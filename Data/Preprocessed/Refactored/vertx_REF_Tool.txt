package io . vertx . test . core ; import io . netty . channel . EventLoopGroup ; import org . junit . Test ; public class EventLoopGroupTest extends VertxTestBase { @ Test public void testGetEventLoopGroup ( ) { EventLoopGroup elp = vertx . nettyEventLoopGroup ( ) ; assertNotNull ( elp ) ; } }
@ Document ( fileName = "override/buffer_from_bytes.adoc" ) package docoverride . buffer ; import io . vertx . docgen . Document ;
package docoverride . buffer ; import io . vertx . core . buffer . Buffer ; import io . vertx . docgen . Source ; @ Source public class Examples { public void example4 ( ) { byte [ ] bytes = new byte [ ] { 1 , 3 , 5 } ; Buffer buff = Buffer . buffer ( bytes ) ; } }
@ Document ( fileName = "override/json.adoc" ) package docoverride . json ; import io . vertx . docgen . Document ;
package docoverride . json ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import io . vertx . docgen . Source ; @ Source public class Examples { public void example0_1 ( ) { String jsonString = "{\"foo\":\"bar\"}" ; JsonObject object = new JsonObject ( jsonString ) ; } public void example0_2 ( ) { String jsonString = "[\"foo\",\"bar\"]" ; JsonArray array = new JsonArray ( jsonString ) ; } public void example1 ( ) { JsonObject object = new JsonObject ( ) ; object . put ( "foo" , "bar" ) . put ( "num" , 123 ) . put ( "mybool" , true ) ; } public void example2 ( JsonObject jsonObject ) { String val = jsonObject . getString ( "some-key" ) ; int intVal = jsonObject . getInteger ( "some-other-key" ) ; } public void example3 ( ) { JsonArray array = new JsonArray ( ) ; array . add ( "foo" ) . add ( 123 ) . add ( false ) ; } public void example4 ( JsonArray array ) { String val = array . getString ( 0 ) ; Integer intVal = array . getInteger ( 1 ) ; Boolean boolVal = array . getBoolean ( 2 ) ; } }
@ Document ( fileName = "override/dependencies.adoc" ) package docoverride . dependencies ; import io . vertx . docgen . Document ;
@ Source package examples ; import io . vertx . docgen . Source ;
package examples ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . parsetools . RecordParser ; public class RecordParserExamples { public void example1 ( ) { final RecordParser parser = RecordParser . newDelimited ( "\n" , h - > { System . out . println ( h . toString ( ) ) ; } ) ; parser . handle ( Buffer . buffer ( "HELLO\nHOW ARE Y" ) ) ; parser . handle ( Buffer . buffer ( "OU?\nI AM" ) ) ; parser . handle ( Buffer . buffer ( "DOING OK" ) ) ; parser . handle ( Buffer . buffer ( "\n" ) ) ; } public void example2 ( ) { RecordParser . newFixed ( 4 , h - > { System . out . println ( h . toString ( ) ) ; } ) ; } }
package examples ; import io . vertx . core . Vertx ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . file . AsyncFile ; import io . vertx . core . file . FileSystem ; import io . vertx . core . file . OpenOptions ; import io . vertx . core . streams . Pump ; public class FileSystemExamples { public void example1 ( Vertx vertx ) { FileSystem fs = vertx . fileSystem ( ) ; fs . copy ( "foo.txt" , "bar.txt" , res - > { if ( res . succeeded ( ) ) { } else { } } ) ; } public void example2 ( Vertx vertx ) { FileSystem fs = vertx . fileSystem ( ) ; fs . copyBlocking ( "foo.txt" , "bar.txt" ) ; } public void example3 ( FileSystem fileSystem ) { OpenOptions options = new OpenOptions ( ) ; fileSystem . open ( "myfile.txt" , options , res - > { if ( res . succeeded ( ) ) { AsyncFile file = res . result ( ) ; } else { } } ) ; } public void asyncAPIExamples ( ) { Vertx vertx = Vertx . vertx ( ) ; vertx . fileSystem ( ) . readFile ( "target/classes/readme.txt" , result - > { if ( result . succeeded ( ) ) { System . out . println ( result . result ( ) ) ; } else { System . err . println ( "Oh oh ..." + result . cause ( ) ) ; } } ) ; vertx . fileSystem ( ) . copy ( "target/classes/readme.txt" , "target/classes/readme2.txt" , result - > { if ( result . succeeded ( ) ) { System . out . println ( "File copied" ) ; } else { System . err . println ( "Oh oh ..." + result . cause ( ) ) ; } } ) ; vertx . fileSystem ( ) . writeFile ( "target/classes/hello.txt" , Buffer . buffer ( "Hello" ) , result - > { if ( result . succeeded ( ) ) { System . out . println ( "File written" ) ; } else { System . err . println ( "Oh oh ..." + result . cause ( ) ) ; } } ) ; vertx . fileSystem ( ) . exists ( "target/classes/junk.txt" , result - > { if ( result . succeeded ( ) && result . result ( ) ) { vertx . fileSystem ( ) . delete ( "target/classes/junk.txt" , r - > { System . out . println ( "File deleted" ) ; } ) ; } else { System . err . println ( "Oh oh ... - cannot delete the file: " + result . cause ( ) ) ; } } ) ; } public void asyncFileWrite ( ) { Vertx vertx = Vertx . vertx ( ) ; vertx . fileSystem ( ) . open ( "target/classes/hello.txt" , new OpenOptions ( ) , result - > { if ( result . succeeded ( ) ) { AsyncFile file = result . result ( ) ; Buffer buff = Buffer . buffer ( "foo" ) ; for ( int i = 0 ; i < 5 ; i ++ ) { file . write ( buff , buff . length ( ) * i , ar - > { if ( ar . succeeded ( ) ) { System . out . println ( "Written ok!" ) ; } else { System . err . println ( "Failed to write: " + ar . cause ( ) ) ; } } ) ; } } else { System . err . println ( "Cannot open file " + result . cause ( ) ) ; } } ) ; } public void asyncFileRead ( ) { Vertx vertx = Vertx . vertx ( ) ; vertx . fileSystem ( ) . open ( "target/classes/les_miserables.txt" , new OpenOptions ( ) , result - > { if ( result . succeeded ( ) ) { AsyncFile file = result . result ( ) ; Buffer buff = Buffer . buffer ( 1000 ) ; for ( int i = 0 ; i < 10 ; i ++ ) { file . read ( buff , i * 100 , i * 100 , 100 , ar - > { if ( ar . succeeded ( ) ) { System . out . println ( "Read ok!" ) ; } else { System . err . println ( "Failed to write: " + ar . cause ( ) ) ; } } ) ; } } else { System . err . println ( "Cannot open file " + result . cause ( ) ) ; } } ) ; } public void asyncFilePump ( ) { Vertx vertx = Vertx . vertx ( ) ; final AsyncFile output = vertx . fileSystem ( ) . openBlocking ( "target/classes/plagiary.txt" , new OpenOptions ( ) ) ; vertx . fileSystem ( ) . open ( "target/classes/les_miserables.txt" , new OpenOptions ( ) , result - > { if ( result . succeeded ( ) ) { AsyncFile file = result . result ( ) ; Pump . pump ( file , output ) . start ( ) ; file . endHandler ( ( r ) - > { System . out . println ( "Copy done" ) ; } ) ; } else { System . err . println ( "Cannot open file " + result . cause ( ) ) ; } } ) ; } }
package examples ; import io . vertx . core . AsyncResult ; import io . vertx . core . AsyncResultHandler ; import io . vertx . core . Handler ; import io . vertx . core . Vertx ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . datagram . DatagramPacket ; import io . vertx . core . datagram . DatagramSocket ; import io . vertx . core . datagram . DatagramSocketOptions ; public class DatagramExamples { public void example1 ( Vertx vertx ) { DatagramSocket socket = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; } public void example2 ( Vertx vertx ) { DatagramSocket socket = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; Buffer buffer = Buffer . buffer ( "content" ) ; socket . send ( buffer , 1234 , "10.0.0.1" , asyncResult - > { System . out . println ( "Send succeeded? " + asyncResult . succeeded ( ) ) ; } ) ; socket . send ( "A string used as content" , 1234 , "10.0.0.1" , asyncResult - > { System . out . println ( "Send succeeded? " + asyncResult . succeeded ( ) ) ; } ) ; } public void example3 ( Vertx vertx ) { DatagramSocket socket = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; socket . listen ( 1234 , "0.0.0.0" , asyncResult - > { if ( asyncResult . succeeded ( ) ) { socket . handler ( packet - > { } ) ; } else { System . out . println ( "Listen failed" + asyncResult . cause ( ) ) ; } } ) ; } public void example4 ( Vertx vertx ) { DatagramSocket socket = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; Buffer buffer = Buffer . buffer ( "content" ) ; socket . send ( buffer , 1234 , "230.0.0.1" , asyncResult - > { System . out . println ( "Send succeeded? " + asyncResult . succeeded ( ) ) ; } ) ; } public void example5 ( Vertx vertx ) { DatagramSocket socket = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; socket . listen ( 1234 , "0.0.0.0" , asyncResult - > { if ( asyncResult . succeeded ( ) ) { socket . handler ( packet - > { } ) ; socket . listenMulticastGroup ( "230.0.0.1" , asyncResult2 - > { System . out . println ( "Listen succeeded? " + asyncResult2 . succeeded ( ) ) ; } ) ; } else { System . out . println ( "Listen failed" + asyncResult . cause ( ) ) ; } } ) ; } public void example6 ( Vertx vertx ) { DatagramSocket socket = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; socket . listen ( 1234 , "0.0.0.0" , asyncResult - > { if ( asyncResult . succeeded ( ) ) { socket . handler ( packet - > { } ) ; socket . listenMulticastGroup ( "230.0.0.1" , asyncResult2 - > { if ( asyncResult2 . succeeded ( ) ) { socket . unlistenMulticastGroup ( "230.0.0.1" , asyncResult3 - > { System . out . println ( "Unlisten succeeded? " + asyncResult3 . succeeded ( ) ) ; } ) ; } else { System . out . println ( "Listen failed" + asyncResult2 . cause ( ) ) ; } } ) ; } else { System . out . println ( "Listen failed" + asyncResult . cause ( ) ) ; } } ) ; } public void example7 ( Vertx vertx ) { DatagramSocket socket = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; socket . blockMulticastGroup ( "230.0.0.1" , "10.0.0.2" , asyncResult - > { System . out . println ( "block succeeded? " + asyncResult . succeeded ( ) ) ; } ) ; } }
package examples ; import io . vertx . core . AbstractVerticle ; public class ConfigurableVerticleExamples extends AbstractVerticle { @ Override public void start ( ) throws Exception { System . out . println ( "Configuration: " + config ( ) . getString ( "name" ) ) ; } }
package io . vertx . test . core ; import org . junit . ComparisonFailure ; import org . junit . Test ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; public class AsyncTestBaseTest extends AsyncTestBase { private ExecutorService executor ; public void setUp ( ) throws Exception { super . setUp ( ) ; disableThreadChecks ( ) ; executor = Executors . newFixedThreadPool ( 10 ) ; } protected void tearDown ( ) throws Exception { executor . shutdownNow ( ) ; super . tearDown ( ) ; } @ Test public void testAssertionFailedFromOtherThread ( ) { executor . execute ( ( ) - > { assertEquals ( "foo" , "bar" ) ; testComplete ( ) ; } ) ; try { await ( ) ; } catch ( ComparisonFailure error ) { assertTrue ( error . getMessage ( ) . startsWith ( "expected:" ) ) ; } } @ Test public void testAssertionFailedFromOtherThreadAwaitBeforeAssertAndTestComplete ( ) { executor . execute ( ( ) - > { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { fail ( e . getMessage ( ) ) ; } assertEquals ( "foo" , "bar" ) ; testComplete ( ) ; } ) ; try { await ( ) ; } catch ( ComparisonFailure error ) { assertTrue ( error . getMessage ( ) . startsWith ( "expected:" ) ) ; } } @ Test public void testAssertionFailedFromOtherThreadForgotToCallAwait ( ) throws Exception { executor . execute ( ( ) - > { assertEquals ( "foo" , "bar" ) ; testComplete ( ) ; } ) ; Thread . sleep ( 500 ) ; try { super . afterAsyncTestBase ( ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { } finally { clearThrown ( ) ; } } @ Test public void testAssertionFailedFromMainThread ( ) { try { assertEquals ( "foo" , "bar" ) ; } catch ( ComparisonFailure error ) { assertTrue ( error . getMessage ( ) . startsWith ( "expected:" ) ) ; } testComplete ( ) ; } @ Test public void testAssertionPassedFromOtherThread ( ) { executor . execute ( ( ) - > { assertEquals ( "foo" , "foo" ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testAssertionPassedFromMainThread ( ) { assertEquals ( "foo" , "foo" ) ; testComplete ( ) ; await ( ) ; } @ Test public void testTimeout ( ) { long timeout = 5000 ; long start = System . currentTimeMillis ( ) ; try { await ( timeout , TimeUnit . MILLISECONDS ) ; } catch ( IllegalStateException error ) { long now = System . currentTimeMillis ( ) ; assertTrue ( error . getMessage ( ) . startsWith ( "Timed out in waiting for test complete" ) ) ; long delay = now - start ; assertTrue ( delay >= timeout ) ; assertTrue ( delay < timeout * 1.5 ) ; } } @ Test public void testFailFromOtherThread ( ) { String msg = "too many aardvarks!" ; executor . execute ( ( ) - > { fail ( msg ) ; testComplete ( ) ; } ) ; try { await ( ) ; } catch ( AssertionError error ) { assertTrue ( error . getMessage ( ) . equals ( msg ) ) ; } } @ Test public void testSuccessfulCompletion ( ) { executor . execute ( ( ) - > { assertEquals ( "foo" , "foo" ) ; assertFalse ( false ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testTestCompleteCalledMultipleTimes ( ) { executor . execute ( ( ) - > { assertEquals ( "foo" , "foo" ) ; testComplete ( ) ; try { testComplete ( ) ; } catch ( IllegalStateException e ) { } } ) ; await ( ) ; } @ Test public void testAwaitCalledMultipleTimes ( ) { executor . execute ( ( ) - > { assertEquals ( "foo" , "foo" ) ; testComplete ( ) ; } ) ; await ( ) ; try { await ( ) ; } catch ( IllegalStateException e ) { } } @ Test public void testNoAssertionsNoTestComplete ( ) { } @ Test public void testNoAssertionsTestComplete ( ) { testComplete ( ) ; } @ Test public void testAssertionOKTestComplete ( ) { assertEquals ( "foo" , "foo" ) ; testComplete ( ) ; } @ Test public void testAssertionFailedFromMainThreadWithNoTestComplete ( ) { try { assertEquals ( "foo" , "bar" ) ; } catch ( AssertionError e ) { testComplete ( ) ; try { super . afterAsyncTestBase ( ) ; } catch ( IllegalStateException e2 ) { fail ( "Should not throw exception" ) ; } finally { clearThrown ( ) ; } } } @ Test public void waitForMultiple ( ) { int toWaitFor = 10 ; waitFor ( 10 ) ; AtomicInteger cnt = new AtomicInteger ( ) ; for ( int i = 0 ; i < toWaitFor ; i ++ ) { executor . execute ( ( ) - > { cnt . incrementAndGet ( ) ; complete ( ) ; } ) ; } await ( ) ; assertEquals ( toWaitFor , cnt . get ( ) ) ; } @ Test public void increaseToWait ( ) { int toWaitFor = 10 ; waitFor ( 3 ) ; complete ( ) ; complete ( ) ; waitForMore ( 9 ) ; AtomicInteger cnt = new AtomicInteger ( ) ; for ( int i = 0 ; i < toWaitFor ; i ++ ) { executor . execute ( ( ) - > { cnt . incrementAndGet ( ) ; complete ( ) ; } ) ; } await ( ) ; assertEquals ( toWaitFor , cnt . get ( ) ) ; } }
package examples ; import io . vertx . core . Vertx ; import io . vertx . core . dns . DnsClient ; import io . vertx . core . dns . MxRecord ; import io . vertx . core . dns . SrvRecord ; import java . util . List ; public class DNSExamples { public void example1 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; } public void example2 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; client . lookup ( "vertx.io" , ar - > { if ( ar . succeeded ( ) ) { System . out . println ( ar . result ( ) ) ; } else { System . out . println ( "Failed to resolve entry" + ar . cause ( ) ) ; } } ) ; } public void example3 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; client . lookup4 ( "vertx.io" , ar - > { if ( ar . succeeded ( ) ) { System . out . println ( ar . result ( ) ) ; } else { System . out . println ( "Failed to resolve entry" + ar . cause ( ) ) ; } } ) ; } public void example4 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; client . lookup6 ( "vertx.io" , ar - > { if ( ar . succeeded ( ) ) { System . out . println ( ar . result ( ) ) ; } else { System . out . println ( "Failed to resolve entry" + ar . cause ( ) ) ; } } ) ; } public void example5 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; client . resolveA ( "vertx.io" , ar - > { if ( ar . succeeded ( ) ) { List < String > records = ar . result ( ) ; for ( String record : records ) { System . out . println ( record ) ; } } else { System . out . println ( "Failed to resolve entry" + ar . cause ( ) ) ; } } ) ; } public void example6 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; client . resolveAAAA ( "vertx.io" , ar - > { if ( ar . succeeded ( ) ) { List < String > records = ar . result ( ) ; for ( String record : records ) { System . out . println ( record ) ; } } else { System . out . println ( "Failed to resolve entry" + ar . cause ( ) ) ; } } ) ; } public void example7 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; client . resolveCNAME ( "vertx.io" , ar - > { if ( ar . succeeded ( ) ) { List < String > records = ar . result ( ) ; for ( String record : records ) { System . out . println ( record ) ; } } else { System . out . println ( "Failed to resolve entry" + ar . cause ( ) ) ; } } ) ; } public void example8 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; client . resolveMX ( "vertx.io" , ar - > { if ( ar . succeeded ( ) ) { List < MxRecord > records = ar . result ( ) ; for ( MxRecord record : records ) { System . out . println ( record ) ; } } else { System . out . println ( "Failed to resolve entry" + ar . cause ( ) ) ; } } ) ; } public void example9 ( MxRecord record ) { record . priority ( ) ; record . name ( ) ; } public void example10 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; client . resolveTXT ( "vertx.io" , ar - > { if ( ar . succeeded ( ) ) { List < String > records = ar . result ( ) ; for ( String record : records ) { System . out . println ( record ) ; } } else { System . out . println ( "Failed to resolve entry" + ar . cause ( ) ) ; } } ) ; } public void example11 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; client . resolveNS ( "vertx.io" , ar - > { if ( ar . succeeded ( ) ) { List < String > records = ar . result ( ) ; for ( String record : records ) { System . out . println ( record ) ; } } else { System . out . println ( "Failed to resolve entry" + ar . cause ( ) ) ; } } ) ; } public void example12 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; client . resolveSRV ( "vertx.io" , ar - > { if ( ar . succeeded ( ) ) { List < SrvRecord > records = ar . result ( ) ; for ( SrvRecord record : records ) { System . out . println ( record ) ; } } else { System . out . println ( "Failed to resolve entry" + ar . cause ( ) ) ; } } ) ; } private static SrvRecord getSrvRecord ( ) { return null ; } public void example13 ( SrvRecord record ) { record . priority ( ) ; record . name ( ) ; record . weight ( ) ; record . port ( ) ; record . protocol ( ) ; record . service ( ) ; record . target ( ) ; } public void example14 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; client . resolvePTR ( "1.0.0.10.in-addr.arpa" , ar - > { if ( ar . succeeded ( ) ) { String record = ar . result ( ) ; System . out . println ( record ) ; } else { System . out . println ( "Failed to resolve entry" + ar . cause ( ) ) ; } } ) ; } public void example15 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; client . reverseLookup ( "10.0.0.1" , ar - > { if ( ar . succeeded ( ) ) { String record = ar . result ( ) ; System . out . println ( record ) ; } else { System . out . println ( "Failed to resolve entry" + ar . cause ( ) ) ; } } ) ; } }
package examples ; import io . vertx . core . * ; import io . vertx . core . http . HttpServer ; import io . vertx . core . http . HttpServerRequest ; import io . vertx . core . http . HttpServerResponse ; import io . vertx . core . json . JsonObject ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import java . util . Arrays ; public class CoreExamples { public void example1 ( ) { Vertx vertx = Vertx . vertx ( ) ; } public void example2 ( ) { Vertx vertx = Vertx . vertx ( new VertxOptions ( ) . setWorkerPoolSize ( 40 ) ) ; } public void example3 ( HttpServerRequest request ) { request . response ( ) . putHeader ( "Content-Type" , "text/plain" ) . write ( "some text" ) . end ( ) ; } public void example4 ( HttpServerRequest request ) { HttpServerResponse response = request . response ( ) ; response . putHeader ( "Content-Type" , "text/plain" ) ; response . write ( "some text" ) ; response . end ( ) ; } public void example5 ( Vertx vertx ) { vertx . setPeriodic ( 1000 , id - > { System . out . println ( "timer fired!" ) ; } ) ; } public void example6 ( HttpServer server ) { server . requestHandler ( request - > { request . response ( ) . end ( "hello world!" ) ; } ) ; } public void example7 ( Vertx vertx ) { vertx . executeBlocking ( future - > { String result = someAPI . blockingMethod ( "hello" ) ; future . complete ( result ) ; } , res - > { System . out . println ( "The result is: " + res . result ( ) ) ; } ) ; } BlockingAPI someAPI = new BlockingAPI ( ) ; class BlockingAPI { String blockingMethod ( String str ) { return str ; } } public void example7_1 ( Vertx vertx ) { DeploymentOptions options = new DeploymentOptions ( ) . setWorker ( true ) ; vertx . deployVerticle ( "com.mycompany.MyOrderProcessorVerticle" , options ) ; } public void example8 ( Vertx vertx ) { Verticle myVerticle = new MyVerticle ( ) ; vertx . deployVerticle ( myVerticle ) ; } class MyVerticle extends AbstractVerticle { @ Override public void start ( ) throws Exception { super . start ( ) ; } } public void example9 ( Vertx vertx ) { vertx . deployVerticle ( "com.mycompany.MyOrderProcessorVerticle" ) ; vertx . deployVerticle ( "verticles/myverticle.js" ) ; vertx . deployVerticle ( "verticles/my_verticle.rb" ) ; } public void example10 ( Vertx vertx ) { vertx . deployVerticle ( "com.mycompany.MyOrderProcessorVerticle" , res - > { if ( res . succeeded ( ) ) { System . out . println ( "Deployment id is: " + res . result ( ) ) ; } else { System . out . println ( "Deployment failed!" ) ; } } ) ; } public void example11 ( Vertx vertx , String deploymentID ) { vertx . undeploy ( deploymentID , res - > { if ( res . succeeded ( ) ) { System . out . println ( "Undeployed ok" ) ; } else { System . out . println ( "Undeploy failed!" ) ; } } ) ; } public void example12 ( Vertx vertx ) { DeploymentOptions options = new DeploymentOptions ( ) . setInstances ( 16 ) ; vertx . deployVerticle ( "com.mycompany.MyOrderProcessorVerticle" , options ) ; } public void example13 ( Vertx vertx ) { JsonObject config = new JsonObject ( ) . put ( "name" , "tim" ) . put ( "directory" , "/blah" ) ; DeploymentOptions options = new DeploymentOptions ( ) . setConfig ( config ) ; vertx . deployVerticle ( "com.mycompany.MyOrderProcessorVerticle" , options ) ; } public void example14 ( Vertx vertx ) { DeploymentOptions options = new DeploymentOptions ( ) . setIsolationGroup ( "mygroup" ) ; options . setIsolatedClasses ( Arrays . asList ( "com.mycompany.myverticle.*" , "com.mycompany.somepkg.SomeClass" , "org.somelibrary.*" ) ) ; vertx . deployVerticle ( "com.mycompany.myverticle.VerticleClass" , options ) ; } public void example15 ( Vertx vertx ) { long timerID = vertx . setTimer ( 1000 , id - > { System . out . println ( "And one second later this is printed" ) ; } ) ; System . out . println ( "First this is printed" ) ; } public void example16 ( Vertx vertx ) { long timerID = vertx . setPeriodic ( 1000 , id - > { System . out . println ( "And every second this is printed" ) ; } ) ; System . out . println ( "First this is printed" ) ; } public void example17 ( Vertx vertx , long timerID ) { vertx . cancelTimer ( timerID ) ; } public void example18 ( String className , Exception exception ) { Logger logger = LoggerFactory . getLogger ( className ) ; logger . info ( "something happened" ) ; logger . error ( "oops!" , exception ) ; } public void retrieveContext ( Vertx vertx ) { Context context = vertx . getOrCreateContext ( ) ; } public void retrieveContextType ( Vertx vertx ) { Context context = vertx . getOrCreateContext ( ) ; if ( context . isEventLoopContext ( ) ) { System . out . println ( "Context attached to Event Loop" ) ; } else if ( context . isWorkerContext ( ) ) { System . out . println ( "Context attached to Worker Thread" ) ; } else if ( context . isMultiThreadedWorkerContext ( ) ) { System . out . println ( "Context attached to Worker Thread - multi threaded worker" ) ; } else if ( ! Context . isOnVertxThread ( ) ) { System . out . println ( "Context not attached to a thread managed by vert.x" ) ; } } public void runInContext ( Vertx vertx ) { vertx . getOrCreateContext ( ) . runOnContext ( ( v ) - > { System . out . println ( "This will be executed asynchronously in the same context" ) ; } ) ; } public void runInContextWithData ( Vertx vertx ) { final Context context = vertx . getOrCreateContext ( ) ; context . put ( "data" , "hello" ) ; context . runOnContext ( ( v ) - > { String hello = context . get ( "data" ) ; } ) ; } public void systemAndEnvProperties ( ) { System . getProperty ( "prop" ) ; System . getenv ( "HOME" ) ; } }
package examples ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Vertx ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . net . * ; import io . vertx . core . shareddata . * ; public class SharedDataExamples { public void example1 ( Vertx vertx ) { SharedData sd = vertx . sharedData ( ) ; LocalMap < String , String > map1 = sd . getLocalMap ( "mymap1" ) ; map1 . put ( "foo" , "bar" ) ; LocalMap < String , Buffer > map2 = sd . getLocalMap ( "mymap2" ) ; map2 . put ( "eek" , Buffer . buffer ( ) . appendInt ( 123 ) ) ; map1 = sd . getLocalMap ( "mymap1" ) ; String val = map1 . get ( "foo" ) ; map2 = sd . getLocalMap ( "mymap2" ) ; Buffer buff = map2 . get ( "eek" ) ; } public void example2 ( Vertx vertx ) { SharedData sd = vertx . sharedData ( ) ; sd . < String , String > getClusterWideMap ( "mymap" , res - > { if ( res . succeeded ( ) ) { AsyncMap < String , String > map = res . result ( ) ; } else { } } ) ; } public void example3 ( AsyncMap < String , String > map ) { map . put ( "foo" , "bar" , resPut - > { if ( resPut . succeeded ( ) ) { } else { } } ) ; } public void example4 ( AsyncMap < String , String > map ) { map . get ( "foo" , resGet - > { if ( resGet . succeeded ( ) ) { Object val = resGet . result ( ) ; } else { } } ) ; } public void example5 ( Vertx vertx , SharedData sd ) { sd . getLock ( "mylock" , res - > { if ( res . succeeded ( ) ) { Lock lock = res . result ( ) ; vertx . setTimer ( 5000 , tid - > lock . release ( ) ) ; } else { } } ) ; } public void example6 ( SharedData sd ) { sd . getLockWithTimeout ( "mylock" , 10000 , res - > { if ( res . succeeded ( ) ) { Lock lock = res . result ( ) ; } else { } } ) ; } public void example7 ( SharedData sd ) { sd . getCounter ( "mycounter" , res - > { if ( res . succeeded ( ) ) { Counter counter = res . result ( ) ; } else { } } ) ; } }
package examples ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Vertx ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . net . * ; public class NetExamples { public void example1 ( Vertx vertx ) { NetServer server = vertx . createNetServer ( ) ; } public void example2 ( Vertx vertx ) { NetServerOptions options = new NetServerOptions ( ) . setPort ( 4321 ) ; NetServer server = vertx . createNetServer ( options ) ; } public void example3 ( Vertx vertx ) { NetServer server = vertx . createNetServer ( ) ; server . listen ( ) ; } public void example4 ( Vertx vertx ) { NetServer server = vertx . createNetServer ( ) ; server . listen ( 1234 , "localhost" ) ; } public void example5 ( Vertx vertx ) { NetServer server = vertx . createNetServer ( ) ; server . listen ( 1234 , "localhost" , res - > { if ( res . succeeded ( ) ) { System . out . println ( "Server is now listening!" ) ; } else { System . out . println ( "Failed to bind!" ) ; } } ) ; } public void example5_1 ( Vertx vertx ) { NetServer server = vertx . createNetServer ( ) ; server . listen ( 0 , "localhost" , res - > { if ( res . succeeded ( ) ) { System . out . println ( "Server is now listening on actual port: " + server . actualPort ( ) ) ; } else { System . out . println ( "Failed to bind!" ) ; } } ) ; } public void example6 ( Vertx vertx ) { NetServer server = vertx . createNetServer ( ) ; server . connectHandler ( socket - > { } ) ; } public void example7 ( Vertx vertx ) { NetServer server = vertx . createNetServer ( ) ; server . connectHandler ( socket - > { socket . handler ( buffer - > { System . out . println ( "I received some bytes: " + buffer . length ( ) ) ; } ) ; } ) ; } public void example8 ( NetSocket socket ) { Buffer buffer = Buffer . buffer ( ) . appendFloat ( 12.34f ) . appendInt ( 123 ) ; socket . write ( buffer ) ; socket . write ( "some data" ) ; socket . write ( "some data" , "UTF-16" ) ; } public void example9 ( NetServer server ) { server . close ( res - > { if ( res . succeeded ( ) ) { System . out . println ( "Server is now closed" ) ; } else { System . out . println ( "close failed" ) ; } } ) ; } public void example9_1 ( NetSocket socket ) { socket . closeHandler ( v - > { System . out . println ( "The socket has been closed" ) ; } ) ; } public void example10 ( NetSocket socket ) { socket . sendFile ( "myfile.dat" ) ; } public void example11 ( Vertx vertx ) { for ( int i = 0 ; i < 10 ; i ++ ) { NetServer server = vertx . createNetServer ( ) ; server . connectHandler ( socket - > { socket . handler ( buffer - > { socket . write ( buffer ) ; } ) ; } ) ; server . listen ( 1234 , "localhost" ) ; } } public void example12 ( Vertx vertx ) { DeploymentOptions options = new DeploymentOptions ( ) . setInstances ( 10 ) ; vertx . deployVerticle ( "com.mycompany.MyVerticle" , options ) ; } public void example13 ( Vertx vertx ) { NetClient client = vertx . createNetClient ( ) ; } public void example14 ( Vertx vertx ) { NetClientOptions options = new NetClientOptions ( ) . setConnectTimeout ( 10000 ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example15 ( Vertx vertx ) { NetClientOptions options = new NetClientOptions ( ) . setConnectTimeout ( 10000 ) ; NetClient client = vertx . createNetClient ( options ) ; client . connect ( 4321 , "localhost" , res - > { if ( res . succeeded ( ) ) { System . out . println ( "Connected!" ) ; NetSocket socket = res . result ( ) ; } else { System . out . println ( "Failed to connect: " + res . cause ( ) . getMessage ( ) ) ; } } ) ; } public void example16 ( Vertx vertx ) { NetClientOptions options = new NetClientOptions ( ) ; options . setReconnectAttempts ( 10 ) . setReconnectInterval ( 500 ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example17 ( Vertx vertx ) { NetServerOptions options = new NetServerOptions ( ) . setSsl ( true ) . setKeyStoreOptions ( new JksOptions ( ) . setPath ( "/path/to/your/server-keystore.jks" ) . setPassword ( "password-of-your-keystore" ) ) ; NetServer server = vertx . createNetServer ( options ) ; } public void example18 ( Vertx vertx ) { Buffer myKeyStoreAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/server-keystore.jks" ) ; JksOptions jksOptions = new JksOptions ( ) . setValue ( myKeyStoreAsABuffer ) . setPassword ( "password-of-your-keystore" ) ; NetServerOptions options = new NetServerOptions ( ) . setSsl ( true ) . setKeyStoreOptions ( jksOptions ) ; NetServer server = vertx . createNetServer ( options ) ; } public void example19 ( Vertx vertx ) { NetServerOptions options = new NetServerOptions ( ) . setSsl ( true ) . setPfxKeyCertOptions ( new PfxOptions ( ) . setPath ( "/path/to/your/server-keystore.pfx" ) . setPassword ( "password-of-your-keystore" ) ) ; NetServer server = vertx . createNetServer ( options ) ; } public void example20 ( Vertx vertx ) { Buffer myKeyStoreAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/server-keystore.pfx" ) ; PfxOptions pfxOptions = new PfxOptions ( ) . setValue ( myKeyStoreAsABuffer ) . setPassword ( "password-of-your-keystore" ) ; NetServerOptions options = new NetServerOptions ( ) . setSsl ( true ) . setPfxKeyCertOptions ( pfxOptions ) ; NetServer server = vertx . createNetServer ( options ) ; } public void example21 ( Vertx vertx ) { NetServerOptions options = new NetServerOptions ( ) . setSsl ( true ) . setPemKeyCertOptions ( new PemKeyCertOptions ( ) . setKeyPath ( "/path/to/your/server-key.pem" ) . setCertPath ( "/path/to/your/server-cert.pem" ) ) ; NetServer server = vertx . createNetServer ( options ) ; } public void example22 ( Vertx vertx ) { Buffer myKeyAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/server-key.pem" ) ; Buffer myCertAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/server-cert.pem" ) ; PemKeyCertOptions pemOptions = new PemKeyCertOptions ( ) . setKeyValue ( myKeyAsABuffer ) . setCertValue ( myCertAsABuffer ) ; NetServerOptions options = new NetServerOptions ( ) . setSsl ( true ) . setPemKeyCertOptions ( pemOptions ) ; NetServer server = vertx . createNetServer ( options ) ; } public void example23 ( Vertx vertx ) { NetServerOptions options = new NetServerOptions ( ) . setSsl ( true ) . setClientAuthRequired ( true ) . setTrustStoreOptions ( new JksOptions ( ) . setPath ( "/path/to/your/truststore.jks" ) . setPassword ( "password-of-your-truststore" ) ) ; NetServer server = vertx . createNetServer ( options ) ; } public void example24 ( Vertx vertx ) { Buffer myTrustStoreAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/truststore.jks" ) ; NetServerOptions options = new NetServerOptions ( ) . setSsl ( true ) . setClientAuthRequired ( true ) . setTrustStoreOptions ( new JksOptions ( ) . setValue ( myTrustStoreAsABuffer ) . setPassword ( "password-of-your-truststore" ) ) ; NetServer server = vertx . createNetServer ( options ) ; } public void example25 ( Vertx vertx ) { NetServerOptions options = new NetServerOptions ( ) . setSsl ( true ) . setClientAuthRequired ( true ) . setPfxTrustOptions ( new PfxOptions ( ) . setPath ( "/path/to/your/truststore.pfx" ) . setPassword ( "password-of-your-truststore" ) ) ; NetServer server = vertx . createNetServer ( options ) ; } public void example26 ( Vertx vertx ) { Buffer myTrustStoreAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/truststore.pfx" ) ; NetServerOptions options = new NetServerOptions ( ) . setSsl ( true ) . setClientAuthRequired ( true ) . setPfxTrustOptions ( new PfxOptions ( ) . setValue ( myTrustStoreAsABuffer ) . setPassword ( "password-of-your-truststore" ) ) ; NetServer server = vertx . createNetServer ( options ) ; } public void example27 ( Vertx vertx ) { NetServerOptions options = new NetServerOptions ( ) . setSsl ( true ) . setClientAuthRequired ( true ) . setPemTrustOptions ( new PemTrustOptions ( ) . addCertPath ( "/path/to/your/server-ca.pem" ) ) ; NetServer server = vertx . createNetServer ( options ) ; } public void example28 ( Vertx vertx ) { Buffer myCaAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/server-ca.pfx" ) ; NetServerOptions options = new NetServerOptions ( ) . setSsl ( true ) . setClientAuthRequired ( true ) . setPemTrustOptions ( new PemTrustOptions ( ) . addCertValue ( myCaAsABuffer ) ) ; NetServer server = vertx . createNetServer ( options ) ; } public void example29 ( Vertx vertx ) { NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setTrustAll ( true ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example30 ( Vertx vertx ) { NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setTrustStoreOptions ( new JksOptions ( ) . setPath ( "/path/to/your/truststore.jks" ) . setPassword ( "password-of-your-truststore" ) ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example31 ( Vertx vertx ) { Buffer myTrustStoreAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/truststore.jks" ) ; NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setTrustStoreOptions ( new JksOptions ( ) . setValue ( myTrustStoreAsABuffer ) . setPassword ( "password-of-your-truststore" ) ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example32 ( Vertx vertx ) { NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setPfxTrustOptions ( new PfxOptions ( ) . setPath ( "/path/to/your/truststore.pfx" ) . setPassword ( "password-of-your-truststore" ) ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example33 ( Vertx vertx ) { Buffer myTrustStoreAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/truststore.pfx" ) ; NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setPfxTrustOptions ( new PfxOptions ( ) . setValue ( myTrustStoreAsABuffer ) . setPassword ( "password-of-your-truststore" ) ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example34 ( Vertx vertx ) { NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setPemTrustOptions ( new PemTrustOptions ( ) . addCertPath ( "/path/to/your/ca-cert.pem" ) ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example35 ( Vertx vertx ) { Buffer myTrustStoreAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/ca-cert.pem" ) ; NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setPemTrustOptions ( new PemTrustOptions ( ) . addCertValue ( myTrustStoreAsABuffer ) ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example36 ( Vertx vertx ) { NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setKeyStoreOptions ( new JksOptions ( ) . setPath ( "/path/to/your/client-keystore.jks" ) . setPassword ( "password-of-your-keystore" ) ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example37 ( Vertx vertx ) { Buffer myKeyStoreAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/client-keystore.jks" ) ; JksOptions jksOptions = new JksOptions ( ) . setValue ( myKeyStoreAsABuffer ) . setPassword ( "password-of-your-keystore" ) ; NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setKeyStoreOptions ( jksOptions ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example38 ( Vertx vertx ) { NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setPfxKeyCertOptions ( new PfxOptions ( ) . setPath ( "/path/to/your/client-keystore.pfx" ) . setPassword ( "password-of-your-keystore" ) ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example39 ( Vertx vertx ) { Buffer myKeyStoreAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/client-keystore.pfx" ) ; PfxOptions pfxOptions = new PfxOptions ( ) . setValue ( myKeyStoreAsABuffer ) . setPassword ( "password-of-your-keystore" ) ; NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setPfxKeyCertOptions ( pfxOptions ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example40 ( Vertx vertx ) { NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setPemKeyCertOptions ( new PemKeyCertOptions ( ) . setKeyPath ( "/path/to/your/client-key.pem" ) . setCertPath ( "/path/to/your/client-cert.pem" ) ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example41 ( Vertx vertx ) { Buffer myKeyAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/client-key.pem" ) ; Buffer myCertAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/client-cert.pem" ) ; PemKeyCertOptions pemOptions = new PemKeyCertOptions ( ) . setKeyValue ( myKeyAsABuffer ) . setCertValue ( myCertAsABuffer ) ; NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setPemKeyCertOptions ( pemOptions ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example42 ( Vertx vertx , JksOptions trustOptions ) { NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setTrustStoreOptions ( trustOptions ) . addCrlPath ( "/path/to/your/crl.pem" ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example43 ( Vertx vertx , JksOptions trustOptions ) { Buffer myCrlAsABuffer = vertx . fileSystem ( ) . readFileBlocking ( "/path/to/your/crl.pem" ) ; NetClientOptions options = new NetClientOptions ( ) . setSsl ( true ) . setTrustStoreOptions ( trustOptions ) . addCrlValue ( myCrlAsABuffer ) ; NetClient client = vertx . createNetClient ( options ) ; } public void example44 ( Vertx vertx , JksOptions keyStoreOptions ) { NetServerOptions options = new NetServerOptions ( ) . setSsl ( true ) . setKeyStoreOptions ( keyStoreOptions ) . addEnabledCipherSuite ( "ECDHE-RSA-AES128-GCM-SHA256" ) . addEnabledCipherSuite ( "ECDHE-ECDSA-AES128-GCM-SHA256" ) . addEnabledCipherSuite ( "ECDHE-RSA-AES256-GCM-SHA384" ) . addEnabledCipherSuite ( "CDHE-ECDSA-AES256-GCM-SHA384" ) ; NetServer server = vertx . createNetServer ( options ) ; } }
package examples ; import io . vertx . core . MultiMap ; import io . vertx . core . Vertx ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . file . AsyncFile ; import io . vertx . core . http . * ; import io . vertx . core . streams . Pump ; public class HTTPExamples { public void example1 ( Vertx vertx ) { HttpServer server = vertx . createHttpServer ( ) ; } public void example2 ( Vertx vertx ) { HttpServerOptions options = new HttpServerOptions ( ) . setMaxWebsocketFrameSize ( 1000000 ) ; HttpServer server = vertx . createHttpServer ( options ) ; } public void example3 ( Vertx vertx ) { HttpServer server = vertx . createHttpServer ( ) ; server . listen ( ) ; } public void example4 ( Vertx vertx ) { HttpServer server = vertx . createHttpServer ( ) ; server . listen ( 8080 , "myhost.com" ) ; } public void example5 ( Vertx vertx ) { HttpServer server = vertx . createHttpServer ( ) ; server . listen ( 8080 , "myhost.com" , res - > { if ( res . succeeded ( ) ) { System . out . println ( "Server is now listening!" ) ; } else { System . out . println ( "Failed to bind!" ) ; } } ) ; } public void example6 ( Vertx vertx ) { HttpServer server = vertx . createHttpServer ( ) ; server . requestHandler ( request - > { } ) ; } public void example7 ( Vertx vertx ) { HttpServer server = vertx . createHttpServer ( ) ; server . requestHandler ( request - > { HttpMethod method = request . method ( ) ; } ) ; } public void example7_1 ( Vertx vertx ) { vertx . createHttpServer ( ) . requestHandler ( request - > { request . response ( ) . end ( "Hello world" ) ; } ) . listen ( 8080 ) ; } public void example8 ( HttpServerRequest request ) { MultiMap headers = request . headers ( ) ; System . out . println ( "User agent is " + headers . get ( "user-agent" ) ) ; System . out . println ( "User agent is " + headers . get ( "User-Agent" ) ) ; } public void example9 ( HttpServerRequest request ) { request . handler ( buffer - > { System . out . println ( "I have received a chunk of the body of length " + buffer . length ( ) ) ; } ) ; } public void example10 ( HttpServerRequest request ) { Buffer totalBuffer = Buffer . buffer ( ) ; request . handler ( buffer - > { System . out . println ( "I have received a chunk of the body of length " + buffer . length ( ) ) ; totalBuffer . appendBuffer ( buffer ) ; } ) ; request . endHandler ( v - > { System . out . println ( "Full body received, length = " + totalBuffer . length ( ) ) ; } ) ; } public void example11 ( HttpServerRequest request ) { request . bodyHandler ( totalBuffer - > { System . out . println ( "Full body received, length = " + totalBuffer . length ( ) ) ; } ) ; } public void example12 ( HttpServer server ) { server . requestHandler ( request - > { request . setExpectMultipart ( true ) ; request . endHandler ( v - > { MultiMap formAttributes = request . formAttributes ( ) ; } ) ; } ) ; } public void example13 ( HttpServer server ) { server . requestHandler ( request - > { request . setExpectMultipart ( true ) ; request . uploadHandler ( upload - > { System . out . println ( "Got a file upload " + upload . name ( ) ) ; } ) ; } ) ; } public void example14 ( HttpServerRequest request ) { request . uploadHandler ( upload - > { upload . handler ( chunk - > { System . out . println ( "Received a chunk of the upload of length " + chunk . length ( ) ) ; } ) ; } ) ; } public void example15 ( HttpServerRequest request ) { request . uploadHandler ( upload - > { upload . streamToFileSystem ( "myuploads_directory/" + upload . filename ( ) ) ; } ) ; } public void example16 ( HttpServerRequest request , Buffer buffer ) { HttpServerResponse response = request . response ( ) ; response . write ( buffer ) ; } public void example17 ( HttpServerRequest request ) { HttpServerResponse response = request . response ( ) ; response . write ( "hello world!" ) ; } public void example18 ( HttpServerRequest request ) { HttpServerResponse response = request . response ( ) ; response . write ( "hello world!" , "UTF-16" ) ; } public void example19 ( HttpServerRequest request ) { HttpServerResponse response = request . response ( ) ; response . write ( "hello world!" ) ; response . end ( ) ; } public void example20 ( HttpServerRequest request ) { HttpServerResponse response = request . response ( ) ; response . end ( "hello world!" ) ; } public void example21 ( HttpServerRequest request ) { HttpServerResponse response = request . response ( ) ; MultiMap headers = response . headers ( ) ; headers . set ( "content-type" , "text/html" ) ; headers . set ( "other-header" , "wibble" ) ; } public void example22 ( HttpServerRequest request ) { HttpServerResponse response = request . response ( ) ; response . putHeader ( "content-type" , "text/html" ) . putHeader ( "other-header" , "wibble" ) ; } public void example23 ( HttpServerRequest request ) { HttpServerResponse response = request . response ( ) ; response . setChunked ( true ) ; } public void example24 ( HttpServerRequest request ) { HttpServerResponse response = request . response ( ) ; response . setChunked ( true ) ; MultiMap trailers = response . trailers ( ) ; trailers . set ( "X-wibble" , "woobble" ) . set ( "X-quux" , "flooble" ) ; } public void example25 ( HttpServerRequest request ) { HttpServerResponse response = request . response ( ) ; response . setChunked ( true ) ; response . putTrailer ( "X-wibble" , "woobble" ) . putTrailer ( "X-quux" , "flooble" ) ; } public void example26 ( Vertx vertx ) { vertx . createHttpServer ( ) . requestHandler ( request - > { String file = "" ; if ( request . path ( ) . equals ( "/" ) ) { file = "index.html" ; } else if ( ! request . path ( ) . contains ( ".." ) ) { file = request . path ( ) ; } request . response ( ) . sendFile ( "web/" + file ) ; } ) . listen ( 8080 ) ; } public void example27 ( Vertx vertx ) { vertx . createHttpServer ( ) . requestHandler ( request - > { HttpServerResponse response = request . response ( ) ; if ( request . method ( ) == HttpMethod . PUT ) { response . setChunked ( true ) ; Pump . pump ( request , response ) . start ( ) ; request . endHandler ( v - > response . end ( ) ) ; } else { response . setStatusCode ( 400 ) . end ( ) ; } } ) . listen ( 8080 ) ; } public void example28 ( Vertx vertx ) { HttpClient client = vertx . createHttpClient ( ) ; } public void example29 ( Vertx vertx ) { HttpClientOptions options = new HttpClientOptions ( ) . setKeepAlive ( false ) ; HttpClient client = vertx . createHttpClient ( options ) ; } public void example30 ( Vertx vertx ) { HttpClientOptions options = new HttpClientOptions ( ) . setDefaultHost ( "wibble.com" ) ; HttpClient client = vertx . createHttpClient ( options ) ; client . getNow ( "/some-uri" , response - > { System . out . println ( "Received response with status code " + response . statusCode ( ) ) ; } ) ; } public void example31 ( Vertx vertx ) { HttpClient client = vertx . createHttpClient ( ) ; client . getNow ( 8080 , "myserver.mycompany.com" , "/some-uri" , response - > { System . out . println ( "Received response with status code " + response . statusCode ( ) ) ; } ) ; client . getNow ( "foo.othercompany.com" , "/other-uri" , response - > { System . out . println ( "Received response with status code " + response . statusCode ( ) ) ; } ) ; } public void example32 ( Vertx vertx ) { HttpClient client = vertx . createHttpClient ( ) ; client . getNow ( "/some-uri" , response - > { System . out . println ( "Received response with status code " + response . statusCode ( ) ) ; } ) ; client . headNow ( "/other-uri" , response - > { System . out . println ( "Received response with status code " + response . statusCode ( ) ) ; } ) ; } public void example33 ( Vertx vertx ) { HttpClient client = vertx . createHttpClient ( ) ; client . request ( HttpMethod . GET , "some-uri" , response - > { System . out . println ( "Received response with status code " + response . statusCode ( ) ) ; } ) . end ( ) ; client . request ( HttpMethod . POST , "foo-uri" , response - > { System . out . println ( "Received response with status code " + response . statusCode ( ) ) ; } ) . end ( "some-data" ) ; } public void example34 ( Vertx vertx , String body ) { HttpClient client = vertx . createHttpClient ( ) ; HttpClientRequest request = client . post ( "some-uri" , response - > { System . out . println ( "Received response with status code " + response . statusCode ( ) ) ; } ) ; request . putHeader ( "content-length" , "1000" ) ; request . putHeader ( "content-type" , "text/plain" ) ; request . write ( body ) ; request . end ( ) ; client . post ( "some-uri" , response - > { System . out . println ( "Received response with status code " + response . statusCode ( ) ) ; } ) . putHeader ( "content-length" , "1000" ) . putHeader ( "content-type" , "text/plain" ) . write ( body ) . end ( ) ; client . post ( "some-uri" , response - > { System . out . println ( "Received response with status code " + response . statusCode ( ) ) ; } ) . putHeader ( "content-type" , "text/plain" ) . end ( body ) ; } public void example35 ( HttpClientRequest request ) { request . write ( "some data" ) ; request . write ( "some other data" , "UTF-16" ) ; Buffer buffer = Buffer . buffer ( ) ; buffer . appendInt ( 123 ) . appendLong ( 245l ) ; request . write ( buffer ) ; } public void example36 ( HttpClientRequest request ) { request . end ( "some simple data" ) ; Buffer buffer = Buffer . buffer ( ) . appendDouble ( 12.34d ) . appendLong ( 432l ) ; request . end ( buffer ) ; } public void example37 ( HttpClientRequest request ) { MultiMap headers = request . headers ( ) ; headers . set ( "content-type" , "application/json" ) . set ( "other-header" , "foo" ) ; } public void example38 ( HttpClientRequest request ) { request . putHeader ( "content-type" , "application/json" ) . putHeader ( "other-header" , "foo" ) ; } public void example39 ( HttpClientRequest request ) { request . end ( ) ; } public void example40 ( HttpClientRequest request ) { request . end ( "some-data" ) ; Buffer buffer = Buffer . buffer ( ) . appendFloat ( 12.3f ) . appendInt ( 321 ) ; request . end ( buffer ) ; } public void example41 ( HttpClientRequest request ) { request . setChunked ( true ) ; for ( int i = 0 ; i < 10 ; i ++ ) { request . write ( "this-is-chunk-" + i ) ; } request . end ( ) ; } public void example42 ( HttpClient client ) { HttpClientRequest request = client . post ( "some-uri" , response - > { System . out . println ( "Received response with status code " + response . statusCode ( ) ) ; } ) ; request . exceptionHandler ( e - > { System . out . println ( "Received exception: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } ) ; } public void statusCodeHandling ( HttpClient client ) { HttpClientRequest request = client . post ( "some-uri" , response - > { if ( response . statusCode ( ) == 200 ) { System . out . println ( "Everything fine" ) ; return ; } if ( response . statusCode ( ) == 500 ) { System . out . println ( "Unexpected behavior on the server side" ) ; return ; } } ) ; request . end ( ) ; } public void example43 ( HttpClient client ) { HttpClientRequest request = client . post ( "some-uri" ) ; request . handler ( response - > { System . out . println ( "Received response with status code " + response . statusCode ( ) ) ; } ) ; } public void example44 ( HttpClientRequest request , AsyncFile file ) { request . setChunked ( true ) ; Pump pump = Pump . pump ( file , request ) ; file . endHandler ( v - > request . end ( ) ) ; pump . start ( ) ; } public void example45 ( HttpClient client ) { client . getNow ( "some-uri" , response - > { System . out . println ( "Status code is " + response . statusCode ( ) ) ; System . out . println ( "Status message is " + response . statusMessage ( ) ) ; } ) ; } public void example46 ( HttpClientResponse response ) { String contentType = response . headers ( ) . get ( "content-type" ) ; String contentLength = response . headers ( ) . get ( "content-lengh" ) ; } public void example47 ( HttpClient client ) { client . getNow ( "some-uri" , response - > { response . handler ( buffer - > { System . out . println ( "Received a part of the response body: " + buffer ) ; } ) ; } ) ; } public void example48 ( HttpClient client ) { client . getNow ( "some-uri" , response - > { Buffer totalBuffer = Buffer . buffer ( ) ; response . handler ( buffer - > { System . out . println ( "Received a part of the response body: " + buffer . length ( ) ) ; totalBuffer . appendBuffer ( buffer ) ; } ) ; response . endHandler ( v - > { System . out . println ( "Total response body length is " + totalBuffer . length ( ) ) ; } ) ; } ) ; } public void example49 ( HttpClient client ) { client . getNow ( "some-uri" , response - > { response . bodyHandler ( totalBuffer - > { System . out . println ( "Total response body length is " + totalBuffer . length ( ) ) ; } ) ; } ) ; } public void example50 ( HttpClient client ) { HttpClientRequest request = client . put ( "some-uri" , response - > { System . out . println ( "Received response with status code " + response . statusCode ( ) ) ; } ) ; request . putHeader ( "Expect" , "100-Continue" ) ; request . continueHandler ( v - > { request . write ( "Some data" ) ; request . write ( "Some more data" ) ; request . end ( ) ; } ) ; } public void example50_1 ( HttpServer httpServer ) { httpServer . requestHandler ( request - > { if ( request . getHeader ( "Expect" ) . equalsIgnoreCase ( "100-Continue" ) ) { boolean accept = true ; if ( accept ) { request . response ( ) . writeContinue ( ) ; request . bodyHandler ( body - > { } ) ; } else { request . response ( ) . setStatusCode ( 405 ) . end ( ) ; } } } ) ; } public void example51 ( HttpServer server ) { server . websocketHandler ( websocket - > { System . out . println ( "Connected!" ) ; } ) ; } public void example52 ( HttpServer server ) { server . websocketHandler ( websocket - > { if ( websocket . path ( ) . equals ( "/myapi" ) ) { websocket . reject ( ) ; } else { } } ) ; } public void example53 ( HttpServer server ) { server . requestHandler ( request - > { if ( request . path ( ) . equals ( "/myapi" ) ) { ServerWebSocket websocket = request . upgrade ( ) ; } else { request . response ( ) . setStatusCode ( 400 ) . end ( ) ; } } ) ; } public void example54 ( HttpClient client ) { client . websocket ( "/some-uri" , websocket - > { System . out . println ( "Connected!" ) ; } ) ; } public void example55 ( WebSocket websocket ) { Buffer buffer = Buffer . buffer ( ) . appendInt ( 123 ) . appendFloat ( 1.23f ) ; websocket . writeBinaryMessage ( buffer ) ; } public void example56 ( WebSocket websocket , Buffer buffer1 , Buffer buffer2 , Buffer buffer3 ) { WebSocketFrame frame1 = WebSocketFrame . binaryFrame ( buffer1 , false ) ; websocket . writeFrame ( frame1 ) ; WebSocketFrame frame2 = WebSocketFrame . continuationFrame ( buffer2 , false ) ; websocket . writeFrame ( frame2 ) ; WebSocketFrame frame3 = WebSocketFrame . continuationFrame ( buffer2 , true ) ; websocket . writeFrame ( frame3 ) ; } public void example56_1 ( WebSocket websocket ) { websocket . writeFinalTextFrame ( "Geronimo!" ) ; Buffer buff = Buffer . buffer ( ) . appendInt ( 12 ) . appendString ( "foo" ) ; websocket . writeFinalBinaryFrame ( buff ) ; } public void example57 ( WebSocket websocket ) { websocket . frameHandler ( frame - > { System . out . println ( "Received a frame of size!" ) ; } ) ; } public void serversharing ( Vertx vertx ) { vertx . createHttpServer ( ) . requestHandler ( request - > { request . response ( ) . end ( "Hello from server " + this ) ; } ) . listen ( 8080 ) ; } public void serversharingclient ( Vertx vertx ) { vertx . setPeriodic ( 100 , ( l ) - > { vertx . createHttpClient ( ) . getNow ( 8080 , "localhost" , "/" , resp - > { resp . bodyHandler ( body - > { System . out . println ( body . toString ( "ISO-8859-1" ) ) ; } ) ; } ) ; } ) ; } }
package examples ; import io . vertx . core . Handler ; import io . vertx . core . Vertx ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . net . NetServer ; import io . vertx . core . net . NetServerOptions ; import io . vertx . core . net . NetSocket ; import io . vertx . core . streams . Pump ; public class StreamsExamples { public void pump1 ( Vertx vertx ) { NetServer server = vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 1234 ) . setHost ( "localhost" ) ) ; server . connectHandler ( sock - > { sock . handler ( buffer - > { sock . write ( buffer ) ; } ) ; } ) . listen ( ) ; } public void pump2 ( Vertx vertx ) { NetServer server = vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 1234 ) . setHost ( "localhost" ) ) ; server . connectHandler ( sock - > { sock . handler ( buffer - > { if ( ! sock . writeQueueFull ( ) ) { sock . write ( buffer ) ; } } ) ; } ) . listen ( ) ; } public void pump3 ( Vertx vertx ) { NetServer server = vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 1234 ) . setHost ( "localhost" ) ) ; server . connectHandler ( sock - > { sock . handler ( buffer - > { sock . write ( buffer ) ; if ( sock . writeQueueFull ( ) ) { sock . pause ( ) ; } } ) ; } ) . listen ( ) ; } public void pump4 ( Vertx vertx ) { NetServer server = vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 1234 ) . setHost ( "localhost" ) ) ; server . connectHandler ( sock - > { sock . handler ( buffer - > { sock . write ( buffer ) ; if ( sock . writeQueueFull ( ) ) { sock . pause ( ) ; sock . drainHandler ( done - > { sock . resume ( ) ; } ) ; } } ) ; } ) . listen ( ) ; } public void pump5 ( Vertx vertx ) { NetServer server = vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 1234 ) . setHost ( "localhost" ) ) ; server . connectHandler ( sock - > { Pump . pump ( sock , sock ) . start ( ) ; } ) . listen ( ) ; } }
package examples ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . net . NetSocket ; public class BufferExamples { public void example1 ( ) { Buffer buff = Buffer . buffer ( ) ; } public void example2 ( ) { Buffer buff = Buffer . buffer ( "some string" ) ; } public void example3 ( ) { Buffer buff = Buffer . buffer ( "some string" , "UTF-16" ) ; } public void example5 ( ) { Buffer buff = Buffer . buffer ( 10000 ) ; } public void example6 ( NetSocket socket ) { Buffer buff = Buffer . buffer ( ) ; buff . appendInt ( 123 ) . appendString ( "hello\n" ) ; socket . write ( buff ) ; } public void example7 ( ) { Buffer buff = Buffer . buffer ( ) ; buff . setInt ( 1000 , 123 ) ; buff . setString ( 0 , "hello" ) ; } public void example8 ( ) { Buffer buff = Buffer . buffer ( ) ; for ( int i = 0 ; i < buff . length ( ) ; i += 4 ) { System . out . println ( "int value at " + i + " is " + buff . getInt ( i ) ) ; } } public void example9 ( ) { Buffer buff = Buffer . buffer ( 128 ) ; int pos = 15 ; buff . setUnsignedByte ( pos , ( short ) 200 ) ; System . out . println ( buff . getUnsignedByte ( pos ) ) ; } }
package examples ; import io . vertx . core . Vertx ; import io . vertx . core . VertxOptions ; import io . vertx . core . eventbus . DeliveryOptions ; import io . vertx . core . eventbus . EventBus ; import io . vertx . core . eventbus . MessageConsumer ; public class EventBusExamples { public void example0_5 ( Vertx vertx ) { EventBus eb = vertx . eventBus ( ) ; } public void example1 ( Vertx vertx ) { EventBus eb = vertx . eventBus ( ) ; eb . consumer ( "news.uk.sport" , message - > { System . out . println ( "I have received a message: " + message . body ( ) ) ; } ) ; } public void example2 ( Vertx vertx ) { EventBus eb = vertx . eventBus ( ) ; MessageConsumer < String > consumer = eb . consumer ( "news.uk.sport" ) ; consumer . handler ( message - > { System . out . println ( "I have received a message: " + message . body ( ) ) ; } ) ; } public void example3 ( MessageConsumer < String > consumer ) { consumer . completionHandler ( res - > { if ( res . succeeded ( ) ) { System . out . println ( "The handler registration has reached all nodes" ) ; } else { System . out . println ( "Registration failed!" ) ; } } ) ; } public void example4 ( MessageConsumer < String > consumer ) { consumer . unregister ( res - > { if ( res . succeeded ( ) ) { System . out . println ( "The handler un-registration has reached all nodes" ) ; } else { System . out . println ( "Un-registration failed!" ) ; } } ) ; } public void example5 ( EventBus eventBus ) { eventBus . publish ( "news.uk.sport" , "Yay! Someone kicked a ball" ) ; } public void example6 ( EventBus eventBus ) { eventBus . send ( "news.uk.sport" , "Yay! Someone kicked a ball" ) ; } public void example8 ( EventBus eventBus ) { MessageConsumer < String > consumer = eventBus . consumer ( "news.uk.sport" ) ; consumer . handler ( message - > { System . out . println ( "I have received a message: " + message . body ( ) ) ; message . reply ( "how interesting!" ) ; } ) ; } public void example9 ( EventBus eventBus ) { eventBus . send ( "news.uk.sport" , "Yay! Someone kicked a ball across a patch of grass" , ar - > { if ( ar . succeeded ( ) ) { System . out . println ( "Received reply: " + ar . result ( ) . body ( ) ) ; } } ) ; } public void example12 ( ) { VertxOptions options = new VertxOptions ( ) ; Vertx . clusteredVertx ( options , res - > { if ( res . succeeded ( ) ) { Vertx vertx = res . result ( ) ; EventBus eventBus = vertx . eventBus ( ) ; System . out . println ( "We now have a clustered event bus: " + eventBus ) ; } else { System . out . println ( "Failed: " + res . cause ( ) ) ; } } ) ; } }
package io . vertx . core ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import java . util . ArrayList ; import java . util . List ; @ DataObject public class DeploymentOptions { public static final boolean DEFAULT_WORKER = false ; public static final boolean DEFAULT_MULTI_THREADED = false ; public static final String DEFAULT_ISOLATION_GROUP = null ; public static final boolean DEFAULT_HA = false ; public static final int DEFAULT_INSTANCES = 1 ; private JsonObject config ; private boolean worker ; private boolean multiThreaded ; private String isolationGroup ; private boolean ha ; private List < String > extraClasspath ; private int instances ; private List < String > isolatedClasses ; public DeploymentOptions ( ) { this . worker = DEFAULT_WORKER ; this . config = null ; this . multiThreaded = DEFAULT_MULTI_THREADED ; this . isolationGroup = DEFAULT_ISOLATION_GROUP ; this . ha = DEFAULT_HA ; this . instances = DEFAULT_INSTANCES ; } public DeploymentOptions ( DeploymentOptions other ) { this . config = other . getConfig ( ) == null ? null : other . getConfig ( ) . copy ( ) ; this . worker = other . isWorker ( ) ; this . multiThreaded = other . isMultiThreaded ( ) ; this . isolationGroup = other . getIsolationGroup ( ) ; this . ha = other . isHa ( ) ; this . extraClasspath = other . getExtraClasspath ( ) == null ? null : new ArrayList < > ( other . getExtraClasspath ( ) ) ; this . instances = other . instances ; this . isolatedClasses = other . getIsolatedClasses ( ) == null ? null : new ArrayList < > ( other . getIsolatedClasses ( ) ) ; } public DeploymentOptions ( JsonObject json ) { fromJson ( json ) ; } public void fromJson ( JsonObject json ) { this . config = json . getJsonObject ( "config" ) ; this . worker = json . getBoolean ( "worker" , DEFAULT_WORKER ) ; this . multiThreaded = json . getBoolean ( "multiThreaded" , DEFAULT_MULTI_THREADED ) ; this . isolationGroup = json . getString ( "isolationGroup" , DEFAULT_ISOLATION_GROUP ) ; this . ha = json . getBoolean ( "ha" , DEFAULT_HA ) ; JsonArray arr = json . getJsonArray ( "extraClasspath" , null ) ; if ( arr != null ) { this . extraClasspath = arr . getList ( ) ; } this . instances = json . getInteger ( "instances" , DEFAULT_INSTANCES ) ; JsonArray arrIsolated = json . getJsonArray ( "isolatedClasses" , null ) ; if ( arrIsolated != null ) { this . isolatedClasses = arrIsolated . getList ( ) ; } } public JsonObject getConfig ( ) { return config ; } public DeploymentOptions setConfig ( JsonObject config ) { this . config = config ; return this ; } public boolean isWorker ( ) { return worker ; } public DeploymentOptions setWorker ( boolean worker ) { this . worker = worker ; return this ; } public boolean isMultiThreaded ( ) { return multiThreaded ; } public DeploymentOptions setMultiThreaded ( boolean multiThreaded ) { this . multiThreaded = multiThreaded ; return this ; } public String getIsolationGroup ( ) { return isolationGroup ; } public DeploymentOptions setIsolationGroup ( String isolationGroup ) { this . isolationGroup = isolationGroup ; return this ; } public boolean isHa ( ) { return ha ; } public DeploymentOptions setHa ( boolean ha ) { this . ha = ha ; return this ; } public List < String > getExtraClasspath ( ) { return extraClasspath ; } public DeploymentOptions setExtraClasspath ( List < String > extraClasspath ) { this . extraClasspath = extraClasspath ; return this ; } public int getInstances ( ) { return instances ; } public DeploymentOptions setInstances ( int instances ) { this . instances = instances ; return this ; } public List < String > getIsolatedClasses ( ) { return isolatedClasses ; } public DeploymentOptions setIsolatedClasses ( List < String > isolatedClasses ) { this . isolatedClasses = isolatedClasses ; return this ; } public JsonObject toJson ( ) { JsonObject json = new JsonObject ( ) ; if ( worker ) json . put ( "worker" , true ) ; if ( multiThreaded ) json . put ( "multiThreaded" , true ) ; if ( isolationGroup != null ) json . put ( "isolationGroup" , isolationGroup ) ; if ( ha ) json . put ( "ha" , true ) ; if ( config != null ) json . put ( "config" , config ) ; if ( extraClasspath != null ) json . put ( "extraClasspath" , new JsonArray ( extraClasspath ) ) ; if ( instances != DEFAULT_INSTANCES ) { json . put ( "instances" , instances ) ; } if ( isolatedClasses != null ) json . put ( "isolatedClasses" , new JsonArray ( isolatedClasses ) ) ; return json ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; DeploymentOptions that = ( DeploymentOptions ) o ; if ( worker != that . worker ) return false ; if ( multiThreaded != that . multiThreaded ) return false ; if ( ha != that . ha ) return false ; if ( instances != that . instances ) return false ; if ( config != null ? ! config . equals ( that . config ) : that . config != null ) return false ; if ( isolationGroup != null ? ! isolationGroup . equals ( that . isolationGroup ) : that . isolationGroup != null ) return false ; if ( extraClasspath != null ? ! extraClasspath . equals ( that . extraClasspath ) : that . extraClasspath != null ) return false ; return ! ( isolatedClasses != null ? ! isolatedClasses . equals ( that . isolatedClasses ) : that . isolatedClasses != null ) ; } @ Override public int hashCode ( ) { int result = config != null ? config . hashCode ( ) : 0 ; result = 31 * result + ( worker ? 1 : 0 ) ; result = 31 * result + ( multiThreaded ? 1 : 0 ) ; result = 31 * result + ( isolationGroup != null ? isolationGroup . hashCode ( ) : 0 ) ; result = 31 * result + ( ha ? 1 : 0 ) ; result = 31 * result + ( extraClasspath != null ? extraClasspath . hashCode ( ) : 0 ) ; result = 31 * result + instances ; result = 31 * result + ( isolatedClasses != null ? isolatedClasses . hashCode ( ) : 0 ) ; return result ; } }
@ Document ( fileName = "index.adoc" ) @ io . vertx . codegen . annotations . GenModule ( name = "vertx" ) package io . vertx . core ; import io . vertx . docgen . Document ;
package io . vertx . test . core ; import io . vertx . core . json . JsonObject ; import io . vertx . core . metrics . MetricsOptions ; import org . junit . Test ; import java . util . Random ; public class MetricsOptionsTest extends VertxTestBase { @ Test public void testOptions ( ) { MetricsOptions options = new MetricsOptions ( ) ; assertFalse ( options . isEnabled ( ) ) ; assertEquals ( options , options . setEnabled ( true ) ) ; assertTrue ( options . isEnabled ( ) ) ; } @ Test public void testCopyOptions ( ) { MetricsOptions options = new MetricsOptions ( ) ; Random rand = new Random ( ) ; boolean metricsEnabled = rand . nextBoolean ( ) ; options . setEnabled ( metricsEnabled ) ; options = new MetricsOptions ( options ) ; assertEquals ( metricsEnabled , options . isEnabled ( ) ) ; } @ Test public void testJsonOptions ( ) { MetricsOptions options = new MetricsOptions ( new JsonObject ( ) ) ; assertFalse ( options . isEnabled ( ) ) ; Random rand = new Random ( ) ; boolean metricsEnabled = rand . nextBoolean ( ) ; String customValue = TestUtils . randomAlphaString ( 10 ) ; options = new MetricsOptions ( new JsonObject ( ) . put ( "enabled" , metricsEnabled ) . put ( "custom" , customValue ) ) ; assertEquals ( metricsEnabled , options . isEnabled ( ) ) ; assertEquals ( metricsEnabled , options . toJson ( ) . getBoolean ( "enabled" ) ) ; assertEquals ( customValue , options . toJson ( ) . getString ( "custom" ) ) ; } }
package io . vertx . core ; import java . util . ServiceLoader ; public class ServiceHelper { public static < T > T loadFactory ( Class < T > clazz ) { ServiceLoader < T > factories = ServiceLoader . load ( clazz ) ; if ( factories . iterator ( ) . hasNext ( ) ) { return factories . iterator ( ) . next ( ) ; } else { factories = ServiceLoader . load ( clazz , ServiceHelper . class . getClassLoader ( ) ) ; if ( factories . iterator ( ) . hasNext ( ) ) { return factories . iterator ( ) . next ( ) ; } else { throw new IllegalStateException ( "Cannot find META-INF/services/" + clazz . getName ( ) + " on classpath" ) ; } } } }
package io . vertx . core ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . http . CaseInsensitiveHeaders ; import java . util . List ; import java . util . Map ; import java . util . Set ; @ VertxGen public interface MultiMap extends Iterable < Map . Entry < String , String > > { static MultiMap caseInsensitiveMultiMap ( ) { return new CaseInsensitiveHeaders ( ) ; } @ GenIgnore String get ( CharSequence name ) ; String get ( String name ) ; List < String > getAll ( String name ) ; @ GenIgnore List < String > getAll ( CharSequence name ) ; @ GenIgnore List < Map . Entry < String , String > > entries ( ) ; boolean contains ( String name ) ; @ GenIgnore boolean contains ( CharSequence name ) ; boolean isEmpty ( ) ; Set < String > names ( ) ; @ Fluent MultiMap add ( String name , String value ) ; @ GenIgnore MultiMap add ( CharSequence name , CharSequence value ) ; @ GenIgnore MultiMap add ( String name , Iterable < String > values ) ; @ GenIgnore MultiMap add ( CharSequence name , Iterable < CharSequence > values ) ; @ Fluent MultiMap addAll ( MultiMap map ) ; @ GenIgnore MultiMap addAll ( Map < String , String > headers ) ; @ Fluent MultiMap set ( String name , String value ) ; @ GenIgnore MultiMap set ( CharSequence name , CharSequence value ) ; @ GenIgnore MultiMap set ( String name , Iterable < String > values ) ; @ GenIgnore MultiMap set ( CharSequence name , Iterable < CharSequence > values ) ; @ Fluent MultiMap setAll ( MultiMap map ) ; @ GenIgnore MultiMap setAll ( Map < String , String > headers ) ; @ Fluent MultiMap remove ( String name ) ; @ GenIgnore MultiMap remove ( CharSequence name ) ; @ Fluent MultiMap clear ( ) ; int size ( ) ; }
package io . vertx . core ; public interface Verticle { Vertx getVertx ( ) ; void init ( Vertx vertx , Context context ) ; void start ( Future < Void > startFuture ) throws Exception ; void stop ( Future < Void > stopFuture ) throws Exception ; }
package io . vertx . core ; public interface AsyncResultHandler < T > extends Handler < AsyncResult < T > > { }
package io . vertx . core ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . json . JsonObject ; import java . util . List ; @ VertxGen public interface Context { static boolean isOnWorkerThread ( ) { return ContextImpl . isOnWorkerThread ( ) ; } static boolean isOnEventLoopThread ( ) { return ContextImpl . isOnEventLoopThread ( ) ; } static boolean isOnVertxThread ( ) { return ContextImpl . isOnVertxThread ( ) ; } void runOnContext ( Handler < Void > action ) ; String deploymentID ( ) ; JsonObject config ( ) ; List < String > processArgs ( ) ; boolean isEventLoopContext ( ) ; boolean isWorkerContext ( ) ; boolean isMultiThreadedWorkerContext ( ) ; < T > T get ( String key ) ; void put ( String key , Object value ) ; boolean remove ( String key ) ; Vertx owner ( ) ; int getInstanceCount ( ) ; }
package io . vertx . core ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . json . JsonObject ; import io . vertx . core . metrics . MetricsOptions ; import io . vertx . core . spi . cluster . ClusterManager ; import java . util . Objects ; @ DataObject public class VertxOptions { public static final int DEFAULT_EVENT_LOOP_POOL_SIZE = 2 * Runtime . getRuntime ( ) . availableProcessors ( ) ; public static final int DEFAULT_WORKER_POOL_SIZE = 20 ; public static final int DEFAULT_INTERNAL_BLOCKING_POOL_SIZE = 20 ; public static final boolean DEFAULT_CLUSTERED = false ; public static final String DEFAULT_CLUSTER_HOST = "localhost" ; public static final int DEFAULT_CLUSTER_PORT = 0 ; public static final long DEFAULT_CLUSTER_PING_INTERVAL = 20000 ; public static final long DEFAULT_CLUSTER_PING_REPLY_INTERVAL = 20000 ; public static final long DEFAULT_BLOCKED_THREAD_CHECK_INTERVAL = 1000 ; public static final long DEFAULT_MAX_EVENT_LOOP_EXECUTE_TIME = 2l * 1000 * 1000000 ; public static final long DEFAULT_MAX_WORKER_EXECUTE_TIME = 60l * 1000 * 1000000 ; public static final int DEFAULT_QUORUM_SIZE = 1 ; public static final String DEFAULT_HA_GROUP = "__DEFAULT__" ; public static final boolean DEFAULT_HA_ENABLED = false ; public static final boolean DEFAULT_METRICS_ENABLED = false ; private static final long DEFAULT_WARNING_EXECPTION_TIME = 5l * 1000 * 1000000 ; private int eventLoopPoolSize = DEFAULT_EVENT_LOOP_POOL_SIZE ; private int workerPoolSize = DEFAULT_WORKER_POOL_SIZE ; private int internalBlockingPoolSize = DEFAULT_INTERNAL_BLOCKING_POOL_SIZE ; private boolean clustered = DEFAULT_CLUSTERED ; private String clusterHost = DEFAULT_CLUSTER_HOST ; private int clusterPort = DEFAULT_CLUSTER_PORT ; private long clusterPingInterval = DEFAULT_CLUSTER_PING_INTERVAL ; private long clusterPingReplyInterval = DEFAULT_CLUSTER_PING_REPLY_INTERVAL ; private long blockedThreadCheckInterval = DEFAULT_BLOCKED_THREAD_CHECK_INTERVAL ; private long maxEventLoopExecuteTime = DEFAULT_MAX_EVENT_LOOP_EXECUTE_TIME ; private long maxWorkerExecuteTime = DEFAULT_MAX_WORKER_EXECUTE_TIME ; private ClusterManager clusterManager ; private boolean haEnabled = DEFAULT_HA_ENABLED ; private int quorumSize = DEFAULT_QUORUM_SIZE ; private String haGroup = DEFAULT_HA_GROUP ; private MetricsOptions metrics ; private long warningExceptionTime = DEFAULT_WARNING_EXECPTION_TIME ; public VertxOptions ( ) { } public VertxOptions ( VertxOptions other ) { this . eventLoopPoolSize = other . getEventLoopPoolSize ( ) ; this . workerPoolSize = other . getWorkerPoolSize ( ) ; this . clustered = other . isClustered ( ) ; this . clusterHost = other . getClusterHost ( ) ; this . clusterPort = other . getClusterPort ( ) ; this . clusterPingInterval = other . getClusterPingInterval ( ) ; this . clusterPingReplyInterval = other . getClusterPingReplyInterval ( ) ; this . blockedThreadCheckInterval = other . getBlockedThreadCheckInterval ( ) ; this . maxEventLoopExecuteTime = other . getMaxEventLoopExecuteTime ( ) ; this . maxWorkerExecuteTime = other . getMaxWorkerExecuteTime ( ) ; this . internalBlockingPoolSize = other . getInternalBlockingPoolSize ( ) ; this . clusterManager = other . getClusterManager ( ) ; this . haEnabled = other . isHAEnabled ( ) ; this . quorumSize = other . getQuorumSize ( ) ; this . haGroup = other . getHAGroup ( ) ; this . metrics = other . getMetricsOptions ( ) != null ? new MetricsOptions ( other . getMetricsOptions ( ) ) : null ; this . warningExceptionTime = other . warningExceptionTime ; } public VertxOptions ( JsonObject json ) { this . eventLoopPoolSize = json . getInteger ( "eventLoopPoolSize" , DEFAULT_EVENT_LOOP_POOL_SIZE ) ; this . workerPoolSize = json . getInteger ( "workerPoolSize" , DEFAULT_WORKER_POOL_SIZE ) ; this . clustered = json . getBoolean ( "clustered" , DEFAULT_CLUSTERED ) ; this . clusterHost = json . getString ( "clusterHost" , DEFAULT_CLUSTER_HOST ) ; this . clusterPort = json . getInteger ( "clusterPort" , DEFAULT_CLUSTER_PORT ) ; this . clusterPingInterval = json . getLong ( "clusterPingInterval" , DEFAULT_CLUSTER_PING_INTERVAL ) ; this . clusterPingReplyInterval = json . getLong ( "clusterPingReplyInterval" , DEFAULT_CLUSTER_PING_REPLY_INTERVAL ) ; this . internalBlockingPoolSize = json . getInteger ( "internalBlockingPoolSize" , DEFAULT_INTERNAL_BLOCKING_POOL_SIZE ) ; this . blockedThreadCheckInterval = json . getLong ( "blockedThreadCheckInterval" , DEFAULT_BLOCKED_THREAD_CHECK_INTERVAL ) ; this . maxEventLoopExecuteTime = json . getLong ( "maxEventLoopExecuteTime" , DEFAULT_MAX_EVENT_LOOP_EXECUTE_TIME ) ; this . maxWorkerExecuteTime = json . getLong ( "maxWorkerExecuteTime" , DEFAULT_MAX_WORKER_EXECUTE_TIME ) ; this . haEnabled = json . getBoolean ( "haEnabled" , false ) ; this . quorumSize = json . getInteger ( "quorumSize" , DEFAULT_QUORUM_SIZE ) ; this . haGroup = json . getString ( "haGroup" , DEFAULT_HA_GROUP ) ; JsonObject metricsJson = json . getJsonObject ( "metricsOptions" ) ; this . metrics = metricsJson != null ? new MetricsOptions ( metricsJson ) : null ; this . warningExceptionTime = json . getLong ( "warningExceptionTime" , DEFAULT_WARNING_EXECPTION_TIME ) ; } public int getEventLoopPoolSize ( ) { return eventLoopPoolSize ; } public VertxOptions setEventLoopPoolSize ( int eventLoopPoolSize ) { if ( eventLoopPoolSize < 1 ) { throw new IllegalArgumentException ( "eventLoopPoolSize must be > 0" ) ; } this . eventLoopPoolSize = eventLoopPoolSize ; return this ; } public int getWorkerPoolSize ( ) { return workerPoolSize ; } public VertxOptions setWorkerPoolSize ( int workerPoolSize ) { if ( workerPoolSize < 1 ) { throw new IllegalArgumentException ( "workerPoolSize must be > 0" ) ; } this . workerPoolSize = workerPoolSize ; return this ; } public boolean isClustered ( ) { return clustered ; } public VertxOptions setClustered ( boolean clustered ) { this . clustered = clustered ; return this ; } public String getClusterHost ( ) { return clusterHost ; } public VertxOptions setClusterHost ( String clusterHost ) { this . clusterHost = clusterHost ; return this ; } public int getClusterPort ( ) { return clusterPort ; } public VertxOptions setClusterPort ( int clusterPort ) { if ( clusterPort < 0 || clusterPort > 65535 ) { throw new IllegalArgumentException ( "clusterPort p must be in range 0 <= p <= 65535" ) ; } this . clusterPort = clusterPort ; return this ; } public long getClusterPingInterval ( ) { return clusterPingInterval ; } public VertxOptions setClusterPingInterval ( long clusterPingInterval ) { if ( clusterPingInterval < 1 ) { throw new IllegalArgumentException ( "clusterPingInterval must be greater than 0" ) ; } this . clusterPingInterval = clusterPingInterval ; return this ; } public long getClusterPingReplyInterval ( ) { return clusterPingReplyInterval ; } public VertxOptions setClusterPingReplyInterval ( long clusterPingReplyInterval ) { if ( clusterPingReplyInterval < 1 ) { throw new IllegalArgumentException ( "clusterPingReplyInterval must be greater than 0" ) ; } this . clusterPingReplyInterval = clusterPingReplyInterval ; return this ; } public long getBlockedThreadCheckInterval ( ) { return blockedThreadCheckInterval ; } public VertxOptions setBlockedThreadCheckInterval ( long blockedThreadCheckInterval ) { if ( blockedThreadCheckInterval < 1 ) { throw new IllegalArgumentException ( "blockedThreadCheckInterval must be > 0" ) ; } this . blockedThreadCheckInterval = blockedThreadCheckInterval ; return this ; } public long getMaxEventLoopExecuteTime ( ) { return maxEventLoopExecuteTime ; } public VertxOptions setMaxEventLoopExecuteTime ( long maxEventLoopExecuteTime ) { if ( maxEventLoopExecuteTime < 1 ) { throw new IllegalArgumentException ( "maxEventLoopExecuteTime must be > 0" ) ; } this . maxEventLoopExecuteTime = maxEventLoopExecuteTime ; return this ; } public long getMaxWorkerExecuteTime ( ) { return maxWorkerExecuteTime ; } public VertxOptions setMaxWorkerExecuteTime ( long maxWorkerExecuteTime ) { if ( maxWorkerExecuteTime < 1 ) { throw new IllegalArgumentException ( "maxWorkerpExecuteTime must be > 0" ) ; } this . maxWorkerExecuteTime = maxWorkerExecuteTime ; return this ; } public ClusterManager getClusterManager ( ) { return clusterManager ; } public VertxOptions setClusterManager ( ClusterManager clusterManager ) { this . clusterManager = clusterManager ; return this ; } public int getInternalBlockingPoolSize ( ) { return internalBlockingPoolSize ; } public VertxOptions setInternalBlockingPoolSize ( int internalBlockingPoolSize ) { if ( internalBlockingPoolSize < 1 ) { throw new IllegalArgumentException ( "internalBlockingPoolSize must be > 0" ) ; } this . internalBlockingPoolSize = internalBlockingPoolSize ; return this ; } public boolean isHAEnabled ( ) { return haEnabled ; } public VertxOptions setHAEnabled ( boolean haEnabled ) { this . haEnabled = haEnabled ; return this ; } public int getQuorumSize ( ) { return quorumSize ; } public VertxOptions setQuorumSize ( int quorumSize ) { if ( quorumSize < 1 ) { throw new IllegalArgumentException ( "quorumSize should be >= 1" ) ; } this . quorumSize = quorumSize ; return this ; } public String getHAGroup ( ) { return haGroup ; } public VertxOptions setHAGroup ( String haGroup ) { Objects . requireNonNull ( haGroup , "ha group cannot be null" ) ; this . haGroup = haGroup ; return this ; } public MetricsOptions getMetricsOptions ( ) { return metrics ; } public VertxOptions setMetricsOptions ( MetricsOptions metrics ) { this . metrics = metrics ; return this ; } public long getWarningExceptionTime ( ) { return warningExceptionTime ; } public VertxOptions setWarningExceptionTime ( long warningExceptionTime ) { if ( warningExceptionTime < 1 ) { throw new IllegalArgumentException ( "warningExceptionTime must be > 0" ) ; } this . warningExceptionTime = warningExceptionTime ; return this ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; VertxOptions that = ( VertxOptions ) o ; if ( blockedThreadCheckInterval != that . blockedThreadCheckInterval ) return false ; if ( clusterPort != that . clusterPort ) return false ; if ( clustered != that . clustered ) return false ; if ( eventLoopPoolSize != that . eventLoopPoolSize ) return false ; if ( haEnabled != that . haEnabled ) return false ; if ( internalBlockingPoolSize != that . internalBlockingPoolSize ) return false ; if ( maxEventLoopExecuteTime != that . maxEventLoopExecuteTime ) return false ; if ( maxWorkerExecuteTime != that . maxWorkerExecuteTime ) return false ; if ( quorumSize != that . quorumSize ) return false ; if ( workerPoolSize != that . workerPoolSize ) return false ; if ( clusterHost != null ? ! clusterHost . equals ( that . clusterHost ) : that . clusterHost != null ) return false ; if ( clusterManager != null ? ! clusterManager . equals ( that . clusterManager ) : that . clusterManager != null ) return false ; if ( haGroup != null ? ! haGroup . equals ( that . haGroup ) : that . haGroup != null ) return false ; if ( warningExceptionTime != that . warningExceptionTime ) return false ; return true ; } @ Override public int hashCode ( ) { int result = eventLoopPoolSize ; result = 31 * result + workerPoolSize ; result = 31 * result + internalBlockingPoolSize ; result = 31 * result + ( clustered ? 1 : 0 ) ; result = 31 * result + ( clusterHost != null ? clusterHost . hashCode ( ) : 0 ) ; result = 31 * result + clusterPort ; result = 31 * result + ( int ) ( blockedThreadCheckInterval ^ ( blockedThreadCheckInterval > > > 32 ) ) ; result = 31 * result + ( int ) ( maxEventLoopExecuteTime ^ ( maxEventLoopExecuteTime > > > 32 ) ) ; result = 31 * result + ( int ) ( maxWorkerExecuteTime ^ ( maxWorkerExecuteTime > > > 32 ) ) ; result = 31 * result + ( clusterManager != null ? clusterManager . hashCode ( ) : 0 ) ; result = 31 * result + ( haEnabled ? 1 : 0 ) ; result = 31 * result + quorumSize ; result = 31 * result + ( haGroup != null ? haGroup . hashCode ( ) : 0 ) ; result = 31 * result + ( int ) ( warningExceptionTime ^ ( warningExceptionTime > > > 32 ) ) ; return result ; } }
package io . vertx . core ; public class VertxException extends RuntimeException { public VertxException ( String message ) { super ( message ) ; } public VertxException ( String message , Throwable cause ) { super ( message , cause ) ; } public VertxException ( Throwable cause ) { super ( cause ) ; } }
package io . vertx . core ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . spi . FutureFactory ; @ VertxGen public interface Future < T > extends AsyncResult < T > { static < T > Future < T > future ( ) { return factory . future ( ) ; } static < T > Future < T > succeededFuture ( ) { return factory . completedFuture ( ) ; } static < T > Future < T > succeededFuture ( T result ) { return factory . completedFuture ( result ) ; } @ GenIgnore static < T > Future < T > failedFuture ( Throwable t ) { return factory . completedFuture ( t ) ; } static < T > Future < T > failedFuture ( String failureMessage ) { return factory . completedFuture ( failureMessage , true ) ; } boolean isComplete ( ) ; void setHandler ( Handler < AsyncResult < T > > handler ) ; void complete ( T result ) ; void complete ( ) ; @ GenIgnore void fail ( Throwable throwable ) ; void fail ( String failureMessage ) ; static FutureFactory factory = ServiceHelper . loadFactory ( FutureFactory . class ) ; }
package io . vertx . core ; import io . netty . channel . socket . DatagramPacket ; @ FunctionalInterface public interface Handler < E > { void handle ( E event ) ; void handle ( DatagramPacket packet ) ; }
package io . vertx . core ; import io . netty . channel . EventLoopGroup ; import io . vertx . codegen . annotations . CacheReturn ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . datagram . DatagramSocket ; import io . vertx . core . datagram . DatagramSocketOptions ; import io . vertx . core . dns . DnsClient ; import io . vertx . core . eventbus . EventBus ; import io . vertx . core . file . FileSystem ; import io . vertx . core . http . HttpClient ; import io . vertx . core . http . HttpClientOptions ; import io . vertx . core . http . HttpServer ; import io . vertx . core . http . HttpServerOptions ; import io . vertx . core . metrics . Measured ; import io . vertx . core . net . NetClient ; import io . vertx . core . net . NetClientOptions ; import io . vertx . core . net . NetServer ; import io . vertx . core . net . NetServerOptions ; import io . vertx . core . shareddata . SharedData ; import io . vertx . core . spi . VerticleFactory ; import io . vertx . core . spi . VertxFactory ; import io . vertx . core . streams . ReadStream ; import java . util . Set ; @ VertxGen public interface Vertx extends Measured { static Vertx vertx ( ) { return factory . vertx ( ) ; } static Vertx vertx ( VertxOptions options ) { return factory . vertx ( options ) ; } static void clusteredVertx ( VertxOptions options , Handler < AsyncResult < Vertx > > resultHandler ) { factory . clusteredVertx ( options , resultHandler ) ; } static Context currentContext ( ) { return factory . context ( ) ; } Context getOrCreateContext ( ) ; NetServer createNetServer ( NetServerOptions options ) ; NetServer createNetServer ( ) ; NetClient createNetClient ( NetClientOptions options ) ; NetClient createNetClient ( ) ; HttpServer createHttpServer ( HttpServerOptions options ) ; HttpServer createHttpServer ( ) ; HttpClient createHttpClient ( HttpClientOptions options ) ; HttpClient createHttpClient ( ) ; DatagramSocket createDatagramSocket ( DatagramSocketOptions options ) ; DatagramSocket createDatagramSocket ( ) ; @ CacheReturn FileSystem fileSystem ( ) ; @ CacheReturn EventBus eventBus ( ) ; DnsClient createDnsClient ( int port , String host ) ; @ CacheReturn SharedData sharedData ( ) ; long setTimer ( long delay , Handler < Long > handler ) ; TimeoutStream timerStream ( long delay ) ; long setPeriodic ( long delay , Handler < Long > handler ) ; TimeoutStream periodicStream ( long delay ) ; boolean cancelTimer ( long id ) ; void runOnContext ( Handler < Void > action ) ; void close ( ) ; void close ( Handler < AsyncResult < Void > > completionHandler ) ; @ GenIgnore void deployVerticle ( Verticle verticle ) ; @ GenIgnore void deployVerticle ( Verticle verticle , Handler < AsyncResult < String > > completionHandler ) ; @ GenIgnore void deployVerticle ( Verticle verticle , DeploymentOptions options ) ; @ GenIgnore void deployVerticle ( Verticle verticle , DeploymentOptions options , Handler < AsyncResult < String > > completionHandler ) ; void deployVerticle ( String name ) ; void deployVerticle ( String name , Handler < AsyncResult < String > > completionHandler ) ; void deployVerticle ( String name , DeploymentOptions options ) ; void deployVerticle ( String name , DeploymentOptions options , Handler < AsyncResult < String > > completionHandler ) ; void undeploy ( String deploymentID ) ; void undeploy ( String deploymentID , Handler < AsyncResult < Void > > completionHandler ) ; Set < String > deploymentIDs ( ) ; @ GenIgnore void registerVerticleFactory ( VerticleFactory factory ) ; @ GenIgnore void unregisterVerticleFactory ( VerticleFactory factory ) ; @ GenIgnore Set < VerticleFactory > verticleFactories ( ) ; boolean isClustered ( ) ; < T > void executeBlocking ( Handler < Future < T > > blockingCodeHandler , boolean ordered , Handler < AsyncResult < T > > resultHandler ) ; < T > void executeBlocking ( Handler < Future < T > > blockingCodeHandler , Handler < AsyncResult < T > > resultHandler ) ; @ GenIgnore EventLoopGroup nettyEventLoopGroup ( ) ; static final VertxFactory factory = ServiceHelper . loadFactory ( VertxFactory . class ) ; }
package io . vertx . test . core ; import io . vertx . core . Vertx ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . HttpClient ; import io . vertx . core . http . HttpClientOptions ; import io . vertx . core . http . HttpMethod ; import io . vertx . core . http . HttpServer ; import io . vertx . core . http . HttpServerOptions ; import io . vertx . core . http . HttpServerRequest ; import io . vertx . core . http . HttpServerRequestStream ; import io . vertx . core . http . HttpServerResponse ; import io . vertx . core . net . NetClient ; import io . vertx . core . net . NetClientOptions ; import io . vertx . core . net . NetSocket ; import io . vertx . core . streams . ReadStream ; import org . junit . Test ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; public class HttpRequestStreamTest extends VertxTestBase { private HttpServer server ; private NetClient netClient ; private HttpClient client ; @ Override protected void tearDown ( ) throws Exception { if ( netClient != null ) { netClient . close ( ) ; } if ( client != null ) { client . close ( ) ; } if ( server != null ) { CountDownLatch latch = new CountDownLatch ( 1 ) ; server . close ( ( asyncResult ) - > { assertTrue ( asyncResult . succeeded ( ) ) ; latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; } super . tearDown ( ) ; } @ Test public void testReadStreamPauseResume ( ) { String path = "/some/path" ; this . server = vertx . createHttpServer ( new HttpServerOptions ( ) . setAcceptBacklog ( 10 ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; ReadStream < HttpServerRequest > httpStream = server . requestStream ( ) ; AtomicBoolean paused = new AtomicBoolean ( ) ; httpStream . handler ( req - > { assertFalse ( paused . get ( ) ) ; HttpServerResponse response = req . response ( ) ; response . setStatusCode ( 200 ) . end ( ) ; response . close ( ) ; } ) ; server . listen ( listenAR - > { assertTrue ( listenAR . succeeded ( ) ) ; paused . set ( true ) ; httpStream . pause ( ) ; netClient = vertx . createNetClient ( new NetClientOptions ( ) . setConnectTimeout ( 1000 ) ) ; netClient . connect ( HttpTestBase . DEFAULT_HTTP_PORT , "localhost" , socketAR - > { assertTrue ( socketAR . succeeded ( ) ) ; NetSocket socket = socketAR . result ( ) ; Buffer buffer = Buffer . buffer ( ) ; socket . handler ( buffer : : appendBuffer ) ; socket . closeHandler ( v - > { assertEquals ( 0 , buffer . length ( ) ) ; paused . set ( false ) ; httpStream . resume ( ) ; client = vertx . createHttpClient ( new HttpClientOptions ( ) ) ; client . request ( HttpMethod . GET , HttpTestBase . DEFAULT_HTTP_PORT , "localhost" , path , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; testComplete ( ) ; } ) . end ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testClosingServerClosesRequestStreamEndHandler ( ) { this . server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; ReadStream < HttpServerRequest > stream = server . requestStream ( ) ; AtomicBoolean closed = new AtomicBoolean ( ) ; stream . endHandler ( v - > closed . set ( true ) ) ; stream . handler ( req - > { } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; assertFalse ( closed . get ( ) ) ; server . close ( v - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( closed . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testCloseServerAsynchronously ( ) { this . server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; AtomicInteger done = new AtomicInteger ( ) ; HttpServerRequestStream stream = server . requestStream ( ) ; stream . handler ( req - > { } ) ; ThreadLocal < Object > stack = new ThreadLocal < > ( ) ; stack . set ( true ) ; stream . endHandler ( v - > { assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; assertNull ( stack . get ( ) ) ; if ( done . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ) ; server . listen ( ar - > { assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; assertNull ( stack . get ( ) ) ; ThreadLocal < Object > stack2 = new ThreadLocal < > ( ) ; stack2 . set ( true ) ; server . close ( v - > { assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; assertNull ( stack2 . get ( ) ) ; if ( done . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ) ; stack2 . set ( null ) ; } ) ; await ( ) ; } }
package io . vertx . core ; import io . vertx . core . json . JsonObject ; import java . util . List ; public abstract class AbstractVerticle implements Verticle { protected Vertx vertx ; protected Context context ; @ Override public Vertx getVertx ( ) { return vertx ; } @ Override public void init ( Vertx vertx , Context context ) { this . vertx = vertx ; this . context = context ; } public String deploymentID ( ) { return context . deploymentID ( ) ; } public JsonObject config ( ) { return context . config ( ) ; } public List < String > processArgs ( ) { return context . processArgs ( ) ; } @ Override public void start ( Future < Void > startFuture ) throws Exception { start ( ) ; startFuture . complete ( ) ; } @ Override public void stop ( Future < Void > stopFuture ) throws Exception { stop ( ) ; stopFuture . complete ( ) ; } public void start ( ) throws Exception { } public void stop ( ) throws Exception { } }
package io . vertx . core ; public interface AsyncResult < T > { T result ( ) ; Throwable cause ( ) ; boolean succeeded ( ) ; boolean failed ( ) ; }
package io . vertx . core ; public abstract class VoidHandler implements Handler < Void > { public final void handle ( Void event ) { handle ( ) ; } protected abstract void handle ( ) ; }
package io . vertx . core ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . streams . ReadStream ; @ VertxGen public interface TimeoutStream extends ReadStream < Long > { @ Override TimeoutStream exceptionHandler ( Handler < Throwable > handler ) ; @ Override TimeoutStream handler ( Handler < Long > handler ) ; @ Override TimeoutStream pause ( ) ; @ Override TimeoutStream resume ( ) ; @ Override TimeoutStream endHandler ( Handler < Void > endHandler ) ; void cancel ( ) ; }
package io . vertx . core ; import io . vertx . core . impl . Args ; import io . vertx . core . json . DecodeException ; import io . vertx . core . json . JsonObject ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . metrics . MetricsOptions ; import io . vertx . core . spi . VertxMetricsFactory ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . net . * ; import java . util . * ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; import java . util . jar . Attributes ; import java . util . jar . Manifest ; public class Starter { public static final String VERTX_OPTIONS_PROP_PREFIX = "vertx.options." ; public static final String DEPLOYMENT_OPTIONS_PROP_PREFIX = "vertx.deployment.options." ; public static final String METRICS_OPTIONS_PROP_PREFIX = "vertx.metrics.options." ; private static final String PATH_SEP = System . getProperty ( "path.separator" ) ; private static final Logger log = LoggerFactory . getLogger ( Starter . class ) ; public static List < String > PROCESS_ARGS ; public static void main ( String [ ] sargs ) throws MalformedURLException { Args args = new Args ( sargs ) ; String extraCP = args . map . get ( "-cp" ) ; if ( extraCP != null ) { URL [ ] urls = urlsW ( extraCP ) ; ClassLoader icl = new URLClassLoader ( urls , Starter . class . getClassLoader ( ) ) ; ClassLoader oldTCCL = Thread . currentThread ( ) . getContextClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( icl ) ; try { Class < ? > clazz = icl . loadClass ( Starter . class . getName ( ) ) ; Object instance = clazz . newInstance ( ) ; Method run = clazz . getMethod ( "run" , Args . class , String [ ] . class ) ; run . invoke ( instance , args , sargs ) ; } catch ( Exception e ) { throw new IllegalStateException ( e ) ; } finally { Thread . currentThread ( ) . setContextClassLoader ( oldTCCL ) ; } } else { try { new Starter ( ) . run ( args , sargs ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; } } } private static URL [ ] urlsW ( String extraCP ) throws java . net . MalformedURLException { String [ ] parts = extraCP . split ( PATH_SEP ) ; URL [ ] urls = new URL [ parts . length ] ; urls = urls2 ( parts , urls ) ; return urls ; } private static URL [ ] urls2 ( String [ ] parts , URL [ ] urls ) throws java . net . MalformedURLException { for ( int p = 0 ; p < parts . length ; p ++ ) { urls = urls ( parts , urls , p ) ; } return urls ; } private static URL [ ] urls ( String [ ] parts , URL [ ] urls , int p ) throws MalformedURLException { String part = parts [ p ] ; File file = new File ( part ) ; URL url = file . toURI ( ) . toURL ( ) ; urls [ p ] = url ; return urls ; } public static void runCommandLine ( String commandLine ) { new Starter ( ) . run ( commandLine ) ; } protected Vertx vertx ; protected VertxOptions options ; protected DeploymentOptions deploymentOptions ; protected void run ( String commandLine ) { String [ ] sargs = commandLine . split ( " " ) ; Args args = new Args ( sargs ) ; try { run ( args , sargs ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; } } protected void run ( String [ ] sargs ) { try { run ( new Args ( sargs ) , sargs ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; } } public void run ( Args args , String [ ] sargs ) throws SocketException { PROCESS_ARGS = Collections . unmodifiableList ( Arrays . asList ( sargs ) ) ; if ( sargs . length > 0 ) { String first = sargs [ 0 ] ; if ( first . equals ( "-version" ) ) { log . info ( getVersion ( ) ) ; return ; } else if ( first . equals ( "run" ) ) { if ( sargs . length < 2 ) { displaySyntax ( ) ; return ; } else { String main = sargs [ 1 ] ; runVerticle ( main , args ) ; return ; } } else if ( first . equals ( "-ha" ) ) { runBare ( args ) ; return ; } } String main = readMainVerticleFromManifest ( ) ; if ( main != null ) { runVerticle ( main , args ) ; } else { displaySyntax ( ) ; } } protected void beforeStartingVertx ( VertxOptions options ) { } protected void afterStartingVertx ( ) { } protected void beforeDeployingVerticle ( DeploymentOptions deploymentOptions ) { } protected void handleDeployFailed ( ) { vertx . close ( ) ; } private Vertx startVertx ( boolean clustered , boolean ha , Args args ) throws SocketException { MetricsOptions metricsOptions = metricsOptions ( ) ; configureFromSystemProperties ( metricsOptions , METRICS_OPTIONS_PROP_PREFIX ) ; options = new VertxOptions ( ) . setMetricsOptions ( metricsOptions ) ; configureFromSystemProperties ( options , VERTX_OPTIONS_PROP_PREFIX ) ; if ( clustered ) { log . info ( "Starting clustering..." ) ; int clusterPort = clusterPort ( args ) ; String clusterHost = args . map . get ( "-cluster-host" ) ; if ( clusterHost == null ) { clusterHost = getDefaultAddress ( ) ; if ( clusterHost == null ) { log . error ( "Unable to find a default network interface for clustering. Please specify one using -cluster-host" ) ; return null ; } else { log . info ( "No cluster-host specified so using address " + clusterHost ) ; } } CountDownLatch latch = new CountDownLatch ( 1 ) ; AtomicReference < AsyncResult < Vertx > > result = new AtomicReference < > ( ) ; options ( ha , args , clusterPort , clusterHost ) ; beforeStartingVertx ( options ) ; Vertx . clusteredVertx ( options , ar - > { result . set ( ar ) ; latch . countDown ( ) ; } ) ; try { if ( ! latch . await ( 2 , TimeUnit . MINUTES ) ) { log . error ( "Timed out in starting clustered Vert.x" ) ; return null ; } } catch ( InterruptedException e ) { log . error ( "Thread interrupted in startup" ) ; return null ; } if ( result . get ( ) . failed ( ) ) { log . error ( "Failed to form cluster" ) ; result . get ( ) . cause ( ) . printStackTrace ( ) ; return null ; } vertx = result . get ( ) . result ( ) ; } else { beforeStartingVertx ( options ) ; vertx = Vertx . vertx ( options ) ; } addShutdownHook ( ) ; afterStartingVertx ( ) ; return vertx ; } private int clusterPort ( Args args ) { int clusterPort = args . getInt ( "-cluster-port" ) ; if ( clusterPort == - 1 ) { clusterPort = 0 ; } return clusterPort ; } private MetricsOptions metricsOptions ( ) { MetricsOptions metricsOptions ; ServiceLoader < VertxMetricsFactory > factories = ServiceLoader . load ( VertxMetricsFactory . class ) ; if ( factories . iterator ( ) . hasNext ( ) ) { VertxMetricsFactory factory = factories . iterator ( ) . next ( ) ; metricsOptions = factory . newOptions ( ) ; } else { metricsOptions = new MetricsOptions ( ) ; } return metricsOptions ; } private void options ( boolean ha , Args args , int clusterPort , String clusterHost ) { options . setClusterHost ( clusterHost ) . setClusterPort ( clusterPort ) . setClustered ( true ) ; if ( ha ) { String haGroup = args . map . get ( "-hagroup" ) ; int quorumSize = args . getInt ( "-quorum" ) ; options . setHAEnabled ( true ) ; if ( haGroup != null ) { options . setHAGroup ( haGroup ) ; } if ( quorumSize != - 1 ) { options . setQuorumSize ( quorumSize ) ; } } } private void runBare ( Args args ) { Vertx vertx = vertx ( args ) ; if ( vertx == null ) { return ; } } private Vertx vertx ( Args args ) { Vertx vertx = null ; try { vertx = startVertx ( true , true , args ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; } return vertx ; } private void runVerticle ( String main , Args args ) throws SocketException { boolean ha = args . map . get ( "-ha" ) != null ; boolean clustered = args . map . get ( "-cluster" ) != null || ha ; Vertx vertx = startVertx ( clustered , ha , args ) ; if ( vertx == null ) { return ; } String sinstances = args . map . get ( "-instances" ) ; int instances ; if ( sinstances != null ) { try { instances = Integer . parseInt ( sinstances ) ; if ( instances != - 1 && instances < 1 ) { log . error ( "Invalid number of instances" ) ; displaySyntax ( ) ; return ; } } catch ( NumberFormatException e ) { displaySyntax ( ) ; return ; } } else { instances = 1 ; } deploymentOptions ( args , ha , instances ) ; String confArg = args . map . get ( "-conf" ) ; boolean worker = args . map . get ( "-worker" ) != null ; String message = ( worker ) ? "deploying worker verticle" : "deploying verticle" ; configureFromSystemProperties ( deploymentOptions , DEPLOYMENT_OPTIONS_PROP_PREFIX ) ; beforeDeployingVerticle ( deploymentOptions ) ; vertx . deployVerticle ( main , deploymentOptions , createLoggingHandler ( message , res - > { if ( res . failed ( ) ) { handleDeployFailed ( ) ; } } ) ) ; } private void deploymentOptions ( Args args , boolean ha , int instances ) { JsonObject conf = conf ( args ) ; boolean worker = args . map . get ( "-worker" ) != null ; deploymentOptions = new DeploymentOptions ( ) ; deploymentOptions . setConfig ( conf ) . setWorker ( worker ) . setHa ( ha ) . setInstances ( instances ) ; } private JsonObject conf ( Args args ) { String confArg = args . map . get ( "-conf" ) ; JsonObject conf ; if ( confArg != null ) { Iterator < VertxMetricsFactory > scanner = null ; VertxMetricsFactory sconf = scanner . next ( ) ; conf = new JsonObject ( sconf ) ; } else { conf = null ; } return conf ; } private < T > AsyncResultHandler < T > createLoggingHandler ( final String message , final Handler < AsyncResult < T > > completionHandler ) { return res - > { if ( res . failed ( ) ) { Throwable cause = res . cause ( ) ; if ( cause instanceof VertxException ) { VertxException ve = ( VertxException ) cause ; log . error ( ve . getMessage ( ) ) ; if ( ve . getCause ( ) != null ) { log . error ( ve . getCause ( ) ) ; } } else { log . error ( "Failed in " + message , cause ) ; } } else { log . info ( "Succeeded in " + message ) ; } if ( completionHandler != null ) { completionHandler . handle ( res ) ; } } ; } private void configureFromSystemProperties ( Object options , String prefix ) { Properties props = System . getProperties ( ) ; Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String propName = ( String ) e . nextElement ( ) ; String propVal = props . getProperty ( propName ) ; if ( propName . startsWith ( prefix ) ) { String fieldName = propName . substring ( prefix . length ( ) ) ; Method setter = getSetter ( fieldName , options . getClass ( ) ) ; if ( setter == null ) { log . warn ( "No such property to configure on options: " + options . getClass ( ) . getName ( ) + "." + fieldName ) ; continue ; } Object arg = arg ( propVal , setter ) ; Class < ? > argType = setter . getParameterTypes ( ) [ 0 ] ; try { if ( argType . equals ( String . class ) ) { } else if ( argType . equals ( int . class ) ) { } else if ( argType . equals ( long . class ) ) { } else if ( argType . equals ( boolean . class ) ) { } else { log . warn ( "Invalid type for setter: " + argType ) ; continue ; } } catch ( IllegalArgumentException e2 ) { log . warn ( "Invalid argtype:" + argType + " on options: " + options . getClass ( ) . getName ( ) + "." + fieldName ) ; continue ; } try { setter . invoke ( options , arg ) ; } catch ( Exception ex ) { throw new VertxException ( "Failed to invoke setter: " + setter , ex ) ; } } } } private Object arg ( String propVal , Method setter ) { Class < ? > argType = setter . getParameterTypes ( ) [ 0 ] ; Object arg = null ; if ( argType . equals ( String . class ) ) { arg = propVal ; } else if ( argType . equals ( int . class ) ) { arg = Integer . valueOf ( propVal ) ; } else if ( argType . equals ( long . class ) ) { arg = Long . valueOf ( propVal ) ; } else if ( argType . equals ( boolean . class ) ) { arg = Boolean . valueOf ( propVal ) ; } else { } return arg ; } private Method getSetter ( String fieldName , Class < ? > clazz ) { Method [ ] meths = clazz . getDeclaredMethods ( ) ; for ( Method meth : meths ) { if ( ( "set" + fieldName ) . toLowerCase ( ) . equals ( meth . getName ( ) . toLowerCase ( ) ) ) { return meth ; } } return null ; } private void addShutdownHook ( ) { Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { public void run ( ) { CountDownLatch latch = new CountDownLatch ( 1 ) ; vertx . close ( ar - > { if ( ! ar . succeeded ( ) ) { log . error ( "Failure in stopping Vert.x" , ar . cause ( ) ) ; } latch . countDown ( ) ; } ) ; try { if ( ! latch . await ( 2 , TimeUnit . MINUTES ) ) { log . error ( "Timed out waiting to undeploy all" ) ; } } catch ( InterruptedException e ) { throw new IllegalStateException ( e ) ; } } } ) ; } private String getDefaultAddress ( ) throws SocketException { Enumeration < NetworkInterface > nets = nets ( ) ; NetworkInterface netinf ; while ( nets . hasMoreElements ( ) ) { netinf = nets . nextElement ( ) ; Enumeration < InetAddress > addresses = netinf . getInetAddresses ( ) ; while ( addresses . hasMoreElements ( ) ) { InetAddress address = addresses . nextElement ( ) ; if ( ! address . isAnyLocalAddress ( ) && ! address . isMulticastAddress ( ) && ! ( address instanceof Inet6Address ) ) { return address . getHostAddress ( ) ; } } } return null ; } private Enumeration < NetworkInterface > nets ( ) throws SocketException { Enumeration < NetworkInterface > nets ; nets = NetworkInterface . getNetworkInterfaces ( ) ; return nets ; } public String getVersion ( ) { try ( InputStream is = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( "vertx-version.txt" ) ) { if ( is == null ) { throw new IllegalStateException ( "Cannot find vertx-version.txt on classpath" ) ; } try ( Scanner scanner = new Scanner ( is , "UTF-8" ) . useDelimiter ( "\\A" ) ) { return scanner . hasNext ( ) ? scanner . next ( ) : "" ; } } catch ( IOException e ) { throw new IllegalStateException ( e . getMessage ( ) ) ; } } private String readMainVerticleFromManifest ( ) { try { Enumeration < URL > resources = getClass ( ) . getClassLoader ( ) . getResources ( "META-INF/MANIFEST.MF" ) ; while ( resources . hasMoreElements ( ) ) { Manifest manifest = new Manifest ( resources . nextElement ( ) . openStream ( ) ) ; Attributes attributes = manifest . getMainAttributes ( ) ; String mainClass = attributes . getValue ( "Main-Class" ) ; if ( Starter . class . getName ( ) . equals ( mainClass ) ) { String theMainVerticle = attributes . getValue ( "Main-Verticle" ) ; if ( theMainVerticle != null ) { return theMainVerticle ; } } } } catch ( IOException e ) { throw new IllegalStateException ( e . getMessage ( ) ) ; } return null ; } private void displaySyntax ( ) { String usage = " vertx run <main> [-options] \n" + " runs a verticle called <main> in its own instance of vert.x. \n\n" + " valid options are: \n" + " -conf <config> Specifies configuration that should be provided \n" + " to the verticle. <config> should reference \n" + " either a text file containing a valid JSON \n" + " object which represents the configuration OR \n" + " be a JSON string. \n" + " -instances <instances> specifies how many instances of the verticle \n" + " will be deployed. Defaults to 1 \n" + " -worker if specified then the verticle is a worker \n" + " verticle. \n" + " -cp <classpath> provide an extra classpath to be used for the \n" + " verticle deployment. \n" + " -cluster if specified then the vert.x instance will form \n" + " a cluster with any other vert.x instances on \n" + " the network. \n" + " -cluster-port port to use for cluster communication. \n" + " Default is 0 which means choose a spare \n" + " random port. \n" + " -cluster-host host to bind to for cluster communication. \n" + " If this is not specified vert.x will attempt \n" + " to choose one from the available interfaces. \n" + " -ha if specified the verticle will be deployed as a \n" + " high availability (HA) deployment. \n" + " This means it can fail over to any other nodes \n" + " in the cluster started with the same HA group \n" + " -quorum used in conjunction with -ha this specifies the \n" + " minimum number of nodes in the cluster for any \n" + " HA deploymentIDs to be active. Defaults to 0 \n" + " -hagroup used in conjunction with -ha this specifies the \n" + " HA group this node will join. There can be \n" + " multiple HA groups in a cluster. Nodes will only\n" + " failover to other nodes in the same group. \n" + " Defaults to __DEFAULT__ \n\n" + " vertx -version \n" + " displays the version" ; log . info ( usage ) ; } }
package io . vertx . core . impl ; import io . vertx . core . json . JsonObject ; public interface FailoverCompleteHandler { void handle ( String nodeID , JsonObject haInfo , boolean failed ) ; }
package io . vertx . core . impl ; import io . vertx . core . * ; import io . vertx . core . json . JsonObject ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . spi . VerticleFactory ; import java . io . File ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLClassLoader ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; public class DeploymentManager { private static final Logger log = LoggerFactory . getLogger ( DeploymentManager . class ) ; private final VertxInternal vertx ; private final Map < String , Deployment > deployments = new ConcurrentHashMap < > ( ) ; private final Map < String , ClassLoader > classloaders = new WeakHashMap < > ( ) ; private final Map < String , List < VerticleFactory > > verticleFactories = new ConcurrentHashMap < > ( ) ; private final List < VerticleFactory > defaultFactories = new ArrayList < > ( ) ; public DeploymentManager ( VertxInternal vertx ) { this . vertx = vertx ; loadVerticleFactories ( ) ; } private void loadVerticleFactories ( ) { ServiceLoader < VerticleFactory > factories = ServiceLoader . load ( VerticleFactory . class ) ; for ( VerticleFactory factory : factories ) { registerVerticleFactory ( factory ) ; } VerticleFactory defaultFactory = new JavaVerticleFactory ( ) ; defaultFactory . init ( vertx ) ; defaultFactories . add ( defaultFactory ) ; } private String generateDeploymentID ( ) { return UUID . randomUUID ( ) . toString ( ) ; } public void deployVerticle ( Verticle verticle , DeploymentOptions options , Handler < AsyncResult < String > > completionHandler ) { if ( options . getInstances ( ) != 1 ) { throw new IllegalArgumentException ( "Can't specify > 1 instances for already created verticle" ) ; } if ( options . getExtraClasspath ( ) != null ) { throw new IllegalArgumentException ( "Can't specify extraClasspath for already created verticle" ) ; } if ( options . getIsolationGroup ( ) != null ) { throw new IllegalArgumentException ( "Can't specify isolationGroup for already created verticle" ) ; } if ( options . getIsolatedClasses ( ) != null ) { throw new IllegalArgumentException ( "Can't specify isolatedClasses for already created verticle" ) ; } ContextImpl currentContext = vertx . getOrCreateContext ( ) ; doDeploy ( "java:" + verticle . getClass ( ) . getName ( ) , generateDeploymentID ( ) , options , currentContext , currentContext , completionHandler , getCurrentClassLoader ( ) , verticle ) ; } public void deployVerticle ( String identifier , DeploymentOptions options , Handler < AsyncResult < String > > completionHandler ) { ContextImpl callingContext = vertx . getOrCreateContext ( ) ; ClassLoader cl = getClassLoader ( options , callingContext ) ; doDeployVerticle ( identifier , generateDeploymentID ( ) , options , callingContext , callingContext , cl , completionHandler ) ; } private void doDeployVerticle ( String identifier , String deploymentID , DeploymentOptions options , ContextImpl parentContext , ContextImpl callingContext , ClassLoader cl , Handler < AsyncResult < String > > completionHandler ) { List < VerticleFactory > verticleFactories = resolveFactories ( identifier ) ; Iterator < VerticleFactory > iter = verticleFactories . iterator ( ) ; doDeployVerticle ( iter , null , identifier , deploymentID , options , parentContext , callingContext , cl , completionHandler ) ; } private void doDeployVerticle ( Iterator < VerticleFactory > iter , Throwable prevErr , String identifier , String deploymentID , DeploymentOptions options , ContextImpl parentContext , ContextImpl callingContext , ClassLoader cl , Handler < AsyncResult < String > > completionHandler ) { if ( iter . hasNext ( ) ) { VerticleFactory verticleFactory = iter . next ( ) ; Future < String > fut = Future . future ( ) ; if ( verticleFactory . requiresResolve ( ) ) { try { verticleFactory . resolve ( identifier , options , cl , fut ) ; } catch ( Exception e ) { try { fut . fail ( e ) ; } catch ( Exception ignore ) { } } } else { fut . complete ( identifier ) ; } fut . setHandler ( ar - > { Throwable err ; if ( ar . succeeded ( ) ) { String resolvedName = ar . result ( ) ; if ( ! resolvedName . equals ( identifier ) ) { deployVerticle ( resolvedName , options , completionHandler ) ; return ; } else { Verticle [ ] verticles = new Verticle [ options . getInstances ( ) ] ; try { for ( int i = 0 ; i < options . getInstances ( ) ; i ++ ) { verticles [ i ] = verticleFactory . createVerticle ( identifier , cl ) ; if ( verticles [ i ] == null ) { throw new NullPointerException ( "VerticleFactory::createVerticle returned null" ) ; } } doDeploy ( identifier , deploymentID , options , parentContext , callingContext , completionHandler , cl , verticles ) ; return ; } catch ( Exception e ) { err = e ; } } } else { err = ar . cause ( ) ; } doDeployVerticle ( iter , err , identifier , deploymentID , options , parentContext , callingContext , cl , completionHandler ) ; } ) ; } else { if ( prevErr != null ) { reportFailure ( prevErr , callingContext , completionHandler ) ; } else { } } } private String getSuffix ( int pos , String str ) { if ( pos + 1 >= str . length ( ) ) { throw new IllegalArgumentException ( "Invalid name: " + str ) ; } return str . substring ( pos + 1 ) ; } public void undeployVerticle ( String deploymentID , Handler < AsyncResult < Void > > completionHandler ) { Deployment deployment = deployments . get ( deploymentID ) ; Context currentContext = vertx . getOrCreateContext ( ) ; if ( deployment == null ) { reportFailure ( new IllegalStateException ( "Unknown deployment" ) , currentContext , completionHandler ) ; } else { deployment . undeploy ( completionHandler ) ; } } public Set < String > deployments ( ) { return Collections . unmodifiableSet ( deployments . keySet ( ) ) ; } public Deployment getDeployment ( String deploymentID ) { return deployments . get ( deploymentID ) ; } public void undeployAll ( Handler < AsyncResult < Void > > completionHandler ) { Set < String > deploymentIDs = new HashSet < > ( ) ; for ( Map . Entry < String , Deployment > entry : deployments . entrySet ( ) ) { if ( ! entry . getValue ( ) . isChild ( ) ) { deploymentIDs . add ( entry . getKey ( ) ) ; } } if ( ! deploymentIDs . isEmpty ( ) ) { AtomicInteger count = new AtomicInteger ( 0 ) ; for ( String deploymentID : deploymentIDs ) { undeployVerticle ( deploymentID , ar - > { if ( ar . failed ( ) ) { log . error ( "Undeploy failed" , ar . cause ( ) ) ; } if ( count . incrementAndGet ( ) == deploymentIDs . size ( ) ) { completionHandler . handle ( Future . succeededFuture ( ) ) ; } } ) ; } } else { Context context = vertx . getOrCreateContext ( ) ; context . runOnContext ( v - > completionHandler . handle ( Future . succeededFuture ( ) ) ) ; } } public void registerVerticleFactory ( VerticleFactory factory ) { String prefix = factory . prefix ( ) ; if ( prefix == null ) { throw new IllegalArgumentException ( "factory.prefix() cannot be null" ) ; } List < VerticleFactory > facts = verticleFactories . get ( prefix ) ; if ( facts == null ) { facts = new ArrayList < > ( ) ; verticleFactories . put ( prefix , facts ) ; } if ( facts . contains ( factory ) ) { throw new IllegalArgumentException ( "Factory already registered" ) ; } facts . add ( factory ) ; facts . sort ( ( fact1 , fact2 ) - > fact1 . order ( ) - fact2 . order ( ) ) ; factory . init ( vertx ) ; } public void unregisterVerticleFactory ( VerticleFactory factory ) { String prefix = factory . prefix ( ) ; if ( prefix == null ) { throw new IllegalArgumentException ( "factory.prefix() cannot be null" ) ; } List < VerticleFactory > facts = verticleFactories . get ( prefix ) ; boolean removed = false ; if ( facts != null ) { if ( facts . remove ( factory ) ) { removed = true ; } if ( facts . isEmpty ( ) ) { verticleFactories . remove ( prefix ) ; } } if ( ! removed ) { throw new IllegalArgumentException ( "factory isn't registered" ) ; } } public Set < VerticleFactory > verticleFactories ( ) { Set < VerticleFactory > facts = new HashSet < > ( ) ; for ( List < VerticleFactory > list : verticleFactories . values ( ) ) { facts . addAll ( list ) ; } return facts ; } private List < VerticleFactory > resolveFactories ( String identifier ) { List < VerticleFactory > factoryList = null ; int pos = identifier . indexOf ( ':' ) ; String lookup = null ; if ( pos != - 1 ) { lookup = identifier . substring ( 0 , pos ) ; } else { pos = identifier . lastIndexOf ( '.' ) ; if ( pos != - 1 ) { lookup = getSuffix ( pos , identifier ) ; } else { factoryList = defaultFactories ; } } if ( factoryList == null ) { factoryList = verticleFactories . get ( lookup ) ; if ( factoryList == null ) { factoryList = defaultFactories ; } } return factoryList ; } private ClassLoader getClassLoader ( DeploymentOptions options , ContextImpl parentContext ) { String isolationGroup = options . getIsolationGroup ( ) ; ClassLoader cl ; if ( isolationGroup == null ) { cl = getCurrentClassLoader ( ) ; } else { synchronized ( this ) { cl = classloaders . get ( isolationGroup ) ; if ( cl == null ) { ClassLoader current = getCurrentClassLoader ( ) ; if ( ! ( current instanceof URLClassLoader ) ) { throw new IllegalStateException ( "Current classloader must be URLClassLoader" ) ; } List < URL > urls = new ArrayList < > ( ) ; List < String > extraClasspath = options . getExtraClasspath ( ) ; if ( extraClasspath != null ) { for ( String pathElement : extraClasspath ) { File file = new File ( pathElement ) ; try { URL url = file . toURI ( ) . toURL ( ) ; urls . add ( url ) ; } catch ( MalformedURLException e ) { throw new IllegalStateException ( e ) ; } } } URLClassLoader urlc = ( URLClassLoader ) current ; urls . addAll ( Arrays . asList ( urlc . getURLs ( ) ) ) ; cl = new IsolatingClassLoader ( urls . toArray ( new URL [ urls . size ( ) ] ) , getCurrentClassLoader ( ) , options . getIsolatedClasses ( ) ) ; classloaders . put ( isolationGroup , cl ) ; } } } return cl ; } private ClassLoader getCurrentClassLoader ( ) { ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( cl == null ) { cl = getClass ( ) . getClassLoader ( ) ; } return cl ; } private < T > void reportFailure ( Throwable t , Context context , Handler < AsyncResult < T > > completionHandler ) { if ( completionHandler != null ) { reportResult ( context , completionHandler , Future . failedFuture ( t ) ) ; } else { log . error ( t . getMessage ( ) , t ) ; } } private < T > void reportSuccess ( T result , Context context , Handler < AsyncResult < T > > completionHandler ) { if ( completionHandler != null ) { reportResult ( context , completionHandler , Future . succeededFuture ( result ) ) ; } } private < T > void reportResult ( Context context , Handler < AsyncResult < T > > completionHandler , AsyncResult < T > result ) { context . runOnContext ( v - > { try { completionHandler . handle ( result ) ; } catch ( Throwable t ) { log . error ( "Failure in calling handler" , t ) ; } } ) ; } private void doDeploy ( String identifier , String deploymentID , DeploymentOptions options , ContextImpl parentContext , ContextImpl callingContext , Handler < AsyncResult < String > > completionHandler , ClassLoader tccl , Verticle ... verticles ) { if ( options . isMultiThreaded ( ) && ! options . isWorker ( ) ) { throw new IllegalArgumentException ( "If multi-threaded then must be worker too" ) ; } JsonObject conf = options . getConfig ( ) == null ? new JsonObject ( ) : options . getConfig ( ) . copy ( ) ; Deployment parent = parentContext . getDeployment ( ) ; DeploymentImpl deployment = new DeploymentImpl ( parent , deploymentID , identifier , options ) ; if ( parent != null ) { parent . addChild ( deployment ) ; deployment . child = true ; } AtomicInteger deployCount = new AtomicInteger ( ) ; AtomicBoolean failureReported = new AtomicBoolean ( ) ; for ( Verticle verticle : verticles ) { ContextImpl context = options . isWorker ( ) ? vertx . createWorkerContext ( options . isMultiThreaded ( ) , deploymentID , conf , tccl ) : vertx . createEventLoopContext ( deploymentID , conf , tccl ) ; context . setDeployment ( deployment ) ; deployment . addVerticle ( new VerticleHolder ( verticle , context ) ) ; context . runOnContext ( v - > { try { verticle . init ( vertx , context ) ; Future < Void > startFuture = Future . future ( ) ; verticle . start ( startFuture ) ; startFuture . setHandler ( ar - > { if ( ar . succeeded ( ) ) { vertx . metricsSPI ( ) . verticleDeployed ( verticle ) ; deployments . put ( deploymentID , deployment ) ; if ( deployCount . incrementAndGet ( ) == verticles . length ) { reportSuccess ( deploymentID , callingContext , completionHandler ) ; } } else if ( ! failureReported . get ( ) ) { reportFailure ( ar . cause ( ) , callingContext , completionHandler ) ; } } ) ; } catch ( Throwable t ) { reportFailure ( t , callingContext , completionHandler ) ; } } ) ; } } static class VerticleHolder { final Verticle verticle ; final ContextImpl context ; VerticleHolder ( Verticle verticle , ContextImpl context ) { this . verticle = verticle ; this . context = context ; } } private class DeploymentImpl implements Deployment { private final Deployment parent ; private final String deploymentID ; private final String verticleIdentifier ; private List < VerticleHolder > verticles = new ArrayList < > ( ) ; private final Set < Deployment > children = new ConcurrentHashSet < > ( ) ; private final DeploymentOptions options ; private boolean undeployed ; private volatile boolean child ; private DeploymentImpl ( Deployment parent , String deploymentID , String verticleIdentifier , DeploymentOptions options ) { this . parent = parent ; this . deploymentID = deploymentID ; this . verticleIdentifier = verticleIdentifier ; this . options = options ; } public void addVerticle ( VerticleHolder holder ) { verticles . add ( holder ) ; } @ Override public void undeploy ( Handler < AsyncResult < Void > > completionHandler ) { ContextImpl currentContext = vertx . getOrCreateContext ( ) ; if ( ! undeployed ) { doUndeploy ( currentContext , completionHandler ) ; } else { reportFailure ( new IllegalStateException ( "Already undeployed" ) , currentContext , completionHandler ) ; } } public void doUndeploy ( ContextImpl undeployingContext , Handler < AsyncResult < Void > > completionHandler ) { if ( ! children . isEmpty ( ) ) { final int size = children . size ( ) ; AtomicInteger childCount = new AtomicInteger ( ) ; for ( Deployment childDeployment : new HashSet < > ( children ) ) { childDeployment . doUndeploy ( undeployingContext , ar - > { children . remove ( childDeployment ) ; if ( ar . failed ( ) ) { reportFailure ( ar . cause ( ) , undeployingContext , completionHandler ) ; } else if ( childCount . incrementAndGet ( ) == size ) { doUndeploy ( undeployingContext , completionHandler ) ; } } ) ; } } else { undeployed = true ; AtomicInteger undeployCount = new AtomicInteger ( ) ; for ( VerticleHolder verticleHolder : verticles ) { ContextImpl context = verticleHolder . context ; context . runOnContext ( v - > { Future < Void > stopFuture = Future . future ( ) ; AtomicBoolean failureReported = new AtomicBoolean ( ) ; stopFuture . setHandler ( ar - > { deployments . remove ( deploymentID ) ; vertx . metricsSPI ( ) . verticleUndeployed ( verticleHolder . verticle ) ; context . runCloseHooks ( ar2 - > { if ( ar2 . failed ( ) ) { log . error ( "Failed to run close hook" , ar2 . cause ( ) ) ; } if ( ar . succeeded ( ) && undeployCount . incrementAndGet ( ) == verticles . size ( ) ) { reportSuccess ( null , undeployingContext , completionHandler ) ; } else if ( ar . failed ( ) && ! failureReported . get ( ) ) { failureReported . set ( true ) ; reportFailure ( ar . cause ( ) , undeployingContext , completionHandler ) ; } } ) ; } ) ; try { verticleHolder . verticle . stop ( stopFuture ) ; } catch ( Throwable t ) { stopFuture . fail ( t ) ; } finally { if ( parent != null ) { parent . removeChild ( this ) ; } } } ) ; } } } @ Override public String verticleIdentifier ( ) { return verticleIdentifier ; } @ Override public DeploymentOptions deploymentOptions ( ) { return options ; } @ Override public void addChild ( Deployment deployment ) { children . add ( deployment ) ; } @ Override public void removeChild ( Deployment deployment ) { children . remove ( deployment ) ; } @ Override public Set < Verticle > getVerticles ( ) { Set < Verticle > verts = new HashSet < > ( ) ; for ( VerticleHolder holder : verticles ) { verts . add ( holder . verticle ) ; } return verts ; } @ Override public boolean isChild ( ) { return child ; } @ Override public String deploymentID ( ) { return deploymentID ; } } }
package io . vertx . core . impl ; import io . vertx . core . AsyncResult ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Handler ; import io . vertx . core . Verticle ; import java . util . Set ; public interface Deployment { void addChild ( Deployment deployment ) ; void removeChild ( Deployment deployment ) ; void undeploy ( Handler < AsyncResult < Void > > completionHandler ) ; void doUndeploy ( ContextImpl undeployingContext , Handler < AsyncResult < Void > > completionHandler ) ; String deploymentID ( ) ; String verticleIdentifier ( ) ; DeploymentOptions deploymentOptions ( ) ; Set < Verticle > getVerticles ( ) ; boolean isChild ( ) ; }
package io . vertx . core . impl ; import io . vertx . core . Handler ; import io . vertx . core . json . JsonObject ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import java . util . concurrent . Executor ; public class EventLoopContext extends ContextImpl { private static final Logger log = LoggerFactory . getLogger ( EventLoopContext . class ) ; public EventLoopContext ( VertxInternal vertx , Executor internalBlockingExec , Executor workerExec , String deploymentID , JsonObject config , ClassLoader tccl ) { super ( vertx , internalBlockingExec , workerExec , deploymentID , config , tccl ) ; } public void executeAsync ( Handler < Void > task ) { eventLoop ( ) . execute ( wrapTask ( null , task , true ) ) ; } @ Override public boolean isEventLoopContext ( ) { return true ; } @ Override public boolean isMultiThreadedWorkerContext ( ) { return false ; } @ Override protected void checkCorrectThread ( ) { Thread current = Thread . currentThread ( ) ; if ( ! ( current instanceof VertxThread ) ) { throw new IllegalStateException ( "Expected to be on Vert.x thread, but actually on: " + current ) ; } else if ( contextThread != null && current != contextThread ) { throw new IllegalStateException ( "Event delivered on unexpected thread " + current + " expected: " + contextThread ) ; } } }
package io . vertx . core . impl ; public interface Action < T > { T perform ( ) ; }
package io . vertx . test . core ; import static org . junit . Assert . assertEquals ; import io . vertx . core . json . JsonObject ; import io . vertx . core . net . NetClientOptions ; import org . junit . Test ; public class NetClientOptionsTest { @ Test public final void testEquals ( ) { NetClientOptions options1 = new NetClientOptions ( ) ; NetClientOptions options2 = new NetClientOptions ( new JsonObject ( "{}" ) ) ; assertEquals ( options1 , options2 ) ; } @ Test public final void testAdd ( ) { NetClientOptions options = new NetClientOptions ( new JsonObject ( "{}" ) ) ; options . addEnabledCipherSuite ( "XXX" ) ; } }
package io . vertx . core . impl ; import io . netty . channel . EventLoop ; import io . netty . channel . EventLoopGroup ; import io . vertx . core . * ; import io . vertx . core . json . JsonObject ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . Executor ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; public abstract class ContextImpl implements Context { private static final Logger log = LoggerFactory . getLogger ( ContextImpl . class ) ; private static final String THREAD_CHECKS_PROP_NAME = "vertx.threadChecks" ; private static final String DISABLE_TIMINGS_PROP_NAME = "vertx.disableContextTimings" ; private static final boolean THREAD_CHECKS = Boolean . getBoolean ( THREAD_CHECKS_PROP_NAME ) ; private static final boolean DISABLE_TIMINGS = Boolean . getBoolean ( DISABLE_TIMINGS_PROP_NAME ) ; protected final VertxInternal owner ; protected final String deploymentID ; protected final JsonObject config ; private Deployment deployment ; private Set < Closeable > closeHooks ; private final ClassLoader tccl ; private final EventLoop eventLoop ; protected final Executor orderedInternalPoolExec ; protected final Executor workerExec ; protected VertxThread contextThread ; private volatile boolean closeHooksRun ; private Map < String , Object > contextData ; protected ContextImpl ( VertxInternal vertx , Executor orderedInternalPoolExec , Executor workerExec , String deploymentID , JsonObject config , ClassLoader tccl ) { this . orderedInternalPoolExec = orderedInternalPoolExec ; this . workerExec = workerExec ; this . deploymentID = deploymentID ; this . config = config ; EventLoopGroup group = vertx . getEventLoopGroup ( ) ; if ( group != null ) { this . eventLoop = group . next ( ) ; } else { this . eventLoop = null ; } this . tccl = tccl ; this . owner = vertx ; } public static void setContext ( ContextImpl context ) { Thread current = Thread . currentThread ( ) ; if ( current instanceof VertxThread ) { setContext ( ( VertxThread ) current , context ) ; } else { throw new IllegalStateException ( "Attempt to setContext on non Vert.x thread " + Thread . currentThread ( ) ) ; } } private static void setContext ( VertxThread thread , ContextImpl context ) { thread . setContext ( context ) ; if ( context != null ) { context . setTCCL ( ) ; } else { Thread . currentThread ( ) . setContextClassLoader ( null ) ; } } public void setDeployment ( Deployment deployment ) { this . deployment = deployment ; } public Deployment getDeployment ( ) { return deployment ; } public void addCloseHook ( Closeable hook ) { if ( closeHooks == null ) { closeHooks = new ConcurrentHashSet < > ( ) ; } closeHooks . add ( hook ) ; } public void removeCloseHook ( Closeable hook ) { if ( closeHooks != null ) { closeHooks . remove ( hook ) ; } } public void runCloseHooks ( Handler < AsyncResult < Void > > completionHandler ) { if ( closeHooksRun ) { throw new IllegalStateException ( "Close hooks already run" ) ; } closeHooksRun = true ; if ( closeHooks != null && ! closeHooks . isEmpty ( ) ) { Set < Closeable > copy = new HashSet < > ( closeHooks ) ; int num = copy . size ( ) ; if ( num != 0 ) { AtomicInteger count = new AtomicInteger ( ) ; AtomicBoolean failed = new AtomicBoolean ( ) ; for ( Closeable hook : copy ) { } } else { completionHandler . handle ( Future . succeededFuture ( ) ) ; } } else { completionHandler . handle ( Future . succeededFuture ( ) ) ; } VertxThreadFactory . unsetContext ( this ) ; } protected abstract void executeAsync ( Handler < Void > task ) ; @ Override public abstract boolean isEventLoopContext ( ) ; @ Override public abstract boolean isMultiThreadedWorkerContext ( ) ; @ Override @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key ) { return ( T ) contextData ( ) . get ( key ) ; } @ Override public void put ( String key , Object value ) { contextData ( ) . put ( key , value ) ; } @ Override public boolean remove ( String key ) { return contextData ( ) . remove ( key ) != null ; } @ Override public boolean isWorkerContext ( ) { return ! isEventLoopContext ( ) ; } public static boolean isOnWorkerThread ( ) { return isOnVertxThread ( true ) ; } public static boolean isOnEventLoopThread ( ) { return isOnVertxThread ( false ) ; } public static boolean isOnVertxThread ( ) { Thread t = Thread . currentThread ( ) ; return ( t instanceof VertxThread ) ; } private static boolean isOnVertxThread ( boolean worker ) { Thread t = Thread . currentThread ( ) ; if ( t instanceof VertxThread ) { VertxThread vt = ( VertxThread ) t ; return vt . isWorker ( ) == worker ; } return false ; } public void executeFromIO ( ContextTask task ) { if ( THREAD_CHECKS ) { checkCorrectThread ( ) ; } wrapTask ( task , null , true ) . run ( ) ; } protected abstract void checkCorrectThread ( ) ; public void runOnContext ( Handler < Void > task ) { try { executeAsync ( task ) ; } catch ( RejectedExecutionException ignore ) { } } @ Override public String deploymentID ( ) { return deploymentID ; } @ Override public JsonObject config ( ) { return config ; } @ Override public List < String > processArgs ( ) { return Starter . PROCESS_ARGS ; } public EventLoop eventLoop ( ) { return eventLoop ; } public Vertx owner ( ) { return owner ; } public < T > void executeBlocking ( Action < T > action , Handler < AsyncResult < T > > resultHandler ) { executeBlocking ( action , null , true , true , resultHandler ) ; } public < T > void executeBlocking ( Handler < Future < T > > blockingCodeHandler , boolean ordered , Handler < AsyncResult < T > > resultHandler ) { executeBlocking ( null , blockingCodeHandler , false , ordered , resultHandler ) ; } protected synchronized Map < String , Object > contextData ( ) { if ( contextData == null ) { contextData = new ConcurrentHashMap < > ( ) ; } return contextData ; } private < T > void executeBlocking ( Action < T > action , Handler < Future < T > > blockingCodeHandler , boolean internal , boolean ordered , Handler < AsyncResult < T > > resultHandler ) { try { Executor exec = internal ? orderedInternalPoolExec : ( ordered ? workerExec : owner . getWorkerPool ( ) ) ; exec . execute ( ( ) - > { Future < T > res = Future . future ( ) ; try { if ( blockingCodeHandler != null ) { setContext ( this ) ; blockingCodeHandler . handle ( res ) ; } else { T result = action . perform ( ) ; res . complete ( result ) ; } } catch ( Throwable e ) { res . fail ( e ) ; } } ) ; } catch ( RejectedExecutionException ignore ) { } } protected Runnable wrapTask ( ContextTask cTask , Handler < Void > hTask , boolean checkThread ) { return ( ) - > { VertxThread current = getCurrentThread ( ) ; if ( THREAD_CHECKS && checkThread ) { if ( contextThread == null ) { contextThread = current ; } else if ( contextThread != current && ! contextThread . isWorker ( ) ) { throw new IllegalStateException ( "Uh oh! Event loop context executing with wrong thread! Expected " + contextThread + " got " + current ) ; } } if ( ! DISABLE_TIMINGS ) { current . executeStart ( ) ; } try { setContext ( current , ContextImpl . this ) ; if ( cTask != null ) { cTask . run ( ) ; } else { } } catch ( Throwable t ) { log . error ( "Unhandled exception" , t ) ; } finally { if ( ! DISABLE_TIMINGS ) { current . executeEnd ( ) ; } } } ; } private VertxThread getCurrentThread ( ) { return ( VertxThread ) Thread . currentThread ( ) ; } private void setTCCL ( ) { Thread . currentThread ( ) . setContextClassLoader ( tccl ) ; } public int getInstanceCount ( ) { if ( deployment == null ) { return 0 ; } if ( deployment . deploymentOptions ( ) == null ) { return 1 ; } return deployment . deploymentOptions ( ) . getInstances ( ) ; } public void runOnContext ( Object task ) { } }
package io . vertx . core . impl ; import io . vertx . core . * ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . net . impl . ServerID ; import io . vertx . core . spi . cluster . ClusterManager ; import io . vertx . core . spi . cluster . NodeListener ; import java . util . * ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; public class HAManager { private static final Logger log = LoggerFactory . getLogger ( HAManager . class ) ; private static final String CLUSTER_MAP_NAME = "__vertx.haInfo" ; private static final long QUORUM_CHECK_PERIOD = 1000 ; private final VertxInternal vertx ; private final DeploymentManager deploymentManager ; private final ClusterManager clusterManager ; private final int quorumSize ; private final String group ; private final JsonObject haInfo ; private final Map < String , String > clusterMap ; private final String nodeID ; private final Queue < Runnable > toDeployOnQuorum = new ConcurrentLinkedQueue < > ( ) ; private final boolean enabled ; private long quorumTimerID ; private volatile boolean attainedQuorum ; private volatile FailoverCompleteHandler failoverCompleteHandler ; private volatile FailoverCompleteHandler removeSubsHandler ; private volatile boolean failDuringFailover ; private volatile boolean stopped ; private volatile boolean killed ; public HAManager ( VertxInternal vertx , ServerID serverID , DeploymentManager deploymentManager , ClusterManager clusterManager , int quorumSize , String group , boolean enabled ) { this . vertx = vertx ; this . deploymentManager = deploymentManager ; this . clusterManager = clusterManager ; this . quorumSize = enabled ? quorumSize : 0 ; this . group = enabled ? group : "__DISABLED__" ; this . enabled = enabled ; this . haInfo = new JsonObject ( ) ; haInfo . put ( "verticles" , new JsonArray ( ) ) ; haInfo . put ( "group" , this . group ) ; haInfo . put ( "server_id" , new JsonObject ( ) . put ( "host" , serverID . host ) . put ( "port" , serverID . port ) ) ; this . clusterMap = clusterManager . getSyncMap ( CLUSTER_MAP_NAME ) ; this . nodeID = clusterManager . getNodeID ( ) ; clusterManager . nodeListener ( new NodeListener ( ) { @ Override public void nodeAdded ( String nodeID ) { HAManager . this . nodeAdded ( nodeID ) ; } @ Override public void nodeLeft ( String leftNodeID ) { HAManager . this . nodeLeft ( leftNodeID ) ; } } ) ; clusterMap . put ( nodeID , haInfo . encode ( ) ) ; quorumTimerID = vertx . setPeriodic ( QUORUM_CHECK_PERIOD , tid - > checkHADeployments ( ) ) ; synchronized ( this ) { checkQuorum ( ) ; } } public void removeFromHA ( String depID ) { Deployment dep = deploymentManager . getDeployment ( depID ) ; if ( dep == null || ! dep . deploymentOptions ( ) . isHa ( ) ) { return ; } synchronized ( haInfo ) { JsonArray haMods = haInfo . getJsonArray ( "verticles" ) ; Iterator < Object > iter = haMods . iterator ( ) ; while ( iter . hasNext ( ) ) { Object obj = iter . next ( ) ; JsonObject mod = ( JsonObject ) obj ; if ( mod . getString ( "dep_id" ) . equals ( depID ) ) { iter . remove ( ) ; } } clusterMap . put ( nodeID , haInfo . encode ( ) ) ; } } public void deployVerticle ( final String verticleName , DeploymentOptions deploymentOptions , final Handler < AsyncResult < String > > doneHandler ) { if ( attainedQuorum ) { doDeployVerticle ( verticleName , deploymentOptions , doneHandler ) ; } else { log . info ( "Quorum not attained. Deployment of verticle will be delayed until there's a quorum." ) ; addToHADeployList ( verticleName , deploymentOptions , doneHandler ) ; } } public void stop ( ) { if ( ! stopped ) { if ( clusterManager . isActive ( ) ) { clusterMap . remove ( nodeID ) ; } vertx . cancelTimer ( quorumTimerID ) ; stopped = true ; } } public void simulateKill ( ) { if ( ! stopped ) { killed = true ; clusterManager . leave ( ar - > { if ( ar . failed ( ) ) { log . error ( "Failed to leave cluster" , ar . cause ( ) ) ; } } ) ; vertx . cancelTimer ( quorumTimerID ) ; stopped = true ; } } public void setFailoverCompleteHandler ( FailoverCompleteHandler failoverCompleteHandler ) { this . failoverCompleteHandler = failoverCompleteHandler ; } public void setRemoveSubsHandler ( FailoverCompleteHandler removeSubsHandler ) { this . removeSubsHandler = removeSubsHandler ; } public boolean isKilled ( ) { return killed ; } public boolean isEnabled ( ) { return enabled ; } public void failDuringFailover ( boolean fail ) { failDuringFailover = fail ; } private void doDeployVerticle ( final String verticleName , DeploymentOptions deploymentOptions , final Handler < AsyncResult < String > > doneHandler ) { final Handler < AsyncResult < String > > wrappedHandler = asyncResult - > { if ( asyncResult . succeeded ( ) ) { addToHA ( asyncResult . result ( ) , verticleName , deploymentOptions ) ; } if ( doneHandler != null ) { doneHandler . handle ( asyncResult ) ; } else if ( asyncResult . failed ( ) ) { log . error ( "Failed to deploy verticle" , asyncResult . cause ( ) ) ; } } ; deploymentManager . deployVerticle ( verticleName , deploymentOptions , wrappedHandler ) ; } private synchronized void nodeAdded ( final String nodeID ) { checkQuorumWhenAdded ( nodeID , System . currentTimeMillis ( ) ) ; } private synchronized void nodeLeft ( String leftNodeID ) { checkQuorum ( ) ; if ( attainedQuorum ) { String sclusterInfo = clusterMap . get ( leftNodeID ) ; if ( sclusterInfo == null ) { } else { JsonObject clusterInfo = new JsonObject ( sclusterInfo ) ; checkRemoveSubs ( leftNodeID , clusterInfo ) ; checkFailover ( leftNodeID , clusterInfo ) ; } List < String > nodes = clusterManager . getNodes ( ) ; for ( Map . Entry < String , String > entry : clusterMap . entrySet ( ) ) { if ( ! nodes . contains ( entry . getKey ( ) ) ) { checkFailover ( entry . getKey ( ) , new JsonObject ( entry . getValue ( ) ) ) ; } } } } private synchronized void checkQuorumWhenAdded ( final String nodeID , final long start ) { if ( clusterMap . containsKey ( nodeID ) ) { checkQuorum ( ) ; } else { vertx . setTimer ( 200 , tid - > { vertx . executeBlockingInternal ( ( ) - > { if ( System . currentTimeMillis ( ) - start > 10000 ) { log . warn ( "Timed out waiting for group information to appear" ) ; } else if ( ! stopped ) { ContextImpl context = vertx . getContext ( ) ; try { ContextImpl . setContext ( null ) ; checkQuorumWhenAdded ( nodeID , start ) ; } finally { ContextImpl . setContext ( context ) ; } } return null ; } , null ) ; } ) ; } } private void checkQuorum ( ) { if ( quorumSize == 0 ) { this . attainedQuorum = true ; } else { List < String > nodes = clusterManager . getNodes ( ) ; int count = 0 ; for ( String node : nodes ) { String json = clusterMap . get ( node ) ; if ( json != null ) { JsonObject clusterInfo = new JsonObject ( json ) ; String group = clusterInfo . getString ( "group" ) ; if ( group . equals ( this . group ) ) { count ++ ; } } } boolean attained = count >= quorumSize ; if ( ! attainedQuorum && attained ) { log . info ( "A quorum has been obtained. Any deploymentIDs waiting on a quorum will now be deployed" ) ; this . attainedQuorum = true ; } else if ( attainedQuorum && ! attained ) { log . info ( "There is no longer a quorum. Any HA deploymentIDs will be undeployed until a quorum is re-attained" ) ; this . attainedQuorum = false ; } } } private void addToHA ( String deploymentID , String verticleName , DeploymentOptions deploymentOptions ) { String encoded ; synchronized ( haInfo ) { JsonObject verticleConf = new JsonObject ( ) . put ( "dep_id" , deploymentID ) ; verticleConf . put ( "verticle_name" , verticleName ) ; verticleConf . put ( "options" , deploymentOptions . toJson ( ) ) ; JsonArray haMods = haInfo . getJsonArray ( "verticles" ) ; haMods . add ( verticleConf ) ; encoded = haInfo . encode ( ) ; clusterMap . put ( nodeID , encoded ) ; } } private void addToHADeployList ( final String verticleName , final DeploymentOptions deploymentOptions , final Handler < AsyncResult < String > > doneHandler ) { toDeployOnQuorum . add ( ( ) - > { ContextImpl ctx = vertx . getContext ( ) ; try { ContextImpl . setContext ( null ) ; deployVerticle ( verticleName , deploymentOptions , doneHandler ) ; } finally { ContextImpl . setContext ( ctx ) ; } } ) ; } private void checkHADeployments ( ) { try { if ( attainedQuorum ) { deployHADeployments ( ) ; } else { undeployHADeployments ( ) ; } } catch ( Throwable t ) { log . error ( "Failed when checking HA deploymentIDs" , t ) ; } } private void undeployHADeployments ( ) { for ( String deploymentID : deploymentManager . deployments ( ) ) { Deployment dep = deploymentManager . getDeployment ( deploymentID ) ; if ( dep != null ) { if ( dep . deploymentOptions ( ) . isHa ( ) ) { ContextImpl ctx = vertx . getContext ( ) ; try { ContextImpl . setContext ( null ) ; deploymentManager . undeployVerticle ( deploymentID , new AsyncResultHandler < Void > ( ) { @ Override public void handle ( AsyncResult < Void > result ) { if ( result . succeeded ( ) ) { log . info ( "Successfully undeployed HA deployment " + deploymentID + "-" + dep . verticleIdentifier ( ) + " as there is no quorum" ) ; addToHADeployList ( dep . verticleIdentifier ( ) , dep . deploymentOptions ( ) , new AsyncResultHandler < String > ( ) { @ Override public void handle ( AsyncResult < String > result ) { if ( result . succeeded ( ) ) { log . info ( "Successfully redeployed verticle " + dep . verticleIdentifier ( ) + " after quorum was re-attained" ) ; } else { log . error ( "Failed to redeploy verticle " + dep . verticleIdentifier ( ) + " after quorum was re-attained" , result . cause ( ) ) ; } } } ) ; } else { log . error ( "Failed to undeploy deployment on lost quorum" , result . cause ( ) ) ; } } } ) ; } finally { ContextImpl . setContext ( ctx ) ; } } } } } private void deployHADeployments ( ) { int size = toDeployOnQuorum . size ( ) ; if ( size != 0 ) { log . info ( "There are " + size + " HA deploymentIDs waiting on a quorum. These will now be deployed" ) ; Runnable task ; while ( ( task = toDeployOnQuorum . poll ( ) ) != null ) { try { task . run ( ) ; } catch ( Throwable t ) { log . error ( "Failed to run redeployment task" , t ) ; } } } } private void checkFailover ( String failedNodeID , JsonObject theHAInfo ) { try { JsonArray deployments = theHAInfo . getJsonArray ( "verticles" ) ; String group = theHAInfo . getString ( "group" ) ; String chosen = chooseHashedNode ( group , failedNodeID . hashCode ( ) ) ; if ( chosen != null && chosen . equals ( this . nodeID ) ) { if ( deployments != null && deployments . size ( ) != 0 ) { log . info ( "node" + nodeID + " says: Node " + failedNodeID + " has failed. This node will deploy " + deployments . size ( ) + " deploymentIDs from that node." ) ; for ( Object obj : deployments ) { JsonObject app = ( JsonObject ) obj ; processFailover ( app ) ; } } clusterMap . remove ( failedNodeID ) ; callFailoverCompleteHandler ( failedNodeID , theHAInfo , true ) ; } } catch ( Throwable t ) { log . error ( "Failed to handle failover" , t ) ; callFailoverCompleteHandler ( failedNodeID , theHAInfo , false ) ; } } private void checkRemoveSubs ( String failedNodeID , JsonObject theHAInfo ) { String chosen = chooseHashedNode ( null , failedNodeID . hashCode ( ) ) ; if ( chosen != null && chosen . equals ( this . nodeID ) ) { callFailoverCompleteHandler ( removeSubsHandler , failedNodeID , theHAInfo , true ) ; } } private void callFailoverCompleteHandler ( String nodeID , JsonObject haInfo , boolean result ) { callFailoverCompleteHandler ( failoverCompleteHandler , nodeID , haInfo , result ) ; } private void callFailoverCompleteHandler ( FailoverCompleteHandler handler , String nodeID , JsonObject haInfo , boolean result ) { if ( handler != null ) { CountDownLatch latch = new CountDownLatch ( 1 ) ; vertx . runOnContext ( v - > { handler . handle ( nodeID , haInfo , result ) ; latch . countDown ( ) ; } ) ; try { latch . await ( 30 , TimeUnit . SECONDS ) ; } catch ( InterruptedException ignore ) { } } } private void processFailover ( JsonObject failedVerticle ) { if ( failDuringFailover ) { throw new VertxException ( "Oops!" ) ; } final String verticleName = failedVerticle . getString ( "verticle_name" ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicReference < Throwable > err = new AtomicReference < > ( ) ; ContextImpl ctx = vertx . getContext ( ) ; if ( ctx != null ) { ContextImpl . setContext ( null ) ; } JsonObject options = failedVerticle . getJsonObject ( "options" ) ; try { doDeployVerticle ( verticleName , new DeploymentOptions ( options ) , result - > { if ( result . succeeded ( ) ) { log . info ( "Successfully redeployed verticle " + verticleName + " after failover" ) ; } else { log . error ( "Failed to redeploy verticle after failover" , result . cause ( ) ) ; err . set ( result . cause ( ) ) ; } latch . countDown ( ) ; Throwable t = err . get ( ) ; if ( t != null ) { throw new VertxException ( t ) ; } } ) ; } finally { if ( ctx != null ) { ContextImpl . setContext ( ctx ) ; } } try { if ( ! latch . await ( 120 , TimeUnit . SECONDS ) ) { throw new VertxException ( "Timed out waiting for redeploy on failover" ) ; } } catch ( InterruptedException e ) { throw new IllegalStateException ( e ) ; } } private String chooseHashedNode ( String group , int hashCode ) { List < String > nodes = clusterManager . getNodes ( ) ; ArrayList < String > matchingMembers = new ArrayList < > ( ) ; for ( String node : nodes ) { String sclusterInfo = clusterMap . get ( node ) ; if ( sclusterInfo != null ) { JsonObject clusterInfo = new JsonObject ( sclusterInfo ) ; String memberGroup = clusterInfo . getString ( "group" ) ; if ( group == null || group . equals ( memberGroup ) ) { matchingMembers . add ( node ) ; } } } if ( ! matchingMembers . isEmpty ( ) ) { long absHash = ( long ) hashCode + Integer . MAX_VALUE ; long lpos = absHash % matchingMembers . size ( ) ; return matchingMembers . get ( ( int ) lpos ) ; } else { return null ; } } }
package io . vertx . core . impl ; import java . util . Map ; import java . util . WeakHashMap ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . atomic . AtomicInteger ; public class VertxThreadFactory implements ThreadFactory { private static final Object FOO = new Object ( ) ; private static Map < VertxThread , Object > weakMap = new WeakHashMap < > ( ) ; private static synchronized void addToMap ( VertxThread thread ) { weakMap . put ( thread , FOO ) ; } private final String prefix ; private final AtomicInteger threadCount = new AtomicInteger ( 0 ) ; private final BlockedThreadChecker checker ; private final boolean worker ; VertxThreadFactory ( String prefix , BlockedThreadChecker checker , boolean worker ) { this . prefix = prefix ; this . checker = checker ; this . worker = worker ; } public static synchronized void unsetContext ( ContextImpl ctx ) { for ( VertxThread thread : weakMap . keySet ( ) ) { if ( thread . getContext ( ) == ctx ) { thread . setContext ( null ) ; } } } public Thread newThread ( Runnable runnable ) { VertxThread t = new VertxThread ( runnable , prefix + threadCount . getAndIncrement ( ) , worker ) ; if ( checker != null ) { checker . registerThread ( t ) ; } addToMap ( t ) ; t . setDaemon ( false ) ; return t ; } }
package io . vertx . core . impl ; import io . netty . channel . EventLoopGroup ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . Vertx ; import io . vertx . core . http . impl . HttpServerImpl ; import io . vertx . core . json . JsonObject ; import io . vertx . core . net . impl . NetServerImpl ; import io . vertx . core . net . impl . ServerID ; import io . vertx . core . spi . cluster . ClusterManager ; import io . vertx . core . spi . metrics . VertxMetrics ; import java . io . File ; import java . util . Map ; import java . util . concurrent . ExecutorService ; public interface VertxInternal extends Vertx { @ Override ContextImpl getOrCreateContext ( ) ; EventLoopGroup getEventLoopGroup ( ) ; ExecutorService getWorkerPool ( ) ; Map < ServerID , HttpServerImpl > sharedHttpServers ( ) ; Map < ServerID , NetServerImpl > sharedNetServers ( ) ; VertxMetrics metricsSPI ( ) ; ContextImpl getContext ( ) ; EventLoopContext createEventLoopContext ( String deploymentID , JsonObject config , ClassLoader tccl ) ; ContextImpl createWorkerContext ( boolean multiThreaded , String deploymentID , JsonObject config , ClassLoader tccl ) ; void simulateKill ( ) ; Deployment getDeployment ( String deploymentID ) ; void failoverCompleteHandler ( FailoverCompleteHandler failoverCompleteHandler ) ; boolean isKilled ( ) ; void failDuringFailover ( boolean fail ) ; String getNodeID ( ) ; File resolveFile ( String fileName ) ; < T > void executeBlockingInternal ( Action < T > action , Handler < AsyncResult < T > > resultHandler ) ; ClusterManager getClusterManager ( ) ; }
package io . vertx . core . impl ; @ FunctionalInterface public interface ContextTask { public void run ( ) throws Exception ; }
package io . vertx . core . impl ; public class NoStackTraceThrowable extends Throwable { public NoStackTraceThrowable ( String message ) { super ( message , null , false , false ) ; } }
package io . vertx . core . impl ; import java . util . Collection ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; public class ConcurrentHashSet < E > implements Set < E > { private final Map < E , Object > map ; private static final Object OBJ = new Object ( ) ; public ConcurrentHashSet ( int size ) { map = new ConcurrentHashMap < > ( size ) ; } public ConcurrentHashSet ( ) { map = new ConcurrentHashMap < > ( ) ; } @ Override public int size ( ) { return map . size ( ) ; } @ Override public boolean isEmpty ( ) { return map . isEmpty ( ) ; } @ Override public boolean contains ( Object o ) { return map . containsKey ( o ) ; } @ Override public Iterator < E > iterator ( ) { return map . keySet ( ) . iterator ( ) ; } @ Override public Object [ ] toArray ( ) { return map . keySet ( ) . toArray ( ) ; } @ Override public < T > T [ ] toArray ( T [ ] a ) { return map . keySet ( ) . toArray ( a ) ; } @ Override public boolean add ( E e ) { return map . put ( e , OBJ ) == null ; } @ Override public boolean remove ( Object o ) { return map . remove ( o ) != null ; } @ Override public boolean containsAll ( Collection < ? > c ) { return map . keySet ( ) . containsAll ( c ) ; } @ Override public boolean addAll ( Collection < ? extends E > c ) { boolean changed = false ; for ( E e : c ) { if ( map . put ( e , OBJ ) == null ) { changed = true ; } } return changed ; } @ Override public boolean retainAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( ) ; } @ Override public boolean removeAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( ) ; } @ Override public void clear ( ) { map . clear ( ) ; } }
package io . vertx . core . impl ; import io . vertx . core . Handler ; import io . vertx . core . json . JsonObject ; import java . util . concurrent . Executor ; public class WorkerContext extends ContextImpl { public WorkerContext ( VertxInternal vertx , Executor orderedInternalPoolExec , Executor workerExec , String deploymentID , JsonObject config , ClassLoader tccl ) { super ( vertx , orderedInternalPoolExec , workerExec , deploymentID , config , tccl ) ; } @ Override public void executeAsync ( Handler < Void > task ) { workerExec . execute ( wrapTask ( null , task , true ) ) ; } @ Override public boolean isEventLoopContext ( ) { return false ; } @ Override public boolean isMultiThreadedWorkerContext ( ) { return false ; } @ Override protected void checkCorrectThread ( ) { } @ Override public void executeFromIO ( ContextTask task ) { workerExec . execute ( wrapTask ( task , null , true ) ) ; } }
package io . vertx . core . impl ; public class Utils { public static String LINE_SEPARATOR = System . getProperty ( "line.separator" ) ; private static final boolean isWindows ; static { String os = System . getProperty ( "os.name" ) . toLowerCase ( ) ; isWindows = os . contains ( "win" ) ; } public static boolean isWindows ( ) { return isWindows ; } }
package io . vertx . core . impl ; import io . vertx . core . Handler ; import io . vertx . core . json . JsonObject ; import java . util . concurrent . Executor ; public class MultiThreadedWorkerContext extends WorkerContext { public MultiThreadedWorkerContext ( VertxInternal vertx , Executor orderedInternalExec , Executor workerExec , String deploymentID , JsonObject config , ClassLoader tccl ) { super ( vertx , orderedInternalExec , workerExec , deploymentID , config , tccl ) ; } @ Override public void executeAsync ( Handler < Void > task ) { workerExec . execute ( wrapTask ( null , task , false ) ) ; } @ Override public boolean isMultiThreadedWorkerContext ( ) { return true ; } }
package io . vertx . test . core ; import io . netty . buffer . ByteBuf ; import io . vertx . core . buffer . Buffer ; import org . junit . Test ; import java . nio . ByteBuffer ; import static io . vertx . test . core . TestUtils . assertIllegalArgumentException ; import static io . vertx . test . core . TestUtils . assertIndexOutOfBoundsException ; import static io . vertx . test . core . TestUtils . assertNullPointerException ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; public class BufferTest { @ Test public void testConstructorArguments ( ) throws Exception { assertIllegalArgumentException ( ( ) - > Buffer . buffer ( - 1 ) ) ; assertNullPointerException ( ( ) - > Buffer . buffer ( ( byte [ ] ) null ) ) ; assertNullPointerException ( ( ) - > Buffer . buffer ( ( String ) null ) ) ; assertNullPointerException ( ( ) - > Buffer . buffer ( ( ByteBuf ) null ) ) ; assertNullPointerException ( ( ) - > Buffer . buffer ( null , "UTF-8" ) ) ; assertNullPointerException ( ( ) - > Buffer . buffer ( "" , null ) ) ; } @ Test public void testSetGetInt ( ) throws Exception { final int size = 10 ; Buffer buffer = Buffer . buffer ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { buffer . setInt ( i * 4 , ( i + 1 ) * 10 ) ; } for ( int i = 0 ; i < size ; i ++ ) { assertEquals ( ( i + 1 ) * 10 , buffer . getInt ( i * 4 ) ) ; } } @ Test public void testAppendBuff ( ) throws Exception { int bytesLen = 100 ; byte [ ] bytes = TestUtils . randomByteArray ( bytesLen ) ; Buffer toAppend = Buffer . buffer ( bytes ) ; Buffer b = Buffer . buffer ( ) ; b . appendBuffer ( toAppend ) ; assertEquals ( b . length ( ) , bytes . length ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , b . getBytes ( ) ) ) ; b . appendBuffer ( toAppend ) ; assertEquals ( b . length ( ) , 2 * bytes . length ) ; assertNullPointerException ( ( ) - > b . appendBuffer ( null ) ) ; } @ Test public void testAppendBytes ( ) throws Exception { int bytesLen = 100 ; byte [ ] bytes = TestUtils . randomByteArray ( bytesLen ) ; Buffer b = Buffer . buffer ( ) ; b . appendBytes ( bytes ) ; assertEquals ( b . length ( ) , bytes . length ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , b . getBytes ( ) ) ) ; b . appendBytes ( bytes ) ; assertEquals ( b . length ( ) , 2 * bytes . length ) ; assertNullPointerException ( ( ) - > b . appendBytes ( null ) ) ; } @ Test public void testAppendBytesWithOffsetAndLen ( ) throws Exception { int bytesLen = 100 ; byte [ ] bytes = TestUtils . randomByteArray ( bytesLen ) ; int len = bytesLen - 2 ; Buffer b = Buffer . buffer ( ) ; b . appendBytes ( bytes , 1 , len ) ; assertEquals ( b . length ( ) , len ) ; byte [ ] copy = new byte [ len ] ; System . arraycopy ( bytes , 1 , copy , 0 , len ) ; assertTrue ( TestUtils . byteArraysEqual ( copy , b . getBytes ( ) ) ) ; b . appendBytes ( bytes , 1 , len ) ; assertEquals ( b . length ( ) , 2 * len ) ; assertNullPointerException ( ( ) - > b . appendBytes ( null , 1 , len ) ) ; } @ Test public void testAppendBufferWithOffsetAndLen ( ) throws Exception { int bytesLen = 100 ; byte [ ] bytes = TestUtils . randomByteArray ( bytesLen ) ; Buffer src = Buffer . buffer ( bytes ) ; int len = bytesLen - 2 ; Buffer b = Buffer . buffer ( ) ; b . appendBuffer ( src , 1 , len ) ; assertEquals ( b . length ( ) , len ) ; byte [ ] copy = new byte [ len ] ; System . arraycopy ( bytes , 1 , copy , 0 , len ) ; assertTrue ( TestUtils . byteArraysEqual ( copy , b . getBytes ( ) ) ) ; b . appendBuffer ( src , 1 , len ) ; assertEquals ( b . length ( ) , 2 * len ) ; assertNullPointerException ( ( ) - > b . appendBuffer ( null , 1 , len ) ) ; } @ Test public void testAppendByte ( ) throws Exception { int bytesLen = 100 ; byte [ ] bytes = TestUtils . randomByteArray ( bytesLen ) ; Buffer b = Buffer . buffer ( ) ; for ( int i = 0 ; i < bytesLen ; i ++ ) { b . appendByte ( bytes [ i ] ) ; } assertEquals ( b . length ( ) , bytes . length ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , b . getBytes ( ) ) ) ; for ( int i = 0 ; i < bytesLen ; i ++ ) { b . appendByte ( bytes [ i ] ) ; } assertEquals ( b . length ( ) , 2 * bytes . length ) ; } @ Test public void testAppendByte2 ( ) throws Exception { int bytesLen = 100 ; Buffer b = Buffer . buffer ( TestUtils . randomByteArray ( bytesLen ) ) ; b . setByte ( b . length ( ) , ( byte ) 9 ) ; } @ Test public void testAppendUnsignedByte ( ) { Buffer b = Buffer . buffer ( TestUtils . randomByteArray ( 100 ) ) ; b . appendUnsignedByte ( ( short ) ( Byte . MAX_VALUE + Byte . MAX_VALUE / 2 ) ) ; assertEquals ( 101 , b . length ( ) ) ; } @ Test public void testAppendUnsignedShort ( ) { Buffer b = Buffer . buffer ( TestUtils . randomByteArray ( 100 ) ) ; b . appendUnsignedShort ( Short . MAX_VALUE + Short . MAX_VALUE / 2 ) ; assertEquals ( 102 , b . length ( ) ) ; } @ Test public void testAppendUnsignedInt ( ) { Buffer b = Buffer . buffer ( TestUtils . randomByteArray ( 100 ) ) ; b . appendUnsignedInt ( Integer . MAX_VALUE + ( long ) Integer . MAX_VALUE / 2 ) ; assertEquals ( 104 , b . length ( ) ) ; } @ Test public void testAppendString1 ( ) throws Exception { String str = TestUtils . randomUnicodeString ( 100 ) ; byte [ ] sb = str . getBytes ( "UTF-8" ) ; Buffer b = Buffer . buffer ( ) ; b . appendString ( str ) ; assertEquals ( b . length ( ) , sb . length ) ; assertTrue ( str . equals ( b . toString ( "UTF-8" ) ) ) ; assertNullPointerException ( ( ) - > b . appendString ( null ) ) ; assertNullPointerException ( ( ) - > b . appendString ( null , "UTF-8" ) ) ; assertNullPointerException ( ( ) - > b . appendString ( "" , null ) ) ; } @ Test public void testAppendString2 ( ) throws Exception { } @ Test public void testGetOutOfBounds ( ) throws Exception { int bytesLen = 100 ; byte [ ] bytes = TestUtils . randomByteArray ( bytesLen ) ; Buffer b = Buffer . buffer ( bytes ) ; assertIndexOutOfBoundsException ( ( ) - > b . getByte ( bytesLen ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getByte ( bytesLen + 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getByte ( bytesLen + 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getByte ( - 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getByte ( - 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getInt ( bytesLen ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getInt ( bytesLen + 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getInt ( bytesLen + 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getInt ( - 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getInt ( - 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getLong ( bytesLen ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getLong ( bytesLen + 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getLong ( bytesLen + 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getLong ( - 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getLong ( - 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getFloat ( bytesLen ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getFloat ( bytesLen + 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getFloat ( bytesLen + 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getFloat ( - 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getFloat ( - 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getDouble ( bytesLen ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getDouble ( bytesLen + 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getDouble ( bytesLen + 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getDouble ( - 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getDouble ( - 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getShort ( bytesLen ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getShort ( bytesLen + 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getShort ( bytesLen + 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getShort ( - 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getShort ( - 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getBytes ( bytesLen + 1 , bytesLen + 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getBytes ( bytesLen + 100 , bytesLen + 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getBytes ( - 1 , - 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getBytes ( - 100 , - 100 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getString ( - 1 , bytesLen ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getString ( 0 , bytesLen + 1 ) ) ; assertIllegalArgumentException ( ( ) - > b . getString ( 2 , 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getString ( - 1 , bytesLen , "UTF-8" ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . getString ( 0 , bytesLen + 1 , "UTF-8" ) ) ; assertIllegalArgumentException ( ( ) - > b . getString ( 2 , 1 , "UTF-8" ) ) ; } @ Test public void testSetOutOfBounds ( ) throws Exception { Buffer b = Buffer . buffer ( numSets ) ; assertIndexOutOfBoundsException ( ( ) - > b . setByte ( - 1 , ( byte ) 0 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . setInt ( - 1 , 0 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . setLong ( - 1 , 0 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . setDouble ( - 1 , 0 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . setFloat ( - 1 , 0 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . setShort ( - 1 , ( short ) 0 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . setBuffer ( - 1 , b ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . setBuffer ( 0 , b , - 1 , 0 ) ) ; assertIllegalArgumentException ( ( ) - > b . setBuffer ( 0 , b , 0 , - 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . setBytes ( - 1 , TestUtils . randomByteArray ( 1 ) ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . setBytes ( - 1 , TestUtils . randomByteArray ( 1 ) , - 1 , 0 ) ) ; assertIllegalArgumentException ( ( ) - > b . setBytes ( - 1 , TestUtils . randomByteArray ( 1 ) , 0 , - 1 ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . setString ( - 1 , "" ) ) ; assertIndexOutOfBoundsException ( ( ) - > b . setString ( - 1 , "" , "UTF-8" ) ) ; } @ Test public void testGetByte ( ) throws Exception { int bytesLen = 100 ; byte [ ] bytes = TestUtils . randomByteArray ( bytesLen ) ; Buffer b = Buffer . buffer ( bytes ) ; for ( int i = 0 ; i < bytesLen ; i ++ ) { assertEquals ( bytes [ i ] , b . getByte ( i ) ) ; } } @ Test public void testGetUnsignedByte ( ) throws Exception { int bytesLen = 100 ; byte [ ] bytes = TestUtils . randomByteArray ( bytesLen ) ; Buffer b = Buffer . buffer ( bytes ) ; for ( int i = 0 ; i < bytesLen ; i ++ ) { assertEquals ( Byte . toUnsignedLong ( bytes [ i ] ) , b . getUnsignedByte ( i ) ) ; } } @ Test public void testGetInt ( ) throws Exception { int numInts = 100 ; Buffer b = Buffer . buffer ( numInts * 4 ) ; for ( int i = 0 ; i < numInts ; i ++ ) { b . setInt ( i * 4 , i ) ; } for ( int i = 0 ; i < numInts ; i ++ ) { assertEquals ( i , b . getInt ( i * 4 ) ) ; } } @ Test public void testGetUnsignedInt ( ) throws Exception { int numInts = 100 ; Buffer b = Buffer . buffer ( numInts * 4 ) ; for ( int i = 0 ; i < numInts ; i ++ ) { b . setInt ( i * 4 , ( int ) ( Integer . MAX_VALUE + ( long ) i ) ) ; } for ( int i = 0 ; i < numInts ; i ++ ) { assertEquals ( Integer . toUnsignedLong ( Integer . MAX_VALUE + i ) , b . getUnsignedInt ( i * 4 ) ) ; } } @ Test public void testGetLong ( ) throws Exception { int numLongs = 100 ; Buffer b = Buffer . buffer ( numLongs * 8 ) ; for ( int i = 0 ; i < numLongs ; i ++ ) { b . setLong ( i * 8 , i ) ; } for ( int i = 0 ; i < numLongs ; i ++ ) { assertEquals ( i , b . getLong ( i * 8 ) ) ; } } @ Test public void testGetFloat ( ) throws Exception { int numFloats = 100 ; Buffer b = Buffer . buffer ( numFloats * 4 ) ; for ( int i = 0 ; i < numFloats ; i ++ ) { b . setFloat ( i * 4 , i ) ; } for ( int i = 0 ; i < numFloats ; i ++ ) { assertEquals ( ( float ) i , b . getFloat ( i * 4 ) , 0 ) ; } } @ Test public void testGetDouble ( ) throws Exception { int numDoubles = 100 ; Buffer b = Buffer . buffer ( numDoubles * 8 ) ; for ( int i = 0 ; i < numDoubles ; i ++ ) { b . setDouble ( i * 8 , i ) ; } for ( int i = 0 ; i < numDoubles ; i ++ ) { assertEquals ( ( double ) i , b . getDouble ( i * 8 ) , 0 ) ; } } @ Test public void testGetShort ( ) throws Exception { int numShorts = 100 ; Buffer b = Buffer . buffer ( numShorts * 2 ) ; for ( short i = 0 ; i < numShorts ; i ++ ) { b . setShort ( i * 2 , i ) ; } for ( short i = 0 ; i < numShorts ; i ++ ) { assertEquals ( i , b . getShort ( i * 2 ) ) ; } } @ Test public void testGetUnsignedShort ( ) throws Exception { int numShorts = 100 ; Buffer b = Buffer . buffer ( numShorts * 2 ) ; for ( short i = 0 ; i < numShorts ; i ++ ) { b . setShort ( i * 2 , ( short ) ( Short . MAX_VALUE + ( int ) i ) ) ; } for ( short i = 0 ; i < numShorts ; i ++ ) { assertEquals ( Integer . toUnsignedLong ( Short . MAX_VALUE + i ) , b . getUnsignedShort ( i * 2 ) ) ; } } @ Test public void testGetString ( ) throws Exception { String str = TestUtils . randomAlphaString ( 100 ) ; Buffer b = Buffer . buffer ( str , "UTF-8" ) ; assertEquals ( 100 , b . length ( ) ) ; String substr = b . getString ( 10 , 20 ) ; assertEquals ( str . substring ( 10 , 20 ) , substr ) ; substr = b . getString ( 10 , 20 , "UTF-8" ) ; assertEquals ( str . substring ( 10 , 20 ) , substr ) ; } @ Test public void testGetBytes ( ) throws Exception { byte [ ] bytes = TestUtils . randomByteArray ( 100 ) ; Buffer b = Buffer . buffer ( bytes ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , b . getBytes ( ) ) ) ; } @ Test public void testGetBytes2 ( ) throws Exception { byte [ ] bytes = TestUtils . randomByteArray ( 100 ) ; Buffer b = Buffer . buffer ( bytes ) ; byte [ ] sub = new byte [ bytes . length / 2 ] ; System . arraycopy ( bytes , bytes . length / 4 , sub , 0 , bytes . length / 2 ) ; assertTrue ( TestUtils . byteArraysEqual ( sub , b . getBytes ( bytes . length / 4 , bytes . length / 4 + bytes . length / 2 ) ) ) ; } private final int numSets = 100 ; @ Test public void testSetInt ( ) throws Exception { testSetInt ( Buffer . buffer ( numSets * 4 ) ) ; } @ Test public void testSetIntExpandBuffer ( ) throws Exception { testSetInt ( Buffer . buffer ( ) ) ; } private void testSetInt ( Buffer buff ) throws Exception { for ( int i = 0 ; i < numSets ; i ++ ) { buff . setInt ( i * 4 , i ) ; } for ( int i = 0 ; i < numSets ; i ++ ) { assertEquals ( i , buff . getInt ( i * 4 ) ) ; } } @ Test public void testSetUnsignedInt ( ) throws Exception { testSetUnsignedInt ( Buffer . buffer ( numSets * 4 ) ) ; } @ Test public void testSetUnsignedIntExpandBuffer ( ) throws Exception { testSetUnsignedInt ( Buffer . buffer ( ) ) ; } private void testSetUnsignedInt ( Buffer buff ) throws Exception { for ( int i = 0 ; i < numSets ; i ++ ) { long val = Integer . toUnsignedLong ( Integer . MAX_VALUE + i ) ; buff . setUnsignedInt ( i * 4 , val ) ; } for ( int i = 0 ; i < numSets ; i ++ ) { long val = Integer . toUnsignedLong ( Integer . MAX_VALUE + i ) ; assertEquals ( val , buff . getUnsignedInt ( i * 4 ) ) ; } } @ Test public void testSetLong ( ) throws Exception { testSetLong ( Buffer . buffer ( numSets * 8 ) ) ; } @ Test public void testSetLongExpandBuffer ( ) throws Exception { testSetLong ( Buffer . buffer ( ) ) ; } private void testSetLong ( Buffer buff ) throws Exception { for ( int i = 0 ; i < numSets ; i ++ ) { buff . setLong ( i * 8 , i ) ; } for ( int i = 0 ; i < numSets ; i ++ ) { assertEquals ( i , buff . getLong ( i * 8 ) ) ; } } @ Test public void testSetByte ( ) throws Exception { testSetByte ( Buffer . buffer ( numSets ) ) ; } @ Test public void testSetByteExpandBuffer ( ) throws Exception { testSetByte ( Buffer . buffer ( ) ) ; } private void testSetByte ( Buffer buff ) throws Exception { for ( int i = 0 ; i < numSets ; i ++ ) { buff . setByte ( i , ( byte ) i ) ; } for ( int i = 0 ; i < numSets ; i ++ ) { assertEquals ( i , buff . getByte ( i ) ) ; } } @ Test public void testSetUnsignedByte ( ) throws Exception { testSetUnsignedByte ( Buffer . buffer ( numSets ) ) ; } @ Test public void testSetUnsignedByteExpandBuffer ( ) throws Exception { testSetUnsignedByte ( Buffer . buffer ( ) ) ; } private void testSetUnsignedByte ( Buffer buff ) throws Exception { for ( int i = 0 ; i < numSets ; i ++ ) { int val = Byte . MAX_VALUE + i ; buff . setUnsignedByte ( i , ( short ) val ) ; } for ( int i = 0 ; i < numSets ; i ++ ) { int val = Byte . MAX_VALUE + i ; assertEquals ( val , buff . getUnsignedByte ( i ) ) ; } } @ Test public void testSetFloat ( ) throws Exception { testSetFloat ( Buffer . buffer ( numSets * 4 ) ) ; } @ Test public void testSetFloatExpandBuffer ( ) throws Exception { testSetFloat ( Buffer . buffer ( ) ) ; } private void testSetFloat ( Buffer buff ) throws Exception { for ( int i = 0 ; i < numSets ; i ++ ) { buff . setFloat ( i * 4 , ( float ) i ) ; } for ( int i = 0 ; i < numSets ; i ++ ) { assertEquals ( ( float ) i , buff . getFloat ( i * 4 ) , 0 ) ; } } @ Test public void testSetDouble ( ) throws Exception { testSetDouble ( Buffer . buffer ( numSets * 8 ) ) ; } @ Test public void testSetDoubleExpandBuffer ( ) throws Exception { testSetDouble ( Buffer . buffer ( ) ) ; } private void testSetDouble ( Buffer buff ) throws Exception { for ( int i = 0 ; i < numSets ; i ++ ) { buff . setDouble ( i * 8 , ( double ) i ) ; } for ( int i = 0 ; i < numSets ; i ++ ) { assertEquals ( ( double ) i , buff . getDouble ( i * 8 ) , 0 ) ; } } @ Test public void testSetShort ( ) throws Exception { testSetShort ( Buffer . buffer ( numSets * 2 ) ) ; } @ Test public void testSetShortExpandBuffer ( ) throws Exception { testSetShort ( Buffer . buffer ( ) ) ; } private void testSetShort ( Buffer buff ) throws Exception { for ( int i = 0 ; i < numSets ; i ++ ) { buff . setShort ( i * 2 , ( short ) i ) ; } for ( int i = 0 ; i < numSets ; i ++ ) { assertEquals ( i , buff . getShort ( i * 2 ) ) ; } } @ Test public void testSetUnsignedShort ( ) throws Exception { testSetUnsignedShort ( Buffer . buffer ( numSets * 2 ) ) ; } @ Test public void testSetUnsignedShortExpandBuffer ( ) throws Exception { testSetUnsignedShort ( Buffer . buffer ( ) ) ; } private void testSetUnsignedShort ( Buffer buff ) throws Exception { for ( int i = 0 ; i < numSets ; i ++ ) { int val = Short . MAX_VALUE + i ; buff . setUnsignedShort ( i * 2 , val ) ; } for ( int i = 0 ; i < numSets ; i ++ ) { int val = Short . MAX_VALUE + i ; assertEquals ( val , buff . getUnsignedShort ( i * 2 ) ) ; } } @ Test public void testSetBytesBuffer ( ) throws Exception { testSetBytesBuffer ( Buffer . buffer ( 150 ) ) ; assertNullPointerException ( ( ) - > Buffer . buffer ( 150 ) . setBytes ( 0 , ( ByteBuffer ) null ) ) ; } @ Test public void testSetBytesBufferExpandBuffer ( ) throws Exception { testSetShort ( Buffer . buffer ( ) ) ; } private void testSetBytesBuffer ( Buffer buff ) throws Exception { Buffer b = TestUtils . randomBuffer ( 100 ) ; buff . setBuffer ( 50 , b ) ; byte [ ] b2 = buff . getBytes ( 50 , 150 ) ; assertEquals ( b , Buffer . buffer ( b2 ) ) ; byte [ ] b3 = TestUtils . randomByteArray ( 100 ) ; buff . setBytes ( 50 , b3 ) ; byte [ ] b4 = buff . getBytes ( 50 , 150 ) ; assertEquals ( Buffer . buffer ( b3 ) , Buffer . buffer ( b4 ) ) ; } @ Test public void testSetBytesWithOffsetAndLen ( ) throws Exception { int bytesLen = 100 ; byte [ ] bytes = TestUtils . randomByteArray ( bytesLen ) ; int len = bytesLen - 2 ; Buffer b = Buffer . buffer ( ) ; b . setByte ( 0 , ( byte ) '0' ) ; b . setBytes ( 1 , bytes , 1 , len ) ; assertEquals ( b . length ( ) , len + 1 ) ; byte [ ] copy = new byte [ len ] ; System . arraycopy ( bytes , 1 , copy , 0 , len ) ; assertTrue ( TestUtils . byteArraysEqual ( copy , b . getBytes ( 1 , b . length ( ) ) ) ) ; b . setBytes ( b . length ( ) , bytes , 1 , len ) ; assertEquals ( b . length ( ) , 2 * len + 1 ) ; assertNullPointerException ( ( ) - > Buffer . buffer ( 150 ) . setBytes ( 0 , ( byte [ ] ) null ) ) ; assertNullPointerException ( ( ) - > Buffer . buffer ( 150 ) . setBytes ( 0 , null , 1 , len ) ) ; } @ Test public void testSetBufferWithOffsetAndLen ( ) throws Exception { int bytesLen = 100 ; byte [ ] bytes = TestUtils . randomByteArray ( bytesLen ) ; Buffer src = Buffer . buffer ( bytes ) ; int len = bytesLen - 2 ; Buffer b = Buffer . buffer ( ) ; b . setByte ( 0 , ( byte ) '0' ) ; b . setBuffer ( 1 , src , 1 , len ) ; assertEquals ( b . length ( ) , len + 1 ) ; byte [ ] copy = new byte [ len ] ; System . arraycopy ( bytes , 1 , copy , 0 , len ) ; assertTrue ( TestUtils . byteArraysEqual ( copy , b . getBytes ( 1 , b . length ( ) ) ) ) ; b . setBuffer ( b . length ( ) , src , 1 , len ) ; assertEquals ( b . length ( ) , 2 * len + 1 ) ; assertNullPointerException ( ( ) - > b . setBuffer ( 1 , null ) ) ; assertNullPointerException ( ( ) - > b . setBuffer ( 1 , null , 0 , len ) ) ; } @ Test public void testSetBytesString ( ) throws Exception { testSetBytesString ( Buffer . buffer ( 150 ) ) ; } @ Test public void testSetBytesStringExpandBuffer ( ) throws Exception { testSetBytesString ( Buffer . buffer ( ) ) ; } private void testSetBytesString ( Buffer buff ) throws Exception { String str = TestUtils . randomUnicodeString ( 100 ) ; buff . setString ( 50 , str ) ; byte [ ] b1 = buff . getBytes ( 50 , buff . length ( ) ) ; String str2 = new String ( b1 , "UTF-8" ) ; assertEquals ( str , str2 ) ; assertNullPointerException ( ( ) - > Buffer . buffer ( 150 ) . setString ( 0 , null ) ) ; assertNullPointerException ( ( ) - > Buffer . buffer ( 150 ) . setString ( 0 , null , "UTF-8" ) ) ; } @ Test public void testToString ( ) throws Exception { String str = TestUtils . randomUnicodeString ( 100 ) ; Buffer buff = Buffer . buffer ( str ) ; assertEquals ( str , buff . toString ( ) ) ; } @ Test public void testCopy ( ) throws Exception { Buffer buff = TestUtils . randomBuffer ( 100 ) ; assertEquals ( buff , buff . copy ( ) ) ; Buffer copy = buff . getBuffer ( 0 , buff . length ( ) ) ; assertEquals ( buff , copy ) ; Buffer copy2 = buff . copy ( ) ; buff . setInt ( 0 , 1 ) ; assertEquals ( copy , copy2 ) ; } @ Test public void testCreateBuffers ( ) throws Exception { Buffer buff = Buffer . buffer ( 1000 ) ; assertEquals ( 0 , buff . length ( ) ) ; String str = TestUtils . randomUnicodeString ( 100 ) ; buff = Buffer . buffer ( str ) ; assertEquals ( buff . length ( ) , str . getBytes ( "UTF-8" ) . length ) ; assertEquals ( str , buff . toString ( ) ) ; byte [ ] bytes = TestUtils . randomByteArray ( 100 ) ; buff = Buffer . buffer ( bytes ) ; assertEquals ( buff . length ( ) , bytes . length ) ; assertEquals ( Buffer . buffer ( bytes ) , Buffer . buffer ( buff . getBytes ( ) ) ) ; } @ Test public void testSlice1 ( ) throws Exception { Buffer buff = TestUtils . randomBuffer ( 100 ) ; Buffer sliced = buff . slice ( ) ; assertEquals ( buff , sliced ) ; long rand = TestUtils . randomLong ( ) ; sliced . setLong ( 0 , rand ) ; assertEquals ( rand , buff . getLong ( 0 ) ) ; buff . appendString ( TestUtils . randomUnicodeString ( 100 ) ) ; assertEquals ( 100 , sliced . length ( ) ) ; } @ Test public void testSlice2 ( ) throws Exception { Buffer buff = TestUtils . randomBuffer ( 100 ) ; Buffer sliced = buff . slice ( 10 , 20 ) ; for ( int i = 0 ; i < 10 ; i ++ ) { assertEquals ( buff . getByte ( 10 + i ) , sliced . getByte ( i ) ) ; } long rand = TestUtils . randomLong ( ) ; sliced . setLong ( 0 , rand ) ; assertEquals ( rand , buff . getLong ( 10 ) ) ; buff . appendString ( TestUtils . randomUnicodeString ( 100 ) ) ; assertEquals ( 10 , sliced . length ( ) ) ; } }
package io . vertx . core . impl ; import io . vertx . core . * ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . net . URL ; import java . net . URLDecoder ; import java . nio . file . FileAlreadyExistsException ; import java . nio . file . Files ; import java . nio . file . StandardCopyOption ; import java . util . Enumeration ; import java . util . UUID ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; public class FileResolver { public static final String DISABLE_FILE_CACHING_PROP_NAME = "vertx.disableFileCaching" ; public static final String DISABLE_CP_RESOLVING_PROP_NAME = "vertx.disableFileCPResolving" ; public static final String CACHE_DIR_BASE_PROP_NAME = "vertx.cacheDirBase" ; private static final String DEFAULT_CACHE_DIR_BASE = ".vertx" ; private static final String FILE_SEP = System . getProperty ( "file.separator" ) ; private static boolean NON_UNIX_FILE_SEP = ! FILE_SEP . equals ( "/" ) ; private static final boolean ENABLE_CACHING = ! Boolean . getBoolean ( DISABLE_FILE_CACHING_PROP_NAME ) ; private static final boolean ENABLE_CP_RESOLVING = ! Boolean . getBoolean ( DISABLE_CP_RESOLVING_PROP_NAME ) ; private static final String CACHE_DIR_BASE = System . getProperty ( CACHE_DIR_BASE_PROP_NAME , DEFAULT_CACHE_DIR_BASE ) ; private final Vertx vertx ; private final File cwd ; private File cacheDir ; private Thread shutdownHook ; public FileResolver ( Vertx vertx ) { this . vertx = vertx ; String cwdOverride = System . getProperty ( "vertx.cwd" ) ; if ( cwdOverride != null ) { cwd = new File ( cwdOverride ) . getAbsoluteFile ( ) ; } else { cwd = null ; } if ( ENABLE_CP_RESOLVING ) { setupCacheDir ( ) ; } } public void close ( Handler < AsyncResult < Void > > handler ) { deleteCacheDir ( handler ) ; if ( shutdownHook != null ) { try { Runtime . getRuntime ( ) . removeShutdownHook ( shutdownHook ) ; } catch ( IllegalStateException ignore ) { } } } public File resolveFile ( String fileName ) { File file = new File ( fileName ) ; if ( cwd != null && ! file . isAbsolute ( ) ) { file = new File ( cwd , fileName ) ; } if ( ! ENABLE_CP_RESOLVING ) { return file ; } if ( ! file . exists ( ) ) { File cacheFile = new File ( cacheDir , fileName ) ; if ( ENABLE_CACHING && cacheFile . exists ( ) ) { return cacheFile ; } ClassLoader cl = getClassLoader ( ) ; if ( NON_UNIX_FILE_SEP ) { fileName = fileName . replace ( FILE_SEP , "/" ) ; } URL url = cl . getResource ( fileName ) ; if ( url != null ) { String prot = url . getProtocol ( ) ; switch ( prot ) { case "file" : return unpackFromFileURL ( url , fileName , cl ) ; case "jar" : return unpackFromJarURL ( url , fileName ) ; default : throw new IllegalStateException ( "Invalid url protocol: " + prot ) ; } } } return file ; } private synchronized File unpackFromFileURL ( URL url , String fileName , ClassLoader cl ) { File resource ; try { resource = new File ( URLDecoder . decode ( url . getPath ( ) , "UTF-8" ) ) ; } catch ( UnsupportedEncodingException e ) { throw new VertxException ( e ) ; } boolean isDirectory = resource . isDirectory ( ) ; File cacheFile = new File ( cacheDir , fileName ) ; if ( ! isDirectory ) { cacheFile . getParentFile ( ) . mkdirs ( ) ; try { if ( ENABLE_CACHING ) { Files . copy ( resource . toPath ( ) , cacheFile . toPath ( ) ) ; } else { Files . copy ( resource . toPath ( ) , cacheFile . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; } } catch ( FileAlreadyExistsException ignore ) { } catch ( IOException e ) { throw new VertxException ( e ) ; } } else { cacheFile . mkdirs ( ) ; String [ ] listing = resource . list ( ) ; for ( String file : listing ) { String subResource = fileName + "/" + file ; URL url2 = cl . getResource ( subResource ) ; unpackFromFileURL ( url2 , subResource , cl ) ; } } return cacheFile ; } private synchronized File unpackFromJarURL ( URL url , String fileName ) { String path = url . getPath ( ) ; String jarFile = path . substring ( 5 , path . lastIndexOf ( ".jar!" ) + 4 ) ; try { ZipFile zip = new ZipFile ( jarFile ) ; Enumeration < ? extends ZipEntry > entries = zip . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; String name = entry . getName ( ) ; if ( name . startsWith ( fileName ) ) { File file = new File ( cacheDir , name ) ; if ( name . endsWith ( "/" ) ) { file . mkdirs ( ) ; } else { file . getParentFile ( ) . mkdirs ( ) ; try ( InputStream is = zip . getInputStream ( entry ) ) { if ( ENABLE_CACHING ) { Files . copy ( is , file . toPath ( ) ) ; } else { Files . copy ( is , file . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; } } catch ( FileAlreadyExistsException ignore ) { } } } } } catch ( IOException e ) { throw new VertxException ( e ) ; } return new File ( cacheDir , fileName ) ; } private ClassLoader getClassLoader ( ) { ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( cl == null ) { cl = getClass ( ) . getClassLoader ( ) ; } return cl ; } private void setupCacheDir ( ) { String cacheDirName = CACHE_DIR_BASE + "/file-cache-" + UUID . randomUUID ( ) . toString ( ) ; cacheDir = new File ( cacheDirName ) ; if ( ! cacheDir . mkdirs ( ) ) { throw new IllegalStateException ( "Failed to create cache dir" ) ; } shutdownHook = new Thread ( ( ) - > deleteCacheDir ( ar - > { } ) ) ; Runtime . getRuntime ( ) . addShutdownHook ( shutdownHook ) ; } private void deleteCacheDir ( Handler < AsyncResult < Void > > handler ) { if ( cacheDir != null && cacheDir . exists ( ) ) { vertx . fileSystem ( ) . deleteRecursive ( cacheDir . getAbsolutePath ( ) , true , handler ) ; } else { handler . handle ( Future . succeededFuture ( ) ) ; } } }
package io . vertx . core . impl ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import java . util . LinkedList ; import java . util . concurrent . Executor ; public class OrderedExecutorFactory { private static final Logger log = LoggerFactory . getLogger ( OrderedExecutorFactory . class ) ; private final Executor parent ; public OrderedExecutorFactory ( Executor parent ) { this . parent = parent ; } public Executor getExecutor ( ) { return new OrderedExecutor ( parent ) ; } private static final class OrderedExecutor implements Executor { private final LinkedList < Runnable > tasks = new LinkedList < > ( ) ; private boolean running ; private final Executor parent ; private final Runnable runner ; public OrderedExecutor ( Executor parent ) { this . parent = parent ; runner = ( ) - > { for ( ; ; ) { final Runnable task ; synchronized ( tasks ) { task = tasks . poll ( ) ; if ( task == null ) { running = false ; return ; } } try { task . run ( ) ; } catch ( Throwable t ) { log . error ( "Caught unexpected Throwable" , t ) ; } } } ; } public void execute ( Runnable command ) { synchronized ( tasks ) { tasks . add ( command ) ; if ( ! running ) { running = true ; parent . execute ( runner ) ; } } } } }
package io . vertx . core . impl ; import io . vertx . core . Future ; import io . vertx . core . spi . FutureFactory ; public class FutureFactoryImpl implements FutureFactory { @ Override public < T > Future < T > future ( ) { return new FutureImpl < > ( ) ; } @ Override public < T > Future < T > completedFuture ( ) { return new FutureImpl < > ( ( T ) null ) ; } @ Override public < T > Future < T > completedFuture ( T result ) { return new FutureImpl < > ( result ) ; } @ Override public < T > Future < T > completedFuture ( Throwable t ) { return new FutureImpl < > ( t ) ; } @ Override public < T > Future < T > completedFuture ( String failureMessage , boolean failed ) { return new FutureImpl < > ( failureMessage , true ) ; } }
package io . vertx . core . impl ; import java . util . HashMap ; import java . util . Map ; public class Args { public final Map < String , String > map = new HashMap < > ( ) ; public Args ( String [ ] args ) { String currentKey = null ; for ( String arg : args ) { if ( arg . startsWith ( "-" ) ) { if ( currentKey != null ) { map . put ( currentKey , "" ) ; } currentKey = arg ; } else { if ( currentKey != null ) { map . put ( currentKey , arg ) ; currentKey = null ; } } } if ( currentKey != null ) { map . put ( currentKey , "" ) ; } } public int getInt ( String argName ) { String arg = map . get ( argName ) ; int val ; if ( arg != null ) { try { val = Integer . parseInt ( arg . trim ( ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Invalid " + argName + ": " + arg ) ; } } else { val = - 1 ; } return val ; } }
package io . vertx . core . impl ; import java . io . IOException ; import java . io . StringWriter ; import java . io . Writer ; import java . util . Locale ; public class StringEscapeUtils { public StringEscapeUtils ( ) { super ( ) ; } public static String escapeJava ( String str ) throws Exception { return escapeJavaStyleString ( str , false , false ) ; } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false , false ) ; } public static String escapeJavaScript ( String str ) throws Exception { return escapeJavaStyleString ( str , true , true ) ; } public static void escapeJavaScript ( Writer out , String str ) throws Exception { escapeJavaStyleString ( out , str , true , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes , boolean escapeForwardSlash ) throws Exception { if ( str == null ) { return null ; } StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes , escapeForwardSlash ) ; return writer . toString ( ) ; } private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote , boolean escapeForwardSlash ) throws IOException { if ( out == null ) { throw new IllegalArgumentException ( "The Writer must not be null" ) ; } if ( str == null ) { return ; } int sz ; sz = str . length ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch > 0xfff ) { out . write ( "\\u" + hex ( ch ) ) ; } else if ( ch > 0xff ) { out . write ( "\\u0" + hex ( ch ) ) ; } else if ( ch > 0x7f ) { out . write ( "\\u00" + hex ( ch ) ) ; } else if ( ch < 32 ) { switch ( ch ) { case '\b' : out . write ( '\\' ) ; out . write ( 'b' ) ; break ; case '\n' : out . write ( '\\' ) ; out . write ( 'n' ) ; break ; case '\t' : out . write ( '\\' ) ; out . write ( 't' ) ; break ; case '\f' : out . write ( '\\' ) ; out . write ( 'f' ) ; break ; case '\r' : out . write ( '\\' ) ; out . write ( 'r' ) ; break ; default : if ( ch > 0xf ) { out . write ( "\\u00" + hex ( ch ) ) ; } else { out . write ( "\\u000" + hex ( ch ) ) ; } break ; } } else { switch ( ch ) { case '\'' : if ( escapeSingleQuote ) { out . write ( '\\' ) ; } out . write ( '\'' ) ; break ; case '"' : out . write ( '\\' ) ; out . write ( '"' ) ; break ; case '\\' : out . write ( '\\' ) ; out . write ( '\\' ) ; break ; case '/' : if ( escapeForwardSlash ) { out . write ( '\\' ) ; } out . write ( '/' ) ; break ; default : out . write ( ch ) ; break ; } } } } private static String hex ( char ch ) { return Integer . toHexString ( ch ) . toUpperCase ( Locale . ENGLISH ) ; } public static String unescapeJava ( String str ) throws Exception { if ( str == null ) { return null ; } StringWriter writer = new StringWriter ( str . length ( ) ) ; unescapeJava ( writer , str ) ; return writer . toString ( ) ; } public static void unescapeJava ( Writer out , String str ) throws Exception { if ( out == null ) { throw new IllegalArgumentException ( "The Writer must not be null" ) ; } if ( str == null ) { return ; } int sz = str . length ( ) ; StringBuilder unicode = new StringBuilder ( ) ; boolean hadSlash = false ; boolean inUnicode = false ; for ( int i = 0 ; i < sz ; i ++ ) { char ch = str . charAt ( i ) ; if ( inUnicode ) { unicode . append ( ch ) ; if ( unicode . length ( ) == 4 ) { int value = Integer . parseInt ( unicode . toString ( ) , 16 ) ; out . write ( ( char ) value ) ; unicode . setLength ( 0 ) ; inUnicode = false ; hadSlash = false ; } continue ; } if ( hadSlash ) { hadSlash = false ; switch ( ch ) { case '\\' : out . write ( '\\' ) ; break ; case '\'' : out . write ( '\'' ) ; break ; case '\"' : out . write ( '"' ) ; break ; case 'r' : out . write ( '\r' ) ; break ; case 'f' : out . write ( '\f' ) ; break ; case 't' : out . write ( '\t' ) ; break ; case 'n' : out . write ( '\n' ) ; break ; case 'b' : out . write ( '\b' ) ; break ; case 'u' : { inUnicode = true ; break ; } default : out . write ( ch ) ; break ; } continue ; } else if ( ch == '\\' ) { hadSlash = true ; continue ; } out . write ( ch ) ; } if ( hadSlash ) { out . write ( '\\' ) ; } } public static String unescapeJavaScript ( String str ) throws Exception { return unescapeJava ( str ) ; } public static void unescapeJavaScript ( Writer out , String str ) throws Exception { unescapeJava ( out , str ) ; } }
package io . vertx . core . impl ; import io . vertx . core . AsyncResult ; import io . vertx . core . Context ; import io . vertx . core . Handler ; import io . vertx . core . Vertx ; import io . vertx . core . VertxOptions ; import io . vertx . core . spi . VertxFactory ; public class VertxFactoryImpl implements VertxFactory { @ Override public Vertx vertx ( ) { return new VertxImpl ( ) ; } @ Override public Vertx vertx ( VertxOptions options ) { if ( options . isClustered ( ) ) { throw new IllegalArgumentException ( "Please use Vertx.clusteredVertx() to create a clustered Vert.x instance" ) ; } return new VertxImpl ( options ) ; } @ Override public void clusteredVertx ( VertxOptions options , final Handler < AsyncResult < Vertx > > resultHandler ) { options . setClustered ( true ) ; new VertxImpl ( options , resultHandler ) ; } @ Override public Context context ( ) { return VertxImpl . context ( ) ; } }
package io . vertx . core . impl ; import io . netty . util . concurrent . FastThreadLocalThread ; final class VertxThread extends FastThreadLocalThread { private final boolean worker ; private long execStart ; private ContextImpl context ; public VertxThread ( Runnable target , String name , boolean worker ) { super ( target , name ) ; this . worker = worker ; } ContextImpl getContext ( ) { return context ; } void setContext ( ContextImpl context ) { this . context = context ; } public final void executeStart ( ) { execStart = System . nanoTime ( ) ; } public final void executeEnd ( ) { execStart = 0 ; } public long startTime ( ) { return execStart ; } public boolean isWorker ( ) { return worker ; } }
package io . vertx . core . impl ; import io . vertx . core . Verticle ; import io . vertx . core . impl . verticle . CompilingClassLoader ; import io . vertx . core . spi . VerticleFactory ; public class JavaVerticleFactory implements VerticleFactory { @ Override public String prefix ( ) { return "java" ; } @ Override public Verticle createVerticle ( String verticleName , ClassLoader classLoader ) throws Exception { verticleName = VerticleFactory . removePrefix ( verticleName ) ; Class clazz ; if ( verticleName . endsWith ( ".java" ) ) { CompilingClassLoader compilingLoader = new CompilingClassLoader ( classLoader , verticleName ) ; String className = compilingLoader . resolveMainClassName ( ) ; clazz = compilingLoader . loadClass ( className ) ; } else { clazz = classLoader . loadClass ( verticleName ) ; } return ( Verticle ) clazz . newInstance ( ) ; } }
package io . vertx . core . impl ; import io . vertx . core . spi . cluster . ClusterManager ; public interface ExtendedClusterManager extends ClusterManager { void beforeLeave ( ) ; }
package io . vertx . core . impl ; import io . vertx . core . AsyncResult ; import io . vertx . core . Future ; import io . vertx . core . Handler ; class FutureImpl < T > implements Future < T > { private boolean failed ; private boolean succeeded ; private Handler < AsyncResult < T > > handler ; private T result ; private Throwable throwable ; FutureImpl ( ) { } FutureImpl ( Throwable t ) { if ( t == null ) { complete ( null ) ; } else { fail ( t ) ; } } FutureImpl ( String failureMessage , boolean failed ) { this ( new NoStackTraceThrowable ( failureMessage ) ) ; } FutureImpl ( T result ) { complete ( result ) ; } public T result ( ) { return result ; } public Throwable cause ( ) { return throwable ; } public boolean succeeded ( ) { return succeeded ; } public boolean failed ( ) { return failed ; } public boolean isComplete ( ) { return failed || succeeded ; } public void setHandler ( Handler < AsyncResult < T > > handler ) { this . handler = handler ; checkCallHandler ( ) ; } public void complete ( T result ) { checkComplete ( ) ; this . result = result ; succeeded = true ; checkCallHandler ( ) ; } @ Override public void complete ( ) { complete ( null ) ; } public void fail ( Throwable throwable ) { checkComplete ( ) ; this . throwable = throwable ; failed = true ; checkCallHandler ( ) ; } @ Override public void fail ( String failureMessage ) { fail ( new NoStackTraceThrowable ( failureMessage ) ) ; } private void checkCallHandler ( ) { if ( handler != null && isComplete ( ) ) { handler . handle ( this ) ; } } private void checkComplete ( ) { if ( succeeded || failed ) { throw new IllegalStateException ( "Result is already complete: " + ( succeeded ? "succeeded" : "failed" ) ) ; } } }
package io . vertx . test . core ; import io . vertx . core . Handler ; import io . vertx . core . streams . Pump ; import io . vertx . core . streams . ReadStream ; import io . vertx . core . streams . WriteStream ; import org . junit . Test ; import java . util . ArrayList ; import java . util . List ; import static org . junit . Assert . * ; public class PumpTest { @ Test public void testPumpBasic ( ) throws Exception { FakeReadStream < MyClass > rs = new FakeReadStream < > ( ) ; FakeWriteStream < MyClass > ws = new FakeWriteStream < > ( ) ; Pump p = Pump . pump ( rs , ws , 1001 ) ; for ( int i = 0 ; i < 10 ; i ++ ) { p . start ( ) ; List < MyClass > inp = new ArrayList < > ( ) ; for ( int j = 0 ; j < 10 ; j ++ ) { MyClass myClass = new MyClass ( ) ; inp . add ( myClass ) ; rs . addData ( myClass ) ; } assertEquals ( inp , ws . received ) ; assertFalse ( rs . paused ) ; assertEquals ( 0 , rs . pauseCount ) ; assertEquals ( 0 , rs . resumeCount ) ; p . stop ( ) ; ws . clearReceived ( ) ; MyClass myClass = new MyClass ( ) ; rs . addData ( myClass ) ; assertEquals ( 0 , ws . received . size ( ) ) ; } } @ Test public void testPumpPauseResume ( ) throws Exception { FakeReadStream < MyClass > rs = new FakeReadStream < > ( ) ; FakeWriteStream < MyClass > ws = new FakeWriteStream < > ( ) ; Pump p = Pump . pump ( rs , ws , 5 ) ; p . start ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { List < MyClass > inp = new ArrayList < > ( ) ; for ( int j = 0 ; j < 4 ; j ++ ) { MyClass myClass = new MyClass ( ) ; inp . add ( myClass ) ; rs . addData ( myClass ) ; assertFalse ( rs . paused ) ; assertEquals ( i , rs . pauseCount ) ; assertEquals ( i , rs . resumeCount ) ; } MyClass myClass = new MyClass ( ) ; inp . add ( myClass ) ; rs . addData ( myClass ) ; assertTrue ( rs . paused ) ; assertEquals ( i + 1 , rs . pauseCount ) ; assertEquals ( i , rs . resumeCount ) ; assertEquals ( inp , ws . received ) ; ws . clearReceived ( ) ; assertFalse ( rs . paused ) ; assertEquals ( i + 1 , rs . pauseCount ) ; assertEquals ( i + 1 , rs . resumeCount ) ; } } private class FakeReadStream < T > implements ReadStream < T > { private Handler < T > dataHandler ; private boolean paused ; int pauseCount ; int resumeCount ; void addData ( T data ) { if ( dataHandler != null ) { dataHandler . handle ( data ) ; } } public FakeReadStream handler ( Handler < T > handler ) { this . dataHandler = handler ; return this ; } public FakeReadStream pause ( ) { paused = true ; pauseCount ++ ; return this ; } public FakeReadStream pause ( Handler < Void > doneHandler ) { pause ( ) ; doneHandler . handle ( null ) ; return this ; } public FakeReadStream resume ( ) { paused = false ; resumeCount ++ ; return this ; } public FakeReadStream resume ( Handler < Void > doneHandler ) { resume ( ) ; doneHandler . handle ( null ) ; return this ; } public FakeReadStream exceptionHandler ( Handler < Throwable > handler ) { return this ; } public FakeReadStream endHandler ( Handler < Void > endHandler ) { return this ; } } private class FakeWriteStream < T > implements WriteStream < T > { int maxSize ; List < T > received = new ArrayList < > ( ) ; Handler < Void > drainHandler ; void clearReceived ( ) { boolean callDrain = writeQueueFull ( ) ; received = new ArrayList < > ( ) ; if ( callDrain && drainHandler != null ) { drainHandler . handle ( null ) ; } } public FakeWriteStream setWriteQueueMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public boolean writeQueueFull ( ) { return received . size ( ) >= maxSize ; } public FakeWriteStream drainHandler ( Handler < Void > handler ) { this . drainHandler = handler ; return this ; } public FakeWriteStream write ( T data ) { received . add ( data ) ; return this ; } public FakeWriteStream exceptionHandler ( Handler < Throwable > handler ) { return this ; } } static class MyClass { } }
package io . vertx . core . impl ; import java . io . IOException ; import java . net . URL ; import java . net . URLClassLoader ; import java . util . Collections ; import java . util . Enumeration ; import java . util . List ; public class IsolatingClassLoader extends URLClassLoader { private List < String > isolatedClasses ; public IsolatingClassLoader ( URL [ ] urls , ClassLoader parent , List < String > isolatedClasses ) { super ( urls , parent ) ; this . isolatedClasses = isolatedClasses ; } @ Override protected Class < ? > loadClass ( String name , boolean resolve ) throws ClassNotFoundException { synchronized ( getClassLoadingLock ( name ) ) { Class < ? > c = findLoadedClass ( name ) ; if ( c == null ) { if ( isIsolatedClass ( name ) ) { if ( isVertxOrSystemClass ( name ) ) { try { c = getParent ( ) . loadClass ( name ) ; } catch ( ClassNotFoundException e ) { } } if ( c == null ) { try { c = findClass ( name ) ; } catch ( ClassNotFoundException e ) { c = getParent ( ) . loadClass ( name ) ; } } if ( resolve ) { resolveClass ( c ) ; } } else { c = super . loadClass ( name , resolve ) ; } } return c ; } } private boolean isIsolatedClass ( String name ) { if ( isolatedClasses != null ) { for ( String isolated : isolatedClasses ) { if ( isolated . endsWith ( ".*" ) ) { String isolatedPackage = isolated . substring ( 0 , isolated . length ( ) - 1 ) ; String paramPackage = name . substring ( 0 , name . lastIndexOf ( '.' ) + 1 ) ; if ( paramPackage . startsWith ( isolatedPackage ) ) { return true ; } } else if ( isolated . equals ( name ) ) { return true ; } } } return false ; } @ Override public URL getResource ( String name ) { URL url = findResource ( name ) ; if ( url == null ) { url = super . getResource ( name ) ; } return url ; } @ Override public Enumeration < URL > getResources ( String name ) throws IOException { List < URL > resources = Collections . list ( findResources ( name ) ) ; if ( getParent ( ) != null ) { Enumeration < URL > parentResources = getParent ( ) . getResources ( name ) ; if ( parentResources . hasMoreElements ( ) ) { resources . addAll ( Collections . list ( parentResources ) ) ; } } return Collections . enumeration ( resources ) ; } private boolean isVertxOrSystemClass ( String name ) { return name . startsWith ( "java." ) || name . startsWith ( "javax." ) || name . startsWith ( "sun.*" ) || name . startsWith ( "com.sun." ) || name . startsWith ( "io.vertx.core" ) || name . startsWith ( "io.netty." ) || name . startsWith ( "com.fasterxml.jackson" ) ; } }
package io . vertx . core . impl ; public class Arguments { public static void require ( boolean condition , String message ) { if ( ! condition ) { throw new IllegalArgumentException ( message ) ; } } public static void requireInRange ( int number , int min , int max , String message ) { if ( number < min || number > max ) { throw new IllegalArgumentException ( message ) ; } } }
package io . vertx . core . impl ; import io . vertx . core . VertxException ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import java . util . Map ; import java . util . Timer ; import java . util . TimerTask ; import java . util . WeakHashMap ; public class BlockedThreadChecker { private static final Logger log = LoggerFactory . getLogger ( BlockedThreadChecker . class ) ; private static final Object O = new Object ( ) ; private Map < VertxThread , Object > threads = new WeakHashMap < > ( ) ; private final Timer timer ; BlockedThreadChecker ( long interval , long maxEventLoopExecTime , long maxWorkerExecTime , long warningExceptionTime ) { timer = new Timer ( "vertx-blocked-thread-checker" , true ) ; timer . schedule ( new TimerTask ( ) { @ Override public void run ( ) { long now = System . nanoTime ( ) ; for ( VertxThread thread : threads . keySet ( ) ) { long execStart = thread . startTime ( ) ; long dur = now - execStart ; final long timeLimit = thread . isWorker ( ) ? maxWorkerExecTime : maxEventLoopExecTime ; if ( execStart != 0 && dur > timeLimit ) { final String message = "Thread " + thread + " has been blocked for " + ( dur / 1000000 ) + " ms, time limit is " + ( timeLimit / 1000000 ) ; if ( dur <= warningExceptionTime ) { log . warn ( message ) ; } else { VertxException stackTrace = new VertxException ( "Thread blocked" ) ; stackTrace . setStackTrace ( thread . getStackTrace ( ) ) ; log . warn ( message , stackTrace ) ; } } } } } , interval , interval ) ; } public synchronized void registerThread ( VertxThread thread ) { threads . put ( thread , O ) ; } public void close ( ) { timer . cancel ( ) ; } }
package io . vertx . core . impl ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; public interface Closeable { void close ( Handler < AsyncResult < Void > > completionHandler ) ; void close ( Object completionHandler ) ; }
package io . vertx . core . impl ; import io . netty . channel . EventLoop ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . channel . socket . DatagramPacket ; import io . netty . util . ResourceLeakDetector ; import io . netty . util . concurrent . GenericFutureListener ; import io . vertx . core . * ; import io . vertx . core . Future ; import io . vertx . core . datagram . DatagramSocket ; import io . vertx . core . datagram . DatagramSocketOptions ; import io . vertx . core . datagram . impl . DatagramSocketImpl ; import io . vertx . core . dns . DnsClient ; import io . vertx . core . dns . impl . DnsClientImpl ; import io . vertx . core . eventbus . EventBus ; import io . vertx . core . eventbus . impl . EventBusImpl ; import io . vertx . core . file . FileSystem ; import io . vertx . core . file . impl . FileSystemImpl ; import io . vertx . core . file . impl . WindowsFileSystem ; import io . vertx . core . http . HttpClient ; import io . vertx . core . http . HttpClientOptions ; import io . vertx . core . http . HttpServer ; import io . vertx . core . http . HttpServerOptions ; import io . vertx . core . http . impl . HttpClientImpl ; import io . vertx . core . http . impl . HttpServerImpl ; import io . vertx . core . json . JsonObject ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . metrics . impl . DummyVertxMetrics ; import io . vertx . core . net . NetClient ; import io . vertx . core . net . NetClientOptions ; import io . vertx . core . net . NetServer ; import io . vertx . core . net . NetServerOptions ; import io . vertx . core . net . impl . NetClientImpl ; import io . vertx . core . net . impl . NetServerImpl ; import io . vertx . core . net . impl . ServerID ; import io . vertx . core . shareddata . SharedData ; import io . vertx . core . shareddata . impl . SharedDataImpl ; import io . vertx . core . spi . VerticleFactory ; import io . vertx . core . spi . VertxMetricsFactory ; import io . vertx . core . spi . cluster . AsyncMultiMap ; import io . vertx . core . spi . cluster . ClusterManager ; import io . vertx . core . spi . metrics . Metrics ; import io . vertx . core . spi . metrics . MetricsProvider ; import io . vertx . core . spi . metrics . VertxMetrics ; import java . io . File ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; public class VertxImpl implements VertxInternal , MetricsProvider { private static final Logger log = LoggerFactory . getLogger ( VertxImpl . class ) ; private static final String NETTY_IO_RATIO_PROPERTY_NAME = "vertx.nettyIORatio" ; private static final int NETTY_IO_RATIO = Integer . getInteger ( NETTY_IO_RATIO_PROPERTY_NAME , 50 ) ; static { ResourceLeakDetector . setLevel ( ResourceLeakDetector . Level . DISABLED ) ; System . setProperty ( "io.netty.noJdkZlibDecoder" , "false" ) ; } private final FileSystem fileSystem = getFileSystem ( ) ; private final SharedData sharedData ; private final VertxMetrics metrics ; private final ConcurrentMap < Long , InternalTimerHandler > timeouts = new ConcurrentHashMap < > ( ) ; private final AtomicLong timeoutCounter = new AtomicLong ( 0 ) ; private final ClusterManager clusterManager ; private final DeploymentManager deploymentManager ; private final FileResolver fileResolver ; private final Map < ServerID , HttpServerImpl > sharedHttpServers = new HashMap < > ( ) ; private final Map < ServerID , NetServerImpl > sharedNetServers = new HashMap < > ( ) ; private final ExecutorService workerPool ; private final ExecutorService internalBlockingPool ; private final OrderedExecutorFactory workerOrderedFact ; private final OrderedExecutorFactory internalOrderedFact ; private final ThreadFactory eventLoopThreadFactory ; private final NioEventLoopGroup eventLoopGroup ; private final BlockedThreadChecker checker ; private final boolean haEnabled ; private EventBusImpl eventBus ; private HAManager haManager ; private boolean closed ; VertxImpl ( ) { this ( new VertxOptions ( ) ) ; } VertxImpl ( VertxOptions options ) { this ( options , null ) ; } VertxImpl ( VertxOptions options , Handler < AsyncResult < Vertx > > resultHandler ) { checker = new BlockedThreadChecker ( options . getBlockedThreadCheckInterval ( ) , options . getMaxEventLoopExecuteTime ( ) , options . getMaxWorkerExecuteTime ( ) , options . getWarningExceptionTime ( ) ) ; eventLoopThreadFactory = new VertxThreadFactory ( "vert.x-eventloop-thread-" , checker , false ) ; eventLoopGroup = new NioEventLoopGroup ( options . getEventLoopPoolSize ( ) , eventLoopThreadFactory ) ; eventLoopGroup . setIoRatio ( NETTY_IO_RATIO ) ; workerPool = Executors . newFixedThreadPool ( options . getWorkerPoolSize ( ) , new VertxThreadFactory ( "vert.x-worker-thread-" , checker , true ) ) ; internalBlockingPool = Executors . newFixedThreadPool ( options . getInternalBlockingPoolSize ( ) , new VertxThreadFactory ( "vert.x-internal-blocking-" , checker , true ) ) ; workerOrderedFact = new OrderedExecutorFactory ( workerPool ) ; internalOrderedFact = new OrderedExecutorFactory ( internalBlockingPool ) ; this . fileResolver = new FileResolver ( this ) ; this . deploymentManager = new DeploymentManager ( this ) ; this . metrics = initialiseMetrics ( options ) ; this . haEnabled = options . isClustered ( ) && options . isHAEnabled ( ) ; if ( options . isClustered ( ) ) { this . clusterManager = getClusterManager ( options ) ; this . clusterManager . setVertx ( this ) ; clusterManager . < String , ServerID > getAsyncMultiMap ( "subs" , ar2 - > { if ( ar2 . succeeded ( ) ) { AsyncMultiMap < String , ServerID > subs = ar2 . result ( ) ; NetServer server = createNetServer ( new NetServerOptions ( ) . setPort ( options . getClusterPort ( ) ) . setHost ( options . getClusterHost ( ) ) ) ; EventBusImpl . EventBusNetServer ebServer = new EventBusImpl . EventBusNetServer ( server ) ; server . listen ( asyncResult - > { if ( asyncResult . succeeded ( ) ) { int publicPort = Integer . getInteger ( "vertx.cluster.public.port" , - 1 ) ; String publicHost = System . getProperty ( "vertx.cluster.public.host" , null ) ; int serverPort = publicPort == - 1 ? server . actualPort ( ) : publicPort ; String serverHost = publicHost == null ? options . getClusterHost ( ) : publicHost ; ServerID serverID = new ServerID ( serverPort , serverHost ) ; synchronized ( VertxImpl . this ) { haManager = new HAManager ( this , serverID , deploymentManager , clusterManager , options . getQuorumSize ( ) , options . getHAGroup ( ) , haEnabled ) ; eventBus = new EventBusImpl ( this , options . getClusterPingInterval ( ) , options . getClusterPingReplyInterval ( ) , clusterManager , haManager , subs , serverID , ebServer ) ; } if ( resultHandler != null ) { resultHandler . handle ( Future . succeededFuture ( this ) ) ; } } else { if ( resultHandler != null ) { resultHandler . handle ( Future . failedFuture ( asyncResult . cause ( ) ) ) ; } else { log . error ( asyncResult . cause ( ) ) ; } } } ) ; } else { if ( resultHandler != null ) { resultHandler . handle ( Future . failedFuture ( ar2 . cause ( ) ) ) ; } else { log . error ( ar2 . cause ( ) ) ; } } } ) ; } ) ; this . sharedData = new SharedDataImpl ( this , clusterManager ) ; } else { this . clusterManager = null ; this . sharedData = new SharedDataImpl ( this , null ) ; this . eventBus = new EventBusImpl ( this ) ; if ( resultHandler != null ) { resultHandler . handle ( Future . succeededFuture ( this ) ) ; } } } protected FileSystem getFileSystem ( ) { return Utils . isWindows ( ) ? new WindowsFileSystem ( this ) : new FileSystemImpl ( this ) ; } @ Override public DatagramSocket createDatagramSocket ( DatagramSocketOptions options ) { return new DatagramSocketImpl ( this , options ) ; } @ Override public DatagramSocket createDatagramSocket ( ) { return createDatagramSocket ( new DatagramSocketOptions ( ) ) ; } public NetServer createNetServer ( NetServerOptions options ) { return new NetServerImpl ( this , options ) ; } @ Override public NetServer createNetServer ( ) { return createNetServer ( new NetServerOptions ( ) ) ; } public NetClient createNetClient ( NetClientOptions options ) { return new NetClientImpl ( this , options ) ; } @ Override public NetClient createNetClient ( ) { return createNetClient ( new NetClientOptions ( ) ) ; } public FileSystem fileSystem ( ) { return fileSystem ; } public SharedData sharedData ( ) { return sharedData ; } public HttpServer createHttpServer ( HttpServerOptions serverOptions ) { return new HttpServerImpl ( this , serverOptions ) ; } @ Override public HttpServer createHttpServer ( ) { return createHttpServer ( new HttpServerOptions ( ) ) ; } public HttpClient createHttpClient ( HttpClientOptions options ) { return new HttpClientImpl ( this , options ) ; } @ Override public HttpClient createHttpClient ( ) { return createHttpClient ( new HttpClientOptions ( ) ) ; } public EventBus eventBus ( ) { if ( eventBus == null ) { synchronized ( this ) { return eventBus ; } } return eventBus ; } public long setPeriodic ( long delay , Handler < Long > handler ) { return scheduleTimeout ( getOrCreateContext ( ) , handler , delay , true ) ; } @ Override public TimeoutStream periodicStream ( long delay ) { return new TimeoutStreamImpl ( delay , true ) ; } public long setTimer ( long delay , Handler < Long > handler ) { return scheduleTimeout ( getOrCreateContext ( ) , handler , delay , false ) ; } @ Override public TimeoutStream timerStream ( long delay ) { return new TimeoutStreamImpl ( delay , false ) ; } public void runOnContext ( Handler < Void > task ) { ContextImpl context = getOrCreateContext ( ) ; context . runOnContext ( task ) ; } public ExecutorService getWorkerPool ( ) { return workerPool ; } public EventLoopGroup getEventLoopGroup ( ) { return eventLoopGroup ; } public ContextImpl getOrCreateContext ( ) { ContextImpl ctx = getContext ( ) ; if ( ctx == null ) { ctx = createEventLoopContext ( null , new JsonObject ( ) , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } return ctx ; } public Map < ServerID , HttpServerImpl > sharedHttpServers ( ) { return sharedHttpServers ; } public Map < ServerID , NetServerImpl > sharedNetServers ( ) { return sharedNetServers ; } @ Override public boolean isMetricsEnabled ( ) { return metrics != null && metrics . isEnabled ( ) ; } @ Override public Metrics getMetrics ( ) { return metrics ; } public boolean cancelTimer ( long id ) { InternalTimerHandler handler = timeouts . remove ( id ) ; if ( handler != null ) { handler . context . removeCloseHook ( handler ) ; return handler . cancel ( ) ; } else { return false ; } } public EventLoopContext createEventLoopContext ( String deploymentID , JsonObject config , ClassLoader tccl ) { return new EventLoopContext ( this , internalOrderedFact . getExecutor ( ) , workerOrderedFact . getExecutor ( ) , deploymentID , config , tccl ) ; } @ Override public DnsClient createDnsClient ( int port , String host ) { return new DnsClientImpl ( this , port , host ) ; } private VertxMetrics initialiseMetrics ( VertxOptions options ) { if ( options . getMetricsOptions ( ) != null && options . getMetricsOptions ( ) . isEnabled ( ) ) { ServiceLoader < VertxMetricsFactory > factories = ServiceLoader . load ( VertxMetricsFactory . class ) ; if ( factories . iterator ( ) . hasNext ( ) ) { VertxMetricsFactory factory = factories . iterator ( ) . next ( ) ; return factory . metrics ( this , options ) ; } else { log . warn ( "Metrics has been set to enabled but no VertxMetricsFactory found on classpath" ) ; } } return new DummyVertxMetrics ( ) ; } private ClusterManager getClusterManager ( VertxOptions options ) { if ( options . isClustered ( ) ) { if ( options . getClusterManager ( ) != null ) { return options . getClusterManager ( ) ; } else { ClusterManager mgr ; String clusterManagerClassName = System . getProperty ( "vertx.cluster.managerClass" ) ; if ( clusterManagerClassName != null ) { try { Class < ? > clazz = Class . forName ( clusterManagerClassName ) ; mgr = ( ClusterManager ) clazz . newInstance ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Failed to instantiate " + clusterManagerClassName , e ) ; } } else { ServiceLoader < ClusterManager > mgrs = ServiceLoader . load ( ClusterManager . class ) ; if ( ! mgrs . iterator ( ) . hasNext ( ) ) { throw new IllegalStateException ( "No ClusterManagerFactory instances found on classpath" ) ; } mgr = mgrs . iterator ( ) . next ( ) ; } return mgr ; } } else { return null ; } } private long scheduleTimeout ( ContextImpl context , Handler < Long > handler , long delay , boolean periodic ) { if ( delay < 1 ) { throw new IllegalArgumentException ( "Cannot schedule a timer with delay < 1 ms" ) ; } long timerId = timeoutCounter . getAndIncrement ( ) ; InternalTimerHandler task = new InternalTimerHandler ( timerId , handler , periodic , delay , context ) ; timeouts . put ( timerId , task ) ; context . addCloseHook ( task ) ; return timerId ; } public ContextImpl createWorkerContext ( boolean multiThreaded , String deploymentID , JsonObject config , ClassLoader tccl ) { if ( multiThreaded ) { return new MultiThreadedWorkerContext ( this , internalOrderedFact . getExecutor ( ) , workerPool , deploymentID , config , tccl ) ; } else { return new WorkerContext ( this , internalOrderedFact . getExecutor ( ) , workerOrderedFact . getExecutor ( ) , deploymentID , config , tccl ) ; } } public static Context context ( ) { Thread current = Thread . currentThread ( ) ; if ( current instanceof VertxThread ) { return ( ( VertxThread ) current ) . getContext ( ) ; } return null ; } public ContextImpl getContext ( ) { ContextImpl context = ( ContextImpl ) context ( ) ; if ( context != null && context . owner == this ) { return context ; } return null ; } public ClusterManager getClusterManager ( ) { return clusterManager ; } @ Override public void close ( ) { close ( null ) ; } @ Override public synchronized void close ( Handler < AsyncResult < Void > > completionHandler ) { if ( closed || eventBus == null ) { if ( completionHandler != null ) { completionHandler . handle ( Future . succeededFuture ( ) ) ; } return ; } closed = true ; deploymentManager . undeployAll ( ar - > { if ( haManager ( ) != null ) { haManager ( ) . stop ( ) ; } eventBus . close ( ar2 - > { Set < HttpServer > httpServers = new HashSet < > ( sharedHttpServers . values ( ) ) ; Set < NetServer > netServers = new HashSet < > ( sharedNetServers . values ( ) ) ; sharedHttpServers . clear ( ) ; sharedNetServers . clear ( ) ; int serverCount = httpServers . size ( ) + netServers . size ( ) ; AtomicInteger serverCloseCount = new AtomicInteger ( ) ; Handler < AsyncResult < Void > > serverCloseHandler = res - > { if ( res . failed ( ) ) { log . error ( "Failure in shutting down server" , res . cause ( ) ) ; } if ( serverCloseCount . incrementAndGet ( ) == serverCount ) { deleteCacheDirAndShutdown ( completionHandler ) ; } } ; for ( HttpServer server : httpServers ) { server . close ( serverCloseHandler ) ; } for ( NetServer server : netServers ) { server . close ( serverCloseHandler ) ; } if ( serverCount == 0 ) { deleteCacheDirAndShutdown ( completionHandler ) ; } } ) ; } ) ; } @ Override public void deployVerticle ( Verticle verticle ) { deployVerticle ( verticle , new DeploymentOptions ( ) , null ) ; } @ Override public void deployVerticle ( Verticle verticle , Handler < AsyncResult < String > > completionHandler ) { deployVerticle ( verticle , new DeploymentOptions ( ) , completionHandler ) ; } @ Override public void deployVerticle ( String name , Handler < AsyncResult < String > > completionHandler ) { deployVerticle ( name , new DeploymentOptions ( ) , completionHandler ) ; } @ Override public void deployVerticle ( Verticle verticle , DeploymentOptions options ) { deployVerticle ( verticle , options , null ) ; } @ Override public void deployVerticle ( Verticle verticle , DeploymentOptions options , Handler < AsyncResult < String > > completionHandler ) { deploymentManager . deployVerticle ( verticle , options , completionHandler ) ; } @ Override public void deployVerticle ( String name ) { deployVerticle ( name , new DeploymentOptions ( ) , null ) ; } @ Override public void deployVerticle ( String name , DeploymentOptions options ) { deployVerticle ( name , options , null ) ; } @ Override public void deployVerticle ( String name , DeploymentOptions options , Handler < AsyncResult < String > > completionHandler ) { if ( options . isHa ( ) && haManager ( ) != null && haManager ( ) . isEnabled ( ) ) { haManager ( ) . deployVerticle ( name , options , completionHandler ) ; } else { deploymentManager . deployVerticle ( name , options , completionHandler ) ; } } @ Override public String getNodeID ( ) { return clusterManager . getNodeID ( ) ; } @ Override public void undeploy ( String deploymentID ) { undeploy ( deploymentID , res - > { } ) ; } @ Override public void undeploy ( String deploymentID , Handler < AsyncResult < Void > > completionHandler ) { if ( haManager ( ) != null && haManager ( ) . isEnabled ( ) ) { haManager ( ) . removeFromHA ( deploymentID ) ; } deploymentManager . undeployVerticle ( deploymentID , completionHandler ) ; } @ Override public Set < String > deploymentIDs ( ) { return deploymentManager . deployments ( ) ; } @ Override public void registerVerticleFactory ( VerticleFactory factory ) { deploymentManager . registerVerticleFactory ( factory ) ; } @ Override public void unregisterVerticleFactory ( VerticleFactory factory ) { deploymentManager . unregisterVerticleFactory ( factory ) ; } @ Override public Set < VerticleFactory > verticleFactories ( ) { return deploymentManager . verticleFactories ( ) ; } @ Override public < T > void executeBlockingInternal ( Action < T > action , Handler < AsyncResult < T > > resultHandler ) { ContextImpl context = getOrCreateContext ( ) ; context . executeBlocking ( action , resultHandler ) ; } @ Override public < T > void executeBlocking ( Handler < Future < T > > blockingCodeHandler , boolean ordered , Handler < AsyncResult < T > > asyncResultHandler ) { ContextImpl context = getOrCreateContext ( ) ; context . executeBlocking ( blockingCodeHandler , ordered , asyncResultHandler ) ; } @ Override public < T > void executeBlocking ( Handler < Future < T > > blockingCodeHandler , Handler < AsyncResult < T > > asyncResultHandler ) { executeBlocking ( blockingCodeHandler , true , asyncResultHandler ) ; } @ Override public boolean isClustered ( ) { return clusterManager != null ; } @ Override public EventLoopGroup nettyEventLoopGroup ( ) { return eventLoopGroup ; } public void simulateKill ( ) { if ( haManager ( ) != null ) { haManager ( ) . simulateKill ( ) ; } } @ Override public Deployment getDeployment ( String deploymentID ) { return deploymentManager . getDeployment ( deploymentID ) ; } @ Override public synchronized void failoverCompleteHandler ( FailoverCompleteHandler failoverCompleteHandler ) { if ( haManager ( ) != null ) { haManager . setFailoverCompleteHandler ( failoverCompleteHandler ) ; } } @ Override public boolean isKilled ( ) { return haManager ( ) . isKilled ( ) ; } @ Override public void failDuringFailover ( boolean fail ) { if ( haManager ( ) != null ) { haManager ( ) . failDuringFailover ( fail ) ; } } @ Override public VertxMetrics metricsSPI ( ) { return metrics ; } @ Override public File resolveFile ( String fileName ) { return fileResolver . resolveFile ( fileName ) ; } @ SuppressWarnings ( "unchecked" ) private void deleteCacheDirAndShutdown ( Handler < AsyncResult < Void > > completionHandler ) { fileResolver . close ( res - > { workerPool . shutdownNow ( ) ; internalBlockingPool . shutdownNow ( ) ; eventLoopGroup . shutdownGracefully ( 0 , 10 , TimeUnit . SECONDS ) . addListener ( new GenericFutureListener ( ) { @ Override public void operationComplete ( io . netty . util . concurrent . Future future ) throws Exception { if ( ! future . isSuccess ( ) ) { log . warn ( "Failure in shutting down event loop group" , future . cause ( ) ) ; } if ( metrics != null ) { metrics . close ( ) ; } checker . close ( ) ; if ( completionHandler != null ) { eventLoopThreadFactory . newThread ( ( ) - > { completionHandler . handle ( Future . succeededFuture ( ) ) ; } ) . start ( ) ; } } } ) ; } ) ; } private HAManager haManager ( ) { if ( haManager == null && haEnabled ) { synchronized ( this ) { return haManager ; } } else { return haManager ; } } private class InternalTimerHandler implements Handler < Void > , Closeable { final Handler < Long > handler ; final boolean periodic ; final long timerID ; final ContextImpl context ; final java . util . concurrent . Future < ? > future ; boolean cancel ( ) { metrics . timerEnded ( timerID , true ) ; return future . cancel ( false ) ; } InternalTimerHandler ( long timerID , Handler < Long > runnable , boolean periodic , long delay , ContextImpl context ) { this . context = context ; this . timerID = timerID ; this . handler = runnable ; this . periodic = periodic ; EventLoop el = context . eventLoop ( ) ; Runnable toRun = ( ) - > context . runOnContext ( this ) ; if ( periodic ) { future = el . scheduleAtFixedRate ( toRun , delay , delay , TimeUnit . MILLISECONDS ) ; } else { future = el . schedule ( toRun , delay , TimeUnit . MILLISECONDS ) ; } metrics . timerCreated ( timerID ) ; } public void handle ( Void v ) { try { handler . handle ( timerID ) ; } finally { if ( ! periodic ) { cleanupNonPeriodic ( ) ; } } } private void cleanupNonPeriodic ( ) { VertxImpl . this . timeouts . remove ( timerID ) ; metrics . timerEnded ( timerID , false ) ; ContextImpl context = getContext ( ) ; if ( context != null ) { context . removeCloseHook ( this ) ; } } public void close ( Handler < AsyncResult < Void > > completionHandler ) { VertxImpl . this . timeouts . remove ( timerID ) ; cancel ( ) ; completionHandler . handle ( Future . succeededFuture ( ) ) ; } } private class TimeoutStreamImpl implements TimeoutStream , Handler < Long > { private final long delay ; private final boolean periodic ; private boolean paused ; private Long id ; private Handler < Long > handler ; private Handler < Void > endHandler ; public TimeoutStreamImpl ( long delay , boolean periodic ) { this . delay = delay ; this . periodic = periodic ; } @ Override public synchronized void handle ( Long event ) { try { if ( ! paused ) { handler . handle ( event ) ; } } finally { } } @ Override public TimeoutStream exceptionHandler ( Handler < Throwable > handler ) { return this ; } @ Override public void cancel ( ) { if ( id != null ) { VertxImpl . this . cancelTimer ( id ) ; } } @ Override public synchronized TimeoutStream handler ( Handler < Long > handler ) { if ( handler != null ) { if ( id != null ) { throw new IllegalStateException ( ) ; } this . handler = handler ; id = scheduleTimeout ( getOrCreateContext ( ) , this , delay , periodic ) ; } else { cancel ( ) ; } return this ; } @ Override public synchronized TimeoutStream pause ( ) { this . paused = true ; return this ; } @ Override public synchronized TimeoutStream resume ( ) { this . paused = false ; return null ; } @ Override public synchronized TimeoutStream endHandler ( Handler < Void > endHandler ) { this . endHandler = endHandler ; return this ; } @ Override public void handle ( DatagramPacket packet ) { } } }
package io . vertx . core . impl . verticle ; import javax . lang . model . element . Modifier ; import javax . lang . model . element . NestingKind ; import javax . tools . JavaFileObject ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import java . net . URI ; public class CustomJavaFileObject implements JavaFileObject { private final String binaryName ; private final Kind kind ; private final URI uri ; protected CustomJavaFileObject ( URI uri , Kind kind , String binaryName ) { this . uri = uri ; this . kind = kind ; this . binaryName = binaryName ; } public String binaryName ( ) { return binaryName ; } @ Override public InputStream openInputStream ( ) throws IOException { return uri . toURL ( ) . openStream ( ) ; } public Kind getKind ( ) { return kind ; } public NestingKind getNestingKind ( ) { return null ; } @ Override public URI toUri ( ) { return uri ; } public String getName ( ) { return toUri ( ) . getPath ( ) ; } public OutputStream openOutputStream ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } public Reader openReader ( boolean ignoreEncodingErrors ) throws IOException { throw new UnsupportedOperationException ( ) ; } public CharSequence getCharContent ( boolean ignoreEncodingErrors ) throws IOException { throw new UnsupportedOperationException ( ) ; } public Writer openWriter ( ) throws IOException { return new OutputStreamWriter ( openOutputStream ( ) ) ; } public long getLastModified ( ) { return 0L ; } public boolean delete ( ) { return false ; } public boolean isNameCompatible ( String simpleName , Kind kind ) { String name = simpleName + kind . extension ; return ( name . equals ( toUri ( ) . getPath ( ) ) || toUri ( ) . getPath ( ) . endsWith ( '/' + name ) ) && kind . equals ( getKind ( ) ) ; } public Modifier getAccessLevel ( ) { return null ; } @ Override public String toString ( ) { return getClass ( ) . getName ( ) + '[' + toUri ( ) + ']' ; } }
package io . vertx . core . impl . verticle ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import javax . tools . Diagnostic ; import javax . tools . DiagnosticCollector ; import javax . tools . JavaCompiler ; import javax . tools . JavaFileObject ; import javax . tools . JavaFileObject . Kind ; import javax . tools . StandardJavaFileManager ; import javax . tools . StandardLocation ; import javax . tools . ToolProvider ; import java . io . File ; import java . io . UnsupportedEncodingException ; import java . net . URL ; import java . net . URLDecoder ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class CompilingClassLoader extends ClassLoader { private static final Logger log = LoggerFactory . getLogger ( CompilingClassLoader . class ) ; private static final String JAVA_COMPILER_OPTIONS_PROP_NAME = "vertx.javaCompilerOptions" ; private final static List < String > COMPILER_OPTIONS ; static { String props = System . getProperty ( JAVA_COMPILER_OPTIONS_PROP_NAME ) ; if ( props != null ) { String [ ] array = props . split ( "," ) ; List < String > compilerProps = new ArrayList < > ( array . length ) ; for ( String prop : array ) { compilerProps . add ( prop . trim ( ) ) ; } COMPILER_OPTIONS = Collections . unmodifiableList ( compilerProps ) ; } else { COMPILER_OPTIONS = null ; } } private final JavaSourceContext javaSourceContext ; private final MemoryFileManager fileManager ; public CompilingClassLoader ( ClassLoader loader , String sourceName ) { super ( loader ) ; URL resource = getResource ( sourceName ) ; if ( resource == null ) { throw new RuntimeException ( "Resource not found: " + sourceName ) ; } File sourceFile ; try { sourceFile = new File ( URLDecoder . decode ( resource . getFile ( ) , "UTF-8" ) ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( "Failed to decode " + e . getMessage ( ) ) ; } if ( ! sourceFile . canRead ( ) ) { throw new RuntimeException ( "File not found: " + sourceFile . getAbsolutePath ( ) + " current dir is: " + new File ( "." ) . getAbsolutePath ( ) ) ; } this . javaSourceContext = new JavaSourceContext ( sourceFile ) ; try { DiagnosticCollector < JavaFileObject > diagnostics = new DiagnosticCollector < > ( ) ; JavaCompiler javaCompiler = ToolProvider . getSystemJavaCompiler ( ) ; if ( javaCompiler == null ) { throw new RuntimeException ( "Unable to detect java compiler, make sure you're using a JDK not a JRE!" ) ; } StandardJavaFileManager standardFileManager = javaCompiler . getStandardFileManager ( null , null , null ) ; standardFileManager . setLocation ( StandardLocation . SOURCE_PATH , Collections . singleton ( javaSourceContext . getSourceRoot ( ) ) ) ; fileManager = new MemoryFileManager ( loader , standardFileManager ) ; JavaFileObject javaFile = standardFileManager . getJavaFileForInput ( StandardLocation . SOURCE_PATH , resolveMainClassName ( ) , Kind . SOURCE ) ; JavaCompiler . CompilationTask task = javaCompiler . getTask ( null , fileManager , diagnostics , COMPILER_OPTIONS , null , Collections . singleton ( javaFile ) ) ; boolean valid = task . call ( ) ; if ( valid ) { for ( Diagnostic < ? > d : diagnostics . getDiagnostics ( ) ) { String code = d . getCode ( ) ; if ( code == null || ( ! code . startsWith ( "compiler.warn.annotation.method.not.found" ) && ! "compiler.warn.proc.processor.incompatible.source.version" . equals ( code ) ) ) { log . info ( d ) ; } } } else { for ( Diagnostic < ? > d : diagnostics . getDiagnostics ( ) ) { log . warn ( d ) ; } throw new RuntimeException ( "Compilation failed!" ) ; } } catch ( Exception e ) { throw new RuntimeException ( "Compilation failed" , e ) ; } } public String resolveMainClassName ( ) { return javaSourceContext . getClassName ( ) ; } @ Override protected Class < ? > findClass ( String name ) throws ClassNotFoundException { byte [ ] bytecode = getClassBytes ( name ) ; if ( bytecode == null ) { throw new ClassNotFoundException ( name ) ; } return defineClass ( name , bytecode , 0 , bytecode . length ) ; } public byte [ ] getClassBytes ( String name ) { return fileManager . getCompiledClass ( name ) ; } }
package io . vertx . core . impl . verticle ; import javax . tools . JavaFileObject . Kind ; import java . io . File ; import java . io . IOException ; import java . nio . charset . StandardCharsets ; import java . nio . file . Files ; public class JavaSourceContext { private final String className ; private final File sourceRoot ; public JavaSourceContext ( File file ) { String packageName = parsePackage ( file ) ; File rootDirectory = file . getParentFile ( ) ; if ( packageName != null ) { String [ ] pathTokens = packageName . split ( "\\." ) ; for ( int i = pathTokens . length - 1 ; i >= 0 ; i -- ) { String token = pathTokens [ i ] ; if ( ! token . equals ( rootDirectory . getName ( ) ) ) { throw new RuntimeException ( "Package structure does not match directory structure: " + token + " != " + rootDirectory . getName ( ) ) ; } rootDirectory = rootDirectory . getParentFile ( ) ; } } sourceRoot = rootDirectory ; String fileName = file . getName ( ) ; String className = fileName . substring ( 0 , fileName . length ( ) - Kind . SOURCE . extension . length ( ) ) ; if ( packageName != null ) { className = packageName + '.' + className ; } this . className = className ; } public File getSourceRoot ( ) { return sourceRoot ; } public String getClassName ( ) { return className ; } private static String parsePackage ( File file ) { try { String source = new String ( Files . readAllBytes ( file . toPath ( ) ) , StandardCharsets . UTF_8 ) ; source = source . replaceAll ( "//.*|(\"(?:\\\\[^\"]|\\\\\"|.)*?\")|(?s)/\\*.*?\\*/" , "$1 " ) ; for ( String line : source . split ( "\\r?\\n" ) ) { line = line . trim ( ) ; if ( ! line . isEmpty ( ) ) { int idx = line . indexOf ( "package " ) ; if ( idx != - 1 ) { return line . substring ( line . indexOf ( ' ' , idx ) , line . indexOf ( ';' , idx ) ) . trim ( ) ; } return null ; } } return null ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } }
package io . vertx . core . impl . verticle ; import javax . tools . JavaFileObject ; import java . io . File ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . net . JarURLConnection ; import java . net . URI ; import java . net . URL ; import java . net . URLDecoder ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . List ; import java . util . jar . JarEntry ; public class PackageHelper { private final static String CLASS_FILE = ".class" ; private final ClassLoader classLoader ; public PackageHelper ( ClassLoader classLoader ) { this . classLoader = classLoader ; } public List < JavaFileObject > find ( String packageName ) throws IOException { String javaPackageName = packageName . replaceAll ( "\\." , "/" ) ; List < JavaFileObject > result = new ArrayList < > ( ) ; Enumeration < URL > urlEnumeration = classLoader . getResources ( javaPackageName ) ; while ( urlEnumeration . hasMoreElements ( ) ) { URL resource = urlEnumeration . nextElement ( ) ; File directory ; try { directory = new File ( URLDecoder . decode ( resource . getFile ( ) , "UTF-8" ) ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( "Failed to decode " + e . getMessage ( ) ) ; } if ( directory . isDirectory ( ) ) { result . addAll ( browseDir ( packageName , directory ) ) ; } else { result . addAll ( browseJar ( resource ) ) ; } } return result ; } private static List < JavaFileObject > browseDir ( String packageName , File directory ) { List < JavaFileObject > result = new ArrayList < > ( ) ; for ( File childFile : directory . listFiles ( ) ) { if ( childFile . isFile ( ) && childFile . getName ( ) . endsWith ( CLASS_FILE ) ) { String binaryName = packageName + "." + childFile . getName ( ) . replaceAll ( CLASS_FILE + "$" , "" ) ; result . add ( new CustomJavaFileObject ( childFile . toURI ( ) , JavaFileObject . Kind . CLASS , binaryName ) ) ; } } return result ; } private static List < JavaFileObject > browseJar ( URL packageFolderURL ) { List < JavaFileObject > result = new ArrayList < > ( ) ; try { String jarUri = packageFolderURL . toExternalForm ( ) . split ( "!" ) [ 0 ] ; JarURLConnection jarConn = ( JarURLConnection ) packageFolderURL . openConnection ( ) ; String rootEntryName = jarConn . getEntryName ( ) ; int rootEnd = rootEntryName . length ( ) + 1 ; Enumeration < JarEntry > entryEnum = jarConn . getJarFile ( ) . entries ( ) ; while ( entryEnum . hasMoreElements ( ) ) { JarEntry jarEntry = entryEnum . nextElement ( ) ; String name = jarEntry . getName ( ) ; if ( name . startsWith ( rootEntryName ) && name . indexOf ( '/' , rootEnd ) == - 1 && name . endsWith ( CLASS_FILE ) ) { String binaryName = name . replaceAll ( "/" , "." ) . replaceAll ( CLASS_FILE + "$" , "" ) ; result . add ( new CustomJavaFileObject ( URI . create ( jarUri + "!/" + name ) , JavaFileObject . Kind . CLASS , binaryName ) ) ; } } } catch ( Exception e ) { throw new RuntimeException ( packageFolderURL + " is not a JAR file" , e ) ; } return result ; } }
package io . vertx . core . impl . verticle ; import javax . tools . FileObject ; import javax . tools . ForwardingJavaFileManager ; import javax . tools . JavaFileManager ; import javax . tools . JavaFileObject ; import javax . tools . SimpleJavaFileObject ; import javax . tools . StandardLocation ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; public class MemoryFileManager extends ForwardingJavaFileManager < JavaFileManager > { private final Map < String , ByteArrayOutputStream > compiledClasses = new HashMap < > ( ) ; private final PackageHelper helper ; public MemoryFileManager ( ClassLoader classLoader , JavaFileManager fileManager ) { super ( fileManager ) ; helper = new PackageHelper ( classLoader ) ; } @ Override public JavaFileObject getJavaFileForOutput ( Location location , final String className , JavaFileObject . Kind kind , FileObject sibling ) throws IOException { try { return new SimpleJavaFileObject ( new URI ( "" ) , kind ) { public OutputStream openOutputStream ( ) throws IOException { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; compiledClasses . put ( className , outputStream ) ; return outputStream ; } } ; } catch ( URISyntaxException e ) { throw new RuntimeException ( e ) ; } } public byte [ ] getCompiledClass ( String name ) { ByteArrayOutputStream bytes = compiledClasses . get ( name ) ; if ( bytes == null ) { return null ; } return bytes . toByteArray ( ) ; } @ Override public String inferBinaryName ( Location location , JavaFileObject file ) { if ( file instanceof CustomJavaFileObject ) { return ( ( CustomJavaFileObject ) file ) . binaryName ( ) ; } else { return super . inferBinaryName ( location , file ) ; } } @ Override public Iterable < JavaFileObject > list ( Location location , String packageName , Set < JavaFileObject . Kind > kinds , boolean recurse ) throws IOException { if ( location == StandardLocation . CLASS_PATH && kinds . contains ( JavaFileObject . Kind . CLASS ) ) { return helper . find ( packageName ) ; } return super . list ( location , packageName , kinds , recurse ) ; } }
package io . vertx . test . core ; import io . vertx . core . * ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . datagram . DatagramSocket ; import io . vertx . core . datagram . DatagramSocketOptions ; import io . vertx . core . eventbus . EventBus ; import io . vertx . core . eventbus . MessageConsumer ; import io . vertx . core . http . * ; import io . vertx . core . metrics . MetricsOptions ; import io . vertx . core . metrics . impl . DummyVertxMetrics ; import io . vertx . core . net . * ; import io . vertx . core . spi . metrics . * ; import org . junit . Ignore ; import org . junit . Test ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicReference ; import java . util . function . BiConsumer ; import java . util . function . Function ; public class MetricsContextTest extends AsyncTestBase { @ Test public void testFactory ( ) throws Exception { AtomicReference < Thread > metricsThread = new AtomicReference < > ( ) ; AtomicReference < Context > metricsContext = new AtomicReference < > ( ) ; ConfigurableMetricsFactory . delegate = ( vertx , options ) - > { metricsThread . set ( Thread . currentThread ( ) ) ; metricsContext . set ( Vertx . currentContext ( ) ) ; return new DummyVertxMetrics ( ) ; } ; Vertx vertx = Vertx . vertx ( new VertxOptions ( ) . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( true ) ) ) ; assertSame ( Thread . currentThread ( ) , metricsThread . get ( ) ) ; assertNull ( metricsContext . get ( ) ) ; } @ Test public void testFactoryInCluster ( ) throws Exception { AtomicReference < Thread > metricsThread = new AtomicReference < > ( ) ; AtomicReference < Context > metricsContext = new AtomicReference < > ( ) ; Thread testThread = Thread . currentThread ( ) ; ConfigurableMetricsFactory . delegate = ( vertx , options ) - > { metricsThread . set ( Thread . currentThread ( ) ) ; metricsContext . set ( Vertx . currentContext ( ) ) ; return new DummyVertxMetrics ( ) ; } ; Vertx . clusteredVertx ( new VertxOptions ( ) . setClustered ( true ) . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( true ) ) , onSuccess ( vertx - > { assertSame ( testThread , metricsThread . get ( ) ) ; assertNull ( metricsContext . get ( ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testHttpServerRequestEventLoop ( ) throws Exception { testHttpServerRequest ( eventLoopContextFactory , eventLoopChecker ) ; } @ Test public void testHttpServerRequestWorker ( ) throws Exception { testHttpServerRequest ( workerContextFactory , workerChecker ) ; } private void testHttpServerRequest ( Function < Vertx , Context > contextFactory , BiConsumer < Thread , Context > checker ) throws Exception { AtomicReference < Thread > expectedThread = new AtomicReference < > ( ) ; AtomicReference < Context > expectedContext = new AtomicReference < > ( ) ; AtomicBoolean requestBeginCalled = new AtomicBoolean ( ) ; AtomicBoolean responseEndCalled = new AtomicBoolean ( ) ; AtomicBoolean socketConnectedCalled = new AtomicBoolean ( ) ; AtomicBoolean socketDisconnectedCalled = new AtomicBoolean ( ) ; AtomicBoolean bytesReadCalled = new AtomicBoolean ( ) ; AtomicBoolean bytesWrittenCalled = new AtomicBoolean ( ) ; AtomicBoolean closeCalled = new AtomicBoolean ( ) ; ConfigurableMetricsFactory . delegate = ( vertx , options ) - > new DummyVertxMetrics ( ) { @ Override public HttpServerMetrics createMetrics ( HttpServer server , SocketAddress localAddress , HttpServerOptions options ) { return new DummyHttpServerMetrics ( ) { @ Override public Void requestBegin ( Void socketMetric , HttpServerRequest request ) { requestBeginCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; return null ; } @ Override public void responseEnd ( Void requestMetric , HttpServerResponse response ) { responseEndCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public Void connected ( SocketAddress remoteAddress ) { socketConnectedCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; return null ; } @ Override public void disconnected ( Void socketMetric , SocketAddress remoteAddress ) { socketDisconnectedCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesRead ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesReadCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesWritten ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesWrittenCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public boolean isEnabled ( ) { return true ; } @ Override public void close ( ) { closeCalled . set ( true ) ; } } ; } } ; CountDownLatch latch = new CountDownLatch ( 1 ) ; Vertx vertx = Vertx . vertx ( new VertxOptions ( ) . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( true ) ) ) ; Context ctx = contextFactory . apply ( vertx ) ; ctx . runOnContext ( v1 - > { HttpServer server = vertx . createHttpServer ( ) . requestHandler ( req - > { HttpServerResponse response = req . response ( ) ; response . setStatusCode ( 200 ) . setChunked ( true ) . write ( "bye" ) . end ( ) ; response . close ( ) ; } ) ; server . listen ( 8080 , "localhost" , onSuccess ( s - > { expectedThread . set ( Thread . currentThread ( ) ) ; expectedContext . set ( Vertx . currentContext ( ) ) ; latch . countDown ( ) ; } ) ) ; } ) ; awaitLatch ( latch ) ; HttpClient client = vertx . createHttpClient ( ) ; client . put ( 8080 , "localhost" , "/" , resp - > { resp . netSocket ( ) . closeHandler ( v - > { vertx . close ( v4 - > { assertTrue ( requestBeginCalled . get ( ) ) ; assertTrue ( responseEndCalled . get ( ) ) ; assertTrue ( bytesReadCalled . get ( ) ) ; assertTrue ( bytesWrittenCalled . get ( ) ) ; assertTrue ( socketConnectedCalled . get ( ) ) ; assertTrue ( socketDisconnectedCalled . get ( ) ) ; assertTrue ( closeCalled . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) . exceptionHandler ( err - > { fail ( err . getMessage ( ) ) ; } ) . setChunked ( true ) . write ( Buffer . buffer ( "hello" ) ) . end ( ) ; await ( ) ; } @ Test public void testHttpServerWebsocketEventLoop ( ) throws Exception { testHttpServerWebsocket ( eventLoopContextFactory , eventLoopChecker ) ; } @ Test public void testHttpServerWebsocketWorker ( ) throws Exception { testHttpServerWebsocket ( workerContextFactory , workerChecker ) ; } private void testHttpServerWebsocket ( Function < Vertx , Context > contextFactory , BiConsumer < Thread , Context > checker ) throws Exception { AtomicReference < Thread > expectedThread = new AtomicReference < > ( ) ; AtomicReference < Context > expectedContext = new AtomicReference < > ( ) ; AtomicBoolean websocketConnected = new AtomicBoolean ( ) ; AtomicBoolean websocketDisconnected = new AtomicBoolean ( ) ; AtomicBoolean socketConnectedCalled = new AtomicBoolean ( ) ; AtomicBoolean socketDisconnectedCalled = new AtomicBoolean ( ) ; AtomicBoolean bytesReadCalled = new AtomicBoolean ( ) ; AtomicBoolean bytesWrittenCalled = new AtomicBoolean ( ) ; AtomicBoolean closeCalled = new AtomicBoolean ( ) ; ConfigurableMetricsFactory . delegate = ( vertx , options ) - > new DummyVertxMetrics ( ) { @ Override public HttpServerMetrics createMetrics ( HttpServer server , SocketAddress localAddress , HttpServerOptions options ) { return new DummyHttpServerMetrics ( ) { @ Override public Void connected ( Void socketMetric , ServerWebSocket serverWebSocket ) { websocketConnected . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; return null ; } @ Override public void disconnected ( Void serverWebSocketMetric ) { websocketDisconnected . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public Void connected ( SocketAddress remoteAddress ) { socketConnectedCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; return null ; } @ Override public void disconnected ( Void socketMetric , SocketAddress remoteAddress ) { socketDisconnectedCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesRead ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesReadCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesWritten ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesWrittenCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public boolean isEnabled ( ) { return true ; } @ Override public void close ( ) { closeCalled . set ( true ) ; } } ; } } ; CountDownLatch latch = new CountDownLatch ( 1 ) ; Vertx vertx = Vertx . vertx ( new VertxOptions ( ) . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( true ) ) ) ; Context ctx = contextFactory . apply ( vertx ) ; ctx . runOnContext ( v1 - > { HttpServer server = vertx . createHttpServer ( ) . websocketHandler ( ws - > { ws . handler ( buf - > { ws . write ( Buffer . buffer ( "bye" ) ) ; } ) ; } ) ; server . listen ( 8080 , "localhost" , onSuccess ( s - > { expectedThread . set ( Thread . currentThread ( ) ) ; expectedContext . set ( Vertx . currentContext ( ) ) ; latch . countDown ( ) ; } ) ) ; } ) ; awaitLatch ( latch ) ; HttpClient client = vertx . createHttpClient ( ) ; client . websocket ( 8080 , "localhost" , "/" , ws - > { ws . handler ( buf - > { ws . closeHandler ( v - > { vertx . close ( v4 - > { assertTrue ( websocketConnected . get ( ) ) ; assertTrue ( websocketDisconnected . get ( ) ) ; assertTrue ( bytesReadCalled . get ( ) ) ; assertTrue ( bytesWrittenCalled . get ( ) ) ; assertTrue ( socketConnectedCalled . get ( ) ) ; assertTrue ( socketDisconnectedCalled . get ( ) ) ; assertTrue ( closeCalled . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; ws . close ( ) ; } ) ; ws . write ( Buffer . buffer ( "hello" ) ) ; } ) ; await ( ) ; } @ Test public void testHttpClientRequestEventLoop ( ) throws Exception { testHttpClientRequest ( eventLoopContextFactory , eventLoopChecker ) ; } @ Test public void testHttpClientRequestWorker ( ) throws Exception { testHttpClientRequest ( workerContextFactory , workerChecker ) ; } private void testHttpClientRequest ( Function < Vertx , Context > contextFactory , BiConsumer < Thread , Context > checker ) throws Exception { AtomicReference < Thread > expectedThread = new AtomicReference < > ( ) ; AtomicReference < Context > expectedContext = new AtomicReference < > ( ) ; AtomicBoolean requestBeginCalled = new AtomicBoolean ( ) ; AtomicBoolean responseEndCalled = new AtomicBoolean ( ) ; AtomicBoolean socketConnectedCalled = new AtomicBoolean ( ) ; AtomicBoolean socketDisconnectedCalled = new AtomicBoolean ( ) ; AtomicBoolean bytesReadCalled = new AtomicBoolean ( ) ; AtomicBoolean bytesWrittenCalled = new AtomicBoolean ( ) ; AtomicBoolean closeCalled = new AtomicBoolean ( ) ; ConfigurableMetricsFactory . delegate = ( vertx , options ) - > new DummyVertxMetrics ( ) { @ Override public HttpClientMetrics createMetrics ( HttpClient client , HttpClientOptions options ) { return new DummyHttpClientMetrics ( ) { @ Override public Void requestBegin ( Void socketMetric , SocketAddress localAddress , SocketAddress remoteAddress , HttpClientRequest request ) { requestBeginCalled . set ( true ) ; return null ; } @ Override public void responseEnd ( Void requestMetric , HttpClientResponse response ) { responseEndCalled . set ( true ) ; } @ Override public Void connected ( SocketAddress remoteAddress ) { socketConnectedCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; return null ; } @ Override public void disconnected ( Void socketMetric , SocketAddress remoteAddress ) { socketDisconnectedCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesRead ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesReadCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesWritten ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesWrittenCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void close ( ) { closeCalled . set ( true ) ; } @ Override public boolean isEnabled ( ) { return true ; } } ; } } ; Vertx vertx = Vertx . vertx ( new VertxOptions ( ) . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( true ) ) ) ; HttpServer server = vertx . createHttpServer ( ) ; server . requestHandler ( req - > { req . endHandler ( buf - > { HttpServerResponse resp = req . response ( ) ; resp . setChunked ( true ) . write ( Buffer . buffer ( "bye" ) ) . end ( ) ; resp . close ( ) ; } ) ; } ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; server . listen ( 8080 , "localhost" , onSuccess ( s - > { latch . countDown ( ) ; } ) ) ; awaitLatch ( latch ) ; Context ctx = contextFactory . apply ( vertx ) ; ctx . runOnContext ( v1 - > { expectedThread . set ( Thread . currentThread ( ) ) ; expectedContext . set ( Vertx . currentContext ( ) ) ; HttpClient client = vertx . createHttpClient ( ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; HttpClientRequest req = client . put ( 8080 , "localhost" , "/" ) ; req . handler ( resp - > { executeInVanillaThread ( ( ) - > { client . close ( ) ; vertx . close ( v2 - > { assertTrue ( requestBeginCalled . get ( ) ) ; assertTrue ( responseEndCalled . get ( ) ) ; assertTrue ( socketConnectedCalled . get ( ) ) ; assertTrue ( socketDisconnectedCalled . get ( ) ) ; assertTrue ( bytesReadCalled . get ( ) ) ; assertTrue ( bytesWrittenCalled . get ( ) ) ; assertTrue ( closeCalled . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; req . setChunked ( true ) . write ( "hello" ) ; req . end ( ) ; } ) ; await ( ) ; } @ Test public void testHttpClientWebsocketEventLoop ( ) throws Exception { testHttpClientWebsocket ( eventLoopContextFactory , eventLoopChecker ) ; } @ Test @ Ignore public void testHttpClientWebsocketWorker ( ) throws Exception { testHttpClientWebsocket ( workerContextFactory , workerChecker ) ; } private void testHttpClientWebsocket ( Function < Vertx , Context > contextFactory , BiConsumer < Thread , Context > checker ) throws Exception { AtomicReference < Thread > expectedThread = new AtomicReference < > ( ) ; AtomicReference < Context > expectedContext = new AtomicReference < > ( ) ; AtomicBoolean websocketConnected = new AtomicBoolean ( ) ; AtomicBoolean websocketDisconnected = new AtomicBoolean ( ) ; AtomicBoolean socketConnectedCalled = new AtomicBoolean ( ) ; AtomicBoolean socketDisconnectedCalled = new AtomicBoolean ( ) ; AtomicBoolean bytesReadCalled = new AtomicBoolean ( ) ; AtomicBoolean bytesWrittenCalled = new AtomicBoolean ( ) ; AtomicBoolean closeCalled = new AtomicBoolean ( ) ; ConfigurableMetricsFactory . delegate = ( vertx , options ) - > new DummyVertxMetrics ( ) { @ Override public HttpClientMetrics createMetrics ( HttpClient client , HttpClientOptions options ) { return new DummyHttpClientMetrics ( ) { @ Override public Void connected ( Void socketMetric , WebSocket webSocket ) { websocketConnected . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; return null ; } @ Override public void disconnected ( Void webSocketMetric ) { websocketDisconnected . set ( true ) ; } @ Override public Void connected ( SocketAddress remoteAddress ) { socketConnectedCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; return null ; } @ Override public void disconnected ( Void socketMetric , SocketAddress remoteAddress ) { socketDisconnectedCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesRead ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesReadCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesWritten ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesWrittenCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void close ( ) { closeCalled . set ( true ) ; } @ Override public boolean isEnabled ( ) { return true ; } } ; } } ; Vertx vertx = Vertx . vertx ( new VertxOptions ( ) . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( true ) ) ) ; HttpServer server = vertx . createHttpServer ( ) ; server . websocketHandler ( ws - > { ws . handler ( buf - > { ws . write ( Buffer . buffer ( "bye" ) ) ; } ) ; } ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; server . listen ( 8080 , "localhost" , onSuccess ( s - > { latch . countDown ( ) ; } ) ) ; awaitLatch ( latch ) ; Context ctx = contextFactory . apply ( vertx ) ; ctx . runOnContext ( v1 - > { expectedThread . set ( Thread . currentThread ( ) ) ; expectedContext . set ( Vertx . currentContext ( ) ) ; HttpClient client = vertx . createHttpClient ( ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; client . websocket ( 8080 , "localhost" , "/" , ws - > { ws . handler ( buf - > { ws . closeHandler ( v2 - > { executeInVanillaThread ( ( ) - > { client . close ( ) ; vertx . close ( v3 - > { assertTrue ( websocketConnected . get ( ) ) ; assertTrue ( websocketDisconnected . get ( ) ) ; assertTrue ( socketConnectedCalled . get ( ) ) ; assertTrue ( socketDisconnectedCalled . get ( ) ) ; assertTrue ( bytesReadCalled . get ( ) ) ; assertTrue ( bytesWrittenCalled . get ( ) ) ; assertTrue ( closeCalled . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; ws . close ( ) ; } ) ; ws . write ( Buffer . buffer ( "hello" ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testNetServerEventLoop ( ) throws Exception { testNetServer ( eventLoopContextFactory , eventLoopChecker ) ; } @ Test public void testNetServerWorker ( ) throws Exception { testNetServer ( workerContextFactory , workerChecker ) ; } private void testNetServer ( Function < Vertx , Context > contextFactory , BiConsumer < Thread , Context > checker ) throws Exception { AtomicReference < Thread > expectedThread = new AtomicReference < > ( ) ; AtomicReference < Context > expectedContext = new AtomicReference < > ( ) ; AtomicBoolean socketConnectedCalled = new AtomicBoolean ( ) ; AtomicBoolean socketDisconnectedCalled = new AtomicBoolean ( ) ; AtomicBoolean bytesReadCalled = new AtomicBoolean ( ) ; AtomicBoolean bytesWrittenCalled = new AtomicBoolean ( ) ; AtomicBoolean closeCalled = new AtomicBoolean ( ) ; ConfigurableMetricsFactory . delegate = ( vertx , options ) - > new DummyVertxMetrics ( ) { @ Override public TCPMetrics createMetrics ( NetServer server , SocketAddress localAddress , NetServerOptions options ) { return new DummyTCPMetrics ( ) { @ Override public Void connected ( SocketAddress remoteAddress ) { socketConnectedCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; return null ; } @ Override public void disconnected ( Void socketMetric , SocketAddress remoteAddress ) { socketDisconnectedCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesRead ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesReadCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesWritten ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesWrittenCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public boolean isEnabled ( ) { return true ; } @ Override public void close ( ) { closeCalled . set ( true ) ; } } ; } } ; CountDownLatch latch = new CountDownLatch ( 1 ) ; Vertx vertx = Vertx . vertx ( new VertxOptions ( ) . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( true ) ) ) ; Context ctx = contextFactory . apply ( vertx ) ; ctx . runOnContext ( v1 - > { NetServer server = vertx . createNetServer ( ) . connectHandler ( so - > { so . handler ( buf - > { so . write ( "bye" ) ; } ) ; } ) ; server . listen ( 1234 , "localhost" , onSuccess ( s - > { expectedThread . set ( Thread . currentThread ( ) ) ; expectedContext . set ( Vertx . currentContext ( ) ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; latch . countDown ( ) ; } ) ) ; } ) ; awaitLatch ( latch ) ; NetClient client = vertx . createNetClient ( ) ; client . connect ( 1234 , "localhost" , onSuccess ( so - > { so . handler ( buf - > { so . closeHandler ( v - > { executeInVanillaThread ( ( ) - > { vertx . close ( v4 - > { assertTrue ( bytesReadCalled . get ( ) ) ; assertTrue ( bytesWrittenCalled . get ( ) ) ; assertTrue ( socketConnectedCalled . get ( ) ) ; assertTrue ( socketDisconnectedCalled . get ( ) ) ; assertTrue ( closeCalled . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; so . close ( ) ; } ) ; so . write ( "hello" ) ; } ) ) ; await ( ) ; } @ Test public void testNetClientEventLoop ( ) throws Exception { testNetClient ( eventLoopContextFactory , eventLoopChecker ) ; } @ Test public void testNetClientWorker ( ) throws Exception { testNetClient ( workerContextFactory , workerChecker ) ; } private void testNetClient ( Function < Vertx , Context > contextFactory , BiConsumer < Thread , Context > checker ) throws Exception { AtomicReference < Thread > expectedThread = new AtomicReference < > ( ) ; AtomicReference < Context > expectedContext = new AtomicReference < > ( ) ; AtomicBoolean socketConnectedCalled = new AtomicBoolean ( ) ; AtomicBoolean socketDisconnectedCalled = new AtomicBoolean ( ) ; AtomicBoolean bytesReadCalled = new AtomicBoolean ( ) ; AtomicBoolean bytesWrittenCalled = new AtomicBoolean ( ) ; AtomicBoolean closeCalled = new AtomicBoolean ( ) ; ConfigurableMetricsFactory . delegate = ( vertx , options ) - > new DummyVertxMetrics ( ) { @ Override public TCPMetrics createMetrics ( NetClient client , NetClientOptions options ) { return new DummyTCPMetrics ( ) { @ Override public Void connected ( SocketAddress remoteAddress ) { socketConnectedCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; return null ; } @ Override public void disconnected ( Void socketMetric , SocketAddress remoteAddress ) { socketDisconnectedCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesRead ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesReadCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesWritten ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesWrittenCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public boolean isEnabled ( ) { return true ; } @ Override public void close ( ) { closeCalled . set ( true ) ; } } ; } } ; CountDownLatch latch = new CountDownLatch ( 1 ) ; Vertx vertx = Vertx . vertx ( new VertxOptions ( ) . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( true ) ) ) ; Context ctx = contextFactory . apply ( vertx ) ; NetServer server = vertx . createNetServer ( ) . connectHandler ( so - > { so . handler ( buf - > { so . write ( "bye" ) ; } ) ; } ) ; server . listen ( 1234 , "localhost" , onSuccess ( s - > { latch . countDown ( ) ; } ) ) ; awaitLatch ( latch ) ; ctx . runOnContext ( v1 - > { NetClient client = vertx . createNetClient ( ) ; expectedThread . set ( Thread . currentThread ( ) ) ; expectedContext . set ( Vertx . currentContext ( ) ) ; client . connect ( 1234 , "localhost" , onSuccess ( so - > { so . handler ( buf - > { so . closeHandler ( v - > { assertTrue ( bytesReadCalled . get ( ) ) ; assertTrue ( bytesWrittenCalled . get ( ) ) ; assertTrue ( socketConnectedCalled . get ( ) ) ; assertTrue ( socketDisconnectedCalled . get ( ) ) ; executeInVanillaThread ( ( ) - > { client . close ( ) ; vertx . close ( v4 - > { assertTrue ( closeCalled . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; so . close ( ) ; } ) ; so . write ( "hello" ) ; } ) ) ; } ) ; await ( ) ; } @ Test public void testDatagramEventLoop ( ) throws Exception { testDatagram ( eventLoopContextFactory , eventLoopChecker ) ; } @ Test public void testDatagramWorker ( ) throws Exception { testDatagram ( workerContextFactory , workerChecker ) ; } private void testDatagram ( Function < Vertx , Context > contextFactory , BiConsumer < Thread , Context > checker ) { AtomicReference < Thread > expectedThread = new AtomicReference < > ( ) ; AtomicReference < Context > expectedContext = new AtomicReference < > ( ) ; AtomicBoolean listening = new AtomicBoolean ( ) ; AtomicBoolean bytesReadCalled = new AtomicBoolean ( ) ; AtomicBoolean bytesWrittenCalled = new AtomicBoolean ( ) ; AtomicBoolean closeCalled = new AtomicBoolean ( ) ; ConfigurableMetricsFactory . delegate = ( vertx , options ) - > new DummyVertxMetrics ( ) { @ Override public DatagramSocketMetrics createMetrics ( DatagramSocket socket , DatagramSocketOptions options ) { return new DummyDatagramMetrics ( ) { @ Override public void listening ( SocketAddress localAddress ) { listening . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesRead ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesReadCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void bytesWritten ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { bytesWrittenCalled . set ( true ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; } @ Override public void close ( ) { closeCalled . set ( true ) ; } @ Override public boolean isEnabled ( ) { return true ; } } ; } } ; Vertx vertx = Vertx . vertx ( new VertxOptions ( ) . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( true ) ) ) ; Context ctx = contextFactory . apply ( vertx ) ; ctx . runOnContext ( v1 - > { expectedThread . set ( Thread . currentThread ( ) ) ; expectedContext . set ( Vertx . currentContext ( ) ) ; DatagramSocket socket = vertx . createDatagramSocket ( ) ; socket . listen ( 1234 , "localhost" , ar1 - > { assertTrue ( ar1 . succeeded ( ) ) ; checker . accept ( expectedThread . get ( ) , expectedContext . get ( ) ) ; socket . handler ( packet - > { assertTrue ( listening . get ( ) ) ; assertTrue ( bytesReadCalled . get ( ) ) ; assertTrue ( bytesWrittenCalled . get ( ) ) ; executeInVanillaThread ( ( ) - > { socket . close ( ar2 - > { assertTrue ( closeCalled . get ( ) ) ; assertTrue ( ar2 . succeeded ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; socket . send ( Buffer . buffer ( "msg" ) , 1234 , "localhost" , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testEventBusLifecycle ( ) { AtomicBoolean closeCalled = new AtomicBoolean ( ) ; ConfigurableMetricsFactory . delegate = ( vertx , options ) - > new DummyVertxMetrics ( ) { @ Override public EventBusMetrics createMetrics ( EventBus eventBus ) { return new DummyEventBusMetrics ( ) { @ Override public boolean isEnabled ( ) { return true ; } @ Override public void close ( ) { closeCalled . set ( true ) ; } } ; } } ; Vertx vertx = Vertx . vertx ( new VertxOptions ( ) . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( true ) ) ) ; vertx . eventBus ( ) ; executeInVanillaThread ( ( ) - > { vertx . close ( onSuccess ( v - > { assertTrue ( closeCalled . get ( ) ) ; testComplete ( ) ; } ) ) ; } ) ; await ( ) ; } @ Test public void testMessageHandler ( ) { testMessageHandler ( ( vertx , handler ) - > handler . handle ( null ) , eventLoopChecker ) ; } @ Test public void testMessageHandlerEventLoop ( ) { testMessageHandler ( ( vertx , handler ) - > eventLoopContextFactory . apply ( vertx ) . runOnContext ( handler ) , eventLoopChecker ) ; } private void testMessageHandler ( BiConsumer < Vertx , Handler < Void > > runOnContext , BiConsumer < Thread , Context > checker ) { AtomicReference < Thread > consumerThread = new AtomicReference < > ( ) ; AtomicReference < Context > consumerContext = new AtomicReference < > ( ) ; AtomicBoolean registeredCalled = new AtomicBoolean ( ) ; AtomicBoolean unregisteredCalled = new AtomicBoolean ( ) ; AtomicBoolean beginHandleCalled = new AtomicBoolean ( ) ; AtomicBoolean endHandleCalled = new AtomicBoolean ( ) ; ConfigurableMetricsFactory . delegate = ( vertx , options ) - > new DummyVertxMetrics ( ) { @ Override public EventBusMetrics createMetrics ( EventBus eventBus ) { return new DummyEventBusMetrics ( ) { @ Override public boolean isEnabled ( ) { return true ; } @ Override public Void handlerRegistered ( String address , boolean replyHandler ) { registeredCalled . set ( true ) ; return null ; } @ Override public void handlerUnregistered ( Void handler ) { unregisteredCalled . set ( true ) ; } @ Override public void beginHandleMessage ( Void handler , boolean local ) { consumerThread . set ( Thread . currentThread ( ) ) ; consumerContext . set ( Vertx . currentContext ( ) ) ; beginHandleCalled . set ( true ) ; } @ Override public void endHandleMessage ( Void handler , Throwable failure ) { endHandleCalled . set ( true ) ; checker . accept ( consumerThread . get ( ) , consumerContext . get ( ) ) ; } } ; } } ; Vertx vertx = Vertx . vertx ( new VertxOptions ( ) . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( true ) ) ) ; EventBus eb = vertx . eventBus ( ) ; runOnContext . accept ( vertx , v - > { MessageConsumer < Object > consumer = eb . consumer ( "the_address" ) ; consumer . handler ( msg - > { checker . accept ( consumerThread . get ( ) , consumerContext . get ( ) ) ; executeInVanillaThread ( ( ) - > { vertx . getOrCreateContext ( ) . runOnContext ( v2 - > { consumer . unregister ( onSuccess ( v3 - > { assertTrue ( registeredCalled . get ( ) ) ; assertTrue ( beginHandleCalled . get ( ) ) ; assertTrue ( endHandleCalled . get ( ) ) ; waitUntil ( ( ) - > unregisteredCalled . get ( ) ) ; testComplete ( ) ; } ) ) ; } ) ; } ) ; } ) . completionHandler ( onSuccess ( v2 - > { eb . send ( "the_address" , "the_msg" ) ; } ) ) ; } ) ; await ( ) ; } @ Test public void testDeployEventLoop ( ) { testDeploy ( false , false , eventLoopChecker ) ; } @ Test public void testDeployWorker ( ) { testDeploy ( true , false , workerChecker ) ; } @ Test public void testDeployMultiThreadedWorker ( ) { testDeploy ( true , true , workerChecker ) ; } private void testDeploy ( boolean worker , boolean multiThreaded , BiConsumer < Thread , Context > checker ) { AtomicReference < Thread > verticleThread = new AtomicReference < > ( ) ; AtomicReference < Context > verticleContext = new AtomicReference < > ( ) ; AtomicBoolean deployedCalled = new AtomicBoolean ( ) ; AtomicBoolean undeployedCalled = new AtomicBoolean ( ) ; ConfigurableMetricsFactory . delegate = ( vertx , options ) - > new DummyVertxMetrics ( ) { @ Override public void verticleDeployed ( Verticle verticle ) { deployedCalled . set ( true ) ; checker . accept ( verticleThread . get ( ) , verticleContext . get ( ) ) ; } @ Override public void verticleUndeployed ( Verticle verticle ) { undeployedCalled . set ( true ) ; checker . accept ( verticleThread . get ( ) , verticleContext . get ( ) ) ; } } ; Vertx vertx = Vertx . vertx ( new VertxOptions ( ) . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( true ) ) ) ; vertx . deployVerticle ( new AbstractVerticle ( ) { @ Override public void start ( ) throws Exception { verticleThread . set ( Thread . currentThread ( ) ) ; verticleContext . set ( Vertx . currentContext ( ) ) ; } } , new DeploymentOptions ( ) . setWorker ( worker ) . setMultiThreaded ( multiThreaded ) , ar1 - > { assertTrue ( ar1 . succeeded ( ) ) ; vertx . undeploy ( ar1 . result ( ) , ar2 - > { assertTrue ( ar1 . succeeded ( ) ) ; assertTrue ( deployedCalled . get ( ) ) ; assertTrue ( undeployedCalled . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } private void executeInVanillaThread ( Runnable task ) { new Thread ( task ) . start ( ) ; } private Function < Vertx , Context > eventLoopContextFactory = Vertx : : getOrCreateContext ; private BiConsumer < Thread , Context > eventLoopChecker = ( thread , ctx ) - > { assertSame ( Vertx . currentContext ( ) , ctx ) ; assertSame ( Thread . currentThread ( ) , thread ) ; } ; private Function < Vertx , Context > workerContextFactory = vertx - > { AtomicReference < Context > ctx = new AtomicReference < > ( ) ; vertx . deployVerticle ( new AbstractVerticle ( ) { @ Override public void start ( ) throws Exception { ctx . set ( context ) ; super . start ( ) ; } } , new DeploymentOptions ( ) . setWorker ( true ) ) ; waitUntil ( ( ) - > ctx . get ( ) != null ) ; return ctx . get ( ) ; } ; private BiConsumer < Thread , Context > workerChecker = ( thread , ctx ) - > { assertSame ( Vertx . currentContext ( ) , ctx ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; } ; }
package io . vertx . core . datagram ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . impl . Arguments ; import io . vertx . core . json . JsonObject ; import io . vertx . core . net . NetworkOptions ; @ DataObject public class DatagramSocketOptions extends NetworkOptions { public static final boolean DEFAULT_BROADCAST = false ; public static final boolean DEFAULT_LOOPBACK_MODE_DISABLED = true ; public static final int DEFAULT_MULTICAST_TIME_TO_LIVE = - 1 ; public static final String DEFAULT_MULTICAST_NETWORK_INTERFACE = null ; public static final boolean DEFAULT_REUSE_ADDRESS = false ; public static final boolean DEFAULT_IPV6 = false ; private boolean broadcast ; private boolean loopbackModeDisabled ; private int multicastTimeToLive ; private String multicastNetworkInterface ; private boolean ipV6 ; public DatagramSocketOptions ( ) { super ( ) ; setReuseAddress ( DEFAULT_REUSE_ADDRESS ) ; broadcast = DEFAULT_BROADCAST ; loopbackModeDisabled = DEFAULT_LOOPBACK_MODE_DISABLED ; multicastTimeToLive = DEFAULT_MULTICAST_TIME_TO_LIVE ; multicastNetworkInterface = DEFAULT_MULTICAST_NETWORK_INTERFACE ; ipV6 = DEFAULT_IPV6 ; } public DatagramSocketOptions ( DatagramSocketOptions other ) { super ( other ) ; this . broadcast = other . isBroadcast ( ) ; this . loopbackModeDisabled = other . isLoopbackModeDisabled ( ) ; this . multicastTimeToLive = other . getMulticastTimeToLive ( ) ; this . multicastNetworkInterface = other . getMulticastNetworkInterface ( ) ; this . ipV6 = other . isIpV6 ( ) ; } public DatagramSocketOptions ( JsonObject json ) { super ( json ) ; this . broadcast = json . getBoolean ( "broadcast" , DEFAULT_BROADCAST ) ; this . loopbackModeDisabled = json . getBoolean ( "loopbackModeDisabled" , DEFAULT_LOOPBACK_MODE_DISABLED ) ; this . multicastTimeToLive = json . getInteger ( "multicastTimeToLive" , DEFAULT_MULTICAST_TIME_TO_LIVE ) ; this . multicastNetworkInterface = json . getString ( "multicastNetworkInterface" , DEFAULT_MULTICAST_NETWORK_INTERFACE ) ; this . ipV6 = json . getBoolean ( "ipV6" , DEFAULT_IPV6 ) ; setReuseAddress ( json . getBoolean ( "reuseAddress" , DEFAULT_REUSE_ADDRESS ) ) ; } @ Override public int getSendBufferSize ( ) { return super . getSendBufferSize ( ) ; } @ Override public DatagramSocketOptions setSendBufferSize ( int sendBufferSize ) { super . setSendBufferSize ( sendBufferSize ) ; return this ; } @ Override public int getReceiveBufferSize ( ) { return super . getReceiveBufferSize ( ) ; } @ Override public DatagramSocketOptions setReceiveBufferSize ( int receiveBufferSize ) { super . setReceiveBufferSize ( receiveBufferSize ) ; return this ; } @ Override public DatagramSocketOptions setReuseAddress ( boolean reuseAddress ) { super . setReuseAddress ( reuseAddress ) ; return this ; } @ Override public int getTrafficClass ( ) { return super . getTrafficClass ( ) ; } @ Override public DatagramSocketOptions setTrafficClass ( int trafficClass ) { super . setTrafficClass ( trafficClass ) ; return this ; } public boolean isBroadcast ( ) { return broadcast ; } public DatagramSocketOptions setBroadcast ( boolean broadcast ) { this . broadcast = broadcast ; return this ; } public boolean isLoopbackModeDisabled ( ) { return loopbackModeDisabled ; } public DatagramSocketOptions setLoopbackModeDisabled ( boolean loopbackModeDisabled ) { this . loopbackModeDisabled = loopbackModeDisabled ; return this ; } public int getMulticastTimeToLive ( ) { return multicastTimeToLive ; } public DatagramSocketOptions setMulticastTimeToLive ( int multicastTimeToLive ) { Arguments . require ( multicastTimeToLive >= 0 , "multicastTimeToLive must be >= 0" ) ; this . multicastTimeToLive = multicastTimeToLive ; return this ; } public String getMulticastNetworkInterface ( ) { return multicastNetworkInterface ; } public DatagramSocketOptions setMulticastNetworkInterface ( String multicastNetworkInterface ) { this . multicastNetworkInterface = multicastNetworkInterface ; return this ; } public boolean isIpV6 ( ) { return ipV6 ; } public DatagramSocketOptions setIpV6 ( boolean ipV6 ) { this . ipV6 = ipV6 ; return this ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof DatagramSocketOptions ) ) return false ; if ( ! super . equals ( o ) ) return false ; DatagramSocketOptions that = ( DatagramSocketOptions ) o ; if ( broadcast != that . broadcast ) return false ; if ( ipV6 != that . ipV6 ) return false ; if ( loopbackModeDisabled != that . loopbackModeDisabled ) return false ; if ( multicastTimeToLive != that . multicastTimeToLive ) return false ; if ( multicastNetworkInterface != null ? ! multicastNetworkInterface . equals ( that . multicastNetworkInterface ) : that . multicastNetworkInterface != null ) return false ; return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + ( broadcast ? 1 : 0 ) ; result = 31 * result + ( loopbackModeDisabled ? 1 : 0 ) ; result = 31 * result + multicastTimeToLive ; result = 31 * result + ( multicastNetworkInterface != null ? multicastNetworkInterface . hashCode ( ) : 0 ) ; result = 31 * result + ( ipV6 ? 1 : 0 ) ; return result ; } }
@ Document ( fileName = "datagrams.adoc" ) package io . vertx . core . datagram ; import io . vertx . docgen . Document ;
package io . vertx . core . datagram ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . streams . WriteStream ; @ VertxGen public interface PacketWritestream extends WriteStream < Buffer > { @ Override PacketWritestream exceptionHandler ( Handler < Throwable > handler ) ; @ Override PacketWritestream write ( Buffer data ) ; @ Override PacketWritestream setWriteQueueMaxSize ( int maxSize ) ; @ Override PacketWritestream drainHandler ( Handler < Void > handler ) ; }
package io . vertx . core . datagram ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . codegen . annotations . CacheReturn ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . metrics . Measured ; import io . vertx . core . net . SocketAddress ; import io . vertx . core . streams . ReadStream ; import io . vertx . core . streams . WriteStream ; @ VertxGen public interface DatagramSocket extends ReadStream < DatagramPacket > , Measured { @ Fluent DatagramSocket send ( Buffer packet , int port , String host , Handler < AsyncResult < DatagramSocket > > handler ) ; PacketWritestream sender ( int port , String host ) ; @ Fluent DatagramSocket send ( String str , int port , String host , Handler < AsyncResult < DatagramSocket > > handler ) ; @ Fluent DatagramSocket send ( String str , String enc , int port , String host , Handler < AsyncResult < DatagramSocket > > handler ) ; void close ( Handler < AsyncResult < Void > > handler ) ; void close ( ) ; @ CacheReturn SocketAddress localAddress ( ) ; @ Fluent DatagramSocket listenMulticastGroup ( String multicastAddress , Handler < AsyncResult < DatagramSocket > > handler ) ; @ Fluent DatagramSocket listenMulticastGroup ( String multicastAddress , String networkInterface , String source , Handler < AsyncResult < DatagramSocket > > handler ) ; @ Fluent DatagramSocket unlistenMulticastGroup ( String multicastAddress , Handler < AsyncResult < DatagramSocket > > handler ) ; @ Fluent DatagramSocket unlistenMulticastGroup ( String multicastAddress , String networkInterface , String source , Handler < AsyncResult < DatagramSocket > > handler ) ; @ Fluent DatagramSocket blockMulticastGroup ( String multicastAddress , String sourceToBlock , Handler < AsyncResult < DatagramSocket > > handler ) ; @ Fluent DatagramSocket blockMulticastGroup ( String multicastAddress , String networkInterface , String sourceToBlock , Handler < AsyncResult < DatagramSocket > > handler ) ; @ Fluent DatagramSocket listen ( int port , String host , Handler < AsyncResult < DatagramSocket > > handler ) ; @ Override DatagramSocket pause ( ) ; @ Override DatagramSocket resume ( ) ; @ Override DatagramSocket endHandler ( Handler < Void > endHandler ) ; @ Override DatagramSocket handler ( Handler < DatagramPacket > handler ) ; @ Override DatagramSocket exceptionHandler ( Handler < Throwable > handler ) ; }
package io . vertx . core . datagram ; import io . vertx . core . buffer . Buffer ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . net . SocketAddress ; @ VertxGen public interface DatagramPacket { SocketAddress sender ( ) ; Buffer data ( ) ; }
package io . vertx . core . datagram . impl ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelOption ; import io . netty . channel . FixedRecvByteBufAllocator ; import io . netty . channel . socket . DatagramChannel ; import io . netty . channel . socket . DatagramPacket ; import io . netty . channel . socket . InternetProtocolFamily ; import io . netty . channel . socket . nio . NioDatagramChannel ; import io . vertx . core . AsyncResult ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . datagram . DatagramSocket ; import io . vertx . core . datagram . DatagramSocketOptions ; import io . vertx . core . datagram . PacketWritestream ; import io . vertx . core . impl . Arguments ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . net . SocketAddress ; import io . vertx . core . net . impl . ConnectionBase ; import io . vertx . core . net . impl . SocketAddressImpl ; import io . vertx . core . spi . metrics . DatagramSocketMetrics ; import io . vertx . core . spi . metrics . Metrics ; import io . vertx . core . spi . metrics . MetricsProvider ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . net . UnknownHostException ; import java . util . Objects ; public class DatagramSocketImpl extends ConnectionBase implements DatagramSocket , MetricsProvider { private Handler < io . vertx . core . datagram . DatagramPacket > packetHandler ; public DatagramSocketImpl ( VertxInternal vertx , DatagramSocketOptions options ) { super ( vertx , createChannel ( options . isIpV6 ( ) ? io . vertx . core . datagram . impl . InternetProtocolFamily . IPv6 : io . vertx . core . datagram . impl . InternetProtocolFamily . IPv4 , new DatagramSocketOptions ( options ) ) , vertx . getOrCreateContext ( ) , vertx . metricsSPI ( ) . createMetrics ( null , options ) ) ; ContextImpl creatingContext = vertx . getContext ( ) ; if ( creatingContext != null && creatingContext . isMultiThreadedWorkerContext ( ) ) { throw new IllegalStateException ( "Cannot use DatagramSocket in a multi-threaded worker verticle" ) ; } channel ( ) . config ( ) . setOption ( ChannelOption . DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION , true ) ; context . eventLoop ( ) . register ( channel ) ; channel . pipeline ( ) . addLast ( "handler" , new DatagramServerHandler ( this ) ) ; channel ( ) . config ( ) . setMaxMessagesPerRead ( 1 ) ; } @ Override protected Object metric ( ) { return null ; } @ Override public DatagramSocket listenMulticastGroup ( String multicastAddress , Handler < AsyncResult < DatagramSocket > > handler ) { try { addListener ( channel ( ) . joinGroup ( InetAddress . getByName ( multicastAddress ) ) , handler ) ; } catch ( UnknownHostException e ) { notifyException ( handler , e ) ; } return this ; } @ Override public DatagramSocket listenMulticastGroup ( String multicastAddress , String networkInterface , String source , Handler < AsyncResult < DatagramSocket > > handler ) { try { InetAddress sourceAddress ; if ( source == null ) { sourceAddress = null ; } else { sourceAddress = InetAddress . getByName ( source ) ; } addListener ( channel ( ) . joinGroup ( InetAddress . getByName ( multicastAddress ) , NetworkInterface . getByName ( networkInterface ) , sourceAddress ) , handler ) ; } catch ( Exception e ) { notifyException ( handler , e ) ; } return this ; } @ Override public DatagramSocket unlistenMulticastGroup ( String multicastAddress , Handler < AsyncResult < DatagramSocket > > handler ) { try { addListener ( channel ( ) . leaveGroup ( InetAddress . getByName ( multicastAddress ) ) , handler ) ; } catch ( UnknownHostException e ) { notifyException ( handler , e ) ; } return this ; } @ Override public DatagramSocket unlistenMulticastGroup ( String multicastAddress , String networkInterface , String source , Handler < AsyncResult < DatagramSocket > > handler ) { try { InetAddress sourceAddress ; if ( source == null ) { sourceAddress = null ; } else { sourceAddress = InetAddress . getByName ( source ) ; } addListener ( channel ( ) . leaveGroup ( InetAddress . getByName ( multicastAddress ) , NetworkInterface . getByName ( networkInterface ) , sourceAddress ) , handler ) ; } catch ( Exception e ) { notifyException ( handler , e ) ; } return this ; } @ Override public DatagramSocket blockMulticastGroup ( String multicastAddress , String networkInterface , String sourceToBlock , Handler < AsyncResult < DatagramSocket > > handler ) { try { InetAddress sourceAddress ; if ( sourceToBlock == null ) { sourceAddress = null ; } else { sourceAddress = InetAddress . getByName ( sourceToBlock ) ; } addListener ( channel ( ) . block ( InetAddress . getByName ( multicastAddress ) , NetworkInterface . getByName ( networkInterface ) , sourceAddress ) , handler ) ; } catch ( Exception e ) { notifyException ( handler , e ) ; } return this ; } @ Override public DatagramSocket blockMulticastGroup ( String multicastAddress , String sourceToBlock , Handler < AsyncResult < DatagramSocket > > handler ) { try { addListener ( channel ( ) . block ( InetAddress . getByName ( multicastAddress ) , InetAddress . getByName ( sourceToBlock ) ) , handler ) ; } catch ( UnknownHostException e ) { notifyException ( handler , e ) ; } return this ; } @ Override public DatagramSocket listen ( int port , String address , Handler < AsyncResult < DatagramSocket > > handler ) { return listen ( new SocketAddressImpl ( port , address ) , handler ) ; } @ Override public synchronized DatagramSocket handler ( Handler < io . vertx . core . datagram . DatagramPacket > handler ) { this . packetHandler = handler ; return this ; } @ Override public synchronized DatagramSocket endHandler ( Handler < Void > endHandler ) { this . closeHandler = endHandler ; return this ; } @ Override public synchronized DatagramSocket exceptionHandler ( Handler < Throwable > handler ) { this . exceptionHandler = handler ; return this ; } private DatagramSocket listen ( SocketAddress local , Handler < AsyncResult < DatagramSocket > > handler ) { Objects . requireNonNull ( handler , "no null handler accepted" ) ; InetSocketAddress is = new InetSocketAddress ( local . host ( ) , local . port ( ) ) ; ChannelFuture future = channel ( ) . bind ( is ) ; return this ; } private void addListener1 ( ChannelFuture future , Object handler ) { } private void addListener ( ChannelFuture future , Object handler ) { } @ SuppressWarnings ( "unchecked" ) final void addListener ( ChannelFuture future , Handler < AsyncResult < DatagramSocket > > handler ) { if ( handler != null ) { future . addListener ( new DatagramChannelFutureListener < > ( this , handler , context ) ) ; } } @ SuppressWarnings ( "unchecked" ) public DatagramSocket pause ( ) { doPause ( ) ; return this ; } @ SuppressWarnings ( "unchecked" ) public DatagramSocket resume ( ) { doResume ( ) ; return this ; } @ Override @ SuppressWarnings ( "unchecked" ) public DatagramSocket send ( Buffer packet , int port , String host , Handler < AsyncResult < DatagramSocket > > handler ) { Objects . requireNonNull ( host , "no null host accepted" ) ; ChannelFuture future = channel ( ) . writeAndFlush ( new DatagramPacket ( packet . getByteBuf ( ) , new InetSocketAddress ( host , port ) ) ) ; addListener ( future , handler ) ; if ( metrics . isEnabled ( ) ) { metrics . bytesWritten ( null , new SocketAddressImpl ( port , host ) , packet . length ( ) ) ; } return this ; } @ Override public PacketWritestream sender ( int port , String host ) { Arguments . requireInRange ( port , 0 , 65535 , "port p must be in range 0 <= p <= 65535" ) ; Objects . requireNonNull ( host , "no null host accepted" ) ; return new PacketWriteStreamImpl ( this , port , host ) ; } @ Override public DatagramSocket send ( String str , int port , String host , Handler < AsyncResult < DatagramSocket > > handler ) { return send ( Buffer . buffer ( str ) , port , host , handler ) ; } @ Override public DatagramSocket send ( String str , String enc , int port , String host , Handler < AsyncResult < DatagramSocket > > handler ) { return send ( Buffer . buffer ( str , enc ) , port , host , handler ) ; } @ Override public void close ( final Handler < AsyncResult < Void > > handler ) { endReadAndFlush ( ) ; metrics . close ( ) ; ChannelFuture future = channel . close ( ) ; if ( handler != null ) { future . addListener ( new DatagramChannelFutureListener < > ( null , handler , context ) ) ; } } @ Override public boolean isMetricsEnabled ( ) { return metrics != null && metrics . isEnabled ( ) ; } @ Override public Metrics getMetrics ( ) { return metrics ; } protected DatagramChannel channel ( ) { return ( DatagramChannel ) channel ; } private static NioDatagramChannel createChannel ( io . vertx . core . datagram . impl . InternetProtocolFamily family , DatagramSocketOptions options ) { NioDatagramChannel channel ; if ( family == null ) { channel = new NioDatagramChannel ( ) ; } else { switch ( family ) { case IPv4 : channel = new NioDatagramChannel ( InternetProtocolFamily . IPv4 ) ; break ; case IPv6 : channel = new NioDatagramChannel ( InternetProtocolFamily . IPv6 ) ; break ; default : channel = new NioDatagramChannel ( ) ; } } if ( options . getSendBufferSize ( ) != - 1 ) { channel . config ( ) . setSendBufferSize ( options . getSendBufferSize ( ) ) ; } if ( options . getReceiveBufferSize ( ) != - 1 ) { channel . config ( ) . setReceiveBufferSize ( options . getReceiveBufferSize ( ) ) ; channel . config ( ) . setRecvByteBufAllocator ( new FixedRecvByteBufAllocator ( options . getReceiveBufferSize ( ) ) ) ; } channel . config ( ) . setReuseAddress ( options . isReuseAddress ( ) ) ; if ( options . getTrafficClass ( ) != - 1 ) { channel . config ( ) . setTrafficClass ( options . getTrafficClass ( ) ) ; } channel . config ( ) . setBroadcast ( options . isBroadcast ( ) ) ; channel . config ( ) . setLoopbackModeDisabled ( options . isLoopbackModeDisabled ( ) ) ; if ( options . getMulticastTimeToLive ( ) != - 1 ) { channel . config ( ) . setTimeToLive ( options . getMulticastTimeToLive ( ) ) ; } if ( options . getMulticastNetworkInterface ( ) != null ) { try { channel . config ( ) . setNetworkInterface ( NetworkInterface . getByName ( options . getMulticastNetworkInterface ( ) ) ) ; } catch ( SocketException e ) { throw new IllegalArgumentException ( "Could not find network interface with name " + options . getMulticastNetworkInterface ( ) ) ; } } return channel ; } private void notifyException ( final Handler < AsyncResult < DatagramSocket > > handler , final Throwable cause ) { context . executeFromIO ( ( ) - > handler . handle ( Future . failedFuture ( cause ) ) ) ; } @ Override protected void finalize ( ) throws Throwable { close ( ) ; super . finalize ( ) ; } protected void handleClosed ( ) { checkContext ( ) ; super . handleClosed ( ) ; } synchronized void handlePacket ( io . vertx . core . datagram . DatagramPacket packet ) { if ( metrics . isEnabled ( ) ) { metrics . bytesRead ( null , packet . sender ( ) , packet . data ( ) . length ( ) ) ; } packetHandler ( packet ) ; } private void packetHandler ( io . vertx . core . datagram . DatagramPacket packet ) { if ( packetHandler != null ) { packetHandler . handle ( packet ) ; } } @ Override protected void handleInterestedOpsChanged ( ) { } }
package io . vertx . core . datagram . impl ; public enum InternetProtocolFamily { IPv4 , IPv6 }
package io . vertx . core . datagram . impl ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . vertx . core . AsyncResult ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . impl . ContextImpl ; final class DatagramChannelFutureListener < T > implements ChannelFutureListener { private final Handler < AsyncResult < T > > handler ; private final T result ; private final ContextImpl context ; DatagramChannelFutureListener ( T result , Handler < AsyncResult < T > > handler , ContextImpl context ) { this . handler = handler ; this . result = result ; this . context = context ; } @ Override public void operationComplete ( final ChannelFuture future ) throws Exception { context . executeFromIO ( ( ) - > notifyHandler ( future ) ) ; } private void notifyHandler ( ChannelFuture future ) { if ( future . isSuccess ( ) ) { handler . handle ( Future . succeededFuture ( result ) ) ; } else { handler . handle ( Future . failedFuture ( future . cause ( ) ) ) ; } } }
package io . vertx . core . datagram . impl ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . datagram . DatagramPacket ; import io . vertx . core . net . SocketAddress ; import io . vertx . core . net . impl . SocketAddressImpl ; import java . net . InetSocketAddress ; final class DatagramPacketImpl implements DatagramPacket { private final InetSocketAddress sender ; private final Buffer buffer ; private SocketAddress senderAddress ; DatagramPacketImpl ( InetSocketAddress sender , Buffer buffer ) { this . sender = sender ; this . buffer = buffer ; } @ Override public SocketAddress sender ( ) { if ( senderAddress == null ) { senderAddress = new SocketAddressImpl ( sender . getPort ( ) , sender . getAddress ( ) . getHostAddress ( ) ) ; } return senderAddress ; } @ Override public Buffer data ( ) { return buffer ; } }
package io . vertx . core . datagram . impl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . socket . DatagramPacket ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . net . impl . VertxHandler ; final class DatagramServerHandler extends VertxHandler < DatagramSocketImpl > { private final DatagramSocketImpl socket ; DatagramServerHandler ( DatagramSocketImpl socket ) { this . socket = socket ; } @ Override protected DatagramSocketImpl getConnection ( Channel channel ) { return socket ; } @ Override protected DatagramSocketImpl removeConnection ( Channel channel ) { return socket ; } @ SuppressWarnings ( "unchecked" ) @ Override protected void channelRead ( final DatagramSocketImpl server , final ContextImpl context , ChannelHandlerContext chctx , final Object msg ) throws Exception { context . executeFromIO ( ( ) - > server . handlePacket ( ( io . vertx . core . datagram . DatagramPacket ) msg ) ) ; } @ Override protected Object safeObject ( Object msg , ByteBufAllocator allocator ) throws Exception { if ( msg instanceof DatagramPacket ) { DatagramPacket packet = ( DatagramPacket ) msg ; ByteBuf content = packet . content ( ) ; if ( content . isDirect ( ) ) { content = safeBuffer ( content , allocator ) ; } return new DatagramPacketImpl ( packet . sender ( ) , Buffer . buffer ( content ) ) ; } return msg ; } }
package io . vertx . test . core ; import io . vertx . core . Vertx ; import io . vertx . core . VertxOptions ; import org . junit . Test ; public class CreateVertxTest extends AsyncTestBase { @ Test public void testCreateSimpleVertx ( ) { Vertx vertx = Vertx . vertx ( ) ; assertNotNull ( vertx ) ; } @ Test public void testCreateVertxWithOptions ( ) { VertxOptions options = new VertxOptions ( ) ; Vertx vertx = Vertx . vertx ( options ) ; assertNotNull ( vertx ) ; assertFalse ( vertx . isClustered ( ) ) ; } @ Test public void testFailCreateClusteredVertxSynchronously ( ) { VertxOptions options = new VertxOptions ( ) ; options . setClustered ( true ) ; try { Vertx . vertx ( options ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } } @ Test public void testCreateClusteredVertxAsync ( ) { VertxOptions options = new VertxOptions ( ) ; options . setClustered ( true ) ; Vertx . clusteredVertx ( options , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertNotNull ( ar . result ( ) ) ; assertTrue ( ar . result ( ) . isClustered ( ) ) ; Vertx v = ar . result ( ) ; v . close ( ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testCreateClusteredVertxAsyncDontSetClustered ( ) { VertxOptions options = new VertxOptions ( ) ; Vertx . clusteredVertx ( options , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertNotNull ( ar . result ( ) ) ; assertTrue ( options . isClustered ( ) ) ; assertTrue ( ar . result ( ) . isClustered ( ) ) ; Vertx v = ar . result ( ) ; v . close ( ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } }
package io . vertx . core . datagram . impl ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . datagram . DatagramSocket ; import io . vertx . core . datagram . PacketWritestream ; import io . vertx . core . streams . WriteStream ; class PacketWriteStreamImpl implements PacketWritestream , Handler < AsyncResult < DatagramSocket > > { private DatagramSocketImpl datagramSocket ; private Handler < Throwable > exceptionHandler ; private final int port ; private final String host ; PacketWriteStreamImpl ( DatagramSocketImpl datagramSocket , int port , String host ) { this . datagramSocket = datagramSocket ; this . port = port ; this . host = host ; } @ Override public void handle ( AsyncResult < DatagramSocket > event ) { if ( event . failed ( ) && exceptionHandler != null ) { exceptionHandler . handle ( event . cause ( ) ) ; } } @ Override public PacketWritestream exceptionHandler ( Handler < Throwable > handler ) { exceptionHandler = handler ; return this ; } @ Override public PacketWritestream write ( Buffer data ) { datagramSocket . send ( data , port , host , this ) ; return this ; } @ Override public PacketWritestream setWriteQueueMaxSize ( int maxSize ) { return this ; } @ Override public boolean writeQueueFull ( ) { return false ; } @ Override public PacketWritestream drainHandler ( Handler < Void > handler ) { return this ; } }
@ Document ( fileName = "streams.adoc" ) package io . vertx . core . streams ; import io . vertx . docgen . Document ;
package io . vertx . core . streams ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; @ VertxGen ( concrete = false ) public interface ReadStream < T > extends StreamBase { ReadStream < T > exceptionHandler ( Handler < Throwable > handler ) ; @ Fluent ReadStream < T > handler ( Handler < T > handler ) ; @ Fluent ReadStream < T > pause ( ) ; @ Fluent ReadStream < T > resume ( ) ; @ Fluent ReadStream < T > endHandler ( Handler < Void > endHandler ) ; }
package io . vertx . core . streams ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; @ VertxGen ( concrete = false ) public interface WriteStream < T > extends StreamBase { @ Override WriteStream < T > exceptionHandler ( Handler < Throwable > handler ) ; @ Fluent WriteStream < T > write ( T data ) ; @ Fluent WriteStream < T > setWriteQueueMaxSize ( int maxSize ) ; boolean writeQueueFull ( ) ; @ Fluent WriteStream < T > drainHandler ( Handler < Void > handler ) ; }
package io . vertx . core . streams ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; @ VertxGen ( concrete = false ) public interface StreamBase { @ Fluent StreamBase exceptionHandler ( Handler < Throwable > handler ) ; }
package io . vertx . core . streams ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . ServiceHelper ; import io . vertx . core . spi . PumpFactory ; @ VertxGen public interface Pump { static < T > Pump pump ( ReadStream < T > rs , WriteStream < T > ws ) { return factory . pump ( rs , ws ) ; } static < T > Pump pump ( ReadStream < T > rs , WriteStream < T > ws , int writeQueueMaxSize ) { return factory . pump ( rs , ws , writeQueueMaxSize ) ; } @ Fluent Pump setWriteQueueMaxSize ( int maxSize ) ; @ Fluent Pump start ( ) ; @ Fluent Pump stop ( ) ; int numberPumped ( ) ; static final PumpFactory factory = ServiceHelper . loadFactory ( PumpFactory . class ) ; }
package io . vertx . core . streams . impl ; import io . vertx . core . Handler ; import io . vertx . core . streams . Pump ; import io . vertx . core . streams . ReadStream ; import io . vertx . core . streams . WriteStream ; public class PumpImpl < T > implements Pump { private final ReadStream < T > readStream ; private final WriteStream < T > writeStream ; private final Handler < T > dataHandler ; private final Handler < Void > drainHandler ; private int pumped ; PumpImpl ( ReadStream < T > rs , WriteStream < T > ws , int maxWriteQueueSize ) { this ( rs , ws ) ; this . writeStream . setWriteQueueMaxSize ( maxWriteQueueSize ) ; } PumpImpl ( ReadStream < T > rs , WriteStream < T > ws ) { this . readStream = rs ; this . writeStream = ws ; drainHandler = v - > readStream . resume ( ) ; dataHandler = data - > { writeStream . write ( data ) ; incPumped ( ) ; if ( writeStream . writeQueueFull ( ) ) { readStream . pause ( ) ; writeStream . drainHandler ( drainHandler ) ; } } ; } @ Override public PumpImpl setWriteQueueMaxSize ( int maxSize ) { writeStream . setWriteQueueMaxSize ( maxSize ) ; return this ; } @ Override public PumpImpl start ( ) { readStream . handler ( dataHandler ) ; return this ; } @ Override public PumpImpl stop ( ) { writeStream . drainHandler ( null ) ; readStream . handler ( null ) ; return this ; } @ Override public synchronized int numberPumped ( ) { return pumped ; } private synchronized void incPumped ( ) { pumped ++ ; } }
package io . vertx . core . streams . impl ; import io . vertx . core . spi . PumpFactory ; import io . vertx . core . streams . Pump ; import io . vertx . core . streams . ReadStream ; import io . vertx . core . streams . WriteStream ; public class PumpFactoryImpl implements PumpFactory { @ Override public < T > Pump pump ( ReadStream < T > rs , WriteStream < T > ws ) { return new PumpImpl < > ( rs , ws ) ; } @ Override public < T > Pump pump ( ReadStream < T > rs , WriteStream < T > ws , int writeQueueMaxSize ) { return new PumpImpl < > ( rs , ws , writeQueueMaxSize ) ; } }
@ Document ( fileName = "shareddata.adoc" ) package io . vertx . core . shareddata ; import io . vertx . docgen . Document ;
package io . vertx . core . shareddata ; public interface Shareable { }
package io . vertx . test . core ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . vertx . core . AsyncResultHandler ; import io . vertx . core . Handler ; import io . vertx . core . Vertx ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . file . AsyncFile ; import io . vertx . core . file . FileProps ; import io . vertx . core . file . FileSystemException ; import io . vertx . core . file . FileSystemProps ; import io . vertx . core . file . OpenOptions ; import io . vertx . core . file . impl . AsyncFileImpl ; import io . vertx . core . impl . Utils ; import io . vertx . core . json . JsonObject ; import io . vertx . core . streams . Pump ; import io . vertx . core . streams . ReadStream ; import io . vertx . core . streams . WriteStream ; import org . junit . Assume ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; import java . io . File ; import java . io . IOException ; import java . nio . file . FileSystems ; import java . nio . file . Files ; import java . nio . file . LinkOption ; import java . nio . file . Path ; import java . nio . file . Paths ; import java . nio . file . attribute . GroupPrincipal ; import java . nio . file . attribute . PosixFileAttributes ; import java . nio . file . attribute . PosixFilePermission ; import java . nio . file . attribute . PosixFilePermissions ; import java . nio . file . attribute . UserPrincipal ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . concurrent . atomic . AtomicInteger ; import static io . vertx . test . core . TestUtils . * ; public class FileSystemTest extends VertxTestBase { private static final String DEFAULT_DIR_PERMS = "rwxr-xr-x" ; private static final String DEFAULT_FILE_PERMS = "rw-r--r--" ; private String pathSep ; private String testDir ; @ Rule public TemporaryFolder testFolder = new TemporaryFolder ( ) ; public void setUp ( ) throws Exception { super . setUp ( ) ; java . nio . file . FileSystem fs = FileSystems . getDefault ( ) ; pathSep = fs . getSeparator ( ) ; File ftestDir = testFolder . newFolder ( ) ; testDir = ftestDir . toString ( ) ; } @ Test public void testIllegalArguments ( ) throws Exception { assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . copy ( null , "ignored" , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . copy ( "ignored" , null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . copyBlocking ( null , "ignored" ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . copyBlocking ( "ignored" , null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . copyRecursive ( null , "ignored" , true , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . copyRecursive ( "ignored" , null , true , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . copyRecursiveBlocking ( null , "ignored" , true ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . copyRecursiveBlocking ( "ignored" , null , true ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . move ( null , "ignored" , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . move ( "ignored" , null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . moveBlocking ( null , "ignored" ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . moveBlocking ( "ignored" , null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . truncate ( null , 0 , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . truncateBlocking ( null , 0 ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . chmod ( null , "ignored" , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . chmod ( "ignored" , null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . chmodBlocking ( null , "ignored" ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . chmodBlocking ( "ignored" , null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . chmodRecursive ( null , "ignored" , "ignored" , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . chmodRecursive ( "ignored" , null , "ignored" , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . chmodRecursiveBlocking ( null , "ignored" , "ignored" ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . chmodRecursiveBlocking ( "ignored" , null , "ignored" ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . chown ( null , "ignored" , "ignored" , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . chownBlocking ( null , "ignored" , "ignored" ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . props ( null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . propsBlocking ( null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . lprops ( null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . lpropsBlocking ( null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . link ( null , "ignored" , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . link ( "ignored" , null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . linkBlocking ( null , "ignored" ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . linkBlocking ( "ignored" , null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . symlink ( null , "ignored" , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . symlink ( "ignored" , null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . symlinkBlocking ( null , "ignored" ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . symlinkBlocking ( "ignored" , null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . unlink ( null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . unlinkBlocking ( null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . readSymlink ( null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . readSymlinkBlocking ( null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . delete ( null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . deleteBlocking ( null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . deleteRecursive ( null , true , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . deleteRecursiveBlocking ( null , true ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . mkdir ( null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . mkdirBlocking ( null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . mkdir ( null , "ignored" , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . mkdirBlocking ( null , "ignored" ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . mkdirs ( null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . mkdirsBlocking ( null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . mkdirs ( null , "ignored" , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . mkdirsBlocking ( null , "ignored" ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . readDir ( null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . readDirBlocking ( null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . readDir ( null , "ignored" , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . readDirBlocking ( null , "ignored" ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . readFile ( null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . readFileBlocking ( null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . writeFile ( null , Buffer . buffer ( ) , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . writeFile ( "ignored" , null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . writeFileBlocking ( null , Buffer . buffer ( ) ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . writeFileBlocking ( "ignored" , null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . open ( null , new OpenOptions ( ) , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . open ( "ignored" , null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . openBlocking ( null , new OpenOptions ( ) ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . openBlocking ( "ignored" , null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . createFile ( null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . createFileBlocking ( null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . createFile ( null , "ignored" , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . createFileBlocking ( null , "ignored" ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . exists ( null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . existsBlocking ( null ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . fsProps ( null , h - > { } ) ) ; assertNullPointerException ( ( ) - > vertx . fileSystem ( ) . fsPropsBlocking ( null ) ) ; String fileName = "some-file.dat" ; AsyncFile asyncFile = vertx . fileSystem ( ) . openBlocking ( testDir + pathSep + fileName , new OpenOptions ( ) ) ; assertNullPointerException ( ( ) - > asyncFile . write ( null ) ) ; assertIllegalArgumentException ( ( ) - > asyncFile . setWriteQueueMaxSize ( 1 ) ) ; assertIllegalArgumentException ( ( ) - > asyncFile . setWriteQueueMaxSize ( 0 ) ) ; assertIllegalArgumentException ( ( ) - > asyncFile . setWriteQueueMaxSize ( - 1 ) ) ; assertNullPointerException ( ( ) - > asyncFile . write ( null , 0 , h - > { } ) ) ; assertNullPointerException ( ( ) - > asyncFile . write ( Buffer . buffer ( ) , 0 , null ) ) ; assertIllegalArgumentException ( ( ) - > asyncFile . write ( Buffer . buffer ( ) , - 1 , h - > { } ) ) ; assertNullPointerException ( ( ) - > asyncFile . read ( null , 0 , 0 , 0 , h - > { } ) ) ; assertNullPointerException ( ( ) - > asyncFile . read ( Buffer . buffer ( ) , 0 , 0 , 0 , null ) ) ; assertIllegalArgumentException ( ( ) - > asyncFile . read ( Buffer . buffer ( ) , - 1 , 0 , 0 , h - > { } ) ) ; assertIllegalArgumentException ( ( ) - > asyncFile . read ( Buffer . buffer ( ) , 0 , - 1 , 0 , h - > { } ) ) ; assertIllegalArgumentException ( ( ) - > asyncFile . read ( Buffer . buffer ( ) , 0 , 0 , - 1 , h - > { } ) ) ; } @ Test public void testSimpleCopy ( ) throws Exception { String source = "foo.txt" ; String target = "bar.txt" ; createFileWithJunk ( source , 100 ) ; testCopy ( source , target , false , true , v - > { assertTrue ( fileExists ( source ) ) ; assertTrue ( fileExists ( target ) ) ; } ) ; await ( ) ; } @ Test public void testSimpleCopyFileAlreadyExists ( ) throws Exception { String source = "foo.txt" ; String target = "bar.txt" ; createFileWithJunk ( source , 100 ) ; createFileWithJunk ( target , 100 ) ; testCopy ( source , target , false , false , v - > { assertTrue ( fileExists ( source ) ) ; assertTrue ( fileExists ( target ) ) ; } ) ; await ( ) ; } @ Test public void testCopyIntoDir ( ) throws Exception { String source = "foo.txt" ; String dir = "some-dir" ; String target = dir + pathSep + "bar.txt" ; mkDir ( dir ) ; createFileWithJunk ( source , 100 ) ; testCopy ( source , target , false , true , v - > { assertTrue ( fileExists ( source ) ) ; assertTrue ( fileExists ( target ) ) ; } ) ; await ( ) ; } @ Test public void testCopyEmptyDir ( ) throws Exception { String source = "some-dir" ; String target = "some-other-dir" ; mkDir ( source ) ; testCopy ( source , target , false , true , v - > { assertTrue ( fileExists ( source ) ) ; assertTrue ( fileExists ( target ) ) ; } ) ; await ( ) ; } @ Test public void testCopyNonEmptyDir ( ) throws Exception { String source = "some-dir" ; String target = "some-other-dir" ; String file1 = pathSep + "somefile.bar" ; mkDir ( source ) ; createFileWithJunk ( source + file1 , 100 ) ; testCopy ( source , target , false , true , v - > { assertTrue ( fileExists ( source ) ) ; assertTrue ( fileExists ( target ) ) ; assertFalse ( fileExists ( target + file1 ) ) ; } ) ; await ( ) ; } @ Test public void testFailCopyDirAlreadyExists ( ) throws Exception { String source = "some-dir" ; String target = "some-other-dir" ; mkDir ( source ) ; mkDir ( target ) ; testCopy ( source , target , false , false , v - > { assertTrue ( fileExists ( source ) ) ; assertTrue ( fileExists ( target ) ) ; } ) ; await ( ) ; } @ Test public void testRecursiveCopy ( ) throws Exception { String dir = "some-dir" ; String file1 = pathSep + "file1.dat" ; String file2 = pathSep + "index.html" ; String dir2 = "next-dir" ; String file3 = pathSep + "blah.java" ; mkDir ( dir ) ; createFileWithJunk ( dir + file1 , 100 ) ; createFileWithJunk ( dir + file2 , 100 ) ; mkDir ( dir + pathSep + dir2 ) ; createFileWithJunk ( dir + pathSep + dir2 + file3 , 100 ) ; String target = "some-other-dir" ; testCopy ( dir , target , true , true , v - > { assertTrue ( fileExists ( dir ) ) ; assertTrue ( fileExists ( target ) ) ; assertTrue ( fileExists ( target + file1 ) ) ; assertTrue ( fileExists ( target + file2 ) ) ; assertTrue ( fileExists ( target + pathSep + dir2 + file3 ) ) ; } ) ; await ( ) ; } private void testCopy ( String source , String target , boolean recursive , boolean shouldPass , Handler < Void > afterOK ) { if ( recursive ) { vertx . fileSystem ( ) . copyRecursive ( testDir + pathSep + source , testDir + pathSep + target , true , createHandler ( shouldPass , afterOK ) ) ; } else { vertx . fileSystem ( ) . copy ( testDir + pathSep + source , testDir + pathSep + target , createHandler ( shouldPass , afterOK ) ) ; } } @ Test public void testSimpleMove ( ) throws Exception { String source = "foo.txt" ; String target = "bar.txt" ; createFileWithJunk ( source , 100 ) ; testMove ( source , target , true , v - > { assertFalse ( fileExists ( source ) ) ; assertTrue ( fileExists ( target ) ) ; } ) ; await ( ) ; } @ Test public void testSimpleMoveFileAlreadyExists ( ) throws Exception { String source = "foo.txt" ; String target = "bar.txt" ; createFileWithJunk ( source , 100 ) ; createFileWithJunk ( target , 100 ) ; testMove ( source , target , false , v - > { assertTrue ( fileExists ( source ) ) ; assertTrue ( fileExists ( target ) ) ; } ) ; await ( ) ; } @ Test public void testMoveEmptyDir ( ) throws Exception { String source = "some-dir" ; String target = "some-other-dir" ; mkDir ( source ) ; testMove ( source , target , true , v - > { assertFalse ( fileExists ( source ) ) ; assertTrue ( fileExists ( target ) ) ; } ) ; await ( ) ; } @ Test public void testMoveEmptyDirTargetExists ( ) throws Exception { String source = "some-dir" ; String target = "some-other-dir" ; mkDir ( source ) ; mkDir ( target ) ; testMove ( source , target , false , v - > { assertTrue ( fileExists ( source ) ) ; assertTrue ( fileExists ( target ) ) ; } ) ; await ( ) ; } @ Test public void testMoveNonEmptyDir ( ) throws Exception { String dir = "some-dir" ; String file1 = pathSep + "file1.dat" ; String file2 = pathSep + "index.html" ; String dir2 = "next-dir" ; String file3 = pathSep + "blah.java" ; mkDir ( dir ) ; createFileWithJunk ( dir + file1 , 100 ) ; createFileWithJunk ( dir + file2 , 100 ) ; mkDir ( dir + pathSep + dir2 ) ; createFileWithJunk ( dir + pathSep + dir2 + file3 , 100 ) ; String target = "some-other-dir" ; testMove ( dir , target , true , v - > { assertFalse ( fileExists ( dir ) ) ; assertTrue ( fileExists ( target ) ) ; assertTrue ( fileExists ( target + file1 ) ) ; assertTrue ( fileExists ( target + file2 ) ) ; assertTrue ( fileExists ( target + pathSep + dir2 + file3 ) ) ; } ) ; await ( ) ; } private void testMove ( String source , String target , boolean shouldPass , Handler < Void > afterOK ) throws Exception { vertx . fileSystem ( ) . move ( testDir + pathSep + source , testDir + pathSep + target , createHandler ( shouldPass , afterOK ) ) ; } @ Test public void testTruncate ( ) throws Exception { String file1 = "some-file.dat" ; long initialLen = 1000 ; long truncatedLen = 534 ; createFileWithJunk ( file1 , initialLen ) ; assertEquals ( initialLen , fileLength ( file1 ) ) ; testTruncate ( file1 , truncatedLen , true , v - > { assertEquals ( truncatedLen , fileLength ( file1 ) ) ; } ) ; await ( ) ; } @ Test public void testTruncateExtendsFile ( ) throws Exception { String file1 = "some-file.dat" ; long initialLen = 500 ; long truncatedLen = 1000 ; createFileWithJunk ( file1 , initialLen ) ; assertEquals ( initialLen , fileLength ( file1 ) ) ; testTruncate ( file1 , truncatedLen , true , v - > { assertEquals ( truncatedLen , fileLength ( file1 ) ) ; } ) ; await ( ) ; } @ Test public void testTruncateFileDoesNotExist ( ) throws Exception { String file1 = "some-file.dat" ; long truncatedLen = 534 ; testTruncate ( file1 , truncatedLen , false , null ) ; await ( ) ; } private void testTruncate ( String file , long truncatedLen , boolean shouldPass , Handler < Void > afterOK ) throws Exception { vertx . fileSystem ( ) . truncate ( testDir + pathSep + file , truncatedLen , createHandler ( shouldPass , afterOK ) ) ; } @ Test public void testChmodNonRecursive1 ( ) throws Exception { testChmodNonRecursive ( "rw-------" ) ; } @ Test public void testChmodNonRecursive2 ( ) throws Exception { testChmodNonRecursive ( "rwx------" ) ; } @ Test public void testChmodNonRecursive3 ( ) throws Exception { testChmodNonRecursive ( "rw-rw-rw-" ) ; } @ Test public void testChmodNonRecursive4 ( ) throws Exception { testChmodNonRecursive ( "rw-r--r--" ) ; } @ Test public void testChmodNonRecursive5 ( ) throws Exception { testChmodNonRecursive ( "rw--w--w-" ) ; } @ Test public void testChmodNonRecursive6 ( ) throws Exception { testChmodNonRecursive ( "rw-rw-rw-" ) ; } private void testChmodNonRecursive ( String perms ) throws Exception { String file1 = "some-file.dat" ; createFileWithJunk ( file1 , 100 ) ; testChmod ( file1 , perms , null , true , v - > { azzertPerms ( perms , file1 ) ; deleteFile ( file1 ) ; } ) ; await ( ) ; } private void azzertPerms ( String perms , String file1 ) { if ( ! Utils . isWindows ( ) ) { assertEquals ( perms , getPerms ( file1 ) ) ; } } @ Test public void testChmodRecursive1 ( ) throws Exception { testChmodRecursive ( "rw-------" , "rwx------" ) ; } @ Test public void testChmodRecursive2 ( ) throws Exception { testChmodRecursive ( "rwx------" , "rwx------" ) ; } @ Test public void testChmodRecursive3 ( ) throws Exception { testChmodRecursive ( "rw-rw-rw-" , "rwxrw-rw-" ) ; } @ Test public void testChmodRecursive4 ( ) throws Exception { testChmodRecursive ( "rw-r--r--" , "rwxr--r--" ) ; } @ Test public void testChmodRecursive5 ( ) throws Exception { testChmodRecursive ( "rw--w--w-" , "rwx-w--w-" ) ; } @ Test public void testChmodRecursive6 ( ) throws Exception { testChmodRecursive ( "rw-rw-rw-" , "rwxrw-rw-" ) ; } private void testChmodRecursive ( String perms , String dirPerms ) throws Exception { String dir = "some-dir" ; String file1 = pathSep + "file1.dat" ; String file2 = pathSep + "index.html" ; String dir2 = "next-dir" ; String file3 = pathSep + "blah.java" ; mkDir ( dir ) ; createFileWithJunk ( dir + file1 , 100 ) ; createFileWithJunk ( dir + file2 , 100 ) ; mkDir ( dir + pathSep + dir2 ) ; createFileWithJunk ( dir + pathSep + dir2 + file3 , 100 ) ; testChmod ( dir , perms , dirPerms , true , v - > { azzertPerms ( dirPerms , dir ) ; azzertPerms ( perms , dir + file1 ) ; azzertPerms ( perms , dir + file2 ) ; azzertPerms ( dirPerms , dir + pathSep + dir2 ) ; azzertPerms ( perms , dir + pathSep + dir2 + file3 ) ; deleteDir ( dir ) ; } ) ; await ( ) ; } @ Test public void testChownToRootFails ( ) throws Exception { testChownFails ( "root" ) ; } @ Test public void testChownToNotExistingUserFails ( ) throws Exception { testChownFails ( "jfhfhjejweg" ) ; } private void testChownFails ( String user ) throws Exception { String file1 = "some-file.dat" ; createFileWithJunk ( file1 , 100 ) ; vertx . fileSystem ( ) . chown ( testDir + pathSep + file1 , user , null , ar - > { deleteFile ( file1 ) ; assertTrue ( ar . failed ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testChownToOwnUser ( ) throws Exception { String file1 = "some-file.dat" ; createFileWithJunk ( file1 , 100 ) ; String fullPath = testDir + pathSep + file1 ; Path path = Paths . get ( fullPath ) ; UserPrincipal owner = Files . getOwner ( path ) ; String user = owner . getName ( ) ; vertx . fileSystem ( ) . chown ( fullPath , user , null , ar - > { deleteFile ( file1 ) ; assertTrue ( ar . succeeded ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testChownToOwnGroup ( ) throws Exception { Assume . assumeFalse ( Utils . isWindows ( ) ) ; String file1 = "some-file.dat" ; createFileWithJunk ( file1 , 100 ) ; String fullPath = testDir + pathSep + file1 ; Path path = Paths . get ( fullPath ) ; GroupPrincipal group = Files . readAttributes ( path , PosixFileAttributes . class , LinkOption . NOFOLLOW_LINKS ) . group ( ) ; vertx . fileSystem ( ) . chown ( fullPath , null , group . getName ( ) , ar - > { deleteFile ( file1 ) ; assertTrue ( ar . succeeded ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } private void testChmod ( String file , String perms , String dirPerms , boolean shouldPass , Handler < Void > afterOK ) throws Exception { if ( Files . isDirectory ( Paths . get ( testDir + pathSep + file ) ) ) { azzertPerms ( DEFAULT_DIR_PERMS , file ) ; } else { azzertPerms ( DEFAULT_FILE_PERMS , file ) ; } if ( dirPerms != null ) { vertx . fileSystem ( ) . chmodRecursive ( testDir + pathSep + file , perms , dirPerms , createHandler ( shouldPass , afterOK ) ) ; } else { vertx . fileSystem ( ) . chmod ( testDir + pathSep + file , perms , createHandler ( shouldPass , afterOK ) ) ; } } @ Test public void testProps ( ) throws Exception { String fileName = "some-file.txt" ; long fileSize = 1234 ; long start = 1000 * ( System . currentTimeMillis ( ) / 1000 - 1 ) ; createFileWithJunk ( fileName , fileSize ) ; testProps ( fileName , false , true , st - > { assertNotNull ( st ) ; assertEquals ( fileSize , st . size ( ) ) ; assertTrue ( st . creationTime ( ) >= start ) ; assertTrue ( st . lastAccessTime ( ) >= start ) ; assertTrue ( st . lastModifiedTime ( ) >= start ) ; assertFalse ( st . isDirectory ( ) ) ; assertTrue ( st . isRegularFile ( ) ) ; assertFalse ( st . isSymbolicLink ( ) ) ; } ) ; await ( ) ; } @ Test public void testPropsFileDoesNotExist ( ) throws Exception { String fileName = "some-file.txt" ; testProps ( fileName , false , false , null ) ; await ( ) ; } @ Test public void testPropsFollowLink ( ) throws Exception { Assume . assumeFalse ( Utils . isWindows ( ) ) ; String fileName = "some-file.txt" ; long fileSize = 1234 ; long start = 1000 * ( System . currentTimeMillis ( ) / 1000 - 1 ) ; createFileWithJunk ( fileName , fileSize ) ; long end = 1000 * ( System . currentTimeMillis ( ) / 1000 + 1 ) ; String linkName = "some-link.txt" ; Files . createSymbolicLink ( Paths . get ( testDir + pathSep + linkName ) , Paths . get ( fileName ) ) ; testProps ( linkName , false , true , st - > { assertNotNull ( st ) ; assertEquals ( fileSize , st . size ( ) ) ; assertTrue ( st . creationTime ( ) >= start ) ; assertTrue ( st . creationTime ( ) <= end ) ; assertTrue ( st . lastAccessTime ( ) >= start ) ; assertTrue ( st . lastAccessTime ( ) <= end ) ; assertTrue ( st . lastModifiedTime ( ) >= start ) ; assertTrue ( st . lastModifiedTime ( ) <= end ) ; assertFalse ( st . isDirectory ( ) ) ; assertFalse ( st . isOther ( ) ) ; assertTrue ( st . isRegularFile ( ) ) ; assertFalse ( st . isSymbolicLink ( ) ) ; } ) ; await ( ) ; } @ Test public void testPropsDontFollowLink ( ) throws Exception { Assume . assumeFalse ( Utils . isWindows ( ) ) ; String fileName = "some-file.txt" ; long fileSize = 1234 ; createFileWithJunk ( fileName , fileSize ) ; String linkName = "some-link.txt" ; Files . createSymbolicLink ( Paths . get ( testDir + pathSep + linkName ) , Paths . get ( fileName ) ) ; testProps ( linkName , true , true , st - > { assertNotNull ( st != null ) ; assertTrue ( st . isSymbolicLink ( ) ) ; } ) ; await ( ) ; } private void testProps ( String fileName , boolean link , boolean shouldPass , Handler < FileProps > afterOK ) throws Exception { AsyncResultHandler < FileProps > handler = ar - > { if ( ar . failed ( ) ) { if ( shouldPass ) { fail ( ar . cause ( ) . getMessage ( ) ) ; } else { assertTrue ( ar . cause ( ) instanceof io . vertx . core . file . FileSystemException ) ; if ( afterOK != null ) { afterOK . handle ( ar . result ( ) ) ; } testComplete ( ) ; } } else { if ( shouldPass ) { if ( afterOK != null ) { afterOK . handle ( ar . result ( ) ) ; } testComplete ( ) ; } else { fail ( "stat should fail" ) ; } } } ; if ( link ) { vertx . fileSystem ( ) . lprops ( testDir + pathSep + fileName , handler ) ; } else { vertx . fileSystem ( ) . props ( testDir + pathSep + fileName , handler ) ; } } @ Test public void testLink ( ) throws Exception { String fileName = "some-file.txt" ; long fileSize = 1234 ; createFileWithJunk ( fileName , fileSize ) ; String linkName = "some-link.txt" ; testLink ( linkName , fileName , false , true , v - > { assertEquals ( fileSize , fileLength ( linkName ) ) ; assertFalse ( Files . isSymbolicLink ( Paths . get ( testDir + pathSep + linkName ) ) ) ; } ) ; await ( ) ; } @ Test public void testSymLink ( ) throws Exception { Assume . assumeFalse ( Utils . isWindows ( ) ) ; String fileName = "some-file.txt" ; long fileSize = 1234 ; createFileWithJunk ( fileName , fileSize ) ; String symlinkName = "some-sym-link.txt" ; testLink ( symlinkName , fileName , true , true , v - > { assertEquals ( fileSize , fileLength ( symlinkName ) ) ; assertTrue ( Files . isSymbolicLink ( Paths . get ( testDir + pathSep + symlinkName ) ) ) ; String read = vertx . fileSystem ( ) . readSymlinkBlocking ( testDir + pathSep + symlinkName ) ; assertEquals ( fileName , read ) ; } ) ; await ( ) ; } private void testLink ( String from , String to , boolean symbolic , boolean shouldPass , Handler < Void > afterOK ) throws Exception { if ( symbolic ) { vertx . fileSystem ( ) . symlink ( testDir + pathSep + from , to , createHandler ( shouldPass , afterOK ) ) ; } else { vertx . fileSystem ( ) . link ( testDir + pathSep + from , testDir + pathSep + to , createHandler ( shouldPass , afterOK ) ) ; } } @ Test public void testUnlink ( ) throws Exception { String fileName = "some-file.txt" ; long fileSize = 1234 ; createFileWithJunk ( fileName , fileSize ) ; String linkName = "some-link.txt" ; Files . createLink ( Paths . get ( testDir + pathSep + linkName ) , Paths . get ( testDir + pathSep + fileName ) ) ; assertEquals ( fileSize , fileLength ( linkName ) ) ; vertx . fileSystem ( ) . unlink ( testDir + pathSep + linkName , createHandler ( true , v - > assertFalse ( fileExists ( linkName ) ) ) ) ; await ( ) ; } @ Test public void testReadSymLink ( ) throws Exception { Assume . assumeFalse ( Utils . isWindows ( ) ) ; String fileName = "some-file.txt" ; long fileSize = 1234 ; createFileWithJunk ( fileName , fileSize ) ; String linkName = "some-link.txt" ; Files . createSymbolicLink ( Paths . get ( testDir + pathSep + linkName ) , Paths . get ( fileName ) ) ; vertx . fileSystem ( ) . readSymlink ( testDir + pathSep + linkName , ar - > { if ( ar . failed ( ) ) { fail ( ar . cause ( ) . getMessage ( ) ) ; } else { assertEquals ( fileName , ar . result ( ) ) ; testComplete ( ) ; } } ) ; await ( ) ; } @ Test public void testSimpleDelete ( ) throws Exception { String fileName = "some-file.txt" ; createFileWithJunk ( fileName , 100 ) ; assertTrue ( fileExists ( fileName ) ) ; testDelete ( fileName , false , true , v - > { assertFalse ( fileExists ( fileName ) ) ; } ) ; await ( ) ; } @ Test public void testDeleteEmptyDir ( ) throws Exception { String dirName = "some-dir" ; mkDir ( dirName ) ; assertTrue ( fileExists ( dirName ) ) ; testDelete ( dirName , false , true , v - > { assertFalse ( fileExists ( dirName ) ) ; } ) ; await ( ) ; } @ Test public void testDeleteNonExistent ( ) throws Exception { String dirName = "some-dir" ; assertFalse ( fileExists ( dirName ) ) ; testDelete ( dirName , false , false , null ) ; await ( ) ; } @ Test public void testDeleteNonEmptyFails ( ) throws Exception { String dirName = "some-dir" ; mkDir ( dirName ) ; String file1 = "some-file.txt" ; createFileWithJunk ( dirName + pathSep + file1 , 100 ) ; testDelete ( dirName , false , false , null ) ; await ( ) ; } @ Test public void testDeleteRecursive ( ) throws Exception { String dir = "some-dir" ; String file1 = pathSep + "file1.dat" ; String file2 = pathSep + "index.html" ; String dir2 = "next-dir" ; String file3 = pathSep + "blah.java" ; mkDir ( dir ) ; createFileWithJunk ( dir + file1 , 100 ) ; createFileWithJunk ( dir + file2 , 100 ) ; mkDir ( dir + pathSep + dir2 ) ; createFileWithJunk ( dir + pathSep + dir2 + file3 , 100 ) ; testDelete ( dir , true , true , v - > { assertFalse ( fileExists ( dir ) ) ; } ) ; await ( ) ; } private void testDelete ( String fileName , boolean recursive , boolean shouldPass , Handler < Void > afterOK ) throws Exception { if ( recursive ) { vertx . fileSystem ( ) . deleteRecursive ( testDir + pathSep + fileName , recursive , createHandler ( shouldPass , afterOK ) ) ; } else { vertx . fileSystem ( ) . delete ( testDir + pathSep + fileName , createHandler ( shouldPass , afterOK ) ) ; } } @ Test public void testMkdirSimple ( ) throws Exception { String dirName = "some-dir" ; testMkdir ( dirName , null , false , true , v - > { assertTrue ( fileExists ( dirName ) ) ; assertTrue ( Files . isDirectory ( Paths . get ( testDir + pathSep + dirName ) ) ) ; } ) ; await ( ) ; } @ Test public void testMkdirWithParentsFails ( ) throws Exception { String dirName = "top-dir" + pathSep + "some-dir" ; testMkdir ( dirName , null , false , false , null ) ; await ( ) ; } @ Test public void testMkdirWithPerms ( ) throws Exception { String dirName = "some-dir" ; String perms = "rwx--x--x" ; testMkdir ( dirName , perms , false , true , v - > { assertTrue ( fileExists ( dirName ) ) ; assertTrue ( Files . isDirectory ( Paths . get ( testDir + pathSep + dirName ) ) ) ; azzertPerms ( perms , dirName ) ; } ) ; await ( ) ; } @ Test public void testMkdirCreateParents ( ) throws Exception { String dirName = "top-dir" + pathSep + "/some-dir" ; testMkdir ( dirName , null , true , true , v - > { assertTrue ( fileExists ( dirName ) ) ; assertTrue ( Files . isDirectory ( Paths . get ( testDir + pathSep + dirName ) ) ) ; } ) ; await ( ) ; } @ Test public void testMkdirCreateParentsWithPerms ( ) throws Exception { String dirName = "top-dir" + pathSep + "/some-dir" ; String perms = "rwx--x--x" ; testMkdir ( dirName , perms , true , true , v - > { assertTrue ( fileExists ( dirName ) ) ; assertTrue ( Files . isDirectory ( Paths . get ( testDir + pathSep + dirName ) ) ) ; azzertPerms ( perms , dirName ) ; } ) ; await ( ) ; } private void testMkdir ( String dirName , String perms , boolean createParents , boolean shouldPass , Handler < Void > afterOK ) throws Exception { AsyncResultHandler < Void > handler = createHandler ( shouldPass , afterOK ) ; if ( createParents ) { if ( perms != null ) { vertx . fileSystem ( ) . mkdirs ( testDir + pathSep + dirName , perms , handler ) ; } else { vertx . fileSystem ( ) . mkdirs ( testDir + pathSep + dirName , handler ) ; } } else { if ( perms != null ) { vertx . fileSystem ( ) . mkdir ( testDir + pathSep + dirName , perms , handler ) ; } else { vertx . fileSystem ( ) . mkdir ( testDir + pathSep + dirName , handler ) ; } } } @ Test public void testReadDirSimple ( ) throws Exception { String dirName = "some-dir" ; mkDir ( dirName ) ; int numFiles = 10 ; for ( int i = 0 ; i < numFiles ; i ++ ) { createFileWithJunk ( dirName + pathSep + "file-" + i + ".dat" , 100 ) ; } testReadDir ( dirName , null , true , fileNames - > { assertEquals ( numFiles , fileNames . size ( ) ) ; Set < String > fset = new HashSet < String > ( ) ; for ( String fileName : fileNames ) { fset . add ( fileName ) ; } File dir = new File ( testDir + pathSep + dirName ) ; String root ; try { root = dir . getCanonicalPath ( ) ; } catch ( IOException e ) { fail ( e . getMessage ( ) ) ; return ; } for ( int i = 0 ; i < numFiles ; i ++ ) { assertTrue ( fset . contains ( root + pathSep + "file-" + i + ".dat" ) ) ; } } ) ; await ( ) ; } @ Test public void testReadDirWithFilter ( ) throws Exception { String dirName = "some-dir" ; mkDir ( dirName ) ; int numFiles = 10 ; for ( int i = 0 ; i < numFiles ; i ++ ) { createFileWithJunk ( dirName + pathSep + "foo-" + i + ".txt" , 100 ) ; } for ( int i = 0 ; i < numFiles ; i ++ ) { createFileWithJunk ( dirName + pathSep + "bar-" + i + ".txt" , 100 ) ; } testReadDir ( dirName , "foo.+" , true , fileNames - > { assertEquals ( numFiles , fileNames . size ( ) ) ; Set < String > fset = new HashSet < > ( ) ; for ( String fileName : fileNames ) { fset . add ( fileName ) ; } File dir = new File ( testDir + pathSep + dirName ) ; String root ; try { root = dir . getCanonicalPath ( ) ; } catch ( IOException e ) { fail ( e . getMessage ( ) ) ; return ; } for ( int i = 0 ; i < numFiles ; i ++ ) { assertTrue ( fset . contains ( root + pathSep + "foo-" + i + ".txt" ) ) ; } } ) ; await ( ) ; } private void testReadDir ( String dirName , String filter , boolean shouldPass , Handler < List < String > > afterOK ) throws Exception { AsyncResultHandler < List < String > > handler = ar - > { if ( ar . failed ( ) ) { if ( shouldPass ) { fail ( ar . cause ( ) . getMessage ( ) ) ; } else { assertTrue ( ar . cause ( ) instanceof FileSystemException ) ; if ( afterOK != null ) { afterOK . handle ( null ) ; } testComplete ( ) ; } } else { if ( shouldPass ) { if ( afterOK != null ) { afterOK . handle ( ar . result ( ) ) ; } testComplete ( ) ; } else { fail ( "read should fail" ) ; } } } ; if ( filter == null ) { vertx . fileSystem ( ) . readDir ( testDir + pathSep + dirName , handler ) ; } else { vertx . fileSystem ( ) . readDir ( testDir + pathSep + dirName , filter , handler ) ; } } @ Test public void testReadFile ( ) throws Exception { byte [ ] content = TestUtils . randomByteArray ( 1000 ) ; String fileName = "some-file.dat" ; createFile ( fileName , content ) ; vertx . fileSystem ( ) . readFile ( testDir + pathSep + fileName , ar - > { if ( ar . failed ( ) ) { fail ( ar . cause ( ) . getMessage ( ) ) ; } else { assertEquals ( Buffer . buffer ( content ) , ar . result ( ) ) ; testComplete ( ) ; } } ) ; await ( ) ; } @ Test public void testWriteFile ( ) throws Exception { byte [ ] content = TestUtils . randomByteArray ( 1000 ) ; Buffer buff = Buffer . buffer ( content ) ; String fileName = "some-file.dat" ; vertx . fileSystem ( ) . writeFile ( testDir + pathSep + fileName , buff , ar - > { if ( ar . failed ( ) ) { fail ( ar . cause ( ) . getMessage ( ) ) ; } else { assertTrue ( fileExists ( fileName ) ) ; assertEquals ( content . length , fileLength ( fileName ) ) ; byte [ ] readBytes ; try { readBytes = Files . readAllBytes ( Paths . get ( testDir + pathSep + fileName ) ) ; } catch ( IOException e ) { fail ( e . getMessage ( ) ) ; return ; } assertEquals ( buff , Buffer . buffer ( readBytes ) ) ; testComplete ( ) ; } } ) ; await ( ) ; } @ Test public void testWriteAsync ( ) throws Exception { String fileName = "some-file.dat" ; int chunkSize = 1000 ; int chunks = 10 ; byte [ ] content = TestUtils . randomByteArray ( chunkSize * chunks ) ; Buffer buff = Buffer . buffer ( content ) ; AtomicInteger count = new AtomicInteger ( ) ; vertx . fileSystem ( ) . open ( testDir + pathSep + fileName , new OpenOptions ( ) , arr - > { if ( arr . succeeded ( ) ) { for ( int i = 0 ; i < chunks ; i ++ ) { Buffer chunk = buff . getBuffer ( i * chunkSize , ( i + 1 ) * chunkSize ) ; assertEquals ( chunkSize , chunk . length ( ) ) ; arr . result ( ) . write ( chunk , i * chunkSize , ar - > { if ( ar . succeeded ( ) ) { if ( count . incrementAndGet ( ) == chunks ) { arr . result ( ) . close ( ar2 - > { if ( ar2 . failed ( ) ) { fail ( ar2 . cause ( ) . getMessage ( ) ) ; } else { assertTrue ( fileExists ( fileName ) ) ; byte [ ] readBytes ; try { readBytes = Files . readAllBytes ( Paths . get ( testDir + pathSep + fileName ) ) ; } catch ( IOException e ) { fail ( e . getMessage ( ) ) ; return ; } Buffer read = Buffer . buffer ( readBytes ) ; assertEquals ( buff , read ) ; testComplete ( ) ; } } ) ; } } else { fail ( ar . cause ( ) . getMessage ( ) ) ; } } ) ; } } else { fail ( arr . cause ( ) . getMessage ( ) ) ; } } ) ; await ( ) ; } @ Test public void testReadAsync ( ) throws Exception { String fileName = "some-file.dat" ; int chunkSize = 1000 ; int chunks = 10 ; byte [ ] content = TestUtils . randomByteArray ( chunkSize * chunks ) ; Buffer expected = Buffer . buffer ( content ) ; createFile ( fileName , content ) ; AtomicInteger reads = new AtomicInteger ( ) ; vertx . fileSystem ( ) . open ( testDir + pathSep + fileName , new OpenOptions ( ) , arr - > { if ( arr . succeeded ( ) ) { Buffer buff = Buffer . buffer ( chunks * chunkSize ) ; for ( int i = 0 ; i < chunks ; i ++ ) { arr . result ( ) . read ( buff , i * chunkSize , i * chunkSize , chunkSize , arb - > { if ( arb . succeeded ( ) ) { if ( reads . incrementAndGet ( ) == chunks ) { arr . result ( ) . close ( ar - > { if ( ar . failed ( ) ) { fail ( ar . cause ( ) . getMessage ( ) ) ; } else { assertEquals ( expected , buff ) ; assertEquals ( buff , arb . result ( ) ) ; testComplete ( ) ; } } ) ; } } else { fail ( arb . cause ( ) . getMessage ( ) ) ; } } ) ; } } else { fail ( arr . cause ( ) . getMessage ( ) ) ; } } ) ; await ( ) ; } @ Test public void testWriteStream ( ) throws Exception { String fileName = "some-file.dat" ; int chunkSize = 1000 ; int chunks = 10 ; byte [ ] content = TestUtils . randomByteArray ( chunkSize * chunks ) ; Buffer buff = Buffer . buffer ( content ) ; vertx . fileSystem ( ) . open ( testDir + pathSep + fileName , new OpenOptions ( ) , ar - > { if ( ar . succeeded ( ) ) { WriteStream < Buffer > ws = ar . result ( ) ; ws . exceptionHandler ( t - > fail ( t . getMessage ( ) ) ) ; for ( int i = 0 ; i < chunks ; i ++ ) { Buffer chunk = buff . getBuffer ( i * chunkSize , ( i + 1 ) * chunkSize ) ; assertEquals ( chunkSize , chunk . length ( ) ) ; ws . write ( chunk ) ; } ar . result ( ) . close ( ar2 - > { if ( ar2 . failed ( ) ) { fail ( ar2 . cause ( ) . getMessage ( ) ) ; } else { assertTrue ( fileExists ( fileName ) ) ; byte [ ] readBytes ; try { readBytes = Files . readAllBytes ( Paths . get ( testDir + pathSep + fileName ) ) ; } catch ( IOException e ) { fail ( e . getMessage ( ) ) ; return ; } assertEquals ( buff , Buffer . buffer ( readBytes ) ) ; testComplete ( ) ; } } ) ; } else { fail ( ar . cause ( ) . getMessage ( ) ) ; } } ) ; await ( ) ; } @ Test public void testWriteStreamAppend ( ) throws Exception { String fileName = "some-file.dat" ; int chunkSize = 1000 ; int chunks = 10 ; byte [ ] existing = TestUtils . randomByteArray ( 1000 ) ; createFile ( fileName , existing ) ; byte [ ] content = TestUtils . randomByteArray ( chunkSize * chunks ) ; Buffer buff = Buffer . buffer ( content ) ; vertx . fileSystem ( ) . open ( testDir + pathSep + fileName , new OpenOptions ( ) , ar - > { if ( ar . succeeded ( ) ) { AsyncFile ws = ar . result ( ) ; long size = vertx . fileSystem ( ) . propsBlocking ( testDir + pathSep + fileName ) . size ( ) ; ws . setWritePos ( size ) ; ws . exceptionHandler ( t - > fail ( t . getMessage ( ) ) ) ; for ( int i = 0 ; i < chunks ; i ++ ) { Buffer chunk = buff . getBuffer ( i * chunkSize , ( i + 1 ) * chunkSize ) ; assertEquals ( chunkSize , chunk . length ( ) ) ; ws . write ( chunk ) ; } ar . result ( ) . close ( ar2 - > { if ( ar2 . failed ( ) ) { fail ( ar2 . cause ( ) . getMessage ( ) ) ; } else { assertTrue ( fileExists ( fileName ) ) ; byte [ ] readBytes ; try { readBytes = Files . readAllBytes ( Paths . get ( testDir + pathSep + fileName ) ) ; } catch ( IOException e ) { fail ( e . getMessage ( ) ) ; return ; } assertEquals ( Buffer . buffer ( existing ) . appendBuffer ( buff ) , Buffer . buffer ( readBytes ) ) ; testComplete ( ) ; } } ) ; } else { fail ( ar . cause ( ) . getMessage ( ) ) ; } } ) ; await ( ) ; } @ Test public void testWriteStreamWithCompositeBuffer ( ) throws Exception { String fileName = "some-file.dat" ; int chunkSize = 1000 ; int chunks = 10 ; byte [ ] content1 = TestUtils . randomByteArray ( chunkSize * ( chunks / 2 ) ) ; byte [ ] content2 = TestUtils . randomByteArray ( chunkSize * ( chunks / 2 ) ) ; ByteBuf byteBuf = Unpooled . wrappedBuffer ( content1 , content2 ) ; Buffer buff = Buffer . buffer ( byteBuf ) ; vertx . fileSystem ( ) . open ( testDir + pathSep + fileName , new OpenOptions ( ) , ar - > { if ( ar . succeeded ( ) ) { WriteStream < Buffer > ws = ar . result ( ) ; ws . exceptionHandler ( t - > fail ( t . getMessage ( ) ) ) ; ws . write ( buff ) ; ar . result ( ) . close ( ar2 - > { if ( ar2 . failed ( ) ) { fail ( ar2 . cause ( ) . getMessage ( ) ) ; } else { assertTrue ( fileExists ( fileName ) ) ; byte [ ] readBytes ; try { readBytes = Files . readAllBytes ( Paths . get ( testDir + pathSep + fileName ) ) ; } catch ( IOException e ) { fail ( e . getMessage ( ) ) ; return ; } assertEquals ( buff , Buffer . buffer ( readBytes ) ) ; byteBuf . release ( ) ; testComplete ( ) ; } } ) ; } else { fail ( ar . cause ( ) . getMessage ( ) ) ; } } ) ; await ( ) ; } @ Test public void testReadStream ( ) throws Exception { String fileName = "some-file.dat" ; int chunkSize = 1000 ; int chunks = 10 ; byte [ ] content = TestUtils . randomByteArray ( chunkSize * chunks ) ; createFile ( fileName , content ) ; vertx . fileSystem ( ) . open ( testDir + pathSep + fileName , new OpenOptions ( ) , ar - > { if ( ar . succeeded ( ) ) { ReadStream < Buffer > rs = ar . result ( ) ; Buffer buff = Buffer . buffer ( ) ; rs . handler ( buff : : appendBuffer ) ; rs . exceptionHandler ( t - > fail ( t . getMessage ( ) ) ) ; rs . endHandler ( v - > { ar . result ( ) . close ( ar2 - > { if ( ar2 . failed ( ) ) { fail ( ar2 . cause ( ) . getMessage ( ) ) ; } else { assertEquals ( Buffer . buffer ( content ) , buff ) ; testComplete ( ) ; } } ) ; } ) ; } else { fail ( ar . cause ( ) . getMessage ( ) ) ; } } ) ; await ( ) ; } @ Test public void testReadStreamSetReadPos ( ) throws Exception { String fileName = "some-file.dat" ; int chunkSize = 1000 ; int chunks = 10 ; byte [ ] content = TestUtils . randomByteArray ( chunkSize * chunks ) ; createFile ( fileName , content ) ; vertx . fileSystem ( ) . open ( testDir + pathSep + fileName , new OpenOptions ( ) , ar - > { if ( ar . succeeded ( ) ) { AsyncFile rs = ar . result ( ) ; rs . setReadPos ( chunkSize * chunks / 2 ) ; Buffer buff = Buffer . buffer ( ) ; rs . handler ( buff : : appendBuffer ) ; rs . exceptionHandler ( t - > fail ( t . getMessage ( ) ) ) ; rs . endHandler ( v - > { ar . result ( ) . close ( ar2 - > { if ( ar2 . failed ( ) ) { fail ( ar2 . cause ( ) . getMessage ( ) ) ; } else { assertEquals ( chunkSize * chunks / 2 , buff . length ( ) ) ; byte [ ] lastHalf = new byte [ chunkSize * chunks / 2 ] ; System . arraycopy ( content , chunkSize * chunks / 2 , lastHalf , 0 , chunkSize * chunks / 2 ) ; assertEquals ( Buffer . buffer ( lastHalf ) , buff ) ; testComplete ( ) ; } } ) ; } ) ; } else { fail ( ar . cause ( ) . getMessage ( ) ) ; } } ) ; await ( ) ; } @ Test @ SuppressWarnings ( "unchecked" ) public void testPumpFileStreams ( ) throws Exception { String fileName1 = "some-file.dat" ; String fileName2 = "some-other-file.dat" ; int fileSize = ( int ) ( AsyncFileImpl . BUFFER_SIZE * 1000.3 ) ; byte [ ] content = TestUtils . randomByteArray ( fileSize ) ; createFile ( fileName1 , content ) ; vertx . fileSystem ( ) . open ( testDir + pathSep + fileName1 , new OpenOptions ( ) , arr - > { if ( arr . succeeded ( ) ) { ReadStream rs = arr . result ( ) ; vertx . fileSystem ( ) . open ( testDir + pathSep + fileName2 , new OpenOptions ( ) , ar - > { if ( ar . succeeded ( ) ) { WriteStream ws = ar . result ( ) ; Pump p = Pump . pump ( rs , ws ) ; p . start ( ) ; rs . endHandler ( v - > { arr . result ( ) . close ( car - > { if ( car . failed ( ) ) { fail ( ar . cause ( ) . getMessage ( ) ) ; } else { ar . result ( ) . close ( ar2 - > { if ( ar2 . failed ( ) ) { fail ( ar2 . cause ( ) . getMessage ( ) ) ; } else { assertTrue ( fileExists ( fileName2 ) ) ; byte [ ] readBytes ; try { readBytes = Files . readAllBytes ( Paths . get ( testDir + pathSep + fileName2 ) ) ; } catch ( IOException e ) { fail ( e . getMessage ( ) ) ; return ; } assertEquals ( Buffer . buffer ( content ) , Buffer . buffer ( readBytes ) ) ; testComplete ( ) ; } } ) ; } } ) ; } ) ; } else { fail ( ar . cause ( ) . getMessage ( ) ) ; } } ) ; } else { fail ( arr . cause ( ) . getMessage ( ) ) ; } } ) ; await ( ) ; } @ Test public void testCreateFileNoPerms ( ) throws Exception { testCreateFile ( null , true ) ; } @ Test public void testCreateFileWithPerms ( ) throws Exception { testCreateFile ( "rwx------" , true ) ; } @ Test public void testCreateFileAlreadyExists ( ) throws Exception { createFileWithJunk ( "some-file.dat" , 100 ) ; testCreateFile ( null , false ) ; } private void testCreateFile ( String perms , boolean shouldPass ) throws Exception { String fileName = "some-file.dat" ; AsyncResultHandler < Void > handler = ar - > { if ( ar . failed ( ) ) { if ( shouldPass ) { fail ( ar . cause ( ) . getMessage ( ) ) ; } else { assertTrue ( ar . cause ( ) instanceof FileSystemException ) ; testComplete ( ) ; } } else { if ( shouldPass ) { assertTrue ( fileExists ( fileName ) ) ; assertEquals ( 0 , fileLength ( fileName ) ) ; if ( perms != null ) { azzertPerms ( perms , fileName ) ; } testComplete ( ) ; } else { fail ( "test should fail" ) ; } } } ; if ( perms != null ) { vertx . fileSystem ( ) . createFile ( testDir + pathSep + fileName , perms , handler ) ; } else { vertx . fileSystem ( ) . createFile ( testDir + pathSep + fileName , handler ) ; } await ( ) ; } @ Test public void testExists ( ) throws Exception { testExists ( true ) ; } @ Test public void testNotExists ( ) throws Exception { testExists ( false ) ; } private void testExists ( boolean exists ) throws Exception { String fileName = "some-file.dat" ; if ( exists ) { createFileWithJunk ( fileName , 100 ) ; } vertx . fileSystem ( ) . exists ( testDir + pathSep + fileName , ar - > { if ( ar . succeeded ( ) ) { if ( exists ) { assertTrue ( ar . result ( ) ) ; } else { assertFalse ( ar . result ( ) ) ; } testComplete ( ) ; } else { fail ( ar . cause ( ) . getMessage ( ) ) ; } } ) ; await ( ) ; } @ Test public void testFSProps ( ) throws Exception { String fileName = "some-file.txt" ; createFileWithJunk ( fileName , 1234 ) ; testFSProps ( fileName , props - > { assertTrue ( props . totalSpace ( ) > 0 ) ; assertTrue ( props . unallocatedSpace ( ) > 0 ) ; assertTrue ( props . usableSpace ( ) > 0 ) ; } ) ; await ( ) ; } private void testFSProps ( String fileName , Handler < FileSystemProps > afterOK ) throws Exception { vertx . fileSystem ( ) . fsProps ( testDir + pathSep + fileName , ar - > { if ( ar . failed ( ) ) { fail ( ar . cause ( ) . getMessage ( ) ) ; } else { afterOK . handle ( ar . result ( ) ) ; testComplete ( ) ; } } ) ; } @ Test public void testOpenOptions ( ) { OpenOptions opts = new OpenOptions ( ) ; assertNull ( opts . getPerms ( ) ) ; String perms = "rwxrwxrwx" ; assertEquals ( opts , opts . setPerms ( perms ) ) ; assertEquals ( perms , opts . getPerms ( ) ) ; assertTrue ( opts . isCreate ( ) ) ; assertEquals ( opts , opts . setCreate ( false ) ) ; assertFalse ( opts . isCreate ( ) ) ; assertFalse ( opts . isCreateNew ( ) ) ; assertEquals ( opts , opts . setCreateNew ( true ) ) ; assertTrue ( opts . isCreateNew ( ) ) ; assertTrue ( opts . isRead ( ) ) ; assertEquals ( opts , opts . setRead ( false ) ) ; assertFalse ( opts . isRead ( ) ) ; assertTrue ( opts . isWrite ( ) ) ; assertEquals ( opts , opts . setWrite ( false ) ) ; assertFalse ( opts . isWrite ( ) ) ; assertFalse ( opts . isDSync ( ) ) ; assertEquals ( opts , opts . setDSync ( true ) ) ; assertTrue ( opts . isDSync ( ) ) ; assertFalse ( opts . isSync ( ) ) ; assertEquals ( opts , opts . setSync ( true ) ) ; assertTrue ( opts . isSync ( ) ) ; assertFalse ( opts . isDeleteOnClose ( ) ) ; assertEquals ( opts , opts . setDeleteOnClose ( true ) ) ; assertTrue ( opts . isDeleteOnClose ( ) ) ; assertFalse ( opts . isTruncateExisting ( ) ) ; assertEquals ( opts , opts . setTruncateExisting ( true ) ) ; assertTrue ( opts . isTruncateExisting ( ) ) ; assertFalse ( opts . isSparse ( ) ) ; assertEquals ( opts , opts . setSparse ( true ) ) ; assertTrue ( opts . isSparse ( ) ) ; } @ Test public void testDefaultOptionOptions ( ) { OpenOptions def = new OpenOptions ( ) ; OpenOptions json = new OpenOptions ( new JsonObject ( ) ) ; assertEquals ( def . getPerms ( ) , json . getPerms ( ) ) ; assertEquals ( def . isRead ( ) , json . isRead ( ) ) ; assertEquals ( def . isWrite ( ) , json . isWrite ( ) ) ; assertEquals ( def . isCreate ( ) , json . isCreate ( ) ) ; assertEquals ( def . isCreateNew ( ) , json . isCreateNew ( ) ) ; assertEquals ( def . isDeleteOnClose ( ) , json . isDeleteOnClose ( ) ) ; assertEquals ( def . isTruncateExisting ( ) , json . isTruncateExisting ( ) ) ; assertEquals ( def . isSparse ( ) , json . isSparse ( ) ) ; assertEquals ( def . isSync ( ) , json . isSync ( ) ) ; assertEquals ( def . isDSync ( ) , json . isDSync ( ) ) ; } @ Test public void testAsyncFileCloseHandlerIsAsync ( ) throws Exception { String fileName = "some-file.dat" ; createFileWithJunk ( fileName , 100 ) ; AsyncFile file = vertx . fileSystem ( ) . openBlocking ( testDir + pathSep + fileName , new OpenOptions ( ) ) ; ThreadLocal stack = new ThreadLocal ( ) ; stack . set ( true ) ; file . close ( ar - > { assertNull ( stack . get ( ) ) ; assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } private AsyncResultHandler < Void > createHandler ( boolean shouldPass , Handler < Void > afterOK ) { return ar - > { if ( ar . failed ( ) ) { if ( shouldPass ) { fail ( ar . cause ( ) . getMessage ( ) ) ; } else { assertTrue ( ar . cause ( ) instanceof FileSystemException ) ; if ( afterOK != null ) { afterOK . handle ( null ) ; } testComplete ( ) ; } } else { if ( shouldPass ) { if ( afterOK != null ) { afterOK . handle ( null ) ; } testComplete ( ) ; } else { fail ( "operation should fail" ) ; } } } ; } private boolean fileExists ( String fileName ) { File file = new File ( testDir , fileName ) ; return file . exists ( ) ; } private void createFileWithJunk ( String fileName , long length ) throws Exception { createFile ( fileName , TestUtils . randomByteArray ( ( int ) length ) ) ; } private void createFile ( String fileName , byte [ ] bytes ) throws Exception { File file = new File ( testDir , fileName ) ; Path path = Paths . get ( file . getCanonicalPath ( ) ) ; Files . write ( path , bytes ) ; setPerms ( path , DEFAULT_FILE_PERMS ) ; } private void deleteDir ( File dir ) { File [ ] files = dir . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . isDirectory ( ) ) { deleteDir ( files [ i ] ) ; } else { files [ i ] . delete ( ) ; } } dir . delete ( ) ; } private void deleteDir ( String dir ) { deleteDir ( new File ( testDir + pathSep + dir ) ) ; } private void mkDir ( String dirName ) throws Exception { File dir = new File ( testDir + pathSep + dirName ) ; dir . mkdir ( ) ; setPerms ( Paths . get ( dir . getCanonicalPath ( ) ) , DEFAULT_DIR_PERMS ) ; } private long fileLength ( String fileName ) { File file = new File ( testDir , fileName ) ; return file . length ( ) ; } private void setPerms ( Path path , String perms ) { if ( Utils . isWindows ( ) == false ) { try { Files . setPosixFilePermissions ( path , PosixFilePermissions . fromString ( perms ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } } private String getPerms ( String fileName ) { try { Set < PosixFilePermission > perms = Files . getPosixFilePermissions ( Paths . get ( testDir + pathSep + fileName ) ) ; return PosixFilePermissions . toString ( perms ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } private void deleteFile ( String fileName ) { File file = new File ( testDir + pathSep + fileName ) ; file . delete ( ) ; } }
package io . vertx . core . shareddata ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . codegen . annotations . VertxGen ; import java . util . Collection ; import java . util . Set ; @ VertxGen public interface LocalMap < K , V > { V get ( K key ) ; V put ( K key , V value ) ; V remove ( K key ) ; void clear ( ) ; int size ( ) ; boolean isEmpty ( ) ; V putIfAbsent ( K key , V value ) ; boolean removeIfPresent ( K key , V value ) ; boolean replaceIfPresent ( K key , V oldValue , V newValue ) ; V replace ( K key , V value ) ; void close ( ) ; @ GenIgnore Set < K > keySet ( ) ; @ GenIgnore Collection < V > values ( ) ; }
package io . vertx . core . shareddata ; import io . vertx . codegen . annotations . VertxGen ; @ VertxGen public interface Lock { void release ( ) ; }
package io . vertx . core . shareddata ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; @ VertxGen public interface Counter { void get ( Handler < AsyncResult < Long > > resultHandler ) ; void incrementAndGet ( Handler < AsyncResult < Long > > resultHandler ) ; void getAndIncrement ( Handler < AsyncResult < Long > > resultHandler ) ; void decrementAndGet ( Handler < AsyncResult < Long > > resultHandler ) ; void addAndGet ( long value , Handler < AsyncResult < Long > > resultHandler ) ; void getAndAdd ( long value , Handler < AsyncResult < Long > > resultHandler ) ; void compareAndSet ( long expected , long value , Handler < AsyncResult < Boolean > > resultHandler ) ; }
package io . vertx . core . shareddata ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; @ VertxGen public interface SharedData { < K , V > void getClusterWideMap ( String name , Handler < AsyncResult < AsyncMap < K , V > > > resultHandler ) ; void getLock ( String name , Handler < AsyncResult < Lock > > resultHandler ) ; void getLockWithTimeout ( String name , long timeout , Handler < AsyncResult < Lock > > resultHandler ) ; void getCounter ( String name , Handler < AsyncResult < Counter > > resultHandler ) ; < K , V > LocalMap < K , V > getLocalMap ( String name ) ; }
package io . vertx . core . shareddata ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; @ VertxGen public interface AsyncMap < K , V > { void get ( K k , Handler < AsyncResult < V > > resultHandler ) ; void put ( K k , V v , Handler < AsyncResult < Void > > completionHandler ) ; void put ( K k , V v , long timeout , Handler < AsyncResult < Void > > completionHandler ) ; void putIfAbsent ( K k , V v , Handler < AsyncResult < V > > completionHandler ) ; void putIfAbsent ( K k , V v , long timeout , Handler < AsyncResult < V > > completionHandler ) ; void remove ( K k , Handler < AsyncResult < V > > resultHandler ) ; void removeIfPresent ( K k , V v , Handler < AsyncResult < Boolean > > resultHandler ) ; void replace ( K k , V v , Handler < AsyncResult < V > > resultHandler ) ; void replaceIfPresent ( K k , V oldValue , V newValue , Handler < AsyncResult < Boolean > > resultHandler ) ; void clear ( Handler < AsyncResult < Void > > resultHandler ) ; void size ( Handler < AsyncResult < Integer > > resultHandler ) ; }
package io . vertx . core . shareddata . impl ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import io . vertx . core . shareddata . Shareable ; public class Checker { static void checkType ( Object obj ) { if ( obj instanceof String || obj instanceof Integer || obj instanceof Long || obj instanceof Boolean || obj instanceof Double || obj instanceof Float || obj instanceof Short || obj instanceof Byte || obj instanceof Character || obj instanceof byte [ ] || obj instanceof Buffer || obj instanceof JsonObject || obj instanceof JsonArray || obj instanceof Shareable ) { } else { throw new IllegalArgumentException ( "Invalid type for shareddata data structure: " + obj . getClass ( ) . getName ( ) ) ; } } static < T > T copyIfRequired ( T obj ) { if ( obj instanceof JsonObject ) { return ( T ) ( ( JsonObject ) obj ) . copy ( ) ; } else if ( obj instanceof JsonArray ) { return ( T ) ( ( JsonArray ) obj ) . copy ( ) ; } else if ( obj instanceof byte [ ] ) { byte [ ] bytes = ( byte [ ] ) obj ; byte [ ] copy = new byte [ bytes . length ] ; System . arraycopy ( bytes , 0 , copy , 0 , bytes . length ) ; return ( T ) copy ; } else if ( obj instanceof Buffer ) { return ( T ) ( ( Buffer ) obj ) . copy ( ) ; } else { return obj ; } } }
package io . vertx . core . shareddata . impl ; import io . vertx . core . AsyncResult ; import io . vertx . core . Context ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . impl . Arguments ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . shareddata . AsyncMap ; import io . vertx . core . shareddata . Counter ; import io . vertx . core . shareddata . LocalMap ; import io . vertx . core . shareddata . Lock ; import io . vertx . core . shareddata . SharedData ; import io . vertx . core . spi . cluster . ClusterManager ; import java . io . Serializable ; import java . util . Objects ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class SharedDataImpl implements SharedData { private static final long DEFAULT_LOCK_TIMEOUT = 10 * 1000 ; private final VertxInternal vertx ; private final ClusterManager clusterManager ; private final ConcurrentMap < String , AsynchronousLock > localLocks = new ConcurrentHashMap < > ( ) ; private final ConcurrentMap < String , Counter > localCounters = new ConcurrentHashMap < > ( ) ; private final ConcurrentMap < Object , LocalMap < ? , ? > > localMaps = new ConcurrentHashMap < > ( ) ; public SharedDataImpl ( VertxInternal vertx , ClusterManager clusterManager ) { this . vertx = vertx ; this . clusterManager = clusterManager ; } @ Override public < K , V > void getClusterWideMap ( String name , Handler < AsyncResult < AsyncMap < K , V > > > resultHandler ) { Objects . requireNonNull ( name , "name" ) ; Objects . requireNonNull ( resultHandler , "resultHandler" ) ; if ( clusterManager == null ) { throw new IllegalStateException ( "Can't get cluster wide map if not clustered" ) ; } } @ Override public void getLock ( String name , Handler < AsyncResult < Lock > > resultHandler ) { Objects . requireNonNull ( name , "name" ) ; Objects . requireNonNull ( resultHandler , "resultHandler" ) ; getLockWithTimeout ( name , DEFAULT_LOCK_TIMEOUT , resultHandler ) ; } @ Override public void getLockWithTimeout ( String name , long timeout , Handler < AsyncResult < Lock > > resultHandler ) { Objects . requireNonNull ( name , "name" ) ; Objects . requireNonNull ( resultHandler , "resultHandler" ) ; Arguments . require ( timeout >= 0 , "timeout must be >= 0" ) ; if ( clusterManager == null ) { getLocalLock ( name , timeout , resultHandler ) ; } else { clusterManager . getLockWithTimeout ( name , timeout , resultHandler ) ; } } @ Override public void getCounter ( String name , Handler < AsyncResult < Counter > > resultHandler ) { Objects . requireNonNull ( name , "name" ) ; Objects . requireNonNull ( resultHandler , "resultHandler" ) ; if ( clusterManager == null ) { getLocalCounter ( name , resultHandler ) ; } else { clusterManager . getCounter ( name , resultHandler ) ; } } @ SuppressWarnings ( "unchecked" ) public < K , V > LocalMap < K , V > getLocalMap ( String name ) { LocalMap < K , V > map = ( LocalMap < K , V > ) localMaps . get ( name ) ; if ( map == null ) { map = new LocalMapImpl < > ( name , localMaps ) ; LocalMap prev = localMaps . putIfAbsent ( name , map ) ; if ( prev != null ) { map = prev ; } } return map ; } private void getLocalLock ( String name , long timeout , Handler < AsyncResult < Lock > > resultHandler ) { AsynchronousLock lock = new AsynchronousLock ( vertx ) ; AsynchronousLock prev = localLocks . putIfAbsent ( name , lock ) ; if ( prev != null ) { lock = lock ( timeout , resultHandler , lock , prev ) ; } } private AsynchronousLock lock ( long timeout , Handler < AsyncResult < Lock > > resultHandler , AsynchronousLock lock , AsynchronousLock prev ) { lock = prev ; lock . acquire ( timeout , resultHandler ) ; return lock ; } private void getLocalCounter ( String name , Handler < AsyncResult < Counter > > resultHandler ) { Counter counter = counter ( name ) ; Counter theCounter = counter ; Context context = vertx . getOrCreateContext ( ) ; } private Counter counter ( String name ) { Counter counter = new AsynchronousCounter ( vertx ) ; Counter prev = localCounters . putIfAbsent ( name , counter ) ; if ( prev != null ) { counter = prev ; } return counter ; } private static void checkType ( Object obj ) { if ( obj == null ) { throw new IllegalArgumentException ( "Cannot put null in key or value of cluster wide map" ) ; } Class < ? > clazz = obj . getClass ( ) ; if ( clazz == Integer . class || clazz == int . class || clazz == Long . class || clazz == long . class || clazz == Short . class || clazz == short . class || clazz == Float . class || clazz == float . class || clazz == Double . class || clazz == double . class || clazz == Boolean . class || clazz == boolean . class || clazz == Byte . class || clazz == byte . class || clazz == String . class || clazz == byte [ ] . class ) { return ; } else if ( obj instanceof ClusterSerializable ) { return ; } else if ( obj instanceof Serializable ) { return ; } else { throw new IllegalArgumentException ( "Invalid type: " + clazz + " to put in cluster wide map" ) ; } } private static class WrappedAsyncMap < K , V > implements AsyncMap < K , V > { private final AsyncMap < K , V > delegate ; WrappedAsyncMap ( AsyncMap < K , V > other ) { this . delegate = other ; } @ Override public void get ( K k , Handler < AsyncResult < V > > asyncResultHandler ) { delegate . get ( k , asyncResultHandler ) ; } @ Override public void put ( K k , V v , Handler < AsyncResult < Void > > completionHandler ) { checkType ( k ) ; checkType ( v ) ; delegate . put ( k , v , completionHandler ) ; } @ Override public void put ( K k , V v , long timeout , Handler < AsyncResult < Void > > completionHandler ) { checkType ( k ) ; checkType ( v ) ; delegate . put ( k , v , timeout , completionHandler ) ; } @ Override public void putIfAbsent ( K k , V v , Handler < AsyncResult < V > > completionHandler ) { checkType ( k ) ; checkType ( v ) ; delegate . putIfAbsent ( k , v , completionHandler ) ; } @ Override public void putIfAbsent ( K k , V v , long timeout , Handler < AsyncResult < V > > completionHandler ) { checkType ( k ) ; checkType ( v ) ; delegate . putIfAbsent ( k , v , timeout , completionHandler ) ; } @ Override public void remove ( K k , Handler < AsyncResult < V > > resultHandler ) { delegate . remove ( k , resultHandler ) ; } @ Override public void removeIfPresent ( K k , V v , Handler < AsyncResult < Boolean > > resultHandler ) { delegate . removeIfPresent ( k , v , resultHandler ) ; } @ Override public void replace ( K k , V v , Handler < AsyncResult < V > > resultHandler ) { delegate . replace ( k , v , resultHandler ) ; } @ Override public void replaceIfPresent ( K k , V oldValue , V newValue , Handler < AsyncResult < Boolean > > resultHandler ) { delegate . replaceIfPresent ( k , oldValue , newValue , resultHandler ) ; } @ Override public void clear ( Handler < AsyncResult < Void > > resultHandler ) { delegate . clear ( resultHandler ) ; } @ Override public void size ( Handler < AsyncResult < Integer > > resultHandler ) { delegate . size ( resultHandler ) ; } } }
package io . vertx . core . shareddata . impl ; import io . vertx . core . * ; import io . vertx . core . shareddata . Lock ; import java . util . LinkedList ; import java . util . Queue ; public class AsynchronousLock implements Lock { private Vertx vertx ; private Queue < LockWaiter > waiters = new LinkedList < > ( ) ; private boolean owned ; public AsynchronousLock ( Vertx vertx ) { this . vertx = vertx ; } public AsynchronousLock ( ) { } public void acquire ( long timeout , Handler < AsyncResult < Lock > > resultHandler ) { Context context = vertx . getOrCreateContext ( ) ; doAcquire ( context , timeout , resultHandler ) ; } @ Override public synchronized void release ( ) { AsynchronousLock . LockWaiter waiter = waiter ( ) ; if ( waiter != null ) { } else { owned = false ; } } private AsynchronousLock . LockWaiter waiter ( ) { LockWaiter waiter = pollWaiters ( ) ; if ( waiter != null ) { waiter . acquire ( this ) ; } else { } return waiter ; } public void doAcquire ( Context context , long timeout , Handler < AsyncResult < Lock > > resultHandler ) { synchronized ( this ) { if ( ! owned ) { owned = true ; lockAquired ( context , resultHandler ) ; } else { waiters . add ( new LockWaiter ( this , context , timeout , resultHandler ) ) ; } } } private void lockAquired ( Context context , Handler < AsyncResult < Lock > > resultHandler ) { context . runOnContext ( v - > resultHandler . handle ( Future . succeededFuture ( this ) ) ) ; } private LockWaiter pollWaiters ( ) { while ( true ) { LockWaiter waiter = waiters . poll ( ) ; if ( waiter == null ) { return null ; } else if ( ! waiter . timedOut ) { return waiter ; } } } private class LockWaiter { final AsynchronousLock lock ; final Context context ; final Handler < AsyncResult < Lock > > resultHandler ; volatile boolean timedOut ; volatile boolean acquired ; LockWaiter ( AsynchronousLock lock , Context context , long timeout , Handler < AsyncResult < Lock > > resultHandler ) { this . lock = lock ; this . context = context ; this . resultHandler = resultHandler ; if ( timeout != Long . MAX_VALUE ) { context . owner ( ) . setTimer ( timeout , tid - > timedOut ( ) ) ; } } void timedOut ( ) { synchronized ( lock ) { if ( ! acquired ) { timedOut = true ; context . runOnContext ( v - > resultHandler . handle ( Future . failedFuture ( new VertxException ( "Timed out waiting to get lock" ) ) ) ) ; } } } void acquire ( AsynchronousLock lock ) { acquired = true ; lock . lockAquired ( context , resultHandler ) ; } } }
package io . vertx . core . shareddata . impl ; import io . vertx . core . shareddata . LocalMap ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import static io . vertx . core . shareddata . impl . Checker . * ; class LocalMapImpl < K , V > implements LocalMap < K , V > { private final ConcurrentMap < Object , LocalMap < ? , ? > > maps ; private final String name ; private final ConcurrentMap < K , V > map = new ConcurrentHashMap < > ( ) ; LocalMapImpl ( String name , ConcurrentMap < Object , LocalMap < ? , ? > > maps ) { this . name = name ; this . maps = maps ; } @ Override public V get ( K key ) { return copyIfRequired ( map . get ( key ) ) ; } @ Override public V put ( K key , V value ) { checkType ( key ) ; checkType ( value ) ; return map . put ( key , value ) ; } @ Override public V remove ( K key ) { return copyIfRequired ( map . remove ( key ) ) ; } @ Override public void clear ( ) { map . clear ( ) ; } @ Override public int size ( ) { return map . size ( ) ; } @ Override public boolean isEmpty ( ) { return map . isEmpty ( ) ; } @ Override public V putIfAbsent ( K key , V value ) { checkType ( key ) ; checkType ( value ) ; return copyIfRequired ( map . putIfAbsent ( key , value ) ) ; } @ Override public boolean removeIfPresent ( K key , V value ) { return map . remove ( key , value ) ; } @ Override public boolean replaceIfPresent ( K key , V oldValue , V newValue ) { checkType ( key ) ; checkType ( oldValue ) ; checkType ( newValue ) ; return map . replace ( key , oldValue , newValue ) ; } @ Override public V replace ( K key , V value ) { checkType ( key ) ; checkType ( value ) ; return copyIfRequired ( map . replace ( key , value ) ) ; } @ Override public void close ( ) { maps . remove ( name ) ; } @ Override public Set < K > keySet ( ) { Set < K > keys = new HashSet < > ( map . size ( ) ) ; for ( K k : map . keySet ( ) ) { keys . add ( copyIfRequired ( k ) ) ; } return keys ; } @ Override public Collection < V > values ( ) { List < V > values = new ArrayList < > ( map . size ( ) ) ; for ( V v : map . values ( ) ) { values . add ( copyIfRequired ( v ) ) ; } return values ; } }
package io . vertx . core . shareddata . impl ; import io . vertx . core . AsyncResult ; import io . vertx . core . Context ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . shareddata . Counter ; import java . util . Objects ; import java . util . concurrent . atomic . AtomicLong ; public class AsynchronousCounter implements Counter { private final VertxInternal vertx ; private final AtomicLong counter ; public AsynchronousCounter ( VertxInternal vertx ) { this . vertx = vertx ; this . counter = new AtomicLong ( ) ; } public AsynchronousCounter ( VertxInternal vertx , AtomicLong counter ) { this . vertx = vertx ; this . counter = counter ; } @ Override public void get ( Handler < AsyncResult < Long > > resultHandler ) { Objects . requireNonNull ( resultHandler , "resultHandler" ) ; Context context = vertx . getOrCreateContext ( ) ; context . runOnContext ( v - > resultHandler . handle ( Future . succeededFuture ( counter . get ( ) ) ) ) ; } @ Override public void incrementAndGet ( Handler < AsyncResult < Long > > resultHandler ) { Objects . requireNonNull ( resultHandler , "resultHandler" ) ; Context context = vertx . getOrCreateContext ( ) ; context . runOnContext ( v - > resultHandler . handle ( Future . succeededFuture ( counter . incrementAndGet ( ) ) ) ) ; } @ Override public void getAndIncrement ( Handler < AsyncResult < Long > > resultHandler ) { Objects . requireNonNull ( resultHandler , "resultHandler" ) ; Context context = vertx . getOrCreateContext ( ) ; context . runOnContext ( v - > resultHandler . handle ( Future . succeededFuture ( counter . getAndIncrement ( ) ) ) ) ; } @ Override public void decrementAndGet ( Handler < AsyncResult < Long > > resultHandler ) { Objects . requireNonNull ( resultHandler , "resultHandler" ) ; Context context = vertx . getOrCreateContext ( ) ; context . runOnContext ( v - > resultHandler . handle ( Future . succeededFuture ( counter . decrementAndGet ( ) ) ) ) ; } @ Override public void addAndGet ( long value , Handler < AsyncResult < Long > > resultHandler ) { Objects . requireNonNull ( resultHandler , "resultHandler" ) ; Context context = vertx . getOrCreateContext ( ) ; context . runOnContext ( v - > resultHandler . handle ( Future . succeededFuture ( counter . addAndGet ( value ) ) ) ) ; } @ Override public void getAndAdd ( long value , Handler < AsyncResult < Long > > resultHandler ) { Objects . requireNonNull ( resultHandler , "resultHandler" ) ; Context context = vertx . getOrCreateContext ( ) ; context . runOnContext ( v - > resultHandler . handle ( Future . succeededFuture ( counter . getAndAdd ( value ) ) ) ) ; } @ Override public void compareAndSet ( long expected , long value , Handler < AsyncResult < Boolean > > resultHandler ) { Objects . requireNonNull ( resultHandler , "resultHandler" ) ; Context context = vertx . getOrCreateContext ( ) ; context . runOnContext ( v - > resultHandler . handle ( Future . succeededFuture ( counter . compareAndSet ( expected , value ) ) ) ) ; } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . impl . IsolatingClassLoader ; import org . junit . Assert ; public class ExtraCPVerticleNotInParentLoader extends AbstractVerticle { @ Override public void start ( ) throws Exception { IsolatingClassLoader cl = ( IsolatingClassLoader ) Thread . currentThread ( ) . getContextClassLoader ( ) ; Class extraCPClass = cl . loadClass ( "MyVerticle" ) ; Assert . assertSame ( extraCPClass . getClassLoader ( ) , cl ) ; try { cl . getParent ( ) . loadClass ( "MyVerticle" ) ; Assert . fail ( "Parent classloader should not see this class" ) ; } catch ( ClassNotFoundException expected ) { } } }
package io . vertx . test . core ; import io . vertx . core . eventbus . EventBus ; import io . vertx . core . eventbus . Message ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import org . junit . Test ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class JSONEventBusTest extends VertxTestBase { private EventBus eb ; public void setUp ( ) throws Exception { super . setUp ( ) ; eb = vertx . eventBus ( ) ; } @ Test public void testChangesNotVisibleObject1 ( ) { JsonObject obj = new JsonObject ( ) ; eb . < JsonObject > consumer ( "foo" ) . handler ( ( Message < JsonObject > msg ) - > { assertFalse ( msg . body ( ) . containsKey ( "b" ) ) ; testComplete ( ) ; } ) ; eb . send ( "foo" , obj ) ; obj . put ( "b" , "blurrgg" ) ; await ( ) ; } @ Test public void testChangesNotVisibleObject2 ( ) { final JsonObject obj = new JsonObject ( ) ; eb . < JsonObject > consumer ( "foo" ) . handler ( ( Message < JsonObject > msg ) - > { msg . body ( ) . put ( "b" , "uqwduihwqd" ) ; } ) ; eb . send ( "foo" , obj ) ; vertx . setTimer ( 1000 , id - > { assertFalse ( obj . containsKey ( "b" ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testChangesNotVisibleObject3 ( ) { Map < String , Object > map = new HashMap < > ( ) ; final JsonObject obj = new JsonObject ( map ) ; eb . < JsonObject > consumer ( "foo" ) . handler ( ( Message < JsonObject > msg ) - > { vertx . setTimer ( 1000 , id - > { assertFalse ( msg . body ( ) . containsKey ( "b" ) ) ; testComplete ( ) ; } ) ; } ) ; eb . send ( "foo" , obj ) ; map . put ( "b" , "uhqdihuqwd" ) ; await ( ) ; } @ Test public void testChangesNotVisibleArray1 ( ) { JsonArray obj = new JsonArray ( ) ; eb . < JsonArray > consumer ( "foo" ) . handler ( ( Message < JsonArray > msg ) - > { assertEquals ( 0 , msg . body ( ) . size ( ) ) ; testComplete ( ) ; } ) ; eb . send ( "foo" , obj ) ; obj . add ( "blah" ) ; await ( ) ; } @ Test public void testChangesNotVisibleArray2 ( ) { final JsonArray obj = new JsonArray ( ) ; eb . < JsonArray > consumer ( "foo" ) . handler ( ( Message < JsonArray > msg ) - > msg . body ( ) . add ( "blah" ) ) ; eb . send ( "foo" , obj ) ; vertx . setTimer ( 1000 , id - > { assertEquals ( 0 , obj . size ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testChangesNotVisibleArray3 ( ) { List < Object > list = new ArrayList < > ( ) ; final JsonArray obj = new JsonArray ( list ) ; eb . < JsonArray > consumer ( "foo" ) . handler ( ( Message < JsonArray > msg ) - > { vertx . setTimer ( 1000 , id - > { assertEquals ( 0 , msg . body ( ) . size ( ) ) ; testComplete ( ) ; } ) ; } ) ; eb . send ( "foo" , obj ) ; list . add ( "uhwqdiuh" ) ; await ( ) ; } }
package io . vertx . core . shareddata . impl ; import io . vertx . core . buffer . Buffer ; public interface ClusterSerializable { void writeToBuffer ( Buffer buffer ) ; int readFromBuffer ( int pos , Buffer buffer ) ; }
package io . vertx . core . metrics ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . json . JsonObject ; @ DataObject public class MetricsOptions { public static final boolean DEFAULT_METRICS_ENABLED = false ; private boolean enabled ; private JsonObject json ; public MetricsOptions ( ) { enabled = DEFAULT_METRICS_ENABLED ; } public MetricsOptions ( MetricsOptions other ) { enabled = other . isEnabled ( ) ; } public MetricsOptions ( JsonObject json ) { this . enabled = json . getBoolean ( "enabled" , DEFAULT_METRICS_ENABLED ) ; this . json = json . copy ( ) ; } public boolean isEnabled ( ) { return enabled ; } public MetricsOptions setEnabled ( boolean enable ) { this . enabled = enable ; return this ; } public JsonObject toJson ( ) { return json != null ? json . copy ( ) : new JsonObject ( ) ; } }
package io . vertx . core . metrics ;
package io . vertx . core . metrics ; import io . vertx . codegen . annotations . VertxGen ; @ VertxGen ( concrete = false ) public interface Measured { boolean isMetricsEnabled ( ) ; }
package io . vertx . core . metrics . impl ; import io . vertx . core . Verticle ; import io . vertx . core . datagram . DatagramSocket ; import io . vertx . core . datagram . DatagramSocketOptions ; import io . vertx . core . eventbus . EventBus ; import io . vertx . core . eventbus . ReplyFailure ; import io . vertx . core . http . HttpClient ; import io . vertx . core . http . HttpClientOptions ; import io . vertx . core . http . HttpClientRequest ; import io . vertx . core . http . HttpClientResponse ; import io . vertx . core . http . HttpServer ; import io . vertx . core . http . HttpServerOptions ; import io . vertx . core . http . HttpServerRequest ; import io . vertx . core . http . HttpServerResponse ; import io . vertx . core . http . ServerWebSocket ; import io . vertx . core . http . WebSocket ; import io . vertx . core . spi . metrics . DatagramSocketMetrics ; import io . vertx . core . spi . metrics . EventBusMetrics ; import io . vertx . core . spi . metrics . HttpClientMetrics ; import io . vertx . core . spi . metrics . HttpServerMetrics ; import io . vertx . core . spi . metrics . TCPMetrics ; import io . vertx . core . spi . metrics . VertxMetrics ; import io . vertx . core . net . NetClient ; import io . vertx . core . net . NetClientOptions ; import io . vertx . core . net . NetServer ; import io . vertx . core . net . NetServerOptions ; import io . vertx . core . net . SocketAddress ; public class DummyVertxMetrics implements VertxMetrics { @ Override public void verticleDeployed ( Verticle verticle ) { } @ Override public void verticleUndeployed ( Verticle verticle ) { } @ Override public void timerCreated ( long id ) { } @ Override public void timerEnded ( long id , boolean cancelled ) { } @ Override public EventBusMetrics createMetrics ( EventBus eventBus ) { return new DummyEventBusMetrics ( ) ; } @ Override public HttpServerMetrics createMetrics ( HttpServer server , SocketAddress localAddress , HttpServerOptions options ) { return new DummyHttpServerMetrics ( ) ; } @ Override public HttpClientMetrics createMetrics ( HttpClient client , HttpClientOptions options ) { return new DummyHttpClientMetrics ( ) ; } @ Override public TCPMetrics createMetrics ( NetServer server , SocketAddress localAddress , NetServerOptions options ) { return new DummyTCPMetrics ( ) ; } @ Override public TCPMetrics createMetrics ( NetClient client , NetClientOptions options ) { return new DummyTCPMetrics ( ) ; } @ Override public DatagramSocketMetrics createMetrics ( DatagramSocket socket , DatagramSocketOptions options ) { return new DummyDatagramMetrics ( ) ; } @ Override public void close ( ) { } @ Override public boolean isEnabled ( ) { return false ; } @ Override public boolean isMetricsEnabled ( ) { return false ; } protected class DummyEventBusMetrics implements EventBusMetrics < Void > { @ Override public void messageWritten ( String address , int numberOfBytes ) { } @ Override public void messageRead ( String address , int numberOfBytes ) { } @ Override public Void handlerRegistered ( String address , boolean replyHandler ) { return null ; } @ Override public void handlerUnregistered ( Void handler ) { } @ Override public void beginHandleMessage ( Void handler , boolean local ) { } @ Override public void endHandleMessage ( Void handler , Throwable failure ) { } @ Override public void messageSent ( String address , boolean publish , boolean local , boolean remote ) { } @ Override public void messageReceived ( String address , boolean publish , boolean local , int handlers ) { } @ Override public void replyFailure ( String address , ReplyFailure failure ) { } @ Override public boolean isEnabled ( ) { return false ; } @ Override public void close ( ) { } } protected class DummyHttpServerMetrics implements HttpServerMetrics < Void , Void , Void > { @ Override public Void requestBegin ( Void socketMetric , HttpServerRequest request ) { return null ; } @ Override public void responseEnd ( Void requestMetric , HttpServerResponse response ) { } @ Override public Void upgrade ( Void requestMetric , ServerWebSocket serverWebSocket ) { return null ; } @ Override public Void connected ( SocketAddress remoteAddress ) { return null ; } @ Override public void disconnected ( Void socketMetric , SocketAddress remoteAddress ) { } @ Override public void bytesRead ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { } @ Override public void bytesWritten ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { } @ Override public void exceptionOccurred ( Void socketMetric , SocketAddress remoteAddress , Throwable t ) { } @ Override public void close ( ) { } @ Override public boolean isEnabled ( ) { return false ; } @ Override public Void connected ( Void socketMetric , ServerWebSocket serverWebSocket ) { return null ; } @ Override public void disconnected ( Void serverWebSocketMetric ) { } } protected class DummyHttpClientMetrics implements HttpClientMetrics < Void , Void , Void > { @ Override public Void requestBegin ( Void socketMetric , SocketAddress localAddress , SocketAddress remoteAddress , HttpClientRequest request ) { return null ; } @ Override public void responseEnd ( Void requestMetric , HttpClientResponse response ) { } @ Override public Void connected ( SocketAddress remoteAddress ) { return null ; } @ Override public void disconnected ( Void socketMetric , SocketAddress remoteAddress ) { } @ Override public void bytesRead ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { } @ Override public void bytesWritten ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { } @ Override public void exceptionOccurred ( Void socketMetric , SocketAddress remoteAddress , Throwable t ) { } @ Override public void close ( ) { } @ Override public boolean isEnabled ( ) { return false ; } @ Override public Void connected ( Void socketMetric , WebSocket webSocket ) { return null ; } @ Override public void disconnected ( Void webSocketMetric ) { } } protected class DummyTCPMetrics implements TCPMetrics < Void > { @ Override public Void connected ( SocketAddress remoteAddress ) { return null ; } @ Override public void disconnected ( Void socketMetric , SocketAddress remoteAddress ) { } @ Override public void bytesRead ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { } @ Override public void bytesWritten ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { } @ Override public void exceptionOccurred ( Void socketMetric , SocketAddress remoteAddress , Throwable t ) { } @ Override public void close ( ) { } @ Override public boolean isEnabled ( ) { return false ; } } protected class DummyDatagramMetrics implements DatagramSocketMetrics { @ Override public void listening ( SocketAddress localAddress ) { } @ Override public void bytesRead ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { } @ Override public void bytesWritten ( Void socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { } @ Override public void exceptionOccurred ( Void socketMetric , SocketAddress remoteAddress , Throwable t ) { } @ Override public void close ( ) { } @ Override public boolean isEnabled ( ) { return false ; } } }
@ Document ( fileName = "dns.adoc" ) package io . vertx . core . dns ; import io . vertx . docgen . Document ;
package io . vertx . core . dns ; import io . vertx . codegen . annotations . VertxGen ; @ VertxGen public interface SrvRecord { int priority ( ) ; int weight ( ) ; int port ( ) ; String name ( ) ; String protocol ( ) ; String service ( ) ; String target ( ) ; }
package io . vertx . core . dns ; import io . vertx . codegen . annotations . VertxGen ; @ VertxGen public interface MxRecord { int priority ( ) ; String name ( ) ; }
package io . vertx . core . dns ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import java . net . Inet4Address ; import java . net . Inet6Address ; import java . util . List ; @ VertxGen public interface DnsClient { @ Fluent DnsClient lookup ( String name , Handler < AsyncResult < String > > handler ) ; @ Fluent DnsClient lookup4 ( String name , Handler < AsyncResult < String > > handler ) ; @ Fluent DnsClient lookup6 ( String name , Handler < AsyncResult < String > > handler ) ; @ Fluent DnsClient resolveA ( String name , Handler < AsyncResult < List < String > > > handler ) ; @ Fluent DnsClient resolveAAAA ( String name , Handler < AsyncResult < List < String > > > handler ) ; @ Fluent DnsClient resolveCNAME ( String name , Handler < AsyncResult < List < String > > > handler ) ; @ Fluent DnsClient resolveMX ( String name , Handler < AsyncResult < List < MxRecord > > > handler ) ; @ Fluent DnsClient resolveTXT ( String name , Handler < AsyncResult < List < String > > > handler ) ; @ Fluent DnsClient resolvePTR ( String name , Handler < AsyncResult < String > > handler ) ; @ Fluent DnsClient resolveNS ( String name , Handler < AsyncResult < List < String > > > handler ) ; @ Fluent DnsClient resolveSRV ( String name , Handler < AsyncResult < List < SrvRecord > > > handler ) ; @ Fluent DnsClient reverseLookup ( String ipaddress , Handler < AsyncResult < String > > handler ) ; }
package io . vertx . core . dns ; import java . util . Objects ; public final class DnsException extends Exception { private DnsResponseCode code ; public DnsException ( DnsResponseCode code ) { Objects . requireNonNull ( code , "code" ) ; this . code = code ; } public DnsResponseCode code ( ) { return code ; } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . json . JsonObject ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; public class TestVerticle extends AbstractVerticle { public static AtomicInteger instanceCount = new AtomicInteger ( ) ; public static List < String > processArgs ; public static JsonObject conf ; public TestVerticle ( ) { } @ Override public void start ( ) throws Exception { processArgs = context . processArgs ( ) ; conf = context . config ( ) ; vertx . eventBus ( ) . send ( "testcounts" , new JsonObject ( ) . put ( "deploymentID" , context . deploymentID ( ) ) . put ( "count" , instanceCount . incrementAndGet ( ) ) ) ; } @ Override public void stop ( ) throws Exception { } }
package io . vertx . core . dns ; public enum DnsResponseCode { NOERROR ( 0 , "no error" ) , FORMERROR ( 1 , "format error" ) , SERVFAIL ( 2 , "server failure" ) , NXDOMAIN ( 3 , "name error" ) , NOTIMPL ( 4 , "not implemented" ) , REFUSED ( 5 , "operation refused" ) , YXDOMAIN ( 6 , "domain name should not exist" ) , YXRRSET ( 7 , "resource record set should not exist" ) , NXRRSET ( 8 , "rrset does not exist" ) , NOTAUTH ( 9 , "not authoritative for zone" ) , NOTZONE ( 10 , "name not in zone" ) , BADVERS ( 11 , "bad extension mechanism for version" ) , BADSIG ( 12 , "bad signature" ) , BADKEY ( 13 , "bad key" ) , BADTIME ( 14 , "bad timestamp" ) ; private final int errorCode ; private final String message ; public static DnsResponseCode valueOf ( int responseCode ) { DnsResponseCode [ ] errors = DnsResponseCode . values ( ) ; for ( DnsResponseCode e : errors ) { if ( e . errorCode == responseCode ) { return e ; } } return null ; } private DnsResponseCode ( int errorCode , String message ) { this . errorCode = errorCode ; this . message = message ; } public int code ( ) { return errorCode ; } @ Override public String toString ( ) { return name ( ) + ": type " + errorCode + ", " + message ; } }
package io . vertx . core . dns . impl ; import io . vertx . core . dns . SrvRecord ; import io . vertx . core . dns . impl . netty . decoder . record . ServiceRecord ; final class SrcRecordImpl implements SrvRecord , Comparable < SrvRecord > { private final ServiceRecord record ; SrcRecordImpl ( ServiceRecord record ) { this . record = record ; } @ Override public int priority ( ) { return record . priority ( ) ; } @ Override public int weight ( ) { return record . weight ( ) ; } @ Override public int port ( ) { return record . port ( ) ; } @ Override public String name ( ) { return record . name ( ) ; } @ Override public String protocol ( ) { return record . protocol ( ) ; } @ Override public String service ( ) { return record . service ( ) ; } @ Override public String target ( ) { return record . target ( ) ; } @ Override public int compareTo ( SrvRecord o ) { return Integer . valueOf ( priority ( ) ) . compareTo ( o . priority ( ) ) ; } }
package io . vertx . core . dns . impl ; import java . util . Comparator ; final class MxRecordComparator implements Comparator < MxRecordImpl > { static final Comparator < MxRecordImpl > INSTANCE = new MxRecordComparator ( ) ; private MxRecordComparator ( ) { } @ Override public int compare ( MxRecordImpl o1 , MxRecordImpl o2 ) { return o1 . compareTo ( o2 ) ; } }
package io . vertx . core . dns . impl ; import io . vertx . core . dns . MxRecord ; import io . vertx . core . dns . impl . netty . decoder . record . MailExchangerRecord ; final class MxRecordImpl implements MxRecord , Comparable < MxRecord > { private final MailExchangerRecord record ; MxRecordImpl ( MailExchangerRecord record ) { this . record = record ; } @ Override public int priority ( ) { return record . priority ( ) ; } @ Override public String name ( ) { return record . name ( ) ; } @ Override public String toString ( ) { return priority ( ) + " " + name ( ) ; } @ Override public int compareTo ( MxRecord o ) { return Integer . valueOf ( priority ( ) ) . compareTo ( o . priority ( ) ) ; } }
package io . vertx . core . dns . impl ; import java . util . Comparator ; final class SrvRecordComparator implements Comparator < SrcRecordImpl > { static final Comparator < SrcRecordImpl > INSTANCE = new SrvRecordComparator ( ) ; private SrvRecordComparator ( ) { } @ Override public int compare ( SrcRecordImpl o1 , SrcRecordImpl o2 ) { return o1 . compareTo ( o2 ) ; } }
package io . vertx . core . dns . impl ; import io . netty . bootstrap . Bootstrap ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelOption ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . socket . DatagramChannel ; import io . netty . channel . socket . DatagramPacket ; import io . netty . channel . socket . nio . NioDatagramChannel ; import io . vertx . core . AsyncResult ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . dns . DnsClient ; import io . vertx . core . dns . DnsException ; import io . vertx . core . dns . DnsResponseCode ; import io . vertx . core . dns . MxRecord ; import io . vertx . core . dns . SrvRecord ; import io . vertx . core . dns . impl . netty . DnsEntry ; import io . vertx . core . dns . impl . netty . DnsQuery ; import io . vertx . core . dns . impl . netty . DnsQueryEncoder ; import io . vertx . core . dns . impl . netty . DnsQuestion ; import io . vertx . core . dns . impl . netty . DnsResource ; import io . vertx . core . dns . impl . netty . DnsResponse ; import io . vertx . core . dns . impl . netty . DnsResponseDecoder ; import io . vertx . core . dns . impl . netty . decoder . RecordDecoderFactory ; import io . vertx . core . dns . impl . netty . decoder . record . MailExchangerRecord ; import io . vertx . core . dns . impl . netty . decoder . record . ServiceRecord ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . net . impl . PartialPooledByteBufAllocator ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . UnknownHostException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Objects ; import java . util . concurrent . ThreadLocalRandom ; public final abstract class DnsClientImpl implements DnsClient { private static final char [ ] HEX_TABLE = "0123456789abcdef" . toCharArray ( ) ; private final Bootstrap bootstrap ; private final InetSocketAddress dnsServer ; private final ContextImpl actualCtx ; public DnsClientImpl ( VertxInternal vertx , int port , String host ) { ContextImpl creatingContext = vertx . getContext ( ) ; if ( creatingContext != null && creatingContext . isMultiThreadedWorkerContext ( ) ) { throw new IllegalStateException ( "Cannot use DnsClient in a multi-threaded worker verticle" ) ; } this . dnsServer = new InetSocketAddress ( host , port ) ; actualCtx = vertx . getOrCreateContext ( ) ; bootstrap = new Bootstrap ( ) ; bootstrap . group ( actualCtx . eventLoop ( ) ) ; bootstrap . channel ( NioDatagramChannel . class ) ; bootstrap . option ( ChannelOption . ALLOCATOR , PartialPooledByteBufAllocator . INSTANCE ) ; bootstrap . handler ( new ChannelInitializer < DatagramChannel > ( ) { @ Override protected void initChannel ( DatagramChannel ch ) throws Exception { ChannelPipeline pipeline = ch . pipeline ( ) ; pipeline . addLast ( new DnsQueryEncoder ( ) ) ; pipeline . addLast ( new DnsResponseDecoder ( ) ) ; } } ) ; } @ Override public DnsClient lookup4 ( String name , Handler < AsyncResult < String > > handler ) { lookup ( name , new HandlerAdapter < String > ( handler ) , DnsEntry . TYPE_A ) ; return this ; } @ Override public DnsClient lookup6 ( String name , Handler < AsyncResult < String > > handler ) { lookup ( name , new HandlerAdapter < String > ( handler ) , DnsEntry . TYPE_AAAA ) ; return this ; } @ Override public DnsClient lookup ( String name , Handler < AsyncResult < String > > handler ) { lookup ( name , new HandlerAdapter < String > ( handler ) , DnsEntry . TYPE_A , DnsEntry . TYPE_AAAA ) ; return this ; } @ Override public DnsClient resolveA ( String name , Handler < AsyncResult < List < String > > > handler ) { lookup ( name , handler , DnsEntry . TYPE_A ) ; return this ; } @ Override public DnsClient resolveCNAME ( String name , Handler < AsyncResult < List < String > > > handler ) { lookup ( name , handler , DnsEntry . TYPE_CNAME ) ; return this ; } @ Override public DnsClient resolveTXT ( String name , Handler < AsyncResult < List < String > > > handler ) { lookup ( name , new Handler < AsyncResult > ( ) { @ SuppressWarnings ( "unchecked" ) @ Override public void handle ( AsyncResult event ) { if ( event . failed ( ) ) { handler . handle ( event ) ; } else { List < String > txts = new ArrayList < > ( ) ; List < List < String > > records = ( List < List < String > > ) event . result ( ) ; for ( List < String > txt : records ) { txts . addAll ( txt ) ; } handler . handle ( Future . succeededFuture ( txts ) ) ; } } @ Override public void handle ( DatagramPacket packet ) { } } , DnsEntry . TYPE_TXT ) ; return this ; } @ Override public DnsClient resolvePTR ( String name , Handler < AsyncResult < String > > handler ) { lookup ( name , new HandlerAdapter < String > ( handler ) , DnsEntry . TYPE_PTR ) ; return this ; } @ Override public DnsClient resolveAAAA ( String name , Handler < AsyncResult < List < String > > > handler ) { lookup ( name , handler , DnsEntry . TYPE_AAAA ) ; return this ; } @ Override public DnsClient resolveSRV ( String name , Handler < AsyncResult < List < SrvRecord > > > handler ) { lookup ( name , new ConvertingHandler < ServiceRecord , SrvRecord > ( handler , SrvRecordComparator . INSTANCE ) { @ Override protected SrvRecord convert ( ServiceRecord entry ) { return new SrcRecordImpl ( entry ) ; } @ Override public void handle ( DatagramPacket packet ) { } } , DnsEntry . TYPE_SRV ) ; return this ; } @ Override public DnsClient reverseLookup ( String address , Handler < AsyncResult < String > > handler ) { return this ; } @ SuppressWarnings ( "unchecked" ) private void lookup ( String name , Handler handler , int ... types ) { Future result = Future . future ( ) ; result . setHandler ( handler ) ; lookup ( name , result , types ) ; } @ SuppressWarnings ( "unchecked" ) private void lookup ( String name , Future result , int ... types ) { Objects . requireNonNull ( name , "no null name accepted" ) ; bootstrap . connect ( dnsServer ) . addListener ( new RetryChannelFutureListener ( result ) { @ Override public void onSuccess ( ChannelFuture future ) throws Exception { DnsQuery query = new DnsQuery ( ThreadLocalRandom . current ( ) . nextInt ( ) ) ; for ( int type : types ) { query . addQuestion ( new DnsQuestion ( name , type ) ) ; } future . channel ( ) . writeAndFlush ( query ) . addListener ( new RetryChannelFutureListener ( result ) { @ Override public void onSuccess ( ChannelFuture future ) throws Exception { future . channel ( ) . pipeline ( ) . addLast ( new SimpleChannelInboundHandler < DnsResponse > ( ) { @ Override protected void channelRead0 ( ChannelHandlerContext ctx , DnsResponse msg ) throws Exception { DnsResponseCode code = DnsResponseCode . valueOf ( msg . getHeader ( ) . getResponseCode ( ) ) ; if ( code == DnsResponseCode . NOERROR ) { List < DnsResource > resources = msg . getAnswers ( ) ; List < Object > records = new ArrayList < > ( resources . size ( ) ) ; for ( DnsResource resource : msg . getAnswers ( ) ) { Object record = RecordDecoderFactory . getFactory ( ) . decode ( resource . type ( ) , msg , resource ) ; if ( record instanceof InetAddress ) { record = ( ( InetAddress ) record ) . getHostAddress ( ) ; } records . add ( record ) ; } setResult ( result , records ) ; } else { setResult ( result , new DnsException ( code ) ) ; } ctx . close ( ) ; } @ Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { setResult ( result , cause ) ; ctx . close ( ) ; } } ) ; } } ) ; } } ) ; } @ SuppressWarnings ( "unchecked" ) private void setResult ( Future r , Object result ) { if ( r . isComplete ( ) ) { return ; } actualCtx . executeFromIO ( ( ) - > { if ( result instanceof Throwable ) { r . fail ( ( Throwable ) result ) ; } else { r . complete ( result ) ; } } ) ; } private static class HandlerAdapter < T > implements Handler < AsyncResult < List < T > > > { private final Handler handler ; HandlerAdapter ( Handler handler ) { this . handler = handler ; } @ SuppressWarnings ( "unchecked" ) @ Override public void handle ( AsyncResult < List < T > > event ) { if ( event . failed ( ) ) { handler . handle ( event ) ; } else { List < T > result = event . result ( ) ; if ( result . isEmpty ( ) ) { handler . handle ( Future . succeededFuture ( ) ) ; } else { handler . handle ( Future . succeededFuture ( result . get ( 0 ) ) ) ; } } } } protected abstract class ConvertingHandler < F , T > implements Handler < AsyncResult < List < F > > > { private final Handler handler ; private final Comparator comparator ; ConvertingHandler ( Handler < AsyncResult < List < T > > > handler , Comparator comparator ) { this . handler = handler ; this . comparator = comparator ; } @ SuppressWarnings ( "unchecked" ) @ Override public void handle ( AsyncResult < List < F > > event ) { if ( event . failed ( ) ) { handler . handle ( event ) ; } else { List records = ( List ) event . result ( ) ; for ( int i = 0 ; i < records . size ( ) ; i ++ ) { F record = ( F ) records . get ( i ) ; records . set ( i , convert ( record ) ) ; } Collections . sort ( records , comparator ) ; handler . handle ( Future . succeededFuture ( records ) ) ; } } protected abstract T convert ( F entry ) ; } private abstract class RetryChannelFutureListener implements ChannelFutureListener { private final Future result ; RetryChannelFutureListener ( final Future result ) { this . result = result ; } @ Override public final void operationComplete ( ChannelFuture future ) throws Exception { if ( ! future . isSuccess ( ) ) { result ( future ) ; } else { onSuccess ( future ) ; } } private void result ( ChannelFuture future ) { if ( ! result . isComplete ( ) ) { result . fail ( future . cause ( ) ) ; } } protected abstract void onSuccess ( ChannelFuture future ) throws Exception ; } }
package io . vertx . core . dns . impl . netty ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public abstract class DnsMessage < H extends DnsHeader > { private final List < DnsQuestion > questions = new ArrayList < > ( ) ; private final List < DnsResource > answers = new ArrayList < > ( ) ; private final List < DnsResource > authority = new ArrayList < > ( ) ; private final List < DnsResource > additional = new ArrayList < > ( ) ; private H header ; public H getHeader ( ) { return header ; } public List < DnsQuestion > getQuestions ( ) { return Collections . unmodifiableList ( questions ) ; } public List < DnsResource > getAnswers ( ) { return Collections . unmodifiableList ( answers ) ; } public List < DnsResource > getAuthorityResources ( ) { return Collections . unmodifiableList ( authority ) ; } public List < DnsResource > getAdditionalResources ( ) { return Collections . unmodifiableList ( additional ) ; } public DnsMessage < H > addAnswer ( DnsResource answer ) { answers . add ( answer ) ; return this ; } public DnsMessage < H > addQuestion ( DnsQuestion question ) { questions . add ( question ) ; return this ; } public DnsMessage < H > addAuthorityResource ( DnsResource resource ) { authority . add ( resource ) ; return this ; } public DnsMessage < H > addAdditionalResource ( DnsResource resource ) { additional . add ( resource ) ; return this ; } public DnsMessage < H > setHeader ( H header ) { this . header = header ; return this ; } }
package io . vertx . core . dns . impl . netty ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . socket . DatagramPacket ; import io . netty . handler . codec . MessageToMessageDecoder ; import io . netty . util . CharsetUtil ; import java . util . List ; public class DnsResponseDecoder extends MessageToMessageDecoder < DatagramPacket > { public static String readName ( ByteBuf buf ) { int position = - 1 ; StringBuilder name = new StringBuilder ( ) ; for ( int len = buf . readUnsignedByte ( ) ; buf . isReadable ( ) && len != 0 ; len = buf . readUnsignedByte ( ) ) { boolean pointer = ( len & 0xc0 ) == 0xc0 ; if ( pointer ) { if ( position == - 1 ) { position = buf . readerIndex ( ) + 1 ; } buf . readerIndex ( ( len & 0x3f ) < < 8 | buf . readUnsignedByte ( ) ) ; } else { name . append ( buf . toString ( buf . readerIndex ( ) , len , CharsetUtil . UTF_8 ) ) . append ( "." ) ; buf . skipBytes ( len ) ; } } if ( position != - 1 ) { buf . readerIndex ( position ) ; } if ( name . length ( ) == 0 ) { return null ; } return name . substring ( 0 , name . length ( ) - 1 ) ; } public static String getName ( ByteBuf buf , int offset ) { StringBuilder name = new StringBuilder ( ) ; for ( int len = buf . getUnsignedByte ( offset ++ ) ; buf . writerIndex ( ) > offset && len != 0 ; len = buf . getUnsignedByte ( offset ++ ) ) { boolean pointer = ( len & 0xc0 ) == 0xc0 ; if ( pointer ) { offset = ( len & 0x3f ) < < 8 | buf . getUnsignedByte ( offset ++ ) ; } else { name . append ( buf . toString ( offset , len , CharsetUtil . UTF_8 ) ) . append ( "." ) ; offset += len ; } } if ( name . length ( ) == 0 ) { return null ; } return name . substring ( 0 , name . length ( ) - 1 ) ; } private static DnsQuestion decodeQuestion ( ByteBuf buf ) { String name = readName ( buf ) ; int type = buf . readUnsignedShort ( ) ; int qClass = buf . readUnsignedShort ( ) ; return new DnsQuestion ( name , type , qClass ) ; } private static DnsResource decodeResource ( ByteBuf buf , ByteBufAllocator allocator ) { String name = readName ( buf ) ; int type = buf . readUnsignedShort ( ) ; int aClass = buf . readUnsignedShort ( ) ; long ttl = buf . readUnsignedInt ( ) ; int len = buf . readUnsignedShort ( ) ; ByteBuf resourceData = allocator . buffer ( len ) ; int contentIndex = buf . readerIndex ( ) ; resourceData . writeBytes ( buf , len ) ; return new DnsResource ( name , type , aClass , ttl , contentIndex , resourceData ) ; } private static DnsResponseHeader decodeHeader ( DnsResponse parent , ByteBuf buf ) { int id = buf . readUnsignedShort ( ) ; DnsResponseHeader header = new DnsResponseHeader ( parent , id ) ; int flags = buf . readUnsignedShort ( ) ; header . setType ( flags > > 15 ) ; header . setOpcode ( flags > > 11 & 0xf ) ; header . setRecursionDesired ( ( flags > > 8 & 1 ) == 1 ) ; header . setAuthoritativeAnswer ( ( flags > > 10 & 1 ) == 1 ) ; header . setTruncated ( ( flags > > 9 & 1 ) == 1 ) ; header . setRecursionAvailable ( ( flags > > 7 & 1 ) == 1 ) ; header . setZ ( flags > > 4 & 0x7 ) ; header . setResponseCode ( flags & 0xf ) ; header . setReadQuestions ( buf . readUnsignedShort ( ) ) ; header . setReadAnswers ( buf . readUnsignedShort ( ) ) ; header . setReadAuthorityResources ( buf . readUnsignedShort ( ) ) ; header . setReadAdditionalResources ( buf . readUnsignedShort ( ) ) ; return header ; } protected static DnsResponse decodeResponse ( ByteBuf buf , ByteBufAllocator allocator ) { DnsResponse response = new DnsResponse ( buf ) ; DnsResponseHeader header = decodeHeader ( response , buf ) ; response . setHeader ( header ) ; for ( int i = 0 ; i < header . getReadQuestions ( ) ; i ++ ) { response . addQuestion ( decodeQuestion ( buf ) ) ; } if ( header . getResponseCode ( ) != 0 ) { return response ; } for ( int i = 0 ; i < header . getReadAnswers ( ) ; i ++ ) { response . addAnswer ( decodeResource ( buf , allocator ) ) ; } for ( int i = 0 ; i < header . getReadAuthorityResources ( ) ; i ++ ) { response . addAuthorityResource ( decodeResource ( buf , allocator ) ) ; } for ( int i = 0 ; i < header . getReadAdditionalResources ( ) ; i ++ ) { response . addAdditionalResource ( decodeResource ( buf , allocator ) ) ; } return response ; } @ Override protected void decode ( ChannelHandlerContext ctx , DatagramPacket packet , List < Object > out ) throws Exception { out . add ( decodeResponse ( packet . content ( ) , ctx . alloc ( ) ) . retain ( ) ) ; } }
package io . vertx . core . dns . impl . netty ; public class DnsQuery extends DnsMessage < DnsQueryHeader > { public DnsQuery ( int id ) { setHeader ( new DnsQueryHeader ( this , id ) ) ; } }
package io . vertx . core . dns . impl . netty ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufHolder ; public class DnsResponse extends DnsMessage < DnsResponseHeader > implements ByteBufHolder { private final ByteBuf rawPacket ; private final int originalIndex ; public DnsResponse ( ByteBuf rawPacket ) { this . rawPacket = rawPacket ; this . originalIndex = rawPacket . readerIndex ( ) ; } @ Override public ByteBuf content ( ) { return rawPacket ; } @ Override public int refCnt ( ) { return rawPacket . refCnt ( ) ; } @ Override public boolean release ( ) { return rawPacket . release ( ) ; } @ Override public DnsResponse copy ( ) { return DnsResponseDecoder . decodeResponse ( rawPacket . copy ( ) , rawPacket . alloc ( ) ) ; } @ Override public ByteBufHolder duplicate ( ) { return DnsResponseDecoder . decodeResponse ( rawPacket . duplicate ( ) , rawPacket . alloc ( ) ) ; } @ Override public DnsResponse retain ( ) { rawPacket . retain ( ) ; return this ; } @ Override public DnsResponse retain ( int increment ) { rawPacket . retain ( increment ) ; return this ; } @ Override public boolean release ( int decrement ) { return rawPacket . release ( decrement ) ; } public int originalIndex ( ) { return originalIndex ; } }
package io . vertx . test . core ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . impl . Utils ; import io . vertx . core . json . DecodeException ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import org . junit . Before ; import org . junit . Test ; import java . math . BigDecimal ; import java . util . ArrayList ; import java . util . Base64 ; import java . util . Collections ; import java . util . Date ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; import static org . junit . Assert . * ; public class JsonArrayTest { private JsonArray jsonArray ; @ Before public void setUp ( ) { jsonArray = new JsonArray ( ) ; } @ Test public void testGetInteger ( ) { jsonArray . add ( 123 ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonArray . getInteger ( 0 ) ) ; try { jsonArray . getInteger ( - 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } try { jsonArray . getInteger ( 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } jsonArray . add ( 123l ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonArray . getInteger ( 1 ) ) ; jsonArray . add ( 123f ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonArray . getInteger ( 2 ) ) ; jsonArray . add ( 123d ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonArray . getInteger ( 3 ) ) ; jsonArray . add ( "foo" ) ; try { jsonArray . getInteger ( 4 ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonArray . addNull ( ) ; assertNull ( jsonArray . getInteger ( 5 ) ) ; } @ Test public void testGetLong ( ) { jsonArray . add ( 123l ) ; assertEquals ( Long . valueOf ( 123l ) , jsonArray . getLong ( 0 ) ) ; try { jsonArray . getLong ( - 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } try { jsonArray . getLong ( 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } jsonArray . add ( 123 ) ; assertEquals ( Long . valueOf ( 123l ) , jsonArray . getLong ( 1 ) ) ; jsonArray . add ( 123f ) ; assertEquals ( Long . valueOf ( 123l ) , jsonArray . getLong ( 2 ) ) ; jsonArray . add ( 123d ) ; assertEquals ( Long . valueOf ( 123l ) , jsonArray . getLong ( 3 ) ) ; jsonArray . add ( "foo" ) ; try { jsonArray . getLong ( 4 ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonArray . addNull ( ) ; assertNull ( jsonArray . getLong ( 5 ) ) ; } @ Test public void testGetFloat ( ) { jsonArray . add ( 123f ) ; assertEquals ( Float . valueOf ( 123f ) , jsonArray . getFloat ( 0 ) ) ; try { jsonArray . getFloat ( - 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } try { jsonArray . getFloat ( 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } jsonArray . add ( 123 ) ; assertEquals ( Float . valueOf ( 123f ) , jsonArray . getFloat ( 1 ) ) ; jsonArray . add ( 123 ) ; assertEquals ( Float . valueOf ( 123f ) , jsonArray . getFloat ( 2 ) ) ; jsonArray . add ( 123d ) ; assertEquals ( Float . valueOf ( 123f ) , jsonArray . getFloat ( 3 ) ) ; jsonArray . add ( "foo" ) ; try { jsonArray . getFloat ( 4 ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonArray . addNull ( ) ; assertNull ( jsonArray . getFloat ( 5 ) ) ; } @ Test public void testGetDouble ( ) { jsonArray . add ( 123d ) ; assertEquals ( Double . valueOf ( 123d ) , jsonArray . getDouble ( 0 ) ) ; try { jsonArray . getDouble ( - 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } try { jsonArray . getDouble ( 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } jsonArray . add ( 123 ) ; assertEquals ( Double . valueOf ( 123d ) , jsonArray . getDouble ( 1 ) ) ; jsonArray . add ( 123 ) ; assertEquals ( Double . valueOf ( 123d ) , jsonArray . getDouble ( 2 ) ) ; jsonArray . add ( 123d ) ; assertEquals ( Double . valueOf ( 123d ) , jsonArray . getDouble ( 3 ) ) ; jsonArray . add ( "foo" ) ; try { jsonArray . getDouble ( 4 ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonArray . addNull ( ) ; assertNull ( jsonArray . getDouble ( 5 ) ) ; } @ Test public void testGetString ( ) { jsonArray . add ( "foo" ) ; assertEquals ( "foo" , jsonArray . getString ( 0 ) ) ; try { jsonArray . getString ( - 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } try { jsonArray . getString ( 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } jsonArray . add ( 123 ) ; try { jsonArray . getString ( 1 ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonArray . addNull ( ) ; assertNull ( jsonArray . getString ( 2 ) ) ; } @ Test public void testGetBoolean ( ) { jsonArray . add ( true ) ; assertEquals ( true , jsonArray . getBoolean ( 0 ) ) ; jsonArray . add ( false ) ; assertEquals ( false , jsonArray . getBoolean ( 1 ) ) ; try { jsonArray . getBoolean ( - 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } try { jsonArray . getBoolean ( 2 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } jsonArray . add ( 123 ) ; try { jsonArray . getBoolean ( 2 ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonArray . addNull ( ) ; assertNull ( jsonArray . getBoolean ( 3 ) ) ; } @ Test public void testGetBinary ( ) { byte [ ] bytes = TestUtils . randomByteArray ( 10 ) ; jsonArray . add ( bytes ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , jsonArray . getBinary ( 0 ) ) ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , Base64 . getDecoder ( ) . decode ( jsonArray . getString ( 0 ) ) ) ) ; try { jsonArray . getBinary ( - 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } try { jsonArray . getBinary ( 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } jsonArray . add ( 123 ) ; try { jsonArray . getBinary ( 1 ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonArray . addNull ( ) ; assertNull ( jsonArray . getBinary ( 2 ) ) ; } @ Test public void testGetJsonObject ( ) { JsonObject obj = new JsonObject ( ) . put ( "foo" , "bar" ) ; jsonArray . add ( obj ) ; assertEquals ( obj , jsonArray . getJsonObject ( 0 ) ) ; try { jsonArray . getJsonObject ( - 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } try { jsonArray . getJsonObject ( 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } jsonArray . add ( 123 ) ; try { jsonArray . getJsonObject ( 1 ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonArray . addNull ( ) ; assertNull ( jsonArray . getJsonObject ( 2 ) ) ; } @ Test public void testGetJsonArray ( ) { JsonArray arr = new JsonArray ( ) . add ( "foo" ) ; jsonArray . add ( arr ) ; assertEquals ( arr , jsonArray . getJsonArray ( 0 ) ) ; try { jsonArray . getJsonArray ( - 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } try { jsonArray . getJsonArray ( 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } jsonArray . add ( 123 ) ; try { jsonArray . getJsonArray ( 1 ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonArray . addNull ( ) ; assertNull ( jsonArray . getJsonArray ( 2 ) ) ; } @ Test public void testGetValue ( ) { jsonArray . add ( 123 ) ; assertEquals ( 123 , jsonArray . getValue ( 0 ) ) ; jsonArray . add ( 123l ) ; assertEquals ( 123l , jsonArray . getValue ( 1 ) ) ; jsonArray . add ( 123f ) ; assertEquals ( 123f , jsonArray . getValue ( 2 ) ) ; jsonArray . add ( 123d ) ; assertEquals ( 123d , jsonArray . getValue ( 3 ) ) ; jsonArray . add ( false ) ; assertEquals ( false , jsonArray . getValue ( 4 ) ) ; jsonArray . add ( true ) ; assertEquals ( true , jsonArray . getValue ( 5 ) ) ; jsonArray . add ( "bar" ) ; assertEquals ( "bar" , jsonArray . getValue ( 6 ) ) ; JsonObject obj = new JsonObject ( ) . put ( "blah" , "wibble" ) ; jsonArray . add ( obj ) ; assertEquals ( obj , jsonArray . getValue ( 7 ) ) ; JsonArray arr = new JsonArray ( ) . add ( "blah" ) . add ( "wibble" ) ; jsonArray . add ( arr ) ; assertEquals ( arr , jsonArray . getValue ( 8 ) ) ; byte [ ] bytes = TestUtils . randomByteArray ( 100 ) ; jsonArray . add ( bytes ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , Base64 . getDecoder ( ) . decode ( ( String ) jsonArray . getValue ( 9 ) ) ) ) ; jsonArray . addNull ( ) ; assertNull ( jsonArray . getValue ( 10 ) ) ; try { jsonArray . getValue ( - 1 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } try { jsonArray . getValue ( 11 ) ; fail ( ) ; } catch ( IndexOutOfBoundsException e ) { } List < Object > list = new ArrayList < > ( ) ; Map < String , Object > innerMap = new HashMap < > ( ) ; innerMap . put ( "blah" , "wibble" ) ; list . add ( innerMap ) ; jsonArray = new JsonArray ( list ) ; obj = ( JsonObject ) jsonArray . getValue ( 0 ) ; assertEquals ( "wibble" , obj . getString ( "blah" ) ) ; list = new ArrayList < > ( ) ; List < Object > innerList = new ArrayList < > ( ) ; innerList . add ( "blah" ) ; list . add ( innerList ) ; jsonArray = new JsonArray ( list ) ; arr = ( JsonArray ) jsonArray . getValue ( 0 ) ; assertEquals ( "blah" , arr . getString ( 0 ) ) ; } enum SomeEnum { FOO , BAR } @ Test public void testAddEnum ( ) { assertSame ( jsonArray , jsonArray . add ( JsonObjectTest . SomeEnum . FOO ) ) ; assertEquals ( JsonObjectTest . SomeEnum . FOO . toString ( ) , jsonArray . getString ( 0 ) ) ; try { jsonArray . add ( ( JsonObjectTest . SomeEnum ) null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testAddString ( ) { assertSame ( jsonArray , jsonArray . add ( "foo" ) ) ; assertEquals ( "foo" , jsonArray . getString ( 0 ) ) ; try { jsonArray . add ( ( String ) null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testAddCharSequence ( ) { assertSame ( jsonArray , jsonArray . add ( new StringBuilder ( "bar" ) ) ) ; assertEquals ( "bar" , jsonArray . getString ( 0 ) ) ; try { jsonArray . add ( ( CharSequence ) null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testAddInteger ( ) { assertSame ( jsonArray , jsonArray . add ( 123 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonArray . getInteger ( 0 ) ) ; try { jsonArray . add ( ( Integer ) null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testAddLong ( ) { assertSame ( jsonArray , jsonArray . add ( 123l ) ) ; assertEquals ( Long . valueOf ( 123l ) , jsonArray . getLong ( 0 ) ) ; try { jsonArray . add ( ( Long ) null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testAddFloat ( ) { assertSame ( jsonArray , jsonArray . add ( 123f ) ) ; assertEquals ( Float . valueOf ( 123f ) , jsonArray . getFloat ( 0 ) ) ; try { jsonArray . add ( ( Float ) null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testAddDouble ( ) { assertSame ( jsonArray , jsonArray . add ( 123d ) ) ; assertEquals ( Double . valueOf ( 123d ) , jsonArray . getDouble ( 0 ) ) ; try { jsonArray . add ( ( Double ) null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testAddBoolean ( ) { assertSame ( jsonArray , jsonArray . add ( true ) ) ; assertEquals ( true , jsonArray . getBoolean ( 0 ) ) ; jsonArray . add ( false ) ; assertEquals ( false , jsonArray . getBoolean ( 1 ) ) ; try { jsonArray . add ( ( Boolean ) null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testAddJsonObject ( ) { JsonObject obj = new JsonObject ( ) . put ( "foo" , "bar" ) ; assertSame ( jsonArray , jsonArray . add ( obj ) ) ; assertEquals ( obj , jsonArray . getJsonObject ( 0 ) ) ; try { jsonArray . add ( ( JsonObject ) null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testAddJsonArray ( ) { JsonArray arr = new JsonArray ( ) . add ( "foo" ) ; assertSame ( jsonArray , jsonArray . add ( arr ) ) ; assertEquals ( arr , jsonArray . getJsonArray ( 0 ) ) ; try { jsonArray . add ( ( JsonArray ) null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testAddBinary ( ) { byte [ ] bytes = TestUtils . randomByteArray ( 10 ) ; assertSame ( jsonArray , jsonArray . add ( bytes ) ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , jsonArray . getBinary ( 0 ) ) ) ; try { jsonArray . add ( ( byte [ ] ) null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testAddObject ( ) { jsonArray . add ( ( Object ) "bar" ) ; jsonArray . add ( ( Object ) ( Integer . valueOf ( 123 ) ) ) ; jsonArray . add ( ( Object ) ( Long . valueOf ( 123l ) ) ) ; jsonArray . add ( ( Object ) ( Float . valueOf ( 1.23f ) ) ) ; jsonArray . add ( ( Object ) ( Double . valueOf ( 1.23d ) ) ) ; jsonArray . add ( ( Object ) true ) ; byte [ ] bytes = TestUtils . randomByteArray ( 10 ) ; jsonArray . add ( ( Object ) ( bytes ) ) ; JsonObject obj = new JsonObject ( ) . put ( "foo" , "blah" ) ; JsonArray arr = new JsonArray ( ) . add ( "quux" ) ; jsonArray . add ( ( Object ) obj ) ; jsonArray . add ( ( Object ) arr ) ; assertEquals ( "bar" , jsonArray . getString ( 0 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonArray . getInteger ( 1 ) ) ; assertEquals ( Long . valueOf ( 123l ) , jsonArray . getLong ( 2 ) ) ; assertEquals ( Float . valueOf ( 1.23f ) , jsonArray . getFloat ( 3 ) ) ; assertEquals ( Double . valueOf ( 1.23d ) , jsonArray . getDouble ( 4 ) ) ; assertEquals ( true , jsonArray . getBoolean ( 5 ) ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , jsonArray . getBinary ( 6 ) ) ) ; assertEquals ( obj , jsonArray . getJsonObject ( 7 ) ) ; assertEquals ( arr , jsonArray . getJsonArray ( 8 ) ) ; try { jsonArray . add ( new SomeClass ( ) ) ; fail ( ) ; } catch ( IllegalStateException e ) { } try { jsonArray . add ( new BigDecimal ( 123 ) ) ; fail ( ) ; } catch ( IllegalStateException e ) { } try { jsonArray . add ( new Date ( ) ) ; fail ( ) ; } catch ( IllegalStateException e ) { } } @ Test public void testAddAllJsonArray ( ) { jsonArray . add ( "bar" ) ; JsonArray arr = new JsonArray ( ) . add ( "foo" ) . add ( 48 ) ; assertSame ( jsonArray , jsonArray . addAll ( arr ) ) ; assertEquals ( arr . getString ( 0 ) , jsonArray . getString ( 1 ) ) ; assertEquals ( arr . getInteger ( 1 ) , jsonArray . getInteger ( 2 ) ) ; try { jsonArray . add ( ( JsonArray ) null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testAddNull ( ) { assertSame ( jsonArray , jsonArray . addNull ( ) ) ; assertEquals ( null , jsonArray . getString ( 0 ) ) ; assertTrue ( jsonArray . hasNull ( 0 ) ) ; } @ Test public void testHasNull ( ) { jsonArray . addNull ( ) ; jsonArray . add ( "foo" ) ; assertEquals ( null , jsonArray . getString ( 0 ) ) ; assertTrue ( jsonArray . hasNull ( 0 ) ) ; assertFalse ( jsonArray . hasNull ( 1 ) ) ; } @ Test public void testContains ( ) { jsonArray . add ( "wibble" ) ; jsonArray . add ( true ) ; jsonArray . add ( 123 ) ; JsonObject obj = new JsonObject ( ) ; JsonArray arr = new JsonArray ( ) ; jsonArray . add ( obj ) ; jsonArray . add ( arr ) ; assertFalse ( jsonArray . contains ( "eek" ) ) ; assertFalse ( jsonArray . contains ( false ) ) ; assertFalse ( jsonArray . contains ( 321 ) ) ; assertFalse ( jsonArray . contains ( new JsonObject ( ) . put ( "blah" , "flib" ) ) ) ; assertFalse ( jsonArray . contains ( new JsonArray ( ) . add ( "oob" ) ) ) ; assertTrue ( jsonArray . contains ( "wibble" ) ) ; assertTrue ( jsonArray . contains ( true ) ) ; assertTrue ( jsonArray . contains ( 123 ) ) ; assertTrue ( jsonArray . contains ( obj ) ) ; assertTrue ( jsonArray . contains ( arr ) ) ; } @ Test public void testRemoveByObject ( ) { jsonArray . add ( "wibble" ) ; jsonArray . add ( true ) ; jsonArray . add ( 123 ) ; assertEquals ( 3 , jsonArray . size ( ) ) ; assertTrue ( jsonArray . remove ( "wibble" ) ) ; assertEquals ( 2 , jsonArray . size ( ) ) ; assertFalse ( jsonArray . remove ( "notthere" ) ) ; assertTrue ( jsonArray . remove ( true ) ) ; assertTrue ( jsonArray . remove ( Integer . valueOf ( 123 ) ) ) ; assertTrue ( jsonArray . isEmpty ( ) ) ; } @ Test public void testRemoveByPos ( ) { jsonArray . add ( "wibble" ) ; jsonArray . add ( true ) ; jsonArray . add ( 123 ) ; assertEquals ( 3 , jsonArray . size ( ) ) ; assertEquals ( "wibble" , jsonArray . remove ( 0 ) ) ; assertEquals ( 2 , jsonArray . size ( ) ) ; assertEquals ( 123 , jsonArray . remove ( 1 ) ) ; assertEquals ( 1 , jsonArray . size ( ) ) ; assertEquals ( true , jsonArray . remove ( 0 ) ) ; assertTrue ( jsonArray . isEmpty ( ) ) ; } @ Test public void testSize ( ) { jsonArray . add ( "wibble" ) ; jsonArray . add ( true ) ; jsonArray . add ( 123 ) ; assertEquals ( 3 , jsonArray . size ( ) ) ; } @ Test public void testClear ( ) { jsonArray . add ( "wibble" ) ; jsonArray . add ( true ) ; jsonArray . add ( 123 ) ; assertEquals ( 3 , jsonArray . size ( ) ) ; assertEquals ( jsonArray , jsonArray . clear ( ) ) ; assertEquals ( 0 , jsonArray . size ( ) ) ; assertTrue ( jsonArray . isEmpty ( ) ) ; } @ Test public void testIterator ( ) { jsonArray . add ( "foo" ) ; jsonArray . add ( 123 ) ; JsonObject obj = new JsonObject ( ) . put ( "foo" , "bar" ) ; jsonArray . add ( obj ) ; Iterator < Object > iter = jsonArray . iterator ( ) ; assertTrue ( iter . hasNext ( ) ) ; Object entry = iter . next ( ) ; assertEquals ( "foo" , entry ) ; assertTrue ( iter . hasNext ( ) ) ; entry = iter . next ( ) ; assertEquals ( 123 , entry ) ; assertTrue ( iter . hasNext ( ) ) ; entry = iter . next ( ) ; assertEquals ( obj , entry ) ; assertFalse ( iter . hasNext ( ) ) ; iter . remove ( ) ; assertFalse ( jsonArray . contains ( obj ) ) ; assertEquals ( 2 , jsonArray . size ( ) ) ; } @ Test public void testStream ( ) { jsonArray . add ( "foo" ) ; jsonArray . add ( 123 ) ; JsonObject obj = new JsonObject ( ) . put ( "foo" , "bar" ) ; jsonArray . add ( obj ) ; List < Object > list = jsonArray . stream ( ) . collect ( Collectors . toList ( ) ) ; Iterator < Object > iter = list . iterator ( ) ; assertTrue ( iter . hasNext ( ) ) ; Object entry = iter . next ( ) ; assertEquals ( "foo" , entry ) ; assertTrue ( iter . hasNext ( ) ) ; entry = iter . next ( ) ; assertEquals ( 123 , entry ) ; assertTrue ( iter . hasNext ( ) ) ; entry = iter . next ( ) ; assertEquals ( obj , entry ) ; assertFalse ( iter . hasNext ( ) ) ; } @ Test public void testCopy ( ) { jsonArray . add ( "foo" ) ; jsonArray . add ( 123 ) ; JsonObject obj = new JsonObject ( ) . put ( "foo" , "bar" ) ; jsonArray . add ( obj ) ; jsonArray . add ( new StringBuilder ( "eeek" ) ) ; JsonArray copy = jsonArray . copy ( ) ; assertEquals ( "eeek" , copy . getString ( 3 ) ) ; assertNotSame ( jsonArray , copy ) ; assertEquals ( jsonArray , copy ) ; assertEquals ( 4 , copy . size ( ) ) ; assertEquals ( "foo" , copy . getString ( 0 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , copy . getInteger ( 1 ) ) ; assertEquals ( obj , copy . getJsonObject ( 2 ) ) ; assertNotSame ( obj , copy . getJsonObject ( 2 ) ) ; copy . add ( "foo" ) ; assertEquals ( 4 , jsonArray . size ( ) ) ; jsonArray . add ( "bar" ) ; assertEquals ( 5 , copy . size ( ) ) ; } @ Test public void testInvalidValsOnCopy ( ) { List < Object > invalid = new ArrayList < > ( ) ; invalid . add ( new SomeClass ( ) ) ; JsonArray arr = new JsonArray ( invalid ) ; try { arr . copy ( ) ; fail ( ) ; } catch ( IllegalStateException e ) { } } @ Test public void testInvalidValsOnCopy2 ( ) { List < Object > invalid = new ArrayList < > ( ) ; List < Object > invalid2 = new ArrayList < > ( ) ; invalid2 . add ( new SomeClass ( ) ) ; invalid . add ( invalid2 ) ; JsonArray arr = new JsonArray ( invalid ) ; try { arr . copy ( ) ; fail ( ) ; } catch ( IllegalStateException e ) { } } @ Test public void testInvalidValsOnCopy3 ( ) { List < Object > invalid = new ArrayList < > ( ) ; Map < String , Object > invalid2 = new HashMap < > ( ) ; invalid2 . put ( "foo" , new SomeClass ( ) ) ; invalid . add ( invalid2 ) ; JsonArray arr = new JsonArray ( invalid ) ; try { arr . copy ( ) ; fail ( ) ; } catch ( IllegalStateException e ) { } } class SomeClass { } @ Test public void testEncode ( ) throws Exception { jsonArray . add ( "foo" ) ; jsonArray . add ( 123 ) ; jsonArray . add ( 1234l ) ; jsonArray . add ( 1.23f ) ; jsonArray . add ( 2.34d ) ; jsonArray . add ( true ) ; byte [ ] bytes = TestUtils . randomByteArray ( 10 ) ; jsonArray . add ( bytes ) ; jsonArray . addNull ( ) ; jsonArray . add ( new JsonObject ( ) . put ( "foo" , "bar" ) ) ; jsonArray . add ( new JsonArray ( ) . add ( "foo" ) . add ( 123 ) ) ; String strBytes = Base64 . getEncoder ( ) . encodeToString ( bytes ) ; String expected = "[\"foo\",123,1234,1.23,2.34,true,\"" + strBytes + "\",null,{\"foo\":\"bar\"},[\"foo\",123]]" ; String json = jsonArray . encode ( ) ; assertEquals ( expected , json ) ; } @ Test public void testDecode ( ) { byte [ ] bytes = TestUtils . randomByteArray ( 10 ) ; String strBytes = Base64 . getEncoder ( ) . encodeToString ( bytes ) ; String json = "[\"foo\",123,1234,1.23,2.34,true,\"" + strBytes + "\",null,{\"foo\":\"bar\"},[\"foo\",123]]" ; JsonArray arr = new JsonArray ( json ) ; assertEquals ( "foo" , arr . getString ( 0 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , arr . getInteger ( 1 ) ) ; assertEquals ( Long . valueOf ( 1234l ) , arr . getLong ( 2 ) ) ; assertEquals ( Float . valueOf ( 1.23f ) , arr . getFloat ( 3 ) ) ; assertEquals ( Double . valueOf ( 2.34d ) , arr . getDouble ( 4 ) ) ; assertEquals ( true , arr . getBoolean ( 5 ) ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , arr . getBinary ( 6 ) ) ) ; assertTrue ( arr . hasNull ( 7 ) ) ; JsonObject obj = arr . getJsonObject ( 8 ) ; assertEquals ( "bar" , obj . getString ( "foo" ) ) ; JsonArray arr2 = arr . getJsonArray ( 9 ) ; assertEquals ( "foo" , arr2 . getString ( 0 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , arr2 . getInteger ( 1 ) ) ; } @ Test public void testEncodePrettily ( ) throws Exception { jsonArray . add ( "foo" ) ; jsonArray . add ( 123 ) ; jsonArray . add ( 1234l ) ; jsonArray . add ( 1.23f ) ; jsonArray . add ( 2.34d ) ; jsonArray . add ( true ) ; byte [ ] bytes = TestUtils . randomByteArray ( 10 ) ; jsonArray . add ( bytes ) ; jsonArray . addNull ( ) ; jsonArray . add ( new JsonObject ( ) . put ( "foo" , "bar" ) ) ; jsonArray . add ( new JsonArray ( ) . add ( "foo" ) . add ( 123 ) ) ; String strBytes = Base64 . getEncoder ( ) . encodeToString ( bytes ) ; String expected = "[ \"foo\", 123, 1234, 1.23, 2.34, true, \"" + strBytes + "\", null, {" + Utils . LINE_SEPARATOR + " \"foo\" : \"bar\"" + Utils . LINE_SEPARATOR + "}, [ \"foo\", 123 ] ]" ; String json = jsonArray . encodePrettily ( ) ; assertEquals ( expected , json ) ; } @ Test public void testToString ( ) { jsonArray . add ( "foo" ) . add ( 123 ) ; assertEquals ( jsonArray . encode ( ) , jsonArray . toString ( ) ) ; } @ Test public void testCommentsInJson ( ) { String jsonWithComments = "// single line comment\n" + "/*\n" + " This is a multi \n" + " line comment\n" + "*/\n" + "[\n" + "// another single line comment this time inside the JSON array itself\n" + " \"foo\", \"bar\" // and a single line comment at end of line \n" + "/*\n" + " This is a another multi \n" + " line comment this time inside the JSON array itself\n" + "*/\n" + "]" ; JsonArray json = new JsonArray ( jsonWithComments ) ; assertEquals ( "[\"foo\",\"bar\"]" , json . encode ( ) ) ; } @ Test public void testInvalidJson ( ) { String invalid = "qiwjdoiqwjdiqwjd" ; try { new JsonArray ( invalid ) ; fail ( ) ; } catch ( DecodeException e ) { } } @ Test public void testGetList ( ) { JsonObject obj = new JsonObject ( ) . put ( "quux" , "wibble" ) ; jsonArray . add ( "foo" ) . add ( 123 ) . add ( obj ) ; List < Object > list = jsonArray . getList ( ) ; list . remove ( "foo" ) ; assertFalse ( jsonArray . contains ( "foo" ) ) ; list . add ( "floob" ) ; assertTrue ( jsonArray . contains ( "floob" ) ) ; assertSame ( obj , list . get ( 1 ) ) ; obj . remove ( "quux" ) ; } @ Test public void testCreateFromList ( ) { List < Object > list = new ArrayList < > ( ) ; list . add ( "foo" ) ; list . add ( 123 ) ; JsonArray arr = new JsonArray ( list ) ; assertEquals ( "foo" , arr . getString ( 0 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , arr . getInteger ( 1 ) ) ; assertSame ( list , arr . getList ( ) ) ; } @ Test public void testCreateFromListCharSequence ( ) { List < Object > list = new ArrayList < > ( ) ; list . add ( "foo" ) ; list . add ( 123 ) ; list . add ( new StringBuilder ( "eek" ) ) ; JsonArray arr = new JsonArray ( list ) ; assertEquals ( "foo" , arr . getString ( 0 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , arr . getInteger ( 1 ) ) ; assertEquals ( "eek" , arr . getString ( 2 ) ) ; assertSame ( list , arr . getList ( ) ) ; } @ Test public void testCreateFromListNestedJsonObject ( ) { List < Object > list = new ArrayList < > ( ) ; list . add ( "foo" ) ; list . add ( 123 ) ; JsonObject obj = new JsonObject ( ) . put ( "blah" , "wibble" ) ; list . add ( obj ) ; JsonArray arr = new JsonArray ( list ) ; assertEquals ( "foo" , arr . getString ( 0 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , arr . getInteger ( 1 ) ) ; assertSame ( list , arr . getList ( ) ) ; assertSame ( obj , arr . getJsonObject ( 2 ) ) ; } @ Test public void testCreateFromListNestedMap ( ) { List < Object > list = new ArrayList < > ( ) ; list . add ( "foo" ) ; list . add ( 123 ) ; Map < String , Object > map = new HashMap < > ( ) ; map . put ( "blah" , "wibble" ) ; list . add ( map ) ; JsonArray arr = new JsonArray ( list ) ; assertEquals ( "foo" , arr . getString ( 0 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , arr . getInteger ( 1 ) ) ; assertSame ( list , arr . getList ( ) ) ; JsonObject obj = arr . getJsonObject ( 2 ) ; assertSame ( map , obj . getMap ( ) ) ; } @ Test public void testCreateFromListNestedJsonArray ( ) { List < Object > list = new ArrayList < > ( ) ; list . add ( "foo" ) ; list . add ( 123 ) ; JsonArray arr2 = new JsonArray ( ) . add ( "blah" ) . add ( "wibble" ) ; list . add ( arr2 ) ; JsonArray arr = new JsonArray ( list ) ; assertEquals ( "foo" , arr . getString ( 0 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , arr . getInteger ( 1 ) ) ; assertSame ( list , arr . getList ( ) ) ; assertSame ( arr2 , arr . getJsonArray ( 2 ) ) ; } @ Test public void testCreateFromListNestedList ( ) { List < Object > list = new ArrayList < > ( ) ; list . add ( "foo" ) ; list . add ( 123 ) ; List < Object > list2 = new ArrayList < > ( ) ; list2 . add ( "blah" ) ; list2 . add ( "wibble" ) ; list . add ( list2 ) ; JsonArray arr = new JsonArray ( list ) ; assertEquals ( "foo" , arr . getString ( 0 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , arr . getInteger ( 1 ) ) ; assertSame ( list , arr . getList ( ) ) ; JsonArray arr2 = arr . getJsonArray ( 2 ) ; assertSame ( list2 , arr2 . getList ( ) ) ; } @ Test public void testClusterSerializable ( ) { jsonArray . add ( "foo" ) . add ( 123 ) ; Buffer buff = Buffer . buffer ( ) ; jsonArray . writeToBuffer ( buff ) ; JsonArray deserialized = new JsonArray ( ) ; deserialized . readFromBuffer ( 0 , buff ) ; assertEquals ( jsonArray , deserialized ) ; } @ Test public void testJsonArrayEquality ( ) { JsonObject obj = new JsonObject ( Collections . singletonMap ( "abc" , Collections . singletonList ( 3 ) ) ) ; assertEquals ( obj , new JsonObject ( Collections . singletonMap ( "abc" , Collections . singletonList ( 3 ) ) ) ) ; assertEquals ( obj , new JsonObject ( Collections . singletonMap ( "abc" , Collections . singletonList ( 3L ) ) ) ) ; assertEquals ( obj , new JsonObject ( Collections . singletonMap ( "abc" , new JsonArray ( ) . add ( 3 ) ) ) ) ; assertEquals ( obj , new JsonObject ( Collections . singletonMap ( "abc" , new JsonArray ( ) . add ( 3L ) ) ) ) ; assertNotEquals ( obj , new JsonObject ( Collections . singletonMap ( "abc" , Collections . singletonList ( 4 ) ) ) ) ; assertNotEquals ( obj , new JsonObject ( Collections . singletonMap ( "abc" , new JsonArray ( ) . add ( 4 ) ) ) ) ; JsonArray array = new JsonArray ( Collections . singletonList ( Collections . singletonList ( 3 ) ) ) ; assertEquals ( array , new JsonArray ( Collections . singletonList ( Collections . singletonList ( 3 ) ) ) ) ; assertEquals ( array , new JsonArray ( Collections . singletonList ( Collections . singletonList ( 3L ) ) ) ) ; assertEquals ( array , new JsonArray ( Collections . singletonList ( new JsonArray ( ) . add ( 3 ) ) ) ) ; assertEquals ( array , new JsonArray ( Collections . singletonList ( new JsonArray ( ) . add ( 3L ) ) ) ) ; assertNotEquals ( array , new JsonArray ( Collections . singletonList ( Collections . singletonList ( 4 ) ) ) ) ; assertNotEquals ( array , new JsonArray ( Collections . singletonList ( new JsonArray ( ) . add ( 4 ) ) ) ) ; } }
package io . vertx . core . dns . impl . netty ; public class DnsResponseHeader extends DnsHeader { private int readQuestions ; private int readAnswers ; private int readAuthorityResources ; private int readAdditionalResources ; private boolean authoritativeAnswer ; private boolean truncated ; private boolean recursionAvailable ; private int z ; private int responseCode ; public DnsResponseHeader ( DnsMessage < ? extends DnsResponseHeader > parent , int id ) { super ( parent ) ; setId ( id ) ; setType ( TYPE_RESPONSE ) ; } public boolean isAuthoritativeAnswer ( ) { return authoritativeAnswer ; } public boolean isTruncated ( ) { return truncated ; } public boolean isRecursionAvailable ( ) { return recursionAvailable ; } public int getZ ( ) { return z ; } public int getResponseCode ( ) { return responseCode ; } public int getReadQuestions ( ) { return readQuestions ; } public int getReadAnswers ( ) { return readAnswers ; } public int getReadAuthorityResources ( ) { return readAuthorityResources ; } public int getReadAdditionalResources ( ) { return readAdditionalResources ; } @ Override public final int getType ( ) { return TYPE_RESPONSE ; } public void setAuthoritativeAnswer ( boolean authoritativeAnswer ) { this . authoritativeAnswer = authoritativeAnswer ; } public void setTruncated ( boolean truncated ) { this . truncated = truncated ; } public void setRecursionAvailable ( boolean recursionAvailable ) { this . recursionAvailable = recursionAvailable ; } public void setZ ( int z ) { this . z = z ; } public void setResponseCode ( int responseCode ) { this . responseCode = responseCode ; } public void setReadQuestions ( int readQuestions ) { this . readQuestions = readQuestions ; } public void setReadAnswers ( int readAnswers ) { this . readAnswers = readAnswers ; } public void setReadAuthorityResources ( int readAuthorityResources ) { this . readAuthorityResources = readAuthorityResources ; } public void setReadAdditionalResources ( int readAdditionalResources ) { this . readAdditionalResources = readAdditionalResources ; } @ Override public final DnsResponseHeader setType ( int type ) { if ( type != TYPE_RESPONSE ) { throw new IllegalArgumentException ( "type cannot be anything but TYPE_RESPONSE (1) for a response header." ) ; } super . setType ( type ) ; return this ; } }
package io . vertx . core . dns . impl . netty ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufHolder ; public class DnsResource extends DnsEntry implements ByteBufHolder { private final int contentIndex ; private final long ttl ; private final ByteBuf content ; public DnsResource ( String name , int type , int aClass , long ttl , int contentIndex , ByteBuf content ) { super ( name , type , aClass ) ; this . ttl = ttl ; this . contentIndex = contentIndex ; this . content = content ; } public long timeToLive ( ) { return ttl ; } public int contentIndex ( ) { return contentIndex ; } public int contentLength ( ) { return content . writerIndex ( ) - content . readerIndex ( ) ; } @ Override public ByteBuf content ( ) { return content ; } @ Override public DnsResource copy ( ) { return new DnsResource ( name ( ) , type ( ) , dnsClass ( ) , ttl , contentIndex , content . copy ( ) ) ; } @ Override public ByteBufHolder duplicate ( ) { return new DnsResource ( name ( ) , type ( ) , dnsClass ( ) , ttl , contentIndex , content . duplicate ( ) ) ; } @ Override public int refCnt ( ) { return content . refCnt ( ) ; } @ Override public DnsResource retain ( ) { content . retain ( ) ; return this ; } @ Override public DnsResource retain ( int increment ) { content . retain ( increment ) ; return this ; } @ Override public boolean release ( ) { return content . release ( ) ; } @ Override public boolean release ( int decrement ) { return content . release ( decrement ) ; } }
package io . vertx . core . dns . impl . netty ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . MessageToByteEncoder ; import io . netty . util . CharsetUtil ; import java . nio . charset . Charset ; import java . util . List ; public class DnsQueryEncoder extends MessageToByteEncoder < DnsQuery > { private static void encodeHeader ( DnsQueryHeader header , ByteBuf buf ) { buf . writeShort ( header . getId ( ) ) ; int flags = flags ( header ) ; buf . writeShort ( flags ) ; buf . writeShort ( header . questionCount ( ) ) ; buf . writeShort ( header . answerCount ( ) ) ; buf . writeShort ( header . authorityResourceCount ( ) ) ; buf . writeShort ( header . additionalResourceCount ( ) ) ; } private static int flags ( DnsQueryHeader header ) { int flags = 0 ; flags |= header . getType ( ) < < 15 ; flags |= header . getOpcode ( ) < < 14 ; flags |= header . isRecursionDesired ( ) ? 1 < < 8 : 0 ; return flags ; } private static void encodeQuestion ( DnsQuestion question , Charset charset , ByteBuf buf ) { String [ ] parts = question . name ( ) . split ( "\\." ) ; for ( int i = 0 ; i < parts . length ; i ++ ) { buf . writeByte ( parts [ i ] . length ( ) ) ; buf . writeBytes ( charset . encode ( parts [ i ] ) ) ; } buf . writeByte ( 0 ) ; buf . writeShort ( question . type ( ) ) ; buf . writeShort ( question . dnsClass ( ) ) ; } protected static void encodeQuery ( DnsQuery query , ByteBuf buf ) { encodeHeader ( query . getHeader ( ) , buf ) ; List < DnsQuestion > questions = query . getQuestions ( ) ; for ( DnsQuestion question : questions ) { encodeQuestion ( question , CharsetUtil . UTF_8 , buf ) ; } } @ Override protected void encode ( ChannelHandlerContext ctx , DnsQuery query , ByteBuf out ) throws Exception { encodeQuery ( query , out ) ; } }
package io . vertx . core . dns . impl . netty ; public class DnsQueryHeader extends DnsHeader { public DnsQueryHeader ( DnsMessage < ? extends DnsQueryHeader > parent , int id ) { super ( parent ) ; setId ( id ) ; setType ( TYPE_QUERY ) ; setRecursionDesired ( true ) ; } @ Override public final int getType ( ) { return TYPE_QUERY ; } @ Override public final DnsQueryHeader setType ( int type ) { if ( type != TYPE_QUERY ) { throw new IllegalArgumentException ( "type cannot be anything but TYPE_QUERY (0) for a query header." ) ; } super . setType ( type ) ; return this ; } }
package io . vertx . core . dns . impl . netty ; public class DnsQuestion extends DnsEntry { public DnsQuestion ( String name , int type ) { this ( name , type , CLASS_IN ) ; } public DnsQuestion ( String name , int type , int qClass ) { super ( name , type , qClass ) ; } @ Override public boolean equals ( Object other ) { if ( other == this ) { return true ; } if ( other instanceof DnsQuestion ) { DnsQuestion question = ( DnsQuestion ) other ; return question . name ( ) . equals ( name ( ) ) && question . type ( ) == type ( ) && question . dnsClass ( ) == dnsClass ( ) ; } return false ; } @ Override public int hashCode ( ) { return ( ( name ( ) . hashCode ( ) + type ( ) ) * 7 + dnsClass ( ) ) * 7 ; } }
package io . vertx . core . dns . impl . netty ; import java . util . Objects ; public class DnsHeader { public static final int TYPE_QUERY = 0 ; public static final int TYPE_RESPONSE = 1 ; public static final int OPCODE_QUERY = 0 ; @ Deprecated public static final int OPCODE_IQUERY = 1 ; private final DnsMessage < ? extends DnsHeader > parent ; private boolean recursionDesired ; private int opcode ; private int id ; private int type ; public DnsHeader ( DnsMessage < ? extends DnsHeader > parent ) { Objects . requireNonNull ( parent , "the parent field cannot be null and must point to a valid DnsMessage." ) ; this . parent = parent ; } public int questionCount ( ) { return parent . getQuestions ( ) . size ( ) ; } public int answerCount ( ) { return parent . getAnswers ( ) . size ( ) ; } public int authorityResourceCount ( ) { return parent . getAuthorityResources ( ) . size ( ) ; } public int additionalResourceCount ( ) { return parent . getAdditionalResources ( ) . size ( ) ; } public boolean isRecursionDesired ( ) { return recursionDesired ; } public int getOpcode ( ) { return opcode ; } public int getType ( ) { return type ; } public int getId ( ) { return id ; } public DnsHeader setOpcode ( int opcode ) { this . opcode = opcode ; return this ; } public DnsHeader setRecursionDesired ( boolean recursionDesired ) { this . recursionDesired = recursionDesired ; return this ; } public DnsHeader setType ( int type ) { this . type = type ; return this ; } public DnsHeader setId ( int id ) { this . id = id ; return this ; } }
package io . vertx . core . dns . impl . netty ; public enum DnsResponseCode { NOERROR ( 0 , "no error" ) , FORMERROR ( 1 , "format error" ) , SERVFAIL ( 2 , "server failure" ) , NXDOMAIN ( 3 , "name error" ) , NOTIMPL ( 4 , "not implemented" ) , REFUSED ( 5 , "operation refused" ) , YXDOMAIN ( 6 , "domain name should not exist" ) , YXRRSET ( 7 , "resource record set should not exist" ) , NXRRSET ( 8 , "rrset does not exist" ) , NOTAUTH ( 9 , "not authoritative for zone" ) , NOTZONE ( 10 , "name not in zone" ) , BADVERS ( 11 , "bad extension mechanism for version" ) , BADSIG ( 12 , "bad signature" ) , BADKEY ( 13 , "bad key" ) , BADTIME ( 14 , "bad timestamp" ) ; private final int errorCode ; private final String message ; public static DnsResponseCode valueOf ( int responseCode ) { DnsResponseCode [ ] errors = DnsResponseCode . values ( ) ; for ( DnsResponseCode e : errors ) { if ( e . errorCode == responseCode ) { return e ; } } return null ; } private DnsResponseCode ( int errorCode , String message ) { this . errorCode = errorCode ; this . message = message ; } public int code ( ) { return errorCode ; } @ Override public String toString ( ) { return name ( ) + ": type " + errorCode + ", " + message ; } }
package io . vertx . core . dns . impl . netty ; public class DnsEntry { public static final int TYPE_A = 0x0001 ; public static final int TYPE_NS = 0x0002 ; public static final int TYPE_CNAME = 0x0005 ; public static final int TYPE_SOA = 0x0006 ; public static final int TYPE_PTR = 0x000c ; public static final int TYPE_MX = 0x000f ; public static final int TYPE_TXT = 0x0010 ; public static final int TYPE_RP = 0x0011 ; public static final int TYPE_AFSDB = 0x0012 ; public static final int TYPE_SIG = 0x0018 ; public static final int TYPE_KEY = 0x0019 ; public static final int TYPE_AAAA = 0x001c ; public static final int TYPE_LOC = 0x001d ; public static final int TYPE_SRV = 0x0021 ; public static final int TYPE_NAPTR = 0x0023 ; public static final int TYPE_KX = 0x0024 ; public static final int TYPE_CERT = 0x0025 ; public static final int TYPE_DNAME = 0x0027 ; public static final int TYPE_OPT = 0x0029 ; public static final int TYPE_APL = 0x002a ; public static final int TYPE_DS = 0x002b ; public static final int TYPE_SSHFP = 0x002c ; public static final int TYPE_IPSECKEY = 0x002d ; public static final int TYPE_RRSIG = 0x002e ; public static final int TYPE_NSEC = 0x002f ; public static final int TYPE_DNSKEY = 0x0030 ; public static final int TYPE_DHCID = 0x0031 ; public static final int TYPE_NSEC3 = 0x0032 ; public static final int TYPE_NSEC3PARAM = 0x0033 ; public static final int TYPE_TLSA = 0x0034 ; public static final int TYPE_HIP = 0x0037 ; public static final int TYPE_SPF = 0x0063 ; public static final int TYPE_TKEY = 0x00f9 ; public static final int TYPE_TSIG = 0x00fa ; public static final int TYPE_IXFR = 0x00fb ; public static final int TYPE_AXFR = 0x00fc ; public static final int TYPE_ANY = 0x00ff ; public static final int TYPE_CAA = 0x0101 ; public static final int TYPE_TA = 0x8000 ; public static final int TYPE_DLV = 0x8001 ; public static final int CLASS_IN = 0x0001 ; public static final int CLASS_CSNET = 0x0002 ; public static final int CLASS_CHAOS = 0x0003 ; public static final int CLASS_HESIOD = 0x0004 ; public static final int CLASS_NONE = 0x00fe ; public static final int CLASS_ANY = 0x00ff ; private final String name ; private final int type ; private final int dnsClass ; public DnsEntry ( String name , int type , int dnsClass ) { if ( name == null || name . length ( ) == 0 ) { throw new IllegalArgumentException ( "name must not be null or left blank." ) ; } if ( ( type & 0xffff ) != type ) { throw new IllegalArgumentException ( "type must be an unsigned short." ) ; } if ( dnsClass < 1 || dnsClass > 4 && dnsClass != CLASS_NONE && dnsClass != CLASS_ANY ) { throw new IllegalArgumentException ( "an invalid class has been supplied." ) ; } this . name = name ; this . type = type ; this . dnsClass = dnsClass ; } public String name ( ) { return name ; } public int type ( ) { return type ; } public int dnsClass ( ) { return dnsClass ; } @ Override public int hashCode ( ) { int hash = hash ( ) ; return hash * 31 + dnsClass ; } private int hash ( ) { int hash = 7 ; for ( int i = 0 ; i < name . length ( ) ; i ++ ) { hash = hash * 31 + name . charAt ( i ) ; } hash = hash * 31 + type ; return hash ; } @ Override public String toString ( ) { return new StringBuilder ( ) . append ( getClass ( ) . getSimpleName ( ) ) . append ( "(domain name: " ) . append ( name ) . append ( ", type: " ) . append ( type ) . append ( ", class: " ) . append ( dnsClass ) . append ( ')' ) . toString ( ) ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o instanceof DnsEntry ) { if ( o . hashCode ( ) != hashCode ( ) ) { return false ; } DnsEntry other = ( DnsEntry ) o ; return other . name ( ) . equals ( name ) && other . type ( ) == type && other . dnsClass ( ) == dnsClass ; } return false ; } }
package io . vertx . core . dns . impl . netty . decoder ; import io . netty . buffer . ByteBuf ; import io . vertx . core . dns . impl . netty . DnsResource ; import io . vertx . core . dns . impl . netty . DnsResponse ; import io . vertx . core . dns . impl . netty . DnsResponseDecoder ; import io . vertx . core . dns . impl . netty . decoder . record . ServiceRecord ; public class ServiceDecoder implements RecordDecoder < ServiceRecord > { @ Override public ServiceRecord decode ( DnsResponse response , DnsResource resource ) { ByteBuf packet = response . content ( ) . readerIndex ( resource . contentIndex ( ) ) ; int priority = packet . readShort ( ) ; int weight = packet . readShort ( ) ; int port = packet . readUnsignedShort ( ) ; String target = DnsResponseDecoder . readName ( packet ) ; return new ServiceRecord ( resource . name ( ) , priority , weight , port , target ) ; } }
package io . vertx . core . dns . impl . netty . decoder ;
package io . vertx . test . core ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . impl . Utils ; import io . vertx . core . json . DecodeException ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import org . junit . Before ; import org . junit . Test ; import java . math . BigDecimal ; import java . util . * ; import java . util . stream . Collectors ; import static org . junit . Assert . * ; public class JsonObjectTest { protected JsonObject jsonObject ; @ Before public void setUp ( ) throws Exception { jsonObject = new JsonObject ( ) ; } @ Test public void testGetInteger ( ) { jsonObject . put ( "foo" , 123 ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonObject . getInteger ( "foo" ) ) ; jsonObject . put ( "bar" , "hello" ) ; try { jsonObject . getInteger ( "bar" ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . put ( "foo" , 123L ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonObject . getInteger ( "foo" ) ) ; jsonObject . put ( "foo" , 123d ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonObject . getInteger ( "foo" ) ) ; jsonObject . put ( "foo" , 123f ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonObject . getInteger ( "foo" ) ) ; jsonObject . put ( "foo" , Long . MAX_VALUE ) ; assertEquals ( Integer . valueOf ( - 1 ) , jsonObject . getInteger ( "foo" ) ) ; jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getInteger ( "foo" ) ) ; assertNull ( jsonObject . getInteger ( "absent" ) ) ; try { jsonObject . getInteger ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetIntegerDefault ( ) { jsonObject . put ( "foo" , 123 ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonObject . getInteger ( "foo" , 321 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonObject . getInteger ( "foo" , null ) ) ; jsonObject . put ( "bar" , "hello" ) ; try { jsonObject . getInteger ( "bar" , 123 ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . put ( "foo" , 123l ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonObject . getInteger ( "foo" , 321 ) ) ; jsonObject . put ( "foo" , 123d ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonObject . getInteger ( "foo" , 321 ) ) ; jsonObject . put ( "foo" , 123f ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonObject . getInteger ( "foo" , 321 ) ) ; jsonObject . put ( "foo" , Long . MAX_VALUE ) ; assertEquals ( Integer . valueOf ( - 1 ) , jsonObject . getInteger ( "foo" , 321 ) ) ; jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getInteger ( "foo" , 321 ) ) ; assertEquals ( Integer . valueOf ( 321 ) , jsonObject . getInteger ( "absent" , 321 ) ) ; assertNull ( jsonObject . getInteger ( "foo" , null ) ) ; assertNull ( jsonObject . getInteger ( "absent" , null ) ) ; try { jsonObject . getInteger ( null , null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetLong ( ) { jsonObject . put ( "foo" , 123l ) ; assertEquals ( Long . valueOf ( 123l ) , jsonObject . getLong ( "foo" ) ) ; jsonObject . put ( "bar" , "hello" ) ; try { jsonObject . getLong ( "bar" ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . put ( "foo" , 123 ) ; assertEquals ( Long . valueOf ( 123l ) , jsonObject . getLong ( "foo" ) ) ; jsonObject . put ( "foo" , 123d ) ; assertEquals ( Long . valueOf ( 123l ) , jsonObject . getLong ( "foo" ) ) ; jsonObject . put ( "foo" , 123f ) ; assertEquals ( Long . valueOf ( 123l ) , jsonObject . getLong ( "foo" ) ) ; jsonObject . put ( "foo" , Long . MAX_VALUE ) ; assertEquals ( Long . valueOf ( Long . MAX_VALUE ) , jsonObject . getLong ( "foo" ) ) ; jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getLong ( "foo" ) ) ; assertNull ( jsonObject . getLong ( "absent" ) ) ; try { jsonObject . getLong ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetLongDefault ( ) { jsonObject . put ( "foo" , 123l ) ; assertEquals ( Long . valueOf ( 123l ) , jsonObject . getLong ( "foo" , 321l ) ) ; assertEquals ( Long . valueOf ( 123 ) , jsonObject . getLong ( "foo" , null ) ) ; jsonObject . put ( "bar" , "hello" ) ; try { jsonObject . getLong ( "bar" , 123l ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . put ( "foo" , 123 ) ; assertEquals ( Long . valueOf ( 123l ) , jsonObject . getLong ( "foo" , 321l ) ) ; jsonObject . put ( "foo" , 123d ) ; assertEquals ( Long . valueOf ( 123l ) , jsonObject . getLong ( "foo" , 321l ) ) ; jsonObject . put ( "foo" , 123f ) ; assertEquals ( Long . valueOf ( 123l ) , jsonObject . getLong ( "foo" , 321l ) ) ; jsonObject . put ( "foo" , Long . MAX_VALUE ) ; assertEquals ( Long . valueOf ( Long . MAX_VALUE ) , jsonObject . getLong ( "foo" , 321l ) ) ; jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getLong ( "foo" , 321l ) ) ; assertEquals ( Long . valueOf ( 321l ) , jsonObject . getLong ( "absent" , 321l ) ) ; assertNull ( jsonObject . getLong ( "foo" , null ) ) ; assertNull ( jsonObject . getLong ( "absent" , null ) ) ; try { jsonObject . getLong ( null , null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetFloat ( ) { jsonObject . put ( "foo" , 123f ) ; assertEquals ( Float . valueOf ( 123f ) , jsonObject . getFloat ( "foo" ) ) ; jsonObject . put ( "bar" , "hello" ) ; try { jsonObject . getFloat ( "bar" ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . put ( "foo" , 123 ) ; assertEquals ( Float . valueOf ( 123f ) , jsonObject . getFloat ( "foo" ) ) ; jsonObject . put ( "foo" , 123d ) ; assertEquals ( Float . valueOf ( 123f ) , jsonObject . getFloat ( "foo" ) ) ; jsonObject . put ( "foo" , 123f ) ; assertEquals ( Float . valueOf ( 123l ) , jsonObject . getFloat ( "foo" ) ) ; jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getFloat ( "foo" ) ) ; assertNull ( jsonObject . getFloat ( "absent" ) ) ; try { jsonObject . getFloat ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetFloatDefault ( ) { jsonObject . put ( "foo" , 123f ) ; assertEquals ( Float . valueOf ( 123f ) , jsonObject . getFloat ( "foo" , 321f ) ) ; assertEquals ( Float . valueOf ( 123 ) , jsonObject . getFloat ( "foo" , null ) ) ; jsonObject . put ( "bar" , "hello" ) ; try { jsonObject . getFloat ( "bar" , 123f ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . put ( "foo" , 123 ) ; assertEquals ( Float . valueOf ( 123f ) , jsonObject . getFloat ( "foo" , 321f ) ) ; jsonObject . put ( "foo" , 123d ) ; assertEquals ( Float . valueOf ( 123f ) , jsonObject . getFloat ( "foo" , 321f ) ) ; jsonObject . put ( "foo" , 123l ) ; assertEquals ( Float . valueOf ( 123f ) , jsonObject . getFloat ( "foo" , 321f ) ) ; jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getFloat ( "foo" , 321f ) ) ; assertEquals ( Float . valueOf ( 321f ) , jsonObject . getFloat ( "absent" , 321f ) ) ; assertNull ( jsonObject . getFloat ( "foo" , null ) ) ; assertNull ( jsonObject . getFloat ( "absent" , null ) ) ; try { jsonObject . getFloat ( null , null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetDouble ( ) { jsonObject . put ( "foo" , 123d ) ; assertEquals ( Double . valueOf ( 123d ) , jsonObject . getDouble ( "foo" ) ) ; jsonObject . put ( "bar" , "hello" ) ; try { jsonObject . getDouble ( "bar" ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . put ( "foo" , 123 ) ; assertEquals ( Double . valueOf ( 123d ) , jsonObject . getDouble ( "foo" ) ) ; jsonObject . put ( "foo" , 123l ) ; assertEquals ( Double . valueOf ( 123d ) , jsonObject . getDouble ( "foo" ) ) ; jsonObject . put ( "foo" , 123f ) ; assertEquals ( Double . valueOf ( 123d ) , jsonObject . getDouble ( "foo" ) ) ; jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getDouble ( "foo" ) ) ; assertNull ( jsonObject . getDouble ( "absent" ) ) ; try { jsonObject . getDouble ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetDoubleDefault ( ) { jsonObject . put ( "foo" , 123d ) ; assertEquals ( Double . valueOf ( 123d ) , jsonObject . getDouble ( "foo" , 321d ) ) ; assertEquals ( Double . valueOf ( 123 ) , jsonObject . getDouble ( "foo" , null ) ) ; jsonObject . put ( "bar" , "hello" ) ; try { jsonObject . getDouble ( "bar" , 123d ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . put ( "foo" , 123 ) ; assertEquals ( Double . valueOf ( 123d ) , jsonObject . getDouble ( "foo" , 321d ) ) ; jsonObject . put ( "foo" , 123f ) ; assertEquals ( Double . valueOf ( 123d ) , jsonObject . getDouble ( "foo" , 321d ) ) ; jsonObject . put ( "foo" , 123l ) ; assertEquals ( Double . valueOf ( 123d ) , jsonObject . getDouble ( "foo" , 321d ) ) ; jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getDouble ( "foo" , 321d ) ) ; assertEquals ( Double . valueOf ( 321d ) , jsonObject . getDouble ( "absent" , 321d ) ) ; assertNull ( jsonObject . getDouble ( "foo" , null ) ) ; assertNull ( jsonObject . getDouble ( "absent" , null ) ) ; try { jsonObject . getDouble ( null , null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetString ( ) { jsonObject . put ( "foo" , "bar" ) ; assertEquals ( "bar" , jsonObject . getString ( "foo" ) ) ; jsonObject . put ( "bar" , 123 ) ; try { jsonObject . getString ( "bar" ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getString ( "foo" ) ) ; assertNull ( jsonObject . getString ( "absent" ) ) ; try { jsonObject . getString ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetStringDefault ( ) { jsonObject . put ( "foo" , "bar" ) ; assertEquals ( "bar" , jsonObject . getString ( "foo" , "wibble" ) ) ; assertEquals ( "bar" , jsonObject . getString ( "foo" , null ) ) ; jsonObject . put ( "bar" , 123 ) ; try { jsonObject . getString ( "bar" , "wibble" ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getString ( "foo" , "wibble" ) ) ; assertEquals ( "wibble" , jsonObject . getString ( "absent" , "wibble" ) ) ; assertNull ( jsonObject . getString ( "foo" , null ) ) ; assertNull ( jsonObject . getString ( "absent" , null ) ) ; try { jsonObject . getString ( null , null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetBoolean ( ) { jsonObject . put ( "foo" , true ) ; assertEquals ( true , jsonObject . getBoolean ( "foo" ) ) ; jsonObject . put ( "foo" , false ) ; assertEquals ( false , jsonObject . getBoolean ( "foo" ) ) ; jsonObject . put ( "bar" , 123 ) ; try { jsonObject . getBoolean ( "bar" ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getBoolean ( "foo" ) ) ; assertNull ( jsonObject . getBoolean ( "absent" ) ) ; try { jsonObject . getBoolean ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetBooleanDefault ( ) { jsonObject . put ( "foo" , true ) ; assertEquals ( true , jsonObject . getBoolean ( "foo" , false ) ) ; assertEquals ( true , jsonObject . getBoolean ( "foo" , null ) ) ; jsonObject . put ( "foo" , false ) ; assertEquals ( false , jsonObject . getBoolean ( "foo" , true ) ) ; assertEquals ( false , jsonObject . getBoolean ( "foo" , null ) ) ; jsonObject . put ( "bar" , 123 ) ; try { jsonObject . getBoolean ( "bar" , true ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getBoolean ( "foo" , true ) ) ; assertNull ( jsonObject . getBoolean ( "foo" , false ) ) ; assertEquals ( true , jsonObject . getBoolean ( "absent" , true ) ) ; assertEquals ( false , jsonObject . getBoolean ( "absent" , false ) ) ; try { jsonObject . getBoolean ( null , null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetBinary ( ) { byte [ ] bytes = TestUtils . randomByteArray ( 100 ) ; jsonObject . put ( "foo" , bytes ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , jsonObject . getBinary ( "foo" ) ) ) ; String val = jsonObject . getString ( "foo" ) ; assertNotNull ( val ) ; byte [ ] retrieved = Base64 . getDecoder ( ) . decode ( val ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , retrieved ) ) ; jsonObject . put ( "foo" , 123 ) ; try { jsonObject . getBinary ( "foo" ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getBinary ( "foo" ) ) ; assertNull ( jsonObject . getBinary ( "absent" ) ) ; try { jsonObject . getBinary ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { } try { jsonObject . getBinary ( null , null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetBinaryDefault ( ) { byte [ ] bytes = TestUtils . randomByteArray ( 100 ) ; byte [ ] defBytes = TestUtils . randomByteArray ( 100 ) ; jsonObject . put ( "foo" , bytes ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , jsonObject . getBinary ( "foo" , defBytes ) ) ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , jsonObject . getBinary ( "foo" , null ) ) ) ; jsonObject . put ( "foo" , 123 ) ; try { jsonObject . getBinary ( "foo" , defBytes ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getBinary ( "foo" , defBytes ) ) ; assertTrue ( TestUtils . byteArraysEqual ( defBytes , jsonObject . getBinary ( "absent" , defBytes ) ) ) ; assertNull ( jsonObject . getBinary ( "foo" , null ) ) ; assertNull ( jsonObject . getBinary ( "absent" , null ) ) ; try { jsonObject . getBinary ( null , null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetJsonObject ( ) { JsonObject obj = new JsonObject ( ) . put ( "blah" , "wibble" ) ; jsonObject . put ( "foo" , obj ) ; assertEquals ( obj , jsonObject . getJsonObject ( "foo" ) ) ; jsonObject . put ( "foo" , "hello" ) ; try { jsonObject . getJsonObject ( "foo" ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getJsonObject ( "foo" ) ) ; assertNull ( jsonObject . getJsonObject ( "absent" ) ) ; try { jsonObject . getJsonObject ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetJsonObjectDefault ( ) { JsonObject obj = new JsonObject ( ) . put ( "blah" , "wibble" ) ; JsonObject def = new JsonObject ( ) . put ( "eek" , "quuz" ) ; jsonObject . put ( "foo" , obj ) ; assertEquals ( obj , jsonObject . getJsonObject ( "foo" , def ) ) ; assertEquals ( obj , jsonObject . getJsonObject ( "foo" , null ) ) ; jsonObject . put ( "foo" , "hello" ) ; try { jsonObject . getJsonObject ( "foo" , def ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getJsonObject ( "foo" , def ) ) ; assertEquals ( def , jsonObject . getJsonObject ( "absent" , def ) ) ; assertNull ( jsonObject . getJsonObject ( "foo" , null ) ) ; assertNull ( jsonObject . getJsonObject ( "absent" , null ) ) ; try { jsonObject . getJsonObject ( null , null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetJsonArray ( ) { JsonArray arr = new JsonArray ( ) . add ( "blah" ) . add ( "wibble" ) ; jsonObject . put ( "foo" , arr ) ; assertEquals ( arr , jsonObject . getJsonArray ( "foo" ) ) ; jsonObject . put ( "foo" , "hello" ) ; try { jsonObject . getJsonArray ( "foo" ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getJsonArray ( "foo" ) ) ; assertNull ( jsonObject . getJsonArray ( "absent" ) ) ; try { jsonObject . getJsonArray ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetJsonArrayDefault ( ) { JsonArray arr = new JsonArray ( ) . add ( "blah" ) . add ( "wibble" ) ; JsonArray def = new JsonArray ( ) . add ( "quux" ) . add ( "eek" ) ; jsonObject . put ( "foo" , arr ) ; assertEquals ( arr , jsonObject . getJsonArray ( "foo" , def ) ) ; assertEquals ( arr , jsonObject . getJsonArray ( "foo" , null ) ) ; jsonObject . put ( "foo" , "hello" ) ; try { jsonObject . getJsonArray ( "foo" , def ) ; fail ( ) ; } catch ( ClassCastException e ) { } jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getJsonArray ( "foo" , def ) ) ; assertEquals ( def , jsonObject . getJsonArray ( "absent" , def ) ) ; assertNull ( jsonObject . getJsonArray ( "foo" , null ) ) ; assertNull ( jsonObject . getJsonArray ( "absent" , null ) ) ; try { jsonObject . getJsonArray ( null , null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testGetValue ( ) { jsonObject . put ( "foo" , 123 ) ; assertEquals ( 123 , jsonObject . getValue ( "foo" ) ) ; jsonObject . put ( "foo" , 123l ) ; assertEquals ( 123l , jsonObject . getValue ( "foo" ) ) ; jsonObject . put ( "foo" , 123f ) ; assertEquals ( 123f , jsonObject . getValue ( "foo" ) ) ; jsonObject . put ( "foo" , 123d ) ; assertEquals ( 123d , jsonObject . getValue ( "foo" ) ) ; jsonObject . put ( "foo" , false ) ; assertEquals ( false , jsonObject . getValue ( "foo" ) ) ; jsonObject . put ( "foo" , true ) ; assertEquals ( true , jsonObject . getValue ( "foo" ) ) ; jsonObject . put ( "foo" , "bar" ) ; assertEquals ( "bar" , jsonObject . getValue ( "foo" ) ) ; JsonObject obj = new JsonObject ( ) . put ( "blah" , "wibble" ) ; jsonObject . put ( "foo" , obj ) ; assertEquals ( obj , jsonObject . getValue ( "foo" ) ) ; JsonArray arr = new JsonArray ( ) . add ( "blah" ) . add ( "wibble" ) ; jsonObject . put ( "foo" , arr ) ; assertEquals ( arr , jsonObject . getValue ( "foo" ) ) ; byte [ ] bytes = TestUtils . randomByteArray ( 100 ) ; jsonObject . put ( "foo" , bytes ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , Base64 . getDecoder ( ) . decode ( ( String ) jsonObject . getValue ( "foo" ) ) ) ) ; jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getValue ( "foo" ) ) ; assertNull ( jsonObject . getValue ( "absent" ) ) ; Map < String , Object > map = new HashMap < > ( ) ; Map < String , Object > innerMap = new HashMap < > ( ) ; innerMap . put ( "blah" , "wibble" ) ; map . put ( "foo" , innerMap ) ; jsonObject = new JsonObject ( map ) ; obj = ( JsonObject ) jsonObject . getValue ( "foo" ) ; assertEquals ( "wibble" , obj . getString ( "blah" ) ) ; map = new HashMap < > ( ) ; List < Object > innerList = new ArrayList < > ( ) ; innerList . add ( "blah" ) ; map . put ( "foo" , innerList ) ; jsonObject = new JsonObject ( map ) ; arr = ( JsonArray ) jsonObject . getValue ( "foo" ) ; assertEquals ( "blah" , arr . getString ( 0 ) ) ; } @ Test public void testGetValueDefault ( ) { jsonObject . put ( "foo" , 123 ) ; assertEquals ( 123 , jsonObject . getValue ( "foo" , "blah" ) ) ; assertEquals ( 123 , jsonObject . getValue ( "foo" , null ) ) ; jsonObject . put ( "foo" , 123l ) ; assertEquals ( 123l , jsonObject . getValue ( "foo" , "blah" ) ) ; assertEquals ( 123l , jsonObject . getValue ( "foo" , null ) ) ; jsonObject . put ( "foo" , 123f ) ; assertEquals ( 123f , jsonObject . getValue ( "foo" , "blah" ) ) ; assertEquals ( 123f , jsonObject . getValue ( "foo" , null ) ) ; jsonObject . put ( "foo" , 123d ) ; assertEquals ( 123d , jsonObject . getValue ( "foo" , "blah" ) ) ; assertEquals ( 123d , jsonObject . getValue ( "foo" , null ) ) ; jsonObject . put ( "foo" , false ) ; assertEquals ( false , jsonObject . getValue ( "foo" , "blah" ) ) ; assertEquals ( false , jsonObject . getValue ( "foo" , null ) ) ; jsonObject . put ( "foo" , true ) ; assertEquals ( true , jsonObject . getValue ( "foo" , "blah" ) ) ; assertEquals ( true , jsonObject . getValue ( "foo" , null ) ) ; jsonObject . put ( "foo" , "bar" ) ; assertEquals ( "bar" , jsonObject . getValue ( "foo" , "blah" ) ) ; assertEquals ( "bar" , jsonObject . getValue ( "foo" , null ) ) ; JsonObject obj = new JsonObject ( ) . put ( "blah" , "wibble" ) ; jsonObject . put ( "foo" , obj ) ; assertEquals ( obj , jsonObject . getValue ( "foo" , "blah" ) ) ; assertEquals ( obj , jsonObject . getValue ( "foo" , null ) ) ; JsonArray arr = new JsonArray ( ) . add ( "blah" ) . add ( "wibble" ) ; jsonObject . put ( "foo" , arr ) ; assertEquals ( arr , jsonObject . getValue ( "foo" , "blah" ) ) ; assertEquals ( arr , jsonObject . getValue ( "foo" , null ) ) ; byte [ ] bytes = TestUtils . randomByteArray ( 100 ) ; jsonObject . put ( "foo" , bytes ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , Base64 . getDecoder ( ) . decode ( ( String ) jsonObject . getValue ( "foo" , "blah" ) ) ) ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , Base64 . getDecoder ( ) . decode ( ( String ) jsonObject . getValue ( "foo" , null ) ) ) ) ; jsonObject . putNull ( "foo" ) ; assertNull ( jsonObject . getValue ( "foo" , "blah" ) ) ; assertNull ( jsonObject . getValue ( "foo" , null ) ) ; assertEquals ( "blah" , jsonObject . getValue ( "absent" , "blah" ) ) ; assertNull ( jsonObject . getValue ( "absent" , null ) ) ; } @ Test public void testContainsKey ( ) { jsonObject . put ( "foo" , "bar" ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; jsonObject . putNull ( "foo" ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; assertFalse ( jsonObject . containsKey ( "absent" ) ) ; } @ Test public void testFieldNames ( ) { jsonObject . put ( "foo" , "bar" ) ; jsonObject . put ( "eek" , 123 ) ; jsonObject . put ( "flib" , new JsonObject ( ) ) ; Set < String > fieldNames = jsonObject . fieldNames ( ) ; assertEquals ( 3 , fieldNames . size ( ) ) ; assertTrue ( fieldNames . contains ( "foo" ) ) ; assertTrue ( fieldNames . contains ( "eek" ) ) ; assertTrue ( fieldNames . contains ( "flib" ) ) ; jsonObject . remove ( "foo" ) ; assertEquals ( 2 , fieldNames . size ( ) ) ; assertFalse ( fieldNames . contains ( "foo" ) ) ; } @ Test public void testSize ( ) { assertEquals ( 0 , jsonObject . size ( ) ) ; jsonObject . put ( "foo" , "bar" ) ; assertEquals ( 1 , jsonObject . size ( ) ) ; jsonObject . put ( "bar" , 123 ) ; assertEquals ( 2 , jsonObject . size ( ) ) ; jsonObject . putNull ( "wibble" ) ; assertEquals ( 3 , jsonObject . size ( ) ) ; jsonObject . remove ( "wibble" ) ; assertEquals ( 2 , jsonObject . size ( ) ) ; jsonObject . clear ( ) ; assertEquals ( 0 , jsonObject . size ( ) ) ; } enum SomeEnum { FOO , BAR } @ Test public void testPutEnum ( ) { assertSame ( jsonObject , jsonObject . put ( "foo" , SomeEnum . FOO ) ) ; assertEquals ( SomeEnum . FOO . toString ( ) , jsonObject . getString ( "foo" ) ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; try { jsonObject . put ( null , SomeEnum . FOO ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testPutString ( ) { assertSame ( jsonObject , jsonObject . put ( "foo" , "bar" ) ) ; assertEquals ( "bar" , jsonObject . getString ( "foo" ) ) ; jsonObject . put ( "quux" , "wibble" ) ; assertEquals ( "wibble" , jsonObject . getString ( "quux" ) ) ; assertEquals ( "bar" , jsonObject . getString ( "foo" ) ) ; jsonObject . put ( "foo" , "blah" ) ; assertEquals ( "blah" , jsonObject . getString ( "foo" ) ) ; jsonObject . put ( "foo" , ( String ) null ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; try { jsonObject . put ( null , "blah" ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testPutCharSequence ( ) { assertSame ( jsonObject , jsonObject . put ( "foo" , new StringBuilder ( "bar" ) ) ) ; assertEquals ( "bar" , jsonObject . getString ( "foo" ) ) ; assertEquals ( "bar" , jsonObject . getString ( "foo" , "def" ) ) ; jsonObject . put ( "quux" , new StringBuilder ( "wibble" ) ) ; assertEquals ( "wibble" , jsonObject . getString ( "quux" ) ) ; assertEquals ( "bar" , jsonObject . getString ( "foo" ) ) ; jsonObject . put ( "foo" , new StringBuilder ( "blah" ) ) ; assertEquals ( "blah" , jsonObject . getString ( "foo" ) ) ; jsonObject . put ( "foo" , ( CharSequence ) null ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; try { jsonObject . put ( null , ( CharSequence ) "blah" ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testPutInteger ( ) { assertSame ( jsonObject , jsonObject . put ( "foo" , 123 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonObject . getInteger ( "foo" ) ) ; jsonObject . put ( "quux" , 321 ) ; assertEquals ( Integer . valueOf ( 321 ) , jsonObject . getInteger ( "quux" ) ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonObject . getInteger ( "foo" ) ) ; jsonObject . put ( "foo" , 456 ) ; assertEquals ( Integer . valueOf ( 456 ) , jsonObject . getInteger ( "foo" ) ) ; jsonObject . put ( "foo" , ( Integer ) null ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; try { jsonObject . put ( null , 123 ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testPutLong ( ) { assertSame ( jsonObject , jsonObject . put ( "foo" , 123l ) ) ; assertEquals ( Long . valueOf ( 123l ) , jsonObject . getLong ( "foo" ) ) ; jsonObject . put ( "quux" , 321l ) ; assertEquals ( Long . valueOf ( 321l ) , jsonObject . getLong ( "quux" ) ) ; assertEquals ( Long . valueOf ( 123l ) , jsonObject . getLong ( "foo" ) ) ; jsonObject . put ( "foo" , 456l ) ; assertEquals ( Long . valueOf ( 456l ) , jsonObject . getLong ( "foo" ) ) ; jsonObject . put ( "foo" , ( Long ) null ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; try { jsonObject . put ( null , 123l ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testPutFloat ( ) { assertSame ( jsonObject , jsonObject . put ( "foo" , 123f ) ) ; assertEquals ( Float . valueOf ( 123f ) , jsonObject . getFloat ( "foo" ) ) ; jsonObject . put ( "quux" , 321f ) ; assertEquals ( Float . valueOf ( 321f ) , jsonObject . getFloat ( "quux" ) ) ; assertEquals ( Float . valueOf ( 123f ) , jsonObject . getFloat ( "foo" ) ) ; jsonObject . put ( "foo" , 456f ) ; assertEquals ( Float . valueOf ( 456f ) , jsonObject . getFloat ( "foo" ) ) ; jsonObject . put ( "foo" , ( Float ) null ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; try { jsonObject . put ( null , 1.2f ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testPutDouble ( ) { assertSame ( jsonObject , jsonObject . put ( "foo" , 123d ) ) ; assertEquals ( Double . valueOf ( 123d ) , jsonObject . getDouble ( "foo" ) ) ; jsonObject . put ( "quux" , 321d ) ; assertEquals ( Double . valueOf ( 321d ) , jsonObject . getDouble ( "quux" ) ) ; assertEquals ( Double . valueOf ( 123d ) , jsonObject . getDouble ( "foo" ) ) ; jsonObject . put ( "foo" , 456d ) ; assertEquals ( Double . valueOf ( 456d ) , jsonObject . getDouble ( "foo" ) ) ; jsonObject . put ( "foo" , ( Double ) null ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; try { jsonObject . put ( null , 1.23d ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testPutBoolean ( ) { assertSame ( jsonObject , jsonObject . put ( "foo" , true ) ) ; assertEquals ( true , jsonObject . getBoolean ( "foo" ) ) ; jsonObject . put ( "quux" , true ) ; assertEquals ( true , jsonObject . getBoolean ( "quux" ) ) ; assertEquals ( true , jsonObject . getBoolean ( "foo" ) ) ; jsonObject . put ( "foo" , true ) ; assertEquals ( true , jsonObject . getBoolean ( "foo" ) ) ; jsonObject . put ( "foo" , ( Boolean ) null ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; try { jsonObject . put ( null , false ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testPutJsonObject ( ) { JsonObject obj1 = new JsonObject ( ) . put ( "blah" , "wibble" ) ; JsonObject obj2 = new JsonObject ( ) . put ( "eeek" , "flibb" ) ; JsonObject obj3 = new JsonObject ( ) . put ( "floob" , "plarp" ) ; assertSame ( jsonObject , jsonObject . put ( "foo" , obj1 ) ) ; assertEquals ( obj1 , jsonObject . getJsonObject ( "foo" ) ) ; jsonObject . put ( "quux" , obj2 ) ; assertEquals ( obj2 , jsonObject . getJsonObject ( "quux" ) ) ; assertEquals ( obj1 , jsonObject . getJsonObject ( "foo" ) ) ; jsonObject . put ( "foo" , obj3 ) ; assertEquals ( obj3 , jsonObject . getJsonObject ( "foo" ) ) ; jsonObject . put ( "foo" , ( JsonObject ) null ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; try { jsonObject . put ( null , new JsonObject ( ) ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testPutJsonArray ( ) { JsonArray obj1 = new JsonArray ( ) . add ( "parp" ) ; JsonArray obj2 = new JsonArray ( ) . add ( "fleep" ) ; JsonArray obj3 = new JsonArray ( ) . add ( "woob" ) ; assertSame ( jsonObject , jsonObject . put ( "foo" , obj1 ) ) ; assertEquals ( obj1 , jsonObject . getJsonArray ( "foo" ) ) ; jsonObject . put ( "quux" , obj2 ) ; assertEquals ( obj2 , jsonObject . getJsonArray ( "quux" ) ) ; assertEquals ( obj1 , jsonObject . getJsonArray ( "foo" ) ) ; jsonObject . put ( "foo" , obj3 ) ; assertEquals ( obj3 , jsonObject . getJsonArray ( "foo" ) ) ; jsonObject . put ( "foo" , ( JsonArray ) null ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; try { jsonObject . put ( null , new JsonArray ( ) ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testPutBinary ( ) { byte [ ] bin1 = TestUtils . randomByteArray ( 100 ) ; byte [ ] bin2 = TestUtils . randomByteArray ( 100 ) ; byte [ ] bin3 = TestUtils . randomByteArray ( 100 ) ; assertSame ( jsonObject , jsonObject . put ( "foo" , bin1 ) ) ; assertTrue ( TestUtils . byteArraysEqual ( bin1 , jsonObject . getBinary ( "foo" ) ) ) ; jsonObject . put ( "quux" , bin2 ) ; assertTrue ( TestUtils . byteArraysEqual ( bin2 , jsonObject . getBinary ( "quux" ) ) ) ; assertTrue ( TestUtils . byteArraysEqual ( bin1 , jsonObject . getBinary ( "foo" ) ) ) ; jsonObject . put ( "foo" , bin3 ) ; assertTrue ( TestUtils . byteArraysEqual ( bin3 , jsonObject . getBinary ( "foo" ) ) ) ; jsonObject . put ( "foo" , ( byte [ ] ) null ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; try { jsonObject . put ( null , bin1 ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testPutNull ( ) { assertSame ( jsonObject , jsonObject . putNull ( "foo" ) ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; assertSame ( jsonObject , jsonObject . putNull ( "bar" ) ) ; assertTrue ( jsonObject . containsKey ( "bar" ) ) ; try { jsonObject . putNull ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } @ Test public void testPutValue ( ) { jsonObject . put ( "str" , ( Object ) "bar" ) ; jsonObject . put ( "int" , ( Object ) ( Integer . valueOf ( 123 ) ) ) ; jsonObject . put ( "long" , ( Object ) ( Long . valueOf ( 123l ) ) ) ; jsonObject . put ( "float" , ( Object ) ( Float . valueOf ( 1.23f ) ) ) ; jsonObject . put ( "double" , ( Object ) ( Double . valueOf ( 1.23d ) ) ) ; jsonObject . put ( "boolean" , ( Object ) true ) ; byte [ ] bytes = TestUtils . randomByteArray ( 10 ) ; jsonObject . put ( "binary" , ( Object ) ( bytes ) ) ; JsonObject obj = new JsonObject ( ) . put ( "foo" , "blah" ) ; JsonArray arr = new JsonArray ( ) . add ( "quux" ) ; jsonObject . put ( "obj" , ( Object ) obj ) ; jsonObject . put ( "arr" , ( Object ) arr ) ; assertEquals ( "bar" , jsonObject . getString ( "str" ) ) ; assertEquals ( Integer . valueOf ( 123 ) , jsonObject . getInteger ( "int" ) ) ; assertEquals ( Long . valueOf ( 123l ) , jsonObject . getLong ( "long" ) ) ; assertEquals ( Float . valueOf ( 1.23f ) , jsonObject . getFloat ( "float" ) ) ; assertEquals ( Double . valueOf ( 1.23d ) , jsonObject . getDouble ( "double" ) ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , jsonObject . getBinary ( "binary" ) ) ) ; assertEquals ( obj , jsonObject . getJsonObject ( "obj" ) ) ; assertEquals ( arr , jsonObject . getJsonArray ( "arr" ) ) ; try { jsonObject . put ( "inv" , new SomeClass ( ) ) ; fail ( ) ; } catch ( IllegalStateException e ) { } try { jsonObject . put ( "inv" , new BigDecimal ( 123 ) ) ; fail ( ) ; } catch ( IllegalStateException e ) { } try { jsonObject . put ( "inv" , new Date ( ) ) ; fail ( ) ; } catch ( IllegalStateException e ) { } } @ Test public void testMergeIn1 ( ) { JsonObject obj1 = new JsonObject ( ) . put ( "foo" , "bar" ) ; JsonObject obj2 = new JsonObject ( ) . put ( "eek" , "flurb" ) ; obj1 . mergeIn ( obj2 ) ; assertEquals ( 2 , obj1 . size ( ) ) ; assertEquals ( "bar" , obj1 . getString ( "foo" ) ) ; assertEquals ( "flurb" , obj1 . getString ( "eek" ) ) ; assertEquals ( 1 , obj2 . size ( ) ) ; assertEquals ( "flurb" , obj2 . getString ( "eek" ) ) ; } @ Test public void testMergeIn2 ( ) { JsonObject obj1 = new JsonObject ( ) . put ( "foo" , "bar" ) ; JsonObject obj2 = new JsonObject ( ) . put ( "foo" , "flurb" ) ; obj1 . mergeIn ( obj2 ) ; assertEquals ( 1 , obj1 . size ( ) ) ; assertEquals ( "flurb" , obj1 . getString ( "foo" ) ) ; assertEquals ( 1 , obj2 . size ( ) ) ; assertEquals ( "flurb" , obj2 . getString ( "foo" ) ) ; } @ Test public void testEncode ( ) throws Exception { jsonObject . put ( "mystr" , "foo" ) ; jsonObject . put ( "mycharsequence" , new StringBuilder ( "oob" ) ) ; jsonObject . put ( "myint" , 123 ) ; jsonObject . put ( "mylong" , 1234l ) ; jsonObject . put ( "myfloat" , 1.23f ) ; jsonObject . put ( "mydouble" , 2.34d ) ; jsonObject . put ( "myboolean" , true ) ; byte [ ] bytes = TestUtils . randomByteArray ( 10 ) ; jsonObject . put ( "mybinary" , bytes ) ; jsonObject . putNull ( "mynull" ) ; jsonObject . put ( "myobj" , new JsonObject ( ) . put ( "foo" , "bar" ) ) ; jsonObject . put ( "myarr" , new JsonArray ( ) . add ( "foo" ) . add ( 123 ) ) ; String strBytes = Base64 . getEncoder ( ) . encodeToString ( bytes ) ; String expected = "{\"mystr\":\"foo\",\"mycharsequence\":\"oob\",\"myint\":123,\"mylong\":1234,\"myfloat\":1.23,\"mydouble\":2.34,\"" + "myboolean\":true,\"mybinary\":\"" + strBytes + "\",\"mynull\":null,\"myobj\":{\"foo\":\"bar\"},\"myarr\":[\"foo\",123]}" ; String json = jsonObject . encode ( ) ; assertEquals ( expected , json ) ; } @ Test public void testDecode ( ) throws Exception { byte [ ] bytes = TestUtils . randomByteArray ( 10 ) ; String strBytes = Base64 . getEncoder ( ) . encodeToString ( bytes ) ; String json = "{\"mystr\":\"foo\",\"myint\":123,\"mylong\":1234,\"myfloat\":1.23,\"mydouble\":2.34,\"" + "myboolean\":true,\"mybinary\":\"" + strBytes + "\",\"mynull\":null,\"myobj\":{\"foo\":\"bar\"},\"myarr\":[\"foo\",123]}" ; JsonObject obj = new JsonObject ( json ) ; assertEquals ( json , obj . encode ( ) ) ; assertEquals ( "foo" , obj . getString ( "mystr" ) ) ; assertEquals ( Integer . valueOf ( 123 ) , obj . getInteger ( "myint" ) ) ; assertEquals ( Long . valueOf ( 1234 ) , obj . getLong ( "mylong" ) ) ; assertEquals ( Float . valueOf ( 1.23f ) , obj . getFloat ( "myfloat" ) ) ; assertEquals ( Double . valueOf ( 2.34d ) , obj . getDouble ( "mydouble" ) ) ; assertTrue ( obj . getBoolean ( "myboolean" ) ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , obj . getBinary ( "mybinary" ) ) ) ; assertTrue ( obj . containsKey ( "mynull" ) ) ; JsonObject nestedObj = obj . getJsonObject ( "myobj" ) ; assertEquals ( "bar" , nestedObj . getString ( "foo" ) ) ; JsonArray nestedArr = obj . getJsonArray ( "myarr" ) ; assertEquals ( "foo" , nestedArr . getString ( 0 ) ) ; assertEquals ( Integer . valueOf ( 123 ) , Integer . valueOf ( nestedArr . getInteger ( 1 ) ) ) ; } @ Test public void testToString ( ) { jsonObject . put ( "foo" , "bar" ) ; assertEquals ( jsonObject . encode ( ) , jsonObject . toString ( ) ) ; } @ Test public void testEncodePrettily ( ) throws Exception { jsonObject . put ( "mystr" , "foo" ) ; jsonObject . put ( "myint" , 123 ) ; jsonObject . put ( "mylong" , 1234l ) ; jsonObject . put ( "myfloat" , 1.23f ) ; jsonObject . put ( "mydouble" , 2.34d ) ; jsonObject . put ( "myboolean" , true ) ; byte [ ] bytes = TestUtils . randomByteArray ( 10 ) ; jsonObject . put ( "mybinary" , bytes ) ; jsonObject . put ( "myobj" , new JsonObject ( ) . put ( "foo" , "bar" ) ) ; jsonObject . put ( "myarr" , new JsonArray ( ) . add ( "foo" ) . add ( 123 ) ) ; String strBytes = Base64 . getEncoder ( ) . encodeToString ( bytes ) ; String expected = "{" + Utils . LINE_SEPARATOR + " \"mystr\" : \"foo\"," + Utils . LINE_SEPARATOR + " \"myint\" : 123," + Utils . LINE_SEPARATOR + " \"mylong\" : 1234," + Utils . LINE_SEPARATOR + " \"myfloat\" : 1.23," + Utils . LINE_SEPARATOR + " \"mydouble\" : 2.34," + Utils . LINE_SEPARATOR + " \"myboolean\" : true," + Utils . LINE_SEPARATOR + " \"mybinary\" : \"" + strBytes + "\"," + Utils . LINE_SEPARATOR + " \"myobj\" : {" + Utils . LINE_SEPARATOR + " \"foo\" : \"bar\"" + Utils . LINE_SEPARATOR + " }," + Utils . LINE_SEPARATOR + " \"myarr\" : [ \"foo\", 123 ]" + Utils . LINE_SEPARATOR + "}" ; String json = jsonObject . encodePrettily ( ) ; assertEquals ( expected , json ) ; } @ Test public void testCommentsInJson ( ) { String jsonWithComments = "// single line comment\n" + "/*\n" + " This is a multi \n" + " line comment\n" + "*/\n" + "{\n" + "// another single line comment this time inside the JSON object itself\n" + " \"foo\": \"bar\" // and a single line comment at end of line \n" + "/*\n" + " This is a another multi \n" + " line comment this time inside the JSON object itself\n" + "*/\n" + "}" ; JsonObject json = new JsonObject ( jsonWithComments ) ; assertEquals ( "{\"foo\":\"bar\"}" , json . encode ( ) ) ; } @ Test public void testInvalidJson ( ) { String invalid = "qiwjdoiqwjdiqwjd" ; try { new JsonObject ( invalid ) ; fail ( ) ; } catch ( DecodeException e ) { } } @ Test public void testClear ( ) { jsonObject . put ( "foo" , "bar" ) ; jsonObject . put ( "quux" , 123 ) ; assertEquals ( 2 , jsonObject . size ( ) ) ; jsonObject . clear ( ) ; assertEquals ( 0 , jsonObject . size ( ) ) ; assertNull ( jsonObject . getValue ( "foo" ) ) ; assertNull ( jsonObject . getValue ( "quux" ) ) ; } @ Test public void testIsEmpty ( ) { assertTrue ( jsonObject . isEmpty ( ) ) ; jsonObject . put ( "foo" , "bar" ) ; jsonObject . put ( "quux" , 123 ) ; assertFalse ( jsonObject . isEmpty ( ) ) ; jsonObject . clear ( ) ; assertTrue ( jsonObject . isEmpty ( ) ) ; } @ Test public void testRemove ( ) { jsonObject . put ( "mystr" , "bar" ) ; jsonObject . put ( "myint" , 123 ) ; assertEquals ( "bar" , jsonObject . remove ( "mystr" ) ) ; assertNull ( jsonObject . getValue ( "mystr" ) ) ; assertEquals ( 123 , jsonObject . remove ( "myint" ) ) ; assertNull ( jsonObject . getValue ( "myint" ) ) ; assertTrue ( jsonObject . isEmpty ( ) ) ; } @ Test public void testIterator ( ) { jsonObject . put ( "foo" , "bar" ) ; jsonObject . put ( "quux" , 123 ) ; JsonObject obj = createJsonObject ( ) ; jsonObject . put ( "wibble" , obj ) ; Iterator < Map . Entry < String , Object > > iter = jsonObject . iterator ( ) ; assertTrue ( iter . hasNext ( ) ) ; Map . Entry < String , Object > entry = iter . next ( ) ; assertEquals ( "foo" , entry . getKey ( ) ) ; assertEquals ( "bar" , entry . getValue ( ) ) ; assertTrue ( iter . hasNext ( ) ) ; entry = iter . next ( ) ; assertEquals ( "quux" , entry . getKey ( ) ) ; assertEquals ( 123 , entry . getValue ( ) ) ; assertTrue ( iter . hasNext ( ) ) ; entry = iter . next ( ) ; assertEquals ( "wibble" , entry . getKey ( ) ) ; assertEquals ( obj , entry . getValue ( ) ) ; assertFalse ( iter . hasNext ( ) ) ; iter . remove ( ) ; assertFalse ( obj . containsKey ( "wibble" ) ) ; assertEquals ( 2 , jsonObject . size ( ) ) ; } @ Test public void testIteratorDoesntChangeObject ( ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "nestedMap" , new HashMap < > ( ) ) ; map . put ( "nestedList" , new ArrayList < > ( ) ) ; JsonObject obj = new JsonObject ( map ) ; Iterator < Map . Entry < String , Object > > iter = obj . iterator ( ) ; Map . Entry < String , Object > entry1 = iter . next ( ) ; assertEquals ( "nestedMap" , entry1 . getKey ( ) ) ; Object val1 = entry1 . getValue ( ) ; assertTrue ( val1 instanceof JsonObject ) ; Map . Entry < String , Object > entry2 = iter . next ( ) ; assertEquals ( "nestedList" , entry2 . getKey ( ) ) ; Object val2 = entry2 . getValue ( ) ; assertTrue ( val2 instanceof JsonArray ) ; assertTrue ( map . get ( "nestedMap" ) instanceof HashMap ) ; assertTrue ( map . get ( "nestedList" ) instanceof ArrayList ) ; } @ Test public void testStream ( ) { jsonObject . put ( "foo" , "bar" ) ; jsonObject . put ( "quux" , 123 ) ; JsonObject obj = createJsonObject ( ) ; jsonObject . put ( "wibble" , obj ) ; List < Map . Entry < String , Object > > list = jsonObject . stream ( ) . collect ( Collectors . toList ( ) ) ; Iterator < Map . Entry < String , Object > > iter = list . iterator ( ) ; assertTrue ( iter . hasNext ( ) ) ; Map . Entry < String , Object > entry = iter . next ( ) ; assertEquals ( "foo" , entry . getKey ( ) ) ; assertEquals ( "bar" , entry . getValue ( ) ) ; assertTrue ( iter . hasNext ( ) ) ; entry = iter . next ( ) ; assertEquals ( "quux" , entry . getKey ( ) ) ; assertEquals ( 123 , entry . getValue ( ) ) ; assertTrue ( iter . hasNext ( ) ) ; entry = iter . next ( ) ; assertEquals ( "wibble" , entry . getKey ( ) ) ; assertEquals ( obj , entry . getValue ( ) ) ; assertFalse ( iter . hasNext ( ) ) ; } @ Test public void testCopy ( ) { jsonObject . put ( "foo" , "bar" ) ; jsonObject . put ( "quux" , 123 ) ; JsonObject obj = createJsonObject ( ) ; jsonObject . put ( "wibble" , obj ) ; jsonObject . put ( "eek" , new StringBuilder ( "blah" ) ) ; JsonObject copy = jsonObject . copy ( ) ; assertNotSame ( jsonObject , copy ) ; assertEquals ( jsonObject , copy ) ; copy . put ( "blah" , "flib" ) ; assertFalse ( jsonObject . containsKey ( "blah" ) ) ; copy . remove ( "foo" ) ; assertFalse ( copy . containsKey ( "foo" ) ) ; assertTrue ( jsonObject . containsKey ( "foo" ) ) ; jsonObject . put ( "oob" , "flarb" ) ; assertFalse ( copy . containsKey ( "oob" ) ) ; jsonObject . remove ( "quux" ) ; assertFalse ( jsonObject . containsKey ( "quux" ) ) ; assertTrue ( copy . containsKey ( "quux" ) ) ; JsonObject nested = jsonObject . getJsonObject ( "wibble" ) ; JsonObject nestedCopied = copy . getJsonObject ( "wibble" ) ; assertNotSame ( nested , nestedCopied ) ; assertEquals ( nested , nestedCopied ) ; assertEquals ( "blah" , copy . getString ( "eek" ) ) ; } @ Test public void testInvalidValsOnCopy1 ( ) { Map < String , Object > invalid = new HashMap < > ( ) ; invalid . put ( "foo" , new SomeClass ( ) ) ; JsonObject object = new JsonObject ( invalid ) ; try { object . copy ( ) ; fail ( ) ; } catch ( IllegalStateException e ) { } } @ Test public void testInvalidValsOnCopy2 ( ) { Map < String , Object > invalid = new HashMap < > ( ) ; Map < String , Object > invalid2 = new HashMap < > ( ) ; invalid2 . put ( "foo" , new SomeClass ( ) ) ; invalid . put ( "bar" , invalid2 ) ; JsonObject object = new JsonObject ( invalid ) ; try { object . copy ( ) ; fail ( ) ; } catch ( IllegalStateException e ) { } } @ Test public void testInvalidValsOnCopy3 ( ) { Map < String , Object > invalid = new HashMap < > ( ) ; List < Object > invalid2 = new ArrayList < > ( ) ; invalid2 . add ( new SomeClass ( ) ) ; invalid . put ( "bar" , invalid2 ) ; JsonObject object = new JsonObject ( invalid ) ; try { object . copy ( ) ; fail ( ) ; } catch ( IllegalStateException e ) { } } class SomeClass { } @ Test public void testGetMap ( ) { jsonObject . put ( "foo" , "bar" ) ; jsonObject . put ( "quux" , 123 ) ; JsonObject obj = createJsonObject ( ) ; jsonObject . put ( "wibble" , obj ) ; Map < String , Object > map = jsonObject . getMap ( ) ; map . remove ( "foo" ) ; assertFalse ( jsonObject . containsKey ( "foo" ) ) ; map . put ( "bleep" , "flarp" ) ; assertTrue ( jsonObject . containsKey ( "bleep" ) ) ; jsonObject . remove ( "quux" ) ; assertFalse ( map . containsKey ( "quux" ) ) ; jsonObject . put ( "wooble" , "plink" ) ; assertTrue ( map . containsKey ( "wooble" ) ) ; assertSame ( obj , map . get ( "wibble" ) ) ; } @ Test public void testCreateFromMap ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( "foo" , "bar" ) ; map . put ( "quux" , 123 ) ; JsonObject obj = new JsonObject ( map ) ; assertEquals ( "bar" , obj . getString ( "foo" ) ) ; assertEquals ( Integer . valueOf ( 123 ) , obj . getInteger ( "quux" ) ) ; assertSame ( map , obj . getMap ( ) ) ; } @ Test public void testCreateFromMapCharSequence ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( "foo" , "bar" ) ; map . put ( "quux" , 123 ) ; map . put ( "eeek" , new StringBuilder ( "blah" ) ) ; JsonObject obj = new JsonObject ( map ) ; assertEquals ( "bar" , obj . getString ( "foo" ) ) ; assertEquals ( Integer . valueOf ( 123 ) , obj . getInteger ( "quux" ) ) ; assertEquals ( "blah" , obj . getString ( "eeek" ) ) ; assertSame ( map , obj . getMap ( ) ) ; } @ Test public void testCreateFromMapNestedJsonObject ( ) { Map < String , Object > map = new HashMap < > ( ) ; JsonObject nestedObj = new JsonObject ( ) . put ( "foo" , "bar" ) ; map . put ( "nested" , nestedObj ) ; JsonObject obj = new JsonObject ( map ) ; JsonObject nestedRetrieved = obj . getJsonObject ( "nested" ) ; assertEquals ( "bar" , nestedRetrieved . getString ( "foo" ) ) ; } @ Test public void testCreateFromMapNestedMap ( ) { Map < String , Object > map = new HashMap < > ( ) ; Map < String , Object > nestedMap = new HashMap < > ( ) ; nestedMap . put ( "foo" , "bar" ) ; map . put ( "nested" , nestedMap ) ; JsonObject obj = new JsonObject ( map ) ; JsonObject nestedRetrieved = obj . getJsonObject ( "nested" ) ; assertEquals ( "bar" , nestedRetrieved . getString ( "foo" ) ) ; } @ Test public void testCreateFromMapNestedJsonArray ( ) { Map < String , Object > map = new HashMap < > ( ) ; JsonArray nestedArr = new JsonArray ( ) . add ( "foo" ) ; map . put ( "nested" , nestedArr ) ; JsonObject obj = new JsonObject ( map ) ; JsonArray nestedRetrieved = obj . getJsonArray ( "nested" ) ; assertEquals ( "foo" , nestedRetrieved . getString ( 0 ) ) ; } @ Test public void testCreateFromMapNestedList ( ) { Map < String , Object > map = new HashMap < > ( ) ; List < String > nestedArr = Arrays . asList ( "foo" ) ; map . put ( "nested" , nestedArr ) ; JsonObject obj = new JsonObject ( map ) ; JsonArray nestedRetrieved = obj . getJsonArray ( "nested" ) ; assertEquals ( "foo" , nestedRetrieved . getString ( 0 ) ) ; } @ Test public void testClusterSerializable ( ) { jsonObject . put ( "foo" , "bar" ) . put ( "blah" , 123 ) ; Buffer buff = Buffer . buffer ( ) ; jsonObject . writeToBuffer ( buff ) ; JsonObject deserialized = new JsonObject ( ) ; deserialized . readFromBuffer ( 0 , buff ) ; assertEquals ( jsonObject , deserialized ) ; } @ Test public void testNumberEquality ( ) { assertNumberEquals ( 4 , 4 ) ; assertNumberEquals ( 4 , ( long ) 4 ) ; assertNumberEquals ( 4 , 4f ) ; assertNumberEquals ( 4 , 4D ) ; assertNumberEquals ( ( long ) 4 , ( long ) 4 ) ; assertNumberEquals ( ( long ) 4 , 4f ) ; assertNumberEquals ( ( long ) 4 , 4D ) ; assertNumberEquals ( 4f , 4f ) ; assertNumberEquals ( 4f , 4D ) ; assertNumberEquals ( 4D , 4D ) ; assertNumberEquals ( 4.1D , 4.1D ) ; assertNumberEquals ( 4.1f , 4.1f ) ; assertNumberNotEquals ( 4.1f , 4.1D ) ; assertNumberEquals ( 4.5D , 4.5D ) ; assertNumberEquals ( 4.5f , 4.5f ) ; assertNumberEquals ( 4.5f , 4.5D ) ; assertNumberNotEquals ( 4 , 5 ) ; assertNumberNotEquals ( 4 , ( long ) 5 ) ; assertNumberNotEquals ( 4 , 5D ) ; assertNumberNotEquals ( 4 , 5f ) ; assertNumberNotEquals ( ( long ) 4 , ( long ) 5 ) ; assertNumberNotEquals ( ( long ) 4 , 5D ) ; assertNumberNotEquals ( ( long ) 4 , 5f ) ; assertNumberNotEquals ( 4f , 5f ) ; assertNumberNotEquals ( 4f , 5D ) ; assertNumberNotEquals ( 4D , 5D ) ; } private void assertNumberEquals ( Number value1 , Number value2 ) { JsonObject o1 = new JsonObject ( ) . put ( "key" , value1 ) ; JsonObject o2 = new JsonObject ( ) . put ( "key" , value2 ) ; if ( ! o1 . equals ( o2 ) ) { fail ( "Was expecting " + value1 . getClass ( ) . getSimpleName ( ) + ":" + value1 + " == " + value2 . getClass ( ) . getSimpleName ( ) + ":" + value2 ) ; } JsonArray a1 = new JsonArray ( ) . add ( value1 ) ; JsonArray a2 = new JsonArray ( ) . add ( value2 ) ; if ( ! a1 . equals ( a2 ) ) { fail ( "Was expecting " + value1 . getClass ( ) . getSimpleName ( ) + ":" + value1 + " == " + value2 . getClass ( ) . getSimpleName ( ) + ":" + value2 ) ; } } private void assertNumberNotEquals ( Number value1 , Number value2 ) { JsonObject o1 = new JsonObject ( ) . put ( "key" , value1 ) ; JsonObject o2 = new JsonObject ( ) . put ( "key" , value2 ) ; if ( o1 . equals ( o2 ) ) { fail ( "Was expecting " + value1 . getClass ( ) . getSimpleName ( ) + ":" + value1 + " != " + value2 . getClass ( ) . getSimpleName ( ) + ":" + value2 ) ; } } @ Test public void testJsonObjectEquality ( ) { JsonObject obj = new JsonObject ( Collections . singletonMap ( "abc" , Collections . singletonMap ( "def" , 3 ) ) ) ; assertEquals ( obj , new JsonObject ( Collections . singletonMap ( "abc" , Collections . singletonMap ( "def" , 3 ) ) ) ) ; assertEquals ( obj , new JsonObject ( Collections . singletonMap ( "abc" , Collections . singletonMap ( "def" , 3L ) ) ) ) ; assertEquals ( obj , new JsonObject ( Collections . singletonMap ( "abc" , new JsonObject ( ) . put ( "def" , 3 ) ) ) ) ; assertEquals ( obj , new JsonObject ( Collections . singletonMap ( "abc" , new JsonObject ( ) . put ( "def" , 3L ) ) ) ) ; assertNotEquals ( obj , new JsonObject ( Collections . singletonMap ( "abc" , Collections . singletonMap ( "def" , 4 ) ) ) ) ; assertNotEquals ( obj , new JsonObject ( Collections . singletonMap ( "abc" , new JsonObject ( ) . put ( "def" , 4 ) ) ) ) ; JsonArray array = new JsonArray ( Collections . singletonList ( Collections . singletonMap ( "def" , 3 ) ) ) ; assertEquals ( array , new JsonArray ( Collections . singletonList ( Collections . singletonMap ( "def" , 3 ) ) ) ) ; assertEquals ( array , new JsonArray ( Collections . singletonList ( Collections . singletonMap ( "def" , 3L ) ) ) ) ; assertEquals ( array , new JsonArray ( Collections . singletonList ( new JsonObject ( ) . put ( "def" , 3 ) ) ) ) ; assertEquals ( array , new JsonArray ( Collections . singletonList ( new JsonObject ( ) . put ( "def" , 3L ) ) ) ) ; assertNotEquals ( array , new JsonArray ( Collections . singletonList ( Collections . singletonMap ( "def" , 4 ) ) ) ) ; assertNotEquals ( array , new JsonArray ( Collections . singletonList ( new JsonObject ( ) . put ( "def" , 4 ) ) ) ) ; } @ Test public void testJsonObjectEquality2 ( ) { JsonObject obj1 = new JsonObject ( ) . put ( "arr" , new JsonArray ( ) . add ( "x" ) ) ; List < Object > list = new ArrayList < > ( ) ; list . add ( "x" ) ; Map < String , Object > map = new HashMap < > ( ) ; map . put ( "arr" , list ) ; JsonObject obj2 = new JsonObject ( map ) ; Iterator < Map . Entry < String , Object > > iter = obj2 . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , Object > entry = iter . next ( ) ; } assertEquals ( obj2 , obj1 ) ; } private JsonObject createJsonObject ( ) { JsonObject obj = new JsonObject ( ) ; obj . put ( "mystr" , "bar" ) ; obj . put ( "myint" , Integer . MAX_VALUE ) ; obj . put ( "mylong" , Long . MAX_VALUE ) ; obj . put ( "myfloat" , Float . MAX_VALUE ) ; obj . put ( "mydouble" , Double . MAX_VALUE ) ; obj . put ( "myboolean" , true ) ; obj . put ( "mybinary" , TestUtils . randomByteArray ( 100 ) ) ; return obj ; } }
package io . vertx . core . dns . impl . netty . decoder ; import io . vertx . core . dns . impl . netty . DnsEntry ; import io . vertx . core . dns . impl . netty . DnsResource ; import io . vertx . core . dns . impl . netty . DnsResponse ; import java . util . HashMap ; import java . util . Map ; import java . util . Objects ; public final class RecordDecoderFactory { private static RecordDecoderFactory factory = new RecordDecoderFactory ( null ) ; public static RecordDecoderFactory getFactory ( ) { return factory ; } public static void setFactory ( RecordDecoderFactory factory ) { Objects . requireNonNull ( factory , "Cannot set record decoder factory to null." ) ; RecordDecoderFactory . factory = factory ; } private final Map < Integer , RecordDecoder < ? > > decoders = new HashMap < > ( ) ; public RecordDecoderFactory ( ) { this ( true , null ) ; } public RecordDecoderFactory ( Map < Integer , RecordDecoder < ? > > customDecoders ) { this ( true , customDecoders ) ; } public RecordDecoderFactory ( boolean useDefaultDecoders , Map < Integer , RecordDecoder < ? > > customDecoders ) { if ( ! useDefaultDecoders && ( customDecoders == null || customDecoders . isEmpty ( ) ) ) { throw new IllegalStateException ( "No decoders have been included to be used with this factory." ) ; } if ( useDefaultDecoders ) { decoders . put ( DnsEntry . TYPE_A , new AddressDecoder ( 4 ) ) ; decoders . put ( DnsEntry . TYPE_AAAA , new AddressDecoder ( 16 ) ) ; decoders . put ( DnsEntry . TYPE_MX , new MailExchangerDecoder ( ) ) ; decoders . put ( DnsEntry . TYPE_TXT , new TextDecoder ( ) ) ; decoders . put ( DnsEntry . TYPE_SRV , new ServiceDecoder ( ) ) ; RecordDecoder < ? > decoder = new DomainDecoder ( ) ; decoders . put ( DnsEntry . TYPE_NS , decoder ) ; decoders . put ( DnsEntry . TYPE_CNAME , decoder ) ; decoders . put ( DnsEntry . TYPE_PTR , decoder ) ; decoders . put ( DnsEntry . TYPE_SOA , new StartOfAuthorityDecoder ( ) ) ; } if ( customDecoders != null ) { decoders . putAll ( customDecoders ) ; } } @ SuppressWarnings ( "unchecked" ) public < T > T decode ( int type , DnsResponse response , DnsResource resource ) { RecordDecoder < ? > decoder = decoders . get ( type ) ; if ( decoder == null ) { throw new IllegalStateException ( "Unsupported resource record type [id: " + type + "]." ) ; } T result = null ; try { result = ( T ) decoder . decode ( response , resource ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return result ; } }
package io . vertx . core . dns . impl . netty . decoder ; import io . netty . handler . codec . DecoderException ; import io . vertx . core . dns . impl . netty . DnsResource ; import io . vertx . core . dns . impl . netty . DnsResponse ; public interface RecordDecoder < T > { T decode ( DnsResponse response , DnsResource resource ) throws DecoderException ; }
package io . vertx . core . dns . impl . netty . decoder ; import io . vertx . core . dns . impl . netty . DnsResource ; import io . vertx . core . dns . impl . netty . DnsResponse ; import io . vertx . core . dns . impl . netty . DnsResponseDecoder ; public class DomainDecoder implements RecordDecoder < String > { @ Override public String decode ( DnsResponse response , DnsResource resource ) { return DnsResponseDecoder . getName ( response . content ( ) , resource . contentIndex ( ) ) ; } }
package io . vertx . core . dns . impl . netty . decoder ; import io . netty . buffer . ByteBuf ; import io . vertx . core . dns . impl . netty . DnsResource ; import io . vertx . core . dns . impl . netty . DnsResponse ; import io . vertx . core . dns . impl . netty . DnsResponseDecoder ; import io . vertx . core . dns . impl . netty . decoder . record . MailExchangerRecord ; public class MailExchangerDecoder implements RecordDecoder < MailExchangerRecord > { @ Override public MailExchangerRecord decode ( DnsResponse response , DnsResource resource ) { ByteBuf packet = response . content ( ) . readerIndex ( resource . contentIndex ( ) ) ; int priority = packet . readShort ( ) ; String name = DnsResponseDecoder . readName ( packet ) ; return new MailExchangerRecord ( priority , name ) ; } }
package io . vertx . core . dns . impl . netty . decoder ; import io . netty . buffer . ByteBuf ; import io . netty . util . CharsetUtil ; import io . vertx . core . dns . impl . netty . DnsResource ; import io . vertx . core . dns . impl . netty . DnsResponse ; import java . util . ArrayList ; import java . util . List ; public class TextDecoder implements RecordDecoder < List < String > > { @ Override public List < String > decode ( DnsResponse response , DnsResource resource ) { List < String > list = new ArrayList < > ( ) ; ByteBuf data = resource . content ( ) . readerIndex ( response . originalIndex ( ) ) ; int index = data . readerIndex ( ) ; while ( index < data . writerIndex ( ) ) { int len = data . getUnsignedByte ( index ++ ) ; list . add ( data . toString ( index , len , CharsetUtil . UTF_8 ) ) ; index += len ; } return list ; } }
package io . vertx . core . dns . impl . netty . decoder ; import io . netty . buffer . ByteBuf ; import io . netty . handler . codec . DecoderException ; import io . netty . util . CharsetUtil ; import io . vertx . core . dns . impl . netty . DnsResource ; import io . vertx . core . dns . impl . netty . DnsResponse ; import java . net . InetAddress ; import java . net . UnknownHostException ; public class AddressDecoder implements RecordDecoder < InetAddress > { private final int octets ; public AddressDecoder ( int octets ) { this . octets = octets ; } @ Override public InetAddress decode ( DnsResponse response , DnsResource resource ) { ByteBuf data = resource . content ( ) . copy ( ) . readerIndex ( response . originalIndex ( ) ) ; int size = data . writerIndex ( ) - data . readerIndex ( ) ; if ( data . readerIndex ( ) != 0 || size != octets ) { throw new DecoderException ( "Invalid content length, or reader index when decoding address [index: " + data . readerIndex ( ) + ", expected length: " + octets + ", actual: " + size + "]." ) ; } byte [ ] address = new byte [ octets ] ; data . getBytes ( data . readerIndex ( ) , address ) ; try { return InetAddress . getByAddress ( address ) ; } catch ( UnknownHostException e ) { throw new DecoderException ( "Could not convert address " + data . toString ( data . readerIndex ( ) , size , CharsetUtil . UTF_8 ) + " to InetAddress." ) ; } } }
package io . vertx . core . dns . impl . netty . decoder ; import io . netty . buffer . ByteBuf ; import io . vertx . core . dns . impl . netty . DnsResource ; import io . vertx . core . dns . impl . netty . DnsResponse ; import io . vertx . core . dns . impl . netty . DnsResponseDecoder ; import io . vertx . core . dns . impl . netty . decoder . record . StartOfAuthorityRecord ; public class StartOfAuthorityDecoder implements RecordDecoder < StartOfAuthorityRecord > { @ Override public StartOfAuthorityRecord decode ( DnsResponse response , DnsResource resource ) { ByteBuf packet = response . content ( ) . readerIndex ( resource . contentIndex ( ) ) ; String mName = DnsResponseDecoder . readName ( packet ) ; String rName = DnsResponseDecoder . readName ( packet ) ; long serial = packet . readUnsignedInt ( ) ; int refresh = packet . readInt ( ) ; int retry = packet . readInt ( ) ; int expire = packet . readInt ( ) ; long minimum = packet . readUnsignedInt ( ) ; return new StartOfAuthorityRecord ( mName , rName , serial , refresh , retry , expire , minimum ) ; } }
package io . vertx . core . dns . impl . netty . decoder . record ; public class ServiceRecord { private final int priority ; private final int weight ; private final int port ; private final String name ; private final String protocol ; private final String service ; private final String target ; public ServiceRecord ( String fullPath , int priority , int weight , int port , String target ) { String [ ] parts = fullPath . split ( "\\." , 3 ) ; service = parts [ 0 ] ; protocol = parts [ 1 ] ; name = parts [ 2 ] ; this . priority = priority ; this . weight = weight ; this . port = port ; this . target = target ; } public int priority ( ) { return priority ; } public int weight ( ) { return weight ; } public int port ( ) { return port ; } public String name ( ) { return name ; } public String protocol ( ) { return protocol ; } public String service ( ) { return service ; } public String target ( ) { return target ; } }
package io . vertx . core . dns . impl . netty . decoder . record ;
package io . vertx . core . dns . impl . netty . decoder . record ; public class StartOfAuthorityRecord { private final String primaryNameServer ; private final String responsiblePerson ; private final long serial ; private final int refreshTime ; private final int retryTime ; private final int expireTime ; private final long minimumTtl ; public StartOfAuthorityRecord ( String primaryNameServer , String responsiblePerson , long serial , int refreshTime , int retryTime , int expireTime , long minimumTtl ) { this . primaryNameServer = primaryNameServer ; this . responsiblePerson = responsiblePerson ; this . serial = serial ; this . refreshTime = refreshTime ; this . retryTime = retryTime ; this . expireTime = expireTime ; this . minimumTtl = minimumTtl ; } public String primaryNameServer ( ) { return primaryNameServer ; } public String responsiblePerson ( ) { return responsiblePerson ; } public long serial ( ) { return serial ; } public int refreshTime ( ) { return refreshTime ; } public int retryTime ( ) { return retryTime ; } public int expireTime ( ) { return expireTime ; } public long minimumTtl ( ) { return minimumTtl ; } }
package io . vertx . test . core ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { java . lang . annotation . ElementType . METHOD } ) public @ interface Repeat { public abstract int times ( ) ; }
package io . vertx . core . dns . impl . netty . decoder . record ; public class MailExchangerRecord { private final int priority ; private final String name ; public MailExchangerRecord ( int priority , String name ) { this . priority = priority ; this . name = name ; } public int priority ( ) { return priority ; } public String name ( ) { return name ; } }
package io . vertx . core . logging ; import io . vertx . core . spi . logging . LogDelegate ; import io . vertx . core . spi . logging . LogDelegateFactory ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class LoggerFactory { public static final String LOGGER_DELEGATE_FACTORY_CLASS_NAME = "vertx.logger-delegate-factory-class-name" ; private static volatile LogDelegateFactory delegateFactory ; private static final ConcurrentMap < String , Logger > loggers = new ConcurrentHashMap < > ( ) ; static { initialise ( ) ; } public static synchronized void initialise ( ) { LogDelegateFactory delegateFactory = delegateFactory ( ) ; try { } catch ( Exception e ) { } LoggerFactory . delegateFactory = delegateFactory ; } private static LogDelegateFactory delegateFactory ( ) { LogDelegateFactory delegateFactory ; String className = JULLogDelegateFactory . class . getName ( ) ; className = System . getProperty ( LOGGER_DELEGATE_FACTORY_CLASS_NAME ) ; if ( className != null ) { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Class < ? > clz = loader . loadClass ( className ) ; delegateFactory = ( LogDelegateFactory ) clz . newInstance ( ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Error instantiating transformer class \"" + className + "\"" , e ) ; } try { Class < ? > clz = loader . loadClass ( className ) ; delegateFactory = ( LogDelegateFactory ) clz . newInstance ( ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Error instantiating transformer class \"" + className + "\"" , e ) ; } } else { delegateFactory = new JULLogDelegateFactory ( ) ; } return delegateFactory ; } public static Logger getLogger ( final Class < ? > clazz ) { String name = clazz . isAnonymousClass ( ) ? clazz . getEnclosingClass ( ) . getCanonicalName ( ) : clazz . getCanonicalName ( ) ; return getLogger ( name ) ; } public static Logger getLogger ( final String name ) { Logger logger = loggers . get ( name ) ; if ( logger == null ) { LogDelegate delegate = delegateFactory . createDelegate ( name ) ; logger = new Logger ( delegate ) ; Logger oldLogger = loggers . putIfAbsent ( name , logger ) ; if ( oldLogger != null ) { logger = oldLogger ; } } return logger ; } public static void removeLogger ( String name ) { loggers . remove ( name ) ; } }
package io . vertx . core . logging ; import io . vertx . core . spi . logging . LogDelegate ; import io . vertx . core . spi . logging . LogDelegateFactory ; public class SLF4JLogDelegateFactory implements LogDelegateFactory { public LogDelegate createDelegate ( final String clazz ) { return new SLF4JLogDelegate ( clazz ) ; } }
package io . vertx . core . logging ; import io . vertx . core . logging . Logger ; import io . vertx . core . spi . logging . LogDelegate ; import org . apache . log4j . Level ; public class Log4jLogDelegate implements LogDelegate { private static final String FQCN = Logger . class . getCanonicalName ( ) ; private final org . apache . log4j . Logger logger ; Log4jLogDelegate ( final String name ) { logger = org . apache . log4j . Logger . getLogger ( name ) ; } public boolean isInfoEnabled ( ) { return logger . isInfoEnabled ( ) ; } public boolean isDebugEnabled ( ) { return logger . isDebugEnabled ( ) ; } public boolean isTraceEnabled ( ) { return logger . isTraceEnabled ( ) ; } public void fatal ( final Object message ) { log ( Level . FATAL , message ) ; } public void fatal ( final Object message , final Throwable t ) { log ( Level . FATAL , message , t ) ; } public void error ( final Object message ) { log ( Level . ERROR , message ) ; } public void error ( final Object message , final Throwable t ) { log ( Level . ERROR , message , t ) ; } public void warn ( final Object message ) { log ( Level . WARN , message ) ; } public void warn ( final Object message , final Throwable t ) { log ( Level . WARN , message , t ) ; } public void info ( final Object message ) { log ( Level . INFO , message ) ; } public void info ( final Object message , final Throwable t ) { log ( Level . INFO , message , t ) ; } public void debug ( final Object message ) { log ( Level . DEBUG , message ) ; } public void debug ( final Object message , final Throwable t ) { log ( Level . DEBUG , message , t ) ; } public void trace ( final Object message ) { log ( Level . TRACE , message ) ; } public void trace ( final Object message , final Throwable t ) { log ( Level . TRACE , message , t ) ; } private void log ( Level level , Object message ) { log ( level , message , null ) ; } private void log ( Level level , Object message , Throwable t ) { logger . log ( FQCN , level , message , t ) ; } }
package io . vertx . core . logging ; import io . vertx . core . spi . logging . LogDelegate ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . slf4j . spi . LocationAwareLogger ; import static org . slf4j . spi . LocationAwareLogger . * ; public class SLF4JLogDelegate implements LogDelegate { private static final String FQCN = io . vertx . core . logging . Logger . class . getCanonicalName ( ) ; private final Logger logger ; SLF4JLogDelegate ( final String name ) { logger = LoggerFactory . getLogger ( name ) ; } public boolean isInfoEnabled ( ) { return logger . isInfoEnabled ( ) ; } public boolean isDebugEnabled ( ) { return logger . isDebugEnabled ( ) ; } public boolean isTraceEnabled ( ) { return logger . isTraceEnabled ( ) ; } public void fatal ( final Object message ) { log ( ERROR_INT , message ) ; } public void fatal ( final Object message , final Throwable t ) { log ( ERROR_INT , message , t ) ; } public void error ( final Object message ) { log ( ERROR_INT , message ) ; } public void error ( final Object message , final Throwable t ) { log ( ERROR_INT , message , t ) ; } public void warn ( final Object message ) { log ( WARN_INT , message ) ; } public void warn ( final Object message , final Throwable t ) { log ( WARN_INT , message , t ) ; } public void info ( final Object message ) { log ( INFO_INT , message ) ; } public void info ( final Object message , final Throwable t ) { log ( INFO_INT , message , t ) ; } public void debug ( final Object message ) { log ( DEBUG_INT , message ) ; } public void debug ( final Object message , final Throwable t ) { log ( DEBUG_INT , message , t ) ; } public void trace ( final Object message ) { log ( TRACE_INT , message ) ; } public void trace ( final Object message , final Throwable t ) { log ( TRACE_INT , message , t ) ; } private void log ( int level , Object message ) { log ( level , message , null ) ; } private void log ( int level , Object message , Throwable t ) { String msg = ( message == null ) ? "NULL" : message . toString ( ) ; if ( logger instanceof LocationAwareLogger ) { LocationAwareLogger l = ( LocationAwareLogger ) logger ; l . log ( null , FQCN , level , msg , null , t ) ; } else { switch ( level ) { case TRACE_INT : logger . trace ( msg , t ) ; break ; case DEBUG_INT : logger . debug ( msg , t ) ; break ; case INFO_INT : logger . info ( msg , t ) ; break ; case WARN_INT : logger . warn ( msg , t ) ; break ; case ERROR_INT : logger . error ( msg , t ) ; break ; default : throw new IllegalArgumentException ( "Unknown log level " + level ) ; } } } }
package io . vertx . core . logging ; import io . vertx . core . spi . logging . LogDelegate ; import java . util . logging . Level ; import java . util . logging . LogRecord ; public class JULLogDelegate implements LogDelegate { private final java . util . logging . Logger logger ; JULLogDelegate ( final String name ) { logger = java . util . logging . Logger . getLogger ( name ) ; } public boolean isInfoEnabled ( ) { return logger . isLoggable ( Level . INFO ) ; } public boolean isDebugEnabled ( ) { return logger . isLoggable ( Level . FINE ) ; } public boolean isTraceEnabled ( ) { return logger . isLoggable ( Level . FINEST ) ; } public void fatal ( final Object message ) { log ( Level . SEVERE , message ) ; } public void fatal ( final Object message , final Throwable t ) { log ( Level . SEVERE , message , t ) ; } public void error ( final Object message ) { log ( Level . SEVERE , message ) ; } public void error ( final Object message , final Throwable t ) { log ( Level . SEVERE , message , t ) ; } public void warn ( final Object message ) { log ( Level . WARNING , message ) ; } public void warn ( final Object message , final Throwable t ) { log ( Level . WARNING , message , t ) ; } public void info ( final Object message ) { log ( Level . INFO , message ) ; } public void info ( final Object message , final Throwable t ) { log ( Level . INFO , message , t ) ; } public void debug ( final Object message ) { log ( Level . FINE , message ) ; } public void debug ( final Object message , final Throwable t ) { log ( Level . FINE , message , t ) ; } public void trace ( final Object message ) { log ( Level . FINEST , message ) ; } public void trace ( final Object message , final Throwable t ) { log ( Level . FINEST , message , t ) ; } private void log ( Level level , Object message ) { log ( level , message , null ) ; } private void log ( Level level , Object message , Throwable t ) { if ( ! logger . isLoggable ( level ) ) { return ; } String msg = ( message == null ) ? "NULL" : message . toString ( ) ; LogRecord record = new LogRecord ( level , msg ) ; record . setLoggerName ( logger . getName ( ) ) ; record . setThrown ( t ) ; record . setSourceClassName ( null ) ; logger . log ( record ) ; } }
package io . vertx . core . logging ; import io . vertx . core . spi . logging . LogDelegate ; import io . vertx . core . spi . logging . LogDelegateFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . logging . LogManager ; public class JULLogDelegateFactory implements LogDelegateFactory { static { if ( System . getProperty ( "java.util.logging.config.file" ) == null ) { try ( InputStream is = JULLogDelegateFactory . class . getClassLoader ( ) . getResourceAsStream ( "vertx-default-jul-logging.properties" ) ) { if ( is != null ) { LogManager . getLogManager ( ) . readConfiguration ( is ) ; } } catch ( IOException ignore ) { } } } public LogDelegate createDelegate ( final String name ) { return new JULLogDelegate ( name ) ; } }
package io . vertx . core . logging ; import io . vertx . core . impl . Utils ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . time . Instant ; import java . time . OffsetDateTime ; import java . time . ZoneId ; import java . time . format . DateTimeFormatter ; import java . util . logging . LogRecord ; public class VertxLoggerFormatter extends java . util . logging . Formatter { @ Override public String format ( final LogRecord record ) { OffsetDateTime date = fromMillis ( record . getMillis ( ) ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( "[" ) . append ( Thread . currentThread ( ) . getName ( ) ) . append ( "] " ) ; sb . append ( date . format ( DateTimeFormatter . ISO_OFFSET_DATE_TIME ) ) . append ( " " ) ; sb . append ( record . getLevel ( ) ) . append ( " [" ) ; sb . append ( record . getLoggerName ( ) ) . append ( "]" ) . append ( " " ) ; sb . append ( record . getMessage ( ) ) ; sb . append ( Utils . LINE_SEPARATOR ) ; if ( record . getThrown ( ) != null ) { try { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; record . getThrown ( ) . printStackTrace ( pw ) ; pw . close ( ) ; sb . append ( sw . toString ( ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } return sb . toString ( ) ; } private static OffsetDateTime fromMillis ( long epochMillis ) { return OffsetDateTime . ofInstant ( Instant . ofEpochMilli ( epochMillis ) , ZoneId . systemDefault ( ) ) ; } }
package io . vertx . core . logging ; import io . vertx . core . spi . logging . LogDelegate ; import io . vertx . core . spi . logging . LogDelegateFactory ; public class Log4jLogDelegateFactory implements LogDelegateFactory { public LogDelegate createDelegate ( final String name ) { return new Log4jLogDelegate ( name ) ; } }
package io . vertx . core . logging ; import io . vertx . core . spi . logging . LogDelegate ; public class Logger { final LogDelegate delegate ; public Logger ( final LogDelegate delegate ) { this . delegate = delegate ; } public boolean isInfoEnabled ( ) { return delegate . isInfoEnabled ( ) ; } public boolean isDebugEnabled ( ) { return delegate . isDebugEnabled ( ) ; } public boolean isTraceEnabled ( ) { return delegate . isTraceEnabled ( ) ; } public void fatal ( final Object message ) { delegate . fatal ( message ) ; } public void fatal ( final Object message , final Throwable t ) { delegate . fatal ( message , t ) ; } public void error ( final Object message ) { delegate . error ( message ) ; } public void error ( final Object message , final Throwable t ) { delegate . error ( message , t ) ; } public void warn ( final Object message ) { delegate . warn ( message ) ; } public void warn ( final Object message , final Throwable t ) { delegate . warn ( message , t ) ; } public void info ( final Object message ) { delegate . info ( message ) ; } public void info ( final Object message , final Throwable t ) { delegate . info ( message , t ) ; } public void debug ( final Object message ) { delegate . debug ( message ) ; } public void debug ( final Object message , final Throwable t ) { delegate . debug ( message , t ) ; } public void trace ( final Object message ) { delegate . trace ( message ) ; } public void trace ( final Object message , final Throwable t ) { delegate . trace ( message , t ) ; } }
package io . vertx . test . core ; enum KeyCert { NONE , JKS , PKCS12 , PEM , JKS_CA , PKCS12_CA , PEM_CA }
@ Document ( fileName = "eventbus.adoc" ) package io . vertx . core . eventbus ; import io . vertx . docgen . Document ;
package io . vertx . core . eventbus ; import io . vertx . core . buffer . Buffer ; public interface MessageCodec < S , R > { void encodeToWire ( Buffer buffer , S s ) ; R decodeFromWire ( int pos , Buffer buffer ) ; R transform ( S s ) ; String name ( ) ; byte systemCodecID ( ) ; }
package io . vertx . core . eventbus ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . metrics . Measured ; import io . vertx . core . streams . WriteStream ; @ VertxGen public interface EventBus extends Measured { @ Fluent EventBus send ( String address , Object message ) ; @ Fluent < T > EventBus send ( String address , Object message , Handler < AsyncResult < Message < T > > > replyHandler ) ; @ Fluent < T > EventBus send ( String address , Object message , DeliveryOptions options ) ; @ Fluent < T > EventBus send ( String address , Object message , DeliveryOptions options , Handler < AsyncResult < Message < T > > > replyHandler ) ; @ Fluent EventBus publish ( String address , Object message ) ; @ Fluent EventBus publish ( String address , Object message , DeliveryOptions options ) ; < T > MessageConsumer < T > consumer ( String address ) ; < T > MessageConsumer < T > consumer ( String address , Handler < Message < T > > handler ) ; < T > MessageConsumer < T > localConsumer ( String address ) ; < T > MessageConsumer < T > localConsumer ( String address , Handler < Message < T > > handler ) ; < T > MessageProducer < T > sender ( String address ) ; < T > MessageProducer < T > sender ( String address , DeliveryOptions options ) ; < T > MessageProducer < T > publisher ( String address ) ; < T > MessageProducer < T > publisher ( String address , DeliveryOptions options ) ; void close ( Handler < AsyncResult < Void > > completionHandler ) ; @ GenIgnore EventBus registerCodec ( MessageCodec codec ) ; @ GenIgnore EventBus unregisterCodec ( String name ) ; @ GenIgnore < T > EventBus registerDefaultCodec ( Class < T > clazz , MessageCodec < T , ? > codec ) ; @ GenIgnore EventBus unregisterDefaultCodec ( Class clazz ) ; }
package io . vertx . core . eventbus ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . MultiMap ; import io . vertx . core . http . CaseInsensitiveHeaders ; import io . vertx . core . impl . Arguments ; import io . vertx . core . json . JsonObject ; import java . util . Map ; import java . util . Objects ; @ DataObject public class DeliveryOptions { public static final long DEFAULT_TIMEOUT = 30 * 1000 ; private long timeout = DEFAULT_TIMEOUT ; private String codecName ; private MultiMap headers ; public DeliveryOptions ( ) { } public DeliveryOptions ( DeliveryOptions other ) { this . timeout = other . getSendTimeout ( ) ; this . codecName = other . getCodecName ( ) ; this . headers = other . getHeaders ( ) ; } public DeliveryOptions ( JsonObject json ) { this . timeout = json . getLong ( "timeout" , DEFAULT_TIMEOUT ) ; this . codecName = json . getString ( "codecName" , null ) ; JsonObject hdrs = json . getJsonObject ( "headers" , null ) ; if ( hdrs != null ) { headers = new CaseInsensitiveHeaders ( ) ; for ( Map . Entry < String , Object > entry : hdrs ) { if ( ! ( entry . getValue ( ) instanceof String ) ) { throw new IllegalStateException ( "Invalid type for message header value " + entry . getValue ( ) . getClass ( ) ) ; } headers . set ( entry . getKey ( ) , ( String ) entry . getValue ( ) ) ; } } } public long getSendTimeout ( ) { return timeout ; } public DeliveryOptions setSendTimeout ( long timeout ) { Arguments . require ( timeout >= 1 , "sendTimeout must be >= 1" ) ; this . timeout = timeout ; return this ; } public String getCodecName ( ) { return codecName ; } public DeliveryOptions setCodecName ( String codecName ) { this . codecName = codecName ; return this ; } public DeliveryOptions addHeader ( String key , String value ) { checkHeaders ( ) ; Objects . requireNonNull ( key , "no null key accepted" ) ; Objects . requireNonNull ( value , "no null value accepted" ) ; headers . add ( key , value ) ; return this ; } public DeliveryOptions setHeaders ( MultiMap headers ) { this . headers = headers ; return this ; } public MultiMap getHeaders ( ) { return headers ; } private void checkHeaders ( ) { if ( headers == null ) { headers = new CaseInsensitiveHeaders ( ) ; } } }
package io . vertx . core . eventbus ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; import io . vertx . core . streams . WriteStream ; @ VertxGen public interface MessageProducer < T > extends WriteStream < T > { @ Override MessageProducer < T > exceptionHandler ( Handler < Throwable > handler ) ; @ Override MessageProducer < T > write ( T data ) ; @ Override MessageProducer < T > setWriteQueueMaxSize ( int maxSize ) ; @ Override MessageProducer < T > drainHandler ( Handler < Void > handler ) ; @ Fluent MessageProducer < T > deliveryOptions ( DeliveryOptions options ) ; String address ( ) ; }
package io . vertx . core . eventbus ; import io . vertx . core . VertxException ; public class ReplyException extends VertxException { private final ReplyFailure failureType ; private final int failureCode ; public ReplyException ( ReplyFailure failureType , int failureCode , String message ) { super ( message ) ; this . failureType = failureType ; this . failureCode = failureCode ; } public ReplyException ( ReplyFailure failureType , String message ) { this ( failureType , - 1 , message ) ; } public ReplyException ( ReplyFailure failureType ) { this ( failureType , - 1 , null ) ; } public ReplyFailure failureType ( ) { return failureType ; } public int failureCode ( ) { return failureCode ; } @ Override public String toString ( ) { String message = getMessage ( ) ; return "(" + failureType + "," + failureCode + ") " + ( message != null ? message : "" ) ; } }
package io . vertx . core . eventbus ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . streams . ReadStream ; @ VertxGen public interface MessageConsumer < T > extends ReadStream < Message < T > > { @ Override MessageConsumer < T > exceptionHandler ( Handler < Throwable > handler ) ; @ Override MessageConsumer < T > handler ( Handler < Message < T > > handler ) ; @ Override MessageConsumer < T > pause ( ) ; @ Override MessageConsumer < T > resume ( ) ; @ Override MessageConsumer < T > endHandler ( Handler < Void > endHandler ) ; ReadStream < T > bodyStream ( ) ; boolean isRegistered ( ) ; String address ( ) ; MessageConsumer < T > setMaxBufferedMessages ( int maxBufferedMessages ) ; int getMaxBufferedMessages ( ) ; void completionHandler ( Handler < AsyncResult < Void > > completionHandler ) ; void unregister ( ) ; void unregister ( Handler < AsyncResult < Void > > completionHandler ) ; }
package io . vertx . core . eventbus ; public enum ReplyFailure { TIMEOUT , NO_HANDLERS , RECIPIENT_FAILURE ; public static ReplyFailure fromInt ( int i ) { switch ( i ) { case 0 : return TIMEOUT ; case 1 : return NO_HANDLERS ; case 2 : return RECIPIENT_FAILURE ; default : throw new IllegalStateException ( "Invalid index " + i ) ; } } public int toInt ( ) { switch ( this ) { case TIMEOUT : return 0 ; case NO_HANDLERS : return 1 ; case RECIPIENT_FAILURE : return 2 ; default : throw new IllegalStateException ( "How did we get here?" ) ; } } }
package io . vertx . core . eventbus ; import io . vertx . codegen . annotations . CacheReturn ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; @ VertxGen public interface Message < T > { String address ( ) ; MultiMap headers ( ) ; @ CacheReturn T body ( ) ; String replyAddress ( ) ; void reply ( Object message ) ; < R > void reply ( Object message , Handler < AsyncResult < Message < R > > > replyHandler ) ; void reply ( Object message , DeliveryOptions options ) ; < R > void reply ( Object message , DeliveryOptions options , Handler < AsyncResult < Message < R > > > replyHandler ) ; void fail ( int failureCode , String message ) ; }
package io . vertx . core . eventbus . impl ; import io . vertx . core . * ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . * ; import io . vertx . core . eventbus . impl . codecs . * ; import io . vertx . core . impl . * ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . net . NetClient ; import io . vertx . core . net . NetClientOptions ; import io . vertx . core . net . NetServer ; import io . vertx . core . net . NetSocket ; import io . vertx . core . net . impl . NetClientImpl ; import io . vertx . core . net . impl . ServerID ; import io . vertx . core . parsetools . RecordParser ; import io . vertx . core . spi . cluster . AsyncMultiMap ; import io . vertx . core . spi . cluster . ChoosableIterable ; import io . vertx . core . spi . cluster . ClusterManager ; import io . vertx . core . spi . metrics . EventBusMetrics ; import io . vertx . core . spi . metrics . MetricsProvider ; import io . vertx . core . streams . ReadStream ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . atomic . AtomicReference ; public class EventBusImpl implements EventBus , MetricsProvider { private static final Logger log = LoggerFactory . getLogger ( EventBusImpl . class ) ; private static final MessageCodec < String , String > PING_MESSAGE_CODEC = new PingMessageCodec ( ) ; private static final MessageCodec < String , String > NULL_MESSAGE_CODEC = new NullMessageCodec ( ) ; private static final MessageCodec < String , String > STRING_MESSAGE_CODEC = new StringMessageCodec ( ) ; private static final MessageCodec < Buffer , Buffer > BUFFER_MESSAGE_CODEC = new BufferMessageCodec ( ) ; private static final MessageCodec < JsonObject , JsonObject > JSON_OBJECT_MESSAGE_CODEC = new JsonObjectMessageCodec ( ) ; private static final MessageCodec < JsonArray , JsonArray > JSON_ARRAY_MESSAGE_CODEC = new JsonArrayMessageCodec ( ) ; private static final MessageCodec < byte [ ] , byte [ ] > BYTE_ARRAY_MESSAGE_CODEC = new ByteArrayMessageCodec ( ) ; private static final MessageCodec < Integer , Integer > INT_MESSAGE_CODEC = new IntMessageCodec ( ) ; private static final MessageCodec < Long , Long > LONG_MESSAGE_CODEC = new LongMessageCodec ( ) ; private static final MessageCodec < Float , Float > FLOAT_MESSAGE_CODEC = new FloatMessageCodec ( ) ; private static final MessageCodec < Double , Double > DOUBLE_MESSAGE_CODEC = new DoubleMessageCodec ( ) ; private static final MessageCodec < Boolean , Boolean > BOOLEAN_MESSAGE_CODEC = new BooleanMessageCodec ( ) ; private static final MessageCodec < Short , Short > SHORT_MESSAGE_CODEC = new ShortMessageCodec ( ) ; private static final MessageCodec < Character , Character > CHAR_MESSAGE_CODEC = new CharMessageCodec ( ) ; private static final MessageCodec < Byte , Byte > BYTE_MESSAGE_CODEC = new ByteMessageCodec ( ) ; private static final MessageCodec < ReplyException , ReplyException > REPLY_EXCEPTION_MESSAGE_CODEC = new ReplyExceptionMessageCodec ( ) ; private static final Buffer PONG = Buffer . buffer ( new byte [ ] { ( byte ) 1 } ) ; private static final String PING_ADDRESS = "__vertx_ping" ; private final VertxInternal vertx ; private final long pingInterval ; private final long pingReplyInterval ; private final ConcurrentMap < ServerID , ConnectionHolder > connections = new ConcurrentHashMap < > ( ) ; private final ConcurrentMap < String , Handlers > handlerMap = new ConcurrentHashMap < > ( ) ; private final ConcurrentMap < String , MessageCodec > userCodecMap = new ConcurrentHashMap < > ( ) ; private final ConcurrentMap < Class , MessageCodec > defaultCodecMap = new ConcurrentHashMap < > ( ) ; private final HAManager haManager ; private final ClusterManager clusterMgr ; private final AtomicLong replySequence = new AtomicLong ( 0 ) ; private final EventBusMetrics metrics ; private final AsyncMultiMap < String , ServerID > subs ; private final MessageCodec [ ] systemCodecs ; private final ServerID serverID ; private final NetServer server ; private final Context sendNoContext ; public EventBusImpl ( VertxInternal vertx ) { this . vertx = vertx ; this . pingInterval = - 1 ; this . pingReplyInterval = - 1 ; this . serverID = new ServerID ( - 1 , "localhost" ) ; this . server = null ; this . subs = null ; this . clusterMgr = null ; this . haManager = null ; this . metrics = vertx . metricsSPI ( ) . createMetrics ( this ) ; this . systemCodecs = systemCodecs ( ) ; this . sendNoContext = vertx . getOrCreateContext ( ) ; } public EventBusImpl ( VertxInternal vertx , long pingInterval , long pingReplyInterval , ClusterManager clusterManager , HAManager haManager , AsyncMultiMap < String , ServerID > subs , ServerID serverID , EventBusNetServer server ) { this . vertx = vertx ; this . clusterMgr = clusterManager ; this . haManager = haManager ; this . metrics = vertx . metricsSPI ( ) . createMetrics ( this ) ; this . pingInterval = pingInterval ; this . pingReplyInterval = pingReplyInterval ; this . subs = subs ; this . systemCodecs = systemCodecs ( ) ; this . serverID = serverID ; this . server = server . netServer ; this . sendNoContext = vertx . getOrCreateContext ( ) ; setServerHandler ( server ) ; addFailoverCompleteHandler ( ) ; } @ Override public EventBus send ( String address , Object message ) { return send ( address , message , new DeliveryOptions ( ) , null ) ; } @ Override public < T > EventBus send ( String address , Object message , Handler < AsyncResult < Message < T > > > replyHandler ) { return send ( address , message , new DeliveryOptions ( ) , replyHandler ) ; } @ Override public < T > EventBus send ( String address , Object message , DeliveryOptions options ) { return send ( address , message , options , null ) ; } @ Override public < T > EventBus send ( String address , Object message , DeliveryOptions options , Handler < AsyncResult < Message < T > > > replyHandler ) { sendOrPub ( null , createMessage ( true , address , options . getHeaders ( ) , message , options . getCodecName ( ) ) , options , replyHandler ) ; return this ; } @ Override public < T > MessageProducer < T > sender ( String address ) { Objects . requireNonNull ( address , "address" ) ; return new MessageProducerImpl < > ( this , address , true , new DeliveryOptions ( ) ) ; } @ Override public < T > MessageProducer < T > sender ( String address , DeliveryOptions options ) { Objects . requireNonNull ( address , "address" ) ; Objects . requireNonNull ( options , "options" ) ; return new MessageProducerImpl < > ( this , address , true , options ) ; } @ Override public < T > MessageProducer < T > publisher ( String address ) { Objects . requireNonNull ( address , "address" ) ; return new MessageProducerImpl < > ( this , address , false , new DeliveryOptions ( ) ) ; } @ Override public < T > MessageProducer < T > publisher ( String address , DeliveryOptions options ) { Objects . requireNonNull ( address , "address" ) ; Objects . requireNonNull ( options , "options" ) ; return new MessageProducerImpl < > ( this , address , false , options ) ; } @ Override public EventBus publish ( String address , Object message ) { return publish ( address , message , new DeliveryOptions ( ) ) ; } @ Override public EventBus publish ( String address , Object message , DeliveryOptions options ) { sendOrPub ( null , createMessage ( false , address , options . getHeaders ( ) , message , options . getCodecName ( ) ) , options , null ) ; return this ; } @ Override public < T > MessageConsumer < T > consumer ( String address ) { Objects . requireNonNull ( address , "address" ) ; return new HandlerRegistration < > ( address , false , false , - 1 ) ; } @ Override public < T > MessageConsumer < T > consumer ( String address , Handler < Message < T > > handler ) { Objects . requireNonNull ( handler , "handler" ) ; MessageConsumer < T > consumer = consumer ( address ) ; consumer . handler ( handler ) ; return consumer ; } @ Override public < T > MessageConsumer < T > localConsumer ( String address ) { Objects . requireNonNull ( address , "address" ) ; return new HandlerRegistration < > ( address , false , true , - 1 ) ; } @ Override public < T > MessageConsumer < T > localConsumer ( String address , Handler < Message < T > > handler ) { Objects . requireNonNull ( handler , "handler" ) ; MessageConsumer < T > consumer = localConsumer ( address ) ; consumer . handler ( handler ) ; return consumer ; } @ Override public EventBus registerCodec ( MessageCodec codec ) { Objects . requireNonNull ( codec , "codec" ) ; Objects . requireNonNull ( codec . name ( ) , "code.name()" ) ; checkSystemCodec ( codec ) ; if ( userCodecMap . containsKey ( codec . name ( ) ) ) { throw new IllegalStateException ( "Already a codec registered with name " + codec . name ( ) ) ; } userCodecMap . put ( codec . name ( ) , codec ) ; return this ; } @ Override public EventBus unregisterCodec ( String name ) { Objects . requireNonNull ( name ) ; userCodecMap . remove ( name ) ; return this ; } @ Override public < T > EventBus registerDefaultCodec ( Class < T > clazz , MessageCodec < T , ? > codec ) { Objects . requireNonNull ( clazz ) ; Objects . requireNonNull ( codec , "codec" ) ; Objects . requireNonNull ( codec . name ( ) , "code.name()" ) ; checkSystemCodec ( codec ) ; if ( defaultCodecMap . containsKey ( clazz ) ) { throw new IllegalStateException ( "Already a default codec registered for class " + clazz ) ; } if ( userCodecMap . containsKey ( codec . name ( ) ) ) { throw new IllegalStateException ( "Already a codec registered with name " + codec . name ( ) ) ; } defaultCodecMap . put ( clazz , codec ) ; userCodecMap . put ( codec . name ( ) , codec ) ; return this ; } @ Override public EventBus unregisterDefaultCodec ( Class clazz ) { Objects . requireNonNull ( clazz ) ; MessageCodec codec = defaultCodecMap . remove ( clazz ) ; if ( codec != null ) { userCodecMap . remove ( codec . name ( ) ) ; } return this ; } @ Override public void close ( Handler < AsyncResult < Void > > completionHandler ) { if ( clusterMgr != null && clusterMgr instanceof ExtendedClusterManager ) { ExtendedClusterManager ecm = ( ExtendedClusterManager ) clusterMgr ; ecm . beforeLeave ( ) ; } unregisterAllHandlers ( ) ; if ( metrics != null ) { metrics . close ( ) ; } if ( server != null ) { server . close ( ar - > { if ( ar . failed ( ) ) { log . error ( "Failed to close server" , ar . cause ( ) ) ; } for ( ConnectionHolder holder : connections . values ( ) ) { holder . close ( ) ; } closeClusterManager ( completionHandler ) ; } ) ; } else { closeClusterManager ( completionHandler ) ; } } private void unregisterAllHandlers ( ) { for ( Handlers handlers : handlerMap . values ( ) ) { for ( HandlerHolder holder : handlers . list ) { holder . handler . unregister ( true ) ; } } } @ Override public boolean isMetricsEnabled ( ) { return metrics != null && metrics . isEnabled ( ) ; } @ Override public EventBusMetrics < ? > getMetrics ( ) { return metrics ; } < T > void sendReply ( ServerID dest , MessageImpl message , DeliveryOptions options , Handler < AsyncResult < Message < T > > > replyHandler ) { if ( message . address ( ) == null ) { sendNoHandlersFailure ( null , replyHandler ) ; } else { sendOrPub ( dest , message , options , replyHandler ) ; } } MessageImpl createMessage ( boolean send , String address , MultiMap headers , Object body , String codecName ) { Objects . requireNonNull ( address , "no null address accepted" ) ; MessageCodec codec = codec ( body , codecName ) ; @ SuppressWarnings ( "unchecked" ) MessageImpl msg = new MessageImpl ( serverID , address , null , headers , body , codec , send ) ; return msg ; } private MessageCodec codec ( Object body , String codecName ) throws java . lang . IllegalArgumentException { MessageCodec codec ; if ( codecName != null ) { codec = userCodecMap . get ( codecName ) ; if ( codec == null ) { throw new IllegalArgumentException ( "No message codec for name: " + codecName ) ; } } else if ( body == null ) { codec = NULL_MESSAGE_CODEC ; } else if ( body instanceof String ) { codec = STRING_MESSAGE_CODEC ; } else if ( body instanceof Buffer ) { codec = BUFFER_MESSAGE_CODEC ; } else if ( body instanceof JsonObject ) { codec = JSON_OBJECT_MESSAGE_CODEC ; } else if ( body instanceof JsonArray ) { codec = JSON_ARRAY_MESSAGE_CODEC ; } else if ( body instanceof byte [ ] ) { codec = BYTE_ARRAY_MESSAGE_CODEC ; } else if ( body instanceof Integer ) { codec = INT_MESSAGE_CODEC ; } else if ( body instanceof Long ) { codec = LONG_MESSAGE_CODEC ; } else if ( body instanceof Float ) { codec = FLOAT_MESSAGE_CODEC ; } else if ( body instanceof Double ) { codec = DOUBLE_MESSAGE_CODEC ; } else if ( body instanceof Boolean ) { codec = BOOLEAN_MESSAGE_CODEC ; } else if ( body instanceof Short ) { codec = SHORT_MESSAGE_CODEC ; } else if ( body instanceof Character ) { codec = CHAR_MESSAGE_CODEC ; } else if ( body instanceof Byte ) { codec = BYTE_MESSAGE_CODEC ; } else if ( body instanceof ReplyException ) { codec = REPLY_EXCEPTION_MESSAGE_CODEC ; } else { codec = defaultCodecMap . get ( body . getClass ( ) ) ; if ( codec == null ) { throw new IllegalArgumentException ( "No message codec for type: " + body . getClass ( ) ) ; } } return codec ; } private void checkSystemCodec ( MessageCodec codec ) { if ( codec . systemCodecID ( ) != - 1 ) { throw new IllegalArgumentException ( "Can't register a system codec" ) ; } } private void closeClusterManager ( Handler < AsyncResult < Void > > completionHandler ) { if ( clusterMgr != null ) { clusterMgr . leave ( ar - > { if ( ar . failed ( ) ) { log . error ( "Failed to leave cluster" , ar . cause ( ) ) ; } if ( completionHandler != null ) { vertx . runOnContext ( v - > completionHandler . handle ( Future . succeededFuture ( ) ) ) ; } } ) ; } else if ( completionHandler != null ) { vertx . runOnContext ( v - > completionHandler . handle ( Future . succeededFuture ( ) ) ) ; } } private void setServerHandler ( EventBusNetServer server ) { Handler < NetSocket > sockHandler = socket - > { RecordParser parser = RecordParser . newFixed ( 4 , null ) ; Handler < Buffer > handler = new Handler < Buffer > ( ) { int size = - 1 ; public void handle ( Buffer buff ) { if ( size == - 1 ) { size = buff . getInt ( 0 ) ; parser . fixedSizeMode ( size ) ; } else { MessageImpl received = new MessageImpl ( ) ; received . readFromWire ( socket , buff , userCodecMap , systemCodecs ) ; metrics . messageRead ( received . address ( ) , buff . length ( ) ) ; parser . fixedSizeMode ( 4 ) ; size = - 1 ; if ( received . codec ( ) == PING_MESSAGE_CODEC ) { socket . write ( PONG ) ; } else { receiveMessage ( received , - 1 , null , null , false ) ; } } } } ; parser . setOutput ( handler ) ; socket . handler ( parser ) ; } ; server . setHandler ( sockHandler ) ; } private void addFailoverCompleteHandler ( ) { haManager . setRemoveSubsHandler ( ( failedNodeID , haInfo , failed ) - > { JsonObject jsid = haInfo . getJsonObject ( "server_id" ) ; if ( jsid != null ) { ServerID sid = new ServerID ( jsid . getInteger ( "port" ) , jsid . getString ( "host" ) ) ; cleanSubsForServerID ( sid ) ; } } ) ; } private < T > void sendToSubs ( ChoosableIterable < ServerID > subs , MessageImpl message , long timeoutID , Handler < AsyncResult < Message < T > > > asyncResultHandler , Handler < Message < T > > replyHandler ) { if ( message . send ( ) ) { ServerID sid = subs . choose ( ) ; if ( ! sid . equals ( serverID ) ) { metrics . messageSent ( message . address ( ) , false , false , true ) ; sendRemote ( sid , message ) ; } else { metrics . messageSent ( message . address ( ) , false , true , false ) ; receiveMessage ( message , timeoutID , asyncResultHandler , replyHandler , true ) ; } } else { boolean local = false ; boolean remote = false ; for ( ServerID sid : subs ) { if ( ! sid . equals ( serverID ) ) { remote = true ; sendRemote ( sid , message ) ; } else { local = true ; } } metrics . messageSent ( message . address ( ) , true , local , remote ) ; if ( local ) { receiveMessage ( message , timeoutID , null , replyHandler , true ) ; } } } private MessageCodec [ ] systemCodecs ( ) { return codecs ( NULL_MESSAGE_CODEC , PING_MESSAGE_CODEC , STRING_MESSAGE_CODEC , BUFFER_MESSAGE_CODEC , JSON_OBJECT_MESSAGE_CODEC , JSON_ARRAY_MESSAGE_CODEC , BYTE_ARRAY_MESSAGE_CODEC , INT_MESSAGE_CODEC , LONG_MESSAGE_CODEC , FLOAT_MESSAGE_CODEC , DOUBLE_MESSAGE_CODEC , BOOLEAN_MESSAGE_CODEC , SHORT_MESSAGE_CODEC , CHAR_MESSAGE_CODEC , BYTE_MESSAGE_CODEC , REPLY_EXCEPTION_MESSAGE_CODEC ) ; } private MessageCodec [ ] codecs ( MessageCodec ... codecs ) { MessageCodec [ ] arr = new MessageCodec [ codecs . length ] ; for ( MessageCodec codec : codecs ) { arr [ codec . systemCodecID ( ) ] = codec ; } return arr ; } private String generateReplyAddress ( ) { if ( clusterMgr != null ) { return UUID . randomUUID ( ) . toString ( ) ; } else { return Long . toString ( replySequence . incrementAndGet ( ) ) ; } } private < T > void sendOrPub ( ServerID replyDest , MessageImpl message , DeliveryOptions options , Handler < AsyncResult < Message < T > > > replyHandler ) { checkStarted ( ) ; Handler < Message < T > > simpleReplyHandler = null ; long timeoutID = - 1 ; if ( replyHandler != null ) { message . setReplyAddress ( generateReplyAddress ( ) ) ; AtomicReference < MessageConsumer > refReg = new AtomicReference < > ( ) ; timeoutID = vertx . setTimer ( options . getSendTimeout ( ) , timerID - > { log . warn ( "Message reply handler timed out as no reply was received - it will be removed" ) ; refReg . get ( ) . unregister ( ) ; metrics . replyFailure ( message . address ( ) , ReplyFailure . TIMEOUT ) ; replyHandler . handle ( Future . failedFuture ( new ReplyException ( ReplyFailure . TIMEOUT , "Timed out waiting for reply" ) ) ) ; } ) ; simpleReplyHandler = convertHandler ( replyHandler ) ; MessageConsumer registration = registerHandler ( message . replyAddress ( ) , simpleReplyHandler , true , true , timeoutID ) ; refReg . set ( registration ) ; } if ( replyDest != null ) { if ( ! replyDest . equals ( this . serverID ) ) { metrics . messageSent ( message . address ( ) , ! message . send ( ) , false , true ) ; sendRemote ( replyDest , message ) ; } else { metrics . messageSent ( message . address ( ) , ! message . send ( ) , true , false ) ; receiveMessage ( message , timeoutID , replyHandler , simpleReplyHandler , true ) ; } } else { if ( subs != null ) { long fTimeoutID = timeoutID ; Handler < Message < T > > fSimpleReplyHandler = simpleReplyHandler ; Handler < AsyncResult < ChoosableIterable < ServerID > > > resultHandler = asyncResult - > { if ( asyncResult . succeeded ( ) ) { ChoosableIterable < ServerID > serverIDs = asyncResult . result ( ) ; if ( serverIDs != null && ! serverIDs . isEmpty ( ) ) { sendToSubs ( serverIDs , message , fTimeoutID , replyHandler , fSimpleReplyHandler ) ; } else { metrics . messageSent ( message . address ( ) , ! message . send ( ) , true , false ) ; receiveMessage ( message , fTimeoutID , replyHandler , fSimpleReplyHandler , true ) ; } } else { log . error ( "Failed to send message" , asyncResult . cause ( ) ) ; } } ; if ( Vertx . currentContext ( ) == null ) { sendNoContext . runOnContext ( v - > { subs . get ( message . address ( ) , resultHandler ) ; } ) ; } else { subs . get ( message . address ( ) , resultHandler ) ; } } else { metrics . messageSent ( message . address ( ) , ! message . send ( ) , true , false ) ; receiveMessage ( message , timeoutID , replyHandler , simpleReplyHandler , true ) ; } } } private < T > Handler < Message < T > > convertHandler ( Handler < AsyncResult < Message < T > > > handler ) { return reply - > { Future < Message < T > > result ; if ( reply . body ( ) instanceof ReplyException ) { ReplyException exception = ( ReplyException ) reply . body ( ) ; metrics . replyFailure ( reply . address ( ) , exception . failureType ( ) ) ; result = Future . failedFuture ( exception ) ; } else { result = Future . succeededFuture ( reply ) ; } handler . handle ( result ) ; } ; } private < T > MessageConsumer registerHandler ( String address , Handler < Message < T > > handler , boolean replyHandler , boolean localOnly , long timeoutID ) { HandlerRegistration < T > registration = new HandlerRegistration < > ( address , replyHandler , localOnly , timeoutID ) ; registration . handler ( handler ) ; return registration ; } private < T > void registerHandler ( String address , HandlerRegistration < T > registration , boolean replyHandler , boolean localOnly , long timeoutID ) { checkStarted ( ) ; Objects . requireNonNull ( address , "address" ) ; Objects . requireNonNull ( registration . handler , "handler" ) ; ContextImpl context = vertx . getContext ( ) ; boolean hasContext = context != null ; if ( ! hasContext ) { context = vertx . createEventLoopContext ( null , new JsonObject ( ) , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } HandlerHolder holder = new HandlerHolder < > ( registration , replyHandler , localOnly , context , timeoutID ) ; Handlers handlers = handlerMap . get ( address ) ; if ( handlers == null ) { handlers = handlers ( address , handlers ) ; if ( subs != null && ! replyHandler && ! localOnly ) { subs . add ( address , serverID , registration : : setResult ) ; } else { registration . setResult ( Future . succeededFuture ( ) ) ; } } else { registration . setResult ( Future . succeededFuture ( ) ) ; } handlers . list . add ( holder ) ; if ( hasContext ) { HandlerEntry entry = new HandlerEntry < > ( address , registration ) ; context . addCloseHook ( entry ) ; } } private EventBusImpl . Handlers handlers ( String address , EventBusImpl . Handlers handlers ) { handlers = new Handlers ( ) ; Handlers prevHandlers = handlerMap . putIfAbsent ( address , handlers ) ; if ( prevHandlers != null ) { handlers = prevHandlers ; } return handlers ; } private < T > void unregisterHandler ( String address , Handler < Message < T > > handler , Handler < AsyncResult < Void > > completionHandler ) { checkStarted ( ) ; Handlers handlers = handlerMap . get ( address ) ; if ( handlers != null ) { synchronized ( handlers ) { int size = handlers . list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { HandlerHolder holder = handlers . list . get ( i ) ; if ( holder . handler == handler ) { if ( holder . timeoutID != - 1 ) { vertx . cancelTimer ( holder . timeoutID ) ; } handlers . list . remove ( i ) ; holder . setRemoved ( ) ; if ( handlers . list . isEmpty ( ) ) { handlerMap . remove ( address ) ; if ( subs != null && ! holder . localOnly ) { removeSub ( address , serverID , completionHandler ) ; } else { callCompletionHandlerAsync ( completionHandler ) ; } } else { callCompletionHandlerAsync ( completionHandler ) ; } holder . context . removeCloseHook ( new HandlerEntry < > ( address , handler ) ) ; break ; } } } } } private < T > void unregisterHandler ( String address , Handler < Message < T > > handler ) { unregisterHandler ( address , handler , null ) ; } private void callCompletionHandlerAsync ( Handler < AsyncResult < Void > > completionHandler ) { if ( completionHandler != null ) { vertx . runOnContext ( v - > completionHandler . handle ( Future . succeededFuture ( ) ) ) ; } } private void cleanSubsForServerID ( ServerID theServerID ) { if ( subs != null ) { subs . removeAllForValue ( theServerID , ar - > { } ) ; } } private void sendRemote ( ServerID theServerID , MessageImpl message ) { ConnectionHolder holder = connections . get ( theServerID ) ; if ( holder == null ) { holder = new ConnectionHolder ( theServerID ) ; ConnectionHolder prevHolder = connections . putIfAbsent ( theServerID , holder ) ; if ( prevHolder != null ) { holder = prevHolder ; } else { holder . connect ( ) ; } } holder . writeMessage ( message ) ; } private void removeSub ( String subName , ServerID theServerID , Handler < AsyncResult < Void > > completionHandler ) { subs . remove ( subName , theServerID , ar - > { if ( ! ar . succeeded ( ) ) { log . error ( "Failed to remove sub" , ar . cause ( ) ) ; } else { if ( ar . result ( ) ) { if ( completionHandler != null ) { completionHandler . handle ( Future . succeededFuture ( ) ) ; } } else { if ( completionHandler != null ) { completionHandler . handle ( Future . failedFuture ( "sub not found" ) ) ; } } } } ) ; } private < T > void receiveMessage ( MessageImpl msg , long timeoutID , Handler < AsyncResult < Message < T > > > replyHandler , Handler < Message < T > > simpleReplyHandler , boolean local ) { msg . setBus ( this ) ; Handlers handlers = handlerMap . get ( msg . address ( ) ) ; if ( handlers != null ) { if ( msg . send ( ) ) { HandlerHolder holder = handlers . choose ( ) ; if ( holder != null ) { metrics . messageReceived ( msg . address ( ) , ! msg . send ( ) , local , 1 ) ; doReceive ( msg , holder , local ) ; } } else { metrics . messageReceived ( msg . address ( ) , ! msg . send ( ) , local , handlers . list . size ( ) ) ; for ( HandlerHolder holder : handlers . list ) { doReceive ( msg , holder , local ) ; } } } else { metrics . messageReceived ( msg . address ( ) , ! msg . send ( ) , local , 0 ) ; if ( replyHandler != null ) { sendNoHandlersFailure ( msg . address ( ) , replyHandler ) ; if ( timeoutID != - 1 ) { vertx . cancelTimer ( timeoutID ) ; } if ( simpleReplyHandler != null ) { unregisterHandler ( msg . replyAddress ( ) , simpleReplyHandler ) ; } } } } private < T > void sendNoHandlersFailure ( String address , Handler < AsyncResult < Message < T > > > handler ) { vertx . runOnContext ( v - > { metrics . replyFailure ( address , ReplyFailure . NO_HANDLERS ) ; handler . handle ( Future . failedFuture ( new ReplyException ( ReplyFailure . NO_HANDLERS ) ) ) ; } ) ; } private < T > void doReceive ( MessageImpl msg , HandlerHolder < T > holder , boolean local ) { @ SuppressWarnings ( "unchecked" ) Message < T > copied = msg . copyBeforeReceive ( ) ; holder . context . runOnContext ( ( v ) - > { try { if ( ! holder . isRemoved ( ) ) { holder . handler . handle ( copied ) ; } } finally { if ( holder . replyHandler ) { unregisterHandler ( msg . address ( ) , holder . handler ) ; } } } ) ; } private void checkStarted ( ) { if ( serverID == null ) { throw new IllegalStateException ( "Event Bus is not started" ) ; } } private class HandlerHolder < T > { final ContextImpl context ; final HandlerRegistration < T > handler ; final boolean replyHandler ; final boolean localOnly ; final long timeoutID ; boolean removed ; void setRemoved ( ) { boolean unregisterMetric = false ; synchronized ( this ) { if ( ! removed ) { removed = true ; unregisterMetric = true ; } } if ( unregisterMetric ) { metrics . handlerUnregistered ( handler . metric ) ; } } synchronized boolean isRemoved ( ) { return removed ; } HandlerHolder ( HandlerRegistration < T > handler , boolean replyHandler , boolean localOnly , ContextImpl context , long timeoutID ) { this . context = context ; this . handler = handler ; this . replyHandler = replyHandler ; this . localOnly = localOnly ; this . timeoutID = timeoutID ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; HandlerHolder that = ( HandlerHolder ) o ; if ( handler != null ? ! handler . equals ( that . handler ) : that . handler != null ) return false ; return true ; } @ Override public int hashCode ( ) { return handler != null ? handler . hashCode ( ) : 0 ; } } private class ConnectionHolder { final NetClient client ; final Queue < MessageImpl > pending = new ArrayDeque < > ( ) ; final ServerID theServerID ; volatile NetSocket socket ; volatile boolean connected ; long timeoutID = - 1 ; long pingTimeoutID = - 1 ; private ConnectionHolder ( ServerID serverID ) { this . theServerID = serverID ; client = new NetClientImpl ( vertx , new NetClientOptions ( ) . setConnectTimeout ( 60 * 1000 ) , false ) ; } void close ( ) { if ( timeoutID != - 1 ) { vertx . cancelTimer ( timeoutID ) ; } if ( pingTimeoutID != - 1 ) { vertx . cancelTimer ( pingTimeoutID ) ; } try { client . close ( ) ; } catch ( Exception ignore ) { } if ( connections . remove ( theServerID , this ) ) { log . debug ( "Cluster connection closed: " + theServerID + " holder " + this ) ; } } void schedulePing ( ) { pingTimeoutID = vertx . setTimer ( pingInterval , id1 - > { timeoutID = vertx . setTimer ( pingReplyInterval , id2 - > { log . warn ( "No pong from server " + serverID + " - will consider it dead" ) ; close ( ) ; } ) ; MessageImpl pingMessage = new MessageImpl < > ( serverID , PING_ADDRESS , null , null , null , new PingMessageCodec ( ) , true ) ; Buffer data = pingMessage . encodeToWire ( ) ; socket . write ( data ) ; } ) ; } synchronized void writeMessage ( MessageImpl message ) { if ( connected ) { Buffer data = message . encodeToWire ( ) ; metrics . messageWritten ( message . address ( ) , data . length ( ) ) ; socket . write ( data ) ; } else { pending . add ( message ) ; } } synchronized void connected ( NetSocket socket ) { this . socket = socket ; connected = true ; socket . exceptionHandler ( t - > close ( ) ) ; socket . closeHandler ( v - > close ( ) ) ; socket . handler ( data - > { vertx . cancelTimer ( timeoutID ) ; schedulePing ( ) ; } ) ; schedulePing ( ) ; for ( MessageImpl message : pending ) { Buffer data = message . encodeToWire ( ) ; metrics . messageWritten ( message . address ( ) , data . length ( ) ) ; socket . write ( data ) ; } pending . clear ( ) ; } void connect ( ) { client . connect ( theServerID . port , theServerID . host , res - > { if ( res . succeeded ( ) ) { connected ( res . result ( ) ) ; } else { close ( ) ; } } ) ; } } private static class Handlers { final List < HandlerHolder > list = new CopyOnWriteArrayList < > ( ) ; final AtomicInteger pos = new AtomicInteger ( 0 ) ; HandlerHolder choose ( ) { while ( true ) { int size = list . size ( ) ; if ( size == 0 ) { return null ; } int p = pos . getAndIncrement ( ) ; if ( p >= size - 1 ) { pos . set ( 0 ) ; } try { return list . get ( p ) ; } catch ( IndexOutOfBoundsException e ) { pos . set ( 0 ) ; } } } } private class HandlerEntry < T > implements Closeable { final String address ; final Handler < Message < T > > handler ; private HandlerEntry ( String address , Handler < Message < T > > handler ) { this . address = address ; this . handler = handler ; } @ Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( getClass ( ) != o . getClass ( ) ) return false ; HandlerEntry entry = ( HandlerEntry ) o ; if ( ! address . equals ( entry . address ) ) return false ; if ( ! handler . equals ( entry . handler ) ) return false ; return true ; } @ Override public int hashCode ( ) { int result = address != null ? address . hashCode ( ) : 0 ; result = 31 * result + ( handler != null ? handler . hashCode ( ) : 0 ) ; return result ; } public void close ( Handler < AsyncResult < Void > > completionHandler ) { unregisterHandler ( this . address , this . handler , null ) ; completionHandler . handle ( Future . succeededFuture ( ) ) ; } } @ Override protected void finalize ( ) throws Throwable { close ( ar - > { } ) ; super . finalize ( ) ; } public class HandlerRegistration < T > implements MessageConsumer < T > , Handler < Message < T > > { private final String address ; private final boolean replyHandler ; private final boolean localOnly ; private final long timeoutID ; private boolean registered ; private Handler < Message < T > > handler ; private AsyncResult < Void > result ; private Handler < AsyncResult < Void > > completionHandler ; private Handler < Void > endHandler ; private Handler < Message < T > > discardHandler ; private int maxBufferedMessages ; private final Queue < Message < T > > pending = new ArrayDeque < > ( 8 ) ; private boolean paused ; private Object metric ; public HandlerRegistration ( String address , boolean replyHandler , boolean localOnly , long timeoutID ) { this . address = address ; this . replyHandler = replyHandler ; this . localOnly = localOnly ; this . timeoutID = timeoutID ; } @ Override public synchronized MessageConsumer < T > setMaxBufferedMessages ( int maxBufferedMessages ) { Arguments . require ( maxBufferedMessages >= 0 , "Max buffered messages cannot be negative" ) ; while ( pending . size ( ) > maxBufferedMessages ) { pending . poll ( ) ; } this . maxBufferedMessages = maxBufferedMessages ; return this ; } @ Override public synchronized int getMaxBufferedMessages ( ) { return maxBufferedMessages ; } @ Override public String address ( ) { return address ; } @ Override public synchronized void completionHandler ( Handler < AsyncResult < Void > > completionHandler ) { Objects . requireNonNull ( completionHandler ) ; if ( result != null ) { AsyncResult < Void > value = result ; vertx . runOnContext ( v - > completionHandler . handle ( value ) ) ; } else { this . completionHandler = completionHandler ; } } @ Override public synchronized void unregister ( ) { unregister ( false ) ; } @ Override public synchronized void unregister ( Handler < AsyncResult < Void > > completionHandler ) { Objects . requireNonNull ( completionHandler ) ; doUnregister ( completionHandler , false ) ; } void unregister ( boolean callEndHandler ) { doUnregister ( null , callEndHandler ) ; } private void doUnregister ( Handler < AsyncResult < Void > > completionHandler , boolean callEndHandler ) { if ( endHandler != null && callEndHandler ) { Handler < Void > theEndHandler = endHandler ; Handler < AsyncResult < Void > > handler = completionHandler ; completionHandler = ar - > { theEndHandler . handle ( null ) ; if ( handler != null ) { handler . handle ( ar ) ; } } ; } if ( registered ) { registered = false ; unregisterHandler ( address , this , completionHandler ) ; } else { callCompletionHandlerAsync ( completionHandler ) ; } registered = false ; } private synchronized void setResult ( AsyncResult < Void > result ) { this . result = result ; if ( completionHandler != null ) { if ( result . succeeded ( ) ) { metric = metrics . handlerRegistered ( address , replyHandler ) ; } Handler < AsyncResult < Void > > callback = completionHandler ; vertx . runOnContext ( v - > callback . handle ( result ) ) ; } else if ( result . failed ( ) ) { log . error ( "Failed to propagate registration for handler " + handler + " and address " + address ) ; } else { metric = metrics . handlerRegistered ( address , replyHandler ) ; } } @ Override public synchronized void handle ( Message < T > event ) { if ( paused ) { if ( pending . size ( ) < maxBufferedMessages ) { pending . add ( event ) ; } else { if ( discardHandler != null ) { discardHandler . handle ( event ) ; } } } else { checkNextTick ( ) ; MessageImpl abc = ( MessageImpl ) event ; metrics . beginHandleMessage ( metric , abc . getSocket ( ) == null ) ; try { handler . handle ( event ) ; metrics . endHandleMessage ( metric , null ) ; } catch ( Exception e ) { metrics . endHandleMessage ( metric , e ) ; throw e ; } } } public synchronized void discardHandler ( Handler < Message < T > > handler ) { this . discardHandler = handler ; } @ Override public synchronized MessageConsumer < T > handler ( Handler < Message < T > > handler ) { this . handler = handler ; if ( this . handler != null && ! registered ) { registered = true ; registerHandler ( address , this , replyHandler , localOnly , timeoutID ) ; } else if ( this . handler == null && registered ) { this . unregister ( ) ; } return this ; } @ Override public ReadStream < T > bodyStream ( ) { return new BodyReadStream < > ( this ) ; } @ Override public synchronized boolean isRegistered ( ) { return registered ; } @ Override public synchronized MessageConsumer < T > pause ( ) { if ( ! paused ) { paused = true ; } return this ; } @ Override public synchronized MessageConsumer < T > resume ( ) { if ( paused ) { paused = false ; checkNextTick ( ) ; } return this ; } @ Override public synchronized MessageConsumer < T > endHandler ( Handler < Void > endHandler ) { if ( endHandler != null ) { Context endCtx = vertx . getOrCreateContext ( ) ; this . endHandler = v1 - > endCtx . runOnContext ( v2 - > endHandler . handle ( null ) ) ; } else { this . endHandler = null ; } return this ; } @ Override public synchronized MessageConsumer < T > exceptionHandler ( Handler < Throwable > handler ) { return this ; } private void checkNextTick ( ) { if ( ! pending . isEmpty ( ) ) { vertx . runOnContext ( v - > { if ( ! paused ) { Message < T > message = pending . poll ( ) ; if ( message != null ) { HandlerRegistration . this . handle ( message ) ; } } } ) ; } } } public static class EventBusNetServer { private final NetServer netServer ; private Handler < NetSocket > handler ; public EventBusNetServer ( NetServer netServer ) { this . netServer = netServer ; netServer . connectHandler ( conn - > { synchronized ( EventBusNetServer . this ) { handler . handle ( conn ) ; } } ) ; } public synchronized void setHandler ( Handler < NetSocket > handler ) { this . handler = handler ; } } }
package io . vertx . test . core ; import io . netty . handler . codec . http . websocketx . WebSocketHandshakeException ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . Context ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Vertx ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . HttpClient ; import io . vertx . core . http . HttpClientOptions ; import io . vertx . core . http . HttpMethod ; import io . vertx . core . http . HttpServer ; import io . vertx . core . http . HttpServerOptions ; import io . vertx . core . http . HttpServerRequest ; import io . vertx . core . http . ServerWebSocket ; import io . vertx . core . http . ServerWebSocketStream ; import io . vertx . core . http . WebSocketBase ; import io . vertx . core . http . WebSocketFrame ; import io . vertx . core . http . WebSocketStream ; import io . vertx . core . http . WebsocketVersion ; import io . vertx . core . impl . ConcurrentHashSet ; import io . vertx . core . net . NetSocket ; import io . vertx . core . streams . ReadStream ; import org . junit . Test ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . ArrayList ; import java . util . Base64 ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . CompletableFuture ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import java . util . function . Consumer ; import static io . vertx . test . core . TestUtils . * ; public class WebsocketTest extends VertxTestBase { private HttpClient client ; private HttpServer server ; public void setUp ( ) throws Exception { super . setUp ( ) ; client = vertx . createHttpClient ( new HttpClientOptions ( ) ) ; } protected void tearDown ( ) throws Exception { client . close ( ) ; if ( server != null ) { CountDownLatch latch = new CountDownLatch ( 1 ) ; server . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; } super . tearDown ( ) ; } @ Test public void testRejectHybi00 ( ) throws Exception { testReject ( WebsocketVersion . V00 ) ; } @ Test public void testRejectHybi08 ( ) throws Exception { testReject ( WebsocketVersion . V08 ) ; } @ Test public void testWSBinaryHybi00 ( ) throws Exception { testWSFrames ( true , WebsocketVersion . V00 ) ; } @ Test public void testWSStringHybi00 ( ) throws Exception { testWSFrames ( false , WebsocketVersion . V00 ) ; } @ Test public void testWSBinaryHybi08 ( ) throws Exception { testWSFrames ( true , WebsocketVersion . V08 ) ; } @ Test public void testWSStringHybi08 ( ) throws Exception { testWSFrames ( false , WebsocketVersion . V08 ) ; } @ Test public void testWSBinaryHybi17 ( ) throws Exception { testWSFrames ( true , WebsocketVersion . V13 ) ; } @ Test public void testWSStringHybi17 ( ) throws Exception { testWSFrames ( false , WebsocketVersion . V13 ) ; } @ Test public void testWSStreamsHybi00 ( ) throws Exception { testWSWriteStream ( WebsocketVersion . V00 ) ; } @ Test public void testWSStreamsHybi08 ( ) throws Exception { testWSWriteStream ( WebsocketVersion . V08 ) ; } @ Test public void testWSStreamsHybi17 ( ) throws Exception { testWSWriteStream ( WebsocketVersion . V13 ) ; } @ Test public void testWriteFromConnectHybi00 ( ) throws Exception { testWriteFromConnectHandler ( WebsocketVersion . V00 ) ; } @ Test public void testWriteFromConnectHybi08 ( ) throws Exception { testWriteFromConnectHandler ( WebsocketVersion . V08 ) ; } @ Test public void testWriteFromConnectHybi17 ( ) throws Exception { testWriteFromConnectHandler ( WebsocketVersion . V13 ) ; } @ Test public void testContinuationWriteFromConnectHybi08 ( ) throws Exception { testContinuationWriteFromConnectHandler ( WebsocketVersion . V08 ) ; } @ Test public void testContinuationWriteFromConnectHybi17 ( ) throws Exception { testContinuationWriteFromConnectHandler ( WebsocketVersion . V13 ) ; } @ Test public void testValidSubProtocolHybi00 ( ) throws Exception { testValidSubProtocol ( WebsocketVersion . V00 ) ; } @ Test public void testValidSubProtocolHybi08 ( ) throws Exception { testValidSubProtocol ( WebsocketVersion . V08 ) ; } @ Test public void testValidSubProtocolHybi17 ( ) throws Exception { testValidSubProtocol ( WebsocketVersion . V13 ) ; } @ Test public void testInvalidSubProtocolHybi00 ( ) throws Exception { testInvalidSubProtocol ( WebsocketVersion . V00 ) ; } @ Test public void testInvalidSubProtocolHybi08 ( ) throws Exception { testInvalidSubProtocol ( WebsocketVersion . V08 ) ; } @ Test public void testInvalidSubProtocolHybi17 ( ) throws Exception { testInvalidSubProtocol ( WebsocketVersion . V13 ) ; } @ Test public void testTLSClientTrustAll ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . NONE , KeyCert . JKS , Trust . NONE , false , false , true , false , true ) ; } @ Test public void testTLSClientTrustServerCert ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . JKS , KeyCert . JKS , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertPKCS12 ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . JKS , KeyCert . PKCS12 , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertPEM ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . JKS , KeyCert . PEM , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertPEM_CA ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . PEM_CA , KeyCert . PEM_CA , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustPKCS12ServerCert ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . PKCS12 , KeyCert . JKS , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustPEMServerCert ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . PEM , KeyCert . JKS , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientUntrustedServer ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . NONE , KeyCert . JKS , Trust . NONE , false , false , false , false , false ) ; } @ Test public void testTLSClientCertNotRequired ( ) throws Exception { testTLS ( KeyCert . JKS , Trust . JKS , KeyCert . JKS , Trust . JKS , false , false , false , false , true ) ; } @ Test public void testTLSClientCertRequired ( ) throws Exception { testTLS ( KeyCert . JKS , Trust . JKS , KeyCert . JKS , Trust . JKS , true , false , false , false , true ) ; } @ Test public void testTLSClientCertRequiredPKCS12 ( ) throws Exception { testTLS ( KeyCert . JKS , Trust . JKS , KeyCert . JKS , Trust . PKCS12 , true , false , false , false , true ) ; } @ Test public void testTLSClientCertRequiredPEM ( ) throws Exception { testTLS ( KeyCert . JKS , Trust . JKS , KeyCert . JKS , Trust . PEM , true , false , false , false , true ) ; } @ Test public void testTLSClientCertPKCS12Required ( ) throws Exception { testTLS ( KeyCert . PKCS12 , Trust . JKS , KeyCert . JKS , Trust . JKS , true , false , false , false , true ) ; } @ Test public void testTLSClientCertPEMRequired ( ) throws Exception { testTLS ( KeyCert . PEM , Trust . JKS , KeyCert . JKS , Trust . JKS , true , false , false , false , true ) ; } @ Test public void testTLSClientCertPEM_CARequired ( ) throws Exception { testTLS ( KeyCert . PEM_CA , Trust . JKS , KeyCert . JKS , Trust . PEM_CA , true , false , false , false , true ) ; } @ Test public void testTLSClientCertRequiredNoClientCert ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . JKS , KeyCert . JKS , Trust . JKS , true , false , false , false , false ) ; } @ Test public void testTLSClientCertClientNotTrusted ( ) throws Exception { testTLS ( KeyCert . JKS , Trust . JKS , KeyCert . JKS , Trust . NONE , true , false , false , false , false ) ; } @ Test public void testTLSClientRevokedServerCert ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . PEM_CA , KeyCert . PEM_CA , Trust . NONE , false , false , false , true , false ) ; } @ Test public void testTLSRevokedClientCertServer ( ) throws Exception { testTLS ( KeyCert . PEM_CA , Trust . JKS , KeyCert . JKS , Trust . PEM_CA , true , true , false , false , false ) ; } @ Test public void testTLSCipherSuites ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . NONE , KeyCert . JKS , Trust . NONE , false , false , true , false , true , ENABLED_CIPHER_SUITES ) ; } private void testTLS ( KeyCert clientCert , Trust clientTrust , KeyCert serverCert , Trust serverTrust , boolean requireClientAuth , boolean serverUsesCrl , boolean clientTrustAll , boolean clientUsesCrl , boolean shouldPass , String ... enabledCipherSuites ) throws Exception { HttpClientOptions options = new HttpClientOptions ( ) ; options . setSsl ( true ) ; if ( clientTrustAll ) { options . setTrustAll ( true ) ; } if ( clientUsesCrl ) { options . addCrlPath ( findFileOnClasspath ( "tls/ca/crl.pem" ) ) ; } setOptions ( options , getClientTrustOptions ( clientTrust ) ) ; setOptions ( options , getClientCertOptions ( clientCert ) ) ; for ( String suite : enabledCipherSuites ) { options . addEnabledCipherSuite ( suite ) ; } client = vertx . createHttpClient ( options ) ; HttpServerOptions serverOptions = new HttpServerOptions ( ) ; serverOptions . setSsl ( true ) ; setOptions ( serverOptions , getServerTrustOptions ( serverTrust ) ) ; setOptions ( serverOptions , getServerCertOptions ( serverCert ) ) ; if ( requireClientAuth ) { serverOptions . setClientAuthRequired ( true ) ; } if ( serverUsesCrl ) { serverOptions . addCrlPath ( findFileOnClasspath ( "tls/ca/crl.pem" ) ) ; } for ( String suite : enabledCipherSuites ) { serverOptions . addEnabledCipherSuite ( suite ) ; } server = vertx . createHttpServer ( serverOptions . setPort ( 4043 ) ) ; server . websocketHandler ( ws - > { ws . handler ( ws : : write ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . websocketStream ( 4043 , HttpTestBase . DEFAULT_HTTP_HOST , "/" ) . exceptionHandler ( t - > { if ( shouldPass ) { t . printStackTrace ( ) ; fail ( "Should not throw exception" ) ; } else { testComplete ( ) ; } } ) . handler ( ws - > { int size = 100 ; Buffer received = Buffer . buffer ( ) ; ws . handler ( data - > { received . appendBuffer ( data ) ; if ( received . length ( ) == size ) { ws . close ( ) ; testComplete ( ) ; } } ) ; Buffer buff = Buffer . buffer ( TestUtils . randomByteArray ( size ) ) ; ws . writeFrame ( WebSocketFrame . binaryFrame ( buff , true ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testHandleWSManually ( ) throws Exception { String path = "/some/path" ; String message = "here is some text data" ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) . requestHandler ( req - > { NetSocket sock = getUpgradedNetSocket ( req , path ) ; Buffer buff = Buffer . buffer ( ) ; buff . appendByte ( ( byte ) 129 ) ; buff . appendByte ( ( byte ) message . length ( ) ) ; buff . appendString ( message ) ; sock . write ( buff ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . websocketStream ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path ) . exceptionHandler ( t - > fail ( t . getMessage ( ) ) ) . handler ( ws - > { ws . handler ( buff - > { assertEquals ( message , buff . toString ( "UTF-8" ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testSharedServersRoundRobin ( ) throws Exception { int numServers = 5 ; int numConnections = numServers * 100 ; List < HttpServer > servers = new ArrayList < > ( ) ; Set < HttpServer > connectedServers = new ConcurrentHashSet < > ( ) ; Map < HttpServer , Integer > connectCount = new ConcurrentHashMap < > ( ) ; CountDownLatch latchListen = new CountDownLatch ( numServers ) ; CountDownLatch latchConns = new CountDownLatch ( numConnections ) ; for ( int i = 0 ; i < numServers ; i ++ ) { HttpServer theServer = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; servers . add ( theServer ) ; theServer . websocketHandler ( ws - > { connectedServers . add ( theServer ) ; Integer cnt = connectCount . get ( theServer ) ; int icnt = cnt == null ? 0 : cnt ; icnt ++ ; connectCount . put ( theServer , icnt ) ; latchConns . countDown ( ) ; } ) . listen ( ar - > { if ( ar . succeeded ( ) ) { latchListen . countDown ( ) ; } else { fail ( "Failed to bind server" ) ; } } ) ; } assertTrue ( latchListen . await ( 10 , TimeUnit . SECONDS ) ) ; CountDownLatch latchClient = new CountDownLatch ( numConnections ) ; for ( int i = 0 ; i < numConnections ; i ++ ) { client . websocket ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , "/someuri" , ws - > { ws . closeHandler ( v - > latchClient . countDown ( ) ) ; ws . close ( ) ; } ) ; } assertTrue ( latchClient . await ( 10 , TimeUnit . SECONDS ) ) ; assertTrue ( latchConns . await ( 10 , TimeUnit . SECONDS ) ) ; assertEquals ( numServers , connectedServers . size ( ) ) ; for ( HttpServer server : servers ) { assertTrue ( connectedServers . contains ( server ) ) ; } assertEquals ( numServers , connectCount . size ( ) ) ; for ( int cnt : connectCount . values ( ) ) { assertEquals ( numConnections / numServers , cnt ) ; } CountDownLatch closeLatch = new CountDownLatch ( numServers ) ; for ( HttpServer server : servers ) { server . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; closeLatch . countDown ( ) ; } ) ; } assertTrue ( closeLatch . await ( 10 , TimeUnit . SECONDS ) ) ; testComplete ( ) ; } @ Test public void testSharedServersRoundRobinWithOtherServerRunningOnDifferentPort ( ) throws Exception { CountDownLatch latch = new CountDownLatch ( 1 ) ; HttpServer theServer = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( 4321 ) ) ; theServer . websocketHandler ( ws - > { fail ( "Should not connect" ) ; } ) . listen ( ar - > { if ( ar . succeeded ( ) ) { latch . countDown ( ) ; } else { fail ( "Failed to bind server" ) ; } } ) ; awaitLatch ( latch ) ; testSharedServersRoundRobin ( ) ; } @ Test public void testSharedServersRoundRobinButFirstStartAndStopServer ( ) throws Exception { CountDownLatch latch = new CountDownLatch ( 1 ) ; HttpServer theServer = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( 4321 ) ) ; theServer . websocketHandler ( ws - > { fail ( "Should not connect" ) ; } ) . listen ( ar - > { if ( ar . succeeded ( ) ) { latch . countDown ( ) ; } else { fail ( "Failed to bind server" ) ; } } ) ; awaitLatch ( latch ) ; CountDownLatch closeLatch = new CountDownLatch ( 1 ) ; theServer . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; closeLatch . countDown ( ) ; } ) ; assertTrue ( closeLatch . await ( 10 , TimeUnit . SECONDS ) ) ; testSharedServersRoundRobin ( ) ; } @ Test public void testWebsocketFrameFactoryArguments ( ) throws Exception { assertNullPointerException ( ( ) - > WebSocketFrame . binaryFrame ( null , true ) ) ; assertNullPointerException ( ( ) - > WebSocketFrame . textFrame ( null , true ) ) ; assertNullPointerException ( ( ) - > WebSocketFrame . continuationFrame ( null , true ) ) ; } private String sha1 ( String s ) { try { MessageDigest md = MessageDigest . getInstance ( "SHA1" ) ; byte [ ] bytes = md . digest ( s . getBytes ( "UTF-8" ) ) ; return Base64 . getEncoder ( ) . encodeToString ( bytes ) ; } catch ( Exception e ) { throw new InternalError ( "Failed to compute sha-1" ) ; } } private NetSocket getUpgradedNetSocket ( HttpServerRequest req , String path ) { assertEquals ( path , req . path ( ) ) ; assertEquals ( "Upgrade" , req . headers ( ) . get ( "Connection" ) ) ; NetSocket sock = req . netSocket ( ) ; String secHeader = req . headers ( ) . get ( "Sec-WebSocket-Key" ) ; String tmp = secHeader + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; String encoded = sha1 ( tmp ) ; sock . write ( "HTTP/1.1 101 Web Socket Protocol Handshake\r\n" + "Upgrade: WebSocket\r\n" + "Connection: Upgrade\r\n" + "Sec-WebSocket-Accept: " + encoded + "\r\n" + "\r\n" ) ; return sock ; } private void testWSWriteStream ( WebsocketVersion version ) throws Exception { String path = "/some/path" ; String query = "foo=bar&wibble=eek" ; String uri = path + "?" + query ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) . websocketHandler ( ws - > { assertEquals ( uri , ws . uri ( ) ) ; assertEquals ( path , ws . path ( ) ) ; assertEquals ( query , ws . query ( ) ) ; assertEquals ( "Upgrade" , ws . headers ( ) . get ( "Connection" ) ) ; ws . handler ( data - > ws . write ( data ) ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; int bsize = 100 ; int sends = 10 ; client . websocket ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path + "?" + query , null , version , ws - > { final Buffer received = Buffer . buffer ( ) ; ws . handler ( data - > { received . appendBuffer ( data ) ; if ( received . length ( ) == bsize * sends ) { ws . close ( ) ; testComplete ( ) ; } } ) ; final Buffer sent = Buffer . buffer ( ) ; for ( int i = 0 ; i < sends ; i ++ ) { Buffer buff = Buffer . buffer ( TestUtils . randomByteArray ( bsize ) ) ; ws . write ( buff ) ; sent . appendBuffer ( buff ) ; } } ) ; } ) ; await ( ) ; } private void testWSFrames ( boolean binary , WebsocketVersion version ) throws Exception { String path = "/some/path" ; String query = "foo=bar&wibble=eek" ; String uri = path + "?" + query ; int frames = version == WebsocketVersion . V00 ? 1 : 10 ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) . websocketHandler ( ws - > { assertEquals ( uri , ws . uri ( ) ) ; assertEquals ( path , ws . path ( ) ) ; assertEquals ( query , ws . query ( ) ) ; assertEquals ( "Upgrade" , ws . headers ( ) . get ( "Connection" ) ) ; AtomicInteger count = new AtomicInteger ( ) ; ws . frameHandler ( frame - > { if ( count . get ( ) == 0 ) { if ( binary ) { assertTrue ( frame . isBinary ( ) ) ; assertFalse ( frame . isText ( ) ) ; } else { assertFalse ( frame . isBinary ( ) ) ; assertTrue ( frame . isText ( ) ) ; } assertFalse ( frame . isContinuation ( ) ) ; } else { assertFalse ( frame . isBinary ( ) ) ; assertFalse ( frame . isText ( ) ) ; assertTrue ( frame . isContinuation ( ) ) ; } if ( count . get ( ) == frames - 1 ) { assertTrue ( frame . isFinal ( ) ) ; } else { assertFalse ( frame . isFinal ( ) ) ; } ws . writeFrame ( frame ) ; if ( count . incrementAndGet ( ) == frames ) { count . set ( 0 ) ; } } ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; int bsize = 100 ; int msgs = 10 ; client . websocket ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path + "?" + query , null , version , ws - > { final List < Buffer > sent = new ArrayList < > ( ) ; final List < Buffer > received = new ArrayList < > ( ) ; AtomicReference < Buffer > currentReceived = new AtomicReference < > ( Buffer . buffer ( ) ) ; ws . frameHandler ( frame - > { currentReceived . get ( ) . appendBuffer ( frame . binaryData ( ) ) ; if ( frame . isFinal ( ) ) { received . add ( currentReceived . get ( ) ) ; currentReceived . set ( Buffer . buffer ( ) ) ; } if ( received . size ( ) == msgs ) { int pos = 0 ; for ( Buffer rec : received ) { assertEquals ( rec , sent . get ( pos ++ ) ) ; } testComplete ( ) ; } } ) ; AtomicReference < Buffer > currentSent = new AtomicReference < > ( Buffer . buffer ( ) ) ; for ( int i = 0 ; i < msgs ; i ++ ) { for ( int j = 0 ; j < frames ; j ++ ) { Buffer buff ; WebSocketFrame frame ; if ( binary ) { buff = Buffer . buffer ( TestUtils . randomByteArray ( bsize ) ) ; if ( j == 0 ) { frame = WebSocketFrame . binaryFrame ( buff , false ) ; } else { frame = WebSocketFrame . continuationFrame ( buff , j == frames - 1 ) ; } } else { String str = TestUtils . randomAlphaString ( bsize ) ; buff = Buffer . buffer ( str ) ; if ( j == 0 ) { frame = WebSocketFrame . textFrame ( str , false ) ; } else { frame = WebSocketFrame . continuationFrame ( buff , j == frames - 1 ) ; } } currentSent . get ( ) . appendBuffer ( buff ) ; ws . writeFrame ( frame ) ; if ( j == frames - 1 ) { sent . add ( currentSent . get ( ) ) ; currentSent . set ( Buffer . buffer ( ) ) ; } } } } ) ; } ) ; await ( ) ; } @ Test public void testWriteFinalTextFrame ( ) throws Exception { testWriteFinalFrame ( false ) ; } @ Test public void testWriteFinalBinaryFrame ( ) throws Exception { testWriteFinalFrame ( true ) ; } private void testWriteFinalFrame ( boolean binary ) throws Exception { String text = TestUtils . randomUnicodeString ( 100 ) ; Buffer data = TestUtils . randomBuffer ( 100 ) ; Consumer < WebSocketFrame > frameConsumer = frame - > { if ( binary ) { assertTrue ( frame . isBinary ( ) ) ; assertFalse ( frame . isText ( ) ) ; assertEquals ( data , frame . binaryData ( ) ) ; } else { assertFalse ( frame . isBinary ( ) ) ; assertTrue ( frame . isText ( ) ) ; assertEquals ( text , frame . textData ( ) ) ; } assertTrue ( frame . isFinal ( ) ) ; } ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) . websocketHandler ( ws - > ws . frameHandler ( frame - > { frameConsumer . accept ( frame ) ; if ( binary ) { ws . writeFinalBinaryFrame ( frame . binaryData ( ) ) ; } else { ws . writeFinalTextFrame ( frame . textData ( ) ) ; } } ) ) ; server . listen ( onSuccess ( s - > client . websocket ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , "/" , ws - > { ws . frameHandler ( frame - > { frameConsumer . accept ( frame ) ; testComplete ( ) ; } ) ; if ( binary ) { ws . writeFinalBinaryFrame ( data ) ; } else { ws . writeFinalTextFrame ( text ) ; } } ) ) ) ; await ( ) ; } private void testContinuationWriteFromConnectHandler ( WebsocketVersion version ) throws Exception { String path = "/some/path" ; String firstFrame = "AAA" ; String continuationFrame = "BBB" ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) . requestHandler ( req - > { NetSocket sock = getUpgradedNetSocket ( req , path ) ; Buffer buff = Buffer . buffer ( ) ; buff . appendByte ( ( byte ) 0x01 ) ; buff . appendByte ( ( byte ) firstFrame . length ( ) ) ; buff . appendString ( firstFrame ) ; sock . write ( buff ) ; buff = Buffer . buffer ( ) ; buff . appendByte ( ( byte ) ( 0x00 | 0x80 ) ) ; buff . appendByte ( ( byte ) continuationFrame . length ( ) ) ; buff . appendString ( continuationFrame ) ; sock . write ( buff ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . websocket ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path , null , version , ws - > { AtomicBoolean receivedFirstFrame = new AtomicBoolean ( ) ; ws . frameHandler ( received - > { Buffer receivedBuffer = Buffer . buffer ( received . textData ( ) ) ; if ( ! received . isFinal ( ) ) { assertEquals ( firstFrame , receivedBuffer . toString ( ) ) ; receivedFirstFrame . set ( true ) ; } else if ( receivedFirstFrame . get ( ) && received . isFinal ( ) ) { assertEquals ( continuationFrame , receivedBuffer . toString ( ) ) ; ws . close ( ) ; testComplete ( ) ; } } ) ; } ) ; } ) ; await ( ) ; } private void testWriteFromConnectHandler ( WebsocketVersion version ) throws Exception { String path = "/some/path" ; Buffer buff = Buffer . buffer ( "AAA" ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) . websocketHandler ( ws - > { assertEquals ( path , ws . path ( ) ) ; ws . writeFrame ( WebSocketFrame . binaryFrame ( buff , true ) ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . websocket ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path , null , version , ws - > { Buffer received = Buffer . buffer ( ) ; ws . handler ( data - > { received . appendBuffer ( data ) ; if ( received . length ( ) == buff . length ( ) ) { assertEquals ( buff , received ) ; ws . close ( ) ; testComplete ( ) ; } } ) ; } ) ; } ) ; await ( ) ; } private void testValidSubProtocol ( WebsocketVersion version ) throws Exception { String path = "/some/path" ; String subProtocol = "myprotocol" ; Buffer buff = Buffer . buffer ( "AAA" ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) . setWebsocketSubProtocol ( subProtocol ) ) . websocketHandler ( ws - > { assertEquals ( path , ws . path ( ) ) ; ws . writeFrame ( WebSocketFrame . binaryFrame ( buff , true ) ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . websocket ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path , null , version , subProtocol , ws - > { final Buffer received = Buffer . buffer ( ) ; ws . handler ( data - > { received . appendBuffer ( data ) ; if ( received . length ( ) == buff . length ( ) ) { assertEquals ( buff , received ) ; ws . close ( ) ; testComplete ( ) ; } } ) ; } ) ; } ) ; await ( ) ; } private void testInvalidSubProtocol ( WebsocketVersion version ) throws Exception { String path = "/some/path" ; String subProtocol = "myprotocol" ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) . setWebsocketSubProtocol ( "invalid" ) ) . websocketHandler ( ws - > { } ) ; server . listen ( onSuccess ( ar - > { client . websocketStream ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path , null , version , subProtocol ) . exceptionHandler ( t - > { testComplete ( ) ; } ) . handler ( ws - > { } ) ; } ) ) ; await ( ) ; } private void testReject ( WebsocketVersion version ) throws Exception { String path = "/some/path" ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) . websocketHandler ( ws - > { assertEquals ( path , ws . path ( ) ) ; ws . reject ( ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . websocketStream ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path , null , version ) . exceptionHandler ( t - > testComplete ( ) ) . handler ( ws - > fail ( "Should not be called" ) ) ; } ) ; await ( ) ; } @ Test public void testWriteMessageHybi00 ( ) { testWriteMessage ( 256 , WebsocketVersion . V00 ) ; } @ Test public void testWriteFragmentedMessage1Hybi00 ( ) { testWriteMessage ( 65536 + 256 , WebsocketVersion . V00 ) ; } @ Test public void testWriteFragmentedMessage2Hybi00 ( ) { testWriteMessage ( 65536 + 65536 + 256 , WebsocketVersion . V00 ) ; } @ Test public void testWriteMessageHybi08 ( ) { testWriteMessage ( 256 , WebsocketVersion . V08 ) ; } @ Test public void testWriteFragmentedMessage1Hybi08 ( ) { testWriteMessage ( 65536 + 256 , WebsocketVersion . V08 ) ; } @ Test public void testWriteFragmentedMessage2Hybi08 ( ) { testWriteMessage ( 65536 + 65536 + 256 , WebsocketVersion . V08 ) ; } @ Test public void testWriteMessageHybi17 ( ) { testWriteMessage ( 256 , WebsocketVersion . V13 ) ; } @ Test public void testWriteFragmentedMessage1Hybi17 ( ) { testWriteMessage ( 65536 + 256 , WebsocketVersion . V13 ) ; } @ Test public void testWriteFragmentedMessage2Hybi17 ( ) { testWriteMessage ( 65536 + 65536 + 256 , WebsocketVersion . V13 ) ; } private void testWriteMessage ( int size , WebsocketVersion version ) { String path = "/some/path" ; byte [ ] expected = TestUtils . randomByteArray ( size ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) . websocketHandler ( ws - > { ws . writeBinaryMessage ( Buffer . buffer ( expected ) ) ; ws . close ( ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . websocket ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path , null , version , ws - > { Buffer actual = Buffer . buffer ( ) ; ws . handler ( actual : : appendBuffer ) ; ws . closeHandler ( v - > { assertArrayEquals ( expected , actual . getBytes ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testWebsocketPauseAndResume ( ) { client . close ( ) ; client = vertx . createHttpClient ( new HttpClientOptions ( ) . setConnectTimeout ( 1000 ) ) ; String path = "/some/path" ; this . server = vertx . createHttpServer ( new HttpServerOptions ( ) . setAcceptBacklog ( 1 ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; AtomicBoolean paused = new AtomicBoolean ( ) ; ReadStream < ServerWebSocket > stream = server . websocketStream ( ) ; stream . handler ( ws - > { assertFalse ( paused . get ( ) ) ; ws . writeBinaryMessage ( Buffer . buffer ( "whatever" ) ) ; ws . close ( ) ; } ) ; server . listen ( listenAR - > { assertTrue ( listenAR . succeeded ( ) ) ; stream . pause ( ) ; paused . set ( true ) ; client . websocketStream ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path ) . exceptionHandler ( err - > { assertTrue ( paused . get ( ) ) ; assertTrue ( err instanceof WebSocketHandshakeException ) ; paused . set ( false ) ; stream . resume ( ) ; client . websocket ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path , ws - > { ws . handler ( buffer - > { assertEquals ( "whatever" , buffer . toString ( "UTF-8" ) ) ; ws . closeHandler ( v2 - > { testComplete ( ) ; } ) ; } ) ; } ) ; } ) . handler ( ws - > fail ( ) ) ; } ) ; await ( ) ; } @ Test public void testClosingServerClosesWebSocketStreamEndHandler ( ) { this . server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; ReadStream < ServerWebSocket > stream = server . websocketStream ( ) ; AtomicBoolean closed = new AtomicBoolean ( ) ; stream . endHandler ( v - > closed . set ( true ) ) ; stream . handler ( ws - > { } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; assertFalse ( closed . get ( ) ) ; server . close ( v - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( closed . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testWebsocketStreamCallbackAsynchronously ( ) { this . server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; AtomicInteger done = new AtomicInteger ( ) ; ServerWebSocketStream stream = server . websocketStream ( ) ; stream . handler ( req - > { } ) ; ThreadLocal < Object > stack = new ThreadLocal < > ( ) ; stack . set ( true ) ; stream . endHandler ( v - > { assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; assertNull ( stack . get ( ) ) ; if ( done . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ) ; server . listen ( ar - > { assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; assertNull ( stack . get ( ) ) ; ThreadLocal < Object > stack2 = new ThreadLocal < > ( ) ; stack2 . set ( true ) ; server . close ( v - > { assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; assertNull ( stack2 . get ( ) ) ; if ( done . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ) ; stack2 . set ( null ) ; } ) ; await ( ) ; } @ Test public void testMultipleServerClose ( ) { this . server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; AtomicInteger times = new AtomicInteger ( ) ; ThreadLocal stack = new ThreadLocal ( ) ; stack . set ( true ) ; server . websocketStream ( ) . endHandler ( v - > { assertNull ( stack . get ( ) ) ; assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; times . incrementAndGet ( ) ; } ) ; server . close ( ar1 - > { assertNull ( stack . get ( ) ) ; assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; server . close ( ar2 - > { server . close ( ar3 - > { assertEquals ( 1 , times . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testEndHandlerCalled ( ) { String path = "/some/path" ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) . websocketHandler ( WebSocketBase : : close ) ; AtomicInteger doneCount = new AtomicInteger ( ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . websocketStream ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path , null ) . endHandler ( done - > doneCount . incrementAndGet ( ) ) . handler ( ws - > { assertEquals ( 0 , doneCount . get ( ) ) ; ws . closeHandler ( v - > { assertEquals ( 1 , doneCount . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testClearClientHandlersOnEnd ( ) { String path = "/some/path" ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) . websocketHandler ( WebSocketBase : : close ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . websocketStream ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path , null ) . handler ( ws - > { ws . endHandler ( v - > { try { ws . endHandler ( null ) ; ws . exceptionHandler ( null ) ; ws . handler ( null ) ; } catch ( Exception e ) { fail ( "Was expecting to set to null the handlers when the socket is closed" ) ; return ; } testComplete ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testUpgrade ( ) { testUpgrade ( false ) ; } @ Test public void testUpgradeDelayed ( ) { testUpgrade ( true ) ; } private void testUpgrade ( boolean delayed ) { String path = "/some/path" ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; server . requestHandler ( request - > { Runnable runner = ( ) - > { ServerWebSocket ws = request . upgrade ( ) ; ws . handler ( buff - > { ws . write ( Buffer . buffer ( "helloworld" ) ) ; ws . close ( ) ; } ) ; } ; if ( delayed ) { vertx . runOnContext ( v - > { runner . run ( ) ; } ) ; } else { runner . run ( ) ; } } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . websocketStream ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path , null ) . handler ( ws - > { Buffer buff = Buffer . buffer ( ) ; ws . handler ( b - > { buff . appendBuffer ( b ) ; } ) ; ws . endHandler ( v - > { assertEquals ( "helloworld" , buff . toString ( ) ) ; testComplete ( ) ; } ) ; ws . write ( Buffer . buffer ( "foo" ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testUpgradeInvalidRequest ( ) { server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; server . requestHandler ( request - > { try { request . upgrade ( ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { } testComplete ( ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . request ( HttpMethod . GET , HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , "/" , resp - > { } ) . end ( ) ; } ) ; await ( ) ; } @ Test public void testRaceConditionWithWebsocketClientEventLoop ( ) { testRaceConditionWithWebsocketClient ( vertx . getOrCreateContext ( ) ) ; } @ Test public void testRaceConditionWithWebsocketClientWorker ( ) throws Exception { CompletableFuture < Context > fut = new CompletableFuture < > ( ) ; vertx . deployVerticle ( new AbstractVerticle ( ) { @ Override public void start ( ) throws Exception { fut . complete ( context ) ; } } , new DeploymentOptions ( ) . setWorker ( true ) , ar - > { if ( ar . failed ( ) ) { fut . completeExceptionally ( ar . cause ( ) ) ; } } ) ; testRaceConditionWithWebsocketClient ( fut . get ( ) ) ; } private void testRaceConditionWithWebsocketClient ( Context context ) { server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; server . requestHandler ( req - > { byte [ ] accept ; try { MessageDigest digest = MessageDigest . getInstance ( "SHA-1" ) ; byte [ ] inputBytes = ( req . getHeader ( "Sec-WebSocket-Key" ) + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ) . getBytes ( ) ; digest . update ( inputBytes ) ; byte [ ] hashedBytes = digest . digest ( ) ; accept = Base64 . getEncoder ( ) . encode ( hashedBytes ) ; } catch ( NoSuchAlgorithmException e ) { fail ( e . getMessage ( ) ) ; return ; } NetSocket so = req . netSocket ( ) ; Buffer data = Buffer . buffer ( ) ; data . appendString ( "HTTP/1.1 101 Switching Protocols\r\n" ) ; data . appendString ( "Upgrade: websocket\r\n" ) ; data . appendString ( "Connection: Upgrade\r\n" ) ; data . appendString ( "Sec-WebSocket-Accept: " + new String ( accept ) + "\r\n" ) ; data . appendString ( "\r\n" ) ; data . appendBytes ( new byte [ ] { ( byte ) 0x82 , 0x05 , 0x68 , 0x65 , 0x6c , 0x6c , 0x6f , } ) ; so . write ( data ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; context . runOnContext ( v - > { client . websocket ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , "/" , ws - > { ws . handler ( buf - > { assertEquals ( "hello" , buf . toString ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testRaceConditionWithWebsocketClientWorker2 ( ) throws Exception { int size = getOptions ( ) . getWorkerPoolSize ( ) - 4 ; List < Context > workers = createWorkers ( size + 1 ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; server . websocketHandler ( ws - > { ws . write ( Buffer . buffer ( "hello" ) ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; workers . get ( 0 ) . runOnContext ( v - > { WebSocketStream webSocketStream = client . websocketStream ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , "/" ) ; webSocketStream . handler ( ws - > { ws . handler ( buf - > { assertEquals ( "hello" , buf . toString ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; } ) ; await ( ) ; } }
package io . vertx . core . eventbus . impl ; import io . vertx . core . Handler ; import io . vertx . core . eventbus . DeliveryOptions ; import io . vertx . core . eventbus . EventBus ; import io . vertx . core . eventbus . MessageProducer ; import io . vertx . core . streams . WriteStream ; public class MessageProducerImpl < T > implements MessageProducer < T > { private final EventBus bus ; private final boolean send ; private final String address ; private DeliveryOptions options ; public MessageProducerImpl ( EventBus bus , String address , boolean send , DeliveryOptions options ) { this . bus = bus ; this . address = address ; this . send = send ; this . options = options ; } @ Override public synchronized MessageProducer < T > deliveryOptions ( DeliveryOptions options ) { this . options = options ; return this ; } @ Override public MessageProducer < T > exceptionHandler ( Handler < Throwable > handler ) { return this ; } @ Override public MessageProducer < T > setWriteQueueMaxSize ( int maxSize ) { return this ; } @ Override public synchronized MessageProducer < T > write ( T data ) { if ( send ) { bus . send ( address , data , options ) ; } else { bus . publish ( address , data , options ) ; } return this ; } @ Override public boolean writeQueueFull ( ) { return false ; } @ Override public MessageProducer < T > drainHandler ( Handler < Void > handler ) { return this ; } @ Override public String address ( ) { return address ; } }
package io . vertx . core . eventbus . impl ; import io . vertx . core . Handler ; import io . vertx . core . eventbus . Message ; import io . vertx . core . streams . ReadStream ; public class BodyReadStream < T > implements ReadStream < T > { private ReadStream < Message < T > > delegate ; public BodyReadStream ( ReadStream < Message < T > > delegate ) { this . delegate = delegate ; } @ Override public ReadStream < T > exceptionHandler ( Handler < Throwable > handler ) { delegate . exceptionHandler ( handler ) ; return null ; } @ Override public ReadStream < T > handler ( Handler < T > handler ) { if ( handler != null ) { delegate . handler ( message - > handler . handle ( message . body ( ) ) ) ; } else { delegate . handler ( null ) ; } return this ; } @ Override public ReadStream < T > pause ( ) { delegate . pause ( ) ; return this ; } @ Override public ReadStream < T > resume ( ) { delegate . resume ( ) ; return this ; } @ Override public ReadStream < T > endHandler ( Handler < Void > endHandler ) { delegate . endHandler ( endHandler ) ; return this ; } }
package io . vertx . core . eventbus . impl ; import io . netty . util . CharsetUtil ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . DeliveryOptions ; import io . vertx . core . eventbus . Message ; import io . vertx . core . eventbus . MessageCodec ; import io . vertx . core . eventbus . ReplyException ; import io . vertx . core . eventbus . ReplyFailure ; import io . vertx . core . http . CaseInsensitiveHeaders ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . net . NetSocket ; import io . vertx . core . net . impl . ServerID ; import java . util . List ; import java . util . Map ; public class MessageImpl < U , V > implements Message < V > { private static final Logger log = LoggerFactory . getLogger ( MessageImpl . class ) ; private static final byte WIRE_PROTOCOL_VERSION = 1 ; private NetSocket socket ; private EventBusImpl bus ; private ServerID sender ; private String address ; private String replyAddress ; private MultiMap headers ; private U sentBody ; private V receivedBody ; private MessageCodec < U , V > messageCodec ; private boolean send ; private Buffer wireBuffer ; private int bodyPos ; private int headersPos ; public MessageImpl ( ) { } public MessageImpl ( ServerID sender , String address , String replyAddress , MultiMap headers , U sentBody , MessageCodec < U , V > messageCodec , boolean send ) { this . sender = sender ; this . address = address ; this . replyAddress = replyAddress ; this . headers = headers ; this . sentBody = sentBody ; this . messageCodec = messageCodec ; this . send = send ; } private MessageImpl ( MessageImpl < U , V > other ) { this . socket = other . socket ; this . bus = other . bus ; this . sender = other . sender ; this . address = other . address ; this . replyAddress = other . replyAddress ; this . messageCodec = other . messageCodec ; if ( other . headers != null ) { List < Map . Entry < String , String > > entries = other . headers . entries ( ) ; this . headers = new CaseInsensitiveHeaders ( ) ; for ( Map . Entry < String , String > entry : entries ) { this . headers . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } } if ( other . sentBody != null ) { this . sentBody = other . sentBody ; this . receivedBody = messageCodec . transform ( other . sentBody ) ; } else { this . wireBuffer = other . wireBuffer ; this . bodyPos = other . bodyPos ; this . headersPos = other . headersPos ; } this . send = other . send ; } NetSocket getSocket ( ) { return socket ; } public MessageImpl < U , V > copyBeforeReceive ( ) { return new MessageImpl < > ( this ) ; } @ Override public String address ( ) { return address ; } @ Override public MultiMap headers ( ) { if ( headers == null ) { if ( headersPos != 0 ) { decodeHeaders ( ) ; } if ( headers == null ) { headers = new CaseInsensitiveHeaders ( ) ; } } return headers ; } @ Override public V body ( ) { if ( receivedBody == null && bodyPos != 0 ) { decodeBody ( ) ; } return receivedBody ; } @ Override public String replyAddress ( ) { return replyAddress ; } public Buffer encodeToWire ( ) { int length = 1024 ; Buffer buffer = Buffer . buffer ( length ) ; buffer . appendInt ( 0 ) ; buffer . appendByte ( WIRE_PROTOCOL_VERSION ) ; byte systemCodecID = messageCodec . systemCodecID ( ) ; buffer . appendByte ( systemCodecID ) ; if ( systemCodecID == - 1 ) { writeString ( buffer , messageCodec . name ( ) ) ; } buffer . appendByte ( send ? ( byte ) 0 : ( byte ) 1 ) ; writeString ( buffer , address ) ; if ( replyAddress != null ) { writeString ( buffer , replyAddress ) ; } else { buffer . appendInt ( 0 ) ; } buffer . appendInt ( sender . port ) ; writeString ( buffer , sender . host ) ; encodeHeaders ( buffer ) ; writeBody ( buffer ) ; buffer . setInt ( 0 , buffer . length ( ) - 4 ) ; return buffer ; } public void readFromWire ( NetSocket socket , Buffer buffer , Map < String , MessageCodec > codecMap , MessageCodec [ ] systemCodecs ) { int pos = 0 ; byte protocolVersion = buffer . getByte ( pos ) ; if ( protocolVersion > WIRE_PROTOCOL_VERSION ) { throw new IllegalStateException ( "Invalid wire protocol version " + protocolVersion + " should be <= " + WIRE_PROTOCOL_VERSION ) ; } pos ++ ; byte systemCodecCode = buffer . getByte ( pos ) ; pos ++ ; if ( systemCodecCode == - 1 ) { int length = buffer . getInt ( pos ) ; pos += 4 ; byte [ ] bytes = buffer . getBytes ( pos , pos + length ) ; String codecName = new String ( bytes , CharsetUtil . UTF_8 ) ; messageCodec = codecMap . get ( codecName ) ; if ( messageCodec == null ) { throw new IllegalStateException ( "No message codec registered with name " + codecName ) ; } pos += length ; } else { messageCodec = systemCodecs [ systemCodecCode ] ; } byte bsend = buffer . getByte ( pos ) ; send = bsend == 0 ; pos ++ ; int length = buffer . getInt ( pos ) ; pos += 4 ; byte [ ] bytes = buffer . getBytes ( pos , pos + length ) ; address = new String ( bytes , CharsetUtil . UTF_8 ) ; pos += length ; length = buffer . getInt ( pos ) ; pos += 4 ; if ( length != 0 ) { bytes = buffer . getBytes ( pos , pos + length ) ; replyAddress = new String ( bytes , CharsetUtil . UTF_8 ) ; pos += length ; } int senderPort = buffer . getInt ( pos ) ; pos += 4 ; length = buffer . getInt ( pos ) ; pos += 4 ; bytes = buffer . getBytes ( pos , pos + length ) ; String senderHost = new String ( bytes , CharsetUtil . UTF_8 ) ; pos += length ; headersPos = pos ; int headersLength = buffer . getInt ( pos ) ; pos += headersLength ; bodyPos = pos ; sender = new ServerID ( senderPort , senderHost ) ; wireBuffer = buffer ; this . socket = socket ; } private void decodeBody ( ) { receivedBody = messageCodec . decodeFromWire ( bodyPos , wireBuffer ) ; bodyPos = 0 ; } private void encodeHeaders ( Buffer buffer ) { if ( headers != null && ! headers . isEmpty ( ) ) { int headersLengthPos = buffer . length ( ) ; buffer . appendInt ( 0 ) ; buffer . appendInt ( headers . size ( ) ) ; List < Map . Entry < String , String > > entries = headers . entries ( ) ; for ( Map . Entry < String , String > entry : entries ) { writeString ( buffer , entry . getKey ( ) ) ; writeString ( buffer , entry . getValue ( ) ) ; } int headersEndPos = buffer . length ( ) ; buffer . setInt ( headersLengthPos , headersEndPos - headersLengthPos ) ; } else { buffer . appendInt ( 4 ) ; } } private void decodeHeaders ( ) { int length = wireBuffer . getInt ( headersPos ) ; if ( length != 4 ) { headersPos += 4 ; int numHeaders = wireBuffer . getInt ( headersPos ) ; headersPos += 4 ; headers = new CaseInsensitiveHeaders ( ) ; for ( int i = 0 ; i < numHeaders ; i ++ ) { int keyLength = wireBuffer . getInt ( headersPos ) ; headersPos += 4 ; byte [ ] bytes = wireBuffer . getBytes ( headersPos , headersPos + keyLength ) ; String key = new String ( bytes , CharsetUtil . UTF_8 ) ; headersPos += keyLength ; int valLength = wireBuffer . getInt ( headersPos ) ; headersPos += 4 ; bytes = wireBuffer . getBytes ( headersPos , headersPos + valLength ) ; String val = new String ( bytes , CharsetUtil . UTF_8 ) ; headersPos += valLength ; headers . add ( key , val ) ; } } headersPos = 0 ; } private void writeBody ( Buffer buff ) { messageCodec . encodeToWire ( buff , sentBody ) ; } private void writeString ( Buffer buff , String str ) { byte [ ] strBytes = str . getBytes ( CharsetUtil . UTF_8 ) ; buff . appendInt ( strBytes . length ) ; buff . appendBytes ( strBytes ) ; } @ Override public void fail ( int failureCode , String message ) { if ( replyAddress != null ) { sendReply ( bus . createMessage ( true , replyAddress , null , new ReplyException ( ReplyFailure . RECIPIENT_FAILURE , failureCode , message ) , null ) , null , null ) ; } } @ Override public void reply ( Object message ) { reply ( message , new DeliveryOptions ( ) , null ) ; } @ Override public < R > void reply ( Object message , Handler < AsyncResult < Message < R > > > replyHandler ) { reply ( message , new DeliveryOptions ( ) , replyHandler ) ; } @ Override public void reply ( Object message , DeliveryOptions options ) { reply ( message , options , null ) ; } @ Override public < R > void reply ( Object message , DeliveryOptions options , Handler < AsyncResult < Message < R > > > replyHandler ) { if ( replyAddress != null ) { sendReply ( bus . createMessage ( true , replyAddress , options . getHeaders ( ) , message , options . getCodecName ( ) ) , options , replyHandler ) ; } } protected void setReplyAddress ( String replyAddress ) { this . replyAddress = replyAddress ; } protected boolean send ( ) { return send ; } protected void setBus ( EventBusImpl eventBus ) { this . bus = eventBus ; } protected MessageCodec codec ( ) { return messageCodec ; } private < R > void sendReply ( MessageImpl msg , DeliveryOptions options , Handler < AsyncResult < Message < R > > > replyHandler ) { if ( bus != null && replyAddress != null ) { bus . sendReply ( sender , msg , options , replyHandler ) ; } } }
package io . vertx . core . eventbus . impl . codecs ; import io . netty . util . CharsetUtil ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; public class StringMessageCodec implements MessageCodec < String , String > { @ Override public void encodeToWire ( Buffer buffer , String s ) { byte [ ] strBytes = s . getBytes ( CharsetUtil . UTF_8 ) ; buffer . appendInt ( strBytes . length ) ; buffer . appendBytes ( strBytes ) ; } @ Override public String decodeFromWire ( int pos , Buffer buffer ) { int length = buffer . getInt ( pos ) ; pos += 4 ; byte [ ] bytes = buffer . getBytes ( pos , pos + length ) ; return new String ( bytes , CharsetUtil . UTF_8 ) ; } @ Override public String transform ( String s ) { return s ; } @ Override public String name ( ) { return "string" ; } @ Override public byte systemCodecID ( ) { return 9 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; public class ByteMessageCodec implements MessageCodec < Byte , Byte > { @ Override public void encodeToWire ( Buffer buffer , Byte b ) { buffer . appendByte ( b ) ; } @ Override public Byte decodeFromWire ( int pos , Buffer buffer ) { return buffer . getByte ( pos ) ; } @ Override public Byte transform ( Byte b ) { return b ; } @ Override public String name ( ) { return "byte" ; } @ Override public byte systemCodecID ( ) { return 2 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . netty . util . CharsetUtil ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; import io . vertx . core . eventbus . ReplyException ; import io . vertx . core . eventbus . ReplyFailure ; public class ReplyExceptionMessageCodec implements MessageCodec < ReplyException , ReplyException > { @ Override public void encodeToWire ( Buffer buffer , ReplyException body ) { buffer . appendByte ( ( byte ) body . failureType ( ) . toInt ( ) ) ; buffer . appendInt ( body . failureCode ( ) ) ; if ( body . getMessage ( ) == null ) { buffer . appendByte ( ( byte ) 0 ) ; } else { buffer . appendByte ( ( byte ) 1 ) ; byte [ ] encoded = body . getMessage ( ) . getBytes ( CharsetUtil . UTF_8 ) ; buffer . appendInt ( encoded . length ) ; buffer . appendBytes ( encoded ) ; } } @ Override public ReplyException decodeFromWire ( int pos , Buffer buffer ) { int i = ( int ) buffer . getByte ( pos ) ; ReplyFailure rf = ReplyFailure . fromInt ( i ) ; pos ++ ; int failureCode = buffer . getInt ( pos ) ; pos += 4 ; boolean isNull = buffer . getByte ( pos ) == ( byte ) 0 ; String message ; if ( ! isNull ) { pos ++ ; int strLength = buffer . getInt ( pos ) ; pos += 4 ; byte [ ] bytes = buffer . getBytes ( pos , pos + strLength ) ; message = new String ( bytes , CharsetUtil . UTF_8 ) ; } else { message = null ; } return new ReplyException ( rf , failureCode , message ) ; } @ Override public ReplyException transform ( ReplyException exception ) { return exception ; } @ Override public String name ( ) { return "replyexception" ; } @ Override public byte systemCodecID ( ) { return 15 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; public class ShortMessageCodec implements MessageCodec < Short , Short > { @ Override public void encodeToWire ( Buffer buffer , Short s ) { buffer . appendShort ( s ) ; } @ Override public Short decodeFromWire ( int pos , Buffer buffer ) { return buffer . getShort ( pos ) ; } @ Override public Short transform ( Short s ) { return s ; } @ Override public String name ( ) { return "short" ; } @ Override public byte systemCodecID ( ) { return 4 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; public class ByteArrayMessageCodec implements MessageCodec < byte [ ] , byte [ ] > { @ Override public void encodeToWire ( Buffer buffer , byte [ ] byteArray ) { buffer . appendInt ( byteArray . length ) ; buffer . appendBytes ( byteArray ) ; } @ Override public byte [ ] decodeFromWire ( int pos , Buffer buffer ) { int length = buffer . getInt ( pos ) ; pos += 4 ; return buffer . getBytes ( pos , pos + length ) ; } @ Override public byte [ ] transform ( byte [ ] bytes ) { byte [ ] copied = new byte [ bytes . length ] ; System . arraycopy ( bytes , 0 , copied , 0 , bytes . length ) ; return copied ; } @ Override public String name ( ) { return "bytearray" ; } @ Override public byte systemCodecID ( ) { return 12 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; public class FloatMessageCodec implements MessageCodec < Float , Float > { @ Override public void encodeToWire ( Buffer buffer , Float f ) { buffer . appendFloat ( f ) ; } @ Override public Float decodeFromWire ( int pos , Buffer buffer ) { return buffer . getFloat ( pos ) ; } @ Override public Float transform ( Float f ) { return f ; } @ Override public String name ( ) { return "float" ; } @ Override public byte systemCodecID ( ) { return 7 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; public class PingMessageCodec implements MessageCodec < String , String > { @ Override public void encodeToWire ( Buffer buffer , String s ) { } @ Override public String decodeFromWire ( int pos , Buffer buffer ) { return null ; } @ Override public String transform ( String s ) { return null ; } @ Override public String name ( ) { return "ping" ; } @ Override public byte systemCodecID ( ) { return 1 ; } }
package io . vertx . test . core ; import io . vertx . core . impl . IsolatingClassLoader ; import io . vertx . core . json . JsonObject ; import org . junit . Before ; import org . junit . Test ; import java . io . File ; import java . io . InputStream ; import java . net . URL ; import java . net . URLClassLoader ; import java . util . Collections ; import java . util . Enumeration ; import java . util . List ; import java . util . Scanner ; import static org . junit . Assert . * ; public class IsolatingClassLoaderTest { private String resourceName = "resource.json" ; private URL url1 ; private URL url2 ; private URL url3 ; private URLClassLoader ucl ; private IsolatingClassLoader icl ; @ Before public void setUp ( ) throws Exception { String basePath = "src/test/resources/icl" ; url1 = new File ( basePath , "pkg1" ) . toURI ( ) . toURL ( ) ; url2 = new File ( basePath , "pkg2" ) . toURI ( ) . toURL ( ) ; url3 = new File ( basePath , "pkg3" ) . toURI ( ) . toURL ( ) ; ucl = new URLClassLoader ( new URL [ ] { url2 , url3 } ) ; icl = new IsolatingClassLoader ( new URL [ ] { url1 } , ucl , null ) ; } @ Test public void testGetResource ( ) throws Exception { URL resource = ucl . getResource ( resourceName ) ; checkResource ( url2 , resource ) ; resource = icl . getResource ( resourceName ) ; checkResource ( url1 , resource ) ; } @ Test public void testGetResourceNull ( ) throws Exception { resourceName = "null_resource" ; URL resource = ucl . getResource ( resourceName ) ; assertNull ( resource ) ; resource = icl . getResource ( resourceName ) ; assertNull ( resource ) ; } @ Test public void testGetResources ( ) throws Exception { Enumeration < URL > resources = ucl . getResources ( resourceName ) ; List < URL > list = Collections . list ( resources ) ; assertEquals ( 2 , list . size ( ) ) ; checkResource ( url2 , list . get ( 0 ) ) ; checkResource ( url3 , list . get ( 1 ) ) ; resources = icl . getResources ( resourceName ) ; list = Collections . list ( resources ) ; assertEquals ( 3 , list . size ( ) ) ; checkResource ( url1 , list . get ( 0 ) ) ; checkResource ( url2 , list . get ( 1 ) ) ; checkResource ( url3 , list . get ( 2 ) ) ; } private void checkResource ( URL expected , URL resource ) throws Exception { assertEquals ( expected . toString ( ) + resourceName , resource . toString ( ) ) ; } @ Test public void testGetResourcesNull ( ) throws Exception { resourceName = "null_resource" ; Enumeration < URL > resources = ucl . getResources ( resourceName ) ; List < URL > list = Collections . list ( resources ) ; assertEquals ( 0 , list . size ( ) ) ; resources = icl . getResources ( resourceName ) ; list = Collections . list ( resources ) ; assertEquals ( 0 , list . size ( ) ) ; } @ Test public void testGetResourceAsStream ( ) throws Exception { testGetResourceAsStream ( 2 , ucl ) ; testGetResourceAsStream ( 1 , icl ) ; } private void testGetResourceAsStream ( long ver , ClassLoader cl ) throws Exception { try ( InputStream is = cl . getResourceAsStream ( resourceName ) ) { assertNotNull ( is ) ; try ( Scanner scanner = new Scanner ( is , "UTF-8" ) . useDelimiter ( "\\A" ) ) { assertTrue ( scanner . hasNext ( ) ) ; JsonObject json = new JsonObject ( scanner . next ( ) ) ; assertEquals ( ver , json . getLong ( "ver" , - 1L ) . longValue ( ) ) ; } } } }
package io . vertx . core . eventbus . impl . codecs ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; public class NullMessageCodec implements MessageCodec < String , String > { @ Override public void encodeToWire ( Buffer buffer , String s ) { } @ Override public String decodeFromWire ( int pos , Buffer buffer ) { return null ; } @ Override public String transform ( String s ) { return null ; } @ Override public String name ( ) { return "null" ; } @ Override public byte systemCodecID ( ) { return 0 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . netty . util . CharsetUtil ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; import io . vertx . core . json . JsonObject ; public class JsonObjectMessageCodec implements MessageCodec < JsonObject , JsonObject > { @ Override public void encodeToWire ( Buffer buffer , JsonObject jsonObject ) { String strJson = jsonObject . encode ( ) ; byte [ ] encoded = strJson . getBytes ( CharsetUtil . UTF_8 ) ; buffer . appendInt ( encoded . length ) ; Buffer buff = Buffer . buffer ( encoded ) ; buffer . appendBuffer ( buff ) ; } @ Override public JsonObject decodeFromWire ( int pos , Buffer buffer ) { int length = buffer . getInt ( pos ) ; pos += 4 ; byte [ ] encoded = buffer . getBytes ( pos , pos + length ) ; String str = new String ( encoded , CharsetUtil . UTF_8 ) ; return new JsonObject ( str ) ; } @ Override public JsonObject transform ( JsonObject jsonObject ) { return jsonObject . copy ( ) ; } @ Override public String name ( ) { return "jsonobject" ; } @ Override public byte systemCodecID ( ) { return 13 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; public class BufferMessageCodec implements MessageCodec < Buffer , Buffer > { @ Override public void encodeToWire ( Buffer buffer , Buffer b ) { buffer . appendInt ( b . length ( ) ) ; buffer . appendBuffer ( b ) ; } @ Override public Buffer decodeFromWire ( int pos , Buffer buffer ) { int length = buffer . getInt ( pos ) ; pos += 4 ; return buffer . getBuffer ( pos , pos + length ) ; } @ Override public Buffer transform ( Buffer b ) { return b . copy ( ) ; } @ Override public String name ( ) { return "buffer" ; } @ Override public byte systemCodecID ( ) { return 11 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; public class CharMessageCodec implements MessageCodec < Character , Character > { @ Override public void encodeToWire ( Buffer buffer , Character chr ) { buffer . appendShort ( ( short ) chr . charValue ( ) ) ; } @ Override public Character decodeFromWire ( int pos , Buffer buffer ) { return ( char ) buffer . getShort ( pos ) ; } @ Override public Character transform ( Character c ) { return c ; } @ Override public String name ( ) { return "char" ; } @ Override public byte systemCodecID ( ) { return 10 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; public class IntMessageCodec implements MessageCodec < Integer , Integer > { @ Override public void encodeToWire ( Buffer buffer , Integer i ) { buffer . appendInt ( i ) ; } @ Override public Integer decodeFromWire ( int pos , Buffer buffer ) { return buffer . getInt ( pos ) ; } @ Override public Integer transform ( Integer i ) { return i ; } @ Override public String name ( ) { return "int" ; } @ Override public byte systemCodecID ( ) { return 5 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; public class LongMessageCodec implements MessageCodec < Long , Long > { @ Override public void encodeToWire ( Buffer buffer , Long l ) { buffer . appendLong ( l ) ; } @ Override public Long decodeFromWire ( int pos , Buffer buffer ) { return buffer . getLong ( pos ) ; } @ Override public Long transform ( Long l ) { return l ; } @ Override public String name ( ) { return "long" ; } @ Override public byte systemCodecID ( ) { return 6 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; public class DoubleMessageCodec implements MessageCodec < Double , Double > { @ Override public void encodeToWire ( Buffer buffer , Double d ) { buffer . appendDouble ( d ) ; } @ Override public Double decodeFromWire ( int pos , Buffer buffer ) { return buffer . getDouble ( pos ) ; } @ Override public Double transform ( Double d ) { return d ; } @ Override public String name ( ) { return "double" ; } @ Override public byte systemCodecID ( ) { return 8 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; public class BooleanMessageCodec implements MessageCodec < Boolean , Boolean > { @ Override public void encodeToWire ( Buffer buffer , Boolean b ) { buffer . appendByte ( ( byte ) ( b ? 0 : 1 ) ) ; } @ Override public Boolean decodeFromWire ( int pos , Buffer buffer ) { return buffer . getByte ( pos ) == 0 ; } @ Override public Boolean transform ( Boolean b ) { return b ; } @ Override public String name ( ) { return "boolean" ; } @ Override public byte systemCodecID ( ) { return 3 ; } }
package io . vertx . core . eventbus . impl . codecs ; import io . netty . util . CharsetUtil ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageCodec ; import io . vertx . core . json . JsonArray ; public class JsonArrayMessageCodec implements MessageCodec < JsonArray , JsonArray > { @ Override public void encodeToWire ( Buffer buffer , JsonArray jsonArray ) { String strJson = jsonArray . encode ( ) ; byte [ ] encoded = strJson . getBytes ( CharsetUtil . UTF_8 ) ; buffer . appendInt ( encoded . length ) ; Buffer buff = Buffer . buffer ( encoded ) ; buffer . appendBuffer ( buff ) ; } @ Override public JsonArray decodeFromWire ( int pos , Buffer buffer ) { int length = buffer . getInt ( pos ) ; pos += 4 ; byte [ ] encoded = buffer . getBytes ( pos , pos + length ) ; String str = new String ( encoded , CharsetUtil . UTF_8 ) ; return new JsonArray ( str ) ; } @ Override public JsonArray transform ( JsonArray jsonArray ) { return jsonArray . copy ( ) ; } @ Override public String name ( ) { return "jsonarray" ; } @ Override public byte systemCodecID ( ) { return 14 ; } }
@ Document ( fileName = "filesystem.adoc" ) package io . vertx . core . file ; import io . vertx . docgen . Document ;
package io . vertx . test . core ; enum Trust { NONE , JKS , PKCS12 , PEM , JKS_CA , PKCS12_CA , PEM_CA }
package io . vertx . core . file ; import io . vertx . codegen . annotations . VertxGen ; @ VertxGen public interface FileProps { long creationTime ( ) ; long lastAccessTime ( ) ; long lastModifiedTime ( ) ; boolean isDirectory ( ) ; boolean isOther ( ) ; boolean isRegularFile ( ) ; boolean isSymbolicLink ( ) ; long size ( ) ; }
package io . vertx . core . file ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . json . JsonObject ; @ DataObject public class OpenOptions { public static final String DEFAULT_PERMS = null ; public static final boolean DEFAULT_READ = true ; public static final boolean DEFAULT_WRITE = true ; public static final boolean DEFAULT_CREATE = true ; public static final boolean DEFAULT_CREATENEW = false ; public static final boolean DEFAULT_DSYNC = false ; public static final boolean DEFAULT_SYNC = false ; public static final boolean DEFAULT_DELETEONCLOSE = false ; public static final boolean DEFAULT_TRUNCATEEXISTING = false ; public static final boolean DEFAULT_SPARSE = false ; private String perms = DEFAULT_PERMS ; private boolean read = DEFAULT_READ ; private boolean write = DEFAULT_WRITE ; private boolean create = DEFAULT_CREATE ; private boolean createNew = DEFAULT_CREATENEW ; private boolean dsync = DEFAULT_DSYNC ; private boolean sync = DEFAULT_SYNC ; private boolean deleteOnClose = DEFAULT_DELETEONCLOSE ; private boolean truncateExisting = DEFAULT_TRUNCATEEXISTING ; private boolean sparse = DEFAULT_SPARSE ; public OpenOptions ( ) { super ( ) ; } public OpenOptions ( OpenOptions other ) { this . perms = other . perms ; this . read = other . read ; this . write = other . write ; this . create = other . create ; this . createNew = other . createNew ; this . dsync = other . dsync ; this . sync = other . sync ; this . deleteOnClose = other . deleteOnClose ; this . truncateExisting = other . truncateExisting ; this . sparse = other . sparse ; } public OpenOptions ( JsonObject json ) { this . perms = json . getString ( "perms" , DEFAULT_PERMS ) ; this . read = json . getBoolean ( "read" , DEFAULT_READ ) ; this . write = json . getBoolean ( "write" , DEFAULT_WRITE ) ; this . create = json . getBoolean ( "create" , DEFAULT_CREATE ) ; this . createNew = json . getBoolean ( "createNew" , DEFAULT_CREATENEW ) ; this . dsync = json . getBoolean ( "dsync" , DEFAULT_DSYNC ) ; this . sync = json . getBoolean ( "sync" , DEFAULT_SYNC ) ; this . deleteOnClose = json . getBoolean ( "deleteOnClose" , DEFAULT_DELETEONCLOSE ) ; this . truncateExisting = json . getBoolean ( "truncateExisting" , DEFAULT_TRUNCATEEXISTING ) ; this . sparse = json . getBoolean ( "sparse" , DEFAULT_SPARSE ) ; } public String getPerms ( ) { return perms ; } public OpenOptions setPerms ( String perms ) { this . perms = perms ; return this ; } public boolean isRead ( ) { return read ; } public OpenOptions setRead ( boolean read ) { this . read = read ; return this ; } public boolean isWrite ( ) { return write ; } public OpenOptions setWrite ( boolean write ) { this . write = write ; return this ; } public boolean isCreate ( ) { return create ; } public OpenOptions setCreate ( boolean create ) { this . create = create ; return this ; } public boolean isCreateNew ( ) { return createNew ; } public OpenOptions setCreateNew ( boolean createNew ) { this . createNew = createNew ; return this ; } public boolean isDeleteOnClose ( ) { return deleteOnClose ; } public OpenOptions setDeleteOnClose ( boolean deleteOnClose ) { this . deleteOnClose = deleteOnClose ; return this ; } public boolean isTruncateExisting ( ) { return truncateExisting ; } public OpenOptions setTruncateExisting ( boolean truncateExisting ) { this . truncateExisting = truncateExisting ; return this ; } public boolean isSparse ( ) { return sparse ; } public OpenOptions setSparse ( boolean sparse ) { this . sparse = sparse ; return this ; } public boolean isSync ( ) { return sync ; } public OpenOptions setSync ( boolean sync ) { this . sync = sync ; return this ; } public boolean isDSync ( ) { return dsync ; } public OpenOptions setDSync ( boolean dsync ) { this . dsync = dsync ; return this ; } }
package io . vertx . core . file ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . codegen . annotations . VertxGen ; import java . util . List ; @ VertxGen public interface FileSystem { @ Fluent FileSystem copy ( String from , String to , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem copyBlocking ( String from , String to ) ; @ Fluent FileSystem copyRecursive ( String from , String to , boolean recursive , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem copyRecursiveBlocking ( String from , String to , boolean recursive ) ; @ Fluent FileSystem move ( String from , String to , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem moveBlocking ( String from , String to ) ; @ Fluent FileSystem truncate ( String path , long len , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem truncateBlocking ( String path , long len ) ; @ Fluent FileSystem chmod ( String path , String perms , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem chmodBlocking ( String path , String perms ) ; @ Fluent FileSystem chmodRecursive ( String path , String perms , String dirPerms , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem chmodRecursiveBlocking ( String path , String perms , String dirPerms ) ; @ Fluent FileSystem chown ( String path , String user , String group , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem chownBlocking ( String path , String user , String group ) ; @ Fluent FileSystem props ( String path , Handler < AsyncResult < FileProps > > handler ) ; FileProps propsBlocking ( String path ) ; @ Fluent FileSystem lprops ( String path , Handler < AsyncResult < FileProps > > handler ) ; FileProps lpropsBlocking ( String path ) ; @ Fluent FileSystem link ( String link , String existing , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem linkBlocking ( String link , String existing ) ; @ Fluent FileSystem symlink ( String link , String existing , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem symlinkBlocking ( String link , String existing ) ; @ Fluent FileSystem unlink ( String link , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem unlinkBlocking ( String link ) ; @ Fluent FileSystem readSymlink ( String link , Handler < AsyncResult < String > > handler ) ; String readSymlinkBlocking ( String link ) ; @ Fluent FileSystem delete ( String path , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem deleteBlocking ( String path ) ; @ Fluent FileSystem deleteRecursive ( String path , boolean recursive , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem deleteRecursiveBlocking ( String path , boolean recursive ) ; @ Fluent FileSystem mkdir ( String path , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem mkdirBlocking ( String path ) ; @ Fluent FileSystem mkdir ( String path , String perms , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem mkdirBlocking ( String path , String perms ) ; @ Fluent FileSystem mkdirs ( String path , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem mkdirsBlocking ( String path ) ; @ Fluent FileSystem mkdirs ( String path , String perms , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem mkdirsBlocking ( String path , String perms ) ; @ Fluent FileSystem readDir ( String path , Handler < AsyncResult < List < String > > > handler ) ; List < String > readDirBlocking ( String path ) ; @ Fluent FileSystem readDir ( String path , String filter , Handler < AsyncResult < List < String > > > handler ) ; List < String > readDirBlocking ( String path , String filter ) ; @ Fluent FileSystem readFile ( String path , Handler < AsyncResult < Buffer > > handler ) ; Buffer readFileBlocking ( String path ) ; @ Fluent FileSystem writeFile ( String path , Buffer data , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem writeFileBlocking ( String path , Buffer data ) ; @ Fluent FileSystem open ( String path , OpenOptions options , Handler < AsyncResult < AsyncFile > > handler ) ; AsyncFile openBlocking ( String path , OpenOptions options ) ; @ Fluent FileSystem createFile ( String path , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem createFileBlocking ( String path ) ; @ Fluent FileSystem createFile ( String path , String perms , Handler < AsyncResult < Void > > handler ) ; @ Fluent FileSystem createFileBlocking ( String path , String perms ) ; @ Fluent FileSystem exists ( String path , Handler < AsyncResult < Boolean > > handler ) ; boolean existsBlocking ( String path ) ; @ Fluent FileSystem fsProps ( String path , Handler < AsyncResult < FileSystemProps > > handler ) ; FileSystemProps fsPropsBlocking ( String path ) ; }
package io . vertx . core . file ; import io . vertx . core . VertxException ; public class FileSystemException extends VertxException { public FileSystemException ( String message ) { super ( message ) ; } public FileSystemException ( String message , Throwable cause ) { super ( message , cause ) ; } public FileSystemException ( Throwable cause ) { super ( cause ) ; } }
package io . vertx . core . file ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . streams . ReadStream ; import io . vertx . core . streams . WriteStream ; @ VertxGen public interface AsyncFile extends ReadStream < Buffer > , WriteStream < Buffer > { @ Override AsyncFile handler ( Handler < Buffer > handler ) ; @ Override AsyncFile pause ( ) ; @ Override AsyncFile resume ( ) ; @ Override AsyncFile endHandler ( Handler < Void > endHandler ) ; @ Override AsyncFile write ( Buffer data ) ; @ Override AsyncFile setWriteQueueMaxSize ( int maxSize ) ; @ Override AsyncFile drainHandler ( Handler < Void > handler ) ; @ Override AsyncFile exceptionHandler ( Handler < Throwable > handler ) ; void close ( ) ; void close ( Handler < AsyncResult < Void > > handler ) ; @ Fluent AsyncFile write ( Buffer buffer , long position , Handler < AsyncResult < Void > > handler ) ; @ Fluent AsyncFile read ( Buffer buffer , int offset , long position , int length , Handler < AsyncResult < Buffer > > handler ) ; @ Fluent AsyncFile flush ( ) ; @ Fluent AsyncFile flush ( Handler < AsyncResult < Void > > handler ) ; @ Fluent AsyncFile setReadPos ( long readPos ) ; @ Fluent AsyncFile setWritePos ( long writePos ) ; }
package io . vertx . core . file ; import io . vertx . codegen . annotations . VertxGen ; @ VertxGen public interface FileSystemProps { long totalSpace ( ) ; long unallocatedSpace ( ) ; long usableSpace ( ) ; }
package io . vertx . core . file . impl ; import io . vertx . core . file . FileProps ; import java . nio . file . attribute . BasicFileAttributes ; public class FilePropsImpl implements FileProps { private final long creationTime ; private final long lastAccessTime ; private final long lastModifiedTime ; private final boolean isDirectory ; private final boolean isOther ; private final boolean isRegularFile ; private final boolean isSymbolicLink ; private final long size ; public FilePropsImpl ( BasicFileAttributes attrs ) { creationTime = attrs . creationTime ( ) . toMillis ( ) ; lastModifiedTime = attrs . lastModifiedTime ( ) . toMillis ( ) ; lastAccessTime = attrs . lastAccessTime ( ) . toMillis ( ) ; isDirectory = attrs . isDirectory ( ) ; isOther = attrs . isOther ( ) ; isRegularFile = attrs . isRegularFile ( ) ; isSymbolicLink = attrs . isSymbolicLink ( ) ; size = attrs . size ( ) ; } @ Override public long creationTime ( ) { return creationTime ; } @ Override public long lastAccessTime ( ) { return lastAccessTime ; } @ Override public long lastModifiedTime ( ) { return lastModifiedTime ; } @ Override public boolean isDirectory ( ) { return isDirectory ; } @ Override public boolean isOther ( ) { return isOther ; } @ Override public boolean isRegularFile ( ) { return isRegularFile ; } @ Override public boolean isSymbolicLink ( ) { return isSymbolicLink ; } @ Override public long size ( ) { return size ; } }
package io . vertx . core . file . impl ; import io . vertx . core . file . FileSystemProps ; public class FileSystemPropsImpl implements FileSystemProps { private final long totalSpace ; private final long unallocatedSpace ; private final long usableSpace ; public FileSystemPropsImpl ( long totalSpace , long unallocatedSpace , long usableSpace ) { this . totalSpace = totalSpace ; this . unallocatedSpace = unallocatedSpace ; this . usableSpace = usableSpace ; } @ Override public long totalSpace ( ) { return totalSpace ; } @ Override public long unallocatedSpace ( ) { return unallocatedSpace ; } @ Override public long usableSpace ( ) { return usableSpace ; } }
package io . vertx . core . file . impl ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . file . AsyncFile ; import io . vertx . core . file . OpenOptions ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import java . util . Objects ; public class WindowsFileSystem extends FileSystemImpl { private static final Logger log = LoggerFactory . getLogger ( WindowsFileSystem . class ) ; public WindowsFileSystem ( final VertxInternal vertx ) { super ( vertx ) ; } private static void logInternal ( final String perms ) { if ( perms != null && log . isDebugEnabled ( ) ) { log . debug ( "You are running on Windows and POSIX style file permissions are not supported" ) ; } } @ Override protected BlockingAction < Void > chmodInternal ( String path , String perms , String dirPerms , Handler < AsyncResult < Void > > handler ) { Objects . requireNonNull ( path ) ; Objects . requireNonNull ( perms ) ; logInternal ( perms ) ; logInternal ( dirPerms ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "You are running on Windows and POSIX style file permissions are not supported!" ) ; } return new BlockingAction < Void > ( handler ) { @ Override public Void perform ( ) { return null ; } } ; } @ Override protected BlockingAction < Void > mkdirInternal ( String path , final String perms , final boolean createParents , Handler < AsyncResult < Void > > handler ) { logInternal ( perms ) ; return super . mkdirInternal ( path , null , createParents , handler ) ; } @ Override protected AsyncFile doOpen ( String path , OpenOptions options , ContextImpl context ) { logInternal ( options . getPerms ( ) ) ; return new AsyncFileImpl ( vertx , path , options , context ) ; } @ Override protected BlockingAction < Void > createFileInternal ( String p , final String perms , Handler < AsyncResult < Void > > handler ) { logInternal ( perms ) ; return super . createFileInternal ( p , null , handler ) ; } @ Override protected BlockingAction < Void > chownInternal ( String path , String user , String group , Handler < AsyncResult < Void > > handler ) { if ( group != null && log . isDebugEnabled ( ) ) { log . debug ( "You are running on Windows and POSIX style file ownership is not supported" ) ; } return super . chownInternal ( path , user , group , handler ) ; } }
package io . vertx . core . file . impl ; import io . netty . buffer . ByteBuf ; import io . vertx . core . AsyncResult ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . file . AsyncFile ; import io . vertx . core . file . FileSystemException ; import io . vertx . core . file . OpenOptions ; import io . vertx . core . impl . Arguments ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . channels . AsynchronousFileChannel ; import java . nio . file . OpenOption ; import java . nio . file . Path ; import java . nio . file . Paths ; import java . nio . file . StandardOpenOption ; import java . nio . file . attribute . FileAttribute ; import java . nio . file . attribute . PosixFilePermissions ; import java . util . HashSet ; import java . util . Objects ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; public class AsyncFileImpl implements AsyncFile { private static final Logger log = LoggerFactory . getLogger ( AsyncFile . class ) ; public static final int BUFFER_SIZE = 8192 ; private final VertxInternal vertx ; private final AsynchronousFileChannel ch ; private final ContextImpl context ; private boolean closed ; private Runnable closedDeferred ; private long writesOutstanding ; private Handler < Throwable > exceptionHandler ; private Handler < Void > drainHandler ; private long writePos ; private int maxWrites = 128 * 1024 ; private int lwm = maxWrites / 2 ; private boolean paused ; private Handler < Buffer > dataHandler ; private Handler < Void > endHandler ; private long readPos ; private boolean readInProgress ; AsyncFileImpl ( VertxInternal vertx , String path , OpenOptions options , ContextImpl context ) { if ( ! options . isRead ( ) && ! options . isWrite ( ) ) { throw new FileSystemException ( "Cannot open file for neither reading nor writing" ) ; } this . vertx = vertx ; Path file = Paths . get ( path ) ; HashSet < OpenOption > opts = new HashSet < > ( ) ; if ( options . isRead ( ) ) opts . add ( StandardOpenOption . READ ) ; if ( options . isWrite ( ) ) opts . add ( StandardOpenOption . WRITE ) ; if ( options . isCreate ( ) ) opts . add ( StandardOpenOption . CREATE ) ; if ( options . isCreateNew ( ) ) opts . add ( StandardOpenOption . CREATE_NEW ) ; if ( options . isSync ( ) ) opts . add ( StandardOpenOption . SYNC ) ; if ( options . isDSync ( ) ) opts . add ( StandardOpenOption . DSYNC ) ; if ( options . isDeleteOnClose ( ) ) opts . add ( StandardOpenOption . DELETE_ON_CLOSE ) ; if ( options . isSparse ( ) ) opts . add ( StandardOpenOption . SPARSE ) ; if ( options . isTruncateExisting ( ) ) opts . add ( StandardOpenOption . TRUNCATE_EXISTING ) ; try { if ( options . getPerms ( ) != null ) { FileAttribute < ? > attrs = PosixFilePermissions . asFileAttribute ( PosixFilePermissions . fromString ( options . getPerms ( ) ) ) ; ch = AsynchronousFileChannel . open ( file , opts , vertx . getWorkerPool ( ) , attrs ) ; } else { ch = AsynchronousFileChannel . open ( file , opts , vertx . getWorkerPool ( ) ) ; } } catch ( IOException e ) { throw new FileSystemException ( e ) ; } this . context = context ; } @ Override public void close ( ) { closeInternal ( null ) ; } @ Override public void close ( Handler < AsyncResult < Void > > handler ) { closeInternal ( handler ) ; } @ Override public synchronized AsyncFile read ( Buffer buffer , int offset , long position , int length , Handler < AsyncResult < Buffer > > handler ) { Objects . requireNonNull ( buffer , "buffer" ) ; Objects . requireNonNull ( handler , "handler" ) ; Arguments . require ( offset >= 0 , "offset must be >= 0" ) ; Arguments . require ( position >= 0 , "position must be >= 0" ) ; Arguments . require ( length >= 0 , "length must be >= 0" ) ; check ( ) ; ByteBuffer bb = ByteBuffer . allocate ( length ) ; doRead ( buffer , offset , bb , position , handler ) ; return this ; } @ Override public AsyncFile write ( Buffer buffer , long position , Handler < AsyncResult < Void > > handler ) { Objects . requireNonNull ( handler , "handler" ) ; return doWrite ( buffer , position , handler ) ; } private synchronized AsyncFile doWrite ( Buffer buffer , long position , Handler < AsyncResult < Void > > handler ) { Objects . requireNonNull ( buffer , "buffer" ) ; Arguments . require ( position >= 0 , "position must be >= 0" ) ; check ( ) ; Handler < AsyncResult < Void > > wrapped = ar - > { if ( ar . succeeded ( ) ) { checkContext ( ) ; checkDrained ( ) ; if ( writesOutstanding == 0 && closedDeferred != null ) { closedDeferred . run ( ) ; } if ( handler != null ) { handler . handle ( ar ) ; } } else { if ( handler != null ) { handler . handle ( ar ) ; } else { handleException ( ar . cause ( ) ) ; } } } ; ByteBuf buf = buffer . getByteBuf ( ) ; if ( buf . nioBufferCount ( ) > 1 ) { doWrite ( buf . nioBuffers ( ) , position , wrapped ) ; } else { ByteBuffer bb = buf . nioBuffer ( ) ; doWrite ( bb , position , bb . limit ( ) , wrapped ) ; } return this ; } @ Override public AsyncFile write ( Buffer buffer ) { int length = buffer . length ( ) ; doWrite ( buffer , writePos , null ) ; writePos += length ; return this ; } @ Override public synchronized AsyncFile setWriteQueueMaxSize ( int maxSize ) { Arguments . require ( maxSize >= 2 , "maxSize must be >= 2" ) ; check ( ) ; this . maxWrites = maxSize ; this . lwm = maxWrites / 2 ; return this ; } @ Override public synchronized boolean writeQueueFull ( ) { check ( ) ; return writesOutstanding >= maxWrites ; } @ Override public synchronized AsyncFile drainHandler ( Handler < Void > handler ) { check ( ) ; this . drainHandler = handler ; checkDrained ( ) ; return this ; } @ Override public synchronized AsyncFile exceptionHandler ( Handler < Throwable > handler ) { check ( ) ; this . exceptionHandler = handler ; return this ; } @ Override public synchronized AsyncFile handler ( Handler < Buffer > handler ) { check ( ) ; this . dataHandler = handler ; if ( dataHandler != null && ! paused && ! closed ) { doRead ( ) ; } return this ; } @ Override public synchronized AsyncFile endHandler ( Handler < Void > handler ) { check ( ) ; this . endHandler = handler ; return this ; } @ Override public synchronized AsyncFile pause ( ) { check ( ) ; paused = true ; return this ; } @ Override public synchronized AsyncFile resume ( ) { check ( ) ; if ( paused && ! closed ) { paused = false ; if ( dataHandler != null ) { doRead ( ) ; } } return this ; } @ Override public AsyncFile flush ( ) { doFlush ( null ) ; return this ; } @ Override public AsyncFile flush ( Handler < AsyncResult < Void > > handler ) { doFlush ( handler ) ; return this ; } @ Override public synchronized AsyncFile setReadPos ( long readPos ) { this . readPos = readPos ; return this ; } @ Override public synchronized AsyncFile setWritePos ( long writePos ) { this . writePos = writePos ; return this ; } private synchronized void checkDrained ( ) { if ( drainHandler != null && writesOutstanding <= lwm ) { Handler < Void > handler = drainHandler ; drainHandler = null ; handler . handle ( null ) ; } } private void handleException ( Throwable t ) { if ( exceptionHandler != null && t instanceof Exception ) { exceptionHandler . handle ( t ) ; } else { log . error ( "Unhandled exception" , t ) ; } } private synchronized void doWrite ( ByteBuffer [ ] buffers , long position , Handler < AsyncResult < Void > > handler ) { AtomicInteger cnt = new AtomicInteger ( ) ; AtomicBoolean sentFailure = new AtomicBoolean ( ) ; for ( ByteBuffer b : buffers ) { int limit = b . limit ( ) ; doWrite ( b , position , limit , ar - > { if ( ar . succeeded ( ) ) { if ( cnt . incrementAndGet ( ) == buffers . length ) { handler . handle ( ar ) ; } } else { if ( sentFailure . compareAndSet ( false , true ) ) { handler . handle ( ar ) ; } } } ) ; position += limit ; } } private synchronized void doRead ( ) { if ( ! readInProgress ) { readInProgress = true ; Buffer buff = Buffer . buffer ( BUFFER_SIZE ) ; read ( buff , 0 , readPos , BUFFER_SIZE , ar - > { if ( ar . succeeded ( ) ) { readInProgress = false ; Buffer buffer = ar . result ( ) ; if ( buffer . length ( ) == 0 ) { handleEnd ( ) ; } else { readPos += buffer . length ( ) ; handleData ( buffer ) ; if ( ! paused && dataHandler != null ) { doRead ( ) ; } } } else { handleException ( ar . cause ( ) ) ; } } ) ; } } private synchronized void handleData ( Buffer buffer ) { buffer ( buffer ) ; if ( dataHandler != null ) { checkContext ( ) ; } } private void buffer ( Buffer buffer ) { if ( dataHandler != null ) { dataHandler . handle ( buffer ) ; } } private synchronized void handleEnd ( ) { endHandlere ( ) ; if ( endHandler != null ) { checkContext ( ) ; } } private void endHandlere ( ) { if ( endHandler != null ) { endHandler . handle ( null ) ; } } private synchronized void doFlush ( Handler < AsyncResult < Void > > handler ) { checkClosed ( ) ; context . executeBlocking ( ( ) - > { try { ch . force ( false ) ; return null ; } catch ( IOException e ) { throw new FileSystemException ( e ) ; } } , handler ) ; } private void doWrite ( ByteBuffer buff , long position , long toWrite , Handler < AsyncResult < Void > > handler ) { if ( toWrite == 0 ) { throw new IllegalStateException ( "Cannot save zero bytes" ) ; } writesOutstanding += toWrite ; writeInternal ( buff , position , handler ) ; } private void writeInternal ( ByteBuffer buff , long position , Handler < AsyncResult < Void > > handler ) { ch . write ( buff , position , null , new java . nio . channels . CompletionHandler < Integer , Object > ( ) { public void completed ( Integer bytesWritten , Object attachment ) { long pos = position ; if ( buff . hasRemaining ( ) ) { pos += bytesWritten ; writeInternal ( buff , pos , handler ) ; } else { context . runOnContext ( ( v ) - > { writesOutstanding -= buff . limit ( ) ; handler . handle ( Future . succeededFuture ( ) ) ; } ) ; } } public void failed ( Throwable exc , Object attachment ) { if ( exc instanceof Exception ) { context . runOnContext ( ( v ) - > handler . handle ( Future . succeededFuture ( ) ) ) ; } else { log . error ( "Error occurred" , exc ) ; } } } ) ; } private void doRead ( Buffer writeBuff , int offset , ByteBuffer buff , long position , Handler < AsyncResult < Buffer > > handler ) { ch . read ( buff , position , null , new java . nio . channels . CompletionHandler < Integer , Object > ( ) { long pos = position ; private void done ( ) { context . runOnContext ( ( v ) - > { buff . flip ( ) ; writeBuff . setBytes ( offset , buff ) ; handler . handle ( Future . succeededFuture ( writeBuff ) ) ; } ) ; } public void completed ( Integer bytesRead , Object attachment ) { if ( bytesRead == - 1 ) { done ( ) ; } else if ( buff . hasRemaining ( ) ) { pos += bytesRead ; doRead ( writeBuff , offset , buff , pos , handler ) ; } else { done ( ) ; } } public void failed ( Throwable t , Object attachment ) { context . runOnContext ( ( v ) - > handler . handle ( Future . failedFuture ( t ) ) ) ; } } ) ; } private void check ( ) { checkClosed ( ) ; } private void checkClosed ( ) { if ( closed ) { throw new IllegalStateException ( "File handle is closed" ) ; } } private void checkContext ( ) { if ( ! vertx . getContext ( ) . equals ( context ) ) { throw new IllegalStateException ( "AsyncFile must only be used in the context that created it, expected: " + context + " actual " + vertx . getContext ( ) ) ; } } private void doClose ( Handler < AsyncResult < Void > > handler ) { Future < Void > res = res ( ) ; try { ch . close ( ) ; } catch ( IOException e ) { res . fail ( e ) ; } if ( handler != null ) { vertx . runOnContext ( v - > handler . handle ( res ) ) ; } } private Future < Void > res ( ) { Future < Void > res = Future . future ( ) ; res . complete ( null ) ; return res ; } private synchronized void closeInternal ( Handler < AsyncResult < Void > > handler ) { check ( ) ; closed = true ; if ( writesOutstanding == 0 ) { doClose ( handler ) ; } else { closedDeferred = ( ) - > doClose ( handler ) ; } } }
package io . vertx . test . core ; public class FileSystemFileResolverTest extends FileResolverTestBase { @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; webRoot = "webroot" ; } }
package io . vertx . core . file . impl ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . file . AsyncFile ; import io . vertx . core . file . FileProps ; import io . vertx . core . file . FileSystem ; import io . vertx . core . file . FileSystemException ; import io . vertx . core . file . FileSystemProps ; import io . vertx . core . file . OpenOptions ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . impl . Action ; import java . io . File ; import java . io . FilenameFilter ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . file . FileAlreadyExistsException ; import java . nio . file . FileStore ; import java . nio . file . FileVisitOption ; import java . nio . file . FileVisitResult ; import java . nio . file . Files ; import java . nio . file . LinkOption ; import java . nio . file . Path ; import java . nio . file . Paths ; import java . nio . file . SimpleFileVisitor ; import java . nio . file . attribute . BasicFileAttributes ; import java . nio . file . attribute . FileAttribute ; import java . nio . file . attribute . GroupPrincipal ; import java . nio . file . attribute . PosixFileAttributeView ; import java . nio . file . attribute . PosixFilePermission ; import java . nio . file . attribute . PosixFilePermissions ; import java . nio . file . attribute . UserPrincipal ; import java . nio . file . attribute . UserPrincipalLookupService ; import java . util . ArrayList ; import java . util . EnumSet ; import java . util . List ; import java . util . Objects ; import java . util . Set ; import java . util . regex . Pattern ; public class FileSystemImpl implements FileSystem { protected final VertxInternal vertx ; public FileSystemImpl ( VertxInternal vertx ) { this . vertx = vertx ; } public FileSystem copy ( String from , String to , Handler < AsyncResult < Void > > handler ) { copyInternal ( from , to , handler ) . run ( ) ; return this ; } public FileSystem copyBlocking ( String from , String to ) { copyInternal ( from , to , null ) . perform ( ) ; return this ; } public FileSystem copyRecursive ( String from , String to , boolean recursive , Handler < AsyncResult < Void > > handler ) { copyInternal ( from , to , recursive , handler ) . run ( ) ; return this ; } public FileSystem copyRecursiveBlocking ( String from , String to , boolean recursive ) { copyInternal ( from , to , recursive , null ) . perform ( ) ; return this ; } public FileSystem move ( String from , String to , Handler < AsyncResult < Void > > handler ) { moveInternal ( from , to , handler ) . run ( ) ; return this ; } public FileSystem moveBlocking ( String from , String to ) { moveInternal ( from , to , null ) . perform ( ) ; return this ; } public FileSystem truncate ( String path , long len , Handler < AsyncResult < Void > > handler ) { truncateInternal ( path , len , handler ) . run ( ) ; return this ; } public FileSystem truncateBlocking ( String path , long len ) { truncateInternal ( path , len , null ) . perform ( ) ; return this ; } public FileSystem chmod ( String path , String perms , Handler < AsyncResult < Void > > handler ) { chmodInternal ( path , perms , handler ) . run ( ) ; return this ; } public FileSystem chmodBlocking ( String path , String perms ) { chmodInternal ( path , perms , null ) . perform ( ) ; return this ; } public FileSystem chmodRecursive ( String path , String perms , String dirPerms , Handler < AsyncResult < Void > > handler ) { chmodInternal ( path , perms , dirPerms , handler ) . run ( ) ; return this ; } public FileSystem chmodRecursiveBlocking ( String path , String perms , String dirPerms ) { chmodInternal ( path , perms , dirPerms , null ) . perform ( ) ; return this ; } public FileSystem chown ( String path , String user , String group , Handler < AsyncResult < Void > > handler ) { chownInternal ( path , user , group , handler ) . run ( ) ; return this ; } public FileSystem chownBlocking ( String path , String user , String group ) { chownInternal ( path , user , group , null ) . perform ( ) ; return this ; } public FileSystem props ( String path , Handler < AsyncResult < FileProps > > handler ) { propsInternal ( path , handler ) . run ( ) ; return this ; } public FileProps propsBlocking ( String path ) { return propsInternal ( path , null ) . perform ( ) ; } public FileSystem lprops ( String path , Handler < AsyncResult < FileProps > > handler ) { lpropsInternal ( path , handler ) . run ( ) ; return this ; } public FileProps lpropsBlocking ( String path ) { return lpropsInternal ( path , null ) . perform ( ) ; } public FileSystem link ( String link , String existing , Handler < AsyncResult < Void > > handler ) { linkInternal ( link , existing , handler ) . run ( ) ; return this ; } public FileSystem linkBlocking ( String link , String existing ) { linkInternal ( link , existing , null ) . perform ( ) ; return this ; } public FileSystem symlink ( String link , String existing , Handler < AsyncResult < Void > > handler ) { symlinkInternal ( link , existing , handler ) . run ( ) ; return this ; } public FileSystem symlinkBlocking ( String link , String existing ) { symlinkInternal ( link , existing , null ) . perform ( ) ; return this ; } public FileSystem unlink ( String link , Handler < AsyncResult < Void > > handler ) { unlinkInternal ( link , handler ) . run ( ) ; return this ; } public FileSystem unlinkBlocking ( String link ) { unlinkInternal ( link , null ) . perform ( ) ; return this ; } public FileSystem readSymlink ( String link , Handler < AsyncResult < String > > handler ) { readSymlinkInternal ( link , handler ) . run ( ) ; return this ; } public String readSymlinkBlocking ( String link ) { return readSymlinkInternal ( link , null ) . perform ( ) ; } public FileSystem delete ( String path , Handler < AsyncResult < Void > > handler ) { deleteInternal ( path , handler ) . run ( ) ; return this ; } public FileSystem deleteBlocking ( String path ) { deleteInternal ( path , null ) . perform ( ) ; return this ; } public FileSystem deleteRecursive ( String path , boolean recursive , Handler < AsyncResult < Void > > handler ) { deleteInternal ( path , recursive , handler ) . run ( ) ; return this ; } public FileSystem deleteRecursiveBlocking ( String path , boolean recursive ) { deleteInternal ( path , recursive , null ) . perform ( ) ; return this ; } public FileSystem mkdir ( String path , Handler < AsyncResult < Void > > handler ) { mkdirInternal ( path , handler ) . run ( ) ; return this ; } public FileSystem mkdirBlocking ( String path ) { mkdirInternal ( path , null ) . perform ( ) ; return this ; } public FileSystem mkdirs ( String path , Handler < AsyncResult < Void > > handler ) { mkdirInternal ( path , true , handler ) . run ( ) ; return this ; } public FileSystem mkdirsBlocking ( String path ) { mkdirInternal ( path , true , null ) . perform ( ) ; return this ; } public FileSystem mkdir ( String path , String perms , Handler < AsyncResult < Void > > handler ) { mkdirInternal ( path , perms , handler ) . run ( ) ; return this ; } public FileSystem mkdirBlocking ( String path , String perms ) { mkdirInternal ( path , perms , null ) . perform ( ) ; return this ; } public FileSystem mkdirs ( String path , String perms , Handler < AsyncResult < Void > > handler ) { mkdirInternal ( path , perms , true , handler ) . run ( ) ; return this ; } public FileSystem mkdirsBlocking ( String path , String perms ) { mkdirInternal ( path , perms , true , null ) . perform ( ) ; return this ; } public FileSystem readDir ( String path , Handler < AsyncResult < List < String > > > handler ) { readDirInternal ( path , handler ) . run ( ) ; return this ; } public List < String > readDirBlocking ( String path ) { return readDirInternal ( path , null ) . perform ( ) ; } public FileSystem readDir ( String path , String filter , Handler < AsyncResult < List < String > > > handler ) { readDirInternal ( path , filter , handler ) . run ( ) ; return this ; } public List < String > readDirBlocking ( String path , String filter ) { return readDirInternal ( path , filter , null ) . perform ( ) ; } public FileSystem readFile ( String path , Handler < AsyncResult < Buffer > > handler ) { readFileInternal ( path , handler ) . run ( ) ; return this ; } public Buffer readFileBlocking ( String path ) { return readFileInternal ( path , null ) . perform ( ) ; } public FileSystem writeFile ( String path , Buffer data , Handler < AsyncResult < Void > > handler ) { writeFileInternal ( path , data , handler ) . run ( ) ; return this ; } public FileSystem writeFileBlocking ( String path , Buffer data ) { writeFileInternal ( path , data , null ) . perform ( ) ; return this ; } public FileSystem open ( String path , OpenOptions options , Handler < AsyncResult < AsyncFile > > handler ) { openInternal ( path , options , handler ) . run ( ) ; return this ; } public AsyncFile openBlocking ( String path , OpenOptions options ) { return openInternal ( path , options , null ) . perform ( ) ; } public FileSystem createFile ( String path , Handler < AsyncResult < Void > > handler ) { createFileInternal ( path , handler ) . run ( ) ; return this ; } public FileSystem createFileBlocking ( String path ) { createFileInternal ( path , null ) . perform ( ) ; return this ; } public FileSystem createFile ( String path , String perms , Handler < AsyncResult < Void > > handler ) { createFileInternal ( path , perms , handler ) . run ( ) ; return this ; } public FileSystem createFileBlocking ( String path , String perms ) { createFileInternal ( path , perms , null ) . perform ( ) ; return this ; } public FileSystem exists ( String path , Handler < AsyncResult < Boolean > > handler ) { existsInternal ( path , handler ) . run ( ) ; return this ; } public boolean existsBlocking ( String path ) { return existsInternal ( path , null ) . perform ( ) ; } public FileSystem fsProps ( String path , Handler < AsyncResult < FileSystemProps > > handler ) { fsPropsInternal ( path , handler ) . run ( ) ; return this ; } public FileSystemProps fsPropsBlocking ( String path ) { return fsPropsInternal ( path , null ) . perform ( ) ; } private BlockingAction < Void > copyInternal ( String from , String to , Handler < AsyncResult < Void > > handler ) { return copyInternal ( from , to , false , handler ) ; } private BlockingAction < Void > copyInternal ( String from , String to , boolean recursive , Handler < AsyncResult < Void > > handler ) { Objects . requireNonNull ( from ) ; Objects . requireNonNull ( to ) ; return new BlockingAction < Void > ( handler ) { public Void perform ( ) { try { Path source = vertx . resolveFile ( from ) . toPath ( ) ; Path target = vertx . resolveFile ( to ) . toPath ( ) ; if ( recursive ) { Files . walkFileTree ( source , EnumSet . of ( FileVisitOption . FOLLOW_LINKS ) , Integer . MAX_VALUE , new SimpleFileVisitor < Path > ( ) { public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) throws IOException { Path targetDir = target . resolve ( source . relativize ( dir ) ) ; try { Files . copy ( dir , targetDir ) ; } catch ( FileAlreadyExistsException e ) { if ( ! Files . isDirectory ( targetDir ) ) { throw e ; } } return FileVisitResult . CONTINUE ; } @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . copy ( file , target . resolve ( source . relativize ( file ) ) ) ; return FileVisitResult . CONTINUE ; } } ) ; } else { Files . copy ( source , target ) ; } } catch ( IOException e ) { throw new FileSystemException ( e ) ; } return null ; } } ; } private BlockingAction < Void > moveInternal ( String from , String to , Handler < AsyncResult < Void > > handler ) { Objects . requireNonNull ( from ) ; Objects . requireNonNull ( to ) ; return new BlockingAction < Void > ( handler ) { public Void perform ( ) { try { Path source = vertx . resolveFile ( from ) . toPath ( ) ; Path target = vertx . resolveFile ( to ) . toPath ( ) ; Files . move ( source , target ) ; } catch ( IOException e ) { throw new FileSystemException ( e ) ; } return null ; } } ; } private BlockingAction < Void > truncateInternal ( String p , long len , Handler < AsyncResult < Void > > handler ) { Objects . requireNonNull ( p ) ; return new BlockingAction < Void > ( handler ) { public Void perform ( ) { RandomAccessFile raf = null ; try { String path = vertx . resolveFile ( p ) . getAbsolutePath ( ) ; if ( len < 0 ) { throw new FileSystemException ( "Cannot truncate file to size < 0" ) ; } if ( ! Files . exists ( Paths . get ( path ) ) ) { throw new FileSystemException ( "Cannot truncate file " + path + ". Does not exist" ) ; } try { raf = new RandomAccessFile ( path , "rw" ) ; raf . setLength ( len ) ; } finally { if ( raf != null ) raf . close ( ) ; } } catch ( IOException e ) { throw new FileSystemException ( e ) ; } return null ; } } ; } private BlockingAction < Void > chmodInternal ( String path , String perms , Handler < AsyncResult < Void > > handler ) { return chmodInternal ( path , perms , null , handler ) ; } protected BlockingAction < Void > chmodInternal ( String path , String perms , String dirPerms , Handler < AsyncResult < Void > > handler ) { Objects . requireNonNull ( path ) ; Set < PosixFilePermission > permissions = PosixFilePermissions . fromString ( perms ) ; Set < PosixFilePermission > dirPermissions = dirPerms == null ? null : PosixFilePermissions . fromString ( dirPerms ) ; return new BlockingAction < Void > ( handler ) { public Void perform ( ) { try { Path target = vertx . resolveFile ( path ) . toPath ( ) ; if ( dirPermissions != null ) { Files . walkFileTree ( target , new SimpleFileVisitor < Path > ( ) { public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) throws IOException { Files . setPosixFilePermissions ( dir , dirPermissions ) ; return FileVisitResult . CONTINUE ; } public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . setPosixFilePermissions ( file , permissions ) ; return FileVisitResult . CONTINUE ; } } ) ; } else { Files . setPosixFilePermissions ( target , permissions ) ; } } catch ( SecurityException e ) { throw new FileSystemException ( "Accessed denied for chmod on " + path ) ; } catch ( IOException e ) { throw new FileSystemException ( e ) ; } return null ; } } ; } protected BlockingAction < Void > chownInternal ( String path , String user , String group , Handler < AsyncResult < Void > > handler ) { Objects . requireNonNull ( path ) ; return new BlockingAction < Void > ( handler ) { public Void perform ( ) { try { Path target = vertx . resolveFile ( path ) . toPath ( ) ; UserPrincipalLookupService service = target . getFileSystem ( ) . getUserPrincipalLookupService ( ) ; UserPrincipal userPrincipal = user == null ? null : service . lookupPrincipalByName ( user ) ; GroupPrincipal groupPrincipal = group == null ? null : service . lookupPrincipalByGroupName ( group ) ; if ( groupPrincipal != null ) { PosixFileAttributeView view = Files . getFileAttributeView ( target , PosixFileAttributeView . class , LinkOption . NOFOLLOW_LINKS ) ; if ( view == null ) { throw new FileSystemException ( "Change group of file not supported" ) ; } view . setGroup ( groupPrincipal ) ; } if ( userPrincipal != null ) { Files . setOwner ( target , userPrincipal ) ; } } catch ( SecurityException e ) { throw new FileSystemException ( "Accessed denied for chown on " + path ) ; } catch ( IOException e ) { throw new FileSystemException ( e ) ; } return null ; } } ; } private BlockingAction < FileProps > propsInternal ( String path , Handler < AsyncResult < FileProps > > handler ) { return props ( path , true , handler ) ; } private BlockingAction < FileProps > lpropsInternal ( String path , Handler < AsyncResult < FileProps > > handler ) { return props ( path , false , handler ) ; } private BlockingAction < FileProps > props ( String path , boolean followLinks , Handler < AsyncResult < FileProps > > handler ) { Objects . requireNonNull ( path ) ; return new BlockingAction < FileProps > ( handler ) { public FileProps perform ( ) { try { Path target = vertx . resolveFile ( path ) . toPath ( ) ; BasicFileAttributes attrs ; if ( followLinks ) { attrs = Files . readAttributes ( target , BasicFileAttributes . class ) ; } else { attrs = Files . readAttributes ( target , BasicFileAttributes . class , LinkOption . NOFOLLOW_LINKS ) ; } return new FilePropsImpl ( attrs ) ; } catch ( IOException e ) { throw new FileSystemException ( e ) ; } } } ; } private BlockingAction < Void > linkInternal ( String link , String existing , Handler < AsyncResult < Void > > handler ) { return link ( link , existing , false , handler ) ; } private BlockingAction < Void > symlinkInternal ( String link , String existing , Handler < AsyncResult < Void > > handler ) { return link ( link , existing , true , handler ) ; } private BlockingAction < Void > link ( String link , String existing , boolean symbolic , Handler < AsyncResult < Void > > handler ) { Objects . requireNonNull ( link ) ; Objects . requireNonNull ( existing ) ; return new BlockingAction < Void > ( handler ) { public Void perform ( ) { try { Path source = vertx . resolveFile ( link ) . toPath ( ) ; Path target = vertx . resolveFile ( existing ) . toPath ( ) ; if ( symbolic ) { Files . createSymbolicLink ( source , target ) ; } else { Files . createLink ( source , target ) ; } } catch ( IOException e ) { throw new FileSystemException ( e ) ; } return null ; } } ; } private BlockingAction < Void > unlinkInternal ( String link , Handler < AsyncResult < Void > > handler ) { return deleteInternal ( link , handler ) ; } private BlockingAction < String > readSymlinkInternal ( String link , Handler < AsyncResult < String > > handler ) { Objects . requireNonNull ( link ) ; return new BlockingAction < String > ( handler ) { public String perform ( ) { try { Path source = vertx . resolveFile ( link ) . toPath ( ) ; return Files . readSymbolicLink ( source ) . toString ( ) ; } catch ( IOException e ) { throw new FileSystemException ( e ) ; } } } ; } private BlockingAction < Void > deleteInternal ( String path , Handler < AsyncResult < Void > > handler ) { return deleteInternal ( path , false , handler ) ; } private BlockingAction < Void > deleteInternal ( String path , boolean recursive , Handler < AsyncResult < Void > > handler ) { Objects . requireNonNull ( path ) ; return new BlockingAction < Void > ( handler ) { public Void perform ( ) { try { Path source = vertx . resolveFile ( path ) . toPath ( ) ; if ( recursive ) { Files . walkFileTree ( source , new SimpleFileVisitor < Path > ( ) { public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } public FileVisitResult postVisitDirectory ( Path dir , IOException e ) throws IOException { if ( e == null ) { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } else { throw e ; } } } ) ; } else { Files . delete ( source ) ; } } catch ( IOException e ) { throw new FileSystemException ( e ) ; } return null ; } } ; } private BlockingAction < Void > mkdirInternal ( String path , Handler < AsyncResult < Void > > handler ) { return mkdirInternal ( path , null , false , handler ) ; } private BlockingAction < Void > mkdirInternal ( String path , boolean createParents , Handler < AsyncResult < Void > > handler ) { return mkdirInternal ( path , null , createParents , handler ) ; } private BlockingAction < Void > mkdirInternal ( String path , String perms , Handler < AsyncResult < Void > > handler ) { return mkdirInternal ( path , perms , false , handler ) ; } protected BlockingAction < Void > mkdirInternal ( String path , String perms , boolean createParents , Handler < AsyncResult < Void > > handler ) { Objects . requireNonNull ( path ) ; FileAttribute < ? > attrs = perms == null ? null : PosixFilePermissions . asFileAttribute ( PosixFilePermissions . fromString ( perms ) ) ; return new BlockingAction < Void > ( handler ) { public Void perform ( ) { try { Path source = vertx . resolveFile ( path ) . toPath ( ) ; if ( createParents ) { if ( attrs != null ) { Files . createDirectories ( source , attrs ) ; } else { Files . createDirectories ( source ) ; } } else { if ( attrs != null ) { Files . createDirectory ( source , attrs ) ; } else { Files . createDirectory ( source ) ; } } } catch ( IOException e ) { throw new FileSystemException ( e ) ; } return null ; } } ; } private BlockingAction < List < String > > readDirInternal ( String path , Handler < AsyncResult < List < String > > > handler ) { return readDirInternal ( path , null , handler ) ; } private BlockingAction < List < String > > readDirInternal ( String p , String filter , Handler < AsyncResult < List < String > > > handler ) { Objects . requireNonNull ( p ) ; return new BlockingAction < List < String > > ( handler ) { public List < String > perform ( ) { try { File file = vertx . resolveFile ( p ) ; if ( ! file . exists ( ) ) { throw new FileSystemException ( "Cannot read directory " + file + ". Does not exist" ) ; } if ( ! file . isDirectory ( ) ) { throw new FileSystemException ( "Cannot read directory " + file + ". It's not a directory" ) ; } else { FilenameFilter fnFilter ; if ( filter != null ) { fnFilter = new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return Pattern . matches ( filter , name ) ; } } ; } else { fnFilter = null ; } File [ ] files ; if ( fnFilter == null ) { files = file . listFiles ( ) ; } else { files = file . listFiles ( fnFilter ) ; } List < String > ret = new ArrayList < > ( files . length ) ; for ( File f : files ) { ret . add ( f . getCanonicalPath ( ) ) ; } return ret ; } } catch ( IOException e ) { throw new FileSystemException ( e ) ; } } } ; } private BlockingAction < Buffer > readFileInternal ( String path , Handler < AsyncResult < Buffer > > handler ) { Objects . requireNonNull ( path ) ; return new BlockingAction < Buffer > ( handler ) { public Buffer perform ( ) { try { Path target = vertx . resolveFile ( path ) . toPath ( ) ; byte [ ] bytes = Files . readAllBytes ( target ) ; Buffer buff = Buffer . buffer ( bytes ) ; return buff ; } catch ( IOException e ) { throw new FileSystemException ( e ) ; } } } ; } private BlockingAction < Void > writeFileInternal ( String path , Buffer data , Handler < AsyncResult < Void > > handler ) { Objects . requireNonNull ( path ) ; Objects . requireNonNull ( data ) ; return new BlockingAction < Void > ( handler ) { public Void perform ( ) { try { Path target = vertx . resolveFile ( path ) . toPath ( ) ; Files . write ( target , data . getBytes ( ) ) ; return null ; } catch ( IOException e ) { throw new FileSystemException ( e ) ; } } } ; } private BlockingAction < AsyncFile > openInternal ( String p , OpenOptions options , Handler < AsyncResult < AsyncFile > > handler ) { Objects . requireNonNull ( p ) ; Objects . requireNonNull ( options ) ; return new BlockingAction < AsyncFile > ( handler ) { String path = vertx . resolveFile ( p ) . getAbsolutePath ( ) ; public AsyncFile perform ( ) { return doOpen ( path , options , context ) ; } } ; } protected AsyncFile doOpen ( String path , OpenOptions options , ContextImpl context ) { return new AsyncFileImpl ( vertx , path , options , context ) ; } private BlockingAction < Void > createFileInternal ( String path , Handler < AsyncResult < Void > > handler ) { return createFileInternal ( path , null , handler ) ; } protected BlockingAction < Void > createFileInternal ( String p , String perms , Handler < AsyncResult < Void > > handler ) { Objects . requireNonNull ( p ) ; FileAttribute < ? > attrs = perms == null ? null : PosixFilePermissions . asFileAttribute ( PosixFilePermissions . fromString ( perms ) ) ; return new BlockingAction < Void > ( handler ) { public Void perform ( ) { try { Path target = vertx . resolveFile ( p ) . toPath ( ) ; if ( attrs != null ) { Files . createFile ( target , attrs ) ; } else { Files . createFile ( target ) ; } } catch ( IOException e ) { throw new FileSystemException ( e ) ; } return null ; } } ; } private BlockingAction < Boolean > existsInternal ( String path , Handler < AsyncResult < Boolean > > handler ) { Objects . requireNonNull ( path ) ; return new BlockingAction < Boolean > ( handler ) { File file = vertx . resolveFile ( path ) ; public Boolean perform ( ) { return file . exists ( ) ; } } ; } private BlockingAction < FileSystemProps > fsPropsInternal ( String path , Handler < AsyncResult < FileSystemProps > > handler ) { Objects . requireNonNull ( path ) ; return new BlockingAction < FileSystemProps > ( handler ) { public FileSystemProps perform ( ) { try { Path target = vertx . resolveFile ( path ) . toPath ( ) ; FileStore fs = Files . getFileStore ( target ) ; return new FileSystemPropsImpl ( fs . getTotalSpace ( ) , fs . getUnallocatedSpace ( ) , fs . getUsableSpace ( ) ) ; } catch ( IOException e ) { throw new FileSystemException ( e ) ; } } } ; } protected abstract class BlockingAction < T > implements Action < T > { private final Handler < AsyncResult < T > > handler ; protected final ContextImpl context ; public BlockingAction ( Handler < AsyncResult < T > > handler ) { this . handler = handler ; this . context = vertx . getOrCreateContext ( ) ; } public void run ( ) { context . executeBlocking ( this , handler ) ; } } }
@ Document ( fileName = "buffers.adoc" ) package io . vertx . core . buffer ; import io . vertx . docgen . Document ;
package io . vertx . core . buffer ; import io . netty . buffer . ByteBuf ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . ServiceHelper ; import io . vertx . core . shareddata . impl . ClusterSerializable ; import io . vertx . core . spi . BufferFactory ; import java . nio . ByteBuffer ; @ VertxGen public interface Buffer extends ClusterSerializable { static Buffer buffer ( ) { return factory . buffer ( ) ; } static Buffer buffer ( int initialSizeHint ) { return factory . buffer ( initialSizeHint ) ; } static Buffer buffer ( String string ) { return factory . buffer ( string ) ; } static Buffer buffer ( String string , String enc ) { return factory . buffer ( string , enc ) ; } @ GenIgnore static Buffer buffer ( byte [ ] bytes ) { return factory . buffer ( bytes ) ; } @ GenIgnore static Buffer buffer ( ByteBuf byteBuf ) { return factory . buffer ( byteBuf ) ; } String toString ( String enc ) ; byte getByte ( int pos ) ; short getUnsignedByte ( int pos ) ; int getInt ( int pos ) ; long getUnsignedInt ( int pos ) ; long getLong ( int pos ) ; double getDouble ( int pos ) ; float getFloat ( int pos ) ; short getShort ( int pos ) ; int getUnsignedShort ( int pos ) ; @ GenIgnore byte [ ] getBytes ( ) ; @ GenIgnore byte [ ] getBytes ( int start , int end ) ; Buffer getBuffer ( int start , int end ) ; String getString ( int start , int end , String enc ) ; String getString ( int start , int end ) ; @ Fluent Buffer appendBuffer ( Buffer buff ) ; @ Fluent Buffer appendBuffer ( Buffer buff , int offset , int len ) ; @ GenIgnore @ Fluent Buffer appendBytes ( byte [ ] bytes ) ; @ GenIgnore @ Fluent Buffer appendBytes ( byte [ ] bytes , int offset , int len ) ; @ Fluent Buffer appendByte ( byte b ) ; @ Fluent Buffer appendUnsignedByte ( short b ) ; @ Fluent Buffer appendInt ( int i ) ; @ Fluent Buffer appendUnsignedInt ( long i ) ; @ Fluent Buffer appendLong ( long l ) ; @ Fluent Buffer appendShort ( short s ) ; @ Fluent Buffer appendUnsignedShort ( int s ) ; @ Fluent Buffer appendFloat ( float f ) ; @ Fluent Buffer appendDouble ( double d ) ; @ Fluent Buffer appendString ( String str , String enc ) ; @ Fluent Buffer appendString ( String str ) ; @ Fluent Buffer setByte ( int pos , byte b ) ; Buffer setUnsignedByte ( int pos , short b ) ; @ Fluent Buffer setInt ( int pos , int i ) ; @ Fluent Buffer setUnsignedInt ( int pos , long i ) ; @ Fluent Buffer setLong ( int pos , long l ) ; @ Fluent Buffer setDouble ( int pos , double d ) ; @ Fluent Buffer setFloat ( int pos , float f ) ; @ Fluent Buffer setShort ( int pos , short s ) ; @ Fluent Buffer setUnsignedShort ( int pos , int s ) ; @ Fluent Buffer setBuffer ( int pos , Buffer b ) ; @ Fluent Buffer setBuffer ( int pos , Buffer b , int offset , int len ) ; @ GenIgnore @ Fluent Buffer setBytes ( int pos , ByteBuffer b ) ; @ GenIgnore @ Fluent Buffer setBytes ( int pos , byte [ ] b ) ; @ GenIgnore @ Fluent Buffer setBytes ( int pos , byte [ ] b , int offset , int len ) ; @ Fluent Buffer setString ( int pos , String str ) ; @ Fluent Buffer setString ( int pos , String str , String enc ) ; int length ( ) ; Buffer copy ( ) ; Buffer slice ( ) ; Buffer slice ( int start , int end ) ; @ GenIgnore ByteBuf getByteBuf ( ) ; static final BufferFactory factory = ServiceHelper . loadFactory ( BufferFactory . class ) ; }
package io . vertx . core . buffer . impl ; import io . netty . buffer . ByteBuf ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . spi . BufferFactory ; public class BufferFactoryImpl implements BufferFactory { @ Override public Buffer buffer ( int initialSizeHint ) { return new BufferImpl ( initialSizeHint ) ; } @ Override public Buffer buffer ( ) { return new BufferImpl ( ) ; } @ Override public Buffer buffer ( String str ) { return new BufferImpl ( str ) ; } @ Override public Buffer buffer ( String str , String enc ) { return new BufferImpl ( str , enc ) ; } @ Override public Buffer buffer ( byte [ ] bytes ) { return new BufferImpl ( bytes ) ; } @ Override public Buffer buffer ( ByteBuf byteBuffer ) { return new BufferImpl ( byteBuffer ) ; } }
package io . vertx . core . buffer . impl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . util . CharsetUtil ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . impl . Arguments ; import java . nio . ByteBuffer ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . util . Objects ; public class BufferImpl implements Buffer { private ByteBuf buffer ; BufferImpl ( ) { this ( 0 ) ; } BufferImpl ( int initialSizeHint ) { buffer = Unpooled . unreleasableBuffer ( Unpooled . buffer ( initialSizeHint , Integer . MAX_VALUE ) ) ; } BufferImpl ( byte [ ] bytes ) { buffer = Unpooled . unreleasableBuffer ( Unpooled . buffer ( bytes . length , Integer . MAX_VALUE ) ) . writeBytes ( bytes ) ; } BufferImpl ( String str , String enc ) { this ( str . getBytes ( Charset . forName ( Objects . requireNonNull ( enc ) ) ) ) ; } BufferImpl ( String str , Charset cs ) { this ( str . getBytes ( cs ) ) ; } BufferImpl ( String str ) { this ( str , StandardCharsets . UTF_8 ) ; } BufferImpl ( ByteBuf buffer ) { this . buffer = Unpooled . unreleasableBuffer ( buffer ) ; } public String toString ( ) { return buffer . toString ( StandardCharsets . UTF_8 ) ; } public String toString ( String enc ) { return buffer . toString ( Charset . forName ( enc ) ) ; } public byte getByte ( int pos ) { return buffer . getByte ( pos ) ; } public short getUnsignedByte ( int pos ) { return buffer . getUnsignedByte ( pos ) ; } public int getInt ( int pos ) { return buffer . getInt ( pos ) ; } public long getUnsignedInt ( int pos ) { return buffer . getUnsignedInt ( pos ) ; } public long getLong ( int pos ) { return buffer . getLong ( pos ) ; } public double getDouble ( int pos ) { return buffer . getDouble ( pos ) ; } public float getFloat ( int pos ) { return buffer . getFloat ( pos ) ; } public short getShort ( int pos ) { return buffer . getShort ( pos ) ; } public int getUnsignedShort ( int pos ) { return buffer . getUnsignedShort ( pos ) ; } public byte [ ] getBytes ( ) { byte [ ] arr = new byte [ buffer . writerIndex ( ) ] ; buffer . getBytes ( 0 , arr ) ; return arr ; } public byte [ ] getBytes ( int start , int end ) { Arguments . require ( end >= start , "end must be greater or equal than start" ) ; byte [ ] arr = new byte [ end - start ] ; buffer . getBytes ( start , arr , 0 , end - start ) ; return arr ; } public Buffer getBuffer ( int start , int end ) { return new BufferImpl ( getBytes ( start , end ) ) ; } public String getString ( int start , int end , String enc ) { byte [ ] bytes = getBytes ( start , end ) ; Charset cs = Charset . forName ( enc ) ; return new String ( bytes , cs ) ; } public String getString ( int start , int end ) { byte [ ] bytes = getBytes ( start , end ) ; return new String ( bytes , StandardCharsets . UTF_8 ) ; } public Buffer appendBuffer ( Buffer buff ) { ByteBuf cb = buff . getByteBuf ( ) ; buffer . writeBytes ( buff . getByteBuf ( ) ) ; cb . readerIndex ( 0 ) ; return this ; } public Buffer appendBuffer ( Buffer buff , int offset , int len ) { buffer . writeBytes ( buff . getByteBuf ( ) , offset , len ) ; return this ; } public Buffer appendBytes ( byte [ ] bytes ) { buffer . writeBytes ( bytes ) ; return this ; } public Buffer appendBytes ( byte [ ] bytes , int offset , int len ) { buffer . writeBytes ( bytes , offset , len ) ; return this ; } public Buffer appendByte ( byte b ) { buffer . writeByte ( b ) ; return this ; } public Buffer appendUnsignedByte ( short b ) { buffer . writeByte ( b ) ; return this ; } public Buffer appendInt ( int i ) { buffer . writeInt ( i ) ; return this ; } public Buffer appendUnsignedInt ( long i ) { buffer . writeInt ( ( int ) i ) ; return this ; } public Buffer appendLong ( long l ) { buffer . writeLong ( l ) ; return this ; } public Buffer appendShort ( short s ) { buffer . writeShort ( s ) ; return this ; } public Buffer appendUnsignedShort ( int s ) { buffer . writeShort ( s ) ; return this ; } public Buffer appendFloat ( float f ) { buffer . writeFloat ( f ) ; return this ; } public Buffer appendDouble ( double d ) { buffer . writeDouble ( d ) ; return this ; } public Buffer appendString ( String str , String enc ) { return append ( str , Charset . forName ( Objects . requireNonNull ( enc ) ) ) ; } public Buffer appendString ( String str ) { return append ( str , CharsetUtil . UTF_8 ) ; } public Buffer setByte ( int pos , byte b ) { ensureWritable ( pos , 1 ) ; buffer . setByte ( pos , b ) ; return this ; } public Buffer setUnsignedByte ( int pos , short b ) { ensureWritable ( pos , 1 ) ; buffer . setByte ( pos , b ) ; return this ; } public Buffer setInt ( int pos , int i ) { ensureWritable ( pos , 4 ) ; buffer . setInt ( pos , i ) ; return this ; } public Buffer setUnsignedInt ( int pos , long i ) { ensureWritable ( pos , 4 ) ; buffer . setInt ( pos , ( int ) i ) ; return this ; } public Buffer setLong ( int pos , long l ) { ensureWritable ( pos , 8 ) ; buffer . setLong ( pos , l ) ; return this ; } public Buffer setDouble ( int pos , double d ) { ensureWritable ( pos , 8 ) ; buffer . setDouble ( pos , d ) ; return this ; } public Buffer setFloat ( int pos , float f ) { ensureWritable ( pos , 4 ) ; buffer . setFloat ( pos , f ) ; return this ; } public Buffer setShort ( int pos , short s ) { ensureWritable ( pos , 2 ) ; buffer . setShort ( pos , s ) ; return this ; } public Buffer setUnsignedShort ( int pos , int s ) { ensureWritable ( pos , 2 ) ; buffer . setShort ( pos , s ) ; return this ; } public Buffer setBuffer ( int pos , Buffer b ) { ensureWritable ( pos , b . length ( ) ) ; buffer . setBytes ( pos , b . getByteBuf ( ) ) ; return this ; } public Buffer setBuffer ( int pos , Buffer b , int offset , int len ) { ensureWritable ( pos , len ) ; buffer . setBytes ( pos , b . getByteBuf ( ) , offset , len ) ; return this ; } public BufferImpl setBytes ( int pos , ByteBuffer b ) { ensureWritable ( pos , b . limit ( ) ) ; buffer . setBytes ( pos , b ) ; return this ; } public Buffer setBytes ( int pos , byte [ ] b ) { ensureWritable ( pos , b . length ) ; buffer . setBytes ( pos , b ) ; return this ; } public Buffer setBytes ( int pos , byte [ ] b , int offset , int len ) { ensureWritable ( pos , len ) ; buffer . setBytes ( pos , b , offset , len ) ; return this ; } public Buffer setString ( int pos , String str ) { return setBytes ( pos , str , CharsetUtil . UTF_8 ) ; } public Buffer setString ( int pos , String str , String enc ) { return setBytes ( pos , str , Charset . forName ( enc ) ) ; } public int length ( ) { return buffer . writerIndex ( ) ; } public Buffer copy ( ) { return new BufferImpl ( buffer . copy ( ) ) ; } public Buffer slice ( ) { return new BufferImpl ( buffer . slice ( ) ) ; } public Buffer slice ( int start , int end ) { return new BufferImpl ( buffer . slice ( start , end - start ) ) ; } public ByteBuf getByteBuf ( ) { return buffer . duplicate ( ) ; } private Buffer append ( String str , Charset charset ) { byte [ ] bytes = str . getBytes ( charset ) ; buffer . writeBytes ( bytes ) ; return this ; } private Buffer setBytes ( int pos , String str , Charset charset ) { byte [ ] bytes = str . getBytes ( charset ) ; ensureWritable ( pos , bytes . length ) ; buffer . setBytes ( pos , bytes ) ; return this ; } private void ensureWritable ( int pos , int len ) { int ni = pos + len ; int cap = buffer . capacity ( ) ; int over = ni - cap ; if ( over > 0 ) { buffer . writerIndex ( cap ) ; buffer . ensureWritable ( over ) ; } if ( ni > buffer . writerIndex ( ) ) { buffer . writerIndex ( ni ) ; } } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; BufferImpl buffer1 = ( BufferImpl ) o ; if ( buffer != null ? ! buffer . equals ( buffer1 . buffer ) : buffer1 . buffer != null ) return false ; return true ; } @ Override public int hashCode ( ) { return buffer != null ? buffer . hashCode ( ) : 0 ; } @ Override public void writeToBuffer ( Buffer buff ) { buff . appendInt ( this . length ( ) ) ; buff . appendBuffer ( this ) ; } @ Override public int readFromBuffer ( int pos , Buffer buffer ) { int len = buffer . getInt ( pos ) ; Buffer b = buffer . getBuffer ( pos + 4 , pos + 4 + len ) ; this . buffer = b . getByteBuf ( ) ; return pos + 4 + len ; } }
package io . vertx . core . http ; import io . vertx . codegen . annotations . CacheReturn ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . ServiceHelper ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . spi . WebSocketFrameFactory ; @ VertxGen public interface WebSocketFrame { static WebSocketFrame binaryFrame ( Buffer data , boolean isFinal ) { return factory . binaryFrame ( data , isFinal ) ; } static WebSocketFrame textFrame ( String str , boolean isFinal ) { return factory . textFrame ( str , isFinal ) ; } static WebSocketFrame continuationFrame ( Buffer data , boolean isFinal ) { return factory . continuationFrame ( data , isFinal ) ; } boolean isText ( ) ; boolean isBinary ( ) ; boolean isContinuation ( ) ; @ CacheReturn String textData ( ) ; @ CacheReturn Buffer binaryData ( ) ; boolean isFinal ( ) ; static final WebSocketFrameFactory factory = ServiceHelper . loadFactory ( WebSocketFrameFactory . class ) ; }
@ Document ( fileName = "http.adoc" ) package io . vertx . core . http ; import io . vertx . docgen . Document ;
package io . vertx . core . http ; public enum HttpVersion { HTTP_1_0 , HTTP_1_1 }
package io . vertx . core . http ; public final class HttpHeaders { public static final CharSequence ACCEPT = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCEPT ) ; public static final CharSequence ACCEPT_CHARSET = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCEPT_CHARSET ) ; public static final CharSequence ACCEPT_ENCODING = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCEPT_ENCODING ) ; public static final CharSequence ACCEPT_LANGUAGE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCEPT_LANGUAGE ) ; public static final CharSequence ACCEPT_RANGES = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCEPT_RANGES ) ; public static final CharSequence ACCEPT_PATCH = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCEPT_PATCH ) ; public static final CharSequence ACCESS_CONTROL_ALLOW_CREDENTIALS = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCESS_CONTROL_ALLOW_CREDENTIALS ) ; public static final CharSequence ACCESS_CONTROL_ALLOW_HEADERS = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCESS_CONTROL_ALLOW_HEADERS ) ; public static final CharSequence ACCESS_CONTROL_ALLOW_METHODS = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCESS_CONTROL_ALLOW_METHODS ) ; public static final CharSequence ACCESS_CONTROL_ALLOW_ORIGIN = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCESS_CONTROL_ALLOW_ORIGIN ) ; public static final CharSequence ACCESS_CONTROL_EXPOSE_HEADERS = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCESS_CONTROL_EXPOSE_HEADERS ) ; public static final CharSequence ACCESS_CONTROL_MAX_AGE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCESS_CONTROL_MAX_AGE ) ; public static final CharSequence ACCESS_CONTROL_REQUEST_HEADERS = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCESS_CONTROL_REQUEST_HEADERS ) ; public static final CharSequence ACCESS_CONTROL_REQUEST_METHOD = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ACCESS_CONTROL_REQUEST_METHOD ) ; public static final CharSequence AGE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . AGE ) ; public static final CharSequence ALLOW = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ALLOW ) ; public static final CharSequence AUTHORIZATION = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . AUTHORIZATION ) ; public static final CharSequence CACHE_CONTROL = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . CACHE_CONTROL ) ; public static final CharSequence CONNECTION = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . CONNECTION ) ; public static final CharSequence CONTENT_BASE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . CONTENT_BASE ) ; public static final CharSequence CONTENT_ENCODING = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . CONTENT_ENCODING ) ; public static final CharSequence CONTENT_LANGUAGE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . CONTENT_LANGUAGE ) ; public static final CharSequence CONTENT_LENGTH = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . CONTENT_LENGTH ) ; public static final CharSequence CONTENT_LOCATION = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . CONTENT_LOCATION ) ; public static final CharSequence CONTENT_TRANSFER_ENCODING = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . CONTENT_TRANSFER_ENCODING ) ; public static final CharSequence CONTENT_MD5 = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . CONTENT_MD5 ) ; public static final CharSequence CONTENT_RANGE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . CONTENT_RANGE ) ; public static final CharSequence CONTENT_TYPE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . CONTENT_TYPE ) ; public static final CharSequence COOKIE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . COOKIE ) ; public static final CharSequence DATE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . DATE ) ; public static final CharSequence ETAG = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ETAG ) ; public static final CharSequence EXPECT = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . EXPECT ) ; public static final CharSequence EXPIRES = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . EXPIRES ) ; public static final CharSequence FROM = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . FROM ) ; public static final CharSequence HOST = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . HOST ) ; public static final CharSequence IF_MATCH = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . IF_MATCH ) ; public static final CharSequence IF_MODIFIED_SINCE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . IF_MODIFIED_SINCE ) ; public static final CharSequence IF_NONE_MATCH = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . IF_NONE_MATCH ) ; public static final CharSequence LAST_MODIFIED = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . LAST_MODIFIED ) ; public static final CharSequence LOCATION = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . LOCATION ) ; public static final CharSequence ORIGIN = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . ORIGIN ) ; public static final CharSequence PROXY_AUTHENTICATE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . PROXY_AUTHENTICATE ) ; public static final CharSequence PROXY_AUTHORIZATION = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . PROXY_AUTHORIZATION ) ; public static final CharSequence REFERER = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . REFERER ) ; public static final CharSequence RETRY_AFTER = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . RETRY_AFTER ) ; public static final CharSequence SERVER = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . SERVER ) ; public static final CharSequence TRANSFER_ENCODING = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . TRANSFER_ENCODING ) ; public static final CharSequence USER_AGENT = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . USER_AGENT ) ; public static final CharSequence SET_COOKIE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Names . SET_COOKIE ) ; public static final CharSequence APPLICATION_X_WWW_FORM_URLENCODED = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Values . APPLICATION_X_WWW_FORM_URLENCODED ) ; public static final CharSequence CHUNKED = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Values . CHUNKED ) ; public static final CharSequence CLOSE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Values . CLOSE ) ; public static final CharSequence CONTINUE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Values . CONTINUE ) ; public static final CharSequence IDENTITY = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Values . IDENTITY ) ; public static final CharSequence KEEP_ALIVE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Values . KEEP_ALIVE ) ; public static final CharSequence UPGRADE = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Values . UPGRADE ) ; public static final CharSequence WEBSOCKET = createOptimized ( io . netty . handler . codec . http . HttpHeaders . Values . WEBSOCKET ) ; public static final CharSequence DEFLATE_GZIP = createOptimized ( "deflate, gzip" ) ; public static final CharSequence TEXT_HTML = createOptimized ( "text/html" ) ; public static final CharSequence GET = createOptimized ( "GET" ) ; public static CharSequence createOptimized ( String value ) { return io . netty . handler . codec . http . HttpHeaders . newEntity ( value ) ; } private HttpHeaders ( ) { } }
package io . vertx . core . http ; public enum WebsocketVersion { V00 , V07 , V08 , V13 }
package io . vertx . test . core ; import io . vertx . core . http . HttpClientOptions ; import io . vertx . core . http . HttpMethod ; import io . vertx . core . http . HttpServerOptions ; import org . junit . Test ; public class HttpCompressionTest extends HttpTestBase { public void setUp ( ) throws Exception { super . setUp ( ) ; client = vertx . createHttpClient ( new HttpClientOptions ( ) . setTryUseCompression ( true ) ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( DEFAULT_HTTP_PORT ) . setCompressionSupported ( true ) ) ; } @ Test public void testDefaultRequestHeaders ( ) { server . requestHandler ( req - > { assertEquals ( 2 , req . headers ( ) . size ( ) ) ; assertEquals ( "localhost:" + DEFAULT_HTTP_PORT , req . headers ( ) . get ( "host" ) ) ; assertNotNull ( req . headers ( ) . get ( "Accept-Encoding" ) ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( server - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "some-uri" , resp - > testComplete ( ) ) . end ( ) ; } ) ) ; await ( ) ; } }
package io . vertx . test . core ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import io . vertx . core . shareddata . LocalMap ; import io . vertx . core . shareddata . SharedData ; import org . junit . Test ; import java . util . Collection ; import java . util . Random ; import java . util . Set ; import static io . vertx . test . core . TestUtils . * ; public class LocalSharedDataTest extends VertxTestBase { private SharedData sharedData ; public void setUp ( ) throws Exception { super . setUp ( ) ; sharedData = vertx . sharedData ( ) ; } @ Test public void testMap ( ) throws Exception { assertNullPointerException ( ( ) - > sharedData . getLocalMap ( null ) ) ; LocalMap < String , String > map = sharedData . getLocalMap ( "foo" ) ; LocalMap < String , String > map2 = sharedData . getLocalMap ( "foo" ) ; assertTrue ( map == map2 ) ; LocalMap < String , String > map3 = sharedData . getLocalMap ( "bar" ) ; assertFalse ( map3 == map2 ) ; map . close ( ) ; LocalMap < String , String > map4 = sharedData . getLocalMap ( "foo" ) ; assertFalse ( map4 == map3 ) ; } @ Test public void testMapTypes ( ) throws Exception { LocalMap map = sharedData . getLocalMap ( "foo" ) ; String key = "key" ; double d = new Random ( ) . nextDouble ( ) ; map . put ( key , d ) ; assertEquals ( d , map . get ( key ) ) ; float f = new Random ( ) . nextFloat ( ) ; map . put ( key , f ) ; assertEquals ( f , map . get ( key ) ) ; byte b = ( byte ) new Random ( ) . nextInt ( ) ; map . put ( key , b ) ; assertEquals ( b , map . get ( key ) ) ; short s = ( short ) new Random ( ) . nextInt ( ) ; map . put ( key , s ) ; assertEquals ( s , map . get ( key ) ) ; int i = new Random ( ) . nextInt ( ) ; map . put ( key , i ) ; assertEquals ( i , map . get ( key ) ) ; long l = new Random ( ) . nextLong ( ) ; map . put ( key , l ) ; assertEquals ( l , map . get ( key ) ) ; map . put ( key , true ) ; assertTrue ( ( Boolean ) map . get ( key ) ) ; map . put ( key , false ) ; assertFalse ( ( Boolean ) map . get ( key ) ) ; char c = ( char ) new Random ( ) . nextLong ( ) ; map . put ( key , c ) ; assertEquals ( c , map . get ( key ) ) ; Buffer buff = TestUtils . randomBuffer ( 100 ) ; map . put ( key , buff ) ; Buffer got1 = ( Buffer ) map . get ( key ) ; assertTrue ( got1 != buff ) ; assertEquals ( buff , map . get ( key ) ) ; Buffer got2 = ( Buffer ) map . get ( key ) ; assertTrue ( got1 != got2 ) ; assertTrue ( got2 != buff ) ; assertEquals ( buff , map . get ( key ) ) ; byte [ ] bytes = TestUtils . randomByteArray ( 100 ) ; map . put ( key , bytes ) ; byte [ ] bgot1 = ( byte [ ] ) map . get ( key ) ; assertTrue ( bgot1 != bytes ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , bgot1 ) ) ; byte [ ] bgot2 = ( byte [ ] ) map . get ( key ) ; assertTrue ( bgot2 != bytes ) ; assertTrue ( bgot1 != bgot2 ) ; assertTrue ( TestUtils . byteArraysEqual ( bytes , bgot2 ) ) ; assertIllegalArgumentException ( ( ) - > map . put ( key , new SomeOtherClass ( ) ) ) ; JsonObject obj = new JsonObject ( ) . put ( "foo" , "bar" ) ; map . put ( "obj" , obj ) ; JsonObject other = ( JsonObject ) map . get ( "obj" ) ; assertEquals ( obj , other ) ; assertNotSame ( obj , other ) ; JsonArray arr = new JsonArray ( ) . add ( "foo" ) ; map . put ( "arr" , arr ) ; JsonArray otherArr = ( JsonArray ) map . get ( "arr" ) ; assertEquals ( arr , otherArr ) ; assertNotSame ( arr , otherArr ) ; } @ Test public void testKeys ( ) { LocalMap < String , String > map = sharedData . getLocalMap ( "foo" ) ; map . put ( "foo1" , "val1" ) ; map . put ( "foo2" , "val2" ) ; map . put ( "foo3" , "val3" ) ; assertEquals ( 3 , map . size ( ) ) ; Set < String > keys = map . keySet ( ) ; assertEquals ( 3 , keys . size ( ) ) ; assertTrue ( keys . contains ( "foo1" ) ) ; assertTrue ( keys . contains ( "foo2" ) ) ; assertTrue ( keys . contains ( "foo3" ) ) ; } @ Test public void testKeysCopied ( ) { LocalMap < JsonObject , String > map = sharedData . getLocalMap ( "foo" ) ; JsonObject json1 = new JsonObject ( ) . put ( "foo1" , "val1" ) ; JsonObject json2 = new JsonObject ( ) . put ( "foo2" , "val1" ) ; JsonObject json3 = new JsonObject ( ) . put ( "foo3" , "val1" ) ; map . put ( json1 , "val1" ) ; map . put ( json2 , "val2" ) ; map . put ( json3 , "val3" ) ; assertEquals ( 3 , map . size ( ) ) ; Set < JsonObject > keys = map . keySet ( ) ; assertEquals ( 3 , keys . size ( ) ) ; assertTrue ( keys . contains ( json1 ) ) ; assertTrue ( keys . contains ( json2 ) ) ; assertTrue ( keys . contains ( json3 ) ) ; assertFalse ( containsExact ( keys , json1 ) ) ; assertFalse ( containsExact ( keys , json2 ) ) ; assertFalse ( containsExact ( keys , json3 ) ) ; } private boolean containsExact ( Collection < JsonObject > coll , JsonObject obj ) { for ( JsonObject j : coll ) { if ( j == obj ) { return true ; } } return false ; } @ Test public void testValues ( ) { LocalMap < String , String > map = sharedData . getLocalMap ( "foo" ) ; map . put ( "foo1" , "val1" ) ; map . put ( "foo2" , "val2" ) ; map . put ( "foo3" , "val3" ) ; assertEquals ( 3 , map . size ( ) ) ; Collection < String > values = map . values ( ) ; assertEquals ( 3 , values . size ( ) ) ; assertTrue ( values . contains ( "val1" ) ) ; assertTrue ( values . contains ( "val2" ) ) ; assertTrue ( values . contains ( "val3" ) ) ; } @ Test public void testValuesCopied ( ) { LocalMap < String , JsonObject > map = sharedData . getLocalMap ( "foo" ) ; JsonObject json1 = new JsonObject ( ) . put ( "foo1" , "val1" ) ; JsonObject json2 = new JsonObject ( ) . put ( "foo2" , "val1" ) ; JsonObject json3 = new JsonObject ( ) . put ( "foo3" , "val1" ) ; map . put ( "key1" , json1 ) ; map . put ( "key2" , json2 ) ; map . put ( "key3" , json3 ) ; assertEquals ( 3 , map . size ( ) ) ; Collection < JsonObject > values = map . values ( ) ; assertEquals ( 3 , values . size ( ) ) ; assertTrue ( values . contains ( json1 ) ) ; assertTrue ( values . contains ( json2 ) ) ; assertTrue ( values . contains ( json3 ) ) ; assertFalse ( containsExact ( values , json1 ) ) ; assertFalse ( containsExact ( values , json2 ) ) ; assertFalse ( containsExact ( values , json3 ) ) ; } class SomeOtherClass { } }
package io . vertx . core . http ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . buffer . Buffer ; import io . vertx . codegen . annotations . CacheReturn ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . net . NetSocket ; import io . vertx . core . net . SocketAddress ; import io . vertx . core . streams . ReadStream ; import javax . net . ssl . SSLPeerUnverifiedException ; import javax . security . cert . X509Certificate ; @ VertxGen public interface HttpServerRequest extends ReadStream < Buffer > { @ Override HttpServerRequest exceptionHandler ( Handler < Throwable > handler ) ; @ Override HttpServerRequest handler ( Handler < Buffer > handler ) ; @ Override HttpServerRequest pause ( ) ; @ Override HttpServerRequest resume ( ) ; @ Override HttpServerRequest endHandler ( Handler < Void > endHandler ) ; HttpVersion version ( ) ; HttpMethod method ( ) ; String uri ( ) ; String path ( ) ; String query ( ) ; @ CacheReturn HttpServerResponse response ( ) ; @ CacheReturn MultiMap headers ( ) ; String getHeader ( String headerName ) ; @ CacheReturn MultiMap params ( ) ; String getParam ( String paramName ) ; @ CacheReturn SocketAddress remoteAddress ( ) ; @ CacheReturn SocketAddress localAddress ( ) ; @ GenIgnore X509Certificate [ ] peerCertificateChain ( ) throws SSLPeerUnverifiedException ; String absoluteURI ( ) ; @ Fluent HttpServerRequest bodyHandler ( Handler < Buffer > bodyHandler ) ; @ CacheReturn NetSocket netSocket ( ) ; @ Fluent HttpServerRequest setExpectMultipart ( boolean expect ) ; boolean isExpectMultipart ( ) ; @ Fluent HttpServerRequest uploadHandler ( Handler < HttpServerFileUpload > uploadHandler ) ; @ CacheReturn MultiMap formAttributes ( ) ; String getFormAttribute ( String attributeName ) ; ServerWebSocket upgrade ( ) ; boolean isEnded ( ) ; }
package io . vertx . core . http ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . streams . ReadStream ; @ VertxGen public interface HttpServerFileUpload extends ReadStream < Buffer > { @ Override HttpServerFileUpload exceptionHandler ( Handler < Throwable > handler ) ; @ Override HttpServerFileUpload handler ( Handler < Buffer > handler ) ; @ Override HttpServerFileUpload endHandler ( Handler < Void > endHandler ) ; @ Override HttpServerFileUpload pause ( ) ; @ Override HttpServerFileUpload resume ( ) ; @ Fluent HttpServerFileUpload streamToFileSystem ( String filename ) ; String filename ( ) ; String name ( ) ; String contentType ( ) ; String contentTransferEncoding ( ) ; String charset ( ) ; long size ( ) ; boolean isSizeAvailable ( ) ; }
package io . vertx . core . http ; public enum HttpMethod { OPTIONS , GET , HEAD , POST , PUT , DELETE , TRACE , CONNECT , PATCH }
package io . vertx . core . http ; import io . vertx . codegen . annotations . CacheReturn ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . AsyncResult ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . streams . WriteStream ; @ VertxGen public interface HttpServerResponse extends WriteStream < Buffer > { @ Override HttpServerResponse exceptionHandler ( Handler < Throwable > handler ) ; @ Override HttpServerResponse write ( Buffer data ) ; @ Override HttpServerResponse setWriteQueueMaxSize ( int maxSize ) ; @ Override HttpServerResponse drainHandler ( Handler < Void > handler ) ; int getStatusCode ( ) ; @ Fluent HttpServerResponse setStatusCode ( int statusCode ) ; String getStatusMessage ( ) ; @ Fluent HttpServerResponse setStatusMessage ( String statusMessage ) ; @ Fluent HttpServerResponse setChunked ( boolean chunked ) ; boolean isChunked ( ) ; @ CacheReturn MultiMap headers ( ) ; @ Fluent HttpServerResponse putHeader ( String name , String value ) ; @ GenIgnore HttpServerResponse putHeader ( CharSequence name , CharSequence value ) ; @ GenIgnore HttpServerResponse putHeader ( String name , Iterable < String > values ) ; @ GenIgnore HttpServerResponse putHeader ( CharSequence name , Iterable < CharSequence > values ) ; @ CacheReturn MultiMap trailers ( ) ; @ Fluent HttpServerResponse putTrailer ( String name , String value ) ; @ GenIgnore HttpServerResponse putTrailer ( CharSequence name , CharSequence value ) ; @ GenIgnore HttpServerResponse putTrailer ( String name , Iterable < String > values ) ; @ GenIgnore HttpServerResponse putTrailer ( CharSequence name , Iterable < CharSequence > value ) ; @ Fluent HttpServerResponse closeHandler ( Handler < Void > handler ) ; @ Fluent HttpServerResponse write ( String chunk , String enc ) ; @ Fluent HttpServerResponse write ( String chunk ) ; @ Fluent HttpServerResponse writeContinue ( ) ; void end ( String chunk ) ; void end ( String chunk , String enc ) ; void end ( Buffer chunk ) ; void end ( ) ; @ Fluent HttpServerResponse sendFile ( String filename ) ; @ Fluent HttpServerResponse sendFile ( String filename , Handler < AsyncResult < Void > > resultHandler ) ; void close ( ) ; boolean ended ( ) ; boolean headWritten ( ) ; @ Fluent HttpServerResponse headersEndHandler ( Handler < Future < Void > > handler ) ; @ Fluent HttpServerResponse bodyEndHandler ( Handler < Void > handler ) ; }
package io . vertx . core . http ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . buffer . Buffer ; import io . vertx . codegen . annotations . CacheReturn ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . net . NetSocket ; import io . vertx . core . streams . ReadStream ; import java . util . List ; @ VertxGen public interface HttpClientResponse extends ReadStream < Buffer > { @ Override HttpClientResponse resume ( ) ; @ Override HttpClientResponse exceptionHandler ( Handler < Throwable > handler ) ; @ Override HttpClientResponse handler ( Handler < Buffer > handler ) ; @ Override HttpClientResponse pause ( ) ; @ Override HttpClientResponse endHandler ( Handler < Void > endHandler ) ; int statusCode ( ) ; String statusMessage ( ) ; @ CacheReturn MultiMap headers ( ) ; String getHeader ( String headerName ) ; String getTrailer ( String trailerName ) ; @ CacheReturn MultiMap trailers ( ) ; @ CacheReturn List < String > cookies ( ) ; @ Fluent HttpClientResponse bodyHandler ( Handler < Buffer > bodyHandler ) ; @ CacheReturn NetSocket netSocket ( ) ; }
package io . vertx . core . http ; import io . vertx . codegen . annotations . CacheReturn ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . net . SocketAddress ; import io . vertx . core . streams . ReadStream ; import io . vertx . core . streams . WriteStream ; @ VertxGen ( concrete = false ) public interface WebSocketBase extends ReadStream < Buffer > , WriteStream < Buffer > { @ Override WebSocketBase exceptionHandler ( Handler < Throwable > handler ) ; @ Override WebSocketBase handler ( Handler < Buffer > handler ) ; @ Override WebSocketBase pause ( ) ; @ Override WebSocketBase resume ( ) ; @ Override WebSocketBase endHandler ( Handler < Void > endHandler ) ; @ Override WebSocketBase write ( Buffer data ) ; @ Override WebSocketBase setWriteQueueMaxSize ( int maxSize ) ; @ Override WebSocketBase drainHandler ( Handler < Void > handler ) ; String binaryHandlerID ( ) ; String textHandlerID ( ) ; @ Fluent WebSocketBase writeFrame ( WebSocketFrame frame ) ; @ Fluent WebSocketBase writeFinalTextFrame ( String text ) ; @ Fluent WebSocketBase writeFinalBinaryFrame ( Buffer data ) ; @ Fluent WebSocketBase writeBinaryMessage ( Buffer data ) ; @ Fluent WebSocketBase closeHandler ( Handler < Void > handler ) ; @ Fluent WebSocketBase frameHandler ( Handler < WebSocketFrame > handler ) ; void close ( ) ; @ CacheReturn SocketAddress remoteAddress ( ) ; @ CacheReturn SocketAddress localAddress ( ) ; }
package io . vertx . core . http ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . buffer . Buffer ; import io . vertx . codegen . annotations . CacheReturn ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . streams . ReadStream ; import io . vertx . core . streams . WriteStream ; @ VertxGen public interface HttpClientRequest extends WriteStream < Buffer > , ReadStream < HttpClientResponse > { @ Override HttpClientRequest exceptionHandler ( Handler < Throwable > handler ) ; @ Override HttpClientRequest write ( Buffer data ) ; @ Override HttpClientRequest setWriteQueueMaxSize ( int maxSize ) ; @ Override HttpClientRequest drainHandler ( Handler < Void > handler ) ; @ Override HttpClientRequest handler ( Handler < HttpClientResponse > handler ) ; @ Override HttpClientRequest pause ( ) ; @ Override HttpClientRequest resume ( ) ; @ Override HttpClientRequest endHandler ( Handler < Void > endHandler ) ; @ Fluent HttpClientRequest setChunked ( boolean chunked ) ; boolean isChunked ( ) ; HttpMethod method ( ) ; String uri ( ) ; @ CacheReturn MultiMap headers ( ) ; @ Fluent HttpClientRequest putHeader ( String name , String value ) ; @ GenIgnore HttpClientRequest putHeader ( CharSequence name , CharSequence value ) ; @ GenIgnore HttpClientRequest putHeader ( String name , Iterable < String > values ) ; @ GenIgnore HttpClientRequest putHeader ( CharSequence name , Iterable < CharSequence > values ) ; @ Fluent HttpClientRequest write ( String chunk ) ; @ Fluent HttpClientRequest write ( String chunk , String enc ) ; @ Fluent HttpClientRequest continueHandler ( Handler < Void > handler ) ; @ Fluent HttpClientRequest sendHead ( ) ; void end ( String chunk ) ; void end ( String chunk , String enc ) ; void end ( Buffer chunk ) ; void end ( ) ; @ Fluent HttpClientRequest setTimeout ( long timeoutMs ) ; }
package io . vertx . core . http ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . metrics . Measured ; @ VertxGen public interface HttpClient extends Measured { HttpClientRequest request ( HttpMethod method , int port , String host , String requestURI ) ; HttpClientRequest request ( HttpMethod method , String host , String requestURI ) ; HttpClientRequest request ( HttpMethod method , int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest request ( HttpMethod method , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest request ( HttpMethod method , String requestURI ) ; HttpClientRequest request ( HttpMethod method , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest requestAbs ( HttpMethod method , String absoluteURI ) ; HttpClientRequest requestAbs ( HttpMethod method , String absoluteURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest get ( int port , String host , String requestURI ) ; HttpClientRequest get ( String host , String requestURI ) ; HttpClientRequest get ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest get ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest get ( String requestURI ) ; HttpClientRequest get ( String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest getAbs ( String absoluteURI ) ; HttpClientRequest getAbs ( String absoluteURI , Handler < HttpClientResponse > responseHandler ) ; HttpClient getNow ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClient getNow ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClient getNow ( String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest post ( int port , String host , String requestURI ) ; HttpClientRequest post ( String host , String requestURI ) ; HttpClientRequest post ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest post ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest post ( String requestURI ) ; HttpClientRequest post ( String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest postAbs ( String absoluteURI ) ; HttpClientRequest postAbs ( String absoluteURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest head ( int port , String host , String requestURI ) ; HttpClientRequest head ( String host , String requestURI ) ; HttpClientRequest head ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest head ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest head ( String requestURI ) ; HttpClientRequest head ( String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest headAbs ( String absoluteURI ) ; HttpClientRequest headAbs ( String absoluteURI , Handler < HttpClientResponse > responseHandler ) ; HttpClient headNow ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClient headNow ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClient headNow ( String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest options ( int port , String host , String requestURI ) ; HttpClientRequest options ( String host , String requestURI ) ; HttpClientRequest options ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest options ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest options ( String requestURI ) ; HttpClientRequest options ( String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest optionsAbs ( String absoluteURI ) ; HttpClientRequest optionsAbs ( String absoluteURI , Handler < HttpClientResponse > responseHandler ) ; HttpClient optionsNow ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClient optionsNow ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClient optionsNow ( String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest put ( int port , String host , String requestURI ) ; HttpClientRequest put ( String host , String requestURI ) ; HttpClientRequest put ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest put ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest put ( String requestURI ) ; HttpClientRequest put ( String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest putAbs ( String absoluteURI ) ; HttpClientRequest putAbs ( String absoluteURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest delete ( int port , String host , String requestURI ) ; HttpClientRequest delete ( String host , String requestURI ) ; HttpClientRequest delete ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest delete ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest delete ( String requestURI ) ; HttpClientRequest delete ( String requestURI , Handler < HttpClientResponse > responseHandler ) ; HttpClientRequest deleteAbs ( String absoluteURI ) ; HttpClientRequest deleteAbs ( String absoluteURI , Handler < HttpClientResponse > responseHandler ) ; HttpClient websocket ( int port , String host , String requestURI , Handler < WebSocket > wsConnect ) ; HttpClient websocket ( String host , String requestURI , Handler < WebSocket > wsConnect ) ; HttpClient websocket ( int port , String host , String requestURI , MultiMap headers , Handler < WebSocket > wsConnect ) ; HttpClient websocket ( String host , String requestURI , MultiMap headers , Handler < WebSocket > wsConnect ) ; HttpClient websocket ( int port , String host , String requestURI , MultiMap headers , WebsocketVersion version , Handler < WebSocket > wsConnect ) ; HttpClient websocket ( String host , String requestURI , MultiMap headers , WebsocketVersion version , Handler < WebSocket > wsConnect ) ; HttpClient websocket ( int port , String host , String requestURI , MultiMap headers , WebsocketVersion version , String subProtocols , Handler < WebSocket > wsConnect ) ; HttpClient websocket ( String host , String requestURI , MultiMap headers , WebsocketVersion version , String subProtocols , Handler < WebSocket > wsConnect ) ; HttpClient websocket ( String requestURI , Handler < WebSocket > wsConnect ) ; HttpClient websocket ( String requestURI , MultiMap headers , Handler < WebSocket > wsConnect ) ; HttpClient websocket ( String requestURI , MultiMap headers , WebsocketVersion version , Handler < WebSocket > wsConnect ) ; HttpClient websocket ( String requestURI , MultiMap headers , WebsocketVersion version , String subProtocols , Handler < WebSocket > wsConnect ) ; WebSocketStream websocketStream ( int port , String host , String requestURI ) ; WebSocketStream websocketStream ( String host , String requestURI ) ; WebSocketStream websocketStream ( int port , String host , String requestURI , MultiMap headers ) ; WebSocketStream websocketStream ( String host , String requestURI , MultiMap headers ) ; WebSocketStream websocketStream ( int port , String host , String requestURI , MultiMap headers , WebsocketVersion version ) ; WebSocketStream websocketStream ( String host , String requestURI , MultiMap headers , WebsocketVersion version ) ; WebSocketStream websocketStream ( int port , String host , String requestURI , MultiMap headers , WebsocketVersion version , String subProtocols ) ; WebSocketStream websocketStream ( String host , String requestURI , MultiMap headers , WebsocketVersion version , String subProtocols ) ; WebSocketStream websocketStream ( String requestURI ) ; WebSocketStream websocketStream ( String requestURI , MultiMap headers ) ; WebSocketStream websocketStream ( String requestURI , MultiMap headers , WebsocketVersion version ) ; WebSocketStream websocketStream ( String requestURI , MultiMap headers , WebsocketVersion version , String subProtocols ) ; void close ( ) ; }
package io . vertx . core . http ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; @ VertxGen public interface WebSocket extends WebSocketBase { @ Override WebSocket exceptionHandler ( Handler < Throwable > handler ) ; @ Override WebSocket handler ( Handler < Buffer > handler ) ; @ Override WebSocket pause ( ) ; @ Override WebSocket resume ( ) ; @ Override WebSocket endHandler ( Handler < Void > endHandler ) ; @ Override WebSocket write ( Buffer data ) ; @ Override WebSocket setWriteQueueMaxSize ( int maxSize ) ; @ Override WebSocket drainHandler ( Handler < Void > handler ) ; @ Override WebSocket writeFrame ( WebSocketFrame frame ) ; @ Override WebSocket writeFinalTextFrame ( String text ) ; @ Override WebSocket writeFinalBinaryFrame ( Buffer data ) ; @ Override WebSocket writeBinaryMessage ( Buffer data ) ; @ Override WebSocket closeHandler ( Handler < Void > handler ) ; @ Override WebSocket frameHandler ( Handler < WebSocketFrame > handler ) ; }
package io . vertx . core . http ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; import io . vertx . core . streams . ReadStream ; @ VertxGen public interface ServerWebSocketStream extends ReadStream < ServerWebSocket > { @ Override ServerWebSocketStream exceptionHandler ( Handler < Throwable > handler ) ; @ Override ServerWebSocketStream handler ( Handler < ServerWebSocket > handler ) ; @ Override ServerWebSocketStream pause ( ) ; @ Override ServerWebSocketStream resume ( ) ; @ Override ServerWebSocketStream endHandler ( Handler < Void > endHandler ) ; }
package io . vertx . test . core ; import io . vertx . core . Handler ; import io . vertx . core . http . HttpClient ; import io . vertx . core . http . HttpServer ; import io . vertx . core . http . HttpServerOptions ; import java . util . concurrent . CountDownLatch ; public class HttpTestBase extends VertxTestBase { public static final String DEFAULT_HTTP_HOST = "localhost" ; public static final int DEFAULT_HTTP_PORT = 8080 ; public static final String DEFAULT_TEST_URI = "some-uri" ; protected HttpServer server ; protected HttpClient client ; public void setUp ( ) throws Exception { super . setUp ( ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( DEFAULT_HTTP_PORT ) . setHost ( DEFAULT_HTTP_HOST ) ) ; } protected void tearDown ( ) throws Exception { if ( client != null ) { client . close ( ) ; } if ( server != null ) { CountDownLatch latch = new CountDownLatch ( 1 ) ; server . close ( ( asyncResult ) - > { assertTrue ( asyncResult . succeeded ( ) ) ; latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; } super . tearDown ( ) ; } @ SuppressWarnings ( "unchecked" ) protected < E > Handler < E > noOpHandler ( ) { return noOp ; } private static final Handler noOp = e - > { } ; }
package io . vertx . core . http ; import io . vertx . codegen . annotations . CacheReturn ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . buffer . Buffer ; import javax . net . ssl . SSLPeerUnverifiedException ; import javax . security . cert . X509Certificate ; @ VertxGen public interface ServerWebSocket extends WebSocketBase { @ Override ServerWebSocket exceptionHandler ( Handler < Throwable > handler ) ; @ Override ServerWebSocket handler ( Handler < Buffer > handler ) ; @ Override ServerWebSocket pause ( ) ; @ Override ServerWebSocket resume ( ) ; @ Override ServerWebSocket endHandler ( Handler < Void > endHandler ) ; @ Override ServerWebSocket write ( Buffer data ) ; @ Override ServerWebSocket setWriteQueueMaxSize ( int maxSize ) ; @ Override ServerWebSocket drainHandler ( Handler < Void > handler ) ; @ Override ServerWebSocket writeFrame ( WebSocketFrame frame ) ; @ Override ServerWebSocket writeFinalTextFrame ( String text ) ; @ Override ServerWebSocket writeFinalBinaryFrame ( Buffer data ) ; @ Override ServerWebSocket writeBinaryMessage ( Buffer data ) ; @ Override ServerWebSocket closeHandler ( Handler < Void > handler ) ; @ Override ServerWebSocket frameHandler ( Handler < WebSocketFrame > handler ) ; String uri ( ) ; String path ( ) ; String query ( ) ; @ CacheReturn MultiMap headers ( ) ; void reject ( ) ; @ GenIgnore X509Certificate [ ] peerCertificateChain ( ) throws SSLPeerUnverifiedException ; }
package io . vertx . core . http ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . metrics . Measured ; @ VertxGen public interface HttpServer extends Measured { HttpServerRequestStream requestStream ( ) ; HttpServer requestHandler ( Handler < HttpServerRequest > handler ) ; @ GenIgnore Handler < HttpServerRequest > requestHandler ( ) ; ServerWebSocketStream websocketStream ( ) ; HttpServer websocketHandler ( Handler < ServerWebSocket > handler ) ; @ GenIgnore Handler < ServerWebSocket > websocketHandler ( ) ; @ Fluent HttpServer listen ( ) ; @ Fluent HttpServer listen ( int port , String host ) ; @ Fluent HttpServer listen ( int port , String host , Handler < AsyncResult < HttpServer > > listenHandler ) ; @ Fluent HttpServer listen ( int port ) ; @ Fluent HttpServer listen ( int port , Handler < AsyncResult < HttpServer > > listenHandler ) ; @ Fluent HttpServer listen ( Handler < AsyncResult < HttpServer > > listenHandler ) ; void close ( ) ; void close ( Handler < AsyncResult < Void > > completionHandler ) ; }
package io . vertx . core . http ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . json . JsonObject ; import io . vertx . core . net . ClientOptionsBase ; import io . vertx . core . net . JksOptions ; import io . vertx . core . net . PemTrustOptions ; import io . vertx . core . net . PemKeyCertOptions ; import io . vertx . core . net . PfxOptions ; import io . vertx . core . net . TCPSSLOptions ; @ DataObject public class HttpClientOptions extends ClientOptionsBase { public static final int DEFAULT_MAX_POOL_SIZE = 5 ; public static final boolean DEFAULT_KEEP_ALIVE = true ; public static final boolean DEFAULT_PIPELINING = false ; public static final boolean DEFAULT_TRY_USE_COMPRESSION = false ; public static final boolean DEFAULT_VERIFY_HOST = true ; public static final int DEFAULT_MAX_WEBSOCKET_FRAME_SIZE = 65536 ; public static final String DEFAULT_DEFAULT_HOST = "localhost" ; public static final int DEFAULT_DEFAULT_PORT = 80 ; private boolean verifyHost = true ; private int maxPoolSize ; private boolean keepAlive ; private boolean pipelining ; private boolean tryUseCompression ; private int maxWebsocketFrameSize ; private String defaultHost ; private int defaultPort ; public HttpClientOptions ( ) { super ( ) ; verifyHost = DEFAULT_VERIFY_HOST ; maxPoolSize = DEFAULT_MAX_POOL_SIZE ; keepAlive = DEFAULT_KEEP_ALIVE ; pipelining = DEFAULT_PIPELINING ; tryUseCompression = DEFAULT_TRY_USE_COMPRESSION ; maxWebsocketFrameSize = DEFAULT_MAX_WEBSOCKET_FRAME_SIZE ; defaultHost = DEFAULT_DEFAULT_HOST ; defaultPort = DEFAULT_DEFAULT_PORT ; } public HttpClientOptions ( HttpClientOptions other ) { super ( other ) ; this . verifyHost = other . isVerifyHost ( ) ; this . maxPoolSize = other . getMaxPoolSize ( ) ; this . keepAlive = other . isKeepAlive ( ) ; this . pipelining = other . isPipelining ( ) ; this . tryUseCompression = other . isTryUseCompression ( ) ; this . maxWebsocketFrameSize = other . maxWebsocketFrameSize ; this . defaultHost = other . defaultHost ; this . defaultPort = other . defaultPort ; } public HttpClientOptions ( JsonObject json ) { super ( json ) ; this . verifyHost = json . getBoolean ( "verifyHost" , DEFAULT_VERIFY_HOST ) ; this . maxPoolSize = json . getInteger ( "maxPoolSize" , DEFAULT_MAX_POOL_SIZE ) ; this . keepAlive = json . getBoolean ( "keepAlive" , DEFAULT_KEEP_ALIVE ) ; this . pipelining = json . getBoolean ( "pipelining" , DEFAULT_PIPELINING ) ; this . tryUseCompression = json . getBoolean ( "tryUseCompression" , DEFAULT_TRY_USE_COMPRESSION ) ; this . maxWebsocketFrameSize = json . getInteger ( "maxWebsocketFrameSize" , DEFAULT_MAX_WEBSOCKET_FRAME_SIZE ) ; this . defaultHost = json . getString ( "defaultHost" , DEFAULT_DEFAULT_HOST ) ; this . defaultPort = json . getInteger ( "defaultPort" , DEFAULT_DEFAULT_PORT ) ; } @ Override public HttpClientOptions setSendBufferSize ( int sendBufferSize ) { super . setSendBufferSize ( sendBufferSize ) ; return this ; } @ Override public HttpClientOptions setReceiveBufferSize ( int receiveBufferSize ) { super . setReceiveBufferSize ( receiveBufferSize ) ; return this ; } @ Override public HttpClientOptions setReuseAddress ( boolean reuseAddress ) { super . setReuseAddress ( reuseAddress ) ; return this ; } @ Override public HttpClientOptions setTrafficClass ( int trafficClass ) { super . setTrafficClass ( trafficClass ) ; return this ; } @ Override public HttpClientOptions setTcpNoDelay ( boolean tcpNoDelay ) { super . setTcpNoDelay ( tcpNoDelay ) ; return this ; } @ Override public HttpClientOptions setTcpKeepAlive ( boolean tcpKeepAlive ) { super . setTcpKeepAlive ( tcpKeepAlive ) ; return this ; } @ Override public HttpClientOptions setSoLinger ( int soLinger ) { super . setSoLinger ( soLinger ) ; return this ; } @ Override public HttpClientOptions setUsePooledBuffers ( boolean usePooledBuffers ) { super . setUsePooledBuffers ( usePooledBuffers ) ; return this ; } @ Override public HttpClientOptions setIdleTimeout ( int idleTimeout ) { super . setIdleTimeout ( idleTimeout ) ; return this ; } @ Override public HttpClientOptions setSsl ( boolean ssl ) { super . setSsl ( ssl ) ; return this ; } @ Override public HttpClientOptions setKeyStoreOptions ( JksOptions options ) { super . setKeyStoreOptions ( options ) ; return this ; } @ Override public HttpClientOptions setPfxKeyCertOptions ( PfxOptions options ) { return ( HttpClientOptions ) super . setPfxKeyCertOptions ( options ) ; } @ Override public HttpClientOptions setPemKeyCertOptions ( PemKeyCertOptions options ) { return ( HttpClientOptions ) super . setPemKeyCertOptions ( options ) ; } @ Override public HttpClientOptions setTrustStoreOptions ( JksOptions options ) { super . setTrustStoreOptions ( options ) ; return this ; } @ Override public HttpClientOptions setPfxTrustOptions ( PfxOptions options ) { return ( HttpClientOptions ) super . setPfxTrustOptions ( options ) ; } @ Override public HttpClientOptions setPemTrustOptions ( PemTrustOptions options ) { return ( HttpClientOptions ) super . setPemTrustOptions ( options ) ; } @ Override public HttpClientOptions addEnabledCipherSuite ( String suite ) { super . addEnabledCipherSuite ( suite ) ; return this ; } @ Override public HttpClientOptions addCrlPath ( String crlPath ) throws NullPointerException { return ( HttpClientOptions ) super . addCrlPath ( crlPath ) ; } @ Override public HttpClientOptions addCrlValue ( Buffer crlValue ) throws NullPointerException { return ( HttpClientOptions ) super . addCrlValue ( crlValue ) ; } @ Override public HttpClientOptions setConnectTimeout ( int connectTimeout ) { super . setConnectTimeout ( connectTimeout ) ; return this ; } @ Override public HttpClientOptions setTrustAll ( boolean trustAll ) { super . setTrustAll ( trustAll ) ; return this ; } public int getMaxPoolSize ( ) { return maxPoolSize ; } public HttpClientOptions setMaxPoolSize ( int maxPoolSize ) { if ( maxPoolSize < 1 ) { throw new IllegalArgumentException ( "maxPoolSize must be > 0" ) ; } this . maxPoolSize = maxPoolSize ; return this ; } public boolean isKeepAlive ( ) { return keepAlive ; } public HttpClientOptions setKeepAlive ( boolean keepAlive ) { this . keepAlive = keepAlive ; return this ; } public boolean isPipelining ( ) { return pipelining ; } public HttpClientOptions setPipelining ( boolean pipelining ) { this . pipelining = pipelining ; return this ; } public boolean isVerifyHost ( ) { return verifyHost ; } public HttpClientOptions setVerifyHost ( boolean verifyHost ) { this . verifyHost = verifyHost ; return this ; } public boolean isTryUseCompression ( ) { return tryUseCompression ; } public HttpClientOptions setTryUseCompression ( boolean tryUseCompression ) { this . tryUseCompression = tryUseCompression ; return this ; } public int getMaxWebsocketFrameSize ( ) { return maxWebsocketFrameSize ; } public HttpClientOptions setMaxWebsocketFrameSize ( int maxWebsocketFrameSize ) { this . maxWebsocketFrameSize = maxWebsocketFrameSize ; return this ; } public String getDefaultHost ( ) { return defaultHost ; } public HttpClientOptions setDefaultHost ( String defaultHost ) { this . defaultHost = defaultHost ; return this ; } public int getDefaultPort ( ) { return defaultPort ; } public HttpClientOptions setDefaultPort ( int defaultPort ) { this . defaultPort = defaultPort ; return this ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof HttpClientOptions ) ) return false ; if ( ! super . equals ( o ) ) return false ; HttpClientOptions that = ( HttpClientOptions ) o ; if ( defaultPort != that . defaultPort ) return false ; if ( keepAlive != that . keepAlive ) return false ; if ( maxPoolSize != that . maxPoolSize ) return false ; if ( maxWebsocketFrameSize != that . maxWebsocketFrameSize ) return false ; if ( pipelining != that . pipelining ) return false ; if ( tryUseCompression != that . tryUseCompression ) return false ; if ( verifyHost != that . verifyHost ) return false ; if ( ! defaultHost . equals ( that . defaultHost ) ) return false ; return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + ( verifyHost ? 1 : 0 ) ; result = 31 * result + maxPoolSize ; result = 31 * result + ( keepAlive ? 1 : 0 ) ; result = 31 * result + ( pipelining ? 1 : 0 ) ; result = 31 * result + ( tryUseCompression ? 1 : 0 ) ; result = 31 * result + maxWebsocketFrameSize ; result = 31 * result + defaultHost . hashCode ( ) ; result = 31 * result + defaultPort ; return result ; } }
package io . vertx . core . http ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; import io . vertx . core . streams . ReadStream ; @ VertxGen public interface WebSocketStream extends ReadStream < WebSocket > { @ Override WebSocketStream exceptionHandler ( Handler < Throwable > handler ) ; @ Override WebSocketStream handler ( Handler < WebSocket > handler ) ; @ Override WebSocketStream pause ( ) ; @ Override WebSocketStream resume ( ) ; @ Override WebSocketStream endHandler ( Handler < Void > endHandler ) ; }
package io . vertx . core . http ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; import io . vertx . core . streams . ReadStream ; @ VertxGen public interface HttpServerRequestStream extends ReadStream < HttpServerRequest > { @ Override HttpServerRequestStream exceptionHandler ( Handler < Throwable > handler ) ; @ Override HttpServerRequestStream handler ( Handler < HttpServerRequest > handler ) ; @ Override HttpServerRequestStream pause ( ) ; @ Override HttpServerRequestStream resume ( ) ; @ Override HttpServerRequestStream endHandler ( Handler < Void > endHandler ) ; }
package io . vertx . core . http ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . json . JsonObject ; import io . vertx . core . net . * ; @ DataObject public class HttpServerOptions extends NetServerOptions { public static final int DEFAULT_PORT = 80 ; public static final boolean DEFAULT_COMPRESSION_SUPPORTED = false ; public static final int DEFAULT_MAX_WEBSOCKET_FRAME_SIZE = 65536 ; public static final boolean DEFAULT_HANDLE_100_CONTINE_AUTOMATICALLY = false ; private boolean compressionSupported ; private int maxWebsocketFrameSize ; private String websocketSubProtocols ; private boolean handle100ContinueAutomatically ; public HttpServerOptions ( ) { super ( ) ; setPort ( DEFAULT_PORT ) ; compressionSupported = DEFAULT_COMPRESSION_SUPPORTED ; maxWebsocketFrameSize = DEFAULT_MAX_WEBSOCKET_FRAME_SIZE ; handle100ContinueAutomatically = DEFAULT_HANDLE_100_CONTINE_AUTOMATICALLY ; } public HttpServerOptions ( HttpServerOptions other ) { super ( other ) ; this . compressionSupported = other . isCompressionSupported ( ) ; this . maxWebsocketFrameSize = other . getMaxWebsocketFrameSize ( ) ; this . websocketSubProtocols = other . getWebsocketSubProtocols ( ) ; this . handle100ContinueAutomatically = other . handle100ContinueAutomatically ; } public HttpServerOptions ( JsonObject json ) { super ( json ) ; this . compressionSupported = json . getBoolean ( "compressionSupported" , DEFAULT_COMPRESSION_SUPPORTED ) ; this . maxWebsocketFrameSize = json . getInteger ( "maxWebsocketFrameSize" , DEFAULT_MAX_WEBSOCKET_FRAME_SIZE ) ; this . websocketSubProtocols = json . getString ( "websocketSubProtocols" , null ) ; this . handle100ContinueAutomatically = json . getBoolean ( "handle100ContinueAutomatically" , DEFAULT_HANDLE_100_CONTINE_AUTOMATICALLY ) ; setPort ( json . getInteger ( "port" , DEFAULT_PORT ) ) ; } @ Override public HttpServerOptions setSendBufferSize ( int sendBufferSize ) { super . setSendBufferSize ( sendBufferSize ) ; return this ; } @ Override public HttpServerOptions setReceiveBufferSize ( int receiveBufferSize ) { super . setReceiveBufferSize ( receiveBufferSize ) ; return this ; } @ Override public HttpServerOptions setReuseAddress ( boolean reuseAddress ) { super . setReuseAddress ( reuseAddress ) ; return this ; } @ Override public HttpServerOptions setTrafficClass ( int trafficClass ) { super . setTrafficClass ( trafficClass ) ; return this ; } @ Override public HttpServerOptions setTcpNoDelay ( boolean tcpNoDelay ) { super . setTcpNoDelay ( tcpNoDelay ) ; return this ; } @ Override public HttpServerOptions setTcpKeepAlive ( boolean tcpKeepAlive ) { super . setTcpKeepAlive ( tcpKeepAlive ) ; return this ; } @ Override public HttpServerOptions setSoLinger ( int soLinger ) { super . setSoLinger ( soLinger ) ; return this ; } @ Override public HttpServerOptions setUsePooledBuffers ( boolean usePooledBuffers ) { super . setUsePooledBuffers ( usePooledBuffers ) ; return this ; } @ Override public HttpServerOptions setIdleTimeout ( int idleTimeout ) { super . setIdleTimeout ( idleTimeout ) ; return this ; } @ Override public HttpServerOptions setSsl ( boolean ssl ) { super . setSsl ( ssl ) ; return this ; } @ Override public HttpServerOptions setKeyStoreOptions ( JksOptions options ) { super . setKeyStoreOptions ( options ) ; return this ; } @ Override public HttpServerOptions setPfxKeyCertOptions ( PfxOptions options ) { return ( HttpServerOptions ) super . setPfxKeyCertOptions ( options ) ; } @ Override public HttpServerOptions setPemKeyCertOptions ( PemKeyCertOptions options ) { return ( HttpServerOptions ) super . setPemKeyCertOptions ( options ) ; } @ Override public HttpServerOptions setTrustStoreOptions ( JksOptions options ) { super . setTrustStoreOptions ( options ) ; return this ; } @ Override public HttpServerOptions setPemTrustOptions ( PemTrustOptions options ) { return ( HttpServerOptions ) super . setPemTrustOptions ( options ) ; } @ Override public HttpServerOptions setPfxTrustOptions ( PfxOptions options ) { return ( HttpServerOptions ) super . setPfxTrustOptions ( options ) ; } @ Override public HttpServerOptions addEnabledCipherSuite ( String suite ) { super . addEnabledCipherSuite ( suite ) ; return this ; } @ Override public HttpServerOptions addCrlPath ( String crlPath ) throws NullPointerException { return ( HttpServerOptions ) super . addCrlPath ( crlPath ) ; } @ Override public HttpServerOptions addCrlValue ( Buffer crlValue ) throws NullPointerException { return ( HttpServerOptions ) super . addCrlValue ( crlValue ) ; } @ Override public HttpServerOptions setAcceptBacklog ( int acceptBacklog ) { super . setAcceptBacklog ( acceptBacklog ) ; return this ; } public HttpServerOptions setPort ( int port ) { super . setPort ( port ) ; return this ; } @ Override public HttpServerOptions setHost ( String host ) { super . setHost ( host ) ; return this ; } public boolean isCompressionSupported ( ) { return compressionSupported ; } public HttpServerOptions setCompressionSupported ( boolean compressionSupported ) { this . compressionSupported = compressionSupported ; return this ; } public int getMaxWebsocketFrameSize ( ) { return maxWebsocketFrameSize ; } public HttpServerOptions setMaxWebsocketFrameSize ( int maxWebsocketFrameSize ) { this . maxWebsocketFrameSize = maxWebsocketFrameSize ; return this ; } public HttpServerOptions setWebsocketSubProtocol ( String subProtocols ) { websocketSubProtocols = subProtocols ; return this ; } public String getWebsocketSubProtocols ( ) { return websocketSubProtocols ; } @ Override public HttpServerOptions setClientAuthRequired ( boolean clientAuthRequired ) { super . setClientAuthRequired ( clientAuthRequired ) ; return this ; } public boolean isHandle100ContinueAutomatically ( ) { return handle100ContinueAutomatically ; } public HttpServerOptions setHandle100ContinueAutomatically ( boolean handle100ContinueAutomatically ) { this . handle100ContinueAutomatically = handle100ContinueAutomatically ; return this ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; if ( ! super . equals ( o ) ) return false ; HttpServerOptions that = ( HttpServerOptions ) o ; if ( compressionSupported != that . compressionSupported ) return false ; if ( maxWebsocketFrameSize != that . maxWebsocketFrameSize ) return false ; if ( handle100ContinueAutomatically != that . handle100ContinueAutomatically ) return false ; return ! ( websocketSubProtocols != null ? ! websocketSubProtocols . equals ( that . websocketSubProtocols ) : that . websocketSubProtocols != null ) ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + ( compressionSupported ? 1 : 0 ) ; result = 31 * result + maxWebsocketFrameSize ; result = 31 * result + ( websocketSubProtocols != null ? websocketSubProtocols . hashCode ( ) : 0 ) ; result = 31 * result + ( handle100ContinueAutomatically ? 1 : 0 ) ; return result ; } }
package io . vertx . core . http ; import io . vertx . core . MultiMap ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Set ; import java . util . TreeSet ; public final class CaseInsensitiveHeaders implements MultiMap { private static final int BUCKET_SIZE = 17 ; private static int hash ( String name ) { int h = 0 ; for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { char c = c ( name , i ) ; h = 31 * h + c ; } if ( h > 0 ) { return h ; } else if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } else { return - h ; } } private static char c ( String name , int i ) { char c = name . charAt ( i ) ; if ( c >= 'A' && c <= 'Z' ) { c += 32 ; } return c ; } private MultiMap set0 ( Iterable < Map . Entry < String , String > > map ) { clear ( ) ; for ( Map . Entry < String , String > entry : map ) { add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; } @ Override public MultiMap setAll ( MultiMap headers ) { return set0 ( headers ) ; } @ Override public MultiMap setAll ( Map < String , String > headers ) { return set0 ( headers . entrySet ( ) ) ; } @ Override public int size ( ) { return names ( ) . size ( ) ; } private static boolean eq ( String name1 , String name2 ) { int nameLen = name1 . length ( ) ; if ( nameLen != name2 . length ( ) ) { return false ; } for ( int i = nameLen - 1 ; i >= 0 ; i -- ) { char c1 = name1 . charAt ( i ) ; char c2 = name2 . charAt ( i ) ; if ( c1 != c2 ) { c1 = c1 ( c1 ) ; c2 = c2 ( c2 ) ; if ( c1 != c2 ) { return false ; } } } return true ; } private static char c2 ( char c2 ) { if ( c2 >= 'A' && c2 <= 'Z' ) { c2 += 32 ; } return c2 ; } private static char c1 ( char c1 ) { if ( c1 >= 'A' && c1 <= 'Z' ) { c1 += 32 ; } return c1 ; } private static int index ( int hash ) { return hash % BUCKET_SIZE ; } private final MapEntry [ ] entries = new MapEntry [ BUCKET_SIZE ] ; private final MapEntry head = new MapEntry ( - 1 , null , null ) ; public CaseInsensitiveHeaders ( ) { head . before = head . after = head ; } @ Override public MultiMap add ( final String name , final String strVal ) { int h = hash ( name ) ; int i = index ( h ) ; add0 ( h , i , name , strVal ) ; return this ; } @ Override public MultiMap add ( String name , Iterable < String > values ) { int h = hash ( name ) ; int i = index ( h ) ; for ( String vstr : values ) { add0 ( h , i , name , vstr ) ; } return this ; } @ Override public MultiMap addAll ( MultiMap headers ) { for ( Map . Entry < String , String > entry : headers . entries ( ) ) { add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; } @ Override public MultiMap addAll ( Map < String , String > map ) { for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; } private void add0 ( int h , int i , final String name , final String value ) { MapEntry e = entries [ i ] ; MapEntry newEntry ; entries [ i ] = newEntry = new MapEntry ( h , name , value ) ; newEntry . next = e ; newEntry . addBefore ( head ) ; } @ Override public MultiMap remove ( final String name ) { Objects . requireNonNull ( name , "name" ) ; int h = hash ( name ) ; int i = index ( h ) ; remove0 ( h , i , name ) ; return this ; } private void remove0 ( int h , int i , String name ) { MapEntry e = entries [ i ] ; if ( e == null ) { return ; } for ( ; ; ) { if ( e . hash == h && eq ( name , e . key ) ) { e . remove ( ) ; MapEntry next = e . next ; if ( next != null ) { entries [ i ] = next ; e = next ; } else { entries [ i ] = null ; return ; } } else { break ; } } for ( ; ; ) { MapEntry next = e . next ; if ( next == null ) { break ; } if ( next . hash == h && eq ( name , next . key ) ) { e . next = next . next ; next . remove ( ) ; } else { e = next ; } } } @ Override public MultiMap set ( final String name , final String strVal ) { int h = hash ( name ) ; int i = index ( h ) ; remove0 ( h , i , name ) ; add0 ( h , i , name , strVal ) ; return this ; } @ Override public MultiMap set ( final String name , final Iterable < String > values ) { Objects . requireNonNull ( values , "values" ) ; int h = hash ( name ) ; int i = index ( h ) ; remove0 ( h , i , name ) ; for ( String v : values ) { if ( v == null ) { break ; } add0 ( h , i , name , v ) ; } return this ; } @ Override public MultiMap clear ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; } @ Override public String get ( final String name ) { Objects . requireNonNull ( name , "name" ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { return e . getValue ( ) ; } e = e . next ; } return null ; } @ Override public List < String > getAll ( final String name ) { Objects . requireNonNull ( name , "name" ) ; LinkedList < String > values = new LinkedList < > ( ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; } @ Override public List < Map . Entry < String , String > > entries ( ) { List < Map . Entry < String , String > > all = new LinkedList < > ( ) ; MapEntry e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; } @ Override public Iterator < Map . Entry < String , String > > iterator ( ) { return entries ( ) . iterator ( ) ; } @ Override public boolean contains ( String name ) { return get ( name ) != null ; } @ Override public boolean isEmpty ( ) { return head == head . after ; } @ Override public Set < String > names ( ) { Set < String > names = new TreeSet < > ( String . CASE_INSENSITIVE_ORDER ) ; MapEntry e = head . after ; while ( e != head ) { names . add ( e . getKey ( ) ) ; e = e . after ; } return names ; } @ Override public String get ( CharSequence name ) { return get ( name . toString ( ) ) ; } @ Override public List < String > getAll ( CharSequence name ) { return getAll ( name . toString ( ) ) ; } @ Override public boolean contains ( CharSequence name ) { return contains ( name . toString ( ) ) ; } @ Override public MultiMap add ( CharSequence name , CharSequence value ) { return add ( name . toString ( ) , value . toString ( ) ) ; } @ Override public MultiMap add ( CharSequence name , Iterable < CharSequence > values ) { String n = name . toString ( ) ; for ( CharSequence seq : values ) { add ( n , seq . toString ( ) ) ; } return this ; } @ Override public MultiMap set ( CharSequence name , CharSequence value ) { return set ( name . toString ( ) , value . toString ( ) ) ; } @ Override public MultiMap set ( CharSequence name , Iterable < CharSequence > values ) { remove ( name ) ; String n = name . toString ( ) ; for ( CharSequence seq : values ) { add ( n , seq . toString ( ) ) ; } return this ; } @ Override public MultiMap remove ( CharSequence name ) { return remove ( name . toString ( ) ) ; } public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Map . Entry < String , String > entry : this ) { sb . append ( entry ) . append ( '\n' ) ; } return sb . toString ( ) ; } private static final class MapEntry implements Map . Entry < String , String > { final int hash ; final String key ; String value ; MapEntry next ; MapEntry before , after ; MapEntry ( int hash , String key , String value ) { this . hash = hash ; this . key = key ; this . value = value ; } void remove ( ) { before . after = after ; after . before = before ; } void addBefore ( MapEntry e ) { after = e ; before = e . before ; before . after = this ; after . before = this ; } @ Override public String getKey ( ) { return key ; } @ Override public String getValue ( ) { return value ; } @ Override public String setValue ( String value ) { Objects . requireNonNull ( value , "value" ) ; String oldValue = this . value ; this . value = value ; return oldValue ; } @ Override public String toString ( ) { return getKey ( ) + ": " + getValue ( ) ; } } }
package io . vertx . core . http . impl ; import io . netty . buffer . ByteBuf ; import io . netty . handler . codec . http . DefaultLastHttpContent ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . handler . codec . http . HttpVersion ; import io . netty . handler . codec . http . LastHttpContent ; class AssembledFullHttpRequest extends AssembledHttpRequest implements FullHttpRequest { public AssembledFullHttpRequest ( HttpRequest request , LastHttpContent content ) { super ( request , content ) ; } public AssembledFullHttpRequest ( HttpRequest request ) { super ( request , LastHttpContent . EMPTY_LAST_CONTENT ) ; } public AssembledFullHttpRequest ( HttpRequest request , ByteBuf buf ) { super ( request , toLastContent ( buf ) ) ; } private static LastHttpContent toLastContent ( ByteBuf buf ) { if ( buf . isReadable ( ) ) { return new DefaultLastHttpContent ( buf , false ) ; } else { return LastHttpContent . EMPTY_LAST_CONTENT ; } } @ Override public AssembledFullHttpRequest setUri ( String uri ) { super . setUri ( uri ) ; return this ; } @ Override public AssembledFullHttpRequest setProtocolVersion ( HttpVersion version ) { super . setProtocolVersion ( version ) ; return this ; } @ Override public AssembledFullHttpRequest setMethod ( HttpMethod method ) { super . setMethod ( method ) ; return this ; } @ Override public AssembledFullHttpRequest duplicate ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public AssembledFullHttpRequest copy ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public HttpHeaders trailingHeaders ( ) { return ( ( LastHttpContent ) content ) . trailingHeaders ( ) ; } @ Override public AssembledFullHttpRequest retain ( ) { super . retain ( ) ; return this ; } @ Override public AssembledFullHttpRequest retain ( int increment ) { super . retain ( increment ) ; return this ; } }
package io . vertx . core . http . impl ; final class UriParser { private UriParser ( ) { } static String path ( String uri ) { int i ; if ( uri . charAt ( 0 ) == '/' ) { i = 0 ; } else { i = uri . indexOf ( "://" ) ; if ( i == - 1 ) { i = 0 ; } else { i = uri . indexOf ( '/' , i + 3 ) ; if ( i == - 1 ) { return "/" ; } } } int queryStart = uri . indexOf ( '?' , i ) ; if ( queryStart == - 1 ) { queryStart = uri . length ( ) ; } return uri . substring ( i , queryStart ) ; } static String query ( String uri ) { int i = uri . indexOf ( '?' ) ; if ( i == - 1 ) { return null ; } else { return uri . substring ( i + 1 , uri . length ( ) ) ; } } }
package io . vertx . core . http . impl ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . handler . codec . http . DefaultHttpContent ; import io . netty . handler . codec . http . HttpContentCompressor ; final class HttpChunkContentCompressor extends HttpContentCompressor { @ Override public void write ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) throws Exception { if ( msg instanceof ByteBuf ) { msg = new DefaultHttpContent ( ( ByteBuf ) msg ) ; } super . write ( ctx , msg , promise ) ; } }
package io . vertx . test . core ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import org . hamcrest . Matcher ; import org . junit . After ; import org . junit . Assert ; import org . junit . Before ; import org . junit . Rule ; import org . junit . internal . ArrayComparisonFailure ; import org . junit . rules . TestName ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . function . BooleanSupplier ; import java . util . function . Consumer ; public class AsyncTestBase { private static final Logger log = LoggerFactory . getLogger ( AsyncTestBase . class ) ; private CountDownLatch latch ; private volatile Throwable throwable ; private volatile Thread thrownThread ; private volatile boolean testCompleteCalled ; private volatile boolean awaitCalled ; private boolean threadChecksEnabled = true ; private volatile boolean tearingDown ; private volatile String mainThreadName ; private Map < String , Exception > threadNames = new ConcurrentHashMap < > ( ) ; @ Rule public TestName name = new TestName ( ) ; protected void setUp ( ) throws Exception { log . info ( "Starting test: " + this . getClass ( ) . getSimpleName ( ) + "#" + name . getMethodName ( ) ) ; mainThreadName = Thread . currentThread ( ) . getName ( ) ; tearingDown = false ; waitFor ( 1 ) ; throwable = null ; testCompleteCalled = false ; awaitCalled = false ; threadNames . clear ( ) ; } protected void tearDown ( ) throws Exception { tearingDown = true ; afterAsyncTestBase ( ) ; } @ Before public void before ( ) throws Exception { setUp ( ) ; } @ After public void after ( ) throws Exception { tearDown ( ) ; } protected synchronized void waitFor ( int count ) { latch = new CountDownLatch ( count ) ; } protected synchronized void waitForMore ( int count ) { latch = new CountDownLatch ( count + ( int ) latch . getCount ( ) ) ; } protected synchronized void complete ( ) { if ( tearingDown ) { throw new IllegalStateException ( "testComplete called after test has completed" ) ; } checkThread ( ) ; if ( testCompleteCalled ) { throw new IllegalStateException ( "already complete" ) ; } latch . countDown ( ) ; if ( latch . getCount ( ) == 0 ) { testCompleteCalled = true ; } } protected void testComplete ( ) { if ( tearingDown ) { throw new IllegalStateException ( "testComplete called after test has completed" ) ; } checkThread ( ) ; if ( testCompleteCalled ) { throw new IllegalStateException ( "testComplete() already called" ) ; } testCompleteCalled = true ; latch . countDown ( ) ; } protected void await ( ) { await ( 2 , TimeUnit . MINUTES ) ; } public void await ( long delay , TimeUnit timeUnit ) { if ( awaitCalled ) { throw new IllegalStateException ( "await() already called" ) ; } awaitCalled = true ; try { boolean ok = latch . await ( delay , timeUnit ) ; if ( ! ok ) { throw new IllegalStateException ( "Timed out in waiting for test complete" ) ; } else { rethrowError ( ) ; } } catch ( InterruptedException e ) { throw new IllegalStateException ( "Test thread was interrupted!" ) ; } } private void rethrowError ( ) { if ( throwable != null ) { if ( throwable instanceof Error ) { throw ( Error ) throwable ; } else if ( throwable instanceof RuntimeException ) { throw ( RuntimeException ) throwable ; } else { throw new IllegalStateException ( throwable ) ; } } } protected void disableThreadChecks ( ) { threadChecksEnabled = false ; } protected void afterAsyncTestBase ( ) { if ( throwable != null && thrownThread != Thread . currentThread ( ) && ! awaitCalled ) { throw new IllegalStateException ( "Assert or failure from non main thread but no await() on main thread" ) ; } for ( Map . Entry < String , Exception > entry : threadNames . entrySet ( ) ) { if ( ! entry . getKey ( ) . equals ( mainThreadName ) ) { if ( threadChecksEnabled && ! entry . getKey ( ) . startsWith ( "vert.x-" ) ) { IllegalStateException is = new IllegalStateException ( "Non Vert.x thread! :" + entry . getKey ( ) ) ; is . setStackTrace ( entry . getValue ( ) . getStackTrace ( ) ) ; throw is ; } } } } private void handleThrowable ( Throwable t ) { if ( tearingDown ) { throw new IllegalStateException ( "assert or failure occurred after test has completed" ) ; } throwable = t ; t . printStackTrace ( ) ; thrownThread = Thread . currentThread ( ) ; latch . countDown ( ) ; if ( t instanceof AssertionError ) { throw ( AssertionError ) t ; } } protected void clearThrown ( ) { throwable = null ; } protected void checkThread ( ) { threadNames . put ( Thread . currentThread ( ) . getName ( ) , new Exception ( ) ) ; } protected void assertTrue ( String message , boolean condition ) { checkThread ( ) ; try { Assert . assertTrue ( message , condition ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertFalse ( boolean condition ) { checkThread ( ) ; try { Assert . assertFalse ( condition ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( String message , char [ ] expecteds , char [ ] actuals ) throws ArrayComparisonFailure { checkThread ( ) ; try { Assert . assertArrayEquals ( message , expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertSame ( String message , Object expected , Object actual ) { checkThread ( ) ; try { Assert . assertSame ( message , expected , actual ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertEquals ( long expected , long actual ) { checkThread ( ) ; try { Assert . assertEquals ( expected , actual ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertNull ( Object object ) { checkThread ( ) ; try { Assert . assertNull ( object ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertFalse ( String message , boolean condition ) { checkThread ( ) ; try { Assert . assertFalse ( message , condition ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void fail ( String message ) { checkThread ( ) ; try { Assert . fail ( message ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertNull ( String message , Object object ) { checkThread ( ) ; try { Assert . assertNull ( message , object ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( String message , float [ ] expecteds , float [ ] actuals , float delta ) throws ArrayComparisonFailure { checkThread ( ) ; try { Assert . assertArrayEquals ( message , expecteds , actuals , delta ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } @ Deprecated protected void assertEquals ( String message , double expected , double actual ) { checkThread ( ) ; try { Assert . assertEquals ( message , expected , actual ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( String message , double [ ] expecteds , double [ ] actuals , double delta ) throws ArrayComparisonFailure { checkThread ( ) ; try { Assert . assertArrayEquals ( message , expecteds , actuals , delta ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( String message , Object [ ] expecteds , Object [ ] actuals ) throws ArrayComparisonFailure { checkThread ( ) ; try { Assert . assertArrayEquals ( message , expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( String message , short [ ] expecteds , short [ ] actuals ) throws ArrayComparisonFailure { checkThread ( ) ; try { Assert . assertArrayEquals ( message , expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( short [ ] expecteds , short [ ] actuals ) { checkThread ( ) ; try { Assert . assertArrayEquals ( expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( long [ ] expecteds , long [ ] actuals ) { checkThread ( ) ; try { Assert . assertArrayEquals ( expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertNotNull ( Object object ) { checkThread ( ) ; try { Assert . assertNotNull ( object ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertEquals ( Object expected , Object actual ) { checkThread ( ) ; try { Assert . assertEquals ( expected , actual ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertEquals ( String message , Object expected , Object actual ) { checkThread ( ) ; try { Assert . assertEquals ( message , expected , actual ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertTrue ( boolean condition ) { checkThread ( ) ; try { Assert . assertTrue ( condition ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( Object [ ] expecteds , Object [ ] actuals ) { checkThread ( ) ; try { Assert . assertArrayEquals ( expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertNotNull ( String message , Object object ) { checkThread ( ) ; try { Assert . assertNotNull ( message , object ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertEquals ( String message , double expected , double actual , double delta ) { checkThread ( ) ; try { Assert . assertEquals ( message , expected , actual , delta ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void fail ( ) { checkThread ( ) ; try { Assert . fail ( ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertSame ( Object expected , Object actual ) { checkThread ( ) ; try { Assert . assertSame ( expected , actual ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertEquals ( String message , long expected , long actual ) { checkThread ( ) ; try { Assert . assertEquals ( message , expected , actual ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( String message , byte [ ] expecteds , byte [ ] actuals ) throws ArrayComparisonFailure { checkThread ( ) ; try { Assert . assertArrayEquals ( message , expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( String message , long [ ] expecteds , long [ ] actuals ) throws ArrayComparisonFailure { checkThread ( ) ; try { Assert . assertArrayEquals ( message , expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertEquals ( double expected , double actual , double delta ) { checkThread ( ) ; try { Assert . assertEquals ( expected , actual , delta ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected < T > void assertThat ( T actual , Matcher < T > matcher ) { checkThread ( ) ; try { Assert . assertThat ( actual , matcher ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } @ Deprecated protected void assertEquals ( String message , Object [ ] expecteds , Object [ ] actuals ) { checkThread ( ) ; try { Assert . assertEquals ( message , expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } @ Deprecated protected void assertEquals ( Object [ ] expecteds , Object [ ] actuals ) { checkThread ( ) ; try { Assert . assertEquals ( expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertNotSame ( String message , Object unexpected , Object actual ) { checkThread ( ) ; try { Assert . assertNotSame ( message , unexpected , actual ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected < T > void assertThat ( String reason , T actual , Matcher < T > matcher ) { checkThread ( ) ; try { Assert . assertThat ( reason , actual , matcher ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( float [ ] expecteds , float [ ] actuals , float delta ) { checkThread ( ) ; try { Assert . assertArrayEquals ( expecteds , actuals , delta ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertNotSame ( Object unexpected , Object actual ) { checkThread ( ) ; try { Assert . assertNotSame ( unexpected , actual ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( byte [ ] expecteds , byte [ ] actuals ) { checkThread ( ) ; try { Assert . assertArrayEquals ( expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( char [ ] expecteds , char [ ] actuals ) { checkThread ( ) ; try { Assert . assertArrayEquals ( expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( double [ ] expecteds , double [ ] actuals , double delta ) { checkThread ( ) ; try { Assert . assertArrayEquals ( expecteds , actuals , delta ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( int [ ] expecteds , int [ ] actuals ) { checkThread ( ) ; try { Assert . assertArrayEquals ( expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } @ Deprecated protected void assertEquals ( double expected , double actual ) { checkThread ( ) ; try { Assert . assertEquals ( expected , actual ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected void assertArrayEquals ( String message , int [ ] expecteds , int [ ] actuals ) throws ArrayComparisonFailure { checkThread ( ) ; try { Assert . assertArrayEquals ( message , expecteds , actuals ) ; } catch ( AssertionError e ) { handleThrowable ( e ) ; } } protected < T > Handler < AsyncResult < T > > onFailure ( Consumer < Throwable > consumer ) { return result - > { assertFalse ( result . succeeded ( ) ) ; consumer . accept ( result . cause ( ) ) ; } ; } protected void awaitLatch ( CountDownLatch latch ) throws InterruptedException { assertTrue ( latch . await ( 10 , TimeUnit . SECONDS ) ) ; } protected void waitUntil ( BooleanSupplier supplier ) { waitUntil ( supplier , 10000 ) ; } protected void waitUntil ( BooleanSupplier supplier , long timeout ) { long start = System . currentTimeMillis ( ) ; while ( true ) { if ( supplier . getAsBoolean ( ) ) { break ; } try { Thread . sleep ( 10 ) ; } catch ( InterruptedException ignore ) { } long now = System . currentTimeMillis ( ) ; if ( now - start > timeout ) { throw new IllegalStateException ( "Timed out" ) ; } } } protected < T > Handler < AsyncResult < T > > onSuccess ( Consumer < T > consumer ) { return result - > { if ( result . failed ( ) ) { result . cause ( ) . printStackTrace ( ) ; fail ( result . cause ( ) . getMessage ( ) ) ; } else { consumer . accept ( result . result ( ) ) ; } } ; } }
package io . vertx . core . http . impl ; import io . netty . handler . codec . http . HttpHeaders ; import io . vertx . core . MultiMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; public class HeadersAdaptor implements MultiMap { private final HttpHeaders headers ; public HeadersAdaptor ( HttpHeaders headers ) { this . headers = headers ; } @ Override public String get ( String name ) { return headers . get ( name ) ; } @ Override public List < String > getAll ( String name ) { return headers . getAll ( name ) ; } @ Override public List < Map . Entry < String , String > > entries ( ) { return headers . entries ( ) ; } @ Override public boolean contains ( String name ) { return headers . contains ( name ) ; } @ Override public boolean isEmpty ( ) { return headers . isEmpty ( ) ; } @ Override public Set < String > names ( ) { return headers . names ( ) ; } @ Override public MultiMap add ( String name , String value ) { headers . add ( name , value ) ; return this ; } @ Override public MultiMap add ( String name , Iterable < String > values ) { headers . add ( name , values ) ; return this ; } @ Override public MultiMap addAll ( MultiMap headers ) { for ( Map . Entry < String , String > entry : headers . entries ( ) ) { add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; } @ Override public MultiMap addAll ( Map < String , String > map ) { for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; } @ Override public MultiMap set ( String name , String value ) { headers . set ( name , value ) ; return this ; } @ Override public MultiMap set ( String name , Iterable < String > values ) { headers . set ( name , values ) ; return this ; } @ Override public MultiMap setAll ( MultiMap httpHeaders ) { clear ( ) ; for ( Map . Entry < String , String > entry : httpHeaders ) { add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; } @ Override public MultiMap remove ( String name ) { headers . remove ( name ) ; return this ; } @ Override public MultiMap clear ( ) { headers . clear ( ) ; return this ; } @ Override public Iterator < Map . Entry < String , String > > iterator ( ) { return headers . iterator ( ) ; } @ Override public int size ( ) { return names ( ) . size ( ) ; } @ Override public MultiMap setAll ( Map < String , String > headers ) { for ( Map . Entry < String , String > entry : headers . entrySet ( ) ) { add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; } @ Override public String get ( CharSequence name ) { return headers . get ( name ) ; } @ Override public List < String > getAll ( CharSequence name ) { return headers . getAll ( name ) ; } @ Override public boolean contains ( CharSequence name ) { return headers . contains ( name ) ; } @ Override public MultiMap add ( CharSequence name , CharSequence value ) { headers . add ( name , value ) ; return this ; } @ Override public MultiMap add ( CharSequence name , Iterable < CharSequence > values ) { headers . add ( name , values ) ; return this ; } @ Override public MultiMap set ( CharSequence name , CharSequence value ) { headers . set ( name , value ) ; return this ; } @ Override public MultiMap set ( CharSequence name , Iterable < CharSequence > values ) { headers . set ( name , values ) ; return this ; } @ Override public MultiMap remove ( CharSequence name ) { headers . remove ( name ) ; return this ; } }
package io . vertx . core . http . impl ; import io . netty . bootstrap . ChannelFactory ; public class VertxNioSocketChannelFactory implements ChannelFactory < VertxNioSocketChannel > { @ Override public VertxNioSocketChannel newChannel ( ) { return new VertxNioSocketChannel < > ( ) ; } }
package io . vertx . core . http . impl ; import java . util . HashMap ; import java . util . Map ; public class MimeMapping { private static final Map < String , String > m = new HashMap < > ( ) ; static { m . put ( "ez" , "application/andrew-inset" ) ; m . put ( "aw" , "application/applixware" ) ; m . put ( "atom" , "application/atom+xml" ) ; m . put ( "atomcat" , "application/atomcat+xml" ) ; m . put ( "atomsvc" , "application/atomsvc+xml" ) ; m . put ( "ccxml" , "application/ccxml+xml" ) ; m . put ( "cdmia" , "application/cdmi-capability" ) ; m . put ( "cdmic" , "application/cdmi-container" ) ; m . put ( "cdmid" , "application/cdmi-domain" ) ; m . put ( "cdmio" , "application/cdmi-object" ) ; m . put ( "cdmiq" , "application/cdmi-queue" ) ; m . put ( "cu" , "application/cu-seeme" ) ; m . put ( "davmount" , "application/davmount+xml" ) ; m . put ( "dbk" , "application/docbook+xml" ) ; m . put ( "dssc" , "application/dssc+der" ) ; m . put ( "xdssc" , "application/dssc+xml" ) ; m . put ( "ecma" , "application/ecmascript" ) ; m . put ( "emma" , "application/emma+xml" ) ; m . put ( "epub" , "application/epub+zip" ) ; m . put ( "exi" , "application/exi" ) ; m . put ( "pfr" , "application/font-tdpfr" ) ; m . put ( "gml" , "application/gml+xml" ) ; m . put ( "gpx" , "application/gpx+xml" ) ; m . put ( "gxf" , "application/gxf" ) ; m . put ( "stk" , "application/hyperstudio" ) ; m . put ( "ink" , "application/inkml+xml" ) ; m . put ( "inkml" , "application/inkml+xml" ) ; m . put ( "ipfix" , "application/ipfix" ) ; m . put ( "jar" , "application/java-archive" ) ; m . put ( "ser" , "application/java-serialized-object" ) ; m . put ( "class" , "application/java-vm" ) ; m . put ( "js" , "application/javascript" ) ; m . put ( "json" , "application/json" ) ; m . put ( "jsonml" , "application/jsonml+json" ) ; m . put ( "lostxml" , "application/lost+xml" ) ; m . put ( "hqx" , "application/mac-binhex40" ) ; m . put ( "cpt" , "application/mac-compactpro" ) ; m . put ( "mads" , "application/mads+xml" ) ; m . put ( "mrc" , "application/marc" ) ; m . put ( "mrcx" , "application/marcxml+xml" ) ; m . put ( "ma" , "application/mathematica" ) ; m . put ( "nb" , "application/mathematica" ) ; m . put ( "mb" , "application/mathematica" ) ; m . put ( "mathml" , "application/mathml+xml" ) ; m . put ( "mbox" , "application/mbox" ) ; m . put ( "mscml" , "application/mediaservercontrol+xml" ) ; m . put ( "metalink" , "application/metalink+xml" ) ; m . put ( "meta4" , "application/metalink4+xml" ) ; m . put ( "mets" , "application/mets+xml" ) ; m . put ( "mods" , "application/mods+xml" ) ; m . put ( "m21" , "application/mp21" ) ; m . put ( "mp21" , "application/mp21" ) ; m . put ( "mp4s" , "application/mp4" ) ; m . put ( "doc" , "application/msword" ) ; m . put ( "dot" , "application/msword" ) ; m . put ( "mxf" , "application/mxf" ) ; m . put ( "bin" , "application/octet-stream" ) ; m . put ( "dms" , "application/octet-stream" ) ; m . put ( "lrf" , "application/octet-stream" ) ; m . put ( "mar" , "application/octet-stream" ) ; m . put ( "so" , "application/octet-stream" ) ; m . put ( "dist" , "application/octet-stream" ) ; m . put ( "distz" , "application/octet-stream" ) ; m . put ( "pkg" , "application/octet-stream" ) ; m . put ( "bpk" , "application/octet-stream" ) ; m . put ( "dump" , "application/octet-stream" ) ; m . put ( "elc" , "application/octet-stream" ) ; m . put ( "deploy" , "application/octet-stream" ) ; m . put ( "oda" , "application/oda" ) ; m . put ( "opf" , "application/oebps-package+xml" ) ; m . put ( "ogx" , "application/ogg" ) ; m . put ( "omdoc" , "application/omdoc+xml" ) ; m . put ( "onetoc" , "application/onenote" ) ; m . put ( "onetoc2" , "application/onenote" ) ; m . put ( "onetmp" , "application/onenote" ) ; m . put ( "onepkg" , "application/onenote" ) ; m . put ( "oxps" , "application/oxps" ) ; m . put ( "xer" , "application/patch-ops-error+xml" ) ; m . put ( "pdf" , "application/pdf" ) ; m . put ( "pgp" , "application/pgp-encrypted" ) ; m . put ( "asc" , "application/pgp-signature" ) ; m . put ( "sig" , "application/pgp-signature" ) ; m . put ( "prf" , "application/pics-rules" ) ; m . put ( "p10" , "application/pkcs10" ) ; m . put ( "p7m" , "application/pkcs7-mime" ) ; m . put ( "p7c" , "application/pkcs7-mime" ) ; m . put ( "p7s" , "application/pkcs7-signature" ) ; m . put ( "p8" , "application/pkcs8" ) ; m . put ( "ac" , "application/pkix-attr-cert" ) ; m . put ( "cer" , "application/pkix-cert" ) ; m . put ( "crl" , "application/pkix-crl" ) ; m . put ( "pkipath" , "application/pkix-pkipath" ) ; m . put ( "pki" , "application/pkixcmp" ) ; m . put ( "pls" , "application/pls+xml" ) ; m . put ( "ai" , "application/postscript" ) ; m . put ( "eps" , "application/postscript" ) ; m . put ( "ps" , "application/postscript" ) ; m . put ( "cww" , "application/prs.cww" ) ; m . put ( "pskcxml" , "application/pskc+xml" ) ; m . put ( "rdf" , "application/rdf+xml" ) ; m . put ( "rif" , "application/reginfo+xml" ) ; m . put ( "rnc" , "application/relax-ng-compact-syntax" ) ; m . put ( "rl" , "application/resource-lists+xml" ) ; m . put ( "rld" , "application/resource-lists-diff+xml" ) ; m . put ( "rs" , "application/rls-services+xml" ) ; m . put ( "gbr" , "application/rpki-ghostbusters" ) ; m . put ( "mft" , "application/rpki-manifest" ) ; m . put ( "roa" , "application/rpki-roa" ) ; m . put ( "rsd" , "application/rsd+xml" ) ; m . put ( "rss" , "application/rss+xml" ) ; m . put ( "rtf" , "application/rtf" ) ; m . put ( "sbml" , "application/sbml+xml" ) ; m . put ( "scq" , "application/scvp-cv-request" ) ; m . put ( "scs" , "application/scvp-cv-response" ) ; m . put ( "spq" , "application/scvp-vp-request" ) ; m . put ( "spp" , "application/scvp-vp-response" ) ; m . put ( "sdp" , "application/sdp" ) ; m . put ( "setpay" , "application/set-payment-initiation" ) ; m . put ( "setreg" , "application/set-registration-initiation" ) ; m . put ( "shf" , "application/shf+xml" ) ; m . put ( "smi" , "application/smil+xml" ) ; m . put ( "smil" , "application/smil+xml" ) ; m . put ( "rq" , "application/sparql-query" ) ; m . put ( "srx" , "application/sparql-results+xml" ) ; m . put ( "gram" , "application/srgs" ) ; m . put ( "grxml" , "application/srgs+xml" ) ; m . put ( "sru" , "application/sru+xml" ) ; m . put ( "ssdl" , "application/ssdl+xml" ) ; m . put ( "ssml" , "application/ssml+xml" ) ; m . put ( "tei" , "application/tei+xml" ) ; m . put ( "teicorpus" , "application/tei+xml" ) ; m . put ( "tfi" , "application/thraud+xml" ) ; m . put ( "tsd" , "application/timestamped-data" ) ; m . put ( "plb" , "application/vnd.3gpp.pic-bw-large" ) ; m . put ( "psb" , "application/vnd.3gpp.pic-bw-small" ) ; m . put ( "pvb" , "application/vnd.3gpp.pic-bw-var" ) ; m . put ( "tcap" , "application/vnd.3gpp2.tcap" ) ; m . put ( "pwn" , "application/vnd.3m.post-it-notes" ) ; m . put ( "aso" , "application/vnd.accpac.simply.aso" ) ; m . put ( "imp" , "application/vnd.accpac.simply.imp" ) ; m . put ( "acu" , "application/vnd.acucobol" ) ; m . put ( "atc" , "application/vnd.acucorp" ) ; m . put ( "acutc" , "application/vnd.acucorp" ) ; m . put ( "air" , "application/vnd.adobe.air-application-installer-package+zip" ) ; m . put ( "fcdt" , "application/vnd.adobe.formscentral.fcdt" ) ; m . put ( "fxp" , "application/vnd.adobe.fxp" ) ; m . put ( "fxpl" , "application/vnd.adobe.fxp" ) ; m . put ( "xdp" , "application/vnd.adobe.xdp+xml" ) ; m . put ( "xfdf" , "application/vnd.adobe.xfdf" ) ; m . put ( "ahead" , "application/vnd.ahead.space" ) ; m . put ( "azf" , "application/vnd.airzip.filesecure.azf" ) ; m . put ( "azs" , "application/vnd.airzip.filesecure.azs" ) ; m . put ( "azw" , "application/vnd.amazon.ebook" ) ; m . put ( "acc" , "application/vnd.americandynamics.acc" ) ; m . put ( "ami" , "application/vnd.amiga.ami" ) ; m . put ( "apk" , "application/vnd.android.package-archive" ) ; m . put ( "cii" , "application/vnd.anser-web-certificate-issue-initiation" ) ; m . put ( "fti" , "application/vnd.anser-web-funds-transfer-initiation" ) ; m . put ( "atx" , "application/vnd.antix.game-component" ) ; m . put ( "mpkg" , "application/vnd.apple.installer+xml" ) ; m . put ( "m3u8" , "application/vnd.apple.mpegurl" ) ; m . put ( "swi" , "application/vnd.aristanetworks.swi" ) ; m . put ( "iota" , "application/vnd.astraea-software.iota" ) ; m . put ( "aep" , "application/vnd.audiograph" ) ; m . put ( "mpm" , "application/vnd.blueice.multipass" ) ; m . put ( "bmi" , "application/vnd.bmi" ) ; m . put ( "rep" , "application/vnd.businessobjects" ) ; m . put ( "cdxml" , "application/vnd.chemdraw+xml" ) ; m . put ( "mmd" , "application/vnd.chipnuts.karaoke-mmd" ) ; m . put ( "cdy" , "application/vnd.cinderella" ) ; m . put ( "cla" , "application/vnd.claymore" ) ; m . put ( "rp9" , "application/vnd.cloanto.rp9" ) ; m . put ( "c4g" , "application/vnd.clonk.c4group" ) ; m . put ( "c4d" , "application/vnd.clonk.c4group" ) ; m . put ( "c4f" , "application/vnd.clonk.c4group" ) ; m . put ( "c4p" , "application/vnd.clonk.c4group" ) ; m . put ( "c4u" , "application/vnd.clonk.c4group" ) ; m . put ( "c11amc" , "application/vnd.cluetrust.cartomobile-config" ) ; m . put ( "c11amz" , "application/vnd.cluetrust.cartomobile-config-pkg" ) ; m . put ( "csp" , "application/vnd.commonspace" ) ; m . put ( "cdbcmsg" , "application/vnd.contact.cmsg" ) ; m . put ( "cmc" , "application/vnd.cosmocaller" ) ; m . put ( "clkx" , "application/vnd.crick.clicker" ) ; m . put ( "clkk" , "application/vnd.crick.clicker.keyboard" ) ; m . put ( "clkp" , "application/vnd.crick.clicker.palette" ) ; m . put ( "clkt" , "application/vnd.crick.clicker.template" ) ; m . put ( "clkw" , "application/vnd.crick.clicker.wordbank" ) ; m . put ( "wbs" , "application/vnd.criticaltools.wbs+xml" ) ; m . put ( "pml" , "application/vnd.ctc-posml" ) ; m . put ( "ppd" , "application/vnd.cups-ppd" ) ; m . put ( "car" , "application/vnd.curl.car" ) ; m . put ( "pcurl" , "application/vnd.curl.pcurl" ) ; m . put ( "dart" , "application/vnd.dart" ) ; m . put ( "rdz" , "application/vnd.data-vision.rdz" ) ; m . put ( "uvf" , "application/vnd.dece.data" ) ; m . put ( "uvvf" , "application/vnd.dece.data" ) ; m . put ( "uvd" , "application/vnd.dece.data" ) ; m . put ( "uvvd" , "application/vnd.dece.data" ) ; m . put ( "uvt" , "application/vnd.dece.ttml+xml" ) ; m . put ( "uvvt" , "application/vnd.dece.ttml+xml" ) ; m . put ( "uvx" , "application/vnd.dece.unspecified" ) ; m . put ( "uvvx" , "application/vnd.dece.unspecified" ) ; m . put ( "uvz" , "application/vnd.dece.zip" ) ; m . put ( "uvvz" , "application/vnd.dece.zip" ) ; m . put ( "fe_launch" , "application/vnd.denovo.fcselayout-link" ) ; m . put ( "dna" , "application/vnd.dna" ) ; m . put ( "mlp" , "application/vnd.dolby.mlp" ) ; m . put ( "dpg" , "application/vnd.dpgraph" ) ; m . put ( "dfac" , "application/vnd.dreamfactory" ) ; m . put ( "kpxx" , "application/vnd.ds-keypoint" ) ; m . put ( "ait" , "application/vnd.dvb.ait" ) ; m . put ( "svc" , "application/vnd.dvb.service" ) ; m . put ( "geo" , "application/vnd.dynageo" ) ; m . put ( "mag" , "application/vnd.ecowin.chart" ) ; m . put ( "nml" , "application/vnd.enliven" ) ; m . put ( "esf" , "application/vnd.epson.esf" ) ; m . put ( "msf" , "application/vnd.epson.msf" ) ; m . put ( "qam" , "application/vnd.epson.quickanime" ) ; m . put ( "slt" , "application/vnd.epson.salt" ) ; m . put ( "ssf" , "application/vnd.epson.ssf" ) ; m . put ( "es3" , "application/vnd.eszigno3+xml" ) ; m . put ( "et3" , "application/vnd.eszigno3+xml" ) ; m . put ( "ez2" , "application/vnd.ezpix-album" ) ; m . put ( "ez3" , "application/vnd.ezpix-package" ) ; m . put ( "fdf" , "application/vnd.fdf" ) ; m . put ( "mseed" , "application/vnd.fdsn.mseed" ) ; m . put ( "seed" , "application/vnd.fdsn.seed" ) ; m . put ( "dataless" , "application/vnd.fdsn.seed" ) ; m . put ( "gph" , "application/vnd.flographit" ) ; m . put ( "ftc" , "application/vnd.fluxtime.clip" ) ; m . put ( "fm" , "application/vnd.framemaker" ) ; m . put ( "frame" , "application/vnd.framemaker" ) ; m . put ( "maker" , "application/vnd.framemaker" ) ; m . put ( "book" , "application/vnd.framemaker" ) ; m . put ( "fnc" , "application/vnd.frogans.fnc" ) ; m . put ( "ltf" , "application/vnd.frogans.ltf" ) ; m . put ( "fsc" , "application/vnd.fsc.weblaunch" ) ; m . put ( "oas" , "application/vnd.fujitsu.oasys" ) ; m . put ( "oa2" , "application/vnd.fujitsu.oasys2" ) ; m . put ( "oa3" , "application/vnd.fujitsu.oasys3" ) ; m . put ( "fg5" , "application/vnd.fujitsu.oasysgp" ) ; m . put ( "bh2" , "application/vnd.fujitsu.oasysprs" ) ; m . put ( "ddd" , "application/vnd.fujixerox.ddd" ) ; m . put ( "xdw" , "application/vnd.fujixerox.docuworks" ) ; m . put ( "xbd" , "application/vnd.fujixerox.docuworks.binder" ) ; m . put ( "fzs" , "application/vnd.fuzzysheet" ) ; m . put ( "txd" , "application/vnd.genomatix.tuxedo" ) ; m . put ( "ggb" , "application/vnd.geogebra.file" ) ; m . put ( "ggt" , "application/vnd.geogebra.tool" ) ; m . put ( "gex" , "application/vnd.geometry-explorer" ) ; m . put ( "gre" , "application/vnd.geometry-explorer" ) ; m . put ( "gxt" , "application/vnd.geonext" ) ; m . put ( "g2w" , "application/vnd.geoplan" ) ; m . put ( "g3w" , "application/vnd.geospace" ) ; m . put ( "gmx" , "application/vnd.gmx" ) ; m . put ( "kml" , "application/vnd.google-earth.kml+xml" ) ; m . put ( "kmz" , "application/vnd.google-earth.kmz" ) ; m . put ( "gqf" , "application/vnd.grafeq" ) ; m . put ( "gqs" , "application/vnd.grafeq" ) ; m . put ( "gac" , "application/vnd.groove-account" ) ; m . put ( "ghf" , "application/vnd.groove-help" ) ; m . put ( "gim" , "application/vnd.groove-identity-message" ) ; m . put ( "grv" , "application/vnd.groove-injector" ) ; m . put ( "gtm" , "application/vnd.groove-tool-message" ) ; m . put ( "tpl" , "application/vnd.groove-tool-template" ) ; m . put ( "vcg" , "application/vnd.groove-vcard" ) ; m . put ( "hal" , "application/vnd.hal+xml" ) ; m . put ( "zmm" , "application/vnd.handheld-entertainment+xml" ) ; m . put ( "hbci" , "application/vnd.hbci" ) ; m . put ( "les" , "application/vnd.hhe.lesson-player" ) ; m . put ( "hpgl" , "application/vnd.hp-hpgl" ) ; m . put ( "hpid" , "application/vnd.hp-hpid" ) ; m . put ( "hps" , "application/vnd.hp-hps" ) ; m . put ( "jlt" , "application/vnd.hp-jlyt" ) ; m . put ( "pcl" , "application/vnd.hp-pcl" ) ; m . put ( "pclxl" , "application/vnd.hp-pclxl" ) ; m . put ( "sfd-hdstx" , "application/vnd.hydrostatix.sof-data" ) ; m . put ( "mpy" , "application/vnd.ibm.minipay" ) ; m . put ( "afp" , "application/vnd.ibm.modcap" ) ; m . put ( "listafp" , "application/vnd.ibm.modcap" ) ; m . put ( "list3820" , "application/vnd.ibm.modcap" ) ; m . put ( "irm" , "application/vnd.ibm.rights-management" ) ; m . put ( "sc" , "application/vnd.ibm.secure-container" ) ; m . put ( "icc" , "application/vnd.iccprofile" ) ; m . put ( "icm" , "application/vnd.iccprofile" ) ; m . put ( "igl" , "application/vnd.igloader" ) ; m . put ( "ivp" , "application/vnd.immervision-ivp" ) ; m . put ( "ivu" , "application/vnd.immervision-ivu" ) ; m . put ( "igm" , "application/vnd.insors.igm" ) ; m . put ( "xpw" , "application/vnd.intercon.formnet" ) ; m . put ( "xpx" , "application/vnd.intercon.formnet" ) ; m . put ( "i2g" , "application/vnd.intergeo" ) ; m . put ( "qbo" , "application/vnd.intu.qbo" ) ; m . put ( "qfx" , "application/vnd.intu.qfx" ) ; m . put ( "rcprofile" , "application/vnd.ipunplugged.rcprofile" ) ; m . put ( "irp" , "application/vnd.irepository.package+xml" ) ; m . put ( "xpr" , "application/vnd.is-xpr" ) ; m . put ( "fcs" , "application/vnd.isac.fcs" ) ; m . put ( "jam" , "application/vnd.jam" ) ; m . put ( "rms" , "application/vnd.jcp.javame.midlet-rms" ) ; m . put ( "jisp" , "application/vnd.jisp" ) ; m . put ( "joda" , "application/vnd.joost.joda-archive" ) ; m . put ( "ktz" , "application/vnd.kahootz" ) ; m . put ( "ktr" , "application/vnd.kahootz" ) ; m . put ( "karbon" , "application/vnd.kde.karbon" ) ; m . put ( "chrt" , "application/vnd.kde.kchart" ) ; m . put ( "kfo" , "application/vnd.kde.kformula" ) ; m . put ( "flw" , "application/vnd.kde.kivio" ) ; m . put ( "kon" , "application/vnd.kde.kontour" ) ; m . put ( "kpr" , "application/vnd.kde.kpresenter" ) ; m . put ( "kpt" , "application/vnd.kde.kpresenter" ) ; m . put ( "ksp" , "application/vnd.kde.kspread" ) ; m . put ( "kwd" , "application/vnd.kde.kword" ) ; m . put ( "kwt" , "application/vnd.kde.kword" ) ; m . put ( "htke" , "application/vnd.kenameaapp" ) ; m . put ( "kia" , "application/vnd.kidspiration" ) ; m . put ( "kne" , "application/vnd.kinar" ) ; m . put ( "knp" , "application/vnd.kinar" ) ; m . put ( "skp" , "application/vnd.koan" ) ; m . put ( "skd" , "application/vnd.koan" ) ; m . put ( "skt" , "application/vnd.koan" ) ; m . put ( "skm" , "application/vnd.koan" ) ; m . put ( "sse" , "application/vnd.kodak-descriptor" ) ; m . put ( "lasxml" , "application/vnd.las.las+xml" ) ; m . put ( "lbd" , "application/vnd.llamagraphics.life-balance.desktop" ) ; m . put ( "lbe" , "application/vnd.llamagraphics.life-balance.exchange+xml" ) ; m . put ( "123" , "application/vnd.lotus-1-2-3" ) ; m . put ( "apr" , "application/vnd.lotus-approach" ) ; m . put ( "pre" , "application/vnd.lotus-freelance" ) ; m . put ( "nsf" , "application/vnd.lotus-notes" ) ; m . put ( "org" , "application/vnd.lotus-organizer" ) ; m . put ( "scm" , "application/vnd.lotus-screencam" ) ; m . put ( "lwp" , "application/vnd.lotus-wordpro" ) ; m . put ( "portpkg" , "application/vnd.macports.portpkg" ) ; m . put ( "mcd" , "application/vnd.mcd" ) ; m . put ( "mc1" , "application/vnd.medcalcdata" ) ; m . put ( "cdkey" , "application/vnd.mediastation.cdkey" ) ; m . put ( "mwf" , "application/vnd.mfer" ) ; m . put ( "mfm" , "application/vnd.mfmp" ) ; m . put ( "flo" , "application/vnd.micrografx.flo" ) ; m . put ( "igx" , "application/vnd.micrografx.igx" ) ; m . put ( "mif" , "application/vnd.mif" ) ; m . put ( "daf" , "application/vnd.mobius.daf" ) ; m . put ( "dis" , "application/vnd.mobius.dis" ) ; m . put ( "mbk" , "application/vnd.mobius.mbk" ) ; m . put ( "mqy" , "application/vnd.mobius.mqy" ) ; m . put ( "msl" , "application/vnd.mobius.msl" ) ; m . put ( "plc" , "application/vnd.mobius.plc" ) ; m . put ( "txf" , "application/vnd.mobius.txf" ) ; m . put ( "mpn" , "application/vnd.mophun.application" ) ; m . put ( "mpc" , "application/vnd.mophun.certificate" ) ; m . put ( "xul" , "application/vnd.mozilla.xul+xml" ) ; m . put ( "cil" , "application/vnd.ms-artgalry" ) ; m . put ( "cab" , "application/vnd.ms-cab-compressed" ) ; m . put ( "xls" , "application/vnd.ms-excel" ) ; m . put ( "xlm" , "application/vnd.ms-excel" ) ; m . put ( "xla" , "application/vnd.ms-excel" ) ; m . put ( "xlc" , "application/vnd.ms-excel" ) ; m . put ( "xlt" , "application/vnd.ms-excel" ) ; m . put ( "xlw" , "application/vnd.ms-excel" ) ; m . put ( "xlam" , "application/vnd.ms-excel.addin.macroenabled.12" ) ; m . put ( "xlsb" , "application/vnd.ms-excel.sheet.binary.macroenabled.12" ) ; m . put ( "xlsm" , "application/vnd.ms-excel.sheet.macroenabled.12" ) ; m . put ( "xltm" , "application/vnd.ms-excel.template.macroenabled.12" ) ; m . put ( "eot" , "application/vnd.ms-fontobject" ) ; m . put ( "chm" , "application/vnd.ms-htmlhelp" ) ; m . put ( "ims" , "application/vnd.ms-ims" ) ; m . put ( "lrm" , "application/vnd.ms-lrm" ) ; m . put ( "thmx" , "application/vnd.ms-officetheme" ) ; m . put ( "cat" , "application/vnd.ms-pki.seccat" ) ; m . put ( "stl" , "application/vnd.ms-pki.stl" ) ; m . put ( "ppt" , "application/vnd.ms-powerpoint" ) ; m . put ( "pps" , "application/vnd.ms-powerpoint" ) ; m . put ( "pot" , "application/vnd.ms-powerpoint" ) ; m . put ( "ppam" , "application/vnd.ms-powerpoint.addin.macroenabled.12" ) ; m . put ( "pptm" , "application/vnd.ms-powerpoint.presentation.macroenabled.12" ) ; m . put ( "sldm" , "application/vnd.ms-powerpoint.slide.macroenabled.12" ) ; m . put ( "ppsm" , "application/vnd.ms-powerpoint.slideshow.macroenabled.12" ) ; m . put ( "potm" , "application/vnd.ms-powerpoint.template.macroenabled.12" ) ; m . put ( "mpp" , "application/vnd.ms-project" ) ; m . put ( "mpt" , "application/vnd.ms-project" ) ; m . put ( "docm" , "application/vnd.ms-word.document.macroenabled.12" ) ; m . put ( "dotm" , "application/vnd.ms-word.template.macroenabled.12" ) ; m . put ( "wps" , "application/vnd.ms-works" ) ; m . put ( "wks" , "application/vnd.ms-works" ) ; m . put ( "wcm" , "application/vnd.ms-works" ) ; m . put ( "wdb" , "application/vnd.ms-works" ) ; m . put ( "wpl" , "application/vnd.ms-wpl" ) ; m . put ( "xps" , "application/vnd.ms-xpsdocument" ) ; m . put ( "mseq" , "application/vnd.mseq" ) ; m . put ( "mus" , "application/vnd.musician" ) ; m . put ( "msty" , "application/vnd.muvee.style" ) ; m . put ( "taglet" , "application/vnd.mynfc" ) ; m . put ( "nlu" , "application/vnd.neurolanguage.nlu" ) ; m . put ( "ntf" , "application/vnd.nitf" ) ; m . put ( "nitf" , "application/vnd.nitf" ) ; m . put ( "nnd" , "application/vnd.noblenet-directory" ) ; m . put ( "nns" , "application/vnd.noblenet-sealer" ) ; m . put ( "nnw" , "application/vnd.noblenet-web" ) ; m . put ( "ngdat" , "application/vnd.nokia.n-gage.data" ) ; m . put ( "n-gage" , "application/vnd.nokia.n-gage.symbian.install" ) ; m . put ( "rpst" , "application/vnd.nokia.radio-preset" ) ; m . put ( "rpss" , "application/vnd.nokia.radio-presets" ) ; m . put ( "edm" , "application/vnd.novadigm.edm" ) ; m . put ( "edx" , "application/vnd.novadigm.edx" ) ; m . put ( "ext" , "application/vnd.novadigm.ext" ) ; m . put ( "odc" , "application/vnd.oasis.opendocument.chart" ) ; m . put ( "otc" , "application/vnd.oasis.opendocument.chart-template" ) ; m . put ( "odb" , "application/vnd.oasis.opendocument.database" ) ; m . put ( "odf" , "application/vnd.oasis.opendocument.formula" ) ; m . put ( "odft" , "application/vnd.oasis.opendocument.formula-template" ) ; m . put ( "odg" , "application/vnd.oasis.opendocument.graphics" ) ; m . put ( "otg" , "application/vnd.oasis.opendocument.graphics-template" ) ; m . put ( "odi" , "application/vnd.oasis.opendocument.image" ) ; m . put ( "oti" , "application/vnd.oasis.opendocument.image-template" ) ; m . put ( "odp" , "application/vnd.oasis.opendocument.presentation" ) ; m . put ( "otp" , "application/vnd.oasis.opendocument.presentation-template" ) ; m . put ( "ods" , "application/vnd.oasis.opendocument.spreadsheet" ) ; m . put ( "ots" , "application/vnd.oasis.opendocument.spreadsheet-template" ) ; m . put ( "odt" , "application/vnd.oasis.opendocument.text" ) ; m . put ( "odm" , "application/vnd.oasis.opendocument.text-master" ) ; m . put ( "ott" , "application/vnd.oasis.opendocument.text-template" ) ; m . put ( "oth" , "application/vnd.oasis.opendocument.text-web" ) ; m . put ( "xo" , "application/vnd.olpc-sugar" ) ; m . put ( "dd2" , "application/vnd.oma.dd2+xml" ) ; m . put ( "oxt" , "application/vnd.openofficeorg.extension" ) ; m . put ( "pptx" , "application/vnd.openxmlformats-officedocument.presentationml.presentation" ) ; m . put ( "sldx" , "application/vnd.openxmlformats-officedocument.presentationml.slide" ) ; m . put ( "ppsx" , "application/vnd.openxmlformats-officedocument.presentationml.slideshow" ) ; m . put ( "potx" , "application/vnd.openxmlformats-officedocument.presentationml.template" ) ; m . put ( "xlsx" , "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" ) ; m . put ( "xltx" , "application/vnd.openxmlformats-officedocument.spreadsheetml.template" ) ; m . put ( "docx" , "application/vnd.openxmlformats-officedocument.wordprocessingml.document" ) ; m . put ( "dotx" , "application/vnd.openxmlformats-officedocument.wordprocessingml.template" ) ; m . put ( "mgp" , "application/vnd.osgeo.mapguide.package" ) ; m . put ( "dp" , "application/vnd.osgi.dp" ) ; m . put ( "esa" , "application/vnd.osgi.subsystem" ) ; m . put ( "pdb" , "application/vnd.palm" ) ; m . put ( "pqa" , "application/vnd.palm" ) ; m . put ( "oprc" , "application/vnd.palm" ) ; m . put ( "paw" , "application/vnd.pawaafile" ) ; m . put ( "str" , "application/vnd.pg.format" ) ; m . put ( "ei6" , "application/vnd.pg.osasli" ) ; m . put ( "efif" , "application/vnd.picsel" ) ; m . put ( "wg" , "application/vnd.pmi.widget" ) ; m . put ( "plf" , "application/vnd.pocketlearn" ) ; m . put ( "pbd" , "application/vnd.powerbuilder6" ) ; m . put ( "box" , "application/vnd.previewsystems.box" ) ; m . put ( "mgz" , "application/vnd.proteus.magazine" ) ; m . put ( "qps" , "application/vnd.publishare-delta-tree" ) ; m . put ( "ptid" , "application/vnd.pvi.ptid1" ) ; m . put ( "qxd" , "application/vnd.quark.quarkxpress" ) ; m . put ( "qxt" , "application/vnd.quark.quarkxpress" ) ; m . put ( "qwd" , "application/vnd.quark.quarkxpress" ) ; m . put ( "qwt" , "application/vnd.quark.quarkxpress" ) ; m . put ( "qxl" , "application/vnd.quark.quarkxpress" ) ; m . put ( "qxb" , "application/vnd.quark.quarkxpress" ) ; m . put ( "bed" , "application/vnd.realvnc.bed" ) ; m . put ( "mxl" , "application/vnd.recordare.musicxml" ) ; m . put ( "musicxml" , "application/vnd.recordare.musicxml+xml" ) ; m . put ( "cryptonote" , "application/vnd.rig.cryptonote" ) ; m . put ( "cod" , "application/vnd.rim.cod" ) ; m . put ( "rm" , "application/vnd.rn-realmedia" ) ; m . put ( "rmvb" , "application/vnd.rn-realmedia-vbr" ) ; m . put ( "link66" , "application/vnd.route66.link66+xml" ) ; m . put ( "st" , "application/vnd.sailingtracker.track" ) ; m . put ( "see" , "application/vnd.seemail" ) ; m . put ( "sema" , "application/vnd.sema" ) ; m . put ( "semd" , "application/vnd.semd" ) ; m . put ( "semf" , "application/vnd.semf" ) ; m . put ( "ifm" , "application/vnd.shana.informed.formdata" ) ; m . put ( "itp" , "application/vnd.shana.informed.formtemplate" ) ; m . put ( "iif" , "application/vnd.shana.informed.interchange" ) ; m . put ( "ipk" , "application/vnd.shana.informed.package" ) ; m . put ( "twd" , "application/vnd.simtech-mindmapper" ) ; m . put ( "twds" , "application/vnd.simtech-mindmapper" ) ; m . put ( "mmf" , "application/vnd.smaf" ) ; m . put ( "teacher" , "application/vnd.smart.teacher" ) ; m . put ( "sdkm" , "application/vnd.solent.sdkm+xml" ) ; m . put ( "sdkd" , "application/vnd.solent.sdkm+xml" ) ; m . put ( "dxp" , "application/vnd.spotfire.dxp" ) ; m . put ( "sfs" , "application/vnd.spotfire.sfs" ) ; m . put ( "sdc" , "application/vnd.stardivision.calc" ) ; m . put ( "sda" , "application/vnd.stardivision.draw" ) ; m . put ( "sdd" , "application/vnd.stardivision.impress" ) ; m . put ( "smf" , "application/vnd.stardivision.math" ) ; m . put ( "sdw" , "application/vnd.stardivision.writer" ) ; m . put ( "vor" , "application/vnd.stardivision.writer" ) ; m . put ( "sgl" , "application/vnd.stardivision.writer-global" ) ; m . put ( "smzip" , "application/vnd.stepmania.package" ) ; m . put ( "sm" , "application/vnd.stepmania.stepchart" ) ; m . put ( "sxc" , "application/vnd.sun.xml.calc" ) ; m . put ( "stc" , "application/vnd.sun.xml.calc.template" ) ; m . put ( "sxd" , "application/vnd.sun.xml.draw" ) ; m . put ( "std" , "application/vnd.sun.xml.draw.template" ) ; m . put ( "sxi" , "application/vnd.sun.xml.impress" ) ; m . put ( "sti" , "application/vnd.sun.xml.impress.template" ) ; m . put ( "sxm" , "application/vnd.sun.xml.math" ) ; m . put ( "sxw" , "application/vnd.sun.xml.writer" ) ; m . put ( "sxg" , "application/vnd.sun.xml.writer.global" ) ; m . put ( "stw" , "application/vnd.sun.xml.writer.template" ) ; m . put ( "sus" , "application/vnd.sus-calendar" ) ; m . put ( "susp" , "application/vnd.sus-calendar" ) ; m . put ( "svd" , "application/vnd.svd" ) ; m . put ( "sis" , "application/vnd.symbian.install" ) ; m . put ( "sisx" , "application/vnd.symbian.install" ) ; m . put ( "xsm" , "application/vnd.syncml+xml" ) ; m . put ( "bdm" , "application/vnd.syncml.dm+wbxml" ) ; m . put ( "xdm" , "application/vnd.syncml.dm+xml" ) ; m . put ( "tao" , "application/vnd.tao.intent-module-archive" ) ; m . put ( "pcap" , "application/vnd.tcpdump.pcap" ) ; m . put ( "cap" , "application/vnd.tcpdump.pcap" ) ; m . put ( "dmp" , "application/vnd.tcpdump.pcap" ) ; m . put ( "tmo" , "application/vnd.tmobile-livetv" ) ; m . put ( "tpt" , "application/vnd.trid.tpt" ) ; m . put ( "mxs" , "application/vnd.triscape.mxs" ) ; m . put ( "tra" , "application/vnd.trueapp" ) ; m . put ( "ufd" , "application/vnd.ufdl" ) ; m . put ( "ufdl" , "application/vnd.ufdl" ) ; m . put ( "utz" , "application/vnd.uiq.theme" ) ; m . put ( "umj" , "application/vnd.umajin" ) ; m . put ( "unityweb" , "application/vnd.unity" ) ; m . put ( "uoml" , "application/vnd.uoml+xml" ) ; m . put ( "vcx" , "application/vnd.vcx" ) ; m . put ( "vsd" , "application/vnd.visio" ) ; m . put ( "vst" , "application/vnd.visio" ) ; m . put ( "vss" , "application/vnd.visio" ) ; m . put ( "vsw" , "application/vnd.visio" ) ; m . put ( "vis" , "application/vnd.visionary" ) ; m . put ( "vsf" , "application/vnd.vsf" ) ; m . put ( "wbxml" , "application/vnd.wap.wbxml" ) ; m . put ( "wmlc" , "application/vnd.wap.wmlc" ) ; m . put ( "wmlsc" , "application/vnd.wap.wmlscriptc" ) ; m . put ( "wtb" , "application/vnd.webturbo" ) ; m . put ( "nbp" , "application/vnd.wolfram.player" ) ; m . put ( "wpd" , "application/vnd.wordperfect" ) ; m . put ( "wqd" , "application/vnd.wqd" ) ; m . put ( "stf" , "application/vnd.wt.stf" ) ; m . put ( "xar" , "application/vnd.xara" ) ; m . put ( "xfdl" , "application/vnd.xfdl" ) ; m . put ( "hvd" , "application/vnd.yamaha.hv-dic" ) ; m . put ( "hvs" , "application/vnd.yamaha.hv-script" ) ; m . put ( "hvp" , "application/vnd.yamaha.hv-voice" ) ; m . put ( "osf" , "application/vnd.yamaha.openscoreformat" ) ; m . put ( "osfpvg" , "application/vnd.yamaha.openscoreformat.osfpvg+xml" ) ; m . put ( "saf" , "application/vnd.yamaha.smaf-audio" ) ; m . put ( "spf" , "application/vnd.yamaha.smaf-phrase" ) ; m . put ( "cmp" , "application/vnd.yellowriver-custom-menu" ) ; m . put ( "zir" , "application/vnd.zul" ) ; m . put ( "zirz" , "application/vnd.zul" ) ; m . put ( "zaz" , "application/vnd.zzazz.deck+xml" ) ; m . put ( "vxml" , "application/voicexml+xml" ) ; m . put ( "wgt" , "application/widget" ) ; m . put ( "hlp" , "application/winhlp" ) ; m . put ( "wsdl" , "application/wsdl+xml" ) ; m . put ( "wspolicy" , "application/wspolicy+xml" ) ; m . put ( "7z" , "application/x-7z-compressed" ) ; m . put ( "abw" , "application/x-abiword" ) ; m . put ( "ace" , "application/x-ace-compressed" ) ; m . put ( "dmg" , "application/x-apple-diskimage" ) ; m . put ( "aab" , "application/x-authorware-bin" ) ; m . put ( "x32" , "application/x-authorware-bin" ) ; m . put ( "u32" , "application/x-authorware-bin" ) ; m . put ( "vox" , "application/x-authorware-bin" ) ; m . put ( "aam" , "application/x-authorware-map" ) ; m . put ( "aas" , "application/x-authorware-seg" ) ; m . put ( "bcpio" , "application/x-bcpio" ) ; m . put ( "torrent" , "application/x-bittorrent" ) ; m . put ( "blb" , "application/x-blorb" ) ; m . put ( "blorb" , "application/x-blorb" ) ; m . put ( "bz" , "application/x-bzip" ) ; m . put ( "bz2" , "application/x-bzip2" ) ; m . put ( "boz" , "application/x-bzip2" ) ; m . put ( "cbr" , "application/x-cbr" ) ; m . put ( "cba" , "application/x-cbr" ) ; m . put ( "cbt" , "application/x-cbr" ) ; m . put ( "cbz" , "application/x-cbr" ) ; m . put ( "cb7" , "application/x-cbr" ) ; m . put ( "vcd" , "application/x-cdlink" ) ; m . put ( "cfs" , "application/x-cfs-compressed" ) ; m . put ( "chat" , "application/x-chat" ) ; m . put ( "pgn" , "application/x-chess-pgn" ) ; m . put ( "nsc" , "application/x-conference" ) ; m . put ( "cpio" , "application/x-cpio" ) ; m . put ( "csh" , "application/x-csh" ) ; m . put ( "deb" , "application/x-debian-package" ) ; m . put ( "udeb" , "application/x-debian-package" ) ; m . put ( "dgc" , "application/x-dgc-compressed" ) ; m . put ( "dir" , "application/x-director" ) ; m . put ( "dcr" , "application/x-director" ) ; m . put ( "dxr" , "application/x-director" ) ; m . put ( "cst" , "application/x-director" ) ; m . put ( "cct" , "application/x-director" ) ; m . put ( "cxt" , "application/x-director" ) ; m . put ( "w3d" , "application/x-director" ) ; m . put ( "fgd" , "application/x-director" ) ; m . put ( "swa" , "application/x-director" ) ; m . put ( "wad" , "application/x-doom" ) ; m . put ( "ncx" , "application/x-dtbncx+xml" ) ; m . put ( "dtb" , "application/x-dtbook+xml" ) ; m . put ( "res" , "application/x-dtbresource+xml" ) ; m . put ( "dvi" , "application/x-dvi" ) ; m . put ( "evy" , "application/x-envoy" ) ; m . put ( "eva" , "application/x-eva" ) ; m . put ( "bdf" , "application/x-font-bdf" ) ; m . put ( "gsf" , "application/x-font-ghostscript" ) ; m . put ( "psf" , "application/x-font-linux-psf" ) ; m . put ( "otf" , "application/x-font-otf" ) ; m . put ( "pcf" , "application/x-font-pcf" ) ; m . put ( "snf" , "application/x-font-snf" ) ; m . put ( "ttf" , "application/x-font-ttf" ) ; m . put ( "ttc" , "application/x-font-ttf" ) ; m . put ( "pfa" , "application/x-font-type1" ) ; m . put ( "pfb" , "application/x-font-type1" ) ; m . put ( "pfm" , "application/x-font-type1" ) ; m . put ( "afm" , "application/x-font-type1" ) ; m . put ( "woff" , "application/x-font-woff" ) ; m . put ( "arc" , "application/x-freearc" ) ; m . put ( "spl" , "application/x-futuresplash" ) ; m . put ( "gca" , "application/x-gca-compressed" ) ; m . put ( "ulx" , "application/x-glulx" ) ; m . put ( "gnumeric" , "application/x-gnumeric" ) ; m . put ( "gramps" , "application/x-gramps-xml" ) ; m . put ( "gtar" , "application/x-gtar" ) ; m . put ( "hdf" , "application/x-hdf" ) ; m . put ( "install" , "application/x-install-instructions" ) ; m . put ( "iso" , "application/x-iso9660-image" ) ; m . put ( "jnlp" , "application/x-java-jnlp-file" ) ; m . put ( "latex" , "application/x-latex" ) ; m . put ( "lzh" , "application/x-lzh-compressed" ) ; m . put ( "lha" , "application/x-lzh-compressed" ) ; m . put ( "mie" , "application/x-mie" ) ; m . put ( "prc" , "application/x-mobipocket-ebook" ) ; m . put ( "mobi" , "application/x-mobipocket-ebook" ) ; m . put ( "application" , "application/x-ms-application" ) ; m . put ( "lnk" , "application/x-ms-shortcut" ) ; m . put ( "wmd" , "application/x-ms-wmd" ) ; m . put ( "wmz" , "application/x-ms-wmz" ) ; m . put ( "xbap" , "application/x-ms-xbap" ) ; m . put ( "mdb" , "application/x-msaccess" ) ; m . put ( "obd" , "application/x-msbinder" ) ; m . put ( "crd" , "application/x-mscardfile" ) ; m . put ( "clp" , "application/x-msclip" ) ; m . put ( "exe" , "application/x-msdownload" ) ; m . put ( "dll" , "application/x-msdownload" ) ; m . put ( "com" , "application/x-msdownload" ) ; m . put ( "bat" , "application/x-msdownload" ) ; m . put ( "msi" , "application/x-msdownload" ) ; m . put ( "mvb" , "application/x-msmediaview" ) ; m . put ( "m13" , "application/x-msmediaview" ) ; m . put ( "m14" , "application/x-msmediaview" ) ; m . put ( "wmf" , "application/x-msmetafile" ) ; m . put ( "emf" , "application/x-msmetafile" ) ; m . put ( "emz" , "application/x-msmetafile" ) ; m . put ( "mny" , "application/x-msmoney" ) ; m . put ( "pub" , "application/x-mspublisher" ) ; m . put ( "scd" , "application/x-msschedule" ) ; m . put ( "trm" , "application/x-msterminal" ) ; m . put ( "wri" , "application/x-mswrite" ) ; m . put ( "nc" , "application/x-netcdf" ) ; m . put ( "cdf" , "application/x-netcdf" ) ; m . put ( "nzb" , "application/x-nzb" ) ; m . put ( "p12" , "application/x-pkcs12" ) ; m . put ( "pfx" , "application/x-pkcs12" ) ; m . put ( "p7b" , "application/x-pkcs7-certificates" ) ; m . put ( "spc" , "application/x-pkcs7-certificates" ) ; m . put ( "p7r" , "application/x-pkcs7-certreqresp" ) ; m . put ( "rar" , "application/x-rar-compressed" ) ; m . put ( "ris" , "application/x-research-info-systems" ) ; m . put ( "sh" , "application/x-sh" ) ; m . put ( "shar" , "application/x-shar" ) ; m . put ( "swf" , "application/x-shockwave-flash" ) ; m . put ( "xap" , "application/x-silverlight-app" ) ; m . put ( "sql" , "application/x-sql" ) ; m . put ( "sit" , "application/x-stuffit" ) ; m . put ( "sitx" , "application/x-stuffitx" ) ; m . put ( "srt" , "application/x-subrip" ) ; m . put ( "sv4cpio" , "application/x-sv4cpio" ) ; m . put ( "sv4crc" , "application/x-sv4crc" ) ; m . put ( "t3" , "application/x-t3vm-image" ) ; m . put ( "gam" , "application/x-tads" ) ; m . put ( "tar" , "application/x-tar" ) ; m . put ( "tcl" , "application/x-tcl" ) ; m . put ( "tex" , "application/x-tex" ) ; m . put ( "tfm" , "application/x-tex-tfm" ) ; m . put ( "texinfo" , "application/x-texinfo" ) ; m . put ( "texi" , "application/x-texinfo" ) ; m . put ( "obj" , "application/x-tgif" ) ; m . put ( "ustar" , "application/x-ustar" ) ; m . put ( "src" , "application/x-wais-source" ) ; m . put ( "der" , "application/x-x509-ca-cert" ) ; m . put ( "crt" , "application/x-x509-ca-cert" ) ; m . put ( "fig" , "application/x-xfig" ) ; m . put ( "xlf" , "application/x-xliff+xml" ) ; m . put ( "xpi" , "application/x-xpinstall" ) ; m . put ( "xz" , "application/x-xz" ) ; m . put ( "z1" , "application/x-zmachine" ) ; m . put ( "z2" , "application/x-zmachine" ) ; m . put ( "z3" , "application/x-zmachine" ) ; m . put ( "z4" , "application/x-zmachine" ) ; m . put ( "z5" , "application/x-zmachine" ) ; m . put ( "z6" , "application/x-zmachine" ) ; m . put ( "z7" , "application/x-zmachine" ) ; m . put ( "z8" , "application/x-zmachine" ) ; m . put ( "xaml" , "application/xaml+xml" ) ; m . put ( "xdf" , "application/xcap-diff+xml" ) ; m . put ( "xenc" , "application/xenc+xml" ) ; m . put ( "xhtml" , "application/xhtml+xml" ) ; m . put ( "xht" , "application/xhtml+xml" ) ; m . put ( "xml" , "application/xml" ) ; m . put ( "xsl" , "application/xml" ) ; m . put ( "dtd" , "application/xml-dtd" ) ; m . put ( "xop" , "application/xop+xml" ) ; m . put ( "xpl" , "application/xproc+xml" ) ; m . put ( "xslt" , "application/xslt+xml" ) ; m . put ( "xspf" , "application/xspf+xml" ) ; m . put ( "mxml" , "application/xv+xml" ) ; m . put ( "xhvml" , "application/xv+xml" ) ; m . put ( "xvml" , "application/xv+xml" ) ; m . put ( "xvm" , "application/xv+xml" ) ; m . put ( "yang" , "application/yang" ) ; m . put ( "yin" , "application/yin+xml" ) ; m . put ( "zip" , "application/zip" ) ; m . put ( "adp" , "audio/adpcm" ) ; m . put ( "au" , "audio/basic" ) ; m . put ( "snd" , "audio/basic" ) ; m . put ( "mid" , "audio/midi" ) ; m . put ( "midi" , "audio/midi" ) ; m . put ( "kar" , "audio/midi" ) ; m . put ( "rmi" , "audio/midi" ) ; m . put ( "mp4a" , "audio/mp4" ) ; m . put ( "mpga" , "audio/mpeg" ) ; m . put ( "mp2" , "audio/mpeg" ) ; m . put ( "mp2a" , "audio/mpeg" ) ; m . put ( "mp3" , "audio/mpeg" ) ; m . put ( "m2a" , "audio/mpeg" ) ; m . put ( "m3a" , "audio/mpeg" ) ; m . put ( "oga" , "audio/ogg" ) ; m . put ( "ogg" , "audio/ogg" ) ; m . put ( "spx" , "audio/ogg" ) ; m . put ( "s3m" , "audio/s3m" ) ; m . put ( "sil" , "audio/silk" ) ; m . put ( "uva" , "audio/vnd.dece.audio" ) ; m . put ( "uvva" , "audio/vnd.dece.audio" ) ; m . put ( "eol" , "audio/vnd.digital-winds" ) ; m . put ( "dra" , "audio/vnd.dra" ) ; m . put ( "dts" , "audio/vnd.dts" ) ; m . put ( "dtshd" , "audio/vnd.dts.hd" ) ; m . put ( "lvp" , "audio/vnd.lucent.voice" ) ; m . put ( "pya" , "audio/vnd.ms-playready.media.pya" ) ; m . put ( "ecelp4800" , "audio/vnd.nuera.ecelp4800" ) ; m . put ( "ecelp7470" , "audio/vnd.nuera.ecelp7470" ) ; m . put ( "ecelp9600" , "audio/vnd.nuera.ecelp9600" ) ; m . put ( "rip" , "audio/vnd.rip" ) ; m . put ( "weba" , "audio/webm" ) ; m . put ( "aac" , "audio/x-aac" ) ; m . put ( "aif" , "audio/x-aiff" ) ; m . put ( "aiff" , "audio/x-aiff" ) ; m . put ( "aifc" , "audio/x-aiff" ) ; m . put ( "caf" , "audio/x-caf" ) ; m . put ( "flac" , "audio/x-flac" ) ; m . put ( "mka" , "audio/x-matroska" ) ; m . put ( "m3u" , "audio/x-mpegurl" ) ; m . put ( "wax" , "audio/x-ms-wax" ) ; m . put ( "wma" , "audio/x-ms-wma" ) ; m . put ( "ram" , "audio/x-pn-realaudio" ) ; m . put ( "ra" , "audio/x-pn-realaudio" ) ; m . put ( "rmp" , "audio/x-pn-realaudio-plugin" ) ; m . put ( "wav" , "audio/x-wav" ) ; m . put ( "xm" , "audio/xm" ) ; m . put ( "cdx" , "chemical/x-cdx" ) ; m . put ( "cif" , "chemical/x-cif" ) ; m . put ( "cmdf" , "chemical/x-cmdf" ) ; m . put ( "cml" , "chemical/x-cml" ) ; m . put ( "csml" , "chemical/x-csml" ) ; m . put ( "xyz" , "chemical/x-xyz" ) ; m . put ( "bmp" , "image/bmp" ) ; m . put ( "cgm" , "image/cgm" ) ; m . put ( "g3" , "image/g3fax" ) ; m . put ( "gif" , "image/gif" ) ; m . put ( "ief" , "image/ief" ) ; m . put ( "jpeg" , "image/jpeg" ) ; m . put ( "jpg" , "image/jpeg" ) ; m . put ( "jpe" , "image/jpeg" ) ; m . put ( "ktx" , "image/ktx" ) ; m . put ( "png" , "image/png" ) ; m . put ( "btif" , "image/prs.btif" ) ; m . put ( "sgi" , "image/sgi" ) ; m . put ( "svg" , "image/svg+xml" ) ; m . put ( "svgz" , "image/svg+xml" ) ; m . put ( "tiff" , "image/tiff" ) ; m . put ( "tif" , "image/tiff" ) ; m . put ( "psd" , "image/vnd.adobe.photoshop" ) ; m . put ( "uvi" , "image/vnd.dece.graphic" ) ; m . put ( "uvvi" , "image/vnd.dece.graphic" ) ; m . put ( "uvg" , "image/vnd.dece.graphic" ) ; m . put ( "uvvg" , "image/vnd.dece.graphic" ) ; m . put ( "sub" , "image/vnd.dvb.subtitle" ) ; m . put ( "djvu" , "image/vnd.djvu" ) ; m . put ( "djv" , "image/vnd.djvu" ) ; m . put ( "dwg" , "image/vnd.dwg" ) ; m . put ( "dxf" , "image/vnd.dxf" ) ; m . put ( "fbs" , "image/vnd.fastbidsheet" ) ; m . put ( "fpx" , "image/vnd.fpx" ) ; m . put ( "fst" , "image/vnd.fst" ) ; m . put ( "mmr" , "image/vnd.fujixerox.edmics-mmr" ) ; m . put ( "rlc" , "image/vnd.fujixerox.edmics-rlc" ) ; m . put ( "mdi" , "image/vnd.ms-modi" ) ; m . put ( "wdp" , "image/vnd.ms-photo" ) ; m . put ( "npx" , "image/vnd.net-fpx" ) ; m . put ( "wbmp" , "image/vnd.wap.wbmp" ) ; m . put ( "xif" , "image/vnd.xiff" ) ; m . put ( "webp" , "image/webp" ) ; m . put ( "3ds" , "image/x-3ds" ) ; m . put ( "ras" , "image/x-cmu-raster" ) ; m . put ( "cmx" , "image/x-cmx" ) ; m . put ( "fh" , "image/x-freehand" ) ; m . put ( "fhc" , "image/x-freehand" ) ; m . put ( "fh4" , "image/x-freehand" ) ; m . put ( "fh5" , "image/x-freehand" ) ; m . put ( "fh7" , "image/x-freehand" ) ; m . put ( "ico" , "image/x-icon" ) ; m . put ( "sid" , "image/x-mrsid-image" ) ; m . put ( "pcx" , "image/x-pcx" ) ; m . put ( "pic" , "image/x-pict" ) ; m . put ( "pct" , "image/x-pict" ) ; m . put ( "pnm" , "image/x-portable-anymap" ) ; m . put ( "pbm" , "image/x-portable-bitmap" ) ; m . put ( "pgm" , "image/x-portable-graymap" ) ; m . put ( "ppm" , "image/x-portable-pixmap" ) ; m . put ( "rgb" , "image/x-rgb" ) ; m . put ( "tga" , "image/x-tga" ) ; m . put ( "xbm" , "image/x-xbitmap" ) ; m . put ( "xpm" , "image/x-xpixmap" ) ; m . put ( "xwd" , "image/x-xwindowdump" ) ; m . put ( "eml" , "message/rfc822" ) ; m . put ( "mime" , "message/rfc822" ) ; m . put ( "igs" , "model/iges" ) ; m . put ( "iges" , "model/iges" ) ; m . put ( "msh" , "model/mesh" ) ; m . put ( "mesh" , "model/mesh" ) ; m . put ( "silo" , "model/mesh" ) ; m . put ( "dae" , "model/vnd.collada+xml" ) ; m . put ( "dwf" , "model/vnd.dwf" ) ; m . put ( "gdl" , "model/vnd.gdl" ) ; m . put ( "gtw" , "model/vnd.gtw" ) ; m . put ( "mts" , "model/vnd.mts" ) ; m . put ( "vtu" , "model/vnd.vtu" ) ; m . put ( "wrl" , "model/vrml" ) ; m . put ( "vrml" , "model/vrml" ) ; m . put ( "x3db" , "model/x3d+binary" ) ; m . put ( "x3dbz" , "model/x3d+binary" ) ; m . put ( "x3dv" , "model/x3d+vrml" ) ; m . put ( "x3dvz" , "model/x3d+vrml" ) ; m . put ( "x3d" , "model/x3d+xml" ) ; m . put ( "x3dz" , "model/x3d+xml" ) ; m . put ( "appcache" , "text/cache-manifest" ) ; m . put ( "ics" , "text/calendar" ) ; m . put ( "ifb" , "text/calendar" ) ; m . put ( "css" , "text/css" ) ; m . put ( "csv" , "text/csv" ) ; m . put ( "html" , "text/html" ) ; m . put ( "htm" , "text/html" ) ; m . put ( "n3" , "text/n3" ) ; m . put ( "txt" , "text/plain" ) ; m . put ( "text" , "text/plain" ) ; m . put ( "conf" , "text/plain" ) ; m . put ( "def" , "text/plain" ) ; m . put ( "list" , "text/plain" ) ; m . put ( "log" , "text/plain" ) ; m . put ( "in" , "text/plain" ) ; m . put ( "dsc" , "text/prs.lines.tag" ) ; m . put ( "rtx" , "text/richtext" ) ; m . put ( "sgml" , "text/sgml" ) ; m . put ( "sgm" , "text/sgml" ) ; m . put ( "tsv" , "text/tab-separated-values" ) ; m . put ( "t" , "text/troff" ) ; m . put ( "tr" , "text/troff" ) ; m . put ( "roff" , "text/troff" ) ; m . put ( "man" , "text/troff" ) ; m . put ( "me" , "text/troff" ) ; m . put ( "ms" , "text/troff" ) ; m . put ( "ttl" , "text/turtle" ) ; m . put ( "uri" , "text/uri-list" ) ; m . put ( "uris" , "text/uri-list" ) ; m . put ( "urls" , "text/uri-list" ) ; m . put ( "vcard" , "text/vcard" ) ; m . put ( "curl" , "text/vnd.curl" ) ; m . put ( "dcurl" , "text/vnd.curl.dcurl" ) ; m . put ( "scurl" , "text/vnd.curl.scurl" ) ; m . put ( "mcurl" , "text/vnd.curl.mcurl" ) ; m . put ( "fly" , "text/vnd.fly" ) ; m . put ( "flx" , "text/vnd.fmi.flexstor" ) ; m . put ( "gv" , "text/vnd.graphviz" ) ; m . put ( "3dml" , "text/vnd.in3d.3dml" ) ; m . put ( "spot" , "text/vnd.in3d.spot" ) ; m . put ( "jad" , "text/vnd.sun.j2me.app-descriptor" ) ; m . put ( "wml" , "text/vnd.wap.wml" ) ; m . put ( "wmls" , "text/vnd.wap.wmlscript" ) ; m . put ( "s" , "text/x-asm" ) ; m . put ( "asm" , "text/x-asm" ) ; m . put ( "c" , "text/x-c" ) ; m . put ( "cc" , "text/x-c" ) ; m . put ( "cxx" , "text/x-c" ) ; m . put ( "cpp" , "text/x-c" ) ; m . put ( "h" , "text/x-c" ) ; m . put ( "hh" , "text/x-c" ) ; m . put ( "dic" , "text/x-c" ) ; m . put ( "f" , "text/x-fortran" ) ; m . put ( "for" , "text/x-fortran" ) ; m . put ( "f77" , "text/x-fortran" ) ; m . put ( "f90" , "text/x-fortran" ) ; m . put ( "java" , "text/x-java-source" ) ; m . put ( "opml" , "text/x-opml" ) ; m . put ( "p" , "text/x-pascal" ) ; m . put ( "pas" , "text/x-pascal" ) ; m . put ( "nfo" , "text/x-nfo" ) ; m . put ( "etx" , "text/x-setext" ) ; m . put ( "sfv" , "text/x-sfv" ) ; m . put ( "uu" , "text/x-uuencode" ) ; m . put ( "vcs" , "text/x-vcalendar" ) ; m . put ( "vcf" , "text/x-vcard" ) ; m . put ( "3gp" , "video/3gpp" ) ; m . put ( "3g2" , "video/3gpp2" ) ; m . put ( "h261" , "video/h261" ) ; m . put ( "h263" , "video/h263" ) ; m . put ( "h264" , "video/h264" ) ; m . put ( "jpgv" , "video/jpeg" ) ; m . put ( "jpm" , "video/jpm" ) ; m . put ( "jpgm" , "video/jpm" ) ; m . put ( "mj2" , "video/mj2" ) ; m . put ( "mjp2" , "video/mj2" ) ; m . put ( "mp4" , "video/mp4" ) ; m . put ( "mp4v" , "video/mp4" ) ; m . put ( "mpg4" , "video/mp4" ) ; m . put ( "mpeg" , "video/mpeg" ) ; m . put ( "mpg" , "video/mpeg" ) ; m . put ( "mpe" , "video/mpeg" ) ; m . put ( "m1v" , "video/mpeg" ) ; m . put ( "m2v" , "video/mpeg" ) ; m . put ( "ogv" , "video/ogg" ) ; m . put ( "qt" , "video/quicktime" ) ; m . put ( "mov" , "video/quicktime" ) ; m . put ( "uvh" , "video/vnd.dece.hd" ) ; m . put ( "uvvh" , "video/vnd.dece.hd" ) ; m . put ( "uvm" , "video/vnd.dece.mobile" ) ; m . put ( "uvvm" , "video/vnd.dece.mobile" ) ; m . put ( "uvp" , "video/vnd.dece.pd" ) ; m . put ( "uvvp" , "video/vnd.dece.pd" ) ; m . put ( "uvs" , "video/vnd.dece.sd" ) ; m . put ( "uvvs" , "video/vnd.dece.sd" ) ; m . put ( "uvv" , "video/vnd.dece.video" ) ; m . put ( "uvvv" , "video/vnd.dece.video" ) ; m . put ( "dvb" , "video/vnd.dvb.file" ) ; m . put ( "fvt" , "video/vnd.fvt" ) ; m . put ( "mxu" , "video/vnd.mpegurl" ) ; m . put ( "m4u" , "video/vnd.mpegurl" ) ; m . put ( "pyv" , "video/vnd.ms-playready.media.pyv" ) ; m . put ( "uvu" , "video/vnd.uvvu.mp4" ) ; m . put ( "uvvu" , "video/vnd.uvvu.mp4" ) ; m . put ( "viv" , "video/vnd.vivo" ) ; m . put ( "webm" , "video/webm" ) ; m . put ( "f4v" , "video/x-f4v" ) ; m . put ( "fli" , "video/x-fli" ) ; m . put ( "flv" , "video/x-flv" ) ; m . put ( "m4v" , "video/x-m4v" ) ; m . put ( "mkv" , "video/x-matroska" ) ; m . put ( "mk3d" , "video/x-matroska" ) ; m . put ( "mks" , "video/x-matroska" ) ; m . put ( "mng" , "video/x-mng" ) ; m . put ( "asf" , "video/x-ms-asf" ) ; m . put ( "asx" , "video/x-ms-asf" ) ; m . put ( "vob" , "video/x-ms-vob" ) ; m . put ( "wm" , "video/x-ms-wm" ) ; m . put ( "wmv" , "video/x-ms-wmv" ) ; m . put ( "wmx" , "video/x-ms-wmx" ) ; m . put ( "wvx" , "video/x-ms-wvx" ) ; m . put ( "avi" , "video/x-msvideo" ) ; m . put ( "movie" , "video/x-sgi-movie" ) ; m . put ( "smv" , "video/x-smv" ) ; m . put ( "ice" , "x-conference/x-cooltalk" ) ; } public static String getMimeTypeForExtension ( String ext ) { return m . get ( ext ) ; } }
package io . vertx . core . http . impl ; import io . netty . bootstrap . ChannelFactory ; public class VertxNioServerChannelFactory implements ChannelFactory < VertxNioServerSocketChannel > { @ Override public VertxNioServerSocketChannel newChannel ( ) { return new VertxNioServerSocketChannel ( ) ; } }
package io . vertx . core . http . impl ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . ServerWebSocket ; import io . vertx . core . http . WebSocketFrame ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . net . impl . ConnectionBase ; import javax . net . ssl . SSLPeerUnverifiedException ; import javax . security . cert . X509Certificate ; public class ServerWebSocketImpl extends WebSocketImplBase implements ServerWebSocket { private final String uri ; private final String path ; private final String query ; private final Runnable connectRunnable ; private final MultiMap headers ; private Object metric ; private boolean connected ; private boolean rejected ; public ServerWebSocketImpl ( VertxInternal vertx , String uri , String path , String query , MultiMap headers , ConnectionBase conn , boolean supportsContinuation , Runnable connectRunnable , int maxWebSocketFrameSize ) { super ( vertx , conn , supportsContinuation , maxWebSocketFrameSize ) ; this . uri = uri ; this . path = path ; this . query = query ; this . headers = headers ; this . connectRunnable = connectRunnable ; } @ Override public String uri ( ) { return uri ; } @ Override public String path ( ) { return path ; } @ Override public String query ( ) { return query ; } @ Override public MultiMap headers ( ) { return headers ; } @ Override public void reject ( ) { synchronized ( conn ) { checkClosed ( ) ; if ( connectRunnable == null ) { throw new IllegalStateException ( "Cannot reject websocket on the client side" ) ; } if ( connected ) { throw new IllegalStateException ( "Cannot reject websocket, it has already been written to" ) ; } rejected = true ; } } @ Override public X509Certificate [ ] peerCertificateChain ( ) throws SSLPeerUnverifiedException { return conn . getPeerCertificateChain ( ) ; } @ Override public void close ( ) { synchronized ( conn ) { checkClosed ( ) ; if ( connectRunnable != null ) { if ( rejected ) { throw new IllegalStateException ( "Cannot close websocket, it has been rejected" ) ; } if ( ! connected && ! closed ) { connect ( ) ; } } super . close ( ) ; } } @ Override public ServerWebSocket handler ( Handler < Buffer > handler ) { synchronized ( conn ) { checkClosed ( ) ; this . dataHandler = handler ; return this ; } } @ Override public ServerWebSocket endHandler ( Handler < Void > handler ) { synchronized ( conn ) { checkClosed ( ) ; this . endHandler = handler ; return this ; } } @ Override public ServerWebSocket exceptionHandler ( Handler < Throwable > handler ) { synchronized ( conn ) { checkClosed ( ) ; this . exceptionHandler = handler ; return this ; } } @ Override public ServerWebSocket closeHandler ( Handler < Void > handler ) { synchronized ( conn ) { checkClosed ( ) ; this . closeHandler = handler ; return this ; } } @ Override public ServerWebSocket frameHandler ( Handler < WebSocketFrame > handler ) { synchronized ( conn ) { checkClosed ( ) ; this . frameHandler = handler ; return this ; } } @ Override public ServerWebSocket pause ( ) { synchronized ( conn ) { checkClosed ( ) ; conn . doPause ( ) ; return this ; } } @ Override public ServerWebSocket resume ( ) { synchronized ( conn ) { checkClosed ( ) ; conn . doResume ( ) ; return this ; } } @ Override public ServerWebSocket setWriteQueueMaxSize ( int maxSize ) { synchronized ( conn ) { checkClosed ( ) ; conn . doSetWriteQueueMaxSize ( maxSize ) ; return this ; } } @ Override public boolean writeQueueFull ( ) { synchronized ( conn ) { checkClosed ( ) ; return conn . isNotWritable ( ) ; } } @ Override public ServerWebSocket write ( Buffer data ) { synchronized ( conn ) { checkClosed ( ) ; writeFrame ( WebSocketFrame . binaryFrame ( data , true ) ) ; return this ; } } @ Override public ServerWebSocket drainHandler ( Handler < Void > handler ) { synchronized ( conn ) { checkClosed ( ) ; this . drainHandler = handler ; return this ; } } @ Override public ServerWebSocket writeFrame ( WebSocketFrame frame ) { synchronized ( conn ) { if ( connectRunnable != null ) { if ( rejected ) { throw new IllegalStateException ( "Cannot write to websocket, it has been rejected" ) ; } if ( ! connected && ! closed ) { connect ( ) ; } } super . writeFrameInternal ( frame ) ; return this ; } } @ Override public ServerWebSocket writeFinalTextFrame ( String text ) { return writeFrame ( WebSocketFrame . textFrame ( text , true ) ) ; } @ Override public ServerWebSocket writeFinalBinaryFrame ( Buffer data ) { return writeFrame ( WebSocketFrame . binaryFrame ( data , true ) ) ; } @ Override public ServerWebSocket writeBinaryMessage ( Buffer data ) { synchronized ( conn ) { checkClosed ( ) ; writeMessageInternal ( data ) ; return this ; } } private void connect ( ) { connectRunnable . run ( ) ; connected = true ; } void connectNow ( ) { synchronized ( conn ) { if ( ! connected && ! rejected ) { connect ( ) ; } } } boolean isRejected ( ) { synchronized ( conn ) { return rejected ; } } void setMetric ( Object metric ) { this . metric = metric ; } Object getMetric ( ) { return metric ; } }
package io . vertx . core . http . impl ; import io . netty . handler . codec . http . DefaultHttpHeaders ; import io . netty . handler . codec . http . HttpResponse ; import io . netty . handler . codec . http . LastHttpContent ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . Vertx ; import io . vertx . core . VoidHandler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . HttpClientResponse ; import io . vertx . core . http . HttpHeaders ; import io . vertx . core . net . NetSocket ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . List ; import java . util . Queue ; public class HttpClientResponseImpl implements HttpClientResponse { private final int statusCode ; private final String statusMessage ; private final HttpClientRequestImpl request ; private final Vertx vertx ; private final ClientConnection conn ; private final HttpResponse response ; private Handler < Buffer > dataHandler ; private Handler < Void > endHandler ; private Handler < Throwable > exceptionHandler ; private LastHttpContent trailer ; private boolean paused ; private Queue < Buffer > pausedChunks ; private boolean hasPausedEnd ; private LastHttpContent pausedTrailer ; private NetSocket netSocket ; private long bytesRead ; private MultiMap headers ; private MultiMap trailers ; private List < String > cookies ; HttpClientResponseImpl ( Vertx vertx , HttpClientRequestImpl request , ClientConnection conn , HttpResponse response ) { this . vertx = vertx ; this . statusCode = response . getStatus ( ) . code ( ) ; this . statusMessage = response . getStatus ( ) . reasonPhrase ( ) ; this . request = request ; this . conn = conn ; this . response = response ; } @ Override public int statusCode ( ) { return statusCode ; } @ Override public String statusMessage ( ) { return statusMessage ; } @ Override public synchronized MultiMap headers ( ) { if ( headers == null ) { headers = new HeadersAdaptor ( response . headers ( ) ) ; } return headers ; } @ Override public String getHeader ( String headerName ) { return headers ( ) . get ( headerName ) ; } @ Override public synchronized MultiMap trailers ( ) { if ( trailers == null ) { trailers = new HeadersAdaptor ( new DefaultHttpHeaders ( ) ) ; } return trailers ; } @ Override public String getTrailer ( String trailerName ) { return trailers . get ( trailerName ) ; } @ Override public synchronized List < String > cookies ( ) { if ( cookies == null ) { cookies = new ArrayList < > ( ) ; cookies . addAll ( response . headers ( ) . getAll ( HttpHeaders . SET_COOKIE ) ) ; if ( trailer != null ) { cookies . addAll ( trailer . trailingHeaders ( ) . getAll ( HttpHeaders . SET_COOKIE ) ) ; } } return cookies ; } @ Override public synchronized HttpClientResponse handler ( Handler < Buffer > dataHandler ) { this . dataHandler = dataHandler ; return this ; } @ Override public synchronized HttpClientResponse endHandler ( Handler < Void > endHandler ) { this . endHandler = endHandler ; return this ; } @ Override public synchronized HttpClientResponse exceptionHandler ( Handler < Throwable > exceptionHandler ) { this . exceptionHandler = exceptionHandler ; return this ; } @ Override public synchronized HttpClientResponse pause ( ) { paused = true ; conn . doPause ( ) ; return this ; } @ Override public synchronized HttpClientResponse resume ( ) { paused = false ; doResume ( ) ; conn . doResume ( ) ; return this ; } @ Override public HttpClientResponse bodyHandler ( final Handler < Buffer > bodyHandler ) { BodyHandler handler = new BodyHandler ( ) ; handler ( handler ) ; endHandler ( new VoidHandler ( ) { public void handle ( ) { handler . notifyHandler ( bodyHandler ) ; } } ) ; return this ; } private void doResume ( ) { if ( pausedChunks != null ) { Buffer chunk ; while ( ( chunk = pausedChunks . poll ( ) ) != null ) { final Buffer theChunk = chunk ; vertx . runOnContext ( new VoidHandler ( ) { @ Override protected void handle ( ) { handleChunk ( theChunk ) ; } } ) ; } } if ( hasPausedEnd ) { final LastHttpContent theTrailer = pausedTrailer ; vertx . runOnContext ( new VoidHandler ( ) { @ Override protected void handle ( ) { handleEnd ( theTrailer ) ; } } ) ; hasPausedEnd = false ; pausedTrailer = null ; } } synchronized void handleChunk ( Buffer data ) { bytesRead += data . length ( ) ; if ( paused ) { if ( pausedChunks == null ) { pausedChunks = new ArrayDeque < > ( ) ; } pausedChunks . add ( data ) ; } else { request . dataReceived ( ) ; if ( dataHandler != null ) { dataHandler . handle ( data ) ; } } } synchronized void handleEnd ( LastHttpContent trailer ) { conn . reportBytesRead ( bytesRead ) ; bytesRead = 0 ; request . reportResponseEnd ( this ) ; if ( paused ) { hasPausedEnd = true ; pausedTrailer = trailer ; } else { this . trailer = trailer ; trailers = new HeadersAdaptor ( trailer . trailingHeaders ( ) ) ; if ( endHandler != null ) { endHandler . handle ( null ) ; } } } synchronized void handleException ( Throwable e ) { if ( exceptionHandler != null ) { exceptionHandler . handle ( e ) ; } } @ Override public synchronized NetSocket netSocket ( ) { if ( netSocket == null ) { netSocket = conn . createNetSocket ( ) ; } return netSocket ; } private static final class BodyHandler implements Handler < Buffer > { private Buffer body ; @ Override public void handle ( Buffer event ) { body ( ) . appendBuffer ( event ) ; } private Buffer body ( ) { if ( body == null ) { body = Buffer . buffer ( ) ; } return body ; } void notifyHandler ( Handler < Buffer > bodyHandler ) { bodyHandler . handle ( body ( ) ) ; body = null ; } } }
package io . vertx . core . http . impl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . handler . codec . http . DefaultLastHttpContent ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpResponse ; import io . netty . handler . codec . http . HttpResponseStatus ; import io . netty . handler . codec . http . HttpVersion ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . handler . codec . DecoderResult ; class AssembledFullHttpResponse extends AssembledHttpResponse implements FullHttpResponse { public AssembledFullHttpResponse ( HttpResponse response , LastHttpContent content ) { this ( response , content . content ( ) , content . trailingHeaders ( ) , content . getDecoderResult ( ) ) ; } public AssembledFullHttpResponse ( HttpResponse response ) { this ( response , Unpooled . EMPTY_BUFFER ) ; } public AssembledFullHttpResponse ( HttpResponse response , ByteBuf buf ) { super ( response , toLastContent ( buf , null , DecoderResult . SUCCESS ) ) ; } public AssembledFullHttpResponse ( HttpResponse response , ByteBuf buf , HttpHeaders trailingHeaders , DecoderResult result ) { super ( response , toLastContent ( buf , trailingHeaders , result ) ) ; } private static LastHttpContent toLastContent ( ByteBuf buf , HttpHeaders trailingHeaders , DecoderResult result ) { if ( buf . isReadable ( ) ) { if ( trailingHeaders == null ) { return new DefaultLastHttpContent ( buf ) ; } else { return new AssembledLastHttpContent ( buf , trailingHeaders , result ) ; } } else { if ( trailingHeaders == null ) { return LastHttpContent . EMPTY_LAST_CONTENT ; } else { return new AssembledLastHttpContent ( Unpooled . EMPTY_BUFFER , trailingHeaders , result ) ; } } } @ Override public AssembledFullHttpResponse setStatus ( HttpResponseStatus status ) { super . setStatus ( status ) ; return this ; } @ Override public AssembledFullHttpResponse retain ( int increment ) { super . retain ( increment ) ; return this ; } @ Override public AssembledFullHttpResponse retain ( ) { super . retain ( ) ; return this ; } @ Override public AssembledFullHttpResponse duplicate ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public AssembledFullHttpResponse copy ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public AssembledFullHttpResponse setProtocolVersion ( HttpVersion version ) { super . setProtocolVersion ( version ) ; return this ; } @ Override public HttpHeaders trailingHeaders ( ) { return ( ( LastHttpContent ) content ) . trailingHeaders ( ) ; } }
package io . vertx . core . http . impl ; import io . netty . buffer . ByteBuf ; import io . netty . handler . codec . http . DefaultHttpContent ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . handler . codec . http . QueryStringDecoder ; import io . netty . handler . codec . http . multipart . Attribute ; import io . netty . handler . codec . http . multipart . DefaultHttpDataFactory ; import io . netty . handler . codec . http . multipart . FileUpload ; import io . netty . handler . codec . http . multipart . HttpPostRequestDecoder ; import io . netty . handler . codec . http . multipart . InterfaceHttpData ; import io . netty . util . CharsetUtil ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . CaseInsensitiveHeaders ; import io . vertx . core . http . HttpServerFileUpload ; import io . vertx . core . http . HttpServerRequest ; import io . vertx . core . http . HttpServerResponse ; import io . vertx . core . http . HttpVersion ; import io . vertx . core . http . ServerWebSocket ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . net . NetSocket ; import io . vertx . core . net . SocketAddress ; import javax . net . ssl . SSLPeerUnverifiedException ; import javax . security . cert . X509Certificate ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URI ; import java . net . URISyntaxException ; import java . nio . charset . Charset ; import java . util . List ; import java . util . Map ; public class HttpServerRequestImpl implements HttpServerRequest { private static final Logger log = LoggerFactory . getLogger ( HttpServerRequestImpl . class ) ; private final ServerConnection conn ; private final HttpRequest request ; private final HttpServerResponse response ; private io . vertx . core . http . HttpVersion version ; private io . vertx . core . http . HttpMethod method ; private String uri ; private String path ; private String query ; private Handler < Buffer > dataHandler ; private Handler < Throwable > exceptionHandler ; private MultiMap params ; private MultiMap headers ; private String absoluteURI ; private NetSocket netSocket ; private Handler < HttpServerFileUpload > uploadHandler ; private Handler < Void > endHandler ; private MultiMap attributes ; private HttpPostRequestDecoder decoder ; private boolean ended ; HttpServerRequestImpl ( ServerConnection conn , HttpRequest request , HttpServerResponse response ) { this . conn = conn ; this . request = request ; this . response = response ; } @ Override public io . vertx . core . http . HttpVersion version ( ) { if ( version == null ) { io . netty . handler . codec . http . HttpVersion nettyVersion = request . getProtocolVersion ( ) ; if ( nettyVersion == io . netty . handler . codec . http . HttpVersion . HTTP_1_0 ) { version = HttpVersion . HTTP_1_0 ; } else if ( nettyVersion == io . netty . handler . codec . http . HttpVersion . HTTP_1_1 ) { version = HttpVersion . HTTP_1_1 ; } else { throw new IllegalStateException ( "Unsupported HTTP version: " + nettyVersion ) ; } } return version ; } @ Override public io . vertx . core . http . HttpMethod method ( ) { if ( method == null ) { method = io . vertx . core . http . HttpMethod . valueOf ( request . getMethod ( ) . toString ( ) ) ; } return method ; } @ Override public String uri ( ) { if ( uri == null ) { uri = request . getUri ( ) ; } return uri ; } @ Override public String path ( ) { if ( path == null ) { path = UriParser . path ( uri ( ) ) ; } return path ; } @ Override public String query ( ) { if ( query == null ) { query = UriParser . query ( uri ( ) ) ; } return query ; } @ Override public HttpServerResponse response ( ) { return response ; } @ Override public MultiMap headers ( ) { if ( headers == null ) { headers = new HeadersAdaptor ( request . headers ( ) ) ; } return headers ; } @ Override public String getHeader ( String headerName ) { return headers ( ) . get ( headerName ) ; } @ Override public MultiMap params ( ) { if ( params == null ) { QueryStringDecoder queryStringDecoder = new QueryStringDecoder ( uri ( ) ) ; Map < String , List < String > > prms = queryStringDecoder . parameters ( ) ; params = new CaseInsensitiveHeaders ( ) ; if ( ! prms . isEmpty ( ) ) { for ( Map . Entry < String , List < String > > entry : prms . entrySet ( ) ) { params . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } return params ; } @ Override public String getParam ( String paramName ) { return params ( ) . get ( paramName ) ; } @ Override public HttpServerRequest handler ( Handler < Buffer > dataHandler ) { synchronized ( conn ) { checkEnded ( ) ; this . dataHandler = dataHandler ; return this ; } } @ Override public HttpServerRequest exceptionHandler ( Handler < Throwable > handler ) { synchronized ( conn ) { this . exceptionHandler = handler ; return this ; } } @ Override public HttpServerRequest pause ( ) { synchronized ( conn ) { conn . pause ( ) ; return this ; } } @ Override public HttpServerRequest resume ( ) { synchronized ( conn ) { conn . resume ( ) ; return this ; } } @ Override public HttpServerRequest endHandler ( Handler < Void > handler ) { synchronized ( conn ) { checkEnded ( ) ; this . endHandler = handler ; return this ; } } @ Override public SocketAddress remoteAddress ( ) { return conn . remoteAddress ( ) ; } @ Override public String absoluteURI ( ) { if ( absoluteURI == null ) { try { URI uri = new URI ( uri ( ) ) ; String scheme = uri . getScheme ( ) ; if ( scheme != null && ( scheme . equals ( "http" ) || scheme . equals ( "https" ) ) ) { absoluteURI = uri . toString ( ) ; } else { String host = headers ( ) . get ( HttpHeaders . Names . HOST ) ; if ( host != null ) { absoluteURI = ( conn . isSSL ( ) ? "https://" : "http://" ) + host + uri ; } else { absoluteURI = conn . getServerOrigin ( ) + uri ; } } } catch ( URISyntaxException e ) { log . error ( "Failed to create abs uri" , e ) ; } } return absoluteURI ; } @ Override public X509Certificate [ ] peerCertificateChain ( ) throws SSLPeerUnverifiedException { return conn . getPeerCertificateChain ( ) ; } @ Override public HttpServerRequest bodyHandler ( final Handler < Buffer > bodyHandler ) { Buffer body = Buffer . buffer ( ) ; handler ( body : : appendBuffer ) ; endHandler ( v - > bodyHandler . handle ( body ) ) ; return this ; } @ Override public NetSocket netSocket ( ) { if ( netSocket == null ) { netSocket = conn . createNetSocket ( ) ; } return netSocket ; } @ Override public HttpServerRequest uploadHandler ( Handler < HttpServerFileUpload > handler ) { synchronized ( conn ) { checkEnded ( ) ; this . uploadHandler = handler ; return this ; } } @ Override public MultiMap formAttributes ( ) { return attributes ( ) ; } @ Override public String getFormAttribute ( String attributeName ) { return formAttributes ( ) . get ( attributeName ) ; } @ Override public ServerWebSocket upgrade ( ) { return conn . upgrade ( this , request ) ; } @ Override public HttpServerRequest setExpectMultipart ( boolean expect ) { synchronized ( conn ) { checkEnded ( ) ; if ( expect ) { if ( decoder == null ) { String contentType = request . headers ( ) . get ( HttpHeaders . Names . CONTENT_TYPE ) ; if ( contentType != null ) { HttpMethod method = request . getMethod ( ) ; String lowerCaseContentType = contentType . toLowerCase ( ) ; boolean isURLEncoded = lowerCaseContentType . startsWith ( HttpHeaders . Values . APPLICATION_X_WWW_FORM_URLENCODED ) ; if ( ( lowerCaseContentType . startsWith ( HttpHeaders . Values . MULTIPART_FORM_DATA ) || isURLEncoded ) && ( method . equals ( HttpMethod . POST ) || method . equals ( HttpMethod . PUT ) || method . equals ( HttpMethod . PATCH ) || method . equals ( HttpMethod . DELETE ) ) ) { decoder = new HttpPostRequestDecoder ( new DataFactory ( ) , request ) ; } } } } else { decoder = null ; } return this ; } } @ Override public boolean isExpectMultipart ( ) { synchronized ( conn ) { return decoder != null ; } } @ Override public SocketAddress localAddress ( ) { return conn . localAddress ( ) ; } @ Override public boolean isEnded ( ) { synchronized ( conn ) { return ended ; } } void handleData ( Buffer data ) { synchronized ( conn ) { if ( decoder != null ) { try { decoder . offer ( new DefaultHttpContent ( data . getByteBuf ( ) . duplicate ( ) ) ) ; } catch ( HttpPostRequestDecoder . ErrorDataDecoderException e ) { handleException ( e ) ; } } if ( dataHandler != null ) { dataHandler . handle ( data ) ; } } } void handleEnd ( ) { synchronized ( conn ) { ended = true ; if ( decoder != null ) { try { decoder . offer ( LastHttpContent . EMPTY_LAST_CONTENT ) ; while ( decoder . hasNext ( ) ) { InterfaceHttpData data = decoder . next ( ) ; if ( data instanceof Attribute ) { Attribute attr = ( Attribute ) data ; try { attributes ( ) . add ( attr . getName ( ) , attr . getValue ( ) ) ; } catch ( Exception e ) { handleException ( e ) ; } } } } catch ( HttpPostRequestDecoder . ErrorDataDecoderException e ) { handleException ( e ) ; } catch ( HttpPostRequestDecoder . EndOfDataDecoderException e ) { } finally { decoder . destroy ( ) ; } } if ( endHandler != null ) { endHandler . handle ( null ) ; } } } void handleException ( Throwable t ) { synchronized ( conn ) { if ( exceptionHandler != null ) { exceptionHandler . handle ( t ) ; } } } private void checkEnded ( ) { if ( ended ) { throw new IllegalStateException ( "Request has already been read" ) ; } } private MultiMap attributes ( ) { if ( attributes == null ) { attributes = new CaseInsensitiveHeaders ( ) ; } return attributes ; } private final static class NettyFileUpload implements FileUpload { private final HttpServerFileUploadImpl upload ; private final String name ; private String contentType ; private String filename ; private String contentTransferEncoding ; private Charset charset ; private boolean completed ; private NettyFileUpload ( HttpServerFileUploadImpl upload , String name , String filename , String contentType , String contentTransferEncoding , Charset charset ) { this . upload = upload ; this . name = name ; this . filename = filename ; this . contentType = contentType ; this . contentTransferEncoding = contentTransferEncoding ; this . charset = charset ; } @ Override public void setContent ( ByteBuf channelBuffer ) throws IOException { completed = true ; upload . receiveData ( Buffer . buffer ( channelBuffer ) ) ; upload . complete ( ) ; } @ Override public void addContent ( ByteBuf channelBuffer , boolean last ) throws IOException { upload . receiveData ( Buffer . buffer ( channelBuffer ) ) ; if ( last ) { completed = true ; upload . complete ( ) ; } } @ Override public void setContent ( File file ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public void setContent ( InputStream inputStream ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public boolean isCompleted ( ) { return completed ; } @ Override public long length ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public void delete ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public byte [ ] get ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public ByteBuf getChunk ( int i ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public String getString ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public String getString ( Charset charset ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public void setCharset ( Charset charset ) { this . charset = charset ; } @ Override public Charset getCharset ( ) { return charset ; } @ Override public boolean renameTo ( File file ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public boolean isInMemory ( ) { return false ; } @ Override public File getFile ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public String getName ( ) { return name ; } @ Override public HttpDataType getHttpDataType ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public int compareTo ( InterfaceHttpData o ) { return 0 ; } @ Override public String getFilename ( ) { return filename ; } @ Override public void setFilename ( String filename ) { this . filename = filename ; } @ Override public void setContentType ( String contentType ) { this . contentType = contentType ; } @ Override public String getContentType ( ) { return contentType ; } @ Override public void setContentTransferEncoding ( String contentTransferEncoding ) { this . contentTransferEncoding = contentTransferEncoding ; } @ Override public String getContentTransferEncoding ( ) { return contentTransferEncoding ; } @ Override public ByteBuf getByteBuf ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public FileUpload copy ( ) { throw new UnsupportedOperationException ( ) ; } public FileUpload duplicate ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public FileUpload retain ( ) { return this ; } @ Override public FileUpload retain ( int increment ) { return this ; } @ Override public ByteBuf content ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public int refCnt ( ) { return 1 ; } @ Override public boolean release ( ) { return false ; } @ Override public boolean release ( int decrement ) { return false ; } } private static String urlDecode ( String str ) { return QueryStringDecoder . decodeComponent ( str , CharsetUtil . UTF_8 ) ; } private class DataFactory extends DefaultHttpDataFactory { DataFactory ( ) { super ( false ) ; } @ Override public FileUpload createFileUpload ( HttpRequest httpRequest , String name , String filename , String contentType , String contentTransferEncoding , Charset charset , long size ) { HttpServerFileUploadImpl upload = new HttpServerFileUploadImpl ( conn . vertx ( ) , HttpServerRequestImpl . this , name , filename , contentType , contentTransferEncoding , charset , size ) ; NettyFileUpload nettyUpload = new NettyFileUpload ( upload , name , filename , contentType , contentTransferEncoding , charset ) ; if ( uploadHandler != null ) { uploadHandler . handle ( upload ) ; } return nettyUpload ; } } }
package io . vertx . core . http . impl ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . http . HttpResponseEncoder ; import io . vertx . core . net . impl . PartialPooledByteBufAllocator ; import java . util . List ; final class VertxHttpResponseEncoder extends HttpResponseEncoder { private ChannelHandlerContext context ; @ Override protected void encode ( ChannelHandlerContext ctx , Object msg , List < Object > out ) throws Exception { super . encode ( context , msg , out ) ; } @ Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { this . context = PartialPooledByteBufAllocator . forceDirectAllocator ( ctx ) ; super . handlerAdded ( ctx ) ; } }
package io . vertx . core . http . impl ; import io . netty . channel . * ; import io . netty . handler . codec . http . * ; import io . netty . handler . codec . http . websocketx . * ; import io . netty . util . ReferenceCountUtil ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . VertxException ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . WebSocket ; import io . vertx . core . http . WebsocketVersion ; import io . vertx . core . http . impl . ws . WebSocketFrameInternal ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . net . NetSocket ; import io . vertx . core . net . impl . ConnectionBase ; import io . vertx . core . net . impl . NetSocketImpl ; import io . vertx . core . net . impl . VertxNetHandler ; import io . vertx . core . spi . metrics . HttpClientMetrics ; import java . net . URI ; import java . util . ArrayDeque ; import java . util . HashMap ; import java . util . Map ; import java . util . Queue ; class ClientConnection extends ConnectionBase { private static final Logger log = LoggerFactory . getLogger ( ClientConnection . class ) ; private final HttpClientImpl client ; private final String hostHeader ; private final boolean ssl ; private final String host ; private final int port ; private final ConnectionLifeCycleListener listener ; private final Queue < HttpClientRequestImpl > requests = new ArrayDeque < > ( ) ; private final Handler < Throwable > exceptionHandler ; private final Object metric ; private final HttpClientMetrics metrics ; private WebSocketClientHandshaker handshaker ; private HttpClientRequestImpl currentRequest ; private HttpClientResponseImpl currentResponse ; private HttpClientRequestImpl requestForResponse ; private WebSocketImpl ws ; ClientConnection ( VertxInternal vertx , HttpClientImpl client , Handler < Throwable > exceptionHandler , Channel channel , boolean ssl , String host , int port , ContextImpl context , ConnectionLifeCycleListener listener , HttpClientMetrics metrics ) { super ( vertx , channel , context , metrics ) ; this . client = client ; this . ssl = ssl ; this . host = host ; this . port = port ; if ( ( port == 80 && ! ssl ) || ( port == 443 && ssl ) ) { this . hostHeader = host ; } else { this . hostHeader = host + ':' + port ; } this . listener = listener ; this . exceptionHandler = exceptionHandler ; this . metrics = metrics ; this . metric = metrics . connected ( remoteAddress ( ) ) ; } @ Override protected Object metric ( ) { return metric ; } protected HttpClientMetrics metrics ( ) { return metrics ; } synchronized void toWebSocket ( String requestURI , MultiMap headers , WebsocketVersion vers , String subProtocols , int maxWebSocketFrameSize , Handler < WebSocket > wsConnect ) { if ( ws != null ) { throw new IllegalStateException ( "Already websocket" ) ; } try { URI wsuri = new URI ( requestURI ) ; if ( ! wsuri . isAbsolute ( ) ) { wsuri = new URI ( ( ssl ? "https:" : "http:" ) + "//" + host + ":" + port + requestURI ) ; } WebSocketVersion version = WebSocketVersion . valueOf ( ( vers == null ? WebSocketVersion . V13 : vers ) . toString ( ) ) ; HttpHeaders nettyHeaders ; if ( headers != null ) { nettyHeaders = new DefaultHttpHeaders ( ) ; for ( Map . Entry < String , String > entry : headers ) { nettyHeaders . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } } else { nettyHeaders = null ; } handshaker = WebSocketClientHandshakerFactory . newHandshaker ( wsuri , version , subProtocols , false , nettyHeaders , maxWebSocketFrameSize ) ; ChannelPipeline p = channel . pipeline ( ) ; p . addBefore ( "handler" , "handshakeCompleter" , new HandshakeInboundHandler ( wsConnect , version != WebSocketVersion . V00 ) ) ; handshaker . handshake ( channel ) . addListener ( future - > { if ( ! future . isSuccess ( ) && exceptionHandler != null ) { exceptionHandler . handle ( future . cause ( ) ) ; } } ) ; } catch ( Exception e ) { handleException ( e ) ; } } private final class HandshakeInboundHandler extends ChannelInboundHandlerAdapter { private final boolean supportsContinuation ; private final Handler < WebSocket > wsConnect ; private final ContextImpl context ; private final Queue < Object > buffered = new ArrayDeque < > ( ) ; private FullHttpResponse response ; private boolean handshaking = true ; public HandshakeInboundHandler ( Handler < WebSocket > wsConnect , boolean supportsContinuation ) { this . supportsContinuation = supportsContinuation ; this . wsConnect = wsConnect ; this . context = vertx . getContext ( ) ; } @ Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { super . channelInactive ( ctx ) ; if ( handshaking ) { handleException ( new WebSocketHandshakeException ( "Connection closed while handshake in process" ) ) ; } } @ Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { if ( handshaker != null && handshaking ) { if ( msg instanceof HttpResponse ) { HttpResponse resp = ( HttpResponse ) msg ; if ( resp . getStatus ( ) . code ( ) != 101 ) { handleException ( new WebSocketHandshakeException ( "Websocket connection attempt returned HTTP status code " + resp . getStatus ( ) . code ( ) ) ) ; return ; } response = new DefaultFullHttpResponse ( resp . getProtocolVersion ( ) , resp . getStatus ( ) ) ; response . headers ( ) . add ( resp . headers ( ) ) ; } if ( msg instanceof HttpContent ) { if ( response != null ) { response . content ( ) . writeBytes ( ( ( HttpContent ) msg ) . content ( ) ) ; if ( msg instanceof LastHttpContent ) { response . trailingHeaders ( ) . add ( ( ( LastHttpContent ) msg ) . trailingHeaders ( ) ) ; try { handshakeComplete ( ctx , response ) ; channel . pipeline ( ) . remove ( HandshakeInboundHandler . this ) ; for ( ; ; ) { Object m = buffered . poll ( ) ; if ( m == null ) { break ; } ctx . fireChannelRead ( m ) ; } } catch ( WebSocketHandshakeException e ) { close ( ) ; handleException ( e ) ; } } } } } else { buffered . add ( msg ) ; } } private void handleException ( WebSocketHandshakeException e ) { handshaking = false ; buffered . clear ( ) ; if ( exceptionHandler != null ) { context . executeFromIO ( ( ) - > { exceptionHandler . handle ( e ) ; } ) ; } else { log . error ( "Error in websocket handshake" , e ) ; } } private void handshakeComplete ( ChannelHandlerContext ctx , FullHttpResponse response ) { handshaking = false ; ChannelHandler handler = ctx . pipeline ( ) . get ( HttpContentDecompressor . class ) ; if ( handler != null ) { ctx . pipeline ( ) . remove ( handler ) ; } ContextImpl . setContext ( context ) ; WebSocketImpl webSocket = new WebSocketImpl ( vertx , ClientConnection . this , supportsContinuation , client . getOptions ( ) . getMaxWebsocketFrameSize ( ) ) ; ws = webSocket ; handshaker . finishHandshake ( channel , response ) ; context . executeFromIO ( ( ) - > { log . debug ( "WebSocket handshake complete" ) ; webSocket . setMetric ( metrics ( ) . connected ( metric ( ) , webSocket ) ) ; wsConnect . handle ( webSocket ) ; } ) ; } } public void closeHandler ( Handler < Void > handler ) { this . closeHandler = handler ; } boolean isClosed ( ) { return ! channel . isOpen ( ) ; } int getOutstandingRequestCount ( ) { return requests . size ( ) ; } @ Override public synchronized void handleInterestedOpsChanged ( ) { if ( ! isNotWritable ( ) ) { if ( currentRequest != null ) { currentRequest . handleDrained ( ) ; } else if ( ws != null ) { ws . writable ( ) ; } } } void handleResponse ( HttpResponse resp ) { if ( resp . getStatus ( ) . code ( ) == 100 ) { requestForResponse = requests . peek ( ) ; } else { requestForResponse = requests . poll ( ) ; } if ( requestForResponse == null ) { throw new IllegalStateException ( "No response handler" ) ; } HttpClientResponseImpl nResp = new HttpClientResponseImpl ( vertx , requestForResponse , this , resp ) ; currentResponse = nResp ; requestForResponse . handleResponse ( nResp ) ; } void handleResponseChunk ( Buffer buff ) { currentResponse . handleChunk ( buff ) ; } void handleResponseEnd ( LastHttpContent trailer ) { currentResponse . handleEnd ( trailer ) ; if ( currentResponse . statusCode ( ) != 100 && requestForResponse . getRequest ( ) . getMethod ( ) != HttpMethod . CONNECT ) { listener . responseEnded ( this ) ; } currentResponse = null ; } synchronized void handleWsFrame ( WebSocketFrameInternal frame ) { if ( ws != null ) { ws . handleFrame ( frame ) ; } } protected synchronized void handleClosed ( ) { super . handleClosed ( ) ; if ( ws != null ) { ws . handleClosed ( ) ; } Exception e = new VertxException ( "Connection was closed" ) ; for ( HttpClientRequestImpl req : requests ) { req . handleException ( e ) ; } if ( currentRequest != null ) { currentRequest . handleException ( e ) ; } else if ( currentResponse != null ) { currentResponse . handleException ( e ) ; } } protected ContextImpl getContext ( ) { return super . getContext ( ) ; } @ Override protected synchronized void handleException ( Throwable e ) { super . handleException ( e ) ; if ( currentRequest != null ) { currentRequest . handleException ( e ) ; } else if ( currentResponse != null ) { currentResponse . handleException ( e ) ; } } synchronized void setCurrentRequest ( HttpClientRequestImpl req ) { if ( currentRequest != null ) { throw new IllegalStateException ( "Connection is already writing a request" ) ; } this . currentRequest = req ; this . requests . add ( req ) ; } synchronized void endRequest ( ) { if ( currentRequest == null ) { throw new IllegalStateException ( "No write in progress" ) ; } currentRequest = null ; listener . requestEnded ( this ) ; } public String hostHeader ( ) { return hostHeader ; } @ Override public synchronized void close ( ) { if ( handshaker == null ) { super . close ( ) ; } else { endReadAndFlush ( ) ; handshaker . close ( channel , new CloseWebSocketFrame ( 1000 , null ) ) ; } } NetSocket createNetSocket ( ) { NetSocketImpl socket = new NetSocketImpl ( vertx , channel , context , client . getSslHelper ( ) , true , metrics , metric ) ; Map < Channel , NetSocketImpl > connectionMap = new HashMap < > ( 1 ) ; connectionMap . put ( channel , socket ) ; endReadAndFlush ( ) ; ChannelPipeline pipeline = channel . pipeline ( ) ; ChannelHandler inflater = pipeline . get ( HttpContentDecompressor . class ) ; if ( inflater != null ) { pipeline . remove ( inflater ) ; } pipeline . remove ( "codec" ) ; pipeline . replace ( "handler" , "handler" , new VertxNetHandler ( connectionMap ) { @ Override public void exceptionCaught ( ChannelHandlerContext chctx , Throwable t ) throws Exception { client . removeChannel ( channel ) ; super . exceptionCaught ( chctx , t ) ; } @ Override public void channelInactive ( ChannelHandlerContext chctx ) throws Exception { client . removeChannel ( channel ) ; super . channelInactive ( chctx ) ; } @ Override public void channelRead ( ChannelHandlerContext chctx , Object msg ) throws Exception { if ( msg instanceof HttpContent ) { ReferenceCountUtil . release ( msg ) ; return ; } super . channelRead ( chctx , msg ) ; } } ) ; return socket ; } }
package io . vertx . test . core ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Vertx ; import io . vertx . core . VertxOptions ; import io . vertx . core . impl . ConcurrentHashSet ; import io . vertx . core . impl . Deployment ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . json . JsonObject ; import io . vertx . core . spi . cluster . ClusterManager ; import io . vertx . test . fakecluster . FakeClusterManager ; import org . junit . Test ; import java . util . ArrayList ; import java . util . List ; import java . util . Random ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . function . BooleanSupplier ; public class ComplexHATest extends VertxTestBase { protected ClusterManager getClusterManager ( ) { return new FakeClusterManager ( ) ; } private Random random = new Random ( ) ; protected final int maxVerticlesPerNode = 20 ; protected Set < Deployment > [ ] deploymentSnapshots ; protected volatile int totDeployed ; protected volatile int killedNode ; protected List < Integer > aliveNodes ; public void setUp ( ) throws Exception { super . setUp ( ) ; deploymentSnapshots = null ; totDeployed = 0 ; killedNode = 0 ; aliveNodes = null ; } @ Test @ Repeat ( times = 10 ) public void testComplexFailover ( ) { try { int numNodes = 8 ; createNodes ( numNodes ) ; deployRandomVerticles ( ( ) - > { killRandom ( ) ; } ) ; await ( 10 , TimeUnit . MINUTES ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; fail ( t . getMessage ( ) ) ; } } protected void deployRandomVerticles ( Runnable runner ) { int toDeploy = 0 ; AtomicInteger deployCount = new AtomicInteger ( ) ; List < Integer > numbersToDeploy = new ArrayList < > ( ) ; for ( int i = 0 ; i < aliveNodes . size ( ) ; i ++ ) { int numToDeploy = random . nextInt ( maxVerticlesPerNode + 1 ) ; numbersToDeploy . add ( numToDeploy ) ; toDeploy += numToDeploy ; } int index = 0 ; for ( int pos : aliveNodes ) { Vertx v = vertices [ pos ] ; int numToDeploy = numbersToDeploy . get ( index ) ; index ++ ; for ( int j = 0 ; j < numToDeploy ; j ++ ) { JsonObject config = new JsonObject ( ) ; config . put ( "foo" , TestUtils . randomAlphaString ( 100 ) ) ; DeploymentOptions options = new DeploymentOptions ( ) . setHa ( true ) . setConfig ( config ) ; String verticleName = "java:io.vertx.test.core.HAVerticle" + ( random . nextInt ( 3 ) + 1 ) ; v . deployVerticle ( verticleName , options , ar - > { assertTrue ( ar . succeeded ( ) ) ; deployCount . incrementAndGet ( ) ; } ) ; } } int ttoDeploy = toDeploy ; eventLoopWaitUntil ( ( ) - > ttoDeploy == deployCount . get ( ) , ( ) - > { totDeployed += ttoDeploy ; runner . run ( ) ; } ) ; } protected void undeployRandomVerticles ( Runnable runner ) { int toUndeploy = 0 ; AtomicInteger undeployCount = new AtomicInteger ( ) ; for ( int pos : aliveNodes ) { Vertx v = vertices [ pos ] ; int deployedNum = v . deploymentIDs ( ) . size ( ) ; int numToUnDeploy = random . nextInt ( deployedNum + 1 ) ; List < String > deployed = new ArrayList < > ( v . deploymentIDs ( ) ) ; int ii = pos ; for ( int j = 0 ; j < numToUnDeploy ; j ++ ) { int depPos = random . nextInt ( deployed . size ( ) ) ; String depID = deployed . remove ( depPos ) ; toUndeploy ++ ; v . undeploy ( depID , onSuccess ( d - > { undeployCount . incrementAndGet ( ) ; } ) ) ; } } int totUndeployed = toUndeploy ; eventLoopWaitUntil ( ( ) - > totUndeployed == undeployCount . get ( ) , ( ) - > { totDeployed -= totUndeployed ; runner . run ( ) ; } ) ; } private void eventLoopWaitUntil ( BooleanSupplier supplier , Runnable runner ) { long start = System . currentTimeMillis ( ) ; doEventLoopWaitUntil ( start , supplier , runner ) ; } private void doEventLoopWaitUntil ( long start , BooleanSupplier supplier , Runnable runner ) { long now = System . currentTimeMillis ( ) ; if ( now - start > 10000 ) { fail ( "Timedout in waiting until" ) ; } else { if ( supplier . getAsBoolean ( ) ) { runner . run ( ) ; } else { vertx . setTimer ( 1 , tid - > doEventLoopWaitUntil ( start , supplier , runner ) ) ; } } } protected void takeDeploymentSnapshots ( ) { for ( int i = 0 ; i < vertices . length ; i ++ ) { VertxInternal v = ( VertxInternal ) vertices [ i ] ; if ( ! v . isKilled ( ) ) { deploymentSnapshots [ i ] = takeDeploymentSnapshot ( i ) ; } } } protected Set < Deployment > takeDeploymentSnapshot ( int pos ) { Set < Deployment > snapshot = new ConcurrentHashSet < > ( ) ; VertxInternal v = ( VertxInternal ) vertices [ pos ] ; for ( String depID : v . deploymentIDs ( ) ) { snapshot . add ( v . getDeployment ( depID ) ) ; } return snapshot ; } protected void kill ( int pos ) { takeDeploymentSnapshots ( ) ; VertxInternal v = ( VertxInternal ) vertices [ pos ] ; killedNode = pos ; v . executeBlocking ( fut - > { v . simulateKill ( ) ; fut . complete ( ) ; } , ar - > { assertTrue ( ar . succeeded ( ) ) ; } ) ; } protected void createNodes ( int nodes ) { startNodes ( nodes , new VertxOptions ( ) . setHAEnabled ( true ) ) ; aliveNodes = new CopyOnWriteArrayList < > ( ) ; for ( int i = 0 ; i < nodes ; i ++ ) { aliveNodes . add ( i ) ; int pos = i ; ( ( VertxInternal ) vertices [ i ] ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { failedOverOnto ( pos ) ; } ) ; } deploymentSnapshots = new Set [ nodes ] ; } protected void failedOverOnto ( int node ) { checkDeployments ( ) ; checkHasDeployments ( node , killedNode ) ; if ( aliveNodes . size ( ) > 1 ) { undeployRandomVerticles ( ( ) - > { deployRandomVerticles ( ( ) - > { killRandom ( ) ; } ) ; } ) ; } else { testComplete ( ) ; } } protected void checkDeployments ( ) { int totalDeployed = 0 ; for ( int i = 0 ; i < vertices . length ; i ++ ) { VertxInternal v = ( VertxInternal ) vertices [ i ] ; if ( ! v . isKilled ( ) ) { totalDeployed += checkHasDeployments ( i , i ) ; } } assertEquals ( totDeployed , totalDeployed ) ; } protected int checkHasDeployments ( int pos , int prevPos ) { Set < Deployment > prevSet = deploymentSnapshots [ prevPos ] ; Set < Deployment > currSet = takeDeploymentSnapshot ( pos ) ; for ( Deployment prev : prevSet ) { boolean contains = false ; for ( Deployment curr : currSet ) { if ( curr . verticleIdentifier ( ) . equals ( prev . verticleIdentifier ( ) ) && curr . deploymentOptions ( ) . equals ( prev . deploymentOptions ( ) ) ) { contains = true ; break ; } } assertTrue ( contains ) ; } return currSet . size ( ) ; } protected void killRandom ( ) { int i = random . nextInt ( aliveNodes . size ( ) ) ; int pos = aliveNodes . get ( i ) ; aliveNodes . remove ( i ) ; kill ( pos ) ; } }
package io . vertx . core . http . impl ; import io . netty . buffer . ByteBuf ; import io . netty . handler . codec . DecoderResult ; import io . netty . handler . codec . http . DefaultHttpContent ; import io . netty . handler . codec . http . HttpContent ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . handler . codec . http . HttpVersion ; class AssembledHttpRequest implements HttpContent , HttpRequest { private final HttpRequest request ; protected final HttpContent content ; AssembledHttpRequest ( HttpRequest request , ByteBuf buf ) { this ( request , new DefaultHttpContent ( buf ) ) ; } AssembledHttpRequest ( HttpRequest request , HttpContent content ) { this . request = request ; this . content = content ; } @ Override public AssembledHttpRequest copy ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public AssembledHttpRequest duplicate ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public AssembledHttpRequest retain ( ) { content . retain ( ) ; return this ; } @ Override public AssembledHttpRequest retain ( int increment ) { content . retain ( increment ) ; return this ; } @ Override public HttpMethod getMethod ( ) { return request . getMethod ( ) ; } @ Override public String getUri ( ) { return request . getUri ( ) ; } @ Override public HttpHeaders headers ( ) { return request . headers ( ) ; } @ Override public HttpRequest setMethod ( HttpMethod method ) { return request . setMethod ( method ) ; } @ Override public HttpVersion getProtocolVersion ( ) { return request . getProtocolVersion ( ) ; } @ Override public HttpRequest setUri ( String uri ) { return request . setUri ( uri ) ; } @ Override public HttpRequest setProtocolVersion ( HttpVersion version ) { return request . setProtocolVersion ( version ) ; } @ Override public DecoderResult getDecoderResult ( ) { return request . getDecoderResult ( ) ; } @ Override public void setDecoderResult ( DecoderResult result ) { request . setDecoderResult ( result ) ; } @ Override public ByteBuf content ( ) { return content . content ( ) ; } @ Override public int refCnt ( ) { return content . refCnt ( ) ; } @ Override public boolean release ( ) { return content . release ( ) ; } @ Override public boolean release ( int decrement ) { return content . release ( decrement ) ; } }
package io . vertx . core . http . impl ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . WebSocketFrame ; import io . vertx . core . http . impl . ws . WebSocketFrameImpl ; import io . vertx . core . spi . WebSocketFrameFactory ; public class WebSocketFrameFactoryImpl implements WebSocketFrameFactory { @ Override public WebSocketFrame binaryFrame ( Buffer data , boolean isFinal ) { return new WebSocketFrameImpl ( FrameType . BINARY , data . getByteBuf ( ) , isFinal ) ; } @ Override public WebSocketFrame textFrame ( String str , boolean isFinal ) { return new WebSocketFrameImpl ( str , isFinal ) ; } @ Override public WebSocketFrame continuationFrame ( Buffer data , boolean isFinal ) { return new WebSocketFrameImpl ( FrameType . CONTINUATION , data . getByteBuf ( ) , isFinal ) ; } }
package io . vertx . core . http . impl ; import io . vertx . core . Handler ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import java . util . ArrayDeque ; import java . util . HashSet ; import java . util . Map ; import java . util . Queue ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; public abstract class ConnectionManager { private static final Logger log = LoggerFactory . getLogger ( ConnectionManager . class ) ; private final int maxSockets ; private final boolean keepAlive ; private final boolean pipelining ; private final Map < TargetAddress , ConnQueue > connQueues = new ConcurrentHashMap < > ( ) ; ConnectionManager ( int maxSockets , boolean keepAlive , boolean pipelining ) { this . maxSockets = maxSockets ; this . keepAlive = keepAlive ; this . pipelining = pipelining ; } public void getConnection ( int port , String host , Handler < ClientConnection > handler , Handler < Throwable > connectionExceptionHandler , ContextImpl context ) { if ( ! keepAlive && pipelining ) { connectionExceptionHandler . handle ( new IllegalStateException ( "Cannot have pipelining with no keep alive" ) ) ; } else { ConnectionManager . ConnQueue connQueue = connQueue ( port , host , handler , connectionExceptionHandler , context ) ; } } private ConnectionManager . ConnQueue connQueue ( int port , String host , Handler < ClientConnection > handler , Handler < Throwable > connectionExceptionHandler , ContextImpl context ) { TargetAddress address = new TargetAddress ( host , port ) ; ConnQueue connQueue = connQueues . get ( address ) ; if ( connQueue == null ) { connQueue = new ConnQueue ( address ) ; ConnQueue prev = connQueues . putIfAbsent ( address , connQueue ) ; if ( prev != null ) { connQueue = prev ; } } connQueue . getConnection ( handler , connectionExceptionHandler , context ) ; return connQueue ; } protected abstract void connect ( String host , int port , Handler < ClientConnection > connectHandler , Handler < Throwable > connectErrorHandler , ContextImpl context , ConnectionLifeCycleListener listener ) ; public void close ( ) { for ( ConnQueue queue : connQueues . values ( ) ) { queue . closeAllConnections ( ) ; } connQueues . clear ( ) ; } private class ConnQueue implements ConnectionLifeCycleListener { private final TargetAddress address ; private final Queue < Waiter > waiters = new ArrayDeque < > ( ) ; private final Set < ClientConnection > allConnections = new HashSet < > ( ) ; private int connCount ; ConnQueue ( TargetAddress address ) { this . address = address ; } public synchronized void getConnection ( Handler < ClientConnection > handler , Handler < Throwable > connectionExceptionHandler , ContextImpl context ) { if ( connCount == maxSockets ) { waiters . add ( new Waiter ( handler , connectionExceptionHandler , context ) ) ; } else { createNewConnection ( handler , connectionExceptionHandler , context ) ; } } public synchronized void requestEnded ( ClientConnection conn ) { if ( pipelining ) { Waiter waiter = waiters . poll ( ) ; if ( waiter != null ) { conn . getContext ( ) . executeFromIO ( ( ) - > waiter . handler . handle ( conn ) ) ; } } } public synchronized void responseEnded ( ClientConnection conn ) { if ( pipelining ) { if ( conn . getOutstandingRequestCount ( ) == 0 && waiters . isEmpty ( ) ) { conn . close ( ) ; } } else if ( keepAlive ) { checkReuseConnection ( conn ) ; } else { conn . close ( ) ; } } void closeAllConnections ( ) { Set < ClientConnection > copy ; synchronized ( this ) { copy = new HashSet < > ( allConnections ) ; allConnections . clear ( ) ; } for ( ClientConnection conn : copy ) { try { conn . close ( ) ; } catch ( Throwable t ) { log . error ( "Failed to close connection" , t ) ; } } } private void checkReuseConnection ( ClientConnection conn ) { Waiter waiter = waiters . poll ( ) ; if ( waiter != null ) { conn . getContext ( ) . executeFromIO ( ( ) - > waiter . handler . handle ( conn ) ) ; } else { conn . close ( ) ; } } private void createNewConnection ( Handler < ClientConnection > handler , Handler < Throwable > connectionExceptionHandler , ContextImpl context ) { connCount ++ ; } public synchronized void connectionClosed ( ClientConnection conn ) { connCount -- ; if ( conn != null ) { allConnections . remove ( conn ) ; } Waiter waiter = waiters . poll ( ) ; if ( waiter != null ) { createNewConnection ( waiter . handler , waiter . connectionExceptionHandler , waiter . context ) ; } else if ( connCount == 0 ) { connQueues . remove ( address ) ; } } } private static class TargetAddress { final String host ; final int port ; private TargetAddress ( String host , int port ) { this . host = host ; this . port = port ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TargetAddress that = ( TargetAddress ) o ; if ( port != that . port ) return false ; if ( host != null ? ! host . equals ( that . host ) : that . host != null ) return false ; return true ; } @ Override public int hashCode ( ) { int result = host != null ? host . hashCode ( ) : 0 ; result = 31 * result + port ; return result ; } } private static class Waiter { final Handler < ClientConnection > handler ; final Handler < Throwable > connectionExceptionHandler ; final ContextImpl context ; private Waiter ( Handler < ClientConnection > handler , Handler < Throwable > connectionExceptionHandler , ContextImpl context ) { this . handler = handler ; this . connectionExceptionHandler = connectionExceptionHandler ; this . context = context ; } } }
package io . vertx . core . http . impl ; import io . netty . bootstrap . Bootstrap ; import io . netty . channel . * ; import io . netty . handler . codec . http . * ; import io . netty . handler . ssl . SslHandler ; import io . netty . handler . timeout . IdleStateHandler ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . VertxException ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . * ; import io . vertx . core . http . HttpMethod ; import io . vertx . core . http . impl . ws . WebSocketFrameImpl ; import io . vertx . core . http . impl . ws . WebSocketFrameInternal ; import io . vertx . core . impl . Closeable ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . net . impl . KeyStoreHelper ; import io . vertx . core . net . impl . PartialPooledByteBufAllocator ; import io . vertx . core . net . impl . SSLHelper ; import io . vertx . core . spi . metrics . HttpClientMetrics ; import io . vertx . core . spi . metrics . Metrics ; import io . vertx . core . spi . metrics . MetricsProvider ; import javax . net . ssl . SSLHandshakeException ; import java . net . InetSocketAddress ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Map ; import java . util . Objects ; import java . util . concurrent . ConcurrentHashMap ; public class HttpClientImpl implements HttpClient , MetricsProvider { private static final Logger log = LoggerFactory . getLogger ( HttpClientImpl . class ) ; private final VertxInternal vertx ; private final HttpClientOptions options ; private final Map < Channel , ClientConnection > connectionMap = new ConcurrentHashMap < > ( ) ; private final ContextImpl creatingContext ; private final ConnectionManager pool ; private final Closeable closeHook ; private final SSLHelper sslHelper ; private final HttpClientMetrics metrics ; private volatile boolean closed ; public HttpClientImpl ( VertxInternal vertx , HttpClientOptions options ) { this . vertx = vertx ; this . options = new HttpClientOptions ( options ) ; this . sslHelper = new SSLHelper ( options , KeyStoreHelper . create ( vertx , options . getKeyCertOptions ( ) ) , KeyStoreHelper . create ( vertx , options . getTrustOptions ( ) ) ) ; this . creatingContext = vertx . getContext ( ) ; closeHook = null ; if ( creatingContext != null ) { if ( creatingContext . isMultiThreadedWorkerContext ( ) ) { throw new IllegalStateException ( "Cannot use HttpClient in a multi-threaded worker verticle" ) ; } creatingContext . addCloseHook ( closeHook ) ; } pool = new ConnectionManager ( options . getMaxPoolSize ( ) , options . isKeepAlive ( ) , options . isPipelining ( ) ) { protected void connect ( String host , int port , Handler < ClientConnection > connectHandler , Handler < Throwable > connectErrorHandler , ContextImpl context , ConnectionLifeCycleListener listener ) { internalConnect ( context , port , host , connectHandler , connectErrorHandler , listener ) ; } } ; this . metrics = vertx . metricsSPI ( ) . createMetrics ( this , options ) ; } @ Override public HttpClient websocket ( int port , String host , String requestURI , Handler < WebSocket > wsConnect ) { websocketStream ( port , host , requestURI , null , null ) . handler ( wsConnect ) ; return this ; } @ Override public HttpClient websocket ( String host , String requestURI , Handler < WebSocket > wsConnect ) { return websocket ( options . getDefaultPort ( ) , host , requestURI , wsConnect ) ; } @ Override public HttpClient websocket ( int port , String host , String requestURI , MultiMap headers , Handler < WebSocket > wsConnect ) { websocketStream ( port , host , requestURI , headers , null ) . handler ( wsConnect ) ; return this ; } @ Override public HttpClient websocket ( String host , String requestURI , MultiMap headers , Handler < WebSocket > wsConnect ) { return websocket ( options . getDefaultPort ( ) , host , requestURI , headers , wsConnect ) ; } @ Override public HttpClient websocket ( int port , String host , String requestURI , MultiMap headers , WebsocketVersion version , Handler < WebSocket > wsConnect ) { websocketStream ( port , host , requestURI , headers , version , null ) . handler ( wsConnect ) ; return this ; } @ Override public HttpClient websocket ( String host , String requestURI , MultiMap headers , WebsocketVersion version , Handler < WebSocket > wsConnect ) { return websocket ( options . getDefaultPort ( ) , host , requestURI , headers , version , wsConnect ) ; } @ Override public HttpClient websocket ( int port , String host , String requestURI , MultiMap headers , WebsocketVersion version , String subProtocols , Handler < WebSocket > wsConnect ) { websocketStream ( port , host , requestURI , headers , version , subProtocols ) . handler ( wsConnect ) ; return this ; } @ Override public HttpClient websocket ( String host , String requestURI , MultiMap headers , WebsocketVersion version , String subProtocols , Handler < WebSocket > wsConnect ) { return websocket ( options . getDefaultPort ( ) , host , requestURI , headers , version , subProtocols , wsConnect ) ; } @ Override public HttpClient websocket ( String requestURI , Handler < WebSocket > wsConnect ) { return websocket ( options . getDefaultPort ( ) , options . getDefaultHost ( ) , requestURI , wsConnect ) ; } @ Override public HttpClient websocket ( String requestURI , MultiMap headers , Handler < WebSocket > wsConnect ) { return websocket ( options . getDefaultPort ( ) , options . getDefaultHost ( ) , requestURI , headers , wsConnect ) ; } @ Override public HttpClient websocket ( String requestURI , MultiMap headers , WebsocketVersion version , Handler < WebSocket > wsConnect ) { return websocket ( options . getDefaultPort ( ) , options . getDefaultHost ( ) , requestURI , headers , version , wsConnect ) ; } @ Override public HttpClient websocket ( String requestURI , MultiMap headers , WebsocketVersion version , String subProtocols , Handler < WebSocket > wsConnect ) { return websocket ( options . getDefaultPort ( ) , options . getDefaultHost ( ) , requestURI , headers , version , subProtocols , wsConnect ) ; } @ Override public WebSocketStream websocketStream ( int port , String host , String requestURI ) { return websocketStream ( port , host , requestURI , null , null ) ; } @ Override public WebSocketStream websocketStream ( String host , String requestURI ) { return websocketStream ( options . getDefaultPort ( ) , host , requestURI ) ; } @ Override public WebSocketStream websocketStream ( int port , String host , String requestURI , MultiMap headers ) { return websocketStream ( port , host , requestURI , headers , null ) ; } @ Override public WebSocketStream websocketStream ( String host , String requestURI , MultiMap headers ) { return websocketStream ( options . getDefaultPort ( ) , host , requestURI , headers ) ; } @ Override public WebSocketStream websocketStream ( int port , String host , String requestURI , MultiMap headers , WebsocketVersion version ) { return websocketStream ( port , host , requestURI , headers , version , null ) ; } @ Override public WebSocketStream websocketStream ( String host , String requestURI , MultiMap headers , WebsocketVersion version ) { return websocketStream ( options . getDefaultPort ( ) , host , requestURI , headers , version ) ; } @ Override public WebSocketStream websocketStream ( int port , String host , String requestURI , MultiMap headers , WebsocketVersion version , String subProtocols ) { return new WebSocketStreamImpl ( port , host , requestURI , headers , version , subProtocols ) ; } @ Override public WebSocketStream websocketStream ( String host , String requestURI , MultiMap headers , WebsocketVersion version , String subProtocols ) { return websocketStream ( options . getDefaultPort ( ) , host , requestURI , headers , version , subProtocols ) ; } @ Override public WebSocketStream websocketStream ( String requestURI ) { return websocketStream ( options . getDefaultPort ( ) , options . getDefaultHost ( ) , requestURI ) ; } @ Override public WebSocketStream websocketStream ( String requestURI , MultiMap headers ) { return websocketStream ( options . getDefaultPort ( ) , options . getDefaultHost ( ) , requestURI , headers ) ; } @ Override public WebSocketStream websocketStream ( String requestURI , MultiMap headers , WebsocketVersion version ) { return websocketStream ( options . getDefaultPort ( ) , options . getDefaultHost ( ) , requestURI , headers , version ) ; } @ Override public WebSocketStream websocketStream ( String requestURI , MultiMap headers , WebsocketVersion version , String subProtocols ) { return websocketStream ( options . getDefaultPort ( ) , options . getDefaultHost ( ) , requestURI , headers , version , subProtocols ) ; } @ Override public HttpClientRequest requestAbs ( HttpMethod method , String absoluteURI , Handler < HttpClientResponse > responseHandler ) { Objects . requireNonNull ( responseHandler , "no null responseHandler accepted" ) ; return requestAbs ( method , absoluteURI ) . handler ( responseHandler ) ; } @ Override public HttpClientRequest request ( HttpMethod method , int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { Objects . requireNonNull ( responseHandler , "no null responseHandler accepted" ) ; return request ( method , port , host , requestURI ) . handler ( responseHandler ) ; } @ Override public HttpClientRequest request ( HttpMethod method , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( method , options . getDefaultPort ( ) , host , requestURI , responseHandler ) ; } @ Override public HttpClientRequest request ( HttpMethod method , String requestURI ) { return request ( method , options . getDefaultPort ( ) , options . getDefaultHost ( ) , requestURI ) ; } @ Override public HttpClientRequest request ( HttpMethod method , String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( method , options . getDefaultPort ( ) , options . getDefaultHost ( ) , requestURI , responseHandler ) ; } @ Override public HttpClientRequest requestAbs ( HttpMethod method , String absoluteURI ) { URL url = parseUrl ( absoluteURI ) ; return doRequest ( method , url . getHost ( ) , url . getPort ( ) , url . getFile ( ) , null ) ; } @ Override public HttpClientRequest request ( HttpMethod method , int port , String host , String requestURI ) { return doRequest ( method , host , port , requestURI , null ) ; } @ Override public HttpClientRequest request ( HttpMethod method , String host , String requestURI ) { return request ( method , options . getDefaultPort ( ) , host , requestURI ) ; } @ Override public HttpClientRequest get ( int port , String host , String requestURI ) { return request ( HttpMethod . GET , port , host , requestURI ) ; } @ Override public HttpClientRequest get ( String host , String requestURI ) { return get ( options . getDefaultPort ( ) , host , requestURI ) ; } @ Override public HttpClientRequest get ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( HttpMethod . GET , port , host , requestURI , responseHandler ) ; } @ Override public HttpClientRequest get ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return get ( options . getDefaultPort ( ) , host , requestURI , responseHandler ) ; } @ Override public HttpClientRequest get ( String requestURI ) { return request ( HttpMethod . GET , requestURI ) ; } @ Override public HttpClientRequest get ( String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( HttpMethod . GET , requestURI , responseHandler ) ; } @ Override public HttpClientRequest getAbs ( String absoluteURI ) { return requestAbs ( HttpMethod . GET , absoluteURI ) ; } @ Override public HttpClientRequest getAbs ( String absoluteURI , Handler < HttpClientResponse > responseHandler ) { return requestAbs ( HttpMethod . GET , absoluteURI , responseHandler ) ; } @ Override public HttpClient getNow ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { get ( port , host , requestURI , responseHandler ) . end ( ) ; return this ; } @ Override public HttpClient getNow ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return getNow ( options . getDefaultPort ( ) , host , requestURI , responseHandler ) ; } @ Override public HttpClient getNow ( String requestURI , Handler < HttpClientResponse > responseHandler ) { get ( requestURI , responseHandler ) . end ( ) ; return this ; } @ Override public HttpClientRequest post ( int port , String host , String requestURI ) { return request ( HttpMethod . POST , port , host , requestURI ) ; } @ Override public HttpClientRequest post ( String host , String requestURI ) { return post ( options . getDefaultPort ( ) , host , requestURI ) ; } @ Override public HttpClientRequest post ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( HttpMethod . POST , port , host , requestURI , responseHandler ) ; } @ Override public HttpClientRequest post ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return post ( options . getDefaultPort ( ) , host , requestURI , responseHandler ) ; } @ Override public HttpClientRequest post ( String requestURI ) { return request ( HttpMethod . POST , requestURI ) ; } @ Override public HttpClientRequest post ( String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( HttpMethod . POST , requestURI , responseHandler ) ; } @ Override public HttpClientRequest postAbs ( String absoluteURI ) { return requestAbs ( HttpMethod . POST , absoluteURI ) ; } @ Override public HttpClientRequest postAbs ( String absoluteURI , Handler < HttpClientResponse > responseHandler ) { return requestAbs ( HttpMethod . POST , absoluteURI , responseHandler ) ; } @ Override public HttpClientRequest head ( int port , String host , String requestURI ) { return request ( HttpMethod . HEAD , port , host , requestURI ) ; } @ Override public HttpClientRequest head ( String host , String requestURI ) { return head ( options . getDefaultPort ( ) , host , requestURI ) ; } @ Override public HttpClientRequest head ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( HttpMethod . HEAD , port , host , requestURI , responseHandler ) ; } @ Override public HttpClientRequest head ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return head ( options . getDefaultPort ( ) , host , requestURI , responseHandler ) ; } @ Override public HttpClientRequest head ( String requestURI ) { return request ( HttpMethod . HEAD , requestURI ) ; } @ Override public HttpClientRequest head ( String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( HttpMethod . HEAD , requestURI , responseHandler ) ; } @ Override public HttpClientRequest headAbs ( String absoluteURI ) { return requestAbs ( HttpMethod . HEAD , absoluteURI ) ; } @ Override public HttpClientRequest headAbs ( String absoluteURI , Handler < HttpClientResponse > responseHandler ) { return requestAbs ( HttpMethod . HEAD , absoluteURI , responseHandler ) ; } @ Override public HttpClient headNow ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { head ( port , host , requestURI , responseHandler ) . end ( ) ; return this ; } @ Override public HttpClient headNow ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return headNow ( options . getDefaultPort ( ) , host , requestURI , responseHandler ) ; } @ Override public HttpClient headNow ( String requestURI , Handler < HttpClientResponse > responseHandler ) { head ( requestURI , responseHandler ) . end ( ) ; return this ; } @ Override public HttpClientRequest options ( int port , String host , String requestURI ) { return request ( HttpMethod . OPTIONS , port , host , requestURI ) ; } @ Override public HttpClientRequest options ( String host , String requestURI ) { return options ( options . getDefaultPort ( ) , host , requestURI ) ; } @ Override public HttpClientRequest options ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( HttpMethod . OPTIONS , port , host , requestURI , responseHandler ) ; } @ Override public HttpClientRequest options ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return options ( options . getDefaultPort ( ) , host , requestURI , responseHandler ) ; } @ Override public HttpClientRequest options ( String requestURI ) { return request ( HttpMethod . OPTIONS , requestURI ) ; } @ Override public HttpClientRequest options ( String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( HttpMethod . OPTIONS , requestURI , responseHandler ) ; } @ Override public HttpClientRequest optionsAbs ( String absoluteURI ) { return requestAbs ( HttpMethod . OPTIONS , absoluteURI ) ; } @ Override public HttpClientRequest optionsAbs ( String absoluteURI , Handler < HttpClientResponse > responseHandler ) { return requestAbs ( HttpMethod . OPTIONS , absoluteURI , responseHandler ) ; } @ Override public HttpClient optionsNow ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { options ( port , host , requestURI , responseHandler ) . end ( ) ; return this ; } @ Override public HttpClient optionsNow ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return optionsNow ( options . getDefaultPort ( ) , host , requestURI , responseHandler ) ; } @ Override public HttpClient optionsNow ( String requestURI , Handler < HttpClientResponse > responseHandler ) { options ( requestURI , responseHandler ) . end ( ) ; return this ; } @ Override public HttpClientRequest put ( int port , String host , String requestURI ) { return request ( HttpMethod . PUT , port , host , requestURI ) ; } @ Override public HttpClientRequest put ( String host , String requestURI ) { return put ( options . getDefaultPort ( ) , host , requestURI ) ; } @ Override public HttpClientRequest put ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( HttpMethod . PUT , port , host , requestURI , responseHandler ) ; } @ Override public HttpClientRequest put ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return put ( options . getDefaultPort ( ) , host , requestURI , responseHandler ) ; } @ Override public HttpClientRequest put ( String requestURI ) { return request ( HttpMethod . PUT , requestURI ) ; } @ Override public HttpClientRequest put ( String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( HttpMethod . PUT , requestURI , responseHandler ) ; } @ Override public HttpClientRequest putAbs ( String absoluteURI ) { return requestAbs ( HttpMethod . PUT , absoluteURI ) ; } @ Override public HttpClientRequest putAbs ( String absoluteURI , Handler < HttpClientResponse > responseHandler ) { return requestAbs ( HttpMethod . PUT , absoluteURI , responseHandler ) ; } @ Override public HttpClientRequest delete ( int port , String host , String requestURI ) { return request ( HttpMethod . DELETE , port , host , requestURI ) ; } @ Override public HttpClientRequest delete ( String host , String requestURI ) { return delete ( options . getDefaultPort ( ) , host , requestURI ) ; } @ Override public HttpClientRequest delete ( int port , String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( HttpMethod . DELETE , port , host , requestURI , responseHandler ) ; } @ Override public HttpClientRequest delete ( String host , String requestURI , Handler < HttpClientResponse > responseHandler ) { return delete ( options . getDefaultPort ( ) , host , requestURI , responseHandler ) ; } @ Override public HttpClientRequest delete ( String requestURI ) { return request ( HttpMethod . DELETE , requestURI ) ; } @ Override public HttpClientRequest delete ( String requestURI , Handler < HttpClientResponse > responseHandler ) { return request ( HttpMethod . DELETE , requestURI , responseHandler ) ; } @ Override public HttpClientRequest deleteAbs ( String absoluteURI ) { return requestAbs ( HttpMethod . DELETE , absoluteURI ) ; } @ Override public HttpClientRequest deleteAbs ( String absoluteURI , Handler < HttpClientResponse > responseHandler ) { return requestAbs ( HttpMethod . DELETE , absoluteURI , responseHandler ) ; } @ Override public synchronized void close ( ) { checkClosed ( ) ; pool . close ( ) ; for ( ClientConnection conn : connectionMap . values ( ) ) { conn . close ( ) ; } if ( creatingContext != null ) { creatingContext . removeCloseHook ( closeHook ) ; } closed = true ; metrics . close ( ) ; } @ Override public boolean isMetricsEnabled ( ) { return metrics != null && metrics . isEnabled ( ) ; } @ Override public Metrics getMetrics ( ) { return metrics ; } HttpClientOptions getOptions ( ) { return options ; } void getConnection ( int port , String host , Handler < ClientConnection > handler , Handler < Throwable > connectionExceptionHandler , ContextImpl context ) { pool . getConnection ( port , host , handler , connectionExceptionHandler , context ) ; } VertxInternal getVertx ( ) { return vertx ; } SSLHelper getSslHelper ( ) { return sslHelper ; } void removeChannel ( Channel channel ) { connectionMap . remove ( channel ) ; } HttpClientMetrics httpClientMetrics ( ) { return metrics ; } private void applyConnectionOptions ( Bootstrap bootstrap ) { bootstrap . option ( ChannelOption . TCP_NODELAY , options . isTcpNoDelay ( ) ) ; if ( options . getSendBufferSize ( ) != - 1 ) { bootstrap . option ( ChannelOption . SO_SNDBUF , options . getSendBufferSize ( ) ) ; } if ( options . getReceiveBufferSize ( ) != - 1 ) { bootstrap . option ( ChannelOption . SO_RCVBUF , options . getReceiveBufferSize ( ) ) ; bootstrap . option ( ChannelOption . RCVBUF_ALLOCATOR , new FixedRecvByteBufAllocator ( options . getReceiveBufferSize ( ) ) ) ; } bootstrap . option ( ChannelOption . SO_LINGER , options . getSoLinger ( ) ) ; if ( options . getTrafficClass ( ) != - 1 ) { bootstrap . option ( ChannelOption . IP_TOS , options . getTrafficClass ( ) ) ; } bootstrap . option ( ChannelOption . CONNECT_TIMEOUT_MILLIS , options . getConnectTimeout ( ) ) ; bootstrap . option ( ChannelOption . ALLOCATOR , PartialPooledByteBufAllocator . INSTANCE ) ; bootstrap . option ( ChannelOption . SO_KEEPALIVE , options . isTcpKeepAlive ( ) ) ; bootstrap . option ( ChannelOption . SO_REUSEADDR , options . isReuseAddress ( ) ) ; } private void internalConnect ( ContextImpl context , int port , String host , Handler < ClientConnection > connectHandler , Handler < Throwable > connectErrorHandler , ConnectionLifeCycleListener listener ) { Bootstrap bootstrap = new Bootstrap ( ) ; bootstrap . group ( context . eventLoop ( ) ) ; bootstrap . channelFactory ( new VertxNioSocketChannelFactory ( ) ) ; sslHelper . validate ( vertx ) ; bootstrap . handler ( new ChannelInitializer < Channel > ( ) { @ Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline pipeline = ch . pipeline ( ) ; if ( options . isSsl ( ) ) { pipeline . addLast ( "ssl" , sslHelper . createSslHandler ( vertx , true , host , port ) ) ; } pipeline . addLast ( "codec" , new HttpClientCodec ( 4096 , 8192 , 8192 , false , false ) ) ; if ( options . isTryUseCompression ( ) ) { pipeline . addLast ( "inflater" , new HttpContentDecompressor ( true ) ) ; } if ( options . getIdleTimeout ( ) > 0 ) { pipeline . addLast ( "idle" , new IdleStateHandler ( 0 , 0 , options . getIdleTimeout ( ) ) ) ; } pipeline . addLast ( "handler" , new ClientHandler ( vertx , context ) ) ; } } ) ; applyConnectionOptions ( bootstrap ) ; ChannelFuture future = bootstrap . connect ( new InetSocketAddress ( host , port ) ) ; future . addListener ( ( ChannelFuture channelFuture ) - > { Channel ch = channelFuture . channel ( ) ; if ( channelFuture . isSuccess ( ) ) { if ( options . isSsl ( ) ) { SslHandler sslHandler = ch . pipeline ( ) . get ( SslHandler . class ) ; io . netty . util . concurrent . Future < Channel > fut = sslHandler . handshakeFuture ( ) ; fut . addListener ( fut2 - > { if ( fut2 . isSuccess ( ) ) { connected ( context , port , host , ch , connectHandler , connectErrorHandler , listener ) ; } else { connectionFailed ( context , ch , connectErrorHandler , new SSLHandshakeException ( "Failed to create SSL connection" ) , listener ) ; } } ) ; } else { connected ( context , port , host , ch , connectHandler , connectErrorHandler , listener ) ; } } else { connectionFailed ( context , ch , connectErrorHandler , channelFuture . cause ( ) , listener ) ; } } ) ; } private URL parseUrl ( String surl ) { try { return new URL ( surl ) ; } catch ( MalformedURLException e ) { throw new VertxException ( "Invalid url: " + surl ) ; } } private HttpClientRequest doRequest ( HttpMethod method , String host , int port , String relativeURI , MultiMap headers ) { Objects . requireNonNull ( method , "no null method accepted" ) ; Objects . requireNonNull ( host , "no null host accepted" ) ; Objects . requireNonNull ( relativeURI , "no null relativeURI accepted" ) ; checkClosed ( ) ; HttpClientRequest req = new HttpClientRequestImpl ( this , method , host , port , relativeURI , vertx ) ; if ( headers != null ) { req . headers ( ) . setAll ( headers ) ; } return req ; } private synchronized void checkClosed ( ) { if ( closed ) { throw new IllegalStateException ( "Client is closed" ) ; } } private void connected ( ContextImpl context , int port , String host , Channel ch , Handler < ClientConnection > connectHandler , Handler < Throwable > exceptionHandler , ConnectionLifeCycleListener listener ) { context . executeFromIO ( ( ) - > createConn ( context , port , host , ch , connectHandler , exceptionHandler , listener ) ) ; } private void createConn ( ContextImpl context , int port , String host , Channel ch , Handler < ClientConnection > connectHandler , Handler < Throwable > exceptionHandler , ConnectionLifeCycleListener listener ) { ClientConnection conn = new ClientConnection ( vertx , HttpClientImpl . this , exceptionHandler , ch , options . isSsl ( ) , host , port , context , listener , metrics ) ; connectionMap . put ( ch , conn ) ; connectHandler . handle ( conn ) ; } private void connectionFailed ( ContextImpl context , Channel ch , Handler < Throwable > connectionExceptionHandler , Throwable t , ConnectionLifeCycleListener listener ) { context . executeFromIO ( ( ) - > { listener . connectionClosed ( null ) ; try { ch . close ( ) ; } catch ( Exception ignore ) { } } ) ; } private class ClientHandler extends VertxHttpHandler < ClientConnection > { private boolean closeFrameSent ; private ContextImpl context ; public ClientHandler ( VertxInternal vertx , ContextImpl context ) { super ( HttpClientImpl . this . connectionMap ) ; this . context = context ; } @ Override protected ContextImpl getContext ( ClientConnection connection ) { return context ; } @ Override protected void doMessageReceived ( ClientConnection conn , ChannelHandlerContext ctx , Object msg ) { if ( conn == null ) { return ; } boolean valid = false ; if ( msg instanceof HttpResponse ) { HttpResponse response = ( HttpResponse ) msg ; conn . handleResponse ( response ) ; valid = true ; } if ( msg instanceof HttpContent ) { HttpContent chunk = ( HttpContent ) msg ; if ( chunk . content ( ) . isReadable ( ) ) { Buffer buff = Buffer . buffer ( chunk . content ( ) . slice ( ) ) ; conn . handleResponseChunk ( buff ) ; } if ( chunk instanceof LastHttpContent ) { conn . handleResponseEnd ( ( LastHttpContent ) chunk ) ; } valid = true ; } else if ( msg instanceof WebSocketFrameInternal ) { WebSocketFrameInternal frame = ( WebSocketFrameInternal ) msg ; switch ( frame . type ( ) ) { case BINARY : case CONTINUATION : case TEXT : conn . handleWsFrame ( frame ) ; break ; case PING : ctx . writeAndFlush ( new WebSocketFrameImpl ( FrameType . PONG , frame . getBinaryData ( ) ) ) ; break ; case PONG : break ; case CLOSE : if ( ! closeFrameSent ) { ctx . writeAndFlush ( frame ) . addListener ( ChannelFutureListener . CLOSE ) ; closeFrameSent = true ; } break ; default : throw new IllegalStateException ( "Invalid type: " + frame . type ( ) ) ; } valid = true ; } if ( ! valid ) { throw new IllegalStateException ( "Invalid object " + msg ) ; } } } private class WebSocketStreamImpl implements WebSocketStream { final int port ; final String host ; final String requestURI ; final MultiMap headers ; final WebsocketVersion version ; final String subProtocols ; private Handler < WebSocket > handler ; private Handler < Throwable > exceptionHandler ; private Handler < Void > endHandler ; public WebSocketStreamImpl ( int port , String host , String requestURI , MultiMap headers , WebsocketVersion version , String subProtocols ) { this . port = port ; this . host = host ; this . requestURI = requestURI ; this . headers = headers ; this . version = version ; this . subProtocols = subProtocols ; } @ Override public synchronized WebSocketStream exceptionHandler ( Handler < Throwable > handler ) { exceptionHandler = handler ; return this ; } @ Override public synchronized WebSocketStream handler ( Handler < WebSocket > handler ) { if ( this . handler == null && handler != null ) { this . handler = handler ; checkClosed ( ) ; ContextImpl context = vertx . getOrCreateContext ( ) ; Handler < Throwable > connectionExceptionHandler = exceptionHandler ; if ( connectionExceptionHandler == null ) { connectionExceptionHandler = null ; } Handler < WebSocket > wsConnect ; if ( endHandler != null ) { Handler < Void > endCallback = endHandler ; } else { wsConnect = handler ; } } return this ; } @ Override public synchronized WebSocketStream endHandler ( Handler < Void > endHandler ) { this . endHandler = endHandler ; return this ; } @ Override public WebSocketStream pause ( ) { return this ; } @ Override public WebSocketStream resume ( ) { return this ; } } @ Override protected void finalize ( ) throws Throwable { close ( ) ; super . finalize ( ) ; } }
package io . vertx . core . http . impl ; import io . vertx . core . Handler ; import io . vertx . core . Vertx ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . file . AsyncFile ; import io . vertx . core . file . OpenOptions ; import io . vertx . core . http . HttpServerFileUpload ; import io . vertx . core . streams . Pump ; import java . nio . charset . Charset ; class HttpServerFileUploadImpl implements HttpServerFileUpload { private final HttpServerRequestImpl req ; private final Vertx vertx ; private final String name ; private final String filename ; private final String contentType ; private final String contentTransferEncoding ; private final Charset charset ; private Handler < Buffer > dataHandler ; private Handler < Void > endHandler ; private AsyncFile file ; private Handler < Throwable > exceptionHandler ; private long size ; private boolean paused ; private Buffer pauseBuff ; private boolean complete ; private boolean lazyCalculateSize ; HttpServerFileUploadImpl ( Vertx vertx , HttpServerRequestImpl req , String name , String filename , String contentType , String contentTransferEncoding , Charset charset , long size ) { this . vertx = vertx ; this . req = req ; this . name = name ; this . filename = filename ; this . contentType = contentType ; this . contentTransferEncoding = contentTransferEncoding ; this . charset = charset ; this . size = size ; if ( size == 0 ) { lazyCalculateSize = true ; } } @ Override public String filename ( ) { return filename ; } @ Override public String name ( ) { return name ; } @ Override public String contentType ( ) { return contentType ; } @ Override public String contentTransferEncoding ( ) { return contentTransferEncoding ; } @ Override public String charset ( ) { return charset . toString ( ) ; } @ Override public synchronized long size ( ) { return size ; } @ Override public synchronized HttpServerFileUpload handler ( Handler < Buffer > handler ) { this . dataHandler = handler ; return this ; } @ Override public synchronized HttpServerFileUpload pause ( ) { req . pause ( ) ; paused = true ; return this ; } @ Override public synchronized HttpServerFileUpload resume ( ) { if ( paused ) { req . resume ( ) ; paused = false ; if ( pauseBuff != null ) { doReceiveData ( pauseBuff ) ; pauseBuff = null ; } if ( complete ) { handleComplete ( ) ; } } return this ; } @ Override public synchronized HttpServerFileUpload exceptionHandler ( Handler < Throwable > exceptionHandler ) { this . exceptionHandler = exceptionHandler ; return this ; } @ Override public synchronized HttpServerFileUpload endHandler ( Handler < Void > handler ) { this . endHandler = handler ; return this ; } @ Override public HttpServerFileUpload streamToFileSystem ( String filename ) { pause ( ) ; vertx . fileSystem ( ) . open ( filename , new OpenOptions ( ) , ar - > { if ( ar . succeeded ( ) ) { file = ar . result ( ) ; Pump p = Pump . pump ( HttpServerFileUploadImpl . this , ar . result ( ) ) ; p . start ( ) ; resume ( ) ; } else { notifyExceptionHandler ( ar . cause ( ) ) ; } } ) ; return this ; } @ Override public synchronized boolean isSizeAvailable ( ) { return ! lazyCalculateSize ; } synchronized void receiveData ( Buffer data ) { if ( data . length ( ) != 0 ) { if ( lazyCalculateSize ) { size += data . length ( ) ; } doReceiveData ( data ) ; } } synchronized void doReceiveData ( Buffer data ) { if ( ! paused ) { if ( dataHandler != null ) { dataHandler . handle ( data ) ; } } else { if ( pauseBuff == null ) { pauseBuff = Buffer . buffer ( ) ; } pauseBuff . appendBuffer ( data ) ; } } synchronized void complete ( ) { if ( paused ) { complete = true ; } else { handleComplete ( ) ; } } private void handleComplete ( ) { lazyCalculateSize = false ; if ( file == null ) { notifyEndHandler ( ) ; } else { file . close ( ar - > { if ( ar . failed ( ) ) { notifyExceptionHandler ( ar . cause ( ) ) ; } notifyEndHandler ( ) ; } ) ; } } private void notifyEndHandler ( ) { if ( endHandler != null ) { endHandler . handle ( null ) ; } } private void notifyExceptionHandler ( Throwable cause ) { if ( exceptionHandler != null ) { exceptionHandler . handle ( cause ) ; } } }
package io . vertx . core . http . impl ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . * ; import io . netty . channel . group . ChannelGroup ; import io . netty . channel . group . ChannelGroupFuture ; import io . netty . channel . group . DefaultChannelGroup ; import io . netty . handler . codec . http . * ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . websocketx . WebSocketHandshakeException ; import io . netty . handler . codec . http . websocketx . WebSocketServerHandshaker ; import io . netty . handler . codec . http . websocketx . WebSocketServerHandshakerFactory ; import io . netty . handler . codec . http . websocketx . WebSocketVersion ; import io . netty . handler . ssl . SslHandler ; import io . netty . handler . stream . ChunkedWriteHandler ; import io . netty . handler . timeout . IdleStateHandler ; import io . netty . util . CharsetUtil ; import io . netty . util . concurrent . GlobalEventExecutor ; import io . vertx . core . * ; import io . vertx . core . http . * ; import io . vertx . core . http . impl . cgbystrom . FlashPolicyHandler ; import io . vertx . core . http . impl . ws . WebSocketFrameImpl ; import io . vertx . core . http . impl . ws . WebSocketFrameInternal ; import io . vertx . core . impl . Closeable ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . net . impl . * ; import io . vertx . core . spi . metrics . HttpServerMetrics ; import io . vertx . core . spi . metrics . Metrics ; import io . vertx . core . spi . metrics . MetricsProvider ; import io . vertx . core . streams . ReadStream ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import static io . netty . handler . codec . http . HttpResponseStatus . * ; import static io . netty . handler . codec . http . HttpVersion . HTTP_1_1 ; public class HttpServerImpl implements HttpServer , Closeable , MetricsProvider { private static final Logger log = LoggerFactory . getLogger ( HttpServerImpl . class ) ; private static final String FLASH_POLICY_HANDLER_PROP_NAME = "vertx.flashPolicyHandler" ; private static final boolean USE_FLASH_POLICY_HANDLER = Boolean . getBoolean ( FLASH_POLICY_HANDLER_PROP_NAME ) ; private static final String DISABLE_WEBSOCKETS_PROP_NAME = "vertx.disableWebsockets" ; private static final boolean DISABLE_WEBSOCKETS = Boolean . getBoolean ( DISABLE_WEBSOCKETS_PROP_NAME ) ; private final HttpServerOptions options ; private final VertxInternal vertx ; private final SSLHelper sslHelper ; private final ContextImpl creatingContext ; private final Map < Channel , ServerConnection > connectionMap = new ConcurrentHashMap < > ( ) ; private final VertxEventLoopGroup availableWorkers = new VertxEventLoopGroup ( ) ; private final HandlerManager < HttpServerRequest > reqHandlerManager = new HandlerManager < > ( availableWorkers ) ; private final HandlerManager < ServerWebSocket > wsHandlerManager = new HandlerManager < > ( availableWorkers ) ; private final ServerWebSocketStreamImpl wsStream = new ServerWebSocketStreamImpl ( ) ; private final HttpServerRequestStreamImpl requestStream = new HttpServerRequestStreamImpl ( ) ; private final String subProtocols ; private String serverOrigin ; private ChannelGroup serverChannelGroup ; private volatile boolean listening ; private ChannelFuture bindFuture ; private ServerID id ; private HttpServerImpl actualServer ; private ContextImpl listenContext ; private HttpServerMetrics metrics ; public HttpServerImpl ( VertxInternal vertx , HttpServerOptions options ) { this . options = new HttpServerOptions ( options ) ; this . vertx = vertx ; this . creatingContext = vertx . getContext ( ) ; if ( creatingContext != null ) { if ( creatingContext . isMultiThreadedWorkerContext ( ) ) { throw new IllegalStateException ( "Cannot use HttpServer in a multi-threaded worker verticle" ) ; } creatingContext . addCloseHook ( this ) ; } this . sslHelper = new SSLHelper ( options , KeyStoreHelper . create ( vertx , options . getKeyCertOptions ( ) ) , KeyStoreHelper . create ( vertx , options . getTrustOptions ( ) ) ) ; this . subProtocols = options . getWebsocketSubProtocols ( ) ; } @ Override public synchronized HttpServer requestHandler ( Handler < HttpServerRequest > handler ) { requestStream . handler ( handler ) ; return this ; } @ Override public HttpServerRequestStream requestStream ( ) { return requestStream ; } @ Override public HttpServer websocketHandler ( Handler < ServerWebSocket > handler ) { websocketStream ( ) . handler ( handler ) ; return this ; } @ Override public Handler < HttpServerRequest > requestHandler ( ) { return requestStream . handler ( ) ; } @ Override public Handler < ServerWebSocket > websocketHandler ( ) { return wsStream . handler ( ) ; } @ Override public ServerWebSocketStream websocketStream ( ) { return wsStream ; } @ Override public HttpServer listen ( ) { return listen ( options . getPort ( ) , options . getHost ( ) , null ) ; } @ Override public HttpServer listen ( Handler < AsyncResult < HttpServer > > listenHandler ) { return listen ( options . getPort ( ) , options . getHost ( ) , listenHandler ) ; } @ Override public HttpServer listen ( int port , String host ) { return listen ( port , host , null ) ; } @ Override public HttpServer listen ( int port ) { return listen ( port , "0.0.0.0" , null ) ; } @ Override public HttpServer listen ( int port , Handler < AsyncResult < HttpServer > > listenHandler ) { return listen ( port , "0.0.0.0" , listenHandler ) ; } public synchronized HttpServer listen ( int port , String host , Handler < AsyncResult < HttpServer > > listenHandler ) { if ( requestStream . handler ( ) == null && wsStream . handler ( ) == null ) { throw new IllegalStateException ( "Set request or websocket handler first" ) ; } if ( listening ) { throw new IllegalStateException ( "Already listening" ) ; } listenContext = vertx . getOrCreateContext ( ) ; listening = true ; serverOrigin = ( options . isSsl ( ) ? "https" : "http" ) + "://" + host + ":" + port ; synchronized ( vertx . sharedHttpServers ( ) ) { id = new ServerID ( port , host ) ; HttpServerImpl shared = vertx . sharedHttpServers ( ) . get ( id ) ; if ( shared == null ) { serverChannelGroup = new DefaultChannelGroup ( "vertx-acceptor-channels" , GlobalEventExecutor . INSTANCE ) ; ServerBootstrap bootstrap = new ServerBootstrap ( ) ; bootstrap . group ( availableWorkers ) ; bootstrap . channelFactory ( new VertxNioServerChannelFactory ( ) ) ; applyConnectionOptions ( bootstrap ) ; sslHelper . validate ( vertx ) ; bootstrap . childHandler ( new ChannelInitializer < Channel > ( ) { @ Override protected void initChannel ( Channel ch ) throws Exception { if ( requestStream . isPaused ( ) || wsStream . isPaused ( ) ) { ch . close ( ) ; return ; } ChannelPipeline pipeline = ch . pipeline ( ) ; if ( sslHelper . isSSL ( ) ) { pipeline . addLast ( "ssl" , sslHelper . createSslHandler ( vertx , false ) ) ; } if ( USE_FLASH_POLICY_HANDLER ) { pipeline . addLast ( "flashpolicy" , new FlashPolicyHandler ( ) ) ; } pipeline . addLast ( "httpDecoder" , new HttpRequestDecoder ( 4096 , 8192 , 8192 , false ) ) ; pipeline . addLast ( "httpEncoder" , new VertxHttpResponseEncoder ( ) ) ; if ( options . isCompressionSupported ( ) ) { pipeline . addLast ( "deflater" , new HttpChunkContentCompressor ( ) ) ; } if ( sslHelper . isSSL ( ) || options . isCompressionSupported ( ) ) { pipeline . addLast ( "chunkedWriter" , new ChunkedWriteHandler ( ) ) ; } if ( options . getIdleTimeout ( ) > 0 ) { pipeline . addLast ( "idle" , new IdleStateHandler ( 0 , 0 , options . getIdleTimeout ( ) ) ) ; } pipeline . addLast ( "handler" , new ServerHandler ( ) ) ; } } ) ; addHandlers ( this , listenContext ) ; try { bindFuture = bootstrap . bind ( new InetSocketAddress ( InetAddress . getByName ( host ) , port ) ) ; Channel serverChannel = bindFuture . channel ( ) ; serverChannelGroup . add ( serverChannel ) ; bindFuture . addListener ( channelFuture - > { if ( ! channelFuture . isSuccess ( ) ) { vertx . sharedHttpServers ( ) . remove ( id ) ; } else { metrics = vertx . metricsSPI ( ) . createMetrics ( this , new SocketAddressImpl ( port , host ) , options ) ; } } ) ; } catch ( final Throwable t ) { if ( listenHandler != null ) { vertx . runOnContext ( v - > listenHandler . handle ( Future . failedFuture ( t ) ) ) ; } else { log . error ( t ) ; } listening = false ; return this ; } vertx . sharedHttpServers ( ) . put ( id , this ) ; actualServer = this ; } else { actualServer = shared ; addHandlers ( actualServer , listenContext ) ; metrics = vertx . metricsSPI ( ) . createMetrics ( this , new SocketAddressImpl ( port , host ) , options ) ; } actualServer . bindFuture . addListener ( future - > { if ( listenHandler != null ) { final AsyncResult < HttpServer > res ; if ( future . isSuccess ( ) ) { res = Future . succeededFuture ( HttpServerImpl . this ) ; } else { res = Future . failedFuture ( future . cause ( ) ) ; listening = false ; } try { listenContext . runOnContext ( ( v ) - > listenHandler . handle ( res ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else if ( ! future . isSuccess ( ) ) { listening = false ; log . error ( future . cause ( ) ) ; } } ) ; } return this ; } @ Override public void close ( ) { close ( null ) ; } @ Override public synchronized void close ( Handler < AsyncResult < Void > > done ) { if ( wsStream . endHandler ( ) != null || requestStream . endHandler ( ) != null ) { Handler < Void > wsEndHandler = wsStream . endHandler ( ) ; wsStream . endHandler ( null ) ; Handler < Void > requestEndHandler = requestStream . endHandler ( ) ; requestStream . endHandler ( null ) ; Handler < AsyncResult < Void > > next = done ; done = new AsyncResultHandler < Void > ( ) { @ Override public void handle ( AsyncResult < Void > event ) { if ( event . succeeded ( ) ) { if ( wsEndHandler != null ) { wsEndHandler . handle ( event . result ( ) ) ; } if ( requestEndHandler != null ) { requestEndHandler . handle ( event . result ( ) ) ; } } if ( next != null ) { next . handle ( event ) ; } } } ; } ContextImpl context = vertx . getOrCreateContext ( ) ; if ( ! listening ) { executeCloseDone ( context , done , null ) ; return ; } listening = false ; synchronized ( vertx . sharedHttpServers ( ) ) { if ( actualServer != null ) { if ( requestStream . handler ( ) != null ) { actualServer . reqHandlerManager . removeHandler ( requestStream . handler ( ) , listenContext ) ; } if ( wsStream . handler ( ) != null ) { actualServer . wsHandlerManager . removeHandler ( wsStream . handler ( ) , listenContext ) ; } if ( actualServer . reqHandlerManager . hasHandlers ( ) || actualServer . wsHandlerManager . hasHandlers ( ) ) { if ( done != null ) { executeCloseDone ( context , done , null ) ; } } else { actualServer . actualClose ( context , done ) ; } } } if ( creatingContext != null ) { creatingContext . removeCloseHook ( this ) ; } } @ Override public Metrics getMetrics ( ) { return metrics ; } @ Override public boolean isMetricsEnabled ( ) { return metrics != null && metrics . isEnabled ( ) ; } SSLHelper getSslHelper ( ) { return sslHelper ; } void removeChannel ( Channel channel ) { connectionMap . remove ( channel ) ; } private void applyConnectionOptions ( ServerBootstrap bootstrap ) { bootstrap . childOption ( ChannelOption . TCP_NODELAY , options . isTcpNoDelay ( ) ) ; if ( options . getSendBufferSize ( ) != - 1 ) { bootstrap . childOption ( ChannelOption . SO_SNDBUF , options . getSendBufferSize ( ) ) ; } if ( options . getReceiveBufferSize ( ) != - 1 ) { bootstrap . childOption ( ChannelOption . SO_RCVBUF , options . getReceiveBufferSize ( ) ) ; bootstrap . childOption ( ChannelOption . RCVBUF_ALLOCATOR , new FixedRecvByteBufAllocator ( options . getReceiveBufferSize ( ) ) ) ; } bootstrap . option ( ChannelOption . SO_LINGER , options . getSoLinger ( ) ) ; if ( options . getTrafficClass ( ) != - 1 ) { bootstrap . childOption ( ChannelOption . IP_TOS , options . getTrafficClass ( ) ) ; } bootstrap . childOption ( ChannelOption . ALLOCATOR , PartialPooledByteBufAllocator . INSTANCE ) ; bootstrap . childOption ( ChannelOption . SO_KEEPALIVE , options . isTcpKeepAlive ( ) ) ; bootstrap . option ( ChannelOption . SO_REUSEADDR , options . isReuseAddress ( ) ) ; bootstrap . option ( ChannelOption . SO_BACKLOG , options . getAcceptBacklog ( ) ) ; } private void addHandlers ( HttpServerImpl server , ContextImpl context ) { if ( requestStream . handler ( ) != null ) { server . reqHandlerManager . addHandler ( requestStream . handler ( ) , context ) ; } if ( wsStream . handler ( ) != null ) { server . wsHandlerManager . addHandler ( wsStream . handler ( ) , context ) ; } } private void actualClose ( final ContextImpl closeContext , final Handler < AsyncResult < Void > > done ) { if ( id != null ) { vertx . sharedHttpServers ( ) . remove ( id ) ; } ContextImpl currCon = vertx . getContext ( ) ; for ( ServerConnection conn : connectionMap . values ( ) ) { conn . close ( ) ; } if ( vertx . getContext ( ) != currCon ) { throw new IllegalStateException ( "Context was changed" ) ; } if ( metrics != null ) { metrics . close ( ) ; } ChannelGroupFuture fut = serverChannelGroup . close ( ) ; fut . addListener ( cgf - > executeCloseDone ( closeContext , done , fut . cause ( ) ) ) ; } private void executeCloseDone ( final ContextImpl closeContext , final Handler < AsyncResult < Void > > done , final Exception e ) { if ( done != null ) { closeContext . runOnContext ( ( v ) - > done . handle ( Future . failedFuture ( e ) ) ) ; } } public class ServerHandler extends VertxHttpHandler < ServerConnection > { private boolean closeFrameSent ; public ServerHandler ( ) { super ( HttpServerImpl . this . connectionMap ) ; } FullHttpRequest wsRequest ; @ Override protected void doMessageReceived ( ServerConnection conn , ChannelHandlerContext ctx , Object msg ) throws Exception { Channel ch = ctx . channel ( ) ; if ( ! DISABLE_WEBSOCKETS ) { if ( msg instanceof HttpRequest ) { final HttpRequest request = ( HttpRequest ) msg ; if ( log . isTraceEnabled ( ) ) log . trace ( "Server received request: " + request . getUri ( ) ) ; if ( request . headers ( ) . contains ( io . vertx . core . http . HttpHeaders . UPGRADE , io . vertx . core . http . HttpHeaders . WEBSOCKET , true ) ) { String connectionHeader = request . headers ( ) . get ( io . vertx . core . http . HttpHeaders . CONNECTION ) ; if ( connectionHeader == null || ! connectionHeader . toLowerCase ( ) . contains ( "upgrade" ) ) { sendError ( "\"Connection\" must be \"Upgrade\"." , BAD_REQUEST , ch ) ; return ; } if ( request . getMethod ( ) != HttpMethod . GET ) { sendError ( null , METHOD_NOT_ALLOWED , ch ) ; return ; } if ( wsRequest == null ) { if ( request instanceof FullHttpRequest ) { handshake ( ( FullHttpRequest ) request , ch , ctx ) ; } else { wsRequest = new DefaultFullHttpRequest ( request . getProtocolVersion ( ) , request . getMethod ( ) , request . getUri ( ) ) ; wsRequest . headers ( ) . set ( request . headers ( ) ) ; } } } else { if ( conn == null ) { createConnAndHandle ( ch , msg , null ) ; } else { conn . handleMessage ( msg ) ; } } } else if ( msg instanceof WebSocketFrameInternal ) { WebSocketFrameInternal wsFrame = ( WebSocketFrameInternal ) msg ; switch ( wsFrame . type ( ) ) { case BINARY : case CONTINUATION : case TEXT : if ( conn != null ) { conn . handleMessage ( msg ) ; } break ; case PING : ch . writeAndFlush ( new WebSocketFrameImpl ( FrameType . PONG , wsFrame . getBinaryData ( ) ) ) ; break ; case PONG : break ; case CLOSE : if ( ! closeFrameSent ) { ch . writeAndFlush ( wsFrame ) . addListener ( ChannelFutureListener . CLOSE ) ; closeFrameSent = true ; } break ; default : throw new IllegalStateException ( "Invalid type: " + wsFrame . type ( ) ) ; } } else if ( msg instanceof HttpContent ) { if ( wsRequest != null ) { wsRequest . content ( ) . writeBytes ( ( ( HttpContent ) msg ) . content ( ) ) ; if ( msg instanceof LastHttpContent ) { FullHttpRequest req = wsRequest ; wsRequest = null ; handshake ( req , ch , ctx ) ; return ; } } if ( conn != null ) { conn . handleMessage ( msg ) ; } } else { throw new IllegalStateException ( "Invalid message " + msg ) ; } } else { if ( conn == null ) { createConnAndHandle ( ch , msg , null ) ; } else { conn . handleMessage ( msg ) ; } } } private void createConnAndHandle ( Channel ch , Object msg , WebSocketServerHandshaker shake ) { HandlerHolder < HttpServerRequest > reqHandler = reqHandlerManager . chooseHandler ( ch . eventLoop ( ) ) ; if ( reqHandler != null ) { ServerConnection conn = new ServerConnection ( vertx , HttpServerImpl . this , ch , reqHandler . context , serverOrigin , shake , metrics ) ; conn . requestHandler ( reqHandler . handler ) ; connectionMap . put ( ch , conn ) ; reqHandler . context . executeFromIO ( ( ) - > { conn . setMetric ( metrics . connected ( conn . remoteAddress ( ) ) ) ; conn . handleMessage ( msg ) ; } ) ; } } private void handshake ( FullHttpRequest request , Channel ch , ChannelHandlerContext ctx ) throws Exception { WebSocketServerHandshaker shake = createHandshaker ( ch , request ) ; if ( shake == null ) { return ; } HandlerHolder < ServerWebSocket > wsHandler = wsHandlerManager . chooseHandler ( ch . eventLoop ( ) ) ; if ( wsHandler == null ) { createConnAndHandle ( ch , request , shake ) ; } else { wsHandler . context . executeFromIO ( ( ) - > { URI theURI ; try { theURI = new URI ( request . getUri ( ) ) ; } catch ( URISyntaxException e2 ) { throw new IllegalArgumentException ( "Invalid uri " + request . getUri ( ) ) ; } ServerConnection wsConn = new ServerConnection ( vertx , HttpServerImpl . this , ch , wsHandler . context , serverOrigin , shake , metrics ) ; wsConn . setMetric ( metrics . connected ( wsConn . remoteAddress ( ) ) ) ; wsConn . wsHandler ( wsHandler . handler ) ; Runnable connectRunnable = ( ) - > { connectionMap . put ( ch , wsConn ) ; try { shake . handshake ( ch , request ) ; } catch ( WebSocketHandshakeException e ) { wsConn . handleException ( e ) ; } catch ( Exception e ) { log . error ( "Failed to generate shake response" , e ) ; } } ; ServerWebSocketImpl ws = new ServerWebSocketImpl ( vertx , theURI . toString ( ) , theURI . getPath ( ) , theURI . getQuery ( ) , new HeadersAdaptor ( request . headers ( ) ) , wsConn , shake . version ( ) != WebSocketVersion . V00 , connectRunnable , options . getMaxWebsocketFrameSize ( ) ) ; ws . setMetric ( metrics . connected ( wsConn . metric ( ) , ws ) ) ; wsConn . handleWebsocketConnect ( ws ) ; if ( ! ws . isRejected ( ) ) { ChannelHandler handler = ctx . pipeline ( ) . get ( HttpChunkContentCompressor . class ) ; if ( handler != null ) { ctx . pipeline ( ) . remove ( handler ) ; } ws . connectNow ( ) ; } else { ch . writeAndFlush ( new DefaultFullHttpResponse ( HTTP_1_1 , BAD_GATEWAY ) ) ; } } ) ; } } } WebSocketServerHandshaker createHandshaker ( Channel ch , HttpRequest request ) { String connectionHeader = request . headers ( ) . get ( io . vertx . core . http . HttpHeaders . CONNECTION ) ; if ( connectionHeader == null || ! connectionHeader . toLowerCase ( ) . contains ( "upgrade" ) ) { sendError ( "\"Connection\" must be \"Upgrade\"." , BAD_REQUEST , ch ) ; return null ; } if ( request . getMethod ( ) != HttpMethod . GET ) { sendError ( null , METHOD_NOT_ALLOWED , ch ) ; return null ; } try { WebSocketServerHandshakerFactory factory = new WebSocketServerHandshakerFactory ( getWebSocketLocation ( ch . pipeline ( ) , request ) , subProtocols , false , options . getMaxWebsocketFrameSize ( ) ) ; WebSocketServerHandshaker shake = factory . newHandshaker ( request ) ; if ( shake == null ) { log . error ( "Unrecognised websockets handshake" ) ; WebSocketServerHandshakerFactory . sendUnsupportedVersionResponse ( ch ) ; } return shake ; } catch ( Exception e ) { throw new VertxException ( e ) ; } } private void sendError ( CharSequence err , HttpResponseStatus status , Channel ch ) { FullHttpResponse resp = new DefaultFullHttpResponse ( HTTP_1_1 , status ) ; if ( status . code ( ) == METHOD_NOT_ALLOWED . code ( ) ) { resp . headers ( ) . set ( io . vertx . core . http . HttpHeaders . ALLOW , io . vertx . core . http . HttpHeaders . GET ) ; } if ( err != null ) { resp . content ( ) . writeBytes ( err . toString ( ) . getBytes ( CharsetUtil . UTF_8 ) ) ; HttpHeaders . setContentLength ( resp , err . length ( ) ) ; } else { HttpHeaders . setContentLength ( resp , 0 ) ; } ch . writeAndFlush ( resp ) ; } private String getWebSocketLocation ( ChannelPipeline pipeline , HttpRequest req ) throws Exception { String prefix ; if ( pipeline . get ( SslHandler . class ) == null ) { prefix = "ws://" ; } else { prefix = "wss://" ; } URI uri = new URI ( req . getUri ( ) ) ; String path = uri . getRawPath ( ) ; String loc = prefix + HttpHeaders . getHost ( req ) + path ; String query = uri . getRawQuery ( ) ; if ( query != null ) { loc += "?" + query ; } return loc ; } @ Override protected void finalize ( ) throws Throwable { close ( ) ; super . finalize ( ) ; } HttpServerOptions options ( ) { return options ; } Map < Channel , ServerConnection > connectionMap ( ) { return connectionMap ; } private class HttpStreamHandler < R extends ReadStream < C > , C extends ReadStream < ? > > implements ReadStream < C > { private Handler < C > handler ; private boolean paused ; private Handler < Void > endHandler ; Handler < C > handler ( ) { synchronized ( HttpServerImpl . this ) { return handler ; } } boolean isPaused ( ) { synchronized ( HttpServerImpl . this ) { return paused ; } } Handler < Void > endHandler ( ) { synchronized ( HttpServerImpl . this ) { return endHandler ; } } @ Override public R handler ( Handler < C > handler ) { synchronized ( HttpServerImpl . this ) { if ( listening ) { throw new IllegalStateException ( "Please set handler before server is listening" ) ; } this . handler = handler ; return ( R ) this ; } } @ Override public R pause ( ) { synchronized ( HttpServerImpl . this ) { if ( ! paused ) { paused = true ; } return ( R ) this ; } } @ Override public R resume ( ) { synchronized ( HttpServerImpl . this ) { if ( paused ) { paused = false ; } return ( R ) this ; } } @ Override public R endHandler ( Handler < Void > endHandler ) { synchronized ( HttpServerImpl . this ) { this . endHandler = endHandler ; return ( R ) this ; } } @ Override public R exceptionHandler ( Handler < Throwable > handler ) { return ( R ) this ; } } class HttpServerRequestStreamImpl extends HttpStreamHandler < HttpServerRequestStream , HttpServerRequest > implements HttpServerRequestStream { } class ServerWebSocketStreamImpl extends HttpStreamHandler < ServerWebSocketStream , ServerWebSocket > implements ServerWebSocketStream { } }
package io . vertx . core . http . impl ; public interface ConnectionLifeCycleListener { void requestEnded ( ClientConnection conn ) ; void responseEnded ( ClientConnection conn ) ; void connectionClosed ( ClientConnection conn ) ; }
package io . vertx . core . http . impl ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . WebSocket ; import io . vertx . core . http . WebSocketFrame ; import io . vertx . core . impl . VertxInternal ; public class WebSocketImpl extends WebSocketImplBase implements WebSocket { private Object metric ; public WebSocketImpl ( VertxInternal vertx , ClientConnection conn , boolean supportsContinuation , int maxWebSocketFrameSize ) { super ( vertx , conn , supportsContinuation , maxWebSocketFrameSize ) ; } @ Override public WebSocket handler ( Handler < Buffer > handler ) { synchronized ( conn ) { if ( handler != null ) { checkClosed ( ) ; } this . dataHandler = handler ; return this ; } } @ Override public WebSocket endHandler ( Handler < Void > handler ) { synchronized ( conn ) { if ( handler != null ) { checkClosed ( ) ; } this . endHandler = handler ; return this ; } } @ Override public WebSocket exceptionHandler ( Handler < Throwable > handler ) { synchronized ( conn ) { if ( handler != null ) { checkClosed ( ) ; } this . exceptionHandler = handler ; return this ; } } @ Override public WebSocket writeFrame ( WebSocketFrame frame ) { writeFrameInternal ( frame ) ; return this ; } @ Override public WebSocket writeFinalTextFrame ( String text ) { return writeFrame ( WebSocketFrame . textFrame ( text , true ) ) ; } @ Override public WebSocket writeFinalBinaryFrame ( Buffer data ) { return writeFrame ( WebSocketFrame . binaryFrame ( data , true ) ) ; } @ Override public WebSocket writeBinaryMessage ( Buffer data ) { writeMessageInternal ( data ) ; return this ; } @ Override public WebSocket closeHandler ( Handler < Void > handler ) { synchronized ( conn ) { checkClosed ( ) ; this . closeHandler = handler ; return this ; } } @ Override public WebSocket frameHandler ( Handler < WebSocketFrame > handler ) { synchronized ( conn ) { checkClosed ( ) ; this . frameHandler = handler ; return this ; } } @ Override public WebSocket pause ( ) { synchronized ( conn ) { checkClosed ( ) ; conn . doPause ( ) ; return this ; } } @ Override public WebSocket resume ( ) { synchronized ( conn ) { checkClosed ( ) ; conn . doResume ( ) ; return this ; } } @ Override public WebSocket setWriteQueueMaxSize ( int maxSize ) { synchronized ( conn ) { checkClosed ( ) ; conn . doSetWriteQueueMaxSize ( maxSize ) ; return this ; } } @ Override public WebSocket write ( Buffer data ) { writeFrame ( WebSocketFrame . binaryFrame ( data , true ) ) ; return this ; } @ Override public WebSocket drainHandler ( Handler < Void > handler ) { synchronized ( conn ) { checkClosed ( ) ; this . drainHandler = handler ; return this ; } } @ Override void handleClosed ( ) { synchronized ( conn ) { ( ( ClientConnection ) conn ) . metrics ( ) . disconnected ( metric ) ; super . handleClosed ( ) ; } } void setMetric ( Object metric ) { synchronized ( conn ) { this . metric = metric ; } } }
package io . vertx . core . http . impl ; import io . netty . buffer . ByteBuf ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . Message ; import io . vertx . core . eventbus . MessageConsumer ; import io . vertx . core . http . WebSocketBase ; import io . vertx . core . http . WebSocketFrame ; import io . vertx . core . http . impl . ws . WebSocketFrameImpl ; import io . vertx . core . http . impl . ws . WebSocketFrameInternal ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . net . SocketAddress ; import io . vertx . core . net . impl . ConnectionBase ; import java . util . UUID ; public abstract class WebSocketImplBase implements WebSocketBase { private final boolean supportsContinuation ; private final String textHandlerID ; private final String binaryHandlerID ; private final int maxWebSocketFrameSize ; private final MessageConsumer binaryHandlerRegistration ; private final MessageConsumer textHandlerRegistration ; protected final ConnectionBase conn ; protected Handler < WebSocketFrame > frameHandler ; protected Handler < Buffer > dataHandler ; protected Handler < Void > drainHandler ; protected Handler < Throwable > exceptionHandler ; protected Handler < Void > closeHandler ; protected Handler < Void > endHandler ; protected boolean closed ; protected WebSocketImplBase ( VertxInternal vertx , ConnectionBase conn , boolean supportsContinuation , int maxWebSocketFrameSize ) { this . supportsContinuation = supportsContinuation ; this . textHandlerID = UUID . randomUUID ( ) . toString ( ) ; this . binaryHandlerID = UUID . randomUUID ( ) . toString ( ) ; this . conn = conn ; Handler < Message < Buffer > > binaryHandler = msg - > writeBinaryFrameInternal ( msg . body ( ) ) ; binaryHandlerRegistration = vertx . eventBus ( ) . < Buffer > localConsumer ( binaryHandlerID ) . handler ( binaryHandler ) ; Handler < Message < String > > textHandler = msg - > writeTextFrameInternal ( msg . body ( ) ) ; textHandlerRegistration = vertx . eventBus ( ) . < String > localConsumer ( textHandlerID ) . handler ( textHandler ) ; this . maxWebSocketFrameSize = maxWebSocketFrameSize ; } public String binaryHandlerID ( ) { return binaryHandlerID ; } public String textHandlerID ( ) { return textHandlerID ; } public boolean writeQueueFull ( ) { synchronized ( conn ) { checkClosed ( ) ; return conn . isNotWritable ( ) ; } } public void close ( ) { synchronized ( conn ) { checkClosed ( ) ; conn . close ( ) ; cleanupHandlers ( ) ; } } @ Override public SocketAddress localAddress ( ) { return conn . localAddress ( ) ; } @ Override public SocketAddress remoteAddress ( ) { return conn . remoteAddress ( ) ; } public abstract WebSocketBase exceptionHandler ( Handler < Throwable > handler ) ; protected void writeMessageInternal ( Buffer data ) { checkClosed ( ) ; writePartialMessage ( data , 0 ) ; } protected void writePartialMessage ( Buffer data , int offset ) { int end = offset + maxWebSocketFrameSize ; boolean isFinal ; if ( end >= data . length ( ) ) { end = data . length ( ) ; isFinal = true ; } else { isFinal = false ; } Buffer slice = data . slice ( offset , end ) ; WebSocketFrame frame ; if ( offset == 0 || ! supportsContinuation ) { frame = WebSocketFrame . binaryFrame ( slice , isFinal ) ; } else { frame = WebSocketFrame . continuationFrame ( slice , isFinal ) ; } writeFrame ( frame ) ; int newOffset = offset + maxWebSocketFrameSize ; if ( ! isFinal ) { writePartialMessage ( data , newOffset ) ; } } protected void writeBinaryFrameInternal ( Buffer data ) { ByteBuf buf = data . getByteBuf ( ) ; WebSocketFrame frame = new WebSocketFrameImpl ( FrameType . BINARY , buf ) ; writeFrame ( frame ) ; } protected void writeTextFrameInternal ( String str ) { WebSocketFrame frame = new WebSocketFrameImpl ( str ) ; writeFrame ( frame ) ; } protected void writeFrameInternal ( WebSocketFrame frame ) { synchronized ( conn ) { checkClosed ( ) ; conn . reportBytesWritten ( frame . binaryData ( ) . length ( ) ) ; conn . writeToChannel ( frame ) ; } } protected void checkClosed ( ) { if ( closed ) { throw new IllegalStateException ( "WebSocket is closed" ) ; } } void handleFrame ( WebSocketFrameInternal frame ) { synchronized ( conn ) { conn . reportBytesRead ( frame . binaryData ( ) . length ( ) ) ; if ( dataHandler != null ) { Buffer buff = Buffer . buffer ( frame . getBinaryData ( ) ) ; dataHandler . handle ( buff ) ; } if ( frameHandler != null ) { frameHandler . handle ( frame ) ; } } } void writable ( ) { if ( drainHandler != null ) { Handler < Void > dh = drainHandler ; drainHandler = null ; dh . handle ( null ) ; } } void handleException ( Throwable t ) { synchronized ( conn ) { if ( exceptionHandler != null ) { exceptionHandler . handle ( t ) ; } } } void handleClosed ( ) { synchronized ( conn ) { cleanupHandlers ( ) ; if ( endHandler != null ) { endHandler . handle ( null ) ; } if ( closeHandler != null ) { closeHandler . handle ( null ) ; } } } private void cleanupHandlers ( ) { if ( ! closed ) { binaryHandlerRegistration . unregister ( ) ; textHandlerRegistration . unregister ( ) ; closed = true ; } } }
package io . vertx . core . http . impl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelFuture ; import io . netty . handler . codec . http . * ; import io . vertx . core . AsyncResult ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . HttpHeaders ; import io . vertx . core . http . HttpServerResponse ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; public class HttpServerResponseImpl implements HttpServerResponse { private static final Logger log = LoggerFactory . getLogger ( HttpServerResponseImpl . class ) ; private final VertxInternal vertx ; private final ServerConnection conn ; private final HttpResponse response ; private final HttpVersion version ; private final boolean keepAlive ; private boolean headWritten ; private boolean written ; private Handler < Void > drainHandler ; private Handler < Throwable > exceptionHandler ; private Handler < Void > closeHandler ; private Handler < Future < Void > > headersEndHandler ; private Handler < Void > bodyEndHandler ; private boolean chunked ; private boolean closed ; private ChannelFuture channelFuture ; private MultiMap headers ; private LastHttpContent trailing ; private MultiMap trailers ; private String statusMessage ; HttpServerResponseImpl ( final VertxInternal vertx , ServerConnection conn , HttpRequest request ) { this . vertx = vertx ; this . conn = conn ; this . version = request . getProtocolVersion ( ) ; this . response = new DefaultHttpResponse ( version , HttpResponseStatus . OK , false ) ; this . keepAlive = version == HttpVersion . HTTP_1_1 || ( version == HttpVersion . HTTP_1_0 && request . headers ( ) . contains ( io . vertx . core . http . HttpHeaders . CONNECTION , HttpHeaders . KEEP_ALIVE , true ) ) ; } @ Override public MultiMap headers ( ) { if ( headers == null ) { headers = new HeadersAdaptor ( response . headers ( ) ) ; } return headers ; } @ Override public MultiMap trailers ( ) { if ( trailers == null ) { if ( trailing == null ) { trailing = new DefaultLastHttpContent ( Unpooled . EMPTY_BUFFER , false ) ; } trailers = new HeadersAdaptor ( trailing . trailingHeaders ( ) ) ; } return trailers ; } @ Override public int getStatusCode ( ) { return response . getStatus ( ) . code ( ) ; } @ Override public HttpServerResponse setStatusCode ( int statusCode ) { HttpResponseStatus status = statusMessage != null ? new HttpResponseStatus ( statusCode , statusMessage ) : HttpResponseStatus . valueOf ( statusCode ) ; this . response . setStatus ( status ) ; return this ; } @ Override public String getStatusMessage ( ) { return response . getStatus ( ) . reasonPhrase ( ) ; } @ Override public HttpServerResponse setStatusMessage ( String statusMessage ) { synchronized ( conn ) { this . statusMessage = statusMessage ; this . response . setStatus ( new HttpResponseStatus ( response . getStatus ( ) . code ( ) , statusMessage ) ) ; return this ; } } @ Override public HttpServerResponseImpl setChunked ( boolean chunked ) { synchronized ( conn ) { checkWritten ( ) ; if ( version != HttpVersion . HTTP_1_0 ) { this . chunked = chunked ; } return this ; } } @ Override public boolean isChunked ( ) { synchronized ( conn ) { return chunked ; } } @ Override public HttpServerResponseImpl putHeader ( String key , String value ) { synchronized ( conn ) { checkWritten ( ) ; headers ( ) . set ( key , value ) ; return this ; } } @ Override public HttpServerResponseImpl putHeader ( String key , Iterable < String > values ) { synchronized ( conn ) { checkWritten ( ) ; headers ( ) . set ( key , values ) ; return this ; } } @ Override public HttpServerResponseImpl putTrailer ( String key , String value ) { synchronized ( conn ) { checkWritten ( ) ; trailers ( ) . set ( key , value ) ; return this ; } } @ Override public HttpServerResponseImpl putTrailer ( String key , Iterable < String > values ) { synchronized ( conn ) { checkWritten ( ) ; trailers ( ) . set ( key , values ) ; return this ; } } @ Override public HttpServerResponse putHeader ( CharSequence name , CharSequence value ) { synchronized ( conn ) { checkWritten ( ) ; headers ( ) . set ( name , value ) ; return this ; } } @ Override public HttpServerResponse putHeader ( CharSequence name , Iterable < CharSequence > values ) { synchronized ( conn ) { checkWritten ( ) ; headers ( ) . set ( name , values ) ; return this ; } } @ Override public HttpServerResponse putTrailer ( CharSequence name , CharSequence value ) { synchronized ( conn ) { checkWritten ( ) ; trailers ( ) . set ( name , value ) ; return this ; } } @ Override public HttpServerResponse putTrailer ( CharSequence name , Iterable < CharSequence > value ) { synchronized ( conn ) { checkWritten ( ) ; trailers ( ) . set ( name , value ) ; return this ; } } @ Override public HttpServerResponse setWriteQueueMaxSize ( int size ) { synchronized ( conn ) { checkWritten ( ) ; conn . doSetWriteQueueMaxSize ( size ) ; return this ; } } @ Override public boolean writeQueueFull ( ) { synchronized ( conn ) { checkWritten ( ) ; return conn . isNotWritable ( ) ; } } @ Override public HttpServerResponse drainHandler ( Handler < Void > handler ) { synchronized ( conn ) { checkWritten ( ) ; this . drainHandler = handler ; conn . getContext ( ) . runOnContext ( v - > conn . handleInterestedOpsChanged ( ) ) ; return this ; } } @ Override public HttpServerResponse exceptionHandler ( Handler < Throwable > handler ) { synchronized ( conn ) { checkWritten ( ) ; this . exceptionHandler = handler ; return this ; } } @ Override public HttpServerResponse closeHandler ( Handler < Void > handler ) { synchronized ( conn ) { checkWritten ( ) ; this . closeHandler = handler ; return this ; } } @ Override public HttpServerResponseImpl write ( Buffer chunk ) { ByteBuf buf = chunk . getByteBuf ( ) ; return write ( buf , null ) ; } @ Override public HttpServerResponseImpl write ( String chunk , String enc ) { return write ( Buffer . buffer ( chunk , enc ) . getByteBuf ( ) , null ) ; } @ Override public HttpServerResponseImpl write ( String chunk ) { return write ( Buffer . buffer ( chunk ) . getByteBuf ( ) , null ) ; } @ Override public HttpServerResponse writeContinue ( ) { conn . write100Continue ( ) ; return this ; } @ Override public void end ( String chunk ) { end ( Buffer . buffer ( chunk ) ) ; } @ Override public void end ( String chunk , String enc ) { end ( Buffer . buffer ( chunk , enc ) ) ; } @ Override public void end ( Buffer chunk ) { synchronized ( conn ) { if ( ! chunked && ! contentLengthSet ( ) ) { headers ( ) . set ( HttpHeaders . CONTENT_LENGTH , String . valueOf ( chunk . length ( ) ) ) ; } ByteBuf buf = chunk . getByteBuf ( ) ; end0 ( buf ) ; } } @ Override public void close ( ) { synchronized ( conn ) { if ( ! closed ) { if ( headWritten ) { closeConnAfterWrite ( ) ; } else { conn . close ( ) ; } closed = true ; } } } @ Override public void end ( ) { synchronized ( conn ) { end0 ( Unpooled . EMPTY_BUFFER ) ; } } @ Override public HttpServerResponseImpl sendFile ( String filename ) { doSendFile ( filename , null ) ; return this ; } @ Override public HttpServerResponse sendFile ( String filename , Handler < AsyncResult < Void > > resultHandler ) { doSendFile ( filename , resultHandler ) ; return this ; } @ Override public boolean ended ( ) { synchronized ( conn ) { return written ; } } @ Override public boolean headWritten ( ) { synchronized ( conn ) { return headWritten ; } } @ Override public HttpServerResponse headersEndHandler ( Handler < Future < Void > > handler ) { synchronized ( conn ) { this . headersEndHandler = handler ; return this ; } } @ Override public HttpServerResponse bodyEndHandler ( Handler < Void > handler ) { synchronized ( conn ) { this . bodyEndHandler = handler ; return this ; } } private void end0 ( ByteBuf data ) { checkWritten ( ) ; if ( ! headWritten ) { prepareHeaders ( ( ) - > { FullHttpResponse resp ; if ( trailing != null ) { resp = new AssembledFullHttpResponse ( response , data , trailing . trailingHeaders ( ) , trailing . getDecoderResult ( ) ) ; } else { resp = new AssembledFullHttpResponse ( response , data ) ; } channelFuture = conn . writeToChannel ( resp ) ; headWritten = true ; } ) ; } else { if ( ! data . isReadable ( ) ) { if ( trailing == null ) { channelFuture = conn . writeToChannel ( LastHttpContent . EMPTY_LAST_CONTENT ) ; } else { channelFuture = conn . writeToChannel ( trailing ) ; } } else { LastHttpContent content ; if ( trailing != null ) { content = new AssembledLastHttpContent ( data , trailing . trailingHeaders ( ) , trailing . getDecoderResult ( ) ) ; } else { content = new DefaultLastHttpContent ( data , false ) ; } channelFuture = conn . writeToChannel ( content ) ; } } if ( ! keepAlive ) { closeConnAfterWrite ( ) ; } written = true ; conn . responseComplete ( ) ; if ( bodyEndHandler != null ) { bodyEndHandler . handle ( null ) ; } } private void doSendFile ( String filename , Handler < AsyncResult < Void > > resultHandler ) { synchronized ( conn ) { if ( headWritten ) { throw new IllegalStateException ( "Head already written" ) ; } checkWritten ( ) ; File file = vertx . resolveFile ( filename ) ; long fileLength = file . length ( ) ; if ( ! contentLengthSet ( ) ) { putHeader ( HttpHeaders . CONTENT_LENGTH , String . valueOf ( fileLength ) ) ; } if ( ! contentTypeSet ( ) ) { int li = filename . lastIndexOf ( '.' ) ; if ( li != - 1 && li != filename . length ( ) - 1 ) { String ext = filename . substring ( li + 1 , filename . length ( ) ) ; String contentType = MimeMapping . getMimeTypeForExtension ( ext ) ; if ( contentType != null ) { putHeader ( HttpHeaders . CONTENT_TYPE , contentType ) ; } } } prepareHeaders ( ( ) - > { RandomAccessFile raf ; try { raf = new RandomAccessFile ( file , "r" ) ; conn . queueForWrite ( response ) ; conn . sendFile ( raf , fileLength ) ; } catch ( IOException e ) { if ( resultHandler != null ) { ContextImpl ctx = vertx . getOrCreateContext ( ) ; ctx . runOnContext ( ( v ) - > resultHandler . handle ( Future . failedFuture ( e ) ) ) ; } else { log . error ( "Failed to send file" , e ) ; } return ; } channelFuture = conn . writeToChannel ( LastHttpContent . EMPTY_LAST_CONTENT ) ; headWritten = written = true ; if ( resultHandler != null ) { ContextImpl ctx = vertx . getOrCreateContext ( ) ; channelFuture . addListener ( future - > { AsyncResult < Void > res ; if ( future . isSuccess ( ) ) { res = Future . succeededFuture ( ) ; } else { res = Future . failedFuture ( future . cause ( ) ) ; } ctx . runOnContext ( ( v ) - > resultHandler . handle ( res ) ) ; } ) ; } if ( ! keepAlive ) { closeConnAfterWrite ( ) ; } conn . responseComplete ( ) ; if ( bodyEndHandler != null ) { bodyEndHandler . handle ( null ) ; } } ) ; } } private boolean contentLengthSet ( ) { if ( headers == null ) { return false ; } return response . headers ( ) . contains ( HttpHeaders . CONTENT_LENGTH ) ; } private boolean contentTypeSet ( ) { if ( headers == null ) { return false ; } return response . headers ( ) . contains ( HttpHeaders . CONTENT_TYPE ) ; } private void closeConnAfterWrite ( ) { if ( channelFuture != null ) { channelFuture . addListener ( fut - > conn . close ( ) ) ; } } void handleDrained ( ) { synchronized ( conn ) { if ( drainHandler != null ) { drainHandler . handle ( null ) ; } } } void handleException ( Throwable t ) { synchronized ( conn ) { if ( exceptionHandler != null ) { exceptionHandler . handle ( t ) ; } } } void handleClosed ( ) { synchronized ( conn ) { if ( closeHandler != null ) { closeHandler . handle ( null ) ; } } } private void checkWritten ( ) { if ( written ) { throw new IllegalStateException ( "Response has already been written" ) ; } } private void prepareHeaders ( Runnable after ) { if ( version == HttpVersion . HTTP_1_0 && keepAlive ) { response . headers ( ) . set ( HttpHeaders . CONNECTION , HttpHeaders . KEEP_ALIVE ) ; } if ( chunked ) { response . headers ( ) . set ( HttpHeaders . TRANSFER_ENCODING , HttpHeaders . CHUNKED ) ; } else if ( version != HttpVersion . HTTP_1_0 && ! contentLengthSet ( ) ) { response . headers ( ) . set ( HttpHeaders . CONTENT_LENGTH , "0" ) ; } if ( headersEndHandler != null ) { Future < Void > fut = Future . future ( ) ; fut . setHandler ( res - > { if ( res . succeeded ( ) ) { after . run ( ) ; } else { if ( exceptionHandler != null ) { exceptionHandler . handle ( res . cause ( ) ) ; } else { log . error ( "Failure in headers end handler" , res . cause ( ) ) ; } } } ) ; headersEndHandler . handle ( fut ) ; } else { after . run ( ) ; } } private HttpServerResponseImpl write ( ByteBuf chunk , Handler < AsyncResult < Void > > completionHandler ) { synchronized ( conn ) { checkWritten ( ) ; if ( ! headWritten && version != HttpVersion . HTTP_1_0 && ! chunked && ! contentLengthSet ( ) ) { throw new IllegalStateException ( "You must set the Content-Length header to be the total size of the message " + "body BEFORE sending any data if you are not using HTTP chunked encoding." ) ; } if ( ! headWritten ) { prepareHeaders ( ( ) - > { channelFuture = conn . writeToChannel ( new AssembledHttpResponse ( response , chunk ) ) ; headWritten = true ; } ) ; } else { channelFuture = conn . writeToChannel ( new DefaultHttpContent ( chunk ) ) ; } conn . addFuture ( completionHandler , channelFuture ) ; return this ; } } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Verticle ; import io . vertx . core . Vertx ; import io . vertx . core . VertxOptions ; import org . junit . Test ; public class BlockedThreadCheckerTest extends VertxTestBase { @ Test public void testBlockCheckDefault ( ) throws Exception { Verticle verticle = new AbstractVerticle ( ) { @ Override public void start ( ) throws InterruptedException { Thread . sleep ( 6000 ) ; testComplete ( ) ; } } ; vertx . deployVerticle ( verticle ) ; await ( ) ; } @ Test public void testBlockCheckExceptionTimeLimit ( ) throws Exception { Verticle verticle = new AbstractVerticle ( ) { @ Override public void start ( ) throws InterruptedException { Thread . sleep ( 2000 ) ; testComplete ( ) ; } } ; VertxOptions vertxOptions = new VertxOptions ( ) ; vertxOptions . setMaxEventLoopExecuteTime ( 1000000000 ) ; vertxOptions . setWarningExceptionTime ( 1000000000 ) ; Vertx newVertx = Vertx . vertx ( vertxOptions ) ; newVertx . deployVerticle ( verticle ) ; await ( ) ; } @ Test public void testBlockCheckWorker ( ) throws Exception { Verticle verticle = new AbstractVerticle ( ) { @ Override public void start ( ) throws InterruptedException { Thread . sleep ( 2000 ) ; testComplete ( ) ; } } ; VertxOptions vertxOptions = new VertxOptions ( ) ; vertxOptions . setMaxWorkerExecuteTime ( 1000000000 ) ; vertxOptions . setWarningExceptionTime ( 1000000000 ) ; Vertx newVertx = Vertx . vertx ( vertxOptions ) ; DeploymentOptions depolymentOptions = new DeploymentOptions ( ) ; depolymentOptions . setWorker ( true ) ; newVertx . deployVerticle ( verticle , depolymentOptions ) ; await ( ) ; } }
package io . vertx . core . http . impl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . DefaultByteBufHolder ; import io . netty . handler . codec . DecoderResult ; import io . netty . handler . codec . http . HttpContent ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . LastHttpContent ; class AssembledLastHttpContent extends DefaultByteBufHolder implements LastHttpContent { private final HttpHeaders trailingHeaders ; private DecoderResult result ; public AssembledLastHttpContent ( ByteBuf buf , HttpHeaders trailingHeaders , DecoderResult result ) { super ( buf ) ; this . trailingHeaders = trailingHeaders ; this . result = result ; } @ Override public HttpHeaders trailingHeaders ( ) { return trailingHeaders ; } @ Override public LastHttpContent copy ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public LastHttpContent retain ( int increment ) { super . retain ( increment ) ; return this ; } @ Override public LastHttpContent retain ( ) { super . retain ( ) ; return this ; } @ Override public HttpContent duplicate ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public DecoderResult getDecoderResult ( ) { return result ; } @ Override public void setDecoderResult ( DecoderResult result ) { this . result = result ; } }
package io . vertx . core . http . impl ; public enum FrameType { CONTINUATION , TEXT , BINARY , CLOSE , PING , PONG , }
package io . vertx . core . http . impl ; import io . netty . channel . Channel ; import io . netty . channel . socket . nio . NioSocketChannel ; import java . nio . channels . SocketChannel ; public class VertxNioSocketChannel < C > extends NioSocketChannel { public C conn ; public VertxNioSocketChannel ( Channel parent , SocketChannel socket ) { super ( parent , socket ) ; } public VertxNioSocketChannel ( ) { } }
package io . vertx . core . http . impl ; import io . netty . buffer . ByteBuf ; import io . netty . handler . codec . DecoderResult ; import io . netty . handler . codec . http . DefaultHttpContent ; import io . netty . handler . codec . http . HttpContent ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpResponse ; import io . netty . handler . codec . http . HttpResponseStatus ; import io . netty . handler . codec . http . HttpVersion ; class AssembledHttpResponse implements HttpResponse , HttpContent { private final HttpResponse response ; protected final HttpContent content ; AssembledHttpResponse ( HttpResponse response , HttpContent content ) { this . response = response ; this . content = content ; } AssembledHttpResponse ( HttpResponse response , ByteBuf buf ) { this ( response , new DefaultHttpContent ( buf ) ) ; } @ Override public HttpContent copy ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public HttpContent duplicate ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public AssembledHttpResponse retain ( ) { content . retain ( ) ; return this ; } @ Override public AssembledHttpResponse retain ( int increment ) { content . retain ( increment ) ; return this ; } @ Override public HttpResponseStatus getStatus ( ) { return response . getStatus ( ) ; } @ Override public AssembledHttpResponse setStatus ( HttpResponseStatus status ) { response . setStatus ( status ) ; return this ; } @ Override public AssembledHttpResponse setProtocolVersion ( HttpVersion version ) { response . setProtocolVersion ( version ) ; return this ; } @ Override public HttpVersion getProtocolVersion ( ) { return response . getProtocolVersion ( ) ; } @ Override public HttpHeaders headers ( ) { return response . headers ( ) ; } @ Override public DecoderResult getDecoderResult ( ) { return response . getDecoderResult ( ) ; } @ Override public void setDecoderResult ( DecoderResult result ) { response . setDecoderResult ( result ) ; } @ Override public ByteBuf content ( ) { return content . content ( ) ; } @ Override public int refCnt ( ) { return content . refCnt ( ) ; } @ Override public boolean release ( ) { return content . release ( ) ; } @ Override public boolean release ( int decrement ) { return content . release ( decrement ) ; } }
package io . vertx . core . http . impl ; import io . netty . buffer . ByteBuf ; import io . netty . channel . * ; import io . netty . handler . codec . DecoderResult ; import io . netty . handler . codec . http . * ; import io . netty . handler . codec . http . websocketx . CloseWebSocketFrame ; import io . netty . handler . codec . http . websocketx . WebSocketHandshakeException ; import io . netty . handler . codec . http . websocketx . WebSocketServerHandshaker ; import io . netty . handler . codec . http . websocketx . WebSocketVersion ; import io . netty . handler . stream . ChunkedFile ; import io . netty . util . ReferenceCountUtil ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . Vertx ; import io . vertx . core . VoidHandler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . HttpServerRequest ; import io . vertx . core . http . ServerWebSocket ; import io . vertx . core . http . WebSocketFrame ; import io . vertx . core . http . impl . ws . WebSocketFrameInternal ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . net . NetSocket ; import io . vertx . core . net . impl . ConnectionBase ; import io . vertx . core . net . impl . NetSocketImpl ; import io . vertx . core . net . impl . VertxNetHandler ; import io . vertx . core . spi . metrics . HttpServerMetrics ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . util . ArrayDeque ; import java . util . HashMap ; import java . util . Map ; import java . util . Queue ; import static io . netty . handler . codec . http . HttpResponseStatus . CONTINUE ; import static io . netty . handler . codec . http . HttpVersion . HTTP_1_1 ; class ServerConnection extends ConnectionBase { private static final Logger log = LoggerFactory . getLogger ( ServerConnection . class ) ; private static final int CHANNEL_PAUSE_QUEUE_SIZE = 5 ; private final Queue < Object > pending = new ArrayDeque < > ( 8 ) ; private final String serverOrigin ; private final HttpServerImpl server ; private WebSocketServerHandshaker handshaker ; private final HttpServerMetrics metrics ; private Object requestMetric ; private Handler < HttpServerRequest > requestHandler ; private Handler < ServerWebSocket > wsHandler ; private HttpServerRequestImpl currentRequest ; private HttpServerResponseImpl pendingResponse ; private ServerWebSocketImpl ws ; private ChannelFuture lastWriteFuture ; private boolean channelPaused ; private boolean paused ; private boolean sentCheck ; private long bytesRead ; private long bytesWritten ; private Object metric ; ServerConnection ( VertxInternal vertx , HttpServerImpl server , Channel channel , ContextImpl context , String serverOrigin , WebSocketServerHandshaker handshaker , HttpServerMetrics metrics ) { super ( vertx , channel , context , metrics ) ; this . serverOrigin = serverOrigin ; this . server = server ; this . handshaker = handshaker ; this . metrics = metrics ; } @ Override protected synchronized Object metric ( ) { return metric ; } synchronized void setMetric ( Object metric ) { this . metric = metric ; } public synchronized void pause ( ) { if ( ! paused ) { paused = true ; } } public synchronized void resume ( ) { if ( paused ) { paused = false ; checkNextTick ( ) ; } } synchronized void handleMessage ( Object msg ) { if ( paused || ( pendingResponse != null && msg instanceof HttpRequest ) || ! pending . isEmpty ( ) ) { pending . add ( msg ) ; if ( pending . size ( ) == CHANNEL_PAUSE_QUEUE_SIZE ) { super . doPause ( ) ; channelPaused = true ; } } else { processMessage ( msg ) ; } } synchronized void responseComplete ( ) { if ( metrics . isEnabled ( ) ) { reportBytesWritten ( bytesWritten ) ; bytesWritten = 0 ; metrics . responseEnd ( requestMetric , pendingResponse ) ; } pendingResponse = null ; checkNextTick ( ) ; } synchronized void requestHandler ( Handler < HttpServerRequest > handler ) { this . requestHandler = handler ; } synchronized void wsHandler ( Handler < ServerWebSocket > handler ) { this . wsHandler = handler ; } String getServerOrigin ( ) { return serverOrigin ; } Vertx vertx ( ) { return vertx ; } @ Override public ChannelFuture writeToChannel ( Object obj ) { if ( metrics . isEnabled ( ) ) { long bytes = getBytes ( obj ) ; if ( bytes == - 1 ) { log . warn ( "Metrics could not be updated to include bytes written because of unknown object " + obj . getClass ( ) + " being written." ) ; } else { bytesWritten += bytes ; } } return lastWriteFuture = super . writeToChannel ( obj ) ; } ServerWebSocket upgrade ( HttpServerRequest request , HttpRequest nettyReq ) { if ( ws != null ) { return ws ; } handshaker = server . createHandshaker ( channel , nettyReq ) ; if ( handshaker == null ) { throw new IllegalStateException ( "Can't upgrade this request" ) ; } ws = new ServerWebSocketImpl ( vertx , request . uri ( ) , request . path ( ) , request . query ( ) , request . headers ( ) , this , handshaker . version ( ) != WebSocketVersion . V00 , null , server . options ( ) . getMaxWebsocketFrameSize ( ) ) ; ws . setMetric ( metrics . upgrade ( requestMetric , ws ) ) ; try { handshaker . handshake ( channel , nettyReq ) ; } catch ( WebSocketHandshakeException e ) { handleException ( e ) ; } catch ( Exception e ) { log . error ( "Failed to generate shake response" , e ) ; } ChannelHandler handler = channel . pipeline ( ) . get ( HttpChunkContentCompressor . class ) ; if ( handler != null ) { channel . pipeline ( ) . remove ( handler ) ; } server . connectionMap ( ) . put ( channel , this ) ; return ws ; } boolean isSSL ( ) { return server . getSslHelper ( ) . isSSL ( ) ; } NetSocket createNetSocket ( ) { NetSocketImpl socket = new NetSocketImpl ( vertx , channel , context , server . getSslHelper ( ) , false , metrics , metric ) ; Map < Channel , NetSocketImpl > connectionMap = new HashMap < > ( 1 ) ; connectionMap . put ( channel , socket ) ; endReadAndFlush ( ) ; ChannelPipeline pipeline = channel . pipeline ( ) ; ChannelHandler compressor = pipeline . get ( HttpChunkContentCompressor . class ) ; if ( compressor != null ) { pipeline . remove ( compressor ) ; } pipeline . remove ( "httpDecoder" ) ; if ( pipeline . get ( "chunkedWriter" ) != null ) { pipeline . remove ( "chunkedWriter" ) ; } channel . pipeline ( ) . replace ( "handler" , "handler" , new VertxNetHandler ( connectionMap ) { @ Override public void exceptionCaught ( ChannelHandlerContext chctx , Throwable t ) throws Exception { server . removeChannel ( channel ) ; super . exceptionCaught ( chctx , t ) ; } @ Override public void channelInactive ( ChannelHandlerContext chctx ) throws Exception { server . removeChannel ( channel ) ; super . channelInactive ( chctx ) ; } @ Override public void channelRead ( ChannelHandlerContext chctx , Object msg ) throws Exception { if ( msg instanceof HttpContent ) { ReferenceCountUtil . release ( msg ) ; return ; } super . channelRead ( chctx , msg ) ; } } ) ; if ( lastWriteFuture == null ) { channel . pipeline ( ) . remove ( "httpEncoder" ) ; } else { lastWriteFuture . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { channel . pipeline ( ) . remove ( "httpEncoder" ) ; } } ) ; } return socket ; } private void handleRequest ( HttpServerRequestImpl req , HttpServerResponseImpl resp ) { this . currentRequest = req ; pendingResponse = resp ; requestMetric = metrics . requestBegin ( metric , req ) ; if ( requestHandler != null ) { requestHandler . handle ( req ) ; } } private void handleChunk ( Buffer chunk ) { if ( metrics . isEnabled ( ) ) { bytesRead += chunk . length ( ) ; } currentRequest . handleData ( chunk ) ; } private void handleEnd ( ) { currentRequest . handleEnd ( ) ; reportBytesRead ( bytesRead ) ; currentRequest = null ; bytesRead = 0 ; } @ Override public synchronized void handleInterestedOpsChanged ( ) { if ( ! isNotWritable ( ) ) { if ( pendingResponse != null ) { pendingResponse . handleDrained ( ) ; } else if ( ws != null ) { ws . writable ( ) ; } } } @ Override public void close ( ) { if ( handshaker == null ) { super . close ( ) ; } else { endReadAndFlush ( ) ; handshaker . close ( channel , new CloseWebSocketFrame ( 1000 , null ) ) ; } } synchronized void handleWebsocketConnect ( ServerWebSocketImpl ws ) { if ( wsHandler != null ) { wsHandler . handle ( ws ) ; this . ws = ws ; } } void write100Continue ( ) { channel . writeAndFlush ( new DefaultFullHttpResponse ( HTTP_1_1 , CONTINUE ) ) ; } synchronized private void handleWsFrame ( WebSocketFrameInternal frame ) { if ( ws != null ) { ws . handleFrame ( frame ) ; } } synchronized protected void handleClosed ( ) { if ( ws != null ) { metrics . disconnected ( ws . getMetric ( ) ) ; ws . setMetric ( null ) ; } super . handleClosed ( ) ; if ( ws != null ) { ws . handleClosed ( ) ; } if ( pendingResponse != null ) { pendingResponse . handleClosed ( ) ; } } protected ContextImpl getContext ( ) { return super . getContext ( ) ; } @ Override protected synchronized void handleException ( Throwable t ) { super . handleException ( t ) ; if ( currentRequest != null ) { currentRequest . handleException ( t ) ; } if ( pendingResponse != null ) { pendingResponse . handleException ( t ) ; } if ( ws != null ) { ws . handleException ( t ) ; } } protected void addFuture ( Handler < AsyncResult < Void > > completionHandler , ChannelFuture future ) { super . addFuture ( completionHandler , future ) ; } @ Override protected boolean supportsFileRegion ( ) { return super . supportsFileRegion ( ) && channel . pipeline ( ) . get ( HttpChunkContentCompressor . class ) == null ; } protected ChannelFuture sendFile ( RandomAccessFile file , long fileLength ) throws IOException { return super . sendFile ( file , fileLength ) ; } private void processMessage ( Object msg ) { if ( msg instanceof HttpRequest ) { HttpRequest request = ( HttpRequest ) msg ; DecoderResult result = ( ( HttpObject ) msg ) . getDecoderResult ( ) ; if ( result . isFailure ( ) ) { channel . pipeline ( ) . fireExceptionCaught ( result . cause ( ) ) ; return ; } if ( server . options ( ) . isHandle100ContinueAutomatically ( ) ) { if ( HttpHeaders . is100ContinueExpected ( request ) ) { write100Continue ( ) ; } } HttpServerResponseImpl resp = new HttpServerResponseImpl ( vertx , this , request ) ; HttpServerRequestImpl req = new HttpServerRequestImpl ( this , request , resp ) ; handleRequest ( req , resp ) ; } if ( msg instanceof HttpContent ) { HttpContent chunk = ( HttpContent ) msg ; if ( chunk . content ( ) . isReadable ( ) ) { Buffer buff = Buffer . buffer ( chunk . content ( ) ) ; handleChunk ( buff ) ; } if ( msg instanceof LastHttpContent ) { if ( ! paused ) { handleEnd ( ) ; } else { pending . add ( LastHttpContent . EMPTY_LAST_CONTENT ) ; } } } else if ( msg instanceof WebSocketFrameInternal ) { WebSocketFrameInternal frame = ( WebSocketFrameInternal ) msg ; handleWsFrame ( frame ) ; } checkNextTick ( ) ; } private void checkNextTick ( ) { if ( ! pending . isEmpty ( ) && ! sentCheck && ! paused && ( pendingResponse == null || pending . peek ( ) instanceof HttpContent ) ) { sentCheck = true ; vertx . runOnContext ( new VoidHandler ( ) { public void handle ( ) { sentCheck = false ; if ( ! paused ) { Object msg = pending . poll ( ) ; if ( msg != null ) { processMessage ( msg ) ; } if ( channelPaused && pending . isEmpty ( ) ) { ServerConnection . super . doResume ( ) ; channelPaused = false ; } } } } ) ; } } private long getBytes ( Object obj ) { if ( obj == null ) return 0 ; if ( obj instanceof Buffer ) { return ( ( Buffer ) obj ) . length ( ) ; } else if ( obj instanceof ByteBuf ) { return ( ( ByteBuf ) obj ) . readableBytes ( ) ; } else if ( obj instanceof HttpContent ) { return ( ( HttpContent ) obj ) . content ( ) . readableBytes ( ) ; } else if ( obj instanceof WebSocketFrame ) { return ( ( WebSocketFrame ) obj ) . binaryData ( ) . length ( ) ; } else if ( obj instanceof FileRegion ) { return ( ( FileRegion ) obj ) . count ( ) ; } else if ( obj instanceof ChunkedFile ) { ChunkedFile file = ( ChunkedFile ) obj ; return file . endOffset ( ) - file . startOffset ( ) ; } else { return - 1 ; } } }
package io . vertx . core . http . impl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . CompositeByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . handler . codec . http . DefaultHttpContent ; import io . netty . handler . codec . http . DefaultHttpRequest ; import io . netty . handler . codec . http . DefaultLastHttpContent ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . handler . codec . http . HttpVersion ; import io . netty . handler . codec . http . LastHttpContent ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . HttpClientRequest ; import io . vertx . core . http . HttpClientResponse ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . net . NetSocket ; import io . vertx . core . spi . metrics . HttpClientMetrics ; import java . util . List ; import java . util . Objects ; import java . util . concurrent . TimeoutException ; import static io . vertx . core . http . HttpHeaders . * ; public class HttpClientRequestImpl implements HttpClientRequest { private static final Logger log = LoggerFactory . getLogger ( HttpClientRequestImpl . class ) ; private final String host ; private final int port ; private final HttpClientImpl client ; private final HttpRequest request ; private final VertxInternal vertx ; private final io . vertx . core . http . HttpMethod method ; private Handler < HttpClientResponse > respHandler ; private Handler < Void > endHandler ; private boolean chunked ; private Handler < Void > continueHandler ; private ClientConnection conn ; private Handler < Void > drainHandler ; private Handler < Throwable > exceptionHandler ; private boolean headWritten ; private boolean completed ; private ByteBuf pendingChunks ; private int pendingMaxSize = - 1 ; private boolean connecting ; private boolean writeHead ; private long written ; private long currentTimeoutTimerId = - 1 ; private MultiMap headers ; private boolean exceptionOccurred ; private long lastDataReceived ; private Object metric ; HttpClientRequestImpl ( HttpClientImpl client , io . vertx . core . http . HttpMethod method , String host , int port , String relativeURI , VertxInternal vertx ) { this . host = host ; this . port = port ; this . client = client ; this . request = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , toNettyHttpMethod ( method ) , relativeURI , false ) ; this . chunked = false ; this . method = method ; this . vertx = vertx ; } @ Override public synchronized HttpClientRequest handler ( Handler < HttpClientResponse > handler ) { if ( handler != null ) { checkComplete ( ) ; respHandler = checkConnect ( method , handler ) ; } else { respHandler = null ; } return this ; } @ Override public HttpClientRequest pause ( ) { return this ; } @ Override public HttpClientRequest resume ( ) { return this ; } @ Override public synchronized HttpClientRequest endHandler ( Handler < Void > endHandler ) { if ( endHandler != null ) { checkComplete ( ) ; } this . endHandler = endHandler ; return this ; } @ Override public synchronized HttpClientRequestImpl setChunked ( boolean chunked ) { checkComplete ( ) ; if ( written > 0 ) { throw new IllegalStateException ( "Cannot set chunked after data has been written on request" ) ; } this . chunked = chunked ; return this ; } @ Override public synchronized boolean isChunked ( ) { return chunked ; } @ Override public io . vertx . core . http . HttpMethod method ( ) { return method ; } @ Override public String uri ( ) { return request . getUri ( ) ; } @ Override public synchronized MultiMap headers ( ) { if ( headers == null ) { headers = new HeadersAdaptor ( request . headers ( ) ) ; } return headers ; } @ Override public synchronized HttpClientRequest putHeader ( String name , String value ) { checkComplete ( ) ; headers ( ) . set ( name , value ) ; return this ; } @ Override public synchronized HttpClientRequest putHeader ( String name , Iterable < String > values ) { checkComplete ( ) ; headers ( ) . set ( name , values ) ; return this ; } @ Override public synchronized HttpClientRequestImpl write ( Buffer chunk ) { checkComplete ( ) ; checkResponseHandler ( ) ; ByteBuf buf = chunk . getByteBuf ( ) ; write ( buf , false ) ; return this ; } @ Override public synchronized HttpClientRequestImpl write ( String chunk ) { checkComplete ( ) ; checkResponseHandler ( ) ; return write ( Buffer . buffer ( chunk ) ) ; } @ Override public synchronized HttpClientRequestImpl write ( String chunk , String enc ) { Objects . requireNonNull ( enc , "no null encoding accepted" ) ; checkComplete ( ) ; checkResponseHandler ( ) ; return write ( Buffer . buffer ( chunk , enc ) ) ; } @ Override public synchronized HttpClientRequest setWriteQueueMaxSize ( int maxSize ) { checkComplete ( ) ; if ( conn != null ) { conn . doSetWriteQueueMaxSize ( maxSize ) ; } else { pendingMaxSize = maxSize ; } return this ; } @ Override public synchronized boolean writeQueueFull ( ) { checkComplete ( ) ; return conn != null && conn . isNotWritable ( ) ; } @ Override public synchronized HttpClientRequest drainHandler ( Handler < Void > handler ) { checkComplete ( ) ; this . drainHandler = handler ; if ( conn != null ) { conn . getContext ( ) . runOnContext ( v - > conn . handleInterestedOpsChanged ( ) ) ; } return this ; } @ Override public synchronized HttpClientRequest exceptionHandler ( Handler < Throwable > handler ) { if ( handler != null ) { checkComplete ( ) ; this . exceptionHandler = t - > { cancelOutstandingTimeoutTimer ( ) ; handler . handle ( t ) ; } ; } else { this . exceptionHandler = null ; } return this ; } @ Override public synchronized HttpClientRequest continueHandler ( Handler < Void > handler ) { checkComplete ( ) ; this . continueHandler = handler ; return this ; } @ Override public synchronized HttpClientRequestImpl sendHead ( ) { checkComplete ( ) ; checkResponseHandler ( ) ; if ( conn != null ) { if ( ! headWritten ) { writeHead ( ) ; } } else { connect ( ) ; writeHead = true ; } return this ; } @ Override public synchronized void end ( String chunk ) { end ( Buffer . buffer ( chunk ) ) ; } @ Override public synchronized void end ( String chunk , String enc ) { Objects . requireNonNull ( enc , "no null encoding accepted" ) ; end ( Buffer . buffer ( chunk , enc ) ) ; } @ Override public synchronized void end ( Buffer chunk ) { checkComplete ( ) ; checkResponseHandler ( ) ; if ( ! chunked && ! contentLengthSet ( ) ) { headers ( ) . set ( CONTENT_LENGTH , String . valueOf ( chunk . length ( ) ) ) ; } write ( chunk . getByteBuf ( ) , true ) ; } @ Override public synchronized void end ( ) { checkComplete ( ) ; checkResponseHandler ( ) ; write ( Unpooled . EMPTY_BUFFER , true ) ; } @ Override public synchronized HttpClientRequest setTimeout ( long timeoutMs ) { cancelOutstandingTimeoutTimer ( ) ; currentTimeoutTimerId = client . getVertx ( ) . setTimer ( timeoutMs , id - > handleTimeout ( timeoutMs ) ) ; return this ; } @ Override public synchronized HttpClientRequest putHeader ( CharSequence name , CharSequence value ) { checkComplete ( ) ; headers ( ) . set ( name , value ) ; return this ; } @ Override public synchronized HttpClientRequest putHeader ( CharSequence name , Iterable < CharSequence > values ) { checkComplete ( ) ; headers ( ) . set ( name , values ) ; return this ; } synchronized void dataReceived ( ) { if ( currentTimeoutTimerId != - 1 ) { lastDataReceived = System . currentTimeMillis ( ) ; } } synchronized void handleDrained ( ) { if ( drainHandler != null ) { drainHandler . handle ( null ) ; } } synchronized void handleException ( Throwable t ) { cancelOutstandingTimeoutTimer ( ) ; exceptionOccurred = true ; getExceptionHandler ( ) . handle ( t ) ; } synchronized void handleResponse ( HttpClientResponseImpl resp ) { if ( ! exceptionOccurred ) { cancelOutstandingTimeoutTimer ( ) ; try { if ( resp . statusCode ( ) == 100 ) { if ( continueHandler != null ) { continueHandler . handle ( null ) ; } } else { if ( respHandler != null ) { respHandler . handle ( resp ) ; } if ( endHandler != null ) { endHandler . handle ( null ) ; } } } catch ( Throwable t ) { handleException ( t ) ; } } } synchronized HttpRequest getRequest ( ) { return request ; } private Handler < HttpClientResponse > checkConnect ( io . vertx . core . http . HttpMethod method , Handler < HttpClientResponse > handler ) { if ( method == io . vertx . core . http . HttpMethod . CONNECT ) { handler = connectHandler ( handler ) ; } return handler ; } private Handler < HttpClientResponse > connectHandler ( Handler < HttpClientResponse > responseHandler ) { Objects . requireNonNull ( responseHandler , "no null responseHandler accepted" ) ; return resp - > { HttpClientResponse response ; if ( resp . statusCode ( ) == 200 ) { NetSocket socket = resp . netSocket ( ) ; socket . pause ( ) ; response = new HttpClientResponse ( ) { private boolean resumed ; @ Override public int statusCode ( ) { return resp . statusCode ( ) ; } @ Override public String statusMessage ( ) { return resp . statusMessage ( ) ; } @ Override public MultiMap headers ( ) { return resp . headers ( ) ; } @ Override public String getHeader ( String headerName ) { return resp . getHeader ( headerName ) ; } @ Override public String getTrailer ( String trailerName ) { return resp . getTrailer ( trailerName ) ; } @ Override public MultiMap trailers ( ) { return resp . trailers ( ) ; } @ Override public List < String > cookies ( ) { return resp . cookies ( ) ; } @ Override public HttpClientResponse bodyHandler ( Handler < Buffer > bodyHandler ) { resp . bodyHandler ( bodyHandler ) ; return this ; } @ Override public synchronized NetSocket netSocket ( ) { if ( ! resumed ) { resumed = true ; vertx . getContext ( ) . runOnContext ( ( v ) - > socket . resume ( ) ) ; } return socket ; } @ Override public HttpClientResponse endHandler ( Handler < Void > endHandler ) { resp . endHandler ( endHandler ) ; return this ; } @ Override public HttpClientResponse handler ( Handler < Buffer > handler ) { resp . handler ( handler ) ; return this ; } @ Override public HttpClientResponse pause ( ) { resp . pause ( ) ; return this ; } @ Override public HttpClientResponse resume ( ) { resp . resume ( ) ; return this ; } @ Override public HttpClientResponse exceptionHandler ( Handler < Throwable > handler ) { resp . exceptionHandler ( handler ) ; return this ; } } ; } else { response = resp ; } responseHandler . handle ( response ) ; } ; } private Handler < Throwable > getExceptionHandler ( ) { return exceptionHandler != null ? exceptionHandler : log : : error ; } private void cancelOutstandingTimeoutTimer ( ) { if ( currentTimeoutTimerId != - 1 ) { client . getVertx ( ) . cancelTimer ( currentTimeoutTimerId ) ; currentTimeoutTimerId = - 1 ; } } private void handleTimeout ( long timeoutMs ) { if ( lastDataReceived == 0 ) { timeout ( timeoutMs ) ; } else { long now = System . currentTimeMillis ( ) ; long timeSinceLastData = now - lastDataReceived ; if ( timeSinceLastData >= timeoutMs ) { timeout ( timeoutMs ) ; } else { lastDataReceived = 0 ; setTimeout ( timeoutMs - timeSinceLastData ) ; } } } private void timeout ( long timeoutMs ) { handleException ( new TimeoutException ( "The timeout period of " + timeoutMs + "ms has been exceeded" ) ) ; } private synchronized void connect ( ) { if ( ! connecting ) { client . getConnection ( port , host , conn - > { synchronized ( this ) { if ( exceptionOccurred ) { conn . close ( ) ; } else if ( ! conn . isClosed ( ) ) { connected ( conn ) ; } else { connect ( ) ; } } } , exceptionHandler , vertx . getOrCreateContext ( ) ) ; connecting = true ; } } private void connected ( ClientConnection conn ) { conn . setCurrentRequest ( this ) ; this . conn = conn ; this . metric = client . httpClientMetrics ( ) . requestBegin ( conn . metric ( ) , conn . localAddress ( ) , conn . remoteAddress ( ) , this ) ; if ( pendingMaxSize != - 1 ) { conn . doSetWriteQueueMaxSize ( pendingMaxSize ) ; } if ( pendingChunks != null ) { ByteBuf pending = pendingChunks ; pendingChunks = null ; if ( completed ) { writeHeadWithContent ( pending , true ) ; conn . reportBytesWritten ( written ) ; if ( respHandler != null ) { conn . endRequest ( ) ; } } else { writeHeadWithContent ( pending , false ) ; } } else { if ( completed ) { writeHeadWithContent ( Unpooled . EMPTY_BUFFER , true ) ; conn . reportBytesWritten ( written ) ; if ( respHandler != null ) { conn . endRequest ( ) ; } } else { if ( writeHead ) { writeHead ( ) ; } } } } void reportResponseEnd ( HttpClientResponseImpl resp ) { HttpClientMetrics metrics = client . httpClientMetrics ( ) ; if ( metrics . isEnabled ( ) ) { metrics . responseEnd ( metric , resp ) ; } } private boolean contentLengthSet ( ) { return headers != null && request . headers ( ) . contains ( CONTENT_LENGTH ) ; } private void writeHead ( ) { prepareHeaders ( ) ; conn . writeToChannel ( request ) ; headWritten = true ; } private void writeHeadWithContent ( ByteBuf buf , boolean end ) { prepareHeaders ( ) ; if ( end ) { conn . writeToChannel ( new AssembledFullHttpRequest ( request , buf ) ) ; } else { conn . writeToChannel ( new AssembledHttpRequest ( request , buf ) ) ; } headWritten = true ; } private void prepareHeaders ( ) { HttpHeaders headers = request . headers ( ) ; headers . remove ( TRANSFER_ENCODING ) ; if ( ! headers . contains ( HOST ) ) { request . headers ( ) . set ( HOST , conn . hostHeader ( ) ) ; } if ( chunked ) { HttpHeaders . setTransferEncodingChunked ( request ) ; } if ( client . getOptions ( ) . isTryUseCompression ( ) && request . headers ( ) . get ( ACCEPT_ENCODING ) == null ) { request . headers ( ) . set ( ACCEPT_ENCODING , DEFLATE_GZIP ) ; } } private void write ( ByteBuf buff , boolean end ) { int readableBytes = buff . readableBytes ( ) ; if ( readableBytes == 0 && ! end ) { return ; } if ( end ) { completed = true ; } if ( ! end && ! chunked && ! contentLengthSet ( ) ) { throw new IllegalStateException ( "You must set the Content-Length header to be the total size of the message " + "body BEFORE sending any data if you are not using HTTP chunked encoding." ) ; } written += buff . readableBytes ( ) ; if ( conn == null ) { if ( pendingChunks == null ) { pendingChunks = buff ; } else { CompositeByteBuf pending ; if ( pendingChunks instanceof CompositeByteBuf ) { pending = ( CompositeByteBuf ) pendingChunks ; } else { pending = Unpooled . compositeBuffer ( ) ; pending . addComponent ( pendingChunks ) . writerIndex ( pendingChunks . writerIndex ( ) ) ; pendingChunks = pending ; } pending . addComponent ( buff ) . writerIndex ( pending . writerIndex ( ) + buff . writerIndex ( ) ) ; } connect ( ) ; } else { if ( ! headWritten ) { writeHeadWithContent ( buff , end ) ; } else { if ( end ) { if ( buff . isReadable ( ) ) { conn . writeToChannel ( new DefaultLastHttpContent ( buff , false ) ) ; } else { conn . writeToChannel ( LastHttpContent . EMPTY_LAST_CONTENT ) ; } } else { conn . writeToChannel ( new DefaultHttpContent ( buff ) ) ; } } if ( end ) { conn . reportBytesWritten ( written ) ; if ( respHandler != null ) { conn . endRequest ( ) ; } } } } private void checkComplete ( ) { if ( completed ) { throw new IllegalStateException ( "Request already complete" ) ; } } private void checkResponseHandler ( ) { if ( respHandler == null ) { throw new IllegalStateException ( "You must set an handler for the HttpClientResponse before connecting" ) ; } } private HttpMethod toNettyHttpMethod ( io . vertx . core . http . HttpMethod method ) { switch ( method ) { case CONNECT : { return HttpMethod . CONNECT ; } case GET : { return HttpMethod . GET ; } case PUT : { return HttpMethod . PUT ; } case POST : { return HttpMethod . POST ; } case DELETE : { return HttpMethod . DELETE ; } case HEAD : { return HttpMethod . HEAD ; } case OPTIONS : { return HttpMethod . OPTIONS ; } case TRACE : { return HttpMethod . TRACE ; } case PATCH : { return HttpMethod . PATCH ; } default : throw new IllegalArgumentException ( ) ; } } }
package io . vertx . core . http . impl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . ByteBufHolder ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . handler . codec . http . DefaultHttpContent ; import io . netty . handler . codec . http . HttpContent ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . handler . codec . http . websocketx . * ; import io . vertx . core . http . impl . ws . WebSocketFrameImpl ; import io . vertx . core . http . impl . ws . WebSocketFrameInternal ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . net . impl . ConnectionBase ; import io . vertx . core . net . impl . VertxHandler ; import java . util . Map ; public abstract class VertxHttpHandler < C extends ConnectionBase > extends VertxHandler < C > { private static ByteBuf safeBuffer ( ByteBufHolder holder , ByteBufAllocator allocator ) { return safeBuffer ( holder . content ( ) , allocator ) ; } protected Map < Channel , C > connectionMap ; protected VertxHttpHandler ( Map < Channel , C > connectionMap ) { this . connectionMap = connectionMap ; } @ Override protected C getConnection ( Channel channel ) { @ SuppressWarnings ( "unchecked" ) VertxNioSocketChannel < C > vch = ( VertxNioSocketChannel < C > ) channel ; if ( vch . conn != null ) { return vch . conn ; } else { C conn = connectionMap . get ( channel ) ; if ( conn != null ) { vch . conn = conn ; } return conn ; } } @ Override protected C removeConnection ( Channel channel ) { @ SuppressWarnings ( "unchecked" ) VertxNioSocketChannel < C > vch = ( VertxNioSocketChannel < C > ) channel ; vch . conn = null ; return connectionMap . remove ( channel ) ; } @ Override protected void channelRead ( final C connection , final ContextImpl context , final ChannelHandlerContext chctx , final Object msg ) throws Exception { if ( connection != null ) { context . executeFromIO ( ( ) - > doMessageReceived ( connection , chctx , msg ) ) ; } else { try { doMessageReceived ( null , chctx , msg ) ; } catch ( Throwable t ) { chctx . pipeline ( ) . fireExceptionCaught ( t ) ; } } } @ Override protected Object safeObject ( Object msg , ByteBufAllocator allocator ) throws Exception { if ( msg instanceof HttpContent ) { HttpContent content = ( HttpContent ) msg ; ByteBuf buf = content . content ( ) ; if ( buf != Unpooled . EMPTY_BUFFER && buf . isDirect ( ) ) { ByteBuf newBuf = safeBuffer ( content , allocator ) ; if ( msg instanceof LastHttpContent ) { LastHttpContent last = ( LastHttpContent ) msg ; return new AssembledLastHttpContent ( newBuf , last . trailingHeaders ( ) , last . getDecoderResult ( ) ) ; } else { return new DefaultHttpContent ( newBuf ) ; } } } else if ( msg instanceof WebSocketFrame ) { ByteBuf payload = safeBuffer ( ( WebSocketFrame ) msg , allocator ) ; boolean isFinal = ( ( WebSocketFrame ) msg ) . isFinalFragment ( ) ; FrameType frameType ; if ( msg instanceof BinaryWebSocketFrame ) { frameType = FrameType . BINARY ; } else if ( msg instanceof CloseWebSocketFrame ) { frameType = FrameType . CLOSE ; } else if ( msg instanceof PingWebSocketFrame ) { frameType = FrameType . PING ; } else if ( msg instanceof PongWebSocketFrame ) { frameType = FrameType . PONG ; } else if ( msg instanceof TextWebSocketFrame ) { frameType = FrameType . TEXT ; } else if ( msg instanceof ContinuationWebSocketFrame ) { frameType = FrameType . CONTINUATION ; } else { throw new IllegalStateException ( "Unsupported websocket msg " + msg ) ; } return new WebSocketFrameImpl ( frameType , payload , isFinal ) ; } return msg ; } @ Override public void write ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) throws Exception { if ( msg instanceof WebSocketFrameInternal ) { WebSocketFrameInternal frame = ( WebSocketFrameInternal ) msg ; ByteBuf buf = frame . getBinaryData ( ) ; if ( buf != Unpooled . EMPTY_BUFFER ) { buf = safeBuffer ( buf , ctx . alloc ( ) ) ; } switch ( frame . type ( ) ) { case BINARY : msg = new BinaryWebSocketFrame ( frame . isFinal ( ) , 0 , buf ) ; break ; case TEXT : msg = new TextWebSocketFrame ( frame . isFinal ( ) , 0 , buf ) ; break ; case CLOSE : msg = new CloseWebSocketFrame ( true , 0 , buf ) ; break ; case CONTINUATION : msg = new ContinuationWebSocketFrame ( frame . isFinal ( ) , 0 , buf ) ; break ; case PONG : msg = new PongWebSocketFrame ( buf ) ; break ; case PING : msg = new PingWebSocketFrame ( buf ) ; break ; default : throw new IllegalStateException ( "Unsupported websocket msg " + msg ) ; } } ctx . write ( msg , promise ) ; } protected abstract void doMessageReceived ( C connection , ChannelHandlerContext ctx , Object msg ) throws Exception ; }
package io . vertx . core . http . impl ; import io . netty . channel . socket . nio . NioServerSocketChannel ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import java . nio . channels . SocketChannel ; import java . util . List ; public class VertxNioServerSocketChannel extends NioServerSocketChannel { private static final Logger log = LoggerFactory . getLogger ( VertxNioServerSocketChannel . class ) ; @ Override protected int doReadMessages ( List < Object > buf ) throws Exception { SocketChannel ch = javaChannel ( ) . accept ( ) ; try { if ( ch != null ) { buf . add ( new VertxNioSocketChannel ( this , ch ) ) ; return 1 ; } } catch ( Throwable t ) { log . warn ( "Failed to create a new channel from an accepted socket." , t ) ; try { ch . close ( ) ; } catch ( Throwable t2 ) { log . warn ( "Failed to close a socket." , t2 ) ; } } return 0 ; } }
package io . vertx . core . http . impl . cgbystrom ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . util . CharsetUtil ; public class FlashPolicyHandler extends ChannelInboundHandlerAdapter { private static final String XML = "<cross-domain-policy><allow-access-from domain=\"*\" to-ports=\"*\" /></cross-domain-policy>" ; enum ParseState { MAGIC1 , MAGIC2 } private ParseState state = ParseState . MAGIC1 ; @ Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { ByteBuf buffer = ( ByteBuf ) msg ; int index = buffer . readerIndex ( ) ; switch ( state ) { case MAGIC1 : if ( ! buffer . isReadable ( ) ) { return ; } final int magic1 = buffer . getUnsignedByte ( index ++ ) ; state = ParseState . MAGIC2 ; if ( magic1 != '<' ) { ctx . fireChannelRead ( buffer ) ; ctx . pipeline ( ) . remove ( this ) ; return ; } case MAGIC2 : if ( ! buffer . isReadable ( ) ) { return ; } final int magic2 = buffer . getUnsignedByte ( index ) ; if ( magic2 != 'p' ) { ctx . fireChannelRead ( buffer ) ; ctx . pipeline ( ) . remove ( this ) ; } else { ctx . writeAndFlush ( Unpooled . copiedBuffer ( XML , CharsetUtil . UTF_8 ) ) . addListener ( ChannelFutureListener . CLOSE ) ; } } } }
package io . vertx . core . http . impl . ws ; import io . netty . buffer . ByteBuf ; import io . vertx . core . http . WebSocketFrame ; import io . vertx . core . http . impl . FrameType ; public interface WebSocketFrameInternal extends WebSocketFrame { ByteBuf getBinaryData ( ) ; void setBinaryData ( ByteBuf binaryData ) ; void setTextData ( String textData ) ; FrameType type ( ) ; }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . Future ; import io . vertx . core . http . HttpServer ; import io . vertx . core . http . HttpServerOptions ; public class SimpleServer extends AbstractVerticle { @ Override public void start ( Future < Void > startFuture ) throws Exception { HttpServer server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( 8080 ) ) ; server . requestHandler ( req - > req . response ( ) . end ( ) ) ; server . listen ( res - > { if ( res . succeeded ( ) ) { startFuture . complete ( ) ; } else { startFuture . fail ( res . cause ( ) ) ; } } ) ; } }
package io . vertx . core . http . impl . ws ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . util . CharsetUtil ; import io . netty . util . ReferenceCounted ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . impl . FrameType ; public class WebSocketFrameImpl implements WebSocketFrameInternal , ReferenceCounted { private final FrameType type ; private final boolean isFinalFrame ; private ByteBuf binaryData ; public WebSocketFrameImpl ( ) { this ( null , Unpooled . EMPTY_BUFFER , true ) ; } public WebSocketFrameImpl ( FrameType frameType ) { this ( frameType , Unpooled . EMPTY_BUFFER , true ) ; } public WebSocketFrameImpl ( String textData ) { this ( textData , true ) ; } public WebSocketFrameImpl ( String textData , boolean isFinalFrame ) { this . type = FrameType . TEXT ; this . isFinalFrame = isFinalFrame ; this . binaryData = Unpooled . copiedBuffer ( textData , CharsetUtil . UTF_8 ) ; } public WebSocketFrameImpl ( FrameType type , ByteBuf binaryData ) { this ( type , binaryData , true ) ; } public WebSocketFrameImpl ( FrameType type , ByteBuf binaryData , boolean isFinalFrame ) { this . type = type ; this . isFinalFrame = isFinalFrame ; this . binaryData = Unpooled . unreleasableBuffer ( binaryData ) ; } public boolean isText ( ) { return this . type == FrameType . TEXT ; } public boolean isBinary ( ) { return this . type == FrameType . BINARY ; } public boolean isContinuation ( ) { return this . type == FrameType . CONTINUATION ; } public ByteBuf getBinaryData ( ) { return binaryData ; } public String textData ( ) { return getBinaryData ( ) . toString ( CharsetUtil . UTF_8 ) ; } public Buffer binaryData ( ) { return Buffer . buffer ( binaryData ) ; } public void setBinaryData ( ByteBuf binaryData ) { if ( this . binaryData != null ) { this . binaryData . release ( ) ; } this . binaryData = binaryData ; } public void setTextData ( String textData ) { if ( this . binaryData != null ) { this . binaryData . release ( ) ; } this . binaryData = Unpooled . copiedBuffer ( textData , CharsetUtil . UTF_8 ) ; } @ Override public String toString ( ) { return getClass ( ) . getSimpleName ( ) + "(type: " + type + ", " + "data: " + getBinaryData ( ) + ')' ; } @ Override public int refCnt ( ) { return binaryData . refCnt ( ) ; } @ Override public ReferenceCounted retain ( ) { return binaryData . retain ( ) ; } @ Override public ReferenceCounted retain ( int increment ) { return binaryData . retain ( increment ) ; } @ Override public boolean release ( ) { return binaryData . release ( ) ; } @ Override public boolean release ( int decrement ) { return binaryData . release ( decrement ) ; } @ Override public boolean isFinal ( ) { return isFinalFrame ; } @ Override public FrameType type ( ) { return type ; } }
package io . vertx . core . json ; public class DecodeException extends RuntimeException { public DecodeException ( ) { } public DecodeException ( String message ) { super ( message ) ; } }
package io . vertx . core . json ; public @ interface Fluent { }
package io . vertx . core . json ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . shareddata . impl . ClusterSerializable ; import java . util . ArrayList ; import java . util . Base64 ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . stream . Stream ; public class JsonArray implements Iterable < Object > , ClusterSerializable { private List < Object > list ; public JsonArray ( String json ) { fromJson ( json ) ; } public JsonArray ( ) { list = new ArrayList < > ( ) ; } public JsonArray ( List list ) { this . list = list ; } public String getString ( int pos ) { CharSequence cs = ( CharSequence ) list . get ( pos ) ; return cs == null ? null : cs . toString ( ) ; } public Integer getInteger ( int pos ) { Number number = ( Number ) list . get ( pos ) ; if ( number == null ) { return null ; } else if ( number instanceof Integer ) { return ( Integer ) number ; } else { return number . intValue ( ) ; } } public Long getLong ( int pos ) { Number number = ( Number ) list . get ( pos ) ; if ( number == null ) { return null ; } else if ( number instanceof Long ) { return ( Long ) number ; } else { return number . longValue ( ) ; } } public Double getDouble ( int pos ) { Number number = ( Number ) list . get ( pos ) ; if ( number == null ) { return null ; } else if ( number instanceof Double ) { return ( Double ) number ; } else { return number . doubleValue ( ) ; } } public Float getFloat ( int pos ) { Number number = ( Number ) list . get ( pos ) ; if ( number == null ) { return null ; } else if ( number instanceof Float ) { return ( Float ) number ; } else { return number . floatValue ( ) ; } } public Boolean getBoolean ( int pos ) { return ( Boolean ) list . get ( pos ) ; } public JsonObject getJsonObject ( int pos ) { Object val = list . get ( pos ) ; if ( val instanceof Map ) { val = new JsonObject ( ( Map ) val ) ; } return ( JsonObject ) val ; } public JsonArray getJsonArray ( int pos ) { Object val = list . get ( pos ) ; if ( val instanceof List ) { val = new JsonArray ( ( List ) val ) ; } return ( JsonArray ) val ; } public byte [ ] getBinary ( int pos ) { String val = ( String ) list . get ( pos ) ; if ( val == null ) { return null ; } else { return Base64 . getDecoder ( ) . decode ( val ) ; } } public Object getValue ( int pos ) { Object val = list . get ( pos ) ; if ( val instanceof Map ) { val = new JsonObject ( ( Map ) val ) ; } else if ( val instanceof List ) { val = new JsonArray ( ( List ) val ) ; } return val ; } public boolean hasNull ( int pos ) { return list . get ( pos ) == null ; } public JsonArray add ( Enum value ) { Objects . requireNonNull ( value ) ; list . add ( value . name ( ) ) ; return this ; } public JsonArray add ( CharSequence value ) { Objects . requireNonNull ( value ) ; list . add ( value . toString ( ) ) ; return this ; } public JsonArray add ( String value ) { Objects . requireNonNull ( value ) ; list . add ( value ) ; return this ; } public JsonArray add ( Integer value ) { Objects . requireNonNull ( value ) ; list . add ( value ) ; return this ; } public JsonArray add ( Long value ) { Objects . requireNonNull ( value ) ; list . add ( value ) ; return this ; } public JsonArray add ( Double value ) { Objects . requireNonNull ( value ) ; list . add ( value ) ; return this ; } public JsonArray add ( Float value ) { Objects . requireNonNull ( value ) ; list . add ( value ) ; return this ; } public JsonArray add ( Boolean value ) { Objects . requireNonNull ( value ) ; list . add ( value ) ; return this ; } public JsonArray addNull ( ) { list . add ( null ) ; return this ; } public JsonArray add ( JsonObject value ) { Objects . requireNonNull ( value ) ; list . add ( value ) ; return this ; } public JsonArray add ( JsonArray value ) { Objects . requireNonNull ( value ) ; list . add ( value ) ; return this ; } public JsonArray add ( byte [ ] value ) { Objects . requireNonNull ( value ) ; list . add ( Base64 . getEncoder ( ) . encodeToString ( value ) ) ; return this ; } public JsonArray add ( Object value ) { Objects . requireNonNull ( value ) ; value = Json . checkAndCopy ( value , false ) ; list . add ( value ) ; return this ; } public JsonArray addAll ( JsonArray array ) { Objects . requireNonNull ( array ) ; list . addAll ( array . list ) ; return this ; } public boolean contains ( Object value ) { return list . contains ( value ) ; } public boolean remove ( Object value ) { return list . remove ( value ) ; } public Object remove ( int pos ) { return list . remove ( pos ) ; } public int size ( ) { return list . size ( ) ; } public boolean isEmpty ( ) { return list . isEmpty ( ) ; } public List getList ( ) { return list ; } public JsonArray clear ( ) { list . clear ( ) ; return this ; } @ Override public Iterator < Object > iterator ( ) { return new Iter ( list . iterator ( ) ) ; } public String encode ( ) { return Json . encode ( list ) ; } public String encodePrettily ( ) { return Json . encodePrettily ( list ) ; } public JsonArray copy ( ) { List < Object > copiedList = new ArrayList < > ( list . size ( ) ) ; for ( Object val : list ) { val = Json . checkAndCopy ( val , true ) ; copiedList . add ( val ) ; } return new JsonArray ( copiedList ) ; } public Stream < Object > stream ( ) { return list . stream ( ) ; } @ Override public String toString ( ) { return encode ( ) ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; return arrayEquals ( list , o ) ; } static boolean arrayEquals ( List < ? > l1 , Object o2 ) { List < ? > l2 ; if ( o2 instanceof JsonArray ) { l2 = ( ( JsonArray ) o2 ) . list ; } else if ( o2 instanceof List < ? > ) { l2 = ( List < ? > ) o2 ; } else { return false ; } if ( l1 . size ( ) != l2 . size ( ) ) return false ; Iterator < ? > iter = l2 . iterator ( ) ; for ( Object entry : l1 ) { Object other = iter . next ( ) ; if ( entry == null ) { if ( other != null ) { return false ; } } else if ( ! JsonObject . equals ( entry , other ) ) { return false ; } } return true ; } @ Override public int hashCode ( ) { return list . hashCode ( ) ; } @ Override public void writeToBuffer ( Buffer buffer ) { String encoded = encode ( ) ; byte [ ] bytes = encoded . getBytes ( ) ; buffer . appendInt ( bytes . length ) ; buffer . appendBytes ( bytes ) ; } @ Override public int readFromBuffer ( int pos , Buffer buffer ) { int length = buffer . getInt ( pos ) ; int start = pos + 4 ; String encoded = buffer . getString ( start , start + length ) ; fromJson ( encoded ) ; return pos + length + 4 ; } private void fromJson ( String json ) { list = Json . decodeValue ( json , List . class ) ; } private class Iter implements Iterator < Object > { final Iterator < Object > listIter ; Iter ( Iterator < Object > listIter ) { this . listIter = listIter ; } @ Override public boolean hasNext ( ) { return listIter . hasNext ( ) ; } @ Override public Object next ( ) { Object val = listIter . next ( ) ; if ( val instanceof Map ) { val = new JsonObject ( ( Map ) val ) ; } else if ( val instanceof List ) { val = new JsonArray ( ( List ) val ) ; } return val ; } @ Override public void remove ( ) { listIter . remove ( ) ; } } }
package io . vertx . core . json ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . shareddata . impl . ClusterSerializable ; import io . vertx . core . spi . VertxMetricsFactory ; import java . nio . charset . StandardCharsets ; import java . util . * ; import java . util . stream . Stream ; public class JsonObject implements Iterable < Map . Entry < String , Object > > , ClusterSerializable { private Map < String , Object > map ; public JsonObject ( VertxMetricsFactory sconf ) { fromJson ( sconf ) ; } public JsonObject ( ) { map = new LinkedHashMap < > ( ) ; } public JsonObject ( Map < String , Object > map ) { this . map = map ; } public String getString ( String key ) { Objects . requireNonNull ( key ) ; CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString ( ) ; } public Integer getInteger ( String key ) { Objects . requireNonNull ( key ) ; Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } else if ( number instanceof Integer ) { return ( Integer ) number ; } else { return number . intValue ( ) ; } } public Long getLong ( String key ) { Objects . requireNonNull ( key ) ; Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } else if ( number instanceof Long ) { return ( Long ) number ; } else { return number . longValue ( ) ; } } public Double getDouble ( String key ) { Objects . requireNonNull ( key ) ; Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } else if ( number instanceof Double ) { return ( Double ) number ; } else { return number . doubleValue ( ) ; } } public Float getFloat ( String key ) { Objects . requireNonNull ( key ) ; Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } else if ( number instanceof Float ) { return ( Float ) number ; } else { return number . floatValue ( ) ; } } public Boolean getBoolean ( String key ) { Objects . requireNonNull ( key ) ; return ( Boolean ) map . get ( key ) ; } public JsonObject getJsonObject ( String key ) { Objects . requireNonNull ( key ) ; Object val = map . get ( key ) ; if ( val instanceof Map ) { val = new JsonObject ( ( Map ) val ) ; } return ( JsonObject ) val ; } public JsonArray getJsonArray ( String key ) { Objects . requireNonNull ( key ) ; Object val = map . get ( key ) ; if ( val instanceof List ) { val = new JsonArray ( ( List ) val ) ; } return ( JsonArray ) val ; } public byte [ ] getBinary ( String key ) { Objects . requireNonNull ( key ) ; String encoded = ( String ) map . get ( key ) ; return encoded == null ? null : Base64 . getDecoder ( ) . decode ( encoded ) ; } public Object getValue ( String key ) { Objects . requireNonNull ( key ) ; Object val = map . get ( key ) ; if ( val instanceof Map ) { val = new JsonObject ( ( Map ) val ) ; } else if ( val instanceof List ) { val = new JsonArray ( ( List ) val ) ; } return val ; } public String getString ( String key , String def ) { Objects . requireNonNull ( key ) ; CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs != null || map . containsKey ( key ) ? cs == null ? null : cs . toString ( ) : def ; } public Integer getInteger ( String key , Integer def ) { Objects . requireNonNull ( key ) ; Number val = ( Number ) map . get ( key ) ; if ( val == null ) { if ( map . containsKey ( key ) ) { return null ; } else { return def ; } } else if ( val instanceof Integer ) { return ( Integer ) val ; } else { return val . intValue ( ) ; } } public Long getLong ( String key , Long def ) { Objects . requireNonNull ( key ) ; Number val = ( Number ) map . get ( key ) ; if ( val == null ) { if ( map . containsKey ( key ) ) { return null ; } else { return def ; } } else if ( val instanceof Long ) { return ( Long ) val ; } else { return val . longValue ( ) ; } } public Double getDouble ( String key , Double def ) { Objects . requireNonNull ( key ) ; Number val = ( Number ) map . get ( key ) ; if ( val == null ) { if ( map . containsKey ( key ) ) { return null ; } else { return def ; } } else if ( val instanceof Double ) { return ( Double ) val ; } else { return val . doubleValue ( ) ; } } public Float getFloat ( String key , Float def ) { Objects . requireNonNull ( key ) ; Number val = ( Number ) map . get ( key ) ; if ( val == null ) { if ( map . containsKey ( key ) ) { return null ; } else { return def ; } } else if ( val instanceof Float ) { return ( Float ) val ; } else { return val . floatValue ( ) ; } } public Boolean getBoolean ( String key , Boolean def ) { Objects . requireNonNull ( key ) ; Object val = map . get ( key ) ; return val != null || map . containsKey ( key ) ? ( Boolean ) val : def ; } public JsonObject getJsonObject ( String key , JsonObject def ) { JsonObject val = getJsonObject ( key ) ; return val != null || map . containsKey ( key ) ? val : def ; } public JsonArray getJsonArray ( String key , JsonArray def ) { JsonArray val = getJsonArray ( key ) ; return val != null || map . containsKey ( key ) ? val : def ; } public byte [ ] getBinary ( String key , byte [ ] def ) { Objects . requireNonNull ( key ) ; Object val = map . get ( key ) ; return val != null || map . containsKey ( key ) ? ( val == null ? null : Base64 . getDecoder ( ) . decode ( ( String ) val ) ) : def ; } public Object getValue ( String key , Object def ) { Objects . requireNonNull ( key ) ; Object val = getValue ( key ) ; return val != null || map . containsKey ( key ) ? val : def ; } public boolean containsKey ( String key ) { Objects . requireNonNull ( key ) ; return map . containsKey ( key ) ; } public Set < String > fieldNames ( ) { return map . keySet ( ) ; } public JsonObject put ( String key , Enum value ) { Objects . requireNonNull ( key ) ; map . put ( key , value == null ? null : value . name ( ) ) ; return this ; } public JsonObject put ( String key , CharSequence value ) { Objects . requireNonNull ( key ) ; map . put ( key , value == null ? null : value . toString ( ) ) ; return this ; } public JsonObject put ( String key , String value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; } public JsonObject put ( String key , Integer value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; } public JsonObject put ( String key , Long value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; } public JsonObject put ( String key , Double value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; } public JsonObject put ( String key , Float value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; } public JsonObject put ( String key , Boolean value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; } public JsonObject putNull ( String key ) { Objects . requireNonNull ( key ) ; map . put ( key , null ) ; return this ; } public JsonObject put ( String key , JsonObject value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; } public JsonObject put ( String key , JsonArray value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; } public JsonObject put ( String key , byte [ ] value ) { Objects . requireNonNull ( key ) ; map . put ( key , value == null ? null : Base64 . getEncoder ( ) . encodeToString ( value ) ) ; return this ; } public JsonObject put ( String key , Object value ) { Objects . requireNonNull ( key ) ; value = Json . checkAndCopy ( value , false ) ; map . put ( key , value ) ; return this ; } public Object remove ( String key ) { return map . remove ( key ) ; } public JsonObject mergeIn ( JsonObject other ) { map . putAll ( other . map ) ; return this ; } public String encode ( ) { return Json . encode ( map ) ; } public String encodePrettily ( ) { return Json . encodePrettily ( map ) ; } public JsonObject copy ( ) { Map < String , Object > copiedMap = new HashMap < > ( map . size ( ) ) ; for ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { Object val = entry . getValue ( ) ; val = Json . checkAndCopy ( val , true ) ; copiedMap . put ( entry . getKey ( ) , val ) ; } return new JsonObject ( copiedMap ) ; } public Map < String , Object > getMap ( ) { return map ; } public Stream < Map . Entry < String , Object > > stream ( ) { return map . entrySet ( ) . stream ( ) ; } @ Override public Iterator < Map . Entry < String , Object > > iterator ( ) { return new Iter ( map . entrySet ( ) . iterator ( ) ) ; } public int size ( ) { return map . size ( ) ; } @ Fluent public JsonObject clear ( ) { map . clear ( ) ; return this ; } public boolean isEmpty ( ) { return map . isEmpty ( ) ; } @ Override public String toString ( ) { return encode ( ) ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; return objectEquals ( map , o ) ; } static boolean objectEquals ( Map < ? , ? > m1 , Object o2 ) { Map < ? , ? > m2 ; if ( o2 instanceof JsonObject ) { m2 = ( ( JsonObject ) o2 ) . map ; } else if ( o2 instanceof Map < ? , ? > ) { m2 = ( Map < ? , ? > ) o2 ; } else { return false ; } if ( m1 . size ( ) != m2 . size ( ) ) return false ; for ( Map . Entry < ? , ? > entry : m1 . entrySet ( ) ) { Object val = entry . getValue ( ) ; if ( val == null ) { if ( m2 . get ( entry . getKey ( ) ) != null ) { return false ; } } else { if ( ! equals ( entry . getValue ( ) , m2 . get ( entry . getKey ( ) ) ) ) { return false ; } } } return true ; } static boolean equals ( Object o1 , Object o2 ) { if ( o1 == o2 ) return true ; if ( o1 instanceof JsonObject ) { return objectEquals ( ( ( JsonObject ) o1 ) . map , o2 ) ; } if ( o1 instanceof Map < ? , ? > ) { return objectEquals ( ( Map < ? , ? > ) o1 , o2 ) ; } if ( o1 instanceof JsonArray ) { return JsonArray . arrayEquals ( ( ( JsonArray ) o1 ) . getList ( ) , o2 ) ; } if ( o1 instanceof List < ? > ) { return JsonArray . arrayEquals ( ( List < ? > ) o1 , o2 ) ; } if ( o1 instanceof Number && o2 instanceof Number && o1 . getClass ( ) != o2 . getClass ( ) ) { Number n1 = ( Number ) o1 ; Number n2 = ( Number ) o2 ; if ( o1 instanceof Float || o1 instanceof Double || o2 instanceof Float || o2 instanceof Double ) { return n1 . doubleValue ( ) == n2 . doubleValue ( ) ; } else { return n1 . longValue ( ) == n2 . longValue ( ) ; } } return o1 . equals ( o2 ) ; } @ Override public int hashCode ( ) { return map . hashCode ( ) ; } @ Override public void writeToBuffer ( Buffer buffer ) { String encoded = encode ( ) ; byte [ ] bytes = encoded . getBytes ( StandardCharsets . UTF_8 ) ; buffer . appendInt ( bytes . length ) ; buffer . appendBytes ( bytes ) ; } @ Override public int readFromBuffer ( int pos , Buffer buffer ) { int length = buffer . getInt ( pos ) ; int start = pos + 4 ; String encoded = buffer . getString ( start , start + length ) ; fromJson ( encoded ) ; return pos + length + 4 ; } private void fromJson ( String json ) { map = Json . decodeValue ( json , Map . class ) ; } private class Iter implements Iterator < Map . Entry < String , Object > > { final Iterator < Map . Entry < String , Object > > mapIter ; Iter ( Iterator < Map . Entry < String , Object > > mapIter ) { this . mapIter = mapIter ; } @ Override public boolean hasNext ( ) { return mapIter . hasNext ( ) ; } @ Override public Map . Entry < String , Object > next ( ) { Map . Entry < String , Object > entry = mapIter . next ( ) ; if ( entry . getValue ( ) instanceof Map ) { return new Entry ( entry . getKey ( ) , new JsonObject ( ( Map ) entry . getValue ( ) ) ) ; } else if ( entry . getValue ( ) instanceof List ) { return new Entry ( entry . getKey ( ) , new JsonArray ( ( List ) entry . getValue ( ) ) ) ; } return entry ; } @ Override public void remove ( ) { mapIter . remove ( ) ; } } private static final class Entry implements Map . Entry < String , Object > { final String key ; final Object value ; public Entry ( String key , Object value ) { this . key = key ; this . value = value ; } @ Override public String getKey ( ) { return key ; } @ Override public Object getValue ( ) { return value ; } @ Override public Object setValue ( Object value ) { throw new UnsupportedOperationException ( ) ; } } }
package io . vertx . core . json ; public class EncodeException extends RuntimeException { public EncodeException ( String message ) { super ( message ) ; } public EncodeException ( ) { } }
package io . vertx . core . json ; import com . fasterxml . jackson . core . JsonGenerator ; import com . fasterxml . jackson . core . JsonParser ; import com . fasterxml . jackson . databind . JsonSerializer ; import com . fasterxml . jackson . databind . ObjectMapper ; import com . fasterxml . jackson . databind . SerializationFeature ; import com . fasterxml . jackson . databind . SerializerProvider ; import com . fasterxml . jackson . databind . module . SimpleModule ; import java . io . IOException ; import java . math . BigDecimal ; import java . util . Base64 ; import java . util . List ; import java . util . Map ; public class Json { public static ObjectMapper mapper = new ObjectMapper ( ) ; public static ObjectMapper prettyMapper = new ObjectMapper ( ) ; static { mapper . configure ( JsonParser . Feature . ALLOW_COMMENTS , true ) ; prettyMapper . configure ( JsonParser . Feature . ALLOW_COMMENTS , true ) ; prettyMapper . configure ( SerializationFeature . INDENT_OUTPUT , true ) ; SimpleModule module = new SimpleModule ( ) ; module . addSerializer ( JsonObject . class , new JsonObjectSerializer ( ) ) ; module . addSerializer ( JsonArray . class , new JsonArraySerializer ( ) ) ; mapper . registerModule ( module ) ; prettyMapper . registerModule ( module ) ; } public static String encode ( Object obj ) throws EncodeException { try { return mapper . writeValueAsString ( obj ) ; } catch ( Exception e ) { throw new EncodeException ( "Failed to encode as JSON: " + e . getMessage ( ) ) ; } } public static String encodePrettily ( Object obj ) throws EncodeException { try { return prettyMapper . writeValueAsString ( obj ) ; } catch ( Exception e ) { throw new EncodeException ( "Failed to encode as JSON: " + e . getMessage ( ) ) ; } } public static < T > T decodeValue ( String str , Class < T > clazz ) throws DecodeException { try { return mapper . readValue ( str , clazz ) ; } catch ( Exception e ) { throw new DecodeException ( "Failed to decode:" + e . getMessage ( ) ) ; } } @ SuppressWarnings ( "unchecked" ) static Object checkAndCopy ( Object val , boolean copy ) { if ( val == null ) { } else if ( val instanceof Number && ! ( val instanceof BigDecimal ) ) { } else if ( val instanceof Boolean ) { } else if ( val instanceof String ) { } else if ( val instanceof CharSequence ) { val = val . toString ( ) ; } else if ( val instanceof JsonObject ) { if ( copy ) { val = ( ( JsonObject ) val ) . copy ( ) ; } } else if ( val instanceof JsonArray ) { if ( copy ) { val = ( ( JsonArray ) val ) . copy ( ) ; } } else if ( val instanceof Map ) { if ( copy ) { val = ( new JsonObject ( ( Map ) val ) ) . copy ( ) ; } else { val = new JsonObject ( ( Map ) val ) ; } } else if ( val instanceof List ) { if ( copy ) { val = ( new JsonArray ( ( List ) val ) ) . copy ( ) ; } else { val = new JsonArray ( ( List ) val ) ; } } else if ( val instanceof byte [ ] ) { val = Base64 . getEncoder ( ) . encodeToString ( ( byte [ ] ) val ) ; } else { throw new IllegalStateException ( "Illegal type in JsonObject: " + val . getClass ( ) ) ; } return val ; } private static class JsonObjectSerializer extends JsonSerializer < JsonObject > { @ Override public void serialize ( JsonObject value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { jgen . writeObject ( value . getMap ( ) ) ; } } private static class JsonArraySerializer extends JsonSerializer < JsonArray > { @ Override public void serialize ( JsonArray value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { jgen . writeObject ( value . getList ( ) ) ; } } }
package io . vertx . core . spi ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . WebSocketFrame ; public interface WebSocketFrameFactory { WebSocketFrame binaryFrame ( Buffer data , boolean isFinal ) ; WebSocketFrame textFrame ( String str , boolean isFinal ) ; WebSocketFrame continuationFrame ( Buffer data , boolean isFinal ) ; }
package io . vertx . core . spi ; import io . vertx . core . streams . Pump ; import io . vertx . core . streams . ReadStream ; import io . vertx . core . streams . WriteStream ; public interface PumpFactory { < T > Pump pump ( ReadStream < T > rs , WriteStream < T > ws ) ; < T > Pump pump ( ReadStream < T > rs , WriteStream < T > ws , int writeQueueMaxSize ) ; }
package io . vertx . core . spi ; import io . netty . buffer . ByteBuf ; import io . vertx . core . buffer . Buffer ; public interface BufferFactory { Buffer buffer ( int initialSizeHint ) ; Buffer buffer ( ) ; Buffer buffer ( String str ) ; Buffer buffer ( String str , String enc ) ; Buffer buffer ( byte [ ] bytes ) ; Buffer buffer ( ByteBuf byteBuffer ) ; }
package io . vertx . test . core ; import io . vertx . core . Vertx ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . HttpClientOptions ; import io . vertx . core . http . HttpMethod ; import io . vertx . core . http . HttpServerOptions ; import io . vertx . core . impl . FileResolver ; import io . vertx . core . impl . VertxInternal ; import org . junit . Test ; import java . io . File ; import java . util . concurrent . CountDownLatch ; public abstract class FileResolverTestBase extends VertxTestBase { protected FileResolver resolver ; protected String webRoot ; @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; resolver = new FileResolver ( vertx ) ; } @ Override protected void tearDown ( ) throws Exception { CountDownLatch latch = new CountDownLatch ( 1 ) ; resolver . close ( onSuccess ( res - > { latch . countDown ( ) ; } ) ) ; awaitLatch ( latch ) ; super . tearDown ( ) ; } @ Test public void testResolveNotExistFile ( ) { File file = resolver . resolveFile ( "doesnotexist.txt" ) ; assertFalse ( file . exists ( ) ) ; assertEquals ( "doesnotexist.txt" , file . getPath ( ) ) ; } @ Test public void testResolveNotExistDirectory ( ) { File file = resolver . resolveFile ( "somedir" ) ; assertFalse ( file . exists ( ) ) ; assertEquals ( "somedir" , file . getPath ( ) ) ; } @ Test public void testResolveNotExistFileInDirectory ( ) { File file = resolver . resolveFile ( "somedir/doesnotexist.txt" ) ; assertFalse ( file . exists ( ) ) ; assertEquals ( "somedir" + File . separator + "doesnotexist.txt" , file . getPath ( ) ) ; } @ Test public void testResolveFileFromClasspath ( ) throws Exception { for ( int i = 0 ; i < 2 ; i ++ ) { File file = resolver . resolveFile ( "afile.html" ) ; assertTrue ( file . exists ( ) ) ; assertTrue ( file . getPath ( ) . startsWith ( ".vertx" + File . separator + "file-cache-" ) ) ; assertFalse ( file . isDirectory ( ) ) ; assertEquals ( "<html><body>afile</body></html>" , readFile ( file ) ) ; } } @ Test public void testResolveFileFromClasspathDisableCaching ( ) throws Exception { System . setProperty ( FileResolver . DISABLE_FILE_CACHING_PROP_NAME , "true" ) ; resolver = new FileResolver ( vertx ) ; for ( int i = 0 ; i < 2 ; i ++ ) { File file = resolver . resolveFile ( "afile.html" ) ; assertTrue ( file . exists ( ) ) ; assertTrue ( file . getPath ( ) . startsWith ( ".vertx" + File . separator + "file-cache-" ) ) ; assertFalse ( file . isDirectory ( ) ) ; assertEquals ( "<html><body>afile</body></html>" , readFile ( file ) ) ; } } @ Test public void testResolveFileWithSpacesFromClasspath ( ) throws Exception { for ( int i = 0 ; i < 2 ; i ++ ) { File file = resolver . resolveFile ( "afile with spaces.html" ) ; assertTrue ( file . exists ( ) ) ; assertTrue ( file . getPath ( ) . startsWith ( ".vertx" + File . separator + "file-cache-" ) ) ; assertFalse ( file . isDirectory ( ) ) ; assertEquals ( "<html><body>afile with spaces</body></html>" , readFile ( file ) ) ; } } @ Test public void testResolveDirectoryFromClasspath ( ) throws Exception { for ( int i = 0 ; i < 2 ; i ++ ) { File file = resolver . resolveFile ( webRoot ) ; assertTrue ( file . exists ( ) ) ; assertTrue ( file . getPath ( ) . startsWith ( ".vertx" + File . separator + "file-cache-" ) ) ; assertTrue ( file . isDirectory ( ) ) ; } } @ Test public void testResolveFileInDirectoryFromClasspath ( ) throws Exception { for ( int i = 0 ; i < 2 ; i ++ ) { File file = resolver . resolveFile ( webRoot + "/somefile.html" ) ; assertTrue ( file . exists ( ) ) ; assertTrue ( file . getPath ( ) . startsWith ( ".vertx" + File . separator + "file-cache-" ) ) ; assertFalse ( file . isDirectory ( ) ) ; assertEquals ( "<html><body>blah</body></html>" , readFile ( file ) ) ; } } @ Test public void testResolveSubDirectoryFromClasspath ( ) throws Exception { for ( int i = 0 ; i < 2 ; i ++ ) { File file = resolver . resolveFile ( webRoot + "/subdir" ) ; assertTrue ( file . exists ( ) ) ; assertTrue ( file . getPath ( ) . startsWith ( ".vertx" + File . separator + "file-cache-" ) ) ; assertTrue ( file . isDirectory ( ) ) ; } } @ Test public void testResolveFileInSubDirectoryFromClasspath ( ) throws Exception { for ( int i = 0 ; i < 2 ; i ++ ) { File file = resolver . resolveFile ( webRoot + "/subdir/subfile.html" ) ; assertTrue ( file . exists ( ) ) ; assertTrue ( file . getPath ( ) . startsWith ( ".vertx" + File . separator + "file-cache-" ) ) ; assertFalse ( file . isDirectory ( ) ) ; assertEquals ( "<html><body>subfile</body></html>" , readFile ( file ) ) ; } } @ Test public void testRecursivelyUnpack ( ) throws Exception { File file = resolver . resolveFile ( webRoot + "/subdir" ) ; assertTrue ( file . exists ( ) ) ; File sub = new File ( new File ( file , "subdir2" ) , "subfile2.html" ) ; assertTrue ( sub . exists ( ) ) ; assertEquals ( "<html><body>subfile2</body></html>" , readFile ( sub ) ) ; } @ Test public void testRecursivelyUnpack2 ( ) throws Exception { File file = resolver . resolveFile ( webRoot + "/subdir" ) ; assertTrue ( file . exists ( ) ) ; File sub = new File ( new File ( file , "subdir2" ) , "subfile2.html" ) ; assertTrue ( sub . exists ( ) ) ; assertEquals ( "<html><body>subfile2</body></html>" , readFile ( sub ) ) ; } @ Test public void testDeleteCacheDir ( ) throws Exception { Vertx vertx2 = Vertx . vertx ( ) ; FileResolver resolver2 = new FileResolver ( vertx2 ) ; File file = resolver2 . resolveFile ( webRoot + "/somefile.html" ) ; assertTrue ( file . exists ( ) ) ; File cacheDir = file . getParentFile ( ) . getParentFile ( ) ; assertTrue ( cacheDir . exists ( ) ) ; resolver2 . close ( onSuccess ( res - > { assertFalse ( cacheDir . exists ( ) ) ; vertx2 . close ( res2 - > { testComplete ( ) ; } ) ; } ) ) ; await ( ) ; } @ Test public void testCacheDirDeletedOnVertxClose ( ) { VertxInternal vertx2 = ( VertxInternal ) Vertx . vertx ( ) ; File file = vertx2 . resolveFile ( webRoot + "/somefile.html" ) ; assertTrue ( file . exists ( ) ) ; File cacheDir = file . getParentFile ( ) . getParentFile ( ) ; assertTrue ( cacheDir . exists ( ) ) ; vertx2 . close ( onSuccess ( v - > { assertFalse ( cacheDir . exists ( ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testFileSystemReadFile ( ) { assertTrue ( vertx . fileSystem ( ) . existsBlocking ( "afile.html" ) ) ; assertFalse ( vertx . fileSystem ( ) . propsBlocking ( "afile.html" ) . isDirectory ( ) ) ; Buffer buffer = vertx . fileSystem ( ) . readFileBlocking ( "afile.html" ) ; assertNotNull ( buffer ) ; assertTrue ( buffer . toString ( ) . startsWith ( "<html><body>afile</body></html>" ) ) ; } @ Test public void testFileSystemReadDirectory ( ) { assertTrue ( vertx . fileSystem ( ) . existsBlocking ( "webroot" ) ) ; assertTrue ( vertx . fileSystem ( ) . propsBlocking ( "webroot" ) . isDirectory ( ) ) ; } @ Test public void testSendFileFromClasspath ( ) { vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( 8080 ) ) . requestHandler ( res - > { res . response ( ) . sendFile ( webRoot + "/somefile.html" ) ; } ) . listen ( onSuccess ( res - > { vertx . createHttpClient ( new HttpClientOptions ( ) ) . request ( HttpMethod . GET , 8080 , "localhost" , "/" , resp - > { resp . bodyHandler ( buff - > { assertTrue ( buff . toString ( ) . startsWith ( "<html><body>blah</body></html>" ) ) ; testComplete ( ) ; } ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } private String readFile ( File file ) { return vertx . fileSystem ( ) . readFileBlocking ( file . getAbsolutePath ( ) ) . toString ( ) ; } }
package io . vertx . core . spi ; import io . vertx . core . AsyncResult ; import io . vertx . core . Context ; import io . vertx . core . Handler ; import io . vertx . core . Vertx ; import io . vertx . core . VertxOptions ; public interface VertxFactory { Vertx vertx ( ) ; Vertx vertx ( VertxOptions options ) ; void clusteredVertx ( VertxOptions options , Handler < AsyncResult < Vertx > > resultHandler ) ; Context context ( ) ; }
package io . vertx . core . spi ; import io . vertx . core . Vertx ; import io . vertx . core . VertxOptions ; import io . vertx . core . metrics . MetricsOptions ; import io . vertx . core . spi . metrics . VertxMetrics ; public interface VertxMetricsFactory { VertxMetrics metrics ( Vertx vertx , VertxOptions options ) ; default MetricsOptions newOptions ( ) { return new MetricsOptions ( ) ; } }
package io . vertx . core . spi ; import io . vertx . core . Future ; public interface FutureFactory { < T > Future < T > future ( ) ; < T > Future < T > completedFuture ( ) ; < T > Future < T > completedFuture ( T result ) ; < T > Future < T > completedFuture ( Throwable t ) ; < T > Future < T > completedFuture ( String failureMessage , boolean failed ) ; }
package io . vertx . core . spi ; import io . vertx . core . AsyncResult ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . Verticle ; import io . vertx . core . Vertx ; public interface VerticleFactory { static String removePrefix ( String identifer ) { int pos = identifer . indexOf ( ':' ) ; if ( pos != - 1 ) { if ( pos == identifer . length ( ) - 1 ) { throw new IllegalArgumentException ( "Invalid identifier: " + identifer ) ; } return identifer . substring ( pos + 1 ) ; } else { return identifer ; } } default int order ( ) { return 0 ; } default boolean requiresResolve ( ) { return false ; } default void resolve ( String identifier , DeploymentOptions deploymentOptions , ClassLoader classLoader , Future < String > resolution ) { resolution . complete ( identifier ) ; } default void init ( Vertx vertx ) { } default void close ( ) { } String prefix ( ) ; Verticle createVerticle ( String verticleName , ClassLoader classLoader ) throws Exception ; }
package io . vertx . core . spi . metrics ; public interface Metrics { boolean isEnabled ( ) ; void close ( ) ; }
package io . vertx . core . spi . metrics ; import io . vertx . core . net . SocketAddress ; public interface NetworkMetrics < S > extends Metrics { void bytesRead ( S socketMetric , SocketAddress remoteAddress , long numberOfBytes ) ; void bytesWritten ( S socketMetric , SocketAddress remoteAddress , long numberOfBytes ) ; void exceptionOccurred ( S socketMetric , SocketAddress remoteAddress , Throwable t ) ; }
package io . vertx . core . spi . metrics ; import io . vertx . core . net . SocketAddress ; public interface TCPMetrics < S > extends NetworkMetrics < S > { S connected ( SocketAddress remoteAddress ) ; void disconnected ( S socketMetric , SocketAddress remoteAddress ) ; }
package io . vertx . core . spi . metrics ; import io . vertx . core . net . SocketAddress ; public interface DatagramSocketMetrics extends NetworkMetrics < Void > { void listening ( SocketAddress localAddress ) ; }
package io . vertx . core . spi . metrics ; import io . vertx . core . http . HttpClientRequest ; import io . vertx . core . http . HttpClientResponse ; import io . vertx . core . http . WebSocket ; import io . vertx . core . net . SocketAddress ; public interface HttpClientMetrics < R , W , S > extends TCPMetrics < S > { R requestBegin ( S socketMetric , SocketAddress localAddress , SocketAddress remoteAddress , HttpClientRequest request ) ; void responseEnd ( R requestMetric , HttpClientResponse response ) ; W connected ( S socketMetric , WebSocket webSocket ) ; void disconnected ( W webSocketMetric ) ; }
package io . vertx . core . spi . metrics ; import io . vertx . core . Verticle ; import io . vertx . core . datagram . DatagramSocket ; import io . vertx . core . datagram . DatagramSocketOptions ; import io . vertx . core . eventbus . EventBus ; import io . vertx . core . http . HttpClient ; import io . vertx . core . http . HttpClientOptions ; import io . vertx . core . http . HttpServer ; import io . vertx . core . http . HttpServerOptions ; import io . vertx . core . metrics . Measured ; import io . vertx . core . net . NetClient ; import io . vertx . core . net . NetClientOptions ; import io . vertx . core . net . NetServer ; import io . vertx . core . net . NetServerOptions ; import io . vertx . core . net . SocketAddress ; public interface VertxMetrics extends Metrics , Measured { void verticleDeployed ( Verticle verticle ) ; void verticleUndeployed ( Verticle verticle ) ; void timerCreated ( long id ) ; void timerEnded ( long id , boolean cancelled ) ; EventBusMetrics createMetrics ( EventBus eventBus ) ; HttpServerMetrics < ? , ? , ? > createMetrics ( HttpServer server , SocketAddress localAddress , HttpServerOptions options ) ; HttpClientMetrics < ? , ? , ? > createMetrics ( HttpClient client , HttpClientOptions options ) ; TCPMetrics < ? > createMetrics ( NetServer server , SocketAddress localAddress , NetServerOptions options ) ; TCPMetrics < ? > createMetrics ( NetClient client , NetClientOptions options ) ; DatagramSocketMetrics createMetrics ( DatagramSocket socket , DatagramSocketOptions options ) ; }
package io . vertx . test . core ; import org . junit . rules . TestRule ; import org . junit . runner . Description ; import org . junit . runners . model . Statement ; public class RepeatRule implements TestRule { private static class RepeatStatement extends Statement { private final int times ; private final Statement statement ; private RepeatStatement ( int times , Statement statement ) { this . times = times ; this . statement = statement ; } @ Override public void evaluate ( ) throws Throwable { for ( int i = 0 ; i < times ; i ++ ) { System . out . println ( "*** Iteration " + ( i + 1 ) + "/" + times + " of test" ) ; statement . evaluate ( ) ; } } } @ Override public Statement apply ( Statement statement , Description description ) { Statement result = statement ; Repeat repeat = description . getAnnotation ( Repeat . class ) ; if ( repeat != null ) { int times = repeat . times ( ) ; result = new RepeatStatement ( times , statement ) ; } return result ; } }
package io . vertx . core . spi . metrics ; import io . vertx . core . http . HttpServerRequest ; import io . vertx . core . http . HttpServerResponse ; import io . vertx . core . http . ServerWebSocket ; public interface HttpServerMetrics < R , W , S > extends TCPMetrics < S > { R requestBegin ( S socketMetric , HttpServerRequest request ) ; void responseEnd ( R requestMetric , HttpServerResponse response ) ; W upgrade ( R requestMetric , ServerWebSocket serverWebSocket ) ; W connected ( S socketMetric , ServerWebSocket serverWebSocket ) ; void disconnected ( W serverWebSocketMetric ) ; }
package io . vertx . core . spi . metrics ; import io . vertx . core . eventbus . ReplyFailure ; public interface EventBusMetrics < H > extends Metrics { H handlerRegistered ( String address , boolean replyHandler ) ; void handlerUnregistered ( H handler ) ; void beginHandleMessage ( H handler , boolean local ) ; void endHandleMessage ( H handler , Throwable failure ) ; void messageSent ( String address , boolean publish , boolean local , boolean remote ) ; void messageReceived ( String address , boolean publish , boolean local , int handlers ) ; void messageWritten ( String address , int numberOfBytes ) ; void messageRead ( String address , int numberOfBytes ) ; void replyFailure ( String address , ReplyFailure failure ) ; }
package io . vertx . core . spi . metrics ; import io . vertx . core . metrics . Measured ; public interface MetricsProvider extends Measured { Metrics getMetrics ( ) ; }
package io . vertx . core . spi . logging ; public interface LogDelegate { boolean isInfoEnabled ( ) ; boolean isDebugEnabled ( ) ; boolean isTraceEnabled ( ) ; void fatal ( Object message ) ; void fatal ( Object message , Throwable t ) ; void error ( Object message ) ; void error ( Object message , Throwable t ) ; void warn ( Object message ) ; void warn ( Object message , Throwable t ) ; void info ( Object message ) ; void info ( Object message , Throwable t ) ; void debug ( Object message ) ; void debug ( Object message , Throwable t ) ; void trace ( Object message ) ; void trace ( Object message , Throwable t ) ; }
package io . vertx . core . spi . logging ; public interface LogDelegateFactory { LogDelegate createDelegate ( String name ) ; }
package io . vertx . core . spi . cluster ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; public interface AsyncMultiMap < K , V > { void add ( K k , V v , Handler < AsyncResult < Void > > completionHandler ) ; void get ( K k , Handler < AsyncResult < ChoosableIterable < V > > > resultHandler ) ; void remove ( K k , V v , Handler < AsyncResult < Boolean > > completionHandler ) ; void removeAllForValue ( V v , Handler < AsyncResult < Void > > completionHandler ) ; }
package io . vertx . core . spi . cluster ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . Vertx ; import io . vertx . core . shareddata . AsyncMap ; import io . vertx . core . shareddata . Counter ; import io . vertx . core . shareddata . Lock ; import java . util . List ; import java . util . Map ; public interface ClusterManager { void setVertx ( Vertx vertx ) ; < K , V > void getAsyncMultiMap ( String name , Handler < AsyncResult < AsyncMultiMap < K , V > > > resultHandler ) ; < K , V > void getAsyncMap ( String name , Handler < AsyncResult < AsyncMap < K , V > > > resultHandler ) ; < K , V > Map < K , V > getSyncMap ( String name ) ; void getLockWithTimeout ( String name , long timeout , Handler < AsyncResult < Lock > > resultHandler ) ; void getCounter ( String name , Handler < AsyncResult < Counter > > resultHandler ) ; String getNodeID ( ) ; List < String > getNodes ( ) ; void nodeListener ( NodeListener listener ) ; void join ( Handler < AsyncResult < Void > > resultHandler ) ; void leave ( Handler < AsyncResult < Void > > resultHandler ) ; boolean isActive ( ) ; }
package io . vertx . core . spi . cluster ; public interface NodeListener { void nodeAdded ( String nodeID ) ; void nodeLeft ( String nodeID ) ; }
package io . vertx . core . spi . cluster ; public interface ChoosableIterable < T > extends Iterable < T > { boolean isEmpty ( ) ; T choose ( ) ; }
@ Document ( fileName = "parsetools.adoc" ) package io . vertx . core . parsetools ; import io . vertx . docgen . Document ;
package io . vertx . test . core ; import io . vertx . core . Context ; import io . vertx . core . Vertx ; import org . junit . Test ; public class ContextTest extends VertxTestBase { @ Test public void testRunOnContext ( ) throws Exception { vertx . runOnContext ( v - > { Thread th = Thread . currentThread ( ) ; Context ctx = Vertx . currentContext ( ) ; ctx . runOnContext ( v2 - > { assertEquals ( th , Thread . currentThread ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { Context c = Vertx . currentContext ( ) ; assertEquals ( ctx , c ) ; } new Thread ( ) { public void run ( ) { ctx . runOnContext ( v3 - > { assertEquals ( th , Thread . currentThread ( ) ) ; assertEquals ( ctx , Vertx . currentContext ( ) ) ; testComplete ( ) ; } ) ; } } . start ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testNoContext ( ) throws Exception { assertNull ( Vertx . currentContext ( ) ) ; } class SomeObject { } @ Test public void testPutGetRemoveData ( ) throws Exception { SomeObject obj = new SomeObject ( ) ; vertx . runOnContext ( v - > { Context ctx = Vertx . currentContext ( ) ; ctx . put ( "foo" , obj ) ; ctx . runOnContext ( v2 - > { assertEquals ( obj , ctx . get ( "foo" ) ) ; assertTrue ( ctx . remove ( "foo" ) ) ; ctx . runOnContext ( v3 - > { assertNull ( ctx . get ( "foo" ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testGettingContextContextUnderContextAnotherInstanceShouldReturnDifferentContext ( ) throws Exception { Vertx other = Vertx . vertx ( ) ; Context context = vertx . getOrCreateContext ( ) ; context . runOnContext ( v - > { Context otherContext = other . getOrCreateContext ( ) ; assertNotSame ( otherContext , context ) ; testComplete ( ) ; } ) ; await ( ) ; } }
package io . vertx . core . parsetools ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . parsetools . impl . RecordParserImpl ; import java . util . Objects ; @ VertxGen public interface RecordParser extends Handler < Buffer > { void setOutput ( Handler < Buffer > output ) ; static RecordParser newDelimited ( String delim , Handler < Buffer > output ) { return RecordParserImpl . newDelimited ( delim , output ) ; } static RecordParser newDelimited ( Buffer delim , Handler < Buffer > output ) { return RecordParserImpl . newDelimited ( delim , output ) ; } static RecordParser newFixed ( int size , Handler < Buffer > output ) { return RecordParserImpl . newFixed ( size , output ) ; } void delimitedMode ( String delim ) ; void delimitedMode ( Buffer delim ) ; void fixedSizeMode ( int size ) ; void handle ( Buffer buffer ) ; }
package io . vertx . core . parsetools . impl ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . impl . Arguments ; import io . vertx . core . parsetools . RecordParser ; import java . util . Objects ; public class RecordParserImpl implements RecordParser { private Buffer buff ; private int pos ; private int start ; private int delimPos ; private boolean reset ; private boolean delimited ; private byte [ ] delim ; private int recordSize ; private Handler < Buffer > output ; private RecordParserImpl ( Handler < Buffer > output ) { this . output = output ; } public void setOutput ( Handler < Buffer > output ) { Objects . requireNonNull ( output , "output" ) ; this . output = output ; } public static Buffer latin1StringToBytes ( String str ) { byte [ ] bytes = new byte [ str . length ( ) ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; bytes [ i ] = ( byte ) ( c & 0xFF ) ; } return Buffer . buffer ( bytes ) ; } public static RecordParser newDelimited ( String delim , Handler < Buffer > output ) { return newDelimited ( latin1StringToBytes ( delim ) , output ) ; } public static RecordParser newDelimited ( Buffer delim , Handler < Buffer > output ) { RecordParserImpl ls = new RecordParserImpl ( output ) ; ls . delimitedMode ( delim ) ; return ls ; } public static RecordParser newFixed ( int size , Handler < Buffer > output ) { Arguments . require ( size > 0 , "Size must be > 0" ) ; RecordParserImpl ls = new RecordParserImpl ( output ) ; ls . fixedSizeMode ( size ) ; return ls ; } public void delimitedMode ( String delim ) { delimitedMode ( latin1StringToBytes ( delim ) ) ; } public void delimitedMode ( Buffer delim ) { Objects . requireNonNull ( delim , "delim" ) ; delimited = true ; this . delim = delim . getBytes ( ) ; delimPos = 0 ; reset = true ; } public void fixedSizeMode ( int size ) { Arguments . require ( size > 0 , "Size must be > 0" ) ; delimited = false ; recordSize = size ; reset = true ; } private void handleParsing ( ) { int len = buff . length ( ) ; do { reset = false ; if ( delimited ) { parseDelimited ( ) ; } else { parseFixed ( ) ; } } while ( reset ) ; if ( start == len ) { buff = null ; pos = 0 ; } else { buff = buff . getBuffer ( start , len ) ; pos = buff . length ( ) ; } start = 0 ; } private void parseDelimited ( ) { int len = buff . length ( ) ; output ( len ) ; } private void output ( int len ) { for ( ; pos < len && ! reset ; pos ++ ) { if ( buff . getByte ( pos ) == delim [ delimPos ] ) { delimPos ++ ; if ( delimPos == delim . length ) { outputwe ( ) ; start = pos + 1 ; delimPos = 0 ; } } else { if ( delimPos > 0 ) { pos -= delimPos ; delimPos = 0 ; } } } } private void outputwe ( ) { Buffer ret = buff . getBuffer ( start , pos - delim . length + 1 ) ; output . handle ( ret ) ; } private void parseFixed ( ) { int len = buff . length ( ) ; while ( len - start >= recordSize && ! reset ) { outpute ( ) ; int end = start + recordSize ; start = end ; pos = start - 1 ; } } private void outpute ( ) { int end = start + recordSize ; Buffer ret = buff . getBuffer ( start , end ) ; output . handle ( ret ) ; } public void handle ( Buffer buffer ) { if ( buff == null ) { buff = buffer ; } else { buff . appendBuffer ( buffer ) ; } handleParsing ( ) ; } }
package io . vertx . core . net ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . metrics . Measured ; import io . vertx . core . streams . ReadStream ; @ VertxGen public interface NetServer extends Measured { NetSocketStream connectStream ( ) ; NetServer connectHandler ( Handler < NetSocket > handler ) ; @ GenIgnore Handler < NetSocket > connectHandler ( ) ; @ Fluent NetServer listen ( ) ; @ Fluent NetServer listen ( Handler < AsyncResult < NetServer > > listenHandler ) ; @ Fluent NetServer listen ( int port , String host ) ; @ Fluent NetServer listen ( int port , String host , Handler < AsyncResult < NetServer > > listenHandler ) ; @ Fluent NetServer listen ( int port ) ; @ Fluent NetServer listen ( int port , Handler < AsyncResult < NetServer > > listenHandler ) ; void close ( ) ; void close ( Handler < AsyncResult < Void > > completionHandler ) ; int actualPort ( ) ; }
@ Document ( fileName = "net.adoc" ) package io . vertx . core . net ; import io . vertx . docgen . Document ;
package io . vertx . core . net ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import io . vertx . core . net . impl . SocketDefaults ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Objects ; import java . util . Set ; public abstract class TCPSSLOptions extends NetworkOptions { public static final boolean DEFAULT_TCP_NO_DELAY = true ; public static final boolean DEFAULT_TCP_KEEP_ALIVE = SocketDefaults . instance . isTcpKeepAlive ( ) ; public static final int DEFAULT_SO_LINGER = SocketDefaults . instance . getSoLinger ( ) ; public static final boolean DEFAULT_USE_POOLED_BUFFERS = false ; public static final boolean DEFAULT_SSL = false ; public static final int DEFAULT_IDLE_TIMEOUT = 0 ; private boolean tcpNoDelay ; private boolean tcpKeepAlive ; private int soLinger ; private boolean usePooledBuffers ; private int idleTimeout ; private boolean ssl ; private KeyCertOptions keyCertOptions ; private TrustOptions trustOptions ; private Set < String > enabledCipherSuites = new HashSet < > ( ) ; private ArrayList < String > crlPaths ; private ArrayList < Buffer > crlValues ; public TCPSSLOptions ( ) { super ( ) ; tcpNoDelay = DEFAULT_TCP_NO_DELAY ; tcpKeepAlive = DEFAULT_TCP_KEEP_ALIVE ; soLinger = DEFAULT_SO_LINGER ; usePooledBuffers = DEFAULT_USE_POOLED_BUFFERS ; idleTimeout = DEFAULT_IDLE_TIMEOUT ; ssl = DEFAULT_SSL ; crlPaths = new ArrayList < > ( ) ; crlValues = new ArrayList < > ( ) ; } public TCPSSLOptions ( TCPSSLOptions other ) { super ( other ) ; this . tcpNoDelay = other . isTcpNoDelay ( ) ; this . tcpKeepAlive = other . isTcpKeepAlive ( ) ; this . soLinger = other . getSoLinger ( ) ; this . usePooledBuffers = other . isUsePooledBuffers ( ) ; this . idleTimeout = other . getIdleTimeout ( ) ; this . ssl = other . isSsl ( ) ; this . keyCertOptions = other . getKeyCertOptions ( ) != null ? other . getKeyCertOptions ( ) . clone ( ) : null ; this . trustOptions = other . getTrustOptions ( ) != null ? other . getTrustOptions ( ) . clone ( ) : null ; this . enabledCipherSuites = other . getEnabledCipherSuites ( ) == null ? new HashSet < > ( ) : new HashSet < > ( other . getEnabledCipherSuites ( ) ) ; this . crlPaths = new ArrayList < > ( other . getCrlPaths ( ) ) ; this . crlValues = new ArrayList < > ( other . getCrlValues ( ) ) ; } public TCPSSLOptions ( JsonObject json ) { super ( json ) ; this . tcpNoDelay = json . getBoolean ( "tcpNoDelay" , DEFAULT_TCP_NO_DELAY ) ; this . tcpKeepAlive = json . getBoolean ( "tcpKeepAlive" , DEFAULT_TCP_KEEP_ALIVE ) ; this . soLinger = json . getInteger ( "soLinger" , DEFAULT_SO_LINGER ) ; this . usePooledBuffers = json . getBoolean ( "usePooledBuffers" , false ) ; this . idleTimeout = json . getInteger ( "idleTimeout" , 0 ) ; this . ssl = json . getBoolean ( "ssl" , false ) ; JsonObject keyCertJson = json . getJsonObject ( "keyStoreOptions" ) ; if ( keyCertJson != null ) { keyCertOptions = new JksOptions ( keyCertJson ) ; } keyCertJson = json . getJsonObject ( "pfxKeyCertOptions" ) ; if ( keyCertJson != null ) { keyCertOptions = new PfxOptions ( keyCertJson ) ; } keyCertJson = json . getJsonObject ( "pemKeyCertOptions" ) ; if ( keyCertJson != null ) { keyCertOptions = new PemKeyCertOptions ( keyCertJson ) ; } JsonObject trustOptions = json . getJsonObject ( "trustStoreOptions" ) ; if ( trustOptions != null ) { this . trustOptions = new JksOptions ( trustOptions ) ; } trustOptions = json . getJsonObject ( "pfxTrustOptions" ) ; if ( trustOptions != null ) { this . trustOptions = new PfxOptions ( trustOptions ) ; } trustOptions = json . getJsonObject ( "pemTrustOptions" ) ; if ( trustOptions != null ) { this . trustOptions = new PemTrustOptions ( trustOptions ) ; } JsonArray arr = json . getJsonArray ( "enabledCipherSuites" ) ; this . enabledCipherSuites = arr == null ? new HashSet < > ( ) : new HashSet < > ( arr . getList ( ) ) ; arr = json . getJsonArray ( "crlPaths" ) ; this . crlPaths = arr == null ? new ArrayList < > ( ) : new ArrayList < > ( arr . getList ( ) ) ; this . crlValues = new ArrayList < > ( ) ; arr = json . getJsonArray ( "crlValues" ) ; if ( arr != null ) { ( ( List < byte [ ] > ) arr . getList ( ) ) . stream ( ) . map ( Buffer : : buffer ) . forEach ( crlValues : : add ) ; } } public boolean isTcpNoDelay ( ) { return tcpNoDelay ; } public TCPSSLOptions setTcpNoDelay ( boolean tcpNoDelay ) { this . tcpNoDelay = tcpNoDelay ; return this ; } public boolean isTcpKeepAlive ( ) { return tcpKeepAlive ; } public TCPSSLOptions setTcpKeepAlive ( boolean tcpKeepAlive ) { this . tcpKeepAlive = tcpKeepAlive ; return this ; } public int getSoLinger ( ) { return soLinger ; } public TCPSSLOptions setSoLinger ( int soLinger ) { if ( soLinger < 0 ) { throw new IllegalArgumentException ( "soLinger must be >= 0" ) ; } this . soLinger = soLinger ; return this ; } public boolean isUsePooledBuffers ( ) { return usePooledBuffers ; } public TCPSSLOptions setUsePooledBuffers ( boolean usePooledBuffers ) { this . usePooledBuffers = usePooledBuffers ; return this ; } public TCPSSLOptions setIdleTimeout ( int idleTimeout ) { if ( idleTimeout < 0 ) { throw new IllegalArgumentException ( "idleTimeout must be >= 0" ) ; } this . idleTimeout = idleTimeout ; return this ; } public int getIdleTimeout ( ) { return idleTimeout ; } public boolean isSsl ( ) { return ssl ; } public TCPSSLOptions setSsl ( boolean ssl ) { this . ssl = ssl ; return this ; } public KeyCertOptions getKeyCertOptions ( ) { return keyCertOptions ; } public TCPSSLOptions setKeyStoreOptions ( JksOptions options ) { this . keyCertOptions = options ; return this ; } public TCPSSLOptions setPfxKeyCertOptions ( PfxOptions options ) { this . keyCertOptions = options ; return this ; } public TCPSSLOptions setPemKeyCertOptions ( PemKeyCertOptions options ) { this . keyCertOptions = options ; return this ; } public TrustOptions getTrustOptions ( ) { return trustOptions ; } public TCPSSLOptions setTrustStoreOptions ( JksOptions options ) { this . trustOptions = options ; return this ; } public TCPSSLOptions setPfxTrustOptions ( PfxOptions options ) { this . trustOptions = options ; return this ; } public TCPSSLOptions setPemTrustOptions ( PemTrustOptions options ) { this . trustOptions = options ; return this ; } public TCPSSLOptions addEnabledCipherSuite ( String suite ) { enabledCipherSuites . add ( suite ) ; return this ; } public Set < String > getEnabledCipherSuites ( ) { return enabledCipherSuites ; } public List < String > getCrlPaths ( ) { return crlPaths ; } public TCPSSLOptions addCrlPath ( String crlPath ) throws NullPointerException { Objects . requireNonNull ( crlPath , "No null crl accepted" ) ; crlPaths . add ( crlPath ) ; return this ; } public List < Buffer > getCrlValues ( ) { return crlValues ; } public TCPSSLOptions addCrlValue ( Buffer crlValue ) throws NullPointerException { Objects . requireNonNull ( crlValue , "No null crl accepted" ) ; crlValues . add ( crlValue ) ; return this ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof TCPSSLOptions ) ) return false ; if ( ! super . equals ( o ) ) return false ; TCPSSLOptions that = ( TCPSSLOptions ) o ; if ( idleTimeout != that . idleTimeout ) return false ; if ( soLinger != that . soLinger ) return false ; if ( ssl != that . ssl ) return false ; if ( tcpKeepAlive != that . tcpKeepAlive ) return false ; if ( tcpNoDelay != that . tcpNoDelay ) return false ; if ( usePooledBuffers != that . usePooledBuffers ) return false ; if ( crlPaths != null ? ! crlPaths . equals ( that . crlPaths ) : that . crlPaths != null ) return false ; if ( crlValues != null ? ! crlValues . equals ( that . crlValues ) : that . crlValues != null ) return false ; if ( enabledCipherSuites != null ? ! enabledCipherSuites . equals ( that . enabledCipherSuites ) : that . enabledCipherSuites != null ) return false ; if ( keyCertOptions != null ? ! keyCertOptions . equals ( that . keyCertOptions ) : that . keyCertOptions != null ) return false ; if ( trustOptions != null ? ! trustOptions . equals ( that . trustOptions ) : that . trustOptions != null ) return false ; return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + ( tcpNoDelay ? 1 : 0 ) ; result = 31 * result + ( tcpKeepAlive ? 1 : 0 ) ; result = 31 * result + soLinger ; result = 31 * result + ( usePooledBuffers ? 1 : 0 ) ; result = 31 * result + idleTimeout ; result = 31 * result + ( ssl ? 1 : 0 ) ; result = 31 * result + ( keyCertOptions != null ? keyCertOptions . hashCode ( ) : 0 ) ; result = 31 * result + ( trustOptions != null ? trustOptions . hashCode ( ) : 0 ) ; result = 31 * result + ( enabledCipherSuites != null ? enabledCipherSuites . hashCode ( ) : 0 ) ; result = 31 * result + ( crlPaths != null ? crlPaths . hashCode ( ) : 0 ) ; result = 31 * result + ( crlValues != null ? crlValues . hashCode ( ) : 0 ) ; return result ; } }
package io . vertx . core . net ; import io . vertx . core . impl . Arguments ; import io . vertx . core . json . JsonObject ; import io . vertx . core . net . impl . SocketDefaults ; public abstract class NetworkOptions { public static final int DEFAULT_SEND_BUFFER_SIZE = SocketDefaults . instance . getTcpSendBufferSize ( ) ; public static final int DEFAULT_RECEIVE_BUFFER_SIZE = SocketDefaults . instance . getTcpReceiveBufferSize ( ) ; public static final int DEFAULT_TRAFFIC_CLASS = SocketDefaults . instance . getTrafficClass ( ) ; public static final boolean DEFAULT_REUSE_ADDRESS = true ; private int sendBufferSize ; private int receiveBufferSize ; private int trafficClass ; private boolean reuseAddress ; public NetworkOptions ( ) { sendBufferSize = DEFAULT_SEND_BUFFER_SIZE ; receiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE ; reuseAddress = DEFAULT_REUSE_ADDRESS ; trafficClass = DEFAULT_TRAFFIC_CLASS ; } public NetworkOptions ( NetworkOptions other ) { this . sendBufferSize = other . getSendBufferSize ( ) ; this . receiveBufferSize = other . getReceiveBufferSize ( ) ; this . reuseAddress = other . isReuseAddress ( ) ; this . trafficClass = other . getTrafficClass ( ) ; } public NetworkOptions ( JsonObject json ) { this . sendBufferSize = json . getInteger ( "sendBufferSize" , DEFAULT_SEND_BUFFER_SIZE ) ; this . receiveBufferSize = json . getInteger ( "receiveBufferSize" , DEFAULT_RECEIVE_BUFFER_SIZE ) ; this . reuseAddress = json . getBoolean ( "reuseAddress" , DEFAULT_REUSE_ADDRESS ) ; this . trafficClass = json . getInteger ( "trafficClass" , DEFAULT_TRAFFIC_CLASS ) ; } public int getSendBufferSize ( ) { return sendBufferSize ; } public NetworkOptions setSendBufferSize ( int sendBufferSize ) { Arguments . require ( sendBufferSize > 0 , "sendBufferSize must be > 0" ) ; this . sendBufferSize = sendBufferSize ; return this ; } public int getReceiveBufferSize ( ) { return receiveBufferSize ; } public NetworkOptions setReceiveBufferSize ( int receiveBufferSize ) { Arguments . require ( receiveBufferSize > 0 , "receiveBufferSize must be > 0" ) ; this . receiveBufferSize = receiveBufferSize ; return this ; } public boolean isReuseAddress ( ) { return reuseAddress ; } public NetworkOptions setReuseAddress ( boolean reuseAddress ) { this . reuseAddress = reuseAddress ; return this ; } public int getTrafficClass ( ) { return trafficClass ; } public NetworkOptions setTrafficClass ( int trafficClass ) { Arguments . requireInRange ( trafficClass , 0 , 255 , "trafficClass tc must be 0 <= tc <= 255" ) ; this . trafficClass = trafficClass ; return this ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof NetworkOptions ) ) return false ; NetworkOptions that = ( NetworkOptions ) o ; if ( receiveBufferSize != that . receiveBufferSize ) return false ; if ( reuseAddress != that . reuseAddress ) return false ; if ( sendBufferSize != that . sendBufferSize ) return false ; if ( trafficClass != that . trafficClass ) return false ; return true ; } @ Override public int hashCode ( ) { int result = sendBufferSize ; result = 31 * result + receiveBufferSize ; result = 31 * result + trafficClass ; result = 31 * result + ( reuseAddress ? 1 : 0 ) ; return result ; } }
package io . vertx . core . net ; import io . vertx . core . json . JsonObject ; public abstract class ClientOptionsBase extends TCPSSLOptions { public static final int DEFAULT_CONNECT_TIMEOUT = 60000 ; public static final boolean DEFAULT_TRUST_ALL = false ; private int connectTimeout ; private boolean trustAll ; public ClientOptionsBase ( ) { super ( ) ; this . connectTimeout = DEFAULT_CONNECT_TIMEOUT ; this . trustAll = DEFAULT_TRUST_ALL ; } public ClientOptionsBase ( ClientOptionsBase other ) { super ( other ) ; this . connectTimeout = other . getConnectTimeout ( ) ; this . trustAll = other . isTrustAll ( ) ; } public ClientOptionsBase ( JsonObject json ) { super ( json ) ; this . connectTimeout = json . getInteger ( "connectTimeout" , DEFAULT_CONNECT_TIMEOUT ) ; this . trustAll = json . getBoolean ( "trustAll" , DEFAULT_TRUST_ALL ) ; } public boolean isTrustAll ( ) { return trustAll ; } public ClientOptionsBase setTrustAll ( boolean trustAll ) { this . trustAll = trustAll ; return this ; } public int getConnectTimeout ( ) { return connectTimeout ; } public ClientOptionsBase setConnectTimeout ( int connectTimeout ) { if ( connectTimeout < 0 ) { throw new IllegalArgumentException ( "connectTimeout must be >= 0" ) ; } this . connectTimeout = connectTimeout ; return this ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof ClientOptionsBase ) ) return false ; if ( ! super . equals ( o ) ) return false ; ClientOptionsBase that = ( ClientOptionsBase ) o ; if ( connectTimeout != that . connectTimeout ) return false ; if ( trustAll != that . trustAll ) return false ; return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + connectTimeout ; result = 31 * result + ( trustAll ? 1 : 0 ) ; return result ; } }
package io . vertx . core . net ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . impl . Arguments ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import java . util . ArrayList ; import java . util . Base64 ; import java . util . List ; import java . util . Objects ; @ DataObject public class PemTrustOptions implements TrustOptions , Cloneable { private ArrayList < String > certPaths ; private ArrayList < Buffer > certValues ; public PemTrustOptions ( ) { super ( ) ; this . certPaths = new ArrayList < > ( ) ; this . certValues = new ArrayList < > ( ) ; } public PemTrustOptions ( PemTrustOptions other ) { super ( ) ; this . certPaths = new ArrayList < > ( other . getCertPaths ( ) ) ; this . certValues = new ArrayList < > ( other . getCertValues ( ) ) ; } public PemTrustOptions ( JsonObject json ) { super ( ) ; this . certPaths = new ArrayList < > ( ) ; this . certValues = new ArrayList < > ( ) ; for ( Object certPath : json . getJsonArray ( "certPaths" , new JsonArray ( ) ) ) { certPaths . add ( ( String ) certPath ) ; } for ( Object certValue : json . getJsonArray ( "certValues" , new JsonArray ( ) ) ) { certValues . add ( Buffer . buffer ( Base64 . getDecoder ( ) . decode ( ( String ) certValue ) ) ) ; } } public List < String > getCertPaths ( ) { return certPaths ; } public PemTrustOptions addCertPath ( String certPath ) throws NullPointerException { Objects . requireNonNull ( certPath , "No null certificate accepted" ) ; Arguments . require ( ! certPath . isEmpty ( ) , "No empty certificate path accepted" ) ; certPaths . add ( certPath ) ; return this ; } public List < Buffer > getCertValues ( ) { return certValues ; } public PemTrustOptions addCertValue ( Buffer certValue ) throws NullPointerException { Objects . requireNonNull ( certValue , "No null certificate accepted" ) ; certValues . add ( certValue ) ; return this ; } @ Override public PemTrustOptions clone ( ) { return new PemTrustOptions ( this ) ; } }
package io . vertx . core . net ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . json . JsonObject ; @ DataObject public class PemKeyCertOptions implements KeyCertOptions , Cloneable { private String keyPath ; private Buffer keyValue ; private String certPath ; private Buffer certValue ; public PemKeyCertOptions ( ) { super ( ) ; } public PemKeyCertOptions ( PemKeyCertOptions other ) { super ( ) ; this . keyPath = other . getKeyPath ( ) ; this . keyValue = other . getKeyValue ( ) ; this . certPath = other . getCertPath ( ) ; this . certValue = other . getCertValue ( ) ; } public PemKeyCertOptions ( JsonObject json ) { super ( ) ; keyPath = json . getString ( "keyPath" ) ; byte [ ] keyValue = json . getBinary ( "keyValue" ) ; this . keyValue = keyValue != null ? Buffer . buffer ( keyValue ) : null ; certPath = json . getString ( "certPath" ) ; byte [ ] certValue = json . getBinary ( "certValue" ) ; this . certValue = certValue != null ? Buffer . buffer ( certValue ) : null ; } public String getKeyPath ( ) { return keyPath ; } public PemKeyCertOptions setKeyPath ( String keyPath ) { this . keyPath = keyPath ; return this ; } public String getCertPath ( ) { return certPath ; } public Buffer getKeyValue ( ) { return keyValue ; } public PemKeyCertOptions setKeyValue ( Buffer keyValue ) { this . keyValue = keyValue ; return this ; } public PemKeyCertOptions setCertPath ( String certPath ) { this . certPath = certPath ; return this ; } public Buffer getCertValue ( ) { return certValue ; } public PemKeyCertOptions setCertValue ( Buffer certValue ) { this . certValue = certValue ; return this ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof PemKeyCertOptions ) ) { return false ; } PemKeyCertOptions that = ( PemKeyCertOptions ) o ; if ( keyPath != null ? ! keyPath . equals ( that . keyPath ) : that . keyPath != null ) { return false ; } if ( keyValue != null ? ! keyValue . equals ( that . keyValue ) : that . keyValue != null ) { return false ; } if ( certPath != null ? ! certPath . equals ( that . certPath ) : that . certPath != null ) { return false ; } if ( certValue != null ? ! certValue . equals ( that . certValue ) : that . certValue != null ) { return false ; } return true ; } @ Override public int hashCode ( ) { int result = 1 ; result += 31 * result + ( keyPath != null ? keyPath . hashCode ( ) : 0 ) ; result += 31 * result + ( keyValue != null ? keyValue . hashCode ( ) : 0 ) ; result += 31 * result + ( certPath != null ? certPath . hashCode ( ) : 0 ) ; result += 31 * result + ( certValue != null ? certValue . hashCode ( ) : 0 ) ; return result ; } @ Override public PemKeyCertOptions clone ( ) { return new PemKeyCertOptions ( this ) ; } }
package io . vertx . core . net ; public @ interface Document { String fileName ( ) ; }
package io . vertx . test . core ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Vertx ; import io . vertx . core . VertxOptions ; import io . vertx . core . impl . Deployment ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . json . JsonObject ; import io . vertx . core . spi . cluster . ClusterManager ; import io . vertx . test . fakecluster . FakeClusterManager ; import org . junit . Test ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; public class HATest extends VertxTestBase { protected ClusterManager getClusterManager ( ) { return new FakeClusterManager ( ) ; } @ Test public void testSimpleFailover ( ) throws Exception { startNodes ( 2 , new VertxOptions ( ) . setHAEnabled ( true ) ) ; DeploymentOptions options = new DeploymentOptions ( ) . setHa ( true ) ; JsonObject config = new JsonObject ( ) . put ( "foo" , "bar" ) ; options . setConfig ( config ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; vertices [ 0 ] . deployVerticle ( "java:" + HAVerticle1 . class . getName ( ) , options , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertEquals ( 1 , vertices [ 0 ] . deploymentIDs ( ) . size ( ) ) ; assertEquals ( 0 , vertices [ 1 ] . deploymentIDs ( ) . size ( ) ) ; latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; kill ( 0 ) ; waitUntil ( ( ) - > vertices [ 1 ] . deploymentIDs ( ) . size ( ) == 1 ) ; checkDeploymentExists ( 1 , "java:" + HAVerticle1 . class . getName ( ) , options ) ; } @ Test public void testQuorum ( ) throws Exception { Vertx vertx1 = startVertx ( 2 ) ; DeploymentOptions options = new DeploymentOptions ( ) . setHa ( true ) ; JsonObject config = new JsonObject ( ) . put ( "foo" , "bar" ) ; options . setConfig ( config ) ; vertx1 . deployVerticle ( "java:" + HAVerticle1 . class . getName ( ) , options , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( vertx1 . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; testComplete ( ) ; } ) ; waitUntil ( ( ) - > vertx1 . deploymentIDs ( ) . isEmpty ( ) ) ; Vertx vertx2 = startVertx ( 2 ) ; await ( ) ; closeVertices ( vertx1 , vertx2 ) ; } @ Test public void testQuorumLost ( ) throws Exception { Vertx vertx1 = startVertx ( 3 ) ; Vertx vertx2 = startVertx ( 3 ) ; Vertx vertx3 = startVertx ( 3 ) ; DeploymentOptions options = new DeploymentOptions ( ) . setHa ( true ) ; JsonObject config = new JsonObject ( ) . put ( "foo" , "bar" ) ; options . setConfig ( config ) ; vertx1 . deployVerticle ( "java:" + HAVerticle1 . class . getName ( ) , options , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( vertx1 . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; ; } ) ; vertx2 . deployVerticle ( "java:" + HAVerticle2 . class . getName ( ) , options , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( vertx2 . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; ; } ) ; waitUntil ( ( ) - > vertx1 . deploymentIDs ( ) . size ( ) == 1 && vertx2 . deploymentIDs ( ) . size ( ) == 1 ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; vertx3 . close ( ar - > { latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; waitUntil ( ( ) - > vertx1 . deploymentIDs ( ) . isEmpty ( ) && vertx2 . deploymentIDs ( ) . isEmpty ( ) ) ; Vertx vertx4 = startVertx ( 3 ) ; waitUntil ( ( ) - > vertx1 . deploymentIDs ( ) . size ( ) == 1 && vertx2 . deploymentIDs ( ) . size ( ) == 1 ) ; closeVertices ( vertx1 , vertx2 , vertx4 ) ; } @ Test public void testCleanCloseNoFailover ( ) throws Exception { Vertx vertx1 = startVertx ( ) ; Vertx vertx2 = startVertx ( ) ; DeploymentOptions options = new DeploymentOptions ( ) . setHa ( true ) ; JsonObject config = new JsonObject ( ) . put ( "foo" , "bar" ) ; options . setConfig ( config ) ; CountDownLatch deployLatch = new CountDownLatch ( 1 ) ; vertx2 . deployVerticle ( "java:" + HAVerticle1 . class . getName ( ) , options , ar - > { assertTrue ( ar . succeeded ( ) ) ; deployLatch . countDown ( ) ; } ) ; awaitLatch ( deployLatch ) ; ( ( VertxInternal ) vertx1 ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { fail ( "Should not be called" ) ; } ) ; vertx2 . close ( ar - > { vertx . setTimer ( 500 , tid - > { testComplete ( ) ; } ) ; } ) ; await ( ) ; closeVertices ( vertx1 ) ; } @ Test public void testFailureInFailover ( ) throws Exception { Vertx vertx1 = startVertx ( ) ; Vertx vertx2 = startVertx ( ) ; Vertx vertx3 = startVertx ( ) ; CountDownLatch latch1 = new CountDownLatch ( 1 ) ; vertx1 . deployVerticle ( "java:" + HAVerticle1 . class . getName ( ) , new DeploymentOptions ( ) . setHa ( true ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( vertx1 . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; latch1 . countDown ( ) ; } ) ; awaitLatch ( latch1 ) ; ( ( VertxInternal ) vertx2 ) . failDuringFailover ( true ) ; ( ( VertxInternal ) vertx3 ) . failDuringFailover ( true ) ; CountDownLatch latch2 = new CountDownLatch ( 1 ) ; ( ( VertxInternal ) vertx2 ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { assertFalse ( succeeded ) ; latch2 . countDown ( ) ; } ) ; ( ( VertxInternal ) vertx3 ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { assertFalse ( succeeded ) ; latch2 . countDown ( ) ; } ) ; ( ( VertxInternal ) vertx1 ) . simulateKill ( ) ; awaitLatch ( latch2 ) ; assertTrue ( vertx2 . deploymentIDs ( ) . isEmpty ( ) ) ; assertTrue ( vertx3 . deploymentIDs ( ) . isEmpty ( ) ) ; ( ( VertxInternal ) vertx2 ) . failDuringFailover ( false ) ; CountDownLatch latch3 = new CountDownLatch ( 1 ) ; ( ( VertxInternal ) vertx2 ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { assertTrue ( succeeded ) ; latch3 . countDown ( ) ; } ) ; ( ( VertxInternal ) vertx3 ) . simulateKill ( ) ; awaitLatch ( latch3 ) ; waitUntil ( ( ) - > vertx2 . deploymentIDs ( ) . size ( ) == 1 ) ; closeVertices ( vertx1 , vertx2 , vertx3 ) ; } @ Test public void testHaGroups ( ) throws Exception { Vertx vertx1 = startVertx ( "group1" , 1 ) ; Vertx vertx2 = startVertx ( "group1" , 1 ) ; Vertx vertx3 = startVertx ( "group2" , 1 ) ; Vertx vertx4 = startVertx ( "group2" , 1 ) ; CountDownLatch latch1 = new CountDownLatch ( 2 ) ; vertx1 . deployVerticle ( "java:" + HAVerticle1 . class . getName ( ) , new DeploymentOptions ( ) . setHa ( true ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( vertx1 . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; latch1 . countDown ( ) ; } ) ; vertx3 . deployVerticle ( "java:" + HAVerticle2 . class . getName ( ) , new DeploymentOptions ( ) . setHa ( true ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( vertx3 . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; latch1 . countDown ( ) ; } ) ; awaitLatch ( latch1 ) ; CountDownLatch latch2 = new CountDownLatch ( 1 ) ; ( ( VertxInternal ) vertx1 ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { fail ( "Should not failover here 1" ) ; } ) ; ( ( VertxInternal ) vertx2 ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { fail ( "Should not failover here 2" ) ; } ) ; ( ( VertxInternal ) vertx4 ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { assertTrue ( succeeded ) ; latch2 . countDown ( ) ; } ) ; ( ( VertxInternal ) vertx3 ) . simulateKill ( ) ; awaitLatch ( latch2 ) ; assertTrue ( vertx4 . deploymentIDs ( ) . size ( ) == 1 ) ; CountDownLatch latch3 = new CountDownLatch ( 1 ) ; ( ( VertxInternal ) vertx2 ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { assertTrue ( succeeded ) ; latch3 . countDown ( ) ; } ) ; ( ( VertxInternal ) vertx4 ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { fail ( "Should not failover here 4" ) ; } ) ; ( ( VertxInternal ) vertx1 ) . simulateKill ( ) ; awaitLatch ( latch3 ) ; assertTrue ( vertx2 . deploymentIDs ( ) . size ( ) == 1 ) ; closeVertices ( vertx1 , vertx2 , vertx3 , vertx4 ) ; } @ Test public void testNoFailoverToNonHANode ( ) throws Exception { Vertx vertx1 = startVertx ( ) ; Vertx vertx2 = startVertx ( null , 0 , false ) ; CountDownLatch latch1 = new CountDownLatch ( 1 ) ; vertx1 . deployVerticle ( "java:" + HAVerticle1 . class . getName ( ) , new DeploymentOptions ( ) . setHa ( true ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( vertx1 . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; latch1 . countDown ( ) ; } ) ; awaitLatch ( latch1 ) ; ( ( VertxInternal ) vertx2 ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { fail ( "Should not failover here 2" ) ; } ) ; ( ( VertxInternal ) vertx1 ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { fail ( "Should not failover here 1" ) ; } ) ; ( ( VertxInternal ) vertx1 ) . simulateKill ( ) ; vertx2 . close ( ar - > { vertx . setTimer ( 500 , tid - > { testComplete ( ) ; } ) ; } ) ; await ( ) ; closeVertices ( vertx2 ) ; } @ Test public void testNonHADeployments ( ) throws Exception { Vertx vertx1 = startVertx ( ) ; Vertx vertx2 = startVertx ( ) ; CountDownLatch latch1 = new CountDownLatch ( 2 ) ; vertx2 . deployVerticle ( "java:" + HAVerticle1 . class . getName ( ) , new DeploymentOptions ( ) . setHa ( true ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( vertx2 . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; latch1 . countDown ( ) ; } ) ; vertx2 . deployVerticle ( "java:" + HAVerticle2 . class . getName ( ) , new DeploymentOptions ( ) . setHa ( false ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( vertx2 . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; latch1 . countDown ( ) ; } ) ; awaitLatch ( latch1 ) ; CountDownLatch latch2 = new CountDownLatch ( 1 ) ; ( ( VertxInternal ) vertx1 ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { assertTrue ( succeeded ) ; latch2 . countDown ( ) ; } ) ; ( ( VertxInternal ) vertx2 ) . simulateKill ( ) ; awaitLatch ( latch2 ) ; assertTrue ( vertx1 . deploymentIDs ( ) . size ( ) == 1 ) ; String depID = vertx1 . deploymentIDs ( ) . iterator ( ) . next ( ) ; assertTrue ( ( ( VertxInternal ) vertx1 ) . getDeployment ( depID ) . verticleIdentifier ( ) . equals ( "java:" + HAVerticle1 . class . getName ( ) ) ) ; closeVertices ( vertx1 , vertx2 ) ; } @ Test public void testCloseRemovesFromCluster ( ) throws Exception { Vertx vertx1 = startVertx ( ) ; Vertx vertx2 = startVertx ( ) ; Vertx vertx3 = startVertx ( ) ; CountDownLatch latch1 = new CountDownLatch ( 1 ) ; vertx3 . deployVerticle ( "java:" + HAVerticle1 . class . getName ( ) , new DeploymentOptions ( ) . setHa ( true ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( vertx3 . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; latch1 . countDown ( ) ; } ) ; awaitLatch ( latch1 ) ; CountDownLatch latch2 = new CountDownLatch ( 1 ) ; vertx2 . close ( ar - > { ( ( VertxInternal ) vertx1 ) . failoverCompleteHandler ( ( nodeID , haInfo , succeeded ) - > { assertTrue ( succeeded ) ; latch2 . countDown ( ) ; } ) ; ( ( VertxInternal ) vertx3 ) . simulateKill ( ) ; } ) ; awaitLatch ( latch2 ) ; assertTrue ( vertx1 . deploymentIDs ( ) . size ( ) == 1 ) ; String depID = vertx1 . deploymentIDs ( ) . iterator ( ) . next ( ) ; assertTrue ( ( ( VertxInternal ) vertx1 ) . getDeployment ( depID ) . verticleIdentifier ( ) . equals ( "java:" + HAVerticle1 . class . getName ( ) ) ) ; closeVertices ( vertx1 , vertx3 ) ; } @ Test public void testQuorumWithHaGroups ( ) throws Exception { Vertx vertx1 = startVertx ( "group1" , 2 ) ; Vertx vertx2 = startVertx ( "group2" , 2 ) ; vertx1 . deployVerticle ( "java:" + HAVerticle1 . class . getName ( ) , new DeploymentOptions ( ) . setHa ( true ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( vertx1 . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; } ) ; Thread . sleep ( 500 ) ; assertTrue ( vertx1 . deploymentIDs ( ) . isEmpty ( ) ) ; Vertx vertx3 = startVertx ( "group1" , 2 ) ; waitUntil ( ( ) - > vertx1 . deploymentIDs ( ) . size ( ) == 1 ) ; vertx2 . deployVerticle ( "java:" + HAVerticle1 . class . getName ( ) , new DeploymentOptions ( ) . setHa ( true ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( vertx2 . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; } ) ; Thread . sleep ( 500 ) ; assertTrue ( vertx2 . deploymentIDs ( ) . isEmpty ( ) ) ; Vertx vertx4 = startVertx ( "group2" , 2 ) ; waitUntil ( ( ) - > vertx2 . deploymentIDs ( ) . size ( ) == 1 ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; vertx4 . close ( ar - > { latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; waitUntil ( ( ) - > vertx2 . deploymentIDs ( ) . isEmpty ( ) ) ; assertTrue ( vertx1 . deploymentIDs ( ) . size ( ) == 1 ) ; CountDownLatch latch2 = new CountDownLatch ( 1 ) ; vertx3 . close ( ar - > { latch2 . countDown ( ) ; } ) ; awaitLatch ( latch2 ) ; waitUntil ( ( ) - > vertx1 . deploymentIDs ( ) . isEmpty ( ) ) ; closeVertices ( vertx1 , vertx2 ) ; } protected Vertx startVertx ( ) throws Exception { return startVertx ( null , 1 ) ; } protected Vertx startVertx ( int quorumSize ) throws Exception { return startVertx ( null , quorumSize ) ; } protected Vertx startVertx ( String haGroup , int quorumSize ) throws Exception { return startVertx ( haGroup , quorumSize , true ) ; } protected Vertx startVertx ( String haGroup , int quorumSize , boolean ha ) throws Exception { VertxOptions options = new VertxOptions ( ) . setHAEnabled ( ha ) . setClustered ( true ) . setClusterHost ( "localhost" ) . setClusterManager ( getClusterManager ( ) ) ; if ( ha ) { options . setQuorumSize ( quorumSize ) ; if ( haGroup != null ) { options . setHAGroup ( haGroup ) ; } } CountDownLatch latch = new CountDownLatch ( 1 ) ; AtomicReference < Vertx > vertxRef = new AtomicReference < > ( ) ; Vertx . clusteredVertx ( options , onSuccess ( vertx - > { vertxRef . set ( vertx ) ; latch . countDown ( ) ; } ) ) ; latch . await ( 2 , TimeUnit . MINUTES ) ; return vertxRef . get ( ) ; } protected void checkDeploymentExists ( int pos , String verticleName , DeploymentOptions options ) { VertxInternal vi = ( VertxInternal ) vertices [ pos ] ; for ( String deploymentID : vi . deploymentIDs ( ) ) { Deployment dep = vi . getDeployment ( deploymentID ) ; if ( verticleName . equals ( dep . verticleIdentifier ( ) ) && options . equals ( dep . deploymentOptions ( ) ) ) { return ; } } fail ( "Can't find deployment for verticleName: " + verticleName + " on node " + pos ) ; } protected void kill ( int pos ) { VertxInternal v = ( VertxInternal ) vertices [ pos ] ; v . executeBlocking ( fut - > { v . simulateKill ( ) ; fut . complete ( ) ; } , ar - > { assertTrue ( ar . succeeded ( ) ) ; } ) ; } protected void closeVertices ( Vertx ... vertices ) throws Exception { CountDownLatch latch = new CountDownLatch ( vertices . length ) ; for ( int i = 0 ; i < vertices . length ; i ++ ) { vertices [ i ] . close ( onSuccess ( res - > { latch . countDown ( ) ; } ) ) ; } latch . await ( 2 , TimeUnit . MINUTES ) ; } }
package io . vertx . core . net ; import io . vertx . codegen . annotations . VertxGen ; @ VertxGen public interface SocketAddress { String host ( ) ; int port ( ) ; }
package io . vertx . core . net ; public class ServerOptionsBase extends TCPSSLOptions { }
package io . vertx . core . net ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . json . JsonObject ; @ DataObject public class NetServerOptions extends TCPSSLOptions { public static final int DEFAULT_PORT = 0 ; public static final String DEFAULT_HOST = "0.0.0.0" ; public static final int DEFAULT_ACCEPT_BACKLOG = 1024 ; public static final boolean DEFAULT_CLIENT_AUTH_REQUIRED = false ; private int port ; private String host ; private int acceptBacklog ; private boolean clientAuthRequired ; public NetServerOptions ( ) { super ( ) ; this . port = DEFAULT_PORT ; this . host = DEFAULT_HOST ; this . acceptBacklog = DEFAULT_ACCEPT_BACKLOG ; this . clientAuthRequired = DEFAULT_CLIENT_AUTH_REQUIRED ; } public NetServerOptions ( NetServerOptions other ) { super ( other ) ; this . port = other . getPort ( ) ; this . host = other . getHost ( ) ; this . acceptBacklog = other . getAcceptBacklog ( ) ; this . clientAuthRequired = other . isClientAuthRequired ( ) ; } public NetServerOptions ( JsonObject json ) { super ( json ) ; this . port = json . getInteger ( "port" , DEFAULT_PORT ) ; this . host = json . getString ( "host" , DEFAULT_HOST ) ; this . acceptBacklog = json . getInteger ( "acceptBacklog" , DEFAULT_ACCEPT_BACKLOG ) ; this . clientAuthRequired = json . getBoolean ( "clientAuthRequired" , DEFAULT_CLIENT_AUTH_REQUIRED ) ; } @ Override public NetServerOptions setSendBufferSize ( int sendBufferSize ) { super . setSendBufferSize ( sendBufferSize ) ; return this ; } @ Override public NetServerOptions setReceiveBufferSize ( int receiveBufferSize ) { super . setReceiveBufferSize ( receiveBufferSize ) ; return this ; } @ Override public NetServerOptions setReuseAddress ( boolean reuseAddress ) { super . setReuseAddress ( reuseAddress ) ; return this ; } @ Override public NetServerOptions setTrafficClass ( int trafficClass ) { super . setTrafficClass ( trafficClass ) ; return this ; } @ Override public NetServerOptions setTcpNoDelay ( boolean tcpNoDelay ) { super . setTcpNoDelay ( tcpNoDelay ) ; return this ; } @ Override public NetServerOptions setTcpKeepAlive ( boolean tcpKeepAlive ) { super . setTcpKeepAlive ( tcpKeepAlive ) ; return this ; } @ Override public NetServerOptions setSoLinger ( int soLinger ) { super . setSoLinger ( soLinger ) ; return this ; } @ Override public NetServerOptions setUsePooledBuffers ( boolean usePooledBuffers ) { super . setUsePooledBuffers ( usePooledBuffers ) ; return this ; } @ Override public NetServerOptions setIdleTimeout ( int idleTimeout ) { super . setIdleTimeout ( idleTimeout ) ; return this ; } @ Override public NetServerOptions setSsl ( boolean ssl ) { super . setSsl ( ssl ) ; return this ; } @ Override public NetServerOptions setKeyStoreOptions ( JksOptions options ) { super . setKeyStoreOptions ( options ) ; return this ; } @ Override public NetServerOptions setPfxKeyCertOptions ( PfxOptions options ) { return ( NetServerOptions ) super . setPfxKeyCertOptions ( options ) ; } @ Override public NetServerOptions setPemKeyCertOptions ( PemKeyCertOptions options ) { return ( NetServerOptions ) super . setPemKeyCertOptions ( options ) ; } @ Override public NetServerOptions setTrustStoreOptions ( JksOptions options ) { super . setTrustStoreOptions ( options ) ; return this ; } @ Override public NetServerOptions setPfxTrustOptions ( PfxOptions options ) { return ( NetServerOptions ) super . setPfxTrustOptions ( options ) ; } @ Override public NetServerOptions setPemTrustOptions ( PemTrustOptions options ) { return ( NetServerOptions ) super . setPemTrustOptions ( options ) ; } @ Override public NetServerOptions addEnabledCipherSuite ( String suite ) { super . addEnabledCipherSuite ( suite ) ; return this ; } @ Override public NetServerOptions addCrlPath ( String crlPath ) throws NullPointerException { return ( NetServerOptions ) super . addCrlPath ( crlPath ) ; } @ Override public NetServerOptions addCrlValue ( Buffer crlValue ) throws NullPointerException { return ( NetServerOptions ) super . addCrlValue ( crlValue ) ; } public int getAcceptBacklog ( ) { return acceptBacklog ; } public NetServerOptions setAcceptBacklog ( int acceptBacklog ) { this . acceptBacklog = acceptBacklog ; return this ; } public int getPort ( ) { return port ; } public NetServerOptions setPort ( int port ) { if ( port < 0 || port > 65535 ) { throw new IllegalArgumentException ( "port p must be in range 0 <= p <= 65535" ) ; } this . port = port ; return this ; } public String getHost ( ) { return host ; } public NetServerOptions setHost ( String host ) { this . host = host ; return this ; } public boolean isClientAuthRequired ( ) { return clientAuthRequired ; } public NetServerOptions setClientAuthRequired ( boolean clientAuthRequired ) { this . clientAuthRequired = clientAuthRequired ; return this ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof NetServerOptions ) ) return false ; if ( ! super . equals ( o ) ) return false ; NetServerOptions that = ( NetServerOptions ) o ; if ( acceptBacklog != that . acceptBacklog ) return false ; if ( clientAuthRequired != that . clientAuthRequired ) return false ; if ( port != that . port ) return false ; if ( host != null ? ! host . equals ( that . host ) : that . host != null ) return false ; return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + port ; result = 31 * result + ( host != null ? host . hashCode ( ) : 0 ) ; result = 31 * result + acceptBacklog ; result = 31 * result + ( clientAuthRequired ? 1 : 0 ) ; return result ; } }
package io . vertx . core . net ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . json . JsonObject ; @ DataObject public class JksOptions implements KeyCertOptions , TrustOptions , Cloneable { private String password ; private String path ; private Buffer value ; public JksOptions ( ) { super ( ) ; } public JksOptions ( JksOptions other ) { super ( ) ; this . password = other . getPassword ( ) ; this . path = other . getPath ( ) ; this . value = other . getValue ( ) ; } public JksOptions ( JsonObject json ) { super ( ) ; this . password = json . getString ( "password" ) ; this . path = json . getString ( "path" ) ; byte [ ] value = json . getBinary ( "value" ) ; this . value = value != null ? Buffer . buffer ( value ) : null ; } public String getPassword ( ) { return password ; } public JksOptions setPassword ( String password ) { this . password = password ; return this ; } public String getPath ( ) { return path ; } public JksOptions setPath ( String path ) { this . path = path ; return this ; } public Buffer getValue ( ) { return value ; } public JksOptions setValue ( Buffer value ) { this . value = value ; return this ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof JksOptions ) ) { return false ; } JksOptions that = ( JksOptions ) o ; if ( password != null ? ! password . equals ( that . password ) : that . password != null ) { return false ; } if ( path != null ? ! path . equals ( that . path ) : that . path != null ) { return false ; } if ( value != null ? ! value . equals ( that . value ) : that . value != null ) { return false ; } return true ; } @ Override public int hashCode ( ) { int result = 1 ; result += 31 * result + ( password != null ? password . hashCode ( ) : 0 ) ; result += 31 * result + ( path != null ? path . hashCode ( ) : 0 ) ; result += 31 * result + ( value != null ? value . hashCode ( ) : 0 ) ; return result ; } @ Override public JksOptions clone ( ) { return new JksOptions ( this ) ; } }
package io . vertx . core . net ; import io . vertx . codegen . annotations . GenIgnore ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . codegen . annotations . CacheReturn ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . streams . ReadStream ; import io . vertx . core . streams . WriteStream ; import javax . net . ssl . SSLPeerUnverifiedException ; import javax . security . cert . X509Certificate ; @ VertxGen public interface NetSocket extends ReadStream < Buffer > , WriteStream < Buffer > { @ Override NetSocket exceptionHandler ( Handler < Throwable > handler ) ; @ Override NetSocket handler ( Handler < Buffer > handler ) ; @ Override NetSocket pause ( ) ; @ Override NetSocket resume ( ) ; @ Override NetSocket endHandler ( Handler < Void > endHandler ) ; @ Override NetSocket write ( Buffer data ) ; @ Override NetSocket setWriteQueueMaxSize ( int maxSize ) ; @ Override NetSocket drainHandler ( Handler < Void > handler ) ; String writeHandlerID ( ) ; @ Fluent NetSocket write ( String str ) ; @ Fluent NetSocket write ( String str , String enc ) ; @ Fluent NetSocket sendFile ( String filename ) ; @ Fluent NetSocket sendFile ( String filename , Handler < AsyncResult < Void > > resultHandler ) ; @ CacheReturn SocketAddress remoteAddress ( ) ; @ CacheReturn SocketAddress localAddress ( ) ; void close ( ) ; @ Fluent NetSocket closeHandler ( Handler < Void > handler ) ; @ Fluent NetSocket upgradeToSsl ( Handler < Void > handler ) ; boolean isSsl ( ) ; @ GenIgnore X509Certificate [ ] peerCertificateChain ( ) throws SSLPeerUnverifiedException ; }
package io . vertx . core . net ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . Handler ; import io . vertx . core . streams . ReadStream ; @ VertxGen public interface NetSocketStream extends ReadStream < NetSocket > { @ Override NetSocketStream exceptionHandler ( Handler < Throwable > handler ) ; @ Override NetSocketStream handler ( Handler < NetSocket > handler ) ; @ Override NetSocketStream pause ( ) ; @ Override NetSocketStream resume ( ) ; @ Override NetSocketStream endHandler ( Handler < Void > endHandler ) ; }
package io . vertx . core . net ; import io . vertx . codegen . annotations . DataObject ; @ DataObject public interface TrustOptions { TrustOptions clone ( ) ; }
package io . vertx . core . net ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . codegen . annotations . Fluent ; import io . vertx . codegen . annotations . VertxGen ; import io . vertx . core . metrics . Measured ; @ VertxGen public interface NetClient extends Measured { @ Fluent NetClient connect ( int port , String host , Handler < AsyncResult < NetSocket > > connectHandler ) ; void close ( ) ; }
package io . vertx . core . net ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . json . JsonObject ; @ DataObject public class PfxOptions implements KeyCertOptions , TrustOptions , Cloneable { private String password ; private String path ; private Buffer value ; public PfxOptions ( ) { super ( ) ; } public PfxOptions ( PfxOptions other ) { super ( ) ; this . password = other . getPassword ( ) ; this . path = other . getPath ( ) ; this . value = other . getValue ( ) ; } public PfxOptions ( JsonObject json ) { super ( ) ; this . password = json . getString ( "password" ) ; this . path = json . getString ( "path" ) ; byte [ ] value = json . getBinary ( "value" ) ; this . value = value != null ? Buffer . buffer ( value ) : null ; } public String getPassword ( ) { return password ; } public PfxOptions setPassword ( String password ) { this . password = password ; return this ; } public String getPath ( ) { return path ; } public PfxOptions setPath ( String path ) { this . path = path ; return this ; } public Buffer getValue ( ) { return value ; } public PfxOptions setValue ( Buffer value ) { this . value = value ; return this ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof PfxOptions ) ) { return false ; } PfxOptions that = ( PfxOptions ) o ; if ( password != null ? ! password . equals ( that . password ) : that . password != null ) { return false ; } if ( path != null ? ! path . equals ( that . path ) : that . path != null ) { return false ; } if ( value != null ? ! value . equals ( that . value ) : that . value != null ) { return false ; } return true ; } @ Override public int hashCode ( ) { int result = 1 ; result += 31 * result + ( password != null ? password . hashCode ( ) : 0 ) ; result += 31 * result + ( path != null ? path . hashCode ( ) : 0 ) ; result += 31 * result + ( value != null ? value . hashCode ( ) : 0 ) ; return result ; } @ Override public PfxOptions clone ( ) { return new PfxOptions ( this ) ; } }
package io . vertx . core . net ; import io . vertx . codegen . annotations . DataObject ; @ DataObject public interface KeyCertOptions { KeyCertOptions clone ( ) ; }
package io . vertx . test . core ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Starter ; import io . vertx . core . Vertx ; import io . vertx . core . VertxOptions ; import io . vertx . core . json . JsonObject ; import io . vertx . core . metrics . MetricsOptions ; import io . vertx . core . metrics . impl . DummyVertxMetrics ; import io . vertx . core . spi . VertxMetricsFactory ; import io . vertx . core . spi . metrics . VertxMetrics ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; public class StarterTest extends VertxTestBase { @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; TestVerticle . instanceCount . set ( 0 ) ; TestVerticle . processArgs = null ; TestVerticle . conf = null ; } @ Override public void tearDown ( ) throws Exception { clearProperties ( ) ; super . tearDown ( ) ; } @ Test public void testVersion ( ) throws Exception { String [ ] args = new String [ ] { "-version" } ; MyStarter starter = new MyStarter ( ) ; starter . run ( args ) ; assertEquals ( System . getProperty ( "vertxVersion" ) , starter . getVersion ( ) ) ; } @ Test public void testRunVerticle ( ) throws Exception { testRunVerticleMultiple ( 1 ) ; } @ Test public void testRunVerticleMultipleInstances ( ) throws Exception { testRunVerticleMultiple ( 10 ) ; } public void testRunVerticleMultiple ( int instances ) throws Exception { MyStarter starter = new MyStarter ( ) ; String [ ] args = new String [ ] { "run" , "java:" + TestVerticle . class . getCanonicalName ( ) , "-instances" , String . valueOf ( instances ) } ; starter . run ( args ) ; waitUntil ( ( ) - > TestVerticle . instanceCount . get ( ) == instances ) ; assertEquals ( Arrays . asList ( args ) , TestVerticle . processArgs ) ; starter . assertHooksInvoked ( ) ; } @ Test public void testRunVerticleClustered ( ) throws Exception { MyStarter starter = new MyStarter ( ) ; String [ ] args = new String [ ] { "run" , "java:" + TestVerticle . class . getCanonicalName ( ) , "-cluster" } ; starter . run ( args ) ; waitUntil ( ( ) - > TestVerticle . instanceCount . get ( ) == 1 ) ; assertEquals ( Arrays . asList ( args ) , TestVerticle . processArgs ) ; starter . assertHooksInvoked ( ) ; } @ Test public void testRunVerticleHA ( ) throws Exception { MyStarter starter = new MyStarter ( ) ; String [ ] args = new String [ ] { "run" , "java:" + TestVerticle . class . getCanonicalName ( ) , "-ha" } ; starter . run ( args ) ; waitUntil ( ( ) - > TestVerticle . instanceCount . get ( ) == 1 ) ; assertEquals ( Arrays . asList ( args ) , TestVerticle . processArgs ) ; starter . assertHooksInvoked ( ) ; } @ Test public void testRunVerticleWithMainVerticleInManifestNoArgs ( ) throws Exception { MyStarter starter = new MyStarter ( ) ; String [ ] args = new String [ 0 ] ; starter . run ( args ) ; waitUntil ( ( ) - > TestVerticle . instanceCount . get ( ) == 1 ) ; assertEquals ( Arrays . asList ( args ) , TestVerticle . processArgs ) ; } @ Test public void testRunVerticleWithMainVerticleInManifestWithArgs ( ) throws Exception { MyStarter starter = new MyStarter ( ) ; String [ ] args = new String [ ] { "-cluster" , "-worker" } ; starter . run ( args ) ; waitUntil ( ( ) - > TestVerticle . instanceCount . get ( ) == 1 ) ; assertEquals ( Arrays . asList ( args ) , TestVerticle . processArgs ) ; } @ Test public void testRunVerticleWithConfString ( ) throws Exception { MyStarter starter = new MyStarter ( ) ; JsonObject conf = new JsonObject ( ) . put ( "foo" , "bar" ) . put ( "wibble" , 123 ) ; String [ ] args = new String [ ] { "run" , "java:" + TestVerticle . class . getCanonicalName ( ) , "-conf" , conf . encode ( ) } ; starter . run ( args ) ; waitUntil ( ( ) - > TestVerticle . instanceCount . get ( ) == 1 ) ; assertEquals ( conf , TestVerticle . conf ) ; } @ Rule public TemporaryFolder testFolder = new TemporaryFolder ( ) ; @ Test public void testRunVerticleWithConfFile ( ) throws Exception { Path tempDir = testFolder . newFolder ( ) . toPath ( ) ; Path tempFile = Files . createTempFile ( tempDir , "conf" , "json" ) ; MyStarter starter = new MyStarter ( ) ; JsonObject conf = new JsonObject ( ) . put ( "foo" , "bar" ) . put ( "wibble" , 123 ) ; Files . write ( tempFile , conf . encode ( ) . getBytes ( ) ) ; String [ ] args = new String [ ] { "run" , "java:" + TestVerticle . class . getCanonicalName ( ) , "-conf" , tempFile . toString ( ) } ; starter . run ( args ) ; waitUntil ( ( ) - > TestVerticle . instanceCount . get ( ) == 1 ) ; assertEquals ( conf , TestVerticle . conf ) ; } @ Test public void testConfigureFromSystemProperties ( ) throws Exception { testConfigureFromSystemProperties ( false ) ; } @ Test public void testConfigureFromSystemPropertiesClustered ( ) throws Exception { testConfigureFromSystemProperties ( true ) ; } private void testConfigureFromSystemProperties ( boolean clustered ) throws Exception { System . setProperty ( Starter . VERTX_OPTIONS_PROP_PREFIX + "eventLoopPoolSize" , "123" ) ; System . setProperty ( Starter . VERTX_OPTIONS_PROP_PREFIX + "maxEventLoopExecuteTime" , "123767667" ) ; System . setProperty ( Starter . METRICS_OPTIONS_PROP_PREFIX + "enabled" , "true" ) ; System . setProperty ( Starter . VERTX_OPTIONS_PROP_PREFIX + "haGroup" , "somegroup" ) ; MyStarter starter = new MyStarter ( ) ; String [ ] args ; if ( clustered ) { args = new String [ ] { "run" , "java:" + TestVerticle . class . getCanonicalName ( ) , "-cluster" } ; } else { args = new String [ ] { "run" , "java:" + TestVerticle . class . getCanonicalName ( ) } ; } starter . run ( args ) ; waitUntil ( ( ) - > TestVerticle . instanceCount . get ( ) == 1 ) ; VertxOptions opts = starter . getVertxOptions ( ) ; assertEquals ( 123 , opts . getEventLoopPoolSize ( ) , 0 ) ; assertEquals ( 123767667l , opts . getMaxEventLoopExecuteTime ( ) ) ; assertEquals ( true , opts . getMetricsOptions ( ) . isEnabled ( ) ) ; assertEquals ( "somegroup" , opts . getHAGroup ( ) ) ; } private void clearProperties ( ) { Set < String > toClear = new HashSet < > ( ) ; Enumeration e = System . getProperties ( ) . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String propName = ( String ) e . nextElement ( ) ; if ( propName . startsWith ( "vertx.options" ) ) { toClear . add ( propName ) ; } } for ( String propName : toClear ) { System . clearProperty ( propName ) ; } } @ Test public void testCustomMetricsOptions ( ) throws Exception { try { ConfigurableMetricsFactory . delegate = new VertxMetricsFactory ( ) { @ Override public VertxMetrics metrics ( Vertx vertx , VertxOptions options ) { return new DummyVertxMetrics ( ) ; } @ Override public MetricsOptions newOptions ( ) { return new CustomMetricsOptions ( ) ; } } ; System . setProperty ( Starter . METRICS_OPTIONS_PROP_PREFIX + "enabled" , "true" ) ; System . setProperty ( Starter . METRICS_OPTIONS_PROP_PREFIX + "customProperty" , "customPropertyValue" ) ; MyStarter starter = new MyStarter ( ) ; String [ ] args = new String [ ] { "run" , "java:" + TestVerticle . class . getCanonicalName ( ) } ; starter . run ( args ) ; waitUntil ( ( ) - > TestVerticle . instanceCount . get ( ) == 1 ) ; VertxOptions opts = starter . getVertxOptions ( ) ; CustomMetricsOptions custom = ( CustomMetricsOptions ) opts . getMetricsOptions ( ) ; assertEquals ( "customPropertyValue" , custom . getCustomProperty ( ) ) ; } finally { ConfigurableMetricsFactory . delegate = null ; } } @ Test public void testConfigureFromSystemPropertiesInvalidPropertyName ( ) throws Exception { System . setProperty ( Starter . VERTX_OPTIONS_PROP_PREFIX + "nosuchproperty" , "123" ) ; MyStarter starter = new MyStarter ( ) ; String [ ] args = new String [ ] { "run" , "java:" + TestVerticle . class . getCanonicalName ( ) } ; starter . run ( args ) ; waitUntil ( ( ) - > TestVerticle . instanceCount . get ( ) == 1 ) ; VertxOptions opts = starter . getVertxOptions ( ) ; assertEquals ( new VertxOptions ( ) , opts ) ; } @ Test public void testConfigureFromSystemPropertiesInvalidPropertyType ( ) throws Exception { System . setProperty ( Starter . VERTX_OPTIONS_PROP_PREFIX + "eventLoopPoolSize" , "sausages" ) ; MyStarter starter = new MyStarter ( ) ; String [ ] args = new String [ ] { "run" , "java:" + TestVerticle . class . getCanonicalName ( ) } ; starter . run ( args ) ; waitUntil ( ( ) - > TestVerticle . instanceCount . get ( ) == 1 ) ; VertxOptions opts = starter . getVertxOptions ( ) ; assertEquals ( new VertxOptions ( ) , opts ) ; } @ Test public void testRunWithCommandLine ( ) throws Exception { MyStarter starter = new MyStarter ( ) ; int instances = 10 ; String cl = "run java:" + TestVerticle . class . getCanonicalName ( ) + " -instances " + instances ; starter . run ( cl ) ; waitUntil ( ( ) - > TestVerticle . instanceCount . get ( ) == instances ) ; } class MyStarter extends Starter { boolean beforeStartingVertxInvoked = false ; boolean afterStartingVertxInvoked = false ; boolean beforeDeployingVerticle = false ; public Vertx getVert ( ) { return vertx ; } public VertxOptions getVertxOptions ( ) { return options ; } public DeploymentOptions getDeploymentOptions ( ) { return deploymentOptions ; } @ Override public void run ( String [ ] sargs ) { super . run ( sargs ) ; } @ Override public void run ( String commandLine ) { super . run ( commandLine ) ; } @ Override public void beforeStartingVertx ( VertxOptions options ) { beforeStartingVertxInvoked = true ; } @ Override public void afterStartingVertx ( ) { afterStartingVertxInvoked = true ; } @ Override protected void beforeDeployingVerticle ( DeploymentOptions deploymentOptions ) { beforeDeployingVerticle = true ; } public void assertHooksInvoked ( ) { assertTrue ( beforeStartingVertxInvoked ) ; assertTrue ( afterStartingVertxInvoked ) ; assertTrue ( beforeDeployingVerticle ) ; } } }
package io . vertx . test . core ; import io . vertx . core . * ; import io . vertx . core . eventbus . Message ; import io . vertx . core . impl . * ; import io . vertx . core . impl . verticle . CompilingClassLoader ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import io . vertx . test . core . sourceverticle . SourceVerticle ; import org . junit . Test ; import java . io . File ; import java . net . URL ; import java . net . URLClassLoader ; import java . nio . file . Files ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import java . util . function . Consumer ; public class DeploymentTest extends VertxTestBase { public void setUp ( ) throws Exception { super . setUp ( ) ; TestVerticle . instanceCount . set ( 0 ) ; } @ Test public void testOptions ( ) { DeploymentOptions options = new DeploymentOptions ( ) ; assertNull ( options . getConfig ( ) ) ; JsonObject config = new JsonObject ( ) . put ( "foo" , "bar" ) . put ( "obj" , new JsonObject ( ) . put ( "quux" , 123 ) ) ; assertEquals ( options , options . setConfig ( config ) ) ; assertEquals ( config , options . getConfig ( ) ) ; assertFalse ( options . isWorker ( ) ) ; assertEquals ( options , options . setWorker ( true ) ) ; assertTrue ( options . isWorker ( ) ) ; assertFalse ( options . isMultiThreaded ( ) ) ; assertEquals ( options , options . setMultiThreaded ( true ) ) ; assertTrue ( options . isMultiThreaded ( ) ) ; assertNull ( options . getIsolationGroup ( ) ) ; String rand = TestUtils . randomUnicodeString ( 1000 ) ; assertEquals ( options , options . setIsolationGroup ( rand ) ) ; assertEquals ( rand , options . getIsolationGroup ( ) ) ; assertFalse ( options . isHa ( ) ) ; assertEquals ( options , options . setHa ( true ) ) ; assertTrue ( options . isHa ( ) ) ; assertNull ( options . getExtraClasspath ( ) ) ; List < String > cp = Arrays . asList ( "foo" , "bar" ) ; assertEquals ( options , options . setExtraClasspath ( cp ) ) ; assertNull ( options . getIsolatedClasses ( ) ) ; List < String > isol = Arrays . asList ( "com.foo.MyClass" , "org.foo.*" ) ; assertEquals ( options , options . setIsolatedClasses ( isol ) ) ; assertSame ( isol , options . getIsolatedClasses ( ) ) ; } @ Test public void testCopyOptions ( ) { DeploymentOptions options = new DeploymentOptions ( ) ; JsonObject config = new JsonObject ( ) . put ( "foo" , "bar" ) ; Random rand = new Random ( ) ; boolean worker = rand . nextBoolean ( ) ; boolean multiThreaded = rand . nextBoolean ( ) ; String isolationGroup = TestUtils . randomAlphaString ( 100 ) ; boolean ha = rand . nextBoolean ( ) ; List < String > cp = Arrays . asList ( "foo" , "bar" ) ; List < String > isol = Arrays . asList ( "com.foo.MyClass" , "org.foo.*" ) ; options . setConfig ( config ) ; options . setWorker ( worker ) ; options . setMultiThreaded ( multiThreaded ) ; options . setIsolationGroup ( isolationGroup ) ; options . setHa ( ha ) ; options . setExtraClasspath ( cp ) ; options . setIsolatedClasses ( isol ) ; DeploymentOptions copy = new DeploymentOptions ( options ) ; assertEquals ( worker , copy . isWorker ( ) ) ; assertEquals ( multiThreaded , copy . isMultiThreaded ( ) ) ; assertEquals ( isolationGroup , copy . getIsolationGroup ( ) ) ; assertNotSame ( config , copy . getConfig ( ) ) ; assertEquals ( "bar" , copy . getConfig ( ) . getString ( "foo" ) ) ; assertEquals ( ha , copy . isHa ( ) ) ; assertEquals ( cp , copy . getExtraClasspath ( ) ) ; assertNotSame ( cp , copy . getExtraClasspath ( ) ) ; assertEquals ( isol , copy . getIsolatedClasses ( ) ) ; assertNotSame ( isol , copy . getIsolatedClasses ( ) ) ; } @ Test public void testDefaultJsonOptions ( ) { DeploymentOptions def = new DeploymentOptions ( ) ; DeploymentOptions json = new DeploymentOptions ( new JsonObject ( ) ) ; assertEquals ( def . getConfig ( ) , json . getConfig ( ) ) ; assertEquals ( def . isWorker ( ) , json . isWorker ( ) ) ; assertEquals ( def . isMultiThreaded ( ) , json . isMultiThreaded ( ) ) ; assertEquals ( def . getIsolationGroup ( ) , json . getIsolationGroup ( ) ) ; assertEquals ( def . isHa ( ) , json . isHa ( ) ) ; assertEquals ( def . getExtraClasspath ( ) , json . getExtraClasspath ( ) ) ; assertEquals ( def . getIsolatedClasses ( ) , json . getIsolatedClasses ( ) ) ; } @ Test public void testJsonOptions ( ) { JsonObject config = new JsonObject ( ) . put ( "foo" , "bar" ) ; Random rand = new Random ( ) ; boolean worker = rand . nextBoolean ( ) ; boolean multiThreaded = rand . nextBoolean ( ) ; String isolationGroup = TestUtils . randomAlphaString ( 100 ) ; boolean ha = rand . nextBoolean ( ) ; List < String > cp = Arrays . asList ( "foo" , "bar" ) ; List < String > isol = Arrays . asList ( "com.foo.MyClass" , "org.foo.*" ) ; JsonObject json = new JsonObject ( ) ; json . put ( "config" , config ) ; json . put ( "worker" , worker ) ; json . put ( "multiThreaded" , multiThreaded ) ; json . put ( "isolationGroup" , isolationGroup ) ; json . put ( "ha" , ha ) ; json . put ( "extraClasspath" , new JsonArray ( cp ) ) ; json . put ( "isolatedClasses" , new JsonArray ( isol ) ) ; DeploymentOptions options = new DeploymentOptions ( json ) ; assertEquals ( worker , options . isWorker ( ) ) ; assertEquals ( multiThreaded , options . isMultiThreaded ( ) ) ; assertEquals ( isolationGroup , options . getIsolationGroup ( ) ) ; assertEquals ( "bar" , options . getConfig ( ) . getString ( "foo" ) ) ; assertEquals ( ha , options . isHa ( ) ) ; assertEquals ( cp , options . getExtraClasspath ( ) ) ; assertEquals ( isol , options . getIsolatedClasses ( ) ) ; } @ Test public void testToJson ( ) { DeploymentOptions options = new DeploymentOptions ( ) ; JsonObject config = new JsonObject ( ) . put ( "foo" , "bar" ) ; Random rand = new Random ( ) ; boolean worker = rand . nextBoolean ( ) ; boolean multiThreaded = rand . nextBoolean ( ) ; String isolationGroup = TestUtils . randomAlphaString ( 100 ) ; boolean ha = rand . nextBoolean ( ) ; List < String > cp = Arrays . asList ( "foo" , "bar" ) ; List < String > isol = Arrays . asList ( "com.foo.MyClass" , "org.foo.*" ) ; options . setConfig ( config ) ; options . setWorker ( worker ) ; options . setMultiThreaded ( multiThreaded ) ; options . setIsolationGroup ( isolationGroup ) ; options . setHa ( ha ) ; options . setExtraClasspath ( cp ) ; options . setIsolatedClasses ( isol ) ; JsonObject json = options . toJson ( ) ; DeploymentOptions copy = new DeploymentOptions ( json ) ; assertEquals ( worker , copy . isWorker ( ) ) ; assertEquals ( multiThreaded , copy . isMultiThreaded ( ) ) ; assertEquals ( isolationGroup , copy . getIsolationGroup ( ) ) ; assertEquals ( "bar" , copy . getConfig ( ) . getString ( "foo" ) ) ; assertEquals ( ha , copy . isHa ( ) ) ; assertEquals ( cp , copy . getExtraClasspath ( ) ) ; assertEquals ( isol , copy . getIsolatedClasses ( ) ) ; } @ Test public void testDeployFromTestThread ( ) throws Exception { MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , ar - > { assertDeployment ( 1 , verticle , null , ar ) ; assertFalse ( verticle . startContext . isMultiThreadedWorkerContext ( ) ) ; assertFalse ( verticle . startContext . isWorkerContext ( ) ) ; assertTrue ( verticle . startContext . isEventLoopContext ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testDeployFromTestThreadNoHandler ( ) throws Exception { MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle ) ; waitUntil ( ( ) - > vertx . deploymentIDs ( ) . size ( ) == 1 ) ; } @ Test public void testDeployWithConfig ( ) throws Exception { MyVerticle verticle = new MyVerticle ( ) ; JsonObject config = generateJSONObject ( ) ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setConfig ( config ) , ar - > { assertDeployment ( 1 , verticle , config , ar ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testDeployFromContext ( ) throws Exception { MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; Context ctx = Vertx . currentContext ( ) ; MyVerticle verticle2 = new MyVerticle ( ) ; vertx . deployVerticle ( verticle2 , ar2 - > { assertDeployment ( 2 , verticle2 , null , ar2 ) ; Context ctx2 = Vertx . currentContext ( ) ; assertEquals ( ctx , ctx2 ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testDeployWorkerFromTestThread ( ) throws Exception { MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setWorker ( true ) , ar - > { assertDeployment ( 1 , verticle , null , ar ) ; assertTrue ( verticle . startContext instanceof WorkerContext ) ; vertx . undeploy ( ar . result ( ) , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertEquals ( verticle . startContext , verticle . stopContext ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testDeployWorkerWithConfig ( ) throws Exception { MyVerticle verticle = new MyVerticle ( ) ; JsonObject conf = generateJSONObject ( ) ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setConfig ( conf ) . setWorker ( true ) , ar - > { assertDeployment ( 1 , verticle , conf , ar ) ; assertFalse ( verticle . startContext . isMultiThreadedWorkerContext ( ) ) ; assertTrue ( verticle . startContext . isWorkerContext ( ) ) ; assertFalse ( verticle . startContext . isEventLoopContext ( ) ) ; vertx . undeploy ( ar . result ( ) , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertEquals ( verticle . startContext , verticle . stopContext ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testDeployMultithreadedWorkerWithConfig ( ) throws Exception { MyVerticle verticle = new MyVerticle ( ) ; JsonObject conf = generateJSONObject ( ) ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setConfig ( conf ) . setWorker ( true ) . setMultiThreaded ( true ) , ar - > { assertDeployment ( 1 , verticle , conf , ar ) ; assertTrue ( verticle . startContext . isMultiThreadedWorkerContext ( ) ) ; assertTrue ( verticle . startContext . isWorkerContext ( ) ) ; assertFalse ( verticle . startContext . isEventLoopContext ( ) ) ; vertx . undeploy ( ar . result ( ) , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertEquals ( verticle . startContext , verticle . stopContext ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testWorkerRightThread ( ) throws Exception { assertFalse ( Context . isOnVertxThread ( ) ) ; Verticle verticle = new AbstractVerticle ( ) { @ Override public void start ( ) throws Exception { assertTrue ( Context . isOnVertxThread ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; assertFalse ( Context . isOnEventLoopThread ( ) ) ; } @ Override public void stop ( ) throws Exception { assertTrue ( Context . isOnVertxThread ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; assertFalse ( Context . isOnEventLoopThread ( ) ) ; } } ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setWorker ( true ) , onSuccess ( res - > { assertTrue ( Context . isOnVertxThread ( ) ) ; assertFalse ( Context . isOnWorkerThread ( ) ) ; assertTrue ( Context . isOnEventLoopThread ( ) ) ; vertx . undeploy ( res , onSuccess ( res2 - > { assertTrue ( Context . isOnVertxThread ( ) ) ; assertFalse ( Context . isOnWorkerThread ( ) ) ; assertTrue ( Context . isOnEventLoopThread ( ) ) ; testComplete ( ) ; } ) ) ; } ) ) ; await ( ) ; } @ Test public void testMTWorkerRightThread ( ) throws Exception { assertFalse ( Context . isOnVertxThread ( ) ) ; Verticle verticle = new AbstractVerticle ( ) { @ Override public void start ( ) throws Exception { assertTrue ( Context . isOnVertxThread ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; assertFalse ( Context . isOnEventLoopThread ( ) ) ; } @ Override public void stop ( ) throws Exception { assertTrue ( Context . isOnVertxThread ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; assertFalse ( Context . isOnEventLoopThread ( ) ) ; } } ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setWorker ( true ) . setMultiThreaded ( true ) , onSuccess ( res - > { assertTrue ( Context . isOnVertxThread ( ) ) ; assertFalse ( Context . isOnWorkerThread ( ) ) ; assertTrue ( Context . isOnEventLoopThread ( ) ) ; vertx . undeploy ( res , onSuccess ( res2 - > { assertTrue ( Context . isOnVertxThread ( ) ) ; assertFalse ( Context . isOnWorkerThread ( ) ) ; assertTrue ( Context . isOnEventLoopThread ( ) ) ; testComplete ( ) ; } ) ) ; } ) ) ; await ( ) ; } @ Test public void testStandardRightThread ( ) throws Exception { assertFalse ( Context . isOnVertxThread ( ) ) ; Verticle verticle = new AbstractVerticle ( ) { @ Override public void start ( ) throws Exception { assertTrue ( Context . isOnVertxThread ( ) ) ; assertFalse ( Context . isOnWorkerThread ( ) ) ; assertTrue ( Context . isOnEventLoopThread ( ) ) ; } @ Override public void stop ( ) throws Exception { assertTrue ( Context . isOnVertxThread ( ) ) ; assertFalse ( Context . isOnWorkerThread ( ) ) ; assertTrue ( Context . isOnEventLoopThread ( ) ) ; } } ; vertx . deployVerticle ( verticle , onSuccess ( res - > { assertTrue ( Context . isOnVertxThread ( ) ) ; assertFalse ( Context . isOnWorkerThread ( ) ) ; assertTrue ( Context . isOnEventLoopThread ( ) ) ; vertx . undeploy ( res , onSuccess ( res2 - > { assertTrue ( Context . isOnVertxThread ( ) ) ; assertFalse ( Context . isOnWorkerThread ( ) ) ; assertTrue ( Context . isOnEventLoopThread ( ) ) ; testComplete ( ) ; } ) ) ; } ) ) ; await ( ) ; } @ Test public void testDeployMultithreadedNotWorker ( ) throws Exception { MyVerticle verticle = new MyVerticle ( ) ; try { vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setWorker ( false ) . setMultiThreaded ( true ) , ar - > { } ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } } @ Test public void testDeployFromContextExceptionInStart ( ) throws Exception { testDeployFromThrowableInStart ( MyVerticle . THROW_EXCEPTION , Exception . class ) ; } @ Test public void testDeployFromContextErrorInStart ( ) throws Exception { testDeployFromThrowableInStart ( MyVerticle . THROW_ERROR , Error . class ) ; } private void testDeployFromThrowableInStart ( int startAction , Class < ? extends Throwable > expectedThrowable ) throws Exception { MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; Context ctx = Vertx . currentContext ( ) ; MyVerticle verticle2 = new MyVerticle ( startAction , MyVerticle . NOOP ) ; vertx . deployVerticle ( verticle2 , ar2 - > { assertFalse ( ar2 . succeeded ( ) ) ; assertEquals ( expectedThrowable , ar2 . cause ( ) . getClass ( ) ) ; assertEquals ( "FooBar!" , ar2 . cause ( ) . getMessage ( ) ) ; assertEquals ( 1 , vertx . deploymentIDs ( ) . size ( ) ) ; Context ctx2 = Vertx . currentContext ( ) ; assertEquals ( ctx , ctx2 ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testDeployFromContextExceptonInStop ( ) throws Exception { testDeployFromContextThrowableInStop ( MyVerticle . THROW_EXCEPTION , Exception . class ) ; } @ Test public void testDeployFromContextErrorInStop ( ) throws Exception { testDeployFromContextThrowableInStop ( MyVerticle . THROW_ERROR , Error . class ) ; } private void testDeployFromContextThrowableInStop ( int stopAction , Class < ? extends Throwable > expectedThrowable ) throws Exception { MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; Context ctx = Vertx . currentContext ( ) ; MyVerticle verticle2 = new MyVerticle ( MyVerticle . NOOP , stopAction ) ; vertx . deployVerticle ( verticle2 , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; vertx . undeploy ( ar2 . result ( ) , ar3 - > { assertFalse ( ar3 . succeeded ( ) ) ; assertEquals ( expectedThrowable , ar3 . cause ( ) . getClass ( ) ) ; assertEquals ( "BooFar!" , ar3 . cause ( ) . getMessage ( ) ) ; assertEquals ( 1 , vertx . deploymentIDs ( ) . size ( ) ) ; assertEquals ( ctx , Vertx . currentContext ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testUndeploy ( ) throws Exception { MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; vertx . undeploy ( ar . result ( ) , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertNull ( ar2 . result ( ) ) ; assertFalse ( vertx . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; assertEquals ( verticle . startContext , verticle . stopContext ) ; Context currentContext = Vertx . currentContext ( ) ; assertNotSame ( currentContext , verticle . startContext ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testUndeployNoHandler ( ) throws Exception { MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; vertx . undeploy ( ar . result ( ) ) ; } ) ; waitUntil ( ( ) - > vertx . deploymentIDs ( ) . isEmpty ( ) ) ; } @ Test public void testUndeployTwice ( ) throws Exception { MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; vertx . undeploy ( ar . result ( ) , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; vertx . undeploy ( ar . result ( ) , ar3 - > { assertFalse ( ar3 . succeeded ( ) ) ; assertTrue ( ar3 . cause ( ) instanceof IllegalStateException ) ; testComplete ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testUndeployInvalidID ( ) throws Exception { vertx . undeploy ( "uqhwdiuhqwd" , ar - > { assertFalse ( ar . succeeded ( ) ) ; assertTrue ( ar . cause ( ) instanceof IllegalStateException ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testDeployExceptionInStart ( ) throws Exception { testDeployThrowableInStart ( MyVerticle . THROW_EXCEPTION , Exception . class ) ; } @ Test public void testDeployErrorInStart ( ) throws Exception { testDeployThrowableInStart ( MyVerticle . THROW_ERROR , Error . class ) ; } private void testDeployThrowableInStart ( int startAction , Class < ? extends Throwable > expectedThrowable ) throws Exception { MyVerticle verticle = new MyVerticle ( startAction , MyVerticle . NOOP ) ; vertx . deployVerticle ( verticle , ar - > { assertFalse ( ar . succeeded ( ) ) ; assertEquals ( expectedThrowable , ar . cause ( ) . getClass ( ) ) ; assertEquals ( "FooBar!" , ar . cause ( ) . getMessage ( ) ) ; assertTrue ( vertx . deploymentIDs ( ) . isEmpty ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testUndeployExceptionInStop ( ) throws Exception { testUndeployThrowableInStop ( MyVerticle . THROW_EXCEPTION , Exception . class ) ; } @ Test public void testUndeployErrorInStop ( ) throws Exception { testUndeployThrowableInStop ( MyVerticle . THROW_ERROR , Error . class ) ; } private void testUndeployThrowableInStop ( int stopAction , Class < ? extends Throwable > expectedThrowable ) throws Exception { MyVerticle verticle = new MyVerticle ( MyVerticle . NOOP , stopAction ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; vertx . undeploy ( ar . result ( ) , ar2 - > { assertFalse ( ar2 . succeeded ( ) ) ; assertEquals ( expectedThrowable , ar2 . cause ( ) . getClass ( ) ) ; assertEquals ( "BooFar!" , ar2 . cause ( ) . getMessage ( ) ) ; assertTrue ( vertx . deploymentIDs ( ) . isEmpty ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testDeployUndeployMultiple ( ) throws Exception { int num = 10 ; CountDownLatch deployLatch = new CountDownLatch ( num ) ; for ( int i = 0 ; i < num ; i ++ ) { MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertTrue ( vertx . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; deployLatch . countDown ( ) ; } ) ; } assertTrue ( deployLatch . await ( 10 , TimeUnit . SECONDS ) ) ; assertEquals ( num , vertx . deploymentIDs ( ) . size ( ) ) ; CountDownLatch undeployLatch = new CountDownLatch ( num ) ; for ( String deploymentID : vertx . deploymentIDs ( ) ) { vertx . undeploy ( deploymentID , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertFalse ( vertx . deploymentIDs ( ) . contains ( deploymentID ) ) ; undeployLatch . countDown ( ) ; } ) ; } assertTrue ( undeployLatch . await ( 10 , TimeUnit . SECONDS ) ) ; assertTrue ( vertx . deploymentIDs ( ) . isEmpty ( ) ) ; } @ Test ( expected = IllegalArgumentException . class ) public void testDeployInstanceSetInstances ( ) throws Exception { vertx . deployVerticle ( new MyVerticle ( ) , new DeploymentOptions ( ) . setInstances ( 2 ) ) ; } @ Test ( expected = IllegalArgumentException . class ) public void testDeployInstanceSetExtraClasspath ( ) throws Exception { vertx . deployVerticle ( new MyVerticle ( ) , new DeploymentOptions ( ) . setExtraClasspath ( Arrays . asList ( "foo" ) ) ) ; } @ Test ( expected = IllegalArgumentException . class ) public void testDeployInstanceSetIsolationGroup ( ) throws Exception { vertx . deployVerticle ( new MyVerticle ( ) , new DeploymentOptions ( ) . setIsolationGroup ( "foo" ) ) ; } @ Test ( expected = IllegalArgumentException . class ) public void testDeployInstanceSetIsolatedClasses ( ) throws Exception { vertx . deployVerticle ( new MyVerticle ( ) , new DeploymentOptions ( ) . setIsolatedClasses ( Arrays . asList ( "foo" ) ) ) ; } @ Test public void testDeployUsingClassName ( ) throws Exception { vertx . deployVerticle ( "java:" + TestVerticle . class . getCanonicalName ( ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testDeployUsingClassAndConfig ( ) throws Exception { JsonObject config = generateJSONObject ( ) ; vertx . deployVerticle ( "java:" + TestVerticle . class . getCanonicalName ( ) , new DeploymentOptions ( ) . setConfig ( config ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testDeployUsingClassFails ( ) throws Exception { vertx . deployVerticle ( "java:uhqwuhiqwduhwd" , ar - > { assertFalse ( ar . succeeded ( ) ) ; assertTrue ( ar . cause ( ) instanceof ClassNotFoundException ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testDeployUndeployMultipleInstancesUsingClassName ( ) throws Exception { int numInstances = 10 ; DeploymentOptions options = new DeploymentOptions ( ) . setInstances ( numInstances ) ; AtomicInteger deployCount = new AtomicInteger ( ) ; AtomicInteger undeployCount = new AtomicInteger ( ) ; AtomicInteger deployHandlerCount = new AtomicInteger ( ) ; AtomicInteger undeployHandlerCount = new AtomicInteger ( ) ; vertx . eventBus ( ) . < String > consumer ( "tvstarted" ) . handler ( msg - > { deployCount . incrementAndGet ( ) ; } ) ; vertx . eventBus ( ) . < String > consumer ( "tvstopped" ) . handler ( msg - > { undeployCount . incrementAndGet ( ) ; msg . reply ( "whatever" ) ; } ) ; CountDownLatch deployLatch = new CountDownLatch ( 1 ) ; vertx . deployVerticle ( TestVerticle2 . class . getCanonicalName ( ) , options , onSuccess ( depID - > { assertEquals ( 1 , deployHandlerCount . incrementAndGet ( ) ) ; deployLatch . countDown ( ) ; } ) ) ; awaitLatch ( deployLatch ) ; waitUntil ( ( ) - > deployCount . get ( ) == numInstances ) ; assertEquals ( 1 , vertx . deploymentIDs ( ) . size ( ) ) ; Deployment deployment = ( ( VertxInternal ) vertx ) . getDeployment ( vertx . deploymentIDs ( ) . iterator ( ) . next ( ) ) ; Set < Verticle > verticles = deployment . getVerticles ( ) ; assertEquals ( numInstances , verticles . size ( ) ) ; CountDownLatch undeployLatch = new CountDownLatch ( 1 ) ; assertEquals ( numInstances , deployCount . get ( ) ) ; vertx . undeploy ( deployment . deploymentID ( ) , onSuccess ( v - > { assertEquals ( 1 , undeployHandlerCount . incrementAndGet ( ) ) ; undeployLatch . countDown ( ) ; } ) ) ; awaitLatch ( undeployLatch ) ; waitUntil ( ( ) - > deployCount . get ( ) == numInstances ) ; assertTrue ( vertx . deploymentIDs ( ) . isEmpty ( ) ) ; } @ Test public void testDeployClassNotFound1 ( ) throws Exception { testDeployClassNotFound ( "iqwjdiqwjdoiqwjdqwij" ) ; } @ Test public void testDeployClassNotFound2 ( ) throws Exception { testDeployClassNotFound ( "foo.bar.wibble.CiejdioqjdoiqwjdoiqjwdClass" ) ; } private void testDeployClassNotFound ( String className ) throws Exception { vertx . deployVerticle ( className , ar - > { assertTrue ( ar . failed ( ) ) ; assertTrue ( ar . cause ( ) instanceof ClassNotFoundException ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testDeployAsSource ( ) throws Exception { String sourceFile = SourceVerticle . class . getName ( ) . replace ( '.' , '/' ) ; sourceFile += ".java" ; vertx . deployVerticle ( "java:" + sourceFile , onSuccess ( res - > { testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testSimpleChildDeployment ( ) throws Exception { Verticle verticle = new MyAsyncVerticle ( f - > { Context parentContext = Vertx . currentContext ( ) ; Verticle child1 = new MyAsyncVerticle ( f2 - > { Context childContext = Vertx . currentContext ( ) ; assertNotSame ( parentContext , childContext ) ; f2 . complete ( null ) ; testComplete ( ) ; } , f2 - > f2 . complete ( null ) ) ; vertx . deployVerticle ( child1 , ar - > { assertTrue ( ar . succeeded ( ) ) ; } ) ; f . complete ( null ) ; } , f - > f . complete ( null ) ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; } ) ; await ( ) ; } @ Test public void testSimpleChildUndeploymentOrder ( ) throws Exception { AtomicBoolean childStopCalled = new AtomicBoolean ( ) ; AtomicBoolean parentStopCalled = new AtomicBoolean ( ) ; AtomicReference < String > parentDepID = new AtomicReference < > ( ) ; AtomicReference < String > childDepID = new AtomicReference < > ( ) ; CountDownLatch deployLatch = new CountDownLatch ( 1 ) ; Verticle verticle = new MyAsyncVerticle ( f - > { Verticle child1 = new MyAsyncVerticle ( f2 - > f2 . complete ( null ) , f2 - > { assertFalse ( parentStopCalled . get ( ) ) ; assertFalse ( childStopCalled . get ( ) ) ; childStopCalled . set ( true ) ; f2 . complete ( null ) ; } ) ; vertx . deployVerticle ( child1 , ar - > { assertTrue ( ar . succeeded ( ) ) ; childDepID . set ( ar . result ( ) ) ; f . complete ( null ) ; } ) ; } , f2 - > { assertFalse ( parentStopCalled . get ( ) ) ; assertTrue ( childStopCalled . get ( ) ) ; assertTrue ( vertx . deploymentIDs ( ) . contains ( parentDepID . get ( ) ) ) ; assertFalse ( vertx . deploymentIDs ( ) . contains ( childDepID . get ( ) ) ) ; parentStopCalled . set ( true ) ; testComplete ( ) ; f2 . complete ( null ) ; } ) ; vertx . deployVerticle ( verticle , ar - > { parentDepID . set ( ar . result ( ) ) ; assertTrue ( ar . succeeded ( ) ) ; deployLatch . countDown ( ) ; } ) ; assertTrue ( deployLatch . await ( 10 , TimeUnit . SECONDS ) ) ; assertTrue ( vertx . deploymentIDs ( ) . contains ( parentDepID . get ( ) ) ) ; assertTrue ( vertx . deploymentIDs ( ) . contains ( childDepID . get ( ) ) ) ; vertx . undeploy ( parentDepID . get ( ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; } ) ; await ( ) ; } @ Test public void testAsyncDeployCalledSynchronously ( ) throws Exception { MyAsyncVerticle verticle = new MyAsyncVerticle ( f - > f . complete ( null ) , f - > f . complete ( null ) ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testAsyncDeployFailureCalledSynchronously ( ) throws Exception { MyAsyncVerticle verticle = new MyAsyncVerticle ( f - > f . fail ( new Exception ( "foobar" ) ) , null ) ; vertx . deployVerticle ( verticle , ar - > { assertFalse ( ar . succeeded ( ) ) ; assertEquals ( "foobar" , ar . cause ( ) . getMessage ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testAsyncDeploy ( ) throws Exception { long start = System . currentTimeMillis ( ) ; long delay = 1000 ; MyAsyncVerticle verticle = new MyAsyncVerticle ( f - > { vertx . setTimer ( delay , id - > { f . complete ( null ) ; } ) ; } , f - > f . complete ( null ) ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; long now = System . currentTimeMillis ( ) ; assertTrue ( now - start >= delay ) ; assertTrue ( vertx . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; testComplete ( ) ; } ) ; Thread . sleep ( delay / 2 ) ; assertTrue ( vertx . deploymentIDs ( ) . isEmpty ( ) ) ; await ( ) ; } @ Test public void testAsyncDeployFailure ( ) throws Exception { long start = System . currentTimeMillis ( ) ; long delay = 1000 ; MyAsyncVerticle verticle = new MyAsyncVerticle ( f - > vertx . setTimer ( delay , id - > f . fail ( new Exception ( "foobar" ) ) ) , null ) ; vertx . deployVerticle ( verticle , ar - > { assertFalse ( ar . succeeded ( ) ) ; assertEquals ( "foobar" , ar . cause ( ) . getMessage ( ) ) ; long now = System . currentTimeMillis ( ) ; assertTrue ( now - start >= delay ) ; assertTrue ( vertx . deploymentIDs ( ) . isEmpty ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testAsyncUndeployCalledSynchronously ( ) throws Exception { MyAsyncVerticle verticle = new MyAsyncVerticle ( f - > f . complete ( null ) , f - > f . complete ( null ) ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; vertx . undeploy ( ar . result ( ) , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertFalse ( vertx . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testAsyncUndeployFailureCalledSynchronously ( ) throws Exception { MyAsyncVerticle verticle = new MyAsyncVerticle ( f - > f . complete ( null ) , f - > f . fail ( new Exception ( "foobar" ) ) ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; vertx . undeploy ( ar . result ( ) , ar2 - > { assertFalse ( ar2 . succeeded ( ) ) ; assertEquals ( "foobar" , ar2 . cause ( ) . getMessage ( ) ) ; assertFalse ( vertx . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testAsyncUndeploy ( ) throws Exception { long delay = 1000 ; MyAsyncVerticle verticle = new MyAsyncVerticle ( f - > f . complete ( null ) , f - > vertx . setTimer ( delay , id - > f . complete ( null ) ) ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; long start = System . currentTimeMillis ( ) ; vertx . undeploy ( ar . result ( ) , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; long now = System . currentTimeMillis ( ) ; assertTrue ( now - start >= delay ) ; assertFalse ( vertx . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; testComplete ( ) ; } ) ; vertx . setTimer ( delay / 2 , id - > assertFalse ( vertx . deploymentIDs ( ) . isEmpty ( ) ) ) ; } ) ; await ( ) ; } @ Test public void testAsyncUndeployFailure ( ) throws Exception { long delay = 1000 ; MyAsyncVerticle verticle = new MyAsyncVerticle ( f - > f . complete ( null ) , f - > vertx . setTimer ( delay , id - > f . fail ( new Exception ( "foobar" ) ) ) ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; long start = System . currentTimeMillis ( ) ; vertx . undeploy ( ar . result ( ) , ar2 - > { assertFalse ( ar2 . succeeded ( ) ) ; long now = System . currentTimeMillis ( ) ; assertTrue ( now - start >= delay ) ; assertFalse ( vertx . deploymentIDs ( ) . contains ( ar . result ( ) ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testChildUndeployedDirectly ( ) throws Exception { Verticle parent = new AbstractVerticle ( ) { @ Override public void start ( Future < Void > startFuture ) throws Exception { Verticle child = new AbstractVerticle ( ) { @ Override public void start ( Future < Void > startFuture ) throws Exception { startFuture . complete ( ) ; vertx . runOnContext ( v - > vertx . undeploy ( context . deploymentID ( ) ) ) ; } } ; vertx . deployVerticle ( child , onSuccess ( depID - > { startFuture . complete ( ) ; } ) ) ; } @ Override public void stop ( Future < Void > stopFuture ) throws Exception { super . stop ( stopFuture ) ; } } ; vertx . deployVerticle ( parent , onSuccess ( depID - > { vertx . setTimer ( 10 , tid - > vertx . undeploy ( depID , onSuccess ( v - > { testComplete ( ) ; } ) ) ) ; } ) ) ; await ( ) ; } @ Test public void testCloseHooksCalled ( ) throws Exception { AtomicInteger closedCount = new AtomicInteger ( ) ; Closeable myCloseable1 = completionHandler - > { closedCount . incrementAndGet ( ) ; completionHandler . handle ( Future . succeededFuture ( ) ) ; } ; Closeable myCloseable2 = completionHandler - > { closedCount . incrementAndGet ( ) ; completionHandler . handle ( Future . succeededFuture ( ) ) ; } ; MyAsyncVerticle verticle = new MyAsyncVerticle ( f - > { ContextImpl ctx = ( ContextImpl ) Vertx . currentContext ( ) ; ctx . addCloseHook ( myCloseable1 ) ; ctx . addCloseHook ( myCloseable2 ) ; f . complete ( null ) ; } , f - > f . complete ( null ) ) ; vertx . deployVerticle ( verticle , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertEquals ( 0 , closedCount . get ( ) ) ; vertx . undeploy ( ar . result ( ) , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertEquals ( 2 , closedCount . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testIsolationGroup1 ( ) throws Exception { List < String > isolatedClasses = Arrays . asList ( TestVerticle . class . getCanonicalName ( ) ) ; vertx . deployVerticle ( "java:" + TestVerticle . class . getCanonicalName ( ) , new DeploymentOptions ( ) . setIsolationGroup ( "somegroup" ) . setIsolatedClasses ( isolatedClasses ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertEquals ( 0 , TestVerticle . instanceCount . get ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testNullIsolationGroup ( ) throws Exception { vertx . deployVerticle ( "java:" + TestVerticle . class . getCanonicalName ( ) , new DeploymentOptions ( ) . setIsolationGroup ( null ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertEquals ( 1 , TestVerticle . instanceCount . get ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testIsolationGroupSameGroup ( ) throws Exception { List < String > isolatedClasses = Arrays . asList ( TestVerticle . class . getCanonicalName ( ) ) ; testIsolationGroup ( "somegroup" , "somegroup" , 1 , 2 , isolatedClasses , "java:" + TestVerticle . class . getCanonicalName ( ) ) ; } @ Test public void testIsolationGroupSameGroupWildcard ( ) throws Exception { List < String > isolatedClasses = Arrays . asList ( "io.vertx.test.core.*" ) ; testIsolationGroup ( "somegroup" , "somegroup" , 1 , 2 , isolatedClasses , "java:" + TestVerticle . class . getCanonicalName ( ) ) ; } @ Test public void testIsolationGroupDifferentGroup ( ) throws Exception { List < String > isolatedClasses = Arrays . asList ( TestVerticle . class . getCanonicalName ( ) ) ; testIsolationGroup ( "somegroup" , "someothergroup" , 1 , 1 , isolatedClasses , "java:" + TestVerticle . class . getCanonicalName ( ) ) ; } private String createClassOutsideClasspath ( String className ) throws Exception { File dir = Files . createTempDirectory ( "vertx" ) . toFile ( ) ; dir . deleteOnExit ( ) ; File source = new File ( dir , className + ".java" ) ; Files . write ( source . toPath ( ) , ( "public class " + className + " extends io.vertx.core.AbstractVerticle {} " ) . getBytes ( ) ) ; URLClassLoader loader = new URLClassLoader ( new URL [ ] { dir . toURI ( ) . toURL ( ) } , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; CompilingClassLoader compilingClassLoader = new CompilingClassLoader ( loader , className + ".java" ) ; compilingClassLoader . loadClass ( className ) ; byte [ ] bytes = compilingClassLoader . getClassBytes ( className ) ; assertNotNull ( bytes ) ; File classFile = new File ( dir , className + ".class" ) ; Files . write ( classFile . toPath ( ) , bytes ) ; return dir . getAbsolutePath ( ) ; } @ Test public void testExtraClasspathLoaderNotInParentLoader ( ) throws Exception { String dir = createClassOutsideClasspath ( "MyVerticle" ) ; List < String > extraClasspath = Arrays . asList ( dir ) ; vertx . deployVerticle ( "java:" + ExtraCPVerticleNotInParentLoader . class . getCanonicalName ( ) , new DeploymentOptions ( ) . setIsolationGroup ( "somegroup" ) . setExtraClasspath ( extraClasspath ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testExtraClasspathLoaderAlreadyInParentLoader ( ) throws Exception { String dir = createClassOutsideClasspath ( "MyVerticle" ) ; URLClassLoader loader = new URLClassLoader ( new URL [ ] { new File ( dir ) . toURI ( ) . toURL ( ) } , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; List < String > extraClasspath = Arrays . asList ( dir ) ; ClassLoader currentCL = Thread . currentThread ( ) . getContextClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( loader ) ; try { vertx . deployVerticle ( "java:" + ExtraCPVerticleAlreadyInParentLoader . class . getCanonicalName ( ) , new DeploymentOptions ( ) . setIsolationGroup ( "somegroup" ) . setExtraClasspath ( extraClasspath ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; testComplete ( ) ; } ) ; } finally { Thread . currentThread ( ) . setContextClassLoader ( currentCL ) ; } await ( ) ; } public static class ParentVerticle extends AbstractVerticle { @ Override public void start ( Future < Void > startFuture ) throws Exception { vertx . deployVerticle ( "java:" + ChildVerticle . class . getName ( ) , ar - > { if ( ar . succeeded ( ) ) { startFuture . complete ( null ) ; } else { ar . cause ( ) . printStackTrace ( ) ; } } ) ; } } public static class ChildVerticle extends AbstractVerticle { } @ Test public void testUndeployAll ( ) throws Exception { int numVerticles = 10 ; List < MyVerticle > verticles = new ArrayList < > ( ) ; CountDownLatch latch = new CountDownLatch ( numVerticles ) ; for ( int i = 0 ; i < numVerticles ; i ++ ) { MyVerticle verticle = new MyVerticle ( ) ; verticles . add ( verticle ) ; vertx . deployVerticle ( "java:" + ParentVerticle . class . getName ( ) , onSuccess ( res - > { latch . countDown ( ) ; } ) ) ; } awaitLatch ( latch ) ; assertEquals ( 2 * numVerticles , vertx . deploymentIDs ( ) . size ( ) ) ; vertx . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; assertEquals ( 0 , vertx . deploymentIDs ( ) . size ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; vertx = null ; } @ Test public void testUndeployAllFailureInUndeploy ( ) throws Exception { int numVerticles = 10 ; List < MyVerticle > verticles = new ArrayList < > ( ) ; CountDownLatch latch = new CountDownLatch ( numVerticles ) ; for ( int i = 0 ; i < numVerticles ; i ++ ) { MyVerticle verticle = new MyVerticle ( MyVerticle . NOOP , MyVerticle . THROW_EXCEPTION ) ; verticles . add ( verticle ) ; vertx . deployVerticle ( verticle , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; latch . countDown ( ) ; } ) ; } awaitLatch ( latch ) ; vertx . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; for ( MyVerticle verticle : verticles ) { assertFalse ( verticle . stopCalled ) ; } testComplete ( ) ; } ) ; await ( ) ; vertx = null ; } @ Test public void testUndeployAllNoDeployments ( ) throws Exception { vertx . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; vertx = null ; } @ Test public void testGetInstanceCount ( ) throws Exception { class MultiInstanceVerticle extends AbstractVerticle { @ Override public void start ( ) { assertEquals ( vertx . getOrCreateContext ( ) . getInstanceCount ( ) , 1 ) ; } } vertx . deployVerticle ( new MultiInstanceVerticle ( ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; Deployment deployment = ( ( VertxInternal ) vertx ) . getDeployment ( vertx . deploymentIDs ( ) . iterator ( ) . next ( ) ) ; vertx . undeploy ( deployment . deploymentID ( ) ) ; } @ Test public void testGetInstanceCountMultipleVerticles ( ) throws Exception { AtomicInteger messageCount = new AtomicInteger ( 0 ) ; AtomicInteger totalReportedInstances = new AtomicInteger ( 0 ) ; vertx . eventBus ( ) . consumer ( "instanceCount" , event - > { messageCount . incrementAndGet ( ) ; totalReportedInstances . addAndGet ( ( int ) event . body ( ) ) ; if ( messageCount . intValue ( ) == 3 ) { assertEquals ( 9 , totalReportedInstances . get ( ) ) ; testComplete ( ) ; } } ) ; vertx . deployVerticle ( TestVerticle3 . class . getCanonicalName ( ) , new DeploymentOptions ( ) . setInstances ( 3 ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; } ) ; await ( ) ; Deployment deployment = ( ( VertxInternal ) vertx ) . getDeployment ( vertx . deploymentIDs ( ) . iterator ( ) . next ( ) ) ; vertx . undeploy ( deployment . deploymentID ( ) ) ; } private void testIsolationGroup ( String group1 , String group2 , int count1 , int count2 , List < String > isolatedClasses , String verticleID ) throws Exception { Map < String , Integer > countMap = new ConcurrentHashMap < > ( ) ; vertx . eventBus ( ) . < JsonObject > consumer ( "testcounts" ) . handler ( ( Message < JsonObject > msg ) - > { countMap . put ( msg . body ( ) . getString ( "deploymentID" ) , msg . body ( ) . getInteger ( "count" ) ) ; } ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; AtomicReference < String > deploymentID1 = new AtomicReference < > ( ) ; AtomicReference < String > deploymentID2 = new AtomicReference < > ( ) ; vertx . deployVerticle ( verticleID , new DeploymentOptions ( ) . setIsolationGroup ( group1 ) . setIsolatedClasses ( isolatedClasses ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; deploymentID1 . set ( ar . result ( ) ) ; assertEquals ( 0 , TestVerticle . instanceCount . get ( ) ) ; vertx . deployVerticle ( verticleID , new DeploymentOptions ( ) . setIsolationGroup ( group2 ) . setIsolatedClasses ( isolatedClasses ) , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; deploymentID2 . set ( ar2 . result ( ) ) ; assertEquals ( 0 , TestVerticle . instanceCount . get ( ) ) ; latch . countDown ( ) ; } ) ; } ) ; awaitLatch ( latch ) ; waitUntil ( ( ) - > countMap . size ( ) == 2 ) ; assertEquals ( count1 , countMap . get ( deploymentID1 . get ( ) ) . intValue ( ) ) ; assertEquals ( count2 , countMap . get ( deploymentID2 . get ( ) ) . intValue ( ) ) ; } private void assertDeployment ( int instances , MyVerticle verticle , JsonObject config , AsyncResult < String > ar ) { assertTrue ( ar . succeeded ( ) ) ; assertEquals ( vertx , verticle . getVertx ( ) ) ; String deploymentID = ar . result ( ) ; assertNotNull ( ar . result ( ) ) ; assertEquals ( deploymentID , verticle . deploymentID ) ; if ( config == null ) { assertEquals ( 0 , verticle . config . size ( ) ) ; } else { assertEquals ( config , verticle . config ) ; } assertTrue ( verticle . startCalled ) ; assertFalse ( verticle . stopCalled ) ; assertTrue ( vertx . deploymentIDs ( ) . contains ( deploymentID ) ) ; assertEquals ( instances , vertx . deploymentIDs ( ) . size ( ) ) ; Context currentContext = Vertx . currentContext ( ) ; assertNotSame ( currentContext , verticle . startContext ) ; } private JsonObject generateJSONObject ( ) { return new JsonObject ( ) . put ( "foo" , "bar" ) . put ( "blah" , 123 ) . put ( "obj" , new JsonObject ( ) . put ( "quux" , "flip" ) ) ; } public class MyVerticle extends AbstractVerticle { static final int NOOP = 0 , THROW_EXCEPTION = 1 , THROW_ERROR = 2 ; boolean startCalled ; boolean stopCalled ; Context startContext ; Context stopContext ; int startAction ; int stopAction ; String deploymentID ; JsonObject config ; MyVerticle ( ) { this ( NOOP , NOOP ) ; } MyVerticle ( int startAction , int stopAction ) { this . startAction = startAction ; this . stopAction = stopAction ; } @ Override public void start ( ) throws Exception { switch ( startAction ) { case THROW_EXCEPTION : throw new Exception ( "FooBar!" ) ; case THROW_ERROR : throw new Error ( "FooBar!" ) ; default : startCalled = true ; startContext = Vertx . currentContext ( ) ; } deploymentID = Vertx . currentContext ( ) . deploymentID ( ) ; config = context . config ( ) ; } @ Override public void stop ( ) throws Exception { switch ( stopAction ) { case THROW_EXCEPTION : throw new Exception ( "BooFar!" ) ; case THROW_ERROR : throw new Error ( "BooFar!" ) ; default : stopCalled = true ; stopContext = Vertx . currentContext ( ) ; } } } public class MyAsyncVerticle extends AbstractVerticle { private final Consumer < Future < Void > > startConsumer ; private final Consumer < Future < Void > > stopConsumer ; public MyAsyncVerticle ( Consumer < Future < Void > > startConsumer , Consumer < Future < Void > > stopConsumer ) { this . startConsumer = startConsumer ; this . stopConsumer = stopConsumer ; } @ Override public void start ( Future < Void > startFuture ) throws Exception { if ( startConsumer != null ) { startConsumer . accept ( startFuture ) ; } } @ Override public void stop ( Future < Void > stopFuture ) throws Exception { if ( stopConsumer != null ) { stopConsumer . accept ( stopFuture ) ; } } } }
package io . vertx . core . net ; import io . vertx . codegen . annotations . DataObject ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . json . JsonObject ; @ DataObject public class NetClientOptions extends ClientOptionsBase { public static final int DEFAULT_RECONNECT_ATTEMPTS = 0 ; public static final long DEFAULT_RECONNECT_INTERVAL = 1000 ; private int reconnectAttempts ; private long reconnectInterval ; public NetClientOptions ( ) { super ( ) ; this . reconnectAttempts = DEFAULT_RECONNECT_ATTEMPTS ; this . reconnectInterval = DEFAULT_RECONNECT_INTERVAL ; } public NetClientOptions ( NetClientOptions other ) { super ( other ) ; this . reconnectAttempts = other . getReconnectAttempts ( ) ; this . reconnectInterval = other . getReconnectInterval ( ) ; } public NetClientOptions ( JsonObject json ) { super ( json ) ; this . reconnectAttempts = json . getInteger ( "reconnectAttempts" , DEFAULT_RECONNECT_ATTEMPTS ) ; this . reconnectInterval = json . getLong ( "reconnectInterval" , DEFAULT_RECONNECT_INTERVAL ) ; } @ Override public NetClientOptions setSendBufferSize ( int sendBufferSize ) { super . setSendBufferSize ( sendBufferSize ) ; return this ; } @ Override public NetClientOptions setReceiveBufferSize ( int receiveBufferSize ) { super . setReceiveBufferSize ( receiveBufferSize ) ; return this ; } @ Override public NetClientOptions setReuseAddress ( boolean reuseAddress ) { super . setReuseAddress ( reuseAddress ) ; return this ; } @ Override public NetClientOptions setTrafficClass ( int trafficClass ) { super . setTrafficClass ( trafficClass ) ; return this ; } @ Override public NetClientOptions setTcpNoDelay ( boolean tcpNoDelay ) { super . setTcpNoDelay ( tcpNoDelay ) ; return this ; } @ Override public NetClientOptions setTcpKeepAlive ( boolean tcpKeepAlive ) { super . setTcpKeepAlive ( tcpKeepAlive ) ; return this ; } @ Override public NetClientOptions setSoLinger ( int soLinger ) { super . setSoLinger ( soLinger ) ; return this ; } @ Override public NetClientOptions setUsePooledBuffers ( boolean usePooledBuffers ) { super . setUsePooledBuffers ( usePooledBuffers ) ; return this ; } @ Override public NetClientOptions setIdleTimeout ( int idleTimeout ) { super . setIdleTimeout ( idleTimeout ) ; return this ; } @ Override public NetClientOptions setSsl ( boolean ssl ) { super . setSsl ( ssl ) ; return this ; } @ Override public NetClientOptions setKeyStoreOptions ( JksOptions options ) { super . setKeyStoreOptions ( options ) ; return this ; } @ Override public NetClientOptions setPfxKeyCertOptions ( PfxOptions options ) { return ( NetClientOptions ) super . setPfxKeyCertOptions ( options ) ; } @ Override public NetClientOptions setPemKeyCertOptions ( PemKeyCertOptions options ) { return ( NetClientOptions ) super . setPemKeyCertOptions ( options ) ; } @ Override public NetClientOptions setTrustStoreOptions ( JksOptions options ) { super . setTrustStoreOptions ( options ) ; return this ; } @ Override public NetClientOptions setPemTrustOptions ( PemTrustOptions options ) { return ( NetClientOptions ) super . setPemTrustOptions ( options ) ; } @ Override public NetClientOptions setPfxTrustOptions ( PfxOptions options ) { return ( NetClientOptions ) super . setPfxTrustOptions ( options ) ; } @ Override public NetClientOptions addEnabledCipherSuite ( String suite ) { super . addEnabledCipherSuite ( suite ) ; return this ; } @ Override public NetClientOptions addCrlPath ( String crlPath ) throws NullPointerException { return ( NetClientOptions ) super . addCrlPath ( crlPath ) ; } @ Override public NetClientOptions addCrlValue ( Buffer crlValue ) throws NullPointerException { return ( NetClientOptions ) super . addCrlValue ( crlValue ) ; } @ Override public NetClientOptions setTrustAll ( boolean trustAll ) { super . setTrustAll ( trustAll ) ; return this ; } @ Override public NetClientOptions setConnectTimeout ( int connectTimeout ) { super . setConnectTimeout ( connectTimeout ) ; return this ; } public NetClientOptions setReconnectAttempts ( int attempts ) { if ( attempts < - 1 ) { throw new IllegalArgumentException ( "reconnect attempts must be >= -1" ) ; } this . reconnectAttempts = attempts ; return this ; } public int getReconnectAttempts ( ) { return reconnectAttempts ; } public NetClientOptions setReconnectInterval ( long interval ) { if ( interval < 1 ) { throw new IllegalArgumentException ( "reconnect interval nust be >= 1" ) ; } this . reconnectInterval = interval ; return this ; } public long getReconnectInterval ( ) { return reconnectInterval ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof NetClientOptions ) ) return false ; if ( ! super . equals ( o ) ) return false ; NetClientOptions that = ( NetClientOptions ) o ; if ( reconnectAttempts != that . reconnectAttempts ) return false ; if ( reconnectInterval != that . reconnectInterval ) return false ; return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + reconnectAttempts ; result = 31 * result + ( int ) ( reconnectInterval ^ ( reconnectInterval > > > 32 ) ) ; return result ; } }
package io . vertx . core . net . impl ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import java . net . Socket ; public class SocketDefaults { private static final Logger log = LoggerFactory . getLogger ( SocketDefaults . class ) ; public static final SocketDefaults instance = new SocketDefaults ( ) ; private boolean tcpNoDelay = true ; private int tcpSendBufferSize ; private int tcpReceiveBufferSize ; private boolean tcpKeepAlive ; private boolean reuseAddress ; private int soLinger ; private int trafficClass ; private SocketDefaults ( ) { try { Socket csock = new Socket ( ) ; tcpNoDelay = csock . getTcpNoDelay ( ) ; tcpSendBufferSize = csock . getSendBufferSize ( ) ; tcpReceiveBufferSize = csock . getReceiveBufferSize ( ) ; tcpKeepAlive = csock . getKeepAlive ( ) ; reuseAddress = csock . getReuseAddress ( ) ; soLinger = csock . getSoLinger ( ) ; trafficClass = csock . getTrafficClass ( ) ; } catch ( Exception e ) { log . warn ( "Failed to read socket defaults, using Vert.x defaults instead" ) ; tcpNoDelay = true ; tcpSendBufferSize = 8 * 1024 ; tcpReceiveBufferSize = 32 * 1024 ; tcpKeepAlive = false ; reuseAddress = false ; soLinger = - 1 ; trafficClass = 0 ; } } public boolean isTcpNoDelay ( ) { return tcpNoDelay ; } public int getTcpSendBufferSize ( ) { return tcpSendBufferSize ; } public int getTcpReceiveBufferSize ( ) { return tcpReceiveBufferSize ; } public boolean isTcpKeepAlive ( ) { return tcpKeepAlive ; } public boolean isReuseAddress ( ) { return reuseAddress ; } public int getSoLinger ( ) { return soLinger ; } public int getTrafficClass ( ) { return trafficClass ; } }
package io . vertx . core . net . impl ; import java . io . Serializable ; public class ServerID implements Serializable { public int port ; public String host ; public ServerID ( int port , String host ) { this . port = port ; this . host = host ; } public ServerID ( ) { } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || ! ( o instanceof ServerID ) ) return false ; ServerID serverID = ( ServerID ) o ; if ( port != serverID . port ) return false ; if ( ! host . equals ( serverID . host ) ) return false ; return true ; } @ Override public int hashCode ( ) { int result = port ; result = 31 * result + host . hashCode ( ) ; return result ; } public String toString ( ) { return host + ":" + port ; } }
package io . vertx . core . net . impl ; import io . netty . channel . * ; import io . netty . util . concurrent . * ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; @ SuppressWarnings ( "deprecation" ) public final class VertxEventLoopGroup extends AbstractEventExecutorGroup implements EventLoopGroup { private int pos ; private final List < EventLoopHolder > workers = new ArrayList < > ( ) ; private final CountDownLatch latch = new CountDownLatch ( 1 ) ; private final AtomicBoolean gracefulShutdown = new AtomicBoolean ( ) ; private final Promise < ? > terminationFuture = new DefaultPromise < Void > ( GlobalEventExecutor . INSTANCE ) ; @ Override public synchronized EventLoop next ( ) { if ( workers . isEmpty ( ) ) { throw new IllegalStateException ( ) ; } else { EventLoop worker = workers . get ( pos ) . worker ; pos ++ ; checkPos ( ) ; return worker ; } } @ Override public Iterator < EventExecutor > iterator ( ) { return new EventLoopIterator ( workers . iterator ( ) ) ; } @ Override public ChannelFuture register ( Channel channel ) { return next ( ) . register ( channel ) ; } @ Override public ChannelFuture register ( Channel channel , ChannelPromise promise ) { return next ( ) . register ( channel , promise ) ; } @ Override public boolean isShutdown ( ) { return latch . getCount ( ) == 0 ; } @ Override public boolean isTerminated ( ) { return isShutdown ( ) ; } @ Override public synchronized boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { return latch . await ( timeout , unit ) ; } public synchronized void addWorker ( EventLoop worker ) { VertxEventLoopGroup . EventLoopHolder holder = holder ( worker ) ; if ( holder == null ) { workers . add ( new EventLoopHolder ( worker ) ) ; } else { } } private VertxEventLoopGroup . EventLoopHolder holder ( EventLoop worker ) { EventLoopHolder holder = findHolder ( worker ) ; if ( holder == null ) { } else { holder . count ++ ; } return holder ; } public synchronized void shutdown ( ) { for ( EventLoopHolder holder : workers ) { holder . worker . shutdown ( ) ; } latch . countDown ( ) ; } @ Override public boolean isShuttingDown ( ) { return gracefulShutdown . get ( ) ; } @ Override public Future < ? > shutdownGracefully ( long quietPeriod , long timeout , TimeUnit unit ) { if ( gracefulShutdown . compareAndSet ( false , true ) ) { final AtomicInteger counter = new AtomicInteger ( workers . size ( ) ) ; for ( EventLoopHolder holder : workers ) { holder . worker . shutdownGracefully ( ) . addListener ( new GenericFutureListener ( ) { @ Override public void operationComplete ( Future future ) throws Exception { if ( counter . decrementAndGet ( ) == 0 ) { terminationFuture . setSuccess ( null ) ; } } } ) ; } } return terminationFuture ; } @ Override public Future < ? > terminationFuture ( ) { return terminationFuture ; } private EventLoopHolder findHolder ( EventLoop worker ) { EventLoopHolder wh = new EventLoopHolder ( worker ) ; for ( EventLoopHolder holder : workers ) { if ( holder . equals ( wh ) ) { return holder ; } } return null ; } public synchronized void removeWorker ( EventLoop worker ) { EventLoopHolder holder = findHolder ( worker ) ; if ( holder != null ) { holder . count -- ; if ( holder . count == 0 ) { workers . remove ( holder ) ; } checkPos ( ) ; } else { throw new IllegalStateException ( "Can't find worker to remove" ) ; } } public synchronized int workerCount ( ) { return workers . size ( ) ; } private void checkPos ( ) { if ( pos == workers . size ( ) ) { pos = 0 ; } } private static class EventLoopHolder { int count = 1 ; final EventLoop worker ; EventLoopHolder ( EventLoop worker ) { this . worker = worker ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; EventLoopHolder that = ( EventLoopHolder ) o ; if ( worker != null ? ! worker . equals ( that . worker ) : that . worker != null ) return false ; return true ; } @ Override public int hashCode ( ) { return worker != null ? worker . hashCode ( ) : 0 ; } } private static final class EventLoopIterator implements Iterator < EventExecutor > { private final Iterator < EventLoopHolder > holderIt ; public EventLoopIterator ( Iterator < EventLoopHolder > holderIt ) { this . holderIt = holderIt ; } @ Override public boolean hasNext ( ) { return holderIt . hasNext ( ) ; } @ Override public EventExecutor next ( ) { return holderIt . next ( ) . worker ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "read-only" ) ; } } }
package io . vertx . core . net . impl ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelOption ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . EventLoop ; import io . netty . channel . FixedRecvByteBufAllocator ; import io . netty . channel . group . ChannelGroup ; import io . netty . channel . group . ChannelGroupFuture ; import io . netty . channel . group . DefaultChannelGroup ; import io . netty . channel . socket . nio . NioServerSocketChannel ; import io . netty . handler . ssl . SslHandler ; import io . netty . handler . stream . ChunkedWriteHandler ; import io . netty . handler . timeout . IdleStateHandler ; import io . netty . util . concurrent . GlobalEventExecutor ; import io . vertx . core . AsyncResult ; import io . vertx . core . AsyncResultHandler ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . impl . Closeable ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . spi . metrics . Metrics ; import io . vertx . core . spi . metrics . MetricsProvider ; import io . vertx . core . spi . metrics . TCPMetrics ; import io . vertx . core . net . NetServer ; import io . vertx . core . net . NetServerOptions ; import io . vertx . core . net . NetSocket ; import io . vertx . core . net . NetSocketStream ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . util . LinkedList ; import java . util . Map ; import java . util . Queue ; import java . util . concurrent . ConcurrentHashMap ; public class NetServerImpl implements NetServer , Closeable , MetricsProvider { private static final Logger log = LoggerFactory . getLogger ( NetServerImpl . class ) ; private final VertxInternal vertx ; private final NetServerOptions options ; private final ContextImpl creatingContext ; private final SSLHelper sslHelper ; private final Map < Channel , NetSocketImpl > socketMap = new ConcurrentHashMap < > ( ) ; private final VertxEventLoopGroup availableWorkers = new VertxEventLoopGroup ( ) ; private final HandlerManager < NetSocket > handlerManager = new HandlerManager < > ( availableWorkers ) ; private final Queue < Runnable > bindListeners = new LinkedList < > ( ) ; private final NetSocketStreamImpl connectStream = new NetSocketStreamImpl ( ) ; private ChannelGroup serverChannelGroup ; private volatile boolean listening ; private volatile ServerID id ; private NetServerImpl actualServer ; private ChannelFuture bindFuture ; private volatile int actualPort ; private boolean listenersRun ; private ContextImpl listenContext ; private TCPMetrics metrics ; public NetServerImpl ( VertxInternal vertx , NetServerOptions options ) { this . vertx = vertx ; this . options = new NetServerOptions ( options ) ; this . sslHelper = new SSLHelper ( options , KeyStoreHelper . create ( vertx , options . getKeyCertOptions ( ) ) , KeyStoreHelper . create ( vertx , options . getTrustOptions ( ) ) ) ; this . creatingContext = vertx . getContext ( ) ; if ( creatingContext != null ) { if ( creatingContext . isMultiThreadedWorkerContext ( ) ) { throw new IllegalStateException ( "Cannot use NetServer in a multi-threaded worker verticle" ) ; } creatingContext . addCloseHook ( this ) ; } } @ Override public NetServer connectHandler ( Handler < NetSocket > handler ) { connectStream . handler ( handler ) ; return this ; } @ Override public Handler < NetSocket > connectHandler ( ) { return connectStream . handler ( ) ; } @ Override public NetSocketStream connectStream ( ) { return connectStream ; } @ Override public NetServer listen ( int port , String host ) { return listen ( port , host , null ) ; } @ Override public NetServer listen ( int port ) { return listen ( port , "0.0.0.0" , null ) ; } @ Override public NetServer listen ( int port , Handler < AsyncResult < NetServer > > listenHandler ) { return listen ( port , "0.0.0.0" , listenHandler ) ; } @ Override public NetServer listen ( ) { listen ( null ) ; return this ; } @ Override public synchronized NetServer listen ( Handler < AsyncResult < NetServer > > listenHandler ) { return listen ( options . getPort ( ) , options . getHost ( ) , listenHandler ) ; } @ Override public synchronized NetServer listen ( int port , String host , Handler < AsyncResult < NetServer > > listenHandler ) { if ( connectStream . handler ( ) == null ) { throw new IllegalStateException ( "Set connect handler first" ) ; } if ( listening ) { throw new IllegalStateException ( "Listen already called" ) ; } listening = true ; listenContext = vertx . getOrCreateContext ( ) ; synchronized ( vertx . sharedNetServers ( ) ) { this . actualPort = port ; id = new ServerID ( port , host ) ; NetServerImpl shared = vertx . sharedNetServers ( ) . get ( id ) ; if ( shared == null || port == 0 ) { serverChannelGroup = new DefaultChannelGroup ( "vertx-acceptor-channels" , GlobalEventExecutor . INSTANCE ) ; ServerBootstrap bootstrap = new ServerBootstrap ( ) ; bootstrap . group ( availableWorkers ) ; bootstrap . channel ( NioServerSocketChannel . class ) ; sslHelper . validate ( vertx ) ; bootstrap . childHandler ( new ChannelInitializer < Channel > ( ) { @ Override protected void initChannel ( Channel ch ) throws Exception { if ( connectStream . isPaused ( ) ) { ch . close ( ) ; return ; } ChannelPipeline pipeline = ch . pipeline ( ) ; if ( sslHelper . isSSL ( ) ) { SslHandler sslHandler = sslHelper . createSslHandler ( vertx , false ) ; pipeline . addLast ( "ssl" , sslHandler ) ; } if ( sslHelper . isSSL ( ) ) { pipeline . addLast ( "chunkedWriter" , new ChunkedWriteHandler ( ) ) ; } if ( options . getIdleTimeout ( ) > 0 ) { pipeline . addLast ( "idle" , new IdleStateHandler ( 0 , 0 , options . getIdleTimeout ( ) ) ) ; } pipeline . addLast ( "handler" , new ServerHandler ( ) ) ; } } ) ; applyConnectionOptions ( bootstrap ) ; handlerManager ( ) ; try { InetSocketAddress addr = new InetSocketAddress ( InetAddress . getByName ( host ) , port ) ; bindFuture = bootstrap . bind ( addr ) . addListener ( future - > runListeners ( ) ) ; this . addListener ( ( ) - > { if ( bindFuture . isSuccess ( ) ) { log . trace ( "Net server listening on " + host + ":" + bindFuture . channel ( ) . localAddress ( ) ) ; NetServerImpl . this . actualPort = ( ( InetSocketAddress ) bindFuture . channel ( ) . localAddress ( ) ) . getPort ( ) ; NetServerImpl . this . id = new ServerID ( NetServerImpl . this . actualPort , id . host ) ; vertx . sharedNetServers ( ) . put ( id , NetServerImpl . this ) ; metrics = vertx . metricsSPI ( ) . createMetrics ( this , new SocketAddressImpl ( id . port , id . host ) , options ) ; } else { vertx . sharedNetServers ( ) . remove ( id ) ; } } ) ; serverChannelGroup . add ( bindFuture . channel ( ) ) ; } catch ( Throwable t ) { if ( listenHandler != null ) { vertx . runOnContext ( v - > listenHandler . handle ( Future . failedFuture ( t ) ) ) ; } else { log . error ( t ) ; } listening = false ; return this ; } if ( port != 0 ) { vertx . sharedNetServers ( ) . put ( id , this ) ; } actualServer = this ; } else { actualServer ( shared ) ; this . actualPort = shared . actualPort ( ) ; metrics = vertx . metricsSPI ( ) . createMetrics ( this , new SocketAddressImpl ( id . port , id . host ) , options ) ; } actualServer . addListener ( ( ) - > { if ( listenHandler != null ) { AsyncResult < NetServer > res ; if ( actualServer . bindFuture . isSuccess ( ) ) { res = Future . succeededFuture ( NetServerImpl . this ) ; } else { listening = false ; res = Future . failedFuture ( actualServer . bindFuture . cause ( ) ) ; } listenContext . runOnContext ( v - > listenHandler . handle ( res ) ) ; } else if ( ! actualServer . bindFuture . isSuccess ( ) ) { log . error ( "Failed to listen" , actualServer . bindFuture . cause ( ) ) ; listening = false ; } } ) ; } return this ; } private void handlerManager ( ) { if ( connectStream . handler ( ) != null ) { handlerManager . addHandler ( connectStream . handler ( ) , listenContext ) ; } } private void actualServer ( NetServerImpl shared ) { actualServer = shared ; if ( connectStream . handler ( ) != null ) { actualServer . handlerManager . addHandler ( connectStream . handler ( ) , listenContext ) ; } } public synchronized void close ( ) { close ( null ) ; } @ Override public synchronized void close ( Handler < AsyncResult < Void > > done ) { done = donee ( done ) ; ContextImpl context = vertx . getOrCreateContext ( ) ; if ( ! listening ) { if ( done != null ) { executeCloseDone ( context , done , null ) ; } return ; } listening = false ; synchronized ( vertx . sharedNetServers ( ) ) { if ( actualServer != null ) { actualServer . handlerManager . removeHandler ( connectStream . handler ( ) , listenContext ) ; if ( actualServer . handlerManager . hasHandlers ( ) ) { if ( done != null ) { executeCloseDone ( context , done , null ) ; } } else { actualServer . actualClose ( context , done ) ; } } } if ( creatingContext != null ) { creatingContext . removeCloseHook ( this ) ; } } private Handler < AsyncResult < Void > > donee ( Handler < AsyncResult < Void > > done ) { if ( connectStream . endHandler ( ) != null ) { done = done ( done ) ; } return done ; } private Handler < AsyncResult < Void > > done ( Handler < AsyncResult < Void > > done ) { Handler < Void > endHandler = connectStream . endHandler ; connectStream . endHandler = null ; Handler < AsyncResult < Void > > next = done ; done = new AsyncResultHandler < Void > ( ) { @ Override public void handle ( AsyncResult < Void > event ) { if ( event . succeeded ( ) ) { endHandler . handle ( event . result ( ) ) ; } if ( next != null ) { next . handle ( event ) ; } } } ; return done ; } @ Override public synchronized int actualPort ( ) { return actualPort ; } @ Override public boolean isMetricsEnabled ( ) { return metrics != null && metrics . isEnabled ( ) ; } @ Override public Metrics getMetrics ( ) { return metrics ; } private void applyConnectionOptions ( ServerBootstrap bootstrap ) { bootstrap . childOption ( ChannelOption . TCP_NODELAY , options . isTcpNoDelay ( ) ) ; if ( options . getSendBufferSize ( ) != - 1 ) { bootstrap . childOption ( ChannelOption . SO_SNDBUF , options . getSendBufferSize ( ) ) ; } if ( options . getReceiveBufferSize ( ) != - 1 ) { bootstrap . childOption ( ChannelOption . SO_RCVBUF , options . getReceiveBufferSize ( ) ) ; bootstrap . childOption ( ChannelOption . RCVBUF_ALLOCATOR , new FixedRecvByteBufAllocator ( options . getReceiveBufferSize ( ) ) ) ; } bootstrap . option ( ChannelOption . SO_LINGER , options . getSoLinger ( ) ) ; if ( options . getTrafficClass ( ) != - 1 ) { bootstrap . childOption ( ChannelOption . IP_TOS , options . getTrafficClass ( ) ) ; } bootstrap . childOption ( ChannelOption . ALLOCATOR , PartialPooledByteBufAllocator . INSTANCE ) ; bootstrap . childOption ( ChannelOption . SO_KEEPALIVE , options . isTcpKeepAlive ( ) ) ; bootstrap . option ( ChannelOption . SO_REUSEADDR , options . isReuseAddress ( ) ) ; bootstrap . option ( ChannelOption . SO_BACKLOG , options . getAcceptBacklog ( ) ) ; } private synchronized void addListener ( Runnable runner ) { if ( ! listenersRun ) { bindListeners . add ( runner ) ; } else { runner . run ( ) ; } } private synchronized void runListeners ( ) { Runnable runner ; while ( ( runner = bindListeners . poll ( ) ) != null ) { runner . run ( ) ; } listenersRun = true ; } private void actualClose ( ContextImpl closeContext , Handler < AsyncResult < Void > > done ) { if ( id != null ) { vertx . sharedNetServers ( ) . remove ( id ) ; } ContextImpl currCon = vertx . getContext ( ) ; for ( NetSocketImpl sock : socketMap . values ( ) ) { sock . close ( ) ; } if ( vertx . getContext ( ) != currCon ) { throw new IllegalStateException ( "Context was changed" ) ; } ChannelGroupFuture fut = serverChannelGroup . close ( ) ; fut . addListener ( cg - > { if ( metrics != null ) { metrics . close ( ) ; } executeCloseDone ( closeContext , done , fut . cause ( ) ) ; } ) ; } private void executeCloseDone ( ContextImpl closeContext , Handler < AsyncResult < Void > > done , Exception e ) { if ( done != null ) { closeContext . runOnContext ( v - > done . handle ( Future . failedFuture ( e ) ) ) ; } } private class ServerHandler extends VertxNetHandler { public ServerHandler ( ) { super ( socketMap ) ; } @ Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { Channel ch = ctx . channel ( ) ; EventLoop worker = ch . eventLoop ( ) ; HandlerHolder < NetSocket > handler = handlerManager . chooseHandler ( worker ) ; if ( handler == null ) { return ; } if ( sslHelper . isSSL ( ) ) { SslHandler sslHandler = ch . pipeline ( ) . get ( SslHandler . class ) ; io . netty . util . concurrent . Future < Channel > fut = sslHandler . handshakeFuture ( ) ; fut . addListener ( future - > { if ( future . isSuccess ( ) ) { connected ( ch , handler ) ; } else { log . error ( "Client from origin " + ch . remoteAddress ( ) + " failed to connect over ssl" ) ; } } ) ; } else { connected ( ch , handler ) ; } } private void connected ( Channel ch , HandlerHolder < NetSocket > handler ) { ContextImpl . setContext ( handler . context ) ; NetSocketImpl sock = new NetSocketImpl ( vertx , ch , handler . context , sslHelper , false , metrics , null ) ; socketMap . put ( ch , sock ) ; handler . context . executeFromIO ( ( ) - > { sock . setMetric ( metrics . connected ( sock . remoteAddress ( ) ) ) ; handler . handler . handle ( sock ) ; } ) ; } } @ Override protected void finalize ( ) throws Throwable { close ( ) ; super . finalize ( ) ; } private class NetSocketStreamImpl implements NetSocketStream { private Handler < NetSocket > handler ; private boolean paused ; private Handler < Void > endHandler ; Handler < NetSocket > handler ( ) { synchronized ( NetServerImpl . this ) { return handler ; } } boolean isPaused ( ) { synchronized ( NetServerImpl . this ) { return paused ; } } Handler < Void > endHandler ( ) { synchronized ( NetServerImpl . this ) { return endHandler ; } } @ Override public NetSocketStreamImpl handler ( Handler < NetSocket > handler ) { synchronized ( NetServerImpl . this ) { if ( listening ) { throw new IllegalStateException ( "Cannot set connectHandler when server is listening" ) ; } this . handler = handler ; return this ; } } @ Override public NetSocketStreamImpl pause ( ) { synchronized ( NetServerImpl . this ) { if ( ! paused ) { paused = true ; } return this ; } } @ Override public NetSocketStreamImpl resume ( ) { synchronized ( NetServerImpl . this ) { if ( paused ) { paused = false ; } return this ; } } @ Override public NetSocketStreamImpl endHandler ( Handler < Void > endHandler ) { synchronized ( NetServerImpl . this ) { this . endHandler = endHandler ; return this ; } } @ Override public NetSocketStreamImpl exceptionHandler ( Handler < Throwable > handler ) { return this ; } } }
package io . vertx . core . net . impl ; import io . netty . handler . ssl . SslHandler ; import io . vertx . core . VertxException ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . http . HttpClientOptions ; import io . vertx . core . http . HttpServerOptions ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . net . NetClientOptions ; import io . vertx . core . net . NetServerOptions ; import javax . net . ssl . KeyManager ; import javax . net . ssl . SSLContext ; import javax . net . ssl . SSLEngine ; import javax . net . ssl . SSLParameters ; import javax . net . ssl . TrustManager ; import javax . net . ssl . X509TrustManager ; import java . io . ByteArrayInputStream ; import java . security . SecureRandom ; import java . security . cert . CRL ; import java . security . cert . CertificateException ; import java . security . cert . CertificateFactory ; import java . security . cert . X509Certificate ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; import java . util . stream . Collectors ; import java . util . stream . Stream ; public class SSLHelper { private static final Logger log = LoggerFactory . getLogger ( SSLHelper . class ) ; private static final String [ ] ENABLED_PROTOCOLS = { "SSLv2Hello" , "TLSv1" , "TLSv1.1" , "TLSv1.2" } ; private boolean ssl ; private KeyStoreHelper keyStoreHelper ; private KeyStoreHelper trustStoreHelper ; private boolean trustAll ; private ArrayList < String > crlPaths ; private ArrayList < Buffer > crlValues ; private ClientAuth clientAuth = ClientAuth . NONE ; private Set < String > enabledCipherSuites ; private boolean verifyHost ; private SSLContext sslContext ; public SSLHelper ( HttpClientOptions options , KeyStoreHelper keyStoreHelper , KeyStoreHelper trustStoreHelper ) { this . ssl = options . isSsl ( ) ; this . keyStoreHelper = keyStoreHelper ; this . trustStoreHelper = trustStoreHelper ; this . trustAll = options . isTrustAll ( ) ; this . crlPaths = new ArrayList < > ( options . getCrlPaths ( ) ) ; this . crlValues = new ArrayList < > ( options . getCrlValues ( ) ) ; this . enabledCipherSuites = options . getEnabledCipherSuites ( ) ; this . verifyHost = options . isVerifyHost ( ) ; } public SSLHelper ( HttpServerOptions options , KeyStoreHelper keyStoreHelper , KeyStoreHelper trustStoreHelper ) { this . ssl = options . isSsl ( ) ; this . keyStoreHelper = keyStoreHelper ; this . trustStoreHelper = trustStoreHelper ; this . clientAuth = options . isClientAuthRequired ( ) ? ClientAuth . REQUIRED : ClientAuth . NONE ; this . crlPaths = options . getCrlPaths ( ) != null ? new ArrayList < > ( options . getCrlPaths ( ) ) : null ; this . crlValues = options . getCrlValues ( ) != null ? new ArrayList < > ( options . getCrlValues ( ) ) : null ; this . enabledCipherSuites = options . getEnabledCipherSuites ( ) ; } public SSLHelper ( NetClientOptions options , KeyStoreHelper keyStoreHelper , KeyStoreHelper trustStoreHelper ) { this . ssl = options . isSsl ( ) ; this . keyStoreHelper = keyStoreHelper ; this . trustStoreHelper = trustStoreHelper ; this . trustAll = options . isTrustAll ( ) ; this . crlPaths = new ArrayList < > ( options . getCrlPaths ( ) ) ; this . crlValues = new ArrayList < > ( options . getCrlValues ( ) ) ; this . enabledCipherSuites = options . getEnabledCipherSuites ( ) ; } public SSLHelper ( NetServerOptions options , KeyStoreHelper keyStoreHelper , KeyStoreHelper trustStoreHelper ) { this . ssl = options . isSsl ( ) ; this . keyStoreHelper = keyStoreHelper ; this . trustStoreHelper = trustStoreHelper ; this . clientAuth = options . isClientAuthRequired ( ) ? ClientAuth . REQUIRED : ClientAuth . NONE ; this . crlPaths = options . getCrlPaths ( ) != null ? new ArrayList < > ( options . getCrlPaths ( ) ) : null ; this . crlValues = options . getCrlValues ( ) != null ? new ArrayList < > ( options . getCrlValues ( ) ) : null ; this . enabledCipherSuites = options . getEnabledCipherSuites ( ) ; } public enum ClientAuth { NONE , REQUEST , REQUIRED } public boolean isSSL ( ) { return ssl ; } public ClientAuth getClientAuth ( ) { return clientAuth ; } private SSLContext createContext ( VertxInternal vertx ) { try { SSLContext context = SSLContext . getInstance ( "TLS" ) ; KeyManager [ ] keyMgrs = keyStoreHelper == null ? null : keyStoreHelper . getKeyMgrs ( vertx ) ; TrustManager [ ] trustMgrs ; if ( trustAll ) { trustMgrs = new TrustManager [ ] { createTrustAllTrustManager ( ) } ; } else { trustMgrs = trustStoreHelper == null ? null : trustStoreHelper . getTrustMgrs ( vertx ) ; } if ( trustMgrs != null && crlPaths != null && crlValues != null && ( crlPaths . size ( ) > 0 || crlValues . size ( ) > 0 ) ) { Stream < Buffer > tmp = crlPaths . stream ( ) . map ( path - > vertx . resolveFile ( path ) . getAbsolutePath ( ) ) . map ( vertx . fileSystem ( ) : : readFileBlocking ) ; tmp = Stream . concat ( tmp , crlValues . stream ( ) ) ; CertificateFactory certificatefactory = CertificateFactory . getInstance ( "X.509" ) ; ArrayList < CRL > crls = new ArrayList < > ( ) ; for ( Buffer crlValue : tmp . collect ( Collectors . toList ( ) ) ) { crls . addAll ( certificatefactory . generateCRLs ( new ByteArrayInputStream ( crlValue . getBytes ( ) ) ) ) ; } trustMgrs = createUntrustRevokedCertTrustManager ( trustMgrs , crls ) ; } context . init ( keyMgrs , trustMgrs , new SecureRandom ( ) ) ; return context ; } catch ( Exception e ) { throw new VertxException ( e ) ; } } private static TrustManager [ ] createUntrustRevokedCertTrustManager ( TrustManager [ ] trustMgrs , ArrayList < CRL > crls ) { trustMgrs = trustMgrs . clone ( ) ; for ( int i = 0 ; i < trustMgrs . length ; i ++ ) { TrustManager trustMgr = trustMgrs [ i ] ; if ( trustMgr instanceof X509TrustManager ) { X509TrustManager x509TrustManager = ( X509TrustManager ) trustMgr ; trustMgrs [ i ] = new X509TrustManager ( ) { @ Override public void checkClientTrusted ( X509Certificate [ ] x509Certificates , String s ) throws CertificateException { checkRevocaked ( x509Certificates ) ; x509TrustManager . checkClientTrusted ( x509Certificates , s ) ; } @ Override public void checkServerTrusted ( X509Certificate [ ] x509Certificates , String s ) throws CertificateException { checkRevocaked ( x509Certificates ) ; x509TrustManager . checkServerTrusted ( x509Certificates , s ) ; } private void checkRevocaked ( X509Certificate [ ] x509Certificates ) throws CertificateException { for ( X509Certificate cert : x509Certificates ) { for ( CRL crl : crls ) { if ( crl . isRevoked ( cert ) ) { throw new CertificateException ( "Certificate revoked" ) ; } } } } @ Override public X509Certificate [ ] getAcceptedIssuers ( ) { return x509TrustManager . getAcceptedIssuers ( ) ; } } ; } } return trustMgrs ; } private static TrustManager createTrustAllTrustManager ( ) { return new X509TrustManager ( ) { @ Override public void checkClientTrusted ( X509Certificate [ ] x509Certificates , String s ) throws CertificateException { } @ Override public void checkServerTrusted ( X509Certificate [ ] x509Certificates , String s ) throws CertificateException { } @ Override public X509Certificate [ ] getAcceptedIssuers ( ) { return new X509Certificate [ 0 ] ; } } ; } private SslHandler createHandler ( SSLEngine engine , boolean client ) { if ( enabledCipherSuites != null && ! enabledCipherSuites . isEmpty ( ) ) { String [ ] toUse = enabledCipherSuites . toArray ( new String [ enabledCipherSuites . size ( ) ] ) ; engine . setEnabledCipherSuites ( toUse ) ; } engine . setUseClientMode ( client ) ; Set < String > enabledProtocols = new HashSet < > ( Arrays . asList ( ENABLED_PROTOCOLS ) ) ; enabledProtocols . retainAll ( Arrays . asList ( engine . getEnabledProtocols ( ) ) ) ; engine . setEnabledProtocols ( enabledProtocols . toArray ( new String [ 0 ] ) ) ; if ( ! client ) { switch ( getClientAuth ( ) ) { case REQUEST : { engine . setWantClientAuth ( true ) ; break ; } case REQUIRED : { engine . setNeedClientAuth ( true ) ; break ; } case NONE : { engine . setNeedClientAuth ( false ) ; break ; } } } else if ( verifyHost ) { SSLParameters sslParameters = engine . getSSLParameters ( ) ; sslParameters . setEndpointIdentificationAlgorithm ( "HTTPS" ) ; engine . setSSLParameters ( sslParameters ) ; } return new SslHandler ( engine ) ; } private SSLContext getContext ( VertxInternal vertx ) { if ( sslContext == null ) { sslContext = createContext ( vertx ) ; } return sslContext ; } public synchronized void validate ( VertxInternal vertx ) { if ( ssl ) { getContext ( vertx ) ; } } public SslHandler createSslHandler ( VertxInternal vertx , boolean client , String host , int port ) { SSLEngine engine = getContext ( vertx ) . createSSLEngine ( host , port ) ; return createHandler ( engine , client ) ; } public SslHandler createSslHandler ( VertxInternal vertx , boolean client ) { SSLEngine engine = getContext ( vertx ) . createSSLEngine ( ) ; return createHandler ( engine , client ) ; } }
package io . vertx . core . net . impl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . CompositeByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelDuplexHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . timeout . IdleState ; import io . netty . handler . timeout . IdleStateEvent ; import io . vertx . core . impl . ContextImpl ; public abstract class VertxHandler < C extends ConnectionBase > extends ChannelDuplexHandler { protected abstract C getConnection ( Channel ch ) ; protected abstract C removeConnection ( Channel ch ) ; protected ContextImpl getContext ( C connection ) { return connection . getContext ( ) ; } protected static ByteBuf safeBuffer ( ByteBuf buf , ByteBufAllocator allocator ) { if ( buf == Unpooled . EMPTY_BUFFER ) { return buf ; } if ( buf . isDirect ( ) || buf instanceof CompositeByteBuf ) { try { if ( buf . isReadable ( ) ) { ByteBuf buffer = allocator . heapBuffer ( buf . readableBytes ( ) ) ; buffer . writeBytes ( buf ) ; return buffer ; } else { return Unpooled . EMPTY_BUFFER ; } } finally { buf . release ( ) ; } } return buf ; } @ Override public void channelWritabilityChanged ( ChannelHandlerContext ctx ) throws Exception { Channel ch = ctx . channel ( ) ; C conn = getConnection ( ch ) ; if ( conn != null ) { ContextImpl context = getContext ( conn ) ; context . executeFromIO ( conn : : handleInterestedOpsChanged ) ; } } @ Override public void exceptionCaught ( ChannelHandlerContext chctx , final Throwable t ) throws Exception { Channel ch = chctx . channel ( ) ; C connection = getConnection ( ch ) ; if ( connection != null ) { ContextImpl context = getContext ( connection ) ; context . executeFromIO ( ( ) - > { try { if ( ch . isOpen ( ) ) { ch . close ( ) ; } } catch ( Throwable ignore ) { } connection . handleException ( t ) ; } ) ; } else { ch . close ( ) ; } } @ Override public void channelInactive ( ChannelHandlerContext chctx ) throws Exception { Channel ch = chctx . channel ( ) ; C connection = removeConnection ( ch ) ; if ( connection != null ) { ContextImpl context = getContext ( connection ) ; context . executeFromIO ( connection : : handleClosed ) ; } } @ Override public void channelReadComplete ( ChannelHandlerContext ctx ) throws Exception { C conn = getConnection ( ctx . channel ( ) ) ; if ( conn != null ) { ContextImpl context = getContext ( conn ) ; context . executeFromIO ( conn : : endReadAndFlush ) ; } } @ Override public void channelRead ( ChannelHandlerContext chctx , Object msg ) throws Exception { Object message = safeObject ( msg , chctx . alloc ( ) ) ; C connection = getConnection ( chctx . channel ( ) ) ; ContextImpl context ; if ( connection != null ) { context = getContext ( connection ) ; context . executeFromIO ( connection : : startRead ) ; } else { context = null ; } channelRead ( connection , context , chctx , message ) ; } @ Override public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception { if ( evt instanceof IdleStateEvent && ( ( IdleStateEvent ) evt ) . state ( ) == IdleState . ALL_IDLE ) { ctx . close ( ) ; } } protected abstract void channelRead ( C connection , ContextImpl context , ChannelHandlerContext chctx , Object msg ) throws Exception ; protected abstract Object safeObject ( Object msg , ByteBufAllocator allocator ) throws Exception ; }
package io . vertx . core . net . impl ; import io . netty . channel . EventLoop ; import io . vertx . core . Handler ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import java . util . List ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CopyOnWriteArrayList ; public class HandlerManager < T > { @ SuppressWarnings ( "unused" ) private static final Logger log = LoggerFactory . getLogger ( HandlerManager . class ) ; private final VertxEventLoopGroup availableWorkers ; private final ConcurrentMap < EventLoop , Handlers < T > > handlerMap = new ConcurrentHashMap < > ( ) ; private volatile boolean hasHandlers ; public HandlerManager ( VertxEventLoopGroup availableWorkers ) { this . availableWorkers = availableWorkers ; } public boolean hasHandlers ( ) { return hasHandlers ; } public HandlerHolder < T > chooseHandler ( EventLoop worker ) { Handlers < T > handlers = handlerMap . get ( worker ) ; return handlers == null ? null : handlers . chooseHandler ( ) ; } public synchronized void addHandler ( Handler < T > handler , ContextImpl context ) { EventLoop worker = context . eventLoop ( ) ; availableWorkers . addWorker ( worker ) ; Handlers < T > handlers = new Handlers < > ( ) ; Handlers < T > prev = handlerMap . putIfAbsent ( worker , handlers ) ; if ( prev != null ) { handlers = prev ; } handlers . addHandler ( new HandlerHolder < > ( context , handler ) ) ; hasHandlers = true ; } public synchronized void removeHandler ( Handler < T > handler , ContextImpl context ) { EventLoop worker = context . eventLoop ( ) ; Handlers < T > handlers = handlerMap . get ( worker ) ; if ( ! handlers . removeHandler ( new HandlerHolder < > ( context , handler ) ) ) { throw new IllegalStateException ( "Can't find handler" ) ; } if ( handlers . isEmpty ( ) ) { handlerMap . remove ( worker ) ; } if ( handlers . isEmpty ( ) ) { hasHandlers = false ; } availableWorkers . removeWorker ( worker ) ; } private static final class Handlers < T > { private int pos ; private final List < HandlerHolder < T > > list = new CopyOnWriteArrayList < > ( ) ; HandlerHolder < T > chooseHandler ( ) { HandlerHolder < T > handler = list . get ( pos ) ; pos ++ ; checkPos ( ) ; return handler ; } void addHandler ( HandlerHolder < T > handler ) { list . add ( handler ) ; } boolean removeHandler ( HandlerHolder < T > handler ) { if ( list . remove ( handler ) ) { checkPos ( ) ; return true ; } else { return false ; } } boolean isEmpty ( ) { return list . isEmpty ( ) ; } void checkPos ( ) { if ( pos == list . size ( ) ) { pos = 0 ; } } } }
package io . vertx . core . net . impl ; import io . vertx . core . impl . Arguments ; import io . vertx . core . net . SocketAddress ; import java . util . Objects ; public class SocketAddressImpl implements SocketAddress { private final String hostAddress ; private final int port ; public SocketAddressImpl ( int port , String host ) { Objects . requireNonNull ( host , "no null host accepted" ) ; Arguments . require ( ! host . isEmpty ( ) , "no empty host accepted" ) ; Arguments . requireInRange ( port , 0 , 65535 , "port p must be in range 0 <= p <= 65535" ) ; this . port = port ; this . hostAddress = host ; } public String host ( ) { return hostAddress ; } public int port ( ) { return port ; } public String toString ( ) { return hostAddress + ":" + port ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; SocketAddressImpl that = ( SocketAddressImpl ) o ; if ( port != that . port ) return false ; if ( hostAddress != null ? ! hostAddress . equals ( that . hostAddress ) : that . hostAddress != null ) return false ; return true ; } @ Override public int hashCode ( ) { int result = hostAddress != null ? hostAddress . hashCode ( ) : 0 ; result = 31 * result + port ; return result ; } }
package io . vertx . core . net . impl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . impl . ContextImpl ; import java . util . Map ; public class VertxNetHandler extends VertxHandler < NetSocketImpl > { private final Map < Channel , NetSocketImpl > connectionMap ; public VertxNetHandler ( Map < Channel , NetSocketImpl > connectionMap ) { this . connectionMap = connectionMap ; } @ Override protected NetSocketImpl getConnection ( Channel channel ) { return connectionMap . get ( channel ) ; } @ Override protected NetSocketImpl removeConnection ( Channel channel ) { return connectionMap . remove ( channel ) ; } @ Override protected void channelRead ( NetSocketImpl sock , ContextImpl context , ChannelHandlerContext chctx , Object msg ) throws Exception { if ( sock != null ) { ByteBuf buf = ( ByteBuf ) msg ; context . executeFromIO ( ( ) - > sock . handleDataReceived ( Buffer . buffer ( buf ) ) ) ; } else { } } @ Override protected Object safeObject ( Object msg , ByteBufAllocator allocator ) throws Exception { if ( msg instanceof ByteBuf ) { return safeBuffer ( ( ByteBuf ) msg , allocator ) ; } return msg ; } }
package io . vertx . test . core ; import io . vertx . core . Context ; import org . junit . Test ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicReference ; public class ExecuteBlockingTest extends VertxTestBase { @ Test public void testExecuteBlockingSuccess ( ) { vertx . executeBlocking ( future - > { try { Thread . sleep ( 1000 ) ; } catch ( Exception ignore ) { } future . complete ( "done!" ) ; } , onSuccess ( res - > { assertEquals ( "done!" , res ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testExecuteBlockingFailed ( ) { vertx . executeBlocking ( future - > { try { Thread . sleep ( 1000 ) ; } catch ( Exception ignore ) { } future . fail ( "failed!" ) ; } , onFailure ( t - > { assertEquals ( "failed!" , t . getMessage ( ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testExecuteBlockingThrowsRTE ( ) { vertx . executeBlocking ( future - > { throw new RuntimeException ( "rte" ) ; } , onFailure ( t - > { assertEquals ( "rte" , t . getMessage ( ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testExecuteBlockingContext ( ) { vertx . runOnContext ( v - > { Context ctx = vertx . getOrCreateContext ( ) ; assertTrue ( ctx . isEventLoopContext ( ) ) ; vertx . executeBlocking ( future - > { assertSame ( ctx , vertx . getOrCreateContext ( ) ) ; assertTrue ( Thread . currentThread ( ) . getName ( ) . startsWith ( "vert.x-worker-thread" ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; assertFalse ( Context . isOnEventLoopThread ( ) ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception ignore ) { } vertx . runOnContext ( v2 - > { assertSame ( ctx , vertx . getOrCreateContext ( ) ) ; assertTrue ( Thread . currentThread ( ) . getName ( ) . startsWith ( "vert.x-eventloop-thread" ) ) ; assertFalse ( Context . isOnWorkerThread ( ) ) ; assertTrue ( Context . isOnEventLoopThread ( ) ) ; future . complete ( "done!" ) ; } ) ; } , onSuccess ( res - > { assertSame ( ctx , vertx . getOrCreateContext ( ) ) ; assertTrue ( Thread . currentThread ( ) . getName ( ) . startsWith ( "vert.x-eventloop-thread" ) ) ; assertFalse ( Context . isOnWorkerThread ( ) ) ; assertTrue ( Context . isOnEventLoopThread ( ) ) ; assertEquals ( "done!" , res ) ; testComplete ( ) ; } ) ) ; } ) ; await ( ) ; } @ Test public void testExecuteBlockingTTCL ( ) throws Exception { ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; assertNotNull ( cl ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; AtomicReference < ClassLoader > blockingTCCL = new AtomicReference < > ( ) ; vertx . < String > executeBlocking ( future - > { future . complete ( "whatever" ) ; blockingTCCL . set ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertEquals ( "whatever" , ar . result ( ) ) ; latch . countDown ( ) ; } ) ; assertSame ( cl , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; awaitLatch ( latch ) ; assertSame ( cl , blockingTCCL . get ( ) ) ; } @ Test public void testExecuteBlockingParallel ( ) throws Exception { long start = System . currentTimeMillis ( ) ; int numExecBlocking = 10 ; long pause = 1000 ; CountDownLatch latch = new CountDownLatch ( numExecBlocking ) ; vertx . runOnContext ( v - > { Context ctx = vertx . getOrCreateContext ( ) ; assertTrue ( ctx . isEventLoopContext ( ) ) ; for ( int i = 0 ; i < numExecBlocking ; i ++ ) { vertx . executeBlocking ( future - > { assertSame ( ctx , vertx . getOrCreateContext ( ) ) ; assertTrue ( Thread . currentThread ( ) . getName ( ) . startsWith ( "vert.x-worker-thread" ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; assertFalse ( Context . isOnEventLoopThread ( ) ) ; try { Thread . sleep ( pause ) ; } catch ( Exception ignore ) { } future . complete ( "done!" ) ; } , false , onSuccess ( res - > { assertSame ( ctx , vertx . getOrCreateContext ( ) ) ; assertTrue ( Thread . currentThread ( ) . getName ( ) . startsWith ( "vert.x-eventloop-thread" ) ) ; assertFalse ( Context . isOnWorkerThread ( ) ) ; assertTrue ( Context . isOnEventLoopThread ( ) ) ; assertEquals ( "done!" , res ) ; latch . countDown ( ) ; } ) ) ; } } ) ; awaitLatch ( latch ) ; long now = System . currentTimeMillis ( ) ; long leeway = 1000 ; assertTrue ( now - start < pause + leeway ) ; } }
package io . vertx . core . net . impl ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . net . PemTrustOptions ; import io . vertx . core . net . JksOptions ; import io . vertx . core . net . PemKeyCertOptions ; import io . vertx . core . net . KeyCertOptions ; import io . vertx . core . net . PfxOptions ; import io . vertx . core . net . TrustOptions ; import javax . net . ssl . KeyManager ; import javax . net . ssl . KeyManagerFactory ; import javax . net . ssl . TrustManager ; import javax . net . ssl . TrustManagerFactory ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . security . KeyFactory ; import java . security . KeyStore ; import java . security . PrivateKey ; import java . security . cert . Certificate ; import java . security . cert . CertificateFactory ; import java . security . spec . PKCS8EncodedKeySpec ; import java . util . Base64 ; import java . util . function . Supplier ; import java . util . stream . Stream ; public abstract class KeyStoreHelper { private static final String DUMMY_PASSWORD = "dummy" ; public static KeyStoreHelper create ( VertxInternal vertx , KeyCertOptions options ) { if ( options instanceof JksOptions ) { JksOptions jks = ( JksOptions ) options ; Supplier < Buffer > value ; if ( jks . getPath ( ) != null ) { value = ( ) - > vertx . fileSystem ( ) . readFileBlocking ( vertx . resolveFile ( jks . getPath ( ) ) . getAbsolutePath ( ) ) ; } else if ( jks . getValue ( ) != null ) { value = jks : : getValue ; } else { return null ; } return new JKSOrPKCS12 ( "JKS" , jks . getPassword ( ) , value ) ; } else if ( options instanceof PfxOptions ) { PfxOptions pkcs12 = ( PfxOptions ) options ; Supplier < Buffer > value ; if ( pkcs12 . getPath ( ) != null ) { value = ( ) - > vertx . fileSystem ( ) . readFileBlocking ( vertx . resolveFile ( pkcs12 . getPath ( ) ) . getAbsolutePath ( ) ) ; } else if ( pkcs12 . getValue ( ) != null ) { value = pkcs12 : : getValue ; } else { return null ; } return new JKSOrPKCS12 ( "PKCS12" , pkcs12 . getPassword ( ) , value ) ; } else if ( options instanceof PemKeyCertOptions ) { PemKeyCertOptions keyCert = ( PemKeyCertOptions ) options ; Supplier < Buffer > key = ( ) - > { if ( keyCert . getKeyPath ( ) != null ) { return vertx . fileSystem ( ) . readFileBlocking ( vertx . resolveFile ( keyCert . getKeyPath ( ) ) . getAbsolutePath ( ) ) ; } else if ( keyCert . getKeyValue ( ) != null ) { return keyCert . getKeyValue ( ) ; } else { throw new RuntimeException ( "Missing private key" ) ; } } ; Supplier < Buffer > cert = ( ) - > { if ( keyCert . getCertPath ( ) != null ) { return vertx . fileSystem ( ) . readFileBlocking ( vertx . resolveFile ( keyCert . getCertPath ( ) ) . getAbsolutePath ( ) ) ; } else if ( keyCert . getCertValue ( ) != null ) { return keyCert . getCertValue ( ) ; } else { throw new RuntimeException ( "Missing X.509 certificate" ) ; } } ; return new KeyCert ( DUMMY_PASSWORD , key , cert ) ; } else { return null ; } } public static KeyStoreHelper create ( VertxInternal vertx , TrustOptions options ) { if ( options instanceof KeyCertOptions ) { return create ( vertx , ( KeyCertOptions ) options ) ; } else if ( options instanceof PemTrustOptions ) { PemTrustOptions trustOptions = ( PemTrustOptions ) options ; Stream < Buffer > certValues = trustOptions . getCertPaths ( ) . stream ( ) . map ( path - > vertx . resolveFile ( path ) . getAbsolutePath ( ) ) . map ( vertx . fileSystem ( ) : : readFileBlocking ) ; certValues = Stream . concat ( certValues , trustOptions . getCertValues ( ) . stream ( ) ) ; return new CA ( certValues ) ; } else { return null ; } } private String password ; public KeyStoreHelper ( String password ) { this . password = password ; } public KeyManager [ ] getKeyMgrs ( VertxInternal vertx ) throws Exception { KeyManagerFactory fact = KeyManagerFactory . getInstance ( KeyManagerFactory . getDefaultAlgorithm ( ) ) ; KeyStore ks = loadStore ( vertx , password ) ; fact . init ( ks , password != null ? password . toCharArray ( ) : null ) ; return fact . getKeyManagers ( ) ; } public TrustManager [ ] getTrustMgrs ( VertxInternal vertx ) throws Exception { TrustManagerFactory fact = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; KeyStore ts = loadStore ( vertx , password ) ; fact . init ( ts ) ; return fact . getTrustManagers ( ) ; } protected abstract KeyStore loadStore ( VertxInternal vertx , String password ) throws Exception ; static class JKSOrPKCS12 extends KeyStoreHelper { private String type ; private Supplier < Buffer > value ; JKSOrPKCS12 ( String type , String password , Supplier < Buffer > value ) { super ( password ) ; this . type = type ; this . value = value ; } protected KeyStore loadStore ( VertxInternal vertx , String ksPassword ) throws Exception { KeyStore ks = KeyStore . getInstance ( type ) ; InputStream in = null ; try { in = new ByteArrayInputStream ( value . get ( ) . getBytes ( ) ) ; ks . load ( in , ksPassword != null ? ksPassword . toCharArray ( ) : null ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException ignore ) { } } } return ks ; } } static class KeyCert extends KeyStoreHelper { private Supplier < Buffer > keyValue ; private Supplier < Buffer > certValue ; KeyCert ( String password , Supplier < Buffer > keyValue , Supplier < Buffer > certValue ) { super ( password ) ; this . keyValue = keyValue ; this . certValue = certValue ; } @ Override protected KeyStore loadStore ( VertxInternal vertx , String password ) throws Exception { KeyStore keyStore = KeyStore . getInstance ( "jks" ) ; keyStore . load ( null , null ) ; PrivateKey key = loadPrivateKey ( this . keyValue . get ( ) ) ; Certificate [ ] chain = loadCert ( this . certValue . get ( ) ) ; keyStore . setEntry ( "dummy-entry" , new KeyStore . PrivateKeyEntry ( key , chain ) , new KeyStore . PasswordProtection ( DUMMY_PASSWORD . toCharArray ( ) ) ) ; return keyStore ; } } static class CA extends KeyStoreHelper { private Stream < Buffer > certValues ; CA ( Stream < Buffer > certValues ) { super ( null ) ; this . certValues = certValues ; } @ Override protected KeyStore loadStore ( VertxInternal vertx , String password ) throws Exception { KeyStore keyStore = KeyStore . getInstance ( "jks" ) ; keyStore . load ( null , null ) ; int count = 0 ; Iterable < Buffer > iterable = certValues : : iterator ; for ( Buffer certValue : iterable ) { for ( Certificate cert : loadCert ( certValue ) ) { keyStore . setCertificateEntry ( "cert-" + count , cert ) ; } } return keyStore ; } } private static byte [ ] loadPem ( Buffer data , String delimiter ) throws IOException { String pem = data . toString ( ) ; String beginDelimiter = "-----BEGIN " + delimiter + "-----" ; String endDelimiter = "-----END " + delimiter + "-----" ; int begin = pem . indexOf ( beginDelimiter ) ; if ( begin == - 1 ) { throw new RuntimeException ( "Missing " + beginDelimiter + " delimiter" ) ; } begin += beginDelimiter . length ( ) ; int end = pem . indexOf ( endDelimiter , begin ) ; if ( end == - 1 ) { throw new RuntimeException ( "Missing " + endDelimiter + " delimiter" ) ; } String content = pem . substring ( begin , end ) ; content = content . replaceAll ( "\\s" , "" ) ; if ( content . length ( ) == 0 ) { throw new RuntimeException ( "Empty pem file" ) ; } return Base64 . getDecoder ( ) . decode ( content ) ; } private static PrivateKey loadPrivateKey ( Buffer key ) throws Exception { if ( key == null ) { throw new RuntimeException ( "Missing private key path" ) ; } byte [ ] value = loadPem ( key , "PRIVATE KEY" ) ; KeyFactory rsaKeyFactory = KeyFactory . getInstance ( "RSA" ) ; return rsaKeyFactory . generatePrivate ( new PKCS8EncodedKeySpec ( value ) ) ; } private static Certificate [ ] loadCert ( Buffer cert ) throws Exception { if ( cert == null ) { throw new RuntimeException ( "Missing X.509 certificate path" ) ; } byte [ ] value = loadPem ( cert , "CERTIFICATE" ) ; CertificateFactory certFactory = CertificateFactory . getInstance ( "X.509" ) ; return certFactory . generateCertificates ( new ByteArrayInputStream ( value ) ) . toArray ( new Certificate [ 0 ] ) ; } }
package io . vertx . core . net . impl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . CompositeByteBuf ; import io . netty . buffer . PooledByteBufAllocator ; import io . netty . buffer . UnpooledByteBufAllocator ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelProgressivePromise ; import io . netty . channel . ChannelPromise ; import io . netty . util . Attribute ; import io . netty . util . AttributeKey ; import io . netty . util . concurrent . EventExecutor ; import java . net . SocketAddress ; public final class PartialPooledByteBufAllocator implements ByteBufAllocator { private static final ByteBufAllocator POOLED = new PooledByteBufAllocator ( true ) ; private static final ByteBufAllocator UNPOOLED = new UnpooledByteBufAllocator ( false ) ; public static final PartialPooledByteBufAllocator INSTANCE = new PartialPooledByteBufAllocator ( ) ; private PartialPooledByteBufAllocator ( ) { } @ Override public ByteBuf buffer ( ) { return UNPOOLED . heapBuffer ( ) ; } @ Override public ByteBuf buffer ( int initialCapacity ) { return UNPOOLED . heapBuffer ( initialCapacity ) ; } @ Override public ByteBuf buffer ( int initialCapacity , int maxCapacity ) { return UNPOOLED . heapBuffer ( initialCapacity , maxCapacity ) ; } @ Override public ByteBuf ioBuffer ( ) { return POOLED . directBuffer ( ) ; } @ Override public ByteBuf ioBuffer ( int initialCapacity ) { return POOLED . directBuffer ( initialCapacity ) ; } @ Override public ByteBuf ioBuffer ( int initialCapacity , int maxCapacity ) { return POOLED . directBuffer ( initialCapacity , maxCapacity ) ; } @ Override public ByteBuf heapBuffer ( ) { return UNPOOLED . heapBuffer ( ) ; } @ Override public ByteBuf heapBuffer ( int initialCapacity ) { return UNPOOLED . heapBuffer ( initialCapacity ) ; } @ Override public ByteBuf heapBuffer ( int initialCapacity , int maxCapacity ) { return UNPOOLED . heapBuffer ( initialCapacity , maxCapacity ) ; } @ Override public ByteBuf directBuffer ( ) { return POOLED . directBuffer ( ) ; } @ Override public ByteBuf directBuffer ( int initialCapacity ) { return POOLED . directBuffer ( initialCapacity ) ; } @ Override public ByteBuf directBuffer ( int initialCapacity , int maxCapacity ) { return POOLED . directBuffer ( initialCapacity , maxCapacity ) ; } @ Override public CompositeByteBuf compositeBuffer ( ) { return UNPOOLED . compositeHeapBuffer ( ) ; } @ Override public CompositeByteBuf compositeBuffer ( int maxNumComponents ) { return UNPOOLED . compositeHeapBuffer ( maxNumComponents ) ; } @ Override public CompositeByteBuf compositeHeapBuffer ( ) { return UNPOOLED . compositeHeapBuffer ( ) ; } @ Override public CompositeByteBuf compositeHeapBuffer ( int maxNumComponents ) { return UNPOOLED . compositeHeapBuffer ( maxNumComponents ) ; } @ Override public CompositeByteBuf compositeDirectBuffer ( ) { return POOLED . compositeDirectBuffer ( ) ; } @ Override public CompositeByteBuf compositeDirectBuffer ( int maxNumComponents ) { return POOLED . compositeDirectBuffer ( ) ; } @ Override public boolean isDirectBufferPooled ( ) { return true ; } public static ChannelHandlerContext forceDirectAllocator ( ChannelHandlerContext ctx ) { return new PooledChannelHandlerContext ( ctx ) ; } private static final class PooledChannelHandlerContext implements ChannelHandlerContext { private final ChannelHandlerContext ctx ; PooledChannelHandlerContext ( ChannelHandlerContext ctx ) { this . ctx = ctx ; } @ Override public Channel channel ( ) { return ctx . channel ( ) ; } @ Override public EventExecutor executor ( ) { return ctx . executor ( ) ; } @ Override public String name ( ) { return ctx . name ( ) ; } @ Override public ChannelHandler handler ( ) { return ctx . handler ( ) ; } @ Override public boolean isRemoved ( ) { return ctx . isRemoved ( ) ; } @ Override public ChannelHandlerContext fireChannelRegistered ( ) { ctx . fireChannelRegistered ( ) ; return this ; } @ Deprecated @ Override public ChannelHandlerContext fireChannelUnregistered ( ) { ctx . fireChannelUnregistered ( ) ; return this ; } @ Override public ChannelHandlerContext fireChannelActive ( ) { ctx . fireChannelActive ( ) ; return this ; } @ Override public ChannelHandlerContext fireChannelInactive ( ) { ctx . fireChannelInactive ( ) ; return this ; } @ Override public ChannelHandlerContext fireExceptionCaught ( Throwable cause ) { ctx . fireExceptionCaught ( cause ) ; return this ; } @ Override public ChannelHandlerContext fireUserEventTriggered ( Object event ) { ctx . fireUserEventTriggered ( event ) ; return this ; } @ Override public ChannelHandlerContext fireChannelRead ( Object msg ) { ctx . fireChannelRead ( msg ) ; return this ; } @ Override public ChannelHandlerContext fireChannelReadComplete ( ) { ctx . fireChannelReadComplete ( ) ; return this ; } @ Override public ChannelHandlerContext fireChannelWritabilityChanged ( ) { ctx . fireChannelWritabilityChanged ( ) ; return this ; } @ Override public ChannelFuture bind ( SocketAddress localAddress ) { return ctx . bind ( localAddress ) ; } @ Override public ChannelFuture connect ( SocketAddress remoteAddress ) { return ctx . connect ( remoteAddress ) ; } @ Override public ChannelFuture connect ( SocketAddress remoteAddress , SocketAddress localAddress ) { return ctx . connect ( remoteAddress , localAddress ) ; } @ Override public ChannelFuture disconnect ( ) { return ctx . disconnect ( ) ; } @ Override public ChannelFuture close ( ) { return ctx . close ( ) ; } @ Deprecated @ Override public ChannelFuture deregister ( ) { return ctx . deregister ( ) ; } @ Override public ChannelFuture bind ( SocketAddress localAddress , ChannelPromise promise ) { return ctx . bind ( localAddress , promise ) ; } @ Override public ChannelFuture connect ( SocketAddress remoteAddress , ChannelPromise promise ) { return ctx . connect ( remoteAddress , promise ) ; } @ Override public ChannelFuture connect ( SocketAddress remoteAddress , SocketAddress localAddress , ChannelPromise promise ) { return ctx . connect ( remoteAddress , localAddress , promise ) ; } @ Override public ChannelFuture disconnect ( ChannelPromise promise ) { return ctx . disconnect ( promise ) ; } @ Override public ChannelFuture close ( ChannelPromise promise ) { return ctx . close ( promise ) ; } @ Deprecated @ Override public ChannelFuture deregister ( ChannelPromise promise ) { return ctx . deregister ( promise ) ; } @ Override public ChannelHandlerContext read ( ) { ctx . read ( ) ; return this ; } @ Override public ChannelFuture write ( Object msg ) { return ctx . write ( msg ) ; } @ Override public ChannelFuture write ( Object msg , ChannelPromise promise ) { return ctx . write ( msg , promise ) ; } @ Override public ChannelHandlerContext flush ( ) { ctx . flush ( ) ; return this ; } @ Override public ChannelFuture writeAndFlush ( Object msg , ChannelPromise promise ) { return ctx . writeAndFlush ( msg , promise ) ; } @ Override public ChannelFuture writeAndFlush ( Object msg ) { return ctx . writeAndFlush ( msg ) ; } @ Override public ChannelPipeline pipeline ( ) { return ctx . pipeline ( ) ; } @ Override public ByteBufAllocator alloc ( ) { return ForceDirectPoooledByteBufAllocator . INSTANCE ; } @ Override public ChannelPromise newPromise ( ) { return ctx . newPromise ( ) ; } @ Override public ChannelProgressivePromise newProgressivePromise ( ) { return ctx . newProgressivePromise ( ) ; } @ Override public ChannelFuture newSucceededFuture ( ) { return ctx . newSucceededFuture ( ) ; } @ Override public ChannelFuture newFailedFuture ( Throwable cause ) { return ctx . newFailedFuture ( cause ) ; } @ Override public ChannelPromise voidPromise ( ) { return ctx . voidPromise ( ) ; } @ Override public < T > Attribute < T > attr ( AttributeKey < T > key ) { return ctx . attr ( key ) ; } } private static final class ForceDirectPoooledByteBufAllocator implements ByteBufAllocator { static ByteBufAllocator INSTANCE = new ForceDirectPoooledByteBufAllocator ( ) ; @ Override public ByteBuf buffer ( ) { return PartialPooledByteBufAllocator . INSTANCE . directBuffer ( ) ; } @ Override public ByteBuf buffer ( int initialCapacity ) { return PartialPooledByteBufAllocator . INSTANCE . directBuffer ( initialCapacity ) ; } @ Override public ByteBuf buffer ( int initialCapacity , int maxCapacity ) { return PartialPooledByteBufAllocator . INSTANCE . directBuffer ( initialCapacity , maxCapacity ) ; } @ Override public ByteBuf ioBuffer ( ) { return PartialPooledByteBufAllocator . INSTANCE . directBuffer ( ) ; } @ Override public ByteBuf ioBuffer ( int initialCapacity ) { return PartialPooledByteBufAllocator . INSTANCE . directBuffer ( initialCapacity ) ; } @ Override public ByteBuf ioBuffer ( int initialCapacity , int maxCapacity ) { return PartialPooledByteBufAllocator . INSTANCE . directBuffer ( initialCapacity , maxCapacity ) ; } @ Override public ByteBuf heapBuffer ( ) { return PartialPooledByteBufAllocator . INSTANCE . heapBuffer ( ) ; } @ Override public ByteBuf heapBuffer ( int initialCapacity ) { return PartialPooledByteBufAllocator . INSTANCE . heapBuffer ( initialCapacity ) ; } @ Override public ByteBuf heapBuffer ( int initialCapacity , int maxCapacity ) { return PartialPooledByteBufAllocator . INSTANCE . heapBuffer ( initialCapacity , maxCapacity ) ; } @ Override public ByteBuf directBuffer ( ) { return PartialPooledByteBufAllocator . INSTANCE . directBuffer ( ) ; } @ Override public ByteBuf directBuffer ( int initialCapacity ) { return PartialPooledByteBufAllocator . INSTANCE . directBuffer ( initialCapacity ) ; } @ Override public ByteBuf directBuffer ( int initialCapacity , int maxCapacity ) { return PartialPooledByteBufAllocator . INSTANCE . directBuffer ( initialCapacity , maxCapacity ) ; } @ Override public CompositeByteBuf compositeBuffer ( ) { return PartialPooledByteBufAllocator . INSTANCE . compositeBuffer ( ) ; } @ Override public CompositeByteBuf compositeBuffer ( int maxNumComponents ) { return PartialPooledByteBufAllocator . INSTANCE . compositeBuffer ( maxNumComponents ) ; } @ Override public CompositeByteBuf compositeHeapBuffer ( ) { return PartialPooledByteBufAllocator . INSTANCE . compositeHeapBuffer ( ) ; } @ Override public CompositeByteBuf compositeHeapBuffer ( int maxNumComponents ) { return PartialPooledByteBufAllocator . INSTANCE . compositeHeapBuffer ( maxNumComponents ) ; } @ Override public CompositeByteBuf compositeDirectBuffer ( ) { return PartialPooledByteBufAllocator . INSTANCE . compositeDirectBuffer ( ) ; } @ Override public CompositeByteBuf compositeDirectBuffer ( int maxNumComponents ) { return PartialPooledByteBufAllocator . INSTANCE . compositeDirectBuffer ( maxNumComponents ) ; } @ Override public boolean isDirectBufferPooled ( ) { return PartialPooledByteBufAllocator . INSTANCE . isDirectBufferPooled ( ) ; } } }
package io . vertx . core . net . impl ; import io . netty . bootstrap . Bootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelOption ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . FixedRecvByteBufAllocator ; import io . netty . channel . socket . nio . NioSocketChannel ; import io . netty . handler . ssl . SslHandler ; import io . netty . handler . stream . ChunkedWriteHandler ; import io . netty . handler . timeout . IdleStateHandler ; import io . vertx . core . AsyncResult ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . impl . Closeable ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . spi . metrics . Metrics ; import io . vertx . core . spi . metrics . MetricsProvider ; import io . vertx . core . spi . metrics . TCPMetrics ; import io . vertx . core . net . NetClient ; import io . vertx . core . net . NetClientOptions ; import io . vertx . core . net . NetSocket ; import java . net . InetSocketAddress ; import java . util . Map ; import java . util . Objects ; import java . util . concurrent . ConcurrentHashMap ; public class NetClientImpl implements NetClient , MetricsProvider { private static final Logger log = LoggerFactory . getLogger ( NetClientImpl . class ) ; private final VertxInternal vertx ; private final NetClientOptions options ; private final SSLHelper sslHelper ; private final Map < Channel , NetSocketImpl > socketMap = new ConcurrentHashMap < > ( ) ; private final Closeable closeHook ; private final ContextImpl creatingContext ; private final TCPMetrics metrics ; private volatile boolean closed ; public NetClientImpl ( VertxInternal vertx , NetClientOptions options ) { this ( vertx , options , true ) ; } public NetClientImpl ( VertxInternal vertx , NetClientOptions options , boolean useCreatingContext ) { this . vertx = vertx ; this . options = new NetClientOptions ( options ) ; this . sslHelper = new SSLHelper ( options , KeyStoreHelper . create ( vertx , options . getKeyCertOptions ( ) ) , KeyStoreHelper . create ( vertx , options . getTrustOptions ( ) ) ) ; this . closeHook = completionHandler - > { NetClientImpl . this . close ( ) ; completionHandler . handle ( Future . succeededFuture ( ) ) ; } ; if ( useCreatingContext ) { creatingContext = vertx . getContext ( ) ; if ( creatingContext != null ) { if ( creatingContext . isMultiThreadedWorkerContext ( ) ) { throw new IllegalStateException ( "Cannot use NetClient in a multi-threaded worker verticle" ) ; } creatingContext . addCloseHook ( closeHook ) ; } } else { creatingContext = null ; } this . metrics = vertx . metricsSPI ( ) . createMetrics ( this , options ) ; } public synchronized NetClient connect ( int port , String host , Handler < AsyncResult < NetSocket > > connectHandler ) { checkClosed ( ) ; connect ( port , host , connectHandler , options . getReconnectAttempts ( ) ) ; return this ; } @ Override public void close ( ) { if ( ! closed ) { for ( NetSocket sock : socketMap . values ( ) ) { sock . close ( ) ; } if ( creatingContext != null ) { creatingContext . removeCloseHook ( closeHook ) ; } closed = true ; metrics . close ( ) ; } } @ Override public boolean isMetricsEnabled ( ) { return metrics != null && metrics . isEnabled ( ) ; } @ Override public Metrics getMetrics ( ) { return metrics ; } private void checkClosed ( ) { if ( closed ) { throw new IllegalStateException ( "Client is closed" ) ; } } private void applyConnectionOptions ( Bootstrap bootstrap ) { bootstrap . option ( ChannelOption . TCP_NODELAY , options . isTcpNoDelay ( ) ) ; if ( options . getSendBufferSize ( ) != - 1 ) { bootstrap . option ( ChannelOption . SO_SNDBUF , options . getSendBufferSize ( ) ) ; } if ( options . getReceiveBufferSize ( ) != - 1 ) { bootstrap . option ( ChannelOption . SO_RCVBUF , options . getReceiveBufferSize ( ) ) ; bootstrap . option ( ChannelOption . RCVBUF_ALLOCATOR , new FixedRecvByteBufAllocator ( options . getReceiveBufferSize ( ) ) ) ; } bootstrap . option ( ChannelOption . SO_LINGER , options . getSoLinger ( ) ) ; if ( options . getTrafficClass ( ) != - 1 ) { bootstrap . option ( ChannelOption . IP_TOS , options . getTrafficClass ( ) ) ; } bootstrap . option ( ChannelOption . CONNECT_TIMEOUT_MILLIS , options . getConnectTimeout ( ) ) ; bootstrap . option ( ChannelOption . ALLOCATOR , PartialPooledByteBufAllocator . INSTANCE ) ; bootstrap . option ( ChannelOption . SO_KEEPALIVE , options . isTcpKeepAlive ( ) ) ; } private void connect ( int port , String host , Handler < AsyncResult < NetSocket > > connectHandler , int remainingAttempts ) { Objects . requireNonNull ( host , "No null host accepted" ) ; Objects . requireNonNull ( connectHandler , "No null connectHandler accepted" ) ; ContextImpl context = vertx . getOrCreateContext ( ) ; sslHelper . validate ( vertx ) ; Bootstrap bootstrap = new Bootstrap ( ) ; bootstrap . group ( context . eventLoop ( ) ) ; bootstrap . channel ( NioSocketChannel . class ) ; bootstrap . handler ( new ChannelInitializer < Channel > ( ) { @ Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline pipeline = ch . pipeline ( ) ; if ( sslHelper . isSSL ( ) ) { SslHandler sslHandler = sslHelper . createSslHandler ( vertx , true ) ; pipeline . addLast ( "ssl" , sslHandler ) ; } if ( sslHelper . isSSL ( ) ) { pipeline . addLast ( "chunkedWriter" , new ChunkedWriteHandler ( ) ) ; } if ( options . getIdleTimeout ( ) > 0 ) { pipeline . addLast ( "idle" , new IdleStateHandler ( 0 , 0 , options . getIdleTimeout ( ) ) ) ; } pipeline . addLast ( "handler" , new VertxNetHandler ( socketMap ) ) ; } } ) ; applyConnectionOptions ( bootstrap ) ; ChannelFuture future = bootstrap . connect ( new InetSocketAddress ( host , port ) ) ; future . addListener ( ( ChannelFuture channelFuture ) - > { Channel ch = channelFuture . channel ( ) ; if ( channelFuture . isSuccess ( ) ) { if ( sslHelper . isSSL ( ) ) { SslHandler sslHandler = ch . pipeline ( ) . get ( SslHandler . class ) ; io . netty . util . concurrent . Future < Channel > fut = sslHandler . handshakeFuture ( ) ; fut . addListener ( future2 - > { if ( future2 . isSuccess ( ) ) { connected ( context , ch , connectHandler ) ; } else { failed ( context , ch , future2 . cause ( ) , connectHandler ) ; } } ) ; } else { connected ( context , ch , connectHandler ) ; } } else { if ( remainingAttempts > 0 || remainingAttempts == - 1 ) { context . executeFromIO ( ( ) - > { log . debug ( "Failed to create connection. Will retry in " + options . getReconnectInterval ( ) + " milliseconds" ) ; vertx . setTimer ( options . getReconnectInterval ( ) , tid - > connect ( port , host , connectHandler , remainingAttempts == - 1 ? remainingAttempts : remainingAttempts - 1 ) ) ; } ) ; } else { failed ( context , ch , channelFuture . cause ( ) , connectHandler ) ; } } } ) ; } private void connected ( ContextImpl context , Channel ch , Handler < AsyncResult < NetSocket > > connectHandler ) { ContextImpl . setContext ( context ) ; NetSocketImpl sock = new NetSocketImpl ( vertx , ch , context , sslHelper , true , metrics , null ) ; socketMap . put ( ch , sock ) ; context . executeFromIO ( ( ) - > { sock . setMetric ( metrics . connected ( sock . remoteAddress ( ) ) ) ; connectHandler . handle ( Future . succeededFuture ( sock ) ) ; } ) ; } private void failed ( ContextImpl context , Channel ch , Throwable t , Handler < AsyncResult < NetSocket > > connectHandler ) { ch . close ( ) ; context . executeFromIO ( ( ) - > doFailed ( connectHandler , t ) ) ; } private static void doFailed ( Handler < AsyncResult < NetSocket > > connectHandler , Throwable t ) { connectHandler . handle ( Future . failedFuture ( t ) ) ; } @ Override protected void finalize ( ) throws Throwable { close ( ) ; super . finalize ( ) ; } }
package io . vertx . core . net . impl ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . DefaultFileRegion ; import io . netty . channel . FileRegion ; import io . netty . handler . ssl . SslHandler ; import io . netty . handler . stream . ChunkedFile ; import io . vertx . core . AsyncResult ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . spi . metrics . NetworkMetrics ; import io . vertx . core . spi . metrics . TCPMetrics ; import io . vertx . core . net . SocketAddress ; import javax . net . ssl . SSLPeerUnverifiedException ; import javax . security . cert . X509Certificate ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . net . InetSocketAddress ; public abstract class ConnectionBase { private static final Logger log = LoggerFactory . getLogger ( ConnectionBase . class ) ; protected final VertxInternal vertx ; protected final Channel channel ; protected final ContextImpl context ; protected final NetworkMetrics metrics ; protected Handler < Throwable > exceptionHandler ; protected Handler < Void > closeHandler ; private boolean read ; private boolean needsFlush ; protected ConnectionBase ( VertxInternal vertx , Channel channel , ContextImpl context , NetworkMetrics metrics ) { this . vertx = vertx ; this . channel = channel ; this . context = context ; this . metrics = metrics ; } protected synchronized final void startRead ( ) { checkContext ( ) ; read = true ; } protected synchronized final void endReadAndFlush ( ) { read = false ; if ( needsFlush ) { needsFlush = false ; channel . flush ( ) ; } } public synchronized ChannelFuture queueForWrite ( final Object obj ) { needsFlush = true ; return channel . write ( obj ) ; } public synchronized ChannelFuture writeToChannel ( Object obj ) { if ( read ) { return queueForWrite ( obj ) ; } if ( channel . isOpen ( ) ) { return channel . writeAndFlush ( obj ) ; } else { return null ; } } public boolean isNotWritable ( ) { return ! channel . isWritable ( ) ; } public void close ( ) { endReadAndFlush ( ) ; channel . close ( ) ; } public void doPause ( ) { channel . config ( ) . setAutoRead ( false ) ; } public void doResume ( ) { channel . config ( ) . setAutoRead ( true ) ; } public void doSetWriteQueueMaxSize ( int size ) { channel . config ( ) . setWriteBufferLowWaterMark ( size / 2 ) ; channel . config ( ) . setWriteBufferHighWaterMark ( size ) ; } protected void checkContext ( ) { if ( context != vertx . getContext ( ) ) { throw new IllegalStateException ( "Wrong context!" ) ; } } protected ContextImpl getContext ( ) { return context ; } protected abstract Object metric ( ) ; protected synchronized void handleException ( Throwable t ) { metrics . exceptionOccurred ( metric ( ) , remoteAddress ( ) , t ) ; if ( exceptionHandler != null ) { exceptionHandler . handle ( t ) ; } else { log . error ( t ) ; } } protected synchronized void handleClosed ( ) { if ( metrics instanceof TCPMetrics ) { ( ( TCPMetrics ) metrics ) . disconnected ( metric ( ) , remoteAddress ( ) ) ; } closeHandler ( ) ; } private void closeHandler ( ) { if ( closeHandler != null ) { closeHandler . handle ( null ) ; } } protected abstract void handleInterestedOpsChanged ( ) ; protected void addFuture ( final Handler < AsyncResult < Void > > completionHandler , final ChannelFuture future ) { if ( future != null ) { future . addListener ( channelFuture - > context . executeFromIO ( ( ) - > { if ( completionHandler != null ) { if ( channelFuture . isSuccess ( ) ) { completionHandler . handle ( Future . succeededFuture ( ) ) ; } else { completionHandler . handle ( Future . failedFuture ( channelFuture . cause ( ) ) ) ; } } else if ( ! channelFuture . isSuccess ( ) ) { handleException ( channelFuture . cause ( ) ) ; } } ) ) ; } } protected boolean supportsFileRegion ( ) { return ! isSSL ( ) ; } public void reportBytesRead ( long numberOfBytes ) { if ( metrics . isEnabled ( ) ) { metrics . bytesRead ( metric ( ) , remoteAddress ( ) , numberOfBytes ) ; } } public void reportBytesWritten ( long numberOfBytes ) { if ( metrics . isEnabled ( ) ) { metrics . bytesWritten ( metric ( ) , remoteAddress ( ) , numberOfBytes ) ; } } private boolean isSSL ( ) { return channel . pipeline ( ) . get ( SslHandler . class ) != null ; } protected ChannelFuture sendFile ( RandomAccessFile raf , long fileLength ) throws IOException { ChannelFuture writeFuture ; if ( ! supportsFileRegion ( ) ) { writeFuture = writeToChannel ( new ChunkedFile ( raf , 0 , fileLength , 8192 ) ) ; } else { FileRegion region = new DefaultFileRegion ( raf . getChannel ( ) , 0 , fileLength ) ; writeFuture = writeToChannel ( region ) ; } if ( writeFuture != null ) { writeFuture . addListener ( fut - > raf . close ( ) ) ; } return writeFuture ; } public X509Certificate [ ] getPeerCertificateChain ( ) throws SSLPeerUnverifiedException { if ( isSSL ( ) ) { ChannelHandlerContext sslHandlerContext = channel . pipeline ( ) . context ( "ssl" ) ; assert sslHandlerContext != null ; SslHandler sslHandler = ( SslHandler ) sslHandlerContext . handler ( ) ; return sslHandler . engine ( ) . getSession ( ) . getPeerCertificateChain ( ) ; } else { return null ; } } public SocketAddress remoteAddress ( ) { InetSocketAddress addr = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( addr == null ) return null ; return new SocketAddressImpl ( addr . getPort ( ) , addr . getAddress ( ) . getHostAddress ( ) ) ; } public SocketAddress localAddress ( ) { InetSocketAddress addr = ( InetSocketAddress ) channel . localAddress ( ) ; if ( addr == null ) return null ; return new SocketAddressImpl ( addr . getPort ( ) , addr . getAddress ( ) . getHostAddress ( ) ) ; } }
package io . vertx . core . net . impl ; import io . vertx . core . Handler ; import io . vertx . core . impl . ContextImpl ; public class HandlerHolder < T > { public final ContextImpl context ; public final Handler < T > handler ; HandlerHolder ( ContextImpl context , Handler < T > handler ) { this . context = context ; this . handler = handler ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; HandlerHolder that = ( HandlerHolder ) o ; if ( context != that . context ) return false ; if ( handler != null ? ! handler . equals ( that . handler ) : that . handler != null ) return false ; return true ; } @ Override public int hashCode ( ) { int result = context . hashCode ( ) ; result = 31 * result + handler . hashCode ( ) ; return result ; } }
package io . vertx . core . net . impl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . handler . ssl . SslHandler ; import io . netty . util . CharsetUtil ; import io . vertx . core . AsyncResult ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . VoidHandler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . Message ; import io . vertx . core . eventbus . MessageConsumer ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . spi . metrics . TCPMetrics ; import io . vertx . core . net . NetSocket ; import io . vertx . core . net . SocketAddress ; import javax . net . ssl . SSLPeerUnverifiedException ; import javax . security . cert . X509Certificate ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . charset . Charset ; import java . util . ArrayDeque ; import java . util . Queue ; import java . util . UUID ; public class NetSocketImpl extends ConnectionBase implements NetSocket { private static final Logger log = LoggerFactory . getLogger ( NetSocketImpl . class ) ; private final String writeHandlerID ; private final MessageConsumer registration ; private final SSLHelper helper ; private final boolean client ; private Object metric ; private Handler < Buffer > dataHandler ; private Handler < Void > endHandler ; private Handler < Void > drainHandler ; private Queue < Buffer > pendingData ; private boolean paused = false ; private ChannelFuture writeFuture ; public NetSocketImpl ( VertxInternal vertx , Channel channel , ContextImpl context , SSLHelper helper , boolean client , TCPMetrics metrics , Object metric ) { super ( vertx , channel , context , metrics ) ; this . helper = helper ; this . client = client ; this . writeHandlerID = UUID . randomUUID ( ) . toString ( ) ; this . metric = metric ; Handler < Message < Buffer > > writeHandler = msg - > write ( msg . body ( ) ) ; registration = vertx . eventBus ( ) . < Buffer > localConsumer ( writeHandlerID ) . handler ( writeHandler ) ; } protected synchronized void setMetric ( Object metric ) { this . metric = metric ; } @ Override protected synchronized Object metric ( ) { return metric ; } @ Override public String writeHandlerID ( ) { return writeHandlerID ; } @ Override public NetSocket write ( Buffer data ) { ByteBuf buf = data . getByteBuf ( ) ; write ( buf ) ; return this ; } @ Override public NetSocket write ( String str ) { write ( Unpooled . copiedBuffer ( str , CharsetUtil . UTF_8 ) ) ; return this ; } @ Override public NetSocket write ( String str , String enc ) { if ( enc == null ) { write ( str ) ; } else { write ( Unpooled . copiedBuffer ( str , Charset . forName ( enc ) ) ) ; } return this ; } @ Override public synchronized NetSocket handler ( Handler < Buffer > dataHandler ) { this . dataHandler = dataHandler ; return this ; } @ Override public synchronized NetSocket pause ( ) { paused = true ; doPause ( ) ; return this ; } @ Override public synchronized NetSocket resume ( ) { if ( ! paused ) { return this ; } paused = false ; if ( pendingData != null ) { for ( ; ; ) { final Buffer buf = pendingData . poll ( ) ; if ( buf == null ) { break ; } context . runOnContext ( new VoidHandler ( ) { @ Override protected void handle ( ) { handleDataReceived ( buf ) ; } } ) ; } } doResume ( ) ; return this ; } @ Override public NetSocket setWriteQueueMaxSize ( int maxSize ) { doSetWriteQueueMaxSize ( maxSize ) ; return this ; } @ Override public boolean writeQueueFull ( ) { return isNotWritable ( ) ; } @ Override public synchronized NetSocket endHandler ( Handler < Void > endHandler ) { this . endHandler = endHandler ; return this ; } @ Override public synchronized NetSocket drainHandler ( Handler < Void > drainHandler ) { this . drainHandler = drainHandler ; vertx . runOnContext ( v - > callDrainHandler ( ) ) ; return this ; } @ Override public NetSocket sendFile ( String filename ) { return sendFile ( filename , null ) ; } @ Override public NetSocket sendFile ( String filename , final Handler < AsyncResult < Void > > resultHandler ) { File f = vertx . resolveFile ( filename ) ; if ( f . isDirectory ( ) ) { throw new IllegalArgumentException ( "filename must point to a file and not to a directory" ) ; } try { RandomAccessFile raf = new RandomAccessFile ( f , "r" ) ; ChannelFuture future = super . sendFile ( raf , f . length ( ) ) ; if ( resultHandler != null ) { future . addListener ( fut - > { final AsyncResult < Void > res ; if ( future . isSuccess ( ) ) { res = Future . succeededFuture ( ) ; } else { res = Future . failedFuture ( future . cause ( ) ) ; } vertx . runOnContext ( v - > resultHandler . handle ( res ) ) ; } ) ; } } catch ( IOException e ) { if ( resultHandler != null ) { vertx . runOnContext ( v - > resultHandler . handle ( Future . failedFuture ( e ) ) ) ; } else { log . error ( "Failed to send file" , e ) ; } } return this ; } @ Override public SocketAddress remoteAddress ( ) { return super . remoteAddress ( ) ; } public SocketAddress localAddress ( ) { return super . localAddress ( ) ; } @ Override public synchronized NetSocket exceptionHandler ( Handler < Throwable > handler ) { this . exceptionHandler = handler ; return this ; } @ Override public synchronized NetSocket closeHandler ( Handler < Void > handler ) { this . closeHandler = handler ; return this ; } @ Override public synchronized void close ( ) { if ( writeFuture != null ) { writeFuture . addListener ( ChannelFutureListener . CLOSE ) ; channel . flush ( ) ; } else { super . close ( ) ; } } @ Override public synchronized NetSocket upgradeToSsl ( final Handler < Void > handler ) { SslHandler sslHandler = channel . pipeline ( ) . get ( SslHandler . class ) ; if ( sslHandler == null ) { sslHandler = helper . createSslHandler ( vertx , client ) ; channel . pipeline ( ) . addFirst ( sslHandler ) ; } sslHandler . handshakeFuture ( ) . addListener ( future - > context . executeFromIO ( ( ) - > { if ( future . isSuccess ( ) ) { handler . handle ( null ) ; } else { log . error ( future . cause ( ) ) ; } } ) ) ; return this ; } @ Override public boolean isSsl ( ) { return channel . pipeline ( ) . get ( SslHandler . class ) != null ; } @ Override public X509Certificate [ ] peerCertificateChain ( ) throws SSLPeerUnverifiedException { return getPeerCertificateChain ( ) ; } @ Override protected synchronized void handleInterestedOpsChanged ( ) { checkContext ( ) ; callDrainHandler ( ) ; } @ Override protected synchronized void handleClosed ( ) { checkContext ( ) ; endHandlerd ( ) ; super . handleClosed ( ) ; registration ( ) ; } private void registration ( ) { if ( vertx . eventBus ( ) != null ) { registration . unregister ( ) ; } } private void endHandlerd ( ) { if ( endHandler != null ) { endHandler . handle ( null ) ; } } synchronized void handleDataReceived ( Buffer data ) { checkContext ( ) ; if ( paused ) { if ( pendingData == null ) { pendingData = new ArrayDeque < > ( ) ; } pendingData . add ( data ) ; return ; } reportBytesRead ( data . length ( ) ) ; data ( data ) ; } private void data ( Buffer data ) { if ( dataHandler != null ) { dataHandler . handle ( data ) ; } } private void write ( ByteBuf buff ) { reportBytesWritten ( buff . readableBytes ( ) ) ; writeFuture = super . writeToChannel ( buff ) ; } private synchronized void callDrainHandler ( ) { if ( drainHandler != null ) { drainHandlerg ( ) ; } } private void drainHandlerg ( ) { if ( ! writeQueueFull ( ) ) { drainHandler . handle ( null ) ; } } }
package io . vertx . codegen . annotations ; public class Fluent { }
package io . vertx . test . core ; import io . vertx . core . Vertx ; import io . vertx . core . shareddata . Counter ; import org . junit . Test ; import static io . vertx . test . core . TestUtils . assertNullPointerException ; public class SharedCounterTest extends VertxTestBase { protected Vertx getVertx ( ) { return vertx ; } @ Test public void testIllegalArguments ( ) throws Exception { assertNullPointerException ( ( ) - > getVertx ( ) . sharedData ( ) . getCounter ( null , ar - > { } ) ) ; assertNullPointerException ( ( ) - > getVertx ( ) . sharedData ( ) . getCounter ( "foo" , null ) ) ; getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar - > { Counter counter = ar . result ( ) ; assertNullPointerException ( ( ) - > counter . get ( null ) ) ; assertNullPointerException ( ( ) - > counter . incrementAndGet ( null ) ) ; assertNullPointerException ( ( ) - > counter . getAndIncrement ( null ) ) ; assertNullPointerException ( ( ) - > counter . decrementAndGet ( null ) ) ; assertNullPointerException ( ( ) - > counter . addAndGet ( 1 , null ) ) ; assertNullPointerException ( ( ) - > counter . getAndAdd ( 1 , null ) ) ; assertNullPointerException ( ( ) - > counter . compareAndSet ( 1 , 1 , null ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testGet ( ) { getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar - > { assertTrue ( ar . succeeded ( ) ) ; Counter counter = ar . result ( ) ; counter . get ( ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertEquals ( 0l , ar2 . result ( ) . longValue ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testIncrementAndGet ( ) { getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar - > { assertTrue ( ar . succeeded ( ) ) ; Counter counter = ar . result ( ) ; counter . incrementAndGet ( ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertEquals ( 1l , ar2 . result ( ) . longValue ( ) ) ; getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar3 - > { assertTrue ( ar3 . succeeded ( ) ) ; Counter counter2 = ar3 . result ( ) ; counter2 . incrementAndGet ( ar4 - > { assertTrue ( ar4 . succeeded ( ) ) ; assertEquals ( 2l , ar4 . result ( ) . longValue ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testGetAndIncrement ( ) { getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar - > { assertTrue ( ar . succeeded ( ) ) ; Counter counter = ar . result ( ) ; counter . getAndIncrement ( ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertEquals ( 0l , ar2 . result ( ) . longValue ( ) ) ; getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar3 - > { assertTrue ( ar3 . succeeded ( ) ) ; Counter counter2 = ar3 . result ( ) ; counter2 . getAndIncrement ( ar4 - > { assertTrue ( ar4 . succeeded ( ) ) ; assertEquals ( 1l , ar4 . result ( ) . longValue ( ) ) ; counter2 . get ( ar5 - > { assertTrue ( ar5 . succeeded ( ) ) ; assertEquals ( 2l , ar5 . result ( ) . longValue ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testDecrementAndGet ( ) { getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar - > { assertTrue ( ar . succeeded ( ) ) ; Counter counter = ar . result ( ) ; counter . decrementAndGet ( ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertEquals ( - 1l , ar2 . result ( ) . longValue ( ) ) ; getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar3 - > { assertTrue ( ar3 . succeeded ( ) ) ; Counter counter2 = ar3 . result ( ) ; counter2 . decrementAndGet ( ar4 - > { assertTrue ( ar4 . succeeded ( ) ) ; assertEquals ( - 2l , ar4 . result ( ) . longValue ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testAddAndGet ( ) { getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar - > { assertTrue ( ar . succeeded ( ) ) ; Counter counter = ar . result ( ) ; counter . addAndGet ( 2 , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertEquals ( 2l , ar2 . result ( ) . longValue ( ) ) ; getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar3 - > { assertTrue ( ar3 . succeeded ( ) ) ; Counter counter2 = ar3 . result ( ) ; counter2 . addAndGet ( 2l , ar4 - > { assertTrue ( ar4 . succeeded ( ) ) ; assertEquals ( 4l , ar4 . result ( ) . longValue ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void getAndAdd ( ) { getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar - > { assertTrue ( ar . succeeded ( ) ) ; Counter counter = ar . result ( ) ; counter . getAndAdd ( 2 , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertEquals ( 0l , ar2 . result ( ) . longValue ( ) ) ; getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar3 - > { assertTrue ( ar3 . succeeded ( ) ) ; Counter counter2 = ar3 . result ( ) ; counter2 . getAndAdd ( 2l , ar4 - > { assertTrue ( ar4 . succeeded ( ) ) ; assertEquals ( 2l , ar4 . result ( ) . longValue ( ) ) ; counter2 . get ( ar5 - > { assertTrue ( ar5 . succeeded ( ) ) ; assertEquals ( 4l , ar5 . result ( ) . longValue ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testCompareAndSet ( ) { getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar - > { assertTrue ( ar . succeeded ( ) ) ; Counter counter = ar . result ( ) ; counter . compareAndSet ( 0l , 2l , onSuccess ( result - > { getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar3 - > { assertTrue ( ar3 . succeeded ( ) ) ; Counter counter2 = ar3 . result ( ) ; counter2 . compareAndSet ( 2l , 4l , ar4 - > { assertTrue ( ar4 . succeeded ( ) ) ; assertTrue ( ar4 . result ( ) ) ; counter2 . compareAndSet ( 3l , 5l , ar5 - > { assertTrue ( ar5 . succeeded ( ) ) ; assertFalse ( ar5 . result ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; } ) ) ; } ) ; await ( ) ; } @ Test public void testDifferentCounters ( ) { getVertx ( ) . sharedData ( ) . getCounter ( "foo" , ar - > { assertTrue ( ar . succeeded ( ) ) ; Counter counter = ar . result ( ) ; counter . incrementAndGet ( onSuccess ( res - > { assertEquals ( 1l , res . longValue ( ) ) ; getVertx ( ) . sharedData ( ) . getCounter ( "bar" , ar3 - > { assertTrue ( ar3 . succeeded ( ) ) ; Counter counter2 = ar3 . result ( ) ; counter2 . incrementAndGet ( ar4 - > { assertEquals ( 1l , ar4 . result ( ) . longValue ( ) ) ; counter . incrementAndGet ( ar5 - > { assertEquals ( 2l , ar5 . result ( ) . longValue ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; } ) ) ; } ) ; await ( ) ; } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . Future ; public class TestVerticle3 extends AbstractVerticle { @ Override public void start ( ) throws Exception { vertx . eventBus ( ) . send ( "instanceCount" , vertx . getOrCreateContext ( ) . getInstanceCount ( ) ) ; } @ Override public void stop ( Future < Void > stopFuture ) throws Exception { } }
package io . vertx . test . core ; import io . vertx . core . * ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . Message ; import io . vertx . core . eventbus . MessageConsumer ; import io . vertx . core . impl . * ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import io . vertx . core . net . * ; import io . vertx . core . net . impl . SocketAddressImpl ; import io . vertx . core . net . impl . SocketDefaults ; import org . junit . Assume ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; import javax . net . ssl . SSLPeerUnverifiedException ; import javax . security . cert . X509Certificate ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import java . util . function . Consumer ; import static io . vertx . test . core . TestUtils . assertIllegalArgumentException ; import static io . vertx . test . core . TestUtils . assertNullPointerException ; public class NetTest extends VertxTestBase { private NetServer server ; private NetClient client ; @ Rule public TemporaryFolder testFolder = new TemporaryFolder ( ) ; public void setUp ( ) throws Exception { super . setUp ( ) ; client = vertx . createNetClient ( new NetClientOptions ( ) . setConnectTimeout ( 1000 ) ) ; server = vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 1234 ) . setHost ( "localhost" ) ) ; } protected void awaitClose ( NetServer server ) throws InterruptedException { CountDownLatch latch = new CountDownLatch ( 1 ) ; server . close ( ( asyncResult ) - > { latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; } protected void tearDown ( ) throws Exception { if ( client != null ) { client . close ( ) ; } if ( server != null ) { awaitClose ( server ) ; } super . tearDown ( ) ; } @ Test public void testClientOptions ( ) { NetClientOptions options = new NetClientOptions ( ) ; assertEquals ( NetworkOptions . DEFAULT_SEND_BUFFER_SIZE , options . getSendBufferSize ( ) ) ; int rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setSendBufferSize ( rand ) ) ; assertEquals ( rand , options . getSendBufferSize ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setSendBufferSize ( 0 ) ) ; assertIllegalArgumentException ( ( ) - > options . setSendBufferSize ( - 123 ) ) ; assertEquals ( NetworkOptions . DEFAULT_RECEIVE_BUFFER_SIZE , options . getReceiveBufferSize ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setReceiveBufferSize ( rand ) ) ; assertEquals ( rand , options . getReceiveBufferSize ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setReceiveBufferSize ( 0 ) ) ; assertIllegalArgumentException ( ( ) - > options . setReceiveBufferSize ( - 123 ) ) ; assertTrue ( options . isReuseAddress ( ) ) ; assertEquals ( options , options . setReuseAddress ( false ) ) ; assertFalse ( options . isReuseAddress ( ) ) ; assertEquals ( NetworkOptions . DEFAULT_TRAFFIC_CLASS , options . getTrafficClass ( ) ) ; rand = 23 ; assertEquals ( options , options . setTrafficClass ( rand ) ) ; assertEquals ( rand , options . getTrafficClass ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setTrafficClass ( - 1 ) ) ; assertIllegalArgumentException ( ( ) - > options . setTrafficClass ( 256 ) ) ; assertTrue ( options . isTcpNoDelay ( ) ) ; assertEquals ( options , options . setTcpNoDelay ( false ) ) ; assertFalse ( options . isTcpNoDelay ( ) ) ; boolean tcpKeepAlive = SocketDefaults . instance . isTcpKeepAlive ( ) ; assertEquals ( tcpKeepAlive , options . isTcpKeepAlive ( ) ) ; assertEquals ( options , options . setTcpKeepAlive ( ! tcpKeepAlive ) ) ; assertEquals ( ! tcpKeepAlive , options . isTcpKeepAlive ( ) ) ; int soLinger = SocketDefaults . instance . getSoLinger ( ) ; assertEquals ( soLinger , options . getSoLinger ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setSoLinger ( rand ) ) ; assertEquals ( rand , options . getSoLinger ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setSoLinger ( - 1 ) ) ; assertFalse ( options . isUsePooledBuffers ( ) ) ; assertEquals ( options , options . setUsePooledBuffers ( true ) ) ; assertTrue ( options . isUsePooledBuffers ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( 0 , options . getIdleTimeout ( ) ) ; assertEquals ( options , options . setIdleTimeout ( rand ) ) ; assertEquals ( rand , options . getIdleTimeout ( ) ) ; assertFalse ( options . isSsl ( ) ) ; assertEquals ( options , options . setSsl ( true ) ) ; assertTrue ( options . isSsl ( ) ) ; assertNull ( options . getKeyCertOptions ( ) ) ; JksOptions keyStoreOptions = new JksOptions ( ) . setPath ( TestUtils . randomAlphaString ( 100 ) ) . setPassword ( TestUtils . randomAlphaString ( 100 ) ) ; assertEquals ( options , options . setKeyStoreOptions ( keyStoreOptions ) ) ; assertEquals ( keyStoreOptions , options . getKeyCertOptions ( ) ) ; assertNull ( options . getTrustOptions ( ) ) ; JksOptions trustStoreOptions = new JksOptions ( ) . setPath ( TestUtils . randomAlphaString ( 100 ) ) . setPassword ( TestUtils . randomAlphaString ( 100 ) ) ; assertEquals ( options , options . setTrustStoreOptions ( trustStoreOptions ) ) ; assertEquals ( trustStoreOptions , options . getTrustOptions ( ) ) ; assertFalse ( options . isTrustAll ( ) ) ; assertEquals ( options , options . setTrustAll ( true ) ) ; assertTrue ( options . isTrustAll ( ) ) ; assertEquals ( 0 , options . getReconnectAttempts ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setReconnectAttempts ( - 2 ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setReconnectAttempts ( rand ) ) ; assertEquals ( rand , options . getReconnectAttempts ( ) ) ; assertEquals ( 1000 , options . getReconnectInterval ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setReconnectInterval ( 0 ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setReconnectInterval ( rand ) ) ; assertEquals ( rand , options . getReconnectInterval ( ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . isEmpty ( ) ) ; assertEquals ( options , options . addEnabledCipherSuite ( "foo" ) ) ; assertEquals ( options , options . addEnabledCipherSuite ( "bar" ) ) ; assertNotNull ( options . getEnabledCipherSuites ( ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . contains ( "foo" ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . contains ( "bar" ) ) ; testComplete ( ) ; } @ Test public void testServerOptions ( ) { NetServerOptions options = new NetServerOptions ( ) ; assertEquals ( NetworkOptions . DEFAULT_SEND_BUFFER_SIZE , options . getSendBufferSize ( ) ) ; int rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setSendBufferSize ( rand ) ) ; assertEquals ( rand , options . getSendBufferSize ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setSendBufferSize ( 0 ) ) ; assertIllegalArgumentException ( ( ) - > options . setSendBufferSize ( - 123 ) ) ; assertEquals ( NetworkOptions . DEFAULT_RECEIVE_BUFFER_SIZE , options . getReceiveBufferSize ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setReceiveBufferSize ( rand ) ) ; assertEquals ( rand , options . getReceiveBufferSize ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setReceiveBufferSize ( 0 ) ) ; assertIllegalArgumentException ( ( ) - > options . setReceiveBufferSize ( - 123 ) ) ; assertTrue ( options . isReuseAddress ( ) ) ; assertEquals ( options , options . setReuseAddress ( false ) ) ; assertFalse ( options . isReuseAddress ( ) ) ; assertEquals ( NetworkOptions . DEFAULT_TRAFFIC_CLASS , options . getTrafficClass ( ) ) ; rand = 23 ; assertEquals ( options , options . setTrafficClass ( rand ) ) ; assertEquals ( rand , options . getTrafficClass ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setTrafficClass ( - 1 ) ) ; assertIllegalArgumentException ( ( ) - > options . setTrafficClass ( 256 ) ) ; assertTrue ( options . isTcpNoDelay ( ) ) ; assertEquals ( options , options . setTcpNoDelay ( false ) ) ; assertFalse ( options . isTcpNoDelay ( ) ) ; boolean tcpKeepAlive = SocketDefaults . instance . isTcpKeepAlive ( ) ; assertEquals ( tcpKeepAlive , options . isTcpKeepAlive ( ) ) ; assertEquals ( options , options . setTcpKeepAlive ( ! tcpKeepAlive ) ) ; assertEquals ( ! tcpKeepAlive , options . isTcpKeepAlive ( ) ) ; int soLinger = SocketDefaults . instance . getSoLinger ( ) ; assertEquals ( soLinger , options . getSoLinger ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setSoLinger ( rand ) ) ; assertEquals ( rand , options . getSoLinger ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setSoLinger ( - 1 ) ) ; assertFalse ( options . isUsePooledBuffers ( ) ) ; assertEquals ( options , options . setUsePooledBuffers ( true ) ) ; assertTrue ( options . isUsePooledBuffers ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( 0 , options . getIdleTimeout ( ) ) ; assertEquals ( options , options . setIdleTimeout ( rand ) ) ; assertEquals ( rand , options . getIdleTimeout ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setIdleTimeout ( - 1 ) ) ; assertFalse ( options . isSsl ( ) ) ; assertEquals ( options , options . setSsl ( true ) ) ; assertTrue ( options . isSsl ( ) ) ; assertNull ( options . getKeyCertOptions ( ) ) ; JksOptions keyStoreOptions = new JksOptions ( ) . setPath ( TestUtils . randomAlphaString ( 100 ) ) . setPassword ( TestUtils . randomAlphaString ( 100 ) ) ; assertEquals ( options , options . setKeyStoreOptions ( keyStoreOptions ) ) ; assertEquals ( keyStoreOptions , options . getKeyCertOptions ( ) ) ; assertNull ( options . getTrustOptions ( ) ) ; JksOptions trustStoreOptions = new JksOptions ( ) . setPath ( TestUtils . randomAlphaString ( 100 ) ) . setPassword ( TestUtils . randomAlphaString ( 100 ) ) ; assertEquals ( options , options . setTrustStoreOptions ( trustStoreOptions ) ) ; assertEquals ( trustStoreOptions , options . getTrustOptions ( ) ) ; assertEquals ( 1024 , options . getAcceptBacklog ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setAcceptBacklog ( rand ) ) ; assertEquals ( rand , options . getAcceptBacklog ( ) ) ; assertEquals ( 0 , options . getPort ( ) ) ; assertEquals ( options , options . setPort ( 1234 ) ) ; assertEquals ( 1234 , options . getPort ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setPort ( - 1 ) ) ; assertIllegalArgumentException ( ( ) - > options . setPort ( 65536 ) ) ; assertEquals ( "0.0.0.0" , options . getHost ( ) ) ; String randString = TestUtils . randomUnicodeString ( 100 ) ; assertEquals ( options , options . setHost ( randString ) ) ; assertEquals ( randString , options . getHost ( ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . isEmpty ( ) ) ; assertEquals ( options , options . addEnabledCipherSuite ( "foo" ) ) ; assertEquals ( options , options . addEnabledCipherSuite ( "bar" ) ) ; assertNotNull ( options . getEnabledCipherSuites ( ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . contains ( "foo" ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . contains ( "bar" ) ) ; testComplete ( ) ; } @ Test public void testCopyClientOptions ( ) { NetClientOptions options = new NetClientOptions ( ) ; int sendBufferSize = TestUtils . randomPositiveInt ( ) ; int receiverBufferSize = TestUtils . randomPortInt ( ) ; Random rand = new Random ( ) ; boolean reuseAddress = rand . nextBoolean ( ) ; int trafficClass = TestUtils . randomByte ( ) + 127 ; boolean tcpNoDelay = rand . nextBoolean ( ) ; boolean tcpKeepAlive = rand . nextBoolean ( ) ; int soLinger = TestUtils . randomPositiveInt ( ) ; boolean usePooledBuffers = rand . nextBoolean ( ) ; int idleTimeout = TestUtils . randomPositiveInt ( ) ; boolean ssl = rand . nextBoolean ( ) ; JksOptions keyStoreOptions = new JksOptions ( ) ; String ksPassword = TestUtils . randomAlphaString ( 100 ) ; keyStoreOptions . setPassword ( ksPassword ) ; JksOptions trustStoreOptions = new JksOptions ( ) ; String tsPassword = TestUtils . randomAlphaString ( 100 ) ; trustStoreOptions . setPassword ( tsPassword ) ; String enabledCipher = TestUtils . randomAlphaString ( 100 ) ; int connectTimeout = TestUtils . randomPositiveInt ( ) ; boolean trustAll = rand . nextBoolean ( ) ; String crlPath = TestUtils . randomUnicodeString ( 100 ) ; Buffer crlValue = TestUtils . randomBuffer ( 100 ) ; int reconnectAttempts = TestUtils . randomPositiveInt ( ) ; long reconnectInterval = TestUtils . randomPositiveInt ( ) ; options . setSendBufferSize ( sendBufferSize ) ; options . setReceiveBufferSize ( receiverBufferSize ) ; options . setReuseAddress ( reuseAddress ) ; options . setTrafficClass ( trafficClass ) ; options . setSsl ( ssl ) ; options . setTcpNoDelay ( tcpNoDelay ) ; options . setTcpKeepAlive ( tcpKeepAlive ) ; options . setSoLinger ( soLinger ) ; options . setUsePooledBuffers ( usePooledBuffers ) ; options . setIdleTimeout ( idleTimeout ) ; options . setKeyStoreOptions ( keyStoreOptions ) ; options . setTrustStoreOptions ( trustStoreOptions ) ; options . addEnabledCipherSuite ( enabledCipher ) ; options . setConnectTimeout ( connectTimeout ) ; options . setTrustAll ( trustAll ) ; options . addCrlPath ( crlPath ) ; options . addCrlValue ( crlValue ) ; options . setReconnectAttempts ( reconnectAttempts ) ; options . setReconnectInterval ( reconnectInterval ) ; NetClientOptions copy = new NetClientOptions ( options ) ; assertEquals ( sendBufferSize , copy . getSendBufferSize ( ) ) ; assertEquals ( receiverBufferSize , copy . getReceiveBufferSize ( ) ) ; assertEquals ( reuseAddress , copy . isReuseAddress ( ) ) ; assertEquals ( trafficClass , copy . getTrafficClass ( ) ) ; assertEquals ( tcpNoDelay , copy . isTcpNoDelay ( ) ) ; assertEquals ( tcpKeepAlive , copy . isTcpKeepAlive ( ) ) ; assertEquals ( soLinger , copy . getSoLinger ( ) ) ; assertEquals ( usePooledBuffers , copy . isUsePooledBuffers ( ) ) ; assertEquals ( idleTimeout , copy . getIdleTimeout ( ) ) ; assertEquals ( ssl , copy . isSsl ( ) ) ; assertNotSame ( keyStoreOptions , copy . getKeyCertOptions ( ) ) ; assertEquals ( ksPassword , ( ( JksOptions ) copy . getKeyCertOptions ( ) ) . getPassword ( ) ) ; assertNotSame ( trustStoreOptions , copy . getTrustOptions ( ) ) ; assertEquals ( tsPassword , ( ( JksOptions ) copy . getTrustOptions ( ) ) . getPassword ( ) ) ; assertEquals ( 1 , copy . getEnabledCipherSuites ( ) . size ( ) ) ; assertTrue ( copy . getEnabledCipherSuites ( ) . contains ( enabledCipher ) ) ; assertEquals ( connectTimeout , copy . getConnectTimeout ( ) ) ; assertEquals ( trustAll , copy . isTrustAll ( ) ) ; assertEquals ( 1 , copy . getCrlPaths ( ) . size ( ) ) ; assertEquals ( crlPath , copy . getCrlPaths ( ) . get ( 0 ) ) ; assertEquals ( 1 , copy . getCrlValues ( ) . size ( ) ) ; assertEquals ( crlValue , copy . getCrlValues ( ) . get ( 0 ) ) ; assertEquals ( reconnectAttempts , copy . getReconnectAttempts ( ) ) ; assertEquals ( reconnectInterval , copy . getReconnectInterval ( ) ) ; } @ Test public void testDefaultClientOptionsJson ( ) { NetClientOptions def = new NetClientOptions ( ) ; NetClientOptions json = new NetClientOptions ( new JsonObject ( ) ) ; assertEquals ( def . getReconnectAttempts ( ) , json . getReconnectAttempts ( ) ) ; assertEquals ( def . getReconnectInterval ( ) , json . getReconnectInterval ( ) ) ; assertEquals ( def . isTrustAll ( ) , json . isTrustAll ( ) ) ; assertEquals ( def . getCrlPaths ( ) , json . getCrlPaths ( ) ) ; assertEquals ( def . getCrlValues ( ) , json . getCrlValues ( ) ) ; assertEquals ( def . getConnectTimeout ( ) , json . getConnectTimeout ( ) ) ; assertEquals ( def . isTcpNoDelay ( ) , json . isTcpNoDelay ( ) ) ; assertEquals ( def . isTcpKeepAlive ( ) , json . isTcpKeepAlive ( ) ) ; assertEquals ( def . getSoLinger ( ) , json . getSoLinger ( ) ) ; assertEquals ( def . isUsePooledBuffers ( ) , json . isUsePooledBuffers ( ) ) ; assertEquals ( def . isSsl ( ) , json . isSsl ( ) ) ; } @ Test public void testClientOptionsJson ( ) { int sendBufferSize = TestUtils . randomPositiveInt ( ) ; int receiverBufferSize = TestUtils . randomPortInt ( ) ; Random rand = new Random ( ) ; boolean reuseAddress = rand . nextBoolean ( ) ; int trafficClass = TestUtils . randomByte ( ) + 127 ; boolean tcpNoDelay = rand . nextBoolean ( ) ; boolean tcpKeepAlive = rand . nextBoolean ( ) ; int soLinger = TestUtils . randomPositiveInt ( ) ; boolean usePooledBuffers = rand . nextBoolean ( ) ; int idleTimeout = TestUtils . randomPositiveInt ( ) ; boolean ssl = rand . nextBoolean ( ) ; JksOptions keyStoreOptions = new JksOptions ( ) ; String ksPassword = TestUtils . randomAlphaString ( 100 ) ; keyStoreOptions . setPassword ( ksPassword ) ; String ksPath = TestUtils . randomAlphaString ( 100 ) ; keyStoreOptions . setPath ( ksPath ) ; JksOptions trustStoreOptions = new JksOptions ( ) ; String tsPassword = TestUtils . randomAlphaString ( 100 ) ; trustStoreOptions . setPassword ( tsPassword ) ; String tsPath = TestUtils . randomAlphaString ( 100 ) ; trustStoreOptions . setPath ( tsPath ) ; String enabledCipher = TestUtils . randomAlphaString ( 100 ) ; int connectTimeout = TestUtils . randomPositiveInt ( ) ; boolean trustAll = rand . nextBoolean ( ) ; String crlPath = TestUtils . randomUnicodeString ( 100 ) ; int reconnectAttempts = TestUtils . randomPositiveInt ( ) ; long reconnectInterval = TestUtils . randomPositiveInt ( ) ; JsonObject json = new JsonObject ( ) ; json . put ( "sendBufferSize" , sendBufferSize ) . put ( "receiveBufferSize" , receiverBufferSize ) . put ( "reuseAddress" , reuseAddress ) . put ( "trafficClass" , trafficClass ) . put ( "tcpNoDelay" , tcpNoDelay ) . put ( "tcpKeepAlive" , tcpKeepAlive ) . put ( "soLinger" , soLinger ) . put ( "usePooledBuffers" , usePooledBuffers ) . put ( "idleTimeout" , idleTimeout ) . put ( "ssl" , ssl ) . put ( "enabledCipherSuites" , new JsonArray ( ) . add ( enabledCipher ) ) . put ( "connectTimeout" , connectTimeout ) . put ( "trustAll" , trustAll ) . put ( "crlPaths" , new JsonArray ( ) . add ( crlPath ) ) . put ( "keyStoreOptions" , new JsonObject ( ) . put ( "type" , "jks" ) . put ( "password" , ksPassword ) . put ( "path" , ksPath ) ) . put ( "trustStoreOptions" , new JsonObject ( ) . put ( "type" , "jks" ) . put ( "password" , tsPassword ) . put ( "path" , tsPath ) ) . put ( "reconnectAttempts" , reconnectAttempts ) . put ( "reconnectInterval" , reconnectInterval ) ; NetClientOptions options = new NetClientOptions ( json ) ; assertEquals ( sendBufferSize , options . getSendBufferSize ( ) ) ; assertEquals ( receiverBufferSize , options . getReceiveBufferSize ( ) ) ; assertEquals ( reuseAddress , options . isReuseAddress ( ) ) ; assertEquals ( trafficClass , options . getTrafficClass ( ) ) ; assertEquals ( tcpKeepAlive , options . isTcpKeepAlive ( ) ) ; assertEquals ( tcpNoDelay , options . isTcpNoDelay ( ) ) ; assertEquals ( soLinger , options . getSoLinger ( ) ) ; assertEquals ( usePooledBuffers , options . isUsePooledBuffers ( ) ) ; assertEquals ( idleTimeout , options . getIdleTimeout ( ) ) ; assertEquals ( ssl , options . isSsl ( ) ) ; assertNotSame ( keyStoreOptions , options . getKeyCertOptions ( ) ) ; assertEquals ( ksPassword , ( ( JksOptions ) options . getKeyCertOptions ( ) ) . getPassword ( ) ) ; assertEquals ( ksPath , ( ( JksOptions ) options . getKeyCertOptions ( ) ) . getPath ( ) ) ; assertNotSame ( trustStoreOptions , options . getTrustOptions ( ) ) ; assertEquals ( tsPassword , ( ( JksOptions ) options . getTrustOptions ( ) ) . getPassword ( ) ) ; assertEquals ( tsPath , ( ( JksOptions ) options . getTrustOptions ( ) ) . getPath ( ) ) ; assertEquals ( 1 , options . getEnabledCipherSuites ( ) . size ( ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . contains ( enabledCipher ) ) ; assertEquals ( connectTimeout , options . getConnectTimeout ( ) ) ; assertEquals ( trustAll , options . isTrustAll ( ) ) ; assertEquals ( 1 , options . getCrlPaths ( ) . size ( ) ) ; assertEquals ( crlPath , options . getCrlPaths ( ) . get ( 0 ) ) ; assertEquals ( reconnectAttempts , options . getReconnectAttempts ( ) ) ; assertEquals ( reconnectInterval , options . getReconnectInterval ( ) ) ; json . remove ( "keyStoreOptions" ) ; json . remove ( "trustStoreOptions" ) ; json . put ( "pfxKeyCertOptions" , new JsonObject ( ) . put ( "password" , ksPassword ) ) . put ( "pfxTrustOptions" , new JsonObject ( ) . put ( "password" , tsPassword ) ) ; options = new NetClientOptions ( json ) ; assertTrue ( options . getTrustOptions ( ) instanceof PfxOptions ) ; assertTrue ( options . getKeyCertOptions ( ) instanceof PfxOptions ) ; json . remove ( "pfxKeyCertOptions" ) ; json . remove ( "pfxTrustOptions" ) ; json . put ( "pemKeyCertOptions" , new JsonObject ( ) ) . put ( "pemTrustOptions" , new JsonObject ( ) ) ; options = new NetClientOptions ( json ) ; assertTrue ( options . getTrustOptions ( ) instanceof PemTrustOptions ) ; assertTrue ( options . getKeyCertOptions ( ) instanceof PemKeyCertOptions ) ; } @ Test public void testCopyServerOptions ( ) { NetServerOptions options = new NetServerOptions ( ) ; int sendBufferSize = TestUtils . randomPositiveInt ( ) ; int receiverBufferSize = TestUtils . randomPortInt ( ) ; Random rand = new Random ( ) ; boolean reuseAddress = rand . nextBoolean ( ) ; int trafficClass = TestUtils . randomByte ( ) + 128 ; boolean tcpNoDelay = rand . nextBoolean ( ) ; boolean tcpKeepAlive = rand . nextBoolean ( ) ; int soLinger = TestUtils . randomPositiveInt ( ) ; boolean usePooledBuffers = rand . nextBoolean ( ) ; int idleTimeout = TestUtils . randomPositiveInt ( ) ; boolean ssl = rand . nextBoolean ( ) ; JksOptions keyStoreOptions = new JksOptions ( ) ; String ksPassword = TestUtils . randomAlphaString ( 100 ) ; keyStoreOptions . setPassword ( ksPassword ) ; JksOptions trustStoreOptions = new JksOptions ( ) ; String tsPassword = TestUtils . randomAlphaString ( 100 ) ; trustStoreOptions . setPassword ( tsPassword ) ; String enabledCipher = TestUtils . randomAlphaString ( 100 ) ; String crlPath = TestUtils . randomUnicodeString ( 100 ) ; Buffer crlValue = TestUtils . randomBuffer ( 100 ) ; int port = 1234 ; String host = TestUtils . randomAlphaString ( 100 ) ; int acceptBacklog = TestUtils . randomPortInt ( ) ; options . setSendBufferSize ( sendBufferSize ) ; options . setReceiveBufferSize ( receiverBufferSize ) ; options . setReuseAddress ( reuseAddress ) ; options . setTrafficClass ( trafficClass ) ; options . setTcpNoDelay ( tcpNoDelay ) ; options . setTcpKeepAlive ( tcpKeepAlive ) ; options . setSoLinger ( soLinger ) ; options . setUsePooledBuffers ( usePooledBuffers ) ; options . setIdleTimeout ( idleTimeout ) ; options . setSsl ( ssl ) ; options . setKeyStoreOptions ( keyStoreOptions ) ; options . setTrustStoreOptions ( trustStoreOptions ) ; options . addEnabledCipherSuite ( enabledCipher ) ; options . addCrlPath ( crlPath ) ; options . addCrlValue ( crlValue ) ; options . setPort ( port ) ; options . setHost ( host ) ; options . setAcceptBacklog ( acceptBacklog ) ; NetServerOptions copy = new NetServerOptions ( options ) ; assertEquals ( sendBufferSize , copy . getSendBufferSize ( ) ) ; assertEquals ( receiverBufferSize , copy . getReceiveBufferSize ( ) ) ; assertEquals ( reuseAddress , copy . isReuseAddress ( ) ) ; assertEquals ( trafficClass , copy . getTrafficClass ( ) ) ; assertEquals ( tcpNoDelay , copy . isTcpNoDelay ( ) ) ; assertEquals ( tcpKeepAlive , copy . isTcpKeepAlive ( ) ) ; assertEquals ( soLinger , copy . getSoLinger ( ) ) ; assertEquals ( usePooledBuffers , copy . isUsePooledBuffers ( ) ) ; assertEquals ( idleTimeout , copy . getIdleTimeout ( ) ) ; assertEquals ( ssl , copy . isSsl ( ) ) ; assertNotSame ( keyStoreOptions , copy . getKeyCertOptions ( ) ) ; assertEquals ( ksPassword , ( ( JksOptions ) copy . getKeyCertOptions ( ) ) . getPassword ( ) ) ; assertNotSame ( trustStoreOptions , copy . getTrustOptions ( ) ) ; assertEquals ( tsPassword , ( ( JksOptions ) copy . getTrustOptions ( ) ) . getPassword ( ) ) ; assertEquals ( 1 , copy . getEnabledCipherSuites ( ) . size ( ) ) ; assertTrue ( copy . getEnabledCipherSuites ( ) . contains ( enabledCipher ) ) ; assertEquals ( 1 , copy . getCrlPaths ( ) . size ( ) ) ; assertEquals ( crlPath , copy . getCrlPaths ( ) . get ( 0 ) ) ; assertEquals ( 1 , copy . getCrlValues ( ) . size ( ) ) ; assertEquals ( crlValue , copy . getCrlValues ( ) . get ( 0 ) ) ; assertEquals ( port , copy . getPort ( ) ) ; assertEquals ( host , copy . getHost ( ) ) ; assertEquals ( acceptBacklog , copy . getAcceptBacklog ( ) ) ; } @ Test public void testDefaultServerOptionsJson ( ) { NetServerOptions def = new NetServerOptions ( ) ; NetServerOptions json = new NetServerOptions ( new JsonObject ( ) ) ; assertEquals ( def . isClientAuthRequired ( ) , json . isClientAuthRequired ( ) ) ; assertEquals ( def . getCrlPaths ( ) , json . getCrlPaths ( ) ) ; assertEquals ( def . getCrlValues ( ) , json . getCrlValues ( ) ) ; assertEquals ( def . getAcceptBacklog ( ) , json . getAcceptBacklog ( ) ) ; assertEquals ( def . getPort ( ) , json . getPort ( ) ) ; assertEquals ( def . getHost ( ) , json . getHost ( ) ) ; assertEquals ( def . isClientAuthRequired ( ) , json . isClientAuthRequired ( ) ) ; assertEquals ( def . getCrlPaths ( ) , json . getCrlPaths ( ) ) ; assertEquals ( def . getCrlValues ( ) , json . getCrlValues ( ) ) ; assertEquals ( def . getAcceptBacklog ( ) , json . getAcceptBacklog ( ) ) ; assertEquals ( def . getPort ( ) , json . getPort ( ) ) ; assertEquals ( def . getHost ( ) , json . getHost ( ) ) ; assertEquals ( def . isTcpNoDelay ( ) , json . isTcpNoDelay ( ) ) ; assertEquals ( def . isTcpKeepAlive ( ) , json . isTcpKeepAlive ( ) ) ; assertEquals ( def . getSoLinger ( ) , json . getSoLinger ( ) ) ; assertEquals ( def . isUsePooledBuffers ( ) , json . isUsePooledBuffers ( ) ) ; assertEquals ( def . isSsl ( ) , json . isSsl ( ) ) ; } @ Test public void testServerOptionsJson ( ) { int sendBufferSize = TestUtils . randomPositiveInt ( ) ; int receiverBufferSize = TestUtils . randomPortInt ( ) ; Random rand = new Random ( ) ; boolean reuseAddress = rand . nextBoolean ( ) ; int trafficClass = TestUtils . randomByte ( ) + 127 ; boolean tcpNoDelay = rand . nextBoolean ( ) ; boolean tcpKeepAlive = rand . nextBoolean ( ) ; int soLinger = TestUtils . randomPositiveInt ( ) ; boolean usePooledBuffers = rand . nextBoolean ( ) ; int idleTimeout = TestUtils . randomInt ( ) ; boolean ssl = rand . nextBoolean ( ) ; JksOptions keyStoreOptions = new JksOptions ( ) ; String ksPassword = TestUtils . randomAlphaString ( 100 ) ; keyStoreOptions . setPassword ( ksPassword ) ; String ksPath = TestUtils . randomAlphaString ( 100 ) ; keyStoreOptions . setPath ( ksPath ) ; JksOptions trustStoreOptions = new JksOptions ( ) ; String tsPassword = TestUtils . randomAlphaString ( 100 ) ; trustStoreOptions . setPassword ( tsPassword ) ; String tsPath = TestUtils . randomAlphaString ( 100 ) ; trustStoreOptions . setPath ( tsPath ) ; String enabledCipher = TestUtils . randomAlphaString ( 100 ) ; String crlPath = TestUtils . randomUnicodeString ( 100 ) ; int port = 1234 ; String host = TestUtils . randomAlphaString ( 100 ) ; int acceptBacklog = TestUtils . randomPortInt ( ) ; JsonObject json = new JsonObject ( ) ; json . put ( "sendBufferSize" , sendBufferSize ) . put ( "receiveBufferSize" , receiverBufferSize ) . put ( "reuseAddress" , reuseAddress ) . put ( "trafficClass" , trafficClass ) . put ( "tcpNoDelay" , tcpNoDelay ) . put ( "tcpKeepAlive" , tcpKeepAlive ) . put ( "soLinger" , soLinger ) . put ( "usePooledBuffers" , usePooledBuffers ) . put ( "idleTimeout" , idleTimeout ) . put ( "ssl" , ssl ) . put ( "enabledCipherSuites" , new JsonArray ( ) . add ( enabledCipher ) ) . put ( "crlPaths" , new JsonArray ( ) . add ( crlPath ) ) . put ( "keyStoreOptions" , new JsonObject ( ) . put ( "password" , ksPassword ) . put ( "path" , ksPath ) ) . put ( "trustStoreOptions" , new JsonObject ( ) . put ( "password" , tsPassword ) . put ( "path" , tsPath ) ) . put ( "port" , port ) . put ( "host" , host ) . put ( "acceptBacklog" , acceptBacklog ) ; NetServerOptions options = new NetServerOptions ( json ) ; assertEquals ( sendBufferSize , options . getSendBufferSize ( ) ) ; assertEquals ( receiverBufferSize , options . getReceiveBufferSize ( ) ) ; assertEquals ( reuseAddress , options . isReuseAddress ( ) ) ; assertEquals ( trafficClass , options . getTrafficClass ( ) ) ; assertEquals ( tcpKeepAlive , options . isTcpKeepAlive ( ) ) ; assertEquals ( tcpNoDelay , options . isTcpNoDelay ( ) ) ; assertEquals ( soLinger , options . getSoLinger ( ) ) ; assertEquals ( usePooledBuffers , options . isUsePooledBuffers ( ) ) ; assertEquals ( idleTimeout , options . getIdleTimeout ( ) ) ; assertEquals ( ssl , options . isSsl ( ) ) ; assertNotSame ( keyStoreOptions , options . getKeyCertOptions ( ) ) ; assertEquals ( ksPassword , ( ( JksOptions ) options . getKeyCertOptions ( ) ) . getPassword ( ) ) ; assertEquals ( ksPath , ( ( JksOptions ) options . getKeyCertOptions ( ) ) . getPath ( ) ) ; assertNotSame ( trustStoreOptions , options . getTrustOptions ( ) ) ; assertEquals ( tsPassword , ( ( JksOptions ) options . getTrustOptions ( ) ) . getPassword ( ) ) ; assertEquals ( tsPath , ( ( JksOptions ) options . getTrustOptions ( ) ) . getPath ( ) ) ; assertEquals ( 1 , options . getEnabledCipherSuites ( ) . size ( ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . contains ( enabledCipher ) ) ; assertEquals ( 1 , options . getCrlPaths ( ) . size ( ) ) ; assertEquals ( crlPath , options . getCrlPaths ( ) . get ( 0 ) ) ; assertEquals ( port , options . getPort ( ) ) ; assertEquals ( host , options . getHost ( ) ) ; assertEquals ( acceptBacklog , options . getAcceptBacklog ( ) ) ; json . remove ( "keyStoreOptions" ) ; json . remove ( "trustStoreOptions" ) ; json . put ( "pfxKeyCertOptions" , new JsonObject ( ) . put ( "password" , ksPassword ) ) . put ( "pfxTrustOptions" , new JsonObject ( ) . put ( "password" , tsPassword ) ) ; options = new NetServerOptions ( json ) ; assertTrue ( options . getTrustOptions ( ) instanceof PfxOptions ) ; assertTrue ( options . getKeyCertOptions ( ) instanceof PfxOptions ) ; json . remove ( "pfxKeyCertOptions" ) ; json . remove ( "pfxTrustOptions" ) ; json . put ( "pemKeyCertOptions" , new JsonObject ( ) ) . put ( "pemTrustOptions" , new JsonObject ( ) ) ; options = new NetServerOptions ( json ) ; assertTrue ( options . getTrustOptions ( ) instanceof PemTrustOptions ) ; assertTrue ( options . getKeyCertOptions ( ) instanceof PemKeyCertOptions ) ; } @ Test public void testSocketAddress ( ) throws Exception { assertNullPointerException ( ( ) - > new SocketAddressImpl ( 0 , null ) ) ; assertIllegalArgumentException ( ( ) - > new SocketAddressImpl ( 0 , "" ) ) ; assertIllegalArgumentException ( ( ) - > new SocketAddressImpl ( - 1 , "someHost" ) ) ; assertIllegalArgumentException ( ( ) - > new SocketAddressImpl ( 65536 , "someHost" ) ) ; } @ Test public void testEchoBytes ( ) { Buffer sent = TestUtils . randomBuffer ( 100 ) ; testEcho ( sock - > sock . write ( sent ) , buff - > assertEquals ( sent , buff ) , sent . length ( ) ) ; } @ Test public void testEchoString ( ) { String sent = TestUtils . randomUnicodeString ( 100 ) ; Buffer buffSent = Buffer . buffer ( sent ) ; testEcho ( sock - > sock . write ( sent ) , buff - > assertEquals ( buffSent , buff ) , buffSent . length ( ) ) ; } @ Test public void testEchoStringUTF8 ( ) { testEchoStringWithEncoding ( "UTF-8" ) ; } @ Test public void testEchoStringUTF16 ( ) { testEchoStringWithEncoding ( "UTF-16" ) ; } void testEchoStringWithEncoding ( String encoding ) { String sent = TestUtils . randomUnicodeString ( 100 ) ; Buffer buffSent = Buffer . buffer ( sent , encoding ) ; testEcho ( sock - > sock . write ( sent , encoding ) , buff - > assertEquals ( buffSent , buff ) , buffSent . length ( ) ) ; } void testEcho ( Consumer < NetSocket > writer , Consumer < Buffer > dataChecker , int length ) { Handler < AsyncResult < NetSocket > > clientHandler = ( asyncResult ) - > { if ( asyncResult . succeeded ( ) ) { NetSocket sock = asyncResult . result ( ) ; Buffer buff = Buffer . buffer ( ) ; sock . handler ( ( buffer ) - > { buff . appendBuffer ( buffer ) ; if ( buff . length ( ) == length ) { dataChecker . accept ( buff ) ; testComplete ( ) ; } if ( buff . length ( ) > length ) { fail ( "Too many bytes received" ) ; } } ) ; writer . accept ( sock ) ; } else { fail ( "failed to connect" ) ; } } ; startEchoServer ( s - > client . connect ( 1234 , "localhost" , clientHandler ) ) ; await ( ) ; } void startEchoServer ( Handler < AsyncResult < NetServer > > listenHandler ) { Handler < NetSocket > serverHandler = socket - > socket . handler ( socket : : write ) ; server . connectHandler ( serverHandler ) . listen ( listenHandler ) ; } @ Test public void testConnectLocalHost ( ) { connect ( 1234 , "localhost" ) ; } void connect ( int port , String host ) { startEchoServer ( s - > { final int numConnections = 100 ; final AtomicInteger connCount = new AtomicInteger ( 0 ) ; for ( int i = 0 ; i < numConnections ; i ++ ) { AsyncResultHandler < NetSocket > handler = res - > { if ( res . succeeded ( ) ) { res . result ( ) . close ( ) ; if ( connCount . incrementAndGet ( ) == numConnections ) { testComplete ( ) ; } } } ; client . connect ( port , host , handler ) ; } } ) ; await ( ) ; } @ Test public void testConnectInvalidPort ( ) { assertIllegalArgumentException ( ( ) - > client . connect ( - 1 , "localhost" , res - > { } ) ) ; assertIllegalArgumentException ( ( ) - > client . connect ( 65536 , "localhost" , res - > { } ) ) ; client . connect ( 9998 , "localhost" , res - > { assertTrue ( res . failed ( ) ) ; assertFalse ( res . succeeded ( ) ) ; assertNotNull ( res . cause ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testConnectInvalidHost ( ) { assertNullPointerException ( ( ) - > client . connect ( 80 , null , res - > { } ) ) ; client . connect ( 1234 , "127.0.0.2" , res - > { assertTrue ( res . failed ( ) ) ; assertFalse ( res . succeeded ( ) ) ; assertNotNull ( res . cause ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testConnectInvalidConnectHandler ( ) throws Exception { assertNullPointerException ( ( ) - > client . connect ( 80 , "localhost" , null ) ) ; } @ Test public void testListenInvalidPort ( ) { Assume . assumeFalse ( System . getProperty ( "os.name" ) . startsWith ( "Windows" ) ) ; server . close ( ) ; server = vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 80 ) ) ; server . connectHandler ( ( netSocket ) - > { } ) . listen ( ar - > { assertTrue ( ar . failed ( ) ) ; assertFalse ( ar . succeeded ( ) ) ; assertNotNull ( ar . cause ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testListenInvalidHost ( ) { server . close ( ) ; server = vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 1234 ) . setHost ( "uhqwduhqwudhqwuidhqwiudhqwudqwiuhd" ) ) ; server . connectHandler ( netSocket - > { } ) . listen ( ar - > { assertTrue ( ar . failed ( ) ) ; assertFalse ( ar . succeeded ( ) ) ; assertNotNull ( ar . cause ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testListenOnWildcardPort ( ) { server . close ( ) ; server = vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 0 ) ) ; server . connectHandler ( ( netSocket ) - > { } ) . listen ( ar - > { assertFalse ( ar . failed ( ) ) ; assertTrue ( ar . succeeded ( ) ) ; assertNull ( ar . cause ( ) ) ; assertTrue ( server . actualPort ( ) > 1024 ) ; assertEquals ( server , ar . result ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testClientCloseHandlersCloseFromClient ( ) { startEchoServer ( s - > clientCloseHandlers ( true ) ) ; await ( ) ; } @ Test public void testClientCloseHandlersCloseFromServer ( ) { server . connectHandler ( ( netSocket ) - > netSocket . close ( ) ) . listen ( ( s ) - > clientCloseHandlers ( false ) ) ; await ( ) ; } void clientCloseHandlers ( boolean closeFromClient ) { client . connect ( 1234 , "localhost" , ar - > { AtomicInteger counter = new AtomicInteger ( 0 ) ; ar . result ( ) . endHandler ( v - > assertEquals ( 1 , counter . incrementAndGet ( ) ) ) ; ar . result ( ) . closeHandler ( v - > { assertEquals ( 2 , counter . incrementAndGet ( ) ) ; testComplete ( ) ; } ) ; if ( closeFromClient ) { ar . result ( ) . close ( ) ; } } ) ; } @ Test public void testServerCloseHandlersCloseFromClient ( ) { serverCloseHandlers ( false , s - > client . connect ( 1234 , "localhost" , ar - > ar . result ( ) . close ( ) ) ) ; await ( ) ; } @ Test public void testServerCloseHandlersCloseFromServer ( ) { serverCloseHandlers ( true , s - > client . connect ( 1234 , "localhost" , ar - > { } ) ) ; await ( ) ; } void serverCloseHandlers ( boolean closeFromServer , Handler < AsyncResult < NetServer > > listenHandler ) { server . connectHandler ( ( sock ) - > { AtomicInteger counter = new AtomicInteger ( 0 ) ; sock . endHandler ( v - > assertEquals ( 1 , counter . incrementAndGet ( ) ) ) ; sock . closeHandler ( v - > { assertEquals ( 2 , counter . incrementAndGet ( ) ) ; testComplete ( ) ; } ) ; if ( closeFromServer ) { sock . close ( ) ; } } ) . listen ( listenHandler ) ; } @ Test public void testClientDrainHandler ( ) { pausingServer ( ( s ) - > { client . connect ( 1234 , "localhost" , ar - > { NetSocket sock = ar . result ( ) ; assertFalse ( sock . writeQueueFull ( ) ) ; sock . setWriteQueueMaxSize ( 1000 ) ; Buffer buff = TestUtils . randomBuffer ( 10000 ) ; vertx . setPeriodic ( 1 , id - > { sock . write ( buff . copy ( ) ) ; if ( sock . writeQueueFull ( ) ) { vertx . cancelTimer ( id ) ; sock . drainHandler ( v - > { assertFalse ( sock . writeQueueFull ( ) ) ; testComplete ( ) ; } ) ; vertx . eventBus ( ) . send ( "server_resume" , "" ) ; } } ) ; } ) ; } ) ; await ( ) ; } void pausingServer ( Handler < AsyncResult < NetServer > > listenHandler ) { server . connectHandler ( sock - > { sock . pause ( ) ; Handler < Message < Buffer > > resumeHandler = ( m ) - > sock . resume ( ) ; MessageConsumer reg = vertx . eventBus ( ) . < Buffer > consumer ( "server_resume" ) . handler ( resumeHandler ) ; sock . closeHandler ( v - > reg . unregister ( ) ) ; } ) . listen ( listenHandler ) ; } @ Test public void testServerDrainHandler ( ) { drainingServer ( s - > { client . connect ( 1234 , "localhost" , ar - > { NetSocket sock = ar . result ( ) ; sock . pause ( ) ; setHandlers ( sock ) ; sock . handler ( buf - > { } ) ; } ) ; } ) ; await ( ) ; } void setHandlers ( NetSocket sock ) { Handler < Message < Buffer > > resumeHandler = m - > sock . resume ( ) ; MessageConsumer reg = vertx . eventBus ( ) . < Buffer > consumer ( "client_resume" ) . handler ( resumeHandler ) ; sock . closeHandler ( v - > reg . unregister ( ) ) ; } void drainingServer ( Handler < AsyncResult < NetServer > > listenHandler ) { server . connectHandler ( sock - > { assertFalse ( sock . writeQueueFull ( ) ) ; sock . setWriteQueueMaxSize ( 1000 ) ; Buffer buff = TestUtils . randomBuffer ( 10000 ) ; vertx . setPeriodic ( 1 , id - > { sock . write ( buff . copy ( ) ) ; if ( sock . writeQueueFull ( ) ) { vertx . cancelTimer ( id ) ; sock . drainHandler ( v - > { assertFalse ( sock . writeQueueFull ( ) ) ; vertx . setTimer ( 100 , id2 - > testComplete ( ) ) ; } ) ; vertx . eventBus ( ) . send ( "client_resume" , "" ) ; } } ) ; } ) . listen ( listenHandler ) ; } @ Test public void testReconnectAttemptsInfinite ( ) { reconnectAttempts ( - 1 ) ; } @ Test public void testReconnectAttemptsMany ( ) { reconnectAttempts ( 100000 ) ; } void reconnectAttempts ( int attempts ) { client . close ( ) ; client = vertx . createNetClient ( new NetClientOptions ( ) . setReconnectAttempts ( attempts ) . setReconnectInterval ( 10 ) ) ; client . connect ( 1234 , "localhost" , ( res ) - > { assertTrue ( res . succeeded ( ) ) ; assertFalse ( res . failed ( ) ) ; testComplete ( ) ; } ) ; vertx . setTimer ( 2000 , id - > startEchoServer ( s - > { } ) ) ; await ( ) ; } @ Test public void testReconnectAttemptsNotEnough ( ) { client . close ( ) ; client = vertx . createNetClient ( new NetClientOptions ( ) . setReconnectAttempts ( 100 ) . setReconnectInterval ( 10 ) ) ; client . connect ( 1234 , "localhost" , ( res ) - > { assertFalse ( res . succeeded ( ) ) ; assertTrue ( res . failed ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testServerIdleTimeout ( ) { server . close ( ) ; server = vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 1234 ) . setHost ( "localhost" ) . setIdleTimeout ( 1 ) ) ; server . connectHandler ( s - > { } ) . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . connect ( 1234 , "localhost" , res - > { assertTrue ( res . succeeded ( ) ) ; NetSocket socket = res . result ( ) ; socket . closeHandler ( v - > testComplete ( ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testClientIdleTimeout ( ) { client . close ( ) ; client = vertx . createNetClient ( new NetClientOptions ( ) . setIdleTimeout ( 1 ) ) ; server . connectHandler ( s - > { } ) . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . connect ( 1234 , "localhost" , res - > { assertTrue ( res . succeeded ( ) ) ; NetSocket socket = res . result ( ) ; socket . closeHandler ( v - > testComplete ( ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testStartTLSClientTrustAll ( ) throws Exception { testTLS ( false , false , true , false , false , true , true , true ) ; } @ Test public void testTLSClientTrustAll ( ) throws Exception { testTLS ( false , false , true , false , false , true , true , false ) ; } @ Test public void testTLSClientTrustServerCert ( ) throws Exception { testTLS ( false , true , true , false , false , false , true , false ) ; } @ Test public void testTLSClientUntrustedServer ( ) throws Exception { testTLS ( false , false , true , false , false , false , false , false ) ; } @ Test public void testTLSClientCertNotRequired ( ) throws Exception { testTLS ( true , true , true , true , false , false , true , false ) ; } @ Test public void testTLSClientCertRequired ( ) throws Exception { testTLS ( true , true , true , true , true , false , true , false ) ; } @ Test public void testTLSClientCertRequiredNoClientCert ( ) throws Exception { testTLS ( false , true , true , true , true , false , false , false ) ; } @ Test public void testTLSClientCertClientNotTrusted ( ) throws Exception { testTLS ( true , true , true , false , true , false , false , false ) ; } @ Test public void testTLSCipherSuites ( ) throws Exception { testTLS ( false , false , true , false , false , true , true , false , ENABLED_CIPHER_SUITES ) ; } void testTLS ( boolean clientCert , boolean clientTrust , boolean serverCert , boolean serverTrust , boolean requireClientAuth , boolean clientTrustAll , boolean shouldPass , boolean startTLS , String ... enabledCipherSuites ) throws Exception { server . close ( ) ; NetServerOptions options = new NetServerOptions ( ) ; if ( ! startTLS ) { options . setSsl ( true ) ; } if ( serverTrust ) { options . setTrustStoreOptions ( new JksOptions ( ) . setPath ( findFileOnClasspath ( "tls/server-truststore.jks" ) ) . setPassword ( "wibble" ) ) ; } if ( serverCert ) { options . setKeyStoreOptions ( new JksOptions ( ) . setPath ( findFileOnClasspath ( "tls/server-keystore.jks" ) ) . setPassword ( "wibble" ) ) ; } if ( requireClientAuth ) { options . setClientAuthRequired ( true ) ; } for ( String suite : enabledCipherSuites ) { options . addEnabledCipherSuite ( suite ) ; } options . setPort ( 4043 ) ; server = vertx . createNetServer ( options ) ; Handler < NetSocket > serverHandler = socket - > { try { X509Certificate [ ] certs = socket . peerCertificateChain ( ) ; if ( clientCert ) { assertNotNull ( certs ) ; assertEquals ( 1 , certs . length ) ; } else { assertNull ( certs ) ; } } catch ( SSLPeerUnverifiedException e ) { assertTrue ( clientTrust || clientTrustAll ) ; } AtomicBoolean upgradedServer = new AtomicBoolean ( ) ; socket . handler ( buff - > { socket . write ( buff ) ; if ( startTLS && ! upgradedServer . get ( ) ) { assertFalse ( socket . isSsl ( ) ) ; socket . upgradeToSsl ( v - > assertTrue ( socket . isSsl ( ) ) ) ; upgradedServer . set ( true ) ; } else { assertTrue ( socket . isSsl ( ) ) ; } } ) ; } ; server . connectHandler ( serverHandler ) . listen ( ar - > { client . close ( ) ; NetClientOptions clientOptions = new NetClientOptions ( ) ; if ( ! startTLS ) { clientOptions . setSsl ( true ) ; if ( clientTrustAll ) { clientOptions . setTrustAll ( true ) ; } if ( clientTrust ) { clientOptions . setTrustStoreOptions ( new JksOptions ( ) . setPath ( findFileOnClasspath ( "tls/client-truststore.jks" ) ) . setPassword ( "wibble" ) ) ; } if ( clientCert ) { clientOptions . setKeyStoreOptions ( new JksOptions ( ) . setPath ( findFileOnClasspath ( "tls/client-keystore.jks" ) ) . setPassword ( "wibble" ) ) ; } for ( String suite : enabledCipherSuites ) { clientOptions . addEnabledCipherSuite ( suite ) ; } } client = vertx . createNetClient ( clientOptions ) ; client . connect ( 4043 , "localhost" , ar2 - > { if ( ar2 . succeeded ( ) ) { if ( ! shouldPass ) { fail ( "Should not connect" ) ; return ; } final int numChunks = 100 ; final int chunkSize = 100 ; final Buffer received = Buffer . buffer ( ) ; final Buffer sent = Buffer . buffer ( ) ; final NetSocket socket = ar2 . result ( ) ; final AtomicBoolean upgradedClient = new AtomicBoolean ( ) ; socket . handler ( buffer - > { received . appendBuffer ( buffer ) ; if ( received . length ( ) == sent . length ( ) ) { assertEquals ( sent , received ) ; testComplete ( ) ; } if ( startTLS && ! upgradedClient . get ( ) ) { assertFalse ( socket . isSsl ( ) ) ; socket . upgradeToSsl ( v - > { assertTrue ( socket . isSsl ( ) ) ; for ( int i = 1 ; i < numChunks ; i ++ ) { sendBuffer ( socket , sent , chunkSize ) ; } } ) ; } else { assertTrue ( socket . isSsl ( ) ) ; } } ) ; int numToSend = startTLS ? 1 : numChunks ; for ( int i = 0 ; i < numToSend ; i ++ ) { sendBuffer ( socket , sent , chunkSize ) ; } } else { if ( shouldPass ) { fail ( "Should not fail to connect" ) ; } else { testComplete ( ) ; } } } ) ; } ) ; await ( ) ; } void sendBuffer ( NetSocket socket , Buffer sent , int chunkSize ) { Buffer buff = TestUtils . randomBuffer ( chunkSize ) ; sent . appendBuffer ( buff ) ; socket . write ( buff ) ; } @ Test public void testSharedServersRoundRobin ( ) throws Exception { int numServers = 5 ; int numConnections = numServers * 20 ; List < NetServer > servers = new ArrayList < > ( ) ; Set < NetServer > connectedServers = new ConcurrentHashSet < > ( ) ; Map < NetServer , Integer > connectCount = new ConcurrentHashMap < > ( ) ; CountDownLatch latchListen = new CountDownLatch ( numServers ) ; CountDownLatch latchConns = new CountDownLatch ( numConnections ) ; for ( int i = 0 ; i < numServers ; i ++ ) { NetServer theServer = vertx . createNetServer ( new NetServerOptions ( ) . setHost ( "localhost" ) . setPort ( 1234 ) ) ; servers . add ( theServer ) ; theServer . connectHandler ( sock - > { connectedServers . add ( theServer ) ; Integer cnt = connectCount . get ( theServer ) ; int icnt = cnt == null ? 0 : cnt ; icnt ++ ; connectCount . put ( theServer , icnt ) ; latchConns . countDown ( ) ; } ) . listen ( ar - > { if ( ar . succeeded ( ) ) { latchListen . countDown ( ) ; } else { fail ( "Failed to bind server" ) ; } } ) ; } assertTrue ( latchListen . await ( 10 , TimeUnit . SECONDS ) ) ; client . close ( ) ; client = vertx . createNetClient ( new NetClientOptions ( ) ) ; CountDownLatch latchClient = new CountDownLatch ( numConnections ) ; for ( int i = 0 ; i < numConnections ; i ++ ) { client . connect ( 1234 , "localhost" , res - > { if ( res . succeeded ( ) ) { latchClient . countDown ( ) ; } else { res . cause ( ) . printStackTrace ( ) ; fail ( "Failed to connect" ) ; } } ) ; } assertTrue ( latchClient . await ( 10 , TimeUnit . SECONDS ) ) ; assertTrue ( latchConns . await ( 10 , TimeUnit . SECONDS ) ) ; assertEquals ( numServers , connectedServers . size ( ) ) ; for ( NetServer server : servers ) { assertTrue ( connectedServers . contains ( server ) ) ; } assertEquals ( numServers , connectCount . size ( ) ) ; for ( int cnt : connectCount . values ( ) ) { assertEquals ( numConnections / numServers , cnt ) ; } CountDownLatch closeLatch = new CountDownLatch ( numServers ) ; for ( NetServer server : servers ) { server . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; closeLatch . countDown ( ) ; } ) ; } assertTrue ( closeLatch . await ( 10 , TimeUnit . SECONDS ) ) ; testComplete ( ) ; } @ Test public void testSharedServersRoundRobinWithOtherServerRunningOnDifferentPort ( ) throws Exception { CountDownLatch latch = new CountDownLatch ( 1 ) ; server . close ( ) ; server = vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 4321 ) ) ; server . connectHandler ( sock - > { fail ( "Should not connect" ) ; } ) . listen ( ar2 - > { if ( ar2 . succeeded ( ) ) { latch . countDown ( ) ; } else { fail ( "Failed to bind server" ) ; } } ) ; awaitLatch ( latch ) ; testSharedServersRoundRobin ( ) ; } @ Test public void testSharedServersRoundRobinButFirstStartAndStopServer ( ) throws Exception { server . close ( ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; server = vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 1234 ) ) ; server . connectHandler ( sock - > { fail ( "Should not connect" ) ; } ) . listen ( ar - > { if ( ar . succeeded ( ) ) { latch . countDown ( ) ; } else { fail ( "Failed to bind server" ) ; } } ) ; awaitLatch ( latch ) ; CountDownLatch closeLatch = new CountDownLatch ( 1 ) ; server . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; closeLatch . countDown ( ) ; } ) ; assertTrue ( closeLatch . await ( 10 , TimeUnit . SECONDS ) ) ; testSharedServersRoundRobin ( ) ; } @ Test public void testFanout ( ) throws Exception { CountDownLatch latch = new CountDownLatch ( 1 ) ; Set < String > connections = new ConcurrentHashSet < > ( ) ; server . connectHandler ( socket - > { connections . add ( socket . writeHandlerID ( ) ) ; socket . handler ( buffer - > { for ( String actorID : connections ) { vertx . eventBus ( ) . publish ( actorID , buffer ) ; } } ) ; socket . closeHandler ( v - > { connections . remove ( socket . writeHandlerID ( ) ) ; } ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; int numConnections = 10 ; CountDownLatch connectLatch = new CountDownLatch ( numConnections ) ; CountDownLatch receivedLatch = new CountDownLatch ( numConnections ) ; for ( int i = 0 ; i < numConnections ; i ++ ) { client . connect ( 1234 , "localhost" , res - > { connectLatch . countDown ( ) ; res . result ( ) . handler ( data - > { receivedLatch . countDown ( ) ; } ) ; } ) ; } assertTrue ( connectLatch . await ( 10 , TimeUnit . SECONDS ) ) ; client . connect ( 1234 , "localhost" , res - > { res . result ( ) . write ( "foo" ) ; } ) ; assertTrue ( receivedLatch . await ( 10 , TimeUnit . SECONDS ) ) ; testComplete ( ) ; } @ Test public void testRemoteAddress ( ) throws Exception { server . connectHandler ( socket - > { SocketAddress addr = socket . remoteAddress ( ) ; assertEquals ( "127.0.0.1" , addr . host ( ) ) ; } ) . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; vertx . createNetClient ( new NetClientOptions ( ) ) . connect ( 1234 , "localhost" , result - > { NetSocket socket = result . result ( ) ; SocketAddress addr = socket . remoteAddress ( ) ; assertEquals ( "127.0.0.1" , addr . host ( ) ) ; assertEquals ( addr . port ( ) , 1234 ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testWriteSameBufferMoreThanOnce ( ) throws Exception { server . connectHandler ( socket - > { Buffer received = Buffer . buffer ( ) ; socket . handler ( buff - > { received . appendBuffer ( buff ) ; if ( received . toString ( ) . equals ( "foofoo" ) ) { testComplete ( ) ; } } ) ; } ) . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . connect ( 1234 , "localhost" , result - > { NetSocket socket = result . result ( ) ; Buffer buff = Buffer . buffer ( "foo" ) ; socket . write ( buff ) ; socket . write ( buff ) ; } ) ; } ) ; await ( ) ; } @ Test public void sendFileClientToServer ( ) throws Exception { File fDir = testFolder . newFolder ( ) ; String content = TestUtils . randomUnicodeString ( 10000 ) ; File file = setupFile ( fDir . toString ( ) , "some-file.txt" , content ) ; Buffer expected = Buffer . buffer ( content ) ; Buffer received = Buffer . buffer ( ) ; server . connectHandler ( sock - > { sock . handler ( buff - > { received . appendBuffer ( buff ) ; if ( received . length ( ) == expected . length ( ) ) { assertEquals ( expected , received ) ; testComplete ( ) ; } } ) ; sock . write ( "foo" ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . connect ( 1234 , "localhost" , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; NetSocket sock = ar2 . result ( ) ; sock . handler ( buf - > { sock . sendFile ( file . getAbsolutePath ( ) ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void sendFileServerToClient ( ) throws Exception { File fDir = testFolder . newFolder ( ) ; String content = TestUtils . randomUnicodeString ( 10000 ) ; File file = setupFile ( fDir . toString ( ) , "some-file.txt" , content ) ; Buffer expected = Buffer . buffer ( content ) ; Buffer received = Buffer . buffer ( ) ; server . connectHandler ( sock - > { sock . handler ( buf - > { sock . sendFile ( file . getAbsolutePath ( ) ) ; } ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . connect ( 1234 , "localhost" , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; NetSocket sock = ar2 . result ( ) ; sock . handler ( buff - > { received . appendBuffer ( buff ) ; if ( received . length ( ) == expected . length ( ) ) { assertEquals ( expected , received ) ; testComplete ( ) ; } } ) ; sock . write ( "foo" ) ; } ) ; } ) ; await ( ) ; } @ Test public void testSendFileDirectory ( ) throws Exception { File fDir = testFolder . newFolder ( ) ; server . connectHandler ( socket - > { SocketAddress addr = socket . remoteAddress ( ) ; assertEquals ( "127.0.0.1" , addr . host ( ) ) ; } ) . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . connect ( 1234 , "localhost" , result - > { assertTrue ( result . succeeded ( ) ) ; NetSocket socket = result . result ( ) ; try { socket . sendFile ( fDir . getAbsolutePath ( ) . toString ( ) ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { testComplete ( ) ; } } ) ; } ) ; await ( ) ; } @ Test public void testServerOptionsCopiedBeforeUse ( ) { server . close ( ) ; NetServerOptions options = new NetServerOptions ( ) . setPort ( 1234 ) ; NetServer server = vertx . createNetServer ( options ) ; options . setPort ( 1235 ) ; server . connectHandler ( sock - > { testComplete ( ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . connect ( 1234 , "localhost" , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testClientOptionsCopiedBeforeUse ( ) { client . close ( ) ; NetClientOptions options = new NetClientOptions ( ) ; client = vertx . createNetClient ( options ) ; options . setSsl ( true ) ; server . connectHandler ( sock - > { testComplete ( ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . connect ( 1234 , "localhost" , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testListenWithNoHandler ( ) { try { server . listen ( ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { } } @ Test public void testListenWithNoHandler2 ( ) { try { server . listen ( ar - > { assertFalse ( ar . succeeded ( ) ) ; } ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { } } @ Test public void testSetHandlerAfterListen ( ) { server . connectHandler ( sock - > { } ) ; server . listen ( ) ; try { server . connectHandler ( sock - > { } ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { } } @ Test public void testSetHandlerAfterListen2 ( ) { server . connectHandler ( sock - > { } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; try { server . connectHandler ( sock - > { } ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { } testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testListenTwice ( ) { server . connectHandler ( sock - > { } ) ; server . listen ( onSuccess ( s - > { try { server . listen ( res - > { } ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { testComplete ( ) ; } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } } ) ) ; await ( ) ; } @ Test public void testListenTwice2 ( ) { server . connectHandler ( sock - > { } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; try { server . listen ( sock - > { } ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { } testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testCloseTwice ( ) { client . close ( ) ; client . close ( ) ; } @ Test public void testAttemptConnectAfterClose ( ) { client . close ( ) ; try { client . connect ( 1234 , "localhost" , ar - > { } ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { } } @ Test public void testClientMultiThreaded ( ) throws Exception { int numThreads = 10 ; Thread [ ] threads = new Thread [ numThreads ] ; CountDownLatch latch = new CountDownLatch ( numThreads ) ; server . connectHandler ( socket - > { socket . handler ( socket : : write ) ; } ) . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; for ( int i = 0 ; i < numThreads ; i ++ ) { threads [ i ] = new Thread ( ) { public void run ( ) { client . connect ( 1234 , "localhost" , result - > { assertTrue ( result . succeeded ( ) ) ; Buffer buff = TestUtils . randomBuffer ( 100000 ) ; NetSocket sock = result . result ( ) ; sock . write ( buff ) ; Buffer received = Buffer . buffer ( ) ; sock . handler ( rec - > { received . appendBuffer ( rec ) ; if ( received . length ( ) == buff . length ( ) ) { assertEquals ( buff , received ) ; latch . countDown ( ) ; } } ) ; } ) ; } } ; threads [ i ] . start ( ) ; } } ) ; awaitLatch ( latch ) ; for ( int i = 0 ; i < numThreads ; i ++ ) { threads [ i ] . join ( ) ; } } @ Test public void testInVerticle ( ) throws Exception { testInVerticle ( false ) ; } private void testInVerticle ( boolean worker ) throws Exception { client . close ( ) ; server . close ( ) ; class MyVerticle extends AbstractVerticle { Context ctx ; @ Override public void start ( ) { ctx = context ; if ( worker ) { assertTrue ( ctx instanceof WorkerContext ) ; } else { assertTrue ( ctx instanceof EventLoopContext ) ; } Thread thr = Thread . currentThread ( ) ; server = vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 1234 ) . setHost ( "localhost" ) ) ; server . connectHandler ( sock - > { sock . handler ( buff - > { sock . write ( buff ) ; } ) ; assertSame ( ctx , context ) ; if ( ! worker ) { assertSame ( thr , Thread . currentThread ( ) ) ; } } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; assertSame ( ctx , context ) ; if ( ! worker ) { assertSame ( thr , Thread . currentThread ( ) ) ; } client = vertx . createNetClient ( new NetClientOptions ( ) ) ; client . connect ( 1234 , "localhost" , ar2 - > { assertSame ( ctx , context ) ; if ( ! worker ) { assertSame ( thr , Thread . currentThread ( ) ) ; } assertTrue ( ar2 . succeeded ( ) ) ; NetSocket sock = ar2 . result ( ) ; Buffer buff = TestUtils . randomBuffer ( 10000 ) ; sock . write ( buff ) ; Buffer brec = Buffer . buffer ( ) ; sock . handler ( rec - > { assertSame ( ctx , context ) ; if ( ! worker ) { assertSame ( thr , Thread . currentThread ( ) ) ; } brec . appendBuffer ( rec ) ; if ( brec . length ( ) == buff . length ( ) ) { testComplete ( ) ; } } ) ; } ) ; } ) ; } } MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setWorker ( worker ) ) ; await ( ) ; } @ Test public void testInMultithreadedWorker ( ) throws Exception { class MyVerticle extends AbstractVerticle { @ Override public void start ( ) { try { server = vertx . createNetServer ( new NetServerOptions ( ) ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { } try { client = vertx . createNetClient ( new NetClientOptions ( ) ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { } testComplete ( ) ; } } MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setWorker ( true ) . setMultiThreaded ( true ) ) ; await ( ) ; } @ Test public void testContexts ( ) throws Exception { Set < ContextImpl > contexts = new ConcurrentHashSet < > ( ) ; AtomicInteger cnt = new AtomicInteger ( ) ; AtomicReference < ContextImpl > serverConnectContext = new AtomicReference < > ( ) ; server . connectHandler ( sock - > { sock . handler ( sock : : write ) ; ContextImpl serverContext = ( ( VertxInternal ) vertx ) . getContext ( ) ; if ( serverConnectContext . get ( ) != null ) { assertSame ( serverConnectContext . get ( ) , serverContext ) ; } else { serverConnectContext . set ( serverContext ) ; } } ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; AtomicReference < ContextImpl > listenContext = new AtomicReference < > ( ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; listenContext . set ( ( ( VertxInternal ) vertx ) . getContext ( ) ) ; latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; CountDownLatch latch2 = new CountDownLatch ( 1 ) ; int numConns = 10 ; for ( int i = 0 ; i < numConns ; i ++ ) { client . connect ( 1234 , "localhost" , conn - > { contexts . add ( ( ( VertxInternal ) vertx ) . getContext ( ) ) ; if ( cnt . incrementAndGet ( ) == numConns ) { assertEquals ( numConns , contexts . size ( ) ) ; latch2 . countDown ( ) ; } } ) ; } awaitLatch ( latch2 ) ; server . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; ContextImpl closeContext = ( ( VertxInternal ) vertx ) . getContext ( ) ; assertFalse ( contexts . contains ( closeContext ) ) ; assertNotSame ( serverConnectContext . get ( ) , closeContext ) ; assertFalse ( contexts . contains ( listenContext . get ( ) ) ) ; assertSame ( serverConnectContext . get ( ) , listenContext . get ( ) ) ; testComplete ( ) ; } ) ; server = null ; await ( ) ; } @ Test public void testReadStreamPauseResume ( ) { server . close ( ) ; server = vertx . createNetServer ( new NetServerOptions ( ) . setAcceptBacklog ( 1 ) . setPort ( 1234 ) . setHost ( "localhost" ) ) ; NetSocketStream socketStream = server . connectStream ( ) ; AtomicBoolean paused = new AtomicBoolean ( ) ; socketStream . handler ( so - > { assertTrue ( ! paused . get ( ) ) ; so . write ( "hello" ) ; so . close ( ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; paused . set ( true ) ; socketStream . pause ( ) ; client . connect ( 1234 , "localhost" , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; NetSocket so2 = ar2 . result ( ) ; so2 . handler ( buffer - > { fail ( ) ; } ) ; so2 . closeHandler ( v - > { paused . set ( false ) ; socketStream . resume ( ) ; client . connect ( 1234 , "localhost" , ar3 - > { assertTrue ( ar3 . succeeded ( ) ) ; NetSocket so3 = ar3 . result ( ) ; Buffer buffer = Buffer . buffer ( ) ; so3 . handler ( buffer : : appendBuffer ) ; so3 . closeHandler ( v3 - > { assertEquals ( "hello" , buffer . toString ( "utf-8" ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testNetSocketStreamCallbackIsAsync ( ) { this . server = vertx . createNetServer ( new NetServerOptions ( ) ) ; AtomicInteger done = new AtomicInteger ( ) ; NetSocketStream stream = server . connectStream ( ) ; stream . handler ( req - > { } ) ; ThreadLocal < Object > stack = new ThreadLocal < > ( ) ; stack . set ( true ) ; stream . endHandler ( v - > { assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; assertNull ( stack . get ( ) ) ; if ( done . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ) ; server . listen ( ar - > { assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; assertNull ( stack . get ( ) ) ; ThreadLocal < Object > stack2 = new ThreadLocal < > ( ) ; stack2 . set ( true ) ; server . close ( v - > { assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; assertNull ( stack2 . get ( ) ) ; if ( done . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ) ; stack2 . set ( null ) ; } ) ; await ( ) ; } @ Test public void testMultipleServerClose ( ) { this . server = vertx . createNetServer ( new NetServerOptions ( ) ) ; AtomicInteger times = new AtomicInteger ( ) ; ThreadLocal stack = new ThreadLocal ( ) ; stack . set ( true ) ; server . connectStream ( ) . endHandler ( v - > { assertNull ( stack . get ( ) ) ; assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; times . incrementAndGet ( ) ; } ) ; server . close ( ar1 - > { assertNull ( stack . get ( ) ) ; assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; server . close ( ar2 - > { server . close ( ar3 - > { assertEquals ( 1 , times . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testInWorker ( ) throws Exception { vertx . deployVerticle ( new AbstractVerticle ( ) { @ Override public void start ( ) throws Exception { assertTrue ( Vertx . currentContext ( ) . isWorkerContext ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; final Context context = Vertx . currentContext ( ) ; NetServer server1 = vertx . createNetServer ( new NetServerOptions ( ) . setHost ( "localhost" ) . setPort ( 1234 ) ) ; server1 . connectHandler ( conn - > { assertTrue ( Vertx . currentContext ( ) . isWorkerContext ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; assertSame ( context , Vertx . currentContext ( ) ) ; conn . handler ( conn : : write ) ; conn . closeHandler ( v - > { testComplete ( ) ; } ) ; } ) . listen ( onSuccess ( s - > { assertTrue ( Vertx . currentContext ( ) . isWorkerContext ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; assertSame ( context , Vertx . currentContext ( ) ) ; NetClient client = vertx . createNetClient ( ) ; client . connect ( 1234 , "localhost" , onSuccess ( res - > { assertTrue ( Vertx . currentContext ( ) . isWorkerContext ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; assertSame ( context , Vertx . currentContext ( ) ) ; res . write ( "foo" ) ; res . handler ( buff - > { assertTrue ( Vertx . currentContext ( ) . isWorkerContext ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; assertSame ( context , Vertx . currentContext ( ) ) ; res . close ( ) ; } ) ; } ) ) ; } ) ) ; } } , new DeploymentOptions ( ) . setWorker ( true ) ) ; await ( ) ; } private File setupFile ( String testDir , String fileName , String content ) throws Exception { File file = new File ( testDir , fileName ) ; if ( file . exists ( ) ) { file . delete ( ) ; } BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( file ) , "UTF-8" ) ) ; out . write ( content ) ; out . close ( ) ; return file ; } @ Test public void testServerWorkerMissBufferWhenBufferArriveBeforeConnectCallback ( ) throws Exception { int size = getOptions ( ) . getWorkerPoolSize ( ) ; List < Context > workers = createWorkers ( size + 1 ) ; CountDownLatch latch1 = new CountDownLatch ( workers . size ( ) - 1 ) ; workers . get ( 0 ) . runOnContext ( v - > { NetServer server = vertx . createNetServer ( ) ; server . connectHandler ( so - > { so . handler ( buf - > { assertEquals ( "hello" , buf . toString ( ) ) ; testComplete ( ) ; } ) ; } ) ; server . listen ( 1234 , ar - > { assertTrue ( ar . succeeded ( ) ) ; for ( int i = 1 ; i < workers . size ( ) ; i ++ ) { workers . get ( i ) . runOnContext ( v2 - > { latch1 . countDown ( ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ignore ) { } } ) ; } } ) ; } ) ; awaitLatch ( latch1 ) ; NetClient client = vertx . createNetClient ( ) ; client . connect ( 1234 , "localhost" , ar - > { assertTrue ( ar . succeeded ( ) ) ; NetSocket so = ar . result ( ) ; so . write ( Buffer . buffer ( "hello" ) ) ; } ) ; await ( ) ; } @ Test public void testClientWorkerMissBufferWhenBufferArriveBeforeConnectCallback ( ) throws Exception { int size = getOptions ( ) . getWorkerPoolSize ( ) ; List < Context > workers = createWorkers ( size + 1 ) ; CountDownLatch latch1 = new CountDownLatch ( 1 ) ; CountDownLatch latch2 = new CountDownLatch ( size ) ; NetServer server = vertx . createNetServer ( ) ; server . connectHandler ( so - > { try { awaitLatch ( latch2 ) ; } catch ( InterruptedException e ) { fail ( e . getMessage ( ) ) ; return ; } so . write ( Buffer . buffer ( "hello" ) ) ; } ) ; server . listen ( 1234 , ar - > { assertTrue ( ar . succeeded ( ) ) ; latch1 . countDown ( ) ; } ) ; awaitLatch ( latch1 ) ; workers . get ( 0 ) . runOnContext ( v - > { NetClient client = vertx . createNetClient ( ) ; client . connect ( 1234 , "localhost" , ar - > { assertTrue ( ar . succeeded ( ) ) ; NetSocket so = ar . result ( ) ; so . handler ( buf - > { assertEquals ( "hello" , buf . toString ( ) ) ; testComplete ( ) ; } ) ; } ) ; for ( int i = 1 ; i < workers . size ( ) ; i ++ ) { workers . get ( i ) . runOnContext ( v2 - > { latch2 . countDown ( ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ignore ) { } } ) ; } } ) ; await ( ) ; } }
package io . vertx . test . core ; import io . vertx . core . MultiMap ; import io . vertx . core . http . CaseInsensitiveHeaders ; import org . junit . Test ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import static org . junit . Assert . * ; public class CaseInsensitiveHeadersTest { @ Test public void testCaseInsensitiveHeaders ( ) throws Exception { MultiMap result = new CaseInsensitiveHeaders ( ) ; assertNotNull ( result ) ; assertTrue ( result . isEmpty ( ) ) ; assertEquals ( 0 , result . size ( ) ) ; assertEquals ( "" , result . toString ( ) ) ; } @ Test public void testAddTest1 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; HashMap < String , String > map = new HashMap < String , String > ( ) ; map . put ( "a" , "b" ) ; MultiMap result = mmap . addAll ( map ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( "a: b\n" , result . toString ( ) ) ; } @ Test public void testAddTest2 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; HashMap < String , String > map = new HashMap < String , String > ( ) ; map . put ( "a" , "b" ) ; map . put ( "c" , "d" ) ; assertEquals ( "a: b\nc: d\n" , mmap . addAll ( map ) . toString ( ) ) ; } @ Test public void testAddTest3 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; HashMap < String , String > map = new HashMap < String , String > ( ) ; map . put ( "a" , "b" ) ; assertEquals ( "a: b\n" , mmap . addAll ( map ) . toString ( ) ) ; } @ Test public void testAddTest4 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; Map < String , String > map = new HashMap < String , String > ( ) ; assertEquals ( "" , mmap . addAll ( map ) . toString ( ) ) ; } @ Test public void testAddTest5 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; MultiMap headers = new CaseInsensitiveHeaders ( ) ; assertEquals ( "" , mmap . addAll ( headers ) . toString ( ) ) ; } @ Test public void testAddTest7 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; CharSequence name = "name" ; CharSequence value = "value" ; assertEquals ( "name: value\n" , mmap . add ( name , value ) . toString ( ) ) ; } @ Test public void testAddTest8 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; CharSequence name = "name" ; ArrayList < CharSequence > values = new ArrayList < CharSequence > ( ) ; values . add ( "somevalue" ) ; assertEquals ( "name: somevalue\n" , mmap . add ( name , values ) . toString ( ) ) ; } @ Test public void testAddTest9 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "" ; ArrayList < CharSequence > values = new ArrayList < CharSequence > ( ) ; values . add ( "somevalue" ) ; assertEquals ( ": somevalue\n" , mmap . add ( name , values ) . toString ( ) ) ; } @ Test public void testAddTest10 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "a" ; ArrayList < CharSequence > values = new ArrayList < CharSequence > ( ) ; values . add ( "somevalue" ) ; assertEquals ( "a: somevalue\n" , mmap . add ( name , values ) . toString ( ) ) ; } @ Test public void testAddTest11 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "" ; String strVal = "" ; assertEquals ( ": \n" , mmap . add ( name , strVal ) . toString ( ) ) ; } @ Test public void testAddTest12 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "a" ; String strVal = "b" ; assertEquals ( "a: b\n" , mmap . add ( name , strVal ) . toString ( ) ) ; } @ Test public void testAddTest13 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "aaa" ; String strVal = "" ; assertEquals ( "aaa: \n" , mmap . add ( name , strVal ) . toString ( ) ) ; } @ Test public void testAddTest14 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "" ; String strVal = "aaa" ; assertEquals ( ": aaa\n" , mmap . add ( name , strVal ) . toString ( ) ) ; } @ Test public void testAddIterable ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "name" ; List < String > values = new ArrayList < String > ( ) ; values . add ( "value1" ) ; values . add ( "value2" ) ; MultiMap result = mmap . add ( name , values ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( "name: value1\nname: value2\n" , result . toString ( ) ) ; } @ Test public void testAddMultiMap ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; MultiMap mm = new CaseInsensitiveHeaders ( ) ; mm . add ( "Header1" , "value1" ) ; mm . add ( "Header2" , "value2" ) ; MultiMap result = mmap . addAll ( mm ) ; assertEquals ( 2 , result . size ( ) ) ; assertEquals ( "Header1: value1\nHeader2: value2\n" , result . toString ( ) ) ; } @ Test public void testClearTest1 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; MultiMap result = mmap . clear ( ) ; assertNotNull ( result ) ; assertTrue ( result . isEmpty ( ) ) ; assertEquals ( 0 , result . size ( ) ) ; assertEquals ( "" , result . toString ( ) ) ; } @ Test public void testContainsTest1 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; CharSequence name = String . valueOf ( new Object ( ) ) ; assertFalse ( mmap . contains ( name ) ) ; } @ Test public void testContainsTest2 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "" ; assertFalse ( mmap . contains ( name ) ) ; } @ Test public void testContainsTest3 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "0123456789" ; boolean result = mmap . contains ( name ) ; assertFalse ( result ) ; mmap . add ( name , "" ) ; result = mmap . contains ( name ) ; assertTrue ( result ) ; } @ Test public void testEntriesTest1 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; List < Map . Entry < String , String > > result = mmap . entries ( ) ; assertNotNull ( result ) ; assertEquals ( 0 , result . size ( ) ) ; } @ Test public void testGetTest1 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; CharSequence name = String . valueOf ( new Object ( ) ) ; assertNull ( mmap . get ( name ) ) ; } @ Test public void testGetTest2 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "1" ; assertNull ( mmap . get ( name ) ) ; } @ Test public void testGetTest3 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "name" ; String result = mmap . get ( name ) ; assertNull ( result ) ; mmap . add ( name , "value" ) ; result = mmap . get ( name ) ; assertEquals ( "value" , result ) ; } @ Test ( expected = NullPointerException . class ) public void testGetNPE ( ) { new CaseInsensitiveHeaders ( ) . get ( null ) ; } @ Test public void testGetAllTest1 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; CharSequence name = String . valueOf ( new Object ( ) ) ; List < String > result = mmap . getAll ( name ) ; assertNotNull ( result ) ; assertEquals ( 0 , result . size ( ) ) ; } @ Test public void testGetAllTest2 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "1" ; List < String > result = mmap . getAll ( name ) ; assertNotNull ( result ) ; assertEquals ( 0 , result . size ( ) ) ; } @ Test public void testGetAllTest3 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "name" ; List < String > result = mmap . getAll ( name ) ; assertNotNull ( result ) ; assertEquals ( 0 , result . size ( ) ) ; } @ Test public void testGetAll ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "name" ; mmap . add ( name , "value1" ) ; mmap . add ( name , "value2" ) ; List < String > result = mmap . getAll ( name ) ; assertNotNull ( result ) ; assertEquals ( 2 , result . size ( ) ) ; assertEquals ( "value1" , result . get ( 0 ) ) ; } @ Test ( expected = NullPointerException . class ) public void testGetAllNPE ( ) throws Exception { new CaseInsensitiveHeaders ( ) . getAll ( null ) ; } @ Test public void testIsEmptyTest1 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; assertTrue ( mmap . isEmpty ( ) ) ; } @ Test public void testIsEmptyTest2 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; mmap . add ( "a" , "b" ) ; assertFalse ( mmap . isEmpty ( ) ) ; } @ Test public void testIteratorTest1 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; Iterator < Map . Entry < String , String > > result = mmap . iterator ( ) ; assertNotNull ( result ) ; assertFalse ( result . hasNext ( ) ) ; } @ Test public void testIteratorTest2 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; mmap . add ( "a" , "b" ) ; Iterator < Map . Entry < String , String > > result = mmap . iterator ( ) ; assertNotNull ( result ) ; assertTrue ( result . hasNext ( ) ) ; } @ Test public void testNamesTest1 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; Set < String > result = mmap . names ( ) ; assertNotNull ( result ) ; assertEquals ( 0 , result . size ( ) ) ; } @ Test public void testRemoveTest1 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; CharSequence name = String . valueOf ( new Object ( ) ) ; MultiMap result = mmap . remove ( name ) ; assertNotNull ( result ) ; assertTrue ( result . isEmpty ( ) ) ; assertEquals ( 0 , result . size ( ) ) ; } @ Test ( expected = NullPointerException . class ) public void testRemoveNPE ( ) throws Exception { new CaseInsensitiveHeaders ( ) . remove ( null ) ; } @ Test public void testRemoveTest2 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "1" ; MultiMap result = mmap . remove ( name ) ; assertNotNull ( result ) ; assertTrue ( result . isEmpty ( ) ) ; assertEquals ( 0 , result . size ( ) ) ; } @ Test public void testRemoveTest3 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "name" ; MultiMap result = mmap . remove ( name ) ; assertNotNull ( result ) ; assertTrue ( result . isEmpty ( ) ) ; assertEquals ( 0 , result . size ( ) ) ; } @ Test public void testRemoveTest4 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "name" ; String value = "value" ; mmap . add ( name , value ) ; assertTrue ( mmap . contains ( name ) ) ; MultiMap result = mmap . remove ( name ) ; assertFalse ( result . contains ( name ) ) ; } @ Test public void testSetTest1 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; HashMap < String , String > headers = new HashMap < String , String > ( ) ; headers . put ( "" , "" ) ; MultiMap result = mmap . setAll ( headers ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( ": \n" , result . toString ( ) ) ; } @ Test public void testSetTest2 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; HashMap < String , String > headers = new HashMap < String , String > ( ) ; headers . put ( "" , "" ) ; headers . put ( "aaa" , "bbb" ) ; MultiMap result = mmap . setAll ( headers ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 2 , result . size ( ) ) ; assertEquals ( ": \naaa: bbb\n" , result . toString ( ) ) ; } @ Test public void testSetTest3 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; HashMap < String , String > headers = new HashMap < String , String > ( ) ; headers . put ( "aaa" , "bbb" ) ; MultiMap result = mmap . setAll ( headers ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( "aaa: bbb\n" , result . toString ( ) ) ; } @ Test public void testSetTest4 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; Map < String , String > headers = new HashMap < String , String > ( ) ; MultiMap result = mmap . setAll ( headers ) ; assertNotNull ( result ) ; assertTrue ( result . isEmpty ( ) ) ; assertEquals ( 0 , result . size ( ) ) ; assertEquals ( "" , result . toString ( ) ) ; } @ Test public void testSetTest5 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; MultiMap headers = new CaseInsensitiveHeaders ( ) ; MultiMap result = mmap . setAll ( headers ) ; assertNotNull ( result ) ; assertTrue ( result . isEmpty ( ) ) ; assertEquals ( 0 , result . size ( ) ) ; assertEquals ( "" , result . toString ( ) ) ; } @ Test public void testSetTest7 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; CharSequence name = "name" ; CharSequence value = "value" ; MultiMap result = mmap . set ( name , value ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( "name: value\n" , result . toString ( ) ) ; } @ Test public void testSetTest8 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; CharSequence name = "name" ; ArrayList < CharSequence > values = new ArrayList < CharSequence > ( ) ; values . add ( "somevalue" ) ; assertEquals ( "name: somevalue\n" , mmap . set ( name , values ) . toString ( ) ) ; } @ Test public void testSetTest9 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "" ; ArrayList < CharSequence > values = new ArrayList < CharSequence > ( ) ; values . add ( "somevalue" ) ; assertEquals ( ": somevalue\n" , mmap . set ( name , values ) . toString ( ) ) ; } @ Test public void testSetTest10 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "aaa" ; ArrayList < CharSequence > values = new ArrayList < CharSequence > ( ) ; values . add ( "somevalue" ) ; assertEquals ( "aaa: somevalue\n" , mmap . set ( name , values ) . toString ( ) ) ; } @ Test public void testSetTest11 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "" ; String strVal = "" ; MultiMap result = mmap . set ( name , strVal ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( ": \n" , result . toString ( ) ) ; } @ Test public void testSetTest12 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "aaa" ; String strVal = "bbb" ; MultiMap result = mmap . set ( name , strVal ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( "aaa: bbb\n" , result . toString ( ) ) ; } @ Test public void testSetTest13 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "aaa" ; String strVal = "" ; MultiMap result = mmap . set ( name , strVal ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( "aaa: \n" , result . toString ( ) ) ; } @ Test public void testSetTest14 ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "" ; String strVal = "bbb" ; MultiMap result = mmap . set ( name , strVal ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( ": bbb\n" , result . toString ( ) ) ; } @ Test ( expected = NullPointerException . class ) public void testSetIterableNPE ( ) throws Exception { new CaseInsensitiveHeaders ( ) . set ( "name" , ( Iterable < String > ) null ) ; } @ Test public void testSetIterableEmpty ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "name" ; List < String > values = new ArrayList < String > ( ) ; MultiMap result = mmap . set ( name , values ) ; assertNotNull ( result ) ; assertTrue ( result . isEmpty ( ) ) ; assertEquals ( 0 , result . size ( ) ) ; assertEquals ( "" , result . toString ( ) ) ; } @ Test public void testSetIterable ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; String name = "name" ; List < String > values = new ArrayList < String > ( ) ; values . add ( "value1" ) ; values . add ( null ) ; MultiMap result = mmap . set ( name , values ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( "name: value1\n" , result . toString ( ) ) ; } @ Test public void testSize ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; assertEquals ( 0 , mmap . size ( ) ) ; mmap . add ( "header" , "value" ) ; assertEquals ( 1 , mmap . size ( ) ) ; mmap . add ( "header2" , "value2" ) ; assertEquals ( 2 , mmap . size ( ) ) ; mmap . add ( "header" , "value3" ) ; assertEquals ( 2 , mmap . size ( ) ) ; } @ Test public void testGetHashColl ( ) { MultiMap mm = new CaseInsensitiveHeaders ( ) ; String name1 = "!~AZ" ; String name2 = "!~\u0080Y" ; mm . add ( name1 , "value1" ) ; mm . add ( name2 , "value2" ) ; assertEquals ( 2 , mm . size ( ) ) ; assertEquals ( "value1" , mm . get ( name1 ) ) ; assertEquals ( "value2" , mm . get ( name2 ) ) ; mm = new CaseInsensitiveHeaders ( ) ; name1 = "" ; name2 = "\0" ; mm . add ( name1 , "value1" ) ; mm . add ( name2 , "value2" ) ; assertEquals ( 2 , mm . size ( ) ) ; assertEquals ( "value1" , mm . get ( name1 ) ) ; assertEquals ( "value2" , mm . get ( name2 ) ) ; mm = new CaseInsensitiveHeaders ( ) ; name1 = "AZa" ; name2 = "\u0080YA" ; mm . add ( name1 , "value1" ) ; mm . add ( name2 , "value2" ) ; assertEquals ( 2 , mm . size ( ) ) ; assertEquals ( "value1" , mm . get ( name1 ) ) ; assertEquals ( "value2" , mm . get ( name2 ) ) ; mm = new CaseInsensitiveHeaders ( ) ; name1 = " !" ; name2 = "? " ; assertTrue ( "hash error" , hash ( name1 ) == hash ( name2 ) ) ; mm . add ( name1 , "value1" ) ; mm . add ( name2 , "value2" ) ; assertEquals ( 2 , mm . size ( ) ) ; assertEquals ( "value1" , mm . get ( name1 ) ) ; assertEquals ( "value2" , mm . get ( name2 ) ) ; mm = new CaseInsensitiveHeaders ( ) ; name1 = "\u0080a" ; name2 = "Ab" ; assertTrue ( "hash error" , hash ( name1 ) == hash ( name2 ) ) ; mm . add ( name1 , "value1" ) ; mm . add ( name2 , "value2" ) ; assertEquals ( 2 , mm . size ( ) ) ; assertEquals ( "value1" , mm . get ( name1 ) ) ; assertEquals ( "value2" , mm . get ( name2 ) ) ; mm = new CaseInsensitiveHeaders ( ) ; name1 = "A" ; name2 = "R" ; assertTrue ( "hash error" , index ( hash ( name1 ) ) == index ( hash ( name2 ) ) ) ; mm . add ( name1 , "value1" ) ; mm . add ( name2 , "value2" ) ; assertEquals ( 2 , mm . size ( ) ) ; assertEquals ( "value1" , mm . get ( name1 ) ) ; assertEquals ( "value2" , mm . get ( name2 ) ) ; } @ Test public void testGetAllHashColl ( ) { MultiMap mm = new CaseInsensitiveHeaders ( ) ; String name1 = "AZ" ; String name2 = "\u0080Y" ; assertTrue ( "hash error" , hash ( name1 ) == hash ( name2 ) ) ; mm . add ( name1 , "value1" ) ; mm . add ( name2 , "value2" ) ; assertEquals ( 2 , mm . size ( ) ) ; assertEquals ( "[value1]" , mm . getAll ( name1 ) . toString ( ) ) ; assertEquals ( "[value2]" , mm . getAll ( name2 ) . toString ( ) ) ; mm = new CaseInsensitiveHeaders ( ) ; name1 = "A" ; name2 = "R" ; assertTrue ( "hash error" , index ( hash ( name1 ) ) == index ( hash ( name2 ) ) ) ; mm . add ( name1 , "value1" ) ; mm . add ( name2 , "value2" ) ; assertEquals ( 2 , mm . size ( ) ) ; assertEquals ( "[value1]" , mm . getAll ( name1 ) . toString ( ) ) ; assertEquals ( "[value2]" , mm . getAll ( name2 ) . toString ( ) ) ; } @ Test public void testRemoveHashColl ( ) { MultiMap mm = new CaseInsensitiveHeaders ( ) ; String name1 = "AZ" ; String name2 = "\u0080Y" ; String name3 = "RZ" ; assertTrue ( "hash error" , hash ( name1 ) == hash ( name2 ) ) ; mm . add ( name1 , "value1" ) ; mm . add ( name2 , "value2" ) ; mm . add ( name3 , "value3" ) ; mm . add ( name1 , "value4" ) ; mm . add ( name2 , "value5" ) ; mm . add ( name3 , "value6" ) ; assertEquals ( 3 , mm . size ( ) ) ; mm . remove ( name1 ) ; mm . remove ( name2 ) ; assertEquals ( 1 , mm . size ( ) ) ; mm = new CaseInsensitiveHeaders ( ) ; name1 = "A" ; name2 = "R" ; assertTrue ( "hash error" , index ( hash ( name1 ) ) == index ( hash ( name2 ) ) ) ; mm . add ( name1 , "value1" ) ; mm . add ( name2 , "value2" ) ; assertEquals ( 2 , mm . size ( ) ) ; mm . remove ( name1 ) ; mm . remove ( name2 ) ; assertTrue ( "not empty" , mm . isEmpty ( ) ) ; } private static int hash ( String name ) { int h = 0 ; for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { char c = name . charAt ( i ) ; if ( c >= 'A' && c <= 'Z' ) { c += 32 ; } h = 31 * h + c ; } if ( h > 0 ) { return h ; } else if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } else { return - h ; } } private static int index ( int hash ) { return hash % 17 ; } @ Test public void testHashMININT ( ) { CaseInsensitiveHeaders mm = new CaseInsensitiveHeaders ( ) ; String name1 = "" ; long value = Integer . MAX_VALUE ; value ++ ; int base = 31 ; long pow = 1 ; while ( value > pow * base ) { pow *= base ; } while ( pow != 0 ) { long mul = value / pow ; name1 = ( ( char ) mul ) + name1 ; value -= pow * mul ; pow /= base ; } name1 = ( ( char ) value ) + name1 ; mm . add ( name1 , "value" ) ; assertEquals ( "value" , mm . get ( name1 ) ) ; } private String sortByLine ( String str ) { String [ ] lines = str . split ( "\n" ) ; Arrays . sort ( lines ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String s : lines ) { sb . append ( s ) ; sb . append ( "\n" ) ; } return sb . toString ( ) ; } @ Test public void testToString ( ) { MultiMap mm = new CaseInsensitiveHeaders ( ) ; assertEquals ( "" , mm . toString ( ) ) ; mm . add ( "Header1" , "Value1" ) ; assertEquals ( "Header1: Value1\n" , sortByLine ( mm . toString ( ) ) ) ; mm . add ( "Header2" , "Value2" ) ; assertEquals ( "Header1: Value1\n" + "Header2: Value2\n" , sortByLine ( mm . toString ( ) ) ) ; mm . add ( "Header1" , "Value3" ) ; assertEquals ( "Header1: Value1\n" + "Header1: Value3\n" + "Header2: Value2\n" , sortByLine ( mm . toString ( ) ) ) ; mm . remove ( "Header1" ) ; assertEquals ( "Header2: Value2\n" , sortByLine ( mm . toString ( ) ) ) ; mm . set ( "Header2" , "Value4" ) ; assertEquals ( "Header2: Value4\n" , sortByLine ( mm . toString ( ) ) ) ; } @ Test public void testMapEntrySetValue ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; mmap . add ( "Header" , "oldvalue" ) ; for ( Map . Entry < String , String > me : mmap ) { me . setValue ( "newvalue" ) ; } assertEquals ( "newvalue" , mmap . get ( "Header" ) ) ; } @ Test public void testMapEntryToString ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; mmap . add ( "Header" , "value" ) ; assertEquals ( "Header: value" , mmap . iterator ( ) . next ( ) . toString ( ) ) ; } @ Test ( expected = NullPointerException . class ) public void testMapEntrySetValueNull ( ) throws Exception { MultiMap mmap = new CaseInsensitiveHeaders ( ) ; mmap . add ( "Header" , "oldvalue" ) ; for ( Map . Entry < String , String > me : mmap ) { me . setValue ( null ) ; } } }
package io . vertx . test . core ; import io . vertx . core . VertxOptions ; import io . vertx . core . json . JsonObject ; import io . vertx . core . metrics . MetricsOptions ; import io . vertx . core . spi . cluster . ClusterManager ; import io . vertx . test . fakecluster . FakeClusterManager ; import org . junit . Test ; import java . util . Random ; public class VertxOptionsTest extends VertxTestBase { @ Test public void testOptions ( ) { VertxOptions options = new VertxOptions ( ) ; assertEquals ( 2 * Runtime . getRuntime ( ) . availableProcessors ( ) , options . getEventLoopPoolSize ( ) ) ; int rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setEventLoopPoolSize ( rand ) ) ; assertEquals ( rand , options . getEventLoopPoolSize ( ) ) ; try { options . setEventLoopPoolSize ( 0 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } assertEquals ( 20 , options . getWorkerPoolSize ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setWorkerPoolSize ( rand ) ) ; assertEquals ( rand , options . getWorkerPoolSize ( ) ) ; try { options . setWorkerPoolSize ( 0 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } assertEquals ( 20 , options . getInternalBlockingPoolSize ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setInternalBlockingPoolSize ( rand ) ) ; assertEquals ( rand , options . getInternalBlockingPoolSize ( ) ) ; try { options . setInternalBlockingPoolSize ( 0 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } assertFalse ( options . isClustered ( ) ) ; assertEquals ( options , options . setClustered ( true ) ) ; assertTrue ( options . isClustered ( ) ) ; assertEquals ( 0 , options . getClusterPort ( ) ) ; assertEquals ( options , options . setClusterPort ( 1234 ) ) ; assertEquals ( 1234 , options . getClusterPort ( ) ) ; try { options . setClusterPort ( - 1 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } try { options . setClusterPort ( 65536 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } assertEquals ( "localhost" , options . getClusterHost ( ) ) ; String randString = TestUtils . randomUnicodeString ( 100 ) ; assertEquals ( options , options . setClusterHost ( randString ) ) ; assertEquals ( randString , options . getClusterHost ( ) ) ; assertEquals ( 20000 , options . getClusterPingInterval ( ) ) ; long randomLong = TestUtils . randomPositiveLong ( ) ; assertEquals ( options , options . setClusterPingInterval ( randomLong ) ) ; assertEquals ( randomLong , options . getClusterPingInterval ( ) ) ; try { options . setClusterPingInterval ( - 1 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { assertEquals ( randomLong , options . getClusterPingInterval ( ) ) ; } assertEquals ( 20000 , options . getClusterPingReplyInterval ( ) ) ; randomLong = TestUtils . randomPositiveLong ( ) ; assertEquals ( options , options . setClusterPingReplyInterval ( randomLong ) ) ; assertEquals ( randomLong , options . getClusterPingReplyInterval ( ) ) ; try { options . setClusterPingReplyInterval ( - 1 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { assertEquals ( randomLong , options . getClusterPingReplyInterval ( ) ) ; } assertEquals ( 1000 , options . getBlockedThreadCheckInterval ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setBlockedThreadCheckInterval ( rand ) ) ; assertEquals ( rand , options . getBlockedThreadCheckInterval ( ) ) ; try { options . setBlockedThreadCheckInterval ( 0 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } assertEquals ( 2000l * 1000000 , options . getMaxEventLoopExecuteTime ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setMaxEventLoopExecuteTime ( rand ) ) ; assertEquals ( rand , options . getMaxEventLoopExecuteTime ( ) ) ; try { options . setMaxEventLoopExecuteTime ( 0 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } assertEquals ( 1l * 60 * 1000 * 1000000 , options . getMaxWorkerExecuteTime ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setMaxWorkerExecuteTime ( rand ) ) ; assertEquals ( rand , options . getMaxWorkerExecuteTime ( ) ) ; try { options . setMaxWorkerExecuteTime ( 0 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } ClusterManager mgr = new FakeClusterManager ( ) ; assertNull ( options . getClusterManager ( ) ) ; assertEquals ( options , options . setClusterManager ( mgr ) ) ; assertSame ( mgr , options . getClusterManager ( ) ) ; assertFalse ( options . isHAEnabled ( ) ) ; assertEquals ( options , options . setHAEnabled ( true ) ) ; assertTrue ( options . isHAEnabled ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( 1 , options . getQuorumSize ( ) ) ; assertEquals ( options , options . setQuorumSize ( rand ) ) ; assertEquals ( rand , options . getQuorumSize ( ) ) ; try { options . setQuorumSize ( 0 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } try { options . setQuorumSize ( - 1 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } assertEquals ( VertxOptions . DEFAULT_HA_GROUP , options . getHAGroup ( ) ) ; randString = TestUtils . randomUnicodeString ( 100 ) ; assertEquals ( options , options . setHAGroup ( randString ) ) ; assertEquals ( randString , options . getHAGroup ( ) ) ; try { options . setHAGroup ( null ) ; fail ( "Should throw exception" ) ; } catch ( NullPointerException e ) { } assertNull ( options . getMetricsOptions ( ) ) ; try { options . setWarningExceptionTime ( - 1 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } assertEquals ( options , options . setWarningExceptionTime ( 1000000000l ) ) ; assertEquals ( 1000000000l , options . getWarningExceptionTime ( ) ) ; } @ Test public void testCopyOptions ( ) { VertxOptions options = new VertxOptions ( ) ; int clusterPort = TestUtils . randomPortInt ( ) ; int eventLoopPoolSize = TestUtils . randomPositiveInt ( ) ; int internalBlockingPoolSize = TestUtils . randomPositiveInt ( ) ; int workerPoolSize = TestUtils . randomPositiveInt ( ) ; int blockedThreadCheckInterval = TestUtils . randomPositiveInt ( ) ; String clusterHost = TestUtils . randomAlphaString ( 100 ) ; long clusterPingInterval = TestUtils . randomPositiveLong ( ) ; long clusterPingReplyInterval = TestUtils . randomPositiveLong ( ) ; int maxEventLoopExecuteTime = TestUtils . randomPositiveInt ( ) ; int maxWorkerExecuteTime = TestUtils . randomPositiveInt ( ) ; int proxyOperationTimeout = TestUtils . randomPositiveInt ( ) ; Random rand = new Random ( ) ; boolean haEnabled = rand . nextBoolean ( ) ; boolean metricsEnabled = rand . nextBoolean ( ) ; int quorumSize = 51214 ; String haGroup = TestUtils . randomAlphaString ( 100 ) ; long warningExceptionTime = TestUtils . randomPositiveLong ( ) ; options . setClusterPort ( clusterPort ) ; options . setEventLoopPoolSize ( eventLoopPoolSize ) ; options . setInternalBlockingPoolSize ( internalBlockingPoolSize ) ; options . setWorkerPoolSize ( workerPoolSize ) ; options . setBlockedThreadCheckInterval ( blockedThreadCheckInterval ) ; options . setClusterHost ( clusterHost ) ; options . setClusterPingInterval ( clusterPingInterval ) ; options . setClusterPingReplyInterval ( clusterPingReplyInterval ) ; options . setMaxEventLoopExecuteTime ( maxEventLoopExecuteTime ) ; options . setMaxWorkerExecuteTime ( maxWorkerExecuteTime ) ; options . setHAEnabled ( haEnabled ) ; options . setQuorumSize ( quorumSize ) ; options . setHAGroup ( haGroup ) ; options . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( metricsEnabled ) ) ; options . setWarningExceptionTime ( warningExceptionTime ) ; options = new VertxOptions ( options ) ; assertEquals ( clusterPort , options . getClusterPort ( ) ) ; assertEquals ( clusterPingInterval , options . getClusterPingInterval ( ) ) ; assertEquals ( clusterPingReplyInterval , options . getClusterPingReplyInterval ( ) ) ; assertEquals ( eventLoopPoolSize , options . getEventLoopPoolSize ( ) ) ; assertEquals ( internalBlockingPoolSize , options . getInternalBlockingPoolSize ( ) ) ; assertEquals ( workerPoolSize , options . getWorkerPoolSize ( ) ) ; assertEquals ( blockedThreadCheckInterval , options . getBlockedThreadCheckInterval ( ) ) ; assertEquals ( clusterHost , options . getClusterHost ( ) ) ; assertEquals ( maxEventLoopExecuteTime , options . getMaxEventLoopExecuteTime ( ) ) ; assertEquals ( maxWorkerExecuteTime , options . getMaxWorkerExecuteTime ( ) ) ; assertEquals ( haEnabled , options . isHAEnabled ( ) ) ; assertEquals ( quorumSize , options . getQuorumSize ( ) ) ; assertEquals ( haGroup , options . getHAGroup ( ) ) ; MetricsOptions metricsOptions = options . getMetricsOptions ( ) ; assertNotNull ( metricsOptions ) ; assertEquals ( metricsEnabled , metricsOptions . isEnabled ( ) ) ; assertEquals ( warningExceptionTime , options . getWarningExceptionTime ( ) ) ; } @ Test public void testDefaultJsonOptions ( ) { VertxOptions def = new VertxOptions ( ) ; VertxOptions json = new VertxOptions ( new JsonObject ( ) ) ; assertEquals ( def . getEventLoopPoolSize ( ) , json . getEventLoopPoolSize ( ) ) ; assertEquals ( def . getWorkerPoolSize ( ) , json . getWorkerPoolSize ( ) ) ; assertEquals ( def . isClustered ( ) , json . isClustered ( ) ) ; assertEquals ( def . getClusterHost ( ) , json . getClusterHost ( ) ) ; assertEquals ( def . getClusterPingInterval ( ) , json . getClusterPingInterval ( ) ) ; assertEquals ( def . getClusterPingReplyInterval ( ) , json . getClusterPingReplyInterval ( ) ) ; assertEquals ( def . getBlockedThreadCheckInterval ( ) , json . getBlockedThreadCheckInterval ( ) ) ; assertEquals ( def . getMaxEventLoopExecuteTime ( ) , json . getMaxEventLoopExecuteTime ( ) ) ; assertEquals ( def . getMaxWorkerExecuteTime ( ) , json . getMaxWorkerExecuteTime ( ) ) ; assertEquals ( def . getInternalBlockingPoolSize ( ) , json . getInternalBlockingPoolSize ( ) ) ; assertEquals ( def . isHAEnabled ( ) , json . isHAEnabled ( ) ) ; assertEquals ( def . getQuorumSize ( ) , json . getQuorumSize ( ) ) ; assertEquals ( def . getHAGroup ( ) , json . getHAGroup ( ) ) ; assertEquals ( def . getWarningExceptionTime ( ) , json . getWarningExceptionTime ( ) ) ; } @ Test public void testJsonOptions ( ) { VertxOptions options = new VertxOptions ( new JsonObject ( ) ) ; assertEquals ( 0 , options . getClusterPort ( ) ) ; assertEquals ( 20000 , options . getClusterPingInterval ( ) ) ; assertEquals ( 20000 , options . getClusterPingReplyInterval ( ) ) ; assertEquals ( 2 * Runtime . getRuntime ( ) . availableProcessors ( ) , options . getEventLoopPoolSize ( ) ) ; assertEquals ( 20 , options . getInternalBlockingPoolSize ( ) ) ; assertEquals ( 20 , options . getWorkerPoolSize ( ) ) ; assertEquals ( 1000 , options . getBlockedThreadCheckInterval ( ) ) ; assertEquals ( "localhost" , options . getClusterHost ( ) ) ; assertEquals ( null , options . getClusterManager ( ) ) ; assertEquals ( 2000l * 1000000 , options . getMaxEventLoopExecuteTime ( ) ) ; assertEquals ( 1l * 60 * 1000 * 1000000 , options . getMaxWorkerExecuteTime ( ) ) ; assertFalse ( options . isHAEnabled ( ) ) ; assertEquals ( 1 , options . getQuorumSize ( ) ) ; assertEquals ( VertxOptions . DEFAULT_HA_GROUP , options . getHAGroup ( ) ) ; assertNull ( options . getMetricsOptions ( ) ) ; assertEquals ( 5000000000l , options . getWarningExceptionTime ( ) ) ; int clusterPort = TestUtils . randomPortInt ( ) ; int eventLoopPoolSize = TestUtils . randomPositiveInt ( ) ; int internalBlockingPoolSize = TestUtils . randomPositiveInt ( ) ; int workerPoolSize = TestUtils . randomPositiveInt ( ) ; int blockedThreadCheckInterval = TestUtils . randomPositiveInt ( ) ; String clusterHost = TestUtils . randomAlphaString ( 100 ) ; long clusterPingInterval = TestUtils . randomPositiveLong ( ) ; long clusterPingReplyInterval = TestUtils . randomPositiveLong ( ) ; int maxEventLoopExecuteTime = TestUtils . randomPositiveInt ( ) ; int maxWorkerExecuteTime = TestUtils . randomPositiveInt ( ) ; int proxyOperationTimeout = TestUtils . randomPositiveInt ( ) ; long warningExceptionTime = TestUtils . randomPositiveLong ( ) ; Random rand = new Random ( ) ; boolean haEnabled = rand . nextBoolean ( ) ; int quorumSize = TestUtils . randomShort ( ) + 1 ; String haGroup = TestUtils . randomAlphaString ( 100 ) ; boolean metricsEnabled = rand . nextBoolean ( ) ; boolean jmxEnabled = rand . nextBoolean ( ) ; String jmxDomain = TestUtils . randomAlphaString ( 100 ) ; options = new VertxOptions ( new JsonObject ( ) . put ( "clusterPort" , clusterPort ) . put ( "eventLoopPoolSize" , eventLoopPoolSize ) . put ( "internalBlockingPoolSize" , internalBlockingPoolSize ) . put ( "workerPoolSize" , workerPoolSize ) . put ( "blockedThreadCheckInterval" , blockedThreadCheckInterval ) . put ( "clusterHost" , clusterHost ) . put ( "clusterPingInterval" , clusterPingInterval ) . put ( "clusterPingReplyInterval" , clusterPingReplyInterval ) . put ( "maxEventLoopExecuteTime" , maxEventLoopExecuteTime ) . put ( "maxWorkerExecuteTime" , maxWorkerExecuteTime ) . put ( "proxyOperationTimeout" , proxyOperationTimeout ) . put ( "haEnabled" , haEnabled ) . put ( "quorumSize" , quorumSize ) . put ( "haGroup" , haGroup ) . put ( "warningExceptionTime" , warningExceptionTime ) . put ( "metricsOptions" , new JsonObject ( ) . put ( "enabled" , metricsEnabled ) . put ( "jmxEnabled" , jmxEnabled ) . put ( "jmxDomain" , jmxDomain ) ) ) ; assertEquals ( clusterPort , options . getClusterPort ( ) ) ; assertEquals ( clusterPingInterval , options . getClusterPingInterval ( ) ) ; assertEquals ( clusterPingReplyInterval , options . getClusterPingReplyInterval ( ) ) ; assertEquals ( eventLoopPoolSize , options . getEventLoopPoolSize ( ) ) ; assertEquals ( internalBlockingPoolSize , options . getInternalBlockingPoolSize ( ) ) ; assertEquals ( workerPoolSize , options . getWorkerPoolSize ( ) ) ; assertEquals ( blockedThreadCheckInterval , options . getBlockedThreadCheckInterval ( ) ) ; assertEquals ( clusterHost , options . getClusterHost ( ) ) ; assertEquals ( null , options . getClusterManager ( ) ) ; assertEquals ( maxEventLoopExecuteTime , options . getMaxEventLoopExecuteTime ( ) ) ; assertEquals ( maxWorkerExecuteTime , options . getMaxWorkerExecuteTime ( ) ) ; assertEquals ( haEnabled , options . isHAEnabled ( ) ) ; assertEquals ( quorumSize , options . getQuorumSize ( ) ) ; assertEquals ( haGroup , options . getHAGroup ( ) ) ; MetricsOptions metricsOptions = options . getMetricsOptions ( ) ; assertEquals ( metricsEnabled , metricsOptions . isEnabled ( ) ) ; assertEquals ( warningExceptionTime , options . getWarningExceptionTime ( ) ) ; } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . Context ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Vertx ; import io . vertx . core . VertxException ; import io . vertx . core . VertxOptions ; import io . vertx . core . logging . Logger ; import io . vertx . core . logging . LoggerFactory ; import io . vertx . core . net . PemTrustOptions ; import io . vertx . core . net . JksOptions ; import io . vertx . core . net . PemKeyCertOptions ; import io . vertx . core . net . KeyCertOptions ; import io . vertx . core . net . PfxOptions ; import io . vertx . core . net . TCPSSLOptions ; import io . vertx . core . net . TrustOptions ; import io . vertx . core . spi . cluster . ClusterManager ; import io . vertx . test . fakecluster . FakeClusterManager ; import org . junit . Rule ; import java . io . File ; import java . net . URISyntaxException ; import java . net . URL ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CompletableFuture ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; public class VertxTestBase extends AsyncTestBase { private static final Logger log = LoggerFactory . getLogger ( VertxTestBase . class ) ; @ Rule public RepeatRule repeatRule = new RepeatRule ( ) ; protected Vertx vertx ; protected Vertx [ ] vertices ; protected void vinit ( ) { vertx = null ; vertices = null ; } public void setUp ( ) throws Exception { super . setUp ( ) ; vinit ( ) ; vertx = Vertx . vertx ( getOptions ( ) ) ; } protected VertxOptions getOptions ( ) { return new VertxOptions ( ) ; } protected void tearDown ( ) throws Exception { if ( vertx != null ) { CountDownLatch latch = new CountDownLatch ( 1 ) ; vertx . close ( ar - > { latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; } if ( vertices != null ) { CountDownLatch latch = new CountDownLatch ( vertices . length ) ; for ( Vertx vertx : vertices ) { vertx . close ( ar - > { if ( ar . failed ( ) ) { log . error ( "Failed to shutdown vert.x" , ar . cause ( ) ) ; } latch . countDown ( ) ; } ) ; } assertTrue ( latch . await ( 180 , TimeUnit . SECONDS ) ) ; } FakeClusterManager . reset ( ) ; super . tearDown ( ) ; } protected ClusterManager getClusterManager ( ) { return null ; } protected void startNodes ( int numNodes ) { startNodes ( numNodes , getOptions ( ) ) ; } protected void startNodes ( int numNodes , VertxOptions options ) { CountDownLatch latch = new CountDownLatch ( numNodes ) ; vertices = new Vertx [ numNodes ] ; for ( int i = 0 ; i < numNodes ; i ++ ) { int index = i ; Vertx . clusteredVertx ( options . setClusterHost ( "localhost" ) . setClusterPort ( 0 ) . setClustered ( true ) . setClusterManager ( getClusterManager ( ) ) , ar - > { if ( ar . failed ( ) ) { ar . cause ( ) . printStackTrace ( ) ; } assertTrue ( "Failed to start node" , ar . succeeded ( ) ) ; vertices [ index ] = ar . result ( ) ; latch . countDown ( ) ; } ) ; } try { assertTrue ( latch . await ( 2 , TimeUnit . MINUTES ) ) ; } catch ( InterruptedException e ) { fail ( e . getMessage ( ) ) ; } } protected String findFileOnClasspath ( String fileName ) { URL url = getClass ( ) . getClassLoader ( ) . getResource ( fileName ) ; if ( url == null ) { throw new IllegalArgumentException ( "Cannot find file " + fileName + " on classpath" ) ; } try { File file = new File ( url . toURI ( ) ) ; return file . getAbsolutePath ( ) ; } catch ( URISyntaxException e ) { throw new VertxException ( e ) ; } } protected void setOptions ( TCPSSLOptions sslOptions , KeyCertOptions options ) { if ( options instanceof JksOptions ) { sslOptions . setKeyStoreOptions ( ( JksOptions ) options ) ; } else if ( options instanceof PfxOptions ) { sslOptions . setPfxKeyCertOptions ( ( PfxOptions ) options ) ; } else { sslOptions . setPemKeyCertOptions ( ( PemKeyCertOptions ) options ) ; } } protected void setOptions ( TCPSSLOptions sslOptions , TrustOptions options ) { if ( options instanceof JksOptions ) { sslOptions . setTrustStoreOptions ( ( JksOptions ) options ) ; } else if ( options instanceof PfxOptions ) { sslOptions . setPfxTrustOptions ( ( PfxOptions ) options ) ; } else { sslOptions . setPemTrustOptions ( ( PemTrustOptions ) options ) ; } } protected TrustOptions getClientTrustOptions ( Trust trust ) { switch ( trust ) { case JKS : return new JksOptions ( ) . setPath ( findFileOnClasspath ( "tls/client-truststore.jks" ) ) . setPassword ( "wibble" ) ; case JKS_CA : return new JksOptions ( ) . setPath ( findFileOnClasspath ( "tls/client-truststore-ca.jks" ) ) . setPassword ( "wibble" ) ; case PKCS12 : return new PfxOptions ( ) . setPath ( findFileOnClasspath ( "tls/client-truststore.p12" ) ) . setPassword ( "wibble" ) ; case PKCS12_CA : return new PfxOptions ( ) . setPath ( findFileOnClasspath ( "tls/client-truststore-ca.p12" ) ) . setPassword ( "wibble" ) ; case PEM : return new PemTrustOptions ( ) . addCertPath ( findFileOnClasspath ( "tls/server-cert.pem" ) ) ; case PEM_CA : return new PemTrustOptions ( ) . addCertPath ( findFileOnClasspath ( "tls/ca/ca-cert.pem" ) ) ; default : return null ; } } protected KeyCertOptions getClientCertOptions ( KeyCert cert ) { switch ( cert ) { case JKS : return new JksOptions ( ) . setPath ( findFileOnClasspath ( "tls/client-keystore.jks" ) ) . setPassword ( "wibble" ) ; case JKS_CA : throw new UnsupportedOperationException ( ) ; case PKCS12 : return new PfxOptions ( ) . setPath ( findFileOnClasspath ( "tls/client-keystore.p12" ) ) . setPassword ( "wibble" ) ; case PKCS12_CA : throw new UnsupportedOperationException ( ) ; case PEM : return new PemKeyCertOptions ( ) . setKeyPath ( findFileOnClasspath ( "tls/client-key.pem" ) ) . setCertPath ( findFileOnClasspath ( "tls/client-cert.pem" ) ) ; case PEM_CA : return new PemKeyCertOptions ( ) . setKeyPath ( findFileOnClasspath ( "tls/client-key.pem" ) ) . setCertPath ( findFileOnClasspath ( "tls/client-cert-ca.pem" ) ) ; default : return null ; } } protected TrustOptions getServerTrustOptions ( Trust trust ) { switch ( trust ) { case JKS : return new JksOptions ( ) . setPath ( findFileOnClasspath ( "tls/server-truststore.jks" ) ) . setPassword ( "wibble" ) ; case JKS_CA : throw new UnsupportedOperationException ( ) ; case PKCS12 : return new PfxOptions ( ) . setPath ( findFileOnClasspath ( "tls/server-truststore.p12" ) ) . setPassword ( "wibble" ) ; case PKCS12_CA : throw new UnsupportedOperationException ( ) ; case PEM : return new PemTrustOptions ( ) . addCertPath ( findFileOnClasspath ( "tls/client-cert.pem" ) ) ; case PEM_CA : return new PemTrustOptions ( ) . addCertPath ( findFileOnClasspath ( "tls/ca/ca-cert.pem" ) ) ; default : return null ; } } protected KeyCertOptions getServerCertOptions ( KeyCert cert ) { switch ( cert ) { case JKS : return new JksOptions ( ) . setPath ( findFileOnClasspath ( "tls/server-keystore.jks" ) ) . setPassword ( "wibble" ) ; case JKS_CA : return new JksOptions ( ) . setPath ( findFileOnClasspath ( "tls/server-keystore-ca.jks" ) ) . setPassword ( "wibble" ) ; case PKCS12 : return new PfxOptions ( ) . setPath ( findFileOnClasspath ( "tls/server-keystore.p12" ) ) . setPassword ( "wibble" ) ; case PKCS12_CA : return new PfxOptions ( ) . setPath ( findFileOnClasspath ( "tls/server-keystore-ca.p12" ) ) . setPassword ( "wibble" ) ; case PEM : return new PemKeyCertOptions ( ) . setKeyPath ( findFileOnClasspath ( "tls/server-key.pem" ) ) . setCertPath ( findFileOnClasspath ( "tls/server-cert.pem" ) ) ; case PEM_CA : return new PemKeyCertOptions ( ) . setKeyPath ( findFileOnClasspath ( "tls/server-key.pem" ) ) . setCertPath ( findFileOnClasspath ( "tls/server-cert-ca.pem" ) ) ; default : return null ; } } protected static final String [ ] ENABLED_CIPHER_SUITES = new String [ ] { "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256" , "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256" , "TLS_RSA_WITH_AES_128_CBC_SHA256" , "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256" , "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256" , "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256" , "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256" , "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA" , "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA" , "TLS_RSA_WITH_AES_128_CBC_SHA" , "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA" , "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA" , "TLS_DHE_RSA_WITH_AES_128_CBC_SHA" , "TLS_DHE_DSS_WITH_AES_128_CBC_SHA" , "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA" , "TLS_ECDHE_RSA_WITH_RC4_128_SHA" , "SSL_RSA_WITH_RC4_128_SHA" , "TLS_ECDH_ECDSA_WITH_RC4_128_SHA" , "TLS_ECDH_RSA_WITH_RC4_128_SHA" , "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256" , "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256" , "TLS_RSA_WITH_AES_128_GCM_SHA256" , "TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256" , "TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256" , "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256" , "TLS_DHE_DSS_WITH_AES_128_GCM_SHA256" , "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA" , "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA" , "SSL_RSA_WITH_3DES_EDE_CBC_SHA" , "TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA" , "TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA" , "SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA" , "SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA" , "SSL_RSA_WITH_RC4_128_MD5" , "TLS_EMPTY_RENEGOTIATION_INFO_SCSV" , "TLS_DH_anon_WITH_AES_128_GCM_SHA256" , "TLS_DH_anon_WITH_AES_128_CBC_SHA256" , "TLS_ECDH_anon_WITH_AES_128_CBC_SHA" , "TLS_DH_anon_WITH_AES_128_CBC_SHA" , "TLS_ECDH_anon_WITH_RC4_128_SHA" , "SSL_DH_anon_WITH_RC4_128_MD5" , "TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA" , "SSL_DH_anon_WITH_3DES_EDE_CBC_SHA" , "TLS_RSA_WITH_NULL_SHA256" , "TLS_ECDHE_ECDSA_WITH_NULL_SHA" , "TLS_ECDHE_RSA_WITH_NULL_SHA" , "SSL_RSA_WITH_NULL_SHA" , "TLS_ECDH_ECDSA_WITH_NULL_SHA" , "TLS_ECDH_RSA_WITH_NULL_SHA" , "TLS_ECDH_anon_WITH_NULL_SHA" , "SSL_RSA_WITH_NULL_MD5" , "SSL_RSA_WITH_DES_CBC_SHA" , "SSL_DHE_RSA_WITH_DES_CBC_SHA" , "SSL_DHE_DSS_WITH_DES_CBC_SHA" , "SSL_DH_anon_WITH_DES_CBC_SHA" , "SSL_RSA_EXPORT_WITH_RC4_40_MD5" , "SSL_DH_anon_EXPORT_WITH_RC4_40_MD5" , "SSL_RSA_EXPORT_WITH_DES40_CBC_SHA" , "SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA" , "SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA" , "SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA" , "TLS_KRB5_WITH_RC4_128_SHA" , "TLS_KRB5_WITH_RC4_128_MD5" , "TLS_KRB5_WITH_3DES_EDE_CBC_SHA" , "TLS_KRB5_WITH_3DES_EDE_CBC_MD5" , "TLS_KRB5_WITH_DES_CBC_SHA" , "TLS_KRB5_WITH_DES_CBC_MD5" , "TLS_KRB5_EXPORT_WITH_RC4_40_SHA" , "TLS_KRB5_EXPORT_WITH_RC4_40_MD5" , "TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA" , "TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5" } ; protected Context createWorker ( ) throws Exception { CompletableFuture < Context > fut = new CompletableFuture < > ( ) ; vertx . deployVerticle ( new AbstractVerticle ( ) { @ Override public void start ( ) throws Exception { fut . complete ( context ) ; } } , new DeploymentOptions ( ) . setWorker ( true ) , ar - > { if ( ar . failed ( ) ) { fut . completeExceptionally ( ar . cause ( ) ) ; } } ) ; return fut . get ( ) ; } protected List < Context > createWorkers ( int num ) throws Exception { List < Context > contexts = new ArrayList < > ( ) ; for ( int i = 0 ; i < num ; i ++ ) { contexts . add ( createWorker ( ) ) ; } return contexts ; } }
package io . vertx . test . core ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . net . impl . ServerID ; import io . vertx . core . spi . cluster . AsyncMultiMap ; import io . vertx . core . spi . cluster . ClusterManager ; import org . junit . Test ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . CountDownLatch ; public class AsyncMultiMapTest extends VertxTestBase { protected ClusterManager clusterManager ; protected volatile AsyncMultiMap < String , ServerID > map ; @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; startNodes ( 1 ) ; clusterManager = ( ( VertxInternal ) vertices [ 0 ] ) . getClusterManager ( ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; clusterManager . < String , ServerID > getAsyncMultiMap ( "mymap" , onSuccess ( res - > { map = res ; latch . countDown ( ) ; } ) ) ; awaitLatch ( latch ) ; } @ Test public void testMapAddGet ( ) { ServerID serverID1 = new ServerID ( 1234 , "foo.com" ) ; map . add ( "some-sub" , serverID1 , onSuccess ( res - > { assertNull ( res ) ; ServerID serverID2 = new ServerID ( 4321 , "blah.com" ) ; map . add ( "some-sub" , serverID2 , onSuccess ( res2 - > { assertNull ( res2 ) ; ServerID serverID3 = new ServerID ( 5432 , "quux.com" ) ; map . add ( "some-sub2" , serverID3 , onSuccess ( res3 - > { assertNull ( res3 ) ; map . get ( "some-sub" , onSuccess ( res4 - > { Set < ServerID > set = new HashSet < > ( ) ; for ( ServerID sid : res4 ) { set . add ( sid ) ; } assertEquals ( 2 , set . size ( ) ) ; assertTrue ( set . contains ( serverID1 ) ) ; assertTrue ( set . contains ( serverID2 ) ) ; map . get ( "some-sub2" , onSuccess ( res5 - > { Set < ServerID > set2 = new HashSet < > ( ) ; for ( ServerID sid : res5 ) { set2 . add ( sid ) ; } assertEquals ( 1 , set2 . size ( ) ) ; assertTrue ( set2 . contains ( serverID3 ) ) ; testComplete ( ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; await ( ) ; } @ Test public void testMapRemove ( ) { ServerID serverID1 = new ServerID ( 1234 , "foo.com" ) ; map . add ( "some-sub" , serverID1 , onSuccess ( res - > { assertNull ( res ) ; ServerID serverID2 = new ServerID ( 4321 , "blah.com" ) ; map . add ( "some-sub" , serverID2 , onSuccess ( res2 - > { assertNull ( res2 ) ; ServerID serverID3 = new ServerID ( 5432 , "quux.com" ) ; map . add ( "some-sub2" , serverID3 , onSuccess ( res3 - > { assertNull ( res3 ) ; map . get ( "some-sub" , onSuccess ( res4 - > { Set < ServerID > set = new HashSet < > ( ) ; for ( ServerID sid : res4 ) { set . add ( sid ) ; } assertEquals ( 2 , set . size ( ) ) ; assertTrue ( set . contains ( serverID1 ) ) ; assertTrue ( set . contains ( serverID2 ) ) ; map . get ( "some-sub2" , onSuccess ( res5 - > { Set < ServerID > set2 = new HashSet < > ( ) ; for ( ServerID sid : res5 ) { set2 . add ( sid ) ; } assertEquals ( 1 , set2 . size ( ) ) ; assertTrue ( set2 . contains ( serverID3 ) ) ; map . remove ( "some-sub2" , serverID1 , onSuccess ( res6 - > { assertFalse ( res6 ) ; map . remove ( "some-sub2" , serverID3 , onSuccess ( res7 - > { map . get ( "some-sub2" , onSuccess ( res8 - > { Set < ServerID > set3 = new HashSet < > ( ) ; for ( ServerID sid : res8 ) { set3 . add ( sid ) ; } assertEquals ( 0 , set3 . size ( ) ) ; testComplete ( ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; await ( ) ; } @ Test public void testRemoveAllForValue ( ) { ServerID serverID1 = new ServerID ( 1234 , "foo.com" ) ; map . add ( "some-sub" , serverID1 , onSuccess ( res - > { assertNull ( res ) ; ServerID serverID2 = new ServerID ( 4321 , "blah.com" ) ; map . add ( "some-sub" , serverID2 , onSuccess ( res2 - > { assertNull ( res2 ) ; map . add ( "some-sub2" , serverID1 , onSuccess ( res3 - > { assertNull ( res3 ) ; map . removeAllForValue ( serverID1 , onSuccess ( res4 - > { assertNull ( res4 ) ; map . get ( "some-sub" , onSuccess ( res5 - > { Set < ServerID > set = new HashSet < > ( ) ; for ( ServerID sid : res5 ) { set . add ( sid ) ; } assertEquals ( 1 , set . size ( ) ) ; assertTrue ( set . contains ( serverID2 ) ) ; assertFalse ( set . contains ( serverID1 ) ) ; map . get ( "some-sub2" , onSuccess ( res6 - > { Set < ServerID > set2 = new HashSet < > ( ) ; for ( ServerID sid : res6 ) { set2 . add ( sid ) ; } assertEquals ( 0 , set2 . size ( ) ) ; testComplete ( ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; await ( ) ; } }
package io . vertx . test . core ; import io . netty . util . CharsetUtil ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . DeliveryOptions ; import io . vertx . core . eventbus . MessageCodec ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import org . junit . Test ; import java . util . concurrent . CountDownLatch ; import java . util . function . Consumer ; public abstract class EventBusTestBase extends VertxTestBase { protected static final String ADDRESS1 = "some-address1" ; protected static final String ADDRESS2 = "some-address2" ; @ Test public void testSendNull ( ) { testSend ( null ) ; } @ Test public void testReplyNull ( ) { testReply ( null ) ; } @ Test public void testPublishNull ( ) { testPublish ( null ) ; } @ Test public void testSendString ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; testSend ( str ) ; } @ Test public void testReplyString ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; testReply ( str ) ; } @ Test public void testPublishString ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; testPublish ( str ) ; } @ Test public void testSendBooleanTrue ( ) { testSend ( true ) ; } @ Test public void testSendBooleanFalse ( ) { testSend ( false ) ; } @ Test public void testReplyBooleanTrue ( ) { testReply ( true ) ; } @ Test public void testReplyBooleanFalse ( ) { testReply ( false ) ; } @ Test public void testPublishBooleanTrue ( ) { testPublish ( true ) ; } @ Test public void testPublishBooleanFalse ( ) { testPublish ( false ) ; } @ Test public void testSendBuffer ( ) { Buffer sent = TestUtils . randomBuffer ( 100 ) ; testSend ( sent , ( buffer ) - > { assertEquals ( sent , buffer ) ; assertFalse ( sent == buffer ) ; } ) ; } @ Test public void testReplyBuffer ( ) { Buffer sent = TestUtils . randomBuffer ( 100 ) ; testReply ( sent , ( bytes ) - > { assertEquals ( sent , bytes ) ; assertFalse ( sent == bytes ) ; } ) ; } @ Test public void testPublishBuffer ( ) { Buffer sent = TestUtils . randomBuffer ( 100 ) ; testPublish ( sent , ( buffer ) - > { assertEquals ( sent , buffer ) ; assertFalse ( sent == buffer ) ; } ) ; } @ Test public void testSendByte ( ) { testSend ( TestUtils . randomByte ( ) ) ; } @ Test public void testReplyByte ( ) { testReply ( TestUtils . randomByte ( ) ) ; } @ Test public void testPublishByte ( ) { testPublish ( TestUtils . randomByte ( ) ) ; } @ Test public void testSendByteArray ( ) { byte [ ] sent = TestUtils . randomByteArray ( 100 ) ; testSend ( sent , ( bytes ) - > { TestUtils . byteArraysEqual ( sent , bytes ) ; assertFalse ( sent == bytes ) ; } ) ; } @ Test public void testReplyByteArray ( ) { byte [ ] sent = TestUtils . randomByteArray ( 100 ) ; testReply ( sent , ( bytes ) - > { TestUtils . byteArraysEqual ( sent , bytes ) ; assertFalse ( sent == bytes ) ; } ) ; } @ Test public void testPublishByteArray ( ) { byte [ ] sent = TestUtils . randomByteArray ( 100 ) ; testPublish ( sent , ( bytes ) - > { TestUtils . byteArraysEqual ( sent , bytes ) ; assertFalse ( sent == bytes ) ; } ) ; } @ Test public void testSendCharacter ( ) { testSend ( TestUtils . randomChar ( ) ) ; } @ Test public void testReplyCharacter ( ) { testReply ( TestUtils . randomChar ( ) ) ; } @ Test public void testPublishCharacter ( ) { testPublish ( TestUtils . randomChar ( ) ) ; } @ Test public void testSendDouble ( ) { testSend ( TestUtils . randomDouble ( ) ) ; } @ Test public void testReplyDouble ( ) { testReply ( TestUtils . randomDouble ( ) ) ; } @ Test public void testPublishDouble ( ) { testPublish ( TestUtils . randomDouble ( ) ) ; } @ Test public void testSendFloat ( ) { testSend ( TestUtils . randomFloat ( ) ) ; } @ Test public void testReplyFloat ( ) { testReply ( TestUtils . randomFloat ( ) ) ; } @ Test public void testPublishFloat ( ) { testPublish ( TestUtils . randomFloat ( ) ) ; } @ Test public void testSendInteger ( ) { testSend ( TestUtils . randomInt ( ) ) ; } @ Test public void testReplyInteger ( ) { testReply ( TestUtils . randomInt ( ) ) ; } @ Test public void testPublishInteger ( ) { testPublish ( TestUtils . randomInt ( ) ) ; } @ Test public void testSendLong ( ) { testSend ( TestUtils . randomLong ( ) ) ; } @ Test public void testReplyLong ( ) { testReply ( TestUtils . randomLong ( ) ) ; } @ Test public void testPublishLong ( ) { testPublish ( TestUtils . randomLong ( ) ) ; } @ Test public void testSendShort ( ) { testSend ( TestUtils . randomShort ( ) ) ; } @ Test public void testReplyShort ( ) { testReply ( TestUtils . randomShort ( ) ) ; } @ Test public void testPublishShort ( ) { testPublish ( TestUtils . randomShort ( ) ) ; } @ Test public void testSendJsonArray ( ) { JsonArray arr = new JsonArray ( ) ; arr . add ( TestUtils . randomUnicodeString ( 100 ) ) . add ( TestUtils . randomInt ( ) ) . add ( TestUtils . randomBoolean ( ) ) ; testSend ( arr , ( received ) - > { assertEquals ( arr , received ) ; assertFalse ( arr == received ) ; } ) ; } @ Test public void testReplyJsonArray ( ) { JsonArray arr = new JsonArray ( ) ; arr . add ( TestUtils . randomUnicodeString ( 100 ) ) . add ( TestUtils . randomInt ( ) ) . add ( TestUtils . randomBoolean ( ) ) ; testReply ( arr , ( received ) - > { assertEquals ( arr , received ) ; assertFalse ( arr == received ) ; } ) ; } @ Test public void testPublishJsonArray ( ) { JsonArray arr = new JsonArray ( ) ; arr . add ( TestUtils . randomUnicodeString ( 100 ) ) . add ( TestUtils . randomInt ( ) ) . add ( TestUtils . randomBoolean ( ) ) ; testPublish ( arr , ( received ) - > { assertEquals ( arr , received ) ; assertFalse ( arr == received ) ; } ) ; } @ Test public void testSendJsonObject ( ) { JsonObject obj = new JsonObject ( ) ; obj . put ( TestUtils . randomUnicodeString ( 100 ) , TestUtils . randomUnicodeString ( 100 ) ) . put ( TestUtils . randomUnicodeString ( 100 ) , TestUtils . randomInt ( ) ) ; testSend ( obj , ( received ) - > { assertEquals ( obj , received ) ; assertFalse ( obj == received ) ; } ) ; } @ Test public void testReplyJsonObject ( ) { JsonObject obj = new JsonObject ( ) ; obj . put ( TestUtils . randomUnicodeString ( 100 ) , TestUtils . randomUnicodeString ( 100 ) ) . put ( TestUtils . randomUnicodeString ( 100 ) , TestUtils . randomInt ( ) ) ; testReply ( obj , ( received ) - > { assertEquals ( obj , received ) ; assertFalse ( obj == received ) ; } ) ; } @ Test public void testPublishJsonObject ( ) { JsonObject obj = new JsonObject ( ) ; obj . put ( TestUtils . randomUnicodeString ( 100 ) , TestUtils . randomUnicodeString ( 100 ) ) . put ( TestUtils . randomUnicodeString ( 100 ) , TestUtils . randomInt ( ) ) ; testPublish ( obj , ( received ) - > { assertEquals ( obj , received ) ; assertFalse ( obj == received ) ; } ) ; } @ Test public void testSendWithHeaders ( ) { testSend ( "foo" , "foo" , null , new DeliveryOptions ( ) . addHeader ( "uhqwduh" , "qijwdqiuwd" ) . addHeader ( "iojdijef" , "iqjwddh" ) ) ; } @ Test public void testSendWithDeliveryOptionsButNoHeaders ( ) { testSend ( "foo" , "foo" , null , new DeliveryOptions ( ) ) ; } @ Test public void testReplyWithHeaders ( ) { testReply ( "foo" , "foo" , null , new DeliveryOptions ( ) . addHeader ( "uhqwduh" , "qijwdqiuwd" ) . addHeader ( "iojdijef" , "iqjwddh" ) ) ; } @ Test public void testSendFromWorker ( ) throws Exception { String expectedBody = TestUtils . randomAlphaString ( 20 ) ; startNodes ( 2 ) ; vertices [ 1 ] . eventBus ( ) . < String > consumer ( ADDRESS1 , msg - > { assertEquals ( expectedBody , msg . body ( ) ) ; testComplete ( ) ; } ) . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; vertices [ 0 ] . deployVerticle ( new AbstractVerticle ( ) { @ Override public void start ( ) throws Exception { vertices [ 0 ] . eventBus ( ) . send ( ADDRESS1 , expectedBody ) ; } } , new DeploymentOptions ( ) . setWorker ( true ) ) ; } ) ; await ( ) ; } @ Test public void testReplyFromWorker ( ) throws Exception { String expectedBody = TestUtils . randomAlphaString ( 20 ) ; startNodes ( 2 ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; vertices [ 0 ] . deployVerticle ( new AbstractVerticle ( ) { @ Override public void start ( ) throws Exception { vertices [ 1 ] . eventBus ( ) . < String > consumer ( ADDRESS1 , msg - > { msg . reply ( expectedBody ) ; } ) . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; latch . countDown ( ) ; } ) ; } } , new DeploymentOptions ( ) . setWorker ( true ) ) ; awaitLatch ( latch ) ; vertices [ 0 ] . eventBus ( ) . send ( ADDRESS1 , "whatever" , reply - > { assertTrue ( reply . succeeded ( ) ) ; assertEquals ( expectedBody , reply . result ( ) . body ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } protected < T > void testSend ( T val ) { testSend ( val , null ) ; } protected abstract < T , R > void testSend ( T val , R received , Consumer < T > consumer , DeliveryOptions options ) ; protected abstract < T > void testSend ( T val , Consumer < T > consumer ) ; protected < T > void testReply ( T val ) { testReply ( val , null ) ; } protected abstract < T > void testReply ( T val , Consumer < T > consumer ) ; protected abstract < T , R > void testReply ( T val , R received , Consumer < R > consumer , DeliveryOptions options ) ; protected < T > void testPublish ( T val ) { testPublish ( val , null ) ; } protected abstract < T > void testPublish ( T val , Consumer < T > consumer ) ; public static class MySystemDecoder implements MessageCodec < MyPOJO , String > { @ Override public void encodeToWire ( Buffer buffer , MyPOJO s ) { } @ Override public String decodeFromWire ( int pos , Buffer buffer ) { return null ; } @ Override public String transform ( MyPOJO s ) { return null ; } @ Override public String name ( ) { return "mysystemdecoder" ; } @ Override public byte systemCodecID ( ) { return 0 ; } } public static class NullNameCodec implements MessageCodec < String , String > { @ Override public void encodeToWire ( Buffer buffer , String s ) { } @ Override public String decodeFromWire ( int pos , Buffer buffer ) { return null ; } @ Override public String transform ( String s ) { return null ; } @ Override public String name ( ) { return null ; } @ Override public byte systemCodecID ( ) { return 0 ; } } public static class MyPOJOEncoder1 implements MessageCodec < MyPOJO , String > { @ Override public void encodeToWire ( Buffer buffer , MyPOJO myPOJO ) { byte [ ] bytes = myPOJO . getStr ( ) . getBytes ( CharsetUtil . UTF_8 ) ; buffer . appendInt ( bytes . length ) ; buffer . appendBytes ( bytes ) ; } @ Override public String decodeFromWire ( int pos , Buffer buffer ) { int length = buffer . getInt ( pos ) ; pos += 4 ; byte [ ] bytes = buffer . getBytes ( pos , pos + length ) ; return new String ( bytes , CharsetUtil . UTF_8 ) ; } @ Override public String transform ( MyPOJO myPOJO ) { return myPOJO . getStr ( ) ; } @ Override public String name ( ) { return "mypojoencoder1" ; } @ Override public byte systemCodecID ( ) { return - 1 ; } } public static class MyPOJOEncoder2 implements MessageCodec < MyPOJO , MyPOJO > { @ Override public void encodeToWire ( Buffer buffer , MyPOJO myPOJO ) { byte [ ] bytes = myPOJO . getStr ( ) . getBytes ( CharsetUtil . UTF_8 ) ; buffer . appendInt ( bytes . length ) ; buffer . appendBytes ( bytes ) ; } @ Override public MyPOJO decodeFromWire ( int pos , Buffer buffer ) { int length = buffer . getInt ( pos ) ; pos += 4 ; byte [ ] bytes = buffer . getBytes ( pos , pos + length ) ; String str = new String ( bytes , CharsetUtil . UTF_8 ) ; return new MyPOJO ( str ) ; } @ Override public MyPOJO transform ( MyPOJO myPOJO ) { return new MyPOJO ( myPOJO . getStr ( ) ) ; } @ Override public String name ( ) { return "mypojoencoder2" ; } @ Override public byte systemCodecID ( ) { return - 1 ; } } public static class MyPOJO { private String str ; public MyPOJO ( String str ) { this . str = str ; } public String getStr ( ) { return str ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; MyPOJO myPOJO = ( MyPOJO ) o ; if ( str != null ? ! str . equals ( myPOJO . str ) : myPOJO . str != null ) return false ; return true ; } @ Override public int hashCode ( ) { return str != null ? str . hashCode ( ) : 0 ; } } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . impl . IsolatingClassLoader ; import org . junit . Assert ; public class ExtraCPVerticleAlreadyInParentLoader extends AbstractVerticle { @ Override public void start ( ) throws Exception { IsolatingClassLoader cl = ( IsolatingClassLoader ) Thread . currentThread ( ) . getContextClassLoader ( ) ; Class extraCPClass = cl . loadClass ( "MyVerticle" ) ; Assert . assertSame ( extraCPClass . getClassLoader ( ) , cl . getParent ( ) ) ; } }
package io . vertx . test . core ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import io . vertx . core . net . PemTrustOptions ; import io . vertx . core . net . JksOptions ; import io . vertx . core . net . PemKeyCertOptions ; import io . vertx . core . net . KeyCertOptions ; import io . vertx . core . net . PfxOptions ; import io . vertx . core . net . TrustOptions ; import io . vertx . core . net . impl . KeyStoreHelper ; import org . junit . Test ; import javax . net . ssl . KeyManager ; import javax . net . ssl . TrustManager ; import java . util . Collections ; import static io . vertx . test . core . TestUtils . assertIllegalArgumentException ; import static io . vertx . test . core . TestUtils . assertNullPointerException ; public class KeyStoreTest extends VertxTestBase { @ Test public void testJKSOptions ( ) throws Exception { JksOptions options = new JksOptions ( ) ; assertNull ( options . getPath ( ) ) ; String randString = TestUtils . randomAlphaString ( 100 ) ; assertEquals ( options , options . setPath ( randString ) ) ; assertEquals ( randString , options . getPath ( ) ) ; assertNull ( options . getPassword ( ) ) ; randString = TestUtils . randomAlphaString ( 100 ) ; assertEquals ( options , options . setPassword ( randString ) ) ; assertEquals ( randString , options . getPassword ( ) ) ; } @ Test public void testDefaultJKSOptionsJson ( ) { JksOptions def = new JksOptions ( ) ; JksOptions json = new JksOptions ( new JsonObject ( ) ) ; assertEquals ( def . getPassword ( ) , json . getPassword ( ) ) ; assertEquals ( def . getPath ( ) , json . getPath ( ) ) ; assertEquals ( def . getValue ( ) , json . getValue ( ) ) ; } @ Test public void testJKSOptionsJson ( ) throws Exception { JksOptions options = new JksOptions ( new JsonObject ( ) ) ; assertEquals ( null , options . getPassword ( ) ) ; assertEquals ( null , options . getPath ( ) ) ; assertEquals ( null , options . getValue ( ) ) ; String password = TestUtils . randomAlphaString ( 100 ) ; String path = TestUtils . randomAlphaString ( 100 ) ; String value = TestUtils . randomAlphaString ( 100 ) ; options = new JksOptions ( new JsonObject ( ) . put ( "password" , password ) . put ( "path" , path ) . put ( "value" , value . getBytes ( ) ) ) ; assertEquals ( password , options . getPassword ( ) ) ; assertEquals ( path , options . getPath ( ) ) ; assertEquals ( Buffer . buffer ( value ) , options . getValue ( ) ) ; } @ Test public void testCopyJKSOptions ( ) throws Exception { JksOptions options = new JksOptions ( ) ; String password = TestUtils . randomAlphaString ( 100 ) ; String path = TestUtils . randomAlphaString ( 100 ) ; Buffer value = Buffer . buffer ( TestUtils . randomAlphaString ( 100 ) ) ; options . setPassword ( password ) ; options . setPath ( path ) ; options . setValue ( value ) ; options = new JksOptions ( options ) ; assertEquals ( password , options . getPassword ( ) ) ; assertEquals ( path , options . getPath ( ) ) ; assertEquals ( value , options . getValue ( ) ) ; } @ Test public void testPKCS12Options ( ) throws Exception { PfxOptions options = new PfxOptions ( ) ; assertNull ( options . getPath ( ) ) ; String randString = TestUtils . randomAlphaString ( 100 ) ; assertEquals ( options , options . setPath ( randString ) ) ; assertEquals ( randString , options . getPath ( ) ) ; assertNull ( options . getPassword ( ) ) ; randString = TestUtils . randomAlphaString ( 100 ) ; assertEquals ( options , options . setPassword ( randString ) ) ; assertEquals ( randString , options . getPassword ( ) ) ; } @ Test public void testDefaultPKCS12OptionsJson ( ) { PfxOptions def = new PfxOptions ( ) ; PfxOptions json = new PfxOptions ( new JsonObject ( ) ) ; assertEquals ( def . getPassword ( ) , json . getPassword ( ) ) ; assertEquals ( def . getPath ( ) , json . getPath ( ) ) ; assertEquals ( def . getValue ( ) , json . getValue ( ) ) ; } @ Test public void testPKCS12OptionsJson ( ) throws Exception { PfxOptions options = new PfxOptions ( new JsonObject ( ) ) ; assertEquals ( null , options . getPassword ( ) ) ; assertEquals ( null , options . getPath ( ) ) ; assertEquals ( null , options . getValue ( ) ) ; String password = TestUtils . randomAlphaString ( 100 ) ; String path = TestUtils . randomAlphaString ( 100 ) ; String value = TestUtils . randomAlphaString ( 100 ) ; options = new PfxOptions ( new JsonObject ( ) . put ( "password" , password ) . put ( "path" , path ) . put ( "value" , value . getBytes ( ) ) ) ; assertEquals ( password , options . getPassword ( ) ) ; assertEquals ( path , options . getPath ( ) ) ; assertEquals ( Buffer . buffer ( value ) , options . getValue ( ) ) ; } @ Test public void testCopyPKCS12Options ( ) throws Exception { PfxOptions options = new PfxOptions ( ) ; String password = TestUtils . randomAlphaString ( 100 ) ; String path = TestUtils . randomAlphaString ( 100 ) ; Buffer value = Buffer . buffer ( TestUtils . randomAlphaString ( 100 ) ) ; options . setPassword ( password ) ; options . setPath ( path ) ; options . setValue ( value ) ; options = new PfxOptions ( options ) ; assertEquals ( password , options . getPassword ( ) ) ; assertEquals ( path , options . getPath ( ) ) ; assertEquals ( value , options . getValue ( ) ) ; } @ Test public void testKeyCertOptions ( ) throws Exception { PemKeyCertOptions options = new PemKeyCertOptions ( ) ; assertNull ( options . getKeyPath ( ) ) ; String randString = TestUtils . randomAlphaString ( 100 ) ; assertEquals ( options , options . setKeyPath ( randString ) ) ; assertEquals ( randString , options . getKeyPath ( ) ) ; assertNull ( options . getCertPath ( ) ) ; randString = TestUtils . randomAlphaString ( 100 ) ; assertEquals ( options , options . setCertPath ( randString ) ) ; assertEquals ( randString , options . getCertPath ( ) ) ; } @ Test public void testDefaultKeyCertOptionsJson ( ) throws Exception { PemKeyCertOptions def = new PemKeyCertOptions ( ) ; PemKeyCertOptions json = new PemKeyCertOptions ( new JsonObject ( ) ) ; assertEquals ( def . getKeyPath ( ) , json . getKeyPath ( ) ) ; assertEquals ( def . getCertPath ( ) , json . getCertPath ( ) ) ; assertEquals ( def . getKeyValue ( ) , json . getKeyValue ( ) ) ; assertEquals ( def . getCertValue ( ) , json . getCertValue ( ) ) ; } @ Test public void testKeyCertOptionsJson ( ) throws Exception { PemKeyCertOptions options = new PemKeyCertOptions ( new JsonObject ( ) ) ; assertEquals ( null , options . getKeyPath ( ) ) ; assertEquals ( null , options . getKeyValue ( ) ) ; assertEquals ( null , options . getCertPath ( ) ) ; assertEquals ( null , options . getCertValue ( ) ) ; String keyPath = TestUtils . randomAlphaString ( 100 ) ; String keyValue = TestUtils . randomAlphaString ( 100 ) ; String certPath = TestUtils . randomAlphaString ( 100 ) ; String certValue = TestUtils . randomAlphaString ( 100 ) ; options = new PemKeyCertOptions ( new JsonObject ( ) . put ( "keyPath" , keyPath ) . put ( "keyValue" , keyValue . getBytes ( ) ) . put ( "certPath" , certPath ) . put ( "certValue" , certValue . getBytes ( ) ) ) ; assertEquals ( keyPath , options . getKeyPath ( ) ) ; assertEquals ( Buffer . buffer ( keyValue ) , options . getKeyValue ( ) ) ; assertEquals ( certPath , options . getCertPath ( ) ) ; assertEquals ( Buffer . buffer ( certValue ) , options . getCertValue ( ) ) ; } @ Test public void testCopyKeyCertOptions ( ) throws Exception { PemKeyCertOptions options = new PemKeyCertOptions ( new JsonObject ( ) ) ; String keyPath = TestUtils . randomAlphaString ( 100 ) ; Buffer keyValue = Buffer . buffer ( TestUtils . randomAlphaString ( 100 ) ) ; String certPath = TestUtils . randomAlphaString ( 100 ) ; Buffer certValue = Buffer . buffer ( TestUtils . randomAlphaString ( 100 ) ) ; options . setKeyPath ( keyPath ) ; options . setKeyValue ( keyValue ) ; options . setCertPath ( certPath ) ; options . setCertValue ( certValue ) ; options = new PemKeyCertOptions ( options ) ; assertEquals ( keyPath , options . getKeyPath ( ) ) ; assertEquals ( keyValue , options . getKeyValue ( ) ) ; assertEquals ( certPath , options . getCertPath ( ) ) ; assertEquals ( certValue , options . getCertValue ( ) ) ; } @ Test public void testTrustOptions ( ) throws Exception { PemTrustOptions options = new PemTrustOptions ( ) ; assertEquals ( Collections . emptyList ( ) , options . getCertPaths ( ) ) ; assertNullPointerException ( ( ) - > options . addCertPath ( null ) ) ; assertIllegalArgumentException ( ( ) - > options . addCertPath ( "" ) ) ; String randString = TestUtils . randomAlphaString ( 100 ) ; options . addCertPath ( randString ) ; assertEquals ( Collections . singletonList ( randString ) , options . getCertPaths ( ) ) ; assertEquals ( Collections . emptyList ( ) , options . getCertValues ( ) ) ; assertNullPointerException ( ( ) - > options . addCertValue ( null ) ) ; randString = TestUtils . randomAlphaString ( 100 ) ; options . addCertValue ( Buffer . buffer ( randString ) ) ; assertEquals ( Collections . singletonList ( Buffer . buffer ( randString ) ) , options . getCertValues ( ) ) ; } @ Test public void testTrustOptionsJson ( ) throws Exception { PemTrustOptions options = new PemTrustOptions ( new JsonObject ( ) ) ; assertEquals ( Collections . emptyList ( ) , options . getCertPaths ( ) ) ; assertEquals ( Collections . emptyList ( ) , options . getCertValues ( ) ) ; String certPath = TestUtils . randomAlphaString ( 100 ) ; String certValue = TestUtils . randomAlphaString ( 100 ) ; JsonObject json = new JsonObject ( ) . put ( "certPaths" , new JsonArray ( ) . add ( certPath ) ) . put ( "certValues" , new JsonArray ( ) . add ( certValue . getBytes ( ) ) ) ; options = new PemTrustOptions ( json ) ; assertEquals ( Collections . singletonList ( certPath ) , options . getCertPaths ( ) ) ; assertEquals ( Collections . singletonList ( Buffer . buffer ( certValue ) ) , options . getCertValues ( ) ) ; } @ Test public void testDefaultTrustOptionsJson ( ) { PemTrustOptions def = new PemTrustOptions ( ) ; PemTrustOptions json = new PemTrustOptions ( new JsonObject ( ) ) ; assertEquals ( def . getCertPaths ( ) , json . getCertPaths ( ) ) ; assertEquals ( def . getCertValues ( ) , json . getCertValues ( ) ) ; } @ Test public void testCopyTrustOptions ( ) throws Exception { PemTrustOptions options = new PemTrustOptions ( new JsonObject ( ) ) ; String certPath = TestUtils . randomAlphaString ( 100 ) ; Buffer certValue = Buffer . buffer ( TestUtils . randomAlphaString ( 100 ) ) ; options . addCertPath ( certPath ) ; options . addCertValue ( certValue ) ; options = new PemTrustOptions ( options ) ; assertEquals ( Collections . singletonList ( certPath ) , options . getCertPaths ( ) ) ; assertEquals ( Collections . singletonList ( certValue ) , options . getCertValues ( ) ) ; } @ Test public void testJKSPath ( ) throws Exception { testKeyStore ( getServerCertOptions ( KeyCert . JKS ) ) ; } @ Test public void testJKSValue ( ) throws Exception { JksOptions options = ( JksOptions ) getServerCertOptions ( KeyCert . JKS ) ; Buffer store = vertx . fileSystem ( ) . readFileBlocking ( options . getPath ( ) ) ; options . setPath ( null ) . setValue ( store ) ; testKeyStore ( options ) ; } @ Test public void testPKCS12Path ( ) throws Exception { testKeyStore ( getServerCertOptions ( KeyCert . PKCS12 ) ) ; } @ Test public void testPKCS12Value ( ) throws Exception { PfxOptions options = ( PfxOptions ) getServerCertOptions ( KeyCert . PKCS12 ) ; Buffer store = vertx . fileSystem ( ) . readFileBlocking ( options . getPath ( ) ) ; options . setPath ( null ) . setValue ( store ) ; testKeyStore ( options ) ; } @ Test public void testKeyCertPath ( ) throws Exception { testKeyStore ( getServerCertOptions ( KeyCert . PEM ) ) ; } @ Test public void testKeyCertValue ( ) throws Exception { PemKeyCertOptions options = ( PemKeyCertOptions ) getServerCertOptions ( KeyCert . PEM ) ; Buffer key = vertx . fileSystem ( ) . readFileBlocking ( options . getKeyPath ( ) ) ; options . setKeyValue ( null ) . setKeyValue ( key ) ; Buffer cert = vertx . fileSystem ( ) . readFileBlocking ( options . getCertPath ( ) ) ; options . setCertValue ( null ) . setCertValue ( cert ) ; testKeyStore ( options ) ; } @ Test public void testCaPath ( ) throws Exception { testTrustStore ( getServerTrustOptions ( Trust . PEM ) ) ; } @ Test public void testCaPathValue ( ) throws Exception { PemTrustOptions options = ( PemTrustOptions ) getServerTrustOptions ( Trust . PEM ) ; options . getCertPaths ( ) . stream ( ) . map ( vertx . fileSystem ( ) : : readFileBlocking ) . forEach ( options : : addCertValue ) ; options . getCertPaths ( ) . clear ( ) ; testTrustStore ( options ) ; } @ Test public void testKeyOptionsEquality ( ) { JksOptions jksOptions = ( JksOptions ) getServerCertOptions ( KeyCert . JKS ) ; JksOptions jksOptionsCopy = new JksOptions ( jksOptions ) ; PfxOptions pfxOptions = ( PfxOptions ) getServerCertOptions ( KeyCert . PKCS12 ) ; PfxOptions pfxOptionsCopy = new PfxOptions ( pfxOptions ) ; PemKeyCertOptions pemKeyCertOptions = ( PemKeyCertOptions ) getServerCertOptions ( KeyCert . PEM ) ; PemKeyCertOptions pemKeyCertOptionsCopy = new PemKeyCertOptions ( pemKeyCertOptions ) ; assertEquals ( jksOptions , jksOptionsCopy ) ; assertEquals ( jksOptions . hashCode ( ) , jksOptionsCopy . hashCode ( ) ) ; assertEquals ( pfxOptions , pfxOptionsCopy ) ; assertEquals ( pfxOptions . hashCode ( ) , pfxOptionsCopy . hashCode ( ) ) ; assertEquals ( pemKeyCertOptions , pemKeyCertOptionsCopy ) ; assertEquals ( pemKeyCertOptions . hashCode ( ) , pemKeyCertOptionsCopy . hashCode ( ) ) ; } private void testKeyStore ( KeyCertOptions options ) throws Exception { KeyStoreHelper helper = KeyStoreHelper . create ( ( VertxInternal ) vertx , options ) ; KeyManager [ ] keyManagers = helper . getKeyMgrs ( ( VertxInternal ) vertx ) ; assertTrue ( keyManagers . length > 0 ) ; } private void testTrustStore ( TrustOptions options ) throws Exception { KeyStoreHelper helper = KeyStoreHelper . create ( ( VertxInternal ) vertx , options ) ; TrustManager [ ] keyManagers = helper . getTrustMgrs ( ( VertxInternal ) vertx ) ; assertTrue ( keyManagers . length > 0 ) ; } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; public class HAVerticle3 extends AbstractVerticle { @ Override public void start ( ) throws Exception { } @ Override public void stop ( ) throws Exception { } }
package io . vertx . test . core ; public class HZBugTest { public static void main ( String [ ] args ) { new HZBugTest ( ) . run ( ) ; } public void run ( ) { } }
package io . vertx . test . core ; import io . vertx . core . metrics . MetricsOptions ; public class CustomMetricsOptions extends MetricsOptions { private String value ; public String getCustomProperty ( ) { return value ; } public void setCustomProperty ( String value ) { this . value = value ; } }
package io . vertx . test . core ; import io . vertx . core . Vertx ; public class ClusterWideMapTestDifferentNodes extends ClusterWideMapTest { @ Override protected int getNumNodes ( ) { return 2 ; } int pos ; @ Override protected Vertx getVertx ( ) { Vertx vertx = vertices [ pos ] ; if ( ++ pos == getNumNodes ( ) ) { pos = 0 ; } return vertx ; } }
package io . vertx . test . core ; import io . vertx . core . Vertx ; import io . vertx . core . spi . cluster . ClusterManager ; import io . vertx . test . fakecluster . FakeClusterManager ; public class ClusteredAsynchronousLockTest extends AsynchronousLockTest { @ Override protected ClusterManager getClusterManager ( ) { return new FakeClusterManager ( ) ; } protected final int numNodes = 2 ; public void setUp ( ) throws Exception { super . setUp ( ) ; startNodes ( numNodes ) ; } int pos ; @ Override protected Vertx getVertx ( ) { Vertx vertx = vertices [ pos ] ; if ( ++ pos == numNodes ) { pos = 0 ; } return vertx ; } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . AsyncResult ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Future ; import io . vertx . core . Handler ; import io . vertx . core . Verticle ; import io . vertx . core . Vertx ; import io . vertx . core . impl . Deployment ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . json . JsonObject ; import io . vertx . core . spi . VerticleFactory ; import org . junit . Test ; import java . io . IOException ; public class VerticleFactoryTest extends VertxTestBase { public void setUp ( ) throws Exception { super . setUp ( ) ; VerticleFactory factory = vertx . verticleFactories ( ) . iterator ( ) . next ( ) ; vertx . unregisterVerticleFactory ( factory ) ; } @ Test public void testRegister ( ) { assertTrue ( vertx . verticleFactories ( ) . isEmpty ( ) ) ; VerticleFactory fact1 = new TestVerticleFactory ( "foo" ) ; vertx . registerVerticleFactory ( fact1 ) ; assertEquals ( 1 , vertx . verticleFactories ( ) . size ( ) ) ; assertTrue ( vertx . verticleFactories ( ) . contains ( fact1 ) ) ; } @ Test public void testUnregister ( ) { VerticleFactory fact1 = new TestVerticleFactory ( "foo" ) ; vertx . registerVerticleFactory ( fact1 ) ; assertEquals ( 1 , vertx . verticleFactories ( ) . size ( ) ) ; assertTrue ( vertx . verticleFactories ( ) . contains ( fact1 ) ) ; vertx . unregisterVerticleFactory ( fact1 ) ; assertFalse ( vertx . verticleFactories ( ) . contains ( fact1 ) ) ; assertTrue ( vertx . verticleFactories ( ) . isEmpty ( ) ) ; } @ Test public void testRegisterTwice ( ) { VerticleFactory fact1 = new TestVerticleFactory ( "foo" ) ; vertx . registerVerticleFactory ( fact1 ) ; try { vertx . registerVerticleFactory ( fact1 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } } @ Test public void testUnregisterTwice ( ) { VerticleFactory fact1 = new TestVerticleFactory ( "foo" ) ; vertx . registerVerticleFactory ( fact1 ) ; vertx . unregisterVerticleFactory ( fact1 ) ; try { vertx . unregisterVerticleFactory ( fact1 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } } @ Test public void testUnregisterNoFact ( ) { VerticleFactory fact1 = new TestVerticleFactory ( "foo" ) ; try { vertx . unregisterVerticleFactory ( fact1 ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } } @ Test public void testRegisterUnregisterTwo ( ) { VerticleFactory fact1 = new TestVerticleFactory ( "foo" ) ; VerticleFactory fact2 = new TestVerticleFactory ( "bar" ) ; vertx . registerVerticleFactory ( fact1 ) ; assertEquals ( 1 , vertx . verticleFactories ( ) . size ( ) ) ; vertx . registerVerticleFactory ( fact2 ) ; assertEquals ( 2 , vertx . verticleFactories ( ) . size ( ) ) ; assertTrue ( vertx . verticleFactories ( ) . contains ( fact1 ) ) ; assertTrue ( vertx . verticleFactories ( ) . contains ( fact2 ) ) ; vertx . unregisterVerticleFactory ( fact1 ) ; assertFalse ( vertx . verticleFactories ( ) . contains ( fact1 ) ) ; assertEquals ( 1 , vertx . verticleFactories ( ) . size ( ) ) ; assertTrue ( vertx . verticleFactories ( ) . contains ( fact2 ) ) ; vertx . unregisterVerticleFactory ( fact2 ) ; assertTrue ( vertx . verticleFactories ( ) . isEmpty ( ) ) ; assertFalse ( vertx . verticleFactories ( ) . contains ( fact1 ) ) ; assertFalse ( vertx . verticleFactories ( ) . contains ( fact2 ) ) ; } @ Test public void testMatchWithPrefix ( ) { TestVerticle verticle1 = new TestVerticle ( ) ; TestVerticle verticle2 = new TestVerticle ( ) ; TestVerticle verticle3 = new TestVerticle ( ) ; TestVerticleFactory fact1 = new TestVerticleFactory ( "aa" , verticle1 ) ; TestVerticleFactory fact2 = new TestVerticleFactory ( "bb" , verticle2 ) ; TestVerticleFactory fact3 = new TestVerticleFactory ( "cc" , verticle3 ) ; vertx . registerVerticleFactory ( fact1 ) ; vertx . registerVerticleFactory ( fact2 ) ; vertx . registerVerticleFactory ( fact3 ) ; String name1 = "aa:myverticle1" ; String name2 = "bb:myverticle2" ; String name3 = "cc:myverticle3" ; vertx . deployVerticle ( name1 , new DeploymentOptions ( ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertEquals ( name1 , fact1 . identifier ) ; assertTrue ( verticle1 . startCalled ) ; assertFalse ( verticle2 . startCalled ) ; assertFalse ( verticle3 . startCalled ) ; assertNull ( fact2 . identifier ) ; assertNull ( fact3 . identifier ) ; vertx . deployVerticle ( name2 , new DeploymentOptions ( ) , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertEquals ( name2 , fact2 . identifier ) ; assertTrue ( verticle2 . startCalled ) ; assertFalse ( verticle3 . startCalled ) ; assertNull ( fact3 . identifier ) ; vertx . deployVerticle ( name3 , new DeploymentOptions ( ) , ar3 - > { assertTrue ( ar3 . succeeded ( ) ) ; assertEquals ( name3 , fact3 . identifier ) ; assertTrue ( verticle3 . startCalled ) ; testComplete ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testMatchWithSuffix ( ) { TestVerticle verticle1 = new TestVerticle ( ) ; TestVerticle verticle2 = new TestVerticle ( ) ; TestVerticle verticle3 = new TestVerticle ( ) ; TestVerticleFactory fact1 = new TestVerticleFactory ( "aa" , verticle1 ) ; TestVerticleFactory fact2 = new TestVerticleFactory ( "bb" , verticle2 ) ; TestVerticleFactory fact3 = new TestVerticleFactory ( "cc" , verticle3 ) ; vertx . registerVerticleFactory ( fact1 ) ; vertx . registerVerticleFactory ( fact2 ) ; vertx . registerVerticleFactory ( fact3 ) ; String name1 = "myverticle1.aa" ; String name2 = "myverticle2.bb" ; String name3 = "myverticle3.cc" ; vertx . deployVerticle ( name1 , new DeploymentOptions ( ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertEquals ( name1 , fact1 . identifier ) ; assertTrue ( verticle1 . startCalled ) ; assertFalse ( verticle2 . startCalled ) ; assertFalse ( verticle3 . startCalled ) ; assertNull ( fact2 . identifier ) ; assertNull ( fact3 . identifier ) ; vertx . deployVerticle ( name2 , new DeploymentOptions ( ) , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertEquals ( name2 , fact2 . identifier ) ; assertTrue ( verticle2 . startCalled ) ; assertFalse ( verticle3 . startCalled ) ; assertNull ( fact3 . identifier ) ; vertx . deployVerticle ( name3 , new DeploymentOptions ( ) , ar3 - > { assertTrue ( ar3 . succeeded ( ) ) ; assertEquals ( name3 , fact3 . identifier ) ; assertTrue ( verticle3 . startCalled ) ; testComplete ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testNoMatch ( ) { TestVerticle verticle1 = new TestVerticle ( ) ; TestVerticle verticle2 = new TestVerticle ( ) ; TestVerticleFactory fact1 = new TestVerticleFactory ( "aa" , verticle1 ) ; TestVerticleFactory fact2 = new TestVerticleFactory ( "bb" , verticle2 ) ; vertx . registerVerticleFactory ( fact1 ) ; vertx . registerVerticleFactory ( fact2 ) ; String name1 = "cc:myverticle1" ; vertx . deployVerticle ( name1 , new DeploymentOptions ( ) , ar - > { assertFalse ( ar . succeeded ( ) ) ; assertFalse ( verticle1 . startCalled ) ; assertFalse ( verticle2 . startCalled ) ; assertTrue ( ar . cause ( ) instanceof ClassNotFoundException ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testResolve ( ) { TestVerticle verticle = new TestVerticle ( ) ; TestVerticleFactory fact = new TestVerticleFactory ( "actual" , verticle ) ; vertx . registerVerticleFactory ( fact ) ; TestVerticleFactory factResolve = new TestVerticleFactory ( "resolve" , "actual:myverticle" ) ; vertx . registerVerticleFactory ( factResolve ) ; JsonObject config = new JsonObject ( ) . put ( "foo" , "bar" ) ; DeploymentOptions original = new DeploymentOptions ( ) . setWorker ( false ) . setConfig ( config ) . setIsolationGroup ( "somegroup" ) ; DeploymentOptions options = new DeploymentOptions ( original ) ; vertx . deployVerticle ( "resolve:someid" , options , res - > { assertTrue ( res . succeeded ( ) ) ; assertEquals ( "resolve:someid" , factResolve . identifierToResolve ) ; assertEquals ( options , factResolve . deploymentOptionsToResolve ) ; assertEquals ( "actual:myverticle" , fact . identifier ) ; assertTrue ( verticle . startCalled ) ; assertTrue ( verticle . startCalled ) ; assertEquals ( 1 , vertx . deploymentIDs ( ) . size ( ) ) ; Deployment dep = ( ( VertxInternal ) vertx ) . getDeployment ( res . result ( ) ) ; assertNotNull ( dep ) ; assertFalse ( original . equals ( dep . deploymentOptions ( ) ) ) ; assertFalse ( dep . deploymentOptions ( ) . getConfig ( ) . containsKey ( "foo" ) ) ; assertEquals ( "quux" , dep . deploymentOptions ( ) . getConfig ( ) . getString ( "wibble" ) ) ; assertTrue ( dep . deploymentOptions ( ) . isWorker ( ) ) ; assertEquals ( "othergroup" , dep . deploymentOptions ( ) . getIsolationGroup ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testOrdering ( ) { TestVerticle verticle = new TestVerticle ( ) ; TestVerticleFactory fact2 = new TestVerticleFactory ( "aa" , verticle , 2 ) ; vertx . registerVerticleFactory ( fact2 ) ; TestVerticleFactory fact1 = new TestVerticleFactory ( "aa" , verticle , 1 ) ; vertx . registerVerticleFactory ( fact1 ) ; TestVerticleFactory fact3 = new TestVerticleFactory ( "aa" , verticle , 3 ) ; vertx . registerVerticleFactory ( fact3 ) ; vertx . deployVerticle ( "aa:someverticle" , res - > { assertTrue ( res . succeeded ( ) ) ; assertEquals ( "aa:someverticle" , fact1 . identifier ) ; assertNull ( fact2 . identifier ) ; assertNull ( fact3 . identifier ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testOrderingFailedInCreate ( ) { TestVerticle verticle = new TestVerticle ( ) ; TestVerticleFactory fact2 = new TestVerticleFactory ( "aa" , verticle , 2 ) ; vertx . registerVerticleFactory ( fact2 ) ; TestVerticleFactory fact1 = new TestVerticleFactory ( "aa" , verticle , 1 , true ) ; vertx . registerVerticleFactory ( fact1 ) ; TestVerticleFactory fact3 = new TestVerticleFactory ( "aa" , verticle , 3 ) ; vertx . registerVerticleFactory ( fact3 ) ; vertx . deployVerticle ( "aa:someverticle" , res - > { assertTrue ( res . succeeded ( ) ) ; assertEquals ( "aa:someverticle" , fact2 . identifier ) ; assertNull ( fact1 . identifier ) ; assertNull ( fact3 . identifier ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testOrderingFailedInCreate2 ( ) { TestVerticle verticle = new TestVerticle ( ) ; TestVerticleFactory fact2 = new TestVerticleFactory ( "aa" , verticle , 2 , true ) ; vertx . registerVerticleFactory ( fact2 ) ; TestVerticleFactory fact1 = new TestVerticleFactory ( "aa" , verticle , 1 , true ) ; vertx . registerVerticleFactory ( fact1 ) ; TestVerticleFactory fact3 = new TestVerticleFactory ( "aa" , verticle , 3 ) ; vertx . registerVerticleFactory ( fact3 ) ; vertx . deployVerticle ( "aa:someverticle" , res - > { assertTrue ( res . succeeded ( ) ) ; assertEquals ( "aa:someverticle" , fact3 . identifier ) ; assertNull ( fact1 . identifier ) ; assertNull ( fact2 . identifier ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testOrderingFailedInCreateAll ( ) { TestVerticle verticle = new TestVerticle ( ) ; TestVerticleFactory fact2 = new TestVerticleFactory ( "aa" , verticle , 2 , true ) ; vertx . registerVerticleFactory ( fact2 ) ; TestVerticleFactory fact1 = new TestVerticleFactory ( "aa" , verticle , 1 , true ) ; vertx . registerVerticleFactory ( fact1 ) ; TestVerticleFactory fact3 = new TestVerticleFactory ( "aa" , verticle , 3 , true ) ; vertx . registerVerticleFactory ( fact3 ) ; vertx . deployVerticle ( "aa:someverticle" , res - > { assertFalse ( res . succeeded ( ) ) ; assertTrue ( res . cause ( ) instanceof ClassNotFoundException ) ; assertNull ( fact1 . identifier ) ; assertNull ( fact2 . identifier ) ; assertNull ( fact3 . identifier ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testOrderingFailedInResolve ( ) { TestVerticle verticle = new TestVerticle ( ) ; TestVerticleFactory factActual = new TestVerticleFactory ( "actual" , verticle ) ; vertx . registerVerticleFactory ( factActual ) ; TestVerticleFactory fact2 = new TestVerticleFactory ( "aa" , "actual:someverticle" , 2 ) ; vertx . registerVerticleFactory ( fact2 ) ; TestVerticleFactory fact1 = new TestVerticleFactory ( "aa" , "actual:someverticle" , 1 , true ) ; vertx . registerVerticleFactory ( fact1 ) ; TestVerticleFactory fact3 = new TestVerticleFactory ( "aa" , "actual:someverticle" , 3 ) ; vertx . registerVerticleFactory ( fact3 ) ; vertx . deployVerticle ( "aa:blah" , res - > { assertTrue ( res . succeeded ( ) ) ; assertNull ( fact2 . identifier ) ; assertNull ( fact1 . identifier ) ; assertNull ( fact3 . identifier ) ; assertEquals ( "aa:blah" , fact2 . identifierToResolve ) ; assertNull ( fact1 . identifierToResolve ) ; assertNull ( fact3 . identifierToResolve ) ; assertEquals ( "actual:someverticle" , factActual . identifier ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testOrderingFailedInResolve2 ( ) { TestVerticle verticle = new TestVerticle ( ) ; TestVerticleFactory factActual = new TestVerticleFactory ( "actual" , verticle ) ; vertx . registerVerticleFactory ( factActual ) ; TestVerticleFactory fact2 = new TestVerticleFactory ( "aa" , "actual:someverticle" , 2 , true ) ; vertx . registerVerticleFactory ( fact2 ) ; TestVerticleFactory fact1 = new TestVerticleFactory ( "aa" , "actual:someverticle" , 1 , true ) ; vertx . registerVerticleFactory ( fact1 ) ; TestVerticleFactory fact3 = new TestVerticleFactory ( "aa" , "actual:someverticle" , 3 ) ; vertx . registerVerticleFactory ( fact3 ) ; vertx . deployVerticle ( "aa:blah" , res - > { assertTrue ( res . succeeded ( ) ) ; assertNull ( fact2 . identifier ) ; assertNull ( fact1 . identifier ) ; assertNull ( fact3 . identifier ) ; assertEquals ( "aa:blah" , fact3 . identifierToResolve ) ; assertNull ( fact1 . identifierToResolve ) ; assertNull ( fact2 . identifierToResolve ) ; assertEquals ( "actual:someverticle" , factActual . identifier ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testOrderingAllFailedInResolve ( ) { TestVerticle verticle = new TestVerticle ( ) ; TestVerticleFactory factActual = new TestVerticleFactory ( "actual" , verticle ) ; vertx . registerVerticleFactory ( factActual ) ; TestVerticleFactory fact2 = new TestVerticleFactory ( "aa" , "actual:someverticle" , 2 , true ) ; vertx . registerVerticleFactory ( fact2 ) ; TestVerticleFactory fact1 = new TestVerticleFactory ( "aa" , "actual:someverticle" , 1 , true ) ; vertx . registerVerticleFactory ( fact1 ) ; TestVerticleFactory fact3 = new TestVerticleFactory ( "aa" , "actual:someverticle" , 3 , true ) ; vertx . registerVerticleFactory ( fact3 ) ; vertx . deployVerticle ( "aa:blah" , res - > { assertTrue ( res . failed ( ) ) ; assertTrue ( res . cause ( ) instanceof IOException ) ; assertNull ( fact2 . identifier ) ; assertNull ( fact1 . identifier ) ; assertNull ( fact3 . identifier ) ; assertNull ( fact3 . identifierToResolve ) ; assertNull ( fact1 . identifierToResolve ) ; assertNull ( fact2 . identifierToResolve ) ; assertNull ( factActual . identifier ) ; testComplete ( ) ; } ) ; await ( ) ; } class TestVerticleFactory implements VerticleFactory { String prefix ; Verticle verticle ; String identifier ; String resolvedIdentifier ; String identifierToResolve ; DeploymentOptions deploymentOptionsToResolve ; int order ; boolean failInCreate ; boolean failInResolve ; TestVerticleFactory ( String prefix ) { this . prefix = prefix ; } TestVerticleFactory ( String prefix , Verticle verticle ) { this . prefix = prefix ; this . verticle = verticle ; } TestVerticleFactory ( String prefix , String resolvedIdentifier ) { this . prefix = prefix ; this . resolvedIdentifier = resolvedIdentifier ; } TestVerticleFactory ( String prefix , Verticle verticle , int order ) { this . prefix = prefix ; this . verticle = verticle ; this . order = order ; } TestVerticleFactory ( String prefix , Verticle verticle , int order , boolean failInCreate ) { this . prefix = prefix ; this . verticle = verticle ; this . order = order ; this . failInCreate = failInCreate ; } TestVerticleFactory ( String prefix , String resolvedIdentifier , int order ) { this . prefix = prefix ; this . resolvedIdentifier = resolvedIdentifier ; this . order = order ; } TestVerticleFactory ( String prefix , String resolvedIdentifier , int order , boolean failInResolve ) { this . prefix = prefix ; this . resolvedIdentifier = resolvedIdentifier ; this . order = order ; this . failInResolve = failInResolve ; } @ Override public int order ( ) { return order ; } @ Override public boolean requiresResolve ( ) { return resolvedIdentifier != null ; } @ Override public void resolve ( String identifier , DeploymentOptions deploymentOptions , ClassLoader classLoader , Future < String > resolution ) { if ( failInResolve ) { resolution . fail ( new IOException ( "whatever" ) ) ; } else { identifierToResolve = identifier ; deploymentOptionsToResolve = deploymentOptions ; deploymentOptions . setConfig ( new JsonObject ( ) . put ( "wibble" , "quux" ) ) ; deploymentOptions . setWorker ( true ) ; deploymentOptions . setIsolationGroup ( "othergroup" ) ; resolution . complete ( resolvedIdentifier ) ; } } @ Override public void init ( Vertx vertx ) { } @ Override public String prefix ( ) { return prefix ; } @ Override public Verticle createVerticle ( String verticleName , ClassLoader classLoader ) throws Exception { if ( failInCreate ) { throw new ClassNotFoundException ( "whatever" ) ; } this . identifier = verticleName ; return verticle ; } @ Override public void close ( ) { } } class TestVerticle extends AbstractVerticle { boolean startCalled ; @ Override public void start ( ) throws Exception { startCalled = true ; } @ Override public void stop ( ) throws Exception { } } }
package io . vertx . test . core ; import io . vertx . core . Vertx ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import io . vertx . core . spi . cluster . ClusterManager ; import io . vertx . test . fakecluster . FakeClusterManager ; import org . junit . Test ; import java . io . Serializable ; import static io . vertx . test . core . TestUtils . * ; public class ClusterWideMapTest extends VertxTestBase { protected int getNumNodes ( ) { return 1 ; } protected Vertx getVertx ( ) { return vertices [ 0 ] ; } public void setUp ( ) throws Exception { super . setUp ( ) ; startNodes ( getNumNodes ( ) ) ; } @ Override protected ClusterManager getClusterManager ( ) { return new FakeClusterManager ( ) ; } @ Test public void testMapPutGetByte ( ) { testMapPutGet ( ( byte ) 1 , ( byte ) 2 ) ; } @ Test public void testMapPutGetShort ( ) { testMapPutGet ( ( short ) 1 , ( short ) 2 ) ; } @ Test public void testMapPutGetInt ( ) { testMapPutGet ( 1 , 2 ) ; } @ Test public void testMapPutGetLong ( ) { testMapPutGet ( 1l , 2l ) ; } @ Test public void testMapPutGetChar ( ) { testMapPutGet ( 'X' , 'Y' ) ; } @ Test public void testMapPutGetFloat ( ) { testMapPutGet ( 1.2f , 2.2f ) ; } @ Test public void testMapPutGetDouble ( ) { testMapPutGet ( 1.2d , 2.2d ) ; } @ Test public void testMapPutGetBoolean ( ) { testMapPutGet ( "foo" , true ) ; } @ Test public void testMapPutGetString ( ) { testMapPutGet ( "foo" , "bar" ) ; } @ Test public void testMapPutGetJsonObject ( ) { testMapPutGet ( new JsonObject ( ) . put ( "foo" , "bar" ) , new JsonObject ( ) . put ( "uihwqduh" , "qiwiojw" ) ) ; } @ Test public void testMapPutGetJsonArray ( ) { testMapPutGet ( new JsonArray ( ) . add ( "foo" ) . add ( 2 ) , new JsonArray ( ) . add ( "uihwqduh" ) . add ( false ) ) ; } @ Test public void testMapPutGetSerializableObject ( ) { testMapPutGet ( new SomeSerializableObject ( "bar" ) , new SomeSerializableObject ( "bar" ) ) ; } @ Test public void testMapPutIfAbsentGetByte ( ) { testMapPutIfAbsentGet ( ( byte ) 1 , ( byte ) 2 ) ; } @ Test public void testMapPutIfAbsentGetShort ( ) { testMapPutIfAbsentGet ( ( short ) 1 , ( short ) 2 ) ; } @ Test public void testMapPutIfAbsentGetInt ( ) { testMapPutIfAbsentGet ( 1 , 2 ) ; } @ Test public void testMapPutIfAbsentGetLong ( ) { testMapPutIfAbsentGet ( 1l , 2l ) ; } @ Test public void testMapPutIfAbsentGetChar ( ) { testMapPutIfAbsentGet ( 'X' , 'Y' ) ; } @ Test public void testMapPutIfAbsentGetFloat ( ) { testMapPutIfAbsentGet ( 1.2f , 2.2f ) ; } @ Test public void testMapPutIfAbsentGetDouble ( ) { testMapPutIfAbsentGet ( 1.2d , 2.2d ) ; } @ Test public void testMapPutIfAbsentGetBoolean ( ) { testMapPutIfAbsentGet ( "foo" , true ) ; } @ Test public void testMapPutIfAbsentGetString ( ) { testMapPutIfAbsentGet ( "foo" , "bar" ) ; } @ Test public void testMapPutIfAbsentGetJsonObject ( ) { testMapPutIfAbsentGet ( new JsonObject ( ) . put ( "foo" , "bar" ) , new JsonObject ( ) . put ( "uihwqduh" , "qiwiojw" ) ) ; } @ Test public void testMapPutIfAbsentGetJsonArray ( ) { testMapPutIfAbsentGet ( new JsonArray ( ) . add ( "foo" ) . add ( 2 ) , new JsonArray ( ) . add ( "uihwqduh" ) . add ( false ) ) ; } @ Test public void testMapPutIfAbsentGetSerializableObject ( ) { testMapPutIfAbsentGet ( new SomeSerializableObject ( "bar" ) , new SomeSerializableObject ( "bar" ) ) ; } @ Test public void testMapRemoveByte ( ) { testMapRemove ( ( byte ) 1 , ( byte ) 2 ) ; } @ Test public void testMapRemoveShort ( ) { testMapRemove ( ( short ) 1 , ( short ) 2 ) ; } @ Test public void testMapRemoveInt ( ) { testMapRemove ( 1 , 2 ) ; } @ Test public void testMapRemoveLong ( ) { testMapRemove ( 1l , 2l ) ; } @ Test public void testMapRemoveChar ( ) { testMapRemove ( 'X' , 'Y' ) ; } @ Test public void testMapRemoveFloat ( ) { testMapRemove ( 1.2f , 2.2f ) ; } @ Test public void testMapRemoveDouble ( ) { testMapRemove ( 1.2d , 2.2d ) ; } @ Test public void testMapRemoveBoolean ( ) { testMapRemove ( "foo" , true ) ; } @ Test public void testMapRemoveString ( ) { testMapRemove ( "foo" , "bar" ) ; } @ Test public void testMapRemoveJsonObject ( ) { testMapRemove ( new JsonObject ( ) . put ( "foo" , "bar" ) , new JsonObject ( ) . put ( "uihwqduh" , "qiwiojw" ) ) ; } @ Test public void testMapRemoveJsonArray ( ) { testMapRemove ( new JsonArray ( ) . add ( "foo" ) . add ( 2 ) , new JsonArray ( ) . add ( "uihwqduh" ) . add ( false ) ) ; } @ Test public void testMapRemoveSerializableObject ( ) { testMapRemove ( new SomeSerializableObject ( "bar" ) , new SomeSerializableObject ( "bar" ) ) ; } @ Test public void testMapRemoveIfPresentByte ( ) { testMapRemoveIfPresent ( ( byte ) 1 , ( byte ) 2 , ( byte ) 3 ) ; } @ Test public void testMapRemoveIfPresentShort ( ) { testMapRemoveIfPresent ( ( short ) 1 , ( short ) 2 , ( short ) 3 ) ; } @ Test public void testMapRemoveIfPresentInt ( ) { testMapRemoveIfPresent ( 1 , 2 , 3 ) ; } @ Test public void testMapRemoveIfPresentLong ( ) { testMapRemoveIfPresent ( 1l , 2l , 3l ) ; } @ Test public void testMapRemoveIfPresentChar ( ) { testMapRemoveIfPresent ( 'X' , 'Y' , 'Z' ) ; } @ Test public void testMapRemoveIfPresentFloat ( ) { testMapRemoveIfPresent ( 1.2f , 2.2f , 3.3f ) ; } @ Test public void testMapRemoveIfPresentDouble ( ) { testMapRemoveIfPresent ( 1.2d , 2.2d , 3.3d ) ; } @ Test public void testMapRemoveIfPresentBoolean ( ) { testMapRemoveIfPresent ( "foo" , true , false ) ; } @ Test public void testMapRemoveIfPresentString ( ) { testMapRemoveIfPresent ( "foo" , "bar" , "quux" ) ; } @ Test public void testMapRemoveIfPresentJsonObject ( ) { testMapRemoveIfPresent ( new JsonObject ( ) . put ( "foo" , "bar" ) , new JsonObject ( ) . put ( "uihwqduh" , "qiwiojw" ) , new JsonObject ( ) . put ( "regerg" , "wfwef" ) ) ; } @ Test public void testMapRemoveIfPresentJsonArray ( ) { testMapRemoveIfPresent ( new JsonArray ( ) . add ( "foo" ) . add ( 2 ) , new JsonArray ( ) . add ( "uihwqduh" ) . add ( false ) , new JsonArray ( ) . add ( "qqddq" ) . add ( true ) ) ; } @ Test public void testMapRemoveIfPresentSerializableObject ( ) { testMapRemoveIfPresent ( new SomeSerializableObject ( "foo" ) , new SomeSerializableObject ( "bar" ) , new SomeSerializableObject ( "quux" ) ) ; } @ Test public void testMapReplaceByte ( ) { testMapReplace ( ( byte ) 1 , ( byte ) 2 , ( byte ) 3 ) ; } @ Test public void testMapReplaceShort ( ) { testMapReplace ( ( short ) 1 , ( short ) 2 , ( short ) 3 ) ; } @ Test public void testMapReplaceInt ( ) { testMapReplace ( 1 , 2 , 3 ) ; } @ Test public void testMapReplaceLong ( ) { testMapReplace ( 1l , 2l , 3l ) ; } @ Test public void testMapReplaceChar ( ) { testMapReplace ( 'X' , 'Y' , 'Z' ) ; } @ Test public void testMapReplaceFloat ( ) { testMapReplace ( 1.2f , 2.2f , 3.3f ) ; } @ Test public void testMapReplaceDouble ( ) { testMapReplace ( 1.2d , 2.2d , 3.3d ) ; } @ Test public void testMapReplaceBoolean ( ) { testMapReplace ( "foo" , true , false ) ; } @ Test public void testMapReplaceString ( ) { testMapReplace ( "foo" , "bar" , "quux" ) ; } @ Test public void testMapReplaceJsonObject ( ) { testMapReplace ( new JsonObject ( ) . put ( "foo" , "bar" ) , new JsonObject ( ) . put ( "uihwqduh" , "qiwiojw" ) , new JsonObject ( ) . put ( "regerg" , "wfwef" ) ) ; } @ Test public void testMapReplaceJsonArray ( ) { testMapReplace ( new JsonArray ( ) . add ( "foo" ) . add ( 2 ) , new JsonArray ( ) . add ( "uihwqduh" ) . add ( false ) , new JsonArray ( ) . add ( "qqddq" ) . add ( true ) ) ; } @ Test public void testMapReplaceSerializableObject ( ) { testMapReplace ( new SomeSerializableObject ( "foo" ) , new SomeSerializableObject ( "bar" ) , new SomeSerializableObject ( "quux" ) ) ; } @ Test public void testMapReplaceIfPresentByte ( ) { testMapReplaceIfPresent ( ( byte ) 1 , ( byte ) 2 , ( byte ) 3 ) ; } @ Test public void testMapReplaceIfPresentShort ( ) { testMapReplaceIfPresent ( ( short ) 1 , ( short ) 2 , ( short ) 3 ) ; } @ Test public void testMapReplaceIfPresentInt ( ) { testMapReplaceIfPresent ( 1 , 2 , 3 ) ; } @ Test public void testMapReplaceIfPresentLong ( ) { testMapReplaceIfPresent ( 1l , 2l , 3l ) ; } @ Test public void testMapReplaceIfPresentChar ( ) { testMapReplaceIfPresent ( 'X' , 'Y' , 'Z' ) ; } @ Test public void testMapReplaceIfPresentFloat ( ) { testMapReplaceIfPresent ( 1.2f , 2.2f , 3.3f ) ; } @ Test public void testMapReplaceIfPresentDouble ( ) { testMapReplaceIfPresent ( 1.2d , 2.2d , 3.3d ) ; } @ Test public void testMapReplaceIfPresentBoolean ( ) { testMapReplaceIfPresent ( "foo" , true , false ) ; } @ Test public void testMapReplaceIfPresentString ( ) { testMapReplaceIfPresent ( "foo" , "bar" , "quux" ) ; } @ Test public void testMapReplaceIfPresentJsonObject ( ) { testMapReplaceIfPresent ( new JsonObject ( ) . put ( "foo" , "bar" ) , new JsonObject ( ) . put ( "uihwqduh" , "qiwiojw" ) , new JsonObject ( ) . put ( "regerg" , "wfwef" ) ) ; } @ Test public void testMapReplaceIfPresentJsonArray ( ) { testMapReplaceIfPresent ( new JsonArray ( ) . add ( "foo" ) . add ( 2 ) , new JsonArray ( ) . add ( "uihwqduh" ) . add ( false ) , new JsonArray ( ) . add ( "qqddq" ) . add ( true ) ) ; } @ Test public void testMapReplaceIfPresentSerializableObject ( ) { testMapReplaceIfPresent ( new SomeSerializableObject ( "foo" ) , new SomeSerializableObject ( "bar" ) , new SomeSerializableObject ( "quux" ) ) ; } @ Test public void testGetMapWithNullName ( ) throws Exception { assertNullPointerException ( ( ) - > getVertx ( ) . sharedData ( ) . < String , String > getClusterWideMap ( null , ar - > { } ) ) ; } @ Test public void testGetMapWithNullResultHandler ( ) throws Exception { assertNullPointerException ( ( ) - > getVertx ( ) . sharedData ( ) . < String , String > getClusterWideMap ( "foo" , null ) ) ; } @ Test public void testPutNullKey ( ) { getVertx ( ) . sharedData ( ) . < String , String > getClusterWideMap ( "foo" , onSuccess ( map - > { assertIllegalArgumentException ( ( ) - > map . put ( null , "foo" , ar2 - > { } ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testPutNullValue ( ) { getVertx ( ) . sharedData ( ) . < String , String > getClusterWideMap ( "foo" , onSuccess ( map - > { assertIllegalArgumentException ( ( ) - > map . put ( "foo" , null , ar2 - > { } ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testPutInvalidKey ( ) { getVertx ( ) . sharedData ( ) . < SomeObject , String > getClusterWideMap ( "foo" , onSuccess ( map - > { assertIllegalArgumentException ( ( ) - > map . put ( new SomeObject ( ) , "foo" , ar2 - > { } ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testPutInvalidValue ( ) { getVertx ( ) . sharedData ( ) . < String , SomeObject > getClusterWideMap ( "foo" , onSuccess ( map - > { assertIllegalArgumentException ( ( ) - > map . put ( "foo" , new SomeObject ( ) , ar2 - > { } ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testPutIfAbsentInvalidKey ( ) { getVertx ( ) . sharedData ( ) . < SomeObject , String > getClusterWideMap ( "foo" , onSuccess ( map - > { assertIllegalArgumentException ( ( ) - > map . putIfAbsent ( new SomeObject ( ) , "foo" , ar2 - > { } ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testPutIfAbsentInvalidValue ( ) { getVertx ( ) . sharedData ( ) . < String , SomeObject > getClusterWideMap ( "foo" , onSuccess ( map - > { assertIllegalArgumentException ( ( ) - > map . putIfAbsent ( "foo" , new SomeObject ( ) , ar2 - > { } ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testMultipleMaps ( ) { getVertx ( ) . sharedData ( ) . < String , String > getClusterWideMap ( "foo" , onSuccess ( map - > { map . put ( "foo" , "bar" , onSuccess ( v - > { getVertx ( ) . sharedData ( ) . < String , String > getClusterWideMap ( "bar" , onSuccess ( map2 - > { map2 . get ( "foo" , onSuccess ( res - > { assertNull ( res ) ; testComplete ( ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; await ( ) ; } @ Test public void testClear ( ) { getVertx ( ) . sharedData ( ) . < String , String > getClusterWideMap ( "foo" , onSuccess ( map - > { map . put ( "foo" , "bar" , onSuccess ( v - > { getVertx ( ) . sharedData ( ) . < String , String > getClusterWideMap ( "foo" , onSuccess ( map2 - > { map2 . clear ( onSuccess ( v2 - > { map . get ( "foo" , onSuccess ( res - > { assertNull ( res ) ; testComplete ( ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; await ( ) ; } @ Test public void testSize ( ) { getVertx ( ) . sharedData ( ) . < String , String > getClusterWideMap ( "foo" , onSuccess ( map - > { map . size ( onSuccess ( size - > { assertEquals ( 0 , size . intValue ( ) ) ; map . put ( "foo" , "bar" , onSuccess ( v - > { map . size ( onSuccess ( size2 - > { assertEquals ( 1 , size2 . intValue ( ) ) ; getVertx ( ) . sharedData ( ) . < String , String > getClusterWideMap ( "foo" , onSuccess ( map2 - > { map2 . size ( onSuccess ( size3 - > { assertEquals ( 1 , size3 . intValue ( ) ) ; testComplete ( ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; await ( ) ; } private < K , V > void testMapPutGet ( K k , V v ) { getVertx ( ) . sharedData ( ) . < K , V > getClusterWideMap ( "foo" , onSuccess ( map - > { map . put ( k , v , onSuccess ( vd - > { getVertx ( ) . sharedData ( ) . < K , V > getClusterWideMap ( "foo" , onSuccess ( map2 - > { map2 . get ( k , onSuccess ( res - > { assertEquals ( v , res ) ; testComplete ( ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; await ( ) ; } private < K , V > void testMapPutIfAbsentGet ( K k , V v ) { getVertx ( ) . sharedData ( ) . < K , V > getClusterWideMap ( "foo" , onSuccess ( map - > { map . putIfAbsent ( k , v , onSuccess ( res - > { assertNull ( res ) ; getVertx ( ) . sharedData ( ) . < K , V > getClusterWideMap ( "foo" , onSuccess ( map2 - > { map2 . get ( k , onSuccess ( res2 - > { assertEquals ( v , res2 ) ; map . putIfAbsent ( k , v , onSuccess ( res3 - > { assertEquals ( v , res3 ) ; testComplete ( ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; await ( ) ; } private < K , V > void testMapRemove ( K k , V v ) { getVertx ( ) . sharedData ( ) . < K , V > getClusterWideMap ( "foo" , onSuccess ( map - > { map . put ( k , v , onSuccess ( res - > { assertNull ( res ) ; getVertx ( ) . sharedData ( ) . < K , V > getClusterWideMap ( "foo" , onSuccess ( map2 - > { map2 . remove ( k , onSuccess ( res2 - > { assertEquals ( v , res2 ) ; testComplete ( ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; await ( ) ; } private < K , V > void testMapRemoveIfPresent ( K k , V v , V other ) { getVertx ( ) . sharedData ( ) . < K , V > getClusterWideMap ( "foo" , onSuccess ( map - > { map . put ( k , v , onSuccess ( res - > { assertNull ( res ) ; getVertx ( ) . sharedData ( ) . < K , V > getClusterWideMap ( "foo" , onSuccess ( map2 - > { map2 . removeIfPresent ( k , other , onSuccess ( res2 - > { assertFalse ( res2 ) ; map2 . removeIfPresent ( k , v , onSuccess ( res3 - > { assertTrue ( res3 ) ; testComplete ( ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; await ( ) ; } private < K , V > void testMapReplace ( K k , V v , V other ) { getVertx ( ) . sharedData ( ) . < K , V > getClusterWideMap ( "foo" , onSuccess ( map - > { map . put ( k , v , onSuccess ( res - > { assertNull ( res ) ; getVertx ( ) . sharedData ( ) . < K , V > getClusterWideMap ( "foo" , onSuccess ( map2 - > { map2 . replace ( k , other , onSuccess ( res2 - > { assertEquals ( v , res2 ) ; map2 . get ( k , onSuccess ( res3 - > { assertEquals ( other , res3 ) ; map2 . remove ( k , onSuccess ( res4 - > { map2 . replace ( k , other , onSuccess ( res5 - > { assertNull ( res5 ) ; map2 . get ( k , onSuccess ( res6 - > { assertNull ( res6 ) ; testComplete ( ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; await ( ) ; } private < K , V > void testMapReplaceIfPresent ( K k , V v , V other ) { getVertx ( ) . sharedData ( ) . < K , V > getClusterWideMap ( "foo" , onSuccess ( map - > { map . put ( k , v , onSuccess ( res - > { assertNull ( res ) ; getVertx ( ) . sharedData ( ) . < K , V > getClusterWideMap ( "foo" , onSuccess ( map2 - > { map2 . replaceIfPresent ( k , v , other , onSuccess ( res2 - > { map2 . replaceIfPresent ( k , v , other , onSuccess ( res3 - > { assertFalse ( res3 ) ; map2 . get ( k , onSuccess ( res4 - > { assertEquals ( other , res4 ) ; testComplete ( ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; } ) ) ; await ( ) ; } public static final class SomeObject { } public static final class SomeSerializableObject implements Serializable { private String str ; public SomeSerializableObject ( String str ) { this . str = str ; } public SomeSerializableObject ( ) { } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof SomeSerializableObject ) ) return false ; SomeSerializableObject that = ( SomeSerializableObject ) o ; if ( str != null ? ! str . equals ( that . str ) : that . str != null ) return false ; return true ; } @ Override public int hashCode ( ) { return str != null ? str . hashCode ( ) : 0 ; } } }
package io . vertx . test . core ; import io . vertx . core . Vertx ; import io . vertx . core . VertxOptions ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . MessageConsumer ; import io . vertx . core . http . HttpClient ; import io . vertx . core . http . HttpClientRequest ; import io . vertx . core . http . HttpMethod ; import io . vertx . core . http . HttpServer ; import io . vertx . core . http . ServerWebSocket ; import io . vertx . core . metrics . MetricsOptions ; import io . vertx . core . net . NetSocket ; import io . vertx . test . fakemetrics . * ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . Test ; import java . util . Arrays ; import java . util . Optional ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; public class MetricsTest extends VertxTestBase { private static final String ADDRESS1 = "some-address1" ; @ BeforeClass public static void setFactory ( ) { ConfigurableMetricsFactory . delegate = new FakeMetricsFactory ( ) ; } @ AfterClass public static void unsetFactory ( ) { ConfigurableMetricsFactory . delegate = null ; } @ Override protected VertxOptions getOptions ( ) { VertxOptions options = super . getOptions ( ) ; options . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( true ) ) ; return options ; } @ Test public void testSendMessage ( ) { testBroadcastMessage ( vertx , new Vertx [ ] { vertx } , false , true , false ) ; } @ Test public void testSendMessageInCluster ( ) { startNodes ( 2 ) ; testBroadcastMessage ( vertices [ 0 ] , new Vertx [ ] { vertices [ 1 ] } , false , false , true ) ; } @ Test public void testPublishMessageToSelf ( ) { testBroadcastMessage ( vertx , new Vertx [ ] { vertx } , true , true , false ) ; } @ Test public void testPublishMessageToRemote ( ) { startNodes ( 2 ) ; testBroadcastMessage ( vertices [ 0 ] , new Vertx [ ] { vertices [ 1 ] } , true , false , true ) ; } @ Test public void testPublishMessageToCluster ( ) { startNodes ( 2 ) ; testBroadcastMessage ( vertices [ 0 ] , vertices , true , true , true ) ; } private void testBroadcastMessage ( Vertx from , Vertx [ ] to , boolean publish , boolean expectedLocal , boolean expectedRemote ) { FakeEventBusMetrics eventBusMetrics = FakeMetricsBase . getMetrics ( from . eventBus ( ) ) ; AtomicInteger broadcastCount = new AtomicInteger ( ) ; AtomicInteger receiveCount = new AtomicInteger ( ) ; for ( Vertx vertx : to ) { MessageConsumer < Object > consumer = vertx . eventBus ( ) . consumer ( ADDRESS1 ) ; consumer . completionHandler ( done - > { assertTrue ( done . succeeded ( ) ) ; if ( broadcastCount . incrementAndGet ( ) == to . length ) { String msg = TestUtils . randomAlphaString ( 10 ) ; if ( publish ) { from . eventBus ( ) . publish ( ADDRESS1 , msg ) ; } else { from . eventBus ( ) . send ( ADDRESS1 , msg ) ; } } } ) ; consumer . handler ( msg - > { if ( receiveCount . incrementAndGet ( ) == to . length ) { assertEquals ( Arrays . asList ( new SentMessage ( ADDRESS1 , publish , expectedLocal , expectedRemote ) ) , eventBusMetrics . getSentMessages ( ) ) ; testComplete ( ) ; } } ) ; } await ( ) ; } @ Test public void testReceiveSentMessageFromSelf ( ) { testReceiveMessageSent ( vertx , vertx , true , 1 ) ; } @ Test public void testReceiveMessageSentFromRemote ( ) { startNodes ( 2 ) ; testReceiveMessageSent ( vertices [ 0 ] , vertices [ 1 ] , false , 1 ) ; } private void testReceiveMessageSent ( Vertx from , Vertx to , boolean expectedLocal , int expectedHandlers ) { FakeEventBusMetrics eventBusMetrics = FakeMetricsBase . getMetrics ( to . eventBus ( ) ) ; MessageConsumer < Object > consumer = to . eventBus ( ) . consumer ( ADDRESS1 ) ; consumer . completionHandler ( done - > { assertTrue ( done . succeeded ( ) ) ; String msg = TestUtils . randomAlphaString ( 10 ) ; from . eventBus ( ) . send ( ADDRESS1 , msg ) ; } ) ; consumer . handler ( msg - > { assertEquals ( Arrays . asList ( new ReceivedMessage ( ADDRESS1 , false , expectedLocal , expectedHandlers ) ) , eventBusMetrics . getReceivedMessages ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testReceivePublishedMessageFromSelf ( ) { testReceiveMessagePublished ( vertx , vertx , true , 3 ) ; } @ Test public void testReceiveMessagePublishedFromRemote ( ) { startNodes ( 2 ) ; testReceiveMessagePublished ( vertices [ 0 ] , vertices [ 1 ] , false , 3 ) ; } private void testReceiveMessagePublished ( Vertx from , Vertx to , boolean expectedLocal , int expectedHandlers ) { FakeEventBusMetrics eventBusMetrics = FakeMetricsBase . getMetrics ( to . eventBus ( ) ) ; AtomicInteger count = new AtomicInteger ( ) ; for ( int i = 0 ; i < expectedHandlers ; i ++ ) { MessageConsumer < Object > consumer = to . eventBus ( ) . consumer ( ADDRESS1 ) ; consumer . completionHandler ( done - > { assertTrue ( done . succeeded ( ) ) ; if ( count . incrementAndGet ( ) == expectedHandlers ) { String msg = TestUtils . randomAlphaString ( 10 ) ; from . eventBus ( ) . publish ( ADDRESS1 , msg ) ; } } ) ; int index = i ; consumer . handler ( msg - > { if ( index == 0 ) { assertEquals ( Arrays . asList ( new ReceivedMessage ( ADDRESS1 , true , expectedLocal , expectedHandlers ) ) , eventBusMetrics . getReceivedMessages ( ) ) ; testComplete ( ) ; } } ) ; } await ( ) ; } @ Test public void testReplyMessageFromSelf ( ) { testReply ( vertx , vertx , true , false ) ; } @ Test public void testReplyMessageFromRemote ( ) { startNodes ( 2 ) ; testReply ( vertices [ 0 ] , vertices [ 1 ] , false , true ) ; } private void testReply ( Vertx from , Vertx to , boolean expectedLocal , boolean expectedRemote ) { FakeEventBusMetrics fromMetrics = FakeMetricsBase . getMetrics ( from . eventBus ( ) ) ; FakeEventBusMetrics toMetrics = FakeMetricsBase . getMetrics ( to . eventBus ( ) ) ; MessageConsumer < Object > consumer = to . eventBus ( ) . consumer ( ADDRESS1 ) ; consumer . completionHandler ( done - > { assertTrue ( done . succeeded ( ) ) ; String msg = TestUtils . randomAlphaString ( 10 ) ; from . eventBus ( ) . send ( ADDRESS1 , msg , reply - > { assertEquals ( 1 , fromMetrics . getReceivedMessages ( ) . size ( ) ) ; ReceivedMessage receivedMessage = fromMetrics . getReceivedMessages ( ) . get ( 0 ) ; assertEquals ( false , receivedMessage . publish ) ; assertEquals ( expectedLocal , receivedMessage . local ) ; assertEquals ( 1 , receivedMessage . handlers ) ; assertEquals ( 1 , toMetrics . getSentMessages ( ) . size ( ) ) ; SentMessage sentMessage = toMetrics . getSentMessages ( ) . get ( 0 ) ; assertEquals ( false , sentMessage . publish ) ; assertEquals ( expectedLocal , sentMessage . local ) ; assertEquals ( expectedRemote , sentMessage . remote ) ; assertEquals ( sentMessage . address , receivedMessage . address ) ; testComplete ( ) ; } ) ; } ) ; consumer . handler ( msg - > { toMetrics . getReceivedMessages ( ) . clear ( ) ; toMetrics . getSentMessages ( ) . clear ( ) ; msg . reply ( TestUtils . randomAlphaString ( 10 ) ) ; } ) ; await ( ) ; } @ Test public void testHandlerRegistration ( ) throws Exception { FakeEventBusMetrics metrics = FakeMetricsBase . getMetrics ( vertx . eventBus ( ) ) ; MessageConsumer < Object > consumer = vertx . eventBus ( ) . consumer ( ADDRESS1 , msg - > { } ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; consumer . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; assertEquals ( 1 , metrics . getRegistrations ( ) . size ( ) ) ; HandlerMetric registration = metrics . getRegistrations ( ) . get ( 0 ) ; assertEquals ( ADDRESS1 , registration . address ) ; assertEquals ( false , registration . replyHandler ) ; consumer . unregister ( ar - > { assertTrue ( ar . succeeded ( ) ) ; assertEquals ( 0 , metrics . getRegistrations ( ) . size ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testHandlerProcessMessage ( ) { testHandlerProcessMessage ( vertx , vertx , 1 ) ; } @ Test public void testHandlerProcessMessageFromRemote ( ) { startNodes ( 2 ) ; testHandlerProcessMessage ( vertices [ 0 ] , vertices [ 1 ] , 0 ) ; } private HandlerMetric assertRegistration ( FakeEventBusMetrics metrics ) { Optional < HandlerMetric > registration = metrics . getRegistrations ( ) . stream ( ) . filter ( reg - > reg . address . equals ( ADDRESS1 ) ) . findFirst ( ) ; assertTrue ( registration . isPresent ( ) ) ; return registration . get ( ) ; } private void testHandlerProcessMessage ( Vertx from , Vertx to , int expectedLocalCoult ) { FakeEventBusMetrics metrics = FakeMetricsBase . getMetrics ( to . eventBus ( ) ) ; to . eventBus ( ) . consumer ( ADDRESS1 , msg - > { HandlerMetric registration = assertRegistration ( metrics ) ; assertEquals ( ADDRESS1 , registration . address ) ; assertEquals ( false , registration . replyHandler ) ; assertEquals ( 1 , registration . beginCount . get ( ) ) ; assertEquals ( 0 , registration . endCount . get ( ) ) ; assertEquals ( 0 , registration . failureCount . get ( ) ) ; assertEquals ( expectedLocalCoult , registration . localCount . get ( ) ) ; msg . reply ( "pong" ) ; } ) . completionHandler ( onSuccess ( v - > { from . eventBus ( ) . send ( ADDRESS1 , "ping" , reply - > { HandlerMetric registration = assertRegistration ( metrics ) ; assertEquals ( ADDRESS1 , registration . address ) ; assertEquals ( false , registration . replyHandler ) ; assertEquals ( 1 , registration . beginCount . get ( ) ) ; waitUntil ( ( ) - > 1 == registration . endCount . get ( ) ) ; assertEquals ( 0 , registration . failureCount . get ( ) ) ; assertEquals ( expectedLocalCoult , registration . localCount . get ( ) ) ; testComplete ( ) ; } ) ; } ) ) ; await ( ) ; } @ Test public void testHandlerProcessMessageFailure ( ) throws Exception { FakeEventBusMetrics metrics = FakeMetricsBase . getMetrics ( vertx . eventBus ( ) ) ; MessageConsumer < Object > consumer = vertx . eventBus ( ) . consumer ( ADDRESS1 , msg - > { assertEquals ( 1 , metrics . getReceivedMessages ( ) . size ( ) ) ; HandlerMetric registration = metrics . getRegistrations ( ) . get ( 0 ) ; assertEquals ( 1 , registration . beginCount . get ( ) ) ; assertEquals ( 0 , registration . endCount . get ( ) ) ; assertEquals ( 0 , registration . failureCount . get ( ) ) ; throw new RuntimeException ( ) ; } ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; consumer . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; vertx . eventBus ( ) . send ( ADDRESS1 , "ping" ) ; assertEquals ( 1 , metrics . getReceivedMessages ( ) . size ( ) ) ; HandlerMetric registration = metrics . getRegistrations ( ) . get ( 0 ) ; long now = System . currentTimeMillis ( ) ; while ( registration . failureCount . get ( ) < 1 && ( System . currentTimeMillis ( ) - now ) < 10 * 1000 ) { Thread . sleep ( 10 ) ; } assertEquals ( 1 , registration . beginCount . get ( ) ) ; assertEquals ( 1 , registration . endCount . get ( ) ) ; assertEquals ( 1 , registration . failureCount . get ( ) ) ; } @ Test public void testHandlerMetricReply ( ) throws Exception { CountDownLatch latch = new CountDownLatch ( 1 ) ; FakeEventBusMetrics metrics = FakeMetricsBase . getMetrics ( vertx . eventBus ( ) ) ; vertx . eventBus ( ) . consumer ( ADDRESS1 , msg - > { assertEquals ( ADDRESS1 , metrics . getRegistrations ( ) . get ( 0 ) . address ) ; waitUntil ( ( ) - > metrics . getRegistrations ( ) . size ( ) == 2 ) ; HandlerMetric registration = metrics . getRegistrations ( ) . get ( 1 ) ; assertTrue ( registration . replyHandler ) ; assertEquals ( 0 , registration . beginCount . get ( ) ) ; assertEquals ( 0 , registration . endCount . get ( ) ) ; assertEquals ( 0 , registration . localCount . get ( ) ) ; msg . reply ( "pong" ) ; } ) . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; vertx . eventBus ( ) . send ( ADDRESS1 , "ping" , reply - > { assertEquals ( ADDRESS1 , metrics . getRegistrations ( ) . get ( 0 ) . address ) ; HandlerMetric registration = metrics . getRegistrations ( ) . get ( 1 ) ; assertTrue ( registration . replyHandler ) ; assertEquals ( 1 , registration . beginCount . get ( ) ) ; assertEquals ( 0 , registration . endCount . get ( ) ) ; assertEquals ( 1 , registration . localCount . get ( ) ) ; vertx . runOnContext ( v - > { assertEquals ( ADDRESS1 , metrics . getRegistrations ( ) . get ( 0 ) . address ) ; assertTrue ( registration . replyHandler ) ; assertEquals ( 1 , registration . beginCount . get ( ) ) ; assertEquals ( 1 , registration . endCount . get ( ) ) ; assertEquals ( 1 , registration . localCount . get ( ) ) ; } ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testBytesCodec ( ) throws Exception { startNodes ( 2 ) ; FakeEventBusMetrics fromMetrics = FakeMetricsBase . getMetrics ( vertices [ 0 ] . eventBus ( ) ) ; FakeEventBusMetrics toMetrics = FakeMetricsBase . getMetrics ( vertices [ 1 ] . eventBus ( ) ) ; vertices [ 1 ] . eventBus ( ) . consumer ( ADDRESS1 , msg - > { int encoded = fromMetrics . getEncodedBytes ( ADDRESS1 ) ; int decoded = toMetrics . getDecodedBytes ( ADDRESS1 ) ; assertTrue ( "Expected to have more " + encoded + " > 1000 encoded bytes" , encoded > 1000 ) ; assertTrue ( "Expected to have more " + decoded + " > 1000 decoded bytes" , decoded > 1000 ) ; testComplete ( ) ; } ) . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; assertEquals ( 0 , fromMetrics . getEncodedBytes ( ADDRESS1 ) ) ; assertEquals ( 0 , toMetrics . getDecodedBytes ( ADDRESS1 ) ) ; vertices [ 0 ] . eventBus ( ) . send ( ADDRESS1 , Buffer . buffer ( new byte [ 1000 ] ) ) ; } ) ; await ( ) ; } @ Test public void testServerWebSocket ( ) throws Exception { HttpServer server = vertx . createHttpServer ( ) ; server . websocketHandler ( ws - > { FakeHttpServerMetrics metrics = FakeMetricsBase . getMetrics ( server ) ; WebSocketMetric metric = metrics . getMetric ( ws ) ; assertNotNull ( metric ) ; assertNotNull ( metric . soMetric ) ; ws . handler ( buffer - > { ws . close ( ) ; } ) ; ws . closeHandler ( closed - > { assertNull ( metrics . getMetric ( ws ) ) ; testComplete ( ) ; } ) ; } ) ; server . listen ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , ar - > { assertTrue ( ar . succeeded ( ) ) ; HttpClient client = vertx . createHttpClient ( ) ; client . websocket ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , "/" , ws - > { ws . write ( Buffer . buffer ( "wibble" ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testServerWebSocketUpgrade ( ) throws Exception { HttpServer server = vertx . createHttpServer ( ) ; server . requestHandler ( req - > { FakeHttpServerMetrics metrics = FakeMetricsBase . getMetrics ( server ) ; assertNotNull ( metrics . getMetric ( req ) ) ; ServerWebSocket ws = req . upgrade ( ) ; assertNull ( metrics . getMetric ( req ) ) ; WebSocketMetric metric = metrics . getMetric ( ws ) ; assertNotNull ( metric ) ; assertNotNull ( metric . soMetric ) ; ws . handler ( buffer - > { ws . close ( ) ; } ) ; ws . closeHandler ( closed - > { assertNull ( metrics . getMetric ( ws ) ) ; testComplete ( ) ; } ) ; } ) ; server . listen ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , ar - > { assertTrue ( ar . succeeded ( ) ) ; HttpClient client = vertx . createHttpClient ( ) ; client . websocket ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , "/" , ws - > { ws . write ( Buffer . buffer ( "wibble" ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testWebSocket ( ) throws Exception { HttpServer server = vertx . createHttpServer ( ) ; server . websocketHandler ( ws - > { ws . write ( Buffer . buffer ( "wibble" ) ) ; } ) ; server . listen ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , ar - > { assertTrue ( ar . succeeded ( ) ) ; HttpClient client = vertx . createHttpClient ( ) ; client . websocket ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , "/" , ws - > { FakeHttpClientMetrics metrics = FakeMetricsBase . getMetrics ( client ) ; WebSocketMetric metric = metrics . getMetric ( ws ) ; assertNotNull ( metric ) ; assertNotNull ( metric . soMetric ) ; ws . closeHandler ( closed - > { assertNull ( metrics . getMetric ( ws ) ) ; testComplete ( ) ; } ) ; ws . handler ( buffer - > { ws . close ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testMulti ( ) { HttpServer s1 = vertx . createHttpServer ( ) ; s1 . requestHandler ( req - > { } ) ; s1 . listen ( 8080 , ar1 - > { assertTrue ( ar1 . succeeded ( ) ) ; HttpServer s2 = vertx . createHttpServer ( ) ; s2 . requestHandler ( req - > { req . response ( ) . end ( ) ; } ) ; s2 . listen ( 8080 , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; FakeHttpServerMetrics metrics1 = FakeMetricsBase . getMetrics ( ar1 . result ( ) ) ; assertSame ( ar1 . result ( ) , metrics1 . server ) ; FakeHttpServerMetrics metrics2 = FakeMetricsBase . getMetrics ( ar2 . result ( ) ) ; assertSame ( ar2 . result ( ) , metrics2 . server ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testHttpConnect ( ) { AtomicReference < HttpClientMetric > clientMetric = new AtomicReference < > ( ) ; HttpServer server = vertx . createHttpServer ( ) ; server . requestHandler ( req - > { FakeHttpServerMetrics metrics = FakeMetricsBase . getMetrics ( server ) ; HttpServerMetric serverMetric = metrics . getMetric ( req ) ; assertNotNull ( serverMetric ) ; req . response ( ) . setStatusCode ( 200 ) ; req . response ( ) . setStatusMessage ( "Connection established" ) ; req . response ( ) . end ( ) ; NetSocket so = req . netSocket ( ) ; so . handler ( req . netSocket ( ) : : write ) ; so . closeHandler ( v - > { assertNull ( metrics . getMetric ( req ) ) ; assertFalse ( serverMetric . socket . connected . get ( ) ) ; assertEquals ( 5 , serverMetric . socket . bytesRead . get ( ) ) ; assertEquals ( 5 , serverMetric . socket . bytesWritten . get ( ) ) ; assertFalse ( clientMetric . get ( ) . socket . connected . get ( ) ) ; assertEquals ( 5 , clientMetric . get ( ) . socket . bytesRead . get ( ) ) ; assertEquals ( 5 , clientMetric . get ( ) . socket . bytesWritten . get ( ) ) ; testComplete ( ) ; } ) ; } ) . listen ( 8080 , ar1 - > { assertTrue ( ar1 . succeeded ( ) ) ; HttpClient client = vertx . createHttpClient ( ) ; HttpClientRequest request = client . request ( HttpMethod . CONNECT , 8080 , "localhost" , "/" ) ; FakeHttpClientMetrics metrics = FakeMetricsBase . getMetrics ( client ) ; request . handler ( resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; clientMetric . set ( metrics . getMetric ( request ) ) ; assertNotNull ( clientMetric . get ( ) ) ; NetSocket socket = resp . netSocket ( ) ; socket . write ( Buffer . buffer ( "hello" ) ) ; socket . handler ( buf - > { assertEquals ( "hello" , buf . toString ( ) ) ; assertNull ( metrics . getMetric ( request ) ) ; socket . close ( ) ; } ) ; } ) . end ( ) ; } ) ; await ( ) ; } }
package io . vertx . test . core ; import io . vertx . core . Verticle ; import io . vertx . core . Vertx ; import io . vertx . core . spi . VerticleFactory ; public class ClasspathVerticleFactory implements VerticleFactory { @ Override public void init ( Vertx vertx ) { } @ Override public String prefix ( ) { return "wibble" ; } @ Override public Verticle createVerticle ( String verticleName , ClassLoader classLoader ) throws Exception { return null ; } @ Override public void close ( ) { } }
package io . vertx . test . core ; import io . vertx . core . Future ; import org . junit . Test ; import java . util . ArrayList ; import java . util . concurrent . atomic . AtomicBoolean ; public class FutureTest extends VertxTestBase { @ Test public void testStateAfterCompletion ( ) { Object foo = new Object ( ) ; Future < Object > future = Future . succeededFuture ( foo ) ; assertTrue ( future . succeeded ( ) ) ; assertFalse ( future . failed ( ) ) ; assertTrue ( future . isComplete ( ) ) ; assertEquals ( foo , future . result ( ) ) ; assertNull ( future . cause ( ) ) ; Exception cause = new Exception ( ) ; future = Future . failedFuture ( cause ) ; assertFalse ( future . succeeded ( ) ) ; assertTrue ( future . failed ( ) ) ; assertTrue ( future . isComplete ( ) ) ; assertNull ( future . result ( ) ) ; assertEquals ( cause , future . cause ( ) ) ; } @ Test public void testSetResultOnCompletedFuture ( ) { ArrayList < Future < Object > > futures = new ArrayList < > ( ) ; futures . add ( Future . succeededFuture ( ) ) ; futures . add ( Future . succeededFuture ( ) ) ; futures . add ( Future . succeededFuture ( new Object ( ) ) ) ; futures . add ( Future . succeededFuture ( new Object ( ) ) ) ; futures . add ( Future . failedFuture ( new Exception ( ) ) ) ; futures . add ( Future . failedFuture ( new Exception ( ) ) ) ; for ( Future < Object > future : futures ) { try { future . complete ( new Object ( ) ) ; fail ( ) ; } catch ( IllegalStateException ignore ) { } try { future . complete ( null ) ; fail ( ) ; } catch ( IllegalStateException ignore ) { } try { future . fail ( new Exception ( ) ) ; fail ( ) ; } catch ( IllegalStateException ignore ) { } } } @ Test public void testCallSetHandlerBeforeCompletion ( ) { AtomicBoolean called = new AtomicBoolean ( ) ; Future < Object > future = Future . future ( ) ; future . setHandler ( result - > { assertTrue ( result . succeeded ( ) ) ; assertFalse ( result . failed ( ) ) ; assertEquals ( null , result . result ( ) ) ; assertEquals ( null , result . cause ( ) ) ; called . set ( true ) ; } ) ; assertFalse ( called . get ( ) ) ; future . complete ( null ) ; assertTrue ( called . get ( ) ) ; called . set ( false ) ; Object foo = new Object ( ) ; future = Future . future ( ) ; future . setHandler ( result - > { called . set ( true ) ; assertTrue ( result . succeeded ( ) ) ; assertFalse ( result . failed ( ) ) ; assertEquals ( foo , result . result ( ) ) ; assertEquals ( null , result . cause ( ) ) ; } ) ; assertFalse ( called . get ( ) ) ; future . complete ( foo ) ; assertTrue ( called . get ( ) ) ; called . set ( false ) ; Exception cause = new Exception ( ) ; future = Future . future ( ) ; future . setHandler ( result - > { called . set ( true ) ; assertFalse ( result . succeeded ( ) ) ; assertTrue ( result . failed ( ) ) ; assertEquals ( null , result . result ( ) ) ; assertEquals ( cause , result . cause ( ) ) ; } ) ; assertFalse ( called . get ( ) ) ; future . fail ( cause ) ; assertTrue ( called . get ( ) ) ; } @ Test public void testCallSetHandlerAfterCompletion ( ) { AtomicBoolean called = new AtomicBoolean ( ) ; Future < Object > future = Future . succeededFuture ( ) ; future . setHandler ( result - > { assertTrue ( result . succeeded ( ) ) ; assertFalse ( result . failed ( ) ) ; assertEquals ( null , result . result ( ) ) ; assertEquals ( null , result . cause ( ) ) ; called . set ( true ) ; } ) ; assertTrue ( called . get ( ) ) ; called . set ( false ) ; Object foo = new Object ( ) ; future = Future . succeededFuture ( foo ) ; future . setHandler ( result - > { assertTrue ( result . succeeded ( ) ) ; assertFalse ( result . failed ( ) ) ; assertEquals ( foo , result . result ( ) ) ; assertEquals ( null , result . cause ( ) ) ; called . set ( true ) ; } ) ; assertTrue ( called . get ( ) ) ; called . set ( false ) ; Exception cause = new Exception ( ) ; future = Future . failedFuture ( cause ) ; future . setHandler ( result - > { assertFalse ( result . succeeded ( ) ) ; assertTrue ( result . failed ( ) ) ; assertEquals ( null , result . result ( ) ) ; assertEquals ( cause , result . cause ( ) ) ; called . set ( true ) ; } ) ; assertTrue ( called . get ( ) ) ; } }
package io . vertx . test . core ; import io . vertx . core . Handler ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . parsetools . RecordParser ; import org . junit . Test ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import static io . vertx . test . core . TestUtils . assertNullPointerException ; import static org . junit . Assert . assertEquals ; public class RecordParserTest { @ Test public void testIllegalArguments ( ) throws Exception { assertNullPointerException ( ( ) - > RecordParser . newDelimited ( ( Buffer ) null , handler - > { } ) ) ; assertNullPointerException ( ( ) - > RecordParser . newDelimited ( ( String ) null , handler - > { } ) ) ; RecordParser parser = RecordParser . newDelimited ( "" , handler - > { } ) ; assertNullPointerException ( ( ) - > parser . setOutput ( null ) ) ; assertNullPointerException ( ( ) - > parser . delimitedMode ( ( Buffer ) null ) ) ; assertNullPointerException ( ( ) - > parser . delimitedMode ( ( String ) null ) ) ; } @ Test public void testDelimited ( ) { delimited ( Buffer . buffer ( ) . appendByte ( ( byte ) '\n' ) ) ; delimited ( Buffer . buffer ( ) . appendByte ( ( byte ) '\r' ) . appendByte ( ( byte ) '\n' ) ) ; delimited ( Buffer . buffer ( new byte [ ] { 0 , 3 , 2 , 5 , 6 , 4 , 6 } ) ) ; } @ Test public void testFixed ( ) { int lines = 50 ; Buffer [ ] expected = new Buffer [ lines ] ; List < Buffer > lineList = generateLines ( lines , false , ( byte ) 0 ) ; expected = lineList . toArray ( expected ) ; int totLength = lines * ( lines - 1 ) / 2 ; Buffer inp = Buffer . buffer ( totLength ) ; for ( int i = 0 ; i < lines ; i ++ ) { inp . appendBuffer ( expected [ i ] ) ; } for ( int i = 1 ; i < inp . length ( ) * 2 ; i ++ ) { doTestFixed ( inp , new Integer [ ] { i } , expected ) ; } List < Integer > chunkSizes = generateChunkSizes ( lines ) ; for ( int i = 0 ; i < 10 ; i ++ ) { Collections . shuffle ( chunkSizes ) ; doTestFixed ( inp , chunkSizes . toArray ( new Integer [ ] { } ) , expected ) ; } } @ Test public void testMixed ( ) { final int lines = 8 ; final List < Object > types = new ArrayList < Object > ( ) ; class MyHandler implements Handler < Buffer > { RecordParser parser = RecordParser . newFixed ( 10 , this ) ; int pos ; public void handle ( Buffer buff ) { if ( pos < lines ) { Object type = types . get ( pos ) ; if ( type instanceof byte [ ] ) { byte [ ] bytes = ( byte [ ] ) type ; parser . delimitedMode ( Buffer . buffer ( bytes ) ) ; } else { int length = ( Integer ) type ; parser . fixedSizeMode ( length ) ; } } } } MyHandler out = new MyHandler ( ) ; Buffer [ ] expected = new Buffer [ lines ] ; Buffer input = Buffer . buffer ( 100 ) ; expected [ 0 ] = TestUtils . randomBuffer ( 10 ) ; input . appendBuffer ( expected [ 0 ] ) ; types . add ( expected [ 0 ] . length ( ) ) ; expected [ 1 ] = TestUtils . randomBuffer ( 100 ) ; input . appendBuffer ( expected [ 1 ] ) ; types . add ( expected [ 1 ] . length ( ) ) ; byte [ ] delim = new byte [ ] { 23 , - 120 , 100 , 3 } ; expected [ 2 ] = TestUtils . randomBuffer ( 50 , true , delim [ 0 ] ) ; input . appendBuffer ( expected [ 2 ] ) ; types . add ( delim ) ; input . appendBuffer ( Buffer . buffer ( delim ) ) ; expected [ 3 ] = TestUtils . randomBuffer ( 1000 ) ; input . appendBuffer ( expected [ 3 ] ) ; types . add ( expected [ 3 ] . length ( ) ) ; expected [ 4 ] = TestUtils . randomBuffer ( 230 , true , delim [ 0 ] ) ; input . appendBuffer ( expected [ 4 ] ) ; types . add ( delim ) ; input . appendBuffer ( Buffer . buffer ( delim ) ) ; delim = new byte [ ] { 17 } ; expected [ 5 ] = TestUtils . randomBuffer ( 341 , true , delim [ 0 ] ) ; input . appendBuffer ( expected [ 5 ] ) ; types . add ( delim ) ; input . appendBuffer ( Buffer . buffer ( delim ) ) ; delim = new byte [ ] { 54 , - 32 , 0 } ; expected [ 6 ] = TestUtils . randomBuffer ( 1234 , true , delim [ 0 ] ) ; input . appendBuffer ( expected [ 6 ] ) ; types . add ( delim ) ; input . appendBuffer ( Buffer . buffer ( delim ) ) ; expected [ 7 ] = TestUtils . randomBuffer ( 100 ) ; input . appendBuffer ( expected [ 7 ] ) ; types . add ( expected [ 7 ] . length ( ) ) ; feedChunks ( input , out . parser , new Integer [ ] { 50 , 10 , 3 } ) ; } private void delimited ( Buffer delim ) { int lines = 50 ; Buffer [ ] expected = new Buffer [ lines ] ; List < Buffer > lineList = generateLines ( lines , true , delim . getByte ( 0 ) ) ; expected = lineList . toArray ( expected ) ; int totLength = lines * ( lines - 1 ) / 2 ; Buffer inp = Buffer . buffer ( totLength + lines * delim . length ( ) ) ; for ( int i = 0 ; i < lines ; i ++ ) { inp . appendBuffer ( expected [ i ] ) ; inp . appendBuffer ( delim ) ; } for ( int i = 1 ; i < inp . length ( ) * 2 ; i ++ ) { doTestDelimited ( inp , delim , new Integer [ ] { i } , expected ) ; } List < Integer > chunkSizes = generateChunkSizes ( lines ) ; for ( int i = 0 ; i < 10 ; i ++ ) { Collections . shuffle ( chunkSizes ) ; doTestDelimited ( inp , delim , chunkSizes . toArray ( new Integer [ ] { } ) , expected ) ; } } private void doTestDelimited ( final Buffer input , Buffer delim , Integer [ ] chunkSizes , final Buffer ... expected ) { final Buffer [ ] results = new Buffer [ expected . length ] ; Handler < Buffer > out = new Handler < Buffer > ( ) { int pos ; public void handle ( Buffer buff ) { results [ pos ++ ] = buff ; } } ; RecordParser parser = RecordParser . newDelimited ( delim , out ) ; feedChunks ( input , parser , chunkSizes ) ; checkResults ( expected , results ) ; } private void doTestFixed ( final Buffer input , Integer [ ] chunkSizes , final Buffer ... expected ) { final Buffer [ ] results = new Buffer [ expected . length ] ; class MyHandler implements Handler < Buffer > { int pos ; RecordParser parser = RecordParser . newFixed ( expected [ 0 ] . length ( ) , this ) ; public void handle ( Buffer buff ) { results [ pos ++ ] = buff ; if ( pos < expected . length ) { parser . fixedSizeMode ( expected [ pos ] . length ( ) ) ; } } } MyHandler out = new MyHandler ( ) ; feedChunks ( input , out . parser , chunkSizes ) ; checkResults ( expected , results ) ; } private void feedChunks ( Buffer input , RecordParser parser , Integer [ ] chunkSizes ) { int pos = 0 ; int chunkPos = 0 ; while ( pos < input . length ( ) ) { int chunkSize = chunkSizes [ chunkPos ++ ] ; if ( chunkPos == chunkSizes . length ) chunkPos = 0 ; int end = pos + chunkSize ; end = end <= input . length ( ) ? end : input . length ( ) ; Buffer sub = input . getBuffer ( pos , end ) ; parser . handle ( sub ) ; pos += chunkSize ; } } private void checkResults ( Buffer [ ] expected , Buffer [ ] results ) { for ( int i = 0 ; i < expected . length ; i ++ ) { assertEquals ( "Expected:" + expected [ i ] + " length:" + expected [ i ] . length ( ) + " Actual:" + results [ i ] + " length:" + results [ i ] . length ( ) , expected [ i ] , results [ i ] ) ; } } private List < Buffer > generateLines ( int lines , boolean delim , byte delimByte ) { List < Buffer > lineList = new ArrayList < Buffer > ( ) ; for ( int i = 0 ; i < lines ; i ++ ) { lineList . add ( TestUtils . randomBuffer ( i + 1 , delim , delimByte ) ) ; } Collections . shuffle ( lineList ) ; return lineList ; } private List < Integer > generateChunkSizes ( int lines ) { List < Integer > chunkSizes = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i < lines / 5 ; i ++ ) { chunkSizes . add ( i ) ; } return chunkSizes ; } @ Test public void testSpreadDelimiter ( ) { doTestDelimited ( Buffer . buffer ( "start-a-b-c-dddabc" ) , Buffer . buffer ( "abc" ) , new Integer [ ] { 18 } , Buffer . buffer ( "start-a-b-c-ddd" ) ) ; doTestDelimited ( Buffer . buffer ( "start-abc-dddabc" ) , Buffer . buffer ( "abc" ) , new Integer [ ] { 18 } , Buffer . buffer ( "start-" ) , Buffer . buffer ( "-ddd" ) ) ; doTestDelimited ( Buffer . buffer ( "start-ab-c-dddabc" ) , Buffer . buffer ( "abc" ) , new Integer [ ] { 18 } , Buffer . buffer ( "start-ab-c-ddd" ) ) ; } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; public class HAVerticle1 extends AbstractVerticle { @ Override public void start ( ) throws Exception { } @ Override public void stop ( ) throws Exception { } }
package io . vertx . test . core ; import io . vertx . core . AsyncResult ; import io . vertx . core . Handler ; import io . vertx . core . Vertx ; import io . vertx . core . VertxOptions ; import io . vertx . core . eventbus . * ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . spi . cluster . ClusterManager ; import io . vertx . test . fakecluster . FakeClusterManager ; import org . junit . Test ; import java . util . ArrayList ; import java . util . Map ; import java . util . concurrent . ConcurrentLinkedDeque ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . function . Consumer ; public class ClusteredEventBusTest extends EventBusTestBase { private static final String ADDRESS1 = "some-address1" ; protected ClusterManager getClusterManager ( ) { return new FakeClusterManager ( ) ; } @ Override protected < T , R > void testSend ( T val , R received , Consumer < T > consumer , DeliveryOptions options ) { if ( vertices == null ) { startNodes ( 2 ) ; } MessageConsumer < T > reg = vertices [ 1 ] . eventBus ( ) . < T > consumer ( ADDRESS1 ) . handler ( ( Message < T > msg ) - > { if ( consumer == null ) { assertEquals ( received , msg . body ( ) ) ; if ( options != null ) { assertNotNull ( msg . headers ( ) ) ; int numHeaders = options . getHeaders ( ) != null ? options . getHeaders ( ) . size ( ) : 0 ; assertEquals ( numHeaders , msg . headers ( ) . size ( ) ) ; if ( numHeaders != 0 ) { for ( Map . Entry < String , String > entry : options . getHeaders ( ) . entries ( ) ) { assertEquals ( msg . headers ( ) . get ( entry . getKey ( ) ) , entry . getValue ( ) ) ; } } } } else { consumer . accept ( msg . body ( ) ) ; } testComplete ( ) ; } ) ; reg . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; if ( options == null ) { vertices [ 0 ] . eventBus ( ) . send ( ADDRESS1 , val ) ; } else { vertices [ 0 ] . eventBus ( ) . send ( ADDRESS1 , val , options ) ; } } ) ; await ( ) ; } @ Override protected < T > void testSend ( T val , Consumer < T > consumer ) { testSend ( val , val , consumer , null ) ; } @ Override protected < T > void testReply ( T val , Consumer < T > consumer ) { testReply ( val , val , consumer , null ) ; } @ Override protected < T , R > void testReply ( T val , R received , Consumer < R > consumer , DeliveryOptions options ) { if ( vertices == null ) { startNodes ( 2 ) ; } String str = TestUtils . randomUnicodeString ( 1000 ) ; MessageConsumer < ? > reg = vertices [ 1 ] . eventBus ( ) . consumer ( ADDRESS1 ) . handler ( msg - > { assertEquals ( str , msg . body ( ) ) ; if ( options == null ) { msg . reply ( val ) ; } else { msg . reply ( val , options ) ; } } ) ; reg . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; vertices [ 0 ] . eventBus ( ) . send ( ADDRESS1 , str , onSuccess ( ( Message < R > reply ) - > { if ( consumer == null ) { assertEquals ( received , reply . body ( ) ) ; if ( options != null && options . getHeaders ( ) != null ) { assertNotNull ( reply . headers ( ) ) ; assertEquals ( options . getHeaders ( ) . size ( ) , reply . headers ( ) . size ( ) ) ; for ( Map . Entry < String , String > entry : options . getHeaders ( ) . entries ( ) ) { assertEquals ( reply . headers ( ) . get ( entry . getKey ( ) ) , entry . getValue ( ) ) ; } } } else { consumer . accept ( reply . body ( ) ) ; } testComplete ( ) ; } ) ) ; } ) ; await ( ) ; } @ Test public void testRegisterRemote1 ( ) { startNodes ( 2 ) ; String str = TestUtils . randomUnicodeString ( 100 ) ; vertices [ 0 ] . eventBus ( ) . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; testComplete ( ) ; } ) . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; vertices [ 1 ] . eventBus ( ) . send ( ADDRESS1 , str ) ; } ) ; await ( ) ; } @ Test public void testRegisterRemote2 ( ) { startNodes ( 2 ) ; String str = TestUtils . randomUnicodeString ( 100 ) ; vertices [ 0 ] . eventBus ( ) . consumer ( ADDRESS1 , ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; testComplete ( ) ; } ) . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; vertices [ 1 ] . eventBus ( ) . send ( ADDRESS1 , str ) ; } ) ; await ( ) ; } @ Override protected < T > void testPublish ( T val , Consumer < T > consumer ) { int numNodes = 3 ; startNodes ( numNodes ) ; AtomicInteger count = new AtomicInteger ( ) ; class MyHandler implements Handler < Message < T > > { @ Override public void handle ( Message < T > msg ) { if ( consumer == null ) { assertEquals ( val , msg . body ( ) ) ; } else { consumer . accept ( msg . body ( ) ) ; } if ( count . incrementAndGet ( ) == numNodes - 1 ) { testComplete ( ) ; } } } AtomicInteger registerCount = new AtomicInteger ( 0 ) ; class MyRegisterHandler implements Handler < AsyncResult < Void > > { @ Override public void handle ( AsyncResult < Void > ar ) { assertTrue ( ar . succeeded ( ) ) ; if ( registerCount . incrementAndGet ( ) == 2 ) { vertices [ 0 ] . eventBus ( ) . publish ( ADDRESS1 , val ) ; } } } MessageConsumer reg = vertices [ 2 ] . eventBus ( ) . < T > consumer ( ADDRESS1 ) . handler ( new MyHandler ( ) ) ; reg . completionHandler ( new MyRegisterHandler ( ) ) ; reg = vertices [ 1 ] . eventBus ( ) . < T > consumer ( ADDRESS1 ) . handler ( new MyHandler ( ) ) ; reg . completionHandler ( new MyRegisterHandler ( ) ) ; vertices [ 0 ] . eventBus ( ) . publish ( ADDRESS1 , val ) ; await ( ) ; } @ Test public void testLocalHandlerNotReceive ( ) throws Exception { startNodes ( 2 ) ; vertices [ 1 ] . eventBus ( ) . localConsumer ( ADDRESS1 ) . handler ( msg - > { fail ( "Should not receive message" ) ; } ) ; vertices [ 0 ] . eventBus ( ) . send ( ADDRESS1 , "foo" ) ; vertices [ 0 ] . setTimer ( 1000 , id - > testComplete ( ) ) ; await ( ) ; } @ Test public void testDecoderSendAsymmetric ( ) throws Exception { startNodes ( 2 ) ; MessageCodec codec = new MyPOJOEncoder1 ( ) ; vertices [ 0 ] . eventBus ( ) . registerCodec ( codec ) ; vertices [ 1 ] . eventBus ( ) . registerCodec ( codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; testSend ( new MyPOJO ( str ) , str , null , new DeliveryOptions ( ) . setCodecName ( codec . name ( ) ) ) ; } @ Test public void testDecoderReplyAsymmetric ( ) throws Exception { startNodes ( 2 ) ; MessageCodec codec = new MyPOJOEncoder1 ( ) ; vertices [ 0 ] . eventBus ( ) . registerCodec ( codec ) ; vertices [ 1 ] . eventBus ( ) . registerCodec ( codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; testReply ( new MyPOJO ( str ) , str , null , new DeliveryOptions ( ) . setCodecName ( codec . name ( ) ) ) ; } @ Test public void testDecoderSendSymmetric ( ) throws Exception { startNodes ( 2 ) ; MessageCodec codec = new MyPOJOEncoder2 ( ) ; vertices [ 0 ] . eventBus ( ) . registerCodec ( codec ) ; vertices [ 1 ] . eventBus ( ) . registerCodec ( codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; MyPOJO pojo = new MyPOJO ( str ) ; testSend ( pojo , pojo , null , new DeliveryOptions ( ) . setCodecName ( codec . name ( ) ) ) ; } @ Test public void testDecoderReplySymmetric ( ) throws Exception { startNodes ( 2 ) ; MessageCodec codec = new MyPOJOEncoder2 ( ) ; vertices [ 0 ] . eventBus ( ) . registerCodec ( codec ) ; vertices [ 1 ] . eventBus ( ) . registerCodec ( codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; MyPOJO pojo = new MyPOJO ( str ) ; testReply ( pojo , pojo , null , new DeliveryOptions ( ) . setCodecName ( codec . name ( ) ) ) ; } @ Test public void testDefaultDecoderSendAsymmetric ( ) throws Exception { startNodes ( 2 ) ; MessageCodec codec = new MyPOJOEncoder1 ( ) ; vertices [ 0 ] . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; vertices [ 1 ] . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; testSend ( new MyPOJO ( str ) , str , null , null ) ; } @ Test public void testDefaultDecoderReplyAsymmetric ( ) throws Exception { startNodes ( 2 ) ; MessageCodec codec = new MyPOJOEncoder1 ( ) ; vertices [ 0 ] . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; vertices [ 1 ] . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; testReply ( new MyPOJO ( str ) , str , null , null ) ; } @ Test public void testDefaultDecoderSendSymetric ( ) throws Exception { startNodes ( 2 ) ; MessageCodec codec = new MyPOJOEncoder2 ( ) ; vertices [ 0 ] . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; vertices [ 1 ] . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; MyPOJO pojo = new MyPOJO ( str ) ; testSend ( pojo , pojo , null , null ) ; } @ Test public void testDefaultDecoderReplySymetric ( ) throws Exception { startNodes ( 2 ) ; MessageCodec codec = new MyPOJOEncoder2 ( ) ; vertices [ 0 ] . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; vertices [ 1 ] . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; MyPOJO pojo = new MyPOJO ( str ) ; testReply ( pojo , pojo , null , null ) ; } @ Test public void testClusteredPong ( ) throws Exception { startNodes ( 2 , new VertxOptions ( ) . setClusterPingInterval ( 500 ) . setClusterPingReplyInterval ( 500 ) ) ; AtomicBoolean sending = new AtomicBoolean ( ) ; MessageConsumer < String > consumer = vertices [ 0 ] . eventBus ( ) . < String > consumer ( "foobar" ) . handler ( msg - > { if ( ! sending . get ( ) ) { sending . set ( true ) ; vertx . setTimer ( 4000 , id - > { vertices [ 1 ] . eventBus ( ) . send ( "foobar" , "whatever2" ) ; } ) ; } else { testComplete ( ) ; } } ) ; consumer . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; vertices [ 1 ] . eventBus ( ) . send ( "foobar" , "whatever" ) ; } ) ; await ( ) ; } @ Test public void testConsumerHandlesCompletionAsynchronously1 ( ) { startNodes ( 2 ) ; MessageConsumer < Object > consumer = vertices [ 0 ] . eventBus ( ) . consumer ( ADDRESS1 ) ; ThreadLocal < Object > stack = new ThreadLocal < > ( ) ; stack . set ( true ) ; consumer . completionHandler ( v - > { assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; assertNull ( stack . get ( ) ) ; testComplete ( ) ; } ) ; consumer . handler ( msg - > { } ) ; await ( ) ; } @ Test public void testConsumerHandlesCompletionAsynchronously2 ( ) { startNodes ( 2 ) ; MessageConsumer < Object > consumer = vertices [ 0 ] . eventBus ( ) . consumer ( ADDRESS1 ) ; consumer . handler ( msg - > { } ) ; ThreadLocal < Object > stack = new ThreadLocal < > ( ) ; stack . set ( true ) ; consumer . completionHandler ( v - > { assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; assertNull ( stack . get ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testSubsRemovedForClosedNode ( ) throws Exception { testSubsRemoved ( latch - > { vertices [ 1 ] . close ( onSuccess ( v - > { latch . countDown ( ) ; } ) ) ; } ) ; } @ Test public void testSubsRemovedForKilledNode ( ) throws Exception { testSubsRemoved ( latch - > { VertxInternal vi = ( VertxInternal ) vertices [ 1 ] ; vi . getClusterManager ( ) . leave ( onSuccess ( v - > { latch . countDown ( ) ; } ) ) ; } ) ; } private void testSubsRemoved ( Consumer < CountDownLatch > action ) throws Exception { startNodes ( 3 ) ; CountDownLatch regLatch = new CountDownLatch ( 1 ) ; AtomicInteger cnt = new AtomicInteger ( ) ; vertices [ 0 ] . eventBus ( ) . consumer ( ADDRESS1 , msg - > { int c = cnt . getAndIncrement ( ) ; assertEquals ( msg . body ( ) , "foo" + c ) ; if ( c == 9 ) { testComplete ( ) ; } if ( c > 9 ) { fail ( "too many messages" ) ; } } ) . completionHandler ( onSuccess ( v - > { vertices [ 1 ] . eventBus ( ) . consumer ( ADDRESS1 , msg - > { fail ( "shouldn't get message" ) ; } ) . completionHandler ( onSuccess ( v2 - > { regLatch . countDown ( ) ; } ) ) ; regLatch . countDown ( ) ; } ) ) ; awaitLatch ( regLatch ) ; CountDownLatch closeLatch = new CountDownLatch ( 1 ) ; action . accept ( closeLatch ) ; awaitLatch ( closeLatch ) ; Thread . sleep ( 2000 ) ; vertices [ 2 ] . runOnContext ( v - > { EventBus ebSender = vertices [ 2 ] . eventBus ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { ebSender . send ( ADDRESS1 , "foo" + i ) ; } } ) ; await ( ) ; } @ Test public void sendNoContext ( ) throws Exception { int size = 1000 ; ConcurrentLinkedDeque < Integer > expected = new ConcurrentLinkedDeque < > ( ) ; ConcurrentLinkedDeque < Integer > obtained = new ConcurrentLinkedDeque < > ( ) ; startNodes ( 2 ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; vertices [ 1 ] . eventBus ( ) . < Integer > consumer ( ADDRESS1 , msg - > { obtained . add ( msg . body ( ) ) ; if ( obtained . size ( ) == expected . size ( ) ) { assertEquals ( new ArrayList < > ( expected ) , new ArrayList < > ( obtained ) ) ; testComplete ( ) ; } } ) . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; latch . countDown ( ) ; } ) ; latch . await ( ) ; EventBus bus = vertices [ 0 ] . eventBus ( ) ; for ( int i = 0 ; i < size ; i ++ ) { expected . add ( i ) ; bus . send ( ADDRESS1 , i ) ; } await ( ) ; } }
package io . vertx . test . core ; import com . fasterxml . jackson . databind . ObjectMapper ; import io . vertx . core . json . Json ; import org . junit . Test ; public class JsonMapperTest extends VertxTestBase { @ Test public void testGetSetMapper ( ) { ObjectMapper mapper = Json . mapper ; assertNotNull ( mapper ) ; ObjectMapper newMapper = new ObjectMapper ( ) ; Json . mapper = newMapper ; assertSame ( newMapper , Json . mapper ) ; Json . mapper = mapper ; } @ Test public void testGetSetPrettyMapper ( ) { ObjectMapper mapper = Json . prettyMapper ; assertNotNull ( mapper ) ; ObjectMapper newMapper = new ObjectMapper ( ) ; Json . prettyMapper = newMapper ; assertSame ( newMapper , Json . prettyMapper ) ; Json . prettyMapper = mapper ; } }
package io . vertx . test . core ; import io . vertx . core . spi . VerticleFactory ; import org . junit . Test ; public class ClasspathVerticleFactoryTest extends VertxTestBase { @ Test public void testLoadedFromClasspath ( ) { assertEquals ( 1 , vertx . verticleFactories ( ) . size ( ) ) ; VerticleFactory fact = vertx . verticleFactories ( ) . iterator ( ) . next ( ) ; assertTrue ( fact instanceof ClasspathVerticleFactory ) ; } }
package io . vertx . test . core ; import io . vertx . core . VertxOptions ; import io . vertx . core . datagram . DatagramSocket ; import io . vertx . core . datagram . DatagramSocketOptions ; import io . vertx . core . http . HttpClient ; import io . vertx . core . http . HttpClientOptions ; import io . vertx . core . http . HttpServer ; import io . vertx . core . http . HttpServerOptions ; import io . vertx . core . metrics . MetricsOptions ; import io . vertx . core . net . NetClient ; import io . vertx . core . net . NetClientOptions ; import io . vertx . core . net . NetServer ; import io . vertx . core . net . NetServerOptions ; import org . junit . Test ; public class DummyMetricsTest extends VertxTestBase { @ Override protected VertxOptions getOptions ( ) { return new VertxOptions ( ) . setMetricsOptions ( new MetricsOptions ( ) . setEnabled ( false ) ) ; } @ Test public void testDummyVertxMetrics ( ) { assertFalse ( vertx . isMetricsEnabled ( ) ) ; } @ Test public void testDummyNetServerMetrics ( ) { NetServer server = vertx . createNetServer ( new NetServerOptions ( ) ) ; assertFalse ( server . isMetricsEnabled ( ) ) ; } @ Test public void testDummyNetClientMetrics ( ) { NetClient client = vertx . createNetClient ( new NetClientOptions ( ) ) ; assertFalse ( client . isMetricsEnabled ( ) ) ; } @ Test public void testDummyHttpServerMetrics ( ) { HttpServer server = vertx . createHttpServer ( new HttpServerOptions ( ) ) ; assertFalse ( server . isMetricsEnabled ( ) ) ; } @ Test public void testDummyHttpClientMetrics ( ) { HttpClient client = vertx . createHttpClient ( new HttpClientOptions ( ) ) ; assertFalse ( client . isMetricsEnabled ( ) ) ; } @ Test public void testDummyEventBusMetrics ( ) { assertFalse ( vertx . eventBus ( ) . isMetricsEnabled ( ) ) ; } @ Test public void testDummyDatagramSocketMetrics ( ) { DatagramSocket sock = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; assertFalse ( sock . isMetricsEnabled ( ) ) ; } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . AsyncResult ; import io . vertx . core . Context ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Handler ; import io . vertx . core . MultiMap ; import io . vertx . core . Vertx ; import io . vertx . core . eventbus . DeliveryOptions ; import io . vertx . core . eventbus . EventBus ; import io . vertx . core . eventbus . Message ; import io . vertx . core . eventbus . MessageCodec ; import io . vertx . core . eventbus . MessageConsumer ; import io . vertx . core . eventbus . MessageProducer ; import io . vertx . core . eventbus . ReplyException ; import io . vertx . core . eventbus . ReplyFailure ; import io . vertx . core . eventbus . impl . EventBusImpl ; import io . vertx . core . http . CaseInsensitiveHeaders ; import io . vertx . core . impl . ConcurrentHashSet ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . EventLoopContext ; import io . vertx . core . impl . MultiThreadedWorkerContext ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . impl . WorkerContext ; import io . vertx . core . streams . Pump ; import io . vertx . core . streams . ReadStream ; import io . vertx . core . streams . WriteStream ; import org . junit . Test ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . function . BiFunction ; import java . util . function . Consumer ; import static io . vertx . test . core . TestUtils . * ; public class LocalEventBusTest extends EventBusTestBase { private Vertx vertx ; private EventBus eb ; private boolean running ; public void setUp ( ) throws Exception { super . setUp ( ) ; vertx = Vertx . vertx ( ) ; eb = vertx . eventBus ( ) ; running = true ; } protected void tearDown ( ) throws Exception { closeVertx ( ) ; super . tearDown ( ) ; } private void closeVertx ( ) throws Exception { if ( running ) { CountDownLatch latch = new CountDownLatch ( 1 ) ; vertx . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; latch . countDown ( ) ; } ) ; assertTrue ( latch . await ( 30 , TimeUnit . SECONDS ) ) ; running = false ; } } @ Test public void testDeliveryOptions ( ) { DeliveryOptions options = new DeliveryOptions ( ) ; assertIllegalArgumentException ( ( ) - > options . setSendTimeout ( 0 ) ) ; assertIllegalArgumentException ( ( ) - > options . setSendTimeout ( - 1 ) ) ; assertNullPointerException ( ( ) - > options . addHeader ( null , "" ) ) ; assertNullPointerException ( ( ) - > options . addHeader ( "" , null ) ) ; } @ Test public void testArgumentValidation ( ) throws Exception { assertNullPointerException ( ( ) - > eb . send ( null , "" ) ) ; assertNullPointerException ( ( ) - > eb . send ( null , "" , handler - > { } ) ) ; assertNullPointerException ( ( ) - > eb . send ( null , "" , new DeliveryOptions ( ) ) ) ; assertNullPointerException ( ( ) - > eb . send ( "" , "" , ( DeliveryOptions ) null ) ) ; assertNullPointerException ( ( ) - > eb . send ( null , "" , new DeliveryOptions ( ) , handler - > { } ) ) ; assertNullPointerException ( ( ) - > eb . send ( "" , "" , null , handler - > { } ) ) ; assertNullPointerException ( ( ) - > eb . publish ( null , "" ) ) ; assertNullPointerException ( ( ) - > eb . publish ( null , "" , new DeliveryOptions ( ) ) ) ; assertNullPointerException ( ( ) - > eb . publish ( "" , "" , null ) ) ; assertNullPointerException ( ( ) - > eb . consumer ( null ) ) ; assertNullPointerException ( ( ) - > eb . consumer ( null , msg - > { } ) ) ; assertNullPointerException ( ( ) - > eb . consumer ( ADDRESS1 , null ) ) ; assertNullPointerException ( ( ) - > eb . localConsumer ( null ) ) ; assertNullPointerException ( ( ) - > eb . localConsumer ( null , msg - > { } ) ) ; assertNullPointerException ( ( ) - > eb . localConsumer ( ADDRESS1 , null ) ) ; assertNullPointerException ( ( ) - > eb . sender ( null ) ) ; assertNullPointerException ( ( ) - > eb . sender ( null , new DeliveryOptions ( ) ) ) ; assertNullPointerException ( ( ) - > eb . publisher ( "" , null ) ) ; assertNullPointerException ( ( ) - > eb . publisher ( null , new DeliveryOptions ( ) ) ) ; assertNullPointerException ( ( ) - > eb . registerCodec ( null ) ) ; assertNullPointerException ( ( ) - > eb . unregisterCodec ( null ) ) ; assertNullPointerException ( ( ) - > eb . registerDefaultCodec ( null , new MyPOJOEncoder1 ( ) ) ) ; assertNullPointerException ( ( ) - > eb . registerDefaultCodec ( Object . class , null ) ) ; assertNullPointerException ( ( ) - > eb . unregisterDefaultCodec ( null ) ) ; } @ Test public void testRegisterUnregister ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; Handler < Message < String > > handler = msg - > fail ( "Should not receive message" ) ; MessageConsumer reg = eb . < String > consumer ( ADDRESS1 ) . handler ( handler ) ; assertEquals ( ADDRESS1 , reg . address ( ) ) ; reg . unregister ( ) ; eb . send ( ADDRESS1 , str ) ; vertx . setTimer ( 1000 , id - > testComplete ( ) ) ; await ( ) ; } @ Test public void testUnregisterTwice ( ) { Handler < Message < String > > handler = msg - > { } ; MessageConsumer reg = eb . < String > consumer ( ADDRESS1 ) . handler ( handler ) ; reg . unregister ( ) ; reg . unregister ( ) ; testComplete ( ) ; } @ Test public void testRegisterLocal1 ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; eb . < String > localConsumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; testComplete ( ) ; } ) . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; eb . send ( ADDRESS1 , str ) ; } ) ; await ( ) ; } @ Test public void testRegisterLocal2 ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; eb . localConsumer ( ADDRESS1 , ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; testComplete ( ) ; } ) . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; eb . send ( ADDRESS1 , str ) ; } ) ; await ( ) ; } @ Test public void testRegisterWithCompletionHandler ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; MessageConsumer < String > reg = eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; testComplete ( ) ; } ) ; reg . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; eb . send ( ADDRESS1 , str ) ; } ) ; await ( ) ; } @ Test public void testSendRoundRobin ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; int numHandlers = 10 ; int numMessages = 100 ; Handler < Message < String > > [ ] handlers = new Handler [ numHandlers ] ; Map < Handler , Integer > countMap = new ConcurrentHashMap < > ( ) ; AtomicInteger totalCount = new AtomicInteger ( ) ; for ( int i = 0 ; i < numHandlers ; i ++ ) { int index = i ; handlers [ i ] = ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; Integer cnt = countMap . get ( handlers [ index ] ) ; int icnt = cnt == null ? 0 : cnt ; icnt ++ ; countMap . put ( handlers [ index ] , icnt ) ; if ( totalCount . incrementAndGet ( ) == numMessages ) { assertEquals ( numHandlers , countMap . size ( ) ) ; for ( Integer ind : countMap . values ( ) ) { assertEquals ( numMessages / numHandlers , ind . intValue ( ) ) ; } testComplete ( ) ; } } ; eb . < String > consumer ( ADDRESS1 ) . handler ( handlers [ i ] ) ; } for ( int i = 0 ; i < numMessages ; i ++ ) { eb . send ( ADDRESS1 , str ) ; } await ( ) ; } @ Test public void testSendRegisterSomeUnregisterOne ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; AtomicInteger totalCount = new AtomicInteger ( ) ; Handler < Message < String > > handler1 = msg - > fail ( "Should not receive message" ) ; Handler < Message < String > > handler2 = msg - > { assertEquals ( str , msg . body ( ) ) ; if ( totalCount . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ; Handler < Message < String > > handler3 = msg - > { assertEquals ( str , msg . body ( ) ) ; if ( totalCount . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ; MessageConsumer reg = eb . < String > consumer ( ADDRESS1 ) . handler ( handler1 ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( handler2 ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( handler3 ) ; reg . unregister ( ) ; eb . send ( ADDRESS1 , str ) ; eb . send ( ADDRESS1 , str ) ; await ( ) ; } @ Test public void testSendRegisterSameHandlerMultipleTimes ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; AtomicInteger totalCount = new AtomicInteger ( ) ; Handler < Message < String > > handler = ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; if ( totalCount . incrementAndGet ( ) == 3 ) { testComplete ( ) ; } } ; eb . < String > consumer ( ADDRESS1 ) . handler ( handler ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( handler ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( handler ) ; eb . send ( ADDRESS1 , str ) ; eb . send ( ADDRESS1 , str ) ; eb . send ( ADDRESS1 , str ) ; await ( ) ; } @ Test public void testSendWithNoHandler ( ) { eb . send ( ADDRESS1 , TestUtils . randomUnicodeString ( 100 ) ) ; vertx . setTimer ( 1000 , id - > testComplete ( ) ) ; await ( ) ; } @ Test public void testSendMultipleAddresses ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; AtomicInteger cnt = new AtomicInteger ( ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { fail ( "Should not receive message" ) ; } ) ; eb . < String > consumer ( ADDRESS2 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; if ( cnt . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ) ; eb . send ( ADDRESS2 , str ) ; eb . send ( ADDRESS2 , str ) ; await ( ) ; } @ Test public void testSendWithTimeoutNoTimeoutNoReply ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; testComplete ( ) ; } ) ; long timeout = 1000 ; eb . send ( ADDRESS1 , str , new DeliveryOptions ( ) . setSendTimeout ( timeout ) , ar - > { } ) ; await ( ) ; } @ Test public void testSendWithReply ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; String reply = TestUtils . randomUnicodeString ( 1000 ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; msg . reply ( reply ) ; } ) ; eb . send ( ADDRESS1 , str , onSuccess ( ( Message < String > msg ) - > { assertEquals ( reply , msg . body ( ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testReplyToReply ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; String reply = TestUtils . randomUnicodeString ( 1000 ) ; String replyReply = TestUtils . randomUnicodeString ( 1000 ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; msg . reply ( reply , onSuccess ( ( Message < String > rep ) - > { assertEquals ( replyReply , rep . body ( ) ) ; testComplete ( ) ; } ) ) ; } ) ; eb . send ( ADDRESS1 , str , onSuccess ( ( Message < String > msg ) - > { assertEquals ( reply , msg . body ( ) ) ; msg . reply ( replyReply ) ; } ) ) ; await ( ) ; } @ Test public void testSendReplyWithTimeout ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; String reply = TestUtils . randomUnicodeString ( 1000 ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; long start = System . currentTimeMillis ( ) ; long timeout = 1000 ; msg . reply ( reply , new DeliveryOptions ( ) . setSendTimeout ( timeout ) , ar - > { long now = System . currentTimeMillis ( ) ; assertFalse ( ar . succeeded ( ) ) ; Throwable cause = ar . cause ( ) ; assertTrue ( cause instanceof ReplyException ) ; ReplyException re = ( ReplyException ) cause ; assertEquals ( - 1 , re . failureCode ( ) ) ; assertEquals ( ReplyFailure . TIMEOUT , re . failureType ( ) ) ; assertTrue ( now - start >= timeout ) ; testComplete ( ) ; } ) ; } ) ; eb . send ( ADDRESS1 , str , onSuccess ( ( Message < String > msg ) - > { assertEquals ( reply , msg . body ( ) ) ; } ) ) ; await ( ) ; } @ Test public void testSendReplyWithTimeoutNoTimeout ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; String reply = TestUtils . randomUnicodeString ( 1000 ) ; String replyReply = TestUtils . randomUnicodeString ( 1000 ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; long timeout = 1000 ; msg . reply ( reply , new DeliveryOptions ( ) . setSendTimeout ( timeout ) , ar - > { assertTrue ( ar . succeeded ( ) ) ; assertEquals ( replyReply , ar . result ( ) . body ( ) ) ; testComplete ( ) ; } ) ; } ) ; eb . send ( ADDRESS1 , str , onSuccess ( ( Message < String > msg ) - > { assertEquals ( reply , msg . body ( ) ) ; msg . reply ( replyReply ) ; } ) ) ; await ( ) ; } @ Test public void testSendWithTimeoutNoTimeoutReply ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; msg . reply ( 23 ) ; } ) ; long timeout = 1000 ; eb . send ( ADDRESS1 , str , new DeliveryOptions ( ) . setSendTimeout ( timeout ) , ( AsyncResult < Message < Integer > > ar ) - > { assertTrue ( ar . succeeded ( ) ) ; assertEquals ( 23 , ( int ) ar . result ( ) . body ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testSendWithTimeoutNoReply ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; } ) ; long timeout = 1000 ; long start = System . currentTimeMillis ( ) ; eb . send ( ADDRESS1 , str , new DeliveryOptions ( ) . setSendTimeout ( timeout ) , ( AsyncResult < Message < Integer > > ar ) - > { long now = System . currentTimeMillis ( ) ; assertFalse ( ar . succeeded ( ) ) ; Throwable cause = ar . cause ( ) ; assertTrue ( cause instanceof ReplyException ) ; ReplyException re = ( ReplyException ) cause ; assertEquals ( - 1 , re . failureCode ( ) ) ; assertEquals ( ReplyFailure . TIMEOUT , re . failureType ( ) ) ; assertTrue ( now - start >= timeout ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testSendWithTimeoutNoHandlers ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; long timeout = 1000 ; eb . send ( ADDRESS1 , str , new DeliveryOptions ( ) . setSendTimeout ( timeout ) , ( AsyncResult < Message < Integer > > ar ) - > { assertFalse ( ar . succeeded ( ) ) ; Throwable cause = ar . cause ( ) ; assertTrue ( cause instanceof ReplyException ) ; ReplyException re = ( ReplyException ) cause ; assertEquals ( - 1 , re . failureCode ( ) ) ; assertEquals ( ReplyFailure . NO_HANDLERS , re . failureType ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testSendWithTimeoutRecipientFailure ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; String failureMsg = TestUtils . randomUnicodeString ( 1000 ) ; int failureCode = 123 ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; msg . fail ( failureCode , failureMsg ) ; } ) ; long timeout = 1000 ; eb . send ( ADDRESS1 , str , new DeliveryOptions ( ) . setSendTimeout ( timeout ) , ( AsyncResult < Message < Integer > > ar ) - > { assertFalse ( ar . succeeded ( ) ) ; Throwable cause = ar . cause ( ) ; assertTrue ( cause instanceof ReplyException ) ; ReplyException re = ( ReplyException ) cause ; assertEquals ( failureCode , re . failureCode ( ) ) ; assertEquals ( failureMsg , re . getMessage ( ) ) ; assertEquals ( ReplyFailure . RECIPIENT_FAILURE , re . failureType ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testSendWithTimeoutReplyAfterTimeout ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; long timeout = 1000 ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; vertx . setTimer ( ( int ) ( timeout * 1.5 ) , id - > { msg . reply ( "too late!" ) ; } ) ; } ) ; eb . send ( ADDRESS1 , str , new DeliveryOptions ( ) . setSendTimeout ( timeout ) , ( AsyncResult < Message < Integer > > ar ) - > { assertFalse ( ar . succeeded ( ) ) ; Throwable cause = ar . cause ( ) ; assertTrue ( cause instanceof ReplyException ) ; ReplyException re = ( ReplyException ) cause ; assertEquals ( - 1 , re . failureCode ( ) ) ; assertEquals ( ReplyFailure . TIMEOUT , re . failureType ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testSendWithTimeoutNoTimeoutAfterReply ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; long timeout = 1000 ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; msg . reply ( "a reply" ) ; } ) ; AtomicBoolean received = new AtomicBoolean ( ) ; eb . send ( ADDRESS1 , str , new DeliveryOptions ( ) . setSendTimeout ( timeout ) , ( AsyncResult < Message < Integer > > ar ) - > { assertTrue ( ar . succeeded ( ) ) ; assertFalse ( received . get ( ) ) ; received . set ( true ) ; vertx . setTimer ( timeout * 2 , tid - > { testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testReplyToSendWithNoReplyHandler ( ) { eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { msg . reply ( "a reply" ) ; testComplete ( ) ; } ) ; eb . send ( ADDRESS1 , "whatever" ) ; await ( ) ; } @ Test public void testReplyToPublish ( ) { eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { msg . reply ( "a reply" ) ; testComplete ( ) ; } ) ; eb . publish ( ADDRESS1 , "whatever" ) ; await ( ) ; } @ Test public void testFailAfterSend ( ) { eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { msg . fail ( 0 , "a failure" ) ; testComplete ( ) ; } ) ; eb . publish ( ADDRESS1 , "whatever" ) ; await ( ) ; } @ Test public void testFailAfterPublish ( ) { eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { msg . fail ( 0 , "a failure" ) ; testComplete ( ) ; } ) ; eb . publish ( ADDRESS1 , "whatever" ) ; await ( ) ; } @ Test public void testPublish ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; testComplete ( ) ; } ) ; eb . publish ( ADDRESS1 , str ) ; await ( ) ; } @ Test public void testPublishMultipleHandlers ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; AtomicInteger count = new AtomicInteger ( ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; if ( count . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; if ( count . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ) ; eb . publish ( ADDRESS1 , str ) ; await ( ) ; } @ Test public void testPublishSameHandlerRegisteredTwice ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; AtomicInteger count = new AtomicInteger ( ) ; Handler < Message < String > > handler = ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; if ( count . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ; eb . < String > consumer ( ADDRESS1 ) . handler ( handler ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( handler ) ; eb . publish ( ADDRESS1 , str ) ; await ( ) ; } @ Test public void testPublishMultipleHandlersUnregisterOne ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; Handler < Message < String > > handler1 = ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; testComplete ( ) ; } ; Handler < Message < String > > handler2 = ( Message < String > msg ) - > { fail ( "Should not be called" ) ; } ; eb . < String > consumer ( ADDRESS1 ) . handler ( handler1 ) ; MessageConsumer reg = eb . < String > consumer ( ADDRESS1 ) . handler ( handler2 ) ; reg . unregister ( ) ; eb . publish ( ADDRESS1 , str ) ; await ( ) ; } @ Test public void testPublishMultipleHandlersDifferentAddresses ( ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; eb . < String > consumer ( ADDRESS1 ) . handler ( ( Message < String > msg ) - > { assertEquals ( str , msg . body ( ) ) ; testComplete ( ) ; } ) ; eb . < String > consumer ( ADDRESS2 ) . handler ( ( Message < String > msg ) - > { fail ( "Should not receive message" ) ; } ) ; eb . publish ( ADDRESS1 , str ) ; await ( ) ; } @ Test public void testNonRegisteredCodecType ( ) { class Boom { } eb . consumer ( "foo" ) . handler ( msg - > { fail ( "Should not have gotten here" ) ; } ) ; try { eb . send ( "foo" , new Boom ( ) ) ; } catch ( IllegalArgumentException e ) { testComplete ( ) ; } await ( ) ; } @ Test public void testCloseEventBus ( ) { eb . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testInVerticle ( ) throws Exception { testInVerticle ( false , false ) ; } @ Test public void testInWorkerVerticle ( ) throws Exception { testInVerticle ( true , false ) ; } @ Test public void testInMultithreadedWorkerVerticle ( ) throws Exception { testInVerticle ( true , true ) ; } private void testInVerticle ( boolean worker , boolean multiThreaded ) throws Exception { class MyVerticle extends AbstractVerticle { Context ctx ; @ Override public void start ( ) { ctx = context ; if ( worker ) { if ( multiThreaded ) { assertTrue ( ctx instanceof MultiThreadedWorkerContext ) ; } else { assertTrue ( ctx instanceof WorkerContext && ! ( ctx instanceof MultiThreadedWorkerContext ) ) ; } } else { assertTrue ( ctx instanceof EventLoopContext ) ; } Thread thr = Thread . currentThread ( ) ; MessageConsumer < ? > reg = vertx . eventBus ( ) . consumer ( ADDRESS1 ) . handler ( msg - > { assertSame ( ctx , context ) ; if ( ! worker ) { assertSame ( thr , Thread . currentThread ( ) ) ; } msg . reply ( "bar" ) ; } ) ; reg . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; assertSame ( ctx , context ) ; if ( ! worker ) { assertSame ( thr , Thread . currentThread ( ) ) ; } vertx . eventBus ( ) . send ( ADDRESS1 , "foo" , onSuccess ( ( Message < Object > reply ) - > { assertSame ( ctx , context ) ; if ( ! worker ) { assertSame ( thr , Thread . currentThread ( ) ) ; } assertEquals ( "bar" , reply . body ( ) ) ; testComplete ( ) ; } ) ) ; } ) ; } } MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setWorker ( worker ) . setMultiThreaded ( multiThreaded ) ) ; await ( ) ; } @ Test public void testContextsSend ( ) throws Exception { Set < ContextImpl > contexts = new ConcurrentHashSet < > ( ) ; CountDownLatch latch = new CountDownLatch ( 2 ) ; vertx . eventBus ( ) . consumer ( ADDRESS1 ) . handler ( msg - > { msg . reply ( "bar" ) ; contexts . add ( ( ( VertxInternal ) vertx ) . getContext ( ) ) ; latch . countDown ( ) ; } ) ; vertx . eventBus ( ) . send ( ADDRESS1 , "foo" , onSuccess ( ( Message < Object > reply ) - > { assertEquals ( "bar" , reply . body ( ) ) ; contexts . add ( ( ( VertxInternal ) vertx ) . getContext ( ) ) ; latch . countDown ( ) ; } ) ) ; awaitLatch ( latch ) ; assertEquals ( 2 , contexts . size ( ) ) ; } @ Test public void testContextsPublish ( ) throws Exception { Set < ContextImpl > contexts = new ConcurrentHashSet < > ( ) ; AtomicInteger cnt = new AtomicInteger ( ) ; int numHandlers = 10 ; for ( int i = 0 ; i < numHandlers ; i ++ ) { vertx . eventBus ( ) . consumer ( ADDRESS1 ) . handler ( msg - > { contexts . add ( ( ( VertxInternal ) vertx ) . getContext ( ) ) ; if ( cnt . incrementAndGet ( ) == numHandlers ) { assertEquals ( numHandlers , contexts . size ( ) ) ; testComplete ( ) ; } } ) ; } vertx . eventBus ( ) . publish ( ADDRESS1 , "foo" ) ; await ( ) ; } @ Test public void testHeadersCopiedAfterSend ( ) throws Exception { MultiMap headers = new CaseInsensitiveHeaders ( ) ; headers . add ( "foo" , "bar" ) ; vertx . eventBus ( ) . consumer ( ADDRESS1 ) . handler ( msg - > { assertNotSame ( headers , msg . headers ( ) ) ; assertEquals ( "bar" , msg . headers ( ) . get ( "foo" ) ) ; testComplete ( ) ; } ) ; vertx . eventBus ( ) . send ( ADDRESS1 , "foo" , new DeliveryOptions ( ) . setHeaders ( headers ) ) ; headers . remove ( "foo" ) ; await ( ) ; } @ Test public void testDecoderSendAsymmetric ( ) throws Exception { MessageCodec codec = new MyPOJOEncoder1 ( ) ; vertx . eventBus ( ) . registerCodec ( codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; testSend ( new MyPOJO ( str ) , str , null , new DeliveryOptions ( ) . setCodecName ( codec . name ( ) ) ) ; } @ Test public void testDecoderReplyAsymmetric ( ) throws Exception { MessageCodec codec = new MyPOJOEncoder1 ( ) ; vertx . eventBus ( ) . registerCodec ( codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; testReply ( new MyPOJO ( str ) , str , null , new DeliveryOptions ( ) . setCodecName ( codec . name ( ) ) ) ; } @ Test public void testDecoderSendSymmetric ( ) throws Exception { MessageCodec codec = new MyPOJOEncoder2 ( ) ; vertx . eventBus ( ) . registerCodec ( codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; MyPOJO pojo = new MyPOJO ( str ) ; testSend ( pojo , pojo , null , new DeliveryOptions ( ) . setCodecName ( codec . name ( ) ) ) ; } @ Test public void testDecoderReplySymmetric ( ) throws Exception { MessageCodec codec = new MyPOJOEncoder2 ( ) ; vertx . eventBus ( ) . registerCodec ( codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; MyPOJO pojo = new MyPOJO ( str ) ; testReply ( pojo , pojo , null , new DeliveryOptions ( ) . setCodecName ( codec . name ( ) ) ) ; } @ Test public void testNoRegisteredDecoder ( ) throws Exception { try { vertx . eventBus ( ) . send ( ADDRESS1 , "foo" , new DeliveryOptions ( ) . setCodecName ( "iqwjdoqiwd" ) ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } } @ Test public void testRegisterSystemDecoder ( ) throws Exception { try { vertx . eventBus ( ) . registerCodec ( new MySystemDecoder ( ) ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } } @ Test public void testUnregisterDecoder ( ) throws Exception { MessageCodec codec = new MyPOJOEncoder1 ( ) ; vertx . eventBus ( ) . registerCodec ( codec ) ; vertx . eventBus ( ) . unregisterCodec ( codec . name ( ) ) ; try { vertx . eventBus ( ) . send ( ADDRESS1 , new MyPOJO ( "foo" ) , new DeliveryOptions ( ) . setCodecName ( codec . name ( ) ) ) ; fail ( "Should throw exception" ) ; } catch ( IllegalArgumentException e ) { } } @ Test public void testRegisterTwice ( ) throws Exception { MessageCodec codec = new MyPOJOEncoder1 ( ) ; vertx . eventBus ( ) . registerCodec ( codec ) ; try { vertx . eventBus ( ) . registerCodec ( codec ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { } } @ Test public void testCodecNullName ( ) throws Exception { try { vertx . eventBus ( ) . registerCodec ( new NullNameCodec ( ) ) ; fail ( "Should throw exception" ) ; } catch ( NullPointerException e ) { } } @ Test public void testDefaultDecoderSendAsymmetric ( ) throws Exception { MessageCodec codec = new MyPOJOEncoder1 ( ) ; vertx . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; testSend ( new MyPOJO ( str ) , str , null , null ) ; } @ Test public void testDefaultDecoderReplyAsymmetric ( ) throws Exception { MessageCodec codec = new MyPOJOEncoder1 ( ) ; vertx . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; testReply ( new MyPOJO ( str ) , str , null , null ) ; } @ Test public void testDefaultDecoderSendSymetric ( ) throws Exception { MessageCodec codec = new MyPOJOEncoder2 ( ) ; vertx . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; MyPOJO pojo = new MyPOJO ( str ) ; testSend ( pojo , pojo , null , null ) ; } @ Test public void testDefaultDecoderReplySymetric ( ) throws Exception { MessageCodec codec = new MyPOJOEncoder2 ( ) ; vertx . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; String str = TestUtils . randomAlphaString ( 100 ) ; MyPOJO pojo = new MyPOJO ( str ) ; testReply ( pojo , pojo , null , null ) ; } @ Test public void testNoRegisteredDefaultDecoder ( ) throws Exception { assertIllegalArgumentException ( ( ) - > vertx . eventBus ( ) . send ( ADDRESS1 , new MyPOJO ( "foo" ) ) ) ; } @ Test public void testRegisterDefaultSystemDecoder ( ) throws Exception { assertIllegalArgumentException ( ( ) - > vertx . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , new MySystemDecoder ( ) ) ) ; } @ Test public void testUnregisterDefaultDecoder ( ) throws Exception { MessageCodec codec = new MyPOJOEncoder1 ( ) ; vertx . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; vertx . eventBus ( ) . unregisterDefaultCodec ( MyPOJO . class ) ; assertIllegalArgumentException ( ( ) - > vertx . eventBus ( ) . send ( ADDRESS1 , new MyPOJO ( "foo" ) ) ) ; } @ Test public void testRegisterDefaultTwice ( ) throws Exception { MessageCodec codec = new MyPOJOEncoder1 ( ) ; vertx . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ; assertIllegalStateException ( ( ) - > vertx . eventBus ( ) . registerDefaultCodec ( MyPOJO . class , codec ) ) ; } @ Test public void testDefaultCodecNullName ( ) throws Exception { assertNullPointerException ( ( ) - > vertx . eventBus ( ) . registerDefaultCodec ( String . class , new NullNameCodec ( ) ) ) ; } @ Override protected < T , R > void testSend ( T val , R received , Consumer < T > consumer , DeliveryOptions options ) { eb . < T > consumer ( ADDRESS1 ) . handler ( ( Message < T > msg ) - > { if ( consumer == null ) { assertEquals ( received , msg . body ( ) ) ; if ( options != null && options . getHeaders ( ) != null ) { assertNotNull ( msg . headers ( ) ) ; assertEquals ( options . getHeaders ( ) . size ( ) , msg . headers ( ) . size ( ) ) ; for ( Map . Entry < String , String > entry : options . getHeaders ( ) . entries ( ) ) { assertEquals ( msg . headers ( ) . get ( entry . getKey ( ) ) , entry . getValue ( ) ) ; } } } else { consumer . accept ( msg . body ( ) ) ; } testComplete ( ) ; } ) ; if ( options != null ) { eb . send ( ADDRESS1 , val , options ) ; } else { eb . send ( ADDRESS1 , val ) ; } await ( ) ; } @ Override protected < T > void testSend ( T val , Consumer < T > consumer ) { testSend ( val , val , consumer , null ) ; } @ Override protected < T > void testReply ( T val , Consumer < T > consumer ) { testReply ( val , val , consumer , null ) ; } @ Override protected < T , R > void testReply ( T val , R received , Consumer < R > consumer , DeliveryOptions options ) { String str = TestUtils . randomUnicodeString ( 1000 ) ; eb . consumer ( ADDRESS1 ) . handler ( msg - > { assertEquals ( str , msg . body ( ) ) ; if ( options != null ) { msg . reply ( val , options ) ; } else { msg . reply ( val ) ; } } ) ; eb . send ( ADDRESS1 , str , onSuccess ( ( Message < R > reply ) - > { if ( consumer == null ) { assertEquals ( received , reply . body ( ) ) ; if ( options != null && options . getHeaders ( ) != null ) { assertNotNull ( reply . headers ( ) ) ; assertEquals ( options . getHeaders ( ) . size ( ) , reply . headers ( ) . size ( ) ) ; for ( Map . Entry < String , String > entry : options . getHeaders ( ) . entries ( ) ) { assertEquals ( reply . headers ( ) . get ( entry . getKey ( ) ) , entry . getValue ( ) ) ; } } } else { consumer . accept ( reply . body ( ) ) ; } testComplete ( ) ; } ) ) ; await ( ) ; } @ Override protected < T > void testPublish ( T val , Consumer < T > consumer ) { AtomicInteger count = new AtomicInteger ( ) ; class MyHandler implements Handler < Message < T > > { @ Override public void handle ( Message < T > msg ) { if ( consumer == null ) { assertEquals ( val , msg . body ( ) ) ; } else { consumer . accept ( msg . body ( ) ) ; } if ( count . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } } eb . < T > consumer ( ADDRESS1 ) . handler ( new MyHandler ( ) ) ; eb . < T > consumer ( ADDRESS1 ) . handler ( new MyHandler ( ) ) ; eb . publish ( ADDRESS1 , val ) ; await ( ) ; } @ Test public void testPauseResumeMessageStream ( ) { testPauseResume ( ( consumer , handler ) - > consumer . handler ( message - > handler . handle ( message . body ( ) ) ) ) ; } @ Test public void testPauseResumeBodyStream ( ) { testPauseResume ( ( consumer , handler ) - > consumer . bodyStream ( ) . handler ( handler ) ) ; } private void testPauseResume ( BiFunction < MessageConsumer < String > , Handler < String > , ReadStream < ? > > register ) { String [ ] data = new String [ 11 ] ; for ( int i = 0 ; i < data . length ; i ++ ) { data [ i ] = TestUtils . randomAlphaString ( 10 ) ; } Set < String > expected = new HashSet < > ( ) ; Handler < String > handler = body - > { assertTrue ( "Was expecting " + expected + " to contain " + body , expected . remove ( body ) ) ; if ( expected . isEmpty ( ) ) { testComplete ( ) ; } } ; MessageConsumer < String > reg = eb . < String > consumer ( ADDRESS1 ) . setMaxBufferedMessages ( 10 ) ; ReadStream < ? > controller = register . apply ( reg , handler ) ; ( ( EventBusImpl . HandlerRegistration < String > ) reg ) . discardHandler ( msg - > { assertEquals ( data [ 10 ] , msg . body ( ) ) ; expected . addAll ( Arrays . asList ( data ) . subList ( 0 , 10 ) ) ; controller . resume ( ) ; } ) ; controller . pause ( ) ; for ( String msg : data ) { eb . publish ( ADDRESS1 , msg ) ; } await ( ) ; } @ Test public void testExceptionWhenDeliveringBufferedMessageWithMessageStream ( ) { testExceptionWhenDeliveringBufferedMessage ( ( consumer , handler ) - > consumer . handler ( message - > handler . handle ( message . body ( ) ) ) ) ; } @ Test public void testExceptionWhenDeliveringBufferedMessageWithBodyStream ( ) { testExceptionWhenDeliveringBufferedMessage ( ( consumer , handler ) - > consumer . bodyStream ( ) . handler ( handler ) ) ; } private void testExceptionWhenDeliveringBufferedMessage ( BiFunction < MessageConsumer < String > , Handler < String > , ReadStream < ? > > register ) { String [ ] data = new String [ 11 ] ; for ( int i = 0 ; i < data . length ; i ++ ) { data [ i ] = TestUtils . randomAlphaString ( 10 ) ; } Set < String > expected = new HashSet < > ( ) ; Handler < String > handler = body - > { assertTrue ( "Was expecting " + expected + " to contain " + body , expected . remove ( body ) ) ; if ( expected . isEmpty ( ) ) { testComplete ( ) ; } else { throw new RuntimeException ( ) ; } } ; MessageConsumer < String > reg = eb . < String > consumer ( ADDRESS1 ) . setMaxBufferedMessages ( 10 ) ; ReadStream < ? > controller = register . apply ( reg , handler ) ; ( ( EventBusImpl . HandlerRegistration < String > ) reg ) . discardHandler ( msg - > { assertEquals ( data [ 10 ] , msg . body ( ) ) ; expected . addAll ( Arrays . asList ( data ) . subList ( 0 , 10 ) ) ; controller . resume ( ) ; } ) ; controller . pause ( ) ; for ( String msg : data ) { eb . publish ( ADDRESS1 , msg ) ; } await ( ) ; } @ Test public void testUnregisterationOfRegisteredConsumerCallsEndHandlerWithMessageStream ( ) { MessageConsumer < String > consumer = eb . consumer ( ADDRESS1 ) ; testUnregisterationOfRegisteredConsumerCallsEndHandler ( consumer , consumer ) ; } @ Test public void testUnregisterationOfRegisteredConsumerCallsEndHandlerWithBodyStream ( ) { MessageConsumer < String > consumer = eb . consumer ( ADDRESS1 ) ; testUnregisterationOfRegisteredConsumerCallsEndHandler ( consumer , consumer . bodyStream ( ) ) ; } private void testUnregisterationOfRegisteredConsumerCallsEndHandler ( MessageConsumer < String > consumer , ReadStream < ? > readStream ) { consumer . handler ( msg - > { } ) ; consumer . endHandler ( v - > { fail ( ) ; } ) ; consumer . unregister ( ) ; vertx . runOnContext ( d - > { testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testUnregisterThenUnsetEndHandler ( ) { MessageConsumer < String > consumer = eb . consumer ( ADDRESS1 ) ; consumer . endHandler ( v - > { } ) ; consumer . unregister ( res - > { testComplete ( ) ; } ) ; consumer . endHandler ( null ) ; await ( ) ; } @ Test public void testUnregistrationWhenSettingNullHandlerWithConsumer ( ) { MessageConsumer < String > consumer = eb . consumer ( ADDRESS1 ) ; testUnregistrationWhenSettingNullHandler ( consumer , consumer ) ; } @ Test public void testUnregistrationWhenSettingNullHandlerWithBodyStream ( ) { MessageConsumer < String > consumer = eb . consumer ( ADDRESS1 ) ; testUnregistrationWhenSettingNullHandler ( consumer , consumer . bodyStream ( ) ) ; } private void testUnregistrationWhenSettingNullHandler ( MessageConsumer < String > consumer , ReadStream < ? > readStream ) { readStream . handler ( msg - > { } ) ; assertTrue ( consumer . isRegistered ( ) ) ; readStream . handler ( null ) ; assertFalse ( consumer . isRegistered ( ) ) ; } @ Test public void testSender ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; WriteStream < String > sender = eb . sender ( ADDRESS1 ) ; eb . consumer ( ADDRESS1 ) . handler ( message - > { if ( message . body ( ) . equals ( str ) ) { testComplete ( ) ; } } ) ; sender . write ( str ) ; await ( ) ; } @ Test public void testSenderWithOptions ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; WriteStream < String > sender = eb . sender ( ADDRESS1 , new DeliveryOptions ( ) . addHeader ( "foo" , "foo_value" ) ) ; eb . consumer ( ADDRESS1 ) . handler ( message - > { if ( message . body ( ) . equals ( str ) && "foo_value" . equals ( message . headers ( ) . get ( "foo" ) ) ) { testComplete ( ) ; } } ) ; sender . write ( str ) ; await ( ) ; } @ Test public void testPublisher ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; MessageProducer < String > publisher = eb . publisher ( ADDRESS1 ) ; assertEquals ( ADDRESS1 , publisher . address ( ) ) ; AtomicInteger count = new AtomicInteger ( ) ; int n = 2 ; for ( int i = 0 ; i < n ; i ++ ) { eb . consumer ( ADDRESS1 ) . handler ( message - > { if ( message . body ( ) . equals ( str ) && count . incrementAndGet ( ) == n ) { testComplete ( ) ; } } ) ; } publisher . write ( str ) ; await ( ) ; } @ Test public void testPublisherWithOptions ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; MessageProducer < String > publisher = eb . publisher ( ADDRESS1 , new DeliveryOptions ( ) . addHeader ( "foo" , "foo_value" ) ) ; assertEquals ( ADDRESS1 , publisher . address ( ) ) ; AtomicInteger count = new AtomicInteger ( ) ; int n = 2 ; for ( int i = 0 ; i < n ; i ++ ) { eb . consumer ( ADDRESS1 ) . handler ( message - > { if ( message . body ( ) . equals ( str ) && "foo_value" . equals ( message . headers ( ) . get ( "foo" ) ) && count . incrementAndGet ( ) == n ) { testComplete ( ) ; } } ) ; } publisher . write ( str ) ; await ( ) ; } @ Test public void testPump ( ) { String str = TestUtils . randomUnicodeString ( 100 ) ; ReadStream < String > consumer = eb . < String > consumer ( ADDRESS1 ) . bodyStream ( ) ; consumer . handler ( message - > { if ( message . equals ( str ) ) { testComplete ( ) ; } } ) ; MessageProducer < String > producer = eb . sender ( ADDRESS2 ) ; Pump . pump ( consumer , producer ) ; producer . write ( str ) ; } @ Test public void testConsumerHandlesCompletionAsynchronously ( ) { MessageConsumer < Object > consumer = eb . consumer ( ADDRESS1 ) ; ThreadLocal < Object > stack = new ThreadLocal < > ( ) ; stack . set ( true ) ; consumer . completionHandler ( v - > { assertNull ( stack . get ( ) ) ; assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; testComplete ( ) ; } ) ; consumer . handler ( msg - > { } ) ; await ( ) ; } @ Test public void testConsumerHandlesCompletionAsynchronously2 ( ) { MessageConsumer < Object > consumer = eb . consumer ( ADDRESS1 ) ; consumer . handler ( msg - > { } ) ; ThreadLocal < Object > stack = new ThreadLocal < > ( ) ; stack . set ( true ) ; consumer . completionHandler ( v - > { assertNull ( stack . get ( ) ) ; assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testUpdateDeliveryOptionsOnProducer ( ) { MessageProducer < String > producer = eb . sender ( ADDRESS1 ) ; MessageConsumer < String > consumer = eb . < String > consumer ( ADDRESS1 ) ; consumer . completionHandler ( v - > { assertTrue ( v . succeeded ( ) ) ; producer . write ( "no-header" ) ; } ) ; consumer . handler ( msg - > { switch ( msg . body ( ) ) { case "no-header" : assertNull ( msg . headers ( ) . get ( "header-name" ) ) ; producer . deliveryOptions ( new DeliveryOptions ( ) . addHeader ( "header-name" , "header-value" ) ) ; producer . write ( "with-header" ) ; break ; case "with-header" : assertEquals ( "header-value" , msg . headers ( ) . get ( "header-name" ) ) ; testComplete ( ) ; break ; default : fail ( ) ; } } ) ; await ( ) ; } @ Test public void testCloseCallsEndHandlerWithRegistrationContext ( ) throws Exception { Context ctx = vertx . getOrCreateContext ( ) ; CountDownLatch registered = new CountDownLatch ( 1 ) ; ctx . runOnContext ( v1 - > { MessageConsumer < String > consumer = eb . consumer ( ADDRESS1 ) ; consumer . endHandler ( v2 - > { assertSame ( Vertx . currentContext ( ) , ctx ) ; testComplete ( ) ; } ) ; consumer . handler ( msg - > { } ) ; consumer . completionHandler ( ar - > { assertTrue ( ar . succeeded ( ) ) ; registered . countDown ( ) ; } ) ; } ) ; awaitLatch ( registered ) ; closeVertx ( ) ; await ( ) ; } }
package io . vertx . test . core ; import io . netty . handler . codec . http . DefaultHttpHeaders ; import io . netty . handler . codec . http . HttpResponseStatus ; import io . vertx . core . * ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . eventbus . Message ; import io . vertx . core . eventbus . MessageConsumer ; import io . vertx . core . http . * ; import io . vertx . core . http . impl . HeadersAdaptor ; import io . vertx . core . impl . * ; import io . vertx . core . json . JsonArray ; import io . vertx . core . json . JsonObject ; import io . vertx . core . net . * ; import io . vertx . core . net . impl . SocketDefaults ; import io . vertx . core . streams . Pump ; import org . junit . Assume ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; import java . io . * ; import java . net . URLEncoder ; import java . nio . file . Files ; import java . nio . file . NoSuchFileException ; import java . nio . file . Path ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import java . util . function . Consumer ; import static io . vertx . test . core . TestUtils . * ; public class HttpTest extends HttpTestBase { @ Rule public TemporaryFolder testFolder = new TemporaryFolder ( ) ; private File testDir ; @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; testDir = testFolder . newFolder ( ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( DEFAULT_HTTP_PORT ) . setHost ( DEFAULT_HTTP_HOST ) . setHandle100ContinueAutomatically ( true ) ) ; client = vertx . createHttpClient ( new HttpClientOptions ( ) ) ; } @ Test public void testClientOptions ( ) { HttpClientOptions options = new HttpClientOptions ( ) ; assertEquals ( NetworkOptions . DEFAULT_SEND_BUFFER_SIZE , options . getSendBufferSize ( ) ) ; int rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setSendBufferSize ( rand ) ) ; assertEquals ( rand , options . getSendBufferSize ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setSendBufferSize ( 0 ) ) ; assertIllegalArgumentException ( ( ) - > options . setSendBufferSize ( - 123 ) ) ; assertEquals ( NetworkOptions . DEFAULT_RECEIVE_BUFFER_SIZE , options . getReceiveBufferSize ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setReceiveBufferSize ( rand ) ) ; assertEquals ( rand , options . getReceiveBufferSize ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setReceiveBufferSize ( 0 ) ) ; assertIllegalArgumentException ( ( ) - > options . setReceiveBufferSize ( - 123 ) ) ; assertTrue ( options . isReuseAddress ( ) ) ; assertEquals ( options , options . setReuseAddress ( false ) ) ; assertFalse ( options . isReuseAddress ( ) ) ; assertEquals ( NetworkOptions . DEFAULT_TRAFFIC_CLASS , options . getTrafficClass ( ) ) ; rand = 23 ; assertEquals ( options , options . setTrafficClass ( rand ) ) ; assertEquals ( rand , options . getTrafficClass ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setTrafficClass ( - 1 ) ) ; assertIllegalArgumentException ( ( ) - > options . setTrafficClass ( 256 ) ) ; assertTrue ( options . isTcpNoDelay ( ) ) ; assertEquals ( options , options . setTcpNoDelay ( false ) ) ; assertFalse ( options . isTcpNoDelay ( ) ) ; boolean tcpKeepAlive = SocketDefaults . instance . isTcpKeepAlive ( ) ; assertEquals ( tcpKeepAlive , options . isTcpKeepAlive ( ) ) ; assertEquals ( options , options . setTcpKeepAlive ( ! tcpKeepAlive ) ) ; assertEquals ( ! tcpKeepAlive , options . isTcpKeepAlive ( ) ) ; int soLinger = SocketDefaults . instance . getSoLinger ( ) ; assertEquals ( soLinger , options . getSoLinger ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setSoLinger ( rand ) ) ; assertEquals ( rand , options . getSoLinger ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setSoLinger ( - 1 ) ) ; assertFalse ( options . isUsePooledBuffers ( ) ) ; assertEquals ( options , options . setUsePooledBuffers ( true ) ) ; assertTrue ( options . isUsePooledBuffers ( ) ) ; assertEquals ( 0 , options . getIdleTimeout ( ) ) ; assertEquals ( options , options . setIdleTimeout ( 10 ) ) ; assertEquals ( 10 , options . getIdleTimeout ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setIdleTimeout ( - 1 ) ) ; assertFalse ( options . isSsl ( ) ) ; assertEquals ( options , options . setSsl ( true ) ) ; assertTrue ( options . isSsl ( ) ) ; assertNull ( options . getKeyCertOptions ( ) ) ; JksOptions keyStoreOptions = new JksOptions ( ) . setPath ( TestUtils . randomAlphaString ( 100 ) ) . setPassword ( TestUtils . randomAlphaString ( 100 ) ) ; assertEquals ( options , options . setKeyStoreOptions ( keyStoreOptions ) ) ; assertEquals ( keyStoreOptions , options . getKeyCertOptions ( ) ) ; assertNull ( options . getTrustOptions ( ) ) ; JksOptions trustStoreOptions = new JksOptions ( ) . setPath ( TestUtils . randomAlphaString ( 100 ) ) . setPassword ( TestUtils . randomAlphaString ( 100 ) ) ; assertEquals ( options , options . setTrustStoreOptions ( trustStoreOptions ) ) ; assertEquals ( trustStoreOptions , options . getTrustOptions ( ) ) ; assertFalse ( options . isTrustAll ( ) ) ; assertEquals ( options , options . setTrustAll ( true ) ) ; assertTrue ( options . isTrustAll ( ) ) ; assertTrue ( options . isVerifyHost ( ) ) ; assertEquals ( options , options . setVerifyHost ( false ) ) ; assertFalse ( options . isVerifyHost ( ) ) ; assertEquals ( 5 , options . getMaxPoolSize ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setMaxPoolSize ( rand ) ) ; assertEquals ( rand , options . getMaxPoolSize ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setMaxPoolSize ( 0 ) ) ; assertIllegalArgumentException ( ( ) - > options . setMaxPoolSize ( - 1 ) ) ; assertTrue ( options . isKeepAlive ( ) ) ; assertEquals ( options , options . setKeepAlive ( false ) ) ; assertFalse ( options . isKeepAlive ( ) ) ; assertFalse ( options . isPipelining ( ) ) ; assertEquals ( options , options . setPipelining ( true ) ) ; assertTrue ( options . isPipelining ( ) ) ; assertEquals ( 60000 , options . getConnectTimeout ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setConnectTimeout ( rand ) ) ; assertEquals ( rand , options . getConnectTimeout ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setConnectTimeout ( - 2 ) ) ; assertFalse ( options . isTryUseCompression ( ) ) ; assertEquals ( options , options . setTryUseCompression ( true ) ) ; assertEquals ( true , options . isTryUseCompression ( ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . isEmpty ( ) ) ; assertEquals ( options , options . addEnabledCipherSuite ( "foo" ) ) ; assertEquals ( options , options . addEnabledCipherSuite ( "bar" ) ) ; assertNotNull ( options . getEnabledCipherSuites ( ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . contains ( "foo" ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . contains ( "bar" ) ) ; testComplete ( ) ; } @ Test public void testServerOptions ( ) { HttpServerOptions options = new HttpServerOptions ( ) ; assertEquals ( NetworkOptions . DEFAULT_SEND_BUFFER_SIZE , options . getSendBufferSize ( ) ) ; int rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setSendBufferSize ( rand ) ) ; assertEquals ( rand , options . getSendBufferSize ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setSendBufferSize ( 0 ) ) ; assertIllegalArgumentException ( ( ) - > options . setSendBufferSize ( - 123 ) ) ; assertEquals ( NetworkOptions . DEFAULT_RECEIVE_BUFFER_SIZE , options . getReceiveBufferSize ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setReceiveBufferSize ( rand ) ) ; assertEquals ( rand , options . getReceiveBufferSize ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setReceiveBufferSize ( 0 ) ) ; assertIllegalArgumentException ( ( ) - > options . setReceiveBufferSize ( - 123 ) ) ; assertTrue ( options . isReuseAddress ( ) ) ; assertEquals ( options , options . setReuseAddress ( false ) ) ; assertFalse ( options . isReuseAddress ( ) ) ; assertEquals ( NetworkOptions . DEFAULT_TRAFFIC_CLASS , options . getTrafficClass ( ) ) ; rand = 23 ; assertEquals ( options , options . setTrafficClass ( rand ) ) ; assertEquals ( rand , options . getTrafficClass ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setTrafficClass ( - 1 ) ) ; assertIllegalArgumentException ( ( ) - > options . setTrafficClass ( 256 ) ) ; assertTrue ( options . isTcpNoDelay ( ) ) ; assertEquals ( options , options . setTcpNoDelay ( false ) ) ; assertFalse ( options . isTcpNoDelay ( ) ) ; boolean tcpKeepAlive = SocketDefaults . instance . isTcpKeepAlive ( ) ; assertEquals ( tcpKeepAlive , options . isTcpKeepAlive ( ) ) ; assertEquals ( options , options . setTcpKeepAlive ( ! tcpKeepAlive ) ) ; assertEquals ( ! tcpKeepAlive , options . isTcpKeepAlive ( ) ) ; int soLinger = SocketDefaults . instance . getSoLinger ( ) ; assertEquals ( soLinger , options . getSoLinger ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setSoLinger ( rand ) ) ; assertEquals ( rand , options . getSoLinger ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setSoLinger ( - 1 ) ) ; assertFalse ( options . isUsePooledBuffers ( ) ) ; assertEquals ( options , options . setUsePooledBuffers ( true ) ) ; assertTrue ( options . isUsePooledBuffers ( ) ) ; assertEquals ( 0 , options . getIdleTimeout ( ) ) ; assertEquals ( options , options . setIdleTimeout ( 10 ) ) ; assertEquals ( 10 , options . getIdleTimeout ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setIdleTimeout ( - 1 ) ) ; assertFalse ( options . isSsl ( ) ) ; assertEquals ( options , options . setSsl ( true ) ) ; assertTrue ( options . isSsl ( ) ) ; assertNull ( options . getKeyCertOptions ( ) ) ; JksOptions keyStoreOptions = new JksOptions ( ) . setPath ( TestUtils . randomAlphaString ( 100 ) ) . setPassword ( TestUtils . randomAlphaString ( 100 ) ) ; assertEquals ( options , options . setKeyStoreOptions ( keyStoreOptions ) ) ; assertEquals ( keyStoreOptions , options . getKeyCertOptions ( ) ) ; assertNull ( options . getTrustOptions ( ) ) ; JksOptions trustStoreOptions = new JksOptions ( ) . setPath ( TestUtils . randomAlphaString ( 100 ) ) . setPassword ( TestUtils . randomAlphaString ( 100 ) ) ; assertEquals ( options , options . setTrustStoreOptions ( trustStoreOptions ) ) ; assertEquals ( trustStoreOptions , options . getTrustOptions ( ) ) ; assertEquals ( 1024 , options . getAcceptBacklog ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setAcceptBacklog ( rand ) ) ; assertEquals ( rand , options . getAcceptBacklog ( ) ) ; assertFalse ( options . isCompressionSupported ( ) ) ; assertEquals ( options , options . setCompressionSupported ( true ) ) ; assertTrue ( options . isCompressionSupported ( ) ) ; assertEquals ( 65536 , options . getMaxWebsocketFrameSize ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setMaxWebsocketFrameSize ( rand ) ) ; assertEquals ( rand , options . getMaxWebsocketFrameSize ( ) ) ; assertEquals ( 80 , options . getPort ( ) ) ; assertEquals ( options , options . setPort ( 1234 ) ) ; assertEquals ( 1234 , options . getPort ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setPort ( - 1 ) ) ; assertIllegalArgumentException ( ( ) - > options . setPort ( 65536 ) ) ; assertEquals ( "0.0.0.0" , options . getHost ( ) ) ; String randString = TestUtils . randomUnicodeString ( 100 ) ; assertEquals ( options , options . setHost ( randString ) ) ; assertEquals ( randString , options . getHost ( ) ) ; assertNull ( options . getWebsocketSubProtocols ( ) ) ; assertEquals ( options , options . setWebsocketSubProtocol ( "foo" ) ) ; assertEquals ( "foo" , options . getWebsocketSubProtocols ( ) ) ; HttpServerOptions optionsCopy = new HttpServerOptions ( options ) ; assertEquals ( options , optionsCopy . setWebsocketSubProtocol ( new String ( options . getWebsocketSubProtocols ( ) ) ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . isEmpty ( ) ) ; assertEquals ( options , options . addEnabledCipherSuite ( "foo" ) ) ; assertEquals ( options , options . addEnabledCipherSuite ( "bar" ) ) ; assertNotNull ( options . getEnabledCipherSuites ( ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . contains ( "foo" ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . contains ( "bar" ) ) ; assertFalse ( options . isHandle100ContinueAutomatically ( ) ) ; assertEquals ( options , options . setHandle100ContinueAutomatically ( true ) ) ; assertTrue ( options . isHandle100ContinueAutomatically ( ) ) ; testComplete ( ) ; } @ Test public void testCopyClientOptions ( ) { HttpClientOptions options = new HttpClientOptions ( ) ; int sendBufferSize = TestUtils . randomPositiveInt ( ) ; int receiverBufferSize = TestUtils . randomPortInt ( ) ; Random rand = new Random ( ) ; boolean reuseAddress = rand . nextBoolean ( ) ; int trafficClass = TestUtils . randomByte ( ) + 128 ; boolean tcpNoDelay = rand . nextBoolean ( ) ; boolean tcpKeepAlive = rand . nextBoolean ( ) ; int soLinger = TestUtils . randomPositiveInt ( ) ; boolean usePooledBuffers = rand . nextBoolean ( ) ; int idleTimeout = TestUtils . randomPositiveInt ( ) ; boolean ssl = rand . nextBoolean ( ) ; JksOptions keyStoreOptions = new JksOptions ( ) ; String ksPassword = TestUtils . randomAlphaString ( 100 ) ; keyStoreOptions . setPassword ( ksPassword ) ; JksOptions trustStoreOptions = new JksOptions ( ) ; String tsPassword = TestUtils . randomAlphaString ( 100 ) ; trustStoreOptions . setPassword ( tsPassword ) ; String enabledCipher = TestUtils . randomAlphaString ( 100 ) ; int connectTimeout = TestUtils . randomPositiveInt ( ) ; boolean trustAll = rand . nextBoolean ( ) ; String crlPath = TestUtils . randomUnicodeString ( 100 ) ; Buffer crlValue = TestUtils . randomBuffer ( 100 ) ; boolean verifyHost = rand . nextBoolean ( ) ; int maxPoolSize = TestUtils . randomPositiveInt ( ) ; boolean keepAlive = rand . nextBoolean ( ) ; boolean pipelining = rand . nextBoolean ( ) ; boolean tryUseCompression = rand . nextBoolean ( ) ; options . setSendBufferSize ( sendBufferSize ) ; options . setReceiveBufferSize ( receiverBufferSize ) ; options . setReuseAddress ( reuseAddress ) ; options . setTrafficClass ( trafficClass ) ; options . setSsl ( ssl ) ; options . setTcpNoDelay ( tcpNoDelay ) ; options . setTcpKeepAlive ( tcpKeepAlive ) ; options . setSoLinger ( soLinger ) ; options . setUsePooledBuffers ( usePooledBuffers ) ; options . setIdleTimeout ( idleTimeout ) ; options . setKeyStoreOptions ( keyStoreOptions ) ; options . setTrustStoreOptions ( trustStoreOptions ) ; options . addEnabledCipherSuite ( enabledCipher ) ; options . setConnectTimeout ( connectTimeout ) ; options . setTrustAll ( trustAll ) ; options . addCrlPath ( crlPath ) ; options . addCrlValue ( crlValue ) ; options . setVerifyHost ( verifyHost ) ; options . setMaxPoolSize ( maxPoolSize ) ; options . setKeepAlive ( keepAlive ) ; options . setPipelining ( pipelining ) ; options . setTryUseCompression ( tryUseCompression ) ; HttpClientOptions copy = new HttpClientOptions ( options ) ; assertEquals ( sendBufferSize , copy . getSendBufferSize ( ) ) ; assertEquals ( receiverBufferSize , copy . getReceiveBufferSize ( ) ) ; assertEquals ( reuseAddress , copy . isReuseAddress ( ) ) ; assertEquals ( trafficClass , copy . getTrafficClass ( ) ) ; assertEquals ( tcpNoDelay , copy . isTcpNoDelay ( ) ) ; assertEquals ( tcpKeepAlive , copy . isTcpKeepAlive ( ) ) ; assertEquals ( soLinger , copy . getSoLinger ( ) ) ; assertEquals ( usePooledBuffers , copy . isUsePooledBuffers ( ) ) ; assertEquals ( idleTimeout , copy . getIdleTimeout ( ) ) ; assertEquals ( ssl , copy . isSsl ( ) ) ; assertNotSame ( keyStoreOptions , copy . getKeyCertOptions ( ) ) ; assertEquals ( ksPassword , ( ( JksOptions ) copy . getKeyCertOptions ( ) ) . getPassword ( ) ) ; assertNotSame ( trustStoreOptions , copy . getTrustOptions ( ) ) ; assertEquals ( tsPassword , ( ( JksOptions ) copy . getTrustOptions ( ) ) . getPassword ( ) ) ; assertEquals ( 1 , copy . getEnabledCipherSuites ( ) . size ( ) ) ; assertTrue ( copy . getEnabledCipherSuites ( ) . contains ( enabledCipher ) ) ; assertEquals ( connectTimeout , copy . getConnectTimeout ( ) ) ; assertEquals ( trustAll , copy . isTrustAll ( ) ) ; assertEquals ( 1 , copy . getCrlPaths ( ) . size ( ) ) ; assertEquals ( crlPath , copy . getCrlPaths ( ) . get ( 0 ) ) ; assertEquals ( 1 , copy . getCrlValues ( ) . size ( ) ) ; assertEquals ( crlValue , copy . getCrlValues ( ) . get ( 0 ) ) ; assertEquals ( verifyHost , copy . isVerifyHost ( ) ) ; assertEquals ( maxPoolSize , copy . getMaxPoolSize ( ) ) ; assertEquals ( keepAlive , copy . isKeepAlive ( ) ) ; assertEquals ( pipelining , copy . isPipelining ( ) ) ; assertEquals ( tryUseCompression , copy . isTryUseCompression ( ) ) ; } @ Test public void testDefaultClientOptionsJson ( ) { HttpClientOptions def = new HttpClientOptions ( ) ; HttpClientOptions json = new HttpClientOptions ( new JsonObject ( ) ) ; assertEquals ( def . getMaxPoolSize ( ) , json . getMaxPoolSize ( ) ) ; assertEquals ( def . isKeepAlive ( ) , json . isKeepAlive ( ) ) ; assertEquals ( def . isPipelining ( ) , json . isPipelining ( ) ) ; assertEquals ( def . isVerifyHost ( ) , json . isVerifyHost ( ) ) ; assertEquals ( def . isTryUseCompression ( ) , json . isTryUseCompression ( ) ) ; assertEquals ( def . isTrustAll ( ) , json . isTrustAll ( ) ) ; assertEquals ( def . getCrlPaths ( ) , json . getCrlPaths ( ) ) ; assertEquals ( def . getCrlValues ( ) , json . getCrlValues ( ) ) ; assertEquals ( def . getConnectTimeout ( ) , json . getConnectTimeout ( ) ) ; assertEquals ( def . isTcpNoDelay ( ) , json . isTcpNoDelay ( ) ) ; assertEquals ( def . isTcpKeepAlive ( ) , json . isTcpKeepAlive ( ) ) ; assertEquals ( def . getSoLinger ( ) , json . getSoLinger ( ) ) ; assertEquals ( def . isUsePooledBuffers ( ) , json . isUsePooledBuffers ( ) ) ; assertEquals ( def . isSsl ( ) , json . isSsl ( ) ) ; } @ Test public void testClientOptionsJson ( ) { int sendBufferSize = TestUtils . randomPositiveInt ( ) ; int receiverBufferSize = TestUtils . randomPortInt ( ) ; Random rand = new Random ( ) ; boolean reuseAddress = rand . nextBoolean ( ) ; int trafficClass = TestUtils . randomByte ( ) + 127 ; boolean tcpNoDelay = rand . nextBoolean ( ) ; boolean tcpKeepAlive = rand . nextBoolean ( ) ; int soLinger = TestUtils . randomPositiveInt ( ) ; boolean usePooledBuffers = rand . nextBoolean ( ) ; int idleTimeout = TestUtils . randomPositiveInt ( ) ; boolean ssl = rand . nextBoolean ( ) ; JksOptions keyStoreOptions = new JksOptions ( ) ; String ksPassword = TestUtils . randomAlphaString ( 100 ) ; keyStoreOptions . setPassword ( ksPassword ) ; String ksPath = TestUtils . randomAlphaString ( 100 ) ; keyStoreOptions . setPath ( ksPath ) ; JksOptions trustStoreOptions = new JksOptions ( ) ; String tsPassword = TestUtils . randomAlphaString ( 100 ) ; trustStoreOptions . setPassword ( tsPassword ) ; String tsPath = TestUtils . randomAlphaString ( 100 ) ; trustStoreOptions . setPath ( tsPath ) ; String enabledCipher = TestUtils . randomAlphaString ( 100 ) ; int connectTimeout = TestUtils . randomPositiveInt ( ) ; boolean trustAll = rand . nextBoolean ( ) ; String crlPath = TestUtils . randomUnicodeString ( 100 ) ; boolean verifyHost = rand . nextBoolean ( ) ; int maxPoolSize = TestUtils . randomPositiveInt ( ) ; boolean keepAlive = rand . nextBoolean ( ) ; boolean pipelining = rand . nextBoolean ( ) ; boolean tryUseCompression = rand . nextBoolean ( ) ; JsonObject json = new JsonObject ( ) ; json . put ( "sendBufferSize" , sendBufferSize ) . put ( "receiveBufferSize" , receiverBufferSize ) . put ( "reuseAddress" , reuseAddress ) . put ( "trafficClass" , trafficClass ) . put ( "tcpNoDelay" , tcpNoDelay ) . put ( "tcpKeepAlive" , tcpKeepAlive ) . put ( "soLinger" , soLinger ) . put ( "usePooledBuffers" , usePooledBuffers ) . put ( "idleTimeout" , idleTimeout ) . put ( "ssl" , ssl ) . put ( "enabledCipherSuites" , new JsonArray ( ) . add ( enabledCipher ) ) . put ( "connectTimeout" , connectTimeout ) . put ( "trustAll" , trustAll ) . put ( "crlPaths" , new JsonArray ( ) . add ( crlPath ) ) . put ( "keyStoreOptions" , new JsonObject ( ) . put ( "type" , "jks" ) . put ( "password" , ksPassword ) . put ( "path" , ksPath ) ) . put ( "trustStoreOptions" , new JsonObject ( ) . put ( "type" , "jks" ) . put ( "password" , tsPassword ) . put ( "path" , tsPath ) ) . put ( "verifyHost" , verifyHost ) . put ( "maxPoolSize" , maxPoolSize ) . put ( "keepAlive" , keepAlive ) . put ( "pipelining" , pipelining ) . put ( "tryUseCompression" , tryUseCompression ) ; HttpClientOptions options = new HttpClientOptions ( json ) ; assertEquals ( sendBufferSize , options . getSendBufferSize ( ) ) ; assertEquals ( receiverBufferSize , options . getReceiveBufferSize ( ) ) ; assertEquals ( reuseAddress , options . isReuseAddress ( ) ) ; assertEquals ( trafficClass , options . getTrafficClass ( ) ) ; assertEquals ( tcpKeepAlive , options . isTcpKeepAlive ( ) ) ; assertEquals ( tcpNoDelay , options . isTcpNoDelay ( ) ) ; assertEquals ( soLinger , options . getSoLinger ( ) ) ; assertEquals ( usePooledBuffers , options . isUsePooledBuffers ( ) ) ; assertEquals ( idleTimeout , options . getIdleTimeout ( ) ) ; assertEquals ( ssl , options . isSsl ( ) ) ; assertNotSame ( keyStoreOptions , options . getKeyCertOptions ( ) ) ; assertEquals ( ksPassword , ( ( JksOptions ) options . getKeyCertOptions ( ) ) . getPassword ( ) ) ; assertEquals ( ksPath , ( ( JksOptions ) options . getKeyCertOptions ( ) ) . getPath ( ) ) ; assertNotSame ( trustStoreOptions , options . getTrustOptions ( ) ) ; assertEquals ( tsPassword , ( ( JksOptions ) options . getTrustOptions ( ) ) . getPassword ( ) ) ; assertEquals ( tsPath , ( ( JksOptions ) options . getTrustOptions ( ) ) . getPath ( ) ) ; assertEquals ( 1 , options . getEnabledCipherSuites ( ) . size ( ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . contains ( enabledCipher ) ) ; assertEquals ( connectTimeout , options . getConnectTimeout ( ) ) ; assertEquals ( trustAll , options . isTrustAll ( ) ) ; assertEquals ( 1 , options . getCrlPaths ( ) . size ( ) ) ; assertEquals ( crlPath , options . getCrlPaths ( ) . get ( 0 ) ) ; assertEquals ( verifyHost , options . isVerifyHost ( ) ) ; assertEquals ( maxPoolSize , options . getMaxPoolSize ( ) ) ; assertEquals ( keepAlive , options . isKeepAlive ( ) ) ; assertEquals ( pipelining , options . isPipelining ( ) ) ; assertEquals ( tryUseCompression , options . isTryUseCompression ( ) ) ; json . put ( "pfxKeyCertOptions" , new JsonObject ( ) . put ( "password" , ksPassword ) ) . put ( "pfxTrustOptions" , new JsonObject ( ) . put ( "password" , tsPassword ) ) ; options = new HttpClientOptions ( json ) ; assertTrue ( options . getTrustOptions ( ) instanceof PfxOptions ) ; assertTrue ( options . getKeyCertOptions ( ) instanceof PfxOptions ) ; json . put ( "pemKeyCertOptions" , new JsonObject ( ) ) . put ( "pemTrustOptions" , new JsonObject ( ) ) ; options = new HttpClientOptions ( json ) ; assertTrue ( options . getTrustOptions ( ) instanceof PemTrustOptions ) ; assertTrue ( options . getKeyCertOptions ( ) instanceof PemKeyCertOptions ) ; } @ Test public void testCopyServerOptions ( ) { HttpServerOptions options = new HttpServerOptions ( ) ; int sendBufferSize = TestUtils . randomPositiveInt ( ) ; int receiverBufferSize = TestUtils . randomPortInt ( ) ; Random rand = new Random ( ) ; boolean reuseAddress = rand . nextBoolean ( ) ; int trafficClass = TestUtils . randomByte ( ) + 128 ; boolean tcpNoDelay = rand . nextBoolean ( ) ; boolean tcpKeepAlive = rand . nextBoolean ( ) ; int soLinger = TestUtils . randomPositiveInt ( ) ; boolean usePooledBuffers = rand . nextBoolean ( ) ; int idleTimeout = TestUtils . randomPositiveInt ( ) ; boolean ssl = rand . nextBoolean ( ) ; JksOptions keyStoreOptions = new JksOptions ( ) ; String ksPassword = TestUtils . randomAlphaString ( 100 ) ; keyStoreOptions . setPassword ( ksPassword ) ; JksOptions trustStoreOptions = new JksOptions ( ) ; String tsPassword = TestUtils . randomAlphaString ( 100 ) ; trustStoreOptions . setPassword ( tsPassword ) ; String enabledCipher = TestUtils . randomAlphaString ( 100 ) ; String crlPath = TestUtils . randomUnicodeString ( 100 ) ; Buffer crlValue = TestUtils . randomBuffer ( 100 ) ; int port = 1234 ; String host = TestUtils . randomAlphaString ( 100 ) ; int acceptBacklog = TestUtils . randomPortInt ( ) ; boolean compressionSupported = rand . nextBoolean ( ) ; int maxWebsocketFrameSize = TestUtils . randomPositiveInt ( ) ; String wsSubProtocol = TestUtils . randomAlphaString ( 10 ) ; boolean is100ContinueHandledAutomatically = rand . nextBoolean ( ) ; options . setSendBufferSize ( sendBufferSize ) ; options . setReceiveBufferSize ( receiverBufferSize ) ; options . setReuseAddress ( reuseAddress ) ; options . setTrafficClass ( trafficClass ) ; options . setTcpNoDelay ( tcpNoDelay ) ; options . setTcpKeepAlive ( tcpKeepAlive ) ; options . setSoLinger ( soLinger ) ; options . setUsePooledBuffers ( usePooledBuffers ) ; options . setIdleTimeout ( idleTimeout ) ; options . setSsl ( ssl ) ; options . setKeyStoreOptions ( keyStoreOptions ) ; options . setTrustStoreOptions ( trustStoreOptions ) ; options . addEnabledCipherSuite ( enabledCipher ) ; options . addCrlPath ( crlPath ) ; options . addCrlValue ( crlValue ) ; options . setPort ( port ) ; options . setHost ( host ) ; options . setAcceptBacklog ( acceptBacklog ) ; options . setCompressionSupported ( compressionSupported ) ; options . setMaxWebsocketFrameSize ( maxWebsocketFrameSize ) ; options . setWebsocketSubProtocol ( wsSubProtocol ) ; options . setHandle100ContinueAutomatically ( is100ContinueHandledAutomatically ) ; HttpServerOptions copy = new HttpServerOptions ( options ) ; assertEquals ( sendBufferSize , copy . getSendBufferSize ( ) ) ; assertEquals ( receiverBufferSize , copy . getReceiveBufferSize ( ) ) ; assertEquals ( reuseAddress , copy . isReuseAddress ( ) ) ; assertEquals ( trafficClass , copy . getTrafficClass ( ) ) ; assertEquals ( tcpNoDelay , copy . isTcpNoDelay ( ) ) ; assertEquals ( tcpKeepAlive , copy . isTcpKeepAlive ( ) ) ; assertEquals ( soLinger , copy . getSoLinger ( ) ) ; assertEquals ( usePooledBuffers , copy . isUsePooledBuffers ( ) ) ; assertEquals ( idleTimeout , copy . getIdleTimeout ( ) ) ; assertEquals ( ssl , copy . isSsl ( ) ) ; assertNotSame ( keyStoreOptions , copy . getKeyCertOptions ( ) ) ; assertEquals ( ksPassword , ( ( JksOptions ) copy . getKeyCertOptions ( ) ) . getPassword ( ) ) ; assertNotSame ( trustStoreOptions , copy . getTrustOptions ( ) ) ; assertEquals ( tsPassword , ( ( JksOptions ) copy . getTrustOptions ( ) ) . getPassword ( ) ) ; assertEquals ( 1 , copy . getEnabledCipherSuites ( ) . size ( ) ) ; assertTrue ( copy . getEnabledCipherSuites ( ) . contains ( enabledCipher ) ) ; assertEquals ( 1 , copy . getCrlPaths ( ) . size ( ) ) ; assertEquals ( crlPath , copy . getCrlPaths ( ) . get ( 0 ) ) ; assertEquals ( 1 , copy . getCrlValues ( ) . size ( ) ) ; assertEquals ( crlValue , copy . getCrlValues ( ) . get ( 0 ) ) ; assertEquals ( port , copy . getPort ( ) ) ; assertEquals ( host , copy . getHost ( ) ) ; assertEquals ( acceptBacklog , copy . getAcceptBacklog ( ) ) ; assertEquals ( compressionSupported , copy . isCompressionSupported ( ) ) ; assertEquals ( maxWebsocketFrameSize , copy . getMaxWebsocketFrameSize ( ) ) ; assertEquals ( wsSubProtocol , copy . getWebsocketSubProtocols ( ) ) ; assertEquals ( is100ContinueHandledAutomatically , copy . isHandle100ContinueAutomatically ( ) ) ; } @ Test public void testDefaultServerOptionsJson ( ) { HttpServerOptions def = new HttpServerOptions ( ) ; HttpServerOptions json = new HttpServerOptions ( new JsonObject ( ) ) ; assertEquals ( def . getMaxWebsocketFrameSize ( ) , json . getMaxWebsocketFrameSize ( ) ) ; assertEquals ( def . getWebsocketSubProtocols ( ) , json . getWebsocketSubProtocols ( ) ) ; assertEquals ( def . isCompressionSupported ( ) , json . isCompressionSupported ( ) ) ; assertEquals ( def . isClientAuthRequired ( ) , json . isClientAuthRequired ( ) ) ; assertEquals ( def . getCrlPaths ( ) , json . getCrlPaths ( ) ) ; assertEquals ( def . getCrlValues ( ) , json . getCrlValues ( ) ) ; assertEquals ( def . getAcceptBacklog ( ) , json . getAcceptBacklog ( ) ) ; assertEquals ( def . getPort ( ) , json . getPort ( ) ) ; assertEquals ( def . getHost ( ) , json . getHost ( ) ) ; assertEquals ( def . isTcpNoDelay ( ) , json . isTcpNoDelay ( ) ) ; assertEquals ( def . isTcpKeepAlive ( ) , json . isTcpKeepAlive ( ) ) ; assertEquals ( def . getSoLinger ( ) , json . getSoLinger ( ) ) ; assertEquals ( def . isUsePooledBuffers ( ) , json . isUsePooledBuffers ( ) ) ; assertEquals ( def . isSsl ( ) , json . isSsl ( ) ) ; assertEquals ( def . isHandle100ContinueAutomatically ( ) , json . isHandle100ContinueAutomatically ( ) ) ; } @ Test public void testServerOptionsJson ( ) { int sendBufferSize = TestUtils . randomPositiveInt ( ) ; int receiverBufferSize = TestUtils . randomPortInt ( ) ; Random rand = new Random ( ) ; boolean reuseAddress = rand . nextBoolean ( ) ; int trafficClass = TestUtils . randomByte ( ) + 127 ; boolean tcpNoDelay = rand . nextBoolean ( ) ; boolean tcpKeepAlive = rand . nextBoolean ( ) ; int soLinger = TestUtils . randomPositiveInt ( ) ; boolean usePooledBuffers = rand . nextBoolean ( ) ; int idleTimeout = TestUtils . randomPositiveInt ( ) ; boolean ssl = rand . nextBoolean ( ) ; JksOptions keyStoreOptions = new JksOptions ( ) ; String ksPassword = TestUtils . randomAlphaString ( 100 ) ; keyStoreOptions . setPassword ( ksPassword ) ; String ksPath = TestUtils . randomAlphaString ( 100 ) ; keyStoreOptions . setPath ( ksPath ) ; JksOptions trustStoreOptions = new JksOptions ( ) ; String tsPassword = TestUtils . randomAlphaString ( 100 ) ; trustStoreOptions . setPassword ( tsPassword ) ; String tsPath = TestUtils . randomAlphaString ( 100 ) ; trustStoreOptions . setPath ( tsPath ) ; String enabledCipher = TestUtils . randomAlphaString ( 100 ) ; String crlPath = TestUtils . randomUnicodeString ( 100 ) ; int port = 1234 ; String host = TestUtils . randomAlphaString ( 100 ) ; int acceptBacklog = TestUtils . randomPortInt ( ) ; boolean compressionSupported = rand . nextBoolean ( ) ; int maxWebsocketFrameSize = TestUtils . randomPositiveInt ( ) ; String wsSubProtocol = TestUtils . randomAlphaString ( 10 ) ; boolean is100ContinueHandledAutomatically = rand . nextBoolean ( ) ; JsonObject json = new JsonObject ( ) ; json . put ( "sendBufferSize" , sendBufferSize ) . put ( "receiveBufferSize" , receiverBufferSize ) . put ( "reuseAddress" , reuseAddress ) . put ( "trafficClass" , trafficClass ) . put ( "tcpNoDelay" , tcpNoDelay ) . put ( "tcpKeepAlive" , tcpKeepAlive ) . put ( "soLinger" , soLinger ) . put ( "usePooledBuffers" , usePooledBuffers ) . put ( "idleTimeout" , idleTimeout ) . put ( "ssl" , ssl ) . put ( "enabledCipherSuites" , new JsonArray ( ) . add ( enabledCipher ) ) . put ( "crlPaths" , new JsonArray ( ) . add ( crlPath ) ) . put ( "keyStoreOptions" , new JsonObject ( ) . put ( "type" , "jks" ) . put ( "password" , ksPassword ) . put ( "path" , ksPath ) ) . put ( "trustStoreOptions" , new JsonObject ( ) . put ( "type" , "jks" ) . put ( "password" , tsPassword ) . put ( "path" , tsPath ) ) . put ( "port" , port ) . put ( "host" , host ) . put ( "acceptBacklog" , acceptBacklog ) . put ( "compressionSupported" , compressionSupported ) . put ( "maxWebsocketFrameSize" , maxWebsocketFrameSize ) . put ( "websocketSubProtocols" , wsSubProtocol ) . put ( "handle100ContinueAutomatically" , is100ContinueHandledAutomatically ) ; HttpServerOptions options = new HttpServerOptions ( json ) ; assertEquals ( sendBufferSize , options . getSendBufferSize ( ) ) ; assertEquals ( receiverBufferSize , options . getReceiveBufferSize ( ) ) ; assertEquals ( reuseAddress , options . isReuseAddress ( ) ) ; assertEquals ( trafficClass , options . getTrafficClass ( ) ) ; assertEquals ( tcpKeepAlive , options . isTcpKeepAlive ( ) ) ; assertEquals ( tcpNoDelay , options . isTcpNoDelay ( ) ) ; assertEquals ( soLinger , options . getSoLinger ( ) ) ; assertEquals ( usePooledBuffers , options . isUsePooledBuffers ( ) ) ; assertEquals ( idleTimeout , options . getIdleTimeout ( ) ) ; assertEquals ( ssl , options . isSsl ( ) ) ; assertNotSame ( keyStoreOptions , options . getKeyCertOptions ( ) ) ; assertEquals ( ksPassword , ( ( JksOptions ) options . getKeyCertOptions ( ) ) . getPassword ( ) ) ; assertEquals ( ksPath , ( ( JksOptions ) options . getKeyCertOptions ( ) ) . getPath ( ) ) ; assertNotSame ( trustStoreOptions , options . getTrustOptions ( ) ) ; assertEquals ( tsPassword , ( ( JksOptions ) options . getTrustOptions ( ) ) . getPassword ( ) ) ; assertEquals ( tsPath , ( ( JksOptions ) options . getTrustOptions ( ) ) . getPath ( ) ) ; assertEquals ( 1 , options . getEnabledCipherSuites ( ) . size ( ) ) ; assertTrue ( options . getEnabledCipherSuites ( ) . contains ( enabledCipher ) ) ; assertEquals ( 1 , options . getCrlPaths ( ) . size ( ) ) ; assertEquals ( crlPath , options . getCrlPaths ( ) . get ( 0 ) ) ; assertEquals ( port , options . getPort ( ) ) ; assertEquals ( host , options . getHost ( ) ) ; assertEquals ( acceptBacklog , options . getAcceptBacklog ( ) ) ; assertEquals ( compressionSupported , options . isCompressionSupported ( ) ) ; assertEquals ( maxWebsocketFrameSize , options . getMaxWebsocketFrameSize ( ) ) ; assertEquals ( wsSubProtocol , options . getWebsocketSubProtocols ( ) ) ; assertEquals ( is100ContinueHandledAutomatically , options . isHandle100ContinueAutomatically ( ) ) ; json . put ( "pfxKeyCertOptions" , new JsonObject ( ) . put ( "password" , ksPassword ) ) . put ( "pfxTrustOptions" , new JsonObject ( ) . put ( "password" , tsPassword ) ) ; options = new HttpServerOptions ( json ) ; assertTrue ( options . getTrustOptions ( ) instanceof PfxOptions ) ; assertTrue ( options . getKeyCertOptions ( ) instanceof PfxOptions ) ; json . put ( "pemKeyCertOptions" , new JsonObject ( ) ) . put ( "pemTrustOptions" , new JsonObject ( ) ) ; options = new HttpServerOptions ( json ) ; assertTrue ( options . getTrustOptions ( ) instanceof PemTrustOptions ) ; assertTrue ( options . getKeyCertOptions ( ) instanceof PemKeyCertOptions ) ; } @ Test public void testServerChaining ( ) { server . requestHandler ( req - > { assertTrue ( req . response ( ) . setChunked ( true ) == req . response ( ) ) ; assertTrue ( req . response ( ) . write ( "foo" , "UTF-8" ) == req . response ( ) ) ; assertTrue ( req . response ( ) . write ( "foo" ) == req . response ( ) ) ; testComplete ( ) ; } ) ; server . listen ( onSuccess ( server - > { client . request ( HttpMethod . PUT , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , noOpHandler ( ) ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testServerChainingSendFile ( ) throws Exception { File file = setupFile ( "test-server-chaining.dat" , "blah" ) ; server . requestHandler ( req - > { assertTrue ( req . response ( ) . sendFile ( file . getAbsolutePath ( ) ) == req . response ( ) ) ; assertTrue ( req . response ( ) . ended ( ) ) ; file . delete ( ) ; testComplete ( ) ; } ) ; server . listen ( onSuccess ( server - > { client . request ( HttpMethod . PUT , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , noOpHandler ( ) ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testClientRequestArguments ( ) throws Exception { HttpClientRequest req = client . request ( HttpMethod . PUT , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , noOpHandler ( ) ) ; assertNullPointerException ( ( ) - > req . putHeader ( ( String ) null , "someValue" ) ) ; assertNullPointerException ( ( ) - > req . putHeader ( ( CharSequence ) null , "someValue" ) ) ; assertNullPointerException ( ( ) - > req . putHeader ( "someKey" , ( Iterable < String > ) null ) ) ; assertNullPointerException ( ( ) - > req . write ( ( Buffer ) null ) ) ; assertNullPointerException ( ( ) - > req . write ( ( String ) null ) ) ; assertNullPointerException ( ( ) - > req . write ( null , "UTF-8" ) ) ; assertNullPointerException ( ( ) - > req . write ( "someString" , null ) ) ; assertNullPointerException ( ( ) - > req . end ( ( Buffer ) null ) ) ; assertNullPointerException ( ( ) - > req . end ( ( String ) null ) ) ; assertNullPointerException ( ( ) - > req . end ( null , "UTF-8" ) ) ; assertNullPointerException ( ( ) - > req . end ( "someString" , null ) ) ; assertIllegalArgumentException ( ( ) - > req . setTimeout ( 0 ) ) ; } @ Test public void testClientChaining ( ) { server . requestHandler ( noOpHandler ( ) ) ; server . listen ( onSuccess ( server - > { HttpClientRequest req = client . request ( HttpMethod . PUT , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , noOpHandler ( ) ) ; assertTrue ( req . setChunked ( true ) == req ) ; assertTrue ( req . sendHead ( ) == req ) ; assertTrue ( req . write ( "foo" , "UTF-8" ) == req ) ; assertTrue ( req . write ( "foo" ) == req ) ; assertTrue ( req . write ( Buffer . buffer ( "foo" ) ) == req ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testLowerCaseHeaders ( ) { server . requestHandler ( req - > { assertEquals ( "foo" , req . headers ( ) . get ( "Foo" ) ) ; assertEquals ( "foo" , req . headers ( ) . get ( "foo" ) ) ; assertEquals ( "foo" , req . headers ( ) . get ( "fOO" ) ) ; assertTrue ( req . headers ( ) . contains ( "Foo" ) ) ; assertTrue ( req . headers ( ) . contains ( "foo" ) ) ; assertTrue ( req . headers ( ) . contains ( "fOO" ) ) ; req . response ( ) . putHeader ( "Quux" , "quux" ) ; assertEquals ( "quux" , req . response ( ) . headers ( ) . get ( "Quux" ) ) ; assertEquals ( "quux" , req . response ( ) . headers ( ) . get ( "quux" ) ) ; assertEquals ( "quux" , req . response ( ) . headers ( ) . get ( "qUUX" ) ) ; assertTrue ( req . response ( ) . headers ( ) . contains ( "Quux" ) ) ; assertTrue ( req . response ( ) . headers ( ) . contains ( "quux" ) ) ; assertTrue ( req . response ( ) . headers ( ) . contains ( "qUUX" ) ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( server - > { HttpClientRequest req = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { assertEquals ( "quux" , resp . headers ( ) . get ( "Quux" ) ) ; assertEquals ( "quux" , resp . headers ( ) . get ( "quux" ) ) ; assertEquals ( "quux" , resp . headers ( ) . get ( "qUUX" ) ) ; assertTrue ( resp . headers ( ) . contains ( "Quux" ) ) ; assertTrue ( resp . headers ( ) . contains ( "quux" ) ) ; assertTrue ( resp . headers ( ) . contains ( "qUUX" ) ) ; testComplete ( ) ; } ) ; req . putHeader ( "Foo" , "foo" ) ; assertEquals ( "foo" , req . headers ( ) . get ( "Foo" ) ) ; assertEquals ( "foo" , req . headers ( ) . get ( "foo" ) ) ; assertEquals ( "foo" , req . headers ( ) . get ( "fOO" ) ) ; assertTrue ( req . headers ( ) . contains ( "Foo" ) ) ; assertTrue ( req . headers ( ) . contains ( "foo" ) ) ; assertTrue ( req . headers ( ) . contains ( "fOO" ) ) ; req . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testPutHeadersOnRequest ( ) { server . requestHandler ( req - > { assertEquals ( "bar" , req . headers ( ) . get ( "foo" ) ) ; assertEquals ( "bar" , req . getHeader ( "foo" ) ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( server - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; testComplete ( ) ; } ) . putHeader ( "foo" , "bar" ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testRequestNPE ( ) { String uri = "/some-uri?foo=bar" ; TestUtils . assertNullPointerException ( ( ) - > client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , uri , null ) ) ; TestUtils . assertNullPointerException ( ( ) - > client . request ( ( HttpMethod ) null , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , uri , resp - > { } ) ) ; TestUtils . assertNullPointerException ( ( ) - > client . requestAbs ( ( HttpMethod ) null , "http://someuri" , resp - > { } ) ) ; TestUtils . assertNullPointerException ( ( ) - > client . request ( HttpMethod . GET , 8080 , "localhost" , "/somepath" , null ) ) ; TestUtils . assertNullPointerException ( ( ) - > client . request ( ( HttpMethod ) null , 8080 , "localhost" , "/somepath" , resp - > { } ) ) ; TestUtils . assertNullPointerException ( ( ) - > client . request ( HttpMethod . GET , 8080 , null , "/somepath" , resp - > { } ) ) ; TestUtils . assertNullPointerException ( ( ) - > client . request ( HttpMethod . GET , 8080 , "localhost" , null , resp - > { } ) ) ; } @ Test public void testInvalidAbsoluteURI ( ) { try { client . requestAbs ( HttpMethod . GET , "ijdijwidjqwoijd192d192192ej12d" , resp - > { } ) . end ( ) ; fail ( "Should throw exception" ) ; } catch ( VertxException e ) { } } @ Test public void testSimpleGET ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . GET , resp - > testComplete ( ) ) ; } @ Test public void testSimplePUT ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . PUT , resp - > testComplete ( ) ) ; } @ Test public void testSimplePOST ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . POST , resp - > testComplete ( ) ) ; } @ Test public void testSimpleDELETE ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . DELETE , resp - > testComplete ( ) ) ; } @ Test public void testSimpleHEAD ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . HEAD , resp - > testComplete ( ) ) ; } @ Test public void testSimpleTRACE ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . TRACE , resp - > testComplete ( ) ) ; } @ Test public void testSimpleCONNECT ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . CONNECT , resp - > testComplete ( ) ) ; } @ Test public void testSimpleOPTIONS ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . OPTIONS , resp - > testComplete ( ) ) ; } @ Test public void testSimplePATCH ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . PATCH , resp - > testComplete ( ) ) ; } @ Test public void testSimpleGETAbsolute ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . GET , true , resp - > testComplete ( ) ) ; } @ Test public void testSimplePUTAbsolute ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . PUT , true , resp - > testComplete ( ) ) ; } @ Test public void testSimplePOSTAbsolute ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . POST , true , resp - > testComplete ( ) ) ; } @ Test public void testSimpleDELETEAbsolute ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . DELETE , true , resp - > testComplete ( ) ) ; } @ Test public void testSimpleHEADAbsolute ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . HEAD , true , resp - > testComplete ( ) ) ; } @ Test public void testSimpleTRACEAbsolute ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . TRACE , true , resp - > testComplete ( ) ) ; } @ Test public void testSimpleCONNECTAbsolute ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . CONNECT , true , resp - > testComplete ( ) ) ; } @ Test public void testSimpleOPTIONSAbsolute ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . OPTIONS , true , resp - > testComplete ( ) ) ; } @ Test public void testSimplePATCHAbsolute ( ) { String uri = "/some-uri?foo=bar" ; testSimpleRequest ( uri , HttpMethod . PATCH , true , resp - > testComplete ( ) ) ; } private void testSimpleRequest ( String uri , HttpMethod method , Handler < HttpClientResponse > handler ) { testSimpleRequest ( uri , method , false , handler ) ; } private void testSimpleRequest ( String uri , HttpMethod method , boolean absolute , Handler < HttpClientResponse > handler ) { HttpClientRequest req ; if ( absolute ) { req = client . requestAbs ( method , "http://" + DEFAULT_HTTP_HOST + ":" + DEFAULT_HTTP_PORT + uri , handler ) ; } else { req = client . request ( method , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , uri , handler ) ; } testSimpleRequest ( uri , method , req ) ; } private void testSimpleRequest ( String uri , HttpMethod method , HttpClientRequest request ) { int index = uri . indexOf ( '?' ) ; String path = index == - 1 ? uri : uri . substring ( 0 , index ) ; String query = index == - 1 ? null : uri . substring ( index + 1 ) ; server . requestHandler ( req - > { assertEquals ( path , req . path ( ) ) ; assertEquals ( method , req . method ( ) ) ; assertEquals ( query , req . query ( ) ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( server - > request . end ( ) ) ) ; await ( ) ; } @ Test public void testResponseEndHandlers1 ( ) { waitFor ( 2 ) ; AtomicInteger cnt = new AtomicInteger ( ) ; server . requestHandler ( req - > { req . response ( ) . headersEndHandler ( fut - > { req . response ( ) . putHeader ( "extraheader" , "wibble" ) ; assertEquals ( 0 , cnt . getAndIncrement ( ) ) ; fut . complete ( ) ; } ) ; req . response ( ) . bodyEndHandler ( v - > { assertEquals ( 1 , cnt . getAndIncrement ( ) ) ; complete ( ) ; } ) ; req . response ( ) . end ( ) ; } ) . listen ( onSuccess ( server - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/" , res - > { assertEquals ( 200 , res . statusCode ( ) ) ; assertEquals ( "wibble" , res . headers ( ) . get ( "extraheader" ) ) ; complete ( ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testResponseEndHandlers2 ( ) { waitFor ( 2 ) ; AtomicInteger cnt = new AtomicInteger ( ) ; server . requestHandler ( req - > { req . response ( ) . headersEndHandler ( fut - > { req . response ( ) . putHeader ( "extraheader" , "wibble" ) ; assertEquals ( 0 , cnt . getAndIncrement ( ) ) ; fut . complete ( ) ; } ) ; req . response ( ) . bodyEndHandler ( v - > { assertEquals ( 1 , cnt . getAndIncrement ( ) ) ; complete ( ) ; } ) ; req . response ( ) . end ( "blah" ) ; } ) . listen ( onSuccess ( server - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/" , res - > { assertEquals ( 200 , res . statusCode ( ) ) ; assertEquals ( "wibble" , res . headers ( ) . get ( "extraheader" ) ) ; res . bodyHandler ( buff - > { assertEquals ( Buffer . buffer ( "blah" ) , buff ) ; complete ( ) ; } ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testResponseEndHandlersSendFile ( ) throws Exception { waitFor ( 2 ) ; AtomicInteger cnt = new AtomicInteger ( ) ; String content = "iqdioqwdqwiojqwijdwqd" ; File toSend = setupFile ( "somefile.txt" , content ) ; server . requestHandler ( req - > { req . response ( ) . headersEndHandler ( fut - > { req . response ( ) . putHeader ( "extraheader" , "wibble" ) ; assertEquals ( 0 , cnt . getAndIncrement ( ) ) ; fut . complete ( ) ; } ) ; req . response ( ) . bodyEndHandler ( v - > { assertEquals ( 1 , cnt . getAndIncrement ( ) ) ; complete ( ) ; } ) ; req . response ( ) . sendFile ( toSend . getAbsolutePath ( ) ) ; } ) . listen ( onSuccess ( server - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/" , res - > { assertEquals ( 200 , res . statusCode ( ) ) ; assertEquals ( "wibble" , res . headers ( ) . get ( "extraheader" ) ) ; res . bodyHandler ( buff - > { assertEquals ( Buffer . buffer ( content ) , buff ) ; complete ( ) ; } ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testAbsoluteURI ( ) { testURIAndPath ( "http://localhost:" + DEFAULT_HTTP_PORT + "/this/is/a/path/foo.html" , "/this/is/a/path/foo.html" ) ; } @ Test public void testRelativeURI ( ) { testURIAndPath ( "/this/is/a/path/foo.html" , "/this/is/a/path/foo.html" ) ; } @ Test public void testAbsoluteURIWithHttpSchemaInQuery ( ) { testURIAndPath ( "http://localhost:" + DEFAULT_HTTP_PORT + "/correct/path?url=http://localhost:8008/wrong/path" , "/correct/path" ) ; } @ Test public void testRelativeURIWithHttpSchemaInQuery ( ) { testURIAndPath ( "/correct/path?url=http://localhost:8008/wrong/path" , "/correct/path" ) ; } @ Test public void testAbsoluteURIEmptyPath ( ) { testURIAndPath ( "http://localhost:" + DEFAULT_HTTP_PORT + "/" , "/" ) ; } private void testURIAndPath ( String uri , String path ) { server . requestHandler ( req - > { assertEquals ( uri , req . uri ( ) ) ; assertEquals ( path , req . path ( ) ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( server - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , uri , resp - > testComplete ( ) ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testParamUmlauteDecoding ( ) throws UnsupportedEncodingException { testParamDecoding ( "" ) ; } @ Test public void testParamPlusDecoding ( ) throws UnsupportedEncodingException { testParamDecoding ( "+" ) ; } @ Test public void testParamPercentDecoding ( ) throws UnsupportedEncodingException { testParamDecoding ( "%" ) ; } @ Test public void testParamSpaceDecoding ( ) throws UnsupportedEncodingException { testParamDecoding ( " " ) ; } @ Test public void testParamNormalDecoding ( ) throws UnsupportedEncodingException { testParamDecoding ( "hello" ) ; } @ Test public void testParamAltogetherDecoding ( ) throws UnsupportedEncodingException { testParamDecoding ( "+% hello" ) ; } private void testParamDecoding ( String value ) throws UnsupportedEncodingException { server . requestHandler ( req - > { req . setExpectMultipart ( true ) ; req . endHandler ( v - > { MultiMap formAttributes = req . formAttributes ( ) ; assertEquals ( value , formAttributes . get ( "param" ) ) ; } ) ; req . response ( ) . end ( ) ; } ) ; String postData = "param=" + URLEncoder . encode ( value , "UTF-8" ) ; server . listen ( onSuccess ( server - > { client . post ( DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/" ) . putHeader ( HttpHeaders . CONTENT_TYPE , HttpHeaders . APPLICATION_X_WWW_FORM_URLENCODED ) . putHeader ( HttpHeaders . CONTENT_LENGTH , String . valueOf ( postData . length ( ) ) ) . handler ( resp - > { testComplete ( ) ; } ) . write ( postData ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testParamsAmpersand ( ) { testParams ( '&' ) ; } @ Test public void testParamsSemiColon ( ) { testParams ( ';' ) ; } private void testParams ( char delim ) { Map < String , String > params = genMap ( 10 ) ; String query = generateQueryString ( params , delim ) ; server . requestHandler ( req - > { assertEquals ( query , req . query ( ) ) ; assertEquals ( params . size ( ) , req . params ( ) . size ( ) ) ; for ( Map . Entry < String , String > entry : req . params ( ) ) { assertEquals ( entry . getValue ( ) , params . get ( entry . getKey ( ) ) ) ; } req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( server - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "some-uri/?" + query , resp - > testComplete ( ) ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testNoParams ( ) { server . requestHandler ( req - > { assertNull ( req . query ( ) ) ; assertTrue ( req . params ( ) . isEmpty ( ) ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( server - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > testComplete ( ) ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testDefaultRequestHeaders ( ) { server . requestHandler ( req - > { assertEquals ( 1 , req . headers ( ) . size ( ) ) ; assertEquals ( "localhost:" + DEFAULT_HTTP_PORT , req . headers ( ) . get ( "host" ) ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( server - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > testComplete ( ) ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testRequestHeadersPutAll ( ) { testRequestHeaders ( false ) ; } @ Test public void testRequestHeadersIndividually ( ) { testRequestHeaders ( true ) ; } private void testRequestHeaders ( boolean individually ) { MultiMap headers = getHeaders ( 10 ) ; server . requestHandler ( req - > { assertEquals ( headers . size ( ) + 1 , req . headers ( ) . size ( ) ) ; for ( Map . Entry < String , String > entry : headers ) { assertEquals ( entry . getValue ( ) , req . headers ( ) . get ( entry . getKey ( ) ) ) ; assertEquals ( entry . getValue ( ) , req . getHeader ( entry . getKey ( ) ) ) ; } req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( server - > { HttpClientRequest req = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > testComplete ( ) ) ; if ( individually ) { for ( Map . Entry < String , String > header : headers ) { req . headers ( ) . add ( header . getKey ( ) , header . getValue ( ) ) ; } } else { req . headers ( ) . setAll ( headers ) ; } req . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testResponseHeadersPutAll ( ) { testResponseHeaders ( false ) ; } @ Test public void testResponseHeadersIndividually ( ) { testResponseHeaders ( true ) ; } private void testResponseHeaders ( boolean individually ) { MultiMap headers = getHeaders ( 10 ) ; server . requestHandler ( req - > { if ( individually ) { for ( Map . Entry < String , String > header : headers ) { req . response ( ) . headers ( ) . add ( header . getKey ( ) , header . getValue ( ) ) ; } } else { req . response ( ) . headers ( ) . setAll ( headers ) ; } req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( server - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { assertEquals ( headers . size ( ) + 1 , resp . headers ( ) . size ( ) ) ; for ( Map . Entry < String , String > entry : headers ) { assertEquals ( entry . getValue ( ) , resp . headers ( ) . get ( entry . getKey ( ) ) ) ; assertEquals ( entry . getValue ( ) , resp . getHeader ( entry . getKey ( ) ) ) ; } testComplete ( ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testResponseMultipleSetCookieInHeader ( ) { testResponseMultipleSetCookie ( true , false ) ; } @ Test public void testResponseMultipleSetCookieInTrailer ( ) { testResponseMultipleSetCookie ( false , true ) ; } @ Test public void testResponseMultipleSetCookieInHeaderAndTrailer ( ) { testResponseMultipleSetCookie ( true , true ) ; } private void testResponseMultipleSetCookie ( boolean inHeader , boolean inTrailer ) { List < String > cookies = new ArrayList < > ( ) ; server . requestHandler ( req - > { if ( inHeader ) { List < String > headers = new ArrayList < > ( ) ; headers . add ( "h1=h1v1" ) ; headers . add ( "h2=h2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT" ) ; cookies . addAll ( headers ) ; req . response ( ) . headers ( ) . set ( "Set-Cookie" , headers ) ; } if ( inTrailer ) { req . response ( ) . setChunked ( true ) ; List < String > trailers = new ArrayList < > ( ) ; trailers . add ( "t1=t1v1" ) ; trailers . add ( "t2=t2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT" ) ; cookies . addAll ( trailers ) ; req . response ( ) . trailers ( ) . set ( "Set-Cookie" , trailers ) ; } req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( server - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . endHandler ( v - > { assertEquals ( cookies . size ( ) , resp . cookies ( ) . size ( ) ) ; for ( int i = 0 ; i < cookies . size ( ) ; ++ i ) { assertEquals ( cookies . get ( i ) , resp . cookies ( ) . get ( i ) ) ; } testComplete ( ) ; } ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testUseRequestAfterComplete ( ) { server . requestHandler ( noOpHandler ( ) ) ; server . listen ( onSuccess ( server - > { HttpClientRequest req = client . request ( HttpMethod . POST , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , noOpHandler ( ) ) ; req . end ( ) ; Buffer buff = Buffer . buffer ( ) ; assertIllegalStateException ( ( ) - > req . end ( ) ) ; assertIllegalStateException ( ( ) - > req . continueHandler ( noOpHandler ( ) ) ) ; assertIllegalStateException ( ( ) - > req . drainHandler ( noOpHandler ( ) ) ) ; assertIllegalStateException ( ( ) - > req . end ( "foo" ) ) ; assertIllegalStateException ( ( ) - > req . end ( buff ) ) ; assertIllegalStateException ( ( ) - > req . end ( "foo" , "UTF-8" ) ) ; assertIllegalStateException ( ( ) - > req . sendHead ( ) ) ; assertIllegalStateException ( ( ) - > req . setChunked ( false ) ) ; assertIllegalStateException ( ( ) - > req . setWriteQueueMaxSize ( 123 ) ) ; assertIllegalStateException ( ( ) - > req . write ( buff ) ) ; assertIllegalStateException ( ( ) - > req . write ( "foo" ) ) ; assertIllegalStateException ( ( ) - > req . write ( "foo" , "UTF-8" ) ) ; assertIllegalStateException ( ( ) - > req . write ( buff ) ) ; assertIllegalStateException ( ( ) - > req . writeQueueFull ( ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testRequestBodyBufferAtEnd ( ) { Buffer body = TestUtils . randomBuffer ( 1000 ) ; server . requestHandler ( req - > req . bodyHandler ( buffer - > { assertEquals ( body , buffer ) ; req . response ( ) . end ( ) ; } ) ) ; server . listen ( onSuccess ( server - > { client . request ( HttpMethod . POST , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > testComplete ( ) ) . end ( body ) ; } ) ) ; await ( ) ; } @ Test public void testRequestBodyStringDefaultEncodingAtEnd ( ) { testRequestBodyStringAtEnd ( null ) ; } @ Test public void testRequestBodyStringUTF8AtEnd ( ) { testRequestBodyStringAtEnd ( "UTF-8" ) ; } @ Test public void testRequestBodyStringUTF16AtEnd ( ) { testRequestBodyStringAtEnd ( "UTF-16" ) ; } private void testRequestBodyStringAtEnd ( String encoding ) { String body = TestUtils . randomUnicodeString ( 1000 ) ; Buffer bodyBuff ; if ( encoding == null ) { bodyBuff = Buffer . buffer ( body ) ; } else { bodyBuff = Buffer . buffer ( body , encoding ) ; } server . requestHandler ( req - > { req . bodyHandler ( buffer - > { assertEquals ( bodyBuff , buffer ) ; testComplete ( ) ; } ) ; } ) ; server . listen ( onSuccess ( server - > { HttpClientRequest req = client . request ( HttpMethod . POST , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , noOpHandler ( ) ) ; if ( encoding == null ) { req . end ( body ) ; } else { req . end ( body , encoding ) ; } } ) ) ; await ( ) ; } @ Test public void testRequestBodyWriteChunked ( ) { testRequestBodyWrite ( true ) ; } @ Test public void testRequestBodyWriteNonChunked ( ) { testRequestBodyWrite ( false ) ; } private void testRequestBodyWrite ( boolean chunked ) { Buffer body = Buffer . buffer ( ) ; server . requestHandler ( req - > { req . bodyHandler ( buffer - > { assertEquals ( body , buffer ) ; req . response ( ) . end ( ) ; } ) ; } ) ; server . listen ( onSuccess ( server - > { HttpClientRequest req = client . request ( HttpMethod . POST , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > testComplete ( ) ) ; int numWrites = 10 ; int chunkSize = 100 ; if ( chunked ) { req . setChunked ( true ) ; } else { req . headers ( ) . set ( "Content-Length" , String . valueOf ( numWrites * chunkSize ) ) ; } for ( int i = 0 ; i < numWrites ; i ++ ) { Buffer b = TestUtils . randomBuffer ( chunkSize ) ; body . appendBuffer ( b ) ; req . write ( b ) ; } req . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testRequestBodyWriteStringChunkedDefaultEncoding ( ) { testRequestBodyWriteString ( true , null ) ; } @ Test public void testRequestBodyWriteStringChunkedUTF8 ( ) { testRequestBodyWriteString ( true , "UTF-8" ) ; } @ Test public void testRequestBodyWriteStringChunkedUTF16 ( ) { testRequestBodyWriteString ( true , "UTF-16" ) ; } @ Test public void testRequestBodyWriteStringNonChunkedDefaultEncoding ( ) { testRequestBodyWriteString ( false , null ) ; } @ Test public void testRequestBodyWriteStringNonChunkedUTF8 ( ) { testRequestBodyWriteString ( false , "UTF-8" ) ; } @ Test public void testRequestBodyWriteStringNonChunkedUTF16 ( ) { testRequestBodyWriteString ( false , "UTF-16" ) ; } private void testRequestBodyWriteString ( boolean chunked , String encoding ) { String body = TestUtils . randomUnicodeString ( 1000 ) ; Buffer bodyBuff ; if ( encoding == null ) { bodyBuff = Buffer . buffer ( body ) ; } else { bodyBuff = Buffer . buffer ( body , encoding ) ; } server . requestHandler ( req - > { req . bodyHandler ( buff - > { assertEquals ( bodyBuff , buff ) ; testComplete ( ) ; } ) ; } ) ; server . listen ( onSuccess ( server - > { HttpClientRequest req = client . request ( HttpMethod . POST , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , noOpHandler ( ) ) ; if ( chunked ) { req . setChunked ( true ) ; } else { req . headers ( ) . set ( "Content-Length" , String . valueOf ( bodyBuff . length ( ) ) ) ; } if ( encoding == null ) { req . write ( body ) ; } else { req . write ( body , encoding ) ; } req . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testRequestWrite ( ) { Buffer body = TestUtils . randomBuffer ( 1000 ) ; server . requestHandler ( req - > { req . bodyHandler ( buff - > { assertEquals ( body , buff ) ; testComplete ( ) ; } ) ; } ) ; server . listen ( onSuccess ( s - > { HttpClientRequest req = client . request ( HttpMethod . POST , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , noOpHandler ( ) ) ; req . setChunked ( true ) ; req . write ( body ) ; req . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testConnectWithoutResponseHandler ( ) throws Exception { try { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI ) . end ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } try { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI ) . end ( "whatever" ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } try { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI ) . end ( "whatever" , "UTF-8" ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } try { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI ) . end ( Buffer . buffer ( "whatever" ) ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } try { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI ) . sendHead ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } try { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI ) . write ( Buffer . buffer ( "whatever" ) ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } try { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI ) . write ( "whatever" ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } try { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI ) . write ( "whatever" , "UTF-8" ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } @ Test public void testClientExceptionHandlerCalledWhenFailingToConnect ( ) throws Exception { client . request ( HttpMethod . GET , 9998 , "255.255.255.255" , DEFAULT_TEST_URI , resp - > fail ( "Connect should not be called" ) ) . exceptionHandler ( error - > testComplete ( ) ) . endHandler ( done - > fail ( ) ) . end ( ) ; await ( ) ; } @ Test public void testClientExceptionHandlerCalledWhenServerTerminatesConnection ( ) throws Exception { int numReqs = 10 ; CountDownLatch latch = new CountDownLatch ( numReqs ) ; server . requestHandler ( request - > { request . response ( ) . close ( ) ; } ) . listen ( DEFAULT_HTTP_PORT , onSuccess ( s - > { for ( int i = 0 ; i < numReqs ; i ++ ) { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > fail ( "Connect should not be called" ) ) . exceptionHandler ( error - > latch . countDown ( ) ) . endHandler ( done - > fail ( ) ) . end ( ) ; } } ) ) ; awaitLatch ( latch ) ; } @ Test public void testClientExceptionHandlerCalledWhenServerTerminatesConnectionAfterPartialResponse ( ) throws Exception { server . requestHandler ( request - > { request . response ( ) . setChunked ( true ) . write ( "foo" ) . close ( ) ; } ) . listen ( DEFAULT_HTTP_PORT , onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > resp . exceptionHandler ( t - > testComplete ( ) ) ) . exceptionHandler ( error - > fail ( ) ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testNoExceptionHandlerCalledWhenResponseReceivedOK ( ) throws Exception { server . requestHandler ( request - > { request . response ( ) . end ( ) ; } ) . listen ( DEFAULT_HTTP_PORT , onSuccess ( s - > { client . get ( DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . endHandler ( v - > { vertx . setTimer ( 100 , tid - > testComplete ( ) ) ; } ) ; resp . exceptionHandler ( t - > { fail ( "Should not be called" ) ; } ) ; } ) . exceptionHandler ( t - > { fail ( "Should not be called" ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testDefaultStatus ( ) { testStatusCode ( - 1 , null ) ; } @ Test public void testDefaultOther ( ) { testStatusCode ( 405 , null ) ; } @ Test public void testOverrideStatusMessage ( ) { testStatusCode ( 404 , "some message" ) ; } @ Test public void testOverrideDefaultStatusMessage ( ) { testStatusCode ( - 1 , "some other message" ) ; } private void testStatusCode ( int code , String statusMessage ) { server . requestHandler ( req - > { if ( code != - 1 ) { req . response ( ) . setStatusCode ( code ) ; } if ( statusMessage != null ) { req . response ( ) . setStatusMessage ( statusMessage ) ; } req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { int theCode ; if ( code == - 1 ) { assertEquals ( 200 , resp . statusCode ( ) ) ; theCode = 200 ; } else { theCode = code ; } if ( statusMessage != null ) { assertEquals ( statusMessage , resp . statusMessage ( ) ) ; } else { assertEquals ( HttpResponseStatus . valueOf ( theCode ) . reasonPhrase ( ) , resp . statusMessage ( ) ) ; } testComplete ( ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testResponseTrailersPutAll ( ) { testResponseTrailers ( false ) ; } @ Test public void testResponseTrailersPutIndividually ( ) { testResponseTrailers ( true ) ; } private void testResponseTrailers ( boolean individually ) { MultiMap trailers = getHeaders ( 10 ) ; server . requestHandler ( req - > { req . response ( ) . setChunked ( true ) ; if ( individually ) { for ( Map . Entry < String , String > header : trailers ) { req . response ( ) . trailers ( ) . add ( header . getKey ( ) , header . getValue ( ) ) ; } } else { req . response ( ) . trailers ( ) . setAll ( trailers ) ; } req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . endHandler ( v - > { assertEquals ( trailers . size ( ) , resp . trailers ( ) . size ( ) ) ; for ( Map . Entry < String , String > entry : trailers ) { assertEquals ( entry . getValue ( ) , resp . trailers ( ) . get ( entry . getKey ( ) ) ) ; assertEquals ( entry . getValue ( ) , resp . getTrailer ( entry . getKey ( ) ) ) ; } testComplete ( ) ; } ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testResponseNoTrailers ( ) { server . requestHandler ( req - > { req . response ( ) . setChunked ( true ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . endHandler ( v - > { assertTrue ( resp . trailers ( ) . isEmpty ( ) ) ; testComplete ( ) ; } ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testUseResponseAfterComplete ( ) { server . requestHandler ( req - > { Buffer buff = Buffer . buffer ( ) ; HttpServerResponse resp = req . response ( ) ; assertFalse ( resp . ended ( ) ) ; resp . end ( ) ; assertTrue ( resp . ended ( ) ) ; assertIllegalStateException ( ( ) - > resp . drainHandler ( noOpHandler ( ) ) ) ; assertIllegalStateException ( ( ) - > resp . end ( ) ) ; assertIllegalStateException ( ( ) - > resp . end ( "foo" ) ) ; assertIllegalStateException ( ( ) - > resp . end ( buff ) ) ; assertIllegalStateException ( ( ) - > resp . end ( "foo" , "UTF-8" ) ) ; assertIllegalStateException ( ( ) - > resp . exceptionHandler ( noOpHandler ( ) ) ) ; assertIllegalStateException ( ( ) - > resp . setChunked ( false ) ) ; assertIllegalStateException ( ( ) - > resp . setWriteQueueMaxSize ( 123 ) ) ; assertIllegalStateException ( ( ) - > resp . write ( buff ) ) ; assertIllegalStateException ( ( ) - > resp . write ( "foo" ) ) ; assertIllegalStateException ( ( ) - > resp . write ( "foo" , "UTF-8" ) ) ; assertIllegalStateException ( ( ) - > resp . write ( buff ) ) ; assertIllegalStateException ( ( ) - > resp . writeQueueFull ( ) ) ; assertIllegalStateException ( ( ) - > resp . sendFile ( "asokdasokd" ) ) ; testComplete ( ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , noOpHandler ( ) ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testResponseBodyBufferAtEnd ( ) { Buffer body = TestUtils . randomBuffer ( 1000 ) ; server . requestHandler ( req - > { req . response ( ) . end ( body ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . bodyHandler ( buff - > { assertEquals ( body , buff ) ; testComplete ( ) ; } ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testResponseBodyStringDefaultEncodingAtEnd ( ) { testResponseBodyStringAtEnd ( null ) ; } @ Test public void testResponseBodyStringUTF8AtEnd ( ) { testResponseBodyStringAtEnd ( "UTF-8" ) ; } @ Test public void testResponseBodyStringUTF16AtEnd ( ) { testResponseBodyStringAtEnd ( "UTF-16" ) ; } private void testResponseBodyStringAtEnd ( String encoding ) { String body = TestUtils . randomUnicodeString ( 1000 ) ; Buffer bodyBuff ; if ( encoding == null ) { bodyBuff = Buffer . buffer ( body ) ; } else { bodyBuff = Buffer . buffer ( body , encoding ) ; } server . requestHandler ( req - > { if ( encoding == null ) { req . response ( ) . end ( body ) ; } else { req . response ( ) . end ( body , encoding ) ; } } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . bodyHandler ( buff - > { assertEquals ( bodyBuff , buff ) ; testComplete ( ) ; } ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testResponseBodyWriteStringNonChunked ( ) { server . requestHandler ( req - > { assertIllegalStateException ( ( ) - > req . response ( ) . write ( "foo" ) ) ; testComplete ( ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . POST , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , noOpHandler ( ) ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testResponseBodyWriteChunked ( ) { testResponseBodyWrite ( true ) ; } @ Test public void testResponseBodyWriteNonChunked ( ) { testResponseBodyWrite ( false ) ; } private void testResponseBodyWrite ( boolean chunked ) { Buffer body = Buffer . buffer ( ) ; int numWrites = 10 ; int chunkSize = 100 ; server . requestHandler ( req - > { assertFalse ( req . response ( ) . headWritten ( ) ) ; if ( chunked ) { req . response ( ) . setChunked ( true ) ; } else { req . response ( ) . headers ( ) . set ( "Content-Length" , String . valueOf ( numWrites * chunkSize ) ) ; } assertFalse ( req . response ( ) . headWritten ( ) ) ; for ( int i = 0 ; i < numWrites ; i ++ ) { Buffer b = TestUtils . randomBuffer ( chunkSize ) ; body . appendBuffer ( b ) ; req . response ( ) . write ( b ) ; assertTrue ( req . response ( ) . headWritten ( ) ) ; } req . response ( ) . end ( ) ; assertTrue ( req . response ( ) . headWritten ( ) ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . bodyHandler ( buff - > { assertEquals ( body , buff ) ; testComplete ( ) ; } ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testResponseBodyWriteStringChunkedDefaultEncoding ( ) { testResponseBodyWriteString ( true , null ) ; } @ Test public void testResponseBodyWriteStringChunkedUTF8 ( ) { testResponseBodyWriteString ( true , "UTF-8" ) ; } @ Test public void testResponseBodyWriteStringChunkedUTF16 ( ) { testResponseBodyWriteString ( true , "UTF-16" ) ; } @ Test public void testResponseBodyWriteStringNonChunkedDefaultEncoding ( ) { testResponseBodyWriteString ( false , null ) ; } @ Test public void testResponseBodyWriteStringNonChunkedUTF8 ( ) { testResponseBodyWriteString ( false , "UTF-8" ) ; } @ Test public void testResponseBodyWriteStringNonChunkedUTF16 ( ) { testResponseBodyWriteString ( false , "UTF-16" ) ; } private void testResponseBodyWriteString ( boolean chunked , String encoding ) { String body = TestUtils . randomUnicodeString ( 1000 ) ; Buffer bodyBuff ; if ( encoding == null ) { bodyBuff = Buffer . buffer ( body ) ; } else { bodyBuff = Buffer . buffer ( body , encoding ) ; } server . requestHandler ( req - > { if ( chunked ) { req . response ( ) . setChunked ( true ) ; } else { req . response ( ) . headers ( ) . set ( "Content-Length" , String . valueOf ( bodyBuff . length ( ) ) ) ; } if ( encoding == null ) { req . response ( ) . write ( body ) ; } else { req . response ( ) . write ( body , encoding ) ; } req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . bodyHandler ( buff - > { assertEquals ( bodyBuff , buff ) ; testComplete ( ) ; } ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testResponseWrite ( ) { Buffer body = TestUtils . randomBuffer ( 1000 ) ; server . requestHandler ( req - > { req . response ( ) . setChunked ( true ) ; req . response ( ) . write ( body ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . POST , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . bodyHandler ( buff - > { assertEquals ( body , buff ) ; testComplete ( ) ; } ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testPipeliningOrder ( ) throws Exception { client . close ( ) ; client = vertx . createHttpClient ( new HttpClientOptions ( ) . setKeepAlive ( true ) . setPipelining ( true ) . setMaxPoolSize ( 1 ) ) ; int requests = 100 ; AtomicInteger reqCount = new AtomicInteger ( 0 ) ; server . requestHandler ( req - > { int theCount = reqCount . get ( ) ; assertEquals ( theCount , Integer . parseInt ( req . headers ( ) . get ( "count" ) ) ) ; reqCount . incrementAndGet ( ) ; req . response ( ) . setChunked ( true ) ; req . bodyHandler ( buff - > { assertEquals ( "This is content " + theCount , buff . toString ( ) ) ; vertx . setTimer ( 1 + ( long ) ( 10 * Math . random ( ) ) , id - > { req . response ( ) . headers ( ) . set ( "count" , String . valueOf ( theCount ) ) ; req . response ( ) . write ( buff ) ; req . response ( ) . end ( ) ; } ) ; } ) ; } ) ; CountDownLatch latch = new CountDownLatch ( requests ) ; server . listen ( onSuccess ( s - > { vertx . setTimer ( 500 , id - > { for ( int count = 0 ; count < requests ; count ++ ) { int theCount = count ; HttpClientRequest req = client . request ( HttpMethod . POST , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { assertEquals ( theCount , Integer . parseInt ( resp . headers ( ) . get ( "count" ) ) ) ; resp . bodyHandler ( buff - > { assertEquals ( "This is content " + theCount , buff . toString ( ) ) ; latch . countDown ( ) ; } ) ; } ) ; req . setChunked ( true ) ; req . headers ( ) . set ( "count" , String . valueOf ( count ) ) ; req . write ( "This is content " + count ) ; req . end ( ) ; } } ) ; } ) ) ; awaitLatch ( latch ) ; } @ Test public void testKeepAlive ( ) throws Exception { testKeepAlive ( true , 5 , 10 , 5 ) ; } @ Test public void testNoKeepAlive ( ) throws Exception { testKeepAlive ( false , 5 , 10 , 10 ) ; } private void testKeepAlive ( boolean keepAlive , int poolSize , int numServers , int expectedConnectedServers ) throws Exception { client . close ( ) ; CountDownLatch firstCloseLatch = new CountDownLatch ( 1 ) ; server . close ( onSuccess ( v - > firstCloseLatch . countDown ( ) ) ) ; awaitLatch ( firstCloseLatch ) ; client = vertx . createHttpClient ( new HttpClientOptions ( ) . setKeepAlive ( keepAlive ) . setPipelining ( false ) . setMaxPoolSize ( poolSize ) ) ; int requests = 100 ; HttpServer [ ] servers = new HttpServer [ numServers ] ; CountDownLatch startServerLatch = new CountDownLatch ( numServers ) ; Set < HttpServer > connectedServers = new ConcurrentHashSet < > ( ) ; for ( int i = 0 ; i < numServers ; i ++ ) { HttpServer server = vertx . createHttpServer ( new HttpServerOptions ( ) . setHost ( DEFAULT_HTTP_HOST ) . setPort ( DEFAULT_HTTP_PORT ) ) ; server . requestHandler ( req - > { connectedServers . add ( server ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; startServerLatch . countDown ( ) ; } ) ; servers [ i ] = server ; } awaitLatch ( startServerLatch ) ; CountDownLatch reqLatch = new CountDownLatch ( requests ) ; vertx . runOnContext ( v - > { for ( int count = 0 ; count < requests ; count ++ ) { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; reqLatch . countDown ( ) ; } ) . end ( ) ; } } ) ; awaitLatch ( reqLatch ) ; assertEquals ( expectedConnectedServers , connectedServers . size ( ) ) ; CountDownLatch serverCloseLatch = new CountDownLatch ( numServers ) ; for ( HttpServer server : servers ) { server . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; serverCloseLatch . countDown ( ) ; } ) ; } awaitLatch ( serverCloseLatch ) ; } @ Test public void testSendFile ( ) throws Exception { String content = TestUtils . randomUnicodeString ( 10000 ) ; sendFile ( "test-send-file.html" , content , false ) ; } @ Test public void testSendFileWithHandler ( ) throws Exception { String content = TestUtils . randomUnicodeString ( 10000 ) ; sendFile ( "test-send-file.html" , content , true ) ; } private void sendFile ( String fileName , String contentExpected , boolean handler ) throws Exception { File fileToSend = setupFile ( fileName , contentExpected ) ; CountDownLatch latch ; if ( handler ) { latch = new CountDownLatch ( 2 ) ; } else { latch = new CountDownLatch ( 1 ) ; } server . requestHandler ( req - > { if ( handler ) { Handler < AsyncResult < Void > > completionHandler = onSuccess ( v - > latch . countDown ( ) ) ; req . response ( ) . sendFile ( fileToSend . getAbsolutePath ( ) , completionHandler ) ; } else { req . response ( ) . sendFile ( fileToSend . getAbsolutePath ( ) ) ; } } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; assertEquals ( "text/html" , resp . headers ( ) . get ( "Content-Type" ) ) ; resp . bodyHandler ( buff - > { assertEquals ( contentExpected , buff . toString ( ) ) ; assertEquals ( fileToSend . length ( ) , Long . parseLong ( resp . headers ( ) . get ( "content-length" ) ) ) ; latch . countDown ( ) ; } ) ; } ) . end ( ) ; } ) ) ; assertTrue ( "Timed out waiting for test to complete." , latch . await ( 10 , TimeUnit . SECONDS ) ) ; testComplete ( ) ; } @ Test public void testSendFileOverrideHeaders ( ) throws Exception { String content = TestUtils . randomUnicodeString ( 10000 ) ; File file = setupFile ( "test-send-file.html" , content ) ; server . requestHandler ( req - > { req . response ( ) . putHeader ( "Content-Type" , "wibble" ) ; req . response ( ) . sendFile ( file . getAbsolutePath ( ) ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { assertEquals ( file . length ( ) , Long . parseLong ( resp . headers ( ) . get ( "content-length" ) ) ) ; assertEquals ( "wibble" , resp . headers ( ) . get ( "content-type" ) ) ; resp . bodyHandler ( buff - > { assertEquals ( content , buff . toString ( ) ) ; file . delete ( ) ; testComplete ( ) ; } ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testSendFileNotFound ( ) throws Exception { server . requestHandler ( req - > { req . response ( ) . putHeader ( "Content-Type" , "wibble" ) ; req . response ( ) . sendFile ( "nosuchfile.html" ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { fail ( "Should not receive response" ) ; } ) . end ( ) ; vertx . setTimer ( 100 , tid - > testComplete ( ) ) ; } ) ) ; await ( ) ; } @ Test public void testSendFileNotFoundWithHandler ( ) throws Exception { server . requestHandler ( req - > { req . response ( ) . putHeader ( "Content-Type" , "wibble" ) ; req . response ( ) . sendFile ( "nosuchfile.html" , onFailure ( t - > { assertTrue ( t instanceof FileNotFoundException ) ; testComplete ( ) ; } ) ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { fail ( "Should not receive response" ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testSendFileDirectoryWithHandler ( ) throws Exception { File dir = testFolder . newFolder ( ) ; server . requestHandler ( req - > { req . response ( ) . putHeader ( "Content-Type" , "wibble" ) ; req . response ( ) . sendFile ( dir . getAbsolutePath ( ) , onFailure ( t - > { assertTrue ( t instanceof FileNotFoundException ) ; testComplete ( ) ; } ) ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { fail ( "Should not receive response" ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void test100ContinueHandledAutomatically ( ) throws Exception { Buffer toSend = TestUtils . randomBuffer ( 1000 ) ; server . requestHandler ( req - > { req . bodyHandler ( data - > { assertEquals ( toSend , data ) ; req . response ( ) . end ( ) ; } ) ; } ) ; server . listen ( onSuccess ( s - > { HttpClientRequest req = client . request ( HttpMethod . PUT , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . endHandler ( v - > testComplete ( ) ) ; } ) ; req . headers ( ) . set ( "Expect" , "100-continue" ) ; req . setChunked ( true ) ; req . continueHandler ( v - > { req . write ( toSend ) ; req . end ( ) ; } ) ; req . sendHead ( ) ; } ) ) ; await ( ) ; } @ Test public void test100ContinueHandledManually ( ) throws Exception { server . close ( ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( DEFAULT_HTTP_PORT ) . setHost ( DEFAULT_HTTP_HOST ) ) ; Buffer toSend = TestUtils . randomBuffer ( 1000 ) ; server . requestHandler ( req - > { assertEquals ( "100-continue" , req . getHeader ( "expect" ) ) ; req . response ( ) . writeContinue ( ) ; req . bodyHandler ( data - > { assertEquals ( toSend , data ) ; req . response ( ) . end ( ) ; } ) ; } ) ; server . listen ( onSuccess ( s - > { HttpClientRequest req = client . request ( HttpMethod . PUT , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . endHandler ( v - > testComplete ( ) ) ; } ) ; req . headers ( ) . set ( "Expect" , "100-continue" ) ; req . setChunked ( true ) ; req . continueHandler ( v - > { req . write ( toSend ) ; req . end ( ) ; } ) ; req . sendHead ( ) ; } ) ) ; await ( ) ; } @ Test public void test100ContinueRejectedManually ( ) throws Exception { server . close ( ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( DEFAULT_HTTP_PORT ) . setHost ( DEFAULT_HTTP_HOST ) ) ; server . requestHandler ( req - > { req . response ( ) . setStatusCode ( 405 ) . end ( ) ; req . bodyHandler ( data - > { fail ( "body should not be received" ) ; } ) ; } ) ; server . listen ( onSuccess ( s - > { HttpClientRequest req = client . request ( HttpMethod . PUT , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { assertEquals ( 405 , resp . statusCode ( ) ) ; testComplete ( ) ; } ) ; req . headers ( ) . set ( "Expect" , "100-continue" ) ; req . setChunked ( true ) ; req . continueHandler ( v - > { fail ( "should not be called" ) ; } ) ; req . sendHead ( ) ; } ) ) ; await ( ) ; } @ Test public void testClientDrainHandler ( ) { pausingServer ( s - > { HttpClientRequest req = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , noOpHandler ( ) ) ; req . setChunked ( true ) ; assertFalse ( req . writeQueueFull ( ) ) ; req . setWriteQueueMaxSize ( 1000 ) ; Buffer buff = TestUtils . randomBuffer ( 10000 ) ; vertx . setPeriodic ( 1 , id - > { req . write ( buff ) ; if ( req . writeQueueFull ( ) ) { vertx . cancelTimer ( id ) ; req . drainHandler ( v - > { assertFalse ( req . writeQueueFull ( ) ) ; testComplete ( ) ; } ) ; vertx . eventBus ( ) . send ( "server_resume" , "" ) ; } } ) ; } ) ; await ( ) ; } @ Test public void testServerDrainHandler ( ) { drainingServer ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . pause ( ) ; Handler < Message < Buffer > > resumeHandler = msg - > resp . resume ( ) ; MessageConsumer reg = vertx . eventBus ( ) . < Buffer > consumer ( "client_resume" ) . handler ( resumeHandler ) ; resp . endHandler ( v - > reg . unregister ( ) ) ; } ) . end ( ) ; } ) ; await ( ) ; } @ Test public void testPoolingKeepAliveAndPipelining ( ) { testPooling ( true , true ) ; } @ Test public void testPoolingKeepAliveNoPipelining ( ) { testPooling ( true , false ) ; } @ Test public void testPoolingNoKeepAliveNoPipelining ( ) { testPooling ( false , false ) ; } @ Test public void testPoolingNoKeepAliveAndPipelining ( ) { testPooling ( false , true ) ; } private void testPooling ( boolean keepAlive , boolean pipelining ) { String path = "foo.txt" ; int numGets = 100 ; int maxPoolSize = 10 ; client . close ( ) ; client = vertx . createHttpClient ( new HttpClientOptions ( ) . setKeepAlive ( keepAlive ) . setPipelining ( pipelining ) . setMaxPoolSize ( maxPoolSize ) ) ; server . requestHandler ( req - > { String cnt = req . headers ( ) . get ( "count" ) ; req . response ( ) . headers ( ) . set ( "count" , cnt ) ; req . response ( ) . end ( ) ; } ) ; AtomicBoolean completeAlready = new AtomicBoolean ( ) ; server . listen ( onSuccess ( s - > { AtomicInteger cnt = new AtomicInteger ( 0 ) ; for ( int i = 0 ; i < numGets ; i ++ ) { int theCount = i ; HttpClientRequest req = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , path , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; assertEquals ( theCount , Integer . parseInt ( resp . headers ( ) . get ( "count" ) ) ) ; if ( cnt . incrementAndGet ( ) == numGets ) { testComplete ( ) ; } } ) ; req . exceptionHandler ( t - > { if ( pipelining && ! keepAlive ) { assertTrue ( t instanceof IllegalStateException ) ; if ( completeAlready . compareAndSet ( false , true ) ) { testComplete ( ) ; } } else { fail ( "Should not throw exception: " + t . getMessage ( ) ) ; } } ) ; req . headers ( ) . set ( "count" , String . valueOf ( i ) ) ; req . end ( ) ; } } ) ) ; await ( ) ; } @ Test public void testConnectionErrorsGetReportedToRequest ( ) throws InterruptedException { AtomicInteger req1Exceptions = new AtomicInteger ( ) ; AtomicInteger req2Exceptions = new AtomicInteger ( ) ; AtomicInteger req3Exceptions = new AtomicInteger ( ) ; CountDownLatch latch = new CountDownLatch ( 3 ) ; HttpClientRequest req1 = client . request ( HttpMethod . GET , 9998 , DEFAULT_HTTP_HOST , "someurl1" , resp - > { fail ( "Should never get a response on a bad port, if you see this message than you are running an http server on port 9998" ) ; } ) ; req1 . exceptionHandler ( t - > { assertEquals ( "More than one call to req1 exception handler was not expected" , 1 , req1Exceptions . incrementAndGet ( ) ) ; latch . countDown ( ) ; } ) ; HttpClientRequest req2 = client . request ( HttpMethod . GET , 9998 , DEFAULT_HTTP_HOST , "someurl2" , resp - > { fail ( "Should never get a response on a bad port, if you see this message than you are running an http server on port 9998" ) ; } ) ; req2 . exceptionHandler ( t - > { assertEquals ( "More than one call to req2 exception handler was not expected" , 1 , req2Exceptions . incrementAndGet ( ) ) ; latch . countDown ( ) ; } ) ; HttpClientRequest req3 = client . request ( HttpMethod . GET , 9998 , DEFAULT_HTTP_HOST , "someurl2" , resp - > { fail ( "Should never get a response on a bad port, if you see this message than you are running an http server on port 9998" ) ; } ) ; req3 . exceptionHandler ( t - > { assertEquals ( "More than one call to req2 exception handler was not expected" , 1 , req3Exceptions . incrementAndGet ( ) ) ; latch . countDown ( ) ; } ) ; req1 . end ( ) ; req2 . end ( ) ; req3 . end ( ) ; awaitLatch ( latch ) ; testComplete ( ) ; } @ Test public void testRequestTimesoutWhenIndicatedPeriodExpiresWithoutAResponseFromRemoteServer ( ) { server . requestHandler ( noOpHandler ( ) ) ; server . listen ( onSuccess ( s - > { HttpClientRequest req = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { fail ( "End should not be called because the request should timeout" ) ; } ) ; req . exceptionHandler ( t - > { assertTrue ( "Expected to end with timeout exception but ended with other exception: " + t , t instanceof TimeoutException ) ; testComplete ( ) ; } ) ; req . setTimeout ( 1000 ) ; req . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testRequestTimeoutExtendedWhenResponseChunksReceived ( ) { long timeout = 2000 ; int numChunks = 100 ; AtomicInteger count = new AtomicInteger ( 0 ) ; long interval = timeout * 2 / numChunks ; server . requestHandler ( req - > { req . response ( ) . setChunked ( true ) ; vertx . setPeriodic ( interval , timerID - > { req . response ( ) . write ( "foo" ) ; if ( count . incrementAndGet ( ) == numChunks ) { req . response ( ) . end ( ) ; vertx . cancelTimer ( timerID ) ; } } ) ; } ) ; server . listen ( onSuccess ( s - > { HttpClientRequest req = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; resp . endHandler ( v - > testComplete ( ) ) ; } ) ; req . exceptionHandler ( t - > fail ( "Should not be called" ) ) ; req . setTimeout ( timeout ) ; req . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testRequestTimeoutCanceledWhenRequestHasAnOtherError ( ) { AtomicReference < Throwable > exception = new AtomicReference < > ( ) ; HttpClientRequest req = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { fail ( "End should not be called because the request should fail to connect" ) ; } ) ; req . exceptionHandler ( exception : : set ) ; req . setTimeout ( 800 ) ; req . end ( ) ; vertx . setTimer ( 1500 , id - > { assertNotNull ( "Expected an exception to be set" , exception . get ( ) ) ; assertFalse ( "Expected to not end with timeout exception, but did: " + exception . get ( ) , exception . get ( ) instanceof TimeoutException ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testRequestTimeoutCanceledWhenRequestEndsNormally ( ) { server . requestHandler ( req - > req . response ( ) . end ( ) ) ; server . listen ( onSuccess ( s - > { AtomicReference < Throwable > exception = new AtomicReference < > ( ) ; HttpClientRequest req = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , noOpHandler ( ) ) ; req . exceptionHandler ( exception : : set ) ; req . setTimeout ( 500 ) ; req . end ( ) ; vertx . setTimer ( 1000 , id - > { assertNull ( "Did not expect any exception" , exception . get ( ) ) ; testComplete ( ) ; } ) ; } ) ) ; await ( ) ; } @ Test public void testRequestNotReceivedIfTimedout ( ) { server . requestHandler ( req - > { vertx . setTimer ( 500 , id - > { req . response ( ) . setStatusCode ( 200 ) ; req . response ( ) . end ( "OK" ) ; } ) ; } ) ; server . listen ( onSuccess ( s - > { HttpClientRequest req = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > fail ( "Response should not be handled" ) ) ; req . exceptionHandler ( t - > { assertTrue ( "Expected to end with timeout exception but ended with other exception: " + t , t instanceof TimeoutException ) ; vertx . setTimer ( 500 , id - > testComplete ( ) ) ; } ) ; req . setTimeout ( 100 ) ; req . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testServerWebsocketIdleTimeout ( ) { server . close ( ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setIdleTimeout ( 1 ) . setPort ( DEFAULT_HTTP_PORT ) . setHost ( DEFAULT_HTTP_HOST ) ) ; server . websocketHandler ( ws - > { } ) . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . websocket ( DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/" , ws - > { ws . closeHandler ( v - > testComplete ( ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testClientWebsocketIdleTimeout ( ) { client . close ( ) ; client = vertx . createHttpClient ( new HttpClientOptions ( ) . setIdleTimeout ( 1 ) ) ; server . websocketHandler ( ws - > { } ) . listen ( ar - > { client . websocket ( DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/" , ws - > { ws . closeHandler ( v - > testComplete ( ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testTLSClientTrustAll ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . NONE , KeyCert . JKS , Trust . NONE , false , false , true , false , true ) ; } @ Test public void testTLSClientTrustServerCert ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . JKS , KeyCert . JKS , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertPKCS12 ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . JKS , KeyCert . PKCS12 , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertPEM ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . JKS , KeyCert . PEM , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertJKS_CAWithJKS_CA ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . JKS_CA , KeyCert . JKS_CA , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertJKS_CAWithPKCS12_CA ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . PKCS12_CA , KeyCert . JKS_CA , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertJKS_CAWithPEM_CA ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . PEM_CA , KeyCert . JKS_CA , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertPKCS12_CAWithJKS_CA ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . JKS_CA , KeyCert . PKCS12_CA , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertPKCS12_CAWithPKCS12_CA ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . PKCS12_CA , KeyCert . PKCS12_CA , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertPKCS12_CAWithPEM_CA ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . PEM_CA , KeyCert . PKCS12_CA , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertPEM_CAWithJKS_CA ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . JKS_CA , KeyCert . PEM_CA , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertPEM_CAWithPKCS12_CA ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . PKCS12_CA , KeyCert . PEM_CA , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustServerCertPEM_CAWithPEM_CA ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . PEM_CA , KeyCert . PEM_CA , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustPKCS12ServerCert ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . PKCS12 , KeyCert . JKS , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientTrustPEMServerCert ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . PEM , KeyCert . JKS , Trust . NONE , false , false , false , false , true ) ; } @ Test public void testTLSClientUntrustedServer ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . NONE , KeyCert . JKS , Trust . NONE , false , false , false , false , false ) ; } @ Test public void testTLSClientUntrustedServerPEM ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . NONE , KeyCert . PEM , Trust . NONE , false , false , false , false , false ) ; } @ Test public void testTLSClientCertNotRequired ( ) throws Exception { testTLS ( KeyCert . JKS , Trust . JKS , KeyCert . JKS , Trust . JKS , false , false , false , false , true ) ; } @ Test public void testTLSClientCertNotRequiredPEM ( ) throws Exception { testTLS ( KeyCert . JKS , Trust . JKS , KeyCert . PEM , Trust . JKS , false , false , false , false , true ) ; } @ Test public void testTLSClientCertRequired ( ) throws Exception { testTLS ( KeyCert . JKS , Trust . JKS , KeyCert . JKS , Trust . JKS , true , false , false , false , true ) ; } @ Test public void testTLSClientCertRequiredPKCS12 ( ) throws Exception { testTLS ( KeyCert . JKS , Trust . JKS , KeyCert . JKS , Trust . PKCS12 , true , false , false , false , true ) ; } @ Test public void testTLSClientCertRequiredPEM ( ) throws Exception { testTLS ( KeyCert . JKS , Trust . JKS , KeyCert . JKS , Trust . PEM , true , false , false , false , true ) ; } @ Test public void testTLSClientCertPKCS12Required ( ) throws Exception { testTLS ( KeyCert . PKCS12 , Trust . JKS , KeyCert . JKS , Trust . JKS , true , false , false , false , true ) ; } @ Test public void testTLSClientCertPEMRequired ( ) throws Exception { testTLS ( KeyCert . PEM , Trust . JKS , KeyCert . JKS , Trust . JKS , true , false , false , false , true ) ; } @ Test public void testTLSClientCertPEM_CARequired ( ) throws Exception { testTLS ( KeyCert . PEM_CA , Trust . JKS , KeyCert . JKS , Trust . PEM_CA , true , false , false , false , true ) ; } @ Test public void testTLSClientCertRequiredNoClientCert ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . JKS , KeyCert . JKS , Trust . JKS , true , false , false , false , false ) ; } @ Test public void testTLSClientCertClientNotTrusted ( ) throws Exception { testTLS ( KeyCert . JKS , Trust . JKS , KeyCert . JKS , Trust . NONE , true , false , false , false , false ) ; } @ Test public void testTLSClientRevokedServerCert ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . PEM_CA , KeyCert . PEM_CA , Trust . NONE , false , false , false , true , false ) ; } @ Test public void testTLSRevokedClientCertServer ( ) throws Exception { testTLS ( KeyCert . PEM_CA , Trust . JKS , KeyCert . JKS , Trust . PEM_CA , true , true , false , false , false ) ; } @ Test public void testTLSCipherSuites ( ) throws Exception { testTLS ( KeyCert . NONE , Trust . NONE , KeyCert . JKS , Trust . NONE , false , false , true , false , true , ENABLED_CIPHER_SUITES ) ; } private void testTLS ( KeyCert clientCert , Trust clientTrust , KeyCert serverCert , Trust serverTrust , boolean requireClientAuth , boolean serverUsesCrl , boolean clientTrustAll , boolean clientUsesCrl , boolean shouldPass , String ... enabledCipherSuites ) throws Exception { client . close ( ) ; server . close ( ) ; HttpClientOptions options = new HttpClientOptions ( ) ; options . setSsl ( true ) ; if ( clientTrustAll ) { options . setTrustAll ( true ) ; } if ( clientUsesCrl ) { options . addCrlPath ( findFileOnClasspath ( "tls/ca/crl.pem" ) ) ; } setOptions ( options , getClientTrustOptions ( clientTrust ) ) ; setOptions ( options , getClientCertOptions ( clientCert ) ) ; for ( String suite : enabledCipherSuites ) { options . addEnabledCipherSuite ( suite ) ; } client = vertx . createHttpClient ( options ) ; HttpServerOptions serverOptions = new HttpServerOptions ( ) ; serverOptions . setSsl ( true ) ; setOptions ( serverOptions , getServerTrustOptions ( serverTrust ) ) ; setOptions ( serverOptions , getServerCertOptions ( serverCert ) ) ; if ( requireClientAuth ) { serverOptions . setClientAuthRequired ( true ) ; } if ( serverUsesCrl ) { serverOptions . addCrlPath ( findFileOnClasspath ( "tls/ca/crl.pem" ) ) ; } for ( String suite : enabledCipherSuites ) { serverOptions . addEnabledCipherSuite ( suite ) ; } server = vertx . createHttpServer ( serverOptions . setPort ( 4043 ) ) ; server . requestHandler ( req - > { req . bodyHandler ( buffer - > { assertEquals ( "foo" , buffer . toString ( ) ) ; req . response ( ) . end ( "bar" ) ; } ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; HttpClientRequest req = client . request ( HttpMethod . GET , 4043 , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , response - > { response . bodyHandler ( data - > assertEquals ( "bar" , data . toString ( ) ) ) ; testComplete ( ) ; } ) ; req . exceptionHandler ( t - > { if ( shouldPass ) { t . printStackTrace ( ) ; fail ( "Should not throw exception" ) ; } else { testComplete ( ) ; } } ) ; req . end ( "foo" ) ; } ) ; await ( ) ; } @ Test public void testJKSInvalidPath ( ) { testInvalidKeyStore ( ( ( JksOptions ) getServerCertOptions ( KeyCert . JKS ) ) . setPath ( "/invalid.jks" ) , "java.nio.file.NoSuchFileException: " , "invalid.jks" ) ; } @ Test public void testJKSMissingPassword ( ) { testInvalidKeyStore ( ( ( JksOptions ) getServerCertOptions ( KeyCert . JKS ) ) . setPassword ( null ) , "Password must not be null" , null ) ; } @ Test public void testJKSInvalidPassword ( ) { testInvalidKeyStore ( ( ( JksOptions ) getServerCertOptions ( KeyCert . JKS ) ) . setPassword ( "wrongpassword" ) , "Keystore was tampered with, or password was incorrect" , null ) ; } @ Test public void testPKCS12InvalidPath ( ) { testInvalidKeyStore ( ( ( PfxOptions ) getServerCertOptions ( KeyCert . PKCS12 ) ) . setPath ( "/invalid.p12" ) , "java.nio.file.NoSuchFileException: " , "invalid.p12" ) ; } @ Test public void testPKCS12MissingPassword ( ) { testInvalidKeyStore ( ( ( PfxOptions ) getServerCertOptions ( KeyCert . PKCS12 ) ) . setPassword ( null ) , "Get Key failed: null" , null ) ; } @ Test public void testPKCS12InvalidPassword ( ) { testInvalidKeyStore ( ( ( PfxOptions ) getServerCertOptions ( KeyCert . PKCS12 ) ) . setPassword ( "wrongpassword" ) , "failed to decrypt safe contents entry: javax.crypto.BadPaddingException: Given final block not properly padded" , null ) ; } @ Test public void testKeyCertMissingKeyPath ( ) { testInvalidKeyStore ( ( ( PemKeyCertOptions ) getServerCertOptions ( KeyCert . PEM ) ) . setKeyPath ( null ) , "Missing private key" , null ) ; } @ Test public void testKeyCertInvalidKeyPath ( ) { testInvalidKeyStore ( ( ( PemKeyCertOptions ) getServerCertOptions ( KeyCert . PEM ) ) . setKeyPath ( "/invalid.pem" ) , "java.nio.file.NoSuchFileException: " , "invalid.pem" ) ; } @ Test public void testKeyCertMissingCertPath ( ) { testInvalidKeyStore ( ( ( PemKeyCertOptions ) getServerCertOptions ( KeyCert . PEM ) ) . setCertPath ( null ) , "Missing X.509 certificate" , null ) ; } @ Test public void testKeyCertInvalidCertPath ( ) { testInvalidKeyStore ( ( ( PemKeyCertOptions ) getServerCertOptions ( KeyCert . PEM ) ) . setCertPath ( "/invalid.pem" ) , "java.nio.file.NoSuchFileException: " , "invalid.pem" ) ; } @ Test public void testKeyCertInvalidPem ( ) throws IOException { String [ ] contents = { "" , "-----BEGIN PRIVATE KEY-----" , "-----BEGIN PRIVATE KEY-----\n-----END PRIVATE KEY-----" , "-----BEGIN PRIVATE KEY-----\n*\n-----END PRIVATE KEY-----" } ; String [ ] messages = { "Missing -----BEGIN PRIVATE KEY----- delimiter" , "Missing -----END PRIVATE KEY----- delimiter" , "Empty pem file" , "Input byte[] should at least have 2 bytes for base64 bytes" } ; for ( int i = 0 ; i < contents . length ; i ++ ) { Path file = testFolder . newFile ( "vertx" + UUID . randomUUID ( ) . toString ( ) + ".pem" ) . toPath ( ) ; Files . write ( file , Collections . singleton ( contents [ i ] ) ) ; String expectedMessage = messages [ i ] ; testInvalidKeyStore ( ( ( PemKeyCertOptions ) getServerCertOptions ( KeyCert . PEM ) ) . setKeyPath ( file . toString ( ) ) , expectedMessage , null ) ; } } @ Test public void testCaInvalidPath ( ) { testInvalidTrustStore ( new PemTrustOptions ( ) . addCertPath ( "/invalid.pem" ) , "java.nio.file.NoSuchFileException: " , "invalid.pem" ) ; } @ Test public void testCaInvalidPem ( ) throws IOException { String [ ] contents = { "" , "-----BEGIN CERTIFICATE-----" , "-----BEGIN CERTIFICATE-----\n-----END CERTIFICATE-----" , "-----BEGIN CERTIFICATE-----\n*\n-----END CERTIFICATE-----" } ; String [ ] messages = { "Missing -----BEGIN CERTIFICATE----- delimiter" , "Missing -----END CERTIFICATE----- delimiter" , "Empty pem file" , "Input byte[] should at least have 2 bytes for base64 bytes" } ; for ( int i = 0 ; i < contents . length ; i ++ ) { Path file = testFolder . newFile ( "vertx" + UUID . randomUUID ( ) . toString ( ) + ".pem" ) . toPath ( ) ; Files . write ( file , Collections . singleton ( contents [ i ] ) ) ; String expectedMessage = messages [ i ] ; testInvalidTrustStore ( new PemTrustOptions ( ) . addCertPath ( file . toString ( ) ) , expectedMessage , null ) ; } } private void testInvalidKeyStore ( KeyCertOptions options , String expectedPrefix , String expectedSuffix ) { HttpServerOptions serverOptions = new HttpServerOptions ( ) ; setOptions ( serverOptions , options ) ; serverOptions . setSsl ( true ) ; serverOptions . setPort ( 4043 ) ; testStore ( serverOptions , expectedPrefix , expectedSuffix ) ; } private void testInvalidTrustStore ( TrustOptions options , String expectedPrefix , String expectedSuffix ) { HttpServerOptions serverOptions = new HttpServerOptions ( ) ; setOptions ( serverOptions , options ) ; serverOptions . setSsl ( true ) ; serverOptions . setPort ( 4043 ) ; testStore ( serverOptions , expectedPrefix , expectedSuffix ) ; } private void testStore ( HttpServerOptions serverOptions , String expectedPrefix , String expectedSuffix ) { HttpServer server = vertx . createHttpServer ( serverOptions ) ; server . requestHandler ( req - > { } ) ; try { server . listen ( ) ; fail ( "Was expecting a failure" ) ; } catch ( VertxException e ) { assertNotNull ( e . getCause ( ) ) ; if ( expectedSuffix == null ) assertEquals ( expectedPrefix , e . getCause ( ) . getMessage ( ) ) ; else { assertTrue ( e . getCause ( ) . getMessage ( ) . startsWith ( expectedPrefix ) ) ; assertTrue ( e . getCause ( ) . getMessage ( ) . endsWith ( expectedSuffix ) ) ; } } } @ Test public void testCrlInvalidPath ( ) throws Exception { HttpClientOptions clientOptions = new HttpClientOptions ( ) ; setOptions ( clientOptions , getClientTrustOptions ( Trust . PEM_CA ) ) ; clientOptions . setSsl ( true ) ; clientOptions . addCrlPath ( "/invalid.pem" ) ; HttpClient client = vertx . createHttpClient ( clientOptions ) ; HttpClientRequest req = client . request ( HttpMethod . CONNECT , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/" , ( handler ) - > { } ) ; try { req . end ( ) ; fail ( "Was expecting a failure" ) ; } catch ( VertxException e ) { assertNotNull ( e . getCause ( ) ) ; assertEquals ( NoSuchFileException . class , e . getCause ( ) . getCause ( ) . getClass ( ) ) ; } } @ Test public void testConnectInvalidPort ( ) { client . request ( HttpMethod . GET , 9998 , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > fail ( "Connect should not be called" ) ) . exceptionHandler ( t - > testComplete ( ) ) . end ( ) ; await ( ) ; } @ Test public void testConnectInvalidHost ( ) { client . request ( HttpMethod . GET , 9998 , "255.255.255.255" , DEFAULT_TEST_URI , resp - > fail ( "Connect should not be called" ) ) . exceptionHandler ( t - > testComplete ( ) ) . end ( ) ; await ( ) ; } @ Test public void testSetHandlersAfterListening ( ) throws Exception { server . requestHandler ( noOpHandler ( ) ) ; server . listen ( onSuccess ( s - > { assertIllegalStateException ( ( ) - > server . requestHandler ( noOpHandler ( ) ) ) ; assertIllegalStateException ( ( ) - > server . websocketHandler ( noOpHandler ( ) ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testSetHandlersAfterListening2 ( ) throws Exception { server . requestHandler ( noOpHandler ( ) ) ; server . listen ( ) ; assertIllegalStateException ( ( ) - > server . requestHandler ( noOpHandler ( ) ) ) ; assertIllegalStateException ( ( ) - > server . websocketHandler ( noOpHandler ( ) ) ) ; } @ Test public void testListenNoHandlers ( ) throws Exception { assertIllegalStateException ( ( ) - > server . listen ( ar - > { } ) ) ; } @ Test public void testListenNoHandlers2 ( ) throws Exception { assertIllegalStateException ( ( ) - > server . listen ( ) ) ; } @ Test public void testListenTwice ( ) throws Exception { server . requestHandler ( noOpHandler ( ) ) ; server . listen ( ) ; assertIllegalStateException ( ( ) - > server . listen ( ) ) ; } @ Test public void testListenTwice2 ( ) throws Exception { server . requestHandler ( noOpHandler ( ) ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; assertIllegalStateException ( ( ) - > server . listen ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testSharedServersRoundRobin ( ) throws Exception { client . close ( ) ; server . close ( ) ; client = vertx . createHttpClient ( new HttpClientOptions ( ) . setKeepAlive ( false ) ) ; int numServers = 5 ; int numRequests = numServers * 100 ; List < HttpServer > servers = new ArrayList < > ( ) ; Set < HttpServer > connectedServers = Collections . newSetFromMap ( new ConcurrentHashMap < > ( ) ) ; Map < HttpServer , Integer > requestCount = new ConcurrentHashMap < > ( ) ; CountDownLatch latchListen = new CountDownLatch ( numServers ) ; CountDownLatch latchConns = new CountDownLatch ( numRequests ) ; Set < Context > contexts = new ConcurrentHashSet < > ( ) ; for ( int i = 0 ; i < numServers ; i ++ ) { HttpServer theServer = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( DEFAULT_HTTP_PORT ) ) ; servers . add ( theServer ) ; final AtomicReference < Context > context = new AtomicReference < > ( ) ; theServer . requestHandler ( req - > { Context ctx = Vertx . currentContext ( ) ; if ( context . get ( ) != null ) { assertSame ( ctx , context . get ( ) ) ; } else { context . set ( ctx ) ; contexts . add ( ctx ) ; } connectedServers . add ( theServer ) ; Integer cnt = requestCount . get ( theServer ) ; int icnt = cnt == null ? 0 : cnt ; icnt ++ ; requestCount . put ( theServer , icnt ) ; latchConns . countDown ( ) ; req . response ( ) . end ( ) ; } ) . listen ( onSuccess ( s - > latchListen . countDown ( ) ) ) ; } assertTrue ( latchListen . await ( 10 , TimeUnit . SECONDS ) ) ; CountDownLatch latchClient = new CountDownLatch ( numRequests ) ; for ( int i = 0 ; i < numRequests ; i ++ ) { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , res - > latchClient . countDown ( ) ) . end ( ) ; } assertTrue ( latchClient . await ( 10 , TimeUnit . SECONDS ) ) ; assertTrue ( latchConns . await ( 10 , TimeUnit . SECONDS ) ) ; assertEquals ( numServers , connectedServers . size ( ) ) ; for ( HttpServer server : servers ) { assertTrue ( connectedServers . contains ( server ) ) ; } assertEquals ( numServers , requestCount . size ( ) ) ; for ( int cnt : requestCount . values ( ) ) { assertEquals ( numRequests / numServers , cnt ) ; } assertEquals ( numServers , contexts . size ( ) ) ; CountDownLatch closeLatch = new CountDownLatch ( numServers ) ; for ( HttpServer server : servers ) { server . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; closeLatch . countDown ( ) ; } ) ; } assertTrue ( closeLatch . await ( 10 , TimeUnit . SECONDS ) ) ; testComplete ( ) ; } @ Test public void testSharedServersRoundRobinWithOtherServerRunningOnDifferentPort ( ) throws Exception { CountDownLatch latch = new CountDownLatch ( 1 ) ; HttpServer theServer = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( 8081 ) ) ; theServer . requestHandler ( req - > { fail ( "Should not process request" ) ; } ) . listen ( onSuccess ( s - > latch . countDown ( ) ) ) ; awaitLatch ( latch ) ; testSharedServersRoundRobin ( ) ; } @ Test public void testSharedServersRoundRobinButFirstStartAndStopServer ( ) throws Exception { CountDownLatch latch = new CountDownLatch ( 1 ) ; HttpServer theServer = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( DEFAULT_HTTP_PORT ) ) ; theServer . requestHandler ( req - > { fail ( "Should not process request" ) ; } ) . listen ( onSuccess ( s - > latch . countDown ( ) ) ) ; awaitLatch ( latch ) ; CountDownLatch closeLatch = new CountDownLatch ( 1 ) ; theServer . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; closeLatch . countDown ( ) ; } ) ; assertTrue ( closeLatch . await ( 10 , TimeUnit . SECONDS ) ) ; testSharedServersRoundRobin ( ) ; } @ Test public void testHeadNoBody ( ) { server . requestHandler ( req - > { assertEquals ( HttpMethod . HEAD , req . method ( ) ) ; req . response ( ) . headers ( ) . set ( "Content-Length" , String . valueOf ( 41 ) ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . HEAD , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { assertEquals ( 41 , Integer . parseInt ( resp . headers ( ) . get ( "Content-Length" ) ) ) ; resp . endHandler ( v - > testComplete ( ) ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testRemoteAddress ( ) { server . requestHandler ( req - > { assertEquals ( "127.0.0.1" , req . remoteAddress ( ) . host ( ) ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > resp . endHandler ( v - > testComplete ( ) ) ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testGetAbsoluteURI ( ) { server . requestHandler ( req - > { assertEquals ( "http://localhost:" + DEFAULT_HTTP_PORT + "/foo/bar" , req . absoluteURI ( ) . toString ( ) ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/foo/bar" , resp - > resp . endHandler ( v - > testComplete ( ) ) ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testListenInvalidPort ( ) throws Exception { Assume . assumeFalse ( System . getProperty ( "os.name" ) . startsWith ( "Windows" ) ) ; server . close ( ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( 7 ) ) ; server . requestHandler ( noOpHandler ( ) ) . listen ( onFailure ( server - > testComplete ( ) ) ) ; await ( ) ; } @ Test public void testListenInvalidHost ( ) { server . close ( ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( DEFAULT_HTTP_PORT ) . setHost ( "iqwjdoqiwjdoiqwdiojwd" ) ) ; server . requestHandler ( noOpHandler ( ) ) ; server . listen ( onFailure ( s - > testComplete ( ) ) ) ; } @ Test public void testPauseClientResponse ( ) { int numWrites = 10 ; int numBytes = 100 ; server . requestHandler ( req - > { req . response ( ) . setChunked ( true ) ; for ( int i = 0 ; i < numWrites ; i ++ ) { req . response ( ) . write ( TestUtils . randomBuffer ( numBytes ) ) ; } req . response ( ) . end ( ) ; } ) ; AtomicBoolean paused = new AtomicBoolean ( ) ; Buffer totBuff = Buffer . buffer ( ) ; HttpClientRequest clientRequest = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . pause ( ) ; paused . set ( true ) ; resp . handler ( chunk - > { if ( paused . get ( ) ) { fail ( "Shouldn't receive chunks when paused" ) ; } else { totBuff . appendBuffer ( chunk ) ; } } ) ; resp . endHandler ( v - > { if ( paused . get ( ) ) { fail ( "Shouldn't receive chunks when paused" ) ; } else { assertEquals ( numWrites * numBytes , totBuff . length ( ) ) ; testComplete ( ) ; } } ) ; vertx . setTimer ( 500 , id - > { paused . set ( false ) ; resp . resume ( ) ; } ) ; } ) ; server . listen ( onSuccess ( s - > clientRequest . end ( ) ) ) ; await ( ) ; } @ Test public void testHttpVersion ( ) { server . requestHandler ( req - > { assertEquals ( HttpVersion . HTTP_1_1 , req . version ( ) ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > resp . endHandler ( v - > testComplete ( ) ) ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testFormUploadSmallFile ( ) throws Exception { testFormUploadFile ( TestUtils . randomAlphaString ( 100 ) , false ) ; } @ Test public void testFormUploadLargerFile ( ) throws Exception { testFormUploadFile ( TestUtils . randomAlphaString ( 20000 ) , false ) ; } @ Test public void testFormUploadSmallFileStreamToDisk ( ) throws Exception { testFormUploadFile ( TestUtils . randomAlphaString ( 100 ) , true ) ; } @ Test public void testFormUploadLargerFileStreamToDisk ( ) throws Exception { testFormUploadFile ( TestUtils . randomAlphaString ( 20000 ) , true ) ; } private void testFormUploadFile ( String contentStr , boolean streamToDisk ) throws Exception { Buffer content = Buffer . buffer ( contentStr ) ; AtomicInteger attributeCount = new AtomicInteger ( ) ; server . requestHandler ( req - > { if ( req . method ( ) == HttpMethod . POST ) { assertEquals ( req . path ( ) , "/form" ) ; req . response ( ) . setChunked ( true ) ; req . setExpectMultipart ( true ) ; assertTrue ( req . isExpectMultipart ( ) ) ; req . setExpectMultipart ( true ) ; assertTrue ( req . isExpectMultipart ( ) ) ; req . uploadHandler ( upload - > { Buffer tot = Buffer . buffer ( ) ; assertEquals ( "file" , upload . name ( ) ) ; assertEquals ( "tmp-0.txt" , upload . filename ( ) ) ; assertEquals ( "image/gif" , upload . contentType ( ) ) ; String uploadedFileName ; if ( ! streamToDisk ) { upload . handler ( buffer - > tot . appendBuffer ( buffer ) ) ; uploadedFileName = null ; } else { uploadedFileName = new File ( testDir , UUID . randomUUID ( ) . toString ( ) ) . getPath ( ) ; upload . streamToFileSystem ( uploadedFileName ) ; } upload . endHandler ( v - > { if ( streamToDisk ) { Buffer uploaded = vertx . fileSystem ( ) . readFileBlocking ( uploadedFileName ) ; assertEquals ( content , uploaded ) ; } else { assertEquals ( content , tot ) ; } assertTrue ( upload . isSizeAvailable ( ) ) ; assertEquals ( content . length ( ) , upload . size ( ) ) ; } ) ; } ) ; req . endHandler ( v - > { MultiMap attrs = req . formAttributes ( ) ; attributeCount . set ( attrs . size ( ) ) ; req . response ( ) . end ( ) ; } ) ; } } ) ; server . listen ( onSuccess ( s - > { HttpClientRequest req = client . request ( HttpMethod . POST , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/form" , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; resp . bodyHandler ( body - > { assertEquals ( 0 , body . length ( ) ) ; } ) ; assertEquals ( 0 , attributeCount . get ( ) ) ; testComplete ( ) ; } ) ; String boundary = "dLV9Wyq26L_-JQxk6ferf-RT153LhOO" ; Buffer buffer = Buffer . buffer ( ) ; String body = "--" + boundary + "\r\n" + "Content-Disposition: form-data; name=\"file\"; filename=\"tmp-0.txt\"\r\n" + "Content-Type: image/gif\r\n" + "\r\n" + contentStr + "\r\n" + "--" + boundary + "--\r\n" ; buffer . appendString ( body ) ; req . headers ( ) . set ( "content-length" , String . valueOf ( buffer . length ( ) ) ) ; req . headers ( ) . set ( "content-type" , "multipart/form-data; boundary=" + boundary ) ; req . write ( buffer ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testFormUploadAttributes ( ) throws Exception { AtomicInteger attributeCount = new AtomicInteger ( ) ; server . requestHandler ( req - > { if ( req . method ( ) == HttpMethod . POST ) { assertEquals ( req . path ( ) , "/form" ) ; req . response ( ) . setChunked ( true ) ; req . setExpectMultipart ( true ) ; req . uploadHandler ( upload - > upload . handler ( buffer - > { fail ( "Should get here" ) ; } ) ) ; req . endHandler ( v - > { MultiMap attrs = req . formAttributes ( ) ; attributeCount . set ( attrs . size ( ) ) ; assertEquals ( "vert x" , attrs . get ( "framework" ) ) ; assertEquals ( "vert x" , req . getFormAttribute ( "framework" ) ) ; assertEquals ( "jvm" , attrs . get ( "runson" ) ) ; assertEquals ( "jvm" , req . getFormAttribute ( "runson" ) ) ; req . response ( ) . end ( ) ; } ) ; } } ) ; server . listen ( onSuccess ( s - > { HttpClientRequest req = client . request ( HttpMethod . POST , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/form" , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; resp . bodyHandler ( body - > { assertEquals ( 0 , body . length ( ) ) ; } ) ; assertEquals ( 2 , attributeCount . get ( ) ) ; testComplete ( ) ; } ) ; try { Buffer buffer = Buffer . buffer ( ) ; buffer . appendString ( "framework=" + URLEncoder . encode ( "vert x" , "UTF-8" ) + "&runson=jvm" , "UTF-8" ) ; req . headers ( ) . set ( "content-length" , String . valueOf ( buffer . length ( ) ) ) ; req . headers ( ) . set ( "content-type" , "application/x-www-form-urlencoded" ) ; req . write ( buffer ) . end ( ) ; } catch ( UnsupportedEncodingException e ) { fail ( e . getMessage ( ) ) ; } } ) ) ; await ( ) ; } @ Test public void testFormUploadAttributes2 ( ) throws Exception { AtomicInteger attributeCount = new AtomicInteger ( ) ; server . requestHandler ( req - > { if ( req . method ( ) == HttpMethod . POST ) { assertEquals ( req . path ( ) , "/form" ) ; req . setExpectMultipart ( true ) ; req . uploadHandler ( event - > event . handler ( buffer - > { fail ( "Should not get here" ) ; } ) ) ; req . endHandler ( v - > { MultiMap attrs = req . formAttributes ( ) ; attributeCount . set ( attrs . size ( ) ) ; assertEquals ( "junit-testUserAlias" , attrs . get ( "origin" ) ) ; assertEquals ( "admin@foo.bar" , attrs . get ( "login" ) ) ; assertEquals ( "admin" , attrs . get ( "pass word" ) ) ; req . response ( ) . end ( ) ; } ) ; } } ) ; server . listen ( onSuccess ( s - > { HttpClientRequest req = client . request ( HttpMethod . POST , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/form" , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; resp . bodyHandler ( body - > { assertEquals ( 0 , body . length ( ) ) ; } ) ; assertEquals ( 3 , attributeCount . get ( ) ) ; testComplete ( ) ; } ) ; Buffer buffer = Buffer . buffer ( ) ; buffer . appendString ( "origin=junit-testUserAlias&login=admin%40foo.bar&pass+word=admin" ) ; req . headers ( ) . set ( "content-length" , String . valueOf ( buffer . length ( ) ) ) ; req . headers ( ) . set ( "content-type" , "application/x-www-form-urlencoded" ) ; req . write ( buffer ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testAccessNetSocket ( ) throws Exception { Buffer toSend = TestUtils . randomBuffer ( 1000 ) ; server . requestHandler ( req - > { req . response ( ) . headers ( ) . set ( "HTTP/1.1" , "101 Upgrade" ) ; req . bodyHandler ( data - > { assertEquals ( toSend , data ) ; req . response ( ) . end ( ) ; } ) ; } ) ; server . listen ( onSuccess ( s - > { HttpClientRequest req = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . endHandler ( v - > { assertNotNull ( resp . netSocket ( ) ) ; testComplete ( ) ; } ) ; } ) ; req . headers ( ) . set ( "content-length" , String . valueOf ( toSend . length ( ) ) ) ; req . write ( toSend ) ; } ) ) ; await ( ) ; } @ Test public void testHostHeaderOverridePossible ( ) { server . requestHandler ( req - > { assertEquals ( "localhost:4444" , req . headers ( ) . get ( "Host" ) ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( s - > { HttpClientRequest req = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > testComplete ( ) ) ; req . putHeader ( "Host" , "localhost:4444" ) ; req . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testResponseBodyWriteFixedString ( ) { String body = "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum." ; Buffer bodyBuff = Buffer . buffer ( body ) ; server . requestHandler ( req - > { req . response ( ) . setChunked ( true ) ; req . response ( ) . write ( body ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { resp . bodyHandler ( buff - > { assertEquals ( bodyBuff , buff ) ; testComplete ( ) ; } ) ; } ) . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testHttpConnect ( ) { Buffer buffer = TestUtils . randomBuffer ( 128 ) ; Buffer received = Buffer . buffer ( ) ; vertx . createNetServer ( new NetServerOptions ( ) . setPort ( 1235 ) ) . connectHandler ( socket - > { socket . handler ( socket : : write ) ; } ) . listen ( onSuccess ( netServer - > { server . requestHandler ( req - > { vertx . createNetClient ( new NetClientOptions ( ) ) . connect ( netServer . actualPort ( ) , "localhost" , onSuccess ( socket - > { req . response ( ) . setStatusCode ( 200 ) ; req . response ( ) . setStatusMessage ( "Connection established" ) ; req . response ( ) . end ( ) ; Pump . pump ( req . netSocket ( ) , socket ) . start ( ) ; Pump . pump ( socket , req . netSocket ( ) ) . start ( ) ; req . netSocket ( ) . closeHandler ( v - > socket . close ( ) ) ; } ) ) ; } ) ; server . listen ( onSuccess ( s - > { client . request ( HttpMethod . CONNECT , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; NetSocket socket = resp . netSocket ( ) ; socket . handler ( buff - > { received . appendBuffer ( buff ) ; if ( received . length ( ) == buffer . length ( ) ) { netServer . close ( ) ; assertEquals ( buffer , received ) ; testComplete ( ) ; } } ) ; socket . write ( buffer ) ; } ) . end ( ) ; } ) ) ; } ) ) ; await ( ) ; } @ Test public void testRequestsTimeoutInQueue ( ) { server . requestHandler ( req - > { vertx . setTimer ( 1000 , id - > { req . response ( ) . end ( ) ; } ) ; } ) ; client . close ( ) ; client = vertx . createHttpClient ( new HttpClientOptions ( ) . setKeepAlive ( false ) . setMaxPoolSize ( 1 ) ) ; server . listen ( onSuccess ( s - > { for ( int i = 0 ; i < 5 ; i ++ ) { HttpClientRequest req = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { fail ( "Should not be called" ) ; } ) ; req . exceptionHandler ( t - > assertTrue ( t instanceof TimeoutException ) ) ; req . setTimeout ( 500 ) ; req . end ( ) ; } HttpClientRequest req = client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , DEFAULT_TEST_URI , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; testComplete ( ) ; } ) ; req . exceptionHandler ( t - > fail ( "Should not throw exception" ) ) ; req . setTimeout ( 3000 ) ; req . end ( ) ; } ) ) ; await ( ) ; } @ Test public void testServerOptionsCopiedBeforeUse ( ) { server . close ( ) ; HttpServerOptions options = new HttpServerOptions ( ) . setHost ( DEFAULT_HTTP_HOST ) . setPort ( DEFAULT_HTTP_PORT ) ; HttpServer server = vertx . createHttpServer ( options ) ; options . setPort ( DEFAULT_HTTP_PORT + 1 ) ; server . requestHandler ( req - > { req . response ( ) . end ( ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/uri" , res - > { assertEquals ( 200 , res . statusCode ( ) ) ; testComplete ( ) ; } ) . end ( ) ; } ) ; await ( ) ; } @ Test public void testClientOptionsCopiedBeforeUse ( ) { client . close ( ) ; server . requestHandler ( req - > { req . response ( ) . end ( ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; HttpClientOptions options = new HttpClientOptions ( ) ; client = vertx . createHttpClient ( options ) ; options . setSsl ( true ) ; client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/uri" , res - > { assertEquals ( 200 , res . statusCode ( ) ) ; testComplete ( ) ; } ) . end ( ) ; } ) ; await ( ) ; } @ Test public void testClientMultiThreaded ( ) throws Exception { int numThreads = 10 ; Thread [ ] threads = new Thread [ numThreads ] ; CountDownLatch latch = new CountDownLatch ( numThreads ) ; server . requestHandler ( req - > { req . response ( ) . putHeader ( "count" , req . headers ( ) . get ( "count" ) ) ; req . response ( ) . end ( ) ; } ) . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; for ( int i = 0 ; i < numThreads ; i ++ ) { int index = i ; threads [ i ] = new Thread ( ) { public void run ( ) { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/" , res - > { assertEquals ( 200 , res . statusCode ( ) ) ; assertEquals ( String . valueOf ( index ) , res . headers ( ) . get ( "count" ) ) ; latch . countDown ( ) ; } ) . putHeader ( "count" , String . valueOf ( index ) ) . end ( ) ; } } ; threads [ i ] . start ( ) ; } } ) ; awaitLatch ( latch ) ; for ( int i = 0 ; i < numThreads ; i ++ ) { threads [ i ] . join ( ) ; } } @ Test public void testInVerticle ( ) throws Exception { testInVerticle ( false ) ; } private void testInVerticle ( boolean worker ) throws Exception { client . close ( ) ; server . close ( ) ; class MyVerticle extends AbstractVerticle { Context ctx ; @ Override public void start ( ) { ctx = Vertx . currentContext ( ) ; if ( worker ) { assertTrue ( ctx instanceof WorkerContext ) ; } else { assertTrue ( ctx instanceof EventLoopContext ) ; } Thread thr = Thread . currentThread ( ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( DEFAULT_HTTP_PORT ) ) ; server . requestHandler ( req - > { req . response ( ) . end ( ) ; assertSame ( ctx , Vertx . currentContext ( ) ) ; if ( ! worker ) { assertSame ( thr , Thread . currentThread ( ) ) ; } } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; assertSame ( ctx , Vertx . currentContext ( ) ) ; if ( ! worker ) { assertSame ( thr , Thread . currentThread ( ) ) ; } client = vertx . createHttpClient ( new HttpClientOptions ( ) ) ; client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/" , res - > { assertSame ( ctx , Vertx . currentContext ( ) ) ; if ( ! worker ) { assertSame ( thr , Thread . currentThread ( ) ) ; } assertEquals ( 200 , res . statusCode ( ) ) ; testComplete ( ) ; } ) . end ( ) ; } ) ; } } MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setWorker ( worker ) ) ; await ( ) ; } @ Test public void testUseInMultithreadedWorker ( ) throws Exception { class MyVerticle extends AbstractVerticle { @ Override public void start ( ) { assertIllegalStateException ( ( ) - > server = vertx . createHttpServer ( new HttpServerOptions ( ) ) ) ; assertIllegalStateException ( ( ) - > client = vertx . createHttpClient ( new HttpClientOptions ( ) ) ) ; testComplete ( ) ; } } MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setWorker ( true ) . setMultiThreaded ( true ) ) ; await ( ) ; } @ Test public void testContexts ( ) throws Exception { Set < ContextImpl > contexts = new ConcurrentHashSet < > ( ) ; AtomicInteger cnt = new AtomicInteger ( ) ; AtomicReference < ContextImpl > serverRequestContext = new AtomicReference < > ( ) ; server . requestHandler ( req - > { ContextImpl serverContext = ( ( VertxInternal ) vertx ) . getContext ( ) ; if ( serverRequestContext . get ( ) != null ) { assertSame ( serverRequestContext . get ( ) , serverContext ) ; } else { serverRequestContext . set ( serverContext ) ; } req . response ( ) . end ( ) ; } ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; AtomicReference < ContextImpl > listenContext = new AtomicReference < > ( ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; listenContext . set ( ( ( VertxInternal ) vertx ) . getContext ( ) ) ; latch . countDown ( ) ; } ) ; awaitLatch ( latch ) ; CountDownLatch latch2 = new CountDownLatch ( 1 ) ; int numReqs = 16 ; int numConns = 8 ; client . close ( ) ; client = vertx . createHttpClient ( new HttpClientOptions ( ) . setMaxPoolSize ( numConns ) ) ; for ( int i = 0 ; i < numReqs ; i ++ ) { client . request ( HttpMethod . GET , DEFAULT_HTTP_PORT , DEFAULT_HTTP_HOST , "/" , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; contexts . add ( ( ( VertxInternal ) vertx ) . getContext ( ) ) ; if ( cnt . incrementAndGet ( ) == numReqs ) { assertTrue ( contexts . size ( ) >= numConns ) ; latch2 . countDown ( ) ; } } ) . end ( ) ; } awaitLatch ( latch2 ) ; server . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; ContextImpl closeContext = ( ( VertxInternal ) vertx ) . getContext ( ) ; assertFalse ( contexts . contains ( closeContext ) ) ; assertNotSame ( serverRequestContext . get ( ) , closeContext ) ; assertFalse ( contexts . contains ( listenContext . get ( ) ) ) ; assertSame ( serverRequestContext . get ( ) , listenContext . get ( ) ) ; testComplete ( ) ; } ) ; server = null ; await ( ) ; } @ Test public void testRequestHandlerNotCalledInvalidRequest ( ) { server . requestHandler ( req - > { fail ( ) ; } ) ; server . listen ( onSuccess ( s - > { vertx . createNetClient ( new NetClientOptions ( ) ) . connect ( 8080 , "127.0.0.1" , result - > { NetSocket socket = result . result ( ) ; socket . closeHandler ( r - > { testComplete ( ) ; } ) ; socket . write ( "GET HTTP1/1\r\n" ) ; socket . write ( "X-Header: test\r\n" ) ; } ) ; } ) ) ; await ( ) ; } @ Test public void testTwoServersSameAddressDifferentContext ( ) throws Exception { vertx . deployVerticle ( SimpleServer . class . getName ( ) , new DeploymentOptions ( ) . setInstances ( 2 ) , onSuccess ( id - > { testComplete ( ) ; } ) ) ; await ( ) ; } @ Test public void testMultipleServerClose ( ) { this . server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( DEFAULT_HTTP_PORT ) ) ; AtomicInteger times = new AtomicInteger ( ) ; ThreadLocal stack = new ThreadLocal ( ) ; stack . set ( true ) ; server . requestStream ( ) . endHandler ( v - > { assertNull ( stack . get ( ) ) ; assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; times . incrementAndGet ( ) ; } ) ; server . close ( ar1 - > { assertNull ( stack . get ( ) ) ; assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; server . close ( ar2 - > { server . close ( ar3 - > { assertEquals ( 1 , times . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testClearHandlersOnEnd ( ) { String path = "/some/path" ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; server . requestHandler ( req - > req . response ( ) . setStatusCode ( 200 ) . end ( ) ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; HttpClientRequest req = client . request ( HttpMethod . GET , HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path ) ; AtomicInteger count = new AtomicInteger ( ) ; req . handler ( resp - > { resp . endHandler ( v - > { try { resp . endHandler ( null ) ; resp . exceptionHandler ( null ) ; resp . handler ( null ) ; } catch ( Exception e ) { fail ( "Was expecting to set to null the handlers when the response is completed" ) ; return ; } if ( count . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ) ; } ) ; req . endHandler ( done - > { try { req . handler ( null ) ; req . exceptionHandler ( null ) ; req . endHandler ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; fail ( "Was expecting to set to null the handlers when the response is completed" ) ; return ; } if ( count . incrementAndGet ( ) == 2 ) { testComplete ( ) ; } } ) ; req . end ( ) ; } ) ; await ( ) ; } @ Test public void testSetHandlersOnEnd ( ) { String path = "/some/path" ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; server . requestHandler ( req - > req . response ( ) . setStatusCode ( 200 ) . end ( ) ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; HttpClientRequest req = client . request ( HttpMethod . GET , HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , path ) ; req . handler ( resp - > { } ) ; req . endHandler ( done - > { try { req . handler ( arg - > { } ) ; fail ( ) ; } catch ( Exception ignore ) { } try { req . exceptionHandler ( arg - > { } ) ; fail ( ) ; } catch ( Exception ignore ) { } try { req . endHandler ( arg - > { } ) ; fail ( ) ; } catch ( Exception ignore ) { } testComplete ( ) ; } ) ; req . end ( ) ; } ) ; await ( ) ; } @ Test public void testRequestEnded ( ) { server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; server . requestHandler ( req - > { assertFalse ( req . isEnded ( ) ) ; req . endHandler ( v - > { assertTrue ( req . isEnded ( ) ) ; try { req . endHandler ( v2 - > { } ) ; fail ( "Shouldn't be able to set end handler" ) ; } catch ( IllegalStateException e ) { } try { req . setExpectMultipart ( true ) ; fail ( "Shouldn't be able to set expect multipart" ) ; } catch ( IllegalStateException e ) { } try { req . bodyHandler ( v2 - > { } ) ; fail ( "Shouldn't be able to set body handler" ) ; } catch ( IllegalStateException e ) { } try { req . handler ( v2 - > { } ) ; fail ( "Shouldn't be able to set handler" ) ; } catch ( IllegalStateException e ) { } req . response ( ) . setStatusCode ( 200 ) . end ( ) ; } ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . getNow ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , "/blah" , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testRequestEndedNoEndHandler ( ) { server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; server . requestHandler ( req - > { assertFalse ( req . isEnded ( ) ) ; req . response ( ) . setStatusCode ( 200 ) . end ( ) ; vertx . setTimer ( 500 , v - > { assertTrue ( req . isEnded ( ) ) ; try { req . endHandler ( v2 - > { } ) ; fail ( "Shouldn't be able to set end handler" ) ; } catch ( IllegalStateException e ) { } try { req . setExpectMultipart ( true ) ; fail ( "Shouldn't be able to set expect multipart" ) ; } catch ( IllegalStateException e ) { } try { req . bodyHandler ( v2 - > { } ) ; fail ( "Shouldn't be able to set body handler" ) ; } catch ( IllegalStateException e ) { } try { req . handler ( v2 - > { } ) ; fail ( "Shouldn't be able to set handler" ) ; } catch ( IllegalStateException e ) { } testComplete ( ) ; } ) ; } ) ; server . listen ( ar - > { assertTrue ( ar . succeeded ( ) ) ; client . getNow ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , "/blah" , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testInWorker ( ) throws Exception { vertx . deployVerticle ( new AbstractVerticle ( ) { @ Override public void start ( ) throws Exception { assertTrue ( Vertx . currentContext ( ) . isWorkerContext ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; HttpServer server1 = vertx . createHttpServer ( new HttpServerOptions ( ) . setHost ( HttpTestBase . DEFAULT_HTTP_HOST ) . setPort ( HttpTestBase . DEFAULT_HTTP_PORT ) ) ; server1 . requestHandler ( req - > { assertTrue ( Vertx . currentContext ( ) . isWorkerContext ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; Buffer buf = Buffer . buffer ( ) ; req . handler ( buf : : appendBuffer ) ; req . endHandler ( v - > { assertEquals ( "hello" , buf . toString ( ) ) ; req . response ( ) . end ( "bye" ) ; } ) ; } ) . listen ( onSuccess ( s - > { assertTrue ( Vertx . currentContext ( ) . isWorkerContext ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; HttpClient client = vertx . createHttpClient ( ) ; client . put ( HttpTestBase . DEFAULT_HTTP_PORT , HttpTestBase . DEFAULT_HTTP_HOST , "/blah" , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; assertTrue ( Vertx . currentContext ( ) . isWorkerContext ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; resp . handler ( buf - > { assertEquals ( "bye" , buf . toString ( ) ) ; resp . endHandler ( v - > { testComplete ( ) ; } ) ; } ) ; } ) . setChunked ( true ) . write ( Buffer . buffer ( "hello" ) ) . end ( ) ; } ) ) ; } } , new DeploymentOptions ( ) . setWorker ( true ) ) ; await ( ) ; } @ Test public void testInMultithreadedWorker ( ) throws Exception { vertx . deployVerticle ( new AbstractVerticle ( ) { @ Override public void start ( ) throws Exception { assertTrue ( Vertx . currentContext ( ) . isWorkerContext ( ) ) ; assertTrue ( Vertx . currentContext ( ) . isMultiThreadedWorkerContext ( ) ) ; assertTrue ( Context . isOnWorkerThread ( ) ) ; try { vertx . createHttpServer ( ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { } try { vertx . createHttpClient ( ) ; fail ( "Should throw exception" ) ; } catch ( IllegalStateException e ) { } testComplete ( ) ; } } , new DeploymentOptions ( ) . setWorker ( true ) . setMultiThreaded ( true ) ) ; await ( ) ; } @ Test public void testAbsoluteURIServer ( ) { server . close ( ) ; server = vertx . createHttpServer ( new HttpServerOptions ( ) . setPort ( DEFAULT_HTTP_PORT ) . setHost ( "0.0.0.0" ) ) ; server . requestHandler ( req - > { String absURI = req . absoluteURI ( ) ; assertEquals ( "http://localhost:8080/path" , absURI ) ; req . response ( ) . end ( ) ; } ) ; server . listen ( onSuccess ( s - > { String host = "localhost" ; String path = "/path" ; int port = 8080 ; client . getNow ( port , host , path , resp - > { assertEquals ( 200 , resp . statusCode ( ) ) ; testComplete ( ) ; } ) ; } ) ) ; await ( ) ; } private void pausingServer ( Consumer < HttpServer > consumer ) { server . requestHandler ( req - > { req . response ( ) . setChunked ( true ) ; req . pause ( ) ; Handler < Message < Buffer > > resumeHandler = msg - > req . resume ( ) ; MessageConsumer reg = vertx . eventBus ( ) . < Buffer > consumer ( "server_resume" ) . handler ( resumeHandler ) ; req . endHandler ( v - > reg . unregister ( ) ) ; req . handler ( buff - > { req . response ( ) . write ( buff ) ; } ) ; } ) ; server . listen ( onSuccess ( consumer ) ) ; } private void drainingServer ( Consumer < HttpServer > consumer ) { server . requestHandler ( req - > { req . response ( ) . setChunked ( true ) ; assertFalse ( req . response ( ) . writeQueueFull ( ) ) ; req . response ( ) . setWriteQueueMaxSize ( 1000 ) ; Buffer buff = TestUtils . randomBuffer ( 10000 ) ; vertx . setPeriodic ( 1 , id - > { req . response ( ) . write ( buff ) ; if ( req . response ( ) . writeQueueFull ( ) ) { vertx . cancelTimer ( id ) ; req . response ( ) . drainHandler ( v - > { assertFalse ( req . response ( ) . writeQueueFull ( ) ) ; testComplete ( ) ; } ) ; vertx . eventBus ( ) . send ( "client_resume" , "" ) ; } } ) ; } ) ; server . listen ( onSuccess ( consumer ) ) ; } private static MultiMap getHeaders ( int num ) { Map < String , String > map = genMap ( num ) ; MultiMap headers = new HeadersAdaptor ( new DefaultHttpHeaders ( ) ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { headers . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return headers ; } private static Map < String , String > genMap ( int num ) { Map < String , String > map = new HashMap < > ( ) ; for ( int i = 0 ; i < num ; i ++ ) { String key ; do { key = TestUtils . randomAlphaString ( 1 + ( int ) ( ( 19 ) * Math . random ( ) ) ) . toLowerCase ( ) ; } while ( map . containsKey ( key ) ) ; map . put ( key , TestUtils . randomAlphaString ( 1 + ( int ) ( ( 19 ) * Math . random ( ) ) ) ) ; } return map ; } private static String generateQueryString ( Map < String , String > params , char delim ) { StringBuilder sb = new StringBuilder ( ) ; int count = 0 ; for ( Map . Entry < String , String > param : params . entrySet ( ) ) { sb . append ( param . getKey ( ) ) . append ( "=" ) . append ( param . getValue ( ) ) ; if ( ++ count != params . size ( ) ) { sb . append ( delim ) ; } } return sb . toString ( ) ; } private File setupFile ( String fileName , String content ) throws Exception { File file = new File ( testDir , fileName ) ; if ( file . exists ( ) ) { file . delete ( ) ; } BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( file ) , "UTF-8" ) ) ; out . write ( content ) ; out . close ( ) ; return file ; } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . dns . DnsClient ; import io . vertx . core . dns . DnsException ; import io . vertx . core . dns . DnsResponseCode ; import io . vertx . core . dns . MxRecord ; import io . vertx . core . dns . SrvRecord ; import io . vertx . test . fakedns . FakeDNSServer ; import org . junit . Test ; import java . net . InetSocketAddress ; import java . util . List ; import static io . vertx . test . core . TestUtils . assertIllegalStateException ; import static io . vertx . test . core . TestUtils . assertNullPointerException ; public class DNSTest extends VertxTestBase { private FakeDNSServer dnsServer ; @ Test public void testIllegalArguments ( ) throws Exception { DnsClient dns = prepareDns ( FakeDNSServer . testResolveAAAA ( "::1" ) ) ; assertNullPointerException ( ( ) - > dns . lookup ( null , ar - > { } ) ) ; assertNullPointerException ( ( ) - > dns . lookup4 ( null , ar - > { } ) ) ; assertNullPointerException ( ( ) - > dns . lookup6 ( null , ar - > { } ) ) ; assertNullPointerException ( ( ) - > dns . resolveA ( null , ar - > { } ) ) ; assertNullPointerException ( ( ) - > dns . resolveAAAA ( null , ar - > { } ) ) ; assertNullPointerException ( ( ) - > dns . resolveCNAME ( null , ar - > { } ) ) ; assertNullPointerException ( ( ) - > dns . resolveMX ( null , ar - > { } ) ) ; assertNullPointerException ( ( ) - > dns . resolveTXT ( null , ar - > { } ) ) ; assertNullPointerException ( ( ) - > dns . resolvePTR ( null , ar - > { } ) ) ; assertNullPointerException ( ( ) - > dns . resolveNS ( null , ar - > { } ) ) ; assertNullPointerException ( ( ) - > dns . resolveSRV ( null , ar - > { } ) ) ; dnsServer . stop ( ) ; } @ Test public void testResolveA ( ) throws Exception { final String ip = "10.0.0.1" ; DnsClient dns = prepareDns ( FakeDNSServer . testResolveA ( ip ) ) ; dns . resolveA ( "vertx.io" , ar - > { List < String > result = ar . result ( ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( ip , result . get ( 0 ) ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testResolveAAAA ( ) throws Exception { DnsClient dns = prepareDns ( FakeDNSServer . testResolveAAAA ( "::1" ) ) ; dns . resolveAAAA ( "vertx.io" , ar - > { List < String > result = ar . result ( ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( "0:0:0:0:0:0:0:1" , result . get ( 0 ) ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testResolveMX ( ) throws Exception { final String mxRecord = "mail.vertx.io" ; final int prio = 10 ; DnsClient dns = prepareDns ( FakeDNSServer . testResolveMX ( prio , mxRecord ) ) ; dns . resolveMX ( "vertx.io" , ar - > { List < MxRecord > result = ar . result ( ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; MxRecord record = result . get ( 0 ) ; assertEquals ( prio , record . priority ( ) ) ; assertEquals ( record . name ( ) , mxRecord ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testResolveTXT ( ) throws Exception { final String txt = "vertx is awesome" ; DnsClient dns = prepareDns ( FakeDNSServer . testResolveTXT ( txt ) ) ; dns . resolveTXT ( "vertx.io" , ar - > { List < String > result = ar . result ( ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( txt , result . get ( 0 ) ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testResolveNS ( ) throws Exception { final String ns = "ns.vertx.io" ; DnsClient dns = prepareDns ( FakeDNSServer . testResolveNS ( ns ) ) ; dns . resolveNS ( "vertx.io" , ar - > { List < String > result = ar . result ( ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; assertEquals ( ns , result . get ( 0 ) ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testResolveCNAME ( ) throws Exception { final String cname = "cname.vertx.io" ; DnsClient dns = prepareDns ( FakeDNSServer . testResolveCNAME ( cname ) ) ; dns . resolveCNAME ( "vertx.io" , ar - > { List < String > result = ar . result ( ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; String record = result . get ( 0 ) ; assertFalse ( record . isEmpty ( ) ) ; assertEquals ( cname , record ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testResolvePTR ( ) throws Exception { final String ptr = "ptr.vertx.io" ; DnsClient dns = prepareDns ( FakeDNSServer . testResolvePTR ( ptr ) ) ; dns . resolvePTR ( "10.0.0.1.in-addr.arpa" , ar - > { String result = ar . result ( ) ; assertNotNull ( result ) ; assertEquals ( ptr , result ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testResolveSRV ( ) throws Exception { final int priority = 10 ; final int weight = 1 ; final int port = 80 ; final String target = "vertx.io" ; DnsClient dns = prepareDns ( FakeDNSServer . testResolveSRV ( priority , weight , port , target ) ) ; dns . resolveSRV ( "vertx.io" , ar - > { List < SrvRecord > result = ar . result ( ) ; assertNotNull ( result ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 1 , result . size ( ) ) ; SrvRecord record = result . get ( 0 ) ; assertEquals ( priority , record . priority ( ) ) ; assertEquals ( weight , record . weight ( ) ) ; assertEquals ( port , record . port ( ) ) ; assertEquals ( target , record . target ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testLookup4 ( ) throws Exception { final String ip = "10.0.0.1" ; DnsClient dns = prepareDns ( FakeDNSServer . testLookup4 ( ip ) ) ; dns . lookup4 ( "vertx.io" , ar - > { String result = ar . result ( ) ; assertNotNull ( result ) ; assertEquals ( ip , result ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testLookup6 ( ) throws Exception { DnsClient dns = prepareDns ( FakeDNSServer . testLookup6 ( ) ) ; dns . lookup6 ( "vertx.io" , ar - > { String result = ar . result ( ) ; assertNotNull ( result ) ; assertEquals ( "0:0:0:0:0:0:0:1" , result ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testLookup ( ) throws Exception { final String ip = "10.0.0.1" ; DnsClient dns = prepareDns ( FakeDNSServer . testLookup ( ip ) ) ; dns . lookup ( "vertx.io" , ar - > { String result = ar . result ( ) ; assertNotNull ( result ) ; assertEquals ( ip , result ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testLookupNonExisting ( ) throws Exception { DnsClient dns = prepareDns ( FakeDNSServer . testLookupNonExisting ( ) ) ; dns . lookup ( "gfegjegjf.sg1" , ar - > { DnsException cause = ( DnsException ) ar . cause ( ) ; assertEquals ( DnsResponseCode . NXDOMAIN , cause . code ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testReverseLookupIpv4 ( ) throws Exception { String address = "10.0.0.1" ; final String ptr = "ptr.vertx.io" ; DnsClient dns = prepareDns ( FakeDNSServer . testReverseLookup ( ptr ) ) ; dns . reverseLookup ( address , ar - > { String result = ar . result ( ) ; assertNotNull ( result ) ; assertEquals ( ptr , result ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testReverseLookupIpv6 ( ) throws Exception { final String ptr = "ptr.vertx.io" ; DnsClient dns = prepareDns ( FakeDNSServer . testReverseLookup ( ptr ) ) ; dns . reverseLookup ( "::1" , ar - > { String result = ar . result ( ) ; assertNotNull ( result ) ; assertEquals ( ptr , result ) ; testComplete ( ) ; } ) ; await ( ) ; dnsServer . stop ( ) ; } @ Test public void testUseInMultithreadedWorker ( ) throws Exception { class MyVerticle extends AbstractVerticle { @ Override public void start ( ) { assertIllegalStateException ( ( ) - > vertx . createDnsClient ( 1234 , "localhost" ) ) ; testComplete ( ) ; } } MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setWorker ( true ) . setMultiThreaded ( true ) ) ; await ( ) ; } private DnsClient prepareDns ( FakeDNSServer server ) throws Exception { dnsServer = server ; dnsServer . start ( ) ; InetSocketAddress addr = ( InetSocketAddress ) dnsServer . getTransports ( ) [ 0 ] . getAcceptor ( ) . getLocalAddress ( ) ; return vertx . createDnsClient ( addr . getPort ( ) , addr . getAddress ( ) . getHostAddress ( ) ) ; } }
package io . vertx . test . core ; public class JarFileResolverTest extends FileResolverTestBase { @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; webRoot = "webroot2" ; } }
package io . vertx . test . core ; import io . vertx . core . Vertx ; import io . vertx . core . spi . cluster . ClusterManager ; import io . vertx . test . fakecluster . FakeClusterManager ; public class ClusteredSharedCounterTest extends SharedCounterTest { @ Override protected ClusterManager getClusterManager ( ) { return new FakeClusterManager ( ) ; } protected final int numNodes = 2 ; public void setUp ( ) throws Exception { super . setUp ( ) ; startNodes ( numNodes ) ; } int pos ; @ Override protected Vertx getVertx ( ) { Vertx vertx = vertices [ pos ] ; if ( ++ pos == numNodes ) { pos = 0 ; } return vertx ; } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; public class HAVerticle2 extends AbstractVerticle { @ Override public void start ( ) throws Exception { } @ Override public void stop ( ) throws Exception { } }
package io . vertx . test . core ; import io . vertx . core . Vertx ; import io . vertx . core . VertxOptions ; import io . vertx . core . metrics . MetricsOptions ; import io . vertx . core . metrics . impl . DummyVertxMetrics ; import io . vertx . core . spi . VertxMetricsFactory ; import io . vertx . core . spi . metrics . VertxMetrics ; public class ConfigurableMetricsFactory implements VertxMetricsFactory { public static VertxMetricsFactory delegate ; @ Override public VertxMetrics metrics ( Vertx vertx , VertxOptions options ) { return delegate != null ? delegate . metrics ( vertx , options ) : new DummyVertxMetrics ( ) ; } @ Override public MetricsOptions newOptions ( ) { return delegate != null ? delegate . newOptions ( ) : new MetricsOptions ( ) ; } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . json . JsonObject ; import org . junit . Test ; public class AbstractVerticleTest extends VertxTestBase { MyAbstractVerticle verticle = new MyAbstractVerticle ( ) ; @ Test public void testFieldsSet ( ) { JsonObject config = new JsonObject ( ) . put ( "foo" , "bar" ) ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setConfig ( config ) , onSuccess ( res - > { assertEquals ( res , verticle . getDeploymentID ( ) ) ; assertEquals ( config , verticle . getConfig ( ) ) ; testComplete ( ) ; } ) ) ; await ( ) ; } class MyAbstractVerticle extends AbstractVerticle { public void start ( ) { } public String getDeploymentID ( ) { return deploymentID ( ) ; } public JsonObject getConfig ( ) { return config ( ) ; } } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . Handler ; import io . vertx . core . TimeoutStream ; import io . vertx . core . Vertx ; import io . vertx . core . streams . ReadStream ; import org . junit . Test ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; public class TimerTest extends VertxTestBase { @ Test public void testTimer ( ) throws Exception { timer ( 1 ) ; } @ Test public void testPeriodic ( ) throws Exception { periodic ( 10 ) ; } @ Test public void testTimings ( ) throws Exception { final long start = System . currentTimeMillis ( ) ; final long delay = 2000 ; vertx . setTimer ( delay , timerID - > { long dur = System . currentTimeMillis ( ) - start ; assertTrue ( dur >= delay ) ; long maxDelay = delay * 2 ; assertTrue ( "Timer accuracy: " + dur + " vs " + maxDelay , dur < maxDelay ) ; vertx . cancelTimer ( timerID ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testInVerticle ( ) throws Exception { class MyVerticle extends AbstractVerticle { AtomicInteger cnt = new AtomicInteger ( ) ; @ Override public void start ( ) { Thread thr = Thread . currentThread ( ) ; vertx . setTimer ( 1 , id - > { assertSame ( thr , Thread . currentThread ( ) ) ; if ( cnt . incrementAndGet ( ) == 5 ) { testComplete ( ) ; } } ) ; vertx . setPeriodic ( 2 , id - > { assertSame ( thr , Thread . currentThread ( ) ) ; if ( cnt . incrementAndGet ( ) == 5 ) { testComplete ( ) ; } } ) ; } } MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle ) ; await ( ) ; } private void periodic ( long delay ) throws Exception { final int numFires = 10 ; final AtomicLong id = new AtomicLong ( - 1 ) ; id . set ( vertx . setPeriodic ( delay , new Handler < Long > ( ) { int count ; public void handle ( Long timerID ) { assertEquals ( id . get ( ) , timerID . longValue ( ) ) ; count ++ ; if ( count == numFires ) { vertx . cancelTimer ( timerID ) ; setEndTimer ( ) ; } if ( count > numFires ) { fail ( "Fired too many times" ) ; } } } ) ) ; await ( ) ; } private void timer ( long delay ) throws Exception { final AtomicLong id = new AtomicLong ( - 1 ) ; id . set ( vertx . setTimer ( delay , new Handler < Long > ( ) { int count ; boolean fired ; public void handle ( Long timerID ) { assertFalse ( fired ) ; fired = true ; assertEquals ( id . get ( ) , timerID . longValue ( ) ) ; assertEquals ( 0 , count ) ; count ++ ; setEndTimer ( ) ; } } ) ) ; await ( ) ; } private void setEndTimer ( ) { vertx . setTimer ( 10 , id - > testComplete ( ) ) ; } @ Test public void testTimerStreamSetHandlerSchedulesTheTimer ( ) throws Exception { vertx . runOnContext ( v - > { ReadStream < Long > timer = vertx . timerStream ( 200 ) ; AtomicBoolean handled = new AtomicBoolean ( ) ; timer . handler ( l - > { assertFalse ( handled . get ( ) ) ; handled . set ( true ) ; } ) ; timer . endHandler ( v2 - > { assertTrue ( handled . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testTimerStreamExceptionDuringHandle ( ) throws Exception { vertx . runOnContext ( v - > { ReadStream < Long > timer = vertx . timerStream ( 200 ) ; AtomicBoolean handled = new AtomicBoolean ( ) ; timer . handler ( l - > { assertFalse ( handled . get ( ) ) ; handled . set ( true ) ; throw new RuntimeException ( ) ; } ) ; timer . endHandler ( v2 - > { assertTrue ( handled . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testTimerStreamCallingWithNullHandlerCancelsTheTimer ( ) throws Exception { vertx . runOnContext ( v - > { ReadStream < Long > timer = vertx . timerStream ( 200 ) ; AtomicInteger count = new AtomicInteger ( ) ; timer . handler ( l - > { if ( count . incrementAndGet ( ) == 1 ) { timer . handler ( null ) ; vertx . setTimer ( 200 , id - > { assertEquals ( 1 , count . get ( ) ) ; testComplete ( ) ; } ) ; } else { fail ( ) ; } } ) ; } ) ; await ( ) ; } @ Test public void testTimerStreamCancellation ( ) throws Exception { vertx . runOnContext ( v - > { TimeoutStream timer = vertx . timerStream ( 200 ) ; AtomicBoolean called = new AtomicBoolean ( ) ; timer . handler ( l - > { called . set ( true ) ; } ) ; timer . cancel ( ) ; vertx . setTimer ( 500 , id - > { assertFalse ( called . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testTimerSetHandlerTwice ( ) throws Exception { vertx . runOnContext ( v - > { ReadStream < Long > timer = vertx . timerStream ( 200 ) ; timer . handler ( l - > testComplete ( ) ) ; try { timer . handler ( l - > fail ( ) ) ; fail ( ) ; } catch ( IllegalStateException ignore ) { } } ) ; await ( ) ; } @ Test public void testTimerPauseResume ( ) throws Exception { ReadStream < Long > timer = vertx . timerStream ( 10 ) ; timer . handler ( l - > testComplete ( ) ) ; timer . pause ( ) ; timer . resume ( ) ; await ( ) ; } @ Test public void testTimerPause ( ) throws Exception { vertx . runOnContext ( v - > { ReadStream < Long > timer = vertx . timerStream ( 10 ) ; timer . handler ( l - > fail ( ) ) ; timer . endHandler ( l - > testComplete ( ) ) ; timer . pause ( ) ; } ) ; await ( ) ; } @ Test public void testPeriodicStreamHandler ( ) throws Exception { TimeoutStream timer = vertx . periodicStream ( 10 ) ; AtomicInteger count = new AtomicInteger ( ) ; timer . handler ( l - > { int value = count . incrementAndGet ( ) ; switch ( value ) { case 0 : break ; case 1 : throw new RuntimeException ( ) ; case 2 : timer . cancel ( ) ; testComplete ( ) ; break ; default : fail ( ) ; } } ) ; timer . endHandler ( v - > { fail ( ) ; } ) ; await ( ) ; } @ Test public void testPeriodicSetHandlerTwice ( ) throws Exception { vertx . runOnContext ( v - > { ReadStream < Long > timer = vertx . periodicStream ( 200 ) ; timer . handler ( l - > testComplete ( ) ) ; try { timer . handler ( l - > fail ( ) ) ; fail ( ) ; } catch ( IllegalStateException ignore ) { } } ) ; await ( ) ; } @ Test public void testPeriodicPauseResume ( ) throws Exception { ReadStream < Long > timer = vertx . periodicStream ( 200 ) ; AtomicInteger count = new AtomicInteger ( ) ; timer . handler ( id - > { int cnt = count . incrementAndGet ( ) ; if ( cnt == 2 ) { timer . pause ( ) ; vertx . setTimer ( 500 , id2 - > { assertEquals ( 2 , count . get ( ) ) ; timer . resume ( ) ; } ) ; } else if ( cnt == 3 ) { testComplete ( ) ; } } ) ; await ( ) ; } @ Test public void testTimeoutStreamEndCallbackAsynchronously ( ) { TimeoutStream stream = vertx . timerStream ( 200 ) ; ThreadLocal < Object > stack = new ThreadLocal < > ( ) ; stack . set ( true ) ; stream . endHandler ( v2 - > { assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; assertNull ( stack . get ( ) ) ; testComplete ( ) ; } ) ; stream . handler ( id - > { } ) ; await ( ) ; } }
package io . vertx . test . core ; import io . vertx . core . buffer . Buffer ; import java . util . Random ; import static org . junit . Assert . fail ; public class TestUtils { private static Random random = new Random ( ) ; public static Buffer randomBuffer ( int length ) { return randomBuffer ( length , false , ( byte ) 0 ) ; } public static byte [ ] randomByteArray ( int length ) { return randomByteArray ( length , false , ( byte ) 0 ) ; } public static byte [ ] randomByteArray ( int length , boolean avoid , byte avoidByte ) { byte [ ] line = new byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { byte rand ; do { rand = randomByte ( ) ; } while ( avoid && rand == avoidByte ) ; line [ i ] = rand ; } return line ; } public static Buffer randomBuffer ( int length , boolean avoid , byte avoidByte ) { byte [ ] line = randomByteArray ( length , avoid , avoidByte ) ; return Buffer . buffer ( line ) ; } public static byte randomByte ( ) { return ( byte ) ( ( int ) ( Math . random ( ) * 255 ) - 128 ) ; } public static int randomInt ( ) { return random . nextInt ( ) ; } public static int randomPortInt ( ) { return random . nextInt ( 65536 ) ; } public static int randomPositiveInt ( ) { while ( true ) { int rand = random . nextInt ( ) ; if ( rand > 0 ) { return rand ; } } } public static long randomPositiveLong ( ) { while ( true ) { long rand = random . nextLong ( ) ; if ( rand > 0 ) { return rand ; } } } public static long randomLong ( ) { return random . nextLong ( ) ; } public static boolean randomBoolean ( ) { return random . nextBoolean ( ) ; } public static char randomChar ( ) { return ( char ) ( random . nextInt ( 16 ) ) ; } public static short randomShort ( ) { return ( short ) ( random . nextInt ( 16 ) - Short . MAX_VALUE ) ; } public static float randomFloat ( ) { return random . nextFloat ( ) ; } public static double randomDouble ( ) { return random . nextDouble ( ) ; } public static String randomUnicodeString ( int length ) { StringBuilder builder = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { char c ; do { c = ( char ) ( 0xFFFF * Math . random ( ) ) ; } while ( ( c >= 0xFFFE && c <= 0xFFFF ) || ( c >= 0xD800 && c <= 0xDFFF ) ) ; builder . append ( c ) ; } return builder . toString ( ) ; } public static String randomAlphaString ( int length ) { StringBuilder builder = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = ( char ) ( 65 + 25 * Math . random ( ) ) ; builder . append ( c ) ; } return builder . toString ( ) ; } public static boolean byteArraysEqual ( byte [ ] b1 , byte [ ] b2 ) { if ( b1 . length != b2 . length ) return false ; for ( int i = 0 ; i < b1 . length ; i ++ ) { if ( b1 [ i ] != b2 [ i ] ) return false ; } return true ; } public static void assertIllegalArgumentException ( Runnable runnable ) { try { runnable . run ( ) ; fail ( "Should throw IllegalArgumentException" ) ; } catch ( IllegalArgumentException e ) { } } public static void assertNullPointerException ( Runnable runnable ) { try { runnable . run ( ) ; fail ( "Should throw NullPointerException" ) ; } catch ( NullPointerException e ) { } } public static void assertIllegalStateException ( Runnable runnable ) { try { runnable . run ( ) ; fail ( "Should throw IllegalStateException" ) ; } catch ( IllegalStateException e ) { } } public static void assertIndexOutOfBoundsException ( Runnable runnable ) { try { runnable . run ( ) ; fail ( "Should throw IndexOutOfBoundsException" ) ; } catch ( IndexOutOfBoundsException e ) { } } }
package io . vertx . test . core . sourceverticle ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Future ; import io . vertx . test . core . sourceverticle . somepackage . OtherSourceVerticle ; public class SourceVerticle extends AbstractVerticle { @ Override public void start ( Future < Void > startFuture ) throws Exception { vertx . deployVerticle ( "java:" + OtherSourceVerticle . class . getName ( ) . replace ( '.' , '/' ) + ".java" , new DeploymentOptions ( ) , ar - > { if ( ar . succeeded ( ) ) { startFuture . complete ( ( Void ) null ) ; } else { ar . cause ( ) . printStackTrace ( ) ; } } ) ; } }
package io . vertx . test . core . sourceverticle . somepackage ; import io . vertx . core . AbstractVerticle ; public class OtherSourceVerticle extends AbstractVerticle { }
package io . vertx . test . fakecluster ; import io . vertx . core . impl . ConcurrentHashSet ; import io . vertx . core . spi . cluster . ChoosableIterable ; import java . util . Iterator ; import java . util . NoSuchElementException ; import java . util . Set ; class ChoosableSet < T > implements ChoosableIterable < T > { private final Set < T > ids ; private volatile Iterator < T > iter ; public ChoosableSet ( int initialSize ) { ids = new ConcurrentHashSet < > ( initialSize ) ; } public int size ( ) { return ids . size ( ) ; } public void add ( T elem ) { ids . add ( elem ) ; } public boolean remove ( T elem ) { return ids . remove ( elem ) ; } public void merge ( ChoosableSet < T > toMerge ) { ids . addAll ( toMerge . ids ) ; } public boolean isEmpty ( ) { return ids . isEmpty ( ) ; } @ Override public Iterator < T > iterator ( ) { return ids . iterator ( ) ; } public synchronized T choose ( ) { if ( ! ids . isEmpty ( ) ) { if ( iter == null || ! iter . hasNext ( ) ) { iter = ids . iterator ( ) ; } try { return iter . next ( ) ; } catch ( NoSuchElementException e ) { return null ; } } else { return null ; } } }
package io . vertx . test . fakecluster ; import io . vertx . core . * ; import io . vertx . core . impl . ContextImpl ; import io . vertx . core . impl . VertxInternal ; import io . vertx . core . shareddata . AsyncMap ; import io . vertx . core . shareddata . Counter ; import io . vertx . core . shareddata . Lock ; import io . vertx . core . shareddata . impl . AsynchronousCounter ; import io . vertx . core . shareddata . impl . AsynchronousLock ; import io . vertx . core . spi . cluster . AsyncMultiMap ; import io . vertx . core . spi . cluster . ChoosableIterable ; import io . vertx . core . spi . cluster . ClusterManager ; import io . vertx . core . spi . cluster . NodeListener ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . atomic . AtomicLong ; public class FakeClusterManager implements ClusterManager { private static Map < String , FakeClusterManager > nodes = Collections . synchronizedMap ( new LinkedHashMap < > ( ) ) ; private static List < NodeListener > nodeListeners = new CopyOnWriteArrayList < > ( ) ; private static ConcurrentMap < String , ConcurrentMap > asyncMaps = new ConcurrentHashMap < > ( ) ; private static ConcurrentMap < String , ConcurrentMap > asyncMultiMaps = new ConcurrentHashMap < > ( ) ; private static ConcurrentMap < String , Map > syncMaps = new ConcurrentHashMap < > ( ) ; private static ConcurrentMap < String , AsynchronousLock > locks = new ConcurrentHashMap < > ( ) ; private static ConcurrentMap < String , AtomicLong > counters = new ConcurrentHashMap < > ( ) ; private volatile String nodeID ; private volatile NodeListener nodeListener ; private volatile VertxInternal vertx ; public void setVertx ( Vertx vertx ) { this . vertx = ( VertxInternal ) vertx ; } private static void doJoin ( String nodeID , FakeClusterManager node ) { if ( nodes . containsKey ( nodeID ) ) { throw new IllegalStateException ( "Node has already joined!" ) ; } nodes . put ( nodeID , node ) ; for ( NodeListener listener : new ArrayList < > ( nodeListeners ) ) { if ( listener != null ) { listener . nodeAdded ( nodeID ) ; } } } private static void doLeave ( String nodeID ) { nodes . remove ( nodeID ) ; for ( NodeListener listener : new ArrayList < > ( nodeListeners ) ) { if ( listener != null ) { listener . nodeLeft ( nodeID ) ; } } } private static void doAddNodeListener ( NodeListener listener ) { if ( nodeListeners . contains ( listener ) ) { throw new IllegalStateException ( "Listener already registered!" ) ; } nodeListeners . add ( listener ) ; } private static void doRemoveNodeListener ( NodeListener listener ) { nodeListeners . remove ( listener ) ; } @ Override public < K , V > void getAsyncMultiMap ( String name , Handler < AsyncResult < AsyncMultiMap < K , V > > > resultHandler ) { ConcurrentMap map = asyncMultiMaps . get ( name ) ; if ( map == null ) { map = new ConcurrentHashMap < > ( ) ; ConcurrentMap prevMap = asyncMultiMaps . putIfAbsent ( name , map ) ; if ( prevMap != null ) { map = prevMap ; } } ConcurrentMap < K , ChoosableSet < V > > theMap = map ; vertx . runOnContext ( v - > resultHandler . handle ( Future . succeededFuture ( new FakeAsyncMultiMap < > ( theMap ) ) ) ) ; } @ Override public < K , V > void getAsyncMap ( String name , Handler < AsyncResult < AsyncMap < K , V > > > resultHandler ) { ConcurrentMap map = asyncMaps . get ( name ) ; if ( map == null ) { map = new ConcurrentHashMap < > ( ) ; ConcurrentMap prevMap = asyncMaps . putIfAbsent ( name , map ) ; if ( prevMap != null ) { map = prevMap ; } } ConcurrentMap < K , V > theMap = map ; vertx . runOnContext ( v - > resultHandler . handle ( Future . succeededFuture ( new FakeAsyncMap < > ( theMap ) ) ) ) ; } @ Override public < K , V > Map < K , V > getSyncMap ( String name ) { Map < K , V > map = ( Map < K , V > ) syncMaps . get ( name ) ; if ( map == null ) { map = new ConcurrentHashMap < > ( ) ; Map < K , V > prevMap = ( Map < K , V > ) syncMaps . putIfAbsent ( name , map ) ; if ( prevMap != null ) { map = prevMap ; } } return map ; } @ Override public void getLockWithTimeout ( String name , long timeout , Handler < AsyncResult < Lock > > resultHandler ) { AsynchronousLock lock = new AsynchronousLock ( vertx ) ; AsynchronousLock prev = locks . putIfAbsent ( name , lock ) ; if ( prev != null ) { lock = prev ; } FakeLock flock = new FakeLock ( lock ) ; flock . acquire ( timeout , resultHandler ) ; } @ Override public void getCounter ( String name , Handler < AsyncResult < Counter > > resultHandler ) { AtomicLong counter = new AtomicLong ( ) ; AtomicLong prev = counters . putIfAbsent ( name , counter ) ; if ( prev != null ) { counter = prev ; } AtomicLong theCounter = counter ; Context context = vertx . getOrCreateContext ( ) ; context . runOnContext ( v - > resultHandler . handle ( Future . succeededFuture ( new AsynchronousCounter ( vertx , theCounter ) ) ) ) ; } @ Override public String getNodeID ( ) { return nodeID ; } @ Override public List < String > getNodes ( ) { return new ArrayList < > ( nodes . keySet ( ) ) ; } @ Override public void nodeListener ( NodeListener listener ) { doAddNodeListener ( listener ) ; this . nodeListener = listener ; } @ Override public void join ( Handler < AsyncResult < Void > > resultHandler ) { this . nodeID = UUID . randomUUID ( ) . toString ( ) ; doJoin ( nodeID , this ) ; Context context = vertx . getOrCreateContext ( ) ; context . runOnContext ( v - > { resultHandler . handle ( Future . succeededFuture ( ) ) ; } ) ; } @ Override public void leave ( Handler < AsyncResult < Void > > resultHandler ) { if ( nodeID != null ) { if ( nodeListener != null ) { doRemoveNodeListener ( nodeListener ) ; nodeListener = null ; } doLeave ( nodeID ) ; this . nodeID = null ; } Context context = vertx . getOrCreateContext ( ) ; context . runOnContext ( v - > resultHandler . handle ( Future . succeededFuture ( ) ) ) ; } @ Override public boolean isActive ( ) { return nodeID != null ; } public static void reset ( ) { nodes . clear ( ) ; nodeListeners . clear ( ) ; asyncMaps . clear ( ) ; asyncMultiMaps . clear ( ) ; locks . clear ( ) ; counters . clear ( ) ; syncMaps . clear ( ) ; } private class FakeLock implements Lock { private final AsynchronousLock delegate ; public FakeLock ( AsynchronousLock delegate ) { this . delegate = delegate ; } public void acquire ( long timeout , Handler < AsyncResult < Lock > > resultHandler ) { Context context = vertx . getOrCreateContext ( ) ; delegate . doAcquire ( context , timeout , resultHandler ) ; } @ Override public void release ( ) { delegate . release ( ) ; } } private class FakeAsyncMap < K , V > implements AsyncMap < K , V > { private final Map < K , V > map ; public FakeAsyncMap ( Map < K , V > map ) { this . map = map ; } @ Override public void get ( final K k , Handler < AsyncResult < V > > resultHandler ) { vertx . executeBlocking ( fut - > fut . complete ( map . get ( k ) ) , resultHandler ) ; } @ Override public void put ( final K k , final V v , Handler < AsyncResult < Void > > resultHandler ) { vertx . executeBlocking ( fut - > { map . put ( k , v ) ; fut . complete ( ) ; } , resultHandler ) ; } @ Override public void putIfAbsent ( K k , V v , Handler < AsyncResult < V > > resultHandler ) { vertx . executeBlocking ( fut - > fut . complete ( map . putIfAbsent ( k , v ) ) , resultHandler ) ; } @ Override public void put ( K k , V v , long timeout , Handler < AsyncResult < Void > > completionHandler ) { put ( k , v , completionHandler ) ; vertx . setTimer ( timeout , tid - > map . remove ( k ) ) ; } @ Override public void putIfAbsent ( K k , V v , long timeout , Handler < AsyncResult < V > > completionHandler ) { putIfAbsent ( k , v , completionHandler ) ; } @ Override public void removeIfPresent ( K k , V v , Handler < AsyncResult < Boolean > > resultHandler ) { vertx . executeBlocking ( fut - > fut . complete ( map . remove ( k , v ) ) , resultHandler ) ; } @ Override public void replace ( K k , V v , Handler < AsyncResult < V > > resultHandler ) { vertx . executeBlocking ( fut - > fut . complete ( map . replace ( k , v ) ) , resultHandler ) ; } @ Override public void replaceIfPresent ( K k , V oldValue , V newValue , Handler < AsyncResult < Boolean > > resultHandler ) { vertx . executeBlocking ( fut - > fut . complete ( map . replace ( k , oldValue , newValue ) ) , resultHandler ) ; } @ Override public void clear ( Handler < AsyncResult < Void > > resultHandler ) { vertx . executeBlocking ( fut - > { map . clear ( ) ; fut . complete ( ) ; } , resultHandler ) ; } @ Override public void size ( Handler < AsyncResult < Integer > > resultHandler ) { vertx . executeBlocking ( fut - > fut . complete ( map . size ( ) ) , resultHandler ) ; } @ Override public void remove ( final K k , Handler < AsyncResult < V > > resultHandler ) { vertx . executeBlocking ( fut - > fut . complete ( map . remove ( k ) ) , resultHandler ) ; } } private class FakeAsyncMultiMap < K , V > implements AsyncMultiMap < K , V > { private final ConcurrentMap < K , ChoosableSet < V > > map ; public FakeAsyncMultiMap ( ConcurrentMap < K , ChoosableSet < V > > map ) { this . map = map ; } @ Override public void add ( final K k , final V v , Handler < AsyncResult < Void > > completionHandler ) { vertx . executeBlocking ( fut - > { ChoosableSet < V > vals = map . get ( k ) ; if ( vals == null ) { vals = new ChoosableSet < > ( 1 ) ; ChoosableSet < V > prevVals = map . putIfAbsent ( k , vals ) ; if ( prevVals != null ) { vals = prevVals ; } } vals . add ( v ) ; fut . complete ( ) ; } , completionHandler ) ; } @ Override public void get ( final K k , Handler < AsyncResult < ChoosableIterable < V > > > asyncResultHandler ) { ContextImpl ctx = ( ContextImpl ) Vertx . currentContext ( ) ; vertx . executeBlocking ( fut - > { ChoosableIterable < V > it = map . get ( k ) ; if ( it == null ) { it = new ChoosableSet < V > ( 0 ) ; } fut . complete ( it ) ; } , asyncResultHandler ) ; } @ Override public void remove ( final K k , final V v , Handler < AsyncResult < Boolean > > completionHandler ) { vertx . executeBlocking ( fut - > { ChoosableSet < V > vals = map . get ( k ) ; boolean found = false ; if ( vals != null ) { boolean removed = vals . remove ( v ) ; if ( removed ) { if ( vals . isEmpty ( ) ) { map . remove ( k ) ; } found = true ; } } fut . complete ( found ) ; } , completionHandler ) ; } @ Override public void removeAllForValue ( final V v , Handler < AsyncResult < Void > > completionHandler ) { vertx . executeBlocking ( fut - > { Iterator < Map . Entry < K , ChoosableSet < V > > > mapIter = map . entrySet ( ) . iterator ( ) ; while ( mapIter . hasNext ( ) ) { Map . Entry < K , ChoosableSet < V > > entry = mapIter . next ( ) ; ChoosableSet < V > vals = entry . getValue ( ) ; Iterator < V > iter = vals . iterator ( ) ; while ( iter . hasNext ( ) ) { V val = iter . next ( ) ; if ( val . equals ( v ) ) { iter . remove ( ) ; } } if ( vals . isEmpty ( ) ) { mapIter . remove ( ) ; } } fut . complete ( ) ; } , completionHandler ) ; } } }
package io . vertx . test . fakedns ; import org . apache . directory . server . dns . DnsServer ; import org . apache . directory . server . dns . io . encoder . DnsMessageEncoder ; import org . apache . directory . server . dns . io . encoder . ResourceRecordEncoder ; import org . apache . directory . server . dns . messages . DnsMessage ; import org . apache . directory . server . dns . messages . QuestionRecord ; import org . apache . directory . server . dns . messages . RecordClass ; import org . apache . directory . server . dns . messages . RecordType ; import org . apache . directory . server . dns . messages . ResourceRecord ; import org . apache . directory . server . dns . messages . ResourceRecordModifier ; import org . apache . directory . server . dns . protocol . DnsProtocolHandler ; import org . apache . directory . server . dns . protocol . DnsUdpDecoder ; import org . apache . directory . server . dns . protocol . DnsUdpEncoder ; import org . apache . directory . server . dns . store . DnsAttribute ; import org . apache . directory . server . dns . store . RecordStore ; import org . apache . directory . server . protocol . shared . transport . UdpTransport ; import org . apache . mina . core . buffer . IoBuffer ; import org . apache . mina . core . session . IoSession ; import org . apache . mina . filter . codec . ProtocolCodecFactory ; import org . apache . mina . filter . codec . ProtocolCodecFilter ; import org . apache . mina . filter . codec . ProtocolDecoder ; import org . apache . mina . filter . codec . ProtocolEncoder ; import org . apache . mina . filter . codec . ProtocolEncoderOutput ; import org . apache . mina . transport . socket . DatagramAcceptor ; import org . apache . mina . transport . socket . DatagramSessionConfig ; import java . io . IOException ; import java . util . HashSet ; import java . util . Set ; public final class FakeDNSServer extends DnsServer { public static final int PORT = 53530 ; private final RecordStore store ; private DatagramAcceptor acceptor ; private FakeDNSServer ( RecordStore store ) { this . store = store ; } public static FakeDNSServer testResolveA ( final String ipAddress ) { return new FakeDNSServer ( new RecordStore ( ) { @ Override public Set < ResourceRecord > getRecords ( QuestionRecord questionRecord ) throws org . apache . directory . server . dns . DnsException { Set < ResourceRecord > set = new HashSet < > ( ) ; ResourceRecordModifier rm = new ResourceRecordModifier ( ) ; rm . setDnsClass ( RecordClass . IN ) ; rm . setDnsName ( "dns.vertx.io" ) ; rm . setDnsTtl ( 100 ) ; rm . setDnsType ( RecordType . A ) ; rm . put ( DnsAttribute . IP_ADDRESS , ipAddress ) ; set . add ( rm . getEntry ( ) ) ; return set ; } } ) ; } public static FakeDNSServer testResolveAAAA ( final String ipAddress ) { return new FakeDNSServer ( new RecordStore ( ) { @ Override public Set < ResourceRecord > getRecords ( QuestionRecord questionRecord ) throws org . apache . directory . server . dns . DnsException { Set < ResourceRecord > set = new HashSet < > ( ) ; ResourceRecordModifier rm = new ResourceRecordModifier ( ) ; rm . setDnsClass ( RecordClass . IN ) ; rm . setDnsName ( "dns.vertx.io" ) ; rm . setDnsTtl ( 100 ) ; rm . setDnsType ( RecordType . AAAA ) ; rm . put ( DnsAttribute . IP_ADDRESS , ipAddress ) ; set . add ( rm . getEntry ( ) ) ; return set ; } } ) ; } public static FakeDNSServer testResolveMX ( final int prio , final String mxRecord ) { return new FakeDNSServer ( new RecordStore ( ) { @ Override public Set < ResourceRecord > getRecords ( QuestionRecord questionRecord ) throws org . apache . directory . server . dns . DnsException { Set < ResourceRecord > set = new HashSet < > ( ) ; ResourceRecordModifier rm = new ResourceRecordModifier ( ) ; rm . setDnsClass ( RecordClass . IN ) ; rm . setDnsName ( "dns.vertx.io" ) ; rm . setDnsTtl ( 100 ) ; rm . setDnsType ( RecordType . MX ) ; rm . put ( DnsAttribute . MX_PREFERENCE , String . valueOf ( prio ) ) ; rm . put ( DnsAttribute . DOMAIN_NAME , mxRecord ) ; set . add ( rm . getEntry ( ) ) ; return set ; } } ) ; } public static FakeDNSServer testResolveTXT ( final String txt ) { return new FakeDNSServer ( new RecordStore ( ) { @ Override public Set < ResourceRecord > getRecords ( QuestionRecord questionRecord ) throws org . apache . directory . server . dns . DnsException { Set < ResourceRecord > set = new HashSet < > ( ) ; ResourceRecordModifier rm = new ResourceRecordModifier ( ) ; rm . setDnsClass ( RecordClass . IN ) ; rm . setDnsName ( "dns.vertx.io" ) ; rm . setDnsTtl ( 100 ) ; rm . setDnsType ( RecordType . TXT ) ; rm . put ( DnsAttribute . CHARACTER_STRING , txt ) ; set . add ( rm . getEntry ( ) ) ; return set ; } } ) ; } public static FakeDNSServer testResolveNS ( final String ns ) { return new FakeDNSServer ( new RecordStore ( ) { @ Override public Set < ResourceRecord > getRecords ( QuestionRecord questionRecord ) throws org . apache . directory . server . dns . DnsException { Set < ResourceRecord > set = new HashSet < > ( ) ; ResourceRecordModifier rm = new ResourceRecordModifier ( ) ; rm . setDnsClass ( RecordClass . IN ) ; rm . setDnsName ( "dns.vertx.io" ) ; rm . setDnsTtl ( 100 ) ; rm . setDnsType ( RecordType . NS ) ; rm . put ( DnsAttribute . DOMAIN_NAME , ns ) ; set . add ( rm . getEntry ( ) ) ; return set ; } } ) ; } public static FakeDNSServer testResolveCNAME ( final String cname ) { return new FakeDNSServer ( new RecordStore ( ) { @ Override public Set < ResourceRecord > getRecords ( QuestionRecord questionRecord ) throws org . apache . directory . server . dns . DnsException { Set < ResourceRecord > set = new HashSet < > ( ) ; ResourceRecordModifier rm = new ResourceRecordModifier ( ) ; rm . setDnsClass ( RecordClass . IN ) ; rm . setDnsName ( "dns.vertx.io" ) ; rm . setDnsTtl ( 100 ) ; rm . setDnsType ( RecordType . CNAME ) ; rm . put ( DnsAttribute . DOMAIN_NAME , cname ) ; set . add ( rm . getEntry ( ) ) ; return set ; } } ) ; } public static FakeDNSServer testResolvePTR ( final String ptr ) { return new FakeDNSServer ( new RecordStore ( ) { @ Override public Set < ResourceRecord > getRecords ( QuestionRecord questionRecord ) throws org . apache . directory . server . dns . DnsException { Set < ResourceRecord > set = new HashSet < > ( ) ; ResourceRecordModifier rm = new ResourceRecordModifier ( ) ; rm . setDnsClass ( RecordClass . IN ) ; rm . setDnsName ( "dns.vertx.io" ) ; rm . setDnsTtl ( 100 ) ; rm . setDnsType ( RecordType . PTR ) ; rm . put ( DnsAttribute . DOMAIN_NAME , ptr ) ; set . add ( rm . getEntry ( ) ) ; return set ; } } ) ; } public static FakeDNSServer testResolveSRV ( final int priority , final int weight , final int port , final String target ) { return new FakeDNSServer ( new RecordStore ( ) { @ Override public Set < ResourceRecord > getRecords ( QuestionRecord questionRecord ) throws org . apache . directory . server . dns . DnsException { Set < ResourceRecord > set = new HashSet < > ( ) ; ResourceRecordModifier rm = new ResourceRecordModifier ( ) ; rm . setDnsClass ( RecordClass . IN ) ; rm . setDnsName ( "dns.vertx.io" ) ; rm . setDnsTtl ( 100 ) ; rm . setDnsType ( RecordType . SRV ) ; rm . put ( DnsAttribute . SERVICE_PRIORITY , String . valueOf ( priority ) ) ; rm . put ( DnsAttribute . SERVICE_WEIGHT , String . valueOf ( weight ) ) ; rm . put ( DnsAttribute . SERVICE_PORT , String . valueOf ( port ) ) ; rm . put ( DnsAttribute . DOMAIN_NAME , target ) ; set . add ( rm . getEntry ( ) ) ; return set ; } } ) ; } public static FakeDNSServer testLookup4 ( final String ip ) { return new FakeDNSServer ( new RecordStore ( ) { @ Override public Set < ResourceRecord > getRecords ( QuestionRecord questionRecord ) throws org . apache . directory . server . dns . DnsException { Set < ResourceRecord > set = new HashSet < > ( ) ; ResourceRecordModifier rm = new ResourceRecordModifier ( ) ; rm . setDnsClass ( RecordClass . IN ) ; rm . setDnsName ( "dns.vertx.io" ) ; rm . setDnsTtl ( 100 ) ; rm . setDnsType ( RecordType . A ) ; rm . put ( DnsAttribute . IP_ADDRESS , ip ) ; set . add ( rm . getEntry ( ) ) ; return set ; } } ) ; } public static FakeDNSServer testLookup6 ( ) { return new FakeDNSServer ( new RecordStore ( ) { @ Override public Set < ResourceRecord > getRecords ( QuestionRecord questionRecord ) throws org . apache . directory . server . dns . DnsException { Set < ResourceRecord > set = new HashSet < > ( ) ; ResourceRecordModifier rm = new ResourceRecordModifier ( ) ; rm . setDnsClass ( RecordClass . IN ) ; rm . setDnsName ( "dns.vertx.io" ) ; rm . setDnsTtl ( 100 ) ; rm . setDnsType ( RecordType . AAAA ) ; rm . put ( DnsAttribute . IP_ADDRESS , "::1" ) ; set . add ( rm . getEntry ( ) ) ; return set ; } } ) ; } public static FakeDNSServer testLookup ( final String ip ) { return testLookup4 ( ip ) ; } public static FakeDNSServer testLookupNonExisting ( ) { return new FakeDNSServer ( new RecordStore ( ) { @ Override public Set < ResourceRecord > getRecords ( QuestionRecord questionRecord ) throws org . apache . directory . server . dns . DnsException { return null ; } } ) ; } public static FakeDNSServer testReverseLookup ( final String ptr ) { return new FakeDNSServer ( new RecordStore ( ) { @ Override public Set < ResourceRecord > getRecords ( QuestionRecord questionRecord ) throws org . apache . directory . server . dns . DnsException { Set < ResourceRecord > set = new HashSet < > ( ) ; ResourceRecordModifier rm = new ResourceRecordModifier ( ) ; rm . setDnsClass ( RecordClass . IN ) ; rm . setDnsName ( "dns.vertx.io" ) ; rm . setDnsTtl ( 100 ) ; rm . setDnsType ( RecordType . PTR ) ; rm . put ( DnsAttribute . DOMAIN_NAME , ptr ) ; set . add ( rm . getEntry ( ) ) ; return set ; } } ) ; } @ Override public void start ( ) throws IOException { UdpTransport transport = new UdpTransport ( "127.0.0.1" , PORT ) ; setTransports ( transport ) ; acceptor = transport . getAcceptor ( ) ; acceptor . setHandler ( new DnsProtocolHandler ( this , store ) { @ Override public void sessionCreated ( IoSession session ) throws Exception { session . getFilterChain ( ) . addFirst ( "codec" , new ProtocolCodecFilter ( new TestDnsProtocolUdpCodecFactory ( ) ) ) ; } } ) ; ( ( DatagramSessionConfig ) acceptor . getSessionConfig ( ) ) . setReuseAddress ( true ) ; acceptor . bind ( ) ; } @ Override public void stop ( ) { acceptor . dispose ( ) ; } private final class TestDnsProtocolUdpCodecFactory implements ProtocolCodecFactory { private DnsMessageEncoder encoder = new DnsMessageEncoder ( ) ; private TestAAAARecordEncoder recordEncoder = new TestAAAARecordEncoder ( ) ; @ Override public ProtocolEncoder getEncoder ( IoSession session ) throws Exception { return new DnsUdpEncoder ( ) { @ Override public void encode ( IoSession session , Object message , ProtocolEncoderOutput out ) { IoBuffer buf = IoBuffer . allocate ( 1024 ) ; DnsMessage dnsMessage = ( DnsMessage ) message ; encoder . encode ( buf , dnsMessage ) ; for ( ResourceRecord record : dnsMessage . getAnswerRecords ( ) ) { if ( record . getRecordType ( ) == RecordType . AAAA ) { try { recordEncoder . put ( buf , record ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } } } buf . flip ( ) ; out . write ( buf ) ; } } ; } @ Override public ProtocolDecoder getDecoder ( IoSession session ) throws Exception { return new DnsUdpDecoder ( ) ; } private final class TestAAAARecordEncoder extends ResourceRecordEncoder { @ Override protected void putResourceRecordData ( IoBuffer ioBuffer , ResourceRecord resourceRecord ) { if ( ! resourceRecord . get ( DnsAttribute . IP_ADDRESS ) . equals ( "::1" ) ) { throw new IllegalStateException ( "Only supposed to be used with IPV6 address of ::1" ) ; } ioBuffer . put ( new byte [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } ) ; } } } }
package io . vertx . test . fakemetrics ; import io . vertx . core . http . HttpClientRequest ; import io . vertx . core . http . HttpServerRequest ; public class HttpServerMetric { public final HttpServerRequest request ; public final SocketMetric socket ; public HttpServerMetric ( HttpServerRequest request , SocketMetric socket ) { this . request = request ; this . socket = socket ; } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . DeploymentOptions ; import io . vertx . core . Vertx ; import io . vertx . core . buffer . Buffer ; import io . vertx . core . datagram . DatagramSocket ; import io . vertx . core . datagram . DatagramSocketOptions ; import io . vertx . core . json . JsonObject ; import io . vertx . core . net . NetworkOptions ; import io . vertx . core . streams . WriteStream ; import org . junit . Test ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . util . Random ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import static io . vertx . test . core . TestUtils . * ; public class DatagramTest extends VertxTestBase { private volatile DatagramSocket peer1 ; private volatile DatagramSocket peer2 ; protected void tearDown ( ) throws Exception { if ( peer1 != null ) { CountDownLatch latch = new CountDownLatch ( 2 ) ; peer1 . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; latch . countDown ( ) ; if ( peer2 != null ) { peer2 . close ( ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; latch . countDown ( ) ; } ) ; } else { latch . countDown ( ) ; } } ) ; latch . await ( 10L , TimeUnit . SECONDS ) ; } super . tearDown ( ) ; } @ Test public void testDatagramSocket ( ) throws Exception { peer1 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; assertNullPointerException ( ( ) - > peer1 . send ( ( Buffer ) null , 1 , "127.0.0.1" , ar - > { } ) ) ; assertIllegalArgumentException ( ( ) - > peer1 . send ( Buffer . buffer ( ) , - 1 , "127.0.0.1" , ar - > { } ) ) ; assertIllegalArgumentException ( ( ) - > peer1 . send ( Buffer . buffer ( ) , 65536 , "127.0.0.1" , ar - > { } ) ) ; assertNullPointerException ( ( ) - > peer1 . send ( ( String ) null , 1 , "127.0.0.1" , ar - > { } ) ) ; assertIllegalArgumentException ( ( ) - > peer1 . send ( "" , - 1 , "127.0.0.1" , ar - > { } ) ) ; assertIllegalArgumentException ( ( ) - > peer1 . send ( "" , 65536 , "127.0.0.1" , ar - > { } ) ) ; assertNullPointerException ( ( ) - > peer1 . send ( ( String ) null , "UTF-8" , 1 , "127.0.0.1" , ar - > { } ) ) ; assertIllegalArgumentException ( ( ) - > peer1 . send ( "" , "UTF-8" , - 1 , "127.0.0.1" , ar - > { } ) ) ; assertIllegalArgumentException ( ( ) - > peer1 . send ( "" , "UTF-8" , 65536 , "127.0.0.1" , ar - > { } ) ) ; assertNullPointerException ( ( ) - > peer1 . send ( "" , null , 1 , "127.0.0.1" , ar - > { } ) ) ; assertIllegalArgumentException ( ( ) - > peer1 . sender ( - 1 , "127.0.0.1" ) ) ; assertIllegalArgumentException ( ( ) - > peer1 . sender ( 65536 , "127.0.0.1" ) ) ; assertNullPointerException ( ( ) - > peer1 . sender ( 1 , null ) ) ; assertIllegalArgumentException ( ( ) - > peer1 . listen ( - 1 , "127.0.0.1" , ar - > { } ) ) ; assertIllegalArgumentException ( ( ) - > peer1 . listen ( 65536 , "127.0.0.1" , ar - > { } ) ) ; assertNullPointerException ( ( ) - > peer1 . listen ( 1 , null , ar - > { } ) ) ; assertNullPointerException ( ( ) - > peer1 . listen ( 1 , "127.0.0.1" , null ) ) ; } @ Test public void testSendReceive ( ) { peer1 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer2 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer2 . exceptionHandler ( t - > fail ( t . getMessage ( ) ) ) ; peer2 . listen ( 1234 , "127.0.0.1" , ar - > { assertTrue ( ar . succeeded ( ) ) ; Buffer buffer = TestUtils . randomBuffer ( 128 ) ; peer2 . handler ( packet - > { assertEquals ( buffer , packet . data ( ) ) ; testComplete ( ) ; } ) ; peer1 . send ( buffer , 1234 , "127.0.0.1" , ar2 - > assertTrue ( ar2 . succeeded ( ) ) ) ; } ) ; await ( ) ; } @ Test public void testSendReceiveLargePacket ( ) { int packetSize = 10000 ; peer1 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) . setSendBufferSize ( packetSize ) ) ; peer2 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) . setReceiveBufferSize ( packetSize + 16 ) ) ; peer2 . exceptionHandler ( t - > fail ( t . getMessage ( ) ) ) ; peer2 . listen ( 1234 , "127.0.0.1" , ar - > { assertTrue ( ar . succeeded ( ) ) ; Buffer buffer = TestUtils . randomBuffer ( packetSize ) ; peer2 . handler ( packet - > { assertEquals ( buffer , packet . data ( ) ) ; testComplete ( ) ; } ) ; peer1 . send ( buffer , 1234 , "127.0.0.1" , ar2 - > assertTrue ( ar2 . succeeded ( ) ) ) ; } ) ; await ( ) ; } @ Test public void testEndHandler ( ) { ThreadLocal < Object > stack = new ThreadLocal < > ( ) ; stack . set ( true ) ; peer2 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer2 . listen ( 1234 , "127.0.0.1" , ar - > { assertTrue ( ar . succeeded ( ) ) ; peer2 . endHandler ( v - > { assertTrue ( Vertx . currentContext ( ) . isEventLoopContext ( ) ) ; assertNull ( stack . get ( ) ) ; testComplete ( ) ; } ) ; peer2 . close ( ) ; } ) ; await ( ) ; } @ Test public void testPauseResume ( ) { peer1 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer2 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer2 . exceptionHandler ( t - > fail ( t . getMessage ( ) ) ) ; peer2 . listen ( 1234 , "127.0.0.1" , ar - > { Buffer buffer = TestUtils . randomBuffer ( 128 ) ; AtomicBoolean received = new AtomicBoolean ( ) ; peer2 . handler ( packet - > received . set ( true ) ) ; peer2 . pause ( ) ; peer1 . send ( buffer , 1234 , "127.0.0.1" , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; } ) ; vertx . setTimer ( 100 , l - > { peer2 . handler ( packet - > { assertFalse ( received . get ( ) ) ; assertEquals ( buffer , packet . data ( ) ) ; testComplete ( ) ; } ) ; peer2 . resume ( ) ; peer1 . send ( buffer , 1234 , "127.0.0.1" , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testSender ( ) { peer1 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer2 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer2 . exceptionHandler ( t - > fail ( t . getMessage ( ) ) ) ; peer2 . listen ( 1234 , "127.0.0.1" , ar - > { Buffer buffer = TestUtils . randomBuffer ( 128 ) ; peer2 . handler ( packet - > { assertEquals ( buffer , packet . data ( ) ) ; testComplete ( ) ; } ) ; WriteStream < Buffer > sender1 = peer1 . sender ( 1234 , "127.0.0.1" ) ; sender1 . write ( buffer ) ; } ) ; } @ Test public void testListenHostPort ( ) { peer2 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer2 . listen ( 1234 , "127.0.0.1" , ar - > { assertTrue ( ar . succeeded ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testListenPort ( ) { peer2 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer2 . listen ( 1234 , "localhost" , ar - > { assertTrue ( ar . succeeded ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testListenInetSocketAddress ( ) { peer2 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer2 . listen ( 1234 , "127.0.0.1" , ar - > { assertTrue ( ar . succeeded ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testListenSamePortMultipleTimes ( ) { peer2 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer1 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer2 . listen ( 1234 , "127.0.0.1" , ar1 - > { assertTrue ( ar1 . succeeded ( ) ) ; peer1 . listen ( 1234 , "127.0.0.1" , ar2 - > { assertTrue ( ar2 . failed ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testEcho ( ) { peer1 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer2 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer1 . exceptionHandler ( t - > fail ( t . getMessage ( ) ) ) ; peer2 . exceptionHandler ( t - > fail ( t . getMessage ( ) ) ) ; peer2 . listen ( 1234 , "127.0.0.1" , ar - > { assertTrue ( ar . succeeded ( ) ) ; Buffer buffer = TestUtils . randomBuffer ( 128 ) ; peer2 . handler ( packet - > { assertEquals ( "127.0.0.1" , packet . sender ( ) . host ( ) ) ; assertEquals ( 1235 , packet . sender ( ) . port ( ) ) ; assertEquals ( buffer , packet . data ( ) ) ; peer2 . send ( packet . data ( ) , 1235 , "127.0.0.1" , ar2 - > assertTrue ( ar2 . succeeded ( ) ) ) ; } ) ; peer1 . listen ( 1235 , "127.0.0.1" , ar2 - > { peer1 . handler ( packet - > { assertEquals ( buffer , packet . data ( ) ) ; assertEquals ( "127.0.0.1" , packet . sender ( ) . host ( ) ) ; assertEquals ( 1234 , packet . sender ( ) . port ( ) ) ; testComplete ( ) ; } ) ; peer1 . send ( buffer , 1234 , "127.0.0.1" , ar3 - > assertTrue ( ar3 . succeeded ( ) ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testSendAfterCloseFails ( ) { peer1 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer2 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer1 . close ( ar - > { assertTrue ( ar . succeeded ( ) ) ; peer1 . send ( "Test" , 1234 , "127.0.0.1" , ar2 - > { assertTrue ( ar2 . failed ( ) ) ; peer1 = null ; peer2 . close ( ar3 - > { assertTrue ( ar3 . succeeded ( ) ) ; peer2 . send ( "Test" , 1234 , "127.0.0.1" , ar4 - > { assertTrue ( ar4 . failed ( ) ) ; peer2 = null ; testComplete ( ) ; } ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testBroadcast ( ) { peer1 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) . setBroadcast ( true ) ) ; peer2 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) . setBroadcast ( true ) ) ; peer2 . exceptionHandler ( t - > fail ( t . getMessage ( ) ) ) ; peer2 . listen ( 1234 , "0.0.0.0" , ar1 - > { assertTrue ( ar1 . succeeded ( ) ) ; Buffer buffer = TestUtils . randomBuffer ( 128 ) ; peer2 . handler ( packet - > { assertEquals ( buffer , packet . data ( ) ) ; testComplete ( ) ; } ) ; peer1 . send ( buffer , 1234 , "255.255.255.255" , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; } ) ; } ) ; await ( ) ; } @ Test public void testBroadcastFailsIfNotConfigured ( ) { peer1 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ; peer1 . send ( "test" , 1234 , "255.255.255.255" , ar - > { assertTrue ( ar . failed ( ) ) ; testComplete ( ) ; } ) ; await ( ) ; } @ Test public void testPause ( ) { } @ Test public void testMulticastJoinLeave ( ) throws Exception { Buffer buffer = TestUtils . randomBuffer ( 128 ) ; String groupAddress = "230.0.0.1" ; String iface = NetworkInterface . getByInetAddress ( InetAddress . getByName ( "127.0.0.1" ) ) . getName ( ) ; AtomicBoolean received = new AtomicBoolean ( ) ; peer1 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) . setMulticastNetworkInterface ( iface ) ) ; peer2 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) . setMulticastNetworkInterface ( iface ) ) ; peer1 . handler ( packet - > { assertEquals ( buffer , packet . data ( ) ) ; received . set ( true ) ; } ) ; peer1 . listen ( 1234 , "0.0.0.0" , ar1 - > { assertTrue ( ar1 . succeeded ( ) ) ; peer1 . listenMulticastGroup ( groupAddress , iface , null , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; peer2 . send ( buffer , 1234 , groupAddress , ar3 - > { assertTrue ( ar3 . succeeded ( ) ) ; vertx . setTimer ( 1000 , id - > { peer1 . unlistenMulticastGroup ( groupAddress , iface , null , ar4 - > { assertTrue ( ar4 . succeeded ( ) ) ; AtomicBoolean receivedAfter = new AtomicBoolean ( ) ; peer1 . handler ( packet - > { receivedAfter . set ( true ) ; } ) ; peer2 . send ( buffer , 1234 , groupAddress , ar5 - > { assertTrue ( ar5 . succeeded ( ) ) ; vertx . setTimer ( 1000 , id2 - > { assertFalse ( receivedAfter . get ( ) ) ; assertTrue ( received . get ( ) ) ; testComplete ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } ) ; await ( ) ; } @ Test public void testOptions ( ) { DatagramSocketOptions options = new DatagramSocketOptions ( ) ; assertEquals ( NetworkOptions . DEFAULT_SEND_BUFFER_SIZE , options . getSendBufferSize ( ) ) ; int rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setSendBufferSize ( rand ) ) ; assertEquals ( rand , options . getSendBufferSize ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setSendBufferSize ( 0 ) ) ; assertIllegalArgumentException ( ( ) - > options . setSendBufferSize ( - 123 ) ) ; assertEquals ( NetworkOptions . DEFAULT_RECEIVE_BUFFER_SIZE , options . getReceiveBufferSize ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setReceiveBufferSize ( rand ) ) ; assertEquals ( rand , options . getReceiveBufferSize ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setReceiveBufferSize ( 0 ) ) ; assertIllegalArgumentException ( ( ) - > options . setReceiveBufferSize ( - 123 ) ) ; assertFalse ( options . isReuseAddress ( ) ) ; assertEquals ( options , options . setReuseAddress ( true ) ) ; assertTrue ( options . isReuseAddress ( ) ) ; assertEquals ( NetworkOptions . DEFAULT_TRAFFIC_CLASS , options . getTrafficClass ( ) ) ; rand = 23 ; assertEquals ( options , options . setTrafficClass ( rand ) ) ; assertEquals ( rand , options . getTrafficClass ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setTrafficClass ( - 1 ) ) ; assertIllegalArgumentException ( ( ) - > options . setTrafficClass ( 256 ) ) ; assertFalse ( options . isBroadcast ( ) ) ; assertEquals ( options , options . setBroadcast ( true ) ) ; assertTrue ( options . isBroadcast ( ) ) ; assertTrue ( options . isLoopbackModeDisabled ( ) ) ; assertEquals ( options , options . setLoopbackModeDisabled ( false ) ) ; assertFalse ( options . isLoopbackModeDisabled ( ) ) ; assertEquals ( - 1 , options . getMulticastTimeToLive ( ) ) ; rand = TestUtils . randomPositiveInt ( ) ; assertEquals ( options , options . setMulticastTimeToLive ( rand ) ) ; assertEquals ( rand , options . getMulticastTimeToLive ( ) ) ; assertIllegalArgumentException ( ( ) - > options . setMulticastTimeToLive ( - 1 ) ) ; assertNull ( options . getMulticastNetworkInterface ( ) ) ; String randString = TestUtils . randomUnicodeString ( 100 ) ; assertEquals ( options , options . setMulticastNetworkInterface ( randString ) ) ; assertEquals ( randString , options . getMulticastNetworkInterface ( ) ) ; assertFalse ( options . isIpV6 ( ) ) ; assertEquals ( options , options . setIpV6 ( true ) ) ; assertTrue ( options . isIpV6 ( ) ) ; testComplete ( ) ; } @ Test public void testCopyOptions ( ) { DatagramSocketOptions options = new DatagramSocketOptions ( ) ; Random rand = new Random ( ) ; boolean broadcast = rand . nextBoolean ( ) ; boolean loopbackModeDisabled = rand . nextBoolean ( ) ; int multicastTimeToLive = TestUtils . randomPositiveInt ( ) ; String multicastNetworkInterface = TestUtils . randomAlphaString ( 100 ) ; boolean reuseAddress = rand . nextBoolean ( ) ; boolean ipV6 = rand . nextBoolean ( ) ; options . setBroadcast ( broadcast ) ; options . setLoopbackModeDisabled ( loopbackModeDisabled ) ; options . setMulticastTimeToLive ( multicastTimeToLive ) ; options . setMulticastNetworkInterface ( multicastNetworkInterface ) ; options . setReuseAddress ( reuseAddress ) ; options . setIpV6 ( ipV6 ) ; DatagramSocketOptions copy = new DatagramSocketOptions ( options ) ; assertEquals ( broadcast , copy . isBroadcast ( ) ) ; assertEquals ( loopbackModeDisabled , copy . isLoopbackModeDisabled ( ) ) ; assertEquals ( multicastTimeToLive , copy . getMulticastTimeToLive ( ) ) ; assertEquals ( multicastNetworkInterface , copy . getMulticastNetworkInterface ( ) ) ; assertEquals ( reuseAddress , copy . isReuseAddress ( ) ) ; assertEquals ( ipV6 , copy . isIpV6 ( ) ) ; testComplete ( ) ; } @ Test public void testDefaultJsonOptions ( ) { DatagramSocketOptions def = new DatagramSocketOptions ( ) ; DatagramSocketOptions json = new DatagramSocketOptions ( new JsonObject ( ) ) ; assertEquals ( def . isBroadcast ( ) , json . isBroadcast ( ) ) ; assertEquals ( def . isLoopbackModeDisabled ( ) , json . isLoopbackModeDisabled ( ) ) ; assertEquals ( def . getMulticastTimeToLive ( ) , json . getMulticastTimeToLive ( ) ) ; assertEquals ( def . getMulticastNetworkInterface ( ) , json . getMulticastNetworkInterface ( ) ) ; assertEquals ( def . isIpV6 ( ) , json . isIpV6 ( ) ) ; } @ Test public void testCopyOptionsJson ( ) { Random rand = new Random ( ) ; boolean broadcast = rand . nextBoolean ( ) ; boolean loopbackModeDisabled = rand . nextBoolean ( ) ; int multicastTimeToLive = TestUtils . randomPositiveInt ( ) ; String multicastNetworkInterface = TestUtils . randomAlphaString ( 100 ) ; boolean reuseAddress = rand . nextBoolean ( ) ; boolean ipV6 = rand . nextBoolean ( ) ; JsonObject json = new JsonObject ( ) . put ( "broadcast" , broadcast ) . put ( "loopbackModeDisabled" , loopbackModeDisabled ) . put ( "multicastTimeToLive" , multicastTimeToLive ) . put ( "multicastNetworkInterface" , multicastNetworkInterface ) . put ( "reuseAddress" , reuseAddress ) . put ( "ipV6" , ipV6 ) ; DatagramSocketOptions copy = new DatagramSocketOptions ( json ) ; assertEquals ( broadcast , copy . isBroadcast ( ) ) ; assertEquals ( loopbackModeDisabled , copy . isLoopbackModeDisabled ( ) ) ; assertEquals ( multicastTimeToLive , copy . getMulticastTimeToLive ( ) ) ; assertEquals ( multicastNetworkInterface , copy . getMulticastNetworkInterface ( ) ) ; assertEquals ( reuseAddress , copy . isReuseAddress ( ) ) ; assertEquals ( ipV6 , copy . isIpV6 ( ) ) ; testComplete ( ) ; } @ Test public void testOptionsCopied ( ) { DatagramSocketOptions options = new DatagramSocketOptions ( ) ; options . setReuseAddress ( true ) ; peer1 = vertx . createDatagramSocket ( options ) ; peer2 = vertx . createDatagramSocket ( options ) ; options . setReuseAddress ( false ) ; peer1 . listen ( 1234 , "127.0.0.1" , ar - > { assertTrue ( ar . succeeded ( ) ) ; peer2 . listen ( 1234 , "127.0.0.1" , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testUseInMultithreadedWorker ( ) throws Exception { class MyVerticle extends AbstractVerticle { @ Override public void start ( ) { assertIllegalStateException ( ( ) - > peer1 = vertx . createDatagramSocket ( new DatagramSocketOptions ( ) ) ) ; testComplete ( ) ; } } MyVerticle verticle = new MyVerticle ( ) ; vertx . deployVerticle ( verticle , new DeploymentOptions ( ) . setWorker ( true ) . setMultiThreaded ( true ) ) ; await ( ) ; } }
package io . vertx . test . fakemetrics ; import java . util . concurrent . atomic . AtomicInteger ; public class HandlerMetric { public final String address ; public final boolean replyHandler ; public final AtomicInteger beginCount = new AtomicInteger ( ) ; public final AtomicInteger endCount = new AtomicInteger ( ) ; public final AtomicInteger failureCount = new AtomicInteger ( ) ; public final AtomicInteger localCount = new AtomicInteger ( ) ; public HandlerMetric ( String address , boolean replyHandler ) { this . address = address ; this . replyHandler = replyHandler ; } @ Override public String toString ( ) { return "HandlerRegistration[address=" + address + ",replyHandler=" + replyHandler + ",beginCount=" + beginCount . get ( ) + ",endCount=" + endCount . get ( ) + ",failureCount=" + failureCount + ",localCount=" + localCount . get ( ) + "]" ; } }
package io . vertx . test . fakemetrics ; import io . vertx . core . Vertx ; import io . vertx . core . VertxOptions ; import io . vertx . core . spi . VertxMetricsFactory ; import io . vertx . core . spi . metrics . VertxMetrics ; public class FakeMetricsFactory implements VertxMetricsFactory { @ Override public VertxMetrics metrics ( Vertx vertx , VertxOptions options ) { return new FakeVertxMetrics ( vertx ) ; } }
package io . vertx . test . fakemetrics ; import io . vertx . core . http . HttpServer ; import io . vertx . core . http . HttpServerRequest ; import io . vertx . core . http . HttpServerResponse ; import io . vertx . core . http . ServerWebSocket ; import io . vertx . core . http . WebSocketBase ; import io . vertx . core . net . SocketAddress ; import io . vertx . core . spi . metrics . HttpServerMetrics ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class FakeHttpServerMetrics extends FakeMetricsBase implements HttpServerMetrics < HttpServerMetric , WebSocketMetric , SocketMetric > { private final ConcurrentMap < WebSocketBase , WebSocketMetric > webSockets = new ConcurrentHashMap < > ( ) ; private final ConcurrentMap < HttpServerRequest , HttpServerMetric > requests = new ConcurrentHashMap < > ( ) ; public final HttpServer server ; public FakeHttpServerMetrics ( HttpServer server ) { super ( server ) ; this . server = server ; } public WebSocketMetric getMetric ( ServerWebSocket ws ) { return webSockets . get ( ws ) ; } public HttpServerMetric getMetric ( HttpServerRequest requests ) { return this . requests . get ( requests ) ; } @ Override public HttpServerMetric requestBegin ( SocketMetric socketMetric , HttpServerRequest request ) { HttpServerMetric metric = new HttpServerMetric ( request , socketMetric ) ; requests . put ( request , metric ) ; return metric ; } @ Override public void responseEnd ( HttpServerMetric requestMetric , HttpServerResponse response ) { requests . remove ( requestMetric . request ) ; } @ Override public WebSocketMetric upgrade ( HttpServerMetric requestMetric , ServerWebSocket serverWebSocket ) { requests . remove ( requestMetric . request ) ; WebSocketMetric metric = new WebSocketMetric ( requestMetric . socket , serverWebSocket ) ; webSockets . put ( serverWebSocket , metric ) ; return metric ; } @ Override public WebSocketMetric connected ( SocketMetric socketMetric , ServerWebSocket serverWebSocket ) { WebSocketMetric metric = new WebSocketMetric ( socketMetric , serverWebSocket ) ; webSockets . put ( serverWebSocket , metric ) ; return metric ; } @ Override public void disconnected ( WebSocketMetric serverWebSocketMetric ) { webSockets . remove ( serverWebSocketMetric . ws ) ; } @ Override public SocketMetric connected ( SocketAddress remoteAddress ) { return new SocketMetric ( remoteAddress ) ; } @ Override public void disconnected ( SocketMetric socketMetric , SocketAddress remoteAddress ) { socketMetric . connected . set ( false ) ; } @ Override public void bytesRead ( SocketMetric socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { socketMetric . bytesRead . addAndGet ( numberOfBytes ) ; } @ Override public void bytesWritten ( SocketMetric socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { socketMetric . bytesWritten . addAndGet ( numberOfBytes ) ; } @ Override public void exceptionOccurred ( SocketMetric socketMetric , SocketAddress remoteAddress , Throwable t ) { } @ Override public boolean isEnabled ( ) { return true ; } @ Override public void close ( ) { } }
package io . vertx . test . fakemetrics ; import io . vertx . core . http . WebSocketBase ; public class WebSocketMetric { public final SocketMetric soMetric ; public final WebSocketBase ws ; public WebSocketMetric ( SocketMetric soMetric , WebSocketBase ws ) { this . soMetric = soMetric ; this . ws = ws ; } }
package io . vertx . test . fakemetrics ; public class ReceivedMessage { public final String address ; public final boolean publish ; public final boolean local ; public final int handlers ; public ReceivedMessage ( String address , boolean publish , boolean local , int handlers ) { this . address = address ; this . publish = publish ; this . local = local ; this . handlers = handlers ; } @ Override public boolean equals ( Object obj ) { ReceivedMessage that = ( ReceivedMessage ) obj ; return address . equals ( that . address ) && publish == that . publish && local == that . local && handlers == that . handlers ; } @ Override public String toString ( ) { return "Message[address" + address + ",publish=" + publish + ",local=" + local + ",handlers=" + handlers + "]" ; } }
package io . vertx . test . fakemetrics ; import io . vertx . core . net . SocketAddress ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicLong ; public class SocketMetric { public final SocketAddress remoteAddress ; public final AtomicBoolean connected = new AtomicBoolean ( true ) ; public final AtomicLong bytesRead = new AtomicLong ( ) ; public final AtomicLong bytesWritten = new AtomicLong ( ) ; public SocketMetric ( SocketAddress remoteAddress ) { this . remoteAddress = remoteAddress ; } }
package io . vertx . test . fakemetrics ; import io . vertx . core . eventbus . EventBus ; import io . vertx . core . eventbus . ReplyFailure ; import io . vertx . core . spi . metrics . EventBusMetrics ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . atomic . AtomicInteger ; public class FakeEventBusMetrics extends FakeMetricsBase implements EventBusMetrics < HandlerMetric > { private final List < SentMessage > sentMessages = Collections . synchronizedList ( new ArrayList < > ( ) ) ; private final List < ReceivedMessage > receivedMessages = Collections . synchronizedList ( new ArrayList < > ( ) ) ; private final List < HandlerMetric > registrations = new ArrayList < > ( ) ; private final Map < String , AtomicInteger > encoded = new ConcurrentHashMap < > ( ) ; private final Map < String , AtomicInteger > decoded = new ConcurrentHashMap < > ( ) ; public FakeEventBusMetrics ( EventBus eventBus ) { super ( eventBus ) ; } public Map < String , AtomicInteger > getEncoded ( ) { return encoded ; } public Map < String , AtomicInteger > getDecoded ( ) { return decoded ; } public List < SentMessage > getSentMessages ( ) { return sentMessages ; } public List < ReceivedMessage > getReceivedMessages ( ) { return receivedMessages ; } public List < HandlerMetric > getRegistrations ( ) { return registrations ; } public int getEncodedBytes ( String address ) { AtomicInteger value = encoded . get ( address ) ; return value != null ? value . get ( ) : 0 ; } public int getDecodedBytes ( String address ) { AtomicInteger value = decoded . get ( address ) ; return value != null ? value . get ( ) : 0 ; } @ Override public HandlerMetric handlerRegistered ( String address , boolean replyHandler ) { HandlerMetric registration = new HandlerMetric ( address , replyHandler ) ; registrations . add ( registration ) ; return registration ; } public void handlerUnregistered ( HandlerMetric handler ) { registrations . remove ( handler ) ; } @ Override public void beginHandleMessage ( HandlerMetric handler , boolean local ) { handler . beginCount . incrementAndGet ( ) ; if ( local ) { handler . localCount . incrementAndGet ( ) ; } } public void endHandleMessage ( HandlerMetric handler , Throwable failure ) { handler . endCount . incrementAndGet ( ) ; if ( failure != null ) { handler . failureCount . incrementAndGet ( ) ; } } @ Override public void messageSent ( String address , boolean publish , boolean local , boolean remote ) { sentMessages . add ( new SentMessage ( address , publish , local , remote ) ) ; } @ Override public void messageReceived ( String address , boolean publish , boolean local , int handlers ) { receivedMessages . add ( new ReceivedMessage ( address , publish , local , handlers ) ) ; } @ Override public void messageWritten ( String address , int numberOfBytes ) { AtomicInteger value = new AtomicInteger ( ) ; AtomicInteger existing = encoded . putIfAbsent ( address , value ) ; if ( existing != null ) { value = existing ; } value . addAndGet ( numberOfBytes ) ; } @ Override public void messageRead ( String address , int numberOfBytes ) { AtomicInteger value = new AtomicInteger ( ) ; AtomicInteger existing = decoded . putIfAbsent ( address , value ) ; if ( existing != null ) { value = existing ; } value . addAndGet ( numberOfBytes ) ; } public void replyFailure ( String address , ReplyFailure failure ) { throw new UnsupportedOperationException ( ) ; } public boolean isEnabled ( ) { throw new UnsupportedOperationException ( ) ; } public void close ( ) { } }
package io . vertx . test . fakemetrics ; import io . vertx . core . http . HttpClientRequest ; public class HttpClientMetric { public final HttpClientRequest request ; public final SocketMetric socket ; public HttpClientMetric ( HttpClientRequest request , SocketMetric socket ) { this . request = request ; this . socket = socket ; } }
package io . vertx . test . fakemetrics ; import io . vertx . core . http . HttpClient ; import io . vertx . core . http . HttpClientRequest ; import io . vertx . core . http . HttpClientResponse ; import io . vertx . core . http . WebSocket ; import io . vertx . core . http . WebSocketBase ; import io . vertx . core . net . SocketAddress ; import io . vertx . core . spi . metrics . HttpClientMetrics ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class FakeHttpClientMetrics extends FakeMetricsBase implements HttpClientMetrics < HttpClientMetric , WebSocketMetric , SocketMetric > { private final ConcurrentMap < WebSocketBase , WebSocketMetric > webSockets = new ConcurrentHashMap < > ( ) ; private final ConcurrentMap < HttpClientRequest , HttpClientMetric > requests = new ConcurrentHashMap < > ( ) ; public WebSocketMetric getMetric ( WebSocket ws ) { return webSockets . get ( ws ) ; } public HttpClientMetric getMetric ( HttpClientRequest request ) { return requests . get ( request ) ; } public FakeHttpClientMetrics ( HttpClient measured ) { super ( measured ) ; } @ Override public WebSocketMetric connected ( SocketMetric socketMetric , WebSocket webSocket ) { WebSocketMetric metric = new WebSocketMetric ( socketMetric , webSocket ) ; webSockets . put ( webSocket , metric ) ; return metric ; } @ Override public void disconnected ( WebSocketMetric webSocketMetric ) { webSockets . remove ( webSocketMetric . ws ) ; } @ Override public HttpClientMetric requestBegin ( SocketMetric socketMetric , SocketAddress localAddress , SocketAddress remoteAddress , HttpClientRequest request ) { HttpClientMetric metric = new HttpClientMetric ( request , socketMetric ) ; requests . put ( request , metric ) ; return metric ; } @ Override public void responseEnd ( HttpClientMetric requestMetric , HttpClientResponse response ) { requests . remove ( requestMetric . request ) ; } @ Override public SocketMetric connected ( SocketAddress remoteAddress ) { return new SocketMetric ( remoteAddress ) ; } @ Override public void disconnected ( SocketMetric socketMetric , SocketAddress remoteAddress ) { socketMetric . connected . set ( false ) ; } @ Override public void bytesRead ( SocketMetric socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { socketMetric . bytesRead . addAndGet ( numberOfBytes ) ; } @ Override public void bytesWritten ( SocketMetric socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { socketMetric . bytesWritten . addAndGet ( numberOfBytes ) ; } @ Override public void exceptionOccurred ( SocketMetric socketMetric , SocketAddress remoteAddress , Throwable t ) { } @ Override public boolean isEnabled ( ) { return true ; } @ Override public void close ( ) { } }
package io . vertx . test . fakemetrics ; import io . vertx . core . Verticle ; import io . vertx . core . Vertx ; import io . vertx . core . datagram . DatagramSocket ; import io . vertx . core . datagram . DatagramSocketOptions ; import io . vertx . core . eventbus . EventBus ; import io . vertx . core . http . HttpClient ; import io . vertx . core . http . HttpClientOptions ; import io . vertx . core . http . HttpServer ; import io . vertx . core . http . HttpServerOptions ; import io . vertx . core . net . NetClient ; import io . vertx . core . net . NetClientOptions ; import io . vertx . core . net . NetServer ; import io . vertx . core . net . NetServerOptions ; import io . vertx . core . net . SocketAddress ; import io . vertx . core . spi . metrics . DatagramSocketMetrics ; import io . vertx . core . spi . metrics . EventBusMetrics ; import io . vertx . core . spi . metrics . HttpClientMetrics ; import io . vertx . core . spi . metrics . HttpServerMetrics ; import io . vertx . core . spi . metrics . TCPMetrics ; import io . vertx . core . spi . metrics . VertxMetrics ; public class FakeVertxMetrics extends FakeMetricsBase implements VertxMetrics { public FakeVertxMetrics ( Vertx vertx ) { super ( vertx ) ; } @ Override public boolean isMetricsEnabled ( ) { return true ; } public void verticleDeployed ( Verticle verticle ) { } public void verticleUndeployed ( Verticle verticle ) { } public void timerCreated ( long id ) { } public void timerEnded ( long id , boolean cancelled ) { } public EventBusMetrics createMetrics ( EventBus eventBus ) { return new FakeEventBusMetrics ( eventBus ) ; } public HttpServerMetrics < ? , ? , ? > createMetrics ( HttpServer server , SocketAddress localAddress , HttpServerOptions options ) { return new FakeHttpServerMetrics ( server ) ; } public HttpClientMetrics < ? , ? , ? > createMetrics ( HttpClient client , HttpClientOptions options ) { return new FakeHttpClientMetrics ( client ) ; } public TCPMetrics < ? > createMetrics ( NetServer server , SocketAddress localAddress , NetServerOptions options ) { return new TCPMetrics < Object > ( ) { public Object connected ( SocketAddress remoteAddress ) { return null ; } public void disconnected ( Object socketMetric , SocketAddress remoteAddress ) { } public void bytesRead ( Object socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { } public void bytesWritten ( Object socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { } public void exceptionOccurred ( Object socketMetric , SocketAddress remoteAddress , Throwable t ) { } public boolean isEnabled ( ) { return false ; } public void close ( ) { } } ; } public TCPMetrics < ? > createMetrics ( NetClient client , NetClientOptions options ) { return new TCPMetrics < Object > ( ) { public Object connected ( SocketAddress remoteAddress ) { return null ; } public void disconnected ( Object socketMetric , SocketAddress remoteAddress ) { } public void bytesRead ( Object socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { } public void bytesWritten ( Object socketMetric , SocketAddress remoteAddress , long numberOfBytes ) { } public void exceptionOccurred ( Object socketMetric , SocketAddress remoteAddress , Throwable t ) { } public boolean isEnabled ( ) { return false ; } public void close ( ) { } } ; } public DatagramSocketMetrics createMetrics ( DatagramSocket socket , DatagramSocketOptions options ) { throw new UnsupportedOperationException ( ) ; } public boolean isEnabled ( ) { throw new UnsupportedOperationException ( ) ; } }
package io . vertx . test . core ; import io . vertx . core . AbstractVerticle ; import io . vertx . core . Context ; import io . vertx . core . Future ; import java . util . HashSet ; import java . util . Set ; public class TestVerticle2 extends AbstractVerticle { private static Set < Context > contexts = new HashSet < > ( ) ; @ Override public void start ( ) throws Exception { synchronized ( contexts ) { if ( contexts . contains ( context ) ) { throw new IllegalStateException ( "Same context!" ) ; } else { contexts . add ( context ) ; vertx . eventBus ( ) . send ( "tvstarted" , "started" ) ; } } } @ Override public void stop ( Future < Void > stopFuture ) throws Exception { vertx . eventBus ( ) . send ( "tvstopped" , "stopped" , reply - > { stopFuture . complete ( null ) ; } ) ; } }
package io . vertx . test . fakemetrics ; public class SentMessage { public final String address ; public final boolean publish ; public final boolean local ; public final boolean remote ; public SentMessage ( String address , boolean publish , boolean local , boolean remote ) { this . address = address ; this . publish = publish ; this . local = local ; this . remote = remote ; } @ Override public boolean equals ( Object obj ) { SentMessage that = ( SentMessage ) obj ; return address . equals ( that . address ) && publish == that . publish && local == that . local && remote == that . remote ; } @ Override public String toString ( ) { return "Message[address=" + address + ",publish=" + publish + ",local=" + local + ",remote=" + remote + "]" ; } }
package io . vertx . test . fakemetrics ; import io . vertx . core . Vertx ; import io . vertx . core . metrics . Measured ; import io . vertx . core . spi . metrics . Metrics ; import java . util . concurrent . ConcurrentHashMap ; public class FakeMetricsBase implements Metrics { private static final ConcurrentHashMap < Object , FakeMetricsBase > metricsMap = new ConcurrentHashMap < > ( ) ; public static < M extends FakeMetricsBase > M getMetrics ( Measured measured ) { return ( M ) metricsMap . get ( measured ) ; } final Measured key ; public FakeMetricsBase ( Measured measured ) { metricsMap . put ( measured , this ) ; key = measured ; } @ Override public boolean isEnabled ( ) { return false ; } @ Override public void close ( ) { metricsMap . remove ( key ) ; } }
package io . vertx . core . logging ; import org . junit . Test ; public class LoggerFactoryTest { @ Test public void testProperlyLogFromAnonymousClass ( ) { new Runnable ( ) { @ Override public void run ( ) { LoggerFactory . getLogger ( getClass ( ) ) . info ( "I'm inside anonymous class" ) ; } } . run ( ) ; } }
@ Document ( fileName = "override/verticles.adoc" ) package docoverride . verticles ; import io . vertx . docgen . Document ;
@ Document ( fileName = "override/verticle-configuration.adoc" ) package docoverride . verticles . configuration ; import io . vertx . docgen . Document ;
@ Document ( fileName = "override/dns.adoc" ) package docoverride . dns ; import io . vertx . docgen . Document ;
package docoverride . dns ; import io . vertx . core . Vertx ; import io . vertx . core . dns . DnsClient ; import io . vertx . core . dns . DnsException ; import io . vertx . core . dns . DnsResponseCode ; import io . vertx . docgen . Source ; @ Source public class Examples { public void example16 ( Vertx vertx ) { DnsClient client = vertx . createDnsClient ( 53 , "10.0.0.1" ) ; client . lookup ( "nonexisting.vert.xio" , ar - > { if ( ar . succeeded ( ) ) { String record = ar . result ( ) ; System . out . println ( record ) ; } else { Throwable cause = ar . cause ( ) ; if ( cause instanceof DnsException ) { DnsException exception = ( DnsException ) cause ; DnsResponseCode code = exception . code ( ) ; } else { System . out . println ( "Failed to resolve entry" + ar . cause ( ) ) ; } } } ) ; } }
@ Document ( fileName = "override/eventbus.adoc" ) package docoverride . eventbus ; import io . vertx . docgen . Document ;
package docoverride . eventbus ; import io . vertx . core . eventbus . DeliveryOptions ; import io . vertx . core . eventbus . EventBus ; import io . vertx . core . eventbus . MessageCodec ; import io . vertx . docgen . Source ; @ Source public class Examples { public void example10 ( EventBus eventBus , MessageCodec myCodec ) { eventBus . registerCodec ( myCodec ) ; DeliveryOptions options = new DeliveryOptions ( ) . setCodecName ( myCodec . name ( ) ) ; eventBus . send ( "orders" , new MyPOJO ( ) , options ) ; } public void example11 ( EventBus eventBus , MessageCodec myCodec ) { eventBus . registerDefaultCodec ( MyPOJO . class , myCodec ) ; eventBus . send ( "orders" , new MyPOJO ( ) ) ; } public void headers ( EventBus eventBus ) { DeliveryOptions options = new DeliveryOptions ( ) ; options . addHeader ( "some-header" , "some-value" ) ; eventBus . send ( "news.uk.sport" , "Yay! Someone kicked a ball" , options ) ; } class MyPOJO { } }
@ Document ( fileName = "override/eventbus_headers.adoc" ) package docoverride . eventbus . headers ; import io . vertx . docgen . Document ;
package io . vertx . test . core ; import io . vertx . core . Vertx ; import io . vertx . core . shareddata . Lock ; import org . junit . Test ; import static io . vertx . test . core . TestUtils . assertIllegalArgumentException ; import static io . vertx . test . core . TestUtils . assertNullPointerException ; public class AsynchronousLockTest extends VertxTestBase { protected Vertx getVertx ( ) { return vertx ; } @ Test public void testIllegalArguments ( ) throws Exception { assertNullPointerException ( ( ) - > getVertx ( ) . sharedData ( ) . getLock ( null , ar - > { } ) ) ; assertNullPointerException ( ( ) - > getVertx ( ) . sharedData ( ) . getLock ( "foo" , null ) ) ; assertNullPointerException ( ( ) - > getVertx ( ) . sharedData ( ) . getLockWithTimeout ( null , 1 , ar - > { } ) ) ; assertNullPointerException ( ( ) - > getVertx ( ) . sharedData ( ) . getLockWithTimeout ( "foo" , 1 , null ) ) ; assertIllegalArgumentException ( ( ) - > getVertx ( ) . sharedData ( ) . getLockWithTimeout ( "foo" , - 1 , ar - > { } ) ) ; } @ Test public void testAcquire ( ) { getVertx ( ) . sharedData ( ) . getLock ( "foo" , ar - > { assertTrue ( ar . succeeded ( ) ) ; long start = System . currentTimeMillis ( ) ; Lock lock = ar . result ( ) ; vertx . setTimer ( 1000 , tid - > { lock . release ( ) ; } ) ; getVertx ( ) . sharedData ( ) . getLock ( "foo" , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertTrue ( System . currentTimeMillis ( ) - start >= 1000 ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testAcquireDifferentLocks ( ) { getVertx ( ) . sharedData ( ) . getLock ( "foo" , ar - > { assertTrue ( ar . succeeded ( ) ) ; long start = System . currentTimeMillis ( ) ; Lock lock = ar . result ( ) ; getVertx ( ) . sharedData ( ) . getLock ( "bar" , ar2 - > { assertTrue ( ar2 . succeeded ( ) ) ; assertTrue ( System . currentTimeMillis ( ) - start < 2000 ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } @ Test public void testAcquireTimeout ( ) { getVertx ( ) . sharedData ( ) . getLock ( "foo" , ar - > { assertTrue ( ar . succeeded ( ) ) ; long start = System . currentTimeMillis ( ) ; getVertx ( ) . sharedData ( ) . getLockWithTimeout ( "foo" , 1000 , ar2 - > { assertFalse ( ar2 . succeeded ( ) ) ; assertTrue ( System . currentTimeMillis ( ) - start >= 1000 ) ; testComplete ( ) ; } ) ; } ) ; await ( ) ; } }
