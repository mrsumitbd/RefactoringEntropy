package uk . co . real_logic . aeron . tools ; import org . junit . Test ; import java . util . ArrayList ; import java . util . List ; public class MessagesAtBitsPerSecondTest { RateController rc ; List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; @ Test public void createWithOneAndOne ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new MessagesAtBitsPerSecondInterval ( 1 , 1 ) ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithZeroBitsPerSecond ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new MessagesAtBitsPerSecondInterval ( 1 , 0 ) ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithZeroMessages ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new MessagesAtBitsPerSecondInterval ( 0 , 1 ) ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithNegativeMessages ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new MessagesAtBitsPerSecondInterval ( - 1 , 1 ) ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithNegativeBitsPerSecond ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new MessagesAtBitsPerSecondInterval ( 1 , - 1 ) ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } }
package uk . co . real_logic . aeron . command ; public class ControlProtocolEvents { public static final int ADD_PUBLICATION = 0x01 ; public static final int REMOVE_PUBLICATION = 0x02 ; public static final int ADD_SUBSCRIPTION = 0x04 ; public static final int REMOVE_SUBSCRIPTION = 0x05 ; public static final int CLIENT_KEEPALIVE = 0x06 ; public static final int ON_ERROR = 0x0F01 ; public static final int ON_CONNECTION_READY = 0x0F02 ; public static final int ON_PUBLICATION_READY = 0x0F03 ; public static final int ON_OPERATION_SUCCESS = 0x0F04 ; public static final int ON_INACTIVE_CONNECTION = 0x0F05 ; }
package uk . co . real_logic . aeron . command ; import uk . co . real_logic . aeron . Flyweight ; import java . nio . ByteOrder ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_INT ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class PublicationBuffersReadyFlyweight extends Flyweight { private static final int CORRELATION_ID_OFFSET = 0 ; private static final int SESSION_ID_OFFSET = CORRELATION_ID_OFFSET + SIZE_OF_LONG ; private static final int STREAM_ID_FIELD_OFFSET = SESSION_ID_OFFSET + SIZE_OF_INT ; private static final int PUBLICATION_LIMIT_COUNTER_ID_OFFSET = STREAM_ID_FIELD_OFFSET + SIZE_OF_INT ; private static final int LOGFILE_FIELD_OFFSET = PUBLICATION_LIMIT_COUNTER_ID_OFFSET + SIZE_OF_INT ; public long correlationId ( ) { return buffer ( ) . getLong ( offset ( ) + CORRELATION_ID_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public PublicationBuffersReadyFlyweight correlationId ( final long correlationId ) { buffer ( ) . putLong ( offset ( ) + CORRELATION_ID_OFFSET , correlationId , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public int sessionId ( ) { return buffer ( ) . getInt ( offset ( ) + SESSION_ID_OFFSET , LITTLE_ENDIAN ) ; } public PublicationBuffersReadyFlyweight sessionId ( final int sessionId ) { buffer ( ) . putInt ( offset ( ) + SESSION_ID_OFFSET , sessionId , LITTLE_ENDIAN ) ; return this ; } public int streamId ( ) { return buffer ( ) . getInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public PublicationBuffersReadyFlyweight streamId ( final int streamId ) { buffer ( ) . putInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , streamId , LITTLE_ENDIAN ) ; return this ; } public int publicationLimitCounterId ( ) { return buffer ( ) . getInt ( offset ( ) + PUBLICATION_LIMIT_COUNTER_ID_OFFSET , LITTLE_ENDIAN ) ; } public PublicationBuffersReadyFlyweight publicationLimitCounterId ( final int positionCounterId ) { buffer ( ) . putInt ( offset ( ) + PUBLICATION_LIMIT_COUNTER_ID_OFFSET , positionCounterId , LITTLE_ENDIAN ) ; return this ; } public String logFileName ( ) { return buffer ( ) . getStringUtf8 ( offset ( ) + LOGFILE_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public PublicationBuffersReadyFlyweight logFileName ( final String logFileName ) { buffer ( ) . putStringUtf8 ( offset ( ) + LOGFILE_FIELD_OFFSET , logFileName , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public int length ( ) { return buffer ( ) . getInt ( offset ( ) + LOGFILE_FIELD_OFFSET ) + LOGFILE_FIELD_OFFSET + SIZE_OF_INT ; } }
package uk . co . real_logic . aeron . command ; import uk . co . real_logic . aeron . Flyweight ; import java . nio . ByteOrder ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_INT ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class ConnectionBuffersReadyFlyweight extends Flyweight { private static final int CORRELATION_ID_OFFSET = 0 ; private static final int JOINING_POSITION_OFFSET = CORRELATION_ID_OFFSET + SIZE_OF_LONG ; private static final int SESSION_ID_OFFSET = JOINING_POSITION_OFFSET + SIZE_OF_LONG ; private static final int STREAM_ID_FIELD_OFFSET = SESSION_ID_OFFSET + SIZE_OF_INT ; private static final int SUBSCRIBER_POSITION_COUNT_OFFSET = STREAM_ID_FIELD_OFFSET + SIZE_OF_INT ; private static final int LOGFILE_FIELD_OFFSET = SUBSCRIBER_POSITION_COUNT_OFFSET + SIZE_OF_INT ; private static final int SUBSCRIBER_POSITION_FIELD_SIZE = SIZE_OF_LONG + SIZE_OF_INT ; public long correlationId ( ) { return buffer ( ) . getLong ( offset ( ) + CORRELATION_ID_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public ConnectionBuffersReadyFlyweight correlationId ( final long correlationId ) { buffer ( ) . putLong ( offset ( ) + CORRELATION_ID_OFFSET , correlationId , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public long joiningPosition ( ) { return buffer ( ) . getLong ( offset ( ) + JOINING_POSITION_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public ConnectionBuffersReadyFlyweight joiningPosition ( final long joiningPosition ) { buffer ( ) . putLong ( offset ( ) + JOINING_POSITION_OFFSET , joiningPosition , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public int sessionId ( ) { return buffer ( ) . getInt ( offset ( ) + SESSION_ID_OFFSET , LITTLE_ENDIAN ) ; } public ConnectionBuffersReadyFlyweight sessionId ( final int sessionId ) { buffer ( ) . putInt ( offset ( ) + SESSION_ID_OFFSET , sessionId , LITTLE_ENDIAN ) ; return this ; } public int streamId ( ) { return buffer ( ) . getInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public ConnectionBuffersReadyFlyweight streamId ( final int streamId ) { buffer ( ) . putInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , streamId , LITTLE_ENDIAN ) ; return this ; } public int subscriberPositionCount ( ) { return buffer ( ) . getInt ( offset ( ) + SUBSCRIBER_POSITION_COUNT_OFFSET , LITTLE_ENDIAN ) ; } public ConnectionBuffersReadyFlyweight subscriberPositionCount ( final int value ) { buffer ( ) . putInt ( offset ( ) + SUBSCRIBER_POSITION_COUNT_OFFSET , value , LITTLE_ENDIAN ) ; return this ; } public String logFileName ( ) { return buffer ( ) . getStringUtf8 ( offset ( ) + LOGFILE_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public ConnectionBuffersReadyFlyweight logFileName ( final String logFileName ) { buffer ( ) . putStringUtf8 ( offset ( ) + LOGFILE_FIELD_OFFSET , logFileName , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public String sourceIdentity ( ) { return buffer ( ) . getStringUtf8 ( sourceIdentityOffset ( ) , LITTLE_ENDIAN ) ; } public ConnectionBuffersReadyFlyweight sourceIdentity ( final String value ) { buffer ( ) . putStringUtf8 ( sourceIdentityOffset ( ) , value , ByteOrder . LITTLE_ENDIAN ) ; return this ; } private int sourceIdentityOffset ( ) { final int logFileNameOffset = offset ( ) + LOGFILE_FIELD_OFFSET ; return buffer ( ) . getInt ( logFileNameOffset ) + logFileNameOffset + SIZE_OF_INT ; } public ConnectionBuffersReadyFlyweight subscriberPositionId ( final int index , final int id ) { buffer ( ) . putInt ( subscriberPositionOffset ( index ) , id ) ; return this ; } public int subscriberPositionId ( final int index ) { return buffer ( ) . getInt ( subscriberPositionOffset ( index ) ) ; } public ConnectionBuffersReadyFlyweight positionIndicatorRegistrationId ( final int index , final long id ) { buffer ( ) . putLong ( subscriberPositionOffset ( index ) + SIZE_OF_INT , id ) ; return this ; } public long positionIndicatorRegistrationId ( final int index ) { return buffer ( ) . getLong ( subscriberPositionOffset ( index ) + SIZE_OF_INT ) ; } private int subscriberPositionOffset ( final int index ) { final int sourceIdentityOffset = sourceIdentityOffset ( ) ; final int endOfSourceIdentity = buffer ( ) . getInt ( sourceIdentityOffset ) + sourceIdentityOffset + SIZE_OF_INT ; return endOfSourceIdentity + index * SUBSCRIBER_POSITION_FIELD_SIZE ; } public int length ( ) { return subscriberPositionOffset ( subscriberPositionCount ( ) - 1 ) + SUBSCRIBER_POSITION_FIELD_SIZE ; } }
package uk . co . real_logic . aeron . command ; import java . nio . ByteOrder ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_INT ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class PublicationMessageFlyweight extends CorrelatedMessageFlyweight { private static final int SESSION_ID_FIELD_OFFSET = CORRELATION_ID_FIELD_OFFSET + SIZE_OF_LONG ; private static final int STREAM_ID_FIELD_OFFSET = SESSION_ID_FIELD_OFFSET + SIZE_OF_INT ; private static final int CHANNEL_OFFSET = STREAM_ID_FIELD_OFFSET + SIZE_OF_INT ; private int lengthOfChannel ; public int sessionId ( ) { return buffer ( ) . getInt ( offset ( ) + SESSION_ID_FIELD_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public PublicationMessageFlyweight sessionId ( final int sessionId ) { buffer ( ) . putInt ( offset ( ) + SESSION_ID_FIELD_OFFSET , sessionId , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public int streamId ( ) { return buffer ( ) . getInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public PublicationMessageFlyweight streamId ( final int streamId ) { buffer ( ) . putInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , streamId , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public String channel ( ) { return stringGet ( offset ( ) + CHANNEL_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public PublicationMessageFlyweight channel ( final String channel ) { lengthOfChannel = stringPut ( offset ( ) + CHANNEL_OFFSET , channel , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public int length ( ) { return CHANNEL_OFFSET + lengthOfChannel ; } }
package uk . co . real_logic . aeron . command ; import uk . co . real_logic . aeron . Flyweight ; import java . nio . ByteOrder ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_INT ; public class ConnectionMessageFlyweight extends Flyweight { private static final int CORRELATION_ID_OFFSET = 0 ; private static final int SESSION_ID_OFFSET = 8 ; private static final int STREAM_ID_FIELD_OFFSET = 12 ; private static final int POSITION_FIELD_OFFSET = 16 ; private static final int CHANNEL_OFFSET = 24 ; private int lengthOfChannel ; public long correlationId ( ) { return buffer ( ) . getLong ( offset ( ) + CORRELATION_ID_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public ConnectionMessageFlyweight correlationId ( final long correlationId ) { buffer ( ) . putLong ( offset ( ) + CORRELATION_ID_OFFSET , correlationId , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public int sessionId ( ) { return buffer ( ) . getInt ( offset ( ) + SESSION_ID_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public ConnectionMessageFlyweight sessionId ( final int sessionId ) { buffer ( ) . putInt ( offset ( ) + SESSION_ID_OFFSET , sessionId , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public int streamId ( ) { return buffer ( ) . getInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public ConnectionMessageFlyweight streamId ( final int streamId ) { buffer ( ) . putInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , streamId , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public long position ( ) { return buffer ( ) . getLong ( offset ( ) + POSITION_FIELD_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public ConnectionMessageFlyweight position ( final long position ) { buffer ( ) . putLong ( offset ( ) + POSITION_FIELD_OFFSET , position , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public String channel ( ) { final int channelOffset = offset ( ) + CHANNEL_OFFSET ; final int length = buffer ( ) . getInt ( channelOffset , ByteOrder . LITTLE_ENDIAN ) ; lengthOfChannel = SIZE_OF_INT + length ; return buffer ( ) . getStringUtf8 ( channelOffset , length ) ; } public ConnectionMessageFlyweight channel ( final String channel ) { lengthOfChannel = stringPut ( offset ( ) + CHANNEL_OFFSET , channel , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public int length ( ) { return CHANNEL_OFFSET + lengthOfChannel ; } }
package uk . co . real_logic . aeron . command ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class RemoveMessageFlyweight extends CorrelatedMessageFlyweight { private static final int REGISTRATION_ID_OFFSET = CORRELATION_ID_FIELD_OFFSET + SIZE_OF_LONG ; public long registrationId ( ) { return buffer ( ) . getLong ( offset ( ) + REGISTRATION_ID_OFFSET , LITTLE_ENDIAN ) ; } public RemoveMessageFlyweight registrationId ( final long registrationId ) { buffer ( ) . putLong ( offset ( ) + REGISTRATION_ID_OFFSET , registrationId , LITTLE_ENDIAN ) ; return this ; } public static int length ( ) { return LENGTH + SIZE_OF_LONG ; } }
package uk . co . real_logic . aeron . command ; import uk . co . real_logic . aeron . Flyweight ; import java . nio . ByteOrder ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class CorrelatedMessageFlyweight extends Flyweight { public static final int CLIENT_ID_FIELD_OFFSET = 0 ; public static final int CORRELATION_ID_FIELD_OFFSET = CLIENT_ID_FIELD_OFFSET + SIZE_OF_LONG ; public static final int LENGTH = 2 * SIZE_OF_LONG ; public long clientId ( ) { return buffer ( ) . getLong ( offset ( ) + CLIENT_ID_FIELD_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public CorrelatedMessageFlyweight clientId ( final long clientId ) { buffer ( ) . putLong ( offset ( ) + CLIENT_ID_FIELD_OFFSET , clientId , ByteOrder . LITTLE_ENDIAN ) ; return this ; } public long correlationId ( ) { return buffer ( ) . getLong ( offset ( ) + CORRELATION_ID_FIELD_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public CorrelatedMessageFlyweight correlationId ( final long correlationId ) { buffer ( ) . putLong ( offset ( ) + CORRELATION_ID_FIELD_OFFSET , correlationId , ByteOrder . LITTLE_ENDIAN ) ; return this ; } }
package uk . co . real_logic . aeron . driver ; import org . junit . Test ; import uk . co . real_logic . agrona . LangUtil ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . net . * ; import java . util . * ; import static java . lang . Short . parseShort ; import static java . net . InetAddress . getByName ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . CoreMatchers . sameInstance ; import static org . junit . Assert . * ; import static uk . co . real_logic . aeron . driver . NetworkUtil . filterBySubnet ; public class NetworkUtilTest { @ Test public void shouldNotMatchIfLengthsAreDifferent ( ) { assertFalse ( NetworkUtil . isMatchWithPrefix ( new byte [ 0 ] , new byte [ 3 ] , 0 ) ) ; assertFalse ( NetworkUtil . isMatchWithPrefix ( new byte [ 1 ] , new byte [ 2 ] , 0 ) ) ; assertFalse ( NetworkUtil . isMatchWithPrefix ( new byte [ 5 ] , new byte [ 5000 ] , 0 ) ) ; } @ Test public void shouldMatchIfAllBytesMatch ( ) throws Exception { final byte [ ] a = { 'a' , 'b' , 'c' , 'd' } ; final byte [ ] b = { 'a' , 'b' , 'c' , 'd' } ; assertTrue ( NetworkUtil . isMatchWithPrefix ( a , b , 32 ) ) ; } @ Test public void shouldMatchIfAllBytesWithPrefixMatch ( ) throws Exception { final byte [ ] a = { 'a' , 'b' , 'c' , 'd' } ; final byte [ ] b = { 'a' , 'b' , 'c' , 'e' } ; assertTrue ( NetworkUtil . isMatchWithPrefix ( a , b , 24 ) ) ; } @ Test public void shouldNotMatchIfNotAllBytesWithPrefixMatch ( ) throws Exception { final byte [ ] a = { 'a' , 'b' , 'c' , 'd' } ; final byte [ ] b = { 'a' , 'b' , 'd' , 'd' } ; assertFalse ( NetworkUtil . isMatchWithPrefix ( a , b , 24 ) ) ; } @ Test public void shouldMatchIfAllBytesWithPrefixUnalignedMatch ( ) throws Exception { assertTrue ( NetworkUtil . isMatchWithPrefix ( asBytes ( 0b10101010_11111111_00000000_00000000 ) , asBytes ( 0b10101010_11111110_00000000_00000000 ) , 15 ) ) ; } @ Test public void shouldNotMatchIfNotAllBytesWithUnalignedPrefixMatch ( ) throws Exception { assertFalse ( NetworkUtil . isMatchWithPrefix ( asBytes ( 0b10101010_11111111_00000000_00000000 ) , asBytes ( 0b10101010_11111111_10000000_00000000 ) , 17 ) ) ; } @ Test public void shouldFilterBySubnetAndFindOneResult ( ) throws Exception { final NetworkInterfaceStub stub = new NetworkInterfaceStub ( ) ; final NetworkInterface ifc1 = stub . add ( "192.168.0.1/24" ) ; stub . add ( "10.0.0.2/8" ) ; final Collection < NetworkInterface > filteredBySubnet = filterBySubnet ( stub , getByName ( "192.168.0.0" ) , 24 ) ; assertThat ( filteredBySubnet . size ( ) , is ( 1 ) ) ; assertThat ( first ( filteredBySubnet ) , is ( ifc1 ) ) ; } @ Test public void shouldFilterBySubnetAndFindNoResults ( ) throws Exception { final NetworkInterfaceStub stub = new NetworkInterfaceStub ( ) ; stub . add ( "192.168.0.1/24" ) ; stub . add ( "10.0.0.2/8" ) ; final Collection < NetworkInterface > filteredBySubnet = filterBySubnet ( stub , getByName ( "192.169.0.0" ) , 24 ) ; assertThat ( filteredBySubnet . size ( ) , is ( 0 ) ) ; } @ Test public void shouldFilterBySubnetAndFindMultipleResultsOrderedByMatchLength ( ) throws Exception { final NetworkInterfaceStub stub = new NetworkInterfaceStub ( ) ; stub . add ( "10.0.0.2/8" ) ; final NetworkInterface ifc1 = stub . add ( "192.0.0.0/8" ) ; final NetworkInterface ifc2 = stub . add ( "192.168.1.1/24" ) ; final NetworkInterface ifc3 = stub . add ( "192.168.0.0/16" ) ; final Collection < NetworkInterface > filteredBySubnet = filterBySubnet ( stub , getByName ( "192.0.0.0" ) , 8 ) ; assertThat ( filteredBySubnet . size ( ) , is ( 3 ) ) ; final Iterator < NetworkInterface > it = filteredBySubnet . iterator ( ) ; assertThat ( it . next ( ) , sameInstance ( ifc2 ) ) ; assertThat ( it . next ( ) , sameInstance ( ifc3 ) ) ; assertThat ( it . next ( ) , sameInstance ( ifc1 ) ) ; } @ Test public void shouldFilterBySubnetAndFindOneIpV6Result ( ) throws Exception { final NetworkInterfaceStub stub = new NetworkInterfaceStub ( ) ; final NetworkInterface ifc1 = stub . add ( "fe80:0:0:0001:0002:0:0:1/80" ) ; stub . add ( "fe80:0:0:0002:0003:0:0:1/80" ) ; final Collection < NetworkInterface > filteredBySubnet = filterBySubnet ( stub , getByName ( "fe80:0:0:0001:0002:0:0:0" ) , 80 ) ; assertThat ( filteredBySubnet . size ( ) , is ( 1 ) ) ; assertThat ( first ( filteredBySubnet ) , is ( ifc1 ) ) ; } @ Test public void shouldFilterBySubnetAndFindNoIpV6Results ( ) throws Exception { final NetworkInterfaceStub stub = new NetworkInterfaceStub ( ) ; stub . add ( "fe80:0:0:0001:0:0:0:1/64" ) ; stub . add ( "fe80:0:0:0002:0:0:0:1/64" ) ; final Collection < NetworkInterface > filteredBySubnet = filterBySubnet ( stub , getByName ( "fe80:0:0:0004:0:0:0:0" ) , 64 ) ; assertThat ( filteredBySubnet . size ( ) , is ( 0 ) ) ; } @ Test public void shouldFilterBySubnetAndFindMultipleIpV6ResultsOrderedByMatchLength ( ) throws Exception { final NetworkInterfaceStub stub = new NetworkInterfaceStub ( ) ; stub . add ( "ee80:0:0:0001:0:0:0:1/64" ) ; final NetworkInterface ifc1 = stub . add ( "fe80:0:0:0:0:0:0:1/16" ) ; final NetworkInterface ifc2 = stub . add ( "fe80:0001:0:0:0:0:0:1/32" ) ; final NetworkInterface ifc3 = stub . add ( "fe80:0001:abcd:0:0:0:0:1/48" ) ; final Collection < NetworkInterface > filteredBySubnet = filterBySubnet ( stub , getByName ( "fe80:0:0:0:0:0:0:0" ) , 16 ) ; assertThat ( filteredBySubnet . size ( ) , is ( 3 ) ) ; final Iterator < NetworkInterface > it = filteredBySubnet . iterator ( ) ; assertThat ( it . next ( ) , sameInstance ( ifc3 ) ) ; assertThat ( it . next ( ) , sameInstance ( ifc2 ) ) ; assertThat ( it . next ( ) , sameInstance ( ifc1 ) ) ; } private static < T > T first ( Collection < T > c ) { return c . iterator ( ) . next ( ) ; } private static class NetworkInterfaceStub implements NetworkInterfaceShim { private int counter = 0 ; private final IdentityHashMap < NetworkInterface , List < InterfaceAddress > > addressesByInterface = new IdentityHashMap < > ( ) ; @ Override public Enumeration < NetworkInterface > getNetworkInterfaces ( ) throws SocketException { return Collections . enumeration ( addressesByInterface . keySet ( ) ) ; } @ Override public List < InterfaceAddress > getInterfaceAddresses ( NetworkInterface ifc ) { return addressesByInterface . get ( ifc ) ; } @ Override public boolean isLoopback ( NetworkInterface ifc ) throws SocketException { return false ; } public NetworkInterface add ( String ... ips ) throws UnknownHostException { final List < InterfaceAddress > ias = new ArrayList < > ( ) ; for ( final String ip : ips ) { final String [ ] parts = ip . split ( "/" ) ; ias . add ( newInterfaceAddress ( getByName ( parts [ 0 ] ) , parseShort ( parts [ 1 ] ) ) ) ; } final NetworkInterface ifc = newNetworkInterface ( String . valueOf ( counter ++ ) ) ; addressesByInterface . put ( ifc , ias ) ; return ifc ; } } private static NetworkInterface newNetworkInterface ( String name ) { NetworkInterface networkInterface = null ; try { final Constructor < NetworkInterface > ctor = NetworkInterface . class . getDeclaredConstructor ( ) ; ctor . setAccessible ( true ) ; final Field nameField = NetworkInterface . class . getDeclaredField ( "name" ) ; nameField . setAccessible ( true ) ; networkInterface = ctor . newInstance ( ) ; nameField . set ( networkInterface , name ) ; } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } return networkInterface ; } private static InterfaceAddress newInterfaceAddress ( InetAddress inetAddress , short maskLength ) { InterfaceAddress interfaceAddress = null ; try { final Constructor < InterfaceAddress > ctor = InterfaceAddress . class . getDeclaredConstructor ( ) ; ctor . setAccessible ( true ) ; final Field addressField = InterfaceAddress . class . getDeclaredField ( "address" ) ; addressField . setAccessible ( true ) ; final Field maskLengthField = InterfaceAddress . class . getDeclaredField ( "maskLength" ) ; maskLengthField . setAccessible ( true ) ; interfaceAddress = ctor . newInstance ( ) ; addressField . set ( interfaceAddress , inetAddress ) ; maskLengthField . set ( interfaceAddress , maskLength ) ; } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } return interfaceAddress ; } private static byte [ ] asBytes ( int i ) { final byte [ ] bs = new byte [ 4 ] ; bs [ 0 ] = ( byte ) ( ( i > > 24 ) & 0xFF ) ; bs [ 1 ] = ( byte ) ( ( i > > 16 ) & 0xFF ) ; bs [ 2 ] = ( byte ) ( ( i > > 8 ) & 0xFF ) ; bs [ 3 ] = ( byte ) ( i & 0xFF ) ; return bs ; } }
package uk . co . real_logic . aeron . driver ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . mockito . stubbing . Answer ; import uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor ; import uk . co . real_logic . aeron . logbuffer . TermAppender ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . protocol . HeaderFlyweight ; import uk . co . real_logic . aeron . protocol . SetupFlyweight ; import uk . co . real_logic . aeron . driver . buffer . RawLog ; import uk . co . real_logic . aeron . driver . cmd . NewPublicationCmd ; import uk . co . real_logic . aeron . driver . cmd . SenderCmd ; import uk . co . real_logic . aeron . driver . media . SendChannelEndpoint ; import uk . co . real_logic . aeron . driver . media . TransportPoller ; import uk . co . real_logic . aeron . driver . media . UdpChannel ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . concurrent . AtomicCounter ; import uk . co . real_logic . agrona . concurrent . OneToOneConcurrentArrayQueue ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . status . AtomicLongPosition ; import uk . co . real_logic . agrona . concurrent . status . Position ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . util . ArrayDeque ; import java . util . Queue ; import java . util . concurrent . TimeUnit ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . core . Is . is ; import static org . mockito . Mockito . * ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . FRAME_ALIGNMENT ; import static uk . co . real_logic . agrona . BitUtil . align ; public class SenderTest { private static final int TERM_BUFFER_LENGTH = LogBufferDescriptor . TERM_MIN_LENGTH ; private static final int MAX_FRAME_LENGTH = 1024 ; private static final int SESSION_ID = 1 ; private static final int STREAM_ID = 2 ; private static final int INITIAL_TERM_ID = 3 ; private static final byte [ ] PAYLOAD = "Payload is here!" . getBytes ( ) ; private static final MutableDirectBuffer HEADER = DataHeaderFlyweight . createDefaultHeader ( SESSION_ID , STREAM_ID , INITIAL_TERM_ID ) ; private static final int ALIGNED_FRAME_LENGTH = align ( HEADER . capacity ( ) + PAYLOAD . length , FRAME_ALIGNMENT ) ; private final EventLogger mockLogger = mock ( EventLogger . class ) ; private final TransportPoller mockTransportPoller = mock ( TransportPoller . class ) ; private final RawLog rawLog = LogBufferHelper . newTestLogBuffers ( TERM_BUFFER_LENGTH , LogBufferDescriptor . TERM_META_DATA_LENGTH ) ; private TermAppender [ ] termAppenders ; private NetworkPublication publication ; private Sender sender ; private final FlowControl flowControl = spy ( new UnicastFlowControl ( ) ) ; private final RetransmitHandler mockRetransmitHandler = mock ( RetransmitHandler . class ) ; private long currentTimestamp = 0 ; private final TimerWheel wheel = new TimerWheel ( ( ) - > currentTimestamp , Configuration . CONDUCTOR_TICK_DURATION_US , TimeUnit . MICROSECONDS , Configuration . CONDUCTOR_TICKS_PER_WHEEL ) ; private final Queue < ByteBuffer > receivedFrames = new ArrayDeque < > ( ) ; private final UdpChannel udpChannel = UdpChannel . parse ( "udp://localhost:40123" ) ; private final InetSocketAddress rcvAddress = udpChannel . remoteData ( ) ; private final DataHeaderFlyweight dataHeader = new DataHeaderFlyweight ( ) ; private final SetupFlyweight setupHeader = new SetupFlyweight ( ) ; private final SystemCounters mockSystemCounters = mock ( SystemCounters . class ) ; private final OneToOneConcurrentArrayQueue < SenderCmd > senderCommandQueue = new OneToOneConcurrentArrayQueue < > ( 1024 ) ; private Answer < Integer > saveByteBufferAnswer = ( invocation ) - > { final Object args [ ] = invocation . getArguments ( ) ; final ByteBuffer buffer = ( ByteBuffer ) args [ 0 ] ; final int length = buffer . limit ( ) - buffer . position ( ) ; receivedFrames . add ( ByteBuffer . allocateDirect ( length ) . put ( buffer ) ) ; return length ; } ; @ Before public void setUp ( ) throws Exception { final SendChannelEndpoint mockSendChannelEndpoint = mock ( SendChannelEndpoint . class ) ; when ( mockSendChannelEndpoint . udpChannel ( ) ) . thenReturn ( udpChannel ) ; when ( mockSendChannelEndpoint . sendTo ( anyObject ( ) , anyObject ( ) ) ) . thenAnswer ( saveByteBufferAnswer ) ; when ( mockSystemCounters . heartbeatsSent ( ) ) . thenReturn ( mock ( AtomicCounter . class ) ) ; when ( mockSystemCounters . bytesSent ( ) ) . thenReturn ( mock ( AtomicCounter . class ) ) ; when ( mockSystemCounters . senderFlowControlLimits ( ) ) . thenReturn ( mock ( AtomicCounter . class ) ) ; sender = new Sender ( new MediaDriver . Context ( ) . senderNioSelector ( mockTransportPoller ) . systemCounters ( mockSystemCounters ) . senderCommandQueue ( senderCommandQueue ) . eventLogger ( mockLogger ) ) ; termAppenders = rawLog . stream ( ) . map ( ( log ) - > new TermAppender ( log . termBuffer ( ) , log . metaDataBuffer ( ) , HEADER , MAX_FRAME_LENGTH ) ) . toArray ( TermAppender [ ] : : new ) ; publication = new NetworkPublication ( mockSendChannelEndpoint , wheel . clock ( ) , rawLog , new AtomicLongPosition ( ) , mock ( Position . class ) , SESSION_ID , STREAM_ID , INITIAL_TERM_ID , MAX_FRAME_LENGTH , flowControl . initialPositionLimit ( INITIAL_TERM_ID , TERM_BUFFER_LENGTH ) , mockSystemCounters ) ; senderCommandQueue . offer ( new NewPublicationCmd ( publication , mockRetransmitHandler , flowControl ) ) ; } @ After public void tearDown ( ) throws Exception { sender . onClose ( ) ; } @ Test public void shouldSendSetupFrameOnChannelWhenTimeoutWithoutStatusMessage ( ) throws Exception { currentTimestamp += Configuration . PUBLICATION_SETUP_TIMEOUT_NS - 1 ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 0 ) ) ; currentTimestamp += 10 ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 1 ) ) ; setupHeader . wrap ( receivedFrames . remove ( ) , 0 ) ; assertThat ( setupHeader . frameLength ( ) , is ( SetupFlyweight . HEADER_LENGTH ) ) ; assertThat ( setupHeader . initialTermId ( ) , is ( INITIAL_TERM_ID ) ) ; assertThat ( setupHeader . activeTermId ( ) , is ( INITIAL_TERM_ID ) ) ; assertThat ( setupHeader . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( setupHeader . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( setupHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_SETUP ) ) ; assertThat ( setupHeader . flags ( ) , is ( ( short ) 0 ) ) ; assertThat ( setupHeader . version ( ) , is ( ( short ) HeaderFlyweight . CURRENT_VERSION ) ) ; } @ Test public void shouldSendMultipleSetupFramesOnChannelWhenTimeoutWithoutStatusMessage ( ) throws Exception { currentTimestamp += Configuration . PUBLICATION_SETUP_TIMEOUT_NS - 1 ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 0 ) ) ; currentTimestamp += 10 ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 1 ) ) ; currentTimestamp += Configuration . PUBLICATION_SETUP_TIMEOUT_NS - 1 ; sender . doWork ( ) ; currentTimestamp += 10 ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 2 ) ) ; } @ Test public void shouldNotSendSetupFrameAfterReceivingStatusMessage ( ) throws Exception { currentTimestamp += Configuration . PUBLICATION_SETUP_TIMEOUT_NS - 1 ; publication . senderPositionLimit ( flowControl . onStatusMessage ( INITIAL_TERM_ID , 0 , 0 , rcvAddress ) ) ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 0 ) ) ; } @ Test public void shouldBeAbleToSendOnChannel ( ) throws Exception { publication . senderPositionLimit ( flowControl . onStatusMessage ( INITIAL_TERM_ID , 0 , ALIGNED_FRAME_LENGTH , rcvAddress ) ) ; final UnsafeBuffer buffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( PAYLOAD . length ) ) ; buffer . putBytes ( 0 , PAYLOAD ) ; termAppenders [ 0 ] . append ( buffer , 0 , PAYLOAD . length ) ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 1 ) ) ; dataHeader . wrap ( receivedFrames . remove ( ) , 0 ) ; assertThat ( dataHeader . frameLength ( ) , is ( ALIGNED_FRAME_LENGTH ) ) ; assertThat ( dataHeader . termId ( ) , is ( INITIAL_TERM_ID ) ) ; assertThat ( dataHeader . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( dataHeader . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( dataHeader . termOffset ( ) , is ( offsetOfMessage ( 1 ) ) ) ; assertThat ( dataHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( dataHeader . flags ( ) , is ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ) ; assertThat ( dataHeader . version ( ) , is ( ( short ) HeaderFlyweight . CURRENT_VERSION ) ) ; } @ Test public void shouldBeAbleToSendOnChannelTwice ( ) throws Exception { publication . senderPositionLimit ( flowControl . onStatusMessage ( INITIAL_TERM_ID , 0 , ( 2 * ALIGNED_FRAME_LENGTH ) , rcvAddress ) ) ; final UnsafeBuffer buffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( PAYLOAD . length ) ) ; buffer . putBytes ( 0 , PAYLOAD ) ; termAppenders [ 0 ] . append ( buffer , 0 , PAYLOAD . length ) ; sender . doWork ( ) ; termAppenders [ 0 ] . append ( buffer , 0 , PAYLOAD . length ) ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 2 ) ) ; dataHeader . wrap ( receivedFrames . remove ( ) , 0 ) ; assertThat ( dataHeader . frameLength ( ) , is ( ALIGNED_FRAME_LENGTH ) ) ; assertThat ( dataHeader . termId ( ) , is ( INITIAL_TERM_ID ) ) ; assertThat ( dataHeader . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( dataHeader . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( dataHeader . termOffset ( ) , is ( offsetOfMessage ( 1 ) ) ) ; assertThat ( dataHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( dataHeader . flags ( ) , is ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ) ; assertThat ( dataHeader . version ( ) , is ( ( short ) HeaderFlyweight . CURRENT_VERSION ) ) ; dataHeader . wrap ( receivedFrames . remove ( ) , 0 ) ; assertThat ( dataHeader . frameLength ( ) , is ( ALIGNED_FRAME_LENGTH ) ) ; assertThat ( dataHeader . termId ( ) , is ( INITIAL_TERM_ID ) ) ; assertThat ( dataHeader . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( dataHeader . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( dataHeader . termOffset ( ) , is ( offsetOfMessage ( 2 ) ) ) ; assertThat ( dataHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( dataHeader . flags ( ) , is ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ) ; assertThat ( dataHeader . version ( ) , is ( ( short ) HeaderFlyweight . CURRENT_VERSION ) ) ; } @ Test public void shouldBeAbleToSendOnChannelTwiceAsBatch ( ) throws Exception { publication . senderPositionLimit ( flowControl . onStatusMessage ( INITIAL_TERM_ID , 0 , ( 2 * ALIGNED_FRAME_LENGTH ) , rcvAddress ) ) ; final UnsafeBuffer buffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( PAYLOAD . length ) ) ; buffer . putBytes ( 0 , PAYLOAD ) ; termAppenders [ 0 ] . append ( buffer , 0 , PAYLOAD . length ) ; termAppenders [ 0 ] . append ( buffer , 0 , PAYLOAD . length ) ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 1 ) ) ; final ByteBuffer frame = receivedFrames . remove ( ) ; dataHeader . wrap ( frame , 0 ) ; assertThat ( dataHeader . frameLength ( ) , is ( ALIGNED_FRAME_LENGTH ) ) ; assertThat ( dataHeader . termId ( ) , is ( INITIAL_TERM_ID ) ) ; assertThat ( dataHeader . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( dataHeader . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( dataHeader . termOffset ( ) , is ( offsetOfMessage ( 1 ) ) ) ; assertThat ( dataHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( dataHeader . flags ( ) , is ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ) ; assertThat ( dataHeader . version ( ) , is ( ( short ) HeaderFlyweight . CURRENT_VERSION ) ) ; dataHeader . wrap ( frame , offsetOfMessage ( 2 ) ) ; assertThat ( dataHeader . frameLength ( ) , is ( ALIGNED_FRAME_LENGTH ) ) ; assertThat ( dataHeader . termId ( ) , is ( INITIAL_TERM_ID ) ) ; assertThat ( dataHeader . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( dataHeader . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( dataHeader . termOffset ( ) , is ( offsetOfMessage ( 2 ) ) ) ; assertThat ( dataHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( dataHeader . flags ( ) , is ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ) ; assertThat ( dataHeader . version ( ) , is ( ( short ) HeaderFlyweight . CURRENT_VERSION ) ) ; } @ Test public void shouldNotSendUntilStatusMessageReceived ( ) throws Exception { final UnsafeBuffer buffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( PAYLOAD . length ) ) ; buffer . putBytes ( 0 , PAYLOAD ) ; termAppenders [ 0 ] . append ( buffer , 0 , PAYLOAD . length ) ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 0 ) ) ; publication . senderPositionLimit ( flowControl . onStatusMessage ( INITIAL_TERM_ID , 0 , ALIGNED_FRAME_LENGTH , rcvAddress ) ) ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 1 ) ) ; dataHeader . wrap ( receivedFrames . remove ( ) , 0 ) ; assertThat ( dataHeader . frameLength ( ) , is ( ALIGNED_FRAME_LENGTH ) ) ; assertThat ( dataHeader . termId ( ) , is ( INITIAL_TERM_ID ) ) ; assertThat ( dataHeader . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( dataHeader . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( dataHeader . termOffset ( ) , is ( offsetOfMessage ( 1 ) ) ) ; assertThat ( dataHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( dataHeader . flags ( ) , is ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ) ; assertThat ( dataHeader . version ( ) , is ( ( short ) HeaderFlyweight . CURRENT_VERSION ) ) ; } @ Test public void shouldNotBeAbleToSendAfterUsingUpYourWindow ( ) throws Exception { final UnsafeBuffer buffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( PAYLOAD . length ) ) ; buffer . putBytes ( 0 , PAYLOAD ) ; termAppenders [ 0 ] . append ( buffer , 0 , PAYLOAD . length ) ; publication . senderPositionLimit ( flowControl . onStatusMessage ( INITIAL_TERM_ID , 0 , ALIGNED_FRAME_LENGTH , rcvAddress ) ) ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 1 ) ) ; dataHeader . wrap ( receivedFrames . remove ( ) , 0 ) ; assertThat ( dataHeader . frameLength ( ) , is ( ALIGNED_FRAME_LENGTH ) ) ; assertThat ( dataHeader . termId ( ) , is ( INITIAL_TERM_ID ) ) ; assertThat ( dataHeader . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( dataHeader . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( dataHeader . termOffset ( ) , is ( offsetOfMessage ( 1 ) ) ) ; assertThat ( dataHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( dataHeader . flags ( ) , is ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ) ; assertThat ( dataHeader . version ( ) , is ( ( short ) HeaderFlyweight . CURRENT_VERSION ) ) ; termAppenders [ 0 ] . append ( buffer , 0 , PAYLOAD . length ) ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 0 ) ) ; } @ Test public void shouldSendLastDataFrameAsHeartbeatWhenIdle ( ) throws Exception { publication . senderPositionLimit ( flowControl . onStatusMessage ( INITIAL_TERM_ID , 0 , ALIGNED_FRAME_LENGTH , rcvAddress ) ) ; final UnsafeBuffer buffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( PAYLOAD . length ) ) ; buffer . putBytes ( 0 , PAYLOAD ) ; termAppenders [ 0 ] . append ( buffer , 0 , PAYLOAD . length ) ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 1 ) ) ; receivedFrames . remove ( ) ; currentTimestamp += Configuration . PUBLICATION_HEARTBEAT_TIMEOUT_NS - 1 ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 0 ) ) ; currentTimestamp += 10 ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , greaterThanOrEqualTo ( 1 ) ) ; dataHeader . wrap ( new UnsafeBuffer ( receivedFrames . remove ( ) ) , 0 ) ; assertThat ( dataHeader . frameLength ( ) , is ( 0 ) ) ; assertThat ( dataHeader . termOffset ( ) , is ( offsetOfMessage ( 2 ) ) ) ; } @ Test public void shouldSendMultipleDataFramesAsHeartbeatsWhenIdle ( ) { publication . senderPositionLimit ( flowControl . onStatusMessage ( INITIAL_TERM_ID , 0 , ALIGNED_FRAME_LENGTH , rcvAddress ) ) ; final UnsafeBuffer buffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( PAYLOAD . length ) ) ; buffer . putBytes ( 0 , PAYLOAD ) ; termAppenders [ 0 ] . append ( buffer , 0 , PAYLOAD . length ) ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 1 ) ) ; receivedFrames . remove ( ) ; currentTimestamp += Configuration . PUBLICATION_HEARTBEAT_TIMEOUT_NS - 1 ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 0 ) ) ; currentTimestamp += 10 ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , greaterThanOrEqualTo ( 1 ) ) ; dataHeader . wrap ( new UnsafeBuffer ( receivedFrames . remove ( ) ) , 0 ) ; assertThat ( dataHeader . frameLength ( ) , is ( 0 ) ) ; assertThat ( dataHeader . termOffset ( ) , is ( offsetOfMessage ( 2 ) ) ) ; currentTimestamp += Configuration . PUBLICATION_HEARTBEAT_TIMEOUT_NS - 1 ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , is ( 0 ) ) ; currentTimestamp += 10 ; sender . doWork ( ) ; assertThat ( receivedFrames . size ( ) , greaterThanOrEqualTo ( 1 ) ) ; dataHeader . wrap ( new UnsafeBuffer ( receivedFrames . remove ( ) ) , 0 ) ; assertThat ( dataHeader . frameLength ( ) , is ( 0 ) ) ; assertThat ( dataHeader . termOffset ( ) , is ( offsetOfMessage ( 2 ) ) ) ; } private int offsetOfMessage ( final int offset ) { return ( offset - 1 ) * align ( HEADER . capacity ( ) + PAYLOAD . length , FRAME_ALIGNMENT ) ; } }
package uk . co . real_logic . aeron . driver ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import uk . co . real_logic . aeron . driver . buffer . RawLogPartition ; import uk . co . real_logic . aeron . logbuffer . FrameDescriptor ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . logbuffer . TermReader ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . protocol . HeaderFlyweight ; import uk . co . real_logic . aeron . protocol . SetupFlyweight ; import uk . co . real_logic . aeron . protocol . StatusMessageFlyweight ; import uk . co . real_logic . aeron . driver . buffer . RawLog ; import uk . co . real_logic . aeron . driver . buffer . RawLogFactory ; import uk . co . real_logic . aeron . driver . cmd . CreateConnectionCmd ; import uk . co . real_logic . aeron . driver . cmd . DriverConductorCmd ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; import uk . co . real_logic . aeron . driver . media . TransportPoller ; import uk . co . real_logic . aeron . driver . media . UdpChannel ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . concurrent . AtomicCounter ; import uk . co . real_logic . agrona . concurrent . NanoClock ; import uk . co . real_logic . agrona . concurrent . OneToOneConcurrentArrayQueue ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . status . AtomicLongPosition ; import uk . co . real_logic . agrona . concurrent . status . Position ; import uk . co . real_logic . agrona . concurrent . status . ReadablePosition ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . DatagramChannel ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . TimeUnit ; import java . util . function . Consumer ; import static junit . framework . TestCase . assertTrue ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . hamcrest . core . Is . is ; import static org . junit . Assert . assertNotNull ; import static org . mockito . Mockito . * ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . * ; import static uk . co . real_logic . aeron . driver . LogBufferHelper . newTestLogBuffers ; import static uk . co . real_logic . agrona . BitUtil . align ; public class ReceiverTest { private static final int TERM_BUFFER_LENGTH = TERM_MIN_LENGTH ; private static final String URI = "udp://localhost:45678" ; private static final UdpChannel UDP_CHANNEL = UdpChannel . parse ( URI ) ; private static final long CORRELATION_ID = 20 ; private static final int STREAM_ID = 10 ; private static final int INITIAL_TERM_ID = 3 ; private static final int ACTIVE_TERM_ID = 3 ; private static final int SESSION_ID = 1 ; private static final int INITIAL_TERM_OFFSET = 0 ; private static final int ACTIVE_INDEX = indexByTerm ( ACTIVE_TERM_ID , ACTIVE_TERM_ID ) ; private static final byte [ ] FAKE_PAYLOAD = "Hello there, message!" . getBytes ( ) ; private static final int INITIAL_WINDOW_LENGTH = Configuration . INITIAL_WINDOW_LENGTH_DEFAULT ; private static final long STATUS_MESSAGE_TIMEOUT = Configuration . STATUS_MESSAGE_TIMEOUT_DEFAULT_NS ; private static final InetSocketAddress SOURCE_ADDRESS = new InetSocketAddress ( "localhost" , 45679 ) ; private static final ReadablePosition POSITION = mock ( ReadablePosition . class ) ; private static final List < ReadablePosition > POSITIONS = Collections . singletonList ( POSITION ) ; private final FeedbackDelayGenerator mockFeedbackDelayGenerator = mock ( FeedbackDelayGenerator . class ) ; private final TransportPoller mockTransportPoller = mock ( TransportPoller . class ) ; private final SystemCounters mockSystemCounters = mock ( SystemCounters . class ) ; private final RawLogFactory mockRawLogFactory = mock ( RawLogFactory . class ) ; private final Position mockHighestReceivedPosition = spy ( new AtomicLongPosition ( ) ) ; private final ByteBuffer dataFrameBuffer = ByteBuffer . allocateDirect ( 2 * 1024 ) ; private final UnsafeBuffer dataBuffer = new UnsafeBuffer ( dataFrameBuffer ) ; private final ByteBuffer setupFrameBuffer = ByteBuffer . allocateDirect ( SetupFlyweight . HEADER_LENGTH ) ; private final UnsafeBuffer setupBuffer = new UnsafeBuffer ( setupFrameBuffer ) ; private final Consumer < Throwable > mockErrorHandler = mock ( Consumer . class ) ; private final DataHeaderFlyweight dataHeader = new DataHeaderFlyweight ( ) ; private final StatusMessageFlyweight statusHeader = new StatusMessageFlyweight ( ) ; private final SetupFlyweight setupHeader = new SetupFlyweight ( ) ; private long currentTime = 0 ; private final NanoClock clock = ( ) - > currentTime ; private final RawLog rawLog = newTestLogBuffers ( TERM_BUFFER_LENGTH , TERM_META_DATA_LENGTH ) ; private final EventLogger mockLogger = mock ( EventLogger . class ) ; private final TimerWheel timerWheel = new TimerWheel ( clock , Configuration . CONDUCTOR_TICK_DURATION_US , TimeUnit . MICROSECONDS , Configuration . CONDUCTOR_TICKS_PER_WHEEL ) ; private final Header header = new Header ( INITIAL_TERM_ID , TERM_BUFFER_LENGTH ) ; private UnsafeBuffer [ ] termBuffers ; private DatagramChannel senderChannel ; private InetSocketAddress senderAddress = new InetSocketAddress ( "localhost" , 40123 ) ; private Receiver receiver ; private ReceiverProxy receiverProxy ; private OneToOneConcurrentArrayQueue < DriverConductorCmd > toConductorQueue ; private ReceiveChannelEndpoint receiveChannelEndpoint ; @ Before public void setUp ( ) throws Exception { when ( POSITION . getVolatile ( ) ) . thenReturn ( computePosition ( ACTIVE_TERM_ID , 0 , Integer . numberOfTrailingZeros ( TERM_BUFFER_LENGTH ) , ACTIVE_TERM_ID ) ) ; when ( mockSystemCounters . statusMessagesSent ( ) ) . thenReturn ( mock ( AtomicCounter . class ) ) ; when ( mockSystemCounters . flowControlUnderRuns ( ) ) . thenReturn ( mock ( AtomicCounter . class ) ) ; when ( mockSystemCounters . bytesReceived ( ) ) . thenReturn ( mock ( AtomicCounter . class ) ) ; final MediaDriver . Context ctx = new MediaDriver . Context ( ) . toConductorFromReceiverCommandQueue ( new OneToOneConcurrentArrayQueue < > ( 1024 ) ) . receiverNioSelector ( mockTransportPoller ) . senderNioSelector ( mockTransportPoller ) . rawLogBuffersFactory ( mockRawLogFactory ) . conductorTimerWheel ( timerWheel ) . systemCounters ( mockSystemCounters ) . receiverCommandQueue ( new OneToOneConcurrentArrayQueue < > ( 1024 ) ) . eventLogger ( mockLogger ) ; toConductorQueue = ctx . toConductorFromReceiverCommandQueue ( ) ; final DriverConductorProxy driverConductorProxy = new DriverConductorProxy ( ThreadingMode . DEDICATED , toConductorQueue , mock ( AtomicCounter . class ) ) ; ctx . fromReceiverDriverConductorProxy ( driverConductorProxy ) ; receiverProxy = new ReceiverProxy ( ThreadingMode . DEDICATED , ctx . receiverCommandQueue ( ) , mock ( AtomicCounter . class ) ) ; receiver = new Receiver ( ctx ) ; senderChannel = DatagramChannel . open ( ) ; senderChannel . bind ( senderAddress ) ; senderChannel . configureBlocking ( false ) ; termBuffers = rawLog . stream ( ) . map ( RawLogPartition : : termBuffer ) . toArray ( UnsafeBuffer [ ] : : new ) ; receiveChannelEndpoint = new ReceiveChannelEndpoint ( UdpChannel . parse ( URI ) , driverConductorProxy , receiver , mockLogger , mockSystemCounters , ( address , buffer , length ) - > false ) ; } @ After public void tearDown ( ) throws Exception { receiveChannelEndpoint . close ( ) ; senderChannel . close ( ) ; receiver . onClose ( ) ; } @ Test public void shouldCreateRcvTermAndSendSmOnSetup ( ) throws Exception { receiverProxy . registerReceiveChannelEndpoint ( receiveChannelEndpoint ) ; receiverProxy . addSubscription ( receiveChannelEndpoint , STREAM_ID ) ; receiver . doWork ( ) ; fillSetupFrame ( setupHeader ) ; receiveChannelEndpoint . onSetupMessage ( setupHeader , setupBuffer , setupHeader . frameLength ( ) , senderAddress ) ; final NetworkConnection connection = new NetworkConnection ( CORRELATION_ID , receiveChannelEndpoint , senderAddress , SESSION_ID , STREAM_ID , INITIAL_TERM_ID , ACTIVE_TERM_ID , INITIAL_TERM_OFFSET , INITIAL_WINDOW_LENGTH , rawLog , timerWheel , mockFeedbackDelayGenerator , POSITIONS , mockHighestReceivedPosition , clock , mockSystemCounters , SOURCE_ADDRESS ) ; final int messagesRead = toConductorQueue . drain ( ( e ) - > { final CreateConnectionCmd cmd = ( CreateConnectionCmd ) e ; assertThat ( cmd . channelEndpoint ( ) . udpChannel ( ) , is ( UDP_CHANNEL ) ) ; assertThat ( cmd . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( cmd . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( cmd . termId ( ) , is ( ACTIVE_TERM_ID ) ) ; receiverProxy . newConnection ( receiveChannelEndpoint , connection ) ; } ) ; assertThat ( messagesRead , is ( 1 ) ) ; receiver . doWork ( ) ; connection . trackRebuild ( ) ; connection . sendPendingStatusMessage ( 1000 , STATUS_MESSAGE_TIMEOUT ) ; final ByteBuffer rcvBuffer = ByteBuffer . allocateDirect ( 256 ) ; final InetSocketAddress rcvAddress = ( InetSocketAddress ) senderChannel . receive ( rcvBuffer ) ; statusHeader . wrap ( rcvBuffer ) ; assertNotNull ( rcvAddress ) ; assertThat ( rcvAddress . getPort ( ) , is ( UDP_CHANNEL . remoteData ( ) . getPort ( ) ) ) ; assertThat ( statusHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_SM ) ) ; assertThat ( statusHeader . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( statusHeader . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( statusHeader . consumptionTermId ( ) , is ( ACTIVE_TERM_ID ) ) ; assertThat ( statusHeader . frameLength ( ) , is ( StatusMessageFlyweight . HEADER_LENGTH ) ) ; } @ Test public void shouldInsertDataIntoLogAfterInitialExchange ( ) throws Exception { receiverProxy . registerReceiveChannelEndpoint ( receiveChannelEndpoint ) ; receiverProxy . addSubscription ( receiveChannelEndpoint , STREAM_ID ) ; receiver . doWork ( ) ; fillSetupFrame ( setupHeader ) ; receiveChannelEndpoint . onSetupMessage ( setupHeader , setupBuffer , setupHeader . frameLength ( ) , senderAddress ) ; final int commandsRead = toConductorQueue . drain ( ( e ) - > { assertTrue ( e instanceof CreateConnectionCmd ) ; receiverProxy . newConnection ( receiveChannelEndpoint , new NetworkConnection ( CORRELATION_ID , receiveChannelEndpoint , senderAddress , SESSION_ID , STREAM_ID , INITIAL_TERM_ID , ACTIVE_TERM_ID , INITIAL_TERM_OFFSET , INITIAL_WINDOW_LENGTH , rawLog , timerWheel , mockFeedbackDelayGenerator , POSITIONS , mockHighestReceivedPosition , clock , mockSystemCounters , SOURCE_ADDRESS ) ) ; } ) ; assertThat ( commandsRead , is ( 1 ) ) ; receiver . doWork ( ) ; fillDataFrame ( dataHeader , 0 , FAKE_PAYLOAD ) ; receiveChannelEndpoint . onDataPacket ( dataHeader , dataBuffer , dataHeader . frameLength ( ) , senderAddress ) ; final long readOutcome = TermReader . read ( termBuffers [ ACTIVE_INDEX ] , INITIAL_TERM_OFFSET , ( buffer , offset , length , header ) - > { assertThat ( header . type ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( header . termId ( ) , is ( ACTIVE_TERM_ID ) ) ; assertThat ( header . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( header . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( header . termOffset ( ) , is ( 0 ) ) ; assertThat ( header . frameLength ( ) , is ( DataHeaderFlyweight . HEADER_LENGTH + FAKE_PAYLOAD . length ) ) ; } , Integer . MAX_VALUE , header , mockErrorHandler ) ; assertThat ( TermReader . fragmentsRead ( readOutcome ) , is ( 1 ) ) ; } @ Test public void shouldNotOverwriteDataFrameWithHeartbeat ( ) throws Exception { receiverProxy . registerReceiveChannelEndpoint ( receiveChannelEndpoint ) ; receiverProxy . addSubscription ( receiveChannelEndpoint , STREAM_ID ) ; receiver . doWork ( ) ; fillSetupFrame ( setupHeader ) ; receiveChannelEndpoint . onSetupMessage ( setupHeader , setupBuffer , setupHeader . frameLength ( ) , senderAddress ) ; final int commandsRead = toConductorQueue . drain ( ( e ) - > { assertTrue ( e instanceof CreateConnectionCmd ) ; receiverProxy . newConnection ( receiveChannelEndpoint , new NetworkConnection ( CORRELATION_ID , receiveChannelEndpoint , senderAddress , SESSION_ID , STREAM_ID , INITIAL_TERM_ID , ACTIVE_TERM_ID , INITIAL_TERM_OFFSET , INITIAL_WINDOW_LENGTH , rawLog , timerWheel , mockFeedbackDelayGenerator , POSITIONS , mockHighestReceivedPosition , clock , mockSystemCounters , SOURCE_ADDRESS ) ) ; } ) ; assertThat ( commandsRead , is ( 1 ) ) ; receiver . doWork ( ) ; fillDataFrame ( dataHeader , 0 , FAKE_PAYLOAD ) ; receiveChannelEndpoint . onDataPacket ( dataHeader , dataBuffer , dataHeader . frameLength ( ) , senderAddress ) ; fillDataFrame ( dataHeader , 0 , FAKE_PAYLOAD ) ; receiveChannelEndpoint . onDataPacket ( dataHeader , dataBuffer , dataHeader . frameLength ( ) , senderAddress ) ; final long readOutcome = TermReader . read ( termBuffers [ ACTIVE_INDEX ] , INITIAL_TERM_OFFSET , ( buffer , offset , length , header ) - > { assertThat ( header . type ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( header . termId ( ) , is ( ACTIVE_TERM_ID ) ) ; assertThat ( header . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( header . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( header . termOffset ( ) , is ( 0 ) ) ; assertThat ( header . frameLength ( ) , is ( DataHeaderFlyweight . HEADER_LENGTH + FAKE_PAYLOAD . length ) ) ; } , Integer . MAX_VALUE , header , mockErrorHandler ) ; assertThat ( TermReader . fragmentsRead ( readOutcome ) , is ( 1 ) ) ; } @ Test public void shouldOverwriteHeartbeatWithDataFrame ( ) throws Exception { receiverProxy . registerReceiveChannelEndpoint ( receiveChannelEndpoint ) ; receiverProxy . addSubscription ( receiveChannelEndpoint , STREAM_ID ) ; receiver . doWork ( ) ; fillSetupFrame ( setupHeader ) ; receiveChannelEndpoint . onSetupMessage ( setupHeader , setupBuffer , setupHeader . frameLength ( ) , senderAddress ) ; final int commandsRead = toConductorQueue . drain ( ( e ) - > { assertTrue ( e instanceof CreateConnectionCmd ) ; receiverProxy . newConnection ( receiveChannelEndpoint , new NetworkConnection ( CORRELATION_ID , receiveChannelEndpoint , senderAddress , SESSION_ID , STREAM_ID , INITIAL_TERM_ID , ACTIVE_TERM_ID , INITIAL_TERM_OFFSET , INITIAL_WINDOW_LENGTH , rawLog , timerWheel , mockFeedbackDelayGenerator , POSITIONS , mockHighestReceivedPosition , clock , mockSystemCounters , SOURCE_ADDRESS ) ) ; } ) ; assertThat ( commandsRead , is ( 1 ) ) ; receiver . doWork ( ) ; fillDataFrame ( dataHeader , 0 , FAKE_PAYLOAD ) ; receiveChannelEndpoint . onDataPacket ( dataHeader , dataBuffer , dataHeader . frameLength ( ) , senderAddress ) ; fillDataFrame ( dataHeader , 0 , FAKE_PAYLOAD ) ; receiveChannelEndpoint . onDataPacket ( dataHeader , dataBuffer , dataHeader . frameLength ( ) , senderAddress ) ; final long readOutcome = TermReader . read ( termBuffers [ ACTIVE_INDEX ] , INITIAL_TERM_OFFSET , ( buffer , offset , length , header ) - > { assertThat ( header . type ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( header . termId ( ) , is ( ACTIVE_TERM_ID ) ) ; assertThat ( header . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( header . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( header . termOffset ( ) , is ( 0 ) ) ; assertThat ( header . frameLength ( ) , is ( DataHeaderFlyweight . HEADER_LENGTH + FAKE_PAYLOAD . length ) ) ; } , Integer . MAX_VALUE , header , mockErrorHandler ) ; assertThat ( TermReader . fragmentsRead ( readOutcome ) , is ( 1 ) ) ; } @ Test public void shouldHandleNonZeroTermOffsetCorrectly ( ) throws Exception { final int initialTermOffset = align ( TERM_BUFFER_LENGTH / 16 , FrameDescriptor . FRAME_ALIGNMENT ) ; final int alignedDataFrameLength = align ( DataHeaderFlyweight . HEADER_LENGTH + FAKE_PAYLOAD . length , FrameDescriptor . FRAME_ALIGNMENT ) ; receiverProxy . registerReceiveChannelEndpoint ( receiveChannelEndpoint ) ; receiverProxy . addSubscription ( receiveChannelEndpoint , STREAM_ID ) ; receiver . doWork ( ) ; fillSetupFrame ( setupHeader , initialTermOffset ) ; receiveChannelEndpoint . onSetupMessage ( setupHeader , setupBuffer , setupHeader . frameLength ( ) , senderAddress ) ; final int commandsRead = toConductorQueue . drain ( ( e ) - > { assertTrue ( e instanceof CreateConnectionCmd ) ; receiverProxy . newConnection ( receiveChannelEndpoint , new NetworkConnection ( CORRELATION_ID , receiveChannelEndpoint , senderAddress , SESSION_ID , STREAM_ID , INITIAL_TERM_ID , ACTIVE_TERM_ID , initialTermOffset , INITIAL_WINDOW_LENGTH , rawLog , timerWheel , mockFeedbackDelayGenerator , POSITIONS , mockHighestReceivedPosition , clock , mockSystemCounters , SOURCE_ADDRESS ) ) ; } ) ; assertThat ( commandsRead , is ( 1 ) ) ; verify ( mockHighestReceivedPosition ) . setOrdered ( initialTermOffset ) ; receiver . doWork ( ) ; fillDataFrame ( dataHeader , initialTermOffset , FAKE_PAYLOAD ) ; receiveChannelEndpoint . onDataPacket ( dataHeader , dataBuffer , alignedDataFrameLength , senderAddress ) ; verify ( mockHighestReceivedPosition ) . setOrdered ( initialTermOffset + alignedDataFrameLength ) ; final long readOutcome = TermReader . read ( termBuffers [ ACTIVE_INDEX ] , initialTermOffset , ( buffer , offset , length , header ) - > { assertThat ( header . type ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( header . termId ( ) , is ( ACTIVE_TERM_ID ) ) ; assertThat ( header . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( header . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( header . termOffset ( ) , is ( initialTermOffset ) ) ; assertThat ( header . frameLength ( ) , is ( DataHeaderFlyweight . HEADER_LENGTH + FAKE_PAYLOAD . length ) ) ; } , Integer . MAX_VALUE , header , mockErrorHandler ) ; assertThat ( TermReader . fragmentsRead ( readOutcome ) , is ( 1 ) ) ; } private void fillDataFrame ( final DataHeaderFlyweight header , final int termOffset , final byte [ ] payload ) { header . wrap ( dataBuffer , 0 ) ; header . termOffset ( termOffset ) . termId ( ACTIVE_TERM_ID ) . streamId ( STREAM_ID ) . sessionId ( SESSION_ID ) . frameLength ( DataHeaderFlyweight . HEADER_LENGTH + payload . length ) . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) . flags ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) . version ( HeaderFlyweight . CURRENT_VERSION ) ; if ( 0 < payload . length ) { dataBuffer . putBytes ( header . dataOffset ( ) , payload ) ; } } private void fillSetupFrame ( final SetupFlyweight header ) { fillSetupFrame ( header , 0 ) ; } private void fillSetupFrame ( final SetupFlyweight header , final int termOffset ) { header . wrap ( setupBuffer , 0 ) ; header . streamId ( STREAM_ID ) . sessionId ( SESSION_ID ) . initialTermId ( INITIAL_TERM_ID ) . activeTermId ( ACTIVE_TERM_ID ) . termOffset ( termOffset ) . frameLength ( SetupFlyweight . HEADER_LENGTH ) . headerType ( HeaderFlyweight . HDR_TYPE_SETUP ) . flags ( ( byte ) 0 ) . version ( HeaderFlyweight . CURRENT_VERSION ) ; } }
package uk . co . real_logic . aeron . tools ; import org . junit . Test ; import java . util . ArrayList ; import java . util . List ; public class SecondsAtMessagesPerSecondTest { RateController rc ; List < RateControllerInterval > ivlsList = new ArrayList < > ( ) ; @ Test public void createWithOneAndOne ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new SecondsAtMessagesPerSecondInterval ( 1 , 1 ) ) ; rc = new RateController ( ( ) - > 0 , ivlsList ) ; } @ Test public void createWithZeroMessagesPerSecond ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new SecondsAtMessagesPerSecondInterval ( 1 , 0 ) ) ; rc = new RateController ( ( ) - > 0 , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithZeroSeconds ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new SecondsAtMessagesPerSecondInterval ( 0 , 1 ) ) ; rc = new RateController ( ( ) - > 0 , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithNegativeSeconds ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new SecondsAtMessagesPerSecondInterval ( - 1 , 1 ) ) ; rc = new RateController ( ( ) - > 0 , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithNegativeMessagesPerSecond ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new SecondsAtMessagesPerSecondInterval ( 1 , - 1 ) ) ; rc = new RateController ( ( ) - > 0 , ivlsList ) ; } }
package uk . co . real_logic . aeron . driver ; import org . hamcrest . Description ; import org . hamcrest . Matcher ; import org . hamcrest . TypeSafeMatcher ; import org . junit . Assume ; import org . junit . Test ; import uk . co . real_logic . aeron . driver . exceptions . InvalidChannelException ; import uk . co . real_logic . aeron . driver . media . UdpChannel ; import uk . co . real_logic . agrona . BitUtil ; import java . net . * ; import java . util . HashMap ; import java . util . Map ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . MatcherAssert . assertThat ; public class UdpChannelTest { @ Test public void shouldHandleExplicitLocalAddressAndPortFormat ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "udp://localhost:40123@localhost:40124" ) ; assertThat ( udpChannel . localData ( ) , is ( new InetSocketAddress ( "localhost" , 40123 ) ) ) ; assertThat ( udpChannel . localControl ( ) , is ( new InetSocketAddress ( "localhost" , 40123 ) ) ) ; assertThat ( udpChannel . remoteData ( ) , is ( new InetSocketAddress ( "localhost" , 40124 ) ) ) ; assertThat ( udpChannel . remoteControl ( ) , is ( new InetSocketAddress ( "localhost" , 40124 ) ) ) ; } @ Test public void shouldHandleExplicitLocalAddressAndPortFormatWithAeronUri ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "aeron:udp?local=localhost:40123|remote=localhost:40124" ) ; assertThat ( udpChannel . localData ( ) , is ( new InetSocketAddress ( "localhost" , 40123 ) ) ) ; assertThat ( udpChannel . localControl ( ) , is ( new InetSocketAddress ( "localhost" , 40123 ) ) ) ; assertThat ( udpChannel . remoteData ( ) , is ( new InetSocketAddress ( "localhost" , 40124 ) ) ) ; assertThat ( udpChannel . remoteControl ( ) , is ( new InetSocketAddress ( "localhost" , 40124 ) ) ) ; } @ Test public void shouldHandleImpliedLocalAddressAndPortFormat ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "udp://localhost:40124" ) ; assertThat ( udpChannel . localData ( ) , is ( new InetSocketAddress ( "0.0.0.0" , 0 ) ) ) ; assertThat ( udpChannel . localControl ( ) , is ( new InetSocketAddress ( "0.0.0.0" , 0 ) ) ) ; assertThat ( udpChannel . remoteData ( ) , is ( new InetSocketAddress ( "localhost" , 40124 ) ) ) ; assertThat ( udpChannel . remoteControl ( ) , is ( new InetSocketAddress ( "localhost" , 40124 ) ) ) ; } @ Test public void shouldHandleImpliedLocalAddressAndPortFormatWithAeronUri ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "aeron:udp?remote=localhost:40124" ) ; assertThat ( udpChannel . localData ( ) , is ( new InetSocketAddress ( "0.0.0.0" , 0 ) ) ) ; assertThat ( udpChannel . localControl ( ) , is ( new InetSocketAddress ( "0.0.0.0" , 0 ) ) ) ; assertThat ( udpChannel . remoteData ( ) , is ( new InetSocketAddress ( "localhost" , 40124 ) ) ) ; assertThat ( udpChannel . remoteControl ( ) , is ( new InetSocketAddress ( "localhost" , 40124 ) ) ) ; } @ Test ( expected = InvalidChannelException . class ) public void shouldThrowExceptionForIncorrectScheme ( ) throws Exception { UdpChannel . parse ( "unknownudp://localhost:40124" ) ; } @ Test ( expected = InvalidChannelException . class ) public void shouldThrowExceptionForMissingAddress ( ) throws Exception { UdpChannel . parse ( "udp://" ) ; } @ Test ( expected = InvalidChannelException . class ) public void shouldThrowExceptionForMissingAddressWithAeronUri ( ) throws Exception { UdpChannel . parse ( "aeron:udp" ) ; } @ Test ( expected = InvalidChannelException . class ) public void shouldThrowExceptionOnEvenMulticastAddress ( ) throws Exception { UdpChannel . parse ( "udp://224.10.9.8" ) ; } @ Test public void shouldParseValidMulticastAddress ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "udp://localhost@224.10.9.9:40124" ) ; assertThat ( udpChannel . localControl ( ) , is ( new InetSocketAddress ( "localhost" , 0 ) ) ) ; assertThat ( udpChannel . remoteControl ( ) , isMulticastAddress ( "224.10.9.10" , 40124 ) ) ; assertThat ( udpChannel . localData ( ) , is ( new InetSocketAddress ( "localhost" , 0 ) ) ) ; assertThat ( udpChannel . remoteData ( ) , isMulticastAddress ( "224.10.9.9" , 40124 ) ) ; assertThat ( udpChannel . localInterface ( ) , is ( NetworkInterface . getByInetAddress ( InetAddress . getByName ( "localhost" ) ) ) ) ; } @ Test public void shouldParseValidMulticastAddressWithAeronUri ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "aeron:udp?interface=localhost|group=224.10.9.9:40124" ) ; assertThat ( udpChannel . localControl ( ) , is ( new InetSocketAddress ( "localhost" , 0 ) ) ) ; assertThat ( udpChannel . remoteControl ( ) , isMulticastAddress ( "224.10.9.10" , 40124 ) ) ; assertThat ( udpChannel . localData ( ) , is ( new InetSocketAddress ( "localhost" , 0 ) ) ) ; assertThat ( udpChannel . remoteData ( ) , isMulticastAddress ( "224.10.9.9" , 40124 ) ) ; assertThat ( udpChannel . localInterface ( ) , is ( NetworkInterface . getByInetAddress ( InetAddress . getByName ( "localhost" ) ) ) ) ; } private Matcher < InetSocketAddress > isMulticastAddress ( final String addressName , final int port ) throws UnknownHostException { final InetAddress inetAddress = InetAddress . getByName ( addressName ) ; return is ( new InetSocketAddress ( inetAddress , port ) ) ; } @ Test public void shouldHandleImpliedLocalPortFormat ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "udp://localhost@localhost:40124" ) ; assertThat ( udpChannel . localData ( ) , is ( new InetSocketAddress ( "localhost" , 0 ) ) ) ; assertThat ( udpChannel . localControl ( ) , is ( new InetSocketAddress ( "localhost" , 0 ) ) ) ; assertThat ( udpChannel . remoteData ( ) , is ( new InetSocketAddress ( "localhost" , 40124 ) ) ) ; assertThat ( udpChannel . remoteControl ( ) , is ( new InetSocketAddress ( "localhost" , 40124 ) ) ) ; } @ Test public void shouldHandleImpliedLocalPortFormatWithAeronUri ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "aeron:udp?local=localhost|remote=localhost:40124" ) ; assertThat ( udpChannel . localData ( ) , is ( new InetSocketAddress ( "localhost" , 0 ) ) ) ; assertThat ( udpChannel . localControl ( ) , is ( new InetSocketAddress ( "localhost" , 0 ) ) ) ; assertThat ( udpChannel . remoteData ( ) , is ( new InetSocketAddress ( "localhost" , 40124 ) ) ) ; assertThat ( udpChannel . remoteControl ( ) , is ( new InetSocketAddress ( "localhost" , 40124 ) ) ) ; } @ Test public void shouldHandleLocalhostLookup ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "udp://localhost:40124" ) ; assertThat ( udpChannel . remoteData ( ) , is ( new InetSocketAddress ( "127.0.0.1" , 40124 ) ) ) ; assertThat ( udpChannel . remoteControl ( ) , is ( new InetSocketAddress ( "127.0.0.1" , 40124 ) ) ) ; } @ Test public void shouldHandleLocalhostLookupWithAeronUri ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "aeron:udp?remote=localhost:40124" ) ; assertThat ( udpChannel . remoteData ( ) , is ( new InetSocketAddress ( "127.0.0.1" , 40124 ) ) ) ; assertThat ( udpChannel . remoteControl ( ) , is ( new InetSocketAddress ( "127.0.0.1" , 40124 ) ) ) ; } @ Test public void shouldHandleBeingUsedAsMapKey ( ) throws Exception { final UdpChannel udpChannel1 = UdpChannel . parse ( "udp://localhost:40124" ) ; final UdpChannel udpChannel2 = UdpChannel . parse ( "udp://localhost:40124" ) ; final Map < UdpChannel , Integer > map = new HashMap < > ( ) ; map . put ( udpChannel1 , 1 ) ; assertThat ( map . get ( udpChannel2 ) , is ( 1 ) ) ; } @ Test ( expected = InvalidChannelException . class ) public void shouldThrowExceptionWhenNoPortSpecified ( ) throws Exception { UdpChannel . parse ( "udp://localhost" ) ; } @ Test public void shouldHandleCanonicalFormForUnicastCorrectly ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "udp://192.168.0.1:40456" ) ; final UdpChannel udpChannelLocal = UdpChannel . parse ( "udp://127.0.0.1@192.168.0.1:40456" ) ; final UdpChannel udpChannelLocalPort = UdpChannel . parse ( "udp://127.0.0.1:40455@192.168.0.1:40456" ) ; final UdpChannel udpChannelLocalhost = UdpChannel . parse ( "udp://localhost@localhost:40456" ) ; assertThat ( udpChannel . canonicalForm ( ) , is ( "UDP-00000000-0-c0a80001-40456" ) ) ; assertThat ( udpChannelLocal . canonicalForm ( ) , is ( "UDP-7f000001-0-c0a80001-40456" ) ) ; assertThat ( udpChannelLocalPort . canonicalForm ( ) , is ( "UDP-7f000001-40455-c0a80001-40456" ) ) ; assertThat ( udpChannelLocalhost . canonicalForm ( ) , is ( "UDP-7f000001-0-7f000001-40456" ) ) ; } @ Test public void shouldHandleIpV6CanonicalFormForUnicastCorrectly ( ) throws Exception { final UdpChannel udpChannelLocal = UdpChannel . parse ( "aeron:udp?local=[::1]|remote=192.168.0.1:40456" ) ; final UdpChannel udpChannelLocalPort = UdpChannel . parse ( "aeron:udp?local=127.0.0.1:40455|remote=[fe80::5246:5dff:fe73:df06]:40456" ) ; assertThat ( udpChannelLocal . canonicalForm ( ) , is ( "UDP-00000000000000000000000000000001-0-c0a80001-40456" ) ) ; assertThat ( udpChannelLocalPort . canonicalForm ( ) , is ( "UDP-7f000001-40455-fe8000000000000052465dfffe73df06-40456" ) ) ; } @ Test public void shouldHandleCanonicalFormForUnicastCorrectlyWithAeronUri ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "aeron:udp?remote=192.168.0.1:40456" ) ; final UdpChannel udpChannelLocal = UdpChannel . parse ( "aeron:udp?local=127.0.0.1|remote=192.168.0.1:40456" ) ; final UdpChannel udpChannelLocalPort = UdpChannel . parse ( "aeron:udp?local=127.0.0.1:40455|remote=192.168.0.1:40456" ) ; final UdpChannel udpChannelLocalhost = UdpChannel . parse ( "aeron:udp?local=localhost|remote=localhost:40456" ) ; assertThat ( udpChannel . canonicalForm ( ) , is ( "UDP-00000000-0-c0a80001-40456" ) ) ; assertThat ( udpChannelLocal . canonicalForm ( ) , is ( "UDP-7f000001-0-c0a80001-40456" ) ) ; assertThat ( udpChannelLocalPort . canonicalForm ( ) , is ( "UDP-7f000001-40455-c0a80001-40456" ) ) ; assertThat ( udpChannelLocalhost . canonicalForm ( ) , is ( "UDP-7f000001-0-7f000001-40456" ) ) ; } @ Test public void shouldGetProtocolFamilyForIpV4 ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "aeron:udp?local=127.0.0.1|remote=127.0.0.1:12345" ) ; assertThat ( udpChannel . protocolFamily ( ) , is ( ( ProtocolFamily ) StandardProtocolFamily . INET ) ) ; } @ Test public void shouldGetProtocolFamilyForIpV6 ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "aeron:udp?local=[::1]|remote=[::1]:12345" ) ; assertThat ( udpChannel . protocolFamily ( ) , is ( ( ProtocolFamily ) StandardProtocolFamily . INET6 ) ) ; } @ Test public void shouldGetProtocolFamilyForIpV4WithoutLocalSpecified ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "aeron:udp?remote=127.0.0.1:12345" ) ; assertThat ( udpChannel . protocolFamily ( ) , is ( ( ProtocolFamily ) StandardProtocolFamily . INET ) ) ; } @ Test public void shouldGetProtocolFamilyForIpV6WithoutLocalSpecified ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "aeron:udp?remote=[::1]:12345" ) ; assertThat ( udpChannel . protocolFamily ( ) , is ( ( ProtocolFamily ) StandardProtocolFamily . INET6 ) ) ; } @ Test public void shouldHandleCanonicalFormWithNsLookup ( ) throws Exception { final String localhostIpAsHex = resolveToHexAddress ( "localhost" ) ; final UdpChannel udpChannelExampleCom0 = UdpChannel . parse ( "aeron:udp?remote=localhost:40456" ) ; assertThat ( udpChannelExampleCom0 . canonicalForm ( ) , is ( "UDP-00000000-0-" + localhostIpAsHex + "-40456" ) ) ; final UdpChannel udpChannelExampleCom1 = UdpChannel . parse ( "udp://localhost:40456" ) ; assertThat ( udpChannelExampleCom1 . canonicalForm ( ) , is ( "UDP-00000000-0-" + localhostIpAsHex + "-40456" ) ) ; } @ Test public void shouldHandleCanonicalFormForMulticastWithLocalPort ( ) throws Exception { final UdpChannel udpChannelLocalPort = UdpChannel . parse ( "udp://127.0.0.1:40455@224.0.1.1:40456" ) ; assertThat ( udpChannelLocalPort . canonicalForm ( ) , is ( "UDP-7f000001-40455-e0000101-40456" ) ) ; final UdpChannel udpChannelSubnetLocalPort = UdpChannel . parse ( "udp://127.0.0.0:40455@224.0.1.1:40456?subnetPrefix=24" ) ; assertThat ( udpChannelSubnetLocalPort . canonicalForm ( ) , is ( "UDP-7f000001-40455-e0000101-40456" ) ) ; } @ Test public void shouldHandleCanonicalFormForMulticastCorrectly ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "udp://localhost@224.0.1.1:40456" ) ; final UdpChannel udpChannelLocal = UdpChannel . parse ( "udp://127.0.0.1@224.0.1.1:40456" ) ; final UdpChannel udpChannelAllSystems = UdpChannel . parse ( "udp://localhost@224.0.0.1:40456" ) ; final UdpChannel udpChannelDefault = UdpChannel . parse ( "udp://224.0.1.1:40456" ) ; final UdpChannel udpChannelSubnet = UdpChannel . parse ( "udp://localhost@224.0.1.1:40456?subnetPrefix=24" ) ; final UdpChannel udpChannelSubnetLocal = UdpChannel . parse ( "udp://127.0.0.0@224.0.1.1:40456?subnetPrefix=24" ) ; assertThat ( udpChannel . canonicalForm ( ) , is ( "UDP-7f000001-0-e0000101-40456" ) ) ; assertThat ( udpChannelLocal . canonicalForm ( ) , is ( "UDP-7f000001-0-e0000101-40456" ) ) ; assertThat ( udpChannelAllSystems . canonicalForm ( ) , is ( "UDP-7f000001-0-e0000001-40456" ) ) ; assertThat ( udpChannelSubnet . canonicalForm ( ) , is ( "UDP-7f000001-0-e0000101-40456" ) ) ; assertThat ( udpChannelSubnetLocal . canonicalForm ( ) , is ( "UDP-7f000001-0-e0000101-40456" ) ) ; assertThat ( udpChannelDefault . localInterface ( ) , supportsMulticastOrIsLoopback ( ) ) ; } @ Test public void shouldHandleCanonicalFormForMulticastCorrectlyWithAeronUri ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( "aeron:udp?interface=localhost|group=224.0.1.1:40456" ) ; final UdpChannel udpChannelLocal = UdpChannel . parse ( "aeron:udp?interface=127.0.0.1|group=224.0.1.1:40456" ) ; final UdpChannel udpChannelAllSystems = UdpChannel . parse ( "aeron:udp?interface=localhost|group=224.0.0.1:40456" ) ; final UdpChannel udpChannelDefault = UdpChannel . parse ( "aeron:udp?group=224.0.1.1:40456" ) ; final UdpChannel udpChannelSubnet = UdpChannel . parse ( "aeron:udp?interface=localhost/24|group=224.0.1.1:40456" ) ; final UdpChannel udpChannelSubnetLocal = UdpChannel . parse ( "aeron:udp?interface=127.0.0.0/24|group=224.0.1.1:40456" ) ; assertThat ( udpChannel . canonicalForm ( ) , is ( "UDP-7f000001-0-e0000101-40456" ) ) ; assertThat ( udpChannelLocal . canonicalForm ( ) , is ( "UDP-7f000001-0-e0000101-40456" ) ) ; assertThat ( udpChannelAllSystems . canonicalForm ( ) , is ( "UDP-7f000001-0-e0000001-40456" ) ) ; assertThat ( udpChannelSubnet . canonicalForm ( ) , is ( "UDP-7f000001-0-e0000101-40456" ) ) ; assertThat ( udpChannelSubnetLocal . canonicalForm ( ) , is ( "UDP-7f000001-0-e0000101-40456" ) ) ; assertThat ( udpChannelDefault . localInterface ( ) , supportsMulticastOrIsLoopback ( ) ) ; } @ Test public void shouldHandleIpV6CanonicalFormForMulticastCorrectly ( ) throws Exception { Assume . assumeTrue ( System . getProperty ( "java.net.preferIPv4Stack" ) == null ) ; final UdpChannel udpChannel = UdpChannel . parse ( "aeron:udp?interface=localhost|group=[FF01::FD]:40456" ) ; final UdpChannel udpChannelLocal = UdpChannel . parse ( "aeron:udp?interface=[::1]:54321/64|group=224.0.1.1:40456" ) ; assertThat ( udpChannel . canonicalForm ( ) , is ( "UDP-7f000001-0-ff0100000000000000000000000000fd-40456" ) ) ; assertThat ( udpChannelLocal . canonicalForm ( ) , is ( "UDP-00000000000000000000000000000001-54321-e0000101-40456" ) ) ; } @ Test ( expected = InvalidChannelException . class ) public void shouldFailIfBothUnicastAndMulticastSpecified ( ) throws Exception { UdpChannel . parse ( "aeron:udp?group=224.0.1.1:40456|remote=192.168.0.1:40456" ) ; } private static Matcher < NetworkInterface > supportsMulticastOrIsLoopback ( ) { return new TypeSafeMatcher < NetworkInterface > ( ) { @ Override public void describeTo ( Description description ) { description . appendText ( "Interface supports multicast or is loopack" ) ; } @ Override protected boolean matchesSafely ( final NetworkInterface item ) { try { return item . supportsMulticast ( ) || item . isLoopback ( ) ; } catch ( final SocketException e ) { throw new RuntimeException ( e ) ; } } } ; } private String resolveToHexAddress ( final String host ) throws UnknownHostException { return BitUtil . toHex ( InetAddress . getByName ( host ) . getAddress ( ) ) ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . driver . buffer . RawLog ; import uk . co . real_logic . aeron . driver . buffer . RawLogPartition ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; import java . util . stream . Stream ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . LOG_META_DATA_LENGTH ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . PARTITION_COUNT ; public class LogBufferHelper { public static RawLog newTestLogBuffers ( final int termLength , final int metaDataLength ) { return new RawLog ( ) { private final RawLogPartition [ ] partitions = new RawLogPartition [ ] { newTestLogBuffer ( termLength , metaDataLength ) , newTestLogBuffer ( termLength , metaDataLength ) , newTestLogBuffer ( termLength , metaDataLength ) , } ; private final UnsafeBuffer logMetaData = new UnsafeBuffer ( ByteBuffer . allocateDirect ( LOG_META_DATA_LENGTH ) ) ; public Stream < RawLogPartition > stream ( ) { return Stream . of ( partitions ) ; } public RawLogPartition [ ] partitions ( ) { return partitions ; } public UnsafeBuffer logMetaData ( ) { return logMetaData ; } public ByteBuffer [ ] sliceTerms ( ) { final ByteBuffer [ ] terms = new ByteBuffer [ PARTITION_COUNT ] ; for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { terms [ i ] = partitions [ i ] . termBuffer ( ) . byteBuffer ( ) . duplicate ( ) ; } return terms ; } public String logFileName ( ) { return "stream.log" ; } public void close ( ) { } } ; } private static RawLogPartition newTestLogBuffer ( final int termBufferLength , final int metaDataBufferLength ) { return new RawLogPartition ( new UnsafeBuffer ( ByteBuffer . allocateDirect ( termBufferLength ) ) , new UnsafeBuffer ( ByteBuffer . allocateDirect ( metaDataBufferLength ) ) ) ; } }
package uk . co . real_logic . aeron . driver ; import org . junit . After ; import org . junit . Test ; import uk . co . real_logic . aeron . logbuffer . FrameDescriptor ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . protocol . HeaderFlyweight ; import uk . co . real_logic . aeron . protocol . StatusMessageFlyweight ; import uk . co . real_logic . aeron . driver . media . ReceiverUdpChannelTransport ; import uk . co . real_logic . aeron . driver . media . SenderUdpChannelTransport ; import uk . co . real_logic . aeron . driver . media . TransportPoller ; import uk . co . real_logic . aeron . driver . media . UdpChannel ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . util . concurrent . atomic . AtomicInteger ; import static org . hamcrest . core . Is . is ; import static org . junit . Assert . assertThat ; import static org . mockito . Mockito . mock ; public class SelectorAndTransportTest { private static final int RCV_PORT = 40123 ; private static final int SRC_PORT = 40124 ; private static final int SESSION_ID = 0xdeadbeef ; private static final int STREAM_ID = 0x44332211 ; private static final int TERM_ID = 0x99887766 ; private static final int FRAME_LENGTH = 24 ; private static final UdpChannel SRC_DST = UdpChannel . parse ( "udp://localhost:" + SRC_PORT + "@localhost:" + RCV_PORT ) ; private static final UdpChannel RCV_DST = UdpChannel . parse ( "udp://localhost:" + RCV_PORT ) ; private static final LossGenerator NO_LOSS = ( address , header , length ) - > false ; private final ByteBuffer byteBuffer = ByteBuffer . allocateDirect ( 256 ) ; private final UnsafeBuffer buffer = new UnsafeBuffer ( byteBuffer ) ; private final DataHeaderFlyweight encodeDataHeader = new DataHeaderFlyweight ( ) ; private final StatusMessageFlyweight statusMessage = new StatusMessageFlyweight ( ) ; private final InetSocketAddress rcvRemoteAddress = new InetSocketAddress ( "localhost" , SRC_PORT ) ; private final InetSocketAddress srcRemoteAddress = new InetSocketAddress ( "localhost" , RCV_PORT ) ; private final EventLogger mockTransportLogger = mock ( EventLogger . class ) ; private final DataPacketHandler mockDataPacketHandler = mock ( DataPacketHandler . class ) ; private final SetupMessageHandler mockSetupMessageHandler = mock ( SetupMessageHandler . class ) ; private final NakMessageHandler mockNakMessageHandler = mock ( NakMessageHandler . class ) ; private final StatusMessageHandler mockStatusMessageHandler = mock ( StatusMessageHandler . class ) ; private TransportPoller transportPoller ; private SenderUdpChannelTransport senderTransport ; private ReceiverUdpChannelTransport receiverTransport ; @ After public void tearDown ( ) { try { if ( null != senderTransport ) { senderTransport . close ( ) ; processLoop ( transportPoller , 5 ) ; } if ( null != receiverTransport ) { receiverTransport . close ( ) ; processLoop ( transportPoller , 5 ) ; } if ( null != transportPoller ) { transportPoller . close ( ) ; } } catch ( final Exception ex ) { ex . printStackTrace ( ) ; } } @ Test ( timeout = 1000 ) public void shouldHandleBasicSetupAndTeardown ( ) throws Exception { transportPoller = new TransportPoller ( ) ; receiverTransport = new ReceiverUdpChannelTransport ( RCV_DST , mockDataPacketHandler , mockSetupMessageHandler , mockTransportLogger , NO_LOSS ) ; senderTransport = new SenderUdpChannelTransport ( SRC_DST , mockStatusMessageHandler , mockNakMessageHandler , mockTransportLogger , NO_LOSS ) ; receiverTransport . openDatagramChannel ( ) ; receiverTransport . registerForRead ( transportPoller ) ; senderTransport . openDatagramChannel ( ) ; senderTransport . registerForRead ( transportPoller ) ; processLoop ( transportPoller , 5 ) ; } @ Test ( timeout = 1000 ) public void shouldSendEmptyDataFrameUnicastFromSourceToReceiver ( ) throws Exception { final AtomicInteger dataHeadersReceived = new AtomicInteger ( 0 ) ; final DataPacketHandler dataPacketHandler = ( header , buffer , length , srcAddress ) - > { assertThat ( header . version ( ) , is ( ( short ) HeaderFlyweight . CURRENT_VERSION ) ) ; assertThat ( header . flags ( ) , is ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ) ; assertThat ( header . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( header . frameLength ( ) , is ( FRAME_LENGTH ) ) ; assertThat ( header . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( header . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( header . termId ( ) , is ( TERM_ID ) ) ; assertThat ( header . dataOffset ( ) , is ( FRAME_LENGTH ) ) ; dataHeadersReceived . incrementAndGet ( ) ; return length ; } ; transportPoller = new TransportPoller ( ) ; receiverTransport = new ReceiverUdpChannelTransport ( RCV_DST , dataPacketHandler , mockSetupMessageHandler , mockTransportLogger , NO_LOSS ) ; senderTransport = new SenderUdpChannelTransport ( SRC_DST , mockStatusMessageHandler , mockNakMessageHandler , mockTransportLogger , NO_LOSS ) ; receiverTransport . openDatagramChannel ( ) ; receiverTransport . registerForRead ( transportPoller ) ; senderTransport . openDatagramChannel ( ) ; senderTransport . registerForRead ( transportPoller ) ; encodeDataHeader . wrap ( buffer , 0 ) ; encodeDataHeader . version ( HeaderFlyweight . CURRENT_VERSION ) . flags ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) . frameLength ( FRAME_LENGTH ) ; encodeDataHeader . sessionId ( SESSION_ID ) . streamId ( STREAM_ID ) . termId ( TERM_ID ) ; byteBuffer . position ( 0 ) . limit ( FRAME_LENGTH ) ; processLoop ( transportPoller , 5 ) ; senderTransport . sendTo ( byteBuffer , srcRemoteAddress ) ; while ( dataHeadersReceived . get ( ) < 1 ) { processLoop ( transportPoller , 1 ) ; } assertThat ( dataHeadersReceived . get ( ) , is ( 1 ) ) ; } @ Test ( timeout = 1000 ) public void shouldSendMultipleDataFramesPerDatagramUnicastFromSourceToReceiver ( ) throws Exception { final AtomicInteger dataHeadersReceived = new AtomicInteger ( 0 ) ; final DataPacketHandler dataPacketHandler = ( header , buffer , length , srcAddress ) - > { assertThat ( header . version ( ) , is ( ( short ) HeaderFlyweight . CURRENT_VERSION ) ) ; assertThat ( header . flags ( ) , is ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ) ; assertThat ( header . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( header . frameLength ( ) , is ( FRAME_LENGTH ) ) ; assertThat ( header . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( header . streamId ( ) , is ( STREAM_ID ) ) ; assertThat ( header . termId ( ) , is ( TERM_ID ) ) ; assertThat ( length , is ( 2 * BitUtil . align ( FRAME_LENGTH , FrameDescriptor . FRAME_ALIGNMENT ) ) ) ; dataHeadersReceived . incrementAndGet ( ) ; return length ; } ; transportPoller = new TransportPoller ( ) ; receiverTransport = new ReceiverUdpChannelTransport ( RCV_DST , dataPacketHandler , mockSetupMessageHandler , mockTransportLogger , NO_LOSS ) ; senderTransport = new SenderUdpChannelTransport ( SRC_DST , mockStatusMessageHandler , mockNakMessageHandler , mockTransportLogger , NO_LOSS ) ; receiverTransport . openDatagramChannel ( ) ; receiverTransport . registerForRead ( transportPoller ) ; senderTransport . openDatagramChannel ( ) ; senderTransport . registerForRead ( transportPoller ) ; encodeDataHeader . wrap ( buffer , 0 ) ; encodeDataHeader . version ( HeaderFlyweight . CURRENT_VERSION ) . flags ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) . frameLength ( FRAME_LENGTH ) ; encodeDataHeader . sessionId ( SESSION_ID ) . streamId ( STREAM_ID ) . termId ( TERM_ID ) ; encodeDataHeader . wrap ( buffer , BitUtil . align ( FRAME_LENGTH , FrameDescriptor . FRAME_ALIGNMENT ) ) ; encodeDataHeader . version ( HeaderFlyweight . CURRENT_VERSION ) . flags ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) . frameLength ( 24 ) ; encodeDataHeader . sessionId ( SESSION_ID ) . streamId ( STREAM_ID ) . termId ( TERM_ID ) ; byteBuffer . position ( 0 ) . limit ( 2 * BitUtil . align ( FRAME_LENGTH , FrameDescriptor . FRAME_ALIGNMENT ) ) ; processLoop ( transportPoller , 5 ) ; senderTransport . sendTo ( byteBuffer , srcRemoteAddress ) ; while ( dataHeadersReceived . get ( ) < 1 ) { processLoop ( transportPoller , 1 ) ; } assertThat ( dataHeadersReceived . get ( ) , is ( 1 ) ) ; } @ Test ( timeout = 1000 ) public void shouldHandleSmFrameFromReceiverToSender ( ) throws Exception { final AtomicInteger controlHeadersReceived = new AtomicInteger ( 0 ) ; final StatusMessageHandler statusMessageHandler = ( statusMessage , srcAddress ) - > { assertThat ( statusMessage . version ( ) , is ( ( short ) HeaderFlyweight . CURRENT_VERSION ) ) ; assertThat ( statusMessage . frameLength ( ) , is ( StatusMessageFlyweight . HEADER_LENGTH ) ) ; controlHeadersReceived . incrementAndGet ( ) ; } ; transportPoller = new TransportPoller ( ) ; receiverTransport = new ReceiverUdpChannelTransport ( RCV_DST , mockDataPacketHandler , mockSetupMessageHandler , mockTransportLogger , NO_LOSS ) ; senderTransport = new SenderUdpChannelTransport ( SRC_DST , statusMessageHandler , mockNakMessageHandler , mockTransportLogger , NO_LOSS ) ; receiverTransport . openDatagramChannel ( ) ; receiverTransport . registerForRead ( transportPoller ) ; senderTransport . openDatagramChannel ( ) ; senderTransport . registerForRead ( transportPoller ) ; statusMessage . wrap ( buffer , 0 ) ; statusMessage . streamId ( STREAM_ID ) . sessionId ( SESSION_ID ) . consumptionTermId ( TERM_ID ) . receiverWindowLength ( 1000 ) . consumptionTermOffset ( 0 ) . version ( HeaderFlyweight . CURRENT_VERSION ) . flags ( ( short ) 0 ) . headerType ( HeaderFlyweight . HDR_TYPE_SM ) . frameLength ( StatusMessageFlyweight . HEADER_LENGTH ) ; byteBuffer . position ( 0 ) . limit ( statusMessage . frameLength ( ) ) ; processLoop ( transportPoller , 5 ) ; receiverTransport . sendTo ( byteBuffer , rcvRemoteAddress ) ; while ( controlHeadersReceived . get ( ) < 1 ) { processLoop ( transportPoller , 1 ) ; } assertThat ( controlHeadersReceived . get ( ) , is ( 1 ) ) ; } private void processLoop ( final TransportPoller transportPoller , final int iterations ) throws Exception { for ( int i = 0 ; i < iterations ; i ++ ) { transportPoller . pollTransports ( ) ; } } }
package uk . co . real_logic . aeron . driver ; import org . junit . experimental . theories . DataPoint ; import org . junit . experimental . theories . Theories ; import org . junit . experimental . theories . Theory ; import org . junit . runner . RunWith ; import org . mockito . InOrder ; import uk . co . real_logic . aeron . logbuffer . FrameDescriptor ; import uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor ; import uk . co . real_logic . aeron . logbuffer . TermAppender ; import uk . co . real_logic . aeron . logbuffer . TermRebuilder ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . protocol . HeaderFlyweight ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; import java . util . concurrent . TimeUnit ; import java . util . function . BiConsumer ; import java . util . function . BooleanSupplier ; import java . util . stream . IntStream ; import static org . mockito . Mockito . * ; import static uk . co . real_logic . agrona . BitUtil . align ; @ RunWith ( Theories . class ) public class RetransmitHandlerTest { private static final int MTU_LENGTH = 1024 ; private static final int TERM_BUFFER_LENGTH = LogBufferDescriptor . TERM_MIN_LENGTH ; private static final int META_DATA_BUFFER_LENGTH = LogBufferDescriptor . TERM_META_DATA_LENGTH ; private static final byte [ ] DATA = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 } ; private static final int MESSAGE_LENGTH = DataHeaderFlyweight . HEADER_LENGTH + DATA . length ; private static final int ALIGNED_FRAME_LENGTH = align ( MESSAGE_LENGTH , FrameDescriptor . FRAME_ALIGNMENT ) ; private static final int SESSION_ID = 0x5E55101D ; private static final int STREAM_ID = 0x5400E ; private static final int TERM_ID = 0x7F003355 ; private static final FeedbackDelayGenerator DELAY_GENERATOR = ( ) - > TimeUnit . MILLISECONDS . toNanos ( 20 ) ; private static final FeedbackDelayGenerator ZERO_DELAY_GENERATOR = ( ) - > TimeUnit . MILLISECONDS . toNanos ( 0 ) ; private static final FeedbackDelayGenerator LINGER_GENERATOR = ( ) - > TimeUnit . MILLISECONDS . toNanos ( 40 ) ; private final UnsafeBuffer termBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( TERM_BUFFER_LENGTH ) ) ; private final UnsafeBuffer metaDataBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( META_DATA_BUFFER_LENGTH ) ) ; private final TermAppender termAppender = new TermAppender ( termBuffer , metaDataBuffer , DataHeaderFlyweight . createDefaultHeader ( 0 , 0 , 0 ) , 1024 ) ; private final UnsafeBuffer rcvBuffer = new UnsafeBuffer ( new byte [ MESSAGE_LENGTH ] ) ; private DataHeaderFlyweight dataHeader = new DataHeaderFlyweight ( ) ; private long currentTime ; private final TimerWheel wheel = new TimerWheel ( ( ) - > currentTime , Configuration . CONDUCTOR_TICK_DURATION_US , TimeUnit . MICROSECONDS , Configuration . CONDUCTOR_TICKS_PER_WHEEL ) ; private final RetransmitSender retransmitSender = mock ( RetransmitSender . class ) ; private final SystemCounters systemCounters = mock ( SystemCounters . class ) ; private RetransmitHandler handler = new RetransmitHandler ( wheel , systemCounters , DELAY_GENERATOR , LINGER_GENERATOR , retransmitSender , TERM_ID , TERM_BUFFER_LENGTH ) ; @ DataPoint public static final BiConsumer < RetransmitHandlerTest , Integer > SENDER_ADD_DATA_FRAME = ( h , i ) - > h . addSentDataFrame ( ) ; @ DataPoint public static final BiConsumer < RetransmitHandlerTest , Integer > RECEIVER_ADD_DATA_FRAME = RetransmitHandlerTest : : addReceivedDataFrame ; @ Theory public void shouldRetransmitOnNak ( final BiConsumer < RetransmitHandlerTest , Integer > creator ) { createTermBuffer ( creator , 5 ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 100 ) ) ; verify ( retransmitSender ) . resend ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; } @ Theory public void shouldNotRetransmitOnNakWhileInLinger ( final BiConsumer < RetransmitHandlerTest , Integer > creator ) { createTermBuffer ( creator , 5 ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 40 ) ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 100 ) ) ; verify ( retransmitSender ) . resend ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; } @ Theory public void shouldRetransmitOnNakAfterLinger ( final BiConsumer < RetransmitHandlerTest , Integer > creator ) { createTermBuffer ( creator , 5 ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 100 ) ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 200 ) ) ; verify ( retransmitSender , times ( 2 ) ) . resend ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; } @ Theory public void shouldRetransmitOnMultipleNaks ( final BiConsumer < RetransmitHandlerTest , Integer > creator ) { createTermBuffer ( creator , 5 ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 1 ) , ALIGNED_FRAME_LENGTH ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 100 ) ) ; final InOrder inOrder = inOrder ( retransmitSender ) ; inOrder . verify ( retransmitSender ) . resend ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; inOrder . verify ( retransmitSender ) . resend ( TERM_ID , offsetOfFrame ( 1 ) , ALIGNED_FRAME_LENGTH ) ; } @ Theory public void shouldRetransmitOnNakOverMessageLength ( final BiConsumer < RetransmitHandlerTest , Integer > creator ) { createTermBuffer ( creator , 10 ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH * 5 ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 100 ) ) ; verify ( retransmitSender ) . resend ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH * 5 ) ; } @ Theory public void shouldRetransmitOnNakOverMtuLength ( final BiConsumer < RetransmitHandlerTest , Integer > creator ) { final int numFramesPerMtu = MTU_LENGTH / ALIGNED_FRAME_LENGTH ; createTermBuffer ( creator , numFramesPerMtu * 5 ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , MTU_LENGTH * 2 ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 100 ) ) ; verify ( retransmitSender ) . resend ( TERM_ID , offsetOfFrame ( 0 ) , MTU_LENGTH * 2 ) ; } @ Theory public void shouldStopRetransmitOnRetransmitReception ( final BiConsumer < RetransmitHandlerTest , Integer > creator ) { createTermBuffer ( creator , 5 ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; handler . onRetransmitReceived ( TERM_ID , offsetOfFrame ( 0 ) ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 100 ) ) ; verifyZeroInteractions ( retransmitSender ) ; } @ Theory public void shouldStopOneRetransmitOnRetransmitReception ( final BiConsumer < RetransmitHandlerTest , Integer > creator ) { createTermBuffer ( creator , 5 ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 1 ) , ALIGNED_FRAME_LENGTH ) ; handler . onRetransmitReceived ( TERM_ID , offsetOfFrame ( 0 ) ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 100 ) ) ; verify ( retransmitSender ) . resend ( TERM_ID , offsetOfFrame ( 1 ) , ALIGNED_FRAME_LENGTH ) ; } @ Theory public void shouldImmediateRetransmitOnNak ( final BiConsumer < RetransmitHandlerTest , Integer > creator ) { createTermBuffer ( creator , 5 ) ; handler = newZeroDelayRetransmitHandler ( ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; verify ( retransmitSender ) . resend ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; } @ Theory public void shouldGoIntoLingerOnImmediateRetransmit ( final BiConsumer < RetransmitHandlerTest , Integer > creator ) { createTermBuffer ( creator , 5 ) ; handler = newZeroDelayRetransmitHandler ( ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 40 ) ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; verify ( retransmitSender ) . resend ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; } @ Theory public void shouldOnlyRetransmitOnNakWhenConfiguredTo ( final BiConsumer < RetransmitHandlerTest , Integer > creator ) { createTermBuffer ( creator , 5 ) ; handler . onNak ( TERM_ID , offsetOfFrame ( 0 ) , ALIGNED_FRAME_LENGTH ) ; verifyZeroInteractions ( retransmitSender ) ; } private RetransmitHandler newZeroDelayRetransmitHandler ( ) { return new RetransmitHandler ( wheel , systemCounters , ZERO_DELAY_GENERATOR , LINGER_GENERATOR , retransmitSender , TERM_ID , TERM_BUFFER_LENGTH ) ; } private void createTermBuffer ( final BiConsumer < RetransmitHandlerTest , Integer > creator , final int num ) { IntStream . range ( 0 , num ) . forEach ( ( i ) - > creator . accept ( this , i ) ) ; } private static int offsetOfFrame ( final int index ) { return index * ALIGNED_FRAME_LENGTH ; } private void addSentDataFrame ( ) { rcvBuffer . putBytes ( 0 , DATA ) ; termAppender . append ( rcvBuffer , 0 , DATA . length ) ; } private void addReceivedDataFrame ( final int msgNum ) { dataHeader . wrap ( rcvBuffer , 0 ) ; dataHeader . termId ( TERM_ID ) . streamId ( STREAM_ID ) . sessionId ( SESSION_ID ) . termOffset ( offsetOfFrame ( msgNum ) ) . frameLength ( MESSAGE_LENGTH ) . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) . flags ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) . version ( HeaderFlyweight . CURRENT_VERSION ) ; dataHeader . buffer ( ) . putBytes ( dataHeader . dataOffset ( ) , DATA ) ; TermRebuilder . insert ( termBuffer , offsetOfFrame ( msgNum ) , rcvBuffer , MESSAGE_LENGTH ) ; } private long processTimersUntil ( final BooleanSupplier condition ) { final long start = wheel . clock ( ) . nanoTime ( ) ; while ( ! condition . getAsBoolean ( ) ) { if ( wheel . computeDelayInMs ( ) > 0 ) { currentTime += TimeUnit . MICROSECONDS . toNanos ( Configuration . CONDUCTOR_TICK_DURATION_US ) ; } wheel . expireTimers ( ) ; } return wheel . clock ( ) . nanoTime ( ) - start ; } }
package uk . co . real_logic . aeron . driver ; import org . junit . Test ; import java . util . stream . IntStream ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; public class OptimalMulticastDelayGeneratorTest { private static final long MAX_BACKOFF = 60 ; private static final long GROUP_SIZE = 10 ; private static final long GRTT = 10 ; private OptimalMulticastDelayGenerator generator = new OptimalMulticastDelayGenerator ( MAX_BACKOFF , GROUP_SIZE , GRTT ) ; @ Test public void shouldNotExceedTmaxBackoff ( ) { IntStream . range ( 0 , 100000 ) . forEach ( ( i ) - > { final double delay = generator . generateNewOptimalDelay ( ) ; assertThat ( delay , lessThanOrEqualTo ( ( double ) MAX_BACKOFF ) ) ; } ) ; } }
package uk . co . real_logic . aeron . driver ; import org . junit . Test ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URLEncoder ; import java . util . HashMap ; import java . util . Map ; import static java . lang . String . format ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertThat ; import static uk . co . real_logic . aeron . driver . UriUtil . parseQueryString ; public class UriUtilTest { @ Test public void shouldParseSimpleQueryParameters ( ) throws Exception { final Map < String , String > params = doParse ( URI . create ( "http://example.com:12345/foo/bar.html?mask=24" ) ) ; assertThat ( params . size ( ) , is ( 1 ) ) ; assertThat ( params . get ( "mask" ) , is ( "24" ) ) ; } @ Test public void shouldParseWithMissingValuePart ( ) throws Exception { final Map < String , String > params = doParse ( URI . create ( "http://example.com:12345/foo/bar.html?mask" ) ) ; assertThat ( params . containsKey ( "mask" ) , is ( true ) ) ; assertThat ( params . get ( "mask" ) , is ( "" ) ) ; } @ Test public void shouldParseWithMultipleArguments ( ) throws Exception { final Map < String , String > params = doParse ( URI . create ( "http://example.com:12345/foo/bar.html?mask=24&wibble&bits=0110102" ) ) ; assertThat ( params . get ( "mask" ) , is ( "24" ) ) ; assertThat ( params . get ( "bits" ) , is ( "0110102" ) ) ; assertThat ( params . get ( "wibble" ) , is ( "" ) ) ; } @ Test public void shouldParseEncodedArguments ( ) throws Exception { final Map < String , String > params = doParse ( URI . create ( format ( "http://example.com:12345/foo/bar.html?mask=24&ip=%s" , URLEncoder . encode ( "FE80::0202:B3FF:FE1E:8329" , "UTF-8" ) ) ) ) ; assertThat ( params . get ( "ip" ) , is ( "FE80::0202:B3FF:FE1E:8329" ) ) ; } @ Test public void shouldAllowArgumentsThatAreNotEncodedButShouldBe ( ) throws Exception { final Map < String , String > params = doParse ( URI . create ( format ( "http://example.com:12345/foo/bar.html?mask=24&ip=%s" , "FE80::0202:B3FF:FE1E:8329" ) ) ) ; assertThat ( params . get ( "ip" ) , is ( "FE80::0202:B3FF:FE1E:8329" ) ) ; } @ Test ( expected = URISyntaxException . class ) public void shouldThrowMalformedUriExceptionIfQueryParametersAreInvalid ( ) throws Exception { doParse ( URI . create ( "http://example.com:12345/foo/bar.html?mask=24&ip=abc=4" ) ) ; } private static Map < String , String > doParse ( final URI uri ) throws URISyntaxException { return parseQueryString ( uri , new HashMap < > ( ) ) ; } }
package uk . co . real_logic . aeron . driver ; import org . junit . Test ; import org . mockito . InOrder ; import uk . co . real_logic . aeron . logbuffer . FrameDescriptor ; import uk . co . real_logic . aeron . logbuffer . TermRebuilder ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . protocol . HeaderFlyweight ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; import java . util . concurrent . TimeUnit ; import java . util . function . BooleanSupplier ; import static org . mockito . Mockito . * ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . TERM_MIN_LENGTH ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . computePosition ; import static uk . co . real_logic . agrona . BitUtil . align ; public class LossDetectorTest { private static final int TERM_BUFFER_LENGTH = TERM_MIN_LENGTH ; private static final int POSITION_BITS_TO_SHIFT = Integer . numberOfTrailingZeros ( TERM_BUFFER_LENGTH ) ; private static final int MASK = TERM_BUFFER_LENGTH - 1 ; private static final byte [ ] DATA = new byte [ 36 ] ; static { for ( int i = 0 ; i < DATA . length ; i ++ ) { DATA [ i ] = ( byte ) i ; } } private static final int MESSAGE_LENGTH = DataHeaderFlyweight . HEADER_LENGTH + DATA . length ; private static final int ALIGNED_FRAME_LENGTH = align ( MESSAGE_LENGTH , FrameDescriptor . FRAME_ALIGNMENT ) ; private static final int SESSION_ID = 0x5E55101D ; private static final int STREAM_ID = 0xC400E ; private static final int TERM_ID = 0xEE81D ; private static final long ACTIVE_TERM_POSITION = computePosition ( TERM_ID , 0 , POSITION_BITS_TO_SHIFT , TERM_ID ) ; private static final StaticDelayGenerator DELAY_GENERATOR = new StaticDelayGenerator ( TimeUnit . MILLISECONDS . toNanos ( 20 ) , false ) ; private static final StaticDelayGenerator DELAY_GENERATOR_WITH_IMMEDIATE = new StaticDelayGenerator ( TimeUnit . MILLISECONDS . toNanos ( 20 ) , true ) ; private final UnsafeBuffer termBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( TERM_BUFFER_LENGTH ) ) ; private final UnsafeBuffer rcvBuffer = new UnsafeBuffer ( new byte [ MESSAGE_LENGTH ] ) ; private final DataHeaderFlyweight dataHeader = new DataHeaderFlyweight ( ) ; private final TimerWheel wheel ; private LossDetector handler ; private NakMessageSender nakMessageSender ; private long currentTime = 0 ; public LossDetectorTest ( ) { wheel = new TimerWheel ( ( ) - > currentTime , Configuration . CONDUCTOR_TICK_DURATION_US , TimeUnit . MICROSECONDS , Configuration . CONDUCTOR_TICKS_PER_WHEEL ) ; nakMessageSender = mock ( NakMessageSender . class ) ; handler = new LossDetector ( wheel , DELAY_GENERATOR , nakMessageSender ) ; dataHeader . wrap ( rcvBuffer , 0 ) ; } @ Test public void shouldNotSendNakWhenBufferIsEmpty ( ) { final long rebuildPosition = ACTIVE_TERM_POSITION ; final long hwmPosition = ACTIVE_TERM_POSITION ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 100 ) ) ; verifyZeroInteractions ( nakMessageSender ) ; } @ Test public void shouldNakMissingData ( ) { final long rebuildPosition = ACTIVE_TERM_POSITION ; final long hwmPosition = ACTIVE_TERM_POSITION + ( ALIGNED_FRAME_LENGTH * 3 ) ; insertDataFrame ( offsetOfMessage ( 0 ) ) ; insertDataFrame ( offsetOfMessage ( 2 ) ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 40 ) ) ; verify ( nakMessageSender ) . onLossDetected ( TERM_ID , offsetOfMessage ( 1 ) , gapLength ( ) ) ; } @ Test public void shouldRetransmitNakForMissingData ( ) { final long rebuildPosition = ACTIVE_TERM_POSITION ; final long hwmPosition = ACTIVE_TERM_POSITION + ( ALIGNED_FRAME_LENGTH * 3 ) ; insertDataFrame ( offsetOfMessage ( 0 ) ) ; insertDataFrame ( offsetOfMessage ( 2 ) ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 60 ) ) ; verify ( nakMessageSender , atLeast ( 2 ) ) . onLossDetected ( TERM_ID , offsetOfMessage ( 1 ) , gapLength ( ) ) ; } @ Test public void shouldSuppressNakOnReceivingNak ( ) { final long rebuildPosition = ACTIVE_TERM_POSITION ; final long hwmPosition = ACTIVE_TERM_POSITION + ( ALIGNED_FRAME_LENGTH * 3 ) ; insertDataFrame ( offsetOfMessage ( 0 ) ) ; insertDataFrame ( offsetOfMessage ( 2 ) ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 20 ) ) ; handler . onNak ( TERM_ID , offsetOfMessage ( 1 ) ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 20 ) ) ; verifyZeroInteractions ( nakMessageSender ) ; } @ Test public void shouldStopNakOnReceivingData ( ) { long rebuildPosition = ACTIVE_TERM_POSITION ; final long hwmPosition = ACTIVE_TERM_POSITION + ( ALIGNED_FRAME_LENGTH * 3 ) ; insertDataFrame ( offsetOfMessage ( 0 ) ) ; insertDataFrame ( offsetOfMessage ( 2 ) ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 20 ) ) ; insertDataFrame ( offsetOfMessage ( 1 ) ) ; rebuildPosition += ( ALIGNED_FRAME_LENGTH * 3 ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 100 ) ) ; verifyZeroInteractions ( nakMessageSender ) ; } @ Test public void shouldHandleMoreThan2Gaps ( ) { long rebuildPosition = ACTIVE_TERM_POSITION ; final long hwmPosition = ACTIVE_TERM_POSITION + ( ALIGNED_FRAME_LENGTH * 7 ) ; insertDataFrame ( offsetOfMessage ( 0 ) ) ; insertDataFrame ( offsetOfMessage ( 2 ) ) ; insertDataFrame ( offsetOfMessage ( 4 ) ) ; insertDataFrame ( offsetOfMessage ( 6 ) ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 40 ) ) ; insertDataFrame ( offsetOfMessage ( 1 ) ) ; rebuildPosition += ( 3 * ALIGNED_FRAME_LENGTH ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 80 ) ) ; final InOrder inOrder = inOrder ( nakMessageSender ) ; inOrder . verify ( nakMessageSender , atLeast ( 1 ) ) . onLossDetected ( TERM_ID , offsetOfMessage ( 1 ) , gapLength ( ) ) ; inOrder . verify ( nakMessageSender , atLeast ( 1 ) ) . onLossDetected ( TERM_ID , offsetOfMessage ( 3 ) , gapLength ( ) ) ; inOrder . verify ( nakMessageSender , never ( ) ) . onLossDetected ( TERM_ID , offsetOfMessage ( 5 ) , gapLength ( ) ) ; } @ Test public void shouldReplaceOldNakWithNewNak ( ) { long rebuildPosition = ACTIVE_TERM_POSITION ; long hwmPosition = ACTIVE_TERM_POSITION + ( ALIGNED_FRAME_LENGTH * 3 ) ; insertDataFrame ( offsetOfMessage ( 0 ) ) ; insertDataFrame ( offsetOfMessage ( 2 ) ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 20 ) ) ; insertDataFrame ( offsetOfMessage ( 4 ) ) ; insertDataFrame ( offsetOfMessage ( 1 ) ) ; rebuildPosition += ( ALIGNED_FRAME_LENGTH * 3 ) ; hwmPosition = ( ALIGNED_FRAME_LENGTH * 5 ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; processTimersUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= TimeUnit . MILLISECONDS . toNanos ( 100 ) ) ; verify ( nakMessageSender , atLeast ( 1 ) ) . onLossDetected ( TERM_ID , offsetOfMessage ( 3 ) , gapLength ( ) ) ; } @ Test public void shouldHandleImmediateNak ( ) { handler = getLossHandlerWithImmediate ( ) ; final long rebuildPosition = ACTIVE_TERM_POSITION ; final long hwmPosition = ACTIVE_TERM_POSITION + ( ALIGNED_FRAME_LENGTH * 3 ) ; insertDataFrame ( offsetOfMessage ( 0 ) ) ; insertDataFrame ( offsetOfMessage ( 2 ) ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; verify ( nakMessageSender ) . onLossDetected ( TERM_ID , offsetOfMessage ( 1 ) , gapLength ( ) ) ; } @ Test public void shouldNotNakImmediatelyByDefault ( ) { final long rebuildPosition = ACTIVE_TERM_POSITION ; final long hwmPosition = ACTIVE_TERM_POSITION + ( ALIGNED_FRAME_LENGTH * 3 ) ; insertDataFrame ( offsetOfMessage ( 0 ) ) ; insertDataFrame ( offsetOfMessage ( 2 ) ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; verifyZeroInteractions ( nakMessageSender ) ; } @ Test public void shouldOnlySendNaksOnceOnMultipleScans ( ) { handler = getLossHandlerWithImmediate ( ) ; final long rebuildPosition = ACTIVE_TERM_POSITION ; final long hwmPosition = ACTIVE_TERM_POSITION + ( ALIGNED_FRAME_LENGTH * 3 ) ; insertDataFrame ( offsetOfMessage ( 0 ) ) ; insertDataFrame ( offsetOfMessage ( 2 ) ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; verify ( nakMessageSender ) . onLossDetected ( TERM_ID , offsetOfMessage ( 1 ) , gapLength ( ) ) ; } @ Test public void shouldHandleHwmGreaterThanCompletedBuffer ( ) { handler = getLossHandlerWithImmediate ( ) ; long rebuildPosition = ACTIVE_TERM_POSITION ; final long hwmPosition = ACTIVE_TERM_POSITION + TERM_BUFFER_LENGTH + ALIGNED_FRAME_LENGTH ; insertDataFrame ( offsetOfMessage ( 0 ) ) ; rebuildPosition += ALIGNED_FRAME_LENGTH ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; verify ( nakMessageSender ) . onLossDetected ( TERM_ID , offsetOfMessage ( 1 ) , TERM_BUFFER_LENGTH - ( int ) rebuildPosition ) ; } @ Test public void shouldHandleNonZeroInitialTermOffset ( ) { handler = getLossHandlerWithImmediate ( ) ; final long rebuildPosition = ACTIVE_TERM_POSITION + ( ALIGNED_FRAME_LENGTH * 3 ) ; final long hwmPosition = ACTIVE_TERM_POSITION + ( ALIGNED_FRAME_LENGTH * 5 ) ; insertDataFrame ( offsetOfMessage ( 2 ) ) ; insertDataFrame ( offsetOfMessage ( 4 ) ) ; handler . scan ( termBuffer , rebuildPosition , hwmPosition , MASK , POSITION_BITS_TO_SHIFT , TERM_ID ) ; verify ( nakMessageSender ) . onLossDetected ( TERM_ID , offsetOfMessage ( 3 ) , gapLength ( ) ) ; verifyNoMoreInteractions ( nakMessageSender ) ; } private LossDetector getLossHandlerWithImmediate ( ) { return new LossDetector ( wheel , DELAY_GENERATOR_WITH_IMMEDIATE , nakMessageSender ) ; } private void insertDataFrame ( final int offset ) { insertDataFrame ( offset , DATA ) ; } private void insertDataFrame ( final int offset , final byte [ ] payload ) { dataHeader . termId ( TERM_ID ) . streamId ( STREAM_ID ) . sessionId ( SESSION_ID ) . termOffset ( offset ) . frameLength ( payload . length + DataHeaderFlyweight . HEADER_LENGTH ) . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) . flags ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) . version ( HeaderFlyweight . CURRENT_VERSION ) ; dataHeader . buffer ( ) . putBytes ( dataHeader . dataOffset ( ) , payload ) ; TermRebuilder . insert ( termBuffer , offset , rcvBuffer , payload . length + DataHeaderFlyweight . HEADER_LENGTH ) ; } private int offsetOfMessage ( final int index ) { return index * ALIGNED_FRAME_LENGTH ; } private int gapLength ( ) { return ALIGNED_FRAME_LENGTH ; } private long processTimersUntil ( final BooleanSupplier condition ) { final long startTime = wheel . clock ( ) . nanoTime ( ) ; while ( ! condition . getAsBoolean ( ) ) { if ( wheel . computeDelayInMs ( ) > 0 ) { currentTime += TimeUnit . MICROSECONDS . toNanos ( Configuration . CONDUCTOR_TICK_DURATION_US ) ; } wheel . expireTimers ( ) ; } return wheel . clock ( ) . nanoTime ( ) - startTime ; } }
package uk . co . real_logic . aeron . driver ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . mockito . ArgumentCaptor ; import org . mockito . stubbing . Answer ; import uk . co . real_logic . aeron . command . * ; import uk . co . real_logic . aeron . driver . buffer . RawLogFactory ; import uk . co . real_logic . aeron . driver . event . EventConfiguration ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; import uk . co . real_logic . aeron . driver . media . TransportPoller ; import uk . co . real_logic . aeron . driver . media . UdpChannel ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . concurrent . * ; import uk . co . real_logic . agrona . concurrent . ringbuffer . ManyToOneRingBuffer ; import uk . co . real_logic . agrona . concurrent . ringbuffer . RingBuffer ; import uk . co . real_logic . agrona . concurrent . ringbuffer . RingBufferDescriptor ; import java . nio . ByteBuffer ; import java . util . concurrent . TimeUnit ; import java . util . function . BooleanSupplier ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import static org . mockito . Mockito . any ; import static org . mockito . Mockito . * ; import static uk . co . real_logic . aeron . ErrorCode . INVALID_CHANNEL ; import static uk . co . real_logic . aeron . ErrorCode . UNKNOWN_PUBLICATION ; import static uk . co . real_logic . aeron . command . ControlProtocolEvents . * ; import static uk . co . real_logic . aeron . driver . Configuration . * ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . TERM_META_DATA_LENGTH ; public class DriverConductorTest { private static final String CHANNEL_URI = "udp://localhost:" ; private static final String INVALID_URI = "udp://" ; private static final int STREAM_ID_1 = 10 ; private static final int STREAM_ID_2 = 20 ; private static final int STREAM_ID_3 = 30 ; private static final int TERM_BUFFER_SZ = Configuration . TERM_BUFFER_LENGTH_DEFAULT ; private static final long CORRELATION_ID_1 = 1429 ; private static final long CORRELATION_ID_2 = 1430 ; private static final long CORRELATION_ID_3 = 1431 ; private static final long CORRELATION_ID_4 = 1432 ; private static final long CLIENT_ID = 1433 ; private static final int BUFFER_LENGTH = 1024 * 1024 ; private final ByteBuffer toDriverBuffer = ByteBuffer . allocateDirect ( Configuration . CONDUCTOR_BUFFER_LENGTH ) ; private final ByteBuffer toEventBuffer = ByteBuffer . allocateDirect ( EventConfiguration . BUFFER_LENGTH_DEFAULT + RingBufferDescriptor . TRAILER_LENGTH ) ; private final TransportPoller transportPoller = mock ( TransportPoller . class ) ; private final RawLogFactory mockRawLogFactory = mock ( RawLogFactory . class ) ; private final RingBuffer fromClientCommands = new ManyToOneRingBuffer ( new UnsafeBuffer ( toDriverBuffer ) ) ; private final RingBuffer toEventReader = new ManyToOneRingBuffer ( new UnsafeBuffer ( toEventBuffer ) ) ; private final ClientProxy mockClientProxy = mock ( ClientProxy . class ) ; private final PublicationMessageFlyweight publicationMessage = new PublicationMessageFlyweight ( ) ; private final SubscriptionMessageFlyweight subscriptionMessage = new SubscriptionMessageFlyweight ( ) ; private final RemoveMessageFlyweight removeMessage = new RemoveMessageFlyweight ( ) ; private final CorrelatedMessageFlyweight correlatedMessage = new CorrelatedMessageFlyweight ( ) ; private final UnsafeBuffer writeBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( 256 ) ) ; private final EventLogger mockConductorLogger = mock ( EventLogger . class ) ; private final SenderProxy senderProxy = mock ( SenderProxy . class ) ; private final ReceiverProxy receiverProxy = mock ( ReceiverProxy . class ) ; private final DriverConductorProxy fromSenderConductorProxy = mock ( DriverConductorProxy . class ) ; private final DriverConductorProxy fromReceiverConductorProxy = mock ( DriverConductorProxy . class ) ; private long currentTime ; private final TimerWheel wheel = new TimerWheel ( ( ) - > currentTime , CONDUCTOR_TICK_DURATION_US , TimeUnit . MICROSECONDS , CONDUCTOR_TICKS_PER_WHEEL ) ; private DriverConductor driverConductor ; private final Answer < Void > closeChannelEndpointAnswer = ( invocation ) - > { final Object args [ ] = invocation . getArguments ( ) ; final ReceiveChannelEndpoint channelEndpoint = ( ReceiveChannelEndpoint ) args [ 0 ] ; channelEndpoint . close ( ) ; return null ; } ; @ Before public void setUp ( ) throws Exception { when ( mockRawLogFactory . newPublication ( anyObject ( ) , anyInt ( ) , anyInt ( ) , anyInt ( ) ) ) . thenReturn ( LogBufferHelper . newTestLogBuffers ( TERM_BUFFER_SZ , TERM_META_DATA_LENGTH ) ) ; currentTime = 0 ; final UnsafeBuffer counterBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( BUFFER_LENGTH ) ) ; final CountersManager countersManager = new CountersManager ( new UnsafeBuffer ( ByteBuffer . allocateDirect ( BUFFER_LENGTH ) ) , counterBuffer ) ; final MediaDriver . Context ctx = new MediaDriver . Context ( ) . receiverNioSelector ( transportPoller ) . senderNioSelector ( transportPoller ) . unicastSenderFlowControl ( UnicastFlowControl : : new ) . multicastSenderFlowControl ( MaxMulticastFlowControl : : new ) . conductorTimerWheel ( wheel ) . toConductorFromReceiverCommandQueue ( new OneToOneConcurrentArrayQueue < > ( 1024 ) ) . toConductorFromSenderCommandQueue ( new OneToOneConcurrentArrayQueue < > ( 1024 ) ) . eventLogger ( mockConductorLogger ) . rawLogBuffersFactory ( mockRawLogFactory ) . countersManager ( countersManager ) ; ctx . toEventReader ( toEventReader ) ; ctx . toDriverCommands ( fromClientCommands ) ; ctx . clientProxy ( mockClientProxy ) ; ctx . countersBuffer ( counterBuffer ) ; final SystemCounters mockSystemCounters = mock ( SystemCounters . class ) ; ctx . systemCounters ( mockSystemCounters ) ; when ( mockSystemCounters . bytesReceived ( ) ) . thenReturn ( mock ( AtomicCounter . class ) ) ; when ( mockSystemCounters . clientKeepAlives ( ) ) . thenReturn ( mock ( AtomicCounter . class ) ) ; ctx . epochClock ( new SystemEpochClock ( ) ) ; ctx . receiverProxy ( receiverProxy ) ; ctx . senderProxy ( senderProxy ) ; ctx . fromReceiverDriverConductorProxy ( fromReceiverConductorProxy ) ; ctx . fromSenderDriverConductorProxy ( fromSenderConductorProxy ) ; driverConductor = new DriverConductor ( ctx ) ; doAnswer ( closeChannelEndpointAnswer ) . when ( receiverProxy ) . closeReceiveChannelEndpoint ( any ( ) ) ; } @ After public void tearDown ( ) throws Exception { driverConductor . onClose ( ) ; } @ Test public void shouldBeAbleToAddSinglePublication ( ) throws Exception { writePublicationMessage ( ADD_PUBLICATION , 1 , 2 , 4000 , CORRELATION_ID_1 ) ; driverConductor . doWork ( ) ; final ArgumentCaptor < NetworkPublication > captor = ArgumentCaptor . forClass ( NetworkPublication . class ) ; verify ( senderProxy , times ( 1 ) ) . newPublication ( captor . capture ( ) , any ( ) , any ( ) ) ; final NetworkPublication publication = captor . getValue ( ) ; assertThat ( publication . sessionId ( ) , is ( 1 ) ) ; assertThat ( publication . streamId ( ) , is ( 2 ) ) ; verify ( mockClientProxy ) . onPublicationReady ( eq ( 2 ) , anyInt ( ) , any ( ) , anyLong ( ) , anyInt ( ) ) ; } @ Test public void shouldBeAbleToAddSingleSubscription ( ) throws Exception { writeSubscriptionMessage ( ControlProtocolEvents . ADD_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_1 , CORRELATION_ID_1 ) ; driverConductor . doWork ( ) ; verify ( mockClientProxy ) . operationSucceeded ( CORRELATION_ID_1 ) ; assertNotNull ( driverConductor . receiverChannelEndpoint ( UdpChannel . parse ( CHANNEL_URI + 4000 ) ) ) ; } @ Test public void shouldBeAbleToAddAndRemoveSingleSubscription ( ) throws Exception { writeSubscriptionMessage ( ControlProtocolEvents . ADD_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_1 , CORRELATION_ID_1 ) ; writeSubscriptionMessage ( ControlProtocolEvents . REMOVE_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_1 , CORRELATION_ID_1 ) ; driverConductor . doWork ( ) ; assertNull ( driverConductor . receiverChannelEndpoint ( UdpChannel . parse ( CHANNEL_URI + 4000 ) ) ) ; } @ Test public void shouldBeAbleToAddMultipleStreams ( ) throws Exception { writePublicationMessage ( ADD_PUBLICATION , 1 , 2 , 4001 , CORRELATION_ID_1 ) ; writePublicationMessage ( ADD_PUBLICATION , 1 , 3 , 4002 , CORRELATION_ID_2 ) ; writePublicationMessage ( ADD_PUBLICATION , 3 , 2 , 4003 , CORRELATION_ID_3 ) ; writePublicationMessage ( ADD_PUBLICATION , 3 , 4 , 4004 , CORRELATION_ID_4 ) ; driverConductor . doWork ( ) ; verify ( senderProxy , times ( 4 ) ) . newPublication ( any ( ) , any ( ) , any ( ) ) ; } @ Test public void shouldBeAbleToRemoveSingleStream ( ) throws Exception { writePublicationMessage ( ADD_PUBLICATION , 1 , 2 , 4005 , CORRELATION_ID_1 ) ; writePublicationMessage ( REMOVE_PUBLICATION , 1 , 2 , 4005 , CORRELATION_ID_1 ) ; driverConductor . doWork ( ) ; doWorkUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= CLIENT_LIVENESS_TIMEOUT_NS + PUBLICATION_LINGER_NS * 2 ) ; verify ( senderProxy ) . removePublication ( any ( ) ) ; assertNull ( driverConductor . senderChannelEndpoint ( UdpChannel . parse ( CHANNEL_URI + 4005 ) ) ) ; } @ Test public void shouldBeAbleToRemoveMultipleStreams ( ) throws Exception { writePublicationMessage ( ADD_PUBLICATION , 1 , 2 , 4006 , CORRELATION_ID_1 ) ; writePublicationMessage ( ADD_PUBLICATION , 1 , 3 , 4007 , CORRELATION_ID_2 ) ; writePublicationMessage ( ADD_PUBLICATION , 3 , 2 , 4008 , CORRELATION_ID_3 ) ; writePublicationMessage ( ADD_PUBLICATION , 3 , 4 , 4008 , CORRELATION_ID_4 ) ; removePublicationMessage ( CORRELATION_ID_1 ) ; removePublicationMessage ( CORRELATION_ID_2 ) ; removePublicationMessage ( CORRELATION_ID_3 ) ; removePublicationMessage ( CORRELATION_ID_4 ) ; driverConductor . doWork ( ) ; doWorkUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= PUBLICATION_LINGER_NS * 2 + CLIENT_LIVENESS_TIMEOUT_NS * 2 ) ; verify ( senderProxy , times ( 4 ) ) . removePublication ( any ( ) ) ; } private void removePublicationMessage ( final long registrationId ) { removeMessage . wrap ( writeBuffer , 0 ) ; removeMessage . registrationId ( registrationId ) ; assertTrue ( fromClientCommands . write ( REMOVE_PUBLICATION , writeBuffer , 0 , RemoveMessageFlyweight . length ( ) ) ) ; } @ Test public void shouldKeepSubscriptionMediaEndpointUponRemovalOfAllButOneSubscriber ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( CHANNEL_URI + 4000 ) ; writeSubscriptionMessage ( ControlProtocolEvents . ADD_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_1 , CORRELATION_ID_1 ) ; writeSubscriptionMessage ( ControlProtocolEvents . ADD_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_2 , CORRELATION_ID_2 ) ; writeSubscriptionMessage ( ControlProtocolEvents . ADD_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_3 , CORRELATION_ID_3 ) ; driverConductor . doWork ( ) ; final ReceiveChannelEndpoint channelEndpoint = driverConductor . receiverChannelEndpoint ( udpChannel ) ; assertNotNull ( channelEndpoint ) ; assertThat ( channelEndpoint . streamCount ( ) , is ( 3 ) ) ; writeSubscriptionMessage ( ControlProtocolEvents . REMOVE_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_1 , CORRELATION_ID_1 ) ; writeSubscriptionMessage ( ControlProtocolEvents . REMOVE_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_2 , CORRELATION_ID_2 ) ; driverConductor . doWork ( ) ; assertNotNull ( driverConductor . receiverChannelEndpoint ( udpChannel ) ) ; assertThat ( channelEndpoint . streamCount ( ) , is ( 1 ) ) ; } @ Test public void shouldOnlyRemoveSubscriptionMediaEndpointUponRemovalOfAllSubscribers ( ) throws Exception { final UdpChannel udpChannel = UdpChannel . parse ( CHANNEL_URI + 4000 ) ; writeSubscriptionMessage ( ControlProtocolEvents . ADD_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_1 , CORRELATION_ID_1 ) ; writeSubscriptionMessage ( ControlProtocolEvents . ADD_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_2 , CORRELATION_ID_2 ) ; writeSubscriptionMessage ( ControlProtocolEvents . ADD_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_3 , CORRELATION_ID_3 ) ; driverConductor . doWork ( ) ; final ReceiveChannelEndpoint channelEndpoint = driverConductor . receiverChannelEndpoint ( udpChannel ) ; assertNotNull ( channelEndpoint ) ; assertThat ( channelEndpoint . streamCount ( ) , is ( 3 ) ) ; writeSubscriptionMessage ( ControlProtocolEvents . REMOVE_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_2 , CORRELATION_ID_2 ) ; writeSubscriptionMessage ( ControlProtocolEvents . REMOVE_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_3 , CORRELATION_ID_3 ) ; driverConductor . doWork ( ) ; assertNotNull ( driverConductor . receiverChannelEndpoint ( udpChannel ) ) ; assertThat ( channelEndpoint . streamCount ( ) , is ( 1 ) ) ; writeSubscriptionMessage ( ControlProtocolEvents . REMOVE_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_1 , CORRELATION_ID_1 ) ; driverConductor . doWork ( ) ; assertNull ( driverConductor . receiverChannelEndpoint ( udpChannel ) ) ; } @ Test public void shouldErrorOnRemoveChannelOnUnknownSessionId ( ) throws Exception { writePublicationMessage ( ADD_PUBLICATION , 1 , 2 , 4000 , CORRELATION_ID_1 ) ; writePublicationMessage ( REMOVE_PUBLICATION , 2 , 2 , 4000 , CORRELATION_ID_1 ) ; driverConductor . doWork ( ) ; verify ( senderProxy ) . newPublication ( any ( ) , any ( ) , any ( ) ) ; verify ( mockClientProxy ) . onError ( eq ( UNKNOWN_PUBLICATION ) , argThat ( not ( isEmptyOrNullString ( ) ) ) , any ( ) , anyInt ( ) ) ; verify ( mockClientProxy , never ( ) ) . operationSucceeded ( anyLong ( ) ) ; verify ( mockConductorLogger ) . logException ( any ( ) ) ; } @ Test public void shouldErrorOnRemoveChannelOnUnknownStreamId ( ) throws Exception { writePublicationMessage ( ADD_PUBLICATION , 1 , 2 , 4000 , CORRELATION_ID_1 ) ; writePublicationMessage ( REMOVE_PUBLICATION , 1 , 3 , 4000 , CORRELATION_ID_1 ) ; driverConductor . doWork ( ) ; verify ( senderProxy ) . newPublication ( any ( ) , any ( ) , any ( ) ) ; verify ( senderProxy , never ( ) ) . removePublication ( any ( ) ) ; verify ( mockClientProxy ) . onError ( eq ( UNKNOWN_PUBLICATION ) , argThat ( not ( isEmptyOrNullString ( ) ) ) , any ( ) , anyInt ( ) ) ; verify ( mockClientProxy , never ( ) ) . operationSucceeded ( anyLong ( ) ) ; verify ( mockConductorLogger ) . logException ( any ( ) ) ; } @ Test public void shouldErrorOnAddSubscriptionWithInvalidUri ( ) throws Exception { writeSubscriptionMessage ( ADD_SUBSCRIPTION , INVALID_URI , STREAM_ID_1 , CORRELATION_ID_1 ) ; driverConductor . doWork ( ) ; driverConductor . doWork ( ) ; verify ( senderProxy , never ( ) ) . newPublication ( any ( ) , any ( ) , any ( ) ) ; verify ( mockClientProxy ) . onError ( eq ( INVALID_CHANNEL ) , argThat ( not ( isEmptyOrNullString ( ) ) ) , any ( ) , anyInt ( ) ) ; verify ( mockClientProxy , never ( ) ) . operationSucceeded ( anyLong ( ) ) ; verify ( mockConductorLogger ) . logException ( any ( ) ) ; } @ Test public void shouldTimeoutPublication ( ) throws Exception { writePublicationMessage ( ADD_PUBLICATION , 1 , 2 , 4000 , CORRELATION_ID_1 ) ; driverConductor . doWork ( ) ; final ArgumentCaptor < NetworkPublication > captor = ArgumentCaptor . forClass ( NetworkPublication . class ) ; verify ( senderProxy , times ( 1 ) ) . newPublication ( captor . capture ( ) , any ( ) , any ( ) ) ; final NetworkPublication publication = captor . getValue ( ) ; doWorkUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= PUBLICATION_LINGER_NS + CLIENT_LIVENESS_TIMEOUT_NS * 2 ) ; verify ( senderProxy ) . removePublication ( eq ( publication ) ) ; assertNull ( driverConductor . senderChannelEndpoint ( UdpChannel . parse ( CHANNEL_URI + 4000 ) ) ) ; } @ Test public void shouldNotTimeoutPublicationOnKeepAlive ( ) throws Exception { writePublicationMessage ( ADD_PUBLICATION , 1 , 2 , 4000 , CORRELATION_ID_1 ) ; driverConductor . doWork ( ) ; final ArgumentCaptor < NetworkPublication > captor = ArgumentCaptor . forClass ( NetworkPublication . class ) ; verify ( senderProxy , times ( 1 ) ) . newPublication ( captor . capture ( ) , any ( ) , any ( ) ) ; final NetworkPublication publication = captor . getValue ( ) ; doWorkUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= CLIENT_LIVENESS_TIMEOUT_NS / 2 ) ; writeKeepaliveClientMessage ( ) ; doWorkUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= CLIENT_LIVENESS_TIMEOUT_NS + 1000 ) ; writeKeepaliveClientMessage ( ) ; doWorkUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= CLIENT_LIVENESS_TIMEOUT_NS * 2 ) ; verify ( senderProxy , never ( ) ) . removePublication ( eq ( publication ) ) ; } @ Test public void shouldTimeoutSubscription ( ) throws Exception { writeSubscriptionMessage ( ControlProtocolEvents . ADD_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_1 , CORRELATION_ID_1 ) ; driverConductor . doWork ( ) ; final ReceiveChannelEndpoint receiveChannelEndpoint = driverConductor . receiverChannelEndpoint ( UdpChannel . parse ( CHANNEL_URI + 4000 ) ) ; assertNotNull ( receiveChannelEndpoint ) ; verify ( receiverProxy ) . addSubscription ( eq ( receiveChannelEndpoint ) , eq ( STREAM_ID_1 ) ) ; doWorkUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= CLIENT_LIVENESS_TIMEOUT_NS * 2 ) ; verify ( receiverProxy , times ( 1 ) ) . removeSubscription ( eq ( receiveChannelEndpoint ) , eq ( STREAM_ID_1 ) ) ; assertNull ( driverConductor . receiverChannelEndpoint ( UdpChannel . parse ( CHANNEL_URI + 4000 ) ) ) ; } @ Test public void shouldNotTimeoutSubscriptionOnKeepAlive ( ) throws Exception { writeSubscriptionMessage ( ControlProtocolEvents . ADD_SUBSCRIPTION , CHANNEL_URI + 4000 , STREAM_ID_1 , CORRELATION_ID_1 ) ; driverConductor . doWork ( ) ; final ReceiveChannelEndpoint receiveChannelEndpoint = driverConductor . receiverChannelEndpoint ( UdpChannel . parse ( CHANNEL_URI + 4000 ) ) ; assertNotNull ( receiveChannelEndpoint ) ; verify ( receiverProxy ) . addSubscription ( eq ( receiveChannelEndpoint ) , eq ( STREAM_ID_1 ) ) ; doWorkUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= CLIENT_LIVENESS_TIMEOUT_NS ) ; writeKeepaliveClientMessage ( ) ; doWorkUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= CLIENT_LIVENESS_TIMEOUT_NS + 1000 ) ; writeKeepaliveClientMessage ( ) ; doWorkUntil ( ( ) - > wheel . clock ( ) . nanoTime ( ) >= CLIENT_LIVENESS_TIMEOUT_NS * 2 ) ; verify ( receiverProxy , never ( ) ) . removeSubscription ( any ( ) , anyInt ( ) ) ; assertNotNull ( driverConductor . receiverChannelEndpoint ( UdpChannel . parse ( CHANNEL_URI + 4000 ) ) ) ; } private void writePublicationMessage ( final int msgTypeId , final int sessionId , final int streamId , final int port , final long correlationId ) { publicationMessage . wrap ( writeBuffer , 0 ) ; publicationMessage . streamId ( streamId ) ; publicationMessage . sessionId ( sessionId ) ; publicationMessage . channel ( CHANNEL_URI + port ) ; publicationMessage . clientId ( CLIENT_ID ) ; publicationMessage . correlationId ( correlationId ) ; fromClientCommands . write ( msgTypeId , writeBuffer , 0 , publicationMessage . length ( ) ) ; } private void writeSubscriptionMessage ( final int msgTypeId , final String channel , final int streamId , final long registrationCorrelationId ) { subscriptionMessage . wrap ( writeBuffer , 0 ) ; subscriptionMessage . streamId ( streamId ) . channel ( channel ) . registrationCorrelationId ( registrationCorrelationId ) . correlationId ( registrationCorrelationId ) . clientId ( CLIENT_ID ) ; fromClientCommands . write ( msgTypeId , writeBuffer , 0 , subscriptionMessage . length ( ) ) ; } private void writeKeepaliveClientMessage ( ) { correlatedMessage . wrap ( writeBuffer , 0 ) ; correlatedMessage . clientId ( CLIENT_ID ) ; correlatedMessage . correlationId ( 0 ) ; fromClientCommands . write ( ControlProtocolEvents . CLIENT_KEEPALIVE , writeBuffer , 0 , CorrelatedMessageFlyweight . LENGTH ) ; } private long doWorkUntil ( final BooleanSupplier condition ) throws Exception { final long startTime = wheel . clock ( ) . nanoTime ( ) ; while ( ! condition . getAsBoolean ( ) ) { if ( wheel . computeDelayInMs ( ) > 0 ) { currentTime += TimeUnit . MICROSECONDS . toNanos ( Configuration . CONDUCTOR_TICK_DURATION_US ) ; } driverConductor . doWork ( ) ; } return wheel . clock ( ) . nanoTime ( ) - startTime ; } }
package uk . co . real_logic . aeron . driver . uri ; import org . junit . Test ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . CoreMatchers . nullValue ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . fail ; public class AeronUriTest { @ Test public void shouldParseSimpleDefaultUri ( ) { assertParseWithMedia ( "aeron:udp" , "udp" ) ; assertParseWithMedia ( "aeron:ipc" , "ipc" ) ; assertParseWithMedia ( "aeron:" , "" ) ; } @ Test public void shouldRejectUriWithoutAeronPrefix ( ) { assertInvalid ( ":udp" ) ; assertInvalid ( "aeron" ) ; assertInvalid ( "aron:" ) ; assertInvalid ( "eeron:" ) ; } @ Test public void shouldRejectWithOutOfPlaceColon ( ) throws Exception { assertInvalid ( "aeron:udp:" ) ; } @ Test public void shouldParseWithSingleParameter ( ) throws Exception { assertParseWithParams ( "aeron:udp?address=224.10.9.8" , "address" , "224.10.9.8" ) ; assertParseWithParams ( "aeron:udp?add|ress=224.10.9.8" , "add|ress" , "224.10.9.8" ) ; assertParseWithParams ( "aeron:udp?address=224.1=0.9.8" , "address" , "224.1=0.9.8" ) ; } @ Test public void shouldParseWithMultipleParameters ( ) throws Exception { assertParseWithParams ( "aeron:udp?address=224.10.9.8|port=4567|interface=192.168.0.3" , "address" , "224.10.9.8" , "port" , "4567" , "interface" , "192.168.0.3" ) ; } @ Test public void shouldAllowReturnDefaultIfParamNotSpecified ( ) throws Exception { final AeronUri uri = AeronUri . parse ( "aeron:udp?address=224.10.9.8" ) ; assertThat ( uri . get ( "interface" ) , is ( nullValue ( ) ) ) ; assertThat ( uri . get ( "interface" , "192.168.0.0" ) , is ( "192.168.0.0" ) ) ; } private void assertParseWithParams ( String uriStr , String ... params ) { if ( params . length % 2 != 0 ) { throw new IllegalArgumentException ( ) ; } final AeronUri uri = AeronUri . parse ( uriStr ) ; for ( int i = 0 ; i < params . length ; i += 2 ) { assertThat ( uri . get ( params [ i ] ) , is ( params [ i + 1 ] ) ) ; } } private void assertParseWithMedia ( String uriStr , String media ) { final AeronUri uri = AeronUri . parse ( uriStr ) ; assertThat ( uri . getScheme ( ) , is ( "aeron" ) ) ; assertThat ( uri . getMedia ( ) , is ( media ) ) ; } private static void assertInvalid ( String string ) { try { AeronUri . parse ( string ) ; fail ( IllegalArgumentException . class . getName ( ) + " not thrown" ) ; } catch ( final IllegalArgumentException ignore ) { } } }
package uk . co . real_logic . aeron . driver . uri ; import org . junit . Test ; import java . net . Inet6Address ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . UnknownHostException ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertThat ; public class SocketAddressUtilTest { @ Test public void shouldParseIpV4AddressAndPort ( ) throws Exception { assertCorrectParse ( "192.168.1.20" , 55 ) ; } @ Test public void shouldParseHostAddressAndPort ( ) throws Exception { assertCorrectParse ( "localhost" , 55 ) ; } @ Test ( expected = IllegalArgumentException . class ) public void shouldRejectOnInvalidPort ( ) throws Exception { SocketAddressUtil . parse ( "192.168.1.20:aa" ) ; } @ Test ( expected = IllegalArgumentException . class ) public void shouldRejectOnMissingPort ( ) throws Exception { SocketAddressUtil . parse ( "192.168.1.20" ) ; } @ Test ( expected = IllegalArgumentException . class ) public void shouldRejectOnEmptyPort ( ) throws Exception { SocketAddressUtil . parse ( "192.168.1.20:" ) ; } @ Test public void shouldParseIpV6 ( ) throws Exception { assertCorrectParseIpV6 ( "::1" , 54321 ) ; } @ Test public void shouldParseWithScope ( ) throws Exception { final InetSocketAddress address = SocketAddressUtil . parse ( "[::1%12~_.-34]:1234" ) ; assertThat ( address . getAddress ( ) , instanceOf ( Inet6Address . class ) ) ; } private void assertCorrectParse ( final String host , final int port ) throws UnknownHostException { final InetSocketAddress address = SocketAddressUtil . parse ( host + ":" + port ) ; assertThat ( address . getAddress ( ) , is ( InetAddress . getByName ( host ) ) ) ; assertThat ( address . getPort ( ) , is ( port ) ) ; } private void assertCorrectParseIpV6 ( final String host , final int port ) throws UnknownHostException { final InetSocketAddress address = SocketAddressUtil . parse ( "[" + host + "]:" + port ) ; assertThat ( address . getAddress ( ) , is ( InetAddress . getByName ( host ) ) ) ; assertThat ( address . getPort ( ) , is ( port ) ) ; } }
package uk . co . real_logic . aeron . tools ; import org . apache . commons . cli . ParseException ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . InactiveConnectionHandler ; import uk . co . real_logic . aeron . NewConnectionHandler ; import uk . co . real_logic . aeron . Publication ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . aeron . exceptions . DriverTimeoutException ; import uk . co . real_logic . aeron . tools . SeedableThreadLocalRandom . SeedCallback ; import uk . co . real_logic . agrona . concurrent . SigInt ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . logging . Logger ; public class PublisherTool implements SeedCallback , RateReporter . Stats , RateReporter . Callback { static { if ( System . getProperty ( "java.util.logging.SimpleFormatter.format" ) == null ) { System . setProperty ( "java.util.logging.SimpleFormatter.format" , "%5$s%n" ) ; } } public static final String APP_USAGE = "PublisherTool" ; private static final Logger LOG = Logger . getLogger ( PublisherTool . class . getName ( ) ) ; private final PubSubOptions options ; private final Thread [ ] pubThreads ; private final PublisherThread [ ] publishers ; private final int numThreads ; private boolean shuttingDown ; private void sanityCheckOptions ( ) throws Exception { if ( options . threads ( ) > 1 ) { if ( options . input ( ) != null ) { LOG . warning ( "File data may be sent in a non-deterministic order when multiple publisher threads are used." ) ; } } if ( options . verify ( ) ) { if ( options . messageSizePattern ( ) . minimum ( ) < 16 ) { throw new Exception ( "Minimum message size must be at least 16 bytes when using verifiable messages." ) ; } } if ( options . messageSizePattern ( ) . minimum ( ) < 1 ) { throw new Exception ( "Minimum message size must be at least 1 byte, as Aeron does not currently support 0-length messages." ) ; } } public PublisherTool ( final PubSubOptions options ) { this . options = options ; try { sanityCheckOptions ( ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } SeedableThreadLocalRandom . setSeedCallback ( this ) ; SigInt . register ( ( ) - > shuttingDown = true ) ; MediaDriver driver = null ; if ( options . useEmbeddedDriver ( ) ) { driver = MediaDriver . launch ( ) ; } numThreads = Math . min ( options . threads ( ) , options . numberOfStreams ( ) ) ; if ( numThreads < options . threads ( ) ) { LOG . warning ( options . threads ( ) + " threads were requested, but only " + options . numberOfStreams ( ) + " channel(s) were specified; using " + numThreads + " thread(s) instead." ) ; } pubThreads = new Thread [ numThreads ] ; publishers = new PublisherThread [ numThreads ] ; final long messagesPerThread = options . messages ( ) / numThreads ; long leftoverMessages = options . messages ( ) - ( messagesPerThread * numThreads ) ; for ( int i = 0 ; i < numThreads ; i ++ ) { publishers [ i ] = new PublisherThread ( i , messagesPerThread + ( ( leftoverMessages -- > 0 ) ? 1 : 0 ) ) ; pubThreads [ i ] = new Thread ( publishers [ i ] ) ; pubThreads [ i ] . start ( ) ; } final RateReporter rateReporter = new RateReporter ( this , this ) ; try { for ( int i = 0 ; i < pubThreads . length ; i ++ ) { pubThreads [ i ] . join ( ) ; } rateReporter . close ( ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } if ( options . useEmbeddedDriver ( ) ) { driver . close ( ) ; } try { options . close ( ) ; } catch ( final IOException e ) { e . printStackTrace ( ) ; } final long verifiableMessages = verifiableMessages ( ) ; final long nonVerifiableMessages = nonVerifiableMessages ( ) ; final long bytesSent = bytes ( ) ; LOG . info ( String . format ( "Exiting. Sent %d messages (%d bytes) total. %d verifiable and %d non-verifiable." , verifiableMessages + nonVerifiableMessages , bytesSent , verifiableMessages , nonVerifiableMessages ) ) ; } public static void main ( final String [ ] args ) { final PubSubOptions opts = new PubSubOptions ( ) ; try { if ( opts . parseArgs ( args ) != 0 ) { opts . printHelp ( PublisherTool . APP_USAGE ) ; System . exit ( 0 ) ; } } catch ( final ParseException ex ) { ex . printStackTrace ( ) ; opts . printHelp ( PublisherTool . APP_USAGE ) ; System . exit ( - 1 ) ; } @ SuppressWarnings ( "unused" ) final PublisherTool app = new PublisherTool ( opts ) ; } public long setSeed ( long seed ) { if ( options . randomSeed ( ) != 0 ) { seed = options . randomSeed ( ) ; } LOG . info ( String . format ( "Thread %s using random seed %d." , Thread . currentThread ( ) . getName ( ) , seed ) ) ; return seed ; } public long verifiableMessages ( ) { long totalMessages = 0 ; for ( int i = 0 ; i < publishers . length ; i ++ ) { totalMessages += publishers [ i ] . verifiableMessagesSent ( ) ; } return totalMessages ; } public long bytes ( ) { long totalBytes = 0 ; for ( int i = 0 ; i < publishers . length ; i ++ ) { totalBytes += publishers [ i ] . bytesSent ( ) ; } return totalBytes ; } public long nonVerifiableMessages ( ) { long totalMessages = 0 ; for ( int i = 0 ; i < publishers . length ; i ++ ) { totalMessages += publishers [ i ] . nonVerifiableMessagesSent ( ) ; } return totalMessages ; } class PublisherThread implements Runnable , InactiveConnectionHandler , NewConnectionHandler , RateController . Callback { final int threadId ; private long nonVerifiableMessagesSent ; private long verifiableMessagesSent ; private long bytesSent ; private final long messagesToSend ; private final Publication publications [ ] ; private final MessageStream messageStreams [ ] ; private int currentPublicationIndex ; private final MessageSizePattern msp ; private final RateController rateController ; private final UnsafeBuffer sendBuffer ; private final boolean verifiableMessages = options . verify ( ) ; private final Aeron . Context ctx ; private final Aeron aeron ; @ SuppressWarnings ( "resource" ) public PublisherThread ( final int threadId , final long messages ) { this . threadId = threadId ; this . messagesToSend = messages ; msp = options . messageSizePattern ( ) ; RateController rc = null ; try { rc = new RateController ( this , options . rateIntervals ( ) , options . iterations ( ) ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } rateController = rc ; sendBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( msp . maximum ( ) ) ) ; ctx = new Aeron . Context ( ) . inactiveConnectionHandler ( this ) . newConnectionHandler ( this ) . errorHandler ( ( throwable ) - > { throwable . printStackTrace ( ) ; if ( throwable instanceof DriverTimeoutException ) { LOG . severe ( "Driver does not appear to be running or has been unresponsive for ten seconds." ) ; System . exit ( - 1 ) ; } } ) . mediaDriverTimeout ( 10000 ) ; aeron = Aeron . connect ( ctx ) ; final ArrayList < Publication > publicationsList = new ArrayList < Publication > ( ) ; int streamIdx = 0 ; for ( int i = 0 ; i < options . channels ( ) . size ( ) ; i ++ ) { final ChannelDescriptor channel = options . channels ( ) . get ( i ) ; for ( int j = 0 ; j < channel . streamIdentifiers ( ) . length ; j ++ ) { if ( ( streamIdx % numThreads ) == this . threadId ) { Publication pub ; if ( options . useSessionId ( ) ) { pub = aeron . addPublication ( channel . channel ( ) , channel . streamIdentifiers ( ) [ j ] , options . sessionId ( ) ) ; } else { pub = aeron . addPublication ( channel . channel ( ) , channel . streamIdentifiers ( ) [ j ] ) ; } publicationsList . add ( pub ) ; LOG . info ( String . format ( "%s publishing %d messages to: %s#%d[%d]" , ( "publisher-" + threadId ) , messagesToSend , pub . channel ( ) , pub . streamId ( ) , pub . sessionId ( ) ) ) ; } streamIdx ++ ; } } publications = new Publication [ publicationsList . size ( ) ] ; publicationsList . toArray ( publications ) ; messageStreams = new MessageStream [ publications . length ] ; for ( int i = 0 ; i < publications . length ; i ++ ) { try { messageStreams [ i ] = new MessageStream ( msp . maximum ( ) , verifiableMessages , options . input ( ) ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } } } public long bytesSent ( ) { return bytesSent ; } public long nonVerifiableMessagesSent ( ) { return nonVerifiableMessagesSent ; } public long verifiableMessagesSent ( ) { return verifiableMessagesSent ; } public void run ( ) { Thread . currentThread ( ) . setName ( "publisher-" + threadId ) ; while ( ! shuttingDown && rateController . next ( ) ) { if ( rateController . messages ( ) == messagesToSend ) { break ; } } for ( int i = 0 ; i < publications . length ; i ++ ) { publications [ i ] . close ( ) ; } aeron . close ( ) ; ctx . close ( ) ; } public void onInactiveConnection ( final String channel , final int streamId , final int sessionId , final long position ) { LOG . info ( String . format ( "INACTIVE CONNECTION: channel \"%s\", stream %d, session %d, position 0x%x" , channel , streamId , sessionId , position ) ) ; } public void onNewConnection ( final String channel , final int streamId , final int sessionId , final long position , final String sourceIdentity ) { LOG . info ( String . format ( "NEW CONNECTION: channel \"%s\", stream %d, session %d, position 0x%x source \"%s\"" , channel , streamId , sessionId , position , sourceIdentity ) ) ; } public int onNext ( ) { int length = - 1 ; boolean sendSucceeded = false ; final Publication pub = publications [ currentPublicationIndex ] ; final MessageStream ms = messageStreams [ currentPublicationIndex ] ; currentPublicationIndex ++ ; if ( currentPublicationIndex == publications . length ) { currentPublicationIndex = 0 ; } if ( ! ms . isActive ( ) ) { return - 1 ; } try { length = ms . getNext ( sendBuffer , msp . getNext ( ) ) ; if ( length >= 0 ) { while ( ! ( sendSucceeded = ( pub . offer ( sendBuffer , 0 , length ) >= 0L ) ) && ! shuttingDown ) { } } } catch ( final Exception e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } if ( sendSucceeded ) { if ( verifiableMessages ) { verifiableMessagesSent ++ ; } else { nonVerifiableMessagesSent ++ ; } bytesSent += length ; } return ( sendSucceeded ? length : - 1 ) ; } } public void report ( final StringBuilder reportString ) { LOG . info ( reportString . toString ( ) ) ; } }
package uk . co . real_logic . aeron . driver . event ; import org . junit . Test ; import java . util . HashSet ; import java . util . Set ; import static org . junit . Assert . assertTrue ; public class EventCodeTest { @ Test public void allTagsBitsAreUnique ( ) { final Set < Long > seenTagBits = new HashSet < > ( ) ; for ( final EventCode code : EventCode . values ( ) ) { assertTrue ( seenTagBits . add ( code . tagBit ( ) ) ) ; } } }
package uk . co . real_logic . aeron . driver . event ; import org . junit . Test ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import static org . hamcrest . Matchers . containsString ; import static org . junit . Assert . assertThat ; public class EventCodecTest { private static final String MESSAGE = "End of the world!" ; private static final String DECLARING_CLASS = EventCodecTest . class . getName ( ) ; private static final String METHOD = "someMethod" ; private static final String FILE = EventCodecTest . class . getSimpleName ( ) + ".java" ; private static final int LINE_NUMBER = 10 ; private static final int BUFFER_LENGTH = 1024 * 10 ; private UnsafeBuffer buffer = new UnsafeBuffer ( new byte [ BUFFER_LENGTH ] ) ; @ Test public void dissectAsExceptionShouldContainTheValuesEncoded ( ) { final Exception ex = new Exception ( MESSAGE ) ; ex . fillInStackTrace ( ) ; final int size = EventCodec . encode ( buffer , ex ) ; final String written = EventCodec . dissectAsException ( EventCode . EXCEPTION , buffer , 0 , size ) ; assertThat ( written , containsString ( MESSAGE ) ) ; assertThat ( written , containsString ( ex . getClass ( ) . getName ( ) ) ) ; assertThat ( written , containsString ( getClass ( ) . getName ( ) ) ) ; assertThat ( written , containsString ( getClass ( ) . getSimpleName ( ) + ".java" ) ) ; assertThat ( written , containsString ( "dissectAsExceptionShouldContainTheValuesEncoded" ) ) ; assertThat ( written , containsString ( ":43" ) ) ; } @ Test public void dissectAsInvocationShouldContainTheValuesEncoded ( ) { final StackTraceElement element = new StackTraceElement ( DECLARING_CLASS , METHOD , FILE , LINE_NUMBER ) ; final int size = EventCodec . encode ( buffer , element ) ; final String written = EventCodec . dissectAsInvocation ( EventCode . EXCEPTION , buffer , 0 , size ) ; assertThat ( written , containsString ( DECLARING_CLASS ) ) ; assertThat ( written , containsString ( METHOD ) ) ; assertThat ( written , containsString ( FILE ) ) ; assertThat ( written , containsString ( ":" + LINE_NUMBER ) ) ; } }
package uk . co . real_logic . aeron . driver . event ; import org . junit . Test ; import java . util . EnumSet ; import java . util . Set ; import static org . hamcrest . Matchers . is ; import static org . junit . Assert . assertThat ; import static uk . co . real_logic . aeron . driver . event . EventCode . EXCEPTION ; import static uk . co . real_logic . aeron . driver . event . EventCode . FRAME_IN ; import static uk . co . real_logic . aeron . driver . event . EventConfiguration . * ; public class EventConfigurationTest { @ Test public void nullPropertyShouldDefaultToProductionEventCodes ( ) { assertThat ( getEnabledEventCodes ( null ) , is ( PRODUCTION_LOGGER_EVENT_CODES ) ) ; } @ Test ( expected = IllegalArgumentException . class ) public void malformedPropertyShouldDefaultToProductionEventCodes ( ) { getEnabledEventCodes ( "list of invalid options" ) ; } @ Test public void allPropertyShouldReturnAllEventCodes ( ) { assertThat ( getEnabledEventCodes ( "all" ) , is ( ALL_LOGGER_EVENT_CODES ) ) ; } @ Test public void eventCodesPropertyShouldBeParsedAsAListOfEventCodes ( ) { final Set < EventCode > expectedCodes = EnumSet . of ( EXCEPTION , FRAME_IN ) ; assertThat ( getEnabledEventCodes ( "EXCEPTION,FRAME_IN" ) , is ( expectedCodes ) ) ; } @ Test public void makeTagBitSet ( ) { final Set < EventCode > eventCodes = EnumSet . of ( EXCEPTION , FRAME_IN ) ; final long bitSet = EventConfiguration . makeTagBitSet ( eventCodes ) ; assertThat ( bitSet , is ( EXCEPTION . tagBit ( ) | FRAME_IN . tagBit ( ) ) ) ; } }
package uk . co . real_logic . aeron . driver . buffer ; import org . junit . Test ; import uk . co . real_logic . aeron . driver . media . UdpChannel ; import java . io . File ; import java . io . IOException ; import static org . junit . Assert . assertTrue ; public class FileMappingConventionTest { @ Test public void uriStringsAreValidFiles ( ) throws IOException { assertIsValidFile ( uriToDir ( "udp://localhost:40123@localhost:40124" ) ) ; assertIsValidFile ( uriToDir ( "udp://localhost:40124" ) ) ; } private String uriToDir ( final String uri ) { final UdpChannel udpChannel = UdpChannel . parse ( uri ) ; return udpChannel . canonicalForm ( ) ; } private void assertIsValidFile ( final String channelDir ) throws IOException { final File file = new File ( channelDir ) ; assertTrue ( "Can't create a file" , file . mkdir ( ) ) ; assertTrue ( "Failed to clean up" , file . delete ( ) ) ; } }
package uk . co . real_logic . aeron . driver . buffer ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . aeron . driver . Configuration ; import uk . co . real_logic . aeron . driver . media . UdpChannel ; import uk . co . real_logic . agrona . IoUtil ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . io . File ; import java . io . IOException ; import static org . hamcrest . Matchers . is ; import static org . junit . Assert . assertThat ; import static org . mockito . Mockito . mock ; public class RawLogFactoryTest { private static final String CHANNEL = "udp://localhost:4321" ; private static final int SESSION_ID = 100 ; private static final int STREAM_ID = 101 ; private static final int CREATION_ID = 102 ; private static final File DATA_DIR = new File ( IoUtil . tmpDirName ( ) , "dataDirName" ) ; private static final int TERM_BUFFER_LENGTH = Configuration . TERM_BUFFER_LENGTH_DEFAULT ; private static final int TERM_BUFFER_MAX_LENGTH = Configuration . TERM_BUFFER_LENGTH_MAX_DEFAULT ; private RawLogFactory rawLogFactory ; private UdpChannel udpChannel = UdpChannel . parse ( CHANNEL ) ; private EventLogger logger = mock ( EventLogger . class ) ; @ Before public void createDataDir ( ) { IoUtil . ensureDirectoryExists ( DATA_DIR , "data" ) ; rawLogFactory = new RawLogFactory ( DATA_DIR . getAbsolutePath ( ) , TERM_BUFFER_LENGTH , TERM_BUFFER_MAX_LENGTH , logger ) ; } @ After public void cleanupFiles ( ) throws IOException { IoUtil . delete ( DATA_DIR , true ) ; } @ Test public void shouldCreateCorrectLengthAndZeroedFilesForPublication ( ) throws Exception { final String canonicalForm = udpChannel . canonicalForm ( ) ; final RawLog rawLog = rawLogFactory . newPublication ( canonicalForm , SESSION_ID , STREAM_ID , CREATION_ID ) ; rawLog . stream ( ) . forEach ( ( partition ) - > { final UnsafeBuffer term = partition . termBuffer ( ) ; assertThat ( term . capacity ( ) , is ( TERM_BUFFER_LENGTH ) ) ; assertThat ( term . getByte ( 0 ) , is ( ( byte ) 0 ) ) ; assertThat ( term . getByte ( TERM_BUFFER_LENGTH - 1 ) , is ( ( byte ) 0 ) ) ; final UnsafeBuffer metaData = partition . metaDataBuffer ( ) ; assertThat ( metaData . capacity ( ) , is ( LogBufferDescriptor . TERM_META_DATA_LENGTH ) ) ; assertThat ( metaData . getByte ( 0 ) , is ( ( byte ) 0 ) ) ; assertThat ( metaData . getByte ( LogBufferDescriptor . TERM_META_DATA_LENGTH - 1 ) , is ( ( byte ) 0 ) ) ; } ) ; } @ Test public void shouldCreateCorrectLengthAndZeroedFilesForConnection ( ) throws Exception { final String canonicalForm = udpChannel . canonicalForm ( ) ; final int connectionTermBufferMaxLength = TERM_BUFFER_LENGTH / 2 ; final RawLog rawLog = rawLogFactory . newConnection ( canonicalForm , SESSION_ID , STREAM_ID , CREATION_ID , connectionTermBufferMaxLength ) ; rawLog . stream ( ) . forEach ( ( partition ) - > { final UnsafeBuffer term = partition . termBuffer ( ) ; assertThat ( term . capacity ( ) , is ( connectionTermBufferMaxLength ) ) ; assertThat ( term . getByte ( 0 ) , is ( ( byte ) 0 ) ) ; assertThat ( term . getByte ( connectionTermBufferMaxLength - 1 ) , is ( ( byte ) 0 ) ) ; final UnsafeBuffer metaData = partition . metaDataBuffer ( ) ; assertThat ( metaData . capacity ( ) , is ( LogBufferDescriptor . TERM_META_DATA_LENGTH ) ) ; assertThat ( metaData . getByte ( 0 ) , is ( ( byte ) 0 ) ) ; assertThat ( metaData . getByte ( LogBufferDescriptor . TERM_META_DATA_LENGTH - 1 ) , is ( ( byte ) 0 ) ) ; } ) ; } @ Test ( expected = IllegalArgumentException . class ) public void shouldExceptionIfRequestedTermBufferLengthGreaterThanMax ( ) { final String canonicalForm = udpChannel . canonicalForm ( ) ; final int connectionTermBufferMaxLength = TERM_BUFFER_MAX_LENGTH * 2 ; rawLogFactory . newConnection ( canonicalForm , SESSION_ID , STREAM_ID , CREATION_ID , connectionTermBufferMaxLength ) ; } }
package uk . co . real_logic . aeron . driver ; @ FunctionalInterface public interface RetransmitSender { void resend ( int termId , int termOffset , int length ) ; }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . driver . cmd . * ; import uk . co . real_logic . aeron . driver . media . SendChannelEndpoint ; import uk . co . real_logic . agrona . concurrent . AtomicCounter ; import java . util . Queue ; import static uk . co . real_logic . aeron . driver . ThreadingMode . SHARED ; public class SenderProxy { private final ThreadingMode threadingMode ; private final Queue < SenderCmd > commandQueue ; private final AtomicCounter failCount ; private Sender sender ; public SenderProxy ( final ThreadingMode threadingMode , final Queue < SenderCmd > commandQueue , final AtomicCounter failCount ) { this . threadingMode = threadingMode ; this . commandQueue = commandQueue ; this . failCount = failCount ; } public void sender ( final Sender sender ) { this . sender = sender ; } public void registerSendChannelEndpoint ( final SendChannelEndpoint channelEndpoint ) { if ( isSharedThread ( ) ) { sender . onRegisterSendChannelEndpoint ( channelEndpoint ) ; } else { offer ( new RegisterSendChannelEndpointCmd ( channelEndpoint ) ) ; } } public void closeSendChannelEndpoint ( final SendChannelEndpoint channelEndpoint ) { if ( isSharedThread ( ) ) { sender . onCloseSendChannelEndpoint ( channelEndpoint ) ; } else { offer ( new CloseSendChannelEndpointCmd ( channelEndpoint ) ) ; } } public void removePublication ( final NetworkPublication publication ) { if ( isSharedThread ( ) ) { sender . onRemovePublication ( publication ) ; } else { offer ( new RemovePublicationCmd ( publication ) ) ; } } public void newPublication ( final NetworkPublication publication , final RetransmitHandler retransmitHandler , final FlowControl flowControl ) { if ( isSharedThread ( ) ) { sender . onNewPublication ( publication , retransmitHandler , flowControl ) ; } else { offer ( new NewPublicationCmd ( publication , retransmitHandler , flowControl ) ) ; } } private boolean isSharedThread ( ) { return threadingMode == SHARED ; } private void offer ( final SenderCmd cmd ) { while ( ! commandQueue . offer ( cmd ) ) { failCount . orderedIncrement ( ) ; Thread . yield ( ) ; } } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . agrona . concurrent . status . Position ; public final class SubscriberPosition { private final SubscriptionLink subscription ; private final Position position ; public SubscriberPosition ( final SubscriptionLink subscription , final Position position ) { this . subscription = subscription ; this . position = position ; } public Position position ( ) { return position ; } public int positionCounterId ( ) { return position ( ) . id ( ) ; } public SubscriptionLink subscription ( ) { return subscription ; } }
package uk . co . real_logic . aeron . driver ; public enum ThreadingMode { DEDICATED , SHARED_NETWORK , SHARED , }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . util . concurrent . TimeUnit ; import static uk . co . real_logic . aeron . logbuffer . TermGapScanner . GapHandler ; import static uk . co . real_logic . aeron . logbuffer . TermGapScanner . scanForGap ; public class LossDetector { private final FeedbackDelayGenerator delayGenerator ; private final NakMessageSender nakMessageSender ; private final TimerWheel . Timer timer ; private final TimerWheel wheel ; private final Gap scannedGap = new Gap ( ) ; private final Gap activeGap = new Gap ( ) ; private final GapHandler onGapFunc = this : : onGap ; private final Runnable onTimerExpireFunc = this : : onTimerExpire ; private int rebuildOffset = 0 ; public LossDetector ( final TimerWheel wheel , final FeedbackDelayGenerator delayGenerator , final NakMessageSender nakMessageSender ) { this . wheel = wheel ; this . timer = wheel . newBlankTimer ( ) ; this . delayGenerator = delayGenerator ; this . nakMessageSender = nakMessageSender ; } public int rebuildOffset ( ) { return rebuildOffset ; } public int scan ( final UnsafeBuffer termBuffer , final long rebuildPosition , final long hwmPosition , final int termLengthMask , final int positionBitsToShift , final int initialTermId ) { int workCount = 1 ; final int rebuildTermOffset = ( int ) rebuildPosition & termLengthMask ; final int hwmTermOffset = ( int ) hwmPosition & termLengthMask ; if ( rebuildPosition < hwmPosition ) { final int rebuildTermsCount = ( int ) ( rebuildPosition > > > positionBitsToShift ) ; final int hwmTermsCount = ( int ) ( hwmPosition > > > positionBitsToShift ) ; final int activeTermId = initialTermId + rebuildTermsCount ; final int activeTermLimit = ( rebuildTermsCount == hwmTermsCount ) ? hwmTermOffset : termBuffer . capacity ( ) ; rebuildOffset = activeTermLimit ; rebuildOffset = scanForGap ( termBuffer , activeTermId , rebuildTermOffset , activeTermLimit , onGapFunc ) ; if ( rebuildOffset < activeTermLimit ) { final Gap gap = scannedGap ; if ( ! timer . isActive ( ) || ! gap . matches ( activeGap . termId , activeGap . termOffset ) ) { activateGap ( gap . termId , gap . termOffset , gap . length ) ; workCount = 0 ; } rebuildOffset = gap . termOffset ; } } else { if ( timer . isActive ( ) ) { timer . cancel ( ) ; } rebuildOffset = rebuildTermOffset ; workCount = 0 ; } return workCount ; } public void onNak ( final int termId , final int termOffset ) { if ( timer . isActive ( ) && activeGap . matches ( termId , termOffset ) ) { suppressNak ( ) ; } } private void suppressNak ( ) { scheduleTimer ( ) ; } private void onGap ( final int termId , final UnsafeBuffer buffer , final int offset , final int length ) { scannedGap . reset ( termId , offset , length ) ; } private void activateGap ( final int termId , final int termOffset , final int length ) { activeGap . reset ( termId , termOffset , length ) ; if ( determineNakDelay ( ) == - 1 ) { return ; } scheduleTimer ( ) ; if ( delayGenerator . shouldFeedbackImmediately ( ) ) { sendNakMessage ( ) ; } } private void onTimerExpire ( ) { sendNakMessage ( ) ; scheduleTimer ( ) ; } private void sendNakMessage ( ) { nakMessageSender . onLossDetected ( activeGap . termId , activeGap . termOffset , activeGap . length ) ; } private long determineNakDelay ( ) { return delayGenerator . generateDelay ( ) ; } private void scheduleTimer ( ) { final long delay = determineNakDelay ( ) ; if ( timer . isActive ( ) ) { timer . cancel ( ) ; } wheel . rescheduleTimeout ( delay , TimeUnit . NANOSECONDS , timer , onTimerExpireFunc ) ; } static final class Gap { int termId ; int termOffset ; int length ; public void reset ( final int termId , final int termOffset , final int length ) { this . termId = termId ; this . termOffset = termOffset ; this . length = length ; } public boolean matches ( final int termId , final int termOffset ) { return termId == this . termId && termOffset == this . termOffset ; } } }
package uk . co . real_logic . aeron . tools ; import uk . co . real_logic . aeron . tools . RateController . IntervalInternal ; public class MessagesAtBitsPerSecondInterval extends RateControllerInterval { private final long goalBitsPerSecond ; private final long messages ; public MessagesAtBitsPerSecondInterval ( final long messages , final long bitsPerSecond ) { this . goalBitsPerSecond = bitsPerSecond ; this . messages = messages ; } public long bitsPerSecond ( ) { return goalBitsPerSecond ; } public long messages ( ) { return messages ; } IntervalInternal makeInternal ( final RateController rateController ) throws Exception { return rateController . new MessagesAtBitsPerSecondInternal ( rateController , messages , goalBitsPerSecond ) ; } }
package uk . co . real_logic . aeron . driver ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Map ; public class UriUtil { public static < M extends Map < String , String > > M parseQueryString ( final URI uri , final M queryParams ) throws URISyntaxException { final String query = uri . getQuery ( ) ; if ( null == query ) { return queryParams ; } final String [ ] pairs = query . split ( "&" ) ; for ( final String pair : pairs ) { final String [ ] componentParts = pair . split ( "=" ) ; if ( componentParts . length == 2 ) { queryParams . put ( componentParts [ 0 ] , componentParts [ 1 ] ) ; } else if ( componentParts . length == 1 ) { queryParams . put ( componentParts [ 0 ] , "" ) ; } else { throw new URISyntaxException ( pair , "Did not contain 1 or 2 parts" ) ; } } return queryParams ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . logbuffer . LogBufferPartition ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . protocol . HeaderFlyweight ; import uk . co . real_logic . aeron . protocol . SetupFlyweight ; import uk . co . real_logic . aeron . driver . buffer . RawLog ; import uk . co . real_logic . aeron . driver . media . SendChannelEndpoint ; import uk . co . real_logic . agrona . concurrent . NanoClock ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . status . Position ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . * ; import static uk . co . real_logic . aeron . driver . Configuration . PUBLICATION_HEARTBEAT_TIMEOUT_NS ; import static uk . co . real_logic . aeron . driver . Configuration . PUBLICATION_SETUP_TIMEOUT_NS ; import static uk . co . real_logic . aeron . logbuffer . TermScanner . available ; import static uk . co . real_logic . aeron . logbuffer . TermScanner . padding ; import static uk . co . real_logic . aeron . logbuffer . TermScanner . scanForAvailability ; public class NetworkPublication implements RetransmitSender , AutoCloseable { private final RawLog rawLog ; private final NanoClock clock ; private final SetupFlyweight setupHeader = new SetupFlyweight ( ) ; private final DataHeaderFlyweight dataHeader = new DataHeaderFlyweight ( ) ; private final ByteBuffer setupFrameBuffer = ByteBuffer . allocateDirect ( SetupFlyweight . HEADER_LENGTH ) ; private final ByteBuffer heartbeatFrameBuffer = ByteBuffer . allocateDirect ( DataHeaderFlyweight . HEADER_LENGTH ) ; private final LogBufferPartition [ ] logPartitions ; private final ByteBuffer [ ] sendBuffers ; private final Position publisherLimit ; private final Position senderPosition ; private final SendChannelEndpoint channelEndpoint ; private final InetSocketAddress dstAddress ; private final SystemCounters systemCounters ; private final int positionBitsToShift ; private final int initialTermId ; private final int termLengthMask ; private final int mtuLength ; private final int termWindowLength ; private long timeOfLastSendOrHeartbeat ; private long timeOfFlush = 0 ; private int statusMessagesReceivedCount = 0 ; private int refCount = 0 ; private volatile long senderPositionLimit ; private boolean trackSenderLimits = true ; private volatile boolean isActive = true ; private volatile boolean shouldSendSetupFrame = true ; public NetworkPublication ( final SendChannelEndpoint channelEndpoint , final NanoClock clock , final RawLog rawLog , final Position senderPosition , final Position publisherLimit , final int sessionId , final int streamId , final int initialTermId , final int mtuLength , final long initialPositionLimit , final SystemCounters systemCounters ) { this . channelEndpoint = channelEndpoint ; this . rawLog = rawLog ; this . senderPosition = senderPosition ; this . systemCounters = systemCounters ; this . dstAddress = channelEndpoint . udpChannel ( ) . remoteData ( ) ; this . clock = clock ; this . publisherLimit = publisherLimit ; this . mtuLength = mtuLength ; logPartitions = rawLog . stream ( ) . map ( ( partition ) - > new LogBufferPartition ( partition . termBuffer ( ) , partition . metaDataBuffer ( ) ) ) . toArray ( LogBufferPartition [ ] : : new ) ; sendBuffers = rawLog . sliceTerms ( ) ; final int termLength = logPartitions [ 0 ] . termBuffer ( ) . capacity ( ) ; termLengthMask = termLength - 1 ; senderPositionLimit = initialPositionLimit ; timeOfLastSendOrHeartbeat = clock . nanoTime ( ) ; positionBitsToShift = Integer . numberOfTrailingZeros ( termLength ) ; this . initialTermId = initialTermId ; termWindowLength = Configuration . publicationTermWindowLength ( termLength ) ; publisherLimit . setOrdered ( termWindowLength ) ; setupHeader . wrap ( new UnsafeBuffer ( setupFrameBuffer ) , 0 ) ; initSetupFrame ( initialTermId , termLength , sessionId , streamId ) ; dataHeader . wrap ( new UnsafeBuffer ( heartbeatFrameBuffer ) , 0 ) ; initHeartBeatFrame ( sessionId , streamId ) ; } public void close ( ) { rawLog . close ( ) ; publisherLimit . close ( ) ; senderPosition . close ( ) ; } public int send ( ) { int bytesSent = 0 ; if ( isActive ) { final long senderPosition = this . senderPosition . get ( ) ; final int activeTermId = computeTermIdFromPosition ( senderPosition , positionBitsToShift , initialTermId ) ; final int termOffset = ( int ) senderPosition & termLengthMask ; final long now = clock . nanoTime ( ) ; if ( shouldSendSetupFrame ) { setupMessageCheck ( now , activeTermId , termOffset , senderPosition ) ; } bytesSent = sendData ( now , senderPosition , termOffset ) ; if ( 0 == bytesSent ) { heartbeatMessageCheck ( now , senderPosition , activeTermId ) ; } } return bytesSent ; } public SendChannelEndpoint sendChannelEndpoint ( ) { return channelEndpoint ; } public int sessionId ( ) { return dataHeader . sessionId ( ) ; } public int streamId ( ) { return dataHeader . streamId ( ) ; } public void senderPositionLimit ( final long positionLimit ) { statusMessagesReceivedCount ++ ; senderPositionLimit = positionLimit ; } public int cleanLogBuffer ( ) { int workCount = 0 ; for ( final LogBufferPartition partition : logPartitions ) { if ( partition . status ( ) == NEEDS_CLEANING ) { partition . clean ( ) ; workCount = 1 ; } } return workCount ; } public long timeOfFlush ( ) { return timeOfFlush ; } public void resend ( final int termId , int termOffset , final int length ) { final long senderPosition = this . senderPosition . get ( ) ; final int activeTermId = computeTermIdFromPosition ( senderPosition , positionBitsToShift , initialTermId ) ; if ( termId == activeTermId || termId == ( activeTermId - 1 ) ) { final int activeIndex = indexByTerm ( initialTermId , termId ) ; final UnsafeBuffer termBuffer = logPartitions [ activeIndex ] . termBuffer ( ) ; final ByteBuffer sendBuffer = sendBuffers [ activeIndex ] ; int remainingBytes = length ; int bytesSent = 0 ; do { termOffset += bytesSent ; final long scanOutcome = scanForAvailability ( termBuffer , termOffset , mtuLength ) ; final int available = available ( scanOutcome ) ; if ( available <= 0 ) { break ; } sendBuffer . limit ( termOffset + available ) . position ( termOffset ) ; if ( available != channelEndpoint . sendTo ( sendBuffer , dstAddress ) ) { systemCounters . dataPacketShortSends ( ) . orderedIncrement ( ) ; break ; } bytesSent = available + padding ( scanOutcome ) ; remainingBytes -= bytesSent ; } while ( remainingBytes > 0 ) ; systemCounters . retransmitsSent ( ) . orderedIncrement ( ) ; } } public void triggerSendSetupFrame ( ) { shouldSendSetupFrame = true ; } public int decRef ( ) { return -- refCount ; } public int incRef ( ) { final int i = ++ refCount ; if ( i == 1 ) { timeOfFlush = 0 ; isActive = true ; } return i ; } public boolean isUnreferencedAndFlushed ( final long now ) { boolean isFlushed = false ; if ( 0 == refCount ) { final long senderPosition = this . senderPosition . getVolatile ( ) ; final int activeIndex = indexByPosition ( senderPosition , positionBitsToShift ) ; isFlushed = ( int ) ( senderPosition & termLengthMask ) >= logPartitions [ activeIndex ] . tailVolatile ( ) ; if ( isFlushed && isActive ) { timeOfFlush = now ; isActive = false ; } } return isFlushed ; } public RawLog rawLog ( ) { return rawLog ; } public int publisherLimitId ( ) { return publisherLimit . id ( ) ; } public int updatePublishersLimit ( ) { int workCount = 0 ; final long candidatePublisherLimit = senderPosition . getVolatile ( ) + termWindowLength ; if ( publisherLimit . proposeMaxOrdered ( candidatePublisherLimit ) ) { workCount = 1 ; } return workCount ; } private int sendData ( final long now , final long senderPosition , final int termOffset ) { int bytesSent = 0 ; final int availableWindow = ( int ) ( senderPositionLimit - senderPosition ) ; if ( availableWindow > 0 ) { final int scanLimit = Math . min ( availableWindow , mtuLength ) ; final int activeIndex = indexByPosition ( senderPosition , positionBitsToShift ) ; final long scanOutcome = scanForAvailability ( logPartitions [ activeIndex ] . termBuffer ( ) , termOffset , scanLimit ) ; final int available = available ( scanOutcome ) ; if ( available > 0 ) { final ByteBuffer sendBuffer = sendBuffers [ activeIndex ] ; sendBuffer . limit ( termOffset + available ) . position ( termOffset ) ; if ( available == channelEndpoint . sendTo ( sendBuffer , dstAddress ) ) { timeOfLastSendOrHeartbeat = now ; trackSenderLimits = true ; bytesSent = available ; this . senderPosition . setOrdered ( senderPosition + bytesSent + padding ( scanOutcome ) ) ; } else { systemCounters . dataPacketShortSends ( ) . orderedIncrement ( ) ; } } } else if ( trackSenderLimits ) { trackSenderLimits = false ; systemCounters . senderFlowControlLimits ( ) . orderedIncrement ( ) ; } return bytesSent ; } private void setupMessageCheck ( final long now , final int activeTermId , final int termOffset , final long senderPosition ) { if ( 0 != senderPosition || ( now > ( timeOfLastSendOrHeartbeat + PUBLICATION_SETUP_TIMEOUT_NS ) ) ) { setupFrameBuffer . clear ( ) ; setupHeader . activeTermId ( activeTermId ) . termOffset ( termOffset ) ; final int bytesSent = channelEndpoint . sendTo ( setupFrameBuffer , dstAddress ) ; if ( SetupFlyweight . HEADER_LENGTH != bytesSent ) { systemCounters . setupMessageShortSends ( ) . orderedIncrement ( ) ; } timeOfLastSendOrHeartbeat = now ; } if ( statusMessagesReceivedCount > 0 ) { shouldSendSetupFrame = false ; } } private void heartbeatMessageCheck ( final long now , final long senderPosition , final int activeTermId ) { if ( now > ( timeOfLastSendOrHeartbeat + PUBLICATION_HEARTBEAT_TIMEOUT_NS ) ) { final int termOffset = ( int ) senderPosition & termLengthMask ; heartbeatFrameBuffer . clear ( ) ; dataHeader . termId ( activeTermId ) . termOffset ( termOffset ) ; final int bytesSent = channelEndpoint . sendTo ( heartbeatFrameBuffer , dstAddress ) ; if ( DataHeaderFlyweight . HEADER_LENGTH != bytesSent ) { systemCounters . dataPacketShortSends ( ) . orderedIncrement ( ) ; } systemCounters . heartbeatsSent ( ) . orderedIncrement ( ) ; timeOfLastSendOrHeartbeat = now ; } } private void initSetupFrame ( final int activeTermId , final int termLength , final int sessionId , final int streamId ) { setupHeader . sessionId ( sessionId ) . streamId ( streamId ) . initialTermId ( initialTermId ) . activeTermId ( activeTermId ) . termOffset ( 0 ) . termLength ( termLength ) . mtuLength ( mtuLength ) . version ( HeaderFlyweight . CURRENT_VERSION ) . flags ( ( byte ) 0 ) . headerType ( HeaderFlyweight . HDR_TYPE_SETUP ) . frameLength ( SetupFlyweight . HEADER_LENGTH ) ; } private void initHeartBeatFrame ( final int sessionId , final int streamId ) { dataHeader . sessionId ( sessionId ) . streamId ( streamId ) . version ( HeaderFlyweight . CURRENT_VERSION ) . flags ( ( byte ) DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) . frameLength ( 0 ) ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . driver . cmd . ReceiverCmd ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; import uk . co . real_logic . aeron . driver . media . TransportPoller ; import uk . co . real_logic . agrona . concurrent . Agent ; import uk . co . real_logic . agrona . concurrent . AtomicCounter ; import uk . co . real_logic . agrona . concurrent . NanoClock ; import uk . co . real_logic . agrona . concurrent . OneToOneConcurrentArrayQueue ; import java . util . ArrayList ; import java . util . function . Consumer ; public class Receiver implements Agent , Consumer < ReceiverCmd > { private final long statusMessageTimeout ; private final TransportPoller transportPoller ; private final OneToOneConcurrentArrayQueue < ReceiverCmd > commandQueue ; private final AtomicCounter totalBytesReceived ; private final NanoClock clock ; private final ArrayList < NetworkConnection > connections = new ArrayList < > ( ) ; private final ArrayList < PendingSetupMessageFromSource > pendingSetupMessages = new ArrayList < > ( ) ; public Receiver ( final MediaDriver . Context ctx ) { statusMessageTimeout = ctx . statusMessageTimeout ( ) ; transportPoller = ctx . receiverNioSelector ( ) ; commandQueue = ctx . receiverCommandQueue ( ) ; totalBytesReceived = ctx . systemCounters ( ) . bytesReceived ( ) ; clock = ctx . conductorTimerWheel ( ) . clock ( ) ; } public String roleName ( ) { return "receiver" ; } public int doWork ( ) throws Exception { int workCount = commandQueue . drain ( this ) ; final int bytesReceived = transportPoller . pollTransports ( ) ; final long now = clock . nanoTime ( ) ; for ( int i = connections . size ( ) - 1 ; i >= 0 ; i -- ) { final NetworkConnection connection = connections . get ( i ) ; if ( ! connection . checkForActivity ( now , Configuration . CONNECTION_LIVENESS_TIMEOUT_NS ) ) { connection . removeFromDispatcher ( ) ; connections . remove ( i ) ; } else { workCount += connection . sendPendingStatusMessage ( now , statusMessageTimeout ) ; workCount += connection . sendPendingNak ( ) ; } } timeoutPendingSetupMessages ( now ) ; totalBytesReceived . addOrdered ( bytesReceived ) ; return workCount + bytesReceived ; } public void addPendingSetupMessage ( final int sessionId , final int streamId , final ReceiveChannelEndpoint channelEndpoint ) { final PendingSetupMessageFromSource cmd = new PendingSetupMessageFromSource ( sessionId , streamId , channelEndpoint ) ; cmd . timeOfStatusMessage ( clock . nanoTime ( ) ) ; pendingSetupMessages . add ( cmd ) ; } public void onAddSubscription ( final ReceiveChannelEndpoint channelEndpoint , final int streamId ) { channelEndpoint . dispatcher ( ) . addSubscription ( streamId ) ; } public void onRemoveSubscription ( final ReceiveChannelEndpoint channelEndpoint , final int streamId ) { channelEndpoint . dispatcher ( ) . removeSubscription ( streamId ) ; } public void onNewConnection ( final ReceiveChannelEndpoint channelEndpoint , final NetworkConnection connection ) { connections . add ( connection ) ; channelEndpoint . dispatcher ( ) . addConnection ( connection ) ; } public void onRegisterReceiveChannelEndpoint ( final ReceiveChannelEndpoint channelEndpoint ) { channelEndpoint . openChannel ( ) ; channelEndpoint . registerForRead ( transportPoller ) ; transportPoller . selectNowWithoutProcessing ( ) ; } public void onCloseReceiveChannelEndpoint ( final ReceiveChannelEndpoint channelEndpoint ) { channelEndpoint . close ( ) ; transportPoller . selectNowWithoutProcessing ( ) ; } public void accept ( final ReceiverCmd cmd ) { cmd . execute ( this ) ; } private void timeoutPendingSetupMessages ( final long now ) { for ( int i = pendingSetupMessages . size ( ) - 1 ; i >= 0 ; i -- ) { final PendingSetupMessageFromSource cmd = pendingSetupMessages . get ( i ) ; if ( now > ( cmd . timeOfStatusMessage ( ) + Configuration . PENDING_SETUPS_TIMEOUT_NS ) ) { pendingSetupMessages . remove ( i ) ; cmd . channelEndpoint ( ) . dispatcher ( ) . removePendingSetup ( cmd . sessionId ( ) , cmd . streamId ( ) ) ; } } } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . protocol . StatusMessageFlyweight ; import java . net . InetSocketAddress ; @ FunctionalInterface public interface StatusMessageHandler { void onMessage ( StatusMessageFlyweight statusMessage , InetSocketAddress srcAddress ) ; }
package uk . co . real_logic . aeron . driver ; @ FunctionalInterface public interface NakMessageSender { void onLossDetected ( int termId , int termOffset , int length ) ; }
package uk . co . real_logic . aeron . driver ; import java . net . InterfaceAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . util . Enumeration ; import java . util . List ; interface NetworkInterfaceShim { Enumeration < NetworkInterface > getNetworkInterfaces ( ) throws SocketException ; List < InterfaceAddress > getInterfaceAddresses ( NetworkInterface ifc ) ; boolean isLoopback ( NetworkInterface ifc ) throws SocketException ; NetworkInterfaceShim DEFAULT = new NetworkInterfaceShim ( ) { public Enumeration < NetworkInterface > getNetworkInterfaces ( ) throws SocketException { return NetworkInterface . getNetworkInterfaces ( ) ; } public List < InterfaceAddress > getInterfaceAddresses ( final NetworkInterface ifc ) { return ifc . getInterfaceAddresses ( ) ; } public boolean isLoopback ( final NetworkInterface ifc ) throws SocketException { return ifc . isLoopback ( ) ; } } ; }
package uk . co . real_logic . aeron . driver ; import java . util . concurrent . locks . LockSupport ; public class RateReporter implements Runnable { @ FunctionalInterface public interface Reporter { void onReport ( double messagesPerSec , double bytesPerSec , long totalMessages , long totalBytes ) ; } private final long reportIntervalNs ; private final long parkNs ; private final Reporter reportingFunc ; private volatile boolean halt = false ; private volatile long totalBytes ; private volatile long totalMessages ; private long lastTotalBytes ; private long lastTotalMessages ; private long lastTimestamp ; public RateReporter ( final long reportInterval , final Reporter reportingFunc ) { this . reportIntervalNs = reportInterval ; this . parkNs = reportInterval ; this . reportingFunc = reportingFunc ; lastTimestamp = System . nanoTime ( ) ; } public void run ( ) { do { LockSupport . parkNanos ( parkNs ) ; final long currentTotalMessages = totalMessages ; final long currentTotalBytes = totalBytes ; final long currentTimestamp = System . nanoTime ( ) ; final long timeSpanNs = currentTimestamp - lastTimestamp ; final double messagesPerSec = ( ( currentTotalMessages - lastTotalMessages ) * reportIntervalNs ) / ( double ) timeSpanNs ; final double bytesPerSec = ( ( currentTotalBytes - lastTotalBytes ) * reportIntervalNs ) / ( double ) timeSpanNs ; reportingFunc . onReport ( messagesPerSec , bytesPerSec , currentTotalMessages , currentTotalBytes ) ; lastTotalBytes = currentTotalBytes ; lastTotalMessages = currentTotalMessages ; lastTimestamp = currentTimestamp ; } while ( ! halt ) ; } public void halt ( ) { halt = true ; } public void onMessage ( final long messages , final long bytes ) { totalBytes += bytes ; totalMessages += messages ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . CncFileDescriptor ; import uk . co . real_logic . aeron . CommonContext ; import uk . co . real_logic . aeron . driver . buffer . RawLogFactory ; import uk . co . real_logic . aeron . driver . cmd . DriverConductorCmd ; import uk . co . real_logic . aeron . driver . cmd . ReceiverCmd ; import uk . co . real_logic . aeron . driver . cmd . SenderCmd ; import uk . co . real_logic . aeron . driver . event . EventConfiguration ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . aeron . driver . exceptions . ConfigurationException ; import uk . co . real_logic . aeron . driver . media . TransportPoller ; import uk . co . real_logic . agrona . IoUtil ; import uk . co . real_logic . agrona . LangUtil ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . concurrent . * ; import uk . co . real_logic . agrona . concurrent . broadcast . BroadcastTransmitter ; import uk . co . real_logic . agrona . concurrent . ringbuffer . ManyToOneRingBuffer ; import uk . co . real_logic . agrona . concurrent . ringbuffer . RingBuffer ; import java . io . File ; import java . io . IOException ; import java . net . StandardSocketOptions ; import java . nio . ByteBuffer ; import java . nio . MappedByteBuffer ; import java . nio . channels . DatagramChannel ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . function . BiConsumer ; import java . util . function . Consumer ; import java . util . function . Supplier ; import static java . lang . Boolean . getBoolean ; import static uk . co . real_logic . aeron . driver . Configuration . * ; import static uk . co . real_logic . agrona . IoUtil . deleteIfExists ; import static uk . co . real_logic . agrona . IoUtil . mapNewFile ; public final class MediaDriver implements AutoCloseable { public static final String DIRS_DELETE_ON_EXIT_PROP_NAME = "aeron.dir.delete.on.exit" ; private final File parentDirectory ; private final List < AgentRunner > runners ; private final Context ctx ; public static void main ( final String [ ] args ) throws Exception { try ( final MediaDriver ignored = MediaDriver . launch ( ) ) { new SigIntBarrier ( ) . await ( ) ; System . out . println ( "Shutdown Driver..." ) ; } } private MediaDriver ( final Context ctx ) { this . ctx = ctx ; parentDirectory = new File ( ctx . dirName ( ) ) ; ensureDirectoriesAreRecreated ( ) ; validateSufficientSocketBufferLengths ( ctx ) ; ctx . unicastSenderFlowControl ( Configuration : : unicastFlowControlStrategy ) . multicastSenderFlowControl ( Configuration : : multicastFlowControlStrategy ) . conductorTimerWheel ( Configuration . newConductorTimerWheel ( ) ) . toConductorFromReceiverCommandQueue ( new OneToOneConcurrentArrayQueue < > ( Configuration . CMD_QUEUE_CAPACITY ) ) . toConductorFromSenderCommandQueue ( new OneToOneConcurrentArrayQueue < > ( Configuration . CMD_QUEUE_CAPACITY ) ) . receiverCommandQueue ( new OneToOneConcurrentArrayQueue < > ( Configuration . CMD_QUEUE_CAPACITY ) ) . senderCommandQueue ( new OneToOneConcurrentArrayQueue < > ( Configuration . CMD_QUEUE_CAPACITY ) ) . conclude ( ) ; final AtomicCounter driverExceptions = ctx . systemCounters ( ) . driverExceptions ( ) ; final Receiver receiver = new Receiver ( ctx ) ; final Sender sender = new Sender ( ctx ) ; final DriverConductor driverConductor = new DriverConductor ( ctx ) ; ctx . receiverProxy ( ) . receiver ( receiver ) ; ctx . senderProxy ( ) . sender ( sender ) ; ctx . fromReceiverDriverConductorProxy ( ) . driverConductor ( driverConductor ) ; ctx . fromSenderDriverConductorProxy ( ) . driverConductor ( driverConductor ) ; ctx . toDriverCommands ( ) . consumerHeartbeatTime ( ctx . epochClock ( ) . time ( ) ) ; switch ( ctx . threadingMode ) { case SHARED : runners = Collections . singletonList ( new AgentRunner ( ctx . sharedIdleStrategy , ctx . exceptionConsumer ( ) , driverExceptions , new CompositeAgent ( sender , new CompositeAgent ( receiver , driverConductor ) ) ) ) ; break ; case SHARED_NETWORK : runners = Arrays . asList ( new AgentRunner ( ctx . sharedNetworkIdleStrategy , ctx . exceptionConsumer ( ) , driverExceptions , new CompositeAgent ( sender , receiver ) ) , new AgentRunner ( ctx . conductorIdleStrategy , ctx . exceptionConsumer ( ) , driverExceptions , driverConductor ) ) ; break ; default : case DEDICATED : runners = Arrays . asList ( new AgentRunner ( ctx . senderIdleStrategy , ctx . exceptionConsumer ( ) , driverExceptions , sender ) , new AgentRunner ( ctx . receiverIdleStrategy , ctx . exceptionConsumer ( ) , driverExceptions , receiver ) , new AgentRunner ( ctx . conductorIdleStrategy , ctx . exceptionConsumer ( ) , driverExceptions , driverConductor ) ) ; break ; } } public static MediaDriver launchEmbedded ( ) { final Context ctx = new Context ( ) ; return launchEmbedded ( ctx ) ; } public static MediaDriver launchEmbedded ( final Context ctx ) { ctx . dirName ( CommonContext . generateEmbeddedDirName ( ) ) ; return launch ( ctx ) ; } public static MediaDriver launch ( ) { return launch ( new Context ( ) ) ; } public static MediaDriver launch ( final Context ctx ) { return new MediaDriver ( ctx ) . start ( ) ; } public void close ( ) { try { runners . forEach ( AgentRunner : : close ) ; freeSocketsForReuseOnWindows ( ) ; ctx . close ( ) ; deleteDirectories ( ) ; } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } } public String contextDirName ( ) { return ctx . dirName ( ) ; } private void freeSocketsForReuseOnWindows ( ) { ctx . receiverNioSelector ( ) . selectNowWithoutProcessing ( ) ; ctx . senderNioSelector ( ) . selectNowWithoutProcessing ( ) ; } private MediaDriver start ( ) { runners . forEach ( ( runner ) - > { final Thread thread = new Thread ( runner ) ; thread . setName ( runner . agent ( ) . roleName ( ) ) ; thread . start ( ) ; } ) ; return this ; } private static void validateSufficientSocketBufferLengths ( final Context ctx ) { try ( final DatagramChannel probe = DatagramChannel . open ( ) ) { final int defaultSoSndbuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; probe . setOption ( StandardSocketOptions . SO_SNDBUF , Integer . MAX_VALUE ) ; final int maxSoSndbuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; if ( maxSoSndbuf < Configuration . SOCKET_SNDBUF_LENGTH ) { System . err . format ( "WARNING: Could not get desired SO_SNDBUF: attempted=%d, actual=%d\n" , Configuration . SOCKET_SNDBUF_LENGTH , maxSoSndbuf ) ; } probe . setOption ( StandardSocketOptions . SO_RCVBUF , Integer . MAX_VALUE ) ; final int maxSoRcvbuf = probe . getOption ( StandardSocketOptions . SO_RCVBUF ) ; if ( maxSoRcvbuf < Configuration . SOCKET_RCVBUF_LENGTH ) { System . err . format ( "WARNING: Could not get desired SO_RCVBUF: attempted=%d, actual=%d\n" , Configuration . SOCKET_RCVBUF_LENGTH , maxSoRcvbuf ) ; } final int soSndbuf = ( 0 == Configuration . SOCKET_SNDBUF_LENGTH ) ? defaultSoSndbuf : Configuration . SOCKET_SNDBUF_LENGTH ; if ( ctx . mtuLength ( ) > soSndbuf ) { throw new ConfigurationException ( String . format ( "MTU greater than socket SO_SNDBUF: mtuLength=%d, SO_SNDBUF=%d" , ctx . mtuLength ( ) , soSndbuf ) ) ; } } catch ( final IOException ex ) { throw new RuntimeException ( String . format ( "probe socket: %s" , ex . toString ( ) ) , ex ) ; } } private void ensureDirectoriesAreRecreated ( ) { final BiConsumer < String , String > callback = ( path , name ) - > { if ( ctx . warnIfDirectoriesExist ( ) ) { System . err . println ( "WARNING: " + name + " directory already exists: " + path ) ; } } ; IoUtil . ensureDirectoryIsRecreated ( parentDirectory , "aeron" , callback ) ; } private void deleteDirectories ( ) throws Exception { if ( ctx . dirsDeleteOnExit ( ) ) { IoUtil . delete ( parentDirectory , false ) ; } } public static class Context extends CommonContext { private RawLogFactory rawLogFactory ; private TransportPoller receiverTransportPoller ; private TransportPoller senderTransportPoller ; private Supplier < FlowControl > unicastSenderFlowControl ; private Supplier < FlowControl > multicastSenderFlowControl ; private EpochClock epochClock ; private TimerWheel conductorTimerWheel ; private OneToOneConcurrentArrayQueue < DriverConductorCmd > toConductorFromReceiverCommandQueue ; private OneToOneConcurrentArrayQueue < DriverConductorCmd > toConductorFromSenderCommandQueue ; private OneToOneConcurrentArrayQueue < ReceiverCmd > receiverCommandQueue ; private OneToOneConcurrentArrayQueue < SenderCmd > senderCommandQueue ; private ReceiverProxy receiverProxy ; private SenderProxy senderProxy ; private DriverConductorProxy fromReceiverDriverConductorProxy ; private DriverConductorProxy fromSenderDriverConductorProxy ; private IdleStrategy conductorIdleStrategy ; private IdleStrategy senderIdleStrategy ; private IdleStrategy receiverIdleStrategy ; private IdleStrategy sharedNetworkIdleStrategy ; private IdleStrategy sharedIdleStrategy ; private ClientProxy clientProxy ; private RingBuffer toDriverCommands ; private RingBuffer toEventReader ; private MappedByteBuffer cncByteBuffer ; private UnsafeBuffer cncMetaDataBuffer ; private CountersManager countersManager ; private SystemCounters systemCounters ; private int publicationTermBufferLength ; private int maxConnectionTermBufferLength ; private int initialWindowLength ; private int eventBufferLength ; private long statusMessageTimeout ; private long dataLossSeed ; private long controlLossSeed ; private double dataLossRate ; private double controlLossRate ; private int mtuLength ; private boolean warnIfDirectoriesExist ; private EventLogger eventLogger ; private Consumer < String > eventConsumer ; private ThreadingMode threadingMode ; private boolean dirsDeleteOnExit ; private LossGenerator dataLossGenerator ; private LossGenerator controlLossGenerator ; public Context ( ) { termBufferLength ( Configuration . termBufferLength ( ) ) ; termBufferMaxLength ( Configuration . termBufferLengthMax ( ) ) ; initialWindowLength ( Configuration . initialWindowLength ( ) ) ; statusMessageTimeout ( Configuration . statusMessageTimeout ( ) ) ; dataLossRate ( Configuration . dataLossRate ( ) ) ; dataLossSeed ( Configuration . dataLossSeed ( ) ) ; controlLossRate ( Configuration . controlLossRate ( ) ) ; controlLossSeed ( Configuration . controlLossSeed ( ) ) ; mtuLength ( Configuration . MTU_LENGTH ) ; eventConsumer = System . out : : println ; eventBufferLength = EventConfiguration . bufferLength ( ) ; warnIfDirectoriesExist = true ; dirsDeleteOnExit ( getBoolean ( DIRS_DELETE_ON_EXIT_PROP_NAME ) ) ; } public Context conclude ( ) { super . conclude ( ) ; try { if ( null == epochClock ) { epochClock = new SystemEpochClock ( ) ; } if ( threadingMode == null ) { threadingMode = Configuration . threadingMode ( ) ; } final ByteBuffer eventByteBuffer = ByteBuffer . allocateDirect ( eventBufferLength ) ; if ( null == eventLogger ) { eventLogger = new EventLogger ( eventByteBuffer ) ; } toEventReader ( new ManyToOneRingBuffer ( new UnsafeBuffer ( eventByteBuffer ) ) ) ; receiverNioSelector ( new TransportPoller ( ) ) ; senderNioSelector ( new TransportPoller ( ) ) ; Configuration . validateTermBufferLength ( termBufferLength ( ) ) ; Configuration . validateInitialWindowLength ( initialWindowLength ( ) , mtuLength ( ) ) ; deleteIfExists ( cncFile ( ) ) ; if ( dirsDeleteOnExit ( ) ) { cncFile ( ) . deleteOnExit ( ) ; } cncByteBuffer = mapNewFile ( cncFile ( ) , CncFileDescriptor . computeCncFileLength ( CONDUCTOR_BUFFER_LENGTH + TO_CLIENTS_BUFFER_LENGTH + COUNTER_LABELS_BUFFER_LENGTH + COUNTER_VALUES_BUFFER_LENGTH ) ) ; cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; CncFileDescriptor . fillMetaData ( cncMetaDataBuffer , CONDUCTOR_BUFFER_LENGTH , TO_CLIENTS_BUFFER_LENGTH , COUNTER_LABELS_BUFFER_LENGTH , COUNTER_VALUES_BUFFER_LENGTH ) ; final BroadcastTransmitter transmitter = new BroadcastTransmitter ( CncFileDescriptor . createToClientsBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; clientProxy ( new ClientProxy ( transmitter , eventLogger ) ) ; toDriverCommands ( new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ) ; concludeCounters ( ) ; receiverProxy ( new ReceiverProxy ( threadingMode , receiverCommandQueue ( ) , systemCounters . receiverProxyFails ( ) ) ) ; senderProxy ( new SenderProxy ( threadingMode , senderCommandQueue ( ) , systemCounters . senderProxyFails ( ) ) ) ; fromReceiverDriverConductorProxy ( new DriverConductorProxy ( threadingMode , toConductorFromReceiverCommandQueue , systemCounters . conductorProxyFails ( ) ) ) ; fromSenderDriverConductorProxy ( new DriverConductorProxy ( threadingMode , toConductorFromSenderCommandQueue , systemCounters . conductorProxyFails ( ) ) ) ; rawLogBuffersFactory ( new RawLogFactory ( dirName ( ) , publicationTermBufferLength , maxConnectionTermBufferLength , eventLogger ) ) ; concludeIdleStrategies ( ) ; concludeLossGenerators ( ) ; } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } return this ; } public Context epochClock ( final EpochClock clock ) { this . epochClock = clock ; return this ; } public Context toConductorFromReceiverCommandQueue ( final OneToOneConcurrentArrayQueue < DriverConductorCmd > conductorCommandQueue ) { this . toConductorFromReceiverCommandQueue = conductorCommandQueue ; return this ; } public Context toConductorFromSenderCommandQueue ( final OneToOneConcurrentArrayQueue < DriverConductorCmd > conductorCommandQueue ) { this . toConductorFromSenderCommandQueue = conductorCommandQueue ; return this ; } public Context rawLogBuffersFactory ( final RawLogFactory rawLogFactory ) { this . rawLogFactory = rawLogFactory ; return this ; } public Context receiverNioSelector ( final TransportPoller transportPoller ) { this . receiverTransportPoller = transportPoller ; return this ; } public Context senderNioSelector ( final TransportPoller transportPoller ) { this . senderTransportPoller = transportPoller ; return this ; } public Context unicastSenderFlowControl ( final Supplier < FlowControl > senderFlowControl ) { this . unicastSenderFlowControl = senderFlowControl ; return this ; } public Context multicastSenderFlowControl ( final Supplier < FlowControl > senderFlowControl ) { this . multicastSenderFlowControl = senderFlowControl ; return this ; } public Context conductorTimerWheel ( final TimerWheel timerWheel ) { this . conductorTimerWheel = timerWheel ; return this ; } public Context receiverCommandQueue ( final OneToOneConcurrentArrayQueue < ReceiverCmd > receiverCommandQueue ) { this . receiverCommandQueue = receiverCommandQueue ; return this ; } public Context senderCommandQueue ( final OneToOneConcurrentArrayQueue < SenderCmd > senderCommandQueue ) { this . senderCommandQueue = senderCommandQueue ; return this ; } public Context receiverProxy ( final ReceiverProxy receiverProxy ) { this . receiverProxy = receiverProxy ; return this ; } public Context senderProxy ( final SenderProxy senderProxy ) { this . senderProxy = senderProxy ; return this ; } public Context fromReceiverDriverConductorProxy ( final DriverConductorProxy driverConductorProxy ) { this . fromReceiverDriverConductorProxy = driverConductorProxy ; return this ; } public Context fromSenderDriverConductorProxy ( final DriverConductorProxy driverConductorProxy ) { this . fromSenderDriverConductorProxy = driverConductorProxy ; return this ; } public Context conductorIdleStrategy ( final IdleStrategy strategy ) { this . conductorIdleStrategy = strategy ; return this ; } public Context senderIdleStrategy ( final IdleStrategy strategy ) { this . senderIdleStrategy = strategy ; return this ; } public Context receiverIdleStrategy ( final IdleStrategy strategy ) { this . receiverIdleStrategy = strategy ; return this ; } public Context sharedNetworkIdleStrategy ( final IdleStrategy strategy ) { this . sharedNetworkIdleStrategy = strategy ; return this ; } public Context sharedIdleStrategy ( final IdleStrategy strategy ) { this . sharedIdleStrategy = strategy ; return this ; } public Context clientProxy ( final ClientProxy clientProxy ) { this . clientProxy = clientProxy ; return this ; } public Context toDriverCommands ( final RingBuffer toDriverCommands ) { this . toDriverCommands = toDriverCommands ; return this ; } public Context countersManager ( final CountersManager countersManager ) { this . countersManager = countersManager ; return this ; } public Context termBufferLength ( final int termBufferLength ) { this . publicationTermBufferLength = termBufferLength ; return this ; } public Context termBufferMaxLength ( final int termBufferMaxLength ) { this . maxConnectionTermBufferLength = termBufferMaxLength ; return this ; } public Context initialWindowLength ( final int initialWindowLength ) { this . initialWindowLength = initialWindowLength ; return this ; } public Context statusMessageTimeout ( final long statusMessageTimeout ) { this . statusMessageTimeout = statusMessageTimeout ; return this ; } public Context warnIfDirectoriesExist ( final boolean value ) { this . warnIfDirectoriesExist = value ; return this ; } public Context eventConsumer ( final Consumer < String > value ) { this . eventConsumer = value ; return this ; } public Context eventLogger ( final EventLogger value ) { this . eventLogger = value ; return this ; } public Context toEventReader ( final RingBuffer toEventReader ) { this . toEventReader = toEventReader ; return this ; } public Context eventBufferLength ( final int length ) { this . eventBufferLength = length ; return this ; } public Context dataLossRate ( final double lossRate ) { this . dataLossRate = lossRate ; return this ; } public Context dataLossSeed ( final long lossSeed ) { this . dataLossSeed = lossSeed ; return this ; } public Context controlLossRate ( final double lossRate ) { this . controlLossRate = lossRate ; return this ; } public Context controlLossSeed ( final long lossSeed ) { this . controlLossSeed = lossSeed ; return this ; } public Context systemCounters ( final SystemCounters systemCounters ) { this . systemCounters = systemCounters ; return this ; } public Context threadingMode ( final ThreadingMode threadingMode ) { this . threadingMode = threadingMode ; return this ; } public Context dataLossGenerator ( final LossGenerator generator ) { this . dataLossGenerator = generator ; return this ; } public Context controlLossGenerator ( final LossGenerator generator ) { this . controlLossGenerator = generator ; return this ; } public Context dirsDeleteOnExit ( final boolean dirsDeleteOnExit ) { this . dirsDeleteOnExit = dirsDeleteOnExit ; return this ; } public EpochClock epochClock ( ) { return epochClock ; } public OneToOneConcurrentArrayQueue < DriverConductorCmd > toConductorFromReceiverCommandQueue ( ) { return toConductorFromReceiverCommandQueue ; } public OneToOneConcurrentArrayQueue < DriverConductorCmd > toConductorFromSenderCommandQueue ( ) { return toConductorFromSenderCommandQueue ; } public RawLogFactory rawLogBuffersFactory ( ) { return rawLogFactory ; } public TransportPoller receiverNioSelector ( ) { return receiverTransportPoller ; } public TransportPoller senderNioSelector ( ) { return senderTransportPoller ; } public Supplier < FlowControl > unicastSenderFlowControl ( ) { return unicastSenderFlowControl ; } public Supplier < FlowControl > multicastSenderFlowControl ( ) { return multicastSenderFlowControl ; } public TimerWheel conductorTimerWheel ( ) { return conductorTimerWheel ; } public OneToOneConcurrentArrayQueue < ReceiverCmd > receiverCommandQueue ( ) { return receiverCommandQueue ; } public OneToOneConcurrentArrayQueue < SenderCmd > senderCommandQueue ( ) { return senderCommandQueue ; } public ReceiverProxy receiverProxy ( ) { return receiverProxy ; } public SenderProxy senderProxy ( ) { return senderProxy ; } public DriverConductorProxy fromReceiverDriverConductorProxy ( ) { return fromReceiverDriverConductorProxy ; } public DriverConductorProxy fromSenderDriverConductorProxy ( ) { return fromSenderDriverConductorProxy ; } public IdleStrategy conductorIdleStrategy ( ) { return conductorIdleStrategy ; } public IdleStrategy senderIdleStrategy ( ) { return senderIdleStrategy ; } public IdleStrategy receiverIdleStrategy ( ) { return receiverIdleStrategy ; } public IdleStrategy sharedNetworkIdleStrategy ( ) { return sharedNetworkIdleStrategy ; } public IdleStrategy sharedIdleStrategy ( ) { return sharedIdleStrategy ; } public ClientProxy clientProxy ( ) { return clientProxy ; } public RingBuffer toDriverCommands ( ) { return toDriverCommands ; } public CountersManager countersManager ( ) { return countersManager ; } public int termBufferLength ( ) { return publicationTermBufferLength ; } public int termBufferMaxLength ( ) { return maxConnectionTermBufferLength ; } public int initialWindowLength ( ) { return initialWindowLength ; } public long statusMessageTimeout ( ) { return statusMessageTimeout ; } public boolean warnIfDirectoriesExist ( ) { return warnIfDirectoriesExist ; } public EventLogger eventLogger ( ) { return eventLogger ; } public Consumer < Throwable > exceptionConsumer ( ) { return eventLogger : : logException ; } public double dataLossRate ( ) { return dataLossRate ; } public long dataLossSeed ( ) { return dataLossSeed ; } public double controlLossRate ( ) { return controlLossRate ; } public long controlLossSeed ( ) { return controlLossSeed ; } public int mtuLength ( ) { return mtuLength ; } public LossGenerator dataLossGenerator ( ) { return dataLossGenerator ; } public LossGenerator controlLossGenerator ( ) { return controlLossGenerator ; } public CommonContext mtuLength ( final int mtuLength ) { this . mtuLength = mtuLength ; return this ; } public SystemCounters systemCounters ( ) { return systemCounters ; } public boolean dirsDeleteOnExit ( ) { return dirsDeleteOnExit ; } public Consumer < String > eventConsumer ( ) { return eventConsumer ; } public int eventBufferLength ( ) { return eventBufferLength ; } public RingBuffer toEventReader ( ) { return toEventReader ; } public void close ( ) { if ( null != systemCounters ) { systemCounters . close ( ) ; } IoUtil . unmap ( cncByteBuffer ) ; super . close ( ) ; } private void concludeCounters ( ) { if ( countersManager ( ) == null ) { if ( counterLabelsBuffer ( ) == null ) { counterLabelsBuffer ( CncFileDescriptor . createCounterLabelsBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; } if ( countersBuffer ( ) == null ) { countersBuffer ( CncFileDescriptor . createCounterValuesBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; } countersManager ( new CountersManager ( counterLabelsBuffer ( ) , countersBuffer ( ) ) ) ; } if ( null == systemCounters ) { systemCounters = new SystemCounters ( countersManager ) ; } } private void concludeIdleStrategies ( ) { if ( null == conductorIdleStrategy ) { conductorIdleStrategy ( Configuration . agentIdleStrategy ( ) ) ; } if ( null == senderIdleStrategy ) { senderIdleStrategy ( Configuration . agentIdleStrategy ( ) ) ; } if ( null == receiverIdleStrategy ) { receiverIdleStrategy ( Configuration . agentIdleStrategy ( ) ) ; } if ( null == sharedNetworkIdleStrategy ) { sharedNetworkIdleStrategy ( Configuration . agentIdleStrategy ( ) ) ; } if ( null == sharedIdleStrategy ) { sharedIdleStrategy ( Configuration . agentIdleStrategy ( ) ) ; } } private void concludeLossGenerators ( ) { if ( null == dataLossGenerator ) { dataLossGenerator ( Configuration . createLossGenerator ( dataLossRate , dataLossSeed ) ) ; } if ( null == controlLossGenerator ) { controlLossGenerator ( Configuration . createLossGenerator ( controlLossRate , controlLossSeed ) ) ; } } } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; public class PendingSetupMessageFromSource { private final int sessionId ; private final int streamId ; private final ReceiveChannelEndpoint channelEndpoint ; private long timeOfStatusMessage ; public PendingSetupMessageFromSource ( final int sessionId , final int streamId , final ReceiveChannelEndpoint channelEndpoint ) { this . sessionId = sessionId ; this . streamId = streamId ; this . channelEndpoint = channelEndpoint ; } public int sessionId ( ) { return sessionId ; } public int streamId ( ) { return streamId ; } public ReceiveChannelEndpoint channelEndpoint ( ) { return channelEndpoint ; } public long timeOfStatusMessage ( ) { return timeOfStatusMessage ; } public void timeOfStatusMessage ( final long now ) { timeOfStatusMessage = now ; } }
package uk . co . real_logic . aeron . driver ; public class Strings { public static boolean isEmpty ( final String value ) { return null == value || value . isEmpty ( ) ; } public static int parseIntOrDefault ( final String value , final int defaultValue ) { if ( null == value ) { return defaultValue ; } return Integer . parseInt ( value ) ; } }
package uk . co . real_logic . aeron . tools ; public interface StatsOutput { void format ( String [ ] keys , long [ ] vals ) throws Exception ; void close ( ) throws Exception ; }
package uk . co . real_logic . aeron . driver ; import static uk . co . real_logic . aeron . driver . Configuration . CLIENT_LIVENESS_TIMEOUT_NS ; public class AeronClient { private final long clientId ; private long timeOfLastKeepalive ; public AeronClient ( final long clientId , final long now ) { this . clientId = clientId ; this . timeOfLastKeepalive = now ; } public long clientId ( ) { return clientId ; } public long timeOfLastKeepalive ( ) { return timeOfLastKeepalive ; } public void timeOfLastKeepalive ( final long now ) { timeOfLastKeepalive = now ; } public boolean hasTimedOut ( final long now ) { return now > ( timeOfLastKeepalive + CLIENT_LIVENESS_TIMEOUT_NS ) ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . protocol . SetupFlyweight ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . net . InetSocketAddress ; @ FunctionalInterface public interface SetupMessageHandler { void onSetupMessage ( SetupFlyweight header , UnsafeBuffer buffer , int length , InetSocketAddress srcAddress ) ; }
package uk . co . real_logic . aeron . driver ; import java . net . InetSocketAddress ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . computePosition ; public class MaxMulticastFlowControl implements FlowControl { private long positionLimit = 0 ; private int positionBitsToShift ; private int initialTermId ; public long onStatusMessage ( final int termId , final int rebuildTermOffset , final int receiverWindowLength , final InetSocketAddress address ) { final long position = computePosition ( termId , rebuildTermOffset , positionBitsToShift , initialTermId ) ; final long newPositionLimit = position + receiverWindowLength ; positionLimit = Math . max ( positionLimit , newPositionLimit ) ; return positionLimit ; } public long initialPositionLimit ( final int initialTermId , final int termBufferCapacity ) { this . initialTermId = initialTermId ; positionBitsToShift = Long . numberOfTrailingZeros ( termBufferCapacity ) ; positionLimit = computePosition ( initialTermId , 0 , positionBitsToShift , initialTermId ) ; return positionLimit ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . driver . cmd . * ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; import uk . co . real_logic . agrona . concurrent . AtomicCounter ; import java . util . Queue ; import static uk . co . real_logic . aeron . driver . ThreadingMode . SHARED ; public class ReceiverProxy { private final ThreadingMode threadingMode ; private final Queue < ReceiverCmd > commandQueue ; private final AtomicCounter failCount ; private Receiver receiver ; public ReceiverProxy ( final ThreadingMode threadingMode , final Queue < ReceiverCmd > commandQueue , final AtomicCounter failCount ) { this . threadingMode = threadingMode ; this . commandQueue = commandQueue ; this . failCount = failCount ; } public void receiver ( final Receiver receiver ) { this . receiver = receiver ; } public Receiver receiver ( ) { return receiver ; } public void addSubscription ( final ReceiveChannelEndpoint mediaEndpoint , final int streamId ) { if ( isSharedThread ( ) ) { receiver . onAddSubscription ( mediaEndpoint , streamId ) ; } else { offer ( new AddSubscriptionCmd ( mediaEndpoint , streamId ) ) ; } } public void removeSubscription ( final ReceiveChannelEndpoint mediaEndpoint , final int streamId ) { if ( isSharedThread ( ) ) { receiver . onRemoveSubscription ( mediaEndpoint , streamId ) ; } else { offer ( new RemoveSubscriptionCmd ( mediaEndpoint , streamId ) ) ; } } public void newConnection ( final ReceiveChannelEndpoint channelEndpoint , final NetworkConnection connection ) { if ( isSharedThread ( ) ) { receiver . onNewConnection ( channelEndpoint , connection ) ; } else { offer ( new NewConnectionCmd ( channelEndpoint , connection ) ) ; } } public void registerReceiveChannelEndpoint ( final ReceiveChannelEndpoint channelEndpoint ) { if ( isSharedThread ( ) ) { receiver . onRegisterReceiveChannelEndpoint ( channelEndpoint ) ; } else { offer ( new RegisterReceiveChannelEndpointCmd ( channelEndpoint ) ) ; } } public void closeReceiveChannelEndpoint ( final ReceiveChannelEndpoint channelEndpoint ) { if ( isSharedThread ( ) ) { receiver . onCloseReceiveChannelEndpoint ( channelEndpoint ) ; } else { offer ( new CloseReceiveChannelEndpointCmd ( channelEndpoint ) ) ; } } private boolean isSharedThread ( ) { return threadingMode == SHARED ; } private void offer ( final ReceiverCmd cmd ) { while ( ! commandQueue . offer ( cmd ) ) { failCount . orderedIncrement ( ) ; Thread . yield ( ) ; } } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . logbuffer . TermRebuilder ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . driver . buffer . RawLog ; import uk . co . real_logic . aeron . driver . buffer . RawLogPartition ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . concurrent . NanoClock ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . status . Position ; import uk . co . real_logic . agrona . concurrent . status . ReadablePosition ; import java . net . InetSocketAddress ; import java . util . List ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . * ; import static uk . co . real_logic . aeron . driver . NetworkConnection . Status . ACTIVE ; class NetworkConnectionPadding1 { @ SuppressWarnings ( "unused" ) protected long p1 , p2 , p3 , p4 , p5 , p6 , p7 , p8 , p9 , p10 , p11 , p12 , p13 , p14 , p15 ; } class NetworkConnectionConductorFields extends NetworkConnectionPadding1 { protected long timeOfLastStatusChange ; protected long rebuildPosition ; protected volatile long beginLossChange = - 1 ; protected volatile long endLossChange = - 1 ; protected int lossTermId ; protected int lossTermOffset ; protected int lossLength ; } class NetworkConnectionPadding2 extends NetworkConnectionConductorFields { @ SuppressWarnings ( "unused" ) protected long p16 , p17 , p18 , p19 , p20 , p21 , p22 , p23 , p24 , p25 , p26 , p27 , p28 , p29 , p30 ; } class NetworkConnectionHotFields extends NetworkConnectionPadding2 { protected long lastPacketTimestamp ; protected long lastStatusMessageTimestamp ; protected long lastStatusMessagePosition ; protected long lastChangeNumber = - 1 ; } class NetworkConnectionPadding3 extends NetworkConnectionHotFields { @ SuppressWarnings ( "unused" ) protected long p31 , p32 , p33 , p34 , p35 , p36 , p37 , p38 , p39 , p40 , p41 , p42 , p43 , p44 , p45 ; } class NetworkConnectionStatusFields extends NetworkConnectionPadding3 { protected volatile long newStatusMessagePosition ; protected volatile NetworkConnection . Status status = NetworkConnection . Status . INIT ; } class NetworkConnectionPadding4 extends NetworkConnectionStatusFields { @ SuppressWarnings ( "unused" ) protected long p46 , p47 , p48 , p49 , p50 , p51 , p52 , p53 , p54 , p55 , p56 , p57 , p58 , p59 , p60 ; } public class NetworkConnection extends NetworkConnectionPadding4 implements AutoCloseable , NakMessageSender { public enum Status { INIT , ACTIVE , INACTIVE , LINGER } private final long correlationId ; private final int sessionId ; private final int streamId ; private final int positionBitsToShift ; private final int termLengthMask ; private final int initialTermId ; private final int currentWindowLength ; private final int currentGain ; private final RawLog rawLog ; private final InetSocketAddress controlAddress ; private final InetSocketAddress sourceAddress ; private final ReceiveChannelEndpoint channelEndpoint ; private final SystemCounters systemCounters ; private final NanoClock clock ; private final UnsafeBuffer [ ] termBuffers ; private final Position hwmPosition ; private final List < ReadablePosition > subscriberPositions ; private final LossDetector lossDetector ; public NetworkConnection ( final long correlationId , final ReceiveChannelEndpoint channelEndpoint , final InetSocketAddress controlAddress , final int sessionId , final int streamId , final int initialTermId , final int activeTermId , final int initialTermOffset , final int initialWindowLength , final RawLog rawLog , final TimerWheel timerwheel , final FeedbackDelayGenerator lossFeedbackDelayGenerator , final List < ReadablePosition > subscriberPositions , final Position hwmPosition , final NanoClock clock , final SystemCounters systemCounters , final InetSocketAddress sourceAddress ) { this . correlationId = correlationId ; this . channelEndpoint = channelEndpoint ; this . controlAddress = controlAddress ; this . sessionId = sessionId ; this . streamId = streamId ; this . rawLog = rawLog ; this . subscriberPositions = subscriberPositions ; this . hwmPosition = hwmPosition ; this . systemCounters = systemCounters ; this . sourceAddress = sourceAddress ; this . clock = clock ; final long time = clock . nanoTime ( ) ; this . timeOfLastStatusChange = time ; this . lastPacketTimestamp = time ; termBuffers = rawLog . stream ( ) . map ( RawLogPartition : : termBuffer ) . toArray ( UnsafeBuffer [ ] : : new ) ; this . lossDetector = new LossDetector ( timerwheel , lossFeedbackDelayGenerator , this ) ; final int termCapacity = termBuffers [ 0 ] . capacity ( ) ; this . currentWindowLength = Math . min ( termCapacity , initialWindowLength ) ; this . currentGain = Math . min ( currentWindowLength / 4 , termCapacity / 4 ) ; this . termLengthMask = termCapacity - 1 ; this . positionBitsToShift = Integer . numberOfTrailingZeros ( termCapacity ) ; this . initialTermId = initialTermId ; final long initialPosition = computePosition ( activeTermId , initialTermOffset , positionBitsToShift , initialTermId ) ; this . lastStatusMessagePosition = initialPosition - ( currentGain + 1 ) ; this . newStatusMessagePosition = this . lastStatusMessagePosition ; this . rebuildPosition = initialPosition ; this . hwmPosition . setOrdered ( initialPosition ) ; } public void close ( ) { hwmPosition . close ( ) ; rawLog . close ( ) ; subscriberPositions . forEach ( ReadablePosition : : close ) ; } public long correlationId ( ) { return correlationId ; } public int sessionId ( ) { return sessionId ; } public int streamId ( ) { return streamId ; } public String channelUriString ( ) { return channelEndpoint . originalUriString ( ) ; } public InetSocketAddress sourceAddress ( ) { return sourceAddress ; } public void removeFromDispatcher ( ) { channelEndpoint . dispatcher ( ) . removeConnection ( this ) ; } public boolean matches ( final ReceiveChannelEndpoint channelEndpoint , final int streamId ) { return this . streamId == streamId && this . channelEndpoint == channelEndpoint ; } public RawLog rawLog ( ) { return rawLog ; } public Status status ( ) { return status ; } public void status ( final Status status ) { timeOfLastStatusChange = clock . nanoTime ( ) ; this . status = status ; } public void ifActiveGoInactive ( ) { if ( Status . ACTIVE == this . status ) { status ( Status . INACTIVE ) ; } } public long timeOfLastStatusChange ( ) { return timeOfLastStatusChange ; } public boolean isDrained ( ) { long subscriberPosition = Long . MAX_VALUE ; final List < ReadablePosition > subscriberPositions = this . subscriberPositions ; for ( int i = 0 , size = subscriberPositions . size ( ) ; i < size ; i ++ ) { subscriberPosition = Math . min ( subscriberPosition , subscriberPositions . get ( i ) . getVolatile ( ) ) ; } return subscriberPosition >= rebuildPosition ; } public void onLossDetected ( final int termId , final int termOffset , final int length ) { final long changeNumber = beginLossChange + 1 ; beginLossChange = changeNumber ; lossTermId = termId ; lossTermOffset = termOffset ; lossLength = length ; endLossChange = changeNumber ; } public int trackRebuild ( ) { long minSubscriberPosition = Long . MAX_VALUE ; long maxSubscriberPosition = Long . MIN_VALUE ; final List < ReadablePosition > subscriberPositions = this . subscriberPositions ; for ( int i = 0 , size = subscriberPositions . size ( ) ; i < size ; i ++ ) { final long position = subscriberPositions . get ( i ) . getVolatile ( ) ; minSubscriberPosition = Math . min ( minSubscriberPosition , position ) ; maxSubscriberPosition = Math . max ( maxSubscriberPosition , position ) ; } final long oldRebuildPosition = this . rebuildPosition ; final long rebuildPosition = Math . max ( oldRebuildPosition , maxSubscriberPosition ) ; final int positionBitsToShift = this . positionBitsToShift ; final int index = indexByPosition ( rebuildPosition , positionBitsToShift ) ; final int workCount = lossDetector . scan ( termBuffers [ index ] , rebuildPosition , hwmPosition . getVolatile ( ) , termLengthMask , positionBitsToShift , initialTermId ) ; final int rebuildTermOffset = ( int ) rebuildPosition & termLengthMask ; final long newRebuildPosition = ( rebuildPosition - rebuildTermOffset ) + lossDetector . rebuildOffset ( ) ; this . rebuildPosition = newRebuildPosition ; final int newTermCount = ( int ) ( newRebuildPosition > > > positionBitsToShift ) ; final int oldTermCount = ( int ) ( oldRebuildPosition > > > positionBitsToShift ) ; if ( newTermCount > oldTermCount ) { final int oldTermCountIndex = indexByTermCount ( oldTermCount ) ; final UnsafeBuffer termBuffer = termBuffers [ previousPartitionIndex ( oldTermCountIndex ) ] ; termBuffer . setMemory ( 0 , termBuffer . capacity ( ) , ( byte ) 0 ) ; } if ( minSubscriberPosition > ( newStatusMessagePosition + currentGain ) ) { newStatusMessagePosition = minSubscriberPosition ; } return workCount ; } public int insertPacket ( final int termId , final int termOffset , final UnsafeBuffer buffer , final int length ) { int bytesReceived = length ; final int positionBitsToShift = this . positionBitsToShift ; final long packetPosition = computePosition ( termId , termOffset , positionBitsToShift , initialTermId ) ; final long proposedPosition = packetPosition + length ; final long windowPosition = lastStatusMessagePosition ; if ( isHeartbeat ( buffer , length ) ) { hwmCandidate ( packetPosition ) ; systemCounters . heartbeatsReceived ( ) . orderedIncrement ( ) ; } else if ( isFlowControlUnderRun ( windowPosition , packetPosition ) || isFlowControlOverRun ( windowPosition , proposedPosition ) ) { bytesReceived = 0 ; } else { final UnsafeBuffer termBuffer = termBuffers [ indexByPosition ( packetPosition , positionBitsToShift ) ] ; TermRebuilder . insert ( termBuffer , termOffset , buffer , length ) ; hwmCandidate ( proposedPosition ) ; } return bytesReceived ; } public boolean checkForActivity ( final long now , final long connectionLivenessTimeout ) { boolean activity = true ; if ( now > ( lastPacketTimestamp + connectionLivenessTimeout ) ) { activity = false ; } return activity ; } public int sendPendingStatusMessage ( final long now , final long statusMessageTimeout ) { int workCount = 0 ; if ( ACTIVE == status ) { final long statusMessagePosition = this . newStatusMessagePosition ; if ( statusMessagePosition != lastStatusMessagePosition || now > ( lastStatusMessageTimestamp + statusMessageTimeout ) ) { final int termId = computeTermIdFromPosition ( statusMessagePosition , positionBitsToShift , initialTermId ) ; final int termOffset = ( int ) statusMessagePosition & termLengthMask ; channelEndpoint . sendStatusMessage ( controlAddress , sessionId , streamId , termId , termOffset , currentWindowLength , ( byte ) 0 ) ; lastStatusMessageTimestamp = now ; lastStatusMessagePosition = statusMessagePosition ; systemCounters . statusMessagesSent ( ) . orderedIncrement ( ) ; workCount = 1 ; } } return workCount ; } public int sendPendingNak ( ) { int workCount = 0 ; final long changeNumber = endLossChange ; if ( changeNumber != lastChangeNumber ) { final int termId = lossTermId ; final int termOffset = lossTermOffset ; final int length = lossLength ; if ( changeNumber == beginLossChange ) { channelEndpoint . sendNakMessage ( controlAddress , sessionId , streamId , termId , termOffset , length ) ; lastChangeNumber = changeNumber ; systemCounters . nakMessagesSent ( ) . orderedIncrement ( ) ; workCount = 1 ; } } return workCount ; } public void removeSubscriber ( final ReadablePosition subscriberPosition ) { subscriberPositions . remove ( subscriberPosition ) ; subscriberPosition . close ( ) ; } public void addSubscriber ( final ReadablePosition subscriberPosition ) { subscriberPositions . add ( subscriberPosition ) ; } public long rebuildPosition ( ) { return rebuildPosition ; } private boolean isHeartbeat ( final UnsafeBuffer buffer , final int length ) { return length == DataHeaderFlyweight . HEADER_LENGTH && buffer . getInt ( 0 ) == 0 ; } private void hwmCandidate ( final long proposedPosition ) { lastPacketTimestamp = clock . nanoTime ( ) ; hwmPosition . proposeMaxOrdered ( proposedPosition ) ; } private boolean isFlowControlUnderRun ( final long windowPosition , final long packetPosition ) { final boolean isFlowControlUnderRun = packetPosition < windowPosition ; if ( isFlowControlUnderRun ) { systemCounters . flowControlUnderRuns ( ) . orderedIncrement ( ) ; } return isFlowControlUnderRun ; } private boolean isFlowControlOverRun ( final long windowPosition , final long proposedPosition ) { final boolean isFlowControlOverRun = proposedPosition > ( windowPosition + currentWindowLength ) ; if ( isFlowControlOverRun ) { systemCounters . flowControlOverRuns ( ) . orderedIncrement ( ) ; } return isFlowControlOverRun ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . Flyweight ; import uk . co . real_logic . aeron . command . CorrelatedMessageFlyweight ; import uk . co . real_logic . aeron . command . PublicationMessageFlyweight ; import uk . co . real_logic . aeron . command . RemoveMessageFlyweight ; import uk . co . real_logic . aeron . command . SubscriptionMessageFlyweight ; import uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor ; import uk . co . real_logic . aeron . driver . event . EventCode ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . driver . MediaDriver . Context ; import uk . co . real_logic . aeron . driver . buffer . RawLog ; import uk . co . real_logic . aeron . driver . buffer . RawLogFactory ; import uk . co . real_logic . aeron . driver . cmd . DriverConductorCmd ; import uk . co . real_logic . aeron . driver . exceptions . ControlProtocolException ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; import uk . co . real_logic . aeron . driver . media . SendChannelEndpoint ; import uk . co . real_logic . aeron . driver . media . UdpChannel ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . concurrent . * ; import uk . co . real_logic . agrona . concurrent . ringbuffer . RingBuffer ; import uk . co . real_logic . agrona . concurrent . status . Position ; import uk . co . real_logic . agrona . concurrent . status . UnsafeBufferPosition ; import java . net . InetSocketAddress ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . concurrent . TimeUnit ; import java . util . function . Consumer ; import java . util . function . Supplier ; import static java . util . stream . Collectors . toList ; import static uk . co . real_logic . aeron . ErrorCode . * ; import static uk . co . real_logic . aeron . command . ControlProtocolEvents . * ; import static uk . co . real_logic . aeron . driver . event . EventConfiguration . EVENT_READER_FRAME_LIMIT ; import static uk . co . real_logic . aeron . driver . Configuration . * ; public class DriverConductor implements Agent { private final int mtuLength ; private final int termBufferLength ; private final int initialWindowLength ; private final RawLogFactory rawLogFactory ; private final ReceiverProxy receiverProxy ; private final SenderProxy senderProxy ; private final ClientProxy clientProxy ; private final DriverConductorProxy fromReceiverConductorProxy ; private final RingBuffer toDriverCommands ; private final RingBuffer toEventReader ; private final OneToOneConcurrentArrayQueue < DriverConductorCmd > fromReceiverDriverConductorCmdQueue ; private final OneToOneConcurrentArrayQueue < DriverConductorCmd > fromSenderDriverConductorCmdQueue ; private final Supplier < FlowControl > unicastFlowControl ; private final Supplier < FlowControl > multicastFlowControl ; private final HashMap < String , SendChannelEndpoint > sendChannelEndpointByChannelMap = new HashMap < > ( ) ; private final HashMap < String , ReceiveChannelEndpoint > receiveChannelEndpointByChannelMap = new HashMap < > ( ) ; private final ArrayList < PublicationLink > publicationLinks = new ArrayList < > ( ) ; private final ArrayList < NetworkPublication > publications = new ArrayList < > ( ) ; private final ArrayList < SubscriptionLink > subscriptionLinks = new ArrayList < > ( ) ; private final ArrayList < NetworkConnection > connections = new ArrayList < > ( ) ; private final ArrayList < AeronClient > clients = new ArrayList < > ( ) ; private final PublicationMessageFlyweight publicationMsgFlyweight = new PublicationMessageFlyweight ( ) ; private final SubscriptionMessageFlyweight subscriptionMsgFlyweight = new SubscriptionMessageFlyweight ( ) ; private final CorrelatedMessageFlyweight correlatedMsgFlyweight = new CorrelatedMessageFlyweight ( ) ; private final RemoveMessageFlyweight removeMsgFlyweight = new RemoveMessageFlyweight ( ) ; private final EpochClock epochClock ; private final NanoClock nanoClock ; private final TimerWheel timerWheel ; private final TimerWheel . Timer checkTimeoutTimer ; private final SystemCounters systemCounters ; private final UnsafeBuffer countersBuffer ; private final CountersManager countersManager ; private final EventLogger logger ; private final Consumer < DriverConductorCmd > onDriverConductorCmdFunc = this : : onDriverConductorCmd ; private final MessageHandler onClientCommandFunc = this : : onClientCommand ; private final MessageHandler onEventFunc ; private final LossGenerator dataLossGenerator ; private final LossGenerator controlLossGenerator ; public DriverConductor ( final Context ctx ) { fromReceiverDriverConductorCmdQueue = ctx . toConductorFromReceiverCommandQueue ( ) ; fromSenderDriverConductorCmdQueue = ctx . toConductorFromSenderCommandQueue ( ) ; receiverProxy = ctx . receiverProxy ( ) ; senderProxy = ctx . senderProxy ( ) ; rawLogFactory = ctx . rawLogBuffersFactory ( ) ; mtuLength = ctx . mtuLength ( ) ; initialWindowLength = ctx . initialWindowLength ( ) ; termBufferLength = ctx . termBufferLength ( ) ; unicastFlowControl = ctx . unicastSenderFlowControl ( ) ; multicastFlowControl = ctx . multicastSenderFlowControl ( ) ; countersManager = ctx . countersManager ( ) ; countersBuffer = ctx . countersBuffer ( ) ; timerWheel = ctx . conductorTimerWheel ( ) ; epochClock = ctx . epochClock ( ) ; nanoClock = timerWheel . clock ( ) ; toDriverCommands = ctx . toDriverCommands ( ) ; toEventReader = ctx . toEventReader ( ) ; clientProxy = ctx . clientProxy ( ) ; fromReceiverConductorProxy = ctx . fromReceiverDriverConductorProxy ( ) ; logger = ctx . eventLogger ( ) ; systemCounters = ctx . systemCounters ( ) ; checkTimeoutTimer = timerWheel . newTimeout ( HEARTBEAT_TIMEOUT_MS , TimeUnit . MILLISECONDS , this : : onHeartbeatCheckTimeouts ) ; dataLossGenerator = ctx . dataLossGenerator ( ) ; controlLossGenerator = ctx . controlLossGenerator ( ) ; final Consumer < String > eventConsumer = ctx . eventConsumer ( ) ; onEventFunc = ( typeId , buffer , offset , length ) - > eventConsumer . accept ( EventCode . get ( typeId ) . decode ( buffer , offset , length ) ) ; final AtomicBuffer buffer = toDriverCommands . buffer ( ) ; publicationMsgFlyweight . wrap ( buffer , 0 ) ; subscriptionMsgFlyweight . wrap ( buffer , 0 ) ; correlatedMsgFlyweight . wrap ( buffer , 0 ) ; removeMsgFlyweight . wrap ( buffer , 0 ) ; toDriverCommands . consumerHeartbeatTime ( nanoClock . nanoTime ( ) ) ; } private static AeronClient findClient ( final ArrayList < AeronClient > clients , final long clientId ) { AeronClient aeronClient = null ; for ( int i = 0 , size = clients . size ( ) ; i < size ; i ++ ) { final AeronClient client = clients . get ( i ) ; if ( client . clientId ( ) == clientId ) { aeronClient = client ; break ; } } return aeronClient ; } private static PublicationLink findPublicationLink ( final ArrayList < PublicationLink > publicationLinks , final long registrationId ) { PublicationLink publicationLink = null ; for ( int i = 0 , size = publicationLinks . size ( ) ; i < size ; i ++ ) { final PublicationLink link = publicationLinks . get ( i ) ; if ( registrationId == link . registrationId ( ) ) { publicationLink = link ; break ; } } return publicationLink ; } private static String generateSourceIdentity ( final InetSocketAddress address ) { return String . format ( "%s:%d" , address . getHostString ( ) , address . getPort ( ) ) ; } private static SubscriptionLink removeSubscription ( final ArrayList < SubscriptionLink > subscriptions , final long registrationId ) { SubscriptionLink subscription = null ; for ( int i = 0 , size = subscriptions . size ( ) ; i < size ; i ++ ) { subscription = subscriptions . get ( i ) ; if ( subscription . registrationId ( ) == registrationId ) { subscriptions . remove ( i ) ; break ; } } return subscription ; } public void onClose ( ) { rawLogFactory . close ( ) ; publications . forEach ( NetworkPublication : : close ) ; connections . forEach ( NetworkConnection : : close ) ; sendChannelEndpointByChannelMap . values ( ) . forEach ( SendChannelEndpoint : : close ) ; receiveChannelEndpointByChannelMap . values ( ) . forEach ( ReceiveChannelEndpoint : : close ) ; } public String roleName ( ) { return "driver-conductor" ; } public SendChannelEndpoint senderChannelEndpoint ( final UdpChannel channel ) { return sendChannelEndpointByChannelMap . get ( channel . canonicalForm ( ) ) ; } public ReceiveChannelEndpoint receiverChannelEndpoint ( final UdpChannel channel ) { return receiveChannelEndpointByChannelMap . get ( channel . canonicalForm ( ) ) ; } public int doWork ( ) throws Exception { int workCount = 0 ; workCount += toDriverCommands . read ( onClientCommandFunc ) ; workCount += fromReceiverDriverConductorCmdQueue . drain ( onDriverConductorCmdFunc ) ; workCount += fromSenderDriverConductorCmdQueue . drain ( onDriverConductorCmdFunc ) ; workCount += toEventReader . read ( onEventFunc , EVENT_READER_FRAME_LIMIT ) ; workCount += processTimers ( ) ; final ArrayList < NetworkConnection > connections = this . connections ; for ( int i = 0 , size = connections . size ( ) ; i < size ; i ++ ) { final NetworkConnection connection = connections . get ( i ) ; workCount += connection . trackRebuild ( ) ; } final ArrayList < NetworkPublication > publications = this . publications ; for ( int i = 0 , size = publications . size ( ) ; i < size ; i ++ ) { final NetworkPublication publication = publications . get ( i ) ; workCount += publication . updatePublishersLimit ( ) + publication . cleanLogBuffer ( ) ; } return workCount ; } private void onHeartbeatCheckTimeouts ( ) { toDriverCommands . consumerHeartbeatTime ( epochClock . time ( ) ) ; final long now = nanoClock . nanoTime ( ) ; onCheckClients ( now ) ; onCheckPublications ( now ) ; onCheckPublicationLinks ( now ) ; onCheckConnections ( now ) ; onCheckSubscriptionLinks ( now ) ; timerWheel . rescheduleTimeout ( HEARTBEAT_TIMEOUT_MS , TimeUnit . MILLISECONDS , checkTimeoutTimer ) ; } public void onCreateConnection ( final int sessionId , final int streamId , final int initialTermId , final int activeTermId , final int initialTermOffset , final int termBufferLength , final int senderMtuLength , final InetSocketAddress controlAddress , final InetSocketAddress sourceAddress , final ReceiveChannelEndpoint channelEndpoint ) { channelEndpoint . validateSenderMtuLength ( senderMtuLength ) ; channelEndpoint . validateWindowMaxLength ( initialWindowLength ) ; final UdpChannel udpChannel = channelEndpoint . udpChannel ( ) ; final String channel = udpChannel . originalUriString ( ) ; final long correlationId = generateCreationCorrelationId ( ) ; final long joiningPosition = LogBufferDescriptor . computePosition ( activeTermId , initialTermOffset , Integer . numberOfTrailingZeros ( termBufferLength ) , initialTermId ) ; final List < SubscriberPosition > subscriberPositions = listSubscriberPositions ( sessionId , streamId , channelEndpoint , channel , joiningPosition ) ; if ( subscriberPositions . size ( ) > 0 ) { final RawLog rawLog = newConnectionLog ( sessionId , streamId , initialTermId , termBufferLength , senderMtuLength , udpChannel , correlationId ) ; final NetworkConnection connection = new NetworkConnection ( correlationId , channelEndpoint , controlAddress , sessionId , streamId , initialTermId , activeTermId , initialTermOffset , initialWindowLength , rawLog , timerWheel , Configuration . doNotSendNaks ( ) ? NO_NAK_DELAY_GENERATOR : udpChannel . isMulticast ( ) ? NAK_MULTICAST_DELAY_GENERATOR : NAK_UNICAST_DELAY_GENERATOR , subscriberPositions . stream ( ) . map ( SubscriberPosition : : position ) . collect ( toList ( ) ) , newPosition ( "receiver hwm" , channel , sessionId , streamId , correlationId ) , nanoClock , systemCounters , sourceAddress ) ; subscriberPositions . forEach ( ( subscriberPosition ) - > subscriberPosition . subscription ( ) . addConnection ( connection , subscriberPosition . position ( ) ) ) ; connections . add ( connection ) ; receiverProxy . newConnection ( channelEndpoint , connection ) ; clientProxy . onConnectionReady ( streamId , sessionId , joiningPosition , rawLog , correlationId , subscriberPositions , generateSourceIdentity ( sourceAddress ) ) ; } } public void onCloseResource ( final AutoCloseable resource ) { try { resource . close ( ) ; } catch ( final Exception ex ) { logger . logException ( ex ) ; } } public List < SubscriberPosition > listSubscriberPositions ( final int sessionId , final int streamId , final ReceiveChannelEndpoint channelEndpoint , final String channel , final long joiningPosition ) { return subscriptionLinks . stream ( ) . filter ( ( subscription ) - > subscription . matches ( channelEndpoint , streamId ) ) . map ( ( subscription ) - > { final Position position = newPosition ( "subscriber pos" , channel , sessionId , streamId , subscription . registrationId ( ) ) ; position . setOrdered ( joiningPosition ) ; return new SubscriberPosition ( subscription , position ) ; } ) . collect ( toList ( ) ) ; } private void onClientCommand ( final int msgTypeId , final MutableDirectBuffer buffer , final int index , final int length ) { Flyweight flyweight = null ; try { switch ( msgTypeId ) { case ADD_PUBLICATION : { logger . log ( EventCode . CMD_IN_ADD_PUBLICATION , buffer , index , length ) ; final PublicationMessageFlyweight publicationMessageFlyweight = publicationMsgFlyweight ; publicationMessageFlyweight . offset ( index ) ; flyweight = publicationMessageFlyweight ; onAddPublication ( publicationMessageFlyweight . channel ( ) , publicationMessageFlyweight . sessionId ( ) , publicationMessageFlyweight . streamId ( ) , publicationMessageFlyweight . correlationId ( ) , publicationMessageFlyweight . clientId ( ) ) ; break ; } case REMOVE_PUBLICATION : { logger . log ( EventCode . CMD_IN_REMOVE_PUBLICATION , buffer , index , length ) ; final RemoveMessageFlyweight removeMessageFlyweight = removeMsgFlyweight ; removeMessageFlyweight . offset ( index ) ; flyweight = removeMessageFlyweight ; onRemovePublication ( removeMessageFlyweight . registrationId ( ) , removeMessageFlyweight . correlationId ( ) ) ; break ; } case ADD_SUBSCRIPTION : { logger . log ( EventCode . CMD_IN_ADD_SUBSCRIPTION , buffer , index , length ) ; final SubscriptionMessageFlyweight subscriptionMessageFlyweight = subscriptionMsgFlyweight ; subscriptionMessageFlyweight . offset ( index ) ; flyweight = subscriptionMessageFlyweight ; onAddSubscription ( subscriptionMessageFlyweight . channel ( ) , subscriptionMessageFlyweight . streamId ( ) , subscriptionMessageFlyweight . correlationId ( ) , subscriptionMessageFlyweight . clientId ( ) ) ; break ; } case REMOVE_SUBSCRIPTION : { logger . log ( EventCode . CMD_IN_REMOVE_SUBSCRIPTION , buffer , index , length ) ; final RemoveMessageFlyweight removeMessageFlyweight = removeMsgFlyweight ; removeMessageFlyweight . offset ( index ) ; flyweight = removeMessageFlyweight ; onRemoveSubscription ( removeMessageFlyweight . registrationId ( ) , removeMessageFlyweight . correlationId ( ) ) ; break ; } case CLIENT_KEEPALIVE : { logger . log ( EventCode . CMD_IN_KEEPALIVE_CLIENT , buffer , index , length ) ; final CorrelatedMessageFlyweight correlatedMessageFlyweight = correlatedMsgFlyweight ; correlatedMessageFlyweight . offset ( index ) ; flyweight = correlatedMessageFlyweight ; onClientKeepalive ( correlatedMessageFlyweight . clientId ( ) ) ; break ; } } } catch ( final ControlProtocolException ex ) { clientProxy . onError ( ex . errorCode ( ) , ex . getMessage ( ) , flyweight , length ) ; logger . logException ( ex ) ; } catch ( final Exception ex ) { clientProxy . onError ( GENERIC_ERROR , ex . getMessage ( ) , flyweight , length ) ; logger . logException ( ex ) ; } } private int processTimers ( ) { int workCount = 0 ; if ( timerWheel . computeDelayInMs ( ) <= 0 ) { workCount = timerWheel . expireTimers ( ) ; } return workCount ; } private void onAddPublication ( final String channel , final int sessionId , final int streamId , final long correlationId , final long clientId ) { final UdpChannel udpChannel = UdpChannel . parse ( channel ) ; final SendChannelEndpoint channelEndpoint = getOrCreateSendChannelEndpoint ( udpChannel ) ; NetworkPublication publication = channelEndpoint . getPublication ( sessionId , streamId ) ; if ( null == publication ) { final int initialTermId = BitUtil . generateRandomisedId ( ) ; final FlowControl flowControl = udpChannel . isMulticast ( ) ? multicastFlowControl . get ( ) : unicastFlowControl . get ( ) ; publication = new NetworkPublication ( channelEndpoint , nanoClock , newPublicationLog ( sessionId , streamId , initialTermId , udpChannel , correlationId ) , newPosition ( "sender pos" , channel , sessionId , streamId , correlationId ) , newPosition ( "publisher limit" , channel , sessionId , streamId , correlationId ) , sessionId , streamId , initialTermId , mtuLength , flowControl . initialPositionLimit ( initialTermId , termBufferLength ) , systemCounters ) ; channelEndpoint . addPublication ( publication ) ; publications . add ( publication ) ; senderProxy . newPublication ( publication , newRetransmitHandler ( publication , initialTermId ) , flowControl ) ; } final AeronClient client = getOrAddClient ( clientId ) ; linkPublication ( correlationId , publication , client ) ; publication . incRef ( ) ; clientProxy . onPublicationReady ( streamId , sessionId , publication . rawLog ( ) , correlationId , publication . publisherLimitId ( ) ) ; } private void linkPublication ( final long correlationId , final NetworkPublication publication , final AeronClient client ) { if ( null != findPublicationLink ( publicationLinks , correlationId ) ) { throw new ControlProtocolException ( GENERIC_ERROR , "registration id already in use." ) ; } publicationLinks . add ( new PublicationLink ( correlationId , publication , client ) ) ; } private RetransmitHandler newRetransmitHandler ( final NetworkPublication publication , final int initialTermId ) { return new RetransmitHandler ( timerWheel , systemCounters , RETRANSMIT_UNICAST_DELAY_GENERATOR , RETRANSMIT_UNICAST_LINGER_GENERATOR , publication , initialTermId , termBufferLength ) ; } private RawLog newPublicationLog ( final int sessionId , final int streamId , final int initialTermId , final UdpChannel udpChannel , final long correlationId ) { final String canonicalForm = udpChannel . canonicalForm ( ) ; final RawLog rawLog = rawLogFactory . newPublication ( canonicalForm , sessionId , streamId , correlationId ) ; final MutableDirectBuffer header = DataHeaderFlyweight . createDefaultHeader ( sessionId , streamId , initialTermId ) ; final UnsafeBuffer logMetaData = rawLog . logMetaData ( ) ; LogBufferDescriptor . storeDefaultFrameHeaders ( logMetaData , header ) ; LogBufferDescriptor . initialTermId ( logMetaData , initialTermId ) ; LogBufferDescriptor . mtuLength ( logMetaData , mtuLength ) ; return rawLog ; } private RawLog newConnectionLog ( final int sessionId , final int streamId , final int initialTermId , final int termBufferLength , final int senderMtuLength , final UdpChannel udpChannel , final long correlationId ) { final String canonicalForm = udpChannel . canonicalForm ( ) ; final RawLog rawLog = rawLogFactory . newConnection ( canonicalForm , sessionId , streamId , correlationId , termBufferLength ) ; final MutableDirectBuffer header = DataHeaderFlyweight . createDefaultHeader ( sessionId , streamId , initialTermId ) ; final UnsafeBuffer logMetaData = rawLog . logMetaData ( ) ; LogBufferDescriptor . storeDefaultFrameHeaders ( logMetaData , header ) ; LogBufferDescriptor . initialTermId ( logMetaData , initialTermId ) ; LogBufferDescriptor . mtuLength ( logMetaData , senderMtuLength ) ; return rawLog ; } private SendChannelEndpoint getOrCreateSendChannelEndpoint ( final UdpChannel udpChannel ) { SendChannelEndpoint channelEndpoint = sendChannelEndpointByChannelMap . get ( udpChannel . canonicalForm ( ) ) ; if ( null == channelEndpoint ) { logger . logChannelCreated ( udpChannel . description ( ) ) ; channelEndpoint = new SendChannelEndpoint ( udpChannel , logger , controlLossGenerator , systemCounters ) ; sendChannelEndpointByChannelMap . put ( udpChannel . canonicalForm ( ) , channelEndpoint ) ; senderProxy . registerSendChannelEndpoint ( channelEndpoint ) ; } return channelEndpoint ; } private void onRemovePublication ( final long registrationId , final long correlationId ) { PublicationLink publicationLink = null ; final ArrayList < PublicationLink > publicationLinks = this . publicationLinks ; for ( int i = 0 , size = publicationLinks . size ( ) ; i < size ; i ++ ) { final PublicationLink link = publicationLinks . get ( i ) ; if ( registrationId == link . registrationId ( ) ) { publicationLink = link ; publicationLinks . remove ( i ) ; break ; } } if ( null == publicationLink ) { throw new ControlProtocolException ( UNKNOWN_PUBLICATION , "Unknown publication: " + registrationId ) ; } publicationLink . remove ( ) ; clientProxy . operationSucceeded ( correlationId ) ; } private void onAddSubscription ( final String channel , final int streamId , final long correlationId , final long clientId ) { final ReceiveChannelEndpoint channelEndpoint = getOrCreateReceiveChannelEndpoint ( UdpChannel . parse ( channel ) ) ; final int refCount = channelEndpoint . incRefToStream ( streamId ) ; if ( 1 == refCount ) { receiverProxy . addSubscription ( channelEndpoint , streamId ) ; } final AeronClient client = getOrAddClient ( clientId ) ; final SubscriptionLink subscription = new SubscriptionLink ( correlationId , channelEndpoint , streamId , client ) ; subscriptionLinks . add ( subscription ) ; clientProxy . operationSucceeded ( correlationId ) ; connections . stream ( ) . filter ( ( connection ) - > connection . matches ( channelEndpoint , streamId ) ) . forEach ( ( connection ) - > { final Position position = newPosition ( "subscriber pos" , channel , connection . sessionId ( ) , streamId , correlationId ) ; connection . addSubscriber ( position ) ; subscription . addConnection ( connection , position ) ; clientProxy . onConnectionReady ( streamId , connection . sessionId ( ) , connection . rebuildPosition ( ) , connection . rawLog ( ) , correlationId , Collections . singletonList ( new SubscriberPosition ( subscription , position ) ) , generateSourceIdentity ( connection . sourceAddress ( ) ) ) ; } ) ; } private ReceiveChannelEndpoint getOrCreateReceiveChannelEndpoint ( final UdpChannel udpChannel ) { ReceiveChannelEndpoint channelEndpoint = receiveChannelEndpointByChannelMap . get ( udpChannel . canonicalForm ( ) ) ; if ( null == channelEndpoint ) { channelEndpoint = new ReceiveChannelEndpoint ( udpChannel , fromReceiverConductorProxy , receiverProxy . receiver ( ) , logger , systemCounters , dataLossGenerator ) ; receiveChannelEndpointByChannelMap . put ( udpChannel . canonicalForm ( ) , channelEndpoint ) ; receiverProxy . registerReceiveChannelEndpoint ( channelEndpoint ) ; } return channelEndpoint ; } private void onRemoveSubscription ( final long registrationId , final long correlationId ) { final SubscriptionLink subscription = removeSubscription ( subscriptionLinks , registrationId ) ; if ( null == subscription ) { throw new ControlProtocolException ( UNKNOWN_SUBSCRIPTION , "Unknown subscription: " + registrationId ) ; } subscription . close ( ) ; final ReceiveChannelEndpoint channelEndpoint = subscription . channelEndpoint ( ) ; final int refCount = channelEndpoint . decRefToStream ( subscription . streamId ( ) ) ; if ( 0 == refCount ) { receiverProxy . removeSubscription ( channelEndpoint , subscription . streamId ( ) ) ; } if ( 0 == channelEndpoint . streamCount ( ) ) { receiveChannelEndpointByChannelMap . remove ( channelEndpoint . udpChannel ( ) . canonicalForm ( ) ) ; receiverProxy . closeReceiveChannelEndpoint ( channelEndpoint ) ; while ( ! channelEndpoint . isClosed ( ) ) { Thread . yield ( ) ; } } clientProxy . operationSucceeded ( correlationId ) ; } private void onClientKeepalive ( final long clientId ) { systemCounters . clientKeepAlives ( ) . addOrdered ( 1 ) ; final AeronClient client = findClient ( clients , clientId ) ; if ( null != client ) { client . timeOfLastKeepalive ( nanoClock . nanoTime ( ) ) ; } } private void onCheckPublicationLinks ( final long now ) { final ArrayList < PublicationLink > publicationLinks = this . publicationLinks ; for ( int i = publicationLinks . size ( ) - 1 ; i >= 0 ; i -- ) { final PublicationLink link = publicationLinks . get ( i ) ; if ( link . hasClientTimedOut ( now ) ) { publicationLinks . remove ( i ) ; } } } private void onCheckPublications ( final long now ) { final ArrayList < NetworkPublication > publications = this . publications ; for ( int i = publications . size ( ) - 1 ; i >= 0 ; i -- ) { final NetworkPublication publication = publications . get ( i ) ; if ( publication . isUnreferencedAndFlushed ( now ) && now > ( publication . timeOfFlush ( ) + PUBLICATION_LINGER_NS ) ) { final SendChannelEndpoint channelEndpoint = publication . sendChannelEndpoint ( ) ; logger . logPublicationRemoval ( channelEndpoint . originalUriString ( ) , publication . sessionId ( ) , publication . streamId ( ) ) ; channelEndpoint . removePublication ( publication ) ; publications . remove ( i ) ; senderProxy . removePublication ( publication ) ; if ( channelEndpoint . sessionCount ( ) == 0 ) { sendChannelEndpointByChannelMap . remove ( channelEndpoint . udpChannel ( ) . canonicalForm ( ) ) ; senderProxy . closeSendChannelEndpoint ( channelEndpoint ) ; } } } } private void onCheckSubscriptionLinks ( final long now ) { final ArrayList < SubscriptionLink > subscriptions = this . subscriptionLinks ; for ( int i = subscriptions . size ( ) - 1 ; i >= 0 ; i -- ) { final SubscriptionLink subscription = subscriptions . get ( i ) ; if ( now > ( subscription . timeOfLastKeepaliveFromClient ( ) + CLIENT_LIVENESS_TIMEOUT_NS ) ) { final ReceiveChannelEndpoint channelEndpoint = subscription . channelEndpoint ( ) ; final int streamId = subscription . streamId ( ) ; logger . logSubscriptionRemoval ( channelEndpoint . originalUriString ( ) , subscription . streamId ( ) , subscription . registrationId ( ) ) ; subscriptions . remove ( i ) ; subscription . close ( ) ; if ( 0 == channelEndpoint . decRefToStream ( subscription . streamId ( ) ) ) { receiverProxy . removeSubscription ( channelEndpoint , streamId ) ; } if ( channelEndpoint . streamCount ( ) == 0 ) { receiveChannelEndpointByChannelMap . remove ( channelEndpoint . udpChannel ( ) . canonicalForm ( ) ) ; receiverProxy . closeReceiveChannelEndpoint ( channelEndpoint ) ; } } } } private void onCheckConnections ( final long now ) { final ArrayList < NetworkConnection > connections = this . connections ; for ( int i = connections . size ( ) - 1 ; i >= 0 ; i -- ) { final NetworkConnection conn = connections . get ( i ) ; switch ( conn . status ( ) ) { case INACTIVE : if ( conn . isDrained ( ) || now > ( conn . timeOfLastStatusChange ( ) + CONNECTION_LIVENESS_TIMEOUT_NS ) ) { conn . status ( NetworkConnection . Status . LINGER ) ; clientProxy . onInactiveConnection ( conn . correlationId ( ) , conn . sessionId ( ) , conn . streamId ( ) , conn . rebuildPosition ( ) , conn . channelUriString ( ) ) ; } break ; case LINGER : if ( now > ( conn . timeOfLastStatusChange ( ) + CONNECTION_LIVENESS_TIMEOUT_NS ) ) { logger . logConnectionRemoval ( conn . channelUriString ( ) , conn . sessionId ( ) , conn . streamId ( ) , conn . correlationId ( ) ) ; connections . remove ( i ) ; subscriptionLinks . stream ( ) . filter ( ( link ) - > conn . matches ( link . channelEndpoint ( ) , link . streamId ( ) ) ) . forEach ( ( subscriptionLink ) - > subscriptionLink . removeConnection ( conn ) ) ; conn . close ( ) ; } break ; } } } private void onCheckClients ( final long now ) { for ( int i = clients . size ( ) - 1 ; i >= 0 ; i -- ) { final AeronClient client = clients . get ( i ) ; if ( now > ( client . timeOfLastKeepalive ( ) + CONNECTION_LIVENESS_TIMEOUT_NS ) ) { clients . remove ( i ) ; } } } private void onDriverConductorCmd ( final DriverConductorCmd cmd ) { cmd . execute ( this ) ; } private AeronClient getOrAddClient ( final long clientId ) { AeronClient client = findClient ( clients , clientId ) ; if ( null == client ) { client = new AeronClient ( clientId , nanoClock . nanoTime ( ) ) ; clients . add ( client ) ; } return client ; } private Position newPosition ( final String name , final String channel , final int sessionId , final int streamId , final long correlationId ) { final int positionId = allocateCounter ( name , channel , sessionId , streamId , correlationId ) ; return new UnsafeBufferPosition ( countersBuffer , positionId , countersManager ) ; } private int allocateCounter ( final String type , final String channel , final int sessionId , final int streamId , final long correlationId ) { return countersManager . allocate ( String . format ( "%s: %s %d %d %d" , type , channel , sessionId , streamId , correlationId ) ) ; } private long generateCreationCorrelationId ( ) { return toDriverCommands . nextCorrelationId ( ) ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . driver . cmd . SenderCmd ; import uk . co . real_logic . aeron . driver . media . SendChannelEndpoint ; import uk . co . real_logic . aeron . driver . media . TransportPoller ; import uk . co . real_logic . agrona . concurrent . Agent ; import uk . co . real_logic . agrona . concurrent . AtomicCounter ; import uk . co . real_logic . agrona . concurrent . OneToOneConcurrentArrayQueue ; import java . util . function . Consumer ; public class Sender implements Agent , Consumer < SenderCmd > { private static final NetworkPublication [ ] EMPTY_PUBLICATIONS = new NetworkPublication [ 0 ] ; private final TransportPoller transportPoller ; private final OneToOneConcurrentArrayQueue < SenderCmd > commandQueue ; private final DriverConductorProxy conductorProxy ; private final AtomicCounter totalBytesSent ; private NetworkPublication [ ] publications = EMPTY_PUBLICATIONS ; private int roundRobinIndex = 0 ; public Sender ( final MediaDriver . Context ctx ) { this . transportPoller = ctx . senderNioSelector ( ) ; this . commandQueue = ctx . senderCommandQueue ( ) ; this . conductorProxy = ctx . fromSenderDriverConductorProxy ( ) ; this . totalBytesSent = ctx . systemCounters ( ) . bytesSent ( ) ; } public int doWork ( ) { final int workCount = commandQueue . drain ( this ) ; final int bytesSent = doSend ( ) ; final int bytesReceived = transportPoller . pollTransports ( ) ; return workCount + bytesSent + bytesReceived ; } public String roleName ( ) { return "sender" ; } public void onRegisterSendChannelEndpoint ( final SendChannelEndpoint channelEndpoint ) { channelEndpoint . openChannel ( ) ; channelEndpoint . registerForRead ( transportPoller ) ; transportPoller . selectNowWithoutProcessing ( ) ; } public void onCloseSendChannelEndpoint ( final SendChannelEndpoint channelEndpoint ) { channelEndpoint . close ( ) ; transportPoller . selectNowWithoutProcessing ( ) ; } public void onNewPublication ( final NetworkPublication publication , final RetransmitHandler retransmitHandler , final FlowControl flowControl ) { final NetworkPublication [ ] oldPublications = publications ; final int length = oldPublications . length ; final NetworkPublication [ ] newPublications = new NetworkPublication [ length + 1 ] ; System . arraycopy ( oldPublications , 0 , newPublications , 0 , length ) ; newPublications [ length ] = publication ; publications = newPublications ; publication . sendChannelEndpoint ( ) . addToDispatcher ( publication , retransmitHandler , flowControl ) ; } public void onRemovePublication ( final NetworkPublication publication ) { final NetworkPublication [ ] oldPublications = publications ; final int length = oldPublications . length ; final NetworkPublication [ ] newPublications = new NetworkPublication [ length - 1 ] ; for ( int i = 0 , j = 0 ; i < length ; i ++ ) { if ( oldPublications [ i ] != publication ) { newPublications [ j ++ ] = oldPublications [ i ] ; } } publications = newPublications ; publication . sendChannelEndpoint ( ) . removeFromDispatcher ( publication ) ; conductorProxy . closeResource ( publication ) ; } public void accept ( final SenderCmd cmd ) { cmd . execute ( this ) ; } private int doSend ( ) { int bytesSent = 0 ; final NetworkPublication [ ] publications = this . publications ; final int length = publications . length ; if ( length > 0 ) { int startingIndex = roundRobinIndex ++ ; if ( startingIndex >= length ) { roundRobinIndex = startingIndex = 0 ; } int i = startingIndex ; do { bytesSent += publications [ i ] . send ( ) ; if ( ++ i == length ) { i = 0 ; } } while ( i != startingIndex ) ; } totalBytesSent . addOrdered ( bytesSent ) ; return bytesSent ; } }
package uk . co . real_logic . aeron . driver ; public class OptimalMulticastDelayGenerator implements FeedbackDelayGenerator { private final double calculatedN ; private final double randMax ; private final double baseX ; private final double constantT ; private final double factorT ; public OptimalMulticastDelayGenerator ( final double maxBackoffT , final double groupSize , final double gRtt ) { final double lambda = Math . log ( groupSize ) + 1 ; this . calculatedN = Math . exp ( 1.2 * lambda / ( 2 * maxBackoffT / gRtt ) ) ; this . randMax = lambda / maxBackoffT ; this . baseX = lambda / ( maxBackoffT * ( Math . exp ( lambda ) - 1 ) ) ; this . constantT = maxBackoffT / lambda ; this . factorT = ( Math . exp ( lambda ) - 1 ) * ( maxBackoffT / lambda ) ; } public long generateDelay ( ) { return ( long ) generateNewOptimalDelay ( ) ; } public double generateNewOptimalDelay ( ) { final double x = uniformRandom ( randMax ) + baseX ; return constantT * Math . log ( x * factorT ) ; } public double calculatedN ( ) { return calculatedN ; } public static double uniformRandom ( final double max ) { return Math . random ( ) * max ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . driver . cmd . CloseResourceCmd ; import uk . co . real_logic . aeron . driver . cmd . CreateConnectionCmd ; import uk . co . real_logic . aeron . driver . cmd . DriverConductorCmd ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; import uk . co . real_logic . agrona . concurrent . AtomicCounter ; import java . net . InetSocketAddress ; import java . util . Queue ; import static uk . co . real_logic . aeron . driver . ThreadingMode . SHARED ; public class DriverConductorProxy { private final ThreadingMode threadingMode ; private final Queue < DriverConductorCmd > commandQueue ; private final AtomicCounter failCount ; private DriverConductor driverConductor ; public DriverConductorProxy ( final ThreadingMode threadingMode , final Queue < DriverConductorCmd > commandQueue , final AtomicCounter failCount ) { this . threadingMode = threadingMode ; this . commandQueue = commandQueue ; this . failCount = failCount ; } public void driverConductor ( final DriverConductor driverConductor ) { this . driverConductor = driverConductor ; } public void createConnection ( final int sessionId , final int streamId , final int initialTermId , final int activeTermId , final int termOffset , final int termLength , final int mtuLength , final InetSocketAddress controlAddress , final InetSocketAddress srcAddress , final ReceiveChannelEndpoint channelEndpoint ) { if ( isShared ( ) ) { driverConductor . onCreateConnection ( sessionId , streamId , initialTermId , activeTermId , termOffset , termLength , mtuLength , controlAddress , srcAddress , channelEndpoint ) ; } else { offer ( new CreateConnectionCmd ( sessionId , streamId , initialTermId , activeTermId , termOffset , termLength , mtuLength , controlAddress , srcAddress , channelEndpoint ) ) ; } } public void closeResource ( final AutoCloseable resource ) { if ( isShared ( ) ) { driverConductor . onCloseResource ( resource ) ; } else { offer ( new CloseResourceCmd ( resource ) ) ; } } private boolean isShared ( ) { return threadingMode == SHARED ; } private void offer ( final DriverConductorCmd cmd ) { while ( ! commandQueue . offer ( cmd ) ) { failCount . orderedIncrement ( ) ; Thread . yield ( ) ; } } }
package uk . co . real_logic . aeron . driver ; public class StaticDelayGenerator implements FeedbackDelayGenerator { private final long delayInNs ; private final boolean immediateFeedback ; public StaticDelayGenerator ( final long delayInNs , final boolean immediateFeedback ) { this . delayInNs = delayInNs ; this . immediateFeedback = immediateFeedback ; } public long generateDelay ( ) { return delayInNs ; } public boolean shouldFeedbackImmediately ( ) { return immediateFeedback ; } }
package uk . co . real_logic . aeron . tools ; import uk . co . real_logic . agrona . concurrent . SystemNanoClock ; import java . util . ArrayList ; public class RateReporter implements RateController . Callback , Runnable { private static final SystemNanoClock CLOCK = new SystemNanoClock ( ) ; private final Thread reporterThread ; private long lastReportTimeNanos ; private long lastNonVerifiableMessages ; private long lastVerifiableMessages ; private long lastBytes ; private boolean shuttingDown ; private final Stats app ; private final Callback callback ; private final StringBuilder sb = new StringBuilder ( ) ; private class DefaultCallback implements Callback { public void report ( final StringBuilder reportString ) { System . out . println ( reportString ) ; } } public interface Callback { void report ( final StringBuilder reportString ) ; } public interface Stats { long verifiableMessages ( ) ; long bytes ( ) ; long nonVerifiableMessages ( ) ; } public RateReporter ( final Stats app , final Callback callback ) { this . app = app ; if ( callback != null ) { this . callback = callback ; } else { this . callback = new DefaultCallback ( ) ; } reporterThread = new Thread ( this ) ; reporterThread . start ( ) ; } public RateReporter ( final Stats app ) { this ( app , null ) ; } public static String humanReadableRate ( final long bits ) { if ( bits < 1000 ) { return bits + " " ; } final int exp = ( int ) ( Math . log ( bits ) / Math . log ( 1000 ) ) ; return String . format ( "%.1f %s" , bits / Math . pow ( 1000 , exp ) , "KMGTPE" . charAt ( exp - 1 ) ) ; } public static String humanReadableRate ( final double bits ) { if ( bits < 1000 ) { return String . format ( "%.3f " , bits ) ; } final int exp = ( int ) ( Math . log ( bits ) / Math . log ( 1000 ) ) ; return String . format ( "%.3f %s" , bits / Math . pow ( 1000 , exp ) , "KMGTPE" . charAt ( exp - 1 ) ) ; } public void close ( ) { shuttingDown = true ; try { reporterThread . join ( ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } } public void run ( ) { final ArrayList < RateControllerInterval > intervals = new ArrayList < > ( ) ; intervals . add ( new MessagesAtMessagesPerSecondInterval ( Long . MAX_VALUE , 1 ) ) ; RateController rateController ; try { rateController = new RateController ( this , intervals ) ; lastReportTimeNanos = CLOCK . nanoTime ( ) - 1000000000 ; while ( ! shuttingDown && rateController . next ( ) ) { } } catch ( final Exception e ) { e . printStackTrace ( ) ; } shuttingDown = true ; } public int onNext ( ) { final long currentTimeNanos = CLOCK . nanoTime ( ) ; final long verifiableMessages = app . verifiableMessages ( ) ; final long nonVerifiableMessages = app . nonVerifiableMessages ( ) ; final long totalMessages = verifiableMessages + nonVerifiableMessages ; final long lastTotalMessages = lastNonVerifiableMessages + lastVerifiableMessages ; final long bytesReceived = app . bytes ( ) ; final double secondsElapsed = ( currentTimeNanos - lastReportTimeNanos ) / 1000000000.0 ; sb . setLength ( 0 ) ; sb . append ( String . format ( "%.6f: %smsgs/sec %sbps" , secondsElapsed , humanReadableRate ( ( totalMessages - lastTotalMessages ) / secondsElapsed ) , humanReadableRate ( ( long ) ( ( ( ( bytesReceived - lastBytes ) * 8 ) ) / secondsElapsed ) ) ) ) ; callback . report ( sb ) ; lastReportTimeNanos = currentTimeNanos ; lastVerifiableMessages = verifiableMessages ; lastNonVerifiableMessages = nonVerifiableMessages ; lastBytes = bytesReceived ; if ( shuttingDown ) { return - 1 ; } return 0 ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . agrona . concurrent . AtomicCounter ; import uk . co . real_logic . agrona . concurrent . CountersManager ; public class SystemCounters implements AutoCloseable { private final AtomicCounter bytesSent ; private final AtomicCounter bytesReceived ; private final AtomicCounter receiverProxyFails ; private final AtomicCounter senderProxyFails ; private final AtomicCounter conductorProxyFails ; private final AtomicCounter nakMessagesSent ; private final AtomicCounter nakMessagesReceived ; private final AtomicCounter retransmitsSent ; private final AtomicCounter statusMessagesSent ; private final AtomicCounter statusMessagesReceived ; private final AtomicCounter heartbeatsSent ; private final AtomicCounter heartbeatsReceived ; private final AtomicCounter flowControlUnderRuns ; private final AtomicCounter flowControlOverRuns ; private final AtomicCounter invalidPackets ; private final AtomicCounter driverExceptions ; private final AtomicCounter dataPacketShortSends ; private final AtomicCounter setupMessageShortSends ; private final AtomicCounter statusMessageShortSends ; private final AtomicCounter nakMessageShortSends ; private final AtomicCounter clientKeepAlives ; private final AtomicCounter senderFlowControlLimits ; public SystemCounters ( final CountersManager countersManager ) { bytesSent = countersManager . newCounter ( "Bytes sent" ) ; bytesReceived = countersManager . newCounter ( "Bytes received" ) ; receiverProxyFails = countersManager . newCounter ( "Failed offers to ReceiverProxy" ) ; senderProxyFails = countersManager . newCounter ( "Failed offers to SenderProxy" ) ; conductorProxyFails = countersManager . newCounter ( "Failed offers to DriverConductorProxy" ) ; nakMessagesSent = countersManager . newCounter ( "NAKs sent" ) ; nakMessagesReceived = countersManager . newCounter ( "NAKs received" ) ; statusMessagesSent = countersManager . newCounter ( "SMs sent" ) ; statusMessagesReceived = countersManager . newCounter ( "SMs received" ) ; heartbeatsSent = countersManager . newCounter ( "Heartbeats sent" ) ; heartbeatsReceived = countersManager . newCounter ( "Heartbeats received" ) ; retransmitsSent = countersManager . newCounter ( "Retransmits sent" ) ; flowControlUnderRuns = countersManager . newCounter ( "Flow control under runs" ) ; flowControlOverRuns = countersManager . newCounter ( "Flow control over runs" ) ; invalidPackets = countersManager . newCounter ( "Invalid packets" ) ; driverExceptions = countersManager . newCounter ( "Driver Exceptions" ) ; dataPacketShortSends = countersManager . newCounter ( "Data Packet short sends" ) ; setupMessageShortSends = countersManager . newCounter ( "Setup Message short sends" ) ; statusMessageShortSends = countersManager . newCounter ( "Status Message short sends" ) ; nakMessageShortSends = countersManager . newCounter ( "NAK Message short sends" ) ; clientKeepAlives = countersManager . newCounter ( "Client keep-alives" ) ; senderFlowControlLimits = countersManager . newCounter ( "Sender flow control limits applied" ) ; } public void close ( ) { bytesSent . close ( ) ; bytesReceived . close ( ) ; receiverProxyFails . close ( ) ; senderProxyFails . close ( ) ; conductorProxyFails . close ( ) ; nakMessagesSent . close ( ) ; nakMessagesReceived . close ( ) ; statusMessagesSent . close ( ) ; statusMessagesReceived . close ( ) ; heartbeatsSent . close ( ) ; heartbeatsReceived . close ( ) ; retransmitsSent . close ( ) ; flowControlUnderRuns . close ( ) ; flowControlOverRuns . close ( ) ; invalidPackets . close ( ) ; driverExceptions . close ( ) ; dataPacketShortSends . close ( ) ; setupMessageShortSends . close ( ) ; statusMessageShortSends . close ( ) ; nakMessageShortSends . close ( ) ; clientKeepAlives . close ( ) ; senderFlowControlLimits . close ( ) ; } public AtomicCounter bytesSent ( ) { return bytesSent ; } public AtomicCounter bytesReceived ( ) { return bytesReceived ; } public AtomicCounter receiverProxyFails ( ) { return receiverProxyFails ; } public AtomicCounter senderProxyFails ( ) { return senderProxyFails ; } public AtomicCounter conductorProxyFails ( ) { return conductorProxyFails ; } public AtomicCounter nakMessagesSent ( ) { return nakMessagesSent ; } public AtomicCounter nakMessagesReceived ( ) { return nakMessagesReceived ; } public AtomicCounter retransmitsSent ( ) { return retransmitsSent ; } public AtomicCounter statusMessagesSent ( ) { return statusMessagesSent ; } public AtomicCounter statusMessagesReceived ( ) { return statusMessagesReceived ; } public AtomicCounter heartbeatsSent ( ) { return heartbeatsSent ; } public AtomicCounter heartbeatsReceived ( ) { return heartbeatsReceived ; } public AtomicCounter flowControlUnderRuns ( ) { return flowControlUnderRuns ; } public AtomicCounter flowControlOverRuns ( ) { return flowControlOverRuns ; } public AtomicCounter invalidPackets ( ) { return invalidPackets ; } public AtomicCounter driverExceptions ( ) { return driverExceptions ; } public AtomicCounter dataPacketShortSends ( ) { return dataPacketShortSends ; } public AtomicCounter setupMessageShortSends ( ) { return setupMessageShortSends ; } public AtomicCounter statusMessageShortSends ( ) { return statusMessageShortSends ; } public AtomicCounter nakMessageShortSends ( ) { return nakMessageShortSends ; } public AtomicCounter clientKeepAlives ( ) { return clientKeepAlives ; } public AtomicCounter senderFlowControlLimits ( ) { return senderFlowControlLimits ; } }
package uk . co . real_logic . aeron . driver ; import java . net . InetSocketAddress ; public interface FlowControl { long onStatusMessage ( int termId , int rebuildTermOffset , int receiverWindowLength , InetSocketAddress address ) ; long initialPositionLimit ( int initialTermId , int termBufferCapacity ) ; }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . ErrorCode ; import uk . co . real_logic . aeron . Flyweight ; import uk . co . real_logic . aeron . command . ConnectionBuffersReadyFlyweight ; import uk . co . real_logic . aeron . command . ConnectionMessageFlyweight ; import uk . co . real_logic . aeron . command . CorrelatedMessageFlyweight ; import uk . co . real_logic . aeron . command . PublicationBuffersReadyFlyweight ; import uk . co . real_logic . aeron . driver . event . EventCode ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . aeron . protocol . ErrorFlyweight ; import uk . co . real_logic . aeron . driver . buffer . RawLog ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . broadcast . BroadcastTransmitter ; import java . nio . ByteBuffer ; import java . util . List ; import static uk . co . real_logic . aeron . command . ControlProtocolEvents . * ; import static uk . co . real_logic . aeron . driver . event . EventCode . CMD_OUT_CONNECTION_READY ; import static uk . co . real_logic . aeron . driver . event . EventCode . CMD_OUT_PUBLICATION_READY ; public class ClientProxy { private static final int WRITE_BUFFER_CAPACITY = 4096 ; private final UnsafeBuffer tmpBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( WRITE_BUFFER_CAPACITY ) ) ; private final BroadcastTransmitter transmitter ; private final ErrorFlyweight errorFlyweight = new ErrorFlyweight ( ) ; private final PublicationBuffersReadyFlyweight publicationReady = new PublicationBuffersReadyFlyweight ( ) ; private final ConnectionBuffersReadyFlyweight connectionReady = new ConnectionBuffersReadyFlyweight ( ) ; private final CorrelatedMessageFlyweight correlatedMessage = new CorrelatedMessageFlyweight ( ) ; private final ConnectionMessageFlyweight connectionMessage = new ConnectionMessageFlyweight ( ) ; private final EventLogger logger ; public ClientProxy ( final BroadcastTransmitter transmitter , final EventLogger logger ) { this . transmitter = transmitter ; this . logger = logger ; } public void onError ( final ErrorCode errorCode , String errorMessage , final Flyweight offendingFlyweight , final int offendingFlyweightLength ) { if ( null == errorMessage ) { errorMessage = "" ; } final byte [ ] errorBytes = errorMessage . getBytes ( ) ; final int frameLength = ErrorFlyweight . HEADER_LENGTH + offendingFlyweightLength + errorBytes . length ; errorFlyweight . wrap ( tmpBuffer , 0 ) ; errorFlyweight . errorCode ( errorCode ) . offendingFlyweight ( offendingFlyweight , offendingFlyweightLength ) . errorMessage ( errorBytes ) . frameLength ( frameLength ) ; transmitter . transmit ( ON_ERROR , tmpBuffer , 0 , errorFlyweight . frameLength ( ) ) ; } public void onConnectionReady ( final int streamId , final int sessionId , final long joiningPosition , final RawLog rawLog , final long correlationId , final List < SubscriberPosition > subscriberPositions , final String sourceIdentity ) { connectionReady . wrap ( tmpBuffer , 0 ) ; connectionReady . sessionId ( sessionId ) . streamId ( streamId ) . joiningPosition ( joiningPosition ) . correlationId ( correlationId ) . logFileName ( rawLog . logFileName ( ) ) . sourceIdentity ( sourceIdentity ) ; final int size = subscriberPositions . size ( ) ; connectionReady . subscriberPositionCount ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { final SubscriberPosition position = subscriberPositions . get ( i ) ; connectionReady . subscriberPositionId ( i , position . positionCounterId ( ) ) ; connectionReady . positionIndicatorRegistrationId ( i , position . subscription ( ) . registrationId ( ) ) ; } logger . log ( CMD_OUT_CONNECTION_READY , tmpBuffer , 0 , connectionReady . length ( ) ) ; transmitter . transmit ( ON_CONNECTION_READY , tmpBuffer , 0 , connectionReady . length ( ) ) ; } public void onPublicationReady ( final int streamId , final int sessionId , final RawLog rawLog , final long correlationId , final int positionCounterId ) { publicationReady . wrap ( tmpBuffer , 0 ) ; publicationReady . sessionId ( sessionId ) . streamId ( streamId ) . correlationId ( correlationId ) . publicationLimitCounterId ( positionCounterId ) ; publicationReady . logFileName ( rawLog . logFileName ( ) ) ; logger . log ( CMD_OUT_PUBLICATION_READY , tmpBuffer , 0 , publicationReady . length ( ) ) ; transmitter . transmit ( ON_PUBLICATION_READY , tmpBuffer , 0 , publicationReady . length ( ) ) ; } public void operationSucceeded ( final long correlationId ) { correlatedMessage . wrap ( tmpBuffer , 0 ) ; correlatedMessage . clientId ( 0 ) ; correlatedMessage . correlationId ( correlationId ) ; logger . log ( EventCode . CMD_OUT_ON_OPERATION_SUCCESS , tmpBuffer , 0 , CorrelatedMessageFlyweight . LENGTH ) ; transmitter . transmit ( ON_OPERATION_SUCCESS , tmpBuffer , 0 , CorrelatedMessageFlyweight . LENGTH ) ; } public void onInactiveConnection ( final long correlationId , final int sessionId , final int streamId , final long position , final String channel ) { connectionMessage . wrap ( tmpBuffer , 0 ) ; connectionMessage . correlationId ( correlationId ) . sessionId ( sessionId ) . streamId ( streamId ) . position ( position ) . channel ( channel ) ; logger . log ( EventCode . CMD_OUT_ON_INACTIVE_CONNECTION , tmpBuffer , 0 , connectionMessage . length ( ) ) ; transmitter . transmit ( ON_INACTIVE_CONNECTION , tmpBuffer , 0 , connectionMessage . length ( ) ) ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; import uk . co . real_logic . agrona . concurrent . status . ReadablePosition ; import java . util . IdentityHashMap ; import java . util . Map ; public class SubscriptionLink { private final long registrationId ; private final int streamId ; private final ReceiveChannelEndpoint channelEndpoint ; private final AeronClient aeronClient ; private final Map < NetworkConnection , ReadablePosition > positionByConnectionMap = new IdentityHashMap < > ( ) ; public SubscriptionLink ( final long registrationId , final ReceiveChannelEndpoint channelEndpoint , final int streamId , final AeronClient aeronClient ) { this . registrationId = registrationId ; this . channelEndpoint = channelEndpoint ; this . streamId = streamId ; this . aeronClient = aeronClient ; } public long registrationId ( ) { return registrationId ; } public ReceiveChannelEndpoint channelEndpoint ( ) { return channelEndpoint ; } public int streamId ( ) { return streamId ; } public long timeOfLastKeepaliveFromClient ( ) { return aeronClient . timeOfLastKeepalive ( ) ; } public boolean matches ( final ReceiveChannelEndpoint channelEndpoint , final int streamId ) { return channelEndpoint == this . channelEndpoint && streamId == this . streamId ; } public void addConnection ( final NetworkConnection connection , final ReadablePosition position ) { positionByConnectionMap . put ( connection , position ) ; } public void removeConnection ( final NetworkConnection connection ) { positionByConnectionMap . remove ( connection ) ; } public void close ( ) { positionByConnectionMap . forEach ( NetworkConnection : : removeSubscriber ) ; } }
package uk . co . real_logic . aeron . driver ; public interface FeedbackDelayGenerator { long generateDelay ( ) ; default boolean shouldFeedbackImmediately ( ) { return false ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . net . InetSocketAddress ; @ FunctionalInterface public interface DataPacketHandler { int onDataPacket ( DataHeaderFlyweight header , UnsafeBuffer buffer , int length , InetSocketAddress srcAddress ) ; }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . protocol . SetupFlyweight ; import uk . co . real_logic . aeron . driver . exceptions . UnknownSubscriptionException ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; import uk . co . real_logic . aeron . driver . media . UdpChannelTransport ; import uk . co . real_logic . agrona . collections . BiInt2ObjectMap ; import uk . co . real_logic . agrona . collections . Int2ObjectHashMap ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . net . InetSocketAddress ; public class DataPacketDispatcher implements DataPacketHandler , SetupMessageHandler { private static final Integer PENDING_SETUP_FRAME = 1 ; private static final Integer INIT_IN_PROGRESS = 2 ; private final BiInt2ObjectMap < Integer > initialisationInProgressMap = new BiInt2ObjectMap < > ( ) ; private final Int2ObjectHashMap < Int2ObjectHashMap < NetworkConnection > > sessionsByStreamIdMap = new Int2ObjectHashMap < > ( ) ; private final DriverConductorProxy conductorProxy ; private final Receiver receiver ; private final ReceiveChannelEndpoint channelEndpoint ; public DataPacketDispatcher ( final DriverConductorProxy conductorProxy , final Receiver receiver , final ReceiveChannelEndpoint channelEndpoint ) { this . conductorProxy = conductorProxy ; this . receiver = receiver ; this . channelEndpoint = channelEndpoint ; } public void addSubscription ( final int streamId ) { if ( null == sessionsByStreamIdMap . get ( streamId ) ) { sessionsByStreamIdMap . put ( streamId , new Int2ObjectHashMap < > ( ) ) ; } } public void removeSubscription ( final int streamId ) { final Int2ObjectHashMap < NetworkConnection > connectionBySessionIdMap = sessionsByStreamIdMap . remove ( streamId ) ; if ( null == connectionBySessionIdMap ) { throw new UnknownSubscriptionException ( "No subscription registered on stream " + streamId ) ; } connectionBySessionIdMap . values ( ) . forEach ( NetworkConnection : : ifActiveGoInactive ) ; } public void addConnection ( final NetworkConnection connection ) { final int sessionId = connection . sessionId ( ) ; final int streamId = connection . streamId ( ) ; final Int2ObjectHashMap < NetworkConnection > connectionByteSessionIdMap = sessionsByStreamIdMap . get ( streamId ) ; if ( null == connectionByteSessionIdMap ) { throw new IllegalStateException ( "No subscription registered on stream " + streamId ) ; } connectionByteSessionIdMap . put ( sessionId , connection ) ; initialisationInProgressMap . remove ( sessionId , streamId ) ; connection . status ( NetworkConnection . Status . ACTIVE ) ; } public void removeConnection ( final NetworkConnection connection ) { final int sessionId = connection . sessionId ( ) ; final int streamId = connection . streamId ( ) ; final Int2ObjectHashMap < NetworkConnection > connectionBySessionIdMap = sessionsByStreamIdMap . get ( streamId ) ; if ( null != connectionBySessionIdMap ) { connectionBySessionIdMap . remove ( sessionId ) ; initialisationInProgressMap . remove ( sessionId , streamId ) ; } connection . ifActiveGoInactive ( ) ; } public void removePendingSetup ( final int sessionId , final int streamId ) { if ( PENDING_SETUP_FRAME . equals ( initialisationInProgressMap . get ( sessionId , streamId ) ) ) { initialisationInProgressMap . remove ( sessionId , streamId ) ; } } public int onDataPacket ( final DataHeaderFlyweight header , final UnsafeBuffer buffer , final int length , final InetSocketAddress srcAddress ) { final int streamId = header . streamId ( ) ; final Int2ObjectHashMap < NetworkConnection > connectionBySessionIdMap = sessionsByStreamIdMap . get ( streamId ) ; if ( null != connectionBySessionIdMap ) { final int sessionId = header . sessionId ( ) ; final int termId = header . termId ( ) ; final NetworkConnection connection = connectionBySessionIdMap . get ( sessionId ) ; if ( null != connection ) { return connection . insertPacket ( termId , header . termOffset ( ) , buffer , length ) ; } else if ( null == initialisationInProgressMap . get ( sessionId , streamId ) ) { elicitSetupMessageFromSource ( srcAddress , streamId , sessionId ) ; } } return 0 ; } public void onSetupMessage ( final SetupFlyweight header , final UnsafeBuffer buffer , final int length , final InetSocketAddress srcAddress ) { final int streamId = header . streamId ( ) ; final Int2ObjectHashMap < NetworkConnection > connectionBySessionIdMap = sessionsByStreamIdMap . get ( streamId ) ; if ( null != connectionBySessionIdMap ) { final int sessionId = header . sessionId ( ) ; final int initialTermId = header . initialTermId ( ) ; final int activeTermId = header . activeTermId ( ) ; final NetworkConnection connection = connectionBySessionIdMap . get ( sessionId ) ; if ( null == connection && isNotAlreadyInProgress ( streamId , sessionId ) ) { createConnection ( srcAddress , streamId , sessionId , initialTermId , activeTermId , header . termOffset ( ) , header . termLength ( ) , header . mtuLength ( ) ) ; } } } private boolean isNotAlreadyInProgress ( final int streamId , final int sessionId ) { return ! INIT_IN_PROGRESS . equals ( initialisationInProgressMap . get ( sessionId , streamId ) ) ; } private void elicitSetupMessageFromSource ( final InetSocketAddress srcAddress , final int streamId , final int sessionId ) { final UdpChannelTransport transport = channelEndpoint . transport ( ) ; final InetSocketAddress controlAddress = transport . isMulticast ( ) ? transport . udpChannel ( ) . remoteControl ( ) : srcAddress ; initialisationInProgressMap . put ( sessionId , streamId , PENDING_SETUP_FRAME ) ; channelEndpoint . sendSetupElicitingStatusMessage ( controlAddress , sessionId , streamId ) ; receiver . addPendingSetupMessage ( sessionId , streamId , channelEndpoint ) ; } private void createConnection ( final InetSocketAddress srcAddress , final int streamId , final int sessionId , final int initialTermId , final int activeTermId , final int termOffset , final int termLength , final int mtuLength ) { final UdpChannelTransport transport = channelEndpoint . transport ( ) ; final InetSocketAddress controlAddress = transport . isMulticast ( ) ? transport . udpChannel ( ) . remoteControl ( ) : srcAddress ; initialisationInProgressMap . put ( sessionId , streamId , INIT_IN_PROGRESS ) ; conductorProxy . createConnection ( sessionId , streamId , initialTermId , activeTermId , termOffset , termLength , mtuLength , controlAddress , srcAddress , channelEndpoint ) ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . net . InetSocketAddress ; import java . util . Random ; public class RandomLossGenerator implements LossGenerator { private final double lossRate ; private final Random random ; public RandomLossGenerator ( final double lossRate ) { this ( lossRate , - 1 ) ; } public RandomLossGenerator ( final double lossRate , final long lossSeed ) { this . random = - 1 == lossSeed ? new Random ( ) : new Random ( lossSeed ) ; this . lossRate = lossRate ; } public boolean shouldDropFrame ( final InetSocketAddress address , final UnsafeBuffer buffer , final int length ) { return random . nextDouble ( ) <= lossRate ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . LangUtil ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . concurrent . BackoffIdleStrategy ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import uk . co . real_logic . agrona . concurrent . broadcast . BroadcastBufferDescriptor ; import uk . co . real_logic . agrona . concurrent . ringbuffer . RingBufferDescriptor ; import java . util . concurrent . TimeUnit ; import static java . lang . Integer . getInteger ; import static java . lang . Long . getLong ; import static java . lang . System . getProperty ; import static uk . co . real_logic . aeron . driver . ThreadingMode . DEDICATED ; public class Configuration { public static final String RECEIVE_BUFFER_LENGTH_PROP_NAME = "aeron.rcv.buffer.length" ; public static final String TERM_BUFFER_LENGTH_PROP_NAME = "aeron.term.buffer.length" ; public static final String TERM_BUFFER_MAX_LENGTH_PROP_NAME = "aeron.term.buffer.max.length" ; public static final String CONDUCTOR_BUFFER_LENGTH_PROP_NAME = "aeron.conductor.buffer.length" ; public static final String TO_CLIENTS_BUFFER_LENGTH_PROP_NAME = "aeron.clients.buffer.length" ; public static final String COUNTER_VALUES_BUFFER_LENGTH_PROP_NAME = "aeron.dir.counters.length" ; public static final String INITIAL_WINDOW_LENGTH_PROP_NAME = "aeron.rcv.initial.window.length" ; public static final String STATUS_MESSAGE_TIMEOUT_PROP_NAME = "aeron.rcv.status.message.timeout" ; public static final String SOCKET_RCVBUF_LENGTH_PROP_NAME = "aeron.socket.so_rcvbuf" ; public static final String SOCKET_SNDBUF_LENGTH_PROP_NAME = "aeron.socket.so_sndbuf" ; public static final String PUBLICATION_LINGER_PROP_NAME = "aeron.publication.linger.timeout" ; public static final String PUBLICATION_TERM_WINDOW_LENGTH_PROP_NAME = "aeron.publication.term.window.length" ; public static final int PUBLICATION_TERM_WINDOW_LENGTH = getInteger ( PUBLICATION_TERM_WINDOW_LENGTH_PROP_NAME , 0 ) ; public static final String SUBSCRIPTION_TERM_WINDOW_ENGTH_PROP_NAME = "aeron.subscription.term.window.length" ; public static final int SUBSCRIPTION_TERM_WINDOW_LENGTH = getInteger ( SUBSCRIPTION_TERM_WINDOW_ENGTH_PROP_NAME , 0 ) ; public static final String CLIENT_LIVENESS_TIMEOUT_PROP_NAME = "aeron.client.liveness.timeout" ; public static final String CONNECTION_LIVENESS_TIMEOUT_PROP_NAME = "aeron.connection.liveness.timeout" ; public static final String DATA_LOSS_RATE_PROP_NAME = "aeron.debug.data.loss.rate" ; public static final String DATA_LOSS_SEED_PROP_NAME = "aeron.debug.data.loss.seed" ; public static final String CONTROL_LOSS_RATE_PROP_NAME = "aeron.debug.control.loss.rate" ; public static final String CONTROL_LOSS_SEED_PROP_NAME = "aeron.debug.control.loss.seed" ; public static final int RECEIVE_BYTE_BUFFER_LENGTH_DEFAULT = 4096 ; public static final int RECEIVE_BYTE_BUFFER_LENGTH = getInteger ( RECEIVE_BUFFER_LENGTH_PROP_NAME , RECEIVE_BYTE_BUFFER_LENGTH_DEFAULT ) ; public static final int TERM_BUFFER_LENGTH_DEFAULT = 16 * 1024 * 1024 ; public static final int TERM_BUFFER_LENGTH_MAX_DEFAULT = 16 * 1024 * 1024 ; public static final int CONDUCTOR_BUFFER_LENGTH_DEFAULT = 1024 * 1024 + RingBufferDescriptor . TRAILER_LENGTH ; public static final int CONDUCTOR_BUFFER_LENGTH = getInteger ( CONDUCTOR_BUFFER_LENGTH_PROP_NAME , CONDUCTOR_BUFFER_LENGTH_DEFAULT ) ; public static final int TO_CLIENTS_BUFFER_LENGTH_DEFAULT = 1024 * 1024 + BroadcastBufferDescriptor . TRAILER_LENGTH ; public static final int TO_CLIENTS_BUFFER_LENGTH = getInteger ( TO_CLIENTS_BUFFER_LENGTH_PROP_NAME , TO_CLIENTS_BUFFER_LENGTH_DEFAULT ) ; public static final int COUNTER_VALUES_BUFFER_LENGTH_DEFAULT = 1024 * 1024 ; public static final int COUNTER_VALUES_BUFFER_LENGTH = getInteger ( COUNTER_VALUES_BUFFER_LENGTH_PROP_NAME , COUNTER_VALUES_BUFFER_LENGTH_DEFAULT ) ; public static final int COUNTER_LABELS_BUFFER_LENGTH = COUNTER_VALUES_BUFFER_LENGTH ; public static final int NAK_GROUPSIZE_DEFAULT = 10 ; public static final int NAK_GRTT_DEFAULT = 10 ; public static final long NAK_MAX_BACKOFF_DEFAULT = TimeUnit . MILLISECONDS . toNanos ( 60 ) ; public static final OptimalMulticastDelayGenerator NAK_MULTICAST_DELAY_GENERATOR = new OptimalMulticastDelayGenerator ( Configuration . NAK_MAX_BACKOFF_DEFAULT , Configuration . NAK_GROUPSIZE_DEFAULT , Configuration . NAK_GRTT_DEFAULT ) ; public static final long NAK_UNICAST_DELAY_DEFAULT_NS = TimeUnit . MILLISECONDS . toNanos ( 60 ) ; public static final StaticDelayGenerator NAK_UNICAST_DELAY_GENERATOR = new StaticDelayGenerator ( Configuration . NAK_UNICAST_DELAY_DEFAULT_NS , true ) ; public static final StaticDelayGenerator NO_NAK_DELAY_GENERATOR = new StaticDelayGenerator ( - 1 , false ) ; public static final long RETRANSMIT_UNICAST_DELAY_DEFAULT_NS = TimeUnit . NANOSECONDS . toNanos ( 0 ) ; public static final FeedbackDelayGenerator RETRANSMIT_UNICAST_DELAY_GENERATOR = ( ) - > RETRANSMIT_UNICAST_DELAY_DEFAULT_NS ; public static final long RETRANSMIT_UNICAST_LINGER_DEFAULT_NS = TimeUnit . MILLISECONDS . toNanos ( 60 ) ; public static final FeedbackDelayGenerator RETRANSMIT_UNICAST_LINGER_GENERATOR = ( ) - > RETRANSMIT_UNICAST_LINGER_DEFAULT_NS ; public static final int MAX_RETRANSMITS_DEFAULT = 16 ; public static final int INITIAL_WINDOW_LENGTH_DEFAULT = 128 * 1024 ; public static final long STATUS_MESSAGE_TIMEOUT_DEFAULT_NS = TimeUnit . MILLISECONDS . toNanos ( 200 ) ; public static final int SOCKET_RCVBUF_LENGTH_DEFAULT = 128 * 1024 ; public static final int SOCKET_RCVBUF_LENGTH = getInteger ( SOCKET_RCVBUF_LENGTH_PROP_NAME , SOCKET_RCVBUF_LENGTH_DEFAULT ) ; public static final int SOCKET_SNDBUF_LENGTH_DEFAULT = 0 ; public static final int SOCKET_SNDBUF_LENGTH = getInteger ( SOCKET_SNDBUF_LENGTH_PROP_NAME , SOCKET_SNDBUF_LENGTH_DEFAULT ) ; public static final long PUBLICATION_LINGER_DEFAULT_NS = TimeUnit . SECONDS . toNanos ( 5 ) ; public static final long PUBLICATION_LINGER_NS = getLong ( PUBLICATION_LINGER_PROP_NAME , PUBLICATION_LINGER_DEFAULT_NS ) ; public static final long CLIENT_LIVENESS_TIMEOUT_DEFAULT_NS = TimeUnit . MILLISECONDS . toNanos ( 5000 ) ; public static final long CLIENT_LIVENESS_TIMEOUT_NS = getLong ( CLIENT_LIVENESS_TIMEOUT_PROP_NAME , CLIENT_LIVENESS_TIMEOUT_DEFAULT_NS ) ; public static final long CONNECTION_LIVENESS_TIMEOUT_DEFAULT_NS = TimeUnit . SECONDS . toNanos ( 10 ) ; public static final long CONNECTION_LIVENESS_TIMEOUT_NS = getLong ( CONNECTION_LIVENESS_TIMEOUT_PROP_NAME , CONNECTION_LIVENESS_TIMEOUT_DEFAULT_NS ) ; public static final int CONDUCTOR_TICKS_PER_WHEEL = 1024 ; public static final int CONDUCTOR_TICK_DURATION_US = 10 * 1000 ; public static final String AGENT_IDLE_STRATEGY_PROP_NAME = "aeron.agent.idle.strategy" ; public static final String AGENT_IDLE_STRATEGY = getProperty ( AGENT_IDLE_STRATEGY_PROP_NAME , "uk.co.real_logic.agrona.concurrent.BackoffIdleStrategy" ) ; public static final long AGENT_IDLE_MAX_SPINS = 20 ; public static final long AGENT_IDLE_MAX_YIELDS = 50 ; public static final long AGENT_IDLE_MIN_PARK_NS = TimeUnit . NANOSECONDS . toNanos ( 1 ) ; public static final long AGENT_IDLE_MAX_PARK_NS = TimeUnit . MICROSECONDS . toNanos ( 100 ) ; public static final int CMD_QUEUE_CAPACITY = 1024 ; public static final long PENDING_SETUPS_TIMEOUT_NS = TimeUnit . MILLISECONDS . toNanos ( 1000 ) ; public static final long PUBLICATION_SETUP_TIMEOUT_NS = TimeUnit . MILLISECONDS . toNanos ( 100 ) ; public static final long PUBLICATION_HEARTBEAT_TIMEOUT_NS = TimeUnit . MILLISECONDS . toNanos ( 100 ) ; public static final String UNICAST_FLOW_CONTROL_STRATEGY_PROP_NAME = "aeron.unicast.flow.control.strategy" ; public static final String UNICAST_FLOW_CONTROL_STRATEGY = getProperty ( UNICAST_FLOW_CONTROL_STRATEGY_PROP_NAME , "uk.co.real_logic.aeron.driver.UnicastFlowControl" ) ; public static final String MULTICAST_FLOW_CONTROL_STRATEGY_PROP_NAME = "aeron.multicast.flow.control.strategy" ; public static final String MULTICAST_FLOW_CONTROL_STRATEGY = getProperty ( MULTICAST_FLOW_CONTROL_STRATEGY_PROP_NAME , "uk.co.real_logic.aeron.driver.MaxMulticastFlowControl" ) ; public static final String MTU_LENGTH_PROP_NAME = "aeron.mtu.length" ; public static final int MTU_LENGTH_DEFAULT = 4096 ; public static final int MTU_LENGTH = getInteger ( MTU_LENGTH_PROP_NAME , MTU_LENGTH_DEFAULT ) ; public static final String THREADING_MODE_PROP_NAME = "aeron.threading.mode" ; public static final String THREADING_MODE_DEFAULT = DEDICATED . name ( ) ; public static final String DO_NOT_SEND_NAK_PROP_NAME = "aeron.driver.disable.naks" ; public static final int HEARTBEAT_TIMEOUT_MS = 1000 ; public static int subscriptionTermWindowLength ( final int termCapacity ) { return 0 != SUBSCRIPTION_TERM_WINDOW_LENGTH ? SUBSCRIPTION_TERM_WINDOW_LENGTH : termCapacity / 2 ; } public static int publicationTermWindowLength ( final int termCapacity ) { return 0 != PUBLICATION_TERM_WINDOW_LENGTH ? PUBLICATION_TERM_WINDOW_LENGTH : termCapacity / 2 ; } public static void validateTermBufferLength ( final int length ) { if ( ! BitUtil . isPowerOfTwo ( length ) ) { throw new IllegalStateException ( "Term buffer length must be a positive power of 2: " + length ) ; } } public static void validateInitialWindowLength ( final int initialWindowLength , final int mtuLength ) { if ( mtuLength > initialWindowLength ) { throw new IllegalStateException ( "Initial window length must be >= to MTU length: " + mtuLength ) ; } } public static IdleStrategy agentIdleStrategy ( ) { IdleStrategy idleStrategy = null ; switch ( AGENT_IDLE_STRATEGY ) { case "uk.co.real_logic.agrona.concurrent.BackoffIdleStrategy" : idleStrategy = new BackoffIdleStrategy ( AGENT_IDLE_MAX_SPINS , AGENT_IDLE_MAX_YIELDS , AGENT_IDLE_MIN_PARK_NS , AGENT_IDLE_MAX_PARK_NS ) ; break ; default : try { idleStrategy = ( IdleStrategy ) Class . forName ( AGENT_IDLE_STRATEGY ) . newInstance ( ) ; } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } break ; } return idleStrategy ; } public static FlowControl unicastFlowControlStrategy ( ) { FlowControl flowControl = null ; try { flowControl = ( FlowControl ) Class . forName ( UNICAST_FLOW_CONTROL_STRATEGY ) . newInstance ( ) ; } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } return flowControl ; } public static FlowControl multicastFlowControlStrategy ( ) { FlowControl flowControl = null ; try { flowControl = ( FlowControl ) Class . forName ( MULTICAST_FLOW_CONTROL_STRATEGY ) . newInstance ( ) ; } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } return flowControl ; } public static TimerWheel newConductorTimerWheel ( ) { return new TimerWheel ( CONDUCTOR_TICK_DURATION_US , TimeUnit . MICROSECONDS , CONDUCTOR_TICKS_PER_WHEEL ) ; } public static int termBufferLength ( ) { return getInteger ( TERM_BUFFER_LENGTH_PROP_NAME , TERM_BUFFER_LENGTH_DEFAULT ) ; } public static int termBufferLengthMax ( ) { return getInteger ( TERM_BUFFER_MAX_LENGTH_PROP_NAME , TERM_BUFFER_LENGTH_MAX_DEFAULT ) ; } public static int initialWindowLength ( ) { return getInteger ( INITIAL_WINDOW_LENGTH_PROP_NAME , INITIAL_WINDOW_LENGTH_DEFAULT ) ; } public static long statusMessageTimeout ( ) { return getLong ( STATUS_MESSAGE_TIMEOUT_PROP_NAME , STATUS_MESSAGE_TIMEOUT_DEFAULT_NS ) ; } public static long dataLossSeed ( ) { return getLong ( DATA_LOSS_SEED_PROP_NAME , - 1 ) ; } public static long controlLossSeed ( ) { return getLong ( CONTROL_LOSS_SEED_PROP_NAME , - 1 ) ; } public static double dataLossRate ( ) { return Double . parseDouble ( getProperty ( DATA_LOSS_RATE_PROP_NAME , "0.0" ) ) ; } public static double controlLossRate ( ) { return Double . parseDouble ( getProperty ( CONTROL_LOSS_RATE_PROP_NAME , "0.0" ) ) ; } public static LossGenerator createLossGenerator ( final double lossRate , final long lossSeed ) { if ( 0 == lossRate ) { return ( address , buffer , length ) - > false ; } return new RandomLossGenerator ( lossRate , lossSeed ) ; } public static ThreadingMode threadingMode ( ) { return ThreadingMode . valueOf ( getProperty ( THREADING_MODE_PROP_NAME , THREADING_MODE_DEFAULT ) ) ; } public static boolean doNotSendNaks ( ) { return Boolean . parseBoolean ( getProperty ( DO_NOT_SEND_NAK_PROP_NAME , "false" ) ) ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . protocol . NakFlyweight ; @ FunctionalInterface public interface NakMessageHandler { void onMessage ( NakFlyweight nakMessage ) ; }
package uk . co . real_logic . aeron . tools ; import java . util . ArrayList ; import java . util . List ; public class MessageSizePattern { final class MessageSizeEntry { final long count ; final int minSize ; final int maxSize ; MessageSizeEntry ( final long count , final int minSize , final int maxSize ) { this . count = count ; this . minSize = minSize ; this . maxSize = maxSize ; } } private int currentIndex = 0 ; private long messageCount = 0 ; private int patternMinSize = Integer . MAX_VALUE ; private int patternMaxSize = 0 ; private final List < MessageSizeEntry > entries = new ArrayList < MessageSizeEntry > ( ) ; public MessageSizePattern ( final int messageSize ) throws Exception { this ( Long . MAX_VALUE , messageSize , messageSize ) ; } public MessageSizePattern ( final long messageCount , final int messageSize ) throws Exception { this ( messageCount , messageSize , messageSize ) ; } public MessageSizePattern ( final long messageCount , final int minSize , final int maxSize ) throws Exception { this . messageCount = 0 ; this . currentIndex = 0 ; addPatternEntry ( messageCount , minSize , maxSize ) ; } public MessageSizePattern ( final MessageSizePattern original ) { this . messageCount = 0 ; this . currentIndex = 0 ; this . patternMinSize = original . patternMinSize ; this . patternMaxSize = original . patternMaxSize ; entries . addAll ( original . entries ) ; } public void addPatternEntry ( final long messageCount , final int size ) throws Exception { addPatternEntry ( messageCount , size , size ) ; } public void addPatternEntry ( final long messages , final int minSize , final int maxSize ) throws Exception { if ( messages < 1 || minSize < 0 || maxSize < 0 ) { throw new Exception ( "Negative values or zero messages are not allowed when adding an entry." ) ; } if ( minSize > maxSize ) { throw new Exception ( "minSize can't be larger than maxSize when adding an entry." ) ; } if ( minSize < patternMinSize ) { patternMinSize = minSize ; } if ( maxSize > patternMaxSize ) { patternMaxSize = maxSize ; } final MessageSizeEntry entry = new MessageSizeEntry ( messages , minSize , maxSize ) ; entries . add ( entry ) ; } public void reset ( ) { this . messageCount = 0 ; this . currentIndex = 0 ; } public int getNext ( ) { if ( messageCount >= entries . get ( currentIndex ) . count ) { messageCount = 0 ; currentIndex ++ ; if ( currentIndex == entries . size ( ) ) { currentIndex = 0 ; } } messageCount ++ ; int value ; final MessageSizeEntry entry = entries . get ( currentIndex ) ; if ( entry . minSize != entry . maxSize ) { value = SeedableThreadLocalRandom . current ( ) . nextInt ( entry . maxSize - entry . minSize + 1 ) + entry . minSize ; } else { value = entry . minSize ; } return value ; } public int minimum ( ) { return patternMinSize ; } public int maximum ( ) { return patternMaxSize ; } public int currentRangeMinimum ( ) { return entries . get ( currentIndex ) . minSize ; } public int currentRangeMaximum ( ) { return entries . get ( currentIndex ) . maxSize ; } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . collections . Long2ObjectHashMap ; import uk . co . real_logic . agrona . concurrent . AtomicCounter ; import uk . co . real_logic . agrona . concurrent . OneToOneConcurrentArrayQueue ; import java . util . Queue ; import java . util . concurrent . TimeUnit ; import java . util . stream . IntStream ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . computePosition ; public class RetransmitHandler { public static final int MAX_RETRANSMITS = Configuration . MAX_RETRANSMITS_DEFAULT ; private final TimerWheel timerWheel ; private final Queue < RetransmitAction > retransmitActionPool = new OneToOneConcurrentArrayQueue < > ( MAX_RETRANSMITS ) ; private final Long2ObjectHashMap < RetransmitAction > activeRetransmitByPositionMap = new Long2ObjectHashMap < > ( ) ; private final AtomicCounter invalidPackets ; private final FeedbackDelayGenerator delayGenerator ; private final FeedbackDelayGenerator lingerTimeoutGenerator ; private final RetransmitSender retransmitSender ; private final int initialTermId ; private final int capacity ; private final int positionBitsToShift ; public RetransmitHandler ( final TimerWheel timerWheel , final SystemCounters systemCounters , final FeedbackDelayGenerator delayGenerator , final FeedbackDelayGenerator lingerTimeoutGenerator , final RetransmitSender retransmitSender , final int initialTermId , final int capacity ) { this . timerWheel = timerWheel ; this . invalidPackets = systemCounters . invalidPackets ( ) ; this . delayGenerator = delayGenerator ; this . lingerTimeoutGenerator = lingerTimeoutGenerator ; this . retransmitSender = retransmitSender ; this . initialTermId = initialTermId ; this . capacity = capacity ; this . positionBitsToShift = Integer . numberOfTrailingZeros ( capacity ) ; IntStream . range ( 0 , MAX_RETRANSMITS ) . forEach ( ( i ) - > retransmitActionPool . offer ( new RetransmitAction ( ) ) ) ; } public void close ( ) { activeRetransmitByPositionMap . forEach ( ( position , retransmitAction ) - > retransmitAction . cancel ( ) ) ; } public void onNak ( final int termId , final int termOffset , final int length ) { if ( isInvalid ( termOffset ) ) { return ; } final long position = computePosition ( termId , termOffset , positionBitsToShift , initialTermId ) ; if ( ! retransmitActionPool . isEmpty ( ) && null == activeRetransmitByPositionMap . get ( position ) ) { final RetransmitAction action = retransmitActionPool . poll ( ) ; action . termId = termId ; action . termOffset = termOffset ; action . length = Math . min ( length , capacity - termOffset ) ; action . position = position ; final long delay = determineRetransmitDelay ( ) ; if ( 0 == delay ) { perform ( action ) ; action . linger ( determineLingerTimeout ( ) ) ; } else { action . delay ( delay ) ; } activeRetransmitByPositionMap . put ( position , action ) ; } } public void onRetransmitReceived ( final int termId , final int termOffset ) { final long position = computePosition ( termId , termOffset , positionBitsToShift , initialTermId ) ; final RetransmitAction action = activeRetransmitByPositionMap . get ( position ) ; if ( null != action && State . DELAYED == action . state ) { activeRetransmitByPositionMap . remove ( position ) ; action . state = State . INACTIVE ; retransmitActionPool . offer ( action ) ; action . delayTimer . cancel ( ) ; } } private boolean isInvalid ( final int termOffset ) { final boolean isInvalid = termOffset >= ( capacity - DataHeaderFlyweight . HEADER_LENGTH ) ; if ( isInvalid ) { invalidPackets . orderedIncrement ( ) ; } return isInvalid ; } private long determineRetransmitDelay ( ) { return delayGenerator . generateDelay ( ) ; } private long determineLingerTimeout ( ) { return lingerTimeoutGenerator . generateDelay ( ) ; } private void perform ( final RetransmitAction action ) { retransmitSender . resend ( action . termId , action . termOffset , action . length ) ; } private enum State { DELAYED , LINGERING , INACTIVE } final class RetransmitAction { long position ; int termId ; int termOffset ; int length ; State state = State . INACTIVE ; TimerWheel . Timer delayTimer = timerWheel . newBlankTimer ( ) ; TimerWheel . Timer lingerTimer = timerWheel . newBlankTimer ( ) ; public void delay ( final long delay ) { state = State . DELAYED ; timerWheel . rescheduleTimeout ( delay , TimeUnit . NANOSECONDS , delayTimer , this : : onDelayTimeout ) ; } public void linger ( final long timeout ) { state = State . LINGERING ; timerWheel . rescheduleTimeout ( timeout , TimeUnit . NANOSECONDS , lingerTimer , this : : onLingerTimeout ) ; } public void onDelayTimeout ( ) { perform ( this ) ; linger ( determineLingerTimeout ( ) ) ; } public void onLingerTimeout ( ) { state = State . INACTIVE ; activeRetransmitByPositionMap . remove ( position ) ; retransmitActionPool . offer ( this ) ; } public void cancel ( ) { delayTimer . cancel ( ) ; lingerTimer . cancel ( ) ; } } }
package uk . co . real_logic . aeron . driver ; import java . net . * ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Enumeration ; import java . util . List ; import static java . lang . Boolean . compare ; import static java . lang . Integer . compare ; import static java . lang . Math . max ; import static java . lang . Math . min ; import static java . util . Collections . sort ; public class NetworkUtil { public static Collection < NetworkInterface > filterBySubnet ( final InetAddress address , final int subnetPrefix ) throws SocketException { return filterBySubnet ( NetworkInterfaceShim . DEFAULT , address , subnetPrefix ) ; } static Collection < NetworkInterface > filterBySubnet ( final NetworkInterfaceShim shim , final InetAddress address , final int subnetPrefix ) throws SocketException { final List < FilterResult > filterResults = new ArrayList < > ( ) ; final byte [ ] queryAddress = address . getAddress ( ) ; final Enumeration < NetworkInterface > ifcs = shim . getNetworkInterfaces ( ) ; while ( ifcs . hasMoreElements ( ) ) { final NetworkInterface ifc = ifcs . nextElement ( ) ; final InterfaceAddress interfaceAddress = findAddressOnInterface ( shim , ifc , queryAddress , subnetPrefix ) ; if ( null != interfaceAddress ) { filterResults . add ( new FilterResult ( interfaceAddress , ifc , shim . isLoopback ( ifc ) ) ) ; } } sort ( filterResults ) ; final List < NetworkInterface > results = new ArrayList < > ( ) ; filterResults . forEach ( ( filterResult ) - > results . add ( filterResult . ifc ) ) ; return results ; } public static InetAddress findAddressOnInterface ( final NetworkInterface ifc , final InetAddress address , final int subnetPrefix ) { final InterfaceAddress interfaceAddress = findAddressOnInterface ( NetworkInterfaceShim . DEFAULT , ifc , address . getAddress ( ) , subnetPrefix ) ; if ( null == interfaceAddress ) { return null ; } return interfaceAddress . getAddress ( ) ; } static InterfaceAddress findAddressOnInterface ( final NetworkInterfaceShim shim , final NetworkInterface ifc , final byte [ ] queryAddress , final int prefixLength ) { InterfaceAddress foundInterfaceAddress = null ; for ( final InterfaceAddress interfaceAddress : shim . getInterfaceAddresses ( ifc ) ) { final byte [ ] candidateAddress = interfaceAddress . getAddress ( ) . getAddress ( ) ; if ( isMatchWithPrefix ( candidateAddress , queryAddress , prefixLength ) ) { foundInterfaceAddress = interfaceAddress ; break ; } } return foundInterfaceAddress ; } static boolean isMatchWithPrefix ( final byte [ ] candidate , final byte [ ] expected , final int prefixLength ) { if ( candidate . length != expected . length ) { return false ; } if ( candidate . length == 4 ) { final int mask = prefixLengthToIpV4Mask ( prefixLength ) ; return ( toInt ( candidate ) & mask ) == ( toInt ( expected ) & mask ) ; } else if ( candidate . length == 16 ) { final long upperMask = prefixLengthToIpV6Mask ( min ( prefixLength , 64 ) ) ; final long lowerMask = prefixLengthToIpV6Mask ( max ( prefixLength - 64 , 0 ) ) ; return ( upperMask & toLong ( candidate , 0 ) ) == ( upperMask & toLong ( expected , 0 ) ) && ( lowerMask & toLong ( candidate , 8 ) ) == ( lowerMask & toLong ( expected , 8 ) ) ; } throw new IllegalArgumentException ( "How many bytes does an IP address have again?" ) ; } private static int prefixLengthToIpV4Mask ( final int subnetPrefix ) { return 0 == subnetPrefix ? 0 : ~ ( ( 1 < < 32 - subnetPrefix ) - 1 ) ; } private static long prefixLengthToIpV6Mask ( final int subnetPrefix ) { return 0 == subnetPrefix ? 0 : ~ ( ( 1L < < 64 - subnetPrefix ) - 1 ) ; } private static int toInt ( final byte [ ] b ) { return ( ( b [ 3 ] & 0xFF ) ) + ( ( b [ 2 ] & 0xFF ) < < 8 ) + ( ( b [ 1 ] & 0xFF ) < < 16 ) + ( ( b [ 0 ] ) < < 24 ) ; } static long toLong ( final byte [ ] b , final int offset ) { return ( ( b [ offset + 7 ] & 0xFFL ) ) + ( ( b [ offset + 6 ] & 0xFFL ) < < 8 ) + ( ( b [ offset + 5 ] & 0xFFL ) < < 16 ) + ( ( b [ offset + 4 ] & 0xFFL ) < < 24 ) + ( ( b [ offset + 3 ] & 0xFFL ) < < 32 ) + ( ( b [ offset + 2 ] & 0xFFL ) < < 40 ) + ( ( b [ offset + 1 ] & 0xFFL ) < < 48 ) + ( ( ( long ) b [ offset ] ) < < 56 ) ; } public static ProtocolFamily getProtocolFamily ( InetAddress address ) { if ( address instanceof Inet4Address ) { return StandardProtocolFamily . INET ; } else if ( address instanceof Inet6Address ) { return StandardProtocolFamily . INET6 ; } else { throw new IllegalStateException ( "Unknown ProtocolFamily" ) ; } } private static class FilterResult implements Comparable < FilterResult > { private final InterfaceAddress interfaceAddress ; private final NetworkInterface ifc ; private final boolean isLoopback ; public FilterResult ( final InterfaceAddress interfaceAddress , final NetworkInterface ifc , final boolean isLoopback ) throws SocketException { this . interfaceAddress = interfaceAddress ; this . ifc = ifc ; this . isLoopback = isLoopback ; } public int compareTo ( final FilterResult other ) { if ( isLoopback == other . isLoopback ) { return - compare ( interfaceAddress . getNetworkPrefixLength ( ) , other . interfaceAddress . getNetworkPrefixLength ( ) ) ; } else { return compare ( isLoopback , other . isLoopback ) ; } } } }
package uk . co . real_logic . aeron . driver ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . net . InetSocketAddress ; @ FunctionalInterface public interface LossGenerator { boolean shouldDropFrame ( InetSocketAddress address , UnsafeBuffer buffer , int length ) ; }
package uk . co . real_logic . aeron . driver ; import java . net . InetSocketAddress ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . computePosition ; public class UnicastFlowControl implements FlowControl { private long positionLimit = 0 ; private int positionBitsToShift ; private int initialTermId ; public long onStatusMessage ( final int termId , final int rebuildTermOffset , final int receiverWindowLength , final InetSocketAddress address ) { final long position = computePosition ( termId , rebuildTermOffset , positionBitsToShift , initialTermId ) ; final long newPositionLimit = position + receiverWindowLength ; positionLimit = Math . max ( positionLimit , newPositionLimit ) ; return positionLimit ; } public long initialPositionLimit ( final int initialTermId , final int termBufferCapacity ) { this . initialTermId = initialTermId ; positionBitsToShift = Long . numberOfTrailingZeros ( termBufferCapacity ) ; positionLimit = computePosition ( initialTermId , 0 , positionBitsToShift , initialTermId ) ; return positionLimit ; } }
package uk . co . real_logic . aeron . driver ; public class PublicationLink { private final long registrationId ; private final NetworkPublication publication ; private final AeronClient client ; public PublicationLink ( final long registrationId , final NetworkPublication publication , final AeronClient client ) { this . registrationId = registrationId ; this . publication = publication ; this . client = client ; } public void remove ( ) { publication . decRef ( ) ; } public long registrationId ( ) { return registrationId ; } public boolean hasClientTimedOut ( final long now ) { final boolean hasClientTimedOut = client . hasTimedOut ( now ) ; if ( hasClientTimedOut ) { publication . decRef ( ) ; } return hasClientTimedOut ; } }
package uk . co . real_logic . aeron . driver . media ; import uk . co . real_logic . agrona . LangUtil ; import java . io . IOException ; import java . lang . reflect . Field ; import java . nio . channels . ClosedChannelException ; import java . nio . channels . SelectionKey ; import java . nio . channels . Selector ; public class TransportPoller implements AutoCloseable { private static final int ITERATION_THRESHOLD = 5 ; private static final Field SELECTED_KEYS_FIELD ; private static final Field PUBLIC_SELECTED_KEYS_FIELD ; static { Field selectKeysField = null ; Field publicSelectKeysField = null ; try { final Class < ? > clazz = Class . forName ( "sun.nio.ch.SelectorImpl" , false , ClassLoader . getSystemClassLoader ( ) ) ; if ( clazz . isAssignableFrom ( Selector . open ( ) . getClass ( ) ) ) { selectKeysField = clazz . getDeclaredField ( "selectedKeys" ) ; selectKeysField . setAccessible ( true ) ; publicSelectKeysField = clazz . getDeclaredField ( "publicSelectedKeys" ) ; publicSelectKeysField . setAccessible ( true ) ; } } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } finally { SELECTED_KEYS_FIELD = selectKeysField ; PUBLIC_SELECTED_KEYS_FIELD = publicSelectKeysField ; } } private final Selector selector ; private final NioSelectedKeySet selectedKeySet ; private UdpChannelTransport [ ] transports = new UdpChannelTransport [ 0 ] ; public TransportPoller ( ) { try { selector = Selector . open ( ) ; selectedKeySet = new NioSelectedKeySet ( ) ; SELECTED_KEYS_FIELD . set ( selector , selectedKeySet ) ; PUBLIC_SELECTED_KEYS_FIELD . set ( selector , selectedKeySet ) ; } catch ( final Exception ex ) { throw new RuntimeException ( ex ) ; } } public SelectionKey registerForRead ( final UdpChannelTransport transport ) { SelectionKey key = null ; try { addTransport ( transport ) ; key = transport . datagramChannel ( ) . register ( selector , SelectionKey . OP_READ , transport ) ; } catch ( final ClosedChannelException ex ) { LangUtil . rethrowUnchecked ( ex ) ; } return key ; } public void cancelRead ( final UdpChannelTransport transport ) { removeTransport ( transport ) ; } public void close ( ) { selector . wakeup ( ) ; try { selector . close ( ) ; } catch ( final IOException ex ) { LangUtil . rethrowUnchecked ( ex ) ; } } public int pollTransports ( ) { int bytesReceived = 0 ; try { final UdpChannelTransport [ ] transports = this . transports ; final int numTransports = transports . length ; if ( numTransports <= ITERATION_THRESHOLD ) { for ( int i = numTransports - 1 ; i >= 0 ; i -- ) { bytesReceived += transports [ i ] . pollForData ( ) ; } } else { selector . selectNow ( ) ; final SelectionKey [ ] keys = selectedKeySet . keys ( ) ; for ( int i = selectedKeySet . size ( ) - 1 ; i >= 0 ; i -- ) { bytesReceived += ( ( UdpChannelTransport ) keys [ i ] . attachment ( ) ) . pollForData ( ) ; } selectedKeySet . reset ( ) ; } } catch ( final IOException ex ) { LangUtil . rethrowUnchecked ( ex ) ; } return bytesReceived ; } public void selectNowWithoutProcessing ( ) { try { selector . selectNow ( ) ; selectedKeySet . reset ( ) ; } catch ( final IOException ex ) { LangUtil . rethrowUnchecked ( ex ) ; } } private void addTransport ( final UdpChannelTransport transport ) { final UdpChannelTransport [ ] oldTransports = transports ; final int length = oldTransports . length ; final UdpChannelTransport [ ] newTransports = new UdpChannelTransport [ length + 1 ] ; System . arraycopy ( oldTransports , 0 , newTransports , 0 , length ) ; newTransports [ length ] = transport ; transports = newTransports ; } private void removeTransport ( final UdpChannelTransport transport ) { final UdpChannelTransport [ ] oldTransports = transports ; final int length = oldTransports . length ; final UdpChannelTransport [ ] newTransports = new UdpChannelTransport [ length - 1 ] ; for ( int i = 0 , j = 0 ; i < length ; i ++ ) { if ( oldTransports [ i ] != transport ) { newTransports [ j ++ ] = oldTransports [ i ] ; } } transports = newTransports ; } }
package uk . co . real_logic . aeron . driver . media ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . aeron . protocol . NakFlyweight ; import uk . co . real_logic . aeron . protocol . StatusMessageFlyweight ; import uk . co . real_logic . aeron . driver . LossGenerator ; import uk . co . real_logic . aeron . driver . NakMessageHandler ; import uk . co . real_logic . aeron . driver . StatusMessageHandler ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . net . InetSocketAddress ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . frameType ; import static uk . co . real_logic . aeron . protocol . HeaderFlyweight . HDR_TYPE_NAK ; import static uk . co . real_logic . aeron . protocol . HeaderFlyweight . HDR_TYPE_SM ; public final class SenderUdpChannelTransport extends UdpChannelTransport { private final NakFlyweight nakMessage = new NakFlyweight ( ) ; private final StatusMessageFlyweight statusMessage = new StatusMessageFlyweight ( ) ; private final StatusMessageHandler smMessageHandler ; private final NakMessageHandler nakMessageHandler ; public SenderUdpChannelTransport ( final UdpChannel udpChannel , final StatusMessageHandler smMessageHandler , final NakMessageHandler nakMessageHandler , final EventLogger logger , final LossGenerator lossGenerator ) { super ( udpChannel , udpChannel . remoteControl ( ) , udpChannel . localControl ( ) , lossGenerator , logger ) ; this . smMessageHandler = smMessageHandler ; this . nakMessageHandler = nakMessageHandler ; nakMessage . wrap ( receiveBuffer ( ) , 0 ) ; statusMessage . wrap ( receiveBuffer ( ) , 0 ) ; } protected int dispatch ( final UnsafeBuffer buffer , final int length , final InetSocketAddress srcAddress ) { int framesRead = 0 ; switch ( frameType ( buffer , 0 ) ) { case HDR_TYPE_NAK : nakMessageHandler . onMessage ( nakMessage ) ; framesRead = 1 ; break ; case HDR_TYPE_SM : smMessageHandler . onMessage ( statusMessage , srcAddress ) ; framesRead = 1 ; break ; } return framesRead ; } }
package uk . co . real_logic . aeron . driver . media ; import uk . co . real_logic . aeron . driver . event . EventCode ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . aeron . protocol . HeaderFlyweight ; import uk . co . real_logic . aeron . driver . Configuration ; import uk . co . real_logic . aeron . driver . LossGenerator ; import uk . co . real_logic . agrona . LangUtil ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . net . NetworkInterface ; import java . net . SocketOption ; import java . net . StandardSocketOptions ; import java . nio . ByteBuffer ; import java . nio . channels . ClosedByInterruptException ; import java . nio . channels . DatagramChannel ; import java . nio . channels . SelectionKey ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . frameLength ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . frameVersion ; public abstract class UdpChannelTransport implements AutoCloseable { private final UdpChannel udpChannel ; private final LossGenerator lossGenerator ; private final EventLogger logger ; private final ByteBuffer receiveByteBuffer = ByteBuffer . allocateDirect ( Configuration . RECEIVE_BYTE_BUFFER_LENGTH ) ; private final UnsafeBuffer receiveBuffer = new UnsafeBuffer ( receiveByteBuffer ) ; private InetSocketAddress endPointSocketAddress ; private InetSocketAddress bindSocketAddress ; private DatagramChannel datagramChannel ; private SelectionKey selectionKey ; private TransportPoller transportPoller ; public UdpChannelTransport ( final UdpChannel udpChannel , final InetSocketAddress endPointSocketAddress , final InetSocketAddress bindSocketAddress , final LossGenerator lossGenerator , final EventLogger logger ) { this . udpChannel = udpChannel ; this . lossGenerator = lossGenerator ; this . logger = logger ; this . endPointSocketAddress = endPointSocketAddress ; this . bindSocketAddress = bindSocketAddress ; } public void openDatagramChannel ( ) { try { datagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; if ( udpChannel . isMulticast ( ) ) { final NetworkInterface localInterface = udpChannel . localInterface ( ) ; datagramChannel . setOption ( StandardSocketOptions . SO_REUSEADDR , true ) ; datagramChannel . bind ( new InetSocketAddress ( endPointSocketAddress . getPort ( ) ) ) ; datagramChannel . join ( endPointSocketAddress . getAddress ( ) , localInterface ) ; datagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_IF , localInterface ) ; } else { datagramChannel . bind ( bindSocketAddress ) ; } if ( 0 != Configuration . SOCKET_SNDBUF_LENGTH ) { datagramChannel . setOption ( StandardSocketOptions . SO_SNDBUF , Configuration . SOCKET_SNDBUF_LENGTH ) ; } if ( 0 != Configuration . SOCKET_RCVBUF_LENGTH ) { datagramChannel . setOption ( StandardSocketOptions . SO_RCVBUF , Configuration . SOCKET_RCVBUF_LENGTH ) ; } datagramChannel . configureBlocking ( false ) ; } catch ( final IOException ex ) { throw new RuntimeException ( String . format ( "channel \"%s\" : %s" , udpChannel . originalUriString ( ) , ex . toString ( ) ) , ex ) ; } } public void registerForRead ( final TransportPoller transportPoller ) { this . transportPoller = transportPoller ; selectionKey = transportPoller . registerForRead ( this ) ; } public UdpChannel udpChannel ( ) { return udpChannel ; } public DatagramChannel datagramChannel ( ) { return datagramChannel ; } public int sendTo ( final ByteBuffer buffer , final InetSocketAddress remoteAddress ) { logger . logFrameOut ( buffer , remoteAddress ) ; int bytesSent = 0 ; try { bytesSent = datagramChannel . send ( buffer , remoteAddress ) ; } catch ( final IOException ex ) { LangUtil . rethrowUnchecked ( ex ) ; } return bytesSent ; } public void close ( ) { try { if ( null != selectionKey ) { selectionKey . cancel ( ) ; } if ( null != transportPoller ) { transportPoller . cancelRead ( this ) ; } datagramChannel . close ( ) ; } catch ( final Exception ex ) { logger . logException ( ex ) ; } } public boolean isMulticast ( ) { return udpChannel . isMulticast ( ) ; } public < T > T getOption ( final SocketOption < T > name ) { T option = null ; try { option = datagramChannel . getOption ( name ) ; } catch ( final IOException ex ) { LangUtil . rethrowUnchecked ( ex ) ; } return option ; } public int receiveBufferCapacity ( ) { return receiveByteBuffer . capacity ( ) ; } protected abstract int dispatch ( final UnsafeBuffer receiveBuffer , final int length , final InetSocketAddress srcAddress ) ; public int pollForData ( ) { int bytesReceived = 0 ; final InetSocketAddress srcAddress = receive ( ) ; if ( null != srcAddress ) { final int length = receiveByteBuffer . position ( ) ; if ( lossGenerator . shouldDropFrame ( srcAddress , receiveBuffer , length ) ) { logger . logFrameInDropped ( receiveByteBuffer , 0 , length , srcAddress ) ; } else { logger . logFrameIn ( receiveByteBuffer , 0 , length , srcAddress ) ; if ( isValidFrame ( receiveBuffer , length ) ) { bytesReceived = dispatch ( receiveBuffer , length , srcAddress ) ; } } } return bytesReceived ; } protected UnsafeBuffer receiveBuffer ( ) { return receiveBuffer ; } private boolean isValidFrame ( final UnsafeBuffer receiveBuffer , final int length ) { boolean isFrameValid = true ; if ( frameVersion ( receiveBuffer , 0 ) != HeaderFlyweight . CURRENT_VERSION ) { logger . log ( EventCode . INVALID_VERSION , receiveBuffer , 0 , frameLength ( receiveBuffer , 0 ) ) ; isFrameValid = false ; } else if ( length < HeaderFlyweight . HEADER_LENGTH ) { logger . log ( EventCode . MALFORMED_FRAME_LENGTH , receiveBuffer , 0 , length ) ; isFrameValid = false ; } return isFrameValid ; } private InetSocketAddress receive ( ) { receiveByteBuffer . clear ( ) ; InetSocketAddress address = null ; try { address = ( InetSocketAddress ) datagramChannel . receive ( receiveByteBuffer ) ; } catch ( final ClosedByInterruptException ignored ) { } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } return address ; } }
package uk . co . real_logic . aeron . driver . media ; import uk . co . real_logic . aeron . ErrorCode ; import uk . co . real_logic . aeron . driver . UriUtil ; import uk . co . real_logic . aeron . driver . uri . AeronUri ; import uk . co . real_logic . aeron . driver . uri . InterfaceSearchAddress ; import uk . co . real_logic . aeron . driver . exceptions . InvalidChannelException ; import uk . co . real_logic . agrona . BitUtil ; import java . net . * ; import java . util . Arrays ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import static java . lang . String . format ; import static java . lang . System . lineSeparator ; import static java . net . InetAddress . getByAddress ; import static uk . co . real_logic . aeron . driver . NetworkUtil . * ; import static uk . co . real_logic . aeron . driver . Strings . isEmpty ; public final class UdpChannel { private static final String UDP_MEDIA_ID = "udp" ; private static final String REMOTE_KEY = "remote" ; private static final String LOCAL_KEY = "local" ; private static final String INTERFACE_KEY = "interface" ; private static final String GROUP_KEY = "group" ; private static final String [ ] UNICAST_KEYS = { LOCAL_KEY , REMOTE_KEY } ; private static final String [ ] MULTICAST_KEYS = { GROUP_KEY , INTERFACE_KEY } ; private final InetSocketAddress remoteData ; private final InetSocketAddress localData ; private final InetSocketAddress remoteControl ; private final InetSocketAddress localControl ; private final String uriStr ; private final String canonicalForm ; private final NetworkInterface localInterface ; private final ProtocolFamily protocolFamily ; public static UdpChannel parse ( final String uriStr ) { try { final AeronUri uri = parseIntoAeronUri ( uriStr ) ; validateConfiguration ( uri ) ; final Context context = new Context ( ) . uriStr ( uriStr ) ; if ( isMulticast ( uri ) ) { final InetSocketAddress dataAddress = uri . getSocketAddress ( GROUP_KEY ) ; final byte [ ] addressAsBytes = dataAddress . getAddress ( ) . getAddress ( ) ; validateDataAddress ( addressAsBytes ) ; addressAsBytes [ addressAsBytes . length - 1 ] ++ ; final InetSocketAddress controlAddress = new InetSocketAddress ( getByAddress ( addressAsBytes ) , dataAddress . getPort ( ) ) ; final InterfaceSearchAddress searchAddress = uri . getInterfaceSearchAddress ( INTERFACE_KEY , InterfaceSearchAddress . wildcard ( ) ) ; final NetworkInterface localInterface = findInterface ( searchAddress ) ; final InetSocketAddress localAddress = resolveToAddressOfInterface ( localInterface , searchAddress ) ; final ProtocolFamily protocolFamily = getProtocolFamily ( dataAddress . getAddress ( ) ) ; context . localControlAddress ( localAddress ) . remoteControlAddress ( controlAddress ) . localDataAddress ( localAddress ) . remoteDataAddress ( dataAddress ) . localInterface ( localInterface ) . protocolFamily ( protocolFamily ) . canonicalForm ( canonicalise ( localAddress , dataAddress ) ) ; } else { final InetSocketAddress remoteAddress = uri . getSocketAddress ( REMOTE_KEY ) ; final InetSocketAddress localAddress = uri . getSocketAddress ( LOCAL_KEY , 0 , new InetSocketAddress ( 0 ) ) ; final ProtocolFamily protocolFamily = ! uri . containsKey ( LOCAL_KEY ) && null != remoteAddress ? getProtocolFamily ( remoteAddress . getAddress ( ) ) : getProtocolFamily ( localAddress . getAddress ( ) ) ; context . remoteControlAddress ( remoteAddress ) . remoteDataAddress ( remoteAddress ) . localControlAddress ( localAddress ) . localDataAddress ( localAddress ) . protocolFamily ( protocolFamily ) . canonicalForm ( canonicalise ( localAddress , remoteAddress ) ) ; } return new UdpChannel ( context ) ; } catch ( final Exception ex ) { throw new InvalidChannelException ( ErrorCode . INVALID_CHANNEL , ex ) ; } } private static void validateDataAddress ( final byte [ ] addressAsBytes ) { if ( BitUtil . isEven ( addressAsBytes [ addressAsBytes . length - 1 ] ) ) { throw new IllegalArgumentException ( "Multicast data address must be odd" ) ; } } private static boolean isMulticast ( final AeronUri uri ) { return uri . containsKey ( GROUP_KEY ) ; } private static void validateConfiguration ( AeronUri uri ) { validateMedia ( uri ) ; validateUnicastXorMulticast ( uri ) ; } private static void validateMedia ( final AeronUri uri ) { if ( ! UDP_MEDIA_ID . equals ( uri . getMedia ( ) ) ) { throw new IllegalArgumentException ( "Udp channel only supports udp media: " + uri ) ; } } private static void validateUnicastXorMulticast ( final AeronUri uri ) { final boolean hasMulticastKeys = uri . containsAnyKey ( MULTICAST_KEYS ) ; final boolean hasUnicastKeys = uri . containsAnyKey ( UNICAST_KEYS ) ; if ( ! ( hasMulticastKeys ^ hasUnicastKeys ) ) { final String msg = "URI must contain either a unicast configuration (%s) or a multicast configuration (%s) not both" ; throw new IllegalArgumentException ( format ( msg , Arrays . toString ( UNICAST_KEYS ) , Arrays . toString ( MULTICAST_KEYS ) ) ) ; } } private static AeronUri parseIntoAeronUri ( final String uriStr ) throws URISyntaxException , UnknownHostException { if ( uriStr . startsWith ( "udp:" ) ) { return parseUdpUriToAeronUri ( uriStr ) ; } else if ( uriStr . startsWith ( "aeron:" ) ) { return AeronUri . parse ( uriStr ) ; } throw new IllegalArgumentException ( "malformed channel URI: " + uriStr ) ; } private static AeronUri parseUdpUriToAeronUri ( final String uriStr ) throws URISyntaxException , UnknownHostException { final URI uri = new URI ( uriStr ) ; final String userInfo = uri . getUserInfo ( ) ; final int uriPort = uri . getPort ( ) ; final Map < String , String > params = UriUtil . parseQueryString ( uri , new HashMap < > ( ) ) ; if ( uriPort < 0 ) { throw new IllegalArgumentException ( "Port must be specified" ) ; } final InetAddress hostAddress = InetAddress . getByName ( uri . getHost ( ) ) ; if ( hostAddress . isMulticastAddress ( ) ) { final String group = uri . getHost ( ) + ":" + uriPort ; final String inf = interfaceStringOf ( userInfo , params . get ( "subnetPrefix" ) ) ; return AeronUri . builder ( ) . media ( UDP_MEDIA_ID ) . param ( GROUP_KEY , group ) . param ( INTERFACE_KEY , inf ) . newInstance ( ) ; } else { final String remote = uri . getHost ( ) + ":" + uriPort ; final String local = userInfo ; return AeronUri . builder ( ) . media ( UDP_MEDIA_ID ) . param ( REMOTE_KEY , remote ) . param ( LOCAL_KEY , local ) . newInstance ( ) ; } } private static String interfaceStringOf ( final String userInfo , final String subnetPrefix ) { if ( isEmpty ( userInfo ) ) { return null ; } if ( isEmpty ( subnetPrefix ) ) { return userInfo ; } return userInfo + "/" + subnetPrefix ; } private static InetSocketAddress resolveToAddressOfInterface ( final NetworkInterface localInterface , final InterfaceSearchAddress searchAddress ) { final InetAddress interfaceAddress = findAddressOnInterface ( localInterface , searchAddress . getInetAddress ( ) , searchAddress . getSubnetPrefix ( ) ) ; if ( null == interfaceAddress ) { throw new IllegalStateException ( ) ; } return new InetSocketAddress ( interfaceAddress , searchAddress . getPort ( ) ) ; } private static NetworkInterface findInterface ( final InterfaceSearchAddress searchAddress ) throws SocketException , UnknownHostException { final Collection < NetworkInterface > filteredIfcs = filterBySubnet ( searchAddress . getInetAddress ( ) , searchAddress . getSubnetPrefix ( ) ) ; for ( final NetworkInterface ifc : filteredIfcs ) { if ( ifc . supportsMulticast ( ) || ifc . isLoopback ( ) ) { return ifc ; } } throw new IllegalArgumentException ( errorNoMatchingInterfaces ( filteredIfcs , searchAddress ) ) ; } public InetSocketAddress remoteData ( ) { return remoteData ; } public InetSocketAddress localData ( ) { return localData ; } public InetSocketAddress remoteControl ( ) { return remoteControl ; } public InetSocketAddress localControl ( ) { return localControl ; } private UdpChannel ( final Context context ) { this . remoteData = context . remoteData ; this . localData = context . localData ; this . remoteControl = context . remoteControl ; this . localControl = context . localControl ; this . uriStr = context . uriStr ; this . canonicalForm = context . canonicalForm ; this . localInterface = context . localInterface ; this . protocolFamily = context . protocolFamily ; } public String canonicalForm ( ) { return canonicalForm ; } public boolean equals ( final Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } final UdpChannel that = ( UdpChannel ) o ; return ! ( canonicalForm != null ? ! canonicalForm . equals ( that . canonicalForm ) : that . canonicalForm != null ) ; } public int hashCode ( ) { return canonicalForm != null ? canonicalForm . hashCode ( ) : 0 ; } public String toString ( ) { return canonicalForm ; } public static String canonicalise ( final InetSocketAddress localData , final InetSocketAddress remoteData ) { return String . format ( "UDP-%1$s-%2$d-%3$s-%4$d" , BitUtil . toHex ( localData . getAddress ( ) . getAddress ( ) ) , localData . getPort ( ) , BitUtil . toHex ( remoteData . getAddress ( ) . getAddress ( ) ) , remoteData . getPort ( ) ) ; } public boolean isMulticast ( ) { return remoteData . getAddress ( ) . isMulticastAddress ( ) ; } public NetworkInterface localInterface ( ) throws SocketException { return localInterface ; } public String originalUriString ( ) { return uriStr ; } public ProtocolFamily protocolFamily ( ) { return protocolFamily ; } private static class Context { private InetSocketAddress remoteData ; private InetSocketAddress localData ; private InetSocketAddress remoteControl ; private InetSocketAddress localControl ; private String uriStr ; private String canonicalForm ; private NetworkInterface localInterface ; private ProtocolFamily protocolFamily ; public Context uriStr ( final String uri ) { uriStr = uri ; return this ; } public Context remoteDataAddress ( final InetSocketAddress remoteData ) { this . remoteData = remoteData ; return this ; } public Context localDataAddress ( final InetSocketAddress localData ) { this . localData = localData ; return this ; } public Context remoteControlAddress ( final InetSocketAddress remoteControl ) { this . remoteControl = remoteControl ; return this ; } public Context localControlAddress ( final InetSocketAddress localControl ) { this . localControl = localControl ; return this ; } public Context canonicalForm ( final String canonicalForm ) { this . canonicalForm = canonicalForm ; return this ; } public Context localInterface ( final NetworkInterface ifc ) { this . localInterface = ifc ; return this ; } public Context protocolFamily ( ProtocolFamily protocolFamily ) { this . protocolFamily = protocolFamily ; return this ; } } private static String errorNoMatchingInterfaces ( final Collection < NetworkInterface > filteredIfcs , final InterfaceSearchAddress address ) throws SocketException { final StringBuilder builder = new StringBuilder ( ) ; builder . append ( "Unable to find multicast interface matching criteria: " ) . append ( address . getAddress ( ) ) . append ( "/" ) . append ( address . getSubnetPrefix ( ) ) ; if ( filteredIfcs . size ( ) > 0 ) { builder . append ( lineSeparator ( ) ) . append ( " Candidates:" ) ; for ( final NetworkInterface ifc : filteredIfcs ) { builder . append ( lineSeparator ( ) ) . append ( " - Name: " ) . append ( ifc . getDisplayName ( ) ) . append ( ", addresses: " ) . append ( ifc . getInterfaceAddresses ( ) ) . append ( ", multicast: " ) . append ( ifc . supportsMulticast ( ) ) ; } } return builder . toString ( ) ; } public String description ( ) { final StringBuilder builder = new StringBuilder ( "UdpChannel - " ) ; if ( null != localInterface ) { builder . append ( "interface: " ) . append ( localInterface . getDisplayName ( ) ) . append ( ", " ) ; } builder . append ( "localData: " ) . append ( localData ) . append ( ", remoteData: " ) . append ( remoteData ) ; return builder . toString ( ) ; } }
package uk . co . real_logic . aeron . driver . media ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . protocol . SetupFlyweight ; import uk . co . real_logic . aeron . driver . DataPacketHandler ; import uk . co . real_logic . aeron . driver . LossGenerator ; import uk . co . real_logic . aeron . driver . SetupMessageHandler ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . net . InetSocketAddress ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . frameType ; import static uk . co . real_logic . aeron . protocol . HeaderFlyweight . * ; public final class ReceiverUdpChannelTransport extends UdpChannelTransport { private final DataHeaderFlyweight dataHeader = new DataHeaderFlyweight ( ) ; private final SetupFlyweight setupHeader = new SetupFlyweight ( ) ; private final DataPacketHandler dataPacketHandler ; private final SetupMessageHandler setupMessageHandler ; public ReceiverUdpChannelTransport ( final UdpChannel udpChannel , final DataPacketHandler dataPacketHandler , final SetupMessageHandler setupMessageHandler , final EventLogger logger , final LossGenerator lossGenerator ) { super ( udpChannel , udpChannel . remoteData ( ) , udpChannel . remoteData ( ) , lossGenerator , logger ) ; this . dataPacketHandler = dataPacketHandler ; this . setupMessageHandler = setupMessageHandler ; dataHeader . wrap ( receiveBuffer ( ) , 0 ) ; setupHeader . wrap ( receiveBuffer ( ) , 0 ) ; } protected int dispatch ( final UnsafeBuffer buffer , final int length , final InetSocketAddress srcAddress ) { int bytesReceived = 0 ; switch ( frameType ( buffer , 0 ) ) { case HDR_TYPE_PAD : case HDR_TYPE_DATA : bytesReceived = dataPacketHandler . onDataPacket ( dataHeader , buffer , length , srcAddress ) ; break ; case HDR_TYPE_SETUP : setupMessageHandler . onSetupMessage ( setupHeader , buffer , length , srcAddress ) ; break ; } return bytesReceived ; } }
package uk . co . real_logic . aeron . tools ; import java . util . Date ; public class StatsConsoleOutput implements StatsOutput { public StatsConsoleOutput ( ) { } public void format ( final String [ ] keys , final long [ ] vals ) throws Exception { System . out . print ( "\033[H\033[2J" ) ; System . out . format ( "%1$tH:%1$tM:%1$tS - Aeron Stats\n" , new Date ( ) ) ; System . out . println ( "===============================" ) ; for ( int i = 0 ; i < keys . length ; i ++ ) { System . out . println ( keys [ i ] + ": " + vals [ i ] ) ; } } public void close ( ) throws Exception { } }
package uk . co . real_logic . aeron . driver . media ; import uk . co . real_logic . agrona . BitUtil ; import java . nio . channels . SelectionKey ; import java . util . AbstractSet ; import java . util . Arrays ; import java . util . Iterator ; import java . util . function . ToIntFunction ; public class NioSelectedKeySet extends AbstractSet < SelectionKey > { private static final int INITIAL_CAPACITY = 16 ; private SelectionKey [ ] keys ; private int size = 0 ; public NioSelectedKeySet ( ) { this ( INITIAL_CAPACITY ) ; } public NioSelectedKeySet ( final int initialCapacity ) { keys = new SelectionKey [ BitUtil . findNextPositivePowerOfTwo ( initialCapacity ) ] ; } public int size ( ) { return size ; } public int capacity ( ) { return keys . length ; } public boolean add ( final SelectionKey selectionKey ) { if ( null == selectionKey ) { return false ; } ensureCapacity ( size + 1 ) ; keys [ size ++ ] = selectionKey ; return true ; } public boolean remove ( final Object o ) { return false ; } public boolean contains ( final Object o ) { return false ; } public SelectionKey [ ] keys ( ) { return keys ; } public void reset ( ) { size = 0 ; } public int forEach ( final ToIntFunction < SelectionKey > function ) { int handledFrames = 0 ; final SelectionKey [ ] keys = this . keys ; for ( int i = size - 1 ; i >= 0 ; i -- ) { handledFrames += function . applyAsInt ( keys [ i ] ) ; } size = 0 ; return handledFrames ; } public Iterator < SelectionKey > iterator ( ) { throw new UnsupportedOperationException ( ) ; } private void ensureCapacity ( final int requiredCapacity ) { if ( requiredCapacity < 0 ) { final String s = String . format ( "Insufficient capacity: length=%d required=%d" , keys . length , requiredCapacity ) ; throw new IllegalStateException ( s ) ; } if ( requiredCapacity > keys . length ) { final int newCapacity = BitUtil . findNextPositivePowerOfTwo ( requiredCapacity ) ; keys = Arrays . copyOf ( keys , newCapacity ) ; } } }
package uk . co . real_logic . aeron . driver . media ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . aeron . driver . * ; import uk . co . real_logic . aeron . driver . exceptions . ConfigurationException ; import uk . co . real_logic . aeron . protocol . * ; import uk . co . real_logic . agrona . collections . Int2ObjectHashMap ; import uk . co . real_logic . agrona . collections . MutableInteger ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . net . InetSocketAddress ; import java . net . StandardSocketOptions ; import java . nio . ByteBuffer ; public class ReceiveChannelEndpoint implements AutoCloseable { private final UdpChannelTransport transport ; private final DataPacketDispatcher dispatcher ; private final SystemCounters systemCounters ; private final Int2ObjectHashMap < MutableInteger > refCountByStreamIdMap = new Int2ObjectHashMap < > ( ) ; private final ByteBuffer smBuffer = ByteBuffer . allocateDirect ( StatusMessageFlyweight . HEADER_LENGTH ) ; private final ByteBuffer nakBuffer = ByteBuffer . allocateDirect ( NakFlyweight . HEADER_LENGTH ) ; private final StatusMessageFlyweight smHeader = new StatusMessageFlyweight ( ) ; private final NakFlyweight nakHeader = new NakFlyweight ( ) ; private volatile boolean isClosed = false ; public ReceiveChannelEndpoint ( final UdpChannel udpChannel , final DriverConductorProxy conductorProxy , final Receiver receiver , final EventLogger logger , final SystemCounters systemCounters , final LossGenerator lossGenerator ) { smHeader . wrap ( smBuffer , 0 ) ; smHeader . version ( HeaderFlyweight . CURRENT_VERSION ) . flags ( ( byte ) 0 ) . headerType ( HeaderFlyweight . HDR_TYPE_SM ) . frameLength ( StatusMessageFlyweight . HEADER_LENGTH ) ; nakHeader . wrap ( nakBuffer , 0 ) ; nakHeader . version ( HeaderFlyweight . CURRENT_VERSION ) . flags ( ( byte ) 0 ) . headerType ( HeaderFlyweight . HDR_TYPE_NAK ) . frameLength ( NakFlyweight . HEADER_LENGTH ) ; this . systemCounters = systemCounters ; dispatcher = new DataPacketDispatcher ( conductorProxy , receiver , this ) ; transport = new ReceiverUdpChannelTransport ( udpChannel , dispatcher , dispatcher , logger , lossGenerator ) ; } public UdpChannelTransport transport ( ) { return transport ; } public UdpChannel udpChannel ( ) { return transport . udpChannel ( ) ; } public String originalUriString ( ) { return transport . udpChannel ( ) . originalUriString ( ) ; } public void close ( ) { transport . close ( ) ; isClosed = true ; } public boolean isClosed ( ) { return isClosed ; } public void openChannel ( ) { transport . openDatagramChannel ( ) ; } public void registerForRead ( final TransportPoller transportPoller ) { transport . registerForRead ( transportPoller ) ; } public DataPacketDispatcher dispatcher ( ) { return dispatcher ; } public int incRefToStream ( final int streamId ) { MutableInteger count = refCountByStreamIdMap . get ( streamId ) ; if ( null == count ) { count = new MutableInteger ( ) ; refCountByStreamIdMap . put ( streamId , count ) ; } count . value ++ ; return count . value ; } public int decRefToStream ( final int streamId ) { final MutableInteger count = refCountByStreamIdMap . get ( streamId ) ; if ( null == count ) { throw new IllegalStateException ( "Could not find stream Id to decrement: " + streamId ) ; } count . value -- ; if ( 0 == count . value ) { refCountByStreamIdMap . remove ( streamId ) ; } return count . value ; } public int streamCount ( ) { return refCountByStreamIdMap . size ( ) ; } public int onDataPacket ( final DataHeaderFlyweight header , final UnsafeBuffer buffer , final int length , final InetSocketAddress srcAddress ) { return dispatcher . onDataPacket ( header , buffer , length , srcAddress ) ; } public void onSetupMessage ( final SetupFlyweight header , final UnsafeBuffer buffer , final int length , final InetSocketAddress srcAddress ) { dispatcher . onSetupMessage ( header , buffer , length , srcAddress ) ; } public void sendSetupElicitingStatusMessage ( final InetSocketAddress controlAddress , final int sessionId , final int streamId ) { sendStatusMessage ( controlAddress , sessionId , streamId , 0 , 0 , 0 , StatusMessageFlyweight . SEND_SETUP_FLAG ) ; } public void validateWindowMaxLength ( final int windowMaxLength ) { final int soRcvbuf = transport . getOption ( StandardSocketOptions . SO_RCVBUF ) ; if ( windowMaxLength > soRcvbuf ) { throw new ConfigurationException ( String . format ( "Max Window length greater than socket SO_RCVBUF: windowMaxLength=%d, SO_RCVBUF=%d" , windowMaxLength , soRcvbuf ) ) ; } } public void validateSenderMtuLength ( final int senderMtuLength ) { final int soRcvbuf = transport . getOption ( StandardSocketOptions . SO_RCVBUF ) ; if ( senderMtuLength > soRcvbuf ) { throw new ConfigurationException ( String . format ( "Sender MTU greater than socket SO_RCVBUF: senderMtuLength=%d, SO_RCVBUF=%d" , senderMtuLength , soRcvbuf ) ) ; } final int capacity = transport . receiveBufferCapacity ( ) ; if ( senderMtuLength > capacity ) { throw new ConfigurationException ( String . format ( "Sender MTU greater than receive buffer capacity: senderMtuLength=%d, capacity=%d" , senderMtuLength , capacity ) ) ; } } public void sendStatusMessage ( final InetSocketAddress controlAddress , final int sessionId , final int streamId , final int termId , final int termOffset , final int window , final short flags ) { if ( ! isClosed ) { smBuffer . clear ( ) ; smHeader . sessionId ( sessionId ) . streamId ( streamId ) . consumptionTermId ( termId ) . consumptionTermOffset ( termOffset ) . receiverWindowLength ( window ) . flags ( flags ) ; final int bytesSent = transport . sendTo ( smBuffer , controlAddress ) ; if ( StatusMessageFlyweight . HEADER_LENGTH != bytesSent ) { systemCounters . statusMessageShortSends ( ) . orderedIncrement ( ) ; } } } public void sendNakMessage ( final InetSocketAddress controlAddress , final int sessionId , final int streamId , final int termId , final int termOffset , final int length ) { if ( ! isClosed ) { nakBuffer . clear ( ) ; nakHeader . streamId ( streamId ) . sessionId ( sessionId ) . termId ( termId ) . termOffset ( termOffset ) . length ( length ) ; final int bytesSent = transport . sendTo ( nakBuffer , controlAddress ) ; if ( NakFlyweight . HEADER_LENGTH != bytesSent ) { systemCounters . nakMessageShortSends ( ) . orderedIncrement ( ) ; } } } }
package uk . co . real_logic . aeron . driver . media ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . aeron . protocol . NakFlyweight ; import uk . co . real_logic . aeron . protocol . StatusMessageFlyweight ; import uk . co . real_logic . aeron . driver . * ; import uk . co . real_logic . aeron . driver . exceptions . ConfigurationException ; import uk . co . real_logic . agrona . collections . BiInt2ObjectMap ; import uk . co . real_logic . agrona . concurrent . AtomicCounter ; import java . net . InetSocketAddress ; import java . net . StandardSocketOptions ; import java . nio . ByteBuffer ; import static uk . co . real_logic . aeron . protocol . StatusMessageFlyweight . SEND_SETUP_FLAG ; public class SendChannelEndpoint implements AutoCloseable { private final BiInt2ObjectMap < NetworkPublication > publicationByStreamAndSessionIdMap = new BiInt2ObjectMap < > ( ) ; private final BiInt2ObjectMap < PublicationAssembly > assemblyByStreamAndSessionIdMap = new BiInt2ObjectMap < > ( ) ; private final UdpChannelTransport transport ; private final AtomicCounter nakMessagesReceived ; private final AtomicCounter statusMessagesReceived ; public SendChannelEndpoint ( final UdpChannel udpChannel , final EventLogger logger , final LossGenerator lossGenerator , final SystemCounters systemCounters ) { this . transport = new SenderUdpChannelTransport ( udpChannel , this : : onStatusMessage , this : : onNakMessage , logger , lossGenerator ) ; this . nakMessagesReceived = systemCounters . nakMessagesReceived ( ) ; this . statusMessagesReceived = systemCounters . statusMessagesReceived ( ) ; } public void openChannel ( ) { transport . openDatagramChannel ( ) ; } public void registerForRead ( final TransportPoller transportPoller ) { transport . registerForRead ( transportPoller ) ; } public int sendTo ( final ByteBuffer buffer , final InetSocketAddress address ) { return transport . sendTo ( buffer , address ) ; } public void close ( ) { transport . close ( ) ; } public UdpChannel udpChannel ( ) { return transport . udpChannel ( ) ; } public String originalUriString ( ) { return transport . udpChannel ( ) . originalUriString ( ) ; } public void validateMtuLength ( final int mtuLength ) { final int soSndbuf = transport . getOption ( StandardSocketOptions . SO_SNDBUF ) ; if ( mtuLength > soSndbuf ) { throw new ConfigurationException ( String . format ( "MTU greater than socket SO_SNDBUF: mtuLength=%d, SO_SNDBUF=%d" , mtuLength , soSndbuf ) ) ; } } public NetworkPublication getPublication ( final int sessionId , final int streamId ) { return publicationByStreamAndSessionIdMap . get ( sessionId , streamId ) ; } public void addPublication ( final NetworkPublication publication ) { publicationByStreamAndSessionIdMap . put ( publication . sessionId ( ) , publication . streamId ( ) , publication ) ; } public NetworkPublication removePublication ( final NetworkPublication publication ) { return publicationByStreamAndSessionIdMap . remove ( publication . sessionId ( ) , publication . streamId ( ) ) ; } public int sessionCount ( ) { return publicationByStreamAndSessionIdMap . size ( ) ; } public void addToDispatcher ( final NetworkPublication publication , final RetransmitHandler retransmitHandler , final FlowControl flowControl ) { assemblyByStreamAndSessionIdMap . put ( publication . sessionId ( ) , publication . streamId ( ) , new PublicationAssembly ( publication , retransmitHandler , flowControl ) ) ; } public void removeFromDispatcher ( final NetworkPublication publication ) { final PublicationAssembly assembly = assemblyByStreamAndSessionIdMap . remove ( publication . sessionId ( ) , publication . streamId ( ) ) ; if ( null != assembly ) { assembly . retransmitHandler . close ( ) ; } } private void onStatusMessage ( final StatusMessageFlyweight statusMsg , final InetSocketAddress srcAddress ) { final PublicationAssembly assembly = assemblyByStreamAndSessionIdMap . get ( statusMsg . sessionId ( ) , statusMsg . streamId ( ) ) ; if ( null != assembly ) { if ( SEND_SETUP_FLAG == ( statusMsg . flags ( ) & SEND_SETUP_FLAG ) ) { assembly . publication . triggerSendSetupFrame ( ) ; } else { final long positionLimit = assembly . flowControl . onStatusMessage ( statusMsg . consumptionTermId ( ) , statusMsg . consumptionTermOffset ( ) , statusMsg . receiverWindowLength ( ) , srcAddress ) ; assembly . publication . senderPositionLimit ( positionLimit ) ; } statusMessagesReceived . orderedIncrement ( ) ; } } private void onNakMessage ( final NakFlyweight nakMessage ) { final PublicationAssembly assembly = assemblyByStreamAndSessionIdMap . get ( nakMessage . sessionId ( ) , nakMessage . streamId ( ) ) ; if ( null != assembly ) { assembly . retransmitHandler . onNak ( nakMessage . termId ( ) , nakMessage . termOffset ( ) , nakMessage . length ( ) ) ; nakMessagesReceived . orderedIncrement ( ) ; } } static final class PublicationAssembly { final NetworkPublication publication ; final RetransmitHandler retransmitHandler ; final FlowControl flowControl ; public PublicationAssembly ( final NetworkPublication publication , final RetransmitHandler retransmitHandler , final FlowControl flowControl ) { this . publication = publication ; this . retransmitHandler = retransmitHandler ; this . flowControl = flowControl ; } } }
package uk . co . real_logic . aeron . driver . uri ; import uk . co . real_logic . aeron . driver . Strings ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . UnknownHostException ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import static uk . co . real_logic . aeron . driver . Strings . parseIntOrDefault ; public class InterfaceSearchAddress { private static final Pattern IPV4_ADDRESS_PATTERN = Pattern . compile ( "([^:/]+)(?::(?<port>[0-9]+))?(?:/(?<subnet>[0-9]+))?" ) ; private static final Pattern IPV6_ADDRESS_PATTERN = Pattern . compile ( "\\[([0-9A-Fa-f:]+)\\](?::(?<port>[0-9]+))?(?:/(?<subnet>[0-9]+))?" ) ; private final InetSocketAddress address ; private final int subnetPrefix ; public InterfaceSearchAddress ( InetSocketAddress address , int subnetPrefix ) { this . address = address ; this . subnetPrefix = subnetPrefix ; } public InetSocketAddress getAddress ( ) { return address ; } public InetAddress getInetAddress ( ) { return address . getAddress ( ) ; } public int getSubnetPrefix ( ) { return subnetPrefix ; } public int getPort ( ) { return address . getPort ( ) ; } public static InterfaceSearchAddress parse ( String s ) throws UnknownHostException { if ( Strings . isEmpty ( s ) ) { throw new IllegalArgumentException ( "Search address string is null or empty" ) ; } final Matcher matcher = getMatcher ( s ) ; final InetAddress hostAddress = InetAddress . getByName ( matcher . group ( 1 ) ) ; final int defaultSubnetPrefix = hostAddress . getAddress ( ) . length * 8 ; final int port = parseIntOrDefault ( matcher . group ( "port" ) , 0 ) ; final int subnetPrefix = parseIntOrDefault ( matcher . group ( "subnet" ) , defaultSubnetPrefix ) ; return new InterfaceSearchAddress ( new InetSocketAddress ( hostAddress , port ) , subnetPrefix ) ; } private static Matcher getMatcher ( CharSequence cs ) { final Matcher ipV4Matcher = IPV4_ADDRESS_PATTERN . matcher ( cs ) ; if ( ipV4Matcher . matches ( ) ) { return ipV4Matcher ; } final Matcher ipV6Matcher = IPV6_ADDRESS_PATTERN . matcher ( cs ) ; if ( ipV6Matcher . matches ( ) ) { return ipV6Matcher ; } throw new IllegalArgumentException ( "Invalid search address: " + cs ) ; } public static InterfaceSearchAddress wildcard ( ) { return new InterfaceSearchAddress ( new InetSocketAddress ( 0 ) , 0 ) ; } }
package uk . co . real_logic . aeron . driver . uri ; import java . net . InetSocketAddress ; import java . util . function . BiFunction ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import static java . lang . Integer . parseInt ; import static uk . co . real_logic . aeron . driver . Strings . parseIntOrDefault ; public class SocketAddressUtil { private static final Pattern IPV4_ADDRESS_PATTERN = Pattern . compile ( "([^:]+)(?::([0-9]+))?" ) ; private static final Pattern IPV6_ADDRESS_PATTERN = Pattern . compile ( "\\[([0-9A-Fa-f:]+)(?:%[a-zA-Z0-9_.~-]+)?\\](?::([0-9]+))?" ) ; private static InetSocketAddress parse ( final CharSequence cs , final BiFunction < String , String , InetSocketAddress > consumer ) { if ( null == cs ) { throw new NullPointerException ( "Input string must not be null" ) ; } final Matcher ipV4Matcher = IPV4_ADDRESS_PATTERN . matcher ( cs ) ; if ( ipV4Matcher . matches ( ) ) { final String host = ipV4Matcher . group ( 1 ) ; final String portString = ipV4Matcher . group ( 2 ) ; return consumer . apply ( host , portString ) ; } final Matcher ipV6Matcher = IPV6_ADDRESS_PATTERN . matcher ( cs ) ; if ( ipV6Matcher . matches ( ) ) { final String host = ipV6Matcher . group ( 1 ) ; final String portString = ipV6Matcher . group ( 2 ) ; return consumer . apply ( host , portString ) ; } throw new IllegalArgumentException ( "Invalid format: " + cs ) ; } public static InetSocketAddress parse ( final CharSequence cs ) { return parse ( cs , ( hostString , portString ) - > { if ( null == portString ) { throw new IllegalArgumentException ( "The 'port' portion of the address is required" ) ; } return new InetSocketAddress ( hostString , parseInt ( portString ) ) ; } ) ; } public static InetSocketAddress parse ( final CharSequence cs , final int defaultPort ) { return parse ( cs , ( hostString , portString ) - > { final int port = parseIntOrDefault ( portString , defaultPort ) ; return new InetSocketAddress ( hostString , port ) ; } ) ; } }
package uk . co . real_logic . aeron . driver . uri ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . UnknownHostException ; import java . util . HashMap ; import java . util . Map ; public class AeronUri { private static final String AERON_PREFIX = "aeron:" ; private final String scheme ; private final String media ; private final Map < String , String > params ; public AeronUri ( String scheme , String media , Map < String , String > params ) { this . scheme = scheme ; this . media = media ; this . params = params ; } public String getMedia ( ) { return media ; } public String getScheme ( ) { return scheme ; } private enum State { MEDIA , PARAMS_KEY , PARAMS_VALUE } public String get ( String key ) { return params . get ( key ) ; } public String get ( String key , String defaultValue ) { final String value = params . get ( key ) ; if ( null != value ) { return value ; } return defaultValue ; } public InetAddress getInetAddress ( String key ) throws UnknownHostException { return InetAddress . getByName ( get ( key ) ) ; } public InetSocketAddress getSocketAddress ( String key ) { return SocketAddressUtil . parse ( get ( key ) ) ; } public InetSocketAddress getSocketAddress ( String key , int defaultPort , InetSocketAddress defaultValue ) { if ( ! containsKey ( key ) ) { return defaultValue ; } return SocketAddressUtil . parse ( get ( key ) , defaultPort ) ; } public InterfaceSearchAddress getInterfaceSearchAddress ( String key , InterfaceSearchAddress defaultValue ) throws UnknownHostException { if ( ! containsKey ( key ) ) { return defaultValue ; } return InterfaceSearchAddress . parse ( get ( key ) ) ; } public boolean containsKey ( String key ) { return params . containsKey ( key ) ; } public boolean containsAnyKey ( String [ ] keys ) { for ( final String key : keys ) { if ( params . containsKey ( key ) ) { return true ; } } return false ; } public static AeronUri parse ( CharSequence cs ) { if ( ! startsWith ( cs , AERON_PREFIX ) ) { throw new IllegalArgumentException ( "AeronUri must start with 'aeron:', found: '" + cs + "'" ) ; } final StringBuilder builder = new StringBuilder ( ) ; final String scheme = "aeron" ; final Map < String , String > params = new HashMap < > ( ) ; String media = null ; String key = null ; State state = State . MEDIA ; for ( int i = AERON_PREFIX . length ( ) ; i < cs . length ( ) ; i ++ ) { final char c = cs . charAt ( i ) ; switch ( state ) { case MEDIA : switch ( c ) { case '?' : media = builder . toString ( ) ; builder . setLength ( 0 ) ; state = State . PARAMS_KEY ; break ; case ':' : throw new IllegalArgumentException ( "Encountered ':' within media definition" ) ; default : builder . append ( c ) ; } break ; case PARAMS_KEY : switch ( c ) { case '=' : key = builder . toString ( ) ; builder . setLength ( 0 ) ; state = State . PARAMS_VALUE ; break ; default : builder . append ( c ) ; } break ; case PARAMS_VALUE : switch ( c ) { case '|' : params . put ( key , builder . toString ( ) ) ; builder . setLength ( 0 ) ; state = State . PARAMS_KEY ; break ; default : builder . append ( c ) ; } break ; default : throw new IllegalStateException ( "Que? State = " + state ) ; } } switch ( state ) { case MEDIA : media = builder . toString ( ) ; break ; case PARAMS_VALUE : params . put ( key , builder . toString ( ) ) ; break ; default : throw new IllegalArgumentException ( "No more input found, but was in state: " + state ) ; } return new AeronUri ( scheme , media , params ) ; } private static boolean startsWith ( CharSequence input , CharSequence prefix ) { if ( input . length ( ) < prefix . length ( ) ) { return false ; } for ( int i = 0 ; i < prefix . length ( ) ; i ++ ) { if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; } public static class Builder { private final Map < String , String > params = new HashMap < > ( ) ; private String media ; public Builder media ( String media ) { this . media = media ; return this ; } public Builder param ( String key , String value ) { if ( null != key && null != value ) { params . put ( key , value ) ; } return this ; } public AeronUri newInstance ( ) { return new AeronUri ( "aeron" , media , params ) ; } } public static Builder builder ( ) { return new Builder ( ) ; } }
package uk . co . real_logic . aeron . driver . exceptions ; import uk . co . real_logic . aeron . ErrorCode ; public class InvalidChannelException extends ControlProtocolException { public InvalidChannelException ( final ErrorCode code , final String msg ) { super ( code , msg ) ; } public InvalidChannelException ( final ErrorCode code , final Exception rootCause ) { super ( code , rootCause ) ; } }
package uk . co . real_logic . aeron . driver . exceptions ; public class UnknownSubscriptionException extends IllegalArgumentException { public UnknownSubscriptionException ( final String message ) { super ( message ) ; } }
package uk . co . real_logic . aeron . driver . exceptions ; public class ConfigurationException extends IllegalArgumentException { public ConfigurationException ( final String message ) { super ( message ) ; } }
package uk . co . real_logic . aeron . driver . exceptions ; import uk . co . real_logic . aeron . ErrorCode ; public class ControlProtocolException extends IllegalArgumentException { private final ErrorCode code ; public ControlProtocolException ( final ErrorCode code , final String msg ) { super ( msg ) ; this . code = code ; } public ControlProtocolException ( final ErrorCode code , final Exception rootCause ) { super ( rootCause ) ; this . code = code ; } public ErrorCode errorCode ( ) { return code ; } }
package uk . co . real_logic . aeron . tools ; import java . util . Random ; import java . util . concurrent . ThreadLocalRandom ; public class SeedableThreadLocalRandom { private static final ThreadLocal < Random > RND = new ThreadLocal < Random > ( ) ; private static SeedCallback seedCallback ; public static void setSeedCallback ( final SeedCallback callback ) { seedCallback = callback ; } public static Random current ( ) { Random rnd = RND . get ( ) ; if ( rnd == null ) { long seed = ThreadLocalRandom . current ( ) . nextLong ( ) ; if ( seedCallback != null ) { seed = seedCallback . setSeed ( seed ) ; } rnd = new Random ( seed ) ; RND . set ( rnd ) ; } return rnd ; } public interface SeedCallback { long setSeed ( long seed ) ; } }
package uk . co . real_logic . aeron . driver . event ; import uk . co . real_logic . aeron . command . * ; import uk . co . real_logic . aeron . protocol . * ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_INT ; public class EventCodec { private static final ThreadLocal < HeaderFlyweight > HEADER_FLYWEIGHT = ThreadLocal . withInitial ( HeaderFlyweight : : new ) ; private static final ThreadLocal < DataHeaderFlyweight > DATA_HEADER = ThreadLocal . withInitial ( DataHeaderFlyweight : : new ) ; private static final ThreadLocal < StatusMessageFlyweight > SM_HEADER = ThreadLocal . withInitial ( StatusMessageFlyweight : : new ) ; private static final ThreadLocal < NakFlyweight > NAK_HEADER = ThreadLocal . withInitial ( NakFlyweight : : new ) ; private static final ThreadLocal < SetupFlyweight > SETUP_HEADER = ThreadLocal . withInitial ( SetupFlyweight : : new ) ; private static final ThreadLocal < PublicationMessageFlyweight > PUB_MESSAGE = ThreadLocal . withInitial ( PublicationMessageFlyweight : : new ) ; private static final ThreadLocal < SubscriptionMessageFlyweight > SUB_MESSAGE = ThreadLocal . withInitial ( SubscriptionMessageFlyweight : : new ) ; private static final ThreadLocal < PublicationBuffersReadyFlyweight > PUBLICATION_READY = ThreadLocal . withInitial ( PublicationBuffersReadyFlyweight : : new ) ; private static final ThreadLocal < ConnectionBuffersReadyFlyweight > CONNECTION_READY = ThreadLocal . withInitial ( ConnectionBuffersReadyFlyweight : : new ) ; private static final ThreadLocal < CorrelatedMessageFlyweight > CORRELATED_MSG = ThreadLocal . withInitial ( CorrelatedMessageFlyweight : : new ) ; private static final ThreadLocal < ConnectionMessageFlyweight > CONNECTION_MSG = ThreadLocal . withInitial ( ConnectionMessageFlyweight : : new ) ; private static final ThreadLocal < RemoveMessageFlyweight > REMOVE_MSG = ThreadLocal . withInitial ( RemoveMessageFlyweight : : new ) ; private static final int LOG_HEADER_LENGTH = 16 ; private static final int SOCKET_ADDRESS_MAX_LENGTH = 24 ; public static final int STACK_DEPTH = 5 ; public static int encode ( final MutableDirectBuffer encodingBuffer , final MutableDirectBuffer buffer , final int offset , final int bufferLength ) { final int captureLength = determineCaptureLength ( bufferLength ) ; int relativeOffset = encodeLogHeader ( encodingBuffer , captureLength , bufferLength ) ; encodingBuffer . putBytes ( relativeOffset , buffer , offset , captureLength ) ; relativeOffset += captureLength ; return relativeOffset ; } public static int encode ( final MutableDirectBuffer encodingBuffer , final ByteBuffer buffer , final int offset , final int bufferLength , final InetSocketAddress dstAddress ) { final int captureLength = determineCaptureLength ( bufferLength ) ; int relativeOffset = encodeLogHeader ( encodingBuffer , captureLength , bufferLength ) ; relativeOffset += encodeSocketAddress ( encodingBuffer , relativeOffset , dstAddress ) ; encodingBuffer . putBytes ( relativeOffset , buffer , offset , captureLength ) ; relativeOffset += captureLength ; return relativeOffset ; } public static int encode ( final MutableDirectBuffer encodingBuffer , final byte [ ] buffer , final int offset , final int bufferLength ) { final int captureLength = determineCaptureLength ( bufferLength ) ; int relativeOffset = encodeLogHeader ( encodingBuffer , captureLength , bufferLength ) ; encodingBuffer . putBytes ( relativeOffset , buffer , offset , captureLength ) ; relativeOffset += captureLength ; return relativeOffset ; } public static int encode ( final MutableDirectBuffer encodingBuffer , final String value ) { final int length = encodingBuffer . putStringUtf8 ( LOG_HEADER_LENGTH , value , LITTLE_ENDIAN ) ; final int recordLength = LOG_HEADER_LENGTH + length ; encodeLogHeader ( encodingBuffer , recordLength , recordLength ) ; return recordLength ; } public static int encode ( final MutableDirectBuffer encodingBuffer , final StackTraceElement stack ) { final int relativeOffset = putStackTraceElement ( encodingBuffer , stack , LOG_HEADER_LENGTH ) ; final int captureLength = relativeOffset ; encodeLogHeader ( encodingBuffer , captureLength , captureLength ) ; return relativeOffset ; } public static int encode ( final MutableDirectBuffer encodingBuffer , final Throwable ex ) { final String msg = null != ex . getMessage ( ) ? ex . getMessage ( ) : "exception message not set" ; int relativeOffset = LOG_HEADER_LENGTH ; relativeOffset += encodingBuffer . putStringUtf8 ( relativeOffset , ex . getClass ( ) . getName ( ) , LITTLE_ENDIAN ) ; relativeOffset += encodingBuffer . putStringUtf8 ( relativeOffset , msg , LITTLE_ENDIAN ) ; final StackTraceElement [ ] stackTrace = ex . getStackTrace ( ) ; for ( int i = 0 ; i < Math . min ( STACK_DEPTH , stackTrace . length ) ; i ++ ) { relativeOffset = putStackTraceElement ( encodingBuffer , stackTrace [ i ] , relativeOffset ) ; } final int recordLength = relativeOffset - LOG_HEADER_LENGTH ; encodeLogHeader ( encodingBuffer , recordLength , recordLength ) ; return relativeOffset ; } private static int putStackTraceElement ( final MutableDirectBuffer encodingBuffer , final StackTraceElement stack , int relativeOffset ) { encodingBuffer . putInt ( relativeOffset , stack . getLineNumber ( ) , LITTLE_ENDIAN ) ; relativeOffset += SIZE_OF_INT ; relativeOffset += encodingBuffer . putStringUtf8 ( relativeOffset , stack . getClassName ( ) , LITTLE_ENDIAN ) ; relativeOffset += encodingBuffer . putStringUtf8 ( relativeOffset , stack . getMethodName ( ) , LITTLE_ENDIAN ) ; relativeOffset += encodingBuffer . putStringUtf8 ( relativeOffset , stack . getFileName ( ) , LITTLE_ENDIAN ) ; return relativeOffset ; } public static String dissectAsFrame ( final EventCode code , final MutableDirectBuffer buffer , final int offset , final int length ) { final StringBuilder builder = new StringBuilder ( ) ; final HeaderFlyweight frame = HEADER_FLYWEIGHT . get ( ) ; int relativeOffset = dissectLogHeader ( code , buffer , offset , builder ) ; builder . append ( ": " ) ; relativeOffset += dissectSocketAddress ( buffer , offset + relativeOffset , builder ) ; builder . append ( " " ) ; frame . wrap ( buffer , offset + relativeOffset ) ; switch ( frame . headerType ( ) ) { case HeaderFlyweight . HDR_TYPE_PAD : case HeaderFlyweight . HDR_TYPE_DATA : final DataHeaderFlyweight dataFrame = DATA_HEADER . get ( ) ; dataFrame . wrap ( buffer , offset + relativeOffset ) ; builder . append ( dissect ( dataFrame ) ) ; break ; case HeaderFlyweight . HDR_TYPE_SM : final StatusMessageFlyweight smFrame = SM_HEADER . get ( ) ; smFrame . wrap ( buffer , offset + relativeOffset ) ; builder . append ( dissect ( smFrame ) ) ; break ; case HeaderFlyweight . HDR_TYPE_NAK : final NakFlyweight nakFrame = NAK_HEADER . get ( ) ; nakFrame . wrap ( buffer , offset + relativeOffset ) ; builder . append ( dissect ( nakFrame ) ) ; break ; case HeaderFlyweight . HDR_TYPE_SETUP : final SetupFlyweight setupFrame = SETUP_HEADER . get ( ) ; setupFrame . wrap ( buffer , offset + relativeOffset ) ; builder . append ( dissect ( setupFrame ) ) ; break ; default : builder . append ( "FRAME_UNKNOWN" ) ; break ; } return builder . toString ( ) ; } public static String dissectAsCommand ( final EventCode code , final MutableDirectBuffer buffer , final int offset , final int length ) { final StringBuilder builder = new StringBuilder ( ) ; final int relativeOffset = dissectLogHeader ( code , buffer , offset , builder ) ; builder . append ( ": " ) ; switch ( code ) { case CMD_IN_ADD_PUBLICATION : final PublicationMessageFlyweight pubCommand = PUB_MESSAGE . get ( ) ; pubCommand . wrap ( buffer , offset + relativeOffset ) ; builder . append ( dissect ( pubCommand ) ) ; break ; case CMD_IN_ADD_SUBSCRIPTION : final SubscriptionMessageFlyweight subCommand = SUB_MESSAGE . get ( ) ; subCommand . wrap ( buffer , offset + relativeOffset ) ; builder . append ( dissect ( subCommand ) ) ; break ; case CMD_IN_REMOVE_PUBLICATION : case CMD_IN_REMOVE_SUBSCRIPTION : final RemoveMessageFlyweight removeCmd = REMOVE_MSG . get ( ) ; removeCmd . wrap ( buffer , offset + relativeOffset ) ; builder . append ( dissect ( removeCmd ) ) ; break ; case CMD_OUT_PUBLICATION_READY : final PublicationBuffersReadyFlyweight newBuffer = PUBLICATION_READY . get ( ) ; newBuffer . wrap ( buffer , offset + relativeOffset ) ; builder . append ( dissect ( newBuffer ) ) ; break ; case CMD_OUT_CONNECTION_READY : final ConnectionBuffersReadyFlyweight connectionReadyCommand = CONNECTION_READY . get ( ) ; connectionReadyCommand . wrap ( buffer , offset + relativeOffset ) ; builder . append ( dissect ( connectionReadyCommand ) ) ; break ; case CMD_OUT_ON_OPERATION_SUCCESS : case CMD_IN_KEEPALIVE_CLIENT : final CorrelatedMessageFlyweight correlatedCmd = CORRELATED_MSG . get ( ) ; correlatedCmd . wrap ( buffer , offset + relativeOffset ) ; builder . append ( dissect ( correlatedCmd ) ) ; break ; case CMD_OUT_ON_INACTIVE_CONNECTION : final ConnectionMessageFlyweight connectionCmd = CONNECTION_MSG . get ( ) ; connectionCmd . wrap ( buffer , offset + relativeOffset ) ; builder . append ( dissect ( connectionCmd ) ) ; break ; default : builder . append ( "COMMAND_UNKNOWN" ) ; break ; } return builder . toString ( ) ; } public static String dissectAsInvocation ( final EventCode code , final MutableDirectBuffer buffer , final int initialOffset , final int length ) { final StringBuilder builder = new StringBuilder ( ) ; final int relativeOffset = dissectLogHeader ( code , buffer , initialOffset , builder ) ; builder . append ( ": " ) ; readStackTraceElement ( buffer , initialOffset + relativeOffset , builder ) ; return builder . toString ( ) ; } public static String dissectAsException ( final EventCode code , final MutableDirectBuffer buffer , final int initialOffset , final int length ) { final StringBuilder builder = new StringBuilder ( ) ; int offset = initialOffset + dissectLogHeader ( code , buffer , initialOffset , builder ) ; builder . append ( ": " ) ; int strLength = buffer . getInt ( offset , LITTLE_ENDIAN ) ; builder . append ( buffer . getStringUtf8 ( offset , strLength ) ) ; offset += strLength + SIZE_OF_INT ; builder . append ( "(" ) ; strLength = buffer . getInt ( offset , LITTLE_ENDIAN ) ; builder . append ( buffer . getStringUtf8 ( offset , strLength ) ) ; offset += strLength + SIZE_OF_INT ; builder . append ( ")" ) ; for ( int i = 0 ; i < STACK_DEPTH ; i ++ ) { builder . append ( '\n' ) ; offset = readStackTraceElement ( buffer , offset , builder ) ; } return builder . toString ( ) ; } public static String dissectAsString ( final EventCode code , final MutableDirectBuffer buffer , final int offset , final int length ) { final StringBuilder builder = new StringBuilder ( ) ; final int relativeOffset = dissectLogHeader ( code , buffer , offset , builder ) ; builder . append ( ": " ) ; builder . append ( buffer . getStringUtf8 ( offset + relativeOffset , LITTLE_ENDIAN ) ) ; return builder . toString ( ) ; } private static int readStackTraceElement ( final MutableDirectBuffer buffer , int offset , final StringBuilder builder ) { final int lineNumber = buffer . getInt ( offset , LITTLE_ENDIAN ) ; offset += SIZE_OF_INT ; int length = buffer . getInt ( offset ) ; final String className = buffer . getStringUtf8 ( offset , length ) ; offset += SIZE_OF_INT + length ; length = buffer . getInt ( offset ) ; final String methodName = buffer . getStringUtf8 ( offset , length ) ; offset += SIZE_OF_INT + length ; length = buffer . getInt ( offset ) ; final String fileName = buffer . getStringUtf8 ( offset , length ) ; offset += SIZE_OF_INT + length ; builder . append ( String . format ( "%s.%s %s:%d" , className , methodName , fileName , lineNumber ) ) ; return offset ; } private static int encodeLogHeader ( final MutableDirectBuffer encodingBuffer , final int captureLength , final int bufferLength ) { int relativeOffset = 0 ; encodingBuffer . putInt ( relativeOffset , captureLength , LITTLE_ENDIAN ) ; relativeOffset += SIZE_OF_INT ; encodingBuffer . putInt ( relativeOffset , bufferLength , LITTLE_ENDIAN ) ; relativeOffset += SIZE_OF_INT ; encodingBuffer . putLong ( relativeOffset , System . nanoTime ( ) , LITTLE_ENDIAN ) ; relativeOffset += BitUtil . SIZE_OF_LONG ; return relativeOffset ; } private static int encodeSocketAddress ( final MutableDirectBuffer encodingBuffer , final int offset , final InetSocketAddress dstAddress ) { int relativeOffset = 0 ; encodingBuffer . putInt ( offset + relativeOffset , dstAddress . getPort ( ) , LITTLE_ENDIAN ) ; relativeOffset += SIZE_OF_INT ; final byte [ ] addrBuffer = dstAddress . getAddress ( ) . getAddress ( ) ; encodingBuffer . putInt ( offset + relativeOffset , addrBuffer . length , LITTLE_ENDIAN ) ; relativeOffset += SIZE_OF_INT ; encodingBuffer . putBytes ( offset + relativeOffset , addrBuffer ) ; relativeOffset += addrBuffer . length ; return relativeOffset ; } private static int determineCaptureLength ( final int bufferLength ) { return Math . min ( bufferLength , EventConfiguration . MAX_EVENT_LENGTH - LOG_HEADER_LENGTH - SOCKET_ADDRESS_MAX_LENGTH ) ; } private static int dissectLogHeader ( final EventCode code , final MutableDirectBuffer buffer , final int offset , final StringBuilder builder ) { int relativeOffset = 0 ; final int captureLength = buffer . getInt ( offset + relativeOffset , LITTLE_ENDIAN ) ; relativeOffset += SIZE_OF_INT ; final int bufferLength = buffer . getInt ( offset + relativeOffset , LITTLE_ENDIAN ) ; relativeOffset += SIZE_OF_INT ; final long timestamp = buffer . getLong ( offset + relativeOffset , LITTLE_ENDIAN ) ; relativeOffset += BitUtil . SIZE_OF_LONG ; builder . append ( String . format ( "[%1$f] %2$s [%3$d/%4$d]" , ( double ) timestamp / 1000000000.0 , code . name ( ) , captureLength , bufferLength ) ) ; return relativeOffset ; } private static int dissectSocketAddress ( final MutableDirectBuffer buffer , final int offset , final StringBuilder builder ) { int relativeOffset = 0 ; final int port = buffer . getInt ( offset + relativeOffset , LITTLE_ENDIAN ) ; relativeOffset += SIZE_OF_INT ; final byte [ ] addressBuffer = new byte [ buffer . getInt ( offset + relativeOffset ) ] ; relativeOffset += SIZE_OF_INT ; buffer . getBytes ( offset + relativeOffset , addressBuffer ) ; relativeOffset += addressBuffer . length ; try { builder . append ( String . format ( "%s.%d" , InetAddress . getByAddress ( addressBuffer ) . getHostAddress ( ) , port ) ) ; } catch ( final Exception ex ) { ex . printStackTrace ( ) ; } return relativeOffset ; } private static String dissect ( final DataHeaderFlyweight header ) { return String . format ( "%s 0x%x len %d %d:%d:%d @%x" , header . headerType ( ) == HeaderFlyweight . HDR_TYPE_PAD ? "PAD" : "DATA" , header . flags ( ) , header . frameLength ( ) , header . sessionId ( ) , header . streamId ( ) , header . termId ( ) , header . termOffset ( ) ) ; } private static String dissect ( final StatusMessageFlyweight header ) { return String . format ( "SM 0x%x len %d %d:%d:%d @%x %d" , header . flags ( ) , header . frameLength ( ) , header . sessionId ( ) , header . streamId ( ) , header . consumptionTermId ( ) , header . consumptionTermOffset ( ) , header . receiverWindowLength ( ) ) ; } private static String dissect ( final NakFlyweight header ) { return String . format ( "NAK 0x%x len %d %d:%d:%d @%x %d" , header . flags ( ) , header . frameLength ( ) , header . sessionId ( ) , header . streamId ( ) , header . termId ( ) , header . termOffset ( ) , header . length ( ) ) ; } private static String dissect ( final SetupFlyweight header ) { return String . format ( "SETUP 0x%x len %d %d:%d:%d %d @%x %d MTU %d" , header . flags ( ) , header . frameLength ( ) , header . sessionId ( ) , header . streamId ( ) , header . activeTermId ( ) , header . initialTermId ( ) , header . termOffset ( ) , header . termLength ( ) , header . mtuLength ( ) ) ; } private static String dissect ( final PublicationMessageFlyweight command ) { return String . format ( "%3$s %1$d:%2$d [%5$d:%4$d]" , command . sessionId ( ) , command . streamId ( ) , command . channel ( ) , command . correlationId ( ) , command . clientId ( ) ) ; } private static String dissect ( final SubscriptionMessageFlyweight command ) { return String . format ( "%s %d [%d][%d:%d]" , command . channel ( ) , command . streamId ( ) , command . registrationCorrelationId ( ) , command . clientId ( ) , command . correlationId ( ) ) ; } private static String dissect ( final PublicationBuffersReadyFlyweight command ) { return String . format ( "%d:%d %d [%d]\n %s" , command . sessionId ( ) , command . streamId ( ) , command . publicationLimitCounterId ( ) , command . correlationId ( ) , command . logFileName ( ) ) ; } private static String dissect ( final ConnectionBuffersReadyFlyweight command ) { final StringBuilder positions = new StringBuilder ( ) ; for ( int i = 0 ; i < command . subscriberPositionCount ( ) ; i ++ ) { positions . append ( String . format ( "[%d:%d:%d]" , i , command . subscriberPositionId ( i ) , command . positionIndicatorRegistrationId ( i ) ) ) ; } return String . format ( "%d:%d %s \"%s\" [%d]\n %s" , command . sessionId ( ) , command . streamId ( ) , positions . toString ( ) , command . sourceIdentity ( ) , command . correlationId ( ) , command . logFileName ( ) ) ; } private static String dissect ( final CorrelatedMessageFlyweight command ) { return String . format ( "[%d:%d]" , command . clientId ( ) , command . correlationId ( ) ) ; } private static String dissect ( final ConnectionMessageFlyweight command ) { return String . format ( "%s %d:%d [%d]" , command . channel ( ) , command . sessionId ( ) , command . streamId ( ) , command . correlationId ( ) ) ; } private static String dissect ( final RemoveMessageFlyweight command ) { return String . format ( "%d [%d:%d]" , command . registrationId ( ) , command . clientId ( ) , command . correlationId ( ) ) ; } }
package uk . co . real_logic . aeron . driver . event ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . ringbuffer . ManyToOneRingBuffer ; import java . io . File ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import static uk . co . real_logic . aeron . driver . event . EventCode . * ; public class EventLogger { private static final ThreadLocal < MutableDirectBuffer > ENCODING_BUFFER = ThreadLocal . withInitial ( ( ) - > new UnsafeBuffer ( ByteBuffer . allocateDirect ( EventConfiguration . MAX_EVENT_LENGTH ) ) ) ; private static final long ENABLED_EVENT_CODES = EventConfiguration . getEnabledEventCodes ( ) ; private static final boolean IS_FRAME_IN_ENABLED = ( ENABLED_EVENT_CODES & FRAME_IN . tagBit ( ) ) == FRAME_IN . tagBit ( ) ; private static final boolean IS_FRAME_IN_DROPPED_ENABLED = ( ENABLED_EVENT_CODES & FRAME_IN_DROPPED . tagBit ( ) ) == FRAME_IN_DROPPED . tagBit ( ) ; private static final boolean IS_FRAME_OUT_ENABLED = ( ENABLED_EVENT_CODES & FRAME_OUT . tagBit ( ) ) == FRAME_OUT . tagBit ( ) ; private static final int INVOKING_METHOD_INDEX = 2 ; private final ManyToOneRingBuffer ringBuffer ; public EventLogger ( final ByteBuffer buffer ) { if ( null != buffer ) { this . ringBuffer = new ManyToOneRingBuffer ( new UnsafeBuffer ( buffer ) ) ; } else { this . ringBuffer = null ; } } public void log ( final EventCode code , final MutableDirectBuffer buffer , final int offset , final int length ) { if ( isEnabled ( code , ENABLED_EVENT_CODES ) ) { final MutableDirectBuffer encodedBuffer = ENCODING_BUFFER . get ( ) ; final int encodedLength = EventCodec . encode ( encodedBuffer , buffer , offset , length ) ; ringBuffer . write ( code . id ( ) , encodedBuffer , 0 , encodedLength ) ; } } public void log ( final EventCode code , final File file ) { if ( isEnabled ( code , ENABLED_EVENT_CODES ) ) { logString ( code , file . toString ( ) ) ; } } public void logFrameIn ( final ByteBuffer buffer , final int offset , final int length , final InetSocketAddress dstAddress ) { if ( IS_FRAME_IN_ENABLED ) { final MutableDirectBuffer encodedBuffer = ENCODING_BUFFER . get ( ) ; final int encodedLength = EventCodec . encode ( encodedBuffer , buffer , offset , length , dstAddress ) ; ringBuffer . write ( FRAME_IN . id ( ) , encodedBuffer , 0 , encodedLength ) ; } } public void logFrameInDropped ( final ByteBuffer buffer , final int offset , final int length , final InetSocketAddress dstAddress ) { if ( IS_FRAME_IN_DROPPED_ENABLED ) { final MutableDirectBuffer encodedBuffer = ENCODING_BUFFER . get ( ) ; final int encodedLength = EventCodec . encode ( encodedBuffer , buffer , offset , length , dstAddress ) ; ringBuffer . write ( FRAME_IN_DROPPED . id ( ) , encodedBuffer , 0 , encodedLength ) ; } } public void logFrameOut ( final ByteBuffer buffer , final InetSocketAddress dstAddress ) { if ( IS_FRAME_OUT_ENABLED ) { final MutableDirectBuffer encodedBuffer = ENCODING_BUFFER . get ( ) ; final int encodedLength = EventCodec . encode ( encodedBuffer , buffer , buffer . position ( ) , buffer . remaining ( ) , dstAddress ) ; ringBuffer . write ( FRAME_OUT . id ( ) , encodedBuffer , 0 , encodedLength ) ; } } public void logPublicationRemoval ( final CharSequence uri , final int sessionId , final int streamId ) { if ( isEnabled ( EventCode . REMOVE_PUBLICATION_CLEANUP , ENABLED_EVENT_CODES ) ) { logString ( EventCode . REMOVE_PUBLICATION_CLEANUP , String . format ( "%s %d:%d" , uri , sessionId , streamId ) ) ; } } public void logSubscriptionRemoval ( final CharSequence uri , final int streamId , final long id ) { if ( isEnabled ( EventCode . REMOVE_SUBSCRIPTION_CLEANUP , ENABLED_EVENT_CODES ) ) { logString ( EventCode . REMOVE_SUBSCRIPTION_CLEANUP , String . format ( "%s %d [%d]" , uri , streamId , id ) ) ; } } public void logConnectionRemoval ( final CharSequence uri , final int sessionId , final int streamId , final long id ) { if ( isEnabled ( EventCode . REMOVE_CONNECTION_CLEANUP , ENABLED_EVENT_CODES ) ) { logString ( EventCode . REMOVE_CONNECTION_CLEANUP , String . format ( "%s %d:%d [%d]" , uri , sessionId , streamId , id ) ) ; } } public void logChannelCreated ( final String description ) { if ( isEnabled ( EventCode . CHANNEL_CREATION , ENABLED_EVENT_CODES ) ) { logString ( EventCode . CHANNEL_CREATION , description ) ; } } public void logInvocation ( ) { if ( isEnabled ( INVOCATION , ENABLED_EVENT_CODES ) ) { final StackTraceElement [ ] stack = Thread . currentThread ( ) . getStackTrace ( ) ; final MutableDirectBuffer encodedBuffer = ENCODING_BUFFER . get ( ) ; final int encodedLength = EventCodec . encode ( encodedBuffer , stack [ INVOKING_METHOD_INDEX ] ) ; ringBuffer . write ( INVOCATION . id ( ) , encodedBuffer , 0 , encodedLength ) ; } } public void logException ( final Throwable ex ) { if ( isEnabled ( EXCEPTION , ENABLED_EVENT_CODES ) ) { final MutableDirectBuffer encodedBuffer = ENCODING_BUFFER . get ( ) ; final int encodedLength = EventCodec . encode ( encodedBuffer , ex ) ; while ( ! ringBuffer . write ( EXCEPTION . id ( ) , encodedBuffer , 0 , encodedLength ) ) { Thread . yield ( ) ; } } else { ex . printStackTrace ( ) ; } } private void logString ( final EventCode code , final String value ) { final MutableDirectBuffer encodedBuffer = ENCODING_BUFFER . get ( ) ; final int encodingLength = EventCodec . encode ( encodedBuffer , value ) ; ringBuffer . write ( code . id ( ) , encodedBuffer , 0 , encodingLength ) ; } private static boolean isEnabled ( final EventCode code , final long enabledEventCodes ) { final long tagBit = code . tagBit ( ) ; return ( enabledEventCodes & tagBit ) == tagBit ; } }
package uk . co . real_logic . aeron . driver . event ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . collections . Int2ObjectHashMap ; public enum EventCode { FRAME_IN ( 1 , EventCodec : : dissectAsFrame ) , FRAME_OUT ( 2 , EventCodec : : dissectAsFrame ) , CMD_IN_ADD_PUBLICATION ( 3 , EventCodec : : dissectAsCommand ) , CMD_IN_REMOVE_PUBLICATION ( 4 , EventCodec : : dissectAsCommand ) , CMD_IN_ADD_SUBSCRIPTION ( 5 , EventCodec : : dissectAsCommand ) , CMD_IN_REMOVE_SUBSCRIPTION ( 6 , EventCodec : : dissectAsCommand ) , CMD_OUT_PUBLICATION_READY ( 7 , EventCodec : : dissectAsCommand ) , CMD_OUT_CONNECTION_READY ( 8 , EventCodec : : dissectAsCommand ) , INVOCATION ( 9 , EventCodec : : dissectAsInvocation ) , EXCEPTION ( 10 , EventCodec : : dissectAsException ) , MALFORMED_FRAME_LENGTH ( 11 , EventCodec : : dissectAsCommand ) , CMD_OUT_ON_OPERATION_SUCCESS ( 12 , EventCodec : : dissectAsCommand ) , CMD_IN_KEEPALIVE_CLIENT ( 13 , EventCodec : : dissectAsCommand ) , REMOVE_PUBLICATION_CLEANUP ( 14 , EventCodec : : dissectAsString ) , REMOVE_SUBSCRIPTION_CLEANUP ( 15 , EventCodec : : dissectAsString ) , REMOVE_CONNECTION_CLEANUP ( 16 , EventCodec : : dissectAsString ) , CMD_OUT_ON_INACTIVE_CONNECTION ( 17 , EventCodec : : dissectAsCommand ) , FRAME_IN_DROPPED ( 18 , EventCodec : : dissectAsFrame ) , ERROR_DELETING_FILE ( 19 , EventCodec : : dissectAsString ) , INVALID_VERSION ( 22 , EventCodec : : dissectAsCommand ) , CHANNEL_CREATION ( 23 , EventCodec : : dissectAsString ) ; private static final Int2ObjectHashMap < EventCode > EVENT_CODE_BY_ID_MAP = new Int2ObjectHashMap < > ( ) ; @ FunctionalInterface private interface DissectFunction { String dissect ( final EventCode code , final MutableDirectBuffer buffer , final int offset , final int length ) ; } private long tagBit ; private final int id ; private final DissectFunction dissector ; static { for ( final EventCode e : EventCode . values ( ) ) { EVENT_CODE_BY_ID_MAP . put ( e . id ( ) , e ) ; } } EventCode ( final int id , final DissectFunction dissector ) { this . id = id ; this . tagBit = 1L < < id ; this . dissector = dissector ; } public int id ( ) { return id ; } public long tagBit ( ) { return tagBit ; } public static EventCode get ( final int id ) { final EventCode code = EVENT_CODE_BY_ID_MAP . get ( id ) ; if ( null == code ) { throw new IllegalArgumentException ( "No EventCode for ID: " + id ) ; } return code ; } public String decode ( final MutableDirectBuffer buffer , final int offset , final int length ) { return dissector . dissect ( this , buffer , offset , length ) ; } }
package uk . co . real_logic . aeron . driver . event ; import uk . co . real_logic . agrona . concurrent . ringbuffer . RingBufferDescriptor ; import java . util . EnumSet ; import java . util . Set ; import java . util . regex . Pattern ; import java . util . stream . Collectors ; public class EventConfiguration { public static final String BUFFER_LENGTH_PROPERTY_NAME = "aeron.event.buffer.length" ; public static final String ENABLED_LOGGER_EVENT_CODES_PROPERTY_NAME = "aeron.event.log" ; public static final Set < EventCode > PRODUCTION_LOGGER_EVENT_CODES = EnumSet . of ( EventCode . EXCEPTION , EventCode . MALFORMED_FRAME_LENGTH , EventCode . ERROR_DELETING_FILE ) ; public static final Set < EventCode > ADMIN_ONLY_EVENT_CODES = EnumSet . of ( EventCode . EXCEPTION , EventCode . MALFORMED_FRAME_LENGTH , EventCode . CMD_IN_ADD_PUBLICATION , EventCode . CMD_IN_ADD_SUBSCRIPTION , EventCode . CMD_IN_KEEPALIVE_CLIENT , EventCode . CMD_IN_REMOVE_PUBLICATION , EventCode . CMD_IN_REMOVE_SUBSCRIPTION , EventCode . REMOVE_CONNECTION_CLEANUP , EventCode . REMOVE_PUBLICATION_CLEANUP , EventCode . REMOVE_SUBSCRIPTION_CLEANUP , EventCode . CMD_OUT_PUBLICATION_READY , EventCode . CMD_OUT_CONNECTION_READY , EventCode . CMD_OUT_ON_INACTIVE_CONNECTION , EventCode . CMD_OUT_ON_OPERATION_SUCCESS , EventCode . ERROR_DELETING_FILE , EventCode . CHANNEL_CREATION ) ; public static final Set < EventCode > ALL_LOGGER_EVENT_CODES = EnumSet . allOf ( EventCode . class ) ; public static final int BUFFER_LENGTH_DEFAULT = 65536 ; public static final int MAX_EVENT_LENGTH = 2048 ; public static final int EVENT_READER_FRAME_LIMIT = 10 ; private static final Pattern COMMA = Pattern . compile ( "," ) ; public static long getEnabledEventCodes ( ) { return makeTagBitSet ( getEnabledEventCodes ( System . getProperty ( ENABLED_LOGGER_EVENT_CODES_PROPERTY_NAME ) ) ) ; } public static int bufferLength ( ) { return Integer . getInteger ( EventConfiguration . BUFFER_LENGTH_PROPERTY_NAME , EventConfiguration . BUFFER_LENGTH_DEFAULT ) + RingBufferDescriptor . TRAILER_LENGTH ; } static long makeTagBitSet ( final Set < EventCode > eventCodes ) { return eventCodes . stream ( ) . mapToLong ( EventCode : : tagBit ) . reduce ( 0L , ( acc , x ) - > acc | x ) ; } static Set < EventCode > getEnabledEventCodes ( final String enabledLoggerEventCodes ) { if ( enabledLoggerEventCodes == null ) { return PRODUCTION_LOGGER_EVENT_CODES ; } switch ( enabledLoggerEventCodes ) { case "all" : return ALL_LOGGER_EVENT_CODES ; case "prod" : return PRODUCTION_LOGGER_EVENT_CODES ; case "admin" : return ADMIN_ONLY_EVENT_CODES ; default : return COMMA . splitAsStream ( enabledLoggerEventCodes ) . map ( EventCode : : valueOf ) . collect ( Collectors . toSet ( ) ) ; } } }
package uk . co . real_logic . aeron . driver . buffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; import java . util . stream . Stream ; public interface RawLog extends AutoCloseable { Stream < ? extends RawLogPartition > stream ( ) ; RawLogPartition [ ] partitions ( ) ; UnsafeBuffer logMetaData ( ) ; ByteBuffer [ ] sliceTerms ( ) ; String logFileName ( ) ; void close ( ) ; }
package uk . co . real_logic . aeron . driver . buffer ; import uk . co . real_logic . agrona . IoUtil ; import java . io . File ; class FileMappingConvention { public static final String PUBLICATIONS = "publications" ; public static final String CONNECTIONS = "connections" ; private final File connectionsDir ; private final File publicationsDir ; public FileMappingConvention ( final String dataDirName ) { final File dataDir = new File ( dataDirName ) ; IoUtil . ensureDirectoryExists ( dataDir , "data directory" ) ; publicationsDir = new File ( dataDir , PUBLICATIONS ) ; connectionsDir = new File ( dataDir , CONNECTIONS ) ; } public File publicationsDir ( ) { return publicationsDir ; } public File connectionsDir ( ) { return connectionsDir ; } public static File streamLocation ( final File rootDir , final String channel , final int sessionId , final int streamId , final long correlationId ) { final String filename = String . format ( "%s-%s-%s-%s.logbuffer" , channel , toHexString ( sessionId ) , toHexString ( streamId ) , toHexString ( correlationId ) ) ; return new File ( rootDir , filename ) ; } private static String toHexString ( final int value ) { return String . format ( "%X" , value ) ; } private static String toHexString ( final long value ) { return String . format ( "%X" , value ) ; } }
package uk . co . real_logic . aeron . driver . buffer ; import uk . co . real_logic . aeron . driver . event . EventCode ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . agrona . IoUtil ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . MappedByteBuffer ; import java . nio . channels . FileChannel ; import java . util . stream . Stream ; import static java . nio . channels . FileChannel . MapMode . READ_WRITE ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . * ; class MappedRawLog implements RawLog { private static final int ONE_GIG = 1 < < 30 ; private final RawLogPartition [ ] partitions ; private final EventLogger logger ; private final File logFile ; private final MappedByteBuffer [ ] mappedBuffers ; private final UnsafeBuffer logMetaDataBuffer ; MappedRawLog ( final File location , final FileChannel blankTemplate , final int termLength , final EventLogger logger ) { this . logger = logger ; this . logFile = location ; partitions = new RawLogPartition [ PARTITION_COUNT ] ; try ( final FileChannel logChannel = new RandomAccessFile ( logFile , "rw" ) . getChannel ( ) ) { final long logLength = computeLogLength ( termLength ) ; blankTemplate . transferTo ( 0 , logLength , logChannel ) ; if ( logLength <= Integer . MAX_VALUE ) { final MappedByteBuffer mappedBuffer = logChannel . map ( READ_WRITE , 0 , logLength ) ; mappedBuffers = new MappedByteBuffer [ ] { mappedBuffer } ; final int metaDataSectionOffset = termLength * PARTITION_COUNT ; for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { final int metaDataOffset = metaDataSectionOffset + ( i * TERM_META_DATA_LENGTH ) ; partitions [ i ] = new RawLogPartition ( new UnsafeBuffer ( mappedBuffer , i * termLength , termLength ) , new UnsafeBuffer ( mappedBuffer , metaDataOffset , TERM_META_DATA_LENGTH ) ) ; } logMetaDataBuffer = new UnsafeBuffer ( mappedBuffer , ( int ) ( logLength - LOG_META_DATA_LENGTH ) , LOG_META_DATA_LENGTH ) ; } else { mappedBuffers = new MappedByteBuffer [ PARTITION_COUNT + 1 ] ; final long metaDataSectionOffset = termLength * ( long ) PARTITION_COUNT ; final int metaDataSectionLength = ( int ) ( logLength - metaDataSectionOffset ) ; final MappedByteBuffer metaDataMappedBuffer = logChannel . map ( READ_WRITE , metaDataSectionOffset , metaDataSectionLength ) ; mappedBuffers [ mappedBuffers . length - 1 ] = metaDataMappedBuffer ; for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { mappedBuffers [ i ] = logChannel . map ( READ_WRITE , termLength * ( long ) i , termLength ) ; partitions [ i ] = new RawLogPartition ( new UnsafeBuffer ( mappedBuffers [ i ] ) , new UnsafeBuffer ( metaDataMappedBuffer , i * TERM_META_DATA_LENGTH , TERM_META_DATA_LENGTH ) ) ; } logMetaDataBuffer = new UnsafeBuffer ( metaDataMappedBuffer , metaDataSectionLength - LOG_META_DATA_LENGTH , LOG_META_DATA_LENGTH ) ; } } catch ( final IOException ex ) { throw new IllegalStateException ( ex ) ; } } public void close ( ) { for ( final MappedByteBuffer buffer : mappedBuffers ) { IoUtil . unmap ( buffer ) ; } if ( ! logFile . delete ( ) ) { logger . log ( EventCode . ERROR_DELETING_FILE , logFile ) ; } } public Stream < RawLogPartition > stream ( ) { return Stream . of ( partitions ) ; } public RawLogPartition [ ] partitions ( ) { return partitions ; } public UnsafeBuffer logMetaData ( ) { return logMetaDataBuffer ; } public ByteBuffer [ ] sliceTerms ( ) { final ByteBuffer [ ] terms = new ByteBuffer [ PARTITION_COUNT ] ; final int termLength = partitions [ 0 ] . termBuffer ( ) . capacity ( ) ; if ( termLength < ONE_GIG ) { final MappedByteBuffer buffer = mappedBuffers [ 0 ] ; for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { buffer . limit ( ( termLength * i ) + termLength ) . position ( termLength * i ) ; terms [ i ] = buffer . slice ( ) ; } } else { for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { terms [ i ] = mappedBuffers [ i ] . duplicate ( ) ; } } return terms ; } public String logFileName ( ) { return logFile . getAbsolutePath ( ) ; } }
package uk . co . real_logic . aeron . driver . buffer ; import uk . co . real_logic . aeron . driver . event . EventLogger ; import uk . co . real_logic . agrona . IoUtil ; import uk . co . real_logic . agrona . LangUtil ; import java . io . File ; import java . nio . channels . FileChannel ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . computeLogLength ; import static uk . co . real_logic . aeron . driver . buffer . FileMappingConvention . streamLocation ; public class RawLogFactory implements AutoCloseable { private final int publicationTermBufferLength ; private final int connectionTermBufferMaxLength ; private final FileChannel blankTemplate ; private final File publicationsDir ; private final File connectionsDir ; private final EventLogger logger ; public RawLogFactory ( final String dataDirectoryName , final int publicationTermBufferLength , final int connectionTermBufferMaxLength , final EventLogger logger ) { this . logger = logger ; final FileMappingConvention fileMappingConvention = new FileMappingConvention ( dataDirectoryName ) ; publicationsDir = fileMappingConvention . publicationsDir ( ) ; connectionsDir = fileMappingConvention . connectionsDir ( ) ; IoUtil . ensureDirectoryExists ( publicationsDir , FileMappingConvention . PUBLICATIONS ) ; IoUtil . ensureDirectoryExists ( connectionsDir , FileMappingConvention . CONNECTIONS ) ; this . publicationTermBufferLength = publicationTermBufferLength ; this . connectionTermBufferMaxLength = connectionTermBufferMaxLength ; final int maxTermLength = Math . max ( publicationTermBufferLength , connectionTermBufferMaxLength ) ; final long blankTemplateLength = computeLogLength ( maxTermLength ) ; blankTemplate = createTemplateFile ( dataDirectoryName , "blankTemplate" , blankTemplateLength ) ; } public void close ( ) { try { blankTemplate . close ( ) ; } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } } public RawLog newPublication ( final String channel , final int sessionId , final int streamId , final long correlationId ) { return newInstance ( publicationsDir , channel , sessionId , streamId , correlationId , publicationTermBufferLength ) ; } public RawLog newConnection ( final String channel , final int sessionId , final int streamId , final long correlationId , final int termBufferLength ) { if ( termBufferLength > connectionTermBufferMaxLength ) { throw new IllegalArgumentException ( "connection term buffer larger than max length: " + termBufferLength + " > " + connectionTermBufferMaxLength ) ; } return newInstance ( connectionsDir , channel , sessionId , streamId , correlationId , termBufferLength ) ; } private static FileChannel createTemplateFile ( final String dataDir , final String name , final long length ) { final File file = new File ( dataDir , name ) ; file . deleteOnExit ( ) ; return IoUtil . createEmptyFile ( file , length ) ; } private RawLog newInstance ( final File rootDir , final String channel , final int sessionId , final int streamId , final long correlationId , final int termBufferLength ) { final File location = streamLocation ( rootDir , channel , sessionId , streamId , correlationId ) ; return new MappedRawLog ( location , blankTemplate , termBufferLength , logger ) ; } }
package uk . co . real_logic . aeron . driver . buffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; public class RawLogPartition { private final UnsafeBuffer termBuffer ; private final UnsafeBuffer metaDataBuffer ; public RawLogPartition ( final UnsafeBuffer termBuffer , final UnsafeBuffer metaDataBuffer ) { this . termBuffer = termBuffer ; this . metaDataBuffer = metaDataBuffer ; } public UnsafeBuffer termBuffer ( ) { return termBuffer ; } public UnsafeBuffer metaDataBuffer ( ) { return metaDataBuffer ; } }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . NetworkPublication ; import uk . co . real_logic . aeron . driver . Sender ; public class RemovePublicationCmd implements SenderCmd { private final NetworkPublication publication ; public RemovePublicationCmd ( final NetworkPublication publication ) { this . publication = publication ; } public void execute ( final Sender sender ) { sender . onRemovePublication ( publication ) ; } }
package uk . co . real_logic . aeron . tools ; import org . apache . commons . cli . ParseException ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . agrona . concurrent . SigIntBarrier ; import java . util . logging . Logger ; public class MediaDriverTool { private static final Logger LOG = Logger . getLogger ( MediaDriverTool . class . getName ( ) ) ; public static void main ( final String [ ] args ) { final MediaDriverOptions opts = new MediaDriverOptions ( ) ; int printHelp = 1 ; int exitValue = 0 ; try { printHelp = opts . parseArgs ( args ) ; } catch ( final ParseException ex ) { ex . printStackTrace ( ) ; exitValue = - 1 ; } if ( printHelp != 0 ) { opts . printHelp ( "MediaDriverTool" ) ; System . out . println ( USAGE_GUIDE ) ; System . exit ( exitValue ) ; } final MediaDriverTool driver = new MediaDriverTool ( ) ; driver . run ( opts ) ; } public void run ( final MediaDriverOptions opts ) { if ( opts . properties ( ) != null ) { System . getProperties ( ) . putAll ( opts . properties ( ) ) ; } final MediaDriver . Context context = new MediaDriver . Context ( ) . conductorIdleStrategy ( opts . conductorIdleStrategy ( ) ) . senderIdleStrategy ( opts . senderIdleStrategy ( ) ) . receiverIdleStrategy ( opts . receiverIdleStrategy ( ) ) . sharedNetworkIdleStrategy ( opts . sharedNetworkIdleStrategy ( ) ) . sharedIdleStrategy ( opts . sharedIdleStrategy ( ) ) . dataLossGenerator ( opts . dataLossGenerator ( ) ) . controlLossGenerator ( opts . controlLossGenerator ( ) ) ; try ( final MediaDriver driver = MediaDriver . launch ( context ) ) { LOG . info ( "Media Driver Started." ) ; new SigIntBarrier ( ) . await ( ) ; LOG . info ( "Media Driver Stopped." ) ; } } private static final String NL = System . lineSeparator ( ) ; private static final String USAGE_GUIDE = "" + NL + "Use this tool to run an Aeron Media driver with configuration in a properties" + NL + "file. Additionally, the idle strategies for all possible threads can be set" + NL + "independently via the command line or properties." + NL + NL + "The Agrona project provides 3 implementations of IdleStrategy:" + NL + uk . co . real_logic . agrona . concurrent . BackoffIdleStrategy . class . getName ( ) + NL + uk . co . real_logic . agrona . concurrent . NoOpIdleStrategy . class . getName ( ) + NL + uk . co . real_logic . agrona . concurrent . BusySpinIdleStrategy . class . getName ( ) + NL + "You may also implement your own IdleStrategy and pass its class name." + NL + NL + "It is possible to provide input parameters to the BackoffIdleStrategy" + NL + "through the command line. After specifying the BackoffIdleStrategy class," + NL + "add (<long>,<long>,<long>,<long>). For Example:" + NL + uk . co . real_logic . agrona . concurrent . BackoffIdleStrategy . class . getName ( ) + "(1,1,1,1)" + NL + NL + "Set the default idle strategies for each thread using these properties:" + NL + "aeron.tools.mediadriver.sender" + NL + "aeron.tools.mediadriver.receiver" + NL + "aeron.tools.mediadriver.conductor" + NL + "aeron.tools.mediadriver.network" + NL + "areon.tools.mediadriver.shared" + NL + NL + "Set the loss generator classes for data and control using these properties:" + NL + "aeron.tools.mediadriver.data.loss" + NL + "aeron.tools.mediadriver.control.loss" + NL ; }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . Sender ; public interface SenderCmd { void execute ( Sender sender ) ; }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . NetworkConnection ; import uk . co . real_logic . aeron . driver . Receiver ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; public class NewConnectionCmd implements ReceiverCmd { private final ReceiveChannelEndpoint channelEndpoint ; private final NetworkConnection connection ; public NewConnectionCmd ( final ReceiveChannelEndpoint channelEndpoint , final NetworkConnection connection ) { this . channelEndpoint = channelEndpoint ; this . connection = connection ; } public void execute ( final Receiver receiver ) { receiver . onNewConnection ( channelEndpoint , connection ) ; } }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . Sender ; import uk . co . real_logic . aeron . driver . media . SendChannelEndpoint ; public class RegisterSendChannelEndpointCmd implements SenderCmd { private final SendChannelEndpoint channelEndpoint ; public RegisterSendChannelEndpointCmd ( final SendChannelEndpoint channelEndpoint ) { this . channelEndpoint = channelEndpoint ; } public void execute ( final Sender sender ) { sender . onRegisterSendChannelEndpoint ( channelEndpoint ) ; } }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . DriverConductor ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; import java . net . InetSocketAddress ; public class CreateConnectionCmd implements DriverConductorCmd { private final int sessionId ; private final int streamId ; private final int initialTermId ; private final int activeTermId ; private final int termOffset ; private final int termLength ; private final int senderMtuLength ; private final InetSocketAddress controlAddress ; private final InetSocketAddress srcAddress ; private final ReceiveChannelEndpoint channelEndpoint ; public CreateConnectionCmd ( final int sessionId , final int streamId , final int initialTermId , final int activeTermId , final int termOffet , final int termLength , final int senderMtuLength , final InetSocketAddress controlAddress , final InetSocketAddress srcAddress , final ReceiveChannelEndpoint channelEndpoint ) { this . sessionId = sessionId ; this . streamId = streamId ; this . initialTermId = initialTermId ; this . activeTermId = activeTermId ; this . termOffset = termOffet ; this . termLength = termLength ; this . senderMtuLength = senderMtuLength ; this . controlAddress = controlAddress ; this . srcAddress = srcAddress ; this . channelEndpoint = channelEndpoint ; } public void execute ( final DriverConductor conductor ) { conductor . onCreateConnection ( sessionId , streamId , initialTermId , activeTermId , termOffset , termLength , senderMtuLength , controlAddress , srcAddress , channelEndpoint ) ; } public ReceiveChannelEndpoint channelEndpoint ( ) { return channelEndpoint ; } public int streamId ( ) { return streamId ; } public int sessionId ( ) { return sessionId ; } public int termId ( ) { return activeTermId ; } }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . DriverConductor ; public interface DriverConductorCmd { void execute ( DriverConductor conductor ) ; }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . Receiver ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; public class CloseReceiveChannelEndpointCmd implements ReceiverCmd { private final ReceiveChannelEndpoint channelEndpoint ; public CloseReceiveChannelEndpointCmd ( final ReceiveChannelEndpoint channelEndpoint ) { this . channelEndpoint = channelEndpoint ; } public void execute ( final Receiver receiver ) { receiver . onCloseReceiveChannelEndpoint ( channelEndpoint ) ; } }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . DriverConductor ; public class CloseResourceCmd implements DriverConductorCmd { private final AutoCloseable resource ; public CloseResourceCmd ( final AutoCloseable resource ) { this . resource = resource ; } public void execute ( DriverConductor conductor ) { conductor . onCloseResource ( resource ) ; } }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . Sender ; import uk . co . real_logic . aeron . driver . media . SendChannelEndpoint ; public class CloseSendChannelEndpointCmd implements SenderCmd { private final SendChannelEndpoint channelEndpoint ; public CloseSendChannelEndpointCmd ( final SendChannelEndpoint channelEndpoint ) { this . channelEndpoint = channelEndpoint ; } public void execute ( final Sender sender ) { sender . onCloseSendChannelEndpoint ( channelEndpoint ) ; } }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . Receiver ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; public class RegisterReceiveChannelEndpointCmd implements ReceiverCmd { private final ReceiveChannelEndpoint channelEndpoint ; public RegisterReceiveChannelEndpointCmd ( final ReceiveChannelEndpoint channelEndpoint ) { this . channelEndpoint = channelEndpoint ; } public void execute ( final Receiver receiver ) { receiver . onRegisterReceiveChannelEndpoint ( channelEndpoint ) ; } }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . Receiver ; public interface ReceiverCmd { void execute ( Receiver receiver ) ; }
package uk . co . real_logic . aeron . tools ; public class TransportStats { protected String proto ; protected String host ; protected int port ; protected long pos ; protected String sessionId ; protected boolean active ; public TransportStats ( ) { } public void setPos ( final long pos ) { if ( pos != this . pos ) { this . pos = pos ; active = true ; } } protected void parseChannel ( final String channel ) { String input = channel ; proto = input . substring ( 0 , input . indexOf ( ':' ) ) ; input = input . substring ( input . indexOf ( ':' ) + 3 ) ; host = input . substring ( 0 , input . indexOf ( ':' ) ) ; input = input . substring ( input . indexOf ( ':' ) + 1 ) ; try { port = Integer . parseInt ( input . substring ( 0 , input . indexOf ( ' ' ) ) ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; } input = input . substring ( input . indexOf ( ' ' ) + 1 ) ; sessionId = input . substring ( 0 , input . indexOf ( ' ' ) ) ; input = input . substring ( input . indexOf ( ' ' ) + 1 ) ; } }
package uk . co . real_logic . aeron . tools ; import org . junit . Before ; import org . junit . Test ; import static org . hamcrest . CoreMatchers . both ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; public class RandomInputStreamTest { private RandomInputStream stream ; @ Before public void setUp ( ) { stream = new RandomInputStream ( ) ; } @ Test public void readByte ( ) throws Exception { final int value = stream . read ( ) ; assertThat ( value , both ( greaterThanOrEqualTo ( 0 ) ) . and ( lessThanOrEqualTo ( 255 ) ) ) ; } @ Test public void readByteArraySmall ( ) throws Exception { final byte [ ] array = new byte [ 1 ] ; final int read = stream . read ( array ) ; assertThat ( read , both ( greaterThanOrEqualTo ( 0 ) ) . and ( lessThanOrEqualTo ( 1 ) ) ) ; } @ Test public void readByteArrayLarge ( ) throws Exception { final byte [ ] array = new byte [ 8192 ] ; final int read = stream . read ( array ) ; assertThat ( read , both ( greaterThanOrEqualTo ( 0 ) ) . and ( lessThanOrEqualTo ( 400 ) ) ) ; } @ Test public void readByteArrayOffset ( ) throws Exception { final byte [ ] array = new byte [ 8192 ] ; final int read = stream . read ( array , 100 , 900 ) ; assertThat ( "FAIL: Expected read to return given length" , read , is ( 900 ) ) ; assertThat ( "FAIL: Expected byte before read location to be 0" , array [ 99 ] , is ( ( byte ) 0 ) ) ; assertThat ( "FAIL: Expected byte after read location to be 0" , array [ 1001 ] , is ( ( byte ) 0 ) ) ; } }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . Receiver ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; public class AddSubscriptionCmd implements ReceiverCmd { private final ReceiveChannelEndpoint channelEndpoint ; private final int streamId ; public AddSubscriptionCmd ( final ReceiveChannelEndpoint channelEndpoint , final int streamId ) { this . channelEndpoint = channelEndpoint ; this . streamId = streamId ; } public void execute ( final Receiver receiver ) { receiver . onAddSubscription ( channelEndpoint , streamId ) ; } }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . Receiver ; import uk . co . real_logic . aeron . driver . media . ReceiveChannelEndpoint ; public class RemoveSubscriptionCmd implements ReceiverCmd { private final ReceiveChannelEndpoint channelEndpoint ; private final int streamId ; public RemoveSubscriptionCmd ( final ReceiveChannelEndpoint channelEndpoint , final int streamId ) { this . channelEndpoint = channelEndpoint ; this . streamId = streamId ; } public void execute ( final Receiver receiver ) { receiver . onRemoveSubscription ( channelEndpoint , streamId ) ; } }
package uk . co . real_logic . aeron . driver . cmd ; import uk . co . real_logic . aeron . driver . FlowControl ; import uk . co . real_logic . aeron . driver . NetworkPublication ; import uk . co . real_logic . aeron . driver . RetransmitHandler ; import uk . co . real_logic . aeron . driver . Sender ; public class NewPublicationCmd implements SenderCmd { private final NetworkPublication publication ; private final RetransmitHandler retransmitHandler ; private final FlowControl flowControl ; public NewPublicationCmd ( final NetworkPublication publication , final RetransmitHandler retransmitHandler , final FlowControl flowControl ) { this . publication = publication ; this . retransmitHandler = retransmitHandler ; this . flowControl = flowControl ; } public void execute ( final Sender sender ) { sender . onNewPublication ( publication , retransmitHandler , flowControl ) ; } }
package uk . co . real_logic . aeron ; import org . junit . After ; import org . junit . Test ; import org . junit . experimental . theories . DataPoint ; import org . junit . experimental . theories . Theories ; import org . junit . experimental . theories . Theory ; import org . junit . runner . RunWith ; import org . mockito . InOrder ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . aeron . driver . ThreadingMode ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . * ; @ RunWith ( Theories . class ) public class PubAndSubTest { @ DataPoint public static final String UNICAST_URI = "udp://localhost:54325" ; @ DataPoint public static final String MULTICAST_URI = "udp://localhost@224.20.30.39:54326" ; private static final int STREAM_ID = 1 ; private static final int SESSION_ID = 2 ; private static final ThreadingMode THREADING_MODE = ThreadingMode . SHARED ; private final MediaDriver . Context context = new MediaDriver . Context ( ) ; private final Aeron . Context publishingAeronContext = new Aeron . Context ( ) ; private final Aeron . Context subscribingAeronContext = new Aeron . Context ( ) ; private Aeron publishingClient ; private Aeron subscribingClient ; private MediaDriver driver ; private Subscription subscription ; private Publication publication ; private UnsafeBuffer buffer = new UnsafeBuffer ( new byte [ 8192 ] ) ; private FragmentHandler fragmentHandler = mock ( FragmentHandler . class ) ; private void launch ( final String channel ) throws Exception { context . dirsDeleteOnExit ( true ) ; context . threadingMode ( THREADING_MODE ) ; driver = MediaDriver . launch ( context ) ; publishingClient = Aeron . connect ( publishingAeronContext ) ; subscribingClient = Aeron . connect ( subscribingAeronContext ) ; publication = publishingClient . addPublication ( channel , STREAM_ID , SESSION_ID ) ; subscription = subscribingClient . addSubscription ( channel , STREAM_ID ) ; } @ After public void closeEverything ( ) throws Exception { if ( null != publication ) { publication . close ( ) ; } if ( null != subscription ) { subscription . close ( ) ; } subscribingClient . close ( ) ; publishingClient . close ( ) ; driver . close ( ) ; } @ Theory @ Test ( timeout = 10000 ) public void shouldSpinUpAndShutdown ( final String channel ) throws Exception { launch ( channel ) ; } @ Theory @ Test ( timeout = 10000 ) public void shouldReceivePublishedMessage ( final String channel ) throws Exception { launch ( channel ) ; buffer . putInt ( 0 , 1 ) ; while ( publication . offer ( buffer , 0 , BitUtil . SIZE_OF_INT ) < 0L ) { Thread . yield ( ) ; } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > 0 , ( i ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 9900 ) ) ; verify ( fragmentHandler ) . onFragment ( any ( UnsafeBuffer . class ) , eq ( DataHeaderFlyweight . HEADER_LENGTH ) , eq ( BitUtil . SIZE_OF_INT ) , any ( Header . class ) ) ; } @ Theory @ Test ( timeout = 10000 ) public void shouldContinueAfterBufferRollover ( final String channel ) throws Exception { final int termBufferLength = 64 * 1024 ; final int numMessagesInTermBuffer = 64 ; final int messageLength = ( termBufferLength / numMessagesInTermBuffer ) - DataHeaderFlyweight . HEADER_LENGTH ; final int numMessagesToSend = numMessagesInTermBuffer + 1 ; context . termBufferLength ( termBufferLength ) ; launch ( channel ) ; for ( int i = 0 ; i < numMessagesToSend ; i ++ ) { while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { Thread . yield ( ) ; } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > 0 , ( j ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 500 ) ) ; } verify ( fragmentHandler , times ( numMessagesToSend ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( messageLength ) , any ( Header . class ) ) ; } @ Theory @ Test ( timeout = 10000 ) public void shouldContinueAfterRolloverWithMinimalPaddingHeader ( final String channel ) throws Exception { final int termBufferLength = 64 * 1024 ; final int termBufferLengthMinusPaddingHeader = termBufferLength - DataHeaderFlyweight . HEADER_LENGTH ; final int num1kMessagesInTermBuffer = 63 ; final int lastMessageLength = termBufferLengthMinusPaddingHeader - ( num1kMessagesInTermBuffer * 1024 ) - DataHeaderFlyweight . HEADER_LENGTH ; final int messageLength = 1024 - DataHeaderFlyweight . HEADER_LENGTH ; context . termBufferLength ( termBufferLength ) ; launch ( channel ) ; for ( int i = 0 ; i < num1kMessagesInTermBuffer - 7 ; i ++ ) { while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { Thread . yield ( ) ; } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > 0 , ( j ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 500 ) ) ; } for ( int i = 7 ; i > 0 ; i -- ) { while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { Thread . yield ( ) ; } } while ( publication . offer ( buffer , 0 , lastMessageLength ) < 0L ) { Thread . yield ( ) ; } while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { Thread . yield ( ) ; } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] == 9 , ( j ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 500 ) ) ; final InOrder inOrder = inOrder ( fragmentHandler ) ; inOrder . verify ( fragmentHandler , times ( num1kMessagesInTermBuffer ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( messageLength ) , any ( Header . class ) ) ; inOrder . verify ( fragmentHandler , times ( 1 ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( lastMessageLength ) , any ( Header . class ) ) ; inOrder . verify ( fragmentHandler , times ( 1 ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( messageLength ) , any ( Header . class ) ) ; } @ Theory @ Test ( timeout = 10000 ) public void shouldReceivePublishedMessageOneForOneWithDataLoss ( final String channel ) throws Exception { final int termBufferLength = 64 * 1024 ; final int numMessagesInTermBuffer = 64 ; final int messageLength = ( termBufferLength / numMessagesInTermBuffer ) - DataHeaderFlyweight . HEADER_LENGTH ; final int numMessagesToSend = 2 * numMessagesInTermBuffer ; context . termBufferLength ( termBufferLength ) ; context . dataLossRate ( 0.10 ) ; context . dataLossSeed ( 0xdeadbeefL ) ; launch ( channel ) ; for ( int i = 0 ; i < numMessagesToSend ; i ++ ) { while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { Thread . yield ( ) ; } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > 0 , ( j ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 900 ) ) ; } verify ( fragmentHandler , times ( numMessagesToSend ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( messageLength ) , any ( Header . class ) ) ; } @ Theory @ Test ( timeout = 10000 ) public void shouldReceivePublishedMessageBatchedWithDataLoss ( final String channel ) throws Exception { final int termBufferLength = 64 * 1024 ; final int numMessagesInTermBuffer = 64 ; final int messageLength = ( termBufferLength / numMessagesInTermBuffer ) - DataHeaderFlyweight . HEADER_LENGTH ; final int numMessagesToSend = 2 * numMessagesInTermBuffer ; final int numBatches = 4 ; final int numMessagesPerBatch = numMessagesToSend / numBatches ; context . termBufferLength ( termBufferLength ) ; context . dataLossRate ( 0.10 ) ; context . dataLossSeed ( 0xcafebabeL ) ; launch ( channel ) ; for ( int i = 0 ; i < numBatches ; i ++ ) { for ( int j = 0 ; j < numMessagesPerBatch ; j ++ ) { while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { Thread . yield ( ) ; } } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] >= numMessagesPerBatch , ( j ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 900 ) ) ; } verify ( fragmentHandler , times ( numMessagesToSend ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( messageLength ) , any ( Header . class ) ) ; } @ Theory @ Test ( timeout = 10000 ) public void shouldContinueAfterBufferRolloverBatched ( final String channel ) throws Exception { final int termBufferLength = 64 * 1024 ; final int numBatchesPerTerm = 4 ; final int numMessagesPerBatch = 16 ; final int numMessagesInTermBuffer = numMessagesPerBatch * numBatchesPerTerm ; final int messageLength = ( termBufferLength / numMessagesInTermBuffer ) - DataHeaderFlyweight . HEADER_LENGTH ; final int numMessagesToSend = numMessagesInTermBuffer + 1 ; context . termBufferLength ( termBufferLength ) ; launch ( channel ) ; for ( int i = 0 ; i < numBatchesPerTerm ; i ++ ) { for ( int j = 0 ; j < numMessagesPerBatch ; j ++ ) { while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { Thread . yield ( ) ; } } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] >= numMessagesPerBatch , ( j ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 900 ) ) ; } while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { Thread . yield ( ) ; } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > 0 , ( j ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 900 ) ) ; verify ( fragmentHandler , times ( numMessagesToSend ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( messageLength ) , any ( Header . class ) ) ; } @ Theory @ Test ( timeout = 10000 ) public void shouldContinueAfterBufferRolloverWithPadding ( final String channel ) throws Exception { final int termBufferLength = 64 * 1024 ; final int messageLength = 1032 - DataHeaderFlyweight . HEADER_LENGTH ; final int numMessagesToSend = 64 ; context . termBufferLength ( termBufferLength ) ; launch ( channel ) ; for ( int i = 0 ; i < numMessagesToSend ; i ++ ) { while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { Thread . yield ( ) ; } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > 0 , ( j ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 500 ) ) ; } verify ( fragmentHandler , times ( numMessagesToSend ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( messageLength ) , any ( Header . class ) ) ; } @ Theory @ Test ( timeout = 10000 ) public void shouldContinueAfterBufferRolloverWithPaddingBatched ( final String channel ) throws Exception { final int termBufferLength = 64 * 1024 ; final int messageLength = 1032 - DataHeaderFlyweight . HEADER_LENGTH ; final int numMessagesToSend = 64 ; final int numBatchesPerTerm = 4 ; final int numMessagesPerBatch = numMessagesToSend / numBatchesPerTerm ; context . termBufferLength ( termBufferLength ) ; launch ( channel ) ; for ( int i = 0 ; i < numBatchesPerTerm ; i ++ ) { for ( int j = 0 ; j < numMessagesPerBatch ; j ++ ) { while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { Thread . yield ( ) ; } } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] >= numMessagesPerBatch , ( j ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 900 ) ) ; } verify ( fragmentHandler , times ( numMessagesToSend ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( messageLength ) , any ( Header . class ) ) ; } @ Theory @ Test ( timeout = 10000 ) public void shouldReceiveOnlyAfterSendingUpToFlowControlLimit ( final String channel ) throws Exception { final int termBufferLength = 64 * 1024 ; final int numMessagesPerTerm = 64 ; final int messageLength = ( termBufferLength / numMessagesPerTerm ) - DataHeaderFlyweight . HEADER_LENGTH ; final int maxFails = 10000 ; int messagesSent = 0 ; context . termBufferLength ( termBufferLength ) ; launch ( channel ) ; for ( int i = 0 ; i < numMessagesPerTerm ; i ++ ) { int offerFails = 0 ; while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { if ( ++ offerFails > maxFails ) { break ; } Thread . yield ( ) ; } if ( offerFails > maxFails ) { break ; } messagesSent ++ ; } final int fragmentsRead [ ] = new int [ 1 ] ; final int messagesToReceive = messagesSent ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] >= messagesToReceive , ( j ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 500 ) ) ; verify ( fragmentHandler , times ( messagesToReceive ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( messageLength ) , any ( Header . class ) ) ; } @ Theory @ Test ( timeout = 10000 ) public void shouldReceivePublishedMessageOneForOneWithReSubscription ( final String channel ) throws Exception { final int termBufferLength = 64 * 1024 ; final int numMessagesInTermBuffer = 64 ; final int messageLength = ( termBufferLength / numMessagesInTermBuffer ) - DataHeaderFlyweight . HEADER_LENGTH ; final int numMessagesToSendStageOne = numMessagesInTermBuffer / 2 ; final int numMessagesToSendStageTwo = numMessagesInTermBuffer ; final CountDownLatch newConnectionLatch = new CountDownLatch ( 1 ) ; final int stage [ ] = { 1 } ; context . termBufferLength ( termBufferLength ) ; subscribingAeronContext . newConnectionHandler ( ( c , streamId , sessionId , position , info ) - > { if ( 2 == stage [ 0 ] ) { newConnectionLatch . countDown ( ) ; } } ) ; launch ( channel ) ; for ( int i = 0 ; i < numMessagesToSendStageOne ; i ++ ) { while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { Thread . yield ( ) ; } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > 0 , ( j ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 900 ) ) ; } subscription . close ( ) ; stage [ 0 ] = 2 ; subscription = subscribingClient . addSubscription ( channel , STREAM_ID ) ; newConnectionLatch . await ( ) ; for ( int i = 0 ; i < numMessagesToSendStageTwo ; i ++ ) { while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { Thread . yield ( ) ; } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > 0 , ( j ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 900 ) ) ; } verify ( fragmentHandler , times ( numMessagesToSendStageOne + numMessagesToSendStageTwo ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( messageLength ) , any ( Header . class ) ) ; } @ Theory @ Test ( timeout = 10000 ) public void shouldFragmentExactMessageLengthsCorrectly ( final String channel ) throws Exception { final int termBufferLength = 64 * 1024 ; final int numFragmentsPerMessage = 2 ; final int mtuLength = 4096 ; final int frameLength = mtuLength - DataHeaderFlyweight . HEADER_LENGTH ; final int messageLength = frameLength * numFragmentsPerMessage ; final int numMessagesToSend = 2 ; final int numFramesToExpect = numMessagesToSend * numFragmentsPerMessage ; context . termBufferLength ( termBufferLength ) . mtuLength ( mtuLength ) ; launch ( channel ) ; for ( int i = 0 ; i < numMessagesToSend ; i ++ ) { while ( publication . offer ( buffer , 0 , messageLength ) < 0L ) { Thread . yield ( ) ; } } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > numFramesToExpect , ( j ) - > { fragmentsRead [ 0 ] += subscription . poll ( fragmentHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 500 ) ) ; verify ( fragmentHandler , times ( numFramesToExpect ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( frameLength ) , any ( Header . class ) ) ; } }
package uk . co . real_logic . aeron ; import java . util . function . BooleanSupplier ; import java . util . function . IntConsumer ; public class SystemTestHelper { public static void executeUntil ( final BooleanSupplier condition , final IntConsumer body , final int maxIterations , final long timeout ) { final long start = System . nanoTime ( ) ; long end ; int iteration = 0 ; do { body . accept ( iteration ) ; end = System . nanoTime ( ) ; } while ( ! condition . getAsBoolean ( ) && ( ( end - start ) < timeout ) && iteration ++ < maxIterations ) ; } }
package uk . co . real_logic . aeron ; import org . junit . After ; import org . junit . Test ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . aeron . driver . ThreadingMode ; import uk . co . real_logic . agrona . IoUtil ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . io . File ; import java . util . UUID ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . * ; public class MultiDriverTest { public static final String MULTICAST_URI = "udp://localhost@224.20.30.39:54326" ; private static final int STREAM_ID = 1 ; private static final int SESSION_ID = 2 ; private static final ThreadingMode THREADING_MODE = ThreadingMode . SHARED ; private static final int TERM_BUFFER_SIZE = 64 * 1024 ; private static final int NUM_MESSAGES_PER_TERM = 64 ; private static final int MESSAGE_LENGTH = ( TERM_BUFFER_SIZE / NUM_MESSAGES_PER_TERM ) - DataHeaderFlyweight . HEADER_LENGTH ; private static final String ROOT_DIR = IoUtil . tmpDirName ( ) + "aeron-system-tests-" + UUID . randomUUID ( ) . toString ( ) + File . separator ; private final MediaDriver . Context driverAContext = new MediaDriver . Context ( ) ; private final MediaDriver . Context driverBContext = new MediaDriver . Context ( ) ; private final Aeron . Context aeronAContext = new Aeron . Context ( ) ; private final Aeron . Context aeronBContext = new Aeron . Context ( ) ; private Aeron clientA ; private Aeron clientB ; private MediaDriver driverA ; private MediaDriver driverB ; private Publication publication ; private Subscription subscriptionA ; private Subscription subscriptionB ; private UnsafeBuffer buffer = new UnsafeBuffer ( new byte [ MESSAGE_LENGTH ] ) ; private FragmentHandler fragmentHandlerA = mock ( FragmentHandler . class ) ; private FragmentHandler fragmentHandlerB = mock ( FragmentHandler . class ) ; private void launch ( ) { final String baseDirA = ROOT_DIR + "A" ; final String baseDirB = ROOT_DIR + "B" ; buffer . putInt ( 0 , 1 ) ; driverAContext . termBufferLength ( TERM_BUFFER_SIZE ) ; driverAContext . dirsDeleteOnExit ( true ) ; driverAContext . dirName ( baseDirA ) ; driverAContext . threadingMode ( THREADING_MODE ) ; aeronAContext . dirName ( driverAContext . dirName ( ) ) ; driverBContext . termBufferLength ( TERM_BUFFER_SIZE ) ; driverBContext . dirsDeleteOnExit ( true ) ; driverBContext . dirName ( baseDirB ) ; driverBContext . threadingMode ( THREADING_MODE ) ; aeronBContext . dirName ( driverBContext . dirName ( ) ) ; driverA = MediaDriver . launch ( driverAContext ) ; driverB = MediaDriver . launch ( driverBContext ) ; clientA = Aeron . connect ( aeronAContext ) ; clientB = Aeron . connect ( aeronBContext ) ; } @ After public void closeEverything ( ) { if ( null != publication ) { publication . close ( ) ; } if ( null != subscriptionA ) { subscriptionA . close ( ) ; } if ( null != subscriptionB ) { subscriptionB . close ( ) ; } clientB . close ( ) ; clientA . close ( ) ; driverB . close ( ) ; driverA . close ( ) ; IoUtil . delete ( new File ( ROOT_DIR ) , true ) ; } @ Test ( timeout = 10000 ) public void shouldSpinUpAndShutdown ( ) throws Exception { launch ( ) ; publication = clientA . addPublication ( MULTICAST_URI , STREAM_ID , SESSION_ID ) ; subscriptionA = clientA . addSubscription ( MULTICAST_URI , STREAM_ID ) ; subscriptionB = clientB . addSubscription ( MULTICAST_URI , STREAM_ID ) ; Thread . sleep ( 20 ) ; } @ Test ( timeout = 10000 ) public void shouldJoinExistingStreamWithLockStepSendingReceiving ( ) throws Exception { final int numMessagesToSendPreJoin = NUM_MESSAGES_PER_TERM / 2 ; final int numMessagesToSendPostJoin = NUM_MESSAGES_PER_TERM ; final CountDownLatch newConnectionLatch = new CountDownLatch ( 1 ) ; aeronBContext . newConnectionHandler ( ( channel , streamId , sessionId , position , info ) - > newConnectionLatch . countDown ( ) ) ; launch ( ) ; publication = clientA . addPublication ( MULTICAST_URI , STREAM_ID , SESSION_ID ) ; subscriptionA = clientA . addSubscription ( MULTICAST_URI , STREAM_ID ) ; for ( int i = 0 ; i < numMessagesToSendPreJoin ; i ++ ) { while ( publication . offer ( buffer , 0 , buffer . capacity ( ) ) < 0L ) { Thread . yield ( ) ; } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > 0 , ( j ) - > { fragmentsRead [ 0 ] += subscriptionA . poll ( fragmentHandlerA , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 500 ) ) ; } subscriptionB = clientB . addSubscription ( MULTICAST_URI , STREAM_ID ) ; newConnectionLatch . await ( ) ; for ( int i = 0 ; i < numMessagesToSendPostJoin ; i ++ ) { while ( publication . offer ( buffer , 0 , buffer . capacity ( ) ) < 0L ) { Thread . yield ( ) ; } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > 0 , ( j ) - > { fragmentsRead [ 0 ] += subscriptionA . poll ( fragmentHandlerA , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 500 ) ) ; fragmentsRead [ 0 ] = 0 ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > 0 , ( j ) - > { fragmentsRead [ 0 ] += subscriptionB . poll ( fragmentHandlerB , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 500 ) ) ; } verify ( fragmentHandlerA , times ( numMessagesToSendPreJoin + numMessagesToSendPostJoin ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( MESSAGE_LENGTH ) , any ( Header . class ) ) ; verify ( fragmentHandlerB , times ( numMessagesToSendPostJoin ) ) . onFragment ( any ( UnsafeBuffer . class ) , anyInt ( ) , eq ( MESSAGE_LENGTH ) , any ( Header . class ) ) ; } }
package uk . co . real_logic . aeron ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . aeron . driver . ThreadingMode ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . util . concurrent . TimeUnit ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; public class PongTest { public static final String PING_URI = "udp://localhost:54325" ; public static final String PONG_URI = "udp://localhost:54326" ; private static final int PING_STREAM_ID = 1 ; private static final int PONG_STREAM_ID = 2 ; private static final ThreadingMode THREADING_MODE = ThreadingMode . SHARED ; private final MediaDriver . Context context = new MediaDriver . Context ( ) ; private final Aeron . Context pingAeronContext = new Aeron . Context ( ) ; private final Aeron . Context pongAeronContext = new Aeron . Context ( ) ; private Aeron pingClient ; private Aeron pongClient ; private MediaDriver driver ; private Subscription pingSubscription ; private Subscription pongSubscription ; private Publication pingPublication ; private Publication pongPublication ; private UnsafeBuffer buffer = new UnsafeBuffer ( new byte [ 4096 ] ) ; private FragmentHandler pongHandler = mock ( FragmentHandler . class ) ; @ Before public void setUp ( ) throws Exception { context . dirsDeleteOnExit ( true ) ; context . threadingMode ( THREADING_MODE ) ; driver = MediaDriver . launch ( context ) ; pingClient = Aeron . connect ( pingAeronContext ) ; pongClient = Aeron . connect ( pongAeronContext ) ; pingPublication = pingClient . addPublication ( PING_URI , PING_STREAM_ID ) ; pingSubscription = pongClient . addSubscription ( PING_URI , PING_STREAM_ID ) ; pongPublication = pongClient . addPublication ( PONG_URI , PONG_STREAM_ID ) ; pongSubscription = pingClient . addSubscription ( PONG_URI , PONG_STREAM_ID ) ; } @ After public void closeEverything ( ) throws Exception { if ( null != pingPublication ) { pingPublication . close ( ) ; } if ( null != pongPublication ) { pongPublication . close ( ) ; } if ( null != pingSubscription ) { pingSubscription . close ( ) ; } if ( null != pongSubscription ) { pongSubscription . close ( ) ; } pongClient . close ( ) ; pingClient . close ( ) ; driver . close ( ) ; } @ Test public void playPingPong ( ) { buffer . putInt ( 0 , 1 ) ; while ( pingPublication . offer ( buffer , 0 , BitUtil . SIZE_OF_INT ) < 0L ) { Thread . yield ( ) ; } final int fragmentsRead [ ] = new int [ 1 ] ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > 0 , ( i ) - > { fragmentsRead [ 0 ] += pingSubscription . poll ( this : : pingHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 5900 ) ) ; fragmentsRead [ 0 ] = 0 ; SystemTestHelper . executeUntil ( ( ) - > fragmentsRead [ 0 ] > 0 , ( i ) - > { fragmentsRead [ 0 ] += pongSubscription . poll ( pongHandler , 10 ) ; Thread . yield ( ) ; } , Integer . MAX_VALUE , TimeUnit . MILLISECONDS . toNanos ( 5900 ) ) ; verify ( pongHandler ) . onFragment ( any ( UnsafeBuffer . class ) , eq ( DataHeaderFlyweight . HEADER_LENGTH ) , eq ( BitUtil . SIZE_OF_INT ) , any ( Header . class ) ) ; } public void pingHandler ( final DirectBuffer buffer , final int offset , final int length , final Header header ) { while ( pongPublication . offer ( buffer , offset , length ) < 0L ) { Thread . yield ( ) ; } } }
package uk . co . real_logic . aeron ; import org . junit . Test ; import org . mockito . ArgumentCaptor ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertThat ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . * ; public class MultiSubscriberTest { public static final String CHANNEL_1 = "aeron:udp?remote=localhost:54325|fruit=banana" ; public static final String CHANNEL_2 = "aeron:udp?remote=localhost:54325|fruit=apple" ; public static final int STREAM_ID = 1 ; public static final int FRAGMENT_COUNT_LIMIT = 10 ; @ Test ( timeout = 10000 ) public void shouldReceiveMessageOnSeparateSubscriptions ( ) throws Exception { final MediaDriver . Context ctx = new MediaDriver . Context ( ) ; ctx . dirsDeleteOnExit ( true ) ; final FragmentHandler mockFragmentHandlerOne = mock ( FragmentHandler . class ) ; final FragmentHandler mockFragmentHandlerTwo = mock ( FragmentHandler . class ) ; final FragmentAssemblyAdapter adapterOne = new FragmentAssemblyAdapter ( mockFragmentHandlerOne ) ; final FragmentAssemblyAdapter adapterTwo = new FragmentAssemblyAdapter ( mockFragmentHandlerTwo ) ; try ( final MediaDriver ignore = MediaDriver . launch ( ctx ) ; final Aeron client = Aeron . connect ( new Aeron . Context ( ) ) ; final Publication publication = client . addPublication ( CHANNEL_1 , STREAM_ID ) ; final Subscription subscriptionOne = client . addSubscription ( CHANNEL_1 , STREAM_ID ) ; final Subscription subscriptionTwo = client . addSubscription ( CHANNEL_2 , STREAM_ID ) ) { final byte [ ] expectedBytes = "Hello, World! here is a small message" . getBytes ( ) ; final UnsafeBuffer srcBuffer = new UnsafeBuffer ( expectedBytes ) ; assertThat ( subscriptionOne . poll ( adapterOne , FRAGMENT_COUNT_LIMIT ) , is ( 0 ) ) ; assertThat ( subscriptionTwo . poll ( adapterTwo , FRAGMENT_COUNT_LIMIT ) , is ( 0 ) ) ; while ( publication . offer ( srcBuffer ) < 0L ) { Thread . yield ( ) ; } while ( subscriptionOne . poll ( adapterOne , FRAGMENT_COUNT_LIMIT ) == 0 ) { Thread . yield ( ) ; } while ( subscriptionTwo . poll ( adapterTwo , FRAGMENT_COUNT_LIMIT ) == 0 ) { Thread . yield ( ) ; } verifyData ( srcBuffer , mockFragmentHandlerOne ) ; verifyData ( srcBuffer , mockFragmentHandlerTwo ) ; } } private void verifyData ( final UnsafeBuffer srcBuffer , final FragmentHandler mockFragmentHandler ) { final ArgumentCaptor < UnsafeBuffer > bufferArg = ArgumentCaptor . forClass ( UnsafeBuffer . class ) ; final ArgumentCaptor < Integer > offsetArg = ArgumentCaptor . forClass ( Integer . class ) ; verify ( mockFragmentHandler , times ( 1 ) ) . onFragment ( bufferArg . capture ( ) , offsetArg . capture ( ) , eq ( srcBuffer . capacity ( ) ) , any ( Header . class ) ) ; final UnsafeBuffer capturedBuffer = bufferArg . getValue ( ) ; final int offset = offsetArg . getValue ( ) ; for ( int i = 0 ; i < srcBuffer . capacity ( ) ; i ++ ) { final int index = offset + i ; assertThat ( "same at " + index , capturedBuffer . getByte ( index ) , is ( srcBuffer . getByte ( i ) ) ) ; } } }
package uk . co . real_logic . aeron ; import org . junit . Test ; import org . junit . experimental . theories . DataPoint ; import org . junit . experimental . theories . Theories ; import org . junit . experimental . theories . Theory ; import org . junit . runner . RunWith ; import org . mockito . ArgumentCaptor ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . FrameDescriptor ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . aeron . driver . ThreadingMode ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertThat ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . * ; @ RunWith ( Theories . class ) public class FragmentedMessageTest { @ DataPoint public static final String UNICAST_URI = "udp://localhost:54325" ; @ DataPoint public static final String MULTICAST_URI = "udp://localhost@224.20.30.39:54326" ; @ DataPoint public static final ThreadingMode SHARED = ThreadingMode . SHARED ; @ DataPoint public static final ThreadingMode SHARED_NETWORK = ThreadingMode . SHARED_NETWORK ; @ DataPoint public static final ThreadingMode DEDICATED = ThreadingMode . DEDICATED ; public static final int STREAM_ID = 1 ; public static final int FRAGMENT_COUNT_LIMIT = 10 ; private final FragmentHandler mockFragmentHandler = mock ( FragmentHandler . class ) ; @ Theory @ Test ( timeout = 10000 ) public void shouldReceivePublishedMessage ( final String channel , final ThreadingMode threadingMode ) throws Exception { final MediaDriver . Context ctx = new MediaDriver . Context ( ) ; ctx . dirsDeleteOnExit ( true ) ; ctx . threadingMode ( threadingMode ) ; final FragmentAssemblyAdapter adapter = new FragmentAssemblyAdapter ( mockFragmentHandler ) ; try ( final MediaDriver ignore = MediaDriver . launch ( ctx ) ; final Aeron client = Aeron . connect ( new Aeron . Context ( ) ) ; final Publication publication = client . addPublication ( channel , STREAM_ID ) ; final Subscription subscription = client . addSubscription ( channel , STREAM_ID ) ) { final UnsafeBuffer srcBuffer = new UnsafeBuffer ( new byte [ ctx . mtuLength ( ) * 4 ] ) ; final int offset = 0 ; final int length = srcBuffer . capacity ( ) / 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { srcBuffer . setMemory ( i * length , length , ( byte ) ( 65 + i ) ) ; } while ( publication . offer ( srcBuffer , offset , srcBuffer . capacity ( ) ) < 0L ) { Thread . yield ( ) ; } final int expectedFragmentsBecauseOfHeader = 5 ; int numFragments = 0 ; do { numFragments += subscription . poll ( adapter , FRAGMENT_COUNT_LIMIT ) ; } while ( numFragments < expectedFragmentsBecauseOfHeader ) ; final ArgumentCaptor < UnsafeBuffer > bufferArg = ArgumentCaptor . forClass ( UnsafeBuffer . class ) ; final ArgumentCaptor < Header > headerArg = ArgumentCaptor . forClass ( Header . class ) ; verify ( mockFragmentHandler , times ( 1 ) ) . onFragment ( bufferArg . capture ( ) , eq ( offset ) , eq ( srcBuffer . capacity ( ) ) , headerArg . capture ( ) ) ; final UnsafeBuffer capturedBuffer = bufferArg . getValue ( ) ; for ( int i = 0 ; i < srcBuffer . capacity ( ) ; i ++ ) { assertThat ( "same at i=" + i , capturedBuffer . getByte ( i ) , is ( srcBuffer . getByte ( i ) ) ) ; } assertThat ( headerArg . getValue ( ) . flags ( ) , is ( FrameDescriptor . UNFRAGMENTED ) ) ; } } }
package uk . co . real_logic . aeron . samples ; import org . HdrHistogram . Histogram ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . FragmentAssemblyAdapter ; import uk . co . real_logic . aeron . Publication ; import uk . co . real_logic . aeron . Subscription ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . agrona . CloseHelper ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import uk . co . real_logic . agrona . concurrent . NoOpIdleStrategy ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . console . ContinueBarrier ; import java . nio . ByteBuffer ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; public class Ping { private static final String PING_CHANNEL = SampleConfiguration . PING_CHANNEL ; private static final String PONG_CHANNEL = SampleConfiguration . PONG_CHANNEL ; private static final int PING_STREAM_ID = SampleConfiguration . PING_STREAM_ID ; private static final int PONG_STREAM_ID = SampleConfiguration . PONG_STREAM_ID ; private static final int NUMBER_OF_MESSAGES = SampleConfiguration . NUMBER_OF_MESSAGES ; private static final int WARMUP_NUMBER_OF_MESSAGES = SampleConfiguration . WARMUP_NUMBER_OF_MESSAGES ; private static final int WARMUP_NUMBER_OF_ITERATIONS = SampleConfiguration . WARMUP_NUMBER_OF_ITERATIONS ; private static final int MESSAGE_LENGTH = SampleConfiguration . MESSAGE_LENGTH ; private static final int FRAGMENT_COUNT_LIMIT = SampleConfiguration . FRAGMENT_COUNT_LIMIT ; private static final boolean EMBEDDED_MEDIA_DRIVER = SampleConfiguration . EMBEDDED_MEDIA_DRIVER ; private static final UnsafeBuffer ATOMIC_BUFFER = new UnsafeBuffer ( ByteBuffer . allocateDirect ( MESSAGE_LENGTH ) ) ; private static final Histogram HISTOGRAM = new Histogram ( TimeUnit . SECONDS . toNanos ( 10 ) , 3 ) ; private static volatile CountDownLatch pongConnectionLatch ; public static void main ( final String [ ] args ) throws Exception { final MediaDriver driver = EMBEDDED_MEDIA_DRIVER ? MediaDriver . launchEmbedded ( ) : null ; final Aeron . Context ctx = new Aeron . Context ( ) . newConnectionHandler ( Ping : : newPongConnectionHandler ) ; final FragmentHandler fragmentHandler = new FragmentAssemblyAdapter ( Ping : : pongHandler ) ; if ( EMBEDDED_MEDIA_DRIVER ) { ctx . dirName ( driver . contextDirName ( ) ) ; } System . out . println ( "Publishing Ping at " + PING_CHANNEL + " on stream Id " + PING_STREAM_ID ) ; System . out . println ( "Subscribing Pong at " + PONG_CHANNEL + " on stream Id " + PONG_STREAM_ID ) ; System . out . println ( "Message length of " + MESSAGE_LENGTH + " bytes" ) ; try ( final Aeron aeron = Aeron . connect ( ctx ) ) { System . out . println ( "Warming up... " + WARMUP_NUMBER_OF_ITERATIONS + " iterations of " + WARMUP_NUMBER_OF_MESSAGES + " messages" ) ; pongConnectionLatch = new CountDownLatch ( 1 ) ; try ( final Publication publication = aeron . addPublication ( PING_CHANNEL , PING_STREAM_ID ) ; final Subscription subscription = aeron . addSubscription ( PONG_CHANNEL , PONG_STREAM_ID ) ) { pongConnectionLatch . await ( ) ; for ( int i = 0 ; i < WARMUP_NUMBER_OF_ITERATIONS ; i ++ ) { sendPingAndReceivePong ( fragmentHandler , publication , subscription , WARMUP_NUMBER_OF_MESSAGES ) ; } } final ContinueBarrier barrier = new ContinueBarrier ( "Execute again?" ) ; pongConnectionLatch = new CountDownLatch ( 1 ) ; try ( final Publication publication = aeron . addPublication ( PING_CHANNEL , PING_STREAM_ID ) ; final Subscription subscription = aeron . addSubscription ( PONG_CHANNEL , PONG_STREAM_ID ) ) { pongConnectionLatch . await ( ) ; Thread . sleep ( 1000 ) ; do { System . out . println ( "Pinging " + NUMBER_OF_MESSAGES + " messages" ) ; HISTOGRAM . reset ( ) ; System . gc ( ) ; sendPingAndReceivePong ( fragmentHandler , publication , subscription , NUMBER_OF_MESSAGES ) ; System . out . println ( "Histogram of RTT latencies in microseconds." ) ; HISTOGRAM . outputPercentileDistribution ( System . out , 1000.0 ) ; } while ( barrier . await ( ) ) ; } } CloseHelper . quietClose ( driver ) ; } private static void sendPingAndReceivePong ( final FragmentHandler fragmentHandler , final Publication publication , final Subscription subscription , final int numMessages ) { final IdleStrategy idleStrategy = new NoOpIdleStrategy ( ) ; for ( int i = 0 ; i < numMessages ; i ++ ) { do { ATOMIC_BUFFER . putLong ( 0 , System . nanoTime ( ) ) ; } while ( publication . offer ( ATOMIC_BUFFER , 0 , MESSAGE_LENGTH ) < 0L ) ; while ( subscription . poll ( fragmentHandler , FRAGMENT_COUNT_LIMIT ) <= 0 ) { idleStrategy . idle ( 0 ) ; } } } private static void pongHandler ( final DirectBuffer buffer , final int offset , final int length , final Header header ) { final long pingTimestamp = buffer . getLong ( offset ) ; final long rttNs = System . nanoTime ( ) - pingTimestamp ; HISTOGRAM . recordValue ( rttNs ) ; } private static void newPongConnectionHandler ( final String channel , final int streamId , final int sessionId , final long joiningPosition , final String sourceIdentity ) { System . out . format ( "New connection: channel=%s streamId=%d session=%d\n" , channel , streamId , sessionId ) ; if ( PONG_STREAM_ID == streamId && PONG_CHANNEL . equals ( channel ) ) { pongConnectionLatch . countDown ( ) ; } } }
package uk . co . real_logic . aeron . tools ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class StatsNetstatOutput implements StatsOutput { private HashMap < String , PublisherStats > pubs = null ; private HashMap < String , SubscriberStats > subs = null ; public StatsNetstatOutput ( ) { pubs = new HashMap < > ( ) ; subs = new HashMap < > ( ) ; } public void format ( final String [ ] keys , final long [ ] vals ) throws Exception { for ( int i = 0 ; i < keys . length ; i ++ ) { if ( keys [ i ] . startsWith ( "receiver" ) || keys [ i ] . startsWith ( "subscriber" ) ) { processSubscriberInfo ( keys [ i ] , vals [ i ] ) ; } else if ( keys [ i ] . startsWith ( "sender" ) || keys [ i ] . startsWith ( "publisher" ) ) { processPublisherInfo ( keys [ i ] , vals [ i ] ) ; } } System . out . println ( "Aeron Channel Statistics" ) ; Iterator itr = pubs . entrySet ( ) . iterator ( ) ; System . out . println ( "Publishers" ) ; System . out . format ( "%1$5s %2$8s %3$8s %4$16s %5$10s\n" , "proto" , "pos" , "limit" , "location" , "session" ) ; while ( itr . hasNext ( ) ) { final Map . Entry pair = ( Map . Entry ) itr . next ( ) ; System . out . print ( ( pair . getValue ( ) ) ) ; } System . out . println ( ) ; itr = subs . entrySet ( ) . iterator ( ) ; System . out . println ( "Subscribers" ) ; System . out . format ( "%1$5s %2$8s %3$8s %4$16s %5$10s\n" , "proto" , "pos" , "hwm" , "location" , "session" ) ; while ( itr . hasNext ( ) ) { final Map . Entry pair = ( Map . Entry ) itr . next ( ) ; System . out . print ( ( pair . getValue ( ) ) ) ; } System . out . println ( "-----------------------------------------------------------\n" ) ; } public void close ( ) throws Exception { } private void processSubscriberInfo ( final String key , final long val ) { SubscriberStats sub = null ; final String senderInfoType = key . substring ( key . indexOf ( ' ' ) + 1 , key . indexOf ( ':' ) ) ; final String channelInfo = key . substring ( key . indexOf ( ':' ) + 2 ) ; if ( subs . containsKey ( channelInfo ) ) { sub = subs . get ( channelInfo ) ; } else { sub = new SubscriberStats ( channelInfo ) ; } updateField ( sub , senderInfoType , val ) ; subs . put ( channelInfo , sub ) ; } private void processPublisherInfo ( final String key , final long val ) { PublisherStats pub = null ; final String senderInfoType = key . substring ( key . indexOf ( ' ' ) + 1 , key . indexOf ( ':' ) ) ; final String channelInfo = key . substring ( key . indexOf ( ':' ) + 2 ) ; if ( pubs . containsKey ( channelInfo ) ) { pub = pubs . get ( channelInfo ) ; } else { pub = new PublisherStats ( channelInfo ) ; } updateField ( pub , senderInfoType , val ) ; pubs . put ( channelInfo , pub ) ; } private void updateField ( final PublisherStats pub , final String key , final long val ) { if ( "limit" . equalsIgnoreCase ( key ) ) { pub . setLimit ( val ) ; } else if ( "pos" . equalsIgnoreCase ( key ) ) { pub . setPos ( val ) ; } } private void updateField ( final SubscriberStats sub , final String key , final long val ) { if ( "hwm" . equalsIgnoreCase ( key ) ) { sub . setHWM ( val ) ; } else if ( "pos" . equalsIgnoreCase ( key ) ) { sub . setPos ( val ) ; } } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . Publication ; import uk . co . real_logic . aeron . Subscription ; import uk . co . real_logic . aeron . CommonContext ; import uk . co . real_logic . aeron . driver . RateReporter ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . aeron . driver . ThreadingMode ; import uk . co . real_logic . agrona . concurrent . BusySpinIdleStrategy ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import uk . co . real_logic . agrona . concurrent . NoOpIdleStrategy ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . console . ContinueBarrier ; import java . nio . ByteBuffer ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import static uk . co . real_logic . aeron . samples . SamplesUtil . rateReporterHandler ; public class EmbeddedThroughput { private static final String CHANNEL = SampleConfiguration . CHANNEL ; private static final int STREAM_ID = SampleConfiguration . STREAM_ID ; private static final int MESSAGE_LENGTH = SampleConfiguration . MESSAGE_LENGTH ; private static final long NUMBER_OF_MESSAGES = SampleConfiguration . NUMBER_OF_MESSAGES ; private static final long LINGER_TIMEOUT_MS = SampleConfiguration . LINGER_TIMEOUT_MS ; private static final int FRAGMENT_COUNT_LIMIT = SampleConfiguration . FRAGMENT_COUNT_LIMIT ; private static final UnsafeBuffer ATOMIC_BUFFER = new UnsafeBuffer ( ByteBuffer . allocateDirect ( MESSAGE_LENGTH ) ) ; private static final IdleStrategy OFFER_IDLE_STRATEGY = new BusySpinIdleStrategy ( ) ; public static void main ( final String [ ] args ) throws Exception { final MediaDriver . Context ctx = new MediaDriver . Context ( ) . threadingMode ( ThreadingMode . DEDICATED ) . conductorIdleStrategy ( new NoOpIdleStrategy ( ) ) . receiverIdleStrategy ( new NoOpIdleStrategy ( ) ) . senderIdleStrategy ( new NoOpIdleStrategy ( ) ) . dirsDeleteOnExit ( true ) ; final RateReporter reporter = new RateReporter ( TimeUnit . SECONDS . toNanos ( 1 ) , SamplesUtil : : printRate ) ; final FragmentHandler rateReporterHandler = rateReporterHandler ( reporter ) ; final ExecutorService executor = Executors . newFixedThreadPool ( 2 ) ; final Aeron . Context context = new Aeron . Context ( ) ; final String embeddedDirName = CommonContext . generateEmbeddedDirName ( ) ; ctx . dirName ( embeddedDirName ) ; context . dirName ( embeddedDirName ) ; System . out . format ( "Aeron dir '%s'\n" , embeddedDirName ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; try ( final MediaDriver ignore = MediaDriver . launch ( ctx ) ; final Aeron aeron = Aeron . connect ( context ) ; final Publication publication = aeron . addPublication ( CHANNEL , STREAM_ID ) ; final Subscription subscription = aeron . addSubscription ( CHANNEL , STREAM_ID ) ) { executor . execute ( reporter ) ; executor . execute ( ( ) - > SamplesUtil . subscriberLoop ( rateReporterHandler , FRAGMENT_COUNT_LIMIT , running ) . accept ( subscription ) ) ; final ContinueBarrier barrier = new ContinueBarrier ( "Execute again?" ) ; do { System . out . format ( "\nStreaming %,d messages of size %d bytes to %s on stream Id %d\n" , NUMBER_OF_MESSAGES , MESSAGE_LENGTH , CHANNEL , STREAM_ID ) ; long backPressureCount = 0 ; for ( long i = 0 ; i < NUMBER_OF_MESSAGES ; i ++ ) { ATOMIC_BUFFER . putLong ( 0 , i ) ; while ( publication . offer ( ATOMIC_BUFFER , 0 , ATOMIC_BUFFER . capacity ( ) ) < 0 ) { backPressureCount ++ ; OFFER_IDLE_STRATEGY . idle ( 0 ) ; } } System . out . println ( "Done streaming. backPressureRatio=" + ( ( double ) backPressureCount / NUMBER_OF_MESSAGES ) ) ; if ( 0 < LINGER_TIMEOUT_MS ) { System . out . println ( "Lingering for " + LINGER_TIMEOUT_MS + " milliseconds..." ) ; Thread . sleep ( LINGER_TIMEOUT_MS ) ; } } while ( barrier . await ( ) ) ; running . set ( false ) ; reporter . halt ( ) ; executor . shutdown ( ) ; } } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . FragmentAssemblyAdapter ; import uk . co . real_logic . aeron . Subscription ; import uk . co . real_logic . aeron . driver . RateReporter ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . agrona . CloseHelper ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import static uk . co . real_logic . aeron . samples . SamplesUtil . rateReporterHandler ; public class RateSubscriber { private static final int STREAM_ID = SampleConfiguration . STREAM_ID ; private static final String CHANNEL = SampleConfiguration . CHANNEL ; private static final int FRAGMENT_COUNT_LIMIT = SampleConfiguration . FRAGMENT_COUNT_LIMIT ; private static final boolean EMBEDDED_MEDIA_DRIVER = SampleConfiguration . EMBEDDED_MEDIA_DRIVER ; public static void main ( final String [ ] args ) throws Exception { System . out . println ( "Subscribing to " + CHANNEL + " on stream Id " + STREAM_ID ) ; final MediaDriver driver = EMBEDDED_MEDIA_DRIVER ? MediaDriver . launchEmbedded ( ) : null ; final ExecutorService executor = Executors . newFixedThreadPool ( 1 ) ; final Aeron . Context ctx = new Aeron . Context ( ) . newConnectionHandler ( SamplesUtil : : printNewConnection ) . inactiveConnectionHandler ( SamplesUtil : : printInactiveConnection ) ; if ( EMBEDDED_MEDIA_DRIVER ) { ctx . dirName ( driver . contextDirName ( ) ) ; } final RateReporter reporter = new RateReporter ( TimeUnit . SECONDS . toNanos ( 1 ) , SamplesUtil : : printRate ) ; final FragmentHandler rateReporterHandler = new FragmentAssemblyAdapter ( rateReporterHandler ( reporter ) ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > { reporter . halt ( ) ; running . set ( false ) ; } ) ; try ( final Aeron aeron = Aeron . connect ( ctx ) ; final Subscription subscription = aeron . addSubscription ( CHANNEL , STREAM_ID ) ) { final Future future = executor . submit ( ( ) - > SamplesUtil . subscriberLoop ( rateReporterHandler , FRAGMENT_COUNT_LIMIT , running ) . accept ( subscription ) ) ; reporter . run ( ) ; System . out . println ( "Shutting down..." ) ; future . get ( ) ; } executor . shutdown ( ) ; if ( ! executor . awaitTermination ( 5 , TimeUnit . SECONDS ) ) { System . out . println ( "Warning: not all tasks completed promptly" ) ; } CloseHelper . quietClose ( driver ) ; } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . Publication ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . agrona . CloseHelper ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; import java . util . concurrent . TimeUnit ; public class BasicPublisher { private static final int STREAM_ID = SampleConfiguration . STREAM_ID ; private static final String CHANNEL = SampleConfiguration . CHANNEL ; private static final long NUMBER_OF_MESSAGES = SampleConfiguration . NUMBER_OF_MESSAGES ; private static final long LINGER_TIMEOUT_MS = SampleConfiguration . LINGER_TIMEOUT_MS ; private static final boolean EMBEDDED_MEDIA_DRIVER = SampleConfiguration . EMBEDDED_MEDIA_DRIVER ; private static final UnsafeBuffer BUFFER = new UnsafeBuffer ( ByteBuffer . allocateDirect ( 256 ) ) ; public static void main ( final String [ ] args ) throws Exception { System . out . println ( "Publishing to " + CHANNEL + " on stream Id " + STREAM_ID ) ; final MediaDriver driver = EMBEDDED_MEDIA_DRIVER ? MediaDriver . launchEmbedded ( ) : null ; final Aeron . Context ctx = new Aeron . Context ( ) ; if ( EMBEDDED_MEDIA_DRIVER ) { ctx . dirName ( driver . contextDirName ( ) ) ; } try ( final Aeron aeron = Aeron . connect ( ctx ) ; final Publication publication = aeron . addPublication ( CHANNEL , STREAM_ID ) ) { for ( int i = 0 ; i < NUMBER_OF_MESSAGES ; i ++ ) { final String message = "Hello World! " + i ; BUFFER . putBytes ( 0 , message . getBytes ( ) ) ; System . out . print ( "offering " + i + "/" + NUMBER_OF_MESSAGES ) ; final long result = publication . offer ( BUFFER , 0 , message . getBytes ( ) . length ) ; if ( result < 0L ) { if ( result == Publication . BACK_PRESSURED ) { System . out . println ( "Offer failed due to back pressure" ) ; } else if ( result == Publication . NOT_CONNECTED ) { System . out . println ( "Offer failed because publisher is not yet connected to subscriber" ) ; } else { System . out . println ( "Offer failed due to unknown reason" ) ; } } else { System . out . println ( "yay!" ) ; } Thread . sleep ( TimeUnit . SECONDS . toMillis ( 1 ) ) ; } System . out . println ( "Done sending." ) ; if ( 0 < LINGER_TIMEOUT_MS ) { System . out . println ( "Lingering for " + LINGER_TIMEOUT_MS + " milliseconds..." ) ; Thread . sleep ( LINGER_TIMEOUT_MS ) ; } } CloseHelper . quietClose ( driver ) ; } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . Publication ; import uk . co . real_logic . aeron . driver . RateReporter ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . agrona . CloseHelper ; import uk . co . real_logic . agrona . concurrent . BusySpinIdleStrategy ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . console . ContinueBarrier ; import java . nio . ByteBuffer ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadLocalRandom ; import java . util . concurrent . TimeUnit ; import java . util . function . IntSupplier ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class StreamingPublisher { private static final int STREAM_ID = SampleConfiguration . STREAM_ID ; private static final String CHANNEL = SampleConfiguration . CHANNEL ; private static final int MESSAGE_LENGTH = SampleConfiguration . MESSAGE_LENGTH ; private static final long NUMBER_OF_MESSAGES = SampleConfiguration . NUMBER_OF_MESSAGES ; private static final long LINGER_TIMEOUT_MS = SampleConfiguration . LINGER_TIMEOUT_MS ; private static final boolean EMBEDDED_MEDIA_DRIVER = SampleConfiguration . EMBEDDED_MEDIA_DRIVER ; private static final boolean RANDOM_MESSAGE_LENGTH = SampleConfiguration . RANDOM_MESSAGE_LENGTH ; private static final UnsafeBuffer ATOMIC_BUFFER = new UnsafeBuffer ( ByteBuffer . allocateDirect ( MESSAGE_LENGTH ) ) ; private static final IdleStrategy OFFER_IDLE_STRATEGY = new BusySpinIdleStrategy ( ) ; private static final IntSupplier LENGTH_GENERATOR = composeLengthGenerator ( RANDOM_MESSAGE_LENGTH , MESSAGE_LENGTH ) ; private static volatile boolean printingActive = true ; public static void main ( final String [ ] args ) throws Exception { if ( MESSAGE_LENGTH < SIZE_OF_LONG ) { throw new IllegalArgumentException ( String . format ( "Message length must be at least %d bytes" , SIZE_OF_LONG ) ) ; } final MediaDriver driver = EMBEDDED_MEDIA_DRIVER ? MediaDriver . launchEmbedded ( ) : null ; final Aeron . Context context = new Aeron . Context ( ) ; if ( EMBEDDED_MEDIA_DRIVER ) { context . dirName ( driver . contextDirName ( ) ) ; } final RateReporter reporter = new RateReporter ( TimeUnit . SECONDS . toNanos ( 1 ) , StreamingPublisher : : printRate ) ; final ExecutorService executor = Executors . newFixedThreadPool ( 1 ) ; executor . execute ( reporter ) ; try ( final Aeron aeron = Aeron . connect ( context ) ; final Publication publication = aeron . addPublication ( CHANNEL , STREAM_ID ) ) { final ContinueBarrier barrier = new ContinueBarrier ( "Execute again?" ) ; do { printingActive = true ; System . out . format ( "\nStreaming %,d messages of%s size %d bytes to %s on stream Id %d\n" , NUMBER_OF_MESSAGES , ( RANDOM_MESSAGE_LENGTH ) ? " random" : "" , MESSAGE_LENGTH , CHANNEL , STREAM_ID ) ; for ( long i = 0 ; i < NUMBER_OF_MESSAGES ; i ++ ) { final int length = LENGTH_GENERATOR . getAsInt ( ) ; ATOMIC_BUFFER . putLong ( 0 , i ) ; while ( publication . offer ( ATOMIC_BUFFER , 0 , length ) < 0L ) { OFFER_IDLE_STRATEGY . idle ( 0 ) ; } reporter . onMessage ( 1 , length ) ; } System . out . println ( "Done streaming." ) ; if ( 0 < LINGER_TIMEOUT_MS ) { System . out . println ( "Lingering for " + LINGER_TIMEOUT_MS + " milliseconds..." ) ; Thread . sleep ( LINGER_TIMEOUT_MS ) ; } printingActive = false ; } while ( barrier . await ( ) ) ; } reporter . halt ( ) ; executor . shutdown ( ) ; CloseHelper . quietClose ( driver ) ; } public static void printRate ( final double messagesPerSec , final double bytesPerSec , final long totalFragments , final long totalBytes ) { if ( printingActive ) { System . out . format ( "%.02g msgs/sec, %.02g bytes/sec, totals %d messages %d MB\n" , messagesPerSec , bytesPerSec , totalFragments , totalBytes / ( 1024 * 1024 ) ) ; } } private static IntSupplier composeLengthGenerator ( final boolean random , final int max ) { if ( random ) { return ( ) - > ThreadLocalRandom . current ( ) . nextInt ( SIZE_OF_LONG , max ) ; } else { return ( ) - > max ; } } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . Subscription ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . agrona . concurrent . BackoffIdleStrategy ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; public class SimpleSubscriber { public static void main ( final String [ ] args ) throws Exception { final int fragmentLimitCount = 10 ; final String channel = "udp://localhost:40123" ; final int streamId = 10 ; System . out . println ( "Subscribing to " + channel + " on stream Id " + streamId ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; final FragmentHandler fragmentHandler = ( buffer , offset , length , header ) - > { final byte [ ] data = new byte [ length ] ; buffer . getBytes ( offset , data ) ; System . out . println ( String . format ( "Received message (%s) to stream %d from session %x term id %x term offset %d (%d@%d)" , new String ( data ) , streamId , header . sessionId ( ) , header . termId ( ) , header . termOffset ( ) , length , offset ) ) ; running . set ( false ) ; } ; final Aeron . Context ctx = new Aeron . Context ( ) ; try ( final Aeron aeron = Aeron . connect ( ctx ) ; final Subscription subscription = aeron . addSubscription ( channel , streamId ) ) { final IdleStrategy idleStrategy = new BackoffIdleStrategy ( 100 , 10 , TimeUnit . MICROSECONDS . toNanos ( 1 ) , TimeUnit . MICROSECONDS . toNanos ( 100 ) ) ; while ( running . get ( ) ) { final int fragmentsRead = subscription . poll ( fragmentHandler , fragmentLimitCount ) ; idleStrategy . idle ( fragmentsRead ) ; } System . out . println ( "Shutting down..." ) ; } } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . Publication ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; public class SimplePublisher { public static void main ( final String [ ] args ) throws Exception { final UnsafeBuffer buffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( 512 ) ) ; final String channel = "udp://localhost:40123" ; final int streamId = 10 ; System . out . println ( "Publishing to " + channel + " on stream Id " + streamId ) ; final Aeron . Context ctx = new Aeron . Context ( ) ; try ( final Aeron aeron = Aeron . connect ( ctx ) ; final Publication publication = aeron . addPublication ( channel , streamId ) ) { final String message = "Hello World! " ; buffer . putBytes ( 0 , message . getBytes ( ) ) ; final long result = publication . offer ( buffer , 0 , message . getBytes ( ) . length ) ; if ( result < 0L ) { if ( result == Publication . BACK_PRESSURED ) { System . out . println ( " Offer failed due to back pressure" ) ; } else if ( result == Publication . NOT_CONNECTED ) { System . out . println ( " Offer failed because publisher is not yet connected to subscriber" ) ; } else { System . out . println ( " Offer failed due to unknown reason" ) ; } } else { System . out . println ( " yay !!" ) ; } System . out . println ( "Done sending." ) ; } finally { ctx . close ( ) ; } } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . FragmentAssemblyAdapter ; import uk . co . real_logic . aeron . Subscription ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . agrona . concurrent . BackoffIdleStrategy ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; public class MultipleSubscribersWithFragmentAssembly { private static final String CHANNEL = SampleConfiguration . CHANNEL ; private static final int STREAM_ID_1 = SampleConfiguration . STREAM_ID ; private static final int STREAM_ID_2 = SampleConfiguration . STREAM_ID + 1 ; private static final int FRAGMENT_COUNT_LIMIT = SampleConfiguration . FRAGMENT_COUNT_LIMIT ; public static void main ( final String [ ] args ) throws Exception { System . out . format ( "Subscribing to %s on stream ID %d and stream ID %d%n" , CHANNEL , STREAM_ID_1 , STREAM_ID_2 ) ; final Aeron . Context ctx = new Aeron . Context ( ) . newConnectionHandler ( MultipleSubscribersWithFragmentAssembly : : eventNewConnection ) . inactiveConnectionHandler ( MultipleSubscribersWithFragmentAssembly : : eventInactiveConnection ) ; final FragmentAssemblyAdapter dataHandler1 = new FragmentAssemblyAdapter ( reassembledStringMessage1 ( STREAM_ID_1 ) ) ; final FragmentAssemblyAdapter dataHandler2 = new FragmentAssemblyAdapter ( reassembledStringMessage2 ( STREAM_ID_2 ) ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; try ( final Aeron aeron = Aeron . connect ( ctx ) ; final Subscription subscription1 = aeron . addSubscription ( CHANNEL , STREAM_ID_1 ) ; final Subscription subscription2 = aeron . addSubscription ( CHANNEL , STREAM_ID_2 ) ) { final IdleStrategy idleStrategy = new BackoffIdleStrategy ( 100 , 10 , TimeUnit . MICROSECONDS . toNanos ( 1 ) , TimeUnit . MICROSECONDS . toNanos ( 100 ) ) ; while ( running . get ( ) ) { final int fragmentsRead1 = subscription1 . poll ( dataHandler1 , FRAGMENT_COUNT_LIMIT ) ; final int fragmentsRead2 = subscription2 . poll ( dataHandler2 , FRAGMENT_COUNT_LIMIT ) ; idleStrategy . idle ( fragmentsRead1 + fragmentsRead2 ) ; } System . out . println ( "Shutting down..." ) ; } } public static void eventNewConnection ( final String channel , final int streamId , final int sessionId , final long position , final String sourceIdentity ) { System . out . format ( "new connection on %s streamId %x sessionId %x from %s%n" , channel , streamId , sessionId , sourceIdentity ) ; } public static void eventInactiveConnection ( final String channel , final int streamId , final int sessionId , final long position ) { System . out . format ( "inactive connection on %s streamId %d sessionId %x%n" , channel , streamId , sessionId ) ; } public static FragmentHandler reassembledStringMessage1 ( final int streamId ) throws Exception { return ( buffer , offset , length , header ) - > { final byte [ ] data = new byte [ length ] ; buffer . getBytes ( offset , data ) ; System . out . format ( "message to stream %d from session %x term id %x term offset %d (%d@%d)%n" , streamId , header . sessionId ( ) , header . termId ( ) , header . termOffset ( ) , length , offset ) ; if ( length != 10000 ) { System . out . format ( "Received message was not assembled properly; received length was %d, but was expecting 10000%n" , length ) ; } } ; } public static FragmentHandler reassembledStringMessage2 ( final int streamId ) throws Exception { return ( buffer , offset , length , header ) - > { final byte [ ] data = new byte [ length ] ; buffer . getBytes ( offset , data ) ; System . out . format ( "message to stream %d from session %x term id %x term offset %d (%d@%d)%n" , streamId , header . sessionId ( ) , header . termId ( ) , header . termOffset ( ) , length , offset ) ; if ( length != 9000 ) { System . out . format ( "Received message was not assembled properly; received length was %d, but was expecting 9000%n" , length ) ; } } ; } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . FragmentAssemblyAdapter ; import uk . co . real_logic . aeron . Publication ; import uk . co . real_logic . aeron . Subscription ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . agrona . CloseHelper ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . concurrent . BusySpinIdleStrategy ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import uk . co . real_logic . agrona . concurrent . NoOpIdleStrategy ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . util . concurrent . atomic . AtomicBoolean ; public class Pong { private static final int PING_STREAM_ID = SampleConfiguration . PING_STREAM_ID ; private static final int PONG_STREAM_ID = SampleConfiguration . PONG_STREAM_ID ; private static final String PING_CHANNEL = SampleConfiguration . PING_CHANNEL ; private static final String PONG_CHANNEL = SampleConfiguration . PONG_CHANNEL ; private static final int FRAME_COUNT_LIMIT = SampleConfiguration . FRAGMENT_COUNT_LIMIT ; private static final boolean EMBEDDED_MEDIA_DRIVER = SampleConfiguration . EMBEDDED_MEDIA_DRIVER ; private static final BusySpinIdleStrategy PING_HANDLER_IDLE_STRATEGY = new BusySpinIdleStrategy ( ) ; public static void main ( final String [ ] args ) throws Exception { final MediaDriver driver = EMBEDDED_MEDIA_DRIVER ? MediaDriver . launchEmbedded ( ) : null ; final Aeron . Context ctx = new Aeron . Context ( ) ; if ( EMBEDDED_MEDIA_DRIVER ) { ctx . dirName ( driver . contextDirName ( ) ) ; } final IdleStrategy idleStrategy = new NoOpIdleStrategy ( ) ; System . out . println ( "Subscribing Ping at " + PING_CHANNEL + " on stream Id " + PING_STREAM_ID ) ; System . out . println ( "Publishing Pong at " + PONG_CHANNEL + " on stream Id " + PONG_STREAM_ID ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; try ( final Aeron aeron = Aeron . connect ( ctx ) ; final Publication pongPublication = aeron . addPublication ( PONG_CHANNEL , PONG_STREAM_ID ) ; final Subscription pingSubscription = aeron . addSubscription ( PING_CHANNEL , PING_STREAM_ID ) ) { final FragmentAssemblyAdapter dataHandler = new FragmentAssemblyAdapter ( ( buffer , offset , length , header ) - > pingHandler ( pongPublication , buffer , offset , length ) ) ; while ( running . get ( ) ) { final int fragmentsRead = pingSubscription . poll ( dataHandler , FRAME_COUNT_LIMIT ) ; idleStrategy . idle ( fragmentsRead ) ; } System . out . println ( "Shutting down..." ) ; } CloseHelper . quietClose ( driver ) ; } private static void pingHandler ( final Publication pongPublication , final DirectBuffer buffer , final int offset , final int length ) { while ( pongPublication . offer ( buffer , offset , length ) < 0L ) { PING_HANDLER_IDLE_STRATEGY . idle ( 0 ) ; } } }
package uk . co . real_logic . aeron . samples ; import java . util . concurrent . TimeUnit ; public class SampleConfiguration { public static final String CHANNEL_PROP = "aeron.sample.channel" ; public static final String STREAM_ID_PROP = "aeron.sample.streamId" ; public static final String PING_CHANNEL_PROP = "aeron.sample.ping.channel" ; public static final String PONG_CHANNEL_PROP = "aeron.sample.pong.channel" ; public static final String PING_STREAM_ID_PROP = "aeron.sample.ping.streamId" ; public static final String PONG_STREAM_ID_PROP = "aeron.sample.pong.streamId" ; public static final String WARMUP_NUMBER_OF_MESSAGES_PROP = "aeron.sample.warmup.messages" ; public static final String WARMUP_NUMBER_OF_ITERATIONS_PROP = "aeron.sample.warmup.iterations" ; public static final String RANDOM_MESSAGE_LENGTH_PROP = "aeron.sample.randomMessageLength" ; public static final String FRAME_COUNT_LIMIT_PROP = "aeron.sample.frameCountLimit" ; public static final String MESSAGE_LENGTH_PROP = "aeron.sample.messageLength" ; public static final String NUMBER_OF_MESSAGES_PROP = "aeron.sample.messages" ; public static final String LINGER_TIMEOUT_MS_PROP = "aeron.sample.lingerTimeout" ; public static final String EMBEDDED_MEDIA_DRIVER_PROP = "aeron.sample.embeddedMediaDriver" ; public static final String CHANNEL ; public static final String PING_CHANNEL ; public static final String PONG_CHANNEL ; public static final int STREAM_ID ; public static final int PING_STREAM_ID ; public static final int PONG_STREAM_ID ; public static final int FRAGMENT_COUNT_LIMIT ; public static final int MESSAGE_LENGTH ; public static final int NUMBER_OF_MESSAGES ; public static final int WARMUP_NUMBER_OF_MESSAGES ; public static final int WARMUP_NUMBER_OF_ITERATIONS ; public static final long LINGER_TIMEOUT_MS ; public static final boolean EMBEDDED_MEDIA_DRIVER ; public static final boolean RANDOM_MESSAGE_LENGTH ; static { CHANNEL = System . getProperty ( CHANNEL_PROP , "udp://localhost:40123" ) ; STREAM_ID = Integer . getInteger ( STREAM_ID_PROP , 10 ) ; PING_CHANNEL = System . getProperty ( PING_CHANNEL_PROP , "udp://localhost:40123" ) ; PONG_CHANNEL = System . getProperty ( PONG_CHANNEL_PROP , "udp://localhost:40124" ) ; PING_STREAM_ID = Integer . getInteger ( PING_STREAM_ID_PROP , 10 ) ; PONG_STREAM_ID = Integer . getInteger ( PONG_STREAM_ID_PROP , 10 ) ; FRAGMENT_COUNT_LIMIT = Integer . getInteger ( FRAME_COUNT_LIMIT_PROP , 10 ) ; MESSAGE_LENGTH = Integer . getInteger ( MESSAGE_LENGTH_PROP , 256 ) ; RANDOM_MESSAGE_LENGTH = Boolean . getBoolean ( RANDOM_MESSAGE_LENGTH_PROP ) ; NUMBER_OF_MESSAGES = Integer . getInteger ( NUMBER_OF_MESSAGES_PROP , 1_000_000 ) ; WARMUP_NUMBER_OF_MESSAGES = Integer . getInteger ( WARMUP_NUMBER_OF_MESSAGES_PROP , 10_000 ) ; WARMUP_NUMBER_OF_ITERATIONS = Integer . getInteger ( WARMUP_NUMBER_OF_ITERATIONS_PROP , 5 ) ; LINGER_TIMEOUT_MS = Long . getLong ( LINGER_TIMEOUT_MS_PROP , TimeUnit . SECONDS . toMillis ( 5 ) ) ; EMBEDDED_MEDIA_DRIVER = Boolean . getBoolean ( EMBEDDED_MEDIA_DRIVER_PROP ) ; } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . Subscription ; import uk . co . real_logic . aeron . driver . RateReporter ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . protocol . HeaderFlyweight ; import uk . co . real_logic . agrona . LangUtil ; import uk . co . real_logic . agrona . concurrent . BusySpinIdleStrategy ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . function . Consumer ; public class SamplesUtil { public static Consumer < Subscription > subscriberLoop ( final FragmentHandler fragmentHandler , final int limit , final AtomicBoolean running ) { final IdleStrategy idleStrategy = new BusySpinIdleStrategy ( ) ; return subscriberLoop ( fragmentHandler , limit , running , idleStrategy ) ; } public static Consumer < Subscription > subscriberLoop ( final FragmentHandler fragmentHandler , final int limit , final AtomicBoolean running , final IdleStrategy idleStrategy ) { return ( subscription ) - > { try { while ( running . get ( ) ) { final int fragmentsRead = subscription . poll ( fragmentHandler , limit ) ; idleStrategy . idle ( fragmentsRead ) ; } } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } } ; } public static FragmentHandler printStringMessage ( final int streamId ) { return ( buffer , offset , length , header ) - > { final byte [ ] data = new byte [ length ] ; buffer . getBytes ( offset , data ) ; System . out . println ( String . format ( "Message to stream %d from session %d (%d@%d) <<%s>>" , streamId , header . sessionId ( ) , length , offset , new String ( data ) ) ) ; } ; } public static FragmentHandler rateReporterHandler ( final RateReporter reporter ) { return ( buffer , offset , length , header ) - > reporter . onMessage ( 1 , length ) ; } public static void printError ( final String channel , final int streamId , final int sessionId , final String message , final HeaderFlyweight cause ) { System . out . println ( message ) ; } public static void printRate ( final double messagesPerSec , final double bytesPerSec , final long totalMessages , final long totalBytes ) { System . out . println ( String . format ( "%.02g msgs/sec, %.02g bytes/sec, totals %d messages %d MB" , messagesPerSec , bytesPerSec , totalMessages , totalBytes / ( 1024 * 1024 ) ) ) ; } public static void printNewConnection ( final String channel , final int streamId , final int sessionId , final long joiningPosition , final String sourceIdentity ) { System . out . println ( String . format ( "New connection on %s streamId=%d sessionId=%d at position=%d from %s" , channel , streamId , sessionId , joiningPosition , sourceIdentity ) ) ; } public static void printInactiveConnection ( final String channel , final int streamId , final int sessionId , final long position ) { System . out . println ( String . format ( "Inactive connection on %s streamId=%d sessionId=%d at position=%d" , channel , streamId , sessionId , position ) ) ; } }
package uk . co . real_logic . aeron . tools ; public class StatsVmStatOutput implements StatsOutput { private final String titles [ ] = { "Bytes" , "Failed Offers" , "NAKs" , "SMs" , "Heartbeats" , "RX" , "Flow Control" , "Invalid" , "Driver" , "Short Sends" , "Keep" , "FC Limits" } ; private final String subTitles [ ] = { "In/Out" , "RP/SP/DCP" , "In/Out" , "In/Out" , "In/Out" , "Sent" , "Under/Over" , "Packets" , "Exceptions" , "DP/StatM/SM/NM" , "Alives" , "Applied" } ; private final String formats [ ] = { "%1$-18s" , "%1$-18s" , "%1$-10s" , "%1$-14s" , "%1$-12s" , "%1$-6s" , "%1$-14s" , "%1$-9s" , "%1$-12s" , "%1$-18s" , "%1$-7s" , "%1$-7s" } ; private int iterations ; public StatsVmStatOutput ( ) { iterations = 0 ; } public void format ( final String [ ] keys , final long [ ] vals ) throws Exception { if ( iterations % 20 == 0 ) { for ( int i = 0 ; i < titles . length ; i ++ ) { System . out . format ( formats [ i ] , titles [ i ] ) ; } System . out . println ( ) ; for ( int i = 0 ; i < titles . length ; i ++ ) { System . out . format ( formats [ i ] , subTitles [ i ] ) ; } System . out . println ( ) ; } System . out . format ( formats [ 0 ] , humanReadableByteCount ( vals [ 1 ] , false ) + "/" + humanReadableByteCount ( vals [ 0 ] , false ) ) ; System . out . format ( formats [ 1 ] , humanReadableCount ( vals [ 2 ] , true ) + "/" + humanReadableCount ( vals [ 3 ] , true ) + "/" + humanReadableCount ( vals [ 4 ] , true ) ) ; System . out . format ( formats [ 2 ] , humanReadableCount ( vals [ 6 ] , true ) + "/" + humanReadableCount ( vals [ 5 ] , true ) ) ; System . out . format ( formats [ 3 ] , humanReadableCount ( vals [ 8 ] , true ) + "/" + humanReadableCount ( vals [ 7 ] , true ) ) ; System . out . format ( formats [ 4 ] , humanReadableCount ( vals [ 9 ] , true ) + "/" + humanReadableCount ( vals [ 10 ] , true ) ) ; System . out . format ( formats [ 5 ] , humanReadableCount ( vals [ 11 ] , true ) ) ; System . out . format ( formats [ 6 ] , humanReadableCount ( vals [ 12 ] , true ) + "/" + humanReadableCount ( vals [ 13 ] , true ) ) ; System . out . format ( formats [ 7 ] , humanReadableCount ( vals [ 14 ] , true ) ) ; System . out . format ( formats [ 8 ] , humanReadableCount ( vals [ 15 ] , true ) ) ; System . out . format ( formats [ 9 ] , humanReadableCount ( vals [ 16 ] , true ) + "/" + humanReadableCount ( vals [ 17 ] , true ) + "/" + humanReadableCount ( vals [ 18 ] , true ) + "/" + humanReadableCount ( vals [ 19 ] , true ) ) ; System . out . format ( formats [ 10 ] , humanReadableCount ( vals [ 20 ] , true ) ) ; System . out . format ( formats [ 11 ] , humanReadableCount ( vals [ 21 ] , true ) ) ; System . out . println ( ) ; iterations ++ ; } public void close ( ) throws Exception { } private String humanReadableByteCount ( final long bytes , final boolean si ) { final int unit = si ? 1000 : 1024 ; if ( bytes < unit ) { return bytes + "B" ; } final int exp = ( int ) ( Math . log ( bytes ) / Math . log ( unit ) ) ; final String pre = ( si ? "kMGTPE" : "KMGTPE" ) . charAt ( exp - 1 ) + ( si ? "" : "i" ) ; return String . format ( "%.1f%sB" , bytes / Math . pow ( unit , exp ) , pre ) ; } private String humanReadableCount ( final long val , final boolean si ) { final int unit = si ? 1000 : 1024 ; if ( val < unit ) { return val + "" ; } final int exp = ( int ) ( Math . log ( val ) / Math . log ( unit ) ) ; final String pre = ( si ? "kMGTPE" : "KMGTPE" ) . charAt ( exp - 1 ) + ( si ? "" : "i" ) ; return String . format ( "%.1f%s" , val / Math . pow ( unit , exp ) , pre ) ; } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . aeron . driver . ThreadingMode ; import uk . co . real_logic . agrona . concurrent . BackoffIdleStrategy ; import uk . co . real_logic . agrona . concurrent . NoOpIdleStrategy ; import uk . co . real_logic . agrona . concurrent . SigIntBarrier ; public class LowLatencyMediaDriver { public static void main ( final String [ ] args ) throws Exception { final MediaDriver . Context ctx = new MediaDriver . Context ( ) . threadingMode ( ThreadingMode . DEDICATED ) . conductorIdleStrategy ( new BackoffIdleStrategy ( 1 , 1 , 1 , 1 ) ) . receiverIdleStrategy ( new NoOpIdleStrategy ( ) ) . senderIdleStrategy ( new NoOpIdleStrategy ( ) ) ; try ( final MediaDriver ignored = MediaDriver . launch ( ctx ) ) { new SigIntBarrier ( ) . await ( ) ; System . out . println ( "Shutdown Driver..." ) ; } } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . LogBuffers ; import uk . co . real_logic . aeron . logbuffer . FrameDescriptor ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . io . PrintStream ; import java . util . Date ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . * ; import static uk . co . real_logic . aeron . protocol . DataHeaderFlyweight . HEADER_LENGTH ; public class LogInspector { private static final char [ ] HEX_ARRAY = "0123456789ABCDEF" . toCharArray ( ) ; private static final String DATA_FORMAT = System . getProperty ( "aeron.log.inspector.data.format" , "hex" ) . toLowerCase ( ) ; private static final boolean SKIP_DEFAULT_HEADERS = Boolean . getBoolean ( "aeron.log.inspector.skipDefaultHeaders" ) ; public static void main ( final String [ ] args ) throws Exception { final PrintStream out = System . out ; if ( args . length < 1 ) { out . println ( "Usage: LogInspector <logFileName> [message dump limit]" ) ; return ; } final String logFileName = args [ 0 ] ; final int messageDumpLimit = args . length >= 2 ? Integer . parseInt ( args [ 1 ] ) : Integer . MAX_VALUE ; try ( final LogBuffers logBuffers = new LogBuffers ( logFileName ) ) { out . println ( "======================================================================" ) ; out . format ( "%s Inspection dump for %s\n" , new Date ( ) , logFileName ) ; out . println ( "======================================================================" ) ; final UnsafeBuffer [ ] atomicBuffers = logBuffers . atomicBuffers ( ) ; final DataHeaderFlyweight dataHeaderFlyweight = new DataHeaderFlyweight ( ) ; final int termLength = atomicBuffers [ 0 ] . capacity ( ) ; final UnsafeBuffer logMetaDataBuffer = atomicBuffers [ PARTITION_COUNT * 2 ] ; out . format ( "Initial term id: %d\n" , initialTermId ( logMetaDataBuffer ) ) ; out . format ( " Active term id: %d\n" , activeTermId ( logMetaDataBuffer ) ) ; out . format ( " Active index: %d\n" , indexByTerm ( initialTermId ( logMetaDataBuffer ) , activeTermId ( logMetaDataBuffer ) ) ) ; out . format ( " Term length: %d\n" , termLength ) ; out . format ( " MTU length: %d\n\n" , mtuLength ( logMetaDataBuffer ) ) ; if ( ! SKIP_DEFAULT_HEADERS ) { final UnsafeBuffer [ ] defaultFrameHeaders = defaultFrameHeaders ( logMetaDataBuffer ) ; for ( int i = 0 ; i < defaultFrameHeaders . length ; i ++ ) { dataHeaderFlyweight . wrap ( defaultFrameHeaders [ i ] ) ; out . format ( "Index %d default %s\n" , i , dataHeaderFlyweight ) ; } } out . println ( ) ; for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { final UnsafeBuffer metaDataBuffer = atomicBuffers [ i + PARTITION_COUNT ] ; out . format ( "Index %d Term Meta Data status=%s tail=%d\n" , i , termStatus ( metaDataBuffer ) , metaDataBuffer . getInt ( TERM_TAIL_COUNTER_OFFSET ) ) ; } for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { out . println ( "\n======================================================================" ) ; out . format ( "Index %d Term Data\n\n" , i ) ; final UnsafeBuffer termBuffer = logBuffers . atomicBuffers ( ) [ i ] ; dataHeaderFlyweight . wrap ( termBuffer ) ; int offset = 0 ; do { dataHeaderFlyweight . offset ( offset ) ; out . println ( dataHeaderFlyweight . toString ( ) ) ; final int frameLength = dataHeaderFlyweight . frameLength ( ) ; if ( frameLength < DataHeaderFlyweight . HEADER_LENGTH ) { try { final int limit = Math . min ( termLength - ( offset + HEADER_LENGTH ) , messageDumpLimit ) ; out . println ( formatBytes ( termBuffer , offset + HEADER_LENGTH , limit ) ) ; } catch ( final Exception ex ) { System . out . printf ( "frameLength=%d offset=%d\n" , frameLength , offset ) ; ex . printStackTrace ( ) ; } break ; } final int limit = Math . min ( frameLength - HEADER_LENGTH , messageDumpLimit ) ; out . println ( formatBytes ( termBuffer , offset + HEADER_LENGTH , limit ) ) ; offset += BitUtil . align ( frameLength , FrameDescriptor . FRAME_ALIGNMENT ) ; } while ( offset < termLength ) ; } } } public static char [ ] formatBytes ( final DirectBuffer buffer , final int offset , final int length ) { switch ( DATA_FORMAT ) { case "ascii" : return bytesToAscii ( buffer , offset , length ) ; default : return bytesToHex ( buffer , offset , length ) ; } } private static char [ ] bytesToAscii ( final DirectBuffer buffer , final int offset , final int length ) { final char [ ] chars = new char [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { int b = buffer . getByte ( offset + i ) & 0xFF ; if ( b < 0 ) { b = 0 ; } chars [ i ] = ( char ) b ; } return chars ; } public static char [ ] bytesToHex ( final DirectBuffer buffer , final int offset , final int length ) { final char [ ] chars = new char [ length * 2 ] ; for ( int i = 0 ; i < length ; i ++ ) { final int b = buffer . getByte ( offset + i ) & 0xFF ; chars [ i * 2 ] = HEX_ARRAY [ b > > > 4 ] ; chars [ i * 2 + 1 ] = HEX_ARRAY [ b & 0x0F ] ; } return chars ; } private static String termStatus ( final UnsafeBuffer metaDataBuffer ) { final int status = metaDataBuffer . getInt ( TERM_STATUS_OFFSET ) ; switch ( status ) { case CLEAN : return "CLEAN" ; case NEEDS_CLEANING : return "NEEDS_CLEANING" ; default : return status + " <UNKNOWN>" ; } } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . CncFileDescriptor ; import uk . co . real_logic . aeron . CommonContext ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . IoUtil ; import uk . co . real_logic . agrona . concurrent . AtomicBuffer ; import uk . co . real_logic . agrona . concurrent . CountersManager ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . io . File ; import java . nio . MappedByteBuffer ; import java . util . Date ; import java . util . concurrent . atomic . AtomicBoolean ; public class AeronStat { public static void main ( final String [ ] args ) throws Exception { final File cncFile = CommonContext . newDefaultCncFile ( ) ; System . out . println ( "Command `n Control file " + cncFile ) ; final MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , "cnc" ) ; final DirectBuffer metaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; final int cncVersion = metaDataBuffer . getInt ( CncFileDescriptor . cncVersionOffset ( 0 ) ) ; if ( CncFileDescriptor . CNC_VERSION != cncVersion ) { throw new IllegalStateException ( "CNC version not supported: version=" + cncVersion ) ; } final AtomicBuffer labelsBuffer = CncFileDescriptor . createCounterLabelsBuffer ( cncByteBuffer , metaDataBuffer ) ; final AtomicBuffer valuesBuffer = CncFileDescriptor . createCounterValuesBuffer ( cncByteBuffer , metaDataBuffer ) ; final CountersManager countersManager = new CountersManager ( labelsBuffer , valuesBuffer ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; while ( running . get ( ) ) { System . out . print ( "\033[H\033[2J" ) ; System . out . format ( "%1$tH:%1$tM:%1$tS - Aeron Stat\n" , new Date ( ) ) ; System . out . println ( "=========================" ) ; countersManager . forEach ( ( id , label ) - > { final int offset = CountersManager . counterOffset ( id ) ; final long value = valuesBuffer . getLongVolatile ( offset ) ; System . out . format ( "%3d: %,20d - %s\n" , id , value , label ) ; } ) ; Thread . sleep ( 1000 ) ; } } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . Publication ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; public class MultiplePublishersWithFragmentation { private static final int STREAM_ID_1 = SampleConfiguration . STREAM_ID ; private static final int STREAM_ID_2 = SampleConfiguration . STREAM_ID + 1 ; private static final String CHANNEL = SampleConfiguration . CHANNEL ; private static final UnsafeBuffer BUFFER_1 = new UnsafeBuffer ( ByteBuffer . allocateDirect ( 10000 ) ) ; private static final UnsafeBuffer BUFFER_2 = new UnsafeBuffer ( ByteBuffer . allocateDirect ( 9000 ) ) ; public static void main ( final String [ ] args ) throws Exception { System . out . println ( "Publishing to " + CHANNEL + " on stream Id " + STREAM_ID_1 + " and stream Id " + STREAM_ID_2 ) ; final Aeron . Context ctx = new Aeron . Context ( ) ; try ( final Aeron aeron = Aeron . connect ( ctx ) ; final Publication publication1 = aeron . addPublication ( CHANNEL , STREAM_ID_1 ) ; final Publication publication2 = aeron . addPublication ( CHANNEL , STREAM_ID_2 ) ) { int j = 1 ; int k = 1 ; final String message1 = "Hello World! " + j ; BUFFER_1 . putBytes ( 0 , message1 . getBytes ( ) ) ; final String message2 = "Hello World! " + k ; BUFFER_2 . putBytes ( 0 , message2 . getBytes ( ) ) ; while ( j <= 5000 || k <= 5000 ) { boolean offerStatus1 = false ; boolean offerStatus2 = false ; long result1 ; long result2 ; while ( ! ( offerStatus1 || offerStatus2 ) ) { if ( j <= 5000 ) { result1 = publication1 . offer ( BUFFER_1 , 0 , BUFFER_1 . capacity ( ) ) ; if ( result1 < 0L ) { if ( result1 == Publication . BACK_PRESSURED ) { System . out . println ( " Offer failed due to back pressure for stream Id " + STREAM_ID_1 ) ; } else if ( result1 == Publication . NOT_CONNECTED ) { System . out . println ( " Offer failed because publisher is not yet " + "connected to subscriber for stream Id " + STREAM_ID_1 ) ; } else { System . out . println ( " Offer failed due to unknown reason" ) ; } offerStatus1 = false ; } else { j ++ ; offerStatus1 = true ; System . out . println ( "Successfully sent data on stream " + STREAM_ID_1 + " and data length " + BUFFER_1 . capacity ( ) + " at offset " + result1 ) ; } } if ( k <= 5000 ) { result2 = publication2 . offer ( BUFFER_2 , 0 , BUFFER_2 . capacity ( ) ) ; if ( result2 < 0L ) { if ( result2 == Publication . BACK_PRESSURED ) { System . out . println ( " Offer failed because publisher is not yet " + "connected to subscriber for stream Id " + STREAM_ID_2 ) ; } else if ( result2 == Publication . NOT_CONNECTED ) { System . out . println ( "Offer failed - publisher is not yet connected to subscriber" + STREAM_ID_2 ) ; } else { System . out . println ( "Offer failed due to unknown reason" ) ; } offerStatus2 = false ; } else { k ++ ; offerStatus2 = true ; System . out . println ( "Successfully sent data on stream " + STREAM_ID_2 + " and data length " + BUFFER_2 . capacity ( ) + " at offset " + result2 ) ; } } } } System . out . println ( "Done sending total messages for stream Id " + STREAM_ID_1 + " = " + ( j - 1 ) + " and stream Id " + STREAM_ID_2 + " = " + ( k - 1 ) ) ; } } }
package uk . co . real_logic . aeron . samples ; import org . HdrHistogram . Histogram ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . FragmentAssemblyAdapter ; import uk . co . real_logic . aeron . Publication ; import uk . co . real_logic . aeron . Subscription ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . aeron . driver . ThreadingMode ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . concurrent . BusySpinIdleStrategy ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import uk . co . real_logic . agrona . concurrent . NoOpIdleStrategy ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . console . ContinueBarrier ; import java . nio . ByteBuffer ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; public class EmbeddedPingPong { private static final int PING_STREAM_ID = SampleConfiguration . PING_STREAM_ID ; private static final int PONG_STREAM_ID = SampleConfiguration . PONG_STREAM_ID ; private static final String PING_CHANNEL = SampleConfiguration . PING_CHANNEL ; private static final String PONG_CHANNEL = SampleConfiguration . PONG_CHANNEL ; private static final int NUMBER_OF_MESSAGES = SampleConfiguration . NUMBER_OF_MESSAGES ; private static final int WARMUP_NUMBER_OF_MESSAGES = SampleConfiguration . WARMUP_NUMBER_OF_MESSAGES ; private static final int WARMUP_NUMBER_OF_ITERATIONS = SampleConfiguration . WARMUP_NUMBER_OF_ITERATIONS ; private static final int MESSAGE_LENGTH = SampleConfiguration . MESSAGE_LENGTH ; private static final int FRAGMENT_COUNT_LIMIT = SampleConfiguration . FRAGMENT_COUNT_LIMIT ; private static final int FRAME_COUNT_LIMIT = SampleConfiguration . FRAGMENT_COUNT_LIMIT ; private static final UnsafeBuffer ATOMIC_BUFFER = new UnsafeBuffer ( ByteBuffer . allocateDirect ( MESSAGE_LENGTH ) ) ; private static final Histogram HISTOGRAM = new Histogram ( TimeUnit . SECONDS . toNanos ( 10 ) , 3 ) ; private static final CountDownLatch PONG_CONNECTION_LATCH = new CountDownLatch ( 1 ) ; private static final BusySpinIdleStrategy PING_HANDLER_IDLE_STRATEGY = new BusySpinIdleStrategy ( ) ; private static final AtomicBoolean RUNNING = new AtomicBoolean ( true ) ; public static void main ( final String [ ] args ) throws Exception { final MediaDriver . Context ctx = new MediaDriver . Context ( ) . threadingMode ( ThreadingMode . DEDICATED ) . conductorIdleStrategy ( new NoOpIdleStrategy ( ) ) . receiverIdleStrategy ( new NoOpIdleStrategy ( ) ) . senderIdleStrategy ( new NoOpIdleStrategy ( ) ) . dirsDeleteOnExit ( true ) ; try ( final MediaDriver ignored = MediaDriver . launchEmbedded ( ctx ) ) { final Thread pongThread = startPong ( ignored . contextDirName ( ) ) ; pongThread . start ( ) ; runPing ( ignored . contextDirName ( ) ) ; RUNNING . set ( false ) ; pongThread . join ( ) ; System . out . println ( "Shutdown Driver..." ) ; } } private static void runPing ( final String embeddedDirName ) throws InterruptedException { final Aeron . Context ctx = new Aeron . Context ( ) . newConnectionHandler ( EmbeddedPingPong : : newPongConnectionHandler ) ; ctx . dirName ( embeddedDirName ) ; System . out . println ( "Publishing Ping at " + PING_CHANNEL + " on stream Id " + PING_STREAM_ID ) ; System . out . println ( "Subscribing Pong at " + PONG_CHANNEL + " on stream Id " + PONG_STREAM_ID ) ; System . out . println ( "Message size of " + MESSAGE_LENGTH + " bytes" ) ; final FragmentAssemblyAdapter dataHandler = new FragmentAssemblyAdapter ( EmbeddedPingPong : : pongHandler ) ; try ( final Aeron aeron = Aeron . connect ( ctx ) ; final Publication pingPublication = aeron . addPublication ( PING_CHANNEL , PING_STREAM_ID ) ; final Subscription pongSubscription = aeron . addSubscription ( PONG_CHANNEL , PONG_STREAM_ID ) ) { System . out . println ( "Waiting for new connection from Pong..." ) ; PONG_CONNECTION_LATCH . await ( ) ; System . out . println ( "Warming up... " + WARMUP_NUMBER_OF_ITERATIONS + " iterations of " + WARMUP_NUMBER_OF_MESSAGES + " messages" ) ; for ( int i = 0 ; i < WARMUP_NUMBER_OF_ITERATIONS ; i ++ ) { sendPingAndReceivePong ( dataHandler , pingPublication , pongSubscription , WARMUP_NUMBER_OF_MESSAGES ) ; } final ContinueBarrier barrier = new ContinueBarrier ( "Execute again?" ) ; do { HISTOGRAM . reset ( ) ; System . out . println ( "Pinging " + NUMBER_OF_MESSAGES + " messages" ) ; sendPingAndReceivePong ( dataHandler , pingPublication , pongSubscription , NUMBER_OF_MESSAGES ) ; System . out . println ( "Histogram of RTT latencies in microseconds." ) ; HISTOGRAM . outputPercentileDistribution ( System . out , 1000.0 ) ; } while ( barrier . await ( ) ) ; } } private static Thread startPong ( final String embeddedDirName ) { return new Thread ( ) { public void run ( ) { System . out . println ( "Subscribing Ping at " + PING_CHANNEL + " on stream Id " + PING_STREAM_ID ) ; System . out . println ( "Publishing Pong at " + PONG_CHANNEL + " on stream Id " + PONG_STREAM_ID ) ; final Aeron . Context ctx = new Aeron . Context ( ) ; ctx . dirName ( embeddedDirName ) ; try ( final Aeron aeron = Aeron . connect ( ctx ) ; final Publication pongPublication = aeron . addPublication ( PONG_CHANNEL , PONG_STREAM_ID ) ; final Subscription pingSubscription = aeron . addSubscription ( PING_CHANNEL , PING_STREAM_ID ) ) { final FragmentAssemblyAdapter dataHandler = new FragmentAssemblyAdapter ( ( buffer , offset , length , header ) - > pingHandler ( pongPublication , buffer , offset , length ) ) ; while ( RUNNING . get ( ) ) { final int fragmentsRead = pingSubscription . poll ( dataHandler , FRAME_COUNT_LIMIT ) ; PING_HANDLER_IDLE_STRATEGY . idle ( fragmentsRead ) ; } System . out . println ( "Shutting down..." ) ; } } } ; } private static void sendPingAndReceivePong ( final FragmentHandler fragmentHandler , final Publication pingPublication , final Subscription pongSubscription , final int numMessages ) { final IdleStrategy idleStrategy = new BusySpinIdleStrategy ( ) ; for ( int i = 0 ; i < numMessages ; i ++ ) { do { ATOMIC_BUFFER . putLong ( 0 , System . nanoTime ( ) ) ; } while ( pingPublication . offer ( ATOMIC_BUFFER , 0 , MESSAGE_LENGTH ) < 0L ) ; while ( pongSubscription . poll ( fragmentHandler , FRAGMENT_COUNT_LIMIT ) <= 0 ) { idleStrategy . idle ( 0 ) ; } } } private static void pongHandler ( final DirectBuffer buffer , final int offset , final int length , final Header header ) { final long pingTimestamp = buffer . getLong ( offset ) ; final long rttNs = System . nanoTime ( ) - pingTimestamp ; HISTOGRAM . recordValue ( rttNs ) ; } private static void newPongConnectionHandler ( final String channel , final int streamId , final int sessionId , final long joiningPosition , final String sourceIdentity ) { if ( PONG_STREAM_ID == streamId && PONG_CHANNEL . equals ( channel ) ) { PONG_CONNECTION_LATCH . countDown ( ) ; } } public static void pingHandler ( final Publication pongPublication , final DirectBuffer buffer , final int offset , final int length ) { while ( pongPublication . offer ( buffer , offset , length ) < 0L ) { PING_HANDLER_IDLE_STRATEGY . idle ( 0 ) ; } } }
package uk . co . real_logic . aeron . samples ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . Subscription ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . agrona . CloseHelper ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . util . concurrent . atomic . AtomicBoolean ; import static uk . co . real_logic . aeron . samples . SamplesUtil . printStringMessage ; public class BasicSubscriber { private static final int STREAM_ID = SampleConfiguration . STREAM_ID ; private static final String CHANNEL = SampleConfiguration . CHANNEL ; private static final int FRAGMENT_COUNT_LIMIT = SampleConfiguration . FRAGMENT_COUNT_LIMIT ; private static final boolean EMBEDDED_MEDIA_DRIVER = SampleConfiguration . EMBEDDED_MEDIA_DRIVER ; public static void main ( final String [ ] args ) throws Exception { System . out . println ( "Subscribing to " + CHANNEL + " on stream Id " + STREAM_ID ) ; final MediaDriver driver = EMBEDDED_MEDIA_DRIVER ? MediaDriver . launchEmbedded ( ) : null ; final Aeron . Context ctx = new Aeron . Context ( ) . newConnectionHandler ( SamplesUtil : : printNewConnection ) . inactiveConnectionHandler ( SamplesUtil : : printInactiveConnection ) ; if ( EMBEDDED_MEDIA_DRIVER ) { ctx . dirName ( driver . contextDirName ( ) ) ; } final FragmentHandler fragmentHandler = printStringMessage ( STREAM_ID ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; try ( final Aeron aeron = Aeron . connect ( ctx ) ; final Subscription subscription = aeron . addSubscription ( CHANNEL , STREAM_ID ) ) { SamplesUtil . subscriberLoop ( fragmentHandler , FRAGMENT_COUNT_LIMIT , running ) . accept ( subscription ) ; System . out . println ( "Shutting down..." ) ; } CloseHelper . quietClose ( driver ) ; } }
package uk . co . real_logic . aeron . samples . raw ; import org . HdrHistogram . Histogram ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . DatagramChannel ; import java . nio . channels . SelectionKey ; import java . nio . channels . Selector ; import java . util . Iterator ; import java . util . Set ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . locks . LockSupport ; import java . util . function . IntSupplier ; import static java . nio . channels . SelectionKey . OP_READ ; import static uk . co . real_logic . aeron . driver . Configuration . MTU_LENGTH_DEFAULT ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class SendSelectReceiveUdpPing { private static final InetSocketAddress SEND_ADDRESS = new InetSocketAddress ( "localhost" , Common . PING_PORT ) ; private int sequenceNumber ; public static void main ( final String [ ] args ) throws IOException { new SendSelectReceiveUdpPing ( ) . run ( ) ; } private void run ( ) throws IOException { final Histogram histogram = new Histogram ( TimeUnit . SECONDS . toNanos ( 10 ) , 3 ) ; final ByteBuffer buffer = ByteBuffer . allocateDirect ( MTU_LENGTH_DEFAULT ) ; final DatagramChannel receiveChannel = DatagramChannel . open ( ) ; Common . init ( receiveChannel ) ; receiveChannel . bind ( new InetSocketAddress ( "localhost" , Common . PONG_PORT ) ) ; final DatagramChannel sendChannel = DatagramChannel . open ( ) ; Common . init ( sendChannel ) ; final Selector selector = Selector . open ( ) ; final IntSupplier handler = ( ) - > { try { buffer . clear ( ) ; receiveChannel . receive ( buffer ) ; final long receivedSequenceNumber = buffer . getLong ( 0 ) ; final long timestamp = buffer . getLong ( SIZE_OF_LONG ) ; if ( receivedSequenceNumber != sequenceNumber ) { throw new IllegalStateException ( "Data Loss:" + sequenceNumber + " to " + receivedSequenceNumber ) ; } final long duration = System . nanoTime ( ) - timestamp ; histogram . recordValue ( duration ) ; } catch ( final IOException ex ) { ex . printStackTrace ( ) ; } return 1 ; } ; receiveChannel . register ( selector , OP_READ , handler ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; while ( running . get ( ) ) { measureRoundTrip ( histogram , SEND_ADDRESS , buffer , sendChannel , selector , running ) ; histogram . reset ( ) ; System . gc ( ) ; LockSupport . parkNanos ( 1000 * 1000 * 1000 ) ; } } private void measureRoundTrip ( final Histogram histogram , final InetSocketAddress sendAddress , final ByteBuffer buffer , final DatagramChannel sendChannel , final Selector selector , final AtomicBoolean running ) throws IOException { for ( sequenceNumber = 0 ; sequenceNumber < Common . NUM_MESSAGES ; sequenceNumber ++ ) { final long timestamp = System . nanoTime ( ) ; buffer . clear ( ) ; buffer . putLong ( sequenceNumber ) ; buffer . putLong ( timestamp ) ; buffer . flip ( ) ; sendChannel . send ( buffer , sendAddress ) ; while ( selector . selectNow ( ) == 0 ) { if ( ! running . get ( ) ) { return ; } } final Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; final Iterator < SelectionKey > iter = selectedKeys . iterator ( ) ; while ( iter . hasNext ( ) ) { final SelectionKey key = iter . next ( ) ; if ( key . isReadable ( ) ) { ( ( IntSupplier ) key . attachment ( ) ) . getAsInt ( ) ; } iter . remove ( ) ; } } histogram . outputPercentileDistribution ( System . out , 1000.0 ) ; } }
package uk . co . real_logic . aeron . samples . raw ; import uk . co . real_logic . aeron . driver . media . NioSelectedKeySet ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . DatagramChannel ; import java . nio . channels . SelectionKey ; import java . nio . channels . Selector ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . function . ToIntFunction ; import static java . nio . channels . SelectionKey . OP_READ ; import static uk . co . real_logic . aeron . driver . Configuration . MTU_LENGTH_DEFAULT ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class HackSelectReceiveSendUdpPong { public static void main ( final String [ ] args ) throws IOException { new HackSelectReceiveSendUdpPong ( ) . run ( ) ; } private void run ( ) throws IOException { final InetSocketAddress sendAddress = new InetSocketAddress ( "localhost" , Common . PONG_PORT ) ; final ByteBuffer buffer = ByteBuffer . allocateDirect ( MTU_LENGTH_DEFAULT ) ; final DatagramChannel receiveChannel = DatagramChannel . open ( ) ; Common . init ( receiveChannel ) ; receiveChannel . bind ( new InetSocketAddress ( "localhost" , Common . PING_PORT ) ) ; final DatagramChannel sendChannel = DatagramChannel . open ( ) ; Common . init ( sendChannel ) ; final Selector selector = Selector . open ( ) ; final NioSelectedKeySet keySet = Common . keySet ( selector ) ; final ToIntFunction < SelectionKey > handler = ( key ) - > { try { buffer . clear ( ) ; receiveChannel . receive ( buffer ) ; final long receivedSequenceNumber = buffer . getLong ( 0 ) ; final long receivedTimestamp = buffer . getLong ( SIZE_OF_LONG ) ; buffer . clear ( ) ; buffer . putLong ( receivedSequenceNumber ) ; buffer . putLong ( receivedTimestamp ) ; buffer . flip ( ) ; sendChannel . send ( buffer , sendAddress ) ; } catch ( final IOException ex ) { ex . printStackTrace ( ) ; } return 1 ; } ; receiveChannel . register ( selector , OP_READ , null ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; while ( true ) { while ( selector . selectNow ( ) == 0 ) { if ( ! running . get ( ) ) { return ; } } keySet . forEach ( handler ) ; } } }
package uk . co . real_logic . aeron . samples . raw ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . DatagramChannel ; import java . nio . channels . SelectionKey ; import java . nio . channels . Selector ; import java . util . Iterator ; import java . util . Set ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . function . IntSupplier ; import static java . nio . channels . SelectionKey . OP_READ ; import static uk . co . real_logic . aeron . driver . Configuration . MTU_LENGTH_DEFAULT ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class SelectReceiveSendUdpPong { public static void main ( final String [ ] args ) throws IOException { new SelectReceiveSendUdpPong ( ) . run ( ) ; } private void run ( ) throws IOException { final InetSocketAddress sendAddress = new InetSocketAddress ( "localhost" , Common . PONG_PORT ) ; final ByteBuffer buffer = ByteBuffer . allocateDirect ( MTU_LENGTH_DEFAULT ) ; final DatagramChannel receiveChannel = DatagramChannel . open ( ) ; Common . init ( receiveChannel ) ; receiveChannel . bind ( new InetSocketAddress ( "localhost" , Common . PING_PORT ) ) ; final DatagramChannel sendChannel = DatagramChannel . open ( ) ; Common . init ( sendChannel ) ; final Selector selector = Selector . open ( ) ; final IntSupplier handler = ( ) - > { try { buffer . clear ( ) ; receiveChannel . receive ( buffer ) ; final long receivedSequenceNumber = buffer . getLong ( 0 ) ; final long receivedTimestamp = buffer . getLong ( SIZE_OF_LONG ) ; buffer . clear ( ) ; buffer . putLong ( receivedSequenceNumber ) ; buffer . putLong ( receivedTimestamp ) ; buffer . flip ( ) ; sendChannel . send ( buffer , sendAddress ) ; } catch ( final IOException ex ) { ex . printStackTrace ( ) ; } return 1 ; } ; receiveChannel . register ( selector , OP_READ , handler ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; while ( true ) { while ( selector . selectNow ( ) == 0 ) { if ( ! running . get ( ) ) { return ; } } final Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; final Iterator < SelectionKey > iter = selectedKeys . iterator ( ) ; while ( iter . hasNext ( ) ) { final SelectionKey key = iter . next ( ) ; if ( key . isReadable ( ) ) { ( ( IntSupplier ) key . attachment ( ) ) . getAsInt ( ) ; } iter . remove ( ) ; } } } }
package uk . co . real_logic . aeron . samples . raw ; import org . HdrHistogram . Histogram ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . DatagramChannel ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . locks . LockSupport ; import static uk . co . real_logic . aeron . driver . Configuration . MTU_LENGTH_DEFAULT ; import static uk . co . real_logic . aeron . samples . raw . Common . init ; public class SendReceiveUdpPing { public static void main ( final String [ ] args ) throws IOException { int numChannels = 1 ; if ( 1 == args . length ) { numChannels = Integer . parseInt ( args [ 0 ] ) ; } final Histogram histogram = new Histogram ( TimeUnit . SECONDS . toNanos ( 10 ) , 3 ) ; final ByteBuffer buffer = ByteBuffer . allocateDirect ( MTU_LENGTH_DEFAULT ) ; final DatagramChannel [ ] receiveChannels = new DatagramChannel [ numChannels ] ; for ( int i = 0 ; i < receiveChannels . length ; i ++ ) { receiveChannels [ i ] = DatagramChannel . open ( ) ; init ( receiveChannels [ i ] ) ; receiveChannels [ i ] . bind ( new InetSocketAddress ( "localhost" , Common . PONG_PORT + i ) ) ; } final InetSocketAddress sendAddress = new InetSocketAddress ( "localhost" , Common . PING_PORT ) ; final DatagramChannel sendChannel = DatagramChannel . open ( ) ; init ( sendChannel ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; while ( running . get ( ) ) { measureRoundTrip ( histogram , sendAddress , buffer , receiveChannels , sendChannel , running ) ; histogram . reset ( ) ; System . gc ( ) ; LockSupport . parkNanos ( 1000_000_000 ) ; } } private static void measureRoundTrip ( final Histogram histogram , final InetSocketAddress sendAddress , final ByteBuffer buffer , final DatagramChannel [ ] receiveChannels , final DatagramChannel sendChannel , final AtomicBoolean running ) throws IOException { for ( int sequenceNumber = 0 ; sequenceNumber < Common . NUM_MESSAGES ; sequenceNumber ++ ) { final long timestamp = System . nanoTime ( ) ; buffer . clear ( ) ; buffer . putLong ( sequenceNumber ) ; buffer . putLong ( timestamp ) ; buffer . flip ( ) ; sendChannel . send ( buffer , sendAddress ) ; buffer . clear ( ) ; boolean available = false ; while ( ! available ) { if ( ! running . get ( ) ) { return ; } for ( int i = receiveChannels . length - 1 ; i >= 0 ; i -- ) { if ( null != receiveChannels [ i ] . receive ( buffer ) ) { available = true ; break ; } } } final long receivedSequenceNumber = buffer . getLong ( 0 ) ; if ( receivedSequenceNumber != sequenceNumber ) { throw new IllegalStateException ( "Data Loss:" + sequenceNumber + " to " + receivedSequenceNumber ) ; } final long duration = System . nanoTime ( ) - buffer . getLong ( BitUtil . SIZE_OF_LONG ) ; histogram . recordValue ( duration ) ; } histogram . outputPercentileDistribution ( System . out , 1000.0 ) ; } }
package uk . co . real_logic . aeron . tools ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; public class StatsCsvOutput implements StatsOutput { public static final String DEFAULT_FILE = "stats.csv" ; private String file ; private FileWriter out ; private boolean firstTime = true ; public StatsCsvOutput ( final String file ) { if ( file != null ) { this . file = file ; } else { this . file = DEFAULT_FILE ; } try { System . out . println ( "Output file: " + this . file ) ; final File outFile = new File ( this . file ) ; outFile . createNewFile ( ) ; out = new FileWriter ( outFile ) ; } catch ( final IOException e ) { e . printStackTrace ( ) ; } } public void format ( final String [ ] keys , final long [ ] vals ) throws Exception { if ( firstTime ) { for ( int i = 0 ; i < keys . length - 1 ; i ++ ) { out . write ( keys [ i ] + "," ) ; } out . write ( keys [ keys . length - 1 ] + "\n" ) ; firstTime = false ; } for ( int i = 0 ; i < vals . length - 1 ; i ++ ) { out . write ( vals [ i ] + "," ) ; } out . write ( vals [ vals . length - 1 ] + "\n" ) ; out . flush ( ) ; } public void close ( ) throws Exception { out . close ( ) ; } }
package uk . co . real_logic . aeron . samples . raw ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . DatagramChannel ; import java . nio . channels . FileChannel ; import java . util . concurrent . atomic . AtomicBoolean ; import static uk . co . real_logic . aeron . driver . Configuration . MTU_LENGTH_DEFAULT ; import static uk . co . real_logic . aeron . samples . raw . Common . init ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class TransferToPong { public static void main ( final String [ ] args ) throws IOException { final FileChannel receiveFileChannel = Common . createTmpFileChannel ( ) ; final ByteBuffer receiveByteBuffer = receiveFileChannel . map ( FileChannel . MapMode . READ_WRITE , 0 , MTU_LENGTH_DEFAULT ) ; final DatagramChannel receiveDatagramChannel = DatagramChannel . open ( ) ; init ( receiveDatagramChannel ) ; receiveDatagramChannel . bind ( new InetSocketAddress ( "localhost" , 40124 ) ) ; receiveDatagramChannel . connect ( new InetSocketAddress ( "localhost" , 40123 ) ) ; final FileChannel sendFileChannel = Common . createTmpFileChannel ( ) ; final ByteBuffer sendByteBuffer = sendFileChannel . map ( FileChannel . MapMode . READ_WRITE , 0 , MTU_LENGTH_DEFAULT ) ; final DatagramChannel sendDatagramChannel = DatagramChannel . open ( ) ; init ( sendDatagramChannel ) ; sendDatagramChannel . bind ( new InetSocketAddress ( "localhost" , 40125 ) ) ; sendDatagramChannel . connect ( new InetSocketAddress ( "localhost" , 40126 ) ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; final int packetSize = SIZE_OF_LONG * 2 ; while ( true ) { boolean available = false ; while ( ! available ) { if ( ! running . get ( ) ) { return ; } final long bytesReceived = receiveFileChannel . transferFrom ( receiveDatagramChannel , 0 , packetSize ) ; if ( packetSize == bytesReceived ) { available = true ; } } final long receivedSequenceNumber = receiveByteBuffer . getLong ( 0 ) ; final long receivedTimestamp = receiveByteBuffer . getLong ( SIZE_OF_LONG ) ; sendByteBuffer . putLong ( 0 , receivedSequenceNumber ) ; sendByteBuffer . putLong ( SIZE_OF_LONG , receivedTimestamp ) ; final long bytesSent = sendFileChannel . transferTo ( 0 , packetSize , sendDatagramChannel ) ; if ( packetSize != bytesSent ) { throw new IllegalStateException ( "Invalid bytes sent " + bytesSent ) ; } } } }
package uk . co . real_logic . aeron . samples . raw ; import uk . co . real_logic . aeron . driver . media . NioSelectedKeySet ; import uk . co . real_logic . agrona . IoUtil ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . lang . reflect . Field ; import java . net . InetSocketAddress ; import java . net . StandardSocketOptions ; import java . nio . channels . DatagramChannel ; import java . nio . channels . FileChannel ; import java . nio . channels . Selector ; import static uk . co . real_logic . aeron . driver . Configuration . MTU_LENGTH_DEFAULT ; public class Common { public static final int NUM_MESSAGES = 10_000 ; public static final int PONG_PORT = 40123 ; public static final int PING_PORT = 50123 ; static final Field SELECTED_KEYS_FIELD ; static final Field PUBLIC_SELECTED_KEYS_FIELD ; static { Field selectKeysField = null ; Field publicSelectKeysField = null ; try { final Class < ? > clazz = Class . forName ( "sun.nio.ch.SelectorImpl" , false , ClassLoader . getSystemClassLoader ( ) ) ; if ( clazz . isAssignableFrom ( Selector . open ( ) . getClass ( ) ) ) { selectKeysField = clazz . getDeclaredField ( "selectedKeys" ) ; selectKeysField . setAccessible ( true ) ; publicSelectKeysField = clazz . getDeclaredField ( "publicSelectedKeys" ) ; publicSelectKeysField . setAccessible ( true ) ; } } catch ( final Exception ignore ) { } SELECTED_KEYS_FIELD = selectKeysField ; PUBLIC_SELECTED_KEYS_FIELD = publicSelectKeysField ; } public static void init ( final DatagramChannel channel ) throws IOException { channel . configureBlocking ( false ) ; channel . setOption ( StandardSocketOptions . SO_REUSEADDR , true ) ; } public static void init ( final DatagramChannel channel , final InetSocketAddress sendAddress ) throws IOException { channel . configureBlocking ( false ) ; channel . setOption ( StandardSocketOptions . SO_REUSEADDR , true ) ; channel . connect ( sendAddress ) ; } public static NioSelectedKeySet keySet ( final Selector selector ) { NioSelectedKeySet tmpSet = null ; if ( null != PUBLIC_SELECTED_KEYS_FIELD ) { try { tmpSet = new NioSelectedKeySet ( ) ; SELECTED_KEYS_FIELD . set ( selector , tmpSet ) ; PUBLIC_SELECTED_KEYS_FIELD . set ( selector , tmpSet ) ; } catch ( final Exception ignore ) { tmpSet = null ; } } return tmpSet ; } public static FileChannel createTmpFileChannel ( ) throws IOException { final File file = File . createTempFile ( "buffer-" , ".dat" ) ; file . deleteOnExit ( ) ; final RandomAccessFile randomAccessFile = new RandomAccessFile ( file , "rw" ) ; final FileChannel fileChannel = randomAccessFile . getChannel ( ) ; IoUtil . fill ( fileChannel , 0 , MTU_LENGTH_DEFAULT , ( byte ) 0 ) ; return fileChannel ; } }
package uk . co . real_logic . aeron . samples . raw ; import org . HdrHistogram . Histogram ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . DatagramChannel ; import java . nio . channels . FileChannel ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . locks . LockSupport ; import static uk . co . real_logic . aeron . driver . Configuration . MTU_LENGTH_DEFAULT ; import static uk . co . real_logic . aeron . samples . raw . Common . init ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class TransferToPing { public static void main ( final String [ ] args ) throws IOException { final Histogram histogram = new Histogram ( TimeUnit . SECONDS . toNanos ( 10 ) , 3 ) ; final FileChannel sendFileChannel = Common . createTmpFileChannel ( ) ; final ByteBuffer sendByteBuffer = sendFileChannel . map ( FileChannel . MapMode . READ_WRITE , 0 , MTU_LENGTH_DEFAULT ) ; final DatagramChannel sendDatagramChannel = DatagramChannel . open ( ) ; init ( sendDatagramChannel ) ; sendDatagramChannel . bind ( new InetSocketAddress ( "localhost" , 40123 ) ) ; sendDatagramChannel . connect ( new InetSocketAddress ( "localhost" , 40124 ) ) ; final FileChannel receiveFileChannel = Common . createTmpFileChannel ( ) ; final ByteBuffer receiveByteBuffer = receiveFileChannel . map ( FileChannel . MapMode . READ_WRITE , 0 , MTU_LENGTH_DEFAULT ) ; final DatagramChannel receiveDatagramChannel = DatagramChannel . open ( ) ; init ( receiveDatagramChannel ) ; receiveDatagramChannel . bind ( new InetSocketAddress ( "localhost" , 40126 ) ) ; receiveDatagramChannel . connect ( new InetSocketAddress ( "localhost" , 40125 ) ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; while ( running . get ( ) ) { measureRoundTrip ( histogram , receiveFileChannel , receiveDatagramChannel , receiveByteBuffer , sendFileChannel , sendDatagramChannel , sendByteBuffer , running ) ; histogram . reset ( ) ; System . gc ( ) ; LockSupport . parkNanos ( 1000 * 1000 * 1000 ) ; } } private static void measureRoundTrip ( final Histogram histogram , final FileChannel receiveFileChannel , final DatagramChannel receiveDatagramChannel , final ByteBuffer receiveByteBuffer , final FileChannel sendFileChannel , final DatagramChannel sendDatagramChannel , final ByteBuffer sendByteBuffer , final AtomicBoolean running ) throws IOException { final int packetSize = SIZE_OF_LONG * 2 ; for ( int sequenceNumber = 0 ; sequenceNumber < Common . NUM_MESSAGES ; sequenceNumber ++ ) { final long timestamp = System . nanoTime ( ) ; sendByteBuffer . putLong ( 0 , sequenceNumber ) ; sendByteBuffer . putLong ( SIZE_OF_LONG , timestamp ) ; final long bytesSent = sendFileChannel . transferTo ( 0 , packetSize , sendDatagramChannel ) ; if ( packetSize != bytesSent ) { throw new IllegalStateException ( "Invalid bytes sent " + bytesSent ) ; } boolean available = false ; while ( ! available ) { if ( ! running . get ( ) ) { return ; } final long bytesReceived = receiveFileChannel . transferFrom ( receiveDatagramChannel , 0 , packetSize ) ; if ( packetSize == bytesReceived ) { available = true ; } } final long receivedSequenceNumber = receiveByteBuffer . getLong ( 0 ) ; if ( receivedSequenceNumber != sequenceNumber ) { throw new IllegalStateException ( "Data Loss:" + sequenceNumber + " to " + receivedSequenceNumber ) ; } final long duration = System . nanoTime ( ) - receiveByteBuffer . getLong ( SIZE_OF_LONG ) ; histogram . recordValue ( duration ) ; } histogram . outputPercentileDistribution ( System . out , 1000.0 ) ; } }
package uk . co . real_logic . aeron . samples . raw ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . DatagramChannel ; import java . util . concurrent . atomic . AtomicBoolean ; import static uk . co . real_logic . aeron . driver . Configuration . MTU_LENGTH_DEFAULT ; import static uk . co . real_logic . aeron . samples . raw . Common . init ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class ReceiveSendUdpPong { public static void main ( final String [ ] args ) throws IOException { int numChannels = 1 ; if ( 1 == args . length ) { numChannels = Integer . parseInt ( args [ 0 ] ) ; } final ByteBuffer buffer = ByteBuffer . allocateDirect ( MTU_LENGTH_DEFAULT ) ; final DatagramChannel [ ] receiveChannels = new DatagramChannel [ numChannels ] ; for ( int i = 0 ; i < receiveChannels . length ; i ++ ) { receiveChannels [ i ] = DatagramChannel . open ( ) ; init ( receiveChannels [ i ] ) ; receiveChannels [ i ] . bind ( new InetSocketAddress ( "localhost" , Common . PING_PORT + i ) ) ; } final InetSocketAddress sendAddress = new InetSocketAddress ( "localhost" , Common . PONG_PORT ) ; final DatagramChannel sendChannel = DatagramChannel . open ( ) ; Common . init ( sendChannel ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; while ( true ) { buffer . clear ( ) ; boolean available = false ; while ( ! available ) { if ( ! running . get ( ) ) { return ; } for ( int i = receiveChannels . length - 1 ; i >= 0 ; i -- ) { if ( null != receiveChannels [ i ] . receive ( buffer ) ) { available = true ; break ; } } } final long receivedSequenceNumber = buffer . getLong ( 0 ) ; final long receivedTimestamp = buffer . getLong ( SIZE_OF_LONG ) ; buffer . clear ( ) ; buffer . putLong ( receivedSequenceNumber ) ; buffer . putLong ( receivedTimestamp ) ; buffer . flip ( ) ; sendChannel . send ( buffer , sendAddress ) ; } } }
package uk . co . real_logic . aeron . samples . raw ; import org . HdrHistogram . Histogram ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . DatagramChannel ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . locks . LockSupport ; import static uk . co . real_logic . aeron . driver . Configuration . MTU_LENGTH_DEFAULT ; import static uk . co . real_logic . aeron . samples . raw . Common . init ; public class WriteReceiveUdpPing { public static void main ( final String [ ] args ) throws IOException { int numChannels = 1 ; if ( 1 == args . length ) { numChannels = Integer . parseInt ( args [ 0 ] ) ; } final Histogram histogram = new Histogram ( TimeUnit . SECONDS . toNanos ( 10 ) , 3 ) ; final ByteBuffer buffer = ByteBuffer . allocateDirect ( MTU_LENGTH_DEFAULT ) ; final DatagramChannel [ ] receiveChannels = new DatagramChannel [ numChannels ] ; for ( int i = 0 ; i < receiveChannels . length ; i ++ ) { receiveChannels [ i ] = DatagramChannel . open ( ) ; init ( receiveChannels [ i ] ) ; receiveChannels [ i ] . bind ( new InetSocketAddress ( "localhost" , Common . PONG_PORT + i ) ) ; } final InetSocketAddress writeAddress = new InetSocketAddress ( "localhost" , Common . PING_PORT ) ; final DatagramChannel writeChannel = DatagramChannel . open ( ) ; init ( writeChannel , writeAddress ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; while ( running . get ( ) ) { measureRoundTrip ( histogram , buffer , receiveChannels , writeChannel , running ) ; histogram . reset ( ) ; System . gc ( ) ; LockSupport . parkNanos ( 1000_000_000 ) ; } } private static void measureRoundTrip ( final Histogram histogram , final ByteBuffer buffer , final DatagramChannel [ ] receiveChannels , final DatagramChannel writeChannel , final AtomicBoolean running ) throws IOException { for ( int sequenceNumber = 0 ; sequenceNumber < Common . NUM_MESSAGES ; sequenceNumber ++ ) { final long timestamp = System . nanoTime ( ) ; buffer . clear ( ) ; buffer . putLong ( sequenceNumber ) ; buffer . putLong ( timestamp ) ; buffer . flip ( ) ; writeChannel . write ( buffer ) ; buffer . clear ( ) ; boolean available = false ; while ( ! available ) { if ( ! running . get ( ) ) { return ; } for ( int i = receiveChannels . length - 1 ; i >= 0 ; i -- ) { if ( null != receiveChannels [ i ] . receive ( buffer ) ) { available = true ; break ; } } } final long receivedSequenceNumber = buffer . getLong ( 0 ) ; if ( receivedSequenceNumber != sequenceNumber ) { throw new IllegalStateException ( "Data Loss:" + sequenceNumber + " to " + receivedSequenceNumber ) ; } final long duration = System . nanoTime ( ) - buffer . getLong ( BitUtil . SIZE_OF_LONG ) ; histogram . recordValue ( duration ) ; } histogram . outputPercentileDistribution ( System . out , 1000.0 ) ; } }
package uk . co . real_logic . aeron . samples . raw ; import org . HdrHistogram . Histogram ; import uk . co . real_logic . aeron . driver . media . NioSelectedKeySet ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . DatagramChannel ; import java . nio . channels . SelectionKey ; import java . nio . channels . Selector ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . locks . LockSupport ; import java . util . function . ToIntFunction ; import static java . nio . channels . SelectionKey . OP_READ ; import static uk . co . real_logic . aeron . driver . Configuration . MTU_LENGTH_DEFAULT ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class SendHackSelectReceiveUdpPing implements ToIntFunction < SelectionKey > { private static final InetSocketAddress SEND_ADDRESS = new InetSocketAddress ( "localhost" , Common . PING_PORT ) ; private static final Histogram HISTOGRAM = new Histogram ( TimeUnit . SECONDS . toNanos ( 10 ) , 3 ) ; private final ByteBuffer buffer = ByteBuffer . allocateDirect ( MTU_LENGTH_DEFAULT ) ; private DatagramChannel receiveChannel ; private int sequenceNumber ; public static void main ( final String [ ] args ) throws IOException { new SendHackSelectReceiveUdpPing ( ) . run ( ) ; } private void run ( ) throws IOException { receiveChannel = DatagramChannel . open ( ) ; Common . init ( receiveChannel ) ; receiveChannel . bind ( new InetSocketAddress ( "localhost" , Common . PONG_PORT ) ) ; final DatagramChannel sendChannel = DatagramChannel . open ( ) ; Common . init ( sendChannel ) ; final Selector selector = Selector . open ( ) ; receiveChannel . register ( selector , OP_READ , this ) ; final NioSelectedKeySet keySet = Common . keySet ( selector ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; while ( running . get ( ) ) { measureRoundTrip ( HISTOGRAM , SEND_ADDRESS , buffer , sendChannel , selector , keySet , running ) ; HISTOGRAM . reset ( ) ; System . gc ( ) ; LockSupport . parkNanos ( 1000 * 1000 * 1000 ) ; } } public int applyAsInt ( final SelectionKey key ) { try { buffer . clear ( ) ; receiveChannel . receive ( buffer ) ; final long receivedSequenceNumber = buffer . getLong ( 0 ) ; final long timestamp = buffer . getLong ( SIZE_OF_LONG ) ; if ( receivedSequenceNumber != sequenceNumber ) { throw new IllegalStateException ( "Data Loss:" + sequenceNumber + " to " + receivedSequenceNumber ) ; } final long duration = System . nanoTime ( ) - timestamp ; HISTOGRAM . recordValue ( duration ) ; } catch ( final IOException ex ) { ex . printStackTrace ( ) ; } return 1 ; } private void measureRoundTrip ( final Histogram histogram , final InetSocketAddress sendAddress , final ByteBuffer buffer , final DatagramChannel sendChannel , final Selector selector , final NioSelectedKeySet keySet , final AtomicBoolean running ) throws IOException { for ( sequenceNumber = 0 ; sequenceNumber < Common . NUM_MESSAGES ; sequenceNumber ++ ) { final long timestamp = System . nanoTime ( ) ; buffer . clear ( ) ; buffer . putLong ( sequenceNumber ) ; buffer . putLong ( timestamp ) ; buffer . flip ( ) ; sendChannel . send ( buffer , sendAddress ) ; while ( selector . selectNow ( ) == 0 ) { if ( ! running . get ( ) ) { return ; } } keySet . forEach ( this ) ; } histogram . outputPercentileDistribution ( System . out , 1000.0 ) ; } }
package uk . co . real_logic . aeron . samples . raw ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . DatagramChannel ; import java . util . concurrent . atomic . AtomicBoolean ; import static uk . co . real_logic . aeron . driver . Configuration . MTU_LENGTH_DEFAULT ; import static uk . co . real_logic . aeron . samples . raw . Common . init ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class ReceiveWriteUdpPong { public static void main ( final String [ ] args ) throws IOException { int numChannels = 1 ; if ( 1 == args . length ) { numChannels = Integer . parseInt ( args [ 0 ] ) ; } final ByteBuffer buffer = ByteBuffer . allocateDirect ( MTU_LENGTH_DEFAULT ) ; final DatagramChannel [ ] receiveChannels = new DatagramChannel [ numChannels ] ; for ( int i = 0 ; i < receiveChannels . length ; i ++ ) { receiveChannels [ i ] = DatagramChannel . open ( ) ; init ( receiveChannels [ i ] ) ; receiveChannels [ i ] . bind ( new InetSocketAddress ( "localhost" , Common . PING_PORT + i ) ) ; } final InetSocketAddress writeAddress = new InetSocketAddress ( "localhost" , Common . PONG_PORT ) ; final DatagramChannel writeChannel = DatagramChannel . open ( ) ; Common . init ( writeChannel , writeAddress ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; while ( true ) { buffer . clear ( ) ; boolean available = false ; while ( ! available ) { if ( ! running . get ( ) ) { return ; } for ( int i = receiveChannels . length - 1 ; i >= 0 ; i -- ) { if ( null != receiveChannels [ i ] . receive ( buffer ) ) { available = true ; break ; } } } final long receivedSequenceNumber = buffer . getLong ( 0 ) ; final long receivedTimestamp = buffer . getLong ( SIZE_OF_LONG ) ; buffer . clear ( ) ; buffer . putLong ( receivedSequenceNumber ) ; buffer . putLong ( receivedTimestamp ) ; buffer . flip ( ) ; writeChannel . write ( buffer ) ; } } }
package uk . co . real_logic . aeron . tools ; import java . io . IOException ; import java . io . InputStream ; public class RandomInputStream extends InputStream { public int available ( ) { return Integer . MAX_VALUE ; } public boolean markSupported ( ) { return false ; } public int read ( ) throws IOException { return SeedableThreadLocalRandom . current ( ) . nextInt ( ) & 0x0000_00FF ; } public long skip ( final long b ) { return b ; } public int read ( final byte [ ] b ) throws IOException { int bytesRead = SeedableThreadLocalRandom . current ( ) . nextInt ( 400 ) ; if ( bytesRead > b . length ) { bytesRead = b . length ; } return read ( b , 0 , bytesRead ) ; } public int read ( final byte [ ] b , final int off , final int len ) throws IOException { int remaining = len ; int offset = off ; while ( remaining >= 4 ) { final int data = SeedableThreadLocalRandom . current ( ) . nextInt ( ) ; b [ offset ++ ] = ( byte ) ( data > > > 24 ) ; b [ offset ++ ] = ( byte ) ( data > > > 16 ) ; b [ offset ++ ] = ( byte ) ( data > > > 8 ) ; b [ offset ++ ] = ( byte ) data ; remaining -= 4 ; } final int data = SeedableThreadLocalRandom . current ( ) . nextInt ( ) ; while ( remaining > 0 ) { b [ offset ++ ] = ( byte ) ( data > > > remaining * 8 ) ; remaining -= 1 ; } return len ; } }
package uk . co . real_logic . aeron . tools ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . io . InputStream ; import java . util . zip . CRC32 ; public class MessageStream { private static final int MAGIC_OFFSET = 0 ; private static final int MESSAGE_CHECKSUM_OFFSET = 4 ; private static final int SEQUENCE_NUMBER_OFFSET = 8 ; private final int messageOffset ; private static final int HEADER_LENGTH = 16 ; private static final int MAGIC = 0x0dd01221 ; private static final int MAGIC_END = 0xbeba1221 ; private static final int HEX_PRINT_WIDTH = 16 ; private final int minSize ; private final int maxSize ; private final boolean verifiable ; private InputStream inputStream ; private final boolean inputStreamIsRandom ; private byte [ ] inputStreamBytes ; private long sequenceNumber = - 1 ; private long messageCount = 0 ; private boolean active = true ; private static final ThreadLocalCRC32 MSG_CHECKSUM = new ThreadLocalCRC32 ( ) ; private static class ThreadLocalCRC32 extends ThreadLocal < CRC32 > { protected CRC32 initialValue ( ) { return new CRC32 ( ) ; } } public MessageStream ( final int size ) throws Exception { this ( size , size , true , null ) ; } public MessageStream ( final int minSize , final int maxSize ) throws Exception { this ( minSize , maxSize , true , null ) ; } public MessageStream ( final int size , final InputStream inputStream ) throws Exception { this ( size , size , true , inputStream ) ; } public MessageStream ( final int size , final boolean verifiable , final InputStream inputStream ) throws Exception { this ( size , size , verifiable , inputStream ) ; } public MessageStream ( final int minSize , final int maxSize , final boolean verifiable ) throws Exception { this ( minSize , maxSize , verifiable , null ) ; } public MessageStream ( final int minSize , final int maxSize , final boolean verifiable , final InputStream inputStream ) throws Exception { if ( inputStream == null ) { this . inputStream = new RandomInputStream ( ) ; this . inputStreamIsRandom = true ; } else { this . inputStream = inputStream ; this . inputStreamIsRandom = false ; } if ( minSize < 0 ) { throw new Exception ( "MessageStream minimum message size must be 0 or greater." ) ; } if ( maxSize < 0 ) { throw new Exception ( "MessageStream maximum message size must be 0 or greater." ) ; } if ( maxSize < minSize ) { throw new Exception ( "MessageStream maximum size must be greater than or equal to minimum size." ) ; } if ( verifiable && ( minSize < HEADER_LENGTH ) ) { throw new Exception ( "MessageStream minimum size must be at least " + HEADER_LENGTH + " bytes when using verifiable messages." ) ; } this . inputStreamBytes = new byte [ maxSize ] ; this . minSize = minSize ; this . maxSize = maxSize ; this . verifiable = verifiable ; if ( this . verifiable ) { this . messageOffset = HEADER_LENGTH ; } else { this . messageOffset = 0 ; } if ( this . minSize > this . maxSize ) { throw new Exception ( "MessageStream maximum size must be greater than or equal to minimum size." ) ; } } public MessageStream ( ) { this . minSize = 0 ; this . maxSize = 0 ; this . messageOffset = HEADER_LENGTH ; this . verifiable = true ; this . inputStream = null ; this . inputStreamIsRandom = false ; } public int payloadOffset ( final DirectBuffer buffer , final int offset ) { if ( isVerifiable ( buffer , offset ) ) { return HEADER_LENGTH ; } return 0 ; } public void putNext ( final DirectBuffer buffer , final int offset , final int length ) throws Exception { if ( ! active ) { throw new Exception ( "Stream has ended." ) ; } final long receivedSequenceNumber = buffer . getLong ( offset + SEQUENCE_NUMBER_OFFSET ) ; final long expectedSequenceNumber = sequenceNumber + 1 ; if ( receivedSequenceNumber != expectedSequenceNumber ) { final Exception e = new Exception ( "Verifiable message stream received sequence number " + receivedSequenceNumber + ", but was expecting " + expectedSequenceNumber + ". Possibly missed " + ( receivedSequenceNumber - expectedSequenceNumber ) + " messages." ) ; sequenceNumber = receivedSequenceNumber ; throw e ; } sequenceNumber ++ ; final CRC32 crc = MSG_CHECKSUM . get ( ) ; crc . reset ( ) ; int i = offset ; for ( ; i < ( offset + MESSAGE_CHECKSUM_OFFSET ) ; i ++ ) { crc . update ( buffer . getByte ( i ) ) ; } for ( ; i < ( offset + SEQUENCE_NUMBER_OFFSET ) ; i ++ ) { crc . update ( 0 ) ; } for ( ; i < ( offset + length ) ; i ++ ) { crc . update ( buffer . getByte ( i ) ) ; } final int msgCksum = buffer . getInt ( offset + MESSAGE_CHECKSUM_OFFSET ) ; if ( ( int ) ( crc . getValue ( ) ) != msgCksum ) { throw new Exception ( "Verifiable message per-message checksum invalid; received " + msgCksum + " but calculated " + ( int ) ( crc . getValue ( ) ) ) ; } messageCount ++ ; if ( buffer . getInt ( offset + MAGIC_OFFSET ) == MAGIC_END ) { active = false ; } } public void reset ( final InputStream inputStream ) { reset ( ) ; this . inputStream = inputStream ; } public void reset ( ) { active = true ; messageCount = 0 ; sequenceNumber = - 1 ; } public boolean isActive ( ) { return active ; } public long getMessageCount ( ) { return messageCount ; } public long getSequenceNumber ( ) { return sequenceNumber ; } public static boolean isVerifiable ( final DirectBuffer buffer , final int offset ) { if ( ( buffer . capacity ( ) - offset ) < HEADER_LENGTH ) { return false ; } final int magic = buffer . getInt ( offset ) ; return ( magic == MAGIC ) || ( magic == MAGIC_END ) ; } static void printHex ( final DirectBuffer buffer , final int length ) { printHex ( buffer , 0 , length ) ; } static void printHex ( final UnsafeBuffer buffer , final int length ) { printHex ( buffer , 0 , length ) ; } static void printHex ( final UnsafeBuffer buffer , final int offset , final int length ) { int pos = 0 ; for ( int i = offset ; i < ( offset + length ) ; i ++ ) { System . out . printf ( "%02x " , buffer . getByte ( i ) ) ; if ( ++ pos % HEX_PRINT_WIDTH == 0 ) { System . out . println ( ) ; } } System . out . println ( ) ; } public static void printHex ( final DirectBuffer buffer , final int offset , final int length ) { int pos = 0 ; for ( int i = offset ; i < ( offset + length ) ; i ++ ) { System . out . printf ( "%02x " , buffer . getByte ( i ) ) ; if ( ++ pos % HEX_PRINT_WIDTH == 0 ) { System . out . println ( ) ; } } System . out . println ( ) ; } public int getNext ( final UnsafeBuffer buffer ) throws Exception { if ( buffer . capacity ( ) < maxSize ) { throw new Exception ( "Buffer capacity must be at least " + maxSize + " bytes." ) ; } final int size = SeedableThreadLocalRandom . current ( ) . nextInt ( maxSize - minSize + 1 ) + minSize ; return getNext ( buffer , size ) ; } private void checkConstraints ( final UnsafeBuffer buffer , final int size ) throws Exception { if ( ! active ) { throw new Exception ( "Stream has ended." ) ; } if ( size < 0 ) { throw new Exception ( "Size must be >= 0." ) ; } if ( verifiable ) { if ( size < HEADER_LENGTH ) { throw new Exception ( "Size must be at least " + HEADER_LENGTH + " when verifiable messages are used." ) ; } } if ( buffer . capacity ( ) < size ) { throw new Exception ( "Buffer capacity must be at least " + size + " bytes." ) ; } } public int getNext ( final UnsafeBuffer buffer , final int size ) throws Exception { checkConstraints ( buffer , size ) ; int pos ; if ( verifiable ) { sequenceNumber ++ ; buffer . putInt ( MAGIC_OFFSET , MAGIC ) ; buffer . putInt ( MESSAGE_CHECKSUM_OFFSET , 0 ) ; buffer . putLong ( SEQUENCE_NUMBER_OFFSET , sequenceNumber ) ; pos = messageOffset ; } else { pos = 0 ; } final int lenleft = size - pos ; if ( inputStreamBytes . length < lenleft ) { inputStreamBytes = new byte [ lenleft ] ; } final int sizeRead = inputStream . read ( inputStreamBytes , 0 , lenleft ) ; if ( sizeRead > 0 ) { buffer . putBytes ( pos , inputStreamBytes , 0 , sizeRead ) ; if ( ( sizeRead >= 4 ) && inputStreamIsRandom && ! verifiable ) { while ( isVerifiable ( buffer , 0 ) ) { buffer . putInt ( MAGIC_OFFSET , SeedableThreadLocalRandom . current ( ) . nextInt ( ) ) ; } } pos += sizeRead ; } else if ( sizeRead < 0 ) { if ( verifiable ) { buffer . putInt ( MAGIC_OFFSET , MAGIC_END ) ; } active = false ; } if ( verifiable ) { final CRC32 msgCksum = MSG_CHECKSUM . get ( ) ; msgCksum . reset ( ) ; for ( int i = 0 ; i < pos ; i ++ ) { msgCksum . update ( buffer . getByte ( i ) ) ; } buffer . putInt ( MESSAGE_CHECKSUM_OFFSET , ( int ) ( msgCksum . getValue ( ) ) ) ; } messageCount ++ ; return pos ; } }
package uk . co . real_logic . aeron . tools ; import org . apache . commons . cli . * ; import uk . co . real_logic . agrona . concurrent . SigInt ; import java . util . concurrent . atomic . AtomicBoolean ; public class StatsDriver { private Options options ; private StatsOutput output = null ; private Stats stats = null ; private String file = null ; private AtomicBoolean running = null ; public StatsDriver ( final String [ ] args ) { try { parseArgs ( args ) ; running = new AtomicBoolean ( true ) ; stats = new Stats ( output ) ; final Runnable task = new Runnable ( ) { public void run ( ) { try { while ( running . get ( ) ) { stats . collectStats ( ) ; Thread . sleep ( 1000 ) ; } stats . close ( ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; } } } ; final Thread worker = new Thread ( task ) ; worker . start ( ) ; SigInt . register ( ( ) - > running . set ( false ) ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; } } public void parseArgs ( final String [ ] args ) throws ParseException { options = new Options ( ) ; options . addOption ( null , "vmstat" , false , "Format transport stats in vmstat format." ) ; options . addOption ( null , "console" , false , "Dump raw stats to the console." ) ; options . addOption ( null , "netstat" , false , "Format channel info in netstat format." ) ; options . addOption ( null , "csv" , false , "Format transport stats as comma separated values." ) ; options . addOption ( null , "file" , true , "Output file for csv format stats." ) ; options . addOption ( "h" , "help" , false , "Display help message." ) ; final CommandLineParser parser = new GnuParser ( ) ; final CommandLine command = parser . parse ( options , args ) ; final String opt ; if ( command . hasOption ( "help" ) ) { System . out . println ( options . toString ( ) ) ; System . exit ( 0 ) ; } output = new StatsConsoleOutput ( ) ; if ( command . hasOption ( "vmstat" ) ) { output = new StatsVmStatOutput ( ) ; } else if ( command . hasOption ( "console" ) ) { output = new StatsConsoleOutput ( ) ; } else if ( command . hasOption ( "netstat" ) ) { output = new StatsNetstatOutput ( ) ; } else if ( command . hasOption ( "csv" ) ) { if ( command . hasOption ( "file" ) ) { file = command . getOptionValue ( "file" , null ) ; } output = new StatsCsvOutput ( file ) ; } } public static void main ( final String [ ] args ) { new StatsDriver ( args ) ; } }
package uk . co . real_logic . aeron . tools ; import uk . co . real_logic . aeron . tools . RateController . IntervalInternal ; public class MessagesAtMessagesPerSecondInterval extends RateControllerInterval { private final double goalMessagesPerSecond ; private final long messages ; public MessagesAtMessagesPerSecondInterval ( final long messages , final double messagesPerSecond ) { this . goalMessagesPerSecond = messagesPerSecond ; this . messages = messages ; } public double messagesPerSecond ( ) { return goalMessagesPerSecond ; } public long messages ( ) { return messages ; } IntervalInternal makeInternal ( final RateController rateController ) throws Exception { return rateController . new MessagesAtMessagesPerSecondInternal ( rateController , messages , goalMessagesPerSecond ) ; } }
package uk . co . real_logic . aeron . tools ; public class SubscriberStats extends TransportStats { private long hwm ; public SubscriberStats ( final String channel ) { parseChannel ( channel ) ; active = true ; } public void setHWM ( final long hwm ) { if ( hwm != this . hwm ) { this . hwm = hwm ; active = true ; } } public String toString ( ) { final String s = String . format ( "%1$5s %2$8d %3$8d %4$10s:%5$5d %6$s%7$s %8$8s\n" , proto , pos , hwm , host , port , "0x" , sessionId , active ? "ACTIVE" : "INACTIVE" ) ; active = false ; return s ; } }
package uk . co . real_logic . aeron . tools ; import org . apache . commons . cli . ParseException ; import uk . co . real_logic . aeron . * ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . agrona . CloseHelper ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . collections . Int2ObjectHashMap ; import uk . co . real_logic . agrona . collections . Long2ObjectHashMap ; import uk . co . real_logic . agrona . concurrent . SigInt ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Random ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . locks . ReentrantReadWriteLock ; import java . util . logging . Logger ; public class ThwackerTool implements InactiveConnectionHandler , NewConnectionHandler { static { if ( System . getProperty ( "java.util.logging.SimpleFormatter.format" ) == null ) { System . setProperty ( "java.util.logging.SimpleFormatter.format" , "%5$s%n" ) ; } if ( System . getProperty ( "aeron.dir.delete.on.exit" ) == null ) { System . setProperty ( "aeron.dir.delete.on.exit" , "true" ) ; } if ( System . getProperty ( "aeron.publication.linger.timeout" ) == null ) { System . setProperty ( "aeron.publication.linger.timeout" , "1000" ) ; } if ( System . getProperty ( "aeron.term.buffer.length" ) == null ) { System . setProperty ( "aeron.term.buffer.length" , "65536" ) ; } } private static final Logger LOG = Logger . getLogger ( ThwackerTool . class . getName ( ) ) ; private static final int FRAGMENT_LIMIT = 10 ; private static final int RETRY_LIMIT = 100000 ; private static final int CONTROL_SID = 9876 ; private static final int DEFAULT_BUFFER_SIZE = 1024 * 100 ; private CountDownLatch allDone = null ; private MediaDriver driver = null ; private Aeron aeron = null ; private ThwackingElement [ ] pubs = null ; private ThwackingElement [ ] subs = null ; private ThwackingElement ctrlPub = null ; private ThwackingElement ctrlSub = null ; private boolean running = false ; private boolean active = false ; private ArrayList < Thread > thwackerThreads = null ; private String channel ; private int port ; private int numberOfPublications ; private int numberOfSubscriptions ; private boolean useChannelPerPub ; private boolean useEmbeddedDriver ; private boolean useSameStreamID ; private boolean useVerifiableMessageStream ; private int createThreadCount = 1 ; private int deleteThreadCount = 1 ; private int senderThreadCount = 1 ; private int receiverThreadCount = 1 ; private int iterations ; private int duration ; private int maxSize ; private int minSize ; public static void main ( final String [ ] args ) { new ThwackerTool ( args ) ; } public ThwackerTool ( final String [ ] args ) { final ThwackerOptions opts = new ThwackerOptions ( ) ; try { if ( opts . parseArgs ( args ) != 0 ) { opts . printHelp ( "ThwackerTool" ) ; System . exit ( - 1 ) ; } } catch ( final ParseException e ) { opts . printHelp ( "ThwackerTool" ) ; System . exit ( - 1 ) ; } createAndInitObjects ( opts ) ; createAndStartThreads ( ) ; run ( duration , iterations ) ; reportMessageCounts ( ) ; cleanUp ( ) ; } public void createAndInitObjects ( final ThwackerOptions opts ) { populateOptions ( opts ) ; driver = useEmbeddedDriver ? MediaDriver . launch ( ) : null ; pubs = new ThwackingElement [ numberOfPublications ] ; subs = new ThwackingElement [ numberOfSubscriptions ] ; populateArrays ( ) ; SigInt . register ( ( ) - > this . running = false ) ; final Aeron . Context ctx = new Aeron . Context ( ) ; ctx . mediaDriverTimeout ( 9999999999L ) ; ctx . inactiveConnectionHandler ( this ) ; ctx . newConnectionHandler ( this ) ; aeron = Aeron . connect ( ctx ) ; active = true ; running = true ; final int totalWorkerThreadCount = createThreadCount * 2 + deleteThreadCount * 2 + senderThreadCount + receiverThreadCount ; allDone = new CountDownLatch ( totalWorkerThreadCount ) ; ctrlSub = new ThwackingElement ( channel + ":" + port , CONTROL_SID , useVerifiableMessageStream , true ) ; ctrlPub = new ThwackingElement ( channel + ":" + port , CONTROL_SID , useVerifiableMessageStream , false ) ; ctrlSub . tryAddSub ( ) ; ctrlPub . tryAddPub ( ) ; thwackerThreads = new ArrayList < > ( ) ; } public void populateOptions ( final ThwackerOptions opts ) { channel = opts . channel ( ) ; port = opts . port ( ) ; numberOfPublications = opts . elements ( ) ; numberOfSubscriptions = opts . elements ( ) ; useChannelPerPub = opts . channelPerPub ( ) ; useEmbeddedDriver = opts . embeddedDriver ( ) ; useSameStreamID = opts . sameSID ( ) ; useVerifiableMessageStream = opts . verifiable ( ) ; createThreadCount = opts . adders ( ) ; deleteThreadCount = opts . removers ( ) ; senderThreadCount = opts . senders ( ) ; receiverThreadCount = 1 ; iterations = opts . iterations ( ) ; duration = opts . duration ( ) ; maxSize = opts . maxMsgSize ( ) ; minSize = opts . minMsgSize ( ) ; } public void populateArrays ( ) { int port ; for ( int i = 0 ; i < pubs . length ; i ++ ) { port = useChannelPerPub ? this . port + i : this . port ; pubs [ i ] = new ThwackingElement ( channel + ":" + port , useSameStreamID ? 0 : i , useVerifiableMessageStream , false ) ; } for ( int i = 0 ; i < subs . length ; i ++ ) { port = useChannelPerPub ? this . port + i : this . port ; subs [ i ] = new ThwackingElement ( channel + ":" + port , useSameStreamID ? 0 : i , useVerifiableMessageStream , true ) ; } } public void reportMessageCounts ( ) { int sent ; int rcvd ; for ( int i = 0 ; i < pubs . length ; i ++ ) { sent = pubs [ i ] . msgCount . get ( ) ; LOG . info ( "Publication " + i + " sent messages:" + sent ) ; rcvd = subs [ i ] . msgCount . get ( ) ; LOG . info ( "Subscription " + i + " received messages:" + rcvd ) ; } LOG . info ( "Control Publication sent messages:" + ctrlPub . msgCount . get ( ) ) ; LOG . info ( "Control Subscription received messages:" + ctrlSub . msgCount . get ( ) ) ; } public void createAndStartThreads ( ) { LOG . fine ( "Creating and starting threads" ) ; for ( int i = 0 ; i < createThreadCount ; i ++ ) { thwackerThreads . add ( new Thread ( this : : createSubs ) ) ; thwackerThreads . add ( new Thread ( this : : createPubs ) ) ; } for ( int i = 0 ; i < deleteThreadCount ; i ++ ) { thwackerThreads . add ( new Thread ( this : : deleteSubs ) ) ; thwackerThreads . add ( new Thread ( this : : deletePubs ) ) ; } for ( int i = 0 ; i < receiverThreadCount ; i ++ ) { thwackerThreads . add ( new Thread ( this : : receiveOnSubs ) ) ; } for ( int i = 0 ; i < senderThreadCount ; i ++ ) { thwackerThreads . add ( i , new Thread ( this : : sendOnRandomPub ) ) ; } for ( int i = 0 ; i < thwackerThreads . size ( ) ; i ++ ) { thwackerThreads . get ( i ) . start ( ) ; } } public void run ( final int duration , int iterations ) { boolean alwaysOn = true ; if ( iterations > 1 ) { alwaysOn = false ; iterations *= 2 ; } for ( int i = 0 ; i < iterations ; i ++ ) { try { if ( ! alwaysOn ) { if ( active ) { active = false ; LOG . fine ( "Thwacking Stopped" ) ; Thread . sleep ( 3000 ) ; } else { active = true ; LOG . fine ( "Thwacking Started" ) ; Thread . sleep ( duration ) ; } } else { Thread . sleep ( duration ) ; } } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } } running = false ; } public void cleanUp ( ) { try { allDone . await ( ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } LOG . info ( "All finished, Closing now!" ) ; for ( int i = 0 ; i < thwackerThreads . size ( ) ; i ++ ) { try { thwackerThreads . get ( i ) . join ( ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } } cleanUpArray ( pubs ) ; cleanUpArray ( subs ) ; ctrlPub . close ( ) ; ctrlSub . close ( ) ; aeron . close ( ) ; CloseHelper . quietClose ( driver ) ; } public void cleanUpArray ( final ThwackingElement [ ] arr ) { for ( final ThwackingElement elem : arr ) { elem . close ( ) ; } } public void createPubs ( ) { final Random rand = SeedableThreadLocalRandom . current ( ) ; while ( running ) { if ( active ) { final int i = rand . nextInt ( numberOfPublications ) ; final ThwackingElement pub = pubs [ i ] ; pub . tryAddPub ( ) ; } Thread . yield ( ) ; } allDone . countDown ( ) ; LOG . fine ( "CreatePubs all done!" ) ; } public void deletePubs ( ) { final Random rand = SeedableThreadLocalRandom . current ( ) ; int i ; ThwackingElement pub ; while ( running ) { if ( active ) { i = rand . nextInt ( numberOfPublications ) ; pub = pubs [ i ] ; pub . tryRemovePub ( ) ; } Thread . yield ( ) ; } allDone . countDown ( ) ; LOG . fine ( "DeletePubs all done!" ) ; } public void sendOnRandomPub ( ) { final Random rand = SeedableThreadLocalRandom . current ( ) ; int i ; ThwackingElement pub ; final long threadId = Thread . currentThread ( ) . getId ( ) ; LOG . fine ( "Sending thread " + threadId + " started!" ) ; while ( running ) { i = rand . nextInt ( numberOfPublications ) ; pub = pubs [ i ] ; pub . trySendMessage ( threadId ) ; ctrlPub . trySendMessage ( threadId ) ; Thread . yield ( ) ; } allDone . countDown ( ) ; LOG . fine ( "Sending thread " + threadId + " all done!" ) ; } public void createSubs ( ) { final Random rand = SeedableThreadLocalRandom . current ( ) ; int i ; ThwackingElement sub ; while ( running ) { if ( active ) { i = rand . nextInt ( numberOfSubscriptions ) ; sub = subs [ i ] ; sub . tryAddSub ( ) ; } Thread . yield ( ) ; } allDone . countDown ( ) ; LOG . fine ( "CreateSubs all done!" ) ; } public void deleteSubs ( ) { final Random rand = SeedableThreadLocalRandom . current ( ) ; int i ; ThwackingElement sub ; while ( running ) { if ( active ) { i = rand . nextInt ( numberOfSubscriptions ) ; sub = subs [ i ] ; sub . tryRemoveSub ( ) ; } try { Thread . sleep ( 1 ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } Thread . yield ( ) ; } allDone . countDown ( ) ; LOG . fine ( "DeleteSubs all done!" ) ; } public void receiveOnSubs ( ) { while ( running ) { for ( final ThwackingElement s : subs ) { s . tryGetMessages ( ) ; } Thread . yield ( ) ; ctrlSub . tryGetMessages ( ) ; } allDone . countDown ( ) ; LOG . fine ( "RecSubs all done!" ) ; } public void onInactiveConnection ( final String channel , final int streamId , final int sessionId , final long position ) { LOG . fine ( "ON INACTIVE ::: " + channel + streamId + sessionId + position ) ; } public void onNewConnection ( final String channel , final int streamId , final int sessionId , final long position , final String sourceIdentity ) { LOG . fine ( "ON NEW CONNECTION ::: " + channel + streamId + sessionId + position + sourceIdentity ) ; } public class Handler { private final ThwackingElement sub ; public Handler ( final ThwackingElement e ) { sub = e ; } public void messageHandler ( final DirectBuffer buffer , final int offset , final int length , final Header header ) { MessageStream ms = null ; final int verifyLength = length - Long . BYTES ; final long threadId = buffer . getLong ( offset + verifyLength ) ; if ( useVerifiableMessageStream ) { if ( MessageStream . isVerifiable ( buffer , offset ) ) { final int sessionId = header . sessionId ( ) ; if ( sessionId == sub . lastSessionId && threadId == sub . lastThreadId ) { ms = sub . cachedMessageStream ; } if ( ms == null ) { Long2ObjectHashMap < MessageStream > threadIdMap = sub . streamMap . get ( sessionId ) ; if ( threadIdMap == null ) { threadIdMap = new Long2ObjectHashMap < > ( ) ; sub . streamMap . put ( sessionId , threadIdMap ) ; } ms = threadIdMap . get ( threadId ) ; if ( ms == null ) { ms = new MessageStream ( ) ; threadIdMap . put ( threadId , ms ) ; } } sub . cachedMessageStream = ms ; sub . lastSessionId = sessionId ; sub . lastThreadId = threadId ; try { ms . putNext ( buffer , offset , verifyLength ) ; } catch ( final Exception e ) { if ( ! e . getMessage ( ) . contains ( "but was expecting 0" ) ) { LOG . warning ( e . getMessage ( ) + " StreamID" + header . streamId ( ) + ":" + header . sessionId ( ) + ":" + threadId ) ; } } } } sub . msgCount . incrementAndGet ( ) ; } } private class ThwackingElement { private ThreadLocal < UnsafeBuffer > buffer = null ; private Publication pub ; private Subscription sub ; private MessageStream ms ; private final String channel ; private final int streamId ; private final AtomicInteger msgCount ; private final boolean verify ; private AtomicBoolean isActive ; private final ReentrantReadWriteLock lock ; private FragmentHandler msgHandler = null ; private ThreadLocal < Boolean > previousSendFailed = null ; private ThreadLocal < Integer > bytesSent = null ; private Int2ObjectHashMap < Long2ObjectHashMap < MessageStream > > streamMap = null ; private MessageStream cachedMessageStream ; private ThreadLocal < MessageStream > senderStream = null ; private int lastSessionId ; private long lastThreadId ; ThwackingElement ( final String chan , final int stId , final boolean verifiable , final boolean createSubscriber ) { channel = chan ; streamId = stId ; verify = verifiable ; buffer = ThreadLocal . withInitial ( ( ) - > new UnsafeBuffer ( ByteBuffer . allocateDirect ( DEFAULT_BUFFER_SIZE ) ) ) ; isActive = new AtomicBoolean ( false ) ; lock = new ReentrantReadWriteLock ( ) ; msgCount = new AtomicInteger ( 0 ) ; if ( createSubscriber ) { msgHandler = new FragmentAssemblyAdapter ( new Handler ( this ) : : messageHandler ) ; streamMap = new Int2ObjectHashMap < > ( ) ; } else { senderStream = new ThreadLocal < > ( ) ; bytesSent = new ThreadLocal < > ( ) ; previousSendFailed = ThreadLocal . withInitial ( ( ) - > false ) ; } } boolean tryAddPub ( ) { boolean added = false ; if ( lock . writeLock ( ) . tryLock ( ) ) { if ( ! isActive . get ( ) ) { pub = aeron . addPublication ( this . channel , this . streamId ) ; isActive . set ( true ) ; added = true ; LOG . fine ( "Added pub " + streamId ) ; } lock . writeLock ( ) . unlock ( ) ; } return added ; } boolean tryAddSub ( ) { boolean added = false ; if ( lock . writeLock ( ) . tryLock ( ) ) { if ( ! isActive . get ( ) ) { sub = aeron . addSubscription ( this . channel , this . streamId ) ; isActive . set ( true ) ; added = true ; LOG . fine ( "Added sub " + streamId ) ; } lock . writeLock ( ) . unlock ( ) ; } return added ; } boolean tryRemovePub ( ) { boolean removed = false ; if ( lock . writeLock ( ) . tryLock ( ) ) { if ( isActive . get ( ) ) { pub . close ( ) ; isActive . set ( false ) ; removed = true ; pub = null ; LOG . fine ( "Removed pub " + streamId ) ; } lock . writeLock ( ) . unlock ( ) ; } return removed ; } boolean tryRemoveSub ( ) { boolean removed = false ; if ( lock . writeLock ( ) . tryLock ( ) ) { if ( isActive . get ( ) ) { sub . close ( ) ; isActive . set ( false ) ; removed = true ; sub = null ; LOG . fine ( "Removed sub " + streamId ) ; } lock . writeLock ( ) . unlock ( ) ; } return removed ; } int tryGetMessages ( ) { int rc = - 1 ; if ( sub != null ) { if ( lock . writeLock ( ) . tryLock ( ) ) { if ( isActive . get ( ) ) { rc = sub . poll ( this . msgHandler , FRAGMENT_LIMIT ) ; LOG . fine ( "called poll on sub " + streamId ) ; } lock . writeLock ( ) . unlock ( ) ; } } return rc ; } long trySendMessage ( final long threadId ) { MessageStream ms = senderStream . get ( ) ; if ( ms == null ) { try { ms = new MessageStream ( minSize , maxSize , verify ) ; } catch ( final Exception e ) { throw new RuntimeException ( e ) ; } senderStream . set ( ms ) ; } int retryCount = 0 ; long rc = 0 ; if ( lock . readLock ( ) . tryLock ( ) ) { if ( isActive . get ( ) ) { if ( ! previousSendFailed . get ( ) ) { try { final int sent = ms . getNext ( buffer . get ( ) ) ; buffer . get ( ) . putLong ( sent , threadId ) ; bytesSent . set ( sent + Long . BYTES ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; } } do { try { rc = pub . offer ( buffer . get ( ) , 0 , bytesSent . get ( ) ) ; retryCount ++ ; } catch ( final Exception e ) { e . printStackTrace ( ) ; LOG . fine ( "BytesSent: " + bytesSent . get ( ) ) ; } } while ( rc < 0 && retryCount < RETRY_LIMIT && running ) ; if ( rc >= 0 ) { if ( previousSendFailed . get ( ) ) { } previousSendFailed . set ( false ) ; msgCount . incrementAndGet ( ) ; } else { previousSendFailed . set ( true ) ; } } lock . readLock ( ) . unlock ( ) ; } return rc ; } void close ( ) { if ( pub != null ) { pub . close ( ) ; } if ( sub != null ) { sub . close ( ) ; } isActive = null ; ms = null ; } } }
package uk . co . real_logic . aeron . tools ; import uk . co . real_logic . aeron . tools . RateController . IntervalInternal ; public class SecondsAtBitsPerSecondInterval extends RateControllerInterval { private final long goalBitsPerSecond ; private final double seconds ; public SecondsAtBitsPerSecondInterval ( final double seconds , final long bitsPerSecond ) { this . goalBitsPerSecond = bitsPerSecond ; this . seconds = seconds ; } public long bitsPerSecond ( ) { return goalBitsPerSecond ; } public double seconds ( ) { return seconds ; } IntervalInternal makeInternal ( final RateController rateController ) throws Exception { return rateController . new SecondsAtBitsPerSecondInternal ( rateController , seconds , goalBitsPerSecond ) ; } }
package uk . co . real_logic . aeron . tools ; import org . apache . commons . cli . ParseException ; import org . junit . Before ; import org . junit . Test ; import org . mockito . Mockito ; import org . mockito . MockitoAnnotations ; import java . io . BufferedReader ; import java . io . StringReader ; import static org . hamcrest . CoreMatchers . both ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . nullValue ; import static org . hamcrest . Matchers . * ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . core . Is . is ; import static org . junit . Assert . assertThat ; import static org . mockito . Mockito . doReturn ; public class PubSubOptionsTest { private PubSubOptions opts ; @ Before public void setUp ( ) { MockitoAnnotations . initMocks ( this ) ; opts = new PubSubOptions ( ) ; } @ Test public void help ( ) throws Exception { final String [ ] args = { "--help" } ; assertThat ( opts . parseArgs ( args ) , is ( 1 ) ) ; } @ Test public void helpShorthand ( ) throws Exception { final String [ ] args = { "-h" } ; assertThat ( opts . parseArgs ( args ) , is ( 1 ) ) ; } @ Test public void threadsShorthandValid ( ) throws Exception { final String [ ] args = { "-t" , "1234" } ; opts . parseArgs ( args ) ; assertThat ( opts . threads ( ) , is ( 1234 ) ) ; } @ Test public void threadsLonghandValid ( ) throws Exception { final String [ ] args = { "--threads" , "1234" } ; opts . parseArgs ( args ) ; assertThat ( opts . threads ( ) , is ( 1234 ) ) ; } @ Test ( expected = ParseException . class ) public void threadsInvalid ( ) throws Exception { final String [ ] args = { "-t" , "asdf" } ; opts . parseArgs ( args ) ; } @ Test ( expected = ParseException . class ) public void threadsLonghandInvalid ( ) throws Exception { final String [ ] args = { "--threads" , "-1000" } ; opts . parseArgs ( args ) ; } @ Test public void iterations ( ) throws Exception { final String [ ] args = { "--iterations" , "1234" } ; opts . parseArgs ( args ) ; assertThat ( opts . iterations ( ) , is ( 1234L ) ) ; } @ Test public void messages ( ) throws Exception { final String [ ] args = { "--messages" , "1234" } ; opts . parseArgs ( args ) ; assertThat ( opts . messages ( ) , is ( 1234L ) ) ; } @ Test public void messagesShorthand ( ) throws Exception { final String [ ] args = { "-m" , "1234" } ; opts . parseArgs ( args ) ; assertThat ( opts . messages ( ) , is ( 1234L ) ) ; } @ Test public void randomSeed ( ) throws Exception { final String [ ] args = { "--seed" , "1234" } ; opts . parseArgs ( args ) ; assertThat ( opts . randomSeed ( ) , is ( 1234L ) ) ; } @ Test public void driverEmbedded ( ) throws Exception { final String [ ] args = { "--driver" , "embedded" } ; opts . parseArgs ( args ) ; assertThat ( opts . useEmbeddedDriver ( ) , is ( true ) ) ; } @ Test public void driverExternal ( ) throws Exception { final String [ ] args = { "--driver" , "external" } ; opts . parseArgs ( args ) ; assertThat ( opts . useEmbeddedDriver ( ) , is ( false ) ) ; } @ Test public void inputStreamStdin ( ) throws Exception { final String [ ] args = { "--input" , "stdin" } ; opts . parseArgs ( args ) ; assertThat ( opts . input ( ) , equalTo ( System . in ) ) ; } @ Test public void inputStreamRandomShorthand ( ) throws Exception { final String [ ] args = { "-i" , "null" } ; opts . parseArgs ( args ) ; assertThat ( opts . input ( ) , is ( nullValue ( ) ) ) ; } @ Test public void inputStreamDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: default input stream should be null." , opts . input ( ) , is ( nullValue ( ) ) ) ; } @ Test public void outputStreamDefaultNull ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default output stream should be null" , opts . output ( ) , is ( nullValue ( ) ) ) ; } @ Test public void outputStreamSetNull ( ) throws Exception { final String [ ] args = { "-o" , "NULL" } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Output stream should be null when set to the string 'null'" , opts . output ( ) , is ( nullValue ( ) ) ) ; } @ Test public void outputStreamStdout ( ) throws Exception { final String [ ] args = { "--output" , "StdOut" } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Expected output to be the standard out" , opts . output ( ) , equalTo ( System . out ) ) ; } @ Test public void outputStreamStderr ( ) throws Exception { final String [ ] args = { "--output" , "stderr" } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Expected output to be standard error." , opts . output ( ) , equalTo ( System . err ) ) ; } @ Test public void channel ( ) throws Exception { final String [ ] args = { "--channels" , "udp://127.0.0.1:12345" } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Exactly one channel." , opts . channels ( ) . size ( ) , is ( 1 ) ) ; final ChannelDescriptor cd = opts . channels ( ) . get ( 0 ) ; final int [ ] streamIds = cd . streamIdentifiers ( ) ; assertThat ( "FAIL: Exactly one stream identifier on the channel." , streamIds . length , is ( 1 ) ) ; assertThat ( "FAIL: Channel is udp://127.0.0.1:12345" , cd . channel ( ) , is ( "udp://127.0.0.1:12345" ) ) ; assertThat ( "FAIL: Stream ID is 1" , cd . streamIdentifiers ( ) [ 0 ] , is ( 1 ) ) ; } @ Test public void channelWithStreamId ( ) throws Exception { final String [ ] args = { "--channels" , "udp://127.0.0.1:12345#100" } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Exactly one channel." , opts . channels ( ) . size ( ) , is ( 1 ) ) ; final ChannelDescriptor cd = opts . channels ( ) . get ( 0 ) ; final int [ ] streamIds = cd . streamIdentifiers ( ) ; assertThat ( "FAIL: Exactly one stream identifier on the channel." , streamIds . length , is ( 1 ) ) ; assertThat ( "FAIL: Channel is udp://127.0.0.1:12345" , cd . channel ( ) , is ( "udp://127.0.0.1:12345" ) ) ; assertThat ( "FAIL: Stream ID is 100" , cd . streamIdentifiers ( ) [ 0 ] , is ( 100 ) ) ; } @ Test public void channelWithPortRange ( ) throws Exception { final String [ ] args = { "--channels" , "udp://127.0.0.1:12345-12347" } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Expected 3 channels." , opts . channels ( ) . size ( ) , is ( 3 ) ) ; assertThat ( "FAIL: Channel 1 incorrect." , opts . channels ( ) . get ( 0 ) . channel ( ) , is ( "udp://127.0.0.1:12345" ) ) ; assertThat ( "FAIL: Channel 2 incorrect" , opts . channels ( ) . get ( 1 ) . channel ( ) , is ( "udp://127.0.0.1:12346" ) ) ; assertThat ( "FAIL: Channel 3 incorrect" , opts . channels ( ) . get ( 2 ) . channel ( ) , is ( "udp://127.0.0.1:12347" ) ) ; } @ Test public void channelWithStreamIdRange ( ) throws Exception { final String [ ] args = { "--channels" , "udp://127.0.0.1:12345#100-102" } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Expected 1 channel." , opts . channels ( ) . size ( ) , is ( 1 ) ) ; final ChannelDescriptor cd = opts . channels ( ) . get ( 0 ) ; assertThat ( "FAIL: Expected 3 stream IDs on channel." , cd . streamIdentifiers ( ) . length , is ( 3 ) ) ; assertThat ( "FAIL: stream-id 1 is wrong value." , cd . streamIdentifiers ( ) [ 0 ] , is ( 100 ) ) ; assertThat ( "FAIL: Stream-id 2 is wrong value." , cd . streamIdentifiers ( ) [ 1 ] , is ( 101 ) ) ; assertThat ( "FAIL: Stream-id 3 is wrong value." , cd . streamIdentifiers ( ) [ 2 ] , is ( 102 ) ) ; } @ Test public void channelCsvWithPortAndStreamIdRange ( ) throws Exception { ChannelDescriptor cd ; final String [ ] args = { "--channels" , "udp://127.0.0.1:5000-5001#1-2,udp://224.9.10.11:6000-6001#600-601,udp://192.168.0.1:7000-7001#700-701" } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Expected 6 channels" , opts . channels ( ) . size ( ) , is ( 6 ) ) ; cd = opts . channels ( ) . get ( 0 ) ; assertThat ( "FAIL: Wrong address for channel 1" , cd . channel ( ) , is ( "udp://127.0.0.1:5000" ) ) ; assertThat ( "FAIL: Wrong number of stream IDs on channel 1" , cd . streamIdentifiers ( ) . length , is ( 2 ) ) ; cd = opts . channels ( ) . get ( 1 ) ; assertThat ( "FAIL: Wrong address for channel 2" , cd . channel ( ) , is ( "udp://127.0.0.1:5001" ) ) ; assertThat ( "FAIL: Wrong number of stream IDs on channel 2" , cd . streamIdentifiers ( ) . length , is ( 2 ) ) ; cd = opts . channels ( ) . get ( 2 ) ; assertThat ( "FAIL: Wrong address for channel 3" , cd . channel ( ) , is ( "udp://224.9.10.11:6000" ) ) ; assertThat ( "FAIL: Wrong number of stream IDs on channel 3" , cd . streamIdentifiers ( ) . length , is ( 2 ) ) ; cd = opts . channels ( ) . get ( 3 ) ; assertThat ( "FAIL: Wrong address for channel 4" , cd . channel ( ) , is ( "udp://224.9.10.11:6001" ) ) ; assertThat ( "FAIL: Wrong number of stream IDs on channel 4" , cd . streamIdentifiers ( ) . length , is ( 2 ) ) ; cd = opts . channels ( ) . get ( 4 ) ; assertThat ( "FAIL: Wrong address for channel 5" , cd . channel ( ) , is ( "udp://192.168.0.1:7000" ) ) ; assertThat ( "FAIL: Wrong number of stream IDs on channel 5" , cd . streamIdentifiers ( ) . length , is ( 2 ) ) ; cd = opts . channels ( ) . get ( 5 ) ; assertThat ( "FAIL: Wrong address for channel 6" , cd . channel ( ) , is ( "udp://192.168.0.1:7001" ) ) ; assertThat ( "FAIL: Wrong number of stream IDs on channel 6" , cd . streamIdentifiers ( ) . length , is ( 2 ) ) ; } @ Test public void channelIPv6 ( ) throws Exception { ChannelDescriptor cd ; final String [ ] args = { "--channels" , "udp://[fe80::1234:2345:3456:4567]:12345#5" } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Expected 1 channel" , opts . channels ( ) . size ( ) , is ( 1 ) ) ; cd = opts . channels ( ) . get ( 0 ) ; assertThat ( "FAIL wrong address for channel 1" , cd . channel ( ) , is ( "udp://[fe80::1234:2345:3456:4567]:12345" ) ) ; } @ Test public void channelAeronUnicastIPv4 ( ) throws Exception { ChannelDescriptor cd ; final String [ ] args = { "--channels" , "aeron:udp?remote=192.168.14.101:10000-10001|local=192.168.14.102#5" } ; opts . parseArgs ( args ) ; assertThat ( opts . channels ( ) . size ( ) , is ( 2 ) ) ; cd = opts . channels ( ) . get ( 0 ) ; assertThat ( "FAIL: wrong address for channel 1" , cd . channel ( ) , is ( "aeron:udp?remote=192.168.14.101:10000|local=192.168.14.102" ) ) ; cd = opts . channels ( ) . get ( 1 ) ; assertThat ( "FAIL: wrong address for channel 2" , cd . channel ( ) , is ( "aeron:udp?remote=192.168.14.101:10001|local=192.168.14.102" ) ) ; } @ Test public void channelAeronUnicastIPv6 ( ) throws Exception { ChannelDescriptor cd ; final String [ ] args = { "--channels" , "aeron:udp?remote=[::1]:12345|local=[::1]" } ; opts . parseArgs ( args ) ; assertThat ( opts . channels ( ) . size ( ) , is ( 1 ) ) ; cd = opts . channels ( ) . get ( 0 ) ; assertThat ( "FAIL: wrong address for channel 1" , cd . channel ( ) , is ( "aeron:udp?remote=[::1]:12345|local=[::1]" ) ) ; } @ Test public void numberOfStreams ( ) throws Exception { final String [ ] args = { "--channels" , "udp://localhost:12345#1-10,udp://localhost:12345#11" } ; opts . parseArgs ( args ) ; assertThat ( opts . numberOfStreams ( ) , is ( 11 ) ) ; } @ Test public void numberOfStreamsAeronUri ( ) throws Exception { final String [ ] args = { "--channels" , "aeron:udp?group=224.10.20.21:12345#1-10|interface=127.0.0.1," + "aeron:udp?remote=localhost:13333#1|local=127.0.0.1" } ; opts . parseArgs ( args ) ; assertThat ( opts . numberOfStreams ( ) , is ( 11 ) ) ; } @ Test public void messageSizes ( ) throws Exception { final String [ ] args = { "--size" , "100" } ; opts . parseArgs ( args ) ; final MessageSizePattern p = opts . messageSizePattern ( ) ; assertThat ( p . getNext ( ) , is ( 100 ) ) ; } @ Test public void messageSizeShortHand ( ) throws Exception { final String [ ] args = { "-s" , "100" } ; opts . parseArgs ( args ) ; final MessageSizePattern p = opts . messageSizePattern ( ) ; assertThat ( p . getNext ( ) , is ( 100 ) ) ; } @ Test public void messageSizeRange ( ) throws Exception { final String [ ] args = { "--size" , "101-102" } ; opts . parseArgs ( args ) ; final MessageSizePattern p = opts . messageSizePattern ( ) ; assertThat ( p . getNext ( ) , both ( greaterThanOrEqualTo ( 101 ) ) . and ( lessThanOrEqualTo ( 102 ) ) ) ; } @ Test public void messageNumberAndSize ( ) throws Exception { final String [ ] args = { "--size" , "1@100" } ; opts . parseArgs ( args ) ; final MessageSizePattern p = opts . messageSizePattern ( ) ; assertThat ( p . getNext ( ) , is ( 100 ) ) ; } @ Test public void messageNumberAndRange ( ) throws Exception { final String [ ] args = { "--size" , "1@101-102" } ; opts . parseArgs ( args ) ; final MessageSizePattern p = opts . messageSizePattern ( ) ; assertThat ( p . getNext ( ) , both ( greaterThanOrEqualTo ( 101 ) ) . and ( lessThanOrEqualTo ( 102 ) ) ) ; } @ Test public void messageNumberAndRangeCsv ( ) throws Exception { final String [ ] args = { "--size" , "1@100,1@101-102,98@1000" } ; opts . parseArgs ( args ) ; final MessageSizePattern p = opts . messageSizePattern ( ) ; assertThat ( p . getNext ( ) , is ( 100 ) ) ; assertThat ( p . getNext ( ) , both ( greaterThanOrEqualTo ( 101 ) ) . and ( lessThanOrEqualTo ( 102 ) ) ) ; assertThat ( p . getNext ( ) , is ( 1000 ) ) ; } @ Test public void messageSizeBytesSuffix ( ) throws Exception { final String [ ] args = { "--size" , "1@100B,1@101b" } ; opts . parseArgs ( args ) ; final MessageSizePattern p = opts . messageSizePattern ( ) ; assertThat ( p . getNext ( ) , is ( 100 ) ) ; assertThat ( p . getNext ( ) , is ( 101 ) ) ; } @ Test public void messageSizeKilobytesSuffix ( ) throws Exception { final String [ ] args = { "--size" , "1@100K,1@101k,1@102KB,1@103kb" } ; opts . parseArgs ( args ) ; final MessageSizePattern p = opts . messageSizePattern ( ) ; assertThat ( p . getNext ( ) , is ( 100 * 1024 ) ) ; assertThat ( p . getNext ( ) , is ( 101 * 1024 ) ) ; assertThat ( p . getNext ( ) , is ( 102 * 1024 ) ) ; assertThat ( p . getNext ( ) , is ( 103 * 1024 ) ) ; } @ Test public void messageSizeMegabytesSuffix ( ) throws Exception { final String [ ] args = { "--size" , "1@100M,1@101m,1@102MB,1@103mb" } ; opts . parseArgs ( args ) ; final MessageSizePattern p = opts . messageSizePattern ( ) ; assertThat ( p . getNext ( ) , is ( 100 * 1024 * 1024 ) ) ; assertThat ( p . getNext ( ) , is ( 101 * 1024 * 1024 ) ) ; assertThat ( p . getNext ( ) , is ( 102 * 1024 * 1024 ) ) ; assertThat ( p . getNext ( ) , is ( 103 * 1024 * 1024 ) ) ; } @ Test public void messageSizeRangesWithSuffixes ( ) throws Exception { final String [ ] args = { "--size" , "1@1023B-1KB,1@1023KB-1MB" } ; opts . parseArgs ( args ) ; final MessageSizePattern p = opts . messageSizePattern ( ) ; assertThat ( p . getNext ( ) , both ( greaterThanOrEqualTo ( 1023 ) ) . and ( lessThanOrEqualTo ( ( 1024 ) ) ) ) ; assertThat ( p . getNext ( ) , both ( greaterThanOrEqualTo ( 1023 * 1024 ) ) . and ( lessThanOrEqualTo ( 1024 * 1024 ) ) ) ; } @ Test public void rateMaximum ( ) throws Exception { final String [ ] args = { "--rate" , "max" } ; opts . parseArgs ( args ) ; assertThat ( opts . rateIntervals ( ) . size ( ) , is ( 1 ) ) ; final RateControllerInterval interval = opts . rateIntervals ( ) . get ( 0 ) ; assertThat ( interval , instanceOf ( SecondsAtBitsPerSecondInterval . class ) ) ; final SecondsAtBitsPerSecondInterval sub = ( SecondsAtBitsPerSecondInterval ) interval ; assertThat ( sub . seconds ( ) , is ( ( double ) Long . MAX_VALUE ) ) ; assertThat ( sub . bitsPerSecond ( ) , is ( Long . MAX_VALUE ) ) ; } @ Test public void rateMbps ( ) throws Exception { final String [ ] args = { "--rate" , "1Gbps" } ; opts . parseArgs ( args ) ; assertThat ( opts . rateIntervals ( ) . size ( ) , is ( 1 ) ) ; final RateControllerInterval interval = opts . rateIntervals ( ) . get ( 0 ) ; assertThat ( interval , instanceOf ( SecondsAtBitsPerSecondInterval . class ) ) ; final SecondsAtBitsPerSecondInterval sub = ( SecondsAtBitsPerSecondInterval ) interval ; assertThat ( sub . seconds ( ) , is ( ( double ) Long . MAX_VALUE ) ) ; assertThat ( sub . bitsPerSecond ( ) , is ( 1_000_000_000L ) ) ; } @ Test public void rateMessagesPerSecond ( ) throws Exception { final String [ ] args = { "--rate" , "100mps" } ; opts . parseArgs ( args ) ; assertThat ( opts . rateIntervals ( ) . size ( ) , is ( 1 ) ) ; final RateControllerInterval interval = opts . rateIntervals ( ) . get ( 0 ) ; assertThat ( interval , instanceOf ( SecondsAtMessagesPerSecondInterval . class ) ) ; final SecondsAtMessagesPerSecondInterval sub = ( SecondsAtMessagesPerSecondInterval ) interval ; assertThat ( sub . seconds ( ) , is ( ( double ) Long . MAX_VALUE ) ) ; assertThat ( sub . messagesPerSecond ( ) , is ( 100D ) ) ; } @ Test ( expected = ParseException . class ) public void rateNotValid ( ) throws Exception { final String [ ] args = { "--rate" , "1.21 Giga Watts" } ; opts . parseArgs ( args ) ; } @ Test public void rateMessagesAtBitsPerSecond ( ) throws Exception { final String [ ] args = { "--rate" , "100m@0.5Mbps" } ; opts . parseArgs ( args ) ; assertThat ( opts . rateIntervals ( ) . size ( ) , is ( 1 ) ) ; final RateControllerInterval interval = opts . rateIntervals ( ) . get ( 0 ) ; assertThat ( interval , instanceOf ( MessagesAtBitsPerSecondInterval . class ) ) ; final MessagesAtBitsPerSecondInterval sub = ( MessagesAtBitsPerSecondInterval ) interval ; assertThat ( sub . messages ( ) , is ( 100L ) ) ; assertThat ( sub . bitsPerSecond ( ) , is ( 500000L ) ) ; } @ Test public void rateMessagesAtMessagesPerSecond ( ) throws Exception { final String [ ] args = { "--rate" , "10m@1mps" } ; opts . parseArgs ( args ) ; assertThat ( opts . rateIntervals ( ) . size ( ) , is ( 1 ) ) ; final RateControllerInterval interval = opts . rateIntervals ( ) . get ( 0 ) ; assertThat ( interval , instanceOf ( MessagesAtMessagesPerSecondInterval . class ) ) ; final MessagesAtMessagesPerSecondInterval sub = ( MessagesAtMessagesPerSecondInterval ) interval ; assertThat ( sub . messages ( ) , is ( 10L ) ) ; assertThat ( sub . messagesPerSecond ( ) , is ( 1D ) ) ; } @ Test public void rateSecondsAtBitsPerSecond ( ) throws Exception { final String [ ] args = { "--rate" , "10.4s@1.5Kbps" } ; opts . parseArgs ( args ) ; assertThat ( opts . rateIntervals ( ) . size ( ) , is ( 1 ) ) ; final RateControllerInterval interval = opts . rateIntervals ( ) . get ( 0 ) ; assertThat ( interval , instanceOf ( SecondsAtBitsPerSecondInterval . class ) ) ; final SecondsAtBitsPerSecondInterval sub = ( SecondsAtBitsPerSecondInterval ) interval ; assertThat ( sub . seconds ( ) , is ( 10.4D ) ) ; assertThat ( sub . bitsPerSecond ( ) , is ( 1500L ) ) ; } @ Test public void rateSecondsAtMessagesPerSecond ( ) throws Exception { final String [ ] args = { "--rate" , "11s@100mps" } ; opts . parseArgs ( args ) ; assertThat ( opts . rateIntervals ( ) . size ( ) , is ( 1 ) ) ; final RateControllerInterval interval = opts . rateIntervals ( ) . get ( 0 ) ; assertThat ( interval , instanceOf ( SecondsAtMessagesPerSecondInterval . class ) ) ; final SecondsAtMessagesPerSecondInterval sub = ( SecondsAtMessagesPerSecondInterval ) interval ; assertThat ( sub . seconds ( ) , is ( 11D ) ) ; assertThat ( sub . messagesPerSecond ( ) , is ( 100D ) ) ; } @ Test public void rateCsv ( ) throws Exception { final String [ ] args = { "--rate" , "100m@0.5mps,10s@1.5Mbps,10s@100mps,50m@100bps" } ; opts . parseArgs ( args ) ; assertThat ( opts . rateIntervals ( ) . size ( ) , is ( 4 ) ) ; RateControllerInterval interval = opts . rateIntervals ( ) . get ( 0 ) ; assertThat ( interval , instanceOf ( MessagesAtMessagesPerSecondInterval . class ) ) ; final MessagesAtMessagesPerSecondInterval sub1 = ( MessagesAtMessagesPerSecondInterval ) interval ; assertThat ( sub1 . messages ( ) , is ( 100L ) ) ; assertThat ( sub1 . messagesPerSecond ( ) , is ( 0.5D ) ) ; interval = opts . rateIntervals ( ) . get ( 1 ) ; assertThat ( interval , instanceOf ( SecondsAtBitsPerSecondInterval . class ) ) ; final SecondsAtBitsPerSecondInterval sub2 = ( SecondsAtBitsPerSecondInterval ) interval ; assertThat ( sub2 . seconds ( ) , is ( 10D ) ) ; assertThat ( sub2 . bitsPerSecond ( ) , is ( 1_500_000L ) ) ; interval = opts . rateIntervals ( ) . get ( 2 ) ; assertThat ( interval , instanceOf ( SecondsAtMessagesPerSecondInterval . class ) ) ; final SecondsAtMessagesPerSecondInterval sub3 = ( SecondsAtMessagesPerSecondInterval ) interval ; assertThat ( sub3 . seconds ( ) , is ( 10D ) ) ; assertThat ( sub3 . messagesPerSecond ( ) , is ( 100D ) ) ; interval = opts . rateIntervals ( ) . get ( 3 ) ; assertThat ( interval , instanceOf ( MessagesAtBitsPerSecondInterval . class ) ) ; final MessagesAtBitsPerSecondInterval sub4 = ( MessagesAtBitsPerSecondInterval ) interval ; assertThat ( sub4 . messages ( ) , is ( 50L ) ) ; assertThat ( sub4 . bitsPerSecond ( ) , is ( 100L ) ) ; } @ Test public void sessionId ( ) throws Exception { final String [ ] args = { "--session" , "1000" } ; assertThat ( "FAIL: useSessionId needs to default to false" , opts . useSessionId ( ) , is ( false ) ) ; opts . parseArgs ( args ) ; assertThat ( opts . sessionId ( ) , is ( 1000 ) ) ; assertThat ( "FAIL: After successfully setting a session ID, useSessionId should return true." , opts . useSessionId ( ) , is ( true ) ) ; } @ Test public void sessionIdDefault ( ) throws Exception { final String [ ] args = { "--session" , "default" } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: using default session ID means useSessionId should return false." , opts . useSessionId ( ) , is ( false ) ) ; } @ Test public void sessionIdFailure ( ) { final String [ ] args = { "--session" , "fails" } ; boolean exceptionThrown = false ; opts . useSessionId ( true ) ; try { opts . parseArgs ( args ) ; } catch ( final ParseException ex ) { exceptionThrown = true ; } assertThat ( "FAIL: parseArgs should have thrown a ParseException for malformed session ID" , exceptionThrown , is ( true ) ) ; assertThat ( "FAIL: invalid session ID input should cause useSessionId to return false." , opts . useSessionId ( ) , is ( false ) ) ; } @ Test public void verifyOn ( ) throws Exception { final String [ ] args = { "--verify" , "Yes" } ; opts . parseArgs ( args ) ; assertThat ( opts . verify ( ) , is ( true ) ) ; } @ Test public void verifyOff ( ) throws Exception { final String [ ] args = { "--verify" , "No" } ; opts . parseArgs ( args ) ; assertThat ( opts . verify ( ) , is ( false ) ) ; } @ Test public void verifyDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --verify should be true" , opts . verify ( ) , is ( true ) ) ; } @ Test ( expected = ParseException . class ) public void verifyException ( ) throws Exception { final String [ ] args = { "--verify" , "schmerify" } ; opts . parseArgs ( args ) ; } @ Test public void defaultsFile ( ) throws Exception { final PubSubOptions spyOpts = Mockito . spy ( opts ) ; final String text = "-c udp://192.168.0.100:3000#5" ; final StringReader reader = new StringReader ( text ) ; final BufferedReader br = new BufferedReader ( reader ) ; doReturn ( br ) . when ( spyOpts ) . newBufferedFileReader ( "filename" ) ; final String [ ] args = { "--defaults" , "filename" } ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . channels ( ) . size ( ) , is ( 1 ) ) ; final ChannelDescriptor cd = spyOpts . channels ( ) . get ( 0 ) ; assertThat ( cd . channel ( ) , is ( "udp://192.168.0.100:3000" ) ) ; assertThat ( cd . streamIdentifiers ( ) . length , is ( 1 ) ) ; assertThat ( cd . streamIdentifiers ( ) [ 0 ] , is ( 5 ) ) ; } @ Test public void defaultsFileMultipleLines ( ) throws Exception { final PubSubOptions spyOpts = Mockito . spy ( opts ) ; final String nl = System . lineSeparator ( ) ; final String text = "# This is a comment line and will be ignored." + nl + " " + nl + "-s 100 -r 100mps" + nl + " -t 3 " + nl + "--verify no" + nl + "-o stdout" + nl + nl ; final StringReader reader = new StringReader ( text ) ; final BufferedReader br = new BufferedReader ( reader ) ; doReturn ( br ) . when ( spyOpts ) . newBufferedFileReader ( "textfile" ) ; final String [ ] args = { "--defaults" , "textfile" } ; spyOpts . parseArgs ( args ) ; assertThat ( "FAIL: Minimum size of messages incorrect." , spyOpts . messageSizePattern ( ) . minimum ( ) , is ( 100 ) ) ; assertThat ( spyOpts . rateIntervals ( ) . size ( ) , is ( 1 ) ) ; assertThat ( spyOpts . rateIntervals ( ) . get ( 0 ) , instanceOf ( SecondsAtMessagesPerSecondInterval . class ) ) ; final SecondsAtMessagesPerSecondInterval sub = ( SecondsAtMessagesPerSecondInterval ) spyOpts . rateIntervals ( ) . get ( 0 ) ; assertThat ( sub . seconds ( ) , is ( ( double ) Long . MAX_VALUE ) ) ; assertThat ( sub . messagesPerSecond ( ) , is ( 100D ) ) ; assertThat ( spyOpts . threads ( ) , is ( 3 ) ) ; assertThat ( spyOpts . verify ( ) , is ( false ) ) ; assertThat ( spyOpts . output ( ) , equalTo ( System . out ) ) ; } @ Test public void defaultsOverriddenByCmdline ( ) throws Exception { final PubSubOptions spyOpts = Mockito . spy ( opts ) ; final String text = "--verify no --threads 2 --output stdout" ; final BufferedReader br = new BufferedReader ( new StringReader ( text ) ) ; doReturn ( br ) . when ( spyOpts ) . newBufferedFileReader ( "filename" ) ; final String [ ] args = { "--output" , "stderr" , "--defaults" , "filename" , "--verify" , "yes" } ; spyOpts . parseArgs ( args ) ; assertThat ( "FAIL: Should be overridden by args" , spyOpts . verify ( ) , is ( true ) ) ; assertThat ( "FAIL: Should be picked up from the defaults file" , spyOpts . threads ( ) , is ( 2 ) ) ; assertThat ( "FAIL: Should be overridden by args" , spyOpts . output ( ) , equalTo ( System . err ) ) ; } }
package uk . co . real_logic . aeron . tools ; import org . apache . commons . cli . ParseException ; import uk . co . real_logic . aeron . * ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . aeron . exceptions . DriverTimeoutException ; import uk . co . real_logic . aeron . exceptions . RegistrationException ; import uk . co . real_logic . aeron . tools . SeedableThreadLocalRandom . SeedCallback ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . collections . Int2ObjectHashMap ; import uk . co . real_logic . agrona . concurrent . BackoffIdleStrategy ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import uk . co . real_logic . agrona . concurrent . SigInt ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . io . IOException ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . concurrent . ThreadLocalRandom ; import java . util . concurrent . TimeUnit ; import java . util . logging . Logger ; import static java . nio . ByteBuffer . allocateDirect ; public class SubscriberTool implements RateReporter . Stats , SeedCallback , RateReporter . Callback { static { if ( System . getProperty ( "java.util.logging.SimpleFormatter.format" ) == null ) { System . setProperty ( "java.util.logging.SimpleFormatter.format" , "%5$s%n" ) ; } } private static final Logger LOG = Logger . getLogger ( SubscriberTool . class . getName ( ) ) ; private boolean shuttingDown ; private final PubSubOptions options = new PubSubOptions ( ) ; private SubscriberThread subscribers [ ] ; private static final String CONTROL_CHANNEL = "udp://localhost:" ; private static final int CONTROL_PORT_START = 62777 ; private static final int CONTROL_STREAMID = 9999 ; private static final int CONTROL_ACTION_NEW_CONNECTION = 0 ; private static final int CONTROL_ACTION_INACTIVE_CONNECTION = 1 ; private static final int CHANNEL_NAME_MAX_LEN = 256 ; public static void main ( final String [ ] args ) { final SubscriberTool subTool = new SubscriberTool ( ) ; try { if ( 1 == subTool . options . parseArgs ( args ) ) { subTool . options . printHelp ( "SubscriberTool" ) ; System . exit ( - 1 ) ; } } catch ( final ParseException e ) { LOG . severe ( e . getMessage ( ) ) ; subTool . options . printHelp ( "SubscriberTool" ) ; System . exit ( - 1 ) ; } sanityCheckOptions ( subTool . options ) ; SeedableThreadLocalRandom . setSeedCallback ( subTool ) ; SigInt . register ( ( ) - > subTool . shuttingDown = true ) ; MediaDriver driver = null ; if ( subTool . options . useEmbeddedDriver ( ) ) { driver = MediaDriver . launch ( ) ; } final Thread subThreads [ ] = new Thread [ subTool . options . threads ( ) ] ; subTool . subscribers = new SubscriberThread [ subTool . options . threads ( ) ] ; for ( int i = 0 ; i < subTool . options . threads ( ) ; i ++ ) { subTool . subscribers [ i ] = subTool . new SubscriberThread ( i ) ; subThreads [ i ] = new Thread ( subTool . subscribers [ i ] ) ; subThreads [ i ] . start ( ) ; } final RateReporter rateReporter = new RateReporter ( subTool , subTool ) ; try { for ( final Thread subThread : subThreads ) { subThread . join ( ) ; } rateReporter . close ( ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } if ( null != driver ) { driver . close ( ) ; } try { subTool . options . close ( ) ; } catch ( final IOException e ) { e . printStackTrace ( ) ; } final long verifiableMessages = subTool . verifiableMessages ( ) ; final long nonVerifiableMessages = subTool . nonVerifiableMessages ( ) ; final long bytesReceived = subTool . bytes ( ) ; LOG . info ( String . format ( "Exiting. Received %d messages (%d bytes) total. %d verifiable and %d non-verifiable." , verifiableMessages + nonVerifiableMessages , bytesReceived , verifiableMessages , nonVerifiableMessages ) ) ; } private static void sanityCheckOptions ( final PubSubOptions options ) { if ( options . threads ( ) > 1 ) { if ( options . output ( ) != null ) { LOG . warning ( "File output may be non-deterministic when multiple subscriber threads are used." ) ; } } } public long verifiableMessages ( ) { long totalMessages = 0 ; for ( final SubscriberThread subscriber : subscribers ) { totalMessages += subscriber . verifiableMessagesReceived ( ) ; } return totalMessages ; } public long bytes ( ) { long totalBytes = 0 ; for ( final SubscriberThread subscriber : subscribers ) { totalBytes += subscriber . bytesReceived ( ) ; } return totalBytes ; } public long nonVerifiableMessages ( ) { long totalMessages = 0 ; for ( final SubscriberThread subscriber : subscribers ) { totalMessages += subscriber . nonVerifiableMessagesReceived ( ) ; } return totalMessages ; } public long setSeed ( long seed ) { if ( options . randomSeed ( ) != 0 ) { seed = options . randomSeed ( ) ; } LOG . info ( String . format ( "Thread %s using random seed %d." , Thread . currentThread ( ) . getName ( ) , seed ) ) ; return seed ; } class SubscriptionWithHandler { final Subscription subscription ; final FragmentHandler handler ; SubscriptionWithHandler ( Subscription subscription , FragmentHandler handler ) { this . subscription = subscription ; this . handler = handler ; } } class SubscriberThread implements Runnable , InactiveConnectionHandler , NewConnectionHandler , RateController . Callback { final int threadId ; private long nonVerifiableMessagesReceived ; private long verifiableMessagesReceived ; private long bytesReceived ; private byte [ ] bytesToWrite = new byte [ 1 ] ; private final Aeron . Context ctx ; private final Aeron aeron ; private final UnsafeBuffer controlBuffer = new UnsafeBuffer ( allocateDirect ( 4 + 4 + CHANNEL_NAME_MAX_LEN + 4 + 4 ) ) ; private final RateController rateController ; private final MessageStreamHandler controlHandler ; final SubscriptionWithHandler subscriptions [ ] ; final SubscriptionWithHandler activeSubscriptions [ ] ; int activeSubscriptionsLength = 0 ; private final Publication controlPublication ; private Subscription controlSubscription ; private final int controlSessionId = ThreadLocalRandom . current ( ) . nextInt ( ) ; private String controlChannel ; private final HashMap < String , Int2ObjectHashMap < Int2ObjectHashMap < MessageStream > > > messageStreams = new HashMap < > ( ) ; private int lastBytesReceived ; @ SuppressWarnings ( "resource" ) public SubscriberThread ( final int threadId ) { this . threadId = threadId ; RateController rc = null ; try { rc = new RateController ( this , options . rateIntervals ( ) , options . iterations ( ) ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } rateController = rc ; ctx = new Aeron . Context ( ) . inactiveConnectionHandler ( this ) . newConnectionHandler ( this ) . errorHandler ( ( throwable ) - > { throwable . printStackTrace ( ) ; if ( throwable instanceof DriverTimeoutException ) { LOG . severe ( "Driver does not appear to be running or has been unresponsive for ten seconds." ) ; System . exit ( - 1 ) ; } } ) . mediaDriverTimeout ( 10000 ) ; aeron = Aeron . connect ( ctx ) ; controlHandler = new MessageStreamHandler ( "control_channel" , CONTROL_STREAMID , null ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { controlChannel = CONTROL_CHANNEL + Integer . toString ( CONTROL_PORT_START + i ) ; controlHandler . channel ( controlChannel ) ; try { controlSubscription = aeron . addSubscription ( controlChannel , CONTROL_STREAMID ) ; break ; } catch ( RegistrationException ignore ) { } } if ( controlSubscription == null ) { LOG . severe ( "Couldn't create control channel." ) ; System . exit ( 1 ) ; } controlPublication = aeron . addPublication ( controlChannel , CONTROL_STREAMID , controlSessionId ) ; final ArrayList < SubscriptionWithHandler > subscriptionsList = new ArrayList < > ( ) ; int streamIdx = 0 ; for ( int i = 0 ; i < options . channels ( ) . size ( ) ; i ++ ) { final ChannelDescriptor channel = options . channels ( ) . get ( i ) ; for ( int j = 0 ; j < channel . streamIdentifiers ( ) . length ; j ++ ) { if ( ( streamIdx % options . threads ( ) ) == this . threadId ) { LOG . info ( String . format ( "subscriber-thread %d subscribing to: %s#%d" , threadId , channel . channel ( ) , channel . streamIdentifiers ( ) [ j ] ) ) ; Int2ObjectHashMap < Int2ObjectHashMap < MessageStream > > streamIdMap = messageStreams . get ( channel . channel ( ) ) ; if ( streamIdMap == null ) { streamIdMap = new Int2ObjectHashMap < > ( ) ; messageStreams . put ( channel . channel ( ) , streamIdMap ) ; } Int2ObjectHashMap < MessageStream > sessionIdMap = streamIdMap . get ( channel . streamIdentifiers ( ) [ j ] ) ; if ( sessionIdMap == null ) { sessionIdMap = new Int2ObjectHashMap < > ( ) ; streamIdMap . put ( channel . streamIdentifiers ( ) [ j ] , sessionIdMap ) ; } final FragmentHandler dataHandler = new FragmentAssemblyAdapter ( new MessageStreamHandler ( channel . channel ( ) , channel . streamIdentifiers ( ) [ j ] , sessionIdMap ) : : onMessage ) ; final Subscription subscription = aeron . addSubscription ( channel . channel ( ) , channel . streamIdentifiers ( ) [ j ] ) ; final SubscriptionWithHandler subAndHandler = new SubscriptionWithHandler ( subscription , dataHandler ) ; subscriptionsList . add ( subAndHandler ) ; } streamIdx ++ ; } } subscriptions = new SubscriptionWithHandler [ subscriptionsList . size ( ) ] ; subscriptionsList . toArray ( subscriptions ) ; activeSubscriptions = new SubscriptionWithHandler [ subscriptions . length ] ; activeSubscriptionsLength = 0 ; } public long bytesReceived ( ) { return bytesReceived ; } public long nonVerifiableMessagesReceived ( ) { return nonVerifiableMessagesReceived ; } public long verifiableMessagesReceived ( ) { return verifiableMessagesReceived ; } private void makeActive ( final String channel , final int streamId ) { for ( int i = 0 ; i < activeSubscriptionsLength ; i ++ ) { if ( ( activeSubscriptions [ i ] . subscription . streamId ( ) == streamId ) && ( activeSubscriptions [ i ] . subscription . channel ( ) . equals ( channel ) ) ) { return ; } } SubscriptionWithHandler sub = null ; for ( final SubscriptionWithHandler subWithHandler : subscriptions ) { if ( ( subWithHandler . subscription . streamId ( ) == streamId ) && ( subWithHandler . subscription . channel ( ) . equals ( channel ) ) ) { sub = subWithHandler ; } } if ( sub == null ) { throw new RuntimeException ( "Tried to activate a subscription we weren't supposed to be subscribed to." ) ; } activeSubscriptions [ activeSubscriptionsLength ] = sub ; activeSubscriptionsLength ++ ; } private void makeInactive ( final String channel , final int streamId ) { for ( int i = 0 ; i < activeSubscriptionsLength ; i ++ ) { if ( ( activeSubscriptions [ i ] . subscription . streamId ( ) == streamId ) && ( activeSubscriptions [ i ] . subscription . channel ( ) . equals ( channel ) ) ) { activeSubscriptions [ i ] = activeSubscriptions [ activeSubscriptionsLength - 1 ] ; activeSubscriptionsLength -- ; return ; } } throw new RuntimeException ( "Tried to de-activate a subscription that was not active." ) ; } public class MessageStreamHandler { private String channel ; private final int streamId ; private MessageStream cachedMessageStream ; private int lastSessionId = - 1 ; private final Int2ObjectHashMap < MessageStream > sessionIdMap ; private final OutputStream os = options . output ( ) ; public MessageStreamHandler ( final String channel , final int streamId , final Int2ObjectHashMap < MessageStream > sessionIdMap ) { this . channel = channel ; this . streamId = streamId ; this . sessionIdMap = sessionIdMap ; } public void channel ( String channel ) { this . channel = channel ; } public void onControl ( final DirectBuffer buffer , final int offset , final int length , final Header header ) { if ( header . sessionId ( ) != controlSessionId ) { return ; } final int action = buffer . getInt ( offset ) ; final int channelLen = buffer . getInt ( offset + 4 ) ; final byte [ ] channelNameBytes = new byte [ channelLen ] ; buffer . getBytes ( offset + 8 , channelNameBytes , 0 , channelLen ) ; final String channel = new String ( channelNameBytes ) ; final int streamId = buffer . getInt ( offset + 8 + channelLen ) ; final int sessionId = buffer . getInt ( offset + 12 + channelLen ) ; if ( action == CONTROL_ACTION_NEW_CONNECTION ) { LOG . info ( String . format ( "NEW CONNECTION: channel \"%s\", stream %d, session %d" , channel , streamId , sessionId ) ) ; final Int2ObjectHashMap < Int2ObjectHashMap < MessageStream > > streamIdMap = messageStreams . get ( channel ) ; if ( streamIdMap == null ) { LOG . warning ( "New connection detected for channel we were not subscribed to." ) ; } else { final Int2ObjectHashMap < MessageStream > sessionIdMap = streamIdMap . get ( streamId ) ; if ( sessionIdMap == null ) { LOG . warning ( "New connection detected for channel we were not subscribed to." ) ; } else { MessageStream ms = sessionIdMap . get ( sessionId ) ; if ( ms == null ) { ms = new MessageStream ( ) ; sessionIdMap . put ( sessionId , ms ) ; } } } makeActive ( channel , streamId ) ; } else if ( action == CONTROL_ACTION_INACTIVE_CONNECTION ) { LOG . info ( String . format ( "INACTIVE CONNECTION: channel \"%s\", stream %d, session %d" , channel , streamId , sessionId ) ) ; final Int2ObjectHashMap < Int2ObjectHashMap < MessageStream > > streamIdMap = messageStreams . get ( channel ) ; if ( streamIdMap == null ) { LOG . warning ( "Inactive connection detected for unknown connection." ) ; } else { final Int2ObjectHashMap < MessageStream > sessionIdMap = streamIdMap . get ( streamId ) ; if ( sessionIdMap == null ) { LOG . warning ( "Inactive connection detected for unknown connection." ) ; } else { final MessageStream ms = sessionIdMap . get ( sessionId ) ; if ( ms == null ) { LOG . warning ( "Inactive connection detected for unknown connection." ) ; } else { sessionIdMap . remove ( sessionId ) ; if ( sessionIdMap . isEmpty ( ) ) { makeInactive ( channel , streamId ) ; } } } } } else { LOG . warning ( String . format ( "Unknown control message type (%d) received." , action ) ) ; } } public void onMessage ( final DirectBuffer buffer , final int offset , final int length , final Header header ) { bytesReceived += length ; MessageStream ms = null ; if ( MessageStream . isVerifiable ( buffer , offset ) ) { final int sessionId = header . sessionId ( ) ; verifiableMessagesReceived ++ ; if ( sessionId == lastSessionId ) { ms = cachedMessageStream ; } if ( ms == null ) { ms = sessionIdMap . get ( sessionId ) ; if ( ms == null ) { ms = new MessageStream ( ) ; sessionIdMap . put ( sessionId , ms ) ; } } cachedMessageStream = ms ; lastSessionId = sessionId ; try { ms . putNext ( buffer , offset , length ) ; } catch ( final Exception e ) { LOG . warning ( "Channel " + channel + ":" + streamId + "[" + sessionId + "]: " + e . getMessage ( ) ) ; } } else { nonVerifiableMessagesReceived ++ ; } if ( os != null ) { final int payloadOffset = ( ms == null ? 0 : ms . payloadOffset ( buffer , offset ) ) ; final int lengthToWrite = length - payloadOffset ; if ( lengthToWrite > bytesToWrite . length ) { bytesToWrite = new byte [ lengthToWrite ] ; } buffer . getBytes ( offset + payloadOffset , bytesToWrite , 0 , lengthToWrite ) ; try { os . write ( bytesToWrite , 0 , lengthToWrite ) ; } catch ( final IOException e ) { e . printStackTrace ( ) ; } } if ( ( nonVerifiableMessagesReceived + verifiableMessagesReceived ) == options . messages ( ) ) { shuttingDown = true ; } lastBytesReceived = length ; if ( ! rateController . next ( ) ) { shuttingDown = true ; } } } public void run ( ) { Thread . currentThread ( ) . setName ( "subscriber-thread " + threadId ) ; final IdleStrategy idleStrategy = new BackoffIdleStrategy ( 100 , 10 , TimeUnit . MICROSECONDS . toNanos ( 1 ) , TimeUnit . MICROSECONDS . toNanos ( 100 ) ) ; while ( ! shuttingDown ) { int fragmentsReceived = 0 ; while ( 0 != controlSubscription . poll ( controlHandler : : onControl , 1 ) ) { Thread . yield ( ) ; } for ( int i = 0 ; i < activeSubscriptionsLength ; i ++ ) { fragmentsReceived += activeSubscriptions [ i ] . subscription . poll ( activeSubscriptions [ i ] . handler , 1 ) ; } idleStrategy . idle ( fragmentsReceived ) ; } for ( final SubscriptionWithHandler subWithHandler : subscriptions ) { subWithHandler . subscription . close ( ) ; } controlSubscription . close ( ) ; controlPublication . close ( ) ; aeron . close ( ) ; ctx . close ( ) ; } private void enqueueControlMessage ( final int type , final String channel , final int streamId , final int sessionId ) { if ( ( streamId != CONTROL_STREAMID ) || ( ! channel . equals ( controlChannel ) ) ) { final byte [ ] channelBytes = channel . getBytes ( ) ; controlBuffer . putInt ( 0 , type ) ; controlBuffer . putInt ( 4 , channelBytes . length ) ; controlBuffer . putBytes ( 8 , channelBytes ) ; controlBuffer . putInt ( 8 + channelBytes . length , streamId ) ; controlBuffer . putInt ( 12 + channelBytes . length , sessionId ) ; while ( controlPublication . offer ( controlBuffer , 0 , 16 + channelBytes . length ) < 0L ) { Thread . yield ( ) ; } } } public void onInactiveConnection ( final String channel , final int streamId , final int sessionId , final long position ) { enqueueControlMessage ( CONTROL_ACTION_INACTIVE_CONNECTION , channel , streamId , sessionId ) ; } public void onNewConnection ( final String channel , final int streamId , final int sessionId , final long position , final String sourceIdentity ) { enqueueControlMessage ( CONTROL_ACTION_NEW_CONNECTION , channel , streamId , sessionId ) ; } public int onNext ( ) { return lastBytesReceived ; } } public void report ( final StringBuilder reportString ) { LOG . info ( reportString . toString ( ) ) ; } }
package uk . co . real_logic . aeron . tools ; import uk . co . real_logic . aeron . tools . RateController . IntervalInternal ; public class SecondsAtMessagesPerSecondInterval extends RateControllerInterval { private final double goalMessagesPerSecond ; private final double seconds ; public SecondsAtMessagesPerSecondInterval ( final double seconds , final double messagesPerSecond ) { this . goalMessagesPerSecond = messagesPerSecond ; this . seconds = seconds ; } public double messagesPerSecond ( ) { return goalMessagesPerSecond ; } public double seconds ( ) { return seconds ; } IntervalInternal makeInternal ( final RateController rateController ) throws Exception { return rateController . new SecondsAtMessagesPerSecondInternal ( rateController , seconds , goalMessagesPerSecond ) ; } }
package uk . co . real_logic . aeron . tools ; public class ChannelDescriptor { private String channel ; private int [ ] streamIds ; ChannelDescriptor ( ) { channel = null ; streamIds = null ; } public String channel ( ) { return channel ; } public void channel ( final String c ) { channel = c ; } public int [ ] streamIdentifiers ( ) { return streamIds ; } public void streamIdentifiers ( final int [ ] ids ) { streamIds = ids ; } public String toString ( ) { return channel ; } }
package uk . co . real_logic . aeron . tools ; import org . apache . commons . cli . * ; public class ThwackerOptions { private static final String NL = System . lineSeparator ( ) ; private static final String DEFAULT_VERIFIABLE_MESSAGE_STREAM = "no" ; private static final String DEFAULT_USE_SAME_SID = "no" ; private static final String DEFAULT_USE_CHANNEL_PER_PUB = "no" ; private static final String DEFAULT_USE_EMBEDDED_DRIVER = "yes" ; private static final String DEFAULT_CHANNEL = "udp://localhost" ; private static final String DEFAULT_PORT = "51234" ; private static final String DEFAULT_DURATION = "30000" ; private static final String DEFAULT_ITERATIONS = "1" ; private static final String DEFAULT_SENDERS = "1" ; private static final String DEFAULT_RECEIVERS = "1" ; private static final String DEFAULT_ADDERS = "1" ; private static final String DEFAULT_REMOVERS = "1" ; private static final String DEFAULT_ELEMENTS = "10" ; private static final String DEFAULT_MAX_MSG_SIZE = "35" ; private static final String DEFAULT_MIN_MSG_SIZE = "35" ; private static final String USAGE = "" + "Examples:" + NL + "-v no -d 10000 -e 10 -s 1 --max-size 100 --min-size 64" + NL + " Run for 10s with unverifiable messages, 10 pubs and 10 subs, 1 sending" + NL + " thread, and random message sizes from 64 to 100 bytes" ; private Options options = null ; private boolean useVerifiableMessageStream ; private boolean useSameSID ; private boolean useChannelPerPub ; private boolean useEmbeddedDriver ; private String channel ; private int port ; private int duration ; private int iterations ; private int senders ; private int receivers ; private int adders ; private int removers ; private int elements ; private int maxSize ; private int minSize ; public ThwackerOptions ( ) { options = new Options ( ) ; options . addOption ( "v" , "verify" , true , "Enable verifiable message streams [yes/no]" ) ; options . addOption ( null , "same-sid" , true , "Enable all Pubs/Subs to use same Stream ID [yes/no]" ) ; options . addOption ( null , "channel-per-pub" , true , "Enable all Pubs to use different channels [yes/no]" ) ; options . addOption ( null , "embedded" , true , "Enable use of Embedded Driver [yes/no]" ) ; options . addOption ( "c" , "channel" , true , "Set the channel" ) ; options . addOption ( "p" , "port" , true , "Set the port" ) ; options . addOption ( "d" , "duration" , true , "Time duration for \"thwacking\" in milliseconds" ) ; options . addOption ( "i" , "iterations" , true , "Number of iterations of \"thwacking\"" ) ; options . addOption ( "s" , "senders" , true , "Number of sending threads" ) ; options . addOption ( "r" , "receivers" , true , "Number of receiving threads" ) ; options . addOption ( null , "adders" , true , "Number of creating threads" ) ; options . addOption ( null , "removers" , true , "Number of deleting threads" ) ; options . addOption ( "e" , "elements" , true , "Number of Publications and Subscriptions" ) ; options . addOption ( null , "min-size" , true , "Minimum size message a Publication will send" ) ; options . addOption ( null , "max-size" , true , "Maximum size message a Publication will send" ) ; options . addOption ( "h" , "help" , false , " Print help text." ) ; useVerifiableMessageStream = false ; useSameSID = false ; useChannelPerPub = false ; useEmbeddedDriver = true ; channel = null ; port = 0 ; duration = 0 ; iterations = 0 ; senders = 0 ; receivers = 0 ; adders = 0 ; removers = 0 ; elements = 0 ; maxSize = 0 ; minSize = 0 ; } public int parseArgs ( final String [ ] args ) throws ParseException { final CommandLineParser parser = new GnuParser ( ) ; final CommandLine command = parser . parse ( options , args ) ; String opt ; if ( command . hasOption ( "help" ) ) { return 1 ; } opt = command . getOptionValue ( "verify" , DEFAULT_VERIFIABLE_MESSAGE_STREAM ) ; useVerifiableMessageStream = parseYesNo ( opt ) ; opt = command . getOptionValue ( "same-sid" , DEFAULT_USE_SAME_SID ) ; useSameSID = parseYesNo ( opt ) ; opt = command . getOptionValue ( "channel-per-pub" , DEFAULT_USE_CHANNEL_PER_PUB ) ; useChannelPerPub = parseYesNo ( opt ) ; opt = command . getOptionValue ( "channel" , DEFAULT_CHANNEL ) ; channel = parseString ( opt ) ; opt = command . getOptionValue ( "embedded" , DEFAULT_USE_EMBEDDED_DRIVER ) ; useEmbeddedDriver = parseYesNo ( opt ) ; opt = command . getOptionValue ( "port" , DEFAULT_PORT ) ; port = parsePositiveInt ( opt ) ; opt = command . getOptionValue ( "duration" , DEFAULT_DURATION ) ; duration = parsePositiveInt ( opt ) ; opt = command . getOptionValue ( "iterations" , DEFAULT_ITERATIONS ) ; iterations = parsePositiveInt ( opt ) ; opt = command . getOptionValue ( "senders" , DEFAULT_SENDERS ) ; senders = parsePositiveInt ( opt ) ; opt = command . getOptionValue ( "receivers" , DEFAULT_RECEIVERS ) ; receivers = parsePositiveInt ( opt ) ; opt = command . getOptionValue ( "adders" , DEFAULT_ADDERS ) ; adders = parsePositiveInt ( opt ) ; opt = command . getOptionValue ( "removers" , DEFAULT_REMOVERS ) ; removers = parsePositiveInt ( opt ) ; opt = command . getOptionValue ( "elements" , DEFAULT_ELEMENTS ) ; elements = parsePositiveInt ( opt ) ; opt = command . getOptionValue ( "max-size" , DEFAULT_MAX_MSG_SIZE ) ; maxSize = parsePositiveInt ( opt ) ; opt = command . getOptionValue ( "min-size" , DEFAULT_MIN_MSG_SIZE ) ; minSize = parsePositiveInt ( opt ) ; return 0 ; } public void printHelp ( final String program ) { final HelpFormatter formatter = new HelpFormatter ( ) ; formatter . printHelp ( program + " [options]" , options ) ; System . out . println ( NL + USAGE + NL ) ; } private boolean parseYesNo ( final String opt ) throws ParseException { boolean rc ; if ( "yes" . equalsIgnoreCase ( opt ) ) { rc = true ; } else if ( "no" . equalsIgnoreCase ( opt ) ) { rc = false ; } else { throw new ParseException ( "An option specified '" + opt + "' can only be 'yes' or 'no'" ) ; } return rc ; } private String parseString ( final String opt ) { return opt ; } private int parsePositiveInt ( final String opt ) throws ParseException { int rc = 0 ; try { rc = Integer . parseInt ( opt ) ; } catch ( final NumberFormatException e ) { throw new ParseException ( "An integer could not be determined from the specified option: " + opt ) ; } if ( rc < 0 ) { throw new ParseException ( "An option specified '" + opt + "' can only be a positive integer" ) ; } return rc ; } public boolean verifiable ( ) { return this . useVerifiableMessageStream ; } public boolean sameSID ( ) { return this . useSameSID ; } public boolean channelPerPub ( ) { return this . useChannelPerPub ; } public boolean embeddedDriver ( ) { return this . useEmbeddedDriver ; } public String channel ( ) { return this . channel ; } public int port ( ) { return this . port ; } public int duration ( ) { return this . duration ; } public int iterations ( ) { return this . iterations ; } public int senders ( ) { return this . senders ; } public int receivers ( ) { return this . receivers ; } public int adders ( ) { return this . adders ; } public int removers ( ) { return this . removers ; } public int elements ( ) { return this . elements ; } public int maxMsgSize ( ) { return maxSize ; } public int minMsgSize ( ) { return minSize ; } }
package uk . co . real_logic . aeron . tools ; public abstract class RateControllerInterval { protected boolean active ; protected long bitsSent ; protected long messagesSent ; protected long beginTimeNanos ; protected long endTimeNanos ; public long messagesSent ( ) { return messagesSent ; } public long bytesSent ( ) { return ( bitsSent / 8 ) ; } public long startTimeNanos ( ) { return beginTimeNanos ; } public long stopTimeNanos ( ) { return endTimeNanos ; } abstract RateController . IntervalInternal makeInternal ( RateController rateController ) throws Exception ; }
package uk . co . real_logic . aeron . tools ; import org . apache . commons . cli . * ; import uk . co . real_logic . aeron . driver . Configuration ; import uk . co . real_logic . aeron . driver . LossGenerator ; import uk . co . real_logic . agrona . concurrent . BackoffIdleStrategy ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . util . Properties ; public class MediaDriverOptions { private final Options options ; private Properties properties ; private IdleStrategy conductorIdleStrategy ; private IdleStrategy senderIdleStrategy ; private IdleStrategy receiverIdleStrategy ; private IdleStrategy sharedNetworkIdleStrategy ; private IdleStrategy sharedIdleStrategy ; private LossGenerator dataLossGenerator ; private LossGenerator controlLossGenerator ; private static final String NULL_VALUE = "null" ; public MediaDriverOptions ( ) { options = new Options ( ) . addOption ( "p" , "properties" , true , "A properties file containing Aeron options." ) . addOption ( "h" , "help" , false , "Display help message." ) . addOption ( "c" , "conductor" , true , "IdleStrategy class for the conductor thread." ) . addOption ( "s" , "sender" , true , "IdleStrategy class for the sender thread." ) . addOption ( "r" , "receiver" , true , "IdleStrategy class for the receiver thread." ) . addOption ( "n" , "network" , true , "IdleStrategy class for the shared network thread." ) . addOption ( "a" , "shared" , true , "IdleStrategy class for the shared thread." ) . addOption ( null , "data-loss" , true , "LossGenerator class for dropping incoming data." ) . addOption ( null , "control-loss" , true , "LossGenerator class for dropping incoming control data." ) ; } public int parseArgs ( final String [ ] args ) throws ParseException { final CommandLineParser parser = new GnuParser ( ) ; final CommandLine command = parser . parse ( options , args ) ; if ( command . hasOption ( "help" ) ) { return 1 ; } String senderValue = NULL_VALUE ; String receiverValue = NULL_VALUE ; String sharedNetworkValue = NULL_VALUE ; String sharedValue = NULL_VALUE ; String conductorValue = NULL_VALUE ; String dataLossValue = NULL_VALUE ; String controlLossValue = NULL_VALUE ; if ( command . hasOption ( "properties" ) ) { this . properties = parseProperties ( command . getOptionValue ( "properties" ) ) ; senderValue = properties . getProperty ( "aeron.tools.mediadriver.sender" ) ; receiverValue = properties . getProperty ( "aeron.tools.mediadriver.receiver" ) ; sharedNetworkValue = properties . getProperty ( "aeron.tools.mediadriver.network" ) ; sharedValue = properties . getProperty ( "aeron.tools.mediadriver.shared" ) ; conductorValue = properties . getProperty ( "aeron.tools.mediadriver.conductor" ) ; dataLossValue = properties . getProperty ( "aeron.tools.mediadriver.data.loss" ) ; controlLossValue = properties . getProperty ( "aeron.tools.mediadriver.control.loss" ) ; } senderIdleStrategy = parseIdleStrategy ( command . getOptionValue ( "sender" , senderValue ) ) ; receiverIdleStrategy = parseIdleStrategy ( command . getOptionValue ( "receiver" , receiverValue ) ) ; sharedNetworkIdleStrategy = parseIdleStrategy ( command . getOptionValue ( "network" , sharedNetworkValue ) ) ; sharedIdleStrategy = parseIdleStrategy ( command . getOptionValue ( "shared" , sharedValue ) ) ; conductorIdleStrategy = parseIdleStrategy ( command . getOptionValue ( "conductor" , conductorValue ) ) ; dataLossGenerator = parseLossGenerator ( command . getOptionValue ( "data-loss" , dataLossValue ) ) ; controlLossGenerator = parseLossGenerator ( command . getOptionValue ( "control-loss" , controlLossValue ) ) ; return 0 ; } public void printHelp ( final String applicationName ) { final HelpFormatter formatter = new HelpFormatter ( ) ; formatter . printHelp ( applicationName + " [options]" , options ) ; } public IdleStrategy conductorIdleStrategy ( ) { return conductorIdleStrategy ; } public void conductorIdleStrategy ( final IdleStrategy conductorIdleStrategy ) { this . conductorIdleStrategy = conductorIdleStrategy ; } public IdleStrategy senderIdleStrategy ( ) { return senderIdleStrategy ; } public void senderIdleStrategy ( final IdleStrategy senderIdleStrategy ) { this . senderIdleStrategy = senderIdleStrategy ; } public IdleStrategy receiverIdleStrategy ( ) { return receiverIdleStrategy ; } public void receiverIdleStrategy ( final IdleStrategy receiverIdleStrategy ) { this . receiverIdleStrategy = receiverIdleStrategy ; } public IdleStrategy sharedNetworkIdleStrategy ( ) { return sharedNetworkIdleStrategy ; } public void sharedNetworkIdleStrategy ( final IdleStrategy sharedNetworkIdleStrategy ) { this . sharedNetworkIdleStrategy = sharedNetworkIdleStrategy ; } public IdleStrategy sharedIdleStrategy ( ) { return sharedIdleStrategy ; } public void sharedIdleStrategy ( final IdleStrategy sharedIdleStrategy ) { this . sharedIdleStrategy = sharedIdleStrategy ; } public LossGenerator dataLossGenerator ( ) { return dataLossGenerator ; } public void dataLossGenerator ( LossGenerator lossGenerator ) { this . dataLossGenerator = lossGenerator ; } public LossGenerator controlLossGenerator ( ) { return controlLossGenerator ; } public void controlLossGenerator ( LossGenerator lossGenerator ) { this . controlLossGenerator = lossGenerator ; } public Properties properties ( ) { return properties ; } public void properties ( final Properties properties ) { this . properties = properties ; } InputStream newFileInputStream ( final String filename ) throws FileNotFoundException { return new FileInputStream ( filename ) ; } private Properties parseProperties ( final String arg ) throws ParseException { final Properties p = new Properties ( ) ; try ( final InputStream inputStream = newFileInputStream ( arg ) ) { p . load ( inputStream ) ; } catch ( final IOException ex ) { throw new ParseException ( ex . getMessage ( ) ) ; } return p ; } private IdleStrategy parseIdleStrategy ( final String arg ) throws ParseException { if ( arg == null || arg . equalsIgnoreCase ( NULL_VALUE ) ) { return null ; } IdleStrategy strategy ; if ( arg . startsWith ( BackoffIdleStrategy . class . getName ( ) ) ) { strategy = parseBackoffIdleStrategy ( arg ) ; } else { try { final Class clazz = Class . forName ( arg ) ; strategy = ( IdleStrategy ) clazz . newInstance ( ) ; } catch ( final ClassNotFoundException | IllegalAccessException | InstantiationException | ClassCastException ex ) { throw new ParseException ( "Error creating new instance of '" + arg + "': " + ex . getMessage ( ) ) ; } } return strategy ; } private IdleStrategy parseBackoffIdleStrategy ( final String arg ) throws ParseException { final int openParenIndex = arg . indexOf ( "(" ) ; long maxSpins = Configuration . AGENT_IDLE_MAX_SPINS ; long maxYields = Configuration . AGENT_IDLE_MAX_YIELDS ; long minParkPeriodNs = Configuration . AGENT_IDLE_MIN_PARK_NS ; long maxParkPeriodNs = Configuration . AGENT_IDLE_MAX_PARK_NS ; if ( openParenIndex != - 1 ) { if ( ! arg . endsWith ( ")" ) ) { throw new ParseException ( "A BackoffIdleStrategy with parameters has no matching closing parenthesis." ) ; } final String [ ] params = arg . substring ( openParenIndex + 1 , arg . length ( ) - 1 ) . split ( "," ) ; if ( params . length != 4 ) { throw new ParseException ( "A BackoffIdleStrategy must have all 4 parameters separated by commas." ) ; } maxSpins = parseLong ( params [ 0 ] . trim ( ) ) ; maxYields = parseLong ( params [ 1 ] . trim ( ) ) ; minParkPeriodNs = parseLong ( params [ 2 ] . trim ( ) ) ; maxParkPeriodNs = parseLong ( params [ 3 ] . trim ( ) ) ; } return newBackoffIdleStrategy ( maxSpins , maxYields , minParkPeriodNs , maxParkPeriodNs ) ; } private LossGenerator parseLossGenerator ( final String arg ) throws ParseException { if ( arg == null || arg . equalsIgnoreCase ( NULL_VALUE ) ) { return null ; } LossGenerator lossGenerator ; try { final Class clazz = Class . forName ( arg ) ; lossGenerator = ( LossGenerator ) clazz . newInstance ( ) ; } catch ( final ClassNotFoundException | IllegalAccessException | InstantiationException | ClassCastException ex ) { throw new ParseException ( "Error creating new instance of '" + arg + "': " + ex . getMessage ( ) ) ; } return lossGenerator ; } IdleStrategy newBackoffIdleStrategy ( final long maxSpins , final long maxYields , final long minParkPeriodNs , final long maxParkPeriodNs ) { return new BackoffIdleStrategy ( maxSpins , maxYields , minParkPeriodNs , maxParkPeriodNs ) ; } private long parseLong ( final String longValue ) throws ParseException { long value ; try { value = Long . parseLong ( longValue ) ; } catch ( final NumberFormatException ex ) { throw new ParseException ( "Could not parse '" + longValue + "' as a long value." ) ; } return value ; } }
package uk . co . real_logic . aeron . tools ; import uk . co . real_logic . agrona . concurrent . SystemNanoClock ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . locks . LockSupport ; public class RateController { private static final long WARMUP_IDLES = 5000 ; private static final long CALLIBRATION_IDLES = 50000 ; private static final long MAX_PARK_NANOS_CALLIBRATION_TIME_NANOS = 1000000000 ; private static final SystemNanoClock CLOCK = new SystemNanoClock ( ) ; private static final long PARK_NANOS ; private static final long PARK_NANOS_FUDGE_FACTOR = 2048 ; private static final long YIELD_NANOS ; private static final long YIELD_NANOS_FUDGE_FACTOR = 1024 ; private static final long TIME_NANOS ; private static final long TIME_NANOS_FUDGE_FACTOR = 2 ; private final Callback sendFunc ; private final ArrayList < IntervalInternal > intervals = new ArrayList < > ( ) ; private IntervalInternal activeInterval ; private int activeIntervalIndex ; private long messagesSent ; private long bytesSent ; private final long iterations ; private long currentIteration ; static { for ( int i = 0 ; i < WARMUP_IDLES ; i ++ ) { if ( CLOCK . nanoTime ( ) < 0 ) { throw new RuntimeException ( "Time travel is not permitted." ) ; } } final long timeStartNs = CLOCK . nanoTime ( ) ; for ( int i = 0 ; i < CALLIBRATION_IDLES ; i ++ ) { if ( CLOCK . nanoTime ( ) < 0 ) { throw new RuntimeException ( "Time travel is not permitted." ) ; } } final long timeEndNs = CLOCK . nanoTime ( ) ; TIME_NANOS = ( ( timeEndNs - timeStartNs ) / CALLIBRATION_IDLES ) * TIME_NANOS_FUDGE_FACTOR ; for ( int i = 0 ; i < WARMUP_IDLES ; i ++ ) { Thread . yield ( ) ; } final long yieldStartNs = CLOCK . nanoTime ( ) ; for ( int i = 0 ; i < CALLIBRATION_IDLES ; i ++ ) { Thread . yield ( ) ; } final long yieldEndNs = CLOCK . nanoTime ( ) ; final long yieldNs = ( ( yieldEndNs - yieldStartNs ) / CALLIBRATION_IDLES ) ; for ( int i = 0 ; i < WARMUP_IDLES ; i ++ ) { LockSupport . parkNanos ( yieldNs ) ; if ( CLOCK . nanoTime ( ) > ( yieldEndNs + MAX_PARK_NANOS_CALLIBRATION_TIME_NANOS ) ) { break ; } } final long parkStartNs = CLOCK . nanoTime ( ) ; int parkNanosLoops ; for ( parkNanosLoops = 0 ; parkNanosLoops < CALLIBRATION_IDLES ; parkNanosLoops ++ ) { LockSupport . parkNanos ( yieldNs ) ; if ( CLOCK . nanoTime ( ) > ( parkStartNs + MAX_PARK_NANOS_CALLIBRATION_TIME_NANOS ) ) { parkNanosLoops ++ ; break ; } } final long parkEndNanos = CLOCK . nanoTime ( ) ; YIELD_NANOS = yieldNs * YIELD_NANOS_FUDGE_FACTOR ; PARK_NANOS = ( ( parkEndNanos - parkStartNs ) / parkNanosLoops ) * PARK_NANOS_FUDGE_FACTOR ; } public boolean next ( ) { if ( activeInterval == null ) { return false ; } if ( ! activeInterval . active ) { activeInterval . play ( ) ; } if ( ! ( activeInterval . sendNext ( ) ) ) { if ( ++ activeIntervalIndex == intervals . size ( ) ) { if ( ++ currentIteration == iterations ) { return false ; } activeIntervalIndex = 0 ; } activeInterval = intervals . get ( activeIntervalIndex ) ; } return true ; } public interface Callback { int onNext ( ) ; } public void rewind ( ) { if ( activeInterval == null ) { return ; } intervals . forEach ( RateController . IntervalInternal : : reset ) ; activeIntervalIndex = 0 ; activeInterval = intervals . get ( 0 ) ; } private static void nanoSleep ( final long nanoseconds ) { long nanoSecondsRemaining = nanoseconds ; final long startNanos = CLOCK . nanoTime ( ) ; while ( nanoSecondsRemaining > PARK_NANOS ) { LockSupport . parkNanos ( nanoSecondsRemaining - PARK_NANOS ) ; nanoSecondsRemaining = nanoseconds - ( CLOCK . nanoTime ( ) - startNanos ) ; } while ( nanoSecondsRemaining > YIELD_NANOS ) { Thread . yield ( ) ; nanoSecondsRemaining = nanoseconds - ( CLOCK . nanoTime ( ) - startNanos ) ; } while ( nanoSecondsRemaining > TIME_NANOS ) { nanoSecondsRemaining = nanoseconds - ( CLOCK . nanoTime ( ) - startNanos ) ; } } private void addIntervals ( final List < RateControllerInterval > intervals ) throws Exception { for ( final RateControllerInterval interval : intervals ) { this . intervals . add ( interval . makeInternal ( this ) ) ; } if ( activeInterval == null ) { activeInterval = this . intervals . get ( 0 ) ; } } class MessagesAtBitsPerSecondInternal extends IntervalInternal { private final long goalBitsPerSecond ; private final long messages ; protected MessagesAtBitsPerSecondInternal ( final RateController rateController , final long messages , final long bitsPerSecond ) throws Exception { if ( messages <= 0 ) { throw new Exception ( "The number of messages in a MessagesAtBitsPerSecond interval must be >= 1." ) ; } if ( bitsPerSecond <= 0 ) { throw new Exception ( "The bits per second in a MessagesAtBitsPerSecond interval must be >= 1." ) ; } this . rateController = rateController ; this . goalBitsPerSecond = bitsPerSecond ; this . messages = messages ; } public boolean sendNext ( ) { final long sizeInBytes = rateController . sendFunc . onNext ( ) ; if ( sizeInBytes < 0 ) { stop ( ) ; return false ; } rateController . messagesSent ++ ; rateController . bytesSent += sizeInBytes ; bitsSent += ( sizeInBytes * 8 ) ; final double seconds = ( double ) bitsSent / ( double ) goalBitsPerSecond ; final long nanoSeconds = ( long ) ( seconds * 1000000000L ) ; final long sendEndTime = CLOCK . nanoTime ( ) ; nanoSleep ( nanoSeconds - ( sendEndTime - beginTimeNanos ) ) ; if ( ++ messagesSent == messages ) { stop ( ) ; return false ; } return true ; } protected IntervalInternal makeInternal ( final RateController rateController ) { return this ; } } class MessagesAtMessagesPerSecondInternal extends IntervalInternal { private final double goalMessagesPerSecond ; private final long messages ; protected MessagesAtMessagesPerSecondInternal ( final RateController rateController , final long messages , final double messagesPerSecond ) throws Exception { if ( messages <= 0 ) { throw new Exception ( "The number of messages in a MessagesAtMessagesPerSecond interval must be >= 1." ) ; } if ( messagesPerSecond <= 0 ) { throw new Exception ( "The messages per second in a MessagesAtMessagesPerSecond interval must be > 0." ) ; } this . rateController = rateController ; this . goalMessagesPerSecond = messagesPerSecond ; this . messages = messages ; } public boolean sendNext ( ) { final long sizeInBytes = rateController . sendFunc . onNext ( ) ; if ( sizeInBytes < 0 ) { stop ( ) ; return false ; } rateController . messagesSent ++ ; rateController . bytesSent += sizeInBytes ; bitsSent += ( sizeInBytes * 8 ) ; messagesSent ++ ; final double seconds = messagesSent / goalMessagesPerSecond ; final long nanoSeconds = ( long ) ( seconds * 1000000000L ) ; final long sendEndTime = CLOCK . nanoTime ( ) ; nanoSleep ( nanoSeconds - ( sendEndTime - beginTimeNanos ) ) ; if ( messagesSent == messages ) { stop ( ) ; return false ; } return true ; } protected IntervalInternal makeInternal ( final RateController rateController ) { return this ; } } class SecondsAtMessagesPerSecondInternal extends IntervalInternal { private final double goalMessagesPerSecond ; private final double seconds ; protected SecondsAtMessagesPerSecondInternal ( final RateController rateController , final double seconds , final double messagesPerSecond ) throws Exception { if ( seconds <= 0 ) { throw new Exception ( "The number of seconds in a SecondsAtMessagesPerSecond interval must be > 0." ) ; } if ( messagesPerSecond < 0 ) { throw new Exception ( "The messages per second in a SecondsAtMessagesPerSecond interval cannot be negative." ) ; } this . rateController = rateController ; this . goalMessagesPerSecond = messagesPerSecond ; this . seconds = seconds ; } public boolean sendNext ( ) { if ( goalMessagesPerSecond == 0 ) { nanoSleep ( ( long ) ( seconds * 1000000000 ) ) ; stop ( ) ; return false ; } final long sizeInBytes = rateController . sendFunc . onNext ( ) ; if ( sizeInBytes < 0 ) { stop ( ) ; return false ; } rateController . messagesSent ++ ; rateController . bytesSent += sizeInBytes ; bitsSent += ( sizeInBytes * 8 ) ; messagesSent ++ ; final double secondsWanted = messagesSent / goalMessagesPerSecond ; final long nanoSeconds = ( long ) ( secondsWanted * 1000000000L ) ; final long sendEndTime = CLOCK . nanoTime ( ) ; nanoSleep ( nanoSeconds - ( sendEndTime - beginTimeNanos ) ) ; if ( ( CLOCK . nanoTime ( ) - beginTimeNanos ) >= ( seconds * 1000000000 ) ) { stop ( ) ; return false ; } return true ; } protected IntervalInternal makeInternal ( final RateController rateController ) { return this ; } } class SecondsAtBitsPerSecondInternal extends IntervalInternal { private final long goalBitsPerSecond ; private final double seconds ; protected SecondsAtBitsPerSecondInternal ( final RateController rateController , final double seconds , final long bitsPerSecond ) throws Exception { if ( seconds <= 0 ) { throw new Exception ( "The number of seconds in a SecondsAtBitsPerSecond interval must be > 0." ) ; } if ( bitsPerSecond < 0 ) { throw new Exception ( "The bits per second in a SecondsAtBitsPerSecond interval cannot be negative." ) ; } this . rateController = rateController ; this . goalBitsPerSecond = bitsPerSecond ; this . seconds = seconds ; } public boolean sendNext ( ) { if ( goalBitsPerSecond == 0 ) { nanoSleep ( ( long ) ( seconds * 1000000000 ) ) ; stop ( ) ; return false ; } final long sizeInBytes = rateController . sendFunc . onNext ( ) ; if ( sizeInBytes < 0 ) { stop ( ) ; return false ; } rateController . messagesSent ++ ; rateController . bytesSent += sizeInBytes ; bitsSent += ( sizeInBytes * 8 ) ; messagesSent ++ ; final double secondsWanted = bitsSent / goalBitsPerSecond ; final long nanoSeconds = ( long ) ( secondsWanted * 1000000000L ) ; final long sendEndTime = CLOCK . nanoTime ( ) ; nanoSleep ( nanoSeconds - ( sendEndTime - beginTimeNanos ) ) ; if ( ( CLOCK . nanoTime ( ) - beginTimeNanos ) >= ( seconds * 1000000000 ) ) { stop ( ) ; return false ; } return true ; } protected IntervalInternal makeInternal ( final RateController rateController ) { return this ; } } public abstract class IntervalInternal extends RateControllerInterval { private final SystemNanoClock clock = new SystemNanoClock ( ) ; protected long lastBitsSent ; protected RateController rateController ; public void reset ( ) { active = false ; bitsSent = 0 ; messagesSent = 0 ; } public abstract boolean sendNext ( ) ; public void play ( ) { beginTimeNanos = clock . nanoTime ( ) ; lastBitsSent = rateController . bytesSent * 8 ; active = true ; } public void stop ( ) { endTimeNanos = clock . nanoTime ( ) ; reset ( ) ; } } public RateController ( final Callback callback , final List < RateControllerInterval > intervals , final long iterations ) throws Exception { if ( iterations <= 0 ) { throw new Exception ( "Iterations must be >= 1." ) ; } if ( callback == null ) { throw new Exception ( "Must specify a callback method." ) ; } this . sendFunc = callback ; if ( intervals == null ) { throw new Exception ( "Intervals list must not be null." ) ; } if ( intervals . isEmpty ( ) ) { throw new Exception ( "Intervals list must contain at least one interval." ) ; } addIntervals ( intervals ) ; this . iterations = iterations ; } public RateController ( final Callback callback , final List < RateControllerInterval > intervals ) throws Exception { this ( callback , intervals , 1 ) ; } public long messages ( ) { return messagesSent ; } public long bytes ( ) { return bytesSent ; } }
package uk . co . real_logic . aeron . tools ; public class PublisherStats extends TransportStats { private long limit ; public PublisherStats ( final String channel ) { parseChannel ( channel ) ; active = true ; } public void setLimit ( final long limit ) { if ( limit != this . limit ) { this . limit = limit ; active = true ; } } public String toString ( ) { final String s = String . format ( "%1$5s %2$8d %3$8d %4$10s:%5$5d %6$s%7$s %8$8s\n" , proto , pos , limit , host , port , "0x" , sessionId , active ? "ACTIVE" : "INACTIVE" ) ; active = false ; return s ; } }
package uk . co . real_logic . aeron . tools ; import org . apache . commons . cli . * ; import java . io . * ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class PubSubOptions { private static final String NL = System . lineSeparator ( ) ; private final Options options ; private boolean showUsage ; private boolean useEmbeddedDriver ; private boolean useSessionId ; private boolean useVerifiableStream ; private long randomSeed ; private long messages ; private long iterations ; private int sessionId ; private int threads ; private List < ChannelDescriptor > channels ; private int totalStreams ; private List < RateControllerInterval > rateIntervals ; private InputStream input ; private OutputStream output ; private MessageSizePattern sizePattern ; private boolean outputNeedsClose ; private boolean inputNeedsClose ; private static final String DEFAULT_CHANNEL = "udp://localhost:31111#1" ; private static final String DEFAULT_DRIVER = "external" ; private static final String DEFAULT_INPUT = "null" ; private static final String DEFAULT_ITERATIONS = "1" ; private static final String DEFAULT_MESSAGES = "unlimited" ; private static final String DEFAULT_OUTPUT = "null" ; private static final String DEFAULT_RATE = "max" ; private static final String DEFAULT_SEED = "0" ; private static final String DEFAULT_SESSION = "default" ; private static final String DEFAULT_SIZE = "32" ; private static final String DEFAULT_THREADS = "1" ; private static final String DEFAULT_VERIFY = "yes" ; private static final OptionValuesStruct DEFAULT_VALUES = new PubSubOptions . OptionValuesStruct ( DEFAULT_CHANNEL , DEFAULT_DRIVER , DEFAULT_INPUT , DEFAULT_ITERATIONS , DEFAULT_MESSAGES , DEFAULT_OUTPUT , DEFAULT_RATE , DEFAULT_SEED , DEFAULT_SESSION , DEFAULT_SIZE , DEFAULT_THREADS , DEFAULT_VERIFY ) ; public PubSubOptions ( ) { options = new Options ( ) ; options . addOption ( "c" , "channels" , true , "Create the given Aeron channels [default: " + DEFAULT_VALUES . channels + "]." ) ; options . addOption ( null , "defaults" , true , "File overriding default values for the command line options." ) ; options . addOption ( null , "driver" , true , "Use 'external' or 'embedded' Aeron driver [default: " + DEFAULT_VALUES . driver + "]." ) ; options . addOption ( "h" , "help" , false , "Display simple usage message." ) ; options . addOption ( "i" , "input" , true , "Publisher will send random bytes ('null'), " + "bytes read from stdin ('stdin'), or a file " + "(path to file) as data [default: " + DEFAULT_VALUES . input + "]." ) ; options . addOption ( null , "iterations" , true , "Run the rate sequence n times [default: " + DEFAULT_VALUES . iterations + "]." ) ; options . addOption ( "m" , "messages" , true , "Send or receive n messages before exiting [default: " + DEFAULT_VALUES . messages + "]." ) ; options . addOption ( "o" , "output" , true , "Subscriber will write the stream to the output file." ) ; options . addOption ( "r" , "rate" , true , "Send/receive rate pattern CSV list [default: " + DEFAULT_VALUES . rate + "]." ) ; options . addOption ( null , "seed" , true , "Random number generator seed." ) ; options . addOption ( null , "session" , true , "Use session id for all publishers [default: " + DEFAULT_VALUES . session + "]." ) ; options . addOption ( "s" , "size" , true , "Message payload size sequence, in bytes [default: " + DEFAULT_VALUES . size + "]." ) ; options . addOption ( "t" , "threads" , true , "Round-Robin channels acress a number of threads [default: " + DEFAULT_VALUES . threads + "]." ) ; options . addOption ( null , "usage" , false , "Display advanced usage guide." ) ; options . addOption ( null , "verify" , true , "Messages and streams are verifiable (yes|no) [default: " + DEFAULT_VALUES . verify + "]." ) ; randomSeed = 0 ; threads = 0 ; messages = 0 ; iterations = 0 ; sessionId = 0 ; totalStreams = 0 ; inputNeedsClose = false ; outputNeedsClose = false ; useEmbeddedDriver = false ; useSessionId = false ; sizePattern = null ; input = null ; output = null ; channels = new ArrayList < ChannelDescriptor > ( ) ; rateIntervals = new ArrayList < RateControllerInterval > ( ) ; } private class ChannelStruct { String prefix ; String suffix ; int portLow ; int portHigh ; public ChannelStruct ( ) { clear ( ) ; } public void clear ( ) { prefix = "" ; suffix = "" ; portLow = 0 ; portHigh = 0 ; } String getChannelWithPort ( final int port ) { return prefix + ":" + port + suffix ; } } private static final class OptionValuesStruct { final String channels ; final String driver ; final String input ; final String iterations ; final String messages ; final String output ; final String rate ; final String seed ; final String session ; final String size ; final String threads ; final String verify ; OptionValuesStruct ( final String channels , final String driver , final String input , final String iterations , final String messages , final String output , final String rate , final String seed , final String session , final String size , final String threads , final String verify ) { this . channels = channels ; this . driver = driver ; this . input = input ; this . iterations = iterations ; this . messages = messages ; this . output = output ; this . rate = rate ; this . seed = seed ; this . session = session ; this . size = size ; this . threads = threads ; this . verify = verify ; } OptionValuesStruct ( final OptionValuesStruct other ) { this . channels = other . channels ; this . driver = other . driver ; this . input = other . input ; this . iterations = other . iterations ; this . messages = other . messages ; this . output = other . output ; this . rate = other . rate ; this . seed = other . seed ; this . session = other . session ; this . size = other . size ; this . threads = other . threads ; this . verify = other . verify ; } OptionValuesStruct ( final CommandLine cmd , final OptionValuesStruct other ) { this . channels = cmd . getOptionValue ( "channels" , other . channels ) ; this . driver = cmd . getOptionValue ( "driver" , other . driver ) ; this . input = cmd . getOptionValue ( "input" , other . input ) ; this . iterations = cmd . getOptionValue ( "iterations" , other . iterations ) ; this . messages = cmd . getOptionValue ( "messages" , other . messages ) ; this . output = cmd . getOptionValue ( "output" , other . output ) ; this . rate = cmd . getOptionValue ( "rate" , other . rate ) ; this . seed = cmd . getOptionValue ( "seed" , other . seed ) ; this . session = cmd . getOptionValue ( "session" , other . session ) ; this . size = cmd . getOptionValue ( "size" , other . size ) ; this . threads = cmd . getOptionValue ( "threads" , other . threads ) ; this . verify = cmd . getOptionValue ( "verify" , other . verify ) ; } } public int parseArgs ( final String [ ] args ) throws ParseException { OptionValuesStruct defaults ; final CommandLineParser parser = new GnuParser ( ) ; final CommandLine command = parser . parse ( options , args ) ; String opt ; if ( command . hasOption ( "usage" ) ) { showUsage = true ; return 1 ; } if ( command . hasOption ( "help" ) ) { return 1 ; } defaults = DEFAULT_VALUES ; if ( command . hasOption ( "defaults" ) ) { defaults = getDefaultsFromOptionsFile ( command . getOptionValue ( "defaults" ) ) ; } opt = command . getOptionValue ( "threads" , defaults . threads ) ; threads ( parseIntCheckPositive ( opt ) ) ; opt = command . getOptionValue ( "seed" , defaults . seed ) ; randomSeed ( parseLongCheckPositive ( opt ) ) ; opt = command . getOptionValue ( "messages" , defaults . messages ) ; messages ( parseNumberOfMessages ( opt ) ) ; opt = command . getOptionValue ( "iterations" , defaults . iterations ) ; iterations ( parseIterations ( opt ) ) ; opt = command . getOptionValue ( "session" , defaults . session ) ; sessionId ( parseSessionId ( opt ) ) ; opt = command . getOptionValue ( "driver" , defaults . driver ) ; useEmbeddedDriver ( parseDriver ( opt ) ) ; opt = command . getOptionValue ( "input" , defaults . input ) ; parseInputStream ( opt ) ; opt = command . getOptionValue ( "output" , defaults . output ) ; parseOutputStream ( opt ) ; opt = command . getOptionValue ( "channels" , defaults . channels ) ; parseChannels ( opt ) ; opt = command . getOptionValue ( "rate" , defaults . rate ) ; parseRates ( opt ) ; opt = command . getOptionValue ( "size" , defaults . size ) ; parseMessageSizes ( opt ) ; opt = command . getOptionValue ( "verify" , defaults . verify ) ; parseVerify ( opt ) ; return 0 ; } public void printHelp ( final String program ) { final HelpFormatter formatter = new HelpFormatter ( ) ; formatter . printHelp ( program + " [options]" , options ) ; System . out . println ( NL + USAGE_EXAMPLES + NL ) ; if ( showUsage ) { System . out . println ( ADVANCED_GUIDE ) ; } else { System . out . println ( "Use --usage for expanded help message." ) ; } } public List < ChannelDescriptor > channels ( ) { return channels ; } public void channels ( final List < ChannelDescriptor > channels ) { this . channels = channels ; } public OutputStream output ( ) { return output ; } public void output ( final OutputStream output ) { this . output = output ; } public InputStream input ( ) { return input ; } public boolean verify ( ) { return useVerifiableStream ; } public void verify ( final boolean verify ) { useVerifiableStream = verify ; } public void input ( final InputStream input ) { this . input = input ; } public void rateIntervals ( final List < RateControllerInterval > rates ) { this . rateIntervals = rates ; } public List < RateControllerInterval > rateIntervals ( ) { return this . rateIntervals ; } public int threads ( ) { return threads ; } public void threads ( final int t ) { threads = t ; } public long messages ( ) { return this . messages ; } public void messages ( final long messages ) { this . messages = messages ; } public long iterations ( ) { return iterations ; } public long randomSeed ( ) { return randomSeed ; } public void randomSeed ( final long value ) { randomSeed = value ; } public void iterations ( final long value ) { iterations = value ; } public boolean useEmbeddedDriver ( ) { return useEmbeddedDriver ; } public void useEmbeddedDriver ( final boolean embedded ) { useEmbeddedDriver = embedded ; } public void useSessionId ( final boolean enabled ) { this . useSessionId = enabled ; } public boolean useSessionId ( ) { return this . useSessionId ; } public void sessionId ( final int id ) { this . sessionId = id ; } public int sessionId ( ) { return this . sessionId ; } public MessageSizePattern messageSizePattern ( ) { return this . sizePattern ; } public void messageSizePattern ( final MessageSizePattern pattern ) { this . sizePattern = pattern ; } public int numberOfStreams ( ) { return totalStreams ; } public void numberOfStreams ( final int value ) { totalStreams = value ; } public void close ( ) throws IOException { if ( inputNeedsClose ) { input . close ( ) ; inputNeedsClose = false ; } if ( output != null ) { output . flush ( ) ; if ( outputNeedsClose ) { output . close ( ) ; outputNeedsClose = false ; } } } private long parseNumberOfMessages ( final String m ) throws ParseException { long value = Long . MAX_VALUE ; if ( ! m . equalsIgnoreCase ( "unlimited" ) ) { value = parseLongCheckPositive ( m ) ; } return value ; } private void parseVerify ( final String verifyStr ) throws ParseException { if ( verifyStr . equalsIgnoreCase ( "no" ) ) { useVerifiableStream = false ; } else if ( verifyStr . equalsIgnoreCase ( "yes" ) ) { useVerifiableStream = true ; } else { throw new ParseException ( "The verify option '" + verifyStr + "' can only be 'yes' or 'no'" ) ; } } private int parseSessionId ( final String sid ) throws ParseException { int value = 0 ; useSessionId = false ; if ( ! sid . equalsIgnoreCase ( "default" ) ) { try { value = Integer . parseInt ( sid ) ; } catch ( final NumberFormatException ex ) { throw new ParseException ( "Could not parse session ID '" + sid + "' as an integer." ) ; } useSessionId = true ; } return value ; } private long parseIterations ( final String iterationsStr ) throws ParseException { long value = Long . MAX_VALUE ; if ( ! iterationsStr . equalsIgnoreCase ( "unlimited" ) ) { value = parseLongCheckPositive ( iterationsStr ) ; } return value ; } private boolean parseDriver ( final String useEmbeddedStr ) throws ParseException { boolean embedded ; if ( useEmbeddedStr . equalsIgnoreCase ( "external" ) ) { embedded = false ; } else if ( useEmbeddedStr . equalsIgnoreCase ( "embedded" ) ) { embedded = true ; } else { throw new ParseException ( "Invalid driver option '" + useEmbeddedStr + "'. Must be 'embedded' or 'external'" ) ; } return embedded ; } private void parseChannels ( final String csv ) throws ParseException { final ChannelStruct chan = new ChannelStruct ( ) ; int streamIdLow = 1 ; int streamIdHigh = 1 ; final String [ ] channelDescriptions = csv . split ( "," ) ; for ( int i = 0 ; i < channelDescriptions . length ; i ++ ) { final String [ ] channelComponents = channelDescriptions [ i ] . split ( "#" ) ; if ( channelComponents . length > 2 ) { throw new ParseException ( "Channel '" + channelDescriptions [ i ] + "' has too many '#' characters" ) ; } final String address = channelComponents [ 0 ] ; if ( address . startsWith ( "aeron:" ) ) { parseAeronChannelToStruct ( address , chan ) ; } else { parseRawChannelToStruct ( address , chan ) ; } if ( channelComponents . length > 1 ) { final String ids = channelComponents [ 1 ] ; final int [ ] streamIdRange = findMinAndMaxStreamIds ( ids ) ; streamIdLow = streamIdRange [ 0 ] ; streamIdHigh = streamIdRange [ 1 ] ; } else { streamIdLow = 1 ; streamIdHigh = 1 ; } if ( chan . portLow < 0 || chan . portLow > 65535 ) { throw new ParseException ( "Low port of '" + channelDescriptions [ i ] + "' is not a valid port." ) ; } if ( chan . portHigh < 0 || chan . portHigh > 65535 ) { throw new ParseException ( "High port of '" + channelDescriptions [ i ] + "' is not a valid port." ) ; } if ( chan . portLow > chan . portHigh ) { throw new ParseException ( "Low port of '" + channelDescriptions [ i ] + "' is greater than high port." ) ; } if ( streamIdLow > streamIdHigh ) { throw new ParseException ( "Low stream-id of '" + channelDescriptions [ i ] + "' is greater than high stream-id." ) ; } addChannelRanges ( chan , streamIdLow , streamIdHigh ) ; } } private void parseAeronChannelToStruct ( final String chanString , final ChannelStruct chanStruct ) throws ParseException { final int ipv6PortIdx = chanString . indexOf ( "]:" ) ; String ports ; if ( ipv6PortIdx != - 1 ) { final int startIdx = ipv6PortIdx + 2 ; final int endIdx = findPortsEndIdx ( chanString , startIdx ) ; ports = chanString . substring ( startIdx , endIdx ) ; chanStruct . prefix = chanString . substring ( 0 , ipv6PortIdx + 1 ) ; chanStruct . suffix = chanString . substring ( endIdx , chanString . length ( ) ) ; } else { final String [ ] addressComponents = chanString . split ( ":" ) ; if ( addressComponents . length != 3 ) { throw new ParseException ( "Channel address '" + chanString + "' wrong number of ':' characters for IPv4." ) ; } final int endIdx = findPortsEndIdx ( addressComponents [ 2 ] , 0 ) ; ports = addressComponents [ 2 ] . substring ( 0 , endIdx ) ; chanStruct . prefix = addressComponents [ 0 ] + ":" + addressComponents [ 1 ] ; chanStruct . suffix = addressComponents [ 2 ] . substring ( endIdx , addressComponents [ 2 ] . length ( ) ) ; } final int [ ] portsArray = findMinAndMaxPort ( ports ) ; chanStruct . portLow = portsArray [ 0 ] ; chanStruct . portHigh = portsArray [ 1 ] ; } private void parseRawChannelToStruct ( final String chanString , final ChannelStruct chanStruct ) throws ParseException { chanStruct . clear ( ) ; String ports ; final int ipv6PortIdx = chanString . indexOf ( "]:" ) ; if ( ipv6PortIdx != - 1 ) { ports = chanString . substring ( ipv6PortIdx + 2 ) ; chanStruct . prefix = chanString . substring ( 0 , ipv6PortIdx + 1 ) ; } else { final String [ ] addressComponents = chanString . split ( ":" ) ; if ( addressComponents . length != 3 ) { throw new ParseException ( "Channel address '" + chanString + "' wrong number of ':' characters for IPv4." ) ; } ports = addressComponents [ 2 ] ; chanStruct . prefix = addressComponents [ 0 ] + ":" + addressComponents [ 1 ] ; } final int [ ] portsArray = findMinAndMaxPort ( ports ) ; chanStruct . portLow = portsArray [ 0 ] ; chanStruct . portHigh = portsArray [ 1 ] ; } private int findPortsEndIdx ( final String input , final int startIdx ) { int endIdx ; for ( endIdx = startIdx ; endIdx < input . length ( ) ; endIdx ++ ) { if ( input . charAt ( endIdx ) == '|' ) { break ; } } return endIdx ; } private int [ ] findMinAndMaxPort ( final String ports ) throws ParseException { int portLow = 0 ; int portHigh = 0 ; if ( ports . contains ( "-" ) ) { final String [ ] portRangeStrings = ports . split ( "-" ) ; if ( portRangeStrings . length != 2 ) { throw new ParseException ( "Address port range '" + ports + "' contains too many '-' characters." ) ; } try { portLow = Integer . parseInt ( portRangeStrings [ 0 ] ) ; portHigh = Integer . parseInt ( portRangeStrings [ 1 ] ) ; } catch ( final NumberFormatException portRangeEx ) { throw new ParseException ( "Address port range '" + ports + "' did not parse into two integers." ) ; } } else { try { portLow = Integer . parseInt ( ports ) ; portHigh = portLow ; } catch ( final NumberFormatException portEx ) { throw new ParseException ( "Address port '" + ports + "' didn't parse into an integer" ) ; } } if ( portLow > portHigh ) { throw new ParseException ( "Address port range '" + ports + "' has low port greater than high port." ) ; } return new int [ ] { portLow , portHigh } ; } private int [ ] findMinAndMaxStreamIds ( final String inputString ) throws ParseException { int streamIdLow = 1 ; int streamIdHigh = 1 ; String ids = inputString ; final int indexOfPipe = ids . indexOf ( "|" ) ; if ( indexOfPipe != - 1 ) { ids = inputString . substring ( 0 , indexOfPipe ) ; } if ( ids . contains ( "-" ) ) { final String [ ] idRange = ids . split ( "-" ) ; if ( idRange . length != 2 ) { throw new ParseException ( "Stream ID range '" + ids + "' has too many '-' characters." ) ; } try { streamIdLow = Integer . parseInt ( idRange [ 0 ] ) ; streamIdHigh = Integer . parseInt ( idRange [ 1 ] ) ; } catch ( final NumberFormatException idRangEx ) { throw new ParseException ( "Stream ID range '" + ids + "' did not parse into two integers." ) ; } } else { try { streamIdLow = Integer . parseInt ( ids ) ; streamIdHigh = streamIdLow ; } catch ( final NumberFormatException streamIdEx ) { throw new ParseException ( "Stream ID '" + ids + "' did not parse into an integer." ) ; } } return new int [ ] { streamIdLow , streamIdHigh } ; } private void addChannelRanges ( final ChannelStruct chan , final int streamIdLow , final int streamIdHigh ) { int currentPort = chan . portLow ; while ( currentPort <= chan . portHigh ) { final ChannelDescriptor cd = new ChannelDescriptor ( ) ; cd . channel ( chan . getChannelWithPort ( currentPort ) ) ; final int [ ] idArray = new int [ streamIdHigh - streamIdLow + 1 ] ; int streamId = streamIdLow ; for ( int i = 0 ; i < idArray . length ; i ++ ) { idArray [ i ] = streamId ++ ; } cd . streamIdentifiers ( idArray ) ; channels . add ( cd ) ; totalStreams += idArray . length ; currentPort ++ ; } } private void parseRates ( final String ratesCsv ) throws ParseException { final String [ ] rates = ratesCsv . split ( "," ) ; for ( final String currentRate : rates ) { final String [ ] rateComponents = currentRate . split ( "@" ) ; if ( rateComponents . length > 2 ) { throw new ParseException ( "Message rate '" + currentRate + "' contains too many '@' characters." ) ; } double duration = Long . MAX_VALUE ; boolean timeDuration = true ; if ( rateComponents . length == 2 ) { final String lowerCaseRate = rateComponents [ 0 ] . toLowerCase ( ) ; if ( lowerCaseRate . endsWith ( "m" ) ) { timeDuration = false ; } else if ( ! lowerCaseRate . endsWith ( "s" ) ) { throw new ParseException ( "Rate " + rateComponents [ 0 ] + " does not contain 'm' or 's' to specify " + "a duration in messages or seconds." ) ; } final String durationStr = lowerCaseRate . substring ( 0 , rateComponents [ 0 ] . length ( ) - 1 ) ; duration = parseDoubleBetweenZeroAndMaxLong ( durationStr ) ; } final String rateComponent = rateComponents [ rateComponents . length - 1 ] ; double rate = Long . MAX_VALUE ; boolean bitsPerSecondRate = true ; if ( ! rateComponent . equalsIgnoreCase ( "max" ) ) { final Matcher matcher = Pattern . compile ( "[a-zA-Z]" ) . matcher ( rateComponent ) ; if ( ! matcher . find ( ) ) { throw new ParseException ( "Rate " + rateComponent + " did not contain any units (Mbps, mps, etc...)." ) ; } final int idx = matcher . start ( ) ; final String prefix = rateComponent . substring ( 0 , idx ) ; final String suffix = rateComponent . substring ( idx , rateComponent . length ( ) ) ; rate = parseDoubleBetweenZeroAndMaxLong ( prefix ) ; if ( suffix . equalsIgnoreCase ( "mps" ) ) { bitsPerSecondRate = false ; } else { rate *= parseBitRateMultiplier ( suffix ) ; } } addSendRate ( duration , timeDuration , rate , bitsPerSecondRate ) ; } } private void addSendRate ( final double duration , final boolean isTimeDuration , final double rate , final boolean isBitsPerSecondRate ) { if ( isTimeDuration ) { if ( isBitsPerSecondRate ) { rateIntervals . add ( new SecondsAtBitsPerSecondInterval ( duration , ( long ) rate ) ) ; } else { rateIntervals . add ( new SecondsAtMessagesPerSecondInterval ( duration , rate ) ) ; } } else { if ( isBitsPerSecondRate ) { rateIntervals . add ( new MessagesAtBitsPerSecondInterval ( ( long ) duration , ( long ) rate ) ) ; } else { rateIntervals . add ( new MessagesAtMessagesPerSecondInterval ( ( long ) duration , rate ) ) ; } } } private void parseMessageSizes ( final String cvs ) throws ParseException { long numMessages = 0 ; int messageSizeMin = 0 ; int messageSizeMax = 0 ; final String [ ] sizeEntries = cvs . split ( "," ) ; for ( int i = 0 ; i < sizeEntries . length ; i ++ ) { final String entryStr = sizeEntries [ i ] ; final String [ ] entryComponents = entryStr . split ( "@" ) ; if ( entryComponents . length > 2 ) { throw new ParseException ( "Message size '" + entryStr + "' contains too many '@' characters." ) ; } String sizeStr ; if ( entryComponents . length == 2 ) { try { numMessages = Long . parseLong ( entryComponents [ 0 ] ) ; } catch ( final NumberFormatException numMessagesEx ) { throw new ParseException ( "Number of messages in '" + entryStr + "' could not parse as long value" ) ; } sizeStr = entryComponents [ 1 ] ; } else { numMessages = Long . MAX_VALUE ; sizeStr = entryComponents [ 0 ] ; } final String [ ] sizeRange = sizeStr . split ( "-" ) ; if ( sizeRange . length > 2 ) { throw new ParseException ( "Message size range in '" + entryStr + "' has too many '-' characters." ) ; } messageSizeMin = parseSize ( sizeRange [ 0 ] ) ; messageSizeMax = messageSizeMin ; if ( sizeRange . length == 2 ) { messageSizeMax = parseSize ( sizeRange [ 1 ] ) ; } addSizeRange ( numMessages , messageSizeMin , messageSizeMax ) ; } } private int parseSize ( final String sizeStr ) throws ParseException { final int kb = 1024 ; final int mb = 1024 * 1024 ; int multiplier = 1 ; long size = 0 ; final String numberStr ; if ( sizeStr . endsWith ( "KB" ) || sizeStr . contains ( "kb" ) ) { multiplier = kb ; numberStr = sizeStr . substring ( 0 , sizeStr . length ( ) - 2 ) ; } else if ( sizeStr . endsWith ( "K" ) || sizeStr . endsWith ( "k" ) ) { multiplier = kb ; numberStr = sizeStr . substring ( 0 , sizeStr . length ( ) - 1 ) ; } else if ( sizeStr . endsWith ( "MB" ) || sizeStr . contains ( "mb" ) ) { multiplier = mb ; numberStr = sizeStr . substring ( 0 , sizeStr . length ( ) - 2 ) ; } else if ( sizeStr . endsWith ( "M" ) || sizeStr . endsWith ( "m" ) ) { multiplier = mb ; numberStr = sizeStr . substring ( 0 , sizeStr . length ( ) - 1 ) ; } else if ( sizeStr . endsWith ( "B" ) || sizeStr . endsWith ( "b" ) ) { multiplier = 1 ; numberStr = sizeStr . substring ( 0 , sizeStr . length ( ) - 1 ) ; } else { multiplier = 1 ; numberStr = sizeStr ; } try { size = Long . parseLong ( numberStr ) ; } catch ( final Exception ex ) { throw new ParseException ( "Could not parse '" + numberStr + "' into a long value." ) ; } size *= multiplier ; if ( size > Integer . MAX_VALUE || size < 0 ) { throw new ParseException ( "Payload size '" + sizeStr + "' too large or negative." ) ; } return ( int ) size ; } private void addSizeRange ( final long messages , final int minSize , final int maxSize ) throws ParseException { try { if ( sizePattern == null ) { sizePattern = new MessageSizePattern ( messages , minSize , maxSize ) ; } else { sizePattern . addPatternEntry ( messages , minSize , maxSize ) ; } } catch ( final Exception ex ) { throw new ParseException ( ex . getMessage ( ) ) ; } } private void parseInputStream ( final String inputStr ) throws ParseException { if ( inputStr . equalsIgnoreCase ( "null" ) ) { input ( null ) ; } else if ( inputStr . equalsIgnoreCase ( "stdin" ) ) { input ( System . in ) ; } else { try { input ( new FileInputStream ( inputStr ) ) ; } catch ( final FileNotFoundException ex ) { throw new ParseException ( "Input file '" + inputStr + "' not found." ) ; } inputNeedsClose = true ; } } private void parseOutputStream ( final String outputStr ) throws ParseException { if ( outputStr . equalsIgnoreCase ( "null" ) ) { output ( null ) ; } else if ( outputStr . equalsIgnoreCase ( "stdout" ) ) { output ( System . out ) ; } else if ( outputStr . equalsIgnoreCase ( "stderr" ) ) { output ( System . err ) ; } else { try { output ( new FileOutputStream ( outputStr ) ) ; } catch ( final FileNotFoundException ex ) { throw new ParseException ( "Could not open file '" + outputStr + "' for writing" ) ; } outputNeedsClose = true ; } } private PubSubOptions . OptionValuesStruct getDefaultsFromOptionsFile ( final String filename ) throws ParseException { BufferedReader br ; final ArrayList < String > args = new ArrayList < String > ( ) ; try { br = newBufferedFileReader ( filename ) ; } catch ( final FileNotFoundException ex ) { throw new ParseException ( "Option defaults file '" + filename + "' not found." ) ; } String line ; try { int lineCount = 0 ; while ( ( line = br . readLine ( ) ) != null ) { lineCount ++ ; line = line . trim ( ) ; if ( line . length ( ) > 0 && ! line . startsWith ( "#" ) ) { final String [ ] arguments = line . split ( "\\s+" ) ; Collections . addAll ( args , arguments ) ; } } br . close ( ) ; } catch ( final IOException ex ) { throw new ParseException ( ex . getMessage ( ) ) ; } final CommandLineParser parser = new GnuParser ( ) ; final CommandLine command = parser . parse ( options , args . toArray ( new String [ args . size ( ) ] ) ) ; return new OptionValuesStruct ( command , DEFAULT_VALUES ) ; } BufferedReader newBufferedFileReader ( final String filename ) throws FileNotFoundException { return new BufferedReader ( new FileReader ( filename ) ) ; } private int parseBitRateMultiplier ( final String s ) throws ParseException { final String rateLowercase = s . toLowerCase ( ) ; if ( rateLowercase . equals ( "gbps" ) ) { return 1000000000 ; } if ( rateLowercase . equals ( "mbps" ) ) { return 1000000 ; } if ( rateLowercase . equals ( "kbps" ) ) { return 1000 ; } if ( rateLowercase . equals ( "bps" ) ) { return 1 ; } throw new ParseException ( "bit rate " + s + " was not 'Gbps','Mbps','Kbps', or 'bps'." ) ; } private long parseLongCheckPositive ( final String longStr ) throws ParseException { long value ; try { value = Long . parseLong ( longStr ) ; } catch ( final NumberFormatException ex ) { throw new ParseException ( "Could not parse '" + longStr + "' as a long value." ) ; } if ( value < 0 ) { throw new ParseException ( "Long value '" + longStr + "' must be positive." ) ; } return value ; } private int parseIntCheckPositive ( final String intStr ) throws ParseException { int value ; try { value = Integer . parseInt ( intStr ) ; } catch ( final NumberFormatException ex ) { throw new ParseException ( "Could not parse '" + intStr + "' as an int value" ) ; } if ( value < 0 ) { throw new ParseException ( "Integer value '" + "' must be positive" ) ; } return value ; } private double parseDoubleBetweenZeroAndMaxLong ( final String doubleStr ) throws ParseException { double value = 0 ; try { value = Double . parseDouble ( doubleStr ) ; } catch ( final NumberFormatException ex ) { throw new ParseException ( "Could not parse '" + doubleStr + " as a double value." ) ; } if ( value < 0D || value > Long . MAX_VALUE ) { throw new ParseException ( "Double value '" + value + "' must be positive and <= long max value." ) ; } return value ; } private static final String USAGE_EXAMPLES = "" + "Examples:" + NL + "-c udp://localhost:31111 -r 60m@1mps" + NL + " Send 60 messages at a rate of 1 message per second" + NL + NL + "-c udp://224.10.10.12:30000#1-10 -r 1Mbps -s 100-200 -m 1000000 -t 2" + NL + " Create 10 multicast channels on port 30000 using stream ID 1 through 10." + NL + " These channels will be split Round-Robin across 2 threads that will each" + NL + " send messages sized between 100 and 200 bytes at a rate of 1Mbps. After a" + NL + " total of 1 million messages have been sent, the program will exit." ; private static final String ADVANCED_GUIDE = "" + "Options Usage Guide" + NL + NL + "-c,--channels '(csv list)'" + NL + " This is a list of one or more Aeron channels. The value may represent a" + NL + " single channel or contain ranges for both ports and stream IDs. Many" + NL + " channels may be defined by using a comma separated list. There are 3 parts" + NL + " to each channel; Address, port, and stream ID. The port and stream ID can" + NL + " be either a single value, or a low to high range separated by a '-'. The" + NL + " port and stream ID values are combined together to create a cartesian" + NL + " product of channels for the given address." + NL + " *NOTE: Enclose entire value in single quotes when on a command prompt." + NL + NL + " Entry Input Format:" + NL + " 'udp://<IP>:port[-portHigh][#streamId[-streamIdHigh]][,...]'" + NL + " [OR]" + NL + " 'aeron:udp?(group|remote)<IP>:port[-portHigh][|(local|address)<IP>]" + NL + " [#streamId[-streamIdHigh]][,...]'" + NL + " For multicast use group and address, for unicast use local and remote." + NL + NL + " IP addresses can be v4 or v6. IPv6 addresses must be in brackets [ ]." + NL + NL + " Examples:" + NL + " udp://localhost:21000" + NL + " Use one channel on port 21000 with stream ID 1" + NL + " udp://224.10.10.21:9100-9109#5" + NL + " Use 10 channels on port 9100 through 9109 all with stream ID 5." + NL + " udp://localhost:21000#5,udp://224.10.10.20:9100-9109#5" + NL + " Comma separated list of the previous two examples, 11 total channels." + NL + " udp://192.168.0.101:9100-9109#5-6" + NL + " On each port between 9100 and 9109 create a channel with stream ID 5" + NL + " and another with stream ID 6 for 20 total channels." + NL + " aeron:udp?group=224.10.10.21:9100|address=192.168.0.101" + NL + " Send to multicast group 224.10.10.21 port 9100 using an interface." + NL + " aeron:udp?remote=192.168.0.100:21000|local=192.168.0.121" + NL + " Send unicast to 192.168.0.100 on port 21000 with stream ID 1." + NL + NL + "--defaults (filename)" + NL + " This allows a file to change the default option values for the program." + NL + " The file is loaded before applying any other command line parameters, so" + NL + " any duplicate options on the command line will override the value in the" + NL + " options file. The syntax for the file is the same as the command line," + NL + " with the exceptions that a '#' used to start a line is considered a" + NL + " comment, and a new line can be used in place of a space." + NL + NL + "--driver (embedded|external)" + NL + " Controls whether the application will start an embedded Aeron messaging" + NL + " driver or communicate with an external one." + "" + NL + "-h,--help" + NL + " Show the shorthand usage guide." + NL + NL + "-i,--input (null|stdin|<file>)" + NL + " Input data for a Publisher to send. When set to 'null' and by default," + NL + " the publisher will generate random data. If 'stdin' is used, standard" + NL + " input will be sent. Any other value is assumed to be a filename. When the" + NL + " publisher reaches the end of the stream, it will exit." + NL + NL + "--iterations (number)" + NL + " Repeat the send rate pattern the given number of times, then exit. See" + NL + " the --rate option." + NL + NL + "-m,--messages (number)" + NL + " Exit after the application sends or receives a given number of messages." + NL + NL + "-o,--output (null|stdout|stderr|<file>)" + NL + " A subscriber will write data received to the given output stream. By" + NL + " default, the subscriber will not write to any stream. This is the " + NL + " behavior of the 'null' value." + NL + NL + "-r,--rate (csv list)" + NL + " This is a list of one or more send rates for a publisher. Each rate entry" + NL + " contains two parts, duration and speed. The duration is the number of" + NL + " seconds or number of messages, and the speed is the bits per second or" + NL + " messages per second. With these options there are four valid combinations" + NL + " of entries; Messages at messages per second, messages at bits per second," + NL + " seconds at messages per second, and seconds at bits per second. The suffix" + NL + " that appears after the numbers determines the type. The 'G', 'M', and 'K'" + NL + " prefix can be used with bps. A sending application will run through the" + NL + " rate pattern once, or --iterations times before exiting. If the duration" + NL + " is not supplied, then it is assumed to mean forever." + NL + NL + " Entry Input Format:" + NL + " [<duration>(m|s)@]<speed>(mps|bps)[,...]" + NL + NL + " Examples:" + NL + " 10Mbps" + NL + " Send forever at 10 Megabits per second." + NL + " 1000m@10mps" + NL + " Send 1000 messages at 10 messages per second." + NL + " 10s@1.5Kbps,1s@1Gbps,0.5mps" + NL + " Send for 10 seconds at 1.5 Kilobit per second, spike to 1" + NL + " Gigabit per second for 1 second, then send one message every 2 seconds" + NL + " forever." + NL + NL + "--seed (number)" + NL + " Set the seed for the random number generator. If multiple threads are" + NL + " being used, each one will use an incrementing seed value." + NL + NL + "--session (number|default)" + NL + " All publishers will be created using the given number as their session ID." + NL + " The special value \"default\" can be used to allow Aeron to select an ID" + NL + " at random." + NL + "" + NL + "-s,--size (csv list)" + NL + " This is a list of one or more message payload sizes. Each entry in the" + NL + " list contains up to two parts, the number of messages and the size or" + NL + " range of possible sizes. The size is specified as a number and optional" + NL + " suffix. A range of sizes is specified by two sizes separated by a hyphen." + NL + " Possible suffixes are 'GB' or 'G', 'MB' or 'M', 'KB' or 'K', and 'B'. " + NL + " The values are binary units, so 'KB' is actually 1024 bytes. If the number" + NL + " of messages not specified then the given size or range will be used" + NL + " indefinitely. The pattern of message sizes will repeat until the sender" + NL + " exits." + NL + NL + " Entry Input Format:" + NL + " [<messages>@]<size>[B][-<maximum>[B]][,...]" + NL + NL + " Examples:" + NL + " 100" + NL + " All messages will be 100 bytes in size." + NL + " 32-1KB" + NL + " All messages will have a random size between 32 and 1024 bytes." + NL + " 99@8K,1@1MB-2MB" + NL + " The first 99 messages will be 8 Kilobytes in size, then one message" + NL + " will be between 1 Megabyte and 2 Megabytes. This pattern will repeat" + NL + " as long as messages are being sent." + NL + NL + "-t,--threads (number)" + NL + " Use the given number of threads to process channels. Channels are split" + NL + " Round-Robin across the threads." + NL + NL + "--verify (yes|no)" + NL + " Each message will reserve space for checksum data that can be used to" + NL + " verify both the individual message and the stream up to that point." + NL + " The default behavior is 'yes', and will use the first 16 bytes of the" + NL + " message payload to store verification data. To send messages with less" + NL + " than 16 bytes of payload this option must be set to 'no'. Subscribers" + NL + " can detect that a message is verifiable. The checksums are not written" + NL + " to the output stream." ; }
package uk . co . real_logic . aeron . tools ; import uk . co . real_logic . aeron . CncFileDescriptor ; import uk . co . real_logic . aeron . CommonContext ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . IoUtil ; import uk . co . real_logic . agrona . concurrent . AtomicBuffer ; import uk . co . real_logic . agrona . concurrent . CountersManager ; import java . io . File ; import java . nio . MappedByteBuffer ; import java . util . ArrayList ; import static java . nio . ByteOrder . nativeOrder ; public class Stats { private CommonContext context = null ; private File cncFile = null ; private MappedByteBuffer cncByteBuffer = null ; private DirectBuffer metaDataBuffer = null ; private AtomicBuffer labelsBuffer = null ; private AtomicBuffer valuesBuffer = null ; private CountersManager countersManager = null ; private StatsOutput output = null ; private static final int LABEL_SIZE = CountersManager . LABEL_LENGTH ; private static final int NUM_BASE_STATS = 22 ; private static final int UNREGISTERED_LABEL_SIZE = CountersManager . UNREGISTERED_LABEL_LENGTH ; public Stats ( final StatsOutput output ) throws Exception { this . output = output == null ? new StatsConsoleOutput ( ) : output ; cncFile = CommonContext . newDefaultCncFile ( ) ; final MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , "cnc" ) ; final DirectBuffer metaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; final int cncVersion = metaDataBuffer . getInt ( CncFileDescriptor . cncVersionOffset ( 0 ) ) ; if ( CncFileDescriptor . CNC_VERSION != cncVersion ) { throw new IllegalStateException ( "CNC version not understood: version = " + cncVersion ) ; } labelsBuffer = CncFileDescriptor . createCounterLabelsBuffer ( cncByteBuffer , metaDataBuffer ) ; valuesBuffer = CncFileDescriptor . createCounterValuesBuffer ( cncByteBuffer , metaDataBuffer ) ; } public void collectStats ( ) throws Exception { String [ ] keys = null ; long [ ] vals = null ; if ( output instanceof StatsNetstatOutput ) { int idx = NUM_BASE_STATS ; final ArrayList < String > tmpKeys = new ArrayList < > ( ) ; final ArrayList < Long > tmpVals = new ArrayList < > ( ) ; int length ; while ( ( length = getLength ( idx ) ) != 0 ) { if ( length != LABEL_SIZE ) { tmpKeys . add ( getLabel ( idx ) ) ; tmpVals . add ( getValue ( idx ) ) ; } idx ++ ; } keys = tmpKeys . toArray ( new String [ tmpKeys . size ( ) ] ) ; vals = new long [ tmpVals . size ( ) ] ; for ( int i = 0 ; i < vals . length ; i ++ ) { vals [ i ] = tmpVals . get ( i ) ; } } else if ( output instanceof StatsConsoleOutput ) { final ArrayList < String > tmpKeys = new ArrayList < > ( ) ; final ArrayList < Long > tmpVals = new ArrayList < > ( ) ; int idx = 0 ; int length ; while ( ( length = getLength ( idx ) ) != 0 ) { System . out . println ( idx ) ; if ( length != UNREGISTERED_LABEL_SIZE ) { tmpKeys . add ( getLabel ( idx ) ) ; tmpVals . add ( getValue ( idx ) ) ; } idx ++ ; } keys = tmpKeys . toArray ( new String [ tmpKeys . size ( ) ] ) ; vals = new long [ tmpVals . size ( ) ] ; for ( int i = 0 ; i < vals . length ; i ++ ) { vals [ i ] = tmpVals . get ( i ) ; } } else if ( output instanceof StatsVmStatOutput || output instanceof StatsCsvOutput ) { keys = new String [ NUM_BASE_STATS ] ; vals = new long [ NUM_BASE_STATS ] ; for ( int idx = 0 ; idx < NUM_BASE_STATS ; idx ++ ) { final int length = getLength ( idx ) ; if ( length != 0 && length != CountersManager . UNREGISTERED_LABEL_LENGTH ) { keys [ idx ] = getLabel ( idx ) ; vals [ idx ] = getValue ( idx ) ; } } } output . format ( keys , vals ) ; } public void close ( ) throws Exception { output . close ( ) ; } private int getLength ( final int idx ) { return labelsBuffer . getInt ( idx * CountersManager . LABEL_LENGTH ) ; } private String getLabel ( final int idx ) { return labelsBuffer . getStringUtf8 ( idx * CountersManager . LABEL_LENGTH , nativeOrder ( ) ) ; } private long getValue ( final int idx ) { final int offset = CountersManager . counterOffset ( idx ) ; return valuesBuffer . getLongVolatile ( offset ) ; } }
package uk . co . real_logic . aeron . tools ; import org . junit . Test ; import java . util . ArrayList ; import java . util . List ; public class SecondsAtBitsPerSecondTest { private RateController rc ; private List < RateControllerInterval > ivlsList = new ArrayList < > ( ) ; @ Test public void createWithOneAndOne ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new SecondsAtBitsPerSecondInterval ( 1 , 1 ) ) ; rc = new RateController ( ( ) - > 0 , ivlsList ) ; } @ Test public void createWithZeroBitsPerSecond ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new SecondsAtBitsPerSecondInterval ( 1 , 0 ) ) ; rc = new RateController ( ( ) - > 0 , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithZeroSeconds ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new SecondsAtBitsPerSecondInterval ( 0 , 1 ) ) ; rc = new RateController ( ( ) - > 0 , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithNegativeSeconds ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new SecondsAtBitsPerSecondInterval ( - 1 , 1 ) ) ; rc = new RateController ( ( ) - > 0 , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithNegativeBitsPerSecond ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new SecondsAtBitsPerSecondInterval ( 1 , - 1 ) ) ; rc = new RateController ( ( ) - > 0 , ivlsList ) ; } }
package uk . co . real_logic . aeron . tools . perf_tools ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . Publication ; import uk . co . real_logic . aeron . Subscription ; import uk . co . real_logic . aeron . CommonContext ; import uk . co . real_logic . aeron . driver . RateReporter ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . driver . MediaDriver ; import uk . co . real_logic . aeron . driver . ThreadingMode ; import uk . co . real_logic . agrona . LangUtil ; import uk . co . real_logic . agrona . concurrent . BusySpinIdleStrategy ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import uk . co . real_logic . agrona . concurrent . NoOpIdleStrategy ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . function . Consumer ; public class AeronThroughput { private static final int STREAM_ID = 10 ; private static final String CHANNEL = "udp://localhost:55555" ; private static final int MESSAGE_LENGTH = 20 ; private static final long NUMBER_OF_MESSAGES = 1000000000 ; private static final long LINGER_TIMEOUT_MS = 2000 ; private static final int FRAGMENT_COUNT_LIMIT = 1 ; private static final UnsafeBuffer ATOMIC_BUFFER = new UnsafeBuffer ( ByteBuffer . allocateDirect ( MESSAGE_LENGTH ) ) ; private static final IdleStrategy OFFER_IDLE_STRATEGY = new BusySpinIdleStrategy ( ) ; public static void printRate ( final double messagesPerSec , final double bytesPerSec , final long totalMessages , final long totalBytes ) { } public static FragmentHandler rateReporterHandler ( final RateReporter reporter ) { return ( buffer , offset , length , header ) - > reporter . onMessage ( 1 , length ) ; } public static Consumer < Subscription > subscriberLoop ( final FragmentHandler fragmentHandler , final int limit , final AtomicBoolean running ) { final IdleStrategy idleStrategy = new BusySpinIdleStrategy ( ) ; return subscriberLoop ( fragmentHandler , limit , running , idleStrategy ) ; } public static Consumer < Subscription > subscriberLoop ( final FragmentHandler fragmentHandler , final int limit , final AtomicBoolean running , final IdleStrategy idleStrategy ) { return ( subscription ) - > { try { while ( running . get ( ) ) { final int fragmentsRead = subscription . poll ( fragmentHandler , limit ) ; idleStrategy . idle ( fragmentsRead ) ; } } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } } ; } private static String humanReadableCount ( final long val , final boolean si ) { final int unit = si ? 1000 : 1024 ; if ( val < unit ) { return val + "" ; } final int exp = ( int ) ( Math . log ( val ) / Math . log ( unit ) ) ; final String pre = ( si ? "kMGTPE" : "KMGTPE" ) . charAt ( exp - 1 ) + ( si ? "" : "i" ) ; return String . format ( "%.3f%s" , val / Math . pow ( unit , exp ) , pre ) ; } public static void main ( final String [ ] args ) throws Exception { final MediaDriver . Context ctx = new MediaDriver . Context ( ) . threadingMode ( ThreadingMode . DEDICATED ) . conductorIdleStrategy ( new NoOpIdleStrategy ( ) ) . receiverIdleStrategy ( new NoOpIdleStrategy ( ) ) . senderIdleStrategy ( new NoOpIdleStrategy ( ) ) . dirsDeleteOnExit ( true ) ; final RateReporter reporter = new RateReporter ( TimeUnit . SECONDS . toNanos ( 1 ) , AeronThroughput : : printRate ) ; final FragmentHandler rateReporterHandler = rateReporterHandler ( reporter ) ; final ExecutorService executor = Executors . newFixedThreadPool ( 2 ) ; final String embeddedDirName = CommonContext . generateEmbeddedDirName ( ) ; ctx . dirName ( embeddedDirName ) ; final Aeron . Context context = new Aeron . Context ( ) ; context . dirName ( embeddedDirName ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; try ( final MediaDriver ignore = MediaDriver . launch ( ctx ) ; final Aeron aeron = Aeron . connect ( context ) ; final Publication publication = aeron . addPublication ( CHANNEL , STREAM_ID ) ; final Subscription subscription = aeron . addSubscription ( CHANNEL , STREAM_ID ) ) { executor . execute ( reporter ) ; executor . execute ( ( ) - > AeronThroughput . subscriberLoop ( rateReporterHandler , FRAGMENT_COUNT_LIMIT , running ) . accept ( subscription ) ) ; final long start = System . currentTimeMillis ( ) ; for ( long i = 0 ; i < NUMBER_OF_MESSAGES ; i ++ ) { ATOMIC_BUFFER . putLong ( 0 , i ) ; while ( publication . offer ( ATOMIC_BUFFER , 0 , ATOMIC_BUFFER . capacity ( ) ) < 0 ) { OFFER_IDLE_STRATEGY . idle ( 0 ) ; } } final long stop = System . currentTimeMillis ( ) ; System . out . println ( "Average throughput for " + MESSAGE_LENGTH + " byte messages was: " + humanReadableCount ( NUMBER_OF_MESSAGES / ( ( stop - start ) / 1000 ) , false ) + " msgs/sec" ) ; if ( 0 < LINGER_TIMEOUT_MS ) { Thread . sleep ( LINGER_TIMEOUT_MS ) ; } running . set ( false ) ; reporter . halt ( ) ; executor . shutdown ( ) ; } } }
package uk . co . real_logic . aeron . tools . perf_tools ; import org . apache . commons . cli . * ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . FragmentAssemblyAdapter ; import uk . co . real_logic . aeron . Publication ; import uk . co . real_logic . aeron . Subscription ; import uk . co . real_logic . aeron . logbuffer . BufferClaim ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import java . util . concurrent . atomic . AtomicBoolean ; public class AeronPong { private final FragmentHandler fragmentHandler ; private final Aeron aeron ; private final Publication pongPublication ; private final Subscription pingSubscription ; private final int pingStreamId = 10 ; private final int pongStreamId = 11 ; private String pingChannel = "udp://localhost:44444" ; private String pongChannel = "udp://localhost:55555" ; private final AtomicBoolean running = new AtomicBoolean ( true ) ; private boolean claim = false ; private BufferClaim bufferClaim = null ; public AeronPong ( final String [ ] args ) { try { parseArgs ( args ) ; } catch ( final ParseException e ) { e . printStackTrace ( ) ; } final Aeron . Context ctx = new Aeron . Context ( ) ; if ( claim ) { fragmentHandler = new FragmentAssemblyAdapter ( this : : pingHandlerClaim ) ; } else { fragmentHandler = new FragmentAssemblyAdapter ( this : : pingHandler ) ; } aeron = Aeron . connect ( ctx ) ; pongPublication = aeron . addPublication ( pongChannel , pongStreamId ) ; pingSubscription = aeron . addSubscription ( pingChannel , pingStreamId ) ; if ( claim ) { bufferClaim = new BufferClaim ( ) ; } } public void run ( ) { while ( running . get ( ) ) { pingSubscription . poll ( fragmentHandler , 1 ) ; } } public void shutdown ( ) { aeron . close ( ) ; } private void parseArgs ( final String [ ] args ) throws ParseException { final Options options = new Options ( ) ; options . addOption ( "c" , "claim" , false , "Use Try/Claim" ) ; options . addOption ( "" , "pongChannel" , true , "Pong channel" ) ; options . addOption ( "" , "pingChannel" , true , "Ping channel" ) ; final CommandLineParser parser = new GnuParser ( ) ; final CommandLine command = parser . parse ( options , args ) ; claim = command . hasOption ( "claim" ) ; if ( command . hasOption ( "pingChannel" ) ) { pingChannel = command . getOptionValue ( "pingChannel" , "udp://localhost:44444" ) ; } if ( command . hasOption ( "pongChannel" ) ) { pongChannel = command . getOptionValue ( "pongChannel" , "udp://localhost:55555" ) ; } } private void pingHandler ( final DirectBuffer buffer , final int offset , final int length , final Header header ) { if ( buffer . getByte ( offset + 0 ) == ( byte ) 'q' ) { running . set ( false ) ; return ; } while ( pongPublication . offer ( buffer , offset , length ) < 0L ) { } } private void pingHandlerClaim ( final DirectBuffer buffer , final int offset , final int length , final Header header ) { if ( buffer . getByte ( offset + 0 ) == ( byte ) 'q' ) { running . set ( false ) ; return ; } if ( pongPublication . tryClaim ( length , bufferClaim ) >= 0 ) { final MutableDirectBuffer newBuffer = bufferClaim . buffer ( ) ; newBuffer . putBytes ( bufferClaim . offset ( ) , buffer , offset , length ) ; bufferClaim . commit ( ) ; } else { pingHandlerClaim ( buffer , offset , length , header ) ; } } public static void main ( final String [ ] args ) { final AeronPong pong = new AeronPong ( args ) ; pong . run ( ) ; pong . shutdown ( ) ; } }
package uk . co . real_logic . aeron . tools . perf_tools ; import org . apache . commons . cli . * ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . FragmentAssemblyAdapter ; import uk . co . real_logic . aeron . Publication ; import uk . co . real_logic . aeron . Subscription ; import uk . co . real_logic . aeron . logbuffer . BufferClaim ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . MutableDirectBuffer ; public class AeronLatencyUnderLoadSubscriber { private final Publication pub ; private final BufferClaim bufferClaim ; private String pubChannel = "udp://localhost:44444" ; private String reflectChannel = "udp://localhost:55555" ; private final int pubStreamId = 11 ; private final int subStreamId = 10 ; private volatile boolean running = true ; public AeronLatencyUnderLoadSubscriber ( final String [ ] args ) { try { parseArgs ( args ) ; } catch ( final ParseException ex ) { throw new RuntimeException ( ex ) ; } final Aeron . Context ctx = new Aeron . Context ( ) ; final FragmentAssemblyAdapter dataHandler = new FragmentAssemblyAdapter ( this : : msgHandler ) ; try ( final Aeron aeron = Aeron . connect ( ctx ) ; final Publication publication = aeron . addPublication ( reflectChannel , pubStreamId ) ; final Subscription sub = aeron . addSubscription ( pubChannel , subStreamId ) ) { System . out . println ( "Reflect: " + reflectChannel + " Pub: " + pubChannel ) ; pub = publication ; bufferClaim = new BufferClaim ( ) ; while ( running ) { sub . poll ( dataHandler , 1 ) ; } try { Thread . sleep ( 500 ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } } } public void msgHandler ( final DirectBuffer buffer , final int offset , final int length , final Header header ) { if ( buffer . getByte ( offset ) == ( byte ) 'q' ) { running = false ; } else { while ( pub . tryClaim ( length , bufferClaim ) < 0L ) { } final MutableDirectBuffer newBuffer = bufferClaim . buffer ( ) ; final int newOffset = bufferClaim . offset ( ) ; newBuffer . putBytes ( newOffset , buffer , offset , length ) ; bufferClaim . commit ( ) ; } } private void parseArgs ( final String [ ] args ) throws ParseException { final Options options = new Options ( ) ; options . addOption ( "c" , "claim" , false , "Use Try/Claim" ) ; options . addOption ( "" , "pubChannel" , true , "Primary publishing channel" ) ; options . addOption ( "" , "reflectChannel" , true , "Reflection channel" ) ; final CommandLineParser parser = new GnuParser ( ) ; final CommandLine command = parser . parse ( options , args ) ; if ( command . hasOption ( "pubChannel" ) ) { pubChannel = command . getOptionValue ( "pubChannel" , "udp://localhost:44444" ) ; } if ( command . hasOption ( "reflectChannel" ) ) { reflectChannel = command . getOptionValue ( "reflectChannel" , "udp://localhost:55555" ) ; } } public static void main ( final String [ ] args ) { new AeronLatencyUnderLoadSubscriber ( args ) ; } }
package uk . co . real_logic . aeron . tools . perf_tools ; import org . apache . commons . cli . * ; import uk . co . real_logic . aeron . * ; import uk . co . real_logic . aeron . logbuffer . BufferClaim ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . concurrent . CountDownLatch ; public class AeronPing implements NewConnectionHandler { private final int numMsgs = 1000000 ; private final int numWarmupMsgs = 50000 ; private final int msgLen = 32 ; private long [ ] [ ] timestamps = null ; private boolean warmedUp = false ; private final FragmentHandler fragmentHandler = new FragmentAssemblyAdapter ( this : : pongHandler ) ; private final Aeron aeron ; private final Publication pub ; private final Subscription sub ; private final CountDownLatch connectionLatch ; private final int pingStreamId = 10 ; private final int pongStreamId = 11 ; private String pingChannel = "udp://localhost:44444" ; private String pongChannel = "udp://localhost:55555" ; private UnsafeBuffer buffer = null ; private int msgCount = 0 ; private boolean claim = false ; private BufferClaim bufferClaim = null ; private double sorted [ ] = null ; private double tmp [ ] = null ; public AeronPing ( final String [ ] args ) throws Exception { parseArgs ( args ) ; final Aeron . Context ctx = new Aeron . Context ( ) . newConnectionHandler ( this ) ; aeron = Aeron . connect ( ctx ) ; pub = aeron . addPublication ( pingChannel , pingStreamId ) ; sub = aeron . addSubscription ( pongChannel , pongStreamId ) ; connectionLatch = new CountDownLatch ( 1 ) ; buffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( msgLen ) ) ; timestamps = new long [ 2 ] [ numMsgs ] ; if ( claim ) { bufferClaim = new BufferClaim ( ) ; } } public void connect ( ) { try { connectionLatch . await ( ) ; System . out . println ( "Connected" ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } } public void run ( ) { for ( int i = 0 ; i < numWarmupMsgs ; i ++ ) { if ( ! claim ) { sendPingAndReceivePong ( ) ; } else { sendPingAndReceivePongClaim ( ) ; } } System . out . println ( "Warmed up" ) ; warmedUp = true ; for ( int i = 0 ; i < numMsgs ; i ++ ) { if ( ! claim ) { sendPingAndReceivePong ( ) ; } else { sendPingAndReceivePongClaim ( ) ; } } buffer . putByte ( 0 , ( byte ) 'q' ) ; while ( pub . offer ( buffer , 0 , msgLen ) <= 0 ) { } } public void shutdown ( ) { aeron . close ( ) ; } public void dumpStats ( ) { double sum = 0.0 ; double max = Double . MIN_VALUE ; double min = Double . MAX_VALUE ; int maxIdx = 0 ; int minIdx = 0 ; double mean = 0.0 ; double stdDev = 0.0 ; tmp = new double [ timestamps [ 0 ] . length ] ; sorted = new double [ tmp . length ] ; for ( int i = 0 ; i < tmp . length ; i ++ ) { tmp [ i ] = ( timestamps [ 1 ] [ i ] - timestamps [ 0 ] [ i ] ) / 1000.0 ; if ( tmp [ i ] > max ) { max = tmp [ i ] ; maxIdx = i ; } if ( tmp [ i ] < min ) { min = tmp [ i ] ; minIdx = i ; } sum += tmp [ i ] ; } mean = sum / tmp . length ; System . arraycopy ( tmp , 0 , sorted , 0 , tmp . length ) ; Arrays . sort ( sorted ) ; sum = 0 ; for ( int i = 0 ; i < tmp . length ; i ++ ) { sum += Math . pow ( mean - tmp [ i ] , 2 ) ; } stdDev = Math . sqrt ( sum / tmp . length ) ; dumpPercentileData ( .9 ) ; dumpPercentileData ( .99 ) ; dumpPercentileData ( .999 ) ; dumpPercentileData ( .9999 ) ; dumpPercentileData ( .99999 ) ; dumpPercentileData ( .999999 ) ; System . out . println ( "Num Messages: " + numMsgs ) ; System . out . println ( "Message Length: " + msgLen ) ; System . out . format ( "Mean: %.3fus\n" , mean ) ; System . out . format ( "Standard Deviation: %.3fus\n" , stdDev ) ; System . out . println ( "Min: " + min + " Index: " + minIdx ) ; System . out . println ( "Max: " + max + " Index: " + maxIdx ) ; } private void parseArgs ( final String [ ] args ) throws ParseException { final Options options = new Options ( ) ; options . addOption ( "c" , "claim" , false , "Use Try/Claim" ) ; options . addOption ( "" , "pongChannel" , true , "Pong channel" ) ; options . addOption ( "" , "pingChannel" , true , "Ping channel" ) ; final CommandLineParser parser = new GnuParser ( ) ; final CommandLine command = parser . parse ( options , args ) ; claim = command . hasOption ( "claim" ) ; if ( command . hasOption ( "pingChannel" ) ) { pingChannel = command . getOptionValue ( "pingChannel" , "udp://localhost:44444" ) ; } if ( command . hasOption ( "pongChannel" ) ) { pongChannel = command . getOptionValue ( "pongChannel" , "udp://localhost:55555" ) ; } } private void dumpPercentileData ( final double percentile ) { final int num = ( int ) ( ( numMsgs - 1 ) * percentile ) ; final double newMax = sorted [ num ] ; final File file = new File ( percentile + "_percentile.dat" ) ; try { final PrintWriter out = new PrintWriter ( file ) ; for ( int i = 0 ; i < numMsgs ; i ++ ) { if ( tmp [ i ] <= newMax ) { out . println ( i + "\t" + tmp [ i ] ) ; } } out . close ( ) ; } catch ( final FileNotFoundException | SecurityException e ) { e . printStackTrace ( ) ; } } public void dumpData ( ) { final File file = new File ( "ping.dat" ) ; try { final PrintWriter out = new PrintWriter ( file ) ; for ( int i = 0 ; i < numMsgs ; i ++ ) { out . println ( i + "\t" + tmp [ i ] ) ; } out . close ( ) ; } catch ( final FileNotFoundException | SecurityException e ) { e . printStackTrace ( ) ; } } public void onNewConnection ( final String channel , final int streamId , final int sessionId , final long position , final String sourceIdentity ) { if ( channel . equals ( pongChannel ) && pongStreamId == streamId ) { connectionLatch . countDown ( ) ; } } private void pongHandler ( final DirectBuffer buffer , final int offset , final int length , final Header header ) { if ( buffer . getByte ( offset + 0 ) == ( byte ) 'p' ) { timestamps [ 1 ] [ buffer . getInt ( offset + 1 ) ] = System . nanoTime ( ) ; } } private void sendPingAndReceivePong ( ) { if ( ! warmedUp ) { buffer . putByte ( 0 , ( byte ) 'w' ) ; } else { buffer . putByte ( 0 , ( byte ) 'p' ) ; buffer . putInt ( 1 , msgCount ) ; timestamps [ 0 ] [ msgCount ++ ] = System . nanoTime ( ) ; } while ( pub . offer ( buffer , 0 , msgLen ) <= 0 ) { } while ( sub . poll ( fragmentHandler , 1 ) <= 0 ) { } } private void sendPingAndReceivePongClaim ( ) { if ( pub . tryClaim ( msgLen , bufferClaim ) > 0 ) { final MutableDirectBuffer buffer = bufferClaim . buffer ( ) ; final int offset = bufferClaim . offset ( ) ; if ( ! warmedUp ) { buffer . putByte ( offset + 0 , ( byte ) 'w' ) ; } else { buffer . putByte ( offset + 0 , ( byte ) 'p' ) ; buffer . putInt ( offset + 1 , msgCount ) ; timestamps [ 0 ] [ msgCount ++ ] = System . nanoTime ( ) ; } bufferClaim . commit ( ) ; while ( sub . poll ( fragmentHandler , 1 ) <= 0 ) { } } else { sendPingAndReceivePongClaim ( ) ; } } public static void main ( final String [ ] args ) throws Exception { final AeronPing ping = new AeronPing ( args ) ; ping . connect ( ) ; ping . run ( ) ; ping . shutdown ( ) ; ping . dumpStats ( ) ; ping . dumpData ( ) ; } }
package uk . co . real_logic . aeron . tools . perf_tools ; import org . apache . commons . cli . * ; import uk . co . real_logic . aeron . Aeron ; import uk . co . real_logic . aeron . FragmentAssemblyAdapter ; import uk . co . real_logic . aeron . Publication ; import uk . co . real_logic . aeron . Subscription ; import uk . co . real_logic . aeron . logbuffer . BufferClaim ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . tools . MessagesAtMessagesPerSecondInterval ; import uk . co . real_logic . aeron . tools . RateController ; import uk . co . real_logic . aeron . tools . RateControllerInterval ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . concurrent . BusySpinIdleStrategy ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import javax . imageio . ImageIO ; import java . awt . * ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CountDownLatch ; public class AeronLatencyUnderLoadPublisher implements RateController . Callback { private Publication pub = null ; private Subscription sub = null ; private CountDownLatch connectionLatch = null ; private FragmentHandler fragmentHandler = null ; private final int pubStreamId = 10 ; private final int subStreamId = 11 ; private String pubChannel = "udp://localhost:44444" ; private String reflectChannel = "udp://localhost:55555" ; private boolean running = true ; private final int msgLen = 20 ; private UnsafeBuffer buffer = null ; private final long timestamps [ ] = new long [ 41111100 ] ; private int msgCount = 0 ; private final BufferClaim bufferClaim ; private int warmups = 0 ; private final double means [ ] = new double [ 7 ] ; public AeronLatencyUnderLoadPublisher ( final String [ ] args ) { try { parseArgs ( args ) ; } catch ( final ParseException e ) { throw new RuntimeException ( e ) ; } final Aeron . Context ctx = new Aeron . Context ( ) . newConnectionHandler ( this : : connectionHandler ) ; fragmentHandler = new FragmentAssemblyAdapter ( this : : msgHandler ) ; final Aeron aeron = Aeron . connect ( ctx ) ; System . out . println ( "Reflect: " + reflectChannel + " Pub: " + pubChannel ) ; pub = aeron . addPublication ( pubChannel , pubStreamId ) ; sub = aeron . addSubscription ( reflectChannel , subStreamId ) ; connectionLatch = new CountDownLatch ( 1 ) ; final IdleStrategy idle = new BusySpinIdleStrategy ( ) ; bufferClaim = new BufferClaim ( ) ; final List < RateControllerInterval > intervals = new ArrayList < > ( ) ; intervals . add ( new MessagesAtMessagesPerSecondInterval ( 100 , 10 ) ) ; intervals . add ( new MessagesAtMessagesPerSecondInterval ( 1000 , 100 ) ) ; intervals . add ( new MessagesAtMessagesPerSecondInterval ( 10000 , 1000 ) ) ; intervals . add ( new MessagesAtMessagesPerSecondInterval ( 100000 , 10000 ) ) ; intervals . add ( new MessagesAtMessagesPerSecondInterval ( 1000000 , 100000 ) ) ; intervals . add ( new MessagesAtMessagesPerSecondInterval ( 10000000 , 1000000 ) ) ; intervals . add ( new MessagesAtMessagesPerSecondInterval ( 30000000 , 3000000 ) ) ; buffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( msgLen ) ) ; msgCount = 0 ; RateController rateController = null ; try { rateController = new RateController ( this , intervals ) ; } catch ( final Exception ex ) { throw new RuntimeException ( ex ) ; } final Runnable task = ( ) - > { while ( running ) { while ( sub . poll ( fragmentHandler , 1 ) <= 0 && running ) { } } System . out . println ( "Done" ) ; } ; final Thread subThread = new Thread ( task ) ; subThread . start ( ) ; try { connectionLatch . await ( ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } final int warmUpMsgs = 100000 ; for ( int i = 0 ; i < warmUpMsgs ; i ++ ) { while ( pub . tryClaim ( buffer . capacity ( ) , bufferClaim ) < 0L ) { idle . idle ( 1 ) ; } final MutableDirectBuffer buffer = bufferClaim . buffer ( ) ; final int offset = bufferClaim . offset ( ) ; buffer . putByte ( offset , ( byte ) 'w' ) ; bufferClaim . commit ( ) ; } try { Thread . sleep ( 1000 ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } System . out . println ( "warmup msgs received: " + warmups ) ; final int start = ( int ) System . currentTimeMillis ( ) ; while ( rateController . next ( ) ) { } final int total = ( int ) ( System . currentTimeMillis ( ) - start ) / 1000 ; buffer . putByte ( 0 , ( byte ) 'q' ) ; while ( pub . offer ( buffer , 0 , buffer . capacity ( ) ) < 0L ) { idle . idle ( 0 ) ; } System . out . println ( "Duration: " + total + " seconds" ) ; try { Thread . sleep ( 1000 ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } running = false ; try { subThread . join ( ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } aeron . close ( ) ; try { computeStats ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public int onNext ( ) { while ( pub . tryClaim ( buffer . capacity ( ) , bufferClaim ) < 0L ) { } final MutableDirectBuffer buffer = bufferClaim . buffer ( ) ; final int offset = bufferClaim . offset ( ) ; buffer . putByte ( offset , ( byte ) 'p' ) ; buffer . putInt ( offset + 1 , msgCount ++ ) ; buffer . putLong ( offset + 5 , System . nanoTime ( ) ) ; bufferClaim . commit ( ) ; return msgLen ; } private void connectionHandler ( final String channel , final int streamId , final int sessionId , final long position , final String sourceIdentity ) { System . out . println ( channel + " " + streamId ) ; if ( channel . equals ( reflectChannel ) && subStreamId == streamId ) { connectionLatch . countDown ( ) ; System . out . println ( "Connected" ) ; } } private void msgHandler ( final DirectBuffer buffer , final int offset , final int length , final Header header ) { if ( buffer . getByte ( offset ) == ( byte ) 'p' ) { timestamps [ buffer . getInt ( offset + 1 ) ] = System . nanoTime ( ) - buffer . getLong ( offset + 5 ) ; } else { warmups ++ ; } } private void parseArgs ( final String [ ] args ) throws ParseException { final Options options = new Options ( ) ; options . addOption ( "c" , "claim" , false , "Use Try/Claim" ) ; options . addOption ( "" , "pubChannel" , true , "Primary publishing channel" ) ; options . addOption ( "" , "reflectChannel" , true , "Reflection channel" ) ; final CommandLineParser parser = new GnuParser ( ) ; final CommandLine command = parser . parse ( options , args ) ; if ( command . hasOption ( "pubChannel" ) ) { pubChannel = command . getOptionValue ( "pubChannel" , "udp://localhost:44444" ) ; } if ( command . hasOption ( "reflectChannel" ) ) { reflectChannel = command . getOptionValue ( "reflectChannel" , "udp://localhost:55555" ) ; } } private void computeStats ( ) throws IOException { means [ 0 ] = computeStats ( 0 , 100 , "10mps" ) ; means [ 1 ] = computeStats ( 100 , 1100 , "100mps" ) ; means [ 2 ] = computeStats ( 1100 , 11000 , "1Kmps" ) ; means [ 3 ] = computeStats ( 11000 , 111000 , "10Kmps" ) ; means [ 4 ] = computeStats ( 111000 , 1111000 , "100Kmps" ) ; means [ 5 ] = computeStats ( 1111000 , 11111000 , "1Mmps" ) ; means [ 6 ] = computeStats ( 11111000 , 41111000 , "3Mmps" ) ; generateScatterPlot ( ) ; } private double computeStats ( final int start , final int end , final String title ) { double sum = 0.0 ; double min = Double . MAX_VALUE ; double max = Double . MIN_VALUE ; for ( int i = start ; i < end ; i ++ ) { final double ts = timestamps [ i ] / 1000.0 ; if ( ts < 0 ) { System . exit ( 1 ) ; } sum += ts ; if ( ts < min ) { min = ts ; } if ( ts > max ) { max = ts ; } } System . out . println ( "Mean latency for " + title + ": " + sum / ( end - start ) ) ; return sum / ( end - start ) ; } private void generateScatterPlot ( ) throws IOException { final BufferedImage image = new BufferedImage ( 1800 , 1000 , BufferedImage . TYPE_INT_ARGB ) ; final Graphics2D g2 = image . createGraphics ( ) ; final FontMetrics fm = g2 . getFontMetrics ( ) ; final String filename = "throughputency.png" ; final File imageFile = new File ( filename ) ; final int height = 940 ; double min = Double . MAX_VALUE ; double max = Double . MIN_VALUE ; for ( final long timestamp : timestamps ) { final double ts = timestamp / 1000.0 ; if ( ts < min ) { min = ts ; } if ( ts > max ) { max = ts ; } } final double stepY = height / max ; g2 . setColor ( Color . white ) ; g2 . fillRect ( 0 , 0 , 1800 , 1000 ) ; g2 . setColor ( Color . black ) ; g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; g2 . drawString ( "Latency ScatterPlot (microseconds)" , 900 - fm . stringWidth ( "Latency ScatterPlot (microseconds)" ) / 2 , 20 ) ; g2 . drawString ( "" + max , 10 , 20 ) ; g2 . drawLine ( 100 , 20 , 100 , 960 ) ; g2 . drawLine ( 100 , 960 , 1790 , 960 ) ; int start = 0 ; int end = 100 ; final double width = 1690.0 / 7.0 ; g2 . setColor ( Color . red ) ; plotSubset ( g2 , start , end , "10 msgs/sec" , 100 , width , stepY , means [ 0 ] ) ; start = 100 ; end = 1100 ; g2 . setColor ( Color . green ) ; plotSubset ( g2 , start , end , "100 msgs/sec" , 100 + width , width , stepY , means [ 1 ] ) ; start = 1100 ; end = 11100 ; g2 . setColor ( Color . blue ) ; plotSubset ( g2 , start , end , "1K msgs/sec" , 100 + width * 2 , width , stepY , means [ 2 ] ) ; start = 11100 ; end = 111100 ; g2 . setColor ( Color . cyan ) ; plotSubset ( g2 , start , end , "10K msgs/sec" , 100 + width * 3 , width , stepY , means [ 3 ] ) ; start = 111100 ; end = 1111100 ; g2 . setColor ( Color . magenta ) ; plotSubset ( g2 , start , end , "100K msgs/sec" , 100 + width * 4 , width , stepY , means [ 4 ] ) ; start = 1111100 ; end = 11111100 ; g2 . setColor ( Color . yellow ) ; plotSubset ( g2 , start , end , "1M msgs/sec" , 100 + width * 5 , width , stepY , means [ 5 ] ) ; start = 11111100 ; end = 41111100 ; g2 . setColor ( Color . orange ) ; plotSubset ( g2 , start , end , "3M msgs/sec" , 100 + width * 6 , width , stepY , means [ 6 ] ) ; ImageIO . write ( image , "png" , imageFile ) ; } private void plotSubset ( final Graphics2D g , final int start , final int end , final String title , final double startX , final double width , final double stepY , final double mean ) { final FontMetrics fm = g . getFontMetrics ( ) ; final Color color = g . getColor ( ) ; g . setColor ( Color . black ) ; g . drawString ( title , ( int ) ( startX + width / 2 - fm . stringWidth ( title ) / 2 ) , 975 ) ; final String tmp = String . format ( "Mean: %.3fus" , mean ) ; g . drawString ( tmp , ( int ) ( startX + width / 2 - fm . stringWidth ( tmp ) / 2 ) , 990 ) ; g . setColor ( color ) ; final double stepX = width / ( end - start ) ; for ( int i = start ; i < end ; i ++ ) { final int posX = ( int ) ( startX + stepX * ( i - start ) ) ; final int posY = 960 - ( ( int ) ( stepY * ( timestamps [ i ] / 1000.0 ) ) + 1 ) ; g . drawLine ( posX , posY , posX , 960 ) ; } } public static void main ( final String [ ] args ) { new AeronLatencyUnderLoadPublisher ( args ) ; } }
package uk . co . real_logic . aeron ; import org . junit . Test ; import static org . hamcrest . Matchers . is ; import static org . junit . Assert . assertThat ; public class ErrorCodeTest { @ Test public void errorCodesShouldBeIndexes ( ) { final ErrorCode [ ] values = ErrorCode . values ( ) ; for ( short i = 0 ; i < values . length ; i ++ ) { assertThat ( ErrorCode . get ( i ) . value ( ) , is ( i ) ) ; } } }
package uk . co . real_logic . aeron ; import org . junit . Test ; import uk . co . real_logic . aeron . command . PublicationMessageFlyweight ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . protocol . ErrorFlyweight ; import uk . co . real_logic . aeron . protocol . HeaderFlyweight ; import uk . co . real_logic . aeron . protocol . NakFlyweight ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; import static org . hamcrest . core . Is . is ; import static org . junit . Assert . assertThat ; public class FlyweightTest { private final ByteBuffer buffer = ByteBuffer . allocateDirect ( 512 ) ; private final UnsafeBuffer aBuff = new UnsafeBuffer ( buffer ) ; private final HeaderFlyweight encodeHeader = new HeaderFlyweight ( ) ; private final HeaderFlyweight decodeHeader = new HeaderFlyweight ( ) ; private final DataHeaderFlyweight encodeDataHeader = new DataHeaderFlyweight ( ) ; private final DataHeaderFlyweight decodeDataHeader = new DataHeaderFlyweight ( ) ; private final PublicationMessageFlyweight encodePublication = new PublicationMessageFlyweight ( ) ; private final PublicationMessageFlyweight decodePublication = new PublicationMessageFlyweight ( ) ; private final ErrorFlyweight encodeError = new ErrorFlyweight ( ) ; private final ErrorFlyweight decodeError = new ErrorFlyweight ( ) ; private final NakFlyweight encodeNakHeader = new NakFlyweight ( ) ; private final NakFlyweight decodeNakHeader = new NakFlyweight ( ) ; @ Test public void shouldWriteCorrectValuesForGenericHeaderFields ( ) { encodeHeader . wrap ( aBuff , 0 ) ; encodeHeader . version ( ( short ) 1 ) ; encodeHeader . flags ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ; encodeHeader . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) ; encodeHeader . frameLength ( 8 ) ; assertThat ( buffer . get ( 0 ) , is ( ( byte ) 0x08 ) ) ; assertThat ( buffer . get ( 1 ) , is ( ( byte ) 0x00 ) ) ; assertThat ( buffer . get ( 2 ) , is ( ( byte ) 0x00 ) ) ; assertThat ( buffer . get ( 3 ) , is ( ( byte ) 0x00 ) ) ; assertThat ( buffer . get ( 4 ) , is ( ( byte ) 0x01 ) ) ; assertThat ( buffer . get ( 5 ) , is ( ( byte ) 0xC0 ) ) ; assertThat ( buffer . get ( 6 ) , is ( ( byte ) HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( buffer . get ( 7 ) , is ( ( byte ) 0x00 ) ) ; } @ Test public void shouldReadWhatIsWrittenToGenericHeaderFields ( ) { encodeHeader . wrap ( aBuff , 0 ) ; encodeHeader . version ( ( short ) 1 ) ; encodeHeader . flags ( ( short ) 0 ) ; encodeHeader . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) ; encodeHeader . frameLength ( 8 ) ; decodeHeader . wrap ( aBuff , 0 ) ; assertThat ( decodeHeader . version ( ) , is ( ( short ) 1 ) ) ; assertThat ( decodeHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( decodeHeader . frameLength ( ) , is ( 8 ) ) ; } @ Test public void shouldWriteAndReadMultipleFramesCorrectly ( ) { encodeHeader . wrap ( aBuff , 0 ) ; encodeHeader . version ( ( short ) 1 ) ; encodeHeader . flags ( ( short ) 0 ) ; encodeHeader . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) ; encodeHeader . frameLength ( 8 ) ; encodeHeader . wrap ( aBuff , 8 ) ; encodeHeader . version ( ( short ) 2 ) ; encodeHeader . flags ( ( short ) 0x01 ) ; encodeHeader . headerType ( HeaderFlyweight . HDR_TYPE_SM ) ; encodeHeader . frameLength ( 8 ) ; decodeHeader . wrap ( aBuff , 0 ) ; assertThat ( decodeHeader . version ( ) , is ( ( short ) 1 ) ) ; assertThat ( decodeHeader . flags ( ) , is ( ( short ) 0 ) ) ; assertThat ( decodeHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( decodeHeader . frameLength ( ) , is ( 8 ) ) ; decodeHeader . wrap ( aBuff , 8 ) ; assertThat ( decodeHeader . version ( ) , is ( ( short ) 2 ) ) ; assertThat ( decodeHeader . flags ( ) , is ( ( short ) 0x01 ) ) ; assertThat ( decodeHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_SM ) ) ; assertThat ( decodeHeader . frameLength ( ) , is ( 8 ) ) ; } @ Test public void shouldReadAndWriteDataHeaderCorrectly ( ) { encodeDataHeader . wrap ( aBuff , 0 ) ; encodeDataHeader . version ( ( short ) 1 ) ; encodeDataHeader . flags ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ; encodeDataHeader . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) ; encodeDataHeader . frameLength ( DataHeaderFlyweight . HEADER_LENGTH ) ; encodeDataHeader . sessionId ( 0xdeadbeef ) ; encodeDataHeader . streamId ( 0x44332211 ) ; encodeDataHeader . termId ( 0x99887766 ) ; decodeDataHeader . wrap ( aBuff , 0 ) ; assertThat ( decodeDataHeader . version ( ) , is ( ( short ) 1 ) ) ; assertThat ( decodeDataHeader . flags ( ) , is ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ) ; assertThat ( decodeDataHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( decodeDataHeader . frameLength ( ) , is ( DataHeaderFlyweight . HEADER_LENGTH ) ) ; assertThat ( decodeDataHeader . sessionId ( ) , is ( 0xdeadbeef ) ) ; assertThat ( decodeDataHeader . streamId ( ) , is ( 0x44332211 ) ) ; assertThat ( decodeDataHeader . termId ( ) , is ( 0x99887766 ) ) ; assertThat ( decodeDataHeader . dataOffset ( ) , is ( DataHeaderFlyweight . HEADER_LENGTH ) ) ; } @ Test public void shouldEncodeAndDecodeNakCorrectly ( ) { encodeNakHeader . wrap ( aBuff , 0 ) ; encodeNakHeader . version ( ( short ) 1 ) ; encodeNakHeader . flags ( ( byte ) 0 ) ; encodeNakHeader . headerType ( HeaderFlyweight . HDR_TYPE_NAK ) ; encodeNakHeader . frameLength ( NakFlyweight . HEADER_LENGTH ) ; encodeNakHeader . sessionId ( 0xdeadbeef ) ; encodeNakHeader . streamId ( 0x44332211 ) ; encodeNakHeader . termId ( 0x99887766 ) ; encodeNakHeader . termOffset ( 0x22334 ) ; encodeNakHeader . length ( 512 ) ; decodeNakHeader . wrap ( aBuff , 0 ) ; assertThat ( decodeNakHeader . version ( ) , is ( ( short ) 1 ) ) ; assertThat ( decodeNakHeader . flags ( ) , is ( ( short ) 0 ) ) ; assertThat ( decodeNakHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_NAK ) ) ; assertThat ( decodeNakHeader . frameLength ( ) , is ( NakFlyweight . HEADER_LENGTH ) ) ; assertThat ( decodeNakHeader . sessionId ( ) , is ( 0xdeadbeef ) ) ; assertThat ( decodeNakHeader . streamId ( ) , is ( 0x44332211 ) ) ; assertThat ( decodeNakHeader . termId ( ) , is ( 0x99887766 ) ) ; assertThat ( decodeNakHeader . termOffset ( ) , is ( 0x22334 ) ) ; assertThat ( decodeNakHeader . length ( ) , is ( 512 ) ) ; } @ Test public void shouldEncodeAndDecodeStringsCorrectly ( ) { encodePublication . wrap ( aBuff , 0 ) ; final String example = "abcc" ; encodePublication . channel ( example ) ; decodePublication . wrap ( aBuff , 0 ) ; assertThat ( decodePublication . channel ( ) , is ( example ) ) ; } @ Test public void shouldReadAndWriteErrorHeaderWithoutErrorStringCorrectly ( ) { final ByteBuffer originalBuffer = ByteBuffer . allocateDirect ( 256 ) ; final UnsafeBuffer originalUnsafeBuffer = new UnsafeBuffer ( originalBuffer ) ; encodeDataHeader . wrap ( originalUnsafeBuffer , 0 ) ; encodeDataHeader . version ( ( short ) 1 ) ; encodeDataHeader . flags ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ; encodeDataHeader . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) ; encodeDataHeader . frameLength ( DataHeaderFlyweight . HEADER_LENGTH ) ; encodeDataHeader . sessionId ( 0xdeadbeef ) ; encodeDataHeader . streamId ( 0x44332211 ) ; encodeDataHeader . termId ( 0x99887766 ) ; encodeError . wrap ( aBuff , 0 ) ; encodeError . version ( ( short ) 1 ) ; encodeError . flags ( ( short ) 0 ) ; encodeError . headerType ( HeaderFlyweight . HDR_TYPE_ERR ) ; encodeError . frameLength ( encodeDataHeader . frameLength ( ) + 12 ) ; encodeError . offendingHeader ( encodeDataHeader , encodeDataHeader . frameLength ( ) ) ; decodeError . wrap ( aBuff , 0 ) ; assertThat ( decodeError . version ( ) , is ( ( short ) 1 ) ) ; assertThat ( decodeError . flags ( ) , is ( ( short ) 0 ) ) ; assertThat ( decodeError . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_ERR ) ) ; assertThat ( decodeError . frameLength ( ) , is ( encodeDataHeader . frameLength ( ) + ErrorFlyweight . HEADER_LENGTH ) ) ; decodeDataHeader . wrap ( aBuff , decodeError . offendingHeaderOffset ( ) ) ; assertThat ( decodeDataHeader . version ( ) , is ( ( short ) 1 ) ) ; assertThat ( decodeDataHeader . flags ( ) , is ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ) ; assertThat ( decodeDataHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( decodeDataHeader . frameLength ( ) , is ( DataHeaderFlyweight . HEADER_LENGTH ) ) ; assertThat ( decodeDataHeader . sessionId ( ) , is ( 0xdeadbeef ) ) ; assertThat ( decodeDataHeader . streamId ( ) , is ( 0x44332211 ) ) ; assertThat ( decodeDataHeader . termId ( ) , is ( 0x99887766 ) ) ; assertThat ( decodeDataHeader . dataOffset ( ) , is ( encodeDataHeader . frameLength ( ) + ErrorFlyweight . HEADER_LENGTH ) ) ; } @ Test public void shouldReadAndWriteErrorHeaderWithErrorStringCorrectly ( ) { final String errorString = "this is an error" ; final ByteBuffer originalBuffer = ByteBuffer . allocateDirect ( 256 ) ; final UnsafeBuffer originalUnsafeBuffer = new UnsafeBuffer ( originalBuffer ) ; encodeDataHeader . wrap ( originalUnsafeBuffer , 0 ) ; encodeDataHeader . version ( ( short ) 1 ) ; encodeDataHeader . flags ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ; encodeDataHeader . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) ; encodeDataHeader . frameLength ( DataHeaderFlyweight . HEADER_LENGTH ) ; encodeDataHeader . sessionId ( 0xdeadbeef ) ; encodeDataHeader . streamId ( 0x44332211 ) ; encodeDataHeader . termId ( 0x99887766 ) ; encodeError . wrap ( aBuff , 0 ) ; encodeError . version ( ( short ) 1 ) ; encodeError . flags ( ( short ) 0 ) ; encodeError . headerType ( HeaderFlyweight . HDR_TYPE_ERR ) ; encodeError . frameLength ( encodeDataHeader . frameLength ( ) + ErrorFlyweight . HEADER_LENGTH + errorString . length ( ) ) ; encodeError . offendingHeader ( encodeDataHeader , encodeDataHeader . frameLength ( ) ) ; encodeError . errorMessage ( errorString . getBytes ( ) ) ; decodeError . wrap ( aBuff , 0 ) ; assertThat ( decodeError . version ( ) , is ( ( short ) 1 ) ) ; assertThat ( decodeError . flags ( ) , is ( ( short ) 0 ) ) ; assertThat ( decodeError . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_ERR ) ) ; assertThat ( decodeError . frameLength ( ) , is ( encodeDataHeader . frameLength ( ) + ErrorFlyweight . HEADER_LENGTH + errorString . length ( ) ) ) ; decodeDataHeader . wrap ( aBuff , decodeError . offendingHeaderOffset ( ) ) ; assertThat ( decodeDataHeader . version ( ) , is ( ( short ) 1 ) ) ; assertThat ( decodeDataHeader . flags ( ) , is ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) ) ; assertThat ( decodeDataHeader . headerType ( ) , is ( HeaderFlyweight . HDR_TYPE_DATA ) ) ; assertThat ( decodeDataHeader . frameLength ( ) , is ( encodeDataHeader . frameLength ( ) ) ) ; assertThat ( decodeDataHeader . sessionId ( ) , is ( 0xdeadbeef ) ) ; assertThat ( decodeDataHeader . streamId ( ) , is ( 0x44332211 ) ) ; assertThat ( decodeDataHeader . termId ( ) , is ( 0x99887766 ) ) ; assertThat ( decodeDataHeader . dataOffset ( ) , is ( encodeDataHeader . frameLength ( ) + ErrorFlyweight . HEADER_LENGTH ) ) ; assertThat ( decodeError . errorMessageOffset ( ) , is ( encodeDataHeader . frameLength ( ) + ErrorFlyweight . HEADER_LENGTH ) ) ; assertThat ( decodeError . errorStringLength ( ) , is ( errorString . length ( ) ) ) ; assertThat ( decodeError . errorMessageAsBytes ( ) , is ( errorString . getBytes ( ) ) ) ; } }
package uk . co . real_logic . aeron ; import org . junit . Before ; import org . junit . Test ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . FrameDescriptor ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; import java . util . function . Consumer ; import static org . hamcrest . Matchers . is ; import static org . junit . Assert . assertThat ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . * ; public class SubscriptionTest { private static final String CHANNEL = "udp://localhost:40124" ; private static final int STREAM_ID_1 = 2 ; private static final long SUBSCRIPTION_CORRELATION_ID = 100 ; private static final int READ_BUFFER_CAPACITY = 1024 ; private static final byte FLAGS = ( byte ) FrameDescriptor . UNFRAGMENTED ; private static final int FRAGMENT_COUNT_LIMIT = Integer . MAX_VALUE ; private static final int HEADER_LENGTH = DataHeaderFlyweight . HEADER_LENGTH ; private final UnsafeBuffer atomicReadBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( READ_BUFFER_CAPACITY ) ) ; private final Consumer < Throwable > errorHandler = mock ( Consumer . class ) ; private final ClientConductor conductor = mock ( ClientConductor . class ) ; private final FragmentHandler fragmentHandler = mock ( FragmentHandler . class ) ; private final Connection connectionOneMock = mock ( Connection . class ) ; private final Header header = mock ( Header . class ) ; private final Connection connectionTwoMock = mock ( Connection . class ) ; private Subscription subscription ; @ Before public void setUp ( ) { when ( header . flags ( ) ) . thenReturn ( FLAGS ) ; subscription = new Subscription ( conductor , CHANNEL , STREAM_ID_1 , SUBSCRIPTION_CORRELATION_ID , errorHandler ) ; } @ Test ( expected = IllegalStateException . class ) public void shouldEnsureTheSubscriptionIsOpenWhenPolling ( ) { subscription . close ( ) ; subscription . poll ( fragmentHandler , FRAGMENT_COUNT_LIMIT ) ; } @ Test public void shouldReadNothingWithNoConnections ( ) { assertThat ( subscription . poll ( fragmentHandler , 1 ) , is ( 0 ) ) ; } @ Test public void shouldReadNothingWhenThereIsNoData ( ) { subscription . addConnection ( connectionOneMock ) ; assertThat ( subscription . poll ( fragmentHandler , 1 ) , is ( 0 ) ) ; } @ Test public void shouldReadData ( ) { subscription . addConnection ( connectionOneMock ) ; when ( connectionOneMock . poll ( fragmentHandler , FRAGMENT_COUNT_LIMIT , errorHandler ) ) . then ( ( invocation ) - > { final FragmentHandler handler = ( FragmentHandler ) invocation . getArguments ( ) [ 0 ] ; handler . onFragment ( atomicReadBuffer , HEADER_LENGTH , READ_BUFFER_CAPACITY - HEADER_LENGTH , header ) ; return 1 ; } ) ; assertThat ( subscription . poll ( fragmentHandler , FRAGMENT_COUNT_LIMIT ) , is ( 1 ) ) ; verify ( fragmentHandler ) . onFragment ( eq ( atomicReadBuffer ) , eq ( HEADER_LENGTH ) , eq ( READ_BUFFER_CAPACITY - HEADER_LENGTH ) , any ( Header . class ) ) ; } @ Test public void shouldReadDataFromMultipleSources ( ) { subscription . addConnection ( connectionOneMock ) ; subscription . addConnection ( connectionTwoMock ) ; when ( connectionOneMock . poll ( fragmentHandler , FRAGMENT_COUNT_LIMIT , errorHandler ) ) . then ( ( invocation ) - > { final FragmentHandler handler = ( FragmentHandler ) invocation . getArguments ( ) [ 0 ] ; handler . onFragment ( atomicReadBuffer , HEADER_LENGTH , READ_BUFFER_CAPACITY - HEADER_LENGTH , header ) ; return 1 ; } ) ; when ( connectionTwoMock . poll ( fragmentHandler , FRAGMENT_COUNT_LIMIT , errorHandler ) ) . then ( ( invocation ) - > { final FragmentHandler handler = ( FragmentHandler ) invocation . getArguments ( ) [ 0 ] ; handler . onFragment ( atomicReadBuffer , HEADER_LENGTH , READ_BUFFER_CAPACITY - HEADER_LENGTH , header ) ; return 1 ; } ) ; assertThat ( subscription . poll ( fragmentHandler , FRAGMENT_COUNT_LIMIT ) , is ( 2 ) ) ; } }
package uk . co . real_logic . aeron ; import org . junit . Test ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . charset . StandardCharsets ; import java . util . Arrays ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . lessThan ; import static org . junit . Assert . assertArrayEquals ; import static org . junit . Assert . assertThat ; import static uk . co . real_logic . aeron . BufferBuilder . INITIAL_CAPACITY ; public class BufferBuilderTest { private final BufferBuilder bufferBuilder = new BufferBuilder ( ) ; @ Test public void shouldInitialiseToDefaultValues ( ) { assertThat ( bufferBuilder . capacity ( ) , is ( INITIAL_CAPACITY ) ) ; assertThat ( bufferBuilder . buffer ( ) . capacity ( ) , is ( INITIAL_CAPACITY ) ) ; assertThat ( bufferBuilder . limit ( ) , is ( 0 ) ) ; } @ Test public void shouldAppendNothingForZeroLength ( ) { final UnsafeBuffer srcBuffer = new UnsafeBuffer ( new byte [ INITIAL_CAPACITY ] ) ; bufferBuilder . append ( srcBuffer , 0 , 0 ) ; assertThat ( bufferBuilder . limit ( ) , is ( 0 ) ) ; } @ Test public void shouldAppendThenReset ( ) { final UnsafeBuffer srcBuffer = new UnsafeBuffer ( new byte [ INITIAL_CAPACITY ] ) ; bufferBuilder . append ( srcBuffer , 0 , srcBuffer . capacity ( ) ) ; assertThat ( bufferBuilder . limit ( ) , is ( srcBuffer . capacity ( ) ) ) ; bufferBuilder . reset ( ) ; assertThat ( bufferBuilder . limit ( ) , is ( 0 ) ) ; } @ Test public void shouldAppendOneBufferWithoutResizing ( ) { final UnsafeBuffer srcBuffer = new UnsafeBuffer ( new byte [ INITIAL_CAPACITY ] ) ; final byte [ ] bytes = "Hello World" . getBytes ( StandardCharsets . UTF_8 ) ; srcBuffer . putBytes ( 0 , bytes , 0 , bytes . length ) ; bufferBuilder . append ( srcBuffer , 0 , bytes . length ) ; final byte [ ] temp = new byte [ bytes . length ] ; bufferBuilder . buffer ( ) . getBytes ( 0 , temp , 0 , bytes . length ) ; assertThat ( bufferBuilder . limit ( ) , is ( bytes . length ) ) ; assertThat ( bufferBuilder . capacity ( ) , is ( INITIAL_CAPACITY ) ) ; assertArrayEquals ( temp , bytes ) ; } @ Test public void shouldAppendTwoBuffersWithoutResizing ( ) { final UnsafeBuffer srcBuffer = new UnsafeBuffer ( new byte [ INITIAL_CAPACITY ] ) ; final byte [ ] bytes = "1111111122222222" . getBytes ( StandardCharsets . UTF_8 ) ; srcBuffer . putBytes ( 0 , bytes , 0 , bytes . length ) ; bufferBuilder . append ( srcBuffer , 0 , bytes . length / 2 ) ; bufferBuilder . append ( srcBuffer , bytes . length / 2 , bytes . length / 2 ) ; final byte [ ] temp = new byte [ bytes . length ] ; bufferBuilder . buffer ( ) . getBytes ( 0 , temp , 0 , bytes . length ) ; assertThat ( bufferBuilder . limit ( ) , is ( bytes . length ) ) ; assertThat ( bufferBuilder . capacity ( ) , is ( INITIAL_CAPACITY ) ) ; assertArrayEquals ( temp , bytes ) ; } @ Test public void shouldFillBufferWithoutResizing ( ) { final int bufferLength = 128 ; final byte [ ] buffer = new byte [ bufferLength ] ; Arrays . fill ( buffer , ( byte ) 7 ) ; final UnsafeBuffer srcBuffer = new UnsafeBuffer ( buffer ) ; final BufferBuilder bufferBuilder = new BufferBuilder ( bufferLength ) ; bufferBuilder . append ( srcBuffer , 0 , bufferLength ) ; final byte [ ] temp = new byte [ bufferLength ] ; bufferBuilder . buffer ( ) . getBytes ( 0 , temp , 0 , bufferLength ) ; assertThat ( bufferBuilder . limit ( ) , is ( bufferLength ) ) ; assertThat ( bufferBuilder . capacity ( ) , is ( bufferLength ) ) ; assertArrayEquals ( temp , buffer ) ; } @ Test public void shouldResizeWhenBufferJustDoesNotFit ( ) { final int bufferLength = 128 ; final byte [ ] buffer = new byte [ bufferLength + 1 ] ; Arrays . fill ( buffer , ( byte ) 7 ) ; final UnsafeBuffer srcBuffer = new UnsafeBuffer ( buffer ) ; final BufferBuilder bufferBuilder = new BufferBuilder ( bufferLength ) ; bufferBuilder . append ( srcBuffer , 0 , buffer . length ) ; final byte [ ] temp = new byte [ buffer . length ] ; bufferBuilder . buffer ( ) . getBytes ( 0 , temp , 0 , buffer . length ) ; assertThat ( bufferBuilder . limit ( ) , is ( buffer . length ) ) ; assertThat ( bufferBuilder . capacity ( ) , is ( bufferLength * 2 ) ) ; assertArrayEquals ( temp , buffer ) ; } @ Test public void shouldAppendTwoBuffersAndResize ( ) { final int bufferLength = 128 ; final byte [ ] buffer = new byte [ bufferLength ] ; final int firstLength = buffer . length / 4 ; final int secondLength = buffer . length / 2 ; Arrays . fill ( buffer , 0 , firstLength + secondLength , ( byte ) 7 ) ; final UnsafeBuffer srcBuffer = new UnsafeBuffer ( buffer ) ; final BufferBuilder bufferBuilder = new BufferBuilder ( bufferLength / 2 ) ; bufferBuilder . append ( srcBuffer , 0 , firstLength ) ; bufferBuilder . append ( srcBuffer , firstLength , secondLength ) ; final byte [ ] temp = new byte [ buffer . length ] ; bufferBuilder . buffer ( ) . getBytes ( 0 , temp , 0 , secondLength + firstLength ) ; assertThat ( bufferBuilder . limit ( ) , is ( firstLength + secondLength ) ) ; assertThat ( bufferBuilder . capacity ( ) , is ( bufferLength ) ) ; assertArrayEquals ( temp , buffer ) ; } @ Test public void shouldCompactBufferToLowerLimit ( ) { final int bufferLength = INITIAL_CAPACITY / 2 ; final byte [ ] buffer = new byte [ bufferLength ] ; final UnsafeBuffer srcBuffer = new UnsafeBuffer ( buffer ) ; final BufferBuilder bufferBuilder = new BufferBuilder ( ) ; final int bufferCount = 5 ; for ( int i = 0 ; i < bufferCount ; i ++ ) { bufferBuilder . append ( srcBuffer , 0 , buffer . length ) ; } final int expectedLimit = buffer . length * bufferCount ; assertThat ( bufferBuilder . limit ( ) , is ( expectedLimit ) ) ; final int expandedCapacity = bufferBuilder . capacity ( ) ; assertThat ( expandedCapacity , greaterThan ( expectedLimit ) ) ; bufferBuilder . reset ( ) ; bufferBuilder . append ( srcBuffer , 0 , buffer . length ) ; bufferBuilder . append ( srcBuffer , 0 , buffer . length ) ; bufferBuilder . append ( srcBuffer , 0 , buffer . length ) ; bufferBuilder . compact ( ) ; assertThat ( bufferBuilder . limit ( ) , is ( buffer . length * 3 ) ) ; assertThat ( bufferBuilder . capacity ( ) , lessThan ( expandedCapacity ) ) ; } }
package uk . co . real_logic . aeron ; import org . junit . Before ; import org . junit . Test ; import uk . co . real_logic . aeron . logbuffer . BufferClaim ; import uk . co . real_logic . aeron . logbuffer . FrameDescriptor ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . status . ReadablePosition ; import java . nio . ByteBuffer ; import static org . hamcrest . Matchers . is ; import static org . junit . Assert . assertThat ; import static org . mockito . Mockito . * ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . * ; public class PublicationTest { private static final String CHANNEL = "udp://localhost:40124" ; private static final int STREAM_ID_1 = 2 ; private static final int SESSION_ID_1 = 13 ; private static final int TERM_ID_1 = 1 ; private static final int CORRELATION_ID = 2000 ; private static final int SEND_BUFFER_CAPACITY = 1024 ; private final ByteBuffer sendBuffer = ByteBuffer . allocateDirect ( SEND_BUFFER_CAPACITY ) ; private final UnsafeBuffer atomicSendBuffer = new UnsafeBuffer ( sendBuffer ) ; private final UnsafeBuffer logMetaDataBuffer = spy ( new UnsafeBuffer ( ByteBuffer . allocateDirect ( LOG_META_DATA_LENGTH ) ) ) ; private final UnsafeBuffer [ ] termBuffers = new UnsafeBuffer [ PARTITION_COUNT ] ; private final UnsafeBuffer [ ] termMetaDataBuffers = new UnsafeBuffer [ PARTITION_COUNT ] ; private final UnsafeBuffer [ ] buffers = new UnsafeBuffer [ ( PARTITION_COUNT * 2 ) + 1 ] ; private Publication publication ; private ClientConductor conductor = mock ( ClientConductor . class ) ; private LogBuffers logBuffers = mock ( LogBuffers . class ) ; @ Before public void setUp ( ) { final ReadablePosition limit = mock ( ReadablePosition . class ) ; when ( limit . getVolatile ( ) ) . thenReturn ( 2L * SEND_BUFFER_CAPACITY ) ; when ( logBuffers . atomicBuffers ( ) ) . thenReturn ( buffers ) ; initialTermId ( logMetaDataBuffer , TERM_ID_1 ) ; for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { termBuffers [ i ] = new UnsafeBuffer ( ByteBuffer . allocateDirect ( TERM_MIN_LENGTH ) ) ; termMetaDataBuffers [ i ] = new UnsafeBuffer ( ByteBuffer . allocateDirect ( TERM_META_DATA_LENGTH ) ) ; buffers [ i ] = termBuffers [ i ] ; buffers [ i + PARTITION_COUNT ] = termMetaDataBuffers [ i ] ; } buffers [ LOG_META_DATA_SECTION_INDEX ] = logMetaDataBuffer ; publication = new Publication ( conductor , CHANNEL , STREAM_ID_1 , SESSION_ID_1 , limit , logBuffers , CORRELATION_ID ) ; publication . incRef ( ) ; } @ Test ( expected = IllegalStateException . class ) public void shouldEnsureThePublicationIsOpenBeforeReadingPosition ( ) { publication . close ( ) ; publication . position ( ) ; } @ Test ( expected = IllegalStateException . class ) public void shouldEnsureThePublicationIsOpenBeforeOffer ( ) { publication . close ( ) ; publication . offer ( atomicSendBuffer ) ; } @ Test ( expected = IllegalStateException . class ) public void shouldEnsureThePublicationIsOpenBeforeClaim ( ) { publication . close ( ) ; final BufferClaim bufferClaim = new BufferClaim ( ) ; publication . tryClaim ( SEND_BUFFER_CAPACITY , bufferClaim ) ; } @ Test public void shouldReportInitialPosition ( ) { assertThat ( publication . position ( ) , is ( 0L ) ) ; } @ Test public void shouldReportMaxMessageLength ( ) { assertThat ( publication . maxMessageLength ( ) , is ( FrameDescriptor . computeMaxMessageLength ( TERM_MIN_LENGTH ) ) ) ; } @ Test public void shouldUnmapBuffersWhenReleased ( ) throws Exception { publication . close ( ) ; logBuffersClosedOnce ( ) ; releaseSelfOnce ( ) ; } @ Test public void shouldNotUnmapBuffersBeforeLastRelease ( ) throws Exception { publication . incRef ( ) ; publication . close ( ) ; verify ( logBuffers , never ( ) ) . close ( ) ; } @ Test public void shouldUnmapBuffersWithMultipleReferences ( ) throws Exception { publication . incRef ( ) ; publication . close ( ) ; publication . close ( ) ; logBuffersClosedOnce ( ) ; } @ Test public void shouldReleaseResourcesIdempotently ( ) throws Exception { publication . close ( ) ; publication . close ( ) ; logBuffersClosedOnce ( ) ; releaseSelfOnce ( ) ; } private void logBuffersClosedOnce ( ) { verify ( logBuffers , times ( 1 ) ) . close ( ) ; } private void releaseSelfOnce ( ) { verify ( conductor , times ( 1 ) ) . releasePublication ( publication ) ; } }
package uk . co . real_logic . aeron . tools ; import org . junit . Test ; import java . util . ArrayList ; import java . util . List ; import static org . hamcrest . CoreMatchers . both ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; import static org . hamcrest . core . Is . is ; public class RateControllerTest { private RateController rc ; interface TestCallbackStats { long numMessagesSent ( ) ; long numBitsSent ( ) ; } public abstract class TestCallback implements RateController . Callback , TestCallbackStats { protected long numMessagesSent = 0 ; protected long numBitsSent = 0 ; public long numMessagesSent ( ) { return numMessagesSent ; } public long numBitsSent ( ) { return numBitsSent ; } } @ Test ( expected = Exception . class ) public void createWithNulls ( ) throws Exception { rc = new RateController ( null , null ) ; } @ Test ( expected = Exception . class ) public void createWithNullCallback ( ) throws Exception { final RateControllerInterval ivl = new MessagesAtBitsPerSecondInterval ( 1 , 1 ) ; final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; ivlsList . add ( ivl ) ; rc = new RateController ( null , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithNullIntervalsList ( ) throws Exception { rc = new RateController ( ( ) - > { return 0 ; } , null ) ; } @ Test ( expected = Exception . class ) public void createWithEmptyIntervalsList ( ) throws Exception { final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test public void createWithMessagesAtMessagesPerSecond ( ) throws Exception { final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; final RateControllerInterval ivl = new MessagesAtMessagesPerSecondInterval ( 1 , 1 ) ; ivlsList . add ( ivl ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test public void createWithMessagesAtBitsPerSecond ( ) throws Exception { final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; final RateControllerInterval ivl = new MessagesAtBitsPerSecondInterval ( 1 , 1 ) ; ivlsList . add ( ivl ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test public void createWithSecondsAtBitsPerSecond ( ) throws Exception { final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; final RateControllerInterval ivl = new SecondsAtBitsPerSecondInterval ( 1 , 1 ) ; ivlsList . add ( ivl ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test public void createWithSecondsAtMessagesPerSecond ( ) throws Exception { final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; final RateControllerInterval ivl = new SecondsAtMessagesPerSecondInterval ( 1 , 1 ) ; ivlsList . add ( ivl ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithZeroIterations ( ) throws Exception { final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; final RateControllerInterval ivl = new MessagesAtMessagesPerSecondInterval ( 1 , 1 ) ; ivlsList . add ( ivl ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList , 0 ) ; } @ Test ( expected = Exception . class ) public void createWithNegativeIterations ( ) throws Exception { final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; final RateControllerInterval ivl = new MessagesAtMessagesPerSecondInterval ( 1 , 1 ) ; ivlsList . add ( ivl ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList , - 1 ) ; } @ Test public void createWithFourIntervals ( ) throws Exception { final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; ivlsList . add ( new SecondsAtMessagesPerSecondInterval ( 1 , 1 ) ) ; ivlsList . add ( new SecondsAtBitsPerSecondInterval ( 1 , 1 ) ) ; ivlsList . add ( new MessagesAtMessagesPerSecondInterval ( 1 , 1 ) ) ; ivlsList . add ( new MessagesAtBitsPerSecondInterval ( 1 , 1 ) ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test public void sendOneMessage ( ) throws Exception { class Callback extends TestCallback { public int onNext ( ) { numMessagesSent ++ ; return 0 ; } } final RateController . Callback callback = new Callback ( ) ; final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; ivlsList . add ( new MessagesAtMessagesPerSecondInterval ( 1 , 1 ) ) ; rc = new RateController ( callback , ivlsList ) ; while ( rc . next ( ) ) { } assertThat ( "FAIL: Exactly one message should have been sent" , ( ( TestCallbackStats ) callback ) . numMessagesSent ( ) , is ( 1L ) ) ; } @ Test public void sendOneBit ( ) throws Exception { class Callback extends TestCallback { public int onNext ( ) { numMessagesSent ++ ; numBitsSent += 1 ; return 1 ; } } final RateController . Callback callback = new Callback ( ) ; final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; ivlsList . add ( new MessagesAtMessagesPerSecondInterval ( 1 , 1 ) ) ; rc = new RateController ( callback , ivlsList ) ; while ( rc . next ( ) ) { } assertThat ( "FAIL: Exactly one bit should have been sent" , ( ( TestCallbackStats ) callback ) . numBitsSent ( ) , is ( 1L ) ) ; } @ Test public void sendFiveMessagesAtMaxMesagesPerSecond ( ) throws Exception { class Callback extends TestCallback { public int onNext ( ) { numMessagesSent ++ ; numBitsSent += 10 ; return 10 ; } } final RateController . Callback callback = new Callback ( ) ; final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; ivlsList . add ( new MessagesAtMessagesPerSecondInterval ( 5 , Long . MAX_VALUE ) ) ; rc = new RateController ( callback , ivlsList ) ; while ( rc . next ( ) ) { } assertThat ( "FAIL: Exactly five messages should have been sent" , ( ( TestCallbackStats ) callback ) . numMessagesSent ( ) , is ( 5L ) ) ; assertThat ( "FAIL: Exactly 50 bits should have been sent" , ( ( TestCallbackStats ) callback ) . numBitsSent ( ) , is ( 50L ) ) ; } @ Test public void sendTwoIntervals ( ) throws Exception { class Callback extends TestCallback { public int onNext ( ) { numMessagesSent ++ ; numBitsSent += 10 ; return 10 ; } } final RateController . Callback callback = new Callback ( ) ; final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; ivlsList . add ( new MessagesAtMessagesPerSecondInterval ( 1 , Long . MAX_VALUE ) ) ; ivlsList . add ( new MessagesAtBitsPerSecondInterval ( 1 , Long . MAX_VALUE ) ) ; rc = new RateController ( callback , ivlsList ) ; while ( rc . next ( ) ) { } assertThat ( "FAIL: Exactly two messages should have been sent" , ( ( TestCallbackStats ) callback ) . numMessagesSent ( ) , is ( 2L ) ) ; assertThat ( "FAIL: Exactly 20 bits should have been sent" , ( ( TestCallbackStats ) callback ) . numBitsSent ( ) , is ( 20L ) ) ; } @ Test public void sendTwoIterationsOfTwoIntervals ( ) throws Exception { class Callback extends TestCallback { public int onNext ( ) { numMessagesSent ++ ; numBitsSent += 10 ; return 10 ; } } final RateController . Callback callback = new Callback ( ) ; final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; ivlsList . add ( new MessagesAtMessagesPerSecondInterval ( 1 , Long . MAX_VALUE ) ) ; ivlsList . add ( new MessagesAtBitsPerSecondInterval ( 1 , Long . MAX_VALUE ) ) ; rc = new RateController ( callback , ivlsList , 2 ) ; while ( rc . next ( ) ) { } assertThat ( "FAIL: Exactly four messages should have been sent" , ( ( TestCallbackStats ) callback ) . numMessagesSent ( ) , is ( 4L ) ) ; assertThat ( "FAIL: Exactly 40 bits should have been sent" , ( ( TestCallbackStats ) callback ) . numBitsSent ( ) , is ( 40L ) ) ; } @ Test public void sendForOneSecond ( ) throws Exception { final List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; ivlsList . add ( new SecondsAtMessagesPerSecondInterval ( 1 , Long . MAX_VALUE ) ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; final long startTime = System . nanoTime ( ) ; while ( rc . next ( ) ) { } final long endTime = System . nanoTime ( ) ; assertThat ( "FAIL: Send should have taken about one second" , endTime , both ( greaterThanOrEqualTo ( startTime + 800000000L ) ) . and ( lessThanOrEqualTo ( startTime + 1200000000L ) ) ) ; } }
package uk . co . real_logic . aeron ; import org . junit . Before ; import org . junit . Test ; import uk . co . real_logic . aeron . command . * ; import uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . protocol . ErrorFlyweight ; import uk . co . real_logic . aeron . exceptions . DriverTimeoutException ; import uk . co . real_logic . aeron . exceptions . RegistrationException ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . concurrent . EpochClock ; import uk . co . real_logic . agrona . concurrent . SystemEpochClock ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . broadcast . CopyBroadcastReceiver ; import java . nio . ByteBuffer ; import java . util . function . Consumer ; import java . util . function . Function ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . hamcrest . Matchers . not ; import static org . hamcrest . Matchers . sameInstance ; import static org . hamcrest . core . Is . is ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import static org . mockito . Mockito . * ; import static uk . co . real_logic . aeron . ErrorCode . INVALID_CHANNEL ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . * ; public class ClientConductorTest { private static final int TERM_BUFFER_LENGTH = TERM_MIN_LENGTH ; private static final int NUM_BUFFERS = ( PARTITION_COUNT * 2 ) + 1 ; protected static final int SESSION_ID_1 = 13 ; protected static final int SESSION_ID_2 = 15 ; private static final int COUNTER_BUFFER_LENGTH = 1024 ; private static final String CHANNEL = "udp://localhost:40124" ; private static final int STREAM_ID_1 = 2 ; private static final int STREAM_ID_2 = 4 ; private static final int SEND_BUFFER_CAPACITY = 1024 ; private static final long CORRELATION_ID = 2000 ; private static final long CORRELATION_ID_2 = 2002 ; private static final long CLOSE_CORRELATION_ID = 2001 ; private static final long UNKNOWN_CORRELATION_ID = 3000 ; private static final int AWAIT_TIMEOUT = 100 ; private static final String SOURCE_INFO = "127.0.0.1:40789" ; private final PublicationBuffersReadyFlyweight publicationReady = new PublicationBuffersReadyFlyweight ( ) ; private final ConnectionBuffersReadyFlyweight connectionReady = new ConnectionBuffersReadyFlyweight ( ) ; private final CorrelatedMessageFlyweight correlatedMessage = new CorrelatedMessageFlyweight ( ) ; private final ErrorFlyweight errorMessage = new ErrorFlyweight ( ) ; private final UnsafeBuffer publicationReadyBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( SEND_BUFFER_CAPACITY ) ) ; private final UnsafeBuffer connectionReadyBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( SEND_BUFFER_CAPACITY ) ) ; private final UnsafeBuffer correlatedMessageBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( SEND_BUFFER_CAPACITY ) ) ; private final UnsafeBuffer errorMessageBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( SEND_BUFFER_CAPACITY ) ) ; private final CopyBroadcastReceiver mockToClientReceiver = mock ( CopyBroadcastReceiver . class ) ; private final UnsafeBuffer counterValuesBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( COUNTER_BUFFER_LENGTH ) ) ; private final EpochClock epochClock = new SystemEpochClock ( ) ; private final TimerWheel timerWheel = mock ( TimerWheel . class ) ; private final Consumer < Throwable > mockClientErrorHandler = Throwable : : printStackTrace ; private DriverProxy driverProxy ; private ClientConductor conductor ; private NewConnectionHandler mockNewConnectionHandler = mock ( NewConnectionHandler . class ) ; private InactiveConnectionHandler mockInactiveConnectionHandler = mock ( InactiveConnectionHandler . class ) ; private LogBuffersFactory logBuffersFactory = mock ( LogBuffersFactory . class ) ; @ Before public void setUp ( ) throws Exception { driverProxy = mock ( DriverProxy . class ) ; when ( driverProxy . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ) . thenReturn ( CORRELATION_ID ) ; when ( driverProxy . addPublication ( CHANNEL , STREAM_ID_2 , SESSION_ID_2 ) ) . thenReturn ( CORRELATION_ID_2 ) ; when ( driverProxy . removePublication ( CORRELATION_ID ) ) . thenReturn ( CLOSE_CORRELATION_ID ) ; when ( driverProxy . addSubscription ( anyString ( ) , anyInt ( ) ) ) . thenReturn ( CORRELATION_ID ) ; when ( driverProxy . removeSubscription ( CORRELATION_ID ) ) . thenReturn ( CLOSE_CORRELATION_ID ) ; when ( timerWheel . clock ( ) ) . thenReturn ( System : : nanoTime ) ; conductor = new ClientConductor ( epochClock , mockToClientReceiver , logBuffersFactory , counterValuesBuffer , driverProxy , timerWheel , mockClientErrorHandler , mockNewConnectionHandler , mockInactiveConnectionHandler , AWAIT_TIMEOUT ) ; publicationReady . wrap ( publicationReadyBuffer , 0 ) ; connectionReady . wrap ( connectionReadyBuffer , 0 ) ; correlatedMessage . wrap ( correlatedMessageBuffer , 0 ) ; errorMessage . wrap ( errorMessageBuffer , 0 ) ; publicationReady . correlationId ( CORRELATION_ID ) ; publicationReady . sessionId ( SESSION_ID_1 ) ; publicationReady . streamId ( STREAM_ID_1 ) ; publicationReady . logFileName ( SESSION_ID_1 + "-log" ) ; connectionReady . sourceIdentity ( SOURCE_INFO ) ; connectionReady . subscriberPositionCount ( 1 ) ; connectionReady . subscriberPositionId ( 0 , 0 ) ; connectionReady . positionIndicatorRegistrationId ( 0 , CORRELATION_ID ) ; correlatedMessage . correlationId ( CLOSE_CORRELATION_ID ) ; final UnsafeBuffer [ ] atomicBuffersSession1 = new UnsafeBuffer [ NUM_BUFFERS ] ; final UnsafeBuffer [ ] atomicBuffersSession2 = new UnsafeBuffer [ NUM_BUFFERS ] ; for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { final UnsafeBuffer termBuffersSession1 = new UnsafeBuffer ( ByteBuffer . allocateDirect ( TERM_BUFFER_LENGTH ) ) ; final UnsafeBuffer metaDataBuffersSession1 = new UnsafeBuffer ( ByteBuffer . allocateDirect ( TERM_META_DATA_LENGTH ) ) ; final UnsafeBuffer termBuffersSession2 = new UnsafeBuffer ( ByteBuffer . allocateDirect ( TERM_BUFFER_LENGTH ) ) ; final UnsafeBuffer metaDataBuffersSession2 = new UnsafeBuffer ( ByteBuffer . allocateDirect ( TERM_META_DATA_LENGTH ) ) ; atomicBuffersSession1 [ i ] = termBuffersSession1 ; atomicBuffersSession1 [ i + PARTITION_COUNT ] = metaDataBuffersSession1 ; atomicBuffersSession2 [ i ] = termBuffersSession2 ; atomicBuffersSession2 [ i + PARTITION_COUNT ] = metaDataBuffersSession2 ; } atomicBuffersSession1 [ LOG_META_DATA_SECTION_INDEX ] = new UnsafeBuffer ( ByteBuffer . allocateDirect ( TERM_BUFFER_LENGTH ) ) ; atomicBuffersSession2 [ LOG_META_DATA_SECTION_INDEX ] = new UnsafeBuffer ( ByteBuffer . allocateDirect ( TERM_BUFFER_LENGTH ) ) ; final MutableDirectBuffer header1 = DataHeaderFlyweight . createDefaultHeader ( SESSION_ID_1 , STREAM_ID_1 , 0 ) ; final MutableDirectBuffer header2 = DataHeaderFlyweight . createDefaultHeader ( SESSION_ID_2 , STREAM_ID_2 , 0 ) ; LogBufferDescriptor . storeDefaultFrameHeaders ( atomicBuffersSession1 [ LOG_META_DATA_SECTION_INDEX ] , header1 ) ; LogBufferDescriptor . storeDefaultFrameHeaders ( atomicBuffersSession2 [ LOG_META_DATA_SECTION_INDEX ] , header2 ) ; final LogBuffers logBuffersSession1 = mock ( LogBuffers . class ) ; final LogBuffers logBuffersSession2 = mock ( LogBuffers . class ) ; when ( logBuffersFactory . map ( eq ( SESSION_ID_1 + "-log" ) ) ) . thenReturn ( logBuffersSession1 ) ; when ( logBuffersFactory . map ( eq ( SESSION_ID_2 + "-log" ) ) ) . thenReturn ( logBuffersSession2 ) ; when ( logBuffersSession1 . atomicBuffers ( ) ) . thenReturn ( atomicBuffersSession1 ) ; when ( logBuffersSession2 . atomicBuffers ( ) ) . thenReturn ( atomicBuffersSession2 ) ; } @ Test public void addPublicationShouldNotifyMediaDriver ( ) throws Exception { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_PUBLICATION_READY , publicationReadyBuffer , ( buffer ) - > publicationReady . length ( ) ) ; conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; verify ( driverProxy ) . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; } @ Test public void addPublicationShouldMapLogFile ( ) throws Exception { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_PUBLICATION_READY , publicationReadyBuffer , ( buffer ) - > publicationReady . length ( ) ) ; conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; verify ( logBuffersFactory ) . map ( SESSION_ID_1 + "-log" ) ; } @ Test ( expected = DriverTimeoutException . class ) public void addPublicationShouldTimeoutWithoutReadyMessage ( ) { conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; } @ Test public void conductorShouldCachePublicationInstances ( ) { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_PUBLICATION_READY , publicationReadyBuffer , ( buffer ) - > publicationReady . length ( ) ) ; final Publication firstPublication = conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; final Publication secondPublication = conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; assertThat ( firstPublication , sameInstance ( secondPublication ) ) ; } @ Test public void closingPublicationShouldNotifyMediaDriver ( ) throws Exception { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_PUBLICATION_READY , publicationReadyBuffer , ( buffer ) - > publicationReady . length ( ) ) ; final Publication publication = conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_OPERATION_SUCCESS , correlatedMessageBuffer , ( buffer ) - > CorrelatedMessageFlyweight . LENGTH ) ; publication . close ( ) ; verify ( driverProxy ) . removePublication ( CORRELATION_ID ) ; } @ Test public void closingPublicationShouldPurgeCache ( ) throws Exception { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_PUBLICATION_READY , publicationReadyBuffer , ( buffer ) - > publicationReady . length ( ) ) ; final Publication firstPublication = conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_OPERATION_SUCCESS , correlatedMessageBuffer , ( buffer ) - > CorrelatedMessageFlyweight . LENGTH ) ; firstPublication . close ( ) ; whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_PUBLICATION_READY , publicationReadyBuffer , ( buffer ) - > publicationReady . length ( ) ) ; final Publication secondPublication = conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; assertThat ( firstPublication , not ( sameInstance ( secondPublication ) ) ) ; } @ Test ( expected = RegistrationException . class ) public void shouldFailToClosePublicationOnMediaDriverError ( ) { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_PUBLICATION_READY , publicationReadyBuffer , ( buffer ) - > publicationReady . length ( ) ) ; final Publication publication = conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_ERROR , errorMessageBuffer , ( buffer ) - > { final byte [ ] message = "channel unknown" . getBytes ( ) ; final RemoveMessageFlyweight removeMessage = new RemoveMessageFlyweight ( ) ; removeMessage . wrap ( new UnsafeBuffer ( ByteBuffer . allocateDirect ( SEND_BUFFER_CAPACITY ) ) , 0 ) ; removeMessage . correlationId ( CLOSE_CORRELATION_ID ) ; errorMessage . errorCode ( INVALID_CHANNEL ) ; errorMessage . offendingFlyweight ( removeMessage , RemoveMessageFlyweight . LENGTH ) ; errorMessage . errorMessage ( message ) ; errorMessage . frameLength ( ErrorFlyweight . HEADER_LENGTH + message . length + RemoveMessageFlyweight . LENGTH ) ; return errorMessage . frameLength ( ) ; } ) ; publication . close ( ) ; } @ Test ( expected = RegistrationException . class ) public void shouldFailToAddPublicationOnMediaDriverError ( ) { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_ERROR , errorMessageBuffer , ( buffer ) - > { final byte [ ] message = "invalid channel" . getBytes ( ) ; final PublicationMessageFlyweight publicationMessage = new PublicationMessageFlyweight ( ) ; publicationMessage . wrap ( new UnsafeBuffer ( ByteBuffer . allocateDirect ( SEND_BUFFER_CAPACITY ) ) , 0 ) ; publicationMessage . correlationId ( CORRELATION_ID ) ; errorMessage . errorCode ( INVALID_CHANNEL ) ; errorMessage . offendingFlyweight ( publicationMessage , publicationMessage . length ( ) ) ; errorMessage . errorMessage ( message ) ; errorMessage . frameLength ( ErrorFlyweight . HEADER_LENGTH + message . length + publicationMessage . length ( ) ) ; return errorMessage . frameLength ( ) ; } ) ; conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; } @ Test public void publicationOnlyRemovedOnLastClose ( ) throws Exception { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_PUBLICATION_READY , publicationReadyBuffer , ( buffer ) - > publicationReady . length ( ) ) ; final Publication publication = conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; publication . close ( ) ; verify ( driverProxy , never ( ) ) . removePublication ( CORRELATION_ID ) ; whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_OPERATION_SUCCESS , correlatedMessageBuffer , ( buffer ) - > CorrelatedMessageFlyweight . LENGTH ) ; publication . close ( ) ; verify ( driverProxy ) . removePublication ( CORRELATION_ID ) ; } @ Test public void closingPublicationDoesNotRemoveOtherPublications ( ) throws Exception { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_PUBLICATION_READY , publicationReadyBuffer , ( buffer ) - > publicationReady . length ( ) ) ; final Publication publication = conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_PUBLICATION_READY , publicationReadyBuffer , ( buffer ) - > { publicationReady . streamId ( STREAM_ID_2 ) ; publicationReady . sessionId ( SESSION_ID_2 ) ; publicationReady . logFileName ( SESSION_ID_2 + "-log" ) ; publicationReady . correlationId ( CORRELATION_ID_2 ) ; return publicationReady . length ( ) ; } ) ; conductor . addPublication ( CHANNEL , STREAM_ID_2 , SESSION_ID_2 ) ; whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_OPERATION_SUCCESS , correlatedMessageBuffer , ( buffer ) - > CorrelatedMessageFlyweight . LENGTH ) ; publication . close ( ) ; verify ( driverProxy ) . removePublication ( CORRELATION_ID ) ; verify ( driverProxy , never ( ) ) . removePublication ( CORRELATION_ID_2 ) ; } @ Test public void shouldNotMapBuffersForUnknownCorrelationId ( ) throws Exception { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_PUBLICATION_READY , publicationReadyBuffer , ( buffer ) - > { publicationReady . correlationId ( UNKNOWN_CORRELATION_ID ) ; return publicationReady . length ( ) ; } ) ; whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_PUBLICATION_READY , publicationReadyBuffer , ( buffer ) - > { publicationReady . correlationId ( CORRELATION_ID ) ; return publicationReady . length ( ) ; } ) ; final Publication publication = conductor . addPublication ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 ) ; conductor . doWork ( ) ; verify ( logBuffersFactory , times ( 1 ) ) . map ( anyString ( ) ) ; assertThat ( publication . registrationId ( ) , is ( CORRELATION_ID ) ) ; } @ Test public void addSubscriptionShouldNotifyMediaDriver ( ) throws Exception { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_OPERATION_SUCCESS , correlatedMessageBuffer , ( buffer ) - > { correlatedMessage . correlationId ( CORRELATION_ID ) ; return CorrelatedMessageFlyweight . LENGTH ; } ) ; conductor . addSubscription ( CHANNEL , STREAM_ID_1 ) ; verify ( driverProxy ) . addSubscription ( CHANNEL , STREAM_ID_1 ) ; } @ Test public void closingSubscriptionShouldNotifyMediaDriver ( ) { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_OPERATION_SUCCESS , correlatedMessageBuffer , ( buffer ) - > { correlatedMessage . correlationId ( CORRELATION_ID ) ; return CorrelatedMessageFlyweight . LENGTH ; } ) ; final Subscription subscription = conductor . addSubscription ( CHANNEL , STREAM_ID_1 ) ; whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_OPERATION_SUCCESS , correlatedMessageBuffer , ( buffer ) - > { correlatedMessage . correlationId ( CLOSE_CORRELATION_ID ) ; return CorrelatedMessageFlyweight . LENGTH ; } ) ; subscription . close ( ) ; verify ( driverProxy ) . removeSubscription ( CORRELATION_ID ) ; } @ Test ( expected = DriverTimeoutException . class ) public void addSubscriptionShouldTimeoutWithoutOperationSuccessful ( ) { conductor . addSubscription ( CHANNEL , STREAM_ID_1 ) ; } @ Test ( expected = RegistrationException . class ) public void shouldFailToAddSubscriptionOnMediaDriverError ( ) { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_ERROR , errorMessageBuffer , ( buffer ) - > { final byte [ ] message = "invalid channel" . getBytes ( ) ; final SubscriptionMessageFlyweight subscriptionMessage = new SubscriptionMessageFlyweight ( ) ; subscriptionMessage . wrap ( new UnsafeBuffer ( ByteBuffer . allocateDirect ( SEND_BUFFER_CAPACITY ) ) , 0 ) ; subscriptionMessage . correlationId ( CORRELATION_ID ) ; errorMessage . errorCode ( INVALID_CHANNEL ) ; errorMessage . offendingFlyweight ( subscriptionMessage , subscriptionMessage . length ( ) ) ; errorMessage . errorMessage ( message ) ; errorMessage . frameLength ( ErrorFlyweight . HEADER_LENGTH + message . length + subscriptionMessage . length ( ) ) ; return errorMessage . frameLength ( ) ; } ) ; conductor . addSubscription ( CHANNEL , STREAM_ID_1 ) ; } @ Test public void clientNotifiedOfNewConnectionShouldMapLogFile ( ) { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_OPERATION_SUCCESS , correlatedMessageBuffer , ( buffer ) - > { correlatedMessage . correlationId ( CORRELATION_ID ) ; return CorrelatedMessageFlyweight . LENGTH ; } ) ; conductor . addSubscription ( CHANNEL , STREAM_ID_1 ) ; conductor . onNewConnection ( STREAM_ID_1 , SESSION_ID_1 , 0L , SESSION_ID_1 + "-log" , connectionReady , CORRELATION_ID ) ; verify ( logBuffersFactory ) . map ( SESSION_ID_1 + "-log" ) ; } @ Test public void clientNotifiedOfNewConnectionsAndInactiveConnections ( ) { whenReceiveBroadcastOnMessage ( ControlProtocolEvents . ON_OPERATION_SUCCESS , correlatedMessageBuffer , ( buffer ) - > { correlatedMessage . correlationId ( CORRELATION_ID ) ; return CorrelatedMessageFlyweight . LENGTH ; } ) ; final Subscription subscription = conductor . addSubscription ( CHANNEL , STREAM_ID_1 ) ; conductor . onNewConnection ( STREAM_ID_1 , SESSION_ID_1 , 0L , SESSION_ID_1 + "-log" , connectionReady , CORRELATION_ID ) ; assertFalse ( subscription . hasNoConnections ( ) ) ; verify ( mockNewConnectionHandler ) . onNewConnection ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 , 0L , SOURCE_INFO ) ; final long position = 0L ; conductor . onInactiveConnection ( STREAM_ID_1 , SESSION_ID_1 , position , CORRELATION_ID ) ; verify ( mockInactiveConnectionHandler ) . onInactiveConnection ( CHANNEL , STREAM_ID_1 , SESSION_ID_1 , position ) ; assertTrue ( subscription . hasNoConnections ( ) ) ; assertFalse ( subscription . isConnected ( SESSION_ID_1 ) ) ; } @ Test public void shouldIgnoreUnknownNewConnection ( ) { conductor . onNewConnection ( STREAM_ID_2 , SESSION_ID_2 , 0L , SESSION_ID_2 + "-log" , connectionReady , CORRELATION_ID_2 ) ; verify ( logBuffersFactory , never ( ) ) . map ( anyString ( ) ) ; verify ( mockNewConnectionHandler , never ( ) ) . onNewConnection ( anyString ( ) , anyInt ( ) , anyInt ( ) , anyLong ( ) , anyString ( ) ) ; } @ Test public void shouldIgnoreUnknownInactiveConnection ( ) { conductor . onInactiveConnection ( STREAM_ID_2 , SESSION_ID_2 , 0L , CORRELATION_ID_2 ) ; verify ( logBuffersFactory , never ( ) ) . map ( anyString ( ) ) ; verify ( mockInactiveConnectionHandler , never ( ) ) . onInactiveConnection ( anyString ( ) , anyInt ( ) , anyInt ( ) , anyLong ( ) ) ; } private void whenReceiveBroadcastOnMessage ( final int msgTypeId , final MutableDirectBuffer buffer , final Function < MutableDirectBuffer , Integer > filler ) { doAnswer ( ( invocation ) - > { final int length = filler . apply ( buffer ) ; conductor . driverListenerAdapter ( ) . onMessage ( msgTypeId , buffer , 0 , length ) ; return 1 ; } ) . when ( mockToClientReceiver ) . receive ( anyObject ( ) ) ; } }
package uk . co . real_logic . aeron ; import org . junit . Before ; import org . junit . Test ; import org . mockito . ArgumentCaptor ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . FrameDescriptor ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteOrder ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . * ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . * ; public class FragmentAssemblyAdapterTest { private static final int SESSION_ID = 777 ; private static final int INITIAL_TERM_ID = 3 ; private final FragmentHandler delegateFragmentHandler = mock ( FragmentHandler . class ) ; private final UnsafeBuffer termBuffer = mock ( UnsafeBuffer . class ) ; private final Header header = spy ( new Header ( INITIAL_TERM_ID , LogBufferDescriptor . TERM_MIN_LENGTH ) ) ; private final FragmentAssemblyAdapter adapter = new FragmentAssemblyAdapter ( delegateFragmentHandler ) ; @ Before public void setUp ( ) { header . buffer ( termBuffer ) ; when ( termBuffer . getInt ( anyInt ( ) , any ( ByteOrder . class ) ) ) . thenReturn ( SESSION_ID ) ; } @ Test public void shouldPassThroughUnfragmentedMessage ( ) { when ( header . flags ( ) ) . thenReturn ( FrameDescriptor . UNFRAGMENTED ) ; final UnsafeBuffer srcBuffer = new UnsafeBuffer ( new byte [ 128 ] ) ; final int offset = 8 ; final int length = 32 ; adapter . onFragment ( srcBuffer , offset , length , header ) ; verify ( delegateFragmentHandler , times ( 1 ) ) . onFragment ( srcBuffer , offset , length , header ) ; } @ Test public void shouldAssembleTwoPartMessage ( ) { when ( header . flags ( ) ) . thenReturn ( FrameDescriptor . BEGIN_FRAG ) . thenReturn ( FrameDescriptor . END_FRAG ) ; final UnsafeBuffer srcBuffer = new UnsafeBuffer ( new byte [ 1024 ] ) ; final int offset = 0 ; final int length = srcBuffer . capacity ( ) / 2 ; srcBuffer . setMemory ( 0 , length , ( byte ) 65 ) ; srcBuffer . setMemory ( length , length , ( byte ) 66 ) ; adapter . onFragment ( srcBuffer , offset , length , header ) ; adapter . onFragment ( srcBuffer , length , length , header ) ; final ArgumentCaptor < UnsafeBuffer > bufferArg = ArgumentCaptor . forClass ( UnsafeBuffer . class ) ; final ArgumentCaptor < Header > headerArg = ArgumentCaptor . forClass ( Header . class ) ; verify ( delegateFragmentHandler , times ( 1 ) ) . onFragment ( bufferArg . capture ( ) , eq ( offset ) , eq ( length * 2 ) , headerArg . capture ( ) ) ; final UnsafeBuffer capturedBuffer = bufferArg . getValue ( ) ; for ( int i = 0 ; i < srcBuffer . capacity ( ) ; i ++ ) { assertThat ( "same at i=" + i , capturedBuffer . getByte ( i ) , is ( srcBuffer . getByte ( i ) ) ) ; } final Header capturedHeader = headerArg . getValue ( ) ; assertThat ( capturedHeader . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( capturedHeader . flags ( ) , is ( FrameDescriptor . UNFRAGMENTED ) ) ; } @ Test public void shouldAssembleFourPartMessage ( ) { when ( header . flags ( ) ) . thenReturn ( FrameDescriptor . BEGIN_FRAG ) . thenReturn ( ( byte ) 0 ) . thenReturn ( ( byte ) 0 ) . thenReturn ( FrameDescriptor . END_FRAG ) ; final UnsafeBuffer srcBuffer = new UnsafeBuffer ( new byte [ 1024 ] ) ; final int offset = 0 ; final int length = srcBuffer . capacity ( ) / 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { srcBuffer . setMemory ( i * length , length , ( byte ) ( 65 + i ) ) ; } adapter . onFragment ( srcBuffer , offset , length , header ) ; adapter . onFragment ( srcBuffer , offset + length , length , header ) ; adapter . onFragment ( srcBuffer , offset + ( length * 2 ) , length , header ) ; adapter . onFragment ( srcBuffer , offset + ( length * 3 ) , length , header ) ; final ArgumentCaptor < UnsafeBuffer > bufferArg = ArgumentCaptor . forClass ( UnsafeBuffer . class ) ; final ArgumentCaptor < Header > headerArg = ArgumentCaptor . forClass ( Header . class ) ; verify ( delegateFragmentHandler , times ( 1 ) ) . onFragment ( bufferArg . capture ( ) , eq ( offset ) , eq ( length * 4 ) , headerArg . capture ( ) ) ; final UnsafeBuffer capturedBuffer = bufferArg . getValue ( ) ; for ( int i = 0 ; i < srcBuffer . capacity ( ) ; i ++ ) { assertThat ( "same at i=" + i , capturedBuffer . getByte ( i ) , is ( srcBuffer . getByte ( i ) ) ) ; } final Header capturedHeader = headerArg . getValue ( ) ; assertThat ( capturedHeader . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( capturedHeader . flags ( ) , is ( FrameDescriptor . UNFRAGMENTED ) ) ; } @ Test public void shouldFreeSessionBuffer ( ) { when ( header . flags ( ) ) . thenReturn ( FrameDescriptor . BEGIN_FRAG ) . thenReturn ( FrameDescriptor . END_FRAG ) ; final UnsafeBuffer srcBuffer = new UnsafeBuffer ( new byte [ 1024 ] ) ; final int offset = 0 ; final int length = srcBuffer . capacity ( ) / 2 ; srcBuffer . setMemory ( 0 , length , ( byte ) 65 ) ; srcBuffer . setMemory ( length , length , ( byte ) 66 ) ; assertFalse ( adapter . freeSessionBuffer ( SESSION_ID ) ) ; adapter . onFragment ( srcBuffer , offset , length , header ) ; adapter . onFragment ( srcBuffer , length , length , header ) ; assertTrue ( adapter . freeSessionBuffer ( SESSION_ID ) ) ; assertFalse ( adapter . freeSessionBuffer ( SESSION_ID ) ) ; } @ Test public void shouldDoNotingIfEndArrivesWithoutBegin ( ) { when ( header . flags ( ) ) . thenReturn ( FrameDescriptor . END_FRAG ) ; final UnsafeBuffer srcBuffer = new UnsafeBuffer ( new byte [ 1024 ] ) ; final int offset = 0 ; final int length = srcBuffer . capacity ( ) / 2 ; adapter . onFragment ( srcBuffer , offset , length , header ) ; verify ( delegateFragmentHandler , never ( ) ) . onFragment ( anyObject ( ) , anyInt ( ) , anyInt ( ) , anyObject ( ) ) ; } @ Test public void shouldDoNotingIfMidArrivesWithoutBegin ( ) { when ( header . flags ( ) ) . thenReturn ( ( byte ) 0 ) . thenReturn ( FrameDescriptor . END_FRAG ) ; final UnsafeBuffer srcBuffer = new UnsafeBuffer ( new byte [ 1024 ] ) ; final int offset = 0 ; final int length = srcBuffer . capacity ( ) / 2 ; adapter . onFragment ( srcBuffer , offset , length , header ) ; adapter . onFragment ( srcBuffer , offset , length , header ) ; verify ( delegateFragmentHandler , never ( ) ) . onFragment ( anyObject ( ) , anyInt ( ) , anyInt ( ) , anyObject ( ) ) ; } }
package uk . co . real_logic . aeron ; import org . junit . Before ; import org . junit . Test ; import org . mockito . InOrder ; import org . mockito . Mockito ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . aeron . protocol . HeaderFlyweight ; import uk . co . real_logic . aeron . logbuffer . * ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . status . AtomicLongPosition ; import uk . co . real_logic . agrona . concurrent . status . Position ; import java . nio . ByteBuffer ; import java . util . function . Consumer ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . hamcrest . Matchers . is ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . * ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . * ; import static uk . co . real_logic . agrona . BitUtil . align ; public class ConnectionTest { private static final int TERM_BUFFER_LENGTH = LogBufferDescriptor . TERM_MIN_LENGTH ; private static final int POSITION_BITS_TO_SHIFT = Integer . numberOfTrailingZeros ( TERM_BUFFER_LENGTH ) ; private static final byte [ ] DATA = new byte [ 36 ] ; static { for ( int i = 0 ; i < DATA . length ; i ++ ) { DATA [ i ] = ( byte ) i ; } } private static final long CORRELATION_ID = 0xC044E1AL ; private static final int SESSION_ID = 0x5E55101D ; private static final int STREAM_ID = 0xC400E ; private static final int INITIAL_TERM_ID = 0xEE81D ; private static final int MESSAGE_LENGTH = DataHeaderFlyweight . HEADER_LENGTH + DATA . length ; private static final int ALIGNED_FRAME_LENGTH = align ( MESSAGE_LENGTH , FrameDescriptor . FRAME_ALIGNMENT ) ; private final UnsafeBuffer rcvBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( ALIGNED_FRAME_LENGTH ) ) ; private final DataHeaderFlyweight dataHeader = new DataHeaderFlyweight ( ) ; private final FragmentHandler mockFragmentHandler = mock ( FragmentHandler . class ) ; private final Position position = spy ( new AtomicLongPosition ( ) ) ; private final LogBuffers logBuffers = mock ( LogBuffers . class ) ; private final Consumer < Throwable > errorHandler = mock ( Consumer . class ) ; private UnsafeBuffer [ ] atomicBuffers = new UnsafeBuffer [ ( PARTITION_COUNT * 2 ) + 1 ] ; private UnsafeBuffer [ ] termBuffers = new UnsafeBuffer [ PARTITION_COUNT ] ; @ Before public void setUp ( ) { dataHeader . wrap ( rcvBuffer , 0 ) ; for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { atomicBuffers [ i ] = new UnsafeBuffer ( ByteBuffer . allocateDirect ( TERM_BUFFER_LENGTH ) ) ; termBuffers [ i ] = atomicBuffers [ i ] ; } for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { atomicBuffers [ i + PARTITION_COUNT ] = new UnsafeBuffer ( ByteBuffer . allocateDirect ( TERM_META_DATA_LENGTH ) ) ; } atomicBuffers [ atomicBuffers . length - 1 ] = new UnsafeBuffer ( ByteBuffer . allocateDirect ( LOG_META_DATA_LENGTH ) ) ; when ( logBuffers . atomicBuffers ( ) ) . thenReturn ( atomicBuffers ) ; } @ Test public void shouldReportCorrectPositionOnReception ( ) { final long initialPosition = computePosition ( INITIAL_TERM_ID , 0 , POSITION_BITS_TO_SHIFT , INITIAL_TERM_ID ) ; final Connection connection = createConnection ( initialPosition ) ; insertDataFrame ( INITIAL_TERM_ID , offsetOfFrame ( 0 ) ) ; final int messages = connection . poll ( mockFragmentHandler , Integer . MAX_VALUE , errorHandler ) ; assertThat ( messages , is ( 1 ) ) ; verify ( mockFragmentHandler ) . onFragment ( any ( UnsafeBuffer . class ) , eq ( DataHeaderFlyweight . HEADER_LENGTH ) , eq ( DATA . length ) , any ( Header . class ) ) ; final InOrder inOrder = Mockito . inOrder ( position ) ; inOrder . verify ( position ) . setOrdered ( initialPosition ) ; inOrder . verify ( position ) . setOrdered ( initialPosition + ALIGNED_FRAME_LENGTH ) ; } @ Test public void shouldReportCorrectPositionOnReceptionWithNonZeroPositionInInitialTermId ( ) { final int initialMessageIndex = 5 ; final int initialTermOffset = offsetOfFrame ( initialMessageIndex ) ; final long initialPosition = computePosition ( INITIAL_TERM_ID , initialTermOffset , POSITION_BITS_TO_SHIFT , INITIAL_TERM_ID ) ; final Connection connection = createConnection ( initialPosition ) ; insertDataFrame ( INITIAL_TERM_ID , offsetOfFrame ( initialMessageIndex ) ) ; final int messages = connection . poll ( mockFragmentHandler , Integer . MAX_VALUE , errorHandler ) ; assertThat ( messages , is ( 1 ) ) ; verify ( mockFragmentHandler ) . onFragment ( any ( UnsafeBuffer . class ) , eq ( initialTermOffset + DataHeaderFlyweight . HEADER_LENGTH ) , eq ( DATA . length ) , any ( Header . class ) ) ; final InOrder inOrder = Mockito . inOrder ( position ) ; inOrder . verify ( position ) . setOrdered ( initialPosition ) ; inOrder . verify ( position ) . setOrdered ( initialPosition + ALIGNED_FRAME_LENGTH ) ; } @ Test public void shouldReportCorrectPositionOnReceptionWithNonZeroPositionInNonInitialTermId ( ) { final int activeTermId = INITIAL_TERM_ID + 1 ; final int initialMessageIndex = 5 ; final int initialTermOffset = offsetOfFrame ( initialMessageIndex ) ; final long initialPosition = computePosition ( activeTermId , initialTermOffset , POSITION_BITS_TO_SHIFT , INITIAL_TERM_ID ) ; final Connection connection = createConnection ( initialPosition ) ; insertDataFrame ( activeTermId , offsetOfFrame ( initialMessageIndex ) ) ; final int messages = connection . poll ( mockFragmentHandler , Integer . MAX_VALUE , errorHandler ) ; assertThat ( messages , is ( 1 ) ) ; verify ( mockFragmentHandler ) . onFragment ( any ( UnsafeBuffer . class ) , eq ( initialTermOffset + DataHeaderFlyweight . HEADER_LENGTH ) , eq ( DATA . length ) , any ( Header . class ) ) ; final InOrder inOrder = Mockito . inOrder ( position ) ; inOrder . verify ( position ) . setOrdered ( initialPosition ) ; inOrder . verify ( position ) . setOrdered ( initialPosition + ALIGNED_FRAME_LENGTH ) ; } public Connection createConnection ( final long initialPosition ) { return new Connection ( SESSION_ID , initialPosition , CORRELATION_ID , position , logBuffers ) ; } private void insertDataFrame ( final int activeTermId , final int termOffset ) { dataHeader . termId ( INITIAL_TERM_ID ) . streamId ( STREAM_ID ) . sessionId ( SESSION_ID ) . termOffset ( termOffset ) . frameLength ( DATA . length + DataHeaderFlyweight . HEADER_LENGTH ) . headerType ( HeaderFlyweight . HDR_TYPE_DATA ) . flags ( DataHeaderFlyweight . BEGIN_AND_END_FLAGS ) . version ( HeaderFlyweight . CURRENT_VERSION ) ; rcvBuffer . putBytes ( dataHeader . dataOffset ( ) , DATA ) ; final int activeIndex = indexByTerm ( INITIAL_TERM_ID , activeTermId ) ; TermRebuilder . insert ( termBuffers [ activeIndex ] , termOffset , rcvBuffer , ALIGNED_FRAME_LENGTH ) ; } private int offsetOfFrame ( final int index ) { return index * ALIGNED_FRAME_LENGTH ; } }
package uk . co . real_logic . aeron ; import org . junit . Test ; import uk . co . real_logic . aeron . command . PublicationMessageFlyweight ; import uk . co . real_logic . aeron . command . RemoveMessageFlyweight ; import uk . co . real_logic . agrona . concurrent . MessageHandler ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . ringbuffer . ManyToOneRingBuffer ; import uk . co . real_logic . agrona . concurrent . ringbuffer . RingBuffer ; import java . nio . ByteBuffer ; import static org . hamcrest . Matchers . is ; import static org . junit . Assert . assertThat ; import static uk . co . real_logic . aeron . command . ControlProtocolEvents . * ; import static uk . co . real_logic . agrona . concurrent . ringbuffer . RingBufferDescriptor . TRAILER_LENGTH ; public class DriverProxyTest { public static final String CHANNEL = "udp://localhost:40123@localhost:40124" ; private static final int STREAM_ID = 1 ; private static final int SESSION_ID = 2 ; private static final long CORRELATION_ID = 3 ; private final RingBuffer conductorBuffer = new ManyToOneRingBuffer ( new UnsafeBuffer ( ByteBuffer . allocateDirect ( TRAILER_LENGTH + 1024 ) ) ) ; private final DriverProxy conductor = new DriverProxy ( conductorBuffer ) ; @ Test public void threadSendsAddChannelMessage ( ) { threadSendsChannelMessage ( ( ) - > conductor . addPublication ( CHANNEL , STREAM_ID , SESSION_ID ) , ADD_PUBLICATION ) ; } @ Test public void threadSendsRemoveChannelMessage ( ) { conductor . removePublication ( CORRELATION_ID ) ; assertReadsOneMessage ( ( msgTypeId , buffer , index , length ) - > { final RemoveMessageFlyweight message = new RemoveMessageFlyweight ( ) ; message . wrap ( buffer , index ) ; assertThat ( msgTypeId , is ( REMOVE_PUBLICATION ) ) ; assertThat ( message . registrationId ( ) , is ( CORRELATION_ID ) ) ; } ) ; } private void threadSendsChannelMessage ( final Runnable sendMessage , final int expectedMsgTypeId ) { sendMessage . run ( ) ; assertReadsOneMessage ( ( msgTypeId , buffer , index , length ) - > { final PublicationMessageFlyweight publicationMessage = new PublicationMessageFlyweight ( ) ; publicationMessage . wrap ( buffer , index ) ; assertThat ( msgTypeId , is ( expectedMsgTypeId ) ) ; assertThat ( publicationMessage . channel ( ) , is ( CHANNEL ) ) ; assertThat ( publicationMessage . sessionId ( ) , is ( SESSION_ID ) ) ; assertThat ( publicationMessage . streamId ( ) , is ( STREAM_ID ) ) ; } ) ; } @ Test public void threadSendsRemoveSubscriberMessage ( ) { conductor . removeSubscription ( CORRELATION_ID ) ; assertReadsOneMessage ( ( msgTypeId , buffer , index , length ) - > { final RemoveMessageFlyweight removeMessage = new RemoveMessageFlyweight ( ) ; removeMessage . wrap ( buffer , index ) ; assertThat ( msgTypeId , is ( REMOVE_SUBSCRIPTION ) ) ; assertThat ( removeMessage . registrationId ( ) , is ( CORRELATION_ID ) ) ; } ) ; } private void assertReadsOneMessage ( final MessageHandler handler ) { final int messageCount = conductorBuffer . read ( handler ) ; assertThat ( messageCount , is ( 1 ) ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import org . junit . Before ; import org . junit . Test ; import org . mockito . InOrder ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; import static java . lang . Integer . valueOf ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; import static org . mockito . Mockito . * ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . * ; public class TermRebuilderTest { private static final int TERM_BUFFER_CAPACITY = LogBufferDescriptor . TERM_MIN_LENGTH ; private final UnsafeBuffer termBuffer = mock ( UnsafeBuffer . class ) ; @ Before public void setUp ( ) { when ( valueOf ( termBuffer . capacity ( ) ) ) . thenReturn ( valueOf ( TERM_BUFFER_CAPACITY ) ) ; } @ Test public void shouldInsertIntoEmptyBuffer ( ) { final UnsafeBuffer packet = new UnsafeBuffer ( ByteBuffer . allocateDirect ( 256 ) ) ; final int termOffset = 0 ; final int srcOffset = 0 ; final int length = 256 ; packet . putInt ( srcOffset , length , LITTLE_ENDIAN ) ; when ( termBuffer . getInt ( 0 , LITTLE_ENDIAN ) ) . thenReturn ( length ) ; TermRebuilder . insert ( termBuffer , termOffset , packet , length ) ; final InOrder inOrder = inOrder ( termBuffer ) ; inOrder . verify ( termBuffer ) . putBytes ( termOffset , packet , srcOffset , length ) ; inOrder . verify ( termBuffer ) . putIntOrdered ( termOffset , length ) ; } @ Test public void shouldInsertLastFrameIntoBuffer ( ) { final int frameLength = BitUtil . align ( 256 , FRAME_ALIGNMENT ) ; final int srcOffset = 0 ; final int tail = TERM_BUFFER_CAPACITY - frameLength ; final int termOffset = tail ; final UnsafeBuffer packet = new UnsafeBuffer ( ByteBuffer . allocateDirect ( frameLength ) ) ; packet . putShort ( typeOffset ( srcOffset ) , ( short ) PADDING_FRAME_TYPE , LITTLE_ENDIAN ) ; packet . putInt ( srcOffset , frameLength , LITTLE_ENDIAN ) ; when ( termBuffer . getInt ( tail , LITTLE_ENDIAN ) ) . thenReturn ( frameLength ) ; when ( termBuffer . getShort ( typeOffset ( tail ) , LITTLE_ENDIAN ) ) . thenReturn ( ( short ) PADDING_FRAME_TYPE ) ; TermRebuilder . insert ( termBuffer , termOffset , packet , frameLength ) ; verify ( termBuffer ) . putBytes ( tail , packet , srcOffset , frameLength ) ; } @ Test public void shouldFillSingleGap ( ) { final int frameLength = 50 ; final int alignedFrameLength = BitUtil . align ( frameLength , FRAME_ALIGNMENT ) ; final int srcOffset = 0 ; final int tail = alignedFrameLength ; final int termOffset = tail ; final UnsafeBuffer packet = new UnsafeBuffer ( ByteBuffer . allocateDirect ( alignedFrameLength ) ) ; when ( termBuffer . getInt ( 0 ) ) . thenReturn ( frameLength ) ; when ( termBuffer . getInt ( alignedFrameLength , LITTLE_ENDIAN ) ) . thenReturn ( frameLength ) ; when ( termBuffer . getInt ( alignedFrameLength * 2 , LITTLE_ENDIAN ) ) . thenReturn ( frameLength ) ; TermRebuilder . insert ( termBuffer , termOffset , packet , alignedFrameLength ) ; verify ( termBuffer ) . putBytes ( tail , packet , srcOffset , alignedFrameLength ) ; } @ Test public void shouldFillAfterAGap ( ) { final int frameLength = 50 ; final int alignedFrameLength = BitUtil . align ( frameLength , FRAME_ALIGNMENT ) ; final int srcOffset = 0 ; final UnsafeBuffer packet = new UnsafeBuffer ( ByteBuffer . allocateDirect ( alignedFrameLength ) ) ; final int termOffset = alignedFrameLength * 2 ; when ( termBuffer . getInt ( 0 , LITTLE_ENDIAN ) ) . thenReturn ( 0 ) ; when ( termBuffer . getInt ( alignedFrameLength , LITTLE_ENDIAN ) ) . thenReturn ( frameLength ) ; TermRebuilder . insert ( termBuffer , termOffset , packet , alignedFrameLength ) ; verify ( termBuffer ) . putBytes ( alignedFrameLength * 2 , packet , srcOffset , alignedFrameLength ) ; } @ Test public void shouldFillGapButNotMoveTailOrHwm ( ) { final int frameLength = 50 ; final int alignedFrameLength = BitUtil . align ( frameLength , FRAME_ALIGNMENT ) ; final int srcOffset = 0 ; final UnsafeBuffer packet = new UnsafeBuffer ( ByteBuffer . allocateDirect ( alignedFrameLength ) ) ; final int termOffset = alignedFrameLength * 2 ; when ( termBuffer . getInt ( 0 , LITTLE_ENDIAN ) ) . thenReturn ( frameLength ) ; when ( termBuffer . getInt ( alignedFrameLength , LITTLE_ENDIAN ) ) . thenReturn ( 0 ) ; TermRebuilder . insert ( termBuffer , termOffset , packet , alignedFrameLength ) ; verify ( termBuffer ) . putBytes ( alignedFrameLength * 2 , packet , srcOffset , alignedFrameLength ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import org . junit . Before ; import org . junit . Test ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import static org . hamcrest . Matchers . is ; import static org . junit . Assert . assertThat ; import static org . mockito . Mockito . * ; public class TermGapScannerTest { private static final int LOG_BUFFER_CAPACITY = LogBufferDescriptor . TERM_MIN_LENGTH ; private static final int TERM_ID = 1 ; private static final int HEADER_LENGTH = DataHeaderFlyweight . HEADER_LENGTH ; private final UnsafeBuffer termBuffer = mock ( UnsafeBuffer . class ) ; private final TermGapScanner . GapHandler gapHandler = mock ( TermGapScanner . GapHandler . class ) ; @ Before public void setUp ( ) { when ( termBuffer . capacity ( ) ) . thenReturn ( LOG_BUFFER_CAPACITY ) ; } @ Test public void shouldReportGapAtBeginningOfBuffer ( ) { final int frameOffset = HEADER_LENGTH * 3 ; final int highWaterMark = frameOffset + HEADER_LENGTH ; when ( termBuffer . getIntVolatile ( frameOffset ) ) . thenReturn ( HEADER_LENGTH ) ; assertThat ( TermGapScanner . scanForGap ( termBuffer , TERM_ID , 0 , highWaterMark , gapHandler ) , is ( 0 ) ) ; verify ( gapHandler ) . onGap ( TERM_ID , termBuffer , 0 , frameOffset ) ; } @ Test public void shouldReportSingleGapWhenBufferNotFull ( ) { final int tail = HEADER_LENGTH ; final int highWaterMark = HEADER_LENGTH * 3 ; when ( termBuffer . getIntVolatile ( tail - HEADER_LENGTH ) ) . thenReturn ( HEADER_LENGTH ) ; when ( termBuffer . getIntVolatile ( tail ) ) . thenReturn ( 0 ) ; when ( termBuffer . getIntVolatile ( highWaterMark - HEADER_LENGTH ) ) . thenReturn ( HEADER_LENGTH ) ; assertThat ( TermGapScanner . scanForGap ( termBuffer , TERM_ID , tail , highWaterMark , gapHandler ) , is ( tail ) ) ; verify ( gapHandler ) . onGap ( TERM_ID , termBuffer , tail , HEADER_LENGTH ) ; } @ Test public void shouldReportSingleGapWhenBufferIsFull ( ) { final int tail = LOG_BUFFER_CAPACITY - ( HEADER_LENGTH * 2 ) ; final int highWaterMark = LOG_BUFFER_CAPACITY ; when ( termBuffer . getIntVolatile ( tail - HEADER_LENGTH ) ) . thenReturn ( HEADER_LENGTH ) ; when ( termBuffer . getIntVolatile ( tail ) ) . thenReturn ( 0 ) ; when ( termBuffer . getIntVolatile ( highWaterMark - HEADER_LENGTH ) ) . thenReturn ( HEADER_LENGTH ) ; assertThat ( TermGapScanner . scanForGap ( termBuffer , TERM_ID , tail , highWaterMark , gapHandler ) , is ( tail ) ) ; verify ( gapHandler ) . onGap ( TERM_ID , termBuffer , tail , HEADER_LENGTH ) ; } @ Test public void shouldReportNoGapWhenHwmIsInPadding ( ) { final int paddingLength = HEADER_LENGTH * 2 ; final int tail = LOG_BUFFER_CAPACITY - paddingLength ; final int highWaterMark = LOG_BUFFER_CAPACITY - paddingLength + HEADER_LENGTH ; when ( termBuffer . getIntVolatile ( tail ) ) . thenReturn ( paddingLength ) ; when ( termBuffer . getIntVolatile ( tail + HEADER_LENGTH ) ) . thenReturn ( 0 ) ; assertThat ( TermGapScanner . scanForGap ( termBuffer , TERM_ID , tail , highWaterMark , gapHandler ) , is ( LOG_BUFFER_CAPACITY ) ) ; verifyZeroInteractions ( gapHandler ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import org . junit . Before ; import org . junit . Test ; import org . mockito . InOrder ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import static java . lang . Integer . valueOf ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertThat ; import static org . mockito . Mockito . * ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . * ; import static uk . co . real_logic . aeron . protocol . HeaderFlyweight . HDR_TYPE_DATA ; import static uk . co . real_logic . agrona . BitUtil . align ; public class TermScannerTest { private static final int TERM_BUFFER_CAPACITY = LogBufferDescriptor . TERM_MIN_LENGTH ; private static final int MTU_LENGTH = 1024 ; private static final int HEADER_LENGTH = DataHeaderFlyweight . HEADER_LENGTH ; private final UnsafeBuffer termBuffer = mock ( UnsafeBuffer . class ) ; @ Before public void setUp ( ) { when ( termBuffer . capacity ( ) ) . thenReturn ( TERM_BUFFER_CAPACITY ) ; } @ Test public void shouldPackPaddingAndOffsetIntoResultingStatus ( ) { final int padding = 77 ; final int available = 65000 ; final long scanOutcome = TermScanner . scanOutcome ( padding , available ) ; assertThat ( TermScanner . padding ( scanOutcome ) , is ( padding ) ) ; assertThat ( TermScanner . available ( scanOutcome ) , is ( available ) ) ; } @ Test public void shouldReturnZeroOnEmptyLog ( ) { final long scanOutcome = TermScanner . scanForAvailability ( termBuffer , 0 , MTU_LENGTH ) ; assertThat ( TermScanner . available ( scanOutcome ) , is ( 0 ) ) ; assertThat ( TermScanner . padding ( scanOutcome ) , is ( 0 ) ) ; } @ Test public void shouldScanSingleMessage ( ) { final int msgLength = 1 ; final int frameLength = HEADER_LENGTH + msgLength ; final int alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; final int frameOffset = 0 ; when ( termBuffer . getIntVolatile ( frameOffset ) ) . thenReturn ( frameLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; final long scanOutcome = TermScanner . scanForAvailability ( termBuffer , frameOffset , MTU_LENGTH ) ; assertThat ( TermScanner . available ( scanOutcome ) , is ( alignedFrameLength ) ) ; assertThat ( TermScanner . padding ( scanOutcome ) , is ( 0 ) ) ; final InOrder inOrder = inOrder ( termBuffer ) ; inOrder . verify ( termBuffer ) . getIntVolatile ( frameOffset ) ; inOrder . verify ( termBuffer ) . getShort ( typeOffset ( frameOffset ) ) ; } @ Test public void shouldFailToScanMessageLargerThanMaxLength ( ) { final int msgLength = 1 ; final int frameLength = HEADER_LENGTH + msgLength ; final int alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; final int maxLength = alignedFrameLength - 1 ; final int frameOffset = 0 ; when ( termBuffer . getIntVolatile ( frameOffset ) ) . thenReturn ( frameLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; final long scanOutcome = TermScanner . scanForAvailability ( termBuffer , frameOffset , maxLength ) ; assertThat ( TermScanner . available ( scanOutcome ) , is ( 0 ) ) ; assertThat ( TermScanner . padding ( scanOutcome ) , is ( 0 ) ) ; final InOrder inOrder = inOrder ( termBuffer ) ; inOrder . verify ( termBuffer ) . getIntVolatile ( frameOffset ) ; inOrder . verify ( termBuffer ) . getShort ( typeOffset ( frameOffset ) ) ; } @ Test public void shouldScanTwoMessagesThatFitInSingleMtu ( ) { final int msgLength = 100 ; final int frameLength = HEADER_LENGTH + msgLength ; final int alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; int frameOffset = 0 ; when ( termBuffer . getIntVolatile ( frameOffset ) ) . thenReturn ( frameLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; when ( termBuffer . getIntVolatile ( frameOffset + alignedFrameLength ) ) . thenReturn ( alignedFrameLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset + alignedFrameLength ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; final long scanOutcome = TermScanner . scanForAvailability ( termBuffer , frameOffset , MTU_LENGTH ) ; assertThat ( TermScanner . available ( scanOutcome ) , is ( alignedFrameLength * 2 ) ) ; assertThat ( TermScanner . padding ( scanOutcome ) , is ( 0 ) ) ; final InOrder inOrder = inOrder ( termBuffer ) ; inOrder . verify ( termBuffer ) . getIntVolatile ( frameOffset ) ; inOrder . verify ( termBuffer ) . getShort ( typeOffset ( frameOffset ) ) ; frameOffset += alignedFrameLength ; inOrder . verify ( termBuffer ) . getIntVolatile ( frameOffset ) ; inOrder . verify ( termBuffer ) . getShort ( typeOffset ( frameOffset ) ) ; } @ Test public void shouldScanTwoMessagesAndStopAtMtuBoundary ( ) { final int frameTwoLength = align ( HEADER_LENGTH + 1 , FRAME_ALIGNMENT ) ; final int frameOneLength = MTU_LENGTH - frameTwoLength ; int frameOffset = 0 ; when ( termBuffer . getIntVolatile ( frameOffset ) ) . thenReturn ( frameOneLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; when ( termBuffer . getIntVolatile ( frameOffset + frameOneLength ) ) . thenReturn ( frameTwoLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset + frameOneLength ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; final long scanOutcome = TermScanner . scanForAvailability ( termBuffer , frameOffset , MTU_LENGTH ) ; assertThat ( TermScanner . available ( scanOutcome ) , is ( frameOneLength + frameTwoLength ) ) ; assertThat ( TermScanner . padding ( scanOutcome ) , is ( 0 ) ) ; final InOrder inOrder = inOrder ( termBuffer ) ; inOrder . verify ( termBuffer ) . getIntVolatile ( frameOffset ) ; inOrder . verify ( termBuffer ) . getShort ( typeOffset ( frameOffset ) ) ; frameOffset += frameOneLength ; inOrder . verify ( termBuffer ) . getIntVolatile ( frameOffset ) ; inOrder . verify ( termBuffer ) . getShort ( typeOffset ( frameOffset ) ) ; } @ Test public void shouldScanTwoMessagesAndStopAtSecondThatSpansMtu ( ) { final int frameTwoLength = align ( HEADER_LENGTH * 2 , FRAME_ALIGNMENT ) ; final int frameOneLength = MTU_LENGTH - ( frameTwoLength / 2 ) ; int frameOffset = 0 ; when ( termBuffer . getIntVolatile ( frameOffset ) ) . thenReturn ( frameOneLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; when ( termBuffer . getIntVolatile ( frameOffset + frameOneLength ) ) . thenReturn ( frameTwoLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset + frameOneLength ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; final long scanOutcome = TermScanner . scanForAvailability ( termBuffer , frameOffset , MTU_LENGTH ) ; assertThat ( TermScanner . available ( scanOutcome ) , is ( frameOneLength ) ) ; assertThat ( TermScanner . padding ( scanOutcome ) , is ( 0 ) ) ; final InOrder inOrder = inOrder ( termBuffer ) ; inOrder . verify ( termBuffer ) . getIntVolatile ( frameOffset ) ; inOrder . verify ( termBuffer ) . getShort ( typeOffset ( frameOffset ) ) ; frameOffset += frameOneLength ; inOrder . verify ( termBuffer ) . getIntVolatile ( frameOffset ) ; inOrder . verify ( termBuffer ) . getShort ( typeOffset ( frameOffset ) ) ; } @ Test public void shouldScanLastFrameInBuffer ( ) { final int alignedFrameLength = align ( HEADER_LENGTH * 2 , FRAME_ALIGNMENT ) ; final int frameOffset = TERM_BUFFER_CAPACITY - alignedFrameLength ; when ( termBuffer . getIntVolatile ( frameOffset ) ) . thenReturn ( alignedFrameLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; final long scanOutcome = TermScanner . scanForAvailability ( termBuffer , frameOffset , MTU_LENGTH ) ; assertThat ( TermScanner . available ( scanOutcome ) , is ( alignedFrameLength ) ) ; assertThat ( TermScanner . padding ( scanOutcome ) , is ( 0 ) ) ; } @ Test public void shouldScanLastMessageInBufferPlusPadding ( ) { final int alignedFrameLength = align ( HEADER_LENGTH * 2 , FRAME_ALIGNMENT ) ; final int paddingFrameLength = align ( HEADER_LENGTH * 3 , FRAME_ALIGNMENT ) ; final int frameOffset = TERM_BUFFER_CAPACITY - ( alignedFrameLength + paddingFrameLength ) ; when ( valueOf ( termBuffer . getIntVolatile ( frameOffset ) ) ) . thenReturn ( alignedFrameLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; when ( termBuffer . getIntVolatile ( frameOffset + alignedFrameLength ) ) . thenReturn ( paddingFrameLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset + alignedFrameLength ) ) ) . thenReturn ( ( short ) PADDING_FRAME_TYPE ) ; final long scanOutcome = TermScanner . scanForAvailability ( termBuffer , frameOffset , MTU_LENGTH ) ; assertThat ( TermScanner . available ( scanOutcome ) , is ( alignedFrameLength + HEADER_LENGTH ) ) ; assertThat ( TermScanner . padding ( scanOutcome ) , is ( paddingFrameLength - HEADER_LENGTH ) ) ; } @ Test public void shouldScanLastMessageInBufferMinusPaddingLimitedByMtu ( ) { final int alignedFrameLength = align ( HEADER_LENGTH , FRAME_ALIGNMENT ) ; final int frameOffset = TERM_BUFFER_CAPACITY - align ( HEADER_LENGTH * 3 , FRAME_ALIGNMENT ) ; final int mtu = alignedFrameLength + 8 ; when ( valueOf ( termBuffer . getIntVolatile ( frameOffset ) ) ) . thenReturn ( alignedFrameLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; when ( termBuffer . getIntVolatile ( frameOffset + alignedFrameLength ) ) . thenReturn ( alignedFrameLength * 2 ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset + alignedFrameLength ) ) ) . thenReturn ( ( short ) PADDING_FRAME_TYPE ) ; final long scanOutcome = TermScanner . scanForAvailability ( termBuffer , frameOffset , mtu ) ; assertThat ( TermScanner . available ( scanOutcome ) , is ( alignedFrameLength ) ) ; assertThat ( TermScanner . padding ( scanOutcome ) , is ( 0 ) ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import org . junit . Before ; import org . junit . Test ; import org . mockito . InOrder ; import org . mockito . Mockito ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . util . function . Consumer ; import static org . hamcrest . core . Is . is ; import static org . junit . Assert . assertThat ; import static org . mockito . Mockito . * ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . * ; import static uk . co . real_logic . aeron . protocol . HeaderFlyweight . HDR_TYPE_DATA ; import static uk . co . real_logic . agrona . BitUtil . align ; public class TermReaderTest { private static final int TERM_BUFFER_CAPACITY = LogBufferDescriptor . TERM_MIN_LENGTH ; private static final int HEADER_LENGTH = DataHeaderFlyweight . HEADER_LENGTH ; private static final int INITIAL_TERM_ID = 7 ; private final Header header = new Header ( INITIAL_TERM_ID , TERM_BUFFER_CAPACITY ) ; private final UnsafeBuffer termBuffer = mock ( UnsafeBuffer . class ) ; private final Consumer < Throwable > errorHandler = mock ( Consumer . class ) ; private final FragmentHandler handler = Mockito . mock ( FragmentHandler . class ) ; @ Before public void setUp ( ) { when ( termBuffer . capacity ( ) ) . thenReturn ( TERM_BUFFER_CAPACITY ) ; } @ Test public void shouldPackPaddingAndOffsetIntoResultingStatus ( ) { final int offset = 77 ; final int fragmentsRead = 999 ; final long scanOutcome = TermReader . readOutcome ( offset , fragmentsRead ) ; assertThat ( TermReader . offset ( scanOutcome ) , is ( offset ) ) ; assertThat ( TermReader . fragmentsRead ( scanOutcome ) , is ( fragmentsRead ) ) ; } @ Test public void shouldReadFirstMessage ( ) { final int msgLength = 1 ; final int frameLength = HEADER_LENGTH + msgLength ; final int termOffset = 0 ; when ( termBuffer . getIntVolatile ( 0 ) ) . thenReturn ( frameLength ) ; when ( termBuffer . getShort ( typeOffset ( 0 ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; final long readOutcome = TermReader . read ( termBuffer , termOffset , handler , Integer . MAX_VALUE , header , errorHandler ) ; assertThat ( TermReader . fragmentsRead ( readOutcome ) , is ( 1 ) ) ; final InOrder inOrder = inOrder ( termBuffer ) ; inOrder . verify ( termBuffer ) . getIntVolatile ( 0 ) ; verify ( handler ) . onFragment ( eq ( termBuffer ) , eq ( HEADER_LENGTH ) , eq ( msgLength ) , any ( Header . class ) ) ; } @ Test public void shouldNotReadPastTail ( ) { final int termOffset = 0 ; final long readOutcome = TermReader . read ( termBuffer , termOffset , handler , Integer . MAX_VALUE , header , errorHandler ) ; assertThat ( TermReader . fragmentsRead ( readOutcome ) , is ( 0 ) ) ; assertThat ( TermReader . offset ( readOutcome ) , is ( termOffset ) ) ; verify ( termBuffer ) . getIntVolatile ( 0 ) ; verify ( handler , never ( ) ) . onFragment ( any ( ) , anyInt ( ) , anyInt ( ) , any ( ) ) ; } @ Test public void shouldReadOneLimitedMessage ( ) { final int msgLength = 1 ; final int frameLength = HEADER_LENGTH + msgLength ; final int termOffset = 0 ; when ( termBuffer . getIntVolatile ( anyInt ( ) ) ) . thenReturn ( frameLength ) ; when ( termBuffer . getShort ( anyInt ( ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; final long readOutcome = TermReader . read ( termBuffer , termOffset , handler , 1 , header , errorHandler ) ; assertThat ( TermReader . fragmentsRead ( readOutcome ) , is ( 1 ) ) ; final InOrder inOrder = inOrder ( termBuffer , handler ) ; inOrder . verify ( termBuffer ) . getIntVolatile ( 0 ) ; inOrder . verify ( handler ) . onFragment ( eq ( termBuffer ) , eq ( HEADER_LENGTH ) , eq ( msgLength ) , any ( Header . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; } @ Test public void shouldReadMultipleMessages ( ) { final int msgLength = 1 ; final int frameLength = HEADER_LENGTH + msgLength ; final int alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; final int termOffset = 0 ; when ( termBuffer . getIntVolatile ( 0 ) ) . thenReturn ( frameLength ) ; when ( termBuffer . getIntVolatile ( alignedFrameLength ) ) . thenReturn ( frameLength ) ; when ( termBuffer . getShort ( anyInt ( ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; final long readOutcome = TermReader . read ( termBuffer , termOffset , handler , Integer . MAX_VALUE , header , errorHandler ) ; assertThat ( TermReader . fragmentsRead ( readOutcome ) , is ( 2 ) ) ; assertThat ( TermReader . offset ( readOutcome ) , is ( alignedFrameLength * 2 ) ) ; final InOrder inOrder = inOrder ( termBuffer , handler ) ; inOrder . verify ( termBuffer ) . getIntVolatile ( 0 ) ; inOrder . verify ( handler ) . onFragment ( eq ( termBuffer ) , eq ( HEADER_LENGTH ) , eq ( msgLength ) , any ( Header . class ) ) ; inOrder . verify ( termBuffer ) . getIntVolatile ( alignedFrameLength ) ; inOrder . verify ( handler ) . onFragment ( eq ( termBuffer ) , eq ( alignedFrameLength + HEADER_LENGTH ) , eq ( msgLength ) , any ( Header . class ) ) ; } @ Test public void shouldReadLastMessage ( ) { final int msgLength = 1 ; final int frameLength = HEADER_LENGTH + msgLength ; final int alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; final int frameOffset = TERM_BUFFER_CAPACITY - alignedFrameLength ; when ( termBuffer . getIntVolatile ( frameOffset ) ) . thenReturn ( frameLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset ) ) ) . thenReturn ( ( short ) HDR_TYPE_DATA ) ; final long readOutcome = TermReader . read ( termBuffer , frameOffset , handler , Integer . MAX_VALUE , header , errorHandler ) ; assertThat ( TermReader . fragmentsRead ( readOutcome ) , is ( 1 ) ) ; assertThat ( TermReader . offset ( readOutcome ) , is ( TERM_BUFFER_CAPACITY ) ) ; final InOrder inOrder = inOrder ( termBuffer , handler ) ; inOrder . verify ( termBuffer ) . getIntVolatile ( frameOffset ) ; inOrder . verify ( handler ) . onFragment ( eq ( termBuffer ) , eq ( frameOffset + HEADER_LENGTH ) , eq ( msgLength ) , any ( Header . class ) ) ; } @ Test public void shouldNotReadLastMessageWhenPadding ( ) { final int msgLength = 1 ; final int frameLength = HEADER_LENGTH + msgLength ; final int alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; final int frameOffset = TERM_BUFFER_CAPACITY - alignedFrameLength ; when ( termBuffer . getIntVolatile ( frameOffset ) ) . thenReturn ( frameLength ) ; when ( termBuffer . getShort ( typeOffset ( frameOffset ) ) ) . thenReturn ( ( short ) PADDING_FRAME_TYPE ) ; final long readOutcome = TermReader . read ( termBuffer , frameOffset , handler , Integer . MAX_VALUE , header , errorHandler ) ; assertThat ( TermReader . fragmentsRead ( readOutcome ) , is ( 0 ) ) ; assertThat ( TermReader . offset ( readOutcome ) , is ( TERM_BUFFER_CAPACITY ) ) ; final InOrder inOrder = inOrder ( termBuffer ) ; inOrder . verify ( termBuffer ) . getIntVolatile ( frameOffset ) ; verify ( handler , never ( ) ) . onFragment ( any ( ) , anyInt ( ) , anyInt ( ) , any ( ) ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import org . junit . Before ; import org . junit . Test ; import org . mockito . InOrder ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; import static org . hamcrest . Matchers . is ; import static org . junit . Assert . assertThat ; import static org . mockito . Mockito . * ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . * ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . TERM_META_DATA_LENGTH ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . TERM_TAIL_COUNTER_OFFSET ; import static uk . co . real_logic . aeron . protocol . DataHeaderFlyweight . HEADER_LENGTH ; import static uk . co . real_logic . agrona . BitUtil . * ; public class TermAppenderTest { private static final int TERM_BUFFER_LENGTH = LogBufferDescriptor . TERM_MIN_LENGTH ; private static final int META_DATA_BUFFER_LENGTH = TERM_META_DATA_LENGTH ; private static final int MAX_FRAME_LENGTH = 1024 ; private static final MutableDirectBuffer DEFAULT_HEADER = new UnsafeBuffer ( ByteBuffer . allocateDirect ( HEADER_LENGTH ) ) ; private final UnsafeBuffer termBuffer = spy ( new UnsafeBuffer ( ByteBuffer . allocateDirect ( TERM_BUFFER_LENGTH ) ) ) ; private final UnsafeBuffer metaDataBuffer = mock ( UnsafeBuffer . class ) ; private TermAppender termAppender ; @ Before public void setUp ( ) { when ( termBuffer . capacity ( ) ) . thenReturn ( TERM_BUFFER_LENGTH ) ; when ( metaDataBuffer . capacity ( ) ) . thenReturn ( META_DATA_BUFFER_LENGTH ) ; termAppender = new TermAppender ( termBuffer , metaDataBuffer , DEFAULT_HEADER , MAX_FRAME_LENGTH ) ; } @ Test public void shouldReportCapacity ( ) { assertThat ( termAppender . termBuffer ( ) . capacity ( ) , is ( TERM_BUFFER_LENGTH ) ) ; } @ Test public void shouldReportMaxFrameLength ( ) { assertThat ( termAppender . maxFrameLength ( ) , is ( MAX_FRAME_LENGTH ) ) ; } @ Test ( expected = IllegalStateException . class ) public void shouldThrowExceptionOnInsufficientCapacityForLog ( ) { when ( termBuffer . capacity ( ) ) . thenReturn ( LogBufferDescriptor . TERM_MIN_LENGTH - 1 ) ; termAppender = new TermAppender ( termBuffer , metaDataBuffer , DEFAULT_HEADER , MAX_FRAME_LENGTH ) ; } @ Test ( expected = IllegalStateException . class ) public void shouldThrowExceptionWhenCapacityNotMultipleOfAlignment ( ) { final int logBufferCapacity = LogBufferDescriptor . TERM_MIN_LENGTH + FRAME_ALIGNMENT + 1 ; when ( termBuffer . capacity ( ) ) . thenReturn ( logBufferCapacity ) ; termAppender = new TermAppender ( termBuffer , metaDataBuffer , DEFAULT_HEADER , MAX_FRAME_LENGTH ) ; } @ Test ( expected = IllegalStateException . class ) public void shouldThrowExceptionOnInsufficientMetaDataBufferCapacity ( ) { when ( metaDataBuffer . capacity ( ) ) . thenReturn ( LogBufferDescriptor . TERM_META_DATA_LENGTH - 1 ) ; termAppender = new TermAppender ( termBuffer , metaDataBuffer , DEFAULT_HEADER , MAX_FRAME_LENGTH ) ; } @ Test ( expected = IllegalStateException . class ) public void shouldThrowExceptionOnDefaultHeaderLengthLessThanBaseHeaderLength ( ) { final int length = HEADER_LENGTH - 1 ; termAppender = new TermAppender ( termBuffer , metaDataBuffer , new UnsafeBuffer ( new byte [ length ] ) , MAX_FRAME_LENGTH ) ; } @ Test ( expected = IllegalStateException . class ) public void shouldThrowExceptionOnDefaultHeaderLengthNotOnWordSizeBoundary ( ) { termAppender = new TermAppender ( termBuffer , metaDataBuffer , new UnsafeBuffer ( new byte [ 31 ] ) , MAX_FRAME_LENGTH ) ; } @ Test ( expected = IllegalStateException . class ) public void shouldThrowExceptionOnMaxFrameSizeNotOnWordSizeBoundary ( ) { final int maxFrameLength = 1001 ; termAppender = new TermAppender ( termBuffer , metaDataBuffer , DEFAULT_HEADER , maxFrameLength ) ; } @ Test public void shouldReportCurrentTail ( ) { final int tailValue = 64 ; when ( metaDataBuffer . getIntVolatile ( TERM_TAIL_COUNTER_OFFSET ) ) . thenReturn ( tailValue ) ; assertThat ( termAppender . tailVolatile ( ) , is ( tailValue ) ) ; } @ Test public void shouldReportCurrentTailAtCapacity ( ) { final int tailValue = TERM_BUFFER_LENGTH + 64 ; when ( metaDataBuffer . getIntVolatile ( TERM_TAIL_COUNTER_OFFSET ) ) . thenReturn ( tailValue ) ; when ( metaDataBuffer . getInt ( TERM_TAIL_COUNTER_OFFSET ) ) . thenReturn ( tailValue ) ; assertThat ( termAppender . tailVolatile ( ) , is ( TERM_BUFFER_LENGTH ) ) ; assertThat ( termAppender . tail ( ) , is ( TERM_BUFFER_LENGTH ) ) ; } @ Test ( expected = IllegalArgumentException . class ) public void shouldThrowExceptionWhenMaxMessageLengthExceeded ( ) { final int maxMessageLength = termAppender . maxMessageLength ( ) ; final UnsafeBuffer srcBuffer = new UnsafeBuffer ( new byte [ 1024 ] ) ; termAppender . append ( srcBuffer , 0 , maxMessageLength + 1 ) ; } @ Test public void shouldAppendFrameToEmptyLog ( ) { final int headerLength = DEFAULT_HEADER . capacity ( ) ; final UnsafeBuffer buffer = new UnsafeBuffer ( new byte [ 128 ] ) ; final int msgLength = 20 ; final int frameLength = msgLength + headerLength ; final int alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; final int tail = 0 ; when ( metaDataBuffer . getAndAddInt ( TERM_TAIL_COUNTER_OFFSET , alignedFrameLength ) ) . thenReturn ( 0 ) ; assertThat ( termAppender . append ( buffer , 0 , msgLength ) , is ( alignedFrameLength ) ) ; final InOrder inOrder = inOrder ( termBuffer , metaDataBuffer ) ; inOrder . verify ( metaDataBuffer , times ( 1 ) ) . getAndAddInt ( TERM_TAIL_COUNTER_OFFSET , alignedFrameLength ) ; verifyDefaultHeader ( inOrder , termBuffer , tail , frameLength ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putBytes ( headerLength , buffer , 0 , msgLength ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putInt ( termOffsetOffset ( tail ) , tail , LITTLE_ENDIAN ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putIntOrdered ( tail , frameLength ) ; } @ Test public void shouldAppendFrameTwiceToLog ( ) { final int headerLength = DEFAULT_HEADER . capacity ( ) ; final UnsafeBuffer buffer = new UnsafeBuffer ( new byte [ 128 ] ) ; final int msgLength = 20 ; final int frameLength = msgLength + headerLength ; final int alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; int tail = 0 ; when ( metaDataBuffer . getAndAddInt ( TERM_TAIL_COUNTER_OFFSET , alignedFrameLength ) ) . thenReturn ( 0 ) . thenReturn ( alignedFrameLength ) ; assertThat ( termAppender . append ( buffer , 0 , msgLength ) , is ( alignedFrameLength ) ) ; assertThat ( termAppender . append ( buffer , 0 , msgLength ) , is ( alignedFrameLength * 2 ) ) ; final InOrder inOrder = inOrder ( termBuffer , metaDataBuffer ) ; inOrder . verify ( metaDataBuffer , times ( 1 ) ) . getAndAddInt ( TERM_TAIL_COUNTER_OFFSET , alignedFrameLength ) ; verifyDefaultHeader ( inOrder , termBuffer , tail , frameLength ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putBytes ( headerLength , buffer , 0 , msgLength ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putInt ( termOffsetOffset ( tail ) , tail , LITTLE_ENDIAN ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putIntOrdered ( tail , frameLength ) ; tail = alignedFrameLength ; inOrder . verify ( metaDataBuffer , times ( 1 ) ) . getAndAddInt ( TERM_TAIL_COUNTER_OFFSET , alignedFrameLength ) ; verifyDefaultHeader ( inOrder , termBuffer , tail , frameLength ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putBytes ( tail + headerLength , buffer , 0 , msgLength ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putInt ( termOffsetOffset ( tail ) , tail , LITTLE_ENDIAN ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putIntOrdered ( tail , frameLength ) ; } @ Test public void shouldPadLogAndTripWhenAppendingWithInsufficientRemainingCapacity ( ) { final int msgLength = 120 ; final int headerLength = DEFAULT_HEADER . capacity ( ) ; final int requiredFrameSize = align ( headerLength + msgLength , FRAME_ALIGNMENT ) ; final int tailValue = termAppender . termBuffer ( ) . capacity ( ) - align ( msgLength , FRAME_ALIGNMENT ) ; final UnsafeBuffer buffer = new UnsafeBuffer ( new byte [ 128 ] ) ; final int frameLength = TERM_BUFFER_LENGTH - tailValue ; when ( metaDataBuffer . getAndAddInt ( TERM_TAIL_COUNTER_OFFSET , requiredFrameSize ) ) . thenReturn ( tailValue ) ; assertThat ( termAppender . append ( buffer , 0 , msgLength ) , is ( TermAppender . TRIPPED ) ) ; final InOrder inOrder = inOrder ( termBuffer , metaDataBuffer ) ; inOrder . verify ( metaDataBuffer , times ( 1 ) ) . getAndAddInt ( TERM_TAIL_COUNTER_OFFSET , requiredFrameSize ) ; verifyDefaultHeader ( inOrder , termBuffer , tailValue , frameLength ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putShort ( typeOffset ( tailValue ) , ( short ) PADDING_FRAME_TYPE , LITTLE_ENDIAN ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putInt ( termOffsetOffset ( tailValue ) , tailValue , LITTLE_ENDIAN ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putIntOrdered ( tailValue , frameLength ) ; } @ Test public void shouldPadLogAndTripWhenAppendingWithInsufficientRemainingCapacityIncludingHeader ( ) { final int headerLength = DEFAULT_HEADER . capacity ( ) ; final int msgLength = 120 ; final int requiredFrameSize = align ( headerLength + msgLength , FRAME_ALIGNMENT ) ; final int tailValue = termAppender . termBuffer ( ) . capacity ( ) - ( requiredFrameSize + ( headerLength - FRAME_ALIGNMENT ) ) ; final UnsafeBuffer buffer = new UnsafeBuffer ( new byte [ 128 ] ) ; final int frameLength = TERM_BUFFER_LENGTH - tailValue ; when ( metaDataBuffer . getAndAddInt ( TERM_TAIL_COUNTER_OFFSET , requiredFrameSize ) ) . thenReturn ( tailValue ) ; assertThat ( termAppender . append ( buffer , 0 , msgLength ) , is ( TermAppender . TRIPPED ) ) ; final InOrder inOrder = inOrder ( termBuffer , metaDataBuffer ) ; inOrder . verify ( metaDataBuffer , times ( 1 ) ) . getAndAddInt ( TERM_TAIL_COUNTER_OFFSET , requiredFrameSize ) ; verifyDefaultHeader ( inOrder , termBuffer , tailValue , frameLength ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putShort ( typeOffset ( tailValue ) , ( short ) PADDING_FRAME_TYPE , LITTLE_ENDIAN ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putInt ( termOffsetOffset ( tailValue ) , tailValue , LITTLE_ENDIAN ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putIntOrdered ( tailValue , frameLength ) ; } @ Test public void shouldFragmentMessageOverTwoFrames ( ) { final int msgLength = termAppender . maxPayloadLength ( ) + 1 ; final int headerLength = DEFAULT_HEADER . capacity ( ) ; final int frameLength = headerLength + 1 ; final int requiredCapacity = align ( headerLength + 1 , FRAME_ALIGNMENT ) + termAppender . maxFrameLength ( ) ; final UnsafeBuffer buffer = new UnsafeBuffer ( new byte [ msgLength ] ) ; when ( metaDataBuffer . getAndAddInt ( TERM_TAIL_COUNTER_OFFSET , requiredCapacity ) ) . thenReturn ( 0 ) ; assertThat ( termAppender . append ( buffer , 0 , msgLength ) , is ( requiredCapacity ) ) ; int tail = 0 ; final InOrder inOrder = inOrder ( termBuffer , metaDataBuffer ) ; inOrder . verify ( metaDataBuffer , times ( 1 ) ) . getAndAddInt ( TERM_TAIL_COUNTER_OFFSET , requiredCapacity ) ; verifyDefaultHeader ( inOrder , termBuffer , tail , termAppender . maxFrameLength ( ) ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putBytes ( tail + headerLength , buffer , 0 , termAppender . maxPayloadLength ( ) ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putByte ( flagsOffset ( tail ) , BEGIN_FRAG ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putInt ( termOffsetOffset ( tail ) , tail , LITTLE_ENDIAN ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putIntOrdered ( tail , termAppender . maxFrameLength ( ) ) ; tail = termAppender . maxFrameLength ( ) ; verifyDefaultHeader ( inOrder , termBuffer , tail , frameLength ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putBytes ( tail + headerLength , buffer , termAppender . maxPayloadLength ( ) , 1 ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putByte ( flagsOffset ( tail ) , END_FRAG ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putInt ( termOffsetOffset ( tail ) , tail , LITTLE_ENDIAN ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putIntOrdered ( tail , frameLength ) ; } @ Test public void shouldClaimRegionForZeroCopyEncoding ( ) { final int headerLength = DEFAULT_HEADER . capacity ( ) ; final int msgLength = 20 ; final int frameLength = msgLength + headerLength ; final int alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; final int tail = 0 ; final BufferClaim bufferClaim = new BufferClaim ( ) ; when ( metaDataBuffer . getAndAddInt ( TERM_TAIL_COUNTER_OFFSET , alignedFrameLength ) ) . thenReturn ( 0 ) ; assertThat ( termAppender . claim ( msgLength , bufferClaim ) , is ( alignedFrameLength ) ) ; assertThat ( bufferClaim . offset ( ) , is ( tail + headerLength ) ) ; assertThat ( bufferClaim . length ( ) , is ( msgLength ) ) ; bufferClaim . commit ( ) ; final InOrder inOrder = inOrder ( termBuffer , metaDataBuffer ) ; inOrder . verify ( metaDataBuffer , times ( 1 ) ) . getAndAddInt ( TERM_TAIL_COUNTER_OFFSET , alignedFrameLength ) ; verifyDefaultHeader ( inOrder , termBuffer , tail , frameLength ) ; inOrder . verify ( termBuffer , times ( 1 ) ) . putInt ( termOffsetOffset ( tail ) , tail , LITTLE_ENDIAN ) ; } private void verifyDefaultHeader ( final InOrder inOrder , final UnsafeBuffer termBuffer , final int frameOffset , final int frameLength ) { inOrder . verify ( termBuffer , times ( 1 ) ) . putInt ( frameOffset , - frameLength , LITTLE_ENDIAN ) ; int headerOffset = SIZE_OF_INT ; inOrder . verify ( termBuffer , times ( 1 ) ) . putInt ( eq ( frameOffset + headerOffset ) , anyInt ( ) ) ; headerOffset += SIZE_OF_INT ; inOrder . verify ( termBuffer , times ( 1 ) ) . putLong ( eq ( frameOffset + headerOffset ) , anyLong ( ) ) ; headerOffset += SIZE_OF_LONG ; inOrder . verify ( termBuffer , times ( 1 ) ) . putLong ( eq ( frameOffset + headerOffset ) , anyLong ( ) ) ; } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . util . Arrays ; public class BufferBuilder { public static final int INITIAL_CAPACITY = 4096 ; private final MutableDirectBuffer mutableDirectBuffer ; private byte [ ] buffer ; private int limit = 0 ; private int capacity ; public BufferBuilder ( ) { this ( INITIAL_CAPACITY ) ; } public BufferBuilder ( final int initialCapacity ) { capacity = BitUtil . findNextPositivePowerOfTwo ( initialCapacity ) ; buffer = new byte [ capacity ] ; mutableDirectBuffer = new UnsafeBuffer ( buffer ) ; } public int capacity ( ) { return capacity ; } public int limit ( ) { return limit ; } public MutableDirectBuffer buffer ( ) { return mutableDirectBuffer ; } public BufferBuilder reset ( ) { limit = 0 ; return this ; } public BufferBuilder compact ( ) { capacity = Math . max ( INITIAL_CAPACITY , BitUtil . findNextPositivePowerOfTwo ( limit ) ) ; buffer = Arrays . copyOf ( buffer , capacity ) ; mutableDirectBuffer . wrap ( buffer ) ; return this ; } public BufferBuilder append ( final DirectBuffer srcBuffer , final int srcOffset , final int length ) { ensureCapacity ( length ) ; srcBuffer . getBytes ( srcOffset , buffer , limit , length ) ; limit += length ; return this ; } private void ensureCapacity ( final int additionalCapacity ) { final int requiredCapacity = limit + additionalCapacity ; if ( requiredCapacity < 0 ) { final String s = String . format ( "Insufficient capacity: limit=%d additional=%d" , limit , additionalCapacity ) ; throw new IllegalStateException ( s ) ; } if ( requiredCapacity > capacity ) { final int newCapacity = findSuitableCapacity ( capacity , requiredCapacity ) ; final byte [ ] newBuffer = Arrays . copyOf ( buffer , newCapacity ) ; capacity = newCapacity ; buffer = newBuffer ; mutableDirectBuffer . wrap ( newBuffer ) ; } } private static int findSuitableCapacity ( int capacity , final int requiredCapacity ) { do { capacity <<= 1 ; } while ( capacity < requiredCapacity ) ; return capacity ; } }
package uk . co . real_logic . aeron . tools ; import org . junit . Test ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteOrder ; import static org . hamcrest . CoreMatchers . not ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . hamcrest . core . Is . is ; public class MessageStreamTest { private static final int MAGIC = 0x0dd01221 ; private static final int BUFFER_SIZE = 200 ; private MessageStream messageStream ; private UnsafeBuffer buffer = new UnsafeBuffer ( new byte [ BUFFER_SIZE ] ) ; @ Test public void createSubscriberSide ( ) { messageStream = new MessageStream ( ) ; } @ Test public void createSixteenByteSize ( ) throws Exception { messageStream = new MessageStream ( 16 ) ; } @ Test ( expected = Exception . class ) public void createZeroByteSize ( ) throws Exception { messageStream = new MessageStream ( 0 ) ; } @ Test ( expected = Exception . class ) public void createNegativeByteSize ( ) throws Exception { messageStream = new MessageStream ( - 1 ) ; } @ Test ( expected = Exception . class ) public void createVerifiableSizeTooSmall ( ) throws Exception { messageStream = new MessageStream ( 15 ) ; } @ Test public void createNonVerifiable ( ) throws Exception { messageStream = new MessageStream ( 1 , 1 , false ) ; } @ Test public void createZeroSizeNonVerifiable ( ) throws Exception { messageStream = new MessageStream ( 0 , 0 , false ) ; } @ Test ( expected = Exception . class ) public void createNegativeSizeNonVerifiable ( ) throws Exception { messageStream = new MessageStream ( - 1 , - 1 , false ) ; } @ Test ( expected = Exception . class ) public void createMinGreaterThanMaxSize ( ) throws Exception { messageStream = new MessageStream ( 20 , 16 ) ; } @ Test public void createMinEqualToMaxSize ( ) throws Exception { messageStream = new MessageStream ( 20 , 20 ) ; } @ Test public void createNullInputStream ( ) throws Exception { messageStream = new MessageStream ( 16 , null ) ; } @ Test public void minVerifiableNullInputStream ( ) throws Exception { messageStream = new MessageStream ( 16 , null ) ; assertThat ( messageStream . getNext ( buffer ) , is ( 16 ) ) ; } @ Test public void minNonVerifiableNullInputStream ( ) throws Exception { messageStream = new MessageStream ( 0 , false , null ) ; buffer . putStringUtf8 ( 0 , "Test test test!" , ByteOrder . nativeOrder ( ) ) ; messageStream . getNext ( buffer ) ; final String result = buffer . getStringUtf8 ( 0 , ByteOrder . nativeOrder ( ) ) ; assertThat ( result , is ( "Test test test!" ) ) ; } @ Test public void nonVerifiableNullInputStream ( ) throws Exception { messageStream = new MessageStream ( 16 , false , null ) ; messageStream . getNext ( buffer ) ; final int magic = buffer . getInt ( 0 ) ; assertThat ( magic , not ( MAGIC ) ) ; } @ Test public void verifiableNullInputStream ( ) throws Exception { messageStream = new MessageStream ( 16 , true , null ) ; messageStream . getNext ( buffer ) ; final int magic = buffer . getInt ( 0 ) ; assertThat ( magic , is ( MAGIC ) ) ; } @ Test ( expected = Exception . class ) public void verifiableOneByteTooBig ( ) throws Exception { messageStream = new MessageStream ( BUFFER_SIZE + 1 , true , null ) ; messageStream . getNext ( buffer ) ; } @ Test ( expected = Exception . class ) public void nonVerifiableOneByteTooBig ( ) throws Exception { messageStream = new MessageStream ( BUFFER_SIZE + 1 , false , null ) ; assertThat ( messageStream . getNext ( buffer ) , is ( BUFFER_SIZE ) ) ; } @ Test public void verifiableExactSize ( ) throws Exception { messageStream = new MessageStream ( BUFFER_SIZE , true , null ) ; assertThat ( messageStream . getNext ( buffer ) , is ( BUFFER_SIZE ) ) ; } @ Test public void nonVerifiableExactSize ( ) throws Exception { messageStream = new MessageStream ( BUFFER_SIZE , false , null ) ; assertThat ( messageStream . getNext ( buffer ) , is ( BUFFER_SIZE ) ) ; } @ Test public void getZeroSize ( ) throws Exception { messageStream = new MessageStream ( BUFFER_SIZE , false , null ) ; assertThat ( messageStream . getNext ( buffer , 0 ) , is ( 0 ) ) ; } @ Test ( expected = Exception . class ) public void getNegativeSize ( ) throws Exception { messageStream = new MessageStream ( BUFFER_SIZE , false , null ) ; messageStream . getNext ( buffer , - 1 ) ; } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . aeron . command . ConnectionBuffersReadyFlyweight ; import uk . co . real_logic . aeron . exceptions . DriverTimeoutException ; import uk . co . real_logic . aeron . exceptions . RegistrationException ; import uk . co . real_logic . agrona . ManagedResource ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . concurrent . Agent ; import uk . co . real_logic . agrona . concurrent . EpochClock ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . broadcast . CopyBroadcastReceiver ; import uk . co . real_logic . agrona . concurrent . status . UnsafeBufferPosition ; import java . util . ArrayList ; import java . util . concurrent . TimeUnit ; import java . util . function . Consumer ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; class ClientConductor implements Agent , DriverListener { private static final long NO_CORRELATION_ID = - 1 ; private static final long KEEPALIVE_TIMEOUT_MS = 500 ; private static final long RESOURCE_TIMEOUT_MS = TimeUnit . SECONDS . toMillis ( 1 ) ; private static final long RESOURCE_LINGER_NS = TimeUnit . SECONDS . toNanos ( 5 ) ; private final long driverTimeoutMs ; private final long driverTimeoutNs ; private volatile boolean driverActive = true ; private final EpochClock epochClock ; private final DriverListenerAdapter driverListenerAdapter ; private final LogBuffersFactory logBuffersFactory ; private final ActivePublications activePublications = new ActivePublications ( ) ; private final ActiveSubscriptions activeSubscriptions = new ActiveSubscriptions ( ) ; private final ArrayList < ManagedResource > managedResources = new ArrayList < > ( ) ; private final UnsafeBuffer counterValuesBuffer ; private final DriverProxy driverProxy ; private final TimerWheel timerWheel ; private final TimerWheel . Timer keepaliveTimer ; private final TimerWheel . Timer managedResourceTimer ; private final Consumer < Throwable > errorHandler ; private final NewConnectionHandler newConnectionHandler ; private final InactiveConnectionHandler inactiveConnectionHandler ; private RegistrationException driverException ; public ClientConductor ( final EpochClock epochClock , final CopyBroadcastReceiver broadcastReceiver , final LogBuffersFactory logBuffersFactory , final UnsafeBuffer counterValuesBuffer , final DriverProxy driverProxy , final TimerWheel timerWheel , final Consumer < Throwable > errorHandler , final NewConnectionHandler newConnectionHandler , final InactiveConnectionHandler inactiveConnectionHandler , final long driverTimeoutMs ) { this . epochClock = epochClock ; this . errorHandler = errorHandler ; this . counterValuesBuffer = counterValuesBuffer ; this . driverProxy = driverProxy ; this . logBuffersFactory = logBuffersFactory ; this . timerWheel = timerWheel ; this . newConnectionHandler = newConnectionHandler ; this . inactiveConnectionHandler = inactiveConnectionHandler ; this . driverTimeoutMs = driverTimeoutMs ; this . driverTimeoutNs = MILLISECONDS . toNanos ( driverTimeoutMs ) ; this . driverListenerAdapter = new DriverListenerAdapter ( broadcastReceiver , this ) ; this . keepaliveTimer = timerWheel . newTimeout ( KEEPALIVE_TIMEOUT_MS , MILLISECONDS , this : : onKeepalive ) ; this . managedResourceTimer = timerWheel . newTimeout ( RESOURCE_TIMEOUT_MS , MILLISECONDS , this : : checkManagedResources ) ; } public void onClose ( ) { managedResources . forEach ( ManagedResource : : delete ) ; } public synchronized int doWork ( ) { return doWork ( NO_CORRELATION_ID , null ) ; } public String roleName ( ) { return "client-conductor" ; } public synchronized Publication addPublication ( final String channel , final int streamId , final int sessionId ) { verifyDriverIsActive ( ) ; Publication publication = activePublications . get ( channel , sessionId , streamId ) ; if ( publication == null ) { final long correlationId = driverProxy . addPublication ( channel , streamId , sessionId ) ; final long timeout = timerWheel . clock ( ) . nanoTime ( ) + driverTimeoutNs ; doWorkUntil ( correlationId , timeout , channel ) ; publication = activePublications . get ( channel , sessionId , streamId ) ; } publication . incRef ( ) ; return publication ; } public synchronized void releasePublication ( final Publication publication ) { verifyDriverIsActive ( ) ; final long correlationId = driverProxy . removePublication ( publication . registrationId ( ) ) ; activePublications . remove ( publication . channel ( ) , publication . sessionId ( ) , publication . streamId ( ) ) ; final long timeout = timerWheel . clock ( ) . nanoTime ( ) + driverTimeoutNs ; doWorkUntil ( correlationId , timeout , publication . channel ( ) ) ; } public synchronized Subscription addSubscription ( final String channel , final int streamId ) { verifyDriverIsActive ( ) ; final long correlationId = driverProxy . addSubscription ( channel , streamId ) ; final long timeout = timerWheel . clock ( ) . nanoTime ( ) + driverTimeoutNs ; final Subscription subscription = new Subscription ( this , channel , streamId , correlationId , errorHandler ) ; activeSubscriptions . add ( subscription ) ; doWorkUntil ( correlationId , timeout , channel ) ; return subscription ; } public synchronized void releaseSubscription ( final Subscription subscription ) { verifyDriverIsActive ( ) ; final long correlationId = driverProxy . removeSubscription ( subscription . registrationId ( ) ) ; final long timeout = timerWheel . clock ( ) . nanoTime ( ) + driverTimeoutNs ; doWorkUntil ( correlationId , timeout , subscription . channel ( ) ) ; activeSubscriptions . remove ( subscription ) ; } public void onNewPublication ( final String channel , final int streamId , final int sessionId , final int publicationLimitId , final String logFileName , final long correlationId ) { final Publication publication = new Publication ( this , channel , streamId , sessionId , new UnsafeBufferPosition ( counterValuesBuffer , publicationLimitId ) , logBuffersFactory . map ( logFileName ) , correlationId ) ; activePublications . put ( channel , sessionId , streamId , publication ) ; } public void onNewConnection ( final int streamId , final int sessionId , final long joiningPosition , final String logFileName , final ConnectionBuffersReadyFlyweight msg , final long correlationId ) { activeSubscriptions . forEach ( streamId , ( subscription ) - > { if ( ! subscription . isConnected ( sessionId ) ) { for ( int i = 0 , size = msg . subscriberPositionCount ( ) ; i < size ; i ++ ) { if ( subscription . registrationId ( ) == msg . positionIndicatorRegistrationId ( i ) ) { subscription . addConnection ( new Connection ( sessionId , joiningPosition , correlationId , new UnsafeBufferPosition ( counterValuesBuffer , msg . subscriberPositionId ( i ) ) , logBuffersFactory . map ( logFileName ) ) ) ; if ( null != newConnectionHandler ) { newConnectionHandler . onNewConnection ( subscription . channel ( ) , streamId , sessionId , joiningPosition , msg . sourceIdentity ( ) ) ; } break ; } } } } ) ; } public void onError ( final ErrorCode errorCode , final String message , final long correlationId ) { driverException = new RegistrationException ( errorCode , message ) ; } public void onInactiveConnection ( final int streamId , final int sessionId , final long position , final long correlationId ) { activeSubscriptions . forEach ( streamId , ( subscription ) - > { if ( subscription . removeConnection ( correlationId ) ) { if ( null != inactiveConnectionHandler ) { inactiveConnectionHandler . onInactiveConnection ( subscription . channel ( ) , streamId , sessionId , position ) ; } } } ) ; } public DriverListenerAdapter driverListenerAdapter ( ) { return driverListenerAdapter ; } public void lingerResource ( final ManagedResource managedResource ) { managedResource . timeOfLastStateChange ( timerWheel . clock ( ) . nanoTime ( ) ) ; managedResources . add ( managedResource ) ; } private int processTimers ( ) { int workCount = 0 ; if ( timerWheel . computeDelayInMs ( ) <= 0 ) { workCount = timerWheel . expireTimers ( ) ; } return workCount ; } private void onKeepalive ( ) { driverProxy . sendClientKeepalive ( ) ; checkDriverHeartbeat ( ) ; timerWheel . rescheduleTimeout ( KEEPALIVE_TIMEOUT_MS , MILLISECONDS , keepaliveTimer ) ; } private void checkManagedResources ( ) { final long now = timerWheel . clock ( ) . nanoTime ( ) ; for ( int i = managedResources . size ( ) - 1 ; i >= 0 ; i -- ) { final ManagedResource resource = managedResources . get ( i ) ; if ( now > ( resource . timeOfLastStateChange ( ) + RESOURCE_LINGER_NS ) ) { managedResources . remove ( i ) ; resource . delete ( ) ; } } timerWheel . rescheduleTimeout ( RESOURCE_TIMEOUT_MS , MILLISECONDS , managedResourceTimer ) ; } private void checkDriverHeartbeat ( ) { final long now = epochClock . time ( ) ; final long currentDriverKeepaliveTime = driverProxy . timeOfLastDriverKeepalive ( ) ; if ( driverActive && ( now > ( currentDriverKeepaliveTime + driverTimeoutMs ) ) ) { driverActive = false ; final String msg = String . format ( "Driver has been inactive for over %dms" , driverTimeoutMs ) ; errorHandler . accept ( new DriverTimeoutException ( msg ) ) ; } } private void verifyDriverIsActive ( ) { if ( ! driverActive ) { throw new DriverTimeoutException ( "Driver is inactive" ) ; } } private int doWork ( final long correlationId , final String expectedChannel ) { int workCount = 0 ; try { workCount += processTimers ( ) ; workCount += driverListenerAdapter . pollMessage ( correlationId , expectedChannel ) ; } catch ( final Exception ex ) { errorHandler . accept ( ex ) ; } return workCount ; } private void doWorkUntil ( final long correlationId , final long timeout , final String expectedChannel ) { driverException = null ; do { doWork ( correlationId , expectedChannel ) ; if ( driverListenerAdapter . lastReceivedCorrelationId ( ) == correlationId ) { if ( null != driverException ) { throw driverException ; } return ; } } while ( timerWheel . clock ( ) . nanoTime ( ) < timeout ) ; throw new DriverTimeoutException ( "No response from driver within timeout" ) ; } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . agrona . collections . BiInt2ObjectMap ; import java . util . HashMap ; import java . util . Map ; import static uk . co . real_logic . agrona . collections . CollectionUtil . getOrDefault ; public class ActivePublications { private final Map < String , BiInt2ObjectMap < Publication > > publicationsByChannelMap = new HashMap < > ( ) ; public Publication get ( final String channel , final int sessionId , final int streamId ) { final BiInt2ObjectMap < Publication > publicationBySessionAndStreamMap = publicationsByChannelMap . get ( channel ) ; if ( null == publicationBySessionAndStreamMap ) { return null ; } return publicationBySessionAndStreamMap . get ( sessionId , streamId ) ; } public Publication put ( final String channel , final int sessionId , final int streamId , final Publication value ) { final BiInt2ObjectMap < Publication > publicationBySessionAndStreamMap = getOrDefault ( publicationsByChannelMap , channel , ( ignore ) - > new BiInt2ObjectMap < > ( ) ) ; return publicationBySessionAndStreamMap . put ( sessionId , streamId , value ) ; } public Publication remove ( final String channel , final int sessionId , final int streamId ) { final BiInt2ObjectMap < Publication > publicationBySessionAndStreamMap = publicationsByChannelMap . get ( channel ) ; if ( null == publicationBySessionAndStreamMap ) { return null ; } final Publication publication = publicationBySessionAndStreamMap . remove ( sessionId , streamId ) ; if ( publicationBySessionAndStreamMap . isEmpty ( ) ) { publicationsByChannelMap . remove ( channel ) ; } return publication ; } }
package uk . co . real_logic . aeron ; @ FunctionalInterface public interface NewConnectionHandler { void onNewConnection ( String channel , int streamId , int sessionId , long joiningPosition , String sourceIdentity ) ; }
package uk . co . real_logic . aeron ; @ FunctionalInterface public interface InactiveConnectionHandler { void onInactiveConnection ( String channel , int streamId , int sessionId , long position ) ; }
package uk . co . real_logic . aeron ; import uk . co . real_logic . agrona . IoUtil ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . MappedByteBuffer ; import java . nio . channels . FileChannel ; import static java . nio . channels . FileChannel . MapMode . READ_WRITE ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . * ; public class LogBuffers implements AutoCloseable { private final MappedByteBuffer [ ] mappedByteBuffers ; private final UnsafeBuffer [ ] atomicBuffers = new UnsafeBuffer [ ( PARTITION_COUNT * 2 ) + 1 ] ; public LogBuffers ( final String logFileName ) { try ( final FileChannel logChannel = new RandomAccessFile ( logFileName , "rw" ) . getChannel ( ) ) { final long logLength = logChannel . size ( ) ; final int termLength = computeTermLength ( logLength ) ; if ( logLength < Integer . MAX_VALUE ) { final MappedByteBuffer mappedBuffer = logChannel . map ( READ_WRITE , 0 , logLength ) ; mappedByteBuffers = new MappedByteBuffer [ ] { mappedBuffer } ; final int metaDataSectionOffset = termLength * PARTITION_COUNT ; for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { final int metaDataOffset = metaDataSectionOffset + ( i * TERM_META_DATA_LENGTH ) ; atomicBuffers [ i ] = new UnsafeBuffer ( mappedBuffer , i * termLength , termLength ) ; atomicBuffers [ i + PARTITION_COUNT ] = new UnsafeBuffer ( mappedBuffer , metaDataOffset , TERM_META_DATA_LENGTH ) ; } atomicBuffers [ atomicBuffers . length - 1 ] = new UnsafeBuffer ( mappedBuffer , ( int ) ( logLength - LOG_META_DATA_LENGTH ) , LOG_META_DATA_LENGTH ) ; } else { mappedByteBuffers = new MappedByteBuffer [ PARTITION_COUNT + 1 ] ; final long metaDataSectionOffset = termLength * ( long ) PARTITION_COUNT ; final int metaDataSectionLength = ( int ) ( logLength - metaDataSectionOffset ) ; final MappedByteBuffer metaDataMappedBuffer = logChannel . map ( READ_WRITE , metaDataSectionOffset , metaDataSectionLength ) ; mappedByteBuffers [ mappedByteBuffers . length - 1 ] = metaDataMappedBuffer ; for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { mappedByteBuffers [ i ] = logChannel . map ( READ_WRITE , termLength * ( long ) i , termLength ) ; atomicBuffers [ i ] = new UnsafeBuffer ( mappedByteBuffers [ i ] ) ; atomicBuffers [ i + PARTITION_COUNT ] = new UnsafeBuffer ( metaDataMappedBuffer , i * TERM_META_DATA_LENGTH , TERM_META_DATA_LENGTH ) ; } atomicBuffers [ atomicBuffers . length - 1 ] = new UnsafeBuffer ( metaDataMappedBuffer , metaDataSectionLength - LOG_META_DATA_LENGTH , LOG_META_DATA_LENGTH ) ; } } catch ( final IOException ex ) { throw new RuntimeException ( ex ) ; } for ( final UnsafeBuffer buffer : atomicBuffers ) { buffer . verifyAlignment ( ) ; } } public UnsafeBuffer [ ] atomicBuffers ( ) { return atomicBuffers ; } public void close ( ) { for ( final MappedByteBuffer buffer : mappedByteBuffers ) { IoUtil . unmap ( buffer ) ; } } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . aeron . command . ConnectionBuffersReadyFlyweight ; interface DriverListener { void onNewPublication ( String channel , int streamId , int sessionId , int publicationLimitId , String logFileName , long correlationId ) ; void onNewConnection ( int streamId , int sessionId , long initialPosition , String logFileName , ConnectionBuffersReadyFlyweight message , long correlationId ) ; void onInactiveConnection ( int streamId , int sessionId , long position , long correlationId ) ; void onError ( ErrorCode errorCode , String message , long correlationId ) ; }
package uk . co . real_logic . aeron ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . agrona . ManagedResource ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . status . Position ; import java . util . Arrays ; import java . util . function . Consumer ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . * ; import static uk . co . real_logic . aeron . logbuffer . TermReader . * ; class Connection implements ManagedResource { private long timeOfLastStateChange = 0 ; private final long correlationId ; private final int sessionId ; private final int termLengthMask ; private final int positionBitsToShift ; private final Position subscriberPosition ; private final UnsafeBuffer [ ] termBuffers ; private final Header header ; private final LogBuffers logBuffers ; public Connection ( final int sessionId , final long initialPosition , final long correlationId , final Position subscriberPosition , final LogBuffers logBuffers ) { this . correlationId = correlationId ; this . sessionId = sessionId ; this . subscriberPosition = subscriberPosition ; this . logBuffers = logBuffers ; final UnsafeBuffer [ ] buffers = logBuffers . atomicBuffers ( ) ; termBuffers = Arrays . copyOf ( buffers , PARTITION_COUNT ) ; final int capacity = termBuffers [ 0 ] . capacity ( ) ; this . termLengthMask = capacity - 1 ; this . positionBitsToShift = Integer . numberOfTrailingZeros ( capacity ) ; final int initialTermId = initialTermId ( buffers [ LOG_META_DATA_SECTION_INDEX ] ) ; header = new Header ( initialTermId , capacity ) ; subscriberPosition . setOrdered ( initialPosition ) ; } public int sessionId ( ) { return sessionId ; } public long correlationId ( ) { return correlationId ; } public int poll ( final FragmentHandler fragmentHandler , final int fragmentLimit , final Consumer < Throwable > errorHandler ) { final long position = subscriberPosition . get ( ) ; final int termOffset = ( int ) position & termLengthMask ; final UnsafeBuffer termBuffer = termBuffers [ indexByPosition ( position , positionBitsToShift ) ] ; final long readOutcome = read ( termBuffer , termOffset , fragmentHandler , fragmentLimit , header , errorHandler ) ; final long newPosition = position + ( offset ( readOutcome ) - termOffset ) ; if ( newPosition > position ) { subscriberPosition . setOrdered ( newPosition ) ; } return fragmentsRead ( readOutcome ) ; } public void timeOfLastStateChange ( final long time ) { this . timeOfLastStateChange = time ; } public long timeOfLastStateChange ( ) { return timeOfLastStateChange ; } public void delete ( ) { logBuffers . close ( ) ; } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . aeron . command . CorrelatedMessageFlyweight ; import uk . co . real_logic . aeron . command . PublicationMessageFlyweight ; import uk . co . real_logic . aeron . command . RemoveMessageFlyweight ; import uk . co . real_logic . aeron . command . SubscriptionMessageFlyweight ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . ringbuffer . RingBuffer ; import java . nio . ByteBuffer ; import static uk . co . real_logic . aeron . command . ControlProtocolEvents . * ; class DriverProxy { public static final int MSG_BUFFER_CAPACITY = 4096 ; private final UnsafeBuffer writeBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( MSG_BUFFER_CAPACITY ) ) ; private final PublicationMessageFlyweight publicationMessage = new PublicationMessageFlyweight ( ) ; private final SubscriptionMessageFlyweight subscriptionMessage = new SubscriptionMessageFlyweight ( ) ; private final RemoveMessageFlyweight removeMessage = new RemoveMessageFlyweight ( ) ; private final UnsafeBuffer keepaliveBuffer = new UnsafeBuffer ( ByteBuffer . allocateDirect ( MSG_BUFFER_CAPACITY ) ) ; private final CorrelatedMessageFlyweight correlatedMessage = new CorrelatedMessageFlyweight ( ) ; private final RingBuffer toDriverCommandBuffer ; private final long clientId ; public DriverProxy ( final RingBuffer toDriverCommandBuffer ) { this . toDriverCommandBuffer = toDriverCommandBuffer ; publicationMessage . wrap ( writeBuffer , 0 ) ; subscriptionMessage . wrap ( writeBuffer , 0 ) ; correlatedMessage . wrap ( keepaliveBuffer , 0 ) ; removeMessage . wrap ( writeBuffer , 0 ) ; clientId = toDriverCommandBuffer . nextCorrelationId ( ) ; } public long timeOfLastDriverKeepalive ( ) { return toDriverCommandBuffer . consumerHeartbeatTime ( ) ; } public long addPublication ( final String channel , final int streamId , final int sessionId ) { return sendPublicationMessage ( channel , streamId , sessionId , ADD_PUBLICATION ) ; } public long removePublication ( final long registrationId ) { final long correlationId = toDriverCommandBuffer . nextCorrelationId ( ) ; removeMessage . correlationId ( correlationId ) ; removeMessage . registrationId ( registrationId ) ; if ( ! toDriverCommandBuffer . write ( REMOVE_PUBLICATION , writeBuffer , 0 , RemoveMessageFlyweight . length ( ) ) ) { throw new IllegalStateException ( "could not write publication remove message" ) ; } return correlationId ; } public long addSubscription ( final String channel , final int streamId ) { return sendSubscriptionMessage ( ADD_SUBSCRIPTION , channel , streamId , - 1 ) ; } public long removeSubscription ( final long registrationId ) { final long correlationId = toDriverCommandBuffer . nextCorrelationId ( ) ; removeMessage . correlationId ( correlationId ) ; removeMessage . registrationId ( registrationId ) ; if ( ! toDriverCommandBuffer . write ( REMOVE_SUBSCRIPTION , writeBuffer , 0 , RemoveMessageFlyweight . length ( ) ) ) { throw new IllegalStateException ( "could not write subscription remove message" ) ; } return correlationId ; } public void sendClientKeepalive ( ) { correlatedMessage . clientId ( clientId ) ; correlatedMessage . correlationId ( 0 ) ; if ( ! toDriverCommandBuffer . write ( CLIENT_KEEPALIVE , keepaliveBuffer , 0 , CorrelatedMessageFlyweight . LENGTH ) ) { throw new IllegalStateException ( "could not write keepalive message" ) ; } } private long sendPublicationMessage ( final String channel , final int streamId , final int sessionId , final int msgTypeId ) { final long correlationId = toDriverCommandBuffer . nextCorrelationId ( ) ; publicationMessage . clientId ( clientId ) ; publicationMessage . correlationId ( correlationId ) ; publicationMessage . streamId ( streamId ) ; publicationMessage . sessionId ( sessionId ) ; publicationMessage . channel ( channel ) ; if ( ! toDriverCommandBuffer . write ( msgTypeId , writeBuffer , 0 , publicationMessage . length ( ) ) ) { throw new IllegalStateException ( "could not write publication message" ) ; } return correlationId ; } private long sendSubscriptionMessage ( final int msgTypeId , final String channel , final int streamId , final long registrationId ) { final long correlationId = toDriverCommandBuffer . nextCorrelationId ( ) ; subscriptionMessage . clientId ( clientId ) ; subscriptionMessage . registrationCorrelationId ( registrationId ) ; subscriptionMessage . correlationId ( correlationId ) ; subscriptionMessage . streamId ( streamId ) ; subscriptionMessage . channel ( channel ) ; if ( ! toDriverCommandBuffer . write ( msgTypeId , writeBuffer , 0 , subscriptionMessage . length ( ) ) ) { throw new IllegalStateException ( "could not write subscription message" ) ; } return correlationId ; } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; import static uk . co . real_logic . agrona . BitUtil . align ; public class CncFileDescriptor { public static final String CNC_FILE = "cnc" ; public static final int CNC_VERSION = 1 ; public static final int CNC_VERSION_FIELD_OFFSET ; public static final int META_DATA_OFFSET ; public static final int TO_DRIVER_BUFFER_LENGTH_FIELD_OFFSET ; public static final int TO_CLIENTS_BUFFER_LENGTH_FIELD_OFFSET ; public static final int COUNTER_LABELS_BUFFER_LENGTH_FIELD_OFFSET ; public static final int COUNTER_VALUES_BUFFER_LENGTH_FIELD_OFFSET ; static { CNC_VERSION_FIELD_OFFSET = 0 ; META_DATA_OFFSET = CNC_VERSION_FIELD_OFFSET + BitUtil . SIZE_OF_INT ; TO_DRIVER_BUFFER_LENGTH_FIELD_OFFSET = 0 ; TO_CLIENTS_BUFFER_LENGTH_FIELD_OFFSET = TO_DRIVER_BUFFER_LENGTH_FIELD_OFFSET + BitUtil . SIZE_OF_INT ; COUNTER_LABELS_BUFFER_LENGTH_FIELD_OFFSET = TO_CLIENTS_BUFFER_LENGTH_FIELD_OFFSET + BitUtil . SIZE_OF_INT ; COUNTER_VALUES_BUFFER_LENGTH_FIELD_OFFSET = COUNTER_LABELS_BUFFER_LENGTH_FIELD_OFFSET + BitUtil . SIZE_OF_INT ; } public static final int META_DATA_LENGTH = COUNTER_VALUES_BUFFER_LENGTH_FIELD_OFFSET + BitUtil . SIZE_OF_INT ; public static final int END_OF_META_DATA_OFFSET = align ( BitUtil . SIZE_OF_INT + META_DATA_LENGTH , BitUtil . CACHE_LINE_LENGTH ) ; public static int computeCncFileLength ( final int totalLengthOfBuffers ) { return END_OF_META_DATA_OFFSET + totalLengthOfBuffers ; } public static int cncVersionOffset ( final int baseOffset ) { return baseOffset + CNC_VERSION_FIELD_OFFSET ; } public static int toDriverBufferLengthOffset ( final int baseOffset ) { return baseOffset + META_DATA_OFFSET + TO_DRIVER_BUFFER_LENGTH_FIELD_OFFSET ; } public static int toClientsBufferLengthOffset ( final int baseOffset ) { return baseOffset + META_DATA_OFFSET + TO_CLIENTS_BUFFER_LENGTH_FIELD_OFFSET ; } public static int counterLabelsBufferLengthOffset ( final int baseOffset ) { return baseOffset + META_DATA_OFFSET + COUNTER_LABELS_BUFFER_LENGTH_FIELD_OFFSET ; } public static int counterValuesBufferLengthOffset ( final int baseOffset ) { return baseOffset + META_DATA_OFFSET + COUNTER_VALUES_BUFFER_LENGTH_FIELD_OFFSET ; } public static UnsafeBuffer createMetaDataBuffer ( final ByteBuffer buffer ) { return new UnsafeBuffer ( buffer , 0 , BitUtil . SIZE_OF_INT + META_DATA_LENGTH ) ; } public static void fillMetaData ( final UnsafeBuffer cncMetaDataBuffer , final int toDriverBufferLength , final int toClientsBufferLength , final int counterLabelsBufferLength , final int counterValuesBufferLength ) { cncMetaDataBuffer . putInt ( cncVersionOffset ( 0 ) , CncFileDescriptor . CNC_VERSION ) ; cncMetaDataBuffer . putInt ( toDriverBufferLengthOffset ( 0 ) , toDriverBufferLength ) ; cncMetaDataBuffer . putInt ( toClientsBufferLengthOffset ( 0 ) , toClientsBufferLength ) ; cncMetaDataBuffer . putInt ( counterLabelsBufferLengthOffset ( 0 ) , counterLabelsBufferLength ) ; cncMetaDataBuffer . putInt ( counterValuesBufferLengthOffset ( 0 ) , counterValuesBufferLength ) ; } public static UnsafeBuffer createToDriverBuffer ( final ByteBuffer buffer , final DirectBuffer metaDataBuffer ) { return new UnsafeBuffer ( buffer , END_OF_META_DATA_OFFSET , metaDataBuffer . getInt ( toDriverBufferLengthOffset ( 0 ) ) ) ; } public static UnsafeBuffer createToClientsBuffer ( final ByteBuffer buffer , final DirectBuffer metaDataBuffer ) { final int offset = END_OF_META_DATA_OFFSET + metaDataBuffer . getInt ( toDriverBufferLengthOffset ( 0 ) ) ; return new UnsafeBuffer ( buffer , offset , metaDataBuffer . getInt ( toClientsBufferLengthOffset ( 0 ) ) ) ; } public static UnsafeBuffer createCounterLabelsBuffer ( final ByteBuffer buffer , final DirectBuffer metaDataBuffer ) { final int offset = END_OF_META_DATA_OFFSET + metaDataBuffer . getInt ( toDriverBufferLengthOffset ( 0 ) ) + metaDataBuffer . getInt ( toClientsBufferLengthOffset ( 0 ) ) ; return new UnsafeBuffer ( buffer , offset , metaDataBuffer . getInt ( counterLabelsBufferLengthOffset ( 0 ) ) ) ; } public static UnsafeBuffer createCounterValuesBuffer ( final ByteBuffer buffer , final DirectBuffer metaDataBuffer ) { final int offset = END_OF_META_DATA_OFFSET + metaDataBuffer . getInt ( toDriverBufferLengthOffset ( 0 ) ) + metaDataBuffer . getInt ( toClientsBufferLengthOffset ( 0 ) ) + metaDataBuffer . getInt ( counterLabelsBufferLengthOffset ( 0 ) ) ; return new UnsafeBuffer ( buffer , offset , metaDataBuffer . getInt ( counterValuesBufferLengthOffset ( 0 ) ) ) ; } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; import java . util . function . Consumer ; public class Subscription implements AutoCloseable { private static final int TRUE = 1 ; private static final int FALSE = 0 ; private static final Connection [ ] EMPTY_ARRAY = new Connection [ 0 ] ; private static final AtomicIntegerFieldUpdater < Subscription > IS_CLOSED_UPDATER = AtomicIntegerFieldUpdater . newUpdater ( Subscription . class , "isClosed" ) ; private final long registrationId ; private final int streamId ; private int roundRobinIndex = 0 ; private volatile int isClosed = FALSE ; private final String channel ; private final ClientConductor clientConductor ; private final Consumer < Throwable > errorHandler ; private volatile Connection [ ] connections = EMPTY_ARRAY ; Subscription ( final ClientConductor conductor , final String channel , final int streamId , final long registrationId , final Consumer < Throwable > errorHandler ) { this . clientConductor = conductor ; this . channel = channel ; this . streamId = streamId ; this . registrationId = registrationId ; this . errorHandler = errorHandler ; } public String channel ( ) { return channel ; } public int streamId ( ) { return streamId ; } public int poll ( final FragmentHandler fragmentHandler , final int fragmentLimit ) { ensureOpen ( ) ; final Connection [ ] connections = this . connections ; final int length = connections . length ; int fragmentsRead = 0 ; if ( length > 0 ) { int startingIndex = roundRobinIndex ++ ; if ( startingIndex >= length ) { roundRobinIndex = startingIndex = 0 ; } int i = startingIndex ; final Consumer < Throwable > errorHandler = this . errorHandler ; do { fragmentsRead += connections [ i ] . poll ( fragmentHandler , fragmentLimit , errorHandler ) ; if ( ++ i == length ) { i = 0 ; } } while ( fragmentsRead < fragmentLimit && i != startingIndex ) ; } return fragmentsRead ; } public void close ( ) { if ( IS_CLOSED_UPDATER . compareAndSet ( this , FALSE , TRUE ) ) { synchronized ( clientConductor ) { for ( final Connection connection : connections ) { clientConductor . lingerResource ( connection ) ; } connections = EMPTY_ARRAY ; clientConductor . releaseSubscription ( this ) ; } } } long registrationId ( ) { return registrationId ; } void addConnection ( final Connection connection ) { final Connection [ ] oldArray = connections ; final int oldLength = oldArray . length ; final Connection [ ] newArray = new Connection [ oldLength + 1 ] ; System . arraycopy ( oldArray , 0 , newArray , 0 , oldLength ) ; newArray [ oldLength ] = connection ; connections = newArray ; } boolean removeConnection ( final long correlationId ) { final Connection [ ] oldArray = connections ; final int oldLength = oldArray . length ; Connection removedConnection = null ; int index = - 1 ; for ( int i = 0 ; i < oldLength ; i ++ ) { if ( oldArray [ i ] . correlationId ( ) == correlationId ) { index = i ; removedConnection = oldArray [ i ] ; } } if ( null != removedConnection ) { final int newSize = oldLength - 1 ; final Connection [ ] newArray = new Connection [ newSize ] ; System . arraycopy ( oldArray , 0 , newArray , 0 , index ) ; System . arraycopy ( oldArray , index + 1 , newArray , index , newSize - index ) ; connections = newArray ; clientConductor . lingerResource ( removedConnection ) ; return true ; } return false ; } boolean isConnected ( final int sessionId ) { boolean isConnected = false ; for ( final Connection connection : connections ) { if ( sessionId == connection . sessionId ( ) ) { isConnected = true ; break ; } } return isConnected ; } boolean hasNoConnections ( ) { return connections . length == 0 ; } private void ensureOpen ( ) { if ( TRUE == isClosed ) { throw new IllegalStateException ( String . format ( "Subscription is closed: channel=%s streamId=%d registrationId=%d" , channel , streamId , registrationId ) ) ; } } }
package uk . co . real_logic . aeron . tools ; import org . junit . Test ; import java . util . ArrayList ; import java . util . List ; public class MessagesAtMessagesPerSecondTest { RateController rc ; List < RateControllerInterval > ivlsList = new ArrayList < RateControllerInterval > ( ) ; @ Test public void createWithOneAndOne ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new MessagesAtMessagesPerSecondInterval ( 1 , 1 ) ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithZeroMessagesPerSecond ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new MessagesAtMessagesPerSecondInterval ( 1 , 0 ) ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithZeroMessages ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new MessagesAtMessagesPerSecondInterval ( 0 , 1 ) ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithNegativeMessages ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new MessagesAtMessagesPerSecondInterval ( - 1 , 1 ) ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } @ Test ( expected = Exception . class ) public void createWithNegativeMessagesPerSecond ( ) throws Exception { ivlsList . clear ( ) ; ivlsList . add ( new MessagesAtMessagesPerSecondInterval ( 1 , - 1 ) ) ; rc = new RateController ( ( ) - > { return 0 ; } , ivlsList ) ; } }
package uk . co . real_logic . aeron ; class MappedLogBuffersFactory implements LogBuffersFactory { public LogBuffers map ( final String logFileName ) { return new LogBuffers ( logFileName ) ; } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; public class Flyweight { private static final byte [ ] EMPTY_BUFFER = new byte [ 0 ] ; private final MutableDirectBuffer buffer = new UnsafeBuffer ( EMPTY_BUFFER ) ; private int offset ; public Flyweight wrap ( final byte [ ] buffer ) { this . buffer . wrap ( buffer ) ; offset = 0 ; return this ; } public Flyweight wrap ( final ByteBuffer buffer ) { return wrap ( buffer , 0 ) ; } public Flyweight wrap ( final ByteBuffer buffer , final int offset ) { this . buffer . wrap ( buffer ) ; this . offset = offset ; return this ; } public Flyweight wrap ( final MutableDirectBuffer buffer ) { return wrap ( buffer , 0 ) ; } public Flyweight wrap ( final MutableDirectBuffer buffer , final int offset ) { this . buffer . wrap ( buffer ) ; this . offset = offset ; return this ; } public MutableDirectBuffer buffer ( ) { return buffer ; } public int offset ( ) { return offset ; } public void offset ( final int offset ) { this . offset = offset ; } protected void copyFlyweight ( final Flyweight srcFlyweight , final int index , final int length ) { buffer . putBytes ( index , srcFlyweight . buffer , srcFlyweight . offset , length ) ; } protected short uint8Get ( final int offset ) { return ( short ) ( buffer . getByte ( offset ) & 0xFF ) ; } protected void uint8Put ( final int offset , final short value ) { buffer . putByte ( offset , ( byte ) value ) ; } protected int uint16Get ( final int offset , final ByteOrder byteOrder ) { return buffer . getShort ( offset , byteOrder ) & 0xFFFF ; } protected void uint16Put ( final int offset , final int value , final ByteOrder byteOrder ) { buffer . putShort ( offset , ( short ) value , byteOrder ) ; } public String stringGet ( final int offset , final ByteOrder byteOrder ) { return buffer . getStringUtf8 ( offset , byteOrder ) ; } public int stringPut ( final int offset , final String value , final ByteOrder byteOrder ) { return buffer . putStringUtf8 ( offset , value , byteOrder ) ; } }
package uk . co . real_logic . aeron ; interface LogBuffersFactory { LogBuffers map ( String logFileName ) ; }
package uk . co . real_logic . aeron ; public enum ErrorCode { GENERIC_ERROR ( 0 ) , INVALID_CHANNEL ( 1 ) , UNKNOWN_SUBSCRIPTION ( 2 ) , GENERIC_ERROR_MESSAGE ( 3 ) , GENERIC_ERROR_SUBSCRIPTION_MESSAGE ( 4 ) , UNKNOWN_PUBLICATION ( 5 ) ; private final short value ; ErrorCode ( final int value ) { this . value = ( short ) value ; } public short value ( ) { return value ; } public static ErrorCode get ( final short value ) { if ( value > Singleton . VALUES . length ) { throw new IllegalArgumentException ( "no ErrorCode for value: " + value ) ; } return Singleton . VALUES [ value ] ; } static class Singleton { public static final ErrorCode [ ] VALUES = ErrorCode . values ( ) ; } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . agrona . collections . Int2ObjectHashMap ; import java . util . ArrayList ; import java . util . List ; import java . util . function . Consumer ; class ActiveSubscriptions { private final Int2ObjectHashMap < List < Subscription > > subscriptionsByStreamIdMap = new Int2ObjectHashMap < > ( ) ; public void forEach ( final int streamId , final Consumer < Subscription > handler ) { final List < Subscription > subscriptions = subscriptionsByStreamIdMap . get ( streamId ) ; if ( null != subscriptions ) { subscriptions . forEach ( handler ) ; } } public void add ( final Subscription subscription ) { final List < Subscription > subscriptions = subscriptionsByStreamIdMap . computeIfAbsent ( subscription . streamId ( ) , ( ignore ) - > new ArrayList < > ( ) ) ; subscriptions . add ( subscription ) ; } public void remove ( final Subscription subscription ) { final int streamId = subscription . streamId ( ) ; final List < Subscription > subscriptions = subscriptionsByStreamIdMap . get ( streamId ) ; if ( subscriptions . remove ( subscription ) && subscriptions . isEmpty ( ) ) { subscriptionsByStreamIdMap . remove ( streamId ) ; if ( subscriptionsByStreamIdMap . isEmpty ( ) ) { subscriptionsByStreamIdMap . remove ( streamId ) ; } } } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . aeron . command . ConnectionBuffersReadyFlyweight ; import uk . co . real_logic . aeron . command . ConnectionMessageFlyweight ; import uk . co . real_logic . aeron . command . CorrelatedMessageFlyweight ; import uk . co . real_logic . aeron . command . PublicationBuffersReadyFlyweight ; import uk . co . real_logic . aeron . protocol . ErrorFlyweight ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . concurrent . MessageHandler ; import uk . co . real_logic . agrona . concurrent . broadcast . CopyBroadcastReceiver ; import static uk . co . real_logic . aeron . command . ControlProtocolEvents . * ; class DriverListenerAdapter implements MessageHandler { private final CopyBroadcastReceiver broadcastReceiver ; private final ErrorFlyweight errorHeader = new ErrorFlyweight ( ) ; private final PublicationBuffersReadyFlyweight publicationReady = new PublicationBuffersReadyFlyweight ( ) ; private final ConnectionBuffersReadyFlyweight connectionReady = new ConnectionBuffersReadyFlyweight ( ) ; private final CorrelatedMessageFlyweight correlatedMessage = new CorrelatedMessageFlyweight ( ) ; private final ConnectionMessageFlyweight connectionMessage = new ConnectionMessageFlyweight ( ) ; private final DriverListener listener ; private long activeCorrelationId ; private long lastReceivedCorrelationId ; private String expectedChannel ; public DriverListenerAdapter ( final CopyBroadcastReceiver broadcastReceiver , final DriverListener listener ) { this . broadcastReceiver = broadcastReceiver ; this . listener = listener ; } public int pollMessage ( final long activeCorrelationId , final String expectedChannel ) { this . activeCorrelationId = activeCorrelationId ; this . lastReceivedCorrelationId = - 1 ; this . expectedChannel = expectedChannel ; return broadcastReceiver . receive ( this ) ; } public long lastReceivedCorrelationId ( ) { return lastReceivedCorrelationId ; } public void onMessage ( final int msgTypeId , final MutableDirectBuffer buffer , final int index , final int length ) { switch ( msgTypeId ) { case ON_PUBLICATION_READY : { publicationReady . wrap ( buffer , index ) ; final long correlationId = publicationReady . correlationId ( ) ; if ( correlationId == activeCorrelationId ) { final int sessionId = publicationReady . sessionId ( ) ; final int streamId = publicationReady . streamId ( ) ; final int publicationLimitCounterId = publicationReady . publicationLimitCounterId ( ) ; final String logFileName = publicationReady . logFileName ( ) ; listener . onNewPublication ( expectedChannel , streamId , sessionId , publicationLimitCounterId , logFileName , correlationId ) ; lastReceivedCorrelationId = correlationId ; } break ; } case ON_CONNECTION_READY : { connectionReady . wrap ( buffer , index ) ; final int sessionId = connectionReady . sessionId ( ) ; final int streamId = connectionReady . streamId ( ) ; final long joiningPosition = connectionReady . joiningPosition ( ) ; final String logFileName = connectionReady . logFileName ( ) ; final long correlationId = connectionReady . correlationId ( ) ; listener . onNewConnection ( streamId , sessionId , joiningPosition , logFileName , connectionReady , correlationId ) ; break ; } case ON_OPERATION_SUCCESS : { correlatedMessage . wrap ( buffer , index ) ; final long correlationId = correlatedMessage . correlationId ( ) ; if ( correlationId == activeCorrelationId ) { lastReceivedCorrelationId = correlationId ; } break ; } case ON_INACTIVE_CONNECTION : { connectionMessage . wrap ( buffer , index ) ; listener . onInactiveConnection ( connectionMessage . streamId ( ) , connectionMessage . sessionId ( ) , connectionMessage . position ( ) , connectionMessage . correlationId ( ) ) ; break ; } case ON_ERROR : { errorHeader . wrap ( buffer , index ) ; correlatedMessage . wrap ( buffer , errorHeader . offendingHeaderOffset ( ) ) ; final long correlationId = correlatedMessage . correlationId ( ) ; if ( correlationId == activeCorrelationId ) { listener . onError ( errorHeader . errorCode ( ) , errorHeader . errorMessage ( ) , correlatedMessage . correlationId ( ) ) ; lastReceivedCorrelationId = correlationId ; } break ; } default : break ; } } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . aeron . exceptions . DriverTimeoutException ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . IoUtil ; import uk . co . real_logic . agrona . TimerWheel ; import uk . co . real_logic . agrona . concurrent . * ; import uk . co . real_logic . agrona . concurrent . broadcast . BroadcastReceiver ; import uk . co . real_logic . agrona . concurrent . broadcast . CopyBroadcastReceiver ; import uk . co . real_logic . agrona . concurrent . ringbuffer . ManyToOneRingBuffer ; import uk . co . real_logic . agrona . concurrent . ringbuffer . RingBuffer ; import java . nio . MappedByteBuffer ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . function . Consumer ; import static uk . co . real_logic . agrona . IoUtil . mapExistingFile ; public final class Aeron implements AutoCloseable { public static final Consumer < Throwable > DEFAULT_ERROR_HANDLER = ( throwable ) - > { throwable . printStackTrace ( ) ; if ( throwable instanceof DriverTimeoutException ) { System . err . printf ( "\n***\n*** Timeout from the Media Driver - is it currently running? Exiting.\n***\n" ) ; System . exit ( - 1 ) ; } } ; private static final long IDLE_SLEEP_NS = TimeUnit . MILLISECONDS . toNanos ( 4 ) ; private static final long NULL_TIMEOUT = - 1 ; private static final long DEFAULT_MEDIA_DRIVER_TIMEOUT_MS = 10_000 ; private static final int CONDUCTOR_TICKS_PER_WHEEL = 1024 ; private static final int CONDUCTOR_TICK_DURATION_US = 10_000 ; private final ClientConductor conductor ; private final AgentRunner conductorRunner ; private final Context ctx ; Aeron ( final Context ctx ) { ctx . conclude ( ) ; this . ctx = ctx ; conductor = new ClientConductor ( ctx . epochClock , ctx . toClientBuffer , ctx . logBuffersFactory , ctx . countersBuffer ( ) , new DriverProxy ( ctx . toDriverBuffer ) , new TimerWheel ( CONDUCTOR_TICK_DURATION_US , TimeUnit . MICROSECONDS , CONDUCTOR_TICKS_PER_WHEEL ) , ctx . errorHandler , ctx . newConnectionHandler , ctx . inactiveConnectionHandler , ctx . mediaDriverTimeout ( ) ) ; conductorRunner = new AgentRunner ( ctx . idleStrategy , ctx . errorHandler , null , conductor ) ; } public static Aeron connect ( final Context ctx ) { return new Aeron ( ctx ) . start ( ) ; } public void close ( ) { conductorRunner . close ( ) ; ctx . close ( ) ; } public Publication addPublication ( final String channel , final int streamId ) { return addPublication ( channel , streamId , 0 ) ; } public Publication addPublication ( final String channel , final int streamId , final int sessionId ) { int sessionIdToRequest = sessionId ; if ( 0 == sessionId ) { sessionIdToRequest = BitUtil . generateRandomisedId ( ) ; } return conductor . addPublication ( channel , streamId , sessionIdToRequest ) ; } public Subscription addSubscription ( final String channel , final int streamId ) { return conductor . addSubscription ( channel , streamId ) ; } private Aeron start ( ) { final Thread thread = new Thread ( conductorRunner ) ; thread . setName ( "aeron-client-conductor" ) ; thread . start ( ) ; return this ; } public static class Context extends CommonContext { private long mediaDriverTimeoutMs = NULL_TIMEOUT ; private final AtomicBoolean isClosed = new AtomicBoolean ( false ) ; private EpochClock epochClock ; private IdleStrategy idleStrategy ; private CopyBroadcastReceiver toClientBuffer ; private RingBuffer toDriverBuffer ; private MappedByteBuffer cncByteBuffer ; private DirectBuffer cncMetaDataBuffer ; private LogBuffersFactory logBuffersFactory ; private Consumer < Throwable > errorHandler ; private NewConnectionHandler newConnectionHandler ; private InactiveConnectionHandler inactiveConnectionHandler ; public Context conclude ( ) { super . conclude ( ) ; try { if ( null == epochClock ) { epochClock = new SystemEpochClock ( ) ; } if ( mediaDriverTimeoutMs == NULL_TIMEOUT ) { mediaDriverTimeoutMs = DEFAULT_MEDIA_DRIVER_TIMEOUT_MS ; } if ( null == idleStrategy ) { idleStrategy = new SleepingIdleStrategy ( IDLE_SLEEP_NS ) ; } if ( cncFile ( ) != null ) { cncByteBuffer = mapExistingFile ( cncFile ( ) , CncFileDescriptor . CNC_FILE ) ; cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; final int cncVersion = cncMetaDataBuffer . getInt ( CncFileDescriptor . cncVersionOffset ( 0 ) ) ; if ( CncFileDescriptor . CNC_VERSION != cncVersion ) { throw new IllegalStateException ( "aeron cnc file version not understood: version=" + cncVersion ) ; } } if ( null == toClientBuffer ) { final BroadcastReceiver receiver = new BroadcastReceiver ( CncFileDescriptor . createToClientsBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; toClientBuffer = new CopyBroadcastReceiver ( receiver ) ; } if ( null == toDriverBuffer ) { toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; } if ( counterLabelsBuffer ( ) == null ) { counterLabelsBuffer ( CncFileDescriptor . createCounterLabelsBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; } if ( countersBuffer ( ) == null ) { countersBuffer ( CncFileDescriptor . createCounterValuesBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; } if ( null == logBuffersFactory ) { logBuffersFactory = new MappedLogBuffersFactory ( ) ; } if ( null == errorHandler ) { errorHandler = DEFAULT_ERROR_HANDLER ; } } catch ( final Exception ex ) { System . err . printf ( "\n***\n*** Failed to connect to the Media Driver - is it currently running?\n***\n" ) ; throw new IllegalStateException ( "Could not initialise communication buffers" , ex ) ; } return this ; } public Context epochClock ( final EpochClock clock ) { this . epochClock = clock ; return this ; } public Context idleStrategy ( final IdleStrategy idleStrategy ) { this . idleStrategy = idleStrategy ; return this ; } public Context toClientBuffer ( final CopyBroadcastReceiver toClientBuffer ) { this . toClientBuffer = toClientBuffer ; return this ; } public Context toDriverBuffer ( final RingBuffer toDriverBuffer ) { this . toDriverBuffer = toDriverBuffer ; return this ; } public Context bufferManager ( final LogBuffersFactory logBuffersFactory ) { this . logBuffersFactory = logBuffersFactory ; return this ; } public Context errorHandler ( final Consumer < Throwable > handler ) { this . errorHandler = handler ; return this ; } public Context newConnectionHandler ( final NewConnectionHandler handler ) { this . newConnectionHandler = handler ; return this ; } public Context inactiveConnectionHandler ( final InactiveConnectionHandler handler ) { this . inactiveConnectionHandler = handler ; return this ; } public Context mediaDriverTimeout ( final long value ) { this . mediaDriverTimeoutMs = value ; return this ; } public long mediaDriverTimeout ( ) { return mediaDriverTimeoutMs ; } public void close ( ) { if ( isClosed . compareAndSet ( false , true ) ) { IoUtil . unmap ( cncByteBuffer ) ; super . close ( ) ; } } } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . aeron . logbuffer . BufferClaim ; import uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor ; import uk . co . real_logic . aeron . logbuffer . TermAppender ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import uk . co . real_logic . agrona . concurrent . status . ReadablePosition ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . * ; public class Publication implements AutoCloseable { public static final long NOT_CONNECTED = - 1 ; public static final long BACK_PRESSURED = - 2 ; private final long registrationId ; private final int streamId ; private final int sessionId ; private final String channel ; private final ClientConductor clientConductor ; private final LogBuffers logBuffers ; private final TermAppender [ ] termAppenders = new TermAppender [ PARTITION_COUNT ] ; private final ReadablePosition publicationLimit ; private final UnsafeBuffer logMetaDataBuffer ; private final int positionBitsToShift ; private int refCount = 0 ; private volatile boolean isClosed = false ; Publication ( final ClientConductor clientConductor , final String channel , final int streamId , final int sessionId , final ReadablePosition publicationLimit , final LogBuffers logBuffers , final long registrationId ) { final UnsafeBuffer [ ] buffers = logBuffers . atomicBuffers ( ) ; final UnsafeBuffer logMetaDataBuffer = buffers [ LOG_META_DATA_SECTION_INDEX ] ; final UnsafeBuffer [ ] defaultFrameHeaders = defaultFrameHeaders ( logMetaDataBuffer ) ; final int mtuLength = mtuLength ( logMetaDataBuffer ) ; activeTermId ( logMetaDataBuffer , initialTermId ( logMetaDataBuffer ) ) ; for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { termAppenders [ i ] = new TermAppender ( buffers [ i ] , buffers [ i + PARTITION_COUNT ] , defaultFrameHeaders [ i ] , mtuLength ) ; } this . clientConductor = clientConductor ; this . channel = channel ; this . streamId = streamId ; this . sessionId = sessionId ; this . logBuffers = logBuffers ; this . logMetaDataBuffer = logMetaDataBuffer ; this . registrationId = registrationId ; this . publicationLimit = publicationLimit ; this . positionBitsToShift = Integer . numberOfTrailingZeros ( termAppenders [ 0 ] . termBuffer ( ) . capacity ( ) ) ; } public String channel ( ) { return channel ; } public int streamId ( ) { return streamId ; } public int sessionId ( ) { return sessionId ; } public int maxMessageLength ( ) { return termAppenders [ 0 ] . maxMessageLength ( ) ; } public void close ( ) { synchronized ( clientConductor ) { if ( -- refCount == 0 ) { isClosed = true ; logBuffers . close ( ) ; clientConductor . releasePublication ( this ) ; } } } public long position ( ) { ensureOpen ( ) ; final int initialTermId = initialTermId ( logMetaDataBuffer ) ; final int activeTermId = activeTermId ( logMetaDataBuffer ) ; final int currentTail = termAppenders [ indexByTerm ( initialTermId , activeTermId ) ] . tailVolatile ( ) ; return computePosition ( activeTermId , currentTail , positionBitsToShift , initialTermId ) ; } public long offer ( final DirectBuffer buffer ) { return offer ( buffer , 0 , buffer . capacity ( ) ) ; } public long offer ( final DirectBuffer buffer , final int offset , final int length ) { ensureOpen ( ) ; final int initialTermId = initialTermId ( logMetaDataBuffer ) ; final int activeTermId = activeTermId ( logMetaDataBuffer ) ; final int activeIndex = indexByTerm ( initialTermId , activeTermId ) ; final TermAppender termAppender = termAppenders [ activeIndex ] ; final int currentTail = termAppender . rawTailVolatile ( ) ; final long position = computePosition ( activeTermId , currentTail , positionBitsToShift , initialTermId ) ; final int capacity = termAppender . termBuffer ( ) . capacity ( ) ; final long limit = publicationLimit . getVolatile ( ) ; long newPosition = limit > 0 ? BACK_PRESSURED : NOT_CONNECTED ; if ( currentTail < capacity && position < limit ) { final int nextOffset = termAppender . append ( buffer , offset , length ) ; newPosition = newPosition ( activeTermId , activeIndex , currentTail , position , nextOffset ) ; } return newPosition ; } public long tryClaim ( final int length , final BufferClaim bufferClaim ) { ensureOpen ( ) ; final int initialTermId = initialTermId ( logMetaDataBuffer ) ; final int activeTermId = activeTermId ( logMetaDataBuffer ) ; final int activeIndex = indexByTerm ( initialTermId , activeTermId ) ; final TermAppender termAppender = termAppenders [ activeIndex ] ; final int currentTail = termAppender . rawTailVolatile ( ) ; final long position = computePosition ( activeTermId , currentTail , positionBitsToShift , initialTermId ) ; final int capacity = termAppender . termBuffer ( ) . capacity ( ) ; final long limit = publicationLimit . getVolatile ( ) ; long newPosition = limit > 0 ? BACK_PRESSURED : NOT_CONNECTED ; if ( currentTail < capacity && position < limit ) { final int nextOffset = termAppender . claim ( length , bufferClaim ) ; newPosition = newPosition ( activeTermId , activeIndex , currentTail , position , nextOffset ) ; } return newPosition ; } long registrationId ( ) { return registrationId ; } void incRef ( ) { synchronized ( clientConductor ) { ++ refCount ; } } private long newPosition ( final int activeTermId , final int activeIndex , final int currentTail , final long position , final int nextOffset ) { final long newPosition ; switch ( nextOffset ) { case TermAppender . TRIPPED : { final int newTermId = activeTermId + 1 ; final int nextIndex = nextPartitionIndex ( activeIndex ) ; final int nextNextIndex = nextPartitionIndex ( nextIndex ) ; LogBufferDescriptor . defaultHeaderTermId ( logMetaDataBuffer , nextIndex , newTermId ) ; LogBufferDescriptor . defaultHeaderTermId ( logMetaDataBuffer , nextNextIndex , newTermId + 1 ) ; termAppenders [ nextNextIndex ] . statusOrdered ( NEEDS_CLEANING ) ; LogBufferDescriptor . activeTermId ( logMetaDataBuffer , newTermId ) ; } case TermAppender . FAILED : newPosition = BACK_PRESSURED ; break ; default : newPosition = ( position - currentTail ) + nextOffset ; } return newPosition ; } private void ensureOpen ( ) { if ( isClosed ) { throw new IllegalStateException ( String . format ( "Publication is closed: channel=%s streamId=%d sessionId=%d registrationId=%d" , channel , streamId , sessionId , registrationId ) ) ; } } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . agrona . IoUtil ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . io . File ; import java . util . UUID ; import static java . lang . System . getProperty ; public class CommonContext implements AutoCloseable { public static final String AERON_DIR_PROP_NAME = "aeron.dir" ; public static final String AERON_DIR_PROP_DEFAULT ; public static final String MULTICAST_DEFAULT_INTERFACE_PROP_NAME = "aeron.multicast.default.interface" ; private String dirName ; private File cncFile ; private UnsafeBuffer counterLabelsBuffer ; private UnsafeBuffer countersBuffer ; static { String aeronDirName = IoUtil . tmpDirName ( ) + "aeron" ; if ( "Linux" . equalsIgnoreCase ( System . getProperty ( "os.name" ) ) ) { final File devShmDir = new File ( "/dev/shm" ) ; if ( devShmDir . exists ( ) ) { aeronDirName = "/dev/shm/aeron" ; } } AERON_DIR_PROP_DEFAULT = aeronDirName ; } public static String generateEmbeddedDirName ( ) { final String randomDirName = UUID . randomUUID ( ) . toString ( ) ; String aeronDirName = IoUtil . tmpDirName ( ) + "aeron-" + randomDirName ; if ( "Linux" . equalsIgnoreCase ( System . getProperty ( "os.name" ) ) ) { final File devShmDir = new File ( "/dev/shm" ) ; if ( devShmDir . exists ( ) ) { aeronDirName = "/dev/shm/aeron-" + randomDirName ; } } return aeronDirName ; } public CommonContext ( ) { dirName = getProperty ( AERON_DIR_PROP_NAME , AERON_DIR_PROP_DEFAULT ) ; } public CommonContext conclude ( ) { cncFile = new File ( dirName , CncFileDescriptor . CNC_FILE ) ; return this ; } public String dirName ( ) { return dirName ; } public CommonContext dirName ( final String dirName ) { this . dirName = dirName ; return this ; } public static File newDefaultCncFile ( ) { return new File ( getProperty ( AERON_DIR_PROP_NAME , AERON_DIR_PROP_DEFAULT ) , CncFileDescriptor . CNC_FILE ) ; } public UnsafeBuffer counterLabelsBuffer ( ) { return counterLabelsBuffer ; } public CommonContext counterLabelsBuffer ( final UnsafeBuffer counterLabelsBuffer ) { this . counterLabelsBuffer = counterLabelsBuffer ; return this ; } public UnsafeBuffer countersBuffer ( ) { return countersBuffer ; } public CommonContext countersBuffer ( final UnsafeBuffer countersBuffer ) { this . countersBuffer = countersBuffer ; return this ; } public File cncFile ( ) { return cncFile ; } public void close ( ) { } }
package uk . co . real_logic . aeron ; import uk . co . real_logic . aeron . logbuffer . FragmentHandler ; import uk . co . real_logic . aeron . logbuffer . Header ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . collections . Int2ObjectHashMap ; import java . util . function . IntFunction ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . * ; public class FragmentAssemblyAdapter implements FragmentHandler { private final FragmentHandler delegate ; private final AssemblyHeader assemblyHeader = new AssemblyHeader ( ) ; private final Int2ObjectHashMap < BufferBuilder > builderBySessionIdMap = new Int2ObjectHashMap < > ( ) ; private final IntFunction < BufferBuilder > builderFunc ; public FragmentAssemblyAdapter ( final FragmentHandler delegate ) { this ( delegate , BufferBuilder . INITIAL_CAPACITY ) ; } public FragmentAssemblyAdapter ( final FragmentHandler delegate , final int initialBufferLength ) { this . delegate = delegate ; builderFunc = ( ignore ) - > new BufferBuilder ( initialBufferLength ) ; } public void onFragment ( final DirectBuffer buffer , final int offset , final int length , final Header header ) { final byte flags = header . flags ( ) ; if ( ( flags & UNFRAGMENTED ) == UNFRAGMENTED ) { delegate . onFragment ( buffer , offset , length , header ) ; } else { if ( ( flags & BEGIN_FRAG ) == BEGIN_FRAG ) { final BufferBuilder builder = builderBySessionIdMap . computeIfAbsent ( header . sessionId ( ) , builderFunc ) ; builder . reset ( ) . append ( buffer , offset , length ) ; } else { final BufferBuilder builder = builderBySessionIdMap . get ( header . sessionId ( ) ) ; if ( null != builder && builder . limit ( ) != 0 ) { builder . append ( buffer , offset , length ) ; if ( ( flags & END_FRAG ) == END_FRAG ) { final int msgLength = builder . limit ( ) ; delegate . onFragment ( builder . buffer ( ) , 0 , msgLength , assemblyHeader . reset ( header , msgLength ) ) ; builder . reset ( ) ; } } } } } public boolean freeSessionBuffer ( final int sessionId ) { return null != builderBySessionIdMap . remove ( sessionId ) ; } private static class AssemblyHeader extends Header { private int frameLength ; public AssemblyHeader reset ( final Header base , final int msgLength ) { positionBitsToShift ( base . positionBitsToShift ( ) ) ; initialTermId ( base . initialTermId ( ) ) ; offset ( base . offset ( ) ) ; buffer ( base . buffer ( ) ) ; frameLength = msgLength + DataHeaderFlyweight . HEADER_LENGTH ; return this ; } public int frameLength ( ) { return frameLength ; } public byte flags ( ) { return ( byte ) ( super . flags ( ) | UNFRAGMENTED ) ; } public int termOffset ( ) { return offset ( ) - ( frameLength - super . frameLength ( ) ) ; } } }
package uk . co . real_logic . aeron . tools ; import org . apache . commons . cli . ParseException ; import org . junit . Before ; import org . junit . Test ; import org . mockito . Mockito ; import org . mockito . MockitoAnnotations ; import uk . co . real_logic . aeron . driver . LossGenerator ; import uk . co . real_logic . agrona . concurrent . BackoffIdleStrategy ; import uk . co . real_logic . agrona . concurrent . IdleStrategy ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . net . InetSocketAddress ; import static org . hamcrest . CoreMatchers . * ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Mockito . doReturn ; public class MediaDriverOptionsTest { MediaDriverOptions opts ; static class TestIdleStrategy implements IdleStrategy { public void idle ( final int workCount ) { } } static class TestLossGenerator implements LossGenerator { public boolean shouldDropFrame ( final InetSocketAddress address , final UnsafeBuffer buffer , final int length ) { return false ; } } @ Before public void setUp ( ) { MockitoAnnotations . initMocks ( this ) ; opts = new MediaDriverOptions ( ) ; } @ Test public void help ( ) throws Exception { final String [ ] args = { "--help" } ; assertThat ( opts . parseArgs ( args ) , is ( 1 ) ) ; } @ Test public void helpShorthand ( ) throws Exception { final String [ ] args = { "-h" } ; assertThat ( opts . parseArgs ( args ) , is ( 1 ) ) ; } @ Test public void defaultsToNull ( ) throws Exception { final String [ ] args = { "" } ; opts . parseArgs ( args ) ; assertThat ( opts . properties ( ) , is ( nullValue ( ) ) ) ; assertThat ( opts . conductorIdleStrategy ( ) , is ( nullValue ( ) ) ) ; assertThat ( opts . senderIdleStrategy ( ) , is ( nullValue ( ) ) ) ; assertThat ( opts . receiverIdleStrategy ( ) , is ( nullValue ( ) ) ) ; assertThat ( opts . sharedNetworkIdleStrategy ( ) , is ( nullValue ( ) ) ) ; assertThat ( opts . sharedIdleStrategy ( ) , is ( nullValue ( ) ) ) ; assertThat ( opts . dataLossGenerator ( ) , is ( nullValue ( ) ) ) ; assertThat ( opts . controlLossGenerator ( ) , is ( nullValue ( ) ) ) ; } @ Test public void propertiesFile ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final String fileText = "hello.world=testing" ; final InputStream inputStream = new ByteArrayInputStream ( fileText . getBytes ( ) ) ; doReturn ( inputStream ) . when ( spyOpts ) . newFileInputStream ( "filename" ) ; final String [ ] args = { "--properties" , "filename" } ; spyOpts . parseArgs ( args ) ; assertThat ( "FAIL: Properties object should have been created" , spyOpts . properties ( ) , is ( not ( nullValue ( ) ) ) ) ; assertThat ( spyOpts . properties ( ) . getProperty ( "hello.world" ) , is ( "testing" ) ) ; } @ Test public void senderIdleStrategy ( ) throws Exception { final String [ ] args = { "--sender" , "uk.co.real_logic.aeron.tools.MediaDriverOptionsTest$TestIdleStrategy" } ; opts . parseArgs ( args ) ; assertThat ( opts . senderIdleStrategy ( ) , instanceOf ( TestIdleStrategy . class ) ) ; } @ Test public void receiverIdleStrategy ( ) throws Exception { final String [ ] args = { "--receiver" , "uk.co.real_logic.aeron.tools.MediaDriverOptionsTest$TestIdleStrategy" } ; opts . parseArgs ( args ) ; assertThat ( opts . receiverIdleStrategy ( ) , instanceOf ( TestIdleStrategy . class ) ) ; } @ Test public void conductorIdleStrategy ( ) throws Exception { final String [ ] args = { "--conductor" , "uk.co.real_logic.aeron.tools.MediaDriverOptionsTest$TestIdleStrategy" } ; opts . parseArgs ( args ) ; assertThat ( opts . conductorIdleStrategy ( ) , instanceOf ( TestIdleStrategy . class ) ) ; } @ Test public void sharedNetworkIdleStrategy ( ) throws Exception { final String [ ] args = { "--network" , "uk.co.real_logic.aeron.tools.MediaDriverOptionsTest$TestIdleStrategy" } ; opts . parseArgs ( args ) ; assertThat ( opts . sharedNetworkIdleStrategy ( ) , instanceOf ( TestIdleStrategy . class ) ) ; } @ Test public void sharedIdleStrategy ( ) throws Exception { final String [ ] args = { "--shared" , "uk.co.real_logic.aeron.tools.MediaDriverOptionsTest$TestIdleStrategy" } ; opts . parseArgs ( args ) ; assertThat ( opts . sharedIdleStrategy ( ) , instanceOf ( TestIdleStrategy . class ) ) ; } @ Test public void senderIdleStrategyProperty ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final String fileText = "aeron.tools.mediadriver.sender=" + TestIdleStrategy . class . getName ( ) ; final InputStream inputStream = new ByteArrayInputStream ( fileText . getBytes ( ) ) ; doReturn ( inputStream ) . when ( spyOpts ) . newFileInputStream ( "filename" ) ; final String [ ] args = { "--properties" , "filename" } ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . senderIdleStrategy ( ) , instanceOf ( TestIdleStrategy . class ) ) ; } @ Test public void receiverIdleStrategyProperty ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final String fileText = "aeron.tools.mediadriver.receiver=" + TestIdleStrategy . class . getName ( ) ; final InputStream inputStream = new ByteArrayInputStream ( fileText . getBytes ( ) ) ; doReturn ( inputStream ) . when ( spyOpts ) . newFileInputStream ( "filename" ) ; final String [ ] args = { "--properties" , "filename" } ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . receiverIdleStrategy ( ) , instanceOf ( TestIdleStrategy . class ) ) ; } @ Test public void conductorIdleStrategyProperty ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final String fileText = "aeron.tools.mediadriver.conductor=" + TestIdleStrategy . class . getName ( ) ; final InputStream inputStream = new ByteArrayInputStream ( fileText . getBytes ( ) ) ; doReturn ( inputStream ) . when ( spyOpts ) . newFileInputStream ( "filename" ) ; final String [ ] args = { "--properties" , "filename" } ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . conductorIdleStrategy ( ) , instanceOf ( TestIdleStrategy . class ) ) ; } @ Test public void netowrkIdleStrategyProperty ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final String fileText = "aeron.tools.mediadriver.network=" + TestIdleStrategy . class . getName ( ) ; final InputStream inputStream = new ByteArrayInputStream ( fileText . getBytes ( ) ) ; doReturn ( inputStream ) . when ( spyOpts ) . newFileInputStream ( "filename" ) ; final String [ ] args = { "--properties" , "filename" } ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . sharedNetworkIdleStrategy ( ) , instanceOf ( TestIdleStrategy . class ) ) ; } @ Test public void sharedIdleStrategyProperty ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final String fileText = "aeron.tools.mediadriver.shared=" + TestIdleStrategy . class . getName ( ) ; final InputStream inputStream = new ByteArrayInputStream ( fileText . getBytes ( ) ) ; doReturn ( inputStream ) . when ( spyOpts ) . newFileInputStream ( "filename" ) ; final String [ ] args = { "--properties" , "filename" } ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . sharedIdleStrategy ( ) , instanceOf ( TestIdleStrategy . class ) ) ; } @ Test public void commandLineOverrideStrategyFromProperties1 ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final String fileText = "aeron.tools.mediadriver.shared=null" ; final InputStream inputStream = new ByteArrayInputStream ( fileText . getBytes ( ) ) ; doReturn ( inputStream ) . when ( spyOpts ) . newFileInputStream ( "filename" ) ; final String [ ] args = { "--shared" , TestIdleStrategy . class . getName ( ) , "--properties" , "filename" } ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . sharedIdleStrategy ( ) , instanceOf ( TestIdleStrategy . class ) ) ; } @ Test public void commandLineOverrideStrategyFromProperties2 ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final String fileText = "aeron.tools.mediadriver.shared=" + TestIdleStrategy . class . getName ( ) ; final InputStream inputStream = new ByteArrayInputStream ( fileText . getBytes ( ) ) ; doReturn ( inputStream ) . when ( spyOpts ) . newFileInputStream ( "filename" ) ; final String [ ] args = { "--shared" , "null" , "--properties" , "filename" } ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . sharedIdleStrategy ( ) , is ( nullValue ( ) ) ) ; } @ Test public void testBackoffIdleStrategy ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final TestIdleStrategy testIdleStrategy = new TestIdleStrategy ( ) ; final String [ ] args = { "--conductor" , BackoffIdleStrategy . class . getName ( ) } ; doReturn ( testIdleStrategy ) . when ( spyOpts ) . newBackoffIdleStrategy ( anyInt ( ) , anyInt ( ) , anyInt ( ) , anyInt ( ) ) ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . conductorIdleStrategy ( ) , instanceOf ( TestIdleStrategy . class ) ) ; } @ Test public void testBackoffIdleStrategyWithInput ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final TestIdleStrategy testIdleStrategy = new TestIdleStrategy ( ) ; final String [ ] args = { "--conductor" , BackoffIdleStrategy . class . getName ( ) + "(10, 20, 30 ,40)" } ; doReturn ( testIdleStrategy ) . when ( spyOpts ) . newBackoffIdleStrategy ( 10 , 20 , 30 , 40 ) ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . conductorIdleStrategy ( ) , instanceOf ( TestIdleStrategy . class ) ) ; } @ Test ( expected = ParseException . class ) public void testBackoffIdleStrategyBadInput ( ) throws Exception { final String [ ] args = { "--conductor" , BackoffIdleStrategy . class . getName ( ) + "(10,20,30)" } ; opts . parseArgs ( args ) ; } @ Test public void testDataLossGenerator ( ) throws Exception { final String [ ] args = { "--data-loss" , TestLossGenerator . class . getName ( ) } ; opts . parseArgs ( args ) ; assertThat ( opts . dataLossGenerator ( ) , instanceOf ( TestLossGenerator . class ) ) ; } @ Test public void testControlLossGenerator ( ) throws Exception { final String [ ] args = { "--control-loss" , TestLossGenerator . class . getName ( ) } ; opts . parseArgs ( args ) ; assertThat ( opts . controlLossGenerator ( ) , instanceOf ( TestLossGenerator . class ) ) ; } @ Test public void testDataLossGeneratorFromProperties ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final String fileText = "aeron.tools.mediadriver.data.loss=" + TestLossGenerator . class . getName ( ) ; final InputStream inputStream = new ByteArrayInputStream ( fileText . getBytes ( ) ) ; final String [ ] args = { "--properties" , "filename" } ; doReturn ( inputStream ) . when ( spyOpts ) . newFileInputStream ( "filename" ) ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . dataLossGenerator ( ) , instanceOf ( TestLossGenerator . class ) ) ; } @ Test public void testControlLossGeneratorFromProperties ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final String fileText = "aeron.tools.mediadriver.control.loss=" + TestLossGenerator . class . getName ( ) ; final InputStream inputStream = new ByteArrayInputStream ( fileText . getBytes ( ) ) ; final String [ ] args = { "--properties" , "filename" } ; doReturn ( inputStream ) . when ( spyOpts ) . newFileInputStream ( "filename" ) ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . controlLossGenerator ( ) , instanceOf ( TestLossGenerator . class ) ) ; } @ Test public void testDataLossGeneratorCommandLineOverridesProperties ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final String fileText = "aeron.tools.mediadriver.data.loss=null" ; final InputStream inputStream = new ByteArrayInputStream ( fileText . getBytes ( ) ) ; final String [ ] args = { "--properties" , "filename" , "--data-loss" , TestLossGenerator . class . getName ( ) } ; doReturn ( inputStream ) . when ( spyOpts ) . newFileInputStream ( "filename" ) ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . dataLossGenerator ( ) , instanceOf ( TestLossGenerator . class ) ) ; } @ Test public void testControlLossGeneratorCommandLineOverridesProperties ( ) throws Exception { final MediaDriverOptions spyOpts = Mockito . spy ( opts ) ; final String fileText = "aeron.tools.mediadriver.control.loss=null" ; final InputStream inputStream = new ByteArrayInputStream ( fileText . getBytes ( ) ) ; final String [ ] args = { "--properties" , "filename" , "--control-loss" , TestLossGenerator . class . getName ( ) } ; doReturn ( inputStream ) . when ( spyOpts ) . newFileInputStream ( "filename" ) ; spyOpts . parseArgs ( args ) ; assertThat ( spyOpts . controlLossGenerator ( ) , instanceOf ( TestLossGenerator . class ) ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteOrder ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; import static uk . co . real_logic . aeron . protocol . DataHeaderFlyweight . HEADER_LENGTH ; public class FrameDescriptor { public static final int FRAME_ALIGNMENT = 8 ; public static final byte BEGIN_FRAG = ( byte ) 0b1000_0000 ; public static final byte END_FRAG = ( byte ) 0b0100_0000 ; public static final byte UNFRAGMENTED = ( byte ) ( BEGIN_FRAG | END_FRAG ) ; public static final int VERSION_OFFSET = DataHeaderFlyweight . VERSION_FIELD_OFFSET ; public static final int FLAGS_OFFSET = DataHeaderFlyweight . FLAGS_FIELD_OFFSET ; public static final int TYPE_OFFSET = DataHeaderFlyweight . TYPE_FIELD_OFFSET ; public static final int TERM_OFFSET = DataHeaderFlyweight . TERM_OFFSET_FIELD_OFFSET ; public static final int PADDING_FRAME_TYPE = 0 ; public static int computeMaxMessageLength ( final int capacity ) { return capacity / 8 ; } public static void checkHeaderLength ( final int length ) { if ( length != HEADER_LENGTH ) { final String s = String . format ( "Frame header length %d must be equal to %d" , length , HEADER_LENGTH ) ; throw new IllegalStateException ( s ) ; } } public static void checkMaxFrameLength ( final int length ) { if ( ( length & ( FRAME_ALIGNMENT - 1 ) ) != 0 ) { final String s = String . format ( "Max frame length must be a multiple of %d, length=%d" , FRAME_ALIGNMENT , length ) ; throw new IllegalStateException ( s ) ; } } public static int versionOffset ( final int frameOffset ) { return frameOffset + VERSION_OFFSET ; } public static int flagsOffset ( final int frameOffset ) { return frameOffset + FLAGS_OFFSET ; } public static int typeOffset ( final int frameOffset ) { return frameOffset + TYPE_OFFSET ; } public static int termOffsetOffset ( final int frameOffset ) { return frameOffset + TERM_OFFSET ; } public static int frameVersion ( final UnsafeBuffer buffer , final int frameOffset ) { return buffer . getByte ( versionOffset ( frameOffset ) ) ; } public static int frameType ( final UnsafeBuffer buffer , final int frameOffset ) { return buffer . getShort ( typeOffset ( frameOffset ) , LITTLE_ENDIAN ) & 0xFFFF ; } public static boolean isPaddingFrame ( final UnsafeBuffer buffer , final int frameOffset ) { return buffer . getShort ( typeOffset ( frameOffset ) ) == PADDING_FRAME_TYPE ; } public static int frameLength ( final UnsafeBuffer buffer , final int frameOffset ) { return buffer . getInt ( frameOffset , LITTLE_ENDIAN ) ; } public static int frameLengthVolatile ( final UnsafeBuffer buffer , final int frameOffset ) { int frameLength = buffer . getIntVolatile ( frameOffset ) ; if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { frameLength = Integer . reverseBytes ( frameLength ) ; } return frameLength ; } public static void frameLengthOrdered ( final UnsafeBuffer buffer , final int frameOffset , int frameLength ) { if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { frameLength = Integer . reverseBytes ( frameLength ) ; } buffer . putIntOrdered ( frameOffset , frameLength ) ; } public static void frameType ( final UnsafeBuffer buffer , final int frameOffset , final int type ) { buffer . putShort ( typeOffset ( frameOffset ) , ( short ) type , LITTLE_ENDIAN ) ; } public static void frameFlags ( final UnsafeBuffer buffer , final int frameOffset , final byte flags ) { buffer . putByte ( flagsOffset ( frameOffset ) , flags ) ; } public static void frameTermOffset ( final UnsafeBuffer buffer , final int frameOffset , final int termOffset ) { buffer . putInt ( termOffsetOffset ( frameOffset ) , termOffset , LITTLE_ENDIAN ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import uk . co . real_logic . agrona . DirectBuffer ; @ FunctionalInterface public interface FragmentHandler { void onFragment ( DirectBuffer buffer , int offset , int length , Header header ) ; }
package uk . co . real_logic . aeron . logbuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . FRAME_ALIGNMENT ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . frameLengthVolatile ; import static uk . co . real_logic . aeron . protocol . DataHeaderFlyweight . HEADER_LENGTH ; import static uk . co . real_logic . agrona . BitUtil . align ; public class TermGapScanner { @ FunctionalInterface public interface GapHandler { void onGap ( final int termId , UnsafeBuffer buffer , int offset , int length ) ; } public static int scanForGap ( final UnsafeBuffer termBuffer , final int termId , int rebuildOffset , final int hwmOffset , final GapHandler handler ) { do { final int frameLength = frameLengthVolatile ( termBuffer , rebuildOffset ) ; if ( frameLength <= 0 ) { break ; } rebuildOffset += align ( frameLength , FRAME_ALIGNMENT ) ; } while ( rebuildOffset < hwmOffset ) ; final int gapBeginOffset = rebuildOffset ; if ( rebuildOffset < hwmOffset ) { final int limit = hwmOffset - HEADER_LENGTH ; while ( rebuildOffset < limit ) { rebuildOffset += FRAME_ALIGNMENT ; if ( 0 != termBuffer . getIntVolatile ( rebuildOffset ) ) { rebuildOffset -= HEADER_LENGTH ; break ; } } final int gapLength = ( rebuildOffset - gapBeginOffset ) + HEADER_LENGTH ; handler . onGap ( termId , termBuffer , gapBeginOffset , gapLength ) ; } return gapBeginOffset ; } }
package uk . co . real_logic . aeron . logbuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . frameLengthOrdered ; public class TermRebuilder { public static void insert ( final UnsafeBuffer termBuffer , final int termOffset , final UnsafeBuffer packet , final int length ) { final int firstFrameLength = packet . getInt ( 0 , LITTLE_ENDIAN ) ; packet . putIntOrdered ( 0 , 0 ) ; termBuffer . putBytes ( termOffset , packet , 0 , length ) ; frameLengthOrdered ( termBuffer , termOffset , firstFrameLength ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . FRAME_ALIGNMENT ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . frameLengthVolatile ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . isPaddingFrame ; import static uk . co . real_logic . aeron . protocol . DataHeaderFlyweight . HEADER_LENGTH ; import static uk . co . real_logic . agrona . BitUtil . align ; public final class TermScanner { public static long scanForAvailability ( final UnsafeBuffer termBuffer , final int offset , int maxLength ) { maxLength = Math . min ( maxLength , termBuffer . capacity ( ) - offset ) ; int available = 0 ; int padding = 0 ; do { final int frameOffset = offset + available ; final int frameLength = frameLengthVolatile ( termBuffer , frameOffset ) ; if ( frameLength <= 0 ) { break ; } int alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; if ( isPaddingFrame ( termBuffer , frameOffset ) ) { padding = alignedFrameLength - HEADER_LENGTH ; alignedFrameLength = HEADER_LENGTH ; } available += alignedFrameLength ; if ( available > maxLength ) { available -= alignedFrameLength ; padding = 0 ; break ; } } while ( ( available + padding ) < maxLength ) ; return scanOutcome ( padding , available ) ; } public static long scanOutcome ( final int padding , final int available ) { return ( ( long ) padding < < 32 ) | available ; } public static int available ( final long scanOutcome ) { return ( int ) scanOutcome ; } public static int padding ( final long scanOutcome ) { return ( int ) ( scanOutcome > > > 32 ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . UnsafeAccess ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteOrder ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . * ; import static uk . co . real_logic . aeron . protocol . DataHeaderFlyweight . HEADER_LENGTH ; import static uk . co . real_logic . agrona . BitUtil . * ; public class TermAppender extends LogBufferPartition { public static final int TRIPPED = - 1 ; public static final int FAILED = - 2 ; private final int maxMessageLength ; private final int maxFrameLength ; private final int maxPayloadLength ; private final MutableDirectBuffer defaultHeader ; public TermAppender ( final UnsafeBuffer termBuffer , final UnsafeBuffer metaDataBuffer , final MutableDirectBuffer defaultHeader , final int maxFrameLength ) { super ( termBuffer , metaDataBuffer ) ; checkHeaderLength ( defaultHeader . capacity ( ) ) ; checkMaxFrameLength ( maxFrameLength ) ; termBuffer . verifyAlignment ( ) ; metaDataBuffer . verifyAlignment ( ) ; this . defaultHeader = defaultHeader ; this . maxFrameLength = maxFrameLength ; this . maxMessageLength = FrameDescriptor . computeMaxMessageLength ( termBuffer . capacity ( ) ) ; this . maxPayloadLength = maxFrameLength - HEADER_LENGTH ; } public int maxMessageLength ( ) { return maxMessageLength ; } public int maxPayloadLength ( ) { return maxPayloadLength ; } public int maxFrameLength ( ) { return maxFrameLength ; } public int append ( final DirectBuffer srcBuffer , final int srcOffset , final int length ) { final int resultingOffset ; if ( length <= maxPayloadLength ) { resultingOffset = appendUnfragmentedMessage ( srcBuffer , srcOffset , length ) ; } else { if ( length > maxMessageLength ) { throw new IllegalArgumentException ( String . format ( "Encoded message exceeds maxMessageLength of %d, length=%d" , maxMessageLength , length ) ) ; } resultingOffset = appendFragmentedMessage ( srcBuffer , srcOffset , length ) ; } return resultingOffset ; } public int claim ( final int length , final BufferClaim bufferClaim ) { if ( length > maxPayloadLength ) { throw new IllegalArgumentException ( String . format ( "Claim exceeds maxPayloadLength of %d, length=%d" , maxPayloadLength , length ) ) ; } final int frameLength = length + HEADER_LENGTH ; final int alignedLength = align ( frameLength , FRAME_ALIGNMENT ) ; final int frameOffset = metaDataBuffer ( ) . getAndAddInt ( LogBufferDescriptor . TERM_TAIL_COUNTER_OFFSET , alignedLength ) ; final UnsafeBuffer termBuffer = termBuffer ( ) ; final int resultingOffset = computeResultingOffset ( termBuffer , frameOffset , alignedLength , termBuffer . capacity ( ) ) ; if ( resultingOffset > 0 ) { applyDefaultHeader ( termBuffer , frameOffset , frameLength , defaultHeader ) ; frameTermOffset ( termBuffer , frameOffset , frameOffset ) ; bufferClaim . wrap ( termBuffer , frameOffset , frameLength ) ; } return resultingOffset ; } private int appendUnfragmentedMessage ( final DirectBuffer srcBuffer , final int srcOffset , final int length ) { final int frameLength = length + HEADER_LENGTH ; final int alignedLength = align ( frameLength , FRAME_ALIGNMENT ) ; final int frameOffset = metaDataBuffer ( ) . getAndAddInt ( LogBufferDescriptor . TERM_TAIL_COUNTER_OFFSET , alignedLength ) ; final UnsafeBuffer termBuffer = termBuffer ( ) ; final int resultingOffset = computeResultingOffset ( termBuffer , frameOffset , alignedLength , termBuffer . capacity ( ) ) ; if ( resultingOffset > 0 ) { applyDefaultHeader ( termBuffer , frameOffset , frameLength , defaultHeader ) ; termBuffer . putBytes ( frameOffset + HEADER_LENGTH , srcBuffer , srcOffset , length ) ; frameTermOffset ( termBuffer , frameOffset , frameOffset ) ; frameLengthOrdered ( termBuffer , frameOffset , frameLength ) ; } return resultingOffset ; } private int appendFragmentedMessage ( final DirectBuffer srcBuffer , final int srcOffset , final int length ) { final int numMaxPayloads = length / maxPayloadLength ; final int remainingPayload = length % maxPayloadLength ; final int lastFrameLength = ( remainingPayload > 0 ) ? align ( remainingPayload + HEADER_LENGTH , FRAME_ALIGNMENT ) : 0 ; final int requiredLength = ( numMaxPayloads * maxFrameLength ) + lastFrameLength ; int frameOffset = metaDataBuffer ( ) . getAndAddInt ( LogBufferDescriptor . TERM_TAIL_COUNTER_OFFSET , requiredLength ) ; final UnsafeBuffer termBuffer = termBuffer ( ) ; final int resultingOffset = computeResultingOffset ( termBuffer , frameOffset , requiredLength , termBuffer . capacity ( ) ) ; if ( resultingOffset > 0 ) { byte flags = BEGIN_FRAG ; int remaining = length ; do { final int bytesToWrite = Math . min ( remaining , maxPayloadLength ) ; final int frameLength = bytesToWrite + HEADER_LENGTH ; final int alignedLength = align ( frameLength , FRAME_ALIGNMENT ) ; applyDefaultHeader ( termBuffer , frameOffset , frameLength , defaultHeader ) ; termBuffer . putBytes ( frameOffset + HEADER_LENGTH , srcBuffer , srcOffset + ( length - remaining ) , bytesToWrite ) ; if ( remaining <= maxPayloadLength ) { flags |= END_FRAG ; } frameFlags ( termBuffer , frameOffset , flags ) ; frameTermOffset ( termBuffer , frameOffset , frameOffset ) ; frameLengthOrdered ( termBuffer , frameOffset , frameLength ) ; flags = 0 ; frameOffset += alignedLength ; remaining -= bytesToWrite ; } while ( remaining > 0 ) ; } return resultingOffset ; } private int computeResultingOffset ( final UnsafeBuffer termBuffer , final int frameOffset , final int length , final int capacity ) { int resultingOffset = frameOffset + length ; if ( resultingOffset > ( capacity - HEADER_LENGTH ) ) { resultingOffset = FAILED ; if ( frameOffset <= ( capacity - HEADER_LENGTH ) ) { final int frameLength = capacity - frameOffset ; applyDefaultHeader ( termBuffer , frameOffset , frameLength , defaultHeader ) ; frameType ( termBuffer , frameOffset , PADDING_FRAME_TYPE ) ; frameTermOffset ( termBuffer , frameOffset , frameOffset ) ; frameLengthOrdered ( termBuffer , frameOffset , frameLength ) ; resultingOffset = TRIPPED ; } } return resultingOffset ; } private static void applyDefaultHeader ( final UnsafeBuffer buffer , final int frameOffset , final int frameLength , final MutableDirectBuffer defaultHeaderBuffer ) { buffer . putInt ( frameOffset , - frameLength , ByteOrder . LITTLE_ENDIAN ) ; UnsafeAccess . UNSAFE . storeFence ( ) ; int headerOffset = SIZE_OF_INT ; buffer . putInt ( frameOffset + headerOffset , defaultHeaderBuffer . getInt ( headerOffset ) ) ; headerOffset += SIZE_OF_INT ; buffer . putLong ( frameOffset + headerOffset , defaultHeaderBuffer . getLong ( headerOffset ) ) ; headerOffset += SIZE_OF_LONG ; buffer . putLong ( frameOffset + headerOffset , defaultHeaderBuffer . getLong ( headerOffset ) ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import uk . co . real_logic . agrona . DirectBuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . FRAME_ALIGNMENT ; import static uk . co . real_logic . aeron . protocol . DataHeaderFlyweight . HEADER_LENGTH ; import static uk . co . real_logic . aeron . protocol . DataHeaderFlyweight . TERM_ID_FIELD_OFFSET ; import static uk . co . real_logic . agrona . BitUtil . CACHE_LINE_LENGTH ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_INT ; public class LogBufferDescriptor { public static final int PARTITION_COUNT = 3 ; public static final int TERM_MIN_LENGTH = 64 * 1024 ; public static final int CLEAN = 0 ; public static final int NEEDS_CLEANING = 1 ; public static final int TERM_TAIL_COUNTER_OFFSET ; public static final int TERM_STATUS_OFFSET ; public static final int TERM_META_DATA_LENGTH ; static { int offset = ( CACHE_LINE_LENGTH * 2 ) ; TERM_TAIL_COUNTER_OFFSET = offset ; offset += ( CACHE_LINE_LENGTH * 2 ) ; TERM_STATUS_OFFSET = offset ; offset += ( CACHE_LINE_LENGTH * 2 ) ; TERM_META_DATA_LENGTH = offset ; } public static final int LOG_META_DATA_SECTION_INDEX = PARTITION_COUNT * 2 ; public static final int LOG_ACTIVE_TERM_ID_OFFSET ; public static final int LOG_INITIAL_TERM_ID_OFFSET ; public static final int LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET ; public static final int LOG_MTU_LENGTH_OFFSET ; public static final int LOG_DEFAULT_FRAME_HEADERS_OFFSET ; public static final int LOG_DEFAULT_FRAME_HEADER_MAX_LENGTH = CACHE_LINE_LENGTH * 2 ; static { int offset = 0 ; LOG_ACTIVE_TERM_ID_OFFSET = offset ; offset += ( CACHE_LINE_LENGTH * 2 ) ; LOG_INITIAL_TERM_ID_OFFSET = offset ; LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET = LOG_INITIAL_TERM_ID_OFFSET + SIZE_OF_INT ; LOG_MTU_LENGTH_OFFSET = LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET + SIZE_OF_INT ; offset += ( CACHE_LINE_LENGTH * 2 ) ; LOG_DEFAULT_FRAME_HEADERS_OFFSET = offset ; LOG_META_DATA_LENGTH = offset + ( LOG_DEFAULT_FRAME_HEADER_MAX_LENGTH * 3 ) ; } public static final int LOG_META_DATA_LENGTH ; public static void checkTermBuffer ( final UnsafeBuffer buffer ) { final int capacity = buffer . capacity ( ) ; if ( capacity < TERM_MIN_LENGTH ) { final String s = String . format ( "Term buffer capacity less than min length of %d, capacity=%d" , TERM_MIN_LENGTH , capacity ) ; throw new IllegalStateException ( s ) ; } if ( ( capacity & ( FRAME_ALIGNMENT - 1 ) ) != 0 ) { final String s = String . format ( "Term buffer capacity not a multiple of %d, capacity=%d" , FRAME_ALIGNMENT , capacity ) ; throw new IllegalStateException ( s ) ; } } public static void checkMetaDataBuffer ( final UnsafeBuffer buffer ) { final int capacity = buffer . capacity ( ) ; if ( capacity < TERM_META_DATA_LENGTH ) { final String s = String . format ( "Meta data buffer capacity less than min length of %d, capacity=%d" , TERM_META_DATA_LENGTH , capacity ) ; throw new IllegalStateException ( s ) ; } } public static int initialTermId ( final UnsafeBuffer logMetaDataBuffer ) { return logMetaDataBuffer . getInt ( LOG_INITIAL_TERM_ID_OFFSET ) ; } public static void initialTermId ( final UnsafeBuffer logMetaDataBuffer , final int initialTermId ) { logMetaDataBuffer . putInt ( LOG_INITIAL_TERM_ID_OFFSET , initialTermId ) ; } public static int mtuLength ( final UnsafeBuffer logMetaDataBuffer ) { return logMetaDataBuffer . getInt ( LOG_MTU_LENGTH_OFFSET ) ; } public static void mtuLength ( final UnsafeBuffer logMetaDaraBuffer , final int mtuLength ) { logMetaDaraBuffer . putInt ( LOG_MTU_LENGTH_OFFSET , mtuLength ) ; } public static int activeTermId ( final UnsafeBuffer logMetaDataBuffer ) { return logMetaDataBuffer . getIntVolatile ( LOG_ACTIVE_TERM_ID_OFFSET ) ; } public static void activeTermId ( final UnsafeBuffer logMetaDataBuffer , final int activeTermId ) { logMetaDataBuffer . putIntOrdered ( LOG_ACTIVE_TERM_ID_OFFSET , activeTermId ) ; } public static int nextPartitionIndex ( final int currentIndex ) { return ( currentIndex + 1 ) % PARTITION_COUNT ; } public static int previousPartitionIndex ( final int currentIndex ) { return ( currentIndex + ( PARTITION_COUNT - 1 ) ) % PARTITION_COUNT ; } public static int indexByTerm ( final int initialTermId , final int activeTermId ) { return ( activeTermId - initialTermId ) % PARTITION_COUNT ; } public static int indexByTermCount ( final int termCount ) { return termCount % PARTITION_COUNT ; } public static int indexByPosition ( final long position , final int positionBitsToShift ) { return ( int ) ( ( position > > > positionBitsToShift ) % PARTITION_COUNT ) ; } public static long computePosition ( final int activeTermId , final int termOffset , final int positionBitsToShift , final int initialTermId ) { final long termCount = activeTermId - initialTermId ; return ( termCount < < positionBitsToShift ) + termOffset ; } public static int computeTermIdFromPosition ( final long position , final int positionBitsToShift , final int initialTermId ) { return ( ( int ) ( position > > > positionBitsToShift ) + initialTermId ) ; } public static int computeTermOffsetFromPosition ( final long position , final int positionBitsToShift ) { final long mask = ( 1L < < positionBitsToShift ) - 1L ; return ( int ) ( position & mask ) ; } public static long computeLogLength ( final int termLength ) { return ( termLength * PARTITION_COUNT ) + ( TERM_META_DATA_LENGTH * PARTITION_COUNT ) + LOG_META_DATA_LENGTH ; } public static int computeTermLength ( final long logLength ) { final long metaDataSectionLength = ( TERM_META_DATA_LENGTH * ( long ) PARTITION_COUNT ) + LOG_META_DATA_LENGTH ; return ( int ) ( ( logLength - metaDataSectionLength ) / 3 ) ; } public static void storeDefaultFrameHeaders ( final UnsafeBuffer logMetaDataBuffer , final DirectBuffer defaultHeader ) { if ( defaultHeader . capacity ( ) != HEADER_LENGTH ) { throw new IllegalArgumentException ( String . format ( "Default header of %d not equal to %d" , defaultHeader . capacity ( ) , HEADER_LENGTH ) ) ; } logMetaDataBuffer . putInt ( LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET , HEADER_LENGTH ) ; for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { final int offset = LOG_DEFAULT_FRAME_HEADERS_OFFSET + ( i * LOG_DEFAULT_FRAME_HEADER_MAX_LENGTH ) ; logMetaDataBuffer . putBytes ( offset , defaultHeader , 0 , HEADER_LENGTH ) ; } } public static UnsafeBuffer [ ] defaultFrameHeaders ( final UnsafeBuffer logMetaDataBuffer ) { final UnsafeBuffer [ ] defaultFrameHeaders = new UnsafeBuffer [ PARTITION_COUNT ] ; for ( int i = 0 ; i < PARTITION_COUNT ; i ++ ) { final int offset = LOG_DEFAULT_FRAME_HEADERS_OFFSET + ( i * LOG_DEFAULT_FRAME_HEADER_MAX_LENGTH ) ; defaultFrameHeaders [ i ] = new UnsafeBuffer ( logMetaDataBuffer , offset , HEADER_LENGTH ) ; } return defaultFrameHeaders ; } public static void defaultHeaderTermId ( final UnsafeBuffer logMetaDataBuffer , final int partitionIndex , final int termId ) { final int headerOffset = LOG_DEFAULT_FRAME_HEADERS_OFFSET + ( partitionIndex * LOG_DEFAULT_FRAME_HEADER_MAX_LENGTH ) ; logMetaDataBuffer . putInt ( headerOffset + TERM_ID_FIELD_OFFSET , termId , LITTLE_ENDIAN ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteOrder ; public class Header { private int positionBitsToShift ; private int initialTermId ; private int offset = 0 ; private UnsafeBuffer buffer ; protected Header ( ) { } public Header ( final int initialTermId , final int termCapacity ) { this . initialTermId = initialTermId ; this . positionBitsToShift = Integer . numberOfTrailingZeros ( termCapacity ) ; } public final long position ( ) { return LogBufferDescriptor . computePosition ( termId ( ) , termOffset ( ) + frameLength ( ) , positionBitsToShift , initialTermId ) ; } public final int positionBitsToShift ( ) { return positionBitsToShift ; } public final void positionBitsToShift ( final int positionBitsToShift ) { this . positionBitsToShift = positionBitsToShift ; } public final int initialTermId ( ) { return initialTermId ; } public final void initialTermId ( final int initialTermId ) { this . initialTermId = initialTermId ; } public final void offset ( final int offset ) { this . offset = offset ; } public final int offset ( ) { return offset ; } public final UnsafeBuffer buffer ( ) { return buffer ; } public final void buffer ( final UnsafeBuffer buffer ) { this . buffer = buffer ; } public int frameLength ( ) { return buffer . getInt ( offset , ByteOrder . LITTLE_ENDIAN ) ; } public final int sessionId ( ) { return buffer . getInt ( offset + DataHeaderFlyweight . SESSION_ID_FIELD_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public final int streamId ( ) { return buffer . getInt ( offset + DataHeaderFlyweight . STREAM_ID_FIELD_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public final int termId ( ) { return buffer . getInt ( offset + DataHeaderFlyweight . TERM_ID_FIELD_OFFSET , ByteOrder . LITTLE_ENDIAN ) ; } public int termOffset ( ) { return offset ; } public final int type ( ) { return buffer . getShort ( offset + DataHeaderFlyweight . TYPE_FIELD_OFFSET , ByteOrder . LITTLE_ENDIAN ) & 0xFFFF ; } public byte flags ( ) { return buffer . getByte ( offset + DataHeaderFlyweight . FLAGS_FIELD_OFFSET ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . * ; import static uk . co . real_logic . aeron . logbuffer . LogBufferDescriptor . TERM_TAIL_COUNTER_OFFSET ; public class LogBufferPartition { private final UnsafeBuffer termBuffer ; private final UnsafeBuffer metaDataBuffer ; public LogBufferPartition ( final UnsafeBuffer termBuffer , final UnsafeBuffer metaDataBuffer ) { checkTermBuffer ( termBuffer ) ; checkMetaDataBuffer ( metaDataBuffer ) ; termBuffer . verifyAlignment ( ) ; metaDataBuffer . verifyAlignment ( ) ; this . termBuffer = termBuffer ; this . metaDataBuffer = metaDataBuffer ; } public UnsafeBuffer termBuffer ( ) { return termBuffer ; } public UnsafeBuffer metaDataBuffer ( ) { return metaDataBuffer ; } public void clean ( ) { termBuffer . setMemory ( 0 , termBuffer . capacity ( ) , ( byte ) 0 ) ; metaDataBuffer . putInt ( TERM_TAIL_COUNTER_OFFSET , 0 ) ; metaDataBuffer . putIntOrdered ( TERM_STATUS_OFFSET , CLEAN ) ; } public int status ( ) { return metaDataBuffer . getIntVolatile ( TERM_STATUS_OFFSET ) ; } public void statusOrdered ( final int status ) { metaDataBuffer . putIntOrdered ( TERM_STATUS_OFFSET , status ) ; } public int tailVolatile ( ) { return Math . min ( metaDataBuffer . getIntVolatile ( TERM_TAIL_COUNTER_OFFSET ) , termBuffer . capacity ( ) ) ; } public int rawTailVolatile ( ) { return metaDataBuffer . getIntVolatile ( TERM_TAIL_COUNTER_OFFSET ) ; } public int tail ( ) { return Math . min ( metaDataBuffer . getInt ( TERM_TAIL_COUNTER_OFFSET ) , termBuffer . capacity ( ) ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import uk . co . real_logic . agrona . BitUtil ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . util . function . Consumer ; import static uk . co . real_logic . aeron . logbuffer . FrameDescriptor . * ; import static uk . co . real_logic . aeron . protocol . DataHeaderFlyweight . HEADER_LENGTH ; public class TermReader { public static long read ( final UnsafeBuffer termBuffer , int termOffset , final FragmentHandler handler , final int fragmentsLimit , final Header header , final Consumer < Throwable > errorHandler ) { int fragmentsRead = 0 ; final int capacity = termBuffer . capacity ( ) ; try { do { final int frameLength = frameLengthVolatile ( termBuffer , termOffset ) ; if ( frameLength <= 0 ) { break ; } final int fragmentOffset = termOffset ; termOffset += BitUtil . align ( frameLength , FRAME_ALIGNMENT ) ; if ( ! isPaddingFrame ( termBuffer , fragmentOffset ) ) { header . buffer ( termBuffer ) ; header . offset ( fragmentOffset ) ; handler . onFragment ( termBuffer , fragmentOffset + HEADER_LENGTH , frameLength - HEADER_LENGTH , header ) ; ++ fragmentsRead ; } } while ( fragmentsRead < fragmentsLimit && termOffset < capacity ) ; } catch ( final Exception ex ) { errorHandler . accept ( ex ) ; } return readOutcome ( termOffset , fragmentsRead ) ; } public static long readOutcome ( final int offset , final int fragmentsRead ) { return ( ( long ) offset < < 32 ) | fragmentsRead ; } public static int fragmentsRead ( final long readOutcome ) { return ( int ) readOutcome ; } public static int offset ( final long readOutcome ) { return ( int ) ( readOutcome > > > 32 ) ; } }
package uk . co . real_logic . aeron . tools ; import org . junit . Test ; import static org . hamcrest . CoreMatchers . both ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; import static org . hamcrest . core . Is . is ; public class MessageSizePatternTest { MessageSizePattern p ; @ Test public void createWithMessageSize ( ) throws Exception { p = new MessageSizePattern ( 1000 ) ; assertThat ( "FAIL: getNext() didn't return correct value" , p . getNext ( ) , is ( 1000 ) ) ; } @ Test public void createWithMessageCountAndSize ( ) throws Exception { p = new MessageSizePattern ( 200 , 1000 ) ; assertThat ( "FAIL: getNext() didn't return correct value" , p . getNext ( ) , is ( 1000 ) ) ; } @ Test public void createWithMessageCountAndRange ( ) throws Exception { p = new MessageSizePattern ( 200 , 1000 , 1001 ) ; assertThat ( "FAIL: getNext() returned unexpected value" , p . getNext ( ) , both ( greaterThanOrEqualTo ( 1000 ) ) . and ( lessThanOrEqualTo ( 1001 ) ) ) ; } @ Test public void copyConstructor ( ) throws Exception { p = new MessageSizePattern ( 1 , 1000 ) ; p . addPatternEntry ( 1 , 1001 , 1002 ) ; assertThat ( p . getNext ( ) , is ( 1000 ) ) ; final MessageSizePattern p2 = new MessageSizePattern ( p ) ; assertThat ( "FAIL: Copied pattern didn't start at the beginning" , p2 . getNext ( ) , is ( 1000 ) ) ; assertThat ( p . getNext ( ) , both ( greaterThanOrEqualTo ( 1001 ) ) . and ( lessThanOrEqualTo ( 1002 ) ) ) ; assertThat ( p2 . getNext ( ) , both ( greaterThanOrEqualTo ( 1001 ) ) . and ( lessThanOrEqualTo ( 1002 ) ) ) ; } @ Test public void addSizeEntry ( ) throws Exception { p = new MessageSizePattern ( 1 , 1000 ) ; p . addPatternEntry ( 1 , 2000 ) ; p . getNext ( ) ; assertThat ( "FAIL: 2nd call to getNext() returned unexpected value" , p . getNext ( ) , is ( 2000 ) ) ; } @ Test public void addRangedEntry ( ) throws Exception { p = new MessageSizePattern ( 1 , 1000 ) ; p . addPatternEntry ( 1 , 1001 , 1002 ) ; p . getNext ( ) ; assertThat ( "FAIL: 2nd call to getNext() returned out of range value" , p . getNext ( ) , both ( greaterThanOrEqualTo ( 1001 ) ) . and ( lessThanOrEqualTo ( 1002 ) ) ) ; } @ Test public void repeatPattern ( ) throws Exception { p = new MessageSizePattern ( 1 , 1000 ) ; p . addPatternEntry ( 1 , 2000 ) ; p . addPatternEntry ( 1 , 3000 ) ; assertThat ( p . getNext ( ) , is ( 1000 ) ) ; assertThat ( p . getNext ( ) , is ( 2000 ) ) ; assertThat ( p . getNext ( ) , is ( 3000 ) ) ; assertThat ( "FAIL: Pattern did not wrap." , p . getNext ( ) , is ( 1000 ) ) ; assertThat ( p . getNext ( ) , is ( 2000 ) ) ; assertThat ( p . getNext ( ) , is ( 3000 ) ) ; } @ Test public void checkPatternMinMax ( ) throws Exception { p = new MessageSizePattern ( 1 , 1000 ) ; p . addPatternEntry ( 1 , 500 ) ; p . addPatternEntry ( 1 , 1500 ) ; assertThat ( "FAIL: Pattern minimum value is wrong" , p . minimum ( ) , is ( 500 ) ) ; assertThat ( "FAIL: Pattern maximum value is wrong" , p . maximum ( ) , is ( 1500 ) ) ; } @ Test public void checkCurrentRangeMinMax ( ) throws Exception { p = new MessageSizePattern ( 1 , 1000 , 2000 ) ; p . addPatternEntry ( 1 , 2000 , 3000 ) ; assertThat ( "FAIL: Pattern minimum value is wrong" , p . minimum ( ) , is ( 1000 ) ) ; assertThat ( "FAIL: Pattern maximum value is wrong" , p . maximum ( ) , is ( 3000 ) ) ; p . getNext ( ) ; assertThat ( p . currentRangeMinimum ( ) , is ( 1000 ) ) ; assertThat ( p . currentRangeMaximum ( ) , is ( 2000 ) ) ; p . getNext ( ) ; assertThat ( p . currentRangeMinimum ( ) , is ( 2000 ) ) ; assertThat ( p . currentRangeMaximum ( ) , is ( 3000 ) ) ; } @ Test public void reset ( ) throws Exception { p = new MessageSizePattern ( 1 , 1000 ) ; p . addPatternEntry ( 1 , 2000 ) ; p . getNext ( ) ; p . reset ( ) ; assertThat ( "FAIL: reset did not go back to the beginning of the pattern" , p . getNext ( ) , is ( 1000 ) ) ; } @ Test ( expected = Exception . class ) public void invalidSize ( ) throws Exception { p = new MessageSizePattern ( - 10 ) ; } @ Test ( expected = Exception . class ) public void invalidNumberOfMessages ( ) throws Exception { p = new MessageSizePattern ( 0 , 1000 ) ; } @ Test ( expected = Exception . class ) public void negativeRange ( ) throws Exception { p = new MessageSizePattern ( 1 , - 1000 , - 500 ) ; } @ Test ( expected = Exception . class ) public void invalidRange ( ) throws Exception { p = new MessageSizePattern ( 1 , 1000 , 500 ) ; } }
package uk . co . real_logic . aeron . logbuffer ; import uk . co . real_logic . aeron . protocol . DataHeaderFlyweight ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . concurrent . AtomicBuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; public class BufferClaim { private final UnsafeBuffer buffer = new UnsafeBuffer ( 0 , 0 ) ; public void wrap ( final AtomicBuffer buffer , final int offset , final int length ) { this . buffer . wrap ( buffer , offset , length ) ; } public MutableDirectBuffer buffer ( ) { return buffer ; } public int offset ( ) { return DataHeaderFlyweight . HEADER_LENGTH ; } public int length ( ) { return buffer . capacity ( ) - DataHeaderFlyweight . HEADER_LENGTH ; } public void commit ( ) { buffer . putIntOrdered ( 0 , buffer . capacity ( ) ) ; } }
package uk . co . real_logic . aeron . exceptions ; import uk . co . real_logic . aeron . ErrorCode ; public class RegistrationException extends RuntimeException { private final ErrorCode code ; public RegistrationException ( final ErrorCode code , final String msg ) { super ( msg ) ; this . code = code ; } public ErrorCode errorCode ( ) { return code ; } }
package uk . co . real_logic . aeron . exceptions ; public class DriverTimeoutException extends RuntimeException { public DriverTimeoutException ( final String message ) { super ( message ) ; } }
package uk . co . real_logic . aeron . protocol ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; public class SetupFlyweight extends HeaderFlyweight { public static final int HEADER_LENGTH = 36 ; private static final int TERM_OFFSET_FIELD_OFFSET = 8 ; private static final int SESSION_ID_FIELD_OFFSET = 12 ; private static final int STREAM_ID_FIELD_OFFSET = 16 ; private static final int INITIAL_TERM_ID_FIELD_OFFSET = 20 ; private static final int ACTIVE_TERM_ID_FIELD_OFFSET = 24 ; private static final int TERM_LENGTH_FIELD_OFFSET = 28 ; private static final int MTU_LENGTH_FIELD_OFFSET = 32 ; public int termOffset ( ) { return buffer ( ) . getInt ( offset ( ) + TERM_OFFSET_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public SetupFlyweight termOffset ( final int termOffset ) { buffer ( ) . putInt ( offset ( ) + TERM_OFFSET_FIELD_OFFSET , termOffset , LITTLE_ENDIAN ) ; return this ; } public int sessionId ( ) { return buffer ( ) . getInt ( offset ( ) + SESSION_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public SetupFlyweight sessionId ( final int sessionId ) { buffer ( ) . putInt ( offset ( ) + SESSION_ID_FIELD_OFFSET , sessionId , LITTLE_ENDIAN ) ; return this ; } public int streamId ( ) { return buffer ( ) . getInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public SetupFlyweight streamId ( final int streamId ) { buffer ( ) . putInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , streamId , LITTLE_ENDIAN ) ; return this ; } public int initialTermId ( ) { return buffer ( ) . getInt ( offset ( ) + INITIAL_TERM_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public SetupFlyweight initialTermId ( final int termId ) { buffer ( ) . putInt ( offset ( ) + INITIAL_TERM_ID_FIELD_OFFSET , termId , LITTLE_ENDIAN ) ; return this ; } public int activeTermId ( ) { return buffer ( ) . getInt ( offset ( ) + ACTIVE_TERM_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public SetupFlyweight activeTermId ( final int termId ) { buffer ( ) . putInt ( offset ( ) + ACTIVE_TERM_ID_FIELD_OFFSET , termId , LITTLE_ENDIAN ) ; return this ; } public int termLength ( ) { return buffer ( ) . getInt ( offset ( ) + TERM_LENGTH_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public SetupFlyweight termLength ( final int termLength ) { buffer ( ) . putInt ( offset ( ) + TERM_LENGTH_FIELD_OFFSET , termLength , LITTLE_ENDIAN ) ; return this ; } public int mtuLength ( ) { return buffer ( ) . getInt ( offset ( ) + MTU_LENGTH_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public SetupFlyweight mtuLength ( final int mtuLength ) { buffer ( ) . putInt ( offset ( ) + MTU_LENGTH_FIELD_OFFSET , mtuLength , LITTLE_ENDIAN ) ; return this ; } }
package uk . co . real_logic . aeron . protocol ; import uk . co . real_logic . aeron . Flyweight ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_SHORT ; public class HeaderFlyweight extends Flyweight { public static final int HDR_TYPE_PAD = 0x00 ; public static final int HDR_TYPE_DATA = 0x01 ; public static final int HDR_TYPE_NAK = 0x02 ; public static final int HDR_TYPE_SM = 0x03 ; public static final int HDR_TYPE_ERR = 0x04 ; public static final int HDR_TYPE_SETUP = 0x05 ; public static final int HDR_TYPE_EXT = 0xFFFF ; public static final byte CURRENT_VERSION = 0x0 ; public static final int FRAME_LENGTH_FIELD_OFFSET = 0 ; public static final int VERSION_FIELD_OFFSET = 4 ; public static final int FLAGS_FIELD_OFFSET = 5 ; public static final int TYPE_FIELD_OFFSET = 6 ; public static final int HEADER_LENGTH = TYPE_FIELD_OFFSET + SIZE_OF_SHORT ; public short version ( ) { return uint8Get ( offset ( ) + VERSION_FIELD_OFFSET ) ; } public HeaderFlyweight version ( final short ver ) { uint8Put ( offset ( ) + VERSION_FIELD_OFFSET , ver ) ; return this ; } public short flags ( ) { return uint8Get ( offset ( ) + FLAGS_FIELD_OFFSET ) ; } public HeaderFlyweight flags ( final short flags ) { uint8Put ( offset ( ) + FLAGS_FIELD_OFFSET , flags ) ; return this ; } public int headerType ( ) { return uint16Get ( offset ( ) + TYPE_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public HeaderFlyweight headerType ( final int type ) { uint16Put ( offset ( ) + TYPE_FIELD_OFFSET , ( short ) type , LITTLE_ENDIAN ) ; return this ; } public int frameLength ( ) { return buffer ( ) . getInt ( offset ( ) + FRAME_LENGTH_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public HeaderFlyweight frameLength ( final int length ) { buffer ( ) . putInt ( offset ( ) + FRAME_LENGTH_FIELD_OFFSET , length , LITTLE_ENDIAN ) ; return this ; } }
package uk . co . real_logic . aeron . protocol ; import uk . co . real_logic . agrona . MutableDirectBuffer ; import uk . co . real_logic . agrona . concurrent . UnsafeBuffer ; import java . nio . ByteOrder ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; public class DataHeaderFlyweight extends HeaderFlyweight { public static final int HEADER_LENGTH = 24 ; public static final short BEGIN_FLAG = 0x80 ; public static final short END_FLAG = 0x40 ; public static final short BEGIN_AND_END_FLAGS = BEGIN_FLAG | END_FLAG ; public static final int TERM_OFFSET_FIELD_OFFSET = 8 ; public static final int SESSION_ID_FIELD_OFFSET = 12 ; public static final int STREAM_ID_FIELD_OFFSET = 16 ; public static final int TERM_ID_FIELD_OFFSET = 20 ; public static final int DATA_OFFSET = 24 ; public int sessionId ( ) { return buffer ( ) . getInt ( offset ( ) + SESSION_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public DataHeaderFlyweight sessionId ( final int sessionId ) { buffer ( ) . putInt ( offset ( ) + SESSION_ID_FIELD_OFFSET , sessionId , LITTLE_ENDIAN ) ; return this ; } public int streamId ( ) { return buffer ( ) . getInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public DataHeaderFlyweight streamId ( final int streamId ) { buffer ( ) . putInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , streamId , LITTLE_ENDIAN ) ; return this ; } public int termId ( ) { return buffer ( ) . getInt ( offset ( ) + TERM_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public DataHeaderFlyweight termId ( final int termId ) { buffer ( ) . putInt ( offset ( ) + TERM_ID_FIELD_OFFSET , termId , LITTLE_ENDIAN ) ; return this ; } public int termOffset ( ) { return buffer ( ) . getInt ( offset ( ) + TERM_OFFSET_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public DataHeaderFlyweight termOffset ( final int termOffset ) { buffer ( ) . putInt ( offset ( ) + TERM_OFFSET_FIELD_OFFSET , termOffset , LITTLE_ENDIAN ) ; return this ; } public int dataOffset ( ) { return offset ( ) + DATA_OFFSET ; } public static MutableDirectBuffer createDefaultHeader ( final int sessionId , final int streamId , final int termId ) { final UnsafeBuffer buffer = new UnsafeBuffer ( new byte [ HEADER_LENGTH ] ) ; buffer . putByte ( VERSION_FIELD_OFFSET , CURRENT_VERSION ) ; buffer . putByte ( FLAGS_FIELD_OFFSET , ( byte ) BEGIN_AND_END_FLAGS ) ; buffer . putShort ( TYPE_FIELD_OFFSET , ( short ) HDR_TYPE_DATA , ByteOrder . LITTLE_ENDIAN ) ; buffer . putInt ( SESSION_ID_FIELD_OFFSET , sessionId , ByteOrder . LITTLE_ENDIAN ) ; buffer . putInt ( STREAM_ID_FIELD_OFFSET , streamId , ByteOrder . LITTLE_ENDIAN ) ; buffer . putInt ( TERM_ID_FIELD_OFFSET , termId , ByteOrder . LITTLE_ENDIAN ) ; return buffer ; } public String toString ( ) { final StringBuilder sb = new StringBuilder ( ) ; final String formattedFlags = String . format ( "%1$8s" , Integer . toBinaryString ( flags ( ) ) ) . replace ( ' ' , '0' ) ; sb . append ( "Data Header{" ) . append ( "frame_length=" ) . append ( frameLength ( ) ) . append ( " version=" ) . append ( version ( ) ) . append ( " flags=" ) . append ( formattedFlags ) . append ( " type=" ) . append ( headerType ( ) ) . append ( " frame_length=" ) . append ( frameLength ( ) ) . append ( " term_offset=" ) . append ( termOffset ( ) ) . append ( " session_id=" ) . append ( sessionId ( ) ) . append ( " stream_id=" ) . append ( streamId ( ) ) . append ( " term_id=" ) . append ( termId ( ) ) . append ( "}" ) ; return sb . toString ( ) ; } }
package uk . co . real_logic . aeron . protocol ; import uk . co . real_logic . aeron . ErrorCode ; import uk . co . real_logic . aeron . Flyweight ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; public class ErrorFlyweight extends HeaderFlyweight { public static final int HEADER_LENGTH = 12 ; private static final int ERROR_CODE_FIELD_OFFSET = 1 ; private static final int OFFENDING_HDR_FRAME_LENGTH_FIELD_OFFSET = 8 ; private static final int OFFENDING_HDR_OFFSET = 12 ; public ErrorCode errorCode ( ) { return ErrorCode . get ( uint8Get ( offset ( ) + ERROR_CODE_FIELD_OFFSET ) ) ; } public ErrorFlyweight errorCode ( final ErrorCode code ) { uint8Put ( offset ( ) + ERROR_CODE_FIELD_OFFSET , code . value ( ) ) ; return this ; } public int offendingHeaderFrameLength ( ) { return buffer ( ) . getInt ( offset ( ) + OFFENDING_HDR_FRAME_LENGTH_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public ErrorFlyweight offendingHeaderFrameLength ( final int length ) { buffer ( ) . putInt ( offset ( ) + OFFENDING_HDR_FRAME_LENGTH_FIELD_OFFSET , length , LITTLE_ENDIAN ) ; return this ; } public int offendingHeaderOffset ( ) { return offset ( ) + OFFENDING_HDR_OFFSET ; } public ErrorFlyweight offendingHeader ( final HeaderFlyweight header , final int maxLength ) { final int length = Math . min ( header . frameLength ( ) , maxLength ) ; return offendingFlyweight ( header , length ) ; } public ErrorFlyweight offendingFlyweight ( final Flyweight offendingFlyweight , final int length ) { offendingHeaderFrameLength ( length ) ; copyFlyweight ( offendingFlyweight , offendingHeaderOffset ( ) , length ) ; return this ; } public int errorMessageOffset ( ) { return offendingHeaderOffset ( ) + offendingHeaderFrameLength ( ) ; } public ErrorFlyweight errorMessage ( final byte [ ] errorMessage ) { buffer ( ) . putBytes ( errorMessageOffset ( ) , errorMessage , 0 , errorMessage . length ) ; return this ; } public int errorStringLength ( ) { return frameLength ( ) - offendingHeaderFrameLength ( ) - ErrorFlyweight . HEADER_LENGTH ; } public byte [ ] errorMessageAsBytes ( ) { final int len = errorStringLength ( ) ; final byte [ ] bytes = new byte [ len ] ; buffer ( ) . getBytes ( errorMessageOffset ( ) , bytes , 0 , len ) ; return bytes ; } public String errorMessage ( ) { return new String ( errorMessageAsBytes ( ) ) ; } }
package uk . co . real_logic . aeron . protocol ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; public class NakFlyweight extends HeaderFlyweight { public static final int HEADER_LENGTH = 28 ; private static final int SESSION_ID_FIELD_OFFSET = 8 ; private static final int STREAM_ID_FIELD_OFFSET = 12 ; private static final int TERM_ID_FIELD_OFFSET = 16 ; private static final int TERM_OFFSET_FIELD_OFFSET = 20 ; private static final int LENGTH_FIELD_OFFSET = 24 ; public int sessionId ( ) { return buffer ( ) . getInt ( offset ( ) + SESSION_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public NakFlyweight sessionId ( final int sessionId ) { buffer ( ) . putInt ( offset ( ) + SESSION_ID_FIELD_OFFSET , sessionId , LITTLE_ENDIAN ) ; return this ; } public int streamId ( ) { return buffer ( ) . getInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public NakFlyweight streamId ( final int streamId ) { buffer ( ) . putInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , streamId , LITTLE_ENDIAN ) ; return this ; } public int termId ( ) { return buffer ( ) . getInt ( offset ( ) + TERM_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public NakFlyweight termId ( final int termId ) { buffer ( ) . putInt ( offset ( ) + TERM_ID_FIELD_OFFSET , termId , LITTLE_ENDIAN ) ; return this ; } public int termOffset ( ) { return buffer ( ) . getInt ( offset ( ) + TERM_OFFSET_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public NakFlyweight termOffset ( final int termOffset ) { buffer ( ) . putInt ( offset ( ) + TERM_OFFSET_FIELD_OFFSET , termOffset , LITTLE_ENDIAN ) ; return this ; } public int length ( ) { return buffer ( ) . getInt ( offset ( ) + LENGTH_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public NakFlyweight length ( final int length ) { buffer ( ) . putInt ( offset ( ) + LENGTH_FIELD_OFFSET , length , LITTLE_ENDIAN ) ; return this ; } }
package uk . co . real_logic . aeron . protocol ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; public class StatusMessageFlyweight extends HeaderFlyweight { public static final int HEADER_LENGTH = 28 ; public static final short SEND_SETUP_FLAG = 0x80 ; private static final int SESSION_ID_FIELD_OFFSET = 8 ; private static final int STREAM_ID_FIELD_OFFSET = 12 ; private static final int CONSUMPTION_TERM_ID_FIELD_OFFSET = 16 ; private static final int CONSUMPTION_TERM_OFFSET_FIELD_OFFSET = 20 ; private static final int RECEIVER_WINDOW_FIELD_OFFSET = 24 ; public int sessionId ( ) { return buffer ( ) . getInt ( offset ( ) + SESSION_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public StatusMessageFlyweight sessionId ( final int sessionId ) { buffer ( ) . putInt ( offset ( ) + SESSION_ID_FIELD_OFFSET , sessionId , LITTLE_ENDIAN ) ; return this ; } public int streamId ( ) { return buffer ( ) . getInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public StatusMessageFlyweight streamId ( final int streamId ) { buffer ( ) . putInt ( offset ( ) + STREAM_ID_FIELD_OFFSET , streamId , LITTLE_ENDIAN ) ; return this ; } public int consumptionTermOffset ( ) { return buffer ( ) . getInt ( offset ( ) + CONSUMPTION_TERM_OFFSET_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public StatusMessageFlyweight consumptionTermOffset ( final int termOffset ) { buffer ( ) . putInt ( offset ( ) + CONSUMPTION_TERM_OFFSET_FIELD_OFFSET , termOffset , LITTLE_ENDIAN ) ; return this ; } public int consumptionTermId ( ) { return buffer ( ) . getInt ( offset ( ) + CONSUMPTION_TERM_ID_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public StatusMessageFlyweight consumptionTermId ( final int termId ) { buffer ( ) . putInt ( offset ( ) + CONSUMPTION_TERM_ID_FIELD_OFFSET , termId , LITTLE_ENDIAN ) ; return this ; } public int receiverWindowLength ( ) { return buffer ( ) . getInt ( offset ( ) + RECEIVER_WINDOW_FIELD_OFFSET , LITTLE_ENDIAN ) ; } public StatusMessageFlyweight receiverWindowLength ( final int receiverWindowLength ) { buffer ( ) . putInt ( offset ( ) + RECEIVER_WINDOW_FIELD_OFFSET , receiverWindowLength , LITTLE_ENDIAN ) ; return this ; } }
package uk . co . real_logic . aeron . command ; import static java . nio . ByteOrder . LITTLE_ENDIAN ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_INT ; import static uk . co . real_logic . agrona . BitUtil . SIZE_OF_LONG ; public class SubscriptionMessageFlyweight extends CorrelatedMessageFlyweight { private static final int REGISTRATION_CORRELATION_ID_OFFSET = CORRELATION_ID_FIELD_OFFSET + SIZE_OF_LONG ; private static final int STREAM_ID_OFFSET = REGISTRATION_CORRELATION_ID_OFFSET + SIZE_OF_LONG ; private static final int CHANNEL_OFFSET = STREAM_ID_OFFSET + SIZE_OF_INT ; private int lengthOfChannel ; public long registrationCorrelationId ( ) { return buffer ( ) . getLong ( offset ( ) + REGISTRATION_CORRELATION_ID_OFFSET , LITTLE_ENDIAN ) ; } public SubscriptionMessageFlyweight registrationCorrelationId ( final long correlationId ) { buffer ( ) . putLong ( offset ( ) + REGISTRATION_CORRELATION_ID_OFFSET , correlationId , LITTLE_ENDIAN ) ; return this ; } public int streamId ( ) { return buffer ( ) . getInt ( offset ( ) + STREAM_ID_OFFSET , LITTLE_ENDIAN ) ; } public SubscriptionMessageFlyweight streamId ( final int streamId ) { buffer ( ) . putInt ( offset ( ) + STREAM_ID_OFFSET , streamId , LITTLE_ENDIAN ) ; return this ; } public String channel ( ) { return stringGet ( offset ( ) + CHANNEL_OFFSET , LITTLE_ENDIAN ) ; } public SubscriptionMessageFlyweight channel ( final String channel ) { lengthOfChannel = stringPut ( offset ( ) + CHANNEL_OFFSET , channel , LITTLE_ENDIAN ) ; return this ; } public int length ( ) { return CHANNEL_OFFSET + lengthOfChannel ; } }
package uk . co . real_logic . aeron . tools ; import org . apache . commons . cli . ParseException ; import org . junit . Before ; import org . junit . Test ; import static org . hamcrest . core . Is . is ; import static org . junit . Assert . assertThat ; public class ThwackerOptionsTest { private ThwackerOptions opts ; @ Before public void setUp ( ) { opts = new ThwackerOptions ( ) ; } @ Test public void verifyShort ( ) throws Exception { final String [ ] args = { "-v" , "yes" } ; opts . parseArgs ( args ) ; assertThat ( opts . verifiable ( ) , is ( true ) ) ; } @ Test public void verifyOn ( ) throws Exception { final String [ ] args = { "--verify" , "Yes" } ; opts . parseArgs ( args ) ; assertThat ( opts . verifiable ( ) , is ( true ) ) ; } @ Test public void verifyOff ( ) throws Exception { final String [ ] args = { "--verify" , "No" } ; opts . parseArgs ( args ) ; assertThat ( opts . verifiable ( ) , is ( false ) ) ; } @ Test public void verifyDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --verify should be false" , opts . verifiable ( ) , is ( false ) ) ; } @ Test ( expected = ParseException . class ) public void verifyException ( ) throws Exception { final String [ ] args = { "--verify" , "schmerify" } ; opts . parseArgs ( args ) ; } @ Test public void sameSIDOn ( ) throws Exception { final String [ ] args = { "--same-sid" , "Yes" } ; opts . parseArgs ( args ) ; assertThat ( opts . sameSID ( ) , is ( true ) ) ; } @ Test public void sameSIDOff ( ) throws Exception { final String [ ] args = { "--same-sid" , "No" } ; opts . parseArgs ( args ) ; assertThat ( opts . sameSID ( ) , is ( false ) ) ; } @ Test public void sameSIDDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --same-sid should be false" , opts . sameSID ( ) , is ( false ) ) ; } @ Test ( expected = ParseException . class ) public void sameSIDException ( ) throws Exception { final String [ ] args = { "--same-sid" , "wrongstring" } ; opts . parseArgs ( args ) ; } @ Test public void channelPerPubOn ( ) throws Exception { final String [ ] args = { "--channel-per-pub" , "Yes" } ; opts . parseArgs ( args ) ; assertThat ( opts . channelPerPub ( ) , is ( true ) ) ; } @ Test public void channelPerPubOff ( ) throws Exception { final String [ ] args = { "--channel-per-pub" , "No" } ; opts . parseArgs ( args ) ; assertThat ( opts . channelPerPub ( ) , is ( false ) ) ; } @ Test public void channelPerPubDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --channel-per-pub should be false" , opts . channelPerPub ( ) , is ( false ) ) ; } @ Test ( expected = ParseException . class ) public void channelPerPubException ( ) throws Exception { final String [ ] args = { "--channel-per-pub" , "chanperpub" } ; opts . parseArgs ( args ) ; } @ Test public void channelDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --channel should be udp://localhost" , opts . channel ( ) , is ( "udp://localhost" ) ) ; } @ Test public void channel ( ) throws Exception { final String [ ] args = { "--channel" , "blahblahblah" } ; opts . parseArgs ( args ) ; assertThat ( opts . channel ( ) , is ( "blahblahblah" ) ) ; } @ Test public void channelShort ( ) throws Exception { final String [ ] args = { "-c" , "blahblahblah" } ; opts . parseArgs ( args ) ; assertThat ( opts . channel ( ) , is ( "blahblahblah" ) ) ; } @ Test public void portPass ( ) throws Exception { final String [ ] args = { "--port" , "12345" } ; opts . parseArgs ( args ) ; assertThat ( opts . port ( ) , is ( 12345 ) ) ; } @ Test public void portShortPass ( ) throws Exception { final String [ ] args = { "-p" , "12345" } ; opts . parseArgs ( args ) ; assertThat ( opts . port ( ) , is ( 12345 ) ) ; } @ Test ( expected = ParseException . class ) public void portFail ( ) throws Exception { final String [ ] args = { "--port" , "-12345" } ; opts . parseArgs ( args ) ; } @ Test public void portDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --port should be " + 51234 , opts . port ( ) , is ( 51234 ) ) ; } @ Test public void durationPass ( ) throws Exception { final String [ ] args = { "--duration" , "77969403" } ; opts . parseArgs ( args ) ; assertThat ( opts . duration ( ) , is ( 77969403 ) ) ; } @ Test public void durationShortPass ( ) throws Exception { final String [ ] args = { "-d" , "77969403" } ; opts . parseArgs ( args ) ; assertThat ( opts . duration ( ) , is ( 77969403 ) ) ; } @ Test ( expected = ParseException . class ) public void durationFail ( ) throws Exception { final String [ ] args = { "--duration" , "-2345145" } ; opts . parseArgs ( args ) ; } @ Test public void durationDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --duration should be '30000'" , opts . duration ( ) , is ( 30000 ) ) ; } @ Test public void iterationsPass ( ) throws Exception { final String [ ] args = { "--iterations" , "7703" } ; opts . parseArgs ( args ) ; assertThat ( opts . iterations ( ) , is ( 7703 ) ) ; } @ Test public void iterationsShortPass ( ) throws Exception { final String [ ] args = { "-i" , "7703" } ; opts . parseArgs ( args ) ; assertThat ( opts . iterations ( ) , is ( 7703 ) ) ; } @ Test ( expected = ParseException . class ) public void iterationsFail ( ) throws Exception { final String [ ] args = { "--iterations" , "-235725" } ; opts . parseArgs ( args ) ; } @ Test public void iterationsDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --iterations should be 1" , opts . iterations ( ) , is ( 1 ) ) ; } @ Test public void sendersPass ( ) throws Exception { final String [ ] args = { "--senders" , "7703" } ; opts . parseArgs ( args ) ; assertThat ( opts . senders ( ) , is ( 7703 ) ) ; } @ Test public void sendersShortPass ( ) throws Exception { final String [ ] args = { "-s" , "7703" } ; opts . parseArgs ( args ) ; assertThat ( opts . senders ( ) , is ( 7703 ) ) ; } @ Test ( expected = ParseException . class ) public void sendersFail ( ) throws Exception { final String [ ] args = { "--senders" , "-235725" } ; opts . parseArgs ( args ) ; } @ Test public void sendersDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --iterations should be 1" , opts . senders ( ) , is ( 1 ) ) ; } @ Test public void receiversPass ( ) throws Exception { final String [ ] args = { "--receivers" , "7703" } ; opts . parseArgs ( args ) ; assertThat ( opts . receivers ( ) , is ( 7703 ) ) ; } @ Test public void receiversShortPass ( ) throws Exception { final String [ ] args = { "-r" , "7703" } ; opts . parseArgs ( args ) ; assertThat ( opts . receivers ( ) , is ( 7703 ) ) ; } @ Test ( expected = ParseException . class ) public void receiversFail ( ) throws Exception { final String [ ] args = { "--receivers" , "-235725" } ; opts . parseArgs ( args ) ; } @ Test public void receiversDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --iterations should be 1" , opts . receivers ( ) , is ( 1 ) ) ; } @ Test public void addersPass ( ) throws Exception { final String [ ] args = { "--adders" , "7703" } ; opts . parseArgs ( args ) ; assertThat ( opts . adders ( ) , is ( 7703 ) ) ; } @ Test ( expected = ParseException . class ) public void addersFail ( ) throws Exception { final String [ ] args = { "--adders" , "-235725" } ; opts . parseArgs ( args ) ; } @ Test public void addersDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --adders should be 1" , opts . adders ( ) , is ( 1 ) ) ; } @ Test public void removersPass ( ) throws Exception { final String [ ] args = { "--removers" , "7703" } ; opts . parseArgs ( args ) ; assertThat ( opts . removers ( ) , is ( 7703 ) ) ; } @ Test ( expected = ParseException . class ) public void removersFail ( ) throws Exception { final String [ ] args = { "--removers" , "-235725" } ; opts . parseArgs ( args ) ; } @ Test public void removersDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --removers should be 1" , opts . removers ( ) , is ( 1 ) ) ; } @ Test public void elementsPass ( ) throws Exception { final String [ ] args = { "--elements" , "7703" } ; opts . parseArgs ( args ) ; assertThat ( opts . elements ( ) , is ( 7703 ) ) ; } @ Test public void elementsShortPass ( ) throws Exception { final String [ ] args = { "-e" , "7703" } ; opts . parseArgs ( args ) ; assertThat ( opts . elements ( ) , is ( 7703 ) ) ; } @ Test ( expected = ParseException . class ) public void elementsFail ( ) throws Exception { final String [ ] args = { "--elements" , "-235725" } ; opts . parseArgs ( args ) ; } @ Test public void elementsDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --elements should be 10" , opts . elements ( ) , is ( 10 ) ) ; } @ Test public void maxSizePass ( ) throws Exception { final String [ ] args = { "--max-size" , "7703" } ; opts . parseArgs ( args ) ; assertThat ( opts . maxMsgSize ( ) , is ( 7703 ) ) ; } @ Test ( expected = ParseException . class ) public void maxSizeFail ( ) throws Exception { final String [ ] args = { "--max-size" , "-235725" } ; opts . parseArgs ( args ) ; } @ Test public void maxSizeDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --max-size should be 35" , opts . maxMsgSize ( ) , is ( 35 ) ) ; } @ Test public void minSizePass ( ) throws Exception { final String [ ] args = { "--min-size" , "7703" } ; opts . parseArgs ( args ) ; assertThat ( opts . minMsgSize ( ) , is ( 7703 ) ) ; } @ Test ( expected = ParseException . class ) public void minSizeFail ( ) throws Exception { final String [ ] args = { "--min-size" , "-235725" } ; opts . parseArgs ( args ) ; } @ Test public void minSizeDefault ( ) throws Exception { final String [ ] args = { } ; opts . parseArgs ( args ) ; assertThat ( "FAIL: Default for --min-size should be 35" , opts . minMsgSize ( ) , is ( 35 ) ) ; } @ Test public void help ( ) throws Exception { final String [ ] args = { "--help" } ; assertThat ( opts . parseArgs ( args ) , is ( 1 ) ) ; } @ Test public void helpShorthand ( ) throws Exception { final String [ ] args = { "-h" } ; assertThat ( opts . parseArgs ( args ) , is ( 1 ) ) ; } }
