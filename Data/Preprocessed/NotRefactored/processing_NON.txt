package japplemenubar ; import java . io . * ; import processing . core . PApplet ; public class JAppleMenuBar { static JAppleMenuBar instance ; static final String FILENAME = "libjAppleMenuBar.jnilib" ; static { try { File temp = File . createTempFile ( "processing" , "menubar" ) ; temp . delete ( ) ; temp . mkdirs ( ) ; temp . deleteOnExit ( ) ; File jnilibFile = new File ( temp , FILENAME ) ; InputStream input = JAppleMenuBar . class . getResourceAsStream ( FILENAME ) ; if ( input != null ) { if ( PApplet . saveStream ( jnilibFile , input ) ) { System . load ( jnilibFile . getAbsolutePath ( ) ) ; instance = new JAppleMenuBar ( ) ; } else { sadness ( "Problem saving " + FILENAME + " for full screen use." ) ; } } else { sadness ( "Could not load " + FILENAME + " from core.jar" ) ; } } catch ( IOException e ) { sadness ( "Unknown error, here's the stack trace." ) ; e . printStackTrace ( ) ; } } static void sadness ( String msg ) { System . err . println ( "Full screen mode disabled. " + msg ) ; } static public void hide ( ) { instance . setVisible ( false , false ) ; } public native void setVisible ( boolean visibility , boolean kioskMode ) ; }
package processing . app . exec ; import java . util . Arrays ; import java . util . Iterator ; public class ProcessResult implements Iterable < String > { private final String cmd ; private final long time ; private final String output ; private final String error ; private final int result ; public ProcessResult ( String cmd , int result , String output , String error , long time ) { this . cmd = cmd ; this . output = output ; this . error = error ; this . result = result ; this . time = time ; } public Iterator < String > iterator ( ) { return Arrays . asList ( output . split ( "\r?\n" ) ) . iterator ( ) ; } public String getCmd ( ) { return cmd ; } public int getResult ( ) { return result ; } public boolean succeeded ( ) { return result == 0 ; } public String getStderr ( ) { return error ; } public String getStdout ( ) { return output ; } public long getTime ( ) { return time ; } @ Override public String toString ( ) { final StringBuilder sb = new StringBuilder ( cmd ) . append ( "\n" ) ; sb . append ( " status: " ) . append ( result ) . append ( "\n" ) ; sb . append ( " " ) . append ( time ) . append ( "ms" ) . append ( "\n" ) ; sb . append ( " stdout:\n" ) . append ( output . trim ( ) ) . append ( "\n" ) ; sb . append ( " stderr:\n" ) . append ( error . trim ( ) ) ; return sb . toString ( ) ; } }
package processing . app . exec ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . io . Writer ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadFactory ; import processing . app . Base ; public class StreamPump implements Runnable { private static final ExecutorService threads = Executors . newCachedThreadPool ( new ThreadFactory ( ) { public Thread newThread ( final Runnable r ) { final Thread t = new Thread ( r ) ; t . setDaemon ( true ) ; t . setName ( "StreamPump " + t . getId ( ) ) ; return t ; } } ) ; private final BufferedReader reader ; private final List < LineProcessor > outs = new CopyOnWriteArrayList < LineProcessor > ( ) ; private final String name ; public StreamPump ( final InputStream in , final String name ) { this . reader = new BufferedReader ( new InputStreamReader ( in ) ) ; this . name = name ; } public StreamPump addTarget ( final OutputStream out ) { outs . add ( new WriterLineProcessor ( out ) ) ; return this ; } public StreamPump addTarget ( final Writer out ) { outs . add ( new WriterLineProcessor ( out ) ) ; return this ; } public StreamPump addTarget ( final LineProcessor out ) { outs . add ( out ) ; return this ; } public void start ( ) { threads . execute ( this ) ; } public void run ( ) { try { String line ; while ( ( line = reader . readLine ( ) ) != null ) { for ( final LineProcessor out : outs ) { try { out . processLine ( line ) ; } catch ( final Exception e ) { } } } } catch ( final IOException e ) { if ( Base . DEBUG ) { System . err . println ( "StreamPump: " + name ) ; e . printStackTrace ( System . err ) ; throw new RuntimeException ( "Inside " + this + " for " + name , e ) ; } } } private static class WriterLineProcessor implements LineProcessor { private final PrintWriter writer ; private WriterLineProcessor ( final OutputStream out ) { this . writer = new PrintWriter ( out , true ) ; } private WriterLineProcessor ( final Writer writer ) { this . writer = new PrintWriter ( writer , true ) ; } public void processLine ( final String line ) { writer . println ( line ) ; } } }
package processing . app . exec ; import java . io . * ; import processing . core . PApplet ; public class ProcessHelper { private final String [ ] cmd ; private final File dir ; public ProcessHelper ( final String ... cmd ) { this . cmd = cmd ; this . dir = null ; } public ProcessHelper ( File dir , final String ... cmd ) { this . cmd = cmd ; this . dir = dir ; } @ Override public String toString ( ) { return PApplet . join ( cmd , " " ) ; } public ProcessResult execute ( ) throws InterruptedException , IOException { return execute ( null ) ; } public ProcessResult execute ( String outgoing ) throws InterruptedException , IOException { final StringWriter outWriter = new StringWriter ( ) ; final StringWriter errWriter = new StringWriter ( ) ; final long startTime = System . currentTimeMillis ( ) ; final String prettyCommand = toString ( ) ; final Process process = dir == null ? Runtime . getRuntime ( ) . exec ( cmd ) : Runtime . getRuntime ( ) . exec ( cmd , new String [ ] { } , dir ) ; ProcessRegistry . watch ( process ) ; if ( outgoing != null ) { OutputStream os = process . getOutputStream ( ) ; PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( os ) ) ; pw . println ( outgoing ) ; pw . flush ( ) ; pw . close ( ) ; } try { String title = prettyCommand ; new StreamPump ( process . getInputStream ( ) , "out: " + title ) . addTarget ( outWriter ) . start ( ) ; new StreamPump ( process . getErrorStream ( ) , "err: " + title ) . addTarget ( errWriter ) . start ( ) ; try { final int result = process . waitFor ( ) ; final long time = System . currentTimeMillis ( ) - startTime ; return new ProcessResult ( prettyCommand , result , outWriter . toString ( ) , errWriter . toString ( ) , time ) ; } catch ( final InterruptedException e ) { System . err . println ( "Interrupted: " + prettyCommand ) ; throw e ; } } finally { process . destroy ( ) ; ProcessRegistry . unwatch ( process ) ; } } static public boolean ffs ( final String ... cmd ) { try { ProcessHelper helper = new ProcessHelper ( cmd ) ; ProcessResult result = helper . execute ( ) ; if ( result . succeeded ( ) ) { return true ; } System . out . println ( result . getStdout ( ) ) ; System . err . println ( result . getStderr ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return false ; } }
package processing . app . syntax ; import java . awt . * ; public class TextAreaDefaults { public SyntaxDocument document ; public boolean caretVisible ; public boolean caretBlinks ; public boolean blockCaret ; public int electricScroll ; public int cols ; public int rows ; public SyntaxStyle [ ] styles ; public Color caretColor ; public Color selectionColor ; public Color lineHighlightColor ; public boolean lineHighlight ; public Color bracketHighlightColor ; public boolean bracketHighlight ; public Color eolMarkerColor ; public boolean eolMarkers ; public boolean paintInvalid ; public Color fgcolor ; public Color bgcolor ; }
package processing . app . syntax ; public class Token { public static final byte NULL = 0 ; public static final byte COMMENT1 = 1 ; public static final byte COMMENT2 = 2 ; public static final byte LITERAL1 = 3 ; public static final byte LITERAL2 = 4 ; public static final byte LABEL = 5 ; public static final byte KEYWORD1 = 6 ; public static final byte KEYWORD2 = 7 ; public static final byte KEYWORD3 = 8 ; public static final byte KEYWORD4 = 9 ; public static final byte KEYWORD5 = 10 ; public static final byte KEYWORD6 = 11 ; public static final byte FUNCTION1 = 12 ; public static final byte FUNCTION2 = 13 ; public static final byte FUNCTION3 = 14 ; public static final byte FUNCTION4 = 15 ; public static final byte OPERATOR = 16 ; public static final byte INVALID = 17 ; public static final byte ID_COUNT = INVALID + 1 ; public static final byte INTERNAL_FIRST = 100 ; public static final byte INTERNAL_LAST = 126 ; public static final byte END = 127 ; public int length ; public byte id ; public Token next ; public Token ( int length , byte id ) { this . length = length ; this . id = id ; } public String toString ( ) { return "[id=" + id + ",length=" + length + "]" ; } }
package processing . app . syntax ; import javax . swing . text . * ; import javax . swing . JPopupMenu ; import processing . app . Preferences ; import java . awt . event . * ; import java . awt . Component ; import java . util . * ; public abstract class InputHandler extends KeyAdapter { public static final String SMART_HOME_END_PROPERTY = "InputHandler.homeEnd" ; public static final String CONTEXT_AWARE_HOME_END = "editor.keys.home_and_end_travel_smart" ; public static final ActionListener BACKSPACE = new backspace ( ) ; public static final ActionListener BACKSPACE_WORD = new backspace_word ( ) ; public static final ActionListener DELETE = new delete ( ) ; public static final ActionListener DELETE_WORD = new delete_word ( ) ; public static final ActionListener END = new end ( false ) ; public static final ActionListener DOCUMENT_END = new document_end ( false ) ; public static final ActionListener SELECT_END = new end ( true ) ; public static final ActionListener SELECT_DOC_END = new document_end ( true ) ; public static final ActionListener INSERT_BREAK = new insert_break ( ) ; public static final ActionListener INSERT_TAB = new insert_tab ( ) ; public static final ActionListener HOME = new home ( false ) ; public static final ActionListener DOCUMENT_HOME = new document_home ( false ) ; public static final ActionListener SELECT_HOME = new home ( true ) ; public static final ActionListener SELECT_DOC_HOME = new document_home ( true ) ; public static final ActionListener NEXT_CHAR = new next_char ( false ) ; public static final ActionListener NEXT_LINE = new next_line ( false ) ; public static final ActionListener NEXT_PAGE = new next_page ( false ) ; public static final ActionListener NEXT_WORD = new next_word ( false ) ; public static final ActionListener SELECT_NEXT_CHAR = new next_char ( true ) ; public static final ActionListener SELECT_NEXT_LINE = new next_line ( true ) ; public static final ActionListener SELECT_NEXT_PAGE = new next_page ( true ) ; public static final ActionListener SELECT_NEXT_WORD = new next_word ( true ) ; public static final ActionListener OVERWRITE = new overwrite ( ) ; public static final ActionListener PREV_CHAR = new prev_char ( false ) ; public static final ActionListener PREV_LINE = new prev_line ( false ) ; public static final ActionListener PREV_PAGE = new prev_page ( false ) ; public static final ActionListener PREV_WORD = new prev_word ( false ) ; public static final ActionListener SELECT_PREV_CHAR = new prev_char ( true ) ; public static final ActionListener SELECT_PREV_LINE = new prev_line ( true ) ; public static final ActionListener SELECT_PREV_PAGE = new prev_page ( true ) ; public static final ActionListener SELECT_PREV_WORD = new prev_word ( true ) ; public static final ActionListener REPEAT = new repeat ( ) ; public static final ActionListener TOGGLE_RECT = new toggle_rect ( ) ; public static final ActionListener CLIPBOARD_CUT = new clipboard_cut ( ) ; public static final ActionListener CLIPBOARD_COPY = new clipboard_copy ( ) ; public static final ActionListener CLIPBOARD_PASTE = new clipboard_paste ( ) ; public static final ActionListener INSERT_CHAR = new insert_char ( ) ; private static Map < String , ActionListener > actions ; static { actions = new HashMap < String , ActionListener > ( ) ; actions . put ( "backspace" , BACKSPACE ) ; actions . put ( "backspace-word" , BACKSPACE_WORD ) ; actions . put ( "delete" , DELETE ) ; actions . put ( "delete-word" , DELETE_WORD ) ; actions . put ( "end" , END ) ; actions . put ( "select-end" , SELECT_END ) ; actions . put ( "document-end" , DOCUMENT_END ) ; actions . put ( "select-doc-end" , SELECT_DOC_END ) ; actions . put ( "insert-break" , INSERT_BREAK ) ; actions . put ( "insert-tab" , INSERT_TAB ) ; actions . put ( "home" , HOME ) ; actions . put ( "select-home" , SELECT_HOME ) ; actions . put ( "document-home" , DOCUMENT_HOME ) ; actions . put ( "select-doc-home" , SELECT_DOC_HOME ) ; actions . put ( "next-char" , NEXT_CHAR ) ; actions . put ( "next-line" , NEXT_LINE ) ; actions . put ( "next-page" , NEXT_PAGE ) ; actions . put ( "next-word" , NEXT_WORD ) ; actions . put ( "select-next-char" , SELECT_NEXT_CHAR ) ; actions . put ( "select-next-line" , SELECT_NEXT_LINE ) ; actions . put ( "select-next-page" , SELECT_NEXT_PAGE ) ; actions . put ( "select-next-word" , SELECT_NEXT_WORD ) ; actions . put ( "overwrite" , OVERWRITE ) ; actions . put ( "prev-char" , PREV_CHAR ) ; actions . put ( "prev-line" , PREV_LINE ) ; actions . put ( "prev-page" , PREV_PAGE ) ; actions . put ( "prev-word" , PREV_WORD ) ; actions . put ( "select-prev-char" , SELECT_PREV_CHAR ) ; actions . put ( "select-prev-line" , SELECT_PREV_LINE ) ; actions . put ( "select-prev-page" , SELECT_PREV_PAGE ) ; actions . put ( "select-prev-word" , SELECT_PREV_WORD ) ; actions . put ( "repeat" , REPEAT ) ; actions . put ( "toggle-rect" , TOGGLE_RECT ) ; actions . put ( "insert-char" , INSERT_CHAR ) ; actions . put ( "clipboard-cut" , CLIPBOARD_CUT ) ; actions . put ( "clipboard-copy" , CLIPBOARD_COPY ) ; actions . put ( "clipboard-paste" , CLIPBOARD_PASTE ) ; } public static ActionListener getAction ( String name ) { return actions . get ( name ) ; } public static String getActionName ( ActionListener listener ) { Set < String > set = getActions ( ) ; for ( String name : set ) { ActionListener _listener = getAction ( name ) ; if ( _listener == listener ) { return name ; } } return null ; } public static Set < String > getActions ( ) { return actions . keySet ( ) ; } public abstract void addDefaultKeyBindings ( ) ; public abstract void addKeyBinding ( String keyBinding , ActionListener action ) ; public abstract void removeKeyBinding ( String keyBinding ) ; public abstract void removeAllKeyBindings ( ) ; public void grabNextKeyStroke ( ActionListener listener ) { grabAction = listener ; } public boolean isRepeatEnabled ( ) { return repeat ; } public void setRepeatEnabled ( boolean repeat ) { this . repeat = repeat ; } public int getRepeatCount ( ) { return ( repeat ? Math . max ( 1 , repeatCount ) : 1 ) ; } public void setRepeatCount ( int repeatCount ) { this . repeatCount = repeatCount ; } public InputHandler . MacroRecorder getMacroRecorder ( ) { return recorder ; } public void setMacroRecorder ( InputHandler . MacroRecorder recorder ) { this . recorder = recorder ; } public abstract InputHandler copy ( ) ; public void executeAction ( ActionListener listener , Object source , String actionCommand ) { ActionEvent evt = new ActionEvent ( source , ActionEvent . ACTION_PERFORMED , actionCommand ) ; if ( listener instanceof Wrapper ) { listener . actionPerformed ( evt ) ; return ; } boolean _repeat = repeat ; int _repeatCount = getRepeatCount ( ) ; if ( listener instanceof InputHandler . NonRepeatable ) listener . actionPerformed ( evt ) ; else { for ( int i = 0 ; i < Math . max ( 1 , repeatCount ) ; i ++ ) listener . actionPerformed ( evt ) ; } if ( grabAction == null ) { if ( recorder != null ) { if ( ! ( listener instanceof InputHandler . NonRecordable ) ) { if ( _repeatCount != 1 ) recorder . actionPerformed ( REPEAT , String . valueOf ( _repeatCount ) ) ; recorder . actionPerformed ( listener , actionCommand ) ; } } if ( _repeat ) { repeat = false ; repeatCount = 0 ; } } } public static JEditTextArea getTextArea ( EventObject evt ) { if ( evt != null ) { Object o = evt . getSource ( ) ; if ( o instanceof Component ) { Component c = ( Component ) o ; for ( ; ; ) { if ( c instanceof JEditTextArea ) return ( JEditTextArea ) c ; else if ( c == null ) break ; if ( c instanceof JPopupMenu ) c = ( ( JPopupMenu ) c ) . getInvoker ( ) ; else c = c . getParent ( ) ; } } } System . err . println ( "BUG: getTextArea() returning null" ) ; System . err . println ( "Report this to Slava Pestov <sp@gjt.org>" ) ; return null ; } protected void handleGrabAction ( KeyEvent evt ) { ActionListener _grabAction = grabAction ; grabAction = null ; executeAction ( _grabAction , evt . getSource ( ) , String . valueOf ( evt . getKeyChar ( ) ) ) ; } protected ActionListener grabAction ; protected boolean repeat ; protected int repeatCount ; protected InputHandler . MacroRecorder recorder ; public interface NonRepeatable { } public interface NonRecordable { } public interface Wrapper { } public interface MacroRecorder { void actionPerformed ( ActionListener listener , String actionCommand ) ; } public static class backspace implements ActionListener { public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; if ( ! textArea . isEditable ( ) ) { textArea . getToolkit ( ) . beep ( ) ; return ; } if ( textArea . getSelectionStart ( ) != textArea . getSelectionStop ( ) ) { textArea . setSelectedText ( "" ) ; } else { int caret = textArea . getCaretPosition ( ) ; if ( caret == 0 ) { textArea . getToolkit ( ) . beep ( ) ; return ; } try { textArea . getDocument ( ) . remove ( caret - 1 , 1 ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } } } } public static class backspace_word implements ActionListener { public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; int start = textArea . getSelectionStart ( ) ; if ( start != textArea . getSelectionStop ( ) ) { textArea . setSelectedText ( "" ) ; } int line = textArea . getCaretLine ( ) ; int lineStart = textArea . getLineStartOffset ( line ) ; int caret = start - lineStart ; String lineText = textArea . getLineText ( textArea . getCaretLine ( ) ) ; if ( caret == 0 ) { if ( lineStart == 0 ) { textArea . getToolkit ( ) . beep ( ) ; return ; } caret -- ; } else { String noWordSep = ( String ) textArea . getDocument ( ) . getProperty ( "noWordSep" ) ; caret = findWordStart ( lineText , caret , noWordSep ) ; } try { textArea . getDocument ( ) . remove ( caret + lineStart , start - ( caret + lineStart ) ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } } } public static class delete implements ActionListener { public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; if ( ! textArea . isEditable ( ) ) { textArea . getToolkit ( ) . beep ( ) ; return ; } if ( textArea . getSelectionStart ( ) != textArea . getSelectionStop ( ) ) { textArea . setSelectedText ( "" ) ; } else { int caret = textArea . getCaretPosition ( ) ; if ( caret == textArea . getDocumentLength ( ) ) { textArea . getToolkit ( ) . beep ( ) ; return ; } try { textArea . getDocument ( ) . remove ( caret , 1 ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } } } } public static class delete_word implements ActionListener { public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; int start = textArea . getSelectionStart ( ) ; if ( start != textArea . getSelectionStop ( ) ) { textArea . setSelectedText ( "" ) ; } int line = textArea . getCaretLine ( ) ; int lineStart = textArea . getLineStartOffset ( line ) ; int caret = start - lineStart ; String lineText = textArea . getLineText ( textArea . getCaretLine ( ) ) ; if ( caret == lineText . length ( ) ) { if ( lineStart + caret == textArea . getDocumentLength ( ) ) { textArea . getToolkit ( ) . beep ( ) ; return ; } caret ++ ; } else { String noWordSep = ( String ) textArea . getDocument ( ) . getProperty ( "noWordSep" ) ; caret = findWordEnd ( lineText , caret , noWordSep ) ; } try { textArea . getDocument ( ) . remove ( start , ( caret + lineStart ) - start ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } } } public static class end implements ActionListener { private boolean select ; public end ( boolean select ) { this . select = select ; } public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; int caret = textArea . getCaretPosition ( ) ; int caretLine = textArea . getCaretLine ( ) ; int lastOfLine = textArea . getLineStopOffset ( caretLine ) - 1 ; int lastNonWhiteSpaceOfLine = textArea . getLineStopNonWhiteSpaceOffset ( caretLine ) - 1 ; int lastVisibleLine = textArea . getFirstLine ( ) + textArea . getVisibleLines ( ) ; if ( lastVisibleLine >= textArea . getLineCount ( ) ) { lastVisibleLine = Math . min ( textArea . getLineCount ( ) - 1 , lastVisibleLine ) ; } else lastVisibleLine -= ( textArea . getElectricScroll ( ) + 1 ) ; int lastVisible = textArea . getLineStopOffset ( lastVisibleLine ) - 1 ; int lastDocument = textArea . getDocumentLength ( ) ; if ( caret == lastDocument && ! Preferences . getBoolean ( CONTEXT_AWARE_HOME_END ) ) { textArea . getToolkit ( ) . beep ( ) ; return ; } else if ( ! Boolean . TRUE . equals ( textArea . getClientProperty ( SMART_HOME_END_PROPERTY ) ) ) { if ( ! Preferences . getBoolean ( CONTEXT_AWARE_HOME_END ) || caret == lastNonWhiteSpaceOfLine ) caret = lastOfLine ; else caret = lastNonWhiteSpaceOfLine ; } else if ( caret == lastVisible ) caret = lastDocument ; else if ( caret == lastOfLine ) caret = lastVisible ; else caret = lastOfLine ; if ( select ) textArea . select ( textArea . getMarkPosition ( ) , caret ) ; else textArea . setCaretPosition ( caret ) ; } } public static class document_end implements ActionListener { private boolean select ; public document_end ( boolean select ) { this . select = select ; } public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; if ( select ) textArea . select ( textArea . getMarkPosition ( ) , textArea . getDocumentLength ( ) ) ; else textArea . setCaretPosition ( textArea . getDocumentLength ( ) ) ; } } public static class home implements ActionListener { private boolean select ; public home ( boolean select ) { this . select = select ; } public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; int caret = textArea . getCaretPosition ( ) ; int firstLine = textArea . getFirstLine ( ) ; int caretLine = textArea . getCaretLine ( ) ; int firstOfLine = textArea . getLineStartOffset ( caretLine ) ; int firstNonWhiteSpaceOfLine = textArea . getLineStartNonWhiteSpaceOffset ( caretLine ) ; int firstVisibleLine = ( firstLine == 0 ? 0 : firstLine + textArea . getElectricScroll ( ) ) ; int firstVisible = textArea . getLineStartOffset ( firstVisibleLine ) ; if ( caret == 0 && ! Preferences . getBoolean ( CONTEXT_AWARE_HOME_END ) ) { textArea . getToolkit ( ) . beep ( ) ; return ; } else if ( ! Boolean . TRUE . equals ( textArea . getClientProperty ( SMART_HOME_END_PROPERTY ) ) ) { if ( ! Preferences . getBoolean ( CONTEXT_AWARE_HOME_END ) || caret == firstNonWhiteSpaceOfLine ) caret = firstOfLine ; else caret = firstNonWhiteSpaceOfLine ; } else if ( caret == firstVisible ) caret = 0 ; else if ( caret == firstOfLine ) caret = firstVisible ; else caret = firstOfLine ; if ( select ) textArea . select ( textArea . getMarkPosition ( ) , caret ) ; else textArea . setCaretPosition ( caret ) ; } } public static class document_home implements ActionListener { private boolean select ; public document_home ( boolean select ) { this . select = select ; } public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; if ( select ) textArea . select ( textArea . getMarkPosition ( ) , 0 ) ; else textArea . setCaretPosition ( 0 ) ; } } public static class insert_break implements ActionListener { public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; if ( ! textArea . isEditable ( ) ) { textArea . getToolkit ( ) . beep ( ) ; return ; } textArea . setSelectedText ( "\n" ) ; } } public static class insert_tab implements ActionListener { public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; if ( ! textArea . isEditable ( ) ) { textArea . getToolkit ( ) . beep ( ) ; return ; } textArea . overwriteSetSelectedText ( "\t" ) ; } } public static class next_char implements ActionListener { private boolean select ; public next_char ( boolean select ) { this . select = select ; } public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; int caret = textArea . getCaretPosition ( ) ; if ( caret == textArea . getDocumentLength ( ) ) { if ( textArea . getSelectionStart ( ) != textArea . getSelectionStop ( ) ) { textArea . select ( caret , caret ) ; } else { textArea . getToolkit ( ) . beep ( ) ; } } else if ( select ) { textArea . select ( textArea . getMarkPosition ( ) , caret + 1 ) ; } else { int start = textArea . getSelectionStart ( ) ; int end = textArea . getSelectionStop ( ) ; if ( start != end ) { textArea . select ( end , end ) ; } else { textArea . setCaretPosition ( caret + 1 ) ; } } } } public static class next_line implements ActionListener { private boolean select ; public next_line ( boolean select ) { this . select = select ; } public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; int caret = textArea . getCaretPosition ( ) ; int line = textArea . getCaretLine ( ) ; if ( line == textArea . getLineCount ( ) - 1 ) { int doc = textArea . getDocumentLength ( ) ; if ( select ) { textArea . select ( textArea . getMarkPosition ( ) , doc ) ; } else { textArea . setCaretPosition ( doc ) ; } return ; } int magic = textArea . getMagicCaretPosition ( ) ; if ( magic == - 1 ) { magic = textArea . offsetToX ( line , caret - textArea . getLineStartOffset ( line ) ) ; } caret = textArea . getLineStartOffset ( line + 1 ) + textArea . xToOffset ( line + 1 , magic ) ; if ( select ) textArea . select ( textArea . getMarkPosition ( ) , caret ) ; else textArea . setCaretPosition ( caret ) ; textArea . setMagicCaretPosition ( magic ) ; } } public static class next_page implements ActionListener { private boolean select ; public next_page ( boolean select ) { this . select = select ; } public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; int lineCount = textArea . getLineCount ( ) ; int firstLine = textArea . getFirstLine ( ) ; int visibleLines = textArea . getVisibleLines ( ) ; int line = textArea . getCaretLine ( ) ; if ( lineCount > visibleLines ) { firstLine += visibleLines ; if ( firstLine + visibleLines >= lineCount - 1 ) { firstLine = lineCount - visibleLines ; } textArea . setFirstLine ( firstLine ) ; int caret = textArea . getLineStartOffset ( Math . min ( textArea . getLineCount ( ) - 1 , line + visibleLines ) ) ; if ( select ) textArea . select ( textArea . getMarkPosition ( ) , caret ) ; else textArea . setCaretPosition ( caret ) ; } } } public static class next_word implements ActionListener { private boolean select ; public next_word ( boolean select ) { this . select = select ; } public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; int caret = textArea . getCaretPosition ( ) ; int line = textArea . getCaretLine ( ) ; int lineStart = textArea . getLineStartOffset ( line ) ; caret -= lineStart ; String lineText = textArea . getLineText ( textArea . getCaretLine ( ) ) ; if ( caret == lineText . length ( ) ) { if ( lineStart + caret == textArea . getDocumentLength ( ) ) { textArea . getToolkit ( ) . beep ( ) ; return ; } caret ++ ; } else { String noWordSep = ( String ) textArea . getDocument ( ) . getProperty ( "noWordSep" ) ; caret = findWordEnd ( lineText , caret , noWordSep ) ; } if ( select ) textArea . select ( textArea . getMarkPosition ( ) , lineStart + caret ) ; else textArea . setCaretPosition ( lineStart + caret ) ; } } public static class overwrite implements ActionListener { public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; textArea . setOverwriteEnabled ( ! textArea . isOverwriteEnabled ( ) ) ; } } public static class prev_char implements ActionListener { private boolean select ; public prev_char ( boolean select ) { this . select = select ; } public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; int caret = textArea . getCaretPosition ( ) ; if ( caret == 0 ) { textArea . getToolkit ( ) . beep ( ) ; return ; } if ( select ) { textArea . select ( textArea . getMarkPosition ( ) , caret - 1 ) ; } else { int start = textArea . getSelectionStart ( ) ; int end = textArea . getSelectionStop ( ) ; if ( start != end ) { textArea . select ( start , start ) ; } else { textArea . setCaretPosition ( caret - 1 ) ; } } } } public static class prev_line implements ActionListener { private boolean select ; public prev_line ( boolean select ) { this . select = select ; } public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; int caret = textArea . getCaretPosition ( ) ; int line = textArea . getCaretLine ( ) ; if ( line == 0 ) { if ( select ) { if ( textArea . getSelectionStart ( ) != 0 ) { textArea . select ( textArea . getMarkPosition ( ) , 0 ) ; } } else { textArea . setCaretPosition ( 0 ) ; } return ; } int magic = textArea . getMagicCaretPosition ( ) ; if ( magic == - 1 ) { magic = textArea . offsetToX ( line , caret - textArea . getLineStartOffset ( line ) ) ; } caret = textArea . getLineStartOffset ( line - 1 ) + textArea . xToOffset ( line - 1 , magic ) ; if ( select ) textArea . select ( textArea . getMarkPosition ( ) , caret ) ; else textArea . setCaretPosition ( caret ) ; textArea . setMagicCaretPosition ( magic ) ; } } public static class prev_page implements ActionListener { private boolean select ; public prev_page ( boolean select ) { this . select = select ; } public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; int firstLine = textArea . getFirstLine ( ) ; int visibleLines = textArea . getVisibleLines ( ) ; int line = textArea . getCaretLine ( ) ; if ( firstLine < visibleLines ) firstLine = visibleLines ; textArea . setFirstLine ( firstLine - visibleLines ) ; int caret = textArea . getLineStartOffset ( Math . max ( 0 , line - visibleLines ) ) ; if ( select ) textArea . select ( textArea . getMarkPosition ( ) , caret ) ; else textArea . setCaretPosition ( caret ) ; } } public static class prev_word implements ActionListener { private boolean select ; public prev_word ( boolean select ) { this . select = select ; } public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; int caret = textArea . getCaretPosition ( ) ; int line = textArea . getCaretLine ( ) ; int lineStart = textArea . getLineStartOffset ( line ) ; caret -= lineStart ; String lineText = textArea . getLineText ( textArea . getCaretLine ( ) ) ; if ( caret == 0 ) { if ( lineStart == 0 ) { textArea . getToolkit ( ) . beep ( ) ; return ; } caret -- ; } else { String noWordSep = ( String ) textArea . getDocument ( ) . getProperty ( "noWordSep" ) ; caret = findWordStart ( lineText , caret , noWordSep ) ; } if ( select ) textArea . select ( textArea . getMarkPosition ( ) , lineStart + caret ) ; else textArea . setCaretPosition ( lineStart + caret ) ; } } public static class repeat implements ActionListener , InputHandler . NonRecordable { public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; textArea . getInputHandler ( ) . setRepeatEnabled ( true ) ; String actionCommand = evt . getActionCommand ( ) ; if ( actionCommand != null ) { textArea . getInputHandler ( ) . setRepeatCount ( Integer . parseInt ( actionCommand ) ) ; } } } public static class toggle_rect implements ActionListener { public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; textArea . setSelectionRectangular ( ! textArea . isSelectionRectangular ( ) ) ; } } public static class clipboard_cut implements ActionListener { public void actionPerformed ( ActionEvent evt ) { getTextArea ( evt ) . cut ( ) ; } } public static class clipboard_copy implements ActionListener { public void actionPerformed ( ActionEvent evt ) { getTextArea ( evt ) . copy ( ) ; } } public static class clipboard_paste implements ActionListener { public void actionPerformed ( ActionEvent evt ) { getTextArea ( evt ) . paste ( ) ; } } public static class insert_char implements ActionListener , InputHandler . NonRepeatable { public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; String str = evt . getActionCommand ( ) ; int repeatCount = textArea . getInputHandler ( ) . getRepeatCount ( ) ; if ( textArea . isEditable ( ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < repeatCount ; i ++ ) sb . append ( str ) ; textArea . overwriteSetSelectedText ( sb . toString ( ) ) ; } else { textArea . getToolkit ( ) . beep ( ) ; } } } public static int findWordStart ( String line , int pos , String noWordSep ) { char ch = line . charAt ( pos - 1 ) ; if ( noWordSep == null ) noWordSep = "" ; boolean selectNoLetter = ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) ; int wordStart = 0 ; for ( int i = pos - 1 ; i >= 0 ; i -- ) { ch = line . charAt ( i ) ; if ( selectNoLetter ^ ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) ) { wordStart = i + 1 ; break ; } } return wordStart ; } public static int findWordEnd ( String line , int pos , String noWordSep ) { char ch = line . charAt ( pos ) ; if ( noWordSep == null ) noWordSep = "" ; boolean selectNoLetter = ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) ; int wordEnd = line . length ( ) ; for ( int i = pos ; i < line . length ( ) ; i ++ ) { ch = line . charAt ( i ) ; if ( selectNoLetter ^ ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) ) { wordEnd = i ; break ; } } return wordEnd ; } }
package processing . app . syntax ; import processing . app . * ; import java . awt . * ; import java . awt . datatransfer . * ; import java . awt . event . * ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . Vector ; import javax . swing . event . * ; import javax . swing . text . * ; import javax . swing . undo . * ; import javax . swing . * ; import java . awt . im . InputMethodRequests ; import java . awt . print . Printable ; import processing . app . syntax . im . InputMethodSupport ; import processing . core . PApplet ; public class JEditTextArea extends JComponent { public static String LEFT_OF_SCROLLBAR = "los" ; public static final int leftHandGutter = 6 ; private InputMethodSupport inputMethodSupport = null ; private Brackets bracketHelper = new Brackets ( ) ; public JEditTextArea ( TextAreaDefaults defaults , InputHandler inputHandler ) { enableEvents ( AWTEvent . KEY_EVENT_MASK ) ; if ( ! DISABLE_CARET ) { caretTimer = new Timer ( 500 , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( hasFocus ( ) ) { blinkCaret ( ) ; } } } ) ; caretTimer . setInitialDelay ( 500 ) ; caretTimer . start ( ) ; } painter = createPainter ( defaults ) ; documentHandler = new DocumentHandler ( ) ; eventListenerList = new EventListenerList ( ) ; caretEvent = new MutableCaretEvent ( ) ; lineSegment = new Segment ( ) ; bracketLine = bracketPosition = - 1 ; blink = true ; setLayout ( new ScrollLayout ( ) ) ; add ( CENTER , painter ) ; add ( RIGHT , vertical = new JScrollBar ( Adjustable . VERTICAL ) ) ; add ( BOTTOM , horizontal = new JScrollBar ( Adjustable . HORIZONTAL ) ) ; vertical . addAdjustmentListener ( new AdjustHandler ( ) ) ; horizontal . addAdjustmentListener ( new AdjustHandler ( ) ) ; painter . addComponentListener ( new ComponentHandler ( ) ) ; painter . addMouseListener ( new MouseHandler ( ) ) ; painter . addMouseMotionListener ( new DragHandler ( ) ) ; addFocusListener ( new FocusHandler ( ) ) ; setFocusTraversalKeysEnabled ( false ) ; setInputHandler ( inputHandler ) ; setDocument ( defaults . document ) ; caretVisible = defaults . caretVisible ; caretBlinks = defaults . caretBlinks ; electricScroll = defaults . electricScroll ; addMouseWheelListener ( new MouseWheelListener ( ) { @ Override public void mouseWheelMoved ( MouseWheelEvent e ) { if ( scrollBarsInitialized ) { if ( e . getScrollType ( ) == MouseWheelEvent . WHEEL_UNIT_SCROLL ) { int scrollAmount = e . getUnitsToScroll ( ) ; boolean isHorizontal = Base . isMacOS ( ) && e . isShiftDown ( ) ; if ( isHorizontal ) { horizontal . setValue ( horizontal . getValue ( ) + scrollAmount ) ; } else { vertical . setValue ( vertical . getValue ( ) + scrollAmount ) ; } } } } } ) ; } protected TextAreaPainter createPainter ( final TextAreaDefaults defaults ) { return new TextAreaPainter ( this , defaults ) ; } public InputMethodRequests getInputMethodRequests ( ) { if ( Preferences . getBoolean ( "editor.input_method_support" ) ) { if ( inputMethodSupport == null ) { inputMethodSupport = new InputMethodSupport ( this ) ; } return inputMethodSupport ; } return null ; } public int getScrollPosition ( ) { return getVerticalScrollPosition ( ) ; } public void setScrollPosition ( int what ) { setVerticalScrollPosition ( what ) ; } public int getVerticalScrollPosition ( ) { return vertical . getValue ( ) ; } public void setVerticalScrollPosition ( int what ) { vertical . setValue ( what ) ; } public int getHorizontalScrollPosition ( ) { return horizontal . getValue ( ) ; } public void setHorizontalScrollPosition ( int what ) { horizontal . setValue ( what ) ; } public final TextAreaPainter getPainter ( ) { return painter ; } public final Printable getPrintable ( ) { return painter . getPrintable ( ) ; } public final InputHandler getInputHandler ( ) { return inputHandler ; } public void setInputHandler ( InputHandler inputHandler ) { this . inputHandler = inputHandler ; } public final boolean isCaretBlinkEnabled ( ) { return caretBlinks ; } public void setCaretBlinkEnabled ( boolean caretBlinks ) { this . caretBlinks = caretBlinks ; if ( ! caretBlinks ) { blink = false ; } painter . invalidateSelectedLines ( ) ; } public final boolean isCaretVisible ( ) { return ( ! caretBlinks || blink ) && caretVisible ; } public void setCaretVisible ( boolean caretVisible ) { this . caretVisible = caretVisible ; blink = true ; painter . invalidateSelectedLines ( ) ; } public final void blinkCaret ( ) { if ( caretBlinks ) { blink = ! blink ; painter . invalidateSelectedLines ( ) ; } else { blink = true ; } } public final int getElectricScroll ( ) { return electricScroll ; } public final void setElectricScroll ( int electricScroll ) { this . electricScroll = electricScroll ; } public void updateScrollBars ( ) { if ( vertical != null && visibleLines != 0 ) { vertical . setValues ( firstLine , visibleLines , 0 , getLineCount ( ) ) ; vertical . setUnitIncrement ( 2 ) ; vertical . setBlockIncrement ( visibleLines ) ; } if ( ( horizontal != null ) && ( painter . getWidth ( ) != 0 ) ) { int lineCount = getLineCount ( ) ; int maxLineLength = 0 ; for ( int i = 0 ; i < lineCount ; i ++ ) { int lineLength = getLineLength ( i ) ; if ( lineLength > maxLineLength ) { maxLineLength = lineLength ; } } int charWidth = painter . getFontMetrics ( ) . charWidth ( 'w' ) ; int width = maxLineLength * charWidth ; int painterWidth = painter . getWidth ( ) ; if ( horizontalOffset < 0 ) { horizontal . setValues ( - horizontalOffset , painterWidth , - leftHandGutter , width ) ; } else { horizontal . setValues ( - leftHandGutter , painterWidth , - leftHandGutter , width ) ; } horizontal . setUnitIncrement ( charWidth ) ; horizontal . setBlockIncrement ( width / 2 ) ; } } public final int getFirstLine ( ) { return firstLine ; } public void setFirstLine ( int firstLine ) { if ( firstLine < 0 || firstLine > getLineCount ( ) ) { throw new IllegalArgumentException ( "First line out of range: " + firstLine + " [0, " + getLineCount ( ) + "]" ) ; } if ( firstLine == this . firstLine ) return ; this . firstLine = firstLine ; if ( firstLine != vertical . getValue ( ) ) { updateScrollBars ( ) ; } painter . repaint ( ) ; } public final int getLastLine ( ) { return getFirstLine ( ) + getVisibleLines ( ) ; } public final int getVisibleLines ( ) { return visibleLines ; } public final void recalculateVisibleLines ( ) { if ( painter == null ) return ; int height = painter . getHeight ( ) ; int lineHeight = painter . getFontMetrics ( ) . getHeight ( ) ; visibleLines = height / lineHeight ; updateScrollBars ( ) ; } public final int getHorizontalOffset ( ) { return horizontalOffset ; } public void setHorizontalOffset ( int horizontalOffset ) { if ( horizontalOffset == this . horizontalOffset ) { return ; } this . horizontalOffset = horizontalOffset ; if ( horizontalOffset != horizontal . getValue ( ) ) { updateScrollBars ( ) ; } painter . repaint ( ) ; } public boolean setOrigin ( int firstLine , int horizontalOffset ) { boolean changed = false ; if ( horizontalOffset != this . horizontalOffset ) { this . horizontalOffset = horizontalOffset ; changed = true ; } if ( firstLine != this . firstLine ) { this . firstLine = firstLine ; changed = true ; } if ( changed ) { updateScrollBars ( ) ; painter . repaint ( ) ; } return changed ; } public boolean scrollToCaret ( ) { int line = getCaretLine ( ) ; int lineStart = getLineStartOffset ( line ) ; int offset = Math . max ( 0 , Math . min ( getLineLength ( line ) - 1 , getCaretPosition ( ) - lineStart ) ) ; return scrollTo ( line , offset ) ; } public boolean scrollTo ( int line , int offset ) { if ( visibleLines == 0 ) { setFirstLine ( Math . max ( 0 , line - electricScroll ) ) ; return true ; } int newFirstLine = firstLine ; int newHorizontalOffset = horizontalOffset ; if ( line < firstLine + electricScroll ) { newFirstLine = Math . max ( 0 , line - electricScroll ) ; } else if ( line + electricScroll >= firstLine + visibleLines ) { newFirstLine = ( line - visibleLines ) + electricScroll + 1 ; if ( newFirstLine + visibleLines >= getLineCount ( ) ) newFirstLine = getLineCount ( ) - visibleLines ; if ( newFirstLine < 0 ) newFirstLine = 0 ; } int x = _offsetToX ( line , offset ) ; int width = painter . getFontMetrics ( ) . charWidth ( 'w' ) ; if ( x < 0 ) { newHorizontalOffset = Math . max ( 0 , horizontalOffset - x + width + 5 ) ; } else if ( x + width >= painter . getWidth ( ) ) { newHorizontalOffset = horizontalOffset + ( painter . getWidth ( ) - x ) - width - 5 ; } return setOrigin ( newFirstLine , newHorizontalOffset ) ; } public int lineToY ( int line ) { FontMetrics fm = painter . getFontMetrics ( ) ; return ( line - firstLine ) * fm . getHeight ( ) - ( fm . getLeading ( ) + fm . getMaxDescent ( ) ) ; } public int yToLine ( int y ) { FontMetrics fm = painter . getFontMetrics ( ) ; int height = fm . getHeight ( ) ; return Math . max ( 0 , Math . min ( getLineCount ( ) - 1 , y / height + firstLine ) ) ; } public final int offsetToX ( int line , int offset ) { painter . currentLineTokens = null ; return _offsetToX ( line , offset ) ; } public int _offsetToX ( int line , int offset ) { TokenMarker tokenMarker = getTokenMarker ( ) ; FontMetrics fm = painter . getFontMetrics ( ) ; getLineText ( line , lineSegment ) ; int segmentOffset = lineSegment . offset ; int x = horizontalOffset ; if ( tokenMarker == null ) { lineSegment . count = offset ; return x + Utilities . getTabbedTextWidth ( lineSegment , fm , x , painter , 0 ) ; } else { Token tokens ; if ( painter . currentLineIndex == line && painter . currentLineTokens != null ) { tokens = painter . currentLineTokens ; } else { painter . currentLineIndex = line ; tokens = painter . currentLineTokens = tokenMarker . markTokens ( lineSegment , line ) ; } SyntaxStyle [ ] styles = painter . getStyles ( ) ; for ( ; ; ) { byte id = tokens . id ; if ( id == Token . END ) { return x ; } if ( id == Token . NULL ) { fm = painter . getFontMetrics ( ) ; } else { fm = painter . getFontMetrics ( styles [ id ] ) ; } int length = tokens . length ; if ( offset + segmentOffset < lineSegment . offset + length ) { lineSegment . count = offset - ( lineSegment . offset - segmentOffset ) ; return x + Utilities . getTabbedTextWidth ( lineSegment , fm , x , painter , 0 ) ; } else { lineSegment . count = length ; x += Utilities . getTabbedTextWidth ( lineSegment , fm , x , painter , 0 ) ; lineSegment . offset += length ; } tokens = tokens . next ; } } } public int xToOffset ( int line , int x ) { TokenMarker tokenMarker = getTokenMarker ( ) ; FontMetrics fm = painter . getFontMetrics ( ) ; getLineText ( line , lineSegment ) ; char [ ] segmentArray = lineSegment . array ; int segmentOffset = lineSegment . offset ; int segmentCount = lineSegment . count ; int width = horizontalOffset ; if ( tokenMarker == null ) { for ( int i = 0 ; i < segmentCount ; i ++ ) { char c = segmentArray [ i + segmentOffset ] ; int charWidth ; if ( c == '\t' ) charWidth = ( int ) painter . nextTabStop ( width , i ) - width ; else charWidth = fm . charWidth ( c ) ; if ( painter . isBlockCaretEnabled ( ) ) { if ( x - charWidth <= width ) return i ; } else { if ( x - charWidth / 2 <= width ) return i ; } width += charWidth ; } return segmentCount ; } else { Token tokens ; if ( painter . currentLineIndex == line && painter . currentLineTokens != null ) { tokens = painter . currentLineTokens ; } else { painter . currentLineIndex = line ; tokens = painter . currentLineTokens = tokenMarker . markTokens ( lineSegment , line ) ; } int offset = 0 ; SyntaxStyle [ ] styles = painter . getStyles ( ) ; for ( ; ; ) { byte id = tokens . id ; if ( id == Token . END ) return offset ; if ( id == Token . NULL ) { fm = painter . getFontMetrics ( ) ; } else { fm = painter . getFontMetrics ( styles [ id ] ) ; } int length = tokens . length ; for ( int i = 0 ; i < length ; i ++ ) { char c = segmentArray [ segmentOffset + offset + i ] ; int charWidth ; if ( c == '\t' ) { charWidth = ( int ) painter . nextTabStop ( width , offset + i ) - width ; } else { charWidth = fm . charWidth ( c ) ; } if ( painter . isBlockCaretEnabled ( ) ) { if ( x - charWidth <= width ) { return offset + i ; } } else { if ( x - charWidth / 2 <= width ) { return offset + i ; } } width += charWidth ; } offset += length ; tokens = tokens . next ; } } } public int xyToOffset ( int x , int y ) { int line = yToLine ( y ) ; int start = getLineStartOffset ( line ) ; return start + xToOffset ( line , x ) ; } public final SyntaxDocument getDocument ( ) { return document ; } public void setDocument ( SyntaxDocument document ) { if ( this . document == document ) return ; if ( this . document != null ) this . document . removeDocumentListener ( documentHandler ) ; this . document = document ; document . addDocumentListener ( documentHandler ) ; select ( 0 , 0 ) ; updateScrollBars ( ) ; painter . repaint ( ) ; } public void setDocument ( SyntaxDocument document , int start , int stop , int scroll ) { if ( this . document == document ) return ; if ( this . document != null ) this . document . removeDocumentListener ( documentHandler ) ; this . document = document ; document . addDocumentListener ( documentHandler ) ; select ( start , stop ) ; updateScrollBars ( ) ; setVerticalScrollPosition ( scroll ) ; painter . repaint ( ) ; } public final TokenMarker getTokenMarker ( ) { return document . getTokenMarker ( ) ; } public final void setTokenMarker ( TokenMarker tokenMarker ) { document . setTokenMarker ( tokenMarker ) ; } public final int getDocumentLength ( ) { return document . getLength ( ) ; } public final int getLineCount ( ) { return document . getDefaultRootElement ( ) . getElementCount ( ) ; } public final int getLineOfOffset ( int offset ) { return document . getDefaultRootElement ( ) . getElementIndex ( offset ) ; } public int getLineStartOffset ( int line ) { Element lineElement = document . getDefaultRootElement ( ) . getElement ( line ) ; return ( lineElement == null ) ? - 1 : lineElement . getStartOffset ( ) ; } public int getLineStartNonWhiteSpaceOffset ( int line ) { int offset = getLineStartOffset ( line ) ; int length = getLineLength ( line ) ; String str = getText ( offset , length ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! Character . isWhitespace ( str . charAt ( i ) ) ) { return offset + i ; } } return offset + length ; } public int getLineStopOffset ( int line ) { Element lineElement = document . getDefaultRootElement ( ) . getElement ( line ) ; return ( lineElement == null ) ? - 1 : lineElement . getEndOffset ( ) ; } public int getLineStopNonWhiteSpaceOffset ( int line ) { int offset = getLineStopOffset ( line ) ; int length = getLineLength ( line ) ; String str = getText ( offset - length - 1 , length ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( ! Character . isWhitespace ( str . charAt ( length - i - 1 ) ) ) { return offset - i ; } } return offset - length ; } public int getLineSelectionStopOffset ( int line ) { Element lineElement = document . getDefaultRootElement ( ) . getElement ( line ) ; return ( lineElement == null ) ? - 1 : Math . min ( lineElement . getEndOffset ( ) , getDocumentLength ( ) ) ; } public int getLineLength ( int line ) { Element lineElement = document . getDefaultRootElement ( ) . getElement ( line ) ; return ( lineElement == null ) ? - 1 : lineElement . getEndOffset ( ) - lineElement . getStartOffset ( ) - 1 ; } public String getText ( ) { try { return document . getText ( 0 , document . getLength ( ) ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; return null ; } } public void setText ( String text ) { try { document . beginCompoundEdit ( ) ; document . remove ( 0 , document . getLength ( ) ) ; document . insertString ( 0 , text , null ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } finally { document . endCompoundEdit ( ) ; } } public final String getText ( int start , int len ) { try { return document . getText ( start , len ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; return null ; } } public final void getText ( int start , int len , Segment segment ) { try { document . getText ( start , len , segment ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; segment . offset = segment . count = 0 ; } } public final String getLineText ( int lineIndex ) { int start = getLineStartOffset ( lineIndex ) ; return getText ( start , getLineStopOffset ( lineIndex ) - start - 1 ) ; } public final void getLineText ( int lineIndex , Segment segment ) { int start = getLineStartOffset ( lineIndex ) ; getText ( start , getLineStopOffset ( lineIndex ) - start - 1 , segment ) ; } public final int getSelectionStart ( ) { return selectionStart ; } public int getSelectionStart ( int line ) { if ( line == selectionStartLine ) return selectionStart ; else if ( rectSelect ) { Element map = document . getDefaultRootElement ( ) ; int start = selectionStart - map . getElement ( selectionStartLine ) . getStartOffset ( ) ; Element lineElement = map . getElement ( line ) ; int lineStart = lineElement . getStartOffset ( ) ; int lineEnd = lineElement . getEndOffset ( ) - 1 ; return Math . min ( lineEnd , lineStart + start ) ; } else return getLineStartOffset ( line ) ; } public final int getSelectionStartLine ( ) { return selectionStartLine ; } public final void setSelectionStart ( int selectionStart ) { select ( selectionStart , selectionEnd ) ; } public final int getSelectionStop ( ) { return selectionEnd ; } public int getSelectionStop ( int line ) { if ( line == selectionEndLine ) return selectionEnd ; else if ( rectSelect ) { Element map = document . getDefaultRootElement ( ) ; int end = selectionEnd - map . getElement ( selectionEndLine ) . getStartOffset ( ) ; Element lineElement = map . getElement ( line ) ; int lineStart = lineElement . getStartOffset ( ) ; int lineEnd = lineElement . getEndOffset ( ) - 1 ; return Math . min ( lineEnd , lineStart + end ) ; } else return getLineStopOffset ( line ) - 1 ; } public final int getSelectionStopLine ( ) { return selectionEndLine ; } public final void setSelectionEnd ( int selectionEnd ) { select ( selectionStart , selectionEnd ) ; } public final boolean isSelectionActive ( ) { return ( selectionStart != selectionEnd ) ; } public final int getCaretPosition ( ) { return ( biasLeft ? selectionStart : selectionEnd ) ; } public final int getCaretLine ( ) { return ( biasLeft ? selectionStartLine : selectionEndLine ) ; } public final int getMarkPosition ( ) { return ( biasLeft ? selectionEnd : selectionStart ) ; } public final int getMarkLine ( ) { return ( biasLeft ? selectionEndLine : selectionStartLine ) ; } public final void setCaretPosition ( int caret ) { select ( caret , caret ) ; } public final void selectAll ( ) { select ( 0 , getDocumentLength ( ) ) ; } public final void selectNone ( ) { select ( getCaretPosition ( ) , getCaretPosition ( ) ) ; } public void select ( int start , int end ) { int newStart , newEnd ; boolean newBias ; if ( start <= end ) { newStart = start ; newEnd = end ; newBias = false ; } else { newStart = end ; newEnd = start ; newBias = true ; } if ( ( newStart < 0 || newEnd > getDocumentLength ( ) ) && start != end ) { throw new IllegalArgumentException ( "Bounds out of" + " range: " + newStart + "," + newEnd + " [" + getDocumentLength ( ) + "]" ) ; } if ( newStart != selectionStart || newEnd != selectionEnd || newBias != biasLeft ) { int newStartLine = getLineOfOffset ( newStart ) ; int newEndLine = getLineOfOffset ( newEnd ) ; if ( painter . isBracketHighlightEnabled ( ) ) { if ( bracketLine != - 1 ) painter . invalidateLine ( bracketLine ) ; updateBracketHighlight ( end ) ; if ( bracketLine != - 1 ) painter . invalidateLine ( bracketLine ) ; } painter . invalidateLineRange ( selectionStartLine , selectionEndLine ) ; painter . invalidateLineRange ( newStartLine , newEndLine ) ; document . addUndoableEdit ( new CaretUndo ( selectionStart , selectionEnd ) ) ; selectionStart = newStart ; selectionEnd = newEnd ; selectionStartLine = newStartLine ; selectionEndLine = newEndLine ; biasLeft = newBias ; fireCaretEvent ( ) ; } blink = true ; if ( ! DISABLE_CARET ) { caretTimer . restart ( ) ; } if ( selectionStart == selectionEnd ) rectSelect = false ; magicCaret = - 1 ; scrollToCaret ( ) ; } private enum CharacterKinds { Word , Whitespace , Other } private CharacterKinds CharacterKind ( char ch , String noWordSep ) { if ( Character . isLetterOrDigit ( ch ) || ch == '_' || noWordSep . indexOf ( ch ) != - 1 ) return CharacterKinds . Word ; else if ( Character . isWhitespace ( ch ) ) return CharacterKinds . Whitespace ; else return CharacterKinds . Other ; } protected void setNewSelectionWord ( int line , int offset ) { if ( getLineLength ( line ) == 0 ) { newSelectionStart = getLineStartOffset ( line ) ; newSelectionEnd = newSelectionStart ; return ; } String noWordSep = ( String ) document . getProperty ( "noWordSep" ) ; if ( noWordSep == null ) noWordSep = "" ; String lineText = getLineText ( line ) ; int wordStart = 0 ; int wordEnd = lineText . length ( ) ; char ch = lineText . charAt ( Math . max ( 0 , offset - 1 ) ) ; CharacterKinds thisWord = CharacterKind ( ch , noWordSep ) ; for ( int i = offset - 1 ; i >= 0 ; i -- ) { ch = lineText . charAt ( i ) ; if ( CharacterKind ( ch , noWordSep ) != thisWord ) { wordStart = i + 1 ; break ; } } for ( int i = offset ; i < lineText . length ( ) ; i ++ ) { ch = lineText . charAt ( i ) ; if ( CharacterKind ( ch , noWordSep ) != thisWord ) { wordEnd = i ; break ; } } int lineStart = getLineStartOffset ( line ) ; newSelectionStart = lineStart + wordStart ; newSelectionEnd = lineStart + wordEnd ; } public final String getSelectedText ( ) { if ( selectionStart == selectionEnd ) return null ; if ( rectSelect ) { Element map = document . getDefaultRootElement ( ) ; int start = selectionStart - map . getElement ( selectionStartLine ) . getStartOffset ( ) ; int end = selectionEnd - map . getElement ( selectionEndLine ) . getStartOffset ( ) ; if ( end < start ) { int tmp = end ; end = start ; start = tmp ; } StringBuilder sb = new StringBuilder ( ) ; Segment seg = new Segment ( ) ; for ( int i = selectionStartLine ; i <= selectionEndLine ; i ++ ) { Element lineElement = map . getElement ( i ) ; int lineStart = lineElement . getStartOffset ( ) ; int lineEnd = lineElement . getEndOffset ( ) - 1 ; int lineLen = lineEnd - lineStart ; lineStart = Math . min ( lineStart + start , lineEnd ) ; lineLen = Math . min ( end - start , lineEnd - lineStart ) ; getText ( lineStart , lineLen , seg ) ; sb . append ( seg . array , seg . offset , seg . count ) ; if ( i != selectionEndLine ) sb . append ( '\n' ) ; } return sb . toString ( ) ; } else { return getText ( selectionStart , selectionEnd - selectionStart ) ; } } public void setSelectedText ( String selectedText ) { if ( ! editable ) { throw new InternalError ( "Text component read only" ) ; } document . beginCompoundEdit ( ) ; try { if ( rectSelect ) { Element map = document . getDefaultRootElement ( ) ; int start = selectionStart - map . getElement ( selectionStartLine ) . getStartOffset ( ) ; int end = selectionEnd - map . getElement ( selectionEndLine ) . getStartOffset ( ) ; if ( end < start ) { int tmp = end ; end = start ; start = tmp ; } int lastNewline = 0 ; int currNewline = 0 ; for ( int i = selectionStartLine ; i <= selectionEndLine ; i ++ ) { Element lineElement = map . getElement ( i ) ; int lineStart = lineElement . getStartOffset ( ) ; int lineEnd = lineElement . getEndOffset ( ) - 1 ; int rectStart = Math . min ( lineEnd , lineStart + start ) ; document . remove ( rectStart , Math . min ( lineEnd - rectStart , end - start ) ) ; if ( selectedText != null ) { currNewline = selectedText . indexOf ( '\n' , lastNewline ) ; if ( currNewline == - 1 ) { currNewline = selectedText . length ( ) ; } document . insertString ( rectStart , selectedText . substring ( lastNewline , currNewline ) , null ) ; lastNewline = Math . min ( selectedText . length ( ) , currNewline + 1 ) ; } } if ( selectedText != null && currNewline != selectedText . length ( ) ) { int offset = map . getElement ( selectionEndLine ) . getEndOffset ( ) - 1 ; document . insertString ( offset , "\n" , null ) ; document . insertString ( offset + 1 , selectedText . substring ( currNewline + 1 ) , null ) ; } } else { document . remove ( selectionStart , selectionEnd - selectionStart ) ; if ( selectedText != null ) { document . insertString ( selectionStart , selectedText , null ) ; } } } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; throw new InternalError ( "Cannot replace selection" ) ; } finally { document . endCompoundEdit ( ) ; } setCaretPosition ( selectionEnd ) ; } public final boolean isEditable ( ) { return editable ; } public final void setEditable ( boolean editable ) { this . editable = editable ; } public final JPopupMenu getRightClickPopup ( ) { return popup ; } public final void setRightClickPopup ( JPopupMenu popup ) { this . popup = popup ; } public final int getMagicCaretPosition ( ) { return magicCaret ; } public final void setMagicCaretPosition ( int magicCaret ) { this . magicCaret = magicCaret ; } public void overwriteSetSelectedText ( String str ) { if ( ! overwrite || selectionStart != selectionEnd ) { setSelectedText ( str ) ; return ; } int caret = getCaretPosition ( ) ; int caretLineEnd = getLineStopOffset ( getCaretLine ( ) ) ; if ( caretLineEnd - caret <= str . length ( ) ) { setSelectedText ( str ) ; return ; } document . beginCompoundEdit ( ) ; try { document . remove ( caret , str . length ( ) ) ; document . insertString ( caret , str , null ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } finally { document . endCompoundEdit ( ) ; } } public final boolean isOverwriteEnabled ( ) { return overwrite ; } public final void setOverwriteEnabled ( boolean overwrite ) { this . overwrite = overwrite ; painter . invalidateSelectedLines ( ) ; } public final boolean isSelectionRectangular ( ) { return rectSelect ; } public final void setSelectionRectangular ( boolean rectSelect ) { this . rectSelect = rectSelect ; painter . invalidateSelectedLines ( ) ; } public final int getBracketPosition ( ) { return bracketPosition ; } public final int getBracketLine ( ) { return bracketLine ; } public final void addCaretListener ( CaretListener listener ) { eventListenerList . add ( CaretListener . class , listener ) ; } public final void removeCaretListener ( CaretListener listener ) { eventListenerList . remove ( CaretListener . class , listener ) ; } public void cut ( ) { if ( editable ) { copy ( ) ; setSelectedText ( "" ) ; } } public void copy ( ) { if ( selectionStart != selectionEnd ) { Clipboard clipboard = getToolkit ( ) . getSystemClipboard ( ) ; String selection = getSelectedText ( ) ; int repeatCount = inputHandler . getRepeatCount ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < repeatCount ; i ++ ) sb . append ( selection ) ; clipboard . setContents ( new StringSelection ( sb . toString ( ) ) , null ) ; } } public void copyAsHTML ( ) { StringBuilder cf = new StringBuilder ( "<html><body><pre>\n" ) ; int selStart = getSelectionStart ( ) ; int selStop = getSelectionStop ( ) ; int startLine = getSelectionStartLine ( ) ; int stopLine = getSelectionStopLine ( ) ; if ( selStart == selStop ) { startLine = 0 ; stopLine = getLineCount ( ) - 1 ; } else { if ( getLineStartOffset ( stopLine ) == selStop ) { stopLine -- ; } } for ( int i = startLine ; i <= stopLine ; i ++ ) { emitAsHTML ( cf , i ) ; } cf . append ( "\n</pre></body></html>" ) ; HtmlSelection formatted = new HtmlSelection ( cf . toString ( ) ) ; Clipboard clipboard = processing . app . Toolkit . getSystemClipboard ( ) ; clipboard . setContents ( formatted , new ClipboardOwner ( ) { public void lostOwnership ( Clipboard clipboard , Transferable contents ) { } } ) ; } private void emitAsHTML ( StringBuilder cf , int line ) { Segment segment = new Segment ( ) ; getLineText ( line , segment ) ; char [ ] segmentArray = segment . array ; int limit = segment . getEndIndex ( ) ; int segmentOffset = segment . offset ; int segmentCount = segment . count ; TokenMarker tokenMarker = getTokenMarker ( ) ; if ( tokenMarker == null ) { for ( int j = 0 ; j < segmentCount ; j ++ ) { char c = segmentArray [ j + segmentOffset ] ; appendAsHTML ( cf , c ) ; } } else { Token tokens ; if ( ( painter . getCurrentLineIndex ( ) == line ) && ( painter . getCurrentLineTokens ( ) != null ) ) { tokens = painter . getCurrentLineTokens ( ) ; } else { painter . setCurrentLineIndex ( line ) ; painter . setCurrentLineTokens ( tokenMarker . markTokens ( segment , line ) ) ; tokens = painter . getCurrentLineTokens ( ) ; } int offset = 0 ; SyntaxStyle [ ] styles = painter . getStyles ( ) ; for ( ; ; ) { byte id = tokens . id ; if ( id == Token . END ) { char c = segmentArray [ segmentOffset + offset ] ; if ( segmentOffset + offset < limit ) { appendAsHTML ( cf , c ) ; } else { cf . append ( '\n' ) ; } return ; } if ( id != Token . NULL ) { cf . append ( "<span style=\"color: #" ) ; cf . append ( PApplet . hex ( styles [ id ] . getColor ( ) . getRGB ( ) & 0xFFFFFF , 6 ) ) ; cf . append ( ";\">" ) ; if ( styles [ id ] . isBold ( ) ) cf . append ( "<b>" ) ; } int length = tokens . length ; for ( int j = 0 ; j < length ; j ++ ) { char c = segmentArray [ segmentOffset + offset + j ] ; if ( offset == 0 && c == ' ' ) { cf . append ( "&nbsp;" ) ; } else { appendAsHTML ( cf , c ) ; } if ( j == ( length - 1 ) && id != Token . NULL && styles [ id ] . isBold ( ) ) cf . append ( "</b>" ) ; if ( j == ( length - 1 ) && id != Token . NULL ) cf . append ( "</span>" ) ; } offset += length ; tokens = tokens . next ; } } } private void appendAsHTML ( StringBuilder buffer , char c ) { if ( c == '<' ) { buffer . append ( "&lt;" ) ; } else if ( c == '>' ) { buffer . append ( "&gt;" ) ; } else if ( c == '&' ) { buffer . append ( "&amp;" ) ; } else if ( c == '\'' ) { buffer . append ( "&apos;" ) ; } else if ( c == '"' ) { buffer . append ( "&quot;" ) ; } else if ( c > 127 ) { buffer . append ( "&#" + ( ( int ) c ) + ";" ) ; } else { buffer . append ( c ) ; } } public void paste ( ) { if ( editable ) { Clipboard clipboard = getToolkit ( ) . getSystemClipboard ( ) ; try { String selection = ( ( String ) clipboard . getContents ( this ) . getTransferData ( DataFlavor . stringFlavor ) ) ; if ( selection . contains ( "\r\n" ) ) { selection = selection . replaceAll ( "\r\n" , "\n" ) ; } else if ( selection . contains ( "\r" ) ) { selection = selection . replace ( '\r' , '\n' ) ; } if ( selection . contains ( "\t" ) ) { int tabSize = Preferences . getInteger ( "editor.tabs.size" ) ; char [ ] c = new char [ tabSize ] ; Arrays . fill ( c , ' ' ) ; String tabString = new String ( c ) ; selection = selection . replaceAll ( "\t" , tabString ) ; } selection = selection . replace ( '\u00A0' , ' ' ) ; if ( selection . indexOf ( '\0' ) != - 1 ) { selection = selection . replaceAll ( "\0" , "" ) ; } int repeatCount = inputHandler . getRepeatCount ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < repeatCount ; i ++ ) { sb . append ( selection ) ; } selection = sb . toString ( ) ; setSelectedText ( selection ) ; } catch ( Exception e ) { getToolkit ( ) . beep ( ) ; System . err . println ( "Clipboard does not contain a string" ) ; } } } public void removeNotify ( ) { super . removeNotify ( ) ; if ( ! DISABLE_CARET ) { caretTimer . stop ( ) ; } } public void processKeyEvent ( KeyEvent event ) { super . processKeyEvent ( event ) ; if ( inputHandler != null ) { switch ( event . getID ( ) ) { case KeyEvent . KEY_TYPED : inputHandler . keyTyped ( event ) ; break ; case KeyEvent . KEY_PRESSED : inputHandler . keyPressed ( event ) ; break ; case KeyEvent . KEY_RELEASED : inputHandler . keyReleased ( event ) ; break ; } } } protected static String CENTER = "center" ; protected static String RIGHT = "right" ; protected static String BOTTOM = "bottom" ; protected Timer caretTimer ; private boolean DISABLE_CARET = false ; protected TextAreaPainter painter ; protected JPopupMenu popup ; protected EventListenerList eventListenerList ; protected MutableCaretEvent caretEvent ; protected boolean caretBlinks ; protected boolean caretVisible ; protected boolean blink ; protected boolean editable = true ; protected int firstLine ; protected int visibleLines ; protected int electricScroll ; protected int horizontalOffset ; protected JScrollBar vertical ; protected JScrollBar horizontal ; protected boolean scrollBarsInitialized ; protected InputHandler inputHandler ; protected SyntaxDocument document ; protected DocumentHandler documentHandler ; protected Segment lineSegment ; protected int selectionStart ; protected int selectionStartLine ; protected int selectionEnd ; protected int selectionEndLine ; protected boolean biasLeft ; protected int newSelectionStart ; protected int newSelectionEnd ; protected boolean selectWord ; protected boolean selectLine ; protected int selectionAncorStart ; protected int selectionAncorEnd ; protected int bracketPosition ; protected int bracketLine ; protected int magicCaret ; protected boolean overwrite ; protected boolean rectSelect ; protected void fireCaretEvent ( ) { Object [ ] listeners = eventListenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -- ) { if ( listeners [ i ] == CaretListener . class ) { ( ( CaretListener ) listeners [ i + 1 ] ) . caretUpdate ( caretEvent ) ; } } } protected void updateBracketHighlight ( int newCaretPosition ) { if ( newCaretPosition == 0 ) { bracketPosition = bracketLine = - 1 ; return ; } try { int offset = bracketHelper . findMatchingBracket ( document . getText ( 0 , document . getLength ( ) ) , newCaretPosition - 1 ) ; if ( offset != - 1 ) { bracketLine = getLineOfOffset ( offset ) ; bracketPosition = offset - getLineStartOffset ( bracketLine ) ; return ; } } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } bracketLine = bracketPosition = - 1 ; } protected void documentChanged ( DocumentEvent evt ) { bracketHelper . invalidate ( ) ; DocumentEvent . ElementChange ch = evt . getChange ( document . getDefaultRootElement ( ) ) ; int count ; if ( ch == null ) count = 0 ; else count = ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ; int line = getLineOfOffset ( evt . getOffset ( ) ) ; if ( count == 0 ) { painter . invalidateLine ( line ) ; } else if ( line < firstLine ) { setFirstLine ( line ) ; } else { painter . invalidateLineRange ( line , firstLine + visibleLines ) ; updateScrollBars ( ) ; } } class ScrollLayout implements LayoutManager { public void addLayoutComponent ( String name , Component comp ) { if ( name . equals ( CENTER ) ) center = comp ; else if ( name . equals ( RIGHT ) ) right = comp ; else if ( name . equals ( BOTTOM ) ) bottom = comp ; else if ( name . equals ( LEFT_OF_SCROLLBAR ) ) leftOfScrollBar . addElement ( comp ) ; } public void removeLayoutComponent ( Component comp ) { if ( center == comp ) center = null ; if ( right == comp ) right = null ; if ( bottom == comp ) bottom = null ; else leftOfScrollBar . removeElement ( comp ) ; } public Dimension preferredLayoutSize ( Container parent ) { Dimension dim = new Dimension ( ) ; Insets insets = getInsets ( ) ; dim . width = insets . left + insets . right ; dim . height = insets . top + insets . bottom ; Dimension centerPref = center . getPreferredSize ( ) ; dim . width += centerPref . width ; dim . height += centerPref . height ; Dimension rightPref = right . getPreferredSize ( ) ; dim . width += rightPref . width ; Dimension bottomPref = bottom . getPreferredSize ( ) ; dim . height += bottomPref . height ; return dim ; } public Dimension minimumLayoutSize ( Container parent ) { Dimension dim = new Dimension ( ) ; Insets insets = getInsets ( ) ; dim . width = insets . left + insets . right ; dim . height = insets . top + insets . bottom ; Dimension centerPref = center . getMinimumSize ( ) ; dim . width += centerPref . width ; dim . height += centerPref . height ; Dimension rightPref = right . getMinimumSize ( ) ; dim . width += rightPref . width ; Dimension bottomPref = bottom . getMinimumSize ( ) ; dim . height += bottomPref . height ; dim . height += 5 ; return dim ; } public void layoutContainer ( Container parent ) { Dimension size = parent . getSize ( ) ; Insets insets = parent . getInsets ( ) ; int itop = insets . top ; int ileft = insets . left ; int ibottom = insets . bottom ; int iright = insets . right ; int rightWidth = right . getPreferredSize ( ) . width ; int bottomHeight = bottom . getPreferredSize ( ) . height ; int centerWidth = size . width - rightWidth - ileft - iright ; int centerHeight = size . height - bottomHeight - itop - ibottom ; center . setBounds ( ileft , itop , centerWidth , centerHeight ) ; right . setBounds ( ileft + centerWidth , itop , rightWidth , centerHeight ) ; Enumeration status = leftOfScrollBar . elements ( ) ; while ( status . hasMoreElements ( ) ) { Component comp = ( Component ) status . nextElement ( ) ; Dimension dim = comp . getPreferredSize ( ) ; comp . setBounds ( ileft , itop + centerHeight , dim . width , bottomHeight ) ; ileft += dim . width ; } bottom . setBounds ( ileft , itop + centerHeight , size . width - rightWidth - ileft - iright , bottomHeight ) ; } private Component center ; private Component right ; private Component bottom ; private Vector leftOfScrollBar = new Vector ( ) ; } class MutableCaretEvent extends CaretEvent { MutableCaretEvent ( ) { super ( JEditTextArea . this ) ; } public int getDot ( ) { return getCaretPosition ( ) ; } public int getMark ( ) { return getMarkPosition ( ) ; } } class AdjustHandler implements AdjustmentListener { public void adjustmentValueChanged ( final AdjustmentEvent evt ) { if ( ! scrollBarsInitialized ) return ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { if ( evt . getAdjustable ( ) == vertical ) { setFirstLine ( vertical . getValue ( ) ) ; } else { setHorizontalOffset ( - horizontal . getValue ( ) ) ; } } } ) ; } } class ComponentHandler extends ComponentAdapter { public void componentResized ( ComponentEvent evt ) { recalculateVisibleLines ( ) ; scrollBarsInitialized = true ; } } class DocumentHandler implements DocumentListener { public void insertUpdate ( DocumentEvent evt ) { documentChanged ( evt ) ; int offset = evt . getOffset ( ) ; int length = evt . getLength ( ) ; int newStart ; int newEnd ; if ( selectionStart > offset || ( selectionStart == selectionEnd && selectionStart == offset ) ) newStart = selectionStart + length ; else newStart = selectionStart ; if ( selectionEnd >= offset ) newEnd = selectionEnd + length ; else newEnd = selectionEnd ; select ( newStart , newEnd ) ; } public void removeUpdate ( DocumentEvent evt ) { documentChanged ( evt ) ; int offset = evt . getOffset ( ) ; int length = evt . getLength ( ) ; int newStart ; int newEnd ; if ( selectionStart > offset ) { if ( selectionStart > offset + length ) newStart = selectionStart - length ; else newStart = offset ; } else newStart = selectionStart ; if ( selectionEnd > offset ) { if ( selectionEnd > offset + length ) newEnd = selectionEnd - length ; else newEnd = offset ; } else newEnd = selectionEnd ; select ( newStart , newEnd ) ; } public void changedUpdate ( DocumentEvent evt ) { } } class DragHandler implements MouseMotionListener { public void mouseDragged ( MouseEvent evt ) { if ( popup != null && popup . isVisible ( ) ) return ; if ( ! selectWord && ! selectLine ) { setSelectionRectangular ( evt . isControlDown ( ) ) ; try { select ( getMarkPosition ( ) , xyToOffset ( evt . getX ( ) , evt . getY ( ) ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { Base . loge ( "xToOffset problem" , e ) ; } } else { int line = yToLine ( evt . getY ( ) ) ; if ( selectWord ) { setNewSelectionWord ( line , xToOffset ( line , evt . getX ( ) ) ) ; } else { newSelectionStart = getLineStartOffset ( line ) ; newSelectionEnd = getLineSelectionStopOffset ( line ) ; } if ( newSelectionStart < selectionAncorStart ) { select ( newSelectionStart , selectionAncorEnd ) ; } else if ( newSelectionEnd > selectionAncorEnd ) { select ( selectionAncorStart , newSelectionEnd ) ; } else { select ( newSelectionStart , newSelectionEnd ) ; } } } public void mouseMoved ( MouseEvent evt ) { } } class FocusHandler implements FocusListener { public void focusGained ( FocusEvent evt ) { setCaretVisible ( true ) ; } public void focusLost ( FocusEvent evt ) { setCaretVisible ( false ) ; } } class MouseHandler extends MouseAdapter { public void mousePressed ( MouseEvent event ) { if ( ! hasFocus ( ) ) { requestFocusInWindow ( ) ; return ; } boolean windowsRightClick = Base . isWindows ( ) && ( event . getButton ( ) == MouseEvent . BUTTON3 ) ; if ( ( event . isPopupTrigger ( ) || windowsRightClick ) && ( popup != null ) ) { popup . show ( painter , event . getX ( ) , event . getY ( ) ) ; return ; } int line = yToLine ( event . getY ( ) ) ; int offset = xToOffset ( line , event . getX ( ) ) ; int dot = getLineStartOffset ( line ) + offset ; selectLine = false ; selectWord = false ; switch ( event . getClickCount ( ) ) { case 1 : doSingleClick ( event , line , offset , dot ) ; break ; case 2 : try { doDoubleClick ( event , line , offset , dot ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } break ; case 3 : doTripleClick ( event , line , offset , dot ) ; break ; } } private void doSingleClick ( MouseEvent evt , int line , int offset , int dot ) { if ( ( evt . getModifiers ( ) & InputEvent . SHIFT_MASK ) != 0 ) { rectSelect = ( evt . getModifiers ( ) & InputEvent . CTRL_MASK ) != 0 ; select ( getMarkPosition ( ) , dot ) ; } else { setCaretPosition ( dot ) ; } } private void doDoubleClick ( MouseEvent evt , int line , int offset , int dot ) throws BadLocationException { if ( getLineLength ( line ) != 0 ) { try { String text = document . getText ( 0 , document . getLength ( ) ) ; int bracket = bracketHelper . findMatchingBracket ( text , Math . max ( 0 , dot - 1 ) ) ; if ( bracket != - 1 ) { int mark = getMarkPosition ( ) ; if ( bracket > mark ) { bracket ++ ; mark -- ; } select ( mark , bracket ) ; return ; } } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } setNewSelectionWord ( line , offset ) ; select ( newSelectionStart , newSelectionEnd ) ; selectWord = true ; selectionAncorStart = selectionStart ; selectionAncorEnd = selectionEnd ; } } private void doTripleClick ( MouseEvent evt , int line , int offset , int dot ) { selectLine = true ; select ( getLineStartOffset ( line ) , getLineSelectionStopOffset ( line ) ) ; selectionAncorStart = selectionStart ; selectionAncorEnd = selectionEnd ; } } class CaretUndo extends AbstractUndoableEdit { private int start ; private int end ; CaretUndo ( int start , int end ) { this . start = start ; this . end = end ; } public boolean isSignificant ( ) { return false ; } public String getPresentationName ( ) { return "caret move" ; } public void undo ( ) throws CannotUndoException { super . undo ( ) ; select ( start , end ) ; } public void redo ( ) throws CannotRedoException { super . redo ( ) ; select ( start , end ) ; } public boolean addEdit ( UndoableEdit edit ) { if ( edit instanceof CaretUndo ) { CaretUndo cedit = ( CaretUndo ) edit ; start = cedit . start ; end = cedit . end ; cedit . die ( ) ; return true ; } return false ; } } }
package processing . app . syntax ; import java . awt . Color ; public class SyntaxStyle { private Color color ; private boolean bold ; public SyntaxStyle ( Color color , boolean bold ) { this . color = color ; this . bold = bold ; } public Color getColor ( ) { return color ; } public boolean isBold ( ) { return bold ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[color=" + color + ( bold ? ",bold" : "" ) + "]" ; } }
package processing . app . syntax ; import javax . swing . text . Segment ; public class KeywordMap { private boolean ignoreCase ; private Keyword [ ] literalMap ; private Keyword [ ] parenMap ; static private int MAP_LENGTH = 52 ; public KeywordMap ( boolean ignoreCase ) { this . ignoreCase = ignoreCase ; literalMap = new Keyword [ MAP_LENGTH ] ; parenMap = new Keyword [ MAP_LENGTH ] ; } public byte lookup ( Segment text , int offset , int length , boolean paren ) { if ( length == 0 ) { return Token . NULL ; } int key = getSegmentMapKey ( text , offset , length ) ; Keyword k = paren ? parenMap [ key ] : literalMap [ key ] ; while ( k != null ) { if ( length == k . keyword . length ) { if ( regionMatches ( ignoreCase , text , offset , k . keyword ) ) { return k . id ; } } k = k . next ; } return Token . NULL ; } static public boolean regionMatches ( boolean ignoreCase , Segment text , int offset , char [ ] match ) { int length = offset + match . length ; char [ ] textArray = text . array ; if ( length > text . offset + text . count ) return false ; for ( int i = offset , j = 0 ; i < length ; i ++ , j ++ ) { char c1 = textArray [ i ] ; char c2 = match [ j ] ; if ( ignoreCase ) { c1 = Character . toUpperCase ( c1 ) ; c2 = Character . toUpperCase ( c2 ) ; } if ( c1 != c2 ) return false ; } return true ; } public void add ( String keyword , byte id , boolean paren ) { int key = getStringMapKey ( keyword ) ; Keyword [ ] map = paren ? parenMap : literalMap ; map [ key ] = new Keyword ( keyword . toCharArray ( ) , id , map [ key ] ) ; } public boolean getIgnoreCase ( ) { return ignoreCase ; } public void setIgnoreCase ( boolean ignoreCase ) { this . ignoreCase = ignoreCase ; } protected int getStringMapKey ( String s ) { return ( Character . toUpperCase ( s . charAt ( 0 ) ) + Character . toUpperCase ( s . charAt ( s . length ( ) - 1 ) ) ) % MAP_LENGTH ; } protected int getSegmentMapKey ( Segment s , int off , int len ) { return ( Character . toUpperCase ( s . array [ off ] ) + Character . toUpperCase ( s . array [ off + len - 1 ] ) ) % MAP_LENGTH ; } private static class Keyword { public final char [ ] keyword ; public final byte id ; public final Keyword next ; public Keyword ( char [ ] keyword , byte id , Keyword next ) { this . keyword = keyword ; this . id = id ; this . next = next ; } } }
package processing . app . syntax ; import javax . swing . text . Segment ; public abstract class TokenMarker { abstract public void addColoring ( String keyword , String coloring ) ; public Token markTokens ( Segment line , int lineIndex ) { if ( lineIndex >= length ) { throw new IllegalArgumentException ( "Tokenizing invalid line: " + lineIndex ) ; } lastToken = null ; LineInfo info = lineInfo [ lineIndex ] ; LineInfo prev ; if ( lineIndex == 0 ) prev = null ; else prev = lineInfo [ lineIndex - 1 ] ; byte oldToken = info . token ; byte token = markTokensImpl ( prev == null ? Token . NULL : prev . token , line , lineIndex ) ; info . token = token ; if ( ! ( lastLine == lineIndex && nextLineRequested ) ) nextLineRequested = ( oldToken != token ) ; lastLine = lineIndex ; addToken ( 0 , Token . END ) ; return firstToken ; } protected abstract byte markTokensImpl ( byte token , Segment line , int lineIndex ) ; public boolean supportsMultilineTokens ( ) { return true ; } public void insertLines ( int index , int lines ) { if ( lines <= 0 ) return ; length += lines ; ensureCapacity ( length ) ; int len = index + lines ; System . arraycopy ( lineInfo , index , lineInfo , len , lineInfo . length - len ) ; for ( int i = index + lines - 1 ; i >= index ; i -- ) { lineInfo [ i ] = new LineInfo ( ) ; } } public void deleteLines ( int index , int lines ) { if ( lines <= 0 ) return ; int len = index + lines ; length -= lines ; System . arraycopy ( lineInfo , len , lineInfo , index , lineInfo . length - len ) ; } public int getLineCount ( ) { return length ; } public boolean isNextLineRequested ( ) { return nextLineRequested ; } protected Token firstToken ; protected Token lastToken ; protected LineInfo [ ] lineInfo ; protected int length ; protected int lastLine ; protected boolean nextLineRequested ; protected TokenMarker ( ) { lastLine = - 1 ; } protected void ensureCapacity ( int index ) { if ( lineInfo == null ) lineInfo = new LineInfo [ index + 1 ] ; else if ( lineInfo . length <= index ) { LineInfo [ ] lineInfoN = new LineInfo [ ( index + 1 ) * 2 ] ; System . arraycopy ( lineInfo , 0 , lineInfoN , 0 , lineInfo . length ) ; lineInfo = lineInfoN ; } } protected void addToken ( int length , byte id ) { if ( id >= Token . INTERNAL_FIRST && id <= Token . INTERNAL_LAST ) throw new InternalError ( "Invalid id: " + id ) ; if ( length == 0 && id != Token . END ) return ; if ( firstToken == null ) { firstToken = new Token ( length , id ) ; lastToken = firstToken ; } else if ( lastToken == null ) { lastToken = firstToken ; firstToken . length = length ; firstToken . id = id ; } else if ( lastToken . next == null ) { lastToken . next = new Token ( length , id ) ; lastToken = lastToken . next ; } else { lastToken = lastToken . next ; lastToken . length = length ; lastToken . id = id ; } } private static class LineInfo { public LineInfo ( ) { } public byte token ; } }
package processing . core ; import java . awt . Color ; import java . awt . Font ; import java . awt . FontMetrics ; import java . awt . Frame ; import java . awt . Image ; import java . awt . Toolkit ; import java . awt . font . FontRenderContext ; import java . util . HashMap ; import java . util . WeakHashMap ; import processing . opengl . PGL ; import processing . opengl . PShader ; public class PGraphics extends PImage implements PConstants { public int pixelCount ; public int smooth ; protected boolean settingsInited ; protected boolean reapplySettings ; protected PGraphics raw ; protected String path ; protected boolean primaryGraphics ; protected boolean [ ] hints = new boolean [ HINT_COUNT ] ; protected WeakHashMap < PImage , Object > cacheMap = new WeakHashMap < PImage , Object > ( ) ; static public final int R = 3 ; static public final int G = 4 ; static public final int B = 5 ; static public final int A = 6 ; static public final int U = 7 ; static public final int V = 8 ; static public final int NX = 9 ; static public final int NY = 10 ; static public final int NZ = 11 ; static public final int EDGE = 12 ; static public final int SR = 13 ; static public final int SG = 14 ; static public final int SB = 15 ; static public final int SA = 16 ; static public final int SW = 17 ; static public final int TX = 18 ; static public final int TY = 19 ; static public final int TZ = 20 ; static public final int VX = 21 ; static public final int VY = 22 ; static public final int VZ = 23 ; static public final int VW = 24 ; static public final int AR = 25 ; static public final int AG = 26 ; static public final int AB = 27 ; static public final int DR = 3 ; static public final int DG = 4 ; static public final int DB = 5 ; static public final int DA = 6 ; static public final int SPR = 28 ; static public final int SPG = 29 ; static public final int SPB = 30 ; static public final int SHINE = 31 ; static public final int ER = 32 ; static public final int EG = 33 ; static public final int EB = 34 ; static public final int BEEN_LIT = 35 ; static public final int HAS_NORMAL = 36 ; static public final int VERTEX_FIELD_COUNT = 37 ; public int colorMode ; public float colorModeX ; public float colorModeY ; public float colorModeZ ; public float colorModeA ; boolean colorModeScale ; boolean colorModeDefault ; public boolean tint ; public int tintColor ; protected boolean tintAlpha ; protected float tintR , tintG , tintB , tintA ; protected int tintRi , tintGi , tintBi , tintAi ; public boolean fill ; public int fillColor = 0xffFFFFFF ; protected boolean fillAlpha ; protected float fillR , fillG , fillB , fillA ; protected int fillRi , fillGi , fillBi , fillAi ; public boolean stroke ; public int strokeColor = 0xff000000 ; protected boolean strokeAlpha ; protected float strokeR , strokeG , strokeB , strokeA ; protected int strokeRi , strokeGi , strokeBi , strokeAi ; static protected final float DEFAULT_STROKE_WEIGHT = 1 ; static protected final int DEFAULT_STROKE_JOIN = MITER ; static protected final int DEFAULT_STROKE_CAP = ROUND ; public float strokeWeight = DEFAULT_STROKE_WEIGHT ; public int strokeJoin = DEFAULT_STROKE_JOIN ; public int strokeCap = DEFAULT_STROKE_CAP ; public int rectMode ; public int ellipseMode ; public int shapeMode ; public int imageMode = CORNER ; public PFont textFont ; public int textAlign = LEFT ; public int textAlignY = BASELINE ; public int textMode = MODEL ; public float textSize ; public float textLeading ; public int ambientColor ; public float ambientR , ambientG , ambientB ; public boolean setAmbient ; public int specularColor ; public float specularR , specularG , specularB ; public int emissiveColor ; public float emissiveR , emissiveG , emissiveB ; public float shininess ; static final int STYLE_STACK_DEPTH = 64 ; PStyle [ ] styleStack = new PStyle [ STYLE_STACK_DEPTH ] ; int styleStackDepth ; public int backgroundColor = 0xffCCCCCC ; protected boolean backgroundAlpha ; protected float backgroundR , backgroundG , backgroundB , backgroundA ; protected int backgroundRi , backgroundGi , backgroundBi , backgroundAi ; protected int blendMode ; static final int MATRIX_STACK_DEPTH = 32 ; public Image image ; protected PSurface surface ; protected float calcR , calcG , calcB , calcA ; protected int calcRi , calcGi , calcBi , calcAi ; protected int calcColor ; protected boolean calcAlpha ; int cacheHsbKey ; float [ ] cacheHsbValue = new float [ 3 ] ; protected int shape ; public static final int DEFAULT_VERTICES = 512 ; protected float vertices [ ] [ ] = new float [ DEFAULT_VERTICES ] [ VERTEX_FIELD_COUNT ] ; protected int vertexCount ; protected boolean bezierInited = false ; public int bezierDetail = 20 ; protected PMatrix3D bezierBasisMatrix = new PMatrix3D ( - 1 , 3 , - 3 , 1 , 3 , - 6 , 3 , 0 , - 3 , 3 , 0 , 0 , 1 , 0 , 0 , 0 ) ; protected PMatrix3D bezierDrawMatrix ; protected boolean curveInited = false ; public int curveDetail = 20 ; public float curveTightness = 0 ; protected PMatrix3D curveBasisMatrix ; protected PMatrix3D curveDrawMatrix ; protected PMatrix3D bezierBasisInverse ; protected PMatrix3D curveToBezierMatrix ; protected float curveVertices [ ] [ ] ; protected int curveVertexCount ; static final protected float sinLUT [ ] ; static final protected float cosLUT [ ] ; static final protected float SINCOS_PRECISION = 0.5f ; static final protected int SINCOS_LENGTH = ( int ) ( 360f / SINCOS_PRECISION ) ; static { sinLUT = new float [ SINCOS_LENGTH ] ; cosLUT = new float [ SINCOS_LENGTH ] ; for ( int i = 0 ; i < SINCOS_LENGTH ; i ++ ) { sinLUT [ i ] = ( float ) Math . sin ( i * DEG_TO_RAD * SINCOS_PRECISION ) ; cosLUT [ i ] = ( float ) Math . cos ( i * DEG_TO_RAD * SINCOS_PRECISION ) ; } } protected char [ ] textBuffer = new char [ 8 * 1024 ] ; protected char [ ] textWidthBuffer = new char [ 8 * 1024 ] ; protected int textBreakCount ; protected int [ ] textBreakStart ; protected int [ ] textBreakStop ; public boolean edge = true ; static protected final int NORMAL_MODE_AUTO = 0 ; static protected final int NORMAL_MODE_SHAPE = 1 ; static protected final int NORMAL_MODE_VERTEX = 2 ; protected int normalMode ; protected boolean autoNormal ; public float normalX , normalY , normalZ ; public int textureMode = IMAGE ; public float textureU ; public float textureV ; public PImage textureImage ; protected float sphereX [ ] , sphereY [ ] , sphereZ [ ] ; public int sphereDetailU = 0 ; public int sphereDetailV = 0 ; public PGraphics ( ) { } public void setParent ( PApplet parent ) { this . parent = parent ; smooth = parent . sketchSmooth ( ) ; pixelDensity = parent . sketchPixelDensity ( ) ; } public void setPrimary ( boolean primary ) { this . primaryGraphics = primary ; if ( primaryGraphics ) { format = RGB ; } } public void setPath ( String path ) { this . path = path ; } public void setSize ( int w , int h ) { width = w ; height = h ; pixelWidth = width * pixelDensity ; pixelHeight = height * pixelDensity ; reapplySettings = true ; } public void dispose ( ) { } public PSurface createSurface ( ) { return surface = new PSurfaceAWT ( this ) ; } public void setCache ( PImage image , Object storage ) { cacheMap . put ( image , storage ) ; } public Object getCache ( PImage image ) { return cacheMap . get ( image ) ; } public void removeCache ( PImage image ) { cacheMap . remove ( image ) ; } public boolean canDraw ( ) { return true ; } public void beginDraw ( ) { } public void endDraw ( ) { } public PGL beginPGL ( ) { showMethodWarning ( "beginGL" ) ; return null ; } public void endPGL ( ) { showMethodWarning ( "endGL" ) ; } public void flush ( ) { } protected void checkSettings ( ) { if ( ! settingsInited ) defaultSettings ( ) ; if ( reapplySettings ) reapplySettings ( ) ; } protected void defaultSettings ( ) { colorMode ( RGB , 255 ) ; fill ( 255 ) ; stroke ( 0 ) ; strokeWeight ( DEFAULT_STROKE_WEIGHT ) ; strokeJoin ( DEFAULT_STROKE_JOIN ) ; strokeCap ( DEFAULT_STROKE_CAP ) ; shape = 0 ; rectMode ( CORNER ) ; ellipseMode ( DIAMETER ) ; autoNormal = true ; textFont = null ; textSize = 12 ; textLeading = 14 ; textAlign = LEFT ; textMode = MODEL ; if ( primaryGraphics ) { background ( backgroundColor ) ; } blendMode ( BLEND ) ; settingsInited = true ; reapplySettings = false ; } protected void reapplySettings ( ) { if ( ! settingsInited ) return ; colorMode ( colorMode , colorModeX , colorModeY , colorModeZ ) ; if ( fill ) { fill ( fillColor ) ; } else { noFill ( ) ; } if ( stroke ) { stroke ( strokeColor ) ; strokeWeight ( strokeWeight ) ; strokeCap ( strokeCap ) ; strokeJoin ( strokeJoin ) ; } else { noStroke ( ) ; } if ( tint ) { tint ( tintColor ) ; } else { noTint ( ) ; } if ( textFont != null ) { float saveLeading = textLeading ; textFont ( textFont , textSize ) ; textLeading ( saveLeading ) ; } textMode ( textMode ) ; textAlign ( textAlign , textAlignY ) ; background ( backgroundColor ) ; blendMode ( blendMode ) ; reapplySettings = false ; } @ SuppressWarnings ( "deprecation" ) public void hint ( int which ) { if ( which == ENABLE_NATIVE_FONTS || which == DISABLE_NATIVE_FONTS ) { showWarning ( "hint(ENABLE_NATIVE_FONTS) no longer supported. " + "Use createFont() instead." ) ; } if ( which > 0 ) { hints [ which ] = true ; } else { hints [ - which ] = false ; } } public void beginShape ( ) { beginShape ( POLYGON ) ; } public void beginShape ( int kind ) { shape = kind ; } public void edge ( boolean edge ) { this . edge = edge ; } public void normal ( float nx , float ny , float nz ) { normalX = nx ; normalY = ny ; normalZ = nz ; if ( shape != 0 ) { if ( normalMode == NORMAL_MODE_AUTO ) { normalMode = NORMAL_MODE_SHAPE ; } else if ( normalMode == NORMAL_MODE_SHAPE ) { normalMode = NORMAL_MODE_VERTEX ; } } } public void attrib ( String name , float ... values ) { showMissingWarning ( "attrib" ) ; } public void attrib ( String name , int ... values ) { showMissingWarning ( "attrib" ) ; } public void attrib ( String name , boolean ... values ) { showMissingWarning ( "attrib" ) ; } public void textureMode ( int mode ) { if ( mode != IMAGE && mode != NORMAL ) { throw new RuntimeException ( "textureMode() only supports IMAGE and NORMAL" ) ; } this . textureMode = mode ; } public void textureWrap ( int wrap ) { showMissingWarning ( "textureWrap" ) ; } public void texture ( PImage image ) { textureImage = image ; } public void noTexture ( ) { textureImage = null ; } protected void vertexCheck ( ) { if ( vertexCount == vertices . length ) { float temp [ ] [ ] = new float [ vertexCount < < 1 ] [ VERTEX_FIELD_COUNT ] ; System . arraycopy ( vertices , 0 , temp , 0 , vertexCount ) ; vertices = temp ; } } public void vertex ( float x , float y ) { vertexCheck ( ) ; float [ ] vertex = vertices [ vertexCount ] ; curveVertexCount = 0 ; vertex [ X ] = x ; vertex [ Y ] = y ; vertex [ Z ] = 0 ; vertex [ EDGE ] = edge ? 1 : 0 ; boolean textured = textureImage != null ; if ( fill || textured ) { if ( ! textured ) { vertex [ R ] = fillR ; vertex [ G ] = fillG ; vertex [ B ] = fillB ; vertex [ A ] = fillA ; } else { if ( tint ) { vertex [ R ] = tintR ; vertex [ G ] = tintG ; vertex [ B ] = tintB ; vertex [ A ] = tintA ; } else { vertex [ R ] = 1 ; vertex [ G ] = 1 ; vertex [ B ] = 1 ; vertex [ A ] = 1 ; } } } if ( stroke ) { vertex [ SR ] = strokeR ; vertex [ SG ] = strokeG ; vertex [ SB ] = strokeB ; vertex [ SA ] = strokeA ; vertex [ SW ] = strokeWeight ; } if ( textured ) { vertex [ U ] = textureU ; vertex [ V ] = textureV ; } if ( autoNormal ) { float norm2 = normalX * normalX + normalY * normalY + normalZ * normalZ ; if ( norm2 < EPSILON ) { vertex [ HAS_NORMAL ] = 0 ; } else { if ( Math . abs ( norm2 - 1 ) > EPSILON ) { float norm = PApplet . sqrt ( norm2 ) ; normalX /= norm ; normalY /= norm ; normalZ /= norm ; } vertex [ HAS_NORMAL ] = 1 ; } } else { vertex [ HAS_NORMAL ] = 1 ; } vertexCount ++ ; } public void vertex ( float x , float y , float z ) { vertexCheck ( ) ; float [ ] vertex = vertices [ vertexCount ] ; if ( shape == POLYGON ) { if ( vertexCount > 0 ) { float pvertex [ ] = vertices [ vertexCount - 1 ] ; if ( ( Math . abs ( pvertex [ X ] - x ) < EPSILON ) && ( Math . abs ( pvertex [ Y ] - y ) < EPSILON ) && ( Math . abs ( pvertex [ Z ] - z ) < EPSILON ) ) { return ; } } } curveVertexCount = 0 ; vertex [ X ] = x ; vertex [ Y ] = y ; vertex [ Z ] = z ; vertex [ EDGE ] = edge ? 1 : 0 ; boolean textured = textureImage != null ; if ( fill || textured ) { if ( ! textured ) { vertex [ R ] = fillR ; vertex [ G ] = fillG ; vertex [ B ] = fillB ; vertex [ A ] = fillA ; } else { if ( tint ) { vertex [ R ] = tintR ; vertex [ G ] = tintG ; vertex [ B ] = tintB ; vertex [ A ] = tintA ; } else { vertex [ R ] = 1 ; vertex [ G ] = 1 ; vertex [ B ] = 1 ; vertex [ A ] = 1 ; } } vertex [ AR ] = ambientR ; vertex [ AG ] = ambientG ; vertex [ AB ] = ambientB ; vertex [ SPR ] = specularR ; vertex [ SPG ] = specularG ; vertex [ SPB ] = specularB ; vertex [ SHINE ] = shininess ; vertex [ ER ] = emissiveR ; vertex [ EG ] = emissiveG ; vertex [ EB ] = emissiveB ; } if ( stroke ) { vertex [ SR ] = strokeR ; vertex [ SG ] = strokeG ; vertex [ SB ] = strokeB ; vertex [ SA ] = strokeA ; vertex [ SW ] = strokeWeight ; } if ( textured ) { vertex [ U ] = textureU ; vertex [ V ] = textureV ; } if ( autoNormal ) { float norm2 = normalX * normalX + normalY * normalY + normalZ * normalZ ; if ( norm2 < EPSILON ) { vertex [ HAS_NORMAL ] = 0 ; } else { if ( Math . abs ( norm2 - 1 ) > EPSILON ) { float norm = PApplet . sqrt ( norm2 ) ; normalX /= norm ; normalY /= norm ; normalZ /= norm ; } vertex [ HAS_NORMAL ] = 1 ; } } else { vertex [ HAS_NORMAL ] = 1 ; } vertex [ NX ] = normalX ; vertex [ NY ] = normalY ; vertex [ NZ ] = normalZ ; vertex [ BEEN_LIT ] = 0 ; vertexCount ++ ; } public void vertex ( float [ ] v ) { vertexCheck ( ) ; curveVertexCount = 0 ; float [ ] vertex = vertices [ vertexCount ] ; System . arraycopy ( v , 0 , vertex , 0 , VERTEX_FIELD_COUNT ) ; vertexCount ++ ; } public void vertex ( float x , float y , float u , float v ) { vertexTexture ( u , v ) ; vertex ( x , y ) ; } public void vertex ( float x , float y , float z , float u , float v ) { vertexTexture ( u , v ) ; vertex ( x , y , z ) ; } protected void vertexTexture ( float u , float v ) { if ( textureImage == null ) { throw new RuntimeException ( "You must first call texture() before " + "using u and v coordinates with vertex()" ) ; } if ( textureMode == IMAGE ) { u /= textureImage . width ; v /= textureImage . height ; } textureU = u ; textureV = v ; if ( textureU < 0 ) textureU = 0 ; else if ( textureU > 1 ) textureU = 1 ; if ( textureV < 0 ) textureV = 0 ; else if ( textureV > 1 ) textureV = 1 ; } public void beginContour ( ) { showMissingWarning ( "beginContour" ) ; } public void endContour ( ) { showMissingWarning ( "endContour" ) ; } public void endShape ( ) { endShape ( OPEN ) ; } public void endShape ( int mode ) { } public PShape loadShape ( String filename ) { return loadShape ( filename , null ) ; } public PShape loadShape ( String filename , String options ) { showMissingWarning ( "loadShape" ) ; return null ; } public PShape createShape ( ) { return createShape ( PShape . GEOMETRY ) ; } public PShape createShape ( int type ) { if ( type == PConstants . GROUP || type == PShape . PATH || type == PShape . GEOMETRY ) { return createShapeFamily ( type ) ; } final String msg = "Only GROUP, PShape.PATH, and PShape.GEOMETRY work with createShape()" ; throw new IllegalArgumentException ( msg ) ; } protected PShape createShapeFamily ( int type ) { return new PShape ( this , type ) ; } public PShape createShape ( int kind , float ... p ) { int len = p . length ; if ( kind == POINT ) { if ( is3D ( ) && len != 2 && len != 3 ) { throw new IllegalArgumentException ( "Use createShape(POINT, x, y) or createShape(POINT, x, y, z)" ) ; } else if ( len != 2 ) { throw new IllegalArgumentException ( "Use createShape(POINT, x, y)" ) ; } return createShapePrimitive ( kind , p ) ; } else if ( kind == LINE ) { if ( is3D ( ) && len != 4 && len != 6 ) { throw new IllegalArgumentException ( "Use createShape(LINE, x1, y1, x2, y2) or createShape(LINE, x1, y1, z1, x2, y2, z1)" ) ; } else if ( len != 4 ) { throw new IllegalArgumentException ( "Use createShape(LINE, x1, y1, x2, y2)" ) ; } return createShapePrimitive ( kind , p ) ; } else if ( kind == TRIANGLE ) { if ( len != 6 ) { throw new IllegalArgumentException ( "Use createShape(TRIANGLE, x1, y1, x2, y2, x3, y3)" ) ; } return createShapePrimitive ( kind , p ) ; } else if ( kind == QUAD ) { if ( len != 8 ) { throw new IllegalArgumentException ( "Use createShape(QUAD, x1, y1, x2, y2, x3, y3, x4, y4)" ) ; } return createShapePrimitive ( kind , p ) ; } else if ( kind == RECT ) { if ( len != 4 && len != 5 && len != 8 && len != 9 ) { throw new IllegalArgumentException ( "Wrong number of parameters for createShape(RECT), see the reference" ) ; } return createShapePrimitive ( kind , p ) ; } else if ( kind == ELLIPSE ) { if ( len != 4 && len != 5 ) { throw new IllegalArgumentException ( "Use createShape(ELLIPSE, x, y, w, h) or createShape(ELLIPSE, x, y, w, h, mode)" ) ; } return createShapePrimitive ( kind , p ) ; } else if ( kind == ARC ) { if ( len != 6 && len != 7 ) { throw new IllegalArgumentException ( "Use createShape(ARC, x, y, w, h, start, stop)" ) ; } return createShapePrimitive ( kind , p ) ; } else if ( kind == BOX ) { if ( ! is3D ( ) ) { throw new IllegalArgumentException ( "createShape(BOX) is not supported in 2D" ) ; } else if ( len != 1 && len != 3 ) { throw new IllegalArgumentException ( "Use createShape(BOX, size) or createShape(BOX, width, height, depth)" ) ; } return createShapePrimitive ( kind , p ) ; } else if ( kind == SPHERE ) { if ( ! is3D ( ) ) { throw new IllegalArgumentException ( "createShape(SPHERE) is not supported in 2D" ) ; } else if ( len != 1 ) { throw new IllegalArgumentException ( "Use createShape(SPHERE, radius)" ) ; } return createShapePrimitive ( kind , p ) ; } throw new IllegalArgumentException ( "Unknown shape type passed to createShape()" ) ; } protected PShape createShapePrimitive ( int kind , float ... p ) { return new PShape ( this , kind , p ) ; } public PShader loadShader ( String fragFilename ) { showMissingWarning ( "loadShader" ) ; return null ; } public PShader loadShader ( String fragFilename , String vertFilename ) { showMissingWarning ( "loadShader" ) ; return null ; } public void shader ( PShader shader ) { showMissingWarning ( "shader" ) ; } public void shader ( PShader shader , int kind ) { showMissingWarning ( "shader" ) ; } public void resetShader ( ) { showMissingWarning ( "resetShader" ) ; } public void resetShader ( int kind ) { showMissingWarning ( "resetShader" ) ; } public void filter ( PShader shader ) { showMissingWarning ( "filter" ) ; } public void clip ( float a , float b , float c , float d ) { if ( imageMode == CORNER ) { if ( c < 0 ) { a += c ; c = - c ; } if ( d < 0 ) { b += d ; d = - d ; } clipImpl ( a , b , a + c , b + d ) ; } else if ( imageMode == CORNERS ) { if ( c < a ) { float temp = a ; a = c ; c = temp ; } if ( d < b ) { float temp = b ; b = d ; d = temp ; } clipImpl ( a , b , c , d ) ; } else if ( imageMode == CENTER ) { if ( c < 0 ) c = - c ; if ( d < 0 ) d = - d ; float x1 = a - c / 2 ; float y1 = b - d / 2 ; clipImpl ( x1 , y1 , x1 + c , y1 + d ) ; } } protected void clipImpl ( float x1 , float y1 , float x2 , float y2 ) { showMissingWarning ( "clip" ) ; } public void noClip ( ) { showMissingWarning ( "noClip" ) ; } public void blendMode ( int mode ) { this . blendMode = mode ; blendModeImpl ( ) ; } protected void blendModeImpl ( ) { if ( blendMode != BLEND ) { showMissingWarning ( "blendMode" ) ; } } protected void bezierVertexCheck ( ) { bezierVertexCheck ( shape , vertexCount ) ; } protected void bezierVertexCheck ( int shape , int vertexCount ) { if ( shape == 0 || shape != POLYGON ) { throw new RuntimeException ( "beginShape() or beginShape(POLYGON) " + "must be used before bezierVertex() or quadraticVertex()" ) ; } if ( vertexCount == 0 ) { throw new RuntimeException ( "vertex() must be used at least once " + "before bezierVertex() or quadraticVertex()" ) ; } } public void bezierVertex ( float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { bezierInitCheck ( ) ; bezierVertexCheck ( ) ; PMatrix3D draw = bezierDrawMatrix ; float [ ] prev = vertices [ vertexCount - 1 ] ; float x1 = prev [ X ] ; float y1 = prev [ Y ] ; float xplot1 = draw . m10 * x1 + draw . m11 * x2 + draw . m12 * x3 + draw . m13 * x4 ; float xplot2 = draw . m20 * x1 + draw . m21 * x2 + draw . m22 * x3 + draw . m23 * x4 ; float xplot3 = draw . m30 * x1 + draw . m31 * x2 + draw . m32 * x3 + draw . m33 * x4 ; float yplot1 = draw . m10 * y1 + draw . m11 * y2 + draw . m12 * y3 + draw . m13 * y4 ; float yplot2 = draw . m20 * y1 + draw . m21 * y2 + draw . m22 * y3 + draw . m23 * y4 ; float yplot3 = draw . m30 * y1 + draw . m31 * y2 + draw . m32 * y3 + draw . m33 * y4 ; for ( int j = 0 ; j < bezierDetail ; j ++ ) { x1 += xplot1 ; xplot1 += xplot2 ; xplot2 += xplot3 ; y1 += yplot1 ; yplot1 += yplot2 ; yplot2 += yplot3 ; vertex ( x1 , y1 ) ; } } public void bezierVertex ( float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { bezierInitCheck ( ) ; bezierVertexCheck ( ) ; PMatrix3D draw = bezierDrawMatrix ; float [ ] prev = vertices [ vertexCount - 1 ] ; float x1 = prev [ X ] ; float y1 = prev [ Y ] ; float z1 = prev [ Z ] ; float xplot1 = draw . m10 * x1 + draw . m11 * x2 + draw . m12 * x3 + draw . m13 * x4 ; float xplot2 = draw . m20 * x1 + draw . m21 * x2 + draw . m22 * x3 + draw . m23 * x4 ; float xplot3 = draw . m30 * x1 + draw . m31 * x2 + draw . m32 * x3 + draw . m33 * x4 ; float yplot1 = draw . m10 * y1 + draw . m11 * y2 + draw . m12 * y3 + draw . m13 * y4 ; float yplot2 = draw . m20 * y1 + draw . m21 * y2 + draw . m22 * y3 + draw . m23 * y4 ; float yplot3 = draw . m30 * y1 + draw . m31 * y2 + draw . m32 * y3 + draw . m33 * y4 ; float zplot1 = draw . m10 * z1 + draw . m11 * z2 + draw . m12 * z3 + draw . m13 * z4 ; float zplot2 = draw . m20 * z1 + draw . m21 * z2 + draw . m22 * z3 + draw . m23 * z4 ; float zplot3 = draw . m30 * z1 + draw . m31 * z2 + draw . m32 * z3 + draw . m33 * z4 ; for ( int j = 0 ; j < bezierDetail ; j ++ ) { x1 += xplot1 ; xplot1 += xplot2 ; xplot2 += xplot3 ; y1 += yplot1 ; yplot1 += yplot2 ; yplot2 += yplot3 ; z1 += zplot1 ; zplot1 += zplot2 ; zplot2 += zplot3 ; vertex ( x1 , y1 , z1 ) ; } } public void quadraticVertex ( float cx , float cy , float x3 , float y3 ) { float [ ] prev = vertices [ vertexCount - 1 ] ; float x1 = prev [ X ] ; float y1 = prev [ Y ] ; bezierVertex ( x1 + ( ( cx - x1 ) * 2 / 3.0f ) , y1 + ( ( cy - y1 ) * 2 / 3.0f ) , x3 + ( ( cx - x3 ) * 2 / 3.0f ) , y3 + ( ( cy - y3 ) * 2 / 3.0f ) , x3 , y3 ) ; } public void quadraticVertex ( float cx , float cy , float cz , float x3 , float y3 , float z3 ) { float [ ] prev = vertices [ vertexCount - 1 ] ; float x1 = prev [ X ] ; float y1 = prev [ Y ] ; float z1 = prev [ Z ] ; bezierVertex ( x1 + ( ( cx - x1 ) * 2 / 3.0f ) , y1 + ( ( cy - y1 ) * 2 / 3.0f ) , z1 + ( ( cz - z1 ) * 2 / 3.0f ) , x3 + ( ( cx - x3 ) * 2 / 3.0f ) , y3 + ( ( cy - y3 ) * 2 / 3.0f ) , z3 + ( ( cz - z3 ) * 2 / 3.0f ) , x3 , y3 , z3 ) ; } protected void curveVertexCheck ( ) { curveVertexCheck ( shape ) ; } protected void curveVertexCheck ( int shape ) { if ( shape != POLYGON ) { throw new RuntimeException ( "You must use beginShape() or " + "beginShape(POLYGON) before curveVertex()" ) ; } if ( curveVertices == null ) { curveVertices = new float [ 128 ] [ 3 ] ; } if ( curveVertexCount == curveVertices . length ) { float [ ] [ ] temp = new float [ curveVertexCount < < 1 ] [ 3 ] ; System . arraycopy ( curveVertices , 0 , temp , 0 , curveVertexCount ) ; curveVertices = temp ; } curveInitCheck ( ) ; } public void curveVertex ( float x , float y ) { curveVertexCheck ( ) ; float [ ] vertex = curveVertices [ curveVertexCount ] ; vertex [ X ] = x ; vertex [ Y ] = y ; curveVertexCount ++ ; if ( curveVertexCount > 3 ) { curveVertexSegment ( curveVertices [ curveVertexCount - 4 ] [ X ] , curveVertices [ curveVertexCount - 4 ] [ Y ] , curveVertices [ curveVertexCount - 3 ] [ X ] , curveVertices [ curveVertexCount - 3 ] [ Y ] , curveVertices [ curveVertexCount - 2 ] [ X ] , curveVertices [ curveVertexCount - 2 ] [ Y ] , curveVertices [ curveVertexCount - 1 ] [ X ] , curveVertices [ curveVertexCount - 1 ] [ Y ] ) ; } } public void curveVertex ( float x , float y , float z ) { curveVertexCheck ( ) ; float [ ] vertex = curveVertices [ curveVertexCount ] ; vertex [ X ] = x ; vertex [ Y ] = y ; vertex [ Z ] = z ; curveVertexCount ++ ; if ( curveVertexCount > 3 ) { curveVertexSegment ( curveVertices [ curveVertexCount - 4 ] [ X ] , curveVertices [ curveVertexCount - 4 ] [ Y ] , curveVertices [ curveVertexCount - 4 ] [ Z ] , curveVertices [ curveVertexCount - 3 ] [ X ] , curveVertices [ curveVertexCount - 3 ] [ Y ] , curveVertices [ curveVertexCount - 3 ] [ Z ] , curveVertices [ curveVertexCount - 2 ] [ X ] , curveVertices [ curveVertexCount - 2 ] [ Y ] , curveVertices [ curveVertexCount - 2 ] [ Z ] , curveVertices [ curveVertexCount - 1 ] [ X ] , curveVertices [ curveVertexCount - 1 ] [ Y ] , curveVertices [ curveVertexCount - 1 ] [ Z ] ) ; } } protected void curveVertexSegment ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { float x0 = x2 ; float y0 = y2 ; PMatrix3D draw = curveDrawMatrix ; float xplot1 = draw . m10 * x1 + draw . m11 * x2 + draw . m12 * x3 + draw . m13 * x4 ; float xplot2 = draw . m20 * x1 + draw . m21 * x2 + draw . m22 * x3 + draw . m23 * x4 ; float xplot3 = draw . m30 * x1 + draw . m31 * x2 + draw . m32 * x3 + draw . m33 * x4 ; float yplot1 = draw . m10 * y1 + draw . m11 * y2 + draw . m12 * y3 + draw . m13 * y4 ; float yplot2 = draw . m20 * y1 + draw . m21 * y2 + draw . m22 * y3 + draw . m23 * y4 ; float yplot3 = draw . m30 * y1 + draw . m31 * y2 + draw . m32 * y3 + draw . m33 * y4 ; int savedCount = curveVertexCount ; vertex ( x0 , y0 ) ; for ( int j = 0 ; j < curveDetail ; j ++ ) { x0 += xplot1 ; xplot1 += xplot2 ; xplot2 += xplot3 ; y0 += yplot1 ; yplot1 += yplot2 ; yplot2 += yplot3 ; vertex ( x0 , y0 ) ; } curveVertexCount = savedCount ; } protected void curveVertexSegment ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { float x0 = x2 ; float y0 = y2 ; float z0 = z2 ; PMatrix3D draw = curveDrawMatrix ; float xplot1 = draw . m10 * x1 + draw . m11 * x2 + draw . m12 * x3 + draw . m13 * x4 ; float xplot2 = draw . m20 * x1 + draw . m21 * x2 + draw . m22 * x3 + draw . m23 * x4 ; float xplot3 = draw . m30 * x1 + draw . m31 * x2 + draw . m32 * x3 + draw . m33 * x4 ; float yplot1 = draw . m10 * y1 + draw . m11 * y2 + draw . m12 * y3 + draw . m13 * y4 ; float yplot2 = draw . m20 * y1 + draw . m21 * y2 + draw . m22 * y3 + draw . m23 * y4 ; float yplot3 = draw . m30 * y1 + draw . m31 * y2 + draw . m32 * y3 + draw . m33 * y4 ; int savedCount = curveVertexCount ; float zplot1 = draw . m10 * z1 + draw . m11 * z2 + draw . m12 * z3 + draw . m13 * z4 ; float zplot2 = draw . m20 * z1 + draw . m21 * z2 + draw . m22 * z3 + draw . m23 * z4 ; float zplot3 = draw . m30 * z1 + draw . m31 * z2 + draw . m32 * z3 + draw . m33 * z4 ; vertex ( x0 , y0 , z0 ) ; for ( int j = 0 ; j < curveDetail ; j ++ ) { x0 += xplot1 ; xplot1 += xplot2 ; xplot2 += xplot3 ; y0 += yplot1 ; yplot1 += yplot2 ; yplot2 += yplot3 ; z0 += zplot1 ; zplot1 += zplot2 ; zplot2 += zplot3 ; vertex ( x0 , y0 , z0 ) ; } curveVertexCount = savedCount ; } public void point ( float x , float y ) { beginShape ( POINTS ) ; vertex ( x , y ) ; endShape ( ) ; } public void point ( float x , float y , float z ) { beginShape ( POINTS ) ; vertex ( x , y , z ) ; endShape ( ) ; } public void line ( float x1 , float y1 , float x2 , float y2 ) { beginShape ( LINES ) ; vertex ( x1 , y1 ) ; vertex ( x2 , y2 ) ; endShape ( ) ; } public void line ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { beginShape ( LINES ) ; vertex ( x1 , y1 , z1 ) ; vertex ( x2 , y2 , z2 ) ; endShape ( ) ; } public void triangle ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { beginShape ( TRIANGLES ) ; vertex ( x1 , y1 ) ; vertex ( x2 , y2 ) ; vertex ( x3 , y3 ) ; endShape ( ) ; } public void quad ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { beginShape ( QUADS ) ; vertex ( x1 , y1 ) ; vertex ( x2 , y2 ) ; vertex ( x3 , y3 ) ; vertex ( x4 , y4 ) ; endShape ( ) ; } public void rectMode ( int mode ) { rectMode = mode ; } public void rect ( float a , float b , float c , float d ) { float hradius , vradius ; switch ( rectMode ) { case CORNERS : break ; case CORNER : c += a ; d += b ; break ; case RADIUS : hradius = c ; vradius = d ; c = a + hradius ; d = b + vradius ; a -= hradius ; b -= vradius ; break ; case CENTER : hradius = c / 2.0f ; vradius = d / 2.0f ; c = a + hradius ; d = b + vradius ; a -= hradius ; b -= vradius ; } if ( a > c ) { float temp = a ; a = c ; c = temp ; } if ( b > d ) { float temp = b ; b = d ; d = temp ; } rectImpl ( a , b , c , d ) ; } protected void rectImpl ( float x1 , float y1 , float x2 , float y2 ) { quad ( x1 , y1 , x2 , y1 , x2 , y2 , x1 , y2 ) ; } public void rect ( float a , float b , float c , float d , float r ) { rect ( a , b , c , d , r , r , r , r ) ; } public void rect ( float a , float b , float c , float d , float tl , float tr , float br , float bl ) { float hradius , vradius ; switch ( rectMode ) { case CORNERS : break ; case CORNER : c += a ; d += b ; break ; case RADIUS : hradius = c ; vradius = d ; c = a + hradius ; d = b + vradius ; a -= hradius ; b -= vradius ; break ; case CENTER : hradius = c / 2.0f ; vradius = d / 2.0f ; c = a + hradius ; d = b + vradius ; a -= hradius ; b -= vradius ; } if ( a > c ) { float temp = a ; a = c ; c = temp ; } if ( b > d ) { float temp = b ; b = d ; d = temp ; } float maxRounding = PApplet . min ( ( c - a ) / 2 , ( d - b ) / 2 ) ; if ( tl > maxRounding ) tl = maxRounding ; if ( tr > maxRounding ) tr = maxRounding ; if ( br > maxRounding ) br = maxRounding ; if ( bl > maxRounding ) bl = maxRounding ; rectImpl ( a , b , c , d , tl , tr , br , bl ) ; } protected void rectImpl ( float x1 , float y1 , float x2 , float y2 , float tl , float tr , float br , float bl ) { beginShape ( ) ; if ( tr != 0 ) { vertex ( x2 - tr , y1 ) ; quadraticVertex ( x2 , y1 , x2 , y1 + tr ) ; } else { vertex ( x2 , y1 ) ; } if ( br != 0 ) { vertex ( x2 , y2 - br ) ; quadraticVertex ( x2 , y2 , x2 - br , y2 ) ; } else { vertex ( x2 , y2 ) ; } if ( bl != 0 ) { vertex ( x1 + bl , y2 ) ; quadraticVertex ( x1 , y2 , x1 , y2 - bl ) ; } else { vertex ( x1 , y2 ) ; } if ( tl != 0 ) { vertex ( x1 , y1 + tl ) ; quadraticVertex ( x1 , y1 , x1 + tl , y1 ) ; } else { vertex ( x1 , y1 ) ; } endShape ( CLOSE ) ; } public void ellipseMode ( int mode ) { ellipseMode = mode ; } public void ellipse ( float a , float b , float c , float d ) { float x = a ; float y = b ; float w = c ; float h = d ; if ( ellipseMode == CORNERS ) { w = c - a ; h = d - b ; } else if ( ellipseMode == RADIUS ) { x = a - c ; y = b - d ; w = c * 2 ; h = d * 2 ; } else if ( ellipseMode == DIAMETER ) { x = a - c / 2f ; y = b - d / 2f ; } if ( w < 0 ) { x += w ; w = - w ; } if ( h < 0 ) { y += h ; h = - h ; } ellipseImpl ( x , y , w , h ) ; } protected void ellipseImpl ( float x , float y , float w , float h ) { } public void arc ( float a , float b , float c , float d , float start , float stop ) { arc ( a , b , c , d , start , stop , 0 ) ; } public void arc ( float a , float b , float c , float d , float start , float stop , int mode ) { float x = a ; float y = b ; float w = c ; float h = d ; if ( ellipseMode == CORNERS ) { w = c - a ; h = d - b ; } else if ( ellipseMode == RADIUS ) { x = a - c ; y = b - d ; w = c * 2 ; h = d * 2 ; } else if ( ellipseMode == CENTER ) { x = a - c / 2f ; y = b - d / 2f ; } if ( ! Float . isInfinite ( start ) && ! Float . isInfinite ( stop ) ) { if ( stop > start ) { while ( start < 0 ) { start += TWO_PI ; stop += TWO_PI ; } if ( stop - start > TWO_PI ) { stop = start + TWO_PI ; } arcImpl ( x , y , w , h , start , stop , mode ) ; } } } protected void arcImpl ( float x , float y , float w , float h , float start , float stop , int mode ) { showMissingWarning ( "arc" ) ; } public void box ( float size ) { box ( size , size , size ) ; } public void box ( float w , float h , float d ) { float x1 = - w / 2f ; float x2 = w / 2f ; float y1 = - h / 2f ; float y2 = h / 2f ; float z1 = - d / 2f ; float z2 = d / 2f ; beginShape ( QUADS ) ; normal ( 0 , 0 , 1 ) ; vertex ( x1 , y1 , z1 ) ; vertex ( x2 , y1 , z1 ) ; vertex ( x2 , y2 , z1 ) ; vertex ( x1 , y2 , z1 ) ; normal ( 1 , 0 , 0 ) ; vertex ( x2 , y1 , z1 ) ; vertex ( x2 , y1 , z2 ) ; vertex ( x2 , y2 , z2 ) ; vertex ( x2 , y2 , z1 ) ; normal ( 0 , 0 , - 1 ) ; vertex ( x2 , y1 , z2 ) ; vertex ( x1 , y1 , z2 ) ; vertex ( x1 , y2 , z2 ) ; vertex ( x2 , y2 , z2 ) ; normal ( - 1 , 0 , 0 ) ; vertex ( x1 , y1 , z2 ) ; vertex ( x1 , y1 , z1 ) ; vertex ( x1 , y2 , z1 ) ; vertex ( x1 , y2 , z2 ) ; normal ( 0 , 1 , 0 ) ; vertex ( x1 , y1 , z2 ) ; vertex ( x2 , y1 , z2 ) ; vertex ( x2 , y1 , z1 ) ; vertex ( x1 , y1 , z1 ) ; normal ( 0 , - 1 , 0 ) ; vertex ( x1 , y2 , z1 ) ; vertex ( x2 , y2 , z1 ) ; vertex ( x2 , y2 , z2 ) ; vertex ( x1 , y2 , z2 ) ; endShape ( ) ; } public void sphereDetail ( int res ) { sphereDetail ( res , res ) ; } public void sphereDetail ( int ures , int vres ) { if ( ures < 3 ) ures = 3 ; if ( vres < 2 ) vres = 2 ; if ( ( ures == sphereDetailU ) && ( vres == sphereDetailV ) ) return ; float delta = ( float ) SINCOS_LENGTH / ures ; float [ ] cx = new float [ ures ] ; float [ ] cz = new float [ ures ] ; for ( int i = 0 ; i < ures ; i ++ ) { cx [ i ] = cosLUT [ ( int ) ( i * delta ) % SINCOS_LENGTH ] ; cz [ i ] = sinLUT [ ( int ) ( i * delta ) % SINCOS_LENGTH ] ; } int vertCount = ures * ( vres - 1 ) + 2 ; int currVert = 0 ; sphereX = new float [ vertCount ] ; sphereY = new float [ vertCount ] ; sphereZ = new float [ vertCount ] ; float angle_step = ( SINCOS_LENGTH * 0.5f ) / vres ; float angle = angle_step ; for ( int i = 1 ; i < vres ; i ++ ) { float curradius = sinLUT [ ( int ) angle % SINCOS_LENGTH ] ; float currY = cosLUT [ ( int ) angle % SINCOS_LENGTH ] ; for ( int j = 0 ; j < ures ; j ++ ) { sphereX [ currVert ] = cx [ j ] * curradius ; sphereY [ currVert ] = currY ; sphereZ [ currVert ++ ] = cz [ j ] * curradius ; } angle += angle_step ; } sphereDetailU = ures ; sphereDetailV = vres ; } public void sphere ( float r ) { if ( ( sphereDetailU < 3 ) || ( sphereDetailV < 2 ) ) { sphereDetail ( 30 ) ; } edge ( false ) ; beginShape ( TRIANGLE_STRIP ) ; for ( int i = 0 ; i < sphereDetailU ; i ++ ) { normal ( 0 , - 1 , 0 ) ; vertex ( 0 , - r , 0 ) ; normal ( sphereX [ i ] , sphereY [ i ] , sphereZ [ i ] ) ; vertex ( r * sphereX [ i ] , r * sphereY [ i ] , r * sphereZ [ i ] ) ; } normal ( 0 , - r , 0 ) ; vertex ( 0 , - r , 0 ) ; normal ( sphereX [ 0 ] , sphereY [ 0 ] , sphereZ [ 0 ] ) ; vertex ( r * sphereX [ 0 ] , r * sphereY [ 0 ] , r * sphereZ [ 0 ] ) ; endShape ( ) ; int v1 , v11 , v2 ; int voff = 0 ; for ( int i = 2 ; i < sphereDetailV ; i ++ ) { v1 = v11 = voff ; voff += sphereDetailU ; v2 = voff ; beginShape ( TRIANGLE_STRIP ) ; for ( int j = 0 ; j < sphereDetailU ; j ++ ) { normal ( sphereX [ v1 ] , sphereY [ v1 ] , sphereZ [ v1 ] ) ; vertex ( r * sphereX [ v1 ] , r * sphereY [ v1 ] , r * sphereZ [ v1 ++ ] ) ; normal ( sphereX [ v2 ] , sphereY [ v2 ] , sphereZ [ v2 ] ) ; vertex ( r * sphereX [ v2 ] , r * sphereY [ v2 ] , r * sphereZ [ v2 ++ ] ) ; } v1 = v11 ; v2 = voff ; normal ( sphereX [ v1 ] , sphereY [ v1 ] , sphereZ [ v1 ] ) ; vertex ( r * sphereX [ v1 ] , r * sphereY [ v1 ] , r * sphereZ [ v1 ] ) ; normal ( sphereX [ v2 ] , sphereY [ v2 ] , sphereZ [ v2 ] ) ; vertex ( r * sphereX [ v2 ] , r * sphereY [ v2 ] , r * sphereZ [ v2 ] ) ; endShape ( ) ; } beginShape ( TRIANGLE_STRIP ) ; for ( int i = 0 ; i < sphereDetailU ; i ++ ) { v2 = voff + i ; normal ( sphereX [ v2 ] , sphereY [ v2 ] , sphereZ [ v2 ] ) ; vertex ( r * sphereX [ v2 ] , r * sphereY [ v2 ] , r * sphereZ [ v2 ] ) ; normal ( 0 , 1 , 0 ) ; vertex ( 0 , r , 0 ) ; } normal ( sphereX [ voff ] , sphereY [ voff ] , sphereZ [ voff ] ) ; vertex ( r * sphereX [ voff ] , r * sphereY [ voff ] , r * sphereZ [ voff ] ) ; normal ( 0 , 1 , 0 ) ; vertex ( 0 , r , 0 ) ; endShape ( ) ; edge ( true ) ; } public float bezierPoint ( float a , float b , float c , float d , float t ) { float t1 = 1.0f - t ; return a * t1 * t1 * t1 + 3 * b * t * t1 * t1 + 3 * c * t * t * t1 + d * t * t * t ; } public float bezierTangent ( float a , float b , float c , float d , float t ) { return ( 3 * t * t * ( - a + 3 * b - 3 * c + d ) + 6 * t * ( a - 2 * b + c ) + 3 * ( - a + b ) ) ; } protected void bezierInitCheck ( ) { if ( ! bezierInited ) { bezierInit ( ) ; } } protected void bezierInit ( ) { bezierDetail ( bezierDetail ) ; bezierInited = true ; } public void bezierDetail ( int detail ) { bezierDetail = detail ; if ( bezierDrawMatrix == null ) { bezierDrawMatrix = new PMatrix3D ( ) ; } splineForward ( detail , bezierDrawMatrix ) ; bezierDrawMatrix . apply ( bezierBasisMatrix ) ; } public void bezier ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { beginShape ( ) ; vertex ( x1 , y1 ) ; bezierVertex ( x2 , y2 , x3 , y3 , x4 , y4 ) ; endShape ( ) ; } public void bezier ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { beginShape ( ) ; vertex ( x1 , y1 , z1 ) ; bezierVertex ( x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; endShape ( ) ; } public float curvePoint ( float a , float b , float c , float d , float t ) { curveInitCheck ( ) ; float tt = t * t ; float ttt = t * tt ; PMatrix3D cb = curveBasisMatrix ; return ( a * ( ttt * cb . m00 + tt * cb . m10 + t * cb . m20 + cb . m30 ) + b * ( ttt * cb . m01 + tt * cb . m11 + t * cb . m21 + cb . m31 ) + c * ( ttt * cb . m02 + tt * cb . m12 + t * cb . m22 + cb . m32 ) + d * ( ttt * cb . m03 + tt * cb . m13 + t * cb . m23 + cb . m33 ) ) ; } public float curveTangent ( float a , float b , float c , float d , float t ) { curveInitCheck ( ) ; float tt3 = t * t * 3 ; float t2 = t * 2 ; PMatrix3D cb = curveBasisMatrix ; return ( a * ( tt3 * cb . m00 + t2 * cb . m10 + cb . m20 ) + b * ( tt3 * cb . m01 + t2 * cb . m11 + cb . m21 ) + c * ( tt3 * cb . m02 + t2 * cb . m12 + cb . m22 ) + d * ( tt3 * cb . m03 + t2 * cb . m13 + cb . m23 ) ) ; } public void curveDetail ( int detail ) { curveDetail = detail ; curveInit ( ) ; } public void curveTightness ( float tightness ) { curveTightness = tightness ; curveInit ( ) ; } protected void curveInitCheck ( ) { if ( ! curveInited ) { curveInit ( ) ; } } protected void curveInit ( ) { if ( curveDrawMatrix == null ) { curveBasisMatrix = new PMatrix3D ( ) ; curveDrawMatrix = new PMatrix3D ( ) ; curveInited = true ; } float s = curveTightness ; curveBasisMatrix . set ( ( s - 1 ) / 2f , ( s + 3 ) / 2f , ( - 3 - s ) / 2f , ( 1 - s ) / 2f , ( 1 - s ) , ( - 5 - s ) / 2f , ( s + 2 ) , ( s - 1 ) / 2f , ( s - 1 ) / 2f , 0 , ( 1 - s ) / 2f , 0 , 0 , 1 , 0 , 0 ) ; splineForward ( curveDetail , curveDrawMatrix ) ; if ( bezierBasisInverse == null ) { bezierBasisInverse = bezierBasisMatrix . get ( ) ; bezierBasisInverse . invert ( ) ; curveToBezierMatrix = new PMatrix3D ( ) ; } curveToBezierMatrix . set ( curveBasisMatrix ) ; curveToBezierMatrix . preApply ( bezierBasisInverse ) ; curveDrawMatrix . apply ( curveBasisMatrix ) ; } public void curve ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { beginShape ( ) ; curveVertex ( x1 , y1 ) ; curveVertex ( x2 , y2 ) ; curveVertex ( x3 , y3 ) ; curveVertex ( x4 , y4 ) ; endShape ( ) ; } public void curve ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { beginShape ( ) ; curveVertex ( x1 , y1 , z1 ) ; curveVertex ( x2 , y2 , z2 ) ; curveVertex ( x3 , y3 , z3 ) ; curveVertex ( x4 , y4 , z4 ) ; endShape ( ) ; } protected void splineForward ( int segments , PMatrix3D matrix ) { float f = 1.0f / segments ; float ff = f * f ; float fff = ff * f ; matrix . set ( 0 , 0 , 0 , 1 , fff , ff , f , 0 , 6 * fff , 2 * ff , 0 , 0 , 6 * fff , 0 , 0 , 0 ) ; } public void smooth ( ) { smooth ( 1 ) ; } public void smooth ( int quality ) { if ( primaryGraphics ) { parent . smooth ( quality ) ; } else { if ( settingsInited ) { if ( this . smooth != quality ) { smoothWarning ( "smooth" ) ; } } else { this . smooth = quality ; } } } public void noSmooth ( ) { smooth ( 0 ) ; } private void smoothWarning ( String method ) { PGraphics . showWarning ( "%s() can only be used before beginDraw()" , method ) ; } public void imageMode ( int mode ) { if ( ( mode == CORNER ) || ( mode == CORNERS ) || ( mode == CENTER ) ) { imageMode = mode ; } else { String msg = "imageMode() only works with CORNER, CORNERS, or CENTER" ; throw new RuntimeException ( msg ) ; } } public void image ( PImage img , float a , float b ) { if ( img . width == - 1 || img . height == - 1 ) return ; if ( imageMode == CORNER || imageMode == CORNERS ) { imageImpl ( img , a , b , a + img . width , b + img . height , 0 , 0 , img . width , img . height ) ; } else if ( imageMode == CENTER ) { float x1 = a - img . width / 2 ; float y1 = b - img . height / 2 ; imageImpl ( img , x1 , y1 , x1 + img . width , y1 + img . height , 0 , 0 , img . width , img . height ) ; } } public void image ( PImage img , float a , float b , float c , float d ) { image ( img , a , b , c , d , 0 , 0 , img . width , img . height ) ; } public void image ( PImage img , float a , float b , float c , float d , int u1 , int v1 , int u2 , int v2 ) { if ( img . width == - 1 || img . height == - 1 ) return ; if ( imageMode == CORNER ) { if ( c < 0 ) { a += c ; c = - c ; } if ( d < 0 ) { b += d ; d = - d ; } imageImpl ( img , a , b , a + c , b + d , u1 , v1 , u2 , v2 ) ; } else if ( imageMode == CORNERS ) { if ( c < a ) { float temp = a ; a = c ; c = temp ; } if ( d < b ) { float temp = b ; b = d ; d = temp ; } imageImpl ( img , a , b , c , d , u1 , v1 , u2 , v2 ) ; } else if ( imageMode == CENTER ) { if ( c < 0 ) c = - c ; if ( d < 0 ) d = - d ; float x1 = a - c / 2 ; float y1 = b - d / 2 ; imageImpl ( img , x1 , y1 , x1 + c , y1 + d , u1 , v1 , u2 , v2 ) ; } } protected void imageImpl ( PImage img , float x1 , float y1 , float x2 , float y2 , int u1 , int v1 , int u2 , int v2 ) { boolean savedStroke = stroke ; int savedTextureMode = textureMode ; stroke = false ; textureMode = IMAGE ; beginShape ( QUADS ) ; texture ( img ) ; vertex ( x1 , y1 , u1 , v1 ) ; vertex ( x1 , y2 , u1 , v2 ) ; vertex ( x2 , y2 , u2 , v2 ) ; vertex ( x2 , y1 , u2 , v1 ) ; endShape ( ) ; stroke = savedStroke ; textureMode = savedTextureMode ; } public void shapeMode ( int mode ) { this . shapeMode = mode ; } public void shape ( PShape shape ) { if ( shape . isVisible ( ) ) { flush ( ) ; if ( shapeMode == CENTER ) { pushMatrix ( ) ; translate ( - shape . getWidth ( ) / 2 , - shape . getHeight ( ) / 2 ) ; } shape . draw ( this ) ; if ( shapeMode == CENTER ) { popMatrix ( ) ; } } } public void shape ( PShape shape , float x , float y ) { if ( shape . isVisible ( ) ) { flush ( ) ; pushMatrix ( ) ; if ( shapeMode == CENTER ) { translate ( x - shape . getWidth ( ) / 2 , y - shape . getHeight ( ) / 2 ) ; } else if ( ( shapeMode == CORNER ) || ( shapeMode == CORNERS ) ) { translate ( x , y ) ; } shape . draw ( this ) ; popMatrix ( ) ; } } protected void shape ( PShape shape , float x , float y , float z ) { showMissingWarning ( "shape" ) ; } public void shape ( PShape shape , float a , float b , float c , float d ) { if ( shape . isVisible ( ) ) { flush ( ) ; pushMatrix ( ) ; if ( shapeMode == CENTER ) { translate ( a - c / 2f , b - d / 2f ) ; scale ( c / shape . getWidth ( ) , d / shape . getHeight ( ) ) ; } else if ( shapeMode == CORNER ) { translate ( a , b ) ; scale ( c / shape . getWidth ( ) , d / shape . getHeight ( ) ) ; } else if ( shapeMode == CORNERS ) { c -= a ; d -= b ; translate ( a , b ) ; scale ( c / shape . getWidth ( ) , d / shape . getHeight ( ) ) ; } shape . draw ( this ) ; popMatrix ( ) ; } } protected void shape ( PShape shape , float x , float y , float z , float c , float d , float e ) { showMissingWarning ( "shape" ) ; } public void textAlign ( int alignX ) { textAlign ( alignX , BASELINE ) ; } public void textAlign ( int alignX , int alignY ) { textAlign = alignX ; textAlignY = alignY ; } public float textAscent ( ) { if ( textFont == null ) { defaultFontOrDeath ( "textAscent" ) ; } return textFont . ascent ( ) * textSize ; } public float textDescent ( ) { if ( textFont == null ) { defaultFontOrDeath ( "textDescent" ) ; } return textFont . descent ( ) * textSize ; } public void textFont ( PFont which ) { if ( which != null ) { textFont = which ; textSize ( which . getDefaultSize ( ) ) ; } else { throw new RuntimeException ( ERROR_TEXTFONT_NULL_PFONT ) ; } } public void textFont ( PFont which , float size ) { textFont ( which ) ; textSize ( size ) ; } public void textLeading ( float leading ) { textLeading = leading ; } public void textMode ( int mode ) { if ( ( mode == LEFT ) || ( mode == RIGHT ) ) { showWarning ( "Since Processing 1.0 beta, textMode() is now textAlign()." ) ; return ; } if ( mode == SCREEN ) { showWarning ( "textMode(SCREEN) has been removed from Processing 2.0." ) ; return ; } if ( textModeCheck ( mode ) ) { textMode = mode ; } else { String modeStr = String . valueOf ( mode ) ; switch ( mode ) { case MODEL : modeStr = "MODEL" ; break ; case SHAPE : modeStr = "SHAPE" ; break ; } showWarning ( "textMode(" + modeStr + ") is not supported by this renderer." ) ; } } protected boolean textModeCheck ( int mode ) { return true ; } public void textSize ( float size ) { if ( size <= 0 ) { System . err . println ( "textSize(" + size + ") ignored: " + "the text size must be larger than zero" ) ; return ; } if ( textFont == null ) { defaultFontOrDeath ( "textSize" , size ) ; } textSize = size ; textLeading = ( textAscent ( ) + textDescent ( ) ) * 1.275f ; } public float textWidth ( char c ) { textWidthBuffer [ 0 ] = c ; return textWidthImpl ( textWidthBuffer , 0 , 1 ) ; } public float textWidth ( String str ) { if ( textFont == null ) { defaultFontOrDeath ( "textWidth" ) ; } int length = str . length ( ) ; if ( length > textWidthBuffer . length ) { textWidthBuffer = new char [ length + 10 ] ; } str . getChars ( 0 , length , textWidthBuffer , 0 ) ; float wide = 0 ; int index = 0 ; int start = 0 ; while ( index < length ) { if ( textWidthBuffer [ index ] == '\n' ) { wide = Math . max ( wide , textWidthImpl ( textWidthBuffer , start , index ) ) ; start = index + 1 ; } index ++ ; } if ( start < length ) { wide = Math . max ( wide , textWidthImpl ( textWidthBuffer , start , index ) ) ; } return wide ; } public float textWidth ( char [ ] chars , int start , int length ) { return textWidthImpl ( chars , start , start + length ) ; } protected float textWidthImpl ( char buffer [ ] , int start , int stop ) { float wide = 0 ; for ( int i = start ; i < stop ; i ++ ) { wide += textFont . width ( buffer [ i ] ) * textSize ; } return wide ; } public void text ( char c , float x , float y ) { if ( textFont == null ) { defaultFontOrDeath ( "text" ) ; } if ( textAlignY == CENTER ) { y += textAscent ( ) / 2 ; } else if ( textAlignY == TOP ) { y += textAscent ( ) ; } else if ( textAlignY == BOTTOM ) { y -= textDescent ( ) ; } textBuffer [ 0 ] = c ; textLineAlignImpl ( textBuffer , 0 , 1 , x , y ) ; } public void text ( char c , float x , float y , float z ) { if ( z != 0 ) translate ( 0 , 0 , z ) ; text ( c , x , y ) ; if ( z != 0 ) translate ( 0 , 0 , - z ) ; } public void text ( String str , float x , float y ) { if ( textFont == null ) { defaultFontOrDeath ( "text" ) ; } int length = str . length ( ) ; if ( length > textBuffer . length ) { textBuffer = new char [ length + 10 ] ; } str . getChars ( 0 , length , textBuffer , 0 ) ; text ( textBuffer , 0 , length , x , y ) ; } public void text ( char [ ] chars , int start , int stop , float x , float y ) { float high = 0 ; for ( int i = start ; i < stop ; i ++ ) { if ( chars [ i ] == '\n' ) { high += textLeading ; } } if ( textAlignY == CENTER ) { y += ( textAscent ( ) - high ) / 2 ; } else if ( textAlignY == TOP ) { y += textAscent ( ) ; } else if ( textAlignY == BOTTOM ) { y -= textDescent ( ) + high ; } int index = 0 ; while ( index < stop ) { if ( chars [ index ] == '\n' ) { textLineAlignImpl ( chars , start , index , x , y ) ; start = index + 1 ; y += textLeading ; } index ++ ; } if ( start < stop ) { textLineAlignImpl ( chars , start , index , x , y ) ; } } public void text ( String str , float x , float y , float z ) { if ( z != 0 ) translate ( 0 , 0 , z ) ; text ( str , x , y ) ; if ( z != 0 ) translate ( 0 , 0 , - z ) ; } public void text ( char [ ] chars , int start , int stop , float x , float y , float z ) { if ( z != 0 ) translate ( 0 , 0 , z ) ; text ( chars , start , stop , x , y ) ; if ( z != 0 ) translate ( 0 , 0 , - z ) ; } public void text ( String str , float x1 , float y1 , float x2 , float y2 ) { if ( textFont == null ) { defaultFontOrDeath ( "text" ) ; } float hradius , vradius ; switch ( rectMode ) { case CORNER : x2 += x1 ; y2 += y1 ; break ; case RADIUS : hradius = x2 ; vradius = y2 ; x2 = x1 + hradius ; y2 = y1 + vradius ; x1 -= hradius ; y1 -= vradius ; break ; case CENTER : hradius = x2 / 2.0f ; vradius = y2 / 2.0f ; x2 = x1 + hradius ; y2 = y1 + vradius ; x1 -= hradius ; y1 -= vradius ; } if ( x2 < x1 ) { float temp = x1 ; x1 = x2 ; x2 = temp ; } if ( y2 < y1 ) { float temp = y1 ; y1 = y2 ; y2 = temp ; } float boxWidth = x2 - x1 ; float spaceWidth = textWidth ( ' ' ) ; if ( textBreakStart == null ) { textBreakStart = new int [ 20 ] ; textBreakStop = new int [ 20 ] ; } textBreakCount = 0 ; int length = str . length ( ) ; if ( length + 1 > textBuffer . length ) { textBuffer = new char [ length + 1 ] ; } str . getChars ( 0 , length , textBuffer , 0 ) ; textBuffer [ length ++ ] = '\n' ; int sentenceStart = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( textBuffer [ i ] == '\n' ) { boolean legit = textSentence ( textBuffer , sentenceStart , i , boxWidth , spaceWidth ) ; if ( ! legit ) break ; sentenceStart = i + 1 ; } } float lineX = x1 ; if ( textAlign == CENTER ) { lineX = lineX + boxWidth / 2f ; } else if ( textAlign == RIGHT ) { lineX = x2 ; } float boxHeight = y2 - y1 ; float topAndBottom = textAscent ( ) + textDescent ( ) ; int lineFitCount = 1 + PApplet . floor ( ( boxHeight - topAndBottom ) / textLeading ) ; int lineCount = Math . min ( textBreakCount , lineFitCount ) ; if ( textAlignY == CENTER ) { float lineHigh = textAscent ( ) + textLeading * ( lineCount - 1 ) ; float y = y1 + textAscent ( ) + ( boxHeight - lineHigh ) / 2 ; for ( int i = 0 ; i < lineCount ; i ++ ) { textLineAlignImpl ( textBuffer , textBreakStart [ i ] , textBreakStop [ i ] , lineX , y ) ; y += textLeading ; } } else if ( textAlignY == BOTTOM ) { float y = y2 - textDescent ( ) - textLeading * ( lineCount - 1 ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { textLineAlignImpl ( textBuffer , textBreakStart [ i ] , textBreakStop [ i ] , lineX , y ) ; y += textLeading ; } } else { float y = y1 + textAscent ( ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { textLineAlignImpl ( textBuffer , textBreakStart [ i ] , textBreakStop [ i ] , lineX , y ) ; y += textLeading ; } } } protected boolean textSentence ( char [ ] buffer , int start , int stop , float boxWidth , float spaceWidth ) { float runningX = 0 ; int lineStart = start ; int wordStart = start ; int index = start ; while ( index <= stop ) { if ( ( buffer [ index ] == ' ' ) || ( index == stop ) ) { float wordWidth = textWidthImpl ( buffer , wordStart , index ) ; if ( runningX + wordWidth >= boxWidth ) { if ( runningX != 0 ) { index = wordStart ; textSentenceBreak ( lineStart , index ) ; while ( ( index < stop ) && ( buffer [ index ] == ' ' ) ) { index ++ ; } } else { do { index -- ; if ( index == wordStart ) { return false ; } wordWidth = textWidthImpl ( buffer , wordStart , index ) ; } while ( wordWidth > boxWidth ) ; textSentenceBreak ( lineStart , index ) ; } lineStart = index ; wordStart = index ; runningX = 0 ; } else if ( index == stop ) { textSentenceBreak ( lineStart , index ) ; index ++ ; } else { runningX += wordWidth ; wordStart = index ; index ++ ; } } else { index ++ ; } } return true ; } protected void textSentenceBreak ( int start , int stop ) { if ( textBreakCount == textBreakStart . length ) { textBreakStart = PApplet . expand ( textBreakStart ) ; textBreakStop = PApplet . expand ( textBreakStop ) ; } textBreakStart [ textBreakCount ] = start ; textBreakStop [ textBreakCount ] = stop ; textBreakCount ++ ; } public void text ( int num , float x , float y ) { text ( String . valueOf ( num ) , x , y ) ; } public void text ( int num , float x , float y , float z ) { text ( String . valueOf ( num ) , x , y , z ) ; } public void text ( float num , float x , float y ) { text ( PApplet . nfs ( num , 0 , 3 ) , x , y ) ; } public void text ( float num , float x , float y , float z ) { text ( PApplet . nfs ( num , 0 , 3 ) , x , y , z ) ; } protected void textLineAlignImpl ( char buffer [ ] , int start , int stop , float x , float y ) { if ( textAlign == CENTER ) { x -= textWidthImpl ( buffer , start , stop ) / 2f ; } else if ( textAlign == RIGHT ) { x -= textWidthImpl ( buffer , start , stop ) ; } textLineImpl ( buffer , start , stop , x , y ) ; } protected void textLineImpl ( char buffer [ ] , int start , int stop , float x , float y ) { for ( int index = start ; index < stop ; index ++ ) { textCharImpl ( buffer [ index ] , x , y ) ; x += textWidth ( buffer [ index ] ) ; } } protected void textCharImpl ( char ch , float x , float y ) { PFont . Glyph glyph = textFont . getGlyph ( ch ) ; if ( glyph != null ) { if ( textMode == MODEL ) { float high = glyph . height / ( float ) textFont . getSize ( ) ; float bwidth = glyph . width / ( float ) textFont . getSize ( ) ; float lextent = glyph . leftExtent / ( float ) textFont . getSize ( ) ; float textent = glyph . topExtent / ( float ) textFont . getSize ( ) ; float x1 = x + lextent * textSize ; float y1 = y - textent * textSize ; float x2 = x1 + bwidth * textSize ; float y2 = y1 + high * textSize ; textCharModelImpl ( glyph . image , x1 , y1 , x2 , y2 , glyph . width , glyph . height ) ; } } else if ( ch != ' ' && ch != 127 ) { showWarning ( "No glyph found for the " + ch + " (\\u" + PApplet . hex ( ch , 4 ) + ") character" ) ; } } protected void textCharModelImpl ( PImage glyph , float x1 , float y1 , float x2 , float y2 , int u2 , int v2 ) { boolean savedTint = tint ; int savedTintColor = tintColor ; float savedTintR = tintR ; float savedTintG = tintG ; float savedTintB = tintB ; float savedTintA = tintA ; boolean savedTintAlpha = tintAlpha ; tint = true ; tintColor = fillColor ; tintR = fillR ; tintG = fillG ; tintB = fillB ; tintA = fillA ; tintAlpha = fillAlpha ; imageImpl ( glyph , x1 , y1 , x2 , y2 , 0 , 0 , u2 , v2 ) ; tint = savedTint ; tintColor = savedTintColor ; tintR = savedTintR ; tintG = savedTintG ; tintB = savedTintB ; tintA = savedTintA ; tintAlpha = savedTintAlpha ; } @ SuppressWarnings ( "deprecation" ) public FontMetrics getFontMetrics ( Font font ) { Frame frame = parent . getFrame ( ) ; if ( frame != null ) { return frame . getToolkit ( ) . getFontMetrics ( font ) ; } return Toolkit . getDefaultToolkit ( ) . getFontMetrics ( font ) ; } public FontRenderContext getFontRenderContext ( Font font ) { return getFontMetrics ( font ) . getFontRenderContext ( ) ; } public void pushMatrix ( ) { showMethodWarning ( "pushMatrix" ) ; } public void popMatrix ( ) { showMethodWarning ( "popMatrix" ) ; } public void translate ( float x , float y ) { showMissingWarning ( "translate" ) ; } public void translate ( float x , float y , float z ) { showMissingWarning ( "translate" ) ; } public void rotate ( float angle ) { showMissingWarning ( "rotate" ) ; } public void rotateX ( float angle ) { showMethodWarning ( "rotateX" ) ; } public void rotateY ( float angle ) { showMethodWarning ( "rotateY" ) ; } public void rotateZ ( float angle ) { showMethodWarning ( "rotateZ" ) ; } public void rotate ( float angle , float x , float y , float z ) { showMissingWarning ( "rotate" ) ; } public void scale ( float s ) { showMissingWarning ( "scale" ) ; } public void scale ( float x , float y ) { showMissingWarning ( "scale" ) ; } public void scale ( float x , float y , float z ) { showMissingWarning ( "scale" ) ; } public void shearX ( float angle ) { showMissingWarning ( "shearX" ) ; } public void shearY ( float angle ) { showMissingWarning ( "shearY" ) ; } public void resetMatrix ( ) { showMethodWarning ( "resetMatrix" ) ; } public void applyMatrix ( PMatrix source ) { if ( source instanceof PMatrix2D ) { applyMatrix ( ( PMatrix2D ) source ) ; } else if ( source instanceof PMatrix3D ) { applyMatrix ( ( PMatrix3D ) source ) ; } } public void applyMatrix ( PMatrix2D source ) { applyMatrix ( source . m00 , source . m01 , source . m02 , source . m10 , source . m11 , source . m12 ) ; } public void applyMatrix ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) { showMissingWarning ( "applyMatrix" ) ; } public void applyMatrix ( PMatrix3D source ) { applyMatrix ( source . m00 , source . m01 , source . m02 , source . m03 , source . m10 , source . m11 , source . m12 , source . m13 , source . m20 , source . m21 , source . m22 , source . m23 , source . m30 , source . m31 , source . m32 , source . m33 ) ; } public void applyMatrix ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { showMissingWarning ( "applyMatrix" ) ; } public PMatrix getMatrix ( ) { showMissingWarning ( "getMatrix" ) ; return null ; } public PMatrix2D getMatrix ( PMatrix2D target ) { showMissingWarning ( "getMatrix" ) ; return null ; } public PMatrix3D getMatrix ( PMatrix3D target ) { showMissingWarning ( "getMatrix" ) ; return null ; } public void setMatrix ( PMatrix source ) { if ( source instanceof PMatrix2D ) { setMatrix ( ( PMatrix2D ) source ) ; } else if ( source instanceof PMatrix3D ) { setMatrix ( ( PMatrix3D ) source ) ; } } public void setMatrix ( PMatrix2D source ) { showMissingWarning ( "setMatrix" ) ; } public void setMatrix ( PMatrix3D source ) { showMissingWarning ( "setMatrix" ) ; } public void printMatrix ( ) { showMethodWarning ( "printMatrix" ) ; } public void beginCamera ( ) { showMethodWarning ( "beginCamera" ) ; } public void endCamera ( ) { showMethodWarning ( "endCamera" ) ; } public void camera ( ) { showMissingWarning ( "camera" ) ; } public void camera ( float eyeX , float eyeY , float eyeZ , float centerX , float centerY , float centerZ , float upX , float upY , float upZ ) { showMissingWarning ( "camera" ) ; } public void printCamera ( ) { showMethodWarning ( "printCamera" ) ; } public void ortho ( ) { showMissingWarning ( "ortho" ) ; } public void ortho ( float left , float right , float bottom , float top ) { showMissingWarning ( "ortho" ) ; } public void ortho ( float left , float right , float bottom , float top , float near , float far ) { showMissingWarning ( "ortho" ) ; } public void perspective ( ) { showMissingWarning ( "perspective" ) ; } public void perspective ( float fovy , float aspect , float zNear , float zFar ) { showMissingWarning ( "perspective" ) ; } public void frustum ( float left , float right , float bottom , float top , float near , float far ) { showMethodWarning ( "frustum" ) ; } public void printProjection ( ) { showMethodWarning ( "printProjection" ) ; } public float screenX ( float x , float y ) { showMissingWarning ( "screenX" ) ; return 0 ; } public float screenY ( float x , float y ) { showMissingWarning ( "screenY" ) ; return 0 ; } public float screenX ( float x , float y , float z ) { showMissingWarning ( "screenX" ) ; return 0 ; } public float screenY ( float x , float y , float z ) { showMissingWarning ( "screenY" ) ; return 0 ; } public float screenZ ( float x , float y , float z ) { showMissingWarning ( "screenZ" ) ; return 0 ; } public float modelX ( float x , float y , float z ) { showMissingWarning ( "modelX" ) ; return 0 ; } public float modelY ( float x , float y , float z ) { showMissingWarning ( "modelY" ) ; return 0 ; } public float modelZ ( float x , float y , float z ) { showMissingWarning ( "modelZ" ) ; return 0 ; } public void pushStyle ( ) { if ( styleStackDepth == styleStack . length ) { styleStack = ( PStyle [ ] ) PApplet . expand ( styleStack ) ; } if ( styleStack [ styleStackDepth ] == null ) { styleStack [ styleStackDepth ] = new PStyle ( ) ; } PStyle s = styleStack [ styleStackDepth ++ ] ; getStyle ( s ) ; } public void popStyle ( ) { if ( styleStackDepth == 0 ) { throw new RuntimeException ( "Too many popStyle() without enough pushStyle()" ) ; } styleStackDepth -- ; style ( styleStack [ styleStackDepth ] ) ; } public void style ( PStyle s ) { imageMode ( s . imageMode ) ; rectMode ( s . rectMode ) ; ellipseMode ( s . ellipseMode ) ; shapeMode ( s . shapeMode ) ; blendMode ( s . blendMode ) ; if ( s . tint ) { tint ( s . tintColor ) ; } else { noTint ( ) ; } if ( s . fill ) { fill ( s . fillColor ) ; } else { noFill ( ) ; } if ( s . stroke ) { stroke ( s . strokeColor ) ; } else { noStroke ( ) ; } strokeWeight ( s . strokeWeight ) ; strokeCap ( s . strokeCap ) ; strokeJoin ( s . strokeJoin ) ; colorMode ( RGB , 1 ) ; ambient ( s . ambientR , s . ambientG , s . ambientB ) ; emissive ( s . emissiveR , s . emissiveG , s . emissiveB ) ; specular ( s . specularR , s . specularG , s . specularB ) ; shininess ( s . shininess ) ; colorMode ( s . colorMode , s . colorModeX , s . colorModeY , s . colorModeZ , s . colorModeA ) ; if ( s . textFont != null ) { textFont ( s . textFont , s . textSize ) ; textLeading ( s . textLeading ) ; } textAlign ( s . textAlign , s . textAlignY ) ; textMode ( s . textMode ) ; } public PStyle getStyle ( ) { return getStyle ( null ) ; } public PStyle getStyle ( PStyle s ) { if ( s == null ) { s = new PStyle ( ) ; } s . imageMode = imageMode ; s . rectMode = rectMode ; s . ellipseMode = ellipseMode ; s . shapeMode = shapeMode ; s . blendMode = blendMode ; s . colorMode = colorMode ; s . colorModeX = colorModeX ; s . colorModeY = colorModeY ; s . colorModeZ = colorModeZ ; s . colorModeA = colorModeA ; s . tint = tint ; s . tintColor = tintColor ; s . fill = fill ; s . fillColor = fillColor ; s . stroke = stroke ; s . strokeColor = strokeColor ; s . strokeWeight = strokeWeight ; s . strokeCap = strokeCap ; s . strokeJoin = strokeJoin ; s . ambientR = ambientR ; s . ambientG = ambientG ; s . ambientB = ambientB ; s . specularR = specularR ; s . specularG = specularG ; s . specularB = specularB ; s . emissiveR = emissiveR ; s . emissiveG = emissiveG ; s . emissiveB = emissiveB ; s . shininess = shininess ; s . textFont = textFont ; s . textAlign = textAlign ; s . textAlignY = textAlignY ; s . textMode = textMode ; s . textSize = textSize ; s . textLeading = textLeading ; return s ; } public void strokeWeight ( float weight ) { strokeWeight = weight ; } public void strokeJoin ( int join ) { strokeJoin = join ; } public void strokeCap ( int cap ) { strokeCap = cap ; } public void noStroke ( ) { stroke = false ; } public void stroke ( int rgb ) { colorCalc ( rgb ) ; strokeFromCalc ( ) ; } public void stroke ( int rgb , float alpha ) { colorCalc ( rgb , alpha ) ; strokeFromCalc ( ) ; } public void stroke ( float gray ) { colorCalc ( gray ) ; strokeFromCalc ( ) ; } public void stroke ( float gray , float alpha ) { colorCalc ( gray , alpha ) ; strokeFromCalc ( ) ; } public void stroke ( float v1 , float v2 , float v3 ) { colorCalc ( v1 , v2 , v3 ) ; strokeFromCalc ( ) ; } public void stroke ( float v1 , float v2 , float v3 , float alpha ) { colorCalc ( v1 , v2 , v3 , alpha ) ; strokeFromCalc ( ) ; } protected void strokeFromCalc ( ) { stroke = true ; strokeR = calcR ; strokeG = calcG ; strokeB = calcB ; strokeA = calcA ; strokeRi = calcRi ; strokeGi = calcGi ; strokeBi = calcBi ; strokeAi = calcAi ; strokeColor = calcColor ; strokeAlpha = calcAlpha ; } public void noTint ( ) { tint = false ; } public void tint ( int rgb ) { colorCalc ( rgb ) ; tintFromCalc ( ) ; } public void tint ( int rgb , float alpha ) { colorCalc ( rgb , alpha ) ; tintFromCalc ( ) ; } public void tint ( float gray ) { colorCalc ( gray ) ; tintFromCalc ( ) ; } public void tint ( float gray , float alpha ) { colorCalc ( gray , alpha ) ; tintFromCalc ( ) ; } public void tint ( float v1 , float v2 , float v3 ) { colorCalc ( v1 , v2 , v3 ) ; tintFromCalc ( ) ; } public void tint ( float v1 , float v2 , float v3 , float alpha ) { colorCalc ( v1 , v2 , v3 , alpha ) ; tintFromCalc ( ) ; } protected void tintFromCalc ( ) { tint = true ; tintR = calcR ; tintG = calcG ; tintB = calcB ; tintA = calcA ; tintRi = calcRi ; tintGi = calcGi ; tintBi = calcBi ; tintAi = calcAi ; tintColor = calcColor ; tintAlpha = calcAlpha ; } public void noFill ( ) { fill = false ; } public void fill ( int rgb ) { colorCalc ( rgb ) ; fillFromCalc ( ) ; } public void fill ( int rgb , float alpha ) { colorCalc ( rgb , alpha ) ; fillFromCalc ( ) ; } public void fill ( float gray ) { colorCalc ( gray ) ; fillFromCalc ( ) ; } public void fill ( float gray , float alpha ) { colorCalc ( gray , alpha ) ; fillFromCalc ( ) ; } public void fill ( float v1 , float v2 , float v3 ) { colorCalc ( v1 , v2 , v3 ) ; fillFromCalc ( ) ; } public void fill ( float v1 , float v2 , float v3 , float alpha ) { colorCalc ( v1 , v2 , v3 , alpha ) ; fillFromCalc ( ) ; } protected void fillFromCalc ( ) { fill = true ; fillR = calcR ; fillG = calcG ; fillB = calcB ; fillA = calcA ; fillRi = calcRi ; fillGi = calcGi ; fillBi = calcBi ; fillAi = calcAi ; fillColor = calcColor ; fillAlpha = calcAlpha ; } public void ambient ( int rgb ) { colorCalc ( rgb ) ; ambientFromCalc ( ) ; } public void ambient ( float gray ) { colorCalc ( gray ) ; ambientFromCalc ( ) ; } public void ambient ( float v1 , float v2 , float v3 ) { colorCalc ( v1 , v2 , v3 ) ; ambientFromCalc ( ) ; } protected void ambientFromCalc ( ) { ambientColor = calcColor ; ambientR = calcR ; ambientG = calcG ; ambientB = calcB ; setAmbient = true ; } public void specular ( int rgb ) { colorCalc ( rgb ) ; specularFromCalc ( ) ; } public void specular ( float gray ) { colorCalc ( gray ) ; specularFromCalc ( ) ; } public void specular ( float v1 , float v2 , float v3 ) { colorCalc ( v1 , v2 , v3 ) ; specularFromCalc ( ) ; } protected void specularFromCalc ( ) { specularColor = calcColor ; specularR = calcR ; specularG = calcG ; specularB = calcB ; } public void shininess ( float shine ) { shininess = shine ; } public void emissive ( int rgb ) { colorCalc ( rgb ) ; emissiveFromCalc ( ) ; } public void emissive ( float gray ) { colorCalc ( gray ) ; emissiveFromCalc ( ) ; } public void emissive ( float v1 , float v2 , float v3 ) { colorCalc ( v1 , v2 , v3 ) ; emissiveFromCalc ( ) ; } protected void emissiveFromCalc ( ) { emissiveColor = calcColor ; emissiveR = calcR ; emissiveG = calcG ; emissiveB = calcB ; } public void lights ( ) { showMethodWarning ( "lights" ) ; } public void noLights ( ) { showMethodWarning ( "noLights" ) ; } public void ambientLight ( float v1 , float v2 , float v3 ) { showMethodWarning ( "ambientLight" ) ; } public void ambientLight ( float v1 , float v2 , float v3 , float x , float y , float z ) { showMethodWarning ( "ambientLight" ) ; } public void directionalLight ( float v1 , float v2 , float v3 , float nx , float ny , float nz ) { showMethodWarning ( "directionalLight" ) ; } public void pointLight ( float v1 , float v2 , float v3 , float x , float y , float z ) { showMethodWarning ( "pointLight" ) ; } public void spotLight ( float v1 , float v2 , float v3 , float x , float y , float z , float nx , float ny , float nz , float angle , float concentration ) { showMethodWarning ( "spotLight" ) ; } public void lightFalloff ( float constant , float linear , float quadratic ) { showMethodWarning ( "lightFalloff" ) ; } public void lightSpecular ( float v1 , float v2 , float v3 ) { showMethodWarning ( "lightSpecular" ) ; } public void background ( int rgb ) { colorCalc ( rgb ) ; backgroundFromCalc ( ) ; } public void background ( int rgb , float alpha ) { colorCalc ( rgb , alpha ) ; backgroundFromCalc ( ) ; } public void background ( float gray ) { colorCalc ( gray ) ; backgroundFromCalc ( ) ; } public void background ( float gray , float alpha ) { if ( format == RGB ) { background ( gray ) ; } else { colorCalc ( gray , alpha ) ; backgroundFromCalc ( ) ; } } public void background ( float v1 , float v2 , float v3 ) { colorCalc ( v1 , v2 , v3 ) ; backgroundFromCalc ( ) ; } public void background ( float v1 , float v2 , float v3 , float alpha ) { colorCalc ( v1 , v2 , v3 , alpha ) ; backgroundFromCalc ( ) ; } public void clear ( ) { background ( 0 , 0 , 0 , 0 ) ; } protected void backgroundFromCalc ( ) { backgroundR = calcR ; backgroundG = calcG ; backgroundB = calcB ; backgroundA = ( format == RGB ) ? 1 : calcA ; backgroundRi = calcRi ; backgroundGi = calcGi ; backgroundBi = calcBi ; backgroundAi = ( format == RGB ) ? 255 : calcAi ; backgroundAlpha = ( format == RGB ) ? false : calcAlpha ; backgroundColor = calcColor ; backgroundImpl ( ) ; } public void background ( PImage image ) { if ( ( image . width != width ) || ( image . height != height ) ) { throw new RuntimeException ( ERROR_BACKGROUND_IMAGE_SIZE ) ; } if ( ( image . format != RGB ) && ( image . format != ARGB ) ) { throw new RuntimeException ( ERROR_BACKGROUND_IMAGE_FORMAT ) ; } backgroundColor = 0 ; backgroundImpl ( image ) ; } protected void backgroundImpl ( PImage image ) { set ( 0 , 0 , image ) ; } protected void backgroundImpl ( ) { pushStyle ( ) ; pushMatrix ( ) ; resetMatrix ( ) ; fill ( backgroundColor ) ; rect ( 0 , 0 , width , height ) ; popMatrix ( ) ; popStyle ( ) ; } public void colorMode ( int mode ) { colorMode ( mode , colorModeX , colorModeY , colorModeZ , colorModeA ) ; } public void colorMode ( int mode , float max ) { colorMode ( mode , max , max , max , max ) ; } public void colorMode ( int mode , float max1 , float max2 , float max3 ) { colorMode ( mode , max1 , max2 , max3 , colorModeA ) ; } public void colorMode ( int mode , float max1 , float max2 , float max3 , float maxA ) { colorMode = mode ; colorModeX = max1 ; colorModeY = max2 ; colorModeZ = max3 ; colorModeA = maxA ; colorModeScale = ( ( maxA != 1 ) || ( max1 != max2 ) || ( max2 != max3 ) || ( max3 != maxA ) ) ; colorModeDefault = ( colorMode == RGB ) && ( colorModeA == 255 ) && ( colorModeX == 255 ) && ( colorModeY == 255 ) && ( colorModeZ == 255 ) ; } protected void colorCalc ( int rgb ) { if ( ( ( rgb & 0xff000000 ) == 0 ) && ( rgb <= colorModeX ) ) { colorCalc ( ( float ) rgb ) ; } else { colorCalcARGB ( rgb , colorModeA ) ; } } protected void colorCalc ( int rgb , float alpha ) { if ( ( ( rgb & 0xff000000 ) == 0 ) && ( rgb <= colorModeX ) ) { colorCalc ( ( float ) rgb , alpha ) ; } else { colorCalcARGB ( rgb , alpha ) ; } } protected void colorCalc ( float gray ) { colorCalc ( gray , colorModeA ) ; } protected void colorCalc ( float gray , float alpha ) { if ( gray > colorModeX ) gray = colorModeX ; if ( alpha > colorModeA ) alpha = colorModeA ; if ( gray < 0 ) gray = 0 ; if ( alpha < 0 ) alpha = 0 ; calcR = colorModeScale ? ( gray / colorModeX ) : gray ; calcG = calcR ; calcB = calcR ; calcA = colorModeScale ? ( alpha / colorModeA ) : alpha ; calcRi = ( int ) ( calcR * 255 ) ; calcGi = ( int ) ( calcG * 255 ) ; calcBi = ( int ) ( calcB * 255 ) ; calcAi = ( int ) ( calcA * 255 ) ; calcColor = ( calcAi < < 24 ) | ( calcRi < < 16 ) | ( calcGi < < 8 ) | calcBi ; calcAlpha = ( calcAi != 255 ) ; } protected void colorCalc ( float x , float y , float z ) { colorCalc ( x , y , z , colorModeA ) ; } protected void colorCalc ( float x , float y , float z , float a ) { if ( x > colorModeX ) x = colorModeX ; if ( y > colorModeY ) y = colorModeY ; if ( z > colorModeZ ) z = colorModeZ ; if ( a > colorModeA ) a = colorModeA ; if ( x < 0 ) x = 0 ; if ( y < 0 ) y = 0 ; if ( z < 0 ) z = 0 ; if ( a < 0 ) a = 0 ; switch ( colorMode ) { case RGB : if ( colorModeScale ) { calcR = x / colorModeX ; calcG = y / colorModeY ; calcB = z / colorModeZ ; calcA = a / colorModeA ; } else { calcR = x ; calcG = y ; calcB = z ; calcA = a ; } break ; case HSB : x /= colorModeX ; y /= colorModeY ; z /= colorModeZ ; calcA = colorModeScale ? ( a / colorModeA ) : a ; if ( y == 0 ) { calcR = calcG = calcB = z ; } else { float which = ( x - ( int ) x ) * 6.0f ; float f = which - ( int ) which ; float p = z * ( 1.0f - y ) ; float q = z * ( 1.0f - y * f ) ; float t = z * ( 1.0f - ( y * ( 1.0f - f ) ) ) ; switch ( ( int ) which ) { case 0 : calcR = z ; calcG = t ; calcB = p ; break ; case 1 : calcR = q ; calcG = z ; calcB = p ; break ; case 2 : calcR = p ; calcG = z ; calcB = t ; break ; case 3 : calcR = p ; calcG = q ; calcB = z ; break ; case 4 : calcR = t ; calcG = p ; calcB = z ; break ; case 5 : calcR = z ; calcG = p ; calcB = q ; break ; } } break ; } calcRi = ( int ) ( 255 * calcR ) ; calcGi = ( int ) ( 255 * calcG ) ; calcBi = ( int ) ( 255 * calcB ) ; calcAi = ( int ) ( 255 * calcA ) ; calcColor = ( calcAi < < 24 ) | ( calcRi < < 16 ) | ( calcGi < < 8 ) | calcBi ; calcAlpha = ( calcAi != 255 ) ; } protected void colorCalcARGB ( int argb , float alpha ) { if ( alpha == colorModeA ) { calcAi = ( argb > > 24 ) & 0xff ; calcColor = argb ; } else { calcAi = ( int ) ( ( ( argb > > 24 ) & 0xff ) * PApplet . constrain ( ( alpha / colorModeA ) , 0 , 1 ) ) ; calcColor = ( calcAi < < 24 ) | ( argb & 0xFFFFFF ) ; } calcRi = ( argb > > 16 ) & 0xff ; calcGi = ( argb > > 8 ) & 0xff ; calcBi = argb & 0xff ; calcA = calcAi / 255.0f ; calcR = calcRi / 255.0f ; calcG = calcGi / 255.0f ; calcB = calcBi / 255.0f ; calcAlpha = ( calcAi != 255 ) ; } public final int color ( int c ) { colorCalc ( c ) ; return calcColor ; } public final int color ( float gray ) { colorCalc ( gray ) ; return calcColor ; } public final int color ( int c , int alpha ) { colorCalc ( c , alpha ) ; return calcColor ; } public final int color ( int c , float alpha ) { colorCalc ( c , alpha ) ; return calcColor ; } public final int color ( float gray , float alpha ) { colorCalc ( gray , alpha ) ; return calcColor ; } public final int color ( int v1 , int v2 , int v3 ) { colorCalc ( v1 , v2 , v3 ) ; return calcColor ; } public final int color ( float v1 , float v2 , float v3 ) { colorCalc ( v1 , v2 , v3 ) ; return calcColor ; } public final int color ( int v1 , int v2 , int v3 , int a ) { colorCalc ( v1 , v2 , v3 , a ) ; return calcColor ; } public final int color ( float v1 , float v2 , float v3 , float a ) { colorCalc ( v1 , v2 , v3 , a ) ; return calcColor ; } public final float alpha ( int rgb ) { float outgoing = ( rgb > > 24 ) & 0xff ; if ( colorModeA == 255 ) return outgoing ; return ( outgoing / 255.0f ) * colorModeA ; } public final float red ( int rgb ) { float c = ( rgb > > 16 ) & 0xff ; if ( colorModeDefault ) return c ; return ( c / 255.0f ) * colorModeX ; } public final float green ( int rgb ) { float c = ( rgb > > 8 ) & 0xff ; if ( colorModeDefault ) return c ; return ( c / 255.0f ) * colorModeY ; } public final float blue ( int rgb ) { float c = ( rgb ) & 0xff ; if ( colorModeDefault ) return c ; return ( c / 255.0f ) * colorModeZ ; } public final float hue ( int rgb ) { if ( rgb != cacheHsbKey ) { Color . RGBtoHSB ( ( rgb > > 16 ) & 0xff , ( rgb > > 8 ) & 0xff , rgb & 0xff , cacheHsbValue ) ; cacheHsbKey = rgb ; } return cacheHsbValue [ 0 ] * colorModeX ; } public final float saturation ( int rgb ) { if ( rgb != cacheHsbKey ) { Color . RGBtoHSB ( ( rgb > > 16 ) & 0xff , ( rgb > > 8 ) & 0xff , rgb & 0xff , cacheHsbValue ) ; cacheHsbKey = rgb ; } return cacheHsbValue [ 1 ] * colorModeY ; } public final float brightness ( int rgb ) { if ( rgb != cacheHsbKey ) { Color . RGBtoHSB ( ( rgb > > 16 ) & 0xff , ( rgb > > 8 ) & 0xff , rgb & 0xff , cacheHsbValue ) ; cacheHsbKey = rgb ; } return cacheHsbValue [ 2 ] * colorModeZ ; } public int lerpColor ( int c1 , int c2 , float amt ) { return lerpColor ( c1 , c2 , amt , colorMode ) ; } static float [ ] lerpColorHSB1 ; static float [ ] lerpColorHSB2 ; static public int lerpColor ( int c1 , int c2 , float amt , int mode ) { if ( amt < 0 ) amt = 0 ; if ( amt > 1 ) amt = 1 ; if ( mode == RGB ) { float a1 = ( ( c1 > > 24 ) & 0xff ) ; float r1 = ( c1 > > 16 ) & 0xff ; float g1 = ( c1 > > 8 ) & 0xff ; float b1 = c1 & 0xff ; float a2 = ( c2 > > 24 ) & 0xff ; float r2 = ( c2 > > 16 ) & 0xff ; float g2 = ( c2 > > 8 ) & 0xff ; float b2 = c2 & 0xff ; return ( ( PApplet . round ( a1 + ( a2 - a1 ) * amt ) < < 24 ) | ( PApplet . round ( r1 + ( r2 - r1 ) * amt ) < < 16 ) | ( PApplet . round ( g1 + ( g2 - g1 ) * amt ) < < 8 ) | ( PApplet . round ( b1 + ( b2 - b1 ) * amt ) ) ) ; } else if ( mode == HSB ) { if ( lerpColorHSB1 == null ) { lerpColorHSB1 = new float [ 3 ] ; lerpColorHSB2 = new float [ 3 ] ; } float a1 = ( c1 > > 24 ) & 0xff ; float a2 = ( c2 > > 24 ) & 0xff ; int alfa = ( PApplet . round ( a1 + ( a2 - a1 ) * amt ) ) < < 24 ; Color . RGBtoHSB ( ( c1 > > 16 ) & 0xff , ( c1 > > 8 ) & 0xff , c1 & 0xff , lerpColorHSB1 ) ; Color . RGBtoHSB ( ( c2 > > 16 ) & 0xff , ( c2 > > 8 ) & 0xff , c2 & 0xff , lerpColorHSB2 ) ; float ho = PApplet . lerp ( lerpColorHSB1 [ 0 ] , lerpColorHSB2 [ 0 ] , amt ) ; float so = PApplet . lerp ( lerpColorHSB1 [ 1 ] , lerpColorHSB2 [ 1 ] , amt ) ; float bo = PApplet . lerp ( lerpColorHSB1 [ 2 ] , lerpColorHSB2 [ 2 ] , amt ) ; return alfa | ( Color . HSBtoRGB ( ho , so , bo ) & 0xFFFFFF ) ; } return 0 ; } public void beginRaw ( PGraphics rawGraphics ) { this . raw = rawGraphics ; rawGraphics . beginDraw ( ) ; } public void endRaw ( ) { if ( raw != null ) { flush ( ) ; raw . endDraw ( ) ; raw . dispose ( ) ; raw = null ; } } public boolean haveRaw ( ) { return raw != null ; } public PGraphics getRaw ( ) { return raw ; } static protected HashMap < String , Object > warnings ; static public void showWarning ( String msg ) { if ( warnings == null ) { warnings = new HashMap < String , Object > ( ) ; } if ( ! warnings . containsKey ( msg ) ) { System . err . println ( msg ) ; warnings . put ( msg , new Object ( ) ) ; } } static public void showWarning ( String msg , Object ... args ) { showWarning ( String . format ( msg , args ) ) ; } static public void showDepthWarning ( String method ) { showWarning ( method + "() can only be used with a renderer that " + "supports 3D, such as P3D." ) ; } static public void showDepthWarningXYZ ( String method ) { showWarning ( method + "() with x, y, and z coordinates " + "can only be used with a renderer that " + "supports 3D, such as P3D. " + "Use a version without a z-coordinate instead." ) ; } static public void showMethodWarning ( String method ) { showWarning ( method + "() is not available with this renderer." ) ; } static public void showVariationWarning ( String str ) { showWarning ( str + " is not available with this renderer." ) ; } static public void showMissingWarning ( String method ) { showWarning ( method + "(), or this particular variation of it, " + "is not available with this renderer." ) ; } static public void showException ( String msg ) { throw new RuntimeException ( msg ) ; } protected void defaultFontOrDeath ( String method ) { defaultFontOrDeath ( method , 12 ) ; } protected void defaultFontOrDeath ( String method , float size ) { if ( parent != null ) { textFont = parent . createDefaultFont ( size ) ; } else { throw new RuntimeException ( "Use textFont() before " + method + "()" ) ; } } public boolean displayable ( ) { return true ; } public boolean is2D ( ) { return true ; } public boolean is3D ( ) { return false ; } public boolean isGL ( ) { return false ; } public boolean is2X ( ) { return pixelDensity == 2 ; } }
package processing . app . syntax ; import java . awt . event . MouseEvent ; import java . awt . * ; import java . awt . print . * ; import javax . swing . ToolTipManager ; import javax . swing . text . * ; import javax . swing . JComponent ; import processing . app . Preferences ; import processing . app . syntax . im . CompositionTextPainter ; public class TextAreaPainter extends JComponent implements TabExpander { boolean printing ; protected CompositionTextPainter compositionTextPainter ; protected JEditTextArea textArea ; protected TextAreaDefaults defaults ; private Font plainFont ; private Font boldFont ; private boolean antialias ; protected int tabSize ; protected FontMetrics fm ; protected Highlight highlights ; int currentLineIndex ; Token currentLineTokens ; Segment currentLine ; public TextAreaPainter ( JEditTextArea textArea , TextAreaDefaults defaults ) { this . textArea = textArea ; this . defaults = defaults ; setAutoscrolls ( true ) ; setOpaque ( true ) ; ToolTipManager . sharedInstance ( ) . registerComponent ( this ) ; currentLine = new Segment ( ) ; currentLineIndex = - 1 ; setCursor ( Cursor . getPredefinedCursor ( Cursor . TEXT_CURSOR ) ) ; updateAppearance ( ) ; } public void updateAppearance ( ) { setForeground ( defaults . fgcolor ) ; setBackground ( defaults . bgcolor ) ; String fontFamily = Preferences . get ( "editor.font.family" ) ; int fontSize = Preferences . getInteger ( "editor.font.size" ) ; plainFont = new Font ( fontFamily , Font . PLAIN , fontSize ) ; if ( ! fontFamily . equals ( plainFont . getFamily ( ) ) ) { System . err . println ( fontFamily + " not available, resetting to monospaced" ) ; fontFamily = "Monospaced" ; Preferences . set ( "editor.font.family" , fontFamily ) ; plainFont = new Font ( fontFamily , Font . PLAIN , fontSize ) ; } boldFont = new Font ( fontFamily , Font . BOLD , fontSize ) ; antialias = Preferences . getBoolean ( "editor.smooth" ) ; fm = super . getFontMetrics ( plainFont ) ; textArea . recalculateVisibleLines ( ) ; } public CompositionTextPainter getCompositionTextpainter ( ) { if ( compositionTextPainter == null ) { compositionTextPainter = new CompositionTextPainter ( textArea ) ; } return compositionTextPainter ; } public final SyntaxStyle [ ] getStyles ( ) { return defaults . styles ; } public final void setLineHighlightEnabled ( boolean lineHighlight ) { defaults . lineHighlight = lineHighlight ; invalidateSelectedLines ( ) ; } public final boolean isBracketHighlightEnabled ( ) { return defaults . bracketHighlight ; } public final boolean isBlockCaretEnabled ( ) { return defaults . blockCaret ; } public interface Highlight { void init ( JEditTextArea textArea , Highlight next ) ; void paintHighlight ( Graphics gfx , int line , int y ) ; String getToolTipText ( MouseEvent evt ) ; } public FontMetrics getFontMetrics ( ) { return fm ; } public FontMetrics getFontMetrics ( SyntaxStyle style ) { return getFontMetrics ( style . isBold ( ) ? boldFont : plainFont ) ; } public void paint ( Graphics gfx ) { Graphics2D g2 = ( Graphics2D ) gfx ; g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , antialias ? RenderingHints . VALUE_TEXT_ANTIALIAS_ON : RenderingHints . VALUE_TEXT_ANTIALIAS_OFF ) ; tabSize = fm . charWidth ( ' ' ) * ( ( Integer ) textArea . getDocument ( ) . getProperty ( PlainDocument . tabSizeAttribute ) ) . intValue ( ) ; Rectangle clipRect = gfx . getClipBounds ( ) ; gfx . setColor ( getBackground ( ) ) ; gfx . fillRect ( clipRect . x , clipRect . y , clipRect . width , clipRect . height ) ; int height = fm . getHeight ( ) ; int firstLine = textArea . getFirstLine ( ) ; int firstInvalid = firstLine + clipRect . y / height ; int lastInvalid = firstLine + ( clipRect . y + clipRect . height - 1 ) / height ; try { TokenMarker tokenMarker = textArea . getDocument ( ) . getTokenMarker ( ) ; int x = textArea . getHorizontalOffset ( ) ; for ( int line = firstInvalid ; line <= lastInvalid ; line ++ ) { paintLine ( gfx , line , x , tokenMarker ) ; } if ( tokenMarker != null && tokenMarker . isNextLineRequested ( ) ) { int h = clipRect . y + clipRect . height ; repaint ( 0 , h , getWidth ( ) , getHeight ( ) - h ) ; } } catch ( Exception e ) { System . err . println ( "Error repainting line" + " range {" + firstInvalid + "," + lastInvalid + "}:" ) ; e . printStackTrace ( ) ; } } public Printable getPrintable ( ) { return new Printable ( ) { @ Override public int print ( Graphics graphics , PageFormat pageFormat , int pageIndex ) throws PrinterException { int lineHeight = fm . getHeight ( ) ; int linesPerPage = ( int ) ( pageFormat . getImageableHeight ( ) / lineHeight ) ; int lineCount = textArea . getLineCount ( ) ; int lastPage = lineCount / linesPerPage ; if ( pageIndex > lastPage ) { return NO_SUCH_PAGE ; } else { Graphics2D g2 = ( Graphics2D ) graphics ; TokenMarker tokenMarker = textArea . getDocument ( ) . getTokenMarker ( ) ; int firstLine = pageIndex * linesPerPage ; g2 . translate ( Math . max ( 54 , pageFormat . getImageableX ( ) ) , pageFormat . getImageableY ( ) - firstLine * lineHeight ) ; printing = true ; for ( int line = firstLine ; line < firstLine + linesPerPage ; line ++ ) { paintLine ( g2 , line , 0 , tokenMarker ) ; } printing = false ; return PAGE_EXISTS ; } } } ; } final public void invalidateLine ( int line ) { repaint ( 0 , textArea . lineToY ( line ) + fm . getMaxDescent ( ) + fm . getLeading ( ) , getWidth ( ) , fm . getHeight ( ) ) ; } final void invalidateLineRange ( int firstLine , int lastLine ) { repaint ( 0 , textArea . lineToY ( firstLine ) + fm . getMaxDescent ( ) + fm . getLeading ( ) , getWidth ( ) , ( lastLine - firstLine + 1 ) * fm . getHeight ( ) ) ; } final void invalidateSelectedLines ( ) { invalidateLineRange ( textArea . getSelectionStartLine ( ) , textArea . getSelectionStopLine ( ) ) ; } @ Override public float nextTabStop ( float x , int tabOffset ) { int offset = textArea . getHorizontalOffset ( ) ; int ntabs = ( ( int ) x - offset ) / tabSize ; return ( ntabs + 1 ) * tabSize + offset ; } public Dimension getPreferredSize ( ) { return new Dimension ( fm . charWidth ( 'w' ) * defaults . cols , fm . getHeight ( ) * defaults . rows ) ; } public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } public int getCurrentLineIndex ( ) { return currentLineIndex ; } public void setCurrentLineIndex ( int what ) { currentLineIndex = what ; } public Token getCurrentLineTokens ( ) { return currentLineTokens ; } public void setCurrentLineTokens ( Token tokens ) { currentLineTokens = tokens ; } public Segment getCurrentLine ( ) { return currentLine ; } protected void paintLine ( Graphics gfx , int line , int x , TokenMarker tokenMarker ) { currentLineIndex = line ; int y = textArea . lineToY ( line ) ; if ( tokenMarker == null ) { paintPlainLine ( gfx , line , x , y ) ; } else if ( line >= 0 && line < textArea . getLineCount ( ) ) { paintSyntaxLine ( gfx , line , x , y , tokenMarker ) ; } } protected void paintPlainLine ( Graphics gfx , int line , int x , int y ) { if ( ! printing ) { paintHighlight ( gfx , line , y ) ; } textArea . getLineText ( line , currentLine ) ; y += fm . getHeight ( ) ; for ( int i = 0 ; i < currentLine . count ; i ++ ) { gfx . drawChars ( currentLine . array , currentLine . offset + i , 1 , x , y ) ; x = currentLine . array [ currentLine . offset + i ] == '\t' ? ( int ) nextTabStop ( x , i ) : x + fm . charWidth ( currentLine . array [ currentLine . offset + i ] ) ; } if ( compositionTextPainter != null && compositionTextPainter . hasComposedTextLayout ( ) ) { compositionTextPainter . draw ( gfx , defaults . lineHighlightColor ) ; } if ( defaults . eolMarkers ) { gfx . setColor ( defaults . eolMarkerColor ) ; gfx . drawString ( "." , x , y ) ; } } protected void paintSyntaxLine ( Graphics gfx , int line , int x , int y , TokenMarker tokenMarker ) { textArea . getLineText ( currentLineIndex , currentLine ) ; currentLineTokens = tokenMarker . markTokens ( currentLine , currentLineIndex ) ; paintHighlight ( gfx , line , y ) ; y += fm . getHeight ( ) ; x = paintSyntaxLine ( gfx , currentLine , x , y , currentLineTokens , defaults . styles ) ; if ( compositionTextPainter != null && compositionTextPainter . hasComposedTextLayout ( ) ) { compositionTextPainter . draw ( gfx , defaults . lineHighlightColor ) ; } if ( defaults . eolMarkers ) { gfx . setColor ( defaults . eolMarkerColor ) ; gfx . drawString ( "." , x , y ) ; } } protected int paintSyntaxLine ( Graphics gfx , Segment line , int x , int y , Token tokens , SyntaxStyle [ ] styles ) { for ( ; ; ) { byte id = tokens . id ; if ( id == Token . END ) break ; int length = tokens . length ; if ( id == Token . NULL ) { gfx . setColor ( defaults . fgcolor ) ; gfx . setFont ( plainFont ) ; } else { SyntaxStyle ss = styles [ id ] ; gfx . setColor ( ss . getColor ( ) ) ; gfx . setFont ( ss . isBold ( ) ? boldFont : plainFont ) ; } line . count = length ; for ( int i = 0 ; i < line . count ; i ++ ) { gfx . drawChars ( line . array , line . offset + i , 1 , x , y ) ; x = line . array [ line . offset + i ] == '\t' ? ( int ) nextTabStop ( x , i ) : x + fm . charWidth ( line . array [ line . offset + i ] ) ; } line . offset += length ; tokens = tokens . next ; } return x ; } protected void paintHighlight ( Graphics gfx , int line , int y ) { if ( line >= textArea . getSelectionStartLine ( ) && line <= textArea . getSelectionStopLine ( ) ) { paintLineHighlight ( gfx , line , y ) ; } if ( highlights != null ) { highlights . paintHighlight ( gfx , line , y ) ; } if ( defaults . bracketHighlight && line == textArea . getBracketLine ( ) ) { paintBracketHighlight ( gfx , line , y ) ; } if ( line == textArea . getCaretLine ( ) ) { paintCaret ( gfx , line , y ) ; } } protected void paintLineHighlight ( Graphics gfx , int line , int y ) { int height = fm . getHeight ( ) ; y += fm . getLeading ( ) + fm . getMaxDescent ( ) ; int selectionStart = textArea . getSelectionStart ( ) ; int selectionEnd = textArea . getSelectionStop ( ) ; if ( selectionStart == selectionEnd ) { if ( defaults . lineHighlight ) { gfx . setColor ( defaults . lineHighlightColor ) ; gfx . fillRect ( 0 , y , getWidth ( ) , height ) ; } } else { gfx . setColor ( defaults . selectionColor ) ; int selectionStartLine = textArea . getSelectionStartLine ( ) ; int selectionEndLine = textArea . getSelectionStopLine ( ) ; int lineStart = textArea . getLineStartOffset ( line ) ; int x1 , x2 ; if ( textArea . isSelectionRectangular ( ) ) { int lineLen = textArea . getLineLength ( line ) ; x1 = textArea . _offsetToX ( line , Math . min ( lineLen , selectionStart - textArea . getLineStartOffset ( selectionStartLine ) ) ) ; x2 = textArea . _offsetToX ( line , Math . min ( lineLen , selectionEnd - textArea . getLineStartOffset ( selectionEndLine ) ) ) ; if ( x1 == x2 ) x2 ++ ; } else if ( selectionStartLine == selectionEndLine ) { x1 = textArea . _offsetToX ( line , selectionStart - lineStart ) ; x2 = textArea . _offsetToX ( line , selectionEnd - lineStart ) ; } else if ( line == selectionStartLine ) { x1 = textArea . _offsetToX ( line , selectionStart - lineStart ) ; x2 = getWidth ( ) ; } else if ( line == selectionEndLine ) { x1 = textArea . _offsetToX ( line , 0 ) ; x2 = textArea . _offsetToX ( line , selectionEnd - lineStart ) ; } else { x1 = textArea . _offsetToX ( line , 0 ) ; x2 = getWidth ( ) ; } gfx . fillRect ( x1 > x2 ? x2 : x1 , y , x1 > x2 ? ( x1 - x2 ) : ( x2 - x1 ) , height ) ; } } protected void paintBracketHighlight ( Graphics gfx , int line , int y ) { int position = textArea . getBracketPosition ( ) ; if ( position != - 1 ) { y += fm . getLeading ( ) + fm . getMaxDescent ( ) ; int x = textArea . _offsetToX ( line , position ) ; gfx . setColor ( defaults . bracketHighlightColor ) ; gfx . drawRect ( x , y , fm . charWidth ( '(' ) - 1 , fm . getHeight ( ) - 1 ) ; } } protected void paintCaret ( Graphics gfx , int line , int y ) { if ( textArea . isCaretVisible ( ) ) { int offset = textArea . getCaretPosition ( ) - textArea . getLineStartOffset ( line ) ; int caretX = textArea . _offsetToX ( line , offset ) ; int caretWidth = ( ( defaults . blockCaret || textArea . isOverwriteEnabled ( ) ) ? fm . charWidth ( 'w' ) : 1 ) ; y += fm . getLeading ( ) + fm . getMaxDescent ( ) ; int height = fm . getHeight ( ) ; gfx . setColor ( defaults . caretColor ) ; if ( textArea . isOverwriteEnabled ( ) ) { gfx . fillRect ( caretX , y + height - 1 , caretWidth , 1 ) ; } else { if ( caretWidth == 1 ) { gfx . drawLine ( caretX , y , caretX , y + height - 1 ) ; } else { gfx . drawRect ( caretX , y , caretWidth - 1 , height - 1 ) ; } } } } }
package processing . app . syntax ; import javax . swing . event . * ; import javax . swing . text . * ; import javax . swing . undo . UndoableEdit ; public class SyntaxDocument extends PlainDocument { public TokenMarker getTokenMarker ( ) { return tokenMarker ; } public void setTokenMarker ( TokenMarker tm ) { tokenMarker = tm ; if ( tm == null ) return ; tokenMarker . insertLines ( 0 , getDefaultRootElement ( ) . getElementCount ( ) ) ; tokenizeLines ( ) ; } public void tokenizeLines ( ) { tokenizeLines ( 0 , getDefaultRootElement ( ) . getElementCount ( ) ) ; } public void tokenizeLines ( int start , int len ) { if ( tokenMarker == null || ! tokenMarker . supportsMultilineTokens ( ) ) return ; Segment lineSegment = new Segment ( ) ; Element map = getDefaultRootElement ( ) ; len += start ; try { for ( int i = start ; i < len ; i ++ ) { Element lineElement = map . getElement ( i ) ; int lineStart = lineElement . getStartOffset ( ) ; getText ( lineStart , lineElement . getEndOffset ( ) - lineStart - 1 , lineSegment ) ; tokenMarker . markTokens ( lineSegment , i ) ; } } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } } public void beginCompoundEdit ( ) { } public void endCompoundEdit ( ) { } public void addUndoableEdit ( UndoableEdit edit ) { } protected TokenMarker tokenMarker ; protected void fireInsertUpdate ( DocumentEvent evt ) { if ( tokenMarker != null ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch != null ) { tokenMarker . insertLines ( ch . getIndex ( ) + 1 , ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ) ; } } super . fireInsertUpdate ( evt ) ; } protected void fireRemoveUpdate ( DocumentEvent evt ) { if ( tokenMarker != null ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch != null ) { tokenMarker . deleteLines ( ch . getIndex ( ) + 1 , ch . getChildrenRemoved ( ) . length - ch . getChildrenAdded ( ) . length ) ; } } super . fireRemoveUpdate ( evt ) ; } }
package processing . app . syntax ; import java . util . ArrayList ; import java . util . List ; public class Brackets { private volatile List < Integer > offsets = null ; public void invalidate ( ) { offsets = null ; } public int findMatchingBracket ( final String text , final int pos ) { if ( pos < 0 || pos > text . length ( ) ) return - 1 ; final char alpha = text . charAt ( pos ) ; final char beta ; final int direction ; switch ( alpha ) { case '(' : beta = ')' ; direction = 1 ; break ; case ')' : beta = '(' ; direction = - 1 ; break ; case '[' : beta = ']' ; direction = 1 ; break ; case ']' : beta = '[' ; direction = - 1 ; break ; case '{' : beta = '}' ; direction = 1 ; break ; case '}' : beta = '{' ; direction = - 1 ; break ; default : return - 1 ; } if ( offsets == null ) parse ( text ) ; int p ; for ( p = 0 ; p < offsets . size ( ) ; p ++ ) if ( offsets . get ( p ) == pos ) break ; if ( p == offsets . size ( ) ) { return - 1 ; } int depth = 1 ; for ( p += direction ; p >= 0 && p < offsets . size ( ) ; p += direction ) { final int offset = offsets . get ( p ) ; final char c = text . charAt ( offset ) ; if ( c == alpha ) depth ++ ; else if ( c == beta ) depth -- ; if ( depth == 0 ) return offset ; } return - 1 ; } int pos ; private void parse ( final String text ) { offsets = new ArrayList < Integer > ( ) ; final int len = text . length ( ) ; for ( pos = 0 ; pos < len ; pos ++ ) { final char c = text . charAt ( pos ) ; if ( c == '/' && ( pos < len - 1 ) ) { final char d = text . charAt ( ++ pos ) ; if ( d == '/' ) { readComment ( text ) ; } else if ( d == '*' ) { readMLComment ( text ) ; } else pos -- ; } else if ( c == '"' || c == '\'' ) { readString ( text , c ) ; } else if ( c == '{' || c == '[' || c == '(' || c == '}' || c == ']' || c == ')' ) { offsets . add ( pos ) ; } } } private void readString ( final String text , final char q ) { final int len = text . length ( ) ; for ( pos ++ ; pos < len ; pos ++ ) { final char c = text . charAt ( pos ) ; if ( c == q ) { return ; } if ( c == '\\' ) { pos ++ ; } } } private void readComment ( final String text ) { final int len = text . length ( ) ; for ( pos ++ ; pos < len ; pos ++ ) if ( text . charAt ( pos ) == '\n' ) { return ; } } private void readMLComment ( final String text ) { final int len = text . length ( ) ; for ( pos ++ ; pos < len ; pos ++ ) { final char c = text . charAt ( pos ) ; if ( c == '*' && ( pos < len - 1 ) ) { pos ++ ; final char d = text . charAt ( pos ) ; if ( d == '/' ) { return ; } } } } }
package processing . app . syntax ; import processing . app . * ; public class PdeTextAreaDefaults extends TextAreaDefaults { public PdeTextAreaDefaults ( Mode mode ) { document = new SyntaxDocument ( ) ; electricScroll = 0 ; caretVisible = true ; caretBlinks = Preferences . getBoolean ( "editor.caret.blink" ) ; blockCaret = Preferences . getBoolean ( "editor.caret.block" ) ; cols = 80 ; rows = 5 ; fgcolor = mode . getColor ( "editor.fgcolor" ) ; bgcolor = mode . getColor ( "editor.bgcolor" ) ; styles = new SyntaxStyle [ Token . ID_COUNT ] ; styles [ Token . COMMENT1 ] = mode . getStyle ( "comment1" ) ; styles [ Token . COMMENT2 ] = mode . getStyle ( "comment2" ) ; styles [ Token . KEYWORD1 ] = mode . getStyle ( "keyword1" ) ; styles [ Token . KEYWORD2 ] = mode . getStyle ( "keyword2" ) ; styles [ Token . KEYWORD3 ] = mode . getStyle ( "keyword3" ) ; styles [ Token . KEYWORD4 ] = mode . getStyle ( "keyword4" ) ; styles [ Token . KEYWORD5 ] = mode . getStyle ( "keyword5" ) ; styles [ Token . KEYWORD6 ] = mode . getStyle ( "keyword6" ) ; styles [ Token . FUNCTION1 ] = mode . getStyle ( "function1" ) ; styles [ Token . FUNCTION2 ] = mode . getStyle ( "function2" ) ; styles [ Token . FUNCTION3 ] = mode . getStyle ( "function3" ) ; styles [ Token . FUNCTION4 ] = mode . getStyle ( "function4" ) ; styles [ Token . LITERAL1 ] = mode . getStyle ( "literal1" ) ; styles [ Token . LITERAL2 ] = mode . getStyle ( "literal2" ) ; styles [ Token . LABEL ] = mode . getStyle ( "label" ) ; styles [ Token . OPERATOR ] = mode . getStyle ( "operator" ) ; styles [ Token . INVALID ] = mode . getStyle ( "invalid" ) ; caretColor = mode . getColor ( "editor.caret.color" ) ; selectionColor = mode . getColor ( "editor.selection.color" ) ; lineHighlight = mode . getBoolean ( "editor.linehighlight" ) ; lineHighlightColor = mode . getColor ( "editor.linehighlight.color" ) ; bracketHighlight = mode . getBoolean ( "editor.brackethighlight" ) ; bracketHighlightColor = mode . getColor ( "editor.brackethighlight.color" ) ; eolMarkers = mode . getBoolean ( "editor.eolmarkers" ) ; eolMarkerColor = mode . getColor ( "editor.eolmarkers.color" ) ; } }
package processing . app . syntax ; import java . awt . datatransfer . DataFlavor ; import java . awt . datatransfer . Transferable ; import java . awt . datatransfer . UnsupportedFlavorException ; import java . io . InputStream ; import java . io . Reader ; import java . io . StringReader ; import java . util . ArrayList ; import java . util . List ; public class HtmlSelection implements Transferable { private static List < DataFlavor > flavors ; static { try { flavors = new ArrayList < DataFlavor > ( ) ; flavors . add ( DataFlavor . stringFlavor ) ; flavors . add ( new DataFlavor ( "text/html;class=java.lang.String" ) ) ; flavors . add ( new DataFlavor ( "text/html;class=java.io.Reader" ) ) ; flavors . add ( new DataFlavor ( "text/html;charset=unicode;class=java.io.InputStream" ) ) ; } catch ( ClassNotFoundException ex ) { ex . printStackTrace ( ) ; } } private String html ; public HtmlSelection ( String html ) { this . html = html ; } public DataFlavor [ ] getTransferDataFlavors ( ) { return flavors . toArray ( new DataFlavor [ flavors . size ( ) ] ) ; } public boolean isDataFlavorSupported ( DataFlavor flavor ) { return flavors . contains ( flavor ) ; } public Object getTransferData ( DataFlavor flavor ) throws UnsupportedFlavorException { if ( flavor . equals ( DataFlavor . stringFlavor ) ) { return html ; } else if ( String . class . equals ( flavor . getRepresentationClass ( ) ) ) { return html ; } else if ( Reader . class . equals ( flavor . getRepresentationClass ( ) ) ) { return new StringReader ( html ) ; } else if ( InputStream . class . equals ( flavor . getRepresentationClass ( ) ) ) { return new StringReader ( html ) ; } throw new UnsupportedFlavorException ( flavor ) ; } }
package processing . app . syntax ; import javax . swing . KeyStroke ; import java . awt . event . * ; import java . awt . Toolkit ; import java . util . Map ; import java . util . HashMap ; import java . util . StringTokenizer ; public class DefaultInputHandler extends InputHandler { public DefaultInputHandler ( ) { bindings = currentBindings = new HashMap ( ) ; } public void addDefaultKeyBindings ( ) { addKeyBinding ( "BACK_SPACE" , BACKSPACE ) ; addKeyBinding ( "C+BACK_SPACE" , BACKSPACE_WORD ) ; addKeyBinding ( "DELETE" , DELETE ) ; addKeyBinding ( "C+DELETE" , DELETE_WORD ) ; addKeyBinding ( "ENTER" , INSERT_BREAK ) ; addKeyBinding ( "TAB" , INSERT_TAB ) ; addKeyBinding ( "INSERT" , OVERWRITE ) ; addKeyBinding ( "C+\\" , TOGGLE_RECT ) ; addKeyBinding ( "HOME" , HOME ) ; addKeyBinding ( "END" , END ) ; addKeyBinding ( "S+HOME" , SELECT_HOME ) ; addKeyBinding ( "S+END" , SELECT_END ) ; addKeyBinding ( "C+HOME" , DOCUMENT_HOME ) ; addKeyBinding ( "C+END" , DOCUMENT_END ) ; addKeyBinding ( "CS+HOME" , SELECT_DOC_HOME ) ; addKeyBinding ( "CS+END" , SELECT_DOC_END ) ; addKeyBinding ( "PAGE_UP" , PREV_PAGE ) ; addKeyBinding ( "PAGE_DOWN" , NEXT_PAGE ) ; addKeyBinding ( "S+PAGE_UP" , SELECT_PREV_PAGE ) ; addKeyBinding ( "S+PAGE_DOWN" , SELECT_NEXT_PAGE ) ; addKeyBinding ( "LEFT" , PREV_CHAR ) ; addKeyBinding ( "S+LEFT" , SELECT_PREV_CHAR ) ; addKeyBinding ( "C+LEFT" , PREV_WORD ) ; addKeyBinding ( "CS+LEFT" , SELECT_PREV_WORD ) ; addKeyBinding ( "RIGHT" , NEXT_CHAR ) ; addKeyBinding ( "S+RIGHT" , SELECT_NEXT_CHAR ) ; addKeyBinding ( "C+RIGHT" , NEXT_WORD ) ; addKeyBinding ( "CS+RIGHT" , SELECT_NEXT_WORD ) ; addKeyBinding ( "UP" , PREV_LINE ) ; addKeyBinding ( "S+UP" , SELECT_PREV_LINE ) ; addKeyBinding ( "DOWN" , NEXT_LINE ) ; addKeyBinding ( "S+DOWN" , SELECT_NEXT_LINE ) ; addKeyBinding ( "C+ENTER" , REPEAT ) ; } public void addKeyBinding ( String keyBinding , ActionListener action ) { Map current = bindings ; StringTokenizer st = new StringTokenizer ( keyBinding ) ; while ( st . hasMoreTokens ( ) ) { KeyStroke keyStroke = parseKeyStroke ( st . nextToken ( ) ) ; if ( keyStroke == null ) return ; if ( st . hasMoreTokens ( ) ) { Object o = current . get ( keyStroke ) ; if ( o instanceof Map ) current = ( Map ) o ; else { o = new HashMap ( ) ; current . put ( keyStroke , o ) ; current = ( Map ) o ; } } else current . put ( keyStroke , action ) ; } } public void removeKeyBinding ( String keyBinding ) { throw new InternalError ( "Not yet implemented" ) ; } public void removeAllKeyBindings ( ) { bindings . clear ( ) ; } public InputHandler copy ( ) { return new DefaultInputHandler ( this ) ; } public void keyPressed ( KeyEvent evt ) { int keyCode = evt . getKeyCode ( ) ; int modifiers = evt . getModifiers ( ) ; if ( keyCode == KeyEvent . VK_CONTROL || keyCode == KeyEvent . VK_SHIFT || keyCode == KeyEvent . VK_ALT || keyCode == KeyEvent . VK_META ) { return ; } if ( ( modifiers & InputEvent . META_MASK ) != 0 ) { KeyStroke keyStroke = KeyStroke . getKeyStroke ( keyCode , modifiers ) ; if ( currentBindings . get ( keyStroke ) == null ) { return ; } } if ( ( modifiers & ~ InputEvent . SHIFT_MASK ) != 0 || evt . isActionKey ( ) || keyCode == KeyEvent . VK_BACK_SPACE || keyCode == KeyEvent . VK_DELETE || keyCode == KeyEvent . VK_ENTER || keyCode == KeyEvent . VK_TAB || keyCode == KeyEvent . VK_ESCAPE ) { if ( grabAction != null ) { handleGrabAction ( evt ) ; return ; } KeyStroke keyStroke = KeyStroke . getKeyStroke ( keyCode , modifiers ) ; Object o = currentBindings . get ( keyStroke ) ; if ( o == null ) { if ( currentBindings != bindings ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; repeatCount = 0 ; repeat = false ; evt . consume ( ) ; } currentBindings = bindings ; return ; } else if ( o instanceof ActionListener ) { currentBindings = bindings ; executeAction ( ( ( ActionListener ) o ) , evt . getSource ( ) , null ) ; evt . consume ( ) ; return ; } else if ( o instanceof Map ) { currentBindings = ( Map ) o ; evt . consume ( ) ; return ; } } } public void keyTyped ( KeyEvent evt ) { int modifiers = evt . getModifiers ( ) ; char c = evt . getKeyChar ( ) ; if ( ( modifiers & InputEvent . META_MASK ) != 0 ) return ; if ( ( modifiers & InputEvent . CTRL_MASK ) != 0 && c == '/' ) return ; if ( c != KeyEvent . CHAR_UNDEFINED ) { if ( c >= 0x20 && c != 0x7f ) { KeyStroke keyStroke = KeyStroke . getKeyStroke ( Character . toUpperCase ( c ) ) ; Object o = currentBindings . get ( keyStroke ) ; if ( o instanceof Map ) { currentBindings = ( Map ) o ; return ; } else if ( o instanceof ActionListener ) { currentBindings = bindings ; executeAction ( ( ActionListener ) o , evt . getSource ( ) , String . valueOf ( c ) ) ; return ; } currentBindings = bindings ; if ( grabAction != null ) { handleGrabAction ( evt ) ; return ; } if ( repeat && Character . isDigit ( c ) ) { repeatCount *= 10 ; repeatCount += ( c - '0' ) ; return ; } executeAction ( INSERT_CHAR , evt . getSource ( ) , String . valueOf ( evt . getKeyChar ( ) ) ) ; repeatCount = 0 ; repeat = false ; } } } public static KeyStroke parseKeyStroke ( String keyStroke ) { if ( keyStroke == null ) return null ; int modifiers = 0 ; int index = keyStroke . indexOf ( '+' ) ; if ( index != - 1 ) { for ( int i = 0 ; i < index ; i ++ ) { switch ( Character . toUpperCase ( keyStroke . charAt ( i ) ) ) { case 'A' : modifiers |= InputEvent . ALT_MASK ; break ; case 'C' : modifiers |= InputEvent . CTRL_MASK ; break ; case 'M' : modifiers |= InputEvent . META_MASK ; break ; case 'S' : modifiers |= InputEvent . SHIFT_MASK ; break ; } } } String key = keyStroke . substring ( index + 1 ) ; if ( key . length ( ) == 1 ) { char ch = Character . toUpperCase ( key . charAt ( 0 ) ) ; if ( modifiers == 0 ) return KeyStroke . getKeyStroke ( ch ) ; else return KeyStroke . getKeyStroke ( ch , modifiers ) ; } else if ( key . length ( ) == 0 ) { System . err . println ( "Invalid key stroke: " + keyStroke ) ; return null ; } else { int ch ; try { ch = KeyEvent . class . getField ( "VK_" . concat ( key ) ) . getInt ( null ) ; } catch ( Exception e ) { System . err . println ( "Invalid key stroke: " + keyStroke ) ; return null ; } return KeyStroke . getKeyStroke ( ch , modifiers ) ; } } private Map bindings ; private Map currentBindings ; private DefaultInputHandler ( DefaultInputHandler copy ) { bindings = currentBindings = copy . bindings ; } }
package processing . app . syntax ; import javax . swing . text . Segment ; import processing . app . Editor ; public class PdeKeywords extends TokenMarker { private KeywordMap keywordColoring ; private int lastOffset ; private int lastKeyword ; public void addColoring ( String keyword , String coloring ) { if ( keywordColoring == null ) { keywordColoring = new KeywordMap ( false ) ; } int num = coloring . charAt ( coloring . length ( ) - 1 ) - '1' ; int id = 0 ; switch ( coloring . charAt ( 0 ) ) { case 'K' : id = Token . KEYWORD1 + num ; keywordColoring . add ( keyword , ( byte ) id , false ) ; if ( id == Token . KEYWORD6 ) { keywordColoring . add ( keyword , ( byte ) id , true ) ; } break ; case 'L' : id = Token . LITERAL1 + num ; keywordColoring . add ( keyword , ( byte ) id , false ) ; break ; case 'F' : id = Token . FUNCTION1 + num ; keywordColoring . add ( keyword , ( byte ) id , true ) ; break ; } } public byte markTokensImpl ( byte token , Segment line , int lineIndex ) { char [ ] array = line . array ; int offset = line . offset ; lastOffset = offset ; lastKeyword = offset ; int mlength = offset + line . count ; boolean backslash = false ; loop : for ( int i = offset ; i < mlength ; i ++ ) { int i1 = ( i + 1 ) ; char c = array [ i ] ; if ( c == '\\' ) { backslash = ! backslash ; continue ; } switch ( token ) { case Token . NULL : switch ( c ) { case '#' : if ( backslash ) backslash = false ; break ; case '"' : doKeyword ( line , i , c ) ; if ( backslash ) backslash = false ; else { addToken ( i - lastOffset , token ) ; token = Token . LITERAL1 ; lastOffset = lastKeyword = i ; } break ; case '\'' : doKeyword ( line , i , c ) ; if ( backslash ) backslash = false ; else { addToken ( i - lastOffset , token ) ; token = Token . LITERAL2 ; lastOffset = lastKeyword = i ; } break ; case ':' : if ( lastKeyword == offset ) { if ( doKeyword ( line , i , c ) ) break ; backslash = false ; addToken ( i1 - lastOffset , Token . LABEL ) ; lastOffset = lastKeyword = i1 ; } else if ( doKeyword ( line , i , c ) ) break ; break ; case '/' : backslash = false ; doKeyword ( line , i , c ) ; if ( mlength - i > 1 ) { switch ( array [ i1 ] ) { case '*' : addToken ( i - lastOffset , token ) ; lastOffset = lastKeyword = i ; if ( mlength - i > 2 && array [ i + 2 ] == '*' ) token = Token . COMMENT2 ; else token = Token . COMMENT1 ; break ; case '/' : addToken ( i - lastOffset , token ) ; addToken ( mlength - i , Token . COMMENT1 ) ; lastOffset = lastKeyword = mlength ; break loop ; } if ( array [ i1 ] != ' ' ) { i ++ ; } } break ; default : backslash = false ; if ( ! Character . isLetterOrDigit ( c ) && c != '_' ) { doKeyword ( line , i , c ) ; } break ; } break ; case Token . COMMENT1 : case Token . COMMENT2 : backslash = false ; if ( c == '*' && mlength - i > 1 ) { if ( array [ i1 ] == '/' ) { i ++ ; addToken ( ( i + 1 ) - lastOffset , token ) ; token = Token . NULL ; lastOffset = lastKeyword = i + 1 ; } } break ; case Token . LITERAL1 : if ( backslash ) backslash = false ; else if ( c == '"' ) { addToken ( i1 - lastOffset , token ) ; token = Token . NULL ; lastOffset = lastKeyword = i1 ; } break ; case Token . LITERAL2 : if ( backslash ) backslash = false ; else if ( c == '\'' ) { addToken ( i1 - lastOffset , Token . LITERAL1 ) ; token = Token . NULL ; lastOffset = lastKeyword = i1 ; } break ; default : throw new InternalError ( "Invalid state: " + token ) ; } } if ( token == Token . NULL ) { doKeyword ( line , mlength , '\0' ) ; } switch ( token ) { case Token . LITERAL1 : case Token . LITERAL2 : addToken ( mlength - lastOffset , Token . INVALID ) ; token = Token . NULL ; break ; case Token . KEYWORD2 : addToken ( mlength - lastOffset , token ) ; if ( ! backslash ) token = Token . NULL ; addToken ( mlength - lastOffset , token ) ; break ; default : addToken ( mlength - lastOffset , token ) ; break ; } return token ; } private boolean doKeyword ( Segment line , int i , char c ) { int i1 = i + 1 ; int len = i - lastKeyword ; boolean paren = Editor . checkParen ( line . array , i , line . array . length ) ; byte id = keywordColoring . lookup ( line , lastKeyword , len , paren ) ; if ( id != Token . NULL ) { if ( lastKeyword != lastOffset ) { addToken ( lastKeyword - lastOffset , Token . NULL ) ; } addToken ( len , id ) ; lastOffset = i ; } lastKeyword = i1 ; return false ; } }
package processing . app . syntax ; import java . awt . event . InputEvent ; import java . awt . event . KeyEvent ; import processing . app . Base ; import processing . app . Preferences ; public class PdeInputHandler extends DefaultInputHandler { public PdeInputHandler ( ) { String mod = Base . isMacOS ( ) ? "A" : "C" ; addKeyBinding ( "BACK_SPACE" , InputHandler . BACKSPACE ) ; if ( Preferences . getBoolean ( "editor.keys.shift_backspace_is_delete" ) ) { addKeyBinding ( "S+BACK_SPACE" , InputHandler . DELETE ) ; } else { addKeyBinding ( "S+BACK_SPACE" , InputHandler . BACKSPACE ) ; } addKeyBinding ( "DELETE" , InputHandler . DELETE ) ; addKeyBinding ( "S+DELETE" , InputHandler . DELETE ) ; addKeyBinding ( mod + "+BACK_SPACE" , InputHandler . BACKSPACE_WORD ) ; addKeyBinding ( mod + "S+BACK_SPACE" , InputHandler . BACKSPACE_WORD ) ; addKeyBinding ( mod + "+DELETE" , InputHandler . DELETE_WORD ) ; addKeyBinding ( mod + "S+DELETE" , InputHandler . DELETE_WORD ) ; addKeyBinding ( "INSERT" , InputHandler . OVERWRITE ) ; if ( Preferences . getBoolean ( "editor.keys.alternative_cut_copy_paste" ) ) { addKeyBinding ( "C+INSERT" , InputHandler . CLIPBOARD_COPY ) ; addKeyBinding ( "S+INSERT" , InputHandler . CLIPBOARD_PASTE ) ; addKeyBinding ( "S+DELETE" , InputHandler . CLIPBOARD_CUT ) ; } if ( Preferences . getBoolean ( "editor.keys.home_and_end_travel_far" ) ) { addKeyBinding ( "HOME" , InputHandler . DOCUMENT_HOME ) ; addKeyBinding ( "END" , InputHandler . DOCUMENT_END ) ; addKeyBinding ( "S+HOME" , InputHandler . SELECT_DOC_HOME ) ; addKeyBinding ( "S+END" , InputHandler . SELECT_DOC_END ) ; } else { addKeyBinding ( "HOME" , InputHandler . HOME ) ; addKeyBinding ( "END" , InputHandler . END ) ; addKeyBinding ( "S+HOME" , InputHandler . SELECT_HOME ) ; addKeyBinding ( "S+END" , InputHandler . SELECT_END ) ; addKeyBinding ( "C+HOME" , InputHandler . DOCUMENT_HOME ) ; addKeyBinding ( "C+END" , InputHandler . DOCUMENT_END ) ; addKeyBinding ( "CS+HOME" , InputHandler . SELECT_DOC_HOME ) ; addKeyBinding ( "CS+END" , InputHandler . SELECT_DOC_END ) ; } if ( Base . isMacOS ( ) ) { addKeyBinding ( "C+A" , InputHandler . HOME ) ; addKeyBinding ( "CS+A" , InputHandler . SELECT_HOME ) ; addKeyBinding ( "C+E" , InputHandler . END ) ; addKeyBinding ( "CS+E" , InputHandler . SELECT_END ) ; addKeyBinding ( "C+D" , InputHandler . DELETE ) ; addKeyBinding ( "C+B" , InputHandler . PREV_CHAR ) ; addKeyBinding ( "CS+B" , InputHandler . SELECT_PREV_CHAR ) ; addKeyBinding ( "C+F" , InputHandler . NEXT_CHAR ) ; addKeyBinding ( "CS+F" , InputHandler . SELECT_NEXT_CHAR ) ; addKeyBinding ( "C+H" , InputHandler . BACKSPACE ) ; addKeyBinding ( "C+N" , InputHandler . NEXT_LINE ) ; addKeyBinding ( "CS+N" , InputHandler . SELECT_NEXT_LINE ) ; addKeyBinding ( "C+P" , InputHandler . PREV_LINE ) ; addKeyBinding ( "CS+P" , InputHandler . SELECT_PREV_LINE ) ; } if ( Base . isMacOS ( ) ) { addKeyBinding ( "M+LEFT" , InputHandler . HOME ) ; addKeyBinding ( "M+RIGHT" , InputHandler . END ) ; addKeyBinding ( "MS+LEFT" , InputHandler . SELECT_HOME ) ; addKeyBinding ( "MS+RIGHT" , InputHandler . SELECT_END ) ; } else { addKeyBinding ( "C+LEFT" , InputHandler . HOME ) ; addKeyBinding ( "C+RIGHT" , InputHandler . END ) ; addKeyBinding ( "CS+HOME" , InputHandler . SELECT_HOME ) ; addKeyBinding ( "CS+END" , InputHandler . SELECT_END ) ; } addKeyBinding ( "PAGE_UP" , InputHandler . PREV_PAGE ) ; addKeyBinding ( "PAGE_DOWN" , InputHandler . NEXT_PAGE ) ; addKeyBinding ( "S+PAGE_UP" , InputHandler . SELECT_PREV_PAGE ) ; addKeyBinding ( "S+PAGE_DOWN" , InputHandler . SELECT_NEXT_PAGE ) ; addKeyBinding ( "LEFT" , InputHandler . PREV_CHAR ) ; addKeyBinding ( "S+LEFT" , InputHandler . SELECT_PREV_CHAR ) ; addKeyBinding ( mod + "+LEFT" , InputHandler . PREV_WORD ) ; addKeyBinding ( mod + "S+LEFT" , InputHandler . SELECT_PREV_WORD ) ; addKeyBinding ( "RIGHT" , InputHandler . NEXT_CHAR ) ; addKeyBinding ( "S+RIGHT" , InputHandler . SELECT_NEXT_CHAR ) ; addKeyBinding ( mod + "+RIGHT" , InputHandler . NEXT_WORD ) ; addKeyBinding ( mod + "S+RIGHT" , InputHandler . SELECT_NEXT_WORD ) ; addKeyBinding ( "UP" , InputHandler . PREV_LINE ) ; addKeyBinding ( mod + "+UP" , InputHandler . PREV_LINE ) ; addKeyBinding ( "S+UP" , InputHandler . SELECT_PREV_LINE ) ; addKeyBinding ( "DOWN" , InputHandler . NEXT_LINE ) ; addKeyBinding ( mod + "+DOWN" , InputHandler . NEXT_LINE ) ; addKeyBinding ( "S+DOWN" , InputHandler . SELECT_NEXT_LINE ) ; addKeyBinding ( "MS+UP" , InputHandler . SELECT_DOC_HOME ) ; addKeyBinding ( "CS+UP" , InputHandler . SELECT_DOC_HOME ) ; addKeyBinding ( "MS+DOWN" , InputHandler . SELECT_DOC_END ) ; addKeyBinding ( "CS+DOWN" , InputHandler . SELECT_DOC_END ) ; addKeyBinding ( mod + "+ENTER" , InputHandler . REPEAT ) ; } protected boolean isMnemonic ( KeyEvent event ) { if ( ! Base . isMacOS ( ) ) { if ( ( event . getModifiers ( ) & InputEvent . ALT_MASK ) != 0 && event . getKeyChar ( ) != KeyEvent . VK_UNDEFINED ) { return true ; } } return false ; } public void keyPressed ( KeyEvent event ) { if ( ( event . getModifiers ( ) & InputEvent . CTRL_MASK ) != 0 && event . getKeyChar ( ) == ',' ) { return ; } if ( isMnemonic ( event ) ) { return ; } if ( ! handlePressed ( event ) ) { super . keyPressed ( event ) ; } } public void keyTyped ( KeyEvent event ) { if ( isMnemonic ( event ) ) { return ; } if ( ! handleTyped ( event ) ) { super . keyTyped ( event ) ; } } public boolean handlePressed ( KeyEvent event ) { return false ; } public boolean handleTyped ( KeyEvent event ) { return false ; } }
package processing . app . syntax . im ; import java . awt . Font ; import java . awt . FontMetrics ; import java . awt . Graphics2D ; import java . awt . Point ; import java . awt . Rectangle ; import java . awt . font . FontRenderContext ; import java . awt . font . TextAttribute ; import java . awt . font . TextLayout ; import java . text . AttributedCharacterIterator ; import java . text . AttributedString ; import java . text . CharacterIterator ; import javax . swing . text . BadLocationException ; import processing . app . syntax . JEditTextArea ; import processing . app . syntax . TextAreaPainter ; public class CompositionTextManager { private JEditTextArea textArea ; private String prevComposeString ; private int prevCommittedCount ; private boolean isInputProcess ; private int initialCaretPosition ; public static final int COMPOSING_UNDERBAR_HEIGHT = 5 ; public CompositionTextManager ( JEditTextArea textArea ) { this . textArea = textArea ; prevComposeString = "" ; isInputProcess = false ; prevCommittedCount = 0 ; } public boolean getIsInputProcess ( ) { return isInputProcess ; } public void insertFullWidthSpace ( ) { initialCaretPosition = textArea . getCaretPosition ( ) ; int layoutCaretPosition = initialCaretPosition ; try { textArea . getDocument ( ) . insertString ( layoutCaretPosition , "\u3000" , null ) ; } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } } public void beginCompositionText ( AttributedCharacterIterator text , int committed_count ) { isInputProcess = true ; prevComposeString = "" ; initialCaretPosition = textArea . getCaretPosition ( ) ; processCompositionText ( text , committed_count ) ; } public void processCompositionText ( AttributedCharacterIterator text , int committed_count ) { int layoutCaretPosition = initialCaretPosition + committed_count ; CompositionTextPainter compositionPainter = textArea . getPainter ( ) . getCompositionTextpainter ( ) ; compositionPainter . setComposedTextLayout ( getTextLayout ( text , committed_count ) , layoutCaretPosition ) ; int textLength = text . getEndIndex ( ) - text . getBeginIndex ( ) - committed_count ; StringBuilder unCommitedStringBuf = new StringBuilder ( textLength ) ; char c ; for ( c = text . setIndex ( committed_count ) ; c != CharacterIterator . DONE && textLength > 0 ; c = text . next ( ) , -- textLength ) { unCommitedStringBuf . append ( c ) ; } String unCommittedString = unCommitedStringBuf . toString ( ) ; try { if ( canRemovePreviousInput ( committed_count ) ) { textArea . getDocument ( ) . remove ( layoutCaretPosition , prevComposeString . length ( ) ) ; } textArea . getDocument ( ) . insertString ( layoutCaretPosition , unCommittedString , null ) ; if ( committed_count > 0 ) { initialCaretPosition = initialCaretPosition + committed_count ; } prevComposeString = unCommittedString ; prevCommittedCount = committed_count ; } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } } private boolean canRemovePreviousInput ( int committed_count ) { return ( prevCommittedCount == committed_count || prevCommittedCount > committed_count ) ; } public void endCompositionText ( AttributedCharacterIterator text , int committed_count ) { if ( committed_count == 0 ) { removeNotCommittedText ( text ) ; } CompositionTextPainter compositionPainter = textArea . getPainter ( ) . getCompositionTextpainter ( ) ; compositionPainter . invalidateComposedTextLayout ( initialCaretPosition + committed_count ) ; prevComposeString = "" ; isInputProcess = false ; } private void removeNotCommittedText ( AttributedCharacterIterator text ) { if ( prevComposeString . length ( ) == 0 ) { return ; } try { textArea . getDocument ( ) . remove ( initialCaretPosition , prevComposeString . length ( ) ) ; } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } } private TextLayout getTextLayout ( AttributedCharacterIterator text , int committed_count ) { AttributedString composed = new AttributedString ( text , committed_count , text . getEndIndex ( ) ) ; Font font = textArea . getPainter ( ) . getFont ( ) ; FontRenderContext context = ( ( Graphics2D ) ( textArea . getPainter ( ) . getGraphics ( ) ) ) . getFontRenderContext ( ) ; composed . addAttribute ( TextAttribute . FONT , font ) ; TextLayout layout = new TextLayout ( composed . getIterator ( ) , context ) ; return layout ; } private Point getCaretLocation ( ) { Point loc = new Point ( ) ; TextAreaPainter painter = textArea . getPainter ( ) ; FontMetrics fm = painter . getFontMetrics ( ) ; int offsetY = fm . getHeight ( ) - COMPOSING_UNDERBAR_HEIGHT ; int lineIndex = textArea . getCaretLine ( ) ; loc . y = lineIndex * fm . getHeight ( ) + offsetY ; int offsetX = textArea . getCaretPosition ( ) - textArea . getLineStartOffset ( lineIndex ) ; loc . x = textArea . offsetToX ( lineIndex , offsetX ) ; return loc ; } public Rectangle getTextLocation ( ) { Point caret = getCaretLocation ( ) ; return getCaretRectangle ( caret . x , caret . y ) ; } private Rectangle getCaretRectangle ( int x , int y ) { TextAreaPainter painter = textArea . getPainter ( ) ; Point origin = painter . getLocationOnScreen ( ) ; int height = painter . getFontMetrics ( ) . getHeight ( ) ; return new Rectangle ( origin . x + x , origin . y + y , 0 , height ) ; } public AttributedCharacterIterator getCommittedText ( int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; String textAreaString = textArea . getText ( beginIndex , length ) ; return new AttributedString ( textAreaString ) . getIterator ( ) ; } public int getInsertPositionOffset ( ) { return textArea . getCaretPosition ( ) * - 1 ; } }
package processing . app . syntax . im ; import java . awt . Rectangle ; import java . awt . event . InputMethodEvent ; import java . awt . event . InputMethodListener ; import java . awt . font . TextHitInfo ; import java . awt . im . InputMethodRequests ; import java . text . AttributedCharacterIterator ; import processing . app . syntax . JEditTextArea ; public class InputMethodSupport implements InputMethodRequests , InputMethodListener { private int committed_count = 0 ; private CompositionTextManager textManager ; public InputMethodSupport ( JEditTextArea textArea ) { textManager = new CompositionTextManager ( textArea ) ; textArea . enableInputMethods ( true ) ; textArea . addInputMethodListener ( this ) ; } public Rectangle getTextLocation ( TextHitInfo offset ) { return textManager . getTextLocation ( ) ; } public TextHitInfo getLocationOffset ( int x , int y ) { return null ; } public int getInsertPositionOffset ( ) { return textManager . getInsertPositionOffset ( ) ; } public AttributedCharacterIterator getCommittedText ( int beginIndex , int endIndex , AttributedCharacterIterator . Attribute [ ] attributes ) { return textManager . getCommittedText ( beginIndex , endIndex ) ; } public int getCommittedTextLength ( ) { return committed_count ; } public AttributedCharacterIterator cancelLatestCommittedText ( AttributedCharacterIterator . Attribute [ ] attributes ) { return null ; } public AttributedCharacterIterator getSelectedText ( AttributedCharacterIterator . Attribute [ ] attributes ) { return null ; } public void inputMethodTextChanged ( InputMethodEvent event ) { AttributedCharacterIterator text = event . getText ( ) ; committed_count = event . getCommittedCharacterCount ( ) ; if ( isFullWidthSpaceInput ( text ) ) { textManager . insertFullWidthSpace ( ) ; caretPositionChanged ( event ) ; return ; } if ( isBeginInputProcess ( text , textManager ) ) { textManager . beginCompositionText ( text , committed_count ) ; caretPositionChanged ( event ) ; return ; } if ( isInputProcess ( text ) ) { textManager . processCompositionText ( text , committed_count ) ; caretPositionChanged ( event ) ; return ; } textManager . endCompositionText ( text , committed_count ) ; caretPositionChanged ( event ) ; } private boolean isFullWidthSpaceInput ( AttributedCharacterIterator text ) { if ( text == null ) return false ; if ( textManager . getIsInputProcess ( ) ) return false ; return ( String . valueOf ( text . first ( ) ) . equals ( "\u3000" ) ) ; } private boolean isBeginInputProcess ( AttributedCharacterIterator text , CompositionTextManager textManager ) { if ( text == null ) return false ; if ( textManager . getIsInputProcess ( ) ) return false ; return ( isInputProcess ( text ) ) ; } private boolean isInputProcess ( AttributedCharacterIterator text ) { if ( text == null ) return false ; return ( text . getEndIndex ( ) - ( text . getBeginIndex ( ) + committed_count ) > 0 ) ; } public void caretPositionChanged ( InputMethodEvent event ) { event . consume ( ) ; } }
package processing . core ; import java . io . Serializable ; import processing . core . PApplet ; import processing . core . PConstants ; public class PVector implements Serializable { public float x ; public float y ; public float z ; transient protected float [ ] array ; public PVector ( ) { } public PVector ( float x , float y , float z ) { this . x = x ; this . y = y ; this . z = z ; } public PVector ( float x , float y ) { this . x = x ; this . y = y ; this . z = 0 ; } public PVector set ( float x , float y , float z ) { this . x = x ; this . y = y ; this . z = z ; return this ; } public PVector set ( float x , float y ) { this . x = x ; this . y = y ; return this ; } public PVector set ( PVector v ) { x = v . x ; y = v . y ; z = v . z ; return this ; } public PVector set ( float [ ] source ) { if ( source . length >= 2 ) { x = source [ 0 ] ; y = source [ 1 ] ; } if ( source . length >= 3 ) { z = source [ 2 ] ; } return this ; } static public PVector random2D ( ) { return random2D ( null , null ) ; } static public PVector random2D ( PApplet parent ) { return random2D ( null , parent ) ; } static public PVector random2D ( PVector target ) { return random2D ( target , null ) ; } static public PVector random2D ( PVector target , PApplet parent ) { return ( parent == null ) ? fromAngle ( ( float ) ( Math . random ( ) * Math . PI * 2 ) , target ) : fromAngle ( parent . random ( PConstants . TAU ) , target ) ; } static public PVector random3D ( ) { return random3D ( null , null ) ; } static public PVector random3D ( PApplet parent ) { return random3D ( null , parent ) ; } static public PVector random3D ( PVector target ) { return random3D ( target , null ) ; } static public PVector random3D ( PVector target , PApplet parent ) { float angle ; float vz ; if ( parent == null ) { angle = ( float ) ( Math . random ( ) * Math . PI * 2 ) ; vz = ( float ) ( Math . random ( ) * 2 - 1 ) ; } else { angle = parent . random ( PConstants . TWO_PI ) ; vz = parent . random ( - 1 , 1 ) ; } float vx = ( float ) ( Math . sqrt ( 1 - vz * vz ) * Math . cos ( angle ) ) ; float vy = ( float ) ( Math . sqrt ( 1 - vz * vz ) * Math . sin ( angle ) ) ; if ( target == null ) { target = new PVector ( vx , vy , vz ) ; } else { target . set ( vx , vy , vz ) ; } return target ; } static public PVector fromAngle ( float angle ) { return fromAngle ( angle , null ) ; } static public PVector fromAngle ( float angle , PVector target ) { if ( target == null ) { target = new PVector ( ( float ) Math . cos ( angle ) , ( float ) Math . sin ( angle ) , 0 ) ; } else { target . set ( ( float ) Math . cos ( angle ) , ( float ) Math . sin ( angle ) , 0 ) ; } return target ; } public PVector copy ( ) { return new PVector ( x , y , z ) ; } @ Deprecated public PVector get ( ) { return copy ( ) ; } public float [ ] get ( float [ ] target ) { if ( target == null ) { return new float [ ] { x , y , z } ; } if ( target . length >= 2 ) { target [ 0 ] = x ; target [ 1 ] = y ; } if ( target . length >= 3 ) { target [ 2 ] = z ; } return target ; } public float mag ( ) { return ( float ) Math . sqrt ( x * x + y * y + z * z ) ; } public float magSq ( ) { return ( x * x + y * y + z * z ) ; } public PVector add ( PVector v ) { x += v . x ; y += v . y ; z += v . z ; return this ; } public PVector add ( float x , float y , float z ) { this . x += x ; this . y += y ; this . z += z ; return this ; } static public PVector add ( PVector v1 , PVector v2 ) { return add ( v1 , v2 , null ) ; } static public PVector add ( PVector v1 , PVector v2 , PVector target ) { if ( target == null ) { target = new PVector ( v1 . x + v2 . x , v1 . y + v2 . y , v1 . z + v2 . z ) ; } else { target . set ( v1 . x + v2 . x , v1 . y + v2 . y , v1 . z + v2 . z ) ; } return target ; } public PVector sub ( PVector v ) { x -= v . x ; y -= v . y ; z -= v . z ; return this ; } public PVector sub ( float x , float y , float z ) { this . x -= x ; this . y -= y ; this . z -= z ; return this ; } static public PVector sub ( PVector v1 , PVector v2 ) { return sub ( v1 , v2 , null ) ; } static public PVector sub ( PVector v1 , PVector v2 , PVector target ) { if ( target == null ) { target = new PVector ( v1 . x - v2 . x , v1 . y - v2 . y , v1 . z - v2 . z ) ; } else { target . set ( v1 . x - v2 . x , v1 . y - v2 . y , v1 . z - v2 . z ) ; } return target ; } public PVector mult ( float n ) { x *= n ; y *= n ; z *= n ; return this ; } static public PVector mult ( PVector v , float n ) { return mult ( v , n , null ) ; } static public PVector mult ( PVector v , float n , PVector target ) { if ( target == null ) { target = new PVector ( v . x * n , v . y * n , v . z * n ) ; } else { target . set ( v . x * n , v . y * n , v . z * n ) ; } return target ; } public PVector div ( float n ) { x /= n ; y /= n ; z /= n ; return this ; } static public PVector div ( PVector v , float n ) { return div ( v , n , null ) ; } static public PVector div ( PVector v , float n , PVector target ) { if ( target == null ) { target = new PVector ( v . x / n , v . y / n , v . z / n ) ; } else { target . set ( v . x / n , v . y / n , v . z / n ) ; } return target ; } public float dist ( PVector v ) { float dx = x - v . x ; float dy = y - v . y ; float dz = z - v . z ; return ( float ) Math . sqrt ( dx * dx + dy * dy + dz * dz ) ; } static public float dist ( PVector v1 , PVector v2 ) { float dx = v1 . x - v2 . x ; float dy = v1 . y - v2 . y ; float dz = v1 . z - v2 . z ; return ( float ) Math . sqrt ( dx * dx + dy * dy + dz * dz ) ; } public float dot ( PVector v ) { return x * v . x + y * v . y + z * v . z ; } public float dot ( float x , float y , float z ) { return this . x * x + this . y * y + this . z * z ; } static public float dot ( PVector v1 , PVector v2 ) { return v1 . x * v2 . x + v1 . y * v2 . y + v1 . z * v2 . z ; } public PVector cross ( PVector v ) { return cross ( v , null ) ; } public PVector cross ( PVector v , PVector target ) { float crossX = y * v . z - v . y * z ; float crossY = z * v . x - v . z * x ; float crossZ = x * v . y - v . x * y ; if ( target == null ) { target = new PVector ( crossX , crossY , crossZ ) ; } else { target . set ( crossX , crossY , crossZ ) ; } return target ; } static public PVector cross ( PVector v1 , PVector v2 , PVector target ) { float crossX = v1 . y * v2 . z - v2 . y * v1 . z ; float crossY = v1 . z * v2 . x - v2 . z * v1 . x ; float crossZ = v1 . x * v2 . y - v2 . x * v1 . y ; if ( target == null ) { target = new PVector ( crossX , crossY , crossZ ) ; } else { target . set ( crossX , crossY , crossZ ) ; } return target ; } public PVector normalize ( ) { float m = mag ( ) ; if ( m != 0 && m != 1 ) { div ( m ) ; } return this ; } public PVector normalize ( PVector target ) { if ( target == null ) { target = new PVector ( ) ; } float m = mag ( ) ; if ( m > 0 ) { target . set ( x / m , y / m , z / m ) ; } else { target . set ( x , y , z ) ; } return target ; } public PVector limit ( float max ) { if ( magSq ( ) > max * max ) { normalize ( ) ; mult ( max ) ; } return this ; } public PVector setMag ( float len ) { normalize ( ) ; mult ( len ) ; return this ; } public PVector setMag ( PVector target , float len ) { target = normalize ( target ) ; target . mult ( len ) ; return target ; } public float heading ( ) { float angle = ( float ) Math . atan2 ( - y , x ) ; return - 1 * angle ; } @ Deprecated public float heading2D ( ) { return heading ( ) ; } public PVector rotate ( float theta ) { float temp = x ; x = x * PApplet . cos ( theta ) - y * PApplet . sin ( theta ) ; y = temp * PApplet . sin ( theta ) + y * PApplet . cos ( theta ) ; return this ; } public PVector lerp ( PVector v , float amt ) { x = PApplet . lerp ( x , v . x , amt ) ; y = PApplet . lerp ( y , v . y , amt ) ; z = PApplet . lerp ( z , v . z , amt ) ; return this ; } public static PVector lerp ( PVector v1 , PVector v2 , float amt ) { PVector v = v1 . copy ( ) ; v . lerp ( v2 , amt ) ; return v ; } public PVector lerp ( float x , float y , float z , float amt ) { this . x = PApplet . lerp ( this . x , x , amt ) ; this . y = PApplet . lerp ( this . y , y , amt ) ; this . z = PApplet . lerp ( this . z , z , amt ) ; return this ; } static public float angleBetween ( PVector v1 , PVector v2 ) { if ( v1 . x == 0 && v1 . y == 0 && v1 . z == 0 ) return 0.0f ; if ( v2 . x == 0 && v2 . y == 0 && v2 . z == 0 ) return 0.0f ; double dot = v1 . x * v2 . x + v1 . y * v2 . y + v1 . z * v2 . z ; double v1mag = Math . sqrt ( v1 . x * v1 . x + v1 . y * v1 . y + v1 . z * v1 . z ) ; double v2mag = Math . sqrt ( v2 . x * v2 . x + v2 . y * v2 . y + v2 . z * v2 . z ) ; double amt = dot / ( v1mag * v2mag ) ; if ( amt <= - 1 ) { return PConstants . PI ; } else if ( amt >= 1 ) { return 0 ; } return ( float ) Math . acos ( amt ) ; } @ Override public String toString ( ) { return "[ " + x + ", " + y + ", " + z + " ]" ; } public float [ ] array ( ) { if ( array == null ) { array = new float [ 3 ] ; } array [ 0 ] = x ; array [ 1 ] = y ; array [ 2 ] = z ; return array ; } @ Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof PVector ) ) { return false ; } final PVector p = ( PVector ) obj ; return x == p . x && y == p . y && z == p . z ; } @ Override public int hashCode ( ) { int result = 1 ; result = 31 * result + Float . floatToIntBits ( x ) ; result = 31 * result + Float . floatToIntBits ( y ) ; result = 31 * result + Float . floatToIntBits ( z ) ; return result ; } }
package processing . app . syntax . im ; import java . awt . Color ; import java . awt . FontMetrics ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . Point ; import java . awt . font . TextLayout ; import processing . app . syntax . JEditTextArea ; public class CompositionTextPainter { private TextLayout composedTextLayout ; private int composedBeginCaretPosition = 0 ; private JEditTextArea textArea ; public CompositionTextPainter ( JEditTextArea textArea ) { this . textArea = textArea ; composedTextLayout = null ; } public boolean hasComposedTextLayout ( ) { return ( composedTextLayout != null ) ; } public void setComposedTextLayout ( TextLayout composedTextLayout , int composedStartCaretPosition ) { this . composedTextLayout = composedTextLayout ; this . composedBeginCaretPosition = composedStartCaretPosition ; } public void invalidateComposedTextLayout ( int composedEndCaretPosition ) { this . composedTextLayout = null ; this . composedBeginCaretPosition = composedEndCaretPosition ; } public void draw ( Graphics gfx , Color fillBackGroundColor ) { assert ( composedTextLayout != null ) ; Point composedLoc = getCaretLocation ( ) ; refillComposedArea ( fillBackGroundColor , composedLoc . x , composedLoc . y ) ; composedTextLayout . draw ( ( Graphics2D ) gfx , composedLoc . x , composedLoc . y ) ; } private void refillComposedArea ( Color fillColor , int x , int y ) { Graphics gfx = textArea . getPainter ( ) . getGraphics ( ) ; gfx . setColor ( fillColor ) ; FontMetrics fm = textArea . getPainter ( ) . getFontMetrics ( ) ; int newY = y - ( fm . getHeight ( ) - CompositionTextManager . COMPOSING_UNDERBAR_HEIGHT ) ; int paintHeight = fm . getHeight ( ) ; int paintWidth = ( int ) composedTextLayout . getBounds ( ) . getWidth ( ) ; gfx . fillRect ( x , newY , paintWidth , paintHeight ) ; } private Point getCaretLocation ( ) { FontMetrics fm = textArea . getPainter ( ) . getFontMetrics ( ) ; int offsetY = fm . getHeight ( ) - CompositionTextManager . COMPOSING_UNDERBAR_HEIGHT ; int lineIndex = textArea . getCaretLine ( ) ; int offsetX = composedBeginCaretPosition - textArea . getLineStartOffset ( lineIndex ) ; return new Point ( textArea . offsetToX ( lineIndex , offsetX ) , ( lineIndex - textArea . getFirstLine ( ) ) * fm . getHeight ( ) + offsetY ) ; } }
package processing . app . contrib ; public interface ContributionChangeListener { public void contributionAdded ( Contribution Contribution ) ; public void contributionRemoved ( Contribution Contribution ) ; public void contributionChanged ( Contribution oldLib , Contribution newLib ) ; }
package processing . app . contrib ; import java . util . * ; import java . util . List ; import java . util . Map . Entry ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; import java . awt . * ; import processing . app . Base ; public class ContributionListPanel extends JPanel implements Scrollable , ContributionChangeListener { ContributionManagerDialog contribManager ; TreeMap < Contribution , ContributionPanel > panelByContribution ; static HyperlinkListener nullHyperlinkListener = new HyperlinkListener ( ) { public void hyperlinkUpdate ( HyperlinkEvent e ) { } } ; private ContributionPanel selectedPanel ; private StatusPanel status ; private ContributionFilter filter ; private ContributionListing contribListing = ContributionListing . getInstance ( ) ; public ContributionListPanel ( ContributionManagerDialog libraryManager , ContributionFilter filter ) { super ( ) ; this . contribManager = libraryManager ; this . filter = filter ; setLayout ( new GridBagLayout ( ) ) ; setOpaque ( true ) ; if ( Base . isLinux ( ) ) { setBackground ( Color . white ) ; } else { setBackground ( UIManager . getColor ( "List.background" ) ) ; } panelByContribution = new TreeMap < Contribution , ContributionPanel > ( contribListing . getComparator ( ) ) ; status = new StatusPanel ( ) ; } private void updatePanelOrdering ( ) { int row = 0 ; for ( Entry < Contribution , ContributionPanel > entry : panelByContribution . entrySet ( ) ) { GridBagConstraints c = new GridBagConstraints ( ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 1 ; c . gridx = 0 ; c . gridy = row ++ ; c . anchor = GridBagConstraints . NORTH ; add ( entry . getValue ( ) , c ) ; } GridBagConstraints c = new GridBagConstraints ( ) ; c . fill = GridBagConstraints . BOTH ; c . weightx = 1 ; c . weighty = 1 ; c . gridx = 0 ; c . gridy = row ++ ; c . anchor = GridBagConstraints . NORTH ; add ( status , c ) ; } public void contributionAdded ( final Contribution contribution ) { if ( filter . matches ( contribution ) ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { if ( ! panelByContribution . containsKey ( contribution ) ) { ContributionPanel newPanel = new ContributionPanel ( ContributionListPanel . this ) ; synchronized ( panelByContribution ) { panelByContribution . put ( contribution , newPanel ) ; } if ( newPanel != null ) { newPanel . setContribution ( contribution ) ; add ( newPanel ) ; updatePanelOrdering ( ) ; updateColors ( ) ; } } EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { scrollRectToVisible ( new Rectangle ( 0 , 0 , 1 , 1 ) ) ; } } ) ; } } ) ; } } public void contributionRemoved ( final Contribution contribution ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { synchronized ( panelByContribution ) { ContributionPanel panel = panelByContribution . get ( contribution ) ; if ( panel != null ) { remove ( panel ) ; panelByContribution . remove ( contribution ) ; } } updatePanelOrdering ( ) ; updateColors ( ) ; updateUI ( ) ; } } ) ; } public void contributionChanged ( final Contribution oldContrib , final Contribution newContrib ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { synchronized ( panelByContribution ) { ContributionPanel panel = panelByContribution . get ( oldContrib ) ; if ( panel == null ) { contributionAdded ( newContrib ) ; } else { panelByContribution . remove ( oldContrib ) ; panel . setContribution ( newContrib ) ; panelByContribution . put ( newContrib , panel ) ; updatePanelOrdering ( ) ; } } } } ) ; } public void filterLibraries ( List < Contribution > filteredContributions ) { synchronized ( panelByContribution ) { Set < Contribution > hiddenPanels = new TreeSet < Contribution > ( contribListing . getComparator ( ) ) ; hiddenPanels . addAll ( panelByContribution . keySet ( ) ) ; for ( Contribution info : filteredContributions ) { ContributionPanel panel = panelByContribution . get ( info ) ; if ( panel != null ) { panel . setVisible ( true ) ; hiddenPanels . remove ( info ) ; } } for ( Contribution info : hiddenPanels ) { ContributionPanel panel = panelByContribution . get ( info ) ; if ( panel != null ) { panel . setVisible ( false ) ; } } } } protected void setSelectedPanel ( ContributionPanel panel ) { if ( selectedPanel == panel ) { selectedPanel . setSelected ( true ) ; } else { ContributionPanel lastSelected = selectedPanel ; selectedPanel = panel ; if ( lastSelected != null ) { lastSelected . setSelected ( false ) ; } panel . setSelected ( true ) ; updateColors ( ) ; requestFocusInWindow ( ) ; } } protected ContributionPanel getSelectedPanel ( ) { return selectedPanel ; } protected void updateColors ( ) { int count = 0 ; synchronized ( panelByContribution ) { for ( Entry < Contribution , ContributionPanel > entry : panelByContribution . entrySet ( ) ) { ContributionPanel panel = entry . getValue ( ) ; if ( panel . isVisible ( ) && panel . isSelected ( ) ) { panel . setBackground ( UIManager . getColor ( "List.selectionBackground" ) ) ; panel . setForeground ( UIManager . getColor ( "List.selectionForeground" ) ) ; panel . setBorder ( UIManager . getBorder ( "List.focusCellHighlightBorder" ) ) ; count ++ ; } else { Border border = null ; if ( panel . isVisible ( ) ) { if ( Base . isMacOS ( ) ) { if ( count % 2 == 1 ) { border = UIManager . getBorder ( "List.oddRowBackgroundPainter" ) ; } else { border = UIManager . getBorder ( "List.evenRowBackgroundPainter" ) ; } } else { if ( count % 2 == 1 ) { panel . setBackground ( new Color ( 219 , 224 , 229 ) ) ; } else { panel . setBackground ( new Color ( 241 , 241 , 241 ) ) ; } } count ++ ; } if ( border == null ) { border = BorderFactory . createEmptyBorder ( 1 , 1 , 1 , 1 ) ; } panel . setBorder ( border ) ; panel . setForeground ( UIManager . getColor ( "List.foreground" ) ) ; } } } } public Dimension getPreferredScrollableViewportSize ( ) { return getPreferredSize ( ) ; } public int getScrollableBlockIncrement ( Rectangle visibleRect , int orientation , int direction ) { if ( orientation == SwingConstants . VERTICAL ) { int blockAmount = visibleRect . height ; if ( direction > 0 ) { visibleRect . y += blockAmount ; } else { visibleRect . y -= blockAmount ; } blockAmount += getScrollableUnitIncrement ( visibleRect , orientation , direction ) ; return blockAmount ; } return 0 ; } public int getScrollableUnitIncrement ( Rectangle visibleRect , int orientation , int direction ) { if ( orientation == SwingConstants . VERTICAL ) { int lastHeight = 0 , height = 0 ; int bottomOfScrollArea = visibleRect . y + visibleRect . height ; for ( Component c : getComponents ( ) ) { if ( c . isVisible ( ) ) { if ( c instanceof ContributionPanel ) { Dimension d = c . getPreferredSize ( ) ; int nextHeight = height + d . height ; if ( direction > 0 ) { if ( nextHeight > bottomOfScrollArea ) { return nextHeight - bottomOfScrollArea ; } } else { if ( nextHeight > visibleRect . y ) { if ( visibleRect . y != height ) { return visibleRect . y - height ; } else { return visibleRect . y - lastHeight ; } } } lastHeight = height ; height = nextHeight ; } } } } return 0 ; } public boolean getScrollableTracksViewportHeight ( ) { return false ; } public boolean getScrollableTracksViewportWidth ( ) { return true ; } }
package processing . app . contrib ; import java . io . * ; import java . net . * ; import java . util . * ; import javax . swing . SwingWorker ; import processing . app . Base ; import processing . app . Editor ; import processing . app . Language ; import processing . core . PApplet ; public class ContributionManager { static public final ContributionListing contribListing ; static { contribListing = ContributionListing . getInstance ( ) ; } static boolean download ( URL source , File dest , ContribProgressMonitor progress ) { boolean success = false ; try { HttpURLConnection conn = ( HttpURLConnection ) source . openConnection ( ) ; HttpURLConnection . setFollowRedirects ( true ) ; conn . setConnectTimeout ( 15 * 1000 ) ; conn . setReadTimeout ( 60 * 1000 ) ; conn . setRequestMethod ( "GET" ) ; conn . connect ( ) ; if ( progress != null ) { int fileSize = conn . getContentLength ( ) ; progress . max = fileSize ; progress . startTask ( Language . text ( "contrib.progress.downloading" ) , fileSize ) ; } InputStream in = conn . getInputStream ( ) ; FileOutputStream out = new FileOutputStream ( dest ) ; byte [ ] b = new byte [ 8192 ] ; int amount ; if ( progress != null ) { int total = 0 ; while ( ! progress . isCanceled ( ) && ( amount = in . read ( b ) ) != - 1 ) { out . write ( b , 0 , amount ) ; total += amount ; progress . setProgress ( total ) ; } } else { while ( ( amount = in . read ( b ) ) != - 1 ) { out . write ( b , 0 , amount ) ; } } out . flush ( ) ; out . close ( ) ; success = true ; } catch ( SocketTimeoutException ste ) { if ( progress != null ) { progress . error ( ste ) ; progress . cancel ( ) ; } } catch ( IOException ioe ) { if ( progress != null ) { progress . error ( ioe ) ; progress . cancel ( ) ; } } if ( progress != null ) { progress . finished ( ) ; } return success ; } static void downloadAndInstall ( final Editor editor , final URL url , final AvailableContribution ad , final ContribProgressBar downloadProgress , final ContribProgressBar installProgress , final StatusPanel status ) { new Thread ( new Runnable ( ) { public void run ( ) { String filename = url . getFile ( ) ; filename = filename . substring ( filename . lastIndexOf ( '/' ) + 1 ) ; try { File contribZip = File . createTempFile ( "download" , filename ) ; contribZip . setWritable ( true ) ; try { download ( url , contribZip , downloadProgress ) ; if ( ! downloadProgress . isCanceled ( ) && ! downloadProgress . isError ( ) ) { installProgress . startTask ( Language . text ( "contrib.progress.installing" ) , ContribProgressMonitor . UNKNOWN ) ; LocalContribution contribution = ad . install ( editor . getBase ( ) , contribZip , false , status ) ; if ( contribution != null ) { contribListing . replaceContribution ( ad , contribution ) ; if ( contribution . getType ( ) == ContributionType . MODE ) { List < ModeContribution > contribModes = editor . getBase ( ) . getModeContribs ( ) ; if ( ! contribModes . contains ( contribution ) ) { contribModes . add ( ( ModeContribution ) contribution ) ; } } refreshInstalled ( editor ) ; } installProgress . finished ( ) ; } else { if ( downloadProgress . exception instanceof SocketTimeoutException ) { status . setErrorMessage ( Language . interpolate ( "contrib.errors.contrib_download.timeout" , ad . getName ( ) ) ) ; } else { status . setErrorMessage ( Language . interpolate ( "contrib.errors.download_and_install" , ad . getName ( ) ) ) ; } } contribZip . delete ( ) ; } catch ( Exception e ) { String msg = null ; if ( e instanceof RuntimeException ) { Throwable cause = ( ( RuntimeException ) e ) . getCause ( ) ; if ( cause instanceof NoClassDefFoundError || cause instanceof NoSuchMethodError ) { msg = "This item is not compatible with this version of Processing" ; } else if ( cause instanceof UnsupportedClassVersionError ) { msg = "This item needs to be recompiled for Java " + PApplet . javaPlatform ; } } if ( msg == null ) { msg = Language . interpolate ( "contrib.errors.download_and_install" , ad . getName ( ) ) ; } status . setErrorMessage ( msg ) ; downloadProgress . cancel ( ) ; installProgress . cancel ( ) ; } } catch ( IOException e ) { status . setErrorMessage ( Language . text ( "contrib.errors.temporary_directory" ) ) ; downloadProgress . cancel ( ) ; installProgress . cancel ( ) ; } } } , "Contribution Installer" ) . start ( ) ; } static void downloadAndInstallOnStartup ( final Base base , final URL url , final AvailableContribution ad ) { new Thread ( new Runnable ( ) { public void run ( ) { String filename = url . getFile ( ) ; filename = filename . substring ( filename . lastIndexOf ( '/' ) + 1 ) ; try { File contribZip = File . createTempFile ( "download" , filename ) ; contribZip . setWritable ( true ) ; try { download ( url , contribZip , null ) ; LocalContribution contribution = ad . install ( base , contribZip , false , null ) ; if ( contribution != null ) { contribListing . replaceContribution ( ad , contribution ) ; if ( contribution . getType ( ) == ContributionType . MODE ) { List < ModeContribution > contribModes = base . getModeContribs ( ) ; if ( contribModes != null && ! contribModes . contains ( contribution ) ) { contribModes . add ( ( ModeContribution ) contribution ) ; } } if ( base . getActiveEditor ( ) != null ) { refreshInstalled ( base . getActiveEditor ( ) ) ; } } contribZip . delete ( ) ; handleUpdateFailedMarkers ( ad , filename . substring ( 0 , filename . lastIndexOf ( '.' ) ) ) ; } catch ( Exception e ) { String arg = "contrib.startup.errors.download_install" ; System . err . println ( Language . interpolate ( arg , ad . getName ( ) ) ) ; } } catch ( IOException e ) { String arg = "contrib.startup.errors.temp_dir" ; System . err . println ( Language . interpolate ( arg , ad . getName ( ) ) ) ; } } } , "Contribution Installer" ) . start ( ) ; } static private void handleUpdateFailedMarkers ( final AvailableContribution ac , String filename ) { File contribLocn = ac . getType ( ) . getSketchbookFolder ( ) ; for ( File contribDir : contribLocn . listFiles ( ) ) if ( contribDir . isDirectory ( ) ) { File [ ] contents = contribDir . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String file ) { return file . equals ( ac . getType ( ) + ".properties" ) ; } } ) ; if ( contents . length > 0 && Base . readSettings ( contents [ 0 ] ) . get ( "name" ) . equals ( ac . getName ( ) ) ) { return ; } } try { new File ( contribLocn , ac . getName ( ) ) . createNewFile ( ) ; } catch ( IOException e ) { String arg = "contrib.startup.errors.new_marker" ; System . err . println ( Language . interpolate ( arg , ac . getName ( ) ) ) ; } } public static void downloadAndInstallOnImport ( final Base base , final List < AvailableContribution > aList ) { base . getActiveEditor ( ) . getTextArea ( ) . setEditable ( false ) ; ArrayList < String > installedLibList = new ArrayList < String > ( ) ; boolean isPrevDone = false ; for ( AvailableContribution ad : aList ) { if ( ad . getType ( ) != ContributionType . LIBRARY ) { continue ; } try { URL url = new URL ( ad . link ) ; String filename = url . getFile ( ) ; filename = filename . substring ( filename . lastIndexOf ( '/' ) + 1 ) ; try { File contribZip = File . createTempFile ( "download" , filename ) ; contribZip . setWritable ( true ) ; try { String statusMsg = base . getActiveEditor ( ) . getStatusMessage ( ) ; if ( isPrevDone ) { String status = statusMsg + " " + Language . interpolate ( "contrib.import.progress.download" , ad . name ) ; base . getActiveEditor ( ) . statusNotice ( status ) ; } else { String arg = "contrib.import.progress.download" ; String status = Language . interpolate ( arg , ad . name ) ; base . getActiveEditor ( ) . statusNotice ( status ) ; } isPrevDone = false ; download ( url , contribZip , null ) ; String arg = "contrib.import.progress.install" ; base . getActiveEditor ( ) . statusNotice ( Language . interpolate ( arg , ad . name ) ) ; LocalContribution contribution = ad . install ( base , contribZip , false , null ) ; if ( contribution != null ) { contribListing . replaceContribution ( ad , contribution ) ; if ( base . getActiveEditor ( ) != null ) { refreshInstalled ( base . getActiveEditor ( ) ) ; } } contribZip . delete ( ) ; installedLibList . add ( ad . name ) ; isPrevDone = true ; arg = "contrib.import.progress.done" ; base . getActiveEditor ( ) . statusNotice ( Language . interpolate ( arg , ad . name ) ) ; } catch ( Exception e ) { String arg = "contrib.startup.errors.download_install" ; System . err . println ( Language . interpolate ( arg , ad . getName ( ) ) ) ; } } catch ( IOException e ) { String arg = "contrib.startup.errors.temp_dir" ; System . err . println ( Language . interpolate ( arg , ad . getName ( ) ) ) ; } } catch ( MalformedURLException e1 ) { System . err . println ( Language . interpolate ( "contrib.import.errors.link" , ad . getName ( ) ) ) ; } } base . getActiveEditor ( ) . getTextArea ( ) . setEditable ( true ) ; base . getActiveEditor ( ) . statusEmpty ( ) ; System . out . println ( Language . text ( "contrib.import.progress.final_list" ) ) ; for ( String l : installedLibList ) { System . out . println ( " * " + l ) ; } } static public void refreshInstalled ( Editor e ) { Iterator < Editor > iter = e . getBase ( ) . getEditors ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Editor ed = iter . next ( ) ; ed . getMode ( ) . rebuildImportMenu ( ) ; ed . getMode ( ) . rebuildExamplesFrame ( ) ; ed . rebuildToolMenu ( ) ; ed . rebuildModeMenu ( ) ; } } public static File getUniqueName ( File parentFolder , String fileName ) { File backupFolderForLib ; int i = 1 ; do { String folderName = fileName ; if ( i >= 2 ) { folderName += "(" + i + ")" ; } i ++ ; backupFolderForLib = new File ( parentFolder , folderName ) ; } while ( backupFolderForLib . exists ( ) ) ; return backupFolderForLib ; } static public String getFileName ( File libFile ) { String path = libFile . getPath ( ) ; int lastSeparator = path . lastIndexOf ( File . separatorChar ) ; String fileName ; if ( lastSeparator != - 1 ) { fileName = path . substring ( lastSeparator + 1 ) ; } else { fileName = path ; } int lastDot = fileName . lastIndexOf ( '.' ) ; if ( lastDot != - 1 ) { return fileName . substring ( 0 , lastDot ) ; } return fileName ; } static public void cleanup ( final Base base ) throws Exception { deleteTemp ( Base . getSketchbookModesFolder ( ) ) ; deleteTemp ( Base . getSketchbookToolsFolder ( ) ) ; deleteFlagged ( Base . getSketchbookLibrariesFolder ( ) ) ; deleteFlagged ( Base . getSketchbookModesFolder ( ) ) ; deleteFlagged ( Base . getSketchbookToolsFolder ( ) ) ; installPreviouslyFailed ( base , Base . getSketchbookModesFolder ( ) ) ; updateFlagged ( base , Base . getSketchbookModesFolder ( ) ) ; updateFlagged ( base , Base . getSketchbookToolsFolder ( ) ) ; SwingWorker s = new SwingWorker < Void , Void > ( ) { @ Override protected Void doInBackground ( ) throws Exception { try { Thread . sleep ( 1 * 1000 ) ; installPreviouslyFailed ( base , Base . getSketchbookToolsFolder ( ) ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } return null ; } } ; s . execute ( ) ; clearRestartFlags ( Base . getSketchbookModesFolder ( ) ) ; clearRestartFlags ( Base . getSketchbookToolsFolder ( ) ) ; } static private void deleteTemp ( File root ) { LinkedList < File > deleteList = new LinkedList < File > ( ) ; for ( File f : root . listFiles ( ) ) if ( f . getName ( ) . matches ( root . getName ( ) . substring ( 0 , 4 ) + "\\d*" + "tmp" ) ) deleteList . add ( f ) ; Iterator < File > folderIter = deleteList . iterator ( ) ; while ( folderIter . hasNext ( ) ) { Base . removeDir ( folderIter . next ( ) ) ; } } static private void deleteFlagged ( File root ) throws Exception { File [ ] markedForDeletion = root . listFiles ( new FileFilter ( ) { public boolean accept ( File folder ) { return ( folder . isDirectory ( ) && LocalContribution . isDeletionFlagged ( folder ) ) ; } } ) ; for ( File folder : markedForDeletion ) { Base . removeDir ( folder ) ; } } static private void installPreviouslyFailed ( Base base , File root ) throws Exception { File [ ] installList = root . listFiles ( new FileFilter ( ) { public boolean accept ( File folder ) { return ( folder . isFile ( ) ) ; } } ) ; for ( File file : installList ) { Iterator < AvailableContribution > iter = contribListing . advertisedContributions . iterator ( ) ; while ( iter . hasNext ( ) ) { AvailableContribution availableContrib = iter . next ( ) ; if ( file . getName ( ) . equals ( availableContrib . getName ( ) ) ) { file . delete ( ) ; installOnStartUp ( base , availableContrib ) ; contribListing . replaceContribution ( availableContrib , availableContrib ) ; } } } } static private void updateFlagged ( Base base , File root ) throws Exception { File [ ] markedForUpdate = root . listFiles ( new FileFilter ( ) { public boolean accept ( File folder ) { return ( folder . isDirectory ( ) && LocalContribution . isUpdateFlagged ( folder ) ) ; } } ) ; ArrayList < String > updateContribsNames = new ArrayList < String > ( ) ; LinkedList < AvailableContribution > updateContribsList = new LinkedList < AvailableContribution > ( ) ; String type = root . getName ( ) . substring ( root . getName ( ) . lastIndexOf ( '/' ) + 1 ) ; String propFileName = null ; if ( type . equalsIgnoreCase ( "tools" ) ) propFileName = "tool.properties" ; else if ( type . equalsIgnoreCase ( "modes" ) ) propFileName = "mode.properties" ; else if ( type . equalsIgnoreCase ( "libraries" ) ) propFileName = "libraries.properties" ; for ( File folder : markedForUpdate ) { Map < String , String > properties = Base . readSettings ( new File ( folder , propFileName ) ) ; updateContribsNames . add ( properties . get ( "name" ) ) ; Base . removeDir ( folder ) ; } Iterator < AvailableContribution > iter = contribListing . advertisedContributions . iterator ( ) ; while ( iter . hasNext ( ) ) { AvailableContribution availableContribs = iter . next ( ) ; if ( updateContribsNames . contains ( availableContribs . getName ( ) ) ) { updateContribsList . add ( availableContribs ) ; } } Iterator < AvailableContribution > iter2 = updateContribsList . iterator ( ) ; while ( iter2 . hasNext ( ) ) { AvailableContribution contribToUpdate = iter2 . next ( ) ; installOnStartUp ( base , contribToUpdate ) ; contribListing . replaceContribution ( contribToUpdate , contribToUpdate ) ; } } static private void installOnStartUp ( final Base base , final AvailableContribution availableContrib ) { if ( availableContrib . link == null ) { Base . showWarning ( Language . interpolate ( "contrib.errors.update_on_restart_failed" , availableContrib . getName ( ) ) , Language . text ( "contrib.unsupported_operating_system" ) ) ; return ; } try { URL downloadUrl = new URL ( availableContrib . link ) ; ContributionManager . downloadAndInstallOnStartup ( base , downloadUrl , availableContrib ) ; } catch ( MalformedURLException e ) { Base . showWarning ( Language . interpolate ( "contrib.errors.update_on_restart_failed" , availableContrib . getName ( ) ) , Language . text ( "contrib.errors.malformed_url" ) , e ) ; } } static private void clearRestartFlags ( File root ) throws Exception { File [ ] folderList = root . listFiles ( new FileFilter ( ) { public boolean accept ( File folder ) { return folder . isDirectory ( ) ; } } ) ; for ( File folder : folderList ) { LocalContribution . clearRestartFlags ( folder ) ; } } }
package processing . app . contrib ; abstract class ContribProgressMonitor { static final int UNKNOWN = - 1 ; boolean canceled = false ; boolean error = false ; boolean finished = false ; Exception exception ; int max ; int progress = 0 ; public void startTask ( String name , int maxValue ) { } public void setProgress ( int value ) { progress = value ; } public int getProgress ( ) { return progress ; } public boolean isCanceled ( ) { return canceled ; } public void cancel ( ) { canceled = true ; } public boolean isError ( ) { return error ; } public Exception getException ( ) { return exception ; } public void error ( Exception e ) { error = true ; exception = e ; } public boolean isFinished ( ) { return finished ; } public void finished ( ) { finished = true ; } }
package processing . app . contrib ; import java . awt . * ; import java . awt . event . * ; import java . io . File ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Iterator ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . Date ; import java . text . DateFormat ; import javax . swing . * ; import javax . swing . border . EmptyBorder ; import javax . swing . event . HyperlinkEvent ; import javax . swing . event . HyperlinkListener ; import javax . swing . text . Document ; import javax . swing . text . html . HTMLDocument ; import javax . swing . text . html . StyleSheet ; import processing . app . Base ; import processing . app . Editor ; import processing . app . Toolkit ; import processing . app . Language ; class ContributionPanel extends JPanel { static public final String REMOVE_RESTART_MESSAGE = String . format ( "<i>%s</i>" , Language . text ( "contrib.messages.remove_restart" ) ) ; static public final String INSTALL_RESTART_MESSAGE = String . format ( "<i>%s</i>" , Language . text ( "contrib.messages.install_restart" ) ) ; static public final String UPDATE_RESTART_MESSAGE = String . format ( "<i>%s</i>" , Language . text ( "contrib.messages.update_restart" ) ) ; static public final String PROGRESS_BAR_CONSTRAINT = "Install/Remove Progress Bar Panel" ; static public final String BUTTON_CONSTRAINT = "Install/Remove Button Panel" ; static public final String INCOMPATIBILITY_BLUR = "This contribution is not compatible with " + "the current revision of Processing" ; private final ContributionListPanel listPanel ; private final ContributionListing contribListing = ContributionListing . getInstance ( ) ; static private final int BUTTON_WIDTH = 100 ; private Contribution contrib ; private boolean alreadySelected ; private boolean enableHyperlinks ; private HyperlinkListener conditionalHyperlinkOpener ; private JTextPane descriptionPane ; private JLabel notificationLabel ; private JButton updateButton ; private JProgressBar installProgressBar ; private JButton installRemoveButton ; private JPopupMenu contextMenu ; private JMenuItem openFolder ; private JPanel barButtonCardPane ; private ActionListener removeActionListener ; private ActionListener installActionListener ; private ActionListener undoActionListener ; private boolean isUpdateInProgress ; private boolean isInstallInProgress ; private boolean isRemoveInProgress ; ContributionPanel ( ContributionListPanel contributionListPanel ) { listPanel = contributionListPanel ; barButtonCardPane = new JPanel ( ) ; enableHyperlinks = false ; alreadySelected = false ; conditionalHyperlinkOpener = new HyperlinkListener ( ) { public void hyperlinkUpdate ( HyperlinkEvent e ) { if ( e . getEventType ( ) == HyperlinkEvent . EventType . ACTIVATED ) { if ( enableHyperlinks ) { if ( e . getURL ( ) != null ) { Base . openURL ( e . getURL ( ) . toString ( ) ) ; } } } } } ; installActionListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { listPanel . contribManager . status . clear ( ) ; isInstallInProgress = true ; ( ( CardLayout ) barButtonCardPane . getLayout ( ) ) . show ( barButtonCardPane , PROGRESS_BAR_CONSTRAINT ) ; if ( contrib instanceof AvailableContribution ) { installContribution ( ( AvailableContribution ) contrib ) ; contribListing . replaceContribution ( contrib , contrib ) ; } } } ; undoActionListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { listPanel . contribManager . status . clear ( ) ; if ( contrib instanceof LocalContribution ) { LocalContribution installed = ( LocalContribution ) contrib ; installed . setDeletionFlag ( false ) ; contribListing . replaceContribution ( contrib , contrib ) ; Iterator < Contribution > contribsListIter = contribListing . allContributions . iterator ( ) ; boolean toBeRestarted = false ; while ( contribsListIter . hasNext ( ) ) { Contribution contribElement = contribsListIter . next ( ) ; if ( contrib . getType ( ) . equals ( contribElement . getType ( ) ) ) { if ( contribElement . isDeletionFlagged ( ) || contribElement . isUpdateFlagged ( ) ) { toBeRestarted = ! toBeRestarted ; break ; } } } listPanel . contribManager . restartButton . setVisible ( toBeRestarted ) ; } } } ; removeActionListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent arg ) { listPanel . contribManager . status . clear ( ) ; if ( contrib . isInstalled ( ) && contrib instanceof LocalContribution ) { isRemoveInProgress = true ; ( ( CardLayout ) barButtonCardPane . getLayout ( ) ) . show ( barButtonCardPane , PROGRESS_BAR_CONSTRAINT ) ; updateButton . setEnabled ( false ) ; installRemoveButton . setEnabled ( false ) ; installProgressBar . setVisible ( true ) ; installProgressBar . setIndeterminate ( true ) ; ContribProgressBar monitor = new ContribProgressBar ( installProgressBar ) { public void finishedAction ( ) { resetInstallProgressBarState ( ) ; isRemoveInProgress = false ; installRemoveButton . setEnabled ( true ) ; reorganizePaneComponents ( ) ; setSelected ( true ) ; } public void cancel ( ) { super . cancel ( ) ; resetInstallProgressBarState ( ) ; isRemoveInProgress = false ; installRemoveButton . setEnabled ( true ) ; reorganizePaneComponents ( ) ; setSelected ( true ) ; ContributionManagerDialog manager = listPanel . contribManager ; boolean isModeActive = false ; if ( contrib . getType ( ) == ContributionType . MODE ) { ModeContribution m = ( ModeContribution ) contrib ; for ( Editor e : manager . editor . getBase ( ) . getEditors ( ) ) { if ( e . getMode ( ) . equals ( m . getMode ( ) ) ) { isModeActive = true ; break ; } } } if ( isModeActive ) { updateButton . setEnabled ( true ) ; } else { manager . restartButton . setVisible ( true ) ; } } } ; ContributionManagerDialog manager = listPanel . contribManager ; LocalContribution localContrib = ( LocalContribution ) contrib ; localContrib . removeContribution ( manager . editor , monitor , manager . status ) ; } } } ; contextMenu = new JPopupMenu ( ) ; openFolder = new JMenuItem ( "Open Folder" ) ; openFolder . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( contrib instanceof LocalContribution ) { File folder = ( ( LocalContribution ) contrib ) . getFolder ( ) ; Base . openFolder ( folder ) ; } } } ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; addPaneComponents ( ) ; setBackground ( listPanel . getBackground ( ) ) ; setOpaque ( true ) ; setSelected ( false ) ; setExpandListener ( this , new MouseAdapter ( ) { public void mousePressed ( MouseEvent e ) { if ( contrib . isCompatible ( Base . getRevision ( ) ) ) { listPanel . setSelectedPanel ( ContributionPanel . this ) ; } else { final String msg = contrib . getName ( ) + " is not compatible with this version of Processing" ; listPanel . contribManager . status . setErrorMessage ( msg ) ; } } } ) ; } private void addPaneComponents ( ) { setLayout ( new BorderLayout ( ) ) ; descriptionPane = new JTextPane ( ) ; descriptionPane . setInheritsPopupMenu ( true ) ; descriptionPane . setEditable ( false ) ; Insets margin = descriptionPane . getMargin ( ) ; margin . bottom = 0 ; descriptionPane . setMargin ( margin ) ; descriptionPane . setContentType ( "text/html" ) ; setTextStyle ( descriptionPane ) ; descriptionPane . setOpaque ( false ) ; if ( UIManager . getLookAndFeel ( ) . getID ( ) . equals ( "Nimbus" ) ) { descriptionPane . setBackground ( new Color ( 0 , 0 , 0 , 0 ) ) ; } descriptionPane . setBorder ( new EmptyBorder ( 4 , 7 , 7 , 7 ) ) ; descriptionPane . setHighlighter ( null ) ; add ( descriptionPane , BorderLayout . CENTER ) ; JPanel updateBox = new JPanel ( ) ; updateBox . setLayout ( new BorderLayout ( ) ) ; notificationLabel = new JLabel ( ) ; notificationLabel . setInheritsPopupMenu ( true ) ; notificationLabel . setVisible ( false ) ; notificationLabel . setOpaque ( false ) ; notificationLabel . setFont ( new Font ( "Verdana" , Font . ITALIC , 10 ) ) ; updateButton = new JButton ( "Update" ) ; updateButton . setInheritsPopupMenu ( true ) ; Dimension updateButtonDimensions = updateButton . getPreferredSize ( ) ; updateButtonDimensions . width = BUTTON_WIDTH ; updateButton . setMinimumSize ( updateButtonDimensions ) ; updateButton . setPreferredSize ( updateButtonDimensions ) ; updateButton . setOpaque ( false ) ; updateButton . setVisible ( false ) ; updateButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { listPanel . contribManager . status . clear ( ) ; isUpdateInProgress = true ; if ( contrib . getType ( ) . requiresRestart ( ) ) { installRemoveButton . setEnabled ( false ) ; installProgressBar . setVisible ( true ) ; installProgressBar . setIndeterminate ( true ) ; ContribProgressBar progress = new ContribProgressBar ( installProgressBar ) { public void finishedAction ( ) { resetInstallProgressBarState ( ) ; updateButton . setEnabled ( false ) ; AvailableContribution ad = contribListing . getAvailableContribution ( contrib ) ; String url = ad . link ; installContribution ( ad , url ) ; } @ Override public void cancel ( ) { super . cancel ( ) ; resetInstallProgressBarState ( ) ; listPanel . contribManager . status . setMessage ( "" ) ; isUpdateInProgress = false ; installRemoveButton . setEnabled ( true ) ; if ( contrib . isDeletionFlagged ( ) ) { ( ( LocalContribution ) contrib ) . setUpdateFlag ( true ) ; ( ( LocalContribution ) contrib ) . setDeletionFlag ( false ) ; contribListing . replaceContribution ( contrib , contrib ) ; } boolean isModeActive = false ; if ( contrib . getType ( ) == ContributionType . MODE ) { ModeContribution m = ( ModeContribution ) contrib ; Base base = listPanel . contribManager . editor . getBase ( ) ; for ( Editor e : base . getEditors ( ) ) { if ( e . getMode ( ) . equals ( m . getMode ( ) ) ) { isModeActive = true ; break ; } } } if ( isModeActive ) { updateButton . setEnabled ( true ) ; } else { listPanel . contribManager . restartButton . setVisible ( true ) ; } } } ; ( ( LocalContribution ) contrib ) . removeContribution ( listPanel . contribManager . editor , progress , listPanel . contribManager . status ) ; } else { updateButton . setEnabled ( false ) ; installRemoveButton . setEnabled ( false ) ; AvailableContribution ad = contribListing . getAvailableContribution ( contrib ) ; String url = ad . link ; installContribution ( ad , url ) ; } } } ) ; updateBox . add ( updateButton , BorderLayout . EAST ) ; updateBox . add ( notificationLabel , BorderLayout . WEST ) ; updateBox . setBorder ( new EmptyBorder ( 4 , 7 , 7 , 7 ) ) ; updateBox . setOpaque ( false ) ; add ( updateBox , BorderLayout . SOUTH ) ; JPanel rightPane = new JPanel ( ) ; rightPane . setInheritsPopupMenu ( true ) ; rightPane . setOpaque ( false ) ; rightPane . setLayout ( new BoxLayout ( rightPane , BoxLayout . Y_AXIS ) ) ; rightPane . setMinimumSize ( new Dimension ( ContributionPanel . BUTTON_WIDTH , 1 ) ) ; add ( rightPane , BorderLayout . EAST ) ; barButtonCardPane . setLayout ( new CardLayout ( ) ) ; barButtonCardPane . setInheritsPopupMenu ( true ) ; barButtonCardPane . setOpaque ( false ) ; barButtonCardPane . setMinimumSize ( new Dimension ( ContributionPanel . BUTTON_WIDTH , 1 ) ) ; installProgressBar = new JProgressBar ( ) ; installProgressBar . setInheritsPopupMenu ( true ) ; installProgressBar . setStringPainted ( true ) ; resetInstallProgressBarState ( ) ; Dimension d = installProgressBar . getPreferredSize ( ) ; d . width = ContributionPanel . BUTTON_WIDTH ; installProgressBar . setPreferredSize ( d ) ; installProgressBar . setMaximumSize ( d ) ; installProgressBar . setMinimumSize ( d ) ; installProgressBar . setOpaque ( false ) ; installProgressBar . setAlignmentX ( CENTER_ALIGNMENT ) ; installRemoveButton = new JButton ( " " ) ; installRemoveButton . setInheritsPopupMenu ( true ) ; Dimension installButtonDimensions = installRemoveButton . getPreferredSize ( ) ; installButtonDimensions . width = ContributionPanel . BUTTON_WIDTH ; installRemoveButton . setPreferredSize ( installButtonDimensions ) ; installRemoveButton . setMaximumSize ( installButtonDimensions ) ; installRemoveButton . setMinimumSize ( installButtonDimensions ) ; installRemoveButton . setOpaque ( false ) ; installRemoveButton . setAlignmentX ( CENTER_ALIGNMENT ) ; JPanel barPane = new JPanel ( ) ; barPane . setOpaque ( false ) ; barPane . add ( installProgressBar ) ; JPanel buttonPane = new JPanel ( ) ; buttonPane . setOpaque ( false ) ; buttonPane . add ( installRemoveButton ) ; barButtonCardPane . add ( buttonPane , BUTTON_CONSTRAINT ) ; barButtonCardPane . add ( barPane , PROGRESS_BAR_CONSTRAINT ) ; ( ( CardLayout ) barButtonCardPane . getLayout ( ) ) . show ( barButtonCardPane , BUTTON_CONSTRAINT ) ; rightPane . add ( barButtonCardPane ) ; d = installProgressBar . getPreferredSize ( ) ; Dimension d2 = installRemoveButton . getPreferredSize ( ) ; d . width = ContributionPanel . BUTTON_WIDTH ; d . height = d2 . height ; rightPane . setMinimumSize ( d ) ; rightPane . setPreferredSize ( d ) ; } private void reorganizePaneComponents ( ) { BorderLayout layout = ( BorderLayout ) this . getLayout ( ) ; remove ( layout . getLayoutComponent ( BorderLayout . SOUTH ) ) ; remove ( layout . getLayoutComponent ( BorderLayout . EAST ) ) ; JPanel updateBox = new JPanel ( ) ; updateBox . setLayout ( new BorderLayout ( ) ) ; updateBox . setInheritsPopupMenu ( true ) ; updateBox . add ( notificationLabel , BorderLayout . WEST ) ; updateBox . setBorder ( new EmptyBorder ( 4 , 7 , 7 , 7 ) ) ; updateBox . setOpaque ( false ) ; add ( updateBox , BorderLayout . SOUTH ) ; JPanel rightPane = new JPanel ( ) ; rightPane . setInheritsPopupMenu ( true ) ; rightPane . setOpaque ( false ) ; rightPane . setLayout ( new BoxLayout ( rightPane , BoxLayout . Y_AXIS ) ) ; rightPane . setMinimumSize ( new Dimension ( ContributionPanel . BUTTON_WIDTH , 1 ) ) ; add ( rightPane , BorderLayout . EAST ) ; if ( updateButton . isVisible ( ) && ! isRemoveInProgress && ! contrib . isDeletionFlagged ( ) ) { JPanel updateRemovePanel = new JPanel ( ) ; updateRemovePanel . setLayout ( new FlowLayout ( ) ) ; updateRemovePanel . setOpaque ( false ) ; updateRemovePanel . add ( updateButton ) ; updateRemovePanel . setInheritsPopupMenu ( true ) ; updateRemovePanel . add ( installRemoveButton ) ; updateBox . add ( updateRemovePanel , BorderLayout . EAST ) ; JPanel barPane = new JPanel ( ) ; barPane . setOpaque ( false ) ; barPane . setInheritsPopupMenu ( true ) ; barPane . add ( installProgressBar ) ; rightPane . add ( barPane ) ; if ( isUpdateInProgress ) ( ( CardLayout ) barButtonCardPane . getLayout ( ) ) . show ( barButtonCardPane , PROGRESS_BAR_CONSTRAINT ) ; } else { updateBox . add ( updateButton , BorderLayout . EAST ) ; barButtonCardPane . removeAll ( ) ; JPanel barPane = new JPanel ( ) ; barPane . setOpaque ( false ) ; barPane . setInheritsPopupMenu ( true ) ; barPane . add ( installProgressBar ) ; JPanel buttonPane = new JPanel ( ) ; buttonPane . setOpaque ( false ) ; buttonPane . setInheritsPopupMenu ( true ) ; buttonPane . add ( installRemoveButton ) ; barButtonCardPane . add ( buttonPane , BUTTON_CONSTRAINT ) ; barButtonCardPane . add ( barPane , PROGRESS_BAR_CONSTRAINT ) ; if ( isInstallInProgress || isRemoveInProgress || isUpdateInProgress ) ( ( CardLayout ) barButtonCardPane . getLayout ( ) ) . show ( barButtonCardPane , PROGRESS_BAR_CONSTRAINT ) ; else ( ( CardLayout ) barButtonCardPane . getLayout ( ) ) . show ( barButtonCardPane , BUTTON_CONSTRAINT ) ; rightPane . add ( barButtonCardPane ) ; } Dimension d = installProgressBar . getPreferredSize ( ) ; Dimension d2 = installRemoveButton . getPreferredSize ( ) ; d . width = ContributionPanel . BUTTON_WIDTH ; d . height = Math . max ( d . height , d2 . height ) ; rightPane . setMinimumSize ( d ) ; rightPane . setPreferredSize ( d ) ; } private void setExpandListener ( Component component , MouseListener expandListener ) { if ( component instanceof JButton ) { return ; } component . addMouseListener ( expandListener ) ; if ( component instanceof Container ) { for ( Component child : ( ( Container ) component ) . getComponents ( ) ) { setExpandListener ( child , expandListener ) ; } } } private void blurContributionPanel ( Component component ) { component . setFocusable ( false ) ; component . setEnabled ( false ) ; if ( component instanceof JComponent ) ( ( JComponent ) component ) . setToolTipText ( INCOMPATIBILITY_BLUR ) ; if ( component instanceof Container ) { for ( Component child : ( ( Container ) component ) . getComponents ( ) ) { blurContributionPanel ( child ) ; } } } public void setContribution ( Contribution contrib ) { this . contrib = contrib ; if ( contrib . isSpecial ( ) ) { ImageIcon processingIcon = Toolkit . getLibIcon ( "icons/pde-48.png" ) ; JLabel iconLabel = new JLabel ( processingIcon ) ; iconLabel . setBorder ( new EmptyBorder ( 4 , 7 , 7 , 7 ) ) ; iconLabel . setVerticalAlignment ( SwingConstants . TOP ) ; add ( iconLabel , BorderLayout . WEST ) ; } StringBuilder description = new StringBuilder ( ) ; description . append ( "<html><body><b>" ) ; if ( contrib . getUrl ( ) == null ) { description . append ( contrib . getName ( ) ) ; } else { description . append ( "<a href=\"" + contrib . getUrl ( ) + "\">" + contrib . getName ( ) + "</a>" ) ; } description . append ( "</b>" ) ; String authorList = contrib . getAuthorList ( ) ; if ( authorList != null && ! authorList . isEmpty ( ) ) { description . append ( " by " ) ; description . append ( toHtmlLinks ( contrib . getAuthorList ( ) ) ) ; } description . append ( "<br/>" ) ; if ( contrib . isDeletionFlagged ( ) ) { description . append ( REMOVE_RESTART_MESSAGE ) ; } else if ( contrib . isRestartFlagged ( ) ) { description . append ( INSTALL_RESTART_MESSAGE ) ; } else if ( contrib . isUpdateFlagged ( ) ) { description . append ( UPDATE_RESTART_MESSAGE ) ; } else { String sentence = contrib . getSentence ( ) ; if ( sentence == null || sentence . isEmpty ( ) ) { sentence = String . format ( "<i>%s</i>" , Language . text ( "contrib.errors.description_unavailable" ) ) ; } else { sentence = sanitizeHtmlTags ( sentence ) ; sentence = toHtmlLinks ( sentence ) ; } description . append ( sentence ) ; } String version = contrib . getPrettyVersion ( ) ; if ( version != null && ! version . isEmpty ( ) ) { description . append ( "<br/>" ) ; if ( version . toLowerCase ( ) . startsWith ( "build" ) ) description . append ( "v" + version . substring ( 5 , version . indexOf ( ',' ) ) . trim ( ) ) ; else if ( version . toLowerCase ( ) . startsWith ( "v" ) ) description . append ( version ) ; else description . append ( "v" + version ) ; } long lastUpdatedUTC = contrib . getLastUpdated ( ) ; if ( lastUpdatedUTC != 0 ) { DateFormat dateFormatter = DateFormat . getDateInstance ( DateFormat . MEDIUM ) ; Date lastUpdatedDate = new Date ( lastUpdatedUTC ) ; if ( version != null && ! version . isEmpty ( ) ) description . append ( ", " ) ; description . append ( "Last Updated on " + dateFormatter . format ( lastUpdatedDate ) ) ; } description . append ( "</body></html>" ) ; descriptionPane . setText ( description . toString ( ) ) ; if ( contribListing . hasUpdates ( contrib ) ) { StringBuilder versionText = new StringBuilder ( ) ; versionText . append ( "<html><body><i>" ) ; if ( contrib . isUpdateFlagged ( ) || contrib . isDeletionFlagged ( ) ) { ; } else { String latestVersion = contribListing . getLatestVersion ( contrib ) ; if ( latestVersion != null ) { versionText . append ( "New version (" + latestVersion + ") available." ) ; } else { versionText . append ( "New version available." ) ; } } versionText . append ( "</i></body></html>" ) ; notificationLabel . setText ( versionText . toString ( ) ) ; notificationLabel . setVisible ( true ) ; } else { notificationLabel . setText ( "" ) ; notificationLabel . setVisible ( false ) ; } updateButton . setEnabled ( true ) ; if ( contrib != null ) { updateButton . setVisible ( ( contribListing . hasUpdates ( contrib ) && ! contrib . isUpdateFlagged ( ) && ! contrib . isDeletionFlagged ( ) ) || isUpdateInProgress ) ; } installRemoveButton . removeActionListener ( installActionListener ) ; installRemoveButton . removeActionListener ( removeActionListener ) ; installRemoveButton . removeActionListener ( undoActionListener ) ; if ( contrib . isDeletionFlagged ( ) ) { installRemoveButton . addActionListener ( undoActionListener ) ; installRemoveButton . setText ( Language . text ( "contrib.undo" ) ) ; } else if ( contrib . isInstalled ( ) ) { installRemoveButton . addActionListener ( removeActionListener ) ; installRemoveButton . setText ( Language . text ( "contrib.remove" ) ) ; installRemoveButton . setVisible ( true ) ; installRemoveButton . setEnabled ( ! contrib . isUpdateFlagged ( ) ) ; reorganizePaneComponents ( ) ; } else { installRemoveButton . addActionListener ( installActionListener ) ; installRemoveButton . setText ( Language . text ( "contrib.install" ) ) ; } contextMenu . removeAll ( ) ; if ( contrib . isInstalled ( ) ) { contextMenu . add ( openFolder ) ; setComponentPopupMenu ( contextMenu ) ; } else { setComponentPopupMenu ( null ) ; } if ( ! contrib . isCompatible ( Base . getRevision ( ) ) ) { blurContributionPanel ( this ) ; } } private void installContribution ( AvailableContribution info ) { if ( info . link == null ) { listPanel . contribManager . status . setErrorMessage ( Language . interpolate ( "contrib.unsupported_operating_system" , info . getType ( ) ) ) ; } else { installContribution ( info , info . link ) ; } } private void installContribution ( AvailableContribution ad , String url ) { installRemoveButton . setEnabled ( false ) ; try { URL downloadUrl = new URL ( url ) ; installProgressBar . setVisible ( true ) ; ContribProgressBar downloadProgress = new ContribProgressBar ( installProgressBar ) { public void finishedAction ( ) { } public void cancel ( ) { resetInstallProgressBarState ( ) ; installRemoveButton . setEnabled ( ! contrib . isUpdateFlagged ( ) ) ; ( ( CardLayout ) barButtonCardPane . getLayout ( ) ) . show ( barButtonCardPane , BUTTON_CONSTRAINT ) ; isInstallInProgress = false ; if ( isUpdateInProgress ) isUpdateInProgress = ! isUpdateInProgress ; updateButton . setVisible ( contribListing . hasUpdates ( contrib ) && ! contrib . isUpdateFlagged ( ) ) ; setSelected ( true ) ; } } ; ContribProgressBar installProgress = new ContribProgressBar ( installProgressBar ) { public void finishedAction ( ) { resetInstallProgressBarState ( ) ; installRemoveButton . setEnabled ( ! contrib . isUpdateFlagged ( ) ) ; if ( isError ( ) ) { listPanel . contribManager . status . setErrorMessage ( Language . text ( "contrib.download_error" ) ) ; } ( ( CardLayout ) barButtonCardPane . getLayout ( ) ) . show ( barButtonCardPane , BUTTON_CONSTRAINT ) ; isInstallInProgress = false ; if ( isUpdateInProgress ) isUpdateInProgress = ! isUpdateInProgress ; updateButton . setVisible ( contribListing . hasUpdates ( contrib ) && ! contrib . isUpdateFlagged ( ) ) ; setSelected ( true ) ; } public void cancel ( ) { finishedAction ( ) ; } } ; ContributionManager . downloadAndInstall ( listPanel . contribManager . editor , downloadUrl , ad , downloadProgress , installProgress , listPanel . contribManager . status ) ; } catch ( MalformedURLException e ) { Base . showWarning ( Language . text ( "contrib.errors.install_failed" ) , Language . text ( "contrib.errors.malformed_url" ) , e ) ; } } protected void resetInstallProgressBarState ( ) { installProgressBar . setString ( Language . text ( "contrib.progress.starting" ) ) ; installProgressBar . setIndeterminate ( false ) ; installProgressBar . setValue ( 0 ) ; installProgressBar . setVisible ( false ) ; } public void setSelected ( boolean isSelected ) { enableHyperlinks = alreadySelected ; if ( contrib != null ) { updateButton . setVisible ( ( contribListing . hasUpdates ( contrib ) && ! contrib . isUpdateFlagged ( ) && ! contrib . isDeletionFlagged ( ) ) || isUpdateInProgress ) ; updateButton . setEnabled ( ! contribListing . hasListDownloadFailed ( ) ) ; } installRemoveButton . setVisible ( isSelected ( ) || installRemoveButton . getText ( ) . equals ( Language . text ( "contrib.remove" ) ) || isUpdateInProgress ) ; installRemoveButton . setEnabled ( installRemoveButton . getText ( ) . equals ( Language . text ( "contrib.remove" ) ) || ! contribListing . hasListDownloadFailed ( ) ) ; reorganizePaneComponents ( ) ; descriptionPane . removeHyperlinkListener ( ContributionListPanel . nullHyperlinkListener ) ; descriptionPane . removeHyperlinkListener ( conditionalHyperlinkOpener ) ; if ( isSelected ( ) ) { descriptionPane . addHyperlinkListener ( conditionalHyperlinkOpener ) ; } else { descriptionPane . addHyperlinkListener ( ContributionListPanel . nullHyperlinkListener ) ; } setSelectionStyle ( descriptionPane , isSelected ( ) ) ; alreadySelected = isSelected ( ) ; } public boolean isSelected ( ) { return listPanel . getSelectedPanel ( ) == this ; } public void setForeground ( Color fg ) { super . setForeground ( fg ) ; if ( contrib != null ) { boolean installed = contrib . isInstalled ( ) ; setForegroundStyle ( descriptionPane , installed , isSelected ( ) ) ; } } static String sanitizeHtmlTags ( String stringIn ) { stringIn = stringIn . replaceAll ( "<" , "&lt;" ) ; stringIn = stringIn . replaceAll ( ">" , "&gt;" ) ; return stringIn ; } static String toHtmlLinks ( String stringIn ) { Pattern p = Pattern . compile ( "\\[(.*?)\\]\\((.*?)\\)" ) ; Matcher m = p . matcher ( stringIn ) ; StringBuilder sb = new StringBuilder ( ) ; int start = 0 ; while ( m . find ( start ) ) { sb . append ( stringIn . substring ( start , m . start ( ) ) ) ; String text = m . group ( 1 ) ; String url = m . group ( 2 ) ; sb . append ( "<a href=\"" ) ; sb . append ( url ) ; sb . append ( "\">" ) ; sb . append ( text ) ; sb . append ( "</a>" ) ; start = m . end ( ) ; } sb . append ( stringIn . substring ( start ) ) ; return sb . toString ( ) ; } static void setForegroundStyle ( JTextPane textPane , boolean installed , boolean selected ) { Document doc = textPane . getDocument ( ) ; if ( doc instanceof HTMLDocument ) { HTMLDocument html = ( HTMLDocument ) doc ; StyleSheet stylesheet = html . getStyleSheet ( ) ; String c = ( installed && ! selected ) ? "#555555" : "#000000" ; stylesheet . addRule ( "body { color:" + c + "; }" ) ; stylesheet . addRule ( "a { color:" + c + "; }" ) ; } } static void setTextStyle ( JTextPane textPane ) { Document doc = textPane . getDocument ( ) ; if ( doc instanceof HTMLDocument ) { HTMLDocument html = ( HTMLDocument ) doc ; StyleSheet stylesheet = html . getStyleSheet ( ) ; stylesheet . addRule ( "body { " + " margin: 0; padding: 0;" + " font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;" + " font-size: 100%;" + "font-size: 0.95em; " + "}" ) ; } } static void setSelectionStyle ( JTextPane textPane , boolean selected ) { Document doc = textPane . getDocument ( ) ; if ( doc instanceof HTMLDocument ) { HTMLDocument html = ( HTMLDocument ) doc ; StyleSheet styleSheet = html . getStyleSheet ( ) ; if ( selected ) { styleSheet . addRule ( "a { text-decoration:underline } " ) ; } else { styleSheet . addRule ( "a { text-decoration:none }" ) ; } } } }
package processing . app . contrib ; import java . io . File ; import java . io . FileFilter ; import java . io . IOException ; import java . util . ArrayList ; import processing . app . Base ; import processing . app . Editor ; import processing . app . Library ; public enum ContributionType { LIBRARY , TOOL , MODE , EXAMPLES ; public String toString ( ) { switch ( this ) { case LIBRARY : return "library" ; case TOOL : return "tool" ; case MODE : return "mode" ; case EXAMPLES : return "examples" ; } return null ; } ; public String getTitle ( ) { String s = toString ( ) ; if ( this == EXAMPLES ) return Character . toUpperCase ( s . charAt ( 0 ) ) + s . substring ( 1 , s . indexOf ( '-' ) + 1 ) + Character . toUpperCase ( s . charAt ( s . indexOf ( '-' ) + 1 ) ) + s . substring ( s . indexOf ( '-' ) + 2 ) ; else return Character . toUpperCase ( s . charAt ( 0 ) ) + s . substring ( 1 ) ; } public String getFolderName ( ) { switch ( this ) { case LIBRARY : return "libraries" ; case TOOL : return "tools" ; case MODE : return "modes" ; case EXAMPLES : return "examples" ; } return null ; } public File createTempFolder ( ) throws IOException { return Base . createTempFolder ( toString ( ) , "tmp" , getSketchbookFolder ( ) ) ; } public boolean isTempFolderName ( String name ) { return name . startsWith ( toString ( ) ) && name . endsWith ( "tmp" ) ; } static public ContributionType fromName ( String s ) { if ( s != null ) { if ( "library" . equalsIgnoreCase ( s ) ) { return LIBRARY ; } if ( "tool" . equalsIgnoreCase ( s ) ) { return TOOL ; } if ( "mode" . equalsIgnoreCase ( s ) ) { return MODE ; } if ( "examples" . equalsIgnoreCase ( s ) ) { return EXAMPLES ; } } return null ; } public File getSketchbookFolder ( ) { switch ( this ) { case LIBRARY : return Base . getSketchbookLibrariesFolder ( ) ; case TOOL : return Base . getSketchbookToolsFolder ( ) ; case MODE : return Base . getSketchbookModesFolder ( ) ; case EXAMPLES : return Base . getSketchbookExamplesFolder ( ) ; } return null ; } boolean isCandidate ( File potential ) { return ( potential . isDirectory ( ) && new File ( potential , toString ( ) ) . exists ( ) && ! isTempFolderName ( potential . getName ( ) ) ) ; } public File [ ] listCandidates ( File folder ) { return folder . listFiles ( new FileFilter ( ) { public boolean accept ( File potential ) { return isCandidate ( potential ) ; } } ) ; } File findCandidate ( File folder ) { File [ ] folders = listCandidates ( folder ) ; if ( folders . length == 0 ) { return null ; } else if ( folders . length > 1 ) { Base . log ( "More than one " + toString ( ) + " found inside " + folder . getAbsolutePath ( ) ) ; } return folders [ 0 ] ; } boolean requiresRestart ( ) { return this == ContributionType . TOOL || this == ContributionType . MODE ; } LocalContribution load ( Base base , File folder ) { switch ( this ) { case LIBRARY : return Library . load ( folder ) ; case TOOL : return ToolContribution . load ( folder ) ; case MODE : return ModeContribution . load ( base , folder ) ; case EXAMPLES : return ExamplesContribution . load ( folder ) ; } return null ; } ArrayList < LocalContribution > listContributions ( Editor editor ) { ArrayList < LocalContribution > contribs = new ArrayList < LocalContribution > ( ) ; switch ( this ) { case LIBRARY : contribs . addAll ( editor . getMode ( ) . contribLibraries ) ; break ; case TOOL : contribs . addAll ( editor . getToolContribs ( ) ) ; break ; case MODE : contribs . addAll ( editor . getBase ( ) . getModeContribs ( ) ) ; break ; case EXAMPLES : contribs . addAll ( editor . getBase ( ) . getExampleContribs ( ) ) ; break ; } return contribs ; } File getBackupFolder ( ) { return new File ( getSketchbookFolder ( ) , "old" ) ; } File createBackupFolder ( StatusPanel status ) { File backupFolder = getBackupFolder ( ) ; if ( ! backupFolder . exists ( ) && ! backupFolder . mkdirs ( ) ) { status . setErrorMessage ( "Could not create a backup folder in the " + "sketchbook " + toString ( ) + " folder." ) ; return null ; } return backupFolder ; } ContributionFilter createFilter ( ) { return new ContributionFilter ( ) { public boolean matches ( Contribution contrib ) { return contrib . getType ( ) == ContributionType . this ; } } ; } static ContributionFilter createUpdateFilter ( ) { return new ContributionFilter ( ) { public boolean matches ( Contribution contrib ) { if ( contrib instanceof LocalContribution ) { return ContributionListing . getInstance ( ) . hasUpdates ( contrib ) ; } return false ; } } ; } }
package processing . app . contrib ; import java . io . File ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import processing . app . Base ; import processing . core . PApplet ; public class ExamplesContribution extends LocalContribution { private ArrayList < String > compatibleModesList ; static public ExamplesContribution load ( File folder ) { return new ExamplesContribution ( folder ) ; } private ExamplesContribution ( File folder ) { super ( folder ) ; if ( properties != null ) { compatibleModesList = parseCompatibleModesList ( properties . get ( "compatibleModesList" ) ) ; } } private static ArrayList < String > parseCompatibleModesList ( String unparsedModes ) { ArrayList < String > modesList = new ArrayList < String > ( ) ; if ( unparsedModes == null || unparsedModes . isEmpty ( ) ) return modesList ; String [ ] splitStr = PApplet . trim ( PApplet . split ( unparsedModes , ',' ) ) ; for ( String mode : splitStr ) modesList . add ( mode . trim ( ) ) ; return modesList ; } public static boolean isExamplesCompatible ( Base base , File exampleLocationFolder ) { File propertiesFile = new File ( exampleLocationFolder , ContributionType . EXAMPLES . toString ( ) + ".properties" ) ; if ( propertiesFile . exists ( ) ) { ArrayList < String > compModesList = parseCompatibleModesList ( Base . readSettings ( propertiesFile ) . get ( "compatibleModesList" ) ) ; for ( String c : compModesList ) { if ( c . equalsIgnoreCase ( base . getActiveEditor ( ) . getMode ( ) . getIdentifier ( ) ) ) { return true ; } } } return false ; } static public void loadMissing ( Base base ) { File examplesFolder = Base . getSketchbookExamplesFolder ( ) ; List < ExamplesContribution > contribExamples = base . getExampleContribs ( ) ; Map < File , ExamplesContribution > existing = new HashMap < File , ExamplesContribution > ( ) ; for ( ExamplesContribution contrib : contribExamples ) { existing . put ( contrib . getFolder ( ) , contrib ) ; } File [ ] potential = ContributionType . EXAMPLES . listCandidates ( examplesFolder ) ; if ( potential != null ) { for ( File folder : potential ) { if ( ! existing . containsKey ( folder ) ) { contribExamples . add ( new ExamplesContribution ( folder ) ) ; } } } } @ Override public ContributionType getType ( ) { return ContributionType . EXAMPLES ; } public ArrayList < String > getCompatibleModesList ( ) { return compatibleModesList ; } }
package processing . app . contrib ; import java . io . * ; import java . net . * ; import java . nio . file . Files ; import java . util . * ; import java . util . concurrent . locks . ReentrantLock ; import processing . app . Base ; import processing . app . Library ; import processing . core . PApplet ; public class ContributionListing { static final String LISTING_URL = "http://download.processing.org/contribs.txt" ; static volatile ContributionListing singleInstance ; File listingFile ; ArrayList < ContributionChangeListener > listeners ; ArrayList < AvailableContribution > advertisedContributions ; Map < String , List < Contribution > > librariesByCategory ; public Map < String , Contribution > librariesByImportHeader ; ArrayList < Contribution > allContributions ; boolean hasDownloadedLatestList ; boolean hasListDownloadFailed ; ReentrantLock downloadingListingLock ; private ContributionListing ( ) { listeners = new ArrayList < ContributionChangeListener > ( ) ; advertisedContributions = new ArrayList < AvailableContribution > ( ) ; librariesByCategory = new HashMap < String , List < Contribution > > ( ) ; librariesByImportHeader = new HashMap < String , Contribution > ( ) ; allContributions = new ArrayList < Contribution > ( ) ; downloadingListingLock = new ReentrantLock ( ) ; listingFile = Base . getSettingsFile ( "contributions.txt" ) ; listingFile . setWritable ( true ) ; if ( listingFile . exists ( ) ) { setAdvertisedList ( listingFile ) ; } } public static ContributionListing getInstance ( ) { if ( singleInstance == null ) { synchronized ( ContributionListing . class ) { if ( singleInstance == null ) { singleInstance = new ContributionListing ( ) ; } } } return singleInstance ; } void setAdvertisedList ( File file ) { listingFile = file ; advertisedContributions . clear ( ) ; advertisedContributions . addAll ( parseContribList ( listingFile ) ) ; for ( Contribution contribution : advertisedContributions ) { addContribution ( contribution ) ; } Collections . sort ( allContributions , nameComparator ) ; } protected void updateInstalledList ( List < Contribution > installedContributions ) { for ( Contribution contribution : installedContributions ) { Contribution existingContribution = getContribution ( contribution ) ; if ( existingContribution != null ) { replaceContribution ( existingContribution , contribution ) ; } else { addContribution ( contribution ) ; } } } protected void replaceContribution ( Contribution oldLib , Contribution newLib ) { if ( oldLib != null && newLib != null ) { for ( String category : oldLib . getCategories ( ) ) { if ( librariesByCategory . containsKey ( category ) ) { List < Contribution > list = librariesByCategory . get ( category ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( list . get ( i ) == oldLib ) { list . set ( i , newLib ) ; } } } } if ( oldLib . getImports ( ) != null ) { for ( String importName : oldLib . getImports ( ) ) { if ( librariesByImportHeader . containsKey ( importName ) ) { librariesByImportHeader . put ( importName , newLib ) ; } } } for ( int i = 0 ; i < allContributions . size ( ) ; i ++ ) { if ( allContributions . get ( i ) == oldLib ) { allContributions . set ( i , newLib ) ; } } notifyChange ( oldLib , newLib ) ; } } private void addContribution ( Contribution contribution ) { if ( contribution . getImports ( ) != null ) { for ( String importName : contribution . getImports ( ) ) { librariesByImportHeader . put ( importName , contribution ) ; } } for ( String category : contribution . getCategories ( ) ) { if ( librariesByCategory . containsKey ( category ) ) { List < Contribution > list = librariesByCategory . get ( category ) ; list . add ( contribution ) ; Collections . sort ( list , nameComparator ) ; } else { ArrayList < Contribution > list = new ArrayList < Contribution > ( ) ; list . add ( contribution ) ; librariesByCategory . put ( category , list ) ; } allContributions . add ( contribution ) ; notifyAdd ( contribution ) ; Collections . sort ( allContributions , nameComparator ) ; } } protected void removeContribution ( Contribution contribution ) { for ( String category : contribution . getCategories ( ) ) { if ( librariesByCategory . containsKey ( category ) ) { librariesByCategory . get ( category ) . remove ( contribution ) ; } } if ( contribution . getImports ( ) != null ) { for ( String importName : contribution . getImports ( ) ) { librariesByImportHeader . remove ( importName ) ; } } allContributions . remove ( contribution ) ; notifyRemove ( contribution ) ; } private Contribution getContribution ( Contribution contribution ) { for ( Contribution c : allContributions ) { if ( c . getName ( ) . equals ( contribution . getName ( ) ) && c . getType ( ) == contribution . getType ( ) ) { return c ; } } return null ; } protected AvailableContribution getAvailableContribution ( Contribution info ) { Iterator < AvailableContribution > iter = advertisedContributions . iterator ( ) ; while ( iter . hasNext ( ) ) { AvailableContribution advertised = iter . next ( ) ; if ( advertised . getType ( ) == info . getType ( ) && advertised . getName ( ) . equals ( info . getName ( ) ) ) { return advertised ; } } return null ; } protected Set < String > getCategories ( ContributionFilter filter ) { Set < String > outgoing = new HashSet < String > ( ) ; Set < String > categorySet = librariesByCategory . keySet ( ) ; for ( String categoryName : categorySet ) { for ( Contribution contrib : librariesByCategory . get ( categoryName ) ) { if ( filter . matches ( contrib ) ) { if ( categoryName != null && categoryName . trim ( ) . length ( ) != 0 ) { outgoing . add ( categoryName ) ; } break ; } } } return outgoing ; } protected List < Contribution > getFilteredLibraryList ( String category , List < String > filters ) { ArrayList < Contribution > filteredList = new ArrayList < Contribution > ( allContributions ) ; Iterator < Contribution > it = filteredList . iterator ( ) ; while ( it . hasNext ( ) ) { Contribution libInfo = it . next ( ) ; if ( category != null && ! libInfo . hasCategory ( category ) ) { it . remove ( ) ; } else { for ( String filter : filters ) { if ( ! matches ( libInfo , filter ) ) { it . remove ( ) ; break ; } } } } return filteredList ; } private boolean matches ( Contribution contrib , String filter ) { int colon = filter . indexOf ( ":" ) ; if ( colon != - 1 ) { String isText = filter . substring ( 0 , colon ) ; String property = filter . substring ( colon + 1 ) ; if ( ! isProperty ( property ) ) { return true ; } if ( "is" . equals ( isText ) || "has" . equals ( isText ) ) { return hasProperty ( contrib , filter . substring ( colon + 1 ) ) ; } else if ( "not" . equals ( isText ) ) { return ! hasProperty ( contrib , filter . substring ( colon + 1 ) ) ; } } filter = ".*" + filter . toLowerCase ( ) + ".*" ; return contrib . getAuthorList ( ) != null && contrib . getAuthorList ( ) . toLowerCase ( ) . matches ( filter ) || contrib . getSentence ( ) != null && contrib . getSentence ( ) . toLowerCase ( ) . matches ( filter ) || contrib . getParagraph ( ) != null && contrib . getParagraph ( ) . toLowerCase ( ) . matches ( filter ) || contrib . hasCategory ( filter ) || contrib . getName ( ) != null && contrib . getName ( ) . toLowerCase ( ) . matches ( filter ) ; } private boolean isProperty ( String property ) { return property . startsWith ( "updat" ) || property . startsWith ( "upgrad" ) || property . startsWith ( "instal" ) && ! property . startsWith ( "installabl" ) || property . equals ( "tool" ) || property . startsWith ( "lib" ) || property . equals ( "mode" ) || property . equals ( "compilation" ) ; } private boolean hasProperty ( Contribution contrib , String property ) { if ( property . startsWith ( "updat" ) || property . startsWith ( "upgrad" ) ) { return hasUpdates ( contrib ) ; } if ( property . startsWith ( "instal" ) && ! property . startsWith ( "installabl" ) ) { return contrib . isInstalled ( ) ; } if ( property . equals ( "tool" ) ) { return contrib . getType ( ) == ContributionType . TOOL ; } if ( property . startsWith ( "lib" ) ) { return contrib . getType ( ) == ContributionType . LIBRARY ; } if ( property . equals ( "mode" ) ) { return contrib . getType ( ) == ContributionType . MODE ; } return false ; } protected List < Contribution > getCompatibleContributionList ( List < Contribution > filteredLibraries , boolean filter ) { ArrayList < Contribution > filteredList = new ArrayList < Contribution > ( filteredLibraries ) ; if ( ! filter ) return filteredList ; Iterator < Contribution > it = filteredList . iterator ( ) ; while ( it . hasNext ( ) ) { Contribution libInfo = it . next ( ) ; if ( ! libInfo . isCompatible ( Base . getRevision ( ) ) ) { it . remove ( ) ; } } return filteredList ; } private void notifyRemove ( Contribution contribution ) { for ( ContributionChangeListener listener : listeners ) { listener . contributionRemoved ( contribution ) ; } } private void notifyAdd ( Contribution contribution ) { for ( ContributionChangeListener listener : listeners ) { listener . contributionAdded ( contribution ) ; } } private void notifyChange ( Contribution oldLib , Contribution newLib ) { for ( ContributionChangeListener listener : listeners ) { listener . contributionChanged ( oldLib , newLib ) ; } } protected void addContributionListener ( ContributionChangeListener listener ) { for ( Contribution contrib : allContributions ) { listener . contributionAdded ( contrib ) ; } listeners . add ( listener ) ; } protected void downloadAvailableList ( final ContribProgressMonitor progress ) { new Thread ( new Runnable ( ) { public void run ( ) { downloadingListingLock . lock ( ) ; URL url = null ; try { url = new URL ( LISTING_URL ) ; } catch ( MalformedURLException e ) { progress . error ( e ) ; progress . finished ( ) ; } if ( ! progress . isFinished ( ) ) { File tempContribFile = Base . getSettingsFile ( "contributions_temp.txt" ) ; tempContribFile . setWritable ( true ) ; ContributionManager . download ( url , tempContribFile , progress ) ; if ( ! progress . isCanceled ( ) && ! progress . isError ( ) ) { try { Files . deleteIfExists ( listingFile . toPath ( ) ) ; listingFile = new File ( Files . move ( tempContribFile . toPath ( ) , tempContribFile . toPath ( ) . resolveSibling ( listingFile . toPath ( ) ) ) . toString ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } hasDownloadedLatestList = true ; hasListDownloadFailed = false ; setAdvertisedList ( listingFile ) ; } else hasListDownloadFailed = true ; } downloadingListingLock . unlock ( ) ; } } , "Contribution List Downloader" ) . start ( ) ; } boolean hasUpdates ( ) { for ( Contribution info : allContributions ) { if ( hasUpdates ( info ) ) { return true ; } } return false ; } boolean hasUpdates ( Base base ) { for ( ModeContribution m : base . getModeContribs ( ) ) if ( hasUpdates ( m ) ) return true ; for ( Library l : base . getActiveEditor ( ) . getMode ( ) . contribLibraries ) if ( hasUpdates ( l ) ) return true ; for ( ToolContribution t : base . getActiveEditor ( ) . getToolContribs ( ) ) if ( hasUpdates ( t ) ) return true ; return false ; } boolean hasUpdates ( Contribution contribution ) { if ( contribution . isInstalled ( ) ) { Contribution advertised = getAvailableContribution ( contribution ) ; if ( advertised == null ) { return false ; } return advertised . getVersion ( ) > contribution . getVersion ( ) ; } return false ; } String getLatestVersion ( Contribution contribution ) { Contribution newestContrib = getAvailableContribution ( contribution ) ; String latestVersion = newestContrib . getPrettyVersion ( ) ; if ( latestVersion != null && ! latestVersion . isEmpty ( ) ) { if ( latestVersion . toLowerCase ( ) . startsWith ( "build" ) ) return ( "v" + latestVersion . substring ( 5 , latestVersion . indexOf ( ',' ) ) . trim ( ) ) ; else if ( latestVersion . toLowerCase ( ) . startsWith ( "v" ) ) return latestVersion ; else return ( "v" + latestVersion ) ; } else return null ; } boolean hasDownloadedLatestList ( ) { return hasDownloadedLatestList ; } boolean hasListDownloadFailed ( ) { return hasListDownloadFailed ; } ArrayList < AvailableContribution > parseContribList ( File file ) { ArrayList < AvailableContribution > outgoing = new ArrayList < AvailableContribution > ( ) ; if ( file != null && file . exists ( ) ) { String [ ] lines = PApplet . loadStrings ( file ) ; int start = 0 ; while ( start < lines . length ) { String type = lines [ start ] ; ContributionType contribType = ContributionType . fromName ( type ) ; if ( contribType == null ) { System . err . println ( "Error in contribution listing file on line " + ( start + 1 ) ) ; int end = ++ start ; while ( end < lines . length && lines [ end ] . trim ( ) . length ( ) != 0 ) { end ++ ; } start = end + 1 ; } else { int end = ++ start ; while ( end < lines . length && lines [ end ] . trim ( ) . length ( ) != 0 ) { end ++ ; } String [ ] contribLines = PApplet . subset ( lines , start , end - start ) ; Map < String , String > contribParams = Base . readSettings ( file . getName ( ) , contribLines ) ; outgoing . add ( new AvailableContribution ( contribType , contribParams ) ) ; start = end + 1 ; } } } return outgoing ; } public Comparator < ? super Contribution > getComparator ( ) { return nameComparator ; } static Comparator < Contribution > nameComparator = new Comparator < Contribution > ( ) { public int compare ( Contribution o1 , Contribution o2 ) { return o1 . getName ( ) . toLowerCase ( ) . compareTo ( o2 . getName ( ) . toLowerCase ( ) ) ; } } ; }
package processing . app . contrib ; import java . io . * ; import java . net . URL ; import java . net . URLClassLoader ; import java . text . SimpleDateFormat ; import java . util . * ; import java . util . zip . * ; import javax . swing . JOptionPane ; import processing . app . * ; import processing . core . PApplet ; public abstract class LocalContribution extends Contribution { static public final String DELETION_FLAG = "marked_for_deletion" ; static public final String UPDATE_FLAGGED = "marked_for_update" ; static public final String RESTART_FLAG = "requires_restart" ; protected String id ; protected int latestVersion ; protected File folder ; protected Map < String , String > properties ; protected ClassLoader loader ; public LocalContribution ( File folder ) { this . folder = folder ; File propertiesFile = new File ( folder , getTypeName ( ) + ".properties" ) ; if ( propertiesFile . exists ( ) ) { properties = Base . readSettings ( propertiesFile ) ; name = properties . get ( "name" ) ; id = properties . get ( "id" ) ; categories = parseCategories ( properties . get ( "category" ) ) ; specifiedImports = parseImports ( properties . get ( "imports" ) ) ; if ( name == null ) { name = folder . getName ( ) ; } authorList = properties . get ( "authorList" ) ; url = properties . get ( "url" ) ; sentence = properties . get ( "sentence" ) ; paragraph = properties . get ( "paragraph" ) ; try { version = Integer . parseInt ( properties . get ( "version" ) ) ; } catch ( NumberFormatException e ) { System . err . println ( "The version number for the " + name + " library is not set properly." ) ; System . err . println ( "Please contact the library author to fix it according to the guidelines." ) ; } prettyVersion = properties . get ( "prettyVersion" ) ; try { lastUpdated = Long . parseLong ( properties . get ( "lastUpdated" ) ) ; } catch ( NumberFormatException e ) { lastUpdated = 0 ; } String minRev = properties . get ( "minRevision" ) ; if ( minRev != null ) { minRevision = PApplet . parseInt ( minRev , 0 ) ; } String maxRev = properties . get ( "maxRevision" ) ; if ( maxRev != null ) { maxRevision = PApplet . parseInt ( maxRev , 0 ) ; } } else { Base . log ( "No properties file at " + propertiesFile . getAbsolutePath ( ) ) ; name = folder . getName ( ) ; categories = defaultCategory ( ) ; } if ( categories . contains ( SPECIAL_CATEGORY_NAME ) ) validateSpecial ( ) ; } private void validateSpecial ( ) { for ( AvailableContribution available : ContributionListing . getInstance ( ) . advertisedContributions ) if ( available . getName ( ) . equals ( name ) ) { if ( ! available . isSpecial ( ) ) categories . remove ( SPECIAL_CATEGORY_NAME ) ; } return ; } public String initLoader ( String className ) throws Exception { File modeDirectory = new File ( folder , getTypeName ( ) ) ; if ( modeDirectory . exists ( ) ) { Base . log ( "checking mode folder regarding " + className ) ; if ( className == null ) { String shortName = folder . getName ( ) ; File mainJar = new File ( modeDirectory , shortName + ".jar" ) ; if ( mainJar . exists ( ) ) { className = findClassInZipFile ( shortName , mainJar ) ; } else { throw new IgnorableException ( mainJar . getAbsolutePath ( ) + " does not exist." ) ; } if ( className == null ) { throw new IgnorableException ( "Could not find " + shortName + " class inside " + mainJar . getAbsolutePath ( ) ) ; } } File [ ] archives = Base . listJarFiles ( modeDirectory ) ; if ( archives != null && archives . length > 0 ) { URL [ ] urlList = new URL [ archives . length ] ; for ( int j = 0 ; j < urlList . length ; j ++ ) { Base . log ( "Found archive " + archives [ j ] + " for " + getName ( ) ) ; urlList [ j ] = archives [ j ] . toURI ( ) . toURL ( ) ; } loader = new URLClassLoader ( urlList ) ; Base . log ( "loading above JARs with loader " + loader ) ; } } if ( loader == null ) { loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; } return className ; } LocalContribution copyAndLoad ( Base base , boolean confirmReplace , StatusPanel status ) { String contribFolderName = getFolder ( ) . getName ( ) ; File contribTypeFolder = getType ( ) . getSketchbookFolder ( ) ; File contribFolder = new File ( contribTypeFolder , contribFolderName ) ; if ( status != null ) { Editor editor = base . getActiveEditor ( ) ; ArrayList < LocalContribution > oldContribs = getType ( ) . listContributions ( editor ) ; if ( contribFolder . exists ( ) && ! contribFolder . isDirectory ( ) ) { contribFolder . delete ( ) ; contribFolder = new File ( contribTypeFolder , contribFolderName ) ; } for ( LocalContribution oldContrib : oldContribs ) { if ( ( oldContrib . getFolder ( ) . exists ( ) && oldContrib . getFolder ( ) . equals ( contribFolder ) ) || ( oldContrib . getId ( ) != null && oldContrib . getId ( ) . equals ( getId ( ) ) ) ) { if ( oldContrib . getType ( ) . requiresRestart ( ) ) { if ( ! oldContrib . backup ( editor , false , status ) ) { return null ; } } else { int result = 0 ; boolean doBackup = Preferences . getBoolean ( "contribution.backup.on_install" ) ; if ( confirmReplace ) { if ( doBackup ) { result = Base . showYesNoQuestion ( editor , "Replace" , "Replace pre-existing \"" + oldContrib . getName ( ) + "\" library?" , "A pre-existing copy of the \"" + oldContrib . getName ( ) + "\" library<br>" + "has been found in your sketchbook. Clicking Yes<br>" + "will move the existing library to a backup folder<br>" + "in <i>libraries/old</i> before replacing it." ) ; if ( result != JOptionPane . YES_OPTION || ! oldContrib . backup ( editor , true , status ) ) { return null ; } } else { result = Base . showYesNoQuestion ( editor , "Replace" , "Replace pre-existing \"" + oldContrib . getName ( ) + "\" library?" , "A pre-existing copy of the \"" + oldContrib . getName ( ) + "\" library<br>" + "has been found in your sketchbook. Clicking Yes<br>" + "will permanently delete this library and all of its contents<br>" + "before replacing it." ) ; if ( result != JOptionPane . YES_OPTION || ! oldContrib . getFolder ( ) . delete ( ) ) { return null ; } } } else { if ( ( doBackup && ! oldContrib . backup ( editor , true , status ) ) || ( ! doBackup && ! oldContrib . getFolder ( ) . delete ( ) ) ) { return null ; } } } } } if ( contribFolder . exists ( ) ) { Base . removeDir ( contribFolder ) ; } } else { if ( contribFolder . exists ( ) && contribFolder . isDirectory ( ) ) { Base . removeDir ( contribFolder ) ; } else if ( contribFolder . exists ( ) ) { contribFolder . delete ( ) ; contribFolder = new File ( contribTypeFolder , contribFolderName ) ; } } File oldFolder = getFolder ( ) ; try { Base . copyDir ( oldFolder , contribFolder ) ; } catch ( IOException e ) { status . setErrorMessage ( "Could not copy " + getTypeName ( ) + " \"" + getName ( ) + "\" to the sketchbook." ) ; e . printStackTrace ( ) ; return null ; } return getType ( ) . load ( base , contribFolder ) ; } boolean backup ( Editor editor , boolean deleteOriginal , StatusPanel status ) { File backupFolder = getType ( ) . createBackupFolder ( status ) ; boolean success = false ; if ( backupFolder != null ) { String libFolderName = getFolder ( ) . getName ( ) ; String prefix = new SimpleDateFormat ( "yyyy-MM-dd" ) . format ( new Date ( ) ) ; final String backupName = prefix + " " + libFolderName ; File backupSubFolder = ContributionManager . getUniqueName ( backupFolder , backupName ) ; if ( deleteOriginal ) { success = getFolder ( ) . renameTo ( backupSubFolder ) ; } else { try { Base . copyDir ( getFolder ( ) , backupSubFolder ) ; success = true ; } catch ( IOException e ) { } } if ( ! success ) { status . setErrorMessage ( "Could not move contribution to backup folder." ) ; } } return success ; } void removeContribution ( final Editor editor , final ContribProgressMonitor pm , final StatusPanel status ) { new Thread ( new Runnable ( ) { public void run ( ) { remove ( editor , pm , status , ContributionListing . getInstance ( ) ) ; } } , "Contribution Uninstaller" ) . start ( ) ; } void remove ( final Editor editor , final ContribProgressMonitor pm , final StatusPanel status , final ContributionListing contribListing ) { pm . startTask ( "Removing" , ContribProgressMonitor . UNKNOWN ) ; boolean doBackup = Preferences . getBoolean ( "contribution.backup.on_remove" ) ; boolean success = false ; if ( getType ( ) == ContributionType . MODE ) { boolean isModeActive = false ; ModeContribution m = ( ModeContribution ) this ; Iterator < Editor > iter = editor . getBase ( ) . getEditors ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Editor e = iter . next ( ) ; if ( e . getMode ( ) . equals ( m . getMode ( ) ) ) { isModeActive = true ; break ; } } if ( ! isModeActive ) m . clearClassLoader ( editor . getBase ( ) ) ; else { pm . cancel ( ) ; Base . showMessage ( "Mode Manager" , "Please save your Sketch and change the Mode of all Editor\nwindows that have " + this . name + " as the active Mode." ) ; return ; } } if ( getType ( ) == ContributionType . TOOL ) { ToolContribution t = ( ToolContribution ) this ; Iterator < Editor > iter = editor . getBase ( ) . getEditors ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Editor ed = iter . next ( ) ; ed . clearToolMenu ( ) ; } t . clearClassLoader ( editor . getBase ( ) ) ; } if ( doBackup ) { success = backup ( editor , true , status ) ; } else { Base . removeDir ( getFolder ( ) ) ; success = ! getFolder ( ) . exists ( ) ; } if ( success ) { if ( getType ( ) == ContributionType . TOOL ) { editor . removeTool ( ) ; } Contribution advertisedVersion = contribListing . getAvailableContribution ( this ) ; if ( advertisedVersion == null ) { contribListing . removeContribution ( this ) ; } else { contribListing . replaceContribution ( this , advertisedVersion ) ; } } else { if ( ! doBackup || ( doBackup && backup ( editor , false , status ) ) ) { if ( setDeletionFlag ( true ) ) { contribListing . replaceContribution ( this , this ) ; } } else status . setErrorMessage ( "Could not delete the contribution's files" ) ; } ContributionManager . refreshInstalled ( editor ) ; if ( success ) pm . finished ( ) ; else pm . cancel ( ) ; } public File getFolder ( ) { return folder ; } public boolean isInstalled ( ) { return folder != null ; } public String getId ( ) { return id ; } public int getLatestVersion ( ) { return latestVersion ; } public String [ ] getSpecifiedImports ( ) { return specifiedImports != null ? specifiedImports . toArray ( new String [ 0 ] ) : null ; } protected static List < String > parseImports ( String importsStr ) { List < String > outgoing = new ArrayList < String > ( ) ; if ( importsStr != null ) { String [ ] listing = PApplet . trim ( PApplet . split ( importsStr , ',' ) ) ; for ( String imp : listing ) { if ( imp . endsWith ( ".*" ) ) { imp = imp . substring ( 0 , imp . length ( ) - 2 ) ; } outgoing . add ( imp ) ; } } return ( outgoing . size ( ) > 0 ) ? outgoing : null ; } boolean setDeletionFlag ( boolean flag ) { return setFlag ( DELETION_FLAG , flag ) ; } boolean isDeletionFlagged ( ) { return isDeletionFlagged ( getFolder ( ) ) ; } static boolean isDeletionFlagged ( File folder ) { return isFlagged ( folder , DELETION_FLAG ) ; } boolean setUpdateFlag ( boolean flag ) { return setFlag ( UPDATE_FLAGGED , flag ) ; } boolean isUpdateFlagged ( ) { return isUpdateFlagged ( getFolder ( ) ) ; } static boolean isUpdateFlagged ( File folder ) { return isFlagged ( folder , UPDATE_FLAGGED ) ; } boolean setRestartFlag ( ) { return setFlag ( RESTART_FLAG , true ) ; } @ Override boolean isRestartFlagged ( ) { return isFlagged ( getFolder ( ) , RESTART_FLAG ) ; } static void clearRestartFlags ( File folder ) { File restartFlag = new File ( folder , RESTART_FLAG ) ; if ( restartFlag . exists ( ) ) { restartFlag . delete ( ) ; } } private boolean setFlag ( String flagFilename , boolean flag ) { if ( flag ) { try { new File ( getFolder ( ) , flagFilename ) . createNewFile ( ) ; return true ; } catch ( IOException e ) { return false ; } } else { return new File ( getFolder ( ) , flagFilename ) . delete ( ) ; } } static private boolean isFlagged ( File folder , String flagFilename ) { return new File ( folder , flagFilename ) . exists ( ) ; } static protected String findClassInZipFile ( String base , File file ) { String classFileName = "/" + base + ".class" ; try { ZipFile zipFile = new ZipFile ( file ) ; Enumeration < ? > entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) entries . nextElement ( ) ; if ( ! entry . isDirectory ( ) ) { String name = entry . getName ( ) ; if ( name . endsWith ( classFileName ) ) { zipFile . close ( ) ; return name . substring ( 0 , name . length ( ) - 6 ) . replace ( '/' , '.' ) ; } } } zipFile . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; } static protected class IgnorableException extends Exception { public IgnorableException ( String msg ) { super ( msg ) ; } } }
package processing . core ; import java . io . BufferedReader ; import java . io . File ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Map ; public class PShapeOBJ extends PShape { public PShapeOBJ ( PApplet parent , String filename ) { this ( parent , parent . createReader ( filename ) , getBasePath ( parent , filename ) ) ; } public PShapeOBJ ( PApplet parent , BufferedReader reader ) { this ( parent , reader , "" ) ; } public PShapeOBJ ( PApplet parent , BufferedReader reader , String basePath ) { ArrayList < OBJFace > faces = new ArrayList < OBJFace > ( ) ; ArrayList < OBJMaterial > materials = new ArrayList < OBJMaterial > ( ) ; ArrayList < PVector > coords = new ArrayList < PVector > ( ) ; ArrayList < PVector > normals = new ArrayList < PVector > ( ) ; ArrayList < PVector > texcoords = new ArrayList < PVector > ( ) ; parseOBJ ( parent , basePath , reader , faces , materials , coords , normals , texcoords ) ; parent = null ; family = GROUP ; addChildren ( faces , materials , coords , normals , texcoords ) ; } protected PShapeOBJ ( OBJFace face , OBJMaterial mtl , ArrayList < PVector > coords , ArrayList < PVector > normals , ArrayList < PVector > texcoords ) { family = GEOMETRY ; if ( face . vertIdx . size ( ) == 3 ) { kind = TRIANGLES ; } else if ( face . vertIdx . size ( ) == 4 ) { kind = QUADS ; } else { kind = POLYGON ; } stroke = false ; fill = true ; fillColor = rgbaValue ( mtl . kd ) ; ambientColor = rgbaValue ( mtl . ka ) ; specularColor = rgbaValue ( mtl . ks ) ; shininess = mtl . ns ; if ( mtl . kdMap != null ) { tintColor = rgbaValue ( mtl . kd , mtl . d ) ; } vertexCount = face . vertIdx . size ( ) ; vertices = new float [ vertexCount ] [ 12 ] ; for ( int j = 0 ; j < face . vertIdx . size ( ) ; j ++ ) { int vertIdx , normIdx ; PVector vert , norms ; vert = norms = null ; vertIdx = face . vertIdx . get ( j ) . intValue ( ) - 1 ; vert = coords . get ( vertIdx ) ; if ( j < face . normIdx . size ( ) ) { normIdx = face . normIdx . get ( j ) . intValue ( ) - 1 ; if ( - 1 < normIdx ) { norms = normals . get ( normIdx ) ; } } vertices [ j ] [ X ] = vert . x ; vertices [ j ] [ Y ] = vert . y ; vertices [ j ] [ Z ] = vert . z ; vertices [ j ] [ PGraphics . R ] = mtl . kd . x ; vertices [ j ] [ PGraphics . G ] = mtl . kd . y ; vertices [ j ] [ PGraphics . B ] = mtl . kd . z ; vertices [ j ] [ PGraphics . A ] = 1 ; if ( norms != null ) { vertices [ j ] [ PGraphics . NX ] = norms . x ; vertices [ j ] [ PGraphics . NY ] = norms . y ; vertices [ j ] [ PGraphics . NZ ] = norms . z ; } if ( mtl != null && mtl . kdMap != null ) { int texIdx ; PVector tex = null ; if ( j < face . texIdx . size ( ) ) { texIdx = face . texIdx . get ( j ) . intValue ( ) - 1 ; if ( - 1 < texIdx ) { tex = texcoords . get ( texIdx ) ; } } image = mtl . kdMap ; if ( tex != null ) { vertices [ j ] [ PGraphics . U ] = tex . x ; vertices [ j ] [ PGraphics . V ] = tex . y ; } } } } protected void addChildren ( ArrayList < OBJFace > faces , ArrayList < OBJMaterial > materials , ArrayList < PVector > coords , ArrayList < PVector > normals , ArrayList < PVector > texcoords ) { int mtlIdxCur = - 1 ; OBJMaterial mtl = null ; for ( int i = 0 ; i < faces . size ( ) ; i ++ ) { OBJFace face = faces . get ( i ) ; if ( mtlIdxCur != face . matIdx || face . matIdx == - 1 ) { mtlIdxCur = PApplet . max ( 0 , face . matIdx ) ; mtl = materials . get ( mtlIdxCur ) ; } PShape child = new PShapeOBJ ( face , mtl , coords , normals , texcoords ) ; addChild ( child ) ; } } static protected void parseOBJ ( PApplet parent , String path , BufferedReader reader , ArrayList < OBJFace > faces , ArrayList < OBJMaterial > materials , ArrayList < PVector > coords , ArrayList < PVector > normals , ArrayList < PVector > texcoords ) { Map < String , Integer > mtlTable = new HashMap < String , Integer > ( ) ; int mtlIdxCur = - 1 ; boolean readv , readvn , readvt ; try { readv = readvn = readvt = false ; String line ; String gname = "object" ; while ( ( line = reader . readLine ( ) ) != null ) { line = line . trim ( ) ; if ( line . equals ( "" ) || line . indexOf ( '#' ) == 0 ) { continue ; } while ( line . contains ( "\\" ) ) { line = line . split ( "\\\\" ) [ 0 ] ; final String s = reader . readLine ( ) ; if ( s != null ) line += s ; } String [ ] parts = line . split ( "\\s+" ) ; if ( parts . length > 0 ) { if ( parts [ 0 ] . equals ( "v" ) ) { PVector tempv = new PVector ( Float . valueOf ( parts [ 1 ] ) . floatValue ( ) , Float . valueOf ( parts [ 2 ] ) . floatValue ( ) , Float . valueOf ( parts [ 3 ] ) . floatValue ( ) ) ; coords . add ( tempv ) ; readv = true ; } else if ( parts [ 0 ] . equals ( "vn" ) ) { PVector tempn = new PVector ( Float . valueOf ( parts [ 1 ] ) . floatValue ( ) , Float . valueOf ( parts [ 2 ] ) . floatValue ( ) , Float . valueOf ( parts [ 3 ] ) . floatValue ( ) ) ; normals . add ( tempn ) ; readvn = true ; } else if ( parts [ 0 ] . equals ( "vt" ) ) { PVector tempv = new PVector ( Float . valueOf ( parts [ 1 ] ) . floatValue ( ) , 1 - Float . valueOf ( parts [ 2 ] ) . floatValue ( ) ) ; texcoords . add ( tempv ) ; readvt = true ; } else if ( parts [ 0 ] . equals ( "o" ) ) { } else if ( parts [ 0 ] . equals ( "mtllib" ) ) { if ( parts [ 1 ] != null ) { String fn = parts [ 1 ] ; if ( fn . indexOf ( File . separator ) == - 1 && ! path . equals ( "" ) ) { fn = path + File . separator + fn ; } BufferedReader mreader = parent . createReader ( fn ) ; if ( mreader != null ) { parseMTL ( parent , path , mreader , materials , mtlTable ) ; mreader . close ( ) ; } } } else if ( parts [ 0 ] . equals ( "g" ) ) { gname = 1 < parts . length ? parts [ 1 ] : "" ; } else if ( parts [ 0 ] . equals ( "usemtl" ) ) { if ( parts [ 1 ] != null ) { String mtlname = parts [ 1 ] ; if ( mtlTable . containsKey ( mtlname ) ) { Integer tempInt = mtlTable . get ( mtlname ) ; mtlIdxCur = tempInt . intValue ( ) ; } else { mtlIdxCur = - 1 ; } } } else if ( parts [ 0 ] . equals ( "f" ) ) { OBJFace face = new OBJFace ( ) ; face . matIdx = mtlIdxCur ; face . name = gname ; for ( int i = 1 ; i < parts . length ; i ++ ) { String seg = parts [ i ] ; if ( seg . indexOf ( "/" ) > 0 ) { String [ ] forder = seg . split ( "/" ) ; if ( forder . length > 2 ) { if ( forder [ 0 ] . length ( ) > 0 && readv ) { face . vertIdx . add ( Integer . valueOf ( forder [ 0 ] ) ) ; } if ( forder [ 1 ] . length ( ) > 0 && readvt ) { face . texIdx . add ( Integer . valueOf ( forder [ 1 ] ) ) ; } if ( forder [ 2 ] . length ( ) > 0 && readvn ) { face . normIdx . add ( Integer . valueOf ( forder [ 2 ] ) ) ; } } else if ( forder . length > 1 ) { if ( forder [ 0 ] . length ( ) > 0 && readv ) { face . vertIdx . add ( Integer . valueOf ( forder [ 0 ] ) ) ; } if ( forder [ 1 ] . length ( ) > 0 ) { if ( readvt ) { face . texIdx . add ( Integer . valueOf ( forder [ 1 ] ) ) ; } else if ( readvn ) { face . normIdx . add ( Integer . valueOf ( forder [ 1 ] ) ) ; } } } else if ( forder . length > 0 ) { if ( forder [ 0 ] . length ( ) > 0 && readv ) { face . vertIdx . add ( Integer . valueOf ( forder [ 0 ] ) ) ; } } } else { if ( seg . length ( ) > 0 && readv ) { face . vertIdx . add ( Integer . valueOf ( seg ) ) ; } } } faces . add ( face ) ; } } } if ( materials . size ( ) == 0 ) { OBJMaterial defMtl = new OBJMaterial ( ) ; materials . add ( defMtl ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } static protected void parseMTL ( PApplet parent , String path , BufferedReader reader , ArrayList < OBJMaterial > materials , Map < String , Integer > materialsHash ) { try { String line ; OBJMaterial currentMtl = null ; while ( ( line = reader . readLine ( ) ) != null ) { line = line . trim ( ) ; String parts [ ] = line . split ( "\\s+" ) ; if ( parts . length > 0 ) { if ( parts [ 0 ] . equals ( "newmtl" ) ) { String mtlname = parts [ 1 ] ; currentMtl = new OBJMaterial ( mtlname ) ; materialsHash . put ( mtlname , Integer . valueOf ( materials . size ( ) ) ) ; materials . add ( currentMtl ) ; } else if ( parts [ 0 ] . equals ( "map_Kd" ) && parts . length > 1 ) { String texname = parts [ 1 ] ; if ( texname . indexOf ( File . separator ) == - 1 && ! path . equals ( "" ) ) { texname = path + File . separator + texname ; } currentMtl . kdMap = parent . loadImage ( texname ) ; } else if ( parts [ 0 ] . equals ( "Ka" ) && parts . length > 3 ) { currentMtl . ka . x = Float . valueOf ( parts [ 1 ] ) . floatValue ( ) ; currentMtl . ka . y = Float . valueOf ( parts [ 2 ] ) . floatValue ( ) ; currentMtl . ka . z = Float . valueOf ( parts [ 3 ] ) . floatValue ( ) ; } else if ( parts [ 0 ] . equals ( "Kd" ) && parts . length > 3 ) { currentMtl . kd . x = Float . valueOf ( parts [ 1 ] ) . floatValue ( ) ; currentMtl . kd . y = Float . valueOf ( parts [ 2 ] ) . floatValue ( ) ; currentMtl . kd . z = Float . valueOf ( parts [ 3 ] ) . floatValue ( ) ; } else if ( parts [ 0 ] . equals ( "Ks" ) && parts . length > 3 ) { currentMtl . ks . x = Float . valueOf ( parts [ 1 ] ) . floatValue ( ) ; currentMtl . ks . y = Float . valueOf ( parts [ 2 ] ) . floatValue ( ) ; currentMtl . ks . z = Float . valueOf ( parts [ 3 ] ) . floatValue ( ) ; } else if ( ( parts [ 0 ] . equals ( "d" ) || parts [ 0 ] . equals ( "Tr" ) ) && parts . length > 1 ) { currentMtl . d = Float . valueOf ( parts [ 1 ] ) . floatValue ( ) ; } else if ( parts [ 0 ] . equals ( "Ns" ) && parts . length > 1 ) { currentMtl . ns = Float . valueOf ( parts [ 1 ] ) . floatValue ( ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } protected static int rgbaValue ( PVector color ) { return 0xFF000000 | ( ( int ) ( color . x * 255 ) < < 16 ) | ( ( int ) ( color . y * 255 ) < < 8 ) | ( int ) ( color . z * 255 ) ; } protected static int rgbaValue ( PVector color , float alpha ) { return ( ( int ) ( alpha * 255 ) < < 24 ) | ( ( int ) ( color . x * 255 ) < < 16 ) | ( ( int ) ( color . y * 255 ) < < 8 ) | ( int ) ( color . z * 255 ) ; } static protected class OBJFace { ArrayList < Integer > vertIdx ; ArrayList < Integer > texIdx ; ArrayList < Integer > normIdx ; int matIdx ; String name ; OBJFace ( ) { vertIdx = new ArrayList < Integer > ( ) ; texIdx = new ArrayList < Integer > ( ) ; normIdx = new ArrayList < Integer > ( ) ; matIdx = - 1 ; name = "" ; } } static protected String getBasePath ( PApplet parent , String filename ) { File file = new File ( parent . dataPath ( filename ) ) ; if ( ! file . exists ( ) ) { file = parent . sketchFile ( filename ) ; } String absolutePath = file . getAbsolutePath ( ) ; return absolutePath . substring ( 0 , absolutePath . lastIndexOf ( File . separator ) ) ; } static protected class OBJMaterial { String name ; PVector ka ; PVector kd ; PVector ks ; float d ; float ns ; PImage kdMap ; OBJMaterial ( ) { this ( "default" ) ; } OBJMaterial ( String name ) { this . name = name ; ka = new PVector ( 0.5f , 0.5f , 0.5f ) ; kd = new PVector ( 0.5f , 0.5f , 0.5f ) ; ks = new PVector ( 0.5f , 0.5f , 0.5f ) ; d = 1.0f ; ns = 0.0f ; kdMap = null ; } } }
package processing . app . contrib ; import java . io . File ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . net . URLClassLoader ; import java . util . * ; import processing . app . Base ; import processing . app . Mode ; public class ModeContribution extends LocalContribution { private Mode mode ; static public ModeContribution load ( Base base , File folder ) { return load ( base , folder , null ) ; } static public ModeContribution load ( Base base , File folder , String searchName ) { try { return new ModeContribution ( base , folder , searchName ) ; } catch ( IgnorableException ig ) { Base . log ( ig . getMessage ( ) ) ; } catch ( Throwable err ) { if ( searchName == null ) { throw new RuntimeException ( err ) ; } else { Base . loge ( "ModeContribution.load() failed for " + searchName , err ) ; } } return null ; } private ModeContribution ( Base base , File folder , String className ) throws Exception { super ( folder ) ; className = initLoader ( className ) ; if ( className != null ) { Class < ? > modeClass = loader . loadClass ( className ) ; Base . log ( "Got mode class " + modeClass ) ; Constructor con = modeClass . getConstructor ( Base . class , File . class ) ; mode = ( Mode ) con . newInstance ( base , folder ) ; mode . setClassLoader ( loader ) ; if ( base != null ) { mode . setupGUI ( ) ; } } } public void clearClassLoader ( Base base ) { List < ModeContribution > contribModes = base . getModeContribs ( ) ; int botherToRemove = contribModes . indexOf ( this ) ; if ( botherToRemove != - 1 ) { contribModes . remove ( botherToRemove ) ; try { ( ( URLClassLoader ) loader ) . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } static public void loadMissing ( Base base ) { File modesFolder = Base . getSketchbookModesFolder ( ) ; List < ModeContribution > contribModes = base . getModeContribs ( ) ; Map < File , ModeContribution > existing = new HashMap < File , ModeContribution > ( ) ; for ( ModeContribution contrib : contribModes ) { existing . put ( contrib . getFolder ( ) , contrib ) ; } File [ ] potential = ContributionType . MODE . listCandidates ( modesFolder ) ; if ( potential != null ) { for ( File folder : potential ) { if ( ! existing . containsKey ( folder ) ) { try { contribModes . add ( new ModeContribution ( base , folder , null ) ) ; } catch ( NoSuchMethodError nsme ) { System . err . println ( folder . getName ( ) + " contains an incompatible Mode" ) ; System . err . println ( nsme . getMessage ( ) ) ; } catch ( NoClassDefFoundError ncdfe ) { System . err . println ( folder . getName ( ) + " contains an incompatible Mode" ) ; System . err . println ( ncdfe . getMessage ( ) ) ; } catch ( IgnorableException ig ) { Base . log ( ig . getMessage ( ) ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } } } final String useMode = System . getProperty ( "usemode" ) ; if ( useMode != null ) { final String [ ] modeInfo = useMode . split ( ":" , 2 ) ; final String modeClass = modeInfo [ 0 ] ; final String modeResourcePath = modeInfo [ 1 ] ; System . out . println ( "Attempting to load " + modeClass + " with resources at " + modeResourcePath ) ; contribModes . add ( ModeContribution . load ( base , new File ( modeResourcePath ) , modeClass ) ) ; } } public Mode getMode ( ) { return mode ; } public ContributionType getType ( ) { return ContributionType . MODE ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ModeContribution ) ) { return false ; } ModeContribution other = ( ModeContribution ) o ; return loader . equals ( other . loader ) && mode . equals ( other . getMode ( ) ) ; } }
package processing . app . contrib ; interface ContributionFilter { boolean matches ( Contribution contrib ) ; }
package processing . app . contrib ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import processing . core . PApplet ; import processing . app . Language ; abstract public class Contribution { static final String SPECIAL_CATEGORY_NAME = "Starred" ; static final List validCategories = Arrays . asList ( "3D" , "Animation" , "Data" , "Geometry" , "GUI" , "Hardware" , "I/O" , "Math" , "Simulation" , "Sound" , SPECIAL_CATEGORY_NAME , "Typography" , "Utilities" , "Video & Vision" , "Other" ) ; protected List < String > categories ; protected String name ; protected String authorList ; protected String url ; protected String sentence ; protected String paragraph ; protected int version ; protected String prettyVersion ; protected long lastUpdated ; protected int minRevision ; protected int maxRevision ; protected List < String > specifiedImports ; protected List < String > getCategories ( ) { return categories ; } protected String getCategoryStr ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( String category : categories ) { sb . append ( category ) ; sb . append ( ',' ) ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; return sb . toString ( ) ; } protected boolean hasCategory ( String category ) { if ( category != null ) { for ( String c : categories ) { if ( category . equalsIgnoreCase ( c ) ) { return true ; } } } return false ; } protected List < String > getImports ( ) { return specifiedImports ; } protected String getImportStr ( ) { if ( specifiedImports == null || specifiedImports . isEmpty ( ) ) { return "" ; } StringBuilder sb = new StringBuilder ( ) ; for ( String importName : specifiedImports ) { sb . append ( importName ) ; sb . append ( ',' ) ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; return sb . toString ( ) ; } protected boolean hasImport ( String importName ) { if ( specifiedImports != null && importName != null ) { for ( String c : specifiedImports ) { if ( importName . equalsIgnoreCase ( c ) ) { return true ; } } } return false ; } public String getName ( ) { return name ; } public String getAuthorList ( ) { return authorList ; } public String getUrl ( ) { return url ; } public String getSentence ( ) { return sentence ; } public String getParagraph ( ) { return paragraph ; } public int getVersion ( ) { return version ; } public String getPrettyVersion ( ) { return prettyVersion ; } public long getLastUpdated ( ) { return lastUpdated ; } public int getMinRevision ( ) { return minRevision ; } public int getMaxRevision ( ) { return maxRevision ; } public boolean isCompatible ( int versionNum ) { return ( ( maxRevision == 0 || versionNum < maxRevision ) && versionNum > minRevision ) ; } abstract public ContributionType getType ( ) ; public String getTypeName ( ) { return getType ( ) . toString ( ) ; } abstract public boolean isInstalled ( ) ; boolean isRestartFlagged ( ) { return false ; } boolean isDeletionFlagged ( ) { return false ; } boolean isUpdateFlagged ( ) { return false ; } boolean isSpecial ( ) { try { return ( authorList . indexOf ( "The Processing Foundation" ) != - 1 || categories . contains ( SPECIAL_CATEGORY_NAME ) ) ; } catch ( NullPointerException npe ) { return false ; } } static List < String > defaultCategory ( ) { List < String > outgoing = new ArrayList < String > ( ) ; outgoing . add ( "Unknown" ) ; return outgoing ; } static List < String > parseCategories ( String categoryStr ) { List < String > outgoing = new ArrayList < String > ( ) ; if ( categoryStr != null ) { String [ ] listing = PApplet . trim ( PApplet . split ( categoryStr , ',' ) ) ; for ( String category : listing ) { if ( validCategories . contains ( category ) ) { category = translateCategory ( category ) ; outgoing . add ( category ) ; } } } if ( outgoing . size ( ) == 0 ) { return defaultCategory ( ) ; } return outgoing ; } static List < String > parseImports ( String importStr ) { List < String > outgoing = new ArrayList < String > ( ) ; if ( importStr != null ) { String [ ] importList = PApplet . trim ( PApplet . split ( importStr , ',' ) ) ; for ( String importName : importList ) { outgoing . add ( importName ) ; } } return ( outgoing . size ( ) > 0 ) ? outgoing : null ; } static private String translateCategory ( String cat ) { String cleaned = cat . replaceAll ( "[\\W]+" , "_" ) . toLowerCase ( ) ; return Language . text ( "contrib.category." + cleaned ) ; } }
package processing . app . contrib ; import java . awt . Color ; import javax . swing . JLabel ; class StatusPanel extends JLabel { public StatusPanel ( ) { super ( " " ) ; } void setMessage ( String message ) { setForeground ( Color . BLACK ) ; setText ( message ) ; repaint ( ) ; } void setErrorMessage ( String message ) { setForeground ( new Color ( 160 , 0 , 0 ) ) ; setText ( message ) ; repaint ( ) ; } void clear ( ) { setText ( "" ) ; repaint ( ) ; } }
package processing . app . contrib ; import java . io . * ; import java . util . List ; import java . util . Map ; import processing . app . Base ; import processing . app . Language ; import processing . core . PApplet ; public class AvailableContribution extends Contribution { protected final ContributionType type ; protected final String link ; public AvailableContribution ( ContributionType type , Map < String , String > params ) { this . type = type ; this . link = params . get ( "download" ) ; categories = parseCategories ( params . get ( "category" ) ) ; specifiedImports = parseImports ( params . get ( "imports" ) ) ; name = params . get ( "name" ) ; authorList = params . get ( "authorList" ) ; url = params . get ( "url" ) ; sentence = params . get ( "sentence" ) ; paragraph = params . get ( "paragraph" ) ; String versionStr = params . get ( "version" ) ; if ( versionStr != null ) { version = PApplet . parseInt ( versionStr , 0 ) ; } prettyVersion = params . get ( "prettyVersion" ) ; String lastUpdatedStr = params . get ( "lastUpdated" ) ; if ( lastUpdatedStr != null ) { try { lastUpdated = Long . parseLong ( lastUpdatedStr ) ; } catch ( NumberFormatException e ) { lastUpdated = 0 ; } } String minRev = params . get ( "minRevision" ) ; if ( minRev != null ) { minRevision = PApplet . parseInt ( minRev , 0 ) ; } String maxRev = params . get ( "maxRevision" ) ; if ( maxRev != null ) { maxRevision = PApplet . parseInt ( maxRev , 0 ) ; } } public LocalContribution install ( Base base , File contribArchive , boolean confirmReplace , StatusPanel status ) { File tempFolder = null ; try { tempFolder = type . createTempFolder ( ) ; } catch ( IOException e ) { if ( status != null ) status . setErrorMessage ( Language . text ( "contrib.errors.temporary_directory" ) ) ; return null ; } Base . unzip ( contribArchive , tempFolder ) ; File contribFolder = null ; if ( type . isCandidate ( tempFolder ) ) { if ( status != null ) { status . setErrorMessage ( Language . interpolate ( "contrib.errors.needs_repackage" , getName ( ) , type . getTitle ( ) ) ) ; } return null ; } contribFolder = type . findCandidate ( tempFolder ) ; LocalContribution installedContrib = null ; if ( contribFolder == null ) { if ( status != null ) { status . setErrorMessage ( Language . interpolate ( "contrib.errors.no_contribution_found" , type ) ) ; } } else { File propFile = new File ( contribFolder , type + ".properties" ) ; if ( writePropertiesFile ( propFile ) ) { LocalContribution newContrib = type . load ( base , contribFolder ) ; File newContribFolder = newContrib . getFolder ( ) ; installedContrib = newContrib . copyAndLoad ( base , confirmReplace , status ) ; if ( newContrib . getType ( ) == ContributionType . MODE ) { ( ( ModeContribution ) newContrib ) . clearClassLoader ( base ) ; } else if ( newContrib . getType ( ) == ContributionType . TOOL ) { ( ( ToolContribution ) newContrib ) . clearClassLoader ( base ) ; } newContrib = null ; System . gc ( ) ; if ( Base . isWindows ( ) ) { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } Base . removeDir ( newContribFolder ) ; } else { if ( status != null ) { status . setErrorMessage ( Language . text ( "contrib.errors.overwriting_properties" ) ) ; } } } if ( tempFolder . exists ( ) ) { Base . removeDir ( tempFolder ) ; } return installedContrib ; } public boolean isInstalled ( ) { return false ; } public ContributionType getType ( ) { return type ; } public boolean writePropertiesFile ( File propFile ) { try { Map < String , String > properties = Base . readSettings ( propFile ) ; String name = properties . get ( "name" ) ; if ( name == null || name . isEmpty ( ) ) name = getName ( ) ; String category ; List < String > categoryList = parseCategories ( properties . get ( "category" ) ) ; if ( categoryList . size ( ) == 1 && categoryList . get ( 0 ) . equals ( "Unknown" ) ) { category = getCategoryStr ( ) ; } else { StringBuilder sb = new StringBuilder ( ) ; for ( String cat : categories ) { sb . append ( cat ) ; sb . append ( ',' ) ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; category = sb . toString ( ) ; } String specifiedImport = "" ; List < String > importsList = parseImports ( properties . get ( "imports" ) ) ; if ( importsList == null || importsList . isEmpty ( ) ) { specifiedImport = getImportStr ( ) ; } else { StringBuilder sbImport = new StringBuilder ( ) ; for ( String it : specifiedImports ) { sbImport . append ( it ) ; sbImport . append ( ',' ) ; } sbImport . deleteCharAt ( sbImport . length ( ) - 1 ) ; specifiedImport = sbImport . toString ( ) ; } String authorList = properties . get ( "authorList" ) ; if ( authorList == null || authorList . isEmpty ( ) ) { authorList = getAuthorList ( ) ; } String url = properties . get ( "url" ) ; if ( url == null || url . isEmpty ( ) ) { url = getUrl ( ) ; } String sentence = properties . get ( "sentence" ) ; if ( sentence == null || sentence . isEmpty ( ) ) { sentence = getSentence ( ) ; } String paragraph = properties . get ( "paragraph" ) ; if ( paragraph == null || paragraph . isEmpty ( ) ) { paragraph = getParagraph ( ) ; } int version ; try { version = Integer . parseInt ( properties . get ( "version" ) ) ; } catch ( NumberFormatException e ) { version = getVersion ( ) ; System . err . println ( "The version number for the " + name + " contribution is not set properly." ) ; System . err . println ( "Please contact the author to fix it according to the guidelines." ) ; } String prettyVersion = properties . get ( "prettyVersion" ) ; if ( prettyVersion == null || prettyVersion . isEmpty ( ) ) prettyVersion = getPrettyVersion ( ) ; String compatibleContribsList = null ; if ( getType ( ) == ContributionType . EXAMPLES ) { compatibleContribsList = properties . get ( "compatibleModesList" ) ; } long lastUpdated ; try { lastUpdated = Long . parseLong ( properties . get ( "lastUpdated" ) ) ; } catch ( NumberFormatException nfe ) { lastUpdated = getLastUpdated ( ) ; } int minRev ; try { minRev = Integer . parseInt ( properties . get ( "minRevision" ) ) ; } catch ( NumberFormatException e ) { minRev = getMinRevision ( ) ; } int maxRev ; try { maxRev = Integer . parseInt ( properties . get ( "maxRevision" ) ) ; } catch ( NumberFormatException e ) { maxRev = getMaxRevision ( ) ; } if ( propFile . delete ( ) && propFile . createNewFile ( ) && propFile . setWritable ( true ) ) { PrintWriter writer = PApplet . createWriter ( propFile ) ; writer . println ( "name=" + name ) ; writer . println ( "category=" + category ) ; writer . println ( "authorList=" + authorList ) ; writer . println ( "url=" + url ) ; writer . println ( "sentence=" + sentence ) ; writer . println ( "paragraph=" + paragraph ) ; writer . println ( "version=" + version ) ; writer . println ( "prettyVersion=" + prettyVersion ) ; writer . println ( "lastUpdated=" + lastUpdated ) ; writer . println ( "minRevision=" + minRev ) ; writer . println ( "maxRevision=" + maxRev ) ; if ( getType ( ) == ContributionType . LIBRARY ) { writer . println ( "imports=" + specifiedImport ) ; } if ( getType ( ) == ContributionType . EXAMPLES ) { writer . println ( "compatibleModesList=" + compatibleContribsList ) ; } writer . flush ( ) ; writer . close ( ) ; } return true ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return false ; } }
package processing . app . contrib ; import javax . swing . JProgressBar ; abstract class ContribProgressBar extends ContribProgressMonitor { JProgressBar progressBar ; public ContribProgressBar ( JProgressBar progressBar ) { this . progressBar = progressBar ; } public void startTask ( String name , int maxValue ) { finished = false ; progressBar . setString ( name ) ; progressBar . setIndeterminate ( maxValue == UNKNOWN ) ; progressBar . setMaximum ( maxValue ) ; } public void setProgress ( int value ) { super . setProgress ( value ) ; progressBar . setValue ( value ) ; } @ Override public void finished ( ) { super . finished ( ) ; finishedAction ( ) ; } public abstract void finishedAction ( ) ; }
package processing . app . contrib ; import java . awt . BorderLayout ; import java . awt . Color ; import java . awt . Container ; import java . awt . Dimension ; import java . awt . Font ; import java . awt . event . * ; import java . io . File ; import java . io . IOException ; import java . lang . management . ManagementFactory ; import java . net . SocketTimeoutException ; import java . util . * ; import javax . swing . * ; import javax . swing . border . EmptyBorder ; import javax . swing . event . * ; import processing . app . * ; public class ContributionManagerDialog { static final String ANY_CATEGORY = Language . text ( "contrib.all" ) ; JFrame dialog ; String title ; ContributionFilter filter ; JComboBox < String > categoryChooser ; JScrollPane scrollPane ; ContributionListPanel contributionListPanel ; StatusPanel status ; FilterField filterField ; JButton restartButton ; JButton retryConnectingButton ; JProgressBar progressBar ; Editor editor ; String category ; String compatibleCheckboxLabel ; boolean isCompatibilityFilter ; ContributionListing contribListing ; public ContributionManagerDialog ( ContributionType type ) { if ( type == null ) { title = Language . text ( "contrib.manager_title.update" ) ; filter = ContributionType . createUpdateFilter ( ) ; compatibleCheckboxLabel = Language . text ( "contrib.show_only_compatible.update" ) ; } else { if ( type == ContributionType . MODE ) { title = Language . text ( "contrib.manager_title.mode" ) ; compatibleCheckboxLabel = Language . text ( "contrib.show_only_compatible.mode" ) ; } else if ( type == ContributionType . TOOL ) { title = Language . text ( "contrib.manager_title.tool" ) ; compatibleCheckboxLabel = Language . text ( "contrib.show_only_compatible.tool" ) ; } else if ( type == ContributionType . LIBRARY ) { title = Language . text ( "contrib.manager_title.library" ) ; compatibleCheckboxLabel = Language . text ( "contrib.show_only_compatible.library" ) ; } else if ( type == ContributionType . EXAMPLES ) { title = Language . text ( "contrib.manager_title.examples" ) ; compatibleCheckboxLabel = Language . text ( "contrib.show_only_compatible.examples" ) ; } filter = type . createFilter ( ) ; } contribListing = ContributionListing . getInstance ( ) ; contributionListPanel = new ContributionListPanel ( this , filter ) ; contribListing . addContributionListener ( contributionListPanel ) ; } public boolean hasUpdates ( ) { return contribListing . hasUpdates ( ) ; } public boolean hasUpdates ( Base base ) { return contribListing . hasUpdates ( base ) ; } public void showFrame ( final Editor editor ) { this . editor = editor ; if ( dialog == null ) { dialog = new JFrame ( title ) ; restartButton = new JButton ( Language . text ( "contrib.restart" ) ) ; restartButton . setVisible ( false ) ; restartButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { Iterator < Editor > iter = editor . getBase ( ) . getEditors ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Editor ed = iter . next ( ) ; if ( ed . getSketch ( ) . isModified ( ) ) { int option = Base . showYesNoQuestion ( editor , title , Language . text ( "contrib.unsaved_changes" ) , Language . text ( "contrib.unsaved_changes.prompt" ) ) ; if ( option == JOptionPane . NO_OPTION ) return ; else break ; } } StringBuilder cmd = new StringBuilder ( ) ; cmd . append ( System . getProperty ( "java.home" ) + File . separator + "bin" + File . separator + "java " ) ; for ( String jvmArg : ManagementFactory . getRuntimeMXBean ( ) . getInputArguments ( ) ) { cmd . append ( jvmArg + " " ) ; } cmd . append ( "-cp " ) . append ( ManagementFactory . getRuntimeMXBean ( ) . getClassPath ( ) ) . append ( " " ) ; cmd . append ( Base . class . getName ( ) ) ; try { Runtime . getRuntime ( ) . exec ( cmd . toString ( ) ) ; System . exit ( 0 ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } ) ; retryConnectingButton = new JButton ( "Retry" ) ; retryConnectingButton . setVisible ( false ) ; retryConnectingButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { status . setMessage ( null ) ; downloadAndUpdateContributionListing ( ) ; } } ) ; progressBar = new JProgressBar ( ) ; progressBar . setVisible ( true ) ; Toolkit . setIcon ( dialog ) ; createComponents ( ) ; registerDisposeListeners ( ) ; dialog . pack ( ) ; dialog . setLocationRelativeTo ( null ) ; } dialog . setVisible ( true ) ; contributionListPanel . grabFocus ( ) ; if ( contribListing . hasDownloadedLatestList ( ) ) { updateContributionListing ( ) ; } else { downloadAndUpdateContributionListing ( ) ; } } protected void disposeFrame ( ) { status . clear ( ) ; dialog . dispose ( ) ; editor = null ; } private void createComponents ( ) { dialog . setResizable ( true ) ; Container pane = dialog . getContentPane ( ) ; pane . setLayout ( new BorderLayout ( ) ) ; JPanel filterPanel = new JPanel ( ) ; filterPanel . setLayout ( new BoxLayout ( filterPanel , BoxLayout . X_AXIS ) ) ; pane . add ( filterPanel , BorderLayout . NORTH ) ; filterPanel . add ( Box . createHorizontalStrut ( 6 ) ) ; JLabel categoryLabel = new JLabel ( Language . text ( "contrib.category" ) ) ; filterPanel . add ( categoryLabel ) ; filterPanel . add ( Box . createHorizontalStrut ( 5 ) ) ; categoryChooser = new JComboBox < String > ( ) ; categoryChooser . setMaximumRowCount ( 20 ) ; updateCategoryChooser ( ) ; filterPanel . add ( categoryChooser ) ; categoryChooser . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent e ) { category = ( String ) categoryChooser . getSelectedItem ( ) ; if ( ContributionManagerDialog . ANY_CATEGORY . equals ( category ) ) { category = null ; } filterLibraries ( category , filterField . filters , isCompatibilityFilter ) ; contributionListPanel . updateColors ( ) ; } } ) ; filterPanel . add ( Box . createHorizontalStrut ( 5 ) ) ; filterField = new FilterField ( ) ; filterPanel . add ( filterField ) ; filterPanel . add ( Box . createHorizontalStrut ( 5 ) ) ; final JCheckBox compatibleContrib = new JCheckBox ( compatibleCheckboxLabel ) ; compatibleContrib . addItemListener ( new ItemListener ( ) { @ Override public void itemStateChanged ( ItemEvent arg0 ) { isCompatibilityFilter = compatibleContrib . isSelected ( ) ; filterLibraries ( category , filterField . filters , isCompatibilityFilter ) ; contributionListPanel . updateColors ( ) ; } } ) ; filterPanel . add ( compatibleContrib ) ; filterPanel . setBorder ( new EmptyBorder ( 7 , 7 , 7 , 7 ) ) ; scrollPane = new JScrollPane ( ) ; scrollPane . setPreferredSize ( new Dimension ( 300 , 300 ) ) ; scrollPane . setViewportView ( contributionListPanel ) ; scrollPane . setVerticalScrollBarPolicy ( ScrollPaneConstants . VERTICAL_SCROLLBAR_AS_NEEDED ) ; scrollPane . setHorizontalScrollBarPolicy ( ScrollPaneConstants . HORIZONTAL_SCROLLBAR_NEVER ) ; pane . add ( scrollPane , BorderLayout . CENTER ) ; pane . add ( Box . createHorizontalStrut ( 10 ) , BorderLayout . WEST ) ; pane . add ( Box . createHorizontalStrut ( 10 ) , BorderLayout . EAST ) ; status = new StatusPanel ( ) ; JPanel statusRestartPane = new JPanel ( ) ; statusRestartPane . setLayout ( new BorderLayout ( ) ) ; statusRestartPane . setBorder ( new EmptyBorder ( 7 , 7 , 7 , 7 ) ) ; statusRestartPane . setOpaque ( false ) ; statusRestartPane . add ( status , BorderLayout . WEST ) ; statusRestartPane . add ( progressBar , BorderLayout . LINE_END ) ; statusRestartPane . add ( restartButton , BorderLayout . EAST ) ; statusRestartPane . add ( retryConnectingButton , BorderLayout . EAST ) ; pane . add ( statusRestartPane , BorderLayout . SOUTH ) ; dialog . setMinimumSize ( new Dimension ( 450 , 400 ) ) ; } private void updateCategoryChooser ( ) { if ( categoryChooser != null ) { ArrayList < String > categories ; categoryChooser . removeAllItems ( ) ; categories = new ArrayList < String > ( contribListing . getCategories ( filter ) ) ; Collections . sort ( categories ) ; boolean categoriesFound = false ; categoryChooser . addItem ( ContributionManagerDialog . ANY_CATEGORY ) ; for ( String s : categories ) { categoryChooser . addItem ( s ) ; if ( ! s . equals ( "Unknown" ) ) { categoriesFound = true ; } } categoryChooser . setEnabled ( categoriesFound ) ; } } private void registerDisposeListeners ( ) { dialog . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { disposeFrame ( ) ; } } ) ; Toolkit . registerWindowCloseKeys ( dialog . getRootPane ( ) , new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { disposeFrame ( ) ; } } ) ; dialog . getContentPane ( ) . addKeyListener ( new KeyAdapter ( ) { public void keyPressed ( KeyEvent e ) { KeyStroke wc = Toolkit . WINDOW_CLOSE_KEYSTROKE ; if ( ( e . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) || ( KeyStroke . getKeyStrokeForEvent ( e ) . equals ( wc ) ) ) { disposeFrame ( ) ; } } } ) ; } protected void filterLibraries ( String category , List < String > filters ) { List < Contribution > filteredLibraries = contribListing . getFilteredLibraryList ( category , filters ) ; contributionListPanel . filterLibraries ( filteredLibraries ) ; } protected void filterLibraries ( String category , List < String > filters , boolean isCompatibilityFilter ) { List < Contribution > filteredLibraries = contribListing . getFilteredLibraryList ( category , filters ) ; filteredLibraries = contribListing . getCompatibleContributionList ( filteredLibraries , isCompatibilityFilter ) ; contributionListPanel . filterLibraries ( filteredLibraries ) ; } protected void updateContributionListing ( ) { if ( editor != null ) { ArrayList < Contribution > contributions = new ArrayList < Contribution > ( ) ; ArrayList < Library > libraries = new ArrayList < Library > ( editor . getMode ( ) . contribLibraries ) ; contributions . addAll ( libraries ) ; List < ToolContribution > tools = editor . getToolContribs ( ) ; contributions . addAll ( tools ) ; List < ModeContribution > modes = editor . getBase ( ) . getModeContribs ( ) ; contributions . addAll ( modes ) ; List < ExamplesContribution > examples = editor . getBase ( ) . getExampleContribs ( ) ; contributions . addAll ( examples ) ; contribListing . updateInstalledList ( contributions ) ; } } protected void downloadAndUpdateContributionListing ( ) { retryConnectingButton . setEnabled ( false ) ; status . setMessage ( Language . text ( "contrib.status.downloading_list" ) ) ; contribListing . downloadAvailableList ( new ContribProgressBar ( progressBar ) { @ Override public void startTask ( String name , int maxValue ) { super . startTask ( name , maxValue ) ; progressBar . setString ( null ) ; } @ Override public void setProgress ( int value ) { super . setProgress ( value ) ; progressBar . setValue ( value ) ; progressBar . setStringPainted ( true ) ; status . setMessage ( Language . text ( "contrib.status.downloading_list" ) ) ; } @ Override public void finishedAction ( ) { progressBar . setVisible ( false ) ; updateContributionListing ( ) ; updateCategoryChooser ( ) ; retryConnectingButton . setEnabled ( true ) ; if ( error ) { if ( exception instanceof SocketTimeoutException ) { status . setErrorMessage ( Language . text ( "contrib.errors.list_download.timeout" ) ) ; } else { status . setErrorMessage ( Language . text ( "contrib.errors.list_download" ) ) ; } exception . printStackTrace ( ) ; retryConnectingButton . setVisible ( true ) ; } else { status . setMessage ( Language . text ( "contrib.status.done" ) ) ; retryConnectingButton . setVisible ( false ) ; } } } ) ; } protected void setFilterText ( String filter ) { if ( filter == null || filter . isEmpty ( ) ) { filterField . setText ( "" ) ; filterField . showingHint = true ; } else { filterField . setText ( filter ) ; filterField . showingHint = false ; } filterField . applyFilter ( ) ; } class FilterField extends JTextField { String filterHint ; boolean showingHint ; List < String > filters ; public FilterField ( ) { super ( Language . text ( "contrib.filter_your_search" ) ) ; filterHint = Language . text ( "contrib.filter_your_search" ) ; showingHint = true ; filters = new ArrayList < String > ( ) ; updateStyle ( ) ; addFocusListener ( new FocusListener ( ) { public void focusLost ( FocusEvent focusEvent ) { if ( filterField . getText ( ) . isEmpty ( ) ) { showingHint = true ; } updateStyle ( ) ; } public void focusGained ( FocusEvent focusEvent ) { if ( showingHint ) { showingHint = false ; filterField . setText ( "" ) ; } updateStyle ( ) ; } } ) ; getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { public void removeUpdate ( DocumentEvent e ) { applyFilter ( ) ; } public void insertUpdate ( DocumentEvent e ) { applyFilter ( ) ; } public void changedUpdate ( DocumentEvent e ) { applyFilter ( ) ; } } ) ; } public void applyFilter ( ) { String filter = filterField . getFilterText ( ) ; filter = filter . toLowerCase ( ) ; filter = filter . replaceAll ( "[^\\x30-\\x39^\\x61-\\x7a^\\x3a]" , " " ) ; filters = Arrays . asList ( filter . split ( " " ) ) ; filterLibraries ( category , filters , isCompatibilityFilter ) ; contributionListPanel . updateColors ( ) ; } public String getFilterText ( ) { return showingHint ? "" : getText ( ) ; } public void updateStyle ( ) { if ( showingHint ) { setText ( filterHint ) ; setForeground ( Color . gray ) ; setFont ( getFont ( ) . deriveFont ( Font . ITALIC ) ) ; } else { setForeground ( UIManager . getColor ( "TextField.foreground" ) ) ; setFont ( getFont ( ) . deriveFont ( Font . PLAIN ) ) ; } } } public boolean hasAlreadyBeenOpened ( ) { return dialog != null ; } }
package processing . app . contrib ; import java . io . * ; import java . net . URLClassLoader ; import java . util . * ; import processing . app . Base ; import processing . app . Editor ; import processing . app . tools . Tool ; public class ToolContribution extends LocalContribution implements Tool { private Tool tool ; private File referenceFile ; static public ToolContribution load ( File folder ) { try { return new ToolContribution ( folder ) ; } catch ( IgnorableException ig ) { Base . log ( ig . getMessage ( ) ) ; } catch ( VerifyError ve ) { } catch ( Throwable e ) { e . printStackTrace ( ) ; } return null ; } private ToolContribution ( File folder ) throws Throwable { super ( folder ) ; String className = initLoader ( null ) ; if ( className != null ) { Class < ? > toolClass = loader . loadClass ( className ) ; tool = ( Tool ) toolClass . newInstance ( ) ; } referenceFile = new File ( folder , "reference/index.html" ) ; } public void clearClassLoader ( Base base ) { try { ( ( URLClassLoader ) this . loader ) . close ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } Iterator < Editor > editorIter = base . getEditors ( ) . iterator ( ) ; while ( editorIter . hasNext ( ) ) { Editor editor = editorIter . next ( ) ; List < ToolContribution > contribTools = editor . getToolContribs ( ) ; for ( ToolContribution toolContrib : contribTools ) if ( toolContrib . getName ( ) . equals ( this . name ) ) { try { ( ( URLClassLoader ) toolContrib . loader ) . close ( ) ; editor . removeToolContrib ( toolContrib ) ; break ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } static public ArrayList < ToolContribution > loadAll ( File toolsFolder ) { File [ ] list = ContributionType . TOOL . listCandidates ( toolsFolder ) ; ArrayList < ToolContribution > outgoing = new ArrayList < ToolContribution > ( ) ; if ( list != null ) { for ( File folder : list ) { try { ToolContribution tc = load ( folder ) ; if ( tc != null ) { outgoing . add ( tc ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } return outgoing ; } public void init ( Editor editor ) { tool . init ( editor ) ; } public void run ( ) { tool . run ( ) ; } public String getMenuTitle ( ) { return tool . getMenuTitle ( ) ; } public ContributionType getType ( ) { return ContributionType . TOOL ; } public File getReferenceIndexFile ( ) { return referenceFile ; } public boolean hasReference ( ) { return referenceFile . exists ( ) ; } }
package test . processing . mode . java ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import processing . app . Base ; import processing . app . Platform ; import processing . app . exec . ProcessHelper ; import processing . app . exec . ProcessResult ; class UTCompiler { private final String classpath ; UTCompiler ( File ... classpath ) throws IOException { final StringBuilder sb = new StringBuilder ( ) ; for ( final File f : classpath ) { if ( sb . length ( ) > 0 ) sb . append ( File . pathSeparatorChar ) ; sb . append ( f . getAbsolutePath ( ) ) ; } this . classpath = sb . toString ( ) ; final Platform p = Base . getPlatform ( ) ; final String javaHomeProp = System . getProperty ( "java.home" ) ; if ( javaHomeProp == null ) { throw new RuntimeException ( "I don't know how to deal with a null java.home proprty, to be quite frank." ) ; } final File javaHome = new File ( javaHomeProp ) . getCanonicalFile ( ) ; p . setenv ( "JAVA_HOME" , javaHome . getCanonicalPath ( ) ) ; final String path = new File ( javaHome , "bin" ) . getCanonicalPath ( ) + File . pathSeparator + p . getenv ( "PATH" ) ; p . setenv ( "PATH" , path ) ; } ProcessResult compile ( final String name , final String program ) throws IOException { final File tmpdir = File . createTempFile ( "utcompiler" , ".tmp" ) ; if ( ! tmpdir . delete ( ) ) throw new IOException ( "Cannot delete " + tmpdir ) ; if ( ! tmpdir . mkdir ( ) ) throw new IOException ( "Cannot create " + tmpdir ) ; final File javaFile = new File ( tmpdir , name + ".java" ) ; final FileWriter java = new FileWriter ( javaFile ) ; try { java . write ( program ) ; } finally { java . close ( ) ; } try { return new ProcessHelper ( "javac" , "-sourcepath" , tmpdir . getAbsolutePath ( ) , "-cp" , classpath , "-nowarn" , "-d" , tmpdir . getAbsolutePath ( ) , javaFile . getAbsolutePath ( ) ) . execute ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } finally { for ( final File f : tmpdir . listFiles ( ) ) if ( ! f . getName ( ) . startsWith ( "." ) ) if ( ! f . delete ( ) ) throw new IOException ( "Can't delete " + f ) ; if ( ! tmpdir . delete ( ) ) throw new IOException ( "Can't delete " + tmpdir ) ; } } }
package test . processing . mode . java ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . StringWriter ; import antlr . ANTLRException ; import processing . app . Base ; import processing . app . Preferences ; import processing . app . SketchException ; import processing . mode . java . preproc . PdePreprocessor ; import processing . mode . java . AutoFormat ; public class ProcessingTestUtil { static void init ( ) { } private static final String RESOURCES = "test/resources/" ; static final UTCompiler COMPILER ; static { try { Base . initPlatform ( ) ; COMPILER = new UTCompiler ( new File ( "bin" ) , new File ( "../core/bin" ) ) ; Preferences . load ( new FileInputStream ( res ( "preferences.txt" ) ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } static String normalize ( final Object s ) { return String . valueOf ( s ) . replace ( "\r" , "" ) ; } static String preprocess ( final String name , final File resource ) throws SketchException , ANTLRException { final String program = read ( resource ) ; final StringWriter out = new StringWriter ( ) ; new PdePreprocessor ( name , 4 ) . write ( out , program ) ; return normalize ( out ) ; } static String format ( final File resource ) { return format ( read ( resource ) ) ; } static String format ( final String programText ) { return normalize ( new AutoFormat ( ) . format ( programText ) ) ; } static File res ( final String resourceName ) { return new File ( RESOURCES , resourceName ) ; } static String read ( final File f ) { try { final FileInputStream fin = new FileInputStream ( f ) ; final InputStreamReader in = new InputStreamReader ( fin , "UTF-8" ) ; try { final StringBuilder sb = new StringBuilder ( ) ; final char [ ] buf = new char [ 1 < < 12 ] ; int len ; while ( ( len = in . read ( buf ) ) != - 1 ) sb . append ( buf , 0 , len ) ; return normalize ( sb ) ; } finally { in . close ( ) ; } } catch ( Exception e ) { throw new RuntimeException ( "Unexpected" , e ) ; } } }
package processing . core ; import java . util . HashMap ; import java . util . Map ; import processing . core . PApplet ; public class PShape implements PConstants { protected String name ; protected Map < String , PShape > nameTable ; static public final int PRIMITIVE = 1 ; static public final int PATH = 2 ; static public final int GEOMETRY = 3 ; protected int family ; protected int kind ; protected PMatrix matrix ; protected int textureMode ; protected PImage image ; public static final String OUTSIDE_BEGIN_END_ERROR = "%1$s can only be called between beginShape() and endShape()" ; public static final String INSIDE_BEGIN_END_ERROR = "%1$s can only be called outside beginShape() and endShape()" ; public static final String NO_SUCH_VERTEX_ERROR = "%1$s vertex index does not exist" ; static public final String NO_VERTICES_ERROR = "getVertexCount() only works with PATH or GEOMETRY shapes" ; public float width ; public float height ; public float depth ; PGraphics g ; protected boolean visible = true ; protected boolean openShape = false ; protected boolean openContour = false ; protected boolean stroke ; protected int strokeColor ; protected float strokeWeight ; protected int strokeCap ; protected int strokeJoin ; protected boolean fill ; protected int fillColor ; protected boolean tint ; protected int tintColor ; protected int ambientColor ; protected boolean setAmbient ; protected int specularColor ; protected int emissiveColor ; protected float shininess ; protected int sphereDetailU , sphereDetailV ; protected int rectMode ; protected int ellipseMode ; protected boolean style = true ; protected float [ ] params ; protected int vertexCount ; protected float [ ] [ ] vertices ; protected PShape parent ; protected int childCount ; protected PShape [ ] children ; protected int vertexCodeCount ; protected int [ ] vertexCodes ; protected boolean close ; protected float calcR , calcG , calcB , calcA ; protected int calcRi , calcGi , calcBi , calcAi ; protected int calcColor ; protected boolean calcAlpha ; public int colorMode ; public float colorModeX ; public float colorModeY ; public float colorModeZ ; public float colorModeA ; boolean colorModeScale ; boolean colorModeDefault ; protected boolean is3D = false ; public PShape ( ) { this . family = GROUP ; } public PShape ( int family ) { this . family = family ; } public PShape ( PGraphics g , int family ) { this . g = g ; this . family = family ; textureMode = g . textureMode ; colorMode ( g . colorMode , g . colorModeX , g . colorModeY , g . colorModeZ , g . colorModeA ) ; fill = g . fill ; fillColor = g . fillColor ; stroke = g . stroke ; strokeColor = g . strokeColor ; strokeWeight = g . strokeWeight ; strokeCap = g . strokeCap ; strokeJoin = g . strokeJoin ; tint = g . tint ; tintColor = g . tintColor ; setAmbient = g . setAmbient ; ambientColor = g . ambientColor ; specularColor = g . specularColor ; emissiveColor = g . emissiveColor ; shininess = g . shininess ; sphereDetailU = g . sphereDetailU ; sphereDetailV = g . sphereDetailV ; rectMode = CORNER ; ellipseMode = CORNER ; if ( family == GROUP ) { } } public PShape ( PGraphics g , int kind , float ... params ) { this ( g , PRIMITIVE ) ; setKind ( kind ) ; setParams ( params ) ; } public void setFamily ( int family ) { this . family = family ; } public void setKind ( int kind ) { this . kind = kind ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public boolean isVisible ( ) { return visible ; } public void setVisible ( boolean visible ) { this . visible = visible ; } public void disableStyle ( ) { style = false ; for ( int i = 0 ; i < childCount ; i ++ ) { children [ i ] . disableStyle ( ) ; } } public void enableStyle ( ) { style = true ; for ( int i = 0 ; i < childCount ; i ++ ) { children [ i ] . enableStyle ( ) ; } } public float getWidth ( ) { return width ; } public float getHeight ( ) { return height ; } public float getDepth ( ) { return depth ; } public boolean is2D ( ) { return ! is3D ; } public boolean is3D ( ) { return is3D ; } public void set3D ( boolean val ) { is3D = val ; } public void textureMode ( int mode ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "textureMode()" ) ; return ; } textureMode = mode ; } public void texture ( PImage tex ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "texture()" ) ; return ; } image = tex ; } public void noTexture ( ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "noTexture()" ) ; return ; } image = null ; } protected void solid ( boolean solid ) { } public void beginContour ( ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "beginContour()" ) ; return ; } if ( family == GROUP ) { PGraphics . showWarning ( "Cannot begin contour in GROUP shapes" ) ; return ; } if ( openContour ) { PGraphics . showWarning ( "Already called beginContour()." ) ; return ; } openContour = true ; beginContourImpl ( ) ; } protected void beginContourImpl ( ) { if ( vertexCodes == null ) { vertexCodes = new int [ 10 ] ; } else if ( vertexCodes . length == vertexCodeCount ) { vertexCodes = PApplet . expand ( vertexCodes ) ; } vertexCodes [ vertexCodeCount ++ ] = BREAK ; } public void endContour ( ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "endContour()" ) ; return ; } if ( family == GROUP ) { PGraphics . showWarning ( "Cannot end contour in GROUP shapes" ) ; return ; } if ( ! openContour ) { PGraphics . showWarning ( "Need to call beginContour() first." ) ; return ; } endContourImpl ( ) ; openContour = false ; } protected void endContourImpl ( ) { } public void vertex ( float x , float y ) { if ( vertices == null ) { vertices = new float [ 10 ] [ 2 ] ; } else if ( vertices . length == vertexCount ) { vertices = ( float [ ] [ ] ) PApplet . expand ( vertices ) ; } vertices [ vertexCount ++ ] = new float [ ] { x , y } ; if ( vertexCodes == null ) { vertexCodes = new int [ 10 ] ; } else if ( vertexCodes . length == vertexCodeCount ) { vertexCodes = PApplet . expand ( vertexCodes ) ; } vertexCodes [ vertexCodeCount ++ ] = VERTEX ; if ( x > width ) { width = x ; } if ( y > height ) { height = y ; } } public void vertex ( float x , float y , float u , float v ) { } public void vertex ( float x , float y , float z ) { vertex ( x , y ) ; } public void vertex ( float x , float y , float z , float u , float v ) { } public void normal ( float nx , float ny , float nz ) { } public void attrib ( String name , float ... values ) { } public void attrib ( String name , int ... values ) { } public void attrib ( String name , boolean ... values ) { } public void beginShape ( ) { beginShape ( POLYGON ) ; } public void beginShape ( int kind ) { this . kind = kind ; openShape = true ; } public void endShape ( ) { endShape ( OPEN ) ; } public void endShape ( int mode ) { if ( family == GROUP ) { PGraphics . showWarning ( "Cannot end GROUP shape" ) ; return ; } if ( ! openShape ) { PGraphics . showWarning ( "Need to call beginShape() first" ) ; return ; } close = ( mode == CLOSE ) ; openShape = false ; } public void strokeWeight ( float weight ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "strokeWeight()" ) ; return ; } strokeWeight = weight ; } public void strokeJoin ( int join ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "strokeJoin()" ) ; return ; } strokeJoin = join ; } public void strokeCap ( int cap ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "strokeCap()" ) ; return ; } strokeCap = cap ; } public void noFill ( ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "noFill()" ) ; return ; } fill = false ; fillColor = 0x0 ; if ( ! setAmbient ) { ambientColor = fillColor ; } } public void fill ( int rgb ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "fill()" ) ; return ; } fill = true ; colorCalc ( rgb ) ; fillColor = calcColor ; if ( ! setAmbient ) { ambientColor = fillColor ; } } public void fill ( int rgb , float alpha ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "fill()" ) ; return ; } fill = true ; colorCalc ( rgb , alpha ) ; fillColor = calcColor ; if ( ! setAmbient ) { ambientColor = fillColor ; } } public void fill ( float gray ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "fill()" ) ; return ; } fill = true ; colorCalc ( gray ) ; fillColor = calcColor ; if ( ! setAmbient ) { ambientColor = fillColor ; } } public void fill ( float gray , float alpha ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "fill()" ) ; return ; } fill = true ; colorCalc ( gray , alpha ) ; fillColor = calcColor ; if ( ! setAmbient ) { ambient ( fillColor ) ; setAmbient = false ; } if ( ! setAmbient ) { ambientColor = fillColor ; } } public void fill ( float x , float y , float z ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "fill()" ) ; return ; } fill = true ; colorCalc ( x , y , z ) ; fillColor = calcColor ; if ( ! setAmbient ) { ambientColor = fillColor ; } } public void fill ( float x , float y , float z , float a ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "fill()" ) ; return ; } fill = true ; colorCalc ( x , y , z , a ) ; fillColor = calcColor ; if ( ! setAmbient ) { ambientColor = fillColor ; } } public void noStroke ( ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "noStroke()" ) ; return ; } stroke = false ; } public void stroke ( int rgb ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "stroke()" ) ; return ; } stroke = true ; colorCalc ( rgb ) ; strokeColor = calcColor ; } public void stroke ( int rgb , float alpha ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "stroke()" ) ; return ; } stroke = true ; colorCalc ( rgb , alpha ) ; strokeColor = calcColor ; } public void stroke ( float gray ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "stroke()" ) ; return ; } stroke = true ; colorCalc ( gray ) ; strokeColor = calcColor ; } public void stroke ( float gray , float alpha ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "stroke()" ) ; return ; } stroke = true ; colorCalc ( gray , alpha ) ; strokeColor = calcColor ; } public void stroke ( float x , float y , float z ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "stroke()" ) ; return ; } stroke = true ; colorCalc ( x , y , z ) ; strokeColor = calcColor ; } public void stroke ( float x , float y , float z , float alpha ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "stroke()" ) ; return ; } stroke = true ; colorCalc ( x , y , z , alpha ) ; strokeColor = calcColor ; } public void noTint ( ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "noTint()" ) ; return ; } tint = false ; } public void tint ( int rgb ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "tint()" ) ; return ; } tint = true ; colorCalc ( rgb ) ; tintColor = calcColor ; } public void tint ( int rgb , float alpha ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "tint()" ) ; return ; } tint = true ; colorCalc ( rgb , alpha ) ; tintColor = calcColor ; } public void tint ( float gray ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "tint()" ) ; return ; } tint = true ; colorCalc ( gray ) ; tintColor = calcColor ; } public void tint ( float gray , float alpha ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "tint()" ) ; return ; } tint = true ; colorCalc ( gray , alpha ) ; tintColor = calcColor ; } public void tint ( float x , float y , float z ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "tint()" ) ; return ; } tint = true ; colorCalc ( x , y , z ) ; tintColor = calcColor ; } public void tint ( float x , float y , float z , float alpha ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "tint()" ) ; return ; } tint = true ; colorCalc ( x , y , z , alpha ) ; tintColor = calcColor ; } public void ambient ( int rgb ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "ambient()" ) ; return ; } setAmbient = true ; colorCalc ( rgb ) ; ambientColor = calcColor ; } public void ambient ( float gray ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "ambient()" ) ; return ; } setAmbient = true ; colorCalc ( gray ) ; ambientColor = calcColor ; } public void ambient ( float x , float y , float z ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "ambient()" ) ; return ; } setAmbient = true ; colorCalc ( x , y , z ) ; ambientColor = calcColor ; } public void specular ( int rgb ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "specular()" ) ; return ; } colorCalc ( rgb ) ; specularColor = calcColor ; } public void specular ( float gray ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "specular()" ) ; return ; } colorCalc ( gray ) ; specularColor = calcColor ; } public void specular ( float x , float y , float z ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "specular()" ) ; return ; } colorCalc ( x , y , z ) ; specularColor = calcColor ; } public void emissive ( int rgb ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "emissive()" ) ; return ; } colorCalc ( rgb ) ; emissiveColor = calcColor ; } public void emissive ( float gray ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "emissive()" ) ; return ; } colorCalc ( gray ) ; emissiveColor = calcColor ; } public void emissive ( float x , float y , float z ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "emissive()" ) ; return ; } colorCalc ( x , y , z ) ; emissiveColor = calcColor ; } public void shininess ( float shine ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "shininess()" ) ; return ; } shininess = shine ; } public void bezierDetail ( int detail ) { } public void bezierVertex ( float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { if ( vertices == null ) { vertices = new float [ 10 ] [ ] ; } else if ( vertexCount + 2 >= vertices . length ) { vertices = ( float [ ] [ ] ) PApplet . expand ( vertices ) ; } vertices [ vertexCount ++ ] = new float [ ] { x2 , y2 } ; vertices [ vertexCount ++ ] = new float [ ] { x3 , y3 } ; vertices [ vertexCount ++ ] = new float [ ] { x4 , y4 } ; if ( vertexCodes . length == vertexCodeCount ) { vertexCodes = PApplet . expand ( vertexCodes ) ; } vertexCodes [ vertexCodeCount ++ ] = BEZIER_VERTEX ; if ( x4 > width ) { width = x4 ; } if ( y4 > height ) { height = y4 ; } } public void bezierVertex ( float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { } public void quadraticVertex ( float cx , float cy , float x3 , float y3 ) { if ( vertices == null ) { vertices = new float [ 10 ] [ ] ; } else if ( vertexCount + 1 >= vertices . length ) { vertices = ( float [ ] [ ] ) PApplet . expand ( vertices ) ; } vertices [ vertexCount ++ ] = new float [ ] { cx , cy } ; vertices [ vertexCount ++ ] = new float [ ] { x3 , y3 } ; if ( vertexCodes . length == vertexCodeCount ) { vertexCodes = PApplet . expand ( vertexCodes ) ; } vertexCodes [ vertexCodeCount ++ ] = QUADRATIC_VERTEX ; if ( x3 > width ) { width = x3 ; } if ( y3 > height ) { height = y3 ; } } public void quadraticVertex ( float cx , float cy , float cz , float x3 , float y3 , float z3 ) { } public void curveDetail ( int detail ) { } public void curveTightness ( float tightness ) { } public void curveVertex ( float x , float y ) { } public void curveVertex ( float x , float y , float z ) { } protected void pre ( PGraphics g ) { if ( matrix != null ) { g . pushMatrix ( ) ; g . applyMatrix ( matrix ) ; } if ( style ) { g . pushStyle ( ) ; styles ( g ) ; } } protected void styles ( PGraphics g ) { if ( stroke ) { g . stroke ( strokeColor ) ; g . strokeWeight ( strokeWeight ) ; g . strokeCap ( strokeCap ) ; g . strokeJoin ( strokeJoin ) ; } else { g . noStroke ( ) ; } if ( fill ) { g . fill ( fillColor ) ; } else { g . noFill ( ) ; } } protected void post ( PGraphics g ) { if ( matrix != null ) { g . popMatrix ( ) ; } if ( style ) { g . popStyle ( ) ; } } static protected PShape createShape ( PApplet parent , PShape src ) { PShape dest = null ; if ( src . family == GROUP ) { dest = parent . createShape ( GROUP ) ; PShape . copyGroup ( parent , src , dest ) ; } else if ( src . family == PRIMITIVE ) { dest = parent . createShape ( src . kind , src . params ) ; PShape . copyPrimitive ( src , dest ) ; } else if ( src . family == GEOMETRY ) { dest = parent . createShape ( src . kind ) ; PShape . copyGeometry ( src , dest ) ; } else if ( src . family == PATH ) { dest = parent . createShape ( PATH ) ; PShape . copyPath ( src , dest ) ; } dest . setName ( src . name ) ; return dest ; } static protected void copyGroup ( PApplet parent , PShape src , PShape dest ) { copyMatrix ( src , dest ) ; copyStyles ( src , dest ) ; copyImage ( src , dest ) ; for ( int i = 0 ; i < src . childCount ; i ++ ) { PShape c = PShape . createShape ( parent , src . children [ i ] ) ; dest . addChild ( c ) ; } } static protected void copyPrimitive ( PShape src , PShape dest ) { copyMatrix ( src , dest ) ; copyStyles ( src , dest ) ; copyImage ( src , dest ) ; } static protected void copyGeometry ( PShape src , PShape dest ) { dest . beginShape ( src . getKind ( ) ) ; copyMatrix ( src , dest ) ; copyStyles ( src , dest ) ; copyImage ( src , dest ) ; if ( src . style ) { for ( int i = 0 ; i < src . vertexCount ; i ++ ) { float [ ] vert = src . vertices [ i ] ; dest . fill ( ( int ) ( vert [ PGraphics . A ] * 255 ) < < 24 | ( int ) ( vert [ PGraphics . R ] * 255 ) < < 16 | ( int ) ( vert [ PGraphics . G ] * 255 ) < < 8 | ( int ) ( vert [ PGraphics . B ] * 255 ) ) ; if ( 0 < PApplet . dist ( vert [ PGraphics . NX ] , vert [ PGraphics . NY ] , vert [ PGraphics . NZ ] , 0 , 0 , 0 ) ) { dest . normal ( vert [ PGraphics . NX ] , vert [ PGraphics . NY ] , vert [ PGraphics . NZ ] ) ; } dest . vertex ( vert [ X ] , vert [ Y ] , vert [ Z ] , vert [ PGraphics . U ] , vert [ PGraphics . V ] ) ; } } else { for ( int i = 0 ; i < src . vertexCount ; i ++ ) { float [ ] vert = src . vertices [ i ] ; if ( vert [ Z ] == 0 ) { dest . vertex ( vert [ X ] , vert [ Y ] ) ; } else { dest . vertex ( vert [ X ] , vert [ Y ] , vert [ Z ] ) ; } } } dest . endShape ( ) ; } static protected void copyPath ( PShape src , PShape dest ) { copyMatrix ( src , dest ) ; copyStyles ( src , dest ) ; copyImage ( src , dest ) ; dest . close = src . close ; dest . setPath ( src . vertexCount , src . vertices , src . vertexCodeCount , src . vertexCodes ) ; } static protected void copyMatrix ( PShape src , PShape dest ) { if ( src . matrix != null ) { dest . applyMatrix ( src . matrix ) ; } } static protected void copyStyles ( PShape src , PShape dest ) { if ( src . stroke ) { dest . stroke = true ; dest . strokeColor = src . strokeColor ; dest . strokeWeight = src . strokeWeight ; dest . strokeCap = src . strokeCap ; dest . strokeJoin = src . strokeJoin ; } else { dest . stroke = false ; } if ( src . fill ) { dest . fill = true ; dest . fillColor = src . fillColor ; } else { dest . fill = false ; } } static protected void copyImage ( PShape src , PShape dest ) { if ( src . image != null ) { dest . texture ( src . image ) ; } } public void draw ( PGraphics g ) { if ( visible ) { pre ( g ) ; drawImpl ( g ) ; post ( g ) ; } } protected void drawImpl ( PGraphics g ) { if ( family == GROUP ) { drawGroup ( g ) ; } else if ( family == PRIMITIVE ) { drawPrimitive ( g ) ; } else if ( family == GEOMETRY ) { drawPath ( g ) ; } else if ( family == PATH ) { drawPath ( g ) ; } } protected void drawGroup ( PGraphics g ) { for ( int i = 0 ; i < childCount ; i ++ ) { children [ i ] . draw ( g ) ; } } protected void drawPrimitive ( PGraphics g ) { if ( kind == POINT ) { g . point ( params [ 0 ] , params [ 1 ] ) ; } else if ( kind == LINE ) { if ( params . length == 4 ) { g . line ( params [ 0 ] , params [ 1 ] , params [ 2 ] , params [ 3 ] ) ; } else { g . line ( params [ 0 ] , params [ 1 ] , params [ 2 ] , params [ 3 ] , params [ 4 ] , params [ 5 ] ) ; } } else if ( kind == TRIANGLE ) { g . triangle ( params [ 0 ] , params [ 1 ] , params [ 2 ] , params [ 3 ] , params [ 4 ] , params [ 5 ] ) ; } else if ( kind == QUAD ) { g . quad ( params [ 0 ] , params [ 1 ] , params [ 2 ] , params [ 3 ] , params [ 4 ] , params [ 5 ] , params [ 6 ] , params [ 7 ] ) ; } else if ( kind == RECT ) { if ( image != null ) { g . imageMode ( CORNER ) ; g . image ( image , params [ 0 ] , params [ 1 ] , params [ 2 ] , params [ 3 ] ) ; } else { if ( params . length != 5 ) { g . rectMode ( CORNER ) ; } else { g . rectMode ( ( int ) params [ 4 ] ) ; } g . rect ( params [ 0 ] , params [ 1 ] , params [ 2 ] , params [ 3 ] ) ; } } else if ( kind == ELLIPSE ) { g . ellipseMode ( CORNER ) ; g . ellipse ( params [ 0 ] , params [ 1 ] , params [ 2 ] , params [ 3 ] ) ; } else if ( kind == ARC ) { g . ellipseMode ( CORNER ) ; g . arc ( params [ 0 ] , params [ 1 ] , params [ 2 ] , params [ 3 ] , params [ 4 ] , params [ 5 ] ) ; } else if ( kind == BOX ) { if ( params . length == 1 ) { g . box ( params [ 0 ] ) ; } else { g . box ( params [ 0 ] , params [ 1 ] , params [ 2 ] ) ; } } else if ( kind == SPHERE ) { g . sphere ( params [ 0 ] ) ; } } protected void drawGeometry ( PGraphics g ) { g . beginShape ( kind ) ; if ( style ) { for ( int i = 0 ; i < vertexCount ; i ++ ) { g . vertex ( vertices [ i ] ) ; } } else { for ( int i = 0 ; i < vertexCount ; i ++ ) { float [ ] vert = vertices [ i ] ; if ( vert [ Z ] == 0 ) { g . vertex ( vert [ X ] , vert [ Y ] ) ; } else { g . vertex ( vert [ X ] , vert [ Y ] , vert [ Z ] ) ; } } } g . endShape ( close ? CLOSE : OPEN ) ; } protected void drawPath ( PGraphics g ) { if ( vertices == null ) return ; boolean insideContour = false ; g . beginShape ( ) ; if ( vertexCodeCount == 0 ) { if ( vertices [ 0 ] . length == 2 ) { for ( int i = 0 ; i < vertexCount ; i ++ ) { g . vertex ( vertices [ i ] [ X ] , vertices [ i ] [ Y ] ) ; } } else { for ( int i = 0 ; i < vertexCount ; i ++ ) { g . vertex ( vertices [ i ] [ X ] , vertices [ i ] [ Y ] , vertices [ i ] [ Z ] ) ; } } } else { int index = 0 ; if ( vertices [ 0 ] . length == 2 ) { for ( int j = 0 ; j < vertexCodeCount ; j ++ ) { switch ( vertexCodes [ j ] ) { case VERTEX : g . vertex ( vertices [ index ] [ X ] , vertices [ index ] [ Y ] ) ; index ++ ; break ; case QUADRATIC_VERTEX : g . quadraticVertex ( vertices [ index + 0 ] [ X ] , vertices [ index + 0 ] [ Y ] , vertices [ index + 1 ] [ X ] , vertices [ index + 1 ] [ Y ] ) ; index += 2 ; break ; case BEZIER_VERTEX : g . bezierVertex ( vertices [ index + 0 ] [ X ] , vertices [ index + 0 ] [ Y ] , vertices [ index + 1 ] [ X ] , vertices [ index + 1 ] [ Y ] , vertices [ index + 2 ] [ X ] , vertices [ index + 2 ] [ Y ] ) ; index += 3 ; break ; case CURVE_VERTEX : g . curveVertex ( vertices [ index ] [ X ] , vertices [ index ] [ Y ] ) ; index ++ ; break ; case BREAK : if ( insideContour ) { g . endContour ( ) ; } g . beginContour ( ) ; insideContour = true ; } } } else { for ( int j = 0 ; j < vertexCodeCount ; j ++ ) { switch ( vertexCodes [ j ] ) { case VERTEX : g . vertex ( vertices [ index ] [ X ] , vertices [ index ] [ Y ] , vertices [ index ] [ Z ] ) ; index ++ ; break ; case QUADRATIC_VERTEX : g . quadraticVertex ( vertices [ index + 0 ] [ X ] , vertices [ index + 0 ] [ Y ] , vertices [ index + 0 ] [ Z ] , vertices [ index + 1 ] [ X ] , vertices [ index + 1 ] [ Y ] , vertices [ index + 0 ] [ Z ] ) ; index += 2 ; break ; case BEZIER_VERTEX : g . bezierVertex ( vertices [ index + 0 ] [ X ] , vertices [ index + 0 ] [ Y ] , vertices [ index + 0 ] [ Z ] , vertices [ index + 1 ] [ X ] , vertices [ index + 1 ] [ Y ] , vertices [ index + 1 ] [ Z ] , vertices [ index + 2 ] [ X ] , vertices [ index + 2 ] [ Y ] , vertices [ index + 2 ] [ Z ] ) ; index += 3 ; break ; case CURVE_VERTEX : g . curveVertex ( vertices [ index ] [ X ] , vertices [ index ] [ Y ] , vertices [ index ] [ Z ] ) ; index ++ ; break ; case BREAK : if ( insideContour ) { g . endContour ( ) ; } g . beginContour ( ) ; insideContour = true ; } } } } if ( insideContour ) { g . endContour ( ) ; } g . endShape ( close ? CLOSE : OPEN ) ; } public PShape getParent ( ) { return parent ; } public int getChildCount ( ) { return childCount ; } protected void crop ( ) { if ( children . length != childCount ) { children = ( PShape [ ] ) PApplet . subset ( children , 0 , childCount ) ; } } public PShape [ ] getChildren ( ) { crop ( ) ; return children ; } public PShape getChild ( int index ) { crop ( ) ; return children [ index ] ; } public PShape getChild ( String target ) { if ( name != null && name . equals ( target ) ) { return this ; } if ( nameTable != null ) { PShape found = nameTable . get ( target ) ; if ( found != null ) return found ; } for ( int i = 0 ; i < childCount ; i ++ ) { PShape found = children [ i ] . getChild ( target ) ; if ( found != null ) return found ; } return null ; } public PShape findChild ( String target ) { if ( parent == null ) { return getChild ( target ) ; } else { return parent . findChild ( target ) ; } } public void addChild ( PShape who ) { if ( children == null ) { children = new PShape [ 1 ] ; } if ( childCount == children . length ) { children = ( PShape [ ] ) PApplet . expand ( children ) ; } children [ childCount ++ ] = who ; who . parent = this ; if ( who . getName ( ) != null ) { addName ( who . getName ( ) , who ) ; } } public void addChild ( PShape who , int idx ) { if ( idx < childCount ) { if ( childCount == children . length ) { children = ( PShape [ ] ) PApplet . expand ( children ) ; } for ( int i = childCount - 1 ; i >= idx ; i -- ) { children [ i + 1 ] = children [ i ] ; } childCount ++ ; children [ idx ] = who ; who . parent = this ; if ( who . getName ( ) != null ) { addName ( who . getName ( ) , who ) ; } } } public void removeChild ( int idx ) { if ( idx < childCount ) { PShape child = children [ idx ] ; for ( int i = idx ; i < childCount - 1 ; i ++ ) { children [ i ] = children [ i + 1 ] ; } childCount -- ; if ( child . getName ( ) != null && nameTable != null ) { nameTable . remove ( child . getName ( ) ) ; } } } public void addName ( String nom , PShape shape ) { if ( parent != null ) { parent . addName ( nom , shape ) ; } else { if ( nameTable == null ) { nameTable = new HashMap < String , PShape > ( ) ; } nameTable . put ( nom , shape ) ; } } public int getChildIndex ( PShape who ) { for ( int i = 0 ; i < childCount ; i ++ ) { if ( children [ i ] == who ) { return i ; } } return - 1 ; } public PShape getTessellation ( ) { return null ; } public int getFamily ( ) { return family ; } public int getKind ( ) { return kind ; } public float [ ] getParams ( ) { return getParams ( null ) ; } public float [ ] getParams ( float [ ] target ) { if ( target == null || target . length != params . length ) { target = new float [ params . length ] ; } PApplet . arrayCopy ( params , target ) ; return target ; } public float getParam ( int index ) { return params [ index ] ; } protected void setParams ( float [ ] source ) { if ( params == null ) { params = new float [ source . length ] ; } if ( source . length != params . length ) { PGraphics . showWarning ( "Wrong number of parameters" ) ; return ; } PApplet . arrayCopy ( source , params ) ; } public void setPath ( int vcount , float [ ] [ ] verts ) { setPath ( vcount , verts , 0 , null ) ; } protected void setPath ( int vcount , float [ ] [ ] verts , int ccount , int [ ] codes ) { if ( verts == null || verts . length < vcount ) return ; if ( 0 < ccount && ( codes == null || codes . length < ccount ) ) return ; int ndim = verts [ 0 ] . length ; vertexCount = vcount ; vertices = new float [ vertexCount ] [ ndim ] ; for ( int i = 0 ; i < vertexCount ; i ++ ) { PApplet . arrayCopy ( verts [ i ] , vertices [ i ] ) ; } vertexCodeCount = ccount ; if ( 0 < vertexCodeCount ) { vertexCodes = new int [ vertexCodeCount ] ; PApplet . arrayCopy ( codes , vertexCodes , vertexCodeCount ) ; } } public int getVertexCount ( ) { if ( family == GROUP || family == PRIMITIVE ) { PGraphics . showWarning ( NO_VERTICES_ERROR ) ; } return vertexCount ; } public PVector getVertex ( int index ) { return getVertex ( index , null ) ; } public PVector getVertex ( int index , PVector vec ) { if ( vec == null ) { vec = new PVector ( ) ; } float [ ] vert = vertices [ index ] ; vec . x = vert [ X ] ; vec . y = vert [ Y ] ; if ( vert . length > 2 ) { vec . z = vert [ Z ] ; } else { vec . z = 0 ; } return vec ; } public float getVertexX ( int index ) { return vertices [ index ] [ X ] ; } public float getVertexY ( int index ) { return vertices [ index ] [ Y ] ; } public float getVertexZ ( int index ) { return vertices [ index ] [ Z ] ; } public void setVertex ( int index , float x , float y ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setVertex()" ) ; return ; } vertices [ index ] [ X ] = x ; vertices [ index ] [ Y ] = y ; } public void setVertex ( int index , float x , float y , float z ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setVertex()" ) ; return ; } vertices [ index ] [ X ] = x ; vertices [ index ] [ Y ] = y ; vertices [ index ] [ Z ] = z ; } public void setVertex ( int index , PVector vec ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setVertex()" ) ; return ; } vertices [ index ] [ X ] = vec . x ; vertices [ index ] [ Y ] = vec . y ; if ( vertices [ index ] . length > 2 ) { vertices [ index ] [ Z ] = vec . z ; } else if ( vec . z != 0 && vec . z == vec . z ) { throw new IllegalArgumentException ( "Cannot set a z-coordinate on a 2D shape" ) ; } } public PVector getNormal ( int index ) { return getNormal ( index , null ) ; } public PVector getNormal ( int index , PVector vec ) { if ( vec == null ) { vec = new PVector ( ) ; } vec . x = vertices [ index ] [ PGraphics . NX ] ; vec . y = vertices [ index ] [ PGraphics . NY ] ; vec . z = vertices [ index ] [ PGraphics . NZ ] ; return vec ; } public float getNormalX ( int index ) { return vertices [ index ] [ PGraphics . NX ] ; } public float getNormalY ( int index ) { return vertices [ index ] [ PGraphics . NY ] ; } public float getNormalZ ( int index ) { return vertices [ index ] [ PGraphics . NZ ] ; } public void setNormal ( int index , float nx , float ny , float nz ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setNormal()" ) ; return ; } vertices [ index ] [ PGraphics . NX ] = nx ; vertices [ index ] [ PGraphics . NY ] = ny ; vertices [ index ] [ PGraphics . NZ ] = nz ; } public void setAttrib ( String name , int index , float ... values ) { } public void setAttrib ( String name , int index , int ... values ) { } public void setAttrib ( String name , int index , boolean ... values ) { } public float getTextureU ( int index ) { return vertices [ index ] [ PGraphics . U ] ; } public float getTextureV ( int index ) { return vertices [ index ] [ PGraphics . V ] ; } public void setTextureUV ( int index , float u , float v ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setTextureUV()" ) ; return ; } if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "setTextureUV()" ) ; return ; } vertices [ index ] [ PGraphics . U ] = u ; vertices [ index ] [ PGraphics . V ] = v ; } public void setTextureMode ( int mode ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setTextureMode()" ) ; return ; } textureMode = mode ; } public void setTexture ( PImage tex ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setTexture()" ) ; return ; } image = tex ; } public int getFill ( int index ) { if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "getFill()" ) ; return fillColor ; } if ( image == null ) { int a = ( int ) ( vertices [ index ] [ PGraphics . A ] * 255 ) ; int r = ( int ) ( vertices [ index ] [ PGraphics . R ] * 255 ) ; int g = ( int ) ( vertices [ index ] [ PGraphics . G ] * 255 ) ; int b = ( int ) ( vertices [ index ] [ PGraphics . B ] * 255 ) ; return ( a < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ; } else { return 0 ; } } public void setFill ( boolean fill ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setFill()" ) ; return ; } this . fill = fill ; } public void setFill ( int fill ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setFill()" ) ; return ; } this . fillColor = fill ; if ( vertices != null ) { for ( int i = 0 ; i < vertices . length ; i ++ ) { setFill ( i , fill ) ; } } } public void setFill ( int index , int fill ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setFill()" ) ; return ; } if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "getFill()" ) ; return ; } if ( image == null ) { vertices [ index ] [ PGraphics . A ] = ( ( fill > > 24 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . R ] = ( ( fill > > 16 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . G ] = ( ( fill > > 8 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . B ] = ( ( fill > > 0 ) & 0xFF ) / 255.0f ; } } public int getTint ( int index ) { if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "getTint()" ) ; return this . tintColor ; } if ( image != null ) { int a = ( int ) ( vertices [ index ] [ PGraphics . A ] * 255 ) ; int r = ( int ) ( vertices [ index ] [ PGraphics . R ] * 255 ) ; int g = ( int ) ( vertices [ index ] [ PGraphics . G ] * 255 ) ; int b = ( int ) ( vertices [ index ] [ PGraphics . B ] * 255 ) ; return ( a < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ; } else { return 0 ; } } public void setTint ( boolean tint ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setTint()" ) ; return ; } this . tint = tint ; } public void setTint ( int fill ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setTint()" ) ; return ; } tintColor = fill ; if ( vertices != null ) { for ( int i = 0 ; i < vertices . length ; i ++ ) { setFill ( i , fill ) ; } } } public void setTint ( int index , int tint ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setTint()" ) ; return ; } if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "setTint()" ) ; return ; } if ( image != null ) { vertices [ index ] [ PGraphics . A ] = ( ( tint > > 24 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . R ] = ( ( tint > > 16 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . G ] = ( ( tint > > 8 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . B ] = ( ( tint > > 0 ) & 0xFF ) / 255.0f ; } } public int getStroke ( int index ) { if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "getStroke()" ) ; return strokeColor ; } int a = ( int ) ( vertices [ index ] [ PGraphics . SA ] * 255 ) ; int r = ( int ) ( vertices [ index ] [ PGraphics . SR ] * 255 ) ; int g = ( int ) ( vertices [ index ] [ PGraphics . SG ] * 255 ) ; int b = ( int ) ( vertices [ index ] [ PGraphics . SB ] * 255 ) ; return ( a < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ; } public void setStroke ( boolean stroke ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStroke()" ) ; return ; } this . stroke = stroke ; } public void setStroke ( int stroke ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStroke()" ) ; return ; } strokeColor = stroke ; if ( vertices != null ) { for ( int i = 0 ; i < vertices . length ; i ++ ) { setStroke ( i , stroke ) ; } } } public void setStroke ( int index , int stroke ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStroke()" ) ; return ; } if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "setStroke()" ) ; return ; } vertices [ index ] [ PGraphics . SA ] = ( ( stroke > > 24 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . SR ] = ( ( stroke > > 16 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . SG ] = ( ( stroke > > 8 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . SB ] = ( ( stroke > > 0 ) & 0xFF ) / 255.0f ; } public float getStrokeWeight ( int index ) { if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "getStrokeWeight()" ) ; return strokeWeight ; } return vertices [ index ] [ PGraphics . SW ] ; } public void setStrokeWeight ( float weight ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStrokeWeight()" ) ; return ; } strokeWeight = weight ; if ( vertices != null ) { for ( int i = 0 ; i < vertices . length ; i ++ ) { setStrokeWeight ( i , weight ) ; } } } public void setStrokeWeight ( int index , float weight ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStrokeWeight()" ) ; return ; } if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "setStrokeWeight()" ) ; return ; } vertices [ index ] [ PGraphics . SW ] = weight ; } public void setStrokeJoin ( int join ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStrokeJoin()" ) ; return ; } strokeJoin = join ; } public void setStrokeCap ( int cap ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStrokeCap()" ) ; return ; } strokeCap = cap ; } public int getAmbient ( int index ) { if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "getAmbient()" ) ; return ambientColor ; } int r = ( int ) ( vertices [ index ] [ PGraphics . AR ] * 255 ) ; int g = ( int ) ( vertices [ index ] [ PGraphics . AG ] * 255 ) ; int b = ( int ) ( vertices [ index ] [ PGraphics . AB ] * 255 ) ; return 0xff000000 | ( r < < 16 ) | ( g < < 8 ) | b ; } public void setAmbient ( int ambient ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setAmbient()" ) ; return ; } ambientColor = ambient ; if ( vertices != null ) { for ( int i = 0 ; i < vertices . length ; i ++ ) { setAmbient ( i , ambient ) ; } } } public void setAmbient ( int index , int ambient ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setAmbient()" ) ; return ; } if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "setAmbient()" ) ; return ; } vertices [ index ] [ PGraphics . AR ] = ( ( ambient > > 16 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . AG ] = ( ( ambient > > 8 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . AB ] = ( ( ambient > > 0 ) & 0xFF ) / 255.0f ; } public int getSpecular ( int index ) { if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "getSpecular()" ) ; return specularColor ; } int r = ( int ) ( vertices [ index ] [ PGraphics . SPR ] * 255 ) ; int g = ( int ) ( vertices [ index ] [ PGraphics . SPG ] * 255 ) ; int b = ( int ) ( vertices [ index ] [ PGraphics . SPB ] * 255 ) ; return 0xff000000 | ( r < < 16 ) | ( g < < 8 ) | b ; } public void setSpecular ( int specular ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setSpecular()" ) ; return ; } specularColor = specular ; if ( vertices != null ) { for ( int i = 0 ; i < vertices . length ; i ++ ) { setSpecular ( i , specular ) ; } } } public void setSpecular ( int index , int specular ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setSpecular()" ) ; return ; } if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "setSpecular()" ) ; return ; } vertices [ index ] [ PGraphics . SPR ] = ( ( specular > > 16 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . SPG ] = ( ( specular > > 8 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . SPB ] = ( ( specular > > 0 ) & 0xFF ) / 255.0f ; } public int getEmissive ( int index ) { if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "getEmissive()" ) ; return emissiveColor ; } int r = ( int ) ( vertices [ index ] [ PGraphics . ER ] * 255 ) ; int g = ( int ) ( vertices [ index ] [ PGraphics . EG ] * 255 ) ; int b = ( int ) ( vertices [ index ] [ PGraphics . EB ] * 255 ) ; return 0xff000000 | ( r < < 16 ) | ( g < < 8 ) | b ; } public void setEmissive ( int emissive ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setEmissive()" ) ; return ; } emissiveColor = emissive ; if ( vertices != null ) { for ( int i = 0 ; i < vertices . length ; i ++ ) { setEmissive ( i , emissive ) ; } } } public void setEmissive ( int index , int emissive ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setEmissive()" ) ; return ; } if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "setEmissive()" ) ; return ; } vertices [ index ] [ PGraphics . ER ] = ( ( emissive > > 16 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . EG ] = ( ( emissive > > 8 ) & 0xFF ) / 255.0f ; vertices [ index ] [ PGraphics . EB ] = ( ( emissive > > 0 ) & 0xFF ) / 255.0f ; } public float getShininess ( int index ) { if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "getShininess()" ) ; return shininess ; } return vertices [ index ] [ PGraphics . SHINE ] ; } public void setShininess ( float shine ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setShininess()" ) ; return ; } shininess = shine ; if ( vertices != null ) { for ( int i = 0 ; i < vertices . length ; i ++ ) { setShininess ( i , shine ) ; } } } public void setShininess ( int index , float shine ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setShininess()" ) ; return ; } if ( vertices == null || index >= vertices . length ) { PGraphics . showWarning ( NO_SUCH_VERTEX_ERROR + " (" + index + ")" , "setShininess()" ) ; return ; } vertices [ index ] [ PGraphics . SHINE ] = shine ; } public int [ ] getVertexCodes ( ) { if ( vertexCodes == null ) { return null ; } if ( vertexCodes . length != vertexCodeCount ) { vertexCodes = PApplet . subset ( vertexCodes , 0 , vertexCodeCount ) ; } return vertexCodes ; } public int getVertexCodeCount ( ) { return vertexCodeCount ; } public int getVertexCode ( int index ) { return vertexCodes [ index ] ; } public boolean isClosed ( ) { return close ; } public boolean contains ( float x , float y ) { if ( family == PATH ) { boolean c = false ; for ( int i = 0 , j = vertexCount - 1 ; i < vertexCount ; j = i ++ ) { if ( ( ( vertices [ i ] [ Y ] > y ) != ( vertices [ j ] [ Y ] > y ) ) && ( x < ( vertices [ j ] [ X ] - vertices [ i ] [ X ] ) * ( y - vertices [ i ] [ Y ] ) / ( vertices [ j ] [ 1 ] - vertices [ i ] [ Y ] ) + vertices [ i ] [ X ] ) ) { c = ! c ; } } return c ; } else { throw new IllegalArgumentException ( "The contains() method is only implemented for paths." ) ; } } public void translate ( float x , float y ) { checkMatrix ( 2 ) ; matrix . translate ( x , y ) ; } public void translate ( float x , float y , float z ) { checkMatrix ( 3 ) ; matrix . translate ( x , y , z ) ; } public void rotateX ( float angle ) { rotate ( angle , 1 , 0 , 0 ) ; } public void rotateY ( float angle ) { rotate ( angle , 0 , 1 , 0 ) ; } public void rotateZ ( float angle ) { rotate ( angle , 0 , 0 , 1 ) ; } public void rotate ( float angle ) { checkMatrix ( 2 ) ; matrix . rotate ( angle ) ; } public void rotate ( float angle , float v0 , float v1 , float v2 ) { checkMatrix ( 3 ) ; float norm2 = v0 * v0 + v1 * v1 + v2 * v2 ; if ( Math . abs ( norm2 - 1 ) > EPSILON ) { float norm = PApplet . sqrt ( norm2 ) ; v0 /= norm ; v1 /= norm ; v2 /= norm ; } matrix . rotate ( angle , v0 , v1 , v2 ) ; } public void scale ( float s ) { checkMatrix ( 2 ) ; matrix . scale ( s ) ; } public void scale ( float x , float y ) { checkMatrix ( 2 ) ; matrix . scale ( x , y ) ; } public void scale ( float x , float y , float z ) { checkMatrix ( 3 ) ; matrix . scale ( x , y , z ) ; } public void resetMatrix ( ) { checkMatrix ( 2 ) ; matrix . reset ( ) ; } public void applyMatrix ( PMatrix source ) { if ( source instanceof PMatrix2D ) { applyMatrix ( ( PMatrix2D ) source ) ; } else if ( source instanceof PMatrix3D ) { applyMatrix ( ( PMatrix3D ) source ) ; } } public void applyMatrix ( PMatrix2D source ) { applyMatrix ( source . m00 , source . m01 , 0 , source . m02 , source . m10 , source . m11 , 0 , source . m12 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } public void applyMatrix ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) { checkMatrix ( 2 ) ; matrix . apply ( n00 , n01 , n02 , n10 , n11 , n12 ) ; } public void applyMatrix ( PMatrix3D source ) { applyMatrix ( source . m00 , source . m01 , source . m02 , source . m03 , source . m10 , source . m11 , source . m12 , source . m13 , source . m20 , source . m21 , source . m22 , source . m23 , source . m30 , source . m31 , source . m32 , source . m33 ) ; } public void applyMatrix ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { checkMatrix ( 3 ) ; matrix . apply ( n00 , n01 , n02 , n03 , n10 , n11 , n12 , n13 , n20 , n21 , n22 , n23 , n30 , n31 , n32 , n33 ) ; } protected void checkMatrix ( int dimensions ) { if ( matrix == null ) { if ( dimensions == 2 ) { matrix = new PMatrix2D ( ) ; } else { matrix = new PMatrix3D ( ) ; } } else if ( dimensions == 3 && ( matrix instanceof PMatrix2D ) ) { matrix = new PMatrix3D ( matrix ) ; } } public void colorMode ( int mode ) { colorMode ( mode , colorModeX , colorModeY , colorModeZ , colorModeA ) ; } public void colorMode ( int mode , float max ) { colorMode ( mode , max , max , max , max ) ; } public void colorMode ( int mode , float maxX , float maxY , float maxZ ) { colorMode ( mode , maxX , maxY , maxZ , colorModeA ) ; } public void colorMode ( int mode , float maxX , float maxY , float maxZ , float maxA ) { colorMode = mode ; colorModeX = maxX ; colorModeY = maxY ; colorModeZ = maxZ ; colorModeA = maxA ; colorModeScale = ( ( maxA != 1 ) || ( maxX != maxY ) || ( maxY != maxZ ) || ( maxZ != maxA ) ) ; colorModeDefault = ( colorMode == RGB ) && ( colorModeA == 255 ) && ( colorModeX == 255 ) && ( colorModeY == 255 ) && ( colorModeZ == 255 ) ; } protected void colorCalc ( int rgb ) { if ( ( ( rgb & 0xff000000 ) == 0 ) && ( rgb <= colorModeX ) ) { colorCalc ( ( float ) rgb ) ; } else { colorCalcARGB ( rgb , colorModeA ) ; } } protected void colorCalc ( int rgb , float alpha ) { if ( ( ( rgb & 0xff000000 ) == 0 ) && ( rgb <= colorModeX ) ) { colorCalc ( ( float ) rgb , alpha ) ; } else { colorCalcARGB ( rgb , alpha ) ; } } protected void colorCalc ( float gray ) { colorCalc ( gray , colorModeA ) ; } protected void colorCalc ( float gray , float alpha ) { if ( gray > colorModeX ) gray = colorModeX ; if ( alpha > colorModeA ) alpha = colorModeA ; if ( gray < 0 ) gray = 0 ; if ( alpha < 0 ) alpha = 0 ; calcR = colorModeScale ? ( gray / colorModeX ) : gray ; calcG = calcR ; calcB = calcR ; calcA = colorModeScale ? ( alpha / colorModeA ) : alpha ; calcRi = ( int ) ( calcR * 255 ) ; calcGi = ( int ) ( calcG * 255 ) ; calcBi = ( int ) ( calcB * 255 ) ; calcAi = ( int ) ( calcA * 255 ) ; calcColor = ( calcAi < < 24 ) | ( calcRi < < 16 ) | ( calcGi < < 8 ) | calcBi ; calcAlpha = ( calcAi != 255 ) ; } protected void colorCalc ( float x , float y , float z ) { colorCalc ( x , y , z , colorModeA ) ; } protected void colorCalc ( float x , float y , float z , float a ) { if ( x > colorModeX ) x = colorModeX ; if ( y > colorModeY ) y = colorModeY ; if ( z > colorModeZ ) z = colorModeZ ; if ( a > colorModeA ) a = colorModeA ; if ( x < 0 ) x = 0 ; if ( y < 0 ) y = 0 ; if ( z < 0 ) z = 0 ; if ( a < 0 ) a = 0 ; switch ( colorMode ) { case RGB : if ( colorModeScale ) { calcR = x / colorModeX ; calcG = y / colorModeY ; calcB = z / colorModeZ ; calcA = a / colorModeA ; } else { calcR = x ; calcG = y ; calcB = z ; calcA = a ; } break ; case HSB : x /= colorModeX ; y /= colorModeY ; z /= colorModeZ ; calcA = colorModeScale ? ( a / colorModeA ) : a ; if ( y == 0 ) { calcR = calcG = calcB = z ; } else { float which = ( x - ( int ) x ) * 6.0f ; float f = which - ( int ) which ; float p = z * ( 1.0f - y ) ; float q = z * ( 1.0f - y * f ) ; float t = z * ( 1.0f - ( y * ( 1.0f - f ) ) ) ; switch ( ( int ) which ) { case 0 : calcR = z ; calcG = t ; calcB = p ; break ; case 1 : calcR = q ; calcG = z ; calcB = p ; break ; case 2 : calcR = p ; calcG = z ; calcB = t ; break ; case 3 : calcR = p ; calcG = q ; calcB = z ; break ; case 4 : calcR = t ; calcG = p ; calcB = z ; break ; case 5 : calcR = z ; calcG = p ; calcB = q ; break ; } } break ; } calcRi = ( int ) ( 255 * calcR ) ; calcGi = ( int ) ( 255 * calcG ) ; calcBi = ( int ) ( 255 * calcB ) ; calcAi = ( int ) ( 255 * calcA ) ; calcColor = ( calcAi < < 24 ) | ( calcRi < < 16 ) | ( calcGi < < 8 ) | calcBi ; calcAlpha = ( calcAi != 255 ) ; } protected void colorCalcARGB ( int argb , float alpha ) { if ( alpha == colorModeA ) { calcAi = ( argb > > 24 ) & 0xff ; calcColor = argb ; } else { calcAi = ( int ) ( ( ( argb > > 24 ) & 0xff ) * ( alpha / colorModeA ) ) ; calcColor = ( calcAi < < 24 ) | ( argb & 0xFFFFFF ) ; } calcRi = ( argb > > 16 ) & 0xff ; calcGi = ( argb > > 8 ) & 0xff ; calcBi = argb & 0xff ; calcA = calcAi / 255.0f ; calcR = calcRi / 255.0f ; calcG = calcGi / 255.0f ; calcB = calcBi / 255.0f ; calcAlpha = ( calcAi != 255 ) ; } }
package test . processing . mode . java ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . fail ; import static test . processing . mode . java . ProcessingTestUtil . res ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; public class AutoFormatTests { @ BeforeClass public static void init ( ) { ProcessingTestUtil . init ( ) ; } static void expectGood ( final String id ) { try { final String formattedProgram = ProcessingTestUtil . format ( res ( id + ".pde" ) ) ; final File goldenFile = res ( id + ".expected" ) ; checkGolden ( formattedProgram , goldenFile ) ; checkGolden ( ProcessingTestUtil . format ( formattedProgram ) , goldenFile ) ; } catch ( Exception e ) { if ( ! e . equals ( e . getCause ( ) ) && e . getCause ( ) != null ) fail ( e . getCause ( ) . toString ( ) ) ; else e . printStackTrace ( System . err ) ; fail ( e . toString ( ) ) ; } } private static void checkGolden ( final String expectedText , final File goldenFile ) throws IOException { if ( goldenFile . exists ( ) ) { final String expected = ProcessingTestUtil . read ( goldenFile ) ; assertEquals ( expected , expectedText ) ; } else { System . err . println ( "WARN: golden file " + goldenFile + " does not exist. Generating." ) ; final FileWriter sug = new FileWriter ( goldenFile ) ; sug . write ( ProcessingTestUtil . normalize ( expectedText ) ) ; sug . close ( ) ; } } @ Test public void bug109 ( ) { expectGood ( "bug109" ) ; } @ Test public void bug405 ( ) { expectGood ( "bug405" ) ; } @ Test public void bug420 ( ) { expectGood ( "bug420" ) ; } }
package test . processing . mode . java ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . fail ; import static test . processing . mode . java . ProcessingTestUtil . COMPILER ; import static test . processing . mode . java . ProcessingTestUtil . preprocess ; import static test . processing . mode . java . ProcessingTestUtil . res ; import java . io . File ; import java . io . FileWriter ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . junit . BeforeClass ; import org . junit . Test ; import processing . app . SketchException ; import processing . app . exec . ProcessResult ; import antlr . RecognitionException ; public class ParserTests { @ BeforeClass public static void init ( ) { ProcessingTestUtil . init ( ) ; } static void expectRecognitionException ( final String id , final String expectedMessage , final int expectedLine ) { try { preprocess ( id , res ( id + ".pde" ) ) ; fail ( "Expected to fail with \"" + expectedMessage + "\" on line " + expectedLine ) ; } catch ( RecognitionException e ) { assertEquals ( expectedMessage , e . getMessage ( ) ) ; assertEquals ( expectedLine , e . getLine ( ) ) ; } catch ( Exception e ) { if ( ! e . equals ( e . getCause ( ) ) && e . getCause ( ) != null ) fail ( e . getCause ( ) . toString ( ) ) ; else fail ( e . toString ( ) ) ; } } static void expectRunnerException ( final String id , final String expectedMessage , final int expectedLine ) { try { preprocess ( id , res ( id + ".pde" ) ) ; fail ( "Expected to fail with \"" + expectedMessage + "\" on line " + expectedLine ) ; } catch ( SketchException e ) { assertEquals ( expectedMessage , e . getMessage ( ) ) ; assertEquals ( expectedLine , e . getCodeLine ( ) ) ; } catch ( Exception e ) { if ( ! e . equals ( e . getCause ( ) ) && e . getCause ( ) != null ) fail ( e . getCause ( ) . toString ( ) ) ; else fail ( e . toString ( ) ) ; } } static void expectCompilerException ( final String id , final String expectedMessage , final int expectedLine ) { try { final String program = ProcessingTestUtil . preprocess ( id , res ( id + ".pde" ) ) ; final ProcessResult compilerResult = COMPILER . compile ( id , program ) ; if ( compilerResult . succeeded ( ) ) { fail ( "Expected to fail with \"" + expectedMessage + "\" on line " + expectedLine ) ; } final String e = compilerResult . getStderr ( ) . split ( "\n" ) [ 0 ] ; final Matcher m = Pattern . compile ( ":(\\d+):\\s+(.+)$" ) . matcher ( e ) ; m . find ( ) ; assertEquals ( expectedMessage , m . group ( 2 ) ) ; assertEquals ( String . valueOf ( expectedLine ) , m . group ( 1 ) ) ; } catch ( Exception e ) { if ( ! e . equals ( e . getCause ( ) ) && e . getCause ( ) != null ) fail ( e . getCause ( ) . toString ( ) ) ; else fail ( e . toString ( ) ) ; } } static void expectGood ( final String id ) { try { final String program = ProcessingTestUtil . preprocess ( id , res ( id + ".pde" ) ) ; final ProcessResult compilerResult = COMPILER . compile ( id , program ) ; if ( ! compilerResult . succeeded ( ) ) { System . err . println ( program ) ; System . err . println ( "----------------------------" ) ; System . err . println ( compilerResult . getStderr ( ) ) ; fail ( "Compilation failed with status " + compilerResult . getResult ( ) ) ; } final File expectedFile = res ( id + ".expected" ) ; if ( expectedFile . exists ( ) ) { final String expected = ProcessingTestUtil . read ( expectedFile ) ; assertEquals ( expected , program ) ; } else { System . err . println ( "WARN: " + id + " does not have an expected output file. Generating." ) ; final FileWriter sug = new FileWriter ( res ( id + ".expected" ) ) ; sug . write ( ProcessingTestUtil . normalize ( program ) ) ; sug . close ( ) ; } } catch ( Exception e ) { if ( ! e . equals ( e . getCause ( ) ) && e . getCause ( ) != null ) fail ( e . getCause ( ) . toString ( ) ) ; else fail ( e . toString ( ) ) ; } } @ Test public void bug4 ( ) { expectGood ( "bug4" ) ; } @ Test public void bug5a ( ) { expectGood ( "bug5a" ) ; } @ Test public void bug5b ( ) { expectGood ( "bug5b" ) ; } @ Test public void bug6 ( ) { expectRecognitionException ( "bug6" , "expecting EOF, found '/'" , 1 ) ; } @ Test public void bug16 ( ) { expectRunnerException ( "bug16" , "Unclosed /* comment */" , 2 ) ; } @ Test public void bug136 ( ) { expectGood ( "bug136" ) ; } @ Test public void bug196 ( ) { expectRecognitionException ( "bug196" , "Web colors must be exactly 6 hex digits. This looks like 5." , 4 ) ; } @ Test public void bug281 ( ) { expectGood ( "bug281" ) ; } @ Test public void bug481 ( ) { expectGood ( "bug481" ) ; } @ Test public void bug507 ( ) { expectRecognitionException ( "bug507" , "expecting EOF, found 'else'" , 5 ) ; } @ Test public void bug598 ( ) { expectGood ( "bug598" ) ; } @ Test public void bug631 ( ) { expectGood ( "bug631" ) ; } @ Test public void bug763 ( ) { expectRunnerException ( "bug763" , "Unterminated string constant" , 6 ) ; } @ Test public void bug820 ( ) { expectCompilerException ( "bug820" , "error: variable x1 is already defined in method setup()" , 18 ) ; } @ Test public void bug1064 ( ) { expectGood ( "bug1064" ) ; } @ Test public void bug1145 ( ) { expectCompilerException ( "bug1145" , "error: '.' expected" , 6 ) ; } @ Test public void bug1362 ( ) { expectGood ( "bug1362" ) ; } @ Test public void bug1390 ( ) { expectGood ( "bug1390" ) ; } @ Test public void bug1442 ( ) { expectGood ( "bug1442" ) ; } @ Test public void bug1511 ( ) { expectGood ( "bug1511" ) ; } @ Test public void bug1512 ( ) { expectGood ( "bug1512" ) ; } @ Test public void bug1514a ( ) { expectGood ( "bug1514a" ) ; } @ Test public void bug1514b ( ) { expectGood ( "bug1514b" ) ; } @ Test public void bug1515 ( ) { expectGood ( "bug1515" ) ; } @ Test public void bug1516 ( ) { expectGood ( "bug1516" ) ; } @ Test public void bug1517 ( ) { expectGood ( "bug1517" ) ; } @ Test public void bug1518a ( ) { expectGood ( "bug1518a" ) ; } @ Test public void bug1518b ( ) { expectGood ( "bug1518b" ) ; } @ Test public void bug1519 ( ) { expectRecognitionException ( "bug1519" , "Maybe too many > characters?" , 7 ) ; } @ Test public void bug1525 ( ) { expectGood ( "bug1525" ) ; } @ Test public void bug1532 ( ) { expectRecognitionException ( "bug1532" , "unexpected token: break" , 50 ) ; } @ Test public void bug1534 ( ) { expectGood ( "bug1534" ) ; } @ Test public void bug1936 ( ) { expectGood ( "bug1936" ) ; } @ Test public void bug315g ( ) { expectGood ( "bug315g" ) ; } @ Test public void bug400g ( ) { expectGood ( "bug400g" ) ; } @ Test public void bug427g ( ) { expectGood ( "bug427g" ) ; } @ Test public void annotations ( ) { expectGood ( "annotations" ) ; } }
package antlr ; import java . io . * ; import antlr . collections . * ; public class ExtendedCommonASTWithHiddenTokens extends CommonASTWithHiddenTokens { public ExtendedCommonASTWithHiddenTokens ( ) { super ( ) ; } public ExtendedCommonASTWithHiddenTokens ( Token tok ) { super ( tok ) ; } public void initialize ( AST ast ) { ExtendedCommonASTWithHiddenTokens a = ( ExtendedCommonASTWithHiddenTokens ) ast ; super . initialize ( a ) ; hiddenBefore = a . getHiddenBefore ( ) ; hiddenAfter = a . getHiddenAfter ( ) ; } public String getHiddenAfterString ( ) { CommonHiddenStreamToken t ; StringBuilder hiddenAfterString = new StringBuilder ( 100 ) ; for ( t = hiddenAfter ; t != null ; t = t . getHiddenAfter ( ) ) { hiddenAfterString . append ( t . getText ( ) ) ; } return hiddenAfterString . toString ( ) ; } public String getHiddenBeforeString ( ) { antlr . CommonHiddenStreamToken child = null , parent = hiddenBefore ; if ( parent == null ) { return "" ; } do { child = parent ; parent = child . getHiddenBefore ( ) ; } while ( parent != null ) ; StringBuilder hiddenBeforeString = new StringBuilder ( 100 ) ; for ( CommonHiddenStreamToken t = child ; t != null ; t = t . getHiddenAfter ( ) ) { hiddenBeforeString . append ( t . getText ( ) ) ; } return hiddenBeforeString . toString ( ) ; } public void xmlSerializeNode ( Writer out ) throws IOException { StringBuilder sb = new StringBuilder ( 100 ) ; sb . append ( "<" ) ; sb . append ( getClass ( ) . getName ( ) + " " ) ; sb . append ( "hiddenBeforeString=\"" + encode ( getHiddenBeforeString ( ) ) + "\" text=\"" + encode ( getText ( ) ) + "\" type=\"" + getType ( ) + "\" hiddenAfterString=\"" + encode ( getHiddenAfterString ( ) ) + "\"/>" ) ; out . write ( sb . toString ( ) ) ; } public void xmlSerializeRootOpen ( Writer out ) throws IOException { StringBuilder sb = new StringBuilder ( 100 ) ; sb . append ( "<" ) ; sb . append ( getClass ( ) . getName ( ) + " " ) ; sb . append ( "hiddenBeforeString=\"" + encode ( getHiddenBeforeString ( ) ) + "\" text=\"" + encode ( getText ( ) ) + "\" type=\"" + getType ( ) + "\" hiddenAfterString=\"" + encode ( getHiddenAfterString ( ) ) + "\">\n" ) ; out . write ( sb . toString ( ) ) ; } public void xmlSerializeRootClose ( Writer out ) throws IOException { out . write ( "</" + getClass ( ) . getName ( ) + ">\n" ) ; } public void xmlSerialize ( Writer out ) throws IOException { for ( AST node = this ; node != null ; node = node . getNextSibling ( ) ) { if ( node . getFirstChild ( ) == null ) { ( ( BaseAST ) node ) . xmlSerializeNode ( out ) ; } else { ( ( BaseAST ) node ) . xmlSerializeRootOpen ( out ) ; ( ( BaseAST ) node . getFirstChild ( ) ) . xmlSerialize ( out ) ; ( ( BaseAST ) node ) . xmlSerializeRootClose ( out ) ; } } } }
package antlr ; import antlr . collections . impl . BitSet ; public class TokenStreamCopyingHiddenTokenFilter extends TokenStreamHiddenTokenFilter implements TokenStream { protected BitSet copyMask ; CommonHiddenStreamToken hiddenCopy = null ; public TokenStreamCopyingHiddenTokenFilter ( TokenStream input ) { super ( input ) ; copyMask = new BitSet ( ) ; } public void copy ( int tokenType ) { copyMask . add ( tokenType ) ; } public CommonHiddenStreamToken partialCloneToken ( CommonHiddenStreamToken t ) { CommonHiddenStreamToken u = new CommonHiddenStreamToken ( t . getType ( ) , t . getText ( ) ) ; u . setColumn ( t . getColumn ( ) ) ; u . setLine ( t . getLine ( ) ) ; u . setFilename ( t . getFilename ( ) ) ; return u ; } public void linkAndCopyToken ( CommonHiddenStreamToken prev , CommonHiddenStreamToken monitored ) { hiddenCopy = partialCloneToken ( LA ( 1 ) ) ; prev . setHiddenAfter ( hiddenCopy ) ; if ( prev != monitored ) { hiddenCopy . setHiddenBefore ( prev ) ; } return ; } private void consumeFirst ( ) throws TokenStreamException { consume ( ) ; CommonHiddenStreamToken p = null ; while ( hideMask . member ( LA ( 1 ) . getType ( ) ) || discardMask . member ( LA ( 1 ) . getType ( ) ) || copyMask . member ( LA ( 1 ) . getType ( ) ) ) { if ( copyMask . member ( LA ( 1 ) . getType ( ) ) ) { hiddenCopy = partialCloneToken ( LA ( 1 ) ) ; if ( p != null ) { p . setHiddenAfter ( hiddenCopy ) ; hiddenCopy . setHiddenBefore ( p ) ; } lastHiddenToken = hiddenCopy ; if ( firstHidden == null ) { firstHidden = hiddenCopy ; } break ; } else if ( hideMask . member ( LA ( 1 ) . getType ( ) ) ) { if ( p != null ) { p . setHiddenAfter ( LA ( 1 ) ) ; LA ( 1 ) . setHiddenBefore ( p ) ; } p = LA ( 1 ) ; lastHiddenToken = p ; if ( firstHidden == null ) { firstHidden = p ; } } consume ( ) ; } } public Token nextToken ( ) throws TokenStreamException { if ( LA ( 1 ) == null ) { consumeFirst ( ) ; } CommonHiddenStreamToken monitored = LA ( 1 ) ; monitored . setHiddenBefore ( lastHiddenToken ) ; lastHiddenToken = null ; consume ( ) ; CommonHiddenStreamToken prev = monitored ; while ( hideMask . member ( LA ( 1 ) . getType ( ) ) || discardMask . member ( LA ( 1 ) . getType ( ) ) || copyMask . member ( LA ( 1 ) . getType ( ) ) ) { if ( copyMask . member ( LA ( 1 ) . getType ( ) ) ) { if ( hiddenCopy != null ) { linkAndCopyToken ( hiddenCopy , monitored ) ; } else { linkAndCopyToken ( prev , monitored ) ; } return monitored ; } else if ( hideMask . member ( LA ( 1 ) . getType ( ) ) ) { prev . setHiddenAfter ( LA ( 1 ) ) ; if ( prev != monitored ) { LA ( 1 ) . setHiddenBefore ( prev ) ; } else if ( hiddenCopy != null ) { hiddenCopy . setHiddenAfter ( LA ( 1 ) ) ; LA ( 1 ) . setHiddenBefore ( hiddenCopy ) ; hiddenCopy = null ; } prev = lastHiddenToken = LA ( 1 ) ; } consume ( ) ; } if ( hiddenCopy != null ) { lastHiddenToken = hiddenCopy ; hiddenCopy = null ; } return monitored ; } }
package processing . mode . java ; import java . util . Stack ; import java . util . regex . Pattern ; import processing . app . Formatter ; import processing . app . Preferences ; import processing . core . PApplet ; public class AutoFormat implements Formatter { private char [ ] chars ; private final StringBuilder buf = new StringBuilder ( ) ; private final StringBuilder result = new StringBuilder ( ) ; private int indentValue ; private boolean EOF ; private boolean inStatementFlag ; private boolean overflowFlag ; private boolean startFlag ; private boolean if_flg ; private boolean elseFlag ; private int arrayLevel ; private int arrayIndent ; private int conditionalLevel ; private int [ ] [ ] sp_flg ; private boolean [ ] [ ] s_ind ; private int if_lev ; private int pos ; private int level ; private int curlyLvl ; private int parenLevel ; private boolean [ ] ind ; private int [ ] p_flg ; private int [ ] [ ] s_tabs ; private Stack < Boolean > doWhileFlags ; private Stack < Boolean > ifWhileForFlags ; private boolean jdoc_flag ; private int tabs ; private char lastNonWhitespace = 0 ; private void handleMultiLineComment ( ) { final boolean savedStartFlag = startFlag ; buf . append ( nextChar ( ) ) ; for ( char ch = nextChar ( ) ; ! EOF ; ch = nextChar ( ) ) { buf . append ( ch ) ; while ( ch != '/' && ! EOF ) { if ( ch == '\n' ) { writeIndentedComment ( ) ; startFlag = true ; } buf . append ( ch = nextChar ( ) ) ; } if ( buf . length ( ) >= 2 && buf . charAt ( buf . length ( ) - 2 ) == '*' ) { jdoc_flag = false ; break ; } } writeIndentedComment ( ) ; startFlag = savedStartFlag ; jdoc_flag = false ; return ; } private void handleSingleLineComment ( ) { char ch = nextChar ( ) ; while ( ch != '\n' && ! EOF ) { buf . append ( ch ) ; ch = nextChar ( ) ; } writeIndentedLine ( ) ; startFlag = true ; } private void writeIndentedLine ( ) { if ( buf . length ( ) == 0 ) { if ( startFlag ) startFlag = elseFlag = false ; return ; } if ( startFlag ) { boolean indentMore = ! buf . toString ( ) . matches ( "[\\s\\]\\}\\)]+;" ) && ( buf . charAt ( 0 ) != '{' || arrayLevel >= 0 ) && overflowFlag ; if ( indentMore ) { tabs ++ ; if ( arrayIndent > 0 ) tabs += arrayIndent ; } printIndentation ( ) ; startFlag = false ; if ( indentMore ) { tabs -- ; if ( arrayIndent > 0 ) tabs -= arrayIndent ; } } if ( lastNonSpaceChar ( ) == '}' && bufStarts ( "else" ) ) { result . append ( ' ' ) ; } if ( elseFlag ) { if ( lastNonSpaceChar ( ) == '}' ) { trimRight ( result ) ; result . append ( ' ' ) ; } elseFlag = false ; } overflowFlag = inStatementFlag ; arrayIndent = arrayLevel ; result . append ( buf ) ; buf . setLength ( 0 ) ; } private char lastNonSpaceChar ( ) { for ( int i = result . length ( ) - 1 ; i >= 0 ; i -- ) { char chI = result . charAt ( i ) ; if ( chI != ' ' && chI != '\n' ) return chI ; } return 0 ; } private void writeIndentedComment ( ) { if ( buf . length ( ) == 0 ) return ; int firstNonSpace = 0 ; while ( buf . charAt ( firstNonSpace ) == ' ' ) firstNonSpace ++ ; if ( lookup_com ( "/**" ) ) jdoc_flag = true ; if ( startFlag ) printIndentation ( ) ; if ( buf . charAt ( firstNonSpace ) == '/' && buf . charAt ( firstNonSpace + 1 ) == '*' ) { if ( startFlag && lastNonWhitespace != ';' ) { result . append ( buf . substring ( firstNonSpace ) ) ; } else { result . append ( buf ) ; } } else { if ( buf . charAt ( firstNonSpace ) == '*' || ! jdoc_flag ) { result . append ( " " + buf . substring ( firstNonSpace ) ) ; } else { result . append ( " * " + buf . substring ( firstNonSpace ) ) ; } } buf . setLength ( 0 ) ; } private void printIndentation ( ) { if ( tabs <= 0 ) { tabs = 0 ; return ; } final int spaces = tabs * indentValue ; for ( int i = 0 ; i < spaces ; i ++ ) { result . append ( ' ' ) ; } } private char peek ( ) { return ( pos + 1 >= chars . length ) ? 0 : chars [ pos + 1 ] ; } private void advanceToNonSpace ( boolean allWsp ) { if ( EOF ) return ; if ( allWsp ) { do { pos ++ ; } while ( pos < chars . length && Character . isWhitespace ( chars [ pos ] ) ) ; } else { do { pos ++ ; } while ( pos < chars . length && chars [ pos ] == ' ' ) ; } if ( pos == chars . length - 1 ) { EOF = true ; } else { pos -- ; } } private char nextChar ( ) { if ( EOF ) return 0 ; pos ++ ; if ( pos >= chars . length - 1 ) EOF = true ; if ( pos >= chars . length ) return 0 ; char retVal = chars [ pos ] ; if ( ! Character . isWhitespace ( retVal ) ) lastNonWhitespace = retVal ; return retVal ; } private void gotElse ( ) { tabs = s_tabs [ curlyLvl ] [ if_lev ] ; p_flg [ level ] = sp_flg [ curlyLvl ] [ if_lev ] ; ind [ level ] = s_ind [ curlyLvl ] [ if_lev ] ; if_flg = true ; inStatementFlag = false ; } private boolean readForNewLine ( ) { final int savedTabs = tabs ; char c = peek ( ) ; while ( ! EOF && ( c == '\t' || c == ' ' ) ) { buf . append ( nextChar ( ) ) ; c = peek ( ) ; } if ( c == '/' ) { buf . append ( nextChar ( ) ) ; c = peek ( ) ; if ( c == '*' ) { buf . append ( nextChar ( ) ) ; handleMultiLineComment ( ) ; } else if ( c == '/' ) { buf . append ( nextChar ( ) ) ; handleSingleLineComment ( ) ; return true ; } } c = peek ( ) ; if ( c == '\n' ) { nextChar ( ) ; tabs = savedTabs ; return true ; } return false ; } private char prevNonWhitespace ( ) { StringBuffer tot = new StringBuffer ( ) ; tot . append ( result ) ; tot . append ( buf ) ; for ( int i = tot . length ( ) - 1 ; i >= 0 ; i -- ) { if ( ! Character . isWhitespace ( tot . charAt ( i ) ) ) return tot . charAt ( i ) ; } return 0 ; } private boolean bufStarts ( final String keyword ) { return Pattern . matches ( "^\\s*" + keyword + "(?![a-zA-Z0-9_&]).*$" , buf ) ; } private boolean bufEnds ( final String keyword ) { return Pattern . matches ( "^.*(?<![a-zA-Z0-9_&])" + keyword + "\\s*$" , buf ) ; } private void if_levSafe ( ) { if ( s_tabs [ 0 ] . length <= if_lev ) { for ( int i = 0 ; i < s_tabs . length ; i ++ ) { s_tabs [ i ] = PApplet . expand ( s_tabs [ i ] ) ; } } if ( sp_flg [ 0 ] . length <= if_lev ) { for ( int i = 0 ; i < sp_flg . length ; i ++ ) { sp_flg [ i ] = PApplet . expand ( sp_flg [ i ] ) ; } } if ( s_ind [ 0 ] . length <= if_lev ) { for ( int i = 0 ; i < s_ind . length ; i ++ ) { s_ind [ i ] = PApplet . expand ( s_ind [ i ] ) ; } } } private boolean lookup_com ( final String keyword ) { final String regex = "^\\s*" + keyword . replace ( "*" , "\\*" ) + ".*$" ; return Pattern . matches ( regex , buf ) ; } static private void trimRight ( final StringBuilder sb ) { while ( sb . length ( ) >= 1 && Character . isWhitespace ( sb . charAt ( sb . length ( ) - 1 ) ) ) { sb . setLength ( sb . length ( ) - 1 ) ; } } public String format ( final String source ) { final String normalizedText = source . replaceAll ( "\r" , "" ) ; final String cleanText = normalizedText + ( normalizedText . endsWith ( "\n" ) ? "" : "\n" ) ; result . setLength ( 0 ) ; indentValue = Preferences . getInteger ( "editor.tabs.size" ) ; boolean forFlag = if_flg = false ; startFlag = true ; int forParenthLevel = 0 ; conditionalLevel = parenLevel = curlyLvl = if_lev = level = 0 ; tabs = 0 ; jdoc_flag = inStatementFlag = overflowFlag = false ; pos = arrayLevel = - 1 ; int [ ] s_level = new int [ 10 ] ; sp_flg = new int [ 20 ] [ 10 ] ; s_ind = new boolean [ 20 ] [ 10 ] ; int [ ] s_if_lev = new int [ 10 ] ; boolean [ ] s_if_flg = new boolean [ 10 ] ; ind = new boolean [ 10 ] ; p_flg = new int [ 10 ] ; s_tabs = new int [ 20 ] [ 10 ] ; doWhileFlags = new Stack < Boolean > ( ) ; ifWhileForFlags = new Stack < Boolean > ( ) ; chars = cleanText . toCharArray ( ) ; EOF = false ; while ( ! EOF ) { char c = nextChar ( ) ; switch ( c ) { default : inStatementFlag = true ; buf . append ( c ) ; break ; case ',' : inStatementFlag = true ; trimRight ( buf ) ; buf . append ( ", " ) ; advanceToNonSpace ( false ) ; break ; case ' ' : case '\t' : elseFlag = bufEnds ( "else" ) ; if ( elseFlag ) { gotElse ( ) ; if ( ! startFlag || buf . length ( ) > 0 ) { buf . append ( c ) ; } writeIndentedLine ( ) ; startFlag = false ; break ; } if ( ! startFlag || buf . length ( ) > 0 ) buf . append ( c ) ; break ; case '\n' : if ( EOF ) break ; elseFlag = bufEnds ( "else" ) ; if ( elseFlag ) gotElse ( ) ; if ( lookup_com ( "//" ) ) { if ( buf . charAt ( buf . length ( ) - 1 ) == '\n' ) { buf . setLength ( buf . length ( ) - 1 ) ; } } if ( elseFlag ) { writeIndentedLine ( ) ; result . append ( "\n" ) ; p_flg [ level ] ++ ; tabs ++ ; } else { writeIndentedLine ( ) ; result . append ( "\n" ) ; } startFlag = true ; break ; case '{' : elseFlag = bufEnds ( "else" ) ; if ( elseFlag ) gotElse ( ) ; doWhileFlags . push ( Boolean . valueOf ( bufEnds ( "do" ) ) ) ; char prevChar = prevNonWhitespace ( ) ; if ( arrayLevel >= 0 || prevChar == '=' || prevChar == ']' ) { arrayLevel ++ ; buf . append ( c ) ; break ; } inStatementFlag = false ; if ( s_if_lev . length == curlyLvl ) { s_if_lev = PApplet . expand ( s_if_lev ) ; s_if_flg = PApplet . expand ( s_if_flg ) ; } s_if_lev [ curlyLvl ] = if_lev ; s_if_flg [ curlyLvl ] = if_flg ; if_lev = 0 ; if_flg = false ; curlyLvl ++ ; if ( startFlag && p_flg [ level ] != 0 ) { p_flg [ level ] -- ; tabs -- ; } trimRight ( buf ) ; if ( buf . length ( ) > 0 || ( result . length ( ) > 0 && ! Character . isWhitespace ( result . charAt ( result . length ( ) - 1 ) ) ) ) { buf . append ( " " ) ; } buf . append ( c ) ; writeIndentedLine ( ) ; readForNewLine ( ) ; writeIndentedLine ( ) ; result . append ( '\n' ) ; tabs ++ ; startFlag = true ; if ( p_flg [ level ] > 0 ) { ind [ level ] = true ; level ++ ; s_level [ level ] = curlyLvl ; } break ; case '}' : if ( arrayLevel >= 0 ) { if ( arrayLevel > 0 ) arrayLevel -- ; if ( arrayIndent > arrayLevel ) arrayIndent = arrayLevel ; buf . append ( c ) ; break ; } inStatementFlag = false ; curlyLvl -- ; if ( curlyLvl < 0 ) { curlyLvl = 0 ; buf . append ( c ) ; writeIndentedLine ( ) ; } else { if_lev = s_if_lev [ curlyLvl ] - 1 ; if ( if_lev < 0 ) if_lev = 0 ; if_levSafe ( ) ; if_flg = s_if_flg [ curlyLvl ] ; trimRight ( buf ) ; writeIndentedLine ( ) ; tabs -- ; trimRight ( result ) ; result . append ( '\n' ) ; printIndentation ( ) ; result . append ( c ) ; if ( peek ( ) == ';' ) result . append ( nextChar ( ) ) ; if ( doWhileFlags . empty ( ) || ! doWhileFlags . pop ( ) . booleanValue ( ) || ! new String ( chars , pos + 1 , chars . length - pos - 1 ) . trim ( ) . startsWith ( "while" ) ) { readForNewLine ( ) ; writeIndentedLine ( ) ; result . append ( '\n' ) ; startFlag = true ; } else { result . append ( ' ' ) ; advanceToNonSpace ( true ) ; startFlag = false ; } if ( curlyLvl < s_level [ level ] && level > 0 ) level -- ; if ( ind [ level ] ) { tabs -= p_flg [ level ] ; p_flg [ level ] = 0 ; ind [ level ] = false ; } } break ; case '"' : case '\'' : inStatementFlag = true ; buf . append ( c ) ; char cc = nextChar ( ) ; while ( ! EOF && cc != c ) { buf . append ( cc ) ; if ( cc == '\\' ) { buf . append ( cc = nextChar ( ) ) ; } if ( cc == '\n' ) { writeIndentedLine ( ) ; startFlag = true ; } cc = nextChar ( ) ; } buf . append ( cc ) ; if ( readForNewLine ( ) ) { chars [ pos -- ] = '\n' ; } break ; case ';' : if ( forFlag ) { trimRight ( buf ) ; buf . append ( "; " ) ; advanceToNonSpace ( false ) ; break ; } buf . append ( c ) ; inStatementFlag = false ; writeIndentedLine ( ) ; if ( p_flg [ level ] > 0 && ! ind [ level ] ) { tabs -= p_flg [ level ] ; p_flg [ level ] = 0 ; } readForNewLine ( ) ; writeIndentedLine ( ) ; result . append ( "\n" ) ; startFlag = true ; arrayLevel = - 1 ; if ( if_lev > 0 ) { if ( if_flg ) { if_lev -- ; if_flg = false ; } else { if_lev = 0 ; } } break ; case '\\' : buf . append ( c ) ; buf . append ( nextChar ( ) ) ; break ; case '?' : conditionalLevel ++ ; buf . append ( c ) ; break ; case ':' : if ( peek ( ) == ':' ) { result . append ( c ) . append ( nextChar ( ) ) ; break ; } else if ( conditionalLevel > 0 ) { conditionalLevel -- ; buf . append ( c ) ; break ; } else if ( forFlag ) { trimRight ( buf ) ; buf . append ( " : " ) ; advanceToNonSpace ( false ) ; break ; } buf . append ( c ) ; inStatementFlag = false ; arrayLevel = - 1 ; tabs -- ; writeIndentedLine ( ) ; tabs ++ ; readForNewLine ( ) ; writeIndentedLine ( ) ; result . append ( '\n' ) ; startFlag = true ; break ; case '/' : final char next = peek ( ) ; if ( next == '/' ) { buf . append ( c ) . append ( nextChar ( ) ) ; handleSingleLineComment ( ) ; result . append ( "\n" ) ; } else if ( next == '*' ) { if ( buf . length ( ) > 0 ) { writeIndentedLine ( ) ; } buf . append ( c ) . append ( nextChar ( ) ) ; handleMultiLineComment ( ) ; } else { buf . append ( c ) ; } break ; case ')' : parenLevel -- ; if ( forFlag && forParenthLevel > parenLevel ) forFlag = false ; if ( parenLevel < 0 ) parenLevel = 0 ; buf . append ( c ) ; boolean wasIfEtc = ! ifWhileForFlags . empty ( ) && ifWhileForFlags . pop ( ) . booleanValue ( ) ; if ( wasIfEtc ) { inStatementFlag = false ; arrayLevel = - 1 ; } writeIndentedLine ( ) ; if ( wasIfEtc && readForNewLine ( ) ) { chars [ pos ] = '\n' ; pos -- ; if ( parenLevel == 0 ) { p_flg [ level ] ++ ; tabs ++ ; ind [ level ] = false ; } } break ; case '(' : final boolean isFor = bufEnds ( "for" ) ; final boolean isIf = bufEnds ( "if" ) ; if ( isFor || isIf || bufEnds ( "while" ) ) { if ( ! Character . isWhitespace ( buf . charAt ( buf . length ( ) - 1 ) ) ) { buf . append ( ' ' ) ; } ifWhileForFlags . push ( true ) ; } else { ifWhileForFlags . push ( false ) ; } buf . append ( c ) ; parenLevel ++ ; if ( isFor && ! forFlag ) { forParenthLevel = parenLevel ; forFlag = true ; } else if ( isIf ) { writeIndentedLine ( ) ; s_tabs [ curlyLvl ] [ if_lev ] = tabs ; sp_flg [ curlyLvl ] [ if_lev ] = p_flg [ level ] ; s_ind [ curlyLvl ] [ if_lev ] = ind [ level ] ; if_lev ++ ; if_levSafe ( ) ; if_flg = true ; } } } if ( buf . length ( ) > 0 ) writeIndentedLine ( ) ; final String formatted = result . toString ( ) ; return formatted . equals ( cleanText ) ? source : formatted ; } }
package processing . mode . java ; import java . awt . * ; import java . awt . image . BufferedImage ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . swing . * ; import javax . swing . event . TreeExpansionEvent ; import javax . swing . event . TreeExpansionListener ; import javax . swing . table . TableColumn ; import javax . swing . tree . * ; import org . netbeans . swing . outline . * ; import com . sun . jdi . Value ; import processing . app . Language ; import processing . app . Mode ; import processing . mode . java . debug . VariableNode ; public class VariableInspector extends JDialog { static final int VERTICAL_OFFSET = 64 ; static final int HORIZONTAL_OFFSET = 16 ; static final int DEFAULT_WIDTH = 300 ; static final int DEFAULT_HEIGHT = 400 ; protected DefaultMutableTreeNode rootNode ; protected DefaultMutableTreeNode builtins ; protected DefaultTreeModel treeModel ; protected Outline tree ; protected OutlineModel model ; protected List < DefaultMutableTreeNode > callStack ; protected List < VariableNode > locals ; protected List < VariableNode > thisFields ; protected List < VariableNode > declaredThisFields ; protected JavaEditor editor ; protected List < TreePath > expandedNodes = new ArrayList < TreePath > ( ) ; public VariableInspector ( final JavaEditor editor ) { super ( editor , "Variables" ) ; this . editor = editor ; getRootPane ( ) . putClientProperty ( "Window.style" , "small" ) ; setFocusableWindowState ( false ) ; Box box = Box . createVerticalBox ( ) ; box . add ( createScrollPane ( ) ) ; getContentPane ( ) . add ( box ) ; pack ( ) ; int x = editor . getX ( ) + editor . getWidth ( ) + HORIZONTAL_OFFSET ; if ( x + getWidth ( ) > getToolkit ( ) . getScreenSize ( ) . width ) { setLocationRelativeTo ( editor ) ; } else { setLocation ( x , editor . getY ( ) + VERTICAL_OFFSET ) ; } } Container createScrollPane ( ) { JScrollPane scrollPane = new JScrollPane ( ) ; tree = new Outline ( ) ; scrollPane . setViewportView ( tree ) ; rootNode = new DefaultMutableTreeNode ( "root" ) ; builtins = new DefaultMutableTreeNode ( "Processing" ) ; treeModel = new DefaultTreeModel ( rootNode ) ; model = DefaultOutlineModel . createOutlineModel ( treeModel , new VariableRowModel ( ) , true , Language . text ( "debugger.name" ) ) ; ExpansionHandler expansionHandler = new ExpansionHandler ( ) ; model . getTreePathSupport ( ) . addTreeWillExpandListener ( expansionHandler ) ; model . getTreePathSupport ( ) . addTreeExpansionListener ( expansionHandler ) ; tree . setModel ( model ) ; tree . setRootVisible ( false ) ; tree . setRenderDataProvider ( new OutlineRenderer ( ) ) ; tree . setColumnHidingAllowed ( false ) ; tree . setAutoscrolls ( false ) ; TableColumn valueColumn = tree . getColumnModel ( ) . getColumn ( 1 ) ; valueColumn . setCellRenderer ( new ValueCellRenderer ( ) ) ; valueColumn . setCellEditor ( new ValueCellEditor ( ) ) ; callStack = new ArrayList < DefaultMutableTreeNode > ( ) ; locals = new ArrayList < VariableNode > ( ) ; thisFields = new ArrayList < VariableNode > ( ) ; declaredThisFields = new ArrayList < VariableNode > ( ) ; scrollPane . setBorder ( BorderFactory . createEmptyBorder ( 0 , 0 , 0 , 0 ) ) ; scrollPane . setPreferredSize ( new Dimension ( DEFAULT_WIDTH , DEFAULT_HEIGHT ) ) ; return scrollPane ; } protected class VariableRowModel implements RowModel { final String column0 = Language . text ( "debugger.value" ) ; final String column1 = Language . text ( "debugger.type" ) ; final String [ ] columnNames = { column0 , column1 } ; final int [ ] editableTypes = { VariableNode . TYPE_BOOLEAN , VariableNode . TYPE_FLOAT , VariableNode . TYPE_INTEGER , VariableNode . TYPE_STRING , VariableNode . TYPE_FLOAT , VariableNode . TYPE_DOUBLE , VariableNode . TYPE_LONG , VariableNode . TYPE_SHORT , VariableNode . TYPE_CHAR } ; @ Override public int getColumnCount ( ) { return 1 ; } @ Override public Object getValueFor ( Object obj , int column ) { if ( obj instanceof VariableNode ) { VariableNode var = ( VariableNode ) obj ; if ( column == 0 ) { return var ; } else if ( column == 1 ) { return var . getTypeName ( ) ; } } return "" ; } @ Override public Class < ? > getColumnClass ( int column ) { if ( column == 0 ) { return VariableNode . class ; } return String . class ; } @ Override public boolean isCellEditable ( Object o , int i ) { if ( i == 0 && o instanceof VariableNode ) { VariableNode var = ( VariableNode ) o ; for ( int type : editableTypes ) { if ( var . getType ( ) == type ) { return true ; } } } return false ; } @ Override public void setValueFor ( Object o , int i , Object o1 ) { VariableNode var = ( VariableNode ) o ; String stringValue = ( String ) o1 ; Debugger dbg = editor . getDebugger ( ) ; Value value = null ; try { switch ( var . getType ( ) ) { case VariableNode . TYPE_INTEGER : value = dbg . vm ( ) . mirrorOf ( Integer . parseInt ( stringValue ) ) ; break ; case VariableNode . TYPE_BOOLEAN : value = dbg . vm ( ) . mirrorOf ( Boolean . parseBoolean ( stringValue ) ) ; break ; case VariableNode . TYPE_FLOAT : value = dbg . vm ( ) . mirrorOf ( Float . parseFloat ( stringValue ) ) ; break ; case VariableNode . TYPE_STRING : value = dbg . vm ( ) . mirrorOf ( stringValue ) ; break ; case VariableNode . TYPE_LONG : value = dbg . vm ( ) . mirrorOf ( Long . parseLong ( stringValue ) ) ; break ; case VariableNode . TYPE_BYTE : value = dbg . vm ( ) . mirrorOf ( Byte . parseByte ( stringValue ) ) ; break ; case VariableNode . TYPE_DOUBLE : value = dbg . vm ( ) . mirrorOf ( Double . parseDouble ( stringValue ) ) ; break ; case VariableNode . TYPE_SHORT : value = dbg . vm ( ) . mirrorOf ( Short . parseShort ( stringValue ) ) ; break ; case VariableNode . TYPE_CHAR : if ( stringValue . length ( ) > 0 ) { value = dbg . vm ( ) . mirrorOf ( stringValue . charAt ( 0 ) ) ; } break ; } } catch ( NumberFormatException ex ) { Logger . getLogger ( VariableRowModel . class . getName ( ) ) . log ( Level . INFO , "invalid value entered for {0}: {1}" , new Object [ ] { var . getName ( ) , stringValue } ) ; } if ( value != null ) { var . setValue ( value ) ; Logger . getLogger ( VariableRowModel . class . getName ( ) ) . log ( Level . INFO , "new value set: {0}" , var . getStringValue ( ) ) ; } } @ Override public String getColumnName ( int i ) { return columnNames [ i ] ; } } class OutlineRenderer implements RenderDataProvider { Icon [ ] [ ] icons ; static final int ICON_SIZE = 16 ; OutlineRenderer ( ) { icons = loadIcons ( "theme/var-icons.gif" ) ; } private ImageIcon [ ] [ ] loadIcons ( String fileName ) { Mode mode = editor . getMode ( ) ; File file = mode . getContentFile ( fileName ) ; if ( ! file . exists ( ) ) { Logger . getLogger ( OutlineRenderer . class . getName ( ) ) . log ( Level . SEVERE , "icon file not found: {0}" , file . getAbsolutePath ( ) ) ; return null ; } Image allIcons = mode . loadImage ( fileName ) ; int cols = allIcons . getWidth ( null ) / ICON_SIZE ; int rows = allIcons . getHeight ( null ) / ICON_SIZE ; ImageIcon [ ] [ ] iconImages = new ImageIcon [ cols ] [ rows ] ; for ( int i = 0 ; i < cols ; i ++ ) { for ( int j = 0 ; j < rows ; j ++ ) { Image image = new BufferedImage ( ICON_SIZE , ICON_SIZE , BufferedImage . TYPE_INT_ARGB ) ; Graphics g = image . getGraphics ( ) ; g . drawImage ( allIcons , - i * ICON_SIZE , - j * ICON_SIZE , null ) ; iconImages [ i ] [ j ] = new ImageIcon ( image ) ; } } return iconImages ; } protected Icon getIcon ( int type , int state ) { if ( type < 0 || type > icons . length - 1 ) { return null ; } return icons [ type ] [ state ] ; } protected VariableNode toVariableNode ( Object o ) { return ( o instanceof VariableNode ) ? ( VariableNode ) o : null ; } protected Icon toGray ( Icon icon ) { if ( icon instanceof ImageIcon ) { Image grayImage = GrayFilter . createDisabledImage ( ( ( ImageIcon ) icon ) . getImage ( ) ) ; return new ImageIcon ( grayImage ) ; } return icon ; } @ Override public String getDisplayName ( Object o ) { return o . toString ( ) ; } @ Override public boolean isHtmlDisplayName ( Object o ) { return false ; } @ Override public Color getBackground ( Object o ) { return null ; } @ Override public Color getForeground ( Object o ) { if ( tree . isEnabled ( ) ) { return null ; } else { return Color . GRAY ; } } @ Override public String getTooltipText ( Object o ) { VariableNode var = toVariableNode ( o ) ; if ( var != null ) { return var . getDescription ( ) ; } else { return "" ; } } @ Override public Icon getIcon ( Object o ) { VariableNode var = toVariableNode ( o ) ; if ( var != null ) { return getIcon ( var . getType ( ) , tree . isEnabled ( ) ? 0 : 1 ) ; } if ( o instanceof TreeNode ) { UIDefaults defaults = UIManager . getDefaults ( ) ; boolean isLeaf = model . isLeaf ( o ) ; Icon icon ; if ( isLeaf ) { icon = defaults . getIcon ( "Tree.leafIcon" ) ; } else { icon = defaults . getIcon ( "Tree.closedIcon" ) ; } if ( ! tree . isEnabled ( ) ) { return toGray ( icon ) ; } return icon ; } return null ; } } protected class ValueCellRenderer extends DefaultOutlineCellRenderer { public ValueCellRenderer ( ) { super ( ) ; } protected void setItalic ( boolean on ) { setFont ( new Font ( getFont ( ) . getName ( ) , on ? Font . ITALIC : Font . PLAIN , getFont ( ) . getSize ( ) ) ) ; } @ Override public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { Component c = super . getTableCellRendererComponent ( table , value , isSelected , hasFocus , row , column ) ; setForeground ( tree . isEnabled ( ) ? Color . BLACK : Color . GRAY ) ; if ( value instanceof VariableNode ) { VariableNode var = ( VariableNode ) value ; setItalic ( var . getValue ( ) == null || var . getType ( ) == VariableNode . TYPE_OBJECT ) ; value = var . getStringValue ( ) ; } setValue ( value ) ; return c ; } } protected class ValueCellEditor extends DefaultCellEditor { public ValueCellEditor ( ) { super ( new JTextField ( ) ) ; } @ Override public Component getTableCellEditorComponent ( JTable table , Object value , boolean isSelected , int row , int column ) { if ( ! ( value instanceof VariableNode ) ) { return super . getTableCellEditorComponent ( table , value , isSelected , row , column ) ; } VariableNode var = ( VariableNode ) value ; String strValue = ( var . getType ( ) == VariableNode . TYPE_STRING && var . getValue ( ) == null ) ? "" : var . getStringValue ( ) ; return super . getTableCellEditorComponent ( table , strValue , isSelected , row , column ) ; } } protected class ExpansionHandler implements ExtTreeWillExpandListener , TreeExpansionListener { @ Override public void treeWillExpand ( TreeExpansionEvent tee ) throws ExpandVetoException { Object last = tee . getPath ( ) . getLastPathComponent ( ) ; if ( ! ( last instanceof VariableNode ) ) { return ; } VariableNode var = ( VariableNode ) last ; var . removeAllChildren ( ) ; var . addChildren ( filterNodes ( editor . getDebugger ( ) . getFields ( var . getValue ( ) , 0 , true ) , new ThisFilter ( ) ) ) ; } @ Override public void treeWillCollapse ( TreeExpansionEvent tee ) throws ExpandVetoException { } @ Override public void treeExpanded ( TreeExpansionEvent tee ) { if ( ! expandedNodes . contains ( tee . getPath ( ) ) ) { expandedNodes . add ( tee . getPath ( ) ) ; } } @ Override public void treeCollapsed ( TreeExpansionEvent tee ) { List < TreePath > removalList = new ArrayList < TreePath > ( ) ; for ( TreePath path : expandedNodes ) { if ( path . getParentPath ( ) . equals ( tee . getPath ( ) ) ) { removalList . add ( path ) ; } } for ( TreePath path : removalList ) { expandedNodes . remove ( path ) ; } expandedNodes . remove ( tee . getPath ( ) ) ; } @ Override public void treeExpansionVetoed ( TreeExpansionEvent tee , ExpandVetoException eve ) { } } public void unlock ( ) { tree . setEnabled ( true ) ; } public void lock ( ) { if ( tree . getCellEditor ( ) != null ) { tree . getCellEditor ( ) . cancelCellEditing ( ) ; } tree . setEnabled ( false ) ; } public void reset ( ) { rootNode . removeAllChildren ( ) ; callStack . clear ( ) ; locals . clear ( ) ; thisFields . clear ( ) ; declaredThisFields . clear ( ) ; expandedNodes . clear ( ) ; treeModel . nodeStructureChanged ( rootNode ) ; } public void updateCallStack ( List < DefaultMutableTreeNode > nodes , String title ) { callStack = nodes ; } public void updateLocals ( List < VariableNode > nodes , String title ) { locals = nodes ; } public void updateThisFields ( List < VariableNode > nodes , String title ) { thisFields = nodes ; } public void updateDeclaredThisFields ( List < VariableNode > nodes , String title ) { declaredThisFields = nodes ; } public void rebuild ( ) { rootNode . removeAllChildren ( ) ; addAllNodes ( rootNode , locals ) ; addAllNodes ( rootNode , filterNodes ( declaredThisFields , new LocalHidesThisFilter ( locals , LocalHidesThisFilter . MODE_PREFIX ) ) ) ; builtins . removeAllChildren ( ) ; addAllNodes ( builtins , filterNodes ( thisFields , new P5BuiltinsFilter ( ) ) ) ; if ( builtins . getChildCount ( ) > 0 ) { rootNode . add ( builtins ) ; } treeModel . nodeStructureChanged ( rootNode ) ; for ( TreePath path : expandedNodes ) { path = synthesizePath ( path ) ; if ( path != null ) { tree . expandPath ( path ) ; } else { } } } protected TreePath synthesizePath ( TreePath path ) { if ( path . getPathCount ( ) == 0 || ! rootNode . equals ( path . getPathComponent ( 0 ) ) ) { return null ; } Object [ ] newPath = new Object [ path . getPathCount ( ) ] ; newPath [ 0 ] = rootNode ; TreeNode currentNode = rootNode ; for ( int i = 0 ; i < path . getPathCount ( ) - 1 ; i ++ ) { for ( int j = 0 ; j < currentNode . getChildCount ( ) ; j ++ ) { TreeNode nextNode = currentNode . getChildAt ( j ) ; if ( nextNode . equals ( path . getPathComponent ( i + 1 ) ) ) { currentNode = nextNode ; newPath [ i + 1 ] = nextNode ; break ; } } if ( newPath [ i + 1 ] == null ) { return null ; } } return new TreePath ( newPath ) ; } protected List < VariableNode > filterNodes ( List < VariableNode > nodes , VariableNodeFilter filter ) { List < VariableNode > filtered = new ArrayList < VariableNode > ( ) ; for ( VariableNode node : nodes ) { if ( filter . accept ( node ) ) { filtered . add ( node ) ; } } return filtered ; } protected void addAllNodes ( DefaultMutableTreeNode root , List < ? extends MutableTreeNode > nodes ) { for ( MutableTreeNode node : nodes ) { root . add ( node ) ; } } public interface VariableNodeFilter { public boolean accept ( VariableNode var ) ; } public class P5BuiltinsFilter implements VariableNodeFilter { protected String [ ] p5Builtins = { "focused" , "frameCount" , "frameRate" , "height" , "online" , "screen" , "width" , "mouseX" , "mouseY" , "pmouseX" , "pmouseY" , "key" , "keyCode" , "keyPressed" } ; @ Override public boolean accept ( VariableNode var ) { return Arrays . asList ( p5Builtins ) . contains ( var . getName ( ) ) ; } } public class ThisFilter implements VariableNodeFilter { @ Override public boolean accept ( VariableNode var ) { return ! var . getName ( ) . startsWith ( "this$" ) ; } } public class LocalHidesThisFilter implements VariableNodeFilter { public static final int MODE_HIDE = 0 ; public static final int MODE_PREFIX = 1 ; protected List < VariableNode > locals ; protected int mode ; public LocalHidesThisFilter ( List < VariableNode > locals , int mode ) { this . locals = locals ; this . mode = mode ; } @ Override public boolean accept ( VariableNode var ) { for ( VariableNode local : locals ) { if ( var . getName ( ) . equals ( local . getName ( ) ) ) { switch ( mode ) { case MODE_PREFIX : var . setName ( "this." + var . getName ( ) ) ; return true ; case MODE_HIDE : return false ; } } } return true ; } } }
package processing . mode . java ; import java . awt . * ; import java . awt . event . * ; import java . beans . * ; import java . io . * ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . MenuEvent ; import javax . swing . event . MenuListener ; import javax . swing . table . TableModel ; import javax . swing . text . Document ; import org . eclipse . jdt . core . compiler . IProblem ; import processing . core . PApplet ; import processing . app . * ; import processing . app . Toolkit ; import processing . app . contrib . AvailableContribution ; import processing . app . contrib . Contribution ; import processing . app . contrib . ContributionListing ; import processing . app . contrib . ContributionManager ; import processing . app . contrib . ToolContribution ; import processing . app . syntax . JEditTextArea ; import processing . app . syntax . PdeTextAreaDefaults ; import processing . mode . java . debug . LineBreakpoint ; import processing . mode . java . debug . LineHighlight ; import processing . mode . java . debug . LineID ; import processing . mode . java . pdex . ErrorCheckerService ; import processing . mode . java . pdex . ErrorMarker ; import processing . mode . java . pdex . ErrorMessageSimplifier ; import processing . mode . java . pdex . JavaTextArea ; import processing . mode . java . pdex . Problem ; import processing . mode . java . pdex . XQErrorTable ; import processing . mode . java . runner . Runner ; import processing . mode . java . tweak . ColorControlBox ; import processing . mode . java . tweak . Handle ; import processing . mode . java . tweak . SketchParser ; import processing . mode . java . tweak . TweakClient ; public class JavaEditor extends Editor { JavaMode jmode ; private Runner runtime ; protected Color breakpointColor ; protected Color currentLineColor ; protected Color breakpointMarkerColor ; protected Color currentLineMarkerColor ; protected List < LineHighlight > breakpointedLines = new ArrayList < LineHighlight > ( ) ; protected LineHighlight currentLine ; protected final String breakpointMarkerComment = " //<>//" ; protected JMenu debugMenu ; protected JMenuItem debugItem ; protected Debugger debugger ; protected boolean debugEnabled ; protected VariableInspector inspector ; protected JMenuItem inspectorItem ; private ErrorColumn errorBar ; protected JScrollPane errorTableScrollPane ; protected XQErrorTable errorTable ; static final int ERROR_TAB_INDEX = 0 ; private boolean hasJavaTabs ; private boolean javaTabWarned ; protected ErrorCheckerService errorCheckerService ; protected JavaEditor ( Base base , String path , EditorState state , Mode mode ) { super ( base , path , state , mode ) ; jmode = ( JavaMode ) mode ; debugger = new Debugger ( this ) ; inspector = new VariableInspector ( this ) ; JMenuItem showUsageItem = new JMenuItem ( "Show Usage..." ) ; showUsageItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleShowUsage ( ) ; } } ) ; getTextArea ( ) . getRightClickPopup ( ) . add ( showUsageItem ) ; JMenuItem renameItem = new JMenuItem ( "Rename..." ) ; renameItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleRefactor ( ) ; } } ) ; textarea . getRightClickPopup ( ) . add ( renameItem ) ; Toolkit . setMenuMnemonics ( textarea . getRightClickPopup ( ) ) ; breakpointColor = mode . getColor ( "breakpoint.bgcolor" ) ; breakpointMarkerColor = mode . getColor ( "breakpoint.marker.color" ) ; currentLineColor = mode . getColor ( "currentline.bgcolor" ) ; currentLineMarkerColor = mode . getColor ( "currentline.marker.color" ) ; for ( LineID lineID : stripBreakpointComments ( ) ) { debugger . setBreakpoint ( lineID ) ; } getSketch ( ) . setModified ( false ) ; hasJavaTabs = checkForJavaTabs ( ) ; errorCheckerService = new ErrorCheckerService ( this ) ; new Thread ( errorCheckerService ) . start ( ) ; JPanel textAndError = new JPanel ( ) ; Box box = ( Box ) textarea . getParent ( ) ; box . remove ( 2 ) ; textAndError . setLayout ( new BorderLayout ( ) ) ; errorBar = new ErrorColumn ( this , textarea . getMinimumSize ( ) . height , jmode ) ; textAndError . add ( errorBar , BorderLayout . EAST ) ; textarea . setBounds ( 0 , 0 , errorBar . getX ( ) - 1 , textarea . getHeight ( ) ) ; textAndError . add ( textarea ) ; box . add ( textAndError ) ; getJavaTextArea ( ) . setMode ( jmode ) ; addWindowFocusListener ( new WindowFocusListener ( ) { public void windowLostFocus ( WindowEvent e ) { getJavaTextArea ( ) . hideSuggestion ( ) ; } public void windowGainedFocus ( WindowEvent e ) { } } ) ; } protected JEditTextArea createTextArea ( ) { return new JavaTextArea ( new PdeTextAreaDefaults ( mode ) , this ) ; } public EditorToolbar createToolbar ( ) { return new JavaToolbar ( this ) ; } public EditorHeader createHeader ( ) { return new EditorHeader ( this ) { public void rebuild ( ) { super . rebuild ( ) ; hasJavaTabs = checkForJavaTabs ( ) ; } } ; } @ Override public EditorFooter createFooter ( ) { EditorFooter footer = super . createFooter ( ) ; errorTableScrollPane = new JScrollPane ( ) ; errorTable = new XQErrorTable ( this ) ; errorTableScrollPane . setBorder ( BorderFactory . createEmptyBorder ( ) ) ; errorTableScrollPane . setViewportView ( errorTable ) ; footer . addPanel ( Language . text ( "editor.footer.errors" ) , errorTableScrollPane ) ; return footer ; } public Formatter createFormatter ( ) { return new AutoFormat ( ) ; } public JMenu buildFileMenu ( ) { String appTitle = Language . text ( "toolbar.export_application" ) ; JMenuItem exportApplication = Toolkit . newJMenuItemShift ( appTitle , 'E' ) ; exportApplication . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleExportApplication ( ) ; } } ) ; return buildFileMenu ( new JMenuItem [ ] { exportApplication } ) ; } public JMenu buildSketchMenu ( ) { JMenuItem runItem = Toolkit . newJMenuItem ( Language . text ( "toolbar.run" ) , 'R' ) ; runItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleRun ( ) ; } } ) ; JMenuItem presentItem = Toolkit . newJMenuItemShift ( Language . text ( "toolbar.present" ) , 'R' ) ; presentItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handlePresent ( ) ; } } ) ; JMenuItem stopItem = new JMenuItem ( Language . text ( "toolbar.stop" ) ) ; stopItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( isDebuggerEnabled ( ) ) { Logger . getLogger ( JavaEditor . class . getName ( ) ) . log ( Level . INFO , "Invoked 'Stop' menu item" ) ; debugger . stopDebug ( ) ; } else { handleStop ( ) ; } } } ) ; JMenuItem tweakItem = Toolkit . newJMenuItemShift ( Language . text ( "menu.sketch.tweak" ) , 'T' ) ; tweakItem . setSelected ( JavaMode . enableTweak ) ; tweakItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JavaMode . enableTweak = true ; handleRun ( ) ; } } ) ; return buildSketchMenu ( new JMenuItem [ ] { runItem , presentItem , tweakItem , stopItem } ) ; } public JMenu buildHelpMenu ( ) { JMenu menu = new JMenu ( Language . text ( "menu.help" ) ) ; JMenuItem item ; if ( ! Base . isMacOS ( ) ) { item = new JMenuItem ( Language . text ( "menu.help.about" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { new About ( JavaEditor . this ) ; } } ) ; menu . add ( item ) ; } item = new JMenuItem ( Language . text ( "menu.help.environment" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { showReference ( "environment" + File . separator + "index.html" ) ; } } ) ; menu . add ( item ) ; item = new JMenuItem ( Language . text ( "menu.help.reference" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { showReference ( "index.html" ) ; } } ) ; menu . add ( item ) ; item = Toolkit . newJMenuItemShift ( Language . text ( "menu.help.find_in_reference" ) , 'F' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( textarea . isSelectionActive ( ) ) { handleFindReference ( ) ; } } } ) ; menu . add ( item ) ; menu . addSeparator ( ) ; final JMenu libRefSubmenu = new JMenu ( Language . text ( "menu.help.libraries_reference" ) ) ; libRefSubmenu . addMenuListener ( new MenuListener ( ) { @ Override public void menuSelected ( MenuEvent e ) { boolean isCoreLibMenuItemAdded = false ; boolean isContribLibMenuItemAdded = false ; isCoreLibMenuItemAdded = addLibReferencesToSubMenu ( mode . coreLibraries , libRefSubmenu ) ; if ( isCoreLibMenuItemAdded && ! mode . contribLibraries . isEmpty ( ) ) libRefSubmenu . addSeparator ( ) ; isContribLibMenuItemAdded = addLibReferencesToSubMenu ( mode . contribLibraries , libRefSubmenu ) ; if ( ! isContribLibMenuItemAdded && ! isCoreLibMenuItemAdded ) { JMenuItem emptyMenuItem = new JMenuItem ( Language . text ( "menu.help.empty" ) ) ; emptyMenuItem . setEnabled ( false ) ; emptyMenuItem . setFocusable ( false ) ; emptyMenuItem . setFocusPainted ( false ) ; libRefSubmenu . add ( emptyMenuItem ) ; } else if ( ! isContribLibMenuItemAdded && ! mode . coreLibraries . isEmpty ( ) ) { libRefSubmenu . removeAll ( ) ; addLibReferencesToSubMenu ( mode . coreLibraries , libRefSubmenu ) ; } } @ Override public void menuDeselected ( MenuEvent e ) { libRefSubmenu . removeAll ( ) ; } @ Override public void menuCanceled ( MenuEvent e ) { menuDeselected ( e ) ; } } ) ; menu . add ( libRefSubmenu ) ; final JMenu toolRefSubmenu = new JMenu ( Language . text ( "menu.help.tools_reference" ) ) ; toolRefSubmenu . addMenuListener ( new MenuListener ( ) { @ Override public void menuSelected ( MenuEvent e ) { boolean isCoreToolMenuItemAdded = false ; boolean isContribToolMenuItemAdded = false ; List < ToolContribution > contribTools = getToolContribs ( ) ; isCoreToolMenuItemAdded = addToolReferencesToSubMenu ( getCoreTools ( ) , toolRefSubmenu ) ; if ( isCoreToolMenuItemAdded && ! contribTools . isEmpty ( ) ) toolRefSubmenu . addSeparator ( ) ; isContribToolMenuItemAdded = addToolReferencesToSubMenu ( contribTools , toolRefSubmenu ) ; if ( ! isContribToolMenuItemAdded && ! isCoreToolMenuItemAdded ) { toolRefSubmenu . removeAll ( ) ; final JMenuItem emptyMenuItem = new JMenuItem ( Language . text ( "menu.help.empty" ) ) ; emptyMenuItem . setEnabled ( false ) ; emptyMenuItem . setBorderPainted ( false ) ; emptyMenuItem . setFocusable ( false ) ; emptyMenuItem . setFocusPainted ( false ) ; toolRefSubmenu . add ( emptyMenuItem ) ; } else if ( ! isContribToolMenuItemAdded && ! contribTools . isEmpty ( ) ) { toolRefSubmenu . removeAll ( ) ; addToolReferencesToSubMenu ( getCoreTools ( ) , toolRefSubmenu ) ; } } @ Override public void menuDeselected ( MenuEvent e ) { toolRefSubmenu . removeAll ( ) ; } @ Override public void menuCanceled ( MenuEvent e ) { menuDeselected ( e ) ; } } ) ; menu . add ( toolRefSubmenu ) ; menu . addSeparator ( ) ; item = new JMenuItem ( Language . text ( "menu.help.online" ) ) ; item . setEnabled ( false ) ; menu . add ( item ) ; item = new JMenuItem ( Language . text ( "menu.help.getting_started" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Base . openURL ( Language . text ( "menu.help.getting_started.url" ) ) ; } } ) ; menu . add ( item ) ; item = new JMenuItem ( Language . text ( "menu.help.troubleshooting" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Base . openURL ( Language . text ( "menu.help.troubleshooting.url" ) ) ; } } ) ; menu . add ( item ) ; item = new JMenuItem ( Language . text ( "menu.help.faq" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Base . openURL ( Language . text ( "menu.help.faq.url" ) ) ; } } ) ; menu . add ( item ) ; item = new JMenuItem ( Language . text ( "menu.help.foundation" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Base . openURL ( Language . text ( "menu.help.foundation.url" ) ) ; } } ) ; menu . add ( item ) ; item = new JMenuItem ( Language . text ( "menu.help.visit" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Base . openURL ( Language . text ( "menu.help.visit.url" ) ) ; } } ) ; menu . add ( item ) ; return menu ; } private boolean addLibReferencesToSubMenu ( ArrayList < Library > libsList , JMenu subMenu ) { boolean isItemAdded = false ; Iterator < Library > iter = libsList . iterator ( ) ; while ( iter . hasNext ( ) ) { final Library libContrib = iter . next ( ) ; if ( libContrib . hasReference ( ) ) { JMenuItem libRefItem = new JMenuItem ( libContrib . getName ( ) ) ; libRefItem . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { showReferenceFile ( libContrib . getReferenceIndexFile ( ) ) ; } } ) ; subMenu . add ( libRefItem ) ; isItemAdded = true ; } } return isItemAdded ; } private boolean addToolReferencesToSubMenu ( List < ToolContribution > toolsList , JMenu subMenu ) { boolean isItemAdded = false ; Iterator < ToolContribution > iter = toolsList . iterator ( ) ; while ( iter . hasNext ( ) ) { final ToolContribution toolContrib = iter . next ( ) ; final File toolRef = new File ( toolContrib . getFolder ( ) , "reference/index.html" ) ; if ( toolRef . exists ( ) ) { JMenuItem libRefItem = new JMenuItem ( toolContrib . getName ( ) ) ; libRefItem . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { showReferenceFile ( toolRef ) ; } } ) ; subMenu . add ( libRefItem ) ; isItemAdded = true ; } } return isItemAdded ; } public String getCommentPrefix ( ) { return "//" ; } public void handleExportApplication ( ) { if ( handleExportCheckModified ( ) ) { statusNotice ( Language . text ( "export.notice.exporting" ) ) ; try { if ( exportApplicationPrompt ( ) ) { Base . openFolder ( sketch . getFolder ( ) ) ; statusNotice ( Language . text ( "export.notice.exporting.done" ) ) ; } else { } } catch ( Exception e ) { statusNotice ( Language . text ( "export.notice.exporting.error" ) ) ; e . printStackTrace ( ) ; } } } protected boolean exportApplicationPrompt ( ) throws IOException , SketchException { JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . Y_AXIS ) ) ; panel . add ( Box . createVerticalStrut ( 6 ) ) ; String line1 = Language . text ( "export.description.line1" ) ; String line2 = Language . text ( "export.description.line2" ) ; JLabel label1 = new JLabel ( line1 , SwingConstants . CENTER ) ; JLabel label2 = new JLabel ( line2 , SwingConstants . CENTER ) ; label1 . setAlignmentX ( Component . LEFT_ALIGNMENT ) ; label2 . setAlignmentX ( Component . LEFT_ALIGNMENT ) ; panel . add ( label1 ) ; panel . add ( label2 ) ; panel . add ( Box . createVerticalStrut ( 12 ) ) ; final JCheckBox windowsButton = new JCheckBox ( "Windows" ) ; windowsButton . setSelected ( Preferences . getBoolean ( "export.application.platform.windows" ) ) ; windowsButton . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent e ) { Preferences . setBoolean ( "export.application.platform.windows" , windowsButton . isSelected ( ) ) ; } } ) ; if ( ! Base . isMacOS ( ) ) { Preferences . setBoolean ( "export.application.platform.macosx" , false ) ; } final JCheckBox macosxButton = new JCheckBox ( "Mac OS X" ) ; macosxButton . setSelected ( Preferences . getBoolean ( "export.application.platform.macosx" ) ) ; macosxButton . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent e ) { Preferences . setBoolean ( "export.application.platform.macosx" , macosxButton . isSelected ( ) ) ; } } ) ; if ( ! Base . isMacOS ( ) ) { macosxButton . setEnabled ( false ) ; macosxButton . setToolTipText ( Language . text ( "export.tooltip.macosx" ) ) ; } final JCheckBox linuxButton = new JCheckBox ( "Linux" ) ; linuxButton . setSelected ( Preferences . getBoolean ( "export.application.platform.linux" ) ) ; linuxButton . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent e ) { Preferences . setBoolean ( "export.application.platform.linux" , linuxButton . isSelected ( ) ) ; } } ) ; JPanel platformPanel = new JPanel ( ) ; platformPanel . add ( windowsButton ) ; platformPanel . add ( Box . createHorizontalStrut ( 6 ) ) ; platformPanel . add ( macosxButton ) ; platformPanel . add ( Box . createHorizontalStrut ( 6 ) ) ; platformPanel . add ( linuxButton ) ; platformPanel . setBorder ( new TitledBorder ( Language . text ( "export.platforms" ) ) ) ; platformPanel . setAlignmentX ( Component . LEFT_ALIGNMENT ) ; panel . add ( platformPanel ) ; int divWidth = platformPanel . getPreferredSize ( ) . width ; int indent = 0 ; final JCheckBox showStopButton = new JCheckBox ( Language . text ( "export.options.show_stop_button" ) ) ; showStopButton . setSelected ( Preferences . getBoolean ( "export.application.stop" ) ) ; showStopButton . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent e ) { Preferences . setBoolean ( "export.application.stop" , showStopButton . isSelected ( ) ) ; } } ) ; showStopButton . setEnabled ( Preferences . getBoolean ( "export.application.present" ) ) ; showStopButton . setBorder ( new EmptyBorder ( 3 , 13 + indent , 6 , 13 ) ) ; final JCheckBox presentButton = new JCheckBox ( Language . text ( "export.options.present" ) ) ; presentButton . setSelected ( Preferences . getBoolean ( "export.application.present" ) ) ; presentButton . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent e ) { boolean sal = presentButton . isSelected ( ) ; Preferences . setBoolean ( "export.application.present" , sal ) ; showStopButton . setEnabled ( sal ) ; } } ) ; presentButton . setBorder ( new EmptyBorder ( 3 , 13 , 3 , 13 ) ) ; JPanel presentPanel = new JPanel ( ) ; presentPanel . setLayout ( new BoxLayout ( presentPanel , BoxLayout . Y_AXIS ) ) ; Box fullScreenBox = Box . createHorizontalBox ( ) ; fullScreenBox . add ( presentButton ) ; fullScreenBox . add ( new ColorPreference ( "run.present.bgcolor" ) ) ; fullScreenBox . add ( Box . createHorizontalStrut ( 10 ) ) ; fullScreenBox . add ( Box . createHorizontalGlue ( ) ) ; presentPanel . add ( fullScreenBox ) ; Box showStopBox = Box . createHorizontalBox ( ) ; showStopBox . add ( showStopButton ) ; showStopBox . add ( new ColorPreference ( "run.present.stop.color" ) ) ; showStopBox . add ( Box . createHorizontalStrut ( 10 ) ) ; showStopBox . add ( Box . createHorizontalGlue ( ) ) ; presentPanel . add ( showStopBox ) ; presentPanel . setBorder ( new TitledBorder ( Language . text ( "export.full_screen" ) ) ) ; presentPanel . setAlignmentX ( Component . LEFT_ALIGNMENT ) ; panel . add ( presentPanel ) ; JPanel embedPanel = new JPanel ( ) ; embedPanel . setLayout ( new BoxLayout ( embedPanel , BoxLayout . Y_AXIS ) ) ; String platformName = null ; if ( Base . isMacOS ( ) ) { platformName = "Mac OS X" ; } else if ( Base . isWindows ( ) ) { platformName = "Windows (" + Base . getNativeBits ( ) + "-bit)" ; } else if ( Base . isLinux ( ) ) { platformName = "Linux (" + Base . getNativeBits ( ) + "-bit)" ; } boolean embed = Preferences . getBoolean ( "export.application.embed_java" ) ; final String embedWarning = "<html><div width=\"" + divWidth + "\"><font size=\"2\">" + "Embedding Java will make the " + platformName + " application " + "larger, but it will be far more likely to work. " + "Users on other platforms will need to " + "<a href=\"\">install Java " + PApplet . javaPlatform + "</a>." ; final String nopeWarning = "<html><div width=\"" + divWidth + "\"><font size=\"2\">" + "Users on all platforms will have to install the latest " + "version of Java " + PApplet . javaPlatform + " from <a href=\"\">http://java.com/download</a>. " + "<br/>&nbsp;" ; final JLabel warningLabel = new JLabel ( embed ? embedWarning : nopeWarning ) ; warningLabel . addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent event ) { Base . openURL ( "http://java.com/download" ) ; } } ) ; warningLabel . setBorder ( new EmptyBorder ( 3 , 13 + indent , 3 , 13 ) ) ; final JCheckBox embedJavaButton = new JCheckBox ( Language . text ( "export.embed_java.for" ) + " " + platformName ) ; embedJavaButton . setSelected ( embed ) ; embedJavaButton . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent e ) { boolean selected = embedJavaButton . isSelected ( ) ; Preferences . setBoolean ( "export.application.embed_java" , selected ) ; if ( selected ) { warningLabel . setText ( embedWarning ) ; } else { warningLabel . setText ( nopeWarning ) ; } } } ) ; embedJavaButton . setBorder ( new EmptyBorder ( 3 , 13 , 3 , 13 ) ) ; embedPanel . add ( embedJavaButton ) ; embedPanel . add ( warningLabel ) ; embedPanel . setBorder ( new TitledBorder ( Language . text ( "export.embed_java" ) ) ) ; panel . add ( embedPanel ) ; if ( Base . isMacOS ( ) ) { JPanel signPanel = new JPanel ( ) ; signPanel . setLayout ( new BoxLayout ( signPanel , BoxLayout . Y_AXIS ) ) ; signPanel . setBorder ( new TitledBorder ( Language . text ( "export.code_signing" ) ) ) ; String thePain = "In recent versions of OS X, Apple has introduced the \u201CGatekeeper\u201D system, " + "which makes it more difficult to run applications like those exported from Processing. " ; if ( new File ( "/usr/bin/codesign_allocate" ) . exists ( ) ) { thePain += "This application will be \u201Cself-signed\u201D which means that Finder may report that the " + "application is from an \u201Cunidentified developer\u201D. If the application will not " + "run, try right-clicking the app and selecting Open from the pop-up menu. Or you can visit " + "System Preferences \u2192 Security & Privacy and select Allow apps downloaded from: anywhere. " ; } else { thePain += "Gatekeeper requires applications to be \u201Csigned\u201D, or they will be reported as damaged. " + "To prevent this message, install Xcode (and the Command Line Tools) from the App Store, or visit " + "System Preferences \u2192 Security & Privacy and select Allow apps downloaded from: anywhere. " ; } thePain += "To avoid the messages entirely, manually code sign your app. " + "For more information: <a href=\"\">https://developer.apple.com/developer-id/</a>" ; JLabel area = new JLabel ( "<html><div width=\"" + divWidth + "\"><font size=\"2\">" + thePain + "</div></html>" ) ; area . setBorder ( new EmptyBorder ( 3 , 13 , 3 , 13 ) ) ; signPanel . add ( area ) ; signPanel . setAlignmentX ( Component . LEFT_ALIGNMENT ) ; area . addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent event ) { Base . openURL ( "https://developer.apple.com/developer-id/" ) ; } } ) ; panel . add ( signPanel ) ; } String [ ] options = { Language . text ( "prompt.export" ) , Language . text ( "prompt.cancel" ) } ; final JOptionPane optionPane = new JOptionPane ( panel , JOptionPane . PLAIN_MESSAGE , JOptionPane . YES_NO_OPTION , null , options , options [ 0 ] ) ; final JDialog dialog = new JDialog ( this , Language . text ( "export" ) , true ) ; dialog . setContentPane ( optionPane ) ; optionPane . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent e ) { String prop = e . getPropertyName ( ) ; if ( dialog . isVisible ( ) && ( e . getSource ( ) == optionPane ) && ( prop . equals ( JOptionPane . VALUE_PROPERTY ) ) ) { dialog . setVisible ( false ) ; } } } ) ; dialog . pack ( ) ; dialog . setResizable ( false ) ; Rectangle bounds = getBounds ( ) ; dialog . setLocation ( bounds . x + ( bounds . width - dialog . getSize ( ) . width ) / 2 , bounds . y + ( bounds . height - dialog . getSize ( ) . height ) / 2 ) ; dialog . setVisible ( true ) ; Object value = optionPane . getValue ( ) ; if ( value . equals ( options [ 0 ] ) ) { return jmode . handleExportApplication ( sketch ) ; } else if ( value . equals ( options [ 1 ] ) || value . equals ( Integer . valueOf ( - 1 ) ) ) { statusNotice ( Language . text ( "export.notice.exporting.cancel" ) ) ; } return false ; } class ColorPreference extends JPanel implements ActionListener { ColorChooser chooser ; String prefName ; public ColorPreference ( String pref ) { prefName = pref ; setBorder ( BorderFactory . createBevelBorder ( BevelBorder . LOWERED ) ) ; setPreferredSize ( new Dimension ( 30 , 20 ) ) ; setMaximumSize ( new Dimension ( 30 , 20 ) ) ; addMouseListener ( new MouseAdapter ( ) { public void mouseReleased ( MouseEvent e ) { Color color = Preferences . getColor ( prefName ) ; chooser = new ColorChooser ( JavaEditor . this , true , color , Language . text ( "color_chooser.select" ) , ColorPreference . this ) ; chooser . show ( ) ; } } ) ; } public void paintComponent ( Graphics g ) { g . setColor ( Preferences . getColor ( prefName ) ) ; Dimension size = getSize ( ) ; g . fillRect ( 0 , 0 , size . width , size . height ) ; } public void actionPerformed ( ActionEvent e ) { Color color = chooser . getColor ( ) ; Preferences . setColor ( prefName , color ) ; repaint ( ) ; chooser . hide ( ) ; } } protected boolean handleExportCheckModified ( ) { if ( sketch . isModified ( ) ) { Object [ ] options = { Language . text ( "prompt.ok" ) , Language . text ( "prompt.cancel" ) } ; int result = JOptionPane . showOptionDialog ( this , Language . text ( "export.unsaved_changes" ) , Language . text ( "menu.file.save" ) , JOptionPane . OK_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , options [ 0 ] ) ; if ( result == JOptionPane . OK_OPTION ) { handleSave ( true ) ; } else { statusNotice ( Language . text ( "export.notice.cancel.unsaved_changes" ) ) ; return false ; } } return true ; } public void handleRun ( ) { if ( isDebuggerEnabled ( ) ) { debugger . continueDebug ( ) ; } else { new Thread ( new Runnable ( ) { public void run ( ) { prepareRun ( ) ; try { toolbar . activateRun ( ) ; runtime = jmode . handleRun ( sketch , JavaEditor . this ) ; } catch ( Exception e ) { statusError ( e ) ; } } } ) . start ( ) ; } } public void handlePresent ( ) { new Thread ( new Runnable ( ) { public void run ( ) { prepareRun ( ) ; try { toolbar . activateRun ( ) ; runtime = jmode . handlePresent ( sketch , JavaEditor . this ) ; } catch ( Exception e ) { statusError ( e ) ; } } } ) . start ( ) ; } public void handleStop ( ) { if ( debugger . isStarted ( ) ) { debugger . stopDebug ( ) ; } else { toolbar . activateStop ( ) ; try { if ( runtime != null ) { runtime . close ( ) ; runtime = null ; } } catch ( Exception e ) { statusError ( e ) ; } toolbar . deactivateStop ( ) ; toolbar . deactivateRun ( ) ; toFront ( ) ; } } public void handleStep ( int modifiers ) { if ( modifiers == 0 ) { Logger . getLogger ( getClass ( ) . getName ( ) ) . log ( Level . INFO , "Invoked 'Step Over' menu item" ) ; debugger . stepOver ( ) ; } else if ( ( modifiers & KeyEvent . SHIFT_DOWN_MASK ) != 0 ) { Logger . getLogger ( getClass ( ) . getName ( ) ) . log ( Level . INFO , "Invoked 'Step Into' menu item" ) ; debugger . stepInto ( ) ; } else if ( ( modifiers & KeyEvent . ALT_DOWN_MASK ) != 0 ) { Logger . getLogger ( getClass ( ) . getName ( ) ) . log ( Level . INFO , "Invoked 'Step Out' menu item" ) ; debugger . stepOut ( ) ; } } public void handleContinue ( ) { Logger . getLogger ( JavaEditor . class . getName ( ) ) . log ( Level . INFO , "Invoked 'Continue' menu item" ) ; debugger . continueDebug ( ) ; } public void toggleBreakpoint ( ) { debugger . toggleBreakpoint ( getCurrentLineID ( ) . lineIdx ( ) ) ; } public void toggleBreakpoint ( int lineIndex ) { debugger . toggleBreakpoint ( lineIndex ) ; } public boolean handleSaveAs ( ) { String oldName = getSketch ( ) . getCode ( 0 ) . getFileName ( ) ; boolean saved = super . handleSaveAs ( ) ; if ( saved ) { List < LineBreakpoint > bps = debugger . getBreakpoints ( oldName ) ; debugger . clearBreakpoints ( oldName ) ; String newName = getSketch ( ) . getCode ( 0 ) . getFileName ( ) ; for ( LineBreakpoint bp : bps ) { LineID line = new LineID ( newName , bp . lineID ( ) . lineIdx ( ) ) ; debugger . setBreakpoint ( line ) ; } for ( SketchCode code : getSketch ( ) . getCode ( ) ) { addBreakpointComments ( code . getFileName ( ) ) ; } } return saved ; } public void handleImportLibrary ( String libraryName ) { sketch . ensureExistence ( ) ; if ( mode . isDefaultExtension ( sketch . getCurrentCode ( ) ) ) { sketch . setCurrentCode ( 0 ) ; } Library lib = mode . findLibraryByName ( libraryName ) ; if ( lib == null ) { statusError ( "Unable to locate library: " + libraryName ) ; return ; } String [ ] list = lib . getSpecifiedImports ( ) ; if ( list == null ) { list = Base . packageListFromClassPath ( lib . getJarPath ( ) ) ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { sb . append ( "import " ) ; sb . append ( list [ i ] ) ; sb . append ( ".*;\n" ) ; } sb . append ( '\n' ) ; sb . append ( getText ( ) ) ; setText ( sb . toString ( ) ) ; setSelection ( 0 , 0 ) ; sketch . setModified ( true ) ; } public void statusError ( String what ) { super . statusError ( what ) ; toolbar . deactivateRun ( ) ; } public void internalCloseRunner ( ) { if ( JavaMode . errorLogsEnabled ) { writeErrorsToFile ( ) ; } handleStop ( ) ; } @ Override public void dispose ( ) { if ( debugEnabled ) { debugger . stopDebug ( ) ; } if ( inspector != null ) { inspector . dispose ( ) ; } errorCheckerService . stopThread ( ) ; super . dispose ( ) ; } private void writeErrorsToFile ( ) { if ( errorCheckerService . tempErrorLog . size ( ) == 0 ) return ; try { System . out . println ( "Writing errors" ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( "Sketch: " + getSketch ( ) . getFolder ( ) + ", " + new java . sql . Timestamp ( new java . util . Date ( ) . getTime ( ) ) + "\nComma in error msg is substituted with ^ symbol\nFor separating arguments in error args | symbol is used\n" ) ; sb . append ( "ERROR TYPE, ERROR ARGS, ERROR MSG\n" ) ; for ( String errMsg : errorCheckerService . tempErrorLog . keySet ( ) ) { IProblem ip = errorCheckerService . tempErrorLog . get ( errMsg ) ; if ( ip != null ) { sb . append ( ErrorMessageSimplifier . getIDName ( ip . getID ( ) ) ) ; sb . append ( ',' ) ; sb . append ( "{" ) ; for ( int i = 0 ; i < ip . getArguments ( ) . length ; i ++ ) { sb . append ( ip . getArguments ( ) [ i ] ) ; if ( i < ip . getArguments ( ) . length - 1 ) sb . append ( "| " ) ; } sb . append ( "}" ) ; sb . append ( ',' ) ; sb . append ( ip . getMessage ( ) . replace ( ',' , '^' ) ) ; sb . append ( "\n" ) ; } } System . out . println ( sb ) ; File opFile = new File ( getSketch ( ) . getFolder ( ) , "ErrorLogs" + File . separator + "ErrorLog_" + System . currentTimeMillis ( ) + ".csv" ) ; PApplet . saveStream ( opFile , new ByteArrayInputStream ( sb . toString ( ) . getBytes ( Charset . defaultCharset ( ) ) ) ) ; } catch ( Exception e ) { System . err . println ( "Failed to save log file for sketch " + getSketch ( ) . getName ( ) ) ; e . printStackTrace ( ) ; } } protected JMenu buildDebugMenu ( ) { debugMenu = new JMenu ( Language . text ( "menu.debug" ) ) ; JMenuItem item ; debugItem = Toolkit . newJMenuItem ( Language . text ( "menu.debug.enable" ) , 'D' ) ; debugItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { toggleDebug ( ) ; } } ) ; debugMenu . add ( debugItem ) ; debugMenu . addSeparator ( ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.debug.continue" ) , KeyEvent . VK_U ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleContinue ( ) ; } } ) ; debugMenu . add ( item ) ; item . setEnabled ( false ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.debug.step" ) , KeyEvent . VK_J ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleStep ( 0 ) ; } } ) ; debugMenu . add ( item ) ; item . setEnabled ( false ) ; item = Toolkit . newJMenuItemShift ( Language . text ( "menu.debug.step_into" ) , KeyEvent . VK_J ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleStep ( KeyEvent . SHIFT_DOWN_MASK ) ; } } ) ; debugMenu . add ( item ) ; item . setEnabled ( false ) ; item = Toolkit . newJMenuItemAlt ( Language . text ( "menu.debug.step_out" ) , KeyEvent . VK_J ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleStep ( KeyEvent . ALT_DOWN_MASK ) ; } } ) ; debugMenu . add ( item ) ; item . setEnabled ( false ) ; debugMenu . addSeparator ( ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.debug.toggle_breakpoint" ) , 'B' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Logger . getLogger ( JavaEditor . class . getName ( ) ) . log ( Level . INFO , "Invoked 'Toggle Breakpoint' menu item" ) ; toggleBreakpoint ( ) ; } } ) ; debugMenu . add ( item ) ; item . setEnabled ( false ) ; return debugMenu ; } protected boolean isDebuggerEnabled ( ) { return debugEnabled ; } @ Override public JMenu buildModeMenu ( ) { return buildDebugMenu ( ) ; } @ Override protected boolean handleOpenInternal ( String path ) { boolean didOpen = super . handleOpenInternal ( path ) ; if ( didOpen && debugger != null ) { debugger . clearBreakpoints ( ) ; clearBreakpointedLines ( ) ; variableInspector ( ) . reset ( ) ; } return didOpen ; } protected List < LineID > stripBreakpointComments ( ) { List < LineID > bps = new ArrayList < LineID > ( ) ; Sketch sketch = getSketch ( ) ; for ( int i = 0 ; i < sketch . getCodeCount ( ) ; i ++ ) { SketchCode tab = sketch . getCode ( i ) ; String code = tab . getProgram ( ) ; String lines [ ] = code . split ( "\\r?\\n" ) ; int lineIdx = 0 ; for ( String line : lines ) { if ( line . endsWith ( breakpointMarkerComment ) ) { LineID lineID = new LineID ( tab . getFileName ( ) , lineIdx ) ; bps . add ( lineID ) ; int index = line . lastIndexOf ( breakpointMarkerComment ) ; lines [ lineIdx ] = line . substring ( 0 , index ) ; } lineIdx ++ ; } code = PApplet . join ( lines , "\n" ) ; setTabContents ( tab . getFileName ( ) , code ) ; } return bps ; } protected void addBreakpointComments ( String tabFilename ) { SketchCode tab = getTab ( tabFilename ) ; if ( tab == null ) { Base . loge ( "Illegal tab name to addBreakpointComments() " + tabFilename ) ; return ; } List < LineBreakpoint > bps = debugger . getBreakpoints ( tab . getFileName ( ) ) ; try { tab . load ( ) ; String code = tab . getProgram ( ) ; String lines [ ] = code . split ( "\\r?\\n" ) ; for ( LineBreakpoint bp : bps ) { lines [ bp . lineID ( ) . lineIdx ( ) ] += breakpointMarkerComment ; } code = PApplet . join ( lines , "\n" ) ; tab . setProgram ( code ) ; tab . save ( ) ; } catch ( IOException ex ) { Logger . getLogger ( JavaEditor . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } @ Override public boolean handleSave ( boolean immediately ) { if ( viewingAutosaveBackup ) { } final List < String > modified = new ArrayList < String > ( ) ; for ( int i = 0 ; i < getSketch ( ) . getCodeCount ( ) ; i ++ ) { SketchCode tab = getSketch ( ) . getCode ( i ) ; if ( tab . isModified ( ) ) { modified . add ( tab . getFileName ( ) ) ; } } boolean saved = super . handleSave ( immediately ) ; if ( saved ) { if ( immediately ) { for ( String tabFilename : modified ) { addBreakpointComments ( tabFilename ) ; } } else { EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { for ( String tabFilename : modified ) { addBreakpointComments ( tabFilename ) ; } } } ) ; } } return saved ; } private boolean viewingAutosaveBackup ; protected void setTabContents ( String tabFilename , String code ) { debugger . clearBreakpoints ( tabFilename ) ; SketchCode currentTab = getCurrentTab ( ) ; SketchCode tab = getTab ( tabFilename ) ; if ( tab != null ) { tab . setProgram ( code ) ; tab . setDocument ( null ) ; setCode ( tab ) ; setCode ( currentTab ) ; } } public void clearConsole ( ) { console . clear ( ) ; } public void clearSelection ( ) { setSelection ( getCaretOffset ( ) , getCaretOffset ( ) ) ; } public void selectLine ( int lineIdx ) { setSelection ( getLineStartOffset ( lineIdx ) , getLineStopOffset ( lineIdx ) ) ; } public void cursorToLineStart ( int lineIdx ) { setSelection ( getLineStartOffset ( lineIdx ) , getLineStartOffset ( lineIdx ) ) ; } public void cursorToLineEnd ( int lineIdx ) { setSelection ( getLineStopOffset ( lineIdx ) , getLineStopOffset ( lineIdx ) ) ; } public void switchToTab ( String tabFileName ) { Sketch s = getSketch ( ) ; for ( int i = 0 ; i < s . getCodeCount ( ) ; i ++ ) { if ( tabFileName . equals ( s . getCode ( i ) . getFileName ( ) ) ) { s . setCurrentCode ( i ) ; break ; } } } public Debugger getDebugger ( ) { return debugger ; } public JavaTextArea getJavaTextArea ( ) { return ( JavaTextArea ) textarea ; } public ErrorCheckerService getErrorChecker ( ) { return errorCheckerService ; } @ Override public void prepareRun ( ) { autoSave ( ) ; super . prepareRun ( ) ; downloadImports ( ) ; } protected void downloadImports ( ) { String importRegex = errorCheckerService . importRegexp ; String tabCode ; for ( SketchCode sc : sketch . getCode ( ) ) { if ( sc . isExtension ( "pde" ) ) { tabCode = sc . getProgram ( ) ; String [ ] [ ] pieces = PApplet . matchAll ( tabCode , importRegex ) ; if ( pieces != null ) { ArrayList < String > importHeaders = new ArrayList < String > ( ) ; for ( String [ ] importStatement : pieces ) { importHeaders . add ( importStatement [ 2 ] ) ; } List < AvailableContribution > installLibsHeaders = getNotInstalledAvailableLibs ( importHeaders ) ; if ( ! installLibsHeaders . isEmpty ( ) ) { StringBuilder libList = new StringBuilder ( "Would you like to install them now?" ) ; for ( AvailableContribution ac : installLibsHeaders ) { libList . append ( "\n  " + ac . getName ( ) ) ; } int option = Base . showYesNoQuestion ( this , Language . text ( "contrib.import.dialog.title" ) , Language . text ( "contrib.import.dialog.primary_text" ) , libList . toString ( ) ) ; if ( option == JOptionPane . YES_OPTION ) { ContributionManager . downloadAndInstallOnImport ( base , installLibsHeaders ) ; } } } } } } private List < AvailableContribution > getNotInstalledAvailableLibs ( ArrayList < String > importHeadersList ) { Map < String , Contribution > importMap = ContributionListing . getInstance ( ) . librariesByImportHeader ; ArrayList < AvailableContribution > libList = new ArrayList < AvailableContribution > ( ) ; for ( String importHeaders : importHeadersList ) { int dot = importHeaders . lastIndexOf ( '.' ) ; String entry = ( dot == - 1 ) ? importHeaders : importHeaders . substring ( 0 , dot ) ; if ( entry . startsWith ( "java." ) || entry . startsWith ( "javax." ) || entry . startsWith ( "processing." ) ) { continue ; } Library library = null ; try { library = this . getMode ( ) . getLibrary ( entry ) ; if ( library == null ) { Contribution c = importMap . get ( importHeaders ) ; if ( c != null && c instanceof AvailableContribution ) { libList . add ( ( AvailableContribution ) c ) ; } } } catch ( Exception e ) { Contribution c = importMap . get ( importHeaders ) ; if ( c != null && c instanceof AvailableContribution ) { libList . add ( ( AvailableContribution ) c ) ; } } } return libList ; } protected void autoSave ( ) { if ( ! JavaMode . autoSaveEnabled ) { return ; } try { if ( sketch . isModified ( ) && ! sketch . isUntitled ( ) ) { if ( JavaMode . autoSavePromptEnabled ) { final JDialog autoSaveDialog = new JDialog ( base . getActiveEditor ( ) , getSketch ( ) . getName ( ) , true ) ; Container container = autoSaveDialog . getContentPane ( ) ; JPanel panelMain = new JPanel ( ) ; panelMain . setBorder ( BorderFactory . createEmptyBorder ( 4 , 0 , 2 , 2 ) ) ; panelMain . setLayout ( new BoxLayout ( panelMain , BoxLayout . PAGE_AXIS ) ) ; JPanel panelLabel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; JLabel label = new JLabel ( "<html><body>&nbsp;There are unsaved" + " changes in your sketch.<br />" + "&nbsp;&nbsp;&nbsp; Do you want to save it before" + " running? </body></html>" ) ; label . setFont ( new Font ( label . getFont ( ) . getName ( ) , Font . PLAIN , label . getFont ( ) . getSize ( ) + 1 ) ) ; panelLabel . add ( label ) ; panelMain . add ( panelLabel ) ; final JCheckBox dontRedisplay = new JCheckBox ( "Remember this decision" ) ; JPanel panelButtons = new JPanel ( new FlowLayout ( FlowLayout . CENTER , 8 , 2 ) ) ; JButton btnRunSave = new JButton ( "Save and Run" ) ; btnRunSave . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { handleSave ( true ) ; if ( dontRedisplay . isSelected ( ) ) { JavaMode . autoSavePromptEnabled = ! dontRedisplay . isSelected ( ) ; JavaMode . defaultAutoSaveEnabled = true ; jmode . savePreferences ( ) ; } autoSaveDialog . dispose ( ) ; } } ) ; panelButtons . add ( btnRunSave ) ; JButton btnRunNoSave = new JButton ( "Run, Don't Save" ) ; btnRunNoSave . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( dontRedisplay . isSelected ( ) ) { JavaMode . autoSavePromptEnabled = ! dontRedisplay . isSelected ( ) ; JavaMode . defaultAutoSaveEnabled = false ; jmode . savePreferences ( ) ; } autoSaveDialog . dispose ( ) ; } } ) ; panelButtons . add ( btnRunNoSave ) ; panelMain . add ( panelButtons ) ; JPanel panelCheck = new JPanel ( ) ; panelCheck . setLayout ( new FlowLayout ( FlowLayout . CENTER , 0 , 0 ) ) ; panelCheck . add ( dontRedisplay ) ; panelMain . add ( panelCheck ) ; container . add ( panelMain ) ; autoSaveDialog . setResizable ( false ) ; autoSaveDialog . pack ( ) ; autoSaveDialog . setLocationRelativeTo ( base . getActiveEditor ( ) ) ; autoSaveDialog . setVisible ( true ) ; } else if ( JavaMode . defaultAutoSaveEnabled ) { handleSave ( true ) ; } } } catch ( Exception e ) { statusError ( e ) ; } } public VariableInspector variableInspector ( ) { return inspector ; } protected void activateRun ( ) { debugItem . setEnabled ( false ) ; toolbar . activateRun ( ) ; } public void deactivateRun ( ) { toolbar . deactivateRun ( ) ; debugItem . setEnabled ( true ) ; } protected void activateDebug ( ) { activateRun ( ) ; } protected void deactivateDebug ( ) { deactivateRun ( ) ; } protected void activateContinue ( ) { ( ( JavaToolbar ) toolbar ) . activateContinue ( ) ; } protected void deactivateContinue ( ) { ( ( JavaToolbar ) toolbar ) . deactivateContinue ( ) ; } protected void activateStep ( ) { ( ( JavaToolbar ) toolbar ) . activateStep ( ) ; } protected void deactivateStep ( ) { ( ( JavaToolbar ) toolbar ) . deactivateStep ( ) ; } public void toggleDebug ( ) { debugEnabled = ! debugEnabled ; rebuildToolbar ( ) ; if ( debugEnabled ) { debugItem . setText ( Language . text ( "menu.debug.disable" ) ) ; } else { debugItem . setText ( Language . text ( "menu.debug.enable" ) ) ; } inspector . setVisible ( debugEnabled ) ; for ( Component item : debugMenu . getMenuComponents ( ) ) { if ( item instanceof JMenuItem && item != debugItem ) { ( ( JMenuItem ) item ) . setEnabled ( debugEnabled ) ; } } } public void setCurrentLine ( LineID line ) { clearCurrentLine ( ) ; if ( line == null ) { return ; } switchToTab ( line . fileName ( ) ) ; cursorToLineStart ( line . lineIdx ( ) ) ; currentLine = new LineHighlight ( line . lineIdx ( ) , currentLineColor , this ) ; currentLine . setMarker ( getJavaTextArea ( ) . currentLineMarker , currentLineMarkerColor ) ; currentLine . setPriority ( 10 ) ; } public void clearCurrentLine ( ) { if ( currentLine != null ) { currentLine . clear ( ) ; currentLine . dispose ( ) ; for ( LineHighlight hl : breakpointedLines ) { if ( hl . getLineID ( ) . equals ( currentLine . getLineID ( ) ) ) { hl . paint ( ) ; break ; } } currentLine = null ; } } public void addBreakpointedLine ( LineID lineID ) { LineHighlight hl = new LineHighlight ( lineID , breakpointColor , this ) ; hl . setMarker ( getJavaTextArea ( ) . breakpointMarker , breakpointMarkerColor ) ; breakpointedLines . add ( hl ) ; if ( currentLine != null && currentLine . getLineID ( ) . equals ( lineID ) ) { currentLine . paint ( ) ; } } public void addBreakpointedLine ( int lineIdx ) { addBreakpointedLine ( getLineIDInCurrentTab ( lineIdx ) ) ; } public void removeBreakpointedLine ( int lineIdx ) { LineID line = getLineIDInCurrentTab ( lineIdx ) ; LineHighlight foundLine = null ; for ( LineHighlight hl : breakpointedLines ) { if ( hl . getLineID ( ) . equals ( line ) ) { foundLine = hl ; break ; } } if ( foundLine != null ) { foundLine . clear ( ) ; breakpointedLines . remove ( foundLine ) ; foundLine . dispose ( ) ; if ( currentLine != null && currentLine . getLineID ( ) . equals ( line ) ) { currentLine . paint ( ) ; } } } public void clearBreakpointedLines ( ) { for ( LineHighlight hl : breakpointedLines ) { hl . clear ( ) ; hl . dispose ( ) ; } breakpointedLines . clear ( ) ; getJavaTextArea ( ) . clearLineBgColors ( ) ; getJavaTextArea ( ) . clearGutterText ( ) ; if ( currentLine != null ) { currentLine . paint ( ) ; } } public LineID getLineIDInCurrentTab ( int lineIdx ) { return new LineID ( getSketch ( ) . getCurrentCode ( ) . getFileName ( ) , lineIdx ) ; } protected LineID getCurrentLineID ( ) { String tab = getSketch ( ) . getCurrentCode ( ) . getFileName ( ) ; int lineNo = getTextArea ( ) . getCaretLine ( ) ; return new LineID ( tab , lineNo ) ; } public boolean isInCurrentTab ( LineID line ) { return line . fileName ( ) . equals ( getSketch ( ) . getCurrentCode ( ) . getFileName ( ) ) ; } @ Override protected void setCode ( SketchCode code ) { super . setCode ( code ) ; final JavaTextArea ta = getJavaTextArea ( ) ; if ( ta != null ) { ta . clearLineBgColors ( ) ; ta . clearGutterText ( ) ; if ( breakpointedLines != null ) { for ( LineHighlight hl : breakpointedLines ) { if ( isInCurrentTab ( hl . getLineID ( ) ) ) { hl . paint ( ) ; } } } if ( currentLine != null ) { if ( isInCurrentTab ( currentLine . getLineID ( ) ) ) { currentLine . paint ( ) ; } } } if ( getDebugger ( ) != null && getDebugger ( ) . isStarted ( ) ) { getDebugger ( ) . startTrackingLineChanges ( ) ; } } public SketchCode getTab ( String fileName ) { Sketch s = getSketch ( ) ; for ( SketchCode c : s . getCode ( ) ) { if ( c . getFileName ( ) . equals ( fileName ) ) { return c ; } } return null ; } public SketchCode getCurrentTab ( ) { return getSketch ( ) . getCurrentCode ( ) ; } public Document currentDocument ( ) { return getCurrentTab ( ) . getDocument ( ) ; } public void statusBusy ( ) { statusNotice ( Language . text ( "editor.status.debug.busy" ) ) ; } public void statusHalted ( ) { statusNotice ( Language . text ( "editor.status.debug.halt" ) ) ; } public static final int STATUS_EMPTY = 100 , STATUS_COMPILER_ERR = 200 , STATUS_WARNING = 300 , STATUS_INFO = 400 , STATUS_ERR = 500 ; public int statusMessageType = STATUS_EMPTY ; public String statusMessage ; public void statusMessage ( final String what , int type ) { if ( type != STATUS_EMPTY ) { if ( what . equals ( statusMessage ) && type == statusMessageType ) { return ; } } statusMessage = new String ( what ) ; statusMessageType = type ; switch ( type ) { case STATUS_COMPILER_ERR : case STATUS_ERR : super . statusError ( what ) ; break ; case STATUS_INFO : case STATUS_WARNING : statusNotice ( what ) ; break ; } if ( type == STATUS_COMPILER_ERR ) return ; SwingWorker < Object , Object > s = new SwingWorker < Object , Object > ( ) { @ Override protected Object doInBackground ( ) throws Exception { try { Thread . sleep ( 2 * 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } statusEmpty ( ) ; return null ; } } ; s . execute ( ) ; } public void statusEmpty ( ) { statusMessage = null ; statusMessageType = STATUS_EMPTY ; super . statusEmpty ( ) ; } public void updateErrorBar ( List < Problem > problems ) { errorBar . updateErrorPoints ( problems ) ; } public List < ErrorMarker > getErrorPoints ( ) { return errorBar . errorPoints ; } public void repaintErrorBar ( ) { errorBar . repaint ( ) ; } public void showConsole ( ) { footer . setPanel ( console ) ; } synchronized public boolean updateTable ( final TableModel tableModel ) { return errorTable . updateTable ( tableModel ) ; } public void updateErrorToggle ( ) { footer . setNotification ( errorTableScrollPane , JavaMode . errorCheckEnabled && errorCheckerService . hasErrors ( ) ) ; } private void handleRefactor ( ) { Base . log ( "Caret at:" + textarea . getLineText ( textarea . getCaretLine ( ) ) ) ; errorCheckerService . getASTGenerator ( ) . handleRefactor ( ) ; } private void handleShowUsage ( ) { Base . log ( "Caret at:" + textarea . getLineText ( textarea . getCaretLine ( ) ) ) ; errorCheckerService . getASTGenerator ( ) . handleShowUsage ( ) ; } public boolean hasJavaTabs ( ) { return hasJavaTabs ; } private boolean checkForJavaTabs ( ) { for ( SketchCode code : getSketch ( ) . getCode ( ) ) { if ( code . getExtension ( ) . equals ( "java" ) ) { if ( ! javaTabWarned ) { System . out . println ( getSketch ( ) . getName ( ) + " contains .java tabs. " ) ; System . out . println ( "Some editor features (like completion " + "and error checking) will be disabled." ) ; javaTabWarned = true ; } return true ; } } return false ; } protected void applyPreferences ( ) { super . applyPreferences ( ) ; if ( jmode != null ) { jmode . loadPreferences ( ) ; Base . log ( "Applying prefs" ) ; errorCheckerService . runManualErrorCheck ( ) ; } } static final String prefTweakPort = "tweak.port" ; static final String prefTweakShowCode = "tweak.showcode" ; public String [ ] baseCode ; TweakClient tweakClient ; protected void startInteractiveMode ( ) { getJavaTextArea ( ) . startInteractiveMode ( ) ; } protected void stopInteractiveMode ( List < List < Handle > > handles ) { tweakClient . shutdown ( ) ; getJavaTextArea ( ) . stopInteractiveMode ( ) ; boolean modified = false ; boolean [ ] modifiedTabs = getModifiedTabs ( handles ) ; for ( boolean mod : modifiedTabs ) { if ( mod ) { modified = true ; break ; } } if ( modified ) { int ret = Base . showYesNoQuestion ( this , Language . text ( "tweak_mode" ) , Language . text ( "tweak_mode.keep_changes.line1" ) , Language . text ( "tweak_mode.keep_changes.line2" ) ) ; if ( ret == 1 ) { loadSavedCode ( ) ; textarea . invalidate ( ) ; } else { for ( int i = 0 ; i < sketch . getCodeCount ( ) ; i ++ ) { if ( modifiedTabs [ i ] ) { sketch . getCode ( i ) . setModified ( true ) ; } else { sketch . getCode ( i ) . setProgram ( sketch . getCode ( i ) . getSavedProgram ( ) ) ; sketch . getCode ( i ) . setDocument ( null ) ; if ( i == sketch . getCurrentCodeIndex ( ) ) { setCode ( sketch . getCurrentCode ( ) ) ; } } } try { sketch . save ( ) ; } catch ( IOException e ) { Base . showWarning ( "Error" , "Could not save the modified sketch." , e ) ; } header . repaint ( ) ; textarea . invalidate ( ) ; } } else { loadSavedCode ( ) ; textarea . invalidate ( ) ; } } protected void updateInterface ( List < List < Handle > > handles , List < List < ColorControlBox > > colorBoxes ) { getJavaTextArea ( ) . updateInterface ( handles , colorBoxes ) ; } static private boolean [ ] getModifiedTabs ( List < List < Handle > > handles ) { boolean [ ] modifiedTabs = new boolean [ handles . size ( ) ] ; for ( int i = 0 ; i < handles . size ( ) ; i ++ ) { for ( Handle h : handles . get ( i ) ) { if ( h . valueChanged ( ) ) { modifiedTabs [ i ] = true ; } } } return modifiedTabs ; } protected void initBaseCode ( ) { SketchCode [ ] code = sketch . getCode ( ) ; baseCode = new String [ code . length ] ; for ( int i = 0 ; i < code . length ; i ++ ) { baseCode [ i ] = new String ( code [ i ] . getSavedProgram ( ) ) ; } } protected void initEditorCode ( List < List < Handle > > handles , boolean withSpaces ) { SketchCode [ ] sketchCode = sketch . getCode ( ) ; for ( int tab = 0 ; tab < baseCode . length ; tab ++ ) { int charInc = 0 ; String code = baseCode [ tab ] ; for ( Handle n : handles . get ( tab ) ) { int s = n . startChar + charInc ; int e = n . endChar + charInc ; String newStr = n . strNewValue ; if ( withSpaces ) { newStr = " " + newStr + " " ; } code = replaceString ( code , s , e , newStr ) ; n . newStartChar = n . startChar + charInc ; charInc += n . strNewValue . length ( ) - n . strValue . length ( ) ; if ( withSpaces ) { charInc += 4 ; } n . newEndChar = n . endChar + charInc ; } sketchCode [ tab ] . setProgram ( code ) ; sketchCode [ tab ] . setDocument ( null ) ; } setCode ( sketch . getCurrentCode ( ) ) ; } private void loadSavedCode ( ) { SketchCode [ ] code = sketch . getCode ( ) ; for ( int i = 0 ; i < code . length ; i ++ ) { if ( ! code [ i ] . getProgram ( ) . equals ( code [ i ] . getSavedProgram ( ) ) ) { code [ i ] . setProgram ( code [ i ] . getSavedProgram ( ) ) ; code [ i ] . setDocument ( null ) ; } } setCode ( sketch . getCurrentCode ( ) ) ; } protected boolean automateSketch ( Sketch sketch , SketchParser parser ) { SketchCode [ ] code = sketch . getCode ( ) ; List < List < Handle > > handles = parser . allHandles ; if ( code . length < 1 ) { return false ; } if ( handles . size ( ) == 0 ) { return false ; } int setupEndPos = SketchParser . getSetupEnd ( baseCode [ 0 ] ) ; if ( setupEndPos < 0 ) { return false ; } int port ; String portStr = Preferences . get ( prefTweakPort ) ; if ( portStr == null ) { Preferences . set ( prefTweakPort , "auto" ) ; portStr = "auto" ; } if ( portStr . equals ( "auto" ) ) { port = ( int ) ( Math . random ( ) * 0x3fff ) + 0xc000 ; } else { port = Preferences . getInteger ( prefTweakPort ) ; } tweakClient = new TweakClient ( port ) ; for ( int tab = 0 ; tab < code . length ; tab ++ ) { for ( Handle h : handles . get ( tab ) ) { h . setTweakClient ( tweakClient ) ; } } for ( int tab = 0 ; tab < code . length ; tab ++ ) { int charInc = 0 ; String c = baseCode [ tab ] ; for ( Handle n : handles . get ( tab ) ) { c = replaceString ( c , n . startChar + charInc , n . endChar + charInc , n . name ) ; charInc += n . name . length ( ) - n . strValue . length ( ) ; } code [ tab ] . setProgram ( c ) ; } String c = code [ 0 ] . getProgram ( ) ; String header ; header = "\n\n" + "/*************************/\n" + "/* MODIFIED BY TWEAKMODE */\n" + "/*************************/\n" + "\n\n" ; header += "import java.net.*;\n" ; header += "import java.io.*;\n" ; header += "import java.nio.*;\n\n" ; int numOfInts = howManyInts ( handles ) ; int numOfFloats = howManyFloats ( handles ) ; if ( numOfInts > 0 ) { header += "int[] tweakmode_int = new int[" + numOfInts + "];\n" ; } if ( numOfFloats > 0 ) { header += "float[] tweakmode_float = new float[" + numOfFloats + "];\n\n" ; } header += TweakClient . getServerCode ( port , numOfInts > 0 , numOfFloats > 0 ) ; header += "TweakModeServer tweakmode_Server;\n" ; header += "void tweakmode_initAllVars() {\n" ; for ( List < Handle > list : handles ) { for ( Handle n : list ) { header += " " + n . name + " = " + n . strValue + ";\n" ; } } header += "}\n\n" ; header += "void tweakmode_initCommunication() {\n" ; header += " tweakmode_Server = new TweakModeServer();\n" ; header += " tweakmode_Server.setup();\n" ; header += " tweakmode_Server.start();\n" ; header += "}\n" ; header += "\n\n\n\n\n" ; String addToSetup = "\n" + " tweakmode_initAllVars();\n" + " tweakmode_initCommunication();\n\n" ; setupEndPos = SketchParser . getSetupEnd ( c ) ; c = replaceString ( c , setupEndPos , setupEndPos , addToSetup ) ; code [ 0 ] . setProgram ( header + c ) ; String showModCode = Preferences . get ( prefTweakShowCode ) ; if ( showModCode == null ) { Preferences . setBoolean ( prefTweakShowCode , false ) ; } if ( Preferences . getBoolean ( prefTweakShowCode ) ) { System . out . println ( "\nTweakMode modified code:\n" ) ; for ( int i = 0 ; i < code . length ; i ++ ) { System . out . println ( "tab " + i + "\n" ) ; System . out . println ( "=======================================================\n" ) ; System . out . println ( code [ i ] . getProgram ( ) ) ; } } return true ; } static private String replaceString ( String str , int start , int end , String put ) { return str . substring ( 0 , start ) + put + str . substring ( end , str . length ( ) ) ; } static private int howManyInts ( List < List < Handle > > handles ) { int count = 0 ; for ( List < Handle > list : handles ) { for ( Handle n : list ) { if ( n . type == "int" || n . type == "hex" || n . type == "webcolor" ) { count ++ ; } } } return count ; } static private int howManyFloats ( List < List < Handle > > handles ) { int count = 0 ; for ( List < Handle > list : handles ) { for ( Handle n : list ) { if ( n . type == "float" ) { count ++ ; } } } return count ; } }
package processing . mode . java ; import java . io . File ; import java . io . IOException ; import java . io . PrintStream ; import java . io . UnsupportedEncodingException ; import processing . app . * ; import processing . app . contrib . ModeContribution ; import processing . core . PApplet ; import processing . mode . java . runner . * ; public class Commander implements RunnerListener { static final String helpArg = "--help" ; static final String buildArg = "--build" ; static final String runArg = "--run" ; static final String presentArg = "--present" ; static final String sketchArg = "--sketch=" ; static final String forceArg = "--force" ; static final String outputArg = "--output=" ; static final String exportApplicationArg = "--export" ; static final String noJavaArg = "--no-java" ; static final String platformArg = "--platform=" ; static final String bitsArg = "--bits=" ; static final int HELP = - 1 ; static final int PREPROCESS = 0 ; static final int BUILD = 1 ; static final int RUN = 2 ; static final int PRESENT = 3 ; static final int EXPORT = 4 ; Sketch sketch ; PrintStream systemOut ; PrintStream systemErr ; static public void main ( String [ ] args ) { Base . setCommandLine ( ) ; Base . initPlatform ( ) ; new Commander ( args ) ; } public Commander ( String [ ] args ) { String sketchPath = null ; File sketchFolder = null ; String pdePath = null ; String outputPath = null ; File outputFolder = null ; boolean outputSet = false ; boolean force = false ; int platform = PApplet . platform ; int platformBits = Base . getNativeBits ( ) ; int task = HELP ; boolean embedJava = true ; try { systemOut = new PrintStream ( System . out , true , "UTF-8" ) ; systemErr = new PrintStream ( System . err , true , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } for ( String arg : args ) { if ( arg . length ( ) == 0 ) { } else if ( arg . equals ( helpArg ) ) { } else if ( arg . equals ( buildArg ) ) { task = BUILD ; } else if ( arg . equals ( runArg ) ) { task = RUN ; } else if ( arg . equals ( presentArg ) ) { task = PRESENT ; } else if ( arg . equals ( exportApplicationArg ) ) { task = EXPORT ; } else if ( arg . equals ( noJavaArg ) ) { embedJava = false ; } else if ( arg . startsWith ( platformArg ) ) { complainAndQuit ( "The --platform option has been removed from Processing 2.1." , false ) ; } else if ( arg . startsWith ( bitsArg ) ) { complainAndQuit ( "The --bits option has been removed from Processing 2.1." , false ) ; } else if ( arg . startsWith ( sketchArg ) ) { sketchPath = arg . substring ( sketchArg . length ( ) ) ; sketchFolder = new File ( sketchPath ) ; if ( ! sketchFolder . exists ( ) ) { complainAndQuit ( sketchFolder + " does not exist." , false ) ; } File pdeFile = new File ( sketchFolder , sketchFolder . getName ( ) + ".pde" ) ; if ( ! pdeFile . exists ( ) ) { complainAndQuit ( "Not a valid sketch folder. " + pdeFile + " does not exist." , true ) ; } pdePath = pdeFile . getAbsolutePath ( ) ; } else if ( arg . startsWith ( outputArg ) ) { outputSet = true ; outputPath = arg . substring ( outputArg . length ( ) ) ; } else if ( arg . equals ( forceArg ) ) { force = true ; } else { complainAndQuit ( "I don't know anything about " + arg + "." , true ) ; } } if ( task == HELP ) { printCommandLine ( systemOut ) ; System . exit ( 0 ) ; } if ( outputSet ) { if ( outputPath == null ) { complainAndQuit ( "An output path must be specified." , true ) ; } outputFolder = new File ( outputPath ) ; if ( outputFolder . exists ( ) ) { if ( force ) { Base . removeDir ( outputFolder ) ; } else { complainAndQuit ( "The output folder already exists. " + "Use --force to remove it." , false ) ; } } if ( ! outputFolder . mkdirs ( ) ) { complainAndQuit ( "Could not create the output folder." , false ) ; } } Preferences . init ( ) ; Base . locateSketchbookFolder ( ) ; if ( sketchPath == null ) { complainAndQuit ( "No sketch path specified." , true ) ; } else { if ( outputSet ) { if ( outputPath . equals ( sketchPath ) ) { complainAndQuit ( "The sketch path and output path cannot be identical." , false ) ; } } boolean success = false ; JavaMode javaMode = ( JavaMode ) ModeContribution . load ( null , Base . getContentFile ( "modes/java" ) , "processing.mode.java.JavaMode" ) . getMode ( ) ; try { sketch = new Sketch ( pdePath , javaMode ) ; if ( ! outputSet ) { outputFolder = sketch . makeTempFolder ( ) ; } if ( task == BUILD || task == RUN || task == PRESENT ) { JavaBuild build = new JavaBuild ( sketch ) ; File srcFolder = new File ( outputFolder , "source" ) ; String className = build . build ( srcFolder , outputFolder , true ) ; if ( className != null ) { success = true ; if ( task == RUN || task == PRESENT ) { Runner runner = new Runner ( build , this ) ; runner . launch ( task == PRESENT ) ; } } else { success = false ; } } else if ( task == EXPORT ) { if ( outputPath == null ) { javaMode . handleExportApplication ( sketch ) ; } else { JavaBuild build = new JavaBuild ( sketch ) ; build . build ( true ) ; if ( build != null ) { success = build . exportApplication ( outputFolder , platform , platformBits , embedJava ) ; } } } if ( ! success ) { System . exit ( 1 ) ; } systemOut . println ( "Finished." ) ; System . exit ( 0 ) ; } catch ( SketchException re ) { statusError ( re ) ; System . exit ( 1 ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } } } public void statusNotice ( String message ) { systemErr . println ( message ) ; } public void statusError ( String message ) { systemErr . println ( message ) ; } public void statusError ( Exception exception ) { if ( exception instanceof SketchException ) { SketchException re = ( SketchException ) exception ; int codeIndex = re . getCodeIndex ( ) ; if ( codeIndex != - 1 ) { String filename = sketch . getCode ( codeIndex ) . getFileName ( ) ; int line = re . getCodeLine ( ) + 1 ; int column = re . getCodeColumn ( ) + 1 ; systemErr . println ( filename + ":" + line + ":" + column + ":" + line + ":" + column + ":" + " " + re . getMessage ( ) ) ; } else { exception . printStackTrace ( ) ; } } else { exception . printStackTrace ( ) ; } } void complainAndQuit ( String lastWords , boolean schoolEmFirst ) { if ( schoolEmFirst ) { printCommandLine ( systemErr ) ; } systemErr . println ( lastWords ) ; System . exit ( 1 ) ; } static void printCommandLine ( PrintStream out ) { out . println ( ) ; out . println ( "Command line edition for Processing " + Base . getVersionName ( ) + " (Java Mode)" ) ; out . println ( ) ; out . println ( "--help Show this help text. Congratulations." ) ; out . println ( ) ; out . println ( "--sketch=<name> Specify the sketch folder (required)" ) ; out . println ( "--output=<name> Specify the output folder (optional and" ) ; out . println ( " cannot be the same as the sketch folder.)" ) ; out . println ( ) ; out . println ( "--force The sketch will not build if the output" ) ; out . println ( " folder already exists, because the contents" ) ; out . println ( " will be replaced. This option erases the" ) ; out . println ( " folder first. Use with extreme caution!" ) ; out . println ( ) ; out . println ( "--build Preprocess and compile a sketch into .class files." ) ; out . println ( "--run Preprocess, compile, and run a sketch." ) ; out . println ( "--present Preprocess, compile, and run a sketch full screen." ) ; out . println ( ) ; out . println ( "--export Export an application." ) ; out . println ( "--no-java Do not embed Java. Use at your own risk!" ) ; out . println ( ) ; } @ Override public void startIndeterminate ( ) { } @ Override public void stopIndeterminate ( ) { } @ Override public void statusHalt ( ) { } @ Override public boolean isHalted ( ) { return false ; } }
package processing . mode . java ; import java . io . * ; import java . util . * ; import java . util . zip . * ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import processing . app . * ; import processing . app . exec . ProcessHelper ; import processing . core . * ; import processing . data . XML ; import processing . mode . java . preproc . * ; public class JavaBuild { public static final String PACKAGE_REGEX = "(?:^|\\s|;)package\\s+(\\S+)\\;" ; protected Sketch sketch ; protected Mode mode ; protected File srcFolder ; protected File binFolder ; private boolean foundMain = false ; private String classPath ; protected String sketchClassName ; private String javaLibraryPath ; private ArrayList < Library > importedLibraries ; public JavaBuild ( Sketch sketch ) { this . sketch = sketch ; this . mode = sketch . getMode ( ) ; } public String build ( boolean sizeWarning ) throws SketchException { return build ( sketch . makeTempFolder ( ) , sketch . makeTempFolder ( ) , sizeWarning ) ; } public String build ( File srcFolder , File binFolder , boolean sizeWarning ) throws SketchException { this . srcFolder = srcFolder ; this . binFolder = binFolder ; String classNameFound = preprocess ( srcFolder , sizeWarning ) ; if ( Compiler . compile ( this ) ) { sketchClassName = classNameFound ; return classNameFound ; } return null ; } public String getSketchClassName ( ) { return sketchClassName ; } public String preprocess ( File srcFolder , boolean sizeWarning ) throws SketchException { return preprocess ( srcFolder , null , new PdePreprocessor ( sketch . getName ( ) ) , sizeWarning ) ; } public String preprocess ( File srcFolder , String packageName , PdePreprocessor preprocessor , boolean sizeWarning ) throws SketchException { sketch . ensureExistence ( ) ; classPath = binFolder . getAbsolutePath ( ) ; String [ ] codeFolderPackages = null ; if ( sketch . hasCodeFolder ( ) ) { File codeFolder = sketch . getCodeFolder ( ) ; javaLibraryPath = codeFolder . getAbsolutePath ( ) ; String codeFolderClassPath = Base . contentsToClassPath ( codeFolder ) ; classPath += File . pathSeparator + codeFolderClassPath ; codeFolderPackages = Base . packageListFromClassPath ( codeFolderClassPath ) ; } else { javaLibraryPath = "" ; } StringBuilder bigCode = new StringBuilder ( ) ; int bigCount = 0 ; for ( SketchCode sc : sketch . getCode ( ) ) { if ( sc . isExtension ( "pde" ) ) { sc . setPreprocOffset ( bigCount ) ; bigCode . append ( sc . getProgram ( ) ) ; bigCode . append ( '\n' ) ; bigCount += sc . getLineCount ( ) ; } } SurfaceInfo sizeInfo = preprocessor . initSketchSize ( sketch . getMainProgram ( ) , sizeWarning ) ; if ( sizeInfo == null ) { return null ; } PreprocessorResult result ; try { File outputFolder = ( packageName == null ) ? srcFolder : new File ( srcFolder , packageName . replace ( '.' , '/' ) ) ; outputFolder . mkdirs ( ) ; final File java = new File ( outputFolder , sketch . getName ( ) + ".java" ) ; final PrintWriter stream = new PrintWriter ( new FileWriter ( java ) ) ; try { result = preprocessor . write ( stream , bigCode . toString ( ) , codeFolderPackages ) ; } finally { stream . close ( ) ; } } catch ( FileNotFoundException fnfe ) { fnfe . printStackTrace ( ) ; String msg = "Build folder disappeared or could not be written" ; throw new SketchException ( msg ) ; } catch ( antlr . RecognitionException re ) { int errorLine = re . getLine ( ) - 1 ; int errorFile = findErrorFile ( errorLine ) ; errorLine -= sketch . getCode ( errorFile ) . getPreprocOffset ( ) ; String msg = re . getMessage ( ) ; if ( msg . contains ( "expecting RCURLY" ) ) { throw new SketchException ( "Found one too many { characters " + "without a } to match it." , errorFile , errorLine , re . getColumn ( ) , false ) ; } if ( msg . contains ( "expecting LCURLY" ) ) { System . err . println ( msg ) ; String suffix = "." ; String [ ] m = PApplet . match ( msg , "found ('.*')" ) ; if ( m != null ) { suffix = ", not " + m [ 1 ] + "." ; } throw new SketchException ( "Was expecting a { character" + suffix , errorFile , errorLine , re . getColumn ( ) , false ) ; } if ( msg . indexOf ( "expecting RBRACK" ) != - 1 ) { System . err . println ( msg ) ; throw new SketchException ( "Syntax error, " + "maybe a missing ] character?" , errorFile , errorLine , re . getColumn ( ) , false ) ; } if ( msg . indexOf ( "expecting SEMI" ) != - 1 ) { System . err . println ( msg ) ; throw new SketchException ( "Syntax error, " + "maybe a missing semicolon?" , errorFile , errorLine , re . getColumn ( ) , false ) ; } if ( msg . indexOf ( "expecting RPAREN" ) != - 1 ) { System . err . println ( msg ) ; throw new SketchException ( "Syntax error, " + "maybe a missing right parenthesis?" , errorFile , errorLine , re . getColumn ( ) , false ) ; } if ( msg . indexOf ( "preproc.web_colors" ) != - 1 ) { throw new SketchException ( "A web color (such as #ffcc00) " + "must be six digits." , errorFile , errorLine , re . getColumn ( ) , false ) ; } throw new SketchException ( msg , errorFile , errorLine , re . getColumn ( ) , false ) ; } catch ( antlr . TokenStreamRecognitionException tsre ) { String mess = "^line (\\d+):(\\d+):\\s" ; String [ ] matches = PApplet . match ( tsre . toString ( ) , mess ) ; if ( matches != null ) { int errorLine = Integer . parseInt ( matches [ 1 ] ) - 1 ; int errorColumn = Integer . parseInt ( matches [ 2 ] ) ; int errorFile = 0 ; for ( int i = 1 ; i < sketch . getCodeCount ( ) ; i ++ ) { SketchCode sc = sketch . getCode ( i ) ; if ( sc . isExtension ( "pde" ) && ( sc . getPreprocOffset ( ) < errorLine ) ) { errorFile = i ; } } errorLine -= sketch . getCode ( errorFile ) . getPreprocOffset ( ) ; throw new SketchException ( tsre . getMessage ( ) , errorFile , errorLine , errorColumn ) ; } else { String msg = tsre . toString ( ) ; throw new SketchException ( msg , 0 , - 1 , - 1 ) ; } } catch ( SketchException pe ) { throw pe ; } catch ( Exception ex ) { System . err . println ( "Uncaught exception type:" + ex . getClass ( ) ) ; ex . printStackTrace ( ) ; throw new SketchException ( ex . toString ( ) ) ; } importedLibraries = new ArrayList < Library > ( ) ; Library core = mode . getCoreLibrary ( ) ; if ( core != null ) { importedLibraries . add ( core ) ; classPath += core . getClassPath ( ) ; javaLibraryPath += File . pathSeparator + core . getNativePath ( ) ; } for ( String item : result . extraImports ) { int dot = item . lastIndexOf ( '.' ) ; String entry = ( dot == - 1 ) ? item : item . substring ( 0 , dot ) ; if ( item . startsWith ( "static " ) ) { int dot2 = item . lastIndexOf ( '.' ) ; entry = entry . substring ( 7 , ( dot2 == - 1 ) ? entry . length ( ) : dot2 ) ; } Library library = mode . getLibrary ( entry ) ; if ( library != null ) { if ( ! importedLibraries . contains ( library ) ) { importedLibraries . add ( library ) ; classPath += library . getClassPath ( ) ; javaLibraryPath += File . pathSeparator + library . getNativePath ( ) ; } } else { boolean found = false ; if ( codeFolderPackages != null ) { String itemPkg = entry ; for ( String pkg : codeFolderPackages ) { if ( pkg . equals ( itemPkg ) ) { found = true ; break ; } } } if ( ignorableImport ( entry + '.' ) ) { found = true ; } if ( ! found ) { System . err . println ( "No library found for " + entry ) ; } } } String javaClassPath = System . getProperty ( "java.class.path" ) ; if ( javaClassPath . startsWith ( "\"" ) && javaClassPath . endsWith ( "\"" ) ) { javaClassPath = javaClassPath . substring ( 1 , javaClassPath . length ( ) - 1 ) ; } classPath += File . pathSeparator + javaClassPath ; for ( SketchCode sc : sketch . getCode ( ) ) { if ( sc . isExtension ( "java" ) ) { String filename = sc . getFileName ( ) ; try { String javaCode = sc . getProgram ( ) ; String [ ] packageMatch = PApplet . match ( javaCode , PACKAGE_REGEX ) ; if ( packageMatch == null && packageName == null ) { sc . copyTo ( new File ( srcFolder , filename ) ) ; } else { if ( packageMatch == null ) { packageMatch = new String [ ] { packageName } ; javaCode = "package " + packageName + ";" + javaCode ; } File packageFolder = new File ( srcFolder , packageMatch [ 0 ] . replace ( '.' , '/' ) ) ; packageFolder . mkdirs ( ) ; Base . saveFile ( javaCode , new File ( packageFolder , filename ) ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; String msg = "Problem moving " + filename + " to the build folder" ; throw new SketchException ( msg ) ; } } else if ( sc . isExtension ( "pde" ) ) { sc . addPreprocOffset ( result . headerOffset ) ; } } foundMain = preprocessor . hasMethod ( "main" ) ; return result . className ; } protected boolean ignorableImport ( String pkg ) { if ( pkg . startsWith ( "java." ) ) return true ; if ( pkg . startsWith ( "javax." ) ) return true ; if ( pkg . startsWith ( "processing.core." ) ) return true ; if ( pkg . startsWith ( "processing.data." ) ) return true ; if ( pkg . startsWith ( "processing.event." ) ) return true ; if ( pkg . startsWith ( "processing.opengl." ) ) return true ; return false ; } protected int findErrorFile ( int errorLine ) { for ( int i = sketch . getCodeCount ( ) - 1 ; i > 0 ; i -- ) { SketchCode sc = sketch . getCode ( i ) ; if ( sc . isExtension ( "pde" ) && ( sc . getPreprocOffset ( ) <= errorLine ) ) { return i ; } } return 0 ; } public File getSrcFolder ( ) { return srcFolder ; } public File getBinFolder ( ) { return binFolder ; } public String getSketchPath ( ) { return sketch . getFolder ( ) . getAbsolutePath ( ) ; } public String getClassPath ( ) { return classPath ; } public String getJavaLibraryPath ( ) { return javaLibraryPath ; } public boolean getFoundMain ( ) { return foundMain ; } public ArrayList < Library > getImportedLibraries ( ) { return importedLibraries ; } public SketchException placeException ( String message , String dotJavaFilename , int dotJavaLine ) { int codeIndex = 0 ; int codeLine = - 1 ; for ( int i = 0 ; i < sketch . getCodeCount ( ) ; i ++ ) { SketchCode code = sketch . getCode ( i ) ; if ( code . isExtension ( "java" ) ) { if ( dotJavaFilename . equals ( code . getFileName ( ) ) ) { codeIndex = i ; codeLine = dotJavaLine ; return new SketchException ( message , codeIndex , codeLine ) ; } } } if ( ! dotJavaFilename . equals ( sketch . getName ( ) + ".java" ) ) { return null ; } codeIndex = 0 ; for ( int i = 0 ; i < sketch . getCodeCount ( ) ; i ++ ) { SketchCode code = sketch . getCode ( i ) ; if ( code . isExtension ( "pde" ) ) { if ( code . getPreprocOffset ( ) <= dotJavaLine ) { codeIndex = i ; codeLine = dotJavaLine - code . getPreprocOffset ( ) ; } } } return new SketchException ( message , codeIndex , codeLine , - 1 , false ) ; } protected boolean exportApplication ( ) throws IOException , SketchException { String foundName = build ( true ) ; if ( foundName == null ) return false ; if ( ! sketch . getName ( ) . equals ( foundName ) ) { Base . showWarning ( "Error during export" , "Sketch name is " + sketch . getName ( ) + " but the sketch\n" + "name in the code was " + foundName , null ) ; return false ; } File folder = null ; for ( String platformName : PConstants . platformNames ) { int platform = Base . getPlatformIndex ( platformName ) ; boolean embedJava = ( platform == PApplet . platform ) && Preferences . getBoolean ( "export.application.embed_java" ) ; if ( Preferences . getBoolean ( "export.application.platform." + platformName ) ) { if ( Library . hasMultipleArch ( platform , importedLibraries ) ) { folder = new File ( sketch . getFolder ( ) , "application." + platformName + "32" ) ; if ( ! exportApplication ( folder , platform , 32 , embedJava && Base . getNativeBits ( ) == 32 ) ) { return false ; } folder = new File ( sketch . getFolder ( ) , "application." + platformName + "64" ) ; if ( ! exportApplication ( folder , platform , 64 , embedJava && Base . getNativeBits ( ) == 64 ) ) { return false ; } } else { folder = new File ( sketch . getFolder ( ) , "application." + platformName ) ; if ( ! exportApplication ( folder , platform , 0 , embedJava ) ) { return false ; } } } } return true ; } protected boolean exportApplication ( File destFolder , int exportPlatform , int exportBits , boolean embedJava ) throws IOException , SketchException { for ( Library library : importedLibraries ) { if ( ! library . supportsArch ( exportPlatform , exportBits ) ) { String pn = PConstants . platformNames [ exportPlatform ] ; Base . showWarning ( "Quibbles 'n Bits" , "The application." + pn + exportBits + " folder will not be created\n" + "because no " + exportBits + "-bit version of " + library . getName ( ) + " is available for " + pn , null ) ; return true ; } } mode . prepareExportFolder ( destFolder ) ; File jarFolder = new File ( destFolder , "lib" ) ; File dotAppFolder = null ; String jvmRuntime = "" ; String jdkPath = null ; if ( exportPlatform == PConstants . MACOSX ) { dotAppFolder = new File ( destFolder , sketch . getName ( ) + ".app" ) ; File contentsOrig = new File ( Base . getJavaHome ( ) , "../../../../.." ) ; if ( embedJava ) { File jdkFolder = new File ( Base . getJavaHome ( ) , "../../.." ) ; String jdkFolderName = jdkFolder . getCanonicalFile ( ) . getName ( ) ; jvmRuntime = "<key>JVMRuntime</key>\n <string>" + jdkFolderName + "</string>" ; jdkPath = new File ( dotAppFolder , "Contents/PlugIns/" + jdkFolderName ) . getAbsolutePath ( ) ; } File contentsFolder = new File ( dotAppFolder , "Contents" ) ; contentsFolder . mkdirs ( ) ; jarFolder = new File ( contentsFolder , "Java" ) ; File macosFolder = new File ( contentsFolder , "MacOS" ) ; macosFolder . mkdirs ( ) ; Base . copyFile ( new File ( contentsOrig , "MacOS/Processing" ) , new File ( contentsFolder , "MacOS/" + sketch . getName ( ) ) ) ; File pkgInfo = new File ( contentsFolder , "PkgInfo" ) ; PrintWriter writer = PApplet . createWriter ( pkgInfo ) ; writer . println ( "APPL????" ) ; writer . flush ( ) ; writer . close ( ) ; if ( embedJava ) { Base . copyDirNative ( new File ( contentsOrig , "PlugIns" ) , new File ( contentsFolder , "PlugIns" ) ) ; } File resourcesFolder = new File ( contentsFolder , "Resources" ) ; Base . copyDir ( new File ( contentsOrig , "Resources/en.lproj" ) , new File ( resourcesFolder , "en.lproj" ) ) ; Base . copyFile ( mode . getContentFile ( "application/sketch.icns" ) , new File ( resourcesFolder , "sketch.icns" ) ) ; } else if ( exportPlatform == PConstants . LINUX ) { if ( embedJava ) { Base . copyDirNative ( Base . getJavaHome ( ) , new File ( destFolder , "java" ) ) ; } } else if ( exportPlatform == PConstants . WINDOWS ) { if ( embedJava ) { Base . copyDir ( Base . getJavaHome ( ) , new File ( destFolder , "java" ) ) ; } } if ( ! jarFolder . exists ( ) ) jarFolder . mkdirs ( ) ; Vector < String > jarListVector = new Vector < String > ( ) ; FileOutputStream zipOutputFile = new FileOutputStream ( new File ( jarFolder , sketch . getName ( ) + ".jar" ) ) ; ZipOutputStream zos = new ZipOutputStream ( zipOutputFile ) ; addManifest ( zos ) ; addClasses ( zos , binFolder ) ; if ( sketch . hasDataFolder ( ) ) { if ( exportPlatform == PConstants . MACOSX ) { Base . copyDir ( sketch . getDataFolder ( ) , new File ( jarFolder , "data" ) ) ; } else { Base . copyDir ( sketch . getDataFolder ( ) , new File ( destFolder , "data" ) ) ; } } if ( sketch . hasCodeFolder ( ) ) { String includes = Base . contentsToClassPath ( sketch . getCodeFolder ( ) ) ; String [ ] codeList = PApplet . splitTokens ( includes , File . pathSeparator ) ; for ( int i = 0 ; i < codeList . length ; i ++ ) { if ( codeList [ i ] . toLowerCase ( ) . endsWith ( ".jar" ) || codeList [ i ] . toLowerCase ( ) . endsWith ( ".zip" ) ) { File exportFile = new File ( codeList [ i ] ) ; String exportFilename = exportFile . getName ( ) ; Base . copyFile ( exportFile , new File ( jarFolder , exportFilename ) ) ; jarListVector . add ( exportFilename ) ; } else { } } } zos . flush ( ) ; zos . close ( ) ; jarListVector . add ( sketch . getName ( ) + ".jar" ) ; for ( Library library : importedLibraries ) { for ( File exportFile : library . getApplicationExports ( exportPlatform , exportBits ) ) { String exportName = exportFile . getName ( ) ; if ( ! exportFile . exists ( ) ) { System . err . println ( exportFile . getName ( ) + " is mentioned in export.txt, but it's " + "a big fat lie and does not exist." ) ; } else if ( exportFile . isDirectory ( ) ) { Base . copyDir ( exportFile , new File ( jarFolder , exportName ) ) ; } else if ( exportName . toLowerCase ( ) . endsWith ( ".zip" ) || exportName . toLowerCase ( ) . endsWith ( ".jar" ) ) { Base . copyFile ( exportFile , new File ( jarFolder , exportName ) ) ; jarListVector . add ( exportName ) ; } else { Base . copyFile ( exportFile , new File ( jarFolder , exportName ) ) ; } } } String jarList [ ] = new String [ jarListVector . size ( ) ] ; jarListVector . copyInto ( jarList ) ; StringBuilder exportClassPath = new StringBuilder ( ) ; if ( exportPlatform == PConstants . MACOSX ) { for ( int i = 0 ; i < jarList . length ; i ++ ) { if ( i != 0 ) exportClassPath . append ( ":" ) ; exportClassPath . append ( "$JAVAROOT/" + jarList [ i ] ) ; } } else if ( exportPlatform == PConstants . WINDOWS ) { for ( int i = 0 ; i < jarList . length ; i ++ ) { if ( i != 0 ) exportClassPath . append ( "," ) ; exportClassPath . append ( jarList [ i ] ) ; } } else { exportClassPath . append ( "$APPDIR" ) ; for ( int i = 0 ; i < jarList . length ; i ++ ) { exportClassPath . append ( ":$APPDIR/lib/" + jarList [ i ] ) ; } } List < String > runOptions = new ArrayList < String > ( ) ; if ( Preferences . getBoolean ( "run.options.memory" ) ) { runOptions . add ( "-Xms" + Preferences . get ( "run.options.memory.initial" ) + "m" ) ; runOptions . add ( "-Xmx" + Preferences . get ( "run.options.memory.maximum" ) + "m" ) ; } runOptions . add ( "-Djna.nosys=true" ) ; if ( exportPlatform == PConstants . WINDOWS ) { runOptions . add ( "-Djava.library.path=\"%EXEDIR%\\lib\"" ) ; } if ( exportPlatform == PConstants . MACOSX ) { StringBuilder runOptionsXML = new StringBuilder ( ) ; for ( String opt : runOptions ) { runOptionsXML . append ( " <string>" ) ; runOptionsXML . append ( opt ) ; runOptionsXML . append ( "</string>" ) ; runOptionsXML . append ( '\n' ) ; } String PLIST_TEMPLATE = "Info.plist.tmpl" ; File plistTemplate = new File ( sketch . getFolder ( ) , PLIST_TEMPLATE ) ; if ( ! plistTemplate . exists ( ) ) { plistTemplate = mode . getContentFile ( "application/" + PLIST_TEMPLATE ) ; } File plistFile = new File ( dotAppFolder , "Contents/Info.plist" ) ; PrintWriter pw = PApplet . createWriter ( plistFile ) ; String lines [ ] = PApplet . loadStrings ( plistTemplate ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { if ( lines [ i ] . indexOf ( "@@" ) != - 1 ) { StringBuilder sb = new StringBuilder ( lines [ i ] ) ; int index = 0 ; while ( ( index = sb . indexOf ( "@@jvm_runtime@@" ) ) != - 1 ) { sb . replace ( index , index + "@@jvm_runtime@@" . length ( ) , jvmRuntime ) ; } while ( ( index = sb . indexOf ( "@@jvm_options_list@@" ) ) != - 1 ) { sb . replace ( index , index + "@@jvm_options_list@@" . length ( ) , runOptionsXML . toString ( ) ) ; } while ( ( index = sb . indexOf ( "@@sketch@@" ) ) != - 1 ) { sb . replace ( index , index + "@@sketch@@" . length ( ) , sketch . getName ( ) ) ; } while ( ( index = sb . indexOf ( "@@lsuipresentationmode@@" ) ) != - 1 ) { sb . replace ( index , index + "@@lsuipresentationmode@@" . length ( ) , Preferences . getBoolean ( "export.application.present" ) ? "4" : "0" ) ; } lines [ i ] = sb . toString ( ) ; } pw . print ( lines [ i ] + "\n" ) ; } pw . flush ( ) ; pw . close ( ) ; if ( Base . isMacOS ( ) && new File ( "/usr/bin/codesign_allocate" ) . exists ( ) ) { if ( embedJava ) { ProcessHelper . ffs ( "codesign" , "--force" , "--sign" , "-" , jdkPath ) ; } String appPath = dotAppFolder . getAbsolutePath ( ) ; ProcessHelper . ffs ( "codesign" , "--force" , "--sign" , "-" , appPath ) ; } } else if ( exportPlatform == PConstants . WINDOWS ) { File buildFile = new File ( destFolder , "launch4j-build.xml" ) ; File configFile = new File ( destFolder , "launch4j-config.xml" ) ; XML project = new XML ( "project" ) ; XML target = project . addChild ( "target" ) ; target . setString ( "name" , "windows" ) ; XML taskdef = target . addChild ( "taskdef" ) ; taskdef . setString ( "name" , "launch4j" ) ; taskdef . setString ( "classname" , "net.sf.launch4j.ant.Launch4jTask" ) ; String launchPath = mode . getContentFile ( "application/launch4j" ) . getAbsolutePath ( ) ; taskdef . setString ( "classpath" , launchPath + "/launch4j.jar:" + launchPath + "/lib/xstream.jar" ) ; XML launch4j = target . addChild ( "launch4j" ) ; launch4j . setString ( "configFile" , configFile . getAbsolutePath ( ) ) ; XML config = new XML ( "launch4jConfig" ) ; config . addChild ( "headerType" ) . setContent ( "gui" ) ; config . addChild ( "dontWrapJar" ) . setContent ( "true" ) ; config . addChild ( "downloadUrl" ) . setContent ( "http://java.com/download" ) ; File exeFile = new File ( destFolder , sketch . getName ( ) + ".exe" ) ; config . addChild ( "outfile" ) . setContent ( exeFile . getAbsolutePath ( ) ) ; File iconFile = mode . getContentFile ( "application/sketch.ico" ) ; config . addChild ( "icon" ) . setContent ( iconFile . getAbsolutePath ( ) ) ; XML clazzPath = config . addChild ( "classPath" ) ; clazzPath . addChild ( "mainClass" ) . setContent ( sketch . getName ( ) ) ; for ( String jarName : jarList ) { clazzPath . addChild ( "cp" ) . setContent ( "lib/" + jarName ) ; } XML jre = config . addChild ( "jre" ) ; if ( embedJava ) { jre . addChild ( "path" ) . setContent ( "java" ) ; } jre . addChild ( "minVersion" ) . setContent ( "1.7.0_40" ) ; for ( String opt : runOptions ) { jre . addChild ( "opt" ) . setContent ( opt ) ; } config . save ( configFile ) ; project . save ( buildFile ) ; if ( ! buildWindowsLauncher ( buildFile , "windows" ) ) { return false ; } configFile . delete ( ) ; buildFile . delete ( ) ; } else { File shellScript = new File ( destFolder , sketch . getName ( ) ) ; PrintWriter pw = PApplet . createWriter ( shellScript ) ; pw . print ( "#!/bin/sh\n\n" ) ; pw . print ( "APPDIR=$(dirname \"$0\")\n" ) ; if ( embedJava ) { pw . print ( "$APPDIR/java/bin/" ) ; } String runOptionsStr = PApplet . join ( runOptions . toArray ( new String [ 0 ] ) , " " ) ; pw . print ( "java " + runOptionsStr + " -Djava.library.path=\"$APPDIR:$APPDIR/lib\"" + " -cp \"" + exportClassPath + "\"" + " " + sketch . getName ( ) + " \"$@\"\n" ) ; pw . flush ( ) ; pw . close ( ) ; String shellPath = shellScript . getAbsolutePath ( ) ; if ( ! Base . isWindows ( ) ) { Runtime . getRuntime ( ) . exec ( new String [ ] { "chmod" , "+x" , shellPath } ) ; } } File sourceFolder = new File ( destFolder , "source" ) ; sourceFolder . mkdirs ( ) ; for ( SketchCode code : sketch . getCode ( ) ) { try { code . copyTo ( new File ( sourceFolder , code . getFileName ( ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } String preprocFilename = sketch . getName ( ) + ".java" ; File preprocFile = new File ( srcFolder , preprocFilename ) ; if ( preprocFile . exists ( ) ) { Base . copyFile ( preprocFile , new File ( sourceFolder , preprocFilename ) ) ; } else { System . err . println ( "Could not copy source file: " + preprocFile . getAbsolutePath ( ) ) ; } return true ; } protected boolean buildWindowsLauncher ( File buildFile , String target ) { Project p = new Project ( ) ; String path = buildFile . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; p . setUserProperty ( "ant.file" , path ) ; p . setUserProperty ( "build.compiler" , "extJavac" ) ; DefaultLogger errorLogger = new DefaultLogger ( ) ; ByteArrayOutputStream errb = new ByteArrayOutputStream ( ) ; PrintStream errp = new PrintStream ( errb ) ; errorLogger . setErrorPrintStream ( errp ) ; ByteArrayOutputStream outb = new ByteArrayOutputStream ( ) ; PrintStream outp = new PrintStream ( outb ) ; errorLogger . setOutputPrintStream ( outp ) ; errorLogger . setMessageOutputLevel ( Project . MSG_INFO ) ; p . addBuildListener ( errorLogger ) ; try { p . fireBuildStarted ( ) ; p . init ( ) ; final ProjectHelper helper = ProjectHelper . getProjectHelper ( ) ; p . addReference ( "ant.projectHelper" , helper ) ; helper . parse ( p , buildFile ) ; p . executeTarget ( target ) ; return true ; } catch ( final BuildException e ) { p . fireBuildFinished ( e ) ; String out = new String ( outb . toByteArray ( ) ) ; String err = new String ( errb . toByteArray ( ) ) ; System . out . println ( out ) ; System . err . println ( err ) ; } return false ; } protected void addManifest ( ZipOutputStream zos ) throws IOException { ZipEntry entry = new ZipEntry ( "META-INF/MANIFEST.MF" ) ; zos . putNextEntry ( entry ) ; String contents = "Manifest-Version: 1.0\n" + "Created-By: Processing " + Base . getVersionName ( ) + "\n" + "Main-Class: " + sketch . getName ( ) + "\n" ; zos . write ( contents . getBytes ( ) ) ; zos . closeEntry ( ) ; } protected void addClasses ( ZipOutputStream zos , File dir ) throws IOException { String path = dir . getAbsolutePath ( ) ; if ( ! path . endsWith ( "/" ) && ! path . endsWith ( "\\" ) ) { path += '/' ; } addClasses ( zos , dir , path ) ; } protected void addClasses ( ZipOutputStream zos , File dir , String rootPath ) throws IOException { File files [ ] = dir . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return ( name . charAt ( 0 ) != '.' ) ; } } ) ; for ( File sub : files ) { String relativePath = sub . getAbsolutePath ( ) . substring ( rootPath . length ( ) ) ; if ( sub . isDirectory ( ) ) { addClasses ( zos , sub , rootPath ) ; } else if ( sub . getName ( ) . endsWith ( ".class" ) ) { ZipEntry entry = new ZipEntry ( relativePath ) ; zos . putNextEntry ( entry ) ; PApplet . saveStream ( zos , new FileInputStream ( sub ) ) ; zos . closeEntry ( ) ; } } } protected void addDataFolder ( ZipOutputStream zos ) throws IOException { if ( sketch . hasDataFolder ( ) ) { String [ ] dataFiles = Base . listFiles ( sketch . getDataFolder ( ) , false ) ; int offset = sketch . getFolder ( ) . getAbsolutePath ( ) . length ( ) + 1 ; for ( String path : dataFiles ) { if ( Base . isWindows ( ) ) { path = path . replace ( '\\' , '/' ) ; } File dataFile = new File ( path ) ; if ( ! dataFile . isDirectory ( ) ) { if ( dataFile . getName ( ) . charAt ( 0 ) != '.' ) { ZipEntry entry = new ZipEntry ( path . substring ( offset ) ) ; zos . putNextEntry ( entry ) ; PApplet . saveStream ( zos , new FileInputStream ( dataFile ) ) ; zos . closeEntry ( ) ; } } } } } protected void packClassPathIntoZipFile ( String path , ZipOutputStream zos , HashMap < String , Object > zipFileContents ) throws IOException { String [ ] pieces = PApplet . split ( path , File . pathSeparatorChar ) ; for ( int i = 0 ; i < pieces . length ; i ++ ) { if ( pieces [ i ] . length ( ) == 0 ) continue ; if ( pieces [ i ] . toLowerCase ( ) . endsWith ( ".jar" ) || pieces [ i ] . toLowerCase ( ) . endsWith ( ".zip" ) ) { try { ZipFile file = new ZipFile ( pieces [ i ] ) ; Enumeration < ? > entries = file . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) entries . nextElement ( ) ; if ( entry . isDirectory ( ) ) { } else { String entryName = entry . getName ( ) ; if ( entryName . indexOf ( "META-INF" ) == 0 ) continue ; if ( zipFileContents . get ( entryName ) != null ) continue ; zipFileContents . put ( entryName , new Object ( ) ) ; ZipEntry entree = new ZipEntry ( entryName ) ; zos . putNextEntry ( entree ) ; byte buffer [ ] = new byte [ ( int ) entry . getSize ( ) ] ; InputStream is = file . getInputStream ( entry ) ; int offset = 0 ; int remaining = buffer . length ; while ( remaining > 0 ) { int count = is . read ( buffer , offset , remaining ) ; offset += count ; remaining -= count ; } zos . write ( buffer ) ; zos . flush ( ) ; zos . closeEntry ( ) ; } } file . close ( ) ; } catch ( IOException e ) { System . err . println ( "Error in file " + pieces [ i ] ) ; e . printStackTrace ( ) ; } } else { File dir = new File ( pieces [ i ] ) ; if ( dir . exists ( ) ) { packClassPathIntoZipFileRecursive ( dir , null , zos ) ; } } } } static protected void packClassPathIntoZipFileRecursive ( File dir , String sofar , ZipOutputStream zos ) throws IOException { String files [ ] = dir . list ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . charAt ( 0 ) == '.' ) continue ; File sub = new File ( dir , files [ i ] ) ; String nowfar = ( sofar == null ) ? files [ i ] : ( sofar + "/" + files [ i ] ) ; if ( sub . isDirectory ( ) ) { packClassPathIntoZipFileRecursive ( sub , nowfar , zos ) ; } else { if ( ! files [ i ] . toLowerCase ( ) . endsWith ( ".jar" ) && ! files [ i ] . toLowerCase ( ) . endsWith ( ".zip" ) && files [ i ] . charAt ( 0 ) != '.' ) { ZipEntry entry = new ZipEntry ( nowfar ) ; zos . putNextEntry ( entry ) ; PApplet . saveStream ( zos , new FileInputStream ( sub ) ) ; zos . closeEntry ( ) ; } } } } }
package processing . mode . java ; import java . io . File ; import java . io . IOException ; import java . util . logging . FileHandler ; import java . util . logging . Handler ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . swing . ImageIcon ; import processing . app . * ; import processing . mode . java . runner . Runner ; import processing . mode . java . tweak . SketchParser ; public class JavaMode extends Mode { public Editor createEditor ( Base base , String path , EditorState state ) { return new JavaEditor ( base , path , state , this ) ; } public JavaMode ( Base base , File folder ) { super ( base , folder ) ; initLogger ( ) ; loadPreferences ( ) ; loadIcons ( ) ; } private void loadIcons ( ) { classIcon = loadIcon ( "theme/icon_class_obj.png" ) ; methodIcon = loadIcon ( "theme/icon_methpub_obj.png" ) ; fieldIcon = loadIcon ( "theme/icon_field_protected_obj.png" ) ; localVarIcon = loadIcon ( "theme/icon_field_default_obj.png" ) ; } public String getTitle ( ) { return "Java" ; } public File [ ] getExampleCategoryFolders ( ) { return new File [ ] { new File ( examplesFolder , "Basics" ) , new File ( examplesFolder , "Topics" ) , new File ( examplesFolder , "Demos" ) , new File ( examplesFolder , "Books" ) } ; } public String getDefaultExtension ( ) { return "pde" ; } public String [ ] getExtensions ( ) { return new String [ ] { "pde" , "java" } ; } public String [ ] getIgnorable ( ) { return new String [ ] { "applet" , "application.macosx" , "application.windows" , "application.linux" } ; } public Library getCoreLibrary ( ) { if ( coreLibrary == null ) { File coreFolder = Base . getContentFile ( "core" ) ; coreLibrary = new Library ( coreFolder ) ; } return coreLibrary ; } public Runner handleRun ( Sketch sketch , RunnerListener listener ) throws SketchException { final JavaEditor editor = ( JavaEditor ) listener ; editor . errorCheckerService . quickErrorCheck ( ) ; if ( enableTweak ) { enableTweak = false ; return handleTweak ( sketch , listener , false ) ; } else { return handleLaunch ( sketch , listener , false ) ; } } public Runner handlePresent ( Sketch sketch , RunnerListener listener ) throws SketchException { final JavaEditor editor = ( JavaEditor ) listener ; editor . errorCheckerService . quickErrorCheck ( ) ; if ( enableTweak ) { enableTweak = false ; return handleTweak ( sketch , listener , true ) ; } else { return handleLaunch ( sketch , listener , true ) ; } } public Runner handleLaunch ( Sketch sketch , RunnerListener listener , final boolean present ) throws SketchException { JavaBuild build = new JavaBuild ( sketch ) ; String appletClassName = build . build ( true ) ; if ( appletClassName != null ) { final Runner runtime = new Runner ( build , listener ) ; new Thread ( new Runnable ( ) { public void run ( ) { runtime . launch ( present ) ; } } ) . start ( ) ; return runtime ; } return null ; } public Runner handleTweak ( Sketch sketch , RunnerListener listener , final boolean present ) throws SketchException { final JavaEditor editor = ( JavaEditor ) listener ; if ( isSketchModified ( sketch ) ) { editor . deactivateRun ( ) ; Base . showMessage ( Language . text ( "menu.file.save" ) , Language . text ( "tweak_mode.save_before_tweak" ) ) ; return null ; } JavaBuild build = new JavaBuild ( sketch ) ; String appletClassName = build . build ( true ) ; if ( appletClassName == null ) { return null ; } editor . initBaseCode ( ) ; boolean requiresTweak = SketchParser . containsTweakComment ( editor . baseCode ) ; final SketchParser parser = new SketchParser ( editor . baseCode , requiresTweak ) ; final boolean launchInteractive = editor . automateSketch ( sketch , parser ) ; build = new JavaBuild ( sketch ) ; appletClassName = build . build ( false ) ; if ( appletClassName != null ) { final Runner runtime = new Runner ( build , listener ) ; new Thread ( new Runnable ( ) { public void run ( ) { runtime . launch ( present ) ; if ( launchInteractive ) { editor . initEditorCode ( parser . allHandles , false ) ; editor . stopInteractiveMode ( parser . allHandles ) ; } } } ) . start ( ) ; if ( launchInteractive ) { editor . initEditorCode ( parser . allHandles , false ) ; editor . updateInterface ( parser . allHandles , parser . colorBoxes ) ; editor . startInteractiveMode ( ) ; } return runtime ; } return null ; } static private boolean isSketchModified ( Sketch sketch ) { for ( SketchCode sc : sketch . getCode ( ) ) { if ( sc . isModified ( ) ) { return true ; } } return false ; } public boolean handleExportApplication ( Sketch sketch ) throws SketchException , IOException { JavaBuild build = new JavaBuild ( sketch ) ; return build . exportApplication ( ) ; } void initLogger ( ) { final boolean VERBOSE_LOGGING = true ; final int LOG_SIZE = 512 * 1024 ; Logger globalLogger = Logger . getLogger ( "" ) ; if ( VERBOSE_LOGGING ) { globalLogger . setLevel ( Level . INFO ) ; } else { globalLogger . setLevel ( Level . WARNING ) ; } try { File logFolder = Base . getSettingsFile ( "debug" ) ; if ( ! logFolder . exists ( ) ) { logFolder . mkdir ( ) ; } File logFile = new File ( logFolder , "DebugMode.%g.log" ) ; Handler handler = new FileHandler ( logFile . getAbsolutePath ( ) , LOG_SIZE , 10 , false ) ; globalLogger . addHandler ( handler ) ; } catch ( IOException ex ) { Logger . getLogger ( JavaMode . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SecurityException ex ) { Logger . getLogger ( JavaMode . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } static public volatile boolean errorCheckEnabled = true ; static public volatile boolean warningsEnabled = true ; static public volatile boolean codeCompletionsEnabled = true ; static public volatile boolean debugOutputEnabled = false ; static public volatile boolean errorLogsEnabled = false ; static public volatile boolean autoSaveEnabled = true ; static public volatile boolean autoSavePromptEnabled = true ; static public volatile boolean defaultAutoSaveEnabled = true ; static public volatile boolean ccTriggerEnabled = false ; static public volatile boolean importSuggestEnabled = true ; static public int autoSaveInterval = 3 ; volatile public static int codeCompletionTriggerLength = 1 ; static public final String prefErrorCheck = "pdex.errorCheckEnabled" ; static public final String prefWarnings = "pdex.warningsEnabled" ; static public final String prefCodeCompletionEnabled = "pdex.completion" ; static public final String prefCCTriggerEnabled = "pdex.completion.trigger" ; static public final String prefDebugOP = "pdex.dbgOutput" ; static public final String prefErrorLogs = "pdex.writeErrorLogs" ; static public final String prefAutoSaveInterval = "pdex.autoSaveInterval" ; static public final String prefAutoSave = "pdex.autoSave.autoSaveEnabled" ; static public final String prefAutoSavePrompt = "pdex.autoSave.promptDisplay" ; static public final String prefDefaultAutoSave = "pdex.autoSave.autoSaveByDefault" ; static public final String prefImportSuggestEnabled = "pdex.importSuggestEnabled" ; static volatile public boolean enableTweak = false ; static public ImageIcon classIcon ; static public ImageIcon fieldIcon ; static public ImageIcon methodIcon ; static public ImageIcon localVarIcon ; public void loadPreferences ( ) { Base . log ( "Load PDEX prefs" ) ; ensurePrefsExist ( ) ; errorCheckEnabled = Preferences . getBoolean ( prefErrorCheck ) ; warningsEnabled = Preferences . getBoolean ( prefWarnings ) ; codeCompletionsEnabled = Preferences . getBoolean ( prefCodeCompletionEnabled ) ; errorLogsEnabled = Preferences . getBoolean ( prefErrorLogs ) ; autoSaveInterval = Preferences . getInteger ( prefAutoSaveInterval ) ; autoSaveEnabled = Preferences . getBoolean ( prefAutoSave ) ; autoSavePromptEnabled = Preferences . getBoolean ( prefAutoSavePrompt ) ; defaultAutoSaveEnabled = Preferences . getBoolean ( prefDefaultAutoSave ) ; ccTriggerEnabled = Preferences . getBoolean ( prefCCTriggerEnabled ) ; importSuggestEnabled = Preferences . getBoolean ( prefImportSuggestEnabled ) ; } public void savePreferences ( ) { Base . log ( "Saving PDEX prefs" ) ; Preferences . setBoolean ( prefErrorCheck , errorCheckEnabled ) ; Preferences . setBoolean ( prefWarnings , warningsEnabled ) ; Preferences . setBoolean ( prefCodeCompletionEnabled , codeCompletionsEnabled ) ; Preferences . setBoolean ( prefErrorLogs , errorLogsEnabled ) ; Preferences . setInteger ( prefAutoSaveInterval , autoSaveInterval ) ; Preferences . setBoolean ( prefAutoSave , autoSaveEnabled ) ; Preferences . setBoolean ( prefAutoSavePrompt , autoSavePromptEnabled ) ; Preferences . setBoolean ( prefDefaultAutoSave , defaultAutoSaveEnabled ) ; Preferences . setBoolean ( prefCCTriggerEnabled , ccTriggerEnabled ) ; Preferences . setBoolean ( prefImportSuggestEnabled , importSuggestEnabled ) ; } public void ensurePrefsExist ( ) { if ( Preferences . get ( prefErrorCheck ) == null ) Preferences . setBoolean ( prefErrorCheck , errorCheckEnabled ) ; if ( Preferences . get ( prefWarnings ) == null ) Preferences . setBoolean ( prefWarnings , warningsEnabled ) ; if ( Preferences . get ( prefCodeCompletionEnabled ) == null ) Preferences . setBoolean ( prefCodeCompletionEnabled , codeCompletionsEnabled ) ; if ( Preferences . get ( prefDebugOP ) == null ) if ( Preferences . get ( prefErrorLogs ) == null ) Preferences . setBoolean ( prefErrorLogs , errorLogsEnabled ) ; if ( Preferences . get ( prefAutoSaveInterval ) == null ) Preferences . setInteger ( prefAutoSaveInterval , autoSaveInterval ) ; if ( Preferences . get ( prefAutoSave ) == null ) Preferences . setBoolean ( prefAutoSave , autoSaveEnabled ) ; if ( Preferences . get ( prefAutoSavePrompt ) == null ) Preferences . setBoolean ( prefAutoSavePrompt , autoSavePromptEnabled ) ; if ( Preferences . get ( prefDefaultAutoSave ) == null ) Preferences . setBoolean ( prefDefaultAutoSave , defaultAutoSaveEnabled ) ; if ( Preferences . get ( prefCCTriggerEnabled ) == null ) Preferences . setBoolean ( prefCCTriggerEnabled , ccTriggerEnabled ) ; if ( Preferences . get ( prefImportSuggestEnabled ) == null ) Preferences . setBoolean ( prefImportSuggestEnabled , importSuggestEnabled ) ; } static public void main ( String [ ] args ) { processing . app . Base . main ( args ) ; } }
package processing . core ; public interface PMatrix { public void reset ( ) ; public PMatrix get ( ) ; public float [ ] get ( float [ ] target ) ; public void set ( PMatrix src ) ; public void set ( float [ ] source ) ; public void set ( float m00 , float m01 , float m02 , float m10 , float m11 , float m12 ) ; public void set ( float m00 , float m01 , float m02 , float m03 , float m10 , float m11 , float m12 , float m13 , float m20 , float m21 , float m22 , float m23 , float m30 , float m31 , float m32 , float m33 ) ; public void translate ( float tx , float ty ) ; public void translate ( float tx , float ty , float tz ) ; public void rotate ( float angle ) ; public void rotateX ( float angle ) ; public void rotateY ( float angle ) ; public void rotateZ ( float angle ) ; public void rotate ( float angle , float v0 , float v1 , float v2 ) ; public void scale ( float s ) ; public void scale ( float sx , float sy ) ; public void scale ( float x , float y , float z ) ; public void shearX ( float angle ) ; public void shearY ( float angle ) ; public void apply ( PMatrix source ) ; public void apply ( PMatrix2D source ) ; public void apply ( PMatrix3D source ) ; public void apply ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) ; public void apply ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) ; public void preApply ( PMatrix left ) ; public void preApply ( PMatrix2D left ) ; public void preApply ( PMatrix3D left ) ; public void preApply ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) ; public void preApply ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) ; public PVector mult ( PVector source , PVector target ) ; public float [ ] mult ( float [ ] source , float [ ] target ) ; public void transpose ( ) ; public boolean invert ( ) ; public float determinant ( ) ; }
package processing . mode . java ; import com . sun . jdi . * ; import com . sun . jdi . event . * ; import com . sun . jdi . request . * ; import java . io . * ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . swing . JTree ; import javax . swing . tree . DefaultMutableTreeNode ; import processing . app . Sketch ; import processing . app . SketchCode ; import processing . mode . java . debug . * ; import processing . mode . java . pdex . VMEventListener ; import processing . mode . java . pdex . VMEventReader ; import processing . mode . java . runner . Runner ; public class Debugger implements VMEventListener { protected JavaEditor editor ; protected Runner runtime ; protected boolean started = false ; protected boolean paused = false ; protected ThreadReference currentThread ; protected String mainClassName ; protected ReferenceType mainClass ; protected Set < ReferenceType > classes = new HashSet < ReferenceType > ( ) ; protected List < ClassLoadListener > classLoadListeners = new ArrayList < ClassLoadListener > ( ) ; protected String srcPath ; protected List < LineBreakpoint > breakpoints = new ArrayList < LineBreakpoint > ( ) ; protected StepRequest requestedStep ; protected Map < LineID , LineID > runtimeLineChanges = new HashMap < LineID , LineID > ( ) ; protected Set < String > runtimeTabsTracked = new HashSet < String > ( ) ; public Debugger ( JavaEditor editor ) { this . editor = editor ; } public VirtualMachine vm ( ) { if ( runtime != null ) { return runtime . vm ( ) ; } return null ; } public JavaEditor getEditor ( ) { return editor ; } public ReferenceType getMainClass ( ) { if ( isStarted ( ) ) { return mainClass ; } return null ; } public ReferenceType getClass ( String name ) { if ( name == null ) { return null ; } if ( name . equals ( mainClassName ) ) { return mainClass ; } for ( ReferenceType rt : classes ) { if ( rt . name ( ) . equals ( name ) ) { return rt ; } } return null ; } public void addClassLoadListener ( ClassLoadListener listener ) { classLoadListeners . add ( listener ) ; } public void removeClassLoadListener ( ClassLoadListener listener ) { classLoadListeners . remove ( listener ) ; } public synchronized void startDebug ( ) { if ( isStarted ( ) ) { return ; } editor . statusBusy ( ) ; editor . clearConsole ( ) ; editor . variableInspector ( ) . reset ( ) ; editor . prepareRun ( ) ; editor . activateDebug ( ) ; try { Sketch sketch = editor . getSketch ( ) ; JavaBuild build = new JavaBuild ( sketch ) ; log ( Level . INFO , "building sketch: {0}" , sketch . getName ( ) ) ; mainClassName = build . build ( true ) ; log ( Level . INFO , "class: {0}" , mainClassName ) ; srcPath = build . getSrcFolder ( ) . getPath ( ) ; log ( Level . INFO , "build src: {0}" , srcPath ) ; log ( Level . INFO , "build bin: {0}" , build . getBinFolder ( ) . getPath ( ) ) ; if ( mainClassName != null ) { log ( Level . INFO , "launching debuggee runtime" ) ; runtime = new Runner ( build , editor ) ; VirtualMachine vm = runtime . launchDebug ( ) ; if ( vm == null ) { log ( Level . SEVERE , "error 37: launch failed" ) ; } VMEventReader eventThread = new VMEventReader ( vm . eventQueue ( ) , this ) ; eventThread . start ( ) ; startTrackingLineChanges ( ) ; editor . statusBusy ( ) ; } } catch ( Exception e ) { editor . statusError ( e ) ; } } public synchronized void stopDebug ( ) { editor . variableInspector ( ) . lock ( ) ; if ( runtime != null ) { log ( Level . INFO , "closing runtime" ) ; runtime . close ( ) ; runtime = null ; classes . clear ( ) ; editor . clearCurrentLine ( ) ; } stopTrackingLineChanges ( ) ; started = false ; editor . deactivateDebug ( ) ; editor . deactivateContinue ( ) ; editor . deactivateStep ( ) ; editor . statusEmpty ( ) ; } public synchronized void continueDebug ( ) { editor . activateContinue ( ) ; editor . variableInspector ( ) . lock ( ) ; editor . clearCurrentLine ( ) ; if ( ! isStarted ( ) ) { startDebug ( ) ; } else if ( isPaused ( ) ) { runtime . vm ( ) . resume ( ) ; paused = false ; editor . statusBusy ( ) ; } } protected void step ( int stepDepth ) { if ( ! isStarted ( ) ) { startDebug ( ) ; } else if ( isPaused ( ) ) { editor . variableInspector ( ) . lock ( ) ; editor . activateStep ( ) ; requestedStep = runtime . vm ( ) . eventRequestManager ( ) . createStepRequest ( currentThread , StepRequest . STEP_LINE , stepDepth ) ; requestedStep . addCountFilter ( 1 ) ; requestedStep . enable ( ) ; paused = false ; runtime . vm ( ) . resume ( ) ; editor . statusBusy ( ) ; } } public synchronized void stepOver ( ) { step ( StepRequest . STEP_OVER ) ; } public synchronized void stepInto ( ) { step ( StepRequest . STEP_INTO ) ; } public synchronized void stepOut ( ) { step ( StepRequest . STEP_OUT ) ; } synchronized void setBreakpoint ( ) { setBreakpoint ( editor . getCurrentLineID ( ) ) ; } synchronized void setBreakpoint ( int lineIdx ) { setBreakpoint ( editor . getLineIDInCurrentTab ( lineIdx ) ) ; } synchronized void setBreakpoint ( LineID line ) { if ( isStarted ( ) && ! isPaused ( ) ) { return ; } if ( hasBreakpoint ( line ) ) { return ; } breakpoints . add ( new LineBreakpoint ( line , this ) ) ; log ( Level . INFO , "set breakpoint on line {0}" , line ) ; } synchronized void removeBreakpoint ( ) { removeBreakpoint ( editor . getCurrentLineID ( ) . lineIdx ( ) ) ; } void removeBreakpoint ( int lineIdx ) { if ( isBusy ( ) ) { return ; } LineBreakpoint bp = breakpointOnLine ( editor . getLineIDInCurrentTab ( lineIdx ) ) ; if ( bp != null ) { bp . remove ( ) ; breakpoints . remove ( bp ) ; log ( Level . INFO , "removed breakpoint {0}" , bp ) ; } } synchronized void clearBreakpoints ( ) { if ( isBusy ( ) ) { log ( Level . WARNING , "busy" ) ; return ; } for ( LineBreakpoint bp : breakpoints ) { bp . remove ( ) ; } breakpoints . clear ( ) ; } synchronized void clearBreakpoints ( String tabFilename ) { if ( isBusy ( ) ) { log ( Level . WARNING , "busy" ) ; return ; } Iterator < LineBreakpoint > i = breakpoints . iterator ( ) ; while ( i . hasNext ( ) ) { LineBreakpoint bp = i . next ( ) ; if ( bp . lineID ( ) . fileName ( ) . equals ( tabFilename ) ) { bp . remove ( ) ; i . remove ( ) ; } } } LineBreakpoint breakpointOnLine ( LineID line ) { for ( LineBreakpoint bp : breakpoints ) { if ( bp . isOnLine ( line ) ) { return bp ; } } return null ; } synchronized void toggleBreakpoint ( int lineIdx ) { LineID line = editor . getLineIDInCurrentTab ( lineIdx ) ; if ( hasBreakpoint ( line ) ) { removeBreakpoint ( line . lineIdx ( ) ) ; } else { setBreakpoint ( line . lineIdx ( ) ) ; } } protected boolean hasBreakpoint ( LineID line ) { LineBreakpoint bp = breakpointOnLine ( line ) ; return bp != null ; } synchronized List < LineBreakpoint > getBreakpoints ( String tabFilename ) { List < LineBreakpoint > list = new ArrayList < LineBreakpoint > ( ) ; for ( LineBreakpoint bp : breakpoints ) { if ( bp . lineID ( ) . fileName ( ) . equals ( tabFilename ) ) { list . add ( bp ) ; } } return list ; } @ Override public synchronized void vmEvent ( EventSet es ) { for ( Event e : es ) { log ( Level . INFO , "*** VM Event: {0}" , e . toString ( ) ) ; if ( e instanceof VMStartEvent ) { vmStartEvent ( ) ; } else if ( e instanceof ClassPrepareEvent ) { vmClassPrepareEvent ( ( ClassPrepareEvent ) e ) ; } else if ( e instanceof BreakpointEvent ) { vmBreakPointEvent ( ( BreakpointEvent ) e ) ; } else if ( e instanceof StepEvent ) { vmStepEvent ( ( StepEvent ) e ) ; } else if ( e instanceof VMDisconnectEvent ) { stopDebug ( ) ; } else if ( e instanceof VMDeathEvent ) { started = false ; editor . statusEmpty ( ) ; } } } private void vmStartEvent ( ) { log ( Level . INFO , "requesting event on main class load: {0}" , mainClassName ) ; ClassPrepareRequest mainClassPrepare = runtime . vm ( ) . eventRequestManager ( ) . createClassPrepareRequest ( ) ; mainClassPrepare . addClassFilter ( mainClassName ) ; mainClassPrepare . enable ( ) ; for ( SketchCode tab : editor . getSketch ( ) . getCode ( ) ) { if ( tab . isExtension ( "java" ) ) { log ( Level . INFO , "requesting event on class load: {0}" , tab . getPrettyName ( ) ) ; ClassPrepareRequest customClassPrepare = runtime . vm ( ) . eventRequestManager ( ) . createClassPrepareRequest ( ) ; customClassPrepare . addClassFilter ( tab . getPrettyName ( ) ) ; customClassPrepare . enable ( ) ; } } runtime . vm ( ) . resume ( ) ; } private void vmClassPrepareEvent ( ClassPrepareEvent ce ) { ReferenceType rt = ce . referenceType ( ) ; currentThread = ce . thread ( ) ; paused = true ; if ( rt . name ( ) . equals ( mainClassName ) ) { mainClass = rt ; log ( Level . INFO , "main class load: {0}" , rt . name ( ) ) ; started = true ; } else { classes . add ( rt ) ; log ( Level . INFO , "class load: {0}" , rt . name ( ) ) ; } for ( ClassLoadListener listener : classLoadListeners ) { if ( listener != null ) { listener . classLoaded ( rt ) ; } } paused = false ; runtime . vm ( ) . resume ( ) ; } private void vmBreakPointEvent ( BreakpointEvent be ) { currentThread = be . thread ( ) ; updateVariableInspector ( currentThread ) ; final LineID newCurrentLine = locationToLineID ( be . location ( ) ) ; javax . swing . SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { editor . setCurrentLine ( newCurrentLine ) ; editor . deactivateStep ( ) ; editor . deactivateContinue ( ) ; } } ) ; if ( requestedStep != null ) { runtime . vm ( ) . eventRequestManager ( ) . deleteEventRequest ( requestedStep ) ; requestedStep = null ; } resumeOtherThreads ( currentThread ) ; paused = true ; editor . statusHalted ( ) ; } private void vmStepEvent ( StepEvent se ) { currentThread = se . thread ( ) ; updateVariableInspector ( currentThread ) ; final LineID newCurrentLine = locationToLineID ( se . location ( ) ) ; javax . swing . SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { editor . setCurrentLine ( newCurrentLine ) ; editor . deactivateStep ( ) ; editor . deactivateContinue ( ) ; } } ) ; EventRequestManager mgr = runtime . vm ( ) . eventRequestManager ( ) ; mgr . deleteEventRequest ( se . request ( ) ) ; requestedStep = null ; paused = true ; editor . statusHalted ( ) ; if ( ! locationIsVisible ( se . location ( ) ) ) { stepOutIntoViewOrContinue ( ) ; } } protected boolean locationIsVisible ( Location l ) { return locationToLineID ( l ) != null ; } protected void stepOutIntoViewOrContinue ( ) { try { List < StackFrame > frames = currentThread . frames ( ) ; if ( frames . size ( ) > 1 ) { if ( locationIsVisible ( frames . get ( 1 ) . location ( ) ) ) { stepOut ( ) ; return ; } } continueDebug ( ) ; } catch ( IncompatibleThreadStateException ex ) { log ( Level . SEVERE , null , ex ) ; } } public synchronized boolean isStarted ( ) { return started && runtime != null && runtime . vm ( ) != null ; } public synchronized boolean isPaused ( ) { return isStarted ( ) && paused && currentThread != null && currentThread . isSuspended ( ) ; } public synchronized boolean isBusy ( ) { return isStarted ( ) && ! isPaused ( ) ; } protected void printStackTrace ( ThreadReference t ) { if ( ! t . isSuspended ( ) ) { return ; } try { System . out . println ( "stack trace for thread " + t . name ( ) + ":" ) ; int i = 0 ; for ( StackFrame f : t . frames ( ) ) { System . out . println ( i ++ + ": " + f . toString ( ) ) ; } } catch ( IncompatibleThreadStateException ex ) { log ( Level . SEVERE , null , ex ) ; } } protected void resumeOtherThreads ( ThreadReference t ) { if ( ! isStarted ( ) ) { return ; } for ( ThreadReference other : vm ( ) . allThreads ( ) ) { if ( ! other . equals ( t ) && other . isSuspended ( ) ) { other . resume ( ) ; } } } public synchronized void printThreads ( ) { if ( ! isPaused ( ) ) { return ; } System . out . println ( "threads:" ) ; for ( ThreadReference t : vm ( ) . allThreads ( ) ) { printThread ( t ) ; } } protected void printThread ( ThreadReference t ) { System . out . println ( t . name ( ) ) ; System . out . println ( " is suspended: " + t . isSuspended ( ) ) ; System . out . println ( " is at breakpoint: " + t . isAtBreakpoint ( ) ) ; System . out . println ( " status: " + threadStatusToString ( t . status ( ) ) ) ; } protected String threadStatusToString ( int status ) { switch ( status ) { case ThreadReference . THREAD_STATUS_MONITOR : return "THREAD_STATUS_MONITOR" ; case ThreadReference . THREAD_STATUS_NOT_STARTED : return "THREAD_STATUS_NOT_STARTED" ; case ThreadReference . THREAD_STATUS_RUNNING : return "THREAD_STATUS_RUNNING" ; case ThreadReference . THREAD_STATUS_SLEEPING : return "THREAD_STATUS_SLEEPING" ; case ThreadReference . THREAD_STATUS_UNKNOWN : return "THREAD_STATUS_UNKNOWN" ; case ThreadReference . THREAD_STATUS_WAIT : return "THREAD_STATUS_WAIT" ; case ThreadReference . THREAD_STATUS_ZOMBIE : return "THREAD_STATUS_ZOMBIE" ; default : return "" ; } } protected void printLocalVariables ( ThreadReference t ) { if ( ! t . isSuspended ( ) ) { return ; } try { if ( t . frameCount ( ) == 0 ) { System . out . println ( "call stack empty" ) ; } else { StackFrame sf = t . frame ( 0 ) ; List < LocalVariable > locals = sf . visibleVariables ( ) ; if ( locals . isEmpty ( ) ) { System . out . println ( "no local variables" ) ; return ; } for ( LocalVariable lv : locals ) { System . out . println ( lv . typeName ( ) + " " + lv . name ( ) + " = " + sf . getValue ( lv ) ) ; } } } catch ( IncompatibleThreadStateException ex ) { log ( Level . SEVERE , null , ex ) ; } catch ( AbsentInformationException ex ) { System . out . println ( "local variable information not available" ) ; } } protected void updateVariableInspector ( ThreadReference t ) { if ( ! t . isSuspended ( ) ) { return ; } try { if ( t . frameCount ( ) == 0 ) { log ( Level . WARNING , "call stack empty" ) ; } else { final VariableInspector vi = editor . variableInspector ( ) ; final List < DefaultMutableTreeNode > stackTrace = getStackTrace ( t ) ; final List < VariableNode > locals = getLocals ( t , 0 ) ; final String currentLocation = currentLocation ( t ) ; final List < VariableNode > thisFields = getThisFields ( t , 0 , true ) ; final List < VariableNode > declaredThisFields = getThisFields ( t , 0 , false ) ; final String thisName = thisName ( t ) ; javax . swing . SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { vi . updateCallStack ( stackTrace , "Call Stack" ) ; vi . updateLocals ( locals , "Locals at " + currentLocation ) ; vi . updateThisFields ( thisFields , "Class " + thisName ) ; vi . updateDeclaredThisFields ( declaredThisFields , "Class " + thisName ) ; vi . unlock ( ) ; vi . rebuild ( ) ; } } ) ; } } catch ( IncompatibleThreadStateException ex ) { log ( Level . SEVERE , null , ex ) ; } } protected String thisName ( ThreadReference t ) { try { if ( ! t . isSuspended ( ) || t . frameCount ( ) == 0 ) { return "" ; } return t . frame ( 0 ) . thisObject ( ) . referenceType ( ) . name ( ) ; } catch ( IncompatibleThreadStateException ex ) { log ( Level . SEVERE , null , ex ) ; return "" ; } } protected String currentLocation ( ThreadReference t ) { try { if ( ! t . isSuspended ( ) || t . frameCount ( ) == 0 ) { return "" ; } return locationToString ( t . frame ( 0 ) . location ( ) ) ; } catch ( IncompatibleThreadStateException ex ) { log ( Level . SEVERE , null , ex ) ; return "" ; } } protected String locationToString ( Location loc ) { LineID line = locationToLineID ( loc ) ; int lineNumber = ( line != null ) ? ( line . lineIdx ( ) + 1 ) : loc . lineNumber ( ) ; return loc . declaringType ( ) . name ( ) + "." + loc . method ( ) . name ( ) + ":" + lineNumber ; } protected List < VariableNode > getLocals ( ThreadReference t , int depth ) { List < VariableNode > vars = new ArrayList < VariableNode > ( ) ; try { if ( t . frameCount ( ) > 0 ) { StackFrame sf = t . frame ( 0 ) ; for ( LocalVariable lv : sf . visibleVariables ( ) ) { Value val = sf . getValue ( lv ) ; VariableNode var = new LocalVariableNode ( lv . name ( ) , lv . typeName ( ) , val , lv , sf ) ; if ( depth > 0 ) { var . addChildren ( getFields ( val , depth - 1 , true ) ) ; } vars . add ( var ) ; } } } catch ( IncompatibleThreadStateException ex ) { log ( Level . SEVERE , null , ex ) ; } catch ( AbsentInformationException ex ) { log ( Level . WARNING , "local variable information not available" , ex ) ; } return vars ; } protected List < VariableNode > getThisFields ( ThreadReference t , int depth , boolean includeInherited ) { try { if ( t . frameCount ( ) > 0 ) { StackFrame sf = t . frame ( 0 ) ; ObjectReference thisObj = sf . thisObject ( ) ; return getFields ( thisObj , depth , includeInherited ) ; } } catch ( IncompatibleThreadStateException ex ) { log ( Level . SEVERE , null , ex ) ; } return new ArrayList < VariableNode > ( ) ; } protected List < VariableNode > getFields ( Value value , int depth , int maxDepth , boolean includeInherited ) { List < VariableNode > vars = new ArrayList < VariableNode > ( ) ; if ( depth <= maxDepth ) { if ( value instanceof ArrayReference ) { return getArrayFields ( ( ArrayReference ) value ) ; } else if ( value instanceof ObjectReference ) { ObjectReference obj = ( ObjectReference ) value ; List < Field > fields = includeInherited ? obj . referenceType ( ) . visibleFields ( ) : obj . referenceType ( ) . fields ( ) ; for ( Field field : fields ) { Value val = obj . getValue ( field ) ; VariableNode var = new FieldNode ( field . name ( ) , field . typeName ( ) , val , field , obj ) ; if ( val != null ) { var . addChildren ( getFields ( val , depth + 1 , maxDepth , includeInherited ) ) ; } vars . add ( var ) ; } } } return vars ; } public List < VariableNode > getFields ( Value value , int maxDepth , boolean includeInherited ) { return getFields ( value , 0 , maxDepth , includeInherited ) ; } protected List < VariableNode > getArrayFields ( ArrayReference array ) { List < VariableNode > fields = new ArrayList < VariableNode > ( ) ; if ( array != null ) { String arrayType = array . type ( ) . name ( ) ; if ( arrayType . endsWith ( "[]" ) ) { arrayType = arrayType . substring ( 0 , arrayType . length ( ) - 2 ) ; } int i = 0 ; for ( Value val : array . getValues ( ) ) { VariableNode var = new ArrayFieldNode ( "[" + i + "]" , arrayType , val , array , i ) ; fields . add ( var ) ; i ++ ; } } return fields ; } protected List < DefaultMutableTreeNode > getStackTrace ( ThreadReference t ) { List < DefaultMutableTreeNode > stack = new ArrayList < DefaultMutableTreeNode > ( ) ; try { for ( StackFrame f : t . frames ( ) ) { stack . add ( new DefaultMutableTreeNode ( locationToString ( f . location ( ) ) ) ) ; } } catch ( IncompatibleThreadStateException ex ) { log ( Level . SEVERE , null , ex ) ; } return stack ; } protected void printThis ( ThreadReference t ) { if ( ! t . isSuspended ( ) ) { return ; } try { if ( t . frameCount ( ) == 0 ) { System . out . println ( "call stack empty" ) ; } else { StackFrame sf = t . frame ( 0 ) ; ObjectReference thisObject = sf . thisObject ( ) ; if ( this != null ) { ReferenceType type = thisObject . referenceType ( ) ; System . out . println ( "fields in this (" + type . name ( ) + "):" ) ; for ( Field f : type . visibleFields ( ) ) { System . out . println ( f . typeName ( ) + " " + f . name ( ) + " = " + thisObject . getValue ( f ) ) ; } } else { System . out . println ( "can't get this (in native or static method)" ) ; } } } catch ( IncompatibleThreadStateException ex ) { log ( Level . SEVERE , null , ex ) ; } } protected void printSourceLocation ( ThreadReference t ) { try { if ( t . frameCount ( ) == 0 ) { System . out . println ( "call stack empty" ) ; } else { Location l = t . frame ( 0 ) . location ( ) ; printSourceLocation ( l ) ; } } catch ( IncompatibleThreadStateException ex ) { log ( Level . SEVERE , null , ex ) ; } } protected void printSourceLocation ( Location l ) { try { System . out . println ( "in method " + l . method ( ) + ":" ) ; System . out . println ( getSourceLine ( l . sourcePath ( ) , l . lineNumber ( ) , 2 ) ) ; } catch ( AbsentInformationException ex ) { log ( Level . SEVERE , null , ex ) ; } } protected String getSourceLine ( String filePath , int lineNo , int radius ) { if ( lineNo == - 1 ) { log ( Level . SEVERE , "invalid line number: {0}" , lineNo ) ; return "" ; } File f = new File ( srcPath + File . separator + filePath ) ; String output = "" ; try { BufferedReader r = new BufferedReader ( new FileReader ( f ) ) ; int i = 1 ; while ( i <= lineNo + radius ) { String line = r . readLine ( ) ; if ( line == null ) { break ; } if ( i >= lineNo - radius ) { if ( i > lineNo - radius ) { output += "\n" ; } output += f . getName ( ) + ":" + i + ( i == lineNo ? " => " : " " ) + line ; } i ++ ; } r . close ( ) ; return output ; } catch ( FileNotFoundException ex ) { return f . getName ( ) + ":" + lineNo ; } catch ( IOException ex ) { log ( Level . SEVERE , null , ex ) ; return "" ; } } protected void printType ( ReferenceType rt ) { System . out . println ( "ref.type: " + rt ) ; System . out . println ( "name: " + rt . name ( ) ) ; try { System . out . println ( "sourceName: " + rt . sourceName ( ) ) ; } catch ( AbsentInformationException ex ) { System . out . println ( "sourceName: unknown" ) ; } System . out . println ( "methods:" ) ; for ( Method m : rt . methods ( ) ) { System . out . println ( m . toString ( ) ) ; } } protected LineID locationToLineID ( Location l ) { try { return javaToSketchLine ( new LineID ( l . sourceName ( ) , l . lineNumber ( ) - 1 ) ) ; } catch ( AbsentInformationException ex ) { log ( Level . SEVERE , null , ex ) ; return null ; } } public LineID javaToSketchLine ( LineID javaLine ) { Sketch sketch = editor . getSketch ( ) ; SketchCode tab = editor . getTab ( javaLine . fileName ( ) ) ; if ( tab != null && tab . isExtension ( "java" ) ) { return originalToRuntimeLine ( javaLine ) ; } if ( ! javaLine . fileName ( ) . equals ( sketch . getName ( ) + ".java" ) ) { return null ; } for ( int i = sketch . getCodeCount ( ) - 1 ; i >= 0 ; i -- ) { tab = sketch . getCode ( i ) ; if ( tab . isExtension ( "pde" ) && tab . getPreprocOffset ( ) <= javaLine . lineIdx ( ) ) { final int index = javaLine . lineIdx ( ) - tab . getPreprocOffset ( ) ; return originalToRuntimeLine ( new LineID ( tab . getFileName ( ) , index ) ) ; } } return null ; } protected LineID originalToRuntimeLine ( LineID line ) { LineID transformed = runtimeLineChanges . get ( line ) ; if ( transformed == null ) { return line ; } return transformed ; } protected LineID runtimeToOriginalLine ( LineID line ) { for ( Entry < LineID , LineID > entry : runtimeLineChanges . entrySet ( ) ) { if ( entry . getValue ( ) . equals ( line ) ) { return entry . getKey ( ) ; } } return line ; } public LineID sketchToJavaLine ( LineID sketchLine ) { sketchLine = runtimeToOriginalLine ( sketchLine ) ; SketchCode tab = editor . getTab ( sketchLine . fileName ( ) ) ; if ( tab == null ) { return null ; } if ( tab . isExtension ( "java" ) ) { return sketchLine ; } LineID javaLine = new LineID ( editor . getSketch ( ) . getName ( ) + ".java" , sketchLine . lineIdx ( ) + tab . getPreprocOffset ( ) ) ; return javaLine ; } protected void startTrackingLineChanges ( ) { SketchCode tab = editor . getSketch ( ) . getCurrentCode ( ) ; if ( runtimeTabsTracked . contains ( tab . getFileName ( ) ) ) { return ; } for ( int i = 0 ; i < tab . getLineCount ( ) ; i ++ ) { LineID old = new LineID ( tab . getFileName ( ) , i ) ; LineID tracked = new LineID ( tab . getFileName ( ) , i ) ; tracked . startTracking ( editor . currentDocument ( ) ) ; runtimeLineChanges . put ( old , tracked ) ; } runtimeTabsTracked . add ( tab . getFileName ( ) ) ; } protected void stopTrackingLineChanges ( ) { for ( LineID tracked : runtimeLineChanges . values ( ) ) { tracked . stopTracking ( ) ; } runtimeLineChanges . clear ( ) ; runtimeTabsTracked . clear ( ) ; } static private void log ( Level level , String msg ) { Logger . getLogger ( Debugger . class . getName ( ) ) . log ( level , msg ) ; } static private void log ( Level level , String msg , Object obj ) { Logger . getLogger ( Debugger . class . getName ( ) ) . log ( level , msg , obj ) ; } }
package processing . mode . java ; import processing . app . * ; import processing . core . * ; import java . io . * ; import java . lang . reflect . Method ; import java . util . HashMap ; public class Compiler { static HashMap < String , String > importSuggestions ; static { importSuggestions = new HashMap < String , String > ( ) ; importSuggestions . put ( "Arrays" , "java.util.Arrays" ) ; importSuggestions . put ( "Collections" , "java.util.Collections" ) ; importSuggestions . put ( "Date" , "java.util.Date" ) ; importSuggestions . put ( "Frame" , "java.awt.Frame" ) ; importSuggestions . put ( "Iterator" , "java.util.Iterator" ) ; } static public boolean compile ( JavaBuild build ) throws SketchException { SketchException exception = null ; boolean success = false ; String baseCommand [ ] = new String [ ] { "-g" , "-Xemacs" , "-source" , "1.7" , "-target" , "1.7" , "-classpath" , build . getClassPath ( ) , "-nowarn" , "-d" , build . getBinFolder ( ) . getAbsolutePath ( ) } ; String [ ] sourceFiles = Base . listFiles ( build . getSrcFolder ( ) , false , ".java" ) ; String [ ] command = PApplet . concat ( baseCommand , sourceFiles ) ; try { final StringBuilder errorBuffer = new StringBuilder ( ) ; Writer internalWriter = new Writer ( ) { public void write ( char [ ] buf , int off , int len ) { errorBuffer . append ( buf , off , len ) ; } public void flush ( ) { } public void close ( ) { } } ; PrintWriter writer = new PrintWriter ( internalWriter ) ; PrintWriter outWriter = new PrintWriter ( System . out ) ; ClassLoader loader = build . mode . getClassLoader ( ) ; try { Class < ? > batchClass = Class . forName ( "org.eclipse.jdt.core.compiler.batch.BatchCompiler" , false , loader ) ; Class < ? > progressClass = Class . forName ( "org.eclipse.jdt.core.compiler.CompilationProgress" , false , loader ) ; Class < ? > [ ] compileArgs = new Class < ? > [ ] { String [ ] . class , PrintWriter . class , PrintWriter . class , progressClass } ; Method compileMethod = batchClass . getMethod ( "compile" , compileArgs ) ; success = ( Boolean ) compileMethod . invoke ( null , new Object [ ] { command , outWriter , writer , null } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new SketchException ( "Unknown error inside the compiler." ) ; } writer . flush ( ) ; writer . close ( ) ; BufferedReader reader = new BufferedReader ( new StringReader ( errorBuffer . toString ( ) ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { String errorFormat = "([\\w\\d_]+.java):(\\d+):\\s*(.*):\\s*(.*)\\s*" ; String [ ] pieces = PApplet . match ( line , errorFormat ) ; if ( pieces == null ) { exception = new SketchException ( "Cannot parse error text: " + line ) ; exception . hideStackTrace ( ) ; System . err . println ( line ) ; while ( ( line = reader . readLine ( ) ) != null ) { System . err . println ( line ) ; } break ; } String dotJavaFilename = pieces [ 1 ] ; int dotJavaLineIndex = PApplet . parseInt ( pieces [ 2 ] ) - 1 ; String errorMessage = pieces [ 4 ] ; exception = build . placeException ( errorMessage , dotJavaFilename , dotJavaLineIndex ) ; if ( exception == null ) { exception = new SketchException ( errorMessage ) ; } if ( errorMessage . startsWith ( "The import " ) && errorMessage . endsWith ( "cannot be resolved" ) ) { String [ ] m = PApplet . match ( errorMessage , "The import (.*) cannot be resolved" ) ; if ( m != null ) { if ( m [ 1 ] . equals ( "processing.xml" ) ) { exception . setMessage ( "processing.xml no longer exists, this code needs to be updated for 2.0." ) ; System . err . println ( "The processing.xml library has been replaced " + "with a new 'XML' class that's built-in." ) ; handleCrustyCode ( ) ; } else { exception . setMessage ( "The package " + "\u201C" + m [ 1 ] + "\u201D" + " does not exist. " + "You might be missing a library." ) ; System . err . println ( "Libraries must be " + "installed in a folder named 'libraries' " + "inside the 'sketchbook' folder." ) ; } } } else if ( errorMessage . endsWith ( "cannot be resolved to a type" ) ) { String what = errorMessage . substring ( 0 , errorMessage . indexOf ( ' ' ) ) ; if ( what . equals ( "BFont" ) || what . equals ( "BGraphics" ) || what . equals ( "BImage" ) ) { exception . setMessage ( what + " has been replaced with P" + what . substring ( 1 ) ) ; handleCrustyCode ( ) ; } else { exception . setMessage ( "Cannot find a class or type " + "named \u201C" + what + "\u201D" ) ; String suggestion = importSuggestions . get ( what ) ; if ( suggestion != null ) { System . err . println ( "You may need to add \"import " + suggestion + ";\" to the top of your sketch." ) ; System . err . println ( "To make sketches more portable, imports that are not part of the Processing API have been removed from Processing 2.0." ) ; System . err . println ( "See the changes page for more information: http://wiki.processing.org/w/Changes" ) ; } } } else if ( errorMessage . endsWith ( "cannot be resolved" ) ) { String what = errorMessage . substring ( 0 , errorMessage . indexOf ( ' ' ) ) ; if ( what . equals ( "LINE_LOOP" ) || what . equals ( "LINE_STRIP" ) ) { exception . setMessage ( "LINE_LOOP and LINE_STRIP are not available, " + "please update your code." ) ; handleCrustyCode ( ) ; } else if ( what . equals ( "framerate" ) ) { exception . setMessage ( "framerate should be changed to frameRate." ) ; handleCrustyCode ( ) ; } else if ( what . equals ( "screen" ) ) { exception . setMessage ( "Change screen.width and screen.height to " + "displayWidth and displayHeight." ) ; handleCrustyCode ( ) ; } else if ( what . equals ( "screenWidth" ) || what . equals ( "screenHeight" ) ) { exception . setMessage ( "Change screenWidth and screenHeight to " + "displayWidth and displayHeight." ) ; handleCrustyCode ( ) ; } else { exception . setMessage ( "Cannot find anything " + "named \u201C" + what + "\u201D" ) ; } } else if ( errorMessage . startsWith ( "Duplicate" ) ) { } else { String [ ] parts = null ; String undefined = "The method (\\S+\\(.*\\)) is undefined for the type (.*)" ; parts = PApplet . match ( errorMessage , undefined ) ; if ( parts != null ) { if ( parts [ 1 ] . equals ( "framerate(int)" ) ) { exception . setMessage ( "framerate() no longer exists, use frameRate() instead." ) ; handleCrustyCode ( ) ; } else if ( parts [ 1 ] . equals ( "push()" ) ) { exception . setMessage ( "push() no longer exists, use pushMatrix() instead." ) ; handleCrustyCode ( ) ; } else if ( parts [ 1 ] . equals ( "pop()" ) ) { exception . setMessage ( "pop() no longer exists, use popMatrix() instead." ) ; handleCrustyCode ( ) ; } else { String mess = "The function " + parts [ 1 ] + " does not exist." ; exception . setMessage ( mess ) ; } break ; } } if ( exception != null ) { exception . hideStackTrace ( ) ; break ; } } } catch ( IOException e ) { String bigSigh = "Error while compiling. (" + e . getMessage ( ) + ")" ; exception = new SketchException ( bigSigh ) ; e . printStackTrace ( ) ; success = false ; } if ( exception != null ) throw exception ; return success ; } static protected void handleCrustyCode ( ) { System . err . println ( "This code needs to be updated " + "for this version of Processing, " + "please read the Changes page on the Wiki." ) ; Editor . showChanges ( ) ; } protected int caretColumn ( String caretLine ) { return caretLine . indexOf ( "^" ) ; } }
package processing . mode . java ; import processing . app . Editor ; import processing . app . Preferences ; import processing . app . Sketch ; import processing . app . syntax . * ; import java . awt . * ; import java . awt . event . * ; import java . util . Arrays ; public class JavaInputHandler extends PdeInputHandler { private Editor editor ; static final int CTRL_ALT = ActionEvent . ALT_MASK | Toolkit . getDefaultToolkit ( ) . getMenuShortcutKeyMask ( ) ; public JavaInputHandler ( Editor editor ) { this . editor = editor ; } public boolean handlePressed ( KeyEvent event ) { char c = event . getKeyChar ( ) ; int code = event . getKeyCode ( ) ; Sketch sketch = editor . getSketch ( ) ; JEditTextArea textarea = editor . getTextArea ( ) ; if ( ( event . getModifiers ( ) & InputEvent . META_MASK ) != 0 ) { return false ; } if ( ( code == KeyEvent . VK_BACK_SPACE ) || ( code == KeyEvent . VK_TAB ) || ( code == KeyEvent . VK_ENTER ) || ( ( c >= 32 ) && ( c < 128 ) ) ) { sketch . setModified ( true ) ; } if ( ( code == KeyEvent . VK_UP ) && ( ( event . getModifiers ( ) & InputEvent . CTRL_MASK ) != 0 ) ) { char contents [ ] = textarea . getText ( ) . toCharArray ( ) ; int caretIndex = textarea . getCaretPosition ( ) ; int index = calcLineStart ( caretIndex - 1 , contents ) ; index -= 2 ; boolean onlySpaces = true ; while ( index > 0 ) { if ( contents [ index ] == 10 ) { if ( onlySpaces ) { index ++ ; break ; } else { onlySpaces = true ; } } else if ( contents [ index ] != ' ' ) { onlySpaces = false ; } index -- ; } if ( index < 0 ) index = 0 ; if ( ( event . getModifiers ( ) & InputEvent . SHIFT_MASK ) != 0 ) { textarea . setSelectionStart ( caretIndex ) ; textarea . setSelectionEnd ( index ) ; } else { textarea . setCaretPosition ( index ) ; } event . consume ( ) ; } else if ( ( code == KeyEvent . VK_DOWN ) && ( ( event . getModifiers ( ) & InputEvent . CTRL_MASK ) != 0 ) ) { char contents [ ] = textarea . getText ( ) . toCharArray ( ) ; int caretIndex = textarea . getCaretPosition ( ) ; int index = caretIndex ; int lineStart = 0 ; boolean onlySpaces = false ; while ( index < contents . length ) { if ( contents [ index ] == 10 ) { if ( onlySpaces ) { index = lineStart ; break ; } else { lineStart = index + 1 ; onlySpaces = true ; } } else if ( contents [ index ] != ' ' ) { onlySpaces = false ; } index ++ ; } if ( ( event . getModifiers ( ) & InputEvent . SHIFT_MASK ) != 0 ) { textarea . setSelectionStart ( caretIndex ) ; textarea . setSelectionEnd ( index ) ; } else { textarea . setCaretPosition ( index ) ; } event . consume ( ) ; } else if ( c == 9 ) { if ( ( event . getModifiers ( ) & InputEvent . SHIFT_MASK ) != 0 ) { editor . handleOutdent ( ) ; } else if ( textarea . isSelectionActive ( ) ) { editor . handleIndent ( ) ; } else if ( Preferences . getBoolean ( "editor.tabs.expand" ) ) { int tabSize = Preferences . getInteger ( "editor.tabs.size" ) ; textarea . setSelectedText ( spaces ( tabSize ) ) ; event . consume ( ) ; } else if ( ! Preferences . getBoolean ( "editor.tabs.expand" ) ) { textarea . setSelectedText ( "\t" ) ; event . consume ( ) ; } } else if ( c == 10 || c == 13 ) { if ( Preferences . getBoolean ( "editor.indent" ) ) { char contents [ ] = textarea . getText ( ) . toCharArray ( ) ; int tabSize = Preferences . getInteger ( "editor.tabs.size" ) ; int origIndex = textarea . getCaretPosition ( ) - 1 ; int spaceCount = calcSpaceCount ( origIndex , contents ) ; int index2 = origIndex ; while ( ( index2 >= 0 ) && Character . isWhitespace ( contents [ index2 ] ) ) { index2 -- ; } if ( index2 != - 1 ) { if ( contents [ index2 ] == '{' ) { spaceCount = calcSpaceCount ( index2 , contents ) ; spaceCount += tabSize ; } } int index = origIndex + 1 ; int extraCount = 0 ; while ( ( index < contents . length ) && ( contents [ index ] == ' ' ) ) { extraCount ++ ; index ++ ; } int braceCount = 0 ; while ( ( index < contents . length ) && ( contents [ index ] != '\n' ) ) { if ( contents [ index ] == '}' ) { braceCount ++ ; } index ++ ; } spaceCount -= extraCount ; if ( spaceCount < 0 ) { textarea . setSelectionEnd ( textarea . getSelectionStop ( ) - spaceCount ) ; textarea . setSelectedText ( "\n" ) ; textarea . setCaretPosition ( textarea . getCaretPosition ( ) + extraCount + spaceCount ) ; } else { String insertion = "\n" + spaces ( spaceCount ) ; textarea . setSelectedText ( insertion ) ; textarea . setCaretPosition ( textarea . getCaretPosition ( ) + extraCount ) ; } if ( braceCount > 0 ) { int sel = textarea . getSelectionStart ( ) ; if ( sel - tabSize >= 0 ) { textarea . select ( sel - tabSize , sel ) ; String s = spaces ( tabSize ) ; if ( textarea . getSelectedText ( ) . equals ( s ) ) { textarea . setSelectedText ( "" ) ; } else { textarea . select ( sel , sel ) ; } } } } else { textarea . setSelectedText ( String . valueOf ( c ) ) ; } event . consume ( ) ; } else if ( c == '}' ) { if ( Preferences . getBoolean ( "editor.indent" ) ) { if ( textarea . getSelectionStart ( ) != textarea . getSelectionStop ( ) ) { textarea . setSelectedText ( "" ) ; } char contents [ ] = textarea . getText ( ) . toCharArray ( ) ; int prevCharIndex = textarea . getCaretPosition ( ) - 1 ; int index = prevCharIndex ; boolean finished = false ; while ( ( index != - 1 ) && ( ! finished ) ) { if ( contents [ index ] == 10 ) { finished = true ; index ++ ; } else if ( contents [ index ] != ' ' ) { return false ; } else { index -- ; } } if ( ! finished ) return false ; int lineStartIndex = index ; int pairedSpaceCount = calcBraceIndent ( prevCharIndex , contents ) ; if ( pairedSpaceCount == - 1 ) return false ; textarea . setSelectionStart ( lineStartIndex ) ; textarea . setSelectedText ( spaces ( pairedSpaceCount ) ) ; event . consume ( ) ; return true ; } } return false ; } public boolean handleTyped ( KeyEvent event ) { char c = event . getKeyChar ( ) ; if ( ( event . getModifiers ( ) & InputEvent . CTRL_MASK ) != 0 ) { if ( c == KeyEvent . VK_COMMA ) { event . consume ( ) ; return true ; } } return false ; } protected int calcLineStart ( int index , char contents [ ] ) { boolean finished = false ; while ( ( index != - 1 ) && ( ! finished ) ) { if ( ( contents [ index ] == 10 ) || ( contents [ index ] == 13 ) ) { finished = true ; } else { index -- ; } } return index + 1 ; } protected int calcSpaceCount ( int index , char contents [ ] ) { index = calcLineStart ( index , contents ) ; int spaceCount = 0 ; while ( ( index < contents . length ) && ( index >= 0 ) && ( contents [ index ++ ] == ' ' ) ) { spaceCount ++ ; } return spaceCount ; } protected int calcBraceIndent ( int index , char [ ] contents ) { int braceDepth = 1 ; boolean finished = false ; while ( ( index != - 1 ) && ( ! finished ) ) { if ( contents [ index ] == '}' ) { braceDepth ++ ; index -- ; } else if ( contents [ index ] == '{' ) { braceDepth -- ; if ( braceDepth == 0 ) { finished = true ; } index -- ; } else { index -- ; } } if ( ! finished ) return - 1 ; return calcSpaceCount ( index , contents ) ; } static private String spaces ( int count ) { char [ ] c = new char [ count ] ; Arrays . fill ( c , ' ' ) ; return new String ( c ) ; } }
package processing . mode . java ; import java . awt . Color ; import java . awt . Cursor ; import java . awt . Dimension ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . RenderingHints ; import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; import java . awt . event . MouseMotionAdapter ; import java . util . ArrayList ; import java . util . List ; import javax . swing . JPanel ; import javax . swing . SwingWorker ; import javax . swing . text . BadLocationException ; import processing . app . Base ; import processing . app . SketchCode ; import processing . mode . java . pdex . ErrorCheckerService ; import processing . mode . java . pdex . ErrorMarker ; import processing . mode . java . pdex . Problem ; import processing . app . Language ; public class ErrorColumn extends JPanel { protected int preferredHeight ; protected int preferredWidth = 12 ; public static final int errorMarkerHeight = 4 ; public Color errorColor ; public Color warningColor ; public Color backgroundColor ; protected JavaEditor editor ; protected ErrorCheckerService errorCheckerService ; protected List < ErrorMarker > errorPoints = new ArrayList < ErrorMarker > ( ) ; protected ArrayList < ErrorMarker > errorPointsOld = new ArrayList < ErrorMarker > ( ) ; public void paintComponent ( Graphics g ) { Graphics2D g2d = ( Graphics2D ) g ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( backgroundColor ) ; g . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; for ( ErrorMarker emarker : errorPoints ) { if ( emarker . getType ( ) == ErrorMarker . Error ) { g . setColor ( errorColor ) ; } else { g . setColor ( warningColor ) ; } g . fillRect ( 2 , emarker . getY ( ) , ( getWidth ( ) - 3 ) , errorMarkerHeight ) ; } } public Dimension getPreferredSize ( ) { return new Dimension ( preferredWidth , preferredHeight ) ; } public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } public ErrorColumn ( JavaEditor editor , int height , JavaMode mode ) { this . editor = editor ; this . preferredHeight = height ; this . errorCheckerService = editor . errorCheckerService ; errorColor = mode . getColor ( "errorbar.errorcolor" ) ; warningColor = mode . getColor ( "errorbar.warningcolor" ) ; backgroundColor = mode . getColor ( "gutter.bgcolor" ) ; addListeners ( ) ; } synchronized public void updateErrorPoints ( final List < Problem > problems ) { final int fheight = this . getHeight ( ) ; SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { protected Object doInBackground ( ) throws Exception { SketchCode sc = editor . getSketch ( ) . getCurrentCode ( ) ; int totalLines = 0 , currentTab = editor . getSketch ( ) . getCurrentCodeIndex ( ) ; try { totalLines = Base . countLines ( sc . getDocument ( ) . getText ( 0 , sc . getDocument ( ) . getLength ( ) ) ) + 1 ; } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } synchronized ( errorPoints ) { errorPointsOld . clear ( ) ; for ( ErrorMarker marker : errorPoints ) { errorPointsOld . add ( marker ) ; } errorPoints . clear ( ) ; synchronized ( problems ) { for ( Problem problem : problems ) { if ( problem . getTabIndex ( ) == currentTab ) { float y = ( problem . getLineNumber ( ) + 1 ) / ( ( float ) totalLines ) ; y *= fheight - 15 ; errorPoints . add ( new ErrorMarker ( problem , ( int ) y , problem . isError ( ) ? ErrorMarker . Error : ErrorMarker . Warning ) ) ; } } } } return null ; } protected void done ( ) { repaint ( ) ; } } ; try { worker . execute ( ) ; } catch ( Exception exp ) { System . out . println ( "Errorbar update markers is slacking." + exp . getMessage ( ) ) ; } } public boolean errorPointsChanged ( ) { if ( errorPointsOld . size ( ) != errorPoints . size ( ) ) { editor . getTextArea ( ) . repaint ( ) ; return true ; } else { for ( int i = 0 ; i < errorPoints . size ( ) ; i ++ ) { if ( errorPoints . get ( i ) . getY ( ) != errorPointsOld . get ( i ) . getY ( ) ) { editor . getTextArea ( ) . repaint ( ) ; return true ; } } } return false ; } protected void addListeners ( ) { addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( final MouseEvent e ) { SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { protected Object doInBackground ( ) throws Exception { for ( ErrorMarker eMarker : errorPoints ) { if ( e . getY ( ) >= eMarker . getY ( ) - 2 && e . getY ( ) <= eMarker . getY ( ) + 2 + errorMarkerHeight ) { errorCheckerService . scrollToErrorLine ( eMarker . getProblem ( ) ) ; return null ; } } return null ; } } ; try { worker . execute ( ) ; } catch ( Exception exp ) { System . out . println ( "Errorbar mouseClicked is slacking." + exp . getMessage ( ) ) ; } } } ) ; addMouseMotionListener ( new MouseMotionAdapter ( ) { public void mouseMoved ( final MouseEvent evt ) { SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { protected Object doInBackground ( ) throws Exception { for ( ErrorMarker eMarker : errorPoints ) { if ( evt . getY ( ) >= eMarker . getY ( ) - 2 && evt . getY ( ) <= eMarker . getY ( ) + 2 + errorMarkerHeight ) { Problem p = eMarker . getProblem ( ) ; String msg = ( ( p . isError ( ) ? Language . text ( "editor.status.error" ) : Language . text ( "editor.status.warning" ) ) + ": " + p . getMessage ( ) ) ; setToolTipText ( msg ) ; setCursor ( Cursor . getPredefinedCursor ( Cursor . HAND_CURSOR ) ) ; break ; } } return null ; } } ; try { worker . execute ( ) ; } catch ( Exception exp ) { System . out . println ( "Errorbar mousemoved Worker is slacking." + exp . getMessage ( ) ) ; } } } ) ; } }
package processing . mode . java ; import java . awt . event . ActionEvent ; import java . awt . event . InputEvent ; import java . awt . event . KeyEvent ; import java . util . ArrayList ; import java . util . List ; import javax . swing . Box ; import processing . app . Editor ; import processing . app . EditorButton ; import processing . app . EditorToolbar ; import processing . app . Language ; public class JavaToolbar extends EditorToolbar { JavaEditor jeditor ; EditorButton stepButton ; EditorButton continueButton ; public JavaToolbar ( Editor editor ) { super ( editor ) ; jeditor = ( JavaEditor ) editor ; } @ Override public List < EditorButton > createButtons ( ) { final boolean debug = ( ( JavaEditor ) editor ) . isDebuggerEnabled ( ) ; List < EditorButton > outgoing = new ArrayList < > ( ) ; final String runText = debug ? Language . text ( "toolbar.debug" ) : Language . text ( "toolbar.run" ) ; runButton = new EditorButton ( mode , "/lib/toolbar/run" , runText , Language . text ( "toolbar.present" ) ) { @ Override public void actionPerformed ( ActionEvent e ) { handleRun ( e . getModifiers ( ) ) ; } } ; outgoing . add ( runButton ) ; if ( debug ) { stepButton = new EditorButton ( mode , "/lib/toolbar/step" , Language . text ( "menu.debug.step" ) , Language . text ( "menu.debug.step_into" ) , Language . text ( "menu.debug.step_out" ) ) { @ Override public void actionPerformed ( ActionEvent e ) { final int mask = KeyEvent . SHIFT_DOWN_MASK | KeyEvent . ALT_DOWN_MASK ; jeditor . handleStep ( e . getModifiers ( ) & mask ) ; } } ; outgoing . add ( stepButton ) ; continueButton = new EditorButton ( mode , "/lib/toolbar/continue" , Language . text ( "menu.debug.continue" ) ) { @ Override public void actionPerformed ( ActionEvent e ) { jeditor . handleContinue ( ) ; } } ; outgoing . add ( continueButton ) ; } stopButton = new EditorButton ( mode , "/lib/toolbar/stop" , Language . text ( "toolbar.stop" ) ) { @ Override public void actionPerformed ( ActionEvent e ) { handleStop ( ) ; } } ; outgoing . add ( stopButton ) ; return outgoing ; } public void addModeButtons ( Box box ) { EditorButton debugButton = new EditorButton ( mode , "/lib/toolbar/debug" , Language . text ( "toolbar.debug" ) ) { @ Override public void actionPerformed ( ActionEvent e ) { jeditor . toggleDebug ( ) ; } } ; if ( ( ( JavaEditor ) editor ) . isDebuggerEnabled ( ) ) { debugButton . setSelected ( true ) ; } box . add ( debugButton ) ; addGap ( box ) ; } @ Override public void handleRun ( int modifiers ) { boolean shift = ( modifiers & InputEvent . SHIFT_MASK ) != 0 ; if ( shift ) { jeditor . handlePresent ( ) ; } else { jeditor . handleRun ( ) ; } } @ Override public void handleStop ( ) { jeditor . handleStop ( ) ; } public void activateContinue ( ) { continueButton . setSelected ( true ) ; repaint ( ) ; } protected void deactivateContinue ( ) { continueButton . setSelected ( false ) ; repaint ( ) ; } protected void activateStep ( ) { stepButton . setSelected ( true ) ; repaint ( ) ; } protected void deactivateStep ( ) { stepButton . setSelected ( false ) ; repaint ( ) ; } }
package processing . mode . java . preproc ; import java . lang . reflect . Field ; import antlr . collections . AST ; import processing . mode . java . preproc . PdeTokenTypes ; public class TokenUtil { private static final String [ ] tokenNames = new String [ 200 ] ; static { for ( int i = 0 ; i < tokenNames . length ; i ++ ) { tokenNames [ i ] = "ERROR:" + i ; } for ( final Field f : PdeTokenTypes . class . getDeclaredFields ( ) ) { try { tokenNames [ f . getInt ( null ) ] = f . getName ( ) ; } catch ( Exception unexpected ) { throw new RuntimeException ( unexpected ) ; } } } public static String nameOf ( final AST node ) { return tokenNames [ node . getType ( ) ] ; } }
package processing . mode . java . preproc ; import processing . app . Base ; import processing . core . PApplet ; public class SurfaceInfo { String statement ; String width ; String height ; String renderer ; String path ; String display ; boolean hasOldSyntax ( ) { if ( width . equals ( "screenWidth" ) || width . equals ( "screenHeight" ) || height . equals ( "screenHeight" ) || height . equals ( "screenWidth" ) ) { final String message = "The screenWidth and screenHeight variables are named\n" + "displayWidth and displayHeight in Processing 3.\n" + "Or you can use the fullScreen() method instead of size()." ; Base . showWarning ( "Time for a quick update" , message , null ) ; return true ; } if ( width . equals ( "screen.width" ) || width . equals ( "screen.height" ) || height . equals ( "screen.height" ) || height . equals ( "screen.width" ) ) { final String message = "The screen.width and screen.height variables are named\n" + "displayWidth and displayHeight in Processing 3.\n" + "Or you can use the fullScreen() method instead of size()." ; Base . showWarning ( "Time for a quick update" , message , null ) ; return true ; } return false ; } boolean hasBadSize ( ) { if ( ! width . equals ( "displayWidth" ) && ! width . equals ( "displayHeight" ) && PApplet . parseInt ( width , - 1 ) == - 1 ) { return true ; } if ( ! height . equals ( "displayWidth" ) && ! height . equals ( "displayHeight" ) && PApplet . parseInt ( height , - 1 ) == - 1 ) { return true ; } return false ; } void checkEmpty ( ) { if ( renderer != null ) { if ( renderer . length ( ) == 0 ) { renderer = null ; } } if ( path != null ) { if ( path . length ( ) == 0 ) { path = null ; } } if ( display != null ) { if ( display . length ( ) == 0 ) { display = null ; } } } public String getStatement ( ) { return statement ; } }
package processing . mode . java . preproc ; import java . io . PrintStream ; import java . io . PrintWriter ; import java . util . BitSet ; import java . util . Stack ; import processing . app . Preferences ; import processing . app . SketchException ; import processing . mode . java . preproc . PdeTokenTypes ; import antlr . CommonASTWithHiddenTokens ; import antlr . CommonHiddenStreamToken ; import antlr . collections . AST ; @ SuppressWarnings ( "serial" ) public class PdeEmitter implements PdeTokenTypes { private final PdePreprocessor pdePreprocessor ; private final PrintWriter out ; private final PrintStream debug = System . err ; private final Stack < AST > stack = new Stack < AST > ( ) ; private final static int ROOT_ID = 0 ; public PdeEmitter ( final PdePreprocessor pdePreprocessor , final PrintWriter out ) { this . pdePreprocessor = pdePreprocessor ; this . out = out ; } static private AST getChild ( final AST ast , final int childType ) { AST child = ast . getFirstChild ( ) ; while ( child != null ) { if ( child . getType ( ) == childType ) { return child ; } child = child . getNextSibling ( ) ; } return null ; } private void dumpHiddenAfter ( final AST ast ) { dumpHiddenTokens ( ( ( CommonASTWithHiddenTokens ) ast ) . getHiddenAfter ( ) ) ; } private void dumpHiddenBefore ( final AST ast ) { antlr . CommonHiddenStreamToken child = null , parent = ( ( CommonASTWithHiddenTokens ) ast ) . getHiddenBefore ( ) ; if ( parent == null ) { return ; } do { child = parent ; parent = child . getHiddenBefore ( ) ; } while ( parent != null ) ; dumpHiddenTokens ( child ) ; } private void dumpHiddenTokens ( CommonHiddenStreamToken t ) { for ( ; t != null ; t = pdePreprocessor . getHiddenAfter ( t ) ) { out . print ( t . getText ( ) ) ; } } private boolean printChildren ( final AST ast ) throws SketchException { boolean ret = false ; AST child = ast . getFirstChild ( ) ; while ( child != null ) { ret = true ; print ( child ) ; child = child . getNextSibling ( ) ; } return ret ; } static private boolean hasChildren ( final AST ast ) { return ( ast . getFirstChild ( ) != null ) ; } private AST getBestPrintableNode ( final AST ast , final boolean includeThisNode ) { AST child ; if ( includeThisNode ) { child = ast ; } else { child = ast . getFirstChild ( ) ; } if ( child != null ) { switch ( child . getType ( ) ) { case CLASS_DEF : case ENUM_DEF : case LITERAL_if : case LITERAL_new : case LITERAL_for : case LITERAL_while : case LITERAL_do : case LITERAL_break : case LITERAL_continue : case LITERAL_return : case LITERAL_switch : case LITERAL_try : case LITERAL_throw : case LITERAL_synchronized : case LITERAL_assert : case BNOT : case LNOT : case INC : case DEC : case UNARY_MINUS : case UNARY_PLUS : return child ; case MODIFIERS : if ( child . getFirstChild ( ) == null ) { return getBestPrintableNode ( child . getNextSibling ( ) , false ) ; } return getBestPrintableNode ( child , false ) ; default : return getBestPrintableNode ( child , false ) ; } } return ast ; } private static final BitSet OTHER_COPIED_TOKENS = new BitSet ( ) { { set ( LT ) ; set ( GT ) ; set ( SR ) ; set ( BSR ) ; } } ; private void printBinaryOperator ( final AST ast ) throws SketchException { print ( ast . getFirstChild ( ) ) ; if ( ! OTHER_COPIED_TOKENS . get ( ast . getType ( ) ) ) { out . print ( ast . getText ( ) ) ; dumpHiddenAfter ( ast ) ; } print ( ast . getFirstChild ( ) . getNextSibling ( ) ) ; } private void printMethodDef ( final AST ast ) throws SketchException { final AST modifiers = ast . getFirstChild ( ) ; final AST typeParameters , type ; if ( modifiers . getNextSibling ( ) . getType ( ) == TYPE_PARAMETERS ) { typeParameters = modifiers . getNextSibling ( ) ; type = typeParameters . getNextSibling ( ) ; } else { typeParameters = null ; type = modifiers . getNextSibling ( ) ; } final AST methodName = type . getNextSibling ( ) ; pdePreprocessor . addMethod ( methodName . getText ( ) ) ; printChildren ( ast ) ; } private void printIfThenElse ( final AST literalIf ) throws SketchException { out . print ( literalIf . getText ( ) ) ; dumpHiddenAfter ( literalIf ) ; final AST condition = literalIf . getFirstChild ( ) ; print ( condition ) ; final AST thenPath = condition . getNextSibling ( ) ; print ( thenPath ) ; final AST elsePath = thenPath . getNextSibling ( ) ; if ( elsePath != null ) { out . print ( "else" ) ; final AST bestPrintableNode = getBestPrintableNode ( elsePath , true ) ; dumpHiddenBefore ( bestPrintableNode ) ; final CommonHiddenStreamToken hiddenBefore = ( ( CommonASTWithHiddenTokens ) elsePath ) . getHiddenBefore ( ) ; if ( elsePath . getType ( ) == PdeTokenTypes . SLIST && elsePath . getNumberOfChildren ( ) == 0 && hiddenBefore == null ) { out . print ( "{" ) ; final CommonHiddenStreamToken hiddenAfter = ( ( CommonASTWithHiddenTokens ) elsePath ) . getHiddenAfter ( ) ; if ( hiddenAfter == null ) { out . print ( "}" ) ; } else { dumpHiddenTokens ( hiddenAfter ) ; } } else { print ( elsePath ) ; } } } public void print ( final AST ast ) throws SketchException { if ( ast == null ) { return ; } stack . push ( ast ) ; final AST child1 = ast . getFirstChild ( ) ; AST child2 = null ; AST child3 = null ; if ( child1 != null ) { child2 = child1 . getNextSibling ( ) ; if ( child2 != null ) { child3 = child2 . getNextSibling ( ) ; } } switch ( ast . getType ( ) ) { case ROOT_ID : dumpHiddenTokens ( pdePreprocessor . getInitialHiddenToken ( ) ) ; printChildren ( ast ) ; break ; case PACKAGE_DEF : out . print ( "package" ) ; dumpHiddenAfter ( ast ) ; print ( ast . getFirstChild ( ) ) ; break ; case IMPORT : out . print ( "import" ) ; dumpHiddenAfter ( ast ) ; print ( ast . getFirstChild ( ) ) ; break ; case STATIC_IMPORT : out . print ( "import static" ) ; dumpHiddenAfter ( ast ) ; print ( ast . getFirstChild ( ) ) ; break ; case CLASS_DEF : case ENUM_DEF : case INTERFACE_DEF : print ( getChild ( ast , MODIFIERS ) ) ; if ( ast . getType ( ) == CLASS_DEF ) { out . print ( "class" ) ; } else if ( ast . getType ( ) == ENUM_DEF ) { out . print ( "enum" ) ; } else { out . print ( "interface" ) ; } dumpHiddenBefore ( getChild ( ast , IDENT ) ) ; print ( getChild ( ast , IDENT ) ) ; print ( getChild ( ast , TYPE_PARAMETERS ) ) ; print ( getChild ( ast , EXTENDS_CLAUSE ) ) ; print ( getChild ( ast , IMPLEMENTS_CLAUSE ) ) ; print ( getChild ( ast , OBJBLOCK ) ) ; break ; case EXTENDS_CLAUSE : if ( hasChildren ( ast ) ) { out . print ( "extends" ) ; dumpHiddenBefore ( getBestPrintableNode ( ast , false ) ) ; printChildren ( ast ) ; } break ; case IMPLEMENTS_CLAUSE : if ( hasChildren ( ast ) ) { out . print ( "implements" ) ; dumpHiddenBefore ( getBestPrintableNode ( ast , false ) ) ; printChildren ( ast ) ; } break ; case DOT : print ( child1 ) ; out . print ( "." ) ; dumpHiddenAfter ( ast ) ; print ( child2 ) ; break ; case MODIFIERS : case OBJBLOCK : case CTOR_DEF : case PARAMETERS : case PARAMETER_DEF : case VARIABLE_PARAMETER_DEF : case VARIABLE_DEF : case ENUM_CONSTANT_DEF : case TYPE : case SLIST : case ELIST : case ARRAY_DECLARATOR : case TYPECAST : case EXPR : case ARRAY_INIT : case FOR_INIT : case FOR_CONDITION : case FOR_ITERATOR : case METHOD_CALL : case INSTANCE_INIT : case INDEX_OP : case SUPER_CTOR_CALL : case CTOR_CALL : printChildren ( ast ) ; break ; case METHOD_DEF : printMethodDef ( ast ) ; break ; case ASSIGN : if ( child2 != null ) { print ( child1 ) ; out . print ( "=" ) ; dumpHiddenAfter ( ast ) ; print ( child2 ) ; } else { out . print ( "=" ) ; dumpHiddenAfter ( ast ) ; print ( child1 ) ; } break ; case PLUS : case MINUS : case DIV : case MOD : case NOT_EQUAL : case EQUAL : case LE : case GE : case LOR : case LAND : case BOR : case BXOR : case BAND : case SL : case SR : case BSR : case LITERAL_instanceof : case PLUS_ASSIGN : case MINUS_ASSIGN : case STAR_ASSIGN : case DIV_ASSIGN : case MOD_ASSIGN : case SR_ASSIGN : case BSR_ASSIGN : case SL_ASSIGN : case BAND_ASSIGN : case BXOR_ASSIGN : case BOR_ASSIGN : case LT : case GT : printBinaryOperator ( ast ) ; break ; case LITERAL_for : out . print ( ast . getText ( ) ) ; dumpHiddenAfter ( ast ) ; if ( child1 . getType ( ) == FOR_EACH_CLAUSE ) { printChildren ( child1 ) ; print ( child2 ) ; } else { printChildren ( ast ) ; } break ; case POST_INC : case POST_DEC : print ( child1 ) ; out . print ( ast . getText ( ) ) ; dumpHiddenAfter ( ast ) ; break ; case BNOT : case LNOT : case INC : case DEC : case UNARY_MINUS : case UNARY_PLUS : out . print ( ast . getText ( ) ) ; dumpHiddenAfter ( ast ) ; print ( child1 ) ; break ; case LITERAL_new : out . print ( "new" ) ; dumpHiddenAfter ( ast ) ; printChildren ( ast ) ; break ; case LITERAL_return : out . print ( "return" ) ; dumpHiddenAfter ( ast ) ; print ( child1 ) ; break ; case STATIC_INIT : out . print ( "static" ) ; dumpHiddenBefore ( getBestPrintableNode ( ast , false ) ) ; print ( child1 ) ; break ; case LITERAL_switch : out . print ( "switch" ) ; dumpHiddenAfter ( ast ) ; printChildren ( ast ) ; break ; case LABELED_STAT : case CASE_GROUP : printChildren ( ast ) ; break ; case LITERAL_case : out . print ( "case" ) ; dumpHiddenAfter ( ast ) ; printChildren ( ast ) ; break ; case LITERAL_default : out . print ( "default" ) ; dumpHiddenAfter ( ast ) ; printChildren ( ast ) ; break ; case NUM_INT : case CHAR_LITERAL : case STRING_LITERAL : case NUM_FLOAT : case NUM_LONG : out . print ( ast . getText ( ) ) ; dumpHiddenAfter ( ast ) ; break ; case LITERAL_synchronized : case LITERAL_assert : out . print ( ast . getText ( ) ) ; dumpHiddenAfter ( ast ) ; printChildren ( ast ) ; break ; case LITERAL_private : case LITERAL_public : case LITERAL_protected : case LITERAL_static : case LITERAL_transient : case LITERAL_native : case LITERAL_threadsafe : case LITERAL_volatile : case LITERAL_class : case FINAL : case ABSTRACT : case LITERAL_package : case LITERAL_void : case LITERAL_boolean : case LITERAL_byte : case LITERAL_char : case LITERAL_short : case LITERAL_int : case LITERAL_float : case LITERAL_long : case LITERAL_double : case LITERAL_true : case LITERAL_false : case LITERAL_null : case SEMI : case LITERAL_this : case LITERAL_super : out . print ( ast . getText ( ) ) ; dumpHiddenAfter ( ast ) ; break ; case EMPTY_STAT : case EMPTY_FIELD : break ; case LITERAL_continue : case LITERAL_break : out . print ( ast . getText ( ) ) ; dumpHiddenAfter ( ast ) ; if ( child1 != null ) { print ( child1 ) ; } break ; case STAR : if ( hasChildren ( ast ) ) { printBinaryOperator ( ast ) ; } else { out . print ( "*" ) ; dumpHiddenAfter ( ast ) ; } break ; case LITERAL_throws : out . print ( "throws" ) ; dumpHiddenAfter ( ast ) ; printChildren ( ast ) ; break ; case LITERAL_if : printIfThenElse ( ast ) ; break ; case LITERAL_while : out . print ( "while" ) ; dumpHiddenAfter ( ast ) ; printChildren ( ast ) ; break ; case LITERAL_do : out . print ( "do" ) ; dumpHiddenAfter ( ast ) ; print ( child1 ) ; out . print ( "while" ) ; dumpHiddenBefore ( getBestPrintableNode ( child2 , false ) ) ; print ( child2 ) ; break ; case LITERAL_try : out . print ( "try" ) ; dumpHiddenAfter ( ast ) ; printChildren ( ast ) ; break ; case LITERAL_catch : out . print ( "catch" ) ; dumpHiddenAfter ( ast ) ; printChildren ( ast ) ; break ; case LITERAL_finally : out . print ( "finally" ) ; dumpHiddenAfter ( ast ) ; printChildren ( ast ) ; break ; case LITERAL_throw : out . print ( "throw" ) ; dumpHiddenAfter ( ast ) ; print ( child1 ) ; break ; case QUESTION : print ( child1 ) ; out . print ( "?" ) ; dumpHiddenAfter ( ast ) ; print ( child2 ) ; print ( child3 ) ; break ; case IDENT : out . print ( ast . getText ( ) ) ; dumpHiddenAfter ( ast ) ; break ; case LITERAL_color : out . print ( "int" ) ; dumpHiddenAfter ( ast ) ; break ; case WEBCOLOR_LITERAL : if ( ast . getText ( ) . length ( ) != 6 ) { System . err . println ( "Internal error: incorrect length of webcolor " + "literal should have been detected sooner." ) ; break ; } out . print ( "0xff" + ast . getText ( ) ) ; dumpHiddenAfter ( ast ) ; break ; case CONSTRUCTOR_CAST : final AST terminalTypeNode = child1 . getFirstChild ( ) ; final AST exprToCast = child2 ; final String pooType = terminalTypeNode . getText ( ) ; out . print ( "PApplet.parse" + Character . toUpperCase ( pooType . charAt ( 0 ) ) + pooType . substring ( 1 ) ) ; dumpHiddenAfter ( terminalTypeNode ) ; print ( exprToCast ) ; break ; case NUM_DOUBLE : final String literalDouble = ast . getText ( ) . toLowerCase ( ) ; out . print ( literalDouble ) ; if ( Preferences . getBoolean ( "preproc.substitute_floats" ) && literalDouble . indexOf ( 'd' ) == - 1 ) { out . print ( "f" ) ; } dumpHiddenAfter ( ast ) ; break ; case TYPE_ARGUMENTS : case TYPE_PARAMETERS : printChildren ( ast ) ; break ; case TYPE_ARGUMENT : case TYPE_PARAMETER : printChildren ( ast ) ; break ; case WILDCARD_TYPE : out . print ( ast . getText ( ) ) ; dumpHiddenAfter ( ast ) ; print ( ast . getFirstChild ( ) ) ; break ; case TYPE_LOWER_BOUNDS : case TYPE_UPPER_BOUNDS : out . print ( ast . getType ( ) == TYPE_LOWER_BOUNDS ? "super" : "extends" ) ; dumpHiddenBefore ( getBestPrintableNode ( ast , false ) ) ; printChildren ( ast ) ; break ; case ANNOTATION : out . print ( "@" ) ; printChildren ( ast ) ; break ; case ANNOTATIONS : case ANNOTATION_ARRAY_INIT : printChildren ( ast ) ; break ; case ANNOTATION_MEMBER_VALUE_PAIR : print ( ast . getFirstChild ( ) ) ; out . print ( "=" ) ; dumpHiddenBefore ( getBestPrintableNode ( ast . getFirstChild ( ) . getNextSibling ( ) , false ) ) ; print ( ast . getFirstChild ( ) . getNextSibling ( ) ) ; break ; default : debug . println ( "Unrecognized type:" + ast . getType ( ) + " (" + TokenUtil . nameOf ( ast ) + ")" ) ; break ; } stack . pop ( ) ; } }
package processing . mode . java . preproc ; import java . io . * ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import processing . app . Base ; import processing . app . Preferences ; import processing . app . SketchException ; import processing . core . PApplet ; import processing . data . StringList ; import processing . mode . java . preproc . PdeLexer ; import processing . mode . java . preproc . PdeRecognizer ; import processing . mode . java . preproc . PdeTokenTypes ; import antlr . * ; import antlr . collections . AST ; public class PdePreprocessor { protected static final String UNICODE_ESCAPES = "0123456789abcdefABCDEF" ; private static final int ROOT_ID = 0 ; protected final String indent ; private final String name ; public static enum Mode { STATIC , ACTIVE , JAVA } private TokenStreamCopyingHiddenTokenFilter filter ; private String advClassName = "" ; protected Mode mode ; Set < String > foundMethods ; SurfaceInfo sizeInfo ; static private final String VOID_SETUP_REGEX = "(?:^|\\s|;)void\\ssetup\\s*\\(" ; static private final Pattern PUBLIC_CLASS = Pattern . compile ( "(^|;)\\s*public\\s+class\\s+\\S+\\s+extends\\s+PApplet" , Pattern . MULTILINE ) ; private static final Pattern FUNCTION_DECL = Pattern . compile ( "(^|;)\\s*((public|private|protected|final|static)\\s+)*" + "(void|int|float|double|String|char|byte)" + "(\\s*\\[\\s*\\])?\\s+[a-zA-Z0-9]+\\s*\\(" , Pattern . MULTILINE ) ; public PdePreprocessor ( final String sketchName ) { this ( sketchName , Preferences . getInteger ( "editor.tabs.size" ) ) ; } public PdePreprocessor ( final String sketchName , final int tabSize ) { this . name = sketchName ; final char [ ] indentChars = new char [ tabSize ] ; Arrays . fill ( indentChars , ' ' ) ; indent = new String ( indentChars ) ; } public SurfaceInfo initSketchSize ( String code , boolean sizeWarning ) throws SketchException { sizeInfo = parseSketchSize ( code , sizeWarning ) ; return sizeInfo ; } static private StringList breakCommas ( String contents ) { StringList outgoing = new StringList ( ) ; boolean insideQuote = false ; StringBuilder current = new StringBuilder ( ) ; char [ ] chars = contents . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( insideQuote ) { current . append ( c ) ; if ( c == '\"' ) { insideQuote = false ; } } else { if ( c == ',' ) { if ( current . length ( ) != 0 ) { outgoing . append ( current . toString ( ) ) ; current . setLength ( 0 ) ; } } else { current . append ( c ) ; if ( c == '\"' ) { insideQuote = true ; } } } } if ( current . length ( ) != 0 ) { outgoing . append ( current . toString ( ) ) ; } return outgoing ; } static public SurfaceInfo parseSketchSize ( String code , boolean fussy ) throws SketchException { String searchArea = scrubComments ( code ) ; String [ ] setupMatch = PApplet . match ( searchArea , VOID_SETUP_REGEX ) ; if ( setupMatch != null ) { String found = setupMatch [ 0 ] ; int start = searchArea . indexOf ( found ) + found . length ( ) ; int openBrace = searchArea . indexOf ( "{" , start ) ; char [ ] c = searchArea . toCharArray ( ) ; int depth = 0 ; int closeBrace = - 1 ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = openBrace ; i < c . length ; i ++ ) { if ( c [ i ] == '{' ) { depth ++ ; } else if ( c [ i ] == '}' ) { depth -- ; if ( depth == 0 ) { closeBrace = ++ i ; break ; } } else { sb . append ( c [ i ] ) ; } } if ( closeBrace == - 1 ) { throw new SketchException ( "Found a { that's missing a matching }" , false ) ; } searchArea = sb . toString ( ) ; } StringList extraStatements = new StringList ( ) ; String [ ] smoothContents = matchMethod ( "smooth" , searchArea ) ; if ( smoothContents != null ) { extraStatements . append ( smoothContents [ 0 ] ) ; } String [ ] noContents = matchMethod ( "noSmooth" , searchArea ) ; if ( noContents != null ) { if ( extraStatements . size ( ) != 0 ) { throw new SketchException ( "smooth() and noSmooth() cannot be used in the same sketch" ) ; } else { extraStatements . append ( noContents [ 0 ] ) ; } } String [ ] pixelDensityContents = matchMethod ( "pixelDensity" , searchArea ) ; if ( pixelDensityContents != null ) { extraStatements . append ( pixelDensityContents [ 0 ] ) ; } String [ ] sizeContents = matchMethod ( "size" , searchArea ) ; String [ ] fullContents = matchMethod ( "fullScreen" , searchArea ) ; if ( sizeContents != null && fullContents != null ) { throw new SketchException ( "size() and fullScreen() cannot be used in the same sketch" , false ) ; } if ( sizeContents != null ) { StringList args = breakCommas ( sizeContents [ 1 ] ) ; SurfaceInfo info = new SurfaceInfo ( ) ; info . statement = sizeContents [ 0 ] ; info . width = args . get ( 0 ) . trim ( ) ; info . height = args . get ( 1 ) . trim ( ) ; info . renderer = ( args . size ( ) >= 3 ) ? args . get ( 2 ) . trim ( ) : null ; info . path = ( args . size ( ) >= 4 ) ? args . get ( 3 ) . trim ( ) : null ; if ( info . hasOldSyntax ( ) ) { throw new SketchException ( "Please update your code to continue." , false ) ; } if ( info . hasBadSize ( ) && fussy ) { final String message = "The size of this sketch could not be determined from your code.\n" + "Use only numbers (not variables) for the size() command.\n" + "Read the size() reference for more details." ; Base . showWarning ( "Could not find sketch size" , message , null ) ; throw new SketchException ( "Please fix the size() line to continue." , false ) ; } if ( extraStatements . size ( ) != 0 ) { info . statement += extraStatements . join ( " " ) ; } info . checkEmpty ( ) ; return info ; } if ( fullContents != null ) { SurfaceInfo info = new SurfaceInfo ( ) ; info . statement = fullContents [ 0 ] ; StringList args = breakCommas ( fullContents [ 1 ] ) ; if ( args . size ( ) > 0 ) { String args0 = args . get ( 0 ) . trim ( ) ; if ( args . size ( ) == 1 ) { if ( args0 . equals ( "SPAN" ) || PApplet . parseInt ( args0 , - 1 ) != - 1 ) { info . display = args0 ; } else { info . renderer = args0 ; } } else if ( args . size ( ) == 2 ) { info . renderer = args0 ; info . display = args . get ( 1 ) . trim ( ) ; } else { throw new SketchException ( "That's too many parameters for fullScreen()" ) ; } } info . width = "displayWidth" ; info . height = "displayHeight" ; if ( extraStatements . size ( ) != 0 ) { info . statement += extraStatements . join ( " " ) ; } info . checkEmpty ( ) ; return info ; } if ( extraStatements . size ( ) != 0 ) { SurfaceInfo info = new SurfaceInfo ( ) ; info . statement = extraStatements . join ( " " ) ; return info ; } return new SurfaceInfo ( ) ; } static protected String [ ] matchMethod ( String methodName , String searchArea ) { final String left = "(?:^|\\s|;)" ; final String right = "\\s*\\(([^\\)]*)\\)\\s*\\;" ; return PApplet . match ( searchArea , left + methodName + right ) ; } static public String scrubComments ( String what ) { char p [ ] = what . toCharArray ( ) ; boolean insideQuote = false ; int index = 0 ; while ( index < p . length ) { if ( ! insideQuote && ( p [ index ] == '/' ) && ( index < p . length - 1 ) && ( p [ index + 1 ] == '/' ) ) { p [ index ++ ] = ' ' ; p [ index ++ ] = ' ' ; while ( ( index < p . length ) && ( p [ index ] != '\n' ) ) { p [ index ++ ] = ' ' ; } } else if ( ! insideQuote && ( p [ index ] == '/' ) && ( index < p . length - 1 ) && ( p [ index + 1 ] == '*' ) ) { p [ index ++ ] = ' ' ; p [ index ++ ] = ' ' ; boolean endOfRainbow = false ; while ( index < p . length - 1 ) { if ( ( p [ index ] == '*' ) && ( p [ index + 1 ] == '/' ) ) { p [ index ++ ] = ' ' ; p [ index ++ ] = ' ' ; endOfRainbow = true ; break ; } else { p [ index ++ ] = ' ' ; } } if ( ! endOfRainbow ) { throw new RuntimeException ( "Missing the */ from the end of a " + "/* comment */" ) ; } } else if ( p [ index ] == '"' && index > 0 && p [ index - 1 ] != '\\' ) { insideQuote = ! insideQuote ; index ++ ; } else { index ++ ; } } return new String ( p ) ; } public void addMethod ( String methodName ) { foundMethods . add ( methodName ) ; } public boolean hasMethod ( String methodName ) { return foundMethods . contains ( methodName ) ; } public void setAdvClassName ( final String advClassName ) { this . advClassName = advClassName ; } public void setMode ( final Mode mode ) { this . mode = mode ; } CommonHiddenStreamToken getHiddenAfter ( final CommonHiddenStreamToken t ) { return filter . getHiddenAfter ( t ) ; } CommonHiddenStreamToken getInitialHiddenToken ( ) { return filter . getInitialHiddenToken ( ) ; } private static int countNewlines ( final String s ) { int count = 0 ; for ( int pos = s . indexOf ( '\n' , 0 ) ; pos >= 0 ; pos = s . indexOf ( '\n' , pos + 1 ) ) count ++ ; return count ; } private static void checkForUnterminatedMultilineComment ( final String program ) throws SketchException { final int length = program . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( ( program . charAt ( i ) == '/' ) && ( i < length - 1 ) && ( program . charAt ( i + 1 ) == '/' ) ) { i += 2 ; while ( ( i < length ) && ( program . charAt ( i ) != '\n' ) ) { i ++ ; } } else if ( ( program . charAt ( i ) == '/' ) && ( i < length - 1 ) && ( program . charAt ( i + 1 ) == '*' ) ) { final int startOfComment = i ; i += 2 ; boolean terminated = false ; while ( i < length - 1 ) { if ( ( program . charAt ( i ) == '*' ) && ( program . charAt ( i + 1 ) == '/' ) ) { i += 2 ; terminated = true ; break ; } else { i ++ ; } } if ( ! terminated ) { throw new SketchException ( "Unclosed /* comment */" , 0 , countNewlines ( program . substring ( 0 , startOfComment ) ) ) ; } } else if ( program . charAt ( i ) == '"' ) { final int stringStart = i ; boolean terminated = false ; for ( i ++ ; i < length ; i ++ ) { final char c = program . charAt ( i ) ; if ( c == '"' ) { terminated = true ; break ; } else if ( c == '\\' ) { if ( i == length - 1 ) { break ; } i ++ ; } else if ( c == '\n' ) { break ; } } if ( ! terminated ) { throw new SketchException ( "Unterminated string constant" , 0 , countNewlines ( program . substring ( 0 , stringStart ) ) ) ; } } else if ( program . charAt ( i ) == '\'' ) { i ++ ; if ( i >= length ) { throw new SketchException ( "Unterminated character constant (after initial quote)" , 0 , countNewlines ( program . substring ( 0 , i ) ) ) ; } boolean escaped = false ; if ( program . charAt ( i ) == '\\' ) { i ++ ; escaped = true ; } if ( i >= length ) { throw new SketchException ( "Unterminated character constant (after backslash)" , 0 , countNewlines ( program . substring ( 0 , i ) ) ) ; } if ( escaped && program . charAt ( i ) == 'u' ) { i ++ ; for ( int j = 0 ; j < 4 ; j ++ ) { if ( UNICODE_ESCAPES . indexOf ( program . charAt ( i ) ) == - 1 ) { throw new SketchException ( "Bad or unfinished \\uXXXX sequence " + "(malformed Unicode character constant)" , 0 , countNewlines ( program . substring ( 0 , i ) ) ) ; } i ++ ; } } else { i ++ ; } if ( i >= length ) { throw new SketchException ( "Unterminated character constant" , 0 , countNewlines ( program . substring ( 0 , i ) ) ) ; } if ( program . charAt ( i ) != '\'' ) { throw new SketchException ( "Badly formed character constant " + "(expecting quote, got " + program . charAt ( i ) + ")" , 0 , countNewlines ( program . substring ( 0 , i ) ) ) ; } } } } public PreprocessorResult write ( final Writer out , String program ) throws SketchException , RecognitionException , TokenStreamException { return write ( out , program , null ) ; } public PreprocessorResult write ( Writer out , String program , String codeFolderPackages [ ] ) throws SketchException , RecognitionException , TokenStreamException { final ArrayList < String > programImports = new ArrayList < String > ( ) ; final ArrayList < String > codeFolderImports = new ArrayList < String > ( ) ; foundMethods = new HashSet < String > ( ) ; if ( ! program . endsWith ( "\n" ) ) { program += "\n" ; } checkForUnterminatedMultilineComment ( program ) ; if ( Preferences . getBoolean ( "preproc.substitute_unicode" ) ) { program = substituteUnicode ( program ) ; } final String importRegexp = "((?:^|;|\\})\\s*)(import\\s+)((?:static\\s+)?\\S+)(\\s*;)" ; final Pattern importPattern = Pattern . compile ( importRegexp ) ; String scrubbed = scrubComments ( program ) ; Matcher m = null ; int offset = 0 ; boolean found = false ; do { m = importPattern . matcher ( scrubbed ) ; found = m . find ( offset ) ; if ( found ) { String before = m . group ( 1 ) ; String piece = m . group ( 2 ) + m . group ( 3 ) + m . group ( 4 ) ; if ( ! ignoreImport ( m . group ( 3 ) ) ) { programImports . add ( m . group ( 3 ) ) ; } int start = m . start ( ) + before . length ( ) ; int stop = start + piece . length ( ) ; program = program . substring ( 0 , start ) + program . substring ( stop ) ; scrubbed = scrubbed . substring ( 0 , start ) + scrubbed . substring ( stop ) ; offset = m . start ( ) ; } } while ( found ) ; if ( codeFolderPackages != null ) { for ( String item : codeFolderPackages ) { codeFolderImports . add ( item + ".*" ) ; } } final PrintWriter stream = new PrintWriter ( out ) ; final int headerOffset = writeImports ( stream , programImports , codeFolderImports ) ; return new PreprocessorResult ( mode , headerOffset + 2 , write ( program , stream ) , programImports ) ; } static String substituteUnicode ( String program ) { char p [ ] = program . toCharArray ( ) ; int unicodeCount = 0 ; for ( int i = 0 ; i < p . length ; i ++ ) { if ( p [ i ] > 127 ) unicodeCount ++ ; } if ( unicodeCount == 0 ) return program ; int index = 0 ; char p2 [ ] = new char [ p . length + unicodeCount * 5 ] ; for ( int i = 0 ; i < p . length ; i ++ ) { if ( p [ i ] < 128 ) { p2 [ index ++ ] = p [ i ] ; } else if ( p [ i ] == 160 ) { p2 [ index ++ ] = ' ' ; } else { int c = p [ i ] ; p2 [ index ++ ] = '\\' ; p2 [ index ++ ] = 'u' ; char str [ ] = Integer . toHexString ( c ) . toCharArray ( ) ; for ( int m = 0 ; m < 4 - str . length ; m ++ ) p2 [ index ++ ] = '0' ; System . arraycopy ( str , 0 , p2 , index , str . length ) ; index += str . length ; } } return new String ( p2 , 0 , index ) ; } private String write ( final String program , final PrintWriter stream ) throws SketchException , RecognitionException , TokenStreamException { String uncomment = scrubComments ( program ) ; PdeRecognizer parser = createParser ( program ) ; if ( PUBLIC_CLASS . matcher ( uncomment ) . find ( ) ) { try { final PrintStream saved = System . err ; try { System . setErr ( new PrintStream ( new ByteArrayOutputStream ( ) ) ) ; parser . javaProgram ( ) ; } finally { System . setErr ( saved ) ; } setMode ( Mode . JAVA ) ; } catch ( Exception e ) { parser = createParser ( program ) ; parser . pdeProgram ( ) ; } } else if ( FUNCTION_DECL . matcher ( uncomment ) . find ( ) ) { setMode ( Mode . ACTIVE ) ; parser . activeProgram ( ) ; } else { parser . pdeProgram ( ) ; } ASTFactory factory = new ASTFactory ( ) ; AST parserAST = parser . getAST ( ) ; AST rootNode = factory . create ( ROOT_ID , "AST ROOT" ) ; rootNode . setFirstChild ( parserAST ) ; makeSimpleMethodsPublic ( rootNode ) ; BaseAST . setVerboseStringConversion ( true , parser . getTokenNames ( ) ) ; final String className ; if ( mode == Mode . JAVA ) { className = getFirstClassName ( parserAST ) ; } else { className = this . name ; } if ( className == null ) return null ; if ( false ) { final StringWriter buf = new StringWriter ( ) ; final PrintWriter bufout = new PrintWriter ( buf ) ; writeDeclaration ( bufout , className ) ; new PdeEmitter ( this , bufout ) . print ( rootNode ) ; writeFooter ( bufout , className ) ; debugAST ( rootNode , true ) ; System . err . println ( buf . toString ( ) ) ; } writeDeclaration ( stream , className ) ; new PdeEmitter ( this , stream ) . print ( rootNode ) ; writeFooter ( stream , className ) ; if ( Preferences . getBoolean ( "preproc.output_parse_tree" ) ) { writeParseTree ( "parseTree.xml" , parserAST ) ; } return className ; } private PdeRecognizer createParser ( final String program ) { PdeLexer lexer = new PdeLexer ( new StringReader ( program ) ) ; lexer . setTokenObjectClass ( "antlr.CommonHiddenStreamToken" ) ; filter = new TokenStreamCopyingHiddenTokenFilter ( lexer ) ; filter . hide ( PdePartialTokenTypes . SL_COMMENT ) ; filter . hide ( PdePartialTokenTypes . ML_COMMENT ) ; filter . hide ( PdePartialTokenTypes . WS ) ; filter . copy ( PdePartialTokenTypes . SEMI ) ; filter . copy ( PdePartialTokenTypes . LPAREN ) ; filter . copy ( PdePartialTokenTypes . RPAREN ) ; filter . copy ( PdePartialTokenTypes . LCURLY ) ; filter . copy ( PdePartialTokenTypes . RCURLY ) ; filter . copy ( PdePartialTokenTypes . COMMA ) ; filter . copy ( PdePartialTokenTypes . RBRACK ) ; filter . copy ( PdePartialTokenTypes . LBRACK ) ; filter . copy ( PdePartialTokenTypes . COLON ) ; filter . copy ( PdePartialTokenTypes . TRIPLE_DOT ) ; filter . copy ( PdePartialTokenTypes . LT ) ; filter . copy ( PdePartialTokenTypes . GT ) ; filter . copy ( PdePartialTokenTypes . SR ) ; filter . copy ( PdePartialTokenTypes . BSR ) ; final PdeRecognizer parser = new PdeRecognizer ( this , filter ) ; parser . setASTNodeClass ( "antlr.ExtendedCommonASTWithHiddenTokens" ) ; return parser ; } private void makeSimpleMethodsPublic ( final AST node ) { if ( node . getType ( ) == PdeTokenTypes . METHOD_DEF ) { final AST mods = node . getFirstChild ( ) ; final AST oldFirstMod = mods . getFirstChild ( ) ; for ( AST mod = oldFirstMod ; mod != null ; mod = mod . getNextSibling ( ) ) { final int t = mod . getType ( ) ; if ( t == PdeTokenTypes . LITERAL_private || t == PdeTokenTypes . LITERAL_protected || t == PdeTokenTypes . LITERAL_public ) { return ; } } if ( mods . getNextSibling ( ) . getType ( ) == PdeTokenTypes . TYPE_PARAMETERS ) { return ; } final CommonHiddenStreamToken publicToken = new CommonHiddenStreamToken ( PdeTokenTypes . LITERAL_public , "public" ) { { setHiddenAfter ( new CommonHiddenStreamToken ( PdeTokenTypes . WS , " " ) ) ; } } ; final AST publicNode = new CommonASTWithHiddenTokens ( publicToken ) ; publicNode . setNextSibling ( oldFirstMod ) ; mods . setFirstChild ( publicNode ) ; } else { for ( AST kid = node . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) makeSimpleMethodsPublic ( kid ) ; } } protected void writeParseTree ( String filename , AST ast ) { try { PrintStream stream = new PrintStream ( new FileOutputStream ( filename ) ) ; stream . println ( "<?xml version=\"1.0\"?>" ) ; stream . println ( "<document>" ) ; OutputStreamWriter writer = new OutputStreamWriter ( stream ) ; if ( ast != null ) { ( ( CommonAST ) ast ) . xmlSerialize ( writer ) ; } writer . flush ( ) ; stream . println ( "</document>" ) ; writer . close ( ) ; } catch ( IOException e ) { } } protected int writeImports ( final PrintWriter out , final List < String > programImports , final List < String > codeFolderImports ) { int count = writeImportList ( out , getCoreImports ( ) ) ; count += writeImportList ( out , programImports ) ; count += writeImportList ( out , codeFolderImports ) ; count += writeImportList ( out , getDefaultImports ( ) ) ; return count ; } protected int writeImportList ( PrintWriter out , List < String > imports ) { return writeImportList ( out , imports . toArray ( new String [ 0 ] ) ) ; } protected int writeImportList ( PrintWriter out , String [ ] imports ) { int count = 0 ; if ( imports != null && imports . length != 0 ) { for ( String item : imports ) { out . println ( "import " + item + "; " ) ; count ++ ; } out . println ( ) ; count ++ ; } return count ; } protected void writeDeclaration ( PrintWriter out , String className ) { if ( mode == Mode . JAVA ) { out . println ( ) ; out . println ( ) ; } else if ( mode == Mode . ACTIVE ) { out . println ( "public class " + className + " extends PApplet {" ) ; out . println ( ) ; } else if ( mode == Mode . STATIC ) { out . println ( "public class " + className + " extends PApplet {" ) ; out . println ( indent + "public void setup() {" ) ; } } protected void writeFooter ( PrintWriter out , String className ) { if ( mode == Mode . STATIC ) { out . println ( indent + indent + "noLoop();" ) ; out . println ( indent + "}" ) ; out . println ( ) ; } if ( ( mode == Mode . STATIC ) || ( mode == Mode . ACTIVE ) ) { if ( ! hasMethod ( "settings" ) && sizeInfo . statement != null ) { out . println ( indent + "public void settings() { " + sizeInfo . statement + " }" ) ; } if ( ! hasMethod ( "main" ) ) { out . println ( indent + "static public void main(String[] passedArgs) {" ) ; out . print ( indent + indent + "String[] appletArgs = new String[] { " ) ; if ( Preferences . getBoolean ( "export.application.present" ) ) { out . print ( "\"" + PApplet . ARGS_PRESENT + "\", " ) ; String farbe = Preferences . get ( "run.present.bgcolor" ) ; out . print ( "\"" + PApplet . ARGS_WINDOW_COLOR + "=" + farbe + "\", " ) ; if ( Preferences . getBoolean ( "export.application.stop" ) ) { farbe = Preferences . get ( "run.present.stop.color" ) ; out . print ( "\"" + PApplet . ARGS_STOP_COLOR + "=" + farbe + "\", " ) ; } else { out . print ( "\"" + PApplet . ARGS_HIDE_STOP + "\", " ) ; } } out . println ( "\"" + className + "\" };" ) ; out . println ( indent + indent + "if (passedArgs != null) {" ) ; out . println ( indent + indent + " PApplet.main(concat(appletArgs, passedArgs));" ) ; out . println ( indent + indent + "} else {" ) ; out . println ( indent + indent + " PApplet.main(appletArgs);" ) ; out . println ( indent + indent + "}" ) ; out . println ( indent + "}" ) ; } out . println ( "}" ) ; } } public String [ ] getCoreImports ( ) { return new String [ ] { "processing.core.*" , "processing.data.*" , "processing.event.*" , "processing.opengl.*" } ; } public String [ ] getDefaultImports ( ) { return new String [ ] { "java.util.HashMap" , "java.util.ArrayList" , "java.io.File" , "java.io.BufferedReader" , "java.io.PrintWriter" , "java.io.InputStream" , "java.io.OutputStream" , "java.io.IOException" } ; } public boolean ignoreImport ( String pkg ) { return false ; } String getFirstClassName ( AST ast ) { String t = advClassName ; advClassName = "" ; return t ; } public void debugAST ( final AST ast , final boolean includeHidden ) { System . err . println ( "------------------" ) ; debugAST ( ast , includeHidden , 0 ) ; } private void debugAST ( final AST ast , final boolean includeHidden , final int indent ) { for ( int i = 0 ; i < indent ; i ++ ) System . err . print ( " " ) ; if ( includeHidden ) { System . err . print ( debugHiddenBefore ( ast ) ) ; } if ( ast . getType ( ) > 0 && ! ast . getText ( ) . equals ( TokenUtil . nameOf ( ast ) ) ) { System . err . print ( TokenUtil . nameOf ( ast ) + "/" ) ; } System . err . print ( ast . getText ( ) . replace ( "\n" , "\\n" ) ) ; if ( includeHidden ) { System . err . print ( debugHiddenAfter ( ast ) ) ; } System . err . println ( ) ; for ( AST kid = ast . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) debugAST ( kid , includeHidden , indent + 1 ) ; } private String debugHiddenAfter ( AST ast ) { return ( ast instanceof antlr . CommonASTWithHiddenTokens ) ? debugHiddenTokens ( ( ( antlr . CommonASTWithHiddenTokens ) ast ) . getHiddenAfter ( ) ) : "" ; } private String debugHiddenBefore ( AST ast ) { if ( ! ( ast instanceof antlr . CommonASTWithHiddenTokens ) ) { return "" ; } antlr . CommonHiddenStreamToken parent = ( ( antlr . CommonASTWithHiddenTokens ) ast ) . getHiddenBefore ( ) ; if ( parent == null ) { return "" ; } antlr . CommonHiddenStreamToken child = null ; do { child = parent ; parent = child . getHiddenBefore ( ) ; } while ( parent != null ) ; return debugHiddenTokens ( child ) ; } private String debugHiddenTokens ( antlr . CommonHiddenStreamToken t ) { final StringBuilder sb = new StringBuilder ( ) ; for ( ; t != null ; t = filter . getHiddenAfter ( t ) ) { if ( sb . length ( ) == 0 ) { sb . append ( "[" ) ; } sb . append ( t . getText ( ) . replace ( "\n" , "\\n" ) ) ; } if ( sb . length ( ) > 0 ) { sb . append ( "]" ) ; } return sb . toString ( ) ; } }
package processing . mode . java . preproc ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import processing . app . SketchException ; public class PreprocessorResult { public final int headerOffset ; public final String className ; public final List < String > extraImports ; public final PdePreprocessor . Mode programType ; public PreprocessorResult ( PdePreprocessor . Mode programType , int headerOffset , String className , final List < String > extraImports ) throws SketchException { if ( className == null ) { throw new SketchException ( "Could not find main class" ) ; } this . headerOffset = headerOffset ; this . className = className ; this . extraImports = Collections . unmodifiableList ( new ArrayList < String > ( extraImports ) ) ; this . programType = programType ; } }
package processing . core ; import java . awt . * ; import java . awt . image . * ; import java . io . * ; import java . util . Iterator ; import javax . imageio . * ; import javax . imageio . metadata . * ; public class PImage implements PConstants , Cloneable { public int format ; public int [ ] pixels ; public int pixelDensity = 1 ; public int pixelWidth ; public int pixelHeight ; public int width ; public int height ; public PApplet parent ; protected boolean modified ; protected int mx1 , my1 , mx2 , my2 ; public boolean loaded = false ; private int fracU , ifU , fracV , ifV , u1 , u2 , v1 , v2 , sX , sY , iw , iw1 , ih1 ; private int ul , ll , ur , lr , cUL , cLL , cUR , cLR ; private int srcXOffset , srcYOffset ; private int r , g , b , a ; private int [ ] srcBuffer ; static final int PRECISIONB = 15 ; static final int PRECISIONF = 1 < < PRECISIONB ; static final int PREC_MAXVAL = PRECISIONF - 1 ; static final int PREC_ALPHA_SHIFT = 24 - PRECISIONB ; static final int PREC_RED_SHIFT = 16 - PRECISIONB ; private int blurRadius ; private int blurKernelSize ; private int [ ] blurKernel ; private int [ ] [ ] blurMult ; public static final int ALPHA_MASK = 0xff000000 ; public static final int RED_MASK = 0x00ff0000 ; public static final int GREEN_MASK = 0x0000ff00 ; public static final int BLUE_MASK = 0x000000ff ; public PImage ( ) { format = ARGB ; pixelDensity = 1 ; } public PImage ( int width , int height ) { init ( width , height , RGB , 1 ) ; } public PImage ( int width , int height , int format ) { init ( width , height , format , 1 ) ; } public PImage ( int width , int height , int format , int factor ) { init ( width , height , format , factor ) ; } public void init ( int width , int height , int format ) { init ( width , height , format , 1 ) ; } public void init ( int width , int height , int format , int factor ) { this . width = width ; this . height = height ; this . format = format ; this . pixelDensity = factor ; pixelWidth = width * pixelDensity ; pixelHeight = height * pixelDensity ; this . pixels = new int [ pixelWidth * pixelHeight ] ; } protected void checkAlpha ( ) { if ( pixels == null ) return ; for ( int i = 0 ; i < pixels . length ; i ++ ) { if ( ( pixels [ i ] & 0xff000000 ) != 0xff000000 ) { format = ARGB ; break ; } } } public PImage ( Image img ) { format = RGB ; if ( img instanceof BufferedImage ) { BufferedImage bi = ( BufferedImage ) img ; width = bi . getWidth ( ) ; height = bi . getHeight ( ) ; pixels = new int [ width * height ] ; pixels = ( ( DataBufferInt ) bi . getRaster ( ) . getDataBuffer ( ) ) . getData ( ) ; int type = bi . getType ( ) ; if ( type == BufferedImage . TYPE_INT_ARGB ) { format = ARGB ; } else if ( type == BufferedImage . TYPE_INT_RGB ) { for ( int i = 0 ; i < pixels . length ; i ++ ) { pixels [ i ] = 0xFF000000 | pixels [ i ] ; } } } else { width = img . getWidth ( null ) ; height = img . getHeight ( null ) ; pixels = new int [ width * height ] ; PixelGrabber pg = new PixelGrabber ( img , 0 , 0 , width , height , pixels , 0 , width ) ; try { pg . grabPixels ( ) ; } catch ( InterruptedException e ) { } } pixelDensity = 1 ; pixelWidth = width ; pixelHeight = height ; } @ Deprecated public Image getImage ( ) { return ( Image ) getNative ( ) ; } public Object getNative ( ) { loadPixels ( ) ; int type = ( format == RGB ) ? BufferedImage . TYPE_INT_RGB : BufferedImage . TYPE_INT_ARGB ; BufferedImage image = new BufferedImage ( pixelWidth , pixelHeight , type ) ; WritableRaster wr = image . getRaster ( ) ; wr . setDataElements ( 0 , 0 , pixelWidth , pixelHeight , pixels ) ; return image ; } public boolean isModified ( ) { return modified ; } public void setModified ( ) { modified = true ; mx1 = 0 ; my1 = 0 ; mx2 = pixelWidth ; my2 = pixelHeight ; } public void setModified ( boolean m ) { modified = m ; } public int getModifiedX1 ( ) { return mx1 ; } public int getModifiedX2 ( ) { return mx2 ; } public int getModifiedY1 ( ) { return my1 ; } public int getModifiedY2 ( ) { return my2 ; } public void loadPixels ( ) { if ( pixels == null || pixels . length != pixelWidth * pixelHeight ) { pixels = new int [ pixelWidth * pixelHeight ] ; } setLoaded ( ) ; } public void updatePixels ( ) { updatePixels ( 0 , 0 , pixelWidth , pixelHeight ) ; } public void updatePixels ( int x , int y , int w , int h ) { int x2 = x + w ; int y2 = y + h ; if ( ! modified ) { mx1 = PApplet . max ( 0 , x ) ; mx2 = PApplet . min ( pixelWidth , x2 ) ; my1 = PApplet . max ( 0 , y ) ; my2 = PApplet . min ( pixelHeight , y2 ) ; modified = true ; } else { if ( x < mx1 ) mx1 = PApplet . max ( 0 , x ) ; if ( x > mx2 ) mx2 = PApplet . min ( pixelWidth , x ) ; if ( y < my1 ) my1 = PApplet . max ( 0 , y ) ; if ( y > my2 ) my2 = PApplet . min ( pixelHeight , y ) ; if ( x2 < mx1 ) mx1 = PApplet . max ( 0 , x2 ) ; if ( x2 > mx2 ) mx2 = PApplet . min ( pixelWidth , x2 ) ; if ( y2 < my1 ) my1 = PApplet . max ( 0 , y2 ) ; if ( y2 > my2 ) my2 = PApplet . min ( pixelHeight , y2 ) ; } } @ Override public Object clone ( ) throws CloneNotSupportedException { return get ( ) ; } public void resize ( int w , int h ) { if ( w <= 0 && h <= 0 ) { throw new IllegalArgumentException ( "width or height must be > 0 for resize" ) ; } if ( w == 0 ) { float diff = ( float ) h / ( float ) height ; w = ( int ) ( width * diff ) ; } else if ( h == 0 ) { float diff = ( float ) w / ( float ) width ; h = ( int ) ( height * diff ) ; } BufferedImage img = shrinkImage ( ( BufferedImage ) getNative ( ) , w * pixelDensity , h * pixelDensity ) ; PImage temp = new PImage ( img ) ; this . pixelWidth = temp . width ; this . pixelHeight = temp . height ; this . pixels = temp . pixels ; this . width = pixelWidth / pixelDensity ; this . height = pixelHeight / pixelDensity ; updatePixels ( ) ; } static private BufferedImage shrinkImage ( BufferedImage img , int targetWidth , int targetHeight ) { int type = ( img . getTransparency ( ) == Transparency . OPAQUE ) ? BufferedImage . TYPE_INT_RGB : BufferedImage . TYPE_INT_ARGB ; BufferedImage outgoing = img ; BufferedImage scratchImage = null ; Graphics2D g2 = null ; int prevW = outgoing . getWidth ( ) ; int prevH = outgoing . getHeight ( ) ; boolean isTranslucent = img . getTransparency ( ) != Transparency . OPAQUE ; int w = img . getWidth ( ) ; int h = img . getHeight ( ) ; do { if ( w > targetWidth ) { w /= 2 ; if ( w < targetWidth ) { w = targetWidth ; } } else if ( targetWidth >= w ) { w = targetWidth ; } if ( h > targetHeight ) { h /= 2 ; if ( h < targetHeight ) { h = targetHeight ; } } else if ( targetHeight >= h ) { h = targetHeight ; } if ( scratchImage == null || isTranslucent ) { scratchImage = new BufferedImage ( w , h , type ) ; g2 = scratchImage . createGraphics ( ) ; } g2 . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; g2 . drawImage ( outgoing , 0 , 0 , w , h , 0 , 0 , prevW , prevH , null ) ; prevW = w ; prevH = h ; outgoing = scratchImage ; } while ( w != targetWidth || h != targetHeight ) ; if ( g2 != null ) { g2 . dispose ( ) ; } if ( targetWidth != outgoing . getWidth ( ) || targetHeight != outgoing . getHeight ( ) ) { scratchImage = new BufferedImage ( targetWidth , targetHeight , type ) ; g2 = scratchImage . createGraphics ( ) ; g2 . drawImage ( outgoing , 0 , 0 , null ) ; g2 . dispose ( ) ; outgoing = scratchImage ; } return outgoing ; } public boolean isLoaded ( ) { return loaded ; } public void setLoaded ( ) { loaded = true ; } public void setLoaded ( boolean l ) { loaded = l ; } public int get ( int x , int y ) { if ( ( x < 0 ) || ( y < 0 ) || ( x >= pixelWidth ) || ( y >= pixelHeight ) ) return 0 ; switch ( format ) { case RGB : return pixels [ y * pixelWidth + x ] | 0xff000000 ; case ARGB : return pixels [ y * pixelWidth + x ] ; case ALPHA : return ( pixels [ y * pixelWidth + x ] < < 24 ) | 0xffffff ; } return 0 ; } public PImage get ( int x , int y , int w , int h ) { int targetX = 0 ; int targetY = 0 ; int targetWidth = w ; int targetHeight = h ; boolean cropped = false ; if ( x < 0 ) { w += x ; targetX = - x ; cropped = true ; x = 0 ; } if ( y < 0 ) { h += y ; targetY = - y ; cropped = true ; y = 0 ; } if ( x + w > pixelWidth ) { w = pixelWidth - x ; cropped = true ; } if ( y + h > pixelHeight ) { h = pixelHeight - y ; cropped = true ; } if ( w < 0 ) { w = 0 ; } if ( h < 0 ) { h = 0 ; } int targetFormat = format ; if ( cropped && format == RGB ) { targetFormat = ARGB ; } PImage target = new PImage ( targetWidth / pixelDensity , targetHeight / pixelDensity , targetFormat , pixelDensity ) ; target . parent = parent ; if ( w > 0 && h > 0 ) { getImpl ( x , y , w , h , target , targetX , targetY ) ; } return target ; } public PImage get ( ) { return get ( 0 , 0 , pixelWidth , pixelHeight ) ; } public PImage copy ( ) { return get ( 0 , 0 , pixelWidth , pixelHeight ) ; } protected void getImpl ( int sourceX , int sourceY , int sourceWidth , int sourceHeight , PImage target , int targetX , int targetY ) { int sourceIndex = sourceY * pixelWidth + sourceX ; int targetIndex = targetY * target . pixelWidth + targetX ; for ( int row = 0 ; row < sourceHeight ; row ++ ) { System . arraycopy ( pixels , sourceIndex , target . pixels , targetIndex , sourceWidth ) ; sourceIndex += pixelWidth ; targetIndex += target . pixelWidth ; } } public void set ( int x , int y , int c ) { if ( ( x < 0 ) || ( y < 0 ) || ( x >= pixelWidth ) || ( y >= pixelHeight ) ) return ; pixels [ y * pixelWidth + x ] = c ; updatePixels ( x , y , 1 , 1 ) ; } public void set ( int x , int y , PImage img ) { int sx = 0 ; int sy = 0 ; int sw = img . pixelWidth ; int sh = img . pixelHeight ; if ( x < 0 ) { sx -= x ; sw += x ; x = 0 ; } if ( y < 0 ) { sy -= y ; sh += y ; y = 0 ; } if ( x + sw > pixelWidth ) { sw = pixelWidth - x ; } if ( y + sh > pixelHeight ) { sh = pixelHeight - y ; } if ( ( sw <= 0 ) || ( sh <= 0 ) ) return ; setImpl ( img , sx , sy , sw , sh , x , y ) ; } protected void setImpl ( PImage sourceImage , int sourceX , int sourceY , int sourceWidth , int sourceHeight , int targetX , int targetY ) { int sourceOffset = sourceY * sourceImage . pixelWidth + sourceX ; int targetOffset = targetY * pixelWidth + targetX ; for ( int y = sourceY ; y < sourceY + sourceHeight ; y ++ ) { System . arraycopy ( sourceImage . pixels , sourceOffset , pixels , targetOffset , sourceWidth ) ; sourceOffset += sourceImage . pixelWidth ; targetOffset += pixelWidth ; } updatePixels ( targetX , targetY , sourceWidth , sourceHeight ) ; } @ Deprecated public void mask ( int maskArray [ ] ) { loadPixels ( ) ; if ( maskArray . length != pixels . length ) { throw new IllegalArgumentException ( "mask() can only be used with an image that's the same size." ) ; } for ( int i = 0 ; i < pixels . length ; i ++ ) { pixels [ i ] = ( ( maskArray [ i ] & 0xff ) < < 24 ) | ( pixels [ i ] & 0xffffff ) ; } format = ARGB ; updatePixels ( ) ; } public void mask ( PImage img ) { img . loadPixels ( ) ; mask ( img . pixels ) ; } public void filter ( int kind ) { loadPixels ( ) ; switch ( kind ) { case BLUR : filter ( BLUR , 1 ) ; break ; case GRAY : if ( format == ALPHA ) { for ( int i = 0 ; i < pixels . length ; i ++ ) { int col = 255 - pixels [ i ] ; pixels [ i ] = 0xff000000 | ( col < < 16 ) | ( col < < 8 ) | col ; } format = RGB ; } else { for ( int i = 0 ; i < pixels . length ; i ++ ) { int col = pixels [ i ] ; int lum = ( 77 * ( col > > 16 & 0xff ) + 151 * ( col > > 8 & 0xff ) + 28 * ( col & 0xff ) ) > > 8 ; pixels [ i ] = ( col & ALPHA_MASK ) | lum < < 16 | lum < < 8 | lum ; } } break ; case INVERT : for ( int i = 0 ; i < pixels . length ; i ++ ) { pixels [ i ] ^= 0xffffff ; } break ; case POSTERIZE : throw new RuntimeException ( "Use filter(POSTERIZE, int levels) " + "instead of filter(POSTERIZE)" ) ; case OPAQUE : for ( int i = 0 ; i < pixels . length ; i ++ ) { pixels [ i ] |= 0xff000000 ; } format = RGB ; break ; case THRESHOLD : filter ( THRESHOLD , 0.5f ) ; break ; case ERODE : erode ( ) ; break ; case DILATE : dilate ( ) ; break ; } updatePixels ( ) ; } public void filter ( int kind , float param ) { loadPixels ( ) ; switch ( kind ) { case BLUR : if ( format == ALPHA ) blurAlpha ( param ) ; else if ( format == ARGB ) blurARGB ( param ) ; else blurRGB ( param ) ; break ; case GRAY : throw new RuntimeException ( "Use filter(GRAY) instead of " + "filter(GRAY, param)" ) ; case INVERT : throw new RuntimeException ( "Use filter(INVERT) instead of " + "filter(INVERT, param)" ) ; case OPAQUE : throw new RuntimeException ( "Use filter(OPAQUE) instead of " + "filter(OPAQUE, param)" ) ; case POSTERIZE : int levels = ( int ) param ; if ( ( levels < 2 ) || ( levels > 255 ) ) { throw new RuntimeException ( "Levels must be between 2 and 255 for " + "filter(POSTERIZE, levels)" ) ; } int levels1 = levels - 1 ; for ( int i = 0 ; i < pixels . length ; i ++ ) { int rlevel = ( pixels [ i ] > > 16 ) & 0xff ; int glevel = ( pixels [ i ] > > 8 ) & 0xff ; int blevel = pixels [ i ] & 0xff ; rlevel = ( ( ( rlevel * levels ) > > 8 ) * 255 ) / levels1 ; glevel = ( ( ( glevel * levels ) > > 8 ) * 255 ) / levels1 ; blevel = ( ( ( blevel * levels ) > > 8 ) * 255 ) / levels1 ; pixels [ i ] = ( ( 0xff000000 & pixels [ i ] ) | ( rlevel < < 16 ) | ( glevel < < 8 ) | blevel ) ; } break ; case THRESHOLD : int thresh = ( int ) ( param * 255 ) ; for ( int i = 0 ; i < pixels . length ; i ++ ) { int max = Math . max ( ( pixels [ i ] & RED_MASK ) > > 16 , Math . max ( ( pixels [ i ] & GREEN_MASK ) > > 8 , ( pixels [ i ] & BLUE_MASK ) ) ) ; pixels [ i ] = ( pixels [ i ] & ALPHA_MASK ) | ( ( max < thresh ) ? 0x000000 : 0xffffff ) ; } break ; case ERODE : throw new RuntimeException ( "Use filter(ERODE) instead of " + "filter(ERODE, param)" ) ; case DILATE : throw new RuntimeException ( "Use filter(DILATE) instead of " + "filter(DILATE, param)" ) ; } updatePixels ( ) ; } protected void buildBlurKernel ( float r ) { int radius = ( int ) ( r * 3.5f ) ; radius = ( radius < 1 ) ? 1 : ( ( radius < 248 ) ? radius : 248 ) ; if ( blurRadius != radius ) { blurRadius = radius ; blurKernelSize = 1 + blurRadius < < 1 ; blurKernel = new int [ blurKernelSize ] ; blurMult = new int [ blurKernelSize ] [ 256 ] ; int bk , bki ; int [ ] bm , bmi ; for ( int i = 1 , radiusi = radius - 1 ; i < radius ; i ++ ) { blurKernel [ radius + i ] = blurKernel [ radiusi ] = bki = radiusi * radiusi ; bm = blurMult [ radius + i ] ; bmi = blurMult [ radiusi -- ] ; for ( int j = 0 ; j < 256 ; j ++ ) bm [ j ] = bmi [ j ] = bki * j ; } bk = blurKernel [ radius ] = radius * radius ; bm = blurMult [ radius ] ; for ( int j = 0 ; j < 256 ; j ++ ) bm [ j ] = bk * j ; } } protected void blurAlpha ( float r ) { int sum , cb ; int read , ri , ym , ymi , bk0 ; int b2 [ ] = new int [ pixels . length ] ; int yi = 0 ; buildBlurKernel ( r ) ; for ( int y = 0 ; y < pixelHeight ; y ++ ) { for ( int x = 0 ; x < pixelWidth ; x ++ ) { cb = sum = 0 ; read = x - blurRadius ; if ( read < 0 ) { bk0 = - read ; read = 0 ; } else { if ( read >= pixelWidth ) break ; bk0 = 0 ; } for ( int i = bk0 ; i < blurKernelSize ; i ++ ) { if ( read >= pixelWidth ) break ; int c = pixels [ read + yi ] ; int [ ] bm = blurMult [ i ] ; cb += bm [ c & BLUE_MASK ] ; sum += blurKernel [ i ] ; read ++ ; } ri = yi + x ; b2 [ ri ] = cb / sum ; } yi += pixelWidth ; } yi = 0 ; ym = - blurRadius ; ymi = ym * pixelWidth ; for ( int y = 0 ; y < pixelHeight ; y ++ ) { for ( int x = 0 ; x < pixelWidth ; x ++ ) { cb = sum = 0 ; if ( ym < 0 ) { bk0 = ri = - ym ; read = x ; } else { if ( ym >= pixelHeight ) break ; bk0 = 0 ; ri = ym ; read = x + ymi ; } for ( int i = bk0 ; i < blurKernelSize ; i ++ ) { if ( ri >= pixelHeight ) break ; int [ ] bm = blurMult [ i ] ; cb += bm [ b2 [ read ] ] ; sum += blurKernel [ i ] ; ri ++ ; read += pixelWidth ; } pixels [ x + yi ] = ( cb / sum ) ; } yi += pixelWidth ; ymi += pixelWidth ; ym ++ ; } } protected void blurRGB ( float r ) { int sum , cr , cg , cb ; int read , ri , ym , ymi , bk0 ; int r2 [ ] = new int [ pixels . length ] ; int g2 [ ] = new int [ pixels . length ] ; int b2 [ ] = new int [ pixels . length ] ; int yi = 0 ; buildBlurKernel ( r ) ; for ( int y = 0 ; y < pixelHeight ; y ++ ) { for ( int x = 0 ; x < pixelWidth ; x ++ ) { cb = cg = cr = sum = 0 ; read = x - blurRadius ; if ( read < 0 ) { bk0 = - read ; read = 0 ; } else { if ( read >= pixelWidth ) { break ; } bk0 = 0 ; } for ( int i = bk0 ; i < blurKernelSize ; i ++ ) { if ( read >= pixelWidth ) { break ; } int c = pixels [ read + yi ] ; int [ ] bm = blurMult [ i ] ; cr += bm [ ( c & RED_MASK ) > > 16 ] ; cg += bm [ ( c & GREEN_MASK ) > > 8 ] ; cb += bm [ c & BLUE_MASK ] ; sum += blurKernel [ i ] ; read ++ ; } ri = yi + x ; r2 [ ri ] = cr / sum ; g2 [ ri ] = cg / sum ; b2 [ ri ] = cb / sum ; } yi += pixelWidth ; } yi = 0 ; ym = - blurRadius ; ymi = ym * pixelWidth ; for ( int y = 0 ; y < pixelHeight ; y ++ ) { for ( int x = 0 ; x < pixelWidth ; x ++ ) { cb = cg = cr = sum = 0 ; if ( ym < 0 ) { bk0 = ri = - ym ; read = x ; } else { if ( ym >= pixelHeight ) { break ; } bk0 = 0 ; ri = ym ; read = x + ymi ; } for ( int i = bk0 ; i < blurKernelSize ; i ++ ) { if ( ri >= pixelHeight ) { break ; } int [ ] bm = blurMult [ i ] ; cr += bm [ r2 [ read ] ] ; cg += bm [ g2 [ read ] ] ; cb += bm [ b2 [ read ] ] ; sum += blurKernel [ i ] ; ri ++ ; read += pixelWidth ; } pixels [ x + yi ] = 0xff000000 | ( cr / sum ) < < 16 | ( cg / sum ) < < 8 | ( cb / sum ) ; } yi += pixelWidth ; ymi += pixelWidth ; ym ++ ; } } protected void blurARGB ( float r ) { int sum , cr , cg , cb , ca ; int read , ri , ym , ymi , bk0 ; int wh = pixels . length ; int r2 [ ] = new int [ wh ] ; int g2 [ ] = new int [ wh ] ; int b2 [ ] = new int [ wh ] ; int a2 [ ] = new int [ wh ] ; int yi = 0 ; buildBlurKernel ( r ) ; for ( int y = 0 ; y < pixelHeight ; y ++ ) { for ( int x = 0 ; x < pixelWidth ; x ++ ) { cb = cg = cr = ca = sum = 0 ; read = x - blurRadius ; if ( read < 0 ) { bk0 = - read ; read = 0 ; } else { if ( read >= pixelWidth ) { break ; } bk0 = 0 ; } for ( int i = bk0 ; i < blurKernelSize ; i ++ ) { if ( read >= pixelWidth ) { break ; } int c = pixels [ read + yi ] ; int [ ] bm = blurMult [ i ] ; ca += bm [ ( c & ALPHA_MASK ) > > > 24 ] ; cr += bm [ ( c & RED_MASK ) > > 16 ] ; cg += bm [ ( c & GREEN_MASK ) > > 8 ] ; cb += bm [ c & BLUE_MASK ] ; sum += blurKernel [ i ] ; read ++ ; } ri = yi + x ; a2 [ ri ] = ca / sum ; r2 [ ri ] = cr / sum ; g2 [ ri ] = cg / sum ; b2 [ ri ] = cb / sum ; } yi += pixelWidth ; } yi = 0 ; ym = - blurRadius ; ymi = ym * pixelWidth ; for ( int y = 0 ; y < pixelHeight ; y ++ ) { for ( int x = 0 ; x < pixelWidth ; x ++ ) { cb = cg = cr = ca = sum = 0 ; if ( ym < 0 ) { bk0 = ri = - ym ; read = x ; } else { if ( ym >= pixelHeight ) { break ; } bk0 = 0 ; ri = ym ; read = x + ymi ; } for ( int i = bk0 ; i < blurKernelSize ; i ++ ) { if ( ri >= pixelHeight ) { break ; } int [ ] bm = blurMult [ i ] ; ca += bm [ a2 [ read ] ] ; cr += bm [ r2 [ read ] ] ; cg += bm [ g2 [ read ] ] ; cb += bm [ b2 [ read ] ] ; sum += blurKernel [ i ] ; ri ++ ; read += pixelWidth ; } pixels [ x + yi ] = ( ca / sum ) < < 24 | ( cr / sum ) < < 16 | ( cg / sum ) < < 8 | ( cb / sum ) ; } yi += pixelWidth ; ymi += pixelWidth ; ym ++ ; } } protected void dilate ( ) { int index = 0 ; int maxIndex = pixels . length ; int [ ] outgoing = new int [ maxIndex ] ; while ( index < maxIndex ) { int curRowIndex = index ; int maxRowIndex = index + pixelWidth ; while ( index < maxRowIndex ) { int orig = pixels [ index ] ; int result = orig ; int idxLeft = index - 1 ; int idxRight = index + 1 ; int idxUp = index - pixelWidth ; int idxDown = index + pixelWidth ; if ( idxLeft < curRowIndex ) { idxLeft = index ; } if ( idxRight >= maxRowIndex ) { idxRight = index ; } if ( idxUp < 0 ) { idxUp = index ; } if ( idxDown >= maxIndex ) { idxDown = index ; } int colUp = pixels [ idxUp ] ; int colLeft = pixels [ idxLeft ] ; int colDown = pixels [ idxDown ] ; int colRight = pixels [ idxRight ] ; int currLum = 77 * ( orig > > 16 & 0xff ) + 151 * ( orig > > 8 & 0xff ) + 28 * ( orig & 0xff ) ; int lumLeft = 77 * ( colLeft > > 16 & 0xff ) + 151 * ( colLeft > > 8 & 0xff ) + 28 * ( colLeft & 0xff ) ; int lumRight = 77 * ( colRight > > 16 & 0xff ) + 151 * ( colRight > > 8 & 0xff ) + 28 * ( colRight & 0xff ) ; int lumUp = 77 * ( colUp > > 16 & 0xff ) + 151 * ( colUp > > 8 & 0xff ) + 28 * ( colUp & 0xff ) ; int lumDown = 77 * ( colDown > > 16 & 0xff ) + 151 * ( colDown > > 8 & 0xff ) + 28 * ( colDown & 0xff ) ; if ( lumLeft > currLum ) { result = colLeft ; currLum = lumLeft ; } if ( lumRight > currLum ) { result = colRight ; currLum = lumRight ; } if ( lumUp > currLum ) { result = colUp ; currLum = lumUp ; } if ( lumDown > currLum ) { result = colDown ; currLum = lumDown ; } outgoing [ index ++ ] = result ; } } System . arraycopy ( outgoing , 0 , pixels , 0 , maxIndex ) ; } protected void erode ( ) { int index = 0 ; int maxIndex = pixels . length ; int [ ] outgoing = new int [ maxIndex ] ; while ( index < maxIndex ) { int curRowIndex = index ; int maxRowIndex = index + pixelWidth ; while ( index < maxRowIndex ) { int orig = pixels [ index ] ; int result = orig ; int idxLeft = index - 1 ; int idxRight = index + 1 ; int idxUp = index - pixelWidth ; int idxDown = index + pixelWidth ; if ( idxLeft < curRowIndex ) { idxLeft = index ; } if ( idxRight >= maxRowIndex ) { idxRight = index ; } if ( idxUp < 0 ) { idxUp = index ; } if ( idxDown >= maxIndex ) { idxDown = index ; } int colUp = pixels [ idxUp ] ; int colLeft = pixels [ idxLeft ] ; int colDown = pixels [ idxDown ] ; int colRight = pixels [ idxRight ] ; int currLum = 77 * ( orig > > 16 & 0xff ) + 151 * ( orig > > 8 & 0xff ) + 28 * ( orig & 0xff ) ; int lumLeft = 77 * ( colLeft > > 16 & 0xff ) + 151 * ( colLeft > > 8 & 0xff ) + 28 * ( colLeft & 0xff ) ; int lumRight = 77 * ( colRight > > 16 & 0xff ) + 151 * ( colRight > > 8 & 0xff ) + 28 * ( colRight & 0xff ) ; int lumUp = 77 * ( colUp > > 16 & 0xff ) + 151 * ( colUp > > 8 & 0xff ) + 28 * ( colUp & 0xff ) ; int lumDown = 77 * ( colDown > > 16 & 0xff ) + 151 * ( colDown > > 8 & 0xff ) + 28 * ( colDown & 0xff ) ; if ( lumLeft < currLum ) { result = colLeft ; currLum = lumLeft ; } if ( lumRight < currLum ) { result = colRight ; currLum = lumRight ; } if ( lumUp < currLum ) { result = colUp ; currLum = lumUp ; } if ( lumDown < currLum ) { result = colDown ; currLum = lumDown ; } outgoing [ index ++ ] = result ; } } System . arraycopy ( outgoing , 0 , pixels , 0 , maxIndex ) ; } public void copy ( int sx , int sy , int sw , int sh , int dx , int dy , int dw , int dh ) { blend ( this , sx , sy , sw , sh , dx , dy , dw , dh , REPLACE ) ; } public void copy ( PImage src , int sx , int sy , int sw , int sh , int dx , int dy , int dw , int dh ) { blend ( src , sx , sy , sw , sh , dx , dy , dw , dh , REPLACE ) ; } static public int blendColor ( int c1 , int c2 , int mode ) { switch ( mode ) { case REPLACE : return c2 ; case BLEND : return blend_blend ( c1 , c2 ) ; case ADD : return blend_add_pin ( c1 , c2 ) ; case SUBTRACT : return blend_sub_pin ( c1 , c2 ) ; case LIGHTEST : return blend_lightest ( c1 , c2 ) ; case DARKEST : return blend_darkest ( c1 , c2 ) ; case DIFFERENCE : return blend_difference ( c1 , c2 ) ; case EXCLUSION : return blend_exclusion ( c1 , c2 ) ; case MULTIPLY : return blend_multiply ( c1 , c2 ) ; case SCREEN : return blend_screen ( c1 , c2 ) ; case HARD_LIGHT : return blend_hard_light ( c1 , c2 ) ; case SOFT_LIGHT : return blend_soft_light ( c1 , c2 ) ; case OVERLAY : return blend_overlay ( c1 , c2 ) ; case DODGE : return blend_dodge ( c1 , c2 ) ; case BURN : return blend_burn ( c1 , c2 ) ; } return 0 ; } public void blend ( int sx , int sy , int sw , int sh , int dx , int dy , int dw , int dh , int mode ) { blend ( this , sx , sy , sw , sh , dx , dy , dw , dh , mode ) ; } public void blend ( PImage src , int sx , int sy , int sw , int sh , int dx , int dy , int dw , int dh , int mode ) { int sx2 = sx + sw ; int sy2 = sy + sh ; int dx2 = dx + dw ; int dy2 = dy + dh ; loadPixels ( ) ; if ( src == this ) { if ( intersect ( sx , sy , sx2 , sy2 , dx , dy , dx2 , dy2 ) ) { blit_resize ( get ( sx , sy , sx2 - sx , sy2 - sy ) , 0 , 0 , sx2 - sx - 1 , sy2 - sy - 1 , pixels , pixelWidth , pixelHeight , dx , dy , dx2 , dy2 , mode ) ; } else { blit_resize ( src , sx , sy , sx2 , sy2 , pixels , pixelWidth , pixelHeight , dx , dy , dx2 , dy2 , mode ) ; } } else { src . loadPixels ( ) ; blit_resize ( src , sx , sy , sx2 , sy2 , pixels , pixelWidth , pixelHeight , dx , dy , dx2 , dy2 , mode ) ; } updatePixels ( ) ; } private boolean intersect ( int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 , int dx2 , int dy2 ) { int sw = sx2 - sx1 + 1 ; int sh = sy2 - sy1 + 1 ; int dw = dx2 - dx1 + 1 ; int dh = dy2 - dy1 + 1 ; if ( dx1 < sx1 ) { dw += dx1 - sx1 ; if ( dw > sw ) { dw = sw ; } } else { int w = sw + sx1 - dx1 ; if ( dw > w ) { dw = w ; } } if ( dy1 < sy1 ) { dh += dy1 - sy1 ; if ( dh > sh ) { dh = sh ; } } else { int h = sh + sy1 - dy1 ; if ( dh > h ) { dh = h ; } } return ! ( dw <= 0 || dh <= 0 ) ; } private void blit_resize ( PImage img , int srcX1 , int srcY1 , int srcX2 , int srcY2 , int [ ] destPixels , int screenW , int screenH , int destX1 , int destY1 , int destX2 , int destY2 , int mode ) { if ( srcX1 < 0 ) srcX1 = 0 ; if ( srcY1 < 0 ) srcY1 = 0 ; if ( srcX2 > img . pixelWidth ) srcX2 = img . pixelWidth ; if ( srcY2 > img . pixelHeight ) srcY2 = img . pixelHeight ; int srcW = srcX2 - srcX1 ; int srcH = srcY2 - srcY1 ; int destW = destX2 - destX1 ; int destH = destY2 - destY1 ; boolean smooth = true ; if ( ! smooth ) { srcW ++ ; srcH ++ ; } if ( destW <= 0 || destH <= 0 || srcW <= 0 || srcH <= 0 || destX1 >= screenW || destY1 >= screenH || srcX1 >= img . pixelWidth || srcY1 >= img . pixelHeight ) { return ; } int dx = ( int ) ( srcW / ( float ) destW * PRECISIONF ) ; int dy = ( int ) ( srcH / ( float ) destH * PRECISIONF ) ; srcXOffset = destX1 < 0 ? - destX1 * dx : srcX1 * PRECISIONF ; srcYOffset = destY1 < 0 ? - destY1 * dy : srcY1 * PRECISIONF ; if ( destX1 < 0 ) { destW += destX1 ; destX1 = 0 ; } if ( destY1 < 0 ) { destH += destY1 ; destY1 = 0 ; } destW = low ( destW , screenW - destX1 ) ; destH = low ( destH , screenH - destY1 ) ; int destOffset = destY1 * screenW + destX1 ; srcBuffer = img . pixels ; if ( smooth ) { iw = img . pixelWidth ; iw1 = img . pixelWidth - 1 ; ih1 = img . pixelHeight - 1 ; switch ( mode ) { case BLEND : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_blend ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case ADD : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_add_pin ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case SUBTRACT : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_sub_pin ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case LIGHTEST : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_lightest ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case DARKEST : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_darkest ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case REPLACE : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = filter_bilinear ( ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case DIFFERENCE : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_difference ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case EXCLUSION : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_exclusion ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case MULTIPLY : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_multiply ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case SCREEN : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_screen ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case OVERLAY : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_overlay ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case HARD_LIGHT : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_hard_light ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case SOFT_LIGHT : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_soft_light ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case DODGE : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_dodge ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case BURN : for ( int y = 0 ; y < destH ; y ++ ) { filter_new_scanline ( ) ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_burn ( destPixels [ destOffset + x ] , filter_bilinear ( ) ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; } } else { switch ( mode ) { case BLEND : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_blend ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case ADD : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_add_pin ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case SUBTRACT : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_sub_pin ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case LIGHTEST : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_lightest ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case DARKEST : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_darkest ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case REPLACE : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = srcBuffer [ sY + ( sX > > PRECISIONB ) ] ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case DIFFERENCE : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_difference ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case EXCLUSION : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_exclusion ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case MULTIPLY : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_multiply ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case SCREEN : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_screen ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case OVERLAY : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_overlay ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case HARD_LIGHT : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_hard_light ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case SOFT_LIGHT : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_soft_light ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case DODGE : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_dodge ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; case BURN : for ( int y = 0 ; y < destH ; y ++ ) { sX = srcXOffset ; sY = ( srcYOffset > > PRECISIONB ) * img . pixelWidth ; for ( int x = 0 ; x < destW ; x ++ ) { destPixels [ destOffset + x ] = blend_burn ( destPixels [ destOffset + x ] , srcBuffer [ sY + ( sX > > PRECISIONB ) ] ) ; sX += dx ; } destOffset += screenW ; srcYOffset += dy ; } break ; } } } private void filter_new_scanline ( ) { sX = srcXOffset ; fracV = srcYOffset & PREC_MAXVAL ; ifV = PREC_MAXVAL - fracV ; v1 = ( srcYOffset > > PRECISIONB ) * iw ; v2 = low ( ( srcYOffset > > PRECISIONB ) + 1 , ih1 ) * iw ; } private int filter_bilinear ( ) { fracU = sX & PREC_MAXVAL ; ifU = PREC_MAXVAL - fracU ; ul = ( ifU * ifV ) > > PRECISIONB ; ll = ( ifU * fracV ) > > PRECISIONB ; ur = ( fracU * ifV ) > > PRECISIONB ; lr = ( fracU * fracV ) > > PRECISIONB ; u1 = ( sX > > PRECISIONB ) ; u2 = low ( u1 + 1 , iw1 ) ; cUL = srcBuffer [ v1 + u1 ] ; cUR = srcBuffer [ v1 + u2 ] ; cLL = srcBuffer [ v2 + u1 ] ; cLR = srcBuffer [ v2 + u2 ] ; r = ( ( ul * ( ( cUL & RED_MASK ) > > 16 ) + ll * ( ( cLL & RED_MASK ) > > 16 ) + ur * ( ( cUR & RED_MASK ) > > 16 ) + lr * ( ( cLR & RED_MASK ) > > 16 ) ) < < PREC_RED_SHIFT ) & RED_MASK ; g = ( ( ul * ( cUL & GREEN_MASK ) + ll * ( cLL & GREEN_MASK ) + ur * ( cUR & GREEN_MASK ) + lr * ( cLR & GREEN_MASK ) ) > > > PRECISIONB ) & GREEN_MASK ; b = ( ul * ( cUL & BLUE_MASK ) + ll * ( cLL & BLUE_MASK ) + ur * ( cUR & BLUE_MASK ) + lr * ( cLR & BLUE_MASK ) ) > > > PRECISIONB ; a = ( ( ul * ( ( cUL & ALPHA_MASK ) > > > 24 ) + ll * ( ( cLL & ALPHA_MASK ) > > > 24 ) + ur * ( ( cUR & ALPHA_MASK ) > > > 24 ) + lr * ( ( cLR & ALPHA_MASK ) > > > 24 ) ) < < PREC_ALPHA_SHIFT ) & ALPHA_MASK ; return a | r | g | b ; } private static int low ( int a , int b ) { return ( a < b ) ? a : b ; } private static int high ( int a , int b ) { return ( a > b ) ? a : b ; } private static int peg ( int n ) { return ( n < 0 ) ? 0 : ( ( n > 255 ) ? 255 : n ) ; } private static int mix ( int a , int b , int f ) { return a + ( ( ( b - a ) * f ) > > 8 ) ; } private static int blend_blend ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | mix ( a & RED_MASK , b & RED_MASK , f ) & RED_MASK | mix ( a & GREEN_MASK , b & GREEN_MASK , f ) & GREEN_MASK | mix ( a & BLUE_MASK , b & BLUE_MASK , f ) ) ; } private static int blend_add_pin ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | low ( ( ( a & RED_MASK ) + ( ( b & RED_MASK ) > > 8 ) * f ) , RED_MASK ) & RED_MASK | low ( ( ( a & GREEN_MASK ) + ( ( b & GREEN_MASK ) > > 8 ) * f ) , GREEN_MASK ) & GREEN_MASK | low ( ( a & BLUE_MASK ) + ( ( ( b & BLUE_MASK ) * f ) > > 8 ) , BLUE_MASK ) ) ; } private static int blend_sub_pin ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | high ( ( ( a & RED_MASK ) - ( ( b & RED_MASK ) > > 8 ) * f ) , GREEN_MASK ) & RED_MASK | high ( ( ( a & GREEN_MASK ) - ( ( b & GREEN_MASK ) > > 8 ) * f ) , BLUE_MASK ) & GREEN_MASK | high ( ( a & BLUE_MASK ) - ( ( ( b & BLUE_MASK ) * f ) > > 8 ) , 0 ) ) ; } private static int blend_lightest ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | high ( a & RED_MASK , ( ( b & RED_MASK ) > > 8 ) * f ) & RED_MASK | high ( a & GREEN_MASK , ( ( b & GREEN_MASK ) > > 8 ) * f ) & GREEN_MASK | high ( a & BLUE_MASK , ( ( b & BLUE_MASK ) * f ) > > 8 ) ) ; } private static int blend_darkest ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | mix ( a & RED_MASK , low ( a & RED_MASK , ( ( b & RED_MASK ) > > 8 ) * f ) , f ) & RED_MASK | mix ( a & GREEN_MASK , low ( a & GREEN_MASK , ( ( b & GREEN_MASK ) > > 8 ) * f ) , f ) & GREEN_MASK | mix ( a & BLUE_MASK , low ( a & BLUE_MASK , ( ( b & BLUE_MASK ) * f ) > > 8 ) , f ) ) ; } private static int blend_difference ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; int ar = ( a & RED_MASK ) > > 16 ; int ag = ( a & GREEN_MASK ) > > 8 ; int ab = ( a & BLUE_MASK ) ; int br = ( b & RED_MASK ) > > 16 ; int bg = ( b & GREEN_MASK ) > > 8 ; int bb = ( b & BLUE_MASK ) ; int cr = ( ar > br ) ? ( ar - br ) : ( br - ar ) ; int cg = ( ag > bg ) ? ( ag - bg ) : ( bg - ag ) ; int cb = ( ab > bb ) ? ( ab - bb ) : ( bb - ab ) ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | ( peg ( ar + ( ( ( cr - ar ) * f ) > > 8 ) ) < < 16 ) | ( peg ( ag + ( ( ( cg - ag ) * f ) > > 8 ) ) < < 8 ) | ( peg ( ab + ( ( ( cb - ab ) * f ) > > 8 ) ) ) ) ; } private static int blend_exclusion ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; int ar = ( a & RED_MASK ) > > 16 ; int ag = ( a & GREEN_MASK ) > > 8 ; int ab = ( a & BLUE_MASK ) ; int br = ( b & RED_MASK ) > > 16 ; int bg = ( b & GREEN_MASK ) > > 8 ; int bb = ( b & BLUE_MASK ) ; int cr = ar + br - ( ( ar * br ) > > 7 ) ; int cg = ag + bg - ( ( ag * bg ) > > 7 ) ; int cb = ab + bb - ( ( ab * bb ) > > 7 ) ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | ( peg ( ar + ( ( ( cr - ar ) * f ) > > 8 ) ) < < 16 ) | ( peg ( ag + ( ( ( cg - ag ) * f ) > > 8 ) ) < < 8 ) | ( peg ( ab + ( ( ( cb - ab ) * f ) > > 8 ) ) ) ) ; } private static int blend_multiply ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; int ar = ( a & RED_MASK ) > > 16 ; int ag = ( a & GREEN_MASK ) > > 8 ; int ab = ( a & BLUE_MASK ) ; int br = ( b & RED_MASK ) > > 16 ; int bg = ( b & GREEN_MASK ) > > 8 ; int bb = ( b & BLUE_MASK ) ; int cr = ( ar * br ) > > 8 ; int cg = ( ag * bg ) > > 8 ; int cb = ( ab * bb ) > > 8 ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | ( peg ( ar + ( ( ( cr - ar ) * f ) > > 8 ) ) < < 16 ) | ( peg ( ag + ( ( ( cg - ag ) * f ) > > 8 ) ) < < 8 ) | ( peg ( ab + ( ( ( cb - ab ) * f ) > > 8 ) ) ) ) ; } private static int blend_screen ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; int ar = ( a & RED_MASK ) > > 16 ; int ag = ( a & GREEN_MASK ) > > 8 ; int ab = ( a & BLUE_MASK ) ; int br = ( b & RED_MASK ) > > 16 ; int bg = ( b & GREEN_MASK ) > > 8 ; int bb = ( b & BLUE_MASK ) ; int cr = 255 - ( ( ( 255 - ar ) * ( 255 - br ) ) > > 8 ) ; int cg = 255 - ( ( ( 255 - ag ) * ( 255 - bg ) ) > > 8 ) ; int cb = 255 - ( ( ( 255 - ab ) * ( 255 - bb ) ) > > 8 ) ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | ( peg ( ar + ( ( ( cr - ar ) * f ) > > 8 ) ) < < 16 ) | ( peg ( ag + ( ( ( cg - ag ) * f ) > > 8 ) ) < < 8 ) | ( peg ( ab + ( ( ( cb - ab ) * f ) > > 8 ) ) ) ) ; } private static int blend_overlay ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; int ar = ( a & RED_MASK ) > > 16 ; int ag = ( a & GREEN_MASK ) > > 8 ; int ab = ( a & BLUE_MASK ) ; int br = ( b & RED_MASK ) > > 16 ; int bg = ( b & GREEN_MASK ) > > 8 ; int bb = ( b & BLUE_MASK ) ; int cr = ( ar < 128 ) ? ( ( ar * br ) > > 7 ) : ( 255 - ( ( ( 255 - ar ) * ( 255 - br ) ) > > 7 ) ) ; int cg = ( ag < 128 ) ? ( ( ag * bg ) > > 7 ) : ( 255 - ( ( ( 255 - ag ) * ( 255 - bg ) ) > > 7 ) ) ; int cb = ( ab < 128 ) ? ( ( ab * bb ) > > 7 ) : ( 255 - ( ( ( 255 - ab ) * ( 255 - bb ) ) > > 7 ) ) ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | ( peg ( ar + ( ( ( cr - ar ) * f ) > > 8 ) ) < < 16 ) | ( peg ( ag + ( ( ( cg - ag ) * f ) > > 8 ) ) < < 8 ) | ( peg ( ab + ( ( ( cb - ab ) * f ) > > 8 ) ) ) ) ; } private static int blend_hard_light ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; int ar = ( a & RED_MASK ) > > 16 ; int ag = ( a & GREEN_MASK ) > > 8 ; int ab = ( a & BLUE_MASK ) ; int br = ( b & RED_MASK ) > > 16 ; int bg = ( b & GREEN_MASK ) > > 8 ; int bb = ( b & BLUE_MASK ) ; int cr = ( br < 128 ) ? ( ( ar * br ) > > 7 ) : ( 255 - ( ( ( 255 - ar ) * ( 255 - br ) ) > > 7 ) ) ; int cg = ( bg < 128 ) ? ( ( ag * bg ) > > 7 ) : ( 255 - ( ( ( 255 - ag ) * ( 255 - bg ) ) > > 7 ) ) ; int cb = ( bb < 128 ) ? ( ( ab * bb ) > > 7 ) : ( 255 - ( ( ( 255 - ab ) * ( 255 - bb ) ) > > 7 ) ) ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | ( peg ( ar + ( ( ( cr - ar ) * f ) > > 8 ) ) < < 16 ) | ( peg ( ag + ( ( ( cg - ag ) * f ) > > 8 ) ) < < 8 ) | ( peg ( ab + ( ( ( cb - ab ) * f ) > > 8 ) ) ) ) ; } private static int blend_soft_light ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; int ar = ( a & RED_MASK ) > > 16 ; int ag = ( a & GREEN_MASK ) > > 8 ; int ab = ( a & BLUE_MASK ) ; int br = ( b & RED_MASK ) > > 16 ; int bg = ( b & GREEN_MASK ) > > 8 ; int bb = ( b & BLUE_MASK ) ; int cr = ( ( ar * br ) > > 7 ) + ( ( ar * ar ) > > 8 ) - ( ( ar * ar * br ) > > 15 ) ; int cg = ( ( ag * bg ) > > 7 ) + ( ( ag * ag ) > > 8 ) - ( ( ag * ag * bg ) > > 15 ) ; int cb = ( ( ab * bb ) > > 7 ) + ( ( ab * ab ) > > 8 ) - ( ( ab * ab * bb ) > > 15 ) ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | ( peg ( ar + ( ( ( cr - ar ) * f ) > > 8 ) ) < < 16 ) | ( peg ( ag + ( ( ( cg - ag ) * f ) > > 8 ) ) < < 8 ) | ( peg ( ab + ( ( ( cb - ab ) * f ) > > 8 ) ) ) ) ; } private static int blend_dodge ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; int ar = ( a & RED_MASK ) > > 16 ; int ag = ( a & GREEN_MASK ) > > 8 ; int ab = ( a & BLUE_MASK ) ; int br = ( b & RED_MASK ) > > 16 ; int bg = ( b & GREEN_MASK ) > > 8 ; int bb = ( b & BLUE_MASK ) ; int cr = ( br == 255 ) ? 255 : peg ( ( ar < < 8 ) / ( 255 - br ) ) ; int cg = ( bg == 255 ) ? 255 : peg ( ( ag < < 8 ) / ( 255 - bg ) ) ; int cb = ( bb == 255 ) ? 255 : peg ( ( ab < < 8 ) / ( 255 - bb ) ) ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | ( peg ( ar + ( ( ( cr - ar ) * f ) > > 8 ) ) < < 16 ) | ( peg ( ag + ( ( ( cg - ag ) * f ) > > 8 ) ) < < 8 ) | ( peg ( ab + ( ( ( cb - ab ) * f ) > > 8 ) ) ) ) ; } private static int blend_burn ( int a , int b ) { int f = ( b & ALPHA_MASK ) > > > 24 ; int ar = ( a & RED_MASK ) > > 16 ; int ag = ( a & GREEN_MASK ) > > 8 ; int ab = ( a & BLUE_MASK ) ; int br = ( b & RED_MASK ) > > 16 ; int bg = ( b & GREEN_MASK ) > > 8 ; int bb = ( b & BLUE_MASK ) ; int cr = ( br == 0 ) ? 0 : 255 - peg ( ( ( 255 - ar ) < < 8 ) / br ) ; int cg = ( bg == 0 ) ? 0 : 255 - peg ( ( ( 255 - ag ) < < 8 ) / bg ) ; int cb = ( bb == 0 ) ? 0 : 255 - peg ( ( ( 255 - ab ) < < 8 ) / bb ) ; return ( low ( ( ( a & ALPHA_MASK ) > > > 24 ) + f , 0xff ) < < 24 | ( peg ( ar + ( ( ( cr - ar ) * f ) > > 8 ) ) < < 16 ) | ( peg ( ag + ( ( ( cg - ag ) * f ) > > 8 ) ) < < 8 ) | ( peg ( ab + ( ( ( cb - ab ) * f ) > > 8 ) ) ) ) ; } static byte TIFF_HEADER [ ] = { 77 , 77 , 0 , 42 , 0 , 0 , 0 , 8 , 0 , 9 , 0 , - 2 , 0 , 4 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 3 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 3 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 2 , 0 , 3 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 122 , 1 , 6 , 0 , 3 , 0 , 0 , 0 , 1 , 0 , 2 , 0 , 0 , 1 , 17 , 0 , 4 , 0 , 0 , 0 , 1 , 0 , 0 , 3 , 0 , 1 , 21 , 0 , 3 , 0 , 0 , 0 , 1 , 0 , 3 , 0 , 0 , 1 , 22 , 0 , 3 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 23 , 0 , 4 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 8 , 0 , 8 , 0 , 8 } ; static final String TIFF_ERROR = "Error: Processing can only read its own TIFF files." ; static protected PImage loadTIFF ( byte tiff [ ] ) { if ( ( tiff [ 42 ] != tiff [ 102 ] ) || ( tiff [ 43 ] != tiff [ 103 ] ) ) { System . err . println ( TIFF_ERROR ) ; return null ; } int width = ( ( tiff [ 30 ] & 0xff ) < < 8 ) | ( tiff [ 31 ] & 0xff ) ; int height = ( ( tiff [ 42 ] & 0xff ) < < 8 ) | ( tiff [ 43 ] & 0xff ) ; int count = ( ( tiff [ 114 ] & 0xff ) < < 24 ) | ( ( tiff [ 115 ] & 0xff ) < < 16 ) | ( ( tiff [ 116 ] & 0xff ) < < 8 ) | ( tiff [ 117 ] & 0xff ) ; if ( count != width * height * 3 ) { System . err . println ( TIFF_ERROR + " (" + width + ", " + height + ")" ) ; return null ; } for ( int i = 0 ; i < TIFF_HEADER . length ; i ++ ) { if ( ( i == 30 ) || ( i == 31 ) || ( i == 42 ) || ( i == 43 ) || ( i == 102 ) || ( i == 103 ) || ( i == 114 ) || ( i == 115 ) || ( i == 116 ) || ( i == 117 ) ) continue ; if ( tiff [ i ] != TIFF_HEADER [ i ] ) { System . err . println ( TIFF_ERROR + " (" + i + ")" ) ; return null ; } } PImage outgoing = new PImage ( width , height , RGB ) ; int index = 768 ; count /= 3 ; for ( int i = 0 ; i < count ; i ++ ) { outgoing . pixels [ i ] = 0xFF000000 | ( tiff [ index ++ ] & 0xff ) < < 16 | ( tiff [ index ++ ] & 0xff ) < < 8 | ( tiff [ index ++ ] & 0xff ) ; } return outgoing ; } protected boolean saveTIFF ( OutputStream output ) { try { byte tiff [ ] = new byte [ 768 ] ; System . arraycopy ( TIFF_HEADER , 0 , tiff , 0 , TIFF_HEADER . length ) ; tiff [ 30 ] = ( byte ) ( ( pixelWidth > > 8 ) & 0xff ) ; tiff [ 31 ] = ( byte ) ( ( pixelWidth ) & 0xff ) ; tiff [ 42 ] = tiff [ 102 ] = ( byte ) ( ( pixelHeight > > 8 ) & 0xff ) ; tiff [ 43 ] = tiff [ 103 ] = ( byte ) ( ( pixelHeight ) & 0xff ) ; int count = pixelWidth * pixelHeight * 3 ; tiff [ 114 ] = ( byte ) ( ( count > > 24 ) & 0xff ) ; tiff [ 115 ] = ( byte ) ( ( count > > 16 ) & 0xff ) ; tiff [ 116 ] = ( byte ) ( ( count > > 8 ) & 0xff ) ; tiff [ 117 ] = ( byte ) ( ( count ) & 0xff ) ; output . write ( tiff ) ; for ( int i = 0 ; i < pixels . length ; i ++ ) { output . write ( ( pixels [ i ] > > 16 ) & 0xff ) ; output . write ( ( pixels [ i ] > > 8 ) & 0xff ) ; output . write ( pixels [ i ] & 0xff ) ; } output . flush ( ) ; return true ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return false ; } protected boolean saveTGA ( OutputStream output ) { byte header [ ] = new byte [ 18 ] ; if ( format == ALPHA ) { header [ 2 ] = 0x0B ; header [ 16 ] = 0x08 ; header [ 17 ] = 0x28 ; } else if ( format == RGB ) { header [ 2 ] = 0x0A ; header [ 16 ] = 24 ; header [ 17 ] = 0x20 ; } else if ( format == ARGB ) { header [ 2 ] = 0x0A ; header [ 16 ] = 32 ; header [ 17 ] = 0x28 ; } else { throw new RuntimeException ( "Image format not recognized inside save()" ) ; } header [ 12 ] = ( byte ) ( pixelWidth & 0xff ) ; header [ 13 ] = ( byte ) ( pixelWidth > > 8 ) ; header [ 14 ] = ( byte ) ( pixelHeight & 0xff ) ; header [ 15 ] = ( byte ) ( pixelHeight > > 8 ) ; try { output . write ( header ) ; int maxLen = pixelHeight * pixelWidth ; int index = 0 ; int col ; int [ ] currChunk = new int [ 128 ] ; if ( format == ALPHA ) { while ( index < maxLen ) { boolean isRLE = false ; int rle = 1 ; currChunk [ 0 ] = col = pixels [ index ] & 0xff ; while ( index + rle < maxLen ) { if ( col != ( pixels [ index + rle ] & 0xff ) || rle == 128 ) { isRLE = ( rle > 1 ) ; break ; } rle ++ ; } if ( isRLE ) { output . write ( 0x80 | ( rle - 1 ) ) ; output . write ( col ) ; } else { rle = 1 ; while ( index + rle < maxLen ) { int cscan = pixels [ index + rle ] & 0xff ; if ( ( col != cscan && rle < 128 ) || rle < 3 ) { currChunk [ rle ] = col = cscan ; } else { if ( col == cscan ) rle -= 2 ; break ; } rle ++ ; } output . write ( rle - 1 ) ; for ( int i = 0 ; i < rle ; i ++ ) output . write ( currChunk [ i ] ) ; } index += rle ; } } else { while ( index < maxLen ) { boolean isRLE = false ; currChunk [ 0 ] = col = pixels [ index ] ; int rle = 1 ; while ( index + rle < maxLen ) { if ( col != pixels [ index + rle ] || rle == 128 ) { isRLE = ( rle > 1 ) ; break ; } rle ++ ; } if ( isRLE ) { output . write ( 128 | ( rle - 1 ) ) ; output . write ( col & 0xff ) ; output . write ( col > > 8 & 0xff ) ; output . write ( col > > 16 & 0xff ) ; if ( format == ARGB ) output . write ( col > > > 24 & 0xff ) ; } else { rle = 1 ; while ( index + rle < maxLen ) { if ( ( col != pixels [ index + rle ] && rle < 128 ) || rle < 3 ) { currChunk [ rle ] = col = pixels [ index + rle ] ; } else { if ( col == pixels [ index + rle ] ) rle -= 2 ; break ; } rle ++ ; } output . write ( rle - 1 ) ; if ( format == ARGB ) { for ( int i = 0 ; i < rle ; i ++ ) { col = currChunk [ i ] ; output . write ( col & 0xff ) ; output . write ( col > > 8 & 0xff ) ; output . write ( col > > 16 & 0xff ) ; output . write ( col > > > 24 & 0xff ) ; } } else { for ( int i = 0 ; i < rle ; i ++ ) { col = currChunk [ i ] ; output . write ( col & 0xff ) ; output . write ( col > > 8 & 0xff ) ; output . write ( col > > 16 & 0xff ) ; } } } index += rle ; } } output . flush ( ) ; return true ; } catch ( IOException e ) { e . printStackTrace ( ) ; return false ; } } protected boolean saveImageIO ( String path ) throws IOException { try { int outputFormat = ( format == ARGB ) ? BufferedImage . TYPE_INT_ARGB : BufferedImage . TYPE_INT_RGB ; String extension = path . substring ( path . lastIndexOf ( '.' ) + 1 ) . toLowerCase ( ) ; if ( extension . equals ( "bmp" ) || extension . equals ( "jpg" ) || extension . equals ( "jpeg" ) ) { outputFormat = BufferedImage . TYPE_INT_RGB ; } BufferedImage bimage = new BufferedImage ( pixelWidth , pixelHeight , outputFormat ) ; bimage . setRGB ( 0 , 0 , pixelWidth , pixelHeight , pixels , 0 , pixelWidth ) ; File file = new File ( path ) ; ImageWriter writer = null ; ImageWriteParam param = null ; IIOMetadata metadata = null ; if ( extension . equals ( "jpg" ) || extension . equals ( "jpeg" ) ) { if ( ( writer = imageioWriter ( "jpeg" ) ) != null ) { param = writer . getDefaultWriteParam ( ) ; param . setCompressionMode ( ImageWriteParam . MODE_EXPLICIT ) ; param . setCompressionQuality ( 0.9f ) ; } } if ( extension . equals ( "png" ) ) { if ( ( writer = imageioWriter ( "png" ) ) != null ) { param = writer . getDefaultWriteParam ( ) ; if ( false ) { metadata = imageioDPI ( writer , param , 100 ) ; } } } if ( writer != null ) { BufferedOutputStream output = new BufferedOutputStream ( PApplet . createOutput ( file ) ) ; writer . setOutput ( ImageIO . createImageOutputStream ( output ) ) ; writer . write ( metadata , new IIOImage ( bimage , null , metadata ) , param ) ; writer . dispose ( ) ; output . flush ( ) ; output . close ( ) ; return true ; } return javax . imageio . ImageIO . write ( bimage , extension , file ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new IOException ( "image save failed." ) ; } } private ImageWriter imageioWriter ( String extension ) { Iterator < ImageWriter > iter = ImageIO . getImageWritersByFormatName ( extension ) ; if ( iter . hasNext ( ) ) { return iter . next ( ) ; } return null ; } private IIOMetadata imageioDPI ( ImageWriter writer , ImageWriteParam param , double dpi ) { ImageTypeSpecifier typeSpecifier = ImageTypeSpecifier . createFromBufferedImageType ( BufferedImage . TYPE_INT_RGB ) ; IIOMetadata metadata = writer . getDefaultImageMetadata ( typeSpecifier , param ) ; if ( ! metadata . isReadOnly ( ) && metadata . isStandardMetadataFormatSupported ( ) ) { double dotsPerMilli = dpi / 25.4 ; IIOMetadataNode horiz = new IIOMetadataNode ( "HorizontalPixelSize" ) ; horiz . setAttribute ( "value" , Double . toString ( dotsPerMilli ) ) ; IIOMetadataNode vert = new IIOMetadataNode ( "VerticalPixelSize" ) ; vert . setAttribute ( "value" , Double . toString ( dotsPerMilli ) ) ; IIOMetadataNode dim = new IIOMetadataNode ( "Dimension" ) ; dim . appendChild ( horiz ) ; dim . appendChild ( vert ) ; IIOMetadataNode root = new IIOMetadataNode ( "javax_imageio_1.0" ) ; root . appendChild ( dim ) ; try { metadata . mergeTree ( "javax_imageio_1.0" , root ) ; return metadata ; } catch ( IIOInvalidTreeException e ) { System . err . println ( "Could not set the DPI of the output image" ) ; e . printStackTrace ( ) ; } } return null ; } protected String [ ] saveImageFormats ; public boolean save ( String filename ) { boolean success = false ; if ( parent != null ) { filename = parent . savePath ( filename ) ; } else { File file = new File ( filename ) ; if ( file . isAbsolute ( ) ) { PApplet . createPath ( file ) ; } else { String msg = "PImage.save() requires an absolute path. " + "Use createImage(), or pass savePath() to save()." ; PGraphics . showException ( msg ) ; } } loadPixels ( ) ; try { OutputStream os = null ; if ( saveImageFormats == null ) { saveImageFormats = javax . imageio . ImageIO . getWriterFormatNames ( ) ; } if ( saveImageFormats != null ) { for ( int i = 0 ; i < saveImageFormats . length ; i ++ ) { if ( filename . endsWith ( "." + saveImageFormats [ i ] ) ) { if ( ! saveImageIO ( filename ) ) { System . err . println ( "Error while saving image." ) ; return false ; } return true ; } } } if ( filename . toLowerCase ( ) . endsWith ( ".tga" ) ) { os = new BufferedOutputStream ( new FileOutputStream ( filename ) , 32768 ) ; success = saveTGA ( os ) ; } else { if ( ! filename . toLowerCase ( ) . endsWith ( ".tif" ) && ! filename . toLowerCase ( ) . endsWith ( ".tiff" ) ) { filename += ".tif" ; } os = new BufferedOutputStream ( new FileOutputStream ( filename ) , 32768 ) ; success = saveTIFF ( os ) ; } os . flush ( ) ; os . close ( ) ; } catch ( IOException e ) { System . err . println ( "Error while saving image." ) ; e . printStackTrace ( ) ; success = false ; } return success ; } }
package processing . mode . java . runner ; import java . io . * ; public class MessageSiphon implements Runnable { BufferedReader streamReader ; Thread thread ; MessageConsumer consumer ; public MessageSiphon ( InputStream stream , MessageConsumer consumer ) { this . streamReader = new BufferedReader ( new InputStreamReader ( stream ) ) ; this . consumer = consumer ; thread = new Thread ( this ) ; thread . setPriority ( Thread . MAX_PRIORITY - 1 ) ; } public void run ( ) { try { String currentLine ; while ( ( currentLine = streamReader . readLine ( ) ) != null ) { consumer . message ( currentLine + "\n" ) ; } thread = null ; } catch ( NullPointerException npe ) { thread = null ; } catch ( Exception e ) { String mess = e . getMessage ( ) ; if ( ( mess != null ) && ( mess . indexOf ( "Bad file descriptor" ) != - 1 ) ) { } else { e . printStackTrace ( ) ; } thread = null ; } } public Thread getThread ( ) { return thread ; } }
package processing . mode . java . runner ; import java . io . * ; class MessageStream extends OutputStream { MessageConsumer messageConsumer ; public MessageStream ( MessageConsumer messageConsumer ) { this . messageConsumer = messageConsumer ; } public void close ( ) { } public void flush ( ) { } public void write ( byte b [ ] ) { System . out . println ( "leech1: " + new String ( b ) ) ; } public void write ( byte b [ ] , int offset , int length ) { this . messageConsumer . message ( new String ( b , offset , length ) ) ; } public void write ( int b ) { System . out . println ( "leech3: '" + ( ( char ) b ) + "'" ) ; } }
package processing . mode . java . runner ; public interface MessageConsumer { public void message ( String s ) ; }
package processing . mode . java . runner ; import processing . app . * ; import processing . app . exec . StreamRedirectThread ; import processing . core . * ; import processing . mode . java . JavaBuild ; import java . awt . GraphicsDevice ; import java . awt . GraphicsEnvironment ; import java . awt . Point ; import java . io . * ; import java . util . * ; import com . sun . jdi . * ; import com . sun . jdi . connect . * ; import com . sun . jdi . connect . Connector . Argument ; import com . sun . jdi . event . * ; import com . sun . jdi . request . * ; public class Runner implements MessageConsumer { protected RunnerListener listener ; protected VirtualMachine vm ; protected Thread errThread = null ; protected Thread outThread = null ; protected SketchException exception ; protected Editor editor ; protected JavaBuild build ; protected Process process ; protected PrintStream sketchErr ; protected PrintStream sketchOut ; public Runner ( JavaBuild build , RunnerListener listener ) throws SketchException { this . listener = listener ; this . build = build ; if ( listener instanceof Editor ) { this . editor = ( Editor ) listener ; sketchErr = editor . getConsole ( ) . getErr ( ) ; sketchOut = editor . getConsole ( ) . getOut ( ) ; } else { sketchErr = System . err ; sketchOut = System . out ; } int bits = Base . getNativeBits ( ) ; for ( Library library : build . getImportedLibraries ( ) ) { if ( ! library . supportsArch ( PApplet . platform , bits ) ) { sketchErr . println ( library . getName ( ) + " does not run in " + bits + "-bit mode." ) ; int opposite = ( bits == 32 ) ? 64 : 32 ; if ( Base . isMacOS ( ) ) { throw new SketchException ( "To use " + library . getName ( ) + ", " + "switch to " + opposite + "-bit mode in Preferences." ) ; } else { throw new SketchException ( library . getName ( ) + " is only compatible " + "with the " + opposite + "-bit download of Processing." ) ; } } } } public void launch ( boolean presenting ) { if ( launchVirtualMachine ( presenting ) ) { generateTrace ( ) ; } } public VirtualMachine launchDebug ( ) { if ( launchVirtualMachine ( false ) ) { redirectStreams ( vm ) ; } return vm ; } protected void redirectStreams ( VirtualMachine vm ) { MessageSiphon ms = new MessageSiphon ( process . getErrorStream ( ) , this ) ; errThread = ms . getThread ( ) ; outThread = new StreamRedirectThread ( "VM output reader" , process . getInputStream ( ) , System . out ) ; errThread . start ( ) ; outThread . start ( ) ; } public VirtualMachine vm ( ) { return vm ; } public boolean launchVirtualMachine ( boolean presenting ) { String [ ] vmParams = getMachineParams ( ) ; String [ ] sketchParams = getSketchParams ( presenting ) ; int port = 8000 + ( int ) ( Math . random ( ) * 1000 ) ; String portStr = String . valueOf ( port ) ; String jdwpArg = "-agentlib:jdwp=transport=dt_socket,address=" + portStr + ",server=y,suspend=y" ; String [ ] commandArgs = new String [ ] { Base . getJavaPath ( ) , jdwpArg } ; commandArgs = PApplet . concat ( commandArgs , vmParams ) ; commandArgs = PApplet . concat ( commandArgs , sketchParams ) ; launchJava ( commandArgs ) ; AttachingConnector connector = ( AttachingConnector ) findConnector ( "com.sun.jdi.SocketAttach" ) ; Map < String , Argument > arguments = connector . defaultArguments ( ) ; Connector . Argument portArg = arguments . get ( "port" ) ; portArg . setValue ( portStr ) ; try { while ( true ) { try { vm = connector . attach ( arguments ) ; if ( vm != null ) { return true ; } } catch ( IOException e ) { try { Thread . sleep ( 100 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( sketchErr ) ; } } } } catch ( IllegalConnectorArgumentsException exc ) { throw new Error ( "Internal error: " + exc ) ; } } protected String [ ] getMachineParams ( ) { ArrayList < String > params = new ArrayList < String > ( ) ; String options = Preferences . get ( "run.options" ) ; if ( options . length ( ) > 0 ) { String pieces [ ] = PApplet . split ( options , ' ' ) ; for ( int i = 0 ; i < pieces . length ; i ++ ) { String p = pieces [ i ] . trim ( ) ; if ( p . length ( ) > 0 ) { params . add ( p ) ; } } } if ( Preferences . getBoolean ( "run.options.memory" ) ) { params . add ( "-Xms" + Preferences . get ( "run.options.memory.initial" ) + "m" ) ; params . add ( "-Xmx" + Preferences . get ( "run.options.memory.maximum" ) + "m" ) ; } if ( Base . isMacOS ( ) ) { params . add ( "-Xdock:name=" + build . getSketchClassName ( ) ) ; } params . add ( "-Djava.library.path=" + build . getJavaLibraryPath ( ) + File . pathSeparator + System . getProperty ( "java.library.path" ) ) ; params . add ( "-cp" ) ; params . add ( build . getClassPath ( ) ) ; params . add ( "-ea" ) ; String outgoing [ ] = new String [ params . size ( ) ] ; params . toArray ( outgoing ) ; return outgoing ; } protected String [ ] getSketchParams ( boolean presenting ) { ArrayList < String > params = new ArrayList < String > ( ) ; if ( build . getFoundMain ( ) ) { params . add ( build . getSketchClassName ( ) ) ; } else { params . add ( "processing.core.PApplet" ) ; int runDisplay = Preferences . getInteger ( "run.display" ) ; if ( editor != null ) { GraphicsDevice editorDevice = editor . getGraphicsConfiguration ( ) . getDevice ( ) ; GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice [ ] devices = ge . getScreenDevices ( ) ; GraphicsDevice runDevice = editorDevice ; if ( runDisplay > 0 && runDisplay <= devices . length ) { runDevice = devices [ runDisplay - 1 ] ; } else { if ( runDisplay > 0 ) { System . err . println ( "Display " + runDisplay + " not available." ) ; } runDevice = editorDevice ; for ( int i = 0 ; i < devices . length ; i ++ ) { if ( devices [ i ] == runDevice ) { runDisplay = i + 1 ; System . err . println ( "Setting 'Run Sketches on Display' preference to display " + runDisplay ) ; Preferences . setInteger ( "run.display" , runDisplay ) ; break ; } } } Point windowLocation = editor . getSketchLocation ( ) ; if ( windowLocation == null ) { if ( editorDevice == runDevice ) { Point editorLocation = editor . getLocation ( ) ; params . add ( PApplet . ARGS_EDITOR_LOCATION + "=" + editorLocation . x + "," + editorLocation . y ) ; } else { } } else { params . add ( PApplet . ARGS_LOCATION + "=" + windowLocation . x + "," + windowLocation . y ) ; } params . add ( PApplet . ARGS_EXTERNAL ) ; } params . add ( PApplet . ARGS_DISPLAY + "=" + runDisplay ) ; if ( presenting ) { params . add ( PApplet . ARGS_PRESENT ) ; params . add ( PApplet . ARGS_STOP_COLOR + "=" + Preferences . get ( "run.present.stop.color" ) ) ; params . add ( PApplet . ARGS_WINDOW_COLOR + "=" + Preferences . get ( "run.present.bgcolor" ) ) ; } params . add ( PApplet . ARGS_SKETCH_FOLDER + "=" + build . getSketchPath ( ) ) ; params . add ( build . getSketchClassName ( ) ) ; } return params . toArray ( new String [ 0 ] ) ; } protected void launchJava ( final String [ ] args ) { new Thread ( new Runnable ( ) { public void run ( ) { process = PApplet . exec ( args ) ; try { int result = process . waitFor ( ) ; if ( result != 0 ) { String [ ] errorStrings = PApplet . loadStrings ( process . getErrorStream ( ) ) ; String [ ] inputStrings = PApplet . loadStrings ( process . getInputStream ( ) ) ; PApplet . printArray ( inputStrings ) ; if ( errorStrings != null && errorStrings . length > 1 ) { if ( errorStrings [ 0 ] . indexOf ( "Invalid maximum heap size" ) != - 1 ) { Base . showWarning ( "Way Too High" , "Please lower the value for \u201Cmaximum available memory\u201D in the\n" + "Preferences window. For more information, read Help \u2192 Troubleshooting." , null ) ; } else { for ( String err : errorStrings ) { sketchErr . println ( err ) ; } sketchErr . println ( "Using startup command: " + PApplet . join ( args , " " ) ) ; } } else { sketchErr . println ( "Could not run the sketch (Target VM failed to initialize)." ) ; if ( Preferences . getBoolean ( "run.options.memory" ) ) { sketchErr . println ( "Make sure that you haven't set the maximum available memory too high." ) ; } sketchErr . println ( "For more information, read revisions.txt and Help \u2192 Troubleshooting." ) ; } listener . statusError ( "Could not run the sketch." ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } ) . start ( ) ; } protected void generateTrace ( ) { vm . allThreads ( ) ; EventRequestManager mgr = vm . eventRequestManager ( ) ; ExceptionRequest excReq = mgr . createExceptionRequest ( null , false , true ) ; excReq . setSuspendPolicy ( EventRequest . SUSPEND_ALL ) ; excReq . enable ( ) ; Thread eventThread = new Thread ( ) { public void run ( ) { try { boolean connected = true ; while ( connected ) { EventQueue eventQueue = vm . eventQueue ( ) ; EventSet eventSet = eventQueue . remove ( ) ; for ( Event event : eventSet ) { if ( event instanceof VMStartEvent ) { vm . resume ( ) ; } else if ( event instanceof ExceptionEvent ) { exceptionEvent ( ( ExceptionEvent ) event ) ; } else if ( event instanceof VMDisconnectEvent ) { connected = false ; } } } } catch ( Exception e ) { System . err . println ( "crashed in event thread due to " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } } ; eventThread . start ( ) ; errThread = new MessageSiphon ( process . getErrorStream ( ) , this ) . getThread ( ) ; outThread = new StreamRedirectThread ( "JVM stdout Reader" , process . getInputStream ( ) , sketchOut ) ; errThread . start ( ) ; outThread . start ( ) ; try { if ( eventThread != null ) eventThread . join ( ) ; errThread . join ( ) ; outThread . join ( ) ; if ( editor != null ) { editor . deactivateRun ( ) ; } } catch ( InterruptedException exc ) { } } protected Connector findConnector ( String connectorName ) { List < Connector > connectors = org . eclipse . jdi . Bootstrap . virtualMachineManager ( ) . allConnectors ( ) ; for ( Object c : connectors ) { Connector connector = ( Connector ) c ; if ( connector . name ( ) . equals ( connectorName ) ) { return connector ; } } Base . showError ( "Compiler Error" , "findConnector() failed to find " + connectorName + " inside Runner" , null ) ; return null ; } public void exceptionEvent ( ExceptionEvent event ) { ObjectReference or = event . exception ( ) ; ReferenceType rt = or . referenceType ( ) ; String exceptionName = rt . name ( ) ; Field messageField = rt . fieldByName ( "detailMessage" ) ; Value messageValue = or . getValue ( messageField ) ; int last = exceptionName . lastIndexOf ( '.' ) ; String message = exceptionName . substring ( last + 1 ) ; if ( messageValue != null ) { String messageStr = messageValue . toString ( ) ; if ( messageStr . startsWith ( "\"" ) ) { messageStr = messageStr . substring ( 1 , messageStr . length ( ) - 1 ) ; } message += ": " + messageStr ; } reportException ( message , or , event . thread ( ) ) ; handleCommonErrors ( exceptionName , message , listener , sketchErr ) ; if ( editor != null ) { editor . deactivateRun ( ) ; } } public static boolean handleCommonErrors ( final String exceptionClass , final String message , final RunnerListener listener , final PrintStream err ) { if ( exceptionClass . equals ( "java.lang.OutOfMemoryError" ) ) { if ( message . contains ( "exceeds VM budget" ) ) { listener . statusError ( "OutOfMemoryError: This code attempts to use more memory than available." ) ; err . println ( "An OutOfMemoryError means that your code is either using up too much memory" ) ; err . println ( "because of a bug (e.g. creating an array that's too large, or unintentionally" ) ; err . println ( "loading thousands of images), or simply that it's trying to use more memory" ) ; err . println ( "than what is supported by the current device." ) ; } else { listener . statusError ( "OutOfMemoryError: You may need to increase the memory setting in Preferences." ) ; err . println ( "An OutOfMemoryError means that your code is either using up too much memory" ) ; err . println ( "because of a bug (e.g. creating an array that's too large, or unintentionally" ) ; err . println ( "loading thousands of images), or that your sketch may need more memory to run." ) ; err . println ( "If your sketch uses a lot of memory (for instance if it loads a lot of data files)" ) ; err . println ( "you can increase the memory available to your sketch using the Preferences window." ) ; } } else if ( exceptionClass . equals ( "java.lang.UnsatisfiedLinkError" ) ) { listener . statusError ( "A library used by this sketch is not installed properly." ) ; err . println ( "A library relies on native code that's not available." ) ; err . println ( "Or only works properly when the sketch is run as a " + ( ( Base . getNativeBits ( ) == 32 ) ? "64-bit " : "32-bit " ) + " application." ) ; } else if ( exceptionClass . equals ( "java.lang.StackOverflowError" ) ) { listener . statusError ( "StackOverflowError: This sketch is attempting too much recursion." ) ; err . println ( "A StackOverflowError means that you have a bug that's causing a function" ) ; err . println ( "to be called recursively (it's calling itself and going in circles)," ) ; err . println ( "or you're intentionally calling a recursive function too much," ) ; err . println ( "and your code should be rewritten in a more efficient manner." ) ; } else if ( exceptionClass . equals ( "java.lang.UnsupportedClassVersionError" ) ) { listener . statusError ( "UnsupportedClassVersionError: A library is using code compiled with an unsupported version of Java." ) ; err . println ( "This version of Processing only supports libraries and JAR files compiled for Java 1.6 or earlier." ) ; err . println ( "A library used by this sketch was compiled for Java 1.7 or later, " ) ; err . println ( "and needs to be recompiled to be compatible with Java 1.6." ) ; } else if ( exceptionClass . equals ( "java.lang.NoSuchMethodError" ) || exceptionClass . equals ( "java.lang.NoSuchFieldError" ) ) { listener . statusError ( exceptionClass . substring ( 10 ) + ": " + "You may be using a library that's incompatible " + "with this version of Processing." ) ; } else { return false ; } return true ; } protected void reportException ( String message , ObjectReference or , ThreadReference thread ) { listener . statusError ( findException ( message , or , thread ) ) ; } protected SketchException findException ( String message , ObjectReference or , ThreadReference thread ) { try { List < StackFrame > frames = thread . frames ( ) ; for ( StackFrame frame : frames ) { try { Location location = frame . location ( ) ; String filename = null ; filename = location . sourceName ( ) ; int lineNumber = location . lineNumber ( ) - 1 ; SketchException rex = build . placeException ( message , filename , lineNumber ) ; if ( rex != null ) { return rex ; } } catch ( AbsentInformationException e ) { exception = new SketchException ( message ) ; exception . hideStackTrace ( ) ; listener . statusError ( exception ) ; } } } catch ( IncompatibleThreadStateException e ) { e . printStackTrace ( sketchErr ) ; } try { Method method = ( ( ClassType ) or . referenceType ( ) ) . concreteMethodByName ( "getStackTrace" , "()[Ljava/lang/StackTraceElement;" ) ; ArrayReference result = ( ArrayReference ) or . invokeMethod ( thread , method , new ArrayList < Value > ( ) , ObjectReference . INVOKE_SINGLE_THREADED ) ; for ( Value val : result . getValues ( ) ) { ObjectReference ref = ( ObjectReference ) val ; method = ( ( ClassType ) ref . referenceType ( ) ) . concreteMethodByName ( "getFileName" , "()Ljava/lang/String;" ) ; StringReference strref = ( StringReference ) ref . invokeMethod ( thread , method , new ArrayList < Value > ( ) , ObjectReference . INVOKE_SINGLE_THREADED ) ; String filename = strref == null ? "Unknown Source" : strref . value ( ) ; method = ( ( ClassType ) ref . referenceType ( ) ) . concreteMethodByName ( "getLineNumber" , "()I" ) ; IntegerValue intval = ( IntegerValue ) ref . invokeMethod ( thread , method , new ArrayList < Value > ( ) , ObjectReference . INVOKE_SINGLE_THREADED ) ; int lineNumber = intval . intValue ( ) - 1 ; SketchException rex = build . placeException ( message , filename , lineNumber ) ; if ( rex != null ) { return rex ; } } method = ( ( ClassType ) or . referenceType ( ) ) . concreteMethodByName ( "printStackTrace" , "()V" ) ; or . invokeMethod ( thread , method , new ArrayList < Value > ( ) , ObjectReference . INVOKE_SINGLE_THREADED ) ; } catch ( Exception e ) { e . printStackTrace ( sketchErr ) ; } SketchException rex = new SketchException ( message ) ; rex . hideStackTrace ( ) ; return rex ; } public void close ( ) { if ( vm != null ) { try { vm . exit ( 0 ) ; } catch ( com . sun . jdi . VMDisconnectedException vmde ) { } vm = null ; } } synchronized public void message ( String s ) { if ( s . indexOf ( PApplet . EXTERNAL_STOP ) == 0 ) { if ( editor != null ) { editor . internalCloseRunner ( ) ; } return ; } if ( s . indexOf ( PApplet . EXTERNAL_MOVE ) == 0 ) { String nums = s . substring ( s . indexOf ( ' ' ) + 1 ) . trim ( ) ; int space = nums . indexOf ( ' ' ) ; int left = Integer . parseInt ( nums . substring ( 0 , space ) ) ; int top = Integer . parseInt ( nums . substring ( space + 1 ) ) ; editor . setSketchLocation ( new Point ( left , top ) ) ; return ; } sketchErr . print ( s ) ; sketchErr . flush ( ) ; } }
package processing . mode . java . tweak ; import java . net . * ; import java . nio . ByteBuffer ; public class TweakClient { private DatagramSocket socket ; private InetAddress address ; private boolean initialized ; private int sketchPort ; static final int VAR_INT = 0 ; static final int VAR_FLOAT = 1 ; static final int SHUTDOWN = 0xffffffff ; public TweakClient ( int sketchPort ) { this . sketchPort = sketchPort ; try { socket = new DatagramSocket ( ) ; address = InetAddress . getByName ( "127.0.0.1" ) ; initialized = true ; } catch ( SocketException e ) { initialized = false ; } catch ( UnknownHostException e ) { socket . close ( ) ; initialized = false ; } catch ( SecurityException e ) { socket . close ( ) ; initialized = false ; } } public void shutdown ( ) { if ( initialized ) { sendShutdown ( ) ; initialized = false ; } } public boolean sendInt ( int index , int val ) { if ( initialized ) { try { byte [ ] buf = new byte [ 12 ] ; ByteBuffer bb = ByteBuffer . wrap ( buf ) ; bb . putInt ( 0 , VAR_INT ) ; bb . putInt ( 4 , index ) ; bb . putInt ( 8 , val ) ; DatagramPacket packet = new DatagramPacket ( buf , buf . length , address , sketchPort ) ; socket . send ( packet ) ; return true ; } catch ( Exception e ) { } } return false ; } public boolean sendFloat ( int index , float val ) { if ( initialized ) { try { byte [ ] buf = new byte [ 12 ] ; ByteBuffer bb = ByteBuffer . wrap ( buf ) ; bb . putInt ( 0 , VAR_FLOAT ) ; bb . putInt ( 4 , index ) ; bb . putFloat ( 8 , val ) ; socket . send ( new DatagramPacket ( buf , buf . length , address , sketchPort ) ) ; return true ; } catch ( Exception e ) { } } return false ; } public boolean sendShutdown ( ) { if ( initialized ) { try { byte [ ] buf = new byte [ 12 ] ; ByteBuffer bb = ByteBuffer . wrap ( buf ) ; bb . putInt ( 0 , SHUTDOWN ) ; socket . send ( new DatagramPacket ( buf , buf . length , address , sketchPort ) ) ; return true ; } catch ( Exception e ) { } } return false ; } static public String getServerCode ( int listenPort , boolean hasInts , boolean hasFloats ) { String serverCode = "" + "class TweakModeServer extends Thread\n" + "{\n" + " protected DatagramSocket socket = null;\n" + " protected boolean running = true;\n" + " final int INT_VAR = 0;\n" + " final int FLOAT_VAR = 1;\n" + " final int SHUTDOWN = 0xffffffff;\n" + " public TweakModeServer() {\n" + " this(\"TweakModeServer\");\n" + " }\n" + " public TweakModeServer(String name) {\n" + " super(name);\n" + " }\n" + " public void setup()\n" + " {\n" + " try {\n" + " socket = new DatagramSocket(" + listenPort + ");\n" + " socket.setSoTimeout(250);\n" + " } catch (IOException e) {\n" + " println(\"error: could not create TweakMode server socket\");\n" + " }\n" + " }\n" + " public void run()\n" + " {\n" + " byte[] buf = new byte[256];\n" + " while(running)\n" + " {\n" + " try {\n" + " DatagramPacket packet = new DatagramPacket(buf, buf.length);\n" + " socket.receive(packet);\n" + " ByteBuffer bb = ByteBuffer.wrap(buf);\n" + " int type = bb.getInt(0);\n" + " int index = bb.getInt(4);\n" ; if ( hasInts ) { serverCode += " if (type == INT_VAR) {\n" + " int val = bb.getInt(8);\n" + " tweakmode_int[index] = val;\n" + " }\n" + " else " ; } if ( hasFloats ) { serverCode += " if (type == FLOAT_VAR) {\n" + " float val = bb.getFloat(8);\n" + " tweakmode_float[index] = val;\n" + " }\n" + " else" ; } serverCode += " if (type == SHUTDOWN) {\n" + " running = false;\n" + " }\n" + " } catch (SocketTimeoutException e) {\n" + " // nothing to do here just try receiving again\n" + " } catch (Exception e) {\n" + " }\n" + " }\n" + " socket.close();\n" + " }\n" + "}\n\n\n" ; return serverCode ; } }
package processing . mode . java . tweak ; import java . awt . Color ; public class ColorScheme { private static ColorScheme instance = null ; public Color redStrokeColor ; public Color progressFillColor ; public Color progressEmptyColor ; public Color markerColor ; public Color whitePaneColor ; private ColorScheme ( ) { redStrokeColor = new Color ( 160 , 20 , 20 ) ; progressEmptyColor = new Color ( 180 , 180 , 180 , 200 ) ; progressFillColor = new Color ( 0 , 0 , 0 , 200 ) ; markerColor = new Color ( 228 , 200 , 91 , 127 ) ; whitePaneColor = new Color ( 255 , 255 , 255 , 120 ) ; } public static ColorScheme getInstance ( ) { if ( instance == null ) { instance = new ColorScheme ( ) ; } return instance ; } }
package processing . mode . java . tweak ; public class Settings { public static boolean alwaysShowColorBoxes = true ; }
package processing . mode . java . tweak ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class SketchParser { public List < List < ColorControlBox > > colorBoxes ; public List < List < Handle > > allHandles ; int intVarCount ; int floatVarCount ; final String varPrefix = "tweakmode" ; String [ ] codeTabs ; boolean requiresComment ; ArrayList < ColorMode > colorModes ; List < List < Range > > scientificNotations ; Range setupFunction ; List < List < Range > > commentBlocks ; List < int [ ] > curlyScopes ; public SketchParser ( String [ ] codeTabs , boolean requiresComment ) { this . codeTabs = codeTabs ; this . requiresComment = requiresComment ; intVarCount = 0 ; floatVarCount = 0 ; commentBlocks = new ArrayList < > ( ) ; for ( String code : codeTabs ) { commentBlocks . add ( getCommentBlocks ( code ) ) ; } setupFunction = new Range ( getSetupStart ( codeTabs [ 0 ] ) , getSetupEnd ( codeTabs [ 0 ] ) ) ; curlyScopes = new ArrayList < > ( ) ; for ( String code : codeTabs ) { curlyScopes . add ( getCurlyScopes ( code ) ) ; } scientificNotations = getAllScientificNotations ( ) ; addAllNumbers ( ) ; colorModes = findAllColorModes ( ) ; createColorBoxes ( ) ; createColorBoxesForLights ( ) ; handleMultipleColorModes ( ) ; } public void addAllNumbers ( ) { allHandles = new ArrayList < > ( ) ; addAllDecimalNumbers ( ) ; addAllHexNumbers ( ) ; addAllWebColorNumbers ( ) ; for ( List < Handle > handle : allHandles ) { Collections . sort ( handle , new HandleComparator ( ) ) ; } } private void addAllDecimalNumbers ( ) { Pattern p = Pattern . compile ( "[\\[\\{<>(),\\t\\s\\+\\-\\/\\*^%!|&=?:~]\\d+\\.?\\d*" ) ; for ( int i = 0 ; i < codeTabs . length ; i ++ ) { List < Handle > handles = new ArrayList < Handle > ( ) ; allHandles . add ( handles ) ; String c = codeTabs [ i ] ; Matcher m = p . matcher ( c ) ; while ( m . find ( ) ) { boolean forceFloat = false ; int start = m . start ( ) + 1 ; int end = m . end ( ) ; if ( isInRangeList ( start , commentBlocks . get ( i ) ) ) { continue ; } if ( setupFunction . contains ( start ) ) { continue ; } if ( requiresComment ) { if ( ! lineHasTweakComment ( start , c ) ) { continue ; } } boolean found = false ; for ( Range r : scientificNotations . get ( i ) ) { if ( r . contains ( start ) ) { found = true ; break ; } } if ( found ) { continue ; } if ( c . charAt ( end ) == 'f' ) { forceFloat = true ; end ++ ; } if ( c . charAt ( start - 1 ) == '-' ) { if ( isNegativeSign ( start - 2 , c ) ) { start -- ; } } if ( c . charAt ( m . end ( ) ) == 'x' || c . charAt ( m . end ( ) ) == 'X' ) { continue ; } if ( isInsideString ( start , c ) ) continue ; if ( isGlobal ( m . start ( ) , i ) ) continue ; int line = countLines ( c . substring ( 0 , start ) ) - 1 ; String value = c . substring ( start , end ) ; if ( value . contains ( "." ) || forceFloat ) { String name = varPrefix + "_float[" + floatVarCount + "]" ; int decimalDigits = getNumDigitsAfterPoint ( value ) ; handles . add ( new Handle ( "float" , name , floatVarCount , value , i , line , start , end , decimalDigits ) ) ; floatVarCount ++ ; } else { String name = varPrefix + "_int[" + intVarCount + "]" ; handles . add ( new Handle ( "int" , name , intVarCount , value , i , line , start , end , 0 ) ) ; intVarCount ++ ; } } } } private void addAllHexNumbers ( ) { Pattern p = Pattern . compile ( "[\\[\\{<>(),\\t\\s\\+\\-\\/\\*^%!|&=?:~]0x[A-Fa-f0-9]+" ) ; for ( int i = 0 ; i < codeTabs . length ; i ++ ) { String c = codeTabs [ i ] ; Matcher m = p . matcher ( c ) ; while ( m . find ( ) ) { int start = m . start ( ) + 1 ; int end = m . end ( ) ; if ( isInRangeList ( start , commentBlocks . get ( i ) ) ) { continue ; } if ( setupFunction . contains ( start ) ) { continue ; } if ( requiresComment ) { if ( ! lineHasTweakComment ( start , c ) ) { continue ; } } if ( isInsideString ( start , c ) ) { continue ; } if ( isGlobal ( m . start ( ) , i ) ) { continue ; } int line = countLines ( c . substring ( 0 , start ) ) - 1 ; String value = c . substring ( start , end ) ; String name = varPrefix + "_int[" + intVarCount + "]" ; Handle handle ; try { handle = new Handle ( "hex" , name , intVarCount , value , i , line , start , end , 0 ) ; } catch ( NumberFormatException e ) { continue ; } allHandles . get ( i ) . add ( handle ) ; intVarCount ++ ; } } } private void addAllWebColorNumbers ( ) { Pattern p = Pattern . compile ( "#[A-Fa-f0-9]{6}" ) ; for ( int i = 0 ; i < codeTabs . length ; i ++ ) { String c = codeTabs [ i ] ; Matcher m = p . matcher ( c ) ; while ( m . find ( ) ) { int start = m . start ( ) ; int end = m . end ( ) ; if ( isInRangeList ( start , commentBlocks . get ( i ) ) ) { continue ; } if ( setupFunction . contains ( start ) ) { continue ; } if ( requiresComment ) { if ( ! lineHasTweakComment ( start , c ) ) { continue ; } } if ( isInsideString ( start , c ) ) { continue ; } if ( isGlobal ( m . start ( ) , i ) ) { continue ; } int line = countLines ( c . substring ( 0 , start ) ) - 1 ; String value = c . substring ( start , end ) ; String name = varPrefix + "_int[" + intVarCount + "]" ; Handle handle ; try { handle = new Handle ( "webcolor" , name , intVarCount , value , i , line , start , end , 0 ) ; } catch ( NumberFormatException e ) { continue ; } allHandles . get ( i ) . add ( handle ) ; intVarCount ++ ; } } } private ArrayList < ColorMode > findAllColorModes ( ) { ArrayList < ColorMode > modes = new ArrayList < ColorMode > ( ) ; for ( int i = 0 ; i < codeTabs . length ; i ++ ) { String tab = codeTabs [ i ] ; int index = - 1 ; while ( ( index = tab . indexOf ( "colorMode" , index + 1 ) ) > - 1 ) { if ( isInRangeList ( index , commentBlocks . get ( i ) ) ) { continue ; } index += 9 ; int parOpen = tab . indexOf ( '(' , index ) ; if ( parOpen < 0 ) { continue ; } int parClose = tab . indexOf ( ')' , parOpen + 1 ) ; if ( parClose < 0 ) { continue ; } String modeDesc = tab . substring ( parOpen + 1 , parClose ) ; String context = getObject ( index - 9 , tab ) ; modes . add ( ColorMode . fromString ( context , modeDesc ) ) ; } } return modes ; } private void createColorBoxes ( ) { colorBoxes = new ArrayList < > ( ) ; Pattern p = Pattern . compile ( "color\\(|color\\s\\(|fill[\\(\\s]|stroke[\\(\\s]|background[\\(\\s]|tint[\\(\\s]" ) ; for ( int i = 0 ; i < codeTabs . length ; i ++ ) { List < ColorControlBox > colorBox = new ArrayList < ColorControlBox > ( ) ; colorBoxes . add ( colorBox ) ; String tab = codeTabs [ i ] ; Matcher m = p . matcher ( tab ) ; while ( m . find ( ) ) { ArrayList < Handle > colorHandles = new ArrayList < Handle > ( ) ; int openPar = tab . indexOf ( "(" , m . start ( ) ) ; int closePar = tab . indexOf ( ")" , m . end ( ) ) ; if ( openPar < 0 || closePar < 0 ) { continue ; } if ( isInRangeList ( m . start ( ) , commentBlocks . get ( i ) ) ) { continue ; } if ( setupFunction . contains ( m . start ( ) ) ) { continue ; } for ( Handle handle : allHandles . get ( i ) ) { if ( handle . startChar > openPar && handle . endChar <= closePar ) { colorHandles . add ( handle ) ; } } if ( colorHandles . size ( ) > 0 ) { String insidePar = tab . substring ( openPar + 1 , closePar ) ; for ( Handle h : colorHandles ) { insidePar = insidePar . replaceFirst ( h . strValue , "" ) ; } boolean garbage = false ; for ( int j = 0 ; j < insidePar . length ( ) ; j ++ ) { if ( insidePar . charAt ( j ) != ' ' && insidePar . charAt ( j ) != ',' ) { garbage = true ; } } if ( ! garbage ) { String context = getObject ( m . start ( ) , tab ) ; ColorMode cmode = getColorModeForContext ( context ) ; ColorControlBox newCCB = new ColorControlBox ( context , cmode , colorHandles ) ; if ( cmode . unrecognizedMode ) { if ( newCCB . isHex ) { colorBox . add ( newCCB ) ; } } else { colorBox . add ( newCCB ) ; } } } } } } private void createColorBoxesForLights ( ) { Pattern p = Pattern . compile ( "ambientLight[\\(\\s]|directionalLight[\\(\\s]" + "|pointLight[\\(\\s]|spotLight[\\(\\s]|lightSpecular[\\(\\s]" + "|specular[\\(\\s]|ambient[\\(\\s]|emissive[\\(\\s]" ) ; for ( int i = 0 ; i < codeTabs . length ; i ++ ) { String tab = codeTabs [ i ] ; Matcher m = p . matcher ( tab ) ; while ( m . find ( ) ) { ArrayList < Handle > colorHandles = new ArrayList < Handle > ( ) ; int openPar = tab . indexOf ( "(" , m . start ( ) ) ; int closePar = tab . indexOf ( ")" , m . end ( ) ) ; if ( openPar < 0 || closePar < 0 ) { continue ; } if ( isInRangeList ( m . start ( ) , commentBlocks . get ( i ) ) ) { continue ; } if ( setupFunction . contains ( m . start ( ) ) ) { continue ; } int colorParamsEnd = openPar ; int commas = 3 ; while ( commas -- > 0 ) { colorParamsEnd = tab . indexOf ( "," , colorParamsEnd + 1 ) ; if ( colorParamsEnd < 0 || colorParamsEnd > closePar ) { colorParamsEnd = closePar ; break ; } } for ( Handle handle : allHandles . get ( i ) ) { if ( handle . startChar > openPar && handle . endChar <= colorParamsEnd ) { colorHandles . add ( handle ) ; } } if ( colorHandles . size ( ) > 0 ) { String insidePar = tab . substring ( openPar + 1 , colorParamsEnd ) ; for ( Handle h : colorHandles ) { insidePar = insidePar . replaceFirst ( h . strValue , "" ) ; } boolean garbage = false ; for ( int j = 0 ; j < insidePar . length ( ) ; j ++ ) { if ( insidePar . charAt ( j ) != ' ' && insidePar . charAt ( j ) != ',' ) { garbage = true ; } } if ( ! garbage ) { String context = getObject ( m . start ( ) , tab ) ; ColorMode cmode = getColorModeForContext ( context ) ; ColorControlBox newCCB = new ColorControlBox ( context , cmode , colorHandles ) ; if ( cmode . unrecognizedMode ) { if ( newCCB . isHex ) { colorBoxes . get ( i ) . add ( newCCB ) ; } } else { colorBoxes . get ( i ) . add ( newCCB ) ; } } } } } } private ColorMode getColorModeForContext ( String context ) { for ( ColorMode cm : colorModes ) { if ( cm . drawContext . equals ( context ) ) { return cm ; } } ColorMode newMode = new ColorMode ( context ) ; colorModes . add ( newMode ) ; return newMode ; } private void handleMultipleColorModes ( ) { Map < String , Integer > modeCount = new HashMap < String , Integer > ( ) ; for ( ColorMode cm : colorModes ) { Integer prev = modeCount . get ( cm . drawContext ) ; if ( prev == null ) { prev = 0 ; } modeCount . put ( cm . drawContext , prev + 1 ) ; } ArrayList < String > multipleContexts = new ArrayList < String > ( ) ; Set < String > allContexts = modeCount . keySet ( ) ; for ( String context : allContexts ) { if ( modeCount . get ( context ) > 1 ) { multipleContexts . add ( context ) ; } } for ( int i = 0 ; i < codeTabs . length ; i ++ ) { List < ColorControlBox > toDelete = new ArrayList < ColorControlBox > ( ) ; for ( String context : multipleContexts ) { for ( ColorControlBox ccb : colorBoxes . get ( i ) ) { if ( ccb . drawContext . equals ( context ) && ! ccb . isHex ) { toDelete . add ( ccb ) ; } } } colorBoxes . get ( i ) . removeAll ( toDelete ) ; } } private List < List < Range > > getAllScientificNotations ( ) { List < List < Range > > notations = new ArrayList < > ( ) ; Pattern p = Pattern . compile ( "[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?[eE][+\\-]?\\d+" ) ; for ( String code : codeTabs ) { List < Range > notation = new ArrayList < Range > ( ) ; Matcher m = p . matcher ( code ) ; while ( m . find ( ) ) { notation . add ( new Range ( m . start ( ) , m . end ( ) ) ) ; } notations . add ( notation ) ; } return notations ; } static public boolean containsTweakComment ( String [ ] codeTabs ) { for ( String tab : codeTabs ) { if ( hasTweakComment ( tab ) ) { return true ; } } return false ; } static private boolean lineHasTweakComment ( int pos , String code ) { int lineEnd = getEndOfLine ( pos , code ) ; if ( lineEnd < 0 ) { return false ; } String line = code . substring ( pos , lineEnd ) ; return hasTweakComment ( line ) ; } static private boolean hasTweakComment ( String code ) { Pattern p = Pattern . compile ( "\\/\\/.*tweak" , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( code ) ; return m . find ( ) ; } static private boolean isNegativeSign ( int pos , String code ) { for ( int i = pos ; i >= 0 ; i -- ) { char c = code . charAt ( i ) ; if ( c != ' ' && c != '\t' ) { return ( c == ',' || c == '{' || c == '[' || c == '(' || c == '=' || c == '?' || c == '+' || c == '-' || c == '/' || c == '*' || c == '%' || c == '<' || c == '>' || c == ':' || c == '&' || c == '|' || c == '^' || c == '!' || c == '~' ) ; } } return false ; } static private int getNumDigitsAfterPoint ( String number ) { Pattern p = Pattern . compile ( "\\.[0-9]+" ) ; Matcher m = p . matcher ( number ) ; if ( m . find ( ) ) { return m . end ( ) - m . start ( ) - 1 ; } return 0 ; } static private int countLines ( String str ) { String [ ] lines = str . split ( "\r\n|\n\r|\n|\r" ) ; return lines . length ; } static private boolean isInsideString ( int pos , String code ) { int quoteNum = 0 ; for ( int c = pos ; c >= 0 && code . charAt ( c ) != '\n' ; c -- ) { if ( code . charAt ( c ) == '"' ) { quoteNum ++ ; } } if ( quoteNum % 2 == 1 ) { return true ; } return false ; } static private int [ ] getCurlyScopes ( String code ) { List < Range > comments = getCommentBlocks ( code ) ; int [ ] scopes = new int [ code . length ( ) ] ; int curlyScope = 0 ; boolean arrayAssignmentMaybeCommingFlag = false ; int arrayAssignmentCurlyScope = 0 ; for ( int pos = 0 ; pos < code . length ( ) ; pos ++ ) { scopes [ pos ] = curlyScope ; if ( isInRangeList ( pos , comments ) ) { continue ; } if ( code . charAt ( pos ) == '{' ) { if ( arrayAssignmentMaybeCommingFlag || arrayAssignmentCurlyScope > 0 ) { arrayAssignmentCurlyScope ++ ; arrayAssignmentMaybeCommingFlag = false ; } else { curlyScope ++ ; } } else if ( code . charAt ( pos ) == '}' ) { if ( arrayAssignmentCurlyScope > 0 ) { arrayAssignmentCurlyScope -- ; } else { curlyScope -- ; } } else if ( code . charAt ( pos ) == '=' ) { arrayAssignmentMaybeCommingFlag = true ; } else if ( ! isWhiteSpace ( code . charAt ( pos ) ) ) { arrayAssignmentMaybeCommingFlag = false ; } } return scopes ; } static private boolean isWhiteSpace ( char c ) { return c == ' ' || c == '\t' || c == '\n' || c == '\r' ; } private boolean isGlobal ( int pos , int codeTabIndex ) { return ( curlyScopes . get ( codeTabIndex ) [ pos ] == 0 ) ; } ; public static List < Range > getCommentBlocks ( String code ) { List < Range > commentBlocks = new ArrayList < Range > ( ) ; int lastBlockStart = 0 ; boolean lookForEnd = false ; for ( int pos = 0 ; pos < code . length ( ) - 1 ; pos ++ ) { if ( lookForEnd ) { if ( code . charAt ( pos ) == '*' && code . charAt ( pos + 1 ) == '/' ) { commentBlocks . add ( new Range ( lastBlockStart , pos + 1 ) ) ; lookForEnd = false ; } } else { if ( code . charAt ( pos ) == '/' && code . charAt ( pos + 1 ) == '*' ) { lastBlockStart = pos ; lookForEnd = true ; } else if ( code . charAt ( pos ) == '/' && code . charAt ( pos + 1 ) == '/' ) { commentBlocks . add ( new Range ( pos , getEndOfLine ( pos , code ) ) ) ; } } } return commentBlocks ; } private static boolean isInRangeList ( int pos , List < Range > rangeList ) { for ( Range r : rangeList ) { if ( r . contains ( pos ) ) { return true ; } } return false ; } static private int getEndOfLine ( int pos , String code ) { return code . indexOf ( "\n" , pos ) ; } static private String getObject ( int pos , String code ) { boolean readObject = false ; String obj = "this" ; while ( pos -- >= 0 ) { if ( code . charAt ( pos ) == '.' ) { if ( ! readObject ) { obj = "" ; readObject = true ; } else { break ; } } else if ( code . charAt ( pos ) == ' ' || code . charAt ( pos ) == '\t' ) { break ; } else if ( readObject ) { obj = code . charAt ( pos ) + obj ; } } return obj ; } public static int getSetupStart ( String code ) { Pattern p = Pattern . compile ( "void[\\s\\t\\r\\n]*setup[\\s\\t]*\\(\\)[\\s\\t\\r\\n]*\\{" ) ; Matcher m = p . matcher ( code ) ; if ( m . find ( ) ) { return m . end ( ) ; } return - 1 ; } public static int getSetupEnd ( String code ) { List < Range > comments = getCommentBlocks ( code ) ; int setupStart = getSetupStart ( code ) ; if ( setupStart == - 1 ) { return - 1 ; } System . out . println ( "setup start = " + setupStart ) ; int bracketCount = 1 ; int pos = setupStart ; while ( bracketCount > 0 && pos < code . length ( ) ) { if ( isInRangeList ( pos , comments ) ) { pos ++ ; continue ; } if ( code . charAt ( pos ) == '{' ) { bracketCount ++ ; } else if ( code . charAt ( pos ) == '}' ) { bracketCount -- ; } pos ++ ; } if ( bracketCount == 0 ) { return pos - 1 ; } return - 1 ; } static class Range { int start ; int end ; public Range ( int s , int e ) { start = s ; end = e ; } public boolean contains ( int v ) { return v >= start && v < end ; } } }
package processing . mode . java . tweak ; import java . awt . BasicStroke ; import java . awt . Color ; import java . awt . Graphics2D ; import java . awt . geom . AffineTransform ; import java . util . ArrayList ; import processing . mode . java . pdex . JavaTextAreaPainter ; public class ColorControlBox { public boolean visible ; ArrayList < Handle > handles ; ColorMode colorMode ; Color color ; boolean ilegalColor = false ; boolean isBW ; boolean isHex ; String drawContext ; int x , y , width , height ; JavaTextAreaPainter painter ; public ColorControlBox ( String context , ColorMode mode , ArrayList < Handle > handles ) { this . drawContext = context ; this . colorMode = mode ; this . handles = handles ; for ( Handle h : handles ) { h . setColorBox ( this ) ; } isBW = isGrayScale ( ) ; isHex = isHexColor ( ) ; color = getCurrentColor ( ) ; visible = Settings . alwaysShowColorBoxes ; } public void initInterface ( JavaTextAreaPainter textAreaPainter , int x , int y , int w , int h ) { this . painter = textAreaPainter ; this . x = x ; this . y = y ; this . width = w ; this . height = h ; } public void setPos ( int x , int y ) { this . x = x ; this . y = y ; } public void draw ( Graphics2D g2d ) { if ( ! visible ) { return ; } AffineTransform trans = g2d . getTransform ( ) ; g2d . translate ( x , y ) ; g2d . setColor ( color ) ; g2d . fillRoundRect ( 0 , 0 , width , height , 5 , 5 ) ; g2d . setStroke ( new BasicStroke ( 1 ) ) ; g2d . setColor ( Color . BLACK ) ; g2d . drawRoundRect ( 0 , 0 , width , height , 5 , 5 ) ; if ( ilegalColor ) { g2d . setColor ( Color . RED ) ; g2d . setStroke ( new BasicStroke ( 2 ) ) ; g2d . drawLine ( width - 3 , 3 , 3 , height - 3 ) ; } g2d . setTransform ( trans ) ; } public boolean isGrayScale ( ) { if ( handles . size ( ) <= 2 ) { int value = handles . get ( 0 ) . newValue . intValue ( ) ; if ( ( value & 0xff000000 ) == 0 ) { return true ; } } return false ; } private boolean isHexColor ( ) { if ( handles . get ( 0 ) . type == "hex" || handles . get ( 0 ) . type == "webcolor" ) { int value = handles . get ( 0 ) . value . intValue ( ) ; if ( ( value & 0xff000000 ) != 0 ) { return true ; } } return false ; } public Color getCurrentColor ( ) { try { if ( handles . size ( ) == 1 ) { if ( isBW ) { float gray = handles . get ( 0 ) . newValue . floatValue ( ) ; return verifiedGrayColor ( gray ) ; } else { int argb = handles . get ( 0 ) . newValue . intValue ( ) ; return verifiedHexColor ( argb ) ; } } else if ( handles . size ( ) == 2 ) { if ( isBW ) { float gray = handles . get ( 0 ) . newValue . floatValue ( ) ; return verifiedGrayColor ( gray ) ; } else { int argb = handles . get ( 0 ) . newValue . intValue ( ) ; float a = handles . get ( 1 ) . newValue . floatValue ( ) ; return verifiedHexColor ( argb , a ) ; } } else if ( handles . size ( ) == 3 ) { float v1 = handles . get ( 0 ) . newValue . floatValue ( ) ; float v2 = handles . get ( 1 ) . newValue . floatValue ( ) ; float v3 = handles . get ( 2 ) . newValue . floatValue ( ) ; if ( colorMode . modeType == ColorMode . RGB ) { return verifiedRGBColor ( v1 , v2 , v3 , colorMode . aMax ) ; } else { return verifiedHSBColor ( v1 , v2 , v3 , colorMode . aMax ) ; } } else if ( handles . size ( ) == 4 ) { float v1 = handles . get ( 0 ) . newValue . floatValue ( ) ; float v2 = handles . get ( 1 ) . newValue . floatValue ( ) ; float v3 = handles . get ( 2 ) . newValue . floatValue ( ) ; float a = handles . get ( 3 ) . newValue . floatValue ( ) ; if ( colorMode . modeType == ColorMode . RGB ) { return verifiedRGBColor ( v1 , v2 , v3 , a ) ; } else { return verifiedHSBColor ( v1 , v2 , v3 , a ) ; } } } catch ( Exception e ) { System . out . println ( "error parsing color value: " + e . toString ( ) ) ; ilegalColor = true ; return Color . WHITE ; } ilegalColor = true ; return Color . WHITE ; } private Color verifiedGrayColor ( float gray ) { if ( gray < 0 || gray > colorMode . v1Max ) { return colorError ( ) ; } ilegalColor = false ; gray = gray / colorMode . v1Max * 255 ; return new Color ( ( int ) gray , ( int ) gray , ( int ) gray , 255 ) ; } private Color verifiedHexColor ( int argb ) { int r = ( argb > > 16 ) & 0xff ; int g = ( argb > > 8 ) & 0xff ; int b = ( argb & 0xff ) ; ilegalColor = false ; return new Color ( r , g , b , 255 ) ; } private Color verifiedHexColor ( int argb , float alpha ) { int r = ( argb > > 16 ) & 0xff ; int g = ( argb > > 8 ) & 0xff ; int b = ( argb & 0xff ) ; ilegalColor = false ; return new Color ( r , g , b , 255 ) ; } public Color verifiedRGBColor ( float r , float g , float b , float a ) { if ( r < 0 || r > colorMode . v1Max || g < 0 || g > colorMode . v2Max || b < 0 || b > colorMode . v3Max ) { return colorError ( ) ; } ilegalColor = false ; r = r / colorMode . v1Max * 255 ; g = g / colorMode . v2Max * 255 ; b = b / colorMode . v3Max * 255 ; return new Color ( ( int ) r , ( int ) g , ( int ) b , 255 ) ; } public Color verifiedHSBColor ( float h , float s , float b , float a ) { if ( h < 0 || h > colorMode . v1Max || s < 0 || s > colorMode . v2Max || b < 0 || b > colorMode . v3Max ) { return colorError ( ) ; } ilegalColor = false ; Color c = Color . getHSBColor ( h / colorMode . v1Max , s / colorMode . v2Max , b / colorMode . v3Max ) ; return new Color ( c . getRed ( ) , c . getGreen ( ) , c . getBlue ( ) , 255 ) ; } private Color colorError ( ) { ilegalColor = true ; return Color . WHITE ; } public void colorChanged ( ) { color = getCurrentColor ( ) ; } public int getTabIndex ( ) { return handles . get ( 0 ) . tabIndex ; } public int getLine ( ) { return handles . get ( 0 ) . line ; } public int getCharIndex ( ) { int lastHandle = handles . size ( ) - 1 ; return handles . get ( lastHandle ) . newEndChar + 2 ; } public boolean pick ( int mx , int my ) { if ( ! visible ) { return false ; } if ( mx > x && mx < x + width && my > y && my < y + height ) { return true ; } return false ; } public boolean setMouseY ( int my ) { boolean change = false ; if ( my > y && my < y + height ) { if ( ! visible ) { change = true ; } visible = true ; } else { if ( visible ) { change = true ; } visible = false ; } return change ; } public void selectorChanged ( int hue , int saturation , int brightness ) { if ( isBW ) { handles . get ( 0 ) . setValue ( ( float ) hue / 255 * colorMode . v1Max ) ; } else { if ( handles . size ( ) == 1 || handles . size ( ) == 2 ) { int prevVal = handles . get ( 0 ) . newValue . intValue ( ) ; int prevAlpha = ( prevVal > > 24 ) & 0xff ; Color c = Color . getHSBColor ( ( float ) hue / 255 , ( float ) saturation / 255 , ( float ) brightness / 255 ) ; int newVal = ( prevAlpha < < 24 ) | ( c . getRed ( ) < < 16 ) | ( c . getGreen ( ) < < 8 ) | ( c . getBlue ( ) ) ; handles . get ( 0 ) . setValue ( newVal ) ; } else if ( handles . size ( ) == 3 || handles . size ( ) == 4 ) { if ( colorMode . modeType == ColorMode . HSB ) { float v1 = ( float ) hue / 255 * colorMode . v1Max ; float v2 = ( float ) saturation / 255 * colorMode . v2Max ; float v3 = ( float ) brightness / 255 * colorMode . v3Max ; handles . get ( 0 ) . setValue ( v1 ) ; handles . get ( 1 ) . setValue ( v2 ) ; handles . get ( 2 ) . setValue ( v3 ) ; } else { Color c = Color . getHSBColor ( ( float ) hue / 255 , ( float ) saturation / 255 , ( float ) brightness / 255 ) ; handles . get ( 0 ) . setValue ( ( float ) c . getRed ( ) / 255 * colorMode . v1Max ) ; handles . get ( 1 ) . setValue ( ( float ) c . getGreen ( ) / 255 * colorMode . v2Max ) ; handles . get ( 2 ) . setValue ( ( float ) c . getBlue ( ) / 255 * colorMode . v3Max ) ; } } } color = getCurrentColor ( ) ; painter . updateCodeText ( ) ; painter . repaint ( ) ; } public String toString ( ) { return handles . size ( ) + " handles, color mode: " + colorMode . toString ( ) ; } }
package processing . mode . java . tweak ; import java . awt . Graphics2D ; import java . awt . Polygon ; import java . awt . geom . AffineTransform ; public class HProgressBar { int x , y , size , width ; int pos ; int lPolyX , rPolyX ; Polygon rightPoly , leftPoly ; public HProgressBar ( int size , int width ) { this . size = size ; this . width = width ; x = 0 ; y = 0 ; setPos ( 0 ) ; int xl [ ] = { 0 , 0 , - ( int ) ( size / 1.5 ) } ; int yl [ ] = { - ( int ) ( ( float ) size / 3 ) , ( int ) ( ( float ) size / 3 ) , 0 } ; leftPoly = new Polygon ( xl , yl , 3 ) ; int xr [ ] = { 0 , ( int ) ( size / 1.5 ) , 0 } ; int yr [ ] = { - ( int ) ( ( float ) size / 3 ) , 0 , ( int ) ( ( float ) size / 3 ) } ; rightPoly = new Polygon ( xr , yr , 3 ) ; } public void setPos ( int pos ) { this . pos = pos ; lPolyX = 0 ; rPolyX = 0 ; if ( pos > 0 ) { rPolyX = pos ; } else if ( pos < 0 ) { lPolyX = pos ; } } public void setWidth ( int width ) { this . width = width ; } public void draw ( Graphics2D g2d ) { AffineTransform trans = g2d . getTransform ( ) ; g2d . translate ( x , y ) ; g2d . setColor ( ColorScheme . getInstance ( ) . whitePaneColor ) ; g2d . fillRect ( - 200 + lPolyX , - size , 200 - lPolyX - width / 2 , size + 1 ) ; g2d . fillRect ( width / 2 , - size , 200 + rPolyX , size + 1 ) ; g2d . setColor ( ColorScheme . getInstance ( ) . progressFillColor ) ; AffineTransform tmp = g2d . getTransform ( ) ; g2d . translate ( - width / 2 - 5 + lPolyX , - size / 2 ) ; g2d . fillRect ( 0 , - 1 , - lPolyX , 2 ) ; g2d . fillPolygon ( leftPoly ) ; g2d . setTransform ( tmp ) ; g2d . translate ( width / 2 + 5 + rPolyX , - size / 2 ) ; g2d . fillRect ( - rPolyX , - 1 , rPolyX + 1 , 2 ) ; g2d . fillPolygon ( rightPoly ) ; g2d . setTransform ( tmp ) ; g2d . setTransform ( trans ) ; } }
package processing . core ; import java . awt . Desktop ; import java . awt . DisplayMode ; import java . awt . EventQueue ; import java . awt . FileDialog ; import java . awt . Font ; import java . awt . Frame ; import java . awt . GraphicsDevice ; import java . awt . GraphicsEnvironment ; import java . awt . HeadlessException ; import java . awt . Image ; import java . awt . Toolkit ; import java . awt . color . ColorSpace ; import java . awt . image . BufferedImage ; import javax . imageio . ImageIO ; import javax . swing . ImageIcon ; import javax . swing . JFileChooser ; import javax . swing . JOptionPane ; import javax . swing . filechooser . FileSystemView ; import javax . xml . parsers . ParserConfigurationException ; import org . xml . sax . SAXException ; import java . io . * ; import java . lang . reflect . * ; import java . net . * ; import java . text . * ; import java . util . * ; import java . util . regex . * ; import java . util . zip . * ; import processing . data . * ; import processing . event . * ; import processing . opengl . * ; public class PApplet implements PConstants { static public final String javaVersionName = System . getProperty ( "java.version" ) ; static public final int javaPlatform = PApplet . parseInt ( PApplet . split ( javaVersionName , '.' ) [ 1 ] ) ; @ Deprecated public static final float javaVersion = new Float ( javaVersionName . substring ( 0 , 3 ) ) ; static public int platform ; static { String osname = System . getProperty ( "os.name" ) ; if ( osname . indexOf ( "Mac" ) != - 1 ) { platform = MACOSX ; } else if ( osname . indexOf ( "Windows" ) != - 1 ) { platform = WINDOWS ; } else if ( osname . equals ( "Linux" ) ) { platform = LINUX ; } else { platform = OTHER ; } } static public boolean useNativeSelect = ( platform != LINUX ) ; public PGraphics g ; public int displayWidth ; public int displayHeight ; public PGraphics recorder ; public String [ ] args ; private String sketchPath ; static final boolean DEBUG = false ; static public final int DEFAULT_WIDTH = 100 ; static public final int DEFAULT_HEIGHT = 100 ; public boolean defaultSize ; public int [ ] pixels ; public int width = DEFAULT_WIDTH ; public int height = DEFAULT_HEIGHT ; public int pixelWidth ; public int pixelHeight ; public int mouseX ; public int mouseY ; public int pmouseX ; public int pmouseY ; protected int dmouseX , dmouseY ; protected int emouseX , emouseY ; @ Deprecated public boolean firstMouse ; public int mouseButton ; public boolean mousePressed ; @ Deprecated public MouseEvent mouseEvent ; public char key ; public int keyCode ; public boolean keyPressed ; @ Deprecated public KeyEvent keyEvent ; public boolean focused = false ; long millisOffset = System . currentTimeMillis ( ) ; public float frameRate = 10 ; protected boolean looping ; protected boolean redraw ; public int frameCount ; public volatile boolean finished ; protected boolean exitCalled ; static public final String ARGS_EDITOR_LOCATION = "--editor-location" ; static public final String ARGS_EXTERNAL = "--external" ; static public final String ARGS_LOCATION = "--location" ; static public final String ARGS_DISPLAY = "--display" ; static public final String ARGS_WINDOW_COLOR = "--window-color" ; static public final String ARGS_PRESENT = "--present" ; static public final String ARGS_STOP_COLOR = "--stop-color" ; static public final String ARGS_HIDE_STOP = "--hide-stop" ; static public final String ARGS_SKETCH_FOLDER = "--sketch-path" ; static public final String EXTERNAL_STOP = "__STOP__" ; static public final String EXTERNAL_MOVE = "__MOVE__" ; boolean external = false ; static final String ERROR_MIN_MAX = "Cannot use min() or max() on an empty array." ; protected PSurface surface ; public Frame frame ; public Frame getFrame ( ) { return frame ; } public void setFrame ( Frame frame ) { this . frame = frame ; } public void init ( ) { defaultSize = true ; finished = false ; looping = true ; redraw = true ; firstMouse = true ; surface . startThread ( ) ; } boolean insideSettings ; String renderer = JAVA2D ; int smooth = 1 ; boolean fullScreen ; int display = - 1 ; GraphicsDevice [ ] displayDevices ; public int pixelDensity = 1 ; String outputPath ; OutputStream outputStream ; int windowColor = 0xffDDDDDD ; boolean insideSettings ( String method , Object ... args ) { if ( insideSettings ) { return true ; } final String url = "https://processing.org/reference/" + method + "_.html" ; if ( ! external ) { StringList argList = new StringList ( args ) ; System . err . println ( "When not using the PDE, " + method + "() can only be used inside settings()." ) ; System . err . println ( "Remove the " + method + "() method from setup(), and add the following:" ) ; System . err . println ( "public void settings() {" ) ; System . err . println ( " " + method + "(" + argList . join ( ", " ) + ");" ) ; System . err . println ( "}" ) ; } throw new IllegalStateException ( method + "() cannot be used here, see " + url ) ; } void handleSettings ( ) { insideSettings = true ; GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice device = ge . getDefaultScreenDevice ( ) ; displayDevices = ge . getScreenDevices ( ) ; if ( display > 0 && display <= displayDevices . length ) { device = displayDevices [ display - 1 ] ; } DisplayMode displayMode = device . getDisplayMode ( ) ; displayWidth = displayMode . getWidth ( ) ; displayHeight = displayMode . getHeight ( ) ; settings ( ) ; if ( display == SPAN && platform == MACOSX ) { Process p = exec ( "defaults" , "read" , "com.apple.spaces" , "spans-displays" ) ; BufferedReader outReader = createReader ( p . getInputStream ( ) ) ; BufferedReader errReader = createReader ( p . getErrorStream ( ) ) ; StringBuilder stdout = new StringBuilder ( ) ; StringBuilder stderr = new StringBuilder ( ) ; String line = null ; try { while ( ( line = outReader . readLine ( ) ) != null ) { stdout . append ( line ) ; } while ( ( line = errReader . readLine ( ) ) != null ) { stderr . append ( line ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } int resultCode = - 1 ; try { resultCode = p . waitFor ( ) ; } catch ( InterruptedException e ) { } String result = trim ( stdout . toString ( ) ) ; if ( "0" . equals ( result ) ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { final String msg = "To use fullScreen(SPAN), first turn off Displays have separate spaces\n" + "in System Preferences \u2192 Mission Control. Then log out and log back in." ; JOptionPane . showMessageDialog ( null , msg , "Apple's Defaults Stink" , JOptionPane . WARNING_MESSAGE ) ; } } ) ; } else if ( ! result . equals ( "1" ) ) { System . err . println ( "Could not check the status of Displays have separate spaces." ) ; System . err . format ( "Received message '%s' and result code %d.%n" , trim ( stderr . toString ( ) ) , resultCode ) ; } } insideSettings = false ; } public void settings ( ) { } final public int sketchWidth ( ) { return width ; } final public int sketchHeight ( ) { return height ; } final public String sketchRenderer ( ) { return renderer ; } final public int sketchSmooth ( ) { return smooth ; } final public boolean sketchFullScreen ( ) { return fullScreen ; } final public int sketchDisplay ( ) { return display ; } final public String sketchOutputPath ( ) { return outputPath ; } final public OutputStream sketchOutputStream ( ) { return outputStream ; } final public int sketchWindowColor ( ) { return windowColor ; } final public int sketchPixelDensity ( ) { return pixelDensity ; } public int displayDensity ( ) { if ( display == SPAN ) { for ( int i = 0 ; i < displayDevices . length ; i ++ ) { if ( displayDensity ( i ) != 2 ) { return 1 ; } } return 2 ; } return displayDensity ( display ) ; } static public int displayDensity ( int display ) { if ( PApplet . platform == PConstants . MACOSX ) { final String javaVendor = System . getProperty ( "java.vendor" ) ; if ( javaVendor . contains ( "Oracle" ) ) { GraphicsDevice device ; GraphicsEnvironment env = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; if ( display == - 1 ) { device = env . getDefaultScreenDevice ( ) ; } else if ( display == SPAN ) { throw new RuntimeException ( "displayDensity() only works with specific display numbers" ) ; } else { GraphicsDevice [ ] devices = env . getScreenDevices ( ) ; if ( display > 0 && display <= devices . length ) { device = devices [ display - 1 ] ; } else { if ( devices . length == 1 ) { System . err . println ( "Only one display is currently known, use displayDensity(1)." ) ; } else { System . err . format ( "Your displays are numbered %d through %d, " + "pass one of those numbers to displayDensity()" , 1 , devices . length ) ; } throw new RuntimeException ( "Display " + display + " does not exist." ) ; } } try { Field field = device . getClass ( ) . getDeclaredField ( "scale" ) ; if ( field != null ) { field . setAccessible ( true ) ; Object scale = field . get ( device ) ; if ( scale instanceof Integer && ( ( Integer ) scale ) . intValue ( ) == 2 ) { return 2 ; } } } catch ( Exception ignore ) { } } } return 1 ; } public void pixelDensity ( int density ) { if ( density != this . pixelDensity ) { if ( insideSettings ( "pixelDensity" , density ) ) { if ( density != 1 && density != 2 ) { throw new RuntimeException ( "pixelDensity() can only be 1 or 2" ) ; } if ( density == 2 && displayDensity ( ) == 1 ) { throw new RuntimeException ( "pixelDensity(2) is not available for this display" ) ; } else { this . pixelDensity = density ; } } } } public void setSize ( int width , int height ) { this . width = width ; this . height = height ; pixelWidth = width * pixelDensity ; pixelHeight = height * pixelDensity ; } public void smooth ( ) { smooth ( 1 ) ; } public void smooth ( int level ) { if ( insideSettings ) { this . smooth = level ; } else if ( this . smooth != level ) { smoothWarning ( "smooth" ) ; } } public void noSmooth ( ) { if ( insideSettings ) { this . smooth = 0 ; } else if ( this . smooth != 0 ) { smoothWarning ( "noSmooth" ) ; } } private void smoothWarning ( String method ) { final String where = external ? "setup" : "settings" ; PGraphics . showWarning ( "%s() can only be used inside %s()" , method , where ) ; } public PGraphics getGraphics ( ) { return g ; } public void orientation ( int which ) { } public void start ( ) { resume ( ) ; handleMethods ( "resume" ) ; surface . resumeThread ( ) ; } public void stop ( ) { pause ( ) ; handleMethods ( "pause" ) ; surface . pauseThread ( ) ; } public void pause ( ) { } public void resume ( ) { } HashMap < String , RegisteredMethods > registerMap = new HashMap < String , PApplet . RegisteredMethods > ( ) ; class RegisteredMethods { int count ; Object [ ] objects ; Method [ ] methods ; Object [ ] emptyArgs = new Object [ ] { } ; void handle ( ) { handle ( emptyArgs ) ; } void handle ( Object [ ] args ) { for ( int i = 0 ; i < count ; i ++ ) { try { methods [ i ] . invoke ( objects [ i ] , args ) ; } catch ( Exception e ) { Throwable t ; if ( e instanceof InvocationTargetException ) { InvocationTargetException ite = ( InvocationTargetException ) e ; t = ite . getCause ( ) ; } else { t = e ; } if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else { t . printStackTrace ( ) ; } } } } void add ( Object object , Method method ) { if ( findIndex ( object ) == - 1 ) { if ( objects == null ) { objects = new Object [ 5 ] ; methods = new Method [ 5 ] ; } else if ( count == objects . length ) { objects = ( Object [ ] ) PApplet . expand ( objects ) ; methods = ( Method [ ] ) PApplet . expand ( methods ) ; } objects [ count ] = object ; methods [ count ] = method ; count ++ ; } else { die ( method . getName ( ) + "() already added for this instance of " + object . getClass ( ) . getName ( ) ) ; } } public void remove ( Object object ) { int index = findIndex ( object ) ; if ( index != - 1 ) { count -- ; for ( int i = index ; i < count ; i ++ ) { objects [ i ] = objects [ i + 1 ] ; methods [ i ] = methods [ i + 1 ] ; } objects [ count ] = null ; methods [ count ] = null ; } } protected int findIndex ( Object object ) { for ( int i = 0 ; i < count ; i ++ ) { if ( objects [ i ] == object ) { return i ; } } return - 1 ; } } public void registerMethod ( String methodName , Object target ) { if ( methodName . equals ( "mouseEvent" ) ) { registerWithArgs ( "mouseEvent" , target , new Class [ ] { processing . event . MouseEvent . class } ) ; } else if ( methodName . equals ( "keyEvent" ) ) { registerWithArgs ( "keyEvent" , target , new Class [ ] { processing . event . KeyEvent . class } ) ; } else if ( methodName . equals ( "touchEvent" ) ) { registerWithArgs ( "touchEvent" , target , new Class [ ] { processing . event . TouchEvent . class } ) ; } else { registerNoArgs ( methodName , target ) ; } } private void registerNoArgs ( String name , Object o ) { RegisteredMethods meth = registerMap . get ( name ) ; if ( meth == null ) { meth = new RegisteredMethods ( ) ; registerMap . put ( name , meth ) ; } Class < ? > c = o . getClass ( ) ; try { Method method = c . getMethod ( name , new Class [ ] { } ) ; meth . add ( o , method ) ; } catch ( NoSuchMethodException nsme ) { die ( "There is no public " + name + "() method in the class " + o . getClass ( ) . getName ( ) ) ; } catch ( Exception e ) { die ( "Could not register " + name + " + () for " + o , e ) ; } } private void registerWithArgs ( String name , Object o , Class < ? > cargs [ ] ) { RegisteredMethods meth = registerMap . get ( name ) ; if ( meth == null ) { meth = new RegisteredMethods ( ) ; registerMap . put ( name , meth ) ; } Class < ? > c = o . getClass ( ) ; try { Method method = c . getMethod ( name , cargs ) ; meth . add ( o , method ) ; } catch ( NoSuchMethodException nsme ) { die ( "There is no public " + name + "() method in the class " + o . getClass ( ) . getName ( ) ) ; } catch ( Exception e ) { die ( "Could not register " + name + " + () for " + o , e ) ; } } public void unregisterMethod ( String name , Object target ) { RegisteredMethods meth = registerMap . get ( name ) ; if ( meth == null ) { die ( "No registered methods with the name " + name + "() were found." ) ; } try { meth . remove ( target ) ; } catch ( Exception e ) { die ( "Could not unregister " + name + "() for " + target , e ) ; } } protected void handleMethods ( String methodName ) { RegisteredMethods meth = registerMap . get ( methodName ) ; if ( meth != null ) { meth . handle ( ) ; } } protected void handleMethods ( String methodName , Object [ ] args ) { RegisteredMethods meth = registerMap . get ( methodName ) ; if ( meth != null ) { meth . handle ( args ) ; } } public void setup ( ) { } public void draw ( ) { finished = true ; } public void fullScreen ( ) { if ( ! fullScreen ) { if ( insideSettings ( "fullScreen" ) ) { this . fullScreen = true ; } } } public void fullScreen ( int display ) { if ( ! fullScreen || display != this . display ) { if ( insideSettings ( "fullScreen" , display ) ) { this . fullScreen = true ; this . display = display ; } } } public void fullScreen ( String renderer ) { if ( ! fullScreen || ! renderer . equals ( this . renderer ) ) { if ( insideSettings ( "fullScreen" , renderer ) ) { this . fullScreen = true ; this . renderer = renderer ; } } } public void fullScreen ( String renderer , int display ) { if ( ! fullScreen || ! renderer . equals ( this . renderer ) || display != this . display ) { if ( insideSettings ( "fullScreen" , renderer , display ) ) { this . fullScreen = true ; this . renderer = renderer ; this . display = display ; } } } public void size ( int width , int height ) { if ( width != this . width || height != this . height ) { if ( insideSettings ( "size" , width , height ) ) { this . width = width ; this . height = height ; } } } public void size ( int width , int height , String renderer ) { if ( width != this . width || height != this . height || ! renderer . equals ( this . renderer ) ) { if ( insideSettings ( "size" , width , height , renderer ) ) { this . width = width ; this . height = height ; this . renderer = renderer ; } } } public void size ( int width , int height , String renderer , String path ) { if ( width != this . width || height != this . height || ! renderer . equals ( this . renderer ) ) { if ( insideSettings ( "size" , width , height , renderer , path ) ) { this . width = width ; this . height = height ; this . renderer = renderer ; this . outputPath = path ; } } } public PGraphics createGraphics ( int w , int h ) { return createGraphics ( w , h , JAVA2D ) ; } public PGraphics createGraphics ( int w , int h , String renderer ) { return createGraphics ( w , h , renderer , null ) ; } public PGraphics createGraphics ( int w , int h , String renderer , String path ) { return makeGraphics ( w , h , renderer , path , false ) ; } protected PGraphics makeGraphics ( int w , int h , String renderer , String path , boolean primary ) { if ( ! primary && ! g . isGL ( ) ) { if ( renderer . equals ( P2D ) ) { throw new RuntimeException ( "createGraphics() with P2D requires size() to use P2D or P3D" ) ; } else if ( renderer . equals ( P3D ) ) { throw new RuntimeException ( "createGraphics() with P3D or OPENGL requires size() to use P2D or P3D" ) ; } } try { Class < ? > rendererClass = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( renderer ) ; Constructor < ? > constructor = rendererClass . getConstructor ( new Class [ ] { } ) ; PGraphics pg = ( PGraphics ) constructor . newInstance ( ) ; pg . setParent ( this ) ; pg . setPrimary ( primary ) ; if ( path != null ) { pg . setPath ( savePath ( path ) ) ; } pg . setSize ( w , h ) ; return pg ; } catch ( InvocationTargetException ite ) { String msg = ite . getTargetException ( ) . getMessage ( ) ; if ( ( msg != null ) && ( msg . indexOf ( "no jogl in java.library.path" ) != - 1 ) ) { throw new RuntimeException ( "The jogl library folder needs to be " + "specified with -Djava.library.path=/path/to/jogl" ) ; } else { ite . getTargetException ( ) . printStackTrace ( ) ; Throwable target = ite . getTargetException ( ) ; if ( platform == MACOSX ) { target . printStackTrace ( System . out ) ; } throw new RuntimeException ( target . getMessage ( ) ) ; } } catch ( ClassNotFoundException cnfe ) { if ( external ) { throw new RuntimeException ( "You need to use \"Import Library\" " + "to add " + renderer + " to your sketch." ) ; } else { throw new RuntimeException ( "The " + renderer + " renderer is not in the class path." ) ; } } catch ( Exception e ) { if ( ( e instanceof IllegalArgumentException ) || ( e instanceof NoSuchMethodException ) || ( e instanceof IllegalAccessException ) ) { if ( e . getMessage ( ) . contains ( "cannot be <= 0" ) ) { throw new RuntimeException ( e ) ; } else { e . printStackTrace ( ) ; String msg = renderer + " needs to be updated " + "for the current release of Processing." ; throw new RuntimeException ( msg ) ; } } else { if ( platform == MACOSX ) { e . printStackTrace ( System . out ) ; } e . printStackTrace ( ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } } } protected PGraphics createPrimaryGraphics ( ) { return makeGraphics ( sketchWidth ( ) , sketchHeight ( ) , sketchRenderer ( ) , sketchOutputPath ( ) , true ) ; } public PImage createImage ( int w , int h , int format ) { PImage image = new PImage ( w , h , format ) ; image . parent = this ; return image ; } protected boolean insideDraw ; protected long frameRateLastNanos = 0 ; public void handleDraw ( ) { if ( canDraw ( ) ) { if ( ! g . canDraw ( ) ) { debug ( "g.canDraw() is false" ) ; return ; } int pquality = g . smooth ; if ( insideDraw ) { System . err . println ( "handleDraw() called before finishing" ) ; System . exit ( 1 ) ; } insideDraw = true ; g . beginDraw ( ) ; if ( recorder != null ) { recorder . beginDraw ( ) ; } long now = System . nanoTime ( ) ; if ( frameCount == 0 ) { setup ( ) ; defaultSize = false ; } else { double rate = 1000000.0 / ( ( now - frameRateLastNanos ) / 1000000.0 ) ; float instantaneousRate = ( float ) rate / 1000.0f ; frameRate = ( frameRate * 0.9f ) + ( instantaneousRate * 0.1f ) ; if ( frameCount != 0 ) { handleMethods ( "pre" ) ; } pmouseX = dmouseX ; pmouseY = dmouseY ; draw ( ) ; dmouseX = mouseX ; dmouseY = mouseY ; dequeueEvents ( ) ; handleMethods ( "draw" ) ; redraw = false ; } g . endDraw ( ) ; if ( pquality != g . smooth ) { surface . setSmooth ( g . smooth ) ; } if ( recorder != null ) { recorder . endDraw ( ) ; } insideDraw = false ; if ( frameCount != 0 ) { handleMethods ( "post" ) ; } frameRateLastNanos = now ; frameCount ++ ; } } public boolean canDraw ( ) { return g != null && ( looping || redraw ) ; } synchronized public void redraw ( ) { if ( ! looping ) { redraw = true ; } } synchronized public void loop ( ) { if ( ! looping ) { looping = true ; } } synchronized public void noLoop ( ) { if ( looping ) { looping = false ; } } InternalEventQueue eventQueue = new InternalEventQueue ( ) ; static class InternalEventQueue { protected Event queue [ ] = new Event [ 10 ] ; protected int offset ; protected int count ; synchronized void add ( Event e ) { if ( count == queue . length ) { queue = ( Event [ ] ) expand ( queue ) ; } queue [ count ++ ] = e ; } synchronized Event remove ( ) { if ( offset == count ) { throw new RuntimeException ( "Nothing left on the event queue." ) ; } Event outgoing = queue [ offset ++ ] ; if ( offset == count ) { offset = 0 ; count = 0 ; } return outgoing ; } synchronized boolean available ( ) { return count != 0 ; } } public void postEvent ( processing . event . Event pe ) { eventQueue . add ( pe ) ; if ( ! looping ) { dequeueEvents ( ) ; } } protected void dequeueEvents ( ) { while ( eventQueue . available ( ) ) { Event e = eventQueue . remove ( ) ; switch ( e . getFlavor ( ) ) { case Event . MOUSE : handleMouseEvent ( ( MouseEvent ) e ) ; break ; case Event . KEY : handleKeyEvent ( ( KeyEvent ) e ) ; break ; } } } protected void handleMouseEvent ( MouseEvent event ) { final int action = event . getAction ( ) ; if ( action == MouseEvent . DRAG || action == MouseEvent . MOVE || action == MouseEvent . PRESS ) { pmouseX = emouseX ; pmouseY = emouseY ; mouseX = event . getX ( ) ; mouseY = event . getY ( ) ; } mouseButton = event . getButton ( ) ; if ( firstMouse ) { pmouseX = mouseX ; pmouseY = mouseY ; dmouseX = mouseX ; dmouseY = mouseY ; firstMouse = false ; } mouseEvent = event ; switch ( action ) { case MouseEvent . PRESS : mousePressed = true ; break ; case MouseEvent . RELEASE : mousePressed = false ; break ; } handleMethods ( "mouseEvent" , new Object [ ] { event } ) ; switch ( action ) { case MouseEvent . PRESS : mousePressed ( event ) ; break ; case MouseEvent . RELEASE : mouseReleased ( event ) ; break ; case MouseEvent . CLICK : mouseClicked ( event ) ; break ; case MouseEvent . DRAG : mouseDragged ( event ) ; break ; case MouseEvent . MOVE : mouseMoved ( event ) ; break ; case MouseEvent . ENTER : mouseEntered ( event ) ; break ; case MouseEvent . EXIT : mouseExited ( event ) ; break ; case MouseEvent . WHEEL : mouseWheel ( event ) ; break ; } if ( ( action == MouseEvent . DRAG ) || ( action == MouseEvent . MOVE ) ) { emouseX = mouseX ; emouseY = mouseY ; } } public void mousePressed ( ) { } public void mousePressed ( MouseEvent event ) { mousePressed ( ) ; } public void mouseReleased ( ) { } public void mouseReleased ( MouseEvent event ) { mouseReleased ( ) ; } public void mouseClicked ( ) { } public void mouseClicked ( MouseEvent event ) { mouseClicked ( ) ; } public void mouseDragged ( ) { } public void mouseDragged ( MouseEvent event ) { mouseDragged ( ) ; } public void mouseMoved ( ) { } public void mouseMoved ( MouseEvent event ) { mouseMoved ( ) ; } public void mouseEntered ( ) { } public void mouseEntered ( MouseEvent event ) { mouseEntered ( ) ; } public void mouseExited ( ) { } public void mouseExited ( MouseEvent event ) { mouseExited ( ) ; } public void mouseWheel ( ) { } public void mouseWheel ( MouseEvent event ) { mouseWheel ( ) ; } protected void handleKeyEvent ( KeyEvent event ) { keyEvent = event ; key = event . getKey ( ) ; keyCode = event . getKeyCode ( ) ; switch ( event . getAction ( ) ) { case KeyEvent . PRESS : keyPressed = true ; keyPressed ( keyEvent ) ; break ; case KeyEvent . RELEASE : keyPressed = false ; keyReleased ( keyEvent ) ; break ; case KeyEvent . TYPE : keyTyped ( keyEvent ) ; break ; } handleMethods ( "keyEvent" , new Object [ ] { event } ) ; if ( event . getAction ( ) == KeyEvent . PRESS ) { if ( key == ESC ) { exit ( ) ; } if ( external && event . getKeyCode ( ) == 'W' && ( ( event . isMetaDown ( ) && platform == MACOSX ) || ( event . isControlDown ( ) && platform != MACOSX ) ) ) { exit ( ) ; } } } public void keyPressed ( ) { } public void keyPressed ( KeyEvent event ) { keyPressed ( ) ; } public void keyReleased ( ) { } public void keyReleased ( KeyEvent event ) { keyReleased ( ) ; } public void keyTyped ( ) { } public void keyTyped ( KeyEvent event ) { keyTyped ( ) ; } public void focusGained ( ) { } public void focusLost ( ) { } public int millis ( ) { return ( int ) ( System . currentTimeMillis ( ) - millisOffset ) ; } static public int second ( ) { return Calendar . getInstance ( ) . get ( Calendar . SECOND ) ; } static public int minute ( ) { return Calendar . getInstance ( ) . get ( Calendar . MINUTE ) ; } static public int hour ( ) { return Calendar . getInstance ( ) . get ( Calendar . HOUR_OF_DAY ) ; } static public int day ( ) { return Calendar . getInstance ( ) . get ( Calendar . DAY_OF_MONTH ) ; } static public int month ( ) { return Calendar . getInstance ( ) . get ( Calendar . MONTH ) + 1 ; } static public int year ( ) { return Calendar . getInstance ( ) . get ( Calendar . YEAR ) ; } public void delay ( int napTime ) { try { Thread . sleep ( napTime ) ; } catch ( InterruptedException e ) { } } public void frameRate ( float fps ) { surface . setFrameRate ( fps ) ; } public void link ( String url ) { try { if ( Desktop . isDesktopSupported ( ) ) { Desktop . getDesktop ( ) . browse ( new URI ( url ) ) ; } else { launch ( url ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } } static public void launch ( String filename ) { launch ( filename ) ; } static String openLauncher ; static public Process launch ( String ... args ) { String [ ] params = null ; if ( platform == WINDOWS ) { params = new String [ ] { "cmd" , "/c" } ; } else if ( platform == MACOSX ) { params = new String [ ] { "open" } ; } else if ( platform == LINUX ) { if ( openLauncher == null ) { try { Process p = Runtime . getRuntime ( ) . exec ( new String [ ] { "gnome-open" } ) ; p . waitFor ( ) ; openLauncher = "gnome-open" ; } catch ( Exception e ) { } } if ( openLauncher == null ) { try { Process p = Runtime . getRuntime ( ) . exec ( new String [ ] { "kde-open" } ) ; p . waitFor ( ) ; openLauncher = "kde-open" ; } catch ( Exception e ) { } } if ( openLauncher == null ) { System . err . println ( "Could not find gnome-open or kde-open, " + "the open() command may not work." ) ; } if ( openLauncher != null ) { params = new String [ ] { openLauncher } ; } } if ( params != null ) { if ( params [ 0 ] . equals ( args [ 0 ] ) ) { return exec ( args ) ; } else { params = concat ( params , args ) ; return exec ( params ) ; } } else { return exec ( args ) ; } } static public Process exec ( String ... args ) { try { return Runtime . getRuntime ( ) . exec ( args ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new RuntimeException ( "Could not open " + join ( args , ' ' ) ) ; } } public void die ( String what ) { dispose ( ) ; throw new RuntimeException ( what ) ; } public void die ( String what , Exception e ) { if ( e != null ) e . printStackTrace ( ) ; die ( what ) ; } public void exit ( ) { if ( surface . isStopped ( ) ) { exitActual ( ) ; } else if ( looping ) { finished = true ; exitCalled = true ; } else if ( ! looping ) { dispose ( ) ; exitActual ( ) ; } } public boolean exitCalled ( ) { return exitCalled ; } public void exitActual ( ) { try { System . exit ( 0 ) ; } catch ( SecurityException e ) { } } public void dispose ( ) { finished = true ; if ( surface . stopThread ( ) ) { if ( g != null ) { g . dispose ( ) ; } handleMethods ( "dispose" ) ; } } public void method ( String name ) { try { Method method = getClass ( ) . getMethod ( name , new Class [ ] { } ) ; method . invoke ( this , new Object [ ] { } ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . getTargetException ( ) . printStackTrace ( ) ; } catch ( NoSuchMethodException nsme ) { System . err . println ( "There is no public " + name + "() method " + "in the class " + getClass ( ) . getName ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void thread ( final String name ) { Thread later = new Thread ( ) { @ Override public void run ( ) { method ( name ) ; } } ; later . start ( ) ; } public void save ( String filename ) { g . save ( savePath ( filename ) ) ; } public void saveFrame ( ) { try { g . save ( savePath ( "screen-" + nf ( frameCount , 4 ) + ".tif" ) ) ; } catch ( SecurityException se ) { System . err . println ( "Can't use saveFrame() when running in a browser, " + "unless using a signed applet." ) ; } } public void saveFrame ( String filename ) { try { g . save ( savePath ( insertFrame ( filename ) ) ) ; } catch ( SecurityException se ) { System . err . println ( "Can't use saveFrame() when running in a browser, " + "unless using a signed applet." ) ; } } public String insertFrame ( String what ) { int first = what . indexOf ( '#' ) ; int last = what . lastIndexOf ( '#' ) ; if ( ( first != - 1 ) && ( last - first > 0 ) ) { String prefix = what . substring ( 0 , first ) ; int count = last - first + 1 ; String suffix = what . substring ( last + 1 ) ; return prefix + nf ( frameCount , count ) + suffix ; } return what ; } public void cursor ( int kind ) { surface . setCursor ( kind ) ; } public void cursor ( PImage img ) { cursor ( img , img . width / 2 , img . height / 2 ) ; } public void cursor ( PImage img , int x , int y ) { surface . setCursor ( img , x , y ) ; } public void cursor ( ) { surface . showCursor ( ) ; } public void noCursor ( ) { surface . hideCursor ( ) ; } static public void print ( byte what ) { System . out . print ( what ) ; System . out . flush ( ) ; } static public void print ( boolean what ) { System . out . print ( what ) ; System . out . flush ( ) ; } static public void print ( char what ) { System . out . print ( what ) ; System . out . flush ( ) ; } static public void print ( int what ) { System . out . print ( what ) ; System . out . flush ( ) ; } static public void print ( long what ) { System . out . print ( what ) ; System . out . flush ( ) ; } static public void print ( float what ) { System . out . print ( what ) ; System . out . flush ( ) ; } static public void print ( double what ) { System . out . print ( what ) ; System . out . flush ( ) ; } static public void print ( String what ) { System . out . print ( what ) ; System . out . flush ( ) ; } static public void print ( Object ... variables ) { StringBuilder sb = new StringBuilder ( ) ; for ( Object o : variables ) { if ( sb . length ( ) != 0 ) { sb . append ( " " ) ; } if ( o == null ) { sb . append ( "null" ) ; } else { sb . append ( o . toString ( ) ) ; } } System . out . print ( sb . toString ( ) ) ; } static public void println ( ) { System . out . println ( ) ; } static public void println ( byte what ) { System . out . println ( what ) ; System . out . flush ( ) ; } static public void println ( boolean what ) { System . out . println ( what ) ; System . out . flush ( ) ; } static public void println ( char what ) { System . out . println ( what ) ; System . out . flush ( ) ; } static public void println ( int what ) { System . out . println ( what ) ; System . out . flush ( ) ; } static public void println ( long what ) { System . out . println ( what ) ; System . out . flush ( ) ; } static public void println ( float what ) { System . out . println ( what ) ; System . out . flush ( ) ; } static public void println ( double what ) { System . out . println ( what ) ; System . out . flush ( ) ; } static public void println ( String what ) { System . out . println ( what ) ; System . out . flush ( ) ; } static public void println ( Object ... variables ) { print ( variables ) ; println ( ) ; } static public void println ( Object what ) { if ( what == null ) { System . out . println ( "null" ) ; } else if ( what . getClass ( ) . isArray ( ) ) { printArray ( what ) ; } else { System . out . println ( what . toString ( ) ) ; System . out . flush ( ) ; } } static public void printArray ( Object what ) { if ( what == null ) { System . out . println ( "null" ) ; } else { String name = what . getClass ( ) . getName ( ) ; if ( name . charAt ( 0 ) == '[' ) { switch ( name . charAt ( 1 ) ) { case '[' : System . out . println ( what ) ; break ; case 'L' : Object poo [ ] = ( Object [ ] ) what ; for ( int i = 0 ; i < poo . length ; i ++ ) { if ( poo [ i ] instanceof String ) { System . out . println ( "[" + i + "] \"" + poo [ i ] + "\"" ) ; } else { System . out . println ( "[" + i + "] " + poo [ i ] ) ; } } break ; case 'Z' : boolean zz [ ] = ( boolean [ ] ) what ; for ( int i = 0 ; i < zz . length ; i ++ ) { System . out . println ( "[" + i + "] " + zz [ i ] ) ; } break ; case 'B' : byte bb [ ] = ( byte [ ] ) what ; for ( int i = 0 ; i < bb . length ; i ++ ) { System . out . println ( "[" + i + "] " + bb [ i ] ) ; } break ; case 'C' : char cc [ ] = ( char [ ] ) what ; for ( int i = 0 ; i < cc . length ; i ++ ) { System . out . println ( "[" + i + "] '" + cc [ i ] + "'" ) ; } break ; case 'I' : int ii [ ] = ( int [ ] ) what ; for ( int i = 0 ; i < ii . length ; i ++ ) { System . out . println ( "[" + i + "] " + ii [ i ] ) ; } break ; case 'J' : long jj [ ] = ( long [ ] ) what ; for ( int i = 0 ; i < jj . length ; i ++ ) { System . out . println ( "[" + i + "] " + jj [ i ] ) ; } break ; case 'F' : float ff [ ] = ( float [ ] ) what ; for ( int i = 0 ; i < ff . length ; i ++ ) { System . out . println ( "[" + i + "] " + ff [ i ] ) ; } break ; case 'D' : double dd [ ] = ( double [ ] ) what ; for ( int i = 0 ; i < dd . length ; i ++ ) { System . out . println ( "[" + i + "] " + dd [ i ] ) ; } break ; default : System . out . println ( what ) ; } } else { System . out . println ( what ) ; } } System . out . flush ( ) ; } static public void debug ( String msg ) { if ( DEBUG ) println ( msg ) ; } static public final float abs ( float n ) { return ( n < 0 ) ? - n : n ; } static public final int abs ( int n ) { return ( n < 0 ) ? - n : n ; } static public final float sq ( float n ) { return n * n ; } static public final float sqrt ( float n ) { return ( float ) Math . sqrt ( n ) ; } static public final float log ( float n ) { return ( float ) Math . log ( n ) ; } static public final float exp ( float n ) { return ( float ) Math . exp ( n ) ; } static public final float pow ( float n , float e ) { return ( float ) Math . pow ( n , e ) ; } static public final int max ( int a , int b ) { return ( a > b ) ? a : b ; } static public final float max ( float a , float b ) { return ( a > b ) ? a : b ; } static public final int max ( int a , int b , int c ) { return ( a > b ) ? ( ( a > c ) ? a : c ) : ( ( b > c ) ? b : c ) ; } static public final float max ( float a , float b , float c ) { return ( a > b ) ? ( ( a > c ) ? a : c ) : ( ( b > c ) ? b : c ) ; } static public final int max ( int [ ] list ) { if ( list . length == 0 ) { throw new ArrayIndexOutOfBoundsException ( ERROR_MIN_MAX ) ; } int max = list [ 0 ] ; for ( int i = 1 ; i < list . length ; i ++ ) { if ( list [ i ] > max ) max = list [ i ] ; } return max ; } static public final float max ( float [ ] list ) { if ( list . length == 0 ) { throw new ArrayIndexOutOfBoundsException ( ERROR_MIN_MAX ) ; } float max = list [ 0 ] ; for ( int i = 1 ; i < list . length ; i ++ ) { if ( list [ i ] > max ) max = list [ i ] ; } return max ; } static public final int min ( int a , int b ) { return ( a < b ) ? a : b ; } static public final float min ( float a , float b ) { return ( a < b ) ? a : b ; } static public final int min ( int a , int b , int c ) { return ( a < b ) ? ( ( a < c ) ? a : c ) : ( ( b < c ) ? b : c ) ; } static public final float min ( float a , float b , float c ) { return ( a < b ) ? ( ( a < c ) ? a : c ) : ( ( b < c ) ? b : c ) ; } static public final int min ( int [ ] list ) { if ( list . length == 0 ) { throw new ArrayIndexOutOfBoundsException ( ERROR_MIN_MAX ) ; } int min = list [ 0 ] ; for ( int i = 1 ; i < list . length ; i ++ ) { if ( list [ i ] < min ) min = list [ i ] ; } return min ; } static public final float min ( float [ ] list ) { if ( list . length == 0 ) { throw new ArrayIndexOutOfBoundsException ( ERROR_MIN_MAX ) ; } float min = list [ 0 ] ; for ( int i = 1 ; i < list . length ; i ++ ) { if ( list [ i ] < min ) min = list [ i ] ; } return min ; } static public final int constrain ( int amt , int low , int high ) { return ( amt < low ) ? low : ( ( amt > high ) ? high : amt ) ; } static public final float constrain ( float amt , float low , float high ) { return ( amt < low ) ? low : ( ( amt > high ) ? high : amt ) ; } static public final float sin ( float angle ) { return ( float ) Math . sin ( angle ) ; } static public final float cos ( float angle ) { return ( float ) Math . cos ( angle ) ; } static public final float tan ( float angle ) { return ( float ) Math . tan ( angle ) ; } static public final float asin ( float value ) { return ( float ) Math . asin ( value ) ; } static public final float acos ( float value ) { return ( float ) Math . acos ( value ) ; } static public final float atan ( float value ) { return ( float ) Math . atan ( value ) ; } static public final float atan2 ( float y , float x ) { return ( float ) Math . atan2 ( y , x ) ; } static public final float degrees ( float radians ) { return radians * RAD_TO_DEG ; } static public final float radians ( float degrees ) { return degrees * DEG_TO_RAD ; } static public final int ceil ( float n ) { return ( int ) Math . ceil ( n ) ; } static public final int floor ( float n ) { return ( int ) Math . floor ( n ) ; } static public final int round ( float n ) { return Math . round ( n ) ; } static public final float mag ( float a , float b ) { return ( float ) Math . sqrt ( a * a + b * b ) ; } static public final float mag ( float a , float b , float c ) { return ( float ) Math . sqrt ( a * a + b * b + c * c ) ; } static public final float dist ( float x1 , float y1 , float x2 , float y2 ) { return sqrt ( sq ( x2 - x1 ) + sq ( y2 - y1 ) ) ; } static public final float dist ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { return sqrt ( sq ( x2 - x1 ) + sq ( y2 - y1 ) + sq ( z2 - z1 ) ) ; } static public final float lerp ( float start , float stop , float amt ) { return start + ( stop - start ) * amt ; } static public final float norm ( float value , float start , float stop ) { return ( value - start ) / ( stop - start ) ; } static public final float map ( float value , float start1 , float stop1 , float start2 , float stop2 ) { return start2 + ( stop2 - start2 ) * ( ( value - start1 ) / ( stop1 - start1 ) ) ; } Random internalRandom ; public final float random ( float high ) { if ( high == 0 || high != high ) { return 0 ; } if ( internalRandom == null ) { internalRandom = new Random ( ) ; } float value = 0 ; do { value = internalRandom . nextFloat ( ) * high ; } while ( value == high ) ; return value ; } public final float randomGaussian ( ) { if ( internalRandom == null ) { internalRandom = new Random ( ) ; } return ( float ) internalRandom . nextGaussian ( ) ; } public final float random ( float low , float high ) { if ( low >= high ) return low ; float diff = high - low ; return random ( diff ) + low ; } public final void randomSeed ( long seed ) { if ( internalRandom == null ) { internalRandom = new Random ( ) ; } internalRandom . setSeed ( seed ) ; } static final int PERLIN_YWRAPB = 4 ; static final int PERLIN_YWRAP = 1 < < PERLIN_YWRAPB ; static final int PERLIN_ZWRAPB = 8 ; static final int PERLIN_ZWRAP = 1 < < PERLIN_ZWRAPB ; static final int PERLIN_SIZE = 4095 ; int perlin_octaves = 4 ; float perlin_amp_falloff = 0.5f ; int perlin_TWOPI , perlin_PI ; float [ ] perlin_cosTable ; float [ ] perlin ; Random perlinRandom ; public float noise ( float x ) { return noise ( x , 0f , 0f ) ; } public float noise ( float x , float y ) { return noise ( x , y , 0f ) ; } public float noise ( float x , float y , float z ) { if ( perlin == null ) { if ( perlinRandom == null ) { perlinRandom = new Random ( ) ; } perlin = new float [ PERLIN_SIZE + 1 ] ; for ( int i = 0 ; i < PERLIN_SIZE + 1 ; i ++ ) { perlin [ i ] = perlinRandom . nextFloat ( ) ; } perlin_cosTable = PGraphics . cosLUT ; perlin_TWOPI = perlin_PI = PGraphics . SINCOS_LENGTH ; perlin_PI >>= 1 ; } if ( x < 0 ) x = - x ; if ( y < 0 ) y = - y ; if ( z < 0 ) z = - z ; int xi = ( int ) x , yi = ( int ) y , zi = ( int ) z ; float xf = x - xi ; float yf = y - yi ; float zf = z - zi ; float rxf , ryf ; float r = 0 ; float ampl = 0.5f ; float n1 , n2 , n3 ; for ( int i = 0 ; i < perlin_octaves ; i ++ ) { int of = xi + ( yi < < PERLIN_YWRAPB ) + ( zi < < PERLIN_ZWRAPB ) ; rxf = noise_fsc ( xf ) ; ryf = noise_fsc ( yf ) ; n1 = perlin [ of & PERLIN_SIZE ] ; n1 += rxf * ( perlin [ ( of + 1 ) & PERLIN_SIZE ] - n1 ) ; n2 = perlin [ ( of + PERLIN_YWRAP ) & PERLIN_SIZE ] ; n2 += rxf * ( perlin [ ( of + PERLIN_YWRAP + 1 ) & PERLIN_SIZE ] - n2 ) ; n1 += ryf * ( n2 - n1 ) ; of += PERLIN_ZWRAP ; n2 = perlin [ of & PERLIN_SIZE ] ; n2 += rxf * ( perlin [ ( of + 1 ) & PERLIN_SIZE ] - n2 ) ; n3 = perlin [ ( of + PERLIN_YWRAP ) & PERLIN_SIZE ] ; n3 += rxf * ( perlin [ ( of + PERLIN_YWRAP + 1 ) & PERLIN_SIZE ] - n3 ) ; n2 += ryf * ( n3 - n2 ) ; n1 += noise_fsc ( zf ) * ( n2 - n1 ) ; r += n1 * ampl ; ampl *= perlin_amp_falloff ; xi <<= 1 ; xf *= 2 ; yi <<= 1 ; yf *= 2 ; zi <<= 1 ; zf *= 2 ; if ( xf >= 1.0f ) { xi ++ ; xf -- ; } if ( yf >= 1.0f ) { yi ++ ; yf -- ; } if ( zf >= 1.0f ) { zi ++ ; zf -- ; } } return r ; } private float noise_fsc ( float i ) { return 0.5f * ( 1.0f - perlin_cosTable [ ( int ) ( i * perlin_PI ) % perlin_TWOPI ] ) ; } public void noiseDetail ( int lod ) { if ( lod > 0 ) perlin_octaves = lod ; } public void noiseDetail ( int lod , float falloff ) { if ( lod > 0 ) perlin_octaves = lod ; if ( falloff > 0 ) perlin_amp_falloff = falloff ; } public void noiseSeed ( long seed ) { if ( perlinRandom == null ) perlinRandom = new Random ( ) ; perlinRandom . setSeed ( seed ) ; perlin = null ; } protected String [ ] loadImageFormats ; public PImage loadImage ( String filename ) { return loadImage ( filename , null ) ; } public PImage loadImage ( String filename , String extension ) { if ( extension == null ) { String lower = filename . toLowerCase ( ) ; int dot = filename . lastIndexOf ( '.' ) ; if ( dot == - 1 ) { extension = "unknown" ; } extension = lower . substring ( dot + 1 ) ; int question = extension . indexOf ( '?' ) ; if ( question != - 1 ) { extension = extension . substring ( 0 , question ) ; } } extension = extension . toLowerCase ( ) ; if ( extension . equals ( "tga" ) ) { try { PImage image = loadImageTGA ( filename ) ; return image ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } } if ( extension . equals ( "tif" ) || extension . equals ( "tiff" ) ) { byte bytes [ ] = loadBytes ( filename ) ; PImage image = ( bytes == null ) ? null : PImage . loadTIFF ( bytes ) ; return image ; } try { if ( extension . equals ( "jpg" ) || extension . equals ( "jpeg" ) || extension . equals ( "gif" ) || extension . equals ( "png" ) || extension . equals ( "unknown" ) ) { byte bytes [ ] = loadBytes ( filename ) ; if ( bytes == null ) { return null ; } else { Image awtImage = new ImageIcon ( bytes ) . getImage ( ) ; if ( awtImage instanceof BufferedImage ) { BufferedImage buffImage = ( BufferedImage ) awtImage ; int space = buffImage . getColorModel ( ) . getColorSpace ( ) . getType ( ) ; if ( space == ColorSpace . TYPE_CMYK ) { System . err . println ( filename + " is a CMYK image, " + "only RGB images are supported." ) ; return null ; } } PImage image = new PImage ( awtImage ) ; if ( image . width == - 1 ) { System . err . println ( "The file " + filename + " contains bad image data, or may not be an image." ) ; } if ( extension . equals ( "gif" ) || extension . equals ( "png" ) ) { image . checkAlpha ( ) ; } return image ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } if ( loadImageFormats == null ) { loadImageFormats = ImageIO . getReaderFormatNames ( ) ; } if ( loadImageFormats != null ) { for ( int i = 0 ; i < loadImageFormats . length ; i ++ ) { if ( extension . equals ( loadImageFormats [ i ] ) ) { return loadImageIO ( filename ) ; } } } System . err . println ( "Could not find a method to load " + filename ) ; return null ; } public PImage requestImage ( String filename ) { return requestImage ( filename , null ) ; } public PImage requestImage ( String filename , String extension ) { PImage vessel = createImage ( 0 , 0 , ARGB ) ; AsyncImageLoader ail = new AsyncImageLoader ( filename , extension , vessel ) ; ail . start ( ) ; return vessel ; } public int requestImageMax = 4 ; volatile int requestImageCount ; class AsyncImageLoader extends Thread { String filename ; String extension ; PImage vessel ; public AsyncImageLoader ( String filename , String extension , PImage vessel ) { this . filename = filename ; this . extension = extension ; this . vessel = vessel ; } @ Override public void run ( ) { while ( requestImageCount == requestImageMax ) { try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { } } requestImageCount ++ ; PImage actual = loadImage ( filename , extension ) ; if ( actual == null ) { vessel . width = - 1 ; vessel . height = - 1 ; } else { vessel . width = actual . width ; vessel . height = actual . height ; vessel . format = actual . format ; vessel . pixels = actual . pixels ; vessel . pixelWidth = actual . width ; vessel . pixelHeight = actual . height ; vessel . pixelDensity = 1 ; } requestImageCount -- ; } } protected PImage loadImageIO ( String filename ) { InputStream stream = createInput ( filename ) ; if ( stream == null ) { System . err . println ( "The image " + filename + " could not be found." ) ; return null ; } try { BufferedImage bi = ImageIO . read ( stream ) ; PImage outgoing = new PImage ( bi . getWidth ( ) , bi . getHeight ( ) ) ; outgoing . parent = this ; bi . getRGB ( 0 , 0 , outgoing . width , outgoing . height , outgoing . pixels , 0 , outgoing . width ) ; outgoing . checkAlpha ( ) ; stream . close ( ) ; return outgoing ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } } protected PImage loadImageTGA ( String filename ) throws IOException { InputStream is = createInput ( filename ) ; if ( is == null ) return null ; byte header [ ] = new byte [ 18 ] ; int offset = 0 ; do { int count = is . read ( header , offset , header . length - offset ) ; if ( count == - 1 ) return null ; offset += count ; } while ( offset < 18 ) ; int format = 0 ; if ( ( ( header [ 2 ] == 3 ) || ( header [ 2 ] == 11 ) ) && ( header [ 16 ] == 8 ) && ( ( header [ 17 ] == 0x8 ) || ( header [ 17 ] == 0x28 ) ) ) { format = ALPHA ; } else if ( ( ( header [ 2 ] == 2 ) || ( header [ 2 ] == 10 ) ) && ( header [ 16 ] == 24 ) && ( ( header [ 17 ] == 0x20 ) || ( header [ 17 ] == 0 ) ) ) { format = RGB ; } else if ( ( ( header [ 2 ] == 2 ) || ( header [ 2 ] == 10 ) ) && ( header [ 16 ] == 32 ) && ( ( header [ 17 ] == 0x8 ) || ( header [ 17 ] == 0x28 ) ) ) { format = ARGB ; } if ( format == 0 ) { System . err . println ( "Unknown .tga file format for " + filename ) ; return null ; } int w = ( ( header [ 13 ] & 0xff ) < < 8 ) + ( header [ 12 ] & 0xff ) ; int h = ( ( header [ 15 ] & 0xff ) < < 8 ) + ( header [ 14 ] & 0xff ) ; PImage outgoing = createImage ( w , h , format ) ; boolean reversed = ( header [ 17 ] & 0x20 ) == 0 ; if ( ( header [ 2 ] == 2 ) || ( header [ 2 ] == 3 ) ) { if ( reversed ) { int index = ( h - 1 ) * w ; switch ( format ) { case ALPHA : for ( int y = h - 1 ; y >= 0 ; y -- ) { for ( int x = 0 ; x < w ; x ++ ) { outgoing . pixels [ index + x ] = is . read ( ) ; } index -= w ; } break ; case RGB : for ( int y = h - 1 ; y >= 0 ; y -- ) { for ( int x = 0 ; x < w ; x ++ ) { outgoing . pixels [ index + x ] = is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) | 0xff000000 ; } index -= w ; } break ; case ARGB : for ( int y = h - 1 ; y >= 0 ; y -- ) { for ( int x = 0 ; x < w ; x ++ ) { outgoing . pixels [ index + x ] = is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) | ( is . read ( ) < < 24 ) ; } index -= w ; } } } else { int count = w * h ; switch ( format ) { case ALPHA : for ( int i = 0 ; i < count ; i ++ ) { outgoing . pixels [ i ] = is . read ( ) ; } break ; case RGB : for ( int i = 0 ; i < count ; i ++ ) { outgoing . pixels [ i ] = is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) | 0xff000000 ; } break ; case ARGB : for ( int i = 0 ; i < count ; i ++ ) { outgoing . pixels [ i ] = is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) | ( is . read ( ) < < 24 ) ; } break ; } } } else { int index = 0 ; int px [ ] = outgoing . pixels ; while ( index < px . length ) { int num = is . read ( ) ; boolean isRLE = ( num & 0x80 ) != 0 ; if ( isRLE ) { num -= 127 ; int pixel = 0 ; switch ( format ) { case ALPHA : pixel = is . read ( ) ; break ; case RGB : pixel = 0xFF000000 | is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) ; break ; case ARGB : pixel = is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) | ( is . read ( ) < < 24 ) ; break ; } for ( int i = 0 ; i < num ; i ++ ) { px [ index ++ ] = pixel ; if ( index == px . length ) break ; } } else { num += 1 ; switch ( format ) { case ALPHA : for ( int i = 0 ; i < num ; i ++ ) { px [ index ++ ] = is . read ( ) ; } break ; case RGB : for ( int i = 0 ; i < num ; i ++ ) { px [ index ++ ] = 0xFF000000 | is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) ; } break ; case ARGB : for ( int i = 0 ; i < num ; i ++ ) { px [ index ++ ] = is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) | ( is . read ( ) < < 24 ) ; } break ; } } } if ( ! reversed ) { int [ ] temp = new int [ w ] ; for ( int y = 0 ; y < h / 2 ; y ++ ) { int z = ( h - 1 ) - y ; System . arraycopy ( px , y * w , temp , 0 , w ) ; System . arraycopy ( px , z * w , px , y * w , w ) ; System . arraycopy ( temp , 0 , px , z * w , w ) ; } } } is . close ( ) ; return outgoing ; } public XML loadXML ( String filename ) { return loadXML ( filename , null ) ; } public XML loadXML ( String filename , String options ) { try { return new XML ( createReader ( filename ) , options ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } catch ( ParserConfigurationException e ) { throw new RuntimeException ( e ) ; } catch ( SAXException e ) { throw new RuntimeException ( e ) ; } } public XML parseXML ( String xmlString ) { return parseXML ( xmlString , null ) ; } public XML parseXML ( String xmlString , String options ) { try { return XML . parse ( xmlString , options ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public boolean saveXML ( XML xml , String filename ) { return saveXML ( xml , filename , null ) ; } public boolean saveXML ( XML xml , String filename , String options ) { return xml . save ( saveFile ( filename ) , options ) ; } public JSONObject parseJSONObject ( String input ) { return new JSONObject ( new StringReader ( input ) ) ; } public JSONObject loadJSONObject ( String filename ) { return new JSONObject ( createReader ( filename ) ) ; } static public JSONObject loadJSONObject ( File file ) { return new JSONObject ( createReader ( file ) ) ; } public boolean saveJSONObject ( JSONObject json , String filename ) { return saveJSONObject ( json , filename , null ) ; } public boolean saveJSONObject ( JSONObject json , String filename , String options ) { return json . save ( saveFile ( filename ) , options ) ; } public JSONArray parseJSONArray ( String input ) { return new JSONArray ( new StringReader ( input ) ) ; } public JSONArray loadJSONArray ( String filename ) { return new JSONArray ( createReader ( filename ) ) ; } static public JSONArray loadJSONArray ( File file ) { return new JSONArray ( createReader ( file ) ) ; } public boolean saveJSONArray ( JSONArray json , String filename ) { return saveJSONArray ( json , filename , null ) ; } public boolean saveJSONArray ( JSONArray json , String filename , String options ) { return json . save ( saveFile ( filename ) , options ) ; } public Table loadTable ( String filename ) { return loadTable ( filename , null ) ; } public Table loadTable ( String filename , String options ) { try { String optionStr = Table . extensionOptions ( true , filename , options ) ; String [ ] optionList = trim ( split ( optionStr , ',' ) ) ; Table dictionary = null ; for ( String opt : optionList ) { if ( opt . startsWith ( "dictionary=" ) ) { dictionary = loadTable ( opt . substring ( opt . indexOf ( '=' ) + 1 ) , "tsv" ) ; return dictionary . typedParse ( createInput ( filename ) , optionStr ) ; } } InputStream input = createInput ( filename ) ; if ( input == null ) { System . err . println ( filename + " does not exist or could not be read" ) ; return null ; } return new Table ( input , optionStr ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } } public boolean saveTable ( Table table , String filename ) { return saveTable ( table , filename , null ) ; } public boolean saveTable ( Table table , String filename , String options ) { try { File outputFile = saveFile ( filename ) ; return table . save ( outputFile , options ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return false ; } } public PFont loadFont ( String filename ) { if ( ! filename . toLowerCase ( ) . endsWith ( ".vlw" ) ) { throw new IllegalArgumentException ( "loadFont() is for .vlw files, try createFont()" ) ; } try { InputStream input = createInput ( filename ) ; return new PFont ( input ) ; } catch ( Exception e ) { die ( "Could not load font " + filename + ". " + "Make sure that the font has been copied " + "to the data folder of your sketch." , e ) ; } return null ; } protected PFont createDefaultFont ( float size ) { return createFont ( "Lucida Sans" , size , true , null ) ; } public PFont createFont ( String name , float size ) { return createFont ( name , size , true , null ) ; } public PFont createFont ( String name , float size , boolean smooth ) { return createFont ( name , size , smooth , null ) ; } public PFont createFont ( String name , float size , boolean smooth , char [ ] charset ) { String lowerName = name . toLowerCase ( ) ; Font baseFont = null ; try { InputStream stream = null ; if ( lowerName . endsWith ( ".otf" ) || lowerName . endsWith ( ".ttf" ) ) { stream = createInput ( name ) ; if ( stream == null ) { System . err . println ( "The font \"" + name + "\" " + "is missing or inaccessible, make sure " + "the URL is valid or that the file has been " + "added to your sketch and is readable." ) ; return null ; } baseFont = Font . createFont ( Font . TRUETYPE_FONT , createInput ( name ) ) ; } else { baseFont = PFont . findFont ( name ) ; } return new PFont ( baseFont . deriveFont ( size * pixelDensity ) , smooth , charset , stream != null , pixelDensity ) ; } catch ( Exception e ) { System . err . println ( "Problem with createFont(\"" + name + "\")" ) ; e . printStackTrace ( ) ; return null ; } } public void selectInput ( String prompt , String callback ) { selectInput ( prompt , callback , null ) ; } public void selectInput ( String prompt , String callback , File file ) { selectInput ( prompt , callback , file , this ) ; } public void selectInput ( String prompt , String callback , File file , Object callbackObject ) { selectInput ( prompt , callback , file , callbackObject , null ) ; } static public void selectInput ( String prompt , String callbackMethod , File file , Object callbackObject , Frame parent ) { selectImpl ( prompt , callbackMethod , file , callbackObject , parent , FileDialog . LOAD ) ; } public void selectOutput ( String prompt , String callback ) { selectOutput ( prompt , callback , null ) ; } public void selectOutput ( String prompt , String callback , File file ) { selectOutput ( prompt , callback , file , this ) ; } public void selectOutput ( String prompt , String callback , File file , Object callbackObject ) { selectOutput ( prompt , callback , file , callbackObject , null ) ; } static public void selectOutput ( String prompt , String callbackMethod , File file , Object callbackObject , Frame parent ) { selectImpl ( prompt , callbackMethod , file , callbackObject , parent , FileDialog . SAVE ) ; } static protected void selectImpl ( final String prompt , final String callbackMethod , final File defaultSelection , final Object callbackObject , final Frame parentFrame , final int mode ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { File selectedFile = null ; if ( useNativeSelect ) { FileDialog dialog = new FileDialog ( parentFrame , prompt , mode ) ; if ( defaultSelection != null ) { dialog . setDirectory ( defaultSelection . getParent ( ) ) ; dialog . setFile ( defaultSelection . getName ( ) ) ; } dialog . setVisible ( true ) ; String directory = dialog . getDirectory ( ) ; String filename = dialog . getFile ( ) ; if ( filename != null ) { selectedFile = new File ( directory , filename ) ; } } else { JFileChooser chooser = new JFileChooser ( ) ; chooser . setDialogTitle ( prompt ) ; if ( defaultSelection != null ) { chooser . setSelectedFile ( defaultSelection ) ; } int result = - 1 ; if ( mode == FileDialog . SAVE ) { result = chooser . showSaveDialog ( parentFrame ) ; } else if ( mode == FileDialog . LOAD ) { result = chooser . showOpenDialog ( parentFrame ) ; } if ( result == JFileChooser . APPROVE_OPTION ) { selectedFile = chooser . getSelectedFile ( ) ; } } selectCallback ( selectedFile , callbackMethod , callbackObject ) ; } } ) ; } public void selectFolder ( String prompt , String callback ) { selectFolder ( prompt , callback , null ) ; } public void selectFolder ( String prompt , String callback , File file ) { selectFolder ( prompt , callback , file , this ) ; } public void selectFolder ( String prompt , String callback , File file , Object callbackObject ) { selectFolder ( prompt , callback , file , callbackObject , null ) ; } static public void selectFolder ( final String prompt , final String callbackMethod , final File defaultSelection , final Object callbackObject , final Frame parentFrame ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { File selectedFile = null ; if ( platform == MACOSX && useNativeSelect != false ) { FileDialog fileDialog = new FileDialog ( parentFrame , prompt , FileDialog . LOAD ) ; System . setProperty ( "apple.awt.fileDialogForDirectories" , "true" ) ; fileDialog . setVisible ( true ) ; System . setProperty ( "apple.awt.fileDialogForDirectories" , "false" ) ; String filename = fileDialog . getFile ( ) ; if ( filename != null ) { selectedFile = new File ( fileDialog . getDirectory ( ) , fileDialog . getFile ( ) ) ; } } else { JFileChooser fileChooser = new JFileChooser ( ) ; fileChooser . setDialogTitle ( prompt ) ; fileChooser . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; if ( defaultSelection != null ) { fileChooser . setSelectedFile ( defaultSelection ) ; } int result = fileChooser . showOpenDialog ( parentFrame ) ; if ( result == JFileChooser . APPROVE_OPTION ) { selectedFile = fileChooser . getSelectedFile ( ) ; } } selectCallback ( selectedFile , callbackMethod , callbackObject ) ; } } ) ; } static private void selectCallback ( File selectedFile , String callbackMethod , Object callbackObject ) { try { Class < ? > callbackClass = callbackObject . getClass ( ) ; Method selectMethod = callbackClass . getMethod ( callbackMethod , new Class [ ] { File . class } ) ; selectMethod . invoke ( callbackObject , new Object [ ] { selectedFile } ) ; } catch ( IllegalAccessException iae ) { System . err . println ( callbackMethod + "() must be public" ) ; } catch ( InvocationTargetException ite ) { ite . printStackTrace ( ) ; } catch ( NoSuchMethodException nsme ) { System . err . println ( callbackMethod + "() could not be found" ) ; } } static public String checkExtension ( String filename ) { if ( filename . toLowerCase ( ) . endsWith ( ".gz" ) ) { filename = filename . substring ( 0 , filename . length ( ) - 3 ) ; } int dotIndex = filename . lastIndexOf ( '.' ) ; if ( dotIndex != - 1 ) { return filename . substring ( dotIndex + 1 ) . toLowerCase ( ) ; } return null ; } public BufferedReader createReader ( String filename ) { InputStream is = createInput ( filename ) ; if ( is == null ) { System . err . println ( filename + " does not exist or could not be read" ) ; return null ; } return createReader ( is ) ; } static public BufferedReader createReader ( File file ) { try { InputStream is = new FileInputStream ( file ) ; if ( file . getName ( ) . toLowerCase ( ) . endsWith ( ".gz" ) ) { is = new GZIPInputStream ( is ) ; } return createReader ( is ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } static public BufferedReader createReader ( InputStream input ) { InputStreamReader isr = null ; try { isr = new InputStreamReader ( input , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { } return new BufferedReader ( isr ) ; } public PrintWriter createWriter ( String filename ) { return createWriter ( saveFile ( filename ) ) ; } static public PrintWriter createWriter ( File file ) { if ( file == null ) { throw new RuntimeException ( "File passed to createWriter() was null" ) ; } try { createPath ( file ) ; OutputStream output = new FileOutputStream ( file ) ; if ( file . getName ( ) . toLowerCase ( ) . endsWith ( ".gz" ) ) { output = new GZIPOutputStream ( output ) ; } return createWriter ( output ) ; } catch ( Exception e ) { throw new RuntimeException ( "Couldn't create a writer for " + file . getAbsolutePath ( ) , e ) ; } } static public PrintWriter createWriter ( OutputStream output ) { try { BufferedOutputStream bos = new BufferedOutputStream ( output , 8192 ) ; OutputStreamWriter osw = new OutputStreamWriter ( bos , "UTF-8" ) ; return new PrintWriter ( osw ) ; } catch ( UnsupportedEncodingException e ) { } return null ; } public InputStream createInput ( String filename ) { InputStream input = createInputRaw ( filename ) ; final String lower = filename . toLowerCase ( ) ; if ( ( input != null ) && ( lower . endsWith ( ".gz" ) || lower . endsWith ( ".svgz" ) ) ) { try { return new GZIPInputStream ( input ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } } return input ; } public InputStream createInputRaw ( String filename ) { if ( filename == null ) return null ; if ( filename . length ( ) == 0 ) { return null ; } if ( filename . contains ( ":" ) ) { try { URL url = new URL ( filename ) ; URLConnection conn = url . openConnection ( ) ; HttpURLConnection httpConn = ( HttpURLConnection ) conn ; httpConn . setInstanceFollowRedirects ( true ) ; int response = httpConn . getResponseCode ( ) ; if ( response >= 300 && response < 400 ) { String newLocation = httpConn . getHeaderField ( "Location" ) ; return createInputRaw ( newLocation ) ; } return conn . getInputStream ( ) ; } catch ( MalformedURLException mfue ) { } catch ( FileNotFoundException fnfe ) { } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } } InputStream stream = null ; try { File file = new File ( dataPath ( filename ) ) ; if ( ! file . exists ( ) ) { file = sketchFile ( filename ) ; } if ( file . isDirectory ( ) ) { return null ; } if ( file . exists ( ) ) { try { String filePath = file . getCanonicalPath ( ) ; String filenameActual = new File ( filePath ) . getName ( ) ; String filenameShort = new File ( filename ) . getName ( ) ; if ( ! filenameActual . equals ( filenameShort ) ) { throw new RuntimeException ( "This file is named " + filenameActual + " not " + filename + ". Rename the file " + "or change your code." ) ; } } catch ( IOException e ) { } } stream = new FileInputStream ( file ) ; if ( stream != null ) return stream ; } catch ( IOException ioe ) { } catch ( SecurityException se ) { } ClassLoader cl = getClass ( ) . getClassLoader ( ) ; stream = cl . getResourceAsStream ( "data/" + filename ) ; if ( stream != null ) { String cn = stream . getClass ( ) . getName ( ) ; if ( ! cn . equals ( "sun.plugin.cache.EmptyInputStream" ) ) { return stream ; } } stream = cl . getResourceAsStream ( filename ) ; if ( stream != null ) { String cn = stream . getClass ( ) . getName ( ) ; if ( ! cn . equals ( "sun.plugin.cache.EmptyInputStream" ) ) { return stream ; } } try { try { try { stream = new FileInputStream ( dataPath ( filename ) ) ; if ( stream != null ) return stream ; } catch ( IOException e2 ) { } try { stream = new FileInputStream ( sketchPath ( filename ) ) ; if ( stream != null ) return stream ; } catch ( Exception e ) { } try { stream = new FileInputStream ( filename ) ; if ( stream != null ) return stream ; } catch ( IOException e1 ) { } } catch ( SecurityException se ) { } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } static public InputStream createInput ( File file ) { if ( file == null ) { throw new IllegalArgumentException ( "File passed to createInput() was null" ) ; } try { InputStream input = new FileInputStream ( file ) ; if ( file . getName ( ) . toLowerCase ( ) . endsWith ( ".gz" ) ) { return new GZIPInputStream ( input ) ; } return input ; } catch ( IOException e ) { System . err . println ( "Could not createInput() for " + file ) ; e . printStackTrace ( ) ; return null ; } } public byte [ ] loadBytes ( String filename ) { InputStream is = createInput ( filename ) ; if ( is != null ) { byte [ ] outgoing = loadBytes ( is ) ; try { is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return outgoing ; } System . err . println ( "The file \"" + filename + "\" " + "is missing or inaccessible, make sure " + "the URL is valid or that the file has been " + "added to your sketch and is readable." ) ; return null ; } static public byte [ ] loadBytes ( InputStream input ) { try { BufferedInputStream bis = new BufferedInputStream ( input ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; int c = bis . read ( ) ; while ( c != - 1 ) { out . write ( c ) ; c = bis . read ( ) ; } return out . toByteArray ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; } static public byte [ ] loadBytes ( File file ) { InputStream is = createInput ( file ) ; byte [ ] byteArr = loadBytes ( is ) ; try { is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return byteArr ; } static public String [ ] loadStrings ( File file ) { InputStream is = createInput ( file ) ; if ( is != null ) { String [ ] outgoing = loadStrings ( is ) ; try { is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return outgoing ; } return null ; } public String [ ] loadStrings ( String filename ) { InputStream is = createInput ( filename ) ; if ( is != null ) { String [ ] strArr = loadStrings ( is ) ; try { is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return strArr ; } System . err . println ( "The file \"" + filename + "\" " + "is missing or inaccessible, make sure " + "the URL is valid or that the file has been " + "added to your sketch and is readable." ) ; return null ; } static public String [ ] loadStrings ( InputStream input ) { try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( input , "UTF-8" ) ) ; return loadStrings ( reader ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; } static public String [ ] loadStrings ( BufferedReader reader ) { try { String lines [ ] = new String [ 100 ] ; int lineCount = 0 ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( lineCount == lines . length ) { String temp [ ] = new String [ lineCount < < 1 ] ; System . arraycopy ( lines , 0 , temp , 0 , lineCount ) ; lines = temp ; } lines [ lineCount ++ ] = line ; } reader . close ( ) ; if ( lineCount == lines . length ) { return lines ; } String output [ ] = new String [ lineCount ] ; System . arraycopy ( lines , 0 , output , 0 , lineCount ) ; return output ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; } public OutputStream createOutput ( String filename ) { return createOutput ( saveFile ( filename ) ) ; } static public OutputStream createOutput ( File file ) { try { createPath ( file ) ; FileOutputStream fos = new FileOutputStream ( file ) ; if ( file . getName ( ) . toLowerCase ( ) . endsWith ( ".gz" ) ) { return new GZIPOutputStream ( fos ) ; } return fos ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; } public boolean saveStream ( String target , String source ) { return saveStream ( saveFile ( target ) , source ) ; } public boolean saveStream ( File target , String source ) { return saveStream ( target , createInputRaw ( source ) ) ; } public boolean saveStream ( String target , InputStream source ) { return saveStream ( saveFile ( target ) , source ) ; } static public boolean saveStream ( File target , InputStream source ) { File tempFile = null ; try { File parentDir = target . getParentFile ( ) ; createPath ( target ) ; tempFile = File . createTempFile ( target . getName ( ) , null , parentDir ) ; FileOutputStream targetStream = new FileOutputStream ( tempFile ) ; saveStream ( targetStream , source ) ; targetStream . close ( ) ; targetStream = null ; if ( target . exists ( ) ) { if ( ! target . delete ( ) ) { System . err . println ( "Could not replace " + target . getAbsolutePath ( ) + "." ) ; } } if ( ! tempFile . renameTo ( target ) ) { System . err . println ( "Could not rename temporary file " + tempFile . getAbsolutePath ( ) ) ; return false ; } return true ; } catch ( IOException e ) { if ( tempFile != null ) { tempFile . delete ( ) ; } e . printStackTrace ( ) ; return false ; } } static public void saveStream ( OutputStream target , InputStream source ) throws IOException { BufferedInputStream bis = new BufferedInputStream ( source , 16384 ) ; BufferedOutputStream bos = new BufferedOutputStream ( target ) ; byte [ ] buffer = new byte [ 8192 ] ; int bytesRead ; while ( ( bytesRead = bis . read ( buffer ) ) != - 1 ) { bos . write ( buffer , 0 , bytesRead ) ; } bos . flush ( ) ; } public void saveBytes ( String filename , byte [ ] data ) { saveBytes ( saveFile ( filename ) , data ) ; } static public void saveBytes ( File file , byte [ ] data ) { File tempFile = null ; try { File parentDir = file . getParentFile ( ) ; tempFile = File . createTempFile ( file . getName ( ) , null , parentDir ) ; OutputStream output = createOutput ( tempFile ) ; saveBytes ( output , data ) ; output . close ( ) ; output = null ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { System . err . println ( "Could not replace " + file . getAbsolutePath ( ) ) ; } } if ( ! tempFile . renameTo ( file ) ) { System . err . println ( "Could not rename temporary file " + tempFile . getAbsolutePath ( ) ) ; } } catch ( IOException e ) { System . err . println ( "error saving bytes to " + file ) ; if ( tempFile != null ) { tempFile . delete ( ) ; } e . printStackTrace ( ) ; } } static public void saveBytes ( OutputStream output , byte [ ] data ) { try { output . write ( data ) ; output . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public void saveStrings ( String filename , String data [ ] ) { saveStrings ( saveFile ( filename ) , data ) ; } static public void saveStrings ( File file , String data [ ] ) { saveStrings ( createOutput ( file ) , data ) ; } static public void saveStrings ( OutputStream output , String [ ] data ) { PrintWriter writer = createWriter ( output ) ; for ( int i = 0 ; i < data . length ; i ++ ) { writer . println ( data [ i ] ) ; } writer . flush ( ) ; writer . close ( ) ; } static protected String calcSketchPath ( ) { String folder = null ; try { folder = System . getProperty ( "user.dir" ) ; if ( platform == MACOSX ) { String jarPath = PApplet . class . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) . getPath ( ) ; jarPath = urlDecode ( jarPath ) ; if ( jarPath . contains ( "Contents/Java/" ) ) { String appPath = jarPath . substring ( 0 , jarPath . indexOf ( ".app" ) + 4 ) ; File containingFolder = new File ( appPath ) . getParentFile ( ) ; folder = containingFolder . getAbsolutePath ( ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return folder ; } public String sketchPath ( ) { if ( sketchPath == null ) { sketchPath = calcSketchPath ( ) ; } return sketchPath ; } public String sketchPath ( String where ) { if ( sketchPath ( ) == null ) { return where ; } try { if ( new File ( where ) . isAbsolute ( ) ) return where ; } catch ( Exception e ) { } return sketchPath ( ) + File . separator + where ; } public File sketchFile ( String where ) { return new File ( sketchPath ( where ) ) ; } public String savePath ( String where ) { if ( where == null ) return null ; String filename = sketchPath ( where ) ; createPath ( filename ) ; return filename ; } public File saveFile ( String where ) { return new File ( savePath ( where ) ) ; } static File desktopFolder ; static public File desktopFile ( String what ) { if ( desktopFolder == null ) { desktopFolder = new File ( System . getProperty ( "user.home" ) , "Desktop" ) ; if ( ! desktopFolder . exists ( ) ) { if ( platform == WINDOWS ) { FileSystemView filesys = FileSystemView . getFileSystemView ( ) ; desktopFolder = filesys . getHomeDirectory ( ) ; } else { throw new UnsupportedOperationException ( "Could not find a suitable desktop foldder" ) ; } } } return new File ( desktopFolder , what ) ; } static public String desktopPath ( String what ) { return desktopFile ( what ) . getAbsolutePath ( ) ; } public String dataPath ( String where ) { return dataFile ( where ) . getAbsolutePath ( ) ; } public File dataFile ( String where ) { File why = new File ( where ) ; if ( why . isAbsolute ( ) ) return why ; String jarPath = getClass ( ) . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) . getPath ( ) ; if ( jarPath . contains ( "Contents/Java/" ) ) { File containingFolder = new File ( urlDecode ( jarPath ) ) . getParentFile ( ) ; File dataFolder = new File ( containingFolder , "data" ) ; return new File ( dataFolder , where ) ; } return new File ( sketchPath + File . separator + "data" + File . separator + where ) ; } static public void createPath ( String path ) { createPath ( new File ( path ) ) ; } static public void createPath ( File file ) { try { String parent = file . getParent ( ) ; if ( parent != null ) { File unit = new File ( parent ) ; if ( ! unit . exists ( ) ) unit . mkdirs ( ) ; } } catch ( SecurityException se ) { System . err . println ( "You don't have permissions to create " + file . getAbsolutePath ( ) ) ; } } static public String getExtension ( String filename ) { String extension ; String lower = filename . toLowerCase ( ) ; int dot = filename . lastIndexOf ( '.' ) ; if ( dot == - 1 ) { extension = "unknown" ; } extension = lower . substring ( dot + 1 ) ; int question = extension . indexOf ( '?' ) ; if ( question != - 1 ) { extension = extension . substring ( 0 , question ) ; } return extension ; } static public String urlEncode ( String str ) { try { return URLEncoder . encode ( str , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { return null ; } } static public String urlDecode ( String str ) { try { return URLDecoder . decode ( str , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { return null ; } } static public byte [ ] sort ( byte list [ ] ) { return sort ( list , list . length ) ; } static public byte [ ] sort ( byte [ ] list , int count ) { byte [ ] outgoing = new byte [ list . length ] ; System . arraycopy ( list , 0 , outgoing , 0 , list . length ) ; Arrays . sort ( outgoing , 0 , count ) ; return outgoing ; } static public char [ ] sort ( char list [ ] ) { return sort ( list , list . length ) ; } static public char [ ] sort ( char [ ] list , int count ) { char [ ] outgoing = new char [ list . length ] ; System . arraycopy ( list , 0 , outgoing , 0 , list . length ) ; Arrays . sort ( outgoing , 0 , count ) ; return outgoing ; } static public int [ ] sort ( int list [ ] ) { return sort ( list , list . length ) ; } static public int [ ] sort ( int [ ] list , int count ) { int [ ] outgoing = new int [ list . length ] ; System . arraycopy ( list , 0 , outgoing , 0 , list . length ) ; Arrays . sort ( outgoing , 0 , count ) ; return outgoing ; } static public float [ ] sort ( float list [ ] ) { return sort ( list , list . length ) ; } static public float [ ] sort ( float [ ] list , int count ) { float [ ] outgoing = new float [ list . length ] ; System . arraycopy ( list , 0 , outgoing , 0 , list . length ) ; Arrays . sort ( outgoing , 0 , count ) ; return outgoing ; } static public String [ ] sort ( String list [ ] ) { return sort ( list , list . length ) ; } static public String [ ] sort ( String [ ] list , int count ) { String [ ] outgoing = new String [ list . length ] ; System . arraycopy ( list , 0 , outgoing , 0 , list . length ) ; Arrays . sort ( outgoing , 0 , count ) ; return outgoing ; } static public void arrayCopy ( Object src , int srcPosition , Object dst , int dstPosition , int length ) { System . arraycopy ( src , srcPosition , dst , dstPosition , length ) ; } static public void arrayCopy ( Object src , Object dst , int length ) { System . arraycopy ( src , 0 , dst , 0 , length ) ; } static public void arrayCopy ( Object src , Object dst ) { System . arraycopy ( src , 0 , dst , 0 , Array . getLength ( src ) ) ; } static public void arraycopy ( Object src , int srcPosition , Object dst , int dstPosition , int length ) { System . arraycopy ( src , srcPosition , dst , dstPosition , length ) ; } static public void arraycopy ( Object src , Object dst , int length ) { System . arraycopy ( src , 0 , dst , 0 , length ) ; } static public void arraycopy ( Object src , Object dst ) { System . arraycopy ( src , 0 , dst , 0 , Array . getLength ( src ) ) ; } static public boolean [ ] expand ( boolean list [ ] ) { return expand ( list , list . length < < 1 ) ; } static public boolean [ ] expand ( boolean list [ ] , int newSize ) { boolean temp [ ] = new boolean [ newSize ] ; System . arraycopy ( list , 0 , temp , 0 , Math . min ( newSize , list . length ) ) ; return temp ; } static public byte [ ] expand ( byte list [ ] ) { return expand ( list , list . length < < 1 ) ; } static public byte [ ] expand ( byte list [ ] , int newSize ) { byte temp [ ] = new byte [ newSize ] ; System . arraycopy ( list , 0 , temp , 0 , Math . min ( newSize , list . length ) ) ; return temp ; } static public char [ ] expand ( char list [ ] ) { return expand ( list , list . length < < 1 ) ; } static public char [ ] expand ( char list [ ] , int newSize ) { char temp [ ] = new char [ newSize ] ; System . arraycopy ( list , 0 , temp , 0 , Math . min ( newSize , list . length ) ) ; return temp ; } static public int [ ] expand ( int list [ ] ) { return expand ( list , list . length < < 1 ) ; } static public int [ ] expand ( int list [ ] , int newSize ) { int temp [ ] = new int [ newSize ] ; System . arraycopy ( list , 0 , temp , 0 , Math . min ( newSize , list . length ) ) ; return temp ; } static public long [ ] expand ( long list [ ] ) { return expand ( list , list . length < < 1 ) ; } static public long [ ] expand ( long list [ ] , int newSize ) { long temp [ ] = new long [ newSize ] ; System . arraycopy ( list , 0 , temp , 0 , Math . min ( newSize , list . length ) ) ; return temp ; } static public float [ ] expand ( float list [ ] ) { return expand ( list , list . length < < 1 ) ; } static public float [ ] expand ( float list [ ] , int newSize ) { float temp [ ] = new float [ newSize ] ; System . arraycopy ( list , 0 , temp , 0 , Math . min ( newSize , list . length ) ) ; return temp ; } static public double [ ] expand ( double list [ ] ) { return expand ( list , list . length < < 1 ) ; } static public double [ ] expand ( double list [ ] , int newSize ) { double temp [ ] = new double [ newSize ] ; System . arraycopy ( list , 0 , temp , 0 , Math . min ( newSize , list . length ) ) ; return temp ; } static public String [ ] expand ( String list [ ] ) { return expand ( list , list . length < < 1 ) ; } static public String [ ] expand ( String list [ ] , int newSize ) { String temp [ ] = new String [ newSize ] ; System . arraycopy ( list , 0 , temp , 0 , Math . min ( newSize , list . length ) ) ; return temp ; } static public Object expand ( Object array ) { return expand ( array , Array . getLength ( array ) < < 1 ) ; } static public Object expand ( Object list , int newSize ) { Class < ? > type = list . getClass ( ) . getComponentType ( ) ; Object temp = Array . newInstance ( type , newSize ) ; System . arraycopy ( list , 0 , temp , 0 , Math . min ( Array . getLength ( list ) , newSize ) ) ; return temp ; } static public byte [ ] append ( byte array [ ] , byte value ) { array = expand ( array , array . length + 1 ) ; array [ array . length - 1 ] = value ; return array ; } static public char [ ] append ( char array [ ] , char value ) { array = expand ( array , array . length + 1 ) ; array [ array . length - 1 ] = value ; return array ; } static public int [ ] append ( int array [ ] , int value ) { array = expand ( array , array . length + 1 ) ; array [ array . length - 1 ] = value ; return array ; } static public float [ ] append ( float array [ ] , float value ) { array = expand ( array , array . length + 1 ) ; array [ array . length - 1 ] = value ; return array ; } static public String [ ] append ( String array [ ] , String value ) { array = expand ( array , array . length + 1 ) ; array [ array . length - 1 ] = value ; return array ; } static public Object append ( Object array , Object value ) { int length = Array . getLength ( array ) ; array = expand ( array , length + 1 ) ; Array . set ( array , length , value ) ; return array ; } static public boolean [ ] shorten ( boolean list [ ] ) { return subset ( list , 0 , list . length - 1 ) ; } static public byte [ ] shorten ( byte list [ ] ) { return subset ( list , 0 , list . length - 1 ) ; } static public char [ ] shorten ( char list [ ] ) { return subset ( list , 0 , list . length - 1 ) ; } static public int [ ] shorten ( int list [ ] ) { return subset ( list , 0 , list . length - 1 ) ; } static public float [ ] shorten ( float list [ ] ) { return subset ( list , 0 , list . length - 1 ) ; } static public String [ ] shorten ( String list [ ] ) { return subset ( list , 0 , list . length - 1 ) ; } static public Object shorten ( Object list ) { int length = Array . getLength ( list ) ; return subset ( list , 0 , length - 1 ) ; } static final public boolean [ ] splice ( boolean list [ ] , boolean value , int index ) { boolean outgoing [ ] = new boolean [ list . length + 1 ] ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; outgoing [ index ] = value ; System . arraycopy ( list , index , outgoing , index + 1 , list . length - index ) ; return outgoing ; } static final public boolean [ ] splice ( boolean list [ ] , boolean value [ ] , int index ) { boolean outgoing [ ] = new boolean [ list . length + value . length ] ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; System . arraycopy ( value , 0 , outgoing , index , value . length ) ; System . arraycopy ( list , index , outgoing , index + value . length , list . length - index ) ; return outgoing ; } static final public byte [ ] splice ( byte list [ ] , byte value , int index ) { byte outgoing [ ] = new byte [ list . length + 1 ] ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; outgoing [ index ] = value ; System . arraycopy ( list , index , outgoing , index + 1 , list . length - index ) ; return outgoing ; } static final public byte [ ] splice ( byte list [ ] , byte value [ ] , int index ) { byte outgoing [ ] = new byte [ list . length + value . length ] ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; System . arraycopy ( value , 0 , outgoing , index , value . length ) ; System . arraycopy ( list , index , outgoing , index + value . length , list . length - index ) ; return outgoing ; } static final public char [ ] splice ( char list [ ] , char value , int index ) { char outgoing [ ] = new char [ list . length + 1 ] ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; outgoing [ index ] = value ; System . arraycopy ( list , index , outgoing , index + 1 , list . length - index ) ; return outgoing ; } static final public char [ ] splice ( char list [ ] , char value [ ] , int index ) { char outgoing [ ] = new char [ list . length + value . length ] ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; System . arraycopy ( value , 0 , outgoing , index , value . length ) ; System . arraycopy ( list , index , outgoing , index + value . length , list . length - index ) ; return outgoing ; } static final public int [ ] splice ( int list [ ] , int value , int index ) { int outgoing [ ] = new int [ list . length + 1 ] ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; outgoing [ index ] = value ; System . arraycopy ( list , index , outgoing , index + 1 , list . length - index ) ; return outgoing ; } static final public int [ ] splice ( int list [ ] , int value [ ] , int index ) { int outgoing [ ] = new int [ list . length + value . length ] ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; System . arraycopy ( value , 0 , outgoing , index , value . length ) ; System . arraycopy ( list , index , outgoing , index + value . length , list . length - index ) ; return outgoing ; } static final public float [ ] splice ( float list [ ] , float value , int index ) { float outgoing [ ] = new float [ list . length + 1 ] ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; outgoing [ index ] = value ; System . arraycopy ( list , index , outgoing , index + 1 , list . length - index ) ; return outgoing ; } static final public float [ ] splice ( float list [ ] , float value [ ] , int index ) { float outgoing [ ] = new float [ list . length + value . length ] ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; System . arraycopy ( value , 0 , outgoing , index , value . length ) ; System . arraycopy ( list , index , outgoing , index + value . length , list . length - index ) ; return outgoing ; } static final public String [ ] splice ( String list [ ] , String value , int index ) { String outgoing [ ] = new String [ list . length + 1 ] ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; outgoing [ index ] = value ; System . arraycopy ( list , index , outgoing , index + 1 , list . length - index ) ; return outgoing ; } static final public String [ ] splice ( String list [ ] , String value [ ] , int index ) { String outgoing [ ] = new String [ list . length + value . length ] ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; System . arraycopy ( value , 0 , outgoing , index , value . length ) ; System . arraycopy ( list , index , outgoing , index + value . length , list . length - index ) ; return outgoing ; } static final public Object splice ( Object list , Object value , int index ) { Class < ? > type = list . getClass ( ) . getComponentType ( ) ; Object outgoing = null ; int length = Array . getLength ( list ) ; if ( value . getClass ( ) . getName ( ) . charAt ( 0 ) == '[' ) { int vlength = Array . getLength ( value ) ; outgoing = Array . newInstance ( type , length + vlength ) ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; System . arraycopy ( value , 0 , outgoing , index , vlength ) ; System . arraycopy ( list , index , outgoing , index + vlength , length - index ) ; } else { outgoing = Array . newInstance ( type , length + 1 ) ; System . arraycopy ( list , 0 , outgoing , 0 , index ) ; Array . set ( outgoing , index , value ) ; System . arraycopy ( list , index , outgoing , index + 1 , length - index ) ; } return outgoing ; } static public boolean [ ] subset ( boolean list [ ] , int start ) { return subset ( list , start , list . length - start ) ; } static public boolean [ ] subset ( boolean list [ ] , int start , int count ) { boolean output [ ] = new boolean [ count ] ; System . arraycopy ( list , start , output , 0 , count ) ; return output ; } static public byte [ ] subset ( byte list [ ] , int start ) { return subset ( list , start , list . length - start ) ; } static public byte [ ] subset ( byte list [ ] , int start , int count ) { byte output [ ] = new byte [ count ] ; System . arraycopy ( list , start , output , 0 , count ) ; return output ; } static public char [ ] subset ( char list [ ] , int start ) { return subset ( list , start , list . length - start ) ; } static public char [ ] subset ( char list [ ] , int start , int count ) { char output [ ] = new char [ count ] ; System . arraycopy ( list , start , output , 0 , count ) ; return output ; } static public int [ ] subset ( int list [ ] , int start ) { return subset ( list , start , list . length - start ) ; } static public int [ ] subset ( int list [ ] , int start , int count ) { int output [ ] = new int [ count ] ; System . arraycopy ( list , start , output , 0 , count ) ; return output ; } static public float [ ] subset ( float list [ ] , int start ) { return subset ( list , start , list . length - start ) ; } static public float [ ] subset ( float list [ ] , int start , int count ) { float output [ ] = new float [ count ] ; System . arraycopy ( list , start , output , 0 , count ) ; return output ; } static public String [ ] subset ( String list [ ] , int start ) { return subset ( list , start , list . length - start ) ; } static public String [ ] subset ( String list [ ] , int start , int count ) { String output [ ] = new String [ count ] ; System . arraycopy ( list , start , output , 0 , count ) ; return output ; } static public Object subset ( Object list , int start ) { int length = Array . getLength ( list ) ; return subset ( list , start , length - start ) ; } static public Object subset ( Object list , int start , int count ) { Class < ? > type = list . getClass ( ) . getComponentType ( ) ; Object outgoing = Array . newInstance ( type , count ) ; System . arraycopy ( list , start , outgoing , 0 , count ) ; return outgoing ; } static public boolean [ ] concat ( boolean a [ ] , boolean b [ ] ) { boolean c [ ] = new boolean [ a . length + b . length ] ; System . arraycopy ( a , 0 , c , 0 , a . length ) ; System . arraycopy ( b , 0 , c , a . length , b . length ) ; return c ; } static public byte [ ] concat ( byte a [ ] , byte b [ ] ) { byte c [ ] = new byte [ a . length + b . length ] ; System . arraycopy ( a , 0 , c , 0 , a . length ) ; System . arraycopy ( b , 0 , c , a . length , b . length ) ; return c ; } static public char [ ] concat ( char a [ ] , char b [ ] ) { char c [ ] = new char [ a . length + b . length ] ; System . arraycopy ( a , 0 , c , 0 , a . length ) ; System . arraycopy ( b , 0 , c , a . length , b . length ) ; return c ; } static public int [ ] concat ( int a [ ] , int b [ ] ) { int c [ ] = new int [ a . length + b . length ] ; System . arraycopy ( a , 0 , c , 0 , a . length ) ; System . arraycopy ( b , 0 , c , a . length , b . length ) ; return c ; } static public float [ ] concat ( float a [ ] , float b [ ] ) { float c [ ] = new float [ a . length + b . length ] ; System . arraycopy ( a , 0 , c , 0 , a . length ) ; System . arraycopy ( b , 0 , c , a . length , b . length ) ; return c ; } static public String [ ] concat ( String a [ ] , String b [ ] ) { String c [ ] = new String [ a . length + b . length ] ; System . arraycopy ( a , 0 , c , 0 , a . length ) ; System . arraycopy ( b , 0 , c , a . length , b . length ) ; return c ; } static public Object concat ( Object a , Object b ) { Class < ? > type = a . getClass ( ) . getComponentType ( ) ; int alength = Array . getLength ( a ) ; int blength = Array . getLength ( b ) ; Object outgoing = Array . newInstance ( type , alength + blength ) ; System . arraycopy ( a , 0 , outgoing , 0 , alength ) ; System . arraycopy ( b , 0 , outgoing , alength , blength ) ; return outgoing ; } static public boolean [ ] reverse ( boolean list [ ] ) { boolean outgoing [ ] = new boolean [ list . length ] ; int length1 = list . length - 1 ; for ( int i = 0 ; i < list . length ; i ++ ) { outgoing [ i ] = list [ length1 - i ] ; } return outgoing ; } static public byte [ ] reverse ( byte list [ ] ) { byte outgoing [ ] = new byte [ list . length ] ; int length1 = list . length - 1 ; for ( int i = 0 ; i < list . length ; i ++ ) { outgoing [ i ] = list [ length1 - i ] ; } return outgoing ; } static public char [ ] reverse ( char list [ ] ) { char outgoing [ ] = new char [ list . length ] ; int length1 = list . length - 1 ; for ( int i = 0 ; i < list . length ; i ++ ) { outgoing [ i ] = list [ length1 - i ] ; } return outgoing ; } static public int [ ] reverse ( int list [ ] ) { int outgoing [ ] = new int [ list . length ] ; int length1 = list . length - 1 ; for ( int i = 0 ; i < list . length ; i ++ ) { outgoing [ i ] = list [ length1 - i ] ; } return outgoing ; } static public float [ ] reverse ( float list [ ] ) { float outgoing [ ] = new float [ list . length ] ; int length1 = list . length - 1 ; for ( int i = 0 ; i < list . length ; i ++ ) { outgoing [ i ] = list [ length1 - i ] ; } return outgoing ; } static public String [ ] reverse ( String list [ ] ) { String outgoing [ ] = new String [ list . length ] ; int length1 = list . length - 1 ; for ( int i = 0 ; i < list . length ; i ++ ) { outgoing [ i ] = list [ length1 - i ] ; } return outgoing ; } static public Object reverse ( Object list ) { Class < ? > type = list . getClass ( ) . getComponentType ( ) ; int length = Array . getLength ( list ) ; Object outgoing = Array . newInstance ( type , length ) ; for ( int i = 0 ; i < length ; i ++ ) { Array . set ( outgoing , i , Array . get ( list , ( length - 1 ) - i ) ) ; } return outgoing ; } static public String trim ( String str ) { return str . replace ( '\u00A0' , ' ' ) . trim ( ) ; } static public String [ ] trim ( String [ ] array ) { String [ ] outgoing = new String [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] != null ) { outgoing [ i ] = array [ i ] . replace ( '\u00A0' , ' ' ) . trim ( ) ; } } return outgoing ; } static public String join ( String [ ] list , char separator ) { return join ( list , String . valueOf ( separator ) ) ; } static public String join ( String [ ] list , String separator ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { if ( i != 0 ) sb . append ( separator ) ; sb . append ( list [ i ] ) ; } return sb . toString ( ) ; } static public String [ ] splitTokens ( String value ) { return splitTokens ( value , WHITESPACE ) ; } static public String [ ] splitTokens ( String value , String delim ) { StringTokenizer toker = new StringTokenizer ( value , delim ) ; String pieces [ ] = new String [ toker . countTokens ( ) ] ; int index = 0 ; while ( toker . hasMoreTokens ( ) ) { pieces [ index ++ ] = toker . nextToken ( ) ; } return pieces ; } static public String [ ] split ( String value , char delim ) { if ( value == null ) return null ; char chars [ ] = value . toCharArray ( ) ; int splitCount = 0 ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( chars [ i ] == delim ) splitCount ++ ; } if ( splitCount == 0 ) { String splits [ ] = new String [ 1 ] ; splits [ 0 ] = value ; return splits ; } String splits [ ] = new String [ splitCount + 1 ] ; int splitIndex = 0 ; int startIndex = 0 ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( chars [ i ] == delim ) { splits [ splitIndex ++ ] = new String ( chars , startIndex , i - startIndex ) ; startIndex = i + 1 ; } } splits [ splitIndex ] = new String ( chars , startIndex , chars . length - startIndex ) ; return splits ; } static public String [ ] split ( String value , String delim ) { ArrayList < String > items = new ArrayList < String > ( ) ; int index ; int offset = 0 ; while ( ( index = value . indexOf ( delim , offset ) ) != - 1 ) { items . add ( value . substring ( offset , index ) ) ; offset = index + delim . length ( ) ; } items . add ( value . substring ( offset ) ) ; String [ ] outgoing = new String [ items . size ( ) ] ; items . toArray ( outgoing ) ; return outgoing ; } static protected HashMap < String , Pattern > matchPatterns ; static Pattern matchPattern ( String regexp ) { Pattern p = null ; if ( matchPatterns == null ) { matchPatterns = new HashMap < String , Pattern > ( ) ; } else { p = matchPatterns . get ( regexp ) ; } if ( p == null ) { if ( matchPatterns . size ( ) == 10 ) { matchPatterns . clear ( ) ; } p = Pattern . compile ( regexp , Pattern . MULTILINE | Pattern . DOTALL ) ; matchPatterns . put ( regexp , p ) ; } return p ; } static public String [ ] match ( String str , String regexp ) { Pattern p = matchPattern ( regexp ) ; Matcher m = p . matcher ( str ) ; if ( m . find ( ) ) { int count = m . groupCount ( ) + 1 ; String [ ] groups = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { groups [ i ] = m . group ( i ) ; } return groups ; } return null ; } static public String [ ] [ ] matchAll ( String str , String regexp ) { Pattern p = matchPattern ( regexp ) ; Matcher m = p . matcher ( str ) ; ArrayList < String [ ] > results = new ArrayList < String [ ] > ( ) ; int count = m . groupCount ( ) + 1 ; while ( m . find ( ) ) { String [ ] groups = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { groups [ i ] = m . group ( i ) ; } results . add ( groups ) ; } if ( results . isEmpty ( ) ) { return null ; } String [ ] [ ] matches = new String [ results . size ( ) ] [ count ] ; for ( int i = 0 ; i < matches . length ; i ++ ) { matches [ i ] = results . get ( i ) ; } return matches ; } static final public boolean parseBoolean ( int what ) { return ( what != 0 ) ; } static final public boolean parseBoolean ( String what ) { return Boolean . parseBoolean ( what ) ; } static final public boolean [ ] parseBoolean ( int what [ ] ) { boolean outgoing [ ] = new boolean [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { outgoing [ i ] = ( what [ i ] != 0 ) ; } return outgoing ; } static final public boolean [ ] parseBoolean ( String what [ ] ) { boolean outgoing [ ] = new boolean [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { outgoing [ i ] = Boolean . parseBoolean ( what [ i ] ) ; } return outgoing ; } static final public byte parseByte ( boolean what ) { return what ? ( byte ) 1 : 0 ; } static final public byte parseByte ( char what ) { return ( byte ) what ; } static final public byte parseByte ( int what ) { return ( byte ) what ; } static final public byte parseByte ( float what ) { return ( byte ) what ; } static final public byte [ ] parseByte ( boolean what [ ] ) { byte outgoing [ ] = new byte [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { outgoing [ i ] = what [ i ] ? ( byte ) 1 : 0 ; } return outgoing ; } static final public byte [ ] parseByte ( char what [ ] ) { byte outgoing [ ] = new byte [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { outgoing [ i ] = ( byte ) what [ i ] ; } return outgoing ; } static final public byte [ ] parseByte ( int what [ ] ) { byte outgoing [ ] = new byte [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { outgoing [ i ] = ( byte ) what [ i ] ; } return outgoing ; } static final public byte [ ] parseByte ( float what [ ] ) { byte outgoing [ ] = new byte [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { outgoing [ i ] = ( byte ) what [ i ] ; } return outgoing ; } static final public char parseChar ( byte what ) { return ( char ) ( what & 0xff ) ; } static final public char parseChar ( int what ) { return ( char ) what ; } static final public char [ ] parseChar ( byte what [ ] ) { char outgoing [ ] = new char [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { outgoing [ i ] = ( char ) ( what [ i ] & 0xff ) ; } return outgoing ; } static final public char [ ] parseChar ( int what [ ] ) { char outgoing [ ] = new char [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { outgoing [ i ] = ( char ) what [ i ] ; } return outgoing ; } static final public int parseInt ( boolean what ) { return what ? 1 : 0 ; } static final public int parseInt ( byte what ) { return what & 0xff ; } static final public int parseInt ( char what ) { return what ; } static final public int parseInt ( float what ) { return ( int ) what ; } static final public int parseInt ( String what ) { return parseInt ( what , 0 ) ; } static final public int parseInt ( String what , int otherwise ) { try { int offset = what . indexOf ( '.' ) ; if ( offset == - 1 ) { return Integer . parseInt ( what ) ; } else { return Integer . parseInt ( what . substring ( 0 , offset ) ) ; } } catch ( NumberFormatException e ) { } return otherwise ; } static final public int [ ] parseInt ( boolean what [ ] ) { int list [ ] = new int [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { list [ i ] = what [ i ] ? 1 : 0 ; } return list ; } static final public int [ ] parseInt ( byte what [ ] ) { int list [ ] = new int [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { list [ i ] = ( what [ i ] & 0xff ) ; } return list ; } static final public int [ ] parseInt ( char what [ ] ) { int list [ ] = new int [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { list [ i ] = what [ i ] ; } return list ; } static public int [ ] parseInt ( float what [ ] ) { int inties [ ] = new int [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { inties [ i ] = ( int ) what [ i ] ; } return inties ; } static public int [ ] parseInt ( String what [ ] ) { return parseInt ( what , 0 ) ; } static public int [ ] parseInt ( String what [ ] , int missing ) { int output [ ] = new int [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { try { output [ i ] = Integer . parseInt ( what [ i ] ) ; } catch ( NumberFormatException e ) { output [ i ] = missing ; } } return output ; } static final public float parseFloat ( int what ) { return what ; } static final public float parseFloat ( String what ) { return parseFloat ( what , Float . NaN ) ; } static final public float parseFloat ( String what , float otherwise ) { try { return new Float ( what ) . floatValue ( ) ; } catch ( NumberFormatException e ) { } return otherwise ; } static final public float [ ] parseFloat ( byte what [ ] ) { float floaties [ ] = new float [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { floaties [ i ] = what [ i ] ; } return floaties ; } static final public float [ ] parseFloat ( int what [ ] ) { float floaties [ ] = new float [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { floaties [ i ] = what [ i ] ; } return floaties ; } static final public float [ ] parseFloat ( String what [ ] ) { return parseFloat ( what , Float . NaN ) ; } static final public float [ ] parseFloat ( String what [ ] , float missing ) { float output [ ] = new float [ what . length ] ; for ( int i = 0 ; i < what . length ; i ++ ) { try { output [ i ] = new Float ( what [ i ] ) . floatValue ( ) ; } catch ( NumberFormatException e ) { output [ i ] = missing ; } } return output ; } static final public String str ( boolean x ) { return String . valueOf ( x ) ; } static final public String str ( byte x ) { return String . valueOf ( x ) ; } static final public String str ( char x ) { return String . valueOf ( x ) ; } static final public String str ( int x ) { return String . valueOf ( x ) ; } static final public String str ( float x ) { return String . valueOf ( x ) ; } static final public String [ ] str ( boolean x [ ] ) { String s [ ] = new String [ x . length ] ; for ( int i = 0 ; i < x . length ; i ++ ) s [ i ] = String . valueOf ( x [ i ] ) ; return s ; } static final public String [ ] str ( byte x [ ] ) { String s [ ] = new String [ x . length ] ; for ( int i = 0 ; i < x . length ; i ++ ) s [ i ] = String . valueOf ( x [ i ] ) ; return s ; } static final public String [ ] str ( char x [ ] ) { String s [ ] = new String [ x . length ] ; for ( int i = 0 ; i < x . length ; i ++ ) s [ i ] = String . valueOf ( x [ i ] ) ; return s ; } static final public String [ ] str ( int x [ ] ) { String s [ ] = new String [ x . length ] ; for ( int i = 0 ; i < x . length ; i ++ ) s [ i ] = String . valueOf ( x [ i ] ) ; return s ; } static final public String [ ] str ( float x [ ] ) { String s [ ] = new String [ x . length ] ; for ( int i = 0 ; i < x . length ; i ++ ) s [ i ] = String . valueOf ( x [ i ] ) ; return s ; } static private NumberFormat int_nf ; static private int int_nf_digits ; static private boolean int_nf_commas ; static public String [ ] nf ( int num [ ] , int digits ) { String formatted [ ] = new String [ num . length ] ; for ( int i = 0 ; i < formatted . length ; i ++ ) { formatted [ i ] = nf ( num [ i ] , digits ) ; } return formatted ; } static public String nf ( int num , int digits ) { if ( ( int_nf != null ) && ( int_nf_digits == digits ) && ! int_nf_commas ) { return int_nf . format ( num ) ; } int_nf = NumberFormat . getInstance ( ) ; int_nf . setGroupingUsed ( false ) ; int_nf_commas = false ; int_nf . setMinimumIntegerDigits ( digits ) ; int_nf_digits = digits ; return int_nf . format ( num ) ; } static public String [ ] nfc ( int num [ ] ) { String formatted [ ] = new String [ num . length ] ; for ( int i = 0 ; i < formatted . length ; i ++ ) { formatted [ i ] = nfc ( num [ i ] ) ; } return formatted ; } static public String nfc ( int num ) { if ( ( int_nf != null ) && ( int_nf_digits == 0 ) && int_nf_commas ) { return int_nf . format ( num ) ; } int_nf = NumberFormat . getInstance ( ) ; int_nf . setGroupingUsed ( true ) ; int_nf_commas = true ; int_nf . setMinimumIntegerDigits ( 0 ) ; int_nf_digits = 0 ; return int_nf . format ( num ) ; } static public String nfs ( int num , int digits ) { return ( num < 0 ) ? nf ( num , digits ) : ( ' ' + nf ( num , digits ) ) ; } static public String [ ] nfs ( int num [ ] , int digits ) { String formatted [ ] = new String [ num . length ] ; for ( int i = 0 ; i < formatted . length ; i ++ ) { formatted [ i ] = nfs ( num [ i ] , digits ) ; } return formatted ; } static public String nfp ( int num , int digits ) { return ( num < 0 ) ? nf ( num , digits ) : ( '+' + nf ( num , digits ) ) ; } static public String [ ] nfp ( int num [ ] , int digits ) { String formatted [ ] = new String [ num . length ] ; for ( int i = 0 ; i < formatted . length ; i ++ ) { formatted [ i ] = nfp ( num [ i ] , digits ) ; } return formatted ; } static private NumberFormat float_nf ; static private int float_nf_left , float_nf_right ; static private boolean float_nf_commas ; static public String [ ] nf ( float num [ ] , int left , int right ) { String formatted [ ] = new String [ num . length ] ; for ( int i = 0 ; i < formatted . length ; i ++ ) { formatted [ i ] = nf ( num [ i ] , left , right ) ; } return formatted ; } static public String nf ( float num , int left , int right ) { if ( ( float_nf != null ) && ( float_nf_left == left ) && ( float_nf_right == right ) && ! float_nf_commas ) { return float_nf . format ( num ) ; } float_nf = NumberFormat . getInstance ( ) ; float_nf . setGroupingUsed ( false ) ; float_nf_commas = false ; if ( left != 0 ) float_nf . setMinimumIntegerDigits ( left ) ; if ( right != 0 ) { float_nf . setMinimumFractionDigits ( right ) ; float_nf . setMaximumFractionDigits ( right ) ; } float_nf_left = left ; float_nf_right = right ; return float_nf . format ( num ) ; } static public String [ ] nfc ( float num [ ] , int right ) { String formatted [ ] = new String [ num . length ] ; for ( int i = 0 ; i < formatted . length ; i ++ ) { formatted [ i ] = nfc ( num [ i ] , right ) ; } return formatted ; } static public String nfc ( float num , int right ) { if ( ( float_nf != null ) && ( float_nf_left == 0 ) && ( float_nf_right == right ) && float_nf_commas ) { return float_nf . format ( num ) ; } float_nf = NumberFormat . getInstance ( ) ; float_nf . setGroupingUsed ( true ) ; float_nf_commas = true ; if ( right != 0 ) { float_nf . setMinimumFractionDigits ( right ) ; float_nf . setMaximumFractionDigits ( right ) ; } float_nf_left = 0 ; float_nf_right = right ; return float_nf . format ( num ) ; } static public String [ ] nfs ( float num [ ] , int left , int right ) { String formatted [ ] = new String [ num . length ] ; for ( int i = 0 ; i < formatted . length ; i ++ ) { formatted [ i ] = nfs ( num [ i ] , left , right ) ; } return formatted ; } static public String nfs ( float num , int left , int right ) { return ( num < 0 ) ? nf ( num , left , right ) : ( ' ' + nf ( num , left , right ) ) ; } static public String [ ] nfp ( float num [ ] , int left , int right ) { String formatted [ ] = new String [ num . length ] ; for ( int i = 0 ; i < formatted . length ; i ++ ) { formatted [ i ] = nfp ( num [ i ] , left , right ) ; } return formatted ; } static public String nfp ( float num , int left , int right ) { return ( num < 0 ) ? nf ( num , left , right ) : ( '+' + nf ( num , left , right ) ) ; } static final public String hex ( byte value ) { return hex ( value , 2 ) ; } static final public String hex ( char value ) { return hex ( value , 4 ) ; } static final public String hex ( int value ) { return hex ( value , 8 ) ; } static final public String hex ( int value , int digits ) { String stuff = Integer . toHexString ( value ) . toUpperCase ( ) ; if ( digits > 8 ) { digits = 8 ; } int length = stuff . length ( ) ; if ( length > digits ) { return stuff . substring ( length - digits ) ; } else if ( length < digits ) { return "00000000" . substring ( 8 - ( digits - length ) ) + stuff ; } return stuff ; } static final public int unhex ( String value ) { return ( int ) ( Long . parseLong ( value , 16 ) ) ; } static final public String binary ( byte value ) { return binary ( value , 8 ) ; } static final public String binary ( char value ) { return binary ( value , 16 ) ; } static final public String binary ( int value ) { return binary ( value , 32 ) ; } static final public String binary ( int value , int digits ) { String stuff = Integer . toBinaryString ( value ) ; if ( digits > 32 ) { digits = 32 ; } int length = stuff . length ( ) ; if ( length > digits ) { return stuff . substring ( length - digits ) ; } else if ( length < digits ) { int offset = 32 - ( digits - length ) ; return "00000000000000000000000000000000" . substring ( offset ) + stuff ; } return stuff ; } static final public int unbinary ( String value ) { return Integer . parseInt ( value , 2 ) ; } public final int color ( int gray ) { if ( g == null ) { if ( gray > 255 ) gray = 255 ; else if ( gray < 0 ) gray = 0 ; return 0xff000000 | ( gray < < 16 ) | ( gray < < 8 ) | gray ; } return g . color ( gray ) ; } public final int color ( float fgray ) { if ( g == null ) { int gray = ( int ) fgray ; if ( gray > 255 ) gray = 255 ; else if ( gray < 0 ) gray = 0 ; return 0xff000000 | ( gray < < 16 ) | ( gray < < 8 ) | gray ; } return g . color ( fgray ) ; } public final int color ( int gray , int alpha ) { if ( g == null ) { if ( alpha > 255 ) alpha = 255 ; else if ( alpha < 0 ) alpha = 0 ; if ( gray > 255 ) { return ( alpha < < 24 ) | ( gray & 0xFFFFFF ) ; } else { return ( alpha < < 24 ) | ( gray < < 16 ) | ( gray < < 8 ) | gray ; } } return g . color ( gray , alpha ) ; } public final int color ( float fgray , float falpha ) { if ( g == null ) { int gray = ( int ) fgray ; int alpha = ( int ) falpha ; if ( gray > 255 ) gray = 255 ; else if ( gray < 0 ) gray = 0 ; if ( alpha > 255 ) alpha = 255 ; else if ( alpha < 0 ) alpha = 0 ; return ( alpha < < 24 ) | ( gray < < 16 ) | ( gray < < 8 ) | gray ; } return g . color ( fgray , falpha ) ; } public final int color ( int v1 , int v2 , int v3 ) { if ( g == null ) { if ( v1 > 255 ) v1 = 255 ; else if ( v1 < 0 ) v1 = 0 ; if ( v2 > 255 ) v2 = 255 ; else if ( v2 < 0 ) v2 = 0 ; if ( v3 > 255 ) v3 = 255 ; else if ( v3 < 0 ) v3 = 0 ; return 0xff000000 | ( v1 < < 16 ) | ( v2 < < 8 ) | v3 ; } return g . color ( v1 , v2 , v3 ) ; } public final int color ( int v1 , int v2 , int v3 , int alpha ) { if ( g == null ) { if ( alpha > 255 ) alpha = 255 ; else if ( alpha < 0 ) alpha = 0 ; if ( v1 > 255 ) v1 = 255 ; else if ( v1 < 0 ) v1 = 0 ; if ( v2 > 255 ) v2 = 255 ; else if ( v2 < 0 ) v2 = 0 ; if ( v3 > 255 ) v3 = 255 ; else if ( v3 < 0 ) v3 = 0 ; return ( alpha < < 24 ) | ( v1 < < 16 ) | ( v2 < < 8 ) | v3 ; } return g . color ( v1 , v2 , v3 , alpha ) ; } public final int color ( float v1 , float v2 , float v3 ) { if ( g == null ) { if ( v1 > 255 ) v1 = 255 ; else if ( v1 < 0 ) v1 = 0 ; if ( v2 > 255 ) v2 = 255 ; else if ( v2 < 0 ) v2 = 0 ; if ( v3 > 255 ) v3 = 255 ; else if ( v3 < 0 ) v3 = 0 ; return 0xff000000 | ( ( int ) v1 < < 16 ) | ( ( int ) v2 < < 8 ) | ( int ) v3 ; } return g . color ( v1 , v2 , v3 ) ; } public final int color ( float v1 , float v2 , float v3 , float alpha ) { if ( g == null ) { if ( alpha > 255 ) alpha = 255 ; else if ( alpha < 0 ) alpha = 0 ; if ( v1 > 255 ) v1 = 255 ; else if ( v1 < 0 ) v1 = 0 ; if ( v2 > 255 ) v2 = 255 ; else if ( v2 < 0 ) v2 = 0 ; if ( v3 > 255 ) v3 = 255 ; else if ( v3 < 0 ) v3 = 0 ; return ( ( int ) alpha < < 24 ) | ( ( int ) v1 < < 16 ) | ( ( int ) v2 < < 8 ) | ( int ) v3 ; } return g . color ( v1 , v2 , v3 , alpha ) ; } public int lerpColor ( int c1 , int c2 , float amt ) { if ( g != null ) { return g . lerpColor ( c1 , c2 , amt ) ; } return PGraphics . lerpColor ( c1 , c2 , amt , RGB ) ; } static public int blendColor ( int c1 , int c2 , int mode ) { return PImage . blendColor ( c1 , c2 , mode ) ; } void frameMoved ( int x , int y ) { if ( ! fullScreen ) { System . err . println ( EXTERNAL_MOVE + " " + x + " " + y ) ; System . err . flush ( ) ; } } void frameResized ( int w , int h ) { } static public void main ( final String [ ] args ) { runSketch ( args , null ) ; } static public void main ( final String mainClass ) { main ( mainClass , null ) ; } static public void main ( final String mainClass , final String [ ] sketchArgs ) { String [ ] args = new String [ ] { mainClass } ; if ( sketchArgs != null ) { args = concat ( args , sketchArgs ) ; } runSketch ( args , null ) ; } static public void runSketch ( final String [ ] args , final PApplet constructedSketch ) { System . setProperty ( "sun.awt.noerasebackground" , "true" ) ; try { Toolkit . getDefaultToolkit ( ) . setDynamicLayout ( true ) ; } catch ( HeadlessException e ) { System . err . println ( "Cannot run sketch without a display. Read this for possible solutions:" ) ; System . err . println ( "https://github.com/processing/processing/wiki/Running-without-a-Display" ) ; System . exit ( 1 ) ; } System . setProperty ( "java.net.useSystemProxies" , "true" ) ; if ( args . length < 1 ) { System . err . println ( "Usage: PApplet [options] <class name> [sketch args]" ) ; System . err . println ( "See the Javadoc for PApplet for an explanation." ) ; System . exit ( 1 ) ; } boolean external = false ; int [ ] location = null ; int [ ] editorLocation = null ; String name = null ; int windowColor = 0 ; int stopColor = 0xff808080 ; boolean hideStop = false ; int displayNum = - 1 ; boolean present = false ; String param = null , value = null ; String folder = calcSketchPath ( ) ; int argIndex = 0 ; while ( argIndex < args . length ) { int equals = args [ argIndex ] . indexOf ( '=' ) ; if ( equals != - 1 ) { param = args [ argIndex ] . substring ( 0 , equals ) ; value = args [ argIndex ] . substring ( equals + 1 ) ; if ( param . equals ( ARGS_EDITOR_LOCATION ) ) { external = true ; editorLocation = parseInt ( split ( value , ',' ) ) ; } else if ( param . equals ( ARGS_DISPLAY ) ) { displayNum = parseInt ( value , - 1 ) ; if ( displayNum == - 1 ) { System . err . println ( "Could not parse " + value + " for " + ARGS_DISPLAY ) ; } } else if ( param . equals ( ARGS_WINDOW_COLOR ) ) { if ( value . charAt ( 0 ) == '#' && value . length ( ) == 7 ) { value = value . substring ( 1 ) ; windowColor = 0xff000000 | Integer . parseInt ( value , 16 ) ; } else { System . err . println ( ARGS_WINDOW_COLOR + " should be a # followed by six digits" ) ; } } else if ( param . equals ( ARGS_STOP_COLOR ) ) { if ( value . charAt ( 0 ) == '#' && value . length ( ) == 7 ) { value = value . substring ( 1 ) ; stopColor = 0xff000000 | Integer . parseInt ( value , 16 ) ; } else { System . err . println ( ARGS_STOP_COLOR + " should be a # followed by six digits" ) ; } } else if ( param . equals ( ARGS_SKETCH_FOLDER ) ) { folder = value ; } else if ( param . equals ( ARGS_LOCATION ) ) { location = parseInt ( split ( value , ',' ) ) ; } } else { if ( args [ argIndex ] . equals ( ARGS_PRESENT ) ) { present = true ; } else if ( args [ argIndex ] . equals ( ARGS_HIDE_STOP ) ) { hideStop = true ; } else if ( args [ argIndex ] . equals ( ARGS_EXTERNAL ) ) { external = true ; } else { name = args [ argIndex ] ; break ; } } argIndex ++ ; } final PApplet sketch ; if ( constructedSketch != null ) { sketch = constructedSketch ; } else { try { Class < ? > c = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( name ) ; sketch = ( PApplet ) c . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } if ( platform == MACOSX ) { try { final String td = "processing.core.ThinkDifferent" ; Class < ? > thinkDifferent = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( td ) ; Method method = thinkDifferent . getMethod ( "init" , new Class [ ] { PApplet . class } ) ; method . invoke ( null , new Object [ ] { sketch } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } sketch . display = displayNum ; sketch . handleSettings ( ) ; sketch . sketchPath = folder ; if ( args . length != argIndex + 1 ) { sketch . args = PApplet . subset ( args , argIndex + 1 ) ; } sketch . external = external ; if ( windowColor != 0 ) { sketch . windowColor = windowColor ; } PSurface surface = sketch . initSurface ( ) ; while ( sketch . defaultSize && ! sketch . finished ) { try { Thread . sleep ( 5 ) ; } catch ( InterruptedException e ) { } } if ( present ) { if ( hideStop ) { stopColor = 0 ; } surface . placePresent ( stopColor ) ; } else { surface . placeWindow ( location , editorLocation ) ; } if ( external ) { surface . setupExternalMessages ( ) ; } } protected PSurface initSurface ( ) { g = createPrimaryGraphics ( ) ; surface = g . createSurface ( ) ; if ( g . displayable ( ) && frame == null ) { frame = new Frame ( ) { @ Override public void setResizable ( boolean resizable ) { deprecationWarning ( "setResizable" ) ; surface . setResizable ( resizable ) ; } @ Override public void setVisible ( boolean visible ) { deprecationWarning ( "setVisible" ) ; surface . setVisible ( visible ) ; } @ Override public void setTitle ( String title ) { deprecationWarning ( "setTitle" ) ; surface . setTitle ( title ) ; } private void deprecationWarning ( String method ) { PGraphics . showWarning ( "Use surface." + method + "() instead of " + "frame." + method + " in Processing 3" ) ; } } ; surface . initFrame ( this ) ; surface . setTitle ( getClass ( ) . getName ( ) ) ; } else { surface . initOffscreen ( this ) ; } init ( ) ; return surface ; } static public void hideMenuBar ( ) { if ( PApplet . platform == PConstants . MACOSX ) { japplemenubar . JAppleMenuBar . hide ( ) ; } } protected void runSketch ( final String [ ] args ) { final String [ ] argsWithSketchName = new String [ args . length + 1 ] ; System . arraycopy ( args , 0 , argsWithSketchName , 0 , args . length ) ; final String className = this . getClass ( ) . getSimpleName ( ) ; final String cleanedClass = className . replaceAll ( "__[^_]+__\\$" , "" ) . replaceAll ( "\\$\\d+" , "" ) ; argsWithSketchName [ args . length ] = cleanedClass ; runSketch ( argsWithSketchName , this ) ; } protected void runSketch ( ) { runSketch ( new String [ 0 ] ) ; } public PGraphics beginRecord ( String renderer , String filename ) { filename = insertFrame ( filename ) ; PGraphics rec = createGraphics ( width , height , renderer , filename ) ; beginRecord ( rec ) ; return rec ; } public void beginRecord ( PGraphics recorder ) { this . recorder = recorder ; recorder . beginDraw ( ) ; } public void endRecord ( ) { if ( recorder != null ) { recorder . endDraw ( ) ; recorder . dispose ( ) ; recorder = null ; } } public PGraphics beginRaw ( String renderer , String filename ) { filename = insertFrame ( filename ) ; PGraphics rec = createGraphics ( width , height , renderer , filename ) ; g . beginRaw ( rec ) ; return rec ; } public void beginRaw ( PGraphics rawGraphics ) { g . beginRaw ( rawGraphics ) ; } public void endRaw ( ) { g . endRaw ( ) ; } public void loadPixels ( ) { g . loadPixels ( ) ; pixels = g . pixels ; } public void updatePixels ( ) { g . updatePixels ( ) ; } public void updatePixels ( int x1 , int y1 , int x2 , int y2 ) { g . updatePixels ( x1 , y1 , x2 , y2 ) ; } public PGL beginPGL ( ) { return g . beginPGL ( ) ; } public void endPGL ( ) { if ( recorder != null ) recorder . endPGL ( ) ; g . endPGL ( ) ; } public void flush ( ) { if ( recorder != null ) recorder . flush ( ) ; g . flush ( ) ; } public void hint ( int which ) { if ( recorder != null ) recorder . hint ( which ) ; g . hint ( which ) ; } public void beginShape ( ) { if ( recorder != null ) recorder . beginShape ( ) ; g . beginShape ( ) ; } public void beginShape ( int kind ) { if ( recorder != null ) recorder . beginShape ( kind ) ; g . beginShape ( kind ) ; } public void edge ( boolean edge ) { if ( recorder != null ) recorder . edge ( edge ) ; g . edge ( edge ) ; } public void normal ( float nx , float ny , float nz ) { if ( recorder != null ) recorder . normal ( nx , ny , nz ) ; g . normal ( nx , ny , nz ) ; } public void attrib ( String name , float ... values ) { if ( recorder != null ) recorder . attrib ( name , values ) ; g . attrib ( name , values ) ; } public void attrib ( String name , int ... values ) { if ( recorder != null ) recorder . attrib ( name , values ) ; g . attrib ( name , values ) ; } public void attrib ( String name , boolean ... values ) { if ( recorder != null ) recorder . attrib ( name , values ) ; g . attrib ( name , values ) ; } public void textureMode ( int mode ) { if ( recorder != null ) recorder . textureMode ( mode ) ; g . textureMode ( mode ) ; } public void textureWrap ( int wrap ) { if ( recorder != null ) recorder . textureWrap ( wrap ) ; g . textureWrap ( wrap ) ; } public void texture ( PImage image ) { if ( recorder != null ) recorder . texture ( image ) ; g . texture ( image ) ; } public void noTexture ( ) { if ( recorder != null ) recorder . noTexture ( ) ; g . noTexture ( ) ; } public void vertex ( float x , float y ) { if ( recorder != null ) recorder . vertex ( x , y ) ; g . vertex ( x , y ) ; } public void vertex ( float x , float y , float z ) { if ( recorder != null ) recorder . vertex ( x , y , z ) ; g . vertex ( x , y , z ) ; } public void vertex ( float [ ] v ) { if ( recorder != null ) recorder . vertex ( v ) ; g . vertex ( v ) ; } public void vertex ( float x , float y , float u , float v ) { if ( recorder != null ) recorder . vertex ( x , y , u , v ) ; g . vertex ( x , y , u , v ) ; } public void vertex ( float x , float y , float z , float u , float v ) { if ( recorder != null ) recorder . vertex ( x , y , z , u , v ) ; g . vertex ( x , y , z , u , v ) ; } public void beginContour ( ) { if ( recorder != null ) recorder . beginContour ( ) ; g . beginContour ( ) ; } public void endContour ( ) { if ( recorder != null ) recorder . endContour ( ) ; g . endContour ( ) ; } public void endShape ( ) { if ( recorder != null ) recorder . endShape ( ) ; g . endShape ( ) ; } public void endShape ( int mode ) { if ( recorder != null ) recorder . endShape ( mode ) ; g . endShape ( mode ) ; } public PShape loadShape ( String filename ) { return g . loadShape ( filename ) ; } public PShape loadShape ( String filename , String options ) { return g . loadShape ( filename , options ) ; } public PShape createShape ( ) { return g . createShape ( ) ; } public PShape createShape ( int type ) { return g . createShape ( type ) ; } public PShape createShape ( int kind , float ... p ) { return g . createShape ( kind , p ) ; } public PShader loadShader ( String fragFilename ) { return g . loadShader ( fragFilename ) ; } public PShader loadShader ( String fragFilename , String vertFilename ) { return g . loadShader ( fragFilename , vertFilename ) ; } public void shader ( PShader shader ) { if ( recorder != null ) recorder . shader ( shader ) ; g . shader ( shader ) ; } public void shader ( PShader shader , int kind ) { if ( recorder != null ) recorder . shader ( shader , kind ) ; g . shader ( shader , kind ) ; } public void resetShader ( ) { if ( recorder != null ) recorder . resetShader ( ) ; g . resetShader ( ) ; } public void resetShader ( int kind ) { if ( recorder != null ) recorder . resetShader ( kind ) ; g . resetShader ( kind ) ; } public void filter ( PShader shader ) { if ( recorder != null ) recorder . filter ( shader ) ; g . filter ( shader ) ; } public void clip ( float a , float b , float c , float d ) { if ( recorder != null ) recorder . clip ( a , b , c , d ) ; g . clip ( a , b , c , d ) ; } public void noClip ( ) { if ( recorder != null ) recorder . noClip ( ) ; g . noClip ( ) ; } public void blendMode ( int mode ) { if ( recorder != null ) recorder . blendMode ( mode ) ; g . blendMode ( mode ) ; } public void bezierVertex ( float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { if ( recorder != null ) recorder . bezierVertex ( x2 , y2 , x3 , y3 , x4 , y4 ) ; g . bezierVertex ( x2 , y2 , x3 , y3 , x4 , y4 ) ; } public void bezierVertex ( float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { if ( recorder != null ) recorder . bezierVertex ( x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; g . bezierVertex ( x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; } public void quadraticVertex ( float cx , float cy , float x3 , float y3 ) { if ( recorder != null ) recorder . quadraticVertex ( cx , cy , x3 , y3 ) ; g . quadraticVertex ( cx , cy , x3 , y3 ) ; } public void quadraticVertex ( float cx , float cy , float cz , float x3 , float y3 , float z3 ) { if ( recorder != null ) recorder . quadraticVertex ( cx , cy , cz , x3 , y3 , z3 ) ; g . quadraticVertex ( cx , cy , cz , x3 , y3 , z3 ) ; } public void curveVertex ( float x , float y ) { if ( recorder != null ) recorder . curveVertex ( x , y ) ; g . curveVertex ( x , y ) ; } public void curveVertex ( float x , float y , float z ) { if ( recorder != null ) recorder . curveVertex ( x , y , z ) ; g . curveVertex ( x , y , z ) ; } public void point ( float x , float y ) { if ( recorder != null ) recorder . point ( x , y ) ; g . point ( x , y ) ; } public void point ( float x , float y , float z ) { if ( recorder != null ) recorder . point ( x , y , z ) ; g . point ( x , y , z ) ; } public void line ( float x1 , float y1 , float x2 , float y2 ) { if ( recorder != null ) recorder . line ( x1 , y1 , x2 , y2 ) ; g . line ( x1 , y1 , x2 , y2 ) ; } public void line ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { if ( recorder != null ) recorder . line ( x1 , y1 , z1 , x2 , y2 , z2 ) ; g . line ( x1 , y1 , z1 , x2 , y2 , z2 ) ; } public void triangle ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { if ( recorder != null ) recorder . triangle ( x1 , y1 , x2 , y2 , x3 , y3 ) ; g . triangle ( x1 , y1 , x2 , y2 , x3 , y3 ) ; } public void quad ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { if ( recorder != null ) recorder . quad ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; g . quad ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; } public void rectMode ( int mode ) { if ( recorder != null ) recorder . rectMode ( mode ) ; g . rectMode ( mode ) ; } public void rect ( float a , float b , float c , float d ) { if ( recorder != null ) recorder . rect ( a , b , c , d ) ; g . rect ( a , b , c , d ) ; } public void rect ( float a , float b , float c , float d , float r ) { if ( recorder != null ) recorder . rect ( a , b , c , d , r ) ; g . rect ( a , b , c , d , r ) ; } public void rect ( float a , float b , float c , float d , float tl , float tr , float br , float bl ) { if ( recorder != null ) recorder . rect ( a , b , c , d , tl , tr , br , bl ) ; g . rect ( a , b , c , d , tl , tr , br , bl ) ; } public void ellipseMode ( int mode ) { if ( recorder != null ) recorder . ellipseMode ( mode ) ; g . ellipseMode ( mode ) ; } public void ellipse ( float a , float b , float c , float d ) { if ( recorder != null ) recorder . ellipse ( a , b , c , d ) ; g . ellipse ( a , b , c , d ) ; } public void arc ( float a , float b , float c , float d , float start , float stop ) { if ( recorder != null ) recorder . arc ( a , b , c , d , start , stop ) ; g . arc ( a , b , c , d , start , stop ) ; } public void arc ( float a , float b , float c , float d , float start , float stop , int mode ) { if ( recorder != null ) recorder . arc ( a , b , c , d , start , stop , mode ) ; g . arc ( a , b , c , d , start , stop , mode ) ; } public void box ( float size ) { if ( recorder != null ) recorder . box ( size ) ; g . box ( size ) ; } public void box ( float w , float h , float d ) { if ( recorder != null ) recorder . box ( w , h , d ) ; g . box ( w , h , d ) ; } public void sphereDetail ( int res ) { if ( recorder != null ) recorder . sphereDetail ( res ) ; g . sphereDetail ( res ) ; } public void sphereDetail ( int ures , int vres ) { if ( recorder != null ) recorder . sphereDetail ( ures , vres ) ; g . sphereDetail ( ures , vres ) ; } public void sphere ( float r ) { if ( recorder != null ) recorder . sphere ( r ) ; g . sphere ( r ) ; } public float bezierPoint ( float a , float b , float c , float d , float t ) { return g . bezierPoint ( a , b , c , d , t ) ; } public float bezierTangent ( float a , float b , float c , float d , float t ) { return g . bezierTangent ( a , b , c , d , t ) ; } public void bezierDetail ( int detail ) { if ( recorder != null ) recorder . bezierDetail ( detail ) ; g . bezierDetail ( detail ) ; } public void bezier ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { if ( recorder != null ) recorder . bezier ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; g . bezier ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; } public void bezier ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { if ( recorder != null ) recorder . bezier ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; g . bezier ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; } public float curvePoint ( float a , float b , float c , float d , float t ) { return g . curvePoint ( a , b , c , d , t ) ; } public float curveTangent ( float a , float b , float c , float d , float t ) { return g . curveTangent ( a , b , c , d , t ) ; } public void curveDetail ( int detail ) { if ( recorder != null ) recorder . curveDetail ( detail ) ; g . curveDetail ( detail ) ; } public void curveTightness ( float tightness ) { if ( recorder != null ) recorder . curveTightness ( tightness ) ; g . curveTightness ( tightness ) ; } public void curve ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { if ( recorder != null ) recorder . curve ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; g . curve ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; } public void curve ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { if ( recorder != null ) recorder . curve ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; g . curve ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; } public void imageMode ( int mode ) { if ( recorder != null ) recorder . imageMode ( mode ) ; g . imageMode ( mode ) ; } public void image ( PImage img , float a , float b ) { if ( recorder != null ) recorder . image ( img , a , b ) ; g . image ( img , a , b ) ; } public void image ( PImage img , float a , float b , float c , float d ) { if ( recorder != null ) recorder . image ( img , a , b , c , d ) ; g . image ( img , a , b , c , d ) ; } public void image ( PImage img , float a , float b , float c , float d , int u1 , int v1 , int u2 , int v2 ) { if ( recorder != null ) recorder . image ( img , a , b , c , d , u1 , v1 , u2 , v2 ) ; g . image ( img , a , b , c , d , u1 , v1 , u2 , v2 ) ; } public void shapeMode ( int mode ) { if ( recorder != null ) recorder . shapeMode ( mode ) ; g . shapeMode ( mode ) ; } public void shape ( PShape shape ) { if ( recorder != null ) recorder . shape ( shape ) ; g . shape ( shape ) ; } public void shape ( PShape shape , float x , float y ) { if ( recorder != null ) recorder . shape ( shape , x , y ) ; g . shape ( shape , x , y ) ; } public void shape ( PShape shape , float a , float b , float c , float d ) { if ( recorder != null ) recorder . shape ( shape , a , b , c , d ) ; g . shape ( shape , a , b , c , d ) ; } public void textAlign ( int alignX ) { if ( recorder != null ) recorder . textAlign ( alignX ) ; g . textAlign ( alignX ) ; } public void textAlign ( int alignX , int alignY ) { if ( recorder != null ) recorder . textAlign ( alignX , alignY ) ; g . textAlign ( alignX , alignY ) ; } public float textAscent ( ) { return g . textAscent ( ) ; } public float textDescent ( ) { return g . textDescent ( ) ; } public void textFont ( PFont which ) { if ( recorder != null ) recorder . textFont ( which ) ; g . textFont ( which ) ; } public void textFont ( PFont which , float size ) { if ( recorder != null ) recorder . textFont ( which , size ) ; g . textFont ( which , size ) ; } public void textLeading ( float leading ) { if ( recorder != null ) recorder . textLeading ( leading ) ; g . textLeading ( leading ) ; } public void textMode ( int mode ) { if ( recorder != null ) recorder . textMode ( mode ) ; g . textMode ( mode ) ; } public void textSize ( float size ) { if ( recorder != null ) recorder . textSize ( size ) ; g . textSize ( size ) ; } public float textWidth ( char c ) { return g . textWidth ( c ) ; } public float textWidth ( String str ) { return g . textWidth ( str ) ; } public float textWidth ( char [ ] chars , int start , int length ) { return g . textWidth ( chars , start , length ) ; } public void text ( char c , float x , float y ) { if ( recorder != null ) recorder . text ( c , x , y ) ; g . text ( c , x , y ) ; } public void text ( char c , float x , float y , float z ) { if ( recorder != null ) recorder . text ( c , x , y , z ) ; g . text ( c , x , y , z ) ; } public void text ( String str , float x , float y ) { if ( recorder != null ) recorder . text ( str , x , y ) ; g . text ( str , x , y ) ; } public void text ( char [ ] chars , int start , int stop , float x , float y ) { if ( recorder != null ) recorder . text ( chars , start , stop , x , y ) ; g . text ( chars , start , stop , x , y ) ; } public void text ( String str , float x , float y , float z ) { if ( recorder != null ) recorder . text ( str , x , y , z ) ; g . text ( str , x , y , z ) ; } public void text ( char [ ] chars , int start , int stop , float x , float y , float z ) { if ( recorder != null ) recorder . text ( chars , start , stop , x , y , z ) ; g . text ( chars , start , stop , x , y , z ) ; } public void text ( String str , float x1 , float y1 , float x2 , float y2 ) { if ( recorder != null ) recorder . text ( str , x1 , y1 , x2 , y2 ) ; g . text ( str , x1 , y1 , x2 , y2 ) ; } public void text ( int num , float x , float y ) { if ( recorder != null ) recorder . text ( num , x , y ) ; g . text ( num , x , y ) ; } public void text ( int num , float x , float y , float z ) { if ( recorder != null ) recorder . text ( num , x , y , z ) ; g . text ( num , x , y , z ) ; } public void text ( float num , float x , float y ) { if ( recorder != null ) recorder . text ( num , x , y ) ; g . text ( num , x , y ) ; } public void text ( float num , float x , float y , float z ) { if ( recorder != null ) recorder . text ( num , x , y , z ) ; g . text ( num , x , y , z ) ; } public void pushMatrix ( ) { if ( recorder != null ) recorder . pushMatrix ( ) ; g . pushMatrix ( ) ; } public void popMatrix ( ) { if ( recorder != null ) recorder . popMatrix ( ) ; g . popMatrix ( ) ; } public void translate ( float x , float y ) { if ( recorder != null ) recorder . translate ( x , y ) ; g . translate ( x , y ) ; } public void translate ( float x , float y , float z ) { if ( recorder != null ) recorder . translate ( x , y , z ) ; g . translate ( x , y , z ) ; } public void rotate ( float angle ) { if ( recorder != null ) recorder . rotate ( angle ) ; g . rotate ( angle ) ; } public void rotateX ( float angle ) { if ( recorder != null ) recorder . rotateX ( angle ) ; g . rotateX ( angle ) ; } public void rotateY ( float angle ) { if ( recorder != null ) recorder . rotateY ( angle ) ; g . rotateY ( angle ) ; } public void rotateZ ( float angle ) { if ( recorder != null ) recorder . rotateZ ( angle ) ; g . rotateZ ( angle ) ; } public void rotate ( float angle , float x , float y , float z ) { if ( recorder != null ) recorder . rotate ( angle , x , y , z ) ; g . rotate ( angle , x , y , z ) ; } public void scale ( float s ) { if ( recorder != null ) recorder . scale ( s ) ; g . scale ( s ) ; } public void scale ( float x , float y ) { if ( recorder != null ) recorder . scale ( x , y ) ; g . scale ( x , y ) ; } public void scale ( float x , float y , float z ) { if ( recorder != null ) recorder . scale ( x , y , z ) ; g . scale ( x , y , z ) ; } public void shearX ( float angle ) { if ( recorder != null ) recorder . shearX ( angle ) ; g . shearX ( angle ) ; } public void shearY ( float angle ) { if ( recorder != null ) recorder . shearY ( angle ) ; g . shearY ( angle ) ; } public void resetMatrix ( ) { if ( recorder != null ) recorder . resetMatrix ( ) ; g . resetMatrix ( ) ; } public void applyMatrix ( PMatrix source ) { if ( recorder != null ) recorder . applyMatrix ( source ) ; g . applyMatrix ( source ) ; } public void applyMatrix ( PMatrix2D source ) { if ( recorder != null ) recorder . applyMatrix ( source ) ; g . applyMatrix ( source ) ; } public void applyMatrix ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) { if ( recorder != null ) recorder . applyMatrix ( n00 , n01 , n02 , n10 , n11 , n12 ) ; g . applyMatrix ( n00 , n01 , n02 , n10 , n11 , n12 ) ; } public void applyMatrix ( PMatrix3D source ) { if ( recorder != null ) recorder . applyMatrix ( source ) ; g . applyMatrix ( source ) ; } public void applyMatrix ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { if ( recorder != null ) recorder . applyMatrix ( n00 , n01 , n02 , n03 , n10 , n11 , n12 , n13 , n20 , n21 , n22 , n23 , n30 , n31 , n32 , n33 ) ; g . applyMatrix ( n00 , n01 , n02 , n03 , n10 , n11 , n12 , n13 , n20 , n21 , n22 , n23 , n30 , n31 , n32 , n33 ) ; } public PMatrix getMatrix ( ) { return g . getMatrix ( ) ; } public PMatrix2D getMatrix ( PMatrix2D target ) { return g . getMatrix ( target ) ; } public PMatrix3D getMatrix ( PMatrix3D target ) { return g . getMatrix ( target ) ; } public void setMatrix ( PMatrix source ) { if ( recorder != null ) recorder . setMatrix ( source ) ; g . setMatrix ( source ) ; } public void setMatrix ( PMatrix2D source ) { if ( recorder != null ) recorder . setMatrix ( source ) ; g . setMatrix ( source ) ; } public void setMatrix ( PMatrix3D source ) { if ( recorder != null ) recorder . setMatrix ( source ) ; g . setMatrix ( source ) ; } public void printMatrix ( ) { if ( recorder != null ) recorder . printMatrix ( ) ; g . printMatrix ( ) ; } public void beginCamera ( ) { if ( recorder != null ) recorder . beginCamera ( ) ; g . beginCamera ( ) ; } public void endCamera ( ) { if ( recorder != null ) recorder . endCamera ( ) ; g . endCamera ( ) ; } public void camera ( ) { if ( recorder != null ) recorder . camera ( ) ; g . camera ( ) ; } public void camera ( float eyeX , float eyeY , float eyeZ , float centerX , float centerY , float centerZ , float upX , float upY , float upZ ) { if ( recorder != null ) recorder . camera ( eyeX , eyeY , eyeZ , centerX , centerY , centerZ , upX , upY , upZ ) ; g . camera ( eyeX , eyeY , eyeZ , centerX , centerY , centerZ , upX , upY , upZ ) ; } public void printCamera ( ) { if ( recorder != null ) recorder . printCamera ( ) ; g . printCamera ( ) ; } public void ortho ( ) { if ( recorder != null ) recorder . ortho ( ) ; g . ortho ( ) ; } public void ortho ( float left , float right , float bottom , float top ) { if ( recorder != null ) recorder . ortho ( left , right , bottom , top ) ; g . ortho ( left , right , bottom , top ) ; } public void ortho ( float left , float right , float bottom , float top , float near , float far ) { if ( recorder != null ) recorder . ortho ( left , right , bottom , top , near , far ) ; g . ortho ( left , right , bottom , top , near , far ) ; } public void perspective ( ) { if ( recorder != null ) recorder . perspective ( ) ; g . perspective ( ) ; } public void perspective ( float fovy , float aspect , float zNear , float zFar ) { if ( recorder != null ) recorder . perspective ( fovy , aspect , zNear , zFar ) ; g . perspective ( fovy , aspect , zNear , zFar ) ; } public void frustum ( float left , float right , float bottom , float top , float near , float far ) { if ( recorder != null ) recorder . frustum ( left , right , bottom , top , near , far ) ; g . frustum ( left , right , bottom , top , near , far ) ; } public void printProjection ( ) { if ( recorder != null ) recorder . printProjection ( ) ; g . printProjection ( ) ; } public float screenX ( float x , float y ) { return g . screenX ( x , y ) ; } public float screenY ( float x , float y ) { return g . screenY ( x , y ) ; } public float screenX ( float x , float y , float z ) { return g . screenX ( x , y , z ) ; } public float screenY ( float x , float y , float z ) { return g . screenY ( x , y , z ) ; } public float screenZ ( float x , float y , float z ) { return g . screenZ ( x , y , z ) ; } public float modelX ( float x , float y , float z ) { return g . modelX ( x , y , z ) ; } public float modelY ( float x , float y , float z ) { return g . modelY ( x , y , z ) ; } public float modelZ ( float x , float y , float z ) { return g . modelZ ( x , y , z ) ; } public void pushStyle ( ) { if ( recorder != null ) recorder . pushStyle ( ) ; g . pushStyle ( ) ; } public void popStyle ( ) { if ( recorder != null ) recorder . popStyle ( ) ; g . popStyle ( ) ; } public void style ( PStyle s ) { if ( recorder != null ) recorder . style ( s ) ; g . style ( s ) ; } public void strokeWeight ( float weight ) { if ( recorder != null ) recorder . strokeWeight ( weight ) ; g . strokeWeight ( weight ) ; } public void strokeJoin ( int join ) { if ( recorder != null ) recorder . strokeJoin ( join ) ; g . strokeJoin ( join ) ; } public void strokeCap ( int cap ) { if ( recorder != null ) recorder . strokeCap ( cap ) ; g . strokeCap ( cap ) ; } public void noStroke ( ) { if ( recorder != null ) recorder . noStroke ( ) ; g . noStroke ( ) ; } public void stroke ( int rgb ) { if ( recorder != null ) recorder . stroke ( rgb ) ; g . stroke ( rgb ) ; } public void stroke ( int rgb , float alpha ) { if ( recorder != null ) recorder . stroke ( rgb , alpha ) ; g . stroke ( rgb , alpha ) ; } public void stroke ( float gray ) { if ( recorder != null ) recorder . stroke ( gray ) ; g . stroke ( gray ) ; } public void stroke ( float gray , float alpha ) { if ( recorder != null ) recorder . stroke ( gray , alpha ) ; g . stroke ( gray , alpha ) ; } public void stroke ( float v1 , float v2 , float v3 ) { if ( recorder != null ) recorder . stroke ( v1 , v2 , v3 ) ; g . stroke ( v1 , v2 , v3 ) ; } public void stroke ( float v1 , float v2 , float v3 , float alpha ) { if ( recorder != null ) recorder . stroke ( v1 , v2 , v3 , alpha ) ; g . stroke ( v1 , v2 , v3 , alpha ) ; } public void noTint ( ) { if ( recorder != null ) recorder . noTint ( ) ; g . noTint ( ) ; } public void tint ( int rgb ) { if ( recorder != null ) recorder . tint ( rgb ) ; g . tint ( rgb ) ; } public void tint ( int rgb , float alpha ) { if ( recorder != null ) recorder . tint ( rgb , alpha ) ; g . tint ( rgb , alpha ) ; } public void tint ( float gray ) { if ( recorder != null ) recorder . tint ( gray ) ; g . tint ( gray ) ; } public void tint ( float gray , float alpha ) { if ( recorder != null ) recorder . tint ( gray , alpha ) ; g . tint ( gray , alpha ) ; } public void tint ( float v1 , float v2 , float v3 ) { if ( recorder != null ) recorder . tint ( v1 , v2 , v3 ) ; g . tint ( v1 , v2 , v3 ) ; } public void tint ( float v1 , float v2 , float v3 , float alpha ) { if ( recorder != null ) recorder . tint ( v1 , v2 , v3 , alpha ) ; g . tint ( v1 , v2 , v3 , alpha ) ; } public void noFill ( ) { if ( recorder != null ) recorder . noFill ( ) ; g . noFill ( ) ; } public void fill ( int rgb ) { if ( recorder != null ) recorder . fill ( rgb ) ; g . fill ( rgb ) ; } public void fill ( int rgb , float alpha ) { if ( recorder != null ) recorder . fill ( rgb , alpha ) ; g . fill ( rgb , alpha ) ; } public void fill ( float gray ) { if ( recorder != null ) recorder . fill ( gray ) ; g . fill ( gray ) ; } public void fill ( float gray , float alpha ) { if ( recorder != null ) recorder . fill ( gray , alpha ) ; g . fill ( gray , alpha ) ; } public void fill ( float v1 , float v2 , float v3 ) { if ( recorder != null ) recorder . fill ( v1 , v2 , v3 ) ; g . fill ( v1 , v2 , v3 ) ; } public void fill ( float v1 , float v2 , float v3 , float alpha ) { if ( recorder != null ) recorder . fill ( v1 , v2 , v3 , alpha ) ; g . fill ( v1 , v2 , v3 , alpha ) ; } public void ambient ( int rgb ) { if ( recorder != null ) recorder . ambient ( rgb ) ; g . ambient ( rgb ) ; } public void ambient ( float gray ) { if ( recorder != null ) recorder . ambient ( gray ) ; g . ambient ( gray ) ; } public void ambient ( float v1 , float v2 , float v3 ) { if ( recorder != null ) recorder . ambient ( v1 , v2 , v3 ) ; g . ambient ( v1 , v2 , v3 ) ; } public void specular ( int rgb ) { if ( recorder != null ) recorder . specular ( rgb ) ; g . specular ( rgb ) ; } public void specular ( float gray ) { if ( recorder != null ) recorder . specular ( gray ) ; g . specular ( gray ) ; } public void specular ( float v1 , float v2 , float v3 ) { if ( recorder != null ) recorder . specular ( v1 , v2 , v3 ) ; g . specular ( v1 , v2 , v3 ) ; } public void shininess ( float shine ) { if ( recorder != null ) recorder . shininess ( shine ) ; g . shininess ( shine ) ; } public void emissive ( int rgb ) { if ( recorder != null ) recorder . emissive ( rgb ) ; g . emissive ( rgb ) ; } public void emissive ( float gray ) { if ( recorder != null ) recorder . emissive ( gray ) ; g . emissive ( gray ) ; } public void emissive ( float v1 , float v2 , float v3 ) { if ( recorder != null ) recorder . emissive ( v1 , v2 , v3 ) ; g . emissive ( v1 , v2 , v3 ) ; } public void lights ( ) { if ( recorder != null ) recorder . lights ( ) ; g . lights ( ) ; } public void noLights ( ) { if ( recorder != null ) recorder . noLights ( ) ; g . noLights ( ) ; } public void ambientLight ( float v1 , float v2 , float v3 ) { if ( recorder != null ) recorder . ambientLight ( v1 , v2 , v3 ) ; g . ambientLight ( v1 , v2 , v3 ) ; } public void ambientLight ( float v1 , float v2 , float v3 , float x , float y , float z ) { if ( recorder != null ) recorder . ambientLight ( v1 , v2 , v3 , x , y , z ) ; g . ambientLight ( v1 , v2 , v3 , x , y , z ) ; } public void directionalLight ( float v1 , float v2 , float v3 , float nx , float ny , float nz ) { if ( recorder != null ) recorder . directionalLight ( v1 , v2 , v3 , nx , ny , nz ) ; g . directionalLight ( v1 , v2 , v3 , nx , ny , nz ) ; } public void pointLight ( float v1 , float v2 , float v3 , float x , float y , float z ) { if ( recorder != null ) recorder . pointLight ( v1 , v2 , v3 , x , y , z ) ; g . pointLight ( v1 , v2 , v3 , x , y , z ) ; } public void spotLight ( float v1 , float v2 , float v3 , float x , float y , float z , float nx , float ny , float nz , float angle , float concentration ) { if ( recorder != null ) recorder . spotLight ( v1 , v2 , v3 , x , y , z , nx , ny , nz , angle , concentration ) ; g . spotLight ( v1 , v2 , v3 , x , y , z , nx , ny , nz , angle , concentration ) ; } public void lightFalloff ( float constant , float linear , float quadratic ) { if ( recorder != null ) recorder . lightFalloff ( constant , linear , quadratic ) ; g . lightFalloff ( constant , linear , quadratic ) ; } public void lightSpecular ( float v1 , float v2 , float v3 ) { if ( recorder != null ) recorder . lightSpecular ( v1 , v2 , v3 ) ; g . lightSpecular ( v1 , v2 , v3 ) ; } public void background ( int rgb ) { if ( recorder != null ) recorder . background ( rgb ) ; g . background ( rgb ) ; } public void background ( int rgb , float alpha ) { if ( recorder != null ) recorder . background ( rgb , alpha ) ; g . background ( rgb , alpha ) ; } public void background ( float gray ) { if ( recorder != null ) recorder . background ( gray ) ; g . background ( gray ) ; } public void background ( float gray , float alpha ) { if ( recorder != null ) recorder . background ( gray , alpha ) ; g . background ( gray , alpha ) ; } public void background ( float v1 , float v2 , float v3 ) { if ( recorder != null ) recorder . background ( v1 , v2 , v3 ) ; g . background ( v1 , v2 , v3 ) ; } public void background ( float v1 , float v2 , float v3 , float alpha ) { if ( recorder != null ) recorder . background ( v1 , v2 , v3 , alpha ) ; g . background ( v1 , v2 , v3 , alpha ) ; } public void clear ( ) { if ( recorder != null ) recorder . clear ( ) ; g . clear ( ) ; } public void background ( PImage image ) { if ( recorder != null ) recorder . background ( image ) ; g . background ( image ) ; } public void colorMode ( int mode ) { if ( recorder != null ) recorder . colorMode ( mode ) ; g . colorMode ( mode ) ; } public void colorMode ( int mode , float max ) { if ( recorder != null ) recorder . colorMode ( mode , max ) ; g . colorMode ( mode , max ) ; } public void colorMode ( int mode , float max1 , float max2 , float max3 ) { if ( recorder != null ) recorder . colorMode ( mode , max1 , max2 , max3 ) ; g . colorMode ( mode , max1 , max2 , max3 ) ; } public void colorMode ( int mode , float max1 , float max2 , float max3 , float maxA ) { if ( recorder != null ) recorder . colorMode ( mode , max1 , max2 , max3 , maxA ) ; g . colorMode ( mode , max1 , max2 , max3 , maxA ) ; } public final float alpha ( int rgb ) { return g . alpha ( rgb ) ; } public final float red ( int rgb ) { return g . red ( rgb ) ; } public final float green ( int rgb ) { return g . green ( rgb ) ; } public final float blue ( int rgb ) { return g . blue ( rgb ) ; } public final float hue ( int rgb ) { return g . hue ( rgb ) ; } public final float saturation ( int rgb ) { return g . saturation ( rgb ) ; } public final float brightness ( int rgb ) { return g . brightness ( rgb ) ; } static public int lerpColor ( int c1 , int c2 , float amt , int mode ) { return PGraphics . lerpColor ( c1 , c2 , amt , mode ) ; } static public void showDepthWarning ( String method ) { PGraphics . showDepthWarning ( method ) ; } static public void showDepthWarningXYZ ( String method ) { PGraphics . showDepthWarningXYZ ( method ) ; } static public void showMethodWarning ( String method ) { PGraphics . showMethodWarning ( method ) ; } static public void showVariationWarning ( String str ) { PGraphics . showVariationWarning ( str ) ; } static public void showMissingWarning ( String method ) { PGraphics . showMissingWarning ( method ) ; } public int get ( int x , int y ) { return g . get ( x , y ) ; } public PImage get ( int x , int y , int w , int h ) { return g . get ( x , y , w , h ) ; } public PImage get ( ) { return g . get ( ) ; } public PImage copy ( ) { return g . copy ( ) ; } public void set ( int x , int y , int c ) { if ( recorder != null ) recorder . set ( x , y , c ) ; g . set ( x , y , c ) ; } public void set ( int x , int y , PImage img ) { if ( recorder != null ) recorder . set ( x , y , img ) ; g . set ( x , y , img ) ; } public void mask ( PImage img ) { if ( recorder != null ) recorder . mask ( img ) ; g . mask ( img ) ; } public void filter ( int kind ) { if ( recorder != null ) recorder . filter ( kind ) ; g . filter ( kind ) ; } public void filter ( int kind , float param ) { if ( recorder != null ) recorder . filter ( kind , param ) ; g . filter ( kind , param ) ; } public void copy ( int sx , int sy , int sw , int sh , int dx , int dy , int dw , int dh ) { if ( recorder != null ) recorder . copy ( sx , sy , sw , sh , dx , dy , dw , dh ) ; g . copy ( sx , sy , sw , sh , dx , dy , dw , dh ) ; } public void copy ( PImage src , int sx , int sy , int sw , int sh , int dx , int dy , int dw , int dh ) { if ( recorder != null ) recorder . copy ( src , sx , sy , sw , sh , dx , dy , dw , dh ) ; g . copy ( src , sx , sy , sw , sh , dx , dy , dw , dh ) ; } public void blend ( int sx , int sy , int sw , int sh , int dx , int dy , int dw , int dh , int mode ) { if ( recorder != null ) recorder . blend ( sx , sy , sw , sh , dx , dy , dw , dh , mode ) ; g . blend ( sx , sy , sw , sh , dx , dy , dw , dh , mode ) ; } public void blend ( PImage src , int sx , int sy , int sw , int sh , int dx , int dy , int dw , int dh , int mode ) { if ( recorder != null ) recorder . blend ( src , sx , sy , sw , sh , dx , dy , dw , dh , mode ) ; g . blend ( src , sx , sy , sw , sh , dx , dy , dw , dh , mode ) ; } }
package processing . mode . java . tweak ; import java . awt . Graphics2D ; import java . awt . geom . AffineTransform ; import java . math . BigDecimal ; import java . util . Comparator ; import java . util . Locale ; public class Handle { public String type ; public String name ; public String strValue ; public String strNewValue ; public int varIndex ; public int startChar ; public int endChar ; public int newStartChar ; public int newEndChar ; public int line ; int tabIndex ; int decimalPlaces ; float incValue ; java . lang . Number value , newValue ; String strDiff ; ColorControlBox colorBox ; int x , y , width , height ; int xCenter , xCurrent , xLast ; HProgressBar progBar = null ; String textFormat ; TweakClient tweakClient ; public Handle ( String t , String n , int vi , String v , int ti , int l , int sc , int ec , int dp ) { type = t ; name = n ; varIndex = vi ; strValue = v ; tabIndex = ti ; line = l ; startChar = sc ; endChar = ec ; decimalPlaces = dp ; incValue = ( float ) ( 1 / Math . pow ( 10 , decimalPlaces ) ) ; if ( "int" . equals ( type ) ) { value = newValue = Integer . parseInt ( strValue ) ; strNewValue = strValue ; textFormat = "%d" ; } else if ( "hex" . equals ( type ) ) { Long val = Long . parseLong ( strValue . substring ( 2 , strValue . length ( ) ) , 16 ) ; value = newValue = val . intValue ( ) ; strNewValue = strValue ; textFormat = "0x%x" ; } else if ( "webcolor" . equals ( type ) ) { Long val = Long . parseLong ( strValue . substring ( 1 , strValue . length ( ) ) , 16 ) ; val = val | 0xff000000 ; value = newValue = val . intValue ( ) ; strNewValue = strValue ; textFormat = "#%06x" ; } else if ( "float" . equals ( type ) ) { value = newValue = Float . parseFloat ( strValue ) ; strNewValue = strValue ; textFormat = "%.0" + decimalPlaces + "f" ; } newStartChar = startChar ; newEndChar = endChar ; } public void initInterface ( int x , int y , int width , int height ) { this . x = x ; this . y = y ; this . width = width ; this . height = height ; progBar = new HProgressBar ( height , width ) ; } public void setCenterX ( int mx ) { xLast = xCurrent = xCenter = mx ; } public void setCurrentX ( int mx ) { xLast = xCurrent ; xCurrent = mx ; progBar . setPos ( xCurrent - xCenter ) ; updateValue ( ) ; } public void resetProgress ( ) { progBar . setPos ( 0 ) ; } public void updateValue ( ) { float change = getChange ( ) ; if ( "int" . equals ( type ) ) { if ( newValue . intValue ( ) + ( int ) change > Integer . MAX_VALUE || newValue . intValue ( ) + ( int ) change < Integer . MIN_VALUE ) { change = 0 ; return ; } setValue ( newValue . intValue ( ) + ( int ) change ) ; } else if ( "hex" . equals ( type ) ) { setValue ( newValue . intValue ( ) + ( int ) change ) ; } else if ( "webcolor" . equals ( type ) ) { setValue ( newValue . intValue ( ) + ( int ) change ) ; } else if ( "float" . equals ( type ) ) { setValue ( newValue . floatValue ( ) + change ) ; } updateColorBox ( ) ; } public void setValue ( Number value ) { if ( "int" . equals ( type ) ) { newValue = value . intValue ( ) ; strNewValue = String . format ( Locale . US , textFormat , newValue . intValue ( ) ) ; } else if ( "hex" . equals ( type ) ) { newValue = value . intValue ( ) ; strNewValue = String . format ( Locale . US , textFormat , newValue . intValue ( ) ) ; } else if ( "webcolor" . equals ( type ) ) { newValue = value . intValue ( ) ; int val = ( newValue . intValue ( ) & 0xffffff ) ; strNewValue = String . format ( Locale . US , textFormat , val ) ; } else if ( "float" . equals ( type ) ) { BigDecimal bd = new BigDecimal ( value . floatValue ( ) ) ; bd = bd . setScale ( decimalPlaces , BigDecimal . ROUND_HALF_UP ) ; newValue = bd . floatValue ( ) ; strNewValue = String . format ( Locale . US , textFormat , newValue . floatValue ( ) ) ; } sendNewValue ( ) ; } public void updateColorBox ( ) { if ( colorBox != null ) { colorBox . colorChanged ( ) ; } } private float getChange ( ) { int pixels = xCurrent - xLast ; return pixels * incValue ; } public void setPos ( int nx , int ny ) { x = nx ; y = ny ; } public void setWidth ( int w ) { width = w ; progBar . setWidth ( w ) ; } public void draw ( Graphics2D g2d , boolean hasFocus ) { AffineTransform prevTrans = g2d . getTransform ( ) ; g2d . translate ( x , y ) ; g2d . setColor ( ColorScheme . getInstance ( ) . progressFillColor ) ; g2d . drawLine ( 0 , 0 , width , 0 ) ; if ( hasFocus ) { if ( progBar != null ) { g2d . translate ( width / 2 , 2 ) ; progBar . draw ( g2d ) ; } } g2d . setTransform ( prevTrans ) ; } public boolean pick ( int mx , int my ) { return pickText ( mx , my ) ; } public boolean pickText ( int mx , int my ) { return ( mx > x - 2 && mx < x + width + 2 && my > y - height && my < y ) ; } public boolean valueChanged ( ) { if ( "int" . equals ( type ) ) { return ( value . intValue ( ) != newValue . intValue ( ) ) ; } else if ( "hex" . equals ( type ) ) { return ( value . intValue ( ) != newValue . intValue ( ) ) ; } else if ( "webcolor" . equals ( type ) ) { return ( value . intValue ( ) != newValue . intValue ( ) ) ; } else { return ( value . floatValue ( ) != newValue . floatValue ( ) ) ; } } public void setColorBox ( ColorControlBox box ) { colorBox = box ; } public void setTweakClient ( TweakClient client ) { tweakClient = client ; } public void sendNewValue ( ) { int index = varIndex ; try { if ( "int" . equals ( type ) ) { tweakClient . sendInt ( index , newValue . intValue ( ) ) ; } else if ( "hex" . equals ( type ) ) { tweakClient . sendInt ( index , newValue . intValue ( ) ) ; } else if ( "webcolor" . equals ( type ) ) { tweakClient . sendInt ( index , newValue . intValue ( ) ) ; } else if ( "float" . equals ( type ) ) { tweakClient . sendFloat ( index , newValue . floatValue ( ) ) ; } } catch ( Exception e ) { System . out . println ( "error sending new value!" ) ; } } public String toString ( ) { return type + " " + name + " = " + strValue + " (tab: " + tabIndex + ", line: " + line + ", start: " + startChar + ", end: " + endChar + ")" ; } } class HandleComparator implements Comparator < Handle > { public int compare ( Handle handle1 , Handle handle2 ) { int tab = handle1 . tabIndex - handle2 . tabIndex ; if ( tab != 0 ) { return tab ; } return handle1 . startChar - handle2 . startChar ; } }
package processing . mode . java . tweak ; import java . awt . BorderLayout ; import java . awt . Color ; import java . awt . Cursor ; import java . awt . Dimension ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . RenderingHints ; import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; import java . awt . geom . AffineTransform ; import java . awt . image . BufferedImage ; import javax . swing . Box ; import javax . swing . JComponent ; import javax . swing . JFrame ; public class ColorSelector { int hue , saturation , brightness ; public JFrame frame ; public ColorControlBox colorBox ; ColorSelectorBox selectorBox ; ColorSelectorSlider selectorSlider ; SelectorTopBar topBar ; public ColorSelector ( ColorControlBox colorBox ) { this . colorBox = colorBox ; createFrame ( ) ; } public void createFrame ( ) { frame = new JFrame ( ) ; frame . setBackground ( Color . BLACK ) ; Box box = Box . createHorizontalBox ( ) ; box . setBackground ( Color . BLACK ) ; selectorSlider = new ColorSelectorSlider ( ) ; if ( ! colorBox . isBW ) { selectorBox = new ColorSelectorBox ( ) ; box . add ( selectorBox ) ; } box . add ( Box . createHorizontalGlue ( ) ) ; box . add ( selectorSlider , BorderLayout . CENTER ) ; box . add ( Box . createHorizontalGlue ( ) ) ; frame . getContentPane ( ) . add ( box , BorderLayout . CENTER ) ; frame . pack ( ) ; frame . setResizable ( false ) ; frame . setCursor ( Cursor . getPredefinedCursor ( Cursor . CROSSHAIR_CURSOR ) ) ; } public void show ( int x , int y ) { frame . setLocation ( x , y ) ; frame . setVisible ( true ) ; frame . repaint ( ) ; } public void hide ( ) { this . colorBox = null ; frame . setVisible ( false ) ; } public void refreshColor ( ) { if ( ! colorBox . ilegalColor ) { setColor ( colorBox . color ) ; } } public void setColor ( Color c ) { if ( selectorBox != null ) { selectorBox . setToColor ( c ) ; } selectorSlider . setToColor ( c ) ; repaintSelector ( ) ; } public void satBrightChanged ( ) { repaintSelector ( ) ; } public void hueChanged ( ) { if ( selectorBox != null ) { selectorBox . renderBack ( ) ; } repaintSelector ( ) ; } public void repaintSelector ( ) { if ( selectorBox != null ) { selectorBox . repaint ( ) ; } selectorSlider . repaint ( ) ; } class ColorSelectorBox extends JComponent { int lastX , lastY ; BufferedImage backImg ; ColorSelectorBox ( ) { if ( ! colorBox . ilegalColor ) { setToColor ( colorBox . color ) ; } renderBack ( ) ; addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent e ) { updateMouse ( e ) ; } } ) ; addMouseMotionListener ( new MouseAdapter ( ) { public void mouseDragged ( MouseEvent e ) { updateMouse ( e ) ; } } ) ; } public void paintComponent ( Graphics g ) { g . drawImage ( backImg , 0 , 0 , this ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( lastY < 128 ? Color . BLACK : Color . WHITE ) ; AffineTransform tx = g2 . getTransform ( ) ; g2 . translate ( lastX , lastY ) ; g2 . drawOval ( - 3 , - 3 , 6 , 6 ) ; g2 . drawLine ( - 8 , 0 , - 6 , 0 ) ; g2 . drawLine ( 6 , 0 , 8 , 0 ) ; g2 . drawLine ( 0 , - 8 , 0 , - 6 ) ; g2 . drawLine ( 0 , 6 , 0 , 8 ) ; g2 . setTransform ( tx ) ; } public void renderBack ( ) { int [ ] pixels = new int [ 256 * 256 ] ; int index = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { for ( int i = 0 ; i < 256 ; i ++ ) { pixels [ index ++ ] = Color . HSBtoRGB ( hue / 255f , ( i / 255f ) , ( 255 - j ) / 255f ) ; } } backImg = new BufferedImage ( 256 , 256 , BufferedImage . TYPE_INT_RGB ) ; backImg . getRaster ( ) . setDataElements ( 0 , 0 , 256 , 256 , pixels ) ; } public void setToColor ( Color c ) { float hsb [ ] = Color . RGBtoHSB ( c . getRed ( ) , c . getGreen ( ) , c . getBlue ( ) , null ) ; saturation = ( int ) ( hsb [ 1 ] * 255 ) ; brightness = ( int ) ( hsb [ 2 ] * 255 ) ; lastX = saturation ; lastY = 255 - brightness ; } void updateMouse ( MouseEvent event ) { int mouseX = event . getX ( ) ; int mouseY = event . getY ( ) ; if ( mouseX >= 0 && mouseX < 256 && mouseY >= 0 && mouseY < 256 ) { lastX = mouseX ; lastY = mouseY ; updateColor ( ) ; } } void updateColor ( ) { saturation = lastX ; brightness = 255 - lastY ; satBrightChanged ( ) ; colorBox . selectorChanged ( hue , saturation , brightness ) ; } public Dimension getPreferredSize ( ) { return new Dimension ( 256 , 256 ) ; } public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } public Dimension getMaximumSize ( ) { return getPreferredSize ( ) ; } } class ColorSelectorSlider extends JComponent { final int WIDE = 30 ; BufferedImage backImg ; int lastY ; ColorSelectorSlider ( ) { if ( ! colorBox . ilegalColor ) { setToColor ( colorBox . color ) ; } renderBack ( ) ; addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent e ) { updateMouse ( e ) ; } } ) ; addMouseMotionListener ( new MouseAdapter ( ) { public void mouseDragged ( MouseEvent e ) { updateMouse ( e ) ; } } ) ; } public void paintComponent ( Graphics g ) { g . drawImage ( backImg , 0 , 0 , this ) ; Graphics2D g2 = ( Graphics2D ) g ; if ( colorBox . isBW && lastY >= 128 ) { g2 . setColor ( Color . WHITE ) ; } else { g2 . setColor ( Color . BLACK ) ; } AffineTransform tx = g2 . getTransform ( ) ; g2 . translate ( 0 , lastY ) ; g . drawRect ( 1 , - 2 , 6 , 4 ) ; g . drawLine ( 13 , 0 , 17 , 0 ) ; g . drawLine ( 15 , - 2 , 15 , 2 ) ; g . drawRect ( 24 , - 2 , 4 , 4 ) ; g2 . setTransform ( tx ) ; } void renderBack ( ) { int [ ] pixels = new int [ WIDE * 256 ] ; int index = 0 ; int argb = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { if ( colorBox . isBW ) { int gray = 255 - j ; argb = 0xff000000 | ( gray < < 16 ) | ( gray < < 8 ) | gray ; } else { argb = Color . HSBtoRGB ( ( 255 - j ) / 255f , 1 , 1 ) ; } for ( int i = 0 ; i < WIDE ; i ++ ) { pixels [ index ++ ] = argb ; } } backImg = new BufferedImage ( WIDE , 256 , BufferedImage . TYPE_INT_RGB ) ; backImg . getRaster ( ) . setDataElements ( 0 , 0 , WIDE , 256 , pixels ) ; } void setToColor ( Color c ) { if ( colorBox . isBW ) { hue = c . getRed ( ) ; } else { float hsb [ ] = Color . RGBtoHSB ( c . getRed ( ) , c . getGreen ( ) , c . getBlue ( ) , null ) ; hue = ( int ) ( hsb [ 0 ] * 255 ) ; } lastY = 255 - hue ; } void updateMouse ( MouseEvent event ) { int mouseY = event . getY ( ) ; if ( mouseY >= 0 && mouseY < 256 ) { lastY = mouseY ; updateColor ( ) ; } } public void updateColor ( ) { hue = 255 - lastY ; hueChanged ( ) ; colorBox . selectorChanged ( hue , saturation , brightness ) ; } public Dimension getPreferredSize ( ) { return new Dimension ( 30 , 255 ) ; } public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } public Dimension getMaximumSize ( ) { return getPreferredSize ( ) ; } } public class SelectorTopBar extends JComponent { int barWidth ; int barHeight = 16 ; public SelectorTopBar ( int w ) { barWidth = w ; } @ Override public void paintComponent ( Graphics g ) { g . setColor ( Color . GRAY ) ; Dimension size = getSize ( ) ; g . fillRect ( 0 , 0 , size . width , size . height ) ; } public Dimension getPreferredSize ( ) { return new Dimension ( barWidth , barHeight ) ; } public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } public Dimension getMaximumSize ( ) { return getPreferredSize ( ) ; } } }
package processing . mode . java . tweak ; public class ColorMode { final static int RGB = 0 ; final static int HSB = 1 ; float v1Max , v2Max , v3Max , aMax ; int modeType ; boolean unrecognizedMode ; String drawContext ; public ColorMode ( String context ) { this . drawContext = context ; modeType = RGB ; v1Max = 255 ; v2Max = 255 ; v3Max = 255 ; aMax = 255 ; unrecognizedMode = false ; } public ColorMode ( String context , int type , float v1 , float v2 , float v3 , float a ) { this . drawContext = context ; modeType = type ; v1Max = v1 ; v2Max = v2 ; v3Max = v3 ; aMax = a ; unrecognizedMode = false ; } public static ColorMode fromString ( String context , String mode ) { try { String [ ] elements = mode . split ( "," ) ; int type = RGB ; if ( elements [ 0 ] . trim ( ) . equals ( "HSB" ) ) { type = HSB ; } if ( elements . length == 1 ) { return new ColorMode ( context , type , 255 , 255 , 255 , 255 ) ; } else if ( elements . length == 2 ) { float max = Float . parseFloat ( elements [ 1 ] . trim ( ) ) ; return new ColorMode ( context , type , max , max , max , max ) ; } else if ( elements . length == 4 ) { float r = Float . parseFloat ( elements [ 1 ] . trim ( ) ) ; float g = Float . parseFloat ( elements [ 2 ] . trim ( ) ) ; float b = Float . parseFloat ( elements [ 3 ] . trim ( ) ) ; return new ColorMode ( context , type , r , g , b , 255 ) ; } else if ( elements . length == 5 ) { float r = Float . parseFloat ( elements [ 1 ] . trim ( ) ) ; float g = Float . parseFloat ( elements [ 2 ] . trim ( ) ) ; float b = Float . parseFloat ( elements [ 3 ] . trim ( ) ) ; float a = Float . parseFloat ( elements [ 4 ] . trim ( ) ) ; return new ColorMode ( context , type , r , g , b , a ) ; } } catch ( Exception e ) { } ColorMode newMode = new ColorMode ( context ) ; newMode . unrecognizedMode = true ; return newMode ; } public String toString ( ) { String type ; if ( modeType == RGB ) { type = "RGB" ; } else { type = "HSB" ; } return "ColorMode: " + type + ": (" + v1Max + ", " + v2Max + ", " + v3Max + ", " + aMax + ")" ; } }
package processing . mode . java . pdex ; import java . awt . BorderLayout ; import java . awt . Color ; import java . awt . Component ; import java . awt . Dimension ; import java . awt . FontMetrics ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . Point ; import java . awt . Rectangle ; import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; import javax . swing . DefaultListModel ; import javax . swing . JButton ; import javax . swing . JComponent ; import javax . swing . JLabel ; import javax . swing . JList ; import javax . swing . JPopupMenu ; import javax . swing . JScrollPane ; import javax . swing . ListSelectionModel ; import javax . swing . Painter ; import javax . swing . SwingWorker ; import javax . swing . UIDefaults ; import javax . swing . UIManager ; import javax . swing . plaf . InsetsUIResource ; import javax . swing . plaf . basic . BasicScrollBarUI ; import javax . swing . text . BadLocationException ; import processing . app . Base ; import processing . app . syntax . JEditTextArea ; import processing . mode . java . JavaEditor ; import processing . mode . java . JavaMode ; public class CompletionPanel { private JList < CompletionCandidate > completionList ; private JPopupMenu popupMenu ; private String subWord ; private int insertionPosition ; private JavaTextArea textarea ; private JScrollPane scrollPane ; protected JavaEditor editor ; static protected final int MOUSE_COMPLETION = 10 , KEYBOARD_COMPLETION = 20 ; private boolean horizontalScrollBarVisible = false ; public CompletionPanel ( final JEditTextArea textarea , int position , String subWord , DefaultListModel < CompletionCandidate > items , final Point location , JavaEditor editor ) { this . textarea = ( JavaTextArea ) textarea ; this . editor = editor ; this . insertionPosition = position ; if ( subWord . indexOf ( '.' ) != - 1 ) this . subWord = subWord . substring ( subWord . lastIndexOf ( '.' ) + 1 ) ; else this . subWord = subWord ; popupMenu = new JPopupMenu ( ) ; popupMenu . removeAll ( ) ; popupMenu . setOpaque ( false ) ; popupMenu . setBorder ( null ) ; scrollPane = new JScrollPane ( ) ; styleScrollPane ( ) ; scrollPane . setViewportView ( completionList = createSuggestionList ( position , items ) ) ; popupMenu . add ( scrollPane , BorderLayout . CENTER ) ; popupMenu . setPopupSize ( calcWidth ( ) , calcHeight ( items . getSize ( ) ) ) ; editor . getErrorChecker ( ) . getASTGenerator ( ) . updateJavaDoc ( completionList . getSelectedValue ( ) ) ; textarea . requestFocusInWindow ( ) ; popupMenu . show ( textarea , location . x , textarea . getBaseline ( 0 , 0 ) + location . y ) ; } private void styleScrollPane ( ) { String laf = UIManager . getLookAndFeel ( ) . getID ( ) ; if ( ! laf . equals ( "Nimbus" ) && ! laf . equals ( "Windows" ) ) return ; String thumbColor = null ; if ( laf . equals ( "Nimbus" ) ) { UIDefaults defaults = new UIDefaults ( ) ; defaults . put ( "PopupMenu.contentMargins" , new InsetsUIResource ( 0 , 0 , 0 , 0 ) ) ; defaults . put ( "ScrollPane[Enabled].borderPainter" , new Painter < JComponent > ( ) { public void paint ( Graphics2D g , JComponent t , int w , int h ) { } } ) ; popupMenu . putClientProperty ( "Nimbus.Overrides" , defaults ) ; scrollPane . putClientProperty ( "Nimbus.Overrides" , defaults ) ; thumbColor = "nimbusBlueGrey" ; } else if ( laf . equals ( "Windows" ) ) { thumbColor = "ScrollBar.thumbShadow" ; } scrollPane . getHorizontalScrollBar ( ) . setPreferredSize ( new Dimension ( Integer . MAX_VALUE , 8 ) ) ; scrollPane . getVerticalScrollBar ( ) . setPreferredSize ( new Dimension ( 8 , Integer . MAX_VALUE ) ) ; scrollPane . getHorizontalScrollBar ( ) . setUI ( new CompletionScrollBarUI ( thumbColor ) ) ; scrollPane . getVerticalScrollBar ( ) . setUI ( new CompletionScrollBarUI ( thumbColor ) ) ; } private static class CompletionScrollBarUI extends BasicScrollBarUI { private String thumbColorName ; protected CompletionScrollBarUI ( String thumbColorName ) { this . thumbColorName = thumbColorName ; } @ Override protected void paintThumb ( Graphics g , JComponent c , Rectangle trackBounds ) { g . setColor ( ( Color ) UIManager . get ( thumbColorName ) ) ; g . fillRect ( trackBounds . x , trackBounds . y , trackBounds . width , trackBounds . height ) ; } @ Override protected JButton createDecreaseButton ( int orientation ) { return createZeroButton ( ) ; } @ Override protected JButton createIncreaseButton ( int orientation ) { return createZeroButton ( ) ; } static private JButton createZeroButton ( ) { JButton jbutton = new JButton ( ) ; jbutton . setPreferredSize ( new Dimension ( 0 , 0 ) ) ; jbutton . setMinimumSize ( new Dimension ( 0 , 0 ) ) ; jbutton . setMaximumSize ( new Dimension ( 0 , 0 ) ) ; return jbutton ; } } public boolean isVisible ( ) { return popupMenu . isVisible ( ) ; } public void setInvisible ( ) { popupMenu . setVisible ( false ) ; } private int calcHeight ( int itemCount ) { int maxHeight = 250 ; FontMetrics fm = textarea . getGraphics ( ) . getFontMetrics ( ) ; float itemHeight = Math . max ( ( fm . getHeight ( ) + ( fm . getDescent ( ) ) * 0.5f ) , JavaMode . classIcon . getIconHeight ( ) * 1.2f ) ; if ( horizontalScrollBarVisible ) { itemCount ++ ; } if ( itemCount < 4 ) { itemHeight *= 1.3f ; } float h = itemHeight * ( itemCount ) ; if ( itemCount >= 4 ) { h += itemHeight * 0.3 ; } return Math . min ( maxHeight , ( int ) h ) ; } private int calcWidth ( ) { int maxWidth = 300 ; float min = 0 ; FontMetrics fm = textarea . getGraphics ( ) . getFontMetrics ( ) ; for ( int i = 0 ; i < completionList . getModel ( ) . getSize ( ) ; i ++ ) { float h = fm . stringWidth ( completionList . getModel ( ) . getElementAt ( i ) . getLabel ( ) ) ; min = Math . max ( min , h ) ; } int w = Math . min ( ( int ) min , maxWidth ) ; horizontalScrollBarVisible = ( w == maxWidth ) ; w += JavaMode . classIcon . getIconWidth ( ) ; w += fm . stringWidth ( " " ) ; return w ; } private JList < CompletionCandidate > createSuggestionList ( final int position , final DefaultListModel < CompletionCandidate > items ) { JList < CompletionCandidate > list = new JList < CompletionCandidate > ( items ) ; list . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; list . setSelectedIndex ( 0 ) ; list . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent e ) { if ( e . getClickCount ( ) == 2 ) { insertSelection ( MOUSE_COMPLETION ) ; setInvisible ( ) ; } } } ) ; list . setCellRenderer ( new CustomListRenderer ( ) ) ; list . setFocusable ( false ) ; return list ; } protected boolean insertSelection ( int completionSource ) { if ( completionList . getSelectedValue ( ) != null ) { try { String currentSubword = fetchCurrentSubword ( ) ; int currentSubwordLen = currentSubword == null ? 0 : currentSubword . length ( ) ; String selectedSuggestion = completionList . getSelectedValue ( ) . getCompletionString ( ) ; if ( currentSubword != null ) { selectedSuggestion = selectedSuggestion . substring ( currentSubwordLen ) ; } else { currentSubword = "" ; } String completionString = completionList . getSelectedValue ( ) . getCompletionString ( ) ; if ( selectedSuggestion . endsWith ( " )" ) ) { if ( completionString . endsWith ( " )" ) ) { completionString = completionString . substring ( 0 , completionString . length ( ) - 2 ) + ")" ; } } boolean mouseClickOnOverloadedMethods = false ; if ( completionSource == MOUSE_COMPLETION ) { if ( completionString . endsWith ( "(" ) ) { mouseClickOnOverloadedMethods = true ; } } Base . loge ( subWord + " <= subword, Inserting suggestion=> " + selectedSuggestion + " Current sub: " + currentSubword ) ; if ( currentSubword . length ( ) > 0 ) { textarea . getDocument ( ) . remove ( insertionPosition - currentSubwordLen , currentSubwordLen ) ; } textarea . getDocument ( ) . insertString ( insertionPosition - currentSubwordLen , completionString , null ) ; if ( selectedSuggestion . endsWith ( ")" ) && ! selectedSuggestion . endsWith ( "()" ) ) { int x = selectedSuggestion . indexOf ( ',' ) ; if ( x == - 1 ) { textarea . setCaretPosition ( textarea . getCaretPosition ( ) - 1 ) ; } else { textarea . setCaretPosition ( insertionPosition + x ) ; } } Base . log ( "Suggestion inserted: " + System . currentTimeMillis ( ) ) ; if ( completionList . getSelectedValue ( ) . getLabel ( ) . contains ( "..." ) ) { } else { setInvisible ( ) ; } if ( mouseClickOnOverloadedMethods ) { SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { protected Object doInBackground ( ) throws Exception { ( ( JavaTextArea ) editor . getTextArea ( ) ) . fetchPhrase ( null ) ; return null ; } } ; worker . execute ( ) ; } return true ; } catch ( BadLocationException e1 ) { e1 . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } setInvisible ( ) ; } return false ; } private String fetchCurrentSubword ( ) { JEditTextArea ta = editor . getTextArea ( ) ; int off = ta . getCaretPosition ( ) ; if ( off < 0 ) return null ; int line = ta . getCaretLine ( ) ; if ( line < 0 ) return null ; String s = ta . getLineText ( line ) ; int x = ta . getCaretPosition ( ) - ta . getLineStartOffset ( line ) - 1 , x1 = x - 1 ; if ( x >= s . length ( ) || x < 0 ) return null ; if ( Base . DEBUG ) System . out . print ( " x char: " + s . charAt ( x ) ) ; String word = ( x < s . length ( ) ? s . charAt ( x ) : "" ) + "" ; if ( s . trim ( ) . length ( ) == 1 ) { word = word . trim ( ) ; if ( word . endsWith ( "." ) ) word = word . substring ( 0 , word . length ( ) - 1 ) ; return word ; } if ( word . equals ( "." ) ) return null ; int i = 0 ; while ( true ) { i ++ ; if ( x1 >= 0 ) { if ( Character . isLetterOrDigit ( s . charAt ( x1 ) ) || s . charAt ( x1 ) == '_' ) { word = s . charAt ( x1 -- ) + word ; } else { break ; } } else { break ; } if ( i > 200 ) { break ; } } if ( Character . isDigit ( word . charAt ( 0 ) ) ) return null ; word = word . trim ( ) ; if ( word . endsWith ( "." ) ) word = word . substring ( 0 , word . length ( ) - 1 ) ; return word ; } protected void moveUp ( ) { if ( completionList . getSelectedIndex ( ) == 0 ) { scrollPane . getVerticalScrollBar ( ) . setValue ( scrollPane . getVerticalScrollBar ( ) . getMaximum ( ) ) ; selectIndex ( completionList . getModel ( ) . getSize ( ) - 1 ) ; } else { int index = Math . max ( completionList . getSelectedIndex ( ) - 1 , 0 ) ; selectIndex ( index ) ; int step = scrollPane . getVerticalScrollBar ( ) . getMaximum ( ) / completionList . getModel ( ) . getSize ( ) ; scrollPane . getVerticalScrollBar ( ) . setValue ( scrollPane . getVerticalScrollBar ( ) . getValue ( ) - step ) ; editor . getErrorChecker ( ) . getASTGenerator ( ) . updateJavaDoc ( completionList . getSelectedValue ( ) ) ; } } protected void moveDown ( ) { if ( completionList . getSelectedIndex ( ) == completionList . getModel ( ) . getSize ( ) - 1 ) { scrollPane . getVerticalScrollBar ( ) . setValue ( 0 ) ; selectIndex ( 0 ) ; } else { int index = Math . min ( completionList . getSelectedIndex ( ) + 1 , completionList . getModel ( ) . getSize ( ) - 1 ) ; selectIndex ( index ) ; editor . getErrorChecker ( ) . getASTGenerator ( ) . updateJavaDoc ( completionList . getSelectedValue ( ) ) ; int step = scrollPane . getVerticalScrollBar ( ) . getMaximum ( ) / completionList . getModel ( ) . getSize ( ) ; scrollPane . getVerticalScrollBar ( ) . setValue ( scrollPane . getVerticalScrollBar ( ) . getValue ( ) + step ) ; } } private void selectIndex ( int index ) { completionList . setSelectedIndex ( index ) ; } private static class CustomListRenderer extends javax . swing . DefaultListCellRenderer { public Component getListCellRendererComponent ( JList < ? > list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { JLabel label = ( JLabel ) super . getListCellRendererComponent ( list , value , index , isSelected , cellHasFocus ) ; if ( value instanceof CompletionCandidate ) { CompletionCandidate cc = ( CompletionCandidate ) value ; switch ( cc . getType ( ) ) { case CompletionCandidate . LOCAL_VAR : label . setIcon ( JavaMode . localVarIcon ) ; break ; case CompletionCandidate . LOCAL_FIELD : case CompletionCandidate . PREDEF_FIELD : label . setIcon ( JavaMode . fieldIcon ) ; break ; case CompletionCandidate . LOCAL_METHOD : case CompletionCandidate . PREDEF_METHOD : label . setIcon ( JavaMode . methodIcon ) ; break ; case CompletionCandidate . LOCAL_CLASS : case CompletionCandidate . PREDEF_CLASS : label . setIcon ( JavaMode . classIcon ) ; break ; default : Base . log ( "(CustomListRenderer)Unknown CompletionCandidate type " + cc . getType ( ) ) ; break ; } } else { Base . log ( "(CustomListRenderer)Unknown CompletionCandidate object " + value ) ; } return label ; } } }
package processing . mode . java . pdex ; public class ImportStatement { private String importName ; private int tab ; private int lineNumber ; public ImportStatement ( String importName , int tab , int lineNumber ) { this . importName = importName ; this . tab = tab ; this . lineNumber = lineNumber ; } public String getImportName ( ) { return importName ; } public String getPackageName ( ) { String ret = new String ( importName . trim ( ) ) ; if ( ret . startsWith ( "import " ) ) ret = ret . substring ( 7 ) ; if ( ret . endsWith ( ";" ) ) ret = ret . substring ( 0 , ret . length ( ) - 1 ) ; return ret ; } public int getTab ( ) { return tab ; } public int getLineNumber ( ) { return lineNumber ; } }
package processing . mode . java . pdex ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import org . eclipse . jdt . core . JavaCore ; import org . eclipse . jdt . core . dom . AST ; import org . eclipse . jdt . core . dom . ASTParser ; import org . eclipse . jdt . core . dom . ASTVisitor ; import org . eclipse . jdt . core . dom . CompilationUnit ; import org . eclipse . jdt . core . dom . MethodDeclaration ; import org . eclipse . jdt . core . dom . Modifier ; import org . eclipse . jdt . core . dom . NumberLiteral ; import org . eclipse . jdt . core . dom . SimpleType ; import org . eclipse . jdt . core . dom . rewrite . ASTRewrite ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . Document ; import org . eclipse . text . edits . MalformedTreeException ; import org . eclipse . text . edits . TextEdit ; import processing . mode . java . preproc . PdePreprocessor ; public class XQPreprocessor { private ASTRewrite rewrite = null ; private ArrayList < String > imports ; private ArrayList < ImportStatement > extraImports ; private String [ ] coreImports , defaultImports ; public XQPreprocessor ( ) { PdePreprocessor p = new PdePreprocessor ( null ) ; defaultImports = p . getDefaultImports ( ) ; coreImports = p . getCoreImports ( ) ; } public String doYourThing ( String source , ArrayList < ImportStatement > programImports ) { this . extraImports = programImports ; Document doc = new Document ( source ) ; ASTParser parser = ASTParser . newParser ( AST . JLS8 ) ; parser . setSource ( doc . get ( ) . toCharArray ( ) ) ; parser . setKind ( ASTParser . K_COMPILATION_UNIT ) ; @ SuppressWarnings ( "unchecked" ) Map < String , String > options = JavaCore . getOptions ( ) ; JavaCore . setComplianceOptions ( JavaCore . VERSION_1_8 , options ) ; options . put ( JavaCore . COMPILER_SOURCE , JavaCore . VERSION_1_8 ) ; parser . setCompilerOptions ( options ) ; CompilationUnit cu = ( CompilationUnit ) parser . createAST ( null ) ; cu . recordModifications ( ) ; rewrite = ASTRewrite . create ( cu . getAST ( ) ) ; cu . accept ( new XQASTVisitor ( ) ) ; TextEdit edits = cu . rewrite ( doc , null ) ; try { edits . apply ( doc ) ; } catch ( MalformedTreeException e ) { e . printStackTrace ( ) ; } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } return doc . get ( ) ; } public String prepareImports ( ) { imports = new ArrayList < String > ( ) ; for ( int i = 0 ; i < extraImports . size ( ) ; i ++ ) { imports . add ( new String ( extraImports . get ( i ) . getImportName ( ) ) ) ; } imports . add ( new String ( "// Default Imports" ) ) ; for ( int i = 0 ; i < coreImports . length ; i ++ ) { imports . add ( new String ( "import " + coreImports [ i ] + ";" ) ) ; } for ( int i = 0 ; i < defaultImports . length ; i ++ ) { imports . add ( new String ( "import " + defaultImports [ i ] + ";" ) ) ; } String totalImports = "" ; for ( int i = 0 ; i < imports . size ( ) ; i ++ ) { totalImports += imports . get ( i ) + "\n" ; } totalImports += "\n" ; return totalImports ; } public String prepareImports ( ArrayList < ImportStatement > programImports ) { this . extraImports = programImports ; return prepareImports ( ) ; } private class XQASTVisitor extends ASTVisitor { @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public boolean visit ( MethodDeclaration node ) { if ( node . getReturnType2 ( ) != null ) { } if ( node . modifiers ( ) . size ( ) == 0 && ! node . isConstructor ( ) ) { List newMod = rewrite . getAST ( ) . newModifiers ( Modifier . PUBLIC ) ; node . modifiers ( ) . add ( newMod . get ( 0 ) ) ; } return true ; } public boolean visit ( NumberLiteral node ) { if ( ! node . getToken ( ) . endsWith ( "f" ) && ! node . getToken ( ) . endsWith ( "d" ) ) { for ( int i = 0 ; i < node . getToken ( ) . length ( ) ; i ++ ) { if ( node . getToken ( ) . charAt ( i ) == '.' ) { String s = node . getToken ( ) + "f" ; node . setToken ( s ) ; break ; } } } return true ; } public boolean visit ( SimpleType node ) { if ( node . toString ( ) . equals ( "color" ) ) { System . err . println ( "color type detected! \nThis shouldn't be happening! Please report this as an issue." ) ; } return true ; } } }
package processing . mode . java . pdex ; import com . sun . jdi . VMDisconnectedException ; import com . sun . jdi . event . EventQueue ; import com . sun . jdi . event . EventSet ; import java . util . logging . Level ; import java . util . logging . Logger ; public class VMEventReader extends Thread { EventQueue eventQueue ; VMEventListener listener ; public VMEventReader ( EventQueue eventQueue , VMEventListener listener ) { super ( "VM Event Thread" ) ; this . eventQueue = eventQueue ; this . listener = listener ; } @ Override public void run ( ) { try { while ( true ) { EventSet eventSet = eventQueue . remove ( ) ; listener . vmEvent ( eventSet ) ; } } catch ( VMDisconnectedException e ) { Logger . getLogger ( VMEventReader . class . getName ( ) ) . log ( Level . INFO , "VMEventReader quit on VM disconnect" ) ; } catch ( Exception e ) { Logger . getLogger ( VMEventReader . class . getName ( ) ) . log ( Level . SEVERE , "VMEventReader quit" , e ) ; } } }
package processing . mode . java . pdex ; import java . awt . Component ; import java . awt . Dimension ; import java . awt . FontMetrics ; import java . awt . GridBagLayout ; import java . awt . Point ; import java . awt . event . KeyAdapter ; import java . awt . event . KeyEvent ; import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; import java . awt . event . WindowEvent ; import java . awt . event . WindowFocusListener ; import javax . swing . BoxLayout ; import javax . swing . JFrame ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . JScrollPane ; import javax . swing . JTextField ; import javax . swing . JTree ; import javax . swing . ScrollPaneConstants ; import javax . swing . SwingWorker ; import javax . swing . event . DocumentEvent ; import javax . swing . event . DocumentListener ; import javax . swing . event . TreeSelectionEvent ; import javax . swing . event . TreeSelectionListener ; import javax . swing . tree . DefaultMutableTreeNode ; import javax . swing . tree . DefaultTreeCellRenderer ; import javax . swing . tree . DefaultTreeModel ; import javax . swing . tree . TreeSelectionModel ; import processing . app . SketchCode ; import processing . mode . java . JavaEditor ; public class TabOutline { protected JFrame frmOutlineView ; protected JScrollPane jsp ; protected DefaultMutableTreeNode tabNode ; protected DefaultMutableTreeNode tempNode ; protected JTree tabTree ; protected JTextField searchField ; protected JLabel lblCaption ; protected JavaEditor editor ; protected ErrorCheckerService errorCheckerService ; protected boolean internalSelection = false ; public TabOutline ( ErrorCheckerService ecs ) { errorCheckerService = ecs ; editor = ecs . getEditor ( ) ; createGUI ( ) ; } private void createGUI ( ) { frmOutlineView = new JFrame ( ) ; frmOutlineView . setAlwaysOnTop ( true ) ; frmOutlineView . setUndecorated ( true ) ; Point tp = errorCheckerService . getEditor ( ) . getTextArea ( ) . getLocationOnScreen ( ) ; lblCaption = new JLabel ( "Tabs List (type to filter)" ) ; int minWidth = estimateFrameWidth ( ) ; int maxWidth = ( int ) ( editor . getMinimumSize ( ) . width * 0.9f ) ; frmOutlineView . setLayout ( new BoxLayout ( frmOutlineView . getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; JPanel panelTop = new JPanel ( ) , panelMiddle = new JPanel ( ) , panelBottom = new JPanel ( ) ; panelTop . setLayout ( new GridBagLayout ( ) ) ; panelMiddle . setLayout ( new BoxLayout ( panelMiddle , BoxLayout . Y_AXIS ) ) ; panelBottom . setLayout ( new BoxLayout ( panelBottom , BoxLayout . Y_AXIS ) ) ; lblCaption . setAlignmentX ( Component . LEFT_ALIGNMENT ) ; panelTop . add ( lblCaption ) ; searchField = new JTextField ( ) ; searchField . setMinimumSize ( new Dimension ( minWidth , 25 ) ) ; panelMiddle . add ( searchField ) ; jsp = new JScrollPane ( ) ; populateTabTree ( ) ; jsp . setViewportView ( tabTree ) ; jsp . setVerticalScrollBarPolicy ( ScrollPaneConstants . VERTICAL_SCROLLBAR_AS_NEEDED ) ; jsp . setHorizontalScrollBarPolicy ( ScrollPaneConstants . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; jsp . setMinimumSize ( new Dimension ( minWidth , editor . getTextArea ( ) . getHeight ( ) - 10 ) ) ; jsp . setMaximumSize ( new Dimension ( maxWidth , editor . getTextArea ( ) . getHeight ( ) - 10 ) ) ; panelBottom . add ( jsp ) ; frmOutlineView . add ( panelTop ) ; frmOutlineView . add ( panelMiddle ) ; frmOutlineView . add ( panelBottom ) ; frmOutlineView . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; frmOutlineView . pack ( ) ; frmOutlineView . setBounds ( tp . x + errorCheckerService . getEditor ( ) . getTextArea ( ) . getWidth ( ) - minWidth , tp . y , minWidth , estimateFrameHeight ( ) ) ; frmOutlineView . setMinimumSize ( new Dimension ( minWidth , Math . min ( errorCheckerService . getEditor ( ) . getTextArea ( ) . getHeight ( ) , frmOutlineView . getHeight ( ) ) ) ) ; frmOutlineView . setLocation ( tp . x + errorCheckerService . getEditor ( ) . getTextArea ( ) . getWidth ( ) / 2 - frmOutlineView . getWidth ( ) / 2 , frmOutlineView . getY ( ) + ( editor . getTextArea ( ) . getHeight ( ) - frmOutlineView . getHeight ( ) ) / 2 ) ; DefaultTreeCellRenderer renderer = ( DefaultTreeCellRenderer ) tabTree . getCellRenderer ( ) ; renderer . setLeafIcon ( null ) ; renderer . setClosedIcon ( null ) ; renderer . setOpenIcon ( null ) ; addListeners ( ) ; } private void addListeners ( ) { searchField . addKeyListener ( new KeyAdapter ( ) { public void keyPressed ( KeyEvent evt ) { if ( tabTree . getRowCount ( ) == 0 ) return ; internalSelection = true ; if ( evt . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) { close ( ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_ENTER ) { if ( tabTree . getLastSelectedPathComponent ( ) != null ) { DefaultMutableTreeNode tnode = ( DefaultMutableTreeNode ) tabTree . getLastSelectedPathComponent ( ) ; switchToTab ( tnode . toString ( ) ) ; close ( ) ; } } else if ( evt . getKeyCode ( ) == KeyEvent . VK_UP ) { if ( tabTree . getLastSelectedPathComponent ( ) == null ) { tabTree . setSelectionRow ( 0 ) ; return ; } int x = tabTree . getLeadSelectionRow ( ) - 1 ; int step = jsp . getVerticalScrollBar ( ) . getMaximum ( ) / tabTree . getRowCount ( ) ; if ( x == - 1 ) { x = tabTree . getRowCount ( ) - 1 ; jsp . getVerticalScrollBar ( ) . setValue ( jsp . getVerticalScrollBar ( ) . getMaximum ( ) ) ; } else { jsp . getVerticalScrollBar ( ) . setValue ( ( jsp . getVerticalScrollBar ( ) . getValue ( ) - step ) ) ; } tabTree . setSelectionRow ( x ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_DOWN ) { if ( tabTree . getLastSelectedPathComponent ( ) == null ) { tabTree . setSelectionRow ( 0 ) ; return ; } int x = tabTree . getLeadSelectionRow ( ) + 1 ; int step = jsp . getVerticalScrollBar ( ) . getMaximum ( ) / tabTree . getRowCount ( ) ; if ( x == tabTree . getRowCount ( ) ) { x = 0 ; jsp . getVerticalScrollBar ( ) . setValue ( jsp . getVerticalScrollBar ( ) . getMinimum ( ) ) ; } else { jsp . getVerticalScrollBar ( ) . setValue ( ( jsp . getVerticalScrollBar ( ) . getValue ( ) + step ) ) ; } tabTree . setSelectionRow ( x ) ; } } } ) ; searchField . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { public void insertUpdate ( DocumentEvent e ) { updateSelection ( ) ; } public void removeUpdate ( DocumentEvent e ) { updateSelection ( ) ; } public void changedUpdate ( DocumentEvent e ) { updateSelection ( ) ; } private void updateSelection ( ) { SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { protected Object doInBackground ( ) throws Exception { String text = searchField . getText ( ) . toLowerCase ( ) ; tempNode = new DefaultMutableTreeNode ( ) ; filterTree ( text , tempNode , tabNode ) ; return null ; } protected void done ( ) { tabTree . setModel ( new DefaultTreeModel ( tempNode ) ) ; ( ( DefaultTreeModel ) tabTree . getModel ( ) ) . reload ( ) ; internalSelection = true ; tabTree . setSelectionRow ( 0 ) ; } } ; worker . execute ( ) ; } } ) ; tabTree . addTreeSelectionListener ( new TreeSelectionListener ( ) { public void valueChanged ( TreeSelectionEvent e ) { if ( internalSelection ) { internalSelection = ( false ) ; return ; } SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { protected Object doInBackground ( ) throws Exception { return null ; } protected void done ( ) { if ( tabTree . getLastSelectedPathComponent ( ) == null ) { return ; } DefaultMutableTreeNode tnode = ( DefaultMutableTreeNode ) tabTree . getLastSelectedPathComponent ( ) ; switchToTab ( tnode . toString ( ) ) ; close ( ) ; } } ; worker . execute ( ) ; } } ) ; tabTree . addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent me ) { if ( tabTree . getLastSelectedPathComponent ( ) == null ) { return ; } DefaultMutableTreeNode tnode = ( DefaultMutableTreeNode ) tabTree . getLastSelectedPathComponent ( ) ; switchToTab ( tnode . toString ( ) ) ; close ( ) ; } } ) ; frmOutlineView . addWindowFocusListener ( new WindowFocusListener ( ) { public void windowLostFocus ( WindowEvent e ) { close ( ) ; } public void windowGainedFocus ( WindowEvent e ) { } } ) ; } private void switchToTab ( String tabName ) { for ( SketchCode sc : editor . getSketch ( ) . getCode ( ) ) { if ( sc . getPrettyName ( ) . equals ( tabName ) ) { editor . getSketch ( ) . setCurrentCode ( editor . getSketch ( ) . getCodeIndex ( sc ) ) ; } } } private void populateTabTree ( ) { tabNode = new DefaultMutableTreeNode ( "Tabs" ) ; for ( SketchCode sc : editor . getSketch ( ) . getCode ( ) ) { DefaultMutableTreeNode tab = new DefaultMutableTreeNode ( sc . getPrettyName ( ) ) ; tabNode . add ( tab ) ; } tempNode = tabNode ; tabTree = new JTree ( tabNode ) ; tabTree . getSelectionModel ( ) . setSelectionMode ( TreeSelectionModel . SINGLE_TREE_SELECTION ) ; tabTree . setRootVisible ( false ) ; tabTree . setSelectionRow ( editor . getSketch ( ) . getCurrentCodeIndex ( ) ) ; } protected boolean filterTree ( String prefix , DefaultMutableTreeNode tree , DefaultMutableTreeNode mainTree ) { if ( mainTree . isLeaf ( ) ) { return ( mainTree . getUserObject ( ) . toString ( ) . toLowerCase ( ) . startsWith ( prefix ) ) ; } boolean found = false ; for ( int i = 0 ; i < mainTree . getChildCount ( ) ; i ++ ) { DefaultMutableTreeNode tNode = new DefaultMutableTreeNode ( ( ( DefaultMutableTreeNode ) mainTree . getChildAt ( i ) ) . getUserObject ( ) ) ; if ( filterTree ( prefix , tNode , ( DefaultMutableTreeNode ) mainTree . getChildAt ( i ) ) ) { found = true ; tree . add ( tNode ) ; } } return found ; } private int estimateFrameWidth ( ) { FontMetrics fm = editor . getTextArea ( ) . getGraphics ( ) . getFontMetrics ( ) ; int w = fm . stringWidth ( lblCaption . getText ( ) ) + 10 ; for ( int i = 0 ; i < editor . getSketch ( ) . getCodeCount ( ) ; i ++ ) { w = Math . max ( w , fm . stringWidth ( editor . getSketch ( ) . getCode ( i ) . getPrettyName ( ) ) + 10 ) ; } return w ; } private int estimateFrameHeight ( ) { int textHeight = jsp . getGraphics ( ) . getFontMetrics ( ) . getHeight ( ) + 2 ; int t = Math . max ( 4 , editor . getSketch ( ) . getCodeCount ( ) + 3 ) ; return Math . min ( textHeight * t , frmOutlineView . getHeight ( ) ) ; } public void show ( ) { frmOutlineView . setVisible ( true ) ; } public void close ( ) { frmOutlineView . setVisible ( false ) ; frmOutlineView . dispose ( ) ; } public boolean isVisible ( ) { return frmOutlineView . isVisible ( ) ; } }
package processing . mode . java . pdex ; import java . awt . Color ; import java . awt . FontMetrics ; import java . awt . event . * ; import java . util . List ; import javax . swing . * ; import javax . swing . event . ListSelectionEvent ; import javax . swing . event . ListSelectionListener ; import javax . swing . table . JTableHeader ; import javax . swing . table . TableModel ; import javax . swing . text . BadLocationException ; import processing . app . Base ; import processing . app . Language ; import processing . mode . java . JavaEditor ; public class XQErrorTable extends JTable { JavaEditor editor ; public static final String [ ] columnNames = { Language . text ( "editor.footer.errors.problem" ) , Language . text ( "editor.footer.errors.tab" ) , Language . text ( "editor.footer.errors.line" ) } ; public int [ ] columnWidths = { 600 , 100 , 50 } ; private boolean columnResizing = false ; public XQErrorTable ( final JavaEditor editor ) { this . editor = editor ; for ( int i = 0 ; i < this . getColumnModel ( ) . getColumnCount ( ) ; i ++ ) { getColumnModel ( ) . getColumn ( i ) . setPreferredWidth ( columnWidths [ i ] ) ; } getTableHeader ( ) . setReorderingAllowed ( false ) ; addMouseListener ( new MouseAdapter ( ) { @ Override synchronized public void mouseClicked ( MouseEvent e ) { try { int row = ( ( XQErrorTable ) e . getSource ( ) ) . getSelectedRow ( ) ; editor . getErrorChecker ( ) . scrollToErrorLine ( row ) ; } catch ( Exception e1 ) { Base . log ( "Exception XQErrorTable mouseReleased " + e ) ; } } } ) ; this . addMouseMotionListener ( new MouseMotionAdapter ( ) { @ Override public void mouseMoved ( MouseEvent evt ) { int rowIndex = rowAtPoint ( evt . getPoint ( ) ) ; List < Problem > problemsList = editor . getErrorChecker ( ) . problemsList ; synchronized ( problemsList ) { if ( rowIndex < problemsList . size ( ) ) { Problem p = problemsList . get ( rowIndex ) ; if ( p . getImportSuggestions ( ) != null && p . getImportSuggestions ( ) . length > 0 ) { String t = p . getMessage ( ) + "(Import Suggestions available)" ; FontMetrics fm = getFontMetrics ( getFont ( ) ) ; int x1 = fm . stringWidth ( p . getMessage ( ) ) ; int x2 = fm . stringWidth ( t ) ; if ( evt . getX ( ) > x1 && evt . getX ( ) < x2 ) { String [ ] list = p . getImportSuggestions ( ) ; String className = list [ 0 ] . substring ( list [ 0 ] . lastIndexOf ( '.' ) + 1 ) ; String [ ] temp = new String [ list . length ] ; for ( int i = 0 ; i < list . length ; i ++ ) { temp [ i ] = "<html>Import '" + className + "' <font color=#777777>(" + list [ i ] + ")</font></html>" ; } showImportSuggestion ( temp , evt . getXOnScreen ( ) , evt . getYOnScreen ( ) - 3 * getFont ( ) . getSize ( ) ) ; } } } } } } ) ; this . getTableHeader ( ) . addMouseListener ( new MouseAdapter ( ) { @ Override public void mousePressed ( MouseEvent e ) { columnResizing = true ; } @ Override public void mouseReleased ( MouseEvent e ) { columnResizing = false ; for ( int i = 0 ; i < ( ( JTableHeader ) e . getSource ( ) ) . getColumnModel ( ) . getColumnCount ( ) ; i ++ ) { columnWidths [ i ] = ( ( JTableHeader ) e . getSource ( ) ) . getColumnModel ( ) . getColumn ( i ) . getWidth ( ) ; } } } ) ; ToolTipManager . sharedInstance ( ) . registerComponent ( this ) ; } @ Override public boolean isCellEditable ( int rowIndex , int colIndex ) { return false ; } synchronized public boolean updateTable ( final TableModel tableModel ) { if ( ! this . isVisible ( ) ) { return false ; } SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { protected Object doInBackground ( ) throws Exception { return null ; } protected void done ( ) { try { setModel ( tableModel ) ; for ( int i = 0 ; i < getColumnModel ( ) . getColumnCount ( ) ; i ++ ) { getColumnModel ( ) . getColumn ( i ) . setPreferredWidth ( columnWidths [ i ] ) ; } getTableHeader ( ) . setReorderingAllowed ( false ) ; validate ( ) ; repaint ( ) ; } catch ( Exception e ) { System . out . println ( "Exception at XQErrorTable.updateTable " + e ) ; } } } ; try { if ( ! columnResizing ) { worker . execute ( ) ; } } catch ( Exception e ) { System . out . println ( "ErrorTable updateTable Worker's slacking." + e . getMessage ( ) ) ; } return true ; } JFrame frmImportSuggest ; private void showImportSuggestion ( String list [ ] , int x , int y ) { if ( frmImportSuggest != null ) { return ; } final JList < String > classList = new JList < String > ( list ) ; classList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; frmImportSuggest = new JFrame ( ) ; frmImportSuggest . setUndecorated ( true ) ; frmImportSuggest . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . Y_AXIS ) ) ; panel . setBackground ( Color . WHITE ) ; frmImportSuggest . setBackground ( Color . WHITE ) ; panel . add ( classList ) ; JLabel label = new JLabel ( "<html><div alight = \"left\"><font size = \"2\"><br>(Click to insert)</font></div></html>" ) ; label . setBackground ( Color . WHITE ) ; label . setHorizontalTextPosition ( SwingConstants . LEFT ) ; panel . add ( label ) ; panel . validate ( ) ; frmImportSuggest . getContentPane ( ) . add ( panel ) ; frmImportSuggest . pack ( ) ; classList . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent e ) { if ( classList . getSelectedValue ( ) != null ) { try { String t = classList . getSelectedValue ( ) . trim ( ) ; Base . log ( t ) ; int x = t . indexOf ( '(' ) ; String impString = "import " + t . substring ( x + 1 , t . indexOf ( ')' ) ) + ";\n" ; int ct = editor . getSketch ( ) . getCurrentCodeIndex ( ) ; editor . getSketch ( ) . setCurrentCode ( 0 ) ; editor . getTextArea ( ) . getDocument ( ) . insertString ( 0 , impString , null ) ; editor . getSketch ( ) . setCurrentCode ( ct ) ; } catch ( BadLocationException ble ) { Base . log ( "Failed to insert import" ) ; ble . printStackTrace ( ) ; } } frmImportSuggest . setVisible ( false ) ; frmImportSuggest . dispose ( ) ; frmImportSuggest = null ; } } ) ; frmImportSuggest . addWindowFocusListener ( new WindowFocusListener ( ) { @ Override public void windowLostFocus ( WindowEvent e ) { if ( frmImportSuggest != null ) { frmImportSuggest . dispose ( ) ; frmImportSuggest = null ; } } @ Override public void windowGainedFocus ( WindowEvent e ) { } } ) ; frmImportSuggest . setLocation ( x , y ) ; frmImportSuggest . setBounds ( x , y , 250 , 100 ) ; frmImportSuggest . pack ( ) ; frmImportSuggest . setVisible ( true ) ; } }
package processing . mode . java . pdex ; import java . util . Iterator ; import java . util . List ; import java . util . TreeMap ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import javax . swing . text . BadLocationException ; import javax . swing . text . Element ; import javax . swing . text . PlainDocument ; import org . eclipse . jdt . core . dom . ASTNode ; import org . eclipse . jdt . core . dom . CompilationUnit ; import org . eclipse . jdt . core . dom . ExpressionStatement ; import org . eclipse . jdt . core . dom . FieldDeclaration ; import org . eclipse . jdt . core . dom . Javadoc ; import org . eclipse . jdt . core . dom . MethodDeclaration ; import org . eclipse . jdt . core . dom . MethodInvocation ; import org . eclipse . jdt . core . dom . QualifiedName ; import org . eclipse . jdt . core . dom . SimpleName ; import org . eclipse . jdt . core . dom . SingleVariableDeclaration ; import org . eclipse . jdt . core . dom . StructuralPropertyDescriptor ; import org . eclipse . jdt . core . dom . Type ; import org . eclipse . jdt . core . dom . TypeDeclaration ; import processing . app . Base ; public class ASTNodeWrapper { private ASTNode Node ; private String label ; private int lineNumber ; public ASTNodeWrapper ( ASTNode node ) { if ( node == null ) { return ; } this . Node = node ; label = getNodeAsString ( node ) ; if ( label == null ) label = node . toString ( ) ; lineNumber = getLineNumber ( node ) ; label += " | Line " + lineNumber ; } public ASTNodeWrapper ( ASTNode node , String label ) { if ( node == null ) { return ; } this . Node = node ; if ( label != null ) this . label = label ; else { label = getNodeAsString ( node ) ; if ( label == null ) label = node . toString ( ) ; label += " | Line " + lineNumber ; } lineNumber = getLineNumber ( node ) ; } public int [ ] getJavaCodeOffsets ( ErrorCheckerService ecs ) { int nodeOffset = Node . getStartPosition ( ) , nodeLength = Node . getLength ( ) ; Base . log ( "0.nodeOffset " + nodeOffset ) ; ASTNode thisNode = Node ; while ( thisNode . getParent ( ) != null ) { if ( getLineNumber ( thisNode . getParent ( ) ) == lineNumber ) { thisNode = thisNode . getParent ( ) ; } else { break ; } } int altStartPos = thisNode . getStartPosition ( ) ; Base . log ( "1.Altspos " + altStartPos ) ; thisNode = thisNode . getParent ( ) ; Javadoc jd = null ; if ( thisNode instanceof TypeDeclaration ) { jd = ( ( TypeDeclaration ) thisNode ) . getJavadoc ( ) ; altStartPos = getJavadocOffset ( ( TypeDeclaration ) thisNode ) ; Base . log ( "Has t jdoc " + ( ( TypeDeclaration ) thisNode ) . getJavadoc ( ) ) ; } else if ( thisNode instanceof MethodDeclaration ) { altStartPos = getJavadocOffset ( ( MethodDeclaration ) thisNode ) ; jd = ( ( MethodDeclaration ) thisNode ) . getJavadoc ( ) ; Base . log ( "Has m jdoc " + jd ) ; } else if ( thisNode instanceof FieldDeclaration ) { FieldDeclaration fd = ( ( FieldDeclaration ) thisNode ) ; jd = fd . getJavadoc ( ) ; Base . log ( "Has f jdoc " + fd . getJavadoc ( ) ) ; altStartPos = getJavadocOffset ( fd ) ; } if ( jd == null ) { Base . log ( "Visiting children of node " + getNodeAsString ( thisNode ) ) ; @ SuppressWarnings ( "unchecked" ) Iterator < StructuralPropertyDescriptor > it = thisNode . structuralPropertiesForType ( ) . iterator ( ) ; boolean flag = true ; while ( it . hasNext ( ) ) { StructuralPropertyDescriptor prop = it . next ( ) ; if ( prop . isChildListProperty ( ) ) { @ SuppressWarnings ( "unchecked" ) List < ASTNode > nodelist = ( List < ASTNode > ) thisNode . getStructuralProperty ( prop ) ; Base . log ( "prop " + prop ) ; for ( ASTNode cnode : nodelist ) { Base . log ( "Visiting node " + getNodeAsString ( cnode ) ) ; if ( getLineNumber ( cnode ) == lineNumber ) { if ( flag ) { altStartPos = cnode . getStartPosition ( ) ; flag = false ; } else { if ( cnode == Node ) { break ; } } } } } } Base . log ( "Altspos " + altStartPos ) ; } int pdeoffsets [ ] = getPDECodeOffsets ( ecs ) ; String pdeCode = ecs . getPDECodeAtLine ( pdeoffsets [ 0 ] , pdeoffsets [ 1 ] - 1 ) . trim ( ) ; int vals [ ] = createOffsetMapping ( ecs , pdeCode , nodeOffset - altStartPos , nodeLength ) ; if ( vals != null ) return new int [ ] { lineNumber , nodeOffset + vals [ 0 ] - altStartPos , vals [ 1 ] } ; else { Base . log ( "joff[1] = " + ( nodeOffset - altStartPos ) ) ; return new int [ ] { lineNumber , nodeOffset - altStartPos , nodeLength } ; } } private int getJavadocOffset ( FieldDeclaration fd ) { @ SuppressWarnings ( "unchecked" ) List < ASTNode > list = fd . modifiers ( ) ; SimpleName sn = ( SimpleName ) getNode ( ) ; Type tp = fd . getType ( ) ; int lineNum = getLineNumber ( sn ) ; Base . log ( "SN " + sn + ", " + lineNum ) ; for ( ASTNode astNode : list ) { if ( getLineNumber ( astNode ) == lineNum ) { Base . log ( "first node in that line " + astNode ) ; Base . log ( "diff " + ( sn . getStartPosition ( ) - astNode . getStartPosition ( ) ) ) ; return ( astNode . getStartPosition ( ) ) ; } } if ( getLineNumber ( fd . getType ( ) ) == lineNum ) { Base . log ( "first node in that line " + tp ) ; Base . log ( "diff " + ( sn . getStartPosition ( ) - tp . getStartPosition ( ) ) ) ; return ( tp . getStartPosition ( ) ) ; } return 0 ; } private int getJavadocOffset ( MethodDeclaration md ) { @ SuppressWarnings ( "unchecked" ) List < ASTNode > list = md . modifiers ( ) ; SimpleName sn = ( SimpleName ) getNode ( ) ; int lineNum = getLineNumber ( sn ) ; Base . log ( "SN " + sn + ", " + lineNum ) ; for ( ASTNode astNode : list ) { if ( getLineNumber ( astNode ) == lineNum ) { Base . log ( "first node in that line " + astNode ) ; Base . log ( "diff " + ( sn . getStartPosition ( ) - astNode . getStartPosition ( ) ) ) ; return ( astNode . getStartPosition ( ) ) ; } } if ( ! md . isConstructor ( ) ) { Type tp = md . getReturnType2 ( ) ; if ( getLineNumber ( tp ) == lineNum ) { Base . log ( "first node in that line " + tp ) ; Base . log ( "diff " + ( sn . getStartPosition ( ) - tp . getStartPosition ( ) ) ) ; return ( tp . getStartPosition ( ) ) ; } } return 0 ; } private int getJavadocOffset ( TypeDeclaration td ) { @ SuppressWarnings ( "unchecked" ) List < ASTNode > list = td . modifiers ( ) ; SimpleName sn = ( SimpleName ) getNode ( ) ; int lineNum = getLineNumber ( sn ) ; Base . log ( "SN " + sn + ", " + lineNum ) ; for ( ASTNode astNode : list ) { if ( getLineNumber ( astNode ) == lineNum ) { Base . log ( "first node in that line " + astNode ) ; Base . log ( "diff " + ( sn . getStartPosition ( ) - astNode . getStartPosition ( ) ) ) ; return ( astNode . getStartPosition ( ) ) ; } } if ( td . getJavadoc ( ) != null ) { Base . log ( "diff " + ( td . getJavadoc ( ) . getStartPosition ( ) + td . getJavadoc ( ) . getLength ( ) + 1 ) ) ; return ( td . getJavadoc ( ) . getStartPosition ( ) + td . getJavadoc ( ) . getLength ( ) + 1 ) ; } Base . log ( "getJavadocOffset(TypeDeclaration td) " + sn + ", found nothing. Meh." ) ; return 0 ; } private int [ ] createOffsetMapping ( ErrorCheckerService ecs , String source , int inpOffset , int nodeLen ) { int ret [ ] [ ] = getOffsetMapping ( ecs , source ) ; if ( ret == null ) { return null ; } int javaCodeMap [ ] = ret [ 0 ] ; int pdeCodeMap [ ] = ret [ 1 ] ; int pi = 1 , pj = 1 ; pj = 0 ; pi = 0 ; int count = 1 ; pj = inpOffset ; int startIndex = javaCodeMap [ pj ] ; while ( pdeCodeMap [ pi ] != startIndex && pi < pdeCodeMap . length ) pi ++ ; int startoffDif = pi - pj ; int stopindex = javaCodeMap [ pj + nodeLen - 1 ] ; Base . log ( startIndex + "SI,St" + stopindex + "sod " + startoffDif ) ; while ( pdeCodeMap [ pi ] < stopindex && pi < pdeCodeMap . length ) { pi ++ ; count ++ ; } Base . log ( "pde len " + count ) ; return new int [ ] { startoffDif , count } ; } public int [ ] [ ] getOffsetMapping ( ErrorCheckerService ecs , String source ) { Base . log ( "Src:" + source ) ; String sourceAlt = new String ( source ) ; String sourceJava = ecs . astGenerator . getJavaSourceCodeLine ( lineNumber ) ; TreeMap < Integer , Integer > offsetmap = new TreeMap < Integer , Integer > ( ) ; if ( sourceJava . trim ( ) . startsWith ( "public" ) && ! source . startsWith ( "public" ) ) { offsetmap . put ( 0 , 6 ) ; } final String webColorRegexp = "#{1}[A-F|a-f|0-9]{6}\\W" ; Pattern webPattern = Pattern . compile ( webColorRegexp ) ; Matcher webMatcher = webPattern . matcher ( sourceAlt ) ; while ( webMatcher . find ( ) ) { offsetmap . put ( webMatcher . end ( ) - 1 , 3 ) ; } final String colorTypeRegex = "color(?![a-zA-Z0-9_])(?=\\[*)(?!(\\s*\\())" ; Pattern colorPattern = Pattern . compile ( colorTypeRegex ) ; Matcher colorMatcher = colorPattern . matcher ( sourceAlt ) ; while ( colorMatcher . find ( ) ) { offsetmap . put ( colorMatcher . end ( ) - 1 , - 2 ) ; } String dataTypeFunc [ ] = { "int" , "char" , "float" , "boolean" , "byte" } ; for ( String dataType : dataTypeFunc ) { String dataTypeRegexp = "\\b" + dataType + "\\s*\\(" ; Pattern pattern = Pattern . compile ( dataTypeRegexp ) ; Matcher matcher = pattern . matcher ( sourceAlt ) ; while ( matcher . find ( ) ) { offsetmap . put ( matcher . end ( ) - 1 , ( "PApplet.parse" ) . length ( ) ) ; } matcher . reset ( ) ; sourceAlt = matcher . replaceAll ( "PApplet.parse" + Character . toUpperCase ( dataType . charAt ( 0 ) ) + dataType . substring ( 1 ) + "(" ) ; } if ( offsetmap . isEmpty ( ) ) { Base . log ( "No offset matching needed." ) ; return null ; } webMatcher = webPattern . matcher ( sourceAlt ) ; while ( webMatcher . find ( ) ) { String found = sourceAlt . substring ( webMatcher . start ( ) , webMatcher . end ( ) ) ; sourceAlt = webMatcher . replaceFirst ( "0xff" + found . substring ( 1 ) ) ; webMatcher = webPattern . matcher ( sourceAlt ) ; } colorMatcher = colorPattern . matcher ( sourceAlt ) ; sourceAlt = colorMatcher . replaceAll ( "int" ) ; Base . log ( "From direct source: " ) ; Base . log ( sourceAlt ) ; int javaCodeMap [ ] = new int [ source . length ( ) * 2 ] ; int pdeCodeMap [ ] = new int [ source . length ( ) * 2 ] ; int pi = 1 , pj = 1 ; int keySum = 0 ; for ( Integer key : offsetmap . keySet ( ) ) { for ( ; pi < key + keySum ; pi ++ ) { javaCodeMap [ pi ] = javaCodeMap [ pi - 1 ] + 1 ; } for ( ; pj < key ; pj ++ ) { pdeCodeMap [ pj ] = pdeCodeMap [ pj - 1 ] + 1 ; } Base . log ( key + ":" + offsetmap . get ( key ) ) ; int kval = offsetmap . get ( key ) ; if ( kval > 0 ) { pi -- ; pj -- ; for ( int i = 0 ; i < kval ; i ++ , pi ++ , pj ++ ) { if ( pi > 1 && pj > 1 ) { javaCodeMap [ pi ] = javaCodeMap [ pi - 1 ] ; pdeCodeMap [ pj ] = pdeCodeMap [ pj - 1 ] + 1 ; } } } else { pi -- ; pj -- ; for ( int i = 0 ; i < - kval ; i ++ , pi ++ , pj ++ ) { if ( pi > 1 && pj > 1 ) { javaCodeMap [ pi ] = javaCodeMap [ pi - 1 ] + 1 ; pdeCodeMap [ pj ] = pdeCodeMap [ pj - 1 ] ; } } } keySum += kval ; } javaCodeMap [ pi ] = javaCodeMap [ pi - 1 ] + 1 ; pdeCodeMap [ pj ] = pdeCodeMap [ pj - 1 ] + 1 ; while ( pi < sourceAlt . length ( ) ) { javaCodeMap [ pi ] = javaCodeMap [ pi - 1 ] + 1 ; pi ++ ; } while ( pj < source . length ( ) ) { pdeCodeMap [ pj ] = pdeCodeMap [ pj - 1 ] + 1 ; pj ++ ; } if ( Base . DEBUG ) { for ( int i = 0 ; i < pdeCodeMap . length ; i ++ ) { if ( pdeCodeMap [ i ] > 0 || javaCodeMap [ i ] > 0 || i == 0 ) { if ( i < source . length ( ) ) System . out . print ( source . charAt ( i ) ) ; System . out . print ( pdeCodeMap [ i ] + " - " + javaCodeMap [ i ] ) ; if ( i < sourceAlt . length ( ) ) System . out . print ( sourceAlt . charAt ( i ) ) ; System . out . print ( " <-[" + i + "]" ) ; System . out . println ( ) ; } } System . out . println ( ) ; } return new int [ ] [ ] { javaCodeMap , pdeCodeMap } ; } public boolean highlightNode ( ASTGenerator astGenerator ) { if ( ! ( Node instanceof SimpleName ) ) { return false ; } SimpleName nodeName = ( SimpleName ) Node ; try { int javaLineNumber = getLineNumber ( nodeName ) ; int pdeOffs [ ] = astGenerator . errorCheckerService . calculateTabIndexAndLineNumber ( javaLineNumber ) ; PlainDocument javaSource = new PlainDocument ( ) ; javaSource . insertString ( 0 , astGenerator . errorCheckerService . sourceCode , null ) ; Element lineElement = javaSource . getDefaultRootElement ( ) . getElement ( javaLineNumber - 1 ) ; if ( lineElement == null ) { Base . log ( lineNumber + " line element null while highlighting " + nodeName ) ; return false ; } String javaLine = javaSource . getText ( lineElement . getStartOffset ( ) , lineElement . getEndOffset ( ) - lineElement . getStartOffset ( ) ) ; astGenerator . editor . getSketch ( ) . setCurrentCode ( pdeOffs [ 0 ] ) ; String pdeLine = astGenerator . editor . getLineText ( pdeOffs [ 1 ] ) ; String lookingFor = nodeName . toString ( ) ; Base . log ( lookingFor + ", " + nodeName . getStartPosition ( ) ) ; Base . log ( javaLineNumber + " JL " + javaLine + " LSO " + lineElement . getStartOffset ( ) + "," + lineElement . getEndOffset ( ) ) ; Base . log ( pdeOffs [ 1 ] + " PL " + pdeLine ) ; if ( ! javaLine . contains ( lookingFor ) || ! pdeLine . contains ( lookingFor ) ) { Base . loge ( "Logical error in highLightNode(). Please file a bug report." ) ; return false ; } OffsetMatcher ofm = new OffsetMatcher ( pdeLine , javaLine ) ; int highlightStart = ofm . getPdeOffForJavaOff ( nodeName . getStartPosition ( ) - lineElement . getStartOffset ( ) , nodeName . getLength ( ) ) ; if ( highlightStart == - 1 ) { Base . loge ( "Logical error in highLightNode() during offset matching. " + "Please file a bug report." ) ; return false ; } int lso = astGenerator . editor . getTextArea ( ) . getLineStartOffset ( pdeOffs [ 1 ] ) ; highlightStart += lso ; astGenerator . editor . setSelection ( highlightStart , highlightStart + nodeName . getLength ( ) ) ; return true ; } catch ( BadLocationException e ) { Base . loge ( "BLE in highLightNode() for " + nodeName ) ; e . printStackTrace ( ) ; } return false ; } public int [ ] [ ] getOffsetMapping ( ErrorCheckerService ecs ) { int pdeoffsets [ ] = getPDECodeOffsets ( ecs ) ; String pdeCode = ecs . getPDECodeAtLine ( pdeoffsets [ 0 ] , pdeoffsets [ 1 ] - 1 ) . trim ( ) ; return getOffsetMapping ( ecs , pdeCode ) ; } public int [ ] getPDECodeOffsets ( ErrorCheckerService ecs ) { return ecs . JavaToPdeOffsets ( lineNumber + 1 , Node . getStartPosition ( ) ) ; } public int getPDECodeOffsetForSN ( ASTGenerator astGen ) { if ( Node instanceof SimpleName ) { Element lineElement = astGen . getJavaSourceCodeElement ( lineNumber ) ; Base . log ( "Line element off " + lineElement . getStartOffset ( ) ) ; OffsetMatcher ofm = new OffsetMatcher ( astGen . getPDESourceCodeLine ( lineNumber ) , astGen . getJavaSourceCodeLine ( lineNumber ) ) ; int pdeOffset = ofm . getPdeOffForJavaOff ( Node . getStartPosition ( ) - lineElement . getStartOffset ( ) , Node . toString ( ) . length ( ) ) ; return pdeOffset ; } return - 1 ; } public String toString ( ) { return label ; } public ASTNode getNode ( ) { return Node ; } public String getLabel ( ) { return label ; } public int getNodeType ( ) { return Node . getNodeType ( ) ; } public int getLineNumber ( ) { return lineNumber ; } public static String getJavaCode ( String source ) { Base . log ( "Src:" + source ) ; String sourceAlt = new String ( source ) ; final String webColorRegexp = "#{1}[A-F|a-f|0-9]{6}\\W" ; Pattern webPattern = Pattern . compile ( webColorRegexp ) ; Matcher webMatcher = webPattern . matcher ( sourceAlt ) ; while ( webMatcher . find ( ) ) { } final String colorTypeRegex = "color(?![a-zA-Z0-9_])(?=\\[*)(?!(\\s*\\())" ; Pattern colorPattern = Pattern . compile ( colorTypeRegex ) ; Matcher colorMatcher = colorPattern . matcher ( sourceAlt ) ; while ( colorMatcher . find ( ) ) { } String dataTypeFunc [ ] = { "int" , "char" , "float" , "boolean" , "byte" } ; for ( String dataType : dataTypeFunc ) { String dataTypeRegexp = "\\b" + dataType + "\\s*\\(" ; Pattern pattern = Pattern . compile ( dataTypeRegexp ) ; Matcher matcher = pattern . matcher ( sourceAlt ) ; while ( matcher . find ( ) ) { } matcher . reset ( ) ; sourceAlt = matcher . replaceAll ( "PApplet.parse" + Character . toUpperCase ( dataType . charAt ( 0 ) ) + dataType . substring ( 1 ) + "(" ) ; } webMatcher = webPattern . matcher ( sourceAlt ) ; while ( webMatcher . find ( ) ) { String found = sourceAlt . substring ( webMatcher . start ( ) , webMatcher . end ( ) ) ; sourceAlt = webMatcher . replaceFirst ( "0xff" + found . substring ( 1 ) ) ; webMatcher = webPattern . matcher ( sourceAlt ) ; } colorMatcher = colorPattern . matcher ( sourceAlt ) ; sourceAlt = colorMatcher . replaceAll ( "int" ) ; Base . log ( "Converted:" + sourceAlt ) ; return sourceAlt ; } private static int getLineNumber ( ASTNode node ) { return ( ( CompilationUnit ) node . getRoot ( ) ) . getLineNumber ( node . getStartPosition ( ) ) ; } static private String getNodeAsString ( ASTNode node ) { if ( node == null ) return "NULL" ; String className = node . getClass ( ) . getName ( ) ; int index = className . lastIndexOf ( "." ) ; if ( index > 0 ) className = className . substring ( index + 1 ) ; String value = className ; if ( node instanceof TypeDeclaration ) value = ( ( TypeDeclaration ) node ) . getName ( ) . toString ( ) + " | " + className ; else if ( node instanceof MethodDeclaration ) value = ( ( MethodDeclaration ) node ) . getName ( ) . toString ( ) + " | " + className ; else if ( node instanceof MethodInvocation ) value = ( ( MethodInvocation ) node ) . getName ( ) . toString ( ) + " | " + className ; else if ( node instanceof FieldDeclaration ) value = ( ( FieldDeclaration ) node ) . toString ( ) + " FldDecl| " ; else if ( node instanceof SingleVariableDeclaration ) value = ( ( SingleVariableDeclaration ) node ) . getName ( ) + " - " + ( ( SingleVariableDeclaration ) node ) . getType ( ) + " | SVD " ; else if ( node instanceof ExpressionStatement ) value = node . toString ( ) + className ; else if ( node instanceof SimpleName ) value = ( ( SimpleName ) node ) . getFullyQualifiedName ( ) + " | " + className ; else if ( node instanceof QualifiedName ) value = node . toString ( ) + " | " + className ; else if ( className . startsWith ( "Variable" ) ) value = node . toString ( ) + " | " + className ; else if ( className . endsWith ( "Type" ) ) value = node . toString ( ) + " |" + className ; value += " [" + node . getStartPosition ( ) + "," + ( node . getStartPosition ( ) + node . getLength ( ) ) + "]" ; value += " Line: " + ( ( CompilationUnit ) node . getRoot ( ) ) . getLineNumber ( node . getStartPosition ( ) ) ; return value ; } }
package processing . core ; public class PGraphicsDanger2D extends PGraphicsJava2D { @ Override public PSurface createSurface ( ) { return surface = new PSurfaceDanger ( this ) ; } @ Override public void beginDraw ( ) { smooth ( smooth ) ; checkSettings ( ) ; resetMatrix ( ) ; vertexCount = 0 ; } @ Override public void loadPixels ( ) { nope ( "loadPixels" ) ; } @ Override public void updatePixels ( ) { nope ( "updatePixels" ) ; } @ Override public void updatePixels ( int x , int y , int c , int d ) { nope ( "updatePixels" ) ; } @ Override public int get ( int x , int y ) { nope ( "get" ) ; return 0 ; } @ Override public PImage get ( int x , int y , int c , int d ) { nope ( "get" ) ; return null ; } @ Override public PImage get ( ) { nope ( "get" ) ; return null ; } @ Override public void set ( int x , int y , int argb ) { nope ( "set" ) ; } @ Override public void set ( int x , int y , PImage image ) { nope ( "set" ) ; } @ Override public void mask ( int alpha [ ] ) { nope ( "mask" ) ; } @ Override public void mask ( PImage alpha ) { nope ( "mask" ) ; } @ Override public void filter ( int kind ) { nope ( "filter" ) ; } @ Override public void filter ( int kind , float param ) { nope ( "filter" ) ; } @ Override public void copy ( int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 , int dx2 , int dy2 ) { nope ( "copy" ) ; } @ Override public void copy ( PImage src , int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 , int dx2 , int dy2 ) { nope ( "copy" ) ; } public void blend ( int sx , int sy , int dx , int dy , int mode ) { nope ( "blend" ) ; } public void blend ( PImage src , int sx , int sy , int dx , int dy , int mode ) { nope ( "blend" ) ; } @ Override public void blend ( int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 , int dx2 , int dy2 , int mode ) { nope ( "blend" ) ; } @ Override public void blend ( PImage src , int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 , int dx2 , int dy2 , int mode ) { nope ( "blend" ) ; } @ Override public boolean save ( String filename ) { nope ( "save" ) ; return false ; } protected void nope ( String function ) { throw new RuntimeException ( function + "() is unavailable with E2D" ) ; } }
package processing . mode . java . pdex ; import java . awt . Component ; import java . awt . Dimension ; import java . awt . Point ; import java . awt . event . KeyAdapter ; import java . awt . event . KeyEvent ; import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; import java . awt . event . WindowEvent ; import java . awt . event . WindowFocusListener ; import java . util . List ; import javax . swing . BoxLayout ; import javax . swing . Icon ; import javax . swing . ImageIcon ; import javax . swing . JFrame ; import javax . swing . JPanel ; import javax . swing . JScrollPane ; import javax . swing . JTextField ; import javax . swing . JTree ; import javax . swing . ScrollPaneConstants ; import javax . swing . SwingWorker ; import javax . swing . event . DocumentEvent ; import javax . swing . event . DocumentListener ; import javax . swing . event . TreeSelectionEvent ; import javax . swing . event . TreeSelectionListener ; import javax . swing . tree . DefaultMutableTreeNode ; import javax . swing . tree . DefaultTreeCellRenderer ; import javax . swing . tree . DefaultTreeModel ; import javax . swing . tree . TreeSelectionModel ; import org . eclipse . jdt . core . dom . ASTNode ; import org . eclipse . jdt . core . dom . FieldDeclaration ; import org . eclipse . jdt . core . dom . MethodDeclaration ; import org . eclipse . jdt . core . dom . TypeDeclaration ; import org . eclipse . jdt . core . dom . VariableDeclarationFragment ; import processing . app . Mode ; import processing . mode . java . JavaEditor ; public class SketchOutline { protected JFrame frmOutlineView ; protected ErrorCheckerService errorCheckerService ; protected JScrollPane jsp ; protected DefaultMutableTreeNode soNode , tempNode ; protected final JTree soTree ; protected JTextField searchField ; protected JavaEditor editor ; protected boolean internalSelection = false ; ImageIcon classIcon , fieldIcon , methodIcon ; public SketchOutline ( DefaultMutableTreeNode codeTree , ErrorCheckerService ecs ) { errorCheckerService = ecs ; editor = ecs . getEditor ( ) ; soNode = new DefaultMutableTreeNode ( ) ; generateSketchOutlineTree ( soNode , codeTree ) ; soNode = ( DefaultMutableTreeNode ) soNode . getChildAt ( 0 ) ; tempNode = soNode ; soTree = new JTree ( soNode ) ; Mode mode = editor . getMode ( ) ; classIcon = mode . loadIcon ( "theme/icon_class_obj.png" ) ; methodIcon = mode . loadIcon ( "theme/icon_methpub_obj.png" ) ; fieldIcon = mode . loadIcon ( "theme/icon_field_protected_obj.png" ) ; createGUI ( ) ; } private void createGUI ( ) { frmOutlineView = new JFrame ( ) ; frmOutlineView . setAlwaysOnTop ( true ) ; frmOutlineView . setUndecorated ( true ) ; Point tp = errorCheckerService . getEditor ( ) . getTextArea ( ) . getLocationOnScreen ( ) ; int minWidth = ( int ) ( editor . getMinimumSize ( ) . width * 0.7f ) ; int maxWidth = ( int ) ( editor . getMinimumSize ( ) . width * 0.9f ) ; frmOutlineView . setLayout ( new BoxLayout ( frmOutlineView . getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; JPanel panelTop = new JPanel ( ) , panelBottom = new JPanel ( ) ; panelTop . setLayout ( new BoxLayout ( panelTop , BoxLayout . Y_AXIS ) ) ; panelBottom . setLayout ( new BoxLayout ( panelBottom , BoxLayout . Y_AXIS ) ) ; searchField = new JTextField ( ) ; searchField . setMinimumSize ( new Dimension ( minWidth , 25 ) ) ; panelTop . add ( searchField ) ; jsp = new JScrollPane ( ) ; soTree . getSelectionModel ( ) . setSelectionMode ( TreeSelectionModel . SINGLE_TREE_SELECTION ) ; soTree . setRootVisible ( false ) ; soTree . setCellRenderer ( new CustomCellRenderer ( ) ) ; for ( int i = 0 ; i < soTree . getRowCount ( ) ; i ++ ) { soTree . expandRow ( i ) ; } soTree . setSelectionRow ( 0 ) ; jsp . setViewportView ( soTree ) ; jsp . setVerticalScrollBarPolicy ( ScrollPaneConstants . VERTICAL_SCROLLBAR_AS_NEEDED ) ; jsp . setHorizontalScrollBarPolicy ( ScrollPaneConstants . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; jsp . setMinimumSize ( new Dimension ( minWidth , editor . getTextArea ( ) . getHeight ( ) - 10 ) ) ; jsp . setMaximumSize ( new Dimension ( maxWidth , editor . getTextArea ( ) . getHeight ( ) - 10 ) ) ; panelBottom . add ( jsp ) ; frmOutlineView . add ( panelTop ) ; frmOutlineView . add ( panelBottom ) ; frmOutlineView . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; frmOutlineView . pack ( ) ; frmOutlineView . setBounds ( tp . x + errorCheckerService . getEditor ( ) . getTextArea ( ) . getWidth ( ) - minWidth , tp . y , minWidth , Math . min ( editor . getTextArea ( ) . getHeight ( ) , frmOutlineView . getHeight ( ) ) ) ; frmOutlineView . setMinimumSize ( new Dimension ( minWidth , Math . min ( errorCheckerService . getEditor ( ) . getTextArea ( ) . getHeight ( ) , frmOutlineView . getHeight ( ) ) ) ) ; frmOutlineView . setLocation ( tp . x + errorCheckerService . getEditor ( ) . getTextArea ( ) . getWidth ( ) / 2 - frmOutlineView . getWidth ( ) / 2 , frmOutlineView . getY ( ) + ( editor . getTextArea ( ) . getHeight ( ) - frmOutlineView . getHeight ( ) ) / 2 ) ; addListeners ( ) ; } protected void addListeners ( ) { searchField . addKeyListener ( new KeyAdapter ( ) { public void keyPressed ( KeyEvent evt ) { if ( soTree . getRowCount ( ) == 0 ) return ; internalSelection = true ; if ( evt . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) { close ( ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_ENTER ) { if ( soTree . getLastSelectedPathComponent ( ) != null ) { DefaultMutableTreeNode tnode = ( DefaultMutableTreeNode ) soTree . getLastSelectedPathComponent ( ) ; if ( tnode . getUserObject ( ) instanceof ASTNodeWrapper ) { ASTNodeWrapper awrap = ( ASTNodeWrapper ) tnode . getUserObject ( ) ; awrap . highlightNode ( errorCheckerService . astGenerator ) ; close ( ) ; } } } else if ( evt . getKeyCode ( ) == KeyEvent . VK_UP ) { if ( soTree . getLastSelectedPathComponent ( ) == null ) { soTree . setSelectionRow ( 0 ) ; return ; } int x = soTree . getLeadSelectionRow ( ) - 1 ; int step = jsp . getVerticalScrollBar ( ) . getMaximum ( ) / soTree . getRowCount ( ) ; if ( x == - 1 ) { x = soTree . getRowCount ( ) - 1 ; jsp . getVerticalScrollBar ( ) . setValue ( jsp . getVerticalScrollBar ( ) . getMaximum ( ) ) ; } else { jsp . getVerticalScrollBar ( ) . setValue ( ( jsp . getVerticalScrollBar ( ) . getValue ( ) - step ) ) ; } soTree . setSelectionRow ( x ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_DOWN ) { if ( soTree . getLastSelectedPathComponent ( ) == null ) { soTree . setSelectionRow ( 0 ) ; return ; } int x = soTree . getLeadSelectionRow ( ) + 1 ; int step = jsp . getVerticalScrollBar ( ) . getMaximum ( ) / soTree . getRowCount ( ) ; if ( x == soTree . getRowCount ( ) ) { x = 0 ; jsp . getVerticalScrollBar ( ) . setValue ( jsp . getVerticalScrollBar ( ) . getMinimum ( ) ) ; } else { jsp . getVerticalScrollBar ( ) . setValue ( ( jsp . getVerticalScrollBar ( ) . getValue ( ) + step ) ) ; } soTree . setSelectionRow ( x ) ; } } } ) ; searchField . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { public void insertUpdate ( DocumentEvent e ) { updateSelection ( ) ; } public void removeUpdate ( DocumentEvent e ) { updateSelection ( ) ; } public void changedUpdate ( DocumentEvent e ) { updateSelection ( ) ; } private void updateSelection ( ) { SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { protected Object doInBackground ( ) throws Exception { String text = searchField . getText ( ) . toLowerCase ( ) ; tempNode = new DefaultMutableTreeNode ( ) ; filterTree ( text , tempNode , soNode ) ; return null ; } protected void done ( ) { soTree . setModel ( new DefaultTreeModel ( tempNode ) ) ; ( ( DefaultTreeModel ) soTree . getModel ( ) ) . reload ( ) ; for ( int i = 0 ; i < soTree . getRowCount ( ) ; i ++ ) { soTree . expandRow ( i ) ; } internalSelection = true ; soTree . setSelectionRow ( 0 ) ; } } ; worker . execute ( ) ; } } ) ; frmOutlineView . addWindowFocusListener ( new WindowFocusListener ( ) { public void windowLostFocus ( WindowEvent e ) { close ( ) ; } public void windowGainedFocus ( WindowEvent e ) { } } ) ; soTree . addTreeSelectionListener ( new TreeSelectionListener ( ) { public void valueChanged ( TreeSelectionEvent e ) { if ( internalSelection ) { internalSelection = ( false ) ; return ; } scrollToNode ( ) ; } } ) ; soTree . addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent me ) { scrollToNode ( ) ; } } ) ; } private void scrollToNode ( ) { SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { protected Object doInBackground ( ) throws Exception { return null ; } protected void done ( ) { if ( soTree . getLastSelectedPathComponent ( ) == null ) { return ; } DefaultMutableTreeNode tnode = ( DefaultMutableTreeNode ) soTree . getLastSelectedPathComponent ( ) ; if ( tnode . getUserObject ( ) instanceof ASTNodeWrapper ) { ASTNodeWrapper awrap = ( ASTNodeWrapper ) tnode . getUserObject ( ) ; awrap . highlightNode ( errorCheckerService . astGenerator ) ; close ( ) ; } } } ; worker . execute ( ) ; } protected boolean filterTree ( String prefix , DefaultMutableTreeNode tree , DefaultMutableTreeNode mainTree ) { if ( mainTree . isLeaf ( ) ) { return mainTree . getUserObject ( ) . toString ( ) . toLowerCase ( ) . startsWith ( prefix ) ; } boolean found = false ; for ( int i = 0 ; i < mainTree . getChildCount ( ) ; i ++ ) { DefaultMutableTreeNode tNode = new DefaultMutableTreeNode ( ( ( DefaultMutableTreeNode ) mainTree . getChildAt ( i ) ) . getUserObject ( ) ) ; if ( filterTree ( prefix , tNode , ( DefaultMutableTreeNode ) mainTree . getChildAt ( i ) ) ) { found = true ; tree . add ( tNode ) ; } } return found ; } @ SuppressWarnings ( "unchecked" ) protected void generateSketchOutlineTree ( DefaultMutableTreeNode node , DefaultMutableTreeNode codetree ) { if ( codetree == null ) return ; if ( ! ( codetree . getUserObject ( ) instanceof ASTNodeWrapper ) ) return ; ASTNodeWrapper awnode = ( ASTNodeWrapper ) codetree . getUserObject ( ) , aw2 = null ; if ( awnode . getNode ( ) instanceof TypeDeclaration ) { aw2 = new ASTNodeWrapper ( ( ( TypeDeclaration ) awnode . getNode ( ) ) . getName ( ) , ( ( TypeDeclaration ) awnode . getNode ( ) ) . getName ( ) . toString ( ) ) ; } else if ( awnode . getNode ( ) instanceof MethodDeclaration ) { aw2 = new ASTNodeWrapper ( ( ( MethodDeclaration ) awnode . getNode ( ) ) . getName ( ) , new CompletionCandidate ( ( ( MethodDeclaration ) awnode . getNode ( ) ) ) . toString ( ) ) ; } else if ( awnode . getNode ( ) instanceof FieldDeclaration ) { FieldDeclaration fd = ( FieldDeclaration ) awnode . getNode ( ) ; for ( VariableDeclarationFragment vdf : ( List < VariableDeclarationFragment > ) fd . fragments ( ) ) { final String text = new CompletionCandidate ( vdf ) . toString ( ) ; DefaultMutableTreeNode newNode = new DefaultMutableTreeNode ( new ASTNodeWrapper ( vdf . getName ( ) , text ) ) ; node . add ( newNode ) ; } return ; } if ( aw2 == null ) return ; DefaultMutableTreeNode newNode = new DefaultMutableTreeNode ( aw2 ) ; node . add ( newNode ) ; for ( int i = 0 ; i < codetree . getChildCount ( ) ; i ++ ) { generateSketchOutlineTree ( newNode , ( DefaultMutableTreeNode ) codetree . getChildAt ( i ) ) ; } } public void show ( ) { frmOutlineView . setVisible ( true ) ; } public void close ( ) { frmOutlineView . setVisible ( false ) ; frmOutlineView . dispose ( ) ; } public boolean isVisible ( ) { return frmOutlineView . isVisible ( ) ; } protected class CustomCellRenderer extends DefaultTreeCellRenderer { public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean sel , boolean expanded , boolean leaf , int row , boolean hasFocus ) { super . getTreeCellRendererComponent ( tree , value , sel , expanded , leaf , row , hasFocus ) ; if ( value instanceof DefaultMutableTreeNode ) setIcon ( getTreeIcon ( value ) ) ; return this ; } public Icon getTreeIcon ( Object o ) { if ( ( ( DefaultMutableTreeNode ) o ) . getUserObject ( ) instanceof ASTNodeWrapper ) { ASTNodeWrapper awrap = ( ASTNodeWrapper ) ( ( DefaultMutableTreeNode ) o ) . getUserObject ( ) ; int type = awrap . getNode ( ) . getParent ( ) . getNodeType ( ) ; if ( type == ASTNode . METHOD_DECLARATION ) { return methodIcon ; } else if ( type == ASTNode . TYPE_DECLARATION ) { return classIcon ; } else if ( type == ASTNode . VARIABLE_DECLARATION_FRAGMENT ) { return fieldIcon ; } } return null ; } } }
package processing . mode . java . pdex ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . TreeMap ; import org . eclipse . jdt . core . compiler . IProblem ; import org . eclipse . jdt . internal . compiler . problem . DefaultProblem ; import processing . app . Language ; import processing . core . PApplet ; import processing . data . StringList ; public class ErrorMessageSimplifier { private static TreeMap < Integer , String > constantsMap ; public ErrorMessageSimplifier ( ) { new Thread ( ) { public void run ( ) { prepareConstantsList ( ) ; } } . start ( ) ; } private static void prepareConstantsList ( ) { constantsMap = new TreeMap < Integer , String > ( ) ; Class < DefaultProblem > probClass = DefaultProblem . class ; Field f [ ] = probClass . getFields ( ) ; for ( Field field : f ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) ) try { Object val = field . get ( null ) ; if ( val instanceof Integer ) { constantsMap . put ( ( Integer ) ( val ) , field . getName ( ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; break ; } } } public static String getIDName ( int id ) { if ( constantsMap == null ) { prepareConstantsList ( ) ; } return constantsMap . get ( id ) ; } public static String getSimplifiedErrorMessage ( Problem problem ) { if ( problem == null ) return null ; IProblem iprob = problem . getIProblem ( ) ; String args [ ] = iprob . getArguments ( ) ; String result = null ; switch ( iprob . getID ( ) ) { case IProblem . ParsingError : if ( args . length > 0 ) { result = Language . interpolate ( "editor.status.error_on" , args [ 0 ] ) ; } break ; case IProblem . ParsingErrorDeleteToken : if ( args . length > 0 ) { result = Language . interpolate ( "editor.status.error_on" , args [ 0 ] ) ; } break ; case IProblem . ParsingErrorInsertToComplete : if ( args . length > 0 ) { if ( args [ 0 ] . length ( ) == 1 ) { result = getErrorMessageForBracket ( args [ 0 ] . charAt ( 0 ) ) ; } else { if ( args [ 0 ] . equals ( "AssignmentOperator Expression" ) ) { result = Language . interpolate ( "editor.status.missing.add" , "=" ) ; } else if ( args [ 0 ] . equalsIgnoreCase ( ") Statement" ) ) { result = getErrorMessageForBracket ( args [ 0 ] . charAt ( 0 ) ) ; } else { result = Language . interpolate ( "editor.status.error_on" , args [ 0 ] ) ; } } } break ; case IProblem . ParsingErrorInvalidToken : if ( args . length > 0 ) { if ( args [ 1 ] . equals ( "VariableDeclaratorId" ) ) { if ( args [ 0 ] . equals ( "int" ) ) { result = Language . text ( "editor.status.reserved_words" ) ; } else { result = Language . interpolate ( "editor.status.error_on" , args [ 0 ] ) ; } } else { result = Language . interpolate ( "editor.status.error_on" , args [ 0 ] ) ; } } break ; case IProblem . ParsingErrorInsertTokenAfter : if ( args . length > 0 ) { if ( args [ 1 ] . length ( ) == 1 ) { result = getErrorMessageForBracket ( args [ 1 ] . charAt ( 0 ) ) ; } else { if ( args [ 1 ] . equalsIgnoreCase ( "Statement" ) ) { result = Language . interpolate ( "editor.status.error_on" , args [ 0 ] ) ; } else { result = Language . interpolate ( "editor.status.error_on" , args [ 0 ] ) + " " + Language . interpolate ( "editor.status.missing.add" , args [ 1 ] ) ; } } } break ; case IProblem . UndefinedMethod : if ( args . length > 2 ) { String methodName = args [ args . length - 2 ] ; String methodArgs = removePackagePrefixes ( args [ args . length - 1 ] ) ; result = Language . interpolate ( "editor.status.undefined_method" , methodName , methodArgs ) ; } break ; case IProblem . ParameterMismatch : if ( args . length > 3 ) { if ( args [ 2 ] . trim ( ) . length ( ) == 0 ) { result = Language . interpolate ( "editor.status.empty_param" , args [ 1 ] ) ; } else { result = Language . interpolate ( "editor.status.wrong_param" , args [ 1 ] , args [ 1 ] , removePackagePrefixes ( args [ 2 ] ) ) ; } } break ; case IProblem . UndefinedField : if ( args . length > 0 ) { result = Language . interpolate ( "editor.status.undef_global_var" , args [ 0 ] ) ; } break ; case IProblem . UndefinedType : if ( args . length > 0 ) { result = Language . interpolate ( "editor.status.undef_class" , args [ 0 ] ) ; } break ; case IProblem . UnresolvedVariable : if ( args . length > 0 ) { result = Language . interpolate ( "editor.status.undef_var" , args [ 0 ] ) ; } break ; case IProblem . UndefinedName : if ( args . length > 0 ) { result = Language . interpolate ( "editor.status.undef_name" , args [ 0 ] ) ; } break ; case IProblem . TypeMismatch : if ( args . length > 1 ) { result = Language . interpolate ( "editor.status.type_mismatch" , args [ 0 ] , args [ 1 ] ) ; } break ; case IProblem . LocalVariableIsNeverUsed : if ( args . length > 0 ) { result = Language . interpolate ( "editor.status.unused_variable" , args [ 0 ] ) ; } break ; case IProblem . UninitializedLocalVariable : if ( args . length > 0 ) { result = Language . interpolate ( "editor.status.uninitialized_variable" , args [ 0 ] ) ; } break ; case IProblem . AssignmentHasNoEffect : if ( args . length > 0 ) { result = Language . interpolate ( "editor.status.no_effect_assignment" , args [ 0 ] ) ; } break ; } return ( result == null ) ? problem . getMessage ( ) : result ; } static private String removePackagePrefixes ( String input ) { if ( ! input . contains ( "." ) ) { return input ; } String [ ] names = PApplet . split ( input , ',' ) ; StringList result = new StringList ( ) ; for ( String name : names ) { int dot = name . lastIndexOf ( '.' ) ; if ( dot >= 0 ) { name = name . substring ( dot + 1 , name . length ( ) ) ; } result . append ( name ) ; } return result . join ( ", " ) ; } static private String getErrorMessageForBracket ( char c ) { switch ( c ) { case ';' : return Language . text ( "editor.status.missing.semicolon" ) ; case '[' : return Language . text ( "editor.status.missing.left_sq_bracket" ) ; case ']' : return Language . text ( "editor.status.missing.right_sq_bracket" ) ; case '(' : return Language . text ( "editor.status.missing.left_paren" ) ; case ')' : return Language . text ( "editor.status.missing.right_paren" ) ; case '{' : return Language . text ( "editor.status.missing.left_curly_bracket" ) ; case '}' : return Language . text ( "editor.status.missing.right_curly_bracket" ) ; } return Language . interpolate ( "editor.status.missing.default" , c ) ; } }
package processing . mode . java . pdex ; import com . sun . jdi . event . EventSet ; public interface VMEventListener { void vmEvent ( EventSet es ) ; }
package processing . mode . java . pdex ; import processing . mode . java . JavaInputHandler ; import processing . mode . java . JavaMode ; import processing . mode . java . JavaEditor ; import processing . mode . java . tweak . ColorControlBox ; import processing . mode . java . tweak . Handle ; import java . awt . * ; import java . awt . event . * ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . swing . DefaultListModel ; import javax . swing . SwingWorker ; import processing . app . Base ; import processing . app . Editor ; import processing . app . Mode ; import processing . app . syntax . JEditTextArea ; import processing . app . syntax . PdeTextAreaDefaults ; import processing . app . syntax . TextAreaDefaults ; public class JavaTextArea extends JEditTextArea { protected PdeTextAreaDefaults defaults ; protected JavaEditor editor ; protected MouseListener [ ] mouseListeners ; protected Map < Integer , Color > lineColors = new HashMap < Integer , Color > ( ) ; protected int gutterPadding ; protected Color gutterBgColor ; protected Color gutterLineColor ; public String breakpointMarker = "<>" ; public String currentLineMarker = "->" ; protected Map < Integer , String > gutterText = new HashMap < Integer , String > ( ) ; protected Map < Integer , Color > gutterTextColors = new HashMap < Integer , Color > ( ) ; private CompletionPanel suggestion ; protected JavaTextAreaPainter getCustomPainter ( ) { return ( JavaTextAreaPainter ) painter ; } public JavaTextArea ( TextAreaDefaults defaults , JavaEditor editor ) { super ( defaults , new JavaInputHandler ( editor ) ) ; this . editor = editor ; mouseListeners = painter . getMouseListeners ( ) ; MouseHandler mouseHandler = new MouseHandler ( ) ; painter . addMouseListener ( mouseHandler ) ; painter . addMouseMotionListener ( mouseHandler ) ; add ( CENTER , painter ) ; Mode mode = editor . getMode ( ) ; gutterBgColor = mode . getColor ( "gutter.bgcolor" ) ; gutterLineColor = mode . getColor ( "gutter.linecolor" ) ; gutterPadding = mode . getInteger ( "gutter.padding" ) ; breakpointMarker = mode . getString ( "breakpoint.marker" ) ; currentLineMarker = mode . getString ( "currentline.marker" ) ; prevCompListeners = painter . getComponentListeners ( ) ; prevMouseListeners = painter . getMouseListeners ( ) ; prevMMotionListeners = painter . getMouseMotionListeners ( ) ; prevKeyListeners = editor . getKeyListeners ( ) ; interactiveMode = false ; addPrevListeners ( ) ; } protected JavaTextAreaPainter createPainter ( final TextAreaDefaults defaults ) { return new JavaTextAreaPainter ( this , defaults ) ; } public void setMode ( JavaMode mode ) { getCustomPainter ( ) . setMode ( mode ) ; } public void processKeyEvent ( KeyEvent evt ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) { if ( suggestion != null ) { if ( suggestion . isVisible ( ) ) { Base . log ( "esc key" ) ; hideSuggestion ( ) ; evt . consume ( ) ; return ; } } } else if ( evt . getKeyCode ( ) == KeyEvent . VK_ENTER && evt . getID ( ) == KeyEvent . KEY_PRESSED ) { if ( suggestion != null ) { if ( suggestion . isVisible ( ) ) { if ( suggestion . insertSelection ( CompletionPanel . KEYBOARD_COMPLETION ) ) { evt . consume ( ) ; if ( suggestion . isVisible ( ) ) prepareSuggestions ( evt ) ; return ; } } } } if ( evt . getID ( ) == KeyEvent . KEY_PRESSED ) { switch ( evt . getKeyCode ( ) ) { case KeyEvent . VK_DOWN : if ( suggestion != null ) if ( suggestion . isVisible ( ) ) { suggestion . moveDown ( ) ; return ; } break ; case KeyEvent . VK_UP : if ( suggestion != null ) if ( suggestion . isVisible ( ) ) { suggestion . moveUp ( ) ; return ; } break ; case KeyEvent . VK_BACK_SPACE : Base . log ( "BK Key" ) ; break ; case KeyEvent . VK_SPACE : if ( suggestion != null ) { if ( suggestion . isVisible ( ) ) { Base . log ( "Space bar, hide completion list" ) ; suggestion . setInvisible ( ) ; } } break ; } } super . processKeyEvent ( evt ) ; if ( ! editor . hasJavaTabs ( ) ) { if ( evt . getID ( ) == KeyEvent . KEY_TYPED ) { processCompletionKeys ( evt ) ; } else if ( Base . isMacOS ( ) && evt . getID ( ) == KeyEvent . KEY_RELEASED ) { processControlSpace ( evt ) ; } } } private void processControlSpace ( final KeyEvent event ) { if ( event . getKeyCode ( ) == KeyEvent . VK_SPACE && event . isControlDown ( ) ) { SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { protected Object doInBackground ( ) throws Exception { if ( JavaMode . codeCompletionsEnabled ) { Base . log ( "[KeyEvent]" + KeyEvent . getKeyText ( event . getKeyCode ( ) ) + " |Prediction started" ) ; Base . log ( "Typing: " + fetchPhrase ( event ) ) ; } return null ; } } ; worker . execute ( ) ; } } private void processCompletionKeys ( final KeyEvent event ) { char keyChar = event . getKeyChar ( ) ; if ( keyChar == KeyEvent . VK_ENTER || keyChar == KeyEvent . VK_ESCAPE || keyChar == KeyEvent . VK_TAB || keyChar == KeyEvent . CHAR_UNDEFINED ) { return ; } else if ( keyChar == ')' ) { hideSuggestion ( ) ; return ; } if ( keyChar == '.' ) { if ( JavaMode . codeCompletionsEnabled ) { Base . log ( "[KeyEvent]" + KeyEvent . getKeyText ( event . getKeyCode ( ) ) + " |Prediction started" ) ; Base . log ( "Typing: " + fetchPhrase ( event ) ) ; } } else if ( keyChar == ' ' ) { if ( ! Base . isMacOS ( ) && JavaMode . codeCompletionsEnabled && ( event . isControlDown ( ) || event . isMetaDown ( ) ) ) { SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { protected Object doInBackground ( ) throws Exception { if ( JavaMode . codeCompletionsEnabled ) { getDocument ( ) . remove ( getCaretPosition ( ) - 1 , 1 ) ; Base . log ( "[KeyEvent]" + event . getKeyChar ( ) + " |Prediction started" ) ; Base . log ( "Typing: " + fetchPhrase ( event ) ) ; } return null ; } } ; worker . execute ( ) ; } else { hideSuggestion ( ) ; } } else { if ( JavaMode . codeCompletionsEnabled ) { prepareSuggestions ( event ) ; } } } private void prepareSuggestions ( final KeyEvent evt ) { SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { protected Object doInBackground ( ) throws Exception { if ( JavaMode . codeCompletionsEnabled && ( JavaMode . ccTriggerEnabled || suggestion . isVisible ( ) ) ) { Base . log ( "[KeyEvent]" + evt . getKeyChar ( ) + " |Prediction started" ) ; Base . log ( "Typing: " + fetchPhrase ( evt ) ) ; } return null ; } } ; worker . execute ( ) ; } private String fetchPhrase ( MouseEvent evt ) { Base . log ( "--handle Mouse Right Click--" ) ; int off = xyToOffset ( evt . getX ( ) , evt . getY ( ) ) ; if ( off < 0 ) return null ; int line = getLineOfOffset ( off ) ; if ( line < 0 ) return null ; String s = getLineText ( line ) ; if ( s == null ) return null ; else if ( s . length ( ) == 0 ) return null ; else { int x = xToOffset ( line , evt . getX ( ) ) , x2 = x + 1 , x1 = x - 1 ; int xLS = off - getLineStartNonWhiteSpaceOffset ( line ) ; Base . log ( "x=" + x ) ; if ( x < 0 || x >= s . length ( ) ) return null ; String word = s . charAt ( x ) + "" ; if ( s . charAt ( x ) == ' ' ) return null ; if ( ! ( Character . isLetterOrDigit ( s . charAt ( x ) ) || s . charAt ( x ) == '_' || s . charAt ( x ) == '$' ) ) return null ; int i = 0 ; while ( true ) { i ++ ; if ( x1 >= 0 && x1 < s . length ( ) ) { if ( Character . isLetter ( s . charAt ( x1 ) ) || s . charAt ( x1 ) == '_' ) { word = s . charAt ( x1 -- ) + word ; xLS -- ; } else x1 = - 1 ; } else x1 = - 1 ; if ( x2 >= 0 && x2 < s . length ( ) ) { if ( Character . isLetterOrDigit ( s . charAt ( x2 ) ) || s . charAt ( x2 ) == '_' || s . charAt ( x2 ) == '$' ) word = word + s . charAt ( x2 ++ ) ; else x2 = - 1 ; } else x2 = - 1 ; if ( x1 < 0 && x2 < 0 ) break ; if ( i > 200 ) { break ; } } if ( Character . isDigit ( word . charAt ( 0 ) ) ) { return null ; } Base . log ( "Mouse click, word: " + word . trim ( ) ) ; editor . getErrorChecker ( ) . getASTGenerator ( ) . setLastClickedWord ( line , word , xLS ) ; return word . trim ( ) ; } } public String fetchPhrase ( KeyEvent evt ) { int off = getCaretPosition ( ) ; Base . log ( "off " + off ) ; if ( off < 0 ) return null ; int line = getCaretLine ( ) ; if ( line < 0 ) return null ; String s = getLineText ( line ) ; Base . log ( " line " + line ) ; int x = getCaretPosition ( ) - getLineStartOffset ( line ) - 1 , x1 = x - 1 ; if ( x >= s . length ( ) || x < 0 ) { hideSuggestion ( ) ; return null ; } Base . log ( " x char: " + s . charAt ( x ) ) ; if ( ! ( Character . isLetterOrDigit ( s . charAt ( x ) ) || s . charAt ( x ) == '_' || s . charAt ( x ) == '(' || s . charAt ( x ) == '.' ) ) { hideSuggestion ( ) ; return null ; } else if ( x > 0 && ( s . charAt ( x - 1 ) == ' ' || s . charAt ( x - 1 ) == '(' ) && Character . isDigit ( s . charAt ( x ) ) ) { hideSuggestion ( ) ; return null ; } else if ( x == 0 ) { hideSuggestion ( ) ; return null ; } String word = ( x < s . length ( ) ? s . charAt ( x ) : "" ) + "" ; if ( s . trim ( ) . length ( ) == 1 ) { word = word . trim ( ) ; if ( word . endsWith ( "." ) ) word = word . substring ( 0 , word . length ( ) - 1 ) ; editor . getErrorChecker ( ) . getASTGenerator ( ) . preparePredictions ( word , line + editor . getErrorChecker ( ) . mainClassOffset , 0 ) ; return word ; } int i = 0 ; int closeB = 0 ; while ( true ) { i ++ ; if ( x1 >= 0 ) { if ( Character . isLetterOrDigit ( s . charAt ( x1 ) ) || s . charAt ( x1 ) == '_' || s . charAt ( x1 ) == '.' || s . charAt ( x1 ) == ')' || s . charAt ( x1 ) == ']' ) { if ( s . charAt ( x1 ) == ')' ) { word = s . charAt ( x1 -- ) + word ; closeB ++ ; while ( x1 >= 0 && closeB > 0 ) { word = s . charAt ( x1 ) + word ; if ( s . charAt ( x1 ) == '(' ) closeB -- ; if ( s . charAt ( x1 ) == ')' ) closeB ++ ; x1 -- ; } } else if ( s . charAt ( x1 ) == ']' ) { word = s . charAt ( x1 -- ) + word ; closeB ++ ; while ( x1 >= 0 && closeB > 0 ) { word = s . charAt ( x1 ) + word ; if ( s . charAt ( x1 ) == '[' ) closeB -- ; if ( s . charAt ( x1 ) == ']' ) closeB ++ ; x1 -- ; } } else { word = s . charAt ( x1 -- ) + word ; } } else { break ; } } else { break ; } if ( i > 200 ) { break ; } } if ( Character . isDigit ( word . charAt ( 0 ) ) ) return null ; word = word . trim ( ) ; int lineStartNonWSOffset = 0 ; if ( word . length ( ) >= JavaMode . codeCompletionTriggerLength ) { editor . getErrorChecker ( ) . getASTGenerator ( ) . preparePredictions ( word , line + editor . getErrorChecker ( ) . mainClassOffset , lineStartNonWSOffset ) ; } return word ; } public void setGutterText ( int lineIdx , String text ) { gutterText . put ( lineIdx , text ) ; painter . invalidateLine ( lineIdx ) ; } public void setGutterText ( int lineIdx , String text , Color textColor ) { gutterTextColors . put ( lineIdx , textColor ) ; setGutterText ( lineIdx , text ) ; } public void clearGutterText ( int lineIdx ) { gutterText . remove ( lineIdx ) ; painter . invalidateLine ( lineIdx ) ; } public void clearGutterText ( ) { for ( int lineIdx : gutterText . keySet ( ) ) { painter . invalidateLine ( lineIdx ) ; } gutterText . clear ( ) ; } public String getGutterText ( int lineIdx ) { return gutterText . get ( lineIdx ) ; } public Color getGutterTextColor ( int lineIdx ) { return gutterTextColors . get ( lineIdx ) ; } public void setLineBgColor ( int lineIdx , Color col ) { lineColors . put ( lineIdx , col ) ; painter . invalidateLine ( lineIdx ) ; } public void clearLineBgColor ( int lineIdx ) { lineColors . remove ( lineIdx ) ; painter . invalidateLine ( lineIdx ) ; } public void clearLineBgColors ( ) { for ( int lineIdx : lineColors . keySet ( ) ) { painter . invalidateLine ( lineIdx ) ; } lineColors . clear ( ) ; } public Color getLineBgColor ( int lineIdx ) { return lineColors . get ( lineIdx ) ; } @ Override public int _offsetToX ( int line , int offset ) { return super . _offsetToX ( line , offset ) + Editor . LEFT_GUTTER ; } @ Override public int xToOffset ( int line , int x ) { return super . xToOffset ( line , x - Editor . LEFT_GUTTER ) ; } protected class MouseHandler implements MouseListener , MouseMotionListener { protected int lastX ; @ Override public void mouseClicked ( MouseEvent me ) { for ( MouseListener ml : mouseListeners ) { ml . mouseClicked ( me ) ; } } @ Override public void mousePressed ( MouseEvent me ) { if ( me . getButton ( ) == MouseEvent . BUTTON3 ) { if ( ! editor . hasJavaTabs ( ) ) { fetchPhrase ( me ) ; } } for ( MouseListener ml : mouseListeners ) { ml . mousePressed ( me ) ; } } @ Override public void mouseReleased ( MouseEvent me ) { for ( MouseListener ml : mouseListeners ) { ml . mouseReleased ( me ) ; } } @ Override public void mouseEntered ( MouseEvent me ) { for ( MouseListener ml : mouseListeners ) { ml . mouseEntered ( me ) ; } } @ Override public void mouseExited ( MouseEvent me ) { for ( MouseListener ml : mouseListeners ) { ml . mouseExited ( me ) ; } } @ Override public void mouseDragged ( MouseEvent me ) { } @ Override public void mouseMoved ( MouseEvent me ) { if ( me . getX ( ) < Editor . LEFT_GUTTER ) { if ( lastX >= Editor . LEFT_GUTTER ) { painter . setCursor ( new Cursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else { if ( lastX < Editor . LEFT_GUTTER ) { painter . setCursor ( new Cursor ( Cursor . TEXT_CURSOR ) ) ; } } lastX = me . getX ( ) ; } } protected void showSuggestion ( DefaultListModel < CompletionCandidate > listModel , String subWord ) { hideSuggestion ( ) ; if ( listModel . size ( ) == 0 ) { Base . log ( "TextArea: No suggestions to show." ) ; } else { int position = getCaretPosition ( ) ; Point location = new Point ( ) ; try { location . x = offsetToX ( getCaretLine ( ) , position - getLineStartOffset ( getCaretLine ( ) ) ) ; location . y = lineToY ( getCaretLine ( ) ) + getPainter ( ) . getFontMetrics ( ) . getHeight ( ) + getPainter ( ) . getFontMetrics ( ) . getDescent ( ) ; } catch ( Exception e2 ) { e2 . printStackTrace ( ) ; return ; } if ( subWord . length ( ) < 2 ) { return ; } suggestion = new CompletionPanel ( this , position , subWord , listModel , location , editor ) ; requestFocusInWindow ( ) ; } } public void hideSuggestion ( ) { if ( suggestion != null ) { suggestion . setInvisible ( ) ; suggestion = null ; } } ComponentListener [ ] prevCompListeners ; MouseListener [ ] prevMouseListeners ; MouseMotionListener [ ] prevMMotionListeners ; KeyListener [ ] prevKeyListeners ; boolean interactiveMode ; public void removeAllListeners ( ) { ComponentListener [ ] componentListeners = painter . getComponentListeners ( ) ; MouseListener [ ] mouseListeners = painter . getMouseListeners ( ) ; MouseMotionListener [ ] mouseMotionListeners = painter . getMouseMotionListeners ( ) ; KeyListener [ ] keyListeners = editor . getKeyListeners ( ) ; for ( ComponentListener cl : componentListeners ) { painter . removeComponentListener ( cl ) ; } for ( MouseListener ml : mouseListeners ) { painter . removeMouseListener ( ml ) ; } for ( MouseMotionListener mml : mouseMotionListeners ) { painter . removeMouseMotionListener ( mml ) ; } for ( KeyListener kl : keyListeners ) { editor . removeKeyListener ( kl ) ; } } public void startInteractiveMode ( ) { if ( interactiveMode ) return ; removeAllListeners ( ) ; getCustomPainter ( ) . startInterativeMode ( ) ; this . editable = false ; this . caretBlinks = false ; this . setCaretVisible ( false ) ; interactiveMode = true ; } public void stopInteractiveMode ( ) { if ( ! interactiveMode ) return ; removeAllListeners ( ) ; addPrevListeners ( ) ; getCustomPainter ( ) . stopInteractiveMode ( ) ; this . editable = true ; this . caretBlinks = true ; this . setCaretVisible ( true ) ; interactiveMode = false ; } public int getHorizontalScroll ( ) { return horizontal . getValue ( ) ; } private void addPrevListeners ( ) { for ( ComponentListener cl : prevCompListeners ) { painter . addComponentListener ( cl ) ; } for ( MouseListener ml : prevMouseListeners ) { painter . addMouseListener ( ml ) ; } for ( MouseMotionListener mml : prevMMotionListeners ) { painter . addMouseMotionListener ( mml ) ; } for ( KeyListener kl : prevKeyListeners ) { editor . addKeyListener ( kl ) ; } } public void updateInterface ( List < List < Handle > > handles , List < List < ColorControlBox > > colorBoxes ) { getCustomPainter ( ) . updateInterface ( handles , colorBoxes ) ; } }
package processing . mode . java . pdex ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . eclipse . jdt . core . compiler . IProblem ; public class Problem { private IProblem iProblem ; private int tabIndex ; private int lineNumber ; private int lineStartOffset ; private int lineStopOffset ; private String message ; private int type ; private String [ ] importSuggestions ; public static final int ERROR = 1 , WARNING = 2 ; public Problem ( IProblem iProblem , int tabIndex , int lineNumber ) { this . iProblem = iProblem ; if ( iProblem . isError ( ) ) { type = ERROR ; } else if ( iProblem . isWarning ( ) ) { type = WARNING ; } this . tabIndex = tabIndex ; this . lineNumber = lineNumber ; this . message = process ( iProblem ) ; this . message = ErrorMessageSimplifier . getSimplifiedErrorMessage ( this ) ; } public void setPDEOffsets ( int startOffset , int stopOffset ) { lineStartOffset = startOffset ; lineStopOffset = stopOffset ; } public int getPDELineStartOffset ( ) { return lineStartOffset ; } public int getPDELineStopOffset ( ) { return lineStopOffset ; } public String toString ( ) { return new String ( "TAB " + tabIndex + ",LN " + lineNumber + "LN START OFF: " + lineStartOffset + ",LN STOP OFF: " + lineStopOffset + ",PROB: " + message ) ; } public boolean isError ( ) { return type == ERROR ; } public boolean isWarning ( ) { return type == WARNING ; } public String getMessage ( ) { return message ; } public IProblem getIProblem ( ) { return iProblem ; } public int getTabIndex ( ) { return tabIndex ; } public int getLineNumber ( ) { return lineNumber ; } public int getSourceLineNumber ( ) { return iProblem . getSourceLineNumber ( ) ; } public void setType ( int ProblemType ) { if ( ProblemType == ERROR ) type = ERROR ; else if ( ProblemType == WARNING ) type = WARNING ; else throw new IllegalArgumentException ( "Illegal Problem type passed to Problem.setType(int)" ) ; } public String [ ] getImportSuggestions ( ) { return importSuggestions ; } public void setImportSuggestions ( String [ ] a ) { importSuggestions = a ; } private static Pattern pattern ; private static Matcher matcher ; private static final String tokenRegExp = "\\b token\\b" ; public static String process ( IProblem problem ) { return process ( problem . getMessage ( ) ) ; } public static String process ( String message ) { if ( message == null ) return null ; pattern = Pattern . compile ( tokenRegExp ) ; matcher = pattern . matcher ( message ) ; message = matcher . replaceAll ( "" ) ; return message ; } public static String splitCamelCaseWord ( String word ) { String newWord = "" ; for ( int i = 1 ; i < word . length ( ) ; i ++ ) { if ( Character . isUpperCase ( word . charAt ( i ) ) ) { newWord += word . substring ( 0 , i ) + " " ; word = word . substring ( i ) ; i = 1 ; } } newWord += word ; return newWord . trim ( ) ; } }
package processing . mode . java . pdex ; public class ErrorMarker { private int y ; private int type = - 1 ; public static final int Error = 1 ; public static final int Warning = 2 ; private Problem problem ; public ErrorMarker ( Problem problem , int y , int type ) { this . problem = problem ; this . y = y ; this . type = type ; } public int getY ( ) { return y ; } public int getType ( ) { return type ; } public Problem getProblem ( ) { return problem ; } }
package processing . mode . java . pdex ; import java . awt . BorderLayout ; import java . awt . Dimension ; import java . awt . Rectangle ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . io . File ; import java . io . FileFilter ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Stack ; import java . util . TreeMap ; import java . util . TreeSet ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . regex . Pattern ; import javax . swing . BorderFactory ; import javax . swing . Box ; import javax . swing . BoxLayout ; import javax . swing . DefaultListModel ; import javax . swing . JButton ; import javax . swing . JComponent ; import javax . swing . JEditorPane ; import javax . swing . JFrame ; import javax . swing . JLabel ; import javax . swing . JList ; import javax . swing . JOptionPane ; import javax . swing . JPanel ; import javax . swing . JScrollPane ; import javax . swing . JTable ; import javax . swing . JTextField ; import javax . swing . JTree ; import javax . swing . ListSelectionModel ; import javax . swing . SwingUtilities ; import javax . swing . SwingWorker ; import javax . swing . event . TreeSelectionEvent ; import javax . swing . event . TreeSelectionListener ; import javax . swing . text . BadLocationException ; import javax . swing . text . Element ; import javax . swing . text . PlainDocument ; import javax . swing . tree . DefaultMutableTreeNode ; import javax . swing . tree . DefaultTreeModel ; import javax . swing . tree . MutableTreeNode ; import org . eclipse . jdt . core . JavaCore ; import org . eclipse . jdt . core . dom . AST ; import org . eclipse . jdt . core . dom . ASTNode ; import org . eclipse . jdt . core . dom . ASTParser ; import org . eclipse . jdt . core . dom . ArrayAccess ; import org . eclipse . jdt . core . dom . ArrayType ; import org . eclipse . jdt . core . dom . Block ; import org . eclipse . jdt . core . dom . Comment ; import org . eclipse . jdt . core . dom . CompilationUnit ; import org . eclipse . jdt . core . dom . Expression ; import org . eclipse . jdt . core . dom . ExpressionStatement ; import org . eclipse . jdt . core . dom . FieldAccess ; import org . eclipse . jdt . core . dom . FieldDeclaration ; import org . eclipse . jdt . core . dom . MethodDeclaration ; import org . eclipse . jdt . core . dom . MethodInvocation ; import org . eclipse . jdt . core . dom . Name ; import org . eclipse . jdt . core . dom . ParameterizedType ; import org . eclipse . jdt . core . dom . PrimitiveType ; import org . eclipse . jdt . core . dom . QualifiedName ; import org . eclipse . jdt . core . dom . SimpleName ; import org . eclipse . jdt . core . dom . SimpleType ; import org . eclipse . jdt . core . dom . SingleVariableDeclaration ; import org . eclipse . jdt . core . dom . StructuralPropertyDescriptor ; import org . eclipse . jdt . core . dom . Type ; import org . eclipse . jdt . core . dom . TypeDeclaration ; import org . eclipse . jdt . core . dom . VariableDeclarationExpression ; import org . eclipse . jdt . core . dom . VariableDeclarationFragment ; import org . eclipse . jdt . core . dom . VariableDeclarationStatement ; import org . jsoup . Jsoup ; import org . jsoup . nodes . Document ; import org . jsoup . select . Elements ; import processing . app . Base ; import processing . app . Library ; import processing . app . SketchCode ; import processing . app . Toolkit ; import processing . app . syntax . JEditTextArea ; import processing . mode . java . JavaEditor ; import processing . mode . java . JavaMode ; import processing . mode . java . preproc . PdePreprocessor ; import com . google . classpath . ClassPath ; import com . google . classpath . ClassPathFactory ; import com . google . classpath . RegExpResourceFilter ; @ SuppressWarnings ( { "deprecation" , "unchecked" } ) public class ASTGenerator { protected ErrorCheckerService errorCheckerService ; protected JavaEditor editor ; public DefaultMutableTreeNode codeTree = new DefaultMutableTreeNode ( ) ; protected DefaultMutableTreeNode currentParent = null ; protected JFrame frmASTView ; protected JFrame frameAutoComp ; protected JTree jtree ; protected JTree refactorTree ; protected CompilationUnit compilationUnit ; protected JTable tableAuto ; protected JEditorPane javadocPane ; protected JScrollPane scrollPane ; protected JFrame frmRename ; protected JButton btnRename ; protected JButton btnListOccurrence ; protected JTextField txtRenameField ; protected JFrame frmOccurenceList ; protected JLabel lblRefactorOldName ; public ASTGenerator ( ErrorCheckerService ecs ) { this . errorCheckerService = ecs ; this . editor = ecs . getEditor ( ) ; setupGUI ( ) ; addListeners ( ) ; predictionOngoing = new AtomicBoolean ( false ) ; } protected void setupGUI ( ) { frmASTView = new JFrame ( ) ; jtree = new JTree ( ) ; frmASTView . setDefaultCloseOperation ( JFrame . HIDE_ON_CLOSE ) ; frmASTView . setBounds ( new Rectangle ( 680 , 100 , 460 , 620 ) ) ; frmASTView . setTitle ( "AST View - " + editor . getSketch ( ) . getName ( ) ) ; JScrollPane sp = new JScrollPane ( ) ; sp . setViewportView ( jtree ) ; frmASTView . add ( sp ) ; btnRename = new JButton ( "Rename" ) ; btnListOccurrence = new JButton ( "Show Usage" ) ; frmRename = new JFrame ( ) ; frmRename . setDefaultCloseOperation ( JFrame . HIDE_ON_CLOSE ) ; frmRename . setSize ( 250 , 130 ) ; frmRename . setLayout ( new BoxLayout ( frmRename . getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; Toolkit . setIcon ( frmRename ) ; JPanel panelTop = new JPanel ( ) , panelBottom = new JPanel ( ) ; panelTop . setLayout ( new BoxLayout ( panelTop , BoxLayout . Y_AXIS ) ) ; panelTop . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; panelBottom . setLayout ( new BoxLayout ( panelBottom , BoxLayout . X_AXIS ) ) ; panelBottom . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; panelBottom . add ( Box . createHorizontalGlue ( ) ) ; panelBottom . add ( btnListOccurrence ) ; panelBottom . add ( Box . createRigidArea ( new Dimension ( 15 , 0 ) ) ) ; panelBottom . add ( btnRename ) ; frmRename . setTitle ( "Enter new name:" ) ; txtRenameField = new JTextField ( ) ; txtRenameField . setPreferredSize ( new Dimension ( 150 , 60 ) ) ; panelTop . add ( txtRenameField ) ; lblRefactorOldName = new JLabel ( ) ; lblRefactorOldName . setText ( "Old Name: " ) ; panelTop . add ( Box . createRigidArea ( new Dimension ( 0 , 10 ) ) ) ; panelTop . add ( lblRefactorOldName ) ; frmRename . add ( panelTop ) ; frmRename . add ( panelBottom ) ; frmRename . setMinimumSize ( frmRename . getSize ( ) ) ; frmRename . setLocation ( editor . getX ( ) + ( editor . getWidth ( ) - frmRename . getWidth ( ) ) / 2 , editor . getY ( ) + ( editor . getHeight ( ) - frmRename . getHeight ( ) ) / 2 ) ; frmOccurenceList = new JFrame ( ) ; frmOccurenceList . setDefaultCloseOperation ( JFrame . HIDE_ON_CLOSE ) ; frmOccurenceList . setSize ( 300 , 400 ) ; Toolkit . setIcon ( frmOccurenceList ) ; JScrollPane sp2 = new JScrollPane ( ) ; refactorTree = new JTree ( ) ; sp2 . setViewportView ( refactorTree ) ; frmOccurenceList . add ( sp2 ) ; } public static final boolean SHOW_AST = ! true ; protected DefaultMutableTreeNode buildAST ( String source , CompilationUnit cu ) { if ( cu == null ) { ASTParser parser = ASTParser . newParser ( AST . JLS4 ) ; parser . setSource ( source . toCharArray ( ) ) ; parser . setKind ( ASTParser . K_COMPILATION_UNIT ) ; Map < String , String > options = JavaCore . getOptions ( ) ; JavaCore . setComplianceOptions ( JavaCore . VERSION_1_6 , options ) ; options . put ( JavaCore . COMPILER_SOURCE , JavaCore . VERSION_1_6 ) ; parser . setCompilerOptions ( options ) ; compilationUnit = ( CompilationUnit ) parser . createAST ( null ) ; } else { compilationUnit = cu ; } getCodeComments ( ) ; codeTree = new DefaultMutableTreeNode ( new ASTNodeWrapper ( ( ASTNode ) compilationUnit . types ( ) . get ( 0 ) ) ) ; if ( compilationUnit . types ( ) == null || compilationUnit . types ( ) . isEmpty ( ) ) { Base . loge ( "No CU found!" ) ; } visitRecur ( ( ASTNode ) compilationUnit . types ( ) . get ( 0 ) , codeTree ) ; SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { @ Override protected Object doInBackground ( ) throws Exception { return null ; } protected void done ( ) { if ( codeTree != null ) { if ( SHOW_AST ) { if ( jtree . hasFocus ( ) || frmASTView . hasFocus ( ) ) return ; jtree . setModel ( new DefaultTreeModel ( codeTree ) ) ; ( ( DefaultTreeModel ) jtree . getModel ( ) ) . reload ( ) ; jtree . validate ( ) ; if ( ! frmASTView . isVisible ( ) ) { frmASTView . setVisible ( true ) ; } } } } } ; worker . execute ( ) ; return codeTree ; } protected ClassPathFactory factory ; protected ClassPath classPath ; protected void loadJars ( ) { factory = new ClassPathFactory ( ) ; StringBuilder tehPath = new StringBuilder ( System . getProperty ( "java.class.path" ) ) ; tehPath . append ( File . pathSeparatorChar + System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" + File . pathSeparatorChar ) ; if ( errorCheckerService . classpathJars != null ) { synchronized ( errorCheckerService . classpathJars ) { for ( URL jarPath : errorCheckerService . classpathJars ) { tehPath . append ( jarPath . getPath ( ) + File . pathSeparatorChar ) ; } } } classPath = factory . createFromPath ( tehPath . toString ( ) ) ; log ( "Classpath created " + ( classPath != null ) ) ; log ( "Sketch classpath jars loaded." ) ; if ( Base . isMacOS ( ) ) { File f = new File ( System . getProperty ( "java.home" ) + File . separator + "bundle" + File . separator + "Classes" + File . separator + "classes.jar" ) ; log ( f . getAbsolutePath ( ) + " | classes.jar found?" + f . exists ( ) ) ; } else { File f = new File ( System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" + File . separator ) ; log ( f . getAbsolutePath ( ) + " | rt.jar found?" + f . exists ( ) ) ; } } protected TreeMap < String , String > jdocMap ; protected void loadJavaDoc ( ) { jdocMap = new TreeMap < String , String > ( ) ; new Thread ( new Runnable ( ) { public void run ( ) { try { loadJavaDoc ( jdocMap , editor . getMode ( ) . getReferenceFolder ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) . start ( ) ; } static void loadJavaDoc ( TreeMap < String , String > jdocMap , File referenceFolder ) throws IOException , MalformedURLException { Document doc ; FileFilter fileFilter = new FileFilter ( ) { public boolean accept ( File file ) { if ( ! file . getName ( ) . endsWith ( "_.html" ) ) return false ; int k = 0 ; for ( int i = 0 ; i < file . getName ( ) . length ( ) ; i ++ ) { if ( file . getName ( ) . charAt ( i ) == '_' ) k ++ ; if ( k > 1 ) return false ; } return true ; } } ; for ( File docFile : referenceFolder . listFiles ( fileFilter ) ) { doc = Jsoup . parse ( docFile , null ) ; Elements elm = doc . getElementsByClass ( "ref-item" ) ; String msg = "" ; String methodName = docFile . getName ( ) . substring ( 0 , docFile . getName ( ) . indexOf ( '_' ) ) ; for ( Iterator < org . jsoup . nodes . Element > it = elm . iterator ( ) ; it . hasNext ( ) ; ) { org . jsoup . nodes . Element ele = it . next ( ) ; msg = "<html><body> <strong><div style=\"width: 300px; text-justification: justify;\"></strong><table cellpadding=\"0\" cellspacing=\"0\" border=\"0\" class=\"ref-item\">" + ele . html ( ) + "</table></div></html></body></html>" ; msg = msg . replaceAll ( "img src=\"" , "img src=\"" + referenceFolder . toURI ( ) . toURL ( ) . toString ( ) + "/" ) ; } jdocMap . put ( methodName , msg ) ; } System . out . println ( "JDoc loaded " + jdocMap . size ( ) ) ; } public DefaultMutableTreeNode buildAST ( CompilationUnit cu ) { return buildAST ( errorCheckerService . sourceCode , cu ) ; } public static CompletionCandidate [ ] checkForTypes ( ASTNode node ) { List < VariableDeclarationFragment > vdfs = null ; switch ( node . getNodeType ( ) ) { case ASTNode . TYPE_DECLARATION : return new CompletionCandidate [ ] { new CompletionCandidate ( ( TypeDeclaration ) node ) } ; case ASTNode . METHOD_DECLARATION : MethodDeclaration md = ( MethodDeclaration ) node ; log ( getNodeAsString ( md ) ) ; List < ASTNode > params = ( List < ASTNode > ) md . getStructuralProperty ( MethodDeclaration . PARAMETERS_PROPERTY ) ; CompletionCandidate [ ] cand = new CompletionCandidate [ params . size ( ) + 1 ] ; cand [ 0 ] = new CompletionCandidate ( md ) ; for ( int i = 0 ; i < params . size ( ) ; i ++ ) { cand [ i + 1 ] = new CompletionCandidate ( ( SingleVariableDeclaration ) params . get ( i ) ) ; } return cand ; case ASTNode . SINGLE_VARIABLE_DECLARATION : return new CompletionCandidate [ ] { new CompletionCandidate ( ( SingleVariableDeclaration ) node ) } ; case ASTNode . FIELD_DECLARATION : vdfs = ( ( FieldDeclaration ) node ) . fragments ( ) ; break ; case ASTNode . VARIABLE_DECLARATION_STATEMENT : vdfs = ( ( VariableDeclarationStatement ) node ) . fragments ( ) ; break ; case ASTNode . VARIABLE_DECLARATION_EXPRESSION : vdfs = ( ( VariableDeclarationExpression ) node ) . fragments ( ) ; break ; default : break ; } if ( vdfs != null ) { CompletionCandidate ret [ ] = new CompletionCandidate [ vdfs . size ( ) ] ; int i = 0 ; for ( VariableDeclarationFragment vdf : vdfs ) { ret [ i ++ ] = new CompletionCandidate ( vdf ) ; } return ret ; } return null ; } public static ASTNode resolveExpression ( ASTNode nearestNode , ASTNode expression , boolean noCompare ) { log ( "Resolving " + getNodeAsString ( expression ) + " noComp " + noCompare ) ; if ( expression instanceof SimpleName ) { return findDeclaration2 ( ( ( SimpleName ) expression ) , nearestNode ) ; } else if ( expression instanceof MethodInvocation ) { log ( "3. Method Invo " + ( ( MethodInvocation ) expression ) . getName ( ) ) ; return findDeclaration2 ( ( ( MethodInvocation ) expression ) . getName ( ) , nearestNode ) ; } else if ( expression instanceof FieldAccess ) { log ( "2. Field access " + getNodeAsString ( ( ( FieldAccess ) expression ) . getExpression ( ) ) + "|||" + getNodeAsString ( ( ( FieldAccess ) expression ) . getName ( ) ) ) ; if ( noCompare ) { return findDeclaration2 ( ( ( FieldAccess ) expression ) . getName ( ) , nearestNode ) ; } else { return resolveExpression ( nearestNode , ( ( FieldAccess ) expression ) . getExpression ( ) , ! noCompare ) ; } } else if ( expression instanceof QualifiedName ) { log ( "1. Resolving " + ( ( QualifiedName ) expression ) . getQualifier ( ) + " ||| " + ( ( QualifiedName ) expression ) . getName ( ) ) ; if ( noCompare ) { return findDeclaration2 ( ( ( QualifiedName ) expression ) . getName ( ) , nearestNode ) ; } else { return findDeclaration2 ( ( ( QualifiedName ) expression ) . getQualifier ( ) , nearestNode ) ; } } return null ; } public ClassMember resolveExpression3rdParty ( ASTNode nearestNode , ASTNode astNode , boolean noCompare ) { log ( "Resolve 3rdParty expr-- " + getNodeAsString ( astNode ) + " nearest node " + getNodeAsString ( nearestNode ) ) ; if ( astNode == null ) return null ; ClassMember scopeParent = null ; SimpleType stp = null ; if ( astNode instanceof SimpleName ) { ASTNode decl = findDeclaration2 ( ( ( SimpleName ) astNode ) , nearestNode ) ; if ( decl != null ) { log ( getNodeAsString ( astNode ) + " found decl -> " + getNodeAsString ( decl ) ) ; return new ClassMember ( extracTypeInfo ( decl ) ) ; } else { Class < ? > tehClass = findClassIfExists ( ( ( SimpleName ) astNode ) . toString ( ) ) ; if ( tehClass != null ) { return new ClassMember ( tehClass ) ; } } astNode = astNode . getParent ( ) ; } switch ( astNode . getNodeType ( ) ) { case ASTNode . FIELD_ACCESS : FieldAccess fa = ( FieldAccess ) astNode ; if ( fa . getExpression ( ) == null ) { log ( "FA,Not implemented." ) ; return null ; } else { if ( fa . getExpression ( ) instanceof SimpleName ) { stp = extracTypeInfo ( findDeclaration2 ( ( SimpleName ) fa . getExpression ( ) , nearestNode ) ) ; if ( stp == null ) { Class < ? > tehClass = findClassIfExists ( ( ( SimpleName ) fa . getExpression ( ) ) . toString ( ) ) ; if ( tehClass != null ) { return definedIn3rdPartyClass ( new ClassMember ( tehClass ) , fa . getName ( ) . toString ( ) ) ; } log ( "FA resolve 3rd par, Can't resolve " + fa . getExpression ( ) ) ; return null ; } log ( "FA, SN Type " + getNodeAsString ( stp ) ) ; scopeParent = definedIn3rdPartyClass ( stp . getName ( ) . toString ( ) , "THIS" ) ; } else { scopeParent = resolveExpression3rdParty ( nearestNode , fa . getExpression ( ) , noCompare ) ; } log ( "FA, ScopeParent " + scopeParent ) ; return definedIn3rdPartyClass ( scopeParent , fa . getName ( ) . toString ( ) ) ; } case ASTNode . METHOD_INVOCATION : MethodInvocation mi = ( MethodInvocation ) astNode ; ASTNode temp = findDeclaration2 ( mi . getName ( ) , nearestNode ) ; if ( temp instanceof MethodDeclaration ) { log ( mi . getName ( ) + " was found locally," + getNodeAsString ( extracTypeInfo ( temp ) ) ) ; return new ClassMember ( extracTypeInfo ( temp ) ) ; } if ( mi . getExpression ( ) == null ) { log ( "MI,Not implemented." ) ; return null ; } else { if ( mi . getExpression ( ) instanceof SimpleName ) { stp = extracTypeInfo ( findDeclaration2 ( ( SimpleName ) mi . getExpression ( ) , nearestNode ) ) ; if ( stp == null ) { Class < ? > tehClass = findClassIfExists ( ( ( SimpleName ) mi . getExpression ( ) ) . toString ( ) ) ; if ( tehClass != null ) { return definedIn3rdPartyClass ( new ClassMember ( tehClass ) , mi . getName ( ) . toString ( ) ) ; } log ( "MI resolve 3rd par, Can't resolve " + mi . getExpression ( ) ) ; return null ; } log ( "MI, SN Type " + getNodeAsString ( stp ) ) ; ASTNode typeDec = findDeclaration2 ( stp . getName ( ) , nearestNode ) ; if ( typeDec == null ) { log ( stp . getName ( ) + " couldn't be found locally.." ) ; Class < ? > tehClass = findClassIfExists ( stp . getName ( ) . toString ( ) ) ; if ( tehClass != null ) { return definedIn3rdPartyClass ( new ClassMember ( tehClass ) , mi . getName ( ) . toString ( ) ) ; } } return definedIn3rdPartyClass ( new ClassMember ( typeDec ) , mi . getName ( ) . toString ( ) ) ; } else { log ( "MI EXP.." + getNodeAsString ( mi . getExpression ( ) ) ) ; scopeParent = resolveExpression3rdParty ( nearestNode , mi . getExpression ( ) , noCompare ) ; log ( "MI, ScopeParent " + scopeParent ) ; return definedIn3rdPartyClass ( scopeParent , mi . getName ( ) . toString ( ) ) ; } } case ASTNode . QUALIFIED_NAME : QualifiedName qn = ( QualifiedName ) astNode ; ASTNode temp2 = findDeclaration2 ( qn . getName ( ) , nearestNode ) ; if ( temp2 instanceof FieldDeclaration ) { log ( qn . getName ( ) + " was found locally," + getNodeAsString ( extracTypeInfo ( temp2 ) ) ) ; return new ClassMember ( extracTypeInfo ( temp2 ) ) ; } if ( qn . getQualifier ( ) == null ) { log ( "QN,Not implemented." ) ; return null ; } else { if ( qn . getQualifier ( ) instanceof SimpleName ) { stp = extracTypeInfo ( findDeclaration2 ( qn . getQualifier ( ) , nearestNode ) ) ; if ( stp == null ) { Class < ? > tehClass = findClassIfExists ( qn . getQualifier ( ) . toString ( ) ) ; if ( tehClass != null ) { return definedIn3rdPartyClass ( new ClassMember ( tehClass ) , qn . getName ( ) . toString ( ) ) ; } log ( "QN resolve 3rd par, Can't resolve " + qn . getQualifier ( ) ) ; return null ; } log ( "QN, SN Local Type " + getNodeAsString ( stp ) ) ; ASTNode typeDec = findDeclaration2 ( stp . getName ( ) , nearestNode ) ; if ( typeDec == null ) { log ( stp . getName ( ) + " couldn't be found locally.." ) ; Class < ? > tehClass = findClassIfExists ( stp . getName ( ) . toString ( ) ) ; if ( tehClass != null ) { return definedIn3rdPartyClass ( new ClassMember ( tehClass ) , qn . getName ( ) . toString ( ) ) ; } log ( "QN resolve 3rd par, Can't resolve " + qn . getQualifier ( ) ) ; return null ; } return definedIn3rdPartyClass ( new ClassMember ( typeDec ) , qn . getName ( ) . toString ( ) ) ; } else { scopeParent = resolveExpression3rdParty ( nearestNode , qn . getQualifier ( ) , noCompare ) ; log ( "QN, ScopeParent " + scopeParent ) ; return definedIn3rdPartyClass ( scopeParent , qn . getName ( ) . toString ( ) ) ; } } case ASTNode . ARRAY_ACCESS : ArrayAccess arac = ( ArrayAccess ) astNode ; return resolveExpression3rdParty ( nearestNode , arac . getArray ( ) , noCompare ) ; default : log ( "Unaccounted type " + getNodeAsString ( astNode ) ) ; break ; } return null ; } public static ASTNode getChildExpression ( ASTNode expression ) { if ( expression instanceof SimpleName ) { return expression ; } else if ( expression instanceof FieldAccess ) { return ( ( FieldAccess ) expression ) . getName ( ) ; } else if ( expression instanceof QualifiedName ) { return ( ( QualifiedName ) expression ) . getName ( ) ; } else if ( expression instanceof MethodInvocation ) { return ( ( MethodInvocation ) expression ) . getName ( ) ; } else if ( expression instanceof ArrayAccess ) { return ( ( ArrayAccess ) expression ) . getArray ( ) ; } log ( " getChildExpression returning NULL for " + getNodeAsString ( expression ) ) ; return null ; } public static ASTNode getParentExpression ( ASTNode expression ) { if ( expression instanceof SimpleName ) { return expression ; } else if ( expression instanceof FieldAccess ) { return ( ( FieldAccess ) expression ) . getExpression ( ) ; } else if ( expression instanceof QualifiedName ) { return ( ( QualifiedName ) expression ) . getQualifier ( ) ; } else if ( expression instanceof MethodInvocation ) { return ( ( MethodInvocation ) expression ) . getExpression ( ) ; } else if ( expression instanceof ArrayAccess ) { return ( ( ArrayAccess ) expression ) . getArray ( ) ; } log ( "getParentExpression returning NULL for " + getNodeAsString ( expression ) ) ; return null ; } protected void trimCandidates ( String newWord ) { ArrayList < CompletionCandidate > newCandidate = new ArrayList < CompletionCandidate > ( ) ; newWord = newWord . toLowerCase ( ) ; for ( CompletionCandidate comp : candidates ) { if ( comp . getNoHtmlLabel ( ) . toLowerCase ( ) . startsWith ( newWord ) ) { newCandidate . add ( comp ) ; } } candidates = newCandidate ; } protected ArrayList < CompletionCandidate > candidates ; protected String lastPredictedWord = " " ; protected int predictionMinLength = 2 ; private AtomicBoolean predictionOngoing ; public void preparePredictions ( final String word , final int line , final int lineStartNonWSOffset ) { if ( predictionOngoing . get ( ) ) return ; if ( ! JavaMode . codeCompletionsEnabled ) return ; if ( word . length ( ) < predictionMinLength ) return ; predictionOngoing . set ( true ) ; if ( caretWithinLineComment ( ) ) { log ( "No predictions." ) ; predictionOngoing . set ( false ) ; return ; } String word2 = ASTNodeWrapper . getJavaCode ( word ) ; boolean noCompare = false ; if ( word2 . endsWith ( "." ) ) { word2 = word2 . substring ( 0 , word2 . length ( ) - 1 ) ; noCompare = true ; } if ( word2 . length ( ) >= predictionMinLength && ! noCompare && word2 . length ( ) > lastPredictedWord . length ( ) ) { if ( word2 . startsWith ( lastPredictedWord ) ) { log ( word + " starts with " + lastPredictedWord ) ; log ( "Don't recalc" ) ; if ( word2 . contains ( "." ) ) { int x = word2 . lastIndexOf ( '.' ) ; trimCandidates ( word2 . substring ( x + 1 ) ) ; } else { trimCandidates ( word2 ) ; } showPredictions ( word ) ; lastPredictedWord = word2 ; predictionOngoing . set ( false ) ; return ; } } int lineNumber = line ; if ( errorCheckerService != null ) { editor = errorCheckerService . getEditor ( ) ; int codeIndex = editor . getSketch ( ) . getCodeIndex ( editor . getCurrentTab ( ) ) ; if ( codeIndex > 0 ) for ( int i = 0 ; i < codeIndex ; i ++ ) { SketchCode sc = editor . getSketch ( ) . getCode ( i ) ; int len = Base . countLines ( sc . getProgram ( ) ) + 1 ; lineNumber += len ; } } ASTNode nearestNode = null ; ASTParser parser = ASTParser . newParser ( AST . JLS4 ) ; parser . setKind ( ASTParser . K_EXPRESSION ) ; parser . setSource ( word2 . toCharArray ( ) ) ; ASTNode testnode = parser . createAST ( null ) ; Base . loge ( "Typed: " + word2 + "|" + " temp Node type: " + testnode . getClass ( ) . getSimpleName ( ) ) ; if ( testnode instanceof MethodInvocation ) { MethodInvocation mi = ( MethodInvocation ) testnode ; log ( mi . getName ( ) + "," + mi . getExpression ( ) + "," + mi . typeArguments ( ) . size ( ) ) ; } nearestNode = findClosestNode ( lineNumber , ( ASTNode ) errorCheckerService . getLastCorrectCU ( ) . types ( ) . get ( 0 ) ) ; if ( nearestNode == null ) { nearestNode = ( ASTNode ) errorCheckerService . getLastCorrectCU ( ) . types ( ) . get ( 0 ) ; } Base . loge ( lineNumber + " Nearest ASTNode to PRED " + getNodeAsString ( nearestNode ) ) ; candidates = new ArrayList < CompletionCandidate > ( ) ; lastPredictedWord = word2 ; if ( testnode instanceof SimpleName && ! noCompare ) { Base . loge ( "One word expression " + getNodeAsString ( testnode ) ) ; while ( nearestNode != null ) { if ( nearestNode instanceof TypeDeclaration ) { TypeDeclaration td = ( TypeDeclaration ) nearestNode ; if ( td . getStructuralProperty ( TypeDeclaration . SUPERCLASS_TYPE_PROPERTY ) != null ) { SimpleType st = ( SimpleType ) td . getStructuralProperty ( TypeDeclaration . SUPERCLASS_TYPE_PROPERTY ) ; log ( "Superclass " + st . getName ( ) ) ; ArrayList < CompletionCandidate > candidates = getMembersForType ( st . getName ( ) . toString ( ) , word2 , noCompare , false ) ; for ( CompletionCandidate can : candidates ) { candidates . add ( can ) ; } } } List < StructuralPropertyDescriptor > sprops = nearestNode . structuralPropertiesForType ( ) ; for ( StructuralPropertyDescriptor sprop : sprops ) { ASTNode cnode = null ; if ( ! sprop . isChildListProperty ( ) ) { if ( nearestNode . getStructuralProperty ( sprop ) instanceof ASTNode ) { cnode = ( ASTNode ) nearestNode . getStructuralProperty ( sprop ) ; CompletionCandidate [ ] types = checkForTypes ( cnode ) ; if ( types != null ) { for ( int i = 0 ; i < types . length ; i ++ ) { if ( types [ i ] . getElementName ( ) . toLowerCase ( ) . startsWith ( word2 . toLowerCase ( ) ) ) candidates . add ( types [ i ] ) ; } } } } else { List < ASTNode > nodelist = ( List < ASTNode > ) nearestNode . getStructuralProperty ( sprop ) ; for ( ASTNode clnode : nodelist ) { CompletionCandidate [ ] types = checkForTypes ( clnode ) ; if ( types != null ) { for ( int i = 0 ; i < types . length ; i ++ ) { if ( types [ i ] . getElementName ( ) . toLowerCase ( ) . startsWith ( word2 . toLowerCase ( ) ) ) candidates . add ( types [ i ] ) ; } } } } } nearestNode = nearestNode . getParent ( ) ; } log ( "Empty can. " + word2 ) ; if ( classPath != null ) { RegExpResourceFilter regExpResourceFilter ; regExpResourceFilter = new RegExpResourceFilter ( Pattern . compile ( ".*" ) , Pattern . compile ( word2 + "[a-zA-Z_0-9]*.class" , Pattern . CASE_INSENSITIVE ) ) ; String [ ] resources = classPath . findResources ( "" , regExpResourceFilter ) ; for ( String matchedClass2 : resources ) { matchedClass2 = matchedClass2 . replace ( '/' , '.' ) ; String matchedClass = matchedClass2 . substring ( 0 , matchedClass2 . length ( ) - 6 ) ; int d = matchedClass . lastIndexOf ( '.' ) ; if ( ignorableImport ( matchedClass2 , matchedClass . substring ( d + 1 ) ) ) continue ; matchedClass = matchedClass . substring ( d + 1 ) ; candidates . add ( new CompletionCandidate ( matchedClass , "<html>" + matchedClass + " : <font color=#777777>" + matchedClass2 . substring ( 0 , d ) + "</font></html>" , matchedClass , CompletionCandidate . PREDEF_CLASS ) ) ; } } } else { Base . loge ( "Complex expression " + getNodeAsString ( testnode ) ) ; log ( "candidates empty" ) ; ASTNode childExpr = getChildExpression ( testnode ) ; log ( "Parent expression : " + getParentExpression ( testnode ) ) ; log ( "Child expression : " + childExpr ) ; if ( childExpr != null ) { if ( ! noCompare ) { log ( "Original testnode " + getNodeAsString ( testnode ) ) ; testnode = getParentExpression ( testnode ) ; log ( "Corrected testnode " + getNodeAsString ( testnode ) ) ; } ClassMember expr = resolveExpression3rdParty ( nearestNode , testnode , noCompare ) ; if ( expr == null ) { log ( "Expr is null" ) ; } else { log ( "Expr is " + expr . toString ( ) ) ; candidates = getMembersForType ( expr , childExpr . toString ( ) , noCompare , false ) ; } } else { log ( "ChildExpr is null" ) ; } } showPredictions ( word ) ; predictionOngoing . set ( false ) ; } protected void showPredictions ( final String word ) { if ( sketchOutline != null && sketchOutline . isVisible ( ) ) { return ; } Collections . sort ( candidates ) ; DefaultListModel < CompletionCandidate > defListModel = filterPredictions ( ) ; errorCheckerService . getEditor ( ) . getJavaTextArea ( ) . showSuggestion ( defListModel , word ) ; } private DefaultListModel < CompletionCandidate > filterPredictions ( ) { DefaultListModel < CompletionCandidate > defListModel = new DefaultListModel < CompletionCandidate > ( ) ; if ( candidates . isEmpty ( ) ) return defListModel ; if ( candidates . get ( 0 ) . getElementName ( ) . equals ( candidates . get ( candidates . size ( ) - 1 ) . getElementName ( ) ) ) { log ( "All CC are methods only: " + candidates . get ( 0 ) . getElementName ( ) ) ; for ( int i = 0 ; i < candidates . size ( ) ; i ++ ) { candidates . get ( i ) . regenerateCompletionString ( ) ; defListModel . addElement ( candidates . get ( i ) ) ; } } else { boolean ignoredSome = false ; for ( int i = 0 ; i < candidates . size ( ) ; i ++ ) { if ( i > 0 && ( candidates . get ( i ) . getElementName ( ) . equals ( candidates . get ( i - 1 ) . getElementName ( ) ) ) ) { if ( candidates . get ( i ) . getType ( ) == CompletionCandidate . LOCAL_METHOD || candidates . get ( i ) . getType ( ) == CompletionCandidate . PREDEF_METHOD ) { CompletionCandidate cc = candidates . get ( i - 1 ) ; String label = cc . getLabel ( ) ; int x = label . lastIndexOf ( ')' ) ; if ( candidates . get ( i ) . getType ( ) == CompletionCandidate . PREDEF_METHOD ) { cc . setLabel ( ( cc . getLabel ( ) . contains ( "<html>" ) ? "<html>" : "" ) + cc . getElementName ( ) + "(...)" + label . substring ( x + 1 ) ) ; } else { cc . setLabel ( cc . getElementName ( ) + "(...)" + label . substring ( x + 1 ) ) ; } cc . setCompletionString ( cc . getElementName ( ) + "(" ) ; ignoredSome = true ; continue ; } } defListModel . addElement ( candidates . get ( i ) ) ; } if ( ignoredSome ) { log ( "Some suggestions hidden" ) ; } } return defListModel ; } public ArrayList < CompletionCandidate > getMembersForType ( String typeName , String child , boolean noCompare , boolean staticOnly ) { ArrayList < CompletionCandidate > candidates = new ArrayList < CompletionCandidate > ( ) ; log ( "In GMFT(), Looking for match " + child . toString ( ) + " in class " + typeName + " noCompare " + noCompare + " staticOnly " + staticOnly ) ; Class < ? > probableClass = findClassIfExists ( typeName ) ; if ( probableClass == null ) { log ( "In GMFT(), class not found." ) ; return candidates ; } return getMembersForType ( new ClassMember ( probableClass ) , child , noCompare , staticOnly ) ; } public ArrayList < CompletionCandidate > getMembersForType ( ClassMember tehClass , String childToLookFor , boolean noCompare , boolean staticOnly ) { String child = childToLookFor . toLowerCase ( ) ; ArrayList < CompletionCandidate > candidates = new ArrayList < CompletionCandidate > ( ) ; log ( "getMemFoType-> Looking for match " + child . toString ( ) + " inside " + tehClass + " noCompare " + noCompare + " staticOnly " + staticOnly ) ; if ( tehClass == null ) { return candidates ; } if ( tehClass . getDeclaringNode ( ) instanceof TypeDeclaration ) { TypeDeclaration td = ( TypeDeclaration ) tehClass . getDeclaringNode ( ) ; for ( int i = 0 ; i < td . getFields ( ) . length ; i ++ ) { List < VariableDeclarationFragment > vdfs = td . getFields ( ) [ i ] . fragments ( ) ; for ( VariableDeclarationFragment vdf : vdfs ) { if ( noCompare ) { candidates . add ( new CompletionCandidate ( vdf ) ) ; } else if ( vdf . getName ( ) . toString ( ) . toLowerCase ( ) . startsWith ( child ) ) candidates . add ( new CompletionCandidate ( vdf ) ) ; } } for ( int i = 0 ; i < td . getMethods ( ) . length ; i ++ ) { if ( noCompare ) { candidates . add ( new CompletionCandidate ( td . getMethods ( ) [ i ] ) ) ; } else if ( td . getMethods ( ) [ i ] . getName ( ) . toString ( ) . toLowerCase ( ) . startsWith ( child ) ) candidates . add ( new CompletionCandidate ( td . getMethods ( ) [ i ] ) ) ; } ArrayList < CompletionCandidate > superClassCandidates = new ArrayList < CompletionCandidate > ( ) ; if ( td . getSuperclassType ( ) != null ) { log ( getNodeAsString ( td . getSuperclassType ( ) ) + " <-Looking into superclass of " + tehClass ) ; superClassCandidates = getMembersForType ( new ClassMember ( td . getSuperclassType ( ) ) , childToLookFor , noCompare , staticOnly ) ; } else { superClassCandidates = getMembersForType ( new ClassMember ( Object . class ) , childToLookFor , noCompare , staticOnly ) ; } for ( CompletionCandidate cc : superClassCandidates ) { candidates . add ( cc ) ; } return candidates ; } Class < ? > probableClass ; if ( tehClass . getClass_ ( ) != null ) { probableClass = tehClass . getClass_ ( ) ; } else { probableClass = findClassIfExists ( tehClass . getTypeAsString ( ) ) ; if ( probableClass == null ) { log ( "Couldn't find class " + tehClass . getTypeAsString ( ) ) ; return candidates ; } log ( "Loaded " + probableClass . toString ( ) ) ; } for ( Method method : probableClass . getMethods ( ) ) { if ( ! Modifier . isStatic ( method . getModifiers ( ) ) && staticOnly ) { continue ; } StringBuilder label = new StringBuilder ( method . getName ( ) + "(" ) ; for ( int i = 0 ; i < method . getParameterTypes ( ) . length ; i ++ ) { label . append ( method . getParameterTypes ( ) [ i ] . getSimpleName ( ) ) ; if ( i < method . getParameterTypes ( ) . length - 1 ) label . append ( "," ) ; } label . append ( ")" ) ; if ( noCompare ) { candidates . add ( new CompletionCandidate ( method ) ) ; } else if ( label . toString ( ) . toLowerCase ( ) . startsWith ( child ) ) { candidates . add ( new CompletionCandidate ( method ) ) ; } } for ( Field field : probableClass . getFields ( ) ) { if ( ! Modifier . isStatic ( field . getModifiers ( ) ) && staticOnly ) { continue ; } if ( noCompare ) { candidates . add ( new CompletionCandidate ( field ) ) ; } else if ( field . getName ( ) . toLowerCase ( ) . startsWith ( child ) ) { candidates . add ( new CompletionCandidate ( field ) ) ; } } return candidates ; } public String getPDESourceCodeLine ( int javaLineNumber ) { int res [ ] = errorCheckerService . calculateTabIndexAndLineNumber ( javaLineNumber ) ; if ( res != null ) { return errorCheckerService . getPDECodeAtLine ( res [ 0 ] , res [ 1 ] ) ; } return null ; } public String getJavaSourceCodeLine ( int javaLineNumber ) { try { PlainDocument javaSource = new PlainDocument ( ) ; javaSource . insertString ( 0 , errorCheckerService . sourceCode , null ) ; Element lineElement = javaSource . getDefaultRootElement ( ) . getElement ( javaLineNumber - 1 ) ; if ( lineElement == null ) { log ( "Couldn't fetch jlinenum " + javaLineNumber ) ; return null ; } String javaLine = javaSource . getText ( lineElement . getStartOffset ( ) , lineElement . getEndOffset ( ) - lineElement . getStartOffset ( ) ) ; return javaLine ; } catch ( BadLocationException e ) { Base . loge ( e + " in getJavaSourceCodeline() for jinenum: " + javaLineNumber ) ; } return null ; } public Element getJavaSourceCodeElement ( int javaLineNumber ) { try { PlainDocument javaSource = new PlainDocument ( ) ; javaSource . insertString ( 0 , errorCheckerService . sourceCode , null ) ; Element lineElement = javaSource . getDefaultRootElement ( ) . getElement ( javaLineNumber - 1 ) ; if ( lineElement == null ) { log ( "Couldn't fetch jlinenum " + javaLineNumber ) ; return null ; } return lineElement ; } catch ( BadLocationException e ) { Base . loge ( e + " in getJavaSourceCodeline() for jinenum: " + javaLineNumber ) ; } return null ; } protected Class < ? > findClassIfExists ( String className ) { if ( className == null ) { return null ; } Class < ? > tehClass = null ; tehClass = loadClass ( className ) ; if ( tehClass != null ) { return tehClass ; } log ( "Looking in the classloader for " + className ) ; ArrayList < ImportStatement > imports = errorCheckerService . getProgramImports ( ) ; for ( ImportStatement impS : imports ) { String temp = impS . getPackageName ( ) ; if ( temp . endsWith ( "*" ) ) { temp = temp . substring ( 0 , temp . length ( ) - 1 ) + className ; } else { int x = temp . lastIndexOf ( '.' ) ; if ( ! temp . substring ( x + 1 ) . equals ( className ) ) { continue ; } } tehClass = loadClass ( temp ) ; if ( tehClass != null ) { log ( tehClass . getName ( ) + " located." ) ; return tehClass ; } } PdePreprocessor p = new PdePreprocessor ( null ) ; for ( String impS : p . getCoreImports ( ) ) { tehClass = loadClass ( impS . substring ( 0 , impS . length ( ) - 1 ) + className ) ; if ( tehClass != null ) { log ( tehClass . getName ( ) + " located." ) ; return tehClass ; } } for ( String impS : p . getDefaultImports ( ) ) { if ( className . equals ( impS ) || impS . endsWith ( className ) ) { tehClass = loadClass ( impS ) ; if ( tehClass != null ) { log ( tehClass . getName ( ) + " located." ) ; return tehClass ; } } } String daddy = "java.lang." + className ; tehClass = loadClass ( daddy ) ; if ( tehClass != null ) { log ( tehClass . getName ( ) + " located." ) ; return tehClass ; } return tehClass ; } protected Class < ? > loadClass ( String className ) { Class < ? > tehClass = null ; if ( className != null ) { try { tehClass = Class . forName ( className , false , errorCheckerService . getSketchClassLoader ( ) ) ; } catch ( ClassNotFoundException e ) { } } return tehClass ; } public ClassMember definedIn3rdPartyClass ( String className , String memberName ) { Class < ? > probableClass = findClassIfExists ( className ) ; if ( probableClass == null ) { log ( "Couldn't load " + className ) ; return null ; } if ( memberName . equals ( "THIS" ) ) { return new ClassMember ( probableClass ) ; } else { return definedIn3rdPartyClass ( new ClassMember ( probableClass ) , memberName ) ; } } public ClassMember definedIn3rdPartyClass ( ClassMember tehClass , String memberName ) { if ( tehClass == null ) return null ; log ( "definedIn3rdPartyClass-> Looking for " + memberName + " in " + tehClass ) ; String memberNameL = memberName . toLowerCase ( ) ; if ( tehClass . getDeclaringNode ( ) instanceof TypeDeclaration ) { TypeDeclaration td = ( TypeDeclaration ) tehClass . getDeclaringNode ( ) ; for ( int i = 0 ; i < td . getFields ( ) . length ; i ++ ) { List < VariableDeclarationFragment > vdfs = td . getFields ( ) [ i ] . fragments ( ) ; for ( VariableDeclarationFragment vdf : vdfs ) { if ( vdf . getName ( ) . toString ( ) . toLowerCase ( ) . startsWith ( memberNameL ) ) return new ClassMember ( vdf ) ; } } for ( int i = 0 ; i < td . getMethods ( ) . length ; i ++ ) { if ( td . getMethods ( ) [ i ] . getName ( ) . toString ( ) . toLowerCase ( ) . startsWith ( memberNameL ) ) return new ClassMember ( td . getMethods ( ) [ i ] ) ; } if ( td . getSuperclassType ( ) != null ) { log ( getNodeAsString ( td . getSuperclassType ( ) ) + " <-Looking into superclass of " + tehClass ) ; return definedIn3rdPartyClass ( new ClassMember ( td . getSuperclassType ( ) ) , memberName ) ; } else { return definedIn3rdPartyClass ( new ClassMember ( Object . class ) , memberName ) ; } } Class < ? > probableClass = null ; if ( tehClass . getClass_ ( ) != null ) { probableClass = tehClass . getClass_ ( ) ; } else { probableClass = findClassIfExists ( tehClass . getTypeAsString ( ) ) ; log ( "Loaded " + probableClass . toString ( ) ) ; } for ( Method method : probableClass . getMethods ( ) ) { if ( method . getName ( ) . equalsIgnoreCase ( memberName ) ) { return new ClassMember ( method ) ; } } for ( Field field : probableClass . getFields ( ) ) { if ( field . getName ( ) . equalsIgnoreCase ( memberName ) ) { return new ClassMember ( field ) ; } } return null ; } public void updateJavaDoc ( final CompletionCandidate candidate ) { return ; } protected static ASTNode findClosestParentNode ( int lineNumber , ASTNode node ) { Iterator < StructuralPropertyDescriptor > it = node . structuralPropertiesForType ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { StructuralPropertyDescriptor prop = it . next ( ) ; if ( prop . isChildProperty ( ) || prop . isSimpleProperty ( ) ) { if ( node . getStructuralProperty ( prop ) != null ) { if ( node . getStructuralProperty ( prop ) instanceof ASTNode ) { ASTNode cnode = ( ASTNode ) node . getStructuralProperty ( prop ) ; int cLineNum = ( ( CompilationUnit ) cnode . getRoot ( ) ) . getLineNumber ( cnode . getStartPosition ( ) + cnode . getLength ( ) ) ; if ( getLineNumber ( cnode ) <= lineNumber && lineNumber <= cLineNum ) { return findClosestParentNode ( lineNumber , cnode ) ; } } } } else if ( prop . isChildListProperty ( ) ) { List < ASTNode > nodelist = ( List < ASTNode > ) node . getStructuralProperty ( prop ) ; for ( ASTNode cnode : nodelist ) { int cLineNum = ( ( CompilationUnit ) cnode . getRoot ( ) ) . getLineNumber ( cnode . getStartPosition ( ) + cnode . getLength ( ) ) ; if ( getLineNumber ( cnode ) <= lineNumber && lineNumber <= cLineNum ) { return findClosestParentNode ( lineNumber , cnode ) ; } } } } return node ; } protected static ASTNode findClosestNode ( int lineNumber , ASTNode node ) { log ( "findClosestNode to line " + lineNumber ) ; ASTNode parent = findClosestParentNode ( lineNumber , node ) ; log ( "findClosestParentNode returned " + getNodeAsString ( parent ) ) ; if ( parent == null ) return null ; if ( getLineNumber ( parent ) == lineNumber ) { log ( parent + "|PNode " + getLineNumber ( parent ) + ", lfor " + lineNumber ) ; return parent ; } List < ASTNode > nodes = null ; if ( parent instanceof TypeDeclaration ) { nodes = ( ( TypeDeclaration ) parent ) . bodyDeclarations ( ) ; } else if ( parent instanceof Block ) { nodes = ( ( Block ) parent ) . statements ( ) ; } else { System . err . println ( "THIS CONDITION SHOULD NOT OCCUR - findClosestNode " + getNodeAsString ( parent ) ) ; return null ; } if ( nodes . size ( ) > 0 ) { ASTNode retNode = parent ; for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { ASTNode cNode = nodes . get ( i ) ; log ( cNode + "|cNode " + getLineNumber ( cNode ) + ", lfor " + lineNumber ) ; if ( getLineNumber ( cNode ) <= lineNumber ) retNode = cNode ; } return retNode ; } return parent ; } public DefaultMutableTreeNode getAST ( ) { return codeTree ; } public String getLabelForASTNode ( int lineNumber , String name , int offset ) { return getASTNodeAt ( lineNumber , name , offset , false ) . getLabel ( ) ; } protected String getLabelIfType ( ASTNodeWrapper node , SimpleName sn ) { ASTNode current = node . getNode ( ) . getParent ( ) ; String type = "" ; StringBuilder fullName = new StringBuilder ( ) ; Stack < String > parents = new Stack < String > ( ) ; String simpleName = ( sn == null ) ? node . getNode ( ) . toString ( ) : sn . toString ( ) ; switch ( node . getNodeType ( ) ) { case ASTNode . TYPE_DECLARATION : case ASTNode . METHOD_DECLARATION : case ASTNode . FIELD_DECLARATION : while ( current != null ) { if ( current instanceof TypeDeclaration ) { parents . push ( ( ( TypeDeclaration ) current ) . getName ( ) . toString ( ) ) ; } current = current . getParent ( ) ; } while ( parents . size ( ) > 0 ) { fullName . append ( parents . pop ( ) + "." ) ; } fullName . append ( simpleName ) ; if ( node . getNode ( ) instanceof MethodDeclaration ) { MethodDeclaration md = ( MethodDeclaration ) node . getNode ( ) ; if ( ! md . isConstructor ( ) ) type = md . getReturnType2 ( ) . toString ( ) ; fullName . append ( '(' ) ; if ( ! md . parameters ( ) . isEmpty ( ) ) { List < ASTNode > params = md . parameters ( ) ; for ( ASTNode par : params ) { if ( par instanceof SingleVariableDeclaration ) { SingleVariableDeclaration svd = ( SingleVariableDeclaration ) par ; fullName . append ( svd . getType ( ) + " " + svd . getName ( ) + "," ) ; } } } if ( fullName . charAt ( fullName . length ( ) - 1 ) == ',' ) fullName . deleteCharAt ( fullName . length ( ) - 1 ) ; fullName . append ( ')' ) ; } else if ( node . getNode ( ) instanceof FieldDeclaration ) { type = ( ( FieldDeclaration ) node . getNode ( ) ) . getType ( ) . toString ( ) ; } int x = fullName . indexOf ( "." ) ; fullName . delete ( 0 , x + 1 ) ; return type + " " + fullName ; case ASTNode . SINGLE_VARIABLE_DECLARATION : SingleVariableDeclaration svd = ( SingleVariableDeclaration ) node . getNode ( ) ; return svd . getType ( ) + " " + svd . getName ( ) ; case ASTNode . VARIABLE_DECLARATION_STATEMENT : return ( ( VariableDeclarationStatement ) node . getNode ( ) ) . getType ( ) + " " + simpleName ; case ASTNode . VARIABLE_DECLARATION_EXPRESSION : return ( ( VariableDeclarationExpression ) node . getNode ( ) ) . getType ( ) + " " + simpleName ; default : break ; } return "" ; } public void scrollToDeclaration ( int lineNumber , String name , int offset ) { getASTNodeAt ( lineNumber , name , offset , true ) ; } public ASTNodeWrapper getASTNodeAt ( int lineNumber , String name , int offset , boolean scrollOnly ) { int pdeLineNumber = lineNumber + errorCheckerService . mainClassOffset ; if ( errorCheckerService != null ) { editor = errorCheckerService . getEditor ( ) ; int codeIndex = editor . getSketch ( ) . getCodeIndex ( editor . getCurrentTab ( ) ) ; if ( codeIndex > 0 ) { for ( int i = 0 ; i < codeIndex ; i ++ ) { SketchCode sc = editor . getSketch ( ) . getCode ( i ) ; int len = Base . countLines ( sc . getProgram ( ) ) + 1 ; pdeLineNumber += len ; } } } ASTNode lineNode = findLineOfNode ( compilationUnit , pdeLineNumber , offset , name ) ; ASTNode decl = null ; String nodeLabel = null ; String nameOfNode = null ; if ( lineNode != null ) { String pdeCodeLine = errorCheckerService . getPDECodeAtLine ( editor . getSketch ( ) . getCurrentCodeIndex ( ) , lineNumber ) ; String javaCodeLine = getJavaSourceCodeLine ( pdeLineNumber ) ; OffsetMatcher ofm = new OffsetMatcher ( pdeCodeLine , javaCodeLine ) ; int javaOffset = ofm . getJavaOffForPdeOff ( offset , name . length ( ) ) + lineNode . getStartPosition ( ) ; ASTNode simpName = dfsLookForASTNode ( errorCheckerService . getLatestCU ( ) , name , javaOffset , javaOffset + name . length ( ) ) ; if ( simpName == null && lineNode instanceof SimpleName ) { switch ( lineNode . getParent ( ) . getNodeType ( ) ) { case ASTNode . TYPE_DECLARATION : case ASTNode . METHOD_DECLARATION : case ASTNode . FIELD_DECLARATION : case ASTNode . VARIABLE_DECLARATION_FRAGMENT : decl = lineNode . getParent ( ) ; return new ASTNodeWrapper ( decl , "" ) ; default : break ; } } if ( simpName instanceof SimpleName ) { nameOfNode = simpName . toString ( ) ; decl = findDeclaration ( ( SimpleName ) simpName ) ; if ( decl != null ) { nodeLabel = getLabelIfType ( new ASTNodeWrapper ( decl ) , ( SimpleName ) simpName ) ; } else { if ( scrollOnly ) { editor . statusMessage ( simpName + " is not defined in this sketch" , JavaEditor . STATUS_ERR ) ; } } } } if ( decl != null && scrollOnly ) { ASTNode simpName2 = getNodeName ( decl , nameOfNode ) ; ASTNodeWrapper declWrap = new ASTNodeWrapper ( simpName2 , nodeLabel ) ; if ( ! declWrap . highlightNode ( this ) ) { Base . loge ( "Highlighting failed." ) ; } } return new ASTNodeWrapper ( decl , nodeLabel ) ; } protected static ASTNode getNodeName ( ASTNode node , String name ) { List < VariableDeclarationFragment > vdfs = null ; switch ( node . getNodeType ( ) ) { case ASTNode . TYPE_DECLARATION : return ( ( TypeDeclaration ) node ) . getName ( ) ; case ASTNode . METHOD_DECLARATION : return ( ( MethodDeclaration ) node ) . getName ( ) ; case ASTNode . SINGLE_VARIABLE_DECLARATION : return ( ( SingleVariableDeclaration ) node ) . getName ( ) ; case ASTNode . FIELD_DECLARATION : vdfs = ( ( FieldDeclaration ) node ) . fragments ( ) ; break ; case ASTNode . VARIABLE_DECLARATION_STATEMENT : vdfs = ( ( VariableDeclarationStatement ) node ) . fragments ( ) ; break ; case ASTNode . VARIABLE_DECLARATION_EXPRESSION : vdfs = ( ( VariableDeclarationExpression ) node ) . fragments ( ) ; break ; default : break ; } if ( vdfs != null ) { for ( VariableDeclarationFragment vdf : vdfs ) { if ( vdf . getName ( ) . toString ( ) . equals ( name ) ) { return vdf . getName ( ) ; } } } return null ; } public static int getLineNumber ( ASTNode node ) { return ( ( CompilationUnit ) node . getRoot ( ) ) . getLineNumber ( node . getStartPosition ( ) ) ; } public static int getLineNumber ( ASTNode node , int pos ) { return ( ( CompilationUnit ) node . getRoot ( ) ) . getLineNumber ( pos ) ; } final ASTGenerator thisASTGenerator = this ; protected void addListeners ( ) { jtree . addTreeSelectionListener ( new TreeSelectionListener ( ) { @ Override public void valueChanged ( TreeSelectionEvent e ) { Base . log ( e . toString ( ) ) ; SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { @ Override protected Object doInBackground ( ) throws Exception { return null ; } protected void done ( ) { if ( jtree . getLastSelectedPathComponent ( ) == null ) { return ; } DefaultMutableTreeNode tnode = ( DefaultMutableTreeNode ) jtree . getLastSelectedPathComponent ( ) ; if ( tnode . getUserObject ( ) instanceof ASTNodeWrapper ) { ASTNodeWrapper awrap = ( ASTNodeWrapper ) tnode . getUserObject ( ) ; awrap . highlightNode ( thisASTGenerator ) ; try { int javaLineNumber = getLineNumber ( awrap . getNode ( ) ) ; int pdeOffs [ ] = errorCheckerService . calculateTabIndexAndLineNumber ( javaLineNumber ) ; PlainDocument javaSource = new PlainDocument ( ) ; javaSource . insertString ( 0 , errorCheckerService . sourceCode , null ) ; Element lineElement = javaSource . getDefaultRootElement ( ) . getElement ( javaLineNumber - 1 ) ; if ( lineElement == null ) { return ; } String javaLine = javaSource . getText ( lineElement . getStartOffset ( ) , lineElement . getEndOffset ( ) - lineElement . getStartOffset ( ) ) ; editor . getSketch ( ) . setCurrentCode ( pdeOffs [ 0 ] ) ; String pdeLine = editor . getLineText ( pdeOffs [ 1 ] ) ; log ( "JL " + javaLine + " LSO " + lineElement . getStartOffset ( ) + "," + lineElement . getEndOffset ( ) ) ; log ( "PL " + pdeLine ) ; } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } } } } ; worker . execute ( ) ; } } ) ; btnRename . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( txtRenameField . getText ( ) . length ( ) == 0 ) return ; SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { @ Override protected Object doInBackground ( ) throws Exception { return null ; } protected void done ( ) { refactorIt ( ) ; } } ; worker . execute ( ) ; } } ) ; btnListOccurrence . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { @ Override protected Object doInBackground ( ) throws Exception { return null ; } protected void done ( ) { handleShowUsage ( ) ; } } ; worker . execute ( ) ; } } ) ; refactorTree . addTreeSelectionListener ( new TreeSelectionListener ( ) { @ Override public void valueChanged ( TreeSelectionEvent e ) { log ( e ) ; SwingWorker < Object , Object > worker = new SwingWorker < Object , Object > ( ) { @ Override protected Object doInBackground ( ) throws Exception { return null ; } protected void done ( ) { if ( refactorTree . getLastSelectedPathComponent ( ) == null ) { return ; } DefaultMutableTreeNode tnode = ( DefaultMutableTreeNode ) refactorTree . getLastSelectedPathComponent ( ) ; if ( tnode . getUserObject ( ) instanceof ASTNodeWrapper ) { ASTNodeWrapper awrap = ( ASTNodeWrapper ) tnode . getUserObject ( ) ; awrap . highlightNode ( thisASTGenerator ) ; } } } ; worker . execute ( ) ; } } ) ; } protected void refactorIt ( ) { String newName = txtRenameField . getText ( ) . trim ( ) ; String selText = lastClickedWord == null ? getSelectedText ( ) : lastClickedWord ; DefaultMutableTreeNode defCU = findAllOccurrences ( ) ; if ( defCU == null ) { editor . statusMessage ( "Can't locate definition of " + selText , JavaEditor . STATUS_ERR ) ; return ; } if ( ! newName . matches ( "([a-zA-Z][a-zA-Z0-9_]*)|([_][a-zA-Z0-9_]+)" ) ) { JOptionPane . showConfirmDialog ( new JFrame ( ) , newName + " isn't a valid name." , "Uh oh.." , JOptionPane . PLAIN_MESSAGE ) ; return ; } errorCheckerService . pauseThread ( ) ; if ( refactorTree . isVisible ( ) ) { refactorTree . setModel ( new DefaultTreeModel ( defCU ) ) ; ( ( DefaultTreeModel ) refactorTree . getModel ( ) ) . reload ( ) ; } int lineOffsetDisplacementConst = newName . length ( ) - selText . length ( ) ; HashMap < Integer , Integer > lineOffsetDisplacement = new HashMap < Integer , Integer > ( ) ; int pdeOffsets [ ] [ ] = new int [ defCU . getChildCount ( ) ] [ 3 ] ; for ( int i = 0 ; i < defCU . getChildCount ( ) ; i ++ ) { ASTNodeWrapper awrap = ( ASTNodeWrapper ) ( ( DefaultMutableTreeNode ) ( defCU . getChildAt ( i ) ) ) . getUserObject ( ) ; int ans [ ] = errorCheckerService . calculateTabIndexAndLineNumber ( awrap . getLineNumber ( ) ) ; pdeOffsets [ i ] [ 0 ] = ans [ 0 ] ; pdeOffsets [ i ] [ 1 ] = ans [ 1 ] ; pdeOffsets [ i ] [ 2 ] = awrap . getPDECodeOffsetForSN ( this ) ; } editor . startCompoundEdit ( ) ; for ( int i = 0 ; i < defCU . getChildCount ( ) ; i ++ ) { ASTNodeWrapper awrap = ( ASTNodeWrapper ) ( ( DefaultMutableTreeNode ) ( defCU . getChildAt ( i ) ) ) . getUserObject ( ) ; int off = 0 ; if ( lineOffsetDisplacement . get ( awrap . getLineNumber ( ) ) != null ) { off = lineOffsetDisplacement . get ( awrap . getLineNumber ( ) ) ; lineOffsetDisplacement . put ( awrap . getLineNumber ( ) , lineOffsetDisplacementConst + off ) ; } else { lineOffsetDisplacement . put ( awrap . getLineNumber ( ) , lineOffsetDisplacementConst ) ; } highlightPDECode ( pdeOffsets [ i ] [ 0 ] , pdeOffsets [ i ] [ 1 ] , pdeOffsets [ i ] [ 2 ] + off , awrap . getNode ( ) . toString ( ) . length ( ) ) ; editor . getTextArea ( ) . setSelectedText ( newName ) ; } editor . stopCompoundEdit ( ) ; errorCheckerService . resumeThread ( ) ; editor . getSketch ( ) . setModified ( true ) ; errorCheckerService . runManualErrorCheck ( ) ; frmRename . setVisible ( false ) ; lastClickedWord = null ; lastClickedWordNode = null ; } public void highlightPDECode ( int tab , int lineNumber , int lineStartWSOffset , int length ) { editor . toFront ( ) ; editor . getSketch ( ) . setCurrentCode ( tab ) ; lineStartWSOffset += editor . getTextArea ( ) . getLineStartOffset ( lineNumber ) ; editor . getTextArea ( ) . select ( lineStartWSOffset , lineStartWSOffset + length ) ; } public void handleShowUsage ( ) { if ( editor . hasJavaTabs ( ) ) return ; log ( "Last clicked word:" + lastClickedWord ) ; if ( lastClickedWord == null && getSelectedText ( ) == null ) { editor . statusMessage ( "Highlight the class/function/variable name first" , JavaEditor . STATUS_INFO ) ; return ; } if ( errorCheckerService . hasSyntaxErrors ( ) ) { editor . statusMessage ( "Can't perform action until syntax errors are " + "fixed :(" , JavaEditor . STATUS_WARNING ) ; return ; } DefaultMutableTreeNode defCU = findAllOccurrences ( ) ; String selText = lastClickedWord == null ? getSelectedText ( ) : lastClickedWord ; if ( defCU == null ) { editor . statusMessage ( "Can't locate definition of " + selText , JavaEditor . STATUS_ERR ) ; return ; } if ( defCU . getChildCount ( ) == 0 ) return ; refactorTree . setModel ( new DefaultTreeModel ( defCU ) ) ; ( ( DefaultTreeModel ) refactorTree . getModel ( ) ) . reload ( ) ; refactorTree . setRootVisible ( false ) ; frmOccurenceList . setTitle ( "Usage of \"" + selText + "\" : " + defCU . getChildCount ( ) + " time(s)" ) ; frmOccurenceList . setLocation ( editor . getX ( ) + editor . getWidth ( ) , editor . getY ( ) ) ; frmOccurenceList . setVisible ( true ) ; lastClickedWord = null ; lastClickedWordNode = null ; } protected String lastClickedWord = null ; protected ASTNodeWrapper lastClickedWordNode = null ; public String getLastClickedWord ( ) { return lastClickedWord ; } public void setLastClickedWord ( int lineNumber , String lastClickedWord , int offset ) { this . lastClickedWord = lastClickedWord ; lastClickedWordNode = getASTNodeAt ( lineNumber , lastClickedWord , offset , false ) ; log ( "Last clicked node: " + lastClickedWordNode ) ; } protected DefaultMutableTreeNode findAllOccurrences ( ) { final JEditTextArea ta = editor . getTextArea ( ) ; log ( "Last clicked word:" + lastClickedWord ) ; String selText = lastClickedWord == null ? ta . getSelectedText ( ) : lastClickedWord ; int line = ta . getSelectionStartLine ( ) ; log ( selText + "<- offsets " + ( line ) + ", " + ( ta . getSelectionStart ( ) - ta . getLineStartOffset ( line ) ) + ", " + ( ta . getSelectionStop ( ) - ta . getLineStartOffset ( line ) ) ) ; int offwhitespace = ta . getLineStartNonWhiteSpaceOffset ( line ) ; ASTNodeWrapper wnode ; if ( lastClickedWord == null || lastClickedWordNode . getNode ( ) == null ) { wnode = getASTNodeAt ( line + errorCheckerService . mainClassOffset , selText , ta . getSelectionStart ( ) - offwhitespace , false ) ; } else { wnode = lastClickedWordNode ; } if ( wnode . getNode ( ) == null ) { return null ; } Base . loge ( "Gonna find all occurrences of " + getNodeAsString ( wnode . getNode ( ) ) ) ; if ( wnode . getNodeType ( ) == ASTNode . METHOD_DECLARATION ) { MethodDeclaration md = ( MethodDeclaration ) wnode . getNode ( ) ; ASTNode node = md . getParent ( ) ; while ( node != null ) { if ( node instanceof TypeDeclaration ) { break ; } node = node . getParent ( ) ; } if ( node != null && node instanceof TypeDeclaration ) { TypeDeclaration td = ( TypeDeclaration ) node ; if ( td . getName ( ) . toString ( ) . equals ( md . getName ( ) . toString ( ) ) ) { Base . loge ( "Renaming constructor of " + getNodeAsString ( td ) ) ; wnode = new ASTNodeWrapper ( td ) ; } } } DefaultMutableTreeNode defCU = new DefaultMutableTreeNode ( new ASTNodeWrapper ( wnode . getNode ( ) , selText ) ) ; dfsNameOnly ( defCU , wnode . getNode ( ) , selText ) ; Stack < Object > tempS = new Stack < Object > ( ) ; for ( int i = 0 ; i < defCU . getChildCount ( ) ; i ++ ) { tempS . push ( defCU . getChildAt ( i ) ) ; } defCU . removeAllChildren ( ) ; while ( ! tempS . isEmpty ( ) ) { defCU . add ( ( MutableTreeNode ) tempS . pop ( ) ) ; } log ( wnode ) ; return defCU ; } public static void visitRecur ( ASTNode node , DefaultMutableTreeNode tnode ) { Iterator < StructuralPropertyDescriptor > it = node . structuralPropertiesForType ( ) . iterator ( ) ; DefaultMutableTreeNode ctnode = null ; while ( it . hasNext ( ) ) { StructuralPropertyDescriptor prop = it . next ( ) ; if ( prop . isChildProperty ( ) || prop . isSimpleProperty ( ) ) { if ( node . getStructuralProperty ( prop ) != null ) { if ( node . getStructuralProperty ( prop ) instanceof ASTNode ) { ASTNode cnode = ( ASTNode ) node . getStructuralProperty ( prop ) ; if ( isAddableASTNode ( cnode ) ) { ctnode = new DefaultMutableTreeNode ( new ASTNodeWrapper ( ( ASTNode ) node . getStructuralProperty ( prop ) ) ) ; tnode . add ( ctnode ) ; visitRecur ( cnode , ctnode ) ; } } else { tnode . add ( new DefaultMutableTreeNode ( node . getStructuralProperty ( prop ) ) ) ; } } } else if ( prop . isChildListProperty ( ) ) { List < ASTNode > nodelist = ( List < ASTNode > ) node . getStructuralProperty ( prop ) ; for ( ASTNode cnode : nodelist ) { if ( isAddableASTNode ( cnode ) ) { ctnode = new DefaultMutableTreeNode ( new ASTNodeWrapper ( cnode ) ) ; tnode . add ( ctnode ) ; visitRecur ( cnode , ctnode ) ; } else { visitRecur ( cnode , tnode ) ; } } } } } public void dfsNameOnly ( DefaultMutableTreeNode tnode , ASTNode decl , String name ) { Stack < DefaultMutableTreeNode > temp = new Stack < DefaultMutableTreeNode > ( ) ; temp . push ( codeTree ) ; while ( ! temp . isEmpty ( ) ) { DefaultMutableTreeNode cnode = temp . pop ( ) ; for ( int i = 0 ; i < cnode . getChildCount ( ) ; i ++ ) { temp . push ( ( DefaultMutableTreeNode ) cnode . getChildAt ( i ) ) ; } if ( ! ( cnode . getUserObject ( ) instanceof ASTNodeWrapper ) ) continue ; ASTNodeWrapper awnode = ( ASTNodeWrapper ) cnode . getUserObject ( ) ; if ( isInstanceOfType ( awnode . getNode ( ) , decl , name ) ) { int val [ ] = errorCheckerService . JavaToPdeOffsets ( awnode . getLineNumber ( ) , 0 ) ; tnode . add ( new DefaultMutableTreeNode ( new ASTNodeWrapper ( awnode . getNode ( ) , "Line " + ( val [ 1 ] + 1 ) + " | Tab: " + editor . getSketch ( ) . getCode ( val [ 0 ] ) . getPrettyName ( ) ) ) ) ; } } } public ASTNode dfsLookForASTNode ( ASTNode root , String name , int startOffset , int endOffset ) { Stack < ASTNode > stack = new Stack < ASTNode > ( ) ; stack . push ( root ) ; while ( ! stack . isEmpty ( ) ) { ASTNode node = stack . pop ( ) ; Iterator < StructuralPropertyDescriptor > it = node . structuralPropertiesForType ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { StructuralPropertyDescriptor prop = it . next ( ) ; if ( prop . isChildProperty ( ) || prop . isSimpleProperty ( ) ) { if ( node . getStructuralProperty ( prop ) instanceof ASTNode ) { ASTNode temp = ( ASTNode ) node . getStructuralProperty ( prop ) ; if ( temp . getStartPosition ( ) <= startOffset && ( temp . getStartPosition ( ) + temp . getLength ( ) ) >= endOffset ) { if ( temp instanceof SimpleName ) { if ( name . equals ( temp . toString ( ) ) ) { return temp ; } } else stack . push ( temp ) ; } } } else if ( prop . isChildListProperty ( ) ) { List < ASTNode > nodelist = ( List < ASTNode > ) node . getStructuralProperty ( prop ) ; for ( ASTNode temp : nodelist ) { if ( temp . getStartPosition ( ) <= startOffset && ( temp . getStartPosition ( ) + temp . getLength ( ) ) >= endOffset ) { stack . push ( temp ) ; if ( temp instanceof SimpleName ) { if ( name . equals ( temp . toString ( ) ) ) { return temp ; } } else stack . push ( temp ) ; } } } } } return null ; } protected SketchOutline sketchOutline ; public void showSketchOutline ( ) { if ( editor . hasJavaTabs ( ) ) return ; sketchOutline = new SketchOutline ( codeTree , errorCheckerService ) ; sketchOutline . show ( ) ; } public void showTabOutline ( ) { new TabOutline ( errorCheckerService ) . show ( ) ; } public int javaCodeOffsetToLineStartOffset ( int line , int jOffset ) { line = pdeLineNumToJavaLineNum ( line ) ; log ( "Looking for line: " + line + ", jOff " + jOffset ) ; Stack < DefaultMutableTreeNode > temp = new Stack < DefaultMutableTreeNode > ( ) ; temp . push ( codeTree ) ; while ( ! temp . isEmpty ( ) ) { DefaultMutableTreeNode cnode = temp . pop ( ) ; for ( int i = 0 ; i < cnode . getChildCount ( ) ; i ++ ) { temp . push ( ( DefaultMutableTreeNode ) cnode . getChildAt ( i ) ) ; } if ( ! ( cnode . getUserObject ( ) instanceof ASTNodeWrapper ) ) continue ; ASTNodeWrapper awnode = ( ASTNodeWrapper ) cnode . getUserObject ( ) ; if ( awnode . getLineNumber ( ) == line ) { log ( "First element with this line no is: " + awnode + "LSO: " + ( jOffset - awnode . getNode ( ) . getStartPosition ( ) ) ) ; return ( jOffset - awnode . getNode ( ) . getStartPosition ( ) ) ; } } return - 1 ; } protected int pdeLineNumToJavaLineNum ( int pdeLineNum ) { int javaLineNumber = pdeLineNum + errorCheckerService . getPdeImportsCount ( ) ; int codeIndex = editor . getSketch ( ) . getCodeIndex ( editor . getCurrentTab ( ) ) ; if ( codeIndex > 0 ) for ( int i = 0 ; i < codeIndex ; i ++ ) { SketchCode sc = editor . getSketch ( ) . getCode ( i ) ; int len = Base . countLines ( sc . getProgram ( ) ) + 1 ; javaLineNumber += len ; } return javaLineNumber ; } protected boolean isInstanceOfType ( ASTNode node , ASTNode decl , String name ) { if ( node instanceof SimpleName ) { SimpleName sn = ( SimpleName ) node ; if ( sn . toString ( ) . equals ( name ) ) { ArrayList < ASTNode > nodesToBeMatched = new ArrayList < ASTNode > ( ) ; nodesToBeMatched . add ( decl ) ; if ( decl instanceof TypeDeclaration ) { log ( "decl is a TD" ) ; TypeDeclaration td = ( TypeDeclaration ) decl ; MethodDeclaration [ ] mlist = td . getMethods ( ) ; for ( MethodDeclaration md : mlist ) { if ( md . getName ( ) . toString ( ) . equals ( name ) ) { nodesToBeMatched . add ( md ) ; } } } log ( "Visiting: " + getNodeAsString ( node ) ) ; ASTNode decl2 = findDeclaration ( sn ) ; Base . loge ( "It's decl: " + getNodeAsString ( decl2 ) ) ; log ( "But we need: " + getNodeAsString ( decl ) ) ; for ( ASTNode astNode : nodesToBeMatched ) { if ( astNode . equals ( decl2 ) ) { return true ; } } } } return false ; } public void handleRefactor ( ) { if ( editor . hasJavaTabs ( ) ) return ; log ( "Last clicked word:" + lastClickedWord ) ; if ( lastClickedWord == null && getSelectedText ( ) == null ) { editor . statusMessage ( "Highlight the class/function/variable name first" , JavaEditor . STATUS_INFO ) ; return ; } if ( errorCheckerService . hasSyntaxErrors ( ) ) { editor . statusMessage ( "Can't perform action until syntax errors are fixed :(" , JavaEditor . STATUS_WARNING ) ; return ; } DefaultMutableTreeNode defCU = findAllOccurrences ( ) ; String selText = lastClickedWord == null ? getSelectedText ( ) : lastClickedWord ; if ( defCU == null ) { editor . statusMessage ( selText + " isn't defined in this sketch, so it can't" + " be renamed" , JavaEditor . STATUS_ERR ) ; return ; } if ( ! frmRename . isVisible ( ) ) { frmRename . setLocation ( editor . getX ( ) + ( editor . getWidth ( ) - frmRename . getWidth ( ) ) / 2 , editor . getY ( ) + ( editor . getHeight ( ) - frmRename . getHeight ( ) ) / 2 ) ; frmRename . setVisible ( true ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { String selText = lastClickedWord == null ? getSelectedText ( ) : lastClickedWord ; frmOccurenceList . setTitle ( "All occurrences of " + selText ) ; lblRefactorOldName . setText ( "Current name: " + selText ) ; txtRenameField . setText ( "" ) ; txtRenameField . requestFocus ( ) ; } } ) ; } frmRename . toFront ( ) ; } public static void printRecur ( ASTNode node ) { Iterator < StructuralPropertyDescriptor > it = node . structuralPropertiesForType ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { StructuralPropertyDescriptor prop = it . next ( ) ; if ( prop . isChildProperty ( ) || prop . isSimpleProperty ( ) ) { if ( node . getStructuralProperty ( prop ) != null ) { if ( node . getStructuralProperty ( prop ) instanceof ASTNode ) { ASTNode cnode = ( ASTNode ) node . getStructuralProperty ( prop ) ; log ( getNodeAsString ( cnode ) ) ; printRecur ( cnode ) ; } } } else if ( prop . isChildListProperty ( ) ) { List < ASTNode > nodelist = ( List < ASTNode > ) node . getStructuralProperty ( prop ) ; for ( ASTNode cnode : nodelist ) { log ( getNodeAsString ( cnode ) ) ; printRecur ( cnode ) ; } } } } protected static ASTNode findLineOfNode ( ASTNode node , int lineNumber , int offset , String name ) { CompilationUnit root = ( CompilationUnit ) node . getRoot ( ) ; if ( root . getLineNumber ( node . getStartPosition ( ) ) == lineNumber ) { return node ; } for ( Object oprop : node . structuralPropertiesForType ( ) ) { StructuralPropertyDescriptor prop = ( StructuralPropertyDescriptor ) oprop ; if ( prop . isChildProperty ( ) || prop . isSimpleProperty ( ) ) { if ( node . getStructuralProperty ( prop ) != null ) { if ( node . getStructuralProperty ( prop ) instanceof ASTNode ) { ASTNode retNode = findLineOfNode ( ( ASTNode ) node . getStructuralProperty ( prop ) , lineNumber , offset , name ) ; if ( retNode != null ) { return retNode ; } } } } else if ( prop . isChildListProperty ( ) ) { List < ASTNode > nodelist = ( List < ASTNode > ) node . getStructuralProperty ( prop ) ; for ( ASTNode retNode : nodelist ) { ASTNode rr = findLineOfNode ( retNode , lineNumber , offset , name ) ; if ( rr != null ) { return rr ; } } } } return null ; } public static ASTNode pinpointOnLine ( ASTNode node , int offset , int lineStartOffset , String name ) { if ( node instanceof SimpleName ) { SimpleName sn = ( SimpleName ) node ; if ( ( lineStartOffset + offset ) >= sn . getStartPosition ( ) && ( lineStartOffset + offset ) <= sn . getStartPosition ( ) + sn . getLength ( ) ) { if ( sn . toString ( ) . equals ( name ) ) { return sn ; } else { return null ; } } else { return null ; } } for ( Object oprop : node . structuralPropertiesForType ( ) ) { StructuralPropertyDescriptor prop = ( StructuralPropertyDescriptor ) oprop ; if ( prop . isChildProperty ( ) || prop . isSimpleProperty ( ) ) { if ( node . getStructuralProperty ( prop ) != null ) { if ( node . getStructuralProperty ( prop ) instanceof ASTNode ) { ASTNode retNode = pinpointOnLine ( ( ASTNode ) node . getStructuralProperty ( prop ) , offset , lineStartOffset , name ) ; if ( retNode != null ) { return retNode ; } } } } else if ( prop . isChildListProperty ( ) ) { List < ASTNode > nodelist = ( List < ASTNode > ) node . getStructuralProperty ( prop ) ; for ( ASTNode retNode : nodelist ) { ASTNode rr = pinpointOnLine ( retNode , offset , lineStartOffset , name ) ; if ( rr != null ) { return rr ; } } } } return null ; } protected static ASTNode findDeclaration ( Name findMe ) { ASTNode declaringClass = null ; ASTNode parent = findMe . getParent ( ) ; ASTNode ret = null ; ArrayList < Integer > constrains = new ArrayList < Integer > ( ) ; if ( parent . getNodeType ( ) == ASTNode . METHOD_INVOCATION ) { Expression exp = ( Expression ) ( ( MethodInvocation ) parent ) . getStructuralProperty ( MethodInvocation . EXPRESSION_PROPERTY ) ; if ( ( ( MethodInvocation ) parent ) . getName ( ) . toString ( ) . equals ( findMe . toString ( ) ) ) { constrains . add ( ASTNode . METHOD_DECLARATION ) ; if ( exp != null ) { constrains . add ( ASTNode . TYPE_DECLARATION ) ; if ( exp instanceof MethodInvocation ) { SimpleType stp = extracTypeInfo ( findDeclaration ( ( ( MethodInvocation ) exp ) . getName ( ) ) ) ; if ( stp == null ) return null ; declaringClass = findDeclaration ( stp . getName ( ) ) ; return definedIn ( declaringClass , ( ( MethodInvocation ) parent ) . getName ( ) . toString ( ) , constrains , declaringClass ) ; } else if ( exp instanceof FieldAccess ) { SimpleType stp = extracTypeInfo ( findDeclaration ( ( ( FieldAccess ) exp ) . getName ( ) ) ) ; if ( stp == null ) return null ; declaringClass = findDeclaration ( ( stp . getName ( ) ) ) ; return definedIn ( declaringClass , ( ( MethodInvocation ) parent ) . getName ( ) . toString ( ) , constrains , declaringClass ) ; } if ( exp instanceof SimpleName ) { SimpleType stp = extracTypeInfo ( findDeclaration ( ( ( SimpleName ) exp ) ) ) ; if ( stp == null ) return null ; declaringClass = findDeclaration ( stp . getName ( ) ) ; constrains . add ( ASTNode . METHOD_DECLARATION ) ; return definedIn ( declaringClass , ( ( MethodInvocation ) parent ) . getName ( ) . toString ( ) , constrains , declaringClass ) ; } } } else { parent = parent . getParent ( ) ; } } else if ( parent . getNodeType ( ) == ASTNode . FIELD_ACCESS ) { FieldAccess fa = ( FieldAccess ) parent ; Expression exp = fa . getExpression ( ) ; if ( fa . getName ( ) . toString ( ) . equals ( findMe . toString ( ) ) ) { constrains . add ( ASTNode . FIELD_DECLARATION ) ; if ( exp != null ) { constrains . add ( ASTNode . TYPE_DECLARATION ) ; if ( exp instanceof MethodInvocation ) { SimpleType stp = extracTypeInfo ( findDeclaration ( ( ( MethodInvocation ) exp ) . getName ( ) ) ) ; if ( stp == null ) return null ; declaringClass = findDeclaration ( stp . getName ( ) ) ; return definedIn ( declaringClass , fa . getName ( ) . toString ( ) , constrains , declaringClass ) ; } else if ( exp instanceof FieldAccess ) { SimpleType stp = extracTypeInfo ( findDeclaration ( ( ( FieldAccess ) exp ) . getName ( ) ) ) ; if ( stp == null ) return null ; declaringClass = findDeclaration ( ( stp . getName ( ) ) ) ; constrains . add ( ASTNode . TYPE_DECLARATION ) ; return definedIn ( declaringClass , fa . getName ( ) . toString ( ) , constrains , declaringClass ) ; } if ( exp instanceof SimpleName ) { SimpleType stp = extracTypeInfo ( findDeclaration ( ( ( SimpleName ) exp ) ) ) ; if ( stp == null ) return null ; declaringClass = findDeclaration ( stp . getName ( ) ) ; constrains . add ( ASTNode . METHOD_DECLARATION ) ; return definedIn ( declaringClass , fa . getName ( ) . toString ( ) , constrains , declaringClass ) ; } } } else { parent = parent . getParent ( ) ; } } else if ( parent . getNodeType ( ) == ASTNode . QUALIFIED_NAME ) { QualifiedName qn = ( QualifiedName ) parent ; if ( ! findMe . toString ( ) . equals ( qn . getQualifier ( ) . toString ( ) ) ) { SimpleType stp = extracTypeInfo ( findDeclaration ( ( qn . getQualifier ( ) ) ) ) ; declaringClass = findDeclaration ( stp . getName ( ) ) ; constrains . clear ( ) ; constrains . add ( ASTNode . TYPE_DECLARATION ) ; constrains . add ( ASTNode . FIELD_DECLARATION ) ; return definedIn ( declaringClass , qn . getName ( ) . toString ( ) , constrains , null ) ; } else { if ( findMe instanceof QualifiedName ) { QualifiedName qnn = ( QualifiedName ) findMe ; SimpleType stp = extracTypeInfo ( findDeclaration ( ( qnn . getQualifier ( ) ) ) ) ; declaringClass = findDeclaration ( stp . getName ( ) ) ; constrains . clear ( ) ; constrains . add ( ASTNode . TYPE_DECLARATION ) ; constrains . add ( ASTNode . FIELD_DECLARATION ) ; return definedIn ( declaringClass , qnn . getName ( ) . toString ( ) , constrains , null ) ; } } } else if ( parent . getNodeType ( ) == ASTNode . SIMPLE_TYPE ) { constrains . add ( ASTNode . TYPE_DECLARATION ) ; if ( parent . getParent ( ) . getNodeType ( ) == ASTNode . CLASS_INSTANCE_CREATION ) constrains . add ( ASTNode . CLASS_INSTANCE_CREATION ) ; } else if ( parent . getNodeType ( ) == ASTNode . TYPE_DECLARATION ) { TypeDeclaration td = ( TypeDeclaration ) parent ; if ( findMe . equals ( td . getName ( ) ) ) { return parent ; } } else if ( parent instanceof Expression ) { } while ( parent != null ) { for ( Object oprop : parent . structuralPropertiesForType ( ) ) { StructuralPropertyDescriptor prop = ( StructuralPropertyDescriptor ) oprop ; if ( prop . isChildProperty ( ) || prop . isSimpleProperty ( ) ) { if ( parent . getStructuralProperty ( prop ) instanceof ASTNode ) { ret = definedIn ( ( ASTNode ) parent . getStructuralProperty ( prop ) , findMe . toString ( ) , constrains , declaringClass ) ; if ( ret != null ) return ret ; } } else if ( prop . isChildListProperty ( ) ) { List < ASTNode > nodelist = ( List < ASTNode > ) parent . getStructuralProperty ( prop ) ; for ( ASTNode retNode : nodelist ) { ret = definedIn ( retNode , findMe . toString ( ) , constrains , declaringClass ) ; if ( ret != null ) return ret ; } } } parent = parent . getParent ( ) ; } return null ; } protected static ASTNode findDeclaration2 ( Name findMe , ASTNode alternateParent ) { ASTNode declaringClass = null ; ASTNode parent = findMe . getParent ( ) ; ASTNode ret = null ; ArrayList < Integer > constrains = new ArrayList < Integer > ( ) ; if ( parent . getNodeType ( ) == ASTNode . METHOD_INVOCATION ) { Expression exp = ( Expression ) ( ( MethodInvocation ) parent ) . getStructuralProperty ( MethodInvocation . EXPRESSION_PROPERTY ) ; if ( ( ( MethodInvocation ) parent ) . getName ( ) . toString ( ) . equals ( findMe . toString ( ) ) ) { constrains . add ( ASTNode . METHOD_DECLARATION ) ; if ( exp != null ) { constrains . add ( ASTNode . TYPE_DECLARATION ) ; if ( exp instanceof MethodInvocation ) { SimpleType stp = extracTypeInfo ( findDeclaration2 ( ( ( MethodInvocation ) exp ) . getName ( ) , alternateParent ) ) ; if ( stp == null ) return null ; declaringClass = findDeclaration2 ( stp . getName ( ) , alternateParent ) ; return definedIn ( declaringClass , ( ( MethodInvocation ) parent ) . getName ( ) . toString ( ) , constrains , declaringClass ) ; } else if ( exp instanceof FieldAccess ) { SimpleType stp = extracTypeInfo ( findDeclaration2 ( ( ( FieldAccess ) exp ) . getName ( ) , alternateParent ) ) ; if ( stp == null ) return null ; declaringClass = findDeclaration2 ( ( stp . getName ( ) ) , alternateParent ) ; return definedIn ( declaringClass , ( ( MethodInvocation ) parent ) . getName ( ) . toString ( ) , constrains , declaringClass ) ; } if ( exp instanceof SimpleName ) { SimpleType stp = extracTypeInfo ( findDeclaration2 ( ( ( SimpleName ) exp ) , alternateParent ) ) ; if ( stp == null ) return null ; declaringClass = findDeclaration2 ( stp . getName ( ) , alternateParent ) ; constrains . add ( ASTNode . METHOD_DECLARATION ) ; return definedIn ( declaringClass , ( ( MethodInvocation ) parent ) . getName ( ) . toString ( ) , constrains , declaringClass ) ; } } } else { parent = parent . getParent ( ) ; alternateParent = alternateParent . getParent ( ) ; } } else if ( parent . getNodeType ( ) == ASTNode . FIELD_ACCESS ) { FieldAccess fa = ( FieldAccess ) parent ; Expression exp = fa . getExpression ( ) ; if ( fa . getName ( ) . toString ( ) . equals ( findMe . toString ( ) ) ) { constrains . add ( ASTNode . FIELD_DECLARATION ) ; if ( exp != null ) { constrains . add ( ASTNode . TYPE_DECLARATION ) ; if ( exp instanceof MethodInvocation ) { SimpleType stp = extracTypeInfo ( findDeclaration2 ( ( ( MethodInvocation ) exp ) . getName ( ) , alternateParent ) ) ; if ( stp == null ) return null ; declaringClass = findDeclaration2 ( stp . getName ( ) , alternateParent ) ; return definedIn ( declaringClass , fa . getName ( ) . toString ( ) , constrains , declaringClass ) ; } else if ( exp instanceof FieldAccess ) { SimpleType stp = extracTypeInfo ( findDeclaration2 ( ( ( FieldAccess ) exp ) . getName ( ) , alternateParent ) ) ; if ( stp == null ) return null ; declaringClass = findDeclaration2 ( ( stp . getName ( ) ) , alternateParent ) ; constrains . add ( ASTNode . TYPE_DECLARATION ) ; return definedIn ( declaringClass , fa . getName ( ) . toString ( ) , constrains , declaringClass ) ; } if ( exp instanceof SimpleName ) { SimpleType stp = extracTypeInfo ( findDeclaration2 ( ( ( SimpleName ) exp ) , alternateParent ) ) ; if ( stp == null ) return null ; declaringClass = findDeclaration2 ( stp . getName ( ) , alternateParent ) ; constrains . add ( ASTNode . METHOD_DECLARATION ) ; return definedIn ( declaringClass , fa . getName ( ) . toString ( ) , constrains , declaringClass ) ; } } } else { parent = parent . getParent ( ) ; alternateParent = alternateParent . getParent ( ) ; } } else if ( parent . getNodeType ( ) == ASTNode . QUALIFIED_NAME ) { QualifiedName qn = ( QualifiedName ) parent ; if ( ! findMe . toString ( ) . equals ( qn . getQualifier ( ) . toString ( ) ) ) { SimpleType stp = extracTypeInfo ( findDeclaration2 ( ( qn . getQualifier ( ) ) , alternateParent ) ) ; if ( stp == null ) return null ; declaringClass = findDeclaration2 ( stp . getName ( ) , alternateParent ) ; constrains . clear ( ) ; constrains . add ( ASTNode . TYPE_DECLARATION ) ; constrains . add ( ASTNode . FIELD_DECLARATION ) ; return definedIn ( declaringClass , qn . getName ( ) . toString ( ) , constrains , null ) ; } else { if ( findMe instanceof QualifiedName ) { QualifiedName qnn = ( QualifiedName ) findMe ; SimpleType stp = extracTypeInfo ( findDeclaration2 ( ( qnn . getQualifier ( ) ) , alternateParent ) ) ; declaringClass = findDeclaration2 ( stp . getName ( ) , alternateParent ) ; constrains . clear ( ) ; constrains . add ( ASTNode . TYPE_DECLARATION ) ; constrains . add ( ASTNode . FIELD_DECLARATION ) ; return definedIn ( declaringClass , qnn . getName ( ) . toString ( ) , constrains , null ) ; } } } else if ( parent . getNodeType ( ) == ASTNode . SIMPLE_TYPE ) { constrains . add ( ASTNode . TYPE_DECLARATION ) ; if ( parent . getParent ( ) . getNodeType ( ) == ASTNode . CLASS_INSTANCE_CREATION ) constrains . add ( ASTNode . CLASS_INSTANCE_CREATION ) ; } else if ( parent instanceof Expression ) { } while ( alternateParent != null ) { for ( Object oprop : alternateParent . structuralPropertiesForType ( ) ) { StructuralPropertyDescriptor prop = ( StructuralPropertyDescriptor ) oprop ; if ( prop . isChildProperty ( ) || prop . isSimpleProperty ( ) ) { if ( alternateParent . getStructuralProperty ( prop ) instanceof ASTNode ) { ret = definedIn ( ( ASTNode ) alternateParent . getStructuralProperty ( prop ) , findMe . toString ( ) , constrains , declaringClass ) ; if ( ret != null ) return ret ; } } else if ( prop . isChildListProperty ( ) ) { List < ASTNode > nodelist = ( List < ASTNode > ) alternateParent . getStructuralProperty ( prop ) ; for ( ASTNode retNode : nodelist ) { ret = definedIn ( retNode , findMe . toString ( ) , constrains , declaringClass ) ; if ( ret != null ) return ret ; } } } alternateParent = alternateParent . getParent ( ) ; } return null ; } protected List < Comment > getCodeComments ( ) { List < Comment > commentList = compilationUnit . getCommentList ( ) ; return commentList ; } protected boolean caretWithinLineComment ( ) { final JEditTextArea ta = editor . getTextArea ( ) ; String pdeLine = editor . getLineText ( ta . getCaretLine ( ) ) . trim ( ) ; int caretPos = ta . getCaretPosition ( ) - ta . getLineStartNonWhiteSpaceOffset ( ta . getCaretLine ( ) ) ; int x = pdeLine . indexOf ( "//" ) ; if ( x >= 0 && caretPos > x ) { return true ; } return false ; } public class ClassMember { private Field field ; private Method method ; private Constructor < ? > cons ; private Class < ? > thisclass ; private String stringVal ; private String classType ; private ASTNode astNode ; private ASTNode declaringNode ; public ClassMember ( Class < ? > m ) { thisclass = m ; stringVal = "Predefined Class " + m . getName ( ) ; classType = m . getName ( ) ; } public ClassMember ( Method m ) { method = m ; stringVal = "Method " + m . getReturnType ( ) . getName ( ) + " | " + m . getName ( ) + " defined in " + m . getDeclaringClass ( ) . getName ( ) ; classType = m . getReturnType ( ) . getName ( ) ; } public ClassMember ( Field m ) { field = m ; stringVal = "Field " + m . getType ( ) . getName ( ) + " | " + m . getName ( ) + " defined in " + m . getDeclaringClass ( ) . getName ( ) ; classType = m . getType ( ) . getName ( ) ; } public ClassMember ( Constructor < ? > m ) { cons = m ; stringVal = "Cons " + " " + m . getName ( ) + " defined in " + m . getDeclaringClass ( ) . getName ( ) ; } public ClassMember ( ASTNode node ) { astNode = node ; stringVal = getNodeAsString ( node ) ; if ( node instanceof TypeDeclaration ) { declaringNode = node ; } if ( node instanceof SimpleType ) { classType = ( ( SimpleType ) node ) . getName ( ) . toString ( ) ; } SimpleType stp = ( node instanceof SimpleType ) ? ( SimpleType ) node : extracTypeInfo ( node ) ; if ( stp != null ) { ASTNode decl = findDeclaration ( stp . getName ( ) ) ; if ( decl == null ) { classType = stp . getName ( ) . toString ( ) ; Class < ? > probableClass = findClassIfExists ( classType ) ; thisclass = probableClass ; } else { declaringNode = decl ; } } } public Class < ? > getClass_ ( ) { return thisclass ; } public ASTNode getDeclaringNode ( ) { return declaringNode ; } public Field getField ( ) { return field ; } public Method getMethod ( ) { return method ; } public Constructor < ? > getCons ( ) { return cons ; } public ASTNode getASTNode ( ) { return astNode ; } public String toString ( ) { return stringVal ; } public String getTypeAsString ( ) { return classType ; } } public static SimpleType extracTypeInfo ( ASTNode node ) { if ( node == null ) { return null ; } Type t = extracTypeInfo2 ( node ) ; if ( t instanceof PrimitiveType ) { return null ; } else if ( t instanceof ArrayType ) { ArrayType at = ( ArrayType ) t ; log ( at . getComponentType ( ) + " <-comp type, ele type-> " + at . getElementType ( ) + ", " + at . getElementType ( ) . getClass ( ) . getName ( ) ) ; if ( at . getElementType ( ) instanceof PrimitiveType ) { return null ; } else if ( at . getElementType ( ) instanceof SimpleType ) { return ( SimpleType ) at . getElementType ( ) ; } else return null ; } else if ( t instanceof ParameterizedType ) { ParameterizedType pmt = ( ParameterizedType ) t ; log ( pmt . getType ( ) + ", " + pmt . getType ( ) . getClass ( ) ) ; if ( pmt . getType ( ) instanceof SimpleType ) { return ( SimpleType ) pmt . getType ( ) ; } else return null ; } return ( SimpleType ) t ; } static public Type extracTypeInfo2 ( ASTNode node ) { if ( node == null ) return null ; switch ( node . getNodeType ( ) ) { case ASTNode . METHOD_DECLARATION : return ( ( MethodDeclaration ) node ) . getReturnType2 ( ) ; case ASTNode . FIELD_DECLARATION : return ( ( FieldDeclaration ) node ) . getType ( ) ; case ASTNode . VARIABLE_DECLARATION_EXPRESSION : return ( ( VariableDeclarationExpression ) node ) . getType ( ) ; case ASTNode . VARIABLE_DECLARATION_STATEMENT : return ( ( VariableDeclarationStatement ) node ) . getType ( ) ; case ASTNode . SINGLE_VARIABLE_DECLARATION : return ( ( SingleVariableDeclaration ) node ) . getType ( ) ; case ASTNode . VARIABLE_DECLARATION_FRAGMENT : return extracTypeInfo2 ( node . getParent ( ) ) ; } log ( "Unknown type info request " + getNodeAsString ( node ) ) ; return null ; } static protected ASTNode definedIn ( ASTNode node , String name , ArrayList < Integer > constrains , ASTNode declaringClass ) { if ( node == null ) return null ; if ( constrains != null ) { if ( ! constrains . contains ( node . getNodeType ( ) ) && constrains . size ( ) > 0 ) { return null ; } } List < VariableDeclarationFragment > vdfList = null ; switch ( node . getNodeType ( ) ) { case ASTNode . TYPE_DECLARATION : TypeDeclaration td = ( TypeDeclaration ) node ; if ( td . getName ( ) . toString ( ) . equals ( name ) ) { if ( constrains . contains ( ASTNode . CLASS_INSTANCE_CREATION ) ) { MethodDeclaration [ ] methods = td . getMethods ( ) ; for ( MethodDeclaration md : methods ) { if ( md . getName ( ) . toString ( ) . equalsIgnoreCase ( name ) ) { log ( "Found a constructor." ) ; return md ; } } } else { return node ; } } else { if ( constrains . contains ( ASTNode . FIELD_DECLARATION ) ) { FieldDeclaration [ ] fields = td . getFields ( ) ; for ( FieldDeclaration fd : fields ) { List < VariableDeclarationFragment > fragments = fd . fragments ( ) ; for ( VariableDeclarationFragment vdf : fragments ) { if ( vdf . getName ( ) . toString ( ) . equalsIgnoreCase ( name ) ) return fd ; } } } else if ( constrains . contains ( ASTNode . METHOD_DECLARATION ) ) { MethodDeclaration [ ] methods = td . getMethods ( ) ; for ( MethodDeclaration md : methods ) { if ( md . getName ( ) . toString ( ) . equalsIgnoreCase ( name ) ) { return md ; } } } } break ; case ASTNode . METHOD_DECLARATION : if ( ( ( MethodDeclaration ) node ) . getName ( ) . toString ( ) . equalsIgnoreCase ( name ) ) return node ; break ; case ASTNode . SINGLE_VARIABLE_DECLARATION : if ( ( ( SingleVariableDeclaration ) node ) . getName ( ) . toString ( ) . equalsIgnoreCase ( name ) ) return node ; break ; case ASTNode . FIELD_DECLARATION : vdfList = ( ( FieldDeclaration ) node ) . fragments ( ) ; break ; case ASTNode . VARIABLE_DECLARATION_EXPRESSION : vdfList = ( ( VariableDeclarationExpression ) node ) . fragments ( ) ; break ; case ASTNode . VARIABLE_DECLARATION_STATEMENT : vdfList = ( ( VariableDeclarationStatement ) node ) . fragments ( ) ; break ; default : } if ( vdfList != null ) { for ( VariableDeclarationFragment vdf : vdfList ) { if ( vdf . getName ( ) . toString ( ) . equalsIgnoreCase ( name ) ) return node ; } } return null ; } public String [ ] getSuggestImports ( final String className ) { if ( ignoredImportSuggestions == null ) { ignoredImportSuggestions = new TreeSet < String > ( ) ; } else { if ( ignoredImportSuggestions . contains ( className ) ) { log ( "Ignoring import suggestions for " + className ) ; return null ; } } log ( "Looking for class " + className ) ; RegExpResourceFilter regf = new RegExpResourceFilter ( Pattern . compile ( ".*" ) , Pattern . compile ( className + ".class" , Pattern . CASE_INSENSITIVE ) ) ; String [ ] resources = classPath . findResources ( "" , regf ) ; ArrayList < String > candidates = new ArrayList < String > ( ) ; for ( String res : resources ) { candidates . add ( res ) ; } for ( Library lib : editor . getMode ( ) . contribLibraries ) { ClassPath cp = factory . createFromPath ( lib . getClassPath ( ) ) ; resources = cp . findResources ( "" , regf ) ; for ( String res : resources ) { candidates . add ( res ) ; log ( "Res: " + res ) ; } } if ( editor . getSketch ( ) . hasCodeFolder ( ) ) { File codeFolder = editor . getSketch ( ) . getCodeFolder ( ) ; ClassPath cp = factory . createFromPath ( Base . contentsToClassPath ( codeFolder ) ) ; resources = cp . findResources ( "" , regf ) ; for ( String res : resources ) { candidates . add ( res ) ; log ( "Res: " + res ) ; } } resources = new String [ candidates . size ( ) ] ; for ( int i = 0 ; i < resources . length ; i ++ ) { resources [ i ] = candidates . get ( i ) . replace ( '/' , '.' ) . substring ( 0 , candidates . get ( i ) . length ( ) - 6 ) ; } return resources ; } protected JFrame frmImportSuggest ; private TreeSet < String > ignoredImportSuggestions ; public void suggestImports ( final String className ) { if ( ignoredImportSuggestions == null ) { ignoredImportSuggestions = new TreeSet < String > ( ) ; } else { if ( ignoredImportSuggestions . contains ( className ) ) { log ( "Ignoring import suggestions for " + className ) ; return ; } } if ( frmImportSuggest != null ) if ( frmImportSuggest . isVisible ( ) ) return ; log ( "Looking for class " + className ) ; RegExpResourceFilter regf = new RegExpResourceFilter ( Pattern . compile ( ".*" ) , Pattern . compile ( className + ".class" , Pattern . CASE_INSENSITIVE ) ) ; String [ ] resources = classPath . findResources ( "" , regf ) ; ArrayList < String > candidates = new ArrayList < String > ( ) ; for ( String res : resources ) { candidates . add ( res ) ; } for ( Library lib : editor . getMode ( ) . contribLibraries ) { ClassPath cp = factory . createFromPath ( lib . getClassPath ( ) ) ; resources = cp . findResources ( "" , regf ) ; for ( String res : resources ) { candidates . add ( res ) ; log ( "Res: " + res ) ; } } if ( editor . getSketch ( ) . hasCodeFolder ( ) ) { File codeFolder = editor . getSketch ( ) . getCodeFolder ( ) ; ClassPath cp = factory . createFromPath ( Base . contentsToClassPath ( codeFolder ) ) ; resources = cp . findResources ( "" , regf ) ; for ( String res : resources ) { candidates . add ( res ) ; log ( "Res: " + res ) ; } } resources = new String [ candidates . size ( ) ] ; for ( int i = 0 ; i < resources . length ; i ++ ) { resources [ i ] = candidates . get ( i ) . replace ( '/' , '.' ) . substring ( 0 , candidates . get ( i ) . length ( ) - 6 ) ; } if ( resources . length >= 1 ) { final JList < String > classList = new JList < String > ( resources ) ; classList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; frmImportSuggest = new JFrame ( ) ; frmImportSuggest . setSize ( 350 , 200 ) ; Toolkit . setIcon ( frmImportSuggest ) ; frmImportSuggest . setLayout ( new BoxLayout ( frmImportSuggest . getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; ( ( JComponent ) frmImportSuggest . getContentPane ( ) ) . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; JLabel lbl = new JLabel ( "<html>The class \"" + className + "\" couldn't be determined. You are probably missing one of the following imports:</html>" ) ; JScrollPane jsp = new JScrollPane ( ) ; jsp . setViewportView ( classList ) ; JButton btnInsertImport = new JButton ( "Insert import" ) ; btnInsertImport . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { if ( classList . getSelectedValue ( ) != null ) { try { String impString = "import " + classList . getSelectedValue ( ) + ";\n" ; int ct = editor . getSketch ( ) . getCurrentCodeIndex ( ) ; editor . getSketch ( ) . setCurrentCode ( 0 ) ; editor . getTextArea ( ) . getDocument ( ) . insertString ( 0 , impString , null ) ; editor . getSketch ( ) . setCurrentCode ( ct ) ; errorCheckerService . runManualErrorCheck ( ) ; frmImportSuggest . setVisible ( false ) ; frmImportSuggest = null ; } catch ( BadLocationException e ) { log ( "Failed to insert import for " + className ) ; e . printStackTrace ( ) ; } } } } ) ; JButton btnCancel = new JButton ( "Cancel" ) ; btnCancel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { frmImportSuggest . setVisible ( false ) ; } } ) ; JPanel panelTop = new JPanel ( ) , panelBottom = new JPanel ( ) , panelLabel = new JPanel ( ) ; panelTop . setLayout ( new BoxLayout ( panelTop , BoxLayout . Y_AXIS ) ) ; panelTop . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; panelLabel . setLayout ( new BorderLayout ( ) ) ; panelLabel . add ( lbl , BorderLayout . CENTER ) ; panelTop . add ( panelLabel ) ; panelTop . add ( Box . createRigidArea ( new Dimension ( 1 , 5 ) ) ) ; panelTop . add ( jsp ) ; panelBottom . setLayout ( new BoxLayout ( panelBottom , BoxLayout . X_AXIS ) ) ; panelBottom . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; panelBottom . setLayout ( new BoxLayout ( panelBottom , BoxLayout . X_AXIS ) ) ; panelBottom . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; panelBottom . add ( Box . createHorizontalGlue ( ) ) ; panelBottom . add ( btnInsertImport ) ; panelBottom . add ( Box . createRigidArea ( new Dimension ( 15 , 0 ) ) ) ; panelBottom . add ( btnCancel ) ; JButton btnIgnore = new JButton ( "Ignore \"" + className + "\"" ) ; btnIgnore . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { ignoredImportSuggestions . add ( className ) ; frmImportSuggest . setVisible ( false ) ; } } ) ; panelBottom . add ( Box . createRigidArea ( new Dimension ( 15 , 0 ) ) ) ; panelBottom . add ( btnIgnore ) ; frmImportSuggest . add ( panelTop ) ; frmImportSuggest . add ( panelBottom ) ; frmImportSuggest . setDefaultCloseOperation ( JFrame . HIDE_ON_CLOSE ) ; frmImportSuggest . setTitle ( "Import Suggestion" ) ; frmImportSuggest . setLocation ( editor . getX ( ) + ( editor . getWidth ( ) - frmImportSuggest . getWidth ( ) ) / 2 , editor . getY ( ) + ( editor . getHeight ( ) - frmImportSuggest . getHeight ( ) ) / 2 ) ; hideSuggestion ( ) ; classList . setSelectedIndex ( 0 ) ; frmImportSuggest . setVisible ( true ) ; } } public void disposeAllWindows ( ) { disposeWindow ( frmASTView , frameAutoComp , frmImportSuggest , frmOccurenceList , frmRename ) ; } public static void disposeWindow ( JFrame ... f ) { for ( JFrame jFrame : f ) { if ( jFrame != null ) jFrame . dispose ( ) ; } } public static final String ignoredImports [ ] = { "com.oracle." , "sun." , "sunw." , "com.sun." , "javax." , "sunw." , "org.ietf." , "org.jcp." , "org.omg." , "org.w3c." , "org.xml." , "org.eclipse." , "com.ibm." , "org.netbeans." , "org.jsoup." , "org.junit." , "org.apache." , "antlr." } ; public static final String allowedImports [ ] = { "java.lang." , "java.util." , "java.io." , "java.math." , "processing.core." , "processing.data." , "processing.event." , "processing.opengl." } ; protected boolean ignorableImport ( String impName , String className ) { for ( ImportStatement impS : errorCheckerService . getProgramImports ( ) ) { if ( impName . startsWith ( impS . getPackageName ( ) ) ) return false ; } for ( String impS : allowedImports ) { if ( impName . startsWith ( impS ) && className . indexOf ( '.' ) == - 1 ) return false ; } return true ; } public static boolean isAddableASTNode ( ASTNode node ) { switch ( node . getNodeType ( ) ) { default : return true ; } } public int getASTNodeLineStartOffset ( ASTNode node ) { int nodeLineNo = getLineNumber ( node ) ; while ( node . getParent ( ) != null ) { if ( getLineNumber ( node . getParent ( ) ) == nodeLineNo ) { node = node . getParent ( ) ; } else { break ; } } return node . getStartPosition ( ) ; } public int [ ] getASTNodeAllOffsets ( ASTNode node ) { int nodeLineNo = getLineNumber ( node ) , nodeOffset = node . getStartPosition ( ) , nodeLength = node . getLength ( ) ; while ( node . getParent ( ) != null ) { if ( getLineNumber ( node . getParent ( ) ) == nodeLineNo ) { node = node . getParent ( ) ; } else { break ; } } return new int [ ] { nodeLineNo , node . getStartPosition ( ) , nodeOffset , nodeLength } ; } static protected String getNodeAsString ( ASTNode node ) { if ( node == null ) return "NULL" ; String className = node . getClass ( ) . getName ( ) ; int index = className . lastIndexOf ( "." ) ; if ( index > 0 ) className = className . substring ( index + 1 ) ; String value = className ; if ( node instanceof TypeDeclaration ) value = ( ( TypeDeclaration ) node ) . getName ( ) . toString ( ) + " | " + className ; else if ( node instanceof MethodDeclaration ) value = ( ( MethodDeclaration ) node ) . getName ( ) . toString ( ) + " | " + className ; else if ( node instanceof MethodInvocation ) value = ( ( MethodInvocation ) node ) . getName ( ) . toString ( ) + " | " + className ; else if ( node instanceof FieldDeclaration ) value = ( ( FieldDeclaration ) node ) . toString ( ) + " FldDecl| " ; else if ( node instanceof SingleVariableDeclaration ) value = ( ( SingleVariableDeclaration ) node ) . getName ( ) + " - " + ( ( SingleVariableDeclaration ) node ) . getType ( ) + " | SVD " ; else if ( node instanceof ExpressionStatement ) value = node . toString ( ) + className ; else if ( node instanceof SimpleName ) value = ( ( SimpleName ) node ) . getFullyQualifiedName ( ) + " | " + className ; else if ( node instanceof QualifiedName ) value = node . toString ( ) + " | " + className ; else if ( node instanceof FieldAccess ) value = node . toString ( ) + " | " ; else if ( className . startsWith ( "Variable" ) ) value = node . toString ( ) + " | " + className ; else if ( className . endsWith ( "Type" ) ) value = node . toString ( ) + " |" + className ; value += " [" + node . getStartPosition ( ) + "," + ( node . getStartPosition ( ) + node . getLength ( ) ) + "]" ; value += " Line: " + ( ( CompilationUnit ) node . getRoot ( ) ) . getLineNumber ( node . getStartPosition ( ) ) ; return value ; } static protected String getNodeAsString2 ( ASTNode node ) { if ( node == null ) return "NULL" ; String className = node . getClass ( ) . getName ( ) ; int index = className . lastIndexOf ( "." ) ; if ( index > 0 ) className = className . substring ( index + 1 ) ; String value = className ; if ( node instanceof TypeDeclaration ) value = ( ( TypeDeclaration ) node ) . getName ( ) . toString ( ) ; else if ( node instanceof MethodDeclaration ) value = ( ( MethodDeclaration ) node ) . getName ( ) . toString ( ) ; else if ( node instanceof MethodInvocation ) value = ( ( MethodInvocation ) node ) . getName ( ) . toString ( ) + " | " + className ; else if ( node instanceof FieldDeclaration ) value = ( ( FieldDeclaration ) node ) . toString ( ) ; else if ( node instanceof SingleVariableDeclaration ) value = ( ( SingleVariableDeclaration ) node ) . getName ( ) . toString ( ) ; else if ( node instanceof ExpressionStatement ) value = node . toString ( ) + className ; else if ( node instanceof SimpleName ) value = ( ( SimpleName ) node ) . getFullyQualifiedName ( ) + " | " + className ; else if ( node instanceof QualifiedName ) value = node . toString ( ) ; else if ( node instanceof VariableDeclarationFragment ) value = ( ( VariableDeclarationFragment ) node ) . getName ( ) . toString ( ) ; else if ( className . startsWith ( "Variable" ) ) value = node . toString ( ) ; else if ( node instanceof VariableDeclarationStatement ) value = ( ( VariableDeclarationStatement ) node ) . toString ( ) ; else if ( className . endsWith ( "Type" ) ) value = node . toString ( ) ; return value ; } static private void log ( Object object ) { Base . log ( object == null ? "null" : object . toString ( ) ) ; } private String getSelectedText ( ) { return editor . getTextArea ( ) . getSelectedText ( ) ; } private void hideSuggestion ( ) { ( ( JavaTextArea ) editor . getTextArea ( ) ) . hideSuggestion ( ) ; } }
package processing . mode . java . pdex ; import java . util . ArrayList ; public class OffsetMatcher { public ArrayList < OffsetMatcher . OffsetPair > offsetMatch ; String pdeCodeLine , javaCodeLine ; boolean matchingNeeded = false ; public OffsetMatcher ( String pdeCode , String javaCode ) { this . pdeCodeLine = pdeCode ; this . javaCodeLine = javaCode ; if ( pdeCodeLine . trim ( ) . equals ( javaCodeLine . trim ( ) ) ) { matchingNeeded = false ; offsetMatch = new ArrayList < OffsetMatcher . OffsetPair > ( ) ; } else { matchingNeeded = true ; minDistance ( ) ; } } public int getPdeOffForJavaOff ( int start , int length ) { if ( ! matchingNeeded ) return start ; int ans = getPdeOffForJavaOff ( start ) ; int end = getPdeOffForJavaOff ( start + length - 1 ) ; if ( ans == - 1 || end == - 1 ) { } else { } return ans ; } public int getJavaOffForPdeOff ( int start , int length ) { if ( ! matchingNeeded ) return start ; int ans = getJavaOffForPdeOff ( start ) ; return ans ; } public int getPdeOffForJavaOff ( int javaOff ) { if ( ! matchingNeeded ) return javaOff ; for ( int i = offsetMatch . size ( ) - 1 ; i >= 0 ; i -- ) { if ( offsetMatch . get ( i ) . javaOffset < javaOff ) { continue ; } else if ( offsetMatch . get ( i ) . javaOffset == javaOff ) { while ( i > 0 && offsetMatch . get ( -- i ) . javaOffset == javaOff ) { } if ( i + 1 < offsetMatch . size ( ) ) { int pdeOff = offsetMatch . get ( ++ i ) . pdeOffset ; while ( i > 0 && offsetMatch . get ( -- i ) . pdeOffset == pdeOff ) { } } int j = i + 1 ; if ( j > - 1 && j < offsetMatch . size ( ) ) return offsetMatch . get ( j ) . pdeOffset ; } } return - 1 ; } public int getJavaOffForPdeOff ( int pdeOff ) { if ( ! matchingNeeded ) return pdeOff ; for ( int i = offsetMatch . size ( ) - 1 ; i >= 0 ; i -- ) { if ( offsetMatch . get ( i ) . pdeOffset < pdeOff ) { continue ; } else if ( offsetMatch . get ( i ) . pdeOffset == pdeOff ) { while ( i > 0 && offsetMatch . get ( -- i ) . pdeOffset == pdeOff ) { } if ( i + 1 < offsetMatch . size ( ) ) { int javaOff = offsetMatch . get ( ++ i ) . javaOffset ; while ( i > 0 && offsetMatch . get ( -- i ) . javaOffset == javaOff ) { } } int j = i + 1 ; if ( j > - 1 && j < offsetMatch . size ( ) ) return offsetMatch . get ( j ) . javaOffset ; } } return - 1 ; } private int minDistance ( ) { int len1 = pdeCodeLine . length ( ) ; int len2 = javaCodeLine . length ( ) ; int [ ] [ ] dp = new int [ len1 + 1 ] [ len2 + 1 ] ; for ( int i = 0 ; i <= len1 ; i ++ ) { dp [ i ] [ 0 ] = i ; } for ( int j = 0 ; j <= len2 ; j ++ ) { dp [ 0 ] [ j ] = j ; } for ( int i = 0 ; i < len1 ; i ++ ) { char c1 = pdeCodeLine . charAt ( i ) ; for ( int j = 0 ; j < len2 ; j ++ ) { char c2 = javaCodeLine . charAt ( j ) ; if ( c1 == c2 ) { dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] ; } else { int replace = dp [ i ] [ j ] + 1 ; int insert = dp [ i ] [ j + 1 ] + 1 ; int delete = dp [ i + 1 ] [ j ] + 1 ; int min = replace > insert ? insert : replace ; min = delete > min ? min : delete ; dp [ i + 1 ] [ j + 1 ] = min ; } } } ArrayList < OffsetPair > alist = new ArrayList < OffsetMatcher . OffsetPair > ( ) ; offsetMatch = alist ; minDistInGrid ( dp , len1 , len2 , 0 , 0 , pdeCodeLine . toCharArray ( ) , javaCodeLine . toCharArray ( ) , alist ) ; return dp [ len1 ] [ len2 ] ; } private void minDistInGrid ( int g [ ] [ ] , int i , int j , int fi , int fj , char s1 [ ] , char s2 [ ] , ArrayList < OffsetPair > set ) { if ( i < s1 . length && j < s2 . length ) { set . add ( new OffsetPair ( i , j ) ) ; } if ( i == fi && j == fj ) { } else { int a = Integer . MAX_VALUE , b = a , c = a ; if ( i > 0 ) a = g [ i - 1 ] [ j ] ; if ( j > 0 ) b = g [ i ] [ j - 1 ] ; if ( i > 0 && j > 0 ) c = g [ i - 1 ] [ j - 1 ] ; int mini = Math . min ( a , Math . min ( b , c ) ) ; if ( mini == a ) { minDistInGrid ( g , i - 1 , j , fi , fj , s1 , s2 , set ) ; } else if ( mini == b ) { minDistInGrid ( g , i , j - 1 , fi , fj , s1 , s2 , set ) ; } else if ( mini == c ) { minDistInGrid ( g , i - 1 , j - 1 , fi , fj , s1 , s2 , set ) ; } } } private class OffsetPair { public final int pdeOffset , javaOffset ; public OffsetPair ( int pde , int java ) { pdeOffset = pde ; javaOffset = java ; } } }
package processing . mode . java . pdex ; import processing . mode . java . JavaMode ; import processing . mode . java . JavaEditor ; import processing . mode . java . tweak . * ; import java . awt . Color ; import java . awt . Cursor ; import java . awt . Font ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . Point ; import java . awt . RenderingHints ; import java . awt . Toolkit ; import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; import java . awt . event . MouseListener ; import java . awt . event . MouseMotionAdapter ; import java . awt . event . MouseMotionListener ; import java . awt . event . WindowAdapter ; import java . awt . event . WindowEvent ; import java . awt . image . BufferedImage ; import java . util . ArrayList ; import java . util . List ; import javax . swing . text . BadLocationException ; import javax . swing . text . Segment ; import javax . swing . text . Utilities ; import processing . app . Base ; import processing . app . Editor ; import processing . app . SketchCode ; import processing . app . syntax . SyntaxDocument ; import processing . app . syntax . TextAreaDefaults ; import processing . app . syntax . TextAreaPainter ; import processing . app . syntax . TokenMarker ; public class JavaTextAreaPainter extends TextAreaPainter implements MouseListener , MouseMotionListener { public Color errorColor ; public Color warningColor ; public Color errorMarkerColor ; public Color warningMarkerColor ; protected Font gutterTextFont ; protected Color gutterTextColor ; protected Color gutterLineHighlightColor ; public static class ErrorLineCoord { public int xStart ; public int xEnd ; public int yStart ; public int yEnd ; public Problem problem ; public ErrorLineCoord ( int xStart , int xEnd , int yStart , int yEnd , Problem problem ) { this . xStart = xStart ; this . xEnd = xEnd ; this . yStart = yStart ; this . yEnd = yEnd ; this . problem = problem ; } } public List < ErrorLineCoord > errorLineCoords = new ArrayList < > ( ) ; public JavaTextAreaPainter ( JavaTextArea textArea , TextAreaDefaults defaults ) { super ( textArea , defaults ) ; addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent evt ) { if ( ! getEditor ( ) . hasJavaTabs ( ) ) { if ( evt . getButton ( ) == MouseEvent . BUTTON1 ) { if ( ( evt . isControlDown ( ) && ! Base . isMacOS ( ) ) || evt . isMetaDown ( ) ) { handleCtrlClick ( evt ) ; } } } } } ) ; addMouseListener ( new MouseAdapter ( ) { long lastTime ; public void mousePressed ( MouseEvent event ) { long thisTime = event . getWhen ( ) ; if ( thisTime - lastTime > 100 ) { if ( event . getX ( ) < Editor . LEFT_GUTTER ) { int offset = getTextArea ( ) . xyToOffset ( event . getX ( ) , event . getY ( ) ) ; if ( offset >= 0 ) { int lineIndex = getTextArea ( ) . getLineOfOffset ( offset ) ; getEditor ( ) . toggleBreakpoint ( lineIndex ) ; } } lastTime = thisTime ; } } } ) ; addMouseMotionListener ( new MouseMotionAdapter ( ) { @ Override public void mouseMoved ( final MouseEvent evt ) { for ( ErrorLineCoord coord : errorLineCoords ) { if ( evt . getX ( ) >= coord . xStart && evt . getX ( ) <= coord . xEnd && evt . getY ( ) >= coord . yStart && evt . getY ( ) <= coord . yEnd + 2 ) { setToolTipText ( coord . problem . getMessage ( ) ) ; break ; } } } } ) ; interactiveMode = false ; cursorType = Cursor . DEFAULT_CURSOR ; } void handleCtrlClick ( MouseEvent evt ) { Base . log ( "--handleCtrlClick--" ) ; int off = textArea . xyToOffset ( evt . getX ( ) , evt . getY ( ) ) ; if ( off < 0 ) return ; int line = textArea . getLineOfOffset ( off ) ; if ( line < 0 ) return ; String s = textArea . getLineText ( line ) ; if ( s == null ) return ; else if ( s . length ( ) == 0 ) return ; else { int x = textArea . xToOffset ( line , evt . getX ( ) ) , x2 = x + 1 , x1 = x - 1 ; Base . log ( "x=" + x ) ; int xLS = off - textArea . getLineStartNonWhiteSpaceOffset ( line ) ; if ( x < 0 || x >= s . length ( ) ) return ; String word = s . charAt ( x ) + "" ; if ( s . charAt ( x ) == ' ' ) return ; if ( ! ( Character . isLetterOrDigit ( s . charAt ( x ) ) || s . charAt ( x ) == '_' || s . charAt ( x ) == '$' ) ) return ; int i = 0 ; while ( true ) { i ++ ; if ( x1 >= 0 && x1 < s . length ( ) ) { if ( Character . isLetter ( s . charAt ( x1 ) ) || s . charAt ( x1 ) == '_' ) { word = s . charAt ( x1 -- ) + word ; xLS -- ; } else x1 = - 1 ; } else x1 = - 1 ; if ( x2 >= 0 && x2 < s . length ( ) ) { if ( Character . isLetterOrDigit ( s . charAt ( x2 ) ) || s . charAt ( x2 ) == '_' || s . charAt ( x2 ) == '$' ) word = word + s . charAt ( x2 ++ ) ; else x2 = - 1 ; } else x2 = - 1 ; if ( x1 < 0 && x2 < 0 ) break ; if ( i > 200 ) { break ; } } if ( Character . isDigit ( word . charAt ( 0 ) ) ) return ; Base . log ( getEditor ( ) . getErrorChecker ( ) . mainClassOffset + line + "|" + line + "| offset " + xLS + word + " <= \n" ) ; getEditor ( ) . getErrorChecker ( ) . getASTGenerator ( ) . scrollToDeclaration ( line , word , xLS ) ; } } @ Override protected void paintLine ( Graphics gfx , int line , int x , TokenMarker tokenMarker ) { try { super . paintLine ( gfx , line , x + Editor . LEFT_GUTTER , tokenMarker ) ; } catch ( Exception e ) { Base . log ( e . getMessage ( ) ) ; } paintLeftGutter ( gfx , line , x ) ; paintErrorLine ( gfx , line , x ) ; } protected void paintLeftGutter ( Graphics gfx , int line , int x ) { int y = textArea . lineToY ( line ) + fm . getLeading ( ) + fm . getMaxDescent ( ) ; if ( line == textArea . getSelectionStopLine ( ) ) { gfx . setColor ( gutterLineHighlightColor ) ; } else { gfx . setColor ( getTextArea ( ) . gutterBgColor ) ; } gfx . fillRect ( 0 , y , Editor . LEFT_GUTTER , fm . getHeight ( ) ) ; String text = getTextArea ( ) . getGutterText ( line ) ; if ( text == null ) { text = String . valueOf ( line + 1 ) ; } char [ ] txt = text . toCharArray ( ) ; gfx . setFont ( gutterTextFont ) ; int tx = Editor . LEFT_GUTTER - Editor . GUTTER_MARGIN - gfx . getFontMetrics ( ) . charsWidth ( txt , 0 , txt . length ) ; gfx . setColor ( gutterTextColor ) ; int ty = textArea . lineToY ( line ) + fm . getHeight ( ) ; Utilities . drawTabbedText ( new Segment ( txt , 0 , text . length ( ) ) , tx , ty , gfx , this , 0 ) ; } String makeOSF ( String what ) { char [ ] c = what . toCharArray ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { c [ i ] += ( char ) ( c [ i ] - '0' + 0x362 ) ; } return new String ( c ) ; } protected void paintLineBgColor ( Graphics gfx , int line , int x ) { int y = textArea . lineToY ( line ) ; y += fm . getLeading ( ) + fm . getMaxDescent ( ) ; int height = fm . getHeight ( ) ; Color col = getTextArea ( ) . getLineBgColor ( line ) ; if ( col == null ) { return ; } gfx . setColor ( col ) ; gfx . fillRect ( 0 , y , getWidth ( ) , height ) ; } protected void paintErrorLine ( Graphics gfx , int line , int x ) { ErrorCheckerService ecs = getEditor ( ) . getErrorChecker ( ) ; if ( ecs == null || ecs . problemsList == null ) { return ; } boolean notFound = true ; boolean isWarning = false ; Problem problem = null ; errorLineCoords . clear ( ) ; for ( ErrorMarker emarker : getEditor ( ) . getErrorPoints ( ) ) { if ( emarker . getProblem ( ) . getLineNumber ( ) == line ) { notFound = false ; if ( emarker . getType ( ) == ErrorMarker . Warning ) { isWarning = true ; } problem = emarker . getProblem ( ) ; break ; } } if ( notFound ) { return ; } int y = textArea . lineToY ( line ) ; y += fm . getLeading ( ) + fm . getMaxDescent ( ) ; int start = textArea . getLineStartOffset ( line ) + problem . getPDELineStartOffset ( ) ; int pLength = problem . getPDELineStopOffset ( ) + 1 - problem . getPDELineStartOffset ( ) ; try { String badCode = null ; String goodCode = null ; try { SyntaxDocument doc = textArea . getDocument ( ) ; badCode = doc . getText ( start , pLength ) ; goodCode = doc . getText ( textArea . getLineStartOffset ( line ) , problem . getPDELineStartOffset ( ) ) ; } catch ( BadLocationException bl ) { return ; } int aw = fm . stringWidth ( trimRight ( badCode ) ) + textArea . getHorizontalOffset ( ) ; int rw = fm . stringWidth ( badCode . trim ( ) ) ; int x1 = fm . stringWidth ( goodCode ) + ( aw - rw ) , y1 = y + fm . getHeight ( ) - 2 , x2 = x1 + rw ; x1 += Editor . LEFT_GUTTER ; x2 += Editor . LEFT_GUTTER ; errorLineCoords . add ( new ErrorLineCoord ( x1 , x2 , y , y1 , problem ) ) ; gfx . setColor ( errorColor ) ; if ( isWarning ) { gfx . setColor ( warningColor ) ; } int xx = x1 ; while ( xx < x2 ) { gfx . drawLine ( xx , y1 , xx + 2 , y1 + 1 ) ; xx += 2 ; gfx . drawLine ( xx , y1 + 1 , xx + 2 , y1 ) ; xx += 2 ; } } catch ( Exception e ) { System . out . println ( "Looks like I messed up! XQTextAreaPainter.paintLine() : " + e ) ; } } static private String trimRight ( String string ) { String newString = "" ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( string . charAt ( i ) != ' ' ) { newString = string . substring ( 0 , i ) + string . trim ( ) ; break ; } } return newString ; } public void setMode ( JavaMode mode ) { errorColor = mode . getColor ( "editor.errorcolor" ) ; warningColor = mode . getColor ( "editor.warningcolor" ) ; errorMarkerColor = mode . getColor ( "editor.errormarkercolor" ) ; warningMarkerColor = mode . getColor ( "editor.warningmarkercolor" ) ; gutterTextFont = mode . getFont ( "editor.gutter.text.font" ) ; gutterTextColor = mode . getColor ( "editor.gutter.text.color" ) ; gutterLineHighlightColor = mode . getColor ( "editor.gutter.linehighlight.color" ) ; } @ Override public String getToolTipText ( MouseEvent event ) { if ( ! getEditor ( ) . hasJavaTabs ( ) ) { int off = textArea . xyToOffset ( event . getX ( ) , event . getY ( ) ) ; if ( off < 0 ) { setToolTipText ( null ) ; return super . getToolTipText ( event ) ; } int line = textArea . getLineOfOffset ( off ) ; if ( line < 0 ) { setToolTipText ( null ) ; return super . getToolTipText ( event ) ; } String s = textArea . getLineText ( line ) ; if ( s == "" ) { return event . toString ( ) ; } else if ( s . length ( ) == 0 ) { setToolTipText ( null ) ; return super . getToolTipText ( event ) ; } else { int x = textArea . xToOffset ( line , event . getX ( ) ) , x2 = x + 1 , x1 = x - 1 ; int xLS = off - textArea . getLineStartNonWhiteSpaceOffset ( line ) ; if ( x < 0 || x >= s . length ( ) ) { setToolTipText ( null ) ; return super . getToolTipText ( event ) ; } String word = s . charAt ( x ) + "" ; if ( s . charAt ( x ) == ' ' ) { setToolTipText ( null ) ; return super . getToolTipText ( event ) ; } if ( ! ( Character . isLetterOrDigit ( s . charAt ( x ) ) || s . charAt ( x ) == '_' || s . charAt ( x ) == '$' ) ) { setToolTipText ( null ) ; return super . getToolTipText ( event ) ; } int i = 0 ; while ( true ) { i ++ ; if ( x1 >= 0 && x1 < s . length ( ) ) { if ( Character . isLetter ( s . charAt ( x1 ) ) || s . charAt ( x1 ) == '_' ) { word = s . charAt ( x1 -- ) + word ; xLS -- ; } else x1 = - 1 ; } else x1 = - 1 ; if ( x2 >= 0 && x2 < s . length ( ) ) { if ( Character . isLetterOrDigit ( s . charAt ( x2 ) ) || s . charAt ( x2 ) == '_' || s . charAt ( x2 ) == '$' ) word = word + s . charAt ( x2 ++ ) ; else x2 = - 1 ; } else x2 = - 1 ; if ( x1 < 0 && x2 < 0 ) break ; if ( i > 200 ) { break ; } } if ( Character . isDigit ( word . charAt ( 0 ) ) ) { setToolTipText ( null ) ; return super . getToolTipText ( event ) ; } String tooltipText = getEditor ( ) . getErrorChecker ( ) . getASTGenerator ( ) . getLabelForASTNode ( line , word , xLS ) ; if ( tooltipText != null ) { return tooltipText ; } } } return super . getToolTipText ( event ) ; } protected int horizontalAdjustment = 0 ; public boolean interactiveMode = false ; public List < List < Handle > > handles ; public List < List < ColorControlBox > > colorBoxes ; public Handle mouseHandle = null ; public ColorSelector colorSelector ; int cursorType ; BufferedImage cursorImg = new BufferedImage ( 16 , 16 , BufferedImage . TYPE_INT_ARGB ) ; Cursor blankCursor = Toolkit . getDefaultToolkit ( ) . createCustomCursor ( cursorImg , new Point ( 0 , 0 ) , "blank cursor" ) ; @ Override synchronized public void paint ( Graphics gfx ) { super . paint ( gfx ) ; if ( interactiveMode && handles != null ) { int currentTab = getCurrentCodeIndex ( ) ; Graphics2D g2d = ( Graphics2D ) gfx ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; for ( Handle n : handles . get ( currentTab ) ) { int lineStartChar = textArea . getLineStartOffset ( n . line ) ; int x = textArea . offsetToX ( n . line , n . newStartChar - lineStartChar ) ; int y = textArea . lineToY ( n . line ) + fm . getHeight ( ) + 1 ; int end = textArea . offsetToX ( n . line , n . newEndChar - lineStartChar ) ; n . setPos ( x , y ) ; n . setWidth ( end - x ) ; n . draw ( g2d , n == mouseHandle ) ; } for ( ColorControlBox cBox : colorBoxes . get ( currentTab ) ) { int lineStartChar = textArea . getLineStartOffset ( cBox . getLine ( ) ) ; int x = textArea . offsetToX ( cBox . getLine ( ) , cBox . getCharIndex ( ) - lineStartChar ) ; int y = textArea . lineToY ( cBox . getLine ( ) ) + fm . getDescent ( ) ; cBox . setPos ( x , y + 1 ) ; cBox . draw ( g2d ) ; } } } protected void startInterativeMode ( ) { addMouseListener ( this ) ; addMouseMotionListener ( this ) ; interactiveMode = true ; setCursor ( new Cursor ( Cursor . DEFAULT_CURSOR ) ) ; repaint ( ) ; } protected void stopInteractiveMode ( ) { interactiveMode = false ; if ( colorSelector != null ) { colorSelector . hide ( ) ; colorSelector . frame . dispatchEvent ( new WindowEvent ( colorSelector . frame , WindowEvent . WINDOW_CLOSING ) ) ; } setCursor ( new Cursor ( Cursor . TEXT_CURSOR ) ) ; repaint ( ) ; } protected void updateInterface ( List < List < Handle > > handles , List < List < ColorControlBox > > colorBoxes ) { this . handles = handles ; this . colorBoxes = colorBoxes ; initInterfacePositions ( ) ; repaint ( ) ; } private synchronized void initInterfacePositions ( ) { SketchCode [ ] code = getEditor ( ) . getSketch ( ) . getCode ( ) ; int prevScroll = textArea . getVerticalScrollPosition ( ) ; String prevText = textArea . getText ( ) ; for ( int tab = 0 ; tab < code . length ; tab ++ ) { String tabCode = getEditor ( ) . baseCode [ tab ] ; textArea . setText ( tabCode ) ; for ( Handle n : handles . get ( tab ) ) { int lineStartChar = textArea . getLineStartOffset ( n . line ) ; int x = textArea . offsetToX ( n . line , n . newStartChar - lineStartChar ) ; int end = textArea . offsetToX ( n . line , n . newEndChar - lineStartChar ) ; int y = textArea . lineToY ( n . line ) + fm . getHeight ( ) + 1 ; n . initInterface ( x , y , end - x , fm . getHeight ( ) ) ; } for ( ColorControlBox cBox : colorBoxes . get ( tab ) ) { int lineStartChar = textArea . getLineStartOffset ( cBox . getLine ( ) ) ; int x = textArea . offsetToX ( cBox . getLine ( ) , cBox . getCharIndex ( ) - lineStartChar ) ; int y = textArea . lineToY ( cBox . getLine ( ) ) + fm . getDescent ( ) ; cBox . initInterface ( this , x , y + 1 , fm . getHeight ( ) - 2 , fm . getHeight ( ) - 2 ) ; } } textArea . setText ( prevText ) ; textArea . scrollTo ( prevScroll , 0 ) ; } public void updateCodeText ( ) { int charInc = 0 ; int currentTab = getCurrentCodeIndex ( ) ; SketchCode sc = getEditor ( ) . getSketch ( ) . getCode ( currentTab ) ; String code = getEditor ( ) . baseCode [ currentTab ] ; for ( Handle n : handles . get ( currentTab ) ) { int s = n . startChar + charInc ; int e = n . endChar + charInc ; code = replaceString ( code , s , e , n . strNewValue ) ; n . newStartChar = n . startChar + charInc ; charInc += n . strNewValue . length ( ) - n . strValue . length ( ) ; n . newEndChar = n . endChar + charInc ; } replaceTextAreaCode ( code ) ; sc . setProgram ( code ) ; } private synchronized void replaceTextAreaCode ( String code ) { int scrollLine = textArea . getVerticalScrollPosition ( ) ; int scrollHor = textArea . getHorizontalScrollPosition ( ) ; textArea . setText ( code ) ; textArea . setOrigin ( scrollLine , - scrollHor ) ; } static private String replaceString ( String str , int start , int end , String put ) { return str . substring ( 0 , start ) + put + str . substring ( end , str . length ( ) ) ; } private void updateCursor ( int mouseX , int mouseY ) { int currentTab = getCurrentCodeIndex ( ) ; for ( Handle n : handles . get ( currentTab ) ) { if ( n . pick ( mouseX , mouseY ) ) { cursorType = Cursor . W_RESIZE_CURSOR ; setCursor ( new Cursor ( cursorType ) ) ; return ; } } for ( ColorControlBox colorBox : colorBoxes . get ( currentTab ) ) { if ( colorBox . pick ( mouseX , mouseY ) ) { cursorType = Cursor . HAND_CURSOR ; setCursor ( new Cursor ( cursorType ) ) ; return ; } } if ( cursorType == Cursor . W_RESIZE_CURSOR || cursorType == Cursor . HAND_CURSOR || cursorType == - 1 ) { cursorType = Cursor . DEFAULT_CURSOR ; setCursor ( new Cursor ( cursorType ) ) ; } } private void showHideColorBoxes ( int y ) { int currentTab = getCurrentCodeIndex ( ) ; boolean change = false ; for ( ColorControlBox box : colorBoxes . get ( currentTab ) ) { if ( box . setMouseY ( y ) ) { change = true ; } } if ( colorSelector != null ) { colorSelector . colorBox . visible = true ; } if ( change ) { repaint ( ) ; } } @ Override public void mouseDragged ( MouseEvent e ) { if ( mouseHandle != null ) { mouseHandle . setCurrentX ( e . getX ( ) ) ; updateCodeText ( ) ; if ( colorSelector != null ) { colorSelector . refreshColor ( ) ; } repaint ( ) ; } } @ Override public void mouseExited ( MouseEvent e ) { } @ Override public void mousePressed ( MouseEvent e ) { int currentTab = getCurrentCodeIndex ( ) ; for ( Handle n : handles . get ( currentTab ) ) { if ( n . pick ( e . getX ( ) , e . getY ( ) ) ) { cursorType = - 1 ; this . setCursor ( blankCursor ) ; mouseHandle = n ; mouseHandle . setCenterX ( e . getX ( ) ) ; repaint ( ) ; return ; } } for ( ColorControlBox box : colorBoxes . get ( currentTab ) ) { if ( box . pick ( e . getX ( ) , e . getY ( ) ) ) { if ( colorSelector != null ) { colorSelector . frame . dispatchEvent ( new WindowEvent ( colorSelector . frame , WindowEvent . WINDOW_CLOSING ) ) ; } colorSelector = new ColorSelector ( box ) ; colorSelector . frame . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { colorSelector . frame . setVisible ( false ) ; colorSelector = null ; } } ) ; colorSelector . show ( this . getLocationOnScreen ( ) . x + e . getX ( ) + 30 , this . getLocationOnScreen ( ) . y + e . getY ( ) - 130 ) ; } } } @ Override public void mouseReleased ( MouseEvent e ) { if ( mouseHandle != null ) { mouseHandle . resetProgress ( ) ; mouseHandle = null ; updateCursor ( e . getX ( ) , e . getY ( ) ) ; repaint ( ) ; } } @ Override public void mouseMoved ( MouseEvent e ) { updateCursor ( e . getX ( ) , e . getY ( ) ) ; if ( ! Settings . alwaysShowColorBoxes ) { showHideColorBoxes ( e . getY ( ) ) ; } } @ Override public void mouseClicked ( MouseEvent e ) { } @ Override public void mouseEntered ( MouseEvent e ) { } private JavaEditor getEditor ( ) { return ( ( JavaTextArea ) textArea ) . editor ; } private int getCurrentCodeIndex ( ) { return getEditor ( ) . getSketch ( ) . getCurrentCodeIndex ( ) ; } private JavaTextArea getTextArea ( ) { return ( JavaTextArea ) textArea ; } }
package processing . mode . java . pdex ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . List ; import org . eclipse . jdt . core . dom . ASTNode ; import org . eclipse . jdt . core . dom . FieldDeclaration ; import org . eclipse . jdt . core . dom . MethodDeclaration ; import org . eclipse . jdt . core . dom . SingleVariableDeclaration ; import org . eclipse . jdt . core . dom . TypeDeclaration ; import org . eclipse . jdt . core . dom . VariableDeclarationFragment ; public class CompletionCandidate implements Comparable < CompletionCandidate > { private String elementName ; private String label ; private String completionString ; private Object wrappedObject ; private int type ; static final int PREDEF_CLASS = 0 ; static final int PREDEF_FIELD = 1 ; static final int PREDEF_METHOD = 2 ; static final int LOCAL_CLASS = 3 ; static final int LOCAL_METHOD = 4 ; static final int LOCAL_FIELD = 5 ; static final int LOCAL_VAR = 6 ; public CompletionCandidate ( Method method ) { method . getDeclaringClass ( ) . getName ( ) ; elementName = method . getName ( ) ; StringBuilder label = new StringBuilder ( "<html>" + method . getName ( ) + "(" ) ; StringBuilder cstr = new StringBuilder ( method . getName ( ) + "(" ) ; for ( int i = 0 ; i < method . getParameterTypes ( ) . length ; i ++ ) { label . append ( method . getParameterTypes ( ) [ i ] . getSimpleName ( ) ) ; if ( i < method . getParameterTypes ( ) . length - 1 ) { label . append ( "," ) ; cstr . append ( "," ) ; } } if ( method . getParameterTypes ( ) . length == 1 ) { cstr . append ( ' ' ) ; } label . append ( ")" ) ; if ( method . getReturnType ( ) != null ) label . append ( " : " + method . getReturnType ( ) . getSimpleName ( ) ) ; label . append ( " - <font color=#777777>" + method . getDeclaringClass ( ) . getSimpleName ( ) + "</font></html>" ) ; cstr . append ( ")" ) ; this . label = label . toString ( ) ; this . completionString = cstr . toString ( ) ; type = PREDEF_METHOD ; wrappedObject = method ; } public Object getWrappedObject ( ) { return wrappedObject ; } public CompletionCandidate ( SingleVariableDeclaration svd ) { completionString = svd . getName ( ) . toString ( ) ; elementName = svd . getName ( ) . toString ( ) ; if ( svd . getParent ( ) instanceof FieldDeclaration ) type = LOCAL_FIELD ; else type = LOCAL_VAR ; label = svd . getName ( ) + " : " + svd . getType ( ) ; wrappedObject = svd ; } public CompletionCandidate ( VariableDeclarationFragment vdf ) { completionString = vdf . getName ( ) . toString ( ) ; elementName = vdf . getName ( ) . toString ( ) ; if ( vdf . getParent ( ) instanceof FieldDeclaration ) type = LOCAL_FIELD ; else type = LOCAL_VAR ; label = vdf . getName ( ) + " : " + ASTGenerator . extracTypeInfo2 ( vdf ) ; wrappedObject = vdf ; } public CompletionCandidate ( MethodDeclaration method ) { elementName = method . getName ( ) . toString ( ) ; type = LOCAL_METHOD ; @ SuppressWarnings ( "unchecked" ) List < ASTNode > params = ( List < ASTNode > ) method . getStructuralProperty ( MethodDeclaration . PARAMETERS_PROPERTY ) ; StringBuilder label = new StringBuilder ( elementName + "(" ) ; StringBuilder cstr = new StringBuilder ( method . getName ( ) + "(" ) ; for ( int i = 0 ; i < params . size ( ) ; i ++ ) { label . append ( params . get ( i ) . toString ( ) ) ; if ( i < params . size ( ) - 1 ) { label . append ( "," ) ; cstr . append ( "," ) ; } } if ( params . size ( ) == 1 ) { cstr . append ( ' ' ) ; } label . append ( ")" ) ; if ( method . getReturnType2 ( ) != null ) label . append ( " : " + method . getReturnType2 ( ) ) ; cstr . append ( ")" ) ; this . label = label . toString ( ) ; this . completionString = cstr . toString ( ) ; wrappedObject = method ; } public CompletionCandidate ( TypeDeclaration td ) { type = LOCAL_CLASS ; elementName = td . getName ( ) . toString ( ) ; label = elementName ; completionString = elementName ; wrappedObject = td ; } public CompletionCandidate ( Field f ) { f . getDeclaringClass ( ) . getName ( ) ; elementName = f . getName ( ) ; type = PREDEF_FIELD ; label = "<html>" + f . getName ( ) + " : " + f . getType ( ) . getSimpleName ( ) + " - <font color=#777777>" + f . getDeclaringClass ( ) . getSimpleName ( ) + "</font></html>" ; completionString = elementName ; wrappedObject = f ; } public CompletionCandidate ( String name , String labelStr , String completionStr , int type ) { elementName = name ; label = labelStr ; completionString = completionStr ; this . type = type ; } public CompletionCandidate ( String name , int type ) { elementName = name ; label = name ; completionString = name ; this . type = type ; } public String getElementName ( ) { return elementName ; } public String getCompletionString ( ) { return completionString ; } public String toString ( ) { return label ; } public int getType ( ) { return type ; } public String getLabel ( ) { return label ; } public String getNoHtmlLabel ( ) { if ( ! label . contains ( "<html>" ) ) { return label ; } else { StringBuilder ans = new StringBuilder ( label ) ; while ( ans . indexOf ( "<" ) > - 1 ) { int a = ans . indexOf ( "<" ) , b = ans . indexOf ( ">" ) ; if ( a > b ) break ; ans . replace ( a , b + 1 , "" ) ; } return ans . toString ( ) ; } } public void setLabel ( String label ) { this . label = label ; } public void setCompletionString ( String completionString ) { this . completionString = completionString ; } public int compareTo ( CompletionCandidate cc ) { if ( type != cc . getType ( ) ) { return cc . getType ( ) - type ; } return ( elementName . compareTo ( cc . getElementName ( ) ) ) ; } public void regenerateCompletionString ( ) { if ( wrappedObject instanceof MethodDeclaration ) { MethodDeclaration method = ( MethodDeclaration ) wrappedObject ; @ SuppressWarnings ( "unchecked" ) List < ASTNode > params = ( List < ASTNode > ) method . getStructuralProperty ( MethodDeclaration . PARAMETERS_PROPERTY ) ; StringBuilder label = new StringBuilder ( elementName + "(" ) ; StringBuilder cstr = new StringBuilder ( method . getName ( ) + "(" ) ; for ( int i = 0 ; i < params . size ( ) ; i ++ ) { label . append ( params . get ( i ) . toString ( ) ) ; if ( i < params . size ( ) - 1 ) { label . append ( "," ) ; cstr . append ( "," ) ; } } if ( params . size ( ) == 1 ) { cstr . append ( ' ' ) ; } label . append ( ")" ) ; if ( method . getReturnType2 ( ) != null ) label . append ( " : " + method . getReturnType2 ( ) ) ; cstr . append ( ")" ) ; this . label = label . toString ( ) ; this . completionString = cstr . toString ( ) ; } else if ( wrappedObject instanceof Method ) { Method method = ( Method ) wrappedObject ; StringBuilder label = new StringBuilder ( "<html>" + method . getName ( ) + "(" ) ; StringBuilder cstr = new StringBuilder ( method . getName ( ) + "(" ) ; for ( int i = 0 ; i < method . getParameterTypes ( ) . length ; i ++ ) { label . append ( method . getParameterTypes ( ) [ i ] . getSimpleName ( ) ) ; if ( i < method . getParameterTypes ( ) . length - 1 ) { label . append ( "," ) ; cstr . append ( "," ) ; } } if ( method . getParameterTypes ( ) . length == 1 ) { cstr . append ( ' ' ) ; } label . append ( ")" ) ; if ( method . getReturnType ( ) != null ) label . append ( " : " + method . getReturnType ( ) . getSimpleName ( ) ) ; label . append ( " - <font color=#777777>" + method . getDeclaringClass ( ) . getSimpleName ( ) + "</font></html>" ) ; cstr . append ( ")" ) ; this . label = label . toString ( ) ; this . completionString = cstr . toString ( ) ; } } }
package processing . core ; public interface PSurface { static public final int MIN_WINDOW_WIDTH = 128 ; static public final int MIN_WINDOW_HEIGHT = 128 ; public void initOffscreen ( PApplet sketch ) ; public void initFrame ( PApplet sketch ) ; public void setTitle ( String title ) ; public void setVisible ( boolean visible ) ; public void setResizable ( boolean resizable ) ; public void placeWindow ( int [ ] location , int [ ] editorLocation ) ; public void placePresent ( int stopColor ) ; public void setupExternalMessages ( ) ; public void setSize ( int width , int height ) ; public void setSmooth ( int level ) ; public void setFrameRate ( float fps ) ; public void setCursor ( int kind ) ; public void setCursor ( PImage image , int hotspotX , int hotspotY ) ; public void showCursor ( ) ; public void hideCursor ( ) ; public void startThread ( ) ; public void pauseThread ( ) ; public void resumeThread ( ) ; public boolean stopThread ( ) ; public boolean isStopped ( ) ; }
package processing . mode . java . pdex ; import java . io . File ; import java . net . URL ; import java . net . URLClassLoader ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . TreeMap ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import javax . swing . event . DocumentEvent ; import javax . swing . event . DocumentListener ; import javax . swing . table . DefaultTableModel ; import javax . swing . text . BadLocationException ; import javax . swing . text . Document ; import javax . swing . text . Element ; import javax . swing . text . PlainDocument ; import org . eclipse . jdt . core . JavaCore ; import org . eclipse . jdt . core . compiler . IProblem ; import org . eclipse . jdt . core . dom . AST ; import org . eclipse . jdt . core . dom . ASTNode ; import org . eclipse . jdt . core . dom . ASTParser ; import org . eclipse . jdt . core . dom . CompilationUnit ; import org . eclipse . jdt . internal . compiler . impl . CompilerOptions ; import processing . app . Base ; import processing . app . Editor ; import processing . app . EditorStatus ; import processing . app . Library ; import processing . app . SketchCode ; import processing . app . syntax . SyntaxDocument ; import processing . core . PApplet ; import processing . mode . java . JavaMode ; import processing . mode . java . JavaEditor ; import processing . mode . java . preproc . PdePreprocessor ; @ SuppressWarnings ( "unchecked" ) public class ErrorCheckerService implements Runnable { protected JavaEditor editor ; public static final int sleepTime = 1000 ; protected ASTParser parser ; protected AtomicBoolean stopThread ; protected AtomicBoolean pauseThread ; protected IProblem [ ] problems ; protected String className ; protected String sourceCode ; protected URL [ ] classPath ; public List < Problem > problemsList ; public int mainClassOffset ; public int defaultImportsOffset ; public boolean staticMode = false ; protected CompilationUnit cu ; protected CompilationUnit compileCheckCU ; protected CompilationUnit lastCorrectCU ; protected boolean loadCompClass = true ; protected Class < ? > checkerClass ; protected CompilationChecker compilationChecker ; protected List < URL > classpathJars ; protected long lastTimeStamp = System . currentTimeMillis ( ) ; protected String [ ] slashAnimation = { "|" , "/" , "--" , "\\" , "|" , "/" , "--" , "\\" } ; protected int slashAnimationIndex = 0 ; public int currentTab = 0 , lastTab = 0 ; protected ArrayList < ImportStatement > programImports ; protected ArrayList < ImportStatement > previousImports = new ArrayList < ImportStatement > ( ) ; protected XQPreprocessor xqpreproc ; final public String importRegexp = "(?:^|;)\\s*(import\\s+)((?:static\\s+)?\\S+)(\\s*;)" ; final Pattern FUNCTION_DECL = Pattern . compile ( "(^|;)\\s*((public|private|protected|final|static)\\s+)*" + "(void|int|float|double|String|char|byte|boolean)" + "(\\s*\\[\\s*\\])?\\s+[a-zA-Z0-9]+\\s*\\(" , Pattern . MULTILINE ) ; protected ErrorMessageSimplifier errorMsgSimplifier ; public ErrorCheckerService ( JavaEditor debugEditor ) { ensureMinP5Version ( ) ; this . editor = debugEditor ; stopThread = new AtomicBoolean ( false ) ; pauseThread = new AtomicBoolean ( false ) ; problemsList = new ArrayList < Problem > ( ) ; classpathJars = new ArrayList < URL > ( ) ; initParser ( ) ; xqpreproc = new XQPreprocessor ( ) ; PdePreprocessor pdePrepoc = new PdePreprocessor ( null ) ; defaultImportsOffset = pdePrepoc . getCoreImports ( ) . length + pdePrepoc . getDefaultImports ( ) . length + 1 ; astGenerator = new ASTGenerator ( this ) ; syntaxErrors = new AtomicBoolean ( true ) ; containsErrors = new AtomicBoolean ( true ) ; errorMsgSimplifier = new ErrorMessageSimplifier ( ) ; tempErrorLog = new TreeMap < String , IProblem > ( ) ; sketchChangedListener = new SketchChangedListener ( ) ; } protected void initParser ( ) { try { parser = ASTParser . newParser ( AST . JLS8 ) ; } catch ( Exception e ) { System . err . println ( "Experimental Mode initialization failed. " + "Are you running the right version of Processing? " ) ; pauseThread ( ) ; } catch ( Error e ) { System . err . println ( "Experimental Mode initialization failed. " ) ; e . printStackTrace ( ) ; pauseThread ( ) ; } } public void ensureMinP5Version ( ) { if ( Base . getRevision ( ) < 225 ) { Base . showWarning ( "Error" , "ERROR: PDE X requires Processing 2.1.2 or higher." , null ) ; } } private final static long errorCheckInterval = 500 ; private volatile boolean noSleep = false ; public void run ( ) { stopThread . set ( false ) ; checkCode ( ) ; lastErrorCheckCall = System . currentTimeMillis ( ) ; if ( ! hasSyntaxErrors ( ) ) { editor . showConsole ( ) ; } astGenerator . buildAST ( cu ) ; handleErrorCheckingToggle ( ) ; while ( ! stopThread . get ( ) ) { try { if ( ! noSleep ) { Thread . sleep ( sleepTime ) ; } else { noSleep = false ; Base . log ( "Didn't sleep!" ) ; } } catch ( Exception e ) { Base . log ( "Oops! [ErrorCheckerThreaded]: " + e ) ; } updatePaintedThingys ( ) ; updateEditorStatus ( ) ; updateSketchCodeListeners ( ) ; if ( pauseThread . get ( ) ) continue ; if ( textModified . get ( ) == 0 ) continue ; if ( System . currentTimeMillis ( ) - lastErrorCheckCall > errorCheckInterval ) { Base . log ( "Interval passed, starting error check" ) ; checkCode ( ) ; checkForMissingImports ( ) ; } } astGenerator . disposeAllWindows ( ) ; compilationChecker = null ; checkerClass = null ; classLoader = null ; System . gc ( ) ; Base . loge ( "Thread stopped: " + editor . getSketch ( ) . getName ( ) ) ; System . gc ( ) ; } protected void updateSketchCodeListeners ( ) { for ( final SketchCode sc : editor . getSketch ( ) . getCode ( ) ) { boolean flag = false ; if ( sc . getDocument ( ) == null || ( ( SyntaxDocument ) sc . getDocument ( ) ) . getDocumentListeners ( ) == null ) continue ; for ( DocumentListener dl : ( ( SyntaxDocument ) sc . getDocument ( ) ) . getDocumentListeners ( ) ) { if ( dl . equals ( sketchChangedListener ) ) { flag = true ; break ; } } if ( ! flag ) { sc . getDocument ( ) . addDocumentListener ( sketchChangedListener ) ; } } } protected void checkForMissingImports ( ) { if ( JavaMode . importSuggestEnabled ) { for ( Problem p : problemsList ) { if ( p . getIProblem ( ) . getID ( ) == IProblem . UndefinedType ) { String args [ ] = p . getIProblem ( ) . getArguments ( ) ; if ( args . length > 0 ) { String missingClass = args [ 0 ] ; Base . log ( "Will suggest for type:" + missingClass ) ; } } } } } protected ASTGenerator astGenerator ; public ASTGenerator getASTGenerator ( ) { return astGenerator ; } protected AtomicInteger textModified = new AtomicInteger ( ) ; private volatile long lastErrorCheckCall = 0 ; public void runManualErrorCheck ( ) { textModified . incrementAndGet ( ) ; lastErrorCheckCall = System . currentTimeMillis ( ) ; } public void quickErrorCheck ( ) { noSleep = true ; } protected SketchChangedListener sketchChangedListener ; protected class SketchChangedListener implements DocumentListener { private SketchChangedListener ( ) { } @ Override public void insertUpdate ( DocumentEvent e ) { if ( JavaMode . errorCheckEnabled ) { runManualErrorCheck ( ) ; } } @ Override public void removeUpdate ( DocumentEvent e ) { if ( JavaMode . errorCheckEnabled ) { runManualErrorCheck ( ) ; } } @ Override public void changedUpdate ( DocumentEvent e ) { if ( JavaMode . errorCheckEnabled ) { runManualErrorCheck ( ) ; } } } public int compilationUnitState = 0 ; protected boolean checkCode ( ) { lastTimeStamp = System . currentTimeMillis ( ) ; try { sourceCode = preprocessCode ( editor . getSketch ( ) . getMainProgram ( ) ) ; compilationUnitState = 0 ; syntaxCheck ( ) ; if ( ! hasSyntaxErrors ( ) ) { } if ( problems . length == 0 && ! editor . hasJavaTabs ( ) ) { sourceCode = xqpreproc . doYourThing ( sourceCode , programImports ) ; prepareCompilerClasspath ( ) ; compileCheck ( ) ; } astGenerator . buildAST ( cu ) ; if ( ! JavaMode . errorCheckEnabled ) { problemsList . clear ( ) ; Base . log ( "Error Check disabled, so not updating UI." ) ; } calcPDEOffsetsForProbList ( ) ; updateErrorTable ( ) ; editor . updateErrorBar ( problemsList ) ; updateEditorStatus ( ) ; editor . getTextArea ( ) . repaint ( ) ; updatePaintedThingys ( ) ; editor . updateErrorToggle ( ) ; int x = textModified . get ( ) ; if ( x >= 2 ) { textModified . set ( 2 ) ; x = 2 ; } if ( x > 0 ) textModified . set ( x - 1 ) ; else textModified . set ( 0 ) ; return true ; } catch ( Exception e ) { Base . log ( "Oops! [ErrorCheckerService.checkCode]: " + e ) ; e . printStackTrace ( ) ; } return false ; } protected AtomicBoolean syntaxErrors , containsErrors ; public boolean hasSyntaxErrors ( ) { return syntaxErrors . get ( ) ; } public boolean hasErrors ( ) { return containsErrors . get ( ) ; } public TreeMap < String , IProblem > tempErrorLog ; protected void syntaxCheck ( ) { syntaxErrors . set ( true ) ; containsErrors . set ( true ) ; parser . setSource ( sourceCode . toCharArray ( ) ) ; parser . setKind ( ASTParser . K_COMPILATION_UNIT ) ; Map < String , String > options = JavaCore . getOptions ( ) ; JavaCore . setComplianceOptions ( JavaCore . VERSION_1_6 , options ) ; options . put ( JavaCore . COMPILER_SOURCE , JavaCore . VERSION_1_6 ) ; options . put ( JavaCore . COMPILER_DOC_COMMENT_SUPPORT , JavaCore . ENABLED ) ; parser . setCompilerOptions ( options ) ; if ( cu == null ) cu = ( CompilationUnit ) parser . createAST ( null ) ; else { synchronized ( cu ) { cu = ( CompilationUnit ) parser . createAST ( null ) ; } } compilationUnitState = 1 ; synchronized ( problemsList ) { problems = cu . getProblems ( ) ; problemsList = new ArrayList < Problem > ( ) ; for ( int i = 0 ; i < problems . length ; i ++ ) { int a [ ] = calculateTabIndexAndLineNumber ( problems [ i ] . getSourceLineNumber ( ) ) ; Problem p = new Problem ( problems [ i ] , a [ 0 ] , a [ 1 ] ) ; problemsList . add ( p ) ; } if ( problems . length == 0 ) { syntaxErrors . set ( false ) ; containsErrors . set ( false ) ; parser . setSource ( sourceCode . toCharArray ( ) ) ; parser . setKind ( ASTParser . K_COMPILATION_UNIT ) ; parser . setCompilerOptions ( options ) ; lastCorrectCU = ( CompilationUnit ) parser . createAST ( null ) ; } else { syntaxErrors . set ( true ) ; containsErrors . set ( true ) ; } } } protected URLClassLoader classLoader ; protected void compileCheck ( ) { parser . setSource ( sourceCode . toCharArray ( ) ) ; parser . setKind ( ASTParser . K_COMPILATION_UNIT ) ; Map < String , String > options = JavaCore . getOptions ( ) ; JavaCore . setComplianceOptions ( JavaCore . VERSION_1_6 , options ) ; options . put ( JavaCore . COMPILER_SOURCE , JavaCore . VERSION_1_6 ) ; options . put ( JavaCore . COMPILER_DOC_COMMENT_SUPPORT , JavaCore . ENABLED ) ; parser . setCompilerOptions ( options ) ; if ( compileCheckCU == null ) compileCheckCU = ( CompilationUnit ) parser . createAST ( null ) ; else { synchronized ( compileCheckCU ) { compileCheckCU = ( CompilationUnit ) parser . createAST ( null ) ; } } if ( ! hasSyntaxErrors ( ) ) lastCorrectCU = compileCheckCU ; cu = compileCheckCU ; compilationUnitState = 2 ; try { if ( loadCompClass ) { classPath = new URL [ classpathJars . size ( ) ] ; classpathJars . toArray ( classPath ) ; compilationChecker = null ; classLoader = null ; System . gc ( ) ; classLoader = new URLClassLoader ( classPath ) ; compilationChecker = new CompilationChecker ( ) ; loadCompClass = false ; } if ( compilerSettings == null ) { prepareCompilerSetting ( ) ; } synchronized ( problemsList ) { problems = compilationChecker . getErrors ( className , sourceCode , compilerSettings , classLoader ) ; if ( problems == null ) { return ; } for ( IProblem problem : problems ) { int [ ] a = calculateTabIndexAndLineNumber ( problem . getSourceLineNumber ( ) - 1 ) ; Problem p = new Problem ( problem , a [ 0 ] , a [ 1 ] ) ; if ( problem . isError ( ) ) { p . setType ( Problem . ERROR ) ; containsErrors . set ( true ) ; } if ( problem . isWarning ( ) ) { p . setType ( Problem . WARNING ) ; } if ( p . isWarning ( ) && ! JavaMode . warningsEnabled ) { continue ; } problemsList . add ( p ) ; } } } catch ( Exception e ) { System . err . println ( "compileCheck() problem." + e ) ; e . printStackTrace ( ) ; pauseThread ( ) ; } catch ( NoClassDefFoundError e ) { e . printStackTrace ( ) ; pauseThread ( ) ; } catch ( OutOfMemoryError e ) { System . err . println ( "Out of memory while checking for errors." ) ; System . err . println ( "Close some sketches and then re-open this sketch." ) ; pauseThread ( ) ; } } private void calcPDEOffsetsForProbList ( ) { try { PlainDocument javaSource = new PlainDocument ( ) ; javaSource . insertString ( 0 , sourceCode , null ) ; List < Document > pdeTabs = new ArrayList < > ( ) ; for ( SketchCode sc : editor . getSketch ( ) . getCode ( ) ) { PlainDocument tab = new PlainDocument ( ) ; if ( editor . getSketch ( ) . getCurrentCode ( ) . equals ( sc ) ) { Document doc = sc . getDocument ( ) ; tab . insertString ( 0 , doc . getText ( 0 , doc . getLength ( ) ) , null ) ; } else { tab . insertString ( 0 , sc . getProgram ( ) , null ) ; } pdeTabs . add ( tab ) ; } int pkgNameOffset = ( "package " + className + ";\n" ) . length ( ) ; if ( compilationUnitState != 2 ) pkgNameOffset = 0 ; for ( Problem p : problemsList ) { int prbStart = p . getIProblem ( ) . getSourceStart ( ) - pkgNameOffset ; int prbEnd = p . getIProblem ( ) . getSourceEnd ( ) - pkgNameOffset ; int javaLineNumber = p . getSourceLineNumber ( ) - 1 ; if ( compilationUnitState == 2 ) { javaLineNumber -- ; } Element lineElement = javaSource . getDefaultRootElement ( ) . getElement ( javaLineNumber ) ; if ( lineElement == null ) { Base . log ( "calcPDEOffsetsForProbList(): " + "Couldn't fetch Java line number " + javaLineNumber + "\nProblem: " + p ) ; p . setPDEOffsets ( - 1 , - 1 ) ; continue ; } int lineStart = lineElement . getStartOffset ( ) ; int lineLength = lineElement . getEndOffset ( ) - lineStart ; String javaLine = javaSource . getText ( lineStart , lineLength ) ; Document doc = pdeTabs . get ( p . getTabIndex ( ) ) ; Element pdeLineElement = doc . getDefaultRootElement ( ) . getElement ( p . getLineNumber ( ) ) ; if ( pdeLineElement == null ) { Base . log ( "calcPDEOffsetsForProbList(): " + "Couldn't fetch pde line number " + javaLineNumber + "\nProblem: " + p ) ; p . setPDEOffsets ( - 1 , - 1 ) ; continue ; } int pdeLineStart = pdeLineElement . getStartOffset ( ) ; int pdeLineLength = pdeLineElement . getEndOffset ( ) - pdeLineStart ; String pdeLine = pdeTabs . get ( p . getTabIndex ( ) ) . getText ( pdeLineStart , pdeLineLength ) ; OffsetMatcher ofm = new OffsetMatcher ( pdeLine , javaLine ) ; int pdeOffset = ofm . getPdeOffForJavaOff ( prbStart - lineStart , prbEnd - prbStart + 1 ) ; p . setPDEOffsets ( pdeOffset , pdeOffset + prbEnd - prbStart ) ; } } catch ( BadLocationException ble ) { ble . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public CompilationUnit getLastCorrectCU ( ) { return lastCorrectCU ; } public CompilationUnit getLatestCU ( ) { return compileCheckCU ; } private int loadClassCounter = 0 ; public URLClassLoader getSketchClassLoader ( ) { loadClassCounter ++ ; if ( loadClassCounter > 100 ) { loadClassCounter = 0 ; classLoader = null ; System . gc ( ) ; classLoader = new URLClassLoader ( classPath ) ; } return classLoader ; } protected void prepareCompilerClasspath ( ) { if ( ! loadCompClass ) { return ; } synchronized ( classpathJars ) { classpathJars = new ArrayList < URL > ( ) ; String entry = "" ; boolean codeFolderChecked = false ; for ( ImportStatement impstat : programImports ) { String item = impstat . getImportName ( ) ; int dot = item . lastIndexOf ( '.' ) ; entry = ( dot == - 1 ) ? item : item . substring ( 0 , dot ) ; entry = entry . substring ( 6 ) . trim ( ) ; if ( ignorableImport ( entry ) ) { continue ; } Library library = null ; try { library = editor . getMode ( ) . getLibrary ( entry ) ; String [ ] libraryPath = PApplet . split ( library . getClassPath ( ) . substring ( 1 ) . trim ( ) , File . pathSeparatorChar ) ; for ( String pathItem : libraryPath ) { classpathJars . add ( new File ( pathItem ) . toURI ( ) . toURL ( ) ) ; } } catch ( Exception e ) { if ( library == null && ! codeFolderChecked ) { if ( editor . getSketch ( ) . hasCodeFolder ( ) ) { File codeFolder = editor . getSketch ( ) . getCodeFolder ( ) ; String codeFolderClassPath = Base . contentsToClassPath ( codeFolder ) ; codeFolderChecked = true ; if ( codeFolderClassPath . equalsIgnoreCase ( "" ) ) { System . err . format ( "Cannot find \"%s\" library. Line %d in tab %s%n" , entry , impstat . getLineNumber ( ) , editor . getSketch ( ) . getCode ( impstat . getTab ( ) ) . getPrettyName ( ) ) ; System . err . println ( "Make sure that the library is installed properly." ) ; } else { String codeFolderPath [ ] = PApplet . split ( codeFolderClassPath . substring ( 1 ) . trim ( ) , File . pathSeparatorChar ) ; try { for ( String pathItem : codeFolderPath ) { classpathJars . add ( new File ( pathItem ) . toURI ( ) . toURL ( ) ) ; } } catch ( Exception e2 ) { e2 . printStackTrace ( ) ; } } } else { System . err . format ( "Cannot find \"%s\" library. Line %d in tab %s%n" , entry , impstat . getLineNumber ( ) , editor . getSketch ( ) . getCode ( impstat . getTab ( ) ) . getPrettyName ( ) ) ; } } else { new Exception ( "Error while handling '" + entry + "'" , e ) . printStackTrace ( ) ; } } } } new Thread ( new Runnable ( ) { public void run ( ) { astGenerator . loadJars ( ) ; } } ) . start ( ) ; } protected boolean ignorableImport ( String packageName ) { return ( packageName . startsWith ( "java." ) || packageName . startsWith ( "javax." ) ) ; } protected Map < String , String > compilerSettings ; protected void prepareCompilerSetting ( ) { compilerSettings = new HashMap < String , String > ( ) ; compilerSettings . put ( CompilerOptions . OPTION_LineNumberAttribute , CompilerOptions . GENERATE ) ; compilerSettings . put ( CompilerOptions . OPTION_SourceFileAttribute , CompilerOptions . GENERATE ) ; compilerSettings . put ( CompilerOptions . OPTION_Source , CompilerOptions . VERSION_1_8 ) ; compilerSettings . put ( CompilerOptions . OPTION_ReportUnusedImport , CompilerOptions . IGNORE ) ; compilerSettings . put ( CompilerOptions . OPTION_ReportMissingSerialVersion , CompilerOptions . IGNORE ) ; compilerSettings . put ( CompilerOptions . OPTION_ReportRawTypeReference , CompilerOptions . IGNORE ) ; compilerSettings . put ( CompilerOptions . OPTION_ReportUncheckedTypeOperation , CompilerOptions . IGNORE ) ; } public void updateErrorTable ( ) { try { String [ ] [ ] errorData = new String [ problemsList . size ( ) ] [ 3 ] ; for ( int i = 0 ; i < problemsList . size ( ) ; i ++ ) { errorData [ i ] [ 0 ] = problemsList . get ( i ) . getMessage ( ) ; errorData [ i ] [ 1 ] = editor . getSketch ( ) . getCode ( problemsList . get ( i ) . getTabIndex ( ) ) . getPrettyName ( ) ; errorData [ i ] [ 2 ] = ( problemsList . get ( i ) . getLineNumber ( ) + 1 ) + "" ; if ( tempErrorLog . size ( ) < 200 ) tempErrorLog . put ( problemsList . get ( i ) . getMessage ( ) , problemsList . get ( i ) . getIProblem ( ) ) ; if ( JavaMode . importSuggestEnabled ) { Problem p = problemsList . get ( i ) ; if ( p . getIProblem ( ) . getID ( ) == IProblem . UndefinedType ) { String args [ ] = p . getIProblem ( ) . getArguments ( ) ; if ( args . length > 0 ) { String missingClass = args [ 0 ] ; String [ ] si = astGenerator . getSuggestImports ( missingClass ) ; if ( si != null && si . length > 0 ) { p . setImportSuggestions ( si ) ; errorData [ i ] [ 0 ] = "<html>" + problemsList . get ( i ) . getMessage ( ) + " (<font color=#0000ff><u>Import Suggestions available</u></font>)</html>" ; } } } } } DefaultTableModel tm = new DefaultTableModel ( errorData , XQErrorTable . columnNames ) ; editor . updateTable ( tm ) ; } catch ( Exception e ) { Base . log ( "Exception at updateErrorTable() " + e ) ; e . printStackTrace ( ) ; pauseThread ( ) ; } } public void updatePaintedThingys ( ) { currentTab = editor . getSketch ( ) . getCodeIndex ( editor . getSketch ( ) . getCurrentCode ( ) ) ; if ( currentTab != lastTab ) { textModified . set ( 5 ) ; lastTab = currentTab ; editor . getTextArea ( ) . repaint ( ) ; editor . statusEmpty ( ) ; return ; } } protected int lastCaretLine = - 1 ; public void updateEditorStatus ( ) { if ( editor . getStatusMode ( ) == EditorStatus . EDIT ) return ; if ( JavaMode . errorCheckEnabled ) { synchronized ( editor . getErrorPoints ( ) ) { for ( ErrorMarker emarker : editor . getErrorPoints ( ) ) { if ( emarker . getProblem ( ) . getLineNumber ( ) == editor . getTextArea ( ) . getCaretLine ( ) ) { if ( emarker . getType ( ) == ErrorMarker . Warning ) { editor . statusMessage ( emarker . getProblem ( ) . getMessage ( ) , JavaEditor . STATUS_INFO ) ; } else { editor . statusMessage ( emarker . getProblem ( ) . getMessage ( ) , JavaEditor . STATUS_COMPILER_ERR ) ; } return ; } } } } if ( editor . statusMessageType == JavaEditor . STATUS_COMPILER_ERR ) { editor . statusEmpty ( ) ; return ; } } public int [ ] JavaToPdeOffsets ( int line , int offset ) { int codeIndex = 0 ; int x = line - mainClassOffset ; if ( x < 0 ) { x = line - 2 ; if ( x < programImports . size ( ) && x >= 0 ) { ImportStatement is = programImports . get ( x ) ; return new int [ ] { is . getTab ( ) , is . getLineNumber ( ) } ; } else { return new int [ ] { 0 , 1 } ; } } try { for ( SketchCode sc : editor . getSketch ( ) . getCode ( ) ) { if ( sc . isExtension ( "pde" ) ) { int len = 0 ; if ( editor . getSketch ( ) . getCurrentCode ( ) . equals ( sc ) ) { len = Base . countLines ( sc . getDocument ( ) . getText ( 0 , sc . getDocument ( ) . getLength ( ) ) ) + 1 ; } else { len = Base . countLines ( sc . getProgram ( ) ) + 1 ; } if ( x >= len ) { if ( codeIndex >= editor . getSketch ( ) . getCodeCount ( ) - 1 ) { x = editor . getSketch ( ) . getCode ( codeIndex ) . getLineCount ( ) ; break ; } else { x -= len ; codeIndex ++ ; } } else { if ( codeIndex >= editor . getSketch ( ) . getCodeCount ( ) ) { codeIndex = editor . getSketch ( ) . getCodeCount ( ) - 1 ; } break ; } } } } catch ( Exception e ) { System . err . println ( "Things got messed up in ErrorCheckerService.JavaToPdeOffset()" ) ; } return new int [ ] { codeIndex , x } ; } public String getPDECodeAtLine ( int tab , int linenumber ) { if ( linenumber < 0 ) return null ; editor . getSketch ( ) . setCurrentCode ( tab ) ; return editor . getTextArea ( ) . getLineText ( linenumber ) ; } public int [ ] calculateTabIndexAndLineNumber ( int javalineNumber ) { int codeIndex = 0 ; int x = javalineNumber - mainClassOffset ; if ( x < 0 ) { x = javalineNumber - 2 ; if ( x < programImports . size ( ) && x >= 0 ) { ImportStatement is = programImports . get ( x ) ; return new int [ ] { is . getTab ( ) , is . getLineNumber ( ) } ; } else { return new int [ ] { 0 , 1 } ; } } try { for ( SketchCode sc : editor . getSketch ( ) . getCode ( ) ) { if ( sc . isExtension ( "pde" ) ) { int len = 0 ; if ( editor . getSketch ( ) . getCurrentCode ( ) . equals ( sc ) ) { len = Base . countLines ( sc . getDocument ( ) . getText ( 0 , sc . getDocument ( ) . getLength ( ) ) ) + 1 ; } else { len = Base . countLines ( sc . getProgram ( ) ) + 1 ; } if ( x >= len ) { if ( codeIndex >= editor . getSketch ( ) . getCodeCount ( ) - 1 ) { x = editor . getSketch ( ) . getCode ( codeIndex ) . getLineCount ( ) ; break ; } else { x -= len ; codeIndex ++ ; } } else { if ( codeIndex >= editor . getSketch ( ) . getCodeCount ( ) ) { codeIndex = editor . getSketch ( ) . getCodeCount ( ) - 1 ; } break ; } } } } catch ( Exception e ) { System . err . println ( "Things got messed up in ErrorCheckerService.calculateTabIndexAndLineNumber()" ) ; } return new int [ ] { codeIndex , x } ; } public int getJavaLineNumFromPDElineNum ( int tab , int pdeLineNum ) { int jLineNum = programImports . size ( ) + 1 ; for ( int i = 0 ; i < tab ; i ++ ) { SketchCode sc = editor . getSketch ( ) . getCode ( i ) ; int len = Base . countLines ( sc . getProgram ( ) ) + 1 ; jLineNum += len ; } return jLineNum ; } protected String preprocessCode ( String pdeCode ) { programImports = new ArrayList < ImportStatement > ( ) ; StringBuilder rawCode = new StringBuilder ( ) ; try { for ( SketchCode sc : editor . getSketch ( ) . getCode ( ) ) { if ( sc . isExtension ( "pde" ) ) { try { if ( editor . getSketch ( ) . getCurrentCode ( ) . equals ( sc ) ) { rawCode . append ( scrapImportStatements ( sc . getDocument ( ) . getText ( 0 , sc . getDocument ( ) . getLength ( ) ) , editor . getSketch ( ) . getCodeIndex ( sc ) ) ) ; } else { rawCode . append ( scrapImportStatements ( sc . getProgram ( ) , editor . getSketch ( ) . getCodeIndex ( sc ) ) ) ; } rawCode . append ( '\n' ) ; } catch ( Exception e ) { System . err . println ( "Exception in preprocessCode() - bigCode " + e . toString ( ) ) ; } rawCode . append ( '\n' ) ; } } } catch ( Exception e ) { Base . log ( "Exception in preprocessCode()" ) ; } String sourceAlt = rawCode . toString ( ) ; String dataTypeFunc [ ] = { "int" , "char" , "float" , "boolean" , "byte" } ; for ( String dataType : dataTypeFunc ) { String dataTypeRegexp = "\\b" + dataType + "\\s*\\(" ; Pattern pattern = Pattern . compile ( dataTypeRegexp ) ; Matcher matcher = pattern . matcher ( sourceAlt ) ; sourceAlt = matcher . replaceAll ( "PApplet.parse" + Character . toUpperCase ( dataType . charAt ( 0 ) ) + dataType . substring ( 1 ) + "(" ) ; } final String webColorRegexp = "#{1}[A-F|a-f|0-9]{6}\\W" ; Pattern webPattern = Pattern . compile ( webColorRegexp ) ; Matcher webMatcher = webPattern . matcher ( sourceAlt ) ; while ( webMatcher . find ( ) ) { String found = sourceAlt . substring ( webMatcher . start ( ) , webMatcher . end ( ) ) ; sourceAlt = webMatcher . replaceFirst ( "0xff" + found . substring ( 1 ) ) ; webMatcher = webPattern . matcher ( sourceAlt ) ; } final String colorTypeRegex = "color(?![a-zA-Z0-9_])(?=\\[*)(?!(\\s*\\())" ; Pattern colorPattern = Pattern . compile ( colorTypeRegex ) ; Matcher colorMatcher = colorPattern . matcher ( sourceAlt ) ; sourceAlt = colorMatcher . replaceAll ( "int" ) ; checkForChangedImports ( ) ; className = ( editor == null ) ? "DefaultClass" : editor . getSketch ( ) . getName ( ) ; Matcher matcher = FUNCTION_DECL . matcher ( sourceAlt ) ; if ( ! matcher . find ( ) ) { sourceAlt = xqpreproc . prepareImports ( programImports ) + "public class " + className + " extends PApplet {\n" + "public void setup() {\n" + sourceAlt + "\nnoLoop();\n}\n" + "\n}\n" ; staticMode = true ; } else { sourceAlt = xqpreproc . prepareImports ( programImports ) + "public class " + className + " extends PApplet {\n" + sourceAlt + "\n}" ; staticMode = false ; } int position = sourceAlt . indexOf ( "{" ) + 1 ; mainClassOffset = 1 ; for ( int i = 0 ; i <= position ; i ++ ) { if ( sourceAlt . charAt ( i ) == '\n' ) { mainClassOffset ++ ; } } if ( staticMode ) { mainClassOffset ++ ; } sourceAlt = substituteUnicode ( sourceAlt ) ; sourceCode = sourceAlt ; return sourceAlt ; } private boolean highlightNode ( ASTNodeWrapper awrap ) { Base . log ( "Highlighting: " + awrap ) ; try { int pdeoffsets [ ] = awrap . getPDECodeOffsets ( this ) ; int javaoffsets [ ] = awrap . getJavaCodeOffsets ( this ) ; Base . log ( "offsets: " + pdeoffsets [ 0 ] + "," + pdeoffsets [ 1 ] + "," + javaoffsets [ 1 ] + "," + javaoffsets [ 2 ] ) ; scrollToErrorLine ( editor , pdeoffsets [ 0 ] , pdeoffsets [ 1 ] , javaoffsets [ 1 ] , javaoffsets [ 2 ] ) ; return true ; } catch ( Exception e ) { Base . loge ( "Scrolling failed for " + awrap ) ; } return false ; } public boolean highlightNode ( ASTNode node ) { ASTNodeWrapper awrap = new ASTNodeWrapper ( node ) ; return highlightNode ( awrap ) ; } public void scrollToErrorLine ( int errorIndex ) { if ( editor == null ) { return ; } if ( errorIndex < problemsList . size ( ) && errorIndex >= 0 ) { Problem p = problemsList . get ( errorIndex ) ; scrollToErrorLine ( p ) ; } } public void scrollToErrorLine ( Problem p ) { if ( editor == null ) { return ; } if ( p == null ) return ; try { if ( p . getPDELineStartOffset ( ) == - 1 || p . getPDELineStopOffset ( ) == - 1 ) { editor . toFront ( ) ; editor . getSketch ( ) . setCurrentCode ( p . getTabIndex ( ) ) ; } else { astGenerator . highlightPDECode ( p . getTabIndex ( ) , p . getLineNumber ( ) , p . getPDELineStartOffset ( ) , ( p . getPDELineStopOffset ( ) - p . getPDELineStartOffset ( ) + 1 ) ) ; } final Document doc = editor . getTextArea ( ) . getDocument ( ) ; final int lineCount = Base . countLines ( doc . getText ( 0 , doc . getLength ( ) ) ) ; if ( p . getLineNumber ( ) < lineCount && p . getLineNumber ( ) >= 0 ) { editor . getTextArea ( ) . scrollTo ( p . getLineNumber ( ) , 0 ) ; } editor . repaint ( ) ; } catch ( Exception e ) { Base . loge ( "Error while selecting text in scrollToErrorLine(), for problem: " + p , e ) ; } } public static boolean scrollToErrorLine ( Editor edt , int tabIndex , int lineNoInTab , int lineStartOffset , int length ) { if ( edt == null ) { return false ; } try { edt . toFront ( ) ; edt . getSketch ( ) . setCurrentCode ( tabIndex ) ; int lsno = edt . getTextArea ( ) . getLineStartNonWhiteSpaceOffset ( lineNoInTab - 1 ) + lineStartOffset ; edt . setSelection ( lsno , lsno + length ) ; edt . getTextArea ( ) . scrollTo ( lineNoInTab - 1 , 0 ) ; edt . repaint ( ) ; Base . log ( lineStartOffset + " LSO,len " + length ) ; } catch ( Exception e ) { System . err . println ( e + " : Error while selecting text in static scrollToErrorLine()" ) ; e . printStackTrace ( ) ; return false ; } return true ; } protected void checkForChangedImports ( ) { if ( programImports . size ( ) != previousImports . size ( ) ) { loadCompClass = true ; previousImports = programImports ; } else { for ( int i = 0 ; i < programImports . size ( ) ; i ++ ) { if ( ! programImports . get ( i ) . getImportName ( ) . equals ( previousImports . get ( i ) . getImportName ( ) ) ) { loadCompClass = true ; previousImports = programImports ; break ; } } } } protected int pdeImportsCount ; public int getPdeImportsCount ( ) { return pdeImportsCount ; } protected String scrapImportStatements ( String tabProgram , int tabNumber ) { pdeImportsCount = 0 ; String tabSource = new String ( tabProgram ) ; do { String [ ] pieces = PApplet . match ( tabSource , importRegexp ) ; if ( pieces == null ) { break ; } String piece = pieces [ 1 ] + pieces [ 2 ] + pieces [ 3 ] ; int len = piece . length ( ) ; int idx = tabSource . indexOf ( piece ) ; programImports . add ( new ImportStatement ( piece , tabNumber , Base . countLines ( tabSource . substring ( 0 , idx ) ) ) ) ; String whiteSpace = "" ; for ( int j = 0 ; j < piece . length ( ) ; j ++ ) { whiteSpace += " " ; } tabSource = tabSource . substring ( 0 , idx ) + whiteSpace + tabSource . substring ( idx + len ) ; pdeImportsCount ++ ; } while ( true ) ; return tabSource ; } public static String substituteUnicode ( String program ) { char p [ ] = program . toCharArray ( ) ; int unicodeCount = 0 ; for ( int i = 0 ; i < p . length ; i ++ ) { if ( p [ i ] > 127 ) { unicodeCount ++ ; } } if ( unicodeCount == 0 ) { return program ; } int index = 0 ; char p2 [ ] = new char [ p . length + unicodeCount * 5 ] ; for ( int i = 0 ; i < p . length ; i ++ ) { if ( p [ i ] < 128 ) { p2 [ index ++ ] = p [ i ] ; } else if ( p [ i ] == 160 ) { p2 [ index ++ ] = ' ' ; } else { int c = p [ i ] ; p2 [ index ++ ] = '\\' ; p2 [ index ++ ] = 'u' ; char str [ ] = Integer . toHexString ( c ) . toCharArray ( ) ; for ( int m = 0 ; m < 4 - str . length ; m ++ ) p2 [ index ++ ] = '0' ; System . arraycopy ( str , 0 , p2 , index , str . length ) ; index += str . length ; } } return new String ( p2 , 0 , index ) ; } public void handleErrorCheckingToggle ( ) { if ( ! JavaMode . errorCheckEnabled ) { Base . log ( editor . getSketch ( ) . getName ( ) + " - Error Checker paused." ) ; editor . getErrorPoints ( ) . clear ( ) ; problemsList . clear ( ) ; updateErrorTable ( ) ; updateEditorStatus ( ) ; editor . getTextArea ( ) . repaint ( ) ; editor . repaintErrorBar ( ) ; } else { Base . log ( editor . getSketch ( ) . getName ( ) + " - Error Checker resumed." ) ; runManualErrorCheck ( ) ; } } public void stopThread ( ) { Base . loge ( "Stopping thread: " + editor . getSketch ( ) . getName ( ) ) ; stopThread . set ( true ) ; } public void pauseThread ( ) { pauseThread . set ( true ) ; } public void resumeThread ( ) { pauseThread . set ( false ) ; } public JavaEditor getEditor ( ) { return editor ; } public ArrayList < ImportStatement > getProgramImports ( ) { return programImports ; } }
package processing . mode . java . pdex ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLClassLoader ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . StringTokenizer ; import org . eclipse . jdt . core . JavaCore ; import org . eclipse . jdt . core . compiler . CharOperation ; import org . eclipse . jdt . core . compiler . IProblem ; import org . eclipse . jdt . core . dom . AST ; import org . eclipse . jdt . core . dom . ASTParser ; import org . eclipse . jdt . core . dom . CompilationUnit ; import org . eclipse . jdt . core . dom . PackageDeclaration ; import org . eclipse . jdt . core . dom . TypeDeclaration ; import org . eclipse . jdt . internal . compiler . ClassFile ; import org . eclipse . jdt . internal . compiler . CompilationResult ; import org . eclipse . jdt . internal . compiler . Compiler ; import org . eclipse . jdt . internal . compiler . DefaultErrorHandlingPolicies ; import org . eclipse . jdt . internal . compiler . ICompilerRequestor ; import org . eclipse . jdt . internal . compiler . classfmt . ClassFileReader ; import org . eclipse . jdt . internal . compiler . classfmt . ClassFormatException ; import org . eclipse . jdt . internal . compiler . env . ICompilationUnit ; import org . eclipse . jdt . internal . compiler . env . INameEnvironment ; import org . eclipse . jdt . internal . compiler . env . NameEnvironmentAnswer ; import org . eclipse . jdt . internal . compiler . impl . CompilerOptions ; import org . eclipse . jdt . internal . compiler . problem . DefaultProblemFactory ; import org . eclipse . jface . text . Document ; public class CompilationChecker { private class CompilationUnitImpl implements ICompilationUnit { private CompilationUnit unit ; CompilationUnitImpl ( CompilationUnit unit ) { this . unit = unit ; } public char [ ] getContents ( ) { char [ ] contents = null ; try { Document doc = new Document ( ) ; doc . set ( sourceText ) ; String sourceCode = doc . get ( ) ; if ( sourceCode != null ) contents = sourceCode . toCharArray ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return contents ; } public char [ ] getMainTypeName ( ) { TypeDeclaration classType = ( TypeDeclaration ) unit . types ( ) . get ( 0 ) ; return classType . getName ( ) . getFullyQualifiedName ( ) . toCharArray ( ) ; } public char [ ] [ ] getPackageName ( ) { String [ ] names = getSimpleNames ( this . unit . getPackage ( ) . getName ( ) . getFullyQualifiedName ( ) ) ; char [ ] [ ] packages = new char [ names . length ] [ ] ; for ( int i = 0 ; i < names . length ; ++ i ) packages [ i ] = names [ i ] . toCharArray ( ) ; return packages ; } public char [ ] getFileName ( ) { TypeDeclaration classType = ( TypeDeclaration ) unit . types ( ) . get ( 0 ) ; String name = classType . getName ( ) . getFullyQualifiedName ( ) + ".java" ; return name . toCharArray ( ) ; } @ Override public boolean ignoreOptionalProblems ( ) { return false ; } } private class CompileRequestorImpl implements ICompilerRequestor { private List < IProblem > problems ; private List < ClassFile > classes ; public CompileRequestorImpl ( ) { this . problems = new ArrayList < IProblem > ( ) ; this . classes = new ArrayList < ClassFile > ( ) ; } public void acceptResult ( CompilationResult result ) { boolean errors = false ; if ( result . hasProblems ( ) ) { IProblem [ ] problems = result . getProblems ( ) ; for ( int i = 0 ; i < problems . length ; i ++ ) { if ( problems [ i ] . isError ( ) ) errors = true ; this . problems . add ( problems [ i ] ) ; } } if ( ! errors ) { ClassFile [ ] classFiles = result . getClassFiles ( ) ; for ( int i = 0 ; i < classFiles . length ; i ++ ) this . classes . add ( classFiles [ i ] ) ; } } List < IProblem > getProblems ( ) { return this . problems ; } } private class NameEnvironmentImpl implements INameEnvironment { private ICompilationUnit unit ; private String fullName ; NameEnvironmentImpl ( ICompilationUnit unit ) { this . unit = unit ; this . fullName = CharOperation . toString ( this . unit . getPackageName ( ) ) + "." + new String ( this . unit . getMainTypeName ( ) ) ; } public NameEnvironmentAnswer findType ( char [ ] [ ] compoundTypeName ) { return findType ( CharOperation . toString ( compoundTypeName ) ) ; } public NameEnvironmentAnswer findType ( char [ ] typeName , char [ ] [ ] packageName ) { String fullName = CharOperation . toString ( packageName ) ; if ( typeName != null ) { if ( fullName . length ( ) > 0 ) fullName += "." ; fullName += new String ( typeName ) ; } return findType ( fullName ) ; } public boolean isPackage ( char [ ] [ ] parentPackageName , char [ ] packageName ) { String fullName = CharOperation . toString ( parentPackageName ) ; if ( packageName != null ) { if ( fullName . length ( ) > 0 ) fullName += "." ; fullName += new String ( packageName ) ; } if ( findType ( fullName ) != null ) return false ; try { return ( getClassLoader ( ) . loadClass ( fullName ) == null ) ; } catch ( ClassNotFoundException e ) { return true ; } } public void cleanup ( ) { } private NameEnvironmentAnswer findType ( String fullName ) { if ( this . fullName . equals ( fullName ) ) return new NameEnvironmentAnswer ( unit , null ) ; try { InputStream is = getClassLoader ( ) . getResourceAsStream ( fullName . replace ( '.' , '/' ) + ".class" ) ; if ( is != null ) { byte [ ] buffer = new byte [ 8192 ] ; int bytes = 0 ; ByteArrayOutputStream os = new ByteArrayOutputStream ( buffer . length ) ; while ( ( bytes = is . read ( buffer , 0 , buffer . length ) ) > 0 ) os . write ( buffer , 0 , bytes ) ; os . flush ( ) ; ClassFileReader classFileReader = new ClassFileReader ( os . toByteArray ( ) , fullName . toCharArray ( ) , true ) ; return new NameEnvironmentAnswer ( classFileReader , null ) ; } return null ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } catch ( ClassFormatException e ) { throw new RuntimeException ( e ) ; } } } private URLClassLoader urlClassLoader ; private ClassLoader getClassLoader ( ) { if ( urlClassLoader != null ) { return urlClassLoader ; } else { return getClass ( ) . getClassLoader ( ) ; } } private void prepareClassLoader ( ArrayList < File > jarList ) { URL urls [ ] = new URL [ jarList . size ( ) ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { try { urls [ i ] = jarList . get ( i ) . toURI ( ) . toURL ( ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } } urlClassLoader = new URLClassLoader ( urls ) ; } @ SuppressWarnings ( "unchecked" ) private ICompilationUnit generateCompilationUnit ( ) { ASTParser parser = ASTParser . newParser ( AST . JLS8 ) ; try { parser . setSource ( "" . toCharArray ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } Map < String , String > options = JavaCore . getOptions ( ) ; JavaCore . setComplianceOptions ( JavaCore . VERSION_1_8 , options ) ; parser . setCompilerOptions ( options ) ; CompilationUnit unit = ( CompilationUnit ) parser . createAST ( null ) ; unit . recordModifications ( ) ; AST ast = unit . getAST ( ) ; PackageDeclaration packageDeclaration = ast . newPackageDeclaration ( ) ; unit . setPackage ( packageDeclaration ) ; packageDeclaration . setName ( ast . newSimpleName ( fileName ) ) ; TypeDeclaration classType = ast . newTypeDeclaration ( ) ; classType . setInterface ( false ) ; classType . setName ( ast . newSimpleName ( fileName ) ) ; unit . types ( ) . add ( classType ) ; return new CompilationUnitImpl ( unit ) ; } static private String fileName = null ; private void compileMeQuitely ( ICompilationUnit unit , Map < String , String > compilerSettings ) { Map < String , String > settings ; if ( compilerSettings == null ) { settings = new HashMap < > ( ) ; settings . put ( CompilerOptions . OPTION_LineNumberAttribute , CompilerOptions . GENERATE ) ; settings . put ( CompilerOptions . OPTION_SourceFileAttribute , CompilerOptions . GENERATE ) ; settings . put ( CompilerOptions . OPTION_Source , CompilerOptions . VERSION_1_6 ) ; settings . put ( CompilerOptions . OPTION_SuppressWarnings , CompilerOptions . DISABLED ) ; } else { settings = compilerSettings ; } CompileRequestorImpl requestor = new CompileRequestorImpl ( ) ; Compiler compiler = new Compiler ( new NameEnvironmentImpl ( unit ) , DefaultErrorHandlingPolicies . proceedWithAllProblems ( ) , new CompilerOptions ( settings ) , requestor , new DefaultProblemFactory ( Locale . getDefault ( ) ) ) ; compiler . compile ( new ICompilationUnit [ ] { unit } ) ; List < IProblem > problems = requestor . getProblems ( ) ; prob = new IProblem [ problems . size ( ) ] ; int count = 0 ; for ( Iterator < IProblem > it = problems . iterator ( ) ; it . hasNext ( ) ; ) { IProblem problem = it . next ( ) ; prob [ count ++ ] = problem ; } } private void compileMeQuitely ( ICompilationUnit unit ) { compileMeQuitely ( unit , null ) ; } static private String [ ] getSimpleNames ( String qualifiedName ) { StringTokenizer st = new StringTokenizer ( qualifiedName , "." ) ; ArrayList < String > list = new ArrayList < String > ( ) ; while ( st . hasMoreTokens ( ) ) { String name = st . nextToken ( ) . trim ( ) ; if ( ! name . equals ( "*" ) ) list . add ( name ) ; } return list . toArray ( new String [ 0 ] ) ; } public static void main ( String [ ] args ) { ArrayList < File > fl = new ArrayList < File > ( ) ; fl . add ( new File ( "/home/quarkninja/Workspaces/processing_workspace/processing/core/library/core.jar" ) ) ; CompilationChecker cc = new CompilationChecker ( fl ) ; cc . getErrors ( "Brightness" ) ; cc . display ( ) ; } public void display ( ) { boolean error = false ; int errorCount = 0 , warningCount = 0 , count = 0 ; for ( int i = 0 ; i < prob . length ; i ++ ) { IProblem problem = prob [ i ] ; if ( problem == null ) continue ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( problem . getMessage ( ) ) ; sb . append ( " | line: " ) ; sb . append ( problem . getSourceLineNumber ( ) ) ; String msg = sb . toString ( ) ; if ( problem . isError ( ) ) { error = true ; msg = "Error: " + msg ; errorCount ++ ; } else if ( problem . isWarning ( ) ) { msg = "Warning: " + msg ; warningCount ++ ; } System . out . println ( msg ) ; prob [ count ++ ] = problem ; } if ( ! error ) { System . out . println ( "====================================" ) ; System . out . println ( " Compiled without any errors. " ) ; System . out . println ( "====================================" ) ; } else { System . out . println ( "====================================" ) ; System . out . println ( " Compilation failed. You erred man! " ) ; System . out . println ( "====================================" ) ; } System . out . print ( "Total warnings: " + warningCount ) ; System . out . println ( ", Total errors: " + errorCount ) ; } IProblem [ ] prob ; public IProblem [ ] getErrors ( String name ) { fileName = name ; compileMeQuitely ( generateCompilationUnit ( ) ) ; return prob ; } public IProblem [ ] getErrors ( String sourceName , String source , Map < String , String > settings , URLClassLoader classLoader ) { fileName = sourceName ; sourceText = "package " + fileName + ";\n" + source ; if ( classLoader != null ) this . urlClassLoader = classLoader ; compileMeQuitely ( generateCompilationUnit ( ) , settings ) ; return prob ; } String sourceText = null ; public IProblem [ ] getErrors ( String sourceName , String source ) { return getErrors ( sourceName , source , null ) ; } public IProblem [ ] getErrors ( String sourceName , String source , Map < String , String > settings ) { fileName = sourceName ; sourceText = "package " + fileName + ";\n" + source ; compileMeQuitely ( generateCompilationUnit ( ) , settings ) ; return prob ; } public CompilationChecker ( ) { } public CompilationChecker ( ArrayList < File > fileList ) { prepareClassLoader ( fileList ) ; } }
package processing . mode . java . debug ; import com . sun . jdi . ArrayReference ; import com . sun . jdi . ClassNotLoadedException ; import com . sun . jdi . InvalidTypeException ; import com . sun . jdi . Value ; import java . util . logging . Level ; import java . util . logging . Logger ; public class ArrayFieldNode extends VariableNode { protected ArrayReference array ; protected int index ; public ArrayFieldNode ( String name , String type , Value value , ArrayReference array , int index ) { super ( name , type , value ) ; this . array = array ; this . index = index ; } @ Override public void setValue ( Value value ) { try { array . setValue ( index , value ) ; } catch ( InvalidTypeException ex ) { Logger . getLogger ( ArrayFieldNode . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ClassNotLoadedException ex ) { Logger . getLogger ( ArrayFieldNode . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } this . value = value ; } }
package processing . mode . java . debug ; import com . sun . jdi . ReferenceType ; public interface ClassLoadListener { public void classLoaded ( ReferenceType theClass ) ; }
package processing . mode . java . debug ; import java . util . HashSet ; import java . util . Set ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . swing . event . DocumentEvent ; import javax . swing . event . DocumentListener ; import javax . swing . text . BadLocationException ; import javax . swing . text . Document ; import javax . swing . text . Element ; import javax . swing . text . Position ; public class LineID implements DocumentListener { protected String fileName ; protected int lineIdx ; protected Document doc ; protected Position pos ; protected Set < LineHighlight > listeners = new HashSet < LineHighlight > ( ) ; public LineID ( String fileName , int lineIdx ) { this . fileName = fileName ; this . lineIdx = lineIdx ; } public String fileName ( ) { return fileName ; } public synchronized int lineIdx ( ) { return lineIdx ; } @ Override public int hashCode ( ) { return toString ( ) . hashCode ( ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final LineID other = ( LineID ) obj ; if ( ( this . fileName == null ) ? ( other . fileName != null ) : ! this . fileName . equals ( other . fileName ) ) { return false ; } if ( this . lineIdx != other . lineIdx ) { return false ; } return true ; } @ Override public String toString ( ) { return fileName + ":" + ( lineIdx + 1 ) ; } public synchronized void startTracking ( Document doc ) { if ( doc == null ) { return ; } if ( doc == this . doc ) { return ; } try { Element line = doc . getDefaultRootElement ( ) . getElement ( lineIdx ) ; if ( line == null ) { return ; } String lineText = doc . getText ( line . getStartOffset ( ) , line . getEndOffset ( ) - line . getStartOffset ( ) ) ; pos = doc . createPosition ( line . getStartOffset ( ) + nonWhiteSpaceOffset ( lineText ) ) ; this . doc = doc ; doc . addDocumentListener ( this ) ; } catch ( BadLocationException ex ) { Logger . getLogger ( LineID . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; pos = null ; this . doc = null ; } } public synchronized void stopTracking ( ) { if ( doc != null ) { doc . removeDocumentListener ( this ) ; doc = null ; } } protected synchronized void updatePosition ( ) { if ( doc != null && pos != null ) { int offset = pos . getOffset ( ) ; int oldLineIdx = lineIdx ; lineIdx = doc . getDefaultRootElement ( ) . getElementIndex ( offset ) ; if ( lineIdx != oldLineIdx ) { for ( LineHighlight l : listeners ) { if ( l != null ) { l . lineChanged ( this , oldLineIdx , lineIdx ) ; } else { listeners . remove ( l ) ; } } } } } public void addListener ( LineHighlight l ) { listeners . add ( l ) ; } public void removeListener ( LineHighlight l ) { listeners . remove ( l ) ; } protected static int nonWhiteSpaceOffset ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! Character . isWhitespace ( str . charAt ( i ) ) ) { return i ; } } return str . length ( ) ; } protected void editEvent ( DocumentEvent de ) { if ( de . getOffset ( ) <= pos . getOffset ( ) ) { updatePosition ( ) ; } } @ Override public void insertUpdate ( DocumentEvent de ) { editEvent ( de ) ; } @ Override public void removeUpdate ( DocumentEvent de ) { editEvent ( de ) ; } @ Override public void changedUpdate ( DocumentEvent de ) { } }
package processing . mode . java . debug ; import java . awt . Color ; import java . util . HashSet ; import java . util . Set ; import processing . mode . java . JavaEditor ; public class LineHighlight { protected JavaEditor editor ; protected Color bgColor ; protected LineID lineID ; protected String marker ; protected Color markerColor ; protected int priority = 0 ; protected static Set < LineHighlight > allHighlights = new HashSet < LineHighlight > ( ) ; public LineHighlight ( LineID lineID , Color bgColor , JavaEditor editor ) { this . lineID = lineID ; this . bgColor = bgColor ; this . editor = editor ; lineID . addListener ( this ) ; lineID . startTracking ( editor . getTab ( lineID . fileName ( ) ) . getDocument ( ) ) ; paint ( ) ; allHighlights . add ( this ) ; } protected static boolean isHighestPriority ( LineHighlight hl ) { for ( LineHighlight check : allHighlights ) { if ( check . getLineID ( ) . equals ( hl . getLineID ( ) ) && check . priority ( ) > hl . priority ( ) ) { return false ; } } return true ; } public void setPriority ( int p ) { this . priority = p ; } public int priority ( ) { return priority ; } public LineHighlight ( int lineIdx , Color bgColor , JavaEditor editor ) { this ( editor . getLineIDInCurrentTab ( lineIdx ) , bgColor , editor ) ; } public void setMarker ( String marker ) { this . marker = marker ; paint ( ) ; } public void setMarker ( String marker , Color markerColor ) { this . markerColor = markerColor ; setMarker ( marker ) ; } public LineID getLineID ( ) { return lineID ; } public Color getColor ( ) { return bgColor ; } public boolean isOnLine ( LineID testLine ) { return lineID . equals ( testLine ) ; } public void lineChanged ( LineID line , int oldLineIdx , int newLineIdx ) { if ( editor . isInCurrentTab ( new LineID ( line . fileName ( ) , oldLineIdx ) ) ) { editor . getJavaTextArea ( ) . clearLineBgColor ( oldLineIdx ) ; editor . getJavaTextArea ( ) . clearGutterText ( oldLineIdx ) ; } if ( LineHighlight . isHighestPriority ( this ) ) { paint ( ) ; } } public void dispose ( ) { lineID . removeListener ( this ) ; lineID . stopTracking ( ) ; allHighlights . remove ( this ) ; } public void paint ( ) { if ( editor . isInCurrentTab ( lineID ) ) { editor . getJavaTextArea ( ) . setLineBgColor ( lineID . lineIdx ( ) , bgColor ) ; if ( marker != null ) { if ( markerColor != null ) { editor . getJavaTextArea ( ) . setGutterText ( lineID . lineIdx ( ) , marker , markerColor ) ; } else { editor . getJavaTextArea ( ) . setGutterText ( lineID . lineIdx ( ) , marker ) ; } } } } public void clear ( ) { if ( editor . isInCurrentTab ( lineID ) ) { editor . getJavaTextArea ( ) . clearLineBgColor ( lineID . lineIdx ( ) ) ; editor . getJavaTextArea ( ) . clearGutterText ( lineID . lineIdx ( ) ) ; } } }
package processing . mode . java . debug ; import java . util . List ; import java . util . logging . Level ; import java . util . logging . Logger ; import processing . app . Base ; import processing . mode . java . Debugger ; import com . sun . jdi . AbsentInformationException ; import com . sun . jdi . Location ; import com . sun . jdi . ReferenceType ; import com . sun . jdi . request . BreakpointRequest ; public class LineBreakpoint implements ClassLoadListener { protected Debugger dbg ; protected LineID line ; protected BreakpointRequest bpr ; protected ReferenceType theClass ; public LineBreakpoint ( LineID line , Debugger dbg ) { this . line = line ; line . startTracking ( dbg . getEditor ( ) . getTab ( line . fileName ( ) ) . getDocument ( ) ) ; this . dbg = dbg ; theClass = dbg . getClass ( className ( ) ) ; set ( ) ; Logger . getLogger ( LineBreakpoint . class . getName ( ) ) . log ( Level . INFO , "LBP Created " + toString ( ) + " class: " + className ( ) , new Object [ ] { } ) ; } public LineBreakpoint ( int lineIdx , Debugger dbg ) { this ( dbg . getEditor ( ) . getLineIDInCurrentTab ( lineIdx ) , dbg ) ; } public LineID lineID ( ) { return line ; } public boolean isOnLine ( LineID testLine ) { return line . equals ( testLine ) ; } protected void attach ( ) { if ( ! dbg . isPaused ( ) ) { Logger . getLogger ( LineBreakpoint . class . getName ( ) ) . log ( Level . WARNING , "can't attach breakpoint, debugger not paused" ) ; return ; } if ( theClass == null ) { Logger . getLogger ( LineBreakpoint . class . getName ( ) ) . log ( Level . WARNING , "can't attach breakpoint, class not loaded: {0}" , className ( ) ) ; return ; } LineID javaLine = dbg . sketchToJavaLine ( line ) ; if ( javaLine == null ) { Logger . getLogger ( LineBreakpoint . class . getName ( ) ) . log ( Level . WARNING , "couldn't find line {0} in the java code" , line ) ; return ; } try { Logger . getLogger ( LineBreakpoint . class . getName ( ) ) . log ( Level . WARNING , "BPs of class: {0} , line " + ( javaLine . lineIdx ( ) + 1 ) , new Object [ ] { theClass } ) ; List < Location > locations = theClass . locationsOfLine ( javaLine . lineIdx ( ) + 1 ) ; if ( locations . isEmpty ( ) ) { Logger . getLogger ( LineBreakpoint . class . getName ( ) ) . log ( Level . WARNING , "no location found for line {0} -> {1}" , new Object [ ] { line , javaLine } ) ; return ; } bpr = dbg . vm ( ) . eventRequestManager ( ) . createBreakpointRequest ( locations . get ( 0 ) ) ; bpr . enable ( ) ; Logger . getLogger ( LineBreakpoint . class . getName ( ) ) . log ( Level . INFO , "attached breakpoint to {0} -> {1}" , new Object [ ] { line , javaLine } ) ; } catch ( AbsentInformationException ex ) { Logger . getLogger ( Debugger . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } protected void detach ( ) { if ( bpr != null ) { dbg . vm ( ) . eventRequestManager ( ) . deleteEventRequest ( bpr ) ; bpr = null ; } } protected void set ( ) { dbg . addClassLoadListener ( this ) ; dbg . getEditor ( ) . addBreakpointedLine ( line ) ; if ( theClass != null && dbg . isPaused ( ) ) { attach ( ) ; } if ( dbg . getEditor ( ) . isInCurrentTab ( line ) ) { dbg . getEditor ( ) . getSketch ( ) . setModified ( true ) ; } } public void remove ( ) { dbg . removeClassLoadListener ( this ) ; dbg . getEditor ( ) . removeBreakpointedLine ( line . lineIdx ( ) ) ; if ( dbg . isPaused ( ) ) { detach ( ) ; } line . stopTracking ( ) ; if ( dbg . getEditor ( ) . isInCurrentTab ( line ) ) { dbg . getEditor ( ) . getSketch ( ) . setModified ( true ) ; } } @ Override public String toString ( ) { return line . toString ( ) ; } protected String className ( ) { if ( line . fileName ( ) . endsWith ( ".pde" ) ) { ReferenceType mainClass = dbg . getMainClass ( ) ; if ( mainClass == null ) { return null ; } return dbg . getMainClass ( ) . name ( ) ; } if ( line . fileName ( ) . endsWith ( ".java" ) ) { return line . fileName ( ) . substring ( 0 , line . fileName ( ) . lastIndexOf ( ".java" ) ) ; } return null ; } @ Override public void classLoaded ( ReferenceType theClass ) { Base . log ( "Class Loaded: " + theClass . name ( ) ) ; if ( theClass . name ( ) . equals ( className ( ) ) ) { this . theClass = theClass ; attach ( ) ; } for ( ReferenceType ct : theClass . nestedTypes ( ) ) { Base . log ( "Nested " + ct . name ( ) ) ; } } }
package processing . mode . java . debug ; import com . sun . jdi . ArrayReference ; import com . sun . jdi . ObjectReference ; import com . sun . jdi . StringReference ; import com . sun . jdi . Value ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . List ; import javax . swing . tree . MutableTreeNode ; import javax . swing . tree . TreeNode ; public class VariableNode implements MutableTreeNode { public static final int TYPE_UNKNOWN = - 1 ; public static final int TYPE_OBJECT = 0 ; public static final int TYPE_ARRAY = 1 ; public static final int TYPE_INTEGER = 2 ; public static final int TYPE_FLOAT = 3 ; public static final int TYPE_BOOLEAN = 4 ; public static final int TYPE_CHAR = 5 ; public static final int TYPE_STRING = 6 ; public static final int TYPE_LONG = 7 ; public static final int TYPE_DOUBLE = 8 ; public static final int TYPE_BYTE = 9 ; public static final int TYPE_SHORT = 10 ; public static final int TYPE_VOID = 11 ; protected String type ; protected String name ; protected Value value ; protected List < MutableTreeNode > children = new ArrayList < MutableTreeNode > ( ) ; protected MutableTreeNode parent ; public VariableNode ( String name , String type , Value value ) { this . name = name ; this . type = type ; this . value = value ; } public void setValue ( Value value ) { this . value = value ; } public Value getValue ( ) { return value ; } public String getStringValue ( ) { String str ; if ( value != null ) { if ( getType ( ) == TYPE_OBJECT ) { str = "instance of " + type ; } else if ( getType ( ) == TYPE_ARRAY ) { str = value . toString ( ) . substring ( 0 , value . toString ( ) . lastIndexOf ( " " ) ) ; } else if ( getType ( ) == TYPE_STRING ) { str = ( ( StringReference ) value ) . value ( ) ; } else { str = value . toString ( ) ; } } else { str = "null" ; } return str ; } public String getTypeName ( ) { return type ; } public int getType ( ) { if ( type == null ) { return TYPE_UNKNOWN ; } if ( type . endsWith ( "[]" ) ) { return TYPE_ARRAY ; } if ( type . equals ( "int" ) ) { return TYPE_INTEGER ; } if ( type . equals ( "long" ) ) { return TYPE_LONG ; } if ( type . equals ( "byte" ) ) { return TYPE_BYTE ; } if ( type . equals ( "short" ) ) { return TYPE_SHORT ; } if ( type . equals ( "float" ) ) { return TYPE_FLOAT ; } if ( type . equals ( "double" ) ) { return TYPE_DOUBLE ; } if ( type . equals ( "char" ) ) { return TYPE_CHAR ; } if ( type . equals ( "java.lang.String" ) ) { return TYPE_STRING ; } if ( type . equals ( "boolean" ) ) { return TYPE_BOOLEAN ; } if ( type . equals ( "void" ) ) { return TYPE_VOID ; } return TYPE_OBJECT ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public void addChild ( VariableNode c ) { children . add ( c ) ; c . setParent ( this ) ; } public void addChildren ( List < VariableNode > children ) { for ( VariableNode child : children ) { addChild ( child ) ; } } @ Override public TreeNode getChildAt ( int i ) { return children . get ( i ) ; } @ Override public int getChildCount ( ) { return children . size ( ) ; } @ Override public TreeNode getParent ( ) { return parent ; } @ Override public int getIndex ( TreeNode tn ) { return children . indexOf ( tn ) ; } @ Override public boolean getAllowsChildren ( ) { if ( value == null ) { return false ; } if ( getType ( ) == TYPE_STRING ) { return false ; } if ( getType ( ) == TYPE_ARRAY ) { ArrayReference array = ( ArrayReference ) value ; return array . length ( ) > 0 ; } if ( getType ( ) == TYPE_OBJECT ) { ObjectReference obj = ( ObjectReference ) value ; return ! obj . referenceType ( ) . visibleFields ( ) . isEmpty ( ) ; } return false ; } @ Override public boolean isLeaf ( ) { return ! getAllowsChildren ( ) ; } @ Override public Enumeration < MutableTreeNode > children ( ) { return Collections . enumeration ( children ) ; } @ Override public String toString ( ) { return getName ( ) ; } public String getDescription ( ) { String str = "" ; if ( type != null ) { str += type + " " ; } str += name ; str += " = " + getStringValue ( ) ; return str ; } @ Override public void insert ( MutableTreeNode mtn , int i ) { children . add ( i , this ) ; } @ Override public void remove ( int i ) { MutableTreeNode mtn = children . remove ( i ) ; if ( mtn != null ) { mtn . setParent ( null ) ; } } @ Override public void remove ( MutableTreeNode mtn ) { children . remove ( mtn ) ; mtn . setParent ( null ) ; } public void removeAllChildren ( ) { for ( MutableTreeNode mtn : children ) { mtn . setParent ( null ) ; } children . clear ( ) ; } @ Override public void setUserObject ( Object o ) { if ( o instanceof Value ) { value = ( Value ) o ; } } @ Override public void removeFromParent ( ) { parent . remove ( this ) ; this . parent = null ; } @ Override public void setParent ( MutableTreeNode mtn ) { parent = mtn ; } @ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final VariableNode other = ( VariableNode ) obj ; if ( ( this . type == null ) ? ( other . type != null ) : ! this . type . equals ( other . type ) ) { return false ; } if ( ( this . name == null ) ? ( other . name != null ) : ! this . name . equals ( other . name ) ) { return false ; } if ( this . value != other . value && ( this . value == null || ! this . value . equals ( other . value ) ) ) { return false ; } return true ; } @ Override public int hashCode ( ) { int hash = 3 ; hash = 97 * hash + ( this . type != null ? this . type . hashCode ( ) : 0 ) ; hash = 97 * hash + ( this . name != null ? this . name . hashCode ( ) : 0 ) ; hash = 97 * hash + ( this . value != null ? this . value . hashCode ( ) : 0 ) ; return hash ; } }
package processing . mode . java . debug ; import com . sun . jdi . ClassNotLoadedException ; import com . sun . jdi . InvalidTypeException ; import com . sun . jdi . LocalVariable ; import com . sun . jdi . StackFrame ; import com . sun . jdi . Value ; import java . util . logging . Level ; import java . util . logging . Logger ; public class LocalVariableNode extends VariableNode { protected LocalVariable var ; protected StackFrame frame ; public LocalVariableNode ( String name , String type , Value value , LocalVariable var , StackFrame frame ) { super ( name , type , value ) ; this . var = var ; this . frame = frame ; } @ Override public void setValue ( Value value ) { try { frame . setValue ( var , value ) ; } catch ( InvalidTypeException ex ) { Logger . getLogger ( LocalVariableNode . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ClassNotLoadedException ex ) { Logger . getLogger ( LocalVariableNode . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } this . value = value ; } }
package processing . mode . java . debug ; import com . sun . jdi . ClassNotLoadedException ; import com . sun . jdi . Field ; import com . sun . jdi . InvalidTypeException ; import com . sun . jdi . ObjectReference ; import com . sun . jdi . Value ; import java . util . logging . Level ; import java . util . logging . Logger ; public class FieldNode extends VariableNode { protected Field field ; protected ObjectReference obj ; public FieldNode ( String name , String type , Value value , Field field , ObjectReference obj ) { super ( name , type , value ) ; this . field = field ; this . obj = obj ; } @ Override public void setValue ( Value value ) { try { obj . setValue ( field , value ) ; } catch ( InvalidTypeException ex ) { Logger . getLogger ( FieldNode . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ClassNotLoadedException ex ) { Logger . getLogger ( FieldNode . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } this . value = value ; } }
package processing . core ; import java . awt . * ; import java . awt . event . * ; import java . awt . geom . Rectangle2D ; import java . awt . image . * ; import java . lang . reflect . * ; import java . net . URL ; import java . util . ArrayList ; import javax . swing . JFrame ; import processing . event . KeyEvent ; import processing . event . MouseEvent ; public class PSurfaceAWT extends PSurfaceNone { GraphicsDevice displayDevice ; JFrame frame ; Rectangle screenRect ; boolean useStrategy = true ; Component canvas ; int sketchWidth ; int sketchHeight ; public PSurfaceAWT ( PGraphics graphics ) { super ( graphics ) ; if ( checkRetina ( ) ) { } canvas = new SmoothCanvas ( ) ; if ( useStrategy ) { canvas . setIgnoreRepaint ( true ) ; } canvas . setFocusTraversalKeysEnabled ( false ) ; canvas . addComponentListener ( new ComponentAdapter ( ) { @ Override public void componentResized ( ComponentEvent e ) { if ( ! sketch . looping ) { sketch . redraw ( ) ; } } } ) ; addListeners ( ) ; } @ Override void requestFocus ( ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { if ( canvas != null ) { canvas . requestFocusInWindow ( ) ; } } } ) ; } class SmoothCanvas extends Canvas { private Dimension oldSize = new Dimension ( 0 , 0 ) ; private Dimension newSize = new Dimension ( 0 , 0 ) ; @ Override public Dimension getPreferredSize ( ) { return new Dimension ( sketchWidth , sketchHeight ) ; } @ Override public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } @ Override public Dimension getMaximumSize ( ) { return frame . isResizable ( ) ? super . getMaximumSize ( ) : getPreferredSize ( ) ; } @ Override public void validate ( ) { super . validate ( ) ; newSize . width = getWidth ( ) ; newSize . height = getHeight ( ) ; if ( ! oldSize . equals ( newSize ) ) { oldSize = newSize ; sketch . setSize ( newSize . width , newSize . height ) ; render ( ) ; } } @ Override public void update ( Graphics g ) { paint ( g ) ; } @ Override public void paint ( Graphics screen ) { if ( useStrategy ) { render ( ) ; } else { if ( onscreen != null ) { synchronized ( offscreenLock ) { screen . drawImage ( onscreen , 0 , 0 , sketchWidth , sketchHeight , null ) ; } } } } } protected synchronized void render ( ) { if ( ! canvas . isDisplayable ( ) ) { return ; } if ( graphics . image == null ) { if ( PApplet . DEBUG ) { new Exception ( "image is null, returning" ) . printStackTrace ( System . out ) ; } return ; } Canvas c = ( Canvas ) canvas ; if ( c . getBufferStrategy ( ) == null ) { c . createBufferStrategy ( 2 ) ; } BufferStrategy strategy = c . getBufferStrategy ( ) ; if ( strategy == null ) { return ; } do { do { Graphics2D draw = ( Graphics2D ) strategy . getDrawGraphics ( ) ; draw . drawImage ( graphics . image , 0 , 0 , sketchWidth , sketchHeight , null ) ; draw . dispose ( ) ; } while ( strategy . contentsRestored ( ) ) ; strategy . show ( ) ; } while ( strategy . contentsLost ( ) ) ; } Object offscreenLock = new Object ( ) ; BufferedImage offscreen ; BufferedImage onscreen ; protected void blit ( ) { if ( useStrategy ) { render ( ) ; } else { if ( graphics . image != null ) { BufferedImage graphicsImage = ( BufferedImage ) graphics . image ; if ( offscreen == null || offscreen . getWidth ( ) != graphicsImage . getWidth ( ) || offscreen . getHeight ( ) != graphicsImage . getHeight ( ) ) { System . out . println ( "creating new image" ) ; offscreen = ( BufferedImage ) canvas . createImage ( graphicsImage . getWidth ( ) , graphicsImage . getHeight ( ) ) ; } Graphics2D off = ( Graphics2D ) offscreen . getGraphics ( ) ; off . drawImage ( graphicsImage , 0 , 0 , null ) ; off . dispose ( ) ; synchronized ( offscreenLock ) { BufferedImage temp = onscreen ; onscreen = offscreen ; offscreen = temp ; } canvas . repaint ( ) ; } } } @ Override public void initOffscreen ( PApplet sketch ) { this . sketch = sketch ; } @ Override public void initFrame ( PApplet sketch ) { this . sketch = sketch ; GraphicsEnvironment environment = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; int displayNum = sketch . sketchDisplay ( ) ; if ( displayNum > 0 ) { GraphicsDevice [ ] devices = environment . getScreenDevices ( ) ; if ( displayNum <= devices . length ) { displayDevice = devices [ displayNum - 1 ] ; } else { System . err . format ( "Display %d does not exist, " + "using the default display instead.%n" , displayNum ) ; for ( int i = 0 ; i < devices . length ; i ++ ) { System . err . format ( "Display %d is %s%n" , ( i + 1 ) , devices [ i ] ) ; } } } if ( displayDevice == null ) { displayDevice = environment . getDefaultScreenDevice ( ) ; } boolean spanDisplays = sketch . sketchDisplay ( ) == PConstants . SPAN ; screenRect = spanDisplays ? getDisplaySpan ( ) : displayDevice . getDefaultConfiguration ( ) . getBounds ( ) ; sketch . displayWidth = screenRect . width ; sketch . displayHeight = screenRect . height ; sketchWidth = sketch . sketchWidth ( ) ; sketchHeight = sketch . sketchHeight ( ) ; boolean fullScreen = sketch . sketchFullScreen ( ) ; if ( screenRect . width == sketchWidth && screenRect . height == sketchHeight ) { fullScreen = true ; sketch . fullScreen ( ) ; } if ( fullScreen || spanDisplays ) { sketchWidth = screenRect . width ; sketchHeight = screenRect . height ; } frame = new JFrame ( displayDevice . getDefaultConfiguration ( ) ) ; final Color windowColor = new Color ( sketch . sketchWindowColor ( ) , false ) ; frame . getContentPane ( ) . setBackground ( windowColor ) ; setIconImage ( frame ) ; frame . add ( canvas ) ; setSize ( sketchWidth , sketchHeight ) ; if ( fullScreen ) { PApplet . hideMenuBar ( ) ; frame . dispose ( ) ; frame . setUndecorated ( true ) ; frame . setBounds ( screenRect ) ; } frame . setLayout ( null ) ; if ( fullScreen ) { frame . invalidate ( ) ; } else { } frame . setResizable ( false ) ; sketch . setFrame ( frame ) ; } @ Override public void setTitle ( String title ) { frame . setTitle ( title ) ; } @ Override public void setResizable ( boolean resizable ) { if ( frame != null ) { frame . setResizable ( resizable ) ; } } @ Override public void setVisible ( boolean visible ) { frame . setVisible ( visible ) ; } @ Override public void placePresent ( int stopColor ) { frame . setBounds ( screenRect ) ; canvas . setBounds ( ( screenRect . width - sketchWidth ) / 2 , ( screenRect . height - sketchHeight ) / 2 , sketchWidth , sketchHeight ) ; if ( stopColor != 0 ) { Label label = new Label ( "stop" ) ; label . setForeground ( new Color ( stopColor , false ) ) ; label . addMouseListener ( new MouseAdapter ( ) { @ Override public void mousePressed ( java . awt . event . MouseEvent e ) { sketch . exit ( ) ; } } ) ; frame . add ( label ) ; Dimension labelSize = label . getPreferredSize ( ) ; labelSize = new Dimension ( 100 , labelSize . height ) ; label . setSize ( labelSize ) ; label . setLocation ( 20 , screenRect . height - labelSize . height - 20 ) ; } } private void setCanvasSize ( ) { int contentW = Math . max ( sketchWidth , MIN_WINDOW_WIDTH ) ; int contentH = Math . max ( sketchHeight , MIN_WINDOW_HEIGHT ) ; canvas . setBounds ( ( contentW - sketchWidth ) / 2 , ( contentH - sketchHeight ) / 2 , sketchWidth , sketchHeight ) ; } private Dimension setFrameSize ( ) { frame . addNotify ( ) ; Insets insets = frame . getInsets ( ) ; int windowW = Math . max ( sketchWidth , MIN_WINDOW_WIDTH ) + insets . left + insets . right ; int windowH = Math . max ( sketchHeight , MIN_WINDOW_HEIGHT ) + insets . top + insets . bottom ; frame . setSize ( windowW , windowH ) ; return new Dimension ( windowW , windowH ) ; } private void setFrameCentered ( ) { frame . setLocation ( screenRect . x + ( screenRect . width - sketchWidth ) / 2 , screenRect . y + ( screenRect . height - sketchHeight ) / 2 ) ; } @ Override public void placeWindow ( int [ ] location , int [ ] editorLocation ) { Dimension window = setFrameSize ( ) ; int contentW = Math . max ( sketchWidth , MIN_WINDOW_WIDTH ) ; int contentH = Math . max ( sketchHeight , MIN_WINDOW_HEIGHT ) ; if ( ! sketch . sketchFullScreen ( ) ) { if ( location != null ) { frame . setLocation ( location [ 0 ] , location [ 1 ] ) ; } else if ( editorLocation != null ) { int locationX = editorLocation [ 0 ] - 20 ; int locationY = editorLocation [ 1 ] ; if ( locationX - window . width > 10 ) { frame . setLocation ( locationX - window . width , locationY ) ; } else { locationX = editorLocation [ 0 ] + 66 ; locationY = editorLocation [ 1 ] + 66 ; if ( ( locationX + window . width > sketch . displayWidth - 33 ) || ( locationY + window . height > sketch . displayHeight - 33 ) ) { locationX = ( sketch . displayWidth - window . width ) / 2 ; locationY = ( sketch . displayHeight - window . height ) / 2 ; } frame . setLocation ( locationX , locationY ) ; } } else { setFrameCentered ( ) ; } Point frameLoc = frame . getLocation ( ) ; if ( frameLoc . y < 0 ) { frame . setLocation ( frameLoc . x , 30 ) ; } } canvas . setBounds ( ( contentW - sketchWidth ) / 2 , ( contentH - sketchHeight ) / 2 , sketchWidth , sketchHeight ) ; setupFrameResizeListener ( ) ; if ( sketch . getGraphics ( ) . displayable ( ) ) { frame . setVisible ( true ) ; } } @ Override public void setSize ( int wide , int high ) { if ( PApplet . DEBUG ) { new Exception ( String . format ( "setSize(%d, %d)" , wide , high ) ) . printStackTrace ( System . out ) ; } if ( wide == sketch . width && high == sketch . height ) { if ( PApplet . DEBUG ) { new Exception ( "w/h unchanged " + wide + " " + high ) . printStackTrace ( System . out ) ; } return ; } sketchWidth = wide ; sketchHeight = high ; if ( frame != null ) { setFrameSize ( ) ; } setCanvasSize ( ) ; sketch . setSize ( wide , high ) ; graphics . setSize ( wide , high ) ; } @ Override public void setSmooth ( int level ) { } private boolean checkRetina ( ) { if ( PApplet . platform == PConstants . MACOSX ) { final String javaVendor = System . getProperty ( "java.vendor" ) ; if ( javaVendor . contains ( "Oracle" ) ) { GraphicsEnvironment env = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice device = env . getDefaultScreenDevice ( ) ; try { Field field = device . getClass ( ) . getDeclaredField ( "scale" ) ; if ( field != null ) { field . setAccessible ( true ) ; Object scale = field . get ( device ) ; if ( scale instanceof Integer && ( ( Integer ) scale ) . intValue ( ) == 2 ) { return true ; } } } catch ( Exception ignore ) { } } } return false ; } static Rectangle getDisplaySpan ( ) { Rectangle bounds = new Rectangle ( ) ; GraphicsEnvironment environment = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; for ( GraphicsDevice device : environment . getScreenDevices ( ) ) { for ( GraphicsConfiguration config : device . getConfigurations ( ) ) { Rectangle2D . union ( bounds , config . getBounds ( ) , bounds ) ; } } return bounds ; } @ Override public void setupExternalMessages ( ) { frame . addComponentListener ( new ComponentAdapter ( ) { @ Override public void componentMoved ( ComponentEvent e ) { Point where = ( ( Frame ) e . getSource ( ) ) . getLocation ( ) ; sketch . frameMoved ( where . x , where . y ) ; } } ) ; frame . addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosing ( WindowEvent e ) { sketch . exit ( ) ; } } ) ; } public void setupFrameResizeListener ( ) { frame . addWindowStateListener ( new WindowStateListener ( ) { @ Override public void windowStateChanged ( WindowEvent e ) { if ( Frame . MAXIMIZED_BOTH == e . getNewState ( ) ) { frame . addNotify ( ) ; } } } ) ; frame . addComponentListener ( new ComponentAdapter ( ) { @ Override public void componentResized ( ComponentEvent e ) { if ( frame . isResizable ( ) ) { Frame farm = ( Frame ) e . getComponent ( ) ; if ( farm . isVisible ( ) ) { Insets insets = farm . getInsets ( ) ; Dimension windowSize = farm . getSize ( ) ; setSize ( windowSize . width - insets . left - insets . right , windowSize . height - insets . top - insets . bottom ) ; } } } } ) ; } static ArrayList < Image > iconImages ; static protected void setIconImage ( Frame frame ) { if ( PApplet . platform != PConstants . MACOSX ) { try { if ( iconImages == null ) { iconImages = new ArrayList < Image > ( ) ; final int [ ] sizes = { 16 , 32 , 48 , 64 , 128 , 256 , 512 } ; for ( int sz : sizes ) { URL url = PApplet . class . getResource ( "/icon/icon-" + sz + ".png" ) ; Image image = Toolkit . getDefaultToolkit ( ) . getImage ( url ) ; iconImages . add ( image ) ; } } frame . setIconImages ( iconImages ) ; } catch ( Exception e ) { } } else { URL url = PApplet . class . getResource ( "/icon/icon-512.png" ) ; ThinkDifferent . setIconImage ( Toolkit . getDefaultToolkit ( ) . getImage ( url ) ) ; } } protected void nativeMouseEvent ( java . awt . event . MouseEvent nativeEvent ) { int peCount = nativeEvent . getClickCount ( ) ; int peAction = 0 ; switch ( nativeEvent . getID ( ) ) { case java . awt . event . MouseEvent . MOUSE_PRESSED : peAction = MouseEvent . PRESS ; break ; case java . awt . event . MouseEvent . MOUSE_RELEASED : peAction = MouseEvent . RELEASE ; break ; case java . awt . event . MouseEvent . MOUSE_CLICKED : peAction = MouseEvent . CLICK ; break ; case java . awt . event . MouseEvent . MOUSE_DRAGGED : peAction = MouseEvent . DRAG ; break ; case java . awt . event . MouseEvent . MOUSE_MOVED : peAction = MouseEvent . MOVE ; break ; case java . awt . event . MouseEvent . MOUSE_ENTERED : peAction = MouseEvent . ENTER ; break ; case java . awt . event . MouseEvent . MOUSE_EXITED : peAction = MouseEvent . EXIT ; break ; case java . awt . event . MouseEvent . MOUSE_WHEEL : peAction = MouseEvent . WHEEL ; peCount = ( ( MouseWheelEvent ) nativeEvent ) . getWheelRotation ( ) ; break ; } int modifiers = nativeEvent . getModifiers ( ) ; int peModifiers = modifiers & ( InputEvent . SHIFT_MASK | InputEvent . CTRL_MASK | InputEvent . META_MASK | InputEvent . ALT_MASK ) ; int peButton = 0 ; if ( ( modifiers & InputEvent . BUTTON1_MASK ) != 0 ) { peButton = PConstants . LEFT ; } else if ( ( modifiers & InputEvent . BUTTON2_MASK ) != 0 ) { peButton = PConstants . CENTER ; } else if ( ( modifiers & InputEvent . BUTTON3_MASK ) != 0 ) { peButton = PConstants . RIGHT ; } if ( PApplet . platform == PConstants . MACOSX ) { if ( ( modifiers & InputEvent . CTRL_MASK ) != 0 ) { peButton = PConstants . RIGHT ; } } sketch . postEvent ( new MouseEvent ( nativeEvent , nativeEvent . getWhen ( ) , peAction , peModifiers , nativeEvent . getX ( ) , nativeEvent . getY ( ) , peButton , peCount ) ) ; } protected void nativeKeyEvent ( java . awt . event . KeyEvent event ) { int peAction = 0 ; switch ( event . getID ( ) ) { case java . awt . event . KeyEvent . KEY_PRESSED : peAction = KeyEvent . PRESS ; break ; case java . awt . event . KeyEvent . KEY_RELEASED : peAction = KeyEvent . RELEASE ; break ; case java . awt . event . KeyEvent . KEY_TYPED : peAction = KeyEvent . TYPE ; break ; } int peModifiers = event . getModifiers ( ) & ( InputEvent . SHIFT_MASK | InputEvent . CTRL_MASK | InputEvent . META_MASK | InputEvent . ALT_MASK ) ; sketch . postEvent ( new KeyEvent ( event , event . getWhen ( ) , peAction , peModifiers , event . getKeyChar ( ) , event . getKeyCode ( ) ) ) ; } protected void addListeners ( ) { canvas . addMouseListener ( new MouseListener ( ) { public void mousePressed ( java . awt . event . MouseEvent e ) { nativeMouseEvent ( e ) ; } public void mouseReleased ( java . awt . event . MouseEvent e ) { nativeMouseEvent ( e ) ; } public void mouseClicked ( java . awt . event . MouseEvent e ) { nativeMouseEvent ( e ) ; } public void mouseEntered ( java . awt . event . MouseEvent e ) { nativeMouseEvent ( e ) ; } public void mouseExited ( java . awt . event . MouseEvent e ) { nativeMouseEvent ( e ) ; } } ) ; canvas . addMouseMotionListener ( new MouseMotionListener ( ) { public void mouseDragged ( java . awt . event . MouseEvent e ) { nativeMouseEvent ( e ) ; } public void mouseMoved ( java . awt . event . MouseEvent e ) { nativeMouseEvent ( e ) ; } } ) ; canvas . addMouseWheelListener ( new MouseWheelListener ( ) { public void mouseWheelMoved ( MouseWheelEvent e ) { nativeMouseEvent ( e ) ; } } ) ; canvas . addKeyListener ( new KeyListener ( ) { public void keyPressed ( java . awt . event . KeyEvent e ) { nativeKeyEvent ( e ) ; } public void keyReleased ( java . awt . event . KeyEvent e ) { nativeKeyEvent ( e ) ; } public void keyTyped ( java . awt . event . KeyEvent e ) { nativeKeyEvent ( e ) ; } } ) ; canvas . addFocusListener ( new FocusListener ( ) { public void focusGained ( FocusEvent e ) { sketch . focused = true ; sketch . focusGained ( ) ; } public void focusLost ( FocusEvent e ) { sketch . focused = false ; sketch . focusLost ( ) ; } } ) ; } int cursorType = PConstants . ARROW ; boolean cursorVisible = true ; Cursor invisibleCursor ; @ Override public void setCursor ( int kind ) { if ( PApplet . platform == PConstants . MACOSX && kind == PConstants . MOVE ) { kind = PConstants . HAND ; } canvas . setCursor ( Cursor . getPredefinedCursor ( kind ) ) ; cursorVisible = true ; this . cursorType = kind ; } @ Override public void setCursor ( PImage img , int x , int y ) { Cursor cursor = canvas . getToolkit ( ) . createCustomCursor ( ( Image ) img . getNative ( ) , new Point ( x , y ) , "custom" ) ; canvas . setCursor ( cursor ) ; cursorVisible = true ; } @ Override public void showCursor ( ) { if ( ! cursorVisible ) { cursorVisible = true ; canvas . setCursor ( Cursor . getPredefinedCursor ( cursorType ) ) ; } } @ Override public void hideCursor ( ) { if ( invisibleCursor == null ) { BufferedImage cursorImg = new BufferedImage ( 16 , 16 , BufferedImage . TYPE_INT_ARGB ) ; invisibleCursor = canvas . getToolkit ( ) . createCustomCursor ( cursorImg , new Point ( 8 , 8 ) , "blank" ) ; } canvas . setCursor ( invisibleCursor ) ; cursorVisible = false ; } @ Override public Thread createThread ( ) { return new AnimationThread ( ) { @ Override public void render ( ) { sketch . handleDraw ( ) ; blit ( ) ; } } ; } void debug ( String format , Object ... args ) { System . out . format ( format + "%n" , args ) ; } }
package processing . core ; import java . util . HashMap ; import java . util . Map ; import javafx . animation . AnimationTimer ; import javafx . application . Application ; import javafx . application . Platform ; import javafx . beans . value . ChangeListener ; import javafx . beans . value . ObservableValue ; import javafx . event . EventHandler ; import javafx . event . EventType ; import javafx . scene . Scene ; import javafx . scene . canvas . Canvas ; import javafx . scene . input . KeyCode ; import javafx . scene . input . KeyEvent ; import javafx . scene . input . MouseEvent ; import javafx . scene . input . ScrollEvent ; import javafx . scene . layout . StackPane ; import javafx . stage . Stage ; import javafx . stage . WindowEvent ; public class PSurfaceFX implements PSurface { PApplet sketch ; PGraphicsFX2D fx ; Stage stage ; Canvas canvas ; AnimationTimer timer ; public PSurfaceFX ( PGraphicsFX2D graphics ) { fx = graphics ; canvas = new ResizableCanvas ( ) ; fx . context = canvas . getGraphicsContext2D ( ) ; } class ResizableCanvas extends Canvas { public ResizableCanvas ( ) { widthProperty ( ) . addListener ( new ChangeListener < Number > ( ) { @ Override public void changed ( ObservableValue < ? extends Number > value , Number oldWidth , Number newWidth ) { sketch . setSize ( newWidth . intValue ( ) , sketch . height ) ; fx . setSize ( sketch . width , sketch . height ) ; } } ) ; heightProperty ( ) . addListener ( new ChangeListener < Number > ( ) { @ Override public void changed ( ObservableValue < ? extends Number > value , Number oldHeight , Number newHeight ) { sketch . setSize ( sketch . width , newHeight . intValue ( ) ) ; fx . setSize ( sketch . width , sketch . height ) ; } } ) ; EventHandler < MouseEvent > mouseHandler = new EventHandler < MouseEvent > ( ) { public void handle ( MouseEvent e ) { fxMouseEvent ( e ) ; } } ; setOnMousePressed ( mouseHandler ) ; setOnMouseReleased ( mouseHandler ) ; setOnMouseClicked ( mouseHandler ) ; setOnMouseEntered ( mouseHandler ) ; setOnMouseExited ( mouseHandler ) ; setOnMouseDragged ( mouseHandler ) ; setOnMouseMoved ( mouseHandler ) ; setOnScroll ( new EventHandler < ScrollEvent > ( ) { public void handle ( ScrollEvent e ) { fxScrollEvent ( e ) ; } } ) ; EventHandler < KeyEvent > keyHandler = new EventHandler < KeyEvent > ( ) { public void handle ( KeyEvent e ) { fxKeyEvent ( e ) ; } } ; setOnKeyPressed ( keyHandler ) ; setOnKeyReleased ( keyHandler ) ; setOnKeyTyped ( keyHandler ) ; setFocusTraversable ( false ) ; focusedProperty ( ) . addListener ( new ChangeListener < Boolean > ( ) { public void changed ( ObservableValue < ? extends Boolean > value , Boolean oldValue , Boolean newValue ) { if ( newValue . booleanValue ( ) ) { sketch . focused = true ; sketch . focusGained ( ) ; } else { sketch . focused = false ; sketch . focusLost ( ) ; } } } ) ; } @ Override public boolean isResizable ( ) { return true ; } @ Override public double prefWidth ( double height ) { return getWidth ( ) ; } @ Override public double prefHeight ( double width ) { return getHeight ( ) ; } } public void initOffscreen ( PApplet sketch ) { } static public class PApplicationFX extends Application { static public PSurfaceFX surface ; public PApplicationFX ( ) { } @ Override public void start ( final Stage stage ) { surface . stage = stage ; Canvas canvas = surface . canvas ; StackPane stackPane = new StackPane ( ) ; stackPane . getChildren ( ) . add ( canvas ) ; canvas . widthProperty ( ) . bind ( stackPane . widthProperty ( ) ) ; canvas . heightProperty ( ) . bind ( stackPane . heightProperty ( ) ) ; stage . setScene ( new Scene ( stackPane ) ) ; } } public void initFrame ( PApplet sketch ) { this . sketch = sketch ; PApplicationFX . surface = this ; new Thread ( new Runnable ( ) { public void run ( ) { Application . launch ( PApplicationFX . class ) ; } } ) . start ( ) ; while ( stage == null ) { try { Thread . sleep ( 5 ) ; } catch ( InterruptedException e ) { } } setSize ( sketch . sketchWidth ( ) , sketch . sketchHeight ( ) ) ; } public void setTitle ( String title ) { stage . setTitle ( title ) ; } @ Override public void setVisible ( boolean visible ) { Platform . runLater ( new Runnable ( ) { public void run ( ) { stage . show ( ) ; canvas . requestFocus ( ) ; } } ) ; } public void setResizable ( boolean resizable ) { stage . setResizable ( resizable ) ; } @ Override public void placeWindow ( int [ ] location , int [ ] editorLocation ) { if ( location != null ) { stage . setX ( location [ 0 ] ) ; stage . setY ( location [ 1 ] ) ; } else if ( editorLocation != null ) { int locationX = editorLocation [ 0 ] - 20 ; int locationY = editorLocation [ 1 ] ; if ( locationX - stage . getWidth ( ) > 10 ) { stage . setX ( locationX - stage . getWidth ( ) ) ; stage . setY ( locationY ) ; } else { locationX = editorLocation [ 0 ] + 66 ; locationY = editorLocation [ 1 ] + 66 ; if ( ( locationX + stage . getWidth ( ) > sketch . displayWidth - 33 ) || ( locationY + stage . getHeight ( ) > sketch . displayHeight - 33 ) ) { locationX = ( int ) ( ( sketch . displayWidth - stage . getWidth ( ) ) / 2 ) ; locationY = ( int ) ( ( sketch . displayHeight - stage . getHeight ( ) ) / 2 ) ; } stage . setX ( locationX ) ; stage . setY ( locationY ) ; } } else { } if ( stage . getY ( ) < 0 ) { stage . setY ( 30 ) ; } if ( sketch . getGraphics ( ) . displayable ( ) ) { setVisible ( true ) ; } } public void placePresent ( int stopColor ) { } @ Override public void setupExternalMessages ( ) { stage . xProperty ( ) . addListener ( new ChangeListener < Number > ( ) { @ Override public void changed ( ObservableValue < ? extends Number > value , Number oldX , Number newX ) { sketch . frameMoved ( newX . intValue ( ) , stage . yProperty ( ) . intValue ( ) ) ; } } ) ; stage . yProperty ( ) . addListener ( new ChangeListener < Number > ( ) { @ Override public void changed ( ObservableValue < ? extends Number > value , Number oldY , Number newY ) { sketch . frameMoved ( stage . xProperty ( ) . intValue ( ) , newY . intValue ( ) ) ; } } ) ; stage . setOnCloseRequest ( new EventHandler < WindowEvent > ( ) { public void handle ( WindowEvent we ) { sketch . exit ( ) ; } } ) ; } public void setSize ( int width , int height ) { stage . setWidth ( width ) ; stage . setHeight ( height ) ; fx . setSize ( width , height ) ; } public void setSmooth ( int level ) { } public void setFrameRate ( float fps ) { } public void setCursor ( int kind ) { } public void setCursor ( PImage image , int hotspotX , int hotspotY ) { } public void showCursor ( ) { } public void hideCursor ( ) { } public void startThread ( ) { if ( timer == null ) { timer = new AnimationTimer ( ) { @ Override public void handle ( long now ) { sketch . handleDraw ( ) ; if ( sketch . exitCalled ) { Platform . exit ( ) ; } } } ; timer . start ( ) ; } } public void pauseThread ( ) { } public void resumeThread ( ) { } public boolean stopThread ( ) { return false ; } public boolean isStopped ( ) { return false ; } static Map < EventType < ? extends MouseEvent > , Integer > mouseMap = new HashMap < EventType < ? extends MouseEvent > , Integer > ( ) ; static { mouseMap . put ( MouseEvent . MOUSE_PRESSED , processing . event . MouseEvent . PRESS ) ; mouseMap . put ( MouseEvent . MOUSE_RELEASED , processing . event . MouseEvent . RELEASE ) ; mouseMap . put ( MouseEvent . MOUSE_CLICKED , processing . event . MouseEvent . CLICK ) ; mouseMap . put ( MouseEvent . MOUSE_DRAGGED , processing . event . MouseEvent . DRAG ) ; mouseMap . put ( MouseEvent . MOUSE_MOVED , processing . event . MouseEvent . MOVE ) ; mouseMap . put ( MouseEvent . MOUSE_ENTERED , processing . event . MouseEvent . ENTER ) ; mouseMap . put ( MouseEvent . MOUSE_EXITED , processing . event . MouseEvent . EXIT ) ; } protected void fxMouseEvent ( MouseEvent fxEvent ) { int count = fxEvent . getClickCount ( ) ; int action = mouseMap . get ( fxEvent . getEventType ( ) ) ; int modifiers = 0 ; if ( fxEvent . isShiftDown ( ) ) { modifiers |= processing . event . Event . SHIFT ; } if ( fxEvent . isControlDown ( ) ) { modifiers |= processing . event . Event . CTRL ; } if ( fxEvent . isMetaDown ( ) ) { modifiers |= processing . event . Event . META ; } if ( fxEvent . isAltDown ( ) ) { modifiers |= processing . event . Event . ALT ; } int button = 0 ; if ( fxEvent . isPrimaryButtonDown ( ) ) { button = PConstants . LEFT ; } else if ( fxEvent . isSecondaryButtonDown ( ) ) { button = PConstants . RIGHT ; } else if ( fxEvent . isMiddleButtonDown ( ) ) { button = PConstants . CENTER ; } if ( PApplet . platform == PConstants . MACOSX && fxEvent . isControlDown ( ) && button == PConstants . LEFT ) { button = PConstants . RIGHT ; } long when = System . currentTimeMillis ( ) ; int x = ( int ) fxEvent . getX ( ) ; int y = ( int ) fxEvent . getY ( ) ; sketch . postEvent ( new processing . event . MouseEvent ( fxEvent , when , action , modifiers , x , y , button , count ) ) ; } protected void fxScrollEvent ( ScrollEvent event ) { } @ SuppressWarnings ( "deprecation" ) protected void fxKeyEvent ( javafx . scene . input . KeyEvent fxEvent ) { int action = 0 ; EventType < ? extends KeyEvent > et = fxEvent . getEventType ( ) ; if ( et == KeyEvent . KEY_PRESSED ) { action = processing . event . KeyEvent . PRESS ; } else if ( et == KeyEvent . KEY_RELEASED ) { action = processing . event . KeyEvent . RELEASE ; } else if ( et == KeyEvent . KEY_TYPED ) { action = processing . event . KeyEvent . TYPE ; } int modifiers = 0 ; if ( fxEvent . isShiftDown ( ) ) { modifiers |= processing . event . Event . SHIFT ; } if ( fxEvent . isControlDown ( ) ) { modifiers |= processing . event . Event . CTRL ; } if ( fxEvent . isMetaDown ( ) ) { modifiers |= processing . event . Event . META ; } if ( fxEvent . isAltDown ( ) ) { modifiers |= processing . event . Event . ALT ; } long when = System . currentTimeMillis ( ) ; KeyCode kc = fxEvent . getCode ( ) ; char key = kc . impl_getChar ( ) . charAt ( 0 ) ; int keyCode = kc . impl_getCode ( ) ; sketch . postEvent ( new processing . event . KeyEvent ( fxEvent , when , action , modifiers , key , keyCode ) ) ; } }
package processing . serial ; import processing . core . * ; import java . lang . reflect . * ; import java . util . Map ; import jssc . * ; public class Serial implements SerialPortEventListener { PApplet parent ; public SerialPort port ; Method serialAvailableMethod ; Method serialEventMethod ; byte [ ] buffer = new byte [ 32768 ] ; int inBuffer = 0 ; int readOffset = 0 ; int bufferUntilSize = 1 ; byte bufferUntilByte = 0 ; volatile boolean invokeSerialAvailable = false ; public Serial ( PApplet parent ) { this ( parent , "COM1" , 9600 , 'N' , 8 , 1 ) ; } public Serial ( PApplet parent , int baudRate ) { this ( parent , "COM1" , baudRate , 'N' , 8 , 1 ) ; } public Serial ( PApplet parent , String portName ) { this ( parent , portName , 9600 , 'N' , 8 , 1 ) ; } public Serial ( PApplet parent , String portName , int baudRate ) { this ( parent , portName , baudRate , 'N' , 8 , 1 ) ; } public Serial ( PApplet parent , String portName , int baudRate , char parity , int dataBits , float stopBits ) { this . parent = parent ; parent . registerMethod ( "dispose" , this ) ; parent . registerMethod ( "pre" , this ) ; if ( parity == 'O' ) { parity = SerialPort . PARITY_ODD ; } else if ( parity == 'E' ) { parity = SerialPort . PARITY_EVEN ; } else if ( parity == 'M' ) { parity = SerialPort . PARITY_MARK ; } else if ( parity == 'S' ) { parity = SerialPort . PARITY_SPACE ; } else { parity = SerialPort . PARITY_NONE ; } int stopBitsIdx = SerialPort . STOPBITS_1 ; if ( stopBits == 1.5f ) { stopBitsIdx = SerialPort . STOPBITS_1_5 ; } else if ( stopBits == 2 ) { stopBitsIdx = SerialPort . STOPBITS_2 ; } port = new SerialPort ( portName ) ; try { port . openPort ( ) ; port . setParams ( baudRate , dataBits , stopBitsIdx , parity ) ; port . addEventListener ( this , SerialPort . MASK_RXCHAR ) ; } catch ( SerialPortException e ) { throw new RuntimeException ( "Error opening serial port " + e . getPortName ( ) + ": " + e . getExceptionType ( ) ) ; } serialEventMethod = findCallback ( "serialEvent" ) ; serialAvailableMethod = findCallback ( "serialAvailable" ) ; } private Method findCallback ( final String name ) { try { return parent . getClass ( ) . getMethod ( name , this . getClass ( ) ) ; } catch ( Exception e ) { } try { return parent . getClass ( ) . getMethod ( name , Object . class ) ; } catch ( Exception e ) { } return null ; } public void dispose ( ) { stop ( ) ; } public boolean active ( ) { return port . isOpened ( ) ; } public void pre ( ) { if ( serialAvailableMethod != null && invokeSerialAvailable ) { invokeSerialAvailable = false ; try { serialAvailableMethod . invoke ( parent , this ) ; } catch ( Exception e ) { System . err . println ( "Error, disabling serialAvailable() for " + port . getPortName ( ) ) ; System . err . println ( e . getLocalizedMessage ( ) ) ; serialAvailableMethod = null ; } } } public int available ( ) { return ( inBuffer - readOffset ) ; } public void buffer ( int size ) { bufferUntilSize = size ; } public void bufferUntil ( int inByte ) { bufferUntilSize = 0 ; bufferUntilByte = ( byte ) inByte ; } public void clear ( ) { synchronized ( buffer ) { inBuffer = 0 ; readOffset = 0 ; } } public boolean getCTS ( ) { try { return port . isCTS ( ) ; } catch ( SerialPortException e ) { throw new RuntimeException ( "Error reading the CTS line: " + e . getExceptionType ( ) ) ; } } public boolean getDSR ( ) { try { return port . isDSR ( ) ; } catch ( SerialPortException e ) { throw new RuntimeException ( "Error reading the DSR line: " + e . getExceptionType ( ) ) ; } } public static Map < String , String > getProperties ( String portName ) { return SerialPortList . getPortProperties ( portName ) ; } public int last ( ) { if ( inBuffer == readOffset ) { return - 1 ; } synchronized ( buffer ) { int ret = buffer [ inBuffer - 1 ] & 0xFF ; inBuffer = 0 ; readOffset = 0 ; return ret ; } } public char lastChar ( ) { return ( char ) last ( ) ; } public static String [ ] list ( ) { return SerialPortList . getPortNames ( ) ; } public int read ( ) { if ( inBuffer == readOffset ) { return - 1 ; } synchronized ( buffer ) { int ret = buffer [ readOffset ++ ] & 0xFF ; if ( inBuffer == readOffset ) { inBuffer = 0 ; readOffset = 0 ; } return ret ; } } public byte [ ] readBytes ( ) { if ( inBuffer == readOffset ) { return null ; } synchronized ( buffer ) { byte [ ] ret = new byte [ inBuffer - readOffset ] ; System . arraycopy ( buffer , readOffset , ret , 0 , ret . length ) ; inBuffer = 0 ; readOffset = 0 ; return ret ; } } public int readBytes ( byte [ ] dest ) { if ( inBuffer == readOffset ) { return 0 ; } synchronized ( buffer ) { int toCopy = inBuffer - readOffset ; if ( dest . length < toCopy ) { toCopy = dest . length ; } System . arraycopy ( buffer , readOffset , dest , 0 , toCopy ) ; readOffset += toCopy ; if ( inBuffer == readOffset ) { inBuffer = 0 ; readOffset = 0 ; } return toCopy ; } } public byte [ ] readBytesUntil ( int inByte ) { if ( inBuffer == readOffset ) { return null ; } synchronized ( buffer ) { int found = - 1 ; for ( int i = readOffset ; i < inBuffer ; i ++ ) { if ( buffer [ i ] == ( byte ) inByte ) { found = i ; break ; } } if ( found == - 1 ) { return null ; } int toCopy = found - readOffset + 1 ; byte [ ] dest = new byte [ toCopy ] ; System . arraycopy ( buffer , readOffset , dest , 0 , toCopy ) ; readOffset += toCopy ; if ( inBuffer == readOffset ) { inBuffer = 0 ; readOffset = 0 ; } return dest ; } } public int readBytesUntil ( int inByte , byte [ ] dest ) { if ( inBuffer == readOffset ) { return 0 ; } synchronized ( buffer ) { int found = - 1 ; for ( int i = readOffset ; i < inBuffer ; i ++ ) { if ( buffer [ i ] == ( byte ) inByte ) { found = i ; break ; } } if ( found == - 1 ) { return 0 ; } int toCopy = found - readOffset + 1 ; if ( dest . length < toCopy ) { System . err . println ( "The buffer passed to readBytesUntil() is to small " + "to contain " + toCopy + " bytes up to and including " + "char " + ( byte ) inByte ) ; return - 1 ; } System . arraycopy ( buffer , readOffset , dest , 0 , toCopy ) ; readOffset += toCopy ; if ( inBuffer == readOffset ) { inBuffer = 0 ; readOffset = 0 ; } return toCopy ; } } public char readChar ( ) { return ( char ) read ( ) ; } public String readString ( ) { if ( inBuffer == readOffset ) { return null ; } return new String ( readBytes ( ) ) ; } public String readStringUntil ( int inByte ) { byte temp [ ] = readBytesUntil ( inByte ) ; if ( temp == null ) { return null ; } else { return new String ( temp ) ; } } public void serialEvent ( SerialPortEvent event ) { if ( event . getEventType ( ) == SerialPortEvent . RXCHAR ) { int toRead ; try { while ( 0 < ( toRead = port . getInputBufferBytesCount ( ) ) ) { synchronized ( buffer ) { if ( serialEventMethod != null ) { toRead = 1 ; } if ( buffer . length < inBuffer + toRead ) { byte temp [ ] = new byte [ buffer . length < < 1 ] ; System . arraycopy ( buffer , 0 , temp , 0 , inBuffer ) ; buffer = temp ; } byte [ ] read = port . readBytes ( toRead ) ; System . arraycopy ( read , 0 , buffer , inBuffer , read . length ) ; inBuffer += read . length ; } if ( serialEventMethod != null ) { if ( ( 0 < bufferUntilSize && bufferUntilSize <= inBuffer - readOffset ) || ( 0 == bufferUntilSize && bufferUntilByte == buffer [ inBuffer - 1 ] ) ) { try { serialEventMethod . invoke ( parent , this ) ; } catch ( Exception e ) { System . err . println ( "Error, disabling serialEvent() for " + port . getPortName ( ) ) ; System . err . println ( e . getLocalizedMessage ( ) ) ; serialEventMethod = null ; } } } invokeSerialAvailable = true ; } } catch ( SerialPortException e ) { throw new RuntimeException ( "Error reading from serial port " + e . getPortName ( ) + ": " + e . getExceptionType ( ) ) ; } } } public void setDTR ( boolean state ) { try { port . setDTR ( state ) ; } catch ( SerialPortException e ) { throw new RuntimeException ( "Error setting the DTR line: " + e . getExceptionType ( ) ) ; } } public void setRTS ( boolean state ) { try { port . setRTS ( state ) ; } catch ( SerialPortException e ) { throw new RuntimeException ( "Error setting the RTS line: " + e . getExceptionType ( ) ) ; } } public void stop ( ) { try { port . closePort ( ) ; } catch ( SerialPortException e ) { } inBuffer = 0 ; readOffset = 0 ; } public void write ( byte [ ] src ) { try { port . writeBytes ( src ) ; } catch ( SerialPortException e ) { throw new RuntimeException ( "Error writing to serial port " + e . getPortName ( ) + ": " + e . getExceptionType ( ) ) ; } } public void write ( int src ) { try { port . writeInt ( src ) ; } catch ( SerialPortException e ) { throw new RuntimeException ( "Error writing to serial port " + e . getPortName ( ) + ": " + e . getExceptionType ( ) ) ; } } public void write ( String src ) { try { port . writeString ( src ) ; } catch ( SerialPortException e ) { throw new RuntimeException ( "Error writing to serial port " + e . getPortName ( ) + ": " + e . getExceptionType ( ) ) ; } } }
import processing . core . PApplet ; public class WriteSVG extends PApplet { public void settings ( ) { size ( 600 , 400 , SVG , desktopPath ( "frame-####.svg" ) ) ; } public void draw ( ) { background ( random ( 255 ) ) ; stroke ( random ( 255 ) ) ; strokeWeight ( 20 ) ; line ( random ( width ) , random ( height ) , random ( width ) , random ( height ) ) ; if ( frameCount == 5 ) exit ( ) ; } static public void main ( String [ ] args ) { PApplet . main ( new String [ ] { "WriteSVG" } ) ; } }
package processing . svg ; import java . awt . Dimension ; import java . io . * ; import org . apache . batik . svggen . SVGGraphics2D ; import org . apache . batik . svggen . SVGGraphics2DIOException ; import org . apache . batik . dom . GenericDOMImplementation ; import org . w3c . dom . Document ; import org . w3c . dom . DOMImplementation ; import processing . core . * ; public class PGraphicsSVG extends PGraphicsJava2D { protected File file ; protected OutputStream output ; public PGraphicsSVG ( ) { } public void setPath ( String path ) { this . path = path ; if ( path != null ) { file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = null ; } } if ( file == null ) { throw new RuntimeException ( "PGraphicsSVG requires an absolute path " + "for the location of the output file." ) ; } } public void setOutput ( OutputStream output ) { this . output = output ; } @ Override public PSurface createSurface ( ) { return surface = new PSurfaceNone ( this ) ; } protected void defaultSettings ( ) { super . defaultSettings ( ) ; textMode = SHAPE ; } public void beginDraw ( ) { DOMImplementation domImpl = GenericDOMImplementation . getDOMImplementation ( ) ; String ns = "http://www.w3.org/2000/svg" ; Document document = domImpl . createDocument ( ns , "svg" , null ) ; g2 = new SVGGraphics2D ( document ) ; ( ( SVGGraphics2D ) g2 ) . setSVGCanvasSize ( new Dimension ( width , height ) ) ; checkSettings ( ) ; resetMatrix ( ) ; vertexCount = 0 ; pushMatrix ( ) ; } public void endDraw ( ) { popMatrix ( ) ; if ( output == null ) { if ( path == null ) { throw new RuntimeException ( "setOutput() or setPath() must be " + "used with the SVG renderer" ) ; } else { File file = parent . saveFile ( parent . insertFrame ( path ) ) ; try { output = new FileOutputStream ( file ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ) ; } } } boolean useCSS = true ; Writer writer = PApplet . createWriter ( output ) ; try { ( ( SVGGraphics2D ) g2 ) . stream ( writer , useCSS ) ; } catch ( SVGGraphics2DIOException e ) { e . printStackTrace ( ) ; } try { writer . flush ( ) ; writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { output = null ; } } public void dispose ( ) { } @ Override public boolean displayable ( ) { return false ; } public void loadPixels ( ) { nope ( "loadPixels" ) ; } public void updatePixels ( ) { nope ( "updatePixels" ) ; } public void updatePixels ( int x , int y , int c , int d ) { nope ( "updatePixels" ) ; } public int get ( int x , int y ) { nope ( "get" ) ; return 0 ; } public PImage get ( int x , int y , int c , int d ) { nope ( "get" ) ; return null ; } public PImage get ( ) { nope ( "get" ) ; return null ; } public void set ( int x , int y , int argb ) { nope ( "set" ) ; } public void set ( int x , int y , PImage image ) { nope ( "set" ) ; } public void mask ( int alpha [ ] ) { nope ( "mask" ) ; } public void mask ( PImage alpha ) { nope ( "mask" ) ; } public void filter ( int kind ) { nope ( "filter" ) ; } public void filter ( int kind , float param ) { nope ( "filter" ) ; } public void copy ( int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 , int dx2 , int dy2 ) { nope ( "copy" ) ; } public void copy ( PImage src , int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 , int dx2 , int dy2 ) { nope ( "copy" ) ; } public void blend ( int sx , int sy , int dx , int dy , int mode ) { nope ( "blend" ) ; } public void blend ( PImage src , int sx , int sy , int dx , int dy , int mode ) { nope ( "blend" ) ; } public void blend ( int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 , int dx2 , int dy2 , int mode ) { nope ( "blend" ) ; } public void blend ( PImage src , int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 , int dx2 , int dy2 , int mode ) { nope ( "blend" ) ; } public boolean save ( String filename ) { nope ( "save" ) ; return false ; } protected void nope ( String function ) { throw new RuntimeException ( "No " + function + "() for PGraphicsSVG" ) ; } }
package processing . pdf ; import java . awt . Font ; import java . awt . Graphics2D ; import java . awt . Image ; import java . io . * ; import java . util . * ; import com . lowagie . text . * ; import com . lowagie . text . pdf . * ; import processing . core . * ; public class PGraphicsPDF extends PGraphicsJava2D { protected File file ; protected OutputStream output ; protected Document document ; protected PdfWriter writer ; protected PdfContentByte content ; static protected DefaultFontMapper mapper ; static protected String [ ] fontList ; public void setPath ( String path ) { this . path = path ; if ( path != null ) { file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = null ; } } if ( file == null ) { throw new RuntimeException ( "PGraphicsPDF requires an absolute path " + "for the location of the output file." ) ; } } public void setOutput ( OutputStream output ) { this . output = output ; } @ Override public PSurface createSurface ( ) { return surface = new PSurfaceNone ( this ) ; } @ Override protected void defaultSettings ( ) { super . defaultSettings ( ) ; textMode = SHAPE ; } public void beginDraw ( ) { if ( document == null ) { document = new Document ( new Rectangle ( width , height ) ) ; boolean missingPath = false ; try { if ( file != null ) { output = new BufferedOutputStream ( new FileOutputStream ( file ) , 16384 ) ; } else if ( output == null ) { missingPath = true ; throw new RuntimeException ( "PGraphicsPDF requires a path " + "for the location of the output file." ) ; } writer = PdfWriter . getInstance ( document , output ) ; document . open ( ) ; content = writer . getDirectContent ( ) ; } catch ( RuntimeException re ) { if ( missingPath ) { throw re ; } else { throw new RuntimeException ( "Problem saving the PDF file." , re ) ; } } catch ( FileNotFoundException fnfe ) { throw new RuntimeException ( "Can't save the PDF file to " + path , fnfe ) ; } catch ( DocumentException de ) { throw new RuntimeException ( "Error inside the PDF library." , de ) ; } g2 = content . createGraphicsShapes ( width , height ) ; } checkSettings ( ) ; resetMatrix ( ) ; vertexCount = 0 ; pushMatrix ( ) ; } static protected DefaultFontMapper getMapper ( ) { if ( mapper == null ) { mapper = new DefaultFontMapper ( ) ; if ( PApplet . platform == PConstants . MACOSX ) { try { String homeLibraryFonts = System . getProperty ( "user.home" ) + "/Library/Fonts" ; mapper . insertDirectory ( homeLibraryFonts ) ; } catch ( Exception e ) { } mapper . insertDirectory ( "/System/Library/Fonts" ) ; mapper . insertDirectory ( "/Library/Fonts" ) ; } else if ( PApplet . platform == PConstants . WINDOWS ) { File roots [ ] = File . listRoots ( ) ; for ( int i = 0 ; i < roots . length ; i ++ ) { if ( roots [ i ] . toString ( ) . startsWith ( "A:" ) ) { continue ; } File folder = new File ( roots [ i ] , "WINDOWS/Fonts" ) ; if ( folder . exists ( ) ) { mapper . insertDirectory ( folder . getAbsolutePath ( ) ) ; break ; } folder = new File ( roots [ i ] , "WINNT/Fonts" ) ; if ( folder . exists ( ) ) { mapper . insertDirectory ( folder . getAbsolutePath ( ) ) ; break ; } } } else if ( PApplet . platform == PConstants . LINUX ) { checkDir ( "/usr/share/fonts/" , mapper ) ; checkDir ( "/usr/local/share/fonts/" , mapper ) ; checkDir ( System . getProperty ( "user.home" ) + "/.fonts" , mapper ) ; } } return mapper ; } static protected void checkDir ( String path , DefaultFontMapper mapper ) { File folder = new File ( path ) ; if ( folder . exists ( ) ) { mapper . insertDirectory ( path ) ; traverseDir ( folder , mapper ) ; } } static protected void traverseDir ( File folder , DefaultFontMapper mapper ) { File [ ] files = folder . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . isDirectory ( ) ) { mapper . insertDirectory ( files [ i ] . getPath ( ) ) ; traverseDir ( new File ( files [ i ] . getPath ( ) ) , mapper ) ; } } } public void endDraw ( ) { popMatrix ( ) ; } protected static boolean fileExists ( File file ) { try { Process process = Runtime . getRuntime ( ) . exec ( new String [ ] { "cmd.exe" , "/c" , "dir" , file . getAbsolutePath ( ) } ) ; boolean haveExitCode = false ; int exitCode = - 1 ; InputStream out = process . getInputStream ( ) ; InputStream err = process . getErrorStream ( ) ; while ( ! haveExitCode ) { while ( out . read ( ) >= 0 ) { } while ( err . read ( ) >= 0 ) { } try { exitCode = process . exitValue ( ) ; haveExitCode = true ; } catch ( IllegalThreadStateException e ) { Thread . sleep ( 100 ) ; } } return exitCode == 0 ; } catch ( IOException e ) { System . out . println ( "Unable to check for file: " + file + " : " + e ) ; return false ; } catch ( InterruptedException e ) { System . out . println ( "Unable to check for file. Interrupted: " + file + " : " + e ) ; return false ; } } public void nextPage ( ) { PStyle savedStyle = getStyle ( ) ; endDraw ( ) ; g2 . dispose ( ) ; try { document . newPage ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } g2 = createGraphics ( ) ; beginDraw ( ) ; style ( savedStyle ) ; } protected Graphics2D createGraphics ( ) { if ( textMode == SHAPE ) { return content . createGraphicsShapes ( width , height ) ; } else if ( textMode == MODEL ) { return content . createGraphics ( width , height , getMapper ( ) ) ; } throw new RuntimeException ( "Invalid textMode() selected for PDF." ) ; } public void dispose ( ) { if ( document != null ) { g2 . dispose ( ) ; document . close ( ) ; document = null ; } } public boolean displayable ( ) { return false ; } protected void imageImpl ( PImage image , float x1 , float y1 , float x2 , float y2 , int u1 , int v1 , int u2 , int v2 ) { pushMatrix ( ) ; translate ( x1 , y1 ) ; int imageWidth = image . width ; int imageHeight = image . height ; scale ( ( x2 - x1 ) / imageWidth , ( y2 - y1 ) / imageHeight ) ; if ( u2 - u1 == imageWidth && v2 - v1 == imageHeight ) { g2 . drawImage ( ( Image ) image . getNative ( ) , 0 , 0 , null ) ; } else { PImage tmp = image . get ( u1 , v1 , u2 - u1 , v2 - v1 ) ; g2 . drawImage ( ( Image ) tmp . getNative ( ) , 0 , 0 , null ) ; } popMatrix ( ) ; } public void textFont ( PFont which ) { super . textFont ( which ) ; checkFont ( ) ; } public void textMode ( int mode ) { if ( textMode != mode ) { if ( mode == SHAPE ) { textMode = SHAPE ; g2 . dispose ( ) ; g2 = createGraphics ( ) ; } else if ( mode == MODEL ) { textMode = MODEL ; g2 . dispose ( ) ; g2 = createGraphics ( ) ; } else if ( mode == SCREEN ) { throw new RuntimeException ( "textMode(SCREEN) not supported with PDF" ) ; } else { throw new RuntimeException ( "That textMode() does not exist" ) ; } } } protected void textLineImpl ( char buffer [ ] , int start , int stop , float x , float y ) { checkFont ( ) ; super . textLineImpl ( buffer , start , stop , x , y ) ; } public void loadPixels ( ) { nope ( "loadPixels" ) ; } public void updatePixels ( ) { nope ( "updatePixels" ) ; } public void updatePixels ( int x , int y , int c , int d ) { nope ( "updatePixels" ) ; } public int get ( int x , int y ) { nope ( "get" ) ; return 0 ; } public PImage get ( int x , int y , int c , int d ) { nope ( "get" ) ; return null ; } public PImage get ( ) { nope ( "get" ) ; return null ; } public void set ( int x , int y , int argb ) { nope ( "set" ) ; } public void set ( int x , int y , PImage image ) { nope ( "set" ) ; } public void mask ( int alpha [ ] ) { nope ( "mask" ) ; } public void mask ( PImage alpha ) { nope ( "mask" ) ; } public void filter ( int kind ) { nope ( "filter" ) ; } public void filter ( int kind , float param ) { nope ( "filter" ) ; } public void copy ( int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 , int dx2 , int dy2 ) { nope ( "copy" ) ; } public void copy ( PImage src , int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 , int dx2 , int dy2 ) { nope ( "copy" ) ; } public void blend ( int sx , int sy , int dx , int dy , int mode ) { nope ( "blend" ) ; } public void blend ( PImage src , int sx , int sy , int dx , int dy , int mode ) { nope ( "blend" ) ; } public void blend ( int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 , int dx2 , int dy2 , int mode ) { nope ( "blend" ) ; } public void blend ( PImage src , int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 , int dx2 , int dy2 , int mode ) { nope ( "blend" ) ; } public boolean save ( String filename ) { nope ( "save" ) ; return false ; } public void addFonts ( String directory ) { mapper . insertDirectory ( directory ) ; } protected void checkFont ( ) { Font awtFont = ( Font ) textFont . getNative ( ) ; if ( awtFont == null ) { throw new RuntimeException ( "Use createFont() instead of loadFont() " + "when drawing text using the PDF library." ) ; } else if ( textMode != SHAPE ) { if ( textFont . isStream ( ) ) { throw new RuntimeException ( "Use textMode(SHAPE) with PDF when loading " + ".ttf and .otf files with createFont()." ) ; } else if ( mapper . getAliases ( ) . get ( textFont . getName ( ) ) == null ) { if ( textFont . getName ( ) . equals ( "Lucida Sans" ) ) { throw new RuntimeException ( "Use textMode(SHAPE) with the default " + "font when exporting to PDF." ) ; } else { throw new RuntimeException ( "Use textMode(SHAPE) with " + "" + textFont . getName ( ) + " " + "when exporting to PDF." ) ; } } } } static public String [ ] listFonts ( ) { if ( fontList == null ) { HashMap < ? , ? > map = getMapper ( ) . getAliases ( ) ; fontList = new String [ map . size ( ) ] ; int count = 0 ; for ( Object key : map . keySet ( ) ) { fontList [ count ++ ] = ( String ) key ; } fontList = PApplet . sort ( fontList ) ; } return fontList ; } protected void nope ( String function ) { throw new RuntimeException ( "No " + function + "() for " + getClass ( ) . getSimpleName ( ) ) ; } }
package processing . dxf ; import java . io . * ; import processing . core . * ; public class RawDXF extends PGraphics { File file ; PrintWriter writer ; int currentLayer ; public RawDXF ( ) { } public void setPath ( String path ) { this . path = path ; if ( path != null ) { file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) file = null ; } if ( file == null ) { throw new RuntimeException ( "DXF export requires an absolute path " + "for the location of the output file." ) ; } } protected void allocate ( ) { setLayer ( 0 ) ; } public void dispose ( ) { writeFooter ( ) ; writer . flush ( ) ; writer . close ( ) ; writer = null ; } public boolean displayable ( ) { return false ; } public boolean is2D ( ) { return false ; } public boolean is3D ( ) { return true ; } public void beginDraw ( ) { if ( writer == null ) { try { writer = new PrintWriter ( new FileWriter ( file ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } writeHeader ( ) ; } } public void endDraw ( ) { writer . flush ( ) ; } public void setLayer ( int layer ) { currentLayer = layer ; } private void writeHeader ( ) { writer . println ( "0" ) ; writer . println ( "SECTION" ) ; writer . println ( "2" ) ; writer . println ( "ENTITIES" ) ; } private void writeFooter ( ) { writer . println ( "0" ) ; writer . println ( "ENDSEC" ) ; writer . println ( "0" ) ; writer . println ( "EOF" ) ; } public void write ( String cmd , float val ) { writer . println ( cmd ) ; writer . println ( val ) ; } public void println ( String what ) { writer . println ( what ) ; } protected void writeLine ( int index1 , int index2 ) { writer . println ( "0" ) ; writer . println ( "LINE" ) ; writer . println ( "8" ) ; writer . println ( String . valueOf ( currentLayer ) ) ; write ( "10" , vertices [ index1 ] [ X ] ) ; write ( "20" , vertices [ index1 ] [ Y ] ) ; write ( "30" , vertices [ index1 ] [ Z ] ) ; write ( "11" , vertices [ index2 ] [ X ] ) ; write ( "21" , vertices [ index2 ] [ Y ] ) ; write ( "31" , vertices [ index2 ] [ Z ] ) ; } protected void writeTriangle ( ) { writer . println ( "0" ) ; writer . println ( "3DFACE" ) ; writer . println ( "8" ) ; writer . println ( String . valueOf ( currentLayer ) ) ; write ( "10" , vertices [ 0 ] [ X ] ) ; write ( "20" , vertices [ 0 ] [ Y ] ) ; write ( "30" , vertices [ 0 ] [ Z ] ) ; write ( "11" , vertices [ 1 ] [ X ] ) ; write ( "21" , vertices [ 1 ] [ Y ] ) ; write ( "31" , vertices [ 1 ] [ Z ] ) ; write ( "12" , vertices [ 2 ] [ X ] ) ; write ( "22" , vertices [ 2 ] [ Y ] ) ; write ( "32" , vertices [ 2 ] [ Z ] ) ; write ( "13" , vertices [ 2 ] [ X ] + EPSILON ) ; write ( "23" , vertices [ 2 ] [ Y ] + EPSILON ) ; write ( "33" , vertices [ 2 ] [ Z ] + EPSILON ) ; vertexCount = 0 ; } public void beginShape ( int kind ) { shape = kind ; if ( ( shape != LINES ) && ( shape != TRIANGLES ) && ( shape != POLYGON ) ) { String err = "RawDXF can only be used with beginRaw(), " + "because it only supports lines and triangles" ; throw new RuntimeException ( err ) ; } if ( ( shape == POLYGON ) && fill ) { throw new RuntimeException ( "DXF Export only supports non-filled shapes." ) ; } vertexCount = 0 ; } public void vertex ( float x , float y ) { vertex ( x , y , 0 ) ; } public void vertex ( float x , float y , float z ) { float vertex [ ] = vertices [ vertexCount ] ; vertex [ X ] = x ; vertex [ Y ] = y ; vertex [ Z ] = z ; if ( fill ) { vertex [ R ] = fillR ; vertex [ G ] = fillG ; vertex [ B ] = fillB ; vertex [ A ] = fillA ; } if ( stroke ) { vertex [ SR ] = strokeR ; vertex [ SG ] = strokeG ; vertex [ SB ] = strokeB ; vertex [ SA ] = strokeA ; vertex [ SW ] = strokeWeight ; } if ( textureImage != null ) { vertex [ U ] = textureU ; vertex [ V ] = textureV ; } vertexCount ++ ; if ( ( shape == LINES ) && ( vertexCount == 2 ) ) { writeLine ( 0 , 1 ) ; vertexCount = 0 ; } else if ( ( shape == TRIANGLES ) && ( vertexCount == 3 ) ) { writeTriangle ( ) ; } } public void endShape ( int mode ) { if ( shape == POLYGON ) { for ( int i = 0 ; i < vertexCount - 1 ; i ++ ) { writeLine ( i , i + 1 ) ; } if ( mode == CLOSE ) { writeLine ( vertexCount - 1 , 0 ) ; } } } }
package processing . net ; import processing . core . * ; import java . io . * ; import java . lang . reflect . * ; import java . net . * ; public class Client implements Runnable { PApplet parent ; Method clientEventMethod ; Method disconnectEventMethod ; Thread thread ; Socket socket ; int port ; String host ; public InputStream input ; public OutputStream output ; byte buffer [ ] = new byte [ 32768 ] ; int bufferIndex ; int bufferLast ; boolean disposeRegistered = false ; public Client ( PApplet parent , String host , int port ) { this . parent = parent ; this . host = host ; this . port = port ; try { socket = new Socket ( this . host , this . port ) ; input = socket . getInputStream ( ) ; output = socket . getOutputStream ( ) ; thread = new Thread ( this ) ; thread . start ( ) ; parent . registerMethod ( "dispose" , this ) ; disposeRegistered = true ; try { clientEventMethod = parent . getClass ( ) . getMethod ( "clientEvent" , new Class [ ] { Client . class } ) ; } catch ( Exception e ) { } try { disconnectEventMethod = parent . getClass ( ) . getMethod ( "disconnectEvent" , new Class [ ] { Client . class } ) ; } catch ( Exception e ) { } } catch ( ConnectException ce ) { ce . printStackTrace ( ) ; dispose ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; dispose ( ) ; } } public Client ( PApplet parent , Socket socket ) throws IOException { this . parent = parent ; this . socket = socket ; input = socket . getInputStream ( ) ; output = socket . getOutputStream ( ) ; thread = new Thread ( this ) ; thread . start ( ) ; try { disconnectEventMethod = parent . getClass ( ) . getMethod ( "disconnectEvent" , new Class [ ] { Client . class } ) ; } catch ( Exception e ) { } } public void stop ( ) { if ( disconnectEventMethod != null && thread != null ) { try { disconnectEventMethod . invoke ( parent , new Object [ ] { this } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; disconnectEventMethod = null ; } } if ( disposeRegistered ) { parent . unregisterMethod ( "dispose" , this ) ; disposeRegistered = false ; } dispose ( ) ; } public void dispose ( ) { thread = null ; try { if ( input != null ) { input . close ( ) ; input = null ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } try { if ( output != null ) { output . close ( ) ; output = null ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } try { if ( socket != null ) { socket . close ( ) ; socket = null ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void run ( ) { while ( Thread . currentThread ( ) == thread ) { try { while ( input != null ) { int value ; try { value = input . read ( ) ; } catch ( SocketException e ) { System . err . println ( "Client SocketException: " + e . getMessage ( ) ) ; stop ( ) ; return ; } if ( value == - 1 ) { System . err . println ( "Client got end-of-stream." ) ; stop ( ) ; return ; } synchronized ( buffer ) { if ( bufferLast == buffer . length ) { byte temp [ ] = new byte [ bufferLast < < 1 ] ; System . arraycopy ( buffer , 0 , temp , 0 , bufferLast ) ; buffer = temp ; } buffer [ bufferLast ++ ] = ( byte ) value ; } if ( clientEventMethod != null ) { try { clientEventMethod . invoke ( parent , new Object [ ] { this } ) ; } catch ( Exception e ) { System . err . println ( "error, disabling clientEvent() for " + host ) ; e . printStackTrace ( ) ; clientEventMethod = null ; } } } } catch ( IOException e ) { e . printStackTrace ( ) ; } } } public boolean active ( ) { return ( thread != null ) ; } public String ip ( ) { if ( socket != null ) { return socket . getInetAddress ( ) . getHostAddress ( ) ; } return null ; } public int available ( ) { return ( bufferLast - bufferIndex ) ; } public void clear ( ) { bufferLast = 0 ; bufferIndex = 0 ; } public int read ( ) { if ( bufferIndex == bufferLast ) return - 1 ; synchronized ( buffer ) { int outgoing = buffer [ bufferIndex ++ ] & 0xff ; if ( bufferIndex == bufferLast ) { bufferIndex = 0 ; bufferLast = 0 ; } return outgoing ; } } public char readChar ( ) { if ( bufferIndex == bufferLast ) return ( char ) ( - 1 ) ; return ( char ) read ( ) ; } public byte [ ] readBytes ( ) { if ( bufferIndex == bufferLast ) return null ; synchronized ( buffer ) { int length = bufferLast - bufferIndex ; byte outgoing [ ] = new byte [ length ] ; System . arraycopy ( buffer , bufferIndex , outgoing , 0 , length ) ; bufferIndex = 0 ; bufferLast = 0 ; return outgoing ; } } public int readBytes ( byte bytebuffer [ ] ) { if ( bufferIndex == bufferLast ) return 0 ; synchronized ( buffer ) { int length = bufferLast - bufferIndex ; if ( length > bytebuffer . length ) length = bytebuffer . length ; System . arraycopy ( buffer , bufferIndex , bytebuffer , 0 , length ) ; bufferIndex += length ; if ( bufferIndex == bufferLast ) { bufferIndex = 0 ; bufferLast = 0 ; } return length ; } } public byte [ ] readBytesUntil ( int interesting ) { if ( bufferIndex == bufferLast ) return null ; byte what = ( byte ) interesting ; synchronized ( buffer ) { int found = - 1 ; for ( int k = bufferIndex ; k < bufferLast ; k ++ ) { if ( buffer [ k ] == what ) { found = k ; break ; } } if ( found == - 1 ) return null ; int length = found - bufferIndex + 1 ; byte outgoing [ ] = new byte [ length ] ; System . arraycopy ( buffer , bufferIndex , outgoing , 0 , length ) ; bufferIndex += length ; if ( bufferIndex == bufferLast ) { bufferIndex = 0 ; bufferLast = 0 ; } return outgoing ; } } public int readBytesUntil ( int interesting , byte byteBuffer [ ] ) { if ( bufferIndex == bufferLast ) return 0 ; byte what = ( byte ) interesting ; synchronized ( buffer ) { int found = - 1 ; for ( int k = bufferIndex ; k < bufferLast ; k ++ ) { if ( buffer [ k ] == what ) { found = k ; break ; } } if ( found == - 1 ) return 0 ; int length = found - bufferIndex + 1 ; if ( length > byteBuffer . length ) { System . err . println ( "readBytesUntil() byte buffer is" + " too small for the " + length + " bytes up to and including char " + interesting ) ; return - 1 ; } System . arraycopy ( buffer , bufferIndex , byteBuffer , 0 , length ) ; bufferIndex += length ; if ( bufferIndex == bufferLast ) { bufferIndex = 0 ; bufferLast = 0 ; } return length ; } } public String readString ( ) { if ( bufferIndex == bufferLast ) return null ; return new String ( readBytes ( ) ) ; } public String readStringUntil ( int interesting ) { byte b [ ] = readBytesUntil ( interesting ) ; if ( b == null ) return null ; return new String ( b ) ; } public void write ( int data ) { try { output . write ( data & 0xff ) ; output . flush ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; stop ( ) ; } } public void write ( byte data [ ] ) { try { output . write ( data ) ; output . flush ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; stop ( ) ; } } public void write ( String data ) { write ( data . getBytes ( ) ) ; } }
package processing . net ; import processing . core . * ; import java . io . * ; import java . lang . reflect . * ; import java . net . * ; public class Server implements Runnable { PApplet parent ; Method serverEventMethod ; Thread thread ; ServerSocket server ; int port ; public int clientCount ; public Client [ ] clients ; public Server ( PApplet parent , int port ) { this ( parent , port , null ) ; } public Server ( PApplet parent , int port , String host ) { this . parent = parent ; this . port = port ; try { if ( host == null ) { server = new ServerSocket ( this . port ) ; } else { server = new ServerSocket ( this . port , 10 , InetAddress . getByName ( host ) ) ; } clients = new Client [ 10 ] ; thread = new Thread ( this ) ; thread . start ( ) ; parent . registerMethod ( "dispose" , this ) ; try { serverEventMethod = parent . getClass ( ) . getMethod ( "serverEvent" , new Class [ ] { Server . class , Client . class } ) ; } catch ( Exception e ) { } } catch ( IOException e ) { thread = null ; throw new RuntimeException ( e ) ; } } public void disconnect ( Client client ) { client . stop ( ) ; int index = clientIndex ( client ) ; if ( index != - 1 ) { removeIndex ( index ) ; } } protected void removeIndex ( int index ) { clientCount -- ; for ( int i = index ; i < clientCount ; i ++ ) { clients [ i ] = clients [ i + 1 ] ; } clients [ clientCount ] = null ; } protected void disconnectAll ( ) { synchronized ( clients ) { for ( int i = 0 ; i < clientCount ; i ++ ) { try { clients [ i ] . stop ( ) ; } catch ( Exception e ) { } clients [ i ] = null ; } clientCount = 0 ; } } protected void addClient ( Client client ) { if ( clientCount == clients . length ) { clients = ( Client [ ] ) PApplet . expand ( clients ) ; } clients [ clientCount ++ ] = client ; } protected int clientIndex ( Client client ) { for ( int i = 0 ; i < clientCount ; i ++ ) { if ( clients [ i ] == client ) { return i ; } } return - 1 ; } public boolean active ( ) { return thread != null ; } static public String ip ( ) { try { return InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; return null ; } } int lastAvailable = - 1 ; public Client available ( ) { synchronized ( clients ) { int index = lastAvailable + 1 ; if ( index >= clientCount ) index = 0 ; for ( int i = 0 ; i < clientCount ; i ++ ) { int which = ( index + i ) % clientCount ; Client client = clients [ which ] ; if ( ! client . active ( ) ) { removeIndex ( which ) ; i -- ; which -- ; } if ( client . available ( ) > 0 ) { lastAvailable = which ; return client ; } } } return null ; } public void stop ( ) { dispose ( ) ; } public void dispose ( ) { thread = null ; if ( clients != null ) { disconnectAll ( ) ; clientCount = 0 ; clients = null ; } try { if ( server != null ) { server . close ( ) ; server = null ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } public void run ( ) { while ( Thread . currentThread ( ) == thread ) { try { Socket socket = server . accept ( ) ; Client client = new Client ( parent , socket ) ; synchronized ( clients ) { addClient ( client ) ; if ( serverEventMethod != null ) { try { serverEventMethod . invoke ( parent , new Object [ ] { this , client } ) ; } catch ( Exception e ) { System . err . println ( "Disabling serverEvent() for port " + port ) ; e . printStackTrace ( ) ; serverEventMethod = null ; } } } } catch ( SocketException e ) { System . err . println ( "Server SocketException: " + e . getMessage ( ) ) ; thread = null ; } catch ( IOException e ) { e . printStackTrace ( ) ; thread = null ; } try { Thread . sleep ( 8 ) ; } catch ( InterruptedException ex ) { } } } public void write ( int data ) { int index = 0 ; while ( index < clientCount ) { if ( clients [ index ] . active ( ) ) { clients [ index ] . write ( data ) ; index ++ ; } else { removeIndex ( index ) ; } } } public void write ( byte data [ ] ) { int index = 0 ; while ( index < clientCount ) { if ( clients [ index ] . active ( ) ) { clients [ index ] . write ( data ) ; index ++ ; } else { removeIndex ( index ) ; } } } public void write ( String data ) { int index = 0 ; while ( index < clientCount ) { if ( clients [ index ] . active ( ) ) { clients [ index ] . write ( data ) ; index ++ ; } else { removeIndex ( index ) ; } } } }
package ch . randelshofer . media . mp3 ; import java . io . BufferedInputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileInputStream ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . PushbackInputStream ; import java . util . HashMap ; import javax . sound . sampled . AudioFormat ; public class MP3ElementaryInputStream extends FilterInputStream { public final static AudioFormat . Encoding MP3 = new AudioFormat . Encoding ( "MP3" ) ; private Frame frame ; private long pos ; private final static int [ ] [ ] BIT_RATES = { { - 1 , - 1 , - 1 , - 1 , - 1 } , { 32 , 32 , 32 , 32 , 8 } , { 64 , 48 , 40 , 48 , 16 } , { 96 , 56 , 48 , 56 , 24 } , { 128 , 64 , 56 , 64 , 32 } , { 160 , 80 , 64 , 80 , 40 } , { 192 , 96 , 80 , 96 , 48 } , { 224 , 112 , 96 , 112 , 56 } , { 256 , 128 , 112 , 128 , 64 } , { 288 , 160 , 128 , 144 , 80 } , { 320 , 192 , 160 , 160 , 96 } , { 352 , 224 , 192 , 176 , 112 } , { 384 , 256 , 224 , 192 , 128 } , { 416 , 320 , 256 , 224 , 144 } , { 448 , 384 , 320 , 256 , 160 } , { - 2 , - 2 , - 2 , - 2 , - 2 } , } ; private final static int [ ] [ ] SAMPLE_RATES = { { 44100 , 22050 , 11025 } , { 48000 , 24000 , 12000 } , { 32000 , 16000 , 8000 } , { - 1 , - 1 , - 1 } , } ; public static class Frame { private int header ; private int crc ; private int bodySize ; private long bodyOffset ; public Frame ( int header ) { this . header = header ; } public int getHeader ( ) { return header ; } public int getVersion ( ) { switch ( getVersionCode ( ) ) { case 0 : return 25 ; case 2 : return 2 ; case 3 : return 1 ; default : return - 1 ; } } public int getVersionCode ( ) { return ( header > > > 19 ) & 3 ; } public int getLayer ( ) { switch ( getLayerCode ( ) ) { case 1 : return 3 ; case 2 : return 2 ; case 3 : return 1 ; default : return - 1 ; } } public int getLayerCode ( ) { return ( header > > > 17 ) & 3 ; } public int getBitRate ( ) { if ( getVersion ( ) < 0 || getLayer ( ) < 0 ) { return - 1 ; } int v = getVersion ( ) == 1 ? 0 : 3 ; int l = getVersion ( ) == 1 ? getLayer ( ) - 1 : ( getLayer ( ) == 1 ? 0 : 1 ) ; return BIT_RATES [ getBitRateCode ( ) ] [ v + l ] ; } public int getBitRateCode ( ) { return ( header > > > 12 ) & 15 ; } public boolean hasCRC ( ) { return ( ( header > > > 16 ) & 1 ) == 0 ; } public int getCRC ( ) { return crc ; } public boolean hasPadding ( ) { return ( ( header > > > 9 ) & 1 ) == 1 ; } public int getSampleRate ( ) { if ( getVersion ( ) < 0 || getLayer ( ) < 0 ) { return - 1 ; } int v = getVersion ( ) == 25 ? 2 : getVersion ( ) - 1 ; return SAMPLE_RATES [ getSampleRateCode ( ) ] [ v ] ; } public int getSampleRateCode ( ) { return ( header > > > 10 ) & 3 ; } public int getSampleCount ( ) { if ( getLayer ( ) < 0 ) { return - 1 ; } return ( getLayer ( ) == 1 ? 192 : 576 ) * getChannelCount ( ) ; } public int getChannelCount ( ) { return getChannelModeCode ( ) == 3 ? 1 : 2 ; } public int getSampleSize ( ) { return 16 ; } public int getChannelModeCode ( ) { return ( header > > > 6 ) & 3 ; } public byte [ ] headerToByteArray ( ) { byte [ ] data = new byte [ hasCRC ( ) ? 6 : 4 ] ; headerToByteArray ( data , 0 ) ; return data ; } public int headerToByteArray ( byte [ ] data , int offset ) { if ( data . length - offset < getHeaderSize ( ) ) { throw new IllegalArgumentException ( "data array is too small" ) ; } data [ offset + 0 ] = ( byte ) ( header > > > 24 ) ; data [ offset + 1 ] = ( byte ) ( header > > > 16 ) ; data [ offset + 2 ] = ( byte ) ( header > > > 8 ) ; data [ offset + 3 ] = ( byte ) ( header > > > 0 ) ; if ( hasCRC ( ) ) { data [ offset + 4 ] = ( byte ) ( crc > > > 8 ) ; data [ offset + 5 ] = ( byte ) ( crc > > > 0 ) ; } return getHeaderSize ( ) ; } public void writeHeader ( OutputStream out ) throws IOException { out . write ( ( header > > > 24 ) ) ; out . write ( ( header > > > 16 ) ) ; out . write ( ( header > > > 8 ) ) ; out . write ( ( header > > > 0 ) ) ; if ( hasCRC ( ) ) { out . write ( ( crc > > > 8 ) ) ; out . write ( ( crc > > > 0 ) ) ; } } public long getFrameOffset ( ) { return getBodyOffset ( ) - getHeaderSize ( ) ; } public int getFrameSize ( ) { return getHeaderSize ( ) + getBodySize ( ) ; } public long getHeaderOffset ( ) { return getFrameOffset ( ) ; } public int getHeaderSize ( ) { return hasCRC ( ) ? 6 : 4 ; } public long getSideInfoOffset ( ) { return bodyOffset ; } public int getSideInfoSize ( ) { return getChannelCount ( ) == 1 ? 17 : 32 ; } public long getBodyOffset ( ) { return bodyOffset ; } public int getBodySize ( ) { return bodySize ; } public int getPaddingSize ( ) { if ( hasPadding ( ) ) { return getLayer ( ) == 1 ? 4 : 1 ; } return 0 ; } private float getFrameRate ( ) { return ( float ) getSampleRate ( ) / getSampleCount ( ) ; } } public MP3ElementaryInputStream ( File file ) throws IOException { super ( new PushbackInputStream ( new BufferedInputStream ( new FileInputStream ( file ) ) , 6 ) ) ; } public MP3ElementaryInputStream ( InputStream in ) { super ( new PushbackInputStream ( in , 6 ) ) ; } public Frame getNextFrame ( ) throws IOException { while ( frame != null && pos < frame . getBodyOffset ( ) + frame . getBodySize ( ) ) { long skipped = skip ( frame . getBodyOffset ( ) + frame . getBodySize ( ) - pos ) ; if ( skipped < 0 ) { break ; } } while ( true ) { int b = read0 ( ) ; if ( b == - 1 ) { frame = null ; break ; } else if ( b == 255 ) { int h0 = b ; int h1 = read0 ( ) ; if ( h1 != - 1 && ( h1 & 0xe0 ) == 0xe0 ) { int h2 = read0 ( ) ; int h3 = read0 ( ) ; if ( h3 != - 1 ) { frame = new Frame ( ( h0 < < 24 ) | ( h1 < < 16 ) | ( h2 < < 8 ) | h3 ) ; if ( frame . getBitRate ( ) == - 1 || frame . getLayer ( ) == - 1 || frame . getSampleRate ( ) == - 1 ) { PushbackInputStream pin = ( PushbackInputStream ) in ; pin . unread ( h3 ) ; pin . unread ( h2 ) ; pin . unread ( h1 ) ; pos -= 3 ; continue ; } int crc0 = - 1 , crc1 = - 1 ; if ( frame . hasCRC ( ) ) { crc0 = read0 ( ) ; crc1 = read0 ( ) ; if ( crc1 == - 1 ) { throw new EOFException ( ) ; } frame . crc = ( crc0 < < 8 ) | crc1 ; } frame . bodyOffset = pos ; if ( frame . getBitRate ( ) <= 0 || frame . getSampleRate ( ) <= 0 ) { frame . bodySize = 0 ; } else if ( frame . getLayer ( ) == 1 ) { frame . bodySize = ( int ) ( ( 12000L * frame . getBitRate ( ) / frame . getSampleRate ( ) ) * 4 ) - frame . getHeaderSize ( ) + frame . getPaddingSize ( ) ; } else if ( frame . getLayer ( ) == 2 || frame . getLayer ( ) == 3 ) { if ( frame . getChannelCount ( ) == 1 ) { frame . bodySize = ( int ) ( 72000L * frame . getBitRate ( ) / ( frame . getSampleRate ( ) + frame . getPaddingSize ( ) ) ) - frame . getHeaderSize ( ) + frame . getPaddingSize ( ) ; } else { frame . bodySize = ( int ) ( 144000L * frame . getBitRate ( ) / ( frame . getSampleRate ( ) + frame . getPaddingSize ( ) ) ) - frame . getHeaderSize ( ) + frame . getPaddingSize ( ) ; } } PushbackInputStream pin = ( PushbackInputStream ) in ; if ( frame . hasCRC ( ) ) { pin . unread ( crc1 ) ; pin . unread ( crc0 ) ; pos -= 2 ; } pin . unread ( h3 ) ; pin . unread ( h2 ) ; pin . unread ( h1 ) ; pin . unread ( h0 ) ; pos -= 4 ; assert pos == frame . getFrameOffset ( ) : pos + "!=" + frame . getFrameOffset ( ) ; break ; } } } } return frame ; } public Frame getFrame ( ) { return frame ; } public AudioFormat getFormat ( ) { if ( frame == null ) { return null ; } else { HashMap < String , Object > properties = new HashMap < String , Object > ( ) ; properties . put ( "vbr" , true ) ; return new AudioFormat ( MP3 , frame . getSampleRate ( ) , frame . getSampleSize ( ) , frame . getChannelCount ( ) , frame . getFrameSize ( ) , frame . getFrameRate ( ) , true , properties ) ; } } private int read0 ( ) throws IOException { int b = super . read ( ) ; if ( b != - 1 ) { pos ++ ; } return b ; } @ Override public int read ( ) throws IOException { if ( frame == null || pos >= frame . getBodyOffset ( ) + frame . getBodySize ( ) ) { return - 1 ; } return read0 ( ) ; } @ Override public int read ( byte [ ] b , int off , int len ) throws IOException { if ( frame == null ) { return - 1 ; } int maxlen = ( int ) ( frame . getBodyOffset ( ) + frame . getBodySize ( ) - pos ) ; if ( maxlen < 1 ) { return - 1 ; } len = Math . min ( maxlen , len ) ; int count = super . read ( b , off , len ) ; if ( count != - 1 ) { pos += count ; } return count ; } public final void readFully ( byte b [ ] ) throws IOException { readFully ( b , 0 , b . length ) ; } public final void readFully ( byte b [ ] , int off , int len ) throws IOException { if ( len < 0 ) { throw new IndexOutOfBoundsException ( ) ; } int n = 0 ; while ( n < len ) { int count = in . read ( b , off + n , len - n ) ; if ( count < 0 ) { throw new EOFException ( ) ; } n += count ; pos += count ; } } @ Override public long skip ( long n ) throws IOException { if ( frame == null ) { return - 1 ; } int maxlen = ( int ) ( frame . getBodyOffset ( ) + frame . getBodySize ( ) - pos ) ; if ( maxlen < 1 ) { return - 1 ; } n = Math . min ( maxlen , n ) ; long skipped = in . skip ( n ) ; if ( skipped > 0 ) { pos += skipped ; } return skipped ; } public long getStreamPosition ( ) { return pos ; } }
package ch . randelshofer . media . mp3 ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import javax . sound . sampled . AudioFormat ; import javax . sound . sampled . AudioInputStream ; public class MP3AudioInputStream extends AudioInputStream { private MP3ElementaryInputStream in ; public MP3AudioInputStream ( File file ) throws IOException { this ( new BufferedInputStream ( new FileInputStream ( file ) ) ) ; } public MP3AudioInputStream ( InputStream in ) throws IOException { super ( null , new AudioFormat ( MP3ElementaryInputStream . MP3 , 44100 , 16 , 2 , 626 , 44100f / 1152f , true ) , - 1 ) ; this . in = new MP3ElementaryInputStream ( in ) ; if ( this . in . getNextFrame ( ) == null ) { throw new IOException ( "Stream is not an MP3 elementary stream" ) ; } } @ Override public int available ( ) throws IOException { return in . available ( ) ; } @ Override public AudioFormat getFormat ( ) { return in . getFormat ( ) ; } @ Override public long getFrameLength ( ) { return - 1 ; } @ Override public void close ( ) throws IOException { in . close ( ) ; } @ Override public int read ( ) throws IOException { throw new IOException ( "cannot read a single byte if frame size > 1" ) ; } @ Override public int read ( byte [ ] b , int off , int len ) throws IOException { if ( in . getFrame ( ) == null && in . getNextFrame ( ) == null ) { return - 1 ; } if ( in . getStreamPosition ( ) != in . getFrame ( ) . getFrameOffset ( ) ) { if ( in . getNextFrame ( ) == null ) { return - 1 ; } } int bytesRead = 0 ; int frameSize = in . getFrame ( ) . getFrameSize ( ) ; while ( len >= frameSize ) { in . readFully ( b , off , frameSize ) ; len -= frameSize ; bytesRead += frameSize ; off += frameSize ; if ( in . getNextFrame ( ) == null ) { break ; } frameSize = in . getFrame ( ) . getFrameSize ( ) ; } return bytesRead ; } @ Override public long skip ( long n ) throws IOException { return in . skip ( n ) ; } @ Override public void mark ( int readlimit ) { } @ Override public boolean markSupported ( ) { return false ; } @ Override public void reset ( ) throws IOException { throw new IOException ( "mark/reset not supported" ) ; } }
package ch . randelshofer . media . quicktime ; import java . io . IOException ; import java . io . OutputStream ; import ch . randelshofer . io . SeekableByteArrayOutputStream ; public class AppleRLEEncoder { private SeekableByteArrayOutputStream tmpSeek = new SeekableByteArrayOutputStream ( ) ; private DataAtomOutputStream tmp = new DataAtomOutputStream ( tmpSeek ) ; public void writeKey16 ( OutputStream out , short [ ] data , int width , int height , int offset , int scanlineStride ) throws IOException { tmpSeek . reset ( ) ; long headerPos = tmpSeek . getStreamPosition ( ) ; tmp . writeInt ( 0 ) ; tmp . writeShort ( 0x0000 ) ; int ymax = offset + height * scanlineStride ; for ( int y = offset ; y < ymax ; y += scanlineStride ) { int xy = y ; int xymax = y + width ; tmp . write ( 1 ) ; int literalCount = 0 ; int repeatCount = 0 ; for ( ; xy < xymax ; ++ xy ) { short v = data [ xy ] ; for ( repeatCount = 0 ; xy < xymax && repeatCount < 127 ; ++ xy , ++ repeatCount ) { if ( data [ xy ] != v ) { break ; } } xy -= repeatCount ; if ( repeatCount < 2 ) { literalCount ++ ; if ( literalCount == 127 ) { tmp . write ( literalCount ) ; tmp . writeShorts ( data , xy - literalCount + 1 , literalCount ) ; literalCount = 0 ; } } else { if ( literalCount > 0 ) { tmp . write ( literalCount ) ; tmp . writeShorts ( data , xy - literalCount , literalCount ) ; literalCount = 0 ; } tmp . write ( - repeatCount ) ; tmp . writeShort ( v ) ; xy += repeatCount - 1 ; } } if ( literalCount > 0 ) { tmp . write ( literalCount ) ; tmp . writeShorts ( data , xy - literalCount , literalCount ) ; literalCount = 0 ; } tmp . write ( - 1 ) ; } long pos = tmpSeek . getStreamPosition ( ) ; tmpSeek . seek ( headerPos ) ; tmp . writeInt ( ( int ) ( pos - headerPos ) ) ; tmpSeek . seek ( pos ) ; tmpSeek . toOutputStream ( out ) ; } public void writeDelta16 ( OutputStream out , short [ ] data , short [ ] prev , int width , int height , int offset , int scanlineStride ) throws IOException { tmpSeek . reset ( ) ; int ymin ; int ymax = offset + height * scanlineStride ; scanline : for ( ymin = offset ; ymin < ymax ; ymin += scanlineStride ) { int xy = ymin ; int xymax = ymin + width ; for ( ; xy < xymax ; ++ xy ) { if ( data [ xy ] != prev [ xy ] ) { break scanline ; } } } if ( ymin == ymax ) { tmp . writeInt ( 4 ) ; tmpSeek . toOutputStream ( out ) ; return ; } scanline : for ( ; ymax > ymin ; ymax -= scanlineStride ) { int xy = ymax - scanlineStride ; int xymax = ymax - scanlineStride + width ; for ( ; xy < xymax ; ++ xy ) { if ( data [ xy ] != prev [ xy ] ) { break scanline ; } } } long headerPos = tmpSeek . getStreamPosition ( ) ; tmp . writeInt ( 0 ) ; if ( ymin == offset && ymax == offset + height * scanlineStride ) { tmp . writeShort ( 0x0000 ) ; } else { tmp . writeShort ( 0x0008 ) ; tmp . writeShort ( ymin / scanlineStride ) ; tmp . writeShort ( 0 ) ; tmp . writeShort ( ( ymax - ymin + 1 ) / scanlineStride ) ; tmp . writeShort ( 0 ) ; } for ( int y = ymin ; y < ymax ; y += scanlineStride ) { int xy = y ; int xymax = y + width ; int skipCount = 0 ; for ( ; xy < xymax ; ++ xy , ++ skipCount ) { if ( data [ xy ] != prev [ xy ] ) { break ; } } if ( skipCount == width ) { tmp . write ( 1 ) ; tmp . write ( - 1 ) ; continue ; } tmp . write ( Math . min ( 255 , skipCount + 1 ) ) ; if ( skipCount > 254 ) { skipCount -= 254 ; while ( skipCount > 254 ) { tmp . write ( 0 ) ; tmp . write ( 255 ) ; skipCount -= 254 ; } tmp . write ( 0 ) ; tmp . write ( skipCount + 1 ) ; } int literalCount = 0 ; int repeatCount = 0 ; for ( ; xy < xymax ; ++ xy ) { for ( skipCount = 0 ; xy < xymax ; ++ xy , ++ skipCount ) { if ( data [ xy ] != prev [ xy ] ) { break ; } } xy -= skipCount ; short v = data [ xy ] ; for ( repeatCount = 0 ; xy < xymax && repeatCount < 127 ; ++ xy , ++ repeatCount ) { if ( data [ xy ] != v ) { break ; } } xy -= repeatCount ; if ( skipCount < 2 && xy + skipCount < xymax && repeatCount < 2 ) { literalCount ++ ; if ( literalCount == 127 ) { tmp . write ( literalCount ) ; tmp . writeShorts ( data , xy - literalCount + 1 , literalCount ) ; literalCount = 0 ; } } else { if ( literalCount > 0 ) { tmp . write ( literalCount ) ; tmp . writeShorts ( data , xy - literalCount , literalCount ) ; literalCount = 0 ; } if ( xy + skipCount == xymax ) { xy += skipCount - 1 ; } else if ( skipCount >= repeatCount ) { while ( skipCount > 254 ) { tmp . write ( 0 ) ; tmp . write ( 255 ) ; xy += 254 ; skipCount -= 254 ; } tmp . write ( 0 ) ; tmp . write ( skipCount + 1 ) ; xy += skipCount - 1 ; } else { tmp . write ( - repeatCount ) ; tmp . writeShort ( v ) ; xy += repeatCount - 1 ; } } } if ( literalCount > 0 ) { tmp . write ( literalCount ) ; tmp . writeShorts ( data , xy - literalCount , literalCount ) ; literalCount = 0 ; } tmp . write ( - 1 ) ; } long pos = tmpSeek . getStreamPosition ( ) ; tmpSeek . seek ( headerPos ) ; tmp . writeInt ( ( int ) ( pos - headerPos ) ) ; tmpSeek . seek ( pos ) ; tmpSeek . toOutputStream ( out ) ; } public void writeKey24 ( OutputStream out , int [ ] data , int width , int height , int offset , int scanlineStride ) throws IOException { tmpSeek . reset ( ) ; long headerPos = tmpSeek . getStreamPosition ( ) ; tmp . writeInt ( 0 ) ; tmp . writeShort ( 0x0000 ) ; int ymax = offset + height * scanlineStride ; for ( int y = offset ; y < ymax ; y += scanlineStride ) { int xy = y ; int xymax = y + width ; tmp . write ( 1 ) ; int literalCount = 0 ; int repeatCount = 0 ; for ( ; xy < xymax ; ++ xy ) { int v = data [ xy ] ; for ( repeatCount = 0 ; xy < xymax && repeatCount < 127 ; ++ xy , ++ repeatCount ) { if ( data [ xy ] != v ) { break ; } } xy -= repeatCount ; if ( repeatCount < 2 ) { literalCount ++ ; if ( literalCount > 126 ) { tmp . write ( literalCount ) ; tmp . writeInts24 ( data , xy - literalCount + 1 , literalCount ) ; literalCount = 0 ; } } else { if ( literalCount > 0 ) { tmp . write ( literalCount ) ; tmp . writeInts24 ( data , xy - literalCount , literalCount ) ; literalCount = 0 ; } tmp . write ( - repeatCount ) ; tmp . writeInt24 ( v ) ; xy += repeatCount - 1 ; } } if ( literalCount > 0 ) { tmp . write ( literalCount ) ; tmp . writeInts24 ( data , xy - literalCount , literalCount ) ; literalCount = 0 ; } tmp . write ( - 1 ) ; } long pos = tmpSeek . getStreamPosition ( ) ; tmpSeek . seek ( headerPos ) ; tmp . writeInt ( ( int ) ( pos - headerPos ) ) ; tmpSeek . seek ( pos ) ; tmpSeek . toOutputStream ( out ) ; } public void writeDelta24 ( OutputStream out , int [ ] data , int [ ] prev , int width , int height , int offset , int scanlineStride ) throws IOException { tmpSeek . reset ( ) ; int ymin ; int ymax = offset + height * scanlineStride ; scanline : for ( ymin = offset ; ymin < ymax ; ymin += scanlineStride ) { int xy = ymin ; int xymax = ymin + width ; for ( ; xy < xymax ; ++ xy ) { if ( data [ xy ] != prev [ xy ] ) { break scanline ; } } } if ( ymin == ymax ) { tmp . writeInt ( 4 ) ; tmpSeek . toOutputStream ( out ) ; return ; } scanline : for ( ; ymax > ymin ; ymax -= scanlineStride ) { int xy = ymax - scanlineStride ; int xymax = ymax - scanlineStride + width ; for ( ; xy < xymax ; ++ xy ) { if ( data [ xy ] != prev [ xy ] ) { break scanline ; } } } long headerPos = tmpSeek . getStreamPosition ( ) ; tmp . writeInt ( 0 ) ; if ( ymin == offset && ymax == offset + height * scanlineStride ) { tmp . writeShort ( 0x0000 ) ; } else { tmp . writeShort ( 0x0008 ) ; tmp . writeShort ( ymin / scanlineStride ) ; tmp . writeShort ( 0 ) ; tmp . writeShort ( ( ymax - ymin + 1 ) / scanlineStride ) ; tmp . writeShort ( 0 ) ; } for ( int y = ymin ; y < ymax ; y += scanlineStride ) { int xy = y ; int xymax = y + width ; int skipCount = 0 ; for ( ; xy < xymax ; ++ xy , ++ skipCount ) { if ( data [ xy ] != prev [ xy ] ) { break ; } } if ( skipCount == width ) { tmp . write ( 1 ) ; tmp . write ( - 1 ) ; continue ; } tmp . write ( Math . min ( 255 , skipCount + 1 ) ) ; if ( skipCount > 254 ) { skipCount -= 254 ; while ( skipCount > 254 ) { tmp . write ( 0 ) ; tmp . write ( 255 ) ; skipCount -= 254 ; } tmp . write ( 0 ) ; tmp . write ( skipCount + 1 ) ; } int literalCount = 0 ; int repeatCount = 0 ; for ( ; xy < xymax ; ++ xy ) { for ( skipCount = 0 ; xy < xymax ; ++ xy , ++ skipCount ) { if ( data [ xy ] != prev [ xy ] ) { break ; } } xy -= skipCount ; int v = data [ xy ] ; for ( repeatCount = 0 ; xy < xymax && repeatCount < 127 ; ++ xy , ++ repeatCount ) { if ( data [ xy ] != v ) { break ; } } xy -= repeatCount ; if ( skipCount < 1 && xy + skipCount < xymax && repeatCount < 2 ) { literalCount ++ ; if ( literalCount == 127 ) { tmp . write ( literalCount ) ; tmp . writeInts24 ( data , xy - literalCount + 1 , literalCount ) ; literalCount = 0 ; } } else { if ( literalCount > 0 ) { tmp . write ( literalCount ) ; tmp . writeInts24 ( data , xy - literalCount , literalCount ) ; literalCount = 0 ; } if ( xy + skipCount == xymax ) { xy += skipCount - 1 ; } else if ( skipCount >= repeatCount ) { while ( skipCount > 254 ) { tmp . write ( 0 ) ; tmp . write ( 255 ) ; xy += 254 ; skipCount -= 254 ; } tmp . write ( 0 ) ; tmp . write ( skipCount + 1 ) ; xy += skipCount - 1 ; } else { tmp . write ( - repeatCount ) ; tmp . writeInt24 ( v ) ; xy += repeatCount - 1 ; } } } if ( literalCount > 0 ) { tmp . write ( literalCount ) ; tmp . writeInts24 ( data , xy - literalCount , literalCount ) ; literalCount = 0 ; } tmp . write ( - 1 ) ; } long pos = tmpSeek . getStreamPosition ( ) ; tmpSeek . seek ( headerPos ) ; tmp . writeInt ( ( int ) ( pos - headerPos ) ) ; tmpSeek . seek ( pos ) ; tmpSeek . toOutputStream ( out ) ; } public void writeKey32 ( OutputStream out , int [ ] data , int width , int height , int offset , int scanlineStride ) throws IOException { tmpSeek . reset ( ) ; long headerPos = tmpSeek . getStreamPosition ( ) ; tmp . writeInt ( 0 ) ; tmp . writeShort ( 0x0000 ) ; int ymax = offset + height * scanlineStride ; for ( int y = offset ; y < ymax ; y += scanlineStride ) { int xy = y ; int xymax = y + width ; tmp . write ( 1 ) ; int literalCount = 0 ; int repeatCount = 0 ; for ( ; xy < xymax ; ++ xy ) { int v = data [ xy ] ; for ( repeatCount = 0 ; xy < xymax && repeatCount < 127 ; ++ xy , ++ repeatCount ) { if ( data [ xy ] != v ) { break ; } } xy -= repeatCount ; if ( repeatCount < 2 ) { literalCount ++ ; if ( literalCount > 126 ) { tmp . write ( literalCount ) ; tmp . writeInts ( data , xy - literalCount + 1 , literalCount ) ; literalCount = 0 ; } } else { if ( literalCount > 0 ) { tmp . write ( literalCount ) ; tmp . writeInts ( data , xy - literalCount , literalCount ) ; literalCount = 0 ; } tmp . write ( - repeatCount ) ; tmp . writeInt ( v ) ; xy += repeatCount - 1 ; } } if ( literalCount > 0 ) { tmp . write ( literalCount ) ; tmp . writeInts ( data , xy - literalCount , literalCount ) ; literalCount = 0 ; } tmp . write ( - 1 ) ; } long pos = tmpSeek . getStreamPosition ( ) ; tmpSeek . seek ( headerPos ) ; tmp . writeInt ( ( int ) ( pos - headerPos ) ) ; tmpSeek . seek ( pos ) ; tmpSeek . toOutputStream ( out ) ; } public void writeDelta32 ( OutputStream out , int [ ] data , int [ ] prev , int width , int height , int offset , int scanlineStride ) throws IOException { tmpSeek . reset ( ) ; int ymin ; int ymax = offset + height * scanlineStride ; scanline : for ( ymin = offset ; ymin < ymax ; ymin += scanlineStride ) { int xy = ymin ; int xymax = ymin + width ; for ( ; xy < xymax ; ++ xy ) { if ( data [ xy ] != prev [ xy ] ) { break scanline ; } } } if ( ymin == ymax ) { tmp . writeInt ( 4 ) ; tmpSeek . toOutputStream ( out ) ; return ; } scanline : for ( ; ymax > ymin ; ymax -= scanlineStride ) { int xy = ymax - scanlineStride ; int xymax = ymax - scanlineStride + width ; for ( ; xy < xymax ; ++ xy ) { if ( data [ xy ] != prev [ xy ] ) { break scanline ; } } } long headerPos = tmpSeek . getStreamPosition ( ) ; tmp . writeInt ( 0 ) ; if ( ymin == offset && ymax == offset + height * scanlineStride ) { tmp . writeShort ( 0x0000 ) ; } else { tmp . writeShort ( 0x0008 ) ; tmp . writeShort ( ymin / scanlineStride ) ; tmp . writeShort ( 0 ) ; tmp . writeShort ( ( ymax - ymin + 1 ) / scanlineStride ) ; tmp . writeShort ( 0 ) ; } for ( int y = ymin ; y < ymax ; y += scanlineStride ) { int xy = y ; int xymax = y + width ; int skipCount = 0 ; for ( ; xy < xymax ; ++ xy , ++ skipCount ) { if ( data [ xy ] != prev [ xy ] ) { break ; } } if ( skipCount == width ) { tmp . write ( 1 ) ; tmp . write ( - 1 ) ; continue ; } tmp . write ( Math . min ( 255 , skipCount + 1 ) ) ; if ( skipCount > 254 ) { skipCount -= 254 ; while ( skipCount > 254 ) { tmp . write ( 0 ) ; tmp . write ( 255 ) ; skipCount -= 254 ; } tmp . write ( 0 ) ; tmp . write ( skipCount + 1 ) ; } int literalCount = 0 ; int repeatCount = 0 ; for ( ; xy < xymax ; ++ xy ) { for ( skipCount = 0 ; xy < xymax ; ++ xy , ++ skipCount ) { if ( data [ xy ] != prev [ xy ] ) { break ; } } xy -= skipCount ; int v = data [ xy ] ; for ( repeatCount = 0 ; xy < xymax && repeatCount < 127 ; ++ xy , ++ repeatCount ) { if ( data [ xy ] != v ) { break ; } } xy -= repeatCount ; if ( skipCount < 1 && xy + skipCount < xymax && repeatCount < 2 ) { literalCount ++ ; if ( literalCount == 127 ) { tmp . write ( literalCount ) ; tmp . writeInts ( data , xy - literalCount + 1 , literalCount ) ; literalCount = 0 ; } } else { if ( literalCount > 0 ) { tmp . write ( literalCount ) ; tmp . writeInts ( data , xy - literalCount , literalCount ) ; literalCount = 0 ; } if ( xy + skipCount == xymax ) { xy += skipCount - 1 ; } else if ( skipCount >= repeatCount ) { while ( skipCount > 254 ) { tmp . write ( 0 ) ; tmp . write ( 255 ) ; xy += 254 ; skipCount -= 254 ; } tmp . write ( 0 ) ; tmp . write ( skipCount + 1 ) ; xy += skipCount - 1 ; } else { tmp . write ( - repeatCount ) ; tmp . writeInt ( v ) ; xy += repeatCount - 1 ; } } } if ( literalCount > 0 ) { tmp . write ( literalCount ) ; tmp . writeInts ( data , xy - literalCount , literalCount ) ; literalCount = 0 ; } tmp . write ( - 1 ) ; } long pos = tmpSeek . getStreamPosition ( ) ; tmpSeek . seek ( headerPos ) ; tmp . writeInt ( ( int ) ( pos - headerPos ) ) ; tmpSeek . seek ( pos ) ; tmpSeek . toOutputStream ( out ) ; } }
package processing . core ; import java . awt . Cursor ; import java . awt . event . KeyEvent ; public interface PConstants { static public final int X = 0 ; static public final int Y = 1 ; static public final int Z = 2 ; static final String JAVA2D = "processing.core.PGraphicsJava2D" ; static final String P2D = "processing.opengl.PGraphics2D" ; static final String P3D = "processing.opengl.PGraphics3D" ; @ Deprecated static final String OPENGL = P3D ; static final String E2D = PGraphicsDanger2D . class . getName ( ) ; static final String FX2D = PGraphicsFX2D . class . getName ( ) ; static final String PDF = "processing.pdf.PGraphicsPDF" ; static final String SVG = "processing.svg.PGraphicsSVG" ; static final String DXF = "processing.dxf.RawDXF" ; static final int OTHER = 0 ; static final int WINDOWS = 1 ; static final int MACOSX = 2 ; static final int LINUX = 3 ; static final String [ ] platformNames = { "other" , "windows" , "macosx" , "linux" } ; static final float EPSILON = 0.0001f ; static final float MAX_FLOAT = Float . MAX_VALUE ; static final float MIN_FLOAT = - Float . MAX_VALUE ; static final int MAX_INT = Integer . MAX_VALUE ; static final int MIN_INT = Integer . MIN_VALUE ; static public final int VERTEX = 0 ; static public final int BEZIER_VERTEX = 1 ; static public final int QUADRATIC_VERTEX = 2 ; static public final int CURVE_VERTEX = 3 ; static public final int BREAK = 4 ; @ Deprecated static public final int QUAD_BEZIER_VERTEX = 2 ; static final float PI = ( float ) Math . PI ; static final float HALF_PI = ( float ) ( Math . PI / 2.0 ) ; static final float THIRD_PI = ( float ) ( Math . PI / 3.0 ) ; static final float QUARTER_PI = ( float ) ( Math . PI / 4.0 ) ; static final float TWO_PI = ( float ) ( 2.0 * Math . PI ) ; static final float TAU = ( float ) ( 2.0 * Math . PI ) ; static final float DEG_TO_RAD = PI / 180.0f ; static final float RAD_TO_DEG = 180.0f / PI ; static final String WHITESPACE = " \t\n\r\f\u00A0" ; static final int RGB = 1 ; static final int ARGB = 2 ; static final int HSB = 3 ; static final int ALPHA = 4 ; static final int TIFF = 0 ; static final int TARGA = 1 ; static final int JPEG = 2 ; static final int GIF = 3 ; static final int BLUR = 11 ; static final int GRAY = 12 ; static final int INVERT = 13 ; static final int OPAQUE = 14 ; static final int POSTERIZE = 15 ; static final int THRESHOLD = 16 ; static final int ERODE = 17 ; static final int DILATE = 18 ; public final static int REPLACE = 0 ; public final static int BLEND = 1 < < 0 ; public final static int ADD = 1 < < 1 ; public final static int SUBTRACT = 1 < < 2 ; public final static int LIGHTEST = 1 < < 3 ; public final static int DARKEST = 1 < < 4 ; public final static int DIFFERENCE = 1 < < 5 ; public final static int EXCLUSION = 1 < < 6 ; public final static int MULTIPLY = 1 < < 7 ; public final static int SCREEN = 1 < < 8 ; public final static int OVERLAY = 1 < < 9 ; public final static int HARD_LIGHT = 1 < < 10 ; public final static int SOFT_LIGHT = 1 < < 11 ; public final static int DODGE = 1 < < 12 ; public final static int BURN = 1 < < 13 ; static final int CHATTER = 0 ; static final int COMPLAINT = 1 ; static final int PROBLEM = 2 ; static final int PROJECTION = 0 ; static final int MODELVIEW = 1 ; static final int CUSTOM = 0 ; static final int ORTHOGRAPHIC = 2 ; static final int PERSPECTIVE = 3 ; static final int GROUP = 0 ; static final int POINT = 2 ; static final int POINTS = 3 ; static final int LINE = 4 ; static final int LINES = 5 ; static final int LINE_STRIP = 50 ; static final int LINE_LOOP = 51 ; static final int TRIANGLE = 8 ; static final int TRIANGLES = 9 ; static final int TRIANGLE_STRIP = 10 ; static final int TRIANGLE_FAN = 11 ; static final int QUAD = 16 ; static final int QUADS = 17 ; static final int QUAD_STRIP = 18 ; static final int POLYGON = 20 ; static final int PATH = 21 ; static final int RECT = 30 ; static final int ELLIPSE = 31 ; static final int ARC = 32 ; static final int SPHERE = 40 ; static final int BOX = 41 ; static final int OPEN = 1 ; static final int CLOSE = 2 ; static final int CORNER = 0 ; static final int CORNERS = 1 ; static final int RADIUS = 2 ; static final int CENTER = 3 ; static final int DIAMETER = 3 ; static final int CHORD = 2 ; static final int PIE = 3 ; static final int BASELINE = 0 ; static final int TOP = 101 ; static final int BOTTOM = 102 ; static final int NORMAL = 1 ; static final int IMAGE = 2 ; public static final int CLAMP = 0 ; public static final int REPEAT = 1 ; static final int MODEL = 4 ; static final int SHAPE = 5 ; static final int SQUARE = 1 < < 0 ; static final int ROUND = 1 < < 1 ; static final int PROJECT = 1 < < 2 ; static final int MITER = 1 < < 3 ; static final int BEVEL = 1 < < 5 ; static final int AMBIENT = 0 ; static final int DIRECTIONAL = 1 ; static final int SPOT = 3 ; static final char BACKSPACE = 8 ; static final char TAB = 9 ; static final char ENTER = 10 ; static final char RETURN = 13 ; static final char ESC = 27 ; static final char DELETE = 127 ; static final int CODED = 0xffff ; static final int UP = KeyEvent . VK_UP ; static final int DOWN = KeyEvent . VK_DOWN ; static final int LEFT = KeyEvent . VK_LEFT ; static final int RIGHT = KeyEvent . VK_RIGHT ; static final int ALT = KeyEvent . VK_ALT ; static final int CONTROL = KeyEvent . VK_CONTROL ; static final int SHIFT = KeyEvent . VK_SHIFT ; static final int PORTRAIT = 1 ; static final int LANDSCAPE = 2 ; static final int SPAN = 0 ; static final int ARROW = Cursor . DEFAULT_CURSOR ; static final int CROSS = Cursor . CROSSHAIR_CURSOR ; static final int HAND = Cursor . HAND_CURSOR ; static final int MOVE = Cursor . MOVE_CURSOR ; static final int TEXT = Cursor . TEXT_CURSOR ; static final int WAIT = Cursor . WAIT_CURSOR ; @ Deprecated static final int ENABLE_NATIVE_FONTS = 1 ; @ Deprecated static final int DISABLE_NATIVE_FONTS = - 1 ; static final int DISABLE_DEPTH_TEST = 2 ; static final int ENABLE_DEPTH_TEST = - 2 ; static final int ENABLE_DEPTH_SORT = 3 ; static final int DISABLE_DEPTH_SORT = - 3 ; static final int DISABLE_OPENGL_ERRORS = 4 ; static final int ENABLE_OPENGL_ERRORS = - 4 ; static final int DISABLE_DEPTH_MASK = 5 ; static final int ENABLE_DEPTH_MASK = - 5 ; static final int DISABLE_OPTIMIZED_STROKE = 6 ; static final int ENABLE_OPTIMIZED_STROKE = - 6 ; static final int ENABLE_STROKE_PERSPECTIVE = 7 ; static final int DISABLE_STROKE_PERSPECTIVE = - 7 ; static final int DISABLE_TEXTURE_MIPMAPS = 8 ; static final int ENABLE_TEXTURE_MIPMAPS = - 8 ; static final int ENABLE_STROKE_PURE = 9 ; static final int DISABLE_STROKE_PURE = - 9 ; static final int HINT_COUNT = 10 ; static final String ERROR_BACKGROUND_IMAGE_SIZE = "background image must be the same size as your application" ; static final String ERROR_BACKGROUND_IMAGE_FORMAT = "background images should be RGB or ARGB" ; static final String ERROR_TEXTFONT_NULL_PFONT = "A null PFont was passed to textFont()" ; static final String ERROR_PUSHMATRIX_OVERFLOW = "Too many calls to pushMatrix()." ; static final String ERROR_PUSHMATRIX_UNDERFLOW = "Too many calls to popMatrix(), and not enough to pushMatrix()." ; }
package ch . randelshofer . media . quicktime ; import ch . randelshofer . io . ImageOutputStreamAdapter ; import java . awt . Rectangle ; import java . awt . image . BufferedImage ; import java . awt . image . DataBufferByte ; import java . awt . image . DataBufferInt ; import java . awt . image . DataBufferUShort ; import java . awt . image . IndexColorModel ; import java . awt . image . WritableRaster ; import java . io . * ; import java . util . ArrayList ; import java . util . Date ; import java . util . LinkedList ; import java . util . zip . DeflaterOutputStream ; import javax . imageio . * ; import javax . imageio . stream . * ; import javax . sound . sampled . AudioFormat ; @ SuppressWarnings ( "resource" ) public class QuickTimeWriter { public static class Edit { public int trackDuration ; public int mediaTime ; public int mediaRate ; public Edit ( int trackDuration , int mediaTime , double mediaRate ) { if ( trackDuration < 0 ) { throw new IllegalArgumentException ( "trackDuration must not be < 0:" + trackDuration ) ; } if ( mediaTime < - 1 ) { throw new IllegalArgumentException ( "mediaTime must not be < -1:" + mediaTime ) ; } if ( mediaRate <= 0 ) { throw new IllegalArgumentException ( "mediaRate must not be <= 0:" + mediaRate ) ; } this . trackDuration = trackDuration ; this . mediaTime = mediaTime ; this . mediaRate = ( int ) ( mediaRate * ( 1 < < 16 ) ) ; } public Edit ( int trackDuration , int mediaTime , int mediaRate ) { if ( trackDuration < 0 ) { throw new IllegalArgumentException ( "trackDuration must not be < 0:" + trackDuration ) ; } if ( mediaTime < - 1 ) { throw new IllegalArgumentException ( "mediaTime must not be < -1:" + mediaTime ) ; } if ( mediaRate <= 0 ) { throw new IllegalArgumentException ( "mediaRate must not be <= 0:" + mediaRate ) ; } this . trackDuration = trackDuration ; this . mediaTime = mediaTime ; this . mediaRate = mediaRate ; } } private ImageOutputStream out ; private long streamOffset ; public static enum VideoFormat { RAW ( "raw " , "None" , true ) , JPG ( "jpeg" , "Photo - JPEG" , true ) , PNG ( "png " , "PNG" , true ) , RLE ( "rle " , "Animation" , false ) , ; private String compressionType ; private String compressorName ; private boolean allSamplesAreSyncSamples ; VideoFormat ( String compressionType , String compressorName , boolean allSamplesAreSyncSamples ) { this . compressionType = compressionType ; this . compressorName = compressorName ; this . allSamplesAreSyncSamples = allSamplesAreSyncSamples ; } } private static enum MediaType { VIDEO , AUDIO ; } private Date creationTime ; private long movieTimeScale = 600 ; private ArrayList < Track > tracks = new ArrayList < Track > ( ) ; private abstract class Track { final MediaType mediaType ; protected long mediaTimeScale = 600 ; protected String mediaCompressionType ; protected String mediaCompressorName ; protected ArrayList < Chunk > chunks = new ArrayList < Chunk > ( ) ; protected ArrayList < TimeToSampleGroup > timeToSamples = new ArrayList < TimeToSampleGroup > ( ) ; protected ArrayList < SampleSizeGroup > sampleSizes = new ArrayList < SampleSizeGroup > ( ) ; protected ArrayList < Long > syncSamples = null ; protected long sampleCount = 0 ; protected long mediaDuration = 0 ; protected Edit [ ] editList ; public Track ( MediaType mediaType ) { this . mediaType = mediaType ; } public void addSample ( Sample sample , int sampleDescriptionId , boolean isSyncSample ) { mediaDuration += sample . duration ; sampleCount ++ ; if ( isSyncSample ) { if ( syncSamples != null ) { syncSamples . add ( sampleCount ) ; } } else { if ( syncSamples == null ) { syncSamples = new ArrayList < Long > ( ) ; for ( long i = 1 ; i < sampleCount ; i ++ ) { syncSamples . add ( i ) ; } } } if ( timeToSamples . isEmpty ( ) || ! timeToSamples . get ( timeToSamples . size ( ) - 1 ) . maybeAddSample ( sample ) ) { timeToSamples . add ( new TimeToSampleGroup ( sample ) ) ; } if ( sampleSizes . isEmpty ( ) || ! sampleSizes . get ( sampleSizes . size ( ) - 1 ) . maybeAddSample ( sample ) ) { sampleSizes . add ( new SampleSizeGroup ( sample ) ) ; } if ( chunks . isEmpty ( ) || ! chunks . get ( chunks . size ( ) - 1 ) . maybeAddSample ( sample , sampleDescriptionId ) ) { chunks . add ( new Chunk ( sample , sampleDescriptionId ) ) ; } } public void addChunk ( Chunk chunk , boolean isSyncSample ) { mediaDuration += chunk . firstSample . duration * chunk . sampleCount ; sampleCount += chunk . sampleCount ; if ( timeToSamples . isEmpty ( ) || ! timeToSamples . get ( timeToSamples . size ( ) - 1 ) . maybeAddChunk ( chunk ) ) { timeToSamples . add ( new TimeToSampleGroup ( chunk ) ) ; } if ( sampleSizes . isEmpty ( ) || ! sampleSizes . get ( sampleSizes . size ( ) - 1 ) . maybeAddChunk ( chunk ) ) { sampleSizes . add ( new SampleSizeGroup ( chunk ) ) ; } if ( chunks . isEmpty ( ) || ! chunks . get ( chunks . size ( ) - 1 ) . maybeAddChunk ( chunk ) ) { chunks . add ( chunk ) ; } } public long getSampleCount ( ) { return sampleCount ; } public long getTrackDuration ( long movieTimeScale ) { if ( editList == null || editList . length == 0 ) { return mediaDuration * movieTimeScale / mediaTimeScale ; } else { long duration = 0 ; for ( int i = 0 ; i < editList . length ; ++ i ) { duration += editList [ i ] . trackDuration ; } return duration ; } } private void writeTrackAtoms ( int trackIndex , CompositeAtom moovAtom , Date modificationTime ) throws IOException { DataAtom leaf ; DataAtomOutputStream d ; CompositeAtom trakAtom = new CompositeAtom ( "trak" ) ; moovAtom . add ( trakAtom ) ; leaf = new DataAtom ( "tkhd" ) ; trakAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0xf ) ; d . writeMacTimestamp ( creationTime ) ; d . writeMacTimestamp ( modificationTime ) ; d . writeInt ( trackIndex + 1 ) ; d . writeInt ( 0 ) ; d . writeUInt ( getTrackDuration ( movieTimeScale ) ) ; d . writeLong ( 0 ) ; d . writeShort ( 0 ) ; d . writeShort ( 0 ) ; d . writeFixed8D8 ( mediaType == MediaType . AUDIO ? 1 : 0 ) ; d . writeShort ( 0 ) ; d . writeFixed16D16 ( 1 ) ; d . writeFixed16D16 ( 0 ) ; d . writeFixed2D30 ( 0 ) ; d . writeFixed16D16 ( 0 ) ; d . writeFixed16D16 ( 1 ) ; d . writeFixed2D30 ( 0 ) ; d . writeFixed16D16 ( 0 ) ; d . writeFixed16D16 ( 0 ) ; d . writeFixed2D30 ( 1 ) ; d . writeFixed16D16 ( mediaType == MediaType . VIDEO ? ( ( VideoTrack ) this ) . videoWidth : 0 ) ; d . writeFixed16D16 ( mediaType == MediaType . VIDEO ? ( ( VideoTrack ) this ) . videoHeight : 0 ) ; CompositeAtom edtsAtom = new CompositeAtom ( "edts" ) ; trakAtom . add ( edtsAtom ) ; leaf = new DataAtom ( "elst" ) ; edtsAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; Edit [ ] elist = editList ; if ( elist == null || elist . length == 0 ) { d . writeUInt ( 1 ) ; d . writeUInt ( getTrackDuration ( movieTimeScale ) ) ; d . writeUInt ( 0 ) ; d . writeFixed16D16 ( 1 ) ; } else { d . writeUInt ( elist . length ) ; for ( int i = 0 ; i < elist . length ; ++ i ) { d . writeUInt ( elist [ i ] . trackDuration ) ; d . writeUInt ( elist [ i ] . mediaTime ) ; d . writeUInt ( elist [ i ] . mediaRate ) ; } } CompositeAtom mdiaAtom = new CompositeAtom ( "mdia" ) ; trakAtom . add ( mdiaAtom ) ; leaf = new DataAtom ( "mdhd" ) ; mdiaAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . writeMacTimestamp ( creationTime ) ; d . writeMacTimestamp ( modificationTime ) ; d . writeUInt ( mediaTimeScale ) ; d . writeUInt ( mediaDuration ) ; d . writeShort ( 0 ) ; d . writeShort ( 0 ) ; leaf = new DataAtom ( "hdlr" ) ; mdiaAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . writeType ( "mhlr" ) ; d . writeType ( mediaType == MediaType . VIDEO ? "vide" : "soun" ) ; if ( mediaType == MediaType . AUDIO ) { d . writeType ( "appl" ) ; } else { d . writeUInt ( 0 ) ; } d . writeUInt ( mediaType == MediaType . AUDIO ? 268435456L : 0 ) ; d . writeUInt ( mediaType == MediaType . AUDIO ? 65941 : 0 ) ; d . writePString ( mediaType == MediaType . AUDIO ? "Apple Sound Media Handler" : "" ) ; writeMediaInformationAtoms ( mdiaAtom ) ; } private void writeMediaInformationAtoms ( CompositeAtom mdiaAtom ) throws IOException { DataAtom leaf ; DataAtomOutputStream d ; CompositeAtom minfAtom = new CompositeAtom ( "minf" ) ; mdiaAtom . add ( minfAtom ) ; writeMediaInformationHeaderAtom ( minfAtom ) ; leaf = new DataAtom ( "hdlr" ) ; minfAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . writeType ( "dhlr" ) ; d . writeType ( "alis" ) ; if ( mediaType == MediaType . AUDIO ) { d . writeType ( "appl" ) ; } else { d . writeUInt ( 0 ) ; } d . writeUInt ( mediaType == MediaType . AUDIO ? 268435457L : 0 ) ; d . writeInt ( mediaType == MediaType . AUDIO ? 65967 : 0 ) ; d . writePString ( "Apple Alias Data Handler" ) ; CompositeAtom dinfAtom = new CompositeAtom ( "dinf" ) ; minfAtom . add ( dinfAtom ) ; leaf = new DataAtom ( "dref" ) ; dinfAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . writeInt ( 1 ) ; d . writeInt ( 12 ) ; d . writeType ( "alis" ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0x1 ) ; writeSampleTableAtoms ( minfAtom ) ; } protected abstract void writeMediaInformationHeaderAtom ( CompositeAtom minfAtom ) throws IOException ; protected abstract void writeSampleDescriptionAtom ( CompositeAtom stblAtom ) throws IOException ; private void writeSampleTableAtoms ( CompositeAtom minfAtom ) throws IOException { DataAtom leaf ; DataAtomOutputStream d ; CompositeAtom stblAtom = new CompositeAtom ( "stbl" ) ; minfAtom . add ( stblAtom ) ; writeSampleDescriptionAtom ( stblAtom ) ; leaf = new DataAtom ( "stts" ) ; stblAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . writeUInt ( timeToSamples . size ( ) ) ; for ( TimeToSampleGroup tts : timeToSamples ) { d . writeUInt ( tts . getSampleCount ( ) ) ; d . writeUInt ( tts . getSampleDuration ( ) ) ; } leaf = new DataAtom ( "stsc" ) ; stblAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; int entryCount = 0 ; long previousSampleCount = - 1 ; long previousSampleDescriptionId = - 1 ; for ( Chunk c : chunks ) { if ( c . sampleCount != previousSampleCount || c . sampleDescriptionId != previousSampleDescriptionId ) { previousSampleCount = c . sampleCount ; previousSampleDescriptionId = c . sampleDescriptionId ; entryCount ++ ; } } d . writeInt ( entryCount ) ; int firstChunk = 1 ; previousSampleCount = - 1 ; previousSampleDescriptionId = - 1 ; for ( Chunk c : chunks ) { if ( c . sampleCount != previousSampleCount || c . sampleDescriptionId != previousSampleDescriptionId ) { previousSampleCount = c . sampleCount ; previousSampleDescriptionId = c . sampleDescriptionId ; d . writeUInt ( firstChunk ) ; d . writeUInt ( c . sampleCount ) ; d . writeInt ( c . sampleDescriptionId ) ; } firstChunk ++ ; } if ( syncSamples != null ) { leaf = new DataAtom ( "stss" ) ; stblAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . writeUInt ( syncSamples . size ( ) ) ; for ( Long number : syncSamples ) { d . writeUInt ( number ) ; } } leaf = new DataAtom ( "stsz" ) ; stblAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; int sampleUnit = mediaType == MediaType . AUDIO && ( ( AudioTrack ) this ) . soundCompressionId != - 2 ? ( ( AudioTrack ) this ) . soundSampleSize / 8 * ( ( AudioTrack ) this ) . soundNumberOfChannels : 1 ; if ( sampleSizes . size ( ) == 1 ) { d . writeUInt ( sampleSizes . get ( 0 ) . getSampleLength ( ) / sampleUnit ) ; d . writeUInt ( sampleSizes . get ( 0 ) . getSampleCount ( ) ) ; } else { d . writeUInt ( 0 ) ; long count = 0 ; for ( SampleSizeGroup s : sampleSizes ) { count += s . sampleCount ; } d . writeUInt ( count ) ; for ( SampleSizeGroup s : sampleSizes ) { long sampleSize = s . getSampleLength ( ) / sampleUnit ; for ( int i = 0 ; i < s . sampleCount ; i ++ ) { d . writeUInt ( sampleSize ) ; } } } if ( chunks . isEmpty ( ) || chunks . get ( chunks . size ( ) - 1 ) . getChunkOffset ( ) <= 0xffffffffL ) { leaf = new DataAtom ( "stco" ) ; stblAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . writeUInt ( chunks . size ( ) ) ; for ( Chunk c : chunks ) { d . writeUInt ( c . getChunkOffset ( ) + mdatOffset ) ; } } else { leaf = new DataAtom ( "co64" ) ; stblAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . writeUInt ( chunks . size ( ) ) ; for ( Chunk c : chunks ) { d . writeLong ( c . getChunkOffset ( ) ) ; } } } } private class VideoTrack extends Track { private VideoFormat videoEncoding ; private float videoQuality = 0.97f ; private int videoWidth = - 1 ; private int videoHeight = - 1 ; private int videoDepth = - 1 ; private IndexColorModel videoColorTable ; private AppleRLEEncoder encoder ; private Object previousData ; private int syncInterval ; public VideoTrack ( ) { super ( MediaType . VIDEO ) ; } @ Override protected void writeMediaInformationHeaderAtom ( CompositeAtom minfAtom ) throws IOException { DataAtom leaf ; DataAtomOutputStream d ; leaf = new DataAtom ( "vmhd" ) ; minfAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0x1 ) ; d . writeShort ( 0x40 ) ; d . writeUShort ( 0 ) ; d . writeUShort ( 0 ) ; d . writeUShort ( 0 ) ; } @ Override protected void writeSampleDescriptionAtom ( CompositeAtom stblAtom ) throws IOException { CompositeAtom leaf ; DataAtomOutputStream d ; leaf = new CompositeAtom ( "stsd" ) ; stblAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . writeInt ( 1 ) ; d . writeInt ( 86 + 12 ) ; d . writeType ( mediaCompressionType ) ; d . write ( new byte [ 6 ] ) ; d . writeShort ( 1 ) ; d . writeShort ( 0 ) ; d . writeShort ( 0 ) ; d . writeType ( "java" ) ; d . writeInt ( 0 ) ; d . writeInt ( 512 ) ; d . writeUShort ( videoWidth ) ; d . writeUShort ( videoHeight ) ; d . writeFixed16D16 ( 72.0 ) ; d . writeFixed16D16 ( 72.0 ) ; d . writeInt ( 0 ) ; d . writeShort ( 1 ) ; d . writePString ( mediaCompressorName , 32 ) ; d . writeShort ( videoDepth ) ; d . writeShort ( videoColorTable == null ? - 1 : 0 ) ; if ( videoColorTable != null ) { writeColorTableAtom ( leaf ) ; } writeGammaAtom ( leaf ) ; } protected void writeGammaAtom ( CompositeAtom stblAtom ) throws IOException { DataAtom leaf ; DataAtomOutputStream d ; leaf = new DataAtom ( "gama" ) ; stblAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . writeFixed16D16 ( 2.2 ) ; } protected void writeColorTableAtom ( CompositeAtom stblAtom ) throws IOException { DataAtom leaf ; DataAtomOutputStream d ; leaf = new DataAtom ( "ctab" ) ; stblAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . writeUInt ( 0 ) ; d . writeUShort ( 0x8000 ) ; d . writeUShort ( videoColorTable . getMapSize ( ) - 1 ) ; for ( int i = 0 , n = videoColorTable . getMapSize ( ) ; i < n ; ++ i ) { d . writeUShort ( 0 ) ; d . writeUShort ( ( videoColorTable . getRed ( i ) < < 8 ) | videoColorTable . getRed ( i ) ) ; d . writeUShort ( ( videoColorTable . getGreen ( i ) < < 8 ) | videoColorTable . getGreen ( i ) ) ; d . writeUShort ( ( videoColorTable . getBlue ( i ) < < 8 ) | videoColorTable . getBlue ( i ) ) ; } } } private class AudioTrack extends Track { private int soundNumberOfChannels ; private int soundSampleSize ; private int soundCompressionId ; private long soundSamplesPerPacket ; private int soundBytesPerPacket ; private int soundBytesPerFrame ; private int soundBytesPerSample ; private double soundSampleRate ; private byte [ ] stsdExtensions = new byte [ 0 ] ; public AudioTrack ( ) { super ( MediaType . AUDIO ) ; } @ Override protected void writeMediaInformationHeaderAtom ( CompositeAtom minfAtom ) throws IOException { DataAtom leaf ; DataAtomOutputStream d ; leaf = new DataAtom ( "smhd" ) ; minfAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . writeFixed8D8 ( 0 ) ; d . writeUShort ( 0 ) ; } @ Override protected void writeSampleDescriptionAtom ( CompositeAtom stblAtom ) throws IOException { DataAtom leaf ; DataAtomOutputStream d ; leaf = new DataAtom ( "stsd" ) ; stblAtom . add ( leaf ) ; d = leaf . getOutputStream ( ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . write ( 0 ) ; d . writeInt ( 1 ) ; d . writeUInt ( 4 + 12 + 20 + 16 + stsdExtensions . length ) ; d . writeType ( mediaCompressionType ) ; d . write ( new byte [ 6 ] ) ; d . writeUShort ( 1 ) ; d . writeUShort ( 1 ) ; d . writeUShort ( 0 ) ; d . writeUInt ( 0 ) ; d . writeUShort ( soundNumberOfChannels ) ; d . writeUShort ( soundSampleSize ) ; d . writeUShort ( soundCompressionId ) ; d . writeUShort ( 0 ) ; d . writeFixed16D16 ( soundSampleRate ) ; d . writeUInt ( soundSamplesPerPacket ) ; d . writeUInt ( soundBytesPerPacket ) ; d . writeUInt ( soundBytesPerFrame ) ; d . writeUInt ( soundBytesPerSample ) ; d . write ( stsdExtensions ) ; } } private static enum States { REALIZED , STARTED , FINISHED , CLOSED ; } private States state = States . REALIZED ; private static class Sample { long offset ; long length ; long duration ; public Sample ( long duration , long offset , long length ) { this . duration = duration ; this . offset = offset ; this . length = length ; } } private abstract static class Group { protected Sample firstSample ; protected Sample lastSample ; protected long sampleCount ; private final static long maxSampleCount = Integer . MAX_VALUE ; protected Group ( Sample firstSample ) { this . firstSample = this . lastSample = firstSample ; sampleCount = 1 ; } protected Group ( Sample firstSample , Sample lastSample , long sampleCount ) { this . firstSample = firstSample ; this . lastSample = lastSample ; this . sampleCount = sampleCount ; if ( sampleCount > maxSampleCount ) { throw new IllegalArgumentException ( "Capacity exceeded" ) ; } } protected Group ( Group group ) { this . firstSample = group . firstSample ; this . lastSample = group . lastSample ; sampleCount = group . sampleCount ; } protected boolean maybeAddSample ( Sample sample ) { if ( sampleCount < maxSampleCount ) { lastSample = sample ; sampleCount ++ ; return true ; } return false ; } protected boolean maybeAddChunk ( Chunk chunk ) { if ( sampleCount + chunk . sampleCount <= maxSampleCount ) { lastSample = chunk . lastSample ; sampleCount += chunk . sampleCount ; return true ; } return false ; } public long getSampleCount ( ) { return sampleCount ; } } private static class TimeToSampleGroup extends Group { public TimeToSampleGroup ( Sample firstSample ) { super ( firstSample ) ; } public TimeToSampleGroup ( Group group ) { super ( group ) ; } @ Override public boolean maybeAddSample ( Sample sample ) { if ( firstSample . duration == sample . duration ) { return super . maybeAddSample ( sample ) ; } return false ; } @ Override public boolean maybeAddChunk ( Chunk chunk ) { if ( firstSample . duration == chunk . firstSample . duration ) { return super . maybeAddChunk ( chunk ) ; } return false ; } public long getSampleDuration ( ) { return firstSample . duration ; } } private static class SampleSizeGroup extends Group { public SampleSizeGroup ( Sample firstSample ) { super ( firstSample ) ; } public SampleSizeGroup ( Group group ) { super ( group ) ; } @ Override public boolean maybeAddSample ( Sample sample ) { if ( firstSample . length == sample . length ) { return super . maybeAddSample ( sample ) ; } return false ; } @ Override public boolean maybeAddChunk ( Chunk chunk ) { if ( firstSample . length == chunk . firstSample . length ) { return super . maybeAddChunk ( chunk ) ; } return false ; } public long getSampleLength ( ) { return firstSample . length ; } } private static class Chunk extends Group { private int sampleDescriptionId ; public Chunk ( Sample firstSample , int sampleDescriptionId ) { super ( firstSample ) ; this . sampleDescriptionId = sampleDescriptionId ; } public Chunk ( Sample firstSample , Sample lastSample , int sampleCount , int sampleDescriptionId ) { super ( firstSample , lastSample , sampleCount ) ; this . sampleDescriptionId = sampleDescriptionId ; } public boolean maybeAddSample ( Sample sample , int sampleDescriptionId ) { if ( sampleDescriptionId == this . sampleDescriptionId && lastSample . offset + lastSample . length == sample . offset ) { return super . maybeAddSample ( sample ) ; } return false ; } @ Override public boolean maybeAddChunk ( Chunk chunk ) { if ( sampleDescriptionId == chunk . sampleDescriptionId && lastSample . offset + lastSample . length == chunk . firstSample . offset ) { return super . maybeAddChunk ( chunk ) ; } return false ; } public long getChunkOffset ( ) { return firstSample . offset ; } } private WideDataAtom mdatAtom ; private long mdatOffset ; private CompositeAtom moovAtom ; private abstract class Atom { protected String type ; protected long offset ; public Atom ( String type ) throws IOException { this . type = type ; offset = getRelativeStreamPosition ( ) ; } public abstract void finish ( ) throws IOException ; public abstract long size ( ) ; } private class CompositeAtom extends DataAtom { private LinkedList < Atom > children ; public CompositeAtom ( String type ) throws IOException { super ( type ) ; children = new LinkedList < Atom > ( ) ; } public void add ( Atom child ) throws IOException { if ( children . size ( ) > 0 ) { children . getLast ( ) . finish ( ) ; } children . add ( child ) ; } @ Override public void finish ( ) throws IOException { if ( ! finished ) { if ( size ( ) > 0xffffffffL ) { throw new IOException ( "CompositeAtom \"" + type + "\" is too large: " + size ( ) ) ; } long pointer = getRelativeStreamPosition ( ) ; seekRelative ( offset ) ; DataAtomOutputStream headerData = new DataAtomOutputStream ( new ImageOutputStreamAdapter ( out ) ) ; headerData . writeInt ( ( int ) size ( ) ) ; headerData . writeType ( type ) ; for ( Atom child : children ) { child . finish ( ) ; } seekRelative ( pointer ) ; finished = true ; } } @ Override public long size ( ) { long length = 8 + data . size ( ) ; for ( Atom child : children ) { length += child . size ( ) ; } return length ; } } private class DataAtom extends Atom { protected DataAtomOutputStream data ; protected boolean finished ; public DataAtom ( String name ) throws IOException { super ( name ) ; out . writeLong ( 0 ) ; data = new DataAtomOutputStream ( new ImageOutputStreamAdapter ( out ) ) ; } public DataAtomOutputStream getOutputStream ( ) { if ( finished ) { throw new IllegalStateException ( "DataAtom is finished" ) ; } return data ; } @ Override public void finish ( ) throws IOException { if ( ! finished ) { long sizeBefore = size ( ) ; if ( size ( ) > 0xffffffffL ) { throw new IOException ( "DataAtom \"" + type + "\" is too large: " + size ( ) ) ; } long pointer = getRelativeStreamPosition ( ) ; seekRelative ( offset ) ; DataAtomOutputStream headerData = new DataAtomOutputStream ( new ImageOutputStreamAdapter ( out ) ) ; headerData . writeUInt ( size ( ) ) ; headerData . writeType ( type ) ; seekRelative ( pointer ) ; finished = true ; long sizeAfter = size ( ) ; if ( sizeBefore != sizeAfter ) { System . err . println ( "size mismatch " + sizeBefore + ".." + sizeAfter ) ; } } } @ Override public long size ( ) { return 8 + data . size ( ) ; } } private class WideDataAtom extends Atom { private DataAtomOutputStream data ; private boolean finished ; public WideDataAtom ( String type ) throws IOException { super ( type ) ; out . writeLong ( 0 ) ; out . writeLong ( 0 ) ; data = new DataAtomOutputStream ( new ImageOutputStreamAdapter ( out ) ) { @ Override public void flush ( ) throws IOException { } } ; } public DataAtomOutputStream getOutputStream ( ) { if ( finished ) { throw new IllegalStateException ( "Atom is finished" ) ; } return data ; } public long getOffset ( ) { return offset ; } @ Override public void finish ( ) throws IOException { if ( ! finished ) { long pointer = getRelativeStreamPosition ( ) ; seekRelative ( offset ) ; DataAtomOutputStream headerData = new DataAtomOutputStream ( new ImageOutputStreamAdapter ( out ) ) ; long finishedSize = size ( ) ; if ( finishedSize <= 0xffffffffL ) { headerData . writeUInt ( 8 ) ; headerData . writeType ( "wide" ) ; headerData . writeUInt ( finishedSize - 8 ) ; headerData . writeType ( type ) ; } else { headerData . writeInt ( 1 ) ; headerData . writeType ( type ) ; headerData . writeLong ( finishedSize - 8 ) ; } seekRelative ( pointer ) ; finished = true ; } } @ Override public long size ( ) { return 16 + data . size ( ) ; } } public QuickTimeWriter ( File file ) throws IOException { if ( file . exists ( ) ) { file . delete ( ) ; } this . out = new FileImageOutputStream ( file ) ; this . streamOffset = 0 ; } public QuickTimeWriter ( ImageOutputStream out ) throws IOException { this . out = out ; this . streamOffset = out . getStreamPosition ( ) ; } public void setMovieTimeScale ( long timeScale ) { if ( timeScale < 1 || timeScale > ( 2L < < 32 ) ) { throw new IllegalArgumentException ( "timeScale must be between 1 and 2^32:" + timeScale ) ; } this . movieTimeScale = timeScale ; } public long getMovieTimeScale ( ) { return movieTimeScale ; } public long getMediaTimeScale ( int track ) { return tracks . get ( track ) . mediaTimeScale ; } public long getMediaDuration ( int track ) { return tracks . get ( track ) . mediaDuration ; } public long getUneditedTrackDuration ( int track ) { Track t = tracks . get ( track ) ; return t . mediaDuration * t . mediaTimeScale / movieTimeScale ; } public long getTrackDuration ( int track ) { return tracks . get ( track ) . getTrackDuration ( movieTimeScale ) ; } public long getMovieDuration ( ) { long duration = 0 ; for ( Track t : tracks ) { duration = Math . max ( duration , t . getTrackDuration ( movieTimeScale ) ) ; } return duration ; } public void setVideoColorTable ( int track , IndexColorModel icm ) { VideoTrack t = ( VideoTrack ) tracks . get ( track ) ; t . videoColorTable = icm ; } public IndexColorModel getVideoColorTable ( int track ) { VideoTrack t = ( VideoTrack ) tracks . get ( track ) ; return t . videoColorTable ; } public void setEditList ( int track , Edit [ ] editList ) { if ( editList != null && editList . length > 0 && editList [ editList . length - 1 ] . mediaTime == - 1 ) { throw new IllegalArgumentException ( "Edit list must not end with empty edit." ) ; } tracks . get ( track ) . editList = editList ; } public void addVideoTrack ( VideoFormat encoding , long timeScale , int width , int height ) throws IOException { addVideoTrack ( encoding . compressionType , encoding . compressorName , timeScale , width , height , 24 , encoding . allSamplesAreSyncSamples ? 1 : 30 ) ; } public void addVideoTrack ( String compressionType , String compressorName , long timeScale , int width , int height , int depth , int syncInterval ) throws IOException { ensureStarted ( ) ; if ( compressionType == null || compressionType . length ( ) != 4 ) { throw new IllegalArgumentException ( "compressionType must be 4 characters long:" + compressionType ) ; } if ( compressorName == null || compressorName . length ( ) < 1 || compressorName . length ( ) > 32 ) { throw new IllegalArgumentException ( "compressorName must be between 1 and 32 characters long:" + compressionType ) ; } if ( timeScale < 1 || timeScale > ( 2L < < 32 ) ) { throw new IllegalArgumentException ( "timeScale must be between 1 and 2^32:" + timeScale ) ; } if ( width < 1 || height < 1 ) { throw new IllegalArgumentException ( "Width and height must be greater than 0, width:" + width + " height:" + height ) ; } VideoTrack t = new VideoTrack ( ) ; t . mediaCompressionType = compressionType ; t . mediaCompressorName = compressorName ; t . mediaTimeScale = timeScale ; t . videoWidth = width ; t . videoHeight = height ; t . videoDepth = depth ; t . syncInterval = syncInterval ; for ( VideoFormat vf : VideoFormat . values ( ) ) { if ( vf . compressionType . equals ( compressionType ) ) { t . videoEncoding = vf ; break ; } } tracks . add ( t ) ; } public void addAudioTrack ( AudioFormat format ) throws IOException { ensureStarted ( ) ; String qtAudioFormat ; double sampleRate = format . getSampleRate ( ) ; long timeScale = ( int ) Math . floor ( sampleRate ) ; int sampleSizeInBits = format . getSampleSizeInBits ( ) ; int numberOfChannels = format . getChannels ( ) ; boolean bigEndian = format . isBigEndian ( ) ; int frameDuration = ( int ) ( format . getSampleRate ( ) / format . getFrameRate ( ) ) ; int frameSize = format . getFrameSize ( ) ; boolean isCompressed = format . getProperty ( "vbr" ) != null && ( ( Boolean ) format . getProperty ( "vbr" ) ) . booleanValue ( ) ; if ( format . getEncoding ( ) . equals ( AudioFormat . Encoding . ALAW ) ) { qtAudioFormat = "alaw" ; if ( sampleSizeInBits != 8 ) { throw new IllegalArgumentException ( "Sample size of 8 for ALAW required:" + sampleSizeInBits ) ; } } else if ( format . getEncoding ( ) . equals ( AudioFormat . Encoding . PCM_SIGNED ) ) { switch ( sampleSizeInBits ) { case 16 : qtAudioFormat = ( bigEndian ) ? "twos" : "sowt" ; break ; case 24 : qtAudioFormat = "in24" ; break ; case 32 : qtAudioFormat = "in32" ; break ; default : throw new IllegalArgumentException ( "Sample size of 16, 24 or 32 for PCM_SIGNED required:" + sampleSizeInBits ) ; } } else if ( format . getEncoding ( ) . equals ( AudioFormat . Encoding . PCM_UNSIGNED ) ) { if ( sampleSizeInBits != 8 ) { throw new IllegalArgumentException ( "Sample size of 8 PCM_UNSIGNED required:" + sampleSizeInBits ) ; } qtAudioFormat = "raw " ; } else if ( format . getEncoding ( ) . equals ( AudioFormat . Encoding . ULAW ) ) { if ( sampleSizeInBits != 8 ) { throw new IllegalArgumentException ( "Sample size of 8 for ULAW required:" + sampleSizeInBits ) ; } qtAudioFormat = "ulaw" ; } else if ( format . getEncoding ( ) . toString ( ) . equals ( "MP3" ) ) { qtAudioFormat = ".mp3" ; } else { qtAudioFormat = format . getEncoding ( ) . toString ( ) ; if ( qtAudioFormat . length ( ) != 4 ) { throw new IllegalArgumentException ( "Unsupported encoding:" + format . getEncoding ( ) ) ; } } addAudioTrack ( qtAudioFormat , timeScale , sampleRate , numberOfChannels , sampleSizeInBits , isCompressed , frameDuration , frameSize ) ; } public void addAudioTrack ( String compressionType , long timeScale , double sampleRate , int numberOfChannels , int sampleSizeInBits , boolean isCompressed , int frameDuration , int frameSize ) throws IOException { ensureStarted ( ) ; if ( compressionType == null || compressionType . length ( ) != 4 ) { throw new IllegalArgumentException ( "audioFormat must be 4 characters long:" + compressionType ) ; } if ( timeScale < 1 || timeScale > ( 2L < < 32 ) ) { throw new IllegalArgumentException ( "timeScale must be between 1 and 2^32:" + timeScale ) ; } if ( timeScale != ( int ) Math . floor ( sampleRate ) ) { throw new IllegalArgumentException ( "timeScale: " + timeScale + " must match integer portion of sampleRate: " + sampleRate ) ; } if ( numberOfChannels != 1 && numberOfChannels != 2 ) { throw new IllegalArgumentException ( "numberOfChannels must be 1 or 2: " + numberOfChannels ) ; } if ( sampleSizeInBits != 8 && sampleSizeInBits != 16 ) { throw new IllegalArgumentException ( "sampleSize must be 8 or 16: " + numberOfChannels ) ; } AudioTrack t = new AudioTrack ( ) ; t . mediaCompressionType = compressionType ; t . mediaTimeScale = timeScale ; t . soundSampleRate = sampleRate ; t . soundCompressionId = isCompressed ? - 2 : - 1 ; t . soundNumberOfChannels = numberOfChannels ; t . soundSampleSize = sampleSizeInBits ; t . soundSamplesPerPacket = frameDuration ; if ( isCompressed ) { t . soundBytesPerPacket = frameSize ; t . soundBytesPerFrame = frameSize * numberOfChannels ; } else { t . soundBytesPerPacket = frameSize / numberOfChannels ; t . soundBytesPerFrame = frameSize ; } t . soundBytesPerSample = sampleSizeInBits / 8 ; tracks . add ( t ) ; } public void setCompressionQuality ( int track , float newValue ) { ( ( VideoTrack ) tracks . get ( track ) ) . videoQuality = newValue ; } public float getCompressionQuality ( int track ) { return ( ( VideoTrack ) tracks . get ( track ) ) . videoQuality ; } public void setSyncInterval ( int track , int i ) { ( ( VideoTrack ) tracks . get ( track ) ) . syncInterval = i ; } public int getSyncInterval ( int track ) { return ( ( VideoTrack ) tracks . get ( track ) ) . syncInterval ; } private void ensureStarted ( ) throws IOException { ensureOpen ( ) ; if ( state == States . FINISHED ) { throw new IOException ( "Can not write into finished movie." ) ; } if ( state != States . STARTED ) { creationTime = new Date ( ) ; writeProlog ( ) ; mdatAtom = new WideDataAtom ( "mdat" ) ; state = States . STARTED ; } } public void writeFrame ( int track , BufferedImage image , long duration ) throws IOException { if ( duration <= 0 ) { throw new IllegalArgumentException ( "Duration must be greater 0." ) ; } VideoTrack t = ( VideoTrack ) tracks . get ( track ) ; if ( t . mediaType != MediaType . VIDEO ) { throw new IllegalArgumentException ( "Track " + track + " is not a video track" ) ; } if ( t . videoEncoding == null ) { throw new UnsupportedOperationException ( "Encoding not supported." ) ; } ensureStarted ( ) ; if ( t . videoWidth != image . getWidth ( ) || t . videoHeight != image . getHeight ( ) ) { throw new IllegalArgumentException ( "Dimensions of frame[" + tracks . get ( track ) . getSampleCount ( ) + "] (width=" + image . getWidth ( ) + ", height=" + image . getHeight ( ) + ") differs from video dimension (width=" + t . videoWidth + ", height=" + t . videoHeight + ") in track " + track + "." ) ; } long offset = getRelativeStreamPosition ( ) ; boolean isSync ; switch ( t . videoEncoding ) { case RAW : { isSync = true ; switch ( t . videoDepth ) { case 8 : { if ( image . getType ( ) != BufferedImage . TYPE_BYTE_INDEXED ) { throw new IllegalArgumentException ( "BufferedImage type " + image . getType ( ) + " does not match track type " + BufferedImage . TYPE_BYTE_INDEXED + "." ) ; } WritableRaster raster = image . getRaster ( ) ; int sw = raster . getSampleModel ( ) . getWidth ( ) ; Rectangle r = raster . getBounds ( ) ; r . x -= raster . getSampleModelTranslateX ( ) ; r . y -= raster . getSampleModelTranslateY ( ) ; DataBufferByte buf = ( DataBufferByte ) raster . getDataBuffer ( ) ; byte [ ] bytes = buf . getData ( ) ; for ( int xy = r . x + r . y * sw , ymax = r . x + ( r . y + r . height ) * sw ; xy < ymax ; xy += sw ) { mdatAtom . getOutputStream ( ) . write ( bytes , xy , r . width ) ; } break ; } case 24 : { WritableRaster raster = image . getRaster ( ) ; int [ ] rgb = new int [ t . videoWidth * 3 ] ; byte [ ] bytes = new byte [ t . videoWidth * 3 ] ; for ( int y = 0 ; y < t . videoHeight ; y ++ ) { rgb = raster . getPixels ( 0 , y , t . videoWidth , 1 , rgb ) ; for ( int k = 0 , n = t . videoWidth * 3 ; k < n ; k ++ ) { bytes [ k ] = ( byte ) rgb [ k ] ; } mdatAtom . getOutputStream ( ) . write ( bytes ) ; } break ; } default : throw new UnsupportedOperationException ( "Encoding not supported." ) ; } break ; } case JPG : { isSync = true ; ImageWriter iw = ImageIO . getImageWritersByMIMEType ( "image/jpeg" ) . next ( ) ; ImageWriteParam iwParam = iw . getDefaultWriteParam ( ) ; iwParam . setCompressionMode ( ImageWriteParam . MODE_EXPLICIT ) ; iwParam . setCompressionQuality ( t . videoQuality ) ; MemoryCacheImageOutputStream imgOut = new MemoryCacheImageOutputStream ( mdatAtom . getOutputStream ( ) ) ; iw . setOutput ( imgOut ) ; IIOImage img = new IIOImage ( image , null , null ) ; iw . write ( null , img , iwParam ) ; iw . dispose ( ) ; break ; } case PNG : { isSync = true ; ImageWriter iw = ImageIO . getImageWritersByMIMEType ( "image/png" ) . next ( ) ; ImageWriteParam iwParam = iw . getDefaultWriteParam ( ) ; MemoryCacheImageOutputStream imgOut = new MemoryCacheImageOutputStream ( mdatAtom . getOutputStream ( ) ) ; iw . setOutput ( imgOut ) ; IIOImage img = new IIOImage ( image , null , null ) ; iw . write ( null , img , iwParam ) ; iw . dispose ( ) ; break ; } case RLE : { isSync = t . previousData == null || t . syncInterval != 0 && t . sampleCount % t . syncInterval == 0 ; WritableRaster raster = image . getRaster ( ) ; int sw = raster . getSampleModel ( ) . getWidth ( ) ; Rectangle r = raster . getBounds ( ) ; r . x -= raster . getSampleModelTranslateX ( ) ; r . y -= raster . getSampleModelTranslateY ( ) ; if ( t . encoder == null ) { t . encoder = new AppleRLEEncoder ( ) ; } AppleRLEEncoder enc = t . encoder ; switch ( t . videoDepth ) { case 16 : { DataBufferUShort buf = ( DataBufferUShort ) raster . getDataBuffer ( ) ; short [ ] data = buf . getData ( ) ; if ( isSync ) { enc . writeKey16 ( mdatAtom . getOutputStream ( ) , data , r . width , r . height , r . x + r . y * sw , sw ) ; } else { enc . writeDelta16 ( mdatAtom . getOutputStream ( ) , data , ( short [ ] ) t . previousData , r . width , r . height , r . x + r . y * sw , sw ) ; } if ( t . previousData == null ) { t . previousData = new short [ data . length ] ; } System . arraycopy ( data , 0 , t . previousData , 0 , data . length ) ; break ; } case 24 : { DataBufferInt buf = ( DataBufferInt ) raster . getDataBuffer ( ) ; int [ ] data = buf . getData ( ) ; if ( isSync ) { enc . writeKey24 ( mdatAtom . getOutputStream ( ) , data , r . width , r . height , r . x + r . y * sw , sw ) ; } else { enc . writeDelta24 ( mdatAtom . getOutputStream ( ) , data , ( int [ ] ) t . previousData , r . width , r . height , r . x + r . y * sw , sw ) ; } if ( t . previousData == null ) { t . previousData = new int [ data . length ] ; } System . arraycopy ( data , 0 , t . previousData , 0 , data . length ) ; break ; } case 32 : { DataBufferInt buf = ( DataBufferInt ) raster . getDataBuffer ( ) ; int [ ] data = buf . getData ( ) ; if ( isSync ) { enc . writeKey32 ( mdatAtom . getOutputStream ( ) , data , image . getWidth ( ) , image . getHeight ( ) , 0 , image . getWidth ( ) ) ; } else { enc . writeDelta32 ( mdatAtom . getOutputStream ( ) , data , ( int [ ] ) t . previousData , image . getWidth ( ) , image . getHeight ( ) , 0 , image . getWidth ( ) ) ; } if ( t . previousData == null ) { t . previousData = new int [ data . length ] ; } System . arraycopy ( data , 0 , t . previousData , 0 , data . length ) ; break ; } default : throw new UnsupportedOperationException ( "Encoding not supported." ) ; } break ; } default : { throw new UnsupportedOperationException ( "Encoding not supported." ) ; } } long length = getRelativeStreamPosition ( ) - offset ; t . addSample ( new Sample ( duration , offset , length ) , 1 , isSync ) ; } public void writeSample ( int track , File file , long duration ) throws IOException { writeSample ( track , file , duration , true ) ; } public void writeSample ( int track , File file , long duration , boolean isSync ) throws IOException { ensureStarted ( ) ; FileInputStream in = null ; try { in = new FileInputStream ( file ) ; writeSample ( track , in , duration , isSync ) ; } finally { if ( in != null ) { in . close ( ) ; } } } public void writeSample ( int track , InputStream in , long duration ) throws IOException { writeSample ( track , in , duration , true ) ; } public void writeSample ( int track , InputStream in , long duration , boolean isSync ) throws IOException { ensureStarted ( ) ; if ( duration <= 0 ) { throw new IllegalArgumentException ( "duration must be greater 0" ) ; } Track t = tracks . get ( track ) ; ensureOpen ( ) ; ensureStarted ( ) ; long offset = getRelativeStreamPosition ( ) ; OutputStream mdatOut = mdatAtom . getOutputStream ( ) ; byte [ ] buf = new byte [ 4096 ] ; int len ; while ( ( len = in . read ( buf ) ) != - 1 ) { mdatOut . write ( buf , 0 , len ) ; } long length = getRelativeStreamPosition ( ) - offset ; t . addSample ( new Sample ( duration , offset , length ) , 1 , isSync ) ; } public void writeSample ( int track , byte [ ] data , long duration ) throws IOException { ensureStarted ( ) ; writeSample ( track , data , 0 , data . length , duration , true ) ; } public void writeSample ( int track , byte [ ] data , long duration , boolean isSync ) throws IOException { ensureStarted ( ) ; writeSample ( track , data , 0 , data . length , duration , isSync ) ; } public void writeSample ( int track , byte [ ] data , int off , int len , long duration ) throws IOException { ensureStarted ( ) ; writeSample ( track , data , off , len , duration , true ) ; } public void writeSample ( int track , byte [ ] data , int off , int len , long duration , boolean isSync ) throws IOException { ensureStarted ( ) ; if ( duration <= 0 ) { throw new IllegalArgumentException ( "duration must be greater 0" ) ; } Track t = tracks . get ( track ) ; ensureOpen ( ) ; ensureStarted ( ) ; long offset = getRelativeStreamPosition ( ) ; OutputStream mdatOut = mdatAtom . getOutputStream ( ) ; mdatOut . write ( data , off , len ) ; t . addSample ( new Sample ( duration , offset , len ) , 1 , isSync ) ; } public void writeSamples ( int track , int sampleCount , byte [ ] data , int sampleDuration ) throws IOException { writeSamples ( track , sampleCount , data , 0 , data . length , sampleDuration , true ) ; } public void writeSamples ( int track , int sampleCount , byte [ ] data , int off , int len , int sampleDuration ) throws IOException { writeSamples ( track , sampleCount , data , off , len , sampleDuration , true ) ; } public void writeSamples ( int track , int sampleCount , byte [ ] data , int off , int len , int sampleDuration , boolean isSync ) throws IOException { ensureStarted ( ) ; if ( sampleDuration <= 0 ) { throw new IllegalArgumentException ( "sampleDuration must be greater 0, sampleDuration=" + sampleDuration ) ; } if ( sampleCount <= 0 ) { throw new IllegalArgumentException ( "sampleCount must be greater 0, sampleCount=" + sampleCount ) ; } if ( len % sampleCount != 0 ) { throw new IllegalArgumentException ( "len must be divisable by sampleCount len=" + len + " sampleCount=" + sampleCount ) ; } Track t = tracks . get ( track ) ; ensureOpen ( ) ; ensureStarted ( ) ; long offset = getRelativeStreamPosition ( ) ; OutputStream mdatOut = mdatAtom . getOutputStream ( ) ; mdatOut . write ( data , off , len ) ; int sampleLength = len / sampleCount ; Sample first = new Sample ( sampleDuration , offset , sampleLength ) ; Sample last = new Sample ( sampleDuration , offset + sampleLength * ( sampleCount - 1 ) , sampleLength ) ; t . addChunk ( new Chunk ( first , last , sampleCount , 1 ) , isSync ) ; } public void close ( ) throws IOException { try { if ( state == States . STARTED ) { finish ( ) ; } } finally { if ( state != States . CLOSED ) { out . close ( ) ; state = States . CLOSED ; } } } public void finish ( ) throws IOException { ensureOpen ( ) ; if ( state != States . FINISHED ) { for ( int i = 0 , n = tracks . size ( ) ; i < n ; i ++ ) { } mdatAtom . finish ( ) ; writeEpilog ( ) ; state = States . FINISHED ; } } private void ensureOpen ( ) throws IOException { if ( state == States . CLOSED ) { throw new IOException ( "Stream closed" ) ; } } private long getRelativeStreamPosition ( ) throws IOException { return out . getStreamPosition ( ) - streamOffset ; } private void seekRelative ( long newPosition ) throws IOException { out . seek ( newPosition + streamOffset ) ; } private void writeProlog ( ) throws IOException { DataAtom ftypAtom = new DataAtom ( "ftyp" ) ; DataAtomOutputStream d = ftypAtom . getOutputStream ( ) ; d . writeType ( "qt " ) ; d . writeBCD4 ( 2005 ) ; d . writeBCD2 ( 3 ) ; d . writeBCD2 ( 0 ) ; d . writeType ( "qt " ) ; d . writeInt ( 0 ) ; d . writeInt ( 0 ) ; d . writeInt ( 0 ) ; ftypAtom . finish ( ) ; } private void writeEpilog ( ) throws IOException { Date modificationTime = new Date ( ) ; long duration = getMovieDuration ( ) ; DataAtom leaf ; moovAtom = new CompositeAtom ( "moov" ) ; leaf = new DataAtom ( "mvhd" ) ; moovAtom . add ( leaf ) ; DataAtomOutputStream d = leaf . getOutputStream ( ) ; d . writeByte ( 0 ) ; d . writeByte ( 0 ) ; d . writeByte ( 0 ) ; d . writeByte ( 0 ) ; d . writeMacTimestamp ( creationTime ) ; d . writeMacTimestamp ( modificationTime ) ; d . writeUInt ( movieTimeScale ) ; d . writeUInt ( duration ) ; d . writeFixed16D16 ( 1d ) ; d . writeShort ( 256 ) ; d . write ( new byte [ 10 ] ) ; d . writeFixed16D16 ( 1f ) ; d . writeFixed16D16 ( 0f ) ; d . writeFixed2D30 ( 0f ) ; d . writeFixed16D16 ( 0f ) ; d . writeFixed16D16 ( 1f ) ; d . writeFixed2D30 ( 0 ) ; d . writeFixed16D16 ( 0 ) ; d . writeFixed16D16 ( 0 ) ; d . writeFixed2D30 ( 1f ) ; d . writeInt ( 0 ) ; d . writeInt ( 0 ) ; d . writeInt ( 0 ) ; d . writeInt ( 0 ) ; d . writeInt ( 0 ) ; d . writeInt ( 0 ) ; d . writeUInt ( tracks . size ( ) + 1 ) ; for ( int i = 0 , n = tracks . size ( ) ; i < n ; i ++ ) { Track t = tracks . get ( i ) ; t . writeTrackAtoms ( i , moovAtom , modificationTime ) ; } moovAtom . finish ( ) ; } public void toWebOptimizedMovie ( File outputFile , boolean compressHeader ) throws IOException { finish ( ) ; long originalMdatOffset = mdatAtom . getOffset ( ) ; CompositeAtom originalMoovAtom = moovAtom ; mdatOffset = 0 ; ImageOutputStream originalOut = out ; try { out = null ; if ( compressHeader ) { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; int maxIteration = 5 ; long compressionHeadersSize = 40 + 8 ; long headerSize = 0 ; long freeSize = 0 ; while ( true ) { mdatOffset = compressionHeadersSize + headerSize + freeSize ; buf . reset ( ) ; DeflaterOutputStream deflater = new DeflaterOutputStream ( buf ) ; out = new MemoryCacheImageOutputStream ( deflater ) ; writeEpilog ( ) ; out . close ( ) ; deflater . close ( ) ; if ( buf . size ( ) > headerSize + freeSize && -- maxIteration > 0 ) { if ( headerSize != 0 ) { freeSize = Math . max ( freeSize , buf . size ( ) - headerSize - freeSize ) ; } headerSize = buf . size ( ) ; } else { freeSize = headerSize + freeSize - buf . size ( ) ; headerSize = buf . size ( ) ; break ; } } if ( maxIteration < 0 || buf . size ( ) == 0 ) { compressHeader = false ; System . err . println ( "WARNING QuickTimeWriter failed to compress header." ) ; } else { out = new FileImageOutputStream ( outputFile ) ; writeProlog ( ) ; DataAtomOutputStream daos = new DataAtomOutputStream ( new ImageOutputStreamAdapter ( out ) ) ; daos . writeUInt ( headerSize + 40 ) ; daos . writeType ( "moov" ) ; daos . writeUInt ( headerSize + 32 ) ; daos . writeType ( "cmov" ) ; daos . writeUInt ( 12 ) ; daos . writeType ( "dcom" ) ; daos . writeType ( "zlib" ) ; daos . writeUInt ( headerSize + 12 ) ; daos . writeType ( "cmvd" ) ; daos . writeUInt ( originalMoovAtom . size ( ) ) ; daos . write ( buf . toByteArray ( ) ) ; daos . writeUInt ( freeSize + 8 ) ; daos . writeType ( "free" ) ; for ( int i = 0 ; i < freeSize ; i ++ ) { daos . write ( 0 ) ; } } } if ( ! compressHeader ) { out = new FileImageOutputStream ( outputFile ) ; mdatOffset = moovAtom . size ( ) ; writeProlog ( ) ; writeEpilog ( ) ; } byte [ ] buf = new byte [ 4096 ] ; originalOut . seek ( ( originalMdatOffset ) ) ; for ( long count = 0 , n = mdatAtom . size ( ) ; count < n ; ) { int read = originalOut . read ( buf , 0 , ( int ) Math . min ( buf . length , n - count ) ) ; out . write ( buf , 0 , read ) ; count += read ; } out . close ( ) ; } finally { mdatOffset = 0 ; moovAtom = originalMoovAtom ; out = originalOut ; } } }
package ch . randelshofer . media . quicktime ; import java . io . * ; import java . util . Date ; import java . util . GregorianCalendar ; import javax . imageio . stream . ImageOutputStreamImpl ; public class DataAtomOutputStream extends FilterOutputStream { ImageOutputStreamImpl impl ; protected static final long MAC_TIMESTAMP_EPOCH = new GregorianCalendar ( 1904 , GregorianCalendar . JANUARY , 1 ) . getTimeInMillis ( ) ; protected long written ; public DataAtomOutputStream ( OutputStream out ) { super ( out ) ; } public void writeType ( String s ) throws IOException { if ( s . length ( ) != 4 ) { throw new IllegalArgumentException ( "type string must have 4 characters" ) ; } try { out . write ( s . getBytes ( "ASCII" ) , 0 , 4 ) ; incCount ( 4 ) ; } catch ( UnsupportedEncodingException e ) { throw new InternalError ( e . toString ( ) ) ; } } public final void writeByte ( int v ) throws IOException { out . write ( v ) ; incCount ( 1 ) ; } @ Override public synchronized void write ( byte b [ ] , int off , int len ) throws IOException { out . write ( b , off , len ) ; incCount ( len ) ; } @ Override public synchronized void write ( int b ) throws IOException { out . write ( b ) ; incCount ( 1 ) ; } public void writeInt ( int v ) throws IOException { out . write ( ( v > > > 24 ) & 0xff ) ; out . write ( ( v > > > 16 ) & 0xff ) ; out . write ( ( v > > > 8 ) & 0xff ) ; out . write ( ( v > > > 0 ) & 0xff ) ; incCount ( 4 ) ; } public void writeUInt ( long v ) throws IOException { out . write ( ( int ) ( ( v > > > 24 ) & 0xff ) ) ; out . write ( ( int ) ( ( v > > > 16 ) & 0xff ) ) ; out . write ( ( int ) ( ( v > > > 8 ) & 0xff ) ) ; out . write ( ( int ) ( ( v > > > 0 ) & 0xff ) ) ; incCount ( 4 ) ; } public void writeShort ( int v ) throws IOException { out . write ( ( v > > 8 ) & 0xff ) ; out . write ( ( v > > > 0 ) & 0xff ) ; incCount ( 2 ) ; } public void writeBCD2 ( int v ) throws IOException { out . write ( ( ( v % 100 / 10 ) < < 4 ) | ( v % 10 ) ) ; incCount ( 1 ) ; } public void writeBCD4 ( int v ) throws IOException { out . write ( ( ( v % 10000 / 1000 ) < < 4 ) | ( v % 1000 / 100 ) ) ; out . write ( ( ( v % 100 / 10 ) < < 4 ) | ( v % 10 ) ) ; incCount ( 2 ) ; } public void writeMacTimestamp ( Date date ) throws IOException { long millis = date . getTime ( ) ; long qtMillis = millis - MAC_TIMESTAMP_EPOCH ; long qtSeconds = qtMillis / 1000 ; writeUInt ( qtSeconds ) ; } public void writeFixed16D16 ( double f ) throws IOException { double v = ( f >= 0 ) ? f : - f ; int wholePart = ( int ) Math . floor ( v ) ; int fractionPart = ( int ) ( ( v - wholePart ) * 65536 ) ; int t = ( wholePart < < 16 ) + fractionPart ; if ( f < 0 ) { t = t - 1 ; } writeInt ( t ) ; } public void writeFixed2D30 ( double f ) throws IOException { double v = ( f >= 0 ) ? f : - f ; int wholePart = ( int ) v ; int fractionPart = ( int ) ( ( v - wholePart ) * 1073741824 ) ; int t = ( wholePart < < 30 ) + fractionPart ; if ( f < 0 ) { t = t - 1 ; } writeInt ( t ) ; } public void writeFixed8D8 ( float f ) throws IOException { float v = ( f >= 0 ) ? f : - f ; int wholePart = ( int ) v ; int fractionPart = ( int ) ( ( v - wholePart ) * 256 ) ; int t = ( wholePart < < 8 ) + fractionPart ; if ( f < 0 ) { t = t - 1 ; } writeUShort ( t ) ; } public void writePString ( String s ) throws IOException { if ( s . length ( ) > 0xffff ) { throw new IllegalArgumentException ( "String too long for PString" ) ; } if ( s . length ( ) != 0 && s . length ( ) < 256 ) { out . write ( s . length ( ) ) ; } else { out . write ( 0 ) ; writeShort ( s . length ( ) ) ; } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { out . write ( s . charAt ( i ) ) ; } incCount ( 1 + s . length ( ) ) ; } public void writePString ( String s , int length ) throws IOException { if ( s . length ( ) > length ) { throw new IllegalArgumentException ( "String too long for PString of length " + length ) ; } if ( s . length ( ) != 0 && s . length ( ) < 256 ) { out . write ( s . length ( ) ) ; } else { out . write ( 0 ) ; writeShort ( s . length ( ) ) ; } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { out . write ( s . charAt ( i ) ) ; } for ( int i = 1 + s . length ( ) ; i < length ; i ++ ) { out . write ( 0 ) ; } incCount ( length ) ; } public void writeLong ( long v ) throws IOException { out . write ( ( int ) ( v > > > 56 ) & 0xff ) ; out . write ( ( int ) ( v > > > 48 ) & 0xff ) ; out . write ( ( int ) ( v > > > 40 ) & 0xff ) ; out . write ( ( int ) ( v > > > 32 ) & 0xff ) ; out . write ( ( int ) ( v > > > 24 ) & 0xff ) ; out . write ( ( int ) ( v > > > 16 ) & 0xff ) ; out . write ( ( int ) ( v > > > 8 ) & 0xff ) ; out . write ( ( int ) ( v > > > 0 ) & 0xff ) ; incCount ( 8 ) ; } public void writeUShort ( int v ) throws IOException { out . write ( ( v > > 8 ) & 0xff ) ; out . write ( ( v > > > 0 ) & 0xff ) ; incCount ( 2 ) ; } protected void incCount ( int value ) { long temp = written + value ; if ( temp < 0 ) { temp = Long . MAX_VALUE ; } written = temp ; } public void writeShorts ( short [ ] s , int off , int len ) throws IOException { if ( off < 0 || len < 0 || off + len > s . length || off + len < 0 ) { throw new IndexOutOfBoundsException ( "off < 0 || len < 0 || off + len > s.length!" ) ; } byte [ ] b = new byte [ len * 2 ] ; int boff = 0 ; for ( int i = 0 ; i < len ; i ++ ) { short v = s [ off + i ] ; b [ boff ++ ] = ( byte ) ( v > > > 8 ) ; b [ boff ++ ] = ( byte ) ( v > > > 0 ) ; } write ( b , 0 , len * 2 ) ; } public void writeInts ( int [ ] i , int off , int len ) throws IOException { if ( off < 0 || len < 0 || off + len > i . length || off + len < 0 ) { throw new IndexOutOfBoundsException ( "off < 0 || len < 0 || off + len > i.length!" ) ; } byte [ ] b = new byte [ len * 4 ] ; int boff = 0 ; for ( int j = 0 ; j < len ; j ++ ) { int v = i [ off + j ] ; b [ boff ++ ] = ( byte ) ( v > > > 24 ) ; b [ boff ++ ] = ( byte ) ( v > > > 16 ) ; b [ boff ++ ] = ( byte ) ( v > > > 8 ) ; b [ boff ++ ] = ( byte ) ( v > > > 0 ) ; } write ( b , 0 , len * 4 ) ; } private byte [ ] byteBuf = new byte [ 3 ] ; public void writeInt24 ( int v ) throws IOException { byteBuf [ 0 ] = ( byte ) ( v > > > 16 ) ; byteBuf [ 1 ] = ( byte ) ( v > > > 8 ) ; byteBuf [ 2 ] = ( byte ) ( v > > > 0 ) ; write ( byteBuf , 0 , 3 ) ; } public void writeInts24 ( int [ ] i , int off , int len ) throws IOException { if ( off < 0 || len < 0 || off + len > i . length || off + len < 0 ) { throw new IndexOutOfBoundsException ( "off < 0 || len < 0 || off + len > i.length!" ) ; } byte [ ] b = new byte [ len * 3 ] ; int boff = 0 ; for ( int j = 0 ; j < len ; j ++ ) { int v = i [ off + j ] ; b [ boff ++ ] = ( byte ) ( v > > > 16 ) ; b [ boff ++ ] = ( byte ) ( v > > > 8 ) ; b [ boff ++ ] = ( byte ) ( v > > > 0 ) ; } write ( b , 0 , len * 3 ) ; } public final long size ( ) { return written ; } }
package ch . randelshofer . gui . datatransfer ; import java . awt . datatransfer . * ; import java . awt . im . InputContext ; import java . io . * ; import java . util . * ; import javax . swing . * ; import javax . swing . text . * ; public class FileTextFieldTransferHandler extends TransferHandler { private boolean shouldRemove ; private JTextComponent exportComp ; private int p0 ; private int p1 ; private int fileSelectionMode ; private FileFilter fileFilter ; public FileTextFieldTransferHandler ( ) { this ( JFileChooser . FILES_ONLY ) ; } public FileTextFieldTransferHandler ( int fileSelectionMode ) { this ( fileSelectionMode , null ) ; } public FileTextFieldTransferHandler ( int fileSelectionMode , FileFilter filter ) { this . fileFilter = filter ; if ( fileSelectionMode != JFileChooser . FILES_AND_DIRECTORIES && fileSelectionMode != JFileChooser . FILES_ONLY && fileSelectionMode != JFileChooser . DIRECTORIES_ONLY ) { throw new IllegalArgumentException ( "illegal file selection mode:" + fileSelectionMode ) ; } this . fileSelectionMode = fileSelectionMode ; } @ Override public boolean importData ( JComponent comp , Transferable t ) { JTextComponent c = ( JTextComponent ) comp ; if ( c == exportComp && c . getCaretPosition ( ) >= p0 && c . getCaretPosition ( ) <= p1 ) { shouldRemove = false ; return true ; } boolean imported = false ; if ( t . isDataFlavorSupported ( DataFlavor . javaFileListFlavor ) ) { InputContext ic = c . getInputContext ( ) ; if ( ic != null ) { ic . endComposition ( ) ; } try { java . util . List list = ( List ) t . getTransferData ( DataFlavor . javaFileListFlavor ) ; if ( list . size ( ) > 0 ) { File file = ( File ) list . get ( 0 ) ; switch ( fileSelectionMode ) { case JFileChooser . FILES_AND_DIRECTORIES : break ; case JFileChooser . FILES_ONLY : if ( file . isDirectory ( ) ) { return false ; } break ; case JFileChooser . DIRECTORIES_ONLY : if ( ! file . isDirectory ( ) ) { return false ; } break ; } if ( fileFilter != null && ! fileFilter . accept ( file ) ) { return false ; } c . setText ( file . getPath ( ) ) ; } imported = true ; } catch ( UnsupportedFlavorException ex ) { } catch ( IOException ex ) { } } if ( ! imported ) { DataFlavor importFlavor = getImportFlavor ( t . getTransferDataFlavors ( ) , c ) ; if ( importFlavor != null ) { InputContext ic = c . getInputContext ( ) ; if ( ic != null ) { ic . endComposition ( ) ; } try { Reader r = importFlavor . getReaderForText ( t ) ; boolean useRead = false ; handleReaderImport ( r , c , useRead ) ; imported = true ; } catch ( UnsupportedFlavorException ex ) { } catch ( BadLocationException ex ) { } catch ( IOException ex ) { } } } return imported ; } @ Override protected Transferable createTransferable ( JComponent comp ) { CompositeTransferable t ; JTextComponent c = ( JTextComponent ) comp ; shouldRemove = true ; p0 = c . getSelectionStart ( ) ; p1 = c . getSelectionEnd ( ) ; if ( p0 != p1 ) { t = new CompositeTransferable ( ) ; String text = c . getSelectedText ( ) ; t . add ( new StringTransferable ( text ) ) ; t . add ( new PlainTextTransferable ( text ) ) ; } else { t = null ; } return t ; } @ Override public boolean canImport ( JComponent comp , DataFlavor [ ] transferFlavors ) { JTextComponent c = ( JTextComponent ) comp ; if ( ! ( c . isEditable ( ) && c . isEnabled ( ) ) ) { return false ; } for ( DataFlavor flavor : transferFlavors ) { if ( flavor . isFlavorJavaFileListType ( ) || flavor . isFlavorTextType ( ) ) { return true ; } } return false ; } protected DataFlavor getImportFlavor ( DataFlavor [ ] flavors , JTextComponent c ) { DataFlavor refFlavor = null ; DataFlavor stringFlavor = null ; for ( int i = 0 ; i < flavors . length ; i ++ ) { String mime = flavors [ i ] . getMimeType ( ) ; if ( mime . startsWith ( "text/plain" ) ) { return flavors [ i ] ; } else if ( refFlavor == null && mime . startsWith ( "application/x-java-jvm-local-objectref" ) && flavors [ i ] . getRepresentationClass ( ) == java . lang . String . class ) { refFlavor = flavors [ i ] ; } else if ( stringFlavor == null && flavors [ i ] . equals ( DataFlavor . stringFlavor ) ) { stringFlavor = flavors [ i ] ; } } if ( refFlavor != null ) { return refFlavor ; } else if ( stringFlavor != null ) { return stringFlavor ; } return null ; } protected void handleReaderImport ( Reader in , JTextComponent c , boolean useRead ) throws BadLocationException , IOException { if ( useRead ) { int startPosition = c . getSelectionStart ( ) ; int endPosition = c . getSelectionEnd ( ) ; int length = endPosition - startPosition ; EditorKit kit = c . getUI ( ) . getEditorKit ( c ) ; Document doc = c . getDocument ( ) ; if ( length > 0 ) { doc . remove ( startPosition , length ) ; } kit . read ( in , doc , startPosition ) ; } else { char [ ] buff = new char [ 1024 ] ; int nch ; boolean lastWasCR = false ; int last ; StringBuilder sb = null ; while ( ( nch = in . read ( buff , 0 , buff . length ) ) != - 1 ) { if ( sb == null ) { sb = new StringBuilder ( nch ) ; } last = 0 ; for ( int counter = 0 ; counter < nch ; counter ++ ) { switch ( buff [ counter ] ) { case '\r' : if ( lastWasCR ) { if ( counter == 0 ) { sb . append ( '\n' ) ; } else { buff [ counter - 1 ] = '\n' ; } } else { lastWasCR = true ; } break ; case '\n' : if ( lastWasCR ) { if ( counter > ( last + 1 ) ) { sb . append ( buff , last , counter - last - 1 ) ; } lastWasCR = false ; last = counter ; } break ; default : if ( lastWasCR ) { if ( counter == 0 ) { sb . append ( '\n' ) ; } else { buff [ counter - 1 ] = '\n' ; } lastWasCR = false ; } break ; } } if ( last < nch ) { if ( lastWasCR ) { if ( last < ( nch - 1 ) ) { sb . append ( buff , last , nch - last - 1 ) ; } } else { sb . append ( buff , last , nch - last ) ; } } } if ( lastWasCR ) { sb . append ( '\n' ) ; } System . out . println ( "FileTextTransferHandler " + c . getSelectionStart ( ) + ".." + c . getSelectionEnd ( ) ) ; c . replaceSelection ( sb != null ? sb . toString ( ) : "" ) ; } } @ Override public int getSourceActions ( JComponent comp ) { JTextComponent c = ( JTextComponent ) comp ; if ( c instanceof JPasswordField && c . getClientProperty ( "JPasswordField.cutCopyAllowed" ) != Boolean . TRUE ) { return NONE ; } return c . isEditable ( ) ? COPY_OR_MOVE : COPY ; } @ Override protected void exportDone ( JComponent comp , Transferable data , int action ) { JTextComponent c = ( JTextComponent ) comp ; if ( shouldRemove && action == MOVE ) { try { Document doc = c . getDocument ( ) ; doc . remove ( p0 , p1 - p0 ) ; } catch ( BadLocationException e ) { } } exportComp = null ; } public FileFilter getFileFilter ( ) { return fileFilter ; } public void setFileFilter ( FileFilter fileFilter ) { this . fileFilter = fileFilter ; } }
package ch . randelshofer . gui . datatransfer ; import java . awt . datatransfer . * ; public abstract class AbstractTransferable implements Transferable { private DataFlavor [ ] flavors ; public AbstractTransferable ( DataFlavor [ ] flavors ) { this . flavors = flavors ; } public DataFlavor [ ] getTransferDataFlavors ( ) { return flavors . clone ( ) ; } public boolean isDataFlavorSupported ( DataFlavor flavor ) { for ( DataFlavor f : flavors ) { if ( f . equals ( flavor ) ) { return true ; } } return false ; } }
package ch . randelshofer . gui . datatransfer ; import java . awt . datatransfer . * ; import java . util . * ; import java . io . * ; public class CompositeTransferable implements java . awt . datatransfer . Transferable { private HashMap < DataFlavor , Transferable > transferables = new HashMap < DataFlavor , Transferable > ( ) ; private LinkedList < DataFlavor > flavors = new LinkedList < DataFlavor > ( ) ; public CompositeTransferable ( ) { } public void add ( Transferable t ) { DataFlavor [ ] f = t . getTransferDataFlavors ( ) ; for ( int i = 0 ; i < f . length ; i ++ ) { if ( ! transferables . containsKey ( f [ i ] ) ) flavors . add ( f [ i ] ) ; transferables . put ( f [ i ] , t ) ; } } public Object getTransferData ( DataFlavor flavor ) throws UnsupportedFlavorException , IOException { Transferable t = transferables . get ( flavor ) ; if ( t == null ) throw new UnsupportedFlavorException ( flavor ) ; return t . getTransferData ( flavor ) ; } public DataFlavor [ ] getTransferDataFlavors ( ) { return flavors . toArray ( new DataFlavor [ transferables . size ( ) ] ) ; } public boolean isDataFlavorSupported ( DataFlavor flavor ) { return transferables . containsKey ( flavor ) ; } }
package ch . randelshofer . gui . datatransfer ; import java . awt . datatransfer . * ; import java . io . * ; public class PlainTextTransferable extends AbstractTransferable { private String plainText ; public PlainTextTransferable ( String plainText ) { this ( getDefaultFlavors ( ) , plainText ) ; } public PlainTextTransferable ( DataFlavor flavor , String plainText ) { this ( new DataFlavor [ ] { flavor } , plainText ) ; } public PlainTextTransferable ( DataFlavor [ ] flavors , String plainText ) { super ( flavors ) ; this . plainText = plainText ; } public Object getTransferData ( DataFlavor flavor ) throws UnsupportedFlavorException , IOException { if ( ! isDataFlavorSupported ( flavor ) ) { throw new UnsupportedFlavorException ( flavor ) ; } plainText = ( plainText == null ) ? "" : plainText ; if ( String . class . equals ( flavor . getRepresentationClass ( ) ) ) { return plainText ; } else if ( Reader . class . equals ( flavor . getRepresentationClass ( ) ) ) { return new StringReader ( plainText ) ; } else if ( InputStream . class . equals ( flavor . getRepresentationClass ( ) ) ) { String charsetName = flavor . getParameter ( "charset" ) ; return new ByteArrayInputStream ( plainText . getBytes ( charsetName == null ? "UTF-8" : charsetName ) ) ; } throw new UnsupportedFlavorException ( flavor ) ; } protected static DataFlavor [ ] getDefaultFlavors ( ) { try { return new DataFlavor [ ] { new DataFlavor ( "text/plain;class=java.lang.String" ) , new DataFlavor ( "text/plain;class=java.io.Reader" ) , new DataFlavor ( "text/plain;charset=unicode;class=java.io.InputStream" ) } ; } catch ( ClassNotFoundException cle ) { InternalError ie = new InternalError ( "error initializing PlainTextTransferable" ) ; ie . initCause ( cle ) ; throw ie ; } } }
package ch . randelshofer . gui . datatransfer ; import java . awt . datatransfer . * ; import java . io . IOException ; public class StringTransferable extends AbstractTransferable { private String string ; public StringTransferable ( String string ) { this ( getDefaultFlavors ( ) , string ) ; } public StringTransferable ( DataFlavor flavor , String string ) { this ( new DataFlavor [ ] { flavor } , string ) ; } public StringTransferable ( DataFlavor [ ] flavors , String string ) { super ( flavors ) ; this . string = string ; } public Object getTransferData ( DataFlavor flavor ) throws UnsupportedFlavorException , IOException { if ( ! isDataFlavorSupported ( flavor ) ) { throw new UnsupportedFlavorException ( flavor ) ; } return string ; } protected static DataFlavor [ ] getDefaultFlavors ( ) { try { return new DataFlavor [ ] { new DataFlavor ( DataFlavor . javaJVMLocalObjectMimeType + ";class=java.lang.String" ) , DataFlavor . stringFlavor } ; } catch ( ClassNotFoundException cle ) { InternalError ie = new InternalError ( "error initializing StringTransferable" ) ; ie . initCause ( cle ) ; throw ie ; } } }
package ch . randelshofer . io ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Arrays ; import static java . lang . Math . * ; public class SeekableByteArrayOutputStream extends ByteArrayOutputStream { private int pos ; public SeekableByteArrayOutputStream ( ) { this ( 32 ) ; } public SeekableByteArrayOutputStream ( int size ) { if ( size < 0 ) { throw new IllegalArgumentException ( "Negative initial size: " + size ) ; } buf = new byte [ size ] ; } @ Override public synchronized void write ( int b ) { int newcount = max ( pos + 1 , count ) ; if ( newcount > buf . length ) { buf = Arrays . copyOf ( buf , Math . max ( buf . length < < 1 , newcount ) ) ; } buf [ pos ++ ] = ( byte ) b ; count = newcount ; } @ Override public synchronized void write ( byte b [ ] , int off , int len ) { if ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == 0 ) { return ; } int newcount = max ( pos + len , count ) ; if ( newcount > buf . length ) { buf = Arrays . copyOf ( buf , Math . max ( buf . length < < 1 , newcount ) ) ; } System . arraycopy ( b , off , buf , pos , len ) ; pos += len ; count = newcount ; } @ Override public synchronized void reset ( ) { count = 0 ; pos = 0 ; } public void seek ( long pos ) throws IOException { this . pos = ( int ) pos ; } public long getStreamPosition ( ) throws IOException { return pos ; } public void toOutputStream ( OutputStream out ) throws IOException { out . write ( buf , 0 , count ) ; } }
package ch . randelshofer . io ; import java . io . IOException ; import java . io . OutputStream ; import javax . imageio . stream . ImageOutputStream ; public class ImageOutputStreamAdapter extends OutputStream { protected ImageOutputStream out ; public ImageOutputStreamAdapter ( ImageOutputStream out ) { this . out = out ; } @ Override public void write ( int b ) throws IOException { out . write ( b ) ; } @ Override public void write ( byte b [ ] ) throws IOException { write ( b , 0 , b . length ) ; } @ Override public void write ( byte b [ ] , int off , int len ) throws IOException { out . write ( b , off , len ) ; } @ Override public void flush ( ) throws IOException { out . flush ( ) ; } @ Override public void close ( ) throws IOException { try { flush ( ) ; } finally { out . close ( ) ; } } }
package processing . app . tools ; import java . awt . * ; import java . awt . event . * ; import java . awt . image . * ; import java . io . * ; import java . util . * ; import java . util . prefs . Preferences ; import javax . imageio . ImageIO ; import javax . sound . sampled . * ; import javax . swing . * ; import javax . swing . border . EmptyBorder ; import javax . swing . filechooser . FileSystemView ; import processing . app . Editor ; import ch . randelshofer . gui . datatransfer . FileTextFieldTransferHandler ; import ch . randelshofer . media . mp3 . MP3AudioInputStream ; import ch . randelshofer . media . quicktime . QuickTimeWriter ; public class MovieMaker extends JFrame implements Tool { private Preferences prefs ; public String getMenuTitle ( ) { return "Movie Maker" ; } public void run ( ) { setVisible ( true ) ; } public void init ( Editor editor ) { initComponents ( editor == null ) ; ( ( JComponent ) getContentPane ( ) ) . setBorder ( new EmptyBorder ( 12 , 18 , 18 , 18 ) ) ; imageFolderField . setTransferHandler ( new FileTextFieldTransferHandler ( JFileChooser . DIRECTORIES_ONLY ) ) ; soundFileField . setTransferHandler ( new FileTextFieldTransferHandler ( ) ) ; JComponent [ ] smallComponents = { compressionBox , compressionLabel , fpsField , fpsLabel , widthField , widthLabel , heightField , heightLabel , originalSizeCheckBox , } ; for ( JComponent c : smallComponents ) { c . putClientProperty ( "JComponent.sizeVariant" , "small" ) ; } prefs = Preferences . userNodeForPackage ( MovieMaker . class ) ; imageFolderField . setText ( prefs . get ( "movie.imageFolder" , "" ) ) ; soundFileField . setText ( prefs . get ( "movie.soundFile" , "" ) ) ; widthField . setText ( "" + prefs . getInt ( "movie.width" , 640 ) ) ; heightField . setText ( "" + prefs . getInt ( "movie.height" , 480 ) ) ; boolean original = prefs . getBoolean ( "movie.originalSize" , false ) ; originalSizeCheckBox . setSelected ( original ) ; widthField . setEnabled ( ! original ) ; heightField . setEnabled ( ! original ) ; String fps = "" + prefs . getDouble ( "movie.fps" , 30 ) ; if ( fps . endsWith ( ".0" ) ) { fps = fps . substring ( 0 , fps . length ( ) - 2 ) ; } fpsField . setText ( fps ) ; compressionBox . setSelectedIndex ( Math . max ( 0 , Math . min ( compressionBox . getItemCount ( ) - 1 , prefs . getInt ( "movie.compression" , 0 ) ) ) ) ; originalSizeCheckBox . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { boolean enabled = ! originalSizeCheckBox . isSelected ( ) ; widthField . setEnabled ( enabled ) ; heightField . setEnabled ( enabled ) ; } } ) ; pack ( ) ; setLocationRelativeTo ( null ) ; } static public void registerWindowCloseKeys ( JRootPane root , ActionListener disposer ) { KeyStroke stroke = KeyStroke . getKeyStroke ( KeyEvent . VK_ESCAPE , 0 ) ; root . registerKeyboardAction ( disposer , stroke , JComponent . WHEN_IN_FOCUSED_WINDOW ) ; int modifiers = Toolkit . getDefaultToolkit ( ) . getMenuShortcutKeyMask ( ) ; stroke = KeyStroke . getKeyStroke ( 'W' , modifiers ) ; root . registerKeyboardAction ( disposer , stroke , JComponent . WHEN_IN_FOCUSED_WINDOW ) ; } private void initComponents ( final boolean standalone ) { imageFolderHelpLabel = new JLabel ( ) ; imageFolderField = new JTextField ( ) ; chooseImageFolderButton = new JButton ( ) ; soundFileHelpLabel = new JLabel ( ) ; soundFileField = new JTextField ( ) ; chooseSoundFileButton = new JButton ( ) ; createMovieButton = new JButton ( ) ; widthLabel = new JLabel ( ) ; widthField = new JTextField ( ) ; heightLabel = new JLabel ( ) ; heightField = new JTextField ( ) ; compressionLabel = new JLabel ( ) ; compressionBox = new JComboBox < String > ( ) ; fpsLabel = new JLabel ( ) ; fpsField = new JTextField ( ) ; originalSizeCheckBox = new JCheckBox ( ) ; setDefaultCloseOperation ( WindowConstants . DO_NOTHING_ON_CLOSE ) ; addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { setVisible ( false ) ; } } ) ; registerWindowCloseKeys ( getRootPane ( ) , new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { if ( standalone ) { System . exit ( 0 ) ; } else { setVisible ( false ) ; } } } ) ; setTitle ( "QuickTime Movie Maker" ) ; aboutLabel = new JLabel ( "<html>" + "<b>This tool creates a QuickTime movie from a sequence of images.</b><br> " + "<br>" + "To avoid artifacts caused by re-compressing images as video,<br> " + "use TIFF, TGA (from Processing), or PNG images as the source.<br>" + "<br>" + "TIFF and TGA images will write more quickly, but require more disk:<br>" + "<tt>saveFrame(\"frames/####.tif\");</tt><br>" + "<tt>saveFrame(\"frames/####.tga\");</tt><br>" + "<br>" + "PNG images are smaller, but your sketch will run more slowly:<br>" + "<tt>saveFrame(\"frames/####.png\");</tt><br>" + "<br>" + "<font color=#808080>This code is based on QuickTime Movie Maker 1.5.1 2011-01-17.<br>" + "Copyright \u00A9 2010-2011 Werner Randelshofer. All rights reserved.<br>" + "This software is licensed under Creative Commons Atribution 3.0." ) ; imageFolderHelpLabel . setText ( "Drag a folder with image files into the field below:" ) ; chooseImageFolderButton . setText ( "Choose..." ) ; chooseImageFolderButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Chooser . selectFolder ( MovieMaker . this , "Select image folder..." , new File ( imageFolderField . getText ( ) ) , new Chooser . Callback ( ) { void select ( File file ) { if ( file != null ) { imageFolderField . setText ( file . getAbsolutePath ( ) ) ; } } } ) ; } } ) ; soundFileHelpLabel . setText ( "Drag a sound file into the field below (.au, .aiff, .wav, .mp3):" ) ; chooseSoundFileButton . setText ( "Choose..." ) ; chooseSoundFileButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Chooser . selectInput ( MovieMaker . this , "Select sound file..." , new File ( soundFileField . getText ( ) ) , new Chooser . Callback ( ) { void select ( File file ) { if ( file != null ) { soundFileField . setText ( file . getAbsolutePath ( ) ) ; } } } ) ; } } ) ; createMovieButton . setText ( "Create Movie..." ) ; createMovieButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { String lastPath = prefs . get ( "movie.outputFile" , null ) ; File lastFile = lastPath == null ? null : new File ( lastPath ) ; Chooser . selectOutput ( MovieMaker . this , "Save movie as..." , lastFile , new Chooser . Callback ( ) { @ Override void select ( File file ) { if ( file != null ) { String path = file . getAbsolutePath ( ) ; if ( ! path . toLowerCase ( ) . endsWith ( ".mov" ) ) { path += ".mov" ; } prefs . put ( "movie.outputFile" , path ) ; createMovie ( new File ( path ) ) ; } } } ) ; } } ) ; Font font = new Font ( "Dialog" , Font . PLAIN , 11 ) ; widthLabel . setFont ( font ) ; widthLabel . setText ( "Width:" ) ; widthField . setColumns ( 4 ) ; widthField . setFont ( font ) ; widthField . setText ( "320" ) ; heightLabel . setFont ( font ) ; heightLabel . setText ( "Height:" ) ; heightField . setColumns ( 4 ) ; heightField . setFont ( font ) ; heightField . setText ( "240" ) ; compressionLabel . setFont ( font ) ; compressionLabel . setText ( "Compression:" ) ; compressionBox . setFont ( font ) ; compressionBox . setModel ( new DefaultComboBoxModel < String > ( new String [ ] { "Animation" , "JPEG" , "PNG" } ) ) ; fpsLabel . setFont ( font ) ; fpsLabel . setText ( "Frame Rate:" ) ; fpsField . setColumns ( 4 ) ; fpsField . setFont ( font ) ; fpsField . setText ( "30" ) ; originalSizeCheckBox . setFont ( font ) ; originalSizeCheckBox . setText ( "Same size as originals" ) ; originalSizeCheckBox . setToolTipText ( "Check this box if the folder contains already encoded video frames in the desired size." ) ; GroupLayout layout = new GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addGap ( 61 , 61 , 61 ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( widthLabel ) . addComponent ( fpsLabel ) ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( fpsField , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( compressionLabel ) . addGap ( 1 , 1 , 1 ) . addComponent ( compressionBox , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( originalSizeCheckBox ) ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( widthField , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( heightLabel ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( heightField , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) ) ) . addGap ( 41 , 41 , 41 ) ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( aboutLabel , GroupLayout . DEFAULT_SIZE , 484 , Short . MAX_VALUE ) . addComponent ( imageFolderHelpLabel ) . addComponent ( soundFileHelpLabel ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( soundFileField , GroupLayout . DEFAULT_SIZE , 372 , Short . MAX_VALUE ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( chooseSoundFileButton ) ) . addComponent ( createMovieButton , GroupLayout . Alignment . TRAILING ) . addGroup ( GroupLayout . Alignment . TRAILING , layout . createSequentialGroup ( ) . addComponent ( imageFolderField , GroupLayout . DEFAULT_SIZE , 372 , Short . MAX_VALUE ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( chooseImageFolderButton ) ) ) ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) ) ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( aboutLabel , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addGap ( 18 , 18 , 18 ) . addComponent ( imageFolderHelpLabel ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . BASELINE ) . addComponent ( imageFolderField , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addComponent ( chooseImageFolderButton ) ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . BASELINE ) . addComponent ( widthLabel ) . addComponent ( widthField , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addComponent ( heightLabel ) . addComponent ( heightField , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . BASELINE ) . addComponent ( compressionBox , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addComponent ( fpsLabel ) . addComponent ( fpsField , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addComponent ( compressionLabel ) . addComponent ( originalSizeCheckBox ) ) . addGap ( 18 , 18 , 18 ) . addComponent ( soundFileHelpLabel ) . addPreferredGap ( LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . BASELINE ) . addComponent ( soundFileField , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addComponent ( chooseSoundFileButton ) ) . addGap ( 18 , 18 , 18 ) . addComponent ( createMovieButton ) . addContainerGap ( ) ) ) ; pack ( ) ; } int width , height ; private void createMovie ( final File movieFile ) { createMovieButton . setEnabled ( false ) ; final File soundFile = soundFileField . getText ( ) . trim ( ) . length ( ) == 0 ? null : new File ( soundFileField . getText ( ) . trim ( ) ) ; final File imageFolder = imageFolderField . getText ( ) . trim ( ) . length ( ) == 0 ? null : new File ( imageFolderField . getText ( ) . trim ( ) ) ; final String streaming = "fastStartCompressed" ; if ( soundFile == null && imageFolder == null ) { JOptionPane . showMessageDialog ( this , "<html>You need to specify a folder with<br>image files and/or a sound file." ) ; return ; } final double fps ; try { width = Integer . parseInt ( widthField . getText ( ) ) ; height = Integer . parseInt ( heightField . getText ( ) ) ; fps = Double . parseDouble ( fpsField . getText ( ) ) ; } catch ( Throwable t ) { JOptionPane . showMessageDialog ( this , "<html>Width, Height and FPS must be numeric." ) ; return ; } if ( width < 1 || height < 1 || fps < 1 ) { JOptionPane . showMessageDialog ( this , "<html>Width, Height and FPS must be greater than zero." ) ; return ; } final QuickTimeWriter . VideoFormat videoFormat ; switch ( compressionBox . getSelectedIndex ( ) ) { case 0 : videoFormat = QuickTimeWriter . VideoFormat . RLE ; break ; case 1 : videoFormat = QuickTimeWriter . VideoFormat . JPG ; break ; case 2 : default : videoFormat = QuickTimeWriter . VideoFormat . PNG ; break ; } prefs . put ( "movie.imageFolder" , imageFolderField . getText ( ) ) ; prefs . put ( "movie.soundFile" , soundFileField . getText ( ) ) ; prefs . putInt ( "movie.width" , width ) ; prefs . putInt ( "movie.height" , height ) ; prefs . putDouble ( "movie.fps" , fps ) ; prefs . putInt ( "movie.compression" , compressionBox . getSelectedIndex ( ) ) ; prefs . putBoolean ( "movie.originalSize" , originalSizeCheckBox . isSelected ( ) ) ; final boolean originalSize = originalSizeCheckBox . isSelected ( ) ; SwingWorker w = new SwingWorker ( ) { @ Override protected Object doInBackground ( ) { try { File [ ] imgFiles = null ; if ( imageFolder != null ) { imgFiles = imageFolder . listFiles ( new FileFilter ( ) { FileSystemView fsv = FileSystemView . getFileSystemView ( ) ; public boolean accept ( File f ) { return f . isFile ( ) && ! fsv . isHiddenFile ( f ) && ! f . getName ( ) . equals ( "Thumbs.db" ) ; } } ) ; if ( imgFiles == null || imgFiles . length == 0 ) { return new RuntimeException ( "No image files found." ) ; } Arrays . sort ( imgFiles ) ; } if ( originalSize ) { BufferedImage temp = readImage ( imgFiles [ 0 ] ) ; if ( temp == null ) { return new RuntimeException ( "Coult not read " + imgFiles [ 0 ] . getAbsolutePath ( ) ) ; } width = temp . getWidth ( ) ; height = temp . getHeight ( ) ; if ( width <= 0 || height <= 0 ) { return new RuntimeException ( "Could not read " + imgFiles [ 0 ] . getName ( ) + ", it may be bad." ) ; } } if ( movieFile . exists ( ) ) { movieFile . delete ( ) ; } if ( imageFolder != null && soundFile != null ) { writeVideoAndAudio ( movieFile , imgFiles , soundFile , width , height , fps , videoFormat , streaming ) ; } else if ( imageFolder != null ) { writeVideoOnlyVFR ( movieFile , imgFiles , width , height , fps , videoFormat , streaming ) ; } else { writeAudioOnly ( movieFile , soundFile , streaming ) ; } return null ; } catch ( Throwable t ) { return t ; } } @ Override protected void done ( ) { Object o ; try { o = get ( ) ; } catch ( Exception ex ) { o = ex ; } if ( o instanceof Throwable ) { Throwable t = ( Throwable ) o ; t . printStackTrace ( ) ; JOptionPane . showMessageDialog ( MovieMaker . this , "<html>Creating the QuickTime Movie failed.<br>" + ( t . getMessage ( ) == null ? t . toString ( ) : t . getMessage ( ) ) , "Sorry" , JOptionPane . ERROR_MESSAGE ) ; } createMovieButton . setEnabled ( true ) ; } } ; w . execute ( ) ; } private BufferedImage readImage ( File file ) throws IOException { Thread current = Thread . currentThread ( ) ; ClassLoader origLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; current . setContextClassLoader ( getClass ( ) . getClassLoader ( ) ) ; BufferedImage image = ImageIO . read ( file ) ; current . setContextClassLoader ( origLoader ) ; if ( image == null ) { String path = file . getAbsolutePath ( ) ; String pathLower = path . toLowerCase ( ) ; if ( pathLower . endsWith ( ".tga" ) ) { return loadImageTGA ( file ) ; } else if ( pathLower . endsWith ( ".tif" ) || pathLower . endsWith ( ".tiff" ) ) { throw new IOException ( "Try TGA or PNG images instead of TIFF." ) ; } } return image ; } private void writeVideoOnlyVFR ( File movieFile , File [ ] imgFiles , int width , int height , double fps , QuickTimeWriter . VideoFormat videoFormat , String streaming ) throws IOException { File tmpFile = streaming . equals ( "none" ) ? movieFile : new File ( movieFile . getPath ( ) + ".tmp" ) ; ProgressMonitor p = new ProgressMonitor ( MovieMaker . this , "Creating " + movieFile . getName ( ) , "Creating output file..." , 0 , imgFiles . length ) ; Graphics2D g = null ; BufferedImage img = null ; BufferedImage prevImg = null ; int [ ] data = null ; int [ ] prevData = null ; QuickTimeWriter qtOut = null ; try { int timeScale = ( int ) ( fps * 100.0 ) ; int duration = 100 ; qtOut = new QuickTimeWriter ( videoFormat == QuickTimeWriter . VideoFormat . RAW ? movieFile : tmpFile ) ; qtOut . addVideoTrack ( videoFormat , timeScale , width , height ) ; qtOut . setSyncInterval ( 0 , 30 ) ; if ( true ) { img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; data = ( ( DataBufferInt ) img . getRaster ( ) . getDataBuffer ( ) ) . getData ( ) ; prevImg = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; prevData = ( ( DataBufferInt ) prevImg . getRaster ( ) . getDataBuffer ( ) ) . getData ( ) ; g = img . createGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_QUALITY ) ; } int prevImgDuration = 0 ; for ( int i = 0 ; i < imgFiles . length && ! p . isCanceled ( ) ; i ++ ) { File f = imgFiles [ i ] ; p . setNote ( "Processing " + f . getName ( ) ) ; p . setProgress ( i ) ; if ( false ) { qtOut . writeSample ( 0 , f , duration ) ; } else { BufferedImage fImg = readImage ( f ) ; g . drawImage ( fImg , 0 , 0 , width , height , null ) ; if ( i != 0 && Arrays . equals ( data , prevData ) ) { prevImgDuration += duration ; } else { if ( prevImgDuration != 0 ) { qtOut . writeFrame ( 0 , prevImg , prevImgDuration ) ; } prevImgDuration = duration ; System . arraycopy ( data , 0 , prevData , 0 , data . length ) ; } } } if ( prevImgDuration != 0 ) { qtOut . writeFrame ( 0 , prevImg , prevImgDuration ) ; } if ( streaming . equals ( "fastStart" ) ) { qtOut . toWebOptimizedMovie ( movieFile , false ) ; tmpFile . delete ( ) ; } else if ( streaming . equals ( "fastStartCompressed" ) ) { qtOut . toWebOptimizedMovie ( movieFile , true ) ; tmpFile . delete ( ) ; } qtOut . close ( ) ; qtOut = null ; } finally { p . close ( ) ; if ( g != null ) { g . dispose ( ) ; } if ( img != null ) { img . flush ( ) ; } if ( qtOut != null ) { qtOut . close ( ) ; } } } private void writeAudioOnly ( File movieFile , File audioFile , String streaming ) throws IOException { File tmpFile = streaming . equals ( "none" ) ? movieFile : new File ( movieFile . getPath ( ) + ".tmp" ) ; int length = ( int ) Math . min ( Integer . MAX_VALUE , audioFile . length ( ) ) ; ProgressMonitor p = new ProgressMonitor ( MovieMaker . this , "Creating " + movieFile . getName ( ) , "Initializing..." , 0 , length ) ; AudioInputStream audioIn = null ; QuickTimeWriter qtOut = null ; try { qtOut = new QuickTimeWriter ( tmpFile ) ; if ( audioFile . getName ( ) . toLowerCase ( ) . endsWith ( ".mp3" ) ) { audioIn = new MP3AudioInputStream ( audioFile ) ; } else { audioIn = AudioSystem . getAudioInputStream ( audioFile ) ; } AudioFormat audioFormat = audioIn . getFormat ( ) ; qtOut . addAudioTrack ( audioFormat ) ; boolean isVBR = audioFormat . getProperty ( "vbr" ) != null && ( ( Boolean ) audioFormat . getProperty ( "vbr" ) ) . booleanValue ( ) ; int asSize = audioFormat . getFrameSize ( ) ; int nbOfFramesInBuffer = isVBR ? 1 : Math . max ( 1 , 1024 / asSize ) ; int asDuration = ( int ) ( audioFormat . getSampleRate ( ) / audioFormat . getFrameRate ( ) ) ; long count = 0 ; byte [ ] audioBuffer = new byte [ asSize * nbOfFramesInBuffer ] ; for ( int bytesRead = audioIn . read ( audioBuffer ) ; bytesRead != - 1 ; bytesRead = audioIn . read ( audioBuffer ) ) { if ( bytesRead != 0 ) { int framesRead = bytesRead / asSize ; qtOut . writeSamples ( 0 , framesRead , audioBuffer , 0 , bytesRead , asDuration ) ; count += bytesRead ; p . setProgress ( ( int ) count ) ; } if ( isVBR ) { audioFormat = audioIn . getFormat ( ) ; if ( audioFormat == null ) { break ; } asSize = audioFormat . getFrameSize ( ) ; asDuration = ( int ) ( audioFormat . getSampleRate ( ) / audioFormat . getFrameRate ( ) ) ; if ( audioBuffer . length < asSize ) { audioBuffer = new byte [ asSize ] ; } } } audioIn . close ( ) ; audioIn = null ; if ( streaming . equals ( "fastStart" ) ) { qtOut . toWebOptimizedMovie ( movieFile , false ) ; tmpFile . delete ( ) ; } else if ( streaming . equals ( "fastStartCompressed" ) ) { qtOut . toWebOptimizedMovie ( movieFile , true ) ; tmpFile . delete ( ) ; } qtOut . close ( ) ; qtOut = null ; } catch ( UnsupportedAudioFileException e ) { IOException ioe = new IOException ( e . getMessage ( ) ) ; ioe . initCause ( e ) ; throw ioe ; } finally { p . close ( ) ; if ( audioIn != null ) { audioIn . close ( ) ; } if ( qtOut != null ) { qtOut . close ( ) ; } } } private void writeVideoAndAudio ( File movieFile , File [ ] imgFiles , File audioFile , int width , int height , double fps , QuickTimeWriter . VideoFormat videoFormat , String streaming ) throws IOException { File tmpFile = streaming . equals ( "none" ) ? movieFile : new File ( movieFile . getPath ( ) + ".tmp" ) ; ProgressMonitor p = new ProgressMonitor ( MovieMaker . this , "Creating " + movieFile . getName ( ) , "Creating Output File..." , 0 , imgFiles . length ) ; AudioInputStream audioIn = null ; QuickTimeWriter qtOut = null ; BufferedImage imgBuffer = null ; Graphics2D g = null ; try { if ( audioFile . getName ( ) . toLowerCase ( ) . endsWith ( ".mp3" ) ) { audioIn = new MP3AudioInputStream ( audioFile ) ; } else { audioIn = AudioSystem . getAudioInputStream ( audioFile ) ; } AudioFormat audioFormat = audioIn . getFormat ( ) ; boolean isVBR = audioFormat . getProperty ( "vbr" ) != null && ( ( Boolean ) audioFormat . getProperty ( "vbr" ) ) . booleanValue ( ) ; int asDuration = ( int ) ( audioFormat . getSampleRate ( ) / audioFormat . getFrameRate ( ) ) ; int vsDuration = 100 ; qtOut = new QuickTimeWriter ( videoFormat == QuickTimeWriter . VideoFormat . RAW ? movieFile : tmpFile ) ; qtOut . addAudioTrack ( audioFormat ) ; qtOut . addVideoTrack ( videoFormat , ( int ) ( fps * vsDuration ) , width , height ) ; int asSize ; byte [ ] audioBuffer ; if ( isVBR ) { asSize = audioFormat . getFrameSize ( ) ; audioBuffer = new byte [ asSize ] ; } else { asSize = audioFormat . getChannels ( ) * audioFormat . getSampleSizeInBits ( ) / 8 ; audioBuffer = new byte [ ( int ) ( qtOut . getMediaTimeScale ( 0 ) / 2 * asSize ) ] ; } if ( true ) { imgBuffer = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; g = imgBuffer . createGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_QUALITY ) ; } int movieTime = 0 ; int imgIndex = 0 ; boolean isAudioDone = false ; while ( ( imgIndex < imgFiles . length || ! isAudioDone ) && ! p . isCanceled ( ) ) { movieTime += qtOut . getMovieTimeScale ( ) / 2 ; while ( ! isAudioDone && qtOut . getTrackDuration ( 0 ) < movieTime + qtOut . getMovieTimeScale ( ) ) { int len = audioIn . read ( audioBuffer ) ; if ( len == - 1 ) { isAudioDone = true ; } else { qtOut . writeSamples ( 0 , len / asSize , audioBuffer , 0 , len , asDuration ) ; } if ( isVBR ) { audioFormat = audioIn . getFormat ( ) ; if ( audioFormat == null ) { break ; } asSize = audioFormat . getFrameSize ( ) ; asDuration = ( int ) ( audioFormat . getSampleRate ( ) / audioFormat . getFrameRate ( ) ) ; if ( audioBuffer . length < asSize ) { audioBuffer = new byte [ asSize ] ; } } } while ( imgIndex < imgFiles . length && qtOut . getTrackDuration ( 1 ) < movieTime ) { p . setProgress ( imgIndex ) ; p . setNote ( "Processing " + imgFiles [ imgIndex ] . getName ( ) ) ; if ( false ) { qtOut . writeSample ( 1 , imgFiles [ imgIndex ] , vsDuration ) ; } else { BufferedImage fImg = readImage ( imgFiles [ imgIndex ] ) ; if ( fImg == null ) { continue ; } g . drawImage ( fImg , 0 , 0 , width , height , null ) ; fImg . flush ( ) ; qtOut . writeFrame ( 1 , imgBuffer , vsDuration ) ; } ++ imgIndex ; } } if ( streaming . equals ( "fastStart" ) ) { qtOut . toWebOptimizedMovie ( movieFile , false ) ; tmpFile . delete ( ) ; } else if ( streaming . equals ( "fastStartCompressed" ) ) { qtOut . toWebOptimizedMovie ( movieFile , true ) ; tmpFile . delete ( ) ; } qtOut . close ( ) ; qtOut = null ; } catch ( UnsupportedAudioFileException e ) { IOException ioe = new IOException ( e . getMessage ( ) ) ; ioe . initCause ( e ) ; throw ioe ; } finally { p . close ( ) ; if ( qtOut != null ) { qtOut . close ( ) ; } if ( audioIn != null ) { audioIn . close ( ) ; } if ( g != null ) { g . dispose ( ) ; } if ( imgBuffer != null ) { imgBuffer . flush ( ) ; } } } static private BufferedImage loadImageTGA ( File file ) throws IOException { InputStream is = new FileInputStream ( file ) ; try { byte header [ ] = new byte [ 18 ] ; int offset = 0 ; do { int count = is . read ( header , offset , header . length - offset ) ; if ( count == - 1 ) return null ; offset += count ; } while ( offset < 18 ) ; int format = 0 ; final int RGB = 1 ; final int ARGB = 2 ; final int ALPHA = 4 ; if ( ( ( header [ 2 ] == 3 ) || ( header [ 2 ] == 11 ) ) && ( header [ 16 ] == 8 ) && ( ( header [ 17 ] == 0x8 ) || ( header [ 17 ] == 0x28 ) ) ) { format = ALPHA ; } else if ( ( ( header [ 2 ] == 2 ) || ( header [ 2 ] == 10 ) ) && ( header [ 16 ] == 24 ) && ( ( header [ 17 ] == 0x20 ) || ( header [ 17 ] == 0 ) ) ) { format = RGB ; } else if ( ( ( header [ 2 ] == 2 ) || ( header [ 2 ] == 10 ) ) && ( header [ 16 ] == 32 ) && ( ( header [ 17 ] == 0x8 ) || ( header [ 17 ] == 0x28 ) ) ) { format = ARGB ; } if ( format == 0 ) { throw new IOException ( "Unknown .tga file format for " + file . getName ( ) ) ; } int w = ( ( header [ 13 ] & 0xff ) < < 8 ) + ( header [ 12 ] & 0xff ) ; int h = ( ( header [ 15 ] & 0xff ) < < 8 ) + ( header [ 14 ] & 0xff ) ; int [ ] pixels = new int [ w * h ] ; boolean reversed = ( header [ 17 ] & 0x20 ) == 0 ; if ( ( header [ 2 ] == 2 ) || ( header [ 2 ] == 3 ) ) { if ( reversed ) { int index = ( h - 1 ) * w ; switch ( format ) { case ALPHA : for ( int y = h - 1 ; y >= 0 ; y -- ) { for ( int x = 0 ; x < w ; x ++ ) { pixels [ index + x ] = is . read ( ) ; } index -= w ; } break ; case RGB : for ( int y = h - 1 ; y >= 0 ; y -- ) { for ( int x = 0 ; x < w ; x ++ ) { pixels [ index + x ] = is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) | 0xff000000 ; } index -= w ; } break ; case ARGB : for ( int y = h - 1 ; y >= 0 ; y -- ) { for ( int x = 0 ; x < w ; x ++ ) { pixels [ index + x ] = is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) | ( is . read ( ) < < 24 ) ; } index -= w ; } } } else { int count = w * h ; switch ( format ) { case ALPHA : for ( int i = 0 ; i < count ; i ++ ) { pixels [ i ] = is . read ( ) ; } break ; case RGB : for ( int i = 0 ; i < count ; i ++ ) { pixels [ i ] = is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) | 0xff000000 ; } break ; case ARGB : for ( int i = 0 ; i < count ; i ++ ) { pixels [ i ] = is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) | ( is . read ( ) < < 24 ) ; } break ; } } } else { int index = 0 ; while ( index < pixels . length ) { int num = is . read ( ) ; boolean isRLE = ( num & 0x80 ) != 0 ; if ( isRLE ) { num -= 127 ; int pixel = 0 ; switch ( format ) { case ALPHA : pixel = is . read ( ) ; break ; case RGB : pixel = 0xFF000000 | is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) ; break ; case ARGB : pixel = is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) | ( is . read ( ) < < 24 ) ; break ; } for ( int i = 0 ; i < num ; i ++ ) { pixels [ index ++ ] = pixel ; if ( index == pixels . length ) break ; } } else { num += 1 ; switch ( format ) { case ALPHA : for ( int i = 0 ; i < num ; i ++ ) { pixels [ index ++ ] = is . read ( ) ; } break ; case RGB : for ( int i = 0 ; i < num ; i ++ ) { pixels [ index ++ ] = 0xFF000000 | is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) ; } break ; case ARGB : for ( int i = 0 ; i < num ; i ++ ) { pixels [ index ++ ] = is . read ( ) | ( is . read ( ) < < 8 ) | ( is . read ( ) < < 16 ) | ( is . read ( ) < < 24 ) ; } break ; } } } if ( ! reversed ) { int [ ] temp = new int [ w ] ; for ( int y = 0 ; y < h / 2 ; y ++ ) { int z = ( h - 1 ) - y ; System . arraycopy ( pixels , y * w , temp , 0 , w ) ; System . arraycopy ( pixels , z * w , pixels , y * w , w ) ; System . arraycopy ( temp , 0 , pixels , z * w , w ) ; } } } int type = ( format == RGB ) ? BufferedImage . TYPE_INT_RGB : BufferedImage . TYPE_INT_ARGB ; BufferedImage image = new BufferedImage ( w , h , type ) ; WritableRaster wr = image . getRaster ( ) ; wr . setDataElements ( 0 , 0 , w , h , pixels ) ; return image ; } finally { is . close ( ) ; } } public static void main ( String args [ ] ) { java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { MovieMaker m = new MovieMaker ( ) ; m . init ( null ) ; m . setVisible ( true ) ; } } ) ; } private JLabel aboutLabel ; private JButton chooseImageFolderButton ; private JButton chooseSoundFileButton ; private JComboBox < String > compressionBox ; private JLabel compressionLabel ; private JTextField fpsField ; private JLabel fpsLabel ; private JTextField heightField ; private JLabel heightLabel ; private JTextField imageFolderField ; private JLabel imageFolderHelpLabel ; private JCheckBox originalSizeCheckBox ; private JTextField soundFileField ; private JLabel soundFileHelpLabel ; private JTextField widthField ; private JLabel widthLabel ; private JButton createMovieButton ; }
package processing . core ; public class PStyle implements PConstants { public int imageMode ; public int rectMode ; public int ellipseMode ; public int shapeMode ; public int blendMode ; public int colorMode ; public float colorModeX ; public float colorModeY ; public float colorModeZ ; public float colorModeA ; public boolean tint ; public int tintColor ; public boolean fill ; public int fillColor ; public boolean stroke ; public int strokeColor ; public float strokeWeight ; public int strokeCap ; public int strokeJoin ; public float ambientR , ambientG , ambientB ; public float specularR , specularG , specularB ; public float emissiveR , emissiveG , emissiveB ; public float shininess ; public PFont textFont ; public int textAlign ; public int textAlignY ; public int textMode ; public float textSize ; public float textLeading ; }
package processing . app . tools ; import java . awt . EventQueue ; import java . awt . FileDialog ; import java . awt . Frame ; import java . io . File ; import javax . swing . JFileChooser ; class Chooser { static final boolean useNativeSelect = true ; static abstract class Callback { void handle ( final File file ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { select ( file ) ; } } ) ; } abstract void select ( File file ) ; } static public void selectInput ( Frame parent , String prompt , File file , Callback callback ) { selectImpl ( parent , prompt , file , callback , FileDialog . LOAD ) ; } static public void selectOutput ( Frame parent , String prompt , File file , Callback callback ) { selectImpl ( parent , prompt , file , callback , FileDialog . SAVE ) ; } static protected void selectImpl ( final Frame parentFrame , final String prompt , final File defaultSelection , final Callback callback , final int mode ) { File selectedFile = null ; if ( useNativeSelect ) { FileDialog dialog = new FileDialog ( parentFrame , prompt , mode ) ; if ( defaultSelection != null ) { dialog . setDirectory ( defaultSelection . getParent ( ) ) ; dialog . setFile ( defaultSelection . getName ( ) ) ; } dialog . setVisible ( true ) ; String directory = dialog . getDirectory ( ) ; String filename = dialog . getFile ( ) ; if ( filename != null ) { selectedFile = new File ( directory , filename ) ; } } else { JFileChooser chooser = new JFileChooser ( ) ; chooser . setDialogTitle ( prompt ) ; if ( defaultSelection != null ) { chooser . setSelectedFile ( defaultSelection ) ; } int result = - 1 ; if ( mode == FileDialog . SAVE ) { result = chooser . showSaveDialog ( parentFrame ) ; } else if ( mode == FileDialog . LOAD ) { result = chooser . showOpenDialog ( parentFrame ) ; } if ( result == JFileChooser . APPROVE_OPTION ) { selectedFile = chooser . getSelectedFile ( ) ; } } callback . handle ( selectedFile ) ; } static public void selectFolder ( final Frame parentFrame , final String prompt , final File defaultSelection , final Callback callback ) { File selectedFile = null ; if ( System . getProperty ( "os.name" ) . contains ( "Mac" ) && useNativeSelect ) { FileDialog fileDialog = new FileDialog ( parentFrame , prompt , FileDialog . LOAD ) ; System . setProperty ( "apple.awt.fileDialogForDirectories" , "true" ) ; fileDialog . setVisible ( true ) ; System . setProperty ( "apple.awt.fileDialogForDirectories" , "false" ) ; String filename = fileDialog . getFile ( ) ; if ( filename != null ) { selectedFile = new File ( fileDialog . getDirectory ( ) , fileDialog . getFile ( ) ) ; } } else { JFileChooser fileChooser = new JFileChooser ( ) ; fileChooser . setDialogTitle ( prompt ) ; fileChooser . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; if ( defaultSelection != null ) { fileChooser . setSelectedFile ( defaultSelection ) ; } int result = fileChooser . showOpenDialog ( parentFrame ) ; if ( result == JFileChooser . APPROVE_OPTION ) { selectedFile = fileChooser . getSelectedFile ( ) ; } } callback . handle ( selectedFile ) ; } }
package com . oracle . appbundler ; public class Argument { private String value = null ; public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } @ Override public String toString ( ) { return value ; } }
package com . oracle . appbundler ; import java . io . File ; import org . apache . tools . ant . BuildException ; public class BundleDocument { private String name = "editor" ; private String role = "" ; private File icon = null ; private String [ ] extensions ; private boolean isPackage = false ; static private String capitalizeFirst ( String string ) { char [ ] stringArray = string . toCharArray ( ) ; stringArray [ 0 ] = Character . toUpperCase ( stringArray [ 0 ] ) ; return new String ( stringArray ) ; } public void setExtensions ( String extensionsList ) { if ( extensionsList == null ) { throw new BuildException ( "Extensions can't be null" ) ; } extensions = extensionsList . split ( "," ) ; for ( String extension : extensions ) { extension . trim ( ) . toLowerCase ( ) ; } } public void setIcon ( File icon ) { this . icon = icon ; } public void setName ( String name ) { this . name = name ; } public void setRole ( String role ) { this . role = capitalizeFirst ( role ) ; } public void setIsPackage ( String isPackageString ) { if ( isPackageString . trim ( ) . equalsIgnoreCase ( "true" ) ) { this . isPackage = true ; } else { this . isPackage = false ; } } public String getIconName ( ) { return icon . getName ( ) ; } public File getIconFile ( ) { return icon ; } public String getName ( ) { return name ; } public String getRole ( ) { return role ; } public String [ ] getExtensions ( ) { return extensions ; } public boolean hasIcon ( ) { return icon != null ; } public boolean isPackage ( ) { return isPackage ; } @ Override public String toString ( ) { StringBuilder s = new StringBuilder ( getName ( ) ) ; s . append ( " " ) . append ( getRole ( ) ) . append ( " " ) . append ( getIconName ( ) ) . append ( " " ) ; for ( String extension : extensions ) { s . append ( extension ) . append ( " " ) ; } return s . toString ( ) ; } }
package com . oracle . appbundler ; public class Option { private String value = null ; public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } @ Override public String toString ( ) { return value ; } }
package com . oracle . appbundler ; public class Architecture { private String name = null ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } @ Override public String toString ( ) { return name ; } }
package com . oracle . appbundler ; import java . io . BufferedOutputStream ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Writer ; import java . net . URL ; import java . nio . file . Files ; import java . nio . file . LinkOption ; import java . nio . file . Path ; import java . nio . file . StandardCopyOption ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . zip . ZipEntry ; import java . util . zip . ZipInputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . resources . FileResource ; public class AppBundlerTask extends Task { private File outputDirectory = null ; private String name = null ; private String displayName = null ; private String identifier = null ; private File iconFile = null ; private String executableName = EXECUTABLE_NAME ; private String shortVersion = null ; private String version = null ; private String signature = "????" ; private String copyright = null ; private String getInfo = null ; private String privileged = null ; private String workingDirectory = null ; private String applicationCategory = null ; private boolean highResolutionCapable = true ; private String minimumSystem = "10.8.3" ; private boolean javafx = false ; private String mainClassName = null ; private FileSet runtime = null ; private ArrayList < FileSet > classPath = new ArrayList < > ( ) ; private ArrayList < FileSet > libraryPath = new ArrayList < > ( ) ; private ArrayList < String > options = new ArrayList < > ( ) ; private ArrayList < String > arguments = new ArrayList < > ( ) ; private ArrayList < String > architectures = new ArrayList < > ( ) ; private ArrayList < BundleDocument > bundleDocuments = new ArrayList < > ( ) ; private Reference classPathRef ; private static final String EXECUTABLE_NAME = "JavaAppLauncher" ; private static final String DEFAULT_ICON_NAME = "GenericApp.icns" ; private static final String OS_TYPE_CODE = "APPL" ; private static final int BUFFER_SIZE = 2048 ; public void setOutputDirectory ( File outputDirectory ) { this . outputDirectory = outputDirectory ; } public void setName ( String name ) { this . name = name ; } public void setDisplayName ( String displayName ) { this . displayName = displayName ; } public void setIdentifier ( String identifier ) { this . identifier = identifier ; } public void setIcon ( File icon ) { this . iconFile = icon ; } public void setExecutableName ( String executable ) { this . executableName = executable ; } public void setShortVersion ( String shortVersion ) { this . shortVersion = shortVersion ; } public void setVersion ( String version ) { this . version = version ; } public void setSignature ( String signature ) { this . signature = signature ; } public void setCopyright ( String copyright ) { this . copyright = copyright ; } public void setGetInfo ( String getInfo ) { this . getInfo = getInfo ; } public void setPrivileged ( String privileged ) { this . privileged = privileged ; } public void setWorkingDirectory ( String workingDirectory ) { this . workingDirectory = workingDirectory ; } public void setApplicationCategory ( String applicationCategory ) { this . applicationCategory = applicationCategory ; } public void setMinimumSystem ( String minimumSystem ) { this . minimumSystem = minimumSystem ; } public void setHighResolutionCapable ( boolean highResolutionCapable ) { this . highResolutionCapable = highResolutionCapable ; } public void setJavaFX ( boolean javafx ) { this . javafx = javafx ; } public void setMainClassName ( String mainClassName ) { this . mainClassName = mainClassName ; } public void addConfiguredRuntime ( FileSet runtime ) throws BuildException { if ( this . runtime != null ) { throw new BuildException ( "Runtime already specified." ) ; } this . runtime = runtime ; runtime . appendIncludes ( new String [ ] { "jre/" , } ) ; runtime . appendExcludes ( new String [ ] { "bin/" , "jre/bin/orbd" , "jre/bin/pack200" , "jre/bin/policytool" , "jre/bin/rmid" , "jre/bin/rmiregistry" , "jre/bin/servertool" , "jre/bin/tnameserv" , "jre/bin/unpack200" , "jre/lib/deploy/" , "jre/lib/deploy.jar" , "jre/lib/javaws.jar" , "jre/lib/libdeploy.dylib" , "jre/lib/libnpjp2.dylib" , "jre/lib/plugin.jar" , "jre/lib/security/javaws.policy" } ) ; if ( ! javafx ) { runtime . appendExcludes ( new String [ ] { "jre/THIRDPARTYLICENSEREADME-JAVAFX.txt" , "jre/lib/javafx.properties" , "jre/lib/jfxrt.jar" , "jre/lib/security/javafx.policy" , "jre/lib/fxplugins.dylib" , "jre/lib/libdecora-sse.dylib" , "jre/lib/libglass.dylib" , "jre/lib/libglib-2.0.0.dylib" , "jre/lib/libgstplugins-lite.dylib" , "jre/lib/libgstreamer-lite.dylib" , "jre/lib/libjavafx-font.dylib" , "jre/lib/libjavafx-iio.dylib" , "jre/lib/libjfxmedia.dylib" , "jre/lib/libjfxwebkit.dylib" , "jre/lib/libprism-es2.dylib" } ) ; } } public void setClasspathRef ( Reference ref ) { this . classPathRef = ref ; } public void addConfiguredClassPath ( FileSet classPath ) { this . classPath . add ( classPath ) ; } public void addConfiguredLibraryPath ( FileSet libraryPath ) { this . libraryPath . add ( libraryPath ) ; } public void addConfiguredBundleDocument ( BundleDocument document ) { this . bundleDocuments . add ( document ) ; } public void addConfiguredOption ( Option option ) throws BuildException { String value = option . getValue ( ) ; if ( value == null ) { throw new BuildException ( "Value is required." ) ; } options . add ( value ) ; } public void addConfiguredArgument ( Argument argument ) throws BuildException { String value = argument . getValue ( ) ; if ( value == null ) { throw new BuildException ( "Value is required." ) ; } arguments . add ( value ) ; } public void addConfiguredArch ( Architecture architecture ) throws BuildException { String name = architecture . getName ( ) ; if ( name == null ) { throw new BuildException ( "Name is required." ) ; } architectures . add ( name ) ; } @ Override public void execute ( ) throws BuildException { if ( outputDirectory == null ) { throw new IllegalStateException ( "Output directory is required." ) ; } if ( ! outputDirectory . exists ( ) ) { throw new IllegalStateException ( "Output directory does not exist." ) ; } if ( ! outputDirectory . isDirectory ( ) ) { throw new IllegalStateException ( "Invalid output directory." ) ; } if ( name == null ) { throw new IllegalStateException ( "Name is required." ) ; } if ( displayName == null ) { throw new IllegalStateException ( "Display name is required." ) ; } if ( identifier == null ) { throw new IllegalStateException ( "Identifier is required." ) ; } if ( iconFile != null ) { if ( ! iconFile . exists ( ) ) { throw new IllegalStateException ( "Icon does not exist." ) ; } if ( iconFile . isDirectory ( ) ) { throw new IllegalStateException ( "Invalid icon." ) ; } } if ( shortVersion == null ) { throw new IllegalStateException ( "Short version is required." ) ; } if ( signature == null ) { throw new IllegalStateException ( "Signature is required." ) ; } if ( signature . length ( ) != 4 ) { throw new IllegalStateException ( "Invalid signature." ) ; } if ( copyright == null ) { throw new IllegalStateException ( "Copyright is required." ) ; } if ( mainClassName == null ) { throw new IllegalStateException ( "Main class name is required." ) ; } try { System . out . println ( "Creating app bundle: " + name ) ; File rootDirectory = new File ( outputDirectory , name + ".app" ) ; delete ( rootDirectory ) ; rootDirectory . mkdir ( ) ; File contentsDirectory = new File ( rootDirectory , "Contents" ) ; contentsDirectory . mkdir ( ) ; File macOSDirectory = new File ( contentsDirectory , "MacOS" ) ; macOSDirectory . mkdir ( ) ; File javaDirectory = new File ( contentsDirectory , "Java" ) ; javaDirectory . mkdir ( ) ; File plugInsDirectory = new File ( contentsDirectory , "PlugIns" ) ; plugInsDirectory . mkdir ( ) ; File resourcesDirectory = new File ( contentsDirectory , "Resources" ) ; resourcesDirectory . mkdir ( ) ; File infoPlistFile = new File ( contentsDirectory , "Info.plist" ) ; infoPlistFile . createNewFile ( ) ; writeInfoPlist ( infoPlistFile ) ; File pkgInfoFile = new File ( contentsDirectory , "PkgInfo" ) ; pkgInfoFile . createNewFile ( ) ; writePkgInfo ( pkgInfoFile ) ; File executableFile = new File ( macOSDirectory , executableName ) ; copy ( getClass ( ) . getResource ( EXECUTABLE_NAME ) , executableFile ) ; executableFile . setExecutable ( true , false ) ; copyResources ( resourcesDirectory ) ; copyRuntime ( plugInsDirectory ) ; copyClassPathEntries ( javaDirectory ) ; copyClassPathRefEntries ( javaDirectory ) ; copyLibraryPathEntries ( macOSDirectory ) ; copyIcon ( resourcesDirectory ) ; copyBundleIcons ( resourcesDirectory ) ; } catch ( IOException exception ) { throw new BuildException ( exception ) ; } } private void copyResources ( File resourcesDirectory ) throws IOException { InputStream inputStream = getClass ( ) . getResourceAsStream ( "res.zip" ) ; ZipInputStream zipInputStream = new ZipInputStream ( inputStream ) ; try { ZipEntry zipEntry = zipInputStream . getNextEntry ( ) ; while ( zipEntry != null ) { File file = new File ( resourcesDirectory , zipEntry . getName ( ) ) ; if ( zipEntry . isDirectory ( ) ) { file . mkdir ( ) ; } else { OutputStream outputStream = new BufferedOutputStream ( new FileOutputStream ( file ) , BUFFER_SIZE ) ; try { int b = zipInputStream . read ( ) ; while ( b != - 1 ) { outputStream . write ( b ) ; b = zipInputStream . read ( ) ; } outputStream . flush ( ) ; } finally { outputStream . close ( ) ; } } zipEntry = zipInputStream . getNextEntry ( ) ; } } finally { zipInputStream . close ( ) ; } } private void copyRuntime ( File plugInsDirectory ) throws IOException { if ( runtime != null ) { File runtimeHomeDirectory = runtime . getDir ( ) ; File runtimeContentsDirectory = runtimeHomeDirectory . getParentFile ( ) ; File runtimeDirectory = runtimeContentsDirectory . getParentFile ( ) ; File pluginDirectory = new File ( plugInsDirectory , runtimeDirectory . getName ( ) ) ; pluginDirectory . mkdir ( ) ; File pluginContentsDirectory = new File ( pluginDirectory , runtimeContentsDirectory . getName ( ) ) ; pluginContentsDirectory . mkdir ( ) ; File runtimeMacOSDirectory = new File ( runtimeContentsDirectory , "MacOS" ) ; copy ( runtimeMacOSDirectory , new File ( pluginContentsDirectory , runtimeMacOSDirectory . getName ( ) ) ) ; File runtimeInfoPlistFile = new File ( runtimeContentsDirectory , "Info.plist" ) ; copy ( runtimeInfoPlistFile , new File ( pluginContentsDirectory , runtimeInfoPlistFile . getName ( ) ) ) ; File pluginHomeDirectory = new File ( pluginContentsDirectory , runtimeHomeDirectory . getName ( ) ) ; DirectoryScanner directoryScanner = runtime . getDirectoryScanner ( getProject ( ) ) ; String [ ] includedFiles = directoryScanner . getIncludedFiles ( ) ; for ( String includedFile : includedFiles ) { File source = new File ( runtimeHomeDirectory , includedFile ) ; File destination = new File ( pluginHomeDirectory , includedFile ) ; copy ( source , destination ) ; } } } private void copyClassPathRefEntries ( File javaDirectory ) throws IOException { if ( classPathRef != null ) { org . apache . tools . ant . types . Path classpath = ( org . apache . tools . ant . types . Path ) classPathRef . getReferencedObject ( getProject ( ) ) ; Iterator < ? > iter = classpath . iterator ( ) ; while ( iter . hasNext ( ) ) { FileResource resource = ( FileResource ) iter . next ( ) ; File source = resource . getFile ( ) ; File destination = new File ( javaDirectory , source . getName ( ) ) ; copy ( source , destination ) ; } } } private void copyClassPathEntries ( File javaDirectory ) throws IOException { for ( FileSet fileSet : classPath ) { File classPathDirectory = fileSet . getDir ( ) ; DirectoryScanner directoryScanner = fileSet . getDirectoryScanner ( getProject ( ) ) ; String [ ] includedFiles = directoryScanner . getIncludedFiles ( ) ; for ( String includedFile : includedFiles ) { File source = new File ( classPathDirectory , includedFile ) ; File destination = new File ( javaDirectory , new File ( includedFile ) . getName ( ) ) ; copy ( source , destination ) ; } } } private void copyLibraryPathEntries ( File macOSDirectory ) throws IOException { for ( FileSet fileSet : libraryPath ) { File libraryPathDirectory = fileSet . getDir ( ) ; DirectoryScanner directoryScanner = fileSet . getDirectoryScanner ( getProject ( ) ) ; String [ ] includedFiles = directoryScanner . getIncludedFiles ( ) ; for ( String includedFile : includedFiles ) { File source = new File ( libraryPathDirectory , includedFile ) ; File destination = new File ( macOSDirectory , new File ( includedFile ) . getName ( ) ) ; copy ( source , destination ) ; } } } private void copyIcon ( File resourcesDirectory ) throws IOException { if ( iconFile == null ) { copy ( getClass ( ) . getResource ( DEFAULT_ICON_NAME ) , new File ( resourcesDirectory , DEFAULT_ICON_NAME ) ) ; } else { copy ( iconFile , new File ( resourcesDirectory , iconFile . getName ( ) ) ) ; } } private void copyBundleIcons ( File resourcesDirectory ) throws IOException { for ( BundleDocument bundleDocument : bundleDocuments ) { if ( bundleDocument . hasIcon ( ) ) { File iconFile = bundleDocument . getIconFile ( ) ; copy ( iconFile , new File ( resourcesDirectory , iconFile . getName ( ) ) ) ; } } } private void writeInfoPlist ( File file ) throws IOException { FileOutputStream output = new FileOutputStream ( file ) ; PropertyLister plist = new PropertyLister ( output ) ; plist . writeStartDocument ( ) ; plist . writeStartDictElement ( ) ; plist . writeProperty ( "CFBundleDevelopmentRegion" , "English" ) ; plist . writeProperty ( "CFBundleExecutable" , executableName ) ; plist . writeProperty ( "CFBundleIconFile" , ( iconFile == null ) ? DEFAULT_ICON_NAME : iconFile . getName ( ) ) ; plist . writeProperty ( "CFBundleIdentifier" , identifier ) ; plist . writeProperty ( "CFBundleDisplayName" , displayName ) ; plist . writeProperty ( "CFBundleInfoDictionaryVersion" , "6.0" ) ; plist . writeProperty ( "CFBundleName" , name ) ; plist . writeProperty ( "CFBundlePackageType" , OS_TYPE_CODE ) ; plist . writeProperty ( "CFBundleShortVersionString" , shortVersion ) ; plist . writeProperty ( "CFBundleVersion" , version ) ; plist . writeProperty ( "CFBundleSignature" , signature ) ; plist . writeProperty ( "NSHumanReadableCopyright" , copyright ) ; if ( getInfo != null ) { plist . writeProperty ( "CFBundleGetInfoString" , getInfo ) ; } if ( applicationCategory != null ) { plist . writeProperty ( "LSApplicationCategoryType" , applicationCategory ) ; } if ( minimumSystem != null ) { plist . writeProperty ( "LSMinimumSystemVersion" , minimumSystem ) ; } if ( highResolutionCapable ) { plist . writeKey ( "NSHighResolutionCapable" ) ; plist . writeBoolean ( true ) ; } if ( runtime != null ) { plist . writeProperty ( "JVMRuntime" , runtime . getDir ( ) . getParentFile ( ) . getParentFile ( ) . getName ( ) ) ; } if ( privileged != null ) { plist . writeProperty ( "JVMRunPrivileged" , privileged ) ; } if ( workingDirectory != null ) { plist . writeProperty ( "WorkingDirectory" , workingDirectory ) ; } plist . writeProperty ( "JVMMainClassName" , mainClassName ) ; plist . writeKey ( "CFBundleDocumentTypes" ) ; plist . writeStartArrayElement ( ) ; for ( BundleDocument bundleDocument : bundleDocuments ) { plist . writeStartDictElement ( ) ; plist . writeKey ( "CFBundleTypeExtensions" ) ; plist . writeStartArrayElement ( ) ; for ( String extension : bundleDocument . getExtensions ( ) ) { plist . writeString ( extension ) ; } plist . writeEndElement ( ) ; if ( bundleDocument . hasIcon ( ) ) { plist . writeKey ( "CFBundleTypeIconFile" ) ; plist . writeString ( bundleDocument . getIconName ( ) ) ; } plist . writeKey ( "CFBundleTypeName" ) ; plist . writeString ( bundleDocument . getName ( ) ) ; plist . writeKey ( "CFBundleTypeRole" ) ; plist . writeString ( bundleDocument . getRole ( ) ) ; plist . writeKey ( "LSTypeIsPackage" ) ; plist . writeBoolean ( bundleDocument . isPackage ( ) ) ; plist . writeEndElement ( ) ; } plist . writeEndElement ( ) ; plist . writeKey ( "LSArchitecturePriority" ) ; plist . writeStartArrayElement ( ) ; for ( String architecture : architectures ) { plist . writeString ( architecture ) ; } plist . writeEndElement ( ) ; plist . writeKey ( "LSEnvironment" ) ; plist . writeStartDictElement ( ) ; plist . writeKey ( "LC_CTYPE" ) ; plist . writeString ( "UTF-8" ) ; plist . writeEndElement ( ) ; plist . writeKey ( "JVMOptions" ) ; plist . writeStartArrayElement ( ) ; for ( String option : options ) { plist . writeString ( option ) ; } plist . writeEndElement ( ) ; plist . writeKey ( "JVMArguments" ) ; plist . writeStartArrayElement ( ) ; for ( String argument : arguments ) { plist . writeString ( argument ) ; } plist . writeEndElement ( ) ; plist . writeEndElement ( ) ; plist . writeEndDocument ( ) ; } private void writePkgInfo ( File file ) throws IOException { Writer out = new BufferedWriter ( new FileWriter ( file ) ) ; try { out . write ( OS_TYPE_CODE + signature ) ; out . flush ( ) ; } finally { out . close ( ) ; } } private static void delete ( File file ) throws IOException { Path filePath = file . toPath ( ) ; if ( Files . exists ( filePath , LinkOption . NOFOLLOW_LINKS ) ) { if ( Files . isDirectory ( filePath , LinkOption . NOFOLLOW_LINKS ) ) { File [ ] files = file . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { delete ( files [ i ] ) ; } } Files . delete ( filePath ) ; } } private static void copy ( URL location , File file ) throws IOException { try ( InputStream in = location . openStream ( ) ) { Files . copy ( in , file . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; } } private static void copy ( File source , File destination ) throws IOException { Path sourcePath = source . toPath ( ) ; Path destinationPath = destination . toPath ( ) ; destination . getParentFile ( ) . mkdirs ( ) ; Files . copy ( sourcePath , destinationPath , StandardCopyOption . REPLACE_EXISTING , LinkOption . NOFOLLOW_LINKS ) ; if ( Files . isDirectory ( sourcePath , LinkOption . NOFOLLOW_LINKS ) ) { String [ ] files = source . list ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { String file = files [ i ] ; copy ( new File ( source , file ) , new File ( destination , file ) ) ; } } } }
package com . oracle . appbundler ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Stack ; class PropertyLister { static private final String XML_HEADER = "<?xml version=\"1.0\" ?>" ; static private final String PLIST_DTD = "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">" ; static private final String PLIST_TAG = "plist" ; static private final String PLIST_VERSION_ATTRIBUTE = "version" ; static private final String DICT_TAG = "dict" ; static private final String KEY_TAG = "key" ; static private final String ARRAY_TAG = "array" ; static private final String STRING_TAG = "string" ; PrintWriter writer ; String indentSpaces = " " ; Stack < String > elements = new Stack < > ( ) ; public PropertyLister ( OutputStream output ) throws UnsupportedEncodingException { OutputStreamWriter osw = new OutputStreamWriter ( output , "UTF-8" ) ; writer = new PrintWriter ( osw ) ; } void writeStartDocument ( ) { writer . println ( XML_HEADER ) ; writer . println ( PLIST_DTD ) ; writeStartElement ( PLIST_TAG , PLIST_VERSION_ATTRIBUTE , "1.0" ) ; } void writeEndDocument ( ) { writeEndElement ( ) ; writer . flush ( ) ; writer . close ( ) ; } void writeStartElement ( String element , String ... args ) { emitIndent ( ) ; writer . print ( "<" + element ) ; for ( int i = 0 ; i < args . length ; i += 2 ) { String attr = args [ i ] ; String value = args [ i + 1 ] ; writer . print ( " " + attr + "=\"" + value + "\"" ) ; } writer . println ( ">" ) ; elements . push ( element ) ; } void writeStartElement ( String element ) { emitIndent ( ) ; writer . println ( "<" + element + ">" ) ; elements . push ( element ) ; } void writeStartDictElement ( ) { writeStartElement ( DICT_TAG ) ; } void writeStartArrayElement ( ) { writeStartElement ( ARRAY_TAG ) ; } void writeEndElement ( ) { emitOutdent ( ) ; writer . println ( "</" + elements . pop ( ) + ">" ) ; } void writeKey ( String key ) { emitSingle ( KEY_TAG , key ) ; } void writeString ( String value ) { emitSingle ( STRING_TAG , value ) ; } void writeBoolean ( boolean value ) { emitIndent ( ) ; writer . println ( "<" + ( value ? "true" : "false" ) + "/>" ) ; } void writeProperty ( String property , String value ) { writeKey ( property ) ; writeString ( value ) ; } private void emitSingle ( String tag , String content ) { emitIndent ( ) ; writer . println ( "<" + tag + ">" + content + "</" + tag + ">" ) ; } private void emitIndent ( ) { for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { writer . print ( indentSpaces ) ; } } private void emitOutdent ( ) { for ( int i = 0 ; i < elements . size ( ) - 1 ; i ++ ) { writer . print ( indentSpaces ) ; } } }
import java . io . * ; import java . net . * ; import java . util . * ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Downloader extends Task { static final String COOKIE = "gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; " + "oraclelicense=accept-securebackup-cookie" ; private int version ; private int update ; private int build ; private boolean jdk ; private String flavor ; private String path ; public Downloader ( ) { } public void setVersion ( int version ) { this . version = version ; } public void setUpdate ( int update ) { this . update = update ; } public void setBuild ( int build ) { this . build = build ; } public void setJDK ( boolean jdk ) { this . jdk = jdk ; } public void setFlavor ( String flavor ) { this . flavor = flavor ; } public void setPath ( String path ) { this . path = path ; } public void execute ( ) throws BuildException { if ( version == 0 ) { throw new BuildException ( "version (i.e. 7 or 8) must be set" ) ; } if ( build == 0 ) { throw new BuildException ( "build number must be set" ) ; } if ( flavor == null ) { throw new BuildException ( "you've gotta choose a flavor (macosx-x64.dmg, windows-x64.exe..." ) ; } try { download ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } void download ( ) throws IOException { String filename = ( jdk ? "jdk" : "jre" ) + ( update == 0 ? String . format ( "-%d-%s" , version , flavor ) : String . format ( "-%du%d-%s" , version , update , flavor ) ) ; if ( path == null ) { path = filename ; } String url = "https://edelivery.oracle.com/otn-pub/java/jdk/" + ( update == 0 ? String . format ( "%d-b%02d/" , version , build ) : String . format ( "%du%d-b%02d/" , version , update , build ) ) + filename ; HttpURLConnection conn = ( HttpURLConnection ) new URL ( url ) . openConnection ( ) ; conn . setRequestProperty ( "Cookie" , COOKIE ) ; if ( conn . getResponseCode ( ) == 302 ) { Map < String , List < String > > headers = conn . getHeaderFields ( ) ; List < String > location = headers . get ( "Location" ) ; if ( location . size ( ) == 1 ) { url = location . get ( 0 ) ; } else { throw new BuildException ( "Got " + location . size ( ) + " locations." ) ; } List < String > cookies = headers . get ( "Set-Cookie" ) ; conn = ( HttpURLConnection ) new URL ( url ) . openConnection ( ) ; for ( String cookie : cookies ) { conn . setRequestProperty ( "Cookie" , cookie ) ; } conn . setRequestProperty ( "Cookie" , COOKIE ) ; conn . connect ( ) ; } if ( conn . getResponseCode ( ) == 200 ) { InputStream input = conn . getInputStream ( ) ; BufferedInputStream bis = new BufferedInputStream ( input ) ; File outputFile = new File ( path ) ; System . out . format ( "Downloading %s from %s%n" , outputFile . getAbsolutePath ( ) , url ) ; File tempFile = File . createTempFile ( "download" , "" , outputFile . getParentFile ( ) ) ; BufferedOutputStream output = new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ; int c = bis . read ( ) ; while ( c != - 1 ) { output . write ( c ) ; c = bis . read ( ) ; } bis . close ( ) ; output . flush ( ) ; output . close ( ) ; if ( outputFile . exists ( ) ) { if ( ! outputFile . delete ( ) ) { throw new BuildException ( "Could not delete old download: " + outputFile . getAbsolutePath ( ) ) ; } } if ( ! tempFile . renameTo ( outputFile ) ) { throw new BuildException ( String . format ( "Could not rename %s to %s" , tempFile . getAbsolutePath ( ) , outputFile . getAbsolutePath ( ) ) ) ; } } else { printHeaders ( conn ) ; System . exit ( 1 ) ; } } static void printHeaders ( URLConnection conn ) { Map < String , List < String > > headers = conn . getHeaderFields ( ) ; Set < Map . Entry < String , List < String > > > entrySet = headers . entrySet ( ) ; for ( Map . Entry < String , List < String > > entry : entrySet ) { String headerName = entry . getKey ( ) ; System . out . println ( "Header Name:" + headerName ) ; List < String > headerValues = entry . getValue ( ) ; for ( String value : headerValues ) { System . out . print ( "Header value:" + value ) ; } System . out . println ( ) ; System . out . println ( ) ; } } }
package processing . core ; import java . nio . IntBuffer ; import javafx . scene . SnapshotParameters ; import javafx . scene . canvas . GraphicsContext ; import javafx . scene . effect . BlendMode ; import javafx . scene . image . PixelFormat ; import javafx . scene . image . PixelReader ; import javafx . scene . image . PixelWriter ; import javafx . scene . image . WritableImage ; import javafx . scene . image . WritablePixelFormat ; import javafx . scene . paint . Color ; import javafx . scene . paint . Paint ; import javafx . scene . shape . ArcType ; import javafx . scene . shape . ClosePath ; import javafx . scene . shape . Path ; import javafx . scene . shape . StrokeLineCap ; import javafx . scene . shape . StrokeLineJoin ; import javafx . scene . transform . Affine ; import javafx . scene . transform . Transform ; public class PGraphicsFX2D extends PGraphics { GraphicsContext context ; static final WritablePixelFormat < IntBuffer > argbFormat = PixelFormat . getIntArgbInstance ( ) ; Path workPath ; Path auxPath ; boolean openContour ; boolean breakShape ; float [ ] curveCoordX ; float [ ] curveCoordY ; float [ ] curveDrawX ; float [ ] curveDrawY ; int transformCount ; Affine transformStack [ ] = new Affine [ MATRIX_STACK_DEPTH ] ; public PGraphicsFX2D ( ) { } @ Override public PSurface createSurface ( ) { return surface = new PSurfaceFX ( this ) ; } @ Override public boolean canDraw ( ) { return true ; } @ Override public void beginDraw ( ) { checkSettings ( ) ; resetMatrix ( ) ; vertexCount = 0 ; } @ Override public void endDraw ( ) { if ( ! primaryGraphics ) { loadPixels ( ) ; } setModified ( ) ; } @ Override public void beginShape ( int kind ) { shape = kind ; vertexCount = 0 ; curveVertexCount = 0 ; workPath = null ; auxPath = null ; } @ Override public void texture ( PImage image ) { showMethodWarning ( "texture" ) ; } @ Override public void vertex ( float x , float y ) { curveVertexCount = 0 ; if ( vertexCount == vertices . length ) { float temp [ ] [ ] = new float [ vertexCount < < 1 ] [ VERTEX_FIELD_COUNT ] ; System . arraycopy ( vertices , 0 , temp , 0 , vertexCount ) ; vertices = temp ; } vertices [ vertexCount ] [ X ] = x ; vertices [ vertexCount ] [ Y ] = y ; vertexCount ++ ; switch ( shape ) { case POINTS : point ( x , y ) ; break ; case LINES : if ( ( vertexCount % 2 ) == 0 ) { line ( vertices [ vertexCount - 2 ] [ X ] , vertices [ vertexCount - 2 ] [ Y ] , x , y ) ; } break ; case TRIANGLES : if ( ( vertexCount % 3 ) == 0 ) { triangle ( vertices [ vertexCount - 3 ] [ X ] , vertices [ vertexCount - 3 ] [ Y ] , vertices [ vertexCount - 2 ] [ X ] , vertices [ vertexCount - 2 ] [ Y ] , x , y ) ; } break ; case TRIANGLE_STRIP : if ( vertexCount >= 3 ) { triangle ( vertices [ vertexCount - 2 ] [ X ] , vertices [ vertexCount - 2 ] [ Y ] , vertices [ vertexCount - 1 ] [ X ] , vertices [ vertexCount - 1 ] [ Y ] , vertices [ vertexCount - 3 ] [ X ] , vertices [ vertexCount - 3 ] [ Y ] ) ; } break ; case TRIANGLE_FAN : if ( vertexCount >= 3 ) { triangle ( vertices [ 0 ] [ X ] , vertices [ 0 ] [ Y ] , vertices [ vertexCount - 2 ] [ X ] , vertices [ vertexCount - 2 ] [ Y ] , x , y ) ; } break ; case QUAD : case QUADS : if ( ( vertexCount % 4 ) == 0 ) { quad ( vertices [ vertexCount - 4 ] [ X ] , vertices [ vertexCount - 4 ] [ Y ] , vertices [ vertexCount - 3 ] [ X ] , vertices [ vertexCount - 3 ] [ Y ] , vertices [ vertexCount - 2 ] [ X ] , vertices [ vertexCount - 2 ] [ Y ] , x , y ) ; } break ; case QUAD_STRIP : if ( ( vertexCount >= 4 ) && ( ( vertexCount % 2 ) == 0 ) ) { quad ( vertices [ vertexCount - 4 ] [ X ] , vertices [ vertexCount - 4 ] [ Y ] , vertices [ vertexCount - 2 ] [ X ] , vertices [ vertexCount - 2 ] [ Y ] , x , y , vertices [ vertexCount - 3 ] [ X ] , vertices [ vertexCount - 3 ] [ Y ] ) ; } break ; case POLYGON : if ( workPath == null ) { context . moveTo ( x , y ) ; } else if ( breakShape ) { context . moveTo ( x , y ) ; breakShape = false ; } else { context . lineTo ( x , y ) ; } break ; } } @ Override public void vertex ( float x , float y , float z ) { showDepthWarningXYZ ( "vertex" ) ; } @ Override public void vertex ( float [ ] v ) { vertex ( v [ X ] , v [ Y ] ) ; } @ Override public void vertex ( float x , float y , float u , float v ) { showVariationWarning ( "vertex(x, y, u, v)" ) ; } @ Override public void vertex ( float x , float y , float z , float u , float v ) { showDepthWarningXYZ ( "vertex" ) ; } @ Override public void beginContour ( ) { if ( openContour ) { PGraphics . showWarning ( "Already called beginContour()" ) ; return ; } Path temp = auxPath ; auxPath = workPath ; workPath = temp ; breakShape = true ; auxPath = new Path ( ) ; breakShape = true ; openContour = true ; } @ Override public void endContour ( ) { if ( ! openContour ) { PGraphics . showWarning ( "Need to call beginContour() first" ) ; return ; } if ( workPath != null ) { auxPath . getElements ( ) . addAll ( workPath . getElements ( ) ) ; auxPath . getElements ( ) . add ( new ClosePath ( ) ) ; } Path temp = workPath ; workPath = auxPath ; auxPath = temp ; openContour = false ; } @ Override public void endShape ( int mode ) { if ( openContour ) { endContour ( ) ; PGraphics . showWarning ( "Missing endContour() before endShape()" ) ; } if ( workPath != null ) { if ( shape == POLYGON ) { if ( mode == CLOSE ) { workPath . getElements ( ) . add ( new ClosePath ( ) ) ; } if ( auxPath != null ) { workPath . getElements ( ) . addAll ( auxPath . getElements ( ) ) ; } } } shape = 0 ; } @ Override protected void clipImpl ( float x1 , float y1 , float x2 , float y2 ) { showTodoWarning ( "clip()" , 3274 ) ; } @ Override public void noClip ( ) { showTodoWarning ( "noClip()" , 3274 ) ; } @ Override protected void blendModeImpl ( ) { BlendMode mode = BlendMode . SRC_OVER ; switch ( blendMode ) { case REPLACE : showWarning ( "blendMode(REPLACE) is not supported" ) ; break ; case BLEND : break ; case ADD : mode = BlendMode . ADD ; break ; case SUBTRACT : showWarning ( "blendMode(SUBTRACT) is not supported" ) ; break ; case LIGHTEST : mode = BlendMode . LIGHTEN ; break ; case DARKEST : mode = BlendMode . DARKEN ; break ; case DIFFERENCE : mode = BlendMode . DIFFERENCE ; break ; case EXCLUSION : mode = BlendMode . EXCLUSION ; break ; case MULTIPLY : mode = BlendMode . MULTIPLY ; break ; case SCREEN : mode = BlendMode . SCREEN ; break ; case OVERLAY : mode = BlendMode . OVERLAY ; break ; case HARD_LIGHT : mode = BlendMode . HARD_LIGHT ; break ; case SOFT_LIGHT : mode = BlendMode . SOFT_LIGHT ; break ; case DODGE : mode = BlendMode . COLOR_DODGE ; break ; case BURN : mode = BlendMode . COLOR_BURN ; break ; } context . setGlobalBlendMode ( mode ) ; } @ Override public void bezierVertex ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { bezierVertexCheck ( ) ; context . bezierCurveTo ( x1 , y1 , x2 , y2 , x3 , y3 ) ; } @ Override public void bezierVertex ( float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { showDepthWarningXYZ ( "bezierVertex" ) ; } @ Override public void quadraticVertex ( float ctrlX , float ctrlY , float endX , float endY ) { context . quadraticCurveTo ( ctrlX , ctrlY , endX , endY ) ; } @ Override public void quadraticVertex ( float x2 , float y2 , float z2 , float x4 , float y4 , float z4 ) { showDepthWarningXYZ ( "quadVertex" ) ; } @ Override protected void curveVertexCheck ( ) { super . curveVertexCheck ( ) ; if ( curveCoordX == null ) { curveCoordX = new float [ 4 ] ; curveCoordY = new float [ 4 ] ; curveDrawX = new float [ 4 ] ; curveDrawY = new float [ 4 ] ; } } @ Override protected void curveVertexSegment ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { curveCoordX [ 0 ] = x1 ; curveCoordY [ 0 ] = y1 ; curveCoordX [ 1 ] = x2 ; curveCoordY [ 1 ] = y2 ; curveCoordX [ 2 ] = x3 ; curveCoordY [ 2 ] = y3 ; curveCoordX [ 3 ] = x4 ; curveCoordY [ 3 ] = y4 ; curveToBezierMatrix . mult ( curveCoordX , curveDrawX ) ; curveToBezierMatrix . mult ( curveCoordY , curveDrawY ) ; if ( workPath == null ) { context . moveTo ( curveDrawX [ 0 ] , curveDrawY [ 0 ] ) ; } context . bezierCurveTo ( curveDrawX [ 1 ] , curveDrawY [ 1 ] , curveDrawX [ 2 ] , curveDrawY [ 2 ] , curveDrawX [ 3 ] , curveDrawY [ 3 ] ) ; } @ Override public void curveVertex ( float x , float y , float z ) { showDepthWarningXYZ ( "curveVertex" ) ; } @ Override public void point ( float x , float y ) { if ( stroke ) { line ( x , y , x + EPSILON , y + EPSILON ) ; } } @ Override public void line ( float x1 , float y1 , float x2 , float y2 ) { context . strokeLine ( x1 , y1 , x2 , y2 ) ; } @ Override public void triangle ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { context . beginPath ( ) ; context . moveTo ( x1 , y1 ) ; context . lineTo ( x2 , y2 ) ; context . lineTo ( x3 , y3 ) ; context . closePath ( ) ; if ( fill ) context . fill ( ) ; if ( stroke ) context . stroke ( ) ; } @ Override public void quad ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { context . beginPath ( ) ; context . moveTo ( x1 , y1 ) ; context . lineTo ( x2 , y2 ) ; context . lineTo ( x3 , y3 ) ; context . lineTo ( x4 , y4 ) ; context . closePath ( ) ; if ( fill ) context . fill ( ) ; if ( stroke ) context . stroke ( ) ; } @ Override protected void rectImpl ( float x1 , float y1 , float x2 , float y2 ) { if ( fill ) context . fillRect ( x1 , y1 , x2 , y2 ) ; if ( stroke ) context . strokeRect ( x1 , y1 , x2 , y2 ) ; } @ Override protected void ellipseImpl ( float x , float y , float w , float h ) { if ( fill ) context . fillOval ( x , y , w , h ) ; if ( stroke ) context . strokeOval ( x , y , w , h ) ; } @ Override protected void arcImpl ( float x , float y , float w , float h , float start , float stop , int mode ) { start = - start * RAD_TO_DEG ; stop = - stop * RAD_TO_DEG ; float sweep = stop - start ; ArcType fillMode = ArcType . ROUND ; ArcType strokeMode = ArcType . OPEN ; if ( mode == OPEN ) { fillMode = ArcType . OPEN ; } else if ( mode == PIE ) { strokeMode = ArcType . ROUND ; } else if ( mode == CHORD ) { fillMode = ArcType . CHORD ; strokeMode = ArcType . CHORD ; } if ( fill ) { context . fillArc ( x , y , w , h , PApplet . degrees ( start ) , PApplet . degrees ( sweep ) , fillMode ) ; } if ( stroke ) { context . strokeArc ( x , y , w , h , PApplet . degrees ( start ) , PApplet . degrees ( sweep ) , strokeMode ) ; } } @ Override public void box ( float w , float h , float d ) { showMethodWarning ( "box" ) ; } @ Override public void sphere ( float r ) { showMethodWarning ( "sphere" ) ; } @ Override public void bezierDetail ( int detail ) { } @ Override public void curveDetail ( int detail ) { } @ Override protected void imageImpl ( PImage who , float x1 , float y1 , float x2 , float y2 , int u1 , int v1 , int u2 , int v2 ) { if ( who . width <= 0 || who . height <= 0 ) return ; ImageCache cash = ( ImageCache ) getCache ( who ) ; if ( cash != null ) { if ( who . width != cash . image . getWidth ( ) || who . height != cash . image . getHeight ( ) ) { cash = null ; } } if ( cash == null ) { cash = new ImageCache ( ) ; setCache ( who , cash ) ; who . updatePixels ( ) ; who . modified = true ; } if ( ( tint && ! cash . tinted ) || ( tint && ( cash . tintedColor != tintColor ) ) || ( ! tint && cash . tinted ) ) { who . updatePixels ( ) ; } if ( who . modified ) { if ( who . pixels == null ) { who . pixels = new int [ who . width * who . height ] ; } cash . update ( who , tint , tintColor ) ; who . modified = false ; } context . drawImage ( ( ( ImageCache ) getCache ( who ) ) . image , u1 , v1 , u2 - u1 , v2 - v1 , x1 , y1 , x2 - x1 , y2 - y1 ) ; } static class ImageCache { boolean tinted ; int tintedColor ; int [ ] tintedTemp ; WritableImage image ; public void update ( PImage source , boolean tint , int tintColor ) { int targetType = ARGB ; boolean opaque = ( tintColor & 0xFF000000 ) == 0xFF000000 ; if ( source . format == RGB ) { if ( ! tint || ( tint && opaque ) ) { targetType = RGB ; } } if ( image == null ) { image = new WritableImage ( source . width , source . height ) ; } PixelWriter pw = image . getPixelWriter ( ) ; if ( tint ) { if ( tintedTemp == null || tintedTemp . length != source . width ) { tintedTemp = new int [ source . width ] ; } int a2 = ( tintColor > > 24 ) & 0xff ; int r2 = ( tintColor > > 16 ) & 0xff ; int g2 = ( tintColor > > 8 ) & 0xff ; int b2 = ( tintColor ) & 0xff ; if ( targetType == RGB ) { int index = 0 ; for ( int y = 0 ; y < source . height ; y ++ ) { for ( int x = 0 ; x < source . width ; x ++ ) { int argb1 = source . pixels [ index ++ ] ; int r1 = ( argb1 > > 16 ) & 0xff ; int g1 = ( argb1 > > 8 ) & 0xff ; int b1 = ( argb1 ) & 0xff ; tintedTemp [ x ] = 0xFF000000 | ( ( ( r2 * r1 ) & 0xff00 ) < < 8 ) | ( ( g2 * g1 ) & 0xff00 ) | ( ( ( b2 * b1 ) & 0xff00 ) > > 8 ) ; } pw . setPixels ( 0 , y , source . width , 1 , argbFormat , tintedTemp , 0 , source . width ) ; } } else if ( targetType == ARGB ) { if ( source . format == RGB && ( tintColor & 0xffffff ) == 0xffffff ) { int hi = tintColor & 0xff000000 ; int index = 0 ; for ( int y = 0 ; y < source . height ; y ++ ) { for ( int x = 0 ; x < source . width ; x ++ ) { tintedTemp [ x ] = hi | ( source . pixels [ index ++ ] & 0xFFFFFF ) ; } pw . setPixels ( 0 , y , source . width , 1 , argbFormat , tintedTemp , 0 , source . width ) ; } } else { int index = 0 ; for ( int y = 0 ; y < source . height ; y ++ ) { if ( source . format == RGB ) { int alpha = tintColor & 0xFF000000 ; for ( int x = 0 ; x < source . width ; x ++ ) { int argb1 = source . pixels [ index ++ ] ; int r1 = ( argb1 > > 16 ) & 0xff ; int g1 = ( argb1 > > 8 ) & 0xff ; int b1 = ( argb1 ) & 0xff ; tintedTemp [ x ] = alpha | ( ( ( r2 * r1 ) & 0xff00 ) < < 8 ) | ( ( g2 * g1 ) & 0xff00 ) | ( ( ( b2 * b1 ) & 0xff00 ) > > 8 ) ; } } else if ( source . format == ARGB ) { for ( int x = 0 ; x < source . width ; x ++ ) { int argb1 = source . pixels [ index ++ ] ; int a1 = ( argb1 > > 24 ) & 0xff ; int r1 = ( argb1 > > 16 ) & 0xff ; int g1 = ( argb1 > > 8 ) & 0xff ; int b1 = ( argb1 ) & 0xff ; tintedTemp [ x ] = ( ( ( a2 * a1 ) & 0xff00 ) < < 16 ) | ( ( ( r2 * r1 ) & 0xff00 ) < < 8 ) | ( ( g2 * g1 ) & 0xff00 ) | ( ( ( b2 * b1 ) & 0xff00 ) > > 8 ) ; } } else if ( source . format == ALPHA ) { int lower = tintColor & 0xFFFFFF ; for ( int x = 0 ; x < source . width ; x ++ ) { int a1 = source . pixels [ index ++ ] ; tintedTemp [ x ] = ( ( ( a2 * a1 ) & 0xff00 ) < < 16 ) | lower ; } } pw . setPixels ( 0 , y , source . width , 1 , argbFormat , tintedTemp , 0 , source . width ) ; } } } } else { if ( targetType == RGB && ( source . pixels [ 0 ] > > 24 == 0 ) ) { source . filter ( OPAQUE ) ; } pw . setPixels ( 0 , 0 , source . width , source . height , argbFormat , source . pixels , 0 , source . width ) ; } this . tinted = tint ; this . tintedColor = tintColor ; } } @ Override public PShape loadShape ( String filename ) { return loadShape ( filename , null ) ; } @ Override public PShape loadShape ( String filename , String options ) { String extension = PApplet . getExtension ( filename ) ; if ( extension . equals ( "svg" ) || extension . equals ( "svgz" ) ) { return new PShapeSVG ( parent . loadXML ( filename ) ) ; } PGraphics . showWarning ( "Unsupported format: " + filename ) ; return null ; } @ Override public void pushMatrix ( ) { if ( transformCount == transformStack . length ) { throw new RuntimeException ( "pushMatrix() cannot use push more than " + transformStack . length + " times" ) ; } context . getTransform ( transformStack [ transformCount ] ) ; transformCount ++ ; } @ Override public void popMatrix ( ) { if ( transformCount == 0 ) { throw new RuntimeException ( "missing a pushMatrix() " + "to go with that popMatrix()" ) ; } transformCount -- ; context . setTransform ( transformStack [ transformCount ] ) ; } @ Override public void translate ( float tx , float ty ) { context . translate ( tx , ty ) ; } @ Override public void rotate ( float angle ) { context . rotate ( PApplet . radians ( angle ) ) ; } @ Override public void rotateX ( float angle ) { showDepthWarning ( "rotateX" ) ; } @ Override public void rotateY ( float angle ) { showDepthWarning ( "rotateY" ) ; } @ Override public void rotateZ ( float angle ) { showDepthWarning ( "rotateZ" ) ; } @ Override public void rotate ( float angle , float vx , float vy , float vz ) { showVariationWarning ( "rotate" ) ; } @ Override public void scale ( float s ) { context . scale ( s , s ) ; } @ Override public void scale ( float sx , float sy ) { context . scale ( sx , sy ) ; } @ Override public void scale ( float sx , float sy , float sz ) { showDepthWarningXYZ ( "scale" ) ; } @ Override public void shearX ( float angle ) { Affine temp = new Affine ( ) ; temp . appendShear ( Math . tan ( angle ) , 0 ) ; context . transform ( temp ) ; } @ Override public void shearY ( float angle ) { Affine temp = new Affine ( ) ; temp . appendShear ( 0 , Math . tan ( angle ) ) ; context . transform ( temp ) ; } @ Override public void resetMatrix ( ) { context . setTransform ( new Affine ( ) ) ; } @ Override public void applyMatrix ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) { context . transform ( n00 , n10 , n01 , n11 , n02 , n12 ) ; } @ Override public void applyMatrix ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { showVariationWarning ( "applyMatrix" ) ; } @ Override public PMatrix getMatrix ( ) { return getMatrix ( ( PMatrix2D ) null ) ; } @ Override public PMatrix2D getMatrix ( PMatrix2D target ) { if ( target == null ) { target = new PMatrix2D ( ) ; } Affine t = context . getTransform ( ) ; target . set ( ( float ) t . getMxx ( ) , ( float ) t . getMxy ( ) , ( float ) t . getTx ( ) , ( float ) t . getMyx ( ) , ( float ) t . getMyy ( ) , ( float ) t . getTy ( ) ) ; return target ; } @ Override public PMatrix3D getMatrix ( PMatrix3D target ) { showVariationWarning ( "getMatrix" ) ; return target ; } @ Override public void setMatrix ( PMatrix2D source ) { context . setTransform ( source . m00 , source . m10 , source . m01 , source . m11 , source . m02 , source . m12 ) ; } @ Override public void setMatrix ( PMatrix3D source ) { showVariationWarning ( "setMatrix" ) ; } @ Override public void printMatrix ( ) { getMatrix ( ( PMatrix2D ) null ) . print ( ) ; } @ Override public float screenX ( float x , float y ) { return ( float ) context . getTransform ( ) . transform ( x , y ) . getX ( ) ; } @ Override public float screenY ( float x , float y ) { return ( float ) context . getTransform ( ) . transform ( x , y ) . getY ( ) ; } @ Override public float screenX ( float x , float y , float z ) { showDepthWarningXYZ ( "screenX" ) ; return 0 ; } @ Override public float screenY ( float x , float y , float z ) { showDepthWarningXYZ ( "screenY" ) ; return 0 ; } @ Override public float screenZ ( float x , float y , float z ) { showDepthWarningXYZ ( "screenZ" ) ; return 0 ; } @ Override public void strokeCap ( int cap ) { super . strokeCap ( cap ) ; if ( strokeCap == ROUND ) { context . setLineCap ( StrokeLineCap . ROUND ) ; } else if ( strokeCap == PROJECT ) { context . setLineCap ( StrokeLineCap . SQUARE ) ; } else { context . setLineCap ( StrokeLineCap . BUTT ) ; } } @ Override public void strokeJoin ( int join ) { super . strokeJoin ( join ) ; if ( strokeJoin == MITER ) { context . setLineJoin ( StrokeLineJoin . MITER ) ; } else if ( strokeJoin == ROUND ) { context . setLineJoin ( StrokeLineJoin . ROUND ) ; } else { context . setLineJoin ( StrokeLineJoin . BEVEL ) ; } } @ Override public void strokeWeight ( float weight ) { super . strokeWeight ( weight ) ; context . setLineWidth ( weight ) ; } @ Override protected void strokeFromCalc ( ) { super . strokeFromCalc ( ) ; context . setStroke ( new Color ( strokeR , strokeG , strokeB , strokeA ) ) ; } @ Override protected void fillFromCalc ( ) { super . fillFromCalc ( ) ; context . setFill ( new Color ( fillR , fillG , fillB , fillA ) ) ; } @ Override public void backgroundImpl ( ) { Paint savedFill = context . getFill ( ) ; BlendMode savedBlend = context . getGlobalBlendMode ( ) ; context . setFill ( new Color ( backgroundR , backgroundG , backgroundB , backgroundA ) ) ; context . setGlobalBlendMode ( BlendMode . SRC_OVER ) ; context . fillRect ( 0 , 0 , width , height ) ; context . setFill ( savedFill ) ; context . setGlobalBlendMode ( savedBlend ) ; } @ Override public void loadPixels ( ) { int wide = width * pixelDensity ; int high = height * pixelDensity ; if ( ( pixels == null ) || ( pixels . length != wide * high ) ) { pixels = new int [ wide * high ] ; } SnapshotParameters sp = new SnapshotParameters ( ) ; if ( pixelDensity == 2 ) { sp . setTransform ( Transform . scale ( 2 , 2 ) ) ; } WritableImage wi = ( ( PSurfaceFX ) surface ) . canvas . snapshot ( sp , null ) ; PixelReader pr = wi . getPixelReader ( ) ; pr . getPixels ( 0 , 0 , wide , high , argbFormat , pixels , 0 , wide ) ; } static final String MASK_WARNING = "mask() cannot be used on the main drawing surface" ; @ Override public void mask ( PImage alpha ) { showWarning ( MASK_WARNING ) ; } static public void showTodoWarning ( String method , int issue ) { showWarning ( method + "() is not yet available: " + "https://github.com/processing/processing/issues/" + issue ) ; } }
package processing . data ; public interface TableRow { public String getString ( int column ) ; public String getString ( String columnName ) ; public int getInt ( int column ) ; public int getInt ( String columnName ) ; public long getLong ( int column ) ; public long getLong ( String columnName ) ; public float getFloat ( int column ) ; public float getFloat ( String columnName ) ; public double getDouble ( int column ) ; public double getDouble ( String columnName ) ; public void setString ( int column , String value ) ; public void setString ( String columnName , String value ) ; public void setInt ( int column , int value ) ; public void setInt ( String columnName , int value ) ; public void setLong ( int column , long value ) ; public void setLong ( String columnName , long value ) ; public void setFloat ( int column , float value ) ; public void setFloat ( String columnName , float value ) ; public void setDouble ( int column , double value ) ; public void setDouble ( String columnName , double value ) ; public int getColumnCount ( ) ; public int getColumnType ( String columnName ) ; public int getColumnType ( int column ) ; public int [ ] getColumnTypes ( ) ; public String getColumnTitle ( int column ) ; public String [ ] getColumnTitles ( ) ; }
package processing . data ; import java . util . Arrays ; import java . util . Iterator ; import java . util . Random ; import processing . core . PApplet ; public class IntList implements Iterable < Integer > { protected int count ; protected int [ ] data ; public IntList ( ) { data = new int [ 10 ] ; } public IntList ( int length ) { data = new int [ length ] ; } public IntList ( int [ ] source ) { count = source . length ; data = new int [ count ] ; System . arraycopy ( source , 0 , data , 0 , count ) ; } public IntList ( Iterable < Object > iter ) { this ( 10 ) ; for ( Object o : iter ) { if ( o == null ) { append ( 0 ) ; } else if ( o instanceof Number ) { append ( ( ( Number ) o ) . intValue ( ) ) ; } else { append ( PApplet . parseInt ( o . toString ( ) . trim ( ) ) ) ; } } crop ( ) ; } public IntList ( Object ... items ) { final int missingValue = 0 ; count = items . length ; data = new int [ count ] ; int index = 0 ; for ( Object o : items ) { int value = missingValue ; if ( o != null ) { if ( o instanceof Number ) { value = ( ( Number ) o ) . intValue ( ) ; } else { value = PApplet . parseInt ( o . toString ( ) . trim ( ) , missingValue ) ; } } data [ index ++ ] = value ; } } static public IntList fromRange ( int stop ) { return fromRange ( 0 , stop ) ; } static public IntList fromRange ( int start , int stop ) { int count = stop - start ; IntList newbie = new IntList ( count ) ; for ( int i = 0 ; i < count ; i ++ ) { newbie . set ( i , start + i ) ; } return newbie ; } private void crop ( ) { if ( count != data . length ) { data = PApplet . subset ( data , 0 , count ) ; } } public int size ( ) { return count ; } public void resize ( int length ) { if ( length > data . length ) { int [ ] temp = new int [ length ] ; System . arraycopy ( data , 0 , temp , 0 , count ) ; data = temp ; } else if ( length > count ) { Arrays . fill ( data , count , length , 0 ) ; } count = length ; } public void clear ( ) { count = 0 ; } public int get ( int index ) { if ( index >= this . count ) { throw new ArrayIndexOutOfBoundsException ( index ) ; } return data [ index ] ; } public void set ( int index , int what ) { if ( index >= count ) { data = PApplet . expand ( data , index + 1 ) ; for ( int i = count ; i < index ; i ++ ) { data [ i ] = 0 ; } count = index + 1 ; } data [ index ] = what ; } public void push ( int value ) { append ( value ) ; } public int pop ( ) { if ( count == 0 ) { throw new RuntimeException ( "Can't call pop() on an empty list" ) ; } int value = get ( count - 1 ) ; count -- ; return value ; } public int remove ( int index ) { if ( index < 0 || index >= count ) { throw new ArrayIndexOutOfBoundsException ( index ) ; } int entry = data [ index ] ; for ( int i = index ; i < count - 1 ; i ++ ) { data [ i ] = data [ i + 1 ] ; } count -- ; return entry ; } public int removeValue ( int value ) { int index = index ( value ) ; if ( index != - 1 ) { remove ( index ) ; return index ; } return - 1 ; } public int removeValues ( int value ) { int ii = 0 ; for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] != value ) { data [ ii ++ ] = data [ i ] ; } } int removed = count - ii ; count = ii ; return removed ; } public void append ( int value ) { if ( count == data . length ) { data = PApplet . expand ( data ) ; } data [ count ++ ] = value ; } public void append ( int [ ] values ) { for ( int v : values ) { append ( v ) ; } } public void append ( IntList list ) { for ( int v : list . values ( ) ) { append ( v ) ; } } public void appendUnique ( int value ) { if ( ! hasValue ( value ) ) { append ( value ) ; } } public void insert ( int index , int value ) { insert ( index , new int [ ] { value } ) ; } public void insert ( int index , int [ ] values ) { if ( index < 0 ) { throw new IllegalArgumentException ( "insert() index cannot be negative: it was " + index ) ; } if ( index >= data . length ) { throw new IllegalArgumentException ( "insert() index " + index + " is past the end of this list" ) ; } int [ ] temp = new int [ count + values . length ] ; System . arraycopy ( data , 0 , temp , 0 , Math . min ( count , index ) ) ; System . arraycopy ( values , 0 , temp , index , values . length ) ; System . arraycopy ( data , index , temp , index + values . length , count - index ) ; count = count + values . length ; data = temp ; } public void insert ( int index , IntList list ) { insert ( index , list . values ( ) ) ; } public int index ( int what ) { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] == what ) { return i ; } } return - 1 ; } public boolean hasValue ( int value ) { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] == value ) { return true ; } } return false ; } public void increment ( int index ) { if ( count <= index ) { resize ( index + 1 ) ; } data [ index ] ++ ; } private void boundsProblem ( int index , String method ) { final String msg = String . format ( "The list size is %d. " + "You cannot %s() to element %d." , count , method , index ) ; throw new ArrayIndexOutOfBoundsException ( msg ) ; } public void add ( int index , int amount ) { if ( index < count ) { data [ index ] += amount ; } else { boundsProblem ( index , "add" ) ; } } public void sub ( int index , int amount ) { if ( index < count ) { data [ index ] -= amount ; } else { boundsProblem ( index , "sub" ) ; } } public void mult ( int index , int amount ) { if ( index < count ) { data [ index ] *= amount ; } else { boundsProblem ( index , "mult" ) ; } } public void div ( int index , int amount ) { if ( index < count ) { data [ index ] /= amount ; } else { boundsProblem ( index , "div" ) ; } } private void checkMinMax ( String functionName ) { if ( count == 0 ) { String msg = String . format ( "Cannot use %s() on an empty %s." , functionName , getClass ( ) . getSimpleName ( ) ) ; throw new RuntimeException ( msg ) ; } } public int min ( ) { checkMinMax ( "min" ) ; int outgoing = data [ 0 ] ; for ( int i = 1 ; i < count ; i ++ ) { if ( data [ i ] < outgoing ) outgoing = data [ i ] ; } return outgoing ; } public int minIndex ( ) { checkMinMax ( "minIndex" ) ; int value = data [ 0 ] ; int index = 0 ; for ( int i = 1 ; i < count ; i ++ ) { if ( data [ i ] < value ) { value = data [ i ] ; index = i ; } } return index ; } public int max ( ) { checkMinMax ( "max" ) ; int outgoing = data [ 0 ] ; for ( int i = 1 ; i < count ; i ++ ) { if ( data [ i ] > outgoing ) outgoing = data [ i ] ; } return outgoing ; } public int maxIndex ( ) { checkMinMax ( "maxIndex" ) ; int value = data [ 0 ] ; int index = 0 ; for ( int i = 1 ; i < count ; i ++ ) { if ( data [ i ] > value ) { value = data [ i ] ; index = i ; } } return index ; } public int sum ( ) { int outgoing = 0 ; for ( int i = 0 ; i < count ; i ++ ) { outgoing += data [ i ] ; } return outgoing ; } public void sort ( ) { Arrays . sort ( data , 0 , count ) ; } public void sortReverse ( ) { new Sort ( ) { @ Override public int size ( ) { return count ; } @ Override public float compare ( int a , int b ) { return data [ b ] - data [ a ] ; } @ Override public void swap ( int a , int b ) { int temp = data [ a ] ; data [ a ] = data [ b ] ; data [ b ] = temp ; } } . run ( ) ; } public void reverse ( ) { int ii = count - 1 ; for ( int i = 0 ; i < count / 2 ; i ++ ) { int t = data [ i ] ; data [ i ] = data [ ii ] ; data [ ii ] = t ; -- ii ; } } public void shuffle ( ) { Random r = new Random ( ) ; int num = count ; while ( num > 1 ) { int value = r . nextInt ( num ) ; num -- ; int temp = data [ num ] ; data [ num ] = data [ value ] ; data [ value ] = temp ; } } public void shuffle ( PApplet sketch ) { int num = count ; while ( num > 1 ) { int value = ( int ) sketch . random ( num ) ; num -- ; int temp = data [ num ] ; data [ num ] = data [ value ] ; data [ value ] = temp ; } } public IntList copy ( ) { IntList outgoing = new IntList ( data ) ; outgoing . count = count ; return outgoing ; } public int [ ] values ( ) { crop ( ) ; return data ; } @ Override public Iterator < Integer > iterator ( ) { return new Iterator < Integer > ( ) { int index = - 1 ; public void remove ( ) { IntList . this . remove ( index ) ; } public Integer next ( ) { return data [ ++ index ] ; } public boolean hasNext ( ) { return index + 1 < count ; } } ; } public int [ ] array ( ) { return array ( null ) ; } public int [ ] array ( int [ ] array ) { if ( array == null || array . length != count ) { array = new int [ count ] ; } System . arraycopy ( data , 0 , array , 0 , count ) ; return array ; } public FloatList getPercent ( ) { double sum = 0 ; for ( float value : array ( ) ) { sum += value ; } FloatList outgoing = new FloatList ( count ) ; for ( int i = 0 ; i < count ; i ++ ) { double percent = data [ i ] / sum ; outgoing . set ( i , ( float ) percent ) ; } return outgoing ; } public IntList getSubset ( int start ) { return getSubset ( start , count - start ) ; } public IntList getSubset ( int start , int num ) { int [ ] subset = new int [ num ] ; System . arraycopy ( data , start , subset , 0 , num ) ; return new IntList ( subset ) ; } public String join ( String separator ) { if ( count == 0 ) { return "" ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( data [ 0 ] ) ; for ( int i = 1 ; i < count ; i ++ ) { sb . append ( separator ) ; sb . append ( data [ i ] ) ; } return sb . toString ( ) ; } public void print ( ) { for ( int i = 0 ; i < size ( ) ; i ++ ) { System . out . format ( "[%d] %d%n" , i , data [ i ] ) ; } } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getSimpleName ( ) + " size=" + size ( ) + " [ " ) ; for ( int i = 0 ; i < size ( ) ; i ++ ) { if ( i != 0 ) { sb . append ( ", " ) ; } sb . append ( i + ": " + data [ i ] ) ; } sb . append ( " ]" ) ; return sb . toString ( ) ; } }
package processing . data ; import java . io . * ; import java . util . HashMap ; import java . util . Iterator ; import processing . core . PApplet ; public class IntDict { protected int count ; protected String [ ] keys ; protected int [ ] values ; private HashMap < String , Integer > indices = new HashMap < String , Integer > ( ) ; public IntDict ( ) { count = 0 ; keys = new String [ 10 ] ; values = new int [ 10 ] ; } public IntDict ( int length ) { count = 0 ; keys = new String [ length ] ; values = new int [ length ] ; } public IntDict ( BufferedReader reader ) { String [ ] lines = PApplet . loadStrings ( reader ) ; keys = new String [ lines . length ] ; values = new int [ lines . length ] ; for ( int i = 0 ; i < lines . length ; i ++ ) { String [ ] pieces = PApplet . split ( lines [ i ] , '\t' ) ; if ( pieces . length == 2 ) { keys [ count ] = pieces [ 0 ] ; values [ count ] = PApplet . parseInt ( pieces [ 1 ] ) ; indices . put ( pieces [ 0 ] , count ) ; count ++ ; } } } public IntDict ( String [ ] keys , int [ ] values ) { if ( keys . length != values . length ) { throw new IllegalArgumentException ( "key and value arrays must be the same length" ) ; } this . keys = keys ; this . values = values ; count = keys . length ; for ( int i = 0 ; i < count ; i ++ ) { indices . put ( keys [ i ] , i ) ; } } public IntDict ( Object [ ] [ ] pairs ) { count = pairs . length ; this . keys = new String [ count ] ; this . values = new int [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { keys [ i ] = ( String ) pairs [ i ] [ 0 ] ; values [ i ] = ( Integer ) pairs [ i ] [ 1 ] ; indices . put ( keys [ i ] , i ) ; } } public int size ( ) { return count ; } public void clear ( ) { count = 0 ; indices = new HashMap < String , Integer > ( ) ; } public String key ( int index ) { return keys [ index ] ; } public Iterable < String > keys ( ) { return new Iterable < String > ( ) { @ Override public Iterator < String > iterator ( ) { return keyIterator ( ) ; } } ; } public Iterator < String > keyIterator ( ) { return new Iterator < String > ( ) { int index = - 1 ; public void remove ( ) { removeIndex ( index ) ; } public String next ( ) { return key ( ++ index ) ; } public boolean hasNext ( ) { return index + 1 < size ( ) ; } } ; } public String [ ] keyArray ( ) { return keyArray ( null ) ; } public String [ ] keyArray ( String [ ] outgoing ) { if ( outgoing == null || outgoing . length != count ) { outgoing = new String [ count ] ; } System . arraycopy ( keys , 0 , outgoing , 0 , count ) ; return outgoing ; } public int value ( int index ) { return values [ index ] ; } public Iterable < Integer > values ( ) { return new Iterable < Integer > ( ) { @ Override public Iterator < Integer > iterator ( ) { return valueIterator ( ) ; } } ; } public Iterator < Integer > valueIterator ( ) { return new Iterator < Integer > ( ) { int index = - 1 ; public void remove ( ) { removeIndex ( index ) ; } public Integer next ( ) { return value ( ++ index ) ; } public boolean hasNext ( ) { return index + 1 < size ( ) ; } } ; } public int [ ] valueArray ( ) { return valueArray ( null ) ; } public int [ ] valueArray ( int [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new int [ count ] ; } System . arraycopy ( values , 0 , array , 0 , count ) ; return array ; } public int get ( String key ) { int index = index ( key ) ; if ( index == - 1 ) { throw new IllegalArgumentException ( "No key named '" + key + "'" ) ; } return values [ index ] ; } public int get ( String key , int alternate ) { int index = index ( key ) ; if ( index == - 1 ) return alternate ; return values [ index ] ; } public void set ( String key , int amount ) { int index = index ( key ) ; if ( index == - 1 ) { create ( key , amount ) ; } else { values [ index ] = amount ; } } public boolean hasKey ( String key ) { return index ( key ) != - 1 ; } public void increment ( String key ) { add ( key , 1 ) ; } public void add ( String key , int amount ) { int index = index ( key ) ; if ( index == - 1 ) { create ( key , amount ) ; } else { values [ index ] += amount ; } } public void sub ( String key , int amount ) { add ( key , - amount ) ; } public void mult ( String key , int amount ) { int index = index ( key ) ; if ( index != - 1 ) { values [ index ] *= amount ; } } public void div ( String key , int amount ) { int index = index ( key ) ; if ( index != - 1 ) { values [ index ] /= amount ; } } private void checkMinMax ( String functionName ) { if ( count == 0 ) { String msg = String . format ( "Cannot use %s() on an empty %s." , functionName , getClass ( ) . getSimpleName ( ) ) ; throw new RuntimeException ( msg ) ; } } public int minIndex ( ) { checkMinMax ( "minIndex" ) ; int index = 0 ; int value = values [ 0 ] ; for ( int i = 1 ; i < count ; i ++ ) { if ( values [ i ] < value ) { index = i ; value = values [ i ] ; } } return index ; } public int minValue ( ) { checkMinMax ( "minValue" ) ; return values [ minIndex ( ) ] ; } public String minKey ( ) { checkMinMax ( "minKey" ) ; return keys [ minIndex ( ) ] ; } public int maxIndex ( ) { checkMinMax ( "maxIndex" ) ; int index = 0 ; int value = values [ 0 ] ; for ( int i = 1 ; i < count ; i ++ ) { if ( values [ i ] > value ) { index = i ; value = values [ i ] ; } } return index ; } public int maxValue ( ) { checkMinMax ( "maxValue" ) ; return values [ maxIndex ( ) ] ; } public String maxKey ( ) { checkMinMax ( "maxKey" ) ; return keys [ maxIndex ( ) ] ; } public int index ( String what ) { Integer found = indices . get ( what ) ; return ( found == null ) ? - 1 : found . intValue ( ) ; } protected void create ( String what , int much ) { if ( count == keys . length ) { keys = PApplet . expand ( keys ) ; values = PApplet . expand ( values ) ; } indices . put ( what , Integer . valueOf ( count ) ) ; keys [ count ] = what ; values [ count ] = much ; count ++ ; } public int remove ( String key ) { int index = index ( key ) ; if ( index != - 1 ) { removeIndex ( index ) ; } return index ; } public String removeIndex ( int index ) { if ( index < 0 || index >= count ) { throw new ArrayIndexOutOfBoundsException ( index ) ; } String key = keys [ index ] ; indices . remove ( keys [ index ] ) ; for ( int i = index ; i < count - 1 ; i ++ ) { keys [ i ] = keys [ i + 1 ] ; values [ i ] = values [ i + 1 ] ; indices . put ( keys [ i ] , i ) ; } count -- ; keys [ count ] = null ; values [ count ] = 0 ; return key ; } public void swap ( int a , int b ) { String tkey = keys [ a ] ; int tvalue = values [ a ] ; keys [ a ] = keys [ b ] ; values [ a ] = values [ b ] ; keys [ b ] = tkey ; values [ b ] = tvalue ; indices . put ( keys [ a ] , Integer . valueOf ( a ) ) ; indices . put ( keys [ b ] , Integer . valueOf ( b ) ) ; } public void sortKeys ( ) { sortImpl ( true , false ) ; } public void sortKeysReverse ( ) { sortImpl ( true , true ) ; } public void sortValues ( ) { sortImpl ( false , false ) ; } public void sortValuesReverse ( ) { sortImpl ( false , true ) ; } protected void sortImpl ( final boolean useKeys , final boolean reverse ) { Sort s = new Sort ( ) { @ Override public int size ( ) { return count ; } @ Override public float compare ( int a , int b ) { int diff = 0 ; if ( useKeys ) { diff = keys [ a ] . compareToIgnoreCase ( keys [ b ] ) ; if ( diff == 0 ) { return values [ a ] - values [ b ] ; } } else { diff = values [ a ] - values [ b ] ; if ( diff == 0 ) { diff = keys [ a ] . compareToIgnoreCase ( keys [ b ] ) ; } } return reverse ? - diff : diff ; } @ Override public void swap ( int a , int b ) { IntDict . this . swap ( a , b ) ; } } ; s . run ( ) ; } public FloatDict getPercent ( ) { double sum = 0 ; for ( int value : valueArray ( ) ) { sum += value ; } FloatDict outgoing = new FloatDict ( ) ; for ( int i = 0 ; i < size ( ) ; i ++ ) { double percent = value ( i ) / sum ; outgoing . set ( key ( i ) , ( float ) percent ) ; } return outgoing ; } public IntDict copy ( ) { IntDict outgoing = new IntDict ( count ) ; System . arraycopy ( keys , 0 , outgoing . keys , 0 , count ) ; System . arraycopy ( values , 0 , outgoing . values , 0 , count ) ; for ( int i = 0 ; i < count ; i ++ ) { outgoing . indices . put ( keys [ i ] , i ) ; } outgoing . count = count ; return outgoing ; } public void write ( PrintWriter writer ) { for ( int i = 0 ; i < count ; i ++ ) { writer . println ( keys [ i ] + "\t" + values [ i ] ) ; } writer . flush ( ) ; } public void print ( ) { for ( int i = 0 ; i < size ( ) ; i ++ ) { System . out . println ( keys [ i ] + " = " + values [ i ] ) ; } } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getSimpleName ( ) + " size=" + size ( ) + " { " ) ; for ( int i = 0 ; i < size ( ) ; i ++ ) { if ( i != 0 ) { sb . append ( ", " ) ; } sb . append ( "\"" + keys [ i ] + "\": " + values [ i ] ) ; } sb . append ( " }" ) ; return sb . toString ( ) ; } }
package processing . data ; import java . io . * ; import java . util . HashMap ; import java . util . Iterator ; import processing . core . PApplet ; public class StringDict { protected int count ; protected String [ ] keys ; protected String [ ] values ; private HashMap < String , Integer > indices = new HashMap < String , Integer > ( ) ; public StringDict ( ) { count = 0 ; keys = new String [ 10 ] ; values = new String [ 10 ] ; } public StringDict ( int length ) { count = 0 ; keys = new String [ length ] ; values = new String [ length ] ; } public StringDict ( BufferedReader reader ) { String [ ] lines = PApplet . loadStrings ( reader ) ; keys = new String [ lines . length ] ; values = new String [ lines . length ] ; for ( int i = 0 ; i < lines . length ; i ++ ) { String [ ] pieces = PApplet . split ( lines [ i ] , '\t' ) ; if ( pieces . length == 2 ) { keys [ count ] = pieces [ 0 ] ; values [ count ] = pieces [ 1 ] ; indices . put ( keys [ count ] , count ) ; count ++ ; } } } public StringDict ( String [ ] keys , String [ ] values ) { if ( keys . length != values . length ) { throw new IllegalArgumentException ( "key and value arrays must be the same length" ) ; } this . keys = keys ; this . values = values ; count = keys . length ; for ( int i = 0 ; i < count ; i ++ ) { indices . put ( keys [ i ] , i ) ; } } public StringDict ( String [ ] [ ] pairs ) { count = pairs . length ; this . keys = new String [ count ] ; this . values = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { keys [ i ] = pairs [ i ] [ 0 ] ; values [ i ] = pairs [ i ] [ 1 ] ; indices . put ( keys [ i ] , i ) ; } } public int size ( ) { return count ; } public void clear ( ) { count = 0 ; indices = new HashMap < String , Integer > ( ) ; } public String key ( int index ) { return keys [ index ] ; } protected void crop ( ) { if ( count != keys . length ) { keys = PApplet . subset ( keys , 0 , count ) ; values = PApplet . subset ( values , 0 , count ) ; } } public Iterable < String > keys ( ) { return new Iterable < String > ( ) { @ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { int index = - 1 ; public void remove ( ) { removeIndex ( index ) ; } public String next ( ) { return key ( ++ index ) ; } public boolean hasNext ( ) { return index + 1 < size ( ) ; } } ; } } ; } public String [ ] keyArray ( ) { return keyArray ( null ) ; } public String [ ] keyArray ( String [ ] outgoing ) { if ( outgoing == null || outgoing . length != count ) { outgoing = new String [ count ] ; } System . arraycopy ( keys , 0 , outgoing , 0 , count ) ; return outgoing ; } public String value ( int index ) { return values [ index ] ; } public Iterable < String > values ( ) { return new Iterable < String > ( ) { @ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { int index = - 1 ; public void remove ( ) { removeIndex ( index ) ; } public String next ( ) { return value ( ++ index ) ; } public boolean hasNext ( ) { return index + 1 < size ( ) ; } } ; } } ; } public String [ ] valueArray ( ) { return valueArray ( null ) ; } public String [ ] valueArray ( String [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new String [ count ] ; } System . arraycopy ( values , 0 , array , 0 , count ) ; return array ; } public String get ( String key ) { int index = index ( key ) ; if ( index == - 1 ) return null ; return values [ index ] ; } public String get ( String key , String alternate ) { int index = index ( key ) ; if ( index == - 1 ) return alternate ; return values [ index ] ; } public void set ( String key , String value ) { int index = index ( key ) ; if ( index == - 1 ) { create ( key , value ) ; } else { values [ index ] = value ; } } public int index ( String what ) { Integer found = indices . get ( what ) ; return ( found == null ) ? - 1 : found . intValue ( ) ; } public boolean hasKey ( String key ) { return index ( key ) != - 1 ; } protected void create ( String key , String value ) { if ( count == keys . length ) { keys = PApplet . expand ( keys ) ; values = PApplet . expand ( values ) ; } indices . put ( key , Integer . valueOf ( count ) ) ; keys [ count ] = key ; values [ count ] = value ; count ++ ; } public int remove ( String key ) { int index = index ( key ) ; if ( index != - 1 ) { removeIndex ( index ) ; } return index ; } public String removeIndex ( int index ) { if ( index < 0 || index >= count ) { throw new ArrayIndexOutOfBoundsException ( index ) ; } String key = keys [ index ] ; indices . remove ( key ) ; for ( int i = index ; i < count - 1 ; i ++ ) { keys [ i ] = keys [ i + 1 ] ; values [ i ] = values [ i + 1 ] ; indices . put ( keys [ i ] , i ) ; } count -- ; keys [ count ] = null ; values [ count ] = null ; return key ; } public void swap ( int a , int b ) { String tkey = keys [ a ] ; String tvalue = values [ a ] ; keys [ a ] = keys [ b ] ; values [ a ] = values [ b ] ; keys [ b ] = tkey ; values [ b ] = tvalue ; indices . put ( keys [ a ] , Integer . valueOf ( a ) ) ; indices . put ( keys [ b ] , Integer . valueOf ( b ) ) ; } public void sortKeys ( ) { sortImpl ( true , false ) ; } public void sortKeysReverse ( ) { sortImpl ( true , true ) ; } public void sortValues ( ) { sortImpl ( false , false ) ; } public void sortValuesReverse ( ) { sortImpl ( false , true ) ; } protected void sortImpl ( final boolean useKeys , final boolean reverse ) { Sort s = new Sort ( ) { @ Override public int size ( ) { return count ; } @ Override public float compare ( int a , int b ) { int diff = 0 ; if ( useKeys ) { diff = keys [ a ] . compareToIgnoreCase ( keys [ b ] ) ; if ( diff == 0 ) { diff = values [ a ] . compareToIgnoreCase ( values [ b ] ) ; } } else { diff = values [ a ] . compareToIgnoreCase ( values [ b ] ) ; if ( diff == 0 ) { diff = keys [ a ] . compareToIgnoreCase ( keys [ b ] ) ; } } return reverse ? - diff : diff ; } @ Override public void swap ( int a , int b ) { StringDict . this . swap ( a , b ) ; } } ; s . run ( ) ; } public StringDict copy ( ) { StringDict outgoing = new StringDict ( count ) ; System . arraycopy ( keys , 0 , outgoing . keys , 0 , count ) ; System . arraycopy ( values , 0 , outgoing . values , 0 , count ) ; for ( int i = 0 ; i < count ; i ++ ) { outgoing . indices . put ( keys [ i ] , i ) ; } outgoing . count = count ; return outgoing ; } public void write ( PrintWriter writer ) { for ( int i = 0 ; i < count ; i ++ ) { writer . println ( keys [ i ] + "\t" + values [ i ] ) ; } writer . flush ( ) ; } public void print ( ) { for ( int i = 0 ; i < size ( ) ; i ++ ) { System . out . println ( keys [ i ] + " = " + values [ i ] ) ; } } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getSimpleName ( ) + " size=" + size ( ) + " { " ) ; for ( int i = 0 ; i < size ( ) ; i ++ ) { if ( i != 0 ) { sb . append ( ", " ) ; } sb . append ( "\"" + keys [ i ] + "\": \"" + values [ i ] + "\"" ) ; } sb . append ( " }" ) ; return sb . toString ( ) ; } }
package processing . data ; import java . io . * ; import java . lang . reflect . * ; import java . nio . charset . Charset ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; import java . sql . SQLException ; import java . sql . Types ; import java . util . * ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . zip . ZipEntry ; import java . util . zip . ZipInputStream ; import java . util . zip . ZipOutputStream ; import javax . xml . parsers . ParserConfigurationException ; import org . xml . sax . SAXException ; import processing . core . PApplet ; import processing . core . PConstants ; public class Table { protected int rowCount ; protected int allocCount ; protected String missingString = null ; protected int missingInt = 0 ; protected long missingLong = 0 ; protected float missingFloat = Float . NaN ; protected double missingDouble = Double . NaN ; protected int missingCategory = - 1 ; String [ ] columnTitles ; HashMapBlows [ ] columnCategories ; HashMap < String , Integer > columnIndices ; protected Object [ ] columns ; static public final int STRING = 0 ; static public final int INT = 1 ; static public final int LONG = 2 ; static public final int FLOAT = 3 ; static public final int DOUBLE = 4 ; static public final int CATEGORY = 5 ; int [ ] columnTypes ; protected RowIterator rowIterator ; protected int expandIncrement ; public Table ( ) { init ( ) ; } public Table ( File file ) throws IOException { this ( file , null ) ; } public Table ( File file , String options ) throws IOException { init ( ) ; parse ( PApplet . createInput ( file ) , extensionOptions ( true , file . getName ( ) , options ) ) ; } public Table ( InputStream input ) throws IOException { this ( input , null ) ; } public Table ( InputStream input , String options ) throws IOException { init ( ) ; parse ( input , options ) ; } public Table ( Iterable < TableRow > rows ) { init ( ) ; int row = 0 ; int alloc = 10 ; for ( TableRow incoming : rows ) { if ( row == 0 ) { setColumnTypes ( incoming . getColumnTypes ( ) ) ; setColumnTitles ( incoming . getColumnTitles ( ) ) ; setRowCount ( alloc ) ; setColumnCount ( incoming . getColumnCount ( ) ) ; } else if ( row == alloc ) { alloc *= 2 ; setRowCount ( alloc ) ; } setRow ( row ++ , incoming ) ; } if ( row != alloc ) { setRowCount ( row ) ; } } public Table ( ResultSet rs ) { init ( ) ; try { ResultSetMetaData rsmd = rs . getMetaData ( ) ; int columnCount = rsmd . getColumnCount ( ) ; setColumnCount ( columnCount ) ; for ( int col = 0 ; col < columnCount ; col ++ ) { setColumnTitle ( col , rsmd . getColumnName ( col + 1 ) ) ; int type = rsmd . getColumnType ( col + 1 ) ; switch ( type ) { case Types . INTEGER : case Types . TINYINT : case Types . SMALLINT : setColumnType ( col , INT ) ; break ; case Types . BIGINT : setColumnType ( col , LONG ) ; break ; case Types . FLOAT : setColumnType ( col , FLOAT ) ; break ; case Types . DECIMAL : case Types . DOUBLE : case Types . REAL : setColumnType ( col , DOUBLE ) ; break ; } } int row = 0 ; while ( rs . next ( ) ) { for ( int col = 0 ; col < columnCount ; col ++ ) { switch ( columnTypes [ col ] ) { case STRING : setString ( row , col , rs . getString ( col + 1 ) ) ; break ; case INT : setInt ( row , col , rs . getInt ( col + 1 ) ) ; break ; case LONG : setLong ( row , col , rs . getLong ( col + 1 ) ) ; break ; case FLOAT : setFloat ( row , col , rs . getFloat ( col + 1 ) ) ; break ; case DOUBLE : setDouble ( row , col , rs . getDouble ( col + 1 ) ) ; break ; default : throw new IllegalArgumentException ( "column type " + columnTypes [ col ] + " not supported." ) ; } } row ++ ; } } catch ( SQLException s ) { throw new RuntimeException ( s ) ; } } public Table typedParse ( InputStream input , String options ) throws IOException { Table table = new Table ( ) ; table . setColumnTypes ( this ) ; table . parse ( input , options ) ; return table ; } protected void init ( ) { columns = new Object [ 0 ] ; columnTypes = new int [ 0 ] ; columnCategories = new HashMapBlows [ 0 ] ; } static final String [ ] loadExtensions = { "csv" , "tsv" , "ods" , "bin" } ; static final String [ ] saveExtensions = { "csv" , "tsv" , "ods" , "bin" , "html" } ; static public String extensionOptions ( boolean loading , String filename , String options ) { String extension = PApplet . checkExtension ( filename ) ; if ( extension != null ) { for ( String possible : loading ? loadExtensions : saveExtensions ) { if ( extension . equals ( possible ) ) { if ( options == null ) { return extension ; } else { return extension + "," + options ; } } } } return options ; } protected void parse ( InputStream input , String options ) throws IOException { boolean awfulCSV = false ; boolean header = false ; String extension = null ; boolean binary = false ; String worksheet = null ; final String sheetParam = "worksheet=" ; String [ ] opts = null ; if ( options != null ) { opts = PApplet . trim ( PApplet . split ( options , ',' ) ) ; for ( String opt : opts ) { if ( opt . equals ( "tsv" ) ) { extension = "tsv" ; } else if ( opt . equals ( "csv" ) ) { extension = "csv" ; } else if ( opt . equals ( "ods" ) ) { extension = "ods" ; } else if ( opt . equals ( "newlines" ) ) { awfulCSV = true ; extension = "csv" ; } else if ( opt . equals ( "bin" ) ) { binary = true ; extension = "bin" ; } else if ( opt . equals ( "header" ) ) { header = true ; } else if ( opt . startsWith ( sheetParam ) ) { worksheet = opt . substring ( sheetParam . length ( ) ) ; } else if ( opt . startsWith ( "dictionary=" ) ) { } else { throw new IllegalArgumentException ( "'" + opt + "' is not a valid option for loading a Table" ) ; } } } if ( extension == null ) { throw new IllegalArgumentException ( "No extension specified for this Table" ) ; } if ( binary ) { loadBinary ( input ) ; } else if ( extension . equals ( "ods" ) ) { odsParse ( input , worksheet , header ) ; } else { BufferedReader reader = PApplet . createReader ( input ) ; if ( awfulCSV ) { parseAwfulCSV ( reader , header ) ; } else if ( "tsv" . equals ( extension ) ) { parseBasic ( reader , header , true ) ; } else if ( "csv" . equals ( extension ) ) { parseBasic ( reader , header , false ) ; } } } protected void parseBasic ( BufferedReader reader , boolean header , boolean tsv ) throws IOException { String line = null ; int row = 0 ; if ( rowCount == 0 ) { setRowCount ( 10 ) ; } try { while ( ( line = reader . readLine ( ) ) != null ) { if ( row == getRowCount ( ) ) { setRowCount ( row < < 1 ) ; } if ( row == 0 && header ) { setColumnTitles ( tsv ? PApplet . split ( line , '\t' ) : splitLineCSV ( line ) ) ; header = false ; } else { setRow ( row , tsv ? PApplet . split ( line , '\t' ) : splitLineCSV ( line ) ) ; row ++ ; } if ( row % 10000 == 0 ) { try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } catch ( Exception e ) { throw new RuntimeException ( "Error reading table on line " + row , e ) ; } if ( row != getRowCount ( ) ) { setRowCount ( row ) ; } } protected void parseAwfulCSV ( BufferedReader reader , boolean header ) throws IOException { char [ ] c = new char [ 100 ] ; int count = 0 ; boolean insideQuote = false ; int alloc = 100 ; setRowCount ( 100 ) ; int row = 0 ; int col = 0 ; int ch ; while ( ( ch = reader . read ( ) ) != - 1 ) { if ( insideQuote ) { if ( ch == '\"' ) { reader . mark ( 1 ) ; if ( reader . read ( ) == '\"' ) { if ( count == c . length ) { c = PApplet . expand ( c ) ; } c [ count ++ ] = '\"' ; } else { reader . reset ( ) ; insideQuote = false ; } } else { if ( count == c . length ) { c = PApplet . expand ( c ) ; } c [ count ++ ] = ( char ) ch ; } } else { if ( ch == '\"' ) { insideQuote = true ; } else if ( ch == '\r' || ch == '\n' ) { if ( ch == '\r' ) { reader . mark ( 1 ) ; if ( reader . read ( ) != '\n' ) { reader . reset ( ) ; } } setString ( row , col , new String ( c , 0 , count ) ) ; count = 0 ; row ++ ; if ( row == 1 && header ) { removeTitleRow ( ) ; header = false ; row = 0 ; } if ( row == alloc ) { alloc *= 2 ; setRowCount ( alloc ) ; } col = 0 ; } else if ( ch == ',' ) { setString ( row , col , new String ( c , 0 , count ) ) ; count = 0 ; col ++ ; ensureColumn ( col ) ; } else { if ( count == c . length ) { c = PApplet . expand ( c ) ; } c [ count ++ ] = ( char ) ch ; } } } if ( count > 0 ) { setString ( row , col , new String ( c , 0 , count ) ) ; } row ++ ; if ( alloc != row ) { setRowCount ( row ) ; } } static protected String [ ] splitLineCSV ( String line ) { char [ ] c = line . toCharArray ( ) ; int rough = 1 ; boolean quote = false ; for ( int i = 0 ; i < c . length ; i ++ ) { if ( ! quote && ( c [ i ] == ',' ) ) { rough ++ ; } else if ( c [ i ] == '\"' ) { quote = ! quote ; } } String [ ] pieces = new String [ rough ] ; int pieceCount = 0 ; int offset = 0 ; while ( offset < c . length ) { int start = offset ; int stop = nextComma ( c , offset ) ; offset = stop + 1 ; if ( c [ start ] == '\"' && c [ stop - 1 ] == '\"' ) { start ++ ; stop -- ; } int i = start ; int ii = start ; while ( i < stop ) { if ( c [ i ] == '\"' ) { i ++ ; } if ( i != ii ) { c [ ii ] = c [ i ] ; } i ++ ; ii ++ ; } String s = new String ( c , start , ii - start ) ; pieces [ pieceCount ++ ] = s ; } for ( int i = pieceCount ; i < pieces . length ; i ++ ) { pieces [ i ] = "" ; } return pieces ; } static protected int nextComma ( char [ ] c , int index ) { boolean quote = false ; for ( int i = index ; i < c . length ; i ++ ) { if ( ! quote && ( c [ i ] == ',' ) ) { return i ; } else if ( c [ i ] == '\"' ) { quote = ! quote ; } } return c . length ; } private InputStream odsFindContentXML ( InputStream input ) { ZipInputStream zis = new ZipInputStream ( input ) ; ZipEntry entry = null ; try { while ( ( entry = zis . getNextEntry ( ) ) != null ) { if ( entry . getName ( ) . equals ( "content.xml" ) ) { return zis ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; } protected void odsParse ( InputStream input , String worksheet , boolean header ) { try { InputStream contentStream = odsFindContentXML ( input ) ; XML xml = new XML ( contentStream ) ; XML [ ] sheets = xml . getChildren ( "office:body/office:spreadsheet/table:table" ) ; boolean found = false ; for ( XML sheet : sheets ) { if ( worksheet == null || worksheet . equals ( sheet . getString ( "table:name" ) ) ) { odsParseSheet ( sheet , header ) ; found = true ; if ( worksheet == null ) { break ; } } } if ( ! found ) { if ( worksheet == null ) { throw new RuntimeException ( "No worksheets found in the ODS file." ) ; } else { throw new RuntimeException ( "No worksheet named " + worksheet + " found in the ODS file." ) ; } } } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ParserConfigurationException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } } private void odsParseSheet ( XML sheet , boolean header ) { final boolean ignoreTags = true ; XML [ ] rows = sheet . getChildren ( "table:table-row" ) ; int rowIndex = 0 ; for ( XML row : rows ) { int rowRepeat = row . getInt ( "table:number-rows-repeated" , 1 ) ; boolean rowNotNull = false ; XML [ ] cells = row . getChildren ( ) ; int columnIndex = 0 ; for ( XML cell : cells ) { int cellRepeat = cell . getInt ( "table:number-columns-repeated" , 1 ) ; String cellData = ignoreTags ? cell . getString ( "office:value" ) : null ; if ( cellData == null ) { int cellKids = cell . getChildCount ( ) ; if ( cellKids != 0 ) { XML [ ] paragraphElements = cell . getChildren ( "text:p" ) ; if ( paragraphElements . length != 1 ) { for ( XML el : paragraphElements ) { System . err . println ( el . toString ( ) ) ; } throw new RuntimeException ( "found more than one text:p element" ) ; } XML textp = paragraphElements [ 0 ] ; String textpContent = textp . getContent ( ) ; if ( textpContent != null ) { cellData = textpContent ; } else { XML [ ] textpKids = textp . getChildren ( ) ; StringBuilder cellBuffer = new StringBuilder ( ) ; for ( XML kid : textpKids ) { String kidName = kid . getName ( ) ; if ( kidName == null ) { odsAppendNotNull ( kid , cellBuffer ) ; } else if ( kidName . equals ( "text:s" ) ) { int spaceCount = kid . getInt ( "text:c" , 1 ) ; for ( int space = 0 ; space < spaceCount ; space ++ ) { cellBuffer . append ( ' ' ) ; } } else if ( kidName . equals ( "text:span" ) ) { odsAppendNotNull ( kid , cellBuffer ) ; } else if ( kidName . equals ( "text:a" ) ) { if ( ignoreTags ) { cellBuffer . append ( kid . getString ( "xlink:href" ) ) ; } else { odsAppendNotNull ( kid , cellBuffer ) ; } } else { odsAppendNotNull ( kid , cellBuffer ) ; System . err . println ( getClass ( ) . getName ( ) + ": don't understand: " + kid ) ; } } cellData = cellBuffer . toString ( ) ; } } } for ( int r = 0 ; r < cellRepeat ; r ++ ) { if ( cellData != null ) { setString ( rowIndex , columnIndex , cellData ) ; } columnIndex ++ ; if ( cellData != null ) { rowNotNull = true ; } } } if ( header ) { removeTitleRow ( ) ; header = false ; } else { if ( rowNotNull && rowRepeat > 1 ) { String [ ] rowStrings = getStringRow ( rowIndex ) ; for ( int r = 1 ; r < rowRepeat ; r ++ ) { addRow ( rowStrings ) ; } } rowIndex += rowRepeat ; } } } private void odsAppendNotNull ( XML kid , StringBuilder buffer ) { String content = kid . getContent ( ) ; if ( content != null ) { buffer . append ( content ) ; } } public void parseInto ( Object enclosingObject , String fieldName ) { Class < ? > target = null ; Object outgoing = null ; Field targetField = null ; try { Class < ? > sketchClass = enclosingObject . getClass ( ) ; targetField = sketchClass . getDeclaredField ( fieldName ) ; Class < ? > targetArray = targetField . getType ( ) ; if ( ! targetArray . isArray ( ) ) { } else { target = targetArray . getComponentType ( ) ; outgoing = Array . newInstance ( target , getRowCount ( ) ) ; } } catch ( NoSuchFieldException e ) { e . printStackTrace ( ) ; } catch ( SecurityException e ) { e . printStackTrace ( ) ; } Class < ? > enclosingClass = target . getEnclosingClass ( ) ; Constructor < ? > con = null ; try { if ( enclosingClass == null ) { con = target . getDeclaredConstructor ( ) ; } else { con = target . getDeclaredConstructor ( new Class [ ] { enclosingClass } ) ; } if ( ! con . isAccessible ( ) ) { con . setAccessible ( true ) ; } } catch ( SecurityException e ) { e . printStackTrace ( ) ; } catch ( NoSuchMethodException e ) { e . printStackTrace ( ) ; } Field [ ] fields = target . getDeclaredFields ( ) ; ArrayList < Field > inuse = new ArrayList < Field > ( ) ; for ( Field field : fields ) { String name = field . getName ( ) ; if ( getColumnIndex ( name , false ) != - 1 ) { if ( ! field . isAccessible ( ) ) { field . setAccessible ( true ) ; } inuse . add ( field ) ; } else { } } int index = 0 ; try { for ( TableRow row : rows ( ) ) { Object item = null ; if ( enclosingClass == null ) { item = con . newInstance ( ) ; } else { item = con . newInstance ( new Object [ ] { enclosingObject } ) ; } for ( Field field : inuse ) { String name = field . getName ( ) ; if ( field . getType ( ) == String . class ) { field . set ( item , row . getString ( name ) ) ; } else if ( field . getType ( ) == Integer . TYPE ) { field . setInt ( item , row . getInt ( name ) ) ; } else if ( field . getType ( ) == Long . TYPE ) { field . setLong ( item , row . getLong ( name ) ) ; } else if ( field . getType ( ) == Float . TYPE ) { field . setFloat ( item , row . getFloat ( name ) ) ; } else if ( field . getType ( ) == Double . TYPE ) { field . setDouble ( item , row . getDouble ( name ) ) ; } else if ( field . getType ( ) == Boolean . TYPE ) { String content = row . getString ( name ) ; if ( content != null ) { if ( content . toLowerCase ( ) . equals ( "true" ) || content . equals ( "1" ) ) { field . setBoolean ( item , true ) ; } } } else if ( field . getType ( ) == Character . TYPE ) { String content = row . getString ( name ) ; if ( content != null && content . length ( ) > 0 ) { field . setChar ( item , content . charAt ( 0 ) ) ; } } } Array . set ( outgoing , index ++ , item ) ; } if ( ! targetField . isAccessible ( ) ) { targetField . setAccessible ( true ) ; } targetField . set ( enclosingObject , outgoing ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } public boolean save ( File file , String options ) throws IOException { return save ( PApplet . createOutput ( file ) , Table . extensionOptions ( false , file . getName ( ) , options ) ) ; } public boolean save ( OutputStream output , String options ) { PrintWriter writer = PApplet . createWriter ( output ) ; String extension = null ; if ( options == null ) { throw new IllegalArgumentException ( "No extension specified for saving this Table" ) ; } String [ ] opts = PApplet . trim ( PApplet . split ( options , ',' ) ) ; extension = opts [ opts . length - 1 ] ; boolean found = false ; for ( String ext : saveExtensions ) { if ( extension . equals ( ext ) ) { found = true ; break ; } } if ( ! found ) { throw new IllegalArgumentException ( "'" + extension + "' not available for Table" ) ; } if ( extension . equals ( "csv" ) ) { writeCSV ( writer ) ; } else if ( extension . equals ( "tsv" ) ) { writeTSV ( writer ) ; } else if ( extension . equals ( "ods" ) ) { try { saveODS ( output ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return false ; } } else if ( extension . equals ( "html" ) ) { writeHTML ( writer ) ; } else if ( extension . equals ( "bin" ) ) { try { saveBinary ( output ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return false ; } } writer . flush ( ) ; writer . close ( ) ; return true ; } protected void writeTSV ( PrintWriter writer ) { if ( columnTitles != null ) { for ( int col = 0 ; col < columns . length ; col ++ ) { if ( col != 0 ) { writer . print ( '\t' ) ; } if ( columnTitles [ col ] != null ) { writer . print ( columnTitles [ col ] ) ; } } writer . println ( ) ; } for ( int row = 0 ; row < rowCount ; row ++ ) { for ( int col = 0 ; col < getColumnCount ( ) ; col ++ ) { if ( col != 0 ) { writer . print ( '\t' ) ; } String entry = getString ( row , col ) ; if ( entry != null ) { writer . print ( entry ) ; } } writer . println ( ) ; } writer . flush ( ) ; } protected void writeCSV ( PrintWriter writer ) { if ( columnTitles != null ) { for ( int col = 0 ; col < getColumnCount ( ) ; col ++ ) { if ( col != 0 ) { writer . print ( ',' ) ; } try { if ( columnTitles [ col ] != null ) { writeEntryCSV ( writer , columnTitles [ col ] ) ; } } catch ( ArrayIndexOutOfBoundsException e ) { PApplet . printArray ( columnTitles ) ; PApplet . printArray ( columns ) ; throw e ; } } writer . println ( ) ; } for ( int row = 0 ; row < rowCount ; row ++ ) { for ( int col = 0 ; col < getColumnCount ( ) ; col ++ ) { if ( col != 0 ) { writer . print ( ',' ) ; } String entry = getString ( row , col ) ; if ( entry != null ) { writeEntryCSV ( writer , entry ) ; } } writer . println ( ) ; } writer . flush ( ) ; } protected void writeEntryCSV ( PrintWriter writer , String entry ) { if ( entry != null ) { if ( entry . indexOf ( '\"' ) != - 1 ) { char [ ] c = entry . toCharArray ( ) ; writer . print ( '\"' ) ; for ( int i = 0 ; i < c . length ; i ++ ) { if ( c [ i ] == '\"' ) { writer . print ( "\"\"" ) ; } else { writer . print ( c [ i ] ) ; } } writer . print ( '\"' ) ; } else if ( entry . indexOf ( ',' ) != - 1 || entry . indexOf ( '\n' ) != - 1 || entry . indexOf ( '\r' ) != - 1 ) { writer . print ( '\"' ) ; writer . print ( entry ) ; writer . print ( '\"' ) ; } else if ( ( entry . length ( ) > 0 ) && ( entry . charAt ( 0 ) == ' ' || entry . charAt ( entry . length ( ) - 1 ) == ' ' ) ) { writer . print ( '\"' ) ; writer . print ( entry ) ; writer . print ( '\"' ) ; } else { writer . print ( entry ) ; } } } protected void writeHTML ( PrintWriter writer ) { writer . println ( "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 3.2//EN\">" ) ; writer . println ( "<html>" ) ; writer . println ( "<head>" ) ; writer . println ( " <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\" />" ) ; writer . println ( "</head>" ) ; writer . println ( "<body>" ) ; writer . println ( " <table>" ) ; if ( hasColumnTitles ( ) ) { writer . println ( " <tr>" ) ; for ( String entry : getColumnTitles ( ) ) { writer . print ( " <th>" ) ; if ( entry != null ) { writeEntryHTML ( writer , entry ) ; } writer . println ( "</th>" ) ; } writer . println ( " </tr>" ) ; } for ( int row = 0 ; row < getRowCount ( ) ; row ++ ) { writer . println ( " <tr>" ) ; for ( int col = 0 ; col < getColumnCount ( ) ; col ++ ) { String entry = getString ( row , col ) ; writer . print ( " <td>" ) ; if ( entry != null ) { writeEntryHTML ( writer , entry ) ; } writer . println ( "</td>" ) ; } writer . println ( " </tr>" ) ; } writer . println ( " </table>" ) ; writer . println ( "</body>" ) ; writer . println ( "</html>" ) ; writer . flush ( ) ; } protected void writeEntryHTML ( PrintWriter writer , String entry ) { for ( char c : entry . toCharArray ( ) ) { if ( c == '<' ) { writer . print ( "&lt;" ) ; } else if ( c == '>' ) { writer . print ( "&gt;" ) ; } else if ( c == '&' ) { writer . print ( "&amp;" ) ; } else if ( c == '"' ) { writer . print ( "&quot;" ) ; } else if ( c < 32 || c > 127 ) { writer . print ( "&#" ) ; writer . print ( ( int ) c ) ; writer . print ( ';' ) ; } else { writer . print ( c ) ; } } } protected void saveODS ( OutputStream os ) throws IOException { ZipOutputStream zos = new ZipOutputStream ( os ) ; final String xmlHeader = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ; ZipEntry entry = new ZipEntry ( "META-INF/manifest.xml" ) ; String [ ] lines = new String [ ] { xmlHeader , "<manifest:manifest xmlns:manifest=\"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\">" , " <manifest:file-entry manifest:media-type=\"application/vnd.oasis.opendocument.spreadsheet\" manifest:version=\"1.2\" manifest:full-path=\"/\"/>" , " <manifest:file-entry manifest:media-type=\"text/xml\" manifest:full-path=\"content.xml\"/>" , " <manifest:file-entry manifest:media-type=\"text/xml\" manifest:full-path=\"styles.xml\"/>" , " <manifest:file-entry manifest:media-type=\"text/xml\" manifest:full-path=\"meta.xml\"/>" , " <manifest:file-entry manifest:media-type=\"text/xml\" manifest:full-path=\"settings.xml\"/>" , "</manifest:manifest>" } ; zos . putNextEntry ( entry ) ; zos . write ( PApplet . join ( lines , "\n" ) . getBytes ( ) ) ; zos . closeEntry ( ) ; final String [ ] dummyFiles = new String [ ] { "meta.xml" , "settings.xml" , "styles.xml" } ; lines = new String [ ] { xmlHeader , "<office:document-meta office:version=\"1.0\"" + " xmlns:office=\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" />" } ; byte [ ] dummyBytes = PApplet . join ( lines , "\n" ) . getBytes ( ) ; for ( String filename : dummyFiles ) { entry = new ZipEntry ( filename ) ; zos . putNextEntry ( entry ) ; zos . write ( dummyBytes ) ; zos . closeEntry ( ) ; } entry = new ZipEntry ( "mimetype" ) ; zos . putNextEntry ( entry ) ; zos . write ( "application/vnd.oasis.opendocument.spreadsheet" . getBytes ( ) ) ; zos . closeEntry ( ) ; entry = new ZipEntry ( "content.xml" ) ; zos . putNextEntry ( entry ) ; writeUTF ( zos , new String [ ] { xmlHeader , "<office:document-content" + " xmlns:office=\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\"" + " xmlns:text=\"urn:oasis:names:tc:opendocument:xmlns:text:1.0\"" + " xmlns:table=\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\"" + " office:version=\"1.2\">" , " <office:body>" , " <office:spreadsheet>" , " <table:table table:name=\"Sheet1\" table:print=\"false\">" } ) ; byte [ ] rowStart = " <table:table-row>\n" . getBytes ( ) ; byte [ ] rowStop = " </table:table-row>\n" . getBytes ( ) ; if ( hasColumnTitles ( ) ) { zos . write ( rowStart ) ; for ( int i = 0 ; i < getColumnCount ( ) ; i ++ ) { saveStringODS ( zos , columnTitles [ i ] ) ; } zos . write ( rowStop ) ; } for ( TableRow row : rows ( ) ) { zos . write ( rowStart ) ; for ( int i = 0 ; i < getColumnCount ( ) ; i ++ ) { if ( columnTypes [ i ] == STRING || columnTypes [ i ] == CATEGORY ) { saveStringODS ( zos , row . getString ( i ) ) ; } else { saveNumberODS ( zos , row . getString ( i ) ) ; } } zos . write ( rowStop ) ; } writeUTF ( zos , new String [ ] { " </table:table>" , " </office:spreadsheet>" , " </office:body>" , "</office:document-content>" } ) ; zos . closeEntry ( ) ; zos . flush ( ) ; zos . close ( ) ; } void saveStringODS ( OutputStream output , String text ) throws IOException { StringBuilder sanitized = new StringBuilder ( ) ; if ( text != null ) { char [ ] array = text . toCharArray ( ) ; for ( char c : array ) { if ( c == '&' ) { sanitized . append ( "&amp;" ) ; } else if ( c == '\'' ) { sanitized . append ( "&apos;" ) ; } else if ( c == '"' ) { sanitized . append ( "&quot;" ) ; } else if ( c == '<' ) { sanitized . append ( "&lt;" ) ; } else if ( c == '>' ) { sanitized . append ( "&rt;" ) ; } else if ( c < 32 || c > 127 ) { sanitized . append ( "&#" + ( ( int ) c ) + ";" ) ; } else { sanitized . append ( c ) ; } } } writeUTF ( output , " <table:table-cell office:value-type=\"string\">" , " <text:p>" + sanitized + "</text:p>" , " </table:table-cell>" ) ; } void saveNumberODS ( OutputStream output , String text ) throws IOException { writeUTF ( output , " <table:table-cell office:value-type=\"float\" office:value=\"" + text + "\">" , " <text:p>" + text + "</text:p>" , " </table:table-cell>" ) ; } static Charset utf8 ; static void writeUTF ( OutputStream output , String ... lines ) throws IOException { if ( utf8 == null ) { utf8 = Charset . forName ( "UTF-8" ) ; } for ( String str : lines ) { output . write ( str . getBytes ( utf8 ) ) ; output . write ( '\n' ) ; } } protected void saveBinary ( OutputStream os ) throws IOException { DataOutputStream output = new DataOutputStream ( new BufferedOutputStream ( os ) ) ; output . writeInt ( 0x9007AB1E ) ; output . writeInt ( getRowCount ( ) ) ; output . writeInt ( getColumnCount ( ) ) ; if ( columnTitles != null ) { output . writeBoolean ( true ) ; for ( String title : columnTitles ) { output . writeUTF ( title ) ; } } else { output . writeBoolean ( false ) ; } for ( int i = 0 ; i < getColumnCount ( ) ; i ++ ) { output . writeInt ( columnTypes [ i ] ) ; } for ( int i = 0 ; i < getColumnCount ( ) ; i ++ ) { if ( columnTypes [ i ] == CATEGORY ) { columnCategories [ i ] . write ( output ) ; } } if ( missingString == null ) { output . writeBoolean ( false ) ; } else { output . writeBoolean ( true ) ; output . writeUTF ( missingString ) ; } output . writeInt ( missingInt ) ; output . writeLong ( missingLong ) ; output . writeFloat ( missingFloat ) ; output . writeDouble ( missingDouble ) ; output . writeInt ( missingCategory ) ; for ( TableRow row : rows ( ) ) { for ( int col = 0 ; col < getColumnCount ( ) ; col ++ ) { switch ( columnTypes [ col ] ) { case STRING : String str = row . getString ( col ) ; if ( str == null ) { output . writeBoolean ( false ) ; } else { output . writeBoolean ( true ) ; output . writeUTF ( str ) ; } break ; case INT : output . writeInt ( row . getInt ( col ) ) ; break ; case LONG : output . writeLong ( row . getLong ( col ) ) ; break ; case FLOAT : output . writeFloat ( row . getFloat ( col ) ) ; break ; case DOUBLE : output . writeDouble ( row . getDouble ( col ) ) ; break ; case CATEGORY : String peace = row . getString ( col ) ; if ( peace . equals ( missingString ) ) { output . writeInt ( missingCategory ) ; } else { output . writeInt ( columnCategories [ col ] . index ( peace ) ) ; } break ; } } } output . flush ( ) ; output . close ( ) ; } protected void loadBinary ( InputStream is ) throws IOException { DataInputStream input = new DataInputStream ( new BufferedInputStream ( is ) ) ; int magic = input . readInt ( ) ; if ( magic != 0x9007AB1E ) { throw new IOException ( "Not a compatible binary table (magic was " + PApplet . hex ( magic ) + ")" ) ; } int rowCount = input . readInt ( ) ; setRowCount ( rowCount ) ; int columnCount = input . readInt ( ) ; setColumnCount ( columnCount ) ; boolean hasTitles = input . readBoolean ( ) ; if ( hasTitles ) { columnTitles = new String [ getColumnCount ( ) ] ; for ( int i = 0 ; i < columnCount ; i ++ ) { setColumnTitle ( i , input . readUTF ( ) ) ; } } for ( int column = 0 ; column < columnCount ; column ++ ) { int newType = input . readInt ( ) ; columnTypes [ column ] = newType ; switch ( newType ) { case INT : columns [ column ] = new int [ rowCount ] ; break ; case LONG : columns [ column ] = new long [ rowCount ] ; ; break ; case FLOAT : columns [ column ] = new float [ rowCount ] ; ; break ; case DOUBLE : columns [ column ] = new double [ rowCount ] ; ; break ; case STRING : columns [ column ] = new String [ rowCount ] ; ; break ; case CATEGORY : columns [ column ] = new int [ rowCount ] ; ; break ; default : throw new IllegalArgumentException ( newType + " is not a valid column type." ) ; } } for ( int i = 0 ; i < columnCount ; i ++ ) { if ( columnTypes [ i ] == CATEGORY ) { columnCategories [ i ] = new HashMapBlows ( input ) ; } } if ( input . readBoolean ( ) ) { missingString = input . readUTF ( ) ; } else { missingString = null ; } missingInt = input . readInt ( ) ; missingLong = input . readLong ( ) ; missingFloat = input . readFloat ( ) ; missingDouble = input . readDouble ( ) ; missingCategory = input . readInt ( ) ; for ( int row = 0 ; row < rowCount ; row ++ ) { for ( int col = 0 ; col < columnCount ; col ++ ) { switch ( columnTypes [ col ] ) { case STRING : String str = null ; if ( input . readBoolean ( ) ) { str = input . readUTF ( ) ; } setString ( row , col , str ) ; break ; case INT : setInt ( row , col , input . readInt ( ) ) ; break ; case LONG : setLong ( row , col , input . readLong ( ) ) ; break ; case FLOAT : setFloat ( row , col , input . readFloat ( ) ) ; break ; case DOUBLE : setDouble ( row , col , input . readDouble ( ) ) ; break ; case CATEGORY : int index = input . readInt ( ) ; setInt ( row , col , index ) ; break ; } } } input . close ( ) ; } public void addColumn ( ) { addColumn ( null , STRING ) ; } public void addColumn ( String title ) { addColumn ( title , STRING ) ; } public void addColumn ( String title , int type ) { insertColumn ( columns . length , title , type ) ; } public void insertColumn ( int index ) { insertColumn ( index , null , STRING ) ; } public void insertColumn ( int index , String title ) { insertColumn ( index , title , STRING ) ; } public void insertColumn ( int index , String title , int type ) { if ( title != null && columnTitles == null ) { columnTitles = new String [ columns . length ] ; } if ( columnTitles != null ) { columnTitles = PApplet . splice ( columnTitles , title , index ) ; columnIndices = null ; } columnTypes = PApplet . splice ( columnTypes , type , index ) ; HashMapBlows [ ] catTemp = new HashMapBlows [ columns . length + 1 ] ; for ( int i = 0 ; i < index ; i ++ ) { catTemp [ i ] = columnCategories [ i ] ; } catTemp [ index ] = new HashMapBlows ( ) ; for ( int i = index ; i < columns . length ; i ++ ) { catTemp [ i + 1 ] = columnCategories [ i ] ; } columnCategories = catTemp ; Object [ ] temp = new Object [ columns . length + 1 ] ; System . arraycopy ( columns , 0 , temp , 0 , index ) ; System . arraycopy ( columns , index , temp , index + 1 , columns . length - index ) ; columns = temp ; switch ( type ) { case INT : columns [ index ] = new int [ rowCount ] ; break ; case LONG : columns [ index ] = new long [ rowCount ] ; break ; case FLOAT : columns [ index ] = new float [ rowCount ] ; break ; case DOUBLE : columns [ index ] = new double [ rowCount ] ; break ; case STRING : columns [ index ] = new String [ rowCount ] ; break ; case CATEGORY : columns [ index ] = new int [ rowCount ] ; break ; } } public void removeColumn ( String columnName ) { removeColumn ( getColumnIndex ( columnName ) ) ; } public void removeColumn ( int column ) { int newCount = columns . length - 1 ; Object [ ] columnsTemp = new Object [ newCount ] ; HashMapBlows [ ] catTemp = new HashMapBlows [ newCount ] ; for ( int i = 0 ; i < column ; i ++ ) { columnsTemp [ i ] = columns [ i ] ; catTemp [ i ] = columnCategories [ i ] ; } for ( int i = column ; i < newCount ; i ++ ) { columnsTemp [ i ] = columns [ i + 1 ] ; catTemp [ i ] = columnCategories [ i + 1 ] ; } columns = columnsTemp ; columnCategories = catTemp ; if ( columnTitles != null ) { String [ ] titlesTemp = new String [ newCount ] ; for ( int i = 0 ; i < column ; i ++ ) { titlesTemp [ i ] = columnTitles [ i ] ; } for ( int i = column ; i < newCount ; i ++ ) { titlesTemp [ i ] = columnTitles [ i + 1 ] ; } columnTitles = titlesTemp ; columnIndices = null ; } } public int getColumnCount ( ) { return columns . length ; } public void setColumnCount ( int newCount ) { int oldCount = columns . length ; if ( oldCount != newCount ) { columns = ( Object [ ] ) PApplet . expand ( columns , newCount ) ; for ( int c = oldCount ; c < newCount ; c ++ ) { columns [ c ] = new String [ rowCount ] ; } if ( columnTitles != null ) { columnTitles = PApplet . expand ( columnTitles , newCount ) ; } columnTypes = PApplet . expand ( columnTypes , newCount ) ; columnCategories = ( HashMapBlows [ ] ) PApplet . expand ( columnCategories , newCount ) ; } } public void setColumnType ( String columnName , String columnType ) { setColumnType ( checkColumnIndex ( columnName ) , columnType ) ; } public void setColumnType ( int column , String columnType ) { columnType = columnType . toLowerCase ( ) ; int type = - 1 ; if ( columnType . equals ( "string" ) ) { type = STRING ; } else if ( columnType . equals ( "int" ) ) { type = INT ; } else if ( columnType . equals ( "long" ) ) { type = LONG ; } else if ( columnType . equals ( "float" ) ) { type = FLOAT ; } else if ( columnType . equals ( "double" ) ) { type = DOUBLE ; } else if ( columnType . equals ( "category" ) ) { type = CATEGORY ; } else { throw new IllegalArgumentException ( "'" + columnType + "' is not a valid column type." ) ; } setColumnType ( column , type ) ; } public void setColumnType ( String columnName , int newType ) { setColumnType ( checkColumnIndex ( columnName ) , newType ) ; } public void setColumnType ( int column , int newType ) { switch ( newType ) { case INT : { int [ ] intData = new int [ rowCount ] ; for ( int row = 0 ; row < rowCount ; row ++ ) { String s = getString ( row , column ) ; intData [ row ] = ( s == null ) ? missingInt : PApplet . parseInt ( s , missingInt ) ; } columns [ column ] = intData ; break ; } case LONG : { long [ ] longData = new long [ rowCount ] ; for ( int row = 0 ; row < rowCount ; row ++ ) { String s = getString ( row , column ) ; try { longData [ row ] = ( s == null ) ? missingLong : Long . parseLong ( s ) ; } catch ( NumberFormatException nfe ) { longData [ row ] = missingLong ; } } columns [ column ] = longData ; break ; } case FLOAT : { float [ ] floatData = new float [ rowCount ] ; for ( int row = 0 ; row < rowCount ; row ++ ) { String s = getString ( row , column ) ; floatData [ row ] = ( s == null ) ? missingFloat : PApplet . parseFloat ( s , missingFloat ) ; } columns [ column ] = floatData ; break ; } case DOUBLE : { double [ ] doubleData = new double [ rowCount ] ; for ( int row = 0 ; row < rowCount ; row ++ ) { String s = getString ( row , column ) ; try { doubleData [ row ] = ( s == null ) ? missingDouble : Double . parseDouble ( s ) ; } catch ( NumberFormatException nfe ) { doubleData [ row ] = missingDouble ; } } columns [ column ] = doubleData ; break ; } case STRING : { if ( columnTypes [ column ] != STRING ) { String [ ] stringData = new String [ rowCount ] ; for ( int row = 0 ; row < rowCount ; row ++ ) { stringData [ row ] = getString ( row , column ) ; } columns [ column ] = stringData ; } break ; } case CATEGORY : { int [ ] indexData = new int [ rowCount ] ; HashMapBlows categories = new HashMapBlows ( ) ; for ( int row = 0 ; row < rowCount ; row ++ ) { String s = getString ( row , column ) ; indexData [ row ] = categories . index ( s ) ; } columnCategories [ column ] = categories ; columns [ column ] = indexData ; break ; } default : { throw new IllegalArgumentException ( "That's not a valid column type." ) ; } } columnTypes [ column ] = newType ; } public void setTableType ( String type ) { for ( int col = 0 ; col < getColumnCount ( ) ; col ++ ) { setColumnType ( col , type ) ; } } public void setColumnTypes ( int [ ] types ) { ensureColumn ( types . length - 1 ) ; for ( int col = 0 ; col < types . length ; col ++ ) { setColumnType ( col , types [ col ] ) ; } } public void setColumnTypes ( final Table dictionary ) { ensureColumn ( dictionary . getRowCount ( ) - 1 ) ; int titleCol = 0 ; int typeCol = 1 ; if ( dictionary . hasColumnTitles ( ) ) { titleCol = dictionary . getColumnIndex ( "title" , true ) ; typeCol = dictionary . getColumnIndex ( "type" , true ) ; } setColumnTitles ( dictionary . getStringColumn ( titleCol ) ) ; final String [ ] typeNames = dictionary . getStringColumn ( typeCol ) ; if ( dictionary . getColumnCount ( ) > 1 ) { if ( getRowCount ( ) > 1000 ) { int proc = Runtime . getRuntime ( ) . availableProcessors ( ) ; ExecutorService pool = Executors . newFixedThreadPool ( proc / 2 ) ; for ( int i = 0 ; i < dictionary . getRowCount ( ) ; i ++ ) { final int col = i ; pool . execute ( new Runnable ( ) { public void run ( ) { setColumnType ( col , typeNames [ col ] ) ; } } ) ; } pool . shutdown ( ) ; while ( ! pool . isTerminated ( ) ) { Thread . yield ( ) ; } } else { for ( int col = 0 ; col < dictionary . getRowCount ( ) ; col ++ ) { setColumnType ( col , typeNames [ col ] ) ; } } } } public int getColumnType ( String columnName ) { return getColumnType ( getColumnIndex ( columnName ) ) ; } public int getColumnType ( int column ) { return columnTypes [ column ] ; } public int [ ] getColumnTypes ( ) { return columnTypes ; } @ Deprecated public String [ ] removeTitleRow ( ) { String [ ] titles = getStringRow ( 0 ) ; removeRow ( 0 ) ; setColumnTitles ( titles ) ; return titles ; } public void setColumnTitles ( String [ ] titles ) { if ( titles != null ) { ensureColumn ( titles . length - 1 ) ; } columnTitles = titles ; columnIndices = null ; } public void setColumnTitle ( int column , String title ) { ensureColumn ( column ) ; if ( columnTitles == null ) { columnTitles = new String [ getColumnCount ( ) ] ; } columnTitles [ column ] = title ; columnIndices = null ; } public boolean hasColumnTitles ( ) { return columnTitles != null ; } public String [ ] getColumnTitles ( ) { return columnTitles ; } public String getColumnTitle ( int col ) { return ( columnTitles == null ) ? null : columnTitles [ col ] ; } public int getColumnIndex ( String columnName ) { return getColumnIndex ( columnName , true ) ; } protected int getColumnIndex ( String name , boolean report ) { if ( columnTitles == null ) { if ( report ) { throw new IllegalArgumentException ( "This table has no header, so no column titles are set." ) ; } return - 1 ; } if ( columnIndices == null ) { columnIndices = new HashMap < String , Integer > ( ) ; for ( int col = 0 ; col < columns . length ; col ++ ) { columnIndices . put ( columnTitles [ col ] , col ) ; } } Integer index = columnIndices . get ( name ) ; if ( index == null ) { if ( report ) { throw new IllegalArgumentException ( "This table has no column named '" + name + "'" ) ; } return - 1 ; } return index . intValue ( ) ; } public int checkColumnIndex ( String title ) { int index = getColumnIndex ( title , false ) ; if ( index != - 1 ) { return index ; } addColumn ( title ) ; return getColumnCount ( ) - 1 ; } public int getRowCount ( ) { return rowCount ; } public int lastRowIndex ( ) { return getRowCount ( ) - 1 ; } public void clearRows ( ) { setRowCount ( 0 ) ; } public void setRowCount ( int newCount ) { if ( newCount != rowCount ) { if ( newCount > 1000000 ) { System . out . print ( "Note: setting maximum row count to " + PApplet . nfc ( newCount ) ) ; } long t = System . currentTimeMillis ( ) ; for ( int col = 0 ; col < columns . length ; col ++ ) { switch ( columnTypes [ col ] ) { case INT : columns [ col ] = PApplet . expand ( ( int [ ] ) columns [ col ] , newCount ) ; break ; case LONG : columns [ col ] = PApplet . expand ( ( long [ ] ) columns [ col ] , newCount ) ; break ; case FLOAT : columns [ col ] = PApplet . expand ( ( float [ ] ) columns [ col ] , newCount ) ; break ; case DOUBLE : columns [ col ] = PApplet . expand ( ( double [ ] ) columns [ col ] , newCount ) ; break ; case STRING : columns [ col ] = PApplet . expand ( ( String [ ] ) columns [ col ] , newCount ) ; break ; case CATEGORY : columns [ col ] = PApplet . expand ( ( int [ ] ) columns [ col ] , newCount ) ; break ; } if ( newCount > 1000000 ) { try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } if ( newCount > 1000000 ) { int ms = ( int ) ( System . currentTimeMillis ( ) - t ) ; System . out . println ( " (resize took " + PApplet . nfc ( ms ) + " ms)" ) ; } } rowCount = newCount ; } public TableRow addRow ( ) { setRowCount ( rowCount + 1 ) ; return new RowPointer ( this , rowCount - 1 ) ; } public TableRow addRow ( TableRow source ) { return setRow ( rowCount , source ) ; } public TableRow setRow ( int row , TableRow source ) { ensureBounds ( row , source . getColumnCount ( ) - 1 ) ; for ( int col = 0 ; col < Math . min ( source . getColumnCount ( ) , columns . length ) ; col ++ ) { switch ( columnTypes [ col ] ) { case INT : setInt ( row , col , source . getInt ( col ) ) ; break ; case LONG : setLong ( row , col , source . getLong ( col ) ) ; break ; case FLOAT : setFloat ( row , col , source . getFloat ( col ) ) ; break ; case DOUBLE : setDouble ( row , col , source . getDouble ( col ) ) ; break ; case STRING : setString ( row , col , source . getString ( col ) ) ; break ; case CATEGORY : int index = source . getInt ( col ) ; setInt ( row , col , index ) ; if ( ! columnCategories [ col ] . hasCategory ( index ) ) { columnCategories [ col ] . setCategory ( index , source . getString ( col ) ) ; } break ; default : throw new RuntimeException ( "no types" ) ; } } return new RowPointer ( this , row ) ; } public TableRow addRow ( Object [ ] columnData ) { setRow ( getRowCount ( ) , columnData ) ; return new RowPointer ( this , rowCount - 1 ) ; } public void addRows ( Table source ) { int index = getRowCount ( ) ; setRowCount ( index + source . getRowCount ( ) ) ; for ( TableRow row : source . rows ( ) ) { setRow ( index ++ , row ) ; } } public void insertRow ( int insert , Object [ ] columnData ) { for ( int col = 0 ; col < columns . length ; col ++ ) { switch ( columnTypes [ col ] ) { case CATEGORY : case INT : { int [ ] intTemp = new int [ rowCount + 1 ] ; System . arraycopy ( columns [ col ] , 0 , intTemp , 0 , insert ) ; System . arraycopy ( columns [ col ] , insert , intTemp , insert + 1 , rowCount - insert ) ; columns [ col ] = intTemp ; break ; } case LONG : { long [ ] longTemp = new long [ rowCount + 1 ] ; System . arraycopy ( columns [ col ] , 0 , longTemp , 0 , insert ) ; System . arraycopy ( columns [ col ] , insert , longTemp , insert + 1 , rowCount - insert ) ; columns [ col ] = longTemp ; break ; } case FLOAT : { float [ ] floatTemp = new float [ rowCount + 1 ] ; System . arraycopy ( columns [ col ] , 0 , floatTemp , 0 , insert ) ; System . arraycopy ( columns [ col ] , insert , floatTemp , insert + 1 , rowCount - insert ) ; columns [ col ] = floatTemp ; break ; } case DOUBLE : { double [ ] doubleTemp = new double [ rowCount + 1 ] ; System . arraycopy ( columns [ col ] , 0 , doubleTemp , 0 , insert ) ; System . arraycopy ( columns [ col ] , insert , doubleTemp , insert + 1 , rowCount - insert ) ; columns [ col ] = doubleTemp ; break ; } case STRING : { String [ ] stringTemp = new String [ rowCount + 1 ] ; System . arraycopy ( columns [ col ] , 0 , stringTemp , 0 , insert ) ; System . arraycopy ( columns [ col ] , insert , stringTemp , insert + 1 , rowCount - insert ) ; columns [ col ] = stringTemp ; break ; } } } setRow ( insert , columnData ) ; rowCount ++ ; } public void removeRow ( int row ) { for ( int col = 0 ; col < columns . length ; col ++ ) { switch ( columnTypes [ col ] ) { case CATEGORY : case INT : { int [ ] intTemp = new int [ rowCount - 1 ] ; System . arraycopy ( columns [ col ] , 0 , intTemp , 0 , row ) ; System . arraycopy ( columns [ col ] , row + 1 , intTemp , row , ( rowCount - row ) - 1 ) ; columns [ col ] = intTemp ; break ; } case LONG : { long [ ] longTemp = new long [ rowCount - 1 ] ; System . arraycopy ( columns [ col ] , 0 , longTemp , 0 , row ) ; System . arraycopy ( columns [ col ] , row + 1 , longTemp , row , ( rowCount - row ) - 1 ) ; columns [ col ] = longTemp ; break ; } case FLOAT : { float [ ] floatTemp = new float [ rowCount - 1 ] ; System . arraycopy ( columns [ col ] , 0 , floatTemp , 0 , row ) ; System . arraycopy ( columns [ col ] , row + 1 , floatTemp , row , ( rowCount - row ) - 1 ) ; columns [ col ] = floatTemp ; break ; } case DOUBLE : { double [ ] doubleTemp = new double [ rowCount - 1 ] ; System . arraycopy ( columns [ col ] , 0 , doubleTemp , 0 , row ) ; System . arraycopy ( columns [ col ] , row + 1 , doubleTemp , row , ( rowCount - row ) - 1 ) ; columns [ col ] = doubleTemp ; break ; } case STRING : { String [ ] stringTemp = new String [ rowCount - 1 ] ; System . arraycopy ( columns [ col ] , 0 , stringTemp , 0 , row ) ; System . arraycopy ( columns [ col ] , row + 1 , stringTemp , row , ( rowCount - row ) - 1 ) ; columns [ col ] = stringTemp ; } } } rowCount -- ; } public void setRow ( int row , Object [ ] pieces ) { ensureBounds ( row , pieces . length - 1 ) ; for ( int col = 0 ; col < pieces . length ; col ++ ) { setRowCol ( row , col , pieces [ col ] ) ; } } protected void setRowCol ( int row , int col , Object piece ) { switch ( columnTypes [ col ] ) { case STRING : String [ ] stringData = ( String [ ] ) columns [ col ] ; if ( piece == null ) { stringData [ row ] = null ; } else { stringData [ row ] = String . valueOf ( piece ) ; } break ; case INT : int [ ] intData = ( int [ ] ) columns [ col ] ; if ( piece == null ) { intData [ row ] = missingInt ; } else if ( piece instanceof Integer ) { intData [ row ] = ( Integer ) piece ; } else { intData [ row ] = PApplet . parseInt ( String . valueOf ( piece ) , missingInt ) ; } break ; case LONG : long [ ] longData = ( long [ ] ) columns [ col ] ; if ( piece == null ) { longData [ row ] = missingLong ; } else if ( piece instanceof Long ) { longData [ row ] = ( Long ) piece ; } else { try { longData [ row ] = Long . parseLong ( String . valueOf ( piece ) ) ; } catch ( NumberFormatException nfe ) { longData [ row ] = missingLong ; } } break ; case FLOAT : float [ ] floatData = ( float [ ] ) columns [ col ] ; if ( piece == null ) { floatData [ row ] = missingFloat ; } else if ( piece instanceof Float ) { floatData [ row ] = ( Float ) piece ; } else { floatData [ row ] = PApplet . parseFloat ( String . valueOf ( piece ) , missingFloat ) ; } break ; case DOUBLE : double [ ] doubleData = ( double [ ] ) columns [ col ] ; if ( piece == null ) { doubleData [ row ] = missingDouble ; } else if ( piece instanceof Double ) { doubleData [ row ] = ( Double ) piece ; } else { try { doubleData [ row ] = Double . parseDouble ( String . valueOf ( piece ) ) ; } catch ( NumberFormatException nfe ) { doubleData [ row ] = missingDouble ; } } break ; case CATEGORY : int [ ] indexData = ( int [ ] ) columns [ col ] ; if ( piece == null ) { indexData [ row ] = missingCategory ; } else { String peace = String . valueOf ( piece ) ; if ( peace . equals ( missingString ) ) { indexData [ row ] = missingCategory ; } else { indexData [ row ] = columnCategories [ col ] . index ( peace ) ; } } break ; default : throw new IllegalArgumentException ( "That's not a valid column type." ) ; } } public TableRow getRow ( int row ) { return new RowPointer ( this , row ) ; } public Iterable < TableRow > rows ( ) { return new Iterable < TableRow > ( ) { public Iterator < TableRow > iterator ( ) { if ( rowIterator == null ) { rowIterator = new RowIterator ( Table . this ) ; } else { rowIterator . reset ( ) ; } return rowIterator ; } } ; } public Iterable < TableRow > rows ( final int [ ] indices ) { return new Iterable < TableRow > ( ) { public Iterator < TableRow > iterator ( ) { return new RowIndexIterator ( Table . this , indices ) ; } } ; } static class RowPointer implements TableRow { Table table ; int row ; public RowPointer ( Table table , int row ) { this . table = table ; this . row = row ; } public void setRow ( int row ) { this . row = row ; } public String getString ( int column ) { return table . getString ( row , column ) ; } public String getString ( String columnName ) { return table . getString ( row , columnName ) ; } public int getInt ( int column ) { return table . getInt ( row , column ) ; } public int getInt ( String columnName ) { return table . getInt ( row , columnName ) ; } public long getLong ( int column ) { return table . getLong ( row , column ) ; } public long getLong ( String columnName ) { return table . getLong ( row , columnName ) ; } public float getFloat ( int column ) { return table . getFloat ( row , column ) ; } public float getFloat ( String columnName ) { return table . getFloat ( row , columnName ) ; } public double getDouble ( int column ) { return table . getDouble ( row , column ) ; } public double getDouble ( String columnName ) { return table . getDouble ( row , columnName ) ; } public void setString ( int column , String value ) { table . setString ( row , column , value ) ; } public void setString ( String columnName , String value ) { table . setString ( row , columnName , value ) ; } public void setInt ( int column , int value ) { table . setInt ( row , column , value ) ; } public void setInt ( String columnName , int value ) { table . setInt ( row , columnName , value ) ; } public void setLong ( int column , long value ) { table . setLong ( row , column , value ) ; } public void setLong ( String columnName , long value ) { table . setLong ( row , columnName , value ) ; } public void setFloat ( int column , float value ) { table . setFloat ( row , column , value ) ; } public void setFloat ( String columnName , float value ) { table . setFloat ( row , columnName , value ) ; } public void setDouble ( int column , double value ) { table . setDouble ( row , column , value ) ; } public void setDouble ( String columnName , double value ) { table . setDouble ( row , columnName , value ) ; } public int getColumnCount ( ) { return table . getColumnCount ( ) ; } public int getColumnType ( String columnName ) { return table . getColumnType ( columnName ) ; } public int getColumnType ( int column ) { return table . getColumnType ( column ) ; } public int [ ] getColumnTypes ( ) { return table . getColumnTypes ( ) ; } public String getColumnTitle ( int column ) { return table . getColumnTitle ( column ) ; } public String [ ] getColumnTitles ( ) { return table . getColumnTitles ( ) ; } } static class RowIterator implements Iterator < TableRow > { Table table ; RowPointer rp ; int row ; public RowIterator ( Table table ) { this . table = table ; row = - 1 ; rp = new RowPointer ( table , row ) ; } public void remove ( ) { table . removeRow ( row ) ; } public TableRow next ( ) { rp . setRow ( ++ row ) ; return rp ; } public boolean hasNext ( ) { return row + 1 < table . getRowCount ( ) ; } public void reset ( ) { row = - 1 ; } } static class RowIndexIterator implements Iterator < TableRow > { Table table ; RowPointer rp ; int [ ] indices ; int index ; public RowIndexIterator ( Table table , int [ ] indices ) { this . table = table ; this . indices = indices ; index = - 1 ; rp = new RowPointer ( table , - 1 ) ; } public void remove ( ) { table . removeRow ( indices [ index ] ) ; } public TableRow next ( ) { rp . setRow ( indices [ ++ index ] ) ; return rp ; } public boolean hasNext ( ) { return index + 1 < indices . length ; } public void reset ( ) { index = - 1 ; } } public int getInt ( int row , int column ) { checkBounds ( row , column ) ; if ( columnTypes [ column ] == INT || columnTypes [ column ] == CATEGORY ) { int [ ] intData = ( int [ ] ) columns [ column ] ; return intData [ row ] ; } String str = getString ( row , column ) ; return ( str == null || str . equals ( missingString ) ) ? missingInt : PApplet . parseInt ( str , missingInt ) ; } public int getInt ( int row , String columnName ) { return getInt ( row , getColumnIndex ( columnName ) ) ; } public void setMissingInt ( int value ) { missingInt = value ; } public void setInt ( int row , int column , int value ) { if ( columnTypes [ column ] == STRING ) { setString ( row , column , String . valueOf ( value ) ) ; } else { ensureBounds ( row , column ) ; if ( columnTypes [ column ] != INT && columnTypes [ column ] != CATEGORY ) { throw new IllegalArgumentException ( "Column " + column + " is not an int column." ) ; } int [ ] intData = ( int [ ] ) columns [ column ] ; intData [ row ] = value ; } } public void setInt ( int row , String columnName , int value ) { setInt ( row , getColumnIndex ( columnName ) , value ) ; } public int [ ] getIntColumn ( String name ) { int col = getColumnIndex ( name ) ; return ( col == - 1 ) ? null : getIntColumn ( col ) ; } public int [ ] getIntColumn ( int col ) { int [ ] outgoing = new int [ rowCount ] ; for ( int row = 0 ; row < rowCount ; row ++ ) { outgoing [ row ] = getInt ( row , col ) ; } return outgoing ; } public int [ ] getIntRow ( int row ) { int [ ] outgoing = new int [ columns . length ] ; for ( int col = 0 ; col < columns . length ; col ++ ) { outgoing [ col ] = getInt ( row , col ) ; } return outgoing ; } public long getLong ( int row , int column ) { checkBounds ( row , column ) ; if ( columnTypes [ column ] == LONG ) { long [ ] longData = ( long [ ] ) columns [ column ] ; return longData [ row ] ; } String str = getString ( row , column ) ; if ( str == null || str . equals ( missingString ) ) { return missingLong ; } try { return Long . parseLong ( str ) ; } catch ( NumberFormatException nfe ) { return missingLong ; } } public long getLong ( int row , String columnName ) { return getLong ( row , getColumnIndex ( columnName ) ) ; } public void setMissingLong ( long value ) { missingLong = value ; } public void setLong ( int row , int column , long value ) { if ( columnTypes [ column ] == STRING ) { setString ( row , column , String . valueOf ( value ) ) ; } else { ensureBounds ( row , column ) ; if ( columnTypes [ column ] != LONG ) { throw new IllegalArgumentException ( "Column " + column + " is not a 'long' column." ) ; } long [ ] longData = ( long [ ] ) columns [ column ] ; longData [ row ] = value ; } } public void setLong ( int row , String columnName , long value ) { setLong ( row , getColumnIndex ( columnName ) , value ) ; } public long [ ] getLongColumn ( String name ) { int col = getColumnIndex ( name ) ; return ( col == - 1 ) ? null : getLongColumn ( col ) ; } public long [ ] getLongColumn ( int col ) { long [ ] outgoing = new long [ rowCount ] ; for ( int row = 0 ; row < rowCount ; row ++ ) { outgoing [ row ] = getLong ( row , col ) ; } return outgoing ; } public long [ ] getLongRow ( int row ) { long [ ] outgoing = new long [ columns . length ] ; for ( int col = 0 ; col < columns . length ; col ++ ) { outgoing [ col ] = getLong ( row , col ) ; } return outgoing ; } public float getFloat ( int row , int column ) { checkBounds ( row , column ) ; if ( columnTypes [ column ] == FLOAT ) { float [ ] floatData = ( float [ ] ) columns [ column ] ; return floatData [ row ] ; } String str = getString ( row , column ) ; if ( str == null || str . equals ( missingString ) ) { return missingFloat ; } return PApplet . parseFloat ( str , missingFloat ) ; } public float getFloat ( int row , String columnName ) { return getFloat ( row , getColumnIndex ( columnName ) ) ; } public void setMissingFloat ( float value ) { missingFloat = value ; } public void setFloat ( int row , int column , float value ) { if ( columnTypes [ column ] == STRING ) { setString ( row , column , String . valueOf ( value ) ) ; } else { ensureBounds ( row , column ) ; if ( columnTypes [ column ] != FLOAT ) { throw new IllegalArgumentException ( "Column " + column + " is not a float column." ) ; } float [ ] longData = ( float [ ] ) columns [ column ] ; longData [ row ] = value ; } } public void setFloat ( int row , String columnName , float value ) { setFloat ( row , getColumnIndex ( columnName ) , value ) ; } public float [ ] getFloatColumn ( String name ) { int col = getColumnIndex ( name ) ; return ( col == - 1 ) ? null : getFloatColumn ( col ) ; } public float [ ] getFloatColumn ( int col ) { float [ ] outgoing = new float [ rowCount ] ; for ( int row = 0 ; row < rowCount ; row ++ ) { outgoing [ row ] = getFloat ( row , col ) ; } return outgoing ; } public float [ ] getFloatRow ( int row ) { float [ ] outgoing = new float [ columns . length ] ; for ( int col = 0 ; col < columns . length ; col ++ ) { outgoing [ col ] = getFloat ( row , col ) ; } return outgoing ; } public double getDouble ( int row , int column ) { checkBounds ( row , column ) ; if ( columnTypes [ column ] == DOUBLE ) { double [ ] doubleData = ( double [ ] ) columns [ column ] ; return doubleData [ row ] ; } String str = getString ( row , column ) ; if ( str == null || str . equals ( missingString ) ) { return missingDouble ; } try { return Double . parseDouble ( str ) ; } catch ( NumberFormatException nfe ) { return missingDouble ; } } public double getDouble ( int row , String columnName ) { return getDouble ( row , getColumnIndex ( columnName ) ) ; } public void setMissingDouble ( double value ) { missingDouble = value ; } public void setDouble ( int row , int column , double value ) { if ( columnTypes [ column ] == STRING ) { setString ( row , column , String . valueOf ( value ) ) ; } else { ensureBounds ( row , column ) ; if ( columnTypes [ column ] != DOUBLE ) { throw new IllegalArgumentException ( "Column " + column + " is not a 'double' column." ) ; } double [ ] doubleData = ( double [ ] ) columns [ column ] ; doubleData [ row ] = value ; } } public void setDouble ( int row , String columnName , double value ) { setDouble ( row , getColumnIndex ( columnName ) , value ) ; } public double [ ] getDoubleColumn ( String name ) { int col = getColumnIndex ( name ) ; return ( col == - 1 ) ? null : getDoubleColumn ( col ) ; } public double [ ] getDoubleColumn ( int col ) { double [ ] outgoing = new double [ rowCount ] ; for ( int row = 0 ; row < rowCount ; row ++ ) { outgoing [ row ] = getDouble ( row , col ) ; } return outgoing ; } public double [ ] getDoubleRow ( int row ) { double [ ] outgoing = new double [ columns . length ] ; for ( int col = 0 ; col < columns . length ; col ++ ) { outgoing [ col ] = getDouble ( row , col ) ; } return outgoing ; } public String getString ( int row , int column ) { checkBounds ( row , column ) ; if ( columnTypes [ column ] == STRING ) { String [ ] stringData = ( String [ ] ) columns [ column ] ; return stringData [ row ] ; } else if ( columnTypes [ column ] == CATEGORY ) { int cat = getInt ( row , column ) ; if ( cat == missingCategory ) { return missingString ; } return columnCategories [ column ] . key ( cat ) ; } else if ( columnTypes [ column ] == FLOAT ) { if ( Float . isNaN ( getFloat ( row , column ) ) ) { return null ; } } else if ( columnTypes [ column ] == DOUBLE ) { if ( Double . isNaN ( getFloat ( row , column ) ) ) { return null ; } } return String . valueOf ( Array . get ( columns [ column ] , row ) ) ; } public String getString ( int row , String columnName ) { return getString ( row , getColumnIndex ( columnName ) ) ; } public void setMissingString ( String value ) { missingString = value ; } public void setString ( int row , int column , String value ) { ensureBounds ( row , column ) ; if ( columnTypes [ column ] != STRING ) { throw new IllegalArgumentException ( "Column " + column + " is not a String column." ) ; } String [ ] stringData = ( String [ ] ) columns [ column ] ; stringData [ row ] = value ; } public void setString ( int row , String columnName , String value ) { int column = checkColumnIndex ( columnName ) ; setString ( row , column , value ) ; } public String [ ] getStringColumn ( String columnName ) { int col = getColumnIndex ( columnName ) ; return ( col == - 1 ) ? null : getStringColumn ( col ) ; } public String [ ] getStringColumn ( int column ) { String [ ] outgoing = new String [ rowCount ] ; for ( int i = 0 ; i < rowCount ; i ++ ) { outgoing [ i ] = getString ( i , column ) ; } return outgoing ; } public String [ ] getStringRow ( int row ) { String [ ] outgoing = new String [ columns . length ] ; for ( int col = 0 ; col < columns . length ; col ++ ) { outgoing [ col ] = getString ( row , col ) ; } return outgoing ; } public int findRowIndex ( String value , int column ) { checkColumn ( column ) ; if ( columnTypes [ column ] == STRING ) { String [ ] stringData = ( String [ ] ) columns [ column ] ; if ( value == null ) { for ( int row = 0 ; row < rowCount ; row ++ ) { if ( stringData [ row ] == null ) return row ; } } else { for ( int row = 0 ; row < rowCount ; row ++ ) { if ( stringData [ row ] != null && stringData [ row ] . equals ( value ) ) { return row ; } } } } else { for ( int row = 0 ; row < rowCount ; row ++ ) { String str = getString ( row , column ) ; if ( str == null ) { if ( value == null ) { return row ; } } else if ( str . equals ( value ) ) { return row ; } } } return - 1 ; } public int findRowIndex ( String value , String columnName ) { return findRowIndex ( value , getColumnIndex ( columnName ) ) ; } public int [ ] findRowIndices ( String value , int column ) { int [ ] outgoing = new int [ rowCount ] ; int count = 0 ; checkColumn ( column ) ; if ( columnTypes [ column ] == STRING ) { String [ ] stringData = ( String [ ] ) columns [ column ] ; if ( value == null ) { for ( int row = 0 ; row < rowCount ; row ++ ) { if ( stringData [ row ] == null ) { outgoing [ count ++ ] = row ; } } } else { for ( int row = 0 ; row < rowCount ; row ++ ) { if ( stringData [ row ] != null && stringData [ row ] . equals ( value ) ) { outgoing [ count ++ ] = row ; } } } } else { for ( int row = 0 ; row < rowCount ; row ++ ) { String str = getString ( row , column ) ; if ( str == null ) { if ( value == null ) { outgoing [ count ++ ] = row ; } } else if ( str . equals ( value ) ) { outgoing [ count ++ ] = row ; } } } return PApplet . subset ( outgoing , 0 , count ) ; } public int [ ] findRowIndices ( String value , String columnName ) { return findRowIndices ( value , getColumnIndex ( columnName ) ) ; } public TableRow findRow ( String value , int column ) { int row = findRowIndex ( value , column ) ; return ( row == - 1 ) ? null : new RowPointer ( this , row ) ; } public TableRow findRow ( String value , String columnName ) { return findRow ( value , getColumnIndex ( columnName ) ) ; } public Iterable < TableRow > findRows ( final String value , final int column ) { return new Iterable < TableRow > ( ) { public Iterator < TableRow > iterator ( ) { return findRowIterator ( value , column ) ; } } ; } public Iterable < TableRow > findRows ( final String value , final String columnName ) { return findRows ( value , getColumnIndex ( columnName ) ) ; } public Iterator < TableRow > findRowIterator ( String value , int column ) { return new RowIndexIterator ( this , findRowIndices ( value , column ) ) ; } public Iterator < TableRow > findRowIterator ( String value , String columnName ) { return findRowIterator ( value , getColumnIndex ( columnName ) ) ; } public int matchRowIndex ( String regexp , int column ) { checkColumn ( column ) ; if ( columnTypes [ column ] == STRING ) { String [ ] stringData = ( String [ ] ) columns [ column ] ; for ( int row = 0 ; row < rowCount ; row ++ ) { if ( stringData [ row ] != null && PApplet . match ( stringData [ row ] , regexp ) != null ) { return row ; } } } else { for ( int row = 0 ; row < rowCount ; row ++ ) { String str = getString ( row , column ) ; if ( str != null && PApplet . match ( str , regexp ) != null ) { return row ; } } } return - 1 ; } public int matchRowIndex ( String what , String columnName ) { return matchRowIndex ( what , getColumnIndex ( columnName ) ) ; } public int [ ] matchRowIndices ( String regexp , int column ) { int [ ] outgoing = new int [ rowCount ] ; int count = 0 ; checkColumn ( column ) ; if ( columnTypes [ column ] == STRING ) { String [ ] stringData = ( String [ ] ) columns [ column ] ; for ( int row = 0 ; row < rowCount ; row ++ ) { if ( stringData [ row ] != null && PApplet . match ( stringData [ row ] , regexp ) != null ) { outgoing [ count ++ ] = row ; } } } else { for ( int row = 0 ; row < rowCount ; row ++ ) { String str = getString ( row , column ) ; if ( str != null && PApplet . match ( str , regexp ) != null ) { outgoing [ count ++ ] = row ; } } } return PApplet . subset ( outgoing , 0 , count ) ; } public int [ ] matchRowIndices ( String what , String columnName ) { return matchRowIndices ( what , getColumnIndex ( columnName ) ) ; } public TableRow matchRow ( String regexp , int column ) { int row = matchRowIndex ( regexp , column ) ; return ( row == - 1 ) ? null : new RowPointer ( this , row ) ; } public TableRow matchRow ( String regexp , String columnName ) { return matchRow ( regexp , getColumnIndex ( columnName ) ) ; } public Iterable < TableRow > matchRows ( final String regexp , final int column ) { return new Iterable < TableRow > ( ) { public Iterator < TableRow > iterator ( ) { return matchRowIterator ( regexp , column ) ; } } ; } public Iterable < TableRow > matchRows ( String regexp , String columnName ) { return matchRows ( regexp , getColumnIndex ( columnName ) ) ; } public Iterator < TableRow > matchRowIterator ( String value , int column ) { return new RowIndexIterator ( this , matchRowIndices ( value , column ) ) ; } public Iterator < TableRow > matchRowIterator ( String value , String columnName ) { return matchRowIterator ( value , getColumnIndex ( columnName ) ) ; } public void replace ( String orig , String replacement ) { for ( int col = 0 ; col < columns . length ; col ++ ) { replace ( orig , replacement , col ) ; } } public void replace ( String orig , String replacement , int col ) { if ( columnTypes [ col ] == STRING ) { String [ ] stringData = ( String [ ] ) columns [ col ] ; if ( orig != null ) { for ( int row = 0 ; row < rowCount ; row ++ ) { if ( orig . equals ( stringData [ row ] ) ) { stringData [ row ] = replacement ; } } } else { for ( int row = 0 ; row < rowCount ; row ++ ) { if ( stringData [ row ] == null ) { stringData [ row ] = replacement ; } } } } } public void replace ( String orig , String replacement , String colName ) { replace ( orig , replacement , getColumnIndex ( colName ) ) ; } public void replaceAll ( String regex , String replacement ) { for ( int col = 0 ; col < columns . length ; col ++ ) { replaceAll ( regex , replacement , col ) ; } } public void replaceAll ( String regex , String replacement , int column ) { checkColumn ( column ) ; if ( columnTypes [ column ] == STRING ) { String [ ] stringData = ( String [ ] ) columns [ column ] ; for ( int row = 0 ; row < rowCount ; row ++ ) { if ( stringData [ row ] != null ) { stringData [ row ] = stringData [ row ] . replaceAll ( regex , replacement ) ; } } } else { throw new IllegalArgumentException ( "replaceAll() can only be used on String columns" ) ; } } public void replaceAll ( String regex , String replacement , String columnName ) { replaceAll ( regex , replacement , getColumnIndex ( columnName ) ) ; } public void removeTokens ( String tokens ) { for ( int col = 0 ; col < getColumnCount ( ) ; col ++ ) { removeTokens ( tokens , col ) ; } } public void removeTokens ( String tokens , int column ) { for ( int row = 0 ; row < rowCount ; row ++ ) { String s = getString ( row , column ) ; if ( s != null ) { char [ ] c = s . toCharArray ( ) ; int index = 0 ; for ( int j = 0 ; j < c . length ; j ++ ) { if ( tokens . indexOf ( c [ j ] ) == - 1 ) { if ( index != j ) { c [ index ] = c [ j ] ; } index ++ ; } } if ( index != c . length ) { setString ( row , column , new String ( c , 0 , index ) ) ; } } } } public void removeTokens ( String tokens , String columnName ) { removeTokens ( tokens , getColumnIndex ( columnName ) ) ; } public void trim ( ) { for ( int col = 0 ; col < getColumnCount ( ) ; col ++ ) { trim ( col ) ; } } public void trim ( int column ) { if ( columnTypes [ column ] == STRING ) { String [ ] stringData = ( String [ ] ) columns [ column ] ; for ( int row = 0 ; row < rowCount ; row ++ ) { if ( stringData [ row ] != null ) { stringData [ row ] = PApplet . trim ( stringData [ row ] ) ; } } } } public void trim ( String columnName ) { trim ( getColumnIndex ( columnName ) ) ; } protected void ensureColumn ( int col ) { if ( col >= columns . length ) { setColumnCount ( col + 1 ) ; } } protected void ensureRow ( int row ) { if ( row >= rowCount ) { setRowCount ( row + 1 ) ; } } protected void ensureBounds ( int row , int col ) { ensureRow ( row ) ; ensureColumn ( col ) ; } protected void checkRow ( int row ) { if ( row < 0 || row >= rowCount ) { throw new ArrayIndexOutOfBoundsException ( "Row " + row + " does not exist." ) ; } } protected void checkColumn ( int column ) { if ( column < 0 || column >= columns . length ) { throw new ArrayIndexOutOfBoundsException ( "Column " + column + " does not exist." ) ; } } protected void checkBounds ( int row , int column ) { checkRow ( row ) ; checkColumn ( column ) ; } static class HashMapBlows { HashMap < String , Integer > dataToIndex = new HashMap < String , Integer > ( ) ; ArrayList < String > indexToData = new ArrayList < String > ( ) ; HashMapBlows ( ) { } HashMapBlows ( DataInputStream input ) throws IOException { read ( input ) ; } int index ( String key ) { Integer value = dataToIndex . get ( key ) ; if ( value != null ) { return value ; } int v = dataToIndex . size ( ) ; dataToIndex . put ( key , v ) ; indexToData . add ( key ) ; return v ; } String key ( int index ) { return indexToData . get ( index ) ; } boolean hasCategory ( int index ) { return index < size ( ) && indexToData . get ( index ) != null ; } void setCategory ( int index , String name ) { while ( indexToData . size ( ) <= index ) { indexToData . add ( null ) ; } indexToData . set ( index , name ) ; dataToIndex . put ( name , index ) ; } int size ( ) { return dataToIndex . size ( ) ; } void write ( DataOutputStream output ) throws IOException { output . writeInt ( size ( ) ) ; for ( String str : indexToData ) { output . writeUTF ( str ) ; } } private void writeln ( PrintWriter writer ) throws IOException { for ( String str : indexToData ) { writer . println ( str ) ; } writer . flush ( ) ; writer . close ( ) ; } void read ( DataInputStream input ) throws IOException { int count = input . readInt ( ) ; dataToIndex = new HashMap < String , Integer > ( count ) ; for ( int i = 0 ; i < count ; i ++ ) { String str = input . readUTF ( ) ; dataToIndex . put ( str , i ) ; indexToData . add ( str ) ; } } } public void sort ( String columnName ) { sort ( getColumnIndex ( columnName ) , false ) ; } public void sort ( int column ) { sort ( column , false ) ; } public void sortReverse ( String columnName ) { sort ( getColumnIndex ( columnName ) , true ) ; } public void sortReverse ( int column ) { sort ( column , true ) ; } protected void sort ( final int column , final boolean reverse ) { final int [ ] order = IntList . fromRange ( getRowCount ( ) ) . array ( ) ; Sort s = new Sort ( ) { @ Override public int size ( ) { return getRowCount ( ) ; } @ Override public float compare ( int index1 , int index2 ) { int a = reverse ? order [ index2 ] : order [ index1 ] ; int b = reverse ? order [ index1 ] : order [ index2 ] ; switch ( getColumnType ( column ) ) { case INT : return getInt ( a , column ) - getInt ( b , column ) ; case LONG : return getLong ( a , column ) - getLong ( b , column ) ; case FLOAT : return getFloat ( a , column ) - getFloat ( b , column ) ; case DOUBLE : return ( float ) ( getDouble ( a , column ) - getDouble ( b , column ) ) ; case STRING : return getString ( a , column ) . compareToIgnoreCase ( getString ( b , column ) ) ; case CATEGORY : return getInt ( a , column ) - getInt ( b , column ) ; default : throw new IllegalArgumentException ( "Invalid column type: " + getColumnType ( column ) ) ; } } @ Override public void swap ( int a , int b ) { int temp = order [ a ] ; order [ a ] = order [ b ] ; order [ b ] = temp ; } } ; s . run ( ) ; for ( int col = 0 ; col < getColumnCount ( ) ; col ++ ) { switch ( getColumnType ( col ) ) { case INT : case CATEGORY : int [ ] oldInt = ( int [ ] ) columns [ col ] ; int [ ] newInt = new int [ rowCount ] ; for ( int row = 0 ; row < getRowCount ( ) ; row ++ ) { newInt [ row ] = oldInt [ order [ row ] ] ; } columns [ col ] = newInt ; break ; case LONG : long [ ] oldLong = ( long [ ] ) columns [ col ] ; long [ ] newLong = new long [ rowCount ] ; for ( int row = 0 ; row < getRowCount ( ) ; row ++ ) { newLong [ row ] = oldLong [ order [ row ] ] ; } columns [ col ] = newLong ; break ; case FLOAT : float [ ] oldFloat = ( float [ ] ) columns [ col ] ; float [ ] newFloat = new float [ rowCount ] ; for ( int row = 0 ; row < getRowCount ( ) ; row ++ ) { newFloat [ row ] = oldFloat [ order [ row ] ] ; } columns [ col ] = newFloat ; break ; case DOUBLE : double [ ] oldDouble = ( double [ ] ) columns [ col ] ; double [ ] newDouble = new double [ rowCount ] ; for ( int row = 0 ; row < getRowCount ( ) ; row ++ ) { newDouble [ row ] = oldDouble [ order [ row ] ] ; } columns [ col ] = newDouble ; break ; case STRING : String [ ] oldString = ( String [ ] ) columns [ col ] ; String [ ] newString = new String [ rowCount ] ; for ( int row = 0 ; row < getRowCount ( ) ; row ++ ) { newString [ row ] = oldString [ order [ row ] ] ; } columns [ col ] = newString ; break ; } } } public String [ ] getUnique ( String columnName ) { return getUnique ( getColumnIndex ( columnName ) ) ; } public String [ ] getUnique ( int column ) { StringList list = new StringList ( getStringColumn ( column ) ) ; return list . getUnique ( ) ; } public IntDict getTally ( String columnName ) { return getTally ( getColumnIndex ( columnName ) ) ; } public IntDict getTally ( int column ) { StringList list = new StringList ( getStringColumn ( column ) ) ; return list . getTally ( ) ; } public IntDict getOrder ( String columnName ) { return getOrder ( getColumnIndex ( columnName ) ) ; } public IntDict getOrder ( int column ) { StringList list = new StringList ( getStringColumn ( column ) ) ; return list . getOrder ( ) ; } public IntList getIntList ( String columnName ) { return new IntList ( getIntColumn ( columnName ) ) ; } public IntList getIntList ( int column ) { return new IntList ( getIntColumn ( column ) ) ; } public FloatList getFloatList ( String columnName ) { return new FloatList ( getFloatColumn ( columnName ) ) ; } public FloatList getFloatList ( int column ) { return new FloatList ( getFloatColumn ( column ) ) ; } public StringList getStringList ( String columnName ) { return new StringList ( getStringColumn ( columnName ) ) ; } public StringList getStringList ( int column ) { return new StringList ( getStringColumn ( column ) ) ; } public IntDict getIntDict ( String keyColumnName , String valueColumnName ) { return new IntDict ( getStringColumn ( keyColumnName ) , getIntColumn ( valueColumnName ) ) ; } public IntDict getIntDict ( int keyColumn , int valueColumn ) { return new IntDict ( getStringColumn ( keyColumn ) , getIntColumn ( valueColumn ) ) ; } public FloatDict getFloatDict ( String keyColumnName , String valueColumnName ) { return new FloatDict ( getStringColumn ( keyColumnName ) , getFloatColumn ( valueColumnName ) ) ; } public FloatDict getFloatDict ( int keyColumn , int valueColumn ) { return new FloatDict ( getStringColumn ( keyColumn ) , getFloatColumn ( valueColumn ) ) ; } public StringDict getStringDict ( String keyColumnName , String valueColumnName ) { return new StringDict ( getStringColumn ( keyColumnName ) , getStringColumn ( valueColumnName ) ) ; } public StringDict getStringDict ( int keyColumn , int valueColumn ) { return new StringDict ( getStringColumn ( keyColumn ) , getStringColumn ( valueColumn ) ) ; } protected Table createSubset ( int [ ] rowSubset ) { Table newbie = new Table ( ) ; newbie . setColumnTitles ( columnTitles ) ; newbie . columnTypes = columnTypes ; newbie . setRowCount ( rowSubset . length ) ; for ( int i = 0 ; i < rowSubset . length ; i ++ ) { int row = rowSubset [ i ] ; for ( int col = 0 ; col < columns . length ; col ++ ) { switch ( columnTypes [ col ] ) { case STRING : newbie . setString ( i , col , getString ( row , col ) ) ; break ; case INT : newbie . setInt ( i , col , getInt ( row , col ) ) ; break ; case LONG : newbie . setLong ( i , col , getLong ( row , col ) ) ; break ; case FLOAT : newbie . setFloat ( i , col , getFloat ( row , col ) ) ; break ; case DOUBLE : newbie . setDouble ( i , col , getDouble ( row , col ) ) ; break ; } } } return newbie ; } protected float getMaxFloat ( ) { boolean found = false ; float max = PConstants . MIN_FLOAT ; for ( int row = 0 ; row < getRowCount ( ) ; row ++ ) { for ( int col = 0 ; col < getColumnCount ( ) ; col ++ ) { float value = getFloat ( row , col ) ; if ( ! Float . isNaN ( value ) ) { if ( ! found ) { max = value ; found = true ; } else if ( value > max ) { max = value ; } } } } return found ? max : missingFloat ; } protected void convertBasic ( BufferedReader reader , boolean tsv , File outputFile ) throws IOException { FileOutputStream fos = new FileOutputStream ( outputFile ) ; BufferedOutputStream bos = new BufferedOutputStream ( fos , 16384 ) ; DataOutputStream output = new DataOutputStream ( bos ) ; output . writeInt ( 0 ) ; output . writeInt ( getColumnCount ( ) ) ; if ( columnTitles != null ) { output . writeBoolean ( true ) ; for ( String title : columnTitles ) { output . writeUTF ( title ) ; } } else { output . writeBoolean ( false ) ; } for ( int type : columnTypes ) { output . writeInt ( type ) ; } String line = null ; int prev = - 1 ; int row = 0 ; while ( ( line = reader . readLine ( ) ) != null ) { convertRow ( output , tsv ? PApplet . split ( line , '\t' ) : splitLineCSV ( line ) ) ; row ++ ; if ( row % 10000 == 0 ) { if ( row < rowCount ) { int pct = ( 100 * row ) / rowCount ; if ( pct != prev ) { System . out . println ( pct + "%" ) ; prev = pct ; } } } } int col = 0 ; for ( HashMapBlows hmb : columnCategories ) { if ( hmb == null ) { output . writeInt ( 0 ) ; } else { hmb . write ( output ) ; hmb . writeln ( PApplet . createWriter ( new File ( columnTitles [ col ] + ".categories" ) ) ) ; } col ++ ; } output . flush ( ) ; output . close ( ) ; RandomAccessFile raf = new RandomAccessFile ( outputFile , "rw" ) ; raf . writeInt ( rowCount ) ; raf . close ( ) ; } protected void convertRow ( DataOutputStream output , String [ ] pieces ) throws IOException { if ( pieces . length > getColumnCount ( ) ) { throw new IllegalArgumentException ( "Row with too many columns: " + PApplet . join ( pieces , "," ) ) ; } for ( int col = 0 ; col < pieces . length ; col ++ ) { switch ( columnTypes [ col ] ) { case STRING : output . writeUTF ( pieces [ col ] ) ; break ; case INT : output . writeInt ( PApplet . parseInt ( pieces [ col ] , missingInt ) ) ; break ; case LONG : try { output . writeLong ( Long . parseLong ( pieces [ col ] ) ) ; } catch ( NumberFormatException nfe ) { output . writeLong ( missingLong ) ; } break ; case FLOAT : output . writeFloat ( PApplet . parseFloat ( pieces [ col ] , missingFloat ) ) ; break ; case DOUBLE : try { output . writeDouble ( Double . parseDouble ( pieces [ col ] ) ) ; } catch ( NumberFormatException nfe ) { output . writeDouble ( missingDouble ) ; } break ; case CATEGORY : String peace = pieces [ col ] ; if ( peace . equals ( missingString ) ) { output . writeInt ( missingCategory ) ; } else { output . writeInt ( columnCategories [ col ] . index ( peace ) ) ; } break ; } } for ( int col = pieces . length ; col < getColumnCount ( ) ; col ++ ) { switch ( columnTypes [ col ] ) { case STRING : output . writeUTF ( "" ) ; break ; case INT : output . writeInt ( missingInt ) ; break ; case LONG : output . writeLong ( missingLong ) ; break ; case FLOAT : output . writeFloat ( missingFloat ) ; break ; case DOUBLE : output . writeDouble ( missingDouble ) ; break ; case CATEGORY : output . writeInt ( missingCategory ) ; break ; } } } public Table copy ( ) { return new Table ( rows ( ) ) ; } }
package processing . data ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; class JSONTokener { private long character ; private boolean eof ; private long index ; private long line ; private char previous ; private Reader reader ; private boolean usePrevious ; public JSONTokener ( Reader reader ) { this . reader = reader . markSupported ( ) ? reader : new BufferedReader ( reader ) ; this . eof = false ; this . usePrevious = false ; this . previous = 0 ; this . index = 0 ; this . character = 1 ; this . line = 1 ; } public JSONTokener ( InputStream inputStream ) { this ( new InputStreamReader ( inputStream ) ) ; } public JSONTokener ( String s ) { this ( new StringReader ( s ) ) ; } public void back ( ) { if ( this . usePrevious || this . index <= 0 ) { throw new RuntimeException ( "Stepping back two steps is not supported" ) ; } this . index -= 1 ; this . character -= 1 ; this . usePrevious = true ; this . eof = false ; } public static int dehexchar ( char c ) { if ( c >= '0' && c <= '9' ) { return c - '0' ; } if ( c >= 'A' && c <= 'F' ) { return c - ( 'A' - 10 ) ; } if ( c >= 'a' && c <= 'f' ) { return c - ( 'a' - 10 ) ; } return - 1 ; } public boolean end ( ) { return this . eof && ! this . usePrevious ; } public boolean more ( ) { this . next ( ) ; if ( this . end ( ) ) { return false ; } this . back ( ) ; return true ; } public char next ( ) { int c ; if ( this . usePrevious ) { this . usePrevious = false ; c = this . previous ; } else { try { c = this . reader . read ( ) ; } catch ( IOException exception ) { throw new RuntimeException ( exception ) ; } if ( c <= 0 ) { this . eof = true ; c = 0 ; } } this . index += 1 ; if ( this . previous == '\r' ) { this . line += 1 ; this . character = c == '\n' ? 0 : 1 ; } else if ( c == '\n' ) { this . line += 1 ; this . character = 0 ; } else { this . character += 1 ; } this . previous = ( char ) c ; return this . previous ; } public char next ( char c ) { char n = this . next ( ) ; if ( n != c ) { throw new RuntimeException ( "Expected '" + c + "' and instead saw '" + n + "'" ) ; } return n ; } public String next ( int n ) { if ( n == 0 ) { return "" ; } char [ ] chars = new char [ n ] ; int pos = 0 ; while ( pos < n ) { chars [ pos ] = this . next ( ) ; if ( this . end ( ) ) { throw new RuntimeException ( "Substring bounds error" ) ; } pos += 1 ; } return new String ( chars ) ; } public char nextClean ( ) { for ( ; ; ) { char c = this . next ( ) ; if ( c == 0 || c > ' ' ) { return c ; } } } public String nextString ( char quote ) { char c ; StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { c = this . next ( ) ; switch ( c ) { case 0 : case '\n' : case '\r' : throw new RuntimeException ( "Unterminated string" ) ; case '\\' : c = this . next ( ) ; switch ( c ) { case 'b' : sb . append ( '\b' ) ; break ; case 't' : sb . append ( '\t' ) ; break ; case 'n' : sb . append ( '\n' ) ; break ; case 'f' : sb . append ( '\f' ) ; break ; case 'r' : sb . append ( '\r' ) ; break ; case 'u' : sb . append ( ( char ) Integer . parseInt ( this . next ( 4 ) , 16 ) ) ; break ; case '"' : case '\'' : case '\\' : case '/' : sb . append ( c ) ; break ; default : throw new RuntimeException ( "Illegal escape." ) ; } break ; default : if ( c == quote ) { return sb . toString ( ) ; } sb . append ( c ) ; } } } public String nextTo ( char delimiter ) { StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '\n' || c == '\r' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } } public String nextTo ( String delimiters ) { char c ; StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { c = this . next ( ) ; if ( delimiters . indexOf ( c ) >= 0 || c == 0 || c == '\n' || c == '\r' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } } public Object nextValue ( ) { char c = this . nextClean ( ) ; String string ; switch ( c ) { case '"' : case '\'' : return this . nextString ( c ) ; case '{' : this . back ( ) ; return new JSONObject ( this ) ; case '[' : this . back ( ) ; return new JSONArray ( this ) ; } StringBuilder sb = new StringBuilder ( ) ; while ( c >= ' ' && ",:]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw new RuntimeException ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; } public char skipTo ( char to ) { char c ; try { long startIndex = this . index ; long startCharacter = this . character ; long startLine = this . line ; this . reader . mark ( 1000000 ) ; do { c = this . next ( ) ; if ( c == 0 ) { this . reader . reset ( ) ; this . index = startIndex ; this . character = startCharacter ; this . line = startLine ; return c ; } } while ( c != to ) ; } catch ( IOException exc ) { throw new RuntimeException ( exc ) ; } this . back ( ) ; return c ; } @ Override public String toString ( ) { return " at " + this . index + " [character " + this . character + " line " + this . line + "]" ; } }
package processing . data ; public abstract class Sort implements Runnable { public Sort ( ) { } public void run ( ) { int c = size ( ) ; if ( c > 1 ) { sort ( 0 , c - 1 ) ; } } protected void sort ( int i , int j ) { int pivotIndex = ( i + j ) / 2 ; swap ( pivotIndex , j ) ; int k = partition ( i - 1 , j ) ; swap ( k , j ) ; if ( ( k - i ) > 1 ) sort ( i , k - 1 ) ; if ( ( j - k ) > 1 ) sort ( k + 1 , j ) ; } protected int partition ( int left , int right ) { int pivot = right ; do { while ( compare ( ++ left , pivot ) < 0 ) { } while ( ( right != 0 ) && ( compare ( -- right , pivot ) > 0 ) ) { } swap ( left , right ) ; } while ( left < right ) ; swap ( left , right ) ; return left ; } abstract public int size ( ) ; abstract public float compare ( int a , int b ) ; abstract public void swap ( int a , int b ) ; }
package processing . core ; public class PSurfaceNone implements PSurface { PApplet sketch ; PGraphics graphics ; Thread thread ; boolean paused ; Object pauseObject = new Object ( ) ; protected float frameRateTarget = 60 ; protected long frameRatePeriod = 1000000000L / 60L ; public PSurfaceNone ( PGraphics graphics ) { this . graphics = graphics ; } @ Override public void initOffscreen ( PApplet sketch ) { this . sketch = sketch ; setSize ( sketch . sketchWidth ( ) , sketch . sketchHeight ( ) ) ; } @ Override public void initFrame ( PApplet sketch ) { throw new IllegalStateException ( "initFrame() not available with " + getClass ( ) . getSimpleName ( ) ) ; } public void setTitle ( String title ) { } public void setVisible ( boolean visible ) { } public void setResizable ( boolean resizable ) { } @ Override public void placeWindow ( int [ ] location , int [ ] editorLocation ) { } @ Override public void placePresent ( int stopColor ) { } @ Override public void setupExternalMessages ( ) { } @ Override public void setSize ( int wide , int high ) { if ( PApplet . DEBUG ) { new Exception ( String . format ( "setSize(%d, %d)" , wide , high ) ) . printStackTrace ( System . out ) ; } if ( wide == sketch . width && high == sketch . height ) { if ( PApplet . DEBUG ) { new Exception ( "w/h unchanged " + wide + " " + high ) . printStackTrace ( System . out ) ; } return ; } sketch . width = wide ; sketch . height = high ; graphics . setSize ( wide , high ) ; } public void setSmooth ( int level ) { } void requestFocus ( ) { } public void setCursor ( int kind ) { } public void setCursor ( PImage image , int hotspotX , int hotspotY ) { } public void showCursor ( ) { } public void hideCursor ( ) { } public Thread createThread ( ) { return new AnimationThread ( ) ; } public void startThread ( ) { if ( thread == null ) { thread = createThread ( ) ; thread . start ( ) ; } else { throw new IllegalStateException ( "Thread already started in " + getClass ( ) . getSimpleName ( ) ) ; } } public boolean stopThread ( ) { if ( thread == null ) { return false ; } thread = null ; return true ; } public boolean isStopped ( ) { return thread == null ; } public void pauseThread ( ) { PApplet . debug ( "PApplet.run() paused, calling object wait..." ) ; paused = true ; } protected void checkPause ( ) { if ( paused ) { synchronized ( pauseObject ) { try { pauseObject . wait ( ) ; } catch ( InterruptedException e ) { } } } } public void resumeThread ( ) { paused = false ; synchronized ( pauseObject ) { pauseObject . notifyAll ( ) ; } } public void setFrameRate ( float fps ) { frameRateTarget = fps ; frameRatePeriod = ( long ) ( 1000000000.0 / frameRateTarget ) ; } class AnimationThread extends Thread { public AnimationThread ( ) { super ( "Animation Thread" ) ; } public void render ( ) { sketch . handleDraw ( ) ; } @ Override public void run ( ) { long beforeTime = System . nanoTime ( ) ; long overSleepTime = 0L ; int noDelays = 0 ; final int NO_DELAYS_PER_YIELD = 15 ; sketch . start ( ) ; while ( ( Thread . currentThread ( ) == thread ) && ! sketch . finished ) { checkPause ( ) ; render ( ) ; if ( sketch . frameCount == 1 ) { requestFocus ( ) ; } long afterTime = System . nanoTime ( ) ; long timeDiff = afterTime - beforeTime ; long sleepTime = ( frameRatePeriod - timeDiff ) - overSleepTime ; if ( sleepTime > 0 ) { try { Thread . sleep ( sleepTime / 1000000L , ( int ) ( sleepTime % 1000000L ) ) ; noDelays = 0 ; } catch ( InterruptedException ex ) { } overSleepTime = ( System . nanoTime ( ) - afterTime ) - sleepTime ; } else { overSleepTime = 0L ; noDelays ++ ; if ( noDelays > NO_DELAYS_PER_YIELD ) { Thread . yield ( ) ; noDelays = 0 ; } } beforeTime = System . nanoTime ( ) ; } sketch . dispose ( ) ; if ( sketch . exitCalled ) { sketch . exitActual ( ) ; } } } }
package processing . data ; import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . StringWriter ; import java . io . Writer ; import java . lang . reflect . Array ; import java . util . ArrayList ; import processing . core . PApplet ; public class JSONArray { private final ArrayList < Object > myArrayList ; public JSONArray ( ) { this . myArrayList = new ArrayList < Object > ( ) ; } public JSONArray ( Reader reader ) { this ( new JSONTokener ( reader ) ) ; } protected JSONArray ( JSONTokener x ) { this ( ) ; if ( x . nextClean ( ) != '[' ) { throw new RuntimeException ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) != ']' ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) == ',' ) { x . back ( ) ; myArrayList . add ( JSONObject . NULL ) ; } else { x . back ( ) ; myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case ';' : case ',' : if ( x . nextClean ( ) == ']' ) { return ; } x . back ( ) ; break ; case ']' : return ; default : throw new RuntimeException ( "Expected a ',' or ']'" ) ; } } } } public JSONArray ( IntList list ) { myArrayList = new ArrayList < Object > ( ) ; for ( int item : list . values ( ) ) { myArrayList . add ( Integer . valueOf ( item ) ) ; } } public JSONArray ( FloatList list ) { myArrayList = new ArrayList < Object > ( ) ; for ( float item : list . values ( ) ) { myArrayList . add ( new Float ( item ) ) ; } } public JSONArray ( StringList list ) { myArrayList = new ArrayList < Object > ( ) ; for ( String item : list . values ( ) ) { myArrayList . add ( item ) ; } } static public JSONArray parse ( String source ) { try { return new JSONArray ( new JSONTokener ( source ) ) ; } catch ( Exception e ) { return null ; } } protected JSONArray ( Object array ) { this ( ) ; if ( array . getClass ( ) . isArray ( ) ) { int length = Array . getLength ( array ) ; for ( int i = 0 ; i < length ; i += 1 ) { this . append ( JSONObject . wrap ( Array . get ( array , i ) ) ) ; } } else { throw new RuntimeException ( "JSONArray initial value should be a string or collection or array." ) ; } } private Object opt ( int index ) { if ( index < 0 || index >= this . size ( ) ) { return null ; } return myArrayList . get ( index ) ; } private Object get ( int index ) { Object object = opt ( index ) ; if ( object == null ) { throw new RuntimeException ( "JSONArray[" + index + "] not found." ) ; } return object ; } public String getString ( int index ) { Object object = this . get ( index ) ; if ( object instanceof String ) { return ( String ) object ; } throw new RuntimeException ( "JSONArray[" + index + "] not a string." ) ; } public String getString ( int index , String defaultValue ) { Object object = this . opt ( index ) ; return JSONObject . NULL . equals ( object ) ? defaultValue : object . toString ( ) ; } public int getInt ( int index ) { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . intValue ( ) : Integer . parseInt ( ( String ) object ) ; } catch ( Exception e ) { throw new RuntimeException ( "JSONArray[" + index + "] is not a number." ) ; } } public int getInt ( int index , int defaultValue ) { try { return getInt ( index ) ; } catch ( Exception e ) { return defaultValue ; } } public long getLong ( int index ) { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . longValue ( ) : Long . parseLong ( ( String ) object ) ; } catch ( Exception e ) { throw new RuntimeException ( "JSONArray[" + index + "] is not a number." ) ; } } public long getLong ( int index , long defaultValue ) { try { return this . getLong ( index ) ; } catch ( Exception e ) { return defaultValue ; } } public float getFloat ( int index ) { return ( float ) getDouble ( index ) ; } public float getFloat ( int index , float defaultValue ) { try { return getFloat ( index ) ; } catch ( Exception e ) { return defaultValue ; } } public double getDouble ( int index ) { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . doubleValue ( ) : Double . parseDouble ( ( String ) object ) ; } catch ( Exception e ) { throw new RuntimeException ( "JSONArray[" + index + "] is not a number." ) ; } } public double getDouble ( int index , double defaultValue ) { try { return this . getDouble ( index ) ; } catch ( Exception e ) { return defaultValue ; } } public boolean getBoolean ( int index ) { Object object = this . get ( index ) ; if ( object . equals ( Boolean . FALSE ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( Boolean . TRUE ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new RuntimeException ( "JSONArray[" + index + "] is not a boolean." ) ; } public boolean getBoolean ( int index , boolean defaultValue ) { try { return getBoolean ( index ) ; } catch ( Exception e ) { return defaultValue ; } } public JSONArray getJSONArray ( int index ) { Object object = this . get ( index ) ; if ( object instanceof JSONArray ) { return ( JSONArray ) object ; } throw new RuntimeException ( "JSONArray[" + index + "] is not a JSONArray." ) ; } public JSONArray getJSONArray ( int index , JSONArray defaultValue ) { try { return getJSONArray ( index ) ; } catch ( Exception e ) { return defaultValue ; } } public JSONObject getJSONObject ( int index ) { Object object = this . get ( index ) ; if ( object instanceof JSONObject ) { return ( JSONObject ) object ; } throw new RuntimeException ( "JSONArray[" + index + "] is not a JSONObject." ) ; } public JSONObject getJSONObject ( int index , JSONObject defaultValue ) { try { return getJSONObject ( index ) ; } catch ( Exception e ) { return defaultValue ; } } public String [ ] getStringArray ( ) { String [ ] outgoing = new String [ size ( ) ] ; for ( int i = 0 ; i < size ( ) ; i ++ ) { outgoing [ i ] = getString ( i ) ; } return outgoing ; } public int [ ] getIntArray ( ) { int [ ] outgoing = new int [ size ( ) ] ; for ( int i = 0 ; i < size ( ) ; i ++ ) { outgoing [ i ] = getInt ( i ) ; } return outgoing ; } public long [ ] getLongArray ( ) { long [ ] outgoing = new long [ size ( ) ] ; for ( int i = 0 ; i < size ( ) ; i ++ ) { outgoing [ i ] = getLong ( i ) ; } return outgoing ; } public float [ ] getFloatArray ( ) { float [ ] outgoing = new float [ size ( ) ] ; for ( int i = 0 ; i < size ( ) ; i ++ ) { outgoing [ i ] = getFloat ( i ) ; } return outgoing ; } public double [ ] getDoubleArray ( ) { double [ ] outgoing = new double [ size ( ) ] ; for ( int i = 0 ; i < size ( ) ; i ++ ) { outgoing [ i ] = getDouble ( i ) ; } return outgoing ; } public boolean [ ] getBooleanArray ( ) { boolean [ ] outgoing = new boolean [ size ( ) ] ; for ( int i = 0 ; i < size ( ) ; i ++ ) { outgoing [ i ] = getBoolean ( i ) ; } return outgoing ; } public JSONArray append ( String value ) { this . append ( ( Object ) value ) ; return this ; } public JSONArray append ( int value ) { this . append ( Integer . valueOf ( value ) ) ; return this ; } public JSONArray append ( long value ) { this . append ( Long . valueOf ( value ) ) ; return this ; } public JSONArray append ( float value ) { return append ( ( double ) value ) ; } public JSONArray append ( double value ) { Double d = value ; JSONObject . testValidity ( d ) ; this . append ( d ) ; return this ; } public JSONArray append ( boolean value ) { this . append ( value ? Boolean . TRUE : Boolean . FALSE ) ; return this ; } public JSONArray append ( JSONArray value ) { myArrayList . add ( value ) ; return this ; } public JSONArray append ( JSONObject value ) { myArrayList . add ( value ) ; return this ; } protected JSONArray append ( Object value ) { myArrayList . add ( value ) ; return this ; } public JSONArray setString ( int index , String value ) { this . set ( index , value ) ; return this ; } public JSONArray setInt ( int index , int value ) { this . set ( index , Integer . valueOf ( value ) ) ; return this ; } public JSONArray setLong ( int index , long value ) { return set ( index , Long . valueOf ( value ) ) ; } public JSONArray setFloat ( int index , float value ) { return setDouble ( index , value ) ; } public JSONArray setDouble ( int index , double value ) { return set ( index , Double . valueOf ( value ) ) ; } public JSONArray setBoolean ( int index , boolean value ) { return set ( index , value ? Boolean . TRUE : Boolean . FALSE ) ; } public JSONArray setJSONArray ( int index , JSONArray value ) { set ( index , value ) ; return this ; } public JSONArray setJSONObject ( int index , JSONObject value ) { set ( index , value ) ; return this ; } private JSONArray set ( int index , Object value ) { JSONObject . testValidity ( value ) ; if ( index < 0 ) { throw new RuntimeException ( "JSONArray[" + index + "] not found." ) ; } if ( index < this . size ( ) ) { this . myArrayList . set ( index , value ) ; } else { while ( index != this . size ( ) ) { this . append ( JSONObject . NULL ) ; } this . append ( value ) ; } return this ; } public int size ( ) { return myArrayList . size ( ) ; } public boolean isNull ( int index ) { return JSONObject . NULL . equals ( this . opt ( index ) ) ; } public Object remove ( int index ) { Object o = this . opt ( index ) ; this . myArrayList . remove ( index ) ; return o ; } public boolean save ( File file , String options ) { return write ( PApplet . createWriter ( file ) , options ) ; } public boolean write ( PrintWriter output ) { return write ( output , null ) ; } public boolean write ( PrintWriter output , String options ) { int indentFactor = 2 ; if ( options != null ) { String [ ] opts = PApplet . split ( options , ',' ) ; for ( String opt : opts ) { if ( opt . equals ( "compact" ) ) { indentFactor = - 1 ; } else if ( opt . startsWith ( "indent=" ) ) { indentFactor = PApplet . parseInt ( opt . substring ( 7 ) , - 2 ) ; if ( indentFactor == - 2 ) { throw new IllegalArgumentException ( "Could not read a number from " + opt ) ; } } else { System . err . println ( "Ignoring " + opt ) ; } } } output . print ( format ( indentFactor ) ) ; output . flush ( ) ; return true ; } @ Override public String toString ( ) { try { return format ( 2 ) ; } catch ( Exception e ) { return null ; } } public String format ( int indentFactor ) { StringWriter sw = new StringWriter ( ) ; synchronized ( sw . getBuffer ( ) ) { return this . writeInternal ( sw , indentFactor , 0 ) . toString ( ) ; } } protected Writer writeInternal ( Writer writer , int indentFactor , int indent ) { try { boolean commanate = false ; int length = this . size ( ) ; writer . write ( '[' ) ; int thisFactor = ( indentFactor == - 1 ) ? 0 : indentFactor ; if ( length == 1 ) { JSONObject . writeValue ( writer , this . myArrayList . get ( 0 ) , indentFactor , indent ) ; } else if ( length != 0 ) { final int newIndent = indent + thisFactor ; for ( int i = 0 ; i < length ; i += 1 ) { if ( commanate ) { writer . write ( ',' ) ; } if ( indentFactor != - 1 ) { writer . write ( '\n' ) ; } JSONObject . indent ( writer , newIndent ) ; JSONObject . writeValue ( writer , this . myArrayList . get ( i ) , indentFactor , newIndent ) ; commanate = true ; } if ( indentFactor != - 1 ) { writer . write ( '\n' ) ; } JSONObject . indent ( writer , indent ) ; } writer . write ( ']' ) ; return writer ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public String join ( String separator ) { int len = this . size ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < len ; i += 1 ) { if ( i > 0 ) { sb . append ( separator ) ; } sb . append ( JSONObject . valueToString ( this . myArrayList . get ( i ) ) ) ; } return sb . toString ( ) ; } }
package processing . data ; import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . StringWriter ; import java . io . Writer ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import processing . core . PApplet ; public class JSONObject { private static final int keyPoolSize = 100 ; private static HashMap < String , Object > keyPool = new HashMap < String , Object > ( keyPoolSize ) ; private static final class Null { @ Override protected final Object clone ( ) { return this ; } @ Override public boolean equals ( Object object ) { return object == null || object == this ; } @ Override public String toString ( ) { return "null" ; } @ Override public int hashCode ( ) { return super . hashCode ( ) ; } } private final HashMap < String , Object > map ; public static final Object NULL = new Null ( ) ; public JSONObject ( ) { this . map = new HashMap < String , Object > ( ) ; } public JSONObject ( Reader reader ) { this ( new JSONTokener ( reader ) ) ; } protected JSONObject ( JSONTokener x ) { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != '{' ) { throw new RuntimeException ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw new RuntimeException ( "A JSONObject text must end with '}'" ) ; case '}' : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == '=' ) { if ( x . next ( ) != '>' ) { x . back ( ) ; } } else if ( c != ':' ) { throw new RuntimeException ( "Expected a ':' after a key" ) ; } this . putOnce ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ';' : case ',' : if ( x . nextClean ( ) == '}' ) { return ; } x . back ( ) ; break ; case '}' : return ; default : throw new RuntimeException ( "Expected a ',' or '}'" ) ; } } } protected JSONObject ( HashMap < String , Object > map ) { this . map = new HashMap < String , Object > ( ) ; if ( map != null ) { Iterator i = map . entrySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; Object value = e . getValue ( ) ; if ( value != null ) { map . put ( ( String ) e . getKey ( ) , wrap ( value ) ) ; } } } } public JSONObject ( IntDict dict ) { map = new HashMap < String , Object > ( ) ; for ( int i = 0 ; i < dict . size ( ) ; i ++ ) { setInt ( dict . key ( i ) , dict . value ( i ) ) ; } } public JSONObject ( FloatDict dict ) { map = new HashMap < String , Object > ( ) ; for ( int i = 0 ; i < dict . size ( ) ; i ++ ) { setFloat ( dict . key ( i ) , dict . value ( i ) ) ; } } public JSONObject ( StringDict dict ) { map = new HashMap < String , Object > ( ) ; for ( int i = 0 ; i < dict . size ( ) ; i ++ ) { setString ( dict . key ( i ) , dict . value ( i ) ) ; } } protected JSONObject ( Object bean ) { this ( ) ; this . populateMap ( bean ) ; } static public JSONObject parse ( String source ) { return new JSONObject ( new JSONTokener ( source ) ) ; } static protected String doubleToString ( double d ) { if ( Double . isInfinite ( d ) || Double . isNaN ( d ) ) { return "null" ; } String string = Double . toString ( d ) ; if ( string . indexOf ( '.' ) > 0 && string . indexOf ( 'e' ) < 0 && string . indexOf ( 'E' ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; } private Object get ( String key ) { if ( key == null ) { throw new RuntimeException ( "Null key." ) ; } Object object = this . opt ( key ) ; if ( object == null ) { throw new RuntimeException ( "JSONObject[" + quote ( key ) + "] not found." ) ; } return object ; } public String getString ( String key ) { Object object = this . get ( key ) ; if ( object instanceof String ) { return ( String ) object ; } throw new RuntimeException ( "JSONObject[" + quote ( key ) + "] not a string." ) ; } public String getString ( String key , String defaultValue ) { Object object = this . opt ( key ) ; return NULL . equals ( object ) ? defaultValue : object . toString ( ) ; } public int getInt ( String key ) { Object object = this . get ( key ) ; try { return object instanceof Number ? ( ( Number ) object ) . intValue ( ) : Integer . parseInt ( ( String ) object ) ; } catch ( Exception e ) { throw new RuntimeException ( "JSONObject[" + quote ( key ) + "] is not an int." ) ; } } public int getInt ( String key , int defaultValue ) { try { return this . getInt ( key ) ; } catch ( Exception e ) { return defaultValue ; } } public long getLong ( String key ) { Object object = this . get ( key ) ; try { return object instanceof Number ? ( ( Number ) object ) . longValue ( ) : Long . parseLong ( ( String ) object ) ; } catch ( Exception e ) { throw new RuntimeException ( "JSONObject[" + quote ( key ) + "] is not a long." , e ) ; } } public long getLong ( String key , long defaultValue ) { try { return this . getLong ( key ) ; } catch ( Exception e ) { return defaultValue ; } } public float getFloat ( String key ) { return ( float ) getDouble ( key ) ; } public float getFloat ( String key , float defaultValue ) { try { return getFloat ( key ) ; } catch ( Exception e ) { return defaultValue ; } } public double getDouble ( String key ) { Object object = this . get ( key ) ; try { return object instanceof Number ? ( ( Number ) object ) . doubleValue ( ) : Double . parseDouble ( ( String ) object ) ; } catch ( Exception e ) { throw new RuntimeException ( "JSONObject[" + quote ( key ) + "] is not a number." ) ; } } public double getDouble ( String key , double defaultValue ) { try { return this . getDouble ( key ) ; } catch ( Exception e ) { return defaultValue ; } } public boolean getBoolean ( String key ) { Object object = this . get ( key ) ; if ( object . equals ( Boolean . FALSE ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( Boolean . TRUE ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new RuntimeException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; } public boolean getBoolean ( String key , boolean defaultValue ) { try { return this . getBoolean ( key ) ; } catch ( Exception e ) { return defaultValue ; } } public JSONArray getJSONArray ( String key ) { Object object = this . get ( key ) ; if ( object instanceof JSONArray ) { return ( JSONArray ) object ; } throw new RuntimeException ( "JSONObject[" + quote ( key ) + "] is not a JSONArray." ) ; } public JSONObject getJSONObject ( String key ) { Object object = this . get ( key ) ; if ( object instanceof JSONObject ) { return ( JSONObject ) object ; } throw new RuntimeException ( "JSONObject[" + quote ( key ) + "] is not a JSONObject." ) ; } public boolean hasKey ( String key ) { return this . map . containsKey ( key ) ; } public boolean isNull ( String key ) { return JSONObject . NULL . equals ( this . opt ( key ) ) ; } public Iterator keyIterator ( ) { return map . keySet ( ) . iterator ( ) ; } public Set keys ( ) { return this . map . keySet ( ) ; } public int size ( ) { return this . map . size ( ) ; } private static String numberToString ( Number number ) { if ( number == null ) { throw new RuntimeException ( "Null pointer" ) ; } testValidity ( number ) ; String string = number . toString ( ) ; if ( string . indexOf ( '.' ) > 0 && string . indexOf ( 'e' ) < 0 && string . indexOf ( 'E' ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; } private Object opt ( String key ) { return key == null ? null : this . map . get ( key ) ; } private void populateMap ( Object bean ) { Class klass = bean . getClass ( ) ; boolean includeSuperClass = klass . getClassLoader ( ) != null ; Method [ ] methods = includeSuperClass ? klass . getMethods ( ) : klass . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i += 1 ) { try { Method method = methods [ i ] ; if ( Modifier . isPublic ( method . getModifiers ( ) ) ) { String name = method . getName ( ) ; String key = "" ; if ( name . startsWith ( "get" ) ) { if ( "getClass" . equals ( name ) || "getDeclaringClass" . equals ( name ) ) { key = "" ; } else { key = name . substring ( 3 ) ; } } else if ( name . startsWith ( "is" ) ) { key = name . substring ( 2 ) ; } if ( key . length ( ) > 0 && Character . isUpperCase ( key . charAt ( 0 ) ) && method . getParameterTypes ( ) . length == 0 ) { if ( key . length ( ) == 1 ) { key = key . toLowerCase ( ) ; } else if ( ! Character . isUpperCase ( key . charAt ( 1 ) ) ) { key = key . substring ( 0 , 1 ) . toLowerCase ( ) + key . substring ( 1 ) ; } Object result = method . invoke ( bean , ( Object [ ] ) null ) ; if ( result != null ) { this . map . put ( key , wrap ( result ) ) ; } } } } catch ( Exception ignore ) { } } } public JSONObject setString ( String key , String value ) { return put ( key , value ) ; } public JSONObject setInt ( String key , int value ) { this . put ( key , Integer . valueOf ( value ) ) ; return this ; } public JSONObject setLong ( String key , long value ) { this . put ( key , Long . valueOf ( value ) ) ; return this ; } public JSONObject setFloat ( String key , float value ) { this . put ( key , new Double ( value ) ) ; return this ; } public JSONObject setDouble ( String key , double value ) { this . put ( key , new Double ( value ) ) ; return this ; } public JSONObject setBoolean ( String key , boolean value ) { this . put ( key , value ? Boolean . TRUE : Boolean . FALSE ) ; return this ; } public JSONObject setJSONObject ( String key , JSONObject value ) { return put ( key , value ) ; } public JSONObject setJSONArray ( String key , JSONArray value ) { return put ( key , value ) ; } private JSONObject put ( String key , Object value ) { String pooled ; if ( key == null ) { throw new RuntimeException ( "Null key." ) ; } if ( value != null ) { testValidity ( value ) ; pooled = ( String ) keyPool . get ( key ) ; if ( pooled == null ) { if ( keyPool . size ( ) >= keyPoolSize ) { keyPool = new HashMap < String , Object > ( keyPoolSize ) ; } keyPool . put ( key , key ) ; } else { key = pooled ; } this . map . put ( key , value ) ; } else { this . remove ( key ) ; } return this ; } private JSONObject putOnce ( String key , Object value ) { if ( key != null && value != null ) { if ( this . opt ( key ) != null ) { throw new RuntimeException ( "Duplicate key \"" + key + "\"" ) ; } this . put ( key , value ) ; } return this ; } static protected String quote ( String string ) { StringWriter sw = new StringWriter ( ) ; synchronized ( sw . getBuffer ( ) ) { try { return quote ( string , sw ) . toString ( ) ; } catch ( IOException ignored ) { return "" ; } } } static protected Writer quote ( String string , Writer w ) throws IOException { if ( string == null || string . length ( ) == 0 ) { w . write ( "\"\"" ) ; return w ; } char b ; char c = 0 ; String hhhh ; int i ; int len = string . length ( ) ; w . write ( '"' ) ; for ( i = 0 ; i < len ; i += 1 ) { b = c ; c = string . charAt ( i ) ; switch ( c ) { case '\\' : case '"' : w . write ( '\\' ) ; w . write ( c ) ; break ; case '/' : if ( b == '<' ) { w . write ( '\\' ) ; } w . write ( c ) ; break ; case '\b' : w . write ( "\\b" ) ; break ; case '\t' : w . write ( "\\t" ) ; break ; case '\n' : w . write ( "\\n" ) ; break ; case '\f' : w . write ( "\\f" ) ; break ; case '\r' : w . write ( "\\r" ) ; break ; default : if ( c < ' ' || ( c >= '\u0080' && c < '\u00a0' ) || ( c >= '\u2000' && c < '\u2100' ) ) { w . write ( "\\u" ) ; hhhh = Integer . toHexString ( c ) ; w . write ( "0000" , 0 , 4 - hhhh . length ( ) ) ; w . write ( hhhh ) ; } else { w . write ( c ) ; } } } w . write ( '"' ) ; return w ; } public Object remove ( String key ) { return this . map . remove ( key ) ; } static protected Object stringToValue ( String string ) { Double d ; if ( string . equals ( "" ) ) { return string ; } if ( string . equalsIgnoreCase ( "true" ) ) { return Boolean . TRUE ; } if ( string . equalsIgnoreCase ( "false" ) ) { return Boolean . FALSE ; } if ( string . equalsIgnoreCase ( "null" ) ) { return JSONObject . NULL ; } char b = string . charAt ( 0 ) ; if ( ( b >= '0' && b <= '9' ) || b == '.' || b == '-' || b == '+' ) { try { if ( string . indexOf ( '.' ) > - 1 || string . indexOf ( 'e' ) > - 1 || string . indexOf ( 'E' ) > - 1 ) { d = Double . valueOf ( string ) ; if ( ! d . isInfinite ( ) && ! d . isNaN ( ) ) { return d ; } } else { Long myLong = Long . valueOf ( string ) ; if ( myLong . longValue ( ) == myLong . intValue ( ) ) { return Integer . valueOf ( myLong . intValue ( ) ) ; } else { return myLong ; } } } catch ( Exception ignore ) { } } return string ; } static protected void testValidity ( Object o ) { if ( o != null ) { if ( o instanceof Double ) { if ( ( ( Double ) o ) . isInfinite ( ) || ( ( Double ) o ) . isNaN ( ) ) { throw new RuntimeException ( "JSON does not allow non-finite numbers." ) ; } } else if ( o instanceof Float ) { if ( ( ( Float ) o ) . isInfinite ( ) || ( ( Float ) o ) . isNaN ( ) ) { throw new RuntimeException ( "JSON does not allow non-finite numbers." ) ; } } } } public boolean save ( File file , String options ) { return write ( PApplet . createWriter ( file ) , options ) ; } public boolean write ( PrintWriter output ) { return write ( output , null ) ; } public boolean write ( PrintWriter output , String options ) { int indentFactor = 2 ; if ( options != null ) { String [ ] opts = PApplet . split ( options , ',' ) ; for ( String opt : opts ) { if ( opt . equals ( "compact" ) ) { indentFactor = - 1 ; } else if ( opt . startsWith ( "indent=" ) ) { indentFactor = PApplet . parseInt ( opt . substring ( 7 ) , - 2 ) ; if ( indentFactor == - 2 ) { throw new IllegalArgumentException ( "Could not read a number from " + opt ) ; } } else { System . err . println ( "Ignoring " + opt ) ; } } } output . print ( format ( indentFactor ) ) ; output . flush ( ) ; return true ; } @ Override public String toString ( ) { try { return format ( 2 ) ; } catch ( Exception e ) { return null ; } } public String format ( int indentFactor ) { StringWriter w = new StringWriter ( ) ; synchronized ( w . getBuffer ( ) ) { return this . writeInternal ( w , indentFactor , 0 ) . toString ( ) ; } } static protected String valueToString ( Object value ) { if ( value == null || value . equals ( null ) ) { return "null" ; } if ( value instanceof Number ) { return numberToString ( ( Number ) value ) ; } if ( value instanceof Boolean || value instanceof JSONObject || value instanceof JSONArray ) { return value . toString ( ) ; } if ( value instanceof Map ) { return new JSONObject ( value ) . toString ( ) ; } if ( value instanceof Collection ) { return new JSONArray ( value ) . toString ( ) ; } if ( value . getClass ( ) . isArray ( ) ) { return new JSONArray ( value ) . toString ( ) ; } return quote ( value . toString ( ) ) ; } static protected Object wrap ( Object object ) { try { if ( object == null ) { return NULL ; } if ( object instanceof JSONObject || object instanceof JSONArray || NULL . equals ( object ) || object instanceof Byte || object instanceof Character || object instanceof Short || object instanceof Integer || object instanceof Long || object instanceof Boolean || object instanceof Float || object instanceof Double || object instanceof String ) { return object ; } if ( object instanceof Collection ) { return new JSONArray ( object ) ; } if ( object . getClass ( ) . isArray ( ) ) { return new JSONArray ( object ) ; } if ( object instanceof Map ) { return new JSONObject ( object ) ; } Package objectPackage = object . getClass ( ) . getPackage ( ) ; String objectPackageName = objectPackage != null ? objectPackage . getName ( ) : "" ; if ( objectPackageName . startsWith ( "java." ) || objectPackageName . startsWith ( "javax." ) || object . getClass ( ) . getClassLoader ( ) == null ) { return object . toString ( ) ; } return new JSONObject ( object ) ; } catch ( Exception exception ) { return null ; } } static final Writer writeValue ( Writer writer , Object value , int indentFactor , int indent ) throws IOException { if ( value == null || value . equals ( null ) ) { writer . write ( "null" ) ; } else if ( value instanceof JSONObject ) { ( ( JSONObject ) value ) . writeInternal ( writer , indentFactor , indent ) ; } else if ( value instanceof JSONArray ) { ( ( JSONArray ) value ) . writeInternal ( writer , indentFactor , indent ) ; } else if ( value instanceof Map ) { new JSONObject ( value ) . writeInternal ( writer , indentFactor , indent ) ; } else if ( value instanceof Collection ) { new JSONArray ( value ) . writeInternal ( writer , indentFactor , indent ) ; } else if ( value . getClass ( ) . isArray ( ) ) { new JSONArray ( value ) . writeInternal ( writer , indentFactor , indent ) ; } else if ( value instanceof Number ) { writer . write ( numberToString ( ( Number ) value ) ) ; } else if ( value instanceof Boolean ) { writer . write ( value . toString ( ) ) ; } else { quote ( value . toString ( ) , writer ) ; } return writer ; } static final void indent ( Writer writer , int indent ) throws IOException { for ( int i = 0 ; i < indent ; i += 1 ) { writer . write ( ' ' ) ; } } protected Writer writeInternal ( Writer writer , int indentFactor , int indent ) { try { boolean commanate = false ; final int length = this . size ( ) ; Iterator keys = this . keyIterator ( ) ; writer . write ( '{' ) ; int actualFactor = ( indentFactor == - 1 ) ? 0 : indentFactor ; if ( length == 1 ) { Object key = keys . next ( ) ; writer . write ( quote ( key . toString ( ) ) ) ; writer . write ( ':' ) ; if ( actualFactor > 0 ) { writer . write ( ' ' ) ; } writeValue ( writer , this . map . get ( key ) , indentFactor , indent ) ; } else if ( length != 0 ) { final int newIndent = indent + actualFactor ; while ( keys . hasNext ( ) ) { Object key = keys . next ( ) ; if ( commanate ) { writer . write ( ',' ) ; } if ( indentFactor != - 1 ) { writer . write ( '\n' ) ; } indent ( writer , newIndent ) ; writer . write ( quote ( key . toString ( ) ) ) ; writer . write ( ':' ) ; if ( actualFactor > 0 ) { writer . write ( ' ' ) ; } writeValue ( writer , this . map . get ( key ) , indentFactor , newIndent ) ; commanate = true ; } if ( indentFactor != - 1 ) { writer . write ( '\n' ) ; } indent ( writer , indent ) ; } writer . write ( '}' ) ; return writer ; } catch ( IOException exception ) { throw new RuntimeException ( exception ) ; } } }
package processing . data ; import java . io . * ; import java . util . HashMap ; import java . util . Iterator ; import processing . core . PApplet ; public class FloatDict { protected int count ; protected String [ ] keys ; protected float [ ] values ; private HashMap < String , Integer > indices = new HashMap < String , Integer > ( ) ; public FloatDict ( ) { count = 0 ; keys = new String [ 10 ] ; values = new float [ 10 ] ; } public FloatDict ( int length ) { count = 0 ; keys = new String [ length ] ; values = new float [ length ] ; } public FloatDict ( BufferedReader reader ) { String [ ] lines = PApplet . loadStrings ( reader ) ; keys = new String [ lines . length ] ; values = new float [ lines . length ] ; for ( int i = 0 ; i < lines . length ; i ++ ) { String [ ] pieces = PApplet . split ( lines [ i ] , '\t' ) ; if ( pieces . length == 2 ) { keys [ count ] = pieces [ 0 ] ; values [ count ] = PApplet . parseFloat ( pieces [ 1 ] ) ; indices . put ( pieces [ 0 ] , count ) ; count ++ ; } } } public FloatDict ( Object [ ] [ ] pairs ) { count = pairs . length ; this . keys = new String [ count ] ; this . values = new float [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { keys [ i ] = ( String ) pairs [ i ] [ 0 ] ; values [ i ] = ( Float ) pairs [ i ] [ 1 ] ; indices . put ( keys [ i ] , i ) ; } } public FloatDict ( String [ ] keys , float [ ] values ) { if ( keys . length != values . length ) { throw new IllegalArgumentException ( "key and value arrays must be the same length" ) ; } this . keys = keys ; this . values = values ; count = keys . length ; for ( int i = 0 ; i < count ; i ++ ) { indices . put ( keys [ i ] , i ) ; } } public int size ( ) { return count ; } public void clear ( ) { count = 0 ; indices = new HashMap < String , Integer > ( ) ; } public String key ( int index ) { return keys [ index ] ; } protected void crop ( ) { if ( count != keys . length ) { keys = PApplet . subset ( keys , 0 , count ) ; values = PApplet . subset ( values , 0 , count ) ; } } public Iterable < String > keys ( ) { return new Iterable < String > ( ) { @ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { int index = - 1 ; public void remove ( ) { removeIndex ( index ) ; } public String next ( ) { return key ( ++ index ) ; } public boolean hasNext ( ) { return index + 1 < size ( ) ; } } ; } } ; } public String [ ] keyArray ( ) { return keyArray ( null ) ; } public String [ ] keyArray ( String [ ] outgoing ) { if ( outgoing == null || outgoing . length != count ) { outgoing = new String [ count ] ; } System . arraycopy ( keys , 0 , outgoing , 0 , count ) ; return outgoing ; } public float value ( int index ) { return values [ index ] ; } public Iterable < Float > values ( ) { return new Iterable < Float > ( ) { @ Override public Iterator < Float > iterator ( ) { return new Iterator < Float > ( ) { int index = - 1 ; public void remove ( ) { removeIndex ( index ) ; } public Float next ( ) { return value ( ++ index ) ; } public boolean hasNext ( ) { return index + 1 < size ( ) ; } } ; } } ; } public float [ ] valueArray ( ) { return valueArray ( null ) ; } public float [ ] valueArray ( float [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new float [ count ] ; } System . arraycopy ( values , 0 , array , 0 , count ) ; return array ; } public float get ( String key ) { int index = index ( key ) ; if ( index == - 1 ) { throw new IllegalArgumentException ( "No key named '" + key + "'" ) ; } return values [ index ] ; } public float get ( String key , float alternate ) { int index = index ( key ) ; if ( index == - 1 ) { return alternate ; } return values [ index ] ; } public void set ( String key , float amount ) { int index = index ( key ) ; if ( index == - 1 ) { create ( key , amount ) ; } else { values [ index ] = amount ; } } public boolean hasKey ( String key ) { return index ( key ) != - 1 ; } public void add ( String key , float amount ) { int index = index ( key ) ; if ( index == - 1 ) { create ( key , amount ) ; } else { values [ index ] += amount ; } } public void sub ( String key , float amount ) { add ( key , - amount ) ; } public void mult ( String key , float amount ) { int index = index ( key ) ; if ( index != - 1 ) { values [ index ] *= amount ; } } public void div ( String key , float amount ) { int index = index ( key ) ; if ( index != - 1 ) { values [ index ] /= amount ; } } private void checkMinMax ( String functionName ) { if ( count == 0 ) { String msg = String . format ( "Cannot use %s() on an empty %s." , functionName , getClass ( ) . getSimpleName ( ) ) ; throw new RuntimeException ( msg ) ; } } public int minIndex ( ) { checkMinMax ( "minIndex" ) ; float m = Float . NaN ; int mi = - 1 ; for ( int i = 0 ; i < count ; i ++ ) { if ( values [ i ] == values [ i ] ) { m = values [ i ] ; mi = i ; for ( int j = i + 1 ; j < count ; j ++ ) { float d = values [ j ] ; if ( ! Float . isNaN ( d ) && ( d < m ) ) { m = values [ j ] ; mi = j ; } } break ; } } return mi ; } public String minKey ( ) { checkMinMax ( "minKey" ) ; int index = minIndex ( ) ; if ( index == - 1 ) { return null ; } return keys [ index ] ; } public float minValue ( ) { checkMinMax ( "minValue" ) ; int index = minIndex ( ) ; if ( index == - 1 ) { return Float . NaN ; } return values [ index ] ; } public int maxIndex ( ) { checkMinMax ( "maxIndex" ) ; float m = Float . NaN ; int mi = - 1 ; for ( int i = 0 ; i < count ; i ++ ) { if ( values [ i ] == values [ i ] ) { m = values [ i ] ; mi = i ; for ( int j = i + 1 ; j < count ; j ++ ) { float d = values [ j ] ; if ( ! Float . isNaN ( d ) && ( d > m ) ) { m = values [ j ] ; mi = j ; } } break ; } } return mi ; } public String maxKey ( ) { checkMinMax ( "maxKey" ) ; int index = maxIndex ( ) ; if ( index == - 1 ) { return null ; } return keys [ index ] ; } public float maxValue ( ) { checkMinMax ( "maxValue" ) ; int index = maxIndex ( ) ; if ( index == - 1 ) { return Float . NaN ; } return values [ index ] ; } public int index ( String what ) { Integer found = indices . get ( what ) ; return ( found == null ) ? - 1 : found . intValue ( ) ; } protected void create ( String what , float much ) { if ( count == keys . length ) { keys = PApplet . expand ( keys ) ; values = PApplet . expand ( values ) ; } indices . put ( what , Integer . valueOf ( count ) ) ; keys [ count ] = what ; values [ count ] = much ; count ++ ; } public int remove ( String key ) { int index = index ( key ) ; if ( index != - 1 ) { removeIndex ( index ) ; } return index ; } public String removeIndex ( int index ) { if ( index < 0 || index >= count ) { throw new ArrayIndexOutOfBoundsException ( index ) ; } String key = keys [ index ] ; indices . remove ( keys [ index ] ) ; for ( int i = index ; i < count - 1 ; i ++ ) { keys [ i ] = keys [ i + 1 ] ; values [ i ] = values [ i + 1 ] ; indices . put ( keys [ i ] , i ) ; } count -- ; keys [ count ] = null ; values [ count ] = 0 ; return key ; } public void swap ( int a , int b ) { String tkey = keys [ a ] ; float tvalue = values [ a ] ; keys [ a ] = keys [ b ] ; values [ a ] = values [ b ] ; keys [ b ] = tkey ; values [ b ] = tvalue ; indices . put ( keys [ a ] , Integer . valueOf ( a ) ) ; indices . put ( keys [ b ] , Integer . valueOf ( b ) ) ; } public void sortKeys ( ) { sortImpl ( true , false ) ; } public void sortKeysReverse ( ) { sortImpl ( true , true ) ; } public void sortValues ( ) { sortImpl ( false , false ) ; } public void sortValuesReverse ( ) { sortImpl ( false , true ) ; } protected void sortImpl ( final boolean useKeys , final boolean reverse ) { Sort s = new Sort ( ) { @ Override public int size ( ) { if ( useKeys ) { return count ; } else if ( count == 0 ) { return 0 ; } else { int right = count - 1 ; while ( values [ right ] != values [ right ] ) { right -- ; if ( right == - 1 ) { return 0 ; } } for ( int i = right ; i >= 0 ; -- i ) { if ( Float . isNaN ( values [ i ] ) ) { swap ( i , right ) ; -- right ; } } return right + 1 ; } } @ Override public float compare ( int a , int b ) { float diff = 0 ; if ( useKeys ) { diff = keys [ a ] . compareToIgnoreCase ( keys [ b ] ) ; if ( diff == 0 ) { return values [ a ] - values [ b ] ; } } else { diff = values [ a ] - values [ b ] ; if ( diff == 0 ) { diff = keys [ a ] . compareToIgnoreCase ( keys [ b ] ) ; } } return reverse ? - diff : diff ; } @ Override public void swap ( int a , int b ) { FloatDict . this . swap ( a , b ) ; } } ; s . run ( ) ; } public FloatDict getPercent ( ) { double sum = 0 ; for ( float value : valueArray ( ) ) { sum += value ; } FloatDict outgoing = new FloatDict ( ) ; for ( int i = 0 ; i < size ( ) ; i ++ ) { double percent = value ( i ) / sum ; outgoing . set ( key ( i ) , ( float ) percent ) ; } return outgoing ; } public FloatDict copy ( ) { FloatDict outgoing = new FloatDict ( count ) ; System . arraycopy ( keys , 0 , outgoing . keys , 0 , count ) ; System . arraycopy ( values , 0 , outgoing . values , 0 , count ) ; for ( int i = 0 ; i < count ; i ++ ) { outgoing . indices . put ( keys [ i ] , i ) ; } outgoing . count = count ; return outgoing ; } public void print ( ) { for ( int i = 0 ; i < size ( ) ; i ++ ) { System . out . println ( keys [ i ] + " = " + values [ i ] ) ; } } public void write ( PrintWriter writer ) { for ( int i = 0 ; i < count ; i ++ ) { writer . println ( keys [ i ] + "\t" + values [ i ] ) ; } writer . flush ( ) ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getSimpleName ( ) + " size=" + size ( ) + " { " ) ; for ( int i = 0 ; i < size ( ) ; i ++ ) { if ( i != 0 ) { sb . append ( ", " ) ; } sb . append ( "\"" + keys [ i ] + "\": " + values [ i ] ) ; } sb . append ( " }" ) ; return sb . toString ( ) ; } }
package processing . data ; import java . io . * ; import javax . xml . parsers . * ; import org . w3c . dom . * ; import org . xml . sax . * ; import javax . xml . transform . * ; import javax . xml . transform . dom . * ; import javax . xml . transform . stream . * ; import javax . xml . xpath . XPathConstants ; import javax . xml . xpath . XPathExpression ; import javax . xml . xpath . XPathFactory ; import processing . core . PApplet ; public class XML implements Serializable { protected Node node ; protected XML parent ; protected XML [ ] children ; protected XML ( ) { } public XML ( File file ) throws IOException , ParserConfigurationException , SAXException { this ( file , null ) ; } public XML ( File file , String options ) throws IOException , ParserConfigurationException , SAXException { this ( PApplet . createReader ( file ) , options ) ; } public XML ( InputStream input ) throws IOException , ParserConfigurationException , SAXException { this ( input , null ) ; } public XML ( InputStream input , String options ) throws IOException , ParserConfigurationException , SAXException { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; try { factory . setAttribute ( "http://apache.org/xml/features/nonvalidating/load-external-dtd" , false ) ; } catch ( IllegalArgumentException e ) { } factory . setExpandEntityReferences ( false ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Document document = builder . parse ( new InputSource ( input ) ) ; node = document . getDocumentElement ( ) ; } public XML ( Reader reader ) throws IOException , ParserConfigurationException , SAXException { this ( reader , null ) ; } public XML ( final Reader reader , String options ) throws IOException , ParserConfigurationException , SAXException { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; try { factory . setAttribute ( "http://apache.org/xml/features/nonvalidating/load-external-dtd" , false ) ; } catch ( IllegalArgumentException e ) { } factory . setExpandEntityReferences ( false ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Document document = builder . parse ( new InputSource ( new Reader ( ) { @ Override public int read ( char [ ] cbuf , int off , int len ) throws IOException { int count = reader . read ( cbuf , off , len ) ; for ( int i = 0 ; i < count ; i ++ ) { if ( cbuf [ off + i ] == '\u2028' ) { cbuf [ off + i ] = '\n' ; } } return count ; } @ Override public void close ( ) throws IOException { reader . close ( ) ; } } ) ) ; node = document . getDocumentElement ( ) ; } public XML ( String name ) { try { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Document document = builder . newDocument ( ) ; node = document . createElement ( name ) ; this . parent = null ; } catch ( ParserConfigurationException pce ) { throw new RuntimeException ( pce ) ; } } protected XML ( XML parent , Node node ) { this . node = node ; this . parent = parent ; } static public XML parse ( String data ) throws IOException , ParserConfigurationException , SAXException { return XML . parse ( data , null ) ; } static public XML parse ( String data , String options ) throws IOException , ParserConfigurationException , SAXException { return new XML ( new StringReader ( data ) , null ) ; } public boolean save ( File file ) { return save ( file , null ) ; } public boolean save ( File file , String options ) { PrintWriter writer = PApplet . createWriter ( file ) ; boolean result = write ( writer ) ; writer . flush ( ) ; writer . close ( ) ; return result ; } public boolean write ( PrintWriter output ) { output . print ( format ( 2 ) ) ; output . flush ( ) ; return true ; } public XML getParent ( ) { return this . parent ; } protected Object getNative ( ) { return node ; } public String getName ( ) { return node . getNodeName ( ) ; } public void setName ( String newName ) { Document document = node . getOwnerDocument ( ) ; node = document . renameNode ( node , null , newName ) ; } public String getLocalName ( ) { return node . getLocalName ( ) ; } protected void checkChildren ( ) { if ( children == null ) { NodeList kids = node . getChildNodes ( ) ; int childCount = kids . getLength ( ) ; children = new XML [ childCount ] ; for ( int i = 0 ; i < childCount ; i ++ ) { children [ i ] = new XML ( this , kids . item ( i ) ) ; } } } public int getChildCount ( ) { checkChildren ( ) ; return children . length ; } public boolean hasChildren ( ) { checkChildren ( ) ; return children . length > 0 ; } public String [ ] listChildren ( ) { checkChildren ( ) ; String [ ] outgoing = new String [ children . length ] ; for ( int i = 0 ; i < children . length ; i ++ ) { outgoing [ i ] = children [ i ] . getName ( ) ; } return outgoing ; } public XML [ ] getChildren ( ) { checkChildren ( ) ; return children ; } public XML getChild ( int index ) { checkChildren ( ) ; return children [ index ] ; } public XML getChild ( String name ) { if ( name . length ( ) > 0 && name . charAt ( 0 ) == '/' ) { throw new IllegalArgumentException ( "getChild() should not begin with a slash" ) ; } if ( name . indexOf ( '/' ) != - 1 ) { return getChildRecursive ( PApplet . split ( name , '/' ) , 0 ) ; } int childCount = getChildCount ( ) ; for ( int i = 0 ; i < childCount ; i ++ ) { XML kid = getChild ( i ) ; String kidName = kid . getName ( ) ; if ( kidName != null && kidName . equals ( name ) ) { return kid ; } } return null ; } protected XML getChildRecursive ( String [ ] items , int offset ) { if ( Character . isDigit ( items [ offset ] . charAt ( 0 ) ) ) { XML kid = getChild ( Integer . parseInt ( items [ offset ] ) ) ; if ( offset == items . length - 1 ) { return kid ; } else { return kid . getChildRecursive ( items , offset + 1 ) ; } } int childCount = getChildCount ( ) ; for ( int i = 0 ; i < childCount ; i ++ ) { XML kid = getChild ( i ) ; String kidName = kid . getName ( ) ; if ( kidName != null && kidName . equals ( items [ offset ] ) ) { if ( offset == items . length - 1 ) { return kid ; } else { return kid . getChildRecursive ( items , offset + 1 ) ; } } } return null ; } public XML [ ] getChildren ( String name ) { if ( name . length ( ) > 0 && name . charAt ( 0 ) == '/' ) { throw new IllegalArgumentException ( "getChildren() should not begin with a slash" ) ; } if ( name . indexOf ( '/' ) != - 1 ) { return getChildrenRecursive ( PApplet . split ( name , '/' ) , 0 ) ; } if ( Character . isDigit ( name . charAt ( 0 ) ) ) { return new XML [ ] { getChild ( Integer . parseInt ( name ) ) } ; } int childCount = getChildCount ( ) ; XML [ ] matches = new XML [ childCount ] ; int matchCount = 0 ; for ( int i = 0 ; i < childCount ; i ++ ) { XML kid = getChild ( i ) ; String kidName = kid . getName ( ) ; if ( kidName != null && kidName . equals ( name ) ) { matches [ matchCount ++ ] = kid ; } } return ( XML [ ] ) PApplet . subset ( matches , 0 , matchCount ) ; } protected XML [ ] getChildrenRecursive ( String [ ] items , int offset ) { if ( offset == items . length - 1 ) { return getChildren ( items [ offset ] ) ; } XML [ ] matches = getChildren ( items [ offset ] ) ; XML [ ] outgoing = new XML [ 0 ] ; for ( int i = 0 ; i < matches . length ; i ++ ) { XML [ ] kidMatches = matches [ i ] . getChildrenRecursive ( items , offset + 1 ) ; outgoing = ( XML [ ] ) PApplet . concat ( outgoing , kidMatches ) ; } return outgoing ; } public XML addChild ( String tag ) { Document document = node . getOwnerDocument ( ) ; Node newChild = document . createElement ( tag ) ; return appendChild ( newChild ) ; } public XML addChild ( XML child ) { Document document = node . getOwnerDocument ( ) ; Node newChild = document . importNode ( ( Node ) child . getNative ( ) , true ) ; return appendChild ( newChild ) ; } protected XML appendChild ( Node newNode ) { node . appendChild ( newNode ) ; XML newbie = new XML ( this , newNode ) ; if ( children != null ) { children = ( XML [ ] ) PApplet . concat ( children , new XML [ ] { newbie } ) ; } return newbie ; } public void removeChild ( XML kid ) { node . removeChild ( kid . node ) ; children = null ; } public void trim ( ) { try { XPathFactory xpathFactory = XPathFactory . newInstance ( ) ; XPathExpression xpathExp = xpathFactory . newXPath ( ) . compile ( "//text()[normalize-space(.) = '']" ) ; NodeList emptyTextNodes = ( NodeList ) xpathExp . evaluate ( node , XPathConstants . NODESET ) ; for ( int i = 0 ; i < emptyTextNodes . getLength ( ) ; i ++ ) { Node emptyTextNode = emptyTextNodes . item ( i ) ; emptyTextNode . getParentNode ( ) . removeChild ( emptyTextNode ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public int getAttributeCount ( ) { return node . getAttributes ( ) . getLength ( ) ; } public String [ ] listAttributes ( ) { NamedNodeMap nnm = node . getAttributes ( ) ; String [ ] outgoing = new String [ nnm . getLength ( ) ] ; for ( int i = 0 ; i < outgoing . length ; i ++ ) { outgoing [ i ] = nnm . item ( i ) . getNodeName ( ) ; } return outgoing ; } public boolean hasAttribute ( String name ) { return ( node . getAttributes ( ) . getNamedItem ( name ) != null ) ; } public String getString ( String name ) { return getString ( name , null ) ; } public String getString ( String name , String defaultValue ) { NamedNodeMap attrs = node . getAttributes ( ) ; if ( attrs != null ) { Node attr = attrs . getNamedItem ( name ) ; if ( attr != null ) { return attr . getNodeValue ( ) ; } } return defaultValue ; } public void setString ( String name , String value ) { ( ( Element ) node ) . setAttribute ( name , value ) ; } public int getInt ( String name ) { return getInt ( name , 0 ) ; } public void setInt ( String name , int value ) { setString ( name , String . valueOf ( value ) ) ; } public int getInt ( String name , int defaultValue ) { String value = getString ( name ) ; return ( value == null ) ? defaultValue : Integer . parseInt ( value ) ; } public void setLong ( String name , long value ) { setString ( name , String . valueOf ( value ) ) ; } public long getLong ( String name , long defaultValue ) { String value = getString ( name ) ; return ( value == null ) ? defaultValue : Long . parseLong ( value ) ; } public float getFloat ( String name ) { return getFloat ( name , 0 ) ; } public float getFloat ( String name , float defaultValue ) { String value = getString ( name ) ; return ( value == null ) ? defaultValue : Float . parseFloat ( value ) ; } public void setFloat ( String name , float value ) { setString ( name , String . valueOf ( value ) ) ; } public double getDouble ( String name ) { return getDouble ( name , 0 ) ; } public double getDouble ( String name , double defaultValue ) { String value = getString ( name ) ; return ( value == null ) ? defaultValue : Double . parseDouble ( value ) ; } public void setDouble ( String name , double value ) { setString ( name , String . valueOf ( value ) ) ; } public String getContent ( ) { return node . getTextContent ( ) ; } public String getContent ( String defaultValue ) { String s = node . getTextContent ( ) ; return ( s != null ) ? s : defaultValue ; } public int getIntContent ( ) { return getIntContent ( 0 ) ; } public int getIntContent ( int defaultValue ) { return PApplet . parseInt ( node . getTextContent ( ) , defaultValue ) ; } public float getFloatContent ( ) { return getFloatContent ( 0 ) ; } public float getFloatContent ( float defaultValue ) { return PApplet . parseFloat ( node . getTextContent ( ) , defaultValue ) ; } public long getLongContent ( ) { return getLongContent ( 0 ) ; } public long getLongContent ( long defaultValue ) { String c = node . getTextContent ( ) ; if ( c != null ) { try { return Long . parseLong ( c ) ; } catch ( NumberFormatException nfe ) { } } return defaultValue ; } public double getDoubleContent ( ) { return getDoubleContent ( 0 ) ; } public double getDoubleContent ( double defaultValue ) { String c = node . getTextContent ( ) ; if ( c != null ) { try { return Double . parseDouble ( c ) ; } catch ( NumberFormatException nfe ) { } } return defaultValue ; } public void setContent ( String text ) { node . setTextContent ( text ) ; } public void setIntContent ( int value ) { setContent ( String . valueOf ( value ) ) ; } public void setFloatContent ( float value ) { setContent ( String . valueOf ( value ) ) ; } public void setLongContent ( long value ) { setContent ( String . valueOf ( value ) ) ; } public void setDoubleContent ( double value ) { setContent ( String . valueOf ( value ) ) ; } public String format ( int indent ) { try { boolean useIndentAmount = false ; TransformerFactory factory = TransformerFactory . newInstance ( ) ; if ( indent != - 1 ) { try { factory . setAttribute ( "indent-number" , indent ) ; } catch ( IllegalArgumentException e ) { useIndentAmount = true ; } } Transformer transformer = factory . newTransformer ( ) ; if ( indent == - 1 || parent == null ) { transformer . setOutputProperty ( OutputKeys . OMIT_XML_DECLARATION , "yes" ) ; } else { transformer . setOutputProperty ( OutputKeys . OMIT_XML_DECLARATION , "no" ) ; } transformer . setOutputProperty ( OutputKeys . METHOD , "xml" ) ; if ( useIndentAmount ) { transformer . setOutputProperty ( "{http://xml.apache.org/xslt}indent-amount" , String . valueOf ( indent ) ) ; } transformer . setOutputProperty ( OutputKeys . ENCODING , "UTF-8" ) ; transformer . setOutputProperty ( OutputKeys . INDENT , "yes" ) ; final String decl = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ; final String sep = System . getProperty ( "line.separator" ) ; StringWriter tempWriter = new StringWriter ( ) ; StreamResult tempResult = new StreamResult ( tempWriter ) ; transformer . transform ( new DOMSource ( node ) , tempResult ) ; String [ ] tempLines = PApplet . split ( tempWriter . toString ( ) , sep ) ; if ( tempLines [ 0 ] . startsWith ( "<?xml" ) ) { int declEnd = tempLines [ 0 ] . indexOf ( "?>" ) + 2 ; if ( tempLines [ 0 ] . length ( ) == declEnd ) { tempLines = PApplet . subset ( tempLines , 1 ) ; } else { tempLines [ 0 ] = tempLines [ 0 ] . substring ( declEnd ) ; } } String singleLine = PApplet . join ( PApplet . trim ( tempLines ) , "" ) ; if ( indent == - 1 ) { return singleLine ; } if ( singleLine . trim ( ) . length ( ) == 0 ) { return decl + sep + singleLine ; } StringWriter stringWriter = new StringWriter ( ) ; StreamResult xmlOutput = new StreamResult ( stringWriter ) ; Source source = new StreamSource ( new StringReader ( singleLine ) ) ; transformer . transform ( source , xmlOutput ) ; String outgoing = stringWriter . toString ( ) ; if ( ! outgoing . startsWith ( decl ) ) { return decl + sep + outgoing ; } else { return outgoing ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } @ Override public String toString ( ) { return format ( - 1 ) ; } }
package processing . data ; import java . util . Arrays ; import java . util . Iterator ; import java . util . Random ; import processing . core . PApplet ; public class FloatList implements Iterable < Float > { int count ; float [ ] data ; public FloatList ( ) { data = new float [ 10 ] ; } public FloatList ( int length ) { data = new float [ length ] ; } public FloatList ( float [ ] list ) { count = list . length ; data = new float [ count ] ; System . arraycopy ( list , 0 , data , 0 , count ) ; } public FloatList ( Iterable < Object > iter ) { this ( 10 ) ; for ( Object o : iter ) { if ( o == null ) { append ( Float . NaN ) ; } else if ( o instanceof Number ) { append ( ( ( Number ) o ) . floatValue ( ) ) ; } else { append ( PApplet . parseFloat ( o . toString ( ) . trim ( ) ) ) ; } } crop ( ) ; } public FloatList ( Object ... items ) { final float missingValue = Float . NaN ; count = items . length ; data = new float [ count ] ; int index = 0 ; for ( Object o : items ) { float value = missingValue ; if ( o != null ) { if ( o instanceof Number ) { value = ( ( Number ) o ) . floatValue ( ) ; } else { value = PApplet . parseFloat ( o . toString ( ) . trim ( ) , missingValue ) ; } } data [ index ++ ] = value ; } } private void crop ( ) { if ( count != data . length ) { data = PApplet . subset ( data , 0 , count ) ; } } public int size ( ) { return count ; } public void resize ( int length ) { if ( length > data . length ) { float [ ] temp = new float [ length ] ; System . arraycopy ( data , 0 , temp , 0 , count ) ; data = temp ; } else if ( length > count ) { Arrays . fill ( data , count , length , 0 ) ; } count = length ; } public void clear ( ) { count = 0 ; } public float get ( int index ) { if ( index >= count ) { throw new ArrayIndexOutOfBoundsException ( index ) ; } return data [ index ] ; } public void set ( int index , float what ) { if ( index >= count ) { data = PApplet . expand ( data , index + 1 ) ; for ( int i = count ; i < index ; i ++ ) { data [ i ] = 0 ; } count = index + 1 ; } data [ index ] = what ; } public void push ( float value ) { append ( value ) ; } public float pop ( ) { if ( count == 0 ) { throw new RuntimeException ( "Can't call pop() on an empty list" ) ; } float value = get ( count - 1 ) ; count -- ; return value ; } public float remove ( int index ) { if ( index < 0 || index >= count ) { throw new ArrayIndexOutOfBoundsException ( index ) ; } float entry = data [ index ] ; for ( int i = index ; i < count - 1 ; i ++ ) { data [ i ] = data [ i + 1 ] ; } count -- ; return entry ; } public int removeValue ( int value ) { int index = index ( value ) ; if ( index != - 1 ) { remove ( index ) ; return index ; } return - 1 ; } public int removeValues ( int value ) { int ii = 0 ; if ( Float . isNaN ( value ) ) { for ( int i = 0 ; i < count ; i ++ ) { if ( ! Float . isNaN ( data [ i ] ) ) { data [ ii ++ ] = data [ i ] ; } } } else { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] != value ) { data [ ii ++ ] = data [ i ] ; } } } int removed = count - ii ; count = ii ; return removed ; } public boolean replaceValue ( float value , float newValue ) { if ( Float . isNaN ( value ) ) { for ( int i = 0 ; i < count ; i ++ ) { if ( Float . isNaN ( data [ i ] ) ) { data [ i ] = newValue ; return true ; } } } else { int index = index ( value ) ; if ( index != - 1 ) { data [ index ] = newValue ; return true ; } } return false ; } public boolean replaceValues ( float value , float newValue ) { boolean changed = false ; if ( Float . isNaN ( value ) ) { for ( int i = 0 ; i < count ; i ++ ) { if ( Float . isNaN ( data [ i ] ) ) { data [ i ] = newValue ; changed = true ; } } } else { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] == value ) { data [ i ] = newValue ; changed = true ; } } } return changed ; } public void append ( float value ) { if ( count == data . length ) { data = PApplet . expand ( data ) ; } data [ count ++ ] = value ; } public void append ( float [ ] values ) { for ( float v : values ) { append ( v ) ; } } public void append ( FloatList list ) { for ( float v : list . values ( ) ) { append ( v ) ; } } public void appendUnique ( float value ) { if ( ! hasValue ( value ) ) { append ( value ) ; } } public void insert ( int index , float value ) { insert ( index , new float [ ] { value } ) ; } public void insert ( int index , float [ ] values ) { if ( index < 0 ) { throw new IllegalArgumentException ( "insert() index cannot be negative: it was " + index ) ; } if ( index >= data . length ) { throw new IllegalArgumentException ( "insert() index " + index + " is past the end of this list" ) ; } float [ ] temp = new float [ count + values . length ] ; System . arraycopy ( data , 0 , temp , 0 , Math . min ( count , index ) ) ; System . arraycopy ( values , 0 , temp , index , values . length ) ; System . arraycopy ( data , index , temp , index + values . length , count - index ) ; count = count + values . length ; data = temp ; } public void insert ( int index , FloatList list ) { insert ( index , list . values ( ) ) ; } public int index ( float what ) { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] == what ) { return i ; } } return - 1 ; } public boolean hasValue ( float value ) { if ( Float . isNaN ( value ) ) { for ( int i = 0 ; i < count ; i ++ ) { if ( Float . isNaN ( data [ i ] ) ) { return true ; } } } else { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] == value ) { return true ; } } } return false ; } private void boundsProblem ( int index , String method ) { final String msg = String . format ( "The list size is %d. " + "You cannot %s() to element %d." , count , method , index ) ; throw new ArrayIndexOutOfBoundsException ( msg ) ; } public void add ( int index , float amount ) { if ( index < count ) { data [ index ] += amount ; } else { boundsProblem ( index , "add" ) ; } } public void sub ( int index , float amount ) { if ( index < count ) { data [ index ] -= amount ; } else { boundsProblem ( index , "sub" ) ; } } public void mult ( int index , float amount ) { if ( index < count ) { data [ index ] *= amount ; } else { boundsProblem ( index , "mult" ) ; } } public void div ( int index , float amount ) { if ( index < count ) { data [ index ] /= amount ; } else { boundsProblem ( index , "div" ) ; } } private void checkMinMax ( String functionName ) { if ( count == 0 ) { String msg = String . format ( "Cannot use %s() on an empty %s." , functionName , getClass ( ) . getSimpleName ( ) ) ; throw new RuntimeException ( msg ) ; } } public float min ( ) { checkMinMax ( "min" ) ; int index = minIndex ( ) ; return index == - 1 ? Float . NaN : data [ index ] ; } public int minIndex ( ) { checkMinMax ( "minIndex" ) ; float m = Float . NaN ; int mi = - 1 ; for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] == data [ i ] ) { m = data [ i ] ; mi = i ; for ( int j = i + 1 ; j < count ; j ++ ) { float d = data [ j ] ; if ( ! Float . isNaN ( d ) && ( d < m ) ) { m = data [ j ] ; mi = j ; } } break ; } } return mi ; } public float max ( ) { checkMinMax ( "max" ) ; int index = maxIndex ( ) ; return index == - 1 ? Float . NaN : data [ index ] ; } public int maxIndex ( ) { checkMinMax ( "maxIndex" ) ; float m = Float . NaN ; int mi = - 1 ; for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] == data [ i ] ) { m = data [ i ] ; mi = i ; for ( int j = i + 1 ; j < count ; j ++ ) { float d = data [ j ] ; if ( ! Float . isNaN ( d ) && ( d > m ) ) { m = data [ j ] ; mi = j ; } } break ; } } return mi ; } public float sum ( ) { double outgoing = 0 ; for ( int i = 0 ; i < count ; i ++ ) { outgoing += data [ i ] ; } return ( float ) outgoing ; } public void sort ( ) { Arrays . sort ( data , 0 , count ) ; } public void sortReverse ( ) { new Sort ( ) { @ Override public int size ( ) { if ( count == 0 ) { return 0 ; } int right = count - 1 ; while ( data [ right ] != data [ right ] ) { right -- ; if ( right == - 1 ) { return 0 ; } } for ( int i = right ; i >= 0 ; -- i ) { float v = data [ i ] ; if ( v != v ) { data [ i ] = data [ right ] ; data [ right ] = v ; -- right ; } } return right + 1 ; } @ Override public float compare ( int a , int b ) { return data [ b ] - data [ a ] ; } @ Override public void swap ( int a , int b ) { float temp = data [ a ] ; data [ a ] = data [ b ] ; data [ b ] = temp ; } } . run ( ) ; } public void reverse ( ) { int ii = count - 1 ; for ( int i = 0 ; i < count / 2 ; i ++ ) { float t = data [ i ] ; data [ i ] = data [ ii ] ; data [ ii ] = t ; -- ii ; } } public void shuffle ( ) { Random r = new Random ( ) ; int num = count ; while ( num > 1 ) { int value = r . nextInt ( num ) ; num -- ; float temp = data [ num ] ; data [ num ] = data [ value ] ; data [ value ] = temp ; } } public void shuffle ( PApplet sketch ) { int num = count ; while ( num > 1 ) { int value = ( int ) sketch . random ( num ) ; num -- ; float temp = data [ num ] ; data [ num ] = data [ value ] ; data [ value ] = temp ; } } public FloatList copy ( ) { FloatList outgoing = new FloatList ( data ) ; outgoing . count = count ; return outgoing ; } public float [ ] values ( ) { crop ( ) ; return data ; } @ Override public Iterator < Float > iterator ( ) { return new Iterator < Float > ( ) { int index = - 1 ; public void remove ( ) { FloatList . this . remove ( index ) ; } public Float next ( ) { return data [ ++ index ] ; } public boolean hasNext ( ) { return index + 1 < count ; } } ; } public float [ ] array ( ) { return array ( null ) ; } public float [ ] array ( float [ ] array ) { if ( array == null || array . length != count ) { array = new float [ count ] ; } System . arraycopy ( data , 0 , array , 0 , count ) ; return array ; } public FloatList getPercent ( ) { double sum = 0 ; for ( float value : array ( ) ) { sum += value ; } FloatList outgoing = new FloatList ( count ) ; for ( int i = 0 ; i < count ; i ++ ) { double percent = data [ i ] / sum ; outgoing . set ( i , ( float ) percent ) ; } return outgoing ; } public FloatList getSubset ( int start ) { return getSubset ( start , count - start ) ; } public FloatList getSubset ( int start , int num ) { float [ ] subset = new float [ num ] ; System . arraycopy ( data , start , subset , 0 , num ) ; return new FloatList ( subset ) ; } public String join ( String separator ) { if ( count == 0 ) { return "" ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( data [ 0 ] ) ; for ( int i = 1 ; i < count ; i ++ ) { sb . append ( separator ) ; sb . append ( data [ i ] ) ; } return sb . toString ( ) ; } public void print ( ) { for ( int i = 0 ; i < size ( ) ; i ++ ) { System . out . format ( "[%d] %f%n" , i , data [ i ] ) ; } } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getSimpleName ( ) + " size=" + size ( ) + " [ " ) ; for ( int i = 0 ; i < size ( ) ; i ++ ) { if ( i != 0 ) { sb . append ( ", " ) ; } sb . append ( i + ": " + data [ i ] ) ; } sb . append ( " ]" ) ; return sb . toString ( ) ; } }
package processing . data ; import java . util . Arrays ; import java . util . Iterator ; import java . util . Random ; import processing . core . PApplet ; public class StringList implements Iterable < String > { int count ; String [ ] data ; public StringList ( ) { this ( 10 ) ; } public StringList ( int length ) { data = new String [ length ] ; } public StringList ( String [ ] list ) { count = list . length ; data = new String [ count ] ; System . arraycopy ( list , 0 , data , 0 , count ) ; } public StringList ( Object ... items ) { count = items . length ; data = new String [ count ] ; int index = 0 ; for ( Object o : items ) { if ( o != null ) { data [ index ] = o . toString ( ) ; } index ++ ; } } public StringList ( Iterable < String > iter ) { this ( 10 ) ; for ( String s : iter ) { append ( s ) ; } } private void crop ( ) { if ( count != data . length ) { data = PApplet . subset ( data , 0 , count ) ; } } public int size ( ) { return count ; } public void resize ( int length ) { if ( length > data . length ) { String [ ] temp = new String [ length ] ; System . arraycopy ( data , 0 , temp , 0 , count ) ; data = temp ; } else if ( length > count ) { Arrays . fill ( data , count , length , 0 ) ; } count = length ; } public void clear ( ) { count = 0 ; } public String get ( int index ) { if ( index >= count ) { throw new ArrayIndexOutOfBoundsException ( index ) ; } return data [ index ] ; } public void set ( int index , String what ) { if ( index >= count ) { data = PApplet . expand ( data , index + 1 ) ; for ( int i = count ; i < index ; i ++ ) { data [ i ] = null ; } count = index + 1 ; } data [ index ] = what ; } public void push ( String value ) { append ( value ) ; } public String pop ( ) { if ( count == 0 ) { throw new RuntimeException ( "Can't call pop() on an empty list" ) ; } String value = get ( count - 1 ) ; data [ -- count ] = null ; return value ; } public String remove ( int index ) { if ( index < 0 || index >= count ) { throw new ArrayIndexOutOfBoundsException ( index ) ; } String entry = data [ index ] ; for ( int i = index ; i < count - 1 ; i ++ ) { data [ i ] = data [ i + 1 ] ; } count -- ; return entry ; } public int removeValue ( String value ) { if ( value == null ) { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] == null ) { remove ( i ) ; return i ; } } } else { int index = index ( value ) ; if ( index != - 1 ) { remove ( index ) ; return index ; } } return - 1 ; } public int removeValues ( String value ) { int ii = 0 ; if ( value == null ) { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] != null ) { data [ ii ++ ] = data [ i ] ; } } } else { for ( int i = 0 ; i < count ; i ++ ) { if ( ! value . equals ( data [ i ] ) ) { data [ ii ++ ] = data [ i ] ; } } } int removed = count - ii ; count = ii ; return removed ; } public int replaceValue ( String value , String newValue ) { if ( value == null ) { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] == null ) { data [ i ] = newValue ; return i ; } } } else { for ( int i = 0 ; i < count ; i ++ ) { if ( value . equals ( data [ i ] ) ) { data [ i ] = newValue ; return i ; } } } return - 1 ; } public int replaceValues ( String value , String newValue ) { int changed = 0 ; if ( value == null ) { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] == null ) { data [ i ] = newValue ; changed ++ ; } } } else { for ( int i = 0 ; i < count ; i ++ ) { if ( value . equals ( data [ i ] ) ) { data [ i ] = newValue ; changed ++ ; } } } return changed ; } public void append ( String value ) { if ( count == data . length ) { data = PApplet . expand ( data ) ; } data [ count ++ ] = value ; } public void append ( String [ ] values ) { for ( String v : values ) { append ( v ) ; } } public void append ( StringList list ) { for ( String v : list . values ( ) ) { append ( v ) ; } } public void appendUnique ( String value ) { if ( ! hasValue ( value ) ) { append ( value ) ; } } public void insert ( int index , String value ) { insert ( index , new String [ ] { value } ) ; } public void insert ( int index , String [ ] values ) { if ( index < 0 ) { throw new IllegalArgumentException ( "insert() index cannot be negative: it was " + index ) ; } if ( index >= data . length ) { throw new IllegalArgumentException ( "insert() index " + index + " is past the end of this list" ) ; } String [ ] temp = new String [ count + values . length ] ; System . arraycopy ( data , 0 , temp , 0 , Math . min ( count , index ) ) ; System . arraycopy ( values , 0 , temp , index , values . length ) ; System . arraycopy ( data , index , temp , index + values . length , count - index ) ; count = count + values . length ; data = temp ; } public void insert ( int index , StringList list ) { insert ( index , list . values ( ) ) ; } public int index ( String what ) { if ( what == null ) { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] == null ) { return i ; } } } else { for ( int i = 0 ; i < count ; i ++ ) { if ( what . equals ( data [ i ] ) ) { return i ; } } } return - 1 ; } public boolean hasValue ( String value ) { if ( value == null ) { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] == null ) { return true ; } } } else { for ( int i = 0 ; i < count ; i ++ ) { if ( value . equals ( data [ i ] ) ) { return true ; } } } return false ; } public void sort ( ) { sortImpl ( false ) ; } public void sortReverse ( ) { sortImpl ( true ) ; } private void sortImpl ( final boolean reverse ) { new Sort ( ) { @ Override public int size ( ) { return count ; } @ Override public float compare ( int a , int b ) { float diff = data [ a ] . compareToIgnoreCase ( data [ b ] ) ; return reverse ? - diff : diff ; } @ Override public void swap ( int a , int b ) { String temp = data [ a ] ; data [ a ] = data [ b ] ; data [ b ] = temp ; } } . run ( ) ; } public void reverse ( ) { int ii = count - 1 ; for ( int i = 0 ; i < count / 2 ; i ++ ) { String t = data [ i ] ; data [ i ] = data [ ii ] ; data [ ii ] = t ; -- ii ; } } public void shuffle ( ) { Random r = new Random ( ) ; int num = count ; while ( num > 1 ) { int value = r . nextInt ( num ) ; num -- ; String temp = data [ num ] ; data [ num ] = data [ value ] ; data [ value ] = temp ; } } public void shuffle ( PApplet sketch ) { int num = count ; while ( num > 1 ) { int value = ( int ) sketch . random ( num ) ; num -- ; String temp = data [ num ] ; data [ num ] = data [ value ] ; data [ value ] = temp ; } } public void lower ( ) { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] != null ) { data [ i ] = data [ i ] . toLowerCase ( ) ; } } } public void upper ( ) { for ( int i = 0 ; i < count ; i ++ ) { if ( data [ i ] != null ) { data [ i ] = data [ i ] . toUpperCase ( ) ; } } } public StringList copy ( ) { StringList outgoing = new StringList ( data ) ; outgoing . count = count ; return outgoing ; } public String [ ] values ( ) { crop ( ) ; return data ; } @ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { int index = - 1 ; public void remove ( ) { StringList . this . remove ( index ) ; } public String next ( ) { return data [ ++ index ] ; } public boolean hasNext ( ) { return index + 1 < count ; } } ; } public String [ ] array ( ) { return array ( null ) ; } public String [ ] array ( String [ ] array ) { if ( array == null || array . length != count ) { array = new String [ count ] ; } System . arraycopy ( data , 0 , array , 0 , count ) ; return array ; } public StringList getSubset ( int start ) { return getSubset ( start , count - start ) ; } public StringList getSubset ( int start , int num ) { String [ ] subset = new String [ num ] ; System . arraycopy ( data , start , subset , 0 , num ) ; return new StringList ( subset ) ; } public String [ ] getUnique ( ) { return getTally ( ) . keyArray ( ) ; } public IntDict getTally ( ) { IntDict outgoing = new IntDict ( ) ; for ( int i = 0 ; i < count ; i ++ ) { outgoing . increment ( data [ i ] ) ; } return outgoing ; } public IntDict getOrder ( ) { IntDict outgoing = new IntDict ( ) ; for ( int i = 0 ; i < count ; i ++ ) { outgoing . set ( data [ i ] , i ) ; } return outgoing ; } public String join ( String separator ) { if ( count == 0 ) { return "" ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( data [ 0 ] ) ; for ( int i = 1 ; i < count ; i ++ ) { sb . append ( separator ) ; sb . append ( data [ i ] ) ; } return sb . toString ( ) ; } public void print ( ) { for ( int i = 0 ; i < size ( ) ; i ++ ) { System . out . format ( "[%d] %s%n" , i , data [ i ] ) ; } } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getSimpleName ( ) + " size=" + size ( ) + " [ " ) ; for ( int i = 0 ; i < size ( ) ; i ++ ) { if ( i != 0 ) { sb . append ( ", " ) ; } sb . append ( i + ": \"" + data [ i ] + "\"" ) ; } sb . append ( " ]" ) ; return sb . toString ( ) ; } }
package processing . event ; public class KeyEvent extends Event { static public final int PRESS = 1 ; static public final int RELEASE = 2 ; static public final int TYPE = 3 ; char key ; int keyCode ; public KeyEvent ( Object nativeObject , long millis , int action , int modifiers , char key , int keyCode ) { super ( nativeObject , millis , action , modifiers ) ; this . flavor = KEY ; this . key = key ; this . keyCode = keyCode ; } public char getKey ( ) { return key ; } public int getKeyCode ( ) { return keyCode ; } }
package processing . event ; public class Event { protected Object nativeObject ; protected long millis ; protected int action ; static public final int SHIFT = 1 < < 0 ; static public final int CTRL = 1 < < 1 ; static public final int META = 1 < < 2 ; static public final int ALT = 1 < < 3 ; protected int modifiers ; static public final int KEY = 1 ; static public final int MOUSE = 2 ; static public final int TOUCH = 3 ; protected int flavor ; public Event ( Object nativeObject , long millis , int action , int modifiers ) { this . nativeObject = nativeObject ; this . millis = millis ; this . action = action ; this . modifiers = modifiers ; } public int getFlavor ( ) { return flavor ; } public Object getNative ( ) { return nativeObject ; } public long getMillis ( ) { return millis ; } public int getAction ( ) { return action ; } public int getModifiers ( ) { return modifiers ; } public boolean isShiftDown ( ) { return ( modifiers & SHIFT ) != 0 ; } public boolean isControlDown ( ) { return ( modifiers & CTRL ) != 0 ; } public boolean isMetaDown ( ) { return ( modifiers & META ) != 0 ; } public boolean isAltDown ( ) { return ( modifiers & ALT ) != 0 ; } }
package processing . event ; public class TouchEvent extends Event { public TouchEvent ( Object nativeObject , long millis , int action , int modifiers ) { super ( nativeObject , millis , action , modifiers ) ; this . flavor = TOUCH ; } }
package processing . event ; public class MouseEvent extends Event { static public final int PRESS = 1 ; static public final int RELEASE = 2 ; static public final int CLICK = 3 ; static public final int DRAG = 4 ; static public final int MOVE = 5 ; static public final int ENTER = 6 ; static public final int EXIT = 7 ; static public final int WHEEL = 8 ; protected int x , y ; protected int button ; protected int count ; public MouseEvent ( Object nativeObject , long millis , int action , int modifiers , int x , int y , int button , int count ) { super ( nativeObject , millis , action , modifiers ) ; this . flavor = MOUSE ; this . x = x ; this . y = y ; this . button = button ; this . count = count ; } public int getX ( ) { return x ; } public int getY ( ) { return y ; } public int getButton ( ) { return button ; } @ Deprecated public int getClickCount ( ) { return count ; } @ Deprecated public float getAmount ( ) { return count ; } public int getCount ( ) { return count ; } private String actionString ( ) { switch ( action ) { default : return "UNKNOWN" ; case CLICK : return "CLICK" ; case DRAG : return "DRAG" ; case ENTER : return "ENTER" ; case EXIT : return "EXIT" ; case MOVE : return "MOVE" ; case PRESS : return "PRESS" ; case RELEASE : return "RELEASE" ; case WHEEL : return "WHEEL" ; } } @ Override public String toString ( ) { return String . format ( "<MouseEvent %s@%d,%d count:%d button:%d>" , actionString ( ) , x , y , count , button ) ; } }
package processing . core ; import java . awt . * ; import java . awt . font . TextAttribute ; import java . awt . geom . * ; import java . awt . image . * ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; public class PGraphicsJava2D extends PGraphics { public Graphics2D g2 ; Composite defaultComposite ; GeneralPath gpath ; GeneralPath auxPath ; boolean openContour ; boolean breakShape ; float [ ] curveCoordX ; float [ ] curveCoordY ; float [ ] curveDrawX ; float [ ] curveDrawY ; int transformCount ; AffineTransform transformStack [ ] = new AffineTransform [ MATRIX_STACK_DEPTH ] ; double [ ] transform = new double [ 6 ] ; Line2D . Float line = new Line2D . Float ( ) ; Ellipse2D . Float ellipse = new Ellipse2D . Float ( ) ; Rectangle2D . Float rect = new Rectangle2D . Float ( ) ; Arc2D . Float arc = new Arc2D . Float ( ) ; protected Color tintColorObject ; protected Color fillColorObject ; public boolean fillGradient ; public Paint fillGradientObject ; protected Stroke strokeObject ; protected Color strokeColorObject ; public boolean strokeGradient ; public Paint strokeGradientObject ; Font fontObject ; public PGraphicsJava2D ( ) { } @ Override public PSurface createSurface ( ) { return surface = new PSurfaceAWT ( this ) ; } @ Override public boolean canDraw ( ) { return true ; } public Graphics2D checkImage ( ) { if ( image == null || ( ( BufferedImage ) image ) . getWidth ( ) != width * pixelDensity || ( ( BufferedImage ) image ) . getHeight ( ) != height * pixelDensity ) { GraphicsConfiguration gc = null ; if ( surface != null ) { Component comp = null ; if ( comp == null ) { comp = parent . frame ; } if ( comp != null ) { gc = comp . getGraphicsConfiguration ( ) ; } } if ( gc == null ) { GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; gc = ge . getDefaultScreenDevice ( ) . getDefaultConfiguration ( ) ; } int wide = width * pixelDensity ; int high = height * pixelDensity ; image = gc . createCompatibleImage ( wide , high , Transparency . TRANSLUCENT ) ; } return ( Graphics2D ) image . getGraphics ( ) ; } @ Override public void beginDraw ( ) { g2 = checkImage ( ) ; if ( strokeObject != null ) { g2 . setStroke ( strokeObject ) ; } if ( fontObject != null ) { g2 . setFont ( fontObject ) ; } handleSmooth ( ) ; checkSettings ( ) ; resetMatrix ( ) ; vertexCount = 0 ; g2 . scale ( pixelDensity , pixelDensity ) ; } protected void handleSmooth ( ) { if ( smooth == 0 ) { g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_OFF ) ; g2 . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_NEAREST_NEIGHBOR ) ; g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_OFF ) ; } else { g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; if ( smooth == 1 || smooth == 3 ) { g2 . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BICUBIC ) ; } else if ( smooth == 2 ) { g2 . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; } g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; g2 . setRenderingHint ( RenderingHints . KEY_FRACTIONALMETRICS , RenderingHints . VALUE_FRACTIONALMETRICS_ON ) ; } } @ Override public void endDraw ( ) { if ( primaryGraphics ) { } else { loadPixels ( ) ; } setModified ( ) ; g2 . dispose ( ) ; } @ Override protected void defaultSettings ( ) { defaultComposite = g2 . getComposite ( ) ; super . defaultSettings ( ) ; } @ Override public void hint ( int which ) { super . hint ( which ) ; if ( which == ENABLE_STROKE_PURE ) { g2 . setRenderingHint ( RenderingHints . KEY_STROKE_CONTROL , RenderingHints . VALUE_STROKE_PURE ) ; } else if ( which == DISABLE_STROKE_PURE ) { g2 . setRenderingHint ( RenderingHints . KEY_STROKE_CONTROL , RenderingHints . VALUE_STROKE_DEFAULT ) ; } } @ Override protected PShape createShapeFamily ( int type ) { return new PShape ( this , type ) ; } @ Override protected PShape createShapePrimitive ( int kind , float ... p ) { return new PShape ( this , kind , p ) ; } @ Override public void beginShape ( int kind ) { shape = kind ; vertexCount = 0 ; curveVertexCount = 0 ; gpath = null ; auxPath = null ; } @ Override public void texture ( PImage image ) { showMethodWarning ( "texture" ) ; } @ Override public void vertex ( float x , float y ) { curveVertexCount = 0 ; if ( vertexCount == vertices . length ) { float temp [ ] [ ] = new float [ vertexCount < < 1 ] [ VERTEX_FIELD_COUNT ] ; System . arraycopy ( vertices , 0 , temp , 0 , vertexCount ) ; vertices = temp ; } vertices [ vertexCount ] [ X ] = x ; vertices [ vertexCount ] [ Y ] = y ; vertexCount ++ ; switch ( shape ) { case POINTS : point ( x , y ) ; break ; case LINES : if ( ( vertexCount % 2 ) == 0 ) { line ( vertices [ vertexCount - 2 ] [ X ] , vertices [ vertexCount - 2 ] [ Y ] , x , y ) ; } break ; case TRIANGLES : if ( ( vertexCount % 3 ) == 0 ) { triangle ( vertices [ vertexCount - 3 ] [ X ] , vertices [ vertexCount - 3 ] [ Y ] , vertices [ vertexCount - 2 ] [ X ] , vertices [ vertexCount - 2 ] [ Y ] , x , y ) ; } break ; case TRIANGLE_STRIP : if ( vertexCount >= 3 ) { triangle ( vertices [ vertexCount - 2 ] [ X ] , vertices [ vertexCount - 2 ] [ Y ] , vertices [ vertexCount - 1 ] [ X ] , vertices [ vertexCount - 1 ] [ Y ] , vertices [ vertexCount - 3 ] [ X ] , vertices [ vertexCount - 3 ] [ Y ] ) ; } break ; case TRIANGLE_FAN : if ( vertexCount >= 3 ) { triangle ( vertices [ 0 ] [ X ] , vertices [ 0 ] [ Y ] , vertices [ vertexCount - 2 ] [ X ] , vertices [ vertexCount - 2 ] [ Y ] , x , y ) ; } break ; case QUAD : case QUADS : if ( ( vertexCount % 4 ) == 0 ) { quad ( vertices [ vertexCount - 4 ] [ X ] , vertices [ vertexCount - 4 ] [ Y ] , vertices [ vertexCount - 3 ] [ X ] , vertices [ vertexCount - 3 ] [ Y ] , vertices [ vertexCount - 2 ] [ X ] , vertices [ vertexCount - 2 ] [ Y ] , x , y ) ; } break ; case QUAD_STRIP : if ( ( vertexCount >= 4 ) && ( ( vertexCount % 2 ) == 0 ) ) { quad ( vertices [ vertexCount - 4 ] [ X ] , vertices [ vertexCount - 4 ] [ Y ] , vertices [ vertexCount - 2 ] [ X ] , vertices [ vertexCount - 2 ] [ Y ] , x , y , vertices [ vertexCount - 3 ] [ X ] , vertices [ vertexCount - 3 ] [ Y ] ) ; } break ; case POLYGON : if ( gpath == null ) { gpath = new GeneralPath ( ) ; gpath . moveTo ( x , y ) ; } else if ( breakShape ) { gpath . moveTo ( x , y ) ; breakShape = false ; } else { gpath . lineTo ( x , y ) ; } break ; } } @ Override public void vertex ( float x , float y , float z ) { showDepthWarningXYZ ( "vertex" ) ; } @ Override public void vertex ( float [ ] v ) { vertex ( v [ X ] , v [ Y ] ) ; } @ Override public void vertex ( float x , float y , float u , float v ) { showVariationWarning ( "vertex(x, y, u, v)" ) ; } @ Override public void vertex ( float x , float y , float z , float u , float v ) { showDepthWarningXYZ ( "vertex" ) ; } @ Override public void beginContour ( ) { if ( openContour ) { PGraphics . showWarning ( "Already called beginContour()" ) ; return ; } GeneralPath contourPath = auxPath ; auxPath = gpath ; gpath = contourPath ; if ( contourPath != null ) { breakShape = true ; } openContour = true ; } @ Override public void endContour ( ) { if ( ! openContour ) { PGraphics . showWarning ( "Need to call beginContour() first" ) ; return ; } if ( gpath != null ) gpath . closePath ( ) ; GeneralPath contourPath = gpath ; gpath = auxPath ; auxPath = contourPath ; openContour = false ; } @ Override public void endShape ( int mode ) { if ( openContour ) { endContour ( ) ; PGraphics . showWarning ( "Missing endContour() before endShape()" ) ; } if ( gpath != null ) { if ( shape == POLYGON ) { if ( mode == CLOSE ) { gpath . closePath ( ) ; } if ( auxPath != null ) { gpath . append ( auxPath , false ) ; } drawShape ( gpath ) ; } } shape = 0 ; } @ Override protected void clipImpl ( float x1 , float y1 , float x2 , float y2 ) { g2 . setClip ( new Rectangle2D . Float ( x1 , y1 , x2 - x1 , y2 - y1 ) ) ; } @ Override public void noClip ( ) { g2 . setClip ( null ) ; } @ Override protected void blendModeImpl ( ) { if ( blendMode == BLEND ) { g2 . setComposite ( defaultComposite ) ; } else { g2 . setComposite ( new Composite ( ) { @ Override public CompositeContext createContext ( ColorModel srcColorModel , ColorModel dstColorModel , RenderingHints hints ) { return new BlendingContext ( blendMode ) ; } } ) ; } } private static final class BlendingContext implements CompositeContext { private int mode ; private BlendingContext ( int mode ) { this . mode = mode ; } public void dispose ( ) { } public void compose ( Raster src , Raster dstIn , WritableRaster dstOut ) { if ( src . getSampleModel ( ) . getDataType ( ) != DataBuffer . TYPE_INT || dstIn . getSampleModel ( ) . getDataType ( ) != DataBuffer . TYPE_INT || dstOut . getSampleModel ( ) . getDataType ( ) != DataBuffer . TYPE_INT ) { throw new IllegalStateException ( "Source and destination must store pixels as INT." ) ; } int width = Math . min ( src . getWidth ( ) , dstIn . getWidth ( ) ) ; int height = Math . min ( src . getHeight ( ) , dstIn . getHeight ( ) ) ; int [ ] srcPixels = new int [ width ] ; int [ ] dstPixels = new int [ width ] ; int alphaFiller = ( dstIn . getNumBands ( ) == 3 ) ? ( 0xFF < < 24 ) : 0x00 ; for ( int y = 0 ; y < height ; y ++ ) { src . getDataElements ( 0 , y , width , 1 , srcPixels ) ; dstIn . getDataElements ( 0 , y , width , 1 , dstPixels ) ; for ( int x = 0 ; x < width ; x ++ ) { dstPixels [ x ] = blendColor ( alphaFiller | dstPixels [ x ] , srcPixels [ x ] , mode ) ; } dstOut . setDataElements ( 0 , y , width , 1 , dstPixels ) ; } } } @ Override public void bezierVertex ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { bezierVertexCheck ( ) ; gpath . curveTo ( x1 , y1 , x2 , y2 , x3 , y3 ) ; } @ Override public void bezierVertex ( float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { showDepthWarningXYZ ( "bezierVertex" ) ; } @ Override public void quadraticVertex ( float ctrlX , float ctrlY , float endX , float endY ) { bezierVertexCheck ( ) ; Point2D cur = gpath . getCurrentPoint ( ) ; float x1 = ( float ) cur . getX ( ) ; float y1 = ( float ) cur . getY ( ) ; bezierVertex ( x1 + ( ( ctrlX - x1 ) * 2 / 3.0f ) , y1 + ( ( ctrlY - y1 ) * 2 / 3.0f ) , endX + ( ( ctrlX - endX ) * 2 / 3.0f ) , endY + ( ( ctrlY - endY ) * 2 / 3.0f ) , endX , endY ) ; } @ Override public void quadraticVertex ( float x2 , float y2 , float z2 , float x4 , float y4 , float z4 ) { showDepthWarningXYZ ( "quadVertex" ) ; } @ Override protected void curveVertexCheck ( ) { super . curveVertexCheck ( ) ; if ( curveCoordX == null ) { curveCoordX = new float [ 4 ] ; curveCoordY = new float [ 4 ] ; curveDrawX = new float [ 4 ] ; curveDrawY = new float [ 4 ] ; } } @ Override protected void curveVertexSegment ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { curveCoordX [ 0 ] = x1 ; curveCoordY [ 0 ] = y1 ; curveCoordX [ 1 ] = x2 ; curveCoordY [ 1 ] = y2 ; curveCoordX [ 2 ] = x3 ; curveCoordY [ 2 ] = y3 ; curveCoordX [ 3 ] = x4 ; curveCoordY [ 3 ] = y4 ; curveToBezierMatrix . mult ( curveCoordX , curveDrawX ) ; curveToBezierMatrix . mult ( curveCoordY , curveDrawY ) ; if ( gpath == null ) { gpath = new GeneralPath ( ) ; gpath . moveTo ( curveDrawX [ 0 ] , curveDrawY [ 0 ] ) ; } gpath . curveTo ( curveDrawX [ 1 ] , curveDrawY [ 1 ] , curveDrawX [ 2 ] , curveDrawY [ 2 ] , curveDrawX [ 3 ] , curveDrawY [ 3 ] ) ; } @ Override public void curveVertex ( float x , float y , float z ) { showDepthWarningXYZ ( "curveVertex" ) ; } @ Override public void point ( float x , float y ) { if ( stroke ) { line ( x , y , x + EPSILON , y + EPSILON ) ; } } @ Override public void line ( float x1 , float y1 , float x2 , float y2 ) { line . setLine ( x1 , y1 , x2 , y2 ) ; strokeShape ( line ) ; } @ Override public void triangle ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { gpath = new GeneralPath ( ) ; gpath . moveTo ( x1 , y1 ) ; gpath . lineTo ( x2 , y2 ) ; gpath . lineTo ( x3 , y3 ) ; gpath . closePath ( ) ; drawShape ( gpath ) ; } @ Override public void quad ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { GeneralPath gp = new GeneralPath ( ) ; gp . moveTo ( x1 , y1 ) ; gp . lineTo ( x2 , y2 ) ; gp . lineTo ( x3 , y3 ) ; gp . lineTo ( x4 , y4 ) ; gp . closePath ( ) ; drawShape ( gp ) ; } @ Override protected void rectImpl ( float x1 , float y1 , float x2 , float y2 ) { rect . setFrame ( x1 , y1 , x2 - x1 , y2 - y1 ) ; drawShape ( rect ) ; } @ Override protected void ellipseImpl ( float x , float y , float w , float h ) { ellipse . setFrame ( x , y , w , h ) ; drawShape ( ellipse ) ; } @ Override protected void arcImpl ( float x , float y , float w , float h , float start , float stop , int mode ) { start = - start * RAD_TO_DEG ; stop = - stop * RAD_TO_DEG ; float sweep = stop - start ; int fillMode = Arc2D . PIE ; int strokeMode = Arc2D . OPEN ; if ( mode == OPEN ) { fillMode = Arc2D . OPEN ; } else if ( mode == PIE ) { strokeMode = Arc2D . PIE ; } else if ( mode == CHORD ) { fillMode = Arc2D . CHORD ; strokeMode = Arc2D . CHORD ; } if ( fill ) { arc . setArc ( x , y , w , h , start , sweep , fillMode ) ; fillShape ( arc ) ; } if ( stroke ) { arc . setArc ( x , y , w , h , start , sweep , strokeMode ) ; strokeShape ( arc ) ; } } protected void fillShape ( Shape s ) { if ( fillGradient ) { g2 . setPaint ( fillGradientObject ) ; g2 . fill ( s ) ; } else if ( fill ) { g2 . setColor ( fillColorObject ) ; g2 . fill ( s ) ; } } protected void strokeShape ( Shape s ) { if ( strokeGradient ) { g2 . setPaint ( strokeGradientObject ) ; g2 . draw ( s ) ; } else if ( stroke ) { g2 . setColor ( strokeColorObject ) ; g2 . draw ( s ) ; } } protected void drawShape ( Shape s ) { if ( fillGradient ) { g2 . setPaint ( fillGradientObject ) ; g2 . fill ( s ) ; } else if ( fill ) { g2 . setColor ( fillColorObject ) ; g2 . fill ( s ) ; } if ( strokeGradient ) { g2 . setPaint ( strokeGradientObject ) ; g2 . draw ( s ) ; } else if ( stroke ) { g2 . setColor ( strokeColorObject ) ; g2 . draw ( s ) ; } } @ Override public void box ( float w , float h , float d ) { showMethodWarning ( "box" ) ; } @ Override public void sphere ( float r ) { showMethodWarning ( "sphere" ) ; } @ Override public void bezierDetail ( int detail ) { } @ Override public void curveDetail ( int detail ) { } @ Override protected void imageImpl ( PImage who , float x1 , float y1 , float x2 , float y2 , int u1 , int v1 , int u2 , int v2 ) { if ( who . width <= 0 || who . height <= 0 ) return ; ImageCache cash = ( ImageCache ) getCache ( who ) ; if ( cash != null ) { if ( who . width != cash . image . getWidth ( ) || who . height != cash . image . getHeight ( ) ) { cash = null ; } } if ( cash == null ) { cash = new ImageCache ( ) ; setCache ( who , cash ) ; who . updatePixels ( ) ; who . modified = true ; } if ( ( tint && ! cash . tinted ) || ( tint && ( cash . tintedColor != tintColor ) ) || ( ! tint && cash . tinted ) ) { who . updatePixels ( ) ; } if ( who . modified ) { if ( who . pixels == null ) { who . pixels = new int [ who . width * who . height ] ; } cash . update ( who , tint , tintColor ) ; who . modified = false ; } g2 . drawImage ( ( ( ImageCache ) getCache ( who ) ) . image , ( int ) x1 , ( int ) y1 , ( int ) x2 , ( int ) y2 , u1 , v1 , u2 , v2 , null ) ; } static class ImageCache { boolean tinted ; int tintedColor ; int [ ] tintedTemp ; BufferedImage image ; public void update ( PImage source , boolean tint , int tintColor ) { int targetType = ARGB ; boolean opaque = ( tintColor & 0xFF000000 ) == 0xFF000000 ; if ( source . format == RGB ) { if ( ! tint || ( tint && opaque ) ) { targetType = RGB ; } } if ( image == null ) { image = new BufferedImage ( source . width , source . height , BufferedImage . TYPE_INT_ARGB ) ; } WritableRaster wr = image . getRaster ( ) ; if ( tint ) { if ( tintedTemp == null || tintedTemp . length != source . width ) { tintedTemp = new int [ source . width ] ; } int a2 = ( tintColor > > 24 ) & 0xff ; int r2 = ( tintColor > > 16 ) & 0xff ; int g2 = ( tintColor > > 8 ) & 0xff ; int b2 = ( tintColor ) & 0xff ; if ( targetType == RGB ) { int index = 0 ; for ( int y = 0 ; y < source . height ; y ++ ) { for ( int x = 0 ; x < source . width ; x ++ ) { int argb1 = source . pixels [ index ++ ] ; int r1 = ( argb1 > > 16 ) & 0xff ; int g1 = ( argb1 > > 8 ) & 0xff ; int b1 = ( argb1 ) & 0xff ; tintedTemp [ x ] = 0xFF000000 | ( ( ( r2 * r1 ) & 0xff00 ) < < 8 ) | ( ( g2 * g1 ) & 0xff00 ) | ( ( ( b2 * b1 ) & 0xff00 ) > > 8 ) ; } wr . setDataElements ( 0 , y , source . width , 1 , tintedTemp ) ; } } else if ( targetType == ARGB ) { if ( source . format == RGB && ( tintColor & 0xffffff ) == 0xffffff ) { int hi = tintColor & 0xff000000 ; int index = 0 ; for ( int y = 0 ; y < source . height ; y ++ ) { for ( int x = 0 ; x < source . width ; x ++ ) { tintedTemp [ x ] = hi | ( source . pixels [ index ++ ] & 0xFFFFFF ) ; } wr . setDataElements ( 0 , y , source . width , 1 , tintedTemp ) ; } } else { int index = 0 ; for ( int y = 0 ; y < source . height ; y ++ ) { if ( source . format == RGB ) { int alpha = tintColor & 0xFF000000 ; for ( int x = 0 ; x < source . width ; x ++ ) { int argb1 = source . pixels [ index ++ ] ; int r1 = ( argb1 > > 16 ) & 0xff ; int g1 = ( argb1 > > 8 ) & 0xff ; int b1 = ( argb1 ) & 0xff ; tintedTemp [ x ] = alpha | ( ( ( r2 * r1 ) & 0xff00 ) < < 8 ) | ( ( g2 * g1 ) & 0xff00 ) | ( ( ( b2 * b1 ) & 0xff00 ) > > 8 ) ; } } else if ( source . format == ARGB ) { for ( int x = 0 ; x < source . width ; x ++ ) { int argb1 = source . pixels [ index ++ ] ; int a1 = ( argb1 > > 24 ) & 0xff ; int r1 = ( argb1 > > 16 ) & 0xff ; int g1 = ( argb1 > > 8 ) & 0xff ; int b1 = ( argb1 ) & 0xff ; tintedTemp [ x ] = ( ( ( a2 * a1 ) & 0xff00 ) < < 16 ) | ( ( ( r2 * r1 ) & 0xff00 ) < < 8 ) | ( ( g2 * g1 ) & 0xff00 ) | ( ( ( b2 * b1 ) & 0xff00 ) > > 8 ) ; } } else if ( source . format == ALPHA ) { int lower = tintColor & 0xFFFFFF ; for ( int x = 0 ; x < source . width ; x ++ ) { int a1 = source . pixels [ index ++ ] ; tintedTemp [ x ] = ( ( ( a2 * a1 ) & 0xff00 ) < < 16 ) | lower ; } } wr . setDataElements ( 0 , y , source . width , 1 , tintedTemp ) ; } } } } else { if ( targetType == RGB && ( source . pixels [ 0 ] > > 24 == 0 ) ) { source . filter ( OPAQUE ) ; } wr . setDataElements ( 0 , 0 , source . width , source . height , source . pixels ) ; } this . tinted = tint ; this . tintedColor = tintColor ; } } @ Override public PShape loadShape ( String filename , String options ) { String extension = PApplet . getExtension ( filename ) ; if ( extension . equals ( "svg" ) || extension . equals ( "svgz" ) ) { return new PShapeSVG ( parent . loadXML ( filename ) ) ; } PGraphics . showWarning ( "Unsupported format: " + filename ) ; return null ; } @ Override public float textAscent ( ) { if ( textFont == null ) { defaultFontOrDeath ( "textAscent" ) ; } Font font = ( Font ) textFont . getNative ( ) ; if ( font != null ) { return getFontMetrics ( font ) . getAscent ( ) ; } return super . textAscent ( ) ; } @ Override public float textDescent ( ) { if ( textFont == null ) { defaultFontOrDeath ( "textDescent" ) ; } Font font = ( Font ) textFont . getNative ( ) ; if ( font != null ) { return getFontMetrics ( font ) . getDescent ( ) ; } return super . textDescent ( ) ; } @ Override protected boolean textModeCheck ( int mode ) { return mode == MODEL ; } @ Override public void textSize ( float size ) { if ( textFont == null ) { defaultFontOrDeath ( "textSize" , size ) ; } Font font = ( Font ) textFont . getNative ( ) ; if ( font != null ) { Map < TextAttribute , Object > map = new HashMap < TextAttribute , Object > ( ) ; map . put ( TextAttribute . SIZE , size ) ; map . put ( TextAttribute . KERNING , TextAttribute . KERNING_ON ) ; font = font . deriveFont ( map ) ; g2 . setFont ( font ) ; textFont . setNative ( font ) ; fontObject = font ; } super . textSize ( size ) ; } @ Override protected float textWidthImpl ( char buffer [ ] , int start , int stop ) { if ( textFont == null ) { defaultFontOrDeath ( "textWidth" ) ; } Font font = ( Font ) textFont . getNative ( ) ; if ( font != null ) { int length = stop - start ; FontMetrics metrics = getFontMetrics ( font ) ; return metrics . charsWidth ( buffer , start , length ) ; } return super . textWidthImpl ( buffer , start , stop ) ; } @ Override protected void textLineImpl ( char buffer [ ] , int start , int stop , float x , float y ) { Font font = ( Font ) textFont . getNative ( ) ; if ( font != null ) { Object antialias = g2 . getRenderingHint ( RenderingHints . KEY_ANTIALIASING ) ; if ( antialias == null ) { antialias = RenderingHints . VALUE_ANTIALIAS_DEFAULT ; } g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , textFont . smooth ? RenderingHints . VALUE_ANTIALIAS_ON : RenderingHints . VALUE_ANTIALIAS_OFF ) ; g2 . setColor ( fillColorObject ) ; int length = stop - start ; if ( length != 0 ) { g2 . drawChars ( buffer , start , length , ( int ) ( x + 0.5f ) , ( int ) ( y + 0.5f ) ) ; } g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , antialias ) ; } else { super . textLineImpl ( buffer , start , stop , x , y ) ; } } @ Override public FontMetrics getFontMetrics ( Font font ) { return ( g2 != null ) ? g2 . getFontMetrics ( font ) : super . getFontMetrics ( font ) ; } @ Override public void pushMatrix ( ) { if ( transformCount == transformStack . length ) { throw new RuntimeException ( "pushMatrix() cannot use push more than " + transformStack . length + " times" ) ; } transformStack [ transformCount ] = g2 . getTransform ( ) ; transformCount ++ ; } @ Override public void popMatrix ( ) { if ( transformCount == 0 ) { throw new RuntimeException ( "missing a pushMatrix() " + "to go with that popMatrix()" ) ; } transformCount -- ; g2 . setTransform ( transformStack [ transformCount ] ) ; } @ Override public void translate ( float tx , float ty ) { g2 . translate ( tx , ty ) ; } @ Override public void rotate ( float angle ) { g2 . rotate ( angle ) ; } @ Override public void rotateX ( float angle ) { showDepthWarning ( "rotateX" ) ; } @ Override public void rotateY ( float angle ) { showDepthWarning ( "rotateY" ) ; } @ Override public void rotateZ ( float angle ) { showDepthWarning ( "rotateZ" ) ; } @ Override public void rotate ( float angle , float vx , float vy , float vz ) { showVariationWarning ( "rotate" ) ; } @ Override public void scale ( float s ) { g2 . scale ( s , s ) ; } @ Override public void scale ( float sx , float sy ) { g2 . scale ( sx , sy ) ; } @ Override public void scale ( float sx , float sy , float sz ) { showDepthWarningXYZ ( "scale" ) ; } @ Override public void shearX ( float angle ) { g2 . shear ( Math . tan ( angle ) , 0 ) ; } @ Override public void shearY ( float angle ) { g2 . shear ( 0 , Math . tan ( angle ) ) ; } @ Override public void resetMatrix ( ) { g2 . setTransform ( new AffineTransform ( ) ) ; } @ Override public void applyMatrix ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) { g2 . transform ( new AffineTransform ( n00 , n10 , n01 , n11 , n02 , n12 ) ) ; } @ Override public void applyMatrix ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { showVariationWarning ( "applyMatrix" ) ; } @ Override public PMatrix getMatrix ( ) { return getMatrix ( ( PMatrix2D ) null ) ; } @ Override public PMatrix2D getMatrix ( PMatrix2D target ) { if ( target == null ) { target = new PMatrix2D ( ) ; } g2 . getTransform ( ) . getMatrix ( transform ) ; target . set ( ( float ) transform [ 0 ] , ( float ) transform [ 2 ] , ( float ) transform [ 4 ] , ( float ) transform [ 1 ] , ( float ) transform [ 3 ] , ( float ) transform [ 5 ] ) ; return target ; } @ Override public PMatrix3D getMatrix ( PMatrix3D target ) { showVariationWarning ( "getMatrix" ) ; return target ; } @ Override public void setMatrix ( PMatrix2D source ) { g2 . setTransform ( new AffineTransform ( source . m00 , source . m10 , source . m01 , source . m11 , source . m02 , source . m12 ) ) ; } @ Override public void setMatrix ( PMatrix3D source ) { showVariationWarning ( "setMatrix" ) ; } @ Override public void printMatrix ( ) { getMatrix ( ( PMatrix2D ) null ) . print ( ) ; } @ Override public float screenX ( float x , float y ) { g2 . getTransform ( ) . getMatrix ( transform ) ; return ( float ) transform [ 0 ] * x + ( float ) transform [ 2 ] * y + ( float ) transform [ 4 ] ; } @ Override public float screenY ( float x , float y ) { g2 . getTransform ( ) . getMatrix ( transform ) ; return ( float ) transform [ 1 ] * x + ( float ) transform [ 3 ] * y + ( float ) transform [ 5 ] ; } @ Override public float screenX ( float x , float y , float z ) { showDepthWarningXYZ ( "screenX" ) ; return 0 ; } @ Override public float screenY ( float x , float y , float z ) { showDepthWarningXYZ ( "screenY" ) ; return 0 ; } @ Override public float screenZ ( float x , float y , float z ) { showDepthWarningXYZ ( "screenZ" ) ; return 0 ; } @ Override public void strokeCap ( int cap ) { super . strokeCap ( cap ) ; strokeImpl ( ) ; } @ Override public void strokeJoin ( int join ) { super . strokeJoin ( join ) ; strokeImpl ( ) ; } @ Override public void strokeWeight ( float weight ) { super . strokeWeight ( weight ) ; strokeImpl ( ) ; } protected void strokeImpl ( ) { int cap = BasicStroke . CAP_BUTT ; if ( strokeCap == ROUND ) { cap = BasicStroke . CAP_ROUND ; } else if ( strokeCap == PROJECT ) { cap = BasicStroke . CAP_SQUARE ; } int join = BasicStroke . JOIN_BEVEL ; if ( strokeJoin == MITER ) { join = BasicStroke . JOIN_MITER ; } else if ( strokeJoin == ROUND ) { join = BasicStroke . JOIN_ROUND ; } strokeObject = new BasicStroke ( strokeWeight , cap , join ) ; g2 . setStroke ( strokeObject ) ; } @ Override protected void strokeFromCalc ( ) { super . strokeFromCalc ( ) ; strokeColorObject = new Color ( strokeColor , true ) ; strokeGradient = false ; } @ Override protected void tintFromCalc ( ) { super . tintFromCalc ( ) ; tintColorObject = new Color ( tintColor , true ) ; } @ Override protected void fillFromCalc ( ) { super . fillFromCalc ( ) ; fillColorObject = new Color ( fillColor , true ) ; fillGradient = false ; } int [ ] clearPixels ; protected void clearPixels ( int color ) { int imageWidth = image . getWidth ( null ) ; int imageHeight = image . getHeight ( null ) ; WritableRaster raster = getRaster ( ) ; if ( ( clearPixels == null ) || ( clearPixels . length < imageWidth ) ) { clearPixels = new int [ imageWidth ] ; } Arrays . fill ( clearPixels , 0 , imageWidth , backgroundColor ) ; for ( int i = 0 ; i < imageHeight ; i ++ ) { raster . setDataElements ( 0 , i , imageWidth , 1 , clearPixels ) ; } } @ Override public void backgroundImpl ( ) { if ( backgroundAlpha ) { clearPixels ( backgroundColor ) ; } else { Color bgColor = new Color ( backgroundColor ) ; Composite oldComposite = g2 . getComposite ( ) ; g2 . setComposite ( defaultComposite ) ; pushMatrix ( ) ; resetMatrix ( ) ; g2 . setColor ( bgColor ) ; if ( image != null ) { g2 . fillRect ( 0 , 0 , image . getWidth ( null ) , image . getHeight ( null ) ) ; } else { g2 . fillRect ( 0 , 0 , width , height ) ; } popMatrix ( ) ; g2 . setComposite ( oldComposite ) ; } } @ Override public void beginRaw ( PGraphics recorderRaw ) { showMethodWarning ( "beginRaw" ) ; } @ Override public void endRaw ( ) { showMethodWarning ( "endRaw" ) ; } protected WritableRaster getRaster ( ) { WritableRaster raster = null ; if ( primaryGraphics ) { if ( image instanceof VolatileImage ) { raster = ( ( VolatileImage ) image ) . getSnapshot ( ) . getRaster ( ) ; } } if ( raster == null ) { raster = ( ( BufferedImage ) image ) . getRaster ( ) ; } if ( raster . getTransferType ( ) != DataBuffer . TYPE_INT ) { System . err . println ( "See https://github.com/processing/processing/issues/2010" ) ; throw new RuntimeException ( "Pixel operations are not supported on this device." ) ; } return raster ; } @ Override public void loadPixels ( ) { if ( pixels == null || ( pixels . length != pixelWidth * pixelHeight ) ) { pixels = new int [ pixelWidth * pixelHeight ] ; } WritableRaster raster = getRaster ( ) ; raster . getDataElements ( 0 , 0 , pixelWidth , pixelHeight , pixels ) ; if ( raster . getNumBands ( ) == 3 ) { for ( int i = 0 ; i < pixels . length ; i ++ ) { pixels [ i ] = 0xff000000 | pixels [ i ] ; } } } @ Override public void updatePixels ( int x , int y , int c , int d ) { if ( ( x != 0 ) || ( y != 0 ) || ( c != pixelWidth ) || ( d != pixelHeight ) ) { showVariationWarning ( "updatePixels(x, y, w, h)" ) ; } if ( pixels != null ) { getRaster ( ) . setDataElements ( 0 , 0 , pixelWidth , pixelHeight , pixels ) ; } modified = true ; } static int getset [ ] = new int [ 1 ] ; @ Override public int get ( int x , int y ) { if ( ( x < 0 ) || ( y < 0 ) || ( x >= width ) || ( y >= height ) ) return 0 ; WritableRaster raster = getRaster ( ) ; raster . getDataElements ( x , y , getset ) ; if ( raster . getNumBands ( ) == 3 ) { return getset [ 0 ] | 0xff000000 ; } return getset [ 0 ] ; } @ Override public PImage get ( ) { return get ( 0 , 0 , width , height ) ; } @ Override protected void getImpl ( int sourceX , int sourceY , int sourceWidth , int sourceHeight , PImage target , int targetX , int targetY ) { WritableRaster raster = getRaster ( ) ; if ( sourceWidth == target . width && sourceHeight == target . height ) { raster . getDataElements ( sourceX , sourceY , sourceWidth , sourceHeight , target . pixels ) ; if ( raster . getNumBands ( ) == 3 ) { target . filter ( OPAQUE ) ; } } else { int [ ] temp = new int [ sourceWidth * sourceHeight ] ; raster . getDataElements ( sourceX , sourceY , sourceWidth , sourceHeight , temp ) ; int sourceOffset = 0 ; int targetOffset = targetY * target . width + targetX ; for ( int y = 0 ; y < sourceHeight ; y ++ ) { if ( raster . getNumBands ( ) == 3 ) { for ( int i = 0 ; i < sourceWidth ; i ++ ) { target . pixels [ targetOffset + i ] = 0xFF000000 | temp [ sourceOffset + i ] ; } } else { System . arraycopy ( temp , sourceOffset , target . pixels , targetOffset , sourceWidth ) ; } sourceOffset += sourceWidth ; targetOffset += target . width ; } } } @ Override public void set ( int x , int y , int argb ) { if ( ( x < 0 ) || ( y < 0 ) || ( x >= width ) || ( y >= height ) ) return ; getset [ 0 ] = argb ; getRaster ( ) . setDataElements ( x , y , getset ) ; } @ Override protected void setImpl ( PImage sourceImage , int sourceX , int sourceY , int sourceWidth , int sourceHeight , int targetX , int targetY ) { WritableRaster raster = getRaster ( ) ; if ( ( sourceX == 0 ) && ( sourceY == 0 ) && ( sourceWidth == sourceImage . width ) && ( sourceHeight == sourceImage . height ) ) { raster . setDataElements ( targetX , targetY , sourceImage . width , sourceImage . height , sourceImage . pixels ) ; } else { PImage temp = sourceImage . get ( sourceX , sourceY , sourceWidth , sourceHeight ) ; raster . setDataElements ( targetX , targetY , temp . width , temp . height , temp . pixels ) ; } } static final String MASK_WARNING = "mask() cannot be used on the main drawing surface" ; @ Override @ SuppressWarnings ( "deprecation" ) public void mask ( int [ ] alpha ) { if ( primaryGraphics ) { showWarning ( MASK_WARNING ) ; } else { super . mask ( alpha ) ; } } @ Override public void mask ( PImage alpha ) { if ( primaryGraphics ) { showWarning ( MASK_WARNING ) ; } else { super . mask ( alpha ) ; } } @ Override public void copy ( int sx , int sy , int sw , int sh , int dx , int dy , int dw , int dh ) { if ( ( sw != dw ) || ( sh != dh ) ) { g2 . drawImage ( image , dx , dy , dx + dw , dy + dh , sx , sy , sx + sw , sy + sh , null ) ; } else { dx = dx - sx ; dy = dy - sy ; g2 . copyArea ( sx , sy , sw , sh , dx , dy ) ; } } @ Override public void copy ( PImage src , int sx , int sy , int sw , int sh , int dx , int dy , int dw , int dh ) { g2 . drawImage ( ( Image ) src . getNative ( ) , dx , dy , dx + dw , dy + dh , sx , sy , sx + sw , sy + sh , null ) ; } }
package processing . opengl ; import processing . core . PApplet ; import processing . core . PConstants ; import java . nio . IntBuffer ; public class FrameBuffer implements PConstants { protected PGraphicsOpenGL pg ; protected PGL pgl ; protected int context ; public int glFbo ; public int glDepth ; public int glStencil ; public int glDepthStencil ; public int glMultisample ; public int width ; public int height ; protected int depthBits ; protected int stencilBits ; protected boolean packedDepthStencil ; protected boolean multisample ; protected int nsamples ; protected int numColorBuffers ; protected Texture [ ] colorBufferTex ; protected boolean screenFb ; protected boolean noDepth ; protected IntBuffer pixelBuffer ; FrameBuffer ( PGraphicsOpenGL pg ) { this . pg = pg ; pgl = pg . pgl ; context = pgl . createEmptyContext ( ) ; } FrameBuffer ( PGraphicsOpenGL pg , int w , int h , int samples , int colorBuffers , int depthBits , int stencilBits , boolean packedDepthStencil , boolean screen ) { this ( pg ) ; glFbo = 0 ; glDepth = 0 ; glStencil = 0 ; glDepthStencil = 0 ; glMultisample = 0 ; if ( screen ) { depthBits = stencilBits = samples = colorBuffers = 0 ; } width = w ; height = h ; if ( 1 < samples ) { multisample = true ; nsamples = samples ; } else { multisample = false ; nsamples = 1 ; } numColorBuffers = colorBuffers ; colorBufferTex = new Texture [ numColorBuffers ] ; for ( int i = 0 ; i < numColorBuffers ; i ++ ) { colorBufferTex [ i ] = null ; } if ( depthBits < 1 && stencilBits < 1 ) { this . depthBits = 0 ; this . stencilBits = 0 ; this . packedDepthStencil = false ; } else { if ( packedDepthStencil ) { this . depthBits = 24 ; this . stencilBits = 8 ; this . packedDepthStencil = true ; } else { this . depthBits = depthBits ; this . stencilBits = stencilBits ; this . packedDepthStencil = false ; } } screenFb = screen ; allocate ( ) ; noDepth = false ; pixelBuffer = null ; } FrameBuffer ( PGraphicsOpenGL pg , int w , int h ) { this ( pg , w , h , 1 , 1 , 0 , 0 , false , false ) ; } FrameBuffer ( PGraphicsOpenGL pg , int w , int h , boolean screen ) { this ( pg , w , h , 1 , 1 , 0 , 0 , false , screen ) ; } @ Override protected void finalize ( ) throws Throwable { try { if ( ! screenFb ) { if ( glFbo != 0 ) { PGraphicsOpenGL . finalizeFrameBufferObject ( glFbo , context ) ; } if ( glDepth != 0 ) { PGraphicsOpenGL . finalizeRenderBufferObject ( glDepth , context ) ; } if ( glStencil != 0 ) { PGraphicsOpenGL . finalizeRenderBufferObject ( glStencil , context ) ; } if ( glMultisample != 0 ) { PGraphicsOpenGL . finalizeRenderBufferObject ( glMultisample , context ) ; } if ( glDepthStencil != 0 ) { PGraphicsOpenGL . finalizeRenderBufferObject ( glDepthStencil , context ) ; } } } finally { super . finalize ( ) ; } } public void clear ( ) { pg . pushFramebuffer ( ) ; pg . setFramebuffer ( this ) ; pgl . clearDepth ( 1 ) ; pgl . clearStencil ( 0 ) ; pgl . clearColor ( 0 , 0 , 0 , 0 ) ; pgl . clear ( PGL . DEPTH_BUFFER_BIT | PGL . STENCIL_BUFFER_BIT | PGL . COLOR_BUFFER_BIT ) ; pg . popFramebuffer ( ) ; } public void copyColor ( FrameBuffer dest ) { copy ( dest , PGL . COLOR_BUFFER_BIT ) ; } public void copyDepth ( FrameBuffer dest ) { copy ( dest , PGL . DEPTH_BUFFER_BIT ) ; } public void copyStencil ( FrameBuffer dest ) { copy ( dest , PGL . STENCIL_BUFFER_BIT ) ; } public void copy ( FrameBuffer dest , int mask ) { pgl . bindFramebufferImpl ( PGL . READ_FRAMEBUFFER , this . glFbo ) ; pgl . bindFramebufferImpl ( PGL . DRAW_FRAMEBUFFER , dest . glFbo ) ; pgl . blitFramebuffer ( 0 , 0 , this . width , this . height , 0 , 0 , dest . width , dest . height , mask , PGL . NEAREST ) ; pgl . bindFramebufferImpl ( PGL . READ_FRAMEBUFFER , pg . getCurrentFB ( ) . glFbo ) ; pgl . bindFramebufferImpl ( PGL . DRAW_FRAMEBUFFER , pg . getCurrentFB ( ) . glFbo ) ; } public void bind ( ) { pgl . bindFramebufferImpl ( PGL . FRAMEBUFFER , glFbo ) ; } public void disableDepthTest ( ) { noDepth = true ; } public void finish ( ) { if ( noDepth ) { if ( pg . getHint ( ENABLE_DEPTH_TEST ) ) { pgl . enable ( PGL . DEPTH_TEST ) ; } else { pgl . disable ( PGL . DEPTH_TEST ) ; } } } public void readPixels ( ) { if ( pixelBuffer == null ) createPixelBuffer ( ) ; pixelBuffer . rewind ( ) ; pgl . readPixels ( 0 , 0 , width , height , PGL . RGBA , PGL . UNSIGNED_BYTE , pixelBuffer ) ; } public void getPixels ( int [ ] pixels ) { if ( pixelBuffer != null ) { pixelBuffer . get ( pixels , 0 , pixels . length ) ; pixelBuffer . rewind ( ) ; } } public IntBuffer getPixelBuffer ( ) { return pixelBuffer ; } public boolean hasDepthBuffer ( ) { return 0 < depthBits ; } public boolean hasStencilBuffer ( ) { return 0 < stencilBits ; } public void setFBO ( int id ) { if ( screenFb ) { glFbo = id ; } } public void setColorBuffer ( Texture tex ) { setColorBuffers ( new Texture [ ] { tex } , 1 ) ; } public void setColorBuffers ( Texture [ ] textures ) { setColorBuffers ( textures , textures . length ) ; } public void setColorBuffers ( Texture [ ] textures , int n ) { if ( screenFb ) return ; if ( numColorBuffers != PApplet . min ( n , textures . length ) ) { throw new RuntimeException ( "Wrong number of textures to set the color " + "buffers." ) ; } for ( int i = 0 ; i < numColorBuffers ; i ++ ) { colorBufferTex [ i ] = textures [ i ] ; } pg . pushFramebuffer ( ) ; pg . setFramebuffer ( this ) ; for ( int i = 0 ; i < numColorBuffers ; i ++ ) { pgl . framebufferTexture2D ( PGL . FRAMEBUFFER , PGL . COLOR_ATTACHMENT0 + i , PGL . TEXTURE_2D , 0 , 0 ) ; } for ( int i = 0 ; i < numColorBuffers ; i ++ ) { pgl . framebufferTexture2D ( PGL . FRAMEBUFFER , PGL . COLOR_ATTACHMENT0 + i , colorBufferTex [ i ] . glTarget , colorBufferTex [ i ] . glName , 0 ) ; } pgl . validateFramebuffer ( ) ; pg . popFramebuffer ( ) ; } public void swapColorBuffers ( ) { for ( int i = 0 ; i < numColorBuffers - 1 ; i ++ ) { int i1 = ( i + 1 ) ; Texture tmp = colorBufferTex [ i ] ; colorBufferTex [ i ] = colorBufferTex [ i1 ] ; colorBufferTex [ i1 ] = tmp ; } pg . pushFramebuffer ( ) ; pg . setFramebuffer ( this ) ; for ( int i = 0 ; i < numColorBuffers ; i ++ ) { pgl . framebufferTexture2D ( PGL . FRAMEBUFFER , PGL . COLOR_ATTACHMENT0 + i , colorBufferTex [ i ] . glTarget , colorBufferTex [ i ] . glName , 0 ) ; } pgl . validateFramebuffer ( ) ; pg . popFramebuffer ( ) ; } public int getDefaultReadBuffer ( ) { if ( screenFb ) { return pgl . getDefaultReadBuffer ( ) ; } else { return PGL . COLOR_ATTACHMENT0 ; } } public int getDefaultDrawBuffer ( ) { if ( screenFb ) { return pgl . getDefaultDrawBuffer ( ) ; } else { return PGL . COLOR_ATTACHMENT0 ; } } protected void allocate ( ) { dispose ( ) ; context = pgl . getCurrentContext ( ) ; if ( screenFb ) { glFbo = 0 ; } else { glFbo = PGraphicsOpenGL . createFrameBufferObject ( context , pgl ) ; if ( multisample ) { createColorBufferMultisample ( ) ; } if ( packedDepthStencil ) { createPackedDepthStencilBuffer ( ) ; } else { if ( 0 < depthBits ) { createDepthBuffer ( ) ; } if ( 0 < stencilBits ) { createStencilBuffer ( ) ; } } } } protected void dispose ( ) { if ( screenFb ) return ; if ( glFbo != 0 ) { PGraphicsOpenGL . finalizeFrameBufferObject ( glFbo , context ) ; glFbo = 0 ; } if ( glDepth != 0 ) { PGraphicsOpenGL . finalizeRenderBufferObject ( glDepth , context ) ; glDepth = 0 ; } if ( glStencil != 0 ) { PGraphicsOpenGL . finalizeRenderBufferObject ( glStencil , context ) ; glStencil = 0 ; } if ( glMultisample != 0 ) { PGraphicsOpenGL . finalizeRenderBufferObject ( glMultisample , context ) ; glMultisample = 0 ; } if ( glDepthStencil != 0 ) { PGraphicsOpenGL . finalizeRenderBufferObject ( glDepthStencil , context ) ; glDepthStencil = 0 ; } } protected boolean contextIsOutdated ( ) { if ( screenFb ) return false ; boolean outdated = ! pgl . contextIsCurrent ( context ) ; if ( outdated ) { PGraphicsOpenGL . removeFrameBufferObject ( glFbo , context ) ; PGraphicsOpenGL . removeRenderBufferObject ( glDepth , context ) ; PGraphicsOpenGL . removeRenderBufferObject ( glStencil , context ) ; PGraphicsOpenGL . removeRenderBufferObject ( glDepthStencil , context ) ; PGraphicsOpenGL . removeRenderBufferObject ( glMultisample , context ) ; glFbo = 0 ; glDepth = 0 ; glStencil = 0 ; glDepthStencil = 0 ; glMultisample = 0 ; for ( int i = 0 ; i < numColorBuffers ; i ++ ) { colorBufferTex [ i ] = null ; } } return outdated ; } protected void createColorBufferMultisample ( ) { if ( screenFb ) return ; pg . pushFramebuffer ( ) ; pg . setFramebuffer ( this ) ; glMultisample = PGraphicsOpenGL . createRenderBufferObject ( context , pgl ) ; pgl . bindRenderbuffer ( PGL . RENDERBUFFER , glMultisample ) ; pgl . renderbufferStorageMultisample ( PGL . RENDERBUFFER , nsamples , PGL . RGBA8 , width , height ) ; pgl . framebufferRenderbuffer ( PGL . FRAMEBUFFER , PGL . COLOR_ATTACHMENT0 , PGL . RENDERBUFFER , glMultisample ) ; pg . popFramebuffer ( ) ; } protected void createPackedDepthStencilBuffer ( ) { if ( screenFb ) return ; if ( width == 0 || height == 0 ) { throw new RuntimeException ( "PFramebuffer: size undefined." ) ; } pg . pushFramebuffer ( ) ; pg . setFramebuffer ( this ) ; glDepthStencil = PGraphicsOpenGL . createRenderBufferObject ( context , pgl ) ; pgl . bindRenderbuffer ( PGL . RENDERBUFFER , glDepthStencil ) ; if ( multisample ) { pgl . renderbufferStorageMultisample ( PGL . RENDERBUFFER , nsamples , PGL . DEPTH24_STENCIL8 , width , height ) ; } else { pgl . renderbufferStorage ( PGL . RENDERBUFFER , PGL . DEPTH24_STENCIL8 , width , height ) ; } pgl . framebufferRenderbuffer ( PGL . FRAMEBUFFER , PGL . DEPTH_ATTACHMENT , PGL . RENDERBUFFER , glDepthStencil ) ; pgl . framebufferRenderbuffer ( PGL . FRAMEBUFFER , PGL . STENCIL_ATTACHMENT , PGL . RENDERBUFFER , glDepthStencil ) ; pg . popFramebuffer ( ) ; } protected void createDepthBuffer ( ) { if ( screenFb ) return ; if ( width == 0 || height == 0 ) { throw new RuntimeException ( "PFramebuffer: size undefined." ) ; } pg . pushFramebuffer ( ) ; pg . setFramebuffer ( this ) ; glDepth = PGraphicsOpenGL . createRenderBufferObject ( context , pgl ) ; pgl . bindRenderbuffer ( PGL . RENDERBUFFER , glDepth ) ; int glConst = PGL . DEPTH_COMPONENT16 ; if ( depthBits == 16 ) { glConst = PGL . DEPTH_COMPONENT16 ; } else if ( depthBits == 24 ) { glConst = PGL . DEPTH_COMPONENT24 ; } else if ( depthBits == 32 ) { glConst = PGL . DEPTH_COMPONENT32 ; } if ( multisample ) { pgl . renderbufferStorageMultisample ( PGL . RENDERBUFFER , nsamples , glConst , width , height ) ; } else { pgl . renderbufferStorage ( PGL . RENDERBUFFER , glConst , width , height ) ; } pgl . framebufferRenderbuffer ( PGL . FRAMEBUFFER , PGL . DEPTH_ATTACHMENT , PGL . RENDERBUFFER , glDepth ) ; pg . popFramebuffer ( ) ; } protected void createStencilBuffer ( ) { if ( screenFb ) return ; if ( width == 0 || height == 0 ) { throw new RuntimeException ( "PFramebuffer: size undefined." ) ; } pg . pushFramebuffer ( ) ; pg . setFramebuffer ( this ) ; glStencil = PGraphicsOpenGL . createRenderBufferObject ( context , pgl ) ; pgl . bindRenderbuffer ( PGL . RENDERBUFFER , glStencil ) ; int glConst = PGL . STENCIL_INDEX1 ; if ( stencilBits == 1 ) { glConst = PGL . STENCIL_INDEX1 ; } else if ( stencilBits == 4 ) { glConst = PGL . STENCIL_INDEX4 ; } else if ( stencilBits == 8 ) { glConst = PGL . STENCIL_INDEX8 ; } if ( multisample ) { pgl . renderbufferStorageMultisample ( PGL . RENDERBUFFER , nsamples , glConst , width , height ) ; } else { pgl . renderbufferStorage ( PGL . RENDERBUFFER , glConst , width , height ) ; } pgl . framebufferRenderbuffer ( PGL . FRAMEBUFFER , PGL . STENCIL_ATTACHMENT , PGL . RENDERBUFFER , glStencil ) ; pg . popFramebuffer ( ) ; } protected void createPixelBuffer ( ) { pixelBuffer = IntBuffer . allocate ( width * height ) ; pixelBuffer . rewind ( ) ; } }
package processing . opengl ; import java . awt . Canvas ; import java . awt . Font ; import java . awt . FontMetrics ; import java . awt . Shape ; import java . awt . font . FontRenderContext ; import java . awt . font . GlyphVector ; import java . awt . geom . PathIterator ; import java . io . IOException ; import java . net . URL ; import java . nio . Buffer ; import java . nio . ByteBuffer ; import java . nio . FloatBuffer ; import java . nio . IntBuffer ; import com . jogamp . opengl . GL ; import com . jogamp . opengl . GL2 ; import com . jogamp . opengl . GL2ES1 ; import com . jogamp . opengl . GL2ES2 ; import com . jogamp . opengl . GL2ES3 ; import com . jogamp . opengl . GL2GL3 ; import com . jogamp . opengl . GLAutoDrawable ; import com . jogamp . opengl . GLCapabilitiesImmutable ; import com . jogamp . opengl . GLContext ; import com . jogamp . opengl . GLDrawable ; import com . jogamp . opengl . GLProfile ; import com . jogamp . opengl . fixedfunc . GLMatrixFunc ; import com . jogamp . opengl . glu . GLU ; import com . jogamp . opengl . glu . GLUtessellator ; import com . jogamp . opengl . glu . GLUtessellatorCallbackAdapter ; import processing . core . PApplet ; import processing . core . PGraphics ; import processing . opengl . PGL ; import processing . opengl . PGraphicsOpenGL ; public class PJOGL extends PGL { public static int PROFILE = 2 ; public static boolean RETINA = false ; public static final int AWT = 0 ; public static final int NEWT = 1 ; public GL gl ; public GLU glu ; public GLContext context ; public Canvas canvas ; public static GLProfile profile ; protected static int DRAW_TIMEOUT_MILLIS = 500 ; protected GLCapabilitiesImmutable capabilities ; protected GLDrawable drawable ; protected GL2ES2 gl2 ; protected GL2GL3 gl3 ; protected GL2 gl2x ; protected Exception drawException ; protected float [ ] projMatrix ; protected float [ ] mvMatrix ; static { MIN_DIRECT_BUFFER_SIZE = 2 ; INDEX_TYPE = GL . GL_UNSIGNED_SHORT ; } public PJOGL ( PGraphicsOpenGL pg ) { super ( pg ) ; glu = new GLU ( ) ; } protected void setFps ( float fps ) { if ( ! setFps || targetFps != fps ) { if ( 60 < fps ) { gl . setSwapInterval ( 0 ) ; } else if ( 30 < fps ) { gl . setSwapInterval ( 1 ) ; } else { gl . setSwapInterval ( 2 ) ; } targetFps = currentFps = fps ; setFps = true ; } } @ Override protected void getGL ( PGL pgl ) { PJOGL pjogl = ( PJOGL ) pgl ; this . drawable = pjogl . drawable ; this . context = pjogl . context ; this . glContext = pjogl . glContext ; setThread ( pjogl . glThread ) ; this . gl = pjogl . gl ; this . gl2 = pjogl . gl2 ; this . gl2x = pjogl . gl2x ; this . gl3 = pjogl . gl3 ; } protected void getGL ( GLAutoDrawable glDrawable ) { context = glDrawable . getContext ( ) ; glContext = context . hashCode ( ) ; setThread ( Thread . currentThread ( ) ) ; gl = context . getGL ( ) ; gl2 = gl . getGL2ES2 ( ) ; try { gl2x = gl . getGL2 ( ) ; } catch ( com . jogamp . opengl . GLException e ) { gl2x = null ; } try { gl3 = gl . getGL2GL3 ( ) ; } catch ( com . jogamp . opengl . GLException e ) { gl3 = null ; } } @ Override protected void beginGL ( ) { if ( gl2x != null ) { if ( projMatrix == null ) { projMatrix = new float [ 16 ] ; } gl2x . glMatrixMode ( GLMatrixFunc . GL_PROJECTION ) ; projMatrix [ 0 ] = pg . projection . m00 ; projMatrix [ 1 ] = pg . projection . m10 ; projMatrix [ 2 ] = pg . projection . m20 ; projMatrix [ 3 ] = pg . projection . m30 ; projMatrix [ 4 ] = pg . projection . m01 ; projMatrix [ 5 ] = pg . projection . m11 ; projMatrix [ 6 ] = pg . projection . m21 ; projMatrix [ 7 ] = pg . projection . m31 ; projMatrix [ 8 ] = pg . projection . m02 ; projMatrix [ 9 ] = pg . projection . m12 ; projMatrix [ 10 ] = pg . projection . m22 ; projMatrix [ 11 ] = pg . projection . m32 ; projMatrix [ 12 ] = pg . projection . m03 ; projMatrix [ 13 ] = pg . projection . m13 ; projMatrix [ 14 ] = pg . projection . m23 ; projMatrix [ 15 ] = pg . projection . m33 ; gl2x . glLoadMatrixf ( projMatrix , 0 ) ; if ( mvMatrix == null ) { mvMatrix = new float [ 16 ] ; } gl2x . glMatrixMode ( GLMatrixFunc . GL_MODELVIEW ) ; mvMatrix [ 0 ] = pg . modelview . m00 ; mvMatrix [ 1 ] = pg . modelview . m10 ; mvMatrix [ 2 ] = pg . modelview . m20 ; mvMatrix [ 3 ] = pg . modelview . m30 ; mvMatrix [ 4 ] = pg . modelview . m01 ; mvMatrix [ 5 ] = pg . modelview . m11 ; mvMatrix [ 6 ] = pg . modelview . m21 ; mvMatrix [ 7 ] = pg . modelview . m31 ; mvMatrix [ 8 ] = pg . modelview . m02 ; mvMatrix [ 9 ] = pg . modelview . m12 ; mvMatrix [ 10 ] = pg . modelview . m22 ; mvMatrix [ 11 ] = pg . modelview . m32 ; mvMatrix [ 12 ] = pg . modelview . m03 ; mvMatrix [ 13 ] = pg . modelview . m13 ; mvMatrix [ 14 ] = pg . modelview . m23 ; mvMatrix [ 15 ] = pg . modelview . m33 ; gl2x . glLoadMatrixf ( mvMatrix , 0 ) ; } } @ Override protected boolean hasFBOs ( ) { if ( context . hasBasicFBOSupport ( ) ) return true ; else return super . hasFBOs ( ) ; } @ Override protected boolean hasShaders ( ) { if ( context . hasGLSL ( ) ) return true ; else return super . hasShaders ( ) ; } protected void init ( GLAutoDrawable glDrawable ) { firstFrame = true ; capabilities = glDrawable . getChosenGLCapabilities ( ) ; if ( ! hasFBOs ( ) ) { throw new RuntimeException ( MISSING_FBO_ERROR ) ; } if ( ! hasShaders ( ) ) { throw new RuntimeException ( MISSING_GLSL_ERROR ) ; } } @ Override protected void enableTexturing ( int target ) { if ( PROFILE == 2 ) enable ( target ) ; if ( target == TEXTURE_2D ) { texturingTargets [ 0 ] = true ; } else if ( target == TEXTURE_RECTANGLE ) { texturingTargets [ 1 ] = true ; } } @ Override protected void disableTexturing ( int target ) { if ( PROFILE == 2 ) disable ( target ) ; if ( target == TEXTURE_2D ) { texturingTargets [ 0 ] = false ; } else if ( target == TEXTURE_RECTANGLE ) { texturingTargets [ 1 ] = false ; } } @ Override protected int getFontAscent ( Object font ) { return pg . getFontMetrics ( ( Font ) font ) . getAscent ( ) ; } @ Override protected int getFontDescent ( Object font ) { return pg . getFontMetrics ( ( Font ) font ) . getDescent ( ) ; } @ Override protected int getTextWidth ( Object font , char [ ] buffer , int start , int stop ) { int length = stop - start ; FontMetrics metrics = pg . getFontMetrics ( ( Font ) font ) ; return metrics . charsWidth ( buffer , start , length ) ; } @ Override protected Object getDerivedFont ( Object font , float size ) { return ( ( Font ) font ) . deriveFont ( size ) ; } @ Override protected String [ ] loadVertexShader ( String filename , int version ) { if ( 2 < PROFILE && version < 150 ) { String [ ] fragSrc0 = pg . parent . loadStrings ( filename ) ; return convertFragmentSource ( fragSrc0 , version , 150 ) ; } else { return pg . parent . loadStrings ( filename ) ; } } @ Override protected String [ ] loadFragmentShader ( String filename , int version ) { if ( 2 < PROFILE && version < 150 ) { String [ ] vertSrc0 = pg . parent . loadStrings ( filename ) ; return convertVertexSource ( vertSrc0 , version , 150 ) ; } else { return pg . parent . loadStrings ( filename ) ; } } @ Override protected String [ ] loadFragmentShader ( URL url , int version ) { try { if ( 2 < PROFILE && version < 150 ) { String [ ] fragSrc0 = PApplet . loadStrings ( url . openStream ( ) ) ; return convertFragmentSource ( fragSrc0 , version , 150 ) ; } else { return PApplet . loadStrings ( url . openStream ( ) ) ; } } catch ( IOException e ) { PGraphics . showException ( "Cannot load fragment shader " + url . getFile ( ) ) ; } return null ; } @ Override protected String [ ] loadVertexShader ( URL url , int version ) { try { if ( 2 < PROFILE && version < 150 ) { String [ ] vertSrc0 = PApplet . loadStrings ( url . openStream ( ) ) ; return convertVertexSource ( vertSrc0 , version , 150 ) ; } else { return PApplet . loadStrings ( url . openStream ( ) ) ; } } catch ( IOException e ) { PGraphics . showException ( "Cannot load vertex shader " + url . getFile ( ) ) ; } return null ; } @ Override protected Tessellator createTessellator ( TessellatorCallback callback ) { return new Tessellator ( callback ) ; } protected static class Tessellator implements PGL . Tessellator { protected GLUtessellator tess ; protected TessellatorCallback callback ; protected GLUCallback gluCallback ; public Tessellator ( TessellatorCallback callback ) { this . callback = callback ; tess = GLU . gluNewTess ( ) ; gluCallback = new GLUCallback ( ) ; GLU . gluTessCallback ( tess , GLU . GLU_TESS_BEGIN , gluCallback ) ; GLU . gluTessCallback ( tess , GLU . GLU_TESS_END , gluCallback ) ; GLU . gluTessCallback ( tess , GLU . GLU_TESS_VERTEX , gluCallback ) ; GLU . gluTessCallback ( tess , GLU . GLU_TESS_COMBINE , gluCallback ) ; GLU . gluTessCallback ( tess , GLU . GLU_TESS_ERROR , gluCallback ) ; } @ Override public void beginPolygon ( ) { GLU . gluTessBeginPolygon ( tess , null ) ; } @ Override public void endPolygon ( ) { GLU . gluTessEndPolygon ( tess ) ; } @ Override public void setWindingRule ( int rule ) { GLU . gluTessProperty ( tess , GLU . GLU_TESS_WINDING_RULE , rule ) ; } @ Override public void beginContour ( ) { GLU . gluTessBeginContour ( tess ) ; } @ Override public void endContour ( ) { GLU . gluTessEndContour ( tess ) ; } @ Override public void addVertex ( double [ ] v ) { GLU . gluTessVertex ( tess , v , 0 , v ) ; } protected class GLUCallback extends GLUtessellatorCallbackAdapter { @ Override public void begin ( int type ) { callback . begin ( type ) ; } @ Override public void end ( ) { callback . end ( ) ; } @ Override public void vertex ( Object data ) { callback . vertex ( data ) ; } @ Override public void combine ( double [ ] coords , Object [ ] data , float [ ] weight , Object [ ] outData ) { callback . combine ( coords , data , weight , outData ) ; } @ Override public void error ( int errnum ) { callback . error ( errnum ) ; } } } @ Override protected String tessError ( int err ) { return glu . gluErrorString ( err ) ; } static { SHAPE_TEXT_SUPPORTED = true ; SEG_MOVETO = PathIterator . SEG_MOVETO ; SEG_LINETO = PathIterator . SEG_LINETO ; SEG_QUADTO = PathIterator . SEG_QUADTO ; SEG_CUBICTO = PathIterator . SEG_CUBICTO ; SEG_CLOSE = PathIterator . SEG_CLOSE ; } @ Override protected FontOutline createFontOutline ( char ch , Object font ) { return new FontOutline ( ch , ( Font ) font ) ; } protected class FontOutline implements PGL . FontOutline { PathIterator iter ; public FontOutline ( char ch , Font font ) { char textArray [ ] = new char [ ] { ch } ; FontRenderContext frc = pg . getFontRenderContext ( font ) ; GlyphVector gv = font . createGlyphVector ( frc , textArray ) ; Shape shp = gv . getOutline ( ) ; iter = shp . getPathIterator ( null ) ; } public boolean isDone ( ) { return iter . isDone ( ) ; } public int currentSegment ( float coords [ ] ) { return iter . currentSegment ( coords ) ; } public void next ( ) { iter . next ( ) ; } } static { FALSE = GL . GL_FALSE ; TRUE = GL . GL_TRUE ; INT = GL2ES2 . GL_INT ; BYTE = GL . GL_BYTE ; SHORT = GL . GL_SHORT ; FLOAT = GL . GL_FLOAT ; BOOL = GL2ES2 . GL_BOOL ; UNSIGNED_INT = GL . GL_UNSIGNED_INT ; UNSIGNED_BYTE = GL . GL_UNSIGNED_BYTE ; UNSIGNED_SHORT = GL . GL_UNSIGNED_SHORT ; RGB = GL . GL_RGB ; RGBA = GL . GL_RGBA ; ALPHA = GL . GL_ALPHA ; LUMINANCE = GL . GL_LUMINANCE ; LUMINANCE_ALPHA = GL . GL_LUMINANCE_ALPHA ; UNSIGNED_SHORT_5_6_5 = GL . GL_UNSIGNED_SHORT_5_6_5 ; UNSIGNED_SHORT_4_4_4_4 = GL . GL_UNSIGNED_SHORT_4_4_4_4 ; UNSIGNED_SHORT_5_5_5_1 = GL . GL_UNSIGNED_SHORT_5_5_5_1 ; RGBA4 = GL . GL_RGBA4 ; RGB5_A1 = GL . GL_RGB5_A1 ; RGB565 = GL . GL_RGB565 ; RGB8 = GL . GL_RGB8 ; RGBA8 = GL . GL_RGBA8 ; ALPHA8 = GL . GL_ALPHA8 ; READ_ONLY = GL2ES3 . GL_READ_ONLY ; WRITE_ONLY = GL . GL_WRITE_ONLY ; READ_WRITE = GL2ES3 . GL_READ_WRITE ; TESS_WINDING_NONZERO = GLU . GLU_TESS_WINDING_NONZERO ; TESS_WINDING_ODD = GLU . GLU_TESS_WINDING_ODD ; GENERATE_MIPMAP_HINT = GL . GL_GENERATE_MIPMAP_HINT ; FASTEST = GL . GL_FASTEST ; NICEST = GL . GL_NICEST ; DONT_CARE = GL . GL_DONT_CARE ; VENDOR = GL . GL_VENDOR ; RENDERER = GL . GL_RENDERER ; VERSION = GL . GL_VERSION ; EXTENSIONS = GL . GL_EXTENSIONS ; SHADING_LANGUAGE_VERSION = GL2ES2 . GL_SHADING_LANGUAGE_VERSION ; MAX_SAMPLES = GL . GL_MAX_SAMPLES ; SAMPLES = GL . GL_SAMPLES ; ALIASED_LINE_WIDTH_RANGE = GL . GL_ALIASED_LINE_WIDTH_RANGE ; ALIASED_POINT_SIZE_RANGE = GL . GL_ALIASED_POINT_SIZE_RANGE ; DEPTH_BITS = GL . GL_DEPTH_BITS ; STENCIL_BITS = GL . GL_STENCIL_BITS ; CCW = GL . GL_CCW ; CW = GL . GL_CW ; VIEWPORT = GL . GL_VIEWPORT ; ARRAY_BUFFER = GL . GL_ARRAY_BUFFER ; ELEMENT_ARRAY_BUFFER = GL . GL_ELEMENT_ARRAY_BUFFER ; MAX_VERTEX_ATTRIBS = GL2ES2 . GL_MAX_VERTEX_ATTRIBS ; STATIC_DRAW = GL . GL_STATIC_DRAW ; DYNAMIC_DRAW = GL . GL_DYNAMIC_DRAW ; STREAM_DRAW = GL2ES2 . GL_STREAM_DRAW ; BUFFER_SIZE = GL . GL_BUFFER_SIZE ; BUFFER_USAGE = GL . GL_BUFFER_USAGE ; POINTS = GL . GL_POINTS ; LINE_STRIP = GL . GL_LINE_STRIP ; LINE_LOOP = GL . GL_LINE_LOOP ; LINES = GL . GL_LINES ; TRIANGLE_FAN = GL . GL_TRIANGLE_FAN ; TRIANGLE_STRIP = GL . GL_TRIANGLE_STRIP ; TRIANGLES = GL . GL_TRIANGLES ; CULL_FACE = GL . GL_CULL_FACE ; FRONT = GL . GL_FRONT ; BACK = GL . GL_BACK ; FRONT_AND_BACK = GL . GL_FRONT_AND_BACK ; POLYGON_OFFSET_FILL = GL . GL_POLYGON_OFFSET_FILL ; UNPACK_ALIGNMENT = GL . GL_UNPACK_ALIGNMENT ; PACK_ALIGNMENT = GL . GL_PACK_ALIGNMENT ; TEXTURE_2D = GL . GL_TEXTURE_2D ; TEXTURE_RECTANGLE = GL2GL3 . GL_TEXTURE_RECTANGLE ; TEXTURE_BINDING_2D = GL . GL_TEXTURE_BINDING_2D ; TEXTURE_BINDING_RECTANGLE = GL2GL3 . GL_TEXTURE_BINDING_RECTANGLE ; MAX_TEXTURE_SIZE = GL . GL_MAX_TEXTURE_SIZE ; TEXTURE_MAX_ANISOTROPY = GL . GL_TEXTURE_MAX_ANISOTROPY_EXT ; MAX_TEXTURE_MAX_ANISOTROPY = GL . GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT ; MAX_VERTEX_TEXTURE_IMAGE_UNITS = GL2ES2 . GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS ; MAX_TEXTURE_IMAGE_UNITS = GL2ES2 . GL_MAX_TEXTURE_IMAGE_UNITS ; MAX_COMBINED_TEXTURE_IMAGE_UNITS = GL2ES2 . GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS ; NUM_COMPRESSED_TEXTURE_FORMATS = GL . GL_NUM_COMPRESSED_TEXTURE_FORMATS ; COMPRESSED_TEXTURE_FORMATS = GL . GL_COMPRESSED_TEXTURE_FORMATS ; NEAREST = GL . GL_NEAREST ; LINEAR = GL . GL_LINEAR ; LINEAR_MIPMAP_NEAREST = GL . GL_LINEAR_MIPMAP_NEAREST ; LINEAR_MIPMAP_LINEAR = GL . GL_LINEAR_MIPMAP_LINEAR ; CLAMP_TO_EDGE = GL . GL_CLAMP_TO_EDGE ; REPEAT = GL . GL_REPEAT ; TEXTURE0 = GL . GL_TEXTURE0 ; TEXTURE1 = GL . GL_TEXTURE1 ; TEXTURE2 = GL . GL_TEXTURE2 ; TEXTURE3 = GL . GL_TEXTURE3 ; TEXTURE_MIN_FILTER = GL . GL_TEXTURE_MIN_FILTER ; TEXTURE_MAG_FILTER = GL . GL_TEXTURE_MAG_FILTER ; TEXTURE_WRAP_S = GL . GL_TEXTURE_WRAP_S ; TEXTURE_WRAP_T = GL . GL_TEXTURE_WRAP_T ; TEXTURE_WRAP_R = GL2ES2 . GL_TEXTURE_WRAP_R ; TEXTURE_CUBE_MAP = GL . GL_TEXTURE_CUBE_MAP ; TEXTURE_CUBE_MAP_POSITIVE_X = GL . GL_TEXTURE_CUBE_MAP_POSITIVE_X ; TEXTURE_CUBE_MAP_POSITIVE_Y = GL . GL_TEXTURE_CUBE_MAP_POSITIVE_Y ; TEXTURE_CUBE_MAP_POSITIVE_Z = GL . GL_TEXTURE_CUBE_MAP_POSITIVE_Z ; TEXTURE_CUBE_MAP_NEGATIVE_X = GL . GL_TEXTURE_CUBE_MAP_NEGATIVE_X ; TEXTURE_CUBE_MAP_NEGATIVE_Y = GL . GL_TEXTURE_CUBE_MAP_NEGATIVE_Y ; TEXTURE_CUBE_MAP_NEGATIVE_Z = GL . GL_TEXTURE_CUBE_MAP_NEGATIVE_Z ; VERTEX_SHADER = GL2ES2 . GL_VERTEX_SHADER ; FRAGMENT_SHADER = GL2ES2 . GL_FRAGMENT_SHADER ; INFO_LOG_LENGTH = GL2ES2 . GL_INFO_LOG_LENGTH ; SHADER_SOURCE_LENGTH = GL2ES2 . GL_SHADER_SOURCE_LENGTH ; COMPILE_STATUS = GL2ES2 . GL_COMPILE_STATUS ; LINK_STATUS = GL2ES2 . GL_LINK_STATUS ; VALIDATE_STATUS = GL2ES2 . GL_VALIDATE_STATUS ; SHADER_TYPE = GL2ES2 . GL_SHADER_TYPE ; DELETE_STATUS = GL2ES2 . GL_DELETE_STATUS ; FLOAT_VEC2 = GL2ES2 . GL_FLOAT_VEC2 ; FLOAT_VEC3 = GL2ES2 . GL_FLOAT_VEC3 ; FLOAT_VEC4 = GL2ES2 . GL_FLOAT_VEC4 ; FLOAT_MAT2 = GL2ES2 . GL_FLOAT_MAT2 ; FLOAT_MAT3 = GL2ES2 . GL_FLOAT_MAT3 ; FLOAT_MAT4 = GL2ES2 . GL_FLOAT_MAT4 ; INT_VEC2 = GL2ES2 . GL_INT_VEC2 ; INT_VEC3 = GL2ES2 . GL_INT_VEC3 ; INT_VEC4 = GL2ES2 . GL_INT_VEC4 ; BOOL_VEC2 = GL2ES2 . GL_BOOL_VEC2 ; BOOL_VEC3 = GL2ES2 . GL_BOOL_VEC3 ; BOOL_VEC4 = GL2ES2 . GL_BOOL_VEC4 ; SAMPLER_2D = GL2ES2 . GL_SAMPLER_2D ; SAMPLER_CUBE = GL2ES2 . GL_SAMPLER_CUBE ; LOW_FLOAT = GL2ES2 . GL_LOW_FLOAT ; MEDIUM_FLOAT = GL2ES2 . GL_MEDIUM_FLOAT ; HIGH_FLOAT = GL2ES2 . GL_HIGH_FLOAT ; LOW_INT = GL2ES2 . GL_LOW_INT ; MEDIUM_INT = GL2ES2 . GL_MEDIUM_INT ; HIGH_INT = GL2ES2 . GL_HIGH_INT ; CURRENT_VERTEX_ATTRIB = GL2ES2 . GL_CURRENT_VERTEX_ATTRIB ; VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = GL2ES2 . GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING ; VERTEX_ATTRIB_ARRAY_ENABLED = GL2ES2 . GL_VERTEX_ATTRIB_ARRAY_ENABLED ; VERTEX_ATTRIB_ARRAY_SIZE = GL2ES2 . GL_VERTEX_ATTRIB_ARRAY_SIZE ; VERTEX_ATTRIB_ARRAY_STRIDE = GL2ES2 . GL_VERTEX_ATTRIB_ARRAY_STRIDE ; VERTEX_ATTRIB_ARRAY_TYPE = GL2ES2 . GL_VERTEX_ATTRIB_ARRAY_TYPE ; VERTEX_ATTRIB_ARRAY_NORMALIZED = GL2ES2 . GL_VERTEX_ATTRIB_ARRAY_NORMALIZED ; VERTEX_ATTRIB_ARRAY_POINTER = GL2ES2 . GL_VERTEX_ATTRIB_ARRAY_POINTER ; BLEND = GL . GL_BLEND ; ONE = GL . GL_ONE ; ZERO = GL . GL_ZERO ; SRC_ALPHA = GL . GL_SRC_ALPHA ; DST_ALPHA = GL . GL_DST_ALPHA ; ONE_MINUS_SRC_ALPHA = GL . GL_ONE_MINUS_SRC_ALPHA ; ONE_MINUS_DST_COLOR = GL . GL_ONE_MINUS_DST_COLOR ; ONE_MINUS_SRC_COLOR = GL . GL_ONE_MINUS_SRC_COLOR ; DST_COLOR = GL . GL_DST_COLOR ; SRC_COLOR = GL . GL_SRC_COLOR ; SAMPLE_ALPHA_TO_COVERAGE = GL . GL_SAMPLE_ALPHA_TO_COVERAGE ; SAMPLE_COVERAGE = GL . GL_SAMPLE_COVERAGE ; KEEP = GL . GL_KEEP ; REPLACE = GL . GL_REPLACE ; INCR = GL . GL_INCR ; DECR = GL . GL_DECR ; INVERT = GL . GL_INVERT ; INCR_WRAP = GL . GL_INCR_WRAP ; DECR_WRAP = GL . GL_DECR_WRAP ; NEVER = GL . GL_NEVER ; ALWAYS = GL . GL_ALWAYS ; EQUAL = GL . GL_EQUAL ; LESS = GL . GL_LESS ; LEQUAL = GL . GL_LEQUAL ; GREATER = GL . GL_GREATER ; GEQUAL = GL . GL_GEQUAL ; NOTEQUAL = GL . GL_NOTEQUAL ; FUNC_ADD = GL . GL_FUNC_ADD ; FUNC_MIN = GL2ES3 . GL_MIN ; FUNC_MAX = GL2ES3 . GL_MAX ; FUNC_REVERSE_SUBTRACT = GL . GL_FUNC_REVERSE_SUBTRACT ; FUNC_SUBTRACT = GL . GL_FUNC_SUBTRACT ; DITHER = GL . GL_DITHER ; CONSTANT_COLOR = GL2ES2 . GL_CONSTANT_COLOR ; CONSTANT_ALPHA = GL2ES2 . GL_CONSTANT_ALPHA ; ONE_MINUS_CONSTANT_COLOR = GL2ES2 . GL_ONE_MINUS_CONSTANT_COLOR ; ONE_MINUS_CONSTANT_ALPHA = GL2ES2 . GL_ONE_MINUS_CONSTANT_ALPHA ; SRC_ALPHA_SATURATE = GL . GL_SRC_ALPHA_SATURATE ; SCISSOR_TEST = GL . GL_SCISSOR_TEST ; STENCIL_TEST = GL . GL_STENCIL_TEST ; DEPTH_TEST = GL . GL_DEPTH_TEST ; DEPTH_WRITEMASK = GL . GL_DEPTH_WRITEMASK ; ALPHA_TEST = GL2ES1 . GL_ALPHA_TEST ; COLOR_BUFFER_BIT = GL . GL_COLOR_BUFFER_BIT ; DEPTH_BUFFER_BIT = GL . GL_DEPTH_BUFFER_BIT ; STENCIL_BUFFER_BIT = GL . GL_STENCIL_BUFFER_BIT ; FRAMEBUFFER = GL . GL_FRAMEBUFFER ; COLOR_ATTACHMENT0 = GL . GL_COLOR_ATTACHMENT0 ; COLOR_ATTACHMENT1 = GL2ES2 . GL_COLOR_ATTACHMENT1 ; COLOR_ATTACHMENT2 = GL2ES2 . GL_COLOR_ATTACHMENT2 ; COLOR_ATTACHMENT3 = GL2ES2 . GL_COLOR_ATTACHMENT3 ; RENDERBUFFER = GL . GL_RENDERBUFFER ; DEPTH_ATTACHMENT = GL . GL_DEPTH_ATTACHMENT ; STENCIL_ATTACHMENT = GL . GL_STENCIL_ATTACHMENT ; READ_FRAMEBUFFER = GL . GL_READ_FRAMEBUFFER ; DRAW_FRAMEBUFFER = GL . GL_DRAW_FRAMEBUFFER ; RGBA8 = GL . GL_RGBA8 ; DEPTH24_STENCIL8 = GL . GL_DEPTH24_STENCIL8 ; DEPTH_COMPONENT = GL2ES2 . GL_DEPTH_COMPONENT ; DEPTH_COMPONENT16 = GL . GL_DEPTH_COMPONENT16 ; DEPTH_COMPONENT24 = GL . GL_DEPTH_COMPONENT24 ; DEPTH_COMPONENT32 = GL . GL_DEPTH_COMPONENT32 ; STENCIL_INDEX = GL2ES2 . GL_STENCIL_INDEX ; STENCIL_INDEX1 = GL . GL_STENCIL_INDEX1 ; STENCIL_INDEX4 = GL . GL_STENCIL_INDEX4 ; STENCIL_INDEX8 = GL . GL_STENCIL_INDEX8 ; DEPTH_STENCIL = GL . GL_DEPTH_STENCIL ; FRAMEBUFFER_COMPLETE = GL . GL_FRAMEBUFFER_COMPLETE ; FRAMEBUFFER_INCOMPLETE_ATTACHMENT = GL . GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT ; FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = GL . GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT ; FRAMEBUFFER_INCOMPLETE_DIMENSIONS = GL . GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS ; FRAMEBUFFER_INCOMPLETE_FORMATS = GL . GL_FRAMEBUFFER_INCOMPLETE_FORMATS ; FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = GL2GL3 . GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER ; FRAMEBUFFER_INCOMPLETE_READ_BUFFER = GL2GL3 . GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER ; FRAMEBUFFER_UNSUPPORTED = GL . GL_FRAMEBUFFER_UNSUPPORTED ; FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = GL . GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE ; FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = GL . GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME ; FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = GL . GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL ; FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = GL . GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE ; RENDERBUFFER_WIDTH = GL . GL_RENDERBUFFER_WIDTH ; RENDERBUFFER_HEIGHT = GL . GL_RENDERBUFFER_HEIGHT ; RENDERBUFFER_RED_SIZE = GL . GL_RENDERBUFFER_RED_SIZE ; RENDERBUFFER_GREEN_SIZE = GL . GL_RENDERBUFFER_GREEN_SIZE ; RENDERBUFFER_BLUE_SIZE = GL . GL_RENDERBUFFER_BLUE_SIZE ; RENDERBUFFER_ALPHA_SIZE = GL . GL_RENDERBUFFER_ALPHA_SIZE ; RENDERBUFFER_DEPTH_SIZE = GL . GL_RENDERBUFFER_DEPTH_SIZE ; RENDERBUFFER_STENCIL_SIZE = GL . GL_RENDERBUFFER_STENCIL_SIZE ; RENDERBUFFER_INTERNAL_FORMAT = GL . GL_RENDERBUFFER_INTERNAL_FORMAT ; MULTISAMPLE = GL . GL_MULTISAMPLE ; POINT_SMOOTH = GL2ES1 . GL_POINT_SMOOTH ; LINE_SMOOTH = GL . GL_LINE_SMOOTH ; POLYGON_SMOOTH = GL2GL3 . GL_POLYGON_SMOOTH ; } @ Override public void flush ( ) { gl . glFlush ( ) ; } @ Override public void finish ( ) { gl . glFinish ( ) ; } @ Override public void hint ( int target , int hint ) { gl . glHint ( target , hint ) ; } @ Override public void enable ( int value ) { if ( - 1 < value ) { gl . glEnable ( value ) ; } } @ Override public void disable ( int value ) { if ( - 1 < value ) { gl . glDisable ( value ) ; } } @ Override public void getBooleanv ( int value , IntBuffer data ) { if ( - 1 < value ) { if ( byteBuffer . capacity ( ) < data . capacity ( ) ) { byteBuffer = allocateDirectByteBuffer ( data . capacity ( ) ) ; } gl . glGetBooleanv ( value , byteBuffer ) ; for ( int i = 0 ; i < data . capacity ( ) ; i ++ ) { data . put ( i , byteBuffer . get ( i ) ) ; } } else { fillIntBuffer ( data , 0 , data . capacity ( ) - 1 , 0 ) ; } } @ Override public void getIntegerv ( int value , IntBuffer data ) { if ( - 1 < value ) { gl . glGetIntegerv ( value , data ) ; } else { fillIntBuffer ( data , 0 , data . capacity ( ) - 1 , 0 ) ; } } @ Override public void getFloatv ( int value , FloatBuffer data ) { if ( - 1 < value ) { gl . glGetFloatv ( value , data ) ; } else { fillFloatBuffer ( data , 0 , data . capacity ( ) - 1 , 0 ) ; } } @ Override public boolean isEnabled ( int value ) { return gl . glIsEnabled ( value ) ; } @ Override public String getString ( int name ) { return gl . glGetString ( name ) ; } @ Override public int getError ( ) { return gl . glGetError ( ) ; } @ Override public String errorString ( int err ) { return glu . gluErrorString ( err ) ; } @ Override public void genBuffers ( int n , IntBuffer buffers ) { gl . glGenBuffers ( n , buffers ) ; } @ Override public void deleteBuffers ( int n , IntBuffer buffers ) { gl . glDeleteBuffers ( n , buffers ) ; } @ Override public void bindBuffer ( int target , int buffer ) { gl . glBindBuffer ( target , buffer ) ; } @ Override public void bufferData ( int target , int size , Buffer data , int usage ) { gl . glBufferData ( target , size , data , usage ) ; } @ Override public void bufferSubData ( int target , int offset , int size , Buffer data ) { gl . glBufferSubData ( target , offset , size , data ) ; } @ Override public void isBuffer ( int buffer ) { gl . glIsBuffer ( buffer ) ; } @ Override public void getBufferParameteriv ( int target , int value , IntBuffer data ) { gl . glGetBufferParameteriv ( target , value , data ) ; } @ Override public ByteBuffer mapBuffer ( int target , int access ) { return gl2 . glMapBuffer ( target , access ) ; } @ Override public ByteBuffer mapBufferRange ( int target , int offset , int length , int access ) { if ( gl2x != null ) { return gl2x . glMapBufferRange ( target , offset , length , access ) ; } else if ( gl3 != null ) { return gl3 . glMapBufferRange ( target , offset , length , access ) ; } else { throw new RuntimeException ( String . format ( MISSING_GLFUNC_ERROR , "glMapBufferRange()" ) ) ; } } @ Override public void unmapBuffer ( int target ) { gl2 . glUnmapBuffer ( target ) ; } @ Override public void depthRangef ( float n , float f ) { gl . glDepthRangef ( n , f ) ; } @ Override public void viewport ( int x , int y , int w , int h ) { float scale = pg . getPixelScale ( ) ; gl . glViewport ( ( int ) scale * x , ( int ) ( scale * y ) , ( int ) ( scale * w ) , ( int ) ( scale * h ) ) ; } @ Override protected void readPixelsImpl ( int x , int y , int width , int height , int format , int type , Buffer buffer ) { gl . glReadPixels ( x , y , width , height , format , type , buffer ) ; } @ Override public void vertexAttrib1f ( int index , float value ) { gl2 . glVertexAttrib1f ( index , value ) ; } @ Override public void vertexAttrib2f ( int index , float value0 , float value1 ) { gl2 . glVertexAttrib2f ( index , value0 , value1 ) ; } @ Override public void vertexAttrib3f ( int index , float value0 , float value1 , float value2 ) { gl2 . glVertexAttrib3f ( index , value0 , value1 , value2 ) ; } @ Override public void vertexAttrib4f ( int index , float value0 , float value1 , float value2 , float value3 ) { gl2 . glVertexAttrib4f ( index , value0 , value1 , value2 , value3 ) ; } @ Override public void vertexAttrib1fv ( int index , FloatBuffer values ) { gl2 . glVertexAttrib1fv ( index , values ) ; } @ Override public void vertexAttrib2fv ( int index , FloatBuffer values ) { gl2 . glVertexAttrib2fv ( index , values ) ; } @ Override public void vertexAttrib3fv ( int index , FloatBuffer values ) { gl2 . glVertexAttrib3fv ( index , values ) ; } @ Override public void vertexAttri4fv ( int index , FloatBuffer values ) { gl2 . glVertexAttrib4fv ( index , values ) ; } @ Override public void vertexAttribPointer ( int index , int size , int type , boolean normalized , int stride , int offset ) { gl2 . glVertexAttribPointer ( index , size , type , normalized , stride , offset ) ; } @ Override public void vertexAttribPointer ( int index , int size , int type , boolean normalized , int stride , Buffer data ) { if ( gl2x != null ) { gl2x . glVertexAttribPointer ( index , size , type , normalized , stride , data ) ; } else { throw new RuntimeException ( String . format ( MISSING_GLFUNC_ERROR , "glVertexAttribPointer()" ) ) ; } } @ Override public void enableVertexAttribArray ( int index ) { gl2 . glEnableVertexAttribArray ( index ) ; } @ Override public void disableVertexAttribArray ( int index ) { gl2 . glDisableVertexAttribArray ( index ) ; } @ Override public void drawArrays ( int mode , int first , int count ) { gl . glDrawArrays ( mode , first , count ) ; } @ Override public void drawElements ( int mode , int count , int type , int offset ) { gl . glDrawElements ( mode , count , type , offset ) ; } @ Override public void drawElements ( int mode , int count , int type , Buffer indices ) { if ( gl2x != null ) { gl2x . glDrawElements ( mode , count , type , indices ) ; } else { throw new RuntimeException ( String . format ( MISSING_GLFUNC_ERROR , "glDrawElements()" ) ) ; } } @ Override public void lineWidth ( float width ) { gl . glLineWidth ( width ) ; } @ Override public void frontFace ( int dir ) { gl . glFrontFace ( dir ) ; } @ Override public void cullFace ( int mode ) { gl . glCullFace ( mode ) ; } @ Override public void polygonOffset ( float factor , float units ) { gl . glPolygonOffset ( factor , units ) ; } @ Override public void pixelStorei ( int pname , int param ) { gl . glPixelStorei ( pname , param ) ; } @ Override public void texImage2D ( int target , int level , int internalFormat , int width , int height , int border , int format , int type , Buffer data ) { gl . glTexImage2D ( target , level , internalFormat , width , height , border , format , type , data ) ; } @ Override public void copyTexImage2D ( int target , int level , int internalFormat , int x , int y , int width , int height , int border ) { gl . glCopyTexImage2D ( target , level , internalFormat , x , y , width , height , border ) ; } @ Override public void texSubImage2D ( int target , int level , int xOffset , int yOffset , int width , int height , int format , int type , Buffer data ) { gl . glTexSubImage2D ( target , level , xOffset , yOffset , width , height , format , type , data ) ; } @ Override public void copyTexSubImage2D ( int target , int level , int xOffset , int yOffset , int x , int y , int width , int height ) { gl . glCopyTexSubImage2D ( target , level , x , y , xOffset , yOffset , width , height ) ; } @ Override public void compressedTexImage2D ( int target , int level , int internalFormat , int width , int height , int border , int imageSize , Buffer data ) { gl . glCompressedTexImage2D ( target , level , internalFormat , width , height , border , imageSize , data ) ; } @ Override public void compressedTexSubImage2D ( int target , int level , int xOffset , int yOffset , int width , int height , int format , int imageSize , Buffer data ) { gl . glCompressedTexSubImage2D ( target , level , xOffset , yOffset , width , height , format , imageSize , data ) ; } @ Override public void texParameteri ( int target , int pname , int param ) { gl . glTexParameteri ( target , pname , param ) ; } @ Override public void texParameterf ( int target , int pname , float param ) { gl . glTexParameterf ( target , pname , param ) ; } @ Override public void texParameteriv ( int target , int pname , IntBuffer params ) { gl . glTexParameteriv ( target , pname , params ) ; } @ Override public void texParameterfv ( int target , int pname , FloatBuffer params ) { gl . glTexParameterfv ( target , pname , params ) ; } @ Override public void generateMipmap ( int target ) { gl . glGenerateMipmap ( target ) ; } @ Override public void genTextures ( int n , IntBuffer textures ) { gl . glGenTextures ( n , textures ) ; } @ Override public void deleteTextures ( int n , IntBuffer textures ) { gl . glDeleteTextures ( n , textures ) ; } @ Override public void getTexParameteriv ( int target , int pname , IntBuffer params ) { gl . glGetTexParameteriv ( target , pname , params ) ; } @ Override public void getTexParameterfv ( int target , int pname , FloatBuffer params ) { gl . glGetTexParameterfv ( target , pname , params ) ; } @ Override public boolean isTexture ( int texture ) { return gl . glIsTexture ( texture ) ; } @ Override protected void activeTextureImpl ( int texture ) { gl . glActiveTexture ( texture ) ; } @ Override protected void bindTextureImpl ( int target , int texture ) { gl . glBindTexture ( target , texture ) ; } @ Override public int createShader ( int type ) { return gl2 . glCreateShader ( type ) ; } @ Override public void shaderSource ( int shader , String source ) { gl2 . glShaderSource ( shader , 1 , new String [ ] { source } , ( int [ ] ) null , 0 ) ; } @ Override public void compileShader ( int shader ) { gl2 . glCompileShader ( shader ) ; } @ Override public void releaseShaderCompiler ( ) { gl2 . glReleaseShaderCompiler ( ) ; } @ Override public void deleteShader ( int shader ) { gl2 . glDeleteShader ( shader ) ; } @ Override public void shaderBinary ( int count , IntBuffer shaders , int binaryFormat , Buffer binary , int length ) { gl2 . glShaderBinary ( count , shaders , binaryFormat , binary , length ) ; } @ Override public int createProgram ( ) { return gl2 . glCreateProgram ( ) ; } @ Override public void attachShader ( int program , int shader ) { gl2 . glAttachShader ( program , shader ) ; } @ Override public void detachShader ( int program , int shader ) { gl2 . glDetachShader ( program , shader ) ; } @ Override public void linkProgram ( int program ) { gl2 . glLinkProgram ( program ) ; } @ Override public void useProgram ( int program ) { gl2 . glUseProgram ( program ) ; } @ Override public void deleteProgram ( int program ) { gl2 . glDeleteProgram ( program ) ; } @ Override public String getActiveAttrib ( int program , int index , IntBuffer size , IntBuffer type ) { int [ ] tmp = { 0 , 0 , 0 } ; byte [ ] namebuf = new byte [ 1024 ] ; gl2 . glGetActiveAttrib ( program , index , 1024 , tmp , 0 , tmp , 1 , tmp , 2 , namebuf , 0 ) ; size . put ( tmp [ 1 ] ) ; type . put ( tmp [ 2 ] ) ; String name = new String ( namebuf , 0 , tmp [ 0 ] ) ; return name ; } @ Override public int getAttribLocation ( int program , String name ) { return gl2 . glGetAttribLocation ( program , name ) ; } @ Override public void bindAttribLocation ( int program , int index , String name ) { gl2 . glBindAttribLocation ( program , index , name ) ; } @ Override public int getUniformLocation ( int program , String name ) { return gl2 . glGetUniformLocation ( program , name ) ; } @ Override public String getActiveUniform ( int program , int index , IntBuffer size , IntBuffer type ) { int [ ] tmp = { 0 , 0 , 0 } ; byte [ ] namebuf = new byte [ 1024 ] ; gl2 . glGetActiveUniform ( program , index , 1024 , tmp , 0 , tmp , 1 , tmp , 2 , namebuf , 0 ) ; size . put ( tmp [ 1 ] ) ; type . put ( tmp [ 2 ] ) ; String name = new String ( namebuf , 0 , tmp [ 0 ] ) ; return name ; } @ Override public void uniform1i ( int location , int value ) { gl2 . glUniform1i ( location , value ) ; } @ Override public void uniform2i ( int location , int value0 , int value1 ) { gl2 . glUniform2i ( location , value0 , value1 ) ; } @ Override public void uniform3i ( int location , int value0 , int value1 , int value2 ) { gl2 . glUniform3i ( location , value0 , value1 , value2 ) ; } @ Override public void uniform4i ( int location , int value0 , int value1 , int value2 , int value3 ) { gl2 . glUniform4i ( location , value0 , value1 , value2 , value3 ) ; } @ Override public void uniform1f ( int location , float value ) { gl2 . glUniform1f ( location , value ) ; } @ Override public void uniform2f ( int location , float value0 , float value1 ) { gl2 . glUniform2f ( location , value0 , value1 ) ; } @ Override public void uniform3f ( int location , float value0 , float value1 , float value2 ) { gl2 . glUniform3f ( location , value0 , value1 , value2 ) ; } @ Override public void uniform4f ( int location , float value0 , float value1 , float value2 , float value3 ) { gl2 . glUniform4f ( location , value0 , value1 , value2 , value3 ) ; } @ Override public void uniform1iv ( int location , int count , IntBuffer v ) { gl2 . glUniform1iv ( location , count , v ) ; } @ Override public void uniform2iv ( int location , int count , IntBuffer v ) { gl2 . glUniform2iv ( location , count , v ) ; } @ Override public void uniform3iv ( int location , int count , IntBuffer v ) { gl2 . glUniform3iv ( location , count , v ) ; } @ Override public void uniform4iv ( int location , int count , IntBuffer v ) { gl2 . glUniform4iv ( location , count , v ) ; } @ Override public void uniform1fv ( int location , int count , FloatBuffer v ) { gl2 . glUniform1fv ( location , count , v ) ; } @ Override public void uniform2fv ( int location , int count , FloatBuffer v ) { gl2 . glUniform2fv ( location , count , v ) ; } @ Override public void uniform3fv ( int location , int count , FloatBuffer v ) { gl2 . glUniform3fv ( location , count , v ) ; } @ Override public void uniform4fv ( int location , int count , FloatBuffer v ) { gl2 . glUniform4fv ( location , count , v ) ; } @ Override public void uniformMatrix2fv ( int location , int count , boolean transpose , FloatBuffer mat ) { gl2 . glUniformMatrix2fv ( location , count , transpose , mat ) ; } @ Override public void uniformMatrix3fv ( int location , int count , boolean transpose , FloatBuffer mat ) { gl2 . glUniformMatrix3fv ( location , count , transpose , mat ) ; } @ Override public void uniformMatrix4fv ( int location , int count , boolean transpose , FloatBuffer mat ) { gl2 . glUniformMatrix4fv ( location , count , transpose , mat ) ; } @ Override public void validateProgram ( int program ) { gl2 . glValidateProgram ( program ) ; } @ Override public boolean isShader ( int shader ) { return gl2 . glIsShader ( shader ) ; } @ Override public void getShaderiv ( int shader , int pname , IntBuffer params ) { gl2 . glGetShaderiv ( shader , pname , params ) ; } @ Override public void getAttachedShaders ( int program , int maxCount , IntBuffer count , IntBuffer shaders ) { gl2 . glGetAttachedShaders ( program , maxCount , count , shaders ) ; } @ Override public String getShaderInfoLog ( int shader ) { int [ ] val = { 0 } ; gl2 . glGetShaderiv ( shader , GL2ES2 . GL_INFO_LOG_LENGTH , val , 0 ) ; int length = val [ 0 ] ; byte [ ] log = new byte [ length ] ; gl2 . glGetShaderInfoLog ( shader , length , val , 0 , log , 0 ) ; return new String ( log ) ; } @ Override public String getShaderSource ( int shader ) { int [ ] len = { 0 } ; byte [ ] buf = new byte [ 1024 ] ; gl2 . glGetShaderSource ( shader , 1024 , len , 0 , buf , 0 ) ; return new String ( buf , 0 , len [ 0 ] ) ; } @ Override public void getShaderPrecisionFormat ( int shaderType , int precisionType , IntBuffer range , IntBuffer precision ) { gl2 . glGetShaderPrecisionFormat ( shaderType , precisionType , range , precision ) ; } @ Override public void getVertexAttribfv ( int index , int pname , FloatBuffer params ) { gl2 . glGetVertexAttribfv ( index , pname , params ) ; } @ Override public void getVertexAttribiv ( int index , int pname , IntBuffer params ) { gl2 . glGetVertexAttribiv ( index , pname , params ) ; } @ Override public void getVertexAttribPointerv ( int index , int pname , ByteBuffer data ) { throw new RuntimeException ( String . format ( MISSING_GLFUNC_ERROR , "glGetVertexAttribPointerv()" ) ) ; } @ Override public void getUniformfv ( int program , int location , FloatBuffer params ) { gl2 . glGetUniformfv ( program , location , params ) ; } @ Override public void getUniformiv ( int program , int location , IntBuffer params ) { gl2 . glGetUniformiv ( program , location , params ) ; } @ Override public boolean isProgram ( int program ) { return gl2 . glIsProgram ( program ) ; } @ Override public void getProgramiv ( int program , int pname , IntBuffer params ) { gl2 . glGetProgramiv ( program , pname , params ) ; } @ Override public String getProgramInfoLog ( int program ) { int [ ] val = { 0 } ; gl2 . glGetShaderiv ( program , GL2ES2 . GL_INFO_LOG_LENGTH , val , 0 ) ; int length = val [ 0 ] ; if ( 0 < length ) { byte [ ] log = new byte [ length ] ; gl2 . glGetProgramInfoLog ( program , length , val , 0 , log , 0 ) ; return new String ( log ) ; } else { return "Unknow error" ; } } @ Override public void scissor ( int x , int y , int w , int h ) { float scale = pg . getPixelScale ( ) ; gl . glScissor ( ( int ) scale * x , ( int ) ( scale * y ) , ( int ) ( scale * w ) , ( int ) ( scale * h ) ) ; } @ Override public void sampleCoverage ( float value , boolean invert ) { gl2 . glSampleCoverage ( value , invert ) ; } @ Override public void stencilFunc ( int func , int ref , int mask ) { gl2 . glStencilFunc ( func , ref , mask ) ; } @ Override public void stencilFuncSeparate ( int face , int func , int ref , int mask ) { gl2 . glStencilFuncSeparate ( face , func , ref , mask ) ; } @ Override public void stencilOp ( int sfail , int dpfail , int dppass ) { gl2 . glStencilOp ( sfail , dpfail , dppass ) ; } @ Override public void stencilOpSeparate ( int face , int sfail , int dpfail , int dppass ) { gl2 . glStencilOpSeparate ( face , sfail , dpfail , dppass ) ; } @ Override public void depthFunc ( int func ) { gl . glDepthFunc ( func ) ; } @ Override public void blendEquation ( int mode ) { gl . glBlendEquation ( mode ) ; } @ Override public void blendEquationSeparate ( int modeRGB , int modeAlpha ) { gl . glBlendEquationSeparate ( modeRGB , modeAlpha ) ; } @ Override public void blendFunc ( int src , int dst ) { gl . glBlendFunc ( src , dst ) ; } @ Override public void blendFuncSeparate ( int srcRGB , int dstRGB , int srcAlpha , int dstAlpha ) { gl . glBlendFuncSeparate ( srcRGB , dstRGB , srcAlpha , dstAlpha ) ; } @ Override public void blendColor ( float red , float green , float blue , float alpha ) { gl2 . glBlendColor ( red , green , blue , alpha ) ; } @ Override public void alphaFunc ( int func , float ref ) { if ( gl2x != null ) { gl2x . glAlphaFunc ( func , ref ) ; } else { throw new RuntimeException ( String . format ( MISSING_GLFUNC_ERROR , "glAlphaFunc()" ) ) ; } } @ Override public void colorMask ( boolean r , boolean g , boolean b , boolean a ) { gl . glColorMask ( r , g , b , a ) ; } @ Override public void depthMask ( boolean mask ) { gl . glDepthMask ( mask ) ; } @ Override public void stencilMask ( int mask ) { gl . glStencilMask ( mask ) ; } @ Override public void stencilMaskSeparate ( int face , int mask ) { gl2 . glStencilMaskSeparate ( face , mask ) ; } @ Override public void clear ( int buf ) { gl . glClear ( buf ) ; } @ Override public void clearColor ( float r , float g , float b , float a ) { gl . glClearColor ( r , g , b , a ) ; } @ Override public void clearDepth ( float d ) { gl . glClearDepthf ( d ) ; } @ Override public void clearStencil ( int s ) { gl . glClearStencil ( s ) ; } @ Override protected void bindFramebufferImpl ( int target , int framebuffer ) { gl . glBindFramebuffer ( target , framebuffer ) ; } @ Override public void deleteFramebuffers ( int n , IntBuffer framebuffers ) { gl . glDeleteFramebuffers ( n , framebuffers ) ; } @ Override public void genFramebuffers ( int n , IntBuffer framebuffers ) { gl . glGenFramebuffers ( n , framebuffers ) ; } @ Override public void bindRenderbuffer ( int target , int renderbuffer ) { gl . glBindRenderbuffer ( target , renderbuffer ) ; } @ Override public void deleteRenderbuffers ( int n , IntBuffer renderbuffers ) { gl . glDeleteRenderbuffers ( n , renderbuffers ) ; } @ Override public void genRenderbuffers ( int n , IntBuffer renderbuffers ) { gl . glGenRenderbuffers ( n , renderbuffers ) ; } @ Override public void renderbufferStorage ( int target , int internalFormat , int width , int height ) { gl . glRenderbufferStorage ( target , internalFormat , width , height ) ; } @ Override public void framebufferRenderbuffer ( int target , int attachment , int rendbuferfTarget , int renderbuffer ) { gl . glFramebufferRenderbuffer ( target , attachment , rendbuferfTarget , renderbuffer ) ; } @ Override public void framebufferTexture2D ( int target , int attachment , int texTarget , int texture , int level ) { gl . glFramebufferTexture2D ( target , attachment , texTarget , texture , level ) ; } @ Override public int checkFramebufferStatus ( int target ) { return gl . glCheckFramebufferStatus ( target ) ; } @ Override public boolean isFramebuffer ( int framebuffer ) { return gl2 . glIsFramebuffer ( framebuffer ) ; } @ Override public void getFramebufferAttachmentParameteriv ( int target , int attachment , int pname , IntBuffer params ) { gl2 . glGetFramebufferAttachmentParameteriv ( target , attachment , pname , params ) ; } @ Override public boolean isRenderbuffer ( int renderbuffer ) { return gl2 . glIsRenderbuffer ( renderbuffer ) ; } @ Override public void getRenderbufferParameteriv ( int target , int pname , IntBuffer params ) { gl2 . glGetRenderbufferParameteriv ( target , pname , params ) ; } @ Override public void blitFramebuffer ( int srcX0 , int srcY0 , int srcX1 , int srcY1 , int dstX0 , int dstY0 , int dstX1 , int dstY1 , int mask , int filter ) { if ( gl2x != null ) { gl2x . glBlitFramebuffer ( srcX0 , srcY0 , srcX1 , srcY1 , dstX0 , dstY0 , dstX1 , dstY1 , mask , filter ) ; } else if ( gl3 != null ) { gl3 . glBlitFramebuffer ( srcX0 , srcY0 , srcX1 , srcY1 , dstX0 , dstY0 , dstX1 , dstY1 , mask , filter ) ; } else { throw new RuntimeException ( String . format ( MISSING_GLFUNC_ERROR , "glBlitFramebuffer()" ) ) ; } } @ Override public void renderbufferStorageMultisample ( int target , int samples , int format , int width , int height ) { if ( gl2x != null ) { gl2x . glRenderbufferStorageMultisample ( target , samples , format , width , height ) ; } else if ( gl3 != null ) { gl3 . glRenderbufferStorageMultisample ( target , samples , format , width , height ) ; } else { throw new RuntimeException ( String . format ( MISSING_GLFUNC_ERROR , "glRenderbufferStorageMultisample()" ) ) ; } } @ Override public void readBuffer ( int buf ) { if ( gl2x != null ) { gl2x . glReadBuffer ( buf ) ; } else if ( gl3 != null ) { gl3 . glReadBuffer ( buf ) ; } else { throw new RuntimeException ( String . format ( MISSING_GLFUNC_ERROR , "glReadBuffer()" ) ) ; } } @ Override public void drawBuffer ( int buf ) { if ( gl2x != null ) { gl2x . glDrawBuffer ( buf ) ; } else if ( gl3 != null ) { gl3 . glDrawBuffer ( buf ) ; } else { throw new RuntimeException ( String . format ( MISSING_GLFUNC_ERROR , "glDrawBuffer()" ) ) ; } } }
package processing . opengl ; import processing . core . PApplet ; import processing . core . PConstants ; import processing . core . PGraphics ; import processing . core . PImage ; import processing . core . PMatrix ; import processing . core . PMatrix2D ; import processing . core . PMatrix3D ; import processing . core . PShape ; import processing . core . PVector ; import processing . opengl . PGraphicsOpenGL . AttributeMap ; import processing . opengl . PGraphicsOpenGL . IndexCache ; import processing . opengl . PGraphicsOpenGL . InGeometry ; import processing . opengl . PGraphicsOpenGL . TessGeometry ; import processing . opengl . PGraphicsOpenGL . Tessellator ; import processing . opengl . PGraphicsOpenGL . VertexAttribute ; import java . nio . Buffer ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Stack ; public class PShapeOpenGL extends PShape { static public final int POSITION = 0 ; static public final int NORMAL = 1 ; static public final int TEXCOORD = 2 ; static public final int DIRECTION = 3 ; static public final int OFFSET = 4 ; static protected final int TRANSLATE = 0 ; static protected final int ROTATE = 1 ; static protected final int SCALE = 2 ; static protected final int MATRIX = 3 ; protected PGraphicsOpenGL pg ; protected PGL pgl ; protected int context ; protected PShapeOpenGL root ; protected InGeometry inGeo ; protected TessGeometry tessGeo ; protected Tessellator tessellator ; protected AttributeMap polyAttribs ; protected HashSet < PImage > textures ; protected boolean strokedTexture ; public int glPolyVertex ; public int glPolyColor ; public int glPolyNormal ; public int glPolyTexcoord ; public int glPolyAmbient ; public int glPolySpecular ; public int glPolyEmissive ; public int glPolyShininess ; public int glPolyIndex ; public int glLineVertex ; public int glLineColor ; public int glLineAttrib ; public int glLineIndex ; public int glPointVertex ; public int glPointColor ; public int glPointAttrib ; public int glPointIndex ; public int glUsage = PGL . STATIC_DRAW ; protected int polyVertCopyOffset ; protected int polyIndCopyOffset ; protected int lineVertCopyOffset ; protected int lineIndCopyOffset ; protected int pointVertCopyOffset ; protected int pointIndCopyOffset ; protected int polyIndexOffset ; protected int polyVertexOffset ; protected int polyVertexAbs ; protected int polyVertexRel ; protected int lineIndexOffset ; protected int lineVertexOffset ; protected int lineVertexAbs ; protected int lineVertexRel ; protected int pointIndexOffset ; protected int pointVertexOffset ; protected int pointVertexAbs ; protected int pointVertexRel ; protected int firstPolyIndexCache ; protected int lastPolyIndexCache ; protected int firstLineIndexCache ; protected int lastLineIndexCache ; protected int firstPointIndexCache ; protected int lastPointIndexCache ; protected int firstPolyVertex ; protected int lastPolyVertex ; protected int firstLineVertex ; protected int lastLineVertex ; protected int firstPointVertex ; protected int lastPointVertex ; protected PMatrix transform ; protected Stack < PMatrix > transformStack ; protected boolean tessellated ; protected boolean needBufferInit = false ; protected boolean solid = true ; protected boolean breakShape = false ; protected boolean shapeCreated = false ; protected boolean hasPolys ; protected boolean hasLines ; protected boolean hasPoints ; protected int bezierDetail ; protected int curveDetail ; protected float curveTightness ; protected int savedBezierDetail ; protected int savedCurveDetail ; protected float savedCurveTightness ; protected float normalX , normalY , normalZ ; static protected final int NORMAL_MODE_AUTO = 0 ; static protected final int NORMAL_MODE_SHAPE = 1 ; static protected final int NORMAL_MODE_VERTEX = 2 ; protected int normalMode ; protected boolean modified ; protected boolean modifiedPolyVertices ; protected boolean modifiedPolyColors ; protected boolean modifiedPolyNormals ; protected boolean modifiedPolyTexCoords ; protected boolean modifiedPolyAmbient ; protected boolean modifiedPolySpecular ; protected boolean modifiedPolyEmissive ; protected boolean modifiedPolyShininess ; protected boolean modifiedLineVertices ; protected boolean modifiedLineColors ; protected boolean modifiedLineAttributes ; protected boolean modifiedPointVertices ; protected boolean modifiedPointColors ; protected boolean modifiedPointAttributes ; protected int firstModifiedPolyVertex ; protected int lastModifiedPolyVertex ; protected int firstModifiedPolyColor ; protected int lastModifiedPolyColor ; protected int firstModifiedPolyNormal ; protected int lastModifiedPolyNormal ; protected int firstModifiedPolyTexcoord ; protected int lastModifiedPolyTexcoord ; protected int firstModifiedPolyAmbient ; protected int lastModifiedPolyAmbient ; protected int firstModifiedPolySpecular ; protected int lastModifiedPolySpecular ; protected int firstModifiedPolyEmissive ; protected int lastModifiedPolyEmissive ; protected int firstModifiedPolyShininess ; protected int lastModifiedPolyShininess ; protected int firstModifiedLineVertex ; protected int lastModifiedLineVertex ; protected int firstModifiedLineColor ; protected int lastModifiedLineColor ; protected int firstModifiedLineAttribute ; protected int lastModifiedLineAttribute ; protected int firstModifiedPointVertex ; protected int lastModifiedPointVertex ; protected int firstModifiedPointColor ; protected int lastModifiedPointColor ; protected int firstModifiedPointAttribute ; protected int lastModifiedPointAttribute ; protected boolean savedStroke ; protected int savedStrokeColor ; protected float savedStrokeWeight ; protected int savedStrokeCap ; protected int savedStrokeJoin ; protected boolean savedFill ; protected int savedFillColor ; protected boolean savedTint ; protected int savedTintColor ; protected int savedAmbientColor ; protected int savedSpecularColor ; protected int savedEmissiveColor ; protected float savedShininess ; protected int savedTextureMode ; PShapeOpenGL ( ) { } public PShapeOpenGL ( PGraphicsOpenGL pg , int family ) { this . pg = pg ; this . family = family ; pgl = pg . pgl ; context = pgl . createEmptyContext ( ) ; glPolyVertex = 0 ; glPolyColor = 0 ; glPolyNormal = 0 ; glPolyTexcoord = 0 ; glPolyAmbient = 0 ; glPolySpecular = 0 ; glPolyEmissive = 0 ; glPolyShininess = 0 ; glPolyIndex = 0 ; glLineVertex = 0 ; glLineColor = 0 ; glLineAttrib = 0 ; glLineIndex = 0 ; glPointVertex = 0 ; glPointColor = 0 ; glPointAttrib = 0 ; glPointIndex = 0 ; this . tessellator = PGraphicsOpenGL . tessellator ; this . root = this ; this . parent = null ; this . tessellated = false ; if ( family == GEOMETRY || family == PRIMITIVE || family == PATH ) { polyAttribs = PGraphicsOpenGL . newAttributeMap ( ) ; inGeo = PGraphicsOpenGL . newInGeometry ( pg , polyAttribs , PGraphicsOpenGL . RETAINED ) ; } textureMode = pg . textureMode ; colorMode ( pg . colorMode , pg . colorModeX , pg . colorModeY , pg . colorModeZ , pg . colorModeA ) ; fill = pg . fill ; fillColor = pg . fillColor ; stroke = pg . stroke ; strokeColor = pg . strokeColor ; strokeWeight = pg . strokeWeight ; strokeCap = pg . strokeCap ; strokeJoin = pg . strokeJoin ; tint = pg . tint ; tintColor = pg . tintColor ; setAmbient = pg . setAmbient ; ambientColor = pg . ambientColor ; specularColor = pg . specularColor ; emissiveColor = pg . emissiveColor ; shininess = pg . shininess ; sphereDetailU = pg . sphereDetailU ; sphereDetailV = pg . sphereDetailV ; bezierDetail = pg . bezierDetail ; curveDetail = pg . curveDetail ; curveTightness = pg . curveTightness ; rectMode = CORNER ; ellipseMode = CORNER ; normalX = normalY = 0 ; normalZ = 1 ; normalMode = NORMAL_MODE_AUTO ; breakShape = false ; if ( family == GROUP ) { shapeCreated = true ; } } public PShapeOpenGL ( PGraphicsOpenGL pg , int kind , float ... p ) { this ( pg , PRIMITIVE ) ; setKind ( kind ) ; setParams ( p ) ; } @ Override public void addChild ( PShape who ) { if ( who instanceof PShapeOpenGL ) { if ( family == GROUP ) { PShapeOpenGL c3d = ( PShapeOpenGL ) who ; super . addChild ( c3d ) ; c3d . updateRoot ( root ) ; markForTessellation ( ) ; if ( c3d . family == GROUP ) { if ( c3d . textures != null ) { for ( PImage tex : c3d . textures ) { addTexture ( tex ) ; } } if ( c3d . strokedTexture ) { strokedTexture ( true ) ; } } else { if ( c3d . image != null ) { addTexture ( c3d . image ) ; if ( c3d . stroke ) { strokedTexture ( true ) ; } } } } else { PGraphics . showWarning ( "Cannot add child shape to non-group shape." ) ; } } else { PGraphics . showWarning ( "Shape must be OpenGL to be added to the group." ) ; } } @ Override public void addChild ( PShape who , int idx ) { if ( who instanceof PShapeOpenGL ) { if ( family == GROUP ) { PShapeOpenGL c3d = ( PShapeOpenGL ) who ; super . addChild ( c3d , idx ) ; c3d . updateRoot ( root ) ; markForTessellation ( ) ; if ( c3d . family == GROUP ) { if ( c3d . textures != null ) { for ( PImage tex : c3d . textures ) { addTexture ( tex ) ; } } if ( c3d . strokedTexture ) { strokedTexture ( true ) ; } } else { if ( c3d . image != null ) { addTexture ( c3d . image ) ; if ( c3d . stroke ) { strokedTexture ( true ) ; } } } } else { PGraphics . showWarning ( "Cannot add child shape to non-group shape." ) ; } } else { PGraphics . showWarning ( "Shape must be OpenGL to be added to the group." ) ; } } @ Override public void removeChild ( int idx ) { super . removeChild ( idx ) ; markForTessellation ( ) ; } protected void updateRoot ( PShape root ) { this . root = ( PShapeOpenGL ) root ; if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . updateRoot ( root ) ; } } } @ Override protected void finalize ( ) throws Throwable { try { finalizePolyBuffers ( ) ; finalizeLineBuffers ( ) ; finalizePointBuffers ( ) ; } finally { super . finalize ( ) ; } } protected void finalizePolyBuffers ( ) { if ( glPolyVertex != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyVertex , context ) ; } if ( glPolyColor != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyColor , context ) ; } if ( glPolyNormal != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyNormal , context ) ; } if ( glPolyTexcoord != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyTexcoord , context ) ; } if ( glPolyAmbient != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyAmbient , context ) ; } if ( glPolySpecular != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolySpecular , context ) ; } if ( glPolyEmissive != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyEmissive , context ) ; } if ( glPolyShininess != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyShininess , context ) ; } for ( VertexAttribute attrib : polyAttribs . values ( ) ) { if ( attrib . glName != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( attrib . glName , context ) ; } } if ( glPolyIndex != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyIndex , context ) ; } } protected void finalizeLineBuffers ( ) { if ( glLineVertex != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glLineVertex , context ) ; } if ( glLineColor != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glLineColor , context ) ; } if ( glLineAttrib != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glLineAttrib , context ) ; } if ( glLineIndex != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glLineIndex , context ) ; } } protected void finalizePointBuffers ( ) { if ( glPointVertex != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPointVertex , context ) ; } if ( glPointColor != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPointColor , context ) ; } if ( glPointAttrib != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPointAttrib , context ) ; } if ( glPointIndex != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPointIndex , context ) ; } } public static PShapeOpenGL createShape ( PGraphicsOpenGL pg , PShape src ) { PShapeOpenGL dest = null ; if ( src . getFamily ( ) == GROUP ) { dest = ( PShapeOpenGL ) pg . createShapeFamily ( GROUP ) ; copyGroup ( pg , src , dest ) ; } else if ( src . getFamily ( ) == PRIMITIVE ) { dest = ( PShapeOpenGL ) pg . createShapePrimitive ( src . getKind ( ) , src . getParams ( ) ) ; PShape . copyPrimitive ( src , dest ) ; } else if ( src . getFamily ( ) == GEOMETRY ) { dest = ( PShapeOpenGL ) pg . createShapeFamily ( PShape . GEOMETRY ) ; PShape . copyGeometry ( src , dest ) ; } else if ( src . getFamily ( ) == PATH ) { dest = ( PShapeOpenGL ) pg . createShapeFamily ( PShape . PATH ) ; PShape . copyPath ( src , dest ) ; } dest . setName ( src . getName ( ) ) ; dest . width = src . width ; dest . height = src . height ; dest . depth = src . depth ; return dest ; } static public void copyGroup ( PGraphicsOpenGL pg , PShape src , PShape dest ) { copyMatrix ( src , dest ) ; copyStyles ( src , dest ) ; copyImage ( src , dest ) ; for ( int i = 0 ; i < src . getChildCount ( ) ; i ++ ) { PShape c = createShape ( pg , src . getChild ( i ) ) ; dest . addChild ( c ) ; } } @ Override public float getWidth ( ) { PVector min = new PVector ( Float . POSITIVE_INFINITY , Float . POSITIVE_INFINITY , Float . POSITIVE_INFINITY ) ; PVector max = new PVector ( Float . NEGATIVE_INFINITY , Float . NEGATIVE_INFINITY , Float . NEGATIVE_INFINITY ) ; if ( shapeCreated ) { getVertexMin ( min ) ; getVertexMax ( max ) ; } width = max . x - min . x ; return width ; } @ Override public float getHeight ( ) { PVector min = new PVector ( Float . POSITIVE_INFINITY , Float . POSITIVE_INFINITY , Float . POSITIVE_INFINITY ) ; PVector max = new PVector ( Float . NEGATIVE_INFINITY , Float . NEGATIVE_INFINITY , Float . NEGATIVE_INFINITY ) ; if ( shapeCreated ) { getVertexMin ( min ) ; getVertexMax ( max ) ; } height = max . y - min . y ; return height ; } @ Override public float getDepth ( ) { PVector min = new PVector ( Float . POSITIVE_INFINITY , Float . POSITIVE_INFINITY , Float . POSITIVE_INFINITY ) ; PVector max = new PVector ( Float . NEGATIVE_INFINITY , Float . NEGATIVE_INFINITY , Float . NEGATIVE_INFINITY ) ; if ( shapeCreated ) { getVertexMin ( min ) ; getVertexMax ( max ) ; } depth = max . z - min . z ; return depth ; } protected void getVertexMin ( PVector min ) { updateTessellation ( ) ; if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . getVertexMin ( min ) ; } } else { if ( hasPolys ) { tessGeo . getPolyVertexMin ( min , firstPolyVertex , lastPolyVertex ) ; } if ( is3D ( ) ) { if ( hasLines ) { tessGeo . getLineVertexMin ( min , firstLineVertex , lastLineVertex ) ; } if ( hasPoints ) { tessGeo . getPointVertexMin ( min , firstPointVertex , lastPointVertex ) ; } } } } protected void getVertexMax ( PVector max ) { updateTessellation ( ) ; if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . getVertexMax ( max ) ; } } else { if ( hasPolys ) { tessGeo . getPolyVertexMax ( max , firstPolyVertex , lastPolyVertex ) ; } if ( is3D ( ) ) { if ( hasLines ) { tessGeo . getLineVertexMax ( max , firstLineVertex , lastLineVertex ) ; } if ( hasPoints ) { tessGeo . getPointVertexMax ( max , firstPointVertex , lastPointVertex ) ; } } } } protected int getVertexSum ( PVector sum , int count ) { updateTessellation ( ) ; if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; count += child . getVertexSum ( sum , count ) ; } } else { if ( hasPolys ) { count += tessGeo . getPolyVertexSum ( sum , firstPolyVertex , lastPolyVertex ) ; } if ( is3D ( ) ) { if ( hasLines ) { count += tessGeo . getLineVertexSum ( sum , firstLineVertex , lastLineVertex ) ; } if ( hasPoints ) { count += tessGeo . getPointVertexSum ( sum , firstPointVertex , lastPointVertex ) ; } } } return count ; } @ Override public void setTextureMode ( int mode ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setTextureMode()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setTextureMode ( mode ) ; } } else { setTextureModeImpl ( mode ) ; } } protected void setTextureModeImpl ( int mode ) { if ( textureMode == mode ) return ; textureMode = mode ; if ( image != null ) { float uFactor = image . width ; float vFactor = image . height ; if ( textureMode == NORMAL ) { uFactor = 1.0f / uFactor ; vFactor = 1.0f / vFactor ; } scaleTextureUV ( uFactor , vFactor ) ; } } @ Override public void setTexture ( PImage tex ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setTexture()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setTexture ( tex ) ; } } else { setTextureImpl ( tex ) ; } } protected void setTextureImpl ( PImage tex ) { PImage image0 = image ; image = tex ; if ( textureMode == IMAGE && image0 != image ) { float uFactor = 1 ; float vFactor = 1 ; if ( image != null ) { uFactor /= image . width ; vFactor /= image . height ; } if ( image0 != null ) { uFactor *= image0 . width ; vFactor *= image0 . height ; } scaleTextureUV ( uFactor , vFactor ) ; } if ( image0 != tex && parent != null ) { ( ( PShapeOpenGL ) parent ) . removeTexture ( tex ) ; } if ( parent != null ) { ( ( PShapeOpenGL ) parent ) . addTexture ( image ) ; if ( is2D ( ) && stroke ) { ( ( PShapeOpenGL ) parent ) . strokedTexture ( true ) ; } } } protected void scaleTextureUV ( float uFactor , float vFactor ) { if ( PGraphicsOpenGL . same ( uFactor , 1 ) && PGraphicsOpenGL . same ( vFactor , 1 ) ) return ; for ( int i = 0 ; i < inGeo . vertexCount ; i ++ ) { float u = inGeo . texcoords [ 2 * i + 0 ] ; float v = inGeo . texcoords [ 2 * i + 1 ] ; inGeo . texcoords [ 2 * i + 0 ] = PApplet . min ( 1 , u * uFactor ) ; inGeo . texcoords [ 2 * i + 1 ] = PApplet . min ( 1 , v * uFactor ) ; } if ( shapeCreated && tessellated && hasPolys ) { int last1 = 0 ; if ( is3D ( ) ) { last1 = lastPolyVertex + 1 ; } else if ( is2D ( ) ) { last1 = lastPolyVertex + 1 ; if ( - 1 < firstLineVertex ) last1 = firstLineVertex ; if ( - 1 < firstPointVertex ) last1 = firstPointVertex ; } for ( int i = firstLineVertex ; i < last1 ; i ++ ) { float u = tessGeo . polyTexCoords [ 2 * i + 0 ] ; float v = tessGeo . polyTexCoords [ 2 * i + 1 ] ; tessGeo . polyTexCoords [ 2 * i + 0 ] = PApplet . min ( 1 , u * uFactor ) ; tessGeo . polyTexCoords [ 2 * i + 1 ] = PApplet . min ( 1 , v * uFactor ) ; } root . setModifiedPolyTexCoords ( firstPolyVertex , last1 - 1 ) ; } } protected void addTexture ( PImage tex ) { if ( textures == null ) { textures = new HashSet < PImage > ( ) ; } textures . add ( tex ) ; if ( parent != null ) { ( ( PShapeOpenGL ) parent ) . addTexture ( tex ) ; } } protected void removeTexture ( PImage tex ) { if ( textures == null || ! textures . contains ( tex ) ) return ; boolean childHasTex = false ; for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; if ( child . hasTexture ( tex ) ) { childHasTex = true ; break ; } } if ( ! childHasTex ) { textures . remove ( tex ) ; if ( textures . size ( ) == 0 ) { textures = null ; } } if ( parent != null ) { ( ( PShapeOpenGL ) parent ) . removeTexture ( tex ) ; } } protected void strokedTexture ( boolean newValue ) { if ( strokedTexture == newValue ) return ; if ( newValue ) { strokedTexture = true ; } else { boolean childHasStrokedTex = false ; for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; if ( child . hasStrokedTexture ( ) ) { childHasStrokedTex = true ; break ; } } if ( ! childHasStrokedTex ) { strokedTexture = false ; } } if ( parent != null ) { ( ( PShapeOpenGL ) parent ) . strokedTexture ( newValue ) ; } } protected boolean hasTexture ( PImage tex ) { if ( family == GROUP ) { return textures != null && textures . contains ( tex ) ; } else { return image == tex ; } } protected boolean hasStrokedTexture ( ) { if ( family == GROUP ) { return strokedTexture ; } else { return image != null && stroke ; } } @ Override public void solid ( boolean solid ) { if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . solid ( solid ) ; } } else { this . solid = solid ; } } @ Override protected void beginContourImpl ( ) { breakShape = true ; } @ Override protected void endContourImpl ( ) { } @ Override public void vertex ( float x , float y ) { vertexImpl ( x , y , 0 , 0 , 0 ) ; if ( image != null ) PGraphics . showWarning ( PGraphicsOpenGL . MISSING_UV_TEXCOORDS_ERROR ) ; } @ Override public void vertex ( float x , float y , float u , float v ) { vertexImpl ( x , y , 0 , u , v ) ; } @ Override public void vertex ( float x , float y , float z ) { vertexImpl ( x , y , z , 0 , 0 ) ; if ( image != null ) PGraphics . showWarning ( PGraphicsOpenGL . MISSING_UV_TEXCOORDS_ERROR ) ; } @ Override public void vertex ( float x , float y , float z , float u , float v ) { vertexImpl ( x , y , z , u , v ) ; } protected void vertexImpl ( float x , float y , float z , float u , float v ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "vertex()" ) ; return ; } if ( family == GROUP ) { PGraphics . showWarning ( "Cannot add vertices to GROUP shape" ) ; return ; } boolean textured = image != null ; int fcolor = 0x00 ; if ( fill || textured ) { if ( ! textured ) { fcolor = fillColor ; } else { if ( tint ) { fcolor = tintColor ; } else { fcolor = 0xffFFFFFF ; } } } if ( textureMode == IMAGE && image != null ) { u /= image . width ; v /= image . height ; } int scolor = 0x00 ; float sweight = 0 ; if ( stroke ) { scolor = strokeColor ; sweight = strokeWeight ; } inGeo . addVertex ( x , y , z , fcolor , normalX , normalY , normalZ , u , v , scolor , sweight , ambientColor , specularColor , emissiveColor , shininess , VERTEX , vertexBreak ( ) ) ; markForTessellation ( ) ; } protected boolean vertexBreak ( ) { if ( breakShape ) { breakShape = false ; return true ; } return false ; } @ Override public void normal ( float nx , float ny , float nz ) { if ( ! openShape ) { PGraphics . showWarning ( OUTSIDE_BEGIN_END_ERROR , "normal()" ) ; return ; } if ( family == GROUP ) { PGraphics . showWarning ( "Cannot set normal in GROUP shape" ) ; return ; } normalX = nx ; normalY = ny ; normalZ = nz ; if ( normalMode == NORMAL_MODE_AUTO ) { normalMode = NORMAL_MODE_SHAPE ; } else if ( normalMode == NORMAL_MODE_SHAPE ) { normalMode = NORMAL_MODE_VERTEX ; } } @ Override public void attrib ( String name , float ... values ) { VertexAttribute attrib = attribImpl ( name , PGL . FLOAT , values . length ) ; if ( attrib != null ) attrib . set ( values ) ; } @ Override public void attrib ( String name , int ... values ) { VertexAttribute attrib = attribImpl ( name , PGL . INT , values . length ) ; if ( attrib != null ) attrib . set ( values ) ; } @ Override public void attrib ( String name , boolean ... values ) { VertexAttribute attrib = attribImpl ( name , PGL . BOOL , values . length ) ; if ( attrib != null ) attrib . set ( values ) ; } protected VertexAttribute attribImpl ( String name , int type , int size ) { if ( 4 < size ) { PGraphics . showWarning ( "Vertex attributes cannot have more than 4 values" ) ; return null ; } VertexAttribute attrib = polyAttribs . get ( name ) ; if ( attrib == null ) { attrib = new VertexAttribute ( name , type , size ) ; polyAttribs . put ( name , attrib ) ; inGeo . initAttrib ( attrib ) ; } if ( attrib . size != size ) { PGraphics . showWarning ( "New value for vertex attribute has wrong number of values" ) ; return null ; } return attrib ; } @ Override public void endShape ( int mode ) { super . endShape ( mode ) ; inGeo . trim ( ) ; close = mode == CLOSE ; markForTessellation ( ) ; shapeCreated = true ; } @ Override public void setParams ( float [ ] source ) { if ( family != PRIMITIVE ) { PGraphics . showWarning ( "Parameters can only be set to PRIMITIVE shapes" ) ; return ; } super . setParams ( source ) ; markForTessellation ( ) ; shapeCreated = true ; } @ Override public void setPath ( int vcount , float [ ] [ ] verts , int ccount , int [ ] codes ) { if ( family != PATH ) { PGraphics . showWarning ( "Vertex coordinates and codes can only be set to " + "PATH shapes" ) ; return ; } super . setPath ( vcount , verts , ccount , codes ) ; markForTessellation ( ) ; shapeCreated = true ; } @ Override public void translate ( float tx , float ty ) { if ( is3D ) { transform ( TRANSLATE , tx , ty , 0 ) ; } else { transform ( TRANSLATE , tx , ty ) ; } } @ Override public void translate ( float tx , float ty , float tz ) { transform ( TRANSLATE , tx , ty , tz ) ; } @ Override public void rotate ( float angle ) { transform ( ROTATE , angle ) ; } @ Override public void rotateX ( float angle ) { rotate ( angle , 1 , 0 , 0 ) ; } @ Override public void rotateY ( float angle ) { rotate ( angle , 0 , 1 , 0 ) ; } @ Override public void rotateZ ( float angle ) { transform ( ROTATE , angle ) ; } @ Override public void rotate ( float angle , float v0 , float v1 , float v2 ) { transform ( ROTATE , angle , v0 , v1 , v2 ) ; } @ Override public void scale ( float s ) { if ( is3D ) { transform ( SCALE , s , s , s ) ; } else { transform ( SCALE , s , s ) ; } } @ Override public void scale ( float x , float y ) { if ( is3D ) { transform ( SCALE , x , y , 1 ) ; } else { transform ( SCALE , x , y ) ; } } @ Override public void scale ( float x , float y , float z ) { transform ( SCALE , x , y , z ) ; } @ Override public void applyMatrix ( PMatrix2D source ) { transform ( MATRIX , source . m00 , source . m01 , source . m02 , source . m10 , source . m11 , source . m12 ) ; } @ Override public void applyMatrix ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) { transform ( MATRIX , n00 , n01 , n02 , n10 , n11 , n12 ) ; } @ Override public void applyMatrix ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { transform ( MATRIX , n00 , n01 , n02 , n03 , n10 , n11 , n12 , n13 , n20 , n21 , n22 , n23 , n30 , n31 , n32 , n33 ) ; } @ Override public void resetMatrix ( ) { if ( shapeCreated && matrix != null && transformStack != null ) { if ( family == GROUP ) { updateTessellation ( ) ; } if ( tessellated ) { PMatrix mat = popTransform ( ) ; while ( mat != null ) { boolean res = mat . invert ( ) ; if ( res ) { applyMatrixImpl ( mat ) ; } else { PGraphics . showWarning ( "Transformation applied on the shape cannot be inverted" ) ; } mat = popTransform ( ) ; } } matrix . reset ( ) ; transformStack . clear ( ) ; } } protected void transform ( int type , float ... args ) { int dimensions = is3D ? 3 : 2 ; checkMatrix ( dimensions ) ; if ( transform == null ) { if ( dimensions == 2 ) { transform = new PMatrix2D ( ) ; } else { transform = new PMatrix3D ( ) ; } } else { transform . reset ( ) ; } int ncoords = args . length ; if ( type == ROTATE ) { ncoords = args . length == 1 ? 2 : 3 ; } else if ( type == MATRIX ) { ncoords = args . length == 6 ? 2 : 3 ; } switch ( type ) { case TRANSLATE : if ( ncoords == 3 ) { transform . translate ( args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; } else { transform . translate ( args [ 0 ] , args [ 1 ] ) ; } break ; case ROTATE : if ( ncoords == 3 ) { transform . rotate ( args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; } else { transform . rotate ( args [ 0 ] ) ; } break ; case SCALE : if ( ncoords == 3 ) { transform . scale ( args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; } else { transform . scale ( args [ 0 ] , args [ 1 ] ) ; } break ; case MATRIX : if ( ncoords == 3 ) { transform . set ( args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] , args [ 4 ] , args [ 5 ] , args [ 6 ] , args [ 7 ] , args [ 8 ] , args [ 9 ] , args [ 10 ] , args [ 11 ] , args [ 12 ] , args [ 13 ] , args [ 14 ] , args [ 15 ] ) ; } else { transform . set ( args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] , args [ 4 ] , args [ 5 ] ) ; } break ; } matrix . apply ( transform ) ; pushTransform ( ) ; if ( tessellated ) applyMatrixImpl ( transform ) ; } protected void pushTransform ( ) { if ( transformStack == null ) transformStack = new Stack < PMatrix > ( ) ; PMatrix mat ; if ( transform instanceof PMatrix2D ) { mat = new PMatrix2D ( ) ; } else { mat = new PMatrix3D ( ) ; } mat . set ( transform ) ; transformStack . push ( mat ) ; } protected PMatrix popTransform ( ) { if ( transformStack == null || transformStack . size ( ) == 0 ) return null ; return transformStack . pop ( ) ; } protected void applyMatrixImpl ( PMatrix matrix ) { if ( hasPolys ) { tessGeo . applyMatrixOnPolyGeometry ( matrix , firstPolyVertex , lastPolyVertex ) ; root . setModifiedPolyVertices ( firstPolyVertex , lastPolyVertex ) ; root . setModifiedPolyNormals ( firstPolyVertex , lastPolyVertex ) ; for ( VertexAttribute attrib : polyAttribs . values ( ) ) { if ( attrib . isPosition ( ) || attrib . isNormal ( ) ) { root . setModifiedPolyAttrib ( attrib , firstPolyVertex , lastPolyVertex ) ; } } } if ( is3D ( ) ) { if ( hasLines ) { tessGeo . applyMatrixOnLineGeometry ( matrix , firstLineVertex , lastLineVertex ) ; root . setModifiedLineVertices ( firstLineVertex , lastLineVertex ) ; root . setModifiedLineAttributes ( firstLineVertex , lastLineVertex ) ; } if ( hasPoints ) { tessGeo . applyMatrixOnPointGeometry ( matrix , firstPointVertex , lastPointVertex ) ; root . setModifiedPointVertices ( firstPointVertex , lastPointVertex ) ; } } } @ Override public void bezierDetail ( int detail ) { bezierDetail = detail ; if ( 0 < inGeo . codeCount ) { markForTessellation ( ) ; } } @ Override public void bezierVertex ( float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { bezierVertexImpl ( x2 , y2 , 0 , x3 , y3 , 0 , x4 , y4 , 0 ) ; } @ Override public void bezierVertex ( float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { bezierVertexImpl ( x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; } protected void bezierVertexImpl ( float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addBezierVertex ( x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 , vertexBreak ( ) ) ; } @ Override public void quadraticVertex ( float cx , float cy , float x3 , float y3 ) { quadraticVertexImpl ( cx , cy , 0 , x3 , y3 , 0 ) ; } @ Override public void quadraticVertex ( float cx , float cy , float cz , float x3 , float y3 , float z3 ) { quadraticVertexImpl ( cx , cy , cz , x3 , y3 , z3 ) ; } protected void quadraticVertexImpl ( float cx , float cy , float cz , float x3 , float y3 , float z3 ) { inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addQuadraticVertex ( cx , cy , cz , x3 , y3 , z3 , vertexBreak ( ) ) ; } @ Override public void curveDetail ( int detail ) { curveDetail = detail ; if ( 0 < inGeo . codeCount ) { markForTessellation ( ) ; } } @ Override public void curveTightness ( float tightness ) { curveTightness = tightness ; if ( 0 < inGeo . codeCount ) { markForTessellation ( ) ; } } @ Override public void curveVertex ( float x , float y ) { curveVertexImpl ( x , y , 0 ) ; } @ Override public void curveVertex ( float x , float y , float z ) { curveVertexImpl ( x , y , z ) ; } protected void curveVertexImpl ( float x , float y , float z ) { inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addCurveVertex ( x , y , z , vertexBreak ( ) ) ; } @ Override public int getVertexCount ( ) { if ( family == GROUP ) return 0 ; else { if ( family == PRIMITIVE || family == PATH ) { updateTessellation ( ) ; } return inGeo . vertexCount ; } } @ Override public PVector getVertex ( int index , PVector vec ) { if ( vec == null ) { vec = new PVector ( ) ; } vec . x = inGeo . vertices [ 3 * index + 0 ] ; vec . y = inGeo . vertices [ 3 * index + 1 ] ; vec . z = inGeo . vertices [ 3 * index + 2 ] ; return vec ; } @ Override public float getVertexX ( int index ) { return inGeo . vertices [ 3 * index + 0 ] ; } @ Override public float getVertexY ( int index ) { return inGeo . vertices [ 3 * index + 1 ] ; } @ Override public float getVertexZ ( int index ) { return inGeo . vertices [ 3 * index + 2 ] ; } @ Override public void setVertex ( int index , float x , float y ) { setVertex ( index , x , y , 0 ) ; } @ Override public void setVertex ( int index , float x , float y , float z ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setVertex()" ) ; return ; } inGeo . vertices [ 3 * index + 0 ] = x ; inGeo . vertices [ 3 * index + 1 ] = y ; inGeo . vertices [ 3 * index + 2 ] = z ; markForTessellation ( ) ; } @ Override public void setVertex ( int index , PVector vec ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setVertex()" ) ; return ; } inGeo . vertices [ 3 * index + 0 ] = vec . x ; inGeo . vertices [ 3 * index + 1 ] = vec . y ; inGeo . vertices [ 3 * index + 2 ] = vec . z ; markForTessellation ( ) ; } @ Override public PVector getNormal ( int index , PVector vec ) { if ( vec == null ) { vec = new PVector ( ) ; } vec . x = inGeo . normals [ 3 * index + 0 ] ; vec . y = inGeo . normals [ 3 * index + 1 ] ; vec . z = inGeo . normals [ 3 * index + 2 ] ; return vec ; } @ Override public float getNormalX ( int index ) { return inGeo . normals [ 3 * index + 0 ] ; } @ Override public float getNormalY ( int index ) { return inGeo . normals [ 3 * index + 1 ] ; } @ Override public float getNormalZ ( int index ) { return inGeo . normals [ 3 * index + 2 ] ; } @ Override public void setNormal ( int index , float nx , float ny , float nz ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setNormal()" ) ; return ; } inGeo . normals [ 3 * index + 0 ] = nx ; inGeo . normals [ 3 * index + 1 ] = ny ; inGeo . normals [ 3 * index + 2 ] = nz ; markForTessellation ( ) ; } @ Override public void setAttrib ( String name , int index , float ... values ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setNormal()" ) ; return ; } VertexAttribute attrib = polyAttribs . get ( name ) ; float [ ] array = inGeo . fattribs . get ( name ) ; for ( int i = 0 ; i < values . length ; i ++ ) { array [ attrib . size * index + 0 ] = values [ i ] ; } markForTessellation ( ) ; } @ Override public void setAttrib ( String name , int index , int ... values ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setNormal()" ) ; return ; } VertexAttribute attrib = polyAttribs . get ( name ) ; int [ ] array = inGeo . iattribs . get ( name ) ; for ( int i = 0 ; i < values . length ; i ++ ) { array [ attrib . size * index + 0 ] = values [ i ] ; } markForTessellation ( ) ; } @ Override public void setAttrib ( String name , int index , boolean ... values ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setNormal()" ) ; return ; } VertexAttribute attrib = polyAttribs . get ( name ) ; byte [ ] array = inGeo . battribs . get ( name ) ; for ( int i = 0 ; i < values . length ; i ++ ) { array [ attrib . size * index + 0 ] = ( byte ) ( values [ i ] ? 1 : 0 ) ; } markForTessellation ( ) ; } @ Override public float getTextureU ( int index ) { return inGeo . texcoords [ 2 * index + 0 ] ; } @ Override public float getTextureV ( int index ) { return inGeo . texcoords [ 2 * index + 1 ] ; } @ Override public void setTextureUV ( int index , float u , float v ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setTextureUV()" ) ; return ; } if ( textureMode == IMAGE && image != null ) { u /= image . width ; v /= image . height ; } inGeo . texcoords [ 2 * index + 0 ] = u ; inGeo . texcoords [ 2 * index + 1 ] = v ; markForTessellation ( ) ; } @ Override public int getFill ( int index ) { if ( family != GROUP && image == null ) { return PGL . nativeToJavaARGB ( inGeo . colors [ index ] ) ; } else { return 0 ; } } @ Override public void setFill ( boolean fill ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setFill()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setFill ( fill ) ; } } else if ( this . fill && ! fill ) { setFillImpl ( 0x0 ) ; } this . fill = fill ; } @ Override public void setFill ( int fill ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setFill()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setFill ( fill ) ; } } else { setFillImpl ( fill ) ; } } protected void setFillImpl ( int fill ) { if ( fillColor == fill ) return ; fillColor = fill ; if ( image == null ) { Arrays . fill ( inGeo . colors , 0 , inGeo . vertexCount , PGL . javaToNativeARGB ( fillColor ) ) ; if ( shapeCreated && tessellated && hasPolys ) { if ( is3D ( ) ) { Arrays . fill ( tessGeo . polyColors , firstPolyVertex , lastPolyVertex + 1 , PGL . javaToNativeARGB ( fillColor ) ) ; root . setModifiedPolyColors ( firstPolyVertex , lastPolyVertex ) ; } else if ( is2D ( ) ) { int last1 = lastPolyVertex + 1 ; if ( - 1 < firstLineVertex ) last1 = firstLineVertex ; if ( - 1 < firstPointVertex ) last1 = firstPointVertex ; Arrays . fill ( tessGeo . polyColors , firstPolyVertex , last1 , PGL . javaToNativeARGB ( fillColor ) ) ; root . setModifiedPolyColors ( firstPolyVertex , last1 - 1 ) ; } } } if ( ! setAmbient ) { setAmbientImpl ( fill ) ; setAmbient = false ; } } @ Override public void setFill ( int index , int fill ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setFill()" ) ; return ; } if ( image == null ) { inGeo . colors [ index ] = PGL . javaToNativeARGB ( fill ) ; markForTessellation ( ) ; } } @ Override public int getTint ( int index ) { if ( family != GROUP && image != null ) { return PGL . nativeToJavaARGB ( inGeo . colors [ index ] ) ; } else { return 0 ; } } @ Override public void setTint ( boolean tint ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setTint()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setTint ( fill ) ; } } else if ( this . tint && ! tint ) { setTintImpl ( 0xFFFFFFFF ) ; } this . tint = tint ; } @ Override public void setTint ( int tint ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setTint()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setTint ( tint ) ; } } else { setTintImpl ( tint ) ; } } protected void setTintImpl ( int tint ) { if ( tintColor == tint ) return ; tintColor = tint ; if ( image != null ) { Arrays . fill ( inGeo . colors , 0 , inGeo . vertexCount , PGL . javaToNativeARGB ( tintColor ) ) ; if ( shapeCreated && tessellated && hasPolys ) { if ( is3D ( ) ) { Arrays . fill ( tessGeo . polyColors , firstPolyVertex , lastPolyVertex + 1 , PGL . javaToNativeARGB ( tintColor ) ) ; root . setModifiedPolyColors ( firstPolyVertex , lastPolyVertex ) ; } else if ( is2D ( ) ) { int last1 = lastPolyVertex + 1 ; if ( - 1 < firstLineVertex ) last1 = firstLineVertex ; if ( - 1 < firstPointVertex ) last1 = firstPointVertex ; Arrays . fill ( tessGeo . polyColors , firstPolyVertex , last1 , PGL . javaToNativeARGB ( tintColor ) ) ; root . setModifiedPolyColors ( firstPolyVertex , last1 - 1 ) ; } } } } @ Override public void setTint ( int index , int tint ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setTint()" ) ; return ; } if ( image != null ) { inGeo . colors [ index ] = PGL . javaToNativeARGB ( tint ) ; markForTessellation ( ) ; } } @ Override public int getStroke ( int index ) { if ( family != GROUP ) { return PGL . nativeToJavaARGB ( inGeo . strokeColors [ index ] ) ; } else { return 0 ; } } @ Override public void setStroke ( boolean stroke ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStroke()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setStroke ( stroke ) ; } } else if ( this . stroke != stroke ) { if ( this . stroke ) { markForTessellation ( ) ; stroke = false ; } setStrokeImpl ( 0x0 ) ; if ( is2D ( ) && parent != null ) { ( ( PShapeOpenGL ) parent ) . strokedTexture ( false ) ; } } this . stroke = stroke ; } @ Override public void setStroke ( int stroke ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStroke()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setStroke ( stroke ) ; } } else { setStrokeImpl ( stroke ) ; } } protected void setStrokeImpl ( int stroke ) { if ( strokeColor == stroke ) return ; strokeColor = stroke ; Arrays . fill ( inGeo . strokeColors , 0 , inGeo . vertexCount , PGL . javaToNativeARGB ( strokeColor ) ) ; if ( shapeCreated && tessellated && ( hasLines || hasPoints ) ) { if ( hasLines ) { if ( is3D ( ) ) { Arrays . fill ( tessGeo . lineColors , firstLineVertex , lastLineVertex + 1 , PGL . javaToNativeARGB ( strokeColor ) ) ; root . setModifiedLineColors ( firstLineVertex , lastLineVertex ) ; } else if ( is2D ( ) ) { Arrays . fill ( tessGeo . polyColors , firstLineVertex , lastLineVertex + 1 , PGL . javaToNativeARGB ( strokeColor ) ) ; root . setModifiedPolyColors ( firstLineVertex , lastLineVertex ) ; } } if ( hasPoints ) { if ( is3D ( ) ) { Arrays . fill ( tessGeo . pointColors , firstPointVertex , lastPointVertex + 1 , PGL . javaToNativeARGB ( strokeColor ) ) ; root . setModifiedPointColors ( firstPointVertex , lastPointVertex ) ; } else if ( is2D ( ) ) { Arrays . fill ( tessGeo . polyColors , firstPointVertex , lastPointVertex + 1 , PGL . javaToNativeARGB ( strokeColor ) ) ; root . setModifiedPolyColors ( firstPointVertex , lastPointVertex ) ; } } } } @ Override public void setStroke ( int index , int stroke ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStroke()" ) ; return ; } inGeo . strokeColors [ index ] = PGL . javaToNativeARGB ( stroke ) ; markForTessellation ( ) ; } @ Override public float getStrokeWeight ( int index ) { if ( family != GROUP ) { return inGeo . strokeWeights [ index ] ; } else { return 0 ; } } @ Override public void setStrokeWeight ( float weight ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStrokeWeight()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setStrokeWeight ( weight ) ; } } else { setStrokeWeightImpl ( weight ) ; } } protected void setStrokeWeightImpl ( float weight ) { if ( PGraphicsOpenGL . same ( strokeWeight , weight ) ) return ; float oldWeight = strokeWeight ; strokeWeight = weight ; Arrays . fill ( inGeo . strokeWeights , 0 , inGeo . vertexCount , strokeWeight ) ; if ( shapeCreated && tessellated && ( hasLines || hasPoints ) ) { float resizeFactor = weight / oldWeight ; if ( hasLines ) { if ( is3D ( ) ) { for ( int i = firstLineVertex ; i <= lastLineVertex ; i ++ ) { tessGeo . lineDirections [ 4 * i + 3 ] *= resizeFactor ; } root . setModifiedLineAttributes ( firstLineVertex , lastLineVertex ) ; } else if ( is2D ( ) ) { markForTessellation ( ) ; } } if ( hasPoints ) { if ( is3D ( ) ) { for ( int i = firstPointVertex ; i <= lastPointVertex ; i ++ ) { tessGeo . pointOffsets [ 2 * i + 0 ] *= resizeFactor ; tessGeo . pointOffsets [ 2 * i + 1 ] *= resizeFactor ; } root . setModifiedPointAttributes ( firstPointVertex , lastPointVertex ) ; } else if ( is2D ( ) ) { markForTessellation ( ) ; } } } } @ Override public void setStrokeWeight ( int index , float weight ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStrokeWeight()" ) ; return ; } inGeo . strokeWeights [ index ] = weight ; markForTessellation ( ) ; } @ Override public void setStrokeJoin ( int join ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStrokeJoin()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setStrokeJoin ( join ) ; } } else { if ( is2D ( ) && strokeJoin != join ) { markForTessellation ( ) ; } strokeJoin = join ; } } @ Override public void setStrokeCap ( int cap ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setStrokeCap()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setStrokeCap ( cap ) ; } } else { if ( is2D ( ) && strokeCap != cap ) { markForTessellation ( ) ; } strokeCap = cap ; } } @ Override public int getAmbient ( int index ) { if ( family != GROUP ) { return PGL . nativeToJavaARGB ( inGeo . ambient [ index ] ) ; } else { return 0 ; } } @ Override public void setAmbient ( int ambient ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setAmbient()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setAmbient ( ambient ) ; } } else { setAmbientImpl ( ambient ) ; } } protected void setAmbientImpl ( int ambient ) { if ( ambientColor == ambient ) return ; ambientColor = ambient ; Arrays . fill ( inGeo . ambient , 0 , inGeo . vertexCount , PGL . javaToNativeARGB ( ambientColor ) ) ; if ( shapeCreated && tessellated && hasPolys ) { if ( is3D ( ) ) { Arrays . fill ( tessGeo . polyAmbient , firstPolyVertex , lastPolyVertex + 1 , PGL . javaToNativeARGB ( ambientColor ) ) ; root . setModifiedPolyAmbient ( firstPolyVertex , lastPolyVertex ) ; } else if ( is2D ( ) ) { int last1 = lastPolyVertex + 1 ; if ( - 1 < firstLineVertex ) last1 = firstLineVertex ; if ( - 1 < firstPointVertex ) last1 = firstPointVertex ; Arrays . fill ( tessGeo . polyAmbient , firstPolyVertex , last1 , PGL . javaToNativeARGB ( ambientColor ) ) ; root . setModifiedPolyColors ( firstPolyVertex , last1 - 1 ) ; } } setAmbient = true ; } @ Override public void setAmbient ( int index , int ambient ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setAmbient()" ) ; return ; } inGeo . ambient [ index ] = PGL . javaToNativeARGB ( ambient ) ; markForTessellation ( ) ; setAmbient = true ; } @ Override public int getSpecular ( int index ) { if ( family == GROUP ) { return PGL . nativeToJavaARGB ( inGeo . specular [ index ] ) ; } else { return 0 ; } } @ Override public void setSpecular ( int specular ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setSpecular()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setSpecular ( specular ) ; } } else { setSpecularImpl ( specular ) ; } } protected void setSpecularImpl ( int specular ) { if ( specularColor == specular ) return ; specularColor = specular ; Arrays . fill ( inGeo . specular , 0 , inGeo . vertexCount , PGL . javaToNativeARGB ( specularColor ) ) ; if ( shapeCreated && tessellated && hasPolys ) { if ( is3D ( ) ) { Arrays . fill ( tessGeo . polySpecular , firstPolyVertex , lastPolyVertex + 1 , PGL . javaToNativeARGB ( specularColor ) ) ; root . setModifiedPolySpecular ( firstPolyVertex , lastPolyVertex ) ; } else if ( is2D ( ) ) { int last1 = lastPolyVertex + 1 ; if ( - 1 < firstLineVertex ) last1 = firstLineVertex ; if ( - 1 < firstPointVertex ) last1 = firstPointVertex ; Arrays . fill ( tessGeo . polySpecular , firstPolyVertex , last1 , PGL . javaToNativeARGB ( specularColor ) ) ; root . setModifiedPolyColors ( firstPolyVertex , last1 - 1 ) ; } } } @ Override public void setSpecular ( int index , int specular ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setSpecular()" ) ; return ; } inGeo . specular [ index ] = PGL . javaToNativeARGB ( specular ) ; markForTessellation ( ) ; } @ Override public int getEmissive ( int index ) { if ( family == GROUP ) { return PGL . nativeToJavaARGB ( inGeo . emissive [ index ] ) ; } else { return 0 ; } } @ Override public void setEmissive ( int emissive ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setEmissive()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setEmissive ( emissive ) ; } } else { setEmissiveImpl ( emissive ) ; } } protected void setEmissiveImpl ( int emissive ) { if ( emissiveColor == emissive ) return ; emissiveColor = emissive ; Arrays . fill ( inGeo . emissive , 0 , inGeo . vertexCount , PGL . javaToNativeARGB ( emissiveColor ) ) ; if ( shapeCreated && tessellated && 0 < tessGeo . polyVertexCount ) { if ( is3D ( ) ) { Arrays . fill ( tessGeo . polyEmissive , firstPolyVertex , lastPolyVertex + 1 , PGL . javaToNativeARGB ( emissiveColor ) ) ; root . setModifiedPolyEmissive ( firstPolyVertex , lastPolyVertex ) ; } else if ( is2D ( ) ) { int last1 = lastPolyVertex + 1 ; if ( - 1 < firstLineVertex ) last1 = firstLineVertex ; if ( - 1 < firstPointVertex ) last1 = firstPointVertex ; Arrays . fill ( tessGeo . polyEmissive , firstPolyVertex , last1 , PGL . javaToNativeARGB ( emissiveColor ) ) ; root . setModifiedPolyColors ( firstPolyVertex , last1 - 1 ) ; } } } @ Override public void setEmissive ( int index , int emissive ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setEmissive()" ) ; return ; } inGeo . emissive [ index ] = PGL . javaToNativeARGB ( emissive ) ; markForTessellation ( ) ; } @ Override public float getShininess ( int index ) { if ( family == GROUP ) { return inGeo . shininess [ index ] ; } else { return 0 ; } } @ Override public void setShininess ( float shininess ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setShininess()" ) ; return ; } if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . setShininess ( shininess ) ; } } else { setShininessImpl ( shininess ) ; } } protected void setShininessImpl ( float shininess ) { if ( PGraphicsOpenGL . same ( this . shininess , shininess ) ) return ; this . shininess = shininess ; Arrays . fill ( inGeo . shininess , 0 , inGeo . vertexCount , shininess ) ; if ( shapeCreated && tessellated && hasPolys ) { if ( is3D ( ) ) { Arrays . fill ( tessGeo . polyShininess , firstPolyVertex , lastPolyVertex + 1 , shininess ) ; root . setModifiedPolyShininess ( firstPolyVertex , lastPolyVertex ) ; } else if ( is2D ( ) ) { int last1 = lastPolyVertex + 1 ; if ( - 1 < firstLineVertex ) last1 = firstLineVertex ; if ( - 1 < firstPointVertex ) last1 = firstPointVertex ; Arrays . fill ( tessGeo . polyShininess , firstPolyVertex , last1 , shininess ) ; root . setModifiedPolyColors ( firstPolyVertex , last1 - 1 ) ; } } } @ Override public void setShininess ( int index , float shine ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "setShininess()" ) ; return ; } inGeo . shininess [ index ] = shine ; markForTessellation ( ) ; } @ Override public int [ ] getVertexCodes ( ) { if ( family == GROUP ) return null ; else { if ( family == PRIMITIVE || family == PATH ) { updateTessellation ( ) ; } if ( inGeo . codes == null ) return null ; return inGeo . codes ; } } @ Override public int getVertexCodeCount ( ) { if ( family == GROUP ) return 0 ; else { if ( family == PRIMITIVE || family == PATH ) { updateTessellation ( ) ; } return inGeo . codeCount ; } } @ Override public int getVertexCode ( int index ) { return inGeo . codes [ index ] ; } @ Override public PShape getTessellation ( ) { updateTessellation ( ) ; float [ ] vertices = tessGeo . polyVertices ; float [ ] normals = tessGeo . polyNormals ; int [ ] color = tessGeo . polyColors ; float [ ] uv = tessGeo . polyTexCoords ; short [ ] indices = tessGeo . polyIndices ; PShape tess ; tess = pg . createShapeFamily ( PShape . GEOMETRY ) ; tess . set3D ( is3D ) ; tess . beginShape ( TRIANGLES ) ; tess . noStroke ( ) ; IndexCache cache = tessGeo . polyIndexCache ; for ( int n = firstPolyIndexCache ; n <= lastPolyIndexCache ; n ++ ) { int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int voffset = cache . vertexOffset [ n ] ; for ( int tr = ioffset / 3 ; tr < ( ioffset + icount ) / 3 ; tr ++ ) { int i0 = voffset + indices [ 3 * tr + 0 ] ; int i1 = voffset + indices [ 3 * tr + 1 ] ; int i2 = voffset + indices [ 3 * tr + 2 ] ; if ( is3D ( ) ) { float x0 = vertices [ 4 * i0 + 0 ] ; float y0 = vertices [ 4 * i0 + 1 ] ; float z0 = vertices [ 4 * i0 + 2 ] ; float x1 = vertices [ 4 * i1 + 0 ] ; float y1 = vertices [ 4 * i1 + 1 ] ; float z1 = vertices [ 4 * i1 + 2 ] ; float x2 = vertices [ 4 * i2 + 0 ] ; float y2 = vertices [ 4 * i2 + 1 ] ; float z2 = vertices [ 4 * i2 + 2 ] ; float nx0 = normals [ 3 * i0 + 0 ] ; float ny0 = normals [ 3 * i0 + 1 ] ; float nz0 = normals [ 3 * i0 + 2 ] ; float nx1 = normals [ 3 * i1 + 0 ] ; float ny1 = normals [ 3 * i1 + 1 ] ; float nz1 = normals [ 3 * i1 + 2 ] ; float nx2 = normals [ 3 * i2 + 0 ] ; float ny2 = normals [ 3 * i2 + 1 ] ; float nz2 = normals [ 3 * i2 + 2 ] ; int argb0 = PGL . nativeToJavaARGB ( color [ i0 ] ) ; int argb1 = PGL . nativeToJavaARGB ( color [ i1 ] ) ; int argb2 = PGL . nativeToJavaARGB ( color [ i2 ] ) ; tess . fill ( argb0 ) ; tess . normal ( nx0 , ny0 , nz0 ) ; tess . vertex ( x0 , y0 , z0 , uv [ 2 * i0 + 0 ] , uv [ 2 * i0 + 1 ] ) ; tess . fill ( argb1 ) ; tess . normal ( nx1 , ny1 , nz1 ) ; tess . vertex ( x1 , y1 , z1 , uv [ 2 * i1 + 0 ] , uv [ 2 * i1 + 1 ] ) ; tess . fill ( argb2 ) ; tess . normal ( nx2 , ny2 , nz2 ) ; tess . vertex ( x2 , y2 , z2 , uv [ 2 * i2 + 0 ] , uv [ 2 * i2 + 1 ] ) ; } else if ( is2D ( ) ) { float x0 = vertices [ 4 * i0 + 0 ] , y0 = vertices [ 4 * i0 + 1 ] ; float x1 = vertices [ 4 * i1 + 0 ] , y1 = vertices [ 4 * i1 + 1 ] ; float x2 = vertices [ 4 * i2 + 0 ] , y2 = vertices [ 4 * i2 + 1 ] ; int argb0 = PGL . nativeToJavaARGB ( color [ i0 ] ) ; int argb1 = PGL . nativeToJavaARGB ( color [ i1 ] ) ; int argb2 = PGL . nativeToJavaARGB ( color [ i2 ] ) ; tess . fill ( argb0 ) ; tess . vertex ( x0 , y0 , uv [ 2 * i0 + 0 ] , uv [ 2 * i0 + 1 ] ) ; tess . fill ( argb1 ) ; tess . vertex ( x1 , y1 , uv [ 2 * i1 + 0 ] , uv [ 2 * i1 + 1 ] ) ; tess . fill ( argb2 ) ; tess . vertex ( x2 , y2 , uv [ 2 * i2 + 0 ] , uv [ 2 * i2 + 1 ] ) ; } } } tess . endShape ( ) ; return tess ; } public float [ ] getTessellation ( int kind , int data ) { updateTessellation ( ) ; if ( kind == TRIANGLES ) { if ( data == POSITION ) { if ( is3D ( ) ) { root . setModifiedPolyVertices ( firstPolyVertex , lastPolyVertex ) ; } else if ( is2D ( ) ) { int last1 = lastPolyVertex + 1 ; if ( - 1 < firstLineVertex ) last1 = firstLineVertex ; if ( - 1 < firstPointVertex ) last1 = firstPointVertex ; root . setModifiedPolyVertices ( firstPolyVertex , last1 - 1 ) ; } return tessGeo . polyVertices ; } else if ( data == NORMAL ) { if ( is3D ( ) ) { root . setModifiedPolyNormals ( firstPolyVertex , lastPolyVertex ) ; } else if ( is2D ( ) ) { int last1 = lastPolyVertex + 1 ; if ( - 1 < firstLineVertex ) last1 = firstLineVertex ; if ( - 1 < firstPointVertex ) last1 = firstPointVertex ; root . setModifiedPolyNormals ( firstPolyVertex , last1 - 1 ) ; } return tessGeo . polyNormals ; } else if ( data == TEXCOORD ) { if ( is3D ( ) ) { root . setModifiedPolyTexCoords ( firstPolyVertex , lastPolyVertex ) ; } else if ( is2D ( ) ) { int last1 = lastPolyVertex + 1 ; if ( - 1 < firstLineVertex ) last1 = firstLineVertex ; if ( - 1 < firstPointVertex ) last1 = firstPointVertex ; root . setModifiedPolyTexCoords ( firstPolyVertex , last1 - 1 ) ; } return tessGeo . polyTexCoords ; } } else if ( kind == LINES ) { if ( data == POSITION ) { if ( is3D ( ) ) { root . setModifiedLineVertices ( firstLineVertex , lastLineVertex ) ; } else if ( is2D ( ) ) { root . setModifiedPolyVertices ( firstLineVertex , lastLineVertex ) ; } return tessGeo . lineVertices ; } else if ( data == DIRECTION ) { if ( is2D ( ) ) { root . setModifiedLineAttributes ( firstLineVertex , lastLineVertex ) ; } return tessGeo . lineDirections ; } } else if ( kind == POINTS ) { if ( data == POSITION ) { if ( is3D ( ) ) { root . setModifiedPointVertices ( firstPointVertex , lastPointVertex ) ; } else if ( is2D ( ) ) { root . setModifiedPolyVertices ( firstPointVertex , lastPointVertex ) ; } return tessGeo . pointVertices ; } else if ( data == OFFSET ) { if ( is2D ( ) ) { root . setModifiedPointAttributes ( firstPointVertex , lastPointVertex ) ; } return tessGeo . pointOffsets ; } } return null ; } @ Override public boolean contains ( float x , float y ) { if ( family == PATH ) { boolean c = false ; for ( int i = 0 , j = inGeo . vertexCount - 1 ; i < inGeo . vertexCount ; j = i ++ ) { if ( ( ( inGeo . vertices [ 3 * i + 1 ] > y ) != ( inGeo . vertices [ 3 * j + 1 ] > y ) ) && ( x < ( inGeo . vertices [ 3 * j ] - inGeo . vertices [ 3 * i ] ) * ( y - inGeo . vertices [ 3 * i + 1 ] ) / ( inGeo . vertices [ 3 * j + 1 ] - inGeo . vertices [ 3 * i + 1 ] ) + inGeo . vertices [ 3 * i ] ) ) { c = ! c ; } } return c ; } else { throw new IllegalArgumentException ( "The contains() method is only implemented for paths." ) ; } } protected void updateTessellation ( ) { if ( ! root . tessellated ) { root . tessellate ( ) ; root . aggregate ( ) ; root . initModified ( ) ; root . needBufferInit = true ; } } protected void markForTessellation ( ) { root . tessellated = false ; tessellated = false ; } protected void initModified ( ) { modified = false ; modifiedPolyVertices = false ; modifiedPolyColors = false ; modifiedPolyNormals = false ; modifiedPolyTexCoords = false ; modifiedPolyAmbient = false ; modifiedPolySpecular = false ; modifiedPolyEmissive = false ; modifiedPolyShininess = false ; modifiedLineVertices = false ; modifiedLineColors = false ; modifiedLineAttributes = false ; modifiedPointVertices = false ; modifiedPointColors = false ; modifiedPointAttributes = false ; firstModifiedPolyVertex = PConstants . MAX_INT ; lastModifiedPolyVertex = PConstants . MIN_INT ; firstModifiedPolyColor = PConstants . MAX_INT ; lastModifiedPolyColor = PConstants . MIN_INT ; firstModifiedPolyNormal = PConstants . MAX_INT ; lastModifiedPolyNormal = PConstants . MIN_INT ; firstModifiedPolyTexcoord = PConstants . MAX_INT ; lastModifiedPolyTexcoord = PConstants . MIN_INT ; firstModifiedPolyAmbient = PConstants . MAX_INT ; lastModifiedPolyAmbient = PConstants . MIN_INT ; firstModifiedPolySpecular = PConstants . MAX_INT ; lastModifiedPolySpecular = PConstants . MIN_INT ; firstModifiedPolyEmissive = PConstants . MAX_INT ; lastModifiedPolyEmissive = PConstants . MIN_INT ; firstModifiedPolyShininess = PConstants . MAX_INT ; lastModifiedPolyShininess = PConstants . MIN_INT ; firstModifiedLineVertex = PConstants . MAX_INT ; lastModifiedLineVertex = PConstants . MIN_INT ; firstModifiedLineColor = PConstants . MAX_INT ; lastModifiedLineColor = PConstants . MIN_INT ; firstModifiedLineAttribute = PConstants . MAX_INT ; lastModifiedLineAttribute = PConstants . MIN_INT ; firstModifiedPointVertex = PConstants . MAX_INT ; lastModifiedPointVertex = PConstants . MIN_INT ; firstModifiedPointColor = PConstants . MAX_INT ; lastModifiedPointColor = PConstants . MIN_INT ; firstModifiedPointAttribute = PConstants . MAX_INT ; lastModifiedPointAttribute = PConstants . MIN_INT ; } protected void tessellate ( ) { if ( root == this && parent == null ) { if ( polyAttribs == null ) { polyAttribs = PGraphicsOpenGL . newAttributeMap ( ) ; collectPolyAttribs ( ) ; } if ( tessGeo == null ) { tessGeo = PGraphicsOpenGL . newTessGeometry ( pg , polyAttribs , PGraphicsOpenGL . RETAINED ) ; } tessGeo . clear ( ) ; for ( int i = 0 ; i < polyAttribs . size ( ) ; i ++ ) { VertexAttribute attrib = polyAttribs . get ( i ) ; tessGeo . initAttrib ( attrib ) ; } tessellateImpl ( ) ; tessGeo . trim ( ) ; } } protected void collectPolyAttribs ( ) { AttributeMap rootAttribs = root . polyAttribs ; if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . collectPolyAttribs ( ) ; } } else { for ( int i = 0 ; i < polyAttribs . size ( ) ; i ++ ) { VertexAttribute attrib = polyAttribs . get ( i ) ; tessGeo . initAttrib ( attrib ) ; if ( rootAttribs . containsKey ( attrib . name ) ) { VertexAttribute rattrib = rootAttribs . get ( attrib . name ) ; if ( rattrib . diff ( attrib ) ) { throw new RuntimeException ( "Children shapes cannot have different attributes with same name" ) ; } } else { rootAttribs . put ( attrib . name , attrib ) ; } } } } protected void tessellateImpl ( ) { tessGeo = root . tessGeo ; firstPolyIndexCache = - 1 ; lastPolyIndexCache = - 1 ; firstLineIndexCache = - 1 ; lastLineIndexCache = - 1 ; firstPointIndexCache = - 1 ; lastPointIndexCache = - 1 ; if ( family == GROUP ) { for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . tessellateImpl ( ) ; } } else { if ( shapeCreated ) { inGeo . clearEdges ( ) ; tessellator . setInGeometry ( inGeo ) ; tessellator . setTessGeometry ( tessGeo ) ; tessellator . setFill ( fill || image != null ) ; tessellator . setTexCache ( null , null ) ; tessellator . setStroke ( stroke ) ; tessellator . setStrokeColor ( strokeColor ) ; tessellator . setStrokeWeight ( strokeWeight ) ; tessellator . setStrokeCap ( strokeCap ) ; tessellator . setStrokeJoin ( strokeJoin ) ; tessellator . setRenderer ( pg ) ; tessellator . setTransform ( matrix ) ; tessellator . set3D ( is3D ( ) ) ; if ( family == GEOMETRY ) { if ( kind == POINTS ) { tessellator . tessellatePoints ( ) ; } else if ( kind == LINES ) { tessellator . tessellateLines ( ) ; } else if ( kind == LINE_STRIP ) { tessellator . tessellateLineStrip ( ) ; } else if ( kind == LINE_LOOP ) { tessellator . tessellateLineLoop ( ) ; } else if ( kind == TRIANGLE || kind == TRIANGLES ) { if ( stroke ) inGeo . addTrianglesEdges ( ) ; if ( normalMode == NORMAL_MODE_AUTO ) inGeo . calcTrianglesNormals ( ) ; tessellator . tessellateTriangles ( ) ; } else if ( kind == TRIANGLE_FAN ) { if ( stroke ) inGeo . addTriangleFanEdges ( ) ; if ( normalMode == NORMAL_MODE_AUTO ) inGeo . calcTriangleFanNormals ( ) ; tessellator . tessellateTriangleFan ( ) ; } else if ( kind == TRIANGLE_STRIP ) { if ( stroke ) inGeo . addTriangleStripEdges ( ) ; if ( normalMode == NORMAL_MODE_AUTO ) inGeo . calcTriangleStripNormals ( ) ; tessellator . tessellateTriangleStrip ( ) ; } else if ( kind == QUAD || kind == QUADS ) { if ( stroke ) inGeo . addQuadsEdges ( ) ; if ( normalMode == NORMAL_MODE_AUTO ) inGeo . calcQuadsNormals ( ) ; tessellator . tessellateQuads ( ) ; } else if ( kind == QUAD_STRIP ) { if ( stroke ) inGeo . addQuadStripEdges ( ) ; if ( normalMode == NORMAL_MODE_AUTO ) inGeo . calcQuadStripNormals ( ) ; tessellator . tessellateQuadStrip ( ) ; } else if ( kind == POLYGON ) { boolean bez = inGeo . hasBezierVertex ( ) ; boolean quad = inGeo . hasQuadraticVertex ( ) ; boolean curv = inGeo . hasCurveVertex ( ) ; if ( bez || quad ) saveBezierVertexSettings ( ) ; if ( curv ) { saveCurveVertexSettings ( ) ; tessellator . resetCurveVertexCount ( ) ; } tessellator . tessellatePolygon ( solid , close , normalMode == NORMAL_MODE_AUTO ) ; if ( bez || quad ) restoreBezierVertexSettings ( ) ; if ( curv ) restoreCurveVertexSettings ( ) ; } } else if ( family == PRIMITIVE ) { inGeo . clear ( ) ; if ( kind == POINT ) { tessellatePoint ( ) ; } else if ( kind == LINE ) { tessellateLine ( ) ; } else if ( kind == TRIANGLE ) { tessellateTriangle ( ) ; } else if ( kind == QUAD ) { tessellateQuad ( ) ; } else if ( kind == RECT ) { tessellateRect ( ) ; } else if ( kind == ELLIPSE ) { tessellateEllipse ( ) ; } else if ( kind == ARC ) { tessellateArc ( ) ; } else if ( kind == BOX ) { tessellateBox ( ) ; } else if ( kind == SPHERE ) { tessellateSphere ( ) ; } } else if ( family == PATH ) { inGeo . clear ( ) ; tessellatePath ( ) ; } if ( image != null && parent != null ) { ( ( PShapeOpenGL ) parent ) . addTexture ( image ) ; } firstPolyIndexCache = tessellator . firstPolyIndexCache ; lastPolyIndexCache = tessellator . lastPolyIndexCache ; firstLineIndexCache = tessellator . firstLineIndexCache ; lastLineIndexCache = tessellator . lastLineIndexCache ; firstPointIndexCache = tessellator . firstPointIndexCache ; lastPointIndexCache = tessellator . lastPointIndexCache ; } } firstPolyVertex = lastPolyVertex = - 1 ; firstLineVertex = lastLineVertex = - 1 ; firstPointVertex = lastPointVertex = - 1 ; tessellated = true ; } protected void tessellatePoint ( ) { float x = 0 , y = 0 , z = 0 ; if ( params . length == 2 ) { x = params [ 0 ] ; y = params [ 1 ] ; z = 0 ; } else if ( params . length == 3 ) { x = params [ 0 ] ; y = params [ 1 ] ; z = params [ 2 ] ; } inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addPoint ( x , y , z , fill , stroke ) ; tessellator . tessellatePoints ( ) ; } protected void tessellateLine ( ) { float x1 = 0 , y1 = 0 , z1 = 0 ; float x2 = 0 , y2 = 0 , z2 = 0 ; if ( params . length == 4 ) { x1 = params [ 0 ] ; y1 = params [ 1 ] ; x2 = params [ 2 ] ; y2 = params [ 3 ] ; } else if ( params . length == 6 ) { x1 = params [ 0 ] ; y1 = params [ 1 ] ; z1 = params [ 2 ] ; x2 = params [ 3 ] ; y2 = params [ 4 ] ; z2 = params [ 5 ] ; } inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addLine ( x1 , y1 , z1 , x2 , y2 , z2 , fill , stroke ) ; tessellator . tessellateLines ( ) ; } protected void tessellateTriangle ( ) { float x1 = 0 , y1 = 0 ; float x2 = 0 , y2 = 0 ; float x3 = 0 , y3 = 0 ; if ( params . length == 6 ) { x1 = params [ 0 ] ; y1 = params [ 1 ] ; x2 = params [ 2 ] ; y2 = params [ 3 ] ; x3 = params [ 4 ] ; y3 = params [ 5 ] ; } inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addTriangle ( x1 , y1 , 0 , x2 , y2 , 0 , x3 , y3 , 0 , fill , stroke ) ; tessellator . tessellateTriangles ( ) ; } protected void tessellateQuad ( ) { float x1 = 0 , y1 = 0 ; float x2 = 0 , y2 = 0 ; float x3 = 0 , y3 = 0 ; float x4 = 0 , y4 = 0 ; if ( params . length == 8 ) { x1 = params [ 0 ] ; y1 = params [ 1 ] ; x2 = params [ 2 ] ; y2 = params [ 3 ] ; x3 = params [ 4 ] ; y3 = params [ 5 ] ; x4 = params [ 6 ] ; y4 = params [ 7 ] ; } inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addQuad ( x1 , y1 , 0 , x2 , y2 , 0 , x3 , y3 , 0 , x4 , y4 , 0 , stroke ) ; tessellator . tessellateQuads ( ) ; } protected void tessellateRect ( ) { float a = 0 , b = 0 , c = 0 , d = 0 ; float tl = 0 , tr = 0 , br = 0 , bl = 0 ; boolean rounded = false ; int mode = rectMode ; if ( params . length == 4 || params . length == 5 ) { a = params [ 0 ] ; b = params [ 1 ] ; c = params [ 2 ] ; d = params [ 3 ] ; if ( params . length == 5 ) { mode = ( int ) ( params [ 4 ] ) ; } rounded = false ; } else if ( params . length == 8 || params . length == 9 ) { a = params [ 0 ] ; b = params [ 1 ] ; c = params [ 2 ] ; d = params [ 3 ] ; tl = params [ 4 ] ; tr = params [ 5 ] ; br = params [ 6 ] ; bl = params [ 7 ] ; if ( params . length == 9 ) { mode = ( int ) ( params [ 8 ] ) ; } rounded = true ; } float hradius , vradius ; switch ( mode ) { case CORNERS : break ; case CORNER : c += a ; d += b ; break ; case RADIUS : hradius = c ; vradius = d ; c = a + hradius ; d = b + vradius ; a -= hradius ; b -= vradius ; break ; case CENTER : hradius = c / 2.0f ; vradius = d / 2.0f ; c = a + hradius ; d = b + vradius ; a -= hradius ; b -= vradius ; } if ( a > c ) { float temp = a ; a = c ; c = temp ; } if ( b > d ) { float temp = b ; b = d ; d = temp ; } float maxRounding = PApplet . min ( ( c - a ) / 2 , ( d - b ) / 2 ) ; if ( tl > maxRounding ) tl = maxRounding ; if ( tr > maxRounding ) tr = maxRounding ; if ( br > maxRounding ) br = maxRounding ; if ( bl > maxRounding ) bl = maxRounding ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; if ( rounded ) { saveBezierVertexSettings ( ) ; inGeo . addRect ( a , b , c , d , tl , tr , br , bl , stroke ) ; tessellator . tessellatePolygon ( true , true , true ) ; restoreBezierVertexSettings ( ) ; } else { inGeo . addRect ( a , b , c , d , stroke ) ; tessellator . tessellateQuads ( ) ; } } protected void tessellateEllipse ( ) { float a = 0 , b = 0 , c = 0 , d = 0 ; int mode = ellipseMode ; if ( 4 <= params . length ) { a = params [ 0 ] ; b = params [ 1 ] ; c = params [ 2 ] ; d = params [ 3 ] ; if ( params . length == 5 ) { mode = ( int ) ( params [ 4 ] ) ; } } float x = a ; float y = b ; float w = c ; float h = d ; if ( mode == CORNERS ) { w = c - a ; h = d - b ; } else if ( mode == RADIUS ) { x = a - c ; y = b - d ; w = c * 2 ; h = d * 2 ; } else if ( mode == DIAMETER ) { x = a - c / 2f ; y = b - d / 2f ; } if ( w < 0 ) { x += w ; w = - w ; } if ( h < 0 ) { y += h ; h = - h ; } inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addEllipse ( x , y , w , h , fill , stroke ) ; tessellator . tessellateTriangleFan ( ) ; } protected void tessellateArc ( ) { float a = 0 , b = 0 , c = 0 , d = 0 ; float start = 0 , stop = 0 ; int mode = ellipseMode ; if ( 6 <= params . length ) { a = params [ 0 ] ; b = params [ 1 ] ; c = params [ 2 ] ; d = params [ 3 ] ; start = params [ 4 ] ; stop = params [ 5 ] ; if ( params . length == 7 ) { mode = ( int ) ( params [ 6 ] ) ; } } float x = a ; float y = b ; float w = c ; float h = d ; if ( mode == CORNERS ) { w = c - a ; h = d - b ; } else if ( mode == RADIUS ) { x = a - c ; y = b - d ; w = c * 2 ; h = d * 2 ; } else if ( mode == CENTER ) { x = a - c / 2f ; y = b - d / 2f ; } if ( ! Float . isInfinite ( start ) && ! Float . isInfinite ( stop ) ) { if ( stop > start ) { while ( start < 0 ) { start += TWO_PI ; stop += TWO_PI ; } if ( stop - start > TWO_PI ) { start = 0 ; stop = TWO_PI ; } inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addArc ( x , y , w , h , start , stop , fill , stroke , mode ) ; tessellator . tessellateTriangleFan ( ) ; } } } protected void tessellateBox ( ) { float w = 0 , h = 0 , d = 0 ; if ( params . length == 1 ) { w = h = d = params [ 0 ] ; } else if ( params . length == 3 ) { w = params [ 0 ] ; h = params [ 1 ] ; d = params [ 2 ] ; } inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . addBox ( w , h , d , fill , stroke ) ; tessellator . tessellateQuads ( ) ; } protected void tessellateSphere ( ) { float r = 0 ; int nu = sphereDetailU ; int nv = sphereDetailV ; if ( 1 <= params . length ) { r = params [ 0 ] ; if ( params . length == 2 ) { nu = nv = ( int ) params [ 1 ] ; } else if ( params . length == 3 ) { nu = ( int ) params [ 1 ] ; nv = ( int ) params [ 2 ] ; } } if ( nu < 3 || nv < 2 ) { nu = nv = 30 ; } int savedDetailU = pg . sphereDetailU ; int savedDetailV = pg . sphereDetailV ; if ( pg . sphereDetailU != nu || pg . sphereDetailV != nv ) { pg . sphereDetail ( nu , nv ) ; } inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; int [ ] indices = inGeo . addSphere ( r , nu , nv , fill , stroke ) ; tessellator . tessellateTriangles ( indices ) ; if ( savedDetailU != nu || savedDetailV != nv ) { pg . sphereDetail ( savedDetailU , savedDetailV ) ; } } protected void tessellatePath ( ) { if ( vertices == null ) return ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; if ( vertexCodeCount == 0 ) { if ( vertices [ 0 ] . length == 2 ) { for ( int i = 0 ; i < vertexCount ; i ++ ) { inGeo . addVertex ( vertices [ i ] [ X ] , vertices [ i ] [ Y ] , VERTEX , false ) ; } } else { for ( int i = 0 ; i < vertexCount ; i ++ ) { inGeo . addVertex ( vertices [ i ] [ X ] , vertices [ i ] [ Y ] , vertices [ i ] [ Z ] , VERTEX , false ) ; } } } else { int idx = 0 ; boolean brk = true ; if ( vertices [ 0 ] . length == 2 ) { for ( int j = 0 ; j < vertexCodeCount ; j ++ ) { switch ( vertexCodes [ j ] ) { case VERTEX : inGeo . addVertex ( vertices [ idx ] [ X ] , vertices [ idx ] [ Y ] , VERTEX , brk ) ; brk = false ; idx ++ ; break ; case QUADRATIC_VERTEX : inGeo . addQuadraticVertex ( vertices [ idx + 0 ] [ X ] , vertices [ idx + 0 ] [ Y ] , 0 , vertices [ idx + 1 ] [ X ] , vertices [ idx + 1 ] [ Y ] , 0 , brk ) ; brk = false ; idx += 2 ; break ; case BEZIER_VERTEX : inGeo . addBezierVertex ( vertices [ idx + 0 ] [ X ] , vertices [ idx + 0 ] [ Y ] , 0 , vertices [ idx + 1 ] [ X ] , vertices [ idx + 1 ] [ Y ] , 0 , vertices [ idx + 2 ] [ X ] , vertices [ idx + 2 ] [ Y ] , 0 , brk ) ; brk = false ; idx += 3 ; break ; case CURVE_VERTEX : inGeo . addCurveVertex ( vertices [ idx ] [ X ] , vertices [ idx ] [ Y ] , 0 , brk ) ; brk = false ; idx ++ ; break ; case BREAK : brk = true ; } } } else { for ( int j = 0 ; j < vertexCodeCount ; j ++ ) { switch ( vertexCodes [ j ] ) { case VERTEX : inGeo . addVertex ( vertices [ idx ] [ X ] , vertices [ idx ] [ Y ] , vertices [ idx ] [ Z ] , brk ) ; brk = false ; idx ++ ; break ; case QUADRATIC_VERTEX : inGeo . addQuadraticVertex ( vertices [ idx + 0 ] [ X ] , vertices [ idx + 0 ] [ Y ] , vertices [ idx + 0 ] [ Z ] , vertices [ idx + 1 ] [ X ] , vertices [ idx + 1 ] [ Y ] , vertices [ idx + 0 ] [ Z ] , brk ) ; brk = false ; idx += 2 ; break ; case BEZIER_VERTEX : inGeo . addBezierVertex ( vertices [ idx + 0 ] [ X ] , vertices [ idx + 0 ] [ Y ] , vertices [ idx + 0 ] [ Z ] , vertices [ idx + 1 ] [ X ] , vertices [ idx + 1 ] [ Y ] , vertices [ idx + 1 ] [ Z ] , vertices [ idx + 2 ] [ X ] , vertices [ idx + 2 ] [ Y ] , vertices [ idx + 2 ] [ Z ] , brk ) ; brk = false ; idx += 3 ; break ; case CURVE_VERTEX : inGeo . addCurveVertex ( vertices [ idx ] [ X ] , vertices [ idx ] [ Y ] , vertices [ idx ] [ Z ] , brk ) ; brk = false ; idx ++ ; break ; case BREAK : brk = true ; } } } } boolean bez = inGeo . hasBezierVertex ( ) ; boolean quad = inGeo . hasQuadraticVertex ( ) ; boolean curv = inGeo . hasCurveVertex ( ) ; if ( bez || quad ) saveBezierVertexSettings ( ) ; if ( curv ) { saveCurveVertexSettings ( ) ; tessellator . resetCurveVertexCount ( ) ; } tessellator . tessellatePolygon ( true , close , true ) ; if ( bez || quad ) restoreBezierVertexSettings ( ) ; if ( curv ) restoreCurveVertexSettings ( ) ; } protected void saveBezierVertexSettings ( ) { savedBezierDetail = pg . bezierDetail ; if ( pg . bezierDetail != bezierDetail ) { pg . bezierDetail ( bezierDetail ) ; } } protected void restoreBezierVertexSettings ( ) { if ( savedBezierDetail != bezierDetail ) { pg . bezierDetail ( savedBezierDetail ) ; } } protected void saveCurveVertexSettings ( ) { savedCurveDetail = pg . curveDetail ; savedCurveTightness = pg . curveTightness ; if ( pg . curveDetail != curveDetail ) { pg . curveDetail ( curveDetail ) ; } if ( pg . curveTightness != curveTightness ) { pg . curveTightness ( curveTightness ) ; } } protected void restoreCurveVertexSettings ( ) { if ( savedCurveDetail != curveDetail ) { pg . curveDetail ( savedCurveDetail ) ; } if ( savedCurveTightness != curveTightness ) { pg . curveTightness ( savedCurveTightness ) ; } } protected void aggregate ( ) { if ( root == this && parent == null ) { polyIndexOffset = 0 ; polyVertexOffset = 0 ; polyVertexAbs = 0 ; polyVertexRel = 0 ; lineIndexOffset = 0 ; lineVertexOffset = 0 ; lineVertexAbs = 0 ; lineVertexRel = 0 ; pointIndexOffset = 0 ; pointVertexOffset = 0 ; pointVertexAbs = 0 ; pointVertexRel = 0 ; aggregateImpl ( ) ; } } protected void aggregateImpl ( ) { if ( family == GROUP ) { hasPolys = false ; hasLines = false ; hasPoints = false ; for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; child . aggregateImpl ( ) ; hasPolys |= child . hasPolys ; hasLines |= child . hasLines ; hasPoints |= child . hasPoints ; } } else { hasPolys = - 1 < firstPolyIndexCache && - 1 < lastPolyIndexCache ; hasLines = - 1 < firstLineIndexCache && - 1 < lastLineIndexCache ; hasPoints = - 1 < firstPointIndexCache && - 1 < lastPointIndexCache ; } if ( hasPolys ) { updatePolyIndexCache ( ) ; } if ( is3D ( ) ) { if ( hasLines ) updateLineIndexCache ( ) ; if ( hasPoints ) updatePointIndexCache ( ) ; } if ( matrix != null ) { if ( hasPolys ) { tessGeo . applyMatrixOnPolyGeometry ( matrix , firstPolyVertex , lastPolyVertex ) ; } if ( is3D ( ) ) { if ( hasLines ) { tessGeo . applyMatrixOnLineGeometry ( matrix , firstLineVertex , lastLineVertex ) ; } if ( hasPoints ) { tessGeo . applyMatrixOnPointGeometry ( matrix , firstPointVertex , lastPointVertex ) ; } } } } protected void updatePolyIndexCache ( ) { IndexCache cache = tessGeo . polyIndexCache ; if ( family == GROUP ) { firstPolyIndexCache = lastPolyIndexCache = - 1 ; int gindex = - 1 ; for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; int first = child . firstPolyIndexCache ; int count = - 1 < first ? child . lastPolyIndexCache - first + 1 : - 1 ; for ( int n = first ; n < first + count ; n ++ ) { if ( gindex == - 1 ) { gindex = cache . addNew ( n ) ; firstPolyIndexCache = gindex ; } else { if ( cache . vertexOffset [ gindex ] == cache . vertexOffset [ n ] ) { cache . incCounts ( gindex , cache . indexCount [ n ] , cache . vertexCount [ n ] ) ; } else { gindex = cache . addNew ( n ) ; } } } if ( - 1 < child . firstPolyVertex ) { if ( firstPolyVertex == - 1 ) { firstPolyVertex = Integer . MAX_VALUE ; } firstPolyVertex = PApplet . min ( firstPolyVertex , child . firstPolyVertex ) ; } if ( - 1 < child . lastPolyVertex ) { lastPolyVertex = PApplet . max ( lastPolyVertex , child . lastPolyVertex ) ; } } lastPolyIndexCache = gindex ; } else { firstPolyVertex = lastPolyVertex = cache . vertexOffset [ firstPolyIndexCache ] ; for ( int n = firstPolyIndexCache ; n <= lastPolyIndexCache ; n ++ ) { int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int vcount = cache . vertexCount [ n ] ; if ( PGL . MAX_VERTEX_INDEX1 <= root . polyVertexRel + vcount || ( is2D ( ) && startStrokedTex ( n ) ) ) { root . polyVertexRel = 0 ; root . polyVertexOffset = root . polyVertexAbs ; cache . indexOffset [ n ] = root . polyIndexOffset ; } else { tessGeo . incPolyIndices ( ioffset , ioffset + icount - 1 , root . polyVertexRel ) ; } cache . vertexOffset [ n ] = root . polyVertexOffset ; if ( is2D ( ) ) { setFirstStrokeVertex ( n , lastPolyVertex ) ; } root . polyIndexOffset += icount ; root . polyVertexAbs += vcount ; root . polyVertexRel += vcount ; lastPolyVertex += vcount ; } lastPolyVertex -- ; if ( is2D ( ) ) { setLastStrokeVertex ( lastPolyVertex ) ; } } } protected boolean startStrokedTex ( int n ) { return image != null && ( n == firstLineIndexCache || n == firstPointIndexCache ) ; } protected void setFirstStrokeVertex ( int n , int vert ) { if ( n == firstLineIndexCache && firstLineVertex == - 1 ) { firstLineVertex = lastLineVertex = vert ; } if ( n == firstPointIndexCache && firstPointVertex == - 1 ) { firstPointVertex = lastPointVertex = vert ; } } protected void setLastStrokeVertex ( int vert ) { if ( - 1 < lastLineVertex ) { lastLineVertex = vert ; } if ( - 1 < lastPointVertex ) { lastPointVertex += vert ; } } protected void updateLineIndexCache ( ) { IndexCache cache = tessGeo . lineIndexCache ; if ( family == GROUP ) { firstLineIndexCache = lastLineIndexCache = - 1 ; int gindex = - 1 ; for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; int first = child . firstLineIndexCache ; int count = - 1 < first ? child . lastLineIndexCache - first + 1 : - 1 ; for ( int n = first ; n < first + count ; n ++ ) { if ( gindex == - 1 ) { gindex = cache . addNew ( n ) ; firstLineIndexCache = gindex ; } else { if ( cache . vertexOffset [ gindex ] == cache . vertexOffset [ n ] ) { cache . incCounts ( gindex , cache . indexCount [ n ] , cache . vertexCount [ n ] ) ; } else { gindex = cache . addNew ( n ) ; } } } if ( - 1 < child . firstLineVertex ) { if ( firstLineVertex == - 1 ) firstLineVertex = Integer . MAX_VALUE ; firstLineVertex = PApplet . min ( firstLineVertex , child . firstLineVertex ) ; } if ( - 1 < child . lastLineVertex ) { lastLineVertex = PApplet . max ( lastLineVertex , child . lastLineVertex ) ; } } lastLineIndexCache = gindex ; } else { firstLineVertex = lastLineVertex = cache . vertexOffset [ firstLineIndexCache ] ; for ( int n = firstLineIndexCache ; n <= lastLineIndexCache ; n ++ ) { int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int vcount = cache . vertexCount [ n ] ; if ( PGL . MAX_VERTEX_INDEX1 <= root . lineVertexRel + vcount ) { root . lineVertexRel = 0 ; root . lineVertexOffset = root . lineVertexAbs ; cache . indexOffset [ n ] = root . lineIndexOffset ; } else { tessGeo . incLineIndices ( ioffset , ioffset + icount - 1 , root . lineVertexRel ) ; } cache . vertexOffset [ n ] = root . lineVertexOffset ; root . lineIndexOffset += icount ; root . lineVertexAbs += vcount ; root . lineVertexRel += vcount ; lastLineVertex += vcount ; } lastLineVertex -- ; } } protected void updatePointIndexCache ( ) { IndexCache cache = tessGeo . pointIndexCache ; if ( family == GROUP ) { firstPointIndexCache = lastPointIndexCache = - 1 ; int gindex = - 1 ; for ( int i = 0 ; i < childCount ; i ++ ) { PShapeOpenGL child = ( PShapeOpenGL ) children [ i ] ; int first = child . firstPointIndexCache ; int count = - 1 < first ? child . lastPointIndexCache - first + 1 : - 1 ; for ( int n = first ; n < first + count ; n ++ ) { if ( gindex == - 1 ) { gindex = cache . addNew ( n ) ; firstPointIndexCache = gindex ; } else { if ( cache . vertexOffset [ gindex ] == cache . vertexOffset [ n ] ) { cache . incCounts ( gindex , cache . indexCount [ n ] , cache . vertexCount [ n ] ) ; } else { gindex = cache . addNew ( n ) ; } } } if ( - 1 < child . firstPointVertex ) { if ( firstPointVertex == - 1 ) firstPointVertex = Integer . MAX_VALUE ; firstPointVertex = PApplet . min ( firstPointVertex , child . firstPointVertex ) ; } if ( - 1 < child . lastPointVertex ) { lastPointVertex = PApplet . max ( lastPointVertex , child . lastPointVertex ) ; } } lastPointIndexCache = gindex ; } else { firstPointVertex = lastPointVertex = cache . vertexOffset [ firstPointIndexCache ] ; for ( int n = firstPointIndexCache ; n <= lastPointIndexCache ; n ++ ) { int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int vcount = cache . vertexCount [ n ] ; if ( PGL . MAX_VERTEX_INDEX1 <= root . pointVertexRel + vcount ) { root . pointVertexRel = 0 ; root . pointVertexOffset = root . pointVertexAbs ; cache . indexOffset [ n ] = root . pointIndexOffset ; } else { tessGeo . incPointIndices ( ioffset , ioffset + icount - 1 , root . pointVertexRel ) ; } cache . vertexOffset [ n ] = root . pointVertexOffset ; root . pointIndexOffset += icount ; root . pointVertexAbs += vcount ; root . pointVertexRel += vcount ; lastPointVertex += vcount ; } lastPointVertex -- ; } } protected void initBuffers ( ) { boolean outdated = contextIsOutdated ( ) ; context = pgl . getCurrentContext ( ) ; if ( hasPolys && ( needBufferInit || outdated ) ) { initPolyBuffers ( ) ; } if ( hasLines && ( needBufferInit || outdated ) ) { initLineBuffers ( ) ; } if ( hasPoints && ( needBufferInit || outdated ) ) { initPointBuffers ( ) ; } needBufferInit = false ; } protected void initPolyBuffers ( ) { int size = tessGeo . polyVertexCount ; int sizef = size * PGL . SIZEOF_FLOAT ; int sizei = size * PGL . SIZEOF_INT ; tessGeo . updatePolyVerticesBuffer ( ) ; if ( glPolyVertex == 0 ) glPolyVertex = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyVertex ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 4 * sizef , tessGeo . polyVerticesBuffer , glUsage ) ; tessGeo . updatePolyColorsBuffer ( ) ; if ( glPolyColor == 0 ) glPolyColor = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyColor ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , tessGeo . polyColorsBuffer , glUsage ) ; tessGeo . updatePolyNormalsBuffer ( ) ; if ( glPolyNormal == 0 ) glPolyNormal = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyNormal ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 3 * sizef , tessGeo . polyNormalsBuffer , glUsage ) ; tessGeo . updatePolyTexCoordsBuffer ( ) ; if ( glPolyTexcoord == 0 ) glPolyTexcoord = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyTexcoord ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 2 * sizef , tessGeo . polyTexCoordsBuffer , glUsage ) ; tessGeo . updatePolyAmbientBuffer ( ) ; if ( glPolyAmbient == 0 ) glPolyAmbient = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyAmbient ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , tessGeo . polyAmbientBuffer , glUsage ) ; tessGeo . updatePolySpecularBuffer ( ) ; if ( glPolySpecular == 0 ) glPolySpecular = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolySpecular ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , tessGeo . polySpecularBuffer , glUsage ) ; tessGeo . updatePolyEmissiveBuffer ( ) ; if ( glPolyEmissive == 0 ) glPolyEmissive = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyEmissive ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , tessGeo . polyEmissiveBuffer , glUsage ) ; tessGeo . updatePolyShininessBuffer ( ) ; if ( glPolyShininess == 0 ) glPolyShininess = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyShininess ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizef , tessGeo . polyShininessBuffer , glUsage ) ; for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; tessGeo . updateAttribBuffer ( attrib . name ) ; if ( ! attrib . bufferCreated ( ) ) attrib . createBuffer ( pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , attrib . glName ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , attrib . sizeInBytes ( size ) , tessGeo . polyAttribBuffers . get ( name ) , PGL . STATIC_DRAW ) ; } pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; tessGeo . updatePolyIndicesBuffer ( ) ; if ( glPolyIndex == 0 ) glPolyIndex = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , glPolyIndex ) ; pgl . bufferData ( PGL . ELEMENT_ARRAY_BUFFER , tessGeo . polyIndexCount * PGL . SIZEOF_INDEX , tessGeo . polyIndicesBuffer , glUsage ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , 0 ) ; } protected void initLineBuffers ( ) { int size = tessGeo . lineVertexCount ; int sizef = size * PGL . SIZEOF_FLOAT ; int sizei = size * PGL . SIZEOF_INT ; tessGeo . updateLineVerticesBuffer ( ) ; if ( glLineVertex == 0 ) glLineVertex = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glLineVertex ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 4 * sizef , tessGeo . lineVerticesBuffer , glUsage ) ; tessGeo . updateLineColorsBuffer ( ) ; if ( glLineColor == 0 ) glLineColor = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glLineColor ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , tessGeo . lineColorsBuffer , glUsage ) ; tessGeo . updateLineDirectionsBuffer ( ) ; if ( glLineAttrib == 0 ) glLineAttrib = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glLineAttrib ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 4 * sizef , tessGeo . lineDirectionsBuffer , glUsage ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; tessGeo . updateLineIndicesBuffer ( ) ; if ( glLineIndex == 0 ) glLineIndex = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , glLineIndex ) ; pgl . bufferData ( PGL . ELEMENT_ARRAY_BUFFER , tessGeo . lineIndexCount * PGL . SIZEOF_INDEX , tessGeo . lineIndicesBuffer , glUsage ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , 0 ) ; } protected void initPointBuffers ( ) { int size = tessGeo . pointVertexCount ; int sizef = size * PGL . SIZEOF_FLOAT ; int sizei = size * PGL . SIZEOF_INT ; tessGeo . updatePointVerticesBuffer ( ) ; if ( glPointVertex == 0 ) glPointVertex = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPointVertex ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 4 * sizef , tessGeo . pointVerticesBuffer , glUsage ) ; tessGeo . updatePointColorsBuffer ( ) ; if ( glPointColor == 0 ) glPointColor = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPointColor ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , tessGeo . pointColorsBuffer , glUsage ) ; tessGeo . updatePointOffsetsBuffer ( ) ; if ( glPointAttrib == 0 ) glPointAttrib = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPointAttrib ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 2 * sizef , tessGeo . pointOffsetsBuffer , glUsage ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; tessGeo . updatePointIndicesBuffer ( ) ; if ( glPointIndex == 0 ) glPointIndex = PGraphicsOpenGL . createVertexBufferObject ( context , pgl ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , glPointIndex ) ; pgl . bufferData ( PGL . ELEMENT_ARRAY_BUFFER , tessGeo . pointIndexCount * PGL . SIZEOF_INDEX , tessGeo . pointIndicesBuffer , glUsage ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , 0 ) ; } protected boolean contextIsOutdated ( ) { boolean outdated = ! pgl . contextIsCurrent ( context ) ; if ( outdated ) { PGraphicsOpenGL . removeVertexBufferObject ( glPolyVertex , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glPolyColor , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glPolyNormal , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glPolyTexcoord , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glPolyAmbient , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glPolySpecular , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glPolyEmissive , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glPolyShininess , context ) ; for ( VertexAttribute attrib : polyAttribs . values ( ) ) { PGraphicsOpenGL . removeVertexBufferObject ( attrib . glName , context ) ; } PGraphicsOpenGL . removeVertexBufferObject ( glPolyIndex , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glLineVertex , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glLineColor , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glLineAttrib , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glLineIndex , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glPointVertex , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glPointColor , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glPointAttrib , context ) ; PGraphicsOpenGL . removeVertexBufferObject ( glPointIndex , context ) ; glPolyVertex = 0 ; glPolyColor = 0 ; glPolyNormal = 0 ; glPolyTexcoord = 0 ; glPolyAmbient = 0 ; glPolySpecular = 0 ; glPolyEmissive = 0 ; glPolyShininess = 0 ; for ( VertexAttribute attrib : polyAttribs . values ( ) ) attrib . glName = 0 ; glPolyIndex = 0 ; glLineVertex = 0 ; glLineColor = 0 ; glLineAttrib = 0 ; glLineIndex = 0 ; glPointVertex = 0 ; glPointColor = 0 ; glPointAttrib = 0 ; glPointIndex = 0 ; } return outdated ; } protected void dispose ( ) { deletePolyBuffers ( ) ; deleteLineBuffers ( ) ; deletePointBuffers ( ) ; } protected void deletePolyBuffers ( ) { if ( glPolyVertex != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glPolyVertex , context , pgl ) ; glPolyVertex = 0 ; } if ( glPolyColor != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glPolyColor , context , pgl ) ; glPolyColor = 0 ; } if ( glPolyNormal != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glPolyNormal , context , pgl ) ; glPolyNormal = 0 ; } if ( glPolyTexcoord != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glPolyTexcoord , context , pgl ) ; glPolyTexcoord = 0 ; } if ( glPolyAmbient != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glPolyAmbient , context , pgl ) ; glPolyAmbient = 0 ; } if ( glPolySpecular != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glPolySpecular , context , pgl ) ; glPolySpecular = 0 ; } if ( glPolyEmissive != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glPolyEmissive , context , pgl ) ; glPolyEmissive = 0 ; } if ( glPolyShininess != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glPolyShininess , context , pgl ) ; glPolyShininess = 0 ; } for ( VertexAttribute attrib : polyAttribs . values ( ) ) { attrib . deleteBuffer ( pgl ) ; } if ( glPolyIndex != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glPolyIndex , context , pgl ) ; glPolyIndex = 0 ; } } protected void deleteLineBuffers ( ) { if ( glLineVertex != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glLineVertex , context , pgl ) ; glLineVertex = 0 ; } if ( glLineColor != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glLineColor , context , pgl ) ; glLineColor = 0 ; } if ( glLineAttrib != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glLineAttrib , context , pgl ) ; glLineAttrib = 0 ; } if ( glLineIndex != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glLineIndex , context , pgl ) ; glLineIndex = 0 ; } } protected void deletePointBuffers ( ) { if ( glPointVertex != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glPointVertex , context , pgl ) ; glPointVertex = 0 ; } if ( glPointColor != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glPointColor , context , pgl ) ; glPointColor = 0 ; } if ( glPointAttrib != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glPointAttrib , context , pgl ) ; glPointAttrib = 0 ; } if ( glPointIndex != 0 ) { PGraphicsOpenGL . deleteVertexBufferObject ( glPointIndex , context , pgl ) ; glPointIndex = 0 ; } } protected void updateGeometry ( ) { root . initBuffers ( ) ; if ( root . modified ) { root . updateGeometryImpl ( ) ; } } protected void updateGeometryImpl ( ) { if ( modifiedPolyVertices ) { int offset = firstModifiedPolyVertex ; int size = lastModifiedPolyVertex - offset + 1 ; copyPolyVertices ( offset , size ) ; modifiedPolyVertices = false ; firstModifiedPolyVertex = PConstants . MAX_INT ; lastModifiedPolyVertex = PConstants . MIN_INT ; } if ( modifiedPolyColors ) { int offset = firstModifiedPolyColor ; int size = lastModifiedPolyColor - offset + 1 ; copyPolyColors ( offset , size ) ; modifiedPolyColors = false ; firstModifiedPolyColor = PConstants . MAX_INT ; lastModifiedPolyColor = PConstants . MIN_INT ; } if ( modifiedPolyNormals ) { int offset = firstModifiedPolyNormal ; int size = lastModifiedPolyNormal - offset + 1 ; copyPolyNormals ( offset , size ) ; modifiedPolyNormals = false ; firstModifiedPolyNormal = PConstants . MAX_INT ; lastModifiedPolyNormal = PConstants . MIN_INT ; } if ( modifiedPolyTexCoords ) { int offset = firstModifiedPolyTexcoord ; int size = lastModifiedPolyTexcoord - offset + 1 ; copyPolyTexCoords ( offset , size ) ; modifiedPolyTexCoords = false ; firstModifiedPolyTexcoord = PConstants . MAX_INT ; lastModifiedPolyTexcoord = PConstants . MIN_INT ; } if ( modifiedPolyAmbient ) { int offset = firstModifiedPolyAmbient ; int size = lastModifiedPolyAmbient - offset + 1 ; copyPolyAmbient ( offset , size ) ; modifiedPolyAmbient = false ; firstModifiedPolyAmbient = PConstants . MAX_INT ; lastModifiedPolyAmbient = PConstants . MIN_INT ; } if ( modifiedPolySpecular ) { int offset = firstModifiedPolySpecular ; int size = lastModifiedPolySpecular - offset + 1 ; copyPolySpecular ( offset , size ) ; modifiedPolySpecular = false ; firstModifiedPolySpecular = PConstants . MAX_INT ; lastModifiedPolySpecular = PConstants . MIN_INT ; } if ( modifiedPolyEmissive ) { int offset = firstModifiedPolyEmissive ; int size = lastModifiedPolyEmissive - offset + 1 ; copyPolyEmissive ( offset , size ) ; modifiedPolyEmissive = false ; firstModifiedPolyEmissive = PConstants . MAX_INT ; lastModifiedPolyEmissive = PConstants . MIN_INT ; } if ( modifiedPolyShininess ) { int offset = firstModifiedPolyShininess ; int size = lastModifiedPolyShininess - offset + 1 ; copyPolyShininess ( offset , size ) ; modifiedPolyShininess = false ; firstModifiedPolyShininess = PConstants . MAX_INT ; lastModifiedPolyShininess = PConstants . MIN_INT ; } for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( attrib . modified ) { int offset = firstModifiedPolyVertex ; int size = lastModifiedPolyVertex - offset + 1 ; copyPolyAttrib ( attrib , offset , size ) ; attrib . modified = false ; attrib . firstModified = PConstants . MAX_INT ; attrib . lastModified = PConstants . MIN_INT ; } } if ( modifiedLineVertices ) { int offset = firstModifiedLineVertex ; int size = lastModifiedLineVertex - offset + 1 ; copyLineVertices ( offset , size ) ; modifiedLineVertices = false ; firstModifiedLineVertex = PConstants . MAX_INT ; lastModifiedLineVertex = PConstants . MIN_INT ; } if ( modifiedLineColors ) { int offset = firstModifiedLineColor ; int size = lastModifiedLineColor - offset + 1 ; copyLineColors ( offset , size ) ; modifiedLineColors = false ; firstModifiedLineColor = PConstants . MAX_INT ; lastModifiedLineColor = PConstants . MIN_INT ; } if ( modifiedLineAttributes ) { int offset = firstModifiedLineAttribute ; int size = lastModifiedLineAttribute - offset + 1 ; copyLineAttributes ( offset , size ) ; modifiedLineAttributes = false ; firstModifiedLineAttribute = PConstants . MAX_INT ; lastModifiedLineAttribute = PConstants . MIN_INT ; } if ( modifiedPointVertices ) { int offset = firstModifiedPointVertex ; int size = lastModifiedPointVertex - offset + 1 ; copyPointVertices ( offset , size ) ; modifiedPointVertices = false ; firstModifiedPointVertex = PConstants . MAX_INT ; lastModifiedPointVertex = PConstants . MIN_INT ; } if ( modifiedPointColors ) { int offset = firstModifiedPointColor ; int size = lastModifiedPointColor - offset + 1 ; copyPointColors ( offset , size ) ; modifiedPointColors = false ; firstModifiedPointColor = PConstants . MAX_INT ; lastModifiedPointColor = PConstants . MIN_INT ; } if ( modifiedPointAttributes ) { int offset = firstModifiedPointAttribute ; int size = lastModifiedPointAttribute - offset + 1 ; copyPointAttributes ( offset , size ) ; modifiedPointAttributes = false ; firstModifiedPointAttribute = PConstants . MAX_INT ; lastModifiedPointAttribute = PConstants . MIN_INT ; } modified = false ; } protected void copyPolyVertices ( int offset , int size ) { tessGeo . updatePolyVerticesBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyVertex ) ; tessGeo . polyVerticesBuffer . position ( 4 * offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , 4 * offset * PGL . SIZEOF_FLOAT , 4 * size * PGL . SIZEOF_FLOAT , tessGeo . polyVerticesBuffer ) ; tessGeo . polyVerticesBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyPolyColors ( int offset , int size ) { tessGeo . updatePolyColorsBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyColor ) ; tessGeo . polyColorsBuffer . position ( offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , offset * PGL . SIZEOF_INT , size * PGL . SIZEOF_INT , tessGeo . polyColorsBuffer ) ; tessGeo . polyColorsBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyPolyNormals ( int offset , int size ) { tessGeo . updatePolyNormalsBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyNormal ) ; tessGeo . polyNormalsBuffer . position ( 3 * offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , 3 * offset * PGL . SIZEOF_FLOAT , 3 * size * PGL . SIZEOF_FLOAT , tessGeo . polyNormalsBuffer ) ; tessGeo . polyNormalsBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyPolyTexCoords ( int offset , int size ) { tessGeo . updatePolyTexCoordsBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyTexcoord ) ; tessGeo . polyTexCoordsBuffer . position ( 2 * offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , 2 * offset * PGL . SIZEOF_FLOAT , 2 * size * PGL . SIZEOF_FLOAT , tessGeo . polyTexCoordsBuffer ) ; tessGeo . polyTexCoordsBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyPolyAmbient ( int offset , int size ) { tessGeo . updatePolyAmbientBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyAmbient ) ; tessGeo . polyAmbientBuffer . position ( offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , offset * PGL . SIZEOF_INT , size * PGL . SIZEOF_INT , tessGeo . polyAmbientBuffer ) ; tessGeo . polyAmbientBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyPolySpecular ( int offset , int size ) { tessGeo . updatePolySpecularBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolySpecular ) ; tessGeo . polySpecularBuffer . position ( offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , offset * PGL . SIZEOF_INT , size * PGL . SIZEOF_INT , tessGeo . polySpecularBuffer ) ; tessGeo . polySpecularBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyPolyEmissive ( int offset , int size ) { tessGeo . updatePolyEmissiveBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyEmissive ) ; tessGeo . polyEmissiveBuffer . position ( offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , offset * PGL . SIZEOF_INT , size * PGL . SIZEOF_INT , tessGeo . polyEmissiveBuffer ) ; tessGeo . polyEmissiveBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyPolyShininess ( int offset , int size ) { tessGeo . updatePolyShininessBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyShininess ) ; tessGeo . polyShininessBuffer . position ( offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , offset * PGL . SIZEOF_FLOAT , size * PGL . SIZEOF_FLOAT , tessGeo . polyShininessBuffer ) ; tessGeo . polyShininessBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyPolyAttrib ( VertexAttribute attrib , int offset , int size ) { tessGeo . updateAttribBuffer ( attrib . name , offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , attrib . glName ) ; Buffer buf = tessGeo . polyAttribBuffers . get ( attrib . name ) ; buf . position ( attrib . size * offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , attrib . sizeInBytes ( offset ) , attrib . sizeInBytes ( size ) , buf ) ; buf . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyLineVertices ( int offset , int size ) { tessGeo . updateLineVerticesBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glLineVertex ) ; tessGeo . lineVerticesBuffer . position ( 4 * offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , 4 * offset * PGL . SIZEOF_FLOAT , 4 * size * PGL . SIZEOF_FLOAT , tessGeo . lineVerticesBuffer ) ; tessGeo . lineVerticesBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyLineColors ( int offset , int size ) { tessGeo . updateLineColorsBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glLineColor ) ; tessGeo . lineColorsBuffer . position ( offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , offset * PGL . SIZEOF_INT , size * PGL . SIZEOF_INT , tessGeo . lineColorsBuffer ) ; tessGeo . lineColorsBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyLineAttributes ( int offset , int size ) { tessGeo . updateLineDirectionsBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glLineAttrib ) ; tessGeo . lineDirectionsBuffer . position ( 4 * offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , 4 * offset * PGL . SIZEOF_FLOAT , 4 * size * PGL . SIZEOF_FLOAT , tessGeo . lineDirectionsBuffer ) ; tessGeo . lineDirectionsBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyPointVertices ( int offset , int size ) { tessGeo . updatePointVerticesBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPointVertex ) ; tessGeo . pointVerticesBuffer . position ( 4 * offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , 4 * offset * PGL . SIZEOF_FLOAT , 4 * size * PGL . SIZEOF_FLOAT , tessGeo . pointVerticesBuffer ) ; tessGeo . pointVerticesBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyPointColors ( int offset , int size ) { tessGeo . updatePointColorsBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPointColor ) ; tessGeo . pointColorsBuffer . position ( offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , offset * PGL . SIZEOF_INT , size * PGL . SIZEOF_INT , tessGeo . pointColorsBuffer ) ; tessGeo . pointColorsBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void copyPointAttributes ( int offset , int size ) { tessGeo . updatePointOffsetsBuffer ( offset , size ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPointAttrib ) ; tessGeo . pointOffsetsBuffer . position ( 2 * offset ) ; pgl . bufferSubData ( PGL . ARRAY_BUFFER , 2 * offset * PGL . SIZEOF_FLOAT , 2 * size * PGL . SIZEOF_FLOAT , tessGeo . pointOffsetsBuffer ) ; tessGeo . pointOffsetsBuffer . rewind ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void setModifiedPolyVertices ( int first , int last ) { if ( first < firstModifiedPolyVertex ) firstModifiedPolyVertex = first ; if ( last > lastModifiedPolyVertex ) lastModifiedPolyVertex = last ; modifiedPolyVertices = true ; modified = true ; } protected void setModifiedPolyColors ( int first , int last ) { if ( first < firstModifiedPolyColor ) firstModifiedPolyColor = first ; if ( last > lastModifiedPolyColor ) lastModifiedPolyColor = last ; modifiedPolyColors = true ; modified = true ; } protected void setModifiedPolyNormals ( int first , int last ) { if ( first < firstModifiedPolyNormal ) firstModifiedPolyNormal = first ; if ( last > lastModifiedPolyNormal ) lastModifiedPolyNormal = last ; modifiedPolyNormals = true ; modified = true ; } protected void setModifiedPolyTexCoords ( int first , int last ) { if ( first < firstModifiedPolyTexcoord ) firstModifiedPolyTexcoord = first ; if ( last > lastModifiedPolyTexcoord ) lastModifiedPolyTexcoord = last ; modifiedPolyTexCoords = true ; modified = true ; } protected void setModifiedPolyAmbient ( int first , int last ) { if ( first < firstModifiedPolyAmbient ) firstModifiedPolyAmbient = first ; if ( last > lastModifiedPolyAmbient ) lastModifiedPolyAmbient = last ; modifiedPolyAmbient = true ; modified = true ; } protected void setModifiedPolySpecular ( int first , int last ) { if ( first < firstModifiedPolySpecular ) firstModifiedPolySpecular = first ; if ( last > lastModifiedPolySpecular ) lastModifiedPolySpecular = last ; modifiedPolySpecular = true ; modified = true ; } protected void setModifiedPolyEmissive ( int first , int last ) { if ( first < firstModifiedPolyEmissive ) firstModifiedPolyEmissive = first ; if ( last > lastModifiedPolyEmissive ) lastModifiedPolyEmissive = last ; modifiedPolyEmissive = true ; modified = true ; } protected void setModifiedPolyShininess ( int first , int last ) { if ( first < firstModifiedPolyShininess ) firstModifiedPolyShininess = first ; if ( last > lastModifiedPolyShininess ) lastModifiedPolyShininess = last ; modifiedPolyShininess = true ; modified = true ; } protected void setModifiedPolyAttrib ( VertexAttribute attrib , int first , int last ) { if ( first < attrib . firstModified ) attrib . firstModified = first ; if ( last > attrib . lastModified ) attrib . lastModified = last ; attrib . modified = true ; modified = true ; } protected void setModifiedLineVertices ( int first , int last ) { if ( first < firstModifiedLineVertex ) firstModifiedLineVertex = first ; if ( last > lastModifiedLineVertex ) lastModifiedLineVertex = last ; modifiedLineVertices = true ; modified = true ; } protected void setModifiedLineColors ( int first , int last ) { if ( first < firstModifiedLineColor ) firstModifiedLineColor = first ; if ( last > lastModifiedLineColor ) lastModifiedLineColor = last ; modifiedLineColors = true ; modified = true ; } protected void setModifiedLineAttributes ( int first , int last ) { if ( first < firstModifiedLineAttribute ) firstModifiedLineAttribute = first ; if ( last > lastModifiedLineAttribute ) lastModifiedLineAttribute = last ; modifiedLineAttributes = true ; modified = true ; } protected void setModifiedPointVertices ( int first , int last ) { if ( first < firstModifiedPointVertex ) firstModifiedPointVertex = first ; if ( last > lastModifiedPointVertex ) lastModifiedPointVertex = last ; modifiedPointVertices = true ; modified = true ; } protected void setModifiedPointColors ( int first , int last ) { if ( first < firstModifiedPointColor ) firstModifiedPointColor = first ; if ( last > lastModifiedPointColor ) lastModifiedPointColor = last ; modifiedPointColors = true ; modified = true ; } protected void setModifiedPointAttributes ( int first , int last ) { if ( first < firstModifiedPointAttribute ) firstModifiedPointAttribute = first ; if ( last > lastModifiedPointAttribute ) lastModifiedPointAttribute = last ; modifiedPointAttributes = true ; modified = true ; } @ Override public void disableStyle ( ) { if ( openShape ) { PGraphics . showWarning ( INSIDE_BEGIN_END_ERROR , "disableStyle()" ) ; return ; } savedStroke = stroke ; savedStrokeColor = strokeColor ; savedStrokeWeight = strokeWeight ; savedStrokeCap = strokeCap ; savedStrokeJoin = strokeJoin ; savedFill = fill ; savedFillColor = fillColor ; savedTint = tint ; savedTintColor = tintColor ; savedAmbientColor = ambientColor ; savedSpecularColor = specularColor ; savedEmissiveColor = emissiveColor ; savedShininess = shininess ; savedTextureMode = textureMode ; super . disableStyle ( ) ; } @ Override public void enableStyle ( ) { if ( savedStroke ) { setStroke ( true ) ; setStroke ( savedStrokeColor ) ; setStrokeWeight ( savedStrokeWeight ) ; setStrokeCap ( savedStrokeCap ) ; setStrokeJoin ( savedStrokeJoin ) ; } else { setStroke ( false ) ; } if ( savedFill ) { setFill ( true ) ; setFill ( savedFillColor ) ; } else { setFill ( false ) ; } if ( savedTint ) { setTint ( true ) ; setTint ( savedTintColor ) ; } setAmbient ( savedAmbientColor ) ; setSpecular ( savedSpecularColor ) ; setEmissive ( savedEmissiveColor ) ; setShininess ( savedShininess ) ; if ( image != null ) { setTextureMode ( savedTextureMode ) ; } super . enableStyle ( ) ; } @ Override protected void styles ( PGraphics g ) { if ( g instanceof PGraphicsOpenGL ) { if ( g . stroke ) { setStroke ( true ) ; setStroke ( g . strokeColor ) ; setStrokeWeight ( g . strokeWeight ) ; setStrokeCap ( g . strokeCap ) ; setStrokeJoin ( g . strokeJoin ) ; } else { setStroke ( false ) ; } if ( g . fill ) { setFill ( true ) ; setFill ( g . fillColor ) ; } else { setFill ( false ) ; } if ( g . tint ) { setTint ( true ) ; setTint ( g . tintColor ) ; } setAmbient ( g . ambientColor ) ; setSpecular ( g . specularColor ) ; setEmissive ( g . emissiveColor ) ; setShininess ( g . shininess ) ; if ( image != null ) { setTextureMode ( g . textureMode ) ; } } else { super . styles ( g ) ; } } public void draw ( ) { draw ( pg ) ; } @ Override public void draw ( PGraphics g ) { if ( g instanceof PGraphicsOpenGL ) { PGraphicsOpenGL gl = ( PGraphicsOpenGL ) g ; if ( visible ) { pre ( gl ) ; updateTessellation ( ) ; updateGeometry ( ) ; if ( family == GROUP ) { if ( fragmentedGroup ( gl ) ) { for ( int i = 0 ; i < childCount ; i ++ ) { ( ( PShapeOpenGL ) children [ i ] ) . draw ( gl ) ; } } else { PImage tex = null ; if ( textures != null && textures . size ( ) == 1 ) { tex = ( PImage ) textures . toArray ( ) [ 0 ] ; } render ( gl , tex ) ; } } else { render ( gl , image ) ; } post ( gl ) ; } } else { super . draw ( g ) ; } } protected boolean fragmentedGroup ( PGraphicsOpenGL g ) { return g . getHint ( DISABLE_OPTIMIZED_STROKE ) || ( textures != null && 1 < textures . size ( ) ) || strokedTexture ; } @ Override protected void pre ( PGraphics g ) { if ( g instanceof PGraphicsOpenGL ) { if ( ! style ) { styles ( g ) ; } } else { super . pre ( g ) ; } } @ Override protected void post ( PGraphics g ) { if ( g instanceof PGraphicsOpenGL ) { } else { super . post ( g ) ; } } @ Override protected void drawGeometry ( PGraphics g ) { vertexCount = inGeo . vertexCount ; vertices = inGeo . getVertexData ( ) ; super . drawGeometry ( g ) ; vertexCount = 0 ; vertices = null ; } protected void render ( PGraphicsOpenGL g , PImage texture ) { if ( root == null ) { throw new RuntimeException ( "Error rendering PShapeOpenGL, root shape is " + "null" ) ; } if ( hasPolys ) { renderPolys ( g , texture ) ; if ( g . haveRaw ( ) ) { rawPolys ( g , texture ) ; } } if ( is3D ( ) ) { if ( hasLines ) { renderLines ( g ) ; if ( g . haveRaw ( ) ) { rawLines ( g ) ; } } if ( hasPoints ) { renderPoints ( g ) ; if ( g . haveRaw ( ) ) { rawPoints ( g ) ; } } } } protected void renderPolys ( PGraphicsOpenGL g , PImage textureImage ) { boolean customShader = g . polyShader != null ; boolean needNormals = customShader ? g . polyShader . accessNormals ( ) : false ; boolean needTexCoords = customShader ? g . polyShader . accessTexCoords ( ) : false ; Texture tex = textureImage != null ? g . getTexture ( textureImage ) : null ; boolean renderingFill = false , renderingStroke = false ; PShader shader = null ; IndexCache cache = tessGeo . polyIndexCache ; for ( int n = firstPolyIndexCache ; n <= lastPolyIndexCache ; n ++ ) { if ( is3D ( ) || ( tex != null && ( firstLineIndexCache == - 1 || n < firstLineIndexCache ) && ( firstPointIndexCache == - 1 || n < firstPointIndexCache ) ) ) { if ( ! renderingFill ) { shader = g . getPolyShader ( g . lights , tex != null ) ; shader . bind ( ) ; renderingFill = true ; } } else { if ( ! renderingStroke ) { if ( tex != null ) { tex . unbind ( ) ; tex = null ; } if ( shader != null && shader . bound ( ) ) { shader . unbind ( ) ; } shader = g . getPolyShader ( g . lights , false ) ; shader . bind ( ) ; renderingFill = false ; renderingStroke = true ; } } int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int voffset = cache . vertexOffset [ n ] ; shader . setVertexAttribute ( root . glPolyVertex , 4 , PGL . FLOAT , 0 , 4 * voffset * PGL . SIZEOF_FLOAT ) ; shader . setColorAttribute ( root . glPolyColor , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; if ( g . lights ) { shader . setNormalAttribute ( root . glPolyNormal , 3 , PGL . FLOAT , 0 , 3 * voffset * PGL . SIZEOF_FLOAT ) ; shader . setAmbientAttribute ( root . glPolyAmbient , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; shader . setSpecularAttribute ( root . glPolySpecular , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; shader . setEmissiveAttribute ( root . glPolyEmissive , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; shader . setShininessAttribute ( root . glPolyShininess , 1 , PGL . FLOAT , 0 , voffset * PGL . SIZEOF_FLOAT ) ; } if ( g . lights || needNormals ) { shader . setNormalAttribute ( root . glPolyNormal , 3 , PGL . FLOAT , 0 , 3 * voffset * PGL . SIZEOF_FLOAT ) ; } if ( tex != null || needTexCoords ) { shader . setTexcoordAttribute ( root . glPolyTexcoord , 2 , PGL . FLOAT , 0 , 2 * voffset * PGL . SIZEOF_FLOAT ) ; shader . setTexture ( tex ) ; } for ( VertexAttribute attrib : polyAttribs . values ( ) ) { if ( ! attrib . active ( shader ) ) continue ; attrib . bind ( pgl ) ; shader . setAttributeVBO ( attrib . glLoc , attrib . glName , attrib . tessSize , attrib . type , attrib . isColor ( ) , 0 , attrib . sizeInBytes ( voffset ) ) ; } shader . draw ( root . glPolyIndex , icount , ioffset ) ; } for ( VertexAttribute attrib : polyAttribs . values ( ) ) { if ( attrib . active ( shader ) ) attrib . unbind ( pgl ) ; } if ( shader != null && shader . bound ( ) ) { shader . unbind ( ) ; } } protected void rawPolys ( PGraphicsOpenGL g , PImage textureImage ) { PGraphics raw = g . getRaw ( ) ; raw . colorMode ( RGB ) ; raw . noStroke ( ) ; raw . beginShape ( TRIANGLES ) ; float [ ] vertices = tessGeo . polyVertices ; int [ ] color = tessGeo . polyColors ; float [ ] uv = tessGeo . polyTexCoords ; short [ ] indices = tessGeo . polyIndices ; IndexCache cache = tessGeo . polyIndexCache ; for ( int n = firstPolyIndexCache ; n <= lastPolyIndexCache ; n ++ ) { int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int voffset = cache . vertexOffset [ n ] ; for ( int tr = ioffset / 3 ; tr < ( ioffset + icount ) / 3 ; tr ++ ) { int i0 = voffset + indices [ 3 * tr + 0 ] ; int i1 = voffset + indices [ 3 * tr + 1 ] ; int i2 = voffset + indices [ 3 * tr + 2 ] ; float [ ] src0 = { 0 , 0 , 0 , 0 } ; float [ ] src1 = { 0 , 0 , 0 , 0 } ; float [ ] src2 = { 0 , 0 , 0 , 0 } ; float [ ] pt0 = { 0 , 0 , 0 , 0 } ; float [ ] pt1 = { 0 , 0 , 0 , 0 } ; float [ ] pt2 = { 0 , 0 , 0 , 0 } ; int argb0 = PGL . nativeToJavaARGB ( color [ i0 ] ) ; int argb1 = PGL . nativeToJavaARGB ( color [ i1 ] ) ; int argb2 = PGL . nativeToJavaARGB ( color [ i2 ] ) ; PApplet . arrayCopy ( vertices , 4 * i0 , src0 , 0 , 4 ) ; PApplet . arrayCopy ( vertices , 4 * i1 , src1 , 0 , 4 ) ; PApplet . arrayCopy ( vertices , 4 * i2 , src2 , 0 , 4 ) ; g . modelview . mult ( src0 , pt0 ) ; g . modelview . mult ( src1 , pt1 ) ; g . modelview . mult ( src2 , pt2 ) ; if ( textureImage != null ) { raw . texture ( textureImage ) ; if ( raw . is3D ( ) ) { raw . fill ( argb0 ) ; raw . vertex ( pt0 [ X ] , pt0 [ Y ] , pt0 [ Z ] , uv [ 2 * i0 + 0 ] , uv [ 2 * i0 + 1 ] ) ; raw . fill ( argb1 ) ; raw . vertex ( pt1 [ X ] , pt1 [ Y ] , pt1 [ Z ] , uv [ 2 * i1 + 0 ] , uv [ 2 * i1 + 1 ] ) ; raw . fill ( argb2 ) ; raw . vertex ( pt2 [ X ] , pt2 [ Y ] , pt2 [ Z ] , uv [ 2 * i2 + 0 ] , uv [ 2 * i2 + 1 ] ) ; } else if ( raw . is2D ( ) ) { float sx0 = g . screenXImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sy0 = g . screenYImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sx1 = g . screenXImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sy1 = g . screenYImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sx2 = g . screenXImpl ( pt2 [ 0 ] , pt2 [ 1 ] , pt2 [ 2 ] , pt2 [ 3 ] ) ; float sy2 = g . screenYImpl ( pt2 [ 0 ] , pt2 [ 1 ] , pt2 [ 2 ] , pt2 [ 3 ] ) ; raw . fill ( argb0 ) ; raw . vertex ( sx0 , sy0 , uv [ 2 * i0 + 0 ] , uv [ 2 * i0 + 1 ] ) ; raw . fill ( argb1 ) ; raw . vertex ( sx1 , sy1 , uv [ 2 * i1 + 0 ] , uv [ 2 * i1 + 1 ] ) ; raw . fill ( argb1 ) ; raw . vertex ( sx2 , sy2 , uv [ 2 * i2 + 0 ] , uv [ 2 * i2 + 1 ] ) ; } } else { if ( raw . is3D ( ) ) { raw . fill ( argb0 ) ; raw . vertex ( pt0 [ X ] , pt0 [ Y ] , pt0 [ Z ] ) ; raw . fill ( argb1 ) ; raw . vertex ( pt1 [ X ] , pt1 [ Y ] , pt1 [ Z ] ) ; raw . fill ( argb2 ) ; raw . vertex ( pt2 [ X ] , pt2 [ Y ] , pt2 [ Z ] ) ; } else if ( raw . is2D ( ) ) { float sx0 = g . screenXImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sy0 = g . screenYImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sx1 = g . screenXImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sy1 = g . screenYImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sx2 = g . screenXImpl ( pt2 [ 0 ] , pt2 [ 1 ] , pt2 [ 2 ] , pt2 [ 3 ] ) ; float sy2 = g . screenYImpl ( pt2 [ 0 ] , pt2 [ 1 ] , pt2 [ 2 ] , pt2 [ 3 ] ) ; raw . fill ( argb0 ) ; raw . vertex ( sx0 , sy0 ) ; raw . fill ( argb1 ) ; raw . vertex ( sx1 , sy1 ) ; raw . fill ( argb2 ) ; raw . vertex ( sx2 , sy2 ) ; } } } } raw . endShape ( ) ; } protected void renderLines ( PGraphicsOpenGL g ) { PShader shader = g . getLineShader ( ) ; shader . bind ( ) ; IndexCache cache = tessGeo . lineIndexCache ; for ( int n = firstLineIndexCache ; n <= lastLineIndexCache ; n ++ ) { int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int voffset = cache . vertexOffset [ n ] ; shader . setVertexAttribute ( root . glLineVertex , 4 , PGL . FLOAT , 0 , 4 * voffset * PGL . SIZEOF_FLOAT ) ; shader . setColorAttribute ( root . glLineColor , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; shader . setLineAttribute ( root . glLineAttrib , 4 , PGL . FLOAT , 0 , 4 * voffset * PGL . SIZEOF_FLOAT ) ; shader . draw ( root . glLineIndex , icount , ioffset ) ; } shader . unbind ( ) ; } protected void rawLines ( PGraphicsOpenGL g ) { PGraphics raw = g . getRaw ( ) ; raw . colorMode ( RGB ) ; raw . noFill ( ) ; raw . strokeCap ( strokeCap ) ; raw . strokeJoin ( strokeJoin ) ; raw . beginShape ( LINES ) ; float [ ] vertices = tessGeo . lineVertices ; int [ ] color = tessGeo . lineColors ; float [ ] attribs = tessGeo . lineDirections ; short [ ] indices = tessGeo . lineIndices ; IndexCache cache = tessGeo . lineIndexCache ; for ( int n = firstLineIndexCache ; n <= lastLineIndexCache ; n ++ ) { int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int voffset = cache . vertexOffset [ n ] ; for ( int ln = ioffset / 6 ; ln < ( ioffset + icount ) / 6 ; ln ++ ) { int i0 = voffset + indices [ 6 * ln + 0 ] ; int i1 = voffset + indices [ 6 * ln + 5 ] ; float sw0 = 2 * attribs [ 4 * i0 + 3 ] ; float sw1 = 2 * attribs [ 4 * i1 + 3 ] ; if ( PGraphicsOpenGL . zero ( sw0 ) ) continue ; float [ ] src0 = { 0 , 0 , 0 , 0 } ; float [ ] src1 = { 0 , 0 , 0 , 0 } ; float [ ] pt0 = { 0 , 0 , 0 , 0 } ; float [ ] pt1 = { 0 , 0 , 0 , 0 } ; int argb0 = PGL . nativeToJavaARGB ( color [ i0 ] ) ; int argb1 = PGL . nativeToJavaARGB ( color [ i1 ] ) ; PApplet . arrayCopy ( vertices , 4 * i0 , src0 , 0 , 4 ) ; PApplet . arrayCopy ( vertices , 4 * i1 , src1 , 0 , 4 ) ; g . modelview . mult ( src0 , pt0 ) ; g . modelview . mult ( src1 , pt1 ) ; if ( raw . is3D ( ) ) { raw . strokeWeight ( sw0 ) ; raw . stroke ( argb0 ) ; raw . vertex ( pt0 [ X ] , pt0 [ Y ] , pt0 [ Z ] ) ; raw . strokeWeight ( sw1 ) ; raw . stroke ( argb1 ) ; raw . vertex ( pt1 [ X ] , pt1 [ Y ] , pt1 [ Z ] ) ; } else if ( raw . is2D ( ) ) { float sx0 = g . screenXImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sy0 = g . screenYImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sx1 = g . screenXImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sy1 = g . screenYImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; raw . strokeWeight ( sw0 ) ; raw . stroke ( argb0 ) ; raw . vertex ( sx0 , sy0 ) ; raw . strokeWeight ( sw1 ) ; raw . stroke ( argb1 ) ; raw . vertex ( sx1 , sy1 ) ; } } } raw . endShape ( ) ; } protected void renderPoints ( PGraphicsOpenGL g ) { PShader shader = g . getPointShader ( ) ; shader . bind ( ) ; IndexCache cache = tessGeo . pointIndexCache ; for ( int n = firstPointIndexCache ; n <= lastPointIndexCache ; n ++ ) { int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int voffset = cache . vertexOffset [ n ] ; shader . setVertexAttribute ( root . glPointVertex , 4 , PGL . FLOAT , 0 , 4 * voffset * PGL . SIZEOF_FLOAT ) ; shader . setColorAttribute ( root . glPointColor , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; shader . setPointAttribute ( root . glPointAttrib , 2 , PGL . FLOAT , 0 , 2 * voffset * PGL . SIZEOF_FLOAT ) ; shader . draw ( root . glPointIndex , icount , ioffset ) ; } shader . unbind ( ) ; } protected void rawPoints ( PGraphicsOpenGL g ) { PGraphics raw = g . getRaw ( ) ; raw . colorMode ( RGB ) ; raw . noFill ( ) ; raw . strokeCap ( strokeCap ) ; raw . beginShape ( POINTS ) ; float [ ] vertices = tessGeo . pointVertices ; int [ ] color = tessGeo . pointColors ; float [ ] attribs = tessGeo . pointOffsets ; short [ ] indices = tessGeo . pointIndices ; IndexCache cache = tessGeo . pointIndexCache ; for ( int n = 0 ; n < cache . size ; n ++ ) { int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int voffset = cache . vertexOffset [ n ] ; int pt = ioffset ; while ( pt < ( ioffset + icount ) / 3 ) { float size = attribs [ 2 * pt + 2 ] ; float weight ; int perim ; if ( 0 < size ) { weight = + size / 0.5f ; perim = PApplet . min ( PGraphicsOpenGL . MAX_POINT_ACCURACY , PApplet . max ( PGraphicsOpenGL . MIN_POINT_ACCURACY , ( int ) ( TWO_PI * weight / PGraphicsOpenGL . POINT_ACCURACY_FACTOR ) ) ) + 1 ; } else { weight = - size / 0.5f ; perim = 5 ; } int i0 = voffset + indices [ 3 * pt ] ; int argb0 = PGL . nativeToJavaARGB ( color [ i0 ] ) ; float [ ] pt0 = { 0 , 0 , 0 , 0 } ; float [ ] src0 = { 0 , 0 , 0 , 0 } ; PApplet . arrayCopy ( vertices , 4 * i0 , src0 , 0 , 4 ) ; g . modelview . mult ( src0 , pt0 ) ; if ( raw . is3D ( ) ) { raw . strokeWeight ( weight ) ; raw . stroke ( argb0 ) ; raw . vertex ( pt0 [ X ] , pt0 [ Y ] , pt0 [ Z ] ) ; } else if ( raw . is2D ( ) ) { float sx0 = g . screenXImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sy0 = g . screenYImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; raw . strokeWeight ( weight ) ; raw . stroke ( argb0 ) ; raw . vertex ( sx0 , sy0 ) ; } pt += perim ; } } raw . endShape ( ) ; } }
package processing . opengl ; import java . io . IOException ; import java . net . URL ; import java . nio . Buffer ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . FloatBuffer ; import java . nio . IntBuffer ; import java . nio . ShortBuffer ; import java . util . Arrays ; import processing . core . PApplet ; import processing . core . PGraphics ; public abstract class PGL { protected PGraphicsOpenGL pg ; protected Thread glThread ; protected int glContext ; public boolean primaryPGL ; protected static boolean USE_FBOLAYER_BY_DEFAULT = false ; public static int REQUESTED_DEPTH_BITS = 24 ; public static int REQUESTED_STENCIL_BITS = 8 ; public static int REQUESTED_ALPHA_BITS = 8 ; protected static boolean USE_DIRECT_BUFFERS = true ; protected static int MIN_DIRECT_BUFFER_SIZE = 1 ; protected static boolean SAVE_SURFACE_TO_PIXELS_HACK = false ; protected static boolean MIPMAPS_ENABLED = true ; protected static int DEFAULT_IN_VERTICES = 64 ; protected static int DEFAULT_IN_EDGES = 128 ; protected static int DEFAULT_IN_TEXTURES = 64 ; protected static int DEFAULT_TESS_VERTICES = 64 ; protected static int DEFAULT_TESS_INDICES = 128 ; protected static int MAX_LIGHTS = 8 ; protected static int MAX_VERTEX_INDEX = 32767 ; protected static int MAX_VERTEX_INDEX1 = MAX_VERTEX_INDEX + 1 ; protected static int FLUSH_VERTEX_COUNT = MAX_VERTEX_INDEX1 ; protected static int MIN_FONT_TEX_SIZE = 256 ; protected static int MAX_FONT_TEX_SIZE = 1024 ; protected static float MIN_CAPS_JOINS_WEIGHT = 2f ; protected static int MAX_CAPS_JOINS_LENGTH = 5000 ; protected static int MIN_ARRAYCOPY_SIZE = 2 ; protected static float STROKE_DISPLACEMENT = 0.999f ; protected boolean fboLayerRequested = false ; protected boolean fboLayerCreated = false ; protected boolean fboLayerInUse = false ; protected boolean firstFrame = true ; public int reqNumSamples ; protected int numSamples ; protected IntBuffer glColorFbo ; protected IntBuffer glMultiFbo ; protected IntBuffer glColorBuf ; protected IntBuffer glColorTex ; protected IntBuffer glDepthStencil ; protected IntBuffer glDepth ; protected IntBuffer glStencil ; protected int fboWidth , fboHeight ; protected int backTex , frontTex ; protected boolean usingFrontTex = false ; protected boolean needSepFrontTex = false ; protected boolean loadedTex2DShader = false ; protected int tex2DShaderProgram ; protected int tex2DVertShader ; protected int tex2DFragShader ; protected int tex2DShaderContext ; protected int tex2DVertLoc ; protected int tex2DTCoordLoc ; protected int tex2DSamplerLoc ; protected int tex2DGeoVBO ; protected boolean loadedTexRectShader = false ; protected int texRectShaderProgram ; protected int texRectVertShader ; protected int texRectFragShader ; protected int texRectShaderContext ; protected int texRectVertLoc ; protected int texRectTCoordLoc ; protected int texRectSamplerLoc ; protected int texRectGeoVBO ; protected float [ ] texCoords = { - 1.0f , - 1.0f , 0.0f , 0.0f , + 1.0f , - 1.0f , 1.0f , 0.0f , - 1.0f , + 1.0f , 0.0f , 1.0f , + 1.0f , + 1.0f , 1.0f , 1.0f } ; protected FloatBuffer texData ; protected static final String SHADER_PREPROCESSOR_DIRECTIVE = "#ifdef GL_ES\n" + "precision mediump float;\n" + "precision mediump int;\n" + "#endif\n" ; protected static String [ ] texVertShaderSource = { "attribute vec2 position;" , "attribute vec2 texCoord;" , "varying vec2 vertTexCoord;" , "void main() {" , " gl_Position = vec4(position, 0, 1);" , " vertTexCoord = texCoord;" , "}" } ; protected static String [ ] tex2DFragShaderSource = { SHADER_PREPROCESSOR_DIRECTIVE , "uniform sampler2D texMap;" , "varying vec2 vertTexCoord;" , "void main() {" , " gl_FragColor = texture2D(texMap, vertTexCoord.st);" , "}" } ; protected static String [ ] texRectFragShaderSource = { SHADER_PREPROCESSOR_DIRECTIVE , "uniform sampler2DRect texMap;" , "varying vec2 vertTexCoord;" , "void main() {" , " gl_FragColor = texture2DRect(texMap, vertTexCoord.st);" , "}" } ; protected boolean [ ] texturingTargets = { false , false } ; protected int maxTexUnits ; protected int activeTexUnit = 0 ; protected int [ ] [ ] boundTextures ; protected float targetFps = 60 ; protected float currentFps = 60 ; protected boolean setFps = false ; protected ByteBuffer byteBuffer ; protected IntBuffer intBuffer ; protected IntBuffer viewBuffer ; protected IntBuffer colorBuffer ; protected FloatBuffer depthBuffer ; protected ByteBuffer stencilBuffer ; public static final String WIKI = " Read http://wiki.processing.org/w/OpenGL_Issues for help." ; public static final String FRAMEBUFFER_ERROR = "Framebuffer error (%1$s), rendering will probably not work as expected" + WIKI ; public static final String MISSING_FBO_ERROR = "Framebuffer objects are not supported by this hardware (or driver)" + WIKI ; public static final String MISSING_GLSL_ERROR = "GLSL shaders are not supported by this hardware (or driver)" + WIKI ; public static final String MISSING_GLFUNC_ERROR = "GL function %1$s is not available on this hardware (or driver)" + WIKI ; public static final String UNSUPPORTED_GLPROF_ERROR = "Unsupported OpenGL profile." ; public static final String TEXUNIT_ERROR = "Number of texture units not supported by this hardware (or driver)" + WIKI ; public static final String NONPRIMARY_ERROR = "The renderer is trying to call a PGL function that can only be called on a primary PGL. " + "This is most likely due to a bug in the renderer's code, please report it with an " + "issue on Processing's github page https://github.com/processing/processing/issues?state=open " + "if using any of the built-in OpenGL renderers. If you are using a contributed " + "library, contact the library's developers." ; protected static int SIZEOF_SHORT = Short . SIZE / 8 ; protected static int SIZEOF_INT = Integer . SIZE / 8 ; protected static int SIZEOF_FLOAT = Float . SIZE / 8 ; protected static int SIZEOF_BYTE = Byte . SIZE / 8 ; protected static int SIZEOF_INDEX = SIZEOF_SHORT ; protected static int INDEX_TYPE = 0x1403 ; protected static float FLOAT_EPS = Float . MIN_VALUE ; static { float eps = 1.0f ; do { eps /= 2.0f ; } while ( ( float ) ( 1.0 + ( eps / 2.0 ) ) != 1.0 ) ; FLOAT_EPS = eps ; } protected static boolean BIG_ENDIAN = ByteOrder . nativeOrder ( ) == ByteOrder . BIG_ENDIAN ; public boolean presentMode = false ; public float offsetX ; public float offsetY ; public PGL ( ) { } public PGL ( PGraphicsOpenGL pg ) { this . pg = pg ; if ( glColorTex == null ) { glColorTex = allocateIntBuffer ( 2 ) ; glColorFbo = allocateIntBuffer ( 1 ) ; glMultiFbo = allocateIntBuffer ( 1 ) ; glColorBuf = allocateIntBuffer ( 1 ) ; glDepthStencil = allocateIntBuffer ( 1 ) ; glDepth = allocateIntBuffer ( 1 ) ; glStencil = allocateIntBuffer ( 1 ) ; fboLayerCreated = false ; fboLayerInUse = false ; firstFrame = false ; } byteBuffer = allocateByteBuffer ( 1 ) ; intBuffer = allocateIntBuffer ( 1 ) ; viewBuffer = allocateIntBuffer ( 4 ) ; } public void setPrimary ( boolean primary ) { primaryPGL = primary ; } static protected int smoothToSamples ( int smooth ) { if ( smooth == 0 ) { return 1 ; } else if ( smooth == 1 ) { return 2 ; } else { return smooth ; } } protected void deleteSurface ( ) { if ( threadIsCurrent ( ) && fboLayerCreated ) { deleteTextures ( 2 , glColorTex ) ; deleteFramebuffers ( 1 , glColorFbo ) ; deleteFramebuffers ( 1 , glMultiFbo ) ; deleteRenderbuffers ( 1 , glColorBuf ) ; deleteRenderbuffers ( 1 , glDepthStencil ) ; deleteRenderbuffers ( 1 , glDepth ) ; deleteRenderbuffers ( 1 , glStencil ) ; } fboLayerCreated = false ; fboLayerInUse = false ; firstFrame = false ; } protected int getReadFramebuffer ( ) { return fboLayerInUse ? glColorFbo . get ( 0 ) : 0 ; } protected int getDrawFramebuffer ( ) { if ( fboLayerInUse ) return 1 < numSamples ? glMultiFbo . get ( 0 ) : glColorFbo . get ( 0 ) ; else return 0 ; } protected int getDefaultDrawBuffer ( ) { return fboLayerInUse ? COLOR_ATTACHMENT0 : BACK ; } protected int getDefaultReadBuffer ( ) { return fboLayerInUse ? COLOR_ATTACHMENT0 : FRONT ; } protected boolean isFBOBacked ( ) { ; return fboLayerInUse ; } public void requestFBOLayer ( ) { fboLayerRequested = true ; } protected boolean isMultisampled ( ) { return 1 < numSamples ; } protected int getDepthBits ( ) { intBuffer . rewind ( ) ; getIntegerv ( DEPTH_BITS , intBuffer ) ; return intBuffer . get ( 0 ) ; } protected int getStencilBits ( ) { intBuffer . rewind ( ) ; getIntegerv ( STENCIL_BITS , intBuffer ) ; return intBuffer . get ( 0 ) ; } protected boolean getDepthTest ( ) { intBuffer . rewind ( ) ; getBooleanv ( DEPTH_TEST , intBuffer ) ; return intBuffer . get ( 0 ) == 0 ? false : true ; } protected boolean getDepthWriteMask ( ) { intBuffer . rewind ( ) ; getBooleanv ( DEPTH_WRITEMASK , intBuffer ) ; return intBuffer . get ( 0 ) == 0 ? false : true ; } protected Texture wrapBackTexture ( Texture texture ) { if ( texture == null ) { texture = new Texture ( pg ) ; texture . init ( pg . width , pg . height , glColorTex . get ( backTex ) , TEXTURE_2D , RGBA , fboWidth , fboHeight , NEAREST , NEAREST , CLAMP_TO_EDGE , CLAMP_TO_EDGE ) ; texture . invertedY ( true ) ; texture . colorBuffer ( true ) ; pg . setCache ( pg , texture ) ; } else { texture . glName = glColorTex . get ( backTex ) ; } return texture ; } protected Texture wrapFrontTexture ( Texture texture ) { if ( texture == null ) { texture = new Texture ( pg ) ; texture . init ( pg . width , pg . height , glColorTex . get ( frontTex ) , TEXTURE_2D , RGBA , fboWidth , fboHeight , NEAREST , NEAREST , CLAMP_TO_EDGE , CLAMP_TO_EDGE ) ; texture . invertedY ( true ) ; texture . colorBuffer ( true ) ; } else { texture . glName = glColorTex . get ( frontTex ) ; } return texture ; } protected void bindFrontTexture ( ) { usingFrontTex = true ; if ( ! texturingIsEnabled ( TEXTURE_2D ) ) { enableTexturing ( TEXTURE_2D ) ; } bindTexture ( TEXTURE_2D , glColorTex . get ( frontTex ) ) ; } protected void unbindFrontTexture ( ) { if ( textureIsBound ( TEXTURE_2D , glColorTex . get ( frontTex ) ) ) { if ( ! texturingIsEnabled ( TEXTURE_2D ) ) { enableTexturing ( TEXTURE_2D ) ; bindTexture ( TEXTURE_2D , 0 ) ; disableTexturing ( TEXTURE_2D ) ; } else { bindTexture ( TEXTURE_2D , 0 ) ; } } } protected void syncBackTexture ( ) { if ( usingFrontTex ) needSepFrontTex = true ; if ( 1 < numSamples ) { bindFramebufferImpl ( READ_FRAMEBUFFER , glMultiFbo . get ( 0 ) ) ; bindFramebufferImpl ( DRAW_FRAMEBUFFER , glColorFbo . get ( 0 ) ) ; blitFramebuffer ( 0 , 0 , fboWidth , fboHeight , 0 , 0 , fboWidth , fboHeight , COLOR_BUFFER_BIT , NEAREST ) ; } } protected void beginDraw ( boolean clear0 ) { if ( needFBOLayer ( clear0 ) ) { if ( ! fboLayerCreated ) createFBOLayer ( ) ; bindFramebufferImpl ( FRAMEBUFFER , glColorFbo . get ( 0 ) ) ; framebufferTexture2D ( FRAMEBUFFER , COLOR_ATTACHMENT0 , TEXTURE_2D , glColorTex . get ( backTex ) , 0 ) ; if ( 1 < numSamples ) { bindFramebufferImpl ( FRAMEBUFFER , glMultiFbo . get ( 0 ) ) ; } if ( firstFrame ) { int argb = pg . backgroundColor ; float a = ( ( argb > > 24 ) & 0xff ) / 255.0f ; float r = ( ( argb > > 16 ) & 0xff ) / 255.0f ; float g = ( ( argb > > 8 ) & 0xff ) / 255.0f ; float b = ( ( argb ) & 0xff ) / 255.0f ; clearColor ( r , g , b , a ) ; clear ( COLOR_BUFFER_BIT ) ; } else if ( ! clear0 ) { int x = 0 ; int y = 0 ; if ( presentMode ) { x = ( int ) offsetX ; y = ( int ) offsetY ; } float scale = pg . getPixelScale ( ) ; drawTexture ( TEXTURE_2D , glColorTex . get ( frontTex ) , fboWidth , fboHeight , x , y , pg . width , pg . height , 0 , 0 , ( int ) ( scale * pg . width ) , ( int ) ( scale * pg . height ) , 0 , 0 , pg . width , pg . height ) ; } fboLayerInUse = true ; } else { fboLayerInUse = false ; } if ( firstFrame ) { firstFrame = false ; } } IntBuffer labelTex ; protected void endDraw ( boolean clear0 , int windowColor ) { if ( fboLayerInUse ) { syncBackTexture ( ) ; bindFramebufferImpl ( FRAMEBUFFER , 0 ) ; if ( presentMode ) { int argb = windowColor ; float a = ( ( argb > > 24 ) & 0xff ) / 255.0f ; float r = ( ( argb > > 16 ) & 0xff ) / 255.0f ; float g = ( ( argb > > 8 ) & 0xff ) / 255.0f ; float b = ( argb & 0xff ) / 255.0f ; clearDepth ( 1 ) ; clearColor ( r , g , b , a ) ; clear ( COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT ) ; if ( labelTex == null ) { labelTex = allocateIntBuffer ( 1 ) ; genTextures ( 1 , labelTex ) ; bindTexture ( TEXTURE_2D , labelTex . get ( 0 ) ) ; texParameteri ( TEXTURE_2D , TEXTURE_MIN_FILTER , NEAREST ) ; texParameteri ( TEXTURE_2D , TEXTURE_MAG_FILTER , NEAREST ) ; texParameteri ( TEXTURE_2D , TEXTURE_WRAP_S , CLAMP_TO_EDGE ) ; texParameteri ( TEXTURE_2D , TEXTURE_WRAP_T , CLAMP_TO_EDGE ) ; texImage2D ( TEXTURE_2D , 0 , RGBA , 100 , 50 , 0 , RGBA , UNSIGNED_BYTE , null ) ; IntBuffer buf = allocateIntBuffer ( labelPix ) ; copyToTexture ( TEXTURE_2D , RGBA , labelTex . get ( 0 ) , 0 , 0 , 100 , 50 , buf ) ; bindTexture ( TEXTURE_2D , 0 ) ; } drawTexture ( TEXTURE_2D , labelTex . get ( 0 ) , 100 , 50 , 0 , 0 , 20 + 100 , 20 + 50 , 0 , 50 , 100 , 0 , 20 , 20 , 20 + 100 , 20 + 50 ) ; } else { clearDepth ( 1 ) ; clearColor ( 0 , 0 , 0 , 0 ) ; clear ( COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT ) ; } disable ( BLEND ) ; int x = 0 ; int y = 0 ; if ( presentMode ) { x = ( int ) offsetX ; y = ( int ) offsetY ; } float scale = pg . getPixelScale ( ) ; drawTexture ( TEXTURE_2D , glColorTex . get ( backTex ) , fboWidth , fboHeight , x , y , pg . width , pg . height , 0 , 0 , ( int ) ( scale * pg . width ) , ( int ) ( scale * pg . height ) , 0 , 0 , pg . width , pg . height ) ; int temp = frontTex ; frontTex = backTex ; backTex = temp ; } } protected abstract void getGL ( PGL pgl ) ; public boolean threadIsCurrent ( ) { return Thread . currentThread ( ) == glThread ; } public void setThread ( Thread thread ) { glThread = thread ; } protected void beginGL ( ) { } protected void endGL ( ) { } private boolean needFBOLayer ( boolean clear0 ) { return fboLayerRequested ; } private void createFBOLayer ( ) { String ext = getString ( EXTENSIONS ) ; float scale = pg . getPixelScale ( ) ; if ( - 1 < ext . indexOf ( "texture_non_power_of_two" ) ) { fboWidth = ( int ) ( scale * pg . width ) ; fboHeight = ( int ) ( scale * pg . height ) ; } else { fboWidth = nextPowerOfTwo ( ( int ) ( scale * pg . width ) ) ; fboHeight = nextPowerOfTwo ( ( int ) ( scale * pg . height ) ) ; } int maxs = maxSamples ( ) ; if ( - 1 < ext . indexOf ( "_framebuffer_multisample" ) && 1 < maxs ) { numSamples = PApplet . min ( reqNumSamples , maxs ) ; } else { numSamples = 1 ; } boolean multisample = 1 < numSamples ; boolean packed = ext . indexOf ( "packed_depth_stencil" ) != - 1 ; int depthBits = PApplet . min ( REQUESTED_DEPTH_BITS , getDepthBits ( ) ) ; int stencilBits = PApplet . min ( REQUESTED_STENCIL_BITS , getStencilBits ( ) ) ; genTextures ( 2 , glColorTex ) ; for ( int i = 0 ; i < 2 ; i ++ ) { bindTexture ( TEXTURE_2D , glColorTex . get ( i ) ) ; texParameteri ( TEXTURE_2D , TEXTURE_MIN_FILTER , NEAREST ) ; texParameteri ( TEXTURE_2D , TEXTURE_MAG_FILTER , NEAREST ) ; texParameteri ( TEXTURE_2D , TEXTURE_WRAP_S , CLAMP_TO_EDGE ) ; texParameteri ( TEXTURE_2D , TEXTURE_WRAP_T , CLAMP_TO_EDGE ) ; texImage2D ( TEXTURE_2D , 0 , RGBA , fboWidth , fboHeight , 0 , RGBA , UNSIGNED_BYTE , null ) ; initTexture ( TEXTURE_2D , RGBA , fboWidth , fboHeight , pg . backgroundColor ) ; } bindTexture ( TEXTURE_2D , 0 ) ; backTex = 0 ; frontTex = 1 ; genFramebuffers ( 1 , glColorFbo ) ; bindFramebufferImpl ( FRAMEBUFFER , glColorFbo . get ( 0 ) ) ; framebufferTexture2D ( FRAMEBUFFER , COLOR_ATTACHMENT0 , TEXTURE_2D , glColorTex . get ( backTex ) , 0 ) ; if ( multisample ) { genFramebuffers ( 1 , glMultiFbo ) ; bindFramebufferImpl ( FRAMEBUFFER , glMultiFbo . get ( 0 ) ) ; genRenderbuffers ( 1 , glColorBuf ) ; bindRenderbuffer ( RENDERBUFFER , glColorBuf . get ( 0 ) ) ; renderbufferStorageMultisample ( RENDERBUFFER , numSamples , RGBA8 , fboWidth , fboHeight ) ; framebufferRenderbuffer ( FRAMEBUFFER , COLOR_ATTACHMENT0 , RENDERBUFFER , glColorBuf . get ( 0 ) ) ; } if ( packed && depthBits == 24 && stencilBits == 8 ) { genRenderbuffers ( 1 , glDepthStencil ) ; bindRenderbuffer ( RENDERBUFFER , glDepthStencil . get ( 0 ) ) ; if ( multisample ) { renderbufferStorageMultisample ( RENDERBUFFER , numSamples , DEPTH24_STENCIL8 , fboWidth , fboHeight ) ; } else { renderbufferStorage ( RENDERBUFFER , DEPTH24_STENCIL8 , fboWidth , fboHeight ) ; } framebufferRenderbuffer ( FRAMEBUFFER , DEPTH_ATTACHMENT , RENDERBUFFER , glDepthStencil . get ( 0 ) ) ; framebufferRenderbuffer ( FRAMEBUFFER , STENCIL_ATTACHMENT , RENDERBUFFER , glDepthStencil . get ( 0 ) ) ; } else { if ( 0 < depthBits ) { int depthComponent = DEPTH_COMPONENT16 ; if ( depthBits == 32 ) { depthComponent = DEPTH_COMPONENT32 ; } else if ( depthBits == 24 ) { depthComponent = DEPTH_COMPONENT24 ; } else if ( depthBits == 16 ) { depthComponent = DEPTH_COMPONENT16 ; } genRenderbuffers ( 1 , glDepth ) ; bindRenderbuffer ( RENDERBUFFER , glDepth . get ( 0 ) ) ; if ( multisample ) { renderbufferStorageMultisample ( RENDERBUFFER , numSamples , depthComponent , fboWidth , fboHeight ) ; } else { renderbufferStorage ( RENDERBUFFER , depthComponent , fboWidth , fboHeight ) ; } framebufferRenderbuffer ( FRAMEBUFFER , DEPTH_ATTACHMENT , RENDERBUFFER , glDepth . get ( 0 ) ) ; } if ( 0 < stencilBits ) { int stencilIndex = STENCIL_INDEX1 ; if ( stencilBits == 8 ) { stencilIndex = STENCIL_INDEX8 ; } else if ( stencilBits == 4 ) { stencilIndex = STENCIL_INDEX4 ; } else if ( stencilBits == 1 ) { stencilIndex = STENCIL_INDEX1 ; } genRenderbuffers ( 1 , glStencil ) ; bindRenderbuffer ( RENDERBUFFER , glStencil . get ( 0 ) ) ; if ( multisample ) { renderbufferStorageMultisample ( RENDERBUFFER , numSamples , stencilIndex , fboWidth , fboHeight ) ; } else { renderbufferStorage ( RENDERBUFFER , stencilIndex , fboWidth , fboHeight ) ; } framebufferRenderbuffer ( FRAMEBUFFER , STENCIL_ATTACHMENT , RENDERBUFFER , glStencil . get ( 0 ) ) ; } } validateFramebuffer ( ) ; clearDepth ( 1 ) ; clearStencil ( 0 ) ; int argb = pg . backgroundColor ; float a = ( ( argb > > 24 ) & 0xff ) / 255.0f ; float r = ( ( argb > > 16 ) & 0xff ) / 255.0f ; float g = ( ( argb > > 8 ) & 0xff ) / 255.0f ; float b = ( ( argb ) & 0xff ) / 255.0f ; clearColor ( r , g , b , a ) ; clear ( DEPTH_BUFFER_BIT | STENCIL_BUFFER_BIT | COLOR_BUFFER_BIT ) ; bindFramebufferImpl ( FRAMEBUFFER , 0 ) ; fboLayerCreated = true ; } protected int createEmptyContext ( ) { return - 1 ; } protected int getCurrentContext ( ) { return glContext ; } protected boolean contextIsCurrent ( int other ) { return other == - 1 || other == glContext ; } protected void enableTexturing ( int target ) { if ( target == TEXTURE_2D ) { texturingTargets [ 0 ] = true ; } else if ( target == TEXTURE_RECTANGLE ) { texturingTargets [ 1 ] = true ; } } protected void disableTexturing ( int target ) { if ( target == TEXTURE_2D ) { texturingTargets [ 0 ] = false ; } else if ( target == TEXTURE_RECTANGLE ) { texturingTargets [ 1 ] = false ; } } protected boolean texturingIsEnabled ( int target ) { if ( target == TEXTURE_2D ) { return texturingTargets [ 0 ] ; } else if ( target == TEXTURE_RECTANGLE ) { return texturingTargets [ 1 ] ; } else { return false ; } } protected boolean textureIsBound ( int target , int id ) { if ( boundTextures == null ) return false ; if ( target == TEXTURE_2D ) { return boundTextures [ activeTexUnit ] [ 0 ] == id ; } else if ( target == TEXTURE_RECTANGLE ) { return boundTextures [ activeTexUnit ] [ 1 ] == id ; } else { return false ; } } protected void initTexture ( int target , int format , int width , int height ) { initTexture ( target , format , width , height , 0 ) ; } protected void initTexture ( int target , int format , int width , int height , int initColor ) { int [ ] glcolor = new int [ 16 * 16 ] ; Arrays . fill ( glcolor , javaToNativeARGB ( initColor ) ) ; IntBuffer texels = allocateDirectIntBuffer ( 16 * 16 ) ; texels . put ( glcolor ) ; texels . rewind ( ) ; for ( int y = 0 ; y < height ; y += 16 ) { int h = PApplet . min ( 16 , height - y ) ; for ( int x = 0 ; x < width ; x += 16 ) { int w = PApplet . min ( 16 , width - x ) ; texSubImage2D ( target , 0 , x , y , w , h , format , UNSIGNED_BYTE , texels ) ; } } } protected void copyToTexture ( int target , int format , int id , int x , int y , int w , int h , int [ ] buffer ) { copyToTexture ( target , format , id , x , y , w , h , IntBuffer . wrap ( buffer ) ) ; } protected void copyToTexture ( int target , int format , int id , int x , int y , int w , int h , IntBuffer buffer ) { activeTexture ( TEXTURE0 ) ; boolean enabledTex = false ; if ( ! texturingIsEnabled ( target ) ) { enableTexturing ( target ) ; enabledTex = true ; } bindTexture ( target , id ) ; texSubImage2D ( target , 0 , x , y , w , h , format , UNSIGNED_BYTE , buffer ) ; bindTexture ( target , 0 ) ; if ( enabledTex ) { disableTexturing ( target ) ; } } public void drawTexture ( int target , int id , int width , int height , int X0 , int Y0 , int X1 , int Y1 ) { drawTexture ( target , id , width , height , 0 , 0 , width , height , X0 , Y0 , X1 , Y1 , X0 , Y0 , X1 , Y1 ) ; } public void drawTexture ( int target , int id , int texW , int texH , int viewX , int viewY , int scrW , int scrH , int texX0 , int texY0 , int texX1 , int texY1 , int scrX0 , int scrY0 , int scrX1 , int scrY1 ) { if ( target == TEXTURE_2D ) { drawTexture2D ( id , texW , texH , viewX , viewY , scrW , scrH , texX0 , texY0 , texX1 , texY1 , scrX0 , scrY0 , scrX1 , scrY1 ) ; } else if ( target == TEXTURE_RECTANGLE ) { drawTextureRect ( id , texW , texH , viewX , viewY , scrW , scrH , texX0 , texY0 , texX1 , texY1 , scrX0 , scrY0 , scrX1 , scrY1 ) ; } } protected PGL initTex2DShader ( ) { PGL ppgl = primaryPGL ? this : pg . getPrimaryPGL ( ) ; if ( ! ppgl . loadedTex2DShader || ppgl . tex2DShaderContext != ppgl . glContext ) { String vertSource = PApplet . join ( texVertShaderSource , "\n" ) ; String fragSource = PApplet . join ( tex2DFragShaderSource , "\n" ) ; ppgl . tex2DVertShader = createShader ( VERTEX_SHADER , vertSource ) ; ppgl . tex2DFragShader = createShader ( FRAGMENT_SHADER , fragSource ) ; if ( 0 < ppgl . tex2DVertShader && 0 < ppgl . tex2DFragShader ) { ppgl . tex2DShaderProgram = createProgram ( ppgl . tex2DVertShader , ppgl . tex2DFragShader ) ; } if ( 0 < ppgl . tex2DShaderProgram ) { ppgl . tex2DVertLoc = getAttribLocation ( ppgl . tex2DShaderProgram , "position" ) ; ppgl . tex2DTCoordLoc = getAttribLocation ( ppgl . tex2DShaderProgram , "texCoord" ) ; ppgl . tex2DSamplerLoc = getUniformLocation ( ppgl . tex2DShaderProgram , "texMap" ) ; } ppgl . loadedTex2DShader = true ; ppgl . tex2DShaderContext = ppgl . glContext ; genBuffers ( 1 , intBuffer ) ; ppgl . tex2DGeoVBO = intBuffer . get ( 0 ) ; bindBuffer ( ARRAY_BUFFER , ppgl . tex2DGeoVBO ) ; bufferData ( ARRAY_BUFFER , 16 * SIZEOF_FLOAT , null , STATIC_DRAW ) ; } if ( texData == null ) { texData = allocateDirectFloatBuffer ( texCoords . length ) ; } return ppgl ; } protected void drawTexture2D ( int id , int texW , int texH , int viewX , int viewY , int scrW , int scrH , int texX0 , int texY0 , int texX1 , int texY1 , int scrX0 , int scrY0 , int scrX1 , int scrY1 ) { PGL ppgl = initTex2DShader ( ) ; if ( 0 < ppgl . tex2DShaderProgram ) { boolean depthTest = getDepthTest ( ) ; disable ( DEPTH_TEST ) ; boolean depthMask = getDepthWriteMask ( ) ; depthMask ( false ) ; viewBuffer . rewind ( ) ; getIntegerv ( VIEWPORT , viewBuffer ) ; viewport ( viewX , viewY , scrW , scrH ) ; useProgram ( ppgl . tex2DShaderProgram ) ; enableVertexAttribArray ( ppgl . tex2DVertLoc ) ; enableVertexAttribArray ( ppgl . tex2DTCoordLoc ) ; texCoords [ 0 ] = 2 * ( float ) scrX0 / scrW - 1 ; texCoords [ 1 ] = 2 * ( float ) scrY0 / scrH - 1 ; texCoords [ 2 ] = ( float ) texX0 / texW ; texCoords [ 3 ] = ( float ) texY0 / texH ; texCoords [ 4 ] = 2 * ( float ) scrX1 / scrW - 1 ; texCoords [ 5 ] = 2 * ( float ) scrY0 / scrH - 1 ; texCoords [ 6 ] = ( float ) texX1 / texW ; texCoords [ 7 ] = ( float ) texY0 / texH ; texCoords [ 8 ] = 2 * ( float ) scrX0 / scrW - 1 ; texCoords [ 9 ] = 2 * ( float ) scrY1 / scrH - 1 ; texCoords [ 10 ] = ( float ) texX0 / texW ; texCoords [ 11 ] = ( float ) texY1 / texH ; texCoords [ 12 ] = 2 * ( float ) scrX1 / scrW - 1 ; texCoords [ 13 ] = 2 * ( float ) scrY1 / scrH - 1 ; texCoords [ 14 ] = ( float ) texX1 / texW ; texCoords [ 15 ] = ( float ) texY1 / texH ; texData . rewind ( ) ; texData . put ( texCoords ) ; activeTexture ( TEXTURE0 ) ; boolean enabledTex = false ; if ( ! texturingIsEnabled ( TEXTURE_2D ) ) { enableTexturing ( TEXTURE_2D ) ; enabledTex = true ; } bindTexture ( TEXTURE_2D , id ) ; uniform1i ( ppgl . tex2DSamplerLoc , 0 ) ; texData . position ( 0 ) ; bindBuffer ( ARRAY_BUFFER , ppgl . tex2DGeoVBO ) ; bufferData ( ARRAY_BUFFER , 16 * SIZEOF_FLOAT , texData , STATIC_DRAW ) ; vertexAttribPointer ( ppgl . tex2DVertLoc , 2 , FLOAT , false , 4 * SIZEOF_FLOAT , 0 ) ; vertexAttribPointer ( ppgl . tex2DTCoordLoc , 2 , FLOAT , false , 4 * SIZEOF_FLOAT , 2 * SIZEOF_FLOAT ) ; drawArrays ( TRIANGLE_STRIP , 0 , 4 ) ; bindBuffer ( ARRAY_BUFFER , 0 ) ; bindTexture ( TEXTURE_2D , 0 ) ; if ( enabledTex ) { disableTexturing ( TEXTURE_2D ) ; } disableVertexAttribArray ( ppgl . tex2DVertLoc ) ; disableVertexAttribArray ( ppgl . tex2DTCoordLoc ) ; useProgram ( 0 ) ; if ( depthTest ) { enable ( DEPTH_TEST ) ; } else { disable ( DEPTH_TEST ) ; } depthMask ( depthMask ) ; viewport ( viewBuffer . get ( 0 ) , viewBuffer . get ( 1 ) , viewBuffer . get ( 2 ) , viewBuffer . get ( 3 ) ) ; } } protected PGL initTexRectShader ( ) { PGL ppgl = primaryPGL ? this : pg . getPrimaryPGL ( ) ; if ( ! ppgl . loadedTexRectShader || ppgl . texRectShaderContext != ppgl . glContext ) { String vertSource = PApplet . join ( texVertShaderSource , "\n" ) ; String fragSource = PApplet . join ( texRectFragShaderSource , "\n" ) ; ppgl . texRectVertShader = createShader ( VERTEX_SHADER , vertSource ) ; ppgl . texRectFragShader = createShader ( FRAGMENT_SHADER , fragSource ) ; if ( 0 < ppgl . texRectVertShader && 0 < ppgl . texRectFragShader ) { ppgl . texRectShaderProgram = createProgram ( ppgl . texRectVertShader , ppgl . texRectFragShader ) ; } if ( 0 < ppgl . texRectShaderProgram ) { ppgl . texRectVertLoc = getAttribLocation ( ppgl . texRectShaderProgram , "position" ) ; ppgl . texRectTCoordLoc = getAttribLocation ( ppgl . texRectShaderProgram , "texCoord" ) ; ppgl . texRectSamplerLoc = getUniformLocation ( ppgl . texRectShaderProgram , "texMap" ) ; } ppgl . loadedTexRectShader = true ; ppgl . texRectShaderContext = ppgl . glContext ; genBuffers ( 1 , intBuffer ) ; ppgl . texRectGeoVBO = intBuffer . get ( 0 ) ; bindBuffer ( ARRAY_BUFFER , ppgl . texRectGeoVBO ) ; bufferData ( ARRAY_BUFFER , 16 * SIZEOF_FLOAT , null , STATIC_DRAW ) ; } return ppgl ; } protected void drawTextureRect ( int id , int texW , int texH , int viewX , int viewY , int scrW , int scrH , int texX0 , int texY0 , int texX1 , int texY1 , int scrX0 , int scrY0 , int scrX1 , int scrY1 ) { PGL ppgl = initTexRectShader ( ) ; if ( texData == null ) { texData = allocateDirectFloatBuffer ( texCoords . length ) ; } if ( 0 < ppgl . texRectShaderProgram ) { boolean depthTest = getDepthTest ( ) ; disable ( DEPTH_TEST ) ; boolean depthMask = getDepthWriteMask ( ) ; depthMask ( false ) ; viewBuffer . rewind ( ) ; getIntegerv ( VIEWPORT , viewBuffer ) ; viewport ( viewX , viewY , scrW , scrH ) ; useProgram ( ppgl . texRectShaderProgram ) ; enableVertexAttribArray ( ppgl . texRectVertLoc ) ; enableVertexAttribArray ( ppgl . texRectTCoordLoc ) ; texCoords [ 0 ] = 2 * ( float ) scrX0 / scrW - 1 ; texCoords [ 1 ] = 2 * ( float ) scrY0 / scrH - 1 ; texCoords [ 2 ] = texX0 ; texCoords [ 3 ] = texY0 ; texCoords [ 4 ] = 2 * ( float ) scrX1 / scrW - 1 ; texCoords [ 5 ] = 2 * ( float ) scrY0 / scrH - 1 ; texCoords [ 6 ] = texX1 ; texCoords [ 7 ] = texY0 ; texCoords [ 8 ] = 2 * ( float ) scrX0 / scrW - 1 ; texCoords [ 9 ] = 2 * ( float ) scrY1 / scrH - 1 ; texCoords [ 10 ] = texX0 ; texCoords [ 11 ] = texY1 ; texCoords [ 12 ] = 2 * ( float ) scrX1 / scrW - 1 ; texCoords [ 13 ] = 2 * ( float ) scrY1 / scrH - 1 ; texCoords [ 14 ] = texX1 ; texCoords [ 15 ] = texY1 ; texData . rewind ( ) ; texData . put ( texCoords ) ; activeTexture ( TEXTURE0 ) ; boolean enabledTex = false ; if ( ! texturingIsEnabled ( TEXTURE_RECTANGLE ) ) { enableTexturing ( TEXTURE_RECTANGLE ) ; enabledTex = true ; } bindTexture ( TEXTURE_RECTANGLE , id ) ; uniform1i ( ppgl . texRectSamplerLoc , 0 ) ; texData . position ( 0 ) ; bindBuffer ( ARRAY_BUFFER , ppgl . texRectGeoVBO ) ; bufferData ( ARRAY_BUFFER , 16 * SIZEOF_FLOAT , texData , STATIC_DRAW ) ; vertexAttribPointer ( ppgl . texRectVertLoc , 2 , FLOAT , false , 4 * SIZEOF_FLOAT , 0 ) ; vertexAttribPointer ( ppgl . texRectTCoordLoc , 2 , FLOAT , false , 4 * SIZEOF_FLOAT , 2 * SIZEOF_FLOAT ) ; drawArrays ( TRIANGLE_STRIP , 0 , 4 ) ; bindBuffer ( ARRAY_BUFFER , 0 ) ; bindTexture ( TEXTURE_RECTANGLE , 0 ) ; if ( enabledTex ) { disableTexturing ( TEXTURE_RECTANGLE ) ; } disableVertexAttribArray ( ppgl . texRectVertLoc ) ; disableVertexAttribArray ( ppgl . texRectTCoordLoc ) ; useProgram ( 0 ) ; if ( depthTest ) { enable ( DEPTH_TEST ) ; } else { disable ( DEPTH_TEST ) ; } depthMask ( depthMask ) ; viewport ( viewBuffer . get ( 0 ) , viewBuffer . get ( 1 ) , viewBuffer . get ( 2 ) , viewBuffer . get ( 3 ) ) ; } } protected int getColorValue ( int scrX , int scrY ) { if ( colorBuffer == null ) { colorBuffer = IntBuffer . allocate ( 1 ) ; } colorBuffer . rewind ( ) ; readPixels ( scrX , pg . height - scrY - 1 , 1 , 1 , RGBA , UNSIGNED_BYTE , colorBuffer ) ; return colorBuffer . get ( ) ; } protected float getDepthValue ( int scrX , int scrY ) { if ( depthBuffer == null ) { depthBuffer = FloatBuffer . allocate ( 1 ) ; } depthBuffer . rewind ( ) ; readPixels ( scrX , pg . height - scrY - 1 , 1 , 1 , DEPTH_COMPONENT , FLOAT , depthBuffer ) ; return depthBuffer . get ( 0 ) ; } protected byte getStencilValue ( int scrX , int scrY ) { if ( stencilBuffer == null ) { stencilBuffer = ByteBuffer . allocate ( 1 ) ; } readPixels ( scrX , pg . height - scrY - 1 , 1 , 1 , STENCIL_INDEX , UNSIGNED_BYTE , stencilBuffer ) ; return stencilBuffer . get ( 0 ) ; } protected static boolean isPowerOfTwo ( int val ) { return ( val & ( val - 1 ) ) == 0 ; } protected static int nextPowerOfTwo ( int val ) { int ret = 1 ; while ( ret < val ) ret <<= 1 ; return ret ; } protected static int nativeToJavaARGB ( int color ) { if ( BIG_ENDIAN ) { return ( color > > > 8 ) | ( ( color < < 24 ) & 0xFF000000 ) ; } else { return ( ( color & 0xFF ) < < 16 ) | ( ( color & 0xFF0000 ) > > 16 ) | ( color & 0xFF00FF00 ) ; } } protected static void nativeToJavaARGB ( int [ ] pixels , int width , int height ) { int index = 0 ; int yindex = ( height - 1 ) * width ; for ( int y = 0 ; y < height / 2 ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { int pixy = pixels [ yindex ] ; int pixi = pixels [ index ] ; if ( BIG_ENDIAN ) { pixels [ index ] = ( pixy > > > 8 ) | ( ( pixy < < 24 ) & 0xFF000000 ) ; pixels [ yindex ] = ( pixi > > > 8 ) | ( ( pixi < < 24 ) & 0xFF000000 ) ; } else { pixels [ index ] = ( ( pixy & 0xFF ) < < 16 ) | ( ( pixy & 0xFF0000 ) > > 16 ) | ( pixy & 0xFF00FF00 ) ; pixels [ yindex ] = ( ( pixi & 0xFF ) < < 16 ) | ( ( pixi & 0xFF0000 ) > > 16 ) | ( pixi & 0xFF00FF00 ) ; } index ++ ; yindex ++ ; } yindex -= width * 2 ; } if ( ( height % 2 ) == 1 ) { index = ( height / 2 ) * width ; for ( int x = 0 ; x < width ; x ++ ) { int pixi = pixels [ index ] ; if ( BIG_ENDIAN ) { pixels [ index ] = ( pixi > > > 8 ) | ( ( pixi < < 24 ) & 0xFF000000 ) ; } else { pixels [ index ] = ( ( pixi & 0xFF ) < < 16 ) | ( ( pixi & 0xFF0000 ) > > 16 ) | ( pixi & 0xFF00FF00 ) ; } index ++ ; } } } protected static int nativeToJavaRGB ( int color ) { if ( BIG_ENDIAN ) { return ( color > > > 8 ) | 0xFF000000 ; } else { return ( ( color & 0xFF ) < < 16 ) | ( ( color & 0xFF0000 ) > > 16 ) | ( color & 0xFF00FF00 ) | 0xFF000000 ; } } protected static void nativeToJavaRGB ( int [ ] pixels , int width , int height ) { int index = 0 ; int yindex = ( height - 1 ) * width ; for ( int y = 0 ; y < height / 2 ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { int pixy = pixels [ yindex ] ; int pixi = pixels [ index ] ; if ( BIG_ENDIAN ) { pixels [ index ] = ( pixy > > > 8 ) | 0xFF000000 ; pixels [ yindex ] = ( pixi > > > 8 ) | 0xFF000000 ; } else { pixels [ index ] = ( ( pixy & 0xFF ) < < 16 ) | ( ( pixy & 0xFF0000 ) > > 16 ) | ( pixy & 0xFF00FF00 ) | 0xFF000000 ; pixels [ yindex ] = ( ( pixi & 0xFF ) < < 16 ) | ( ( pixi & 0xFF0000 ) > > 16 ) | ( pixi & 0xFF00FF00 ) | 0xFF000000 ; } index ++ ; yindex ++ ; } yindex -= width * 2 ; } if ( ( height % 2 ) == 1 ) { index = ( height / 2 ) * width ; for ( int x = 0 ; x < width ; x ++ ) { int pixi = pixels [ index ] ; if ( BIG_ENDIAN ) { pixels [ index ] = ( pixi > > > 8 ) | 0xFF000000 ; } else { pixels [ index ] = ( ( pixi & 0xFF ) < < 16 ) | ( ( pixi & 0xFF0000 ) > > 16 ) | ( pixi & 0xFF00FF00 ) | 0xFF000000 ; } index ++ ; } } } protected static int javaToNativeARGB ( int color ) { if ( BIG_ENDIAN ) { return ( ( color > > 24 ) & 0xFF ) | ( ( color < < 8 ) & 0xFFFFFF00 ) ; } else { return ( color & 0xFF000000 ) | ( ( color < < 16 ) & 0xFF0000 ) | ( color & 0xFF00 ) | ( ( color > > 16 ) & 0xFF ) ; } } protected static void javaToNativeARGB ( int [ ] pixels , int width , int height ) { int index = 0 ; int yindex = ( height - 1 ) * width ; for ( int y = 0 ; y < height / 2 ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { int pixy = pixels [ yindex ] ; int pixi = pixels [ index ] ; if ( BIG_ENDIAN ) { pixels [ index ] = ( ( pixy > > 24 ) & 0xFF ) | ( ( pixy < < 8 ) & 0xFFFFFF00 ) ; pixels [ yindex ] = ( ( pixi > > 24 ) & 0xFF ) | ( ( pixi < < 8 ) & 0xFFFFFF00 ) ; } else { pixels [ index ] = ( pixy & 0xFF000000 ) | ( ( pixy < < 16 ) & 0xFF0000 ) | ( pixy & 0xFF00 ) | ( ( pixy > > 16 ) & 0xFF ) ; pixels [ yindex ] = ( pixi & 0xFF000000 ) | ( ( pixi < < 16 ) & 0xFF0000 ) | ( pixi & 0xFF00 ) | ( ( pixi > > 16 ) & 0xFF ) ; } index ++ ; yindex ++ ; } yindex -= width * 2 ; } if ( ( height % 2 ) == 1 ) { index = ( height / 2 ) * width ; for ( int x = 0 ; x < width ; x ++ ) { int pixi = pixels [ index ] ; if ( BIG_ENDIAN ) { pixels [ index ] = ( ( pixi > > 24 ) & 0xFF ) | ( ( pixi < < 8 ) & 0xFFFFFF00 ) ; } else { pixels [ index ] = ( pixi & 0xFF000000 ) | ( ( pixi < < 16 ) & 0xFF0000 ) | ( pixi & 0xFF00 ) | ( ( pixi > > 16 ) & 0xFF ) ; } index ++ ; } } } protected static int javaToNativeRGB ( int color ) { if ( BIG_ENDIAN ) { return 0xFF | ( ( color < < 8 ) & 0xFFFFFF00 ) ; } else { return 0xFF000000 | ( ( color < < 16 ) & 0xFF0000 ) | ( color & 0xFF00 ) | ( ( color > > 16 ) & 0xFF ) ; } } protected static void javaToNativeRGB ( int [ ] pixels , int width , int height ) { int index = 0 ; int yindex = ( height - 1 ) * width ; for ( int y = 0 ; y < height / 2 ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { int pixy = pixels [ yindex ] ; int pixi = pixels [ index ] ; if ( BIG_ENDIAN ) { pixels [ index ] = 0xFF | ( ( pixy < < 8 ) & 0xFFFFFF00 ) ; pixels [ yindex ] = 0xFF | ( ( pixi < < 8 ) & 0xFFFFFF00 ) ; } else { pixels [ index ] = 0xFF000000 | ( ( pixy < < 16 ) & 0xFF0000 ) | ( pixy & 0xFF00 ) | ( ( pixy > > 16 ) & 0xFF ) ; pixels [ yindex ] = 0xFF000000 | ( ( pixi < < 16 ) & 0xFF0000 ) | ( pixi & 0xFF00 ) | ( ( pixi > > 16 ) & 0xFF ) ; } index ++ ; yindex ++ ; } yindex -= width * 2 ; } if ( ( height % 2 ) == 1 ) { index = ( height / 2 ) * width ; for ( int x = 0 ; x < width ; x ++ ) { int pixi = pixels [ index ] ; if ( BIG_ENDIAN ) { pixels [ index ] = 0xFF | ( ( pixi < < 8 ) & 0xFFFFFF00 ) ; } else { pixels [ index ] = 0xFF000000 | ( ( pixi < < 16 ) & 0xFF0000 ) | ( pixi & 0xFF00 ) | ( ( pixi > > 16 ) & 0xFF ) ; } index ++ ; } } } protected static int qualityToSamples ( int quality ) { if ( quality <= 1 ) { return 1 ; } else { int n = 2 * ( quality / 2 ) ; return n ; } } protected String [ ] loadVertexShader ( String filename ) { return pg . parent . loadStrings ( filename ) ; } protected String [ ] loadFragmentShader ( String filename ) { return pg . parent . loadStrings ( filename ) ; } protected String [ ] loadFragmentShader ( URL url ) { try { return PApplet . loadStrings ( url . openStream ( ) ) ; } catch ( IOException e ) { PGraphics . showException ( "Cannot load fragment shader " + url . getFile ( ) ) ; } return null ; } protected String [ ] loadVertexShader ( URL url ) { try { return PApplet . loadStrings ( url . openStream ( ) ) ; } catch ( IOException e ) { PGraphics . showException ( "Cannot load vertex shader " + url . getFile ( ) ) ; } return null ; } protected String [ ] loadVertexShader ( String filename , int version ) { return loadVertexShader ( filename ) ; } protected String [ ] loadFragmentShader ( String filename , int version ) { return loadFragmentShader ( filename ) ; } protected String [ ] loadFragmentShader ( URL url , int version ) { return loadFragmentShader ( url ) ; } protected String [ ] loadVertexShader ( URL url , int version ) { return loadVertexShader ( url ) ; } protected static String [ ] convertFragmentSource ( String [ ] fragSrc0 , int version0 , int version1 ) { if ( version0 == 120 && version1 == 150 ) { String [ ] fragSrc = new String [ fragSrc0 . length + 2 ] ; fragSrc [ 0 ] = "#version 150" ; fragSrc [ 1 ] = "out vec4 fragColor;" ; for ( int i = 0 ; i < fragSrc0 . length ; i ++ ) { String line = fragSrc0 [ i ] ; line = line . replace ( "varying" , "in" ) ; line = line . replace ( "attribute" , "in" ) ; line = line . replace ( "gl_FragColor" , "fragColor" ) ; line = line . replace ( "texture" , "texMap" ) ; line = line . replace ( "texMap2D(" , "texture(" ) ; line = line . replace ( "texMap2DRect(" , "texture(" ) ; fragSrc [ i + 2 ] = line ; } return fragSrc ; } return fragSrc0 ; } protected static String [ ] convertVertexSource ( String [ ] vertSrc0 , int version0 , int version1 ) { if ( version0 == 120 && version1 == 150 ) { String [ ] vertSrc = new String [ vertSrc0 . length + 1 ] ; vertSrc [ 0 ] = "#version 150" ; for ( int i = 0 ; i < vertSrc0 . length ; i ++ ) { String line = vertSrc0 [ i ] ; line = line . replace ( "attribute" , "in" ) ; line = line . replace ( "varying" , "out" ) ; vertSrc [ i + 1 ] = line ; } return vertSrc ; } return vertSrc0 ; } protected int createShader ( int shaderType , String source ) { int shader = createShader ( shaderType ) ; if ( shader != 0 ) { shaderSource ( shader , source ) ; compileShader ( shader ) ; if ( ! compiled ( shader ) ) { System . err . println ( "Could not compile shader " + shaderType + ":" ) ; System . err . println ( getShaderInfoLog ( shader ) ) ; deleteShader ( shader ) ; shader = 0 ; } } return shader ; } protected int createProgram ( int vertexShader , int fragmentShader ) { int program = createProgram ( ) ; if ( program != 0 ) { attachShader ( program , vertexShader ) ; attachShader ( program , fragmentShader ) ; linkProgram ( program ) ; if ( ! linked ( program ) ) { System . err . println ( "Could not link program: " ) ; System . err . println ( getProgramInfoLog ( program ) ) ; deleteProgram ( program ) ; program = 0 ; } } return program ; } protected boolean compiled ( int shader ) { intBuffer . rewind ( ) ; getShaderiv ( shader , COMPILE_STATUS , intBuffer ) ; return intBuffer . get ( 0 ) == 0 ? false : true ; } protected boolean linked ( int program ) { intBuffer . rewind ( ) ; getProgramiv ( program , LINK_STATUS , intBuffer ) ; return intBuffer . get ( 0 ) == 0 ? false : true ; } protected boolean validateFramebuffer ( ) { int status = checkFramebufferStatus ( FRAMEBUFFER ) ; if ( status == FRAMEBUFFER_COMPLETE ) { return true ; } else if ( status == FRAMEBUFFER_INCOMPLETE_ATTACHMENT ) { System . err . println ( String . format ( FRAMEBUFFER_ERROR , "incomplete attachment" ) ) ; } else if ( status == FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT ) { System . err . println ( String . format ( FRAMEBUFFER_ERROR , "incomplete missing attachment" ) ) ; } else if ( status == FRAMEBUFFER_INCOMPLETE_DIMENSIONS ) { System . err . println ( String . format ( FRAMEBUFFER_ERROR , "incomplete dimensions" ) ) ; } else if ( status == FRAMEBUFFER_INCOMPLETE_FORMATS ) { System . err . println ( String . format ( FRAMEBUFFER_ERROR , "incomplete formats" ) ) ; } else if ( status == FRAMEBUFFER_UNSUPPORTED ) { System . err . println ( String . format ( FRAMEBUFFER_ERROR , "framebuffer unsupported" ) ) ; } else { System . err . println ( String . format ( FRAMEBUFFER_ERROR , "unknown error" ) ) ; } return false ; } protected int [ ] getGLVersion ( ) { String version = getString ( VERSION ) . trim ( ) ; int [ ] res = { 0 , 0 , 0 } ; String [ ] parts = version . split ( " " ) ; for ( int i = 0 ; i < parts . length ; i ++ ) { if ( 0 < parts [ i ] . indexOf ( "." ) ) { String nums [ ] = parts [ i ] . split ( "\\." ) ; try { res [ 0 ] = Integer . parseInt ( nums [ 0 ] ) ; } catch ( NumberFormatException e ) { } if ( 1 < nums . length ) { try { res [ 1 ] = Integer . parseInt ( nums [ 1 ] ) ; } catch ( NumberFormatException e ) { } } if ( 2 < nums . length ) { try { res [ 2 ] = Integer . parseInt ( nums [ 2 ] ) ; } catch ( NumberFormatException e ) { } } break ; } } return res ; } protected boolean hasFBOs ( ) { int major = getGLVersion ( ) [ 0 ] ; if ( major < 2 ) { String ext = getString ( EXTENSIONS ) ; return ext . indexOf ( "_framebuffer_object" ) != - 1 && ext . indexOf ( "_vertex_shader" ) != - 1 && ext . indexOf ( "_shader_objects" ) != - 1 && ext . indexOf ( "_shading_language" ) != - 1 ; } else { return true ; } } protected boolean hasShaders ( ) { int major = getGLVersion ( ) [ 0 ] ; if ( major < 2 ) { String ext = getString ( EXTENSIONS ) ; return ext . indexOf ( "_fragment_shader" ) != - 1 && ext . indexOf ( "_vertex_shader" ) != - 1 && ext . indexOf ( "_shader_objects" ) != - 1 && ext . indexOf ( "_shading_language" ) != - 1 ; } else { return true ; } } protected boolean hasNpotTexSupport ( ) { int major = getGLVersion ( ) [ 0 ] ; if ( major < 3 ) { String ext = getString ( EXTENSIONS ) ; return - 1 < ext . indexOf ( "_texture_non_power_of_two" ) ; } else { return true ; } } protected boolean hasAutoMipmapGenSupport ( ) { int major = getGLVersion ( ) [ 0 ] ; if ( major < 3 ) { String ext = getString ( EXTENSIONS ) ; return - 1 < ext . indexOf ( "_generate_mipmap" ) ; } else { return true ; } } protected boolean hasFboMultisampleSupport ( ) { int major = getGLVersion ( ) [ 0 ] ; if ( major < 3 ) { String ext = getString ( EXTENSIONS ) ; return - 1 < ext . indexOf ( "_framebuffer_multisample" ) ; } else { return true ; } } protected boolean hasPackedDepthStencilSupport ( ) { int major = getGLVersion ( ) [ 0 ] ; if ( major < 3 ) { String ext = getString ( EXTENSIONS ) ; return - 1 < ext . indexOf ( "_packed_depth_stencil" ) ; } else { return true ; } } protected boolean hasAnisoSamplingSupport ( ) { int major = getGLVersion ( ) [ 0 ] ; if ( major < 3 ) { String ext = getString ( EXTENSIONS ) ; return - 1 < ext . indexOf ( "_texture_filter_anisotropic" ) ; } else { return true ; } } protected int maxSamples ( ) { intBuffer . rewind ( ) ; getIntegerv ( MAX_SAMPLES , intBuffer ) ; return intBuffer . get ( 0 ) ; } protected int getMaxTexUnits ( ) { intBuffer . rewind ( ) ; getIntegerv ( MAX_TEXTURE_IMAGE_UNITS , intBuffer ) ; return intBuffer . get ( 0 ) ; } protected static ByteBuffer allocateDirectByteBuffer ( int size ) { int bytes = PApplet . max ( MIN_DIRECT_BUFFER_SIZE , size ) * SIZEOF_BYTE ; return ByteBuffer . allocateDirect ( bytes ) . order ( ByteOrder . nativeOrder ( ) ) ; } protected static ByteBuffer allocateByteBuffer ( int size ) { if ( USE_DIRECT_BUFFERS ) { return allocateDirectByteBuffer ( size ) ; } else { return ByteBuffer . allocate ( size ) ; } } protected static ByteBuffer allocateByteBuffer ( byte [ ] arr ) { if ( USE_DIRECT_BUFFERS ) { ByteBuffer buf = allocateDirectByteBuffer ( arr . length ) ; buf . put ( arr ) ; buf . position ( 0 ) ; return buf ; } else { return ByteBuffer . wrap ( arr ) ; } } protected static ByteBuffer updateByteBuffer ( ByteBuffer buf , byte [ ] arr , boolean wrap ) { if ( USE_DIRECT_BUFFERS ) { if ( buf == null || buf . capacity ( ) < arr . length ) { buf = allocateDirectByteBuffer ( arr . length ) ; } buf . position ( 0 ) ; buf . put ( arr ) ; buf . rewind ( ) ; } else { if ( wrap ) { buf = ByteBuffer . wrap ( arr ) ; } else { if ( buf == null || buf . capacity ( ) < arr . length ) { buf = ByteBuffer . allocate ( arr . length ) ; } buf . position ( 0 ) ; buf . put ( arr ) ; buf . rewind ( ) ; } } return buf ; } protected static void updateByteBuffer ( ByteBuffer buf , byte [ ] arr , int offset , int size ) { if ( USE_DIRECT_BUFFERS || ( buf . hasArray ( ) && buf . array ( ) != arr ) ) { buf . position ( offset ) ; buf . put ( arr , offset , size ) ; buf . rewind ( ) ; } } protected static void getByteArray ( ByteBuffer buf , byte [ ] arr ) { if ( ! buf . hasArray ( ) || buf . array ( ) != arr ) { buf . position ( 0 ) ; buf . get ( arr ) ; buf . rewind ( ) ; } } protected static void putByteArray ( ByteBuffer buf , byte [ ] arr ) { if ( ! buf . hasArray ( ) || buf . array ( ) != arr ) { buf . position ( 0 ) ; buf . put ( arr ) ; buf . rewind ( ) ; } } protected static void fillByteBuffer ( ByteBuffer buf , int i0 , int i1 , byte val ) { int n = i1 - i0 ; byte [ ] temp = new byte [ n ] ; Arrays . fill ( temp , 0 , n , val ) ; buf . position ( i0 ) ; buf . put ( temp , 0 , n ) ; buf . rewind ( ) ; } protected static ShortBuffer allocateDirectShortBuffer ( int size ) { int bytes = PApplet . max ( MIN_DIRECT_BUFFER_SIZE , size ) * SIZEOF_SHORT ; return ByteBuffer . allocateDirect ( bytes ) . order ( ByteOrder . nativeOrder ( ) ) . asShortBuffer ( ) ; } protected static ShortBuffer allocateShortBuffer ( int size ) { if ( USE_DIRECT_BUFFERS ) { return allocateDirectShortBuffer ( size ) ; } else { return ShortBuffer . allocate ( size ) ; } } protected static ShortBuffer allocateShortBuffer ( short [ ] arr ) { if ( USE_DIRECT_BUFFERS ) { ShortBuffer buf = allocateDirectShortBuffer ( arr . length ) ; buf . put ( arr ) ; buf . position ( 0 ) ; return buf ; } else { return ShortBuffer . wrap ( arr ) ; } } protected static ShortBuffer updateShortBuffer ( ShortBuffer buf , short [ ] arr , boolean wrap ) { if ( USE_DIRECT_BUFFERS ) { if ( buf == null || buf . capacity ( ) < arr . length ) { buf = allocateDirectShortBuffer ( arr . length ) ; } buf . position ( 0 ) ; buf . put ( arr ) ; buf . rewind ( ) ; } else { if ( wrap ) { buf = ShortBuffer . wrap ( arr ) ; } else { if ( buf == null || buf . capacity ( ) < arr . length ) { buf = ShortBuffer . allocate ( arr . length ) ; } buf . position ( 0 ) ; buf . put ( arr ) ; buf . rewind ( ) ; } } return buf ; } protected static void updateShortBuffer ( ShortBuffer buf , short [ ] arr , int offset , int size ) { if ( USE_DIRECT_BUFFERS || ( buf . hasArray ( ) && buf . array ( ) != arr ) ) { buf . position ( offset ) ; buf . put ( arr , offset , size ) ; buf . rewind ( ) ; } } protected static void getShortArray ( ShortBuffer buf , short [ ] arr ) { if ( ! buf . hasArray ( ) || buf . array ( ) != arr ) { buf . position ( 0 ) ; buf . get ( arr ) ; buf . rewind ( ) ; } } protected static void putShortArray ( ShortBuffer buf , short [ ] arr ) { if ( ! buf . hasArray ( ) || buf . array ( ) != arr ) { buf . position ( 0 ) ; buf . put ( arr ) ; buf . rewind ( ) ; } } protected static void fillShortBuffer ( ShortBuffer buf , int i0 , int i1 , short val ) { int n = i1 - i0 ; short [ ] temp = new short [ n ] ; Arrays . fill ( temp , 0 , n , val ) ; buf . position ( i0 ) ; buf . put ( temp , 0 , n ) ; buf . rewind ( ) ; } protected static IntBuffer allocateDirectIntBuffer ( int size ) { int bytes = PApplet . max ( MIN_DIRECT_BUFFER_SIZE , size ) * SIZEOF_INT ; return ByteBuffer . allocateDirect ( bytes ) . order ( ByteOrder . nativeOrder ( ) ) . asIntBuffer ( ) ; } protected static IntBuffer allocateIntBuffer ( int size ) { if ( USE_DIRECT_BUFFERS ) { return allocateDirectIntBuffer ( size ) ; } else { return IntBuffer . allocate ( size ) ; } } protected static IntBuffer allocateIntBuffer ( int [ ] arr ) { if ( USE_DIRECT_BUFFERS ) { IntBuffer buf = allocateDirectIntBuffer ( arr . length ) ; buf . put ( arr ) ; buf . position ( 0 ) ; return buf ; } else { return IntBuffer . wrap ( arr ) ; } } protected static IntBuffer updateIntBuffer ( IntBuffer buf , int [ ] arr , boolean wrap ) { if ( USE_DIRECT_BUFFERS ) { if ( buf == null || buf . capacity ( ) < arr . length ) { buf = allocateDirectIntBuffer ( arr . length ) ; } buf . position ( 0 ) ; buf . put ( arr ) ; buf . rewind ( ) ; } else { if ( wrap ) { buf = IntBuffer . wrap ( arr ) ; } else { if ( buf == null || buf . capacity ( ) < arr . length ) { buf = IntBuffer . allocate ( arr . length ) ; } buf . position ( 0 ) ; buf . put ( arr ) ; buf . rewind ( ) ; } } return buf ; } protected static void updateIntBuffer ( IntBuffer buf , int [ ] arr , int offset , int size ) { if ( USE_DIRECT_BUFFERS || ( buf . hasArray ( ) && buf . array ( ) != arr ) ) { buf . position ( offset ) ; buf . put ( arr , offset , size ) ; buf . rewind ( ) ; } } protected static void getIntArray ( IntBuffer buf , int [ ] arr ) { if ( ! buf . hasArray ( ) || buf . array ( ) != arr ) { buf . position ( 0 ) ; buf . get ( arr ) ; buf . rewind ( ) ; } } protected static void putIntArray ( IntBuffer buf , int [ ] arr ) { if ( ! buf . hasArray ( ) || buf . array ( ) != arr ) { buf . position ( 0 ) ; buf . put ( arr ) ; buf . rewind ( ) ; } } protected static void fillIntBuffer ( IntBuffer buf , int i0 , int i1 , int val ) { int n = i1 - i0 ; int [ ] temp = new int [ n ] ; Arrays . fill ( temp , 0 , n , val ) ; buf . position ( i0 ) ; buf . put ( temp , 0 , n ) ; buf . rewind ( ) ; } protected static FloatBuffer allocateDirectFloatBuffer ( int size ) { int bytes = PApplet . max ( MIN_DIRECT_BUFFER_SIZE , size ) * SIZEOF_FLOAT ; return ByteBuffer . allocateDirect ( bytes ) . order ( ByteOrder . nativeOrder ( ) ) . asFloatBuffer ( ) ; } protected static FloatBuffer allocateFloatBuffer ( int size ) { if ( USE_DIRECT_BUFFERS ) { return allocateDirectFloatBuffer ( size ) ; } else { return FloatBuffer . allocate ( size ) ; } } protected static FloatBuffer allocateFloatBuffer ( float [ ] arr ) { if ( USE_DIRECT_BUFFERS ) { FloatBuffer buf = allocateDirectFloatBuffer ( arr . length ) ; buf . put ( arr ) ; buf . position ( 0 ) ; return buf ; } else { return FloatBuffer . wrap ( arr ) ; } } protected static FloatBuffer updateFloatBuffer ( FloatBuffer buf , float [ ] arr , boolean wrap ) { if ( USE_DIRECT_BUFFERS ) { if ( buf == null || buf . capacity ( ) < arr . length ) { buf = allocateDirectFloatBuffer ( arr . length ) ; } buf . position ( 0 ) ; buf . put ( arr ) ; buf . rewind ( ) ; } else { if ( wrap ) { buf = FloatBuffer . wrap ( arr ) ; } else { if ( buf == null || buf . capacity ( ) < arr . length ) { buf = FloatBuffer . allocate ( arr . length ) ; } buf . position ( 0 ) ; buf . put ( arr ) ; buf . rewind ( ) ; } } return buf ; } protected static void updateFloatBuffer ( FloatBuffer buf , float [ ] arr , int offset , int size ) { if ( USE_DIRECT_BUFFERS || ( buf . hasArray ( ) && buf . array ( ) != arr ) ) { buf . position ( offset ) ; buf . put ( arr , offset , size ) ; buf . rewind ( ) ; } } protected static void getFloatArray ( FloatBuffer buf , float [ ] arr ) { if ( ! buf . hasArray ( ) || buf . array ( ) != arr ) { buf . position ( 0 ) ; buf . get ( arr ) ; buf . rewind ( ) ; } } protected static void putFloatArray ( FloatBuffer buf , float [ ] arr ) { if ( ! buf . hasArray ( ) || buf . array ( ) != arr ) { buf . position ( 0 ) ; buf . put ( arr ) ; buf . rewind ( ) ; } } protected static void fillFloatBuffer ( FloatBuffer buf , int i0 , int i1 , float val ) { int n = i1 - i0 ; float [ ] temp = new float [ n ] ; Arrays . fill ( temp , 0 , n , val ) ; buf . position ( i0 ) ; buf . put ( temp , 0 , n ) ; buf . rewind ( ) ; } abstract protected int getFontAscent ( Object font ) ; abstract protected int getFontDescent ( Object font ) ; abstract protected int getTextWidth ( Object font , char [ ] buffer , int start , int stop ) ; abstract protected Object getDerivedFont ( Object font , float size ) ; protected abstract Tessellator createTessellator ( TessellatorCallback callback ) ; protected interface Tessellator { public void beginPolygon ( ) ; public void endPolygon ( ) ; public void setWindingRule ( int rule ) ; public void beginContour ( ) ; public void endContour ( ) ; public void addVertex ( double [ ] v ) ; } protected interface TessellatorCallback { public void begin ( int type ) ; public void end ( ) ; public void vertex ( Object data ) ; public void combine ( double [ ] coords , Object [ ] data , float [ ] weight , Object [ ] outData ) ; public void error ( int errnum ) ; } protected String tessError ( int err ) { return "" ; } protected static boolean SHAPE_TEXT_SUPPORTED ; protected static int SEG_MOVETO ; protected static int SEG_LINETO ; protected static int SEG_QUADTO ; protected static int SEG_CUBICTO ; protected static int SEG_CLOSE ; protected abstract FontOutline createFontOutline ( char ch , Object font ) ; protected interface FontOutline { public boolean isDone ( ) ; public int currentSegment ( float coords [ ] ) ; public void next ( ) ; } public static int FALSE ; public static int TRUE ; public static int INT ; public static int BYTE ; public static int SHORT ; public static int FLOAT ; public static int BOOL ; public static int UNSIGNED_INT ; public static int UNSIGNED_BYTE ; public static int UNSIGNED_SHORT ; public static int RGB ; public static int RGBA ; public static int ALPHA ; public static int LUMINANCE ; public static int LUMINANCE_ALPHA ; public static int UNSIGNED_SHORT_5_6_5 ; public static int UNSIGNED_SHORT_4_4_4_4 ; public static int UNSIGNED_SHORT_5_5_5_1 ; public static int RGBA4 ; public static int RGB5_A1 ; public static int RGB565 ; public static int RGB8 ; public static int RGBA8 ; public static int ALPHA8 ; public static int READ_ONLY ; public static int WRITE_ONLY ; public static int READ_WRITE ; public static int TESS_WINDING_NONZERO ; public static int TESS_WINDING_ODD ; public static int GENERATE_MIPMAP_HINT ; public static int FASTEST ; public static int NICEST ; public static int DONT_CARE ; public static int VENDOR ; public static int RENDERER ; public static int VERSION ; public static int EXTENSIONS ; public static int SHADING_LANGUAGE_VERSION ; public static int MAX_SAMPLES ; public static int SAMPLES ; public static int ALIASED_LINE_WIDTH_RANGE ; public static int ALIASED_POINT_SIZE_RANGE ; public static int DEPTH_BITS ; public static int STENCIL_BITS ; public static int CCW ; public static int CW ; public static int VIEWPORT ; public static int ARRAY_BUFFER ; public static int ELEMENT_ARRAY_BUFFER ; public static int MAX_VERTEX_ATTRIBS ; public static int STATIC_DRAW ; public static int DYNAMIC_DRAW ; public static int STREAM_DRAW ; public static int BUFFER_SIZE ; public static int BUFFER_USAGE ; public static int POINTS ; public static int LINE_STRIP ; public static int LINE_LOOP ; public static int LINES ; public static int TRIANGLE_FAN ; public static int TRIANGLE_STRIP ; public static int TRIANGLES ; public static int CULL_FACE ; public static int FRONT ; public static int BACK ; public static int FRONT_AND_BACK ; public static int POLYGON_OFFSET_FILL ; public static int UNPACK_ALIGNMENT ; public static int PACK_ALIGNMENT ; public static int TEXTURE_2D ; public static int TEXTURE_RECTANGLE ; public static int TEXTURE_BINDING_2D ; public static int TEXTURE_BINDING_RECTANGLE ; public static int MAX_TEXTURE_SIZE ; public static int TEXTURE_MAX_ANISOTROPY ; public static int MAX_TEXTURE_MAX_ANISOTROPY ; public static int MAX_VERTEX_TEXTURE_IMAGE_UNITS ; public static int MAX_TEXTURE_IMAGE_UNITS ; public static int MAX_COMBINED_TEXTURE_IMAGE_UNITS ; public static int NUM_COMPRESSED_TEXTURE_FORMATS ; public static int COMPRESSED_TEXTURE_FORMATS ; public static int NEAREST ; public static int LINEAR ; public static int LINEAR_MIPMAP_NEAREST ; public static int LINEAR_MIPMAP_LINEAR ; public static int CLAMP_TO_EDGE ; public static int REPEAT ; public static int TEXTURE0 ; public static int TEXTURE1 ; public static int TEXTURE2 ; public static int TEXTURE3 ; public static int TEXTURE_MIN_FILTER ; public static int TEXTURE_MAG_FILTER ; public static int TEXTURE_WRAP_S ; public static int TEXTURE_WRAP_T ; public static int TEXTURE_WRAP_R ; public static int TEXTURE_CUBE_MAP ; public static int TEXTURE_CUBE_MAP_POSITIVE_X ; public static int TEXTURE_CUBE_MAP_POSITIVE_Y ; public static int TEXTURE_CUBE_MAP_POSITIVE_Z ; public static int TEXTURE_CUBE_MAP_NEGATIVE_X ; public static int TEXTURE_CUBE_MAP_NEGATIVE_Y ; public static int TEXTURE_CUBE_MAP_NEGATIVE_Z ; public static int VERTEX_SHADER ; public static int FRAGMENT_SHADER ; public static int INFO_LOG_LENGTH ; public static int SHADER_SOURCE_LENGTH ; public static int COMPILE_STATUS ; public static int LINK_STATUS ; public static int VALIDATE_STATUS ; public static int SHADER_TYPE ; public static int DELETE_STATUS ; public static int FLOAT_VEC2 ; public static int FLOAT_VEC3 ; public static int FLOAT_VEC4 ; public static int FLOAT_MAT2 ; public static int FLOAT_MAT3 ; public static int FLOAT_MAT4 ; public static int INT_VEC2 ; public static int INT_VEC3 ; public static int INT_VEC4 ; public static int BOOL_VEC2 ; public static int BOOL_VEC3 ; public static int BOOL_VEC4 ; public static int SAMPLER_2D ; public static int SAMPLER_CUBE ; public static int LOW_FLOAT ; public static int MEDIUM_FLOAT ; public static int HIGH_FLOAT ; public static int LOW_INT ; public static int MEDIUM_INT ; public static int HIGH_INT ; public static int CURRENT_VERTEX_ATTRIB ; public static int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING ; public static int VERTEX_ATTRIB_ARRAY_ENABLED ; public static int VERTEX_ATTRIB_ARRAY_SIZE ; public static int VERTEX_ATTRIB_ARRAY_STRIDE ; public static int VERTEX_ATTRIB_ARRAY_TYPE ; public static int VERTEX_ATTRIB_ARRAY_NORMALIZED ; public static int VERTEX_ATTRIB_ARRAY_POINTER ; public static int BLEND ; public static int ONE ; public static int ZERO ; public static int SRC_ALPHA ; public static int DST_ALPHA ; public static int ONE_MINUS_SRC_ALPHA ; public static int ONE_MINUS_DST_COLOR ; public static int ONE_MINUS_SRC_COLOR ; public static int DST_COLOR ; public static int SRC_COLOR ; public static int SAMPLE_ALPHA_TO_COVERAGE ; public static int SAMPLE_COVERAGE ; public static int KEEP ; public static int REPLACE ; public static int INCR ; public static int DECR ; public static int INVERT ; public static int INCR_WRAP ; public static int DECR_WRAP ; public static int NEVER ; public static int ALWAYS ; public static int EQUAL ; public static int LESS ; public static int LEQUAL ; public static int GREATER ; public static int GEQUAL ; public static int NOTEQUAL ; public static int FUNC_ADD ; public static int FUNC_MIN ; public static int FUNC_MAX ; public static int FUNC_REVERSE_SUBTRACT ; public static int FUNC_SUBTRACT ; public static int DITHER ; public static int CONSTANT_COLOR ; public static int CONSTANT_ALPHA ; public static int ONE_MINUS_CONSTANT_COLOR ; public static int ONE_MINUS_CONSTANT_ALPHA ; public static int SRC_ALPHA_SATURATE ; public static int SCISSOR_TEST ; public static int STENCIL_TEST ; public static int DEPTH_TEST ; public static int DEPTH_WRITEMASK ; public static int ALPHA_TEST ; public static int COLOR_BUFFER_BIT ; public static int DEPTH_BUFFER_BIT ; public static int STENCIL_BUFFER_BIT ; public static int FRAMEBUFFER ; public static int COLOR_ATTACHMENT0 ; public static int COLOR_ATTACHMENT1 ; public static int COLOR_ATTACHMENT2 ; public static int COLOR_ATTACHMENT3 ; public static int RENDERBUFFER ; public static int DEPTH_ATTACHMENT ; public static int STENCIL_ATTACHMENT ; public static int READ_FRAMEBUFFER ; public static int DRAW_FRAMEBUFFER ; public static int DEPTH24_STENCIL8 ; public static int DEPTH_COMPONENT ; public static int DEPTH_COMPONENT16 ; public static int DEPTH_COMPONENT24 ; public static int DEPTH_COMPONENT32 ; public static int STENCIL_INDEX ; public static int STENCIL_INDEX1 ; public static int STENCIL_INDEX4 ; public static int STENCIL_INDEX8 ; public static int DEPTH_STENCIL ; public static int FRAMEBUFFER_COMPLETE ; public static int FRAMEBUFFER_INCOMPLETE_ATTACHMENT ; public static int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT ; public static int FRAMEBUFFER_INCOMPLETE_DIMENSIONS ; public static int FRAMEBUFFER_INCOMPLETE_FORMATS ; public static int FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER ; public static int FRAMEBUFFER_INCOMPLETE_READ_BUFFER ; public static int FRAMEBUFFER_UNSUPPORTED ; public static int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE ; public static int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME ; public static int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL ; public static int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE ; public static int RENDERBUFFER_WIDTH ; public static int RENDERBUFFER_HEIGHT ; public static int RENDERBUFFER_RED_SIZE ; public static int RENDERBUFFER_GREEN_SIZE ; public static int RENDERBUFFER_BLUE_SIZE ; public static int RENDERBUFFER_ALPHA_SIZE ; public static int RENDERBUFFER_DEPTH_SIZE ; public static int RENDERBUFFER_STENCIL_SIZE ; public static int RENDERBUFFER_INTERNAL_FORMAT ; public static int MULTISAMPLE ; public static int POINT_SMOOTH ; public static int LINE_SMOOTH ; public static int POLYGON_SMOOTH ; public abstract void flush ( ) ; public abstract void finish ( ) ; public abstract void hint ( int target , int hint ) ; public abstract void enable ( int value ) ; public abstract void disable ( int value ) ; public abstract void getBooleanv ( int value , IntBuffer data ) ; public abstract void getIntegerv ( int value , IntBuffer data ) ; public abstract void getFloatv ( int value , FloatBuffer data ) ; public abstract boolean isEnabled ( int value ) ; public abstract String getString ( int name ) ; public abstract int getError ( ) ; public abstract String errorString ( int err ) ; public abstract void genBuffers ( int n , IntBuffer buffers ) ; public abstract void deleteBuffers ( int n , IntBuffer buffers ) ; public abstract void bindBuffer ( int target , int buffer ) ; public abstract void bufferData ( int target , int size , Buffer data , int usage ) ; public abstract void bufferSubData ( int target , int offset , int size , Buffer data ) ; public abstract void isBuffer ( int buffer ) ; public abstract void getBufferParameteriv ( int target , int value , IntBuffer data ) ; public abstract ByteBuffer mapBuffer ( int target , int access ) ; public abstract ByteBuffer mapBufferRange ( int target , int offset , int length , int access ) ; public abstract void unmapBuffer ( int target ) ; public abstract void depthRangef ( float n , float f ) ; public abstract void viewport ( int x , int y , int w , int h ) ; public void readPixels ( int x , int y , int width , int height , int format , int type , Buffer buffer ) { boolean pgCall = format != STENCIL_INDEX && format != DEPTH_COMPONENT && format != DEPTH_STENCIL ; if ( pgCall ) pg . beginReadPixels ( ) ; readPixelsImpl ( x , y , width , height , format , type , buffer ) ; if ( pgCall ) pg . endReadPixels ( ) ; } protected abstract void readPixelsImpl ( int x , int y , int width , int height , int format , int type , Buffer buffer ) ; public abstract void vertexAttrib1f ( int index , float value ) ; public abstract void vertexAttrib2f ( int index , float value0 , float value1 ) ; public abstract void vertexAttrib3f ( int index , float value0 , float value1 , float value2 ) ; public abstract void vertexAttrib4f ( int index , float value0 , float value1 , float value2 , float value3 ) ; public abstract void vertexAttrib1fv ( int index , FloatBuffer values ) ; public abstract void vertexAttrib2fv ( int index , FloatBuffer values ) ; public abstract void vertexAttrib3fv ( int index , FloatBuffer values ) ; public abstract void vertexAttri4fv ( int index , FloatBuffer values ) ; public abstract void vertexAttribPointer ( int index , int size , int type , boolean normalized , int stride , int offset ) ; public abstract void vertexAttribPointer ( int index , int size , int type , boolean normalized , int stride , Buffer data ) ; public abstract void enableVertexAttribArray ( int index ) ; public abstract void disableVertexAttribArray ( int index ) ; public abstract void drawArrays ( int mode , int first , int count ) ; public abstract void drawElements ( int mode , int count , int type , int offset ) ; public abstract void drawElements ( int mode , int count , int type , Buffer indices ) ; public abstract void lineWidth ( float width ) ; public abstract void frontFace ( int dir ) ; public abstract void cullFace ( int mode ) ; public abstract void polygonOffset ( float factor , float units ) ; public abstract void pixelStorei ( int pname , int param ) ; public abstract void texImage2D ( int target , int level , int internalFormat , int width , int height , int border , int format , int type , Buffer data ) ; public abstract void copyTexImage2D ( int target , int level , int internalFormat , int x , int y , int width , int height , int border ) ; public abstract void texSubImage2D ( int target , int level , int xOffset , int yOffset , int width , int height , int format , int type , Buffer data ) ; public abstract void copyTexSubImage2D ( int target , int level , int xOffset , int yOffset , int x , int y , int width , int height ) ; public abstract void compressedTexImage2D ( int target , int level , int internalFormat , int width , int height , int border , int imageSize , Buffer data ) ; public abstract void compressedTexSubImage2D ( int target , int level , int xOffset , int yOffset , int width , int height , int format , int imageSize , Buffer data ) ; public abstract void texParameteri ( int target , int pname , int param ) ; public abstract void texParameterf ( int target , int pname , float param ) ; public abstract void texParameteriv ( int target , int pname , IntBuffer params ) ; public abstract void texParameterfv ( int target , int pname , FloatBuffer params ) ; public abstract void generateMipmap ( int target ) ; public abstract void genTextures ( int n , IntBuffer textures ) ; public abstract void deleteTextures ( int n , IntBuffer textures ) ; public abstract void getTexParameteriv ( int target , int pname , IntBuffer params ) ; public abstract void getTexParameterfv ( int target , int pname , FloatBuffer params ) ; public abstract boolean isTexture ( int texture ) ; public void activeTexture ( int texture ) { activeTexUnit = texture - TEXTURE0 ; activeTextureImpl ( texture ) ; } protected abstract void activeTextureImpl ( int texture ) ; public void bindTexture ( int target , int texture ) { bindTextureImpl ( target , texture ) ; if ( boundTextures == null ) { maxTexUnits = getMaxTexUnits ( ) ; boundTextures = new int [ maxTexUnits ] [ 2 ] ; } if ( maxTexUnits <= activeTexUnit ) { throw new RuntimeException ( TEXUNIT_ERROR ) ; } if ( target == TEXTURE_2D ) { boundTextures [ activeTexUnit ] [ 0 ] = texture ; } else if ( target == TEXTURE_RECTANGLE ) { boundTextures [ activeTexUnit ] [ 1 ] = texture ; } } protected abstract void bindTextureImpl ( int target , int texture ) ; public abstract int createShader ( int type ) ; public abstract void shaderSource ( int shader , String source ) ; public abstract void compileShader ( int shader ) ; public abstract void releaseShaderCompiler ( ) ; public abstract void deleteShader ( int shader ) ; public abstract void shaderBinary ( int count , IntBuffer shaders , int binaryFormat , Buffer binary , int length ) ; public abstract int createProgram ( ) ; public abstract void attachShader ( int program , int shader ) ; public abstract void detachShader ( int program , int shader ) ; public abstract void linkProgram ( int program ) ; public abstract void useProgram ( int program ) ; public abstract void deleteProgram ( int program ) ; public abstract String getActiveAttrib ( int program , int index , IntBuffer size , IntBuffer type ) ; public abstract int getAttribLocation ( int program , String name ) ; public abstract void bindAttribLocation ( int program , int index , String name ) ; public abstract int getUniformLocation ( int program , String name ) ; public abstract String getActiveUniform ( int program , int index , IntBuffer size , IntBuffer type ) ; public abstract void uniform1i ( int location , int value ) ; public abstract void uniform2i ( int location , int value0 , int value1 ) ; public abstract void uniform3i ( int location , int value0 , int value1 , int value2 ) ; public abstract void uniform4i ( int location , int value0 , int value1 , int value2 , int value3 ) ; public abstract void uniform1f ( int location , float value ) ; public abstract void uniform2f ( int location , float value0 , float value1 ) ; public abstract void uniform3f ( int location , float value0 , float value1 , float value2 ) ; public abstract void uniform4f ( int location , float value0 , float value1 , float value2 , float value3 ) ; public abstract void uniform1iv ( int location , int count , IntBuffer v ) ; public abstract void uniform2iv ( int location , int count , IntBuffer v ) ; public abstract void uniform3iv ( int location , int count , IntBuffer v ) ; public abstract void uniform4iv ( int location , int count , IntBuffer v ) ; public abstract void uniform1fv ( int location , int count , FloatBuffer v ) ; public abstract void uniform2fv ( int location , int count , FloatBuffer v ) ; public abstract void uniform3fv ( int location , int count , FloatBuffer v ) ; public abstract void uniform4fv ( int location , int count , FloatBuffer v ) ; public abstract void uniformMatrix2fv ( int location , int count , boolean transpose , FloatBuffer mat ) ; public abstract void uniformMatrix3fv ( int location , int count , boolean transpose , FloatBuffer mat ) ; public abstract void uniformMatrix4fv ( int location , int count , boolean transpose , FloatBuffer mat ) ; public abstract void validateProgram ( int program ) ; public abstract boolean isShader ( int shader ) ; public abstract void getShaderiv ( int shader , int pname , IntBuffer params ) ; public abstract void getAttachedShaders ( int program , int maxCount , IntBuffer count , IntBuffer shaders ) ; public abstract String getShaderInfoLog ( int shader ) ; public abstract String getShaderSource ( int shader ) ; public abstract void getShaderPrecisionFormat ( int shaderType , int precisionType , IntBuffer range , IntBuffer precision ) ; public abstract void getVertexAttribfv ( int index , int pname , FloatBuffer params ) ; public abstract void getVertexAttribiv ( int index , int pname , IntBuffer params ) ; public abstract void getVertexAttribPointerv ( int index , int pname , ByteBuffer data ) ; public abstract void getUniformfv ( int program , int location , FloatBuffer params ) ; public abstract void getUniformiv ( int program , int location , IntBuffer params ) ; public abstract boolean isProgram ( int program ) ; public abstract void getProgramiv ( int program , int pname , IntBuffer params ) ; public abstract String getProgramInfoLog ( int program ) ; public abstract void scissor ( int x , int y , int w , int h ) ; public abstract void sampleCoverage ( float value , boolean invert ) ; public abstract void stencilFunc ( int func , int ref , int mask ) ; public abstract void stencilFuncSeparate ( int face , int func , int ref , int mask ) ; public abstract void stencilOp ( int sfail , int dpfail , int dppass ) ; public abstract void stencilOpSeparate ( int face , int sfail , int dpfail , int dppass ) ; public abstract void depthFunc ( int func ) ; public abstract void blendEquation ( int mode ) ; public abstract void blendEquationSeparate ( int modeRGB , int modeAlpha ) ; public abstract void blendFunc ( int src , int dst ) ; public abstract void blendFuncSeparate ( int srcRGB , int dstRGB , int srcAlpha , int dstAlpha ) ; public abstract void blendColor ( float red , float green , float blue , float alpha ) ; public abstract void alphaFunc ( int func , float ref ) ; public abstract void colorMask ( boolean r , boolean g , boolean b , boolean a ) ; public abstract void depthMask ( boolean mask ) ; public abstract void stencilMask ( int mask ) ; public abstract void stencilMaskSeparate ( int face , int mask ) ; public abstract void clear ( int buf ) ; public abstract void clearColor ( float r , float g , float b , float a ) ; public abstract void clearDepth ( float d ) ; public abstract void clearStencil ( int s ) ; public void bindFramebuffer ( int target , int framebuffer ) { pg . beginBindFramebuffer ( target , framebuffer ) ; bindFramebufferImpl ( target , framebuffer ) ; pg . endBindFramebuffer ( target , framebuffer ) ; } protected abstract void bindFramebufferImpl ( int target , int framebuffer ) ; public abstract void deleteFramebuffers ( int n , IntBuffer framebuffers ) ; public abstract void genFramebuffers ( int n , IntBuffer framebuffers ) ; public abstract void bindRenderbuffer ( int target , int renderbuffer ) ; public abstract void deleteRenderbuffers ( int n , IntBuffer renderbuffers ) ; public abstract void genRenderbuffers ( int n , IntBuffer renderbuffers ) ; public abstract void renderbufferStorage ( int target , int internalFormat , int width , int height ) ; public abstract void framebufferRenderbuffer ( int target , int attachment , int rendbuferfTarget , int renderbuffer ) ; public abstract void framebufferTexture2D ( int target , int attachment , int texTarget , int texture , int level ) ; public abstract int checkFramebufferStatus ( int target ) ; public abstract boolean isFramebuffer ( int framebuffer ) ; public abstract void getFramebufferAttachmentParameteriv ( int target , int attachment , int pname , IntBuffer params ) ; public abstract boolean isRenderbuffer ( int renderbuffer ) ; public abstract void getRenderbufferParameteriv ( int target , int pname , IntBuffer params ) ; public abstract void blitFramebuffer ( int srcX0 , int srcY0 , int srcX1 , int srcY1 , int dstX0 , int dstY0 , int dstX1 , int dstY1 , int mask , int filter ) ; public abstract void renderbufferStorageMultisample ( int target , int samples , int format , int width , int height ) ; public abstract void readBuffer ( int buf ) ; public abstract void drawBuffer ( int buf ) ; int [ ] labelPix = { - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1315861 , - 2171170 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1118482 , - 1 , - 2105377 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1052689 , - 1 , - 2105377 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2039584 , - 855310 , - 263173 , - 131587 , - 460552 , - 1315861 , - 2236963 , - 2236963 , - 1052689 , - 263173 , - 1 , - 460552 , - 1118482 , - 2236963 , - 2236963 , - 1776412 , - 657931 , - 197380 , - 197380 , - 723724 , - 1907998 , - 2236963 , - 2236963 , - 2236963 , - 789517 , - 1118482 , - 1447447 , - 460552 , - 197380 , - 789517 , - 1710619 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 526345 , - 131587 , - 921103 , - 1250068 , - 592138 , - 1 , - 1184275 , - 2236963 , - 1447447 , - 526345 , - 1 , - 1052689 , - 1513240 , - 2236963 , - 1710619 , - 1 , - 328966 , - 1184275 , - 1118482 , - 263173 , - 65794 , - 1776412 , - 2236963 , - 2236963 , - 394759 , - 263173 , - 65794 , - 1118482 , - 1381654 , - 394759 , - 131587 , - 1907998 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2039584 , - 1 , - 1184275 , - 2236963 , - 2236963 , - 2236963 , - 460552 , - 723724 , - 2236963 , - 2236963 , - 1052689 , - 1 , - 2105377 , - 2236963 , - 2171170 , - 328966 , - 263173 , - 2105377 , - 2236963 , - 2236963 , - 2039584 , - 197380 , - 460552 , - 2236963 , - 2236963 , - 394759 , - 1 , - 1513240 , - 2236963 , - 2236963 , - 2105377 , - 197380 , - 526345 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2171170 , - 65794 , - 394759 , - 1710619 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1052689 , - 1 , - 2105377 , - 2236963 , - 1907998 , - 1 , - 1184275 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1052689 , - 1 , - 1973791 , - 2236963 , - 394759 , - 328966 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1052689 , - 65794 , - 2171170 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1250068 , - 1 , - 1 , - 197380 , - 855310 , - 1579033 , - 2236963 , - 2236963 , - 2236963 , - 1052689 , - 1 , - 2105377 , - 2236963 , - 1579033 , - 1 , - 1579033 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1447447 , - 1 , - 1644826 , - 2236963 , - 394759 , - 657931 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1381654 , - 1 , - 1842205 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1776412 , - 986896 , - 328966 , - 1 , - 1 , - 855310 , - 2236963 , - 2236963 , - 1052689 , - 1 , - 2105377 , - 2236963 , - 1447447 , - 1 , - 1644826 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1513240 , - 1 , - 1579033 , - 2236963 , - 394759 , - 789517 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1381654 , - 1 , - 1776412 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2105377 , - 2171170 , - 2236963 , - 2236963 , - 1907998 , - 460552 , - 1 , - 1973791 , - 2236963 , - 1052689 , - 1 , - 2105377 , - 2236963 , - 1776412 , - 1 , - 1381654 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1184275 , - 1 , - 1776412 , - 2236963 , - 394759 , - 526345 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1118482 , - 65794 , - 2171170 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1776412 , - 1 , - 1250068 , - 2236963 , - 2236963 , - 2236963 , - 1250068 , - 1 , - 1776412 , - 2236963 , - 1118482 , - 1 , - 2039584 , - 2236963 , - 2105377 , - 131587 , - 460552 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 328966 , - 131587 , - 2171170 , - 2236963 , - 394759 , - 1 , - 1907998 , - 2236963 , - 2236963 , - 2236963 , - 328966 , - 394759 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 592138 , - 197380 , - 1250068 , - 1842205 , - 1381654 , - 263173 , - 263173 , - 2236963 , - 2236963 , - 1250068 , - 1 , - 921103 , - 1579033 , - 2236963 , - 1250068 , - 1 , - 789517 , - 1776412 , - 1776412 , - 657931 , - 1 , - 1513240 , - 2236963 , - 2236963 , - 394759 , - 1 , - 394759 , - 1644826 , - 1776412 , - 723724 , - 65794 , - 1776412 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1842205 , - 460552 , - 1 , - 1 , - 1 , - 526345 , - 1973791 , - 2236963 , - 2236963 , - 2039584 , - 394759 , - 1 , - 460552 , - 2236963 , - 2236963 , - 1315861 , - 131587 , - 1 , - 1 , - 394759 , - 1447447 , - 2236963 , - 2236963 , - 2236963 , - 394759 , - 460552 , - 855310 , - 1 , - 1 , - 394759 , - 1513240 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2039584 , - 1842205 , - 2171170 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2105377 , - 2171170 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1973791 , - 2039584 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 394759 , - 526345 , - 2236963 , - 2105377 , - 1973791 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 394759 , - 526345 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 394759 , - 526345 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 1184275 , - 1250068 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 , - 2236963 } ; }
package processing . opengl ; import processing . core . * ; import java . awt . Font ; import java . net . URL ; import java . nio . * ; import java . util . * ; public class PGraphicsOpenGL extends PGraphics { public PGL pgl ; protected PGraphicsOpenGL currentPG ; protected WeakHashMap < PFont , FontTexture > fontMap ; static protected PSurfaceJOGL surfaceJOGL ; public boolean initialized ; static protected final int FLUSH_CONTINUOUSLY = 0 ; static protected final int FLUSH_WHEN_FULL = 1 ; static protected final int IMMEDIATE = 0 ; static protected final int RETAINED = 1 ; protected int flushMode = FLUSH_WHEN_FULL ; public int glPolyVertex ; public int glPolyColor ; public int glPolyNormal ; public int glPolyTexcoord ; public int glPolyAmbient ; public int glPolySpecular ; public int glPolyEmissive ; public int glPolyShininess ; public int glPolyIndex ; protected boolean polyBuffersCreated = false ; protected int polyBuffersContext ; public int glLineVertex ; public int glLineColor ; public int glLineAttrib ; public int glLineIndex ; protected boolean lineBuffersCreated = false ; protected int lineBuffersContext ; public int glPointVertex ; public int glPointColor ; public int glPointAttrib ; public int glPointIndex ; protected boolean pointBuffersCreated = false ; protected int pointBuffersContext ; protected AttributeMap polyAttribs ; static protected final int INIT_VERTEX_BUFFER_SIZE = 256 ; static protected final int INIT_INDEX_BUFFER_SIZE = 512 ; static protected boolean glParamsRead = false ; static public boolean npotTexSupported ; static public boolean autoMipmapGenSupported ; static public boolean fboMultisampleSupported ; static public boolean packedDepthStencilSupported ; static public boolean anisoSamplingSupported ; static public boolean blendEqSupported ; static public int maxTextureSize ; static public int maxSamples ; static public float maxAnisoAmount ; static public int depthBits ; static public int stencilBits ; static public String OPENGL_VENDOR ; static public String OPENGL_RENDERER ; static public String OPENGL_VERSION ; static public String OPENGL_EXTENSIONS ; static public String GLSL_VERSION ; static protected HashMap < GLResource , Boolean > glTextureObjects = new HashMap < GLResource , Boolean > ( ) ; static protected HashMap < GLResource , Boolean > glVertexBuffers = new HashMap < GLResource , Boolean > ( ) ; static protected HashMap < GLResource , Boolean > glFrameBuffers = new HashMap < GLResource , Boolean > ( ) ; static protected HashMap < GLResource , Boolean > glRenderBuffers = new HashMap < GLResource , Boolean > ( ) ; static protected HashMap < GLResource , Boolean > glslPrograms = new HashMap < GLResource , Boolean > ( ) ; static protected HashMap < GLResource , Boolean > glslVertexShaders = new HashMap < GLResource , Boolean > ( ) ; static protected HashMap < GLResource , Boolean > glslFragmentShaders = new HashMap < GLResource , Boolean > ( ) ; static protected URL defColorShaderVertURL = PGraphicsOpenGL . class . getResource ( "/processing/opengl/shaders/ColorVert.glsl" ) ; static protected URL defTextureShaderVertURL = PGraphicsOpenGL . class . getResource ( "/processing/opengl/shaders/TexVert.glsl" ) ; static protected URL defLightShaderVertURL = PGraphicsOpenGL . class . getResource ( "/processing/opengl/shaders/LightVert.glsl" ) ; static protected URL defTexlightShaderVertURL = PGraphicsOpenGL . class . getResource ( "/processing/opengl/shaders/TexLightVert.glsl" ) ; static protected URL defColorShaderFragURL = PGraphicsOpenGL . class . getResource ( "/processing/opengl/shaders/ColorFrag.glsl" ) ; static protected URL defTextureShaderFragURL = PGraphicsOpenGL . class . getResource ( "/processing/opengl/shaders/TexFrag.glsl" ) ; static protected URL defLightShaderFragURL = PGraphicsOpenGL . class . getResource ( "/processing/opengl/shaders/LightFrag.glsl" ) ; static protected URL defTexlightShaderFragURL = PGraphicsOpenGL . class . getResource ( "/processing/opengl/shaders/TexLightFrag.glsl" ) ; static protected URL defLineShaderVertURL = PGraphicsOpenGL . class . getResource ( "/processing/opengl/shaders/LineVert.glsl" ) ; static protected URL defLineShaderFragURL = PGraphicsOpenGL . class . getResource ( "/processing/opengl/shaders/LineFrag.glsl" ) ; static protected URL defPointShaderVertURL = PGraphicsOpenGL . class . getResource ( "/processing/opengl/shaders/PointVert.glsl" ) ; static protected URL defPointShaderFragURL = PGraphicsOpenGL . class . getResource ( "/processing/opengl/shaders/PointFrag.glsl" ) ; static protected URL maskShaderFragURL = PGraphicsOpenGL . class . getResource ( "/processing/opengl/shaders/MaskFrag.glsl" ) ; protected PShader defColorShader ; protected PShader defTextureShader ; protected PShader defLightShader ; protected PShader defTexlightShader ; protected PShader defLineShader ; protected PShader defPointShader ; protected PShader maskShader ; protected PShader polyShader ; protected PShader lineShader ; protected PShader pointShader ; protected InGeometry inGeo ; protected TessGeometry tessGeo ; protected TexCache texCache ; static protected Tessellator tessellator ; protected DepthSorter sorter ; public float cameraFOV ; public float cameraX , cameraY , cameraZ ; public float cameraNear , cameraFar ; public float cameraAspect ; protected float eyeDist ; protected boolean manipulatingCamera ; public PMatrix3D projection ; public PMatrix3D camera ; public PMatrix3D cameraInv ; public PMatrix3D modelview ; public PMatrix3D modelviewInv ; public PMatrix3D projmodelview ; protected float [ ] glProjection ; protected float [ ] glModelview ; protected float [ ] glProjmodelview ; protected float [ ] glNormal ; static protected PMatrix3D identity = new PMatrix3D ( ) ; protected boolean sized ; static protected final int MATRIX_STACK_DEPTH = 32 ; protected int modelviewStackDepth ; protected int projectionStackDepth ; protected float [ ] [ ] modelviewStack = new float [ MATRIX_STACK_DEPTH ] [ 16 ] ; protected float [ ] [ ] modelviewInvStack = new float [ MATRIX_STACK_DEPTH ] [ 16 ] ; protected float [ ] [ ] cameraStack = new float [ MATRIX_STACK_DEPTH ] [ 16 ] ; protected float [ ] [ ] cameraInvStack = new float [ MATRIX_STACK_DEPTH ] [ 16 ] ; protected float [ ] [ ] projectionStack = new float [ MATRIX_STACK_DEPTH ] [ 16 ] ; public boolean lights ; public int lightCount = 0 ; public int [ ] lightType ; public float [ ] lightPosition ; public float [ ] lightNormal ; public float [ ] lightAmbient ; public float [ ] lightDiffuse ; public float [ ] lightSpecular ; public float [ ] lightFalloffCoefficients ; public float [ ] lightSpotParameters ; public float [ ] currentLightSpecular ; public float currentLightFalloffConstant ; public float currentLightFalloffLinear ; public float currentLightFalloffQuadratic ; protected int textureWrap = CLAMP ; protected int textureSampling = Texture . TRILINEAR ; protected boolean clip = false ; protected int [ ] clipRect = { 0 , 0 , 0 , 0 } ; FontTexture textTex ; static protected final int FB_STACK_DEPTH = 16 ; protected int fbStackDepth ; protected FrameBuffer [ ] fbStack ; protected FrameBuffer drawFramebuffer ; protected FrameBuffer readFramebuffer ; protected FrameBuffer currentFramebuffer ; protected FrameBuffer offscreenFramebuffer ; protected FrameBuffer multisampleFramebuffer ; protected boolean offscreenMultisample ; protected boolean pixOpChangedFB ; protected Texture texture ; protected Texture ptexture ; protected IntBuffer pixelBuffer ; protected int [ ] nativePixels ; protected IntBuffer nativePixelBuffer ; protected Texture filterTexture ; protected PImage filterImage ; protected boolean arePixelsUpToDate ; protected boolean drawing = false ; protected boolean restoreSurface = false ; protected boolean smoothDisabled = false ; protected int smoothCallCount = 0 ; protected int lastSmoothCall = - 10 ; protected int lastBlendMode = - 1 ; static protected final int OP_NONE = 0 ; static protected final int OP_READ = 1 ; static protected final int OP_WRITE = 2 ; protected int pixelsOp = OP_NONE ; protected IntBuffer viewport ; protected boolean clearColorBuffer ; protected boolean clearColorBuffer0 ; protected boolean openContour = false ; protected boolean breakShape = false ; protected boolean defaultEdges = false ; static protected final int EDGE_MIDDLE = 0 ; static protected final int EDGE_START = 1 ; static protected final int EDGE_STOP = 2 ; static protected final int EDGE_SINGLE = 3 ; static protected final int EDGE_CLOSE = - 1 ; final static protected int MIN_POINT_ACCURACY = 20 ; final static protected int MAX_POINT_ACCURACY = 200 ; final static protected float POINT_ACCURACY_FACTOR = 10.0f ; final static protected float [ ] [ ] QUAD_POINT_SIGNS = { { - 1 , + 1 } , { - 1 , - 1 } , { + 1 , - 1 } , { + 1 , + 1 } } ; static protected IntBuffer intBuffer ; static protected FloatBuffer floatBuffer ; static final String OPENGL_THREAD_ERROR = "Cannot run the OpenGL renderer outside the main thread, change your code" + "\nso the drawing calls are all inside the main thread, " + "\nor use the default renderer instead." ; static final String BLEND_DRIVER_ERROR = "blendMode(%1$s) is not supported by this hardware (or driver)" ; static final String BLEND_RENDERER_ERROR = "blendMode(%1$s) is not supported by this renderer" ; static final String ALREADY_BEGAN_CONTOUR_ERROR = "Already called beginContour()" ; static final String NO_BEGIN_CONTOUR_ERROR = "Need to call beginContour() first" ; static final String UNSUPPORTED_SMOOTH_LEVEL_ERROR = "Smooth level %1$s is not available. Using %2$s instead" ; static final String UNSUPPORTED_SMOOTH_ERROR = "Smooth is not supported by this hardware (or driver)" ; static final String TOO_MANY_SMOOTH_CALLS_ERROR = "The smooth/noSmooth functions are being called too often.\n" + "This results in screen flickering, so they will be disabled\n" + "for the rest of the sketch's execution" ; static final String UNSUPPORTED_SHAPE_FORMAT_ERROR = "Unsupported shape format" ; static final String MISSING_UV_TEXCOORDS_ERROR = "No uv texture coordinates supplied with vertex() call" ; static final String INVALID_FILTER_SHADER_ERROR = "Your shader cannot be used as a filter because is of type POINT or LINES" ; static final String INCONSISTENT_SHADER_TYPES = "The vertex and fragment shaders have different types" ; static final String WRONG_SHADER_TYPE_ERROR = "shader() called with a wrong shader" ; static final String SHADER_NEED_LIGHT_ATTRIBS = "The provided shader needs light attributes (ambient, diffuse, etc.), but " + "the current scene is unlit, so the default shader will be used instead" ; static final String MISSING_FRAGMENT_SHADER = "The fragment shader is missing, cannot create shader object" ; static final String MISSING_VERTEX_SHADER = "The vertex shader is missing, cannot create shader object" ; static final String UNKNOWN_SHADER_KIND_ERROR = "Unknown shader kind" ; static final String NO_TEXLIGHT_SHADER_ERROR = "Your shader needs to be of TEXLIGHT type " + "to render this geometry properly, using default shader instead." ; static final String NO_LIGHT_SHADER_ERROR = "Your shader needs to be of LIGHT type " + "to render this geometry properly, using default shader instead." ; static final String NO_TEXTURE_SHADER_ERROR = "Your shader needs to be of TEXTURE type " + "to render this geometry properly, using default shader instead." ; static final String NO_COLOR_SHADER_ERROR = "Your shader needs to be of COLOR type " + "to render this geometry properly, using default shader instead." ; static final String TESSELLATION_ERROR = "Tessellation Error: %1$s" ; public PGraphicsOpenGL ( ) { pgl = createPGL ( this ) ; if ( tessellator == null ) { tessellator = new Tessellator ( ) ; } if ( intBuffer == null ) { intBuffer = PGL . allocateIntBuffer ( 2 ) ; floatBuffer = PGL . allocateFloatBuffer ( 2 ) ; } viewport = PGL . allocateIntBuffer ( 4 ) ; polyAttribs = newAttributeMap ( ) ; inGeo = newInGeometry ( this , polyAttribs , IMMEDIATE ) ; tessGeo = newTessGeometry ( this , polyAttribs , IMMEDIATE ) ; texCache = newTexCache ( this ) ; projection = new PMatrix3D ( ) ; camera = new PMatrix3D ( ) ; cameraInv = new PMatrix3D ( ) ; modelview = new PMatrix3D ( ) ; modelviewInv = new PMatrix3D ( ) ; projmodelview = new PMatrix3D ( ) ; lightType = new int [ PGL . MAX_LIGHTS ] ; lightPosition = new float [ 4 * PGL . MAX_LIGHTS ] ; lightNormal = new float [ 3 * PGL . MAX_LIGHTS ] ; lightAmbient = new float [ 3 * PGL . MAX_LIGHTS ] ; lightDiffuse = new float [ 3 * PGL . MAX_LIGHTS ] ; lightSpecular = new float [ 3 * PGL . MAX_LIGHTS ] ; lightFalloffCoefficients = new float [ 3 * PGL . MAX_LIGHTS ] ; lightSpotParameters = new float [ 2 * PGL . MAX_LIGHTS ] ; currentLightSpecular = new float [ 3 ] ; initialized = false ; } @ Override public void setPrimary ( boolean primary ) { super . setPrimary ( primary ) ; pgl . setPrimary ( primary ) ; format = ARGB ; if ( primary ) { fbStack = new FrameBuffer [ FB_STACK_DEPTH ] ; fontMap = new WeakHashMap < PFont , FontTexture > ( ) ; } } @ Override public void setSize ( int iwidth , int iheight ) { width = iwidth ; height = iheight ; updatePixelSize ( ) ; cameraFOV = 60 * DEG_TO_RAD ; cameraX = width / 2.0f ; cameraY = height / 2.0f ; cameraZ = cameraY / ( ( float ) Math . tan ( cameraFOV / 2.0f ) ) ; cameraNear = cameraZ / 10.0f ; cameraFar = cameraZ * 10.0f ; cameraAspect = ( float ) width / ( float ) height ; sized = true ; } @ Override public void dispose ( ) { super . dispose ( ) ; if ( primaryGraphics ) { } finalizePolyBuffers ( ) ; finalizeLineBuffers ( ) ; finalizePointBuffers ( ) ; deleteSurfaceTextures ( ) ; if ( primaryGraphics ) { deleteDefaultShaders ( ) ; } else { if ( offscreenFramebuffer != null ) { offscreenFramebuffer . dispose ( ) ; } if ( multisampleFramebuffer != null ) { multisampleFramebuffer . dispose ( ) ; } } deleteFinalizedGLResources ( pgl ) ; if ( primaryGraphics ) { pgl . deleteSurface ( ) ; } } @ Override protected void finalize ( ) throws Throwable { try { finalizePolyBuffers ( ) ; finalizeLineBuffers ( ) ; finalizePointBuffers ( ) ; deleteSurfaceTextures ( ) ; if ( ! primaryGraphics ) { if ( offscreenFramebuffer != null ) { offscreenFramebuffer . dispose ( ) ; offscreenFramebuffer = null ; } if ( multisampleFramebuffer != null ) { multisampleFramebuffer . dispose ( ) ; multisampleFramebuffer = null ; } } } finally { super . finalize ( ) ; } } protected void setFlushMode ( int mode ) { flushMode = mode ; } @ Override public PSurface createSurface ( ) { surfaceJOGL = new PSurfaceJOGL ( this ) ; return surfaceJOGL ; } protected void updatePixelSize ( ) { float f = getPixelScale ( ) ; pixelWidth = ( int ) ( width * f ) ; pixelHeight = ( int ) ( height * f ) ; } @ Override public void setCache ( PImage image , Object storage ) { getPrimaryPG ( ) . cacheMap . put ( image , storage ) ; } @ Override public Object getCache ( PImage image ) { return getPrimaryPG ( ) . cacheMap . get ( image ) ; } @ Override public void removeCache ( PImage image ) { getPrimaryPG ( ) . cacheMap . remove ( image ) ; } public float getPixelScale ( ) { if ( surfaceJOGL == null ) return pixelDensity ; else return surfaceJOGL . getPixelScale ( ) ; } protected void setFontTexture ( PFont font , FontTexture fontTexture ) { getPrimaryPG ( ) . fontMap . put ( font , fontTexture ) ; } protected FontTexture getFontTexture ( PFont font ) { return getPrimaryPG ( ) . fontMap . get ( font ) ; } protected void removeFontTexture ( PFont font ) { getPrimaryPG ( ) . fontMap . remove ( font ) ; } protected static class GLResource { int id ; int context ; GLResource ( int id , int context ) { this . id = id ; this . context = context ; } @ Override public boolean equals ( Object obj ) { GLResource other = ( GLResource ) obj ; return other . id == id && other . context == context ; } @ Override public int hashCode ( ) { int result = 17 ; result = 31 * result + id ; result = 31 * result + context ; return result ; } } protected static int createTextureObject ( int context , PGL pgl ) { deleteFinalizedTextureObjects ( pgl ) ; pgl . genTextures ( 1 , intBuffer ) ; int id = intBuffer . get ( 0 ) ; GLResource res = new GLResource ( id , context ) ; if ( ! glTextureObjects . containsKey ( res ) ) { glTextureObjects . put ( res , false ) ; } return id ; } protected static void deleteTextureObject ( int id , int context , PGL pgl ) { GLResource res = new GLResource ( id , context ) ; if ( glTextureObjects . containsKey ( res ) ) { intBuffer . put ( 0 , id ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteTextures ( 1 , intBuffer ) ; glTextureObjects . remove ( res ) ; } } protected static void deleteAllTextureObjects ( PGL pgl ) { for ( GLResource res : glTextureObjects . keySet ( ) ) { intBuffer . put ( 0 , res . id ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteTextures ( 1 , intBuffer ) ; } glTextureObjects . clear ( ) ; } synchronized protected static void finalizeTextureObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glTextureObjects . containsKey ( res ) ) { glTextureObjects . put ( res , true ) ; } } protected static void deleteFinalizedTextureObjects ( PGL pgl ) { Set < GLResource > finalized = new HashSet < GLResource > ( ) ; for ( GLResource res : glTextureObjects . keySet ( ) ) { if ( glTextureObjects . get ( res ) ) { finalized . add ( res ) ; intBuffer . put ( 0 , res . id ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteTextures ( 1 , intBuffer ) ; } } for ( GLResource res : finalized ) { glTextureObjects . remove ( res ) ; } } protected static void removeTextureObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glTextureObjects . containsKey ( res ) ) { glTextureObjects . remove ( res ) ; } } protected static int createVertexBufferObject ( int context , PGL pgl ) { deleteFinalizedVertexBufferObjects ( pgl ) ; pgl . genBuffers ( 1 , intBuffer ) ; int id = intBuffer . get ( 0 ) ; GLResource res = new GLResource ( id , context ) ; if ( ! glVertexBuffers . containsKey ( res ) ) { glVertexBuffers . put ( res , false ) ; } return id ; } protected static void deleteVertexBufferObject ( int id , int context , PGL pgl ) { GLResource res = new GLResource ( id , context ) ; if ( glVertexBuffers . containsKey ( res ) ) { intBuffer . put ( 0 , id ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteBuffers ( 1 , intBuffer ) ; glVertexBuffers . remove ( res ) ; } } protected static void deleteAllVertexBufferObjects ( PGL pgl ) { for ( GLResource res : glVertexBuffers . keySet ( ) ) { intBuffer . put ( 0 , res . id ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteBuffers ( 1 , intBuffer ) ; } glVertexBuffers . clear ( ) ; } synchronized static protected void finalizeVertexBufferObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glVertexBuffers . containsKey ( res ) ) { glVertexBuffers . put ( res , true ) ; } } protected static void deleteFinalizedVertexBufferObjects ( PGL pgl ) { Set < GLResource > finalized = new HashSet < GLResource > ( ) ; for ( GLResource res : glVertexBuffers . keySet ( ) ) { if ( glVertexBuffers . get ( res ) ) { finalized . add ( res ) ; intBuffer . put ( 0 , res . id ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteBuffers ( 1 , intBuffer ) ; } } for ( GLResource res : finalized ) { glVertexBuffers . remove ( res ) ; } } protected static void removeVertexBufferObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glVertexBuffers . containsKey ( res ) ) { glVertexBuffers . remove ( res ) ; } } protected static int createFrameBufferObject ( int context , PGL pgl ) { deleteFinalizedFrameBufferObjects ( pgl ) ; pgl . genFramebuffers ( 1 , intBuffer ) ; int id = intBuffer . get ( 0 ) ; GLResource res = new GLResource ( id , context ) ; if ( ! glFrameBuffers . containsKey ( res ) ) { glFrameBuffers . put ( res , false ) ; } return id ; } protected static void deleteFrameBufferObject ( int id , int context , PGL pgl ) { GLResource res = new GLResource ( id , context ) ; if ( glFrameBuffers . containsKey ( res ) ) { intBuffer . put ( 0 , id ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteFramebuffers ( 1 , intBuffer ) ; glFrameBuffers . remove ( res ) ; } } protected static void deleteAllFrameBufferObjects ( PGL pgl ) { for ( GLResource res : glFrameBuffers . keySet ( ) ) { intBuffer . put ( 0 , res . id ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteFramebuffers ( 1 , intBuffer ) ; } glFrameBuffers . clear ( ) ; } synchronized static protected void finalizeFrameBufferObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glFrameBuffers . containsKey ( res ) ) { glFrameBuffers . put ( res , true ) ; } } protected static void deleteFinalizedFrameBufferObjects ( PGL pgl ) { Set < GLResource > finalized = new HashSet < GLResource > ( ) ; for ( GLResource res : glFrameBuffers . keySet ( ) ) { if ( glFrameBuffers . get ( res ) ) { finalized . add ( res ) ; intBuffer . put ( 0 , res . id ) ; if ( pgl . threadIsCurrent ( ) ) { pgl . deleteFramebuffers ( 1 , intBuffer ) ; } } } for ( GLResource res : finalized ) { glFrameBuffers . remove ( res ) ; } } protected static void removeFrameBufferObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glFrameBuffers . containsKey ( res ) ) { glFrameBuffers . remove ( res ) ; } } protected static int createRenderBufferObject ( int context , PGL pgl ) { deleteFinalizedRenderBufferObjects ( pgl ) ; pgl . genRenderbuffers ( 1 , intBuffer ) ; int id = intBuffer . get ( 0 ) ; GLResource res = new GLResource ( id , context ) ; if ( ! glRenderBuffers . containsKey ( res ) ) { glRenderBuffers . put ( res , false ) ; } return id ; } protected static void deleteRenderBufferObject ( int id , int context , PGL pgl ) { GLResource res = new GLResource ( id , context ) ; if ( glRenderBuffers . containsKey ( res ) ) { intBuffer . put ( 0 , id ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteRenderbuffers ( 1 , intBuffer ) ; glRenderBuffers . remove ( res ) ; } } protected static void deleteAllRenderBufferObjects ( PGL pgl ) { for ( GLResource res : glRenderBuffers . keySet ( ) ) { intBuffer . put ( 0 , res . id ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteRenderbuffers ( 1 , intBuffer ) ; } glRenderBuffers . clear ( ) ; } synchronized static protected void finalizeRenderBufferObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glRenderBuffers . containsKey ( res ) ) { glRenderBuffers . put ( res , true ) ; } } protected static void deleteFinalizedRenderBufferObjects ( PGL pgl ) { Set < GLResource > finalized = new HashSet < GLResource > ( ) ; for ( GLResource res : glRenderBuffers . keySet ( ) ) { if ( glRenderBuffers . get ( res ) ) { finalized . add ( res ) ; intBuffer . put ( 0 , res . id ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteRenderbuffers ( 1 , intBuffer ) ; } } for ( GLResource res : finalized ) { glRenderBuffers . remove ( res ) ; } } protected static void removeRenderBufferObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glRenderBuffers . containsKey ( res ) ) { glRenderBuffers . remove ( res ) ; } } protected static int createGLSLProgramObject ( int context , PGL pgl ) { deleteFinalizedGLSLProgramObjects ( pgl ) ; int id = pgl . createProgram ( ) ; GLResource res = new GLResource ( id , context ) ; if ( ! glslPrograms . containsKey ( res ) ) { glslPrograms . put ( res , false ) ; } return id ; } protected static void deleteGLSLProgramObject ( int id , int context , PGL pgl ) { GLResource res = new GLResource ( id , context ) ; if ( glslPrograms . containsKey ( res ) ) { if ( pgl . threadIsCurrent ( ) ) pgl . deleteProgram ( res . id ) ; glslPrograms . remove ( res ) ; } } protected static void deleteAllGLSLProgramObjects ( PGL pgl ) { for ( GLResource res : glslPrograms . keySet ( ) ) { if ( pgl . threadIsCurrent ( ) ) pgl . deleteProgram ( res . id ) ; } glslPrograms . clear ( ) ; } synchronized static protected void finalizeGLSLProgramObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glslPrograms . containsKey ( res ) ) { glslPrograms . put ( res , true ) ; } } protected static void deleteFinalizedGLSLProgramObjects ( PGL pgl ) { Set < GLResource > finalized = new HashSet < GLResource > ( ) ; for ( GLResource res : glslPrograms . keySet ( ) ) { if ( glslPrograms . get ( res ) ) { finalized . add ( res ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteProgram ( res . id ) ; } } for ( GLResource res : finalized ) { glslPrograms . remove ( res ) ; } } protected static void removeGLSLProgramObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glslPrograms . containsKey ( res ) ) { glslPrograms . remove ( res ) ; } } protected static int createGLSLVertShaderObject ( int context , PGL pgl ) { deleteFinalizedGLSLVertShaderObjects ( pgl ) ; int id = pgl . createShader ( PGL . VERTEX_SHADER ) ; GLResource res = new GLResource ( id , context ) ; if ( ! glslVertexShaders . containsKey ( res ) ) { glslVertexShaders . put ( res , false ) ; } return id ; } protected static void deleteGLSLVertShaderObject ( int id , int context , PGL pgl ) { GLResource res = new GLResource ( id , context ) ; if ( glslVertexShaders . containsKey ( res ) ) { if ( pgl . threadIsCurrent ( ) ) pgl . deleteShader ( res . id ) ; glslVertexShaders . remove ( res ) ; } } protected static void deleteAllGLSLVertShaderObjects ( PGL pgl ) { for ( GLResource res : glslVertexShaders . keySet ( ) ) { if ( pgl . threadIsCurrent ( ) ) pgl . deleteShader ( res . id ) ; } glslVertexShaders . clear ( ) ; } synchronized static protected void finalizeGLSLVertShaderObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glslVertexShaders . containsKey ( res ) ) { glslVertexShaders . put ( res , true ) ; } } protected static void deleteFinalizedGLSLVertShaderObjects ( PGL pgl ) { Set < GLResource > finalized = new HashSet < GLResource > ( ) ; for ( GLResource res : glslVertexShaders . keySet ( ) ) { if ( glslVertexShaders . get ( res ) ) { finalized . add ( res ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteShader ( res . id ) ; } } for ( GLResource res : finalized ) { glslVertexShaders . remove ( res ) ; } } protected static void removeGLSLVertShaderObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glslVertexShaders . containsKey ( res ) ) { glslVertexShaders . remove ( res ) ; } } protected static int createGLSLFragShaderObject ( int context , PGL pgl ) { deleteFinalizedGLSLFragShaderObjects ( pgl ) ; int id = pgl . createShader ( PGL . FRAGMENT_SHADER ) ; GLResource res = new GLResource ( id , context ) ; if ( ! glslFragmentShaders . containsKey ( res ) ) { glslFragmentShaders . put ( res , false ) ; } return id ; } protected static void deleteGLSLFragShaderObject ( int id , int context , PGL pgl ) { GLResource res = new GLResource ( id , context ) ; if ( glslFragmentShaders . containsKey ( res ) ) { if ( pgl . threadIsCurrent ( ) ) pgl . deleteShader ( res . id ) ; glslFragmentShaders . remove ( res ) ; } } protected static void deleteAllGLSLFragShaderObjects ( PGL pgl ) { for ( GLResource res : glslFragmentShaders . keySet ( ) ) { if ( pgl . threadIsCurrent ( ) ) pgl . deleteShader ( res . id ) ; } glslFragmentShaders . clear ( ) ; } synchronized static protected void finalizeGLSLFragShaderObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glslFragmentShaders . containsKey ( res ) ) { glslFragmentShaders . put ( res , true ) ; } } protected static void deleteFinalizedGLSLFragShaderObjects ( PGL pgl ) { Set < GLResource > finalized = new HashSet < GLResource > ( ) ; for ( GLResource res : glslFragmentShaders . keySet ( ) ) { if ( glslFragmentShaders . get ( res ) ) { finalized . add ( res ) ; if ( pgl . threadIsCurrent ( ) ) pgl . deleteShader ( res . id ) ; } } for ( GLResource res : finalized ) { glslFragmentShaders . remove ( res ) ; } } protected static void removeGLSLFragShaderObject ( int id , int context ) { GLResource res = new GLResource ( id , context ) ; if ( glslFragmentShaders . containsKey ( res ) ) { glslFragmentShaders . remove ( res ) ; } } protected static void deleteFinalizedGLResources ( PGL pgl ) { deleteFinalizedTextureObjects ( pgl ) ; deleteFinalizedVertexBufferObjects ( pgl ) ; deleteFinalizedFrameBufferObjects ( pgl ) ; deleteFinalizedRenderBufferObjects ( pgl ) ; deleteFinalizedGLSLProgramObjects ( pgl ) ; deleteFinalizedGLSLVertShaderObjects ( pgl ) ; deleteFinalizedGLSLFragShaderObjects ( pgl ) ; } protected void pushFramebuffer ( ) { PGraphicsOpenGL ppg = getPrimaryPG ( ) ; if ( ppg . fbStackDepth == FB_STACK_DEPTH ) { throw new RuntimeException ( "Too many pushFramebuffer calls" ) ; } ppg . fbStack [ ppg . fbStackDepth ] = ppg . currentFramebuffer ; ppg . fbStackDepth ++ ; } protected void setFramebuffer ( FrameBuffer fbo ) { PGraphicsOpenGL ppg = getPrimaryPG ( ) ; if ( ppg . currentFramebuffer != fbo ) { ppg . currentFramebuffer = fbo ; if ( ppg . currentFramebuffer != null ) ppg . currentFramebuffer . bind ( ) ; } } protected void popFramebuffer ( ) { PGraphicsOpenGL ppg = getPrimaryPG ( ) ; if ( ppg . fbStackDepth == 0 ) { throw new RuntimeException ( "popFramebuffer call is unbalanced." ) ; } ppg . fbStackDepth -- ; FrameBuffer fbo = ppg . fbStack [ ppg . fbStackDepth ] ; if ( ppg . currentFramebuffer != fbo ) { ppg . currentFramebuffer . finish ( ) ; ppg . currentFramebuffer = fbo ; if ( ppg . currentFramebuffer != null ) ppg . currentFramebuffer . bind ( ) ; } } protected FrameBuffer getCurrentFB ( ) { return getPrimaryPG ( ) . currentFramebuffer ; } protected void createPolyBuffers ( ) { if ( ! polyBuffersCreated || polyBuffersContextIsOutdated ( ) ) { polyBuffersContext = pgl . getCurrentContext ( ) ; int sizef = INIT_VERTEX_BUFFER_SIZE * PGL . SIZEOF_FLOAT ; int sizei = INIT_VERTEX_BUFFER_SIZE * PGL . SIZEOF_INT ; int sizex = INIT_INDEX_BUFFER_SIZE * PGL . SIZEOF_INDEX ; glPolyVertex = createVertexBufferObject ( polyBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyVertex ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 3 * sizef , null , PGL . STATIC_DRAW ) ; glPolyColor = createVertexBufferObject ( polyBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyColor ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , null , PGL . STATIC_DRAW ) ; glPolyNormal = createVertexBufferObject ( polyBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyNormal ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 3 * sizef , null , PGL . STATIC_DRAW ) ; glPolyTexcoord = createVertexBufferObject ( polyBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyTexcoord ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 2 * sizef , null , PGL . STATIC_DRAW ) ; glPolyAmbient = createVertexBufferObject ( polyBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyAmbient ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , null , PGL . STATIC_DRAW ) ; glPolySpecular = createVertexBufferObject ( polyBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolySpecular ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , null , PGL . STATIC_DRAW ) ; glPolyEmissive = createVertexBufferObject ( polyBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyEmissive ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , null , PGL . STATIC_DRAW ) ; glPolyShininess = createVertexBufferObject ( polyBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyShininess ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizef , null , PGL . STATIC_DRAW ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; glPolyIndex = createVertexBufferObject ( polyBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , glPolyIndex ) ; pgl . bufferData ( PGL . ELEMENT_ARRAY_BUFFER , sizex , null , PGL . STATIC_DRAW ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , 0 ) ; polyBuffersCreated = true ; } boolean created = false ; for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( ! attrib . bufferCreated ( ) || polyBuffersContextIsOutdated ( ) ) { attrib . createBuffer ( pgl ) ; created = true ; } } if ( created ) pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void updatePolyBuffers ( boolean lit , boolean tex , boolean needNormals , boolean needTexCoords ) { createPolyBuffers ( ) ; int size = tessGeo . polyVertexCount ; int sizef = size * PGL . SIZEOF_FLOAT ; int sizei = size * PGL . SIZEOF_INT ; tessGeo . updatePolyVerticesBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyVertex ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 4 * sizef , tessGeo . polyVerticesBuffer , PGL . STATIC_DRAW ) ; tessGeo . updatePolyColorsBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyColor ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , tessGeo . polyColorsBuffer , PGL . STATIC_DRAW ) ; if ( lit ) { tessGeo . updatePolyAmbientBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyAmbient ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , tessGeo . polyAmbientBuffer , PGL . STATIC_DRAW ) ; tessGeo . updatePolySpecularBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolySpecular ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , tessGeo . polySpecularBuffer , PGL . STATIC_DRAW ) ; tessGeo . updatePolyEmissiveBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyEmissive ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , tessGeo . polyEmissiveBuffer , PGL . STATIC_DRAW ) ; tessGeo . updatePolyShininessBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyShininess ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizef , tessGeo . polyShininessBuffer , PGL . STATIC_DRAW ) ; } if ( lit || needNormals ) { tessGeo . updatePolyNormalsBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyNormal ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 3 * sizef , tessGeo . polyNormalsBuffer , PGL . STATIC_DRAW ) ; } if ( tex || needTexCoords ) { tessGeo . updatePolyTexCoordsBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPolyTexcoord ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 2 * sizef , tessGeo . polyTexCoordsBuffer , PGL . STATIC_DRAW ) ; } for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; tessGeo . updateAttribBuffer ( name ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , attrib . glName ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , attrib . sizeInBytes ( size ) , tessGeo . polyAttribBuffers . get ( name ) , PGL . STATIC_DRAW ) ; } tessGeo . updatePolyIndicesBuffer ( ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , glPolyIndex ) ; pgl . bufferData ( PGL . ELEMENT_ARRAY_BUFFER , tessGeo . polyIndexCount * PGL . SIZEOF_INDEX , tessGeo . polyIndicesBuffer , PGL . STATIC_DRAW ) ; } protected void unbindPolyBuffers ( ) { pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , 0 ) ; } protected boolean polyBuffersContextIsOutdated ( ) { return ! pgl . contextIsCurrent ( polyBuffersContext ) ; } protected void finalizePolyBuffers ( ) { if ( glPolyVertex != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyVertex , polyBuffersContext ) ; glPolyVertex = 0 ; } if ( glPolyColor != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyColor , polyBuffersContext ) ; glPolyColor = 0 ; } if ( glPolyNormal != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyNormal , polyBuffersContext ) ; glPolyNormal = 0 ; } if ( glPolyTexcoord != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyTexcoord , polyBuffersContext ) ; glPolyTexcoord = 0 ; } if ( glPolyAmbient != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyAmbient , polyBuffersContext ) ; glPolyAmbient = 0 ; } if ( glPolySpecular != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolySpecular , polyBuffersContext ) ; glPolySpecular = 0 ; } if ( glPolyEmissive != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyEmissive , polyBuffersContext ) ; glPolyEmissive = 0 ; } if ( glPolyShininess != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyShininess , polyBuffersContext ) ; glPolyShininess = 0 ; } for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( attrib . glName != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( attrib . glName , polyBuffersContext ) ; attrib . glName = 0 ; } } if ( glPolyIndex != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPolyIndex , polyBuffersContext ) ; glPolyIndex = 0 ; } polyBuffersCreated = false ; } protected void createLineBuffers ( ) { if ( ! lineBuffersCreated || lineBufferContextIsOutdated ( ) ) { lineBuffersContext = pgl . getCurrentContext ( ) ; int sizef = INIT_VERTEX_BUFFER_SIZE * PGL . SIZEOF_FLOAT ; int sizei = INIT_VERTEX_BUFFER_SIZE * PGL . SIZEOF_INT ; int sizex = INIT_INDEX_BUFFER_SIZE * PGL . SIZEOF_INDEX ; glLineVertex = createVertexBufferObject ( lineBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glLineVertex ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 3 * sizef , null , PGL . STATIC_DRAW ) ; glLineColor = createVertexBufferObject ( lineBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glLineColor ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , null , PGL . STATIC_DRAW ) ; glLineAttrib = createVertexBufferObject ( lineBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glLineAttrib ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 4 * sizef , null , PGL . STATIC_DRAW ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; glLineIndex = createVertexBufferObject ( lineBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , glLineIndex ) ; pgl . bufferData ( PGL . ELEMENT_ARRAY_BUFFER , sizex , null , PGL . STATIC_DRAW ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , 0 ) ; lineBuffersCreated = true ; } } protected void updateLineBuffers ( ) { createLineBuffers ( ) ; int size = tessGeo . lineVertexCount ; int sizef = size * PGL . SIZEOF_FLOAT ; int sizei = size * PGL . SIZEOF_INT ; tessGeo . updateLineVerticesBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glLineVertex ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 4 * sizef , tessGeo . lineVerticesBuffer , PGL . STATIC_DRAW ) ; tessGeo . updateLineColorsBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glLineColor ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , tessGeo . lineColorsBuffer , PGL . STATIC_DRAW ) ; tessGeo . updateLineDirectionsBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glLineAttrib ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 4 * sizef , tessGeo . lineDirectionsBuffer , PGL . STATIC_DRAW ) ; tessGeo . updateLineIndicesBuffer ( ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , glLineIndex ) ; pgl . bufferData ( PGL . ELEMENT_ARRAY_BUFFER , tessGeo . lineIndexCount * PGL . SIZEOF_INDEX , tessGeo . lineIndicesBuffer , PGL . STATIC_DRAW ) ; } protected void unbindLineBuffers ( ) { pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , 0 ) ; } protected boolean lineBufferContextIsOutdated ( ) { return ! pgl . contextIsCurrent ( lineBuffersContext ) ; } protected void finalizeLineBuffers ( ) { if ( glLineVertex != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glLineVertex , lineBuffersContext ) ; glLineVertex = 0 ; } if ( glLineColor != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glLineColor , lineBuffersContext ) ; glLineColor = 0 ; } if ( glLineAttrib != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glLineAttrib , lineBuffersContext ) ; glLineAttrib = 0 ; } if ( glLineIndex != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glLineIndex , lineBuffersContext ) ; glLineIndex = 0 ; } lineBuffersCreated = false ; } protected void createPointBuffers ( ) { if ( ! pointBuffersCreated || pointBuffersContextIsOutdated ( ) ) { pointBuffersContext = pgl . getCurrentContext ( ) ; int sizef = INIT_VERTEX_BUFFER_SIZE * PGL . SIZEOF_FLOAT ; int sizei = INIT_VERTEX_BUFFER_SIZE * PGL . SIZEOF_INT ; int sizex = INIT_INDEX_BUFFER_SIZE * PGL . SIZEOF_INDEX ; glPointVertex = createVertexBufferObject ( pointBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPointVertex ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 3 * sizef , null , PGL . STATIC_DRAW ) ; glPointColor = createVertexBufferObject ( pointBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPointColor ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , null , PGL . STATIC_DRAW ) ; glPointAttrib = createVertexBufferObject ( pointBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPointAttrib ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 2 * sizef , null , PGL . STATIC_DRAW ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; glPointIndex = createVertexBufferObject ( pointBuffersContext , pgl ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , glPointIndex ) ; pgl . bufferData ( PGL . ELEMENT_ARRAY_BUFFER , sizex , null , PGL . STATIC_DRAW ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , 0 ) ; pointBuffersCreated = true ; } } protected void updatePointBuffers ( ) { createPointBuffers ( ) ; int size = tessGeo . pointVertexCount ; int sizef = size * PGL . SIZEOF_FLOAT ; int sizei = size * PGL . SIZEOF_INT ; tessGeo . updatePointVerticesBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPointVertex ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 4 * sizef , tessGeo . pointVerticesBuffer , PGL . STATIC_DRAW ) ; tessGeo . updatePointColorsBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPointColor ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , sizei , tessGeo . pointColorsBuffer , PGL . STATIC_DRAW ) ; tessGeo . updatePointOffsetsBuffer ( ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glPointAttrib ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , 2 * sizef , tessGeo . pointOffsetsBuffer , PGL . STATIC_DRAW ) ; tessGeo . updatePointIndicesBuffer ( ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , glPointIndex ) ; pgl . bufferData ( PGL . ELEMENT_ARRAY_BUFFER , tessGeo . pointIndexCount * PGL . SIZEOF_INDEX , tessGeo . pointIndicesBuffer , PGL . STATIC_DRAW ) ; } protected void unbindPointBuffers ( ) { pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , 0 ) ; } protected boolean pointBuffersContextIsOutdated ( ) { return ! pgl . contextIsCurrent ( pointBuffersContext ) ; } protected void finalizePointBuffers ( ) { if ( glPointVertex != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPointVertex , pointBuffersContext ) ; glPointVertex = 0 ; } if ( glPointColor != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPointColor , pointBuffersContext ) ; glPointColor = 0 ; } if ( glPointAttrib != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPointAttrib , pointBuffersContext ) ; glPointAttrib = 0 ; } if ( glPointIndex != 0 ) { PGraphicsOpenGL . finalizeVertexBufferObject ( glPointIndex , pointBuffersContext ) ; glPointIndex = 0 ; } pointBuffersCreated = false ; } @ Override public void beginDraw ( ) { if ( primaryGraphics ) { if ( ! initialized ) { initPrimary ( ) ; } setCurrentPG ( this ) ; } else { pgl . getGL ( getPrimaryPGL ( ) ) ; getPrimaryPG ( ) . setCurrentPG ( this ) ; } report ( "top beginDraw()" ) ; if ( ! checkGLThread ( ) ) { return ; } if ( drawing ) { return ; } if ( ! primaryGraphics && getPrimaryPG ( ) . texCache . containsTexture ( this ) ) { getPrimaryPG ( ) . flush ( ) ; } if ( ! glParamsRead ) { getGLParameters ( ) ; } setViewport ( ) ; if ( primaryGraphics ) { beginOnscreenDraw ( ) ; } else { beginOffscreenDraw ( ) ; } setDrawDefaults ( ) ; drawing = true ; report ( "bot beginDraw()" ) ; } @ Override public void endDraw ( ) { report ( "top endDraw()" ) ; if ( ! drawing ) { return ; } flush ( ) ; if ( PGL . SAVE_SURFACE_TO_PIXELS_HACK && ( ! getPrimaryPG ( ) . initialized || parent . frameCount == 0 ) ) { saveSurfaceToPixels ( ) ; restoreSurface = true ; } if ( primaryGraphics ) { endOnscreenDraw ( ) ; } else { endOffscreenDraw ( ) ; } if ( primaryGraphics ) { setCurrentPG ( null ) ; } else { getPrimaryPG ( ) . setCurrentPG ( getPrimaryPG ( ) ) ; } drawing = false ; report ( "bot endDraw()" ) ; } protected PGL createPGL ( PGraphicsOpenGL pg ) { return new PJOGL ( pg ) ; } protected PGraphicsOpenGL getPrimaryPG ( ) { if ( primaryGraphics ) { return this ; } else { return ( PGraphicsOpenGL ) parent . g ; } } protected void setCurrentPG ( PGraphicsOpenGL pg ) { currentPG = pg ; } protected PGraphicsOpenGL getCurrentPG ( ) { return currentPG ; } protected PGL getPrimaryPGL ( ) { if ( primaryGraphics ) { return pgl ; } else { return ( ( PGraphicsOpenGL ) parent . g ) . pgl ; } } @ Override public PGL beginPGL ( ) { flush ( ) ; pgl . beginGL ( ) ; return pgl ; } @ Override public void endPGL ( ) { pgl . endGL ( ) ; restoreGL ( ) ; } public void updateProjmodelview ( ) { projmodelview . set ( projection ) ; projmodelview . apply ( modelview ) ; } protected void restartPGL ( ) { initialized = false ; } protected void restoreGL ( ) { blendMode ( blendMode ) ; if ( hints [ DISABLE_DEPTH_TEST ] ) { pgl . disable ( PGL . DEPTH_TEST ) ; } else { pgl . enable ( PGL . DEPTH_TEST ) ; } pgl . depthFunc ( PGL . LEQUAL ) ; if ( smooth < 1 ) { pgl . disable ( PGL . MULTISAMPLE ) ; } else { pgl . enable ( PGL . MULTISAMPLE ) ; pgl . disable ( PGL . POLYGON_SMOOTH ) ; } pgl . viewport ( viewport . get ( 0 ) , viewport . get ( 1 ) , viewport . get ( 2 ) , viewport . get ( 3 ) ) ; if ( clip ) { pgl . enable ( PGL . SCISSOR_TEST ) ; pgl . scissor ( clipRect [ 0 ] , clipRect [ 1 ] , clipRect [ 2 ] , clipRect [ 3 ] ) ; } else { pgl . disable ( PGL . SCISSOR_TEST ) ; } pgl . frontFace ( PGL . CW ) ; pgl . disable ( PGL . CULL_FACE ) ; pgl . activeTexture ( PGL . TEXTURE0 ) ; if ( hints [ DISABLE_DEPTH_MASK ] ) { pgl . depthMask ( false ) ; } else { pgl . depthMask ( true ) ; } FrameBuffer fb = getCurrentFB ( ) ; if ( fb != null ) { fb . bind ( ) ; pgl . drawBuffer ( fb . getDefaultDrawBuffer ( ) ) ; } } protected void beginBindFramebuffer ( int target , int framebuffer ) { } protected void endBindFramebuffer ( int target , int framebuffer ) { FrameBuffer fb = getCurrentFB ( ) ; if ( framebuffer == 0 && fb != null && fb . glFbo != 0 ) { fb . bind ( ) ; } } protected void beginReadPixels ( ) { beginPixelsOp ( OP_READ ) ; } protected void endReadPixels ( ) { endPixelsOp ( ) ; } protected void beginPixelsOp ( int op ) { FrameBuffer pixfb = null ; if ( primaryGraphics ) { if ( op == OP_READ ) { if ( pgl . isFBOBacked ( ) && pgl . isMultisampled ( ) ) { pgl . syncBackTexture ( ) ; pixfb = readFramebuffer ; } else { pixfb = drawFramebuffer ; } } else if ( op == OP_WRITE ) { pixfb = drawFramebuffer ; } } else { if ( op == OP_READ ) { if ( offscreenMultisample ) { multisampleFramebuffer . copyColor ( offscreenFramebuffer ) ; } pixfb = offscreenFramebuffer ; } else if ( op == OP_WRITE ) { pixfb = offscreenMultisample ? multisampleFramebuffer : offscreenFramebuffer ; } } if ( pixfb != getCurrentFB ( ) ) { pushFramebuffer ( ) ; setFramebuffer ( pixfb ) ; pixOpChangedFB = true ; } if ( op == OP_READ ) { pgl . readBuffer ( getCurrentFB ( ) . getDefaultDrawBuffer ( ) ) ; } else if ( op == OP_WRITE ) { pgl . drawBuffer ( getCurrentFB ( ) . getDefaultDrawBuffer ( ) ) ; } pixelsOp = op ; } protected void endPixelsOp ( ) { if ( pixOpChangedFB ) { popFramebuffer ( ) ; pixOpChangedFB = false ; } pgl . readBuffer ( getCurrentFB ( ) . getDefaultReadBuffer ( ) ) ; pgl . drawBuffer ( getCurrentFB ( ) . getDefaultDrawBuffer ( ) ) ; pixelsOp = OP_NONE ; } protected void updateGLProjection ( ) { if ( glProjection == null ) { glProjection = new float [ 16 ] ; } glProjection [ 0 ] = projection . m00 ; glProjection [ 1 ] = projection . m10 ; glProjection [ 2 ] = projection . m20 ; glProjection [ 3 ] = projection . m30 ; glProjection [ 4 ] = projection . m01 ; glProjection [ 5 ] = projection . m11 ; glProjection [ 6 ] = projection . m21 ; glProjection [ 7 ] = projection . m31 ; glProjection [ 8 ] = projection . m02 ; glProjection [ 9 ] = projection . m12 ; glProjection [ 10 ] = projection . m22 ; glProjection [ 11 ] = projection . m32 ; glProjection [ 12 ] = projection . m03 ; glProjection [ 13 ] = projection . m13 ; glProjection [ 14 ] = projection . m23 ; glProjection [ 15 ] = projection . m33 ; } protected void updateGLModelview ( ) { if ( glModelview == null ) { glModelview = new float [ 16 ] ; } glModelview [ 0 ] = modelview . m00 ; glModelview [ 1 ] = modelview . m10 ; glModelview [ 2 ] = modelview . m20 ; glModelview [ 3 ] = modelview . m30 ; glModelview [ 4 ] = modelview . m01 ; glModelview [ 5 ] = modelview . m11 ; glModelview [ 6 ] = modelview . m21 ; glModelview [ 7 ] = modelview . m31 ; glModelview [ 8 ] = modelview . m02 ; glModelview [ 9 ] = modelview . m12 ; glModelview [ 10 ] = modelview . m22 ; glModelview [ 11 ] = modelview . m32 ; glModelview [ 12 ] = modelview . m03 ; glModelview [ 13 ] = modelview . m13 ; glModelview [ 14 ] = modelview . m23 ; glModelview [ 15 ] = modelview . m33 ; } protected void updateGLProjmodelview ( ) { if ( glProjmodelview == null ) { glProjmodelview = new float [ 16 ] ; } glProjmodelview [ 0 ] = projmodelview . m00 ; glProjmodelview [ 1 ] = projmodelview . m10 ; glProjmodelview [ 2 ] = projmodelview . m20 ; glProjmodelview [ 3 ] = projmodelview . m30 ; glProjmodelview [ 4 ] = projmodelview . m01 ; glProjmodelview [ 5 ] = projmodelview . m11 ; glProjmodelview [ 6 ] = projmodelview . m21 ; glProjmodelview [ 7 ] = projmodelview . m31 ; glProjmodelview [ 8 ] = projmodelview . m02 ; glProjmodelview [ 9 ] = projmodelview . m12 ; glProjmodelview [ 10 ] = projmodelview . m22 ; glProjmodelview [ 11 ] = projmodelview . m32 ; glProjmodelview [ 12 ] = projmodelview . m03 ; glProjmodelview [ 13 ] = projmodelview . m13 ; glProjmodelview [ 14 ] = projmodelview . m23 ; glProjmodelview [ 15 ] = projmodelview . m33 ; } protected void updateGLNormal ( ) { if ( glNormal == null ) { glNormal = new float [ 9 ] ; } glNormal [ 0 ] = modelviewInv . m00 ; glNormal [ 1 ] = modelviewInv . m01 ; glNormal [ 2 ] = modelviewInv . m02 ; glNormal [ 3 ] = modelviewInv . m10 ; glNormal [ 4 ] = modelviewInv . m11 ; glNormal [ 5 ] = modelviewInv . m12 ; glNormal [ 6 ] = modelviewInv . m20 ; glNormal [ 7 ] = modelviewInv . m21 ; glNormal [ 8 ] = modelviewInv . m22 ; } @ Override protected void defaultSettings ( ) { super . defaultSettings ( ) ; manipulatingCamera = false ; clearColorBuffer = false ; textureMode ( IMAGE ) ; ambient ( 255 ) ; specular ( 125 ) ; emissive ( 0 ) ; shininess ( 1 ) ; setAmbient = false ; } @ Override public void hint ( int which ) { boolean oldValue = hints [ PApplet . abs ( which ) ] ; super . hint ( which ) ; boolean newValue = hints [ PApplet . abs ( which ) ] ; if ( oldValue == newValue ) { return ; } if ( which == DISABLE_DEPTH_TEST ) { flush ( ) ; pgl . disable ( PGL . DEPTH_TEST ) ; } else if ( which == ENABLE_DEPTH_TEST ) { flush ( ) ; pgl . enable ( PGL . DEPTH_TEST ) ; } else if ( which == DISABLE_DEPTH_MASK ) { flush ( ) ; pgl . depthMask ( false ) ; } else if ( which == ENABLE_DEPTH_MASK ) { flush ( ) ; pgl . depthMask ( true ) ; } else if ( which == ENABLE_OPTIMIZED_STROKE ) { flush ( ) ; setFlushMode ( FLUSH_WHEN_FULL ) ; } else if ( which == DISABLE_OPTIMIZED_STROKE ) { if ( is2D ( ) ) { PGraphics . showWarning ( "Optimized strokes can only be disabled in 3D" ) ; } else { flush ( ) ; setFlushMode ( FLUSH_CONTINUOUSLY ) ; } } else if ( which == DISABLE_STROKE_PERSPECTIVE ) { if ( 0 < tessGeo . lineVertexCount && 0 < tessGeo . lineIndexCount ) { flush ( ) ; } } else if ( which == ENABLE_STROKE_PERSPECTIVE ) { if ( 0 < tessGeo . lineVertexCount && 0 < tessGeo . lineIndexCount ) { flush ( ) ; } } else if ( which == ENABLE_DEPTH_SORT ) { if ( is3D ( ) ) { flush ( ) ; if ( sorter == null ) sorter = new DepthSorter ( this ) ; } else { PGraphics . showWarning ( "Depth sorting can only be enabled in 3D" ) ; } } else if ( which == DISABLE_DEPTH_SORT ) { if ( is3D ( ) ) { flush ( ) ; } } } protected boolean getHint ( int which ) { if ( which > 0 ) { return hints [ which ] ; } else { return ! hints [ - which ] ; } } @ Override protected PShape createShapeFamily ( int type ) { PShape shape = new PShapeOpenGL ( this , type ) ; if ( is3D ( ) ) { shape . set3D ( true ) ; } return shape ; } @ Override protected PShape createShapePrimitive ( int kind , float ... p ) { PShape shape = new PShapeOpenGL ( this , kind , p ) ; if ( is3D ( ) ) { shape . set3D ( true ) ; } return shape ; } @ Override public void beginShape ( int kind ) { shape = kind ; inGeo . clear ( ) ; curveVertexCount = 0 ; breakShape = false ; defaultEdges = true ; super . noTexture ( ) ; normalMode = NORMAL_MODE_AUTO ; } @ Override public void endShape ( int mode ) { tessellate ( mode ) ; if ( ( flushMode == FLUSH_CONTINUOUSLY ) || ( flushMode == FLUSH_WHEN_FULL && tessGeo . isFull ( ) ) ) { flush ( ) ; } else { arePixelsUpToDate = false ; } } protected void endShape ( int [ ] indices ) { if ( shape != TRIANGLE && shape != TRIANGLES ) { throw new RuntimeException ( "Indices and edges can only be set for " + "TRIANGLE shapes" ) ; } tessellate ( indices ) ; if ( flushMode == FLUSH_CONTINUOUSLY || ( flushMode == FLUSH_WHEN_FULL && tessGeo . isFull ( ) ) ) { flush ( ) ; } else { arePixelsUpToDate = false ; } } @ Override public void textureWrap ( int wrap ) { this . textureWrap = wrap ; } public void textureSampling ( int sampling ) { this . textureSampling = sampling ; } @ Override public void beginContour ( ) { if ( openContour ) { PGraphics . showWarning ( ALREADY_BEGAN_CONTOUR_ERROR ) ; return ; } openContour = true ; breakShape = true ; } @ Override public void endContour ( ) { if ( ! openContour ) { PGraphics . showWarning ( NO_BEGIN_CONTOUR_ERROR ) ; return ; } openContour = false ; } @ Override public void vertex ( float x , float y ) { vertexImpl ( x , y , 0 , 0 , 0 ) ; if ( textureImage != null ) PGraphics . showWarning ( MISSING_UV_TEXCOORDS_ERROR ) ; } @ Override public void vertex ( float x , float y , float u , float v ) { vertexImpl ( x , y , 0 , u , v ) ; } @ Override public void vertex ( float x , float y , float z ) { vertexImpl ( x , y , z , 0 , 0 ) ; if ( textureImage != null ) PGraphics . showWarning ( MISSING_UV_TEXCOORDS_ERROR ) ; } @ Override public void vertex ( float x , float y , float z , float u , float v ) { vertexImpl ( x , y , z , u , v ) ; } @ Override public void attrib ( String name , float ... values ) { VertexAttribute attrib = attribImpl ( name , PGL . FLOAT , values . length ) ; if ( attrib != null ) attrib . set ( values ) ; } @ Override public void attrib ( String name , int ... values ) { VertexAttribute attrib = attribImpl ( name , PGL . INT , values . length ) ; if ( attrib != null ) attrib . set ( values ) ; } @ Override public void attrib ( String name , boolean ... values ) { VertexAttribute attrib = attribImpl ( name , PGL . BOOL , values . length ) ; if ( attrib != null ) attrib . set ( values ) ; } protected VertexAttribute attribImpl ( String name , int type , int size ) { if ( 4 < size ) { PGraphics . showWarning ( "Vertex attributes cannot have more than 4 values" ) ; return null ; } VertexAttribute attrib = polyAttribs . get ( name ) ; if ( attrib == null ) { attrib = new VertexAttribute ( name , type , size ) ; polyAttribs . put ( name , attrib ) ; inGeo . initAttrib ( attrib ) ; tessGeo . initAttrib ( attrib ) ; } if ( attrib . size != size ) { PGraphics . showWarning ( "New value for vertex attribute has wrong number of values" ) ; return null ; } return attrib ; } protected void vertexImpl ( float x , float y , float z , float u , float v ) { boolean textured = textureImage != null ; int fcolor = 0x00 ; if ( fill || textured ) { if ( ! textured ) { fcolor = fillColor ; } else { if ( tint ) { fcolor = tintColor ; } else { fcolor = 0xffFFFFFF ; } } } int scolor = 0x00 ; float sweight = 0 ; if ( stroke ) { scolor = strokeColor ; sweight = strokeWeight ; } if ( textured && textureMode == IMAGE ) { u /= textureImage . width ; v /= textureImage . height ; } inGeo . addVertex ( x , y , z , fcolor , normalX , normalY , normalZ , u , v , scolor , sweight , ambientColor , specularColor , emissiveColor , shininess , VERTEX , vertexBreak ( ) ) ; } protected boolean vertexBreak ( ) { if ( breakShape ) { breakShape = false ; return true ; } return false ; } @ Override protected void clipImpl ( float x1 , float y1 , float x2 , float y2 ) { flush ( ) ; pgl . enable ( PGL . SCISSOR_TEST ) ; float h = y2 - y1 ; clipRect [ 0 ] = ( int ) x1 ; clipRect [ 1 ] = ( int ) ( height - y1 - h ) ; clipRect [ 2 ] = ( int ) ( x2 - x1 ) ; clipRect [ 3 ] = ( int ) h ; pgl . scissor ( clipRect [ 0 ] , clipRect [ 1 ] , clipRect [ 2 ] , clipRect [ 3 ] ) ; clip = true ; } @ Override public void noClip ( ) { if ( clip ) { flush ( ) ; pgl . disable ( PGL . SCISSOR_TEST ) ; clip = false ; } } protected void tessellate ( int mode ) { tessellator . setInGeometry ( inGeo ) ; tessellator . setTessGeometry ( tessGeo ) ; tessellator . setFill ( fill || textureImage != null ) ; tessellator . setTexCache ( texCache , textureImage ) ; tessellator . setStroke ( stroke ) ; tessellator . setStrokeColor ( strokeColor ) ; tessellator . setStrokeWeight ( strokeWeight ) ; tessellator . setStrokeCap ( strokeCap ) ; tessellator . setStrokeJoin ( strokeJoin ) ; tessellator . setRenderer ( this ) ; tessellator . setTransform ( modelview ) ; tessellator . set3D ( is3D ( ) ) ; if ( shape == POINTS ) { tessellator . tessellatePoints ( ) ; } else if ( shape == LINES ) { tessellator . tessellateLines ( ) ; } else if ( shape == LINE_STRIP ) { tessellator . tessellateLineStrip ( ) ; } else if ( shape == LINE_LOOP ) { tessellator . tessellateLineLoop ( ) ; } else if ( shape == TRIANGLE || shape == TRIANGLES ) { if ( stroke && defaultEdges ) inGeo . addTrianglesEdges ( ) ; if ( normalMode == NORMAL_MODE_AUTO ) inGeo . calcTrianglesNormals ( ) ; tessellator . tessellateTriangles ( ) ; } else if ( shape == TRIANGLE_FAN ) { if ( stroke && defaultEdges ) inGeo . addTriangleFanEdges ( ) ; if ( normalMode == NORMAL_MODE_AUTO ) inGeo . calcTriangleFanNormals ( ) ; tessellator . tessellateTriangleFan ( ) ; } else if ( shape == TRIANGLE_STRIP ) { if ( stroke && defaultEdges ) inGeo . addTriangleStripEdges ( ) ; if ( normalMode == NORMAL_MODE_AUTO ) inGeo . calcTriangleStripNormals ( ) ; tessellator . tessellateTriangleStrip ( ) ; } else if ( shape == QUAD || shape == QUADS ) { if ( stroke && defaultEdges ) inGeo . addQuadsEdges ( ) ; if ( normalMode == NORMAL_MODE_AUTO ) inGeo . calcQuadsNormals ( ) ; tessellator . tessellateQuads ( ) ; } else if ( shape == QUAD_STRIP ) { if ( stroke && defaultEdges ) inGeo . addQuadStripEdges ( ) ; if ( normalMode == NORMAL_MODE_AUTO ) inGeo . calcQuadStripNormals ( ) ; tessellator . tessellateQuadStrip ( ) ; } else if ( shape == POLYGON ) { tessellator . tessellatePolygon ( true , mode == CLOSE , normalMode == NORMAL_MODE_AUTO ) ; } } protected void tessellate ( int [ ] indices ) { tessellator . setInGeometry ( inGeo ) ; tessellator . setTessGeometry ( tessGeo ) ; tessellator . setFill ( fill || textureImage != null ) ; tessellator . setStroke ( stroke ) ; tessellator . setStrokeColor ( strokeColor ) ; tessellator . setStrokeWeight ( strokeWeight ) ; tessellator . setStrokeCap ( strokeCap ) ; tessellator . setStrokeJoin ( strokeJoin ) ; tessellator . setTexCache ( texCache , textureImage ) ; tessellator . setTransform ( modelview ) ; tessellator . set3D ( is3D ( ) ) ; if ( stroke && defaultEdges ) inGeo . addTrianglesEdges ( ) ; if ( normalMode == NORMAL_MODE_AUTO ) inGeo . calcTrianglesNormals ( ) ; tessellator . tessellateTriangles ( indices ) ; } @ Override public void flush ( ) { boolean hasPolys = 0 < tessGeo . polyVertexCount && 0 < tessGeo . polyIndexCount ; boolean hasLines = 0 < tessGeo . lineVertexCount && 0 < tessGeo . lineIndexCount ; boolean hasPoints = 0 < tessGeo . pointVertexCount && 0 < tessGeo . pointIndexCount ; boolean hasPixels = modified && pixels != null ; if ( hasPixels ) { flushPixels ( ) ; } if ( hasPoints || hasLines || hasPolys ) { PMatrix3D modelview0 = null ; PMatrix3D modelviewInv0 = null ; if ( flushMode == FLUSH_WHEN_FULL ) { modelview0 = modelview ; modelviewInv0 = modelviewInv ; modelview = modelviewInv = identity ; projmodelview . set ( projection ) ; } if ( hasPolys && ! getHint ( ENABLE_DEPTH_SORT ) ) { flushPolys ( ) ; if ( raw != null ) { rawPolys ( ) ; } } if ( is3D ( ) ) { if ( hasLines ) { flushLines ( ) ; if ( raw != null ) { rawLines ( ) ; } } if ( hasPoints ) { flushPoints ( ) ; if ( raw != null ) { rawPoints ( ) ; } } } if ( hasPolys && getHint ( ENABLE_DEPTH_SORT ) ) { flushSortedPolys ( ) ; if ( raw != null ) { rawSortedPolys ( ) ; } } if ( flushMode == FLUSH_WHEN_FULL ) { modelview = modelview0 ; modelviewInv = modelviewInv0 ; updateProjmodelview ( ) ; } } tessGeo . clear ( ) ; texCache . clear ( ) ; arePixelsUpToDate = false ; } protected void flushPixels ( ) { drawPixels ( mx1 , my1 , mx2 - mx1 , my2 - my1 ) ; modified = false ; } protected void flushPolys ( ) { boolean customShader = polyShader != null ; boolean needNormals = customShader ? polyShader . accessNormals ( ) : false ; boolean needTexCoords = customShader ? polyShader . accessTexCoords ( ) : false ; updatePolyBuffers ( lights , texCache . hasTextures , needNormals , needTexCoords ) ; for ( int i = 0 ; i < texCache . size ; i ++ ) { Texture tex = texCache . getTexture ( i ) ; PShader shader = getPolyShader ( lights , tex != null ) ; shader . bind ( ) ; int first = texCache . firstCache [ i ] ; int last = texCache . lastCache [ i ] ; IndexCache cache = tessGeo . polyIndexCache ; for ( int n = first ; n <= last ; n ++ ) { int ioffset = n == first ? texCache . firstIndex [ i ] : cache . indexOffset [ n ] ; int icount = n == last ? texCache . lastIndex [ i ] - ioffset + 1 : cache . indexOffset [ n ] + cache . indexCount [ n ] - ioffset ; int voffset = cache . vertexOffset [ n ] ; shader . setVertexAttribute ( glPolyVertex , 4 , PGL . FLOAT , 0 , 4 * voffset * PGL . SIZEOF_FLOAT ) ; shader . setColorAttribute ( glPolyColor , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; if ( lights ) { shader . setNormalAttribute ( glPolyNormal , 3 , PGL . FLOAT , 0 , 3 * voffset * PGL . SIZEOF_FLOAT ) ; shader . setAmbientAttribute ( glPolyAmbient , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; shader . setSpecularAttribute ( glPolySpecular , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; shader . setEmissiveAttribute ( glPolyEmissive , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; shader . setShininessAttribute ( glPolyShininess , 1 , PGL . FLOAT , 0 , voffset * PGL . SIZEOF_FLOAT ) ; } if ( lights || needNormals ) { shader . setNormalAttribute ( glPolyNormal , 3 , PGL . FLOAT , 0 , 3 * voffset * PGL . SIZEOF_FLOAT ) ; } if ( tex != null || needTexCoords ) { shader . setTexcoordAttribute ( glPolyTexcoord , 2 , PGL . FLOAT , 0 , 2 * voffset * PGL . SIZEOF_FLOAT ) ; shader . setTexture ( tex ) ; } for ( VertexAttribute attrib : polyAttribs . values ( ) ) { if ( ! attrib . active ( shader ) ) continue ; attrib . bind ( pgl ) ; shader . setAttributeVBO ( attrib . glLoc , attrib . glName , attrib . tessSize , attrib . type , attrib . isColor ( ) , 0 , attrib . sizeInBytes ( voffset ) ) ; } shader . draw ( glPolyIndex , icount , ioffset ) ; } for ( VertexAttribute attrib : polyAttribs . values ( ) ) { if ( attrib . active ( shader ) ) attrib . unbind ( pgl ) ; } shader . unbind ( ) ; } unbindPolyBuffers ( ) ; } protected void flushSortedPolys ( ) { boolean customShader = polyShader != null ; boolean needNormals = customShader ? polyShader . accessNormals ( ) : false ; boolean needTexCoords = customShader ? polyShader . accessTexCoords ( ) : false ; updatePolyBuffers ( lights , texCache . hasTextures , needNormals , needTexCoords ) ; sorter . sort ( tessGeo ) ; int [ ] triangleIndices = sorter . triangleIndices ; int [ ] texCacheMap = sorter . texCacheMap ; int [ ] indexCacheMap = sorter . indexCacheMap ; for ( int i = 0 ; i < tessGeo . polyIndexCount / 3 ; i ++ ) { int ti = triangleIndices [ i ] ; Texture tex = texCache . getTexture ( texCacheMap [ ti ] ) ; int voffset = tessGeo . polyIndexCache . vertexOffset [ indexCacheMap [ ti ] ] ; PShader shader = getPolyShader ( lights , tex != null ) ; shader . bind ( ) ; int ioffset = 3 * ti ; int icount = 3 ; shader . setVertexAttribute ( glPolyVertex , 4 , PGL . FLOAT , 0 , 4 * voffset * PGL . SIZEOF_FLOAT ) ; shader . setColorAttribute ( glPolyColor , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; if ( lights ) { shader . setNormalAttribute ( glPolyNormal , 3 , PGL . FLOAT , 0 , 3 * voffset * PGL . SIZEOF_FLOAT ) ; shader . setAmbientAttribute ( glPolyAmbient , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; shader . setSpecularAttribute ( glPolySpecular , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; shader . setEmissiveAttribute ( glPolyEmissive , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; shader . setShininessAttribute ( glPolyShininess , 1 , PGL . FLOAT , 0 , voffset * PGL . SIZEOF_FLOAT ) ; } if ( lights || needNormals ) { shader . setNormalAttribute ( glPolyNormal , 3 , PGL . FLOAT , 0 , 3 * voffset * PGL . SIZEOF_FLOAT ) ; } if ( tex != null || needTexCoords ) { shader . setTexcoordAttribute ( glPolyTexcoord , 2 , PGL . FLOAT , 0 , 2 * voffset * PGL . SIZEOF_FLOAT ) ; shader . setTexture ( tex ) ; } for ( VertexAttribute attrib : polyAttribs . values ( ) ) { if ( ! attrib . active ( shader ) ) continue ; attrib . bind ( pgl ) ; shader . setAttributeVBO ( attrib . glLoc , attrib . glName , attrib . tessSize , attrib . type , attrib . isColor ( ) , 0 , attrib . sizeInBytes ( voffset ) ) ; } shader . draw ( glPolyIndex , icount , ioffset ) ; for ( VertexAttribute attrib : polyAttribs . values ( ) ) { if ( attrib . active ( shader ) ) attrib . unbind ( pgl ) ; } shader . unbind ( ) ; } unbindPolyBuffers ( ) ; } void rawPolys ( ) { raw . colorMode ( RGB ) ; raw . noStroke ( ) ; raw . beginShape ( TRIANGLES ) ; float [ ] vertices = tessGeo . polyVertices ; int [ ] color = tessGeo . polyColors ; float [ ] uv = tessGeo . polyTexCoords ; short [ ] indices = tessGeo . polyIndices ; for ( int i = 0 ; i < texCache . size ; i ++ ) { PImage textureImage = texCache . getTextureImage ( i ) ; int first = texCache . firstCache [ i ] ; int last = texCache . lastCache [ i ] ; IndexCache cache = tessGeo . polyIndexCache ; for ( int n = first ; n <= last ; n ++ ) { int ioffset = n == first ? texCache . firstIndex [ i ] : cache . indexOffset [ n ] ; int icount = n == last ? texCache . lastIndex [ i ] - ioffset + 1 : cache . indexOffset [ n ] + cache . indexCount [ n ] - ioffset ; int voffset = cache . vertexOffset [ n ] ; for ( int tr = ioffset / 3 ; tr < ( ioffset + icount ) / 3 ; tr ++ ) { int i0 = voffset + indices [ 3 * tr + 0 ] ; int i1 = voffset + indices [ 3 * tr + 1 ] ; int i2 = voffset + indices [ 3 * tr + 2 ] ; float [ ] pt0 = { 0 , 0 , 0 , 0 } ; float [ ] pt1 = { 0 , 0 , 0 , 0 } ; float [ ] pt2 = { 0 , 0 , 0 , 0 } ; int argb0 = PGL . nativeToJavaARGB ( color [ i0 ] ) ; int argb1 = PGL . nativeToJavaARGB ( color [ i1 ] ) ; int argb2 = PGL . nativeToJavaARGB ( color [ i2 ] ) ; if ( flushMode == FLUSH_CONTINUOUSLY ) { float [ ] src0 = { 0 , 0 , 0 , 0 } ; float [ ] src1 = { 0 , 0 , 0 , 0 } ; float [ ] src2 = { 0 , 0 , 0 , 0 } ; PApplet . arrayCopy ( vertices , 4 * i0 , src0 , 0 , 4 ) ; PApplet . arrayCopy ( vertices , 4 * i1 , src1 , 0 , 4 ) ; PApplet . arrayCopy ( vertices , 4 * i2 , src2 , 0 , 4 ) ; modelview . mult ( src0 , pt0 ) ; modelview . mult ( src1 , pt1 ) ; modelview . mult ( src2 , pt2 ) ; } else { PApplet . arrayCopy ( vertices , 4 * i0 , pt0 , 0 , 4 ) ; PApplet . arrayCopy ( vertices , 4 * i1 , pt1 , 0 , 4 ) ; PApplet . arrayCopy ( vertices , 4 * i2 , pt2 , 0 , 4 ) ; } if ( textureImage != null ) { raw . texture ( textureImage ) ; if ( raw . is3D ( ) ) { raw . fill ( argb0 ) ; raw . vertex ( pt0 [ X ] , pt0 [ Y ] , pt0 [ Z ] , uv [ 2 * i0 + 0 ] , uv [ 2 * i0 + 1 ] ) ; raw . fill ( argb1 ) ; raw . vertex ( pt1 [ X ] , pt1 [ Y ] , pt1 [ Z ] , uv [ 2 * i1 + 0 ] , uv [ 2 * i1 + 1 ] ) ; raw . fill ( argb2 ) ; raw . vertex ( pt2 [ X ] , pt2 [ Y ] , pt2 [ Z ] , uv [ 2 * i2 + 0 ] , uv [ 2 * i2 + 1 ] ) ; } else if ( raw . is2D ( ) ) { float sx0 = screenXImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sy0 = screenYImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sx1 = screenXImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sy1 = screenYImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sx2 = screenXImpl ( pt2 [ 0 ] , pt2 [ 1 ] , pt2 [ 2 ] , pt2 [ 3 ] ) ; float sy2 = screenYImpl ( pt2 [ 0 ] , pt2 [ 1 ] , pt2 [ 2 ] , pt2 [ 3 ] ) ; raw . fill ( argb0 ) ; raw . vertex ( sx0 , sy0 , uv [ 2 * i0 + 0 ] , uv [ 2 * i0 + 1 ] ) ; raw . fill ( argb1 ) ; raw . vertex ( sx1 , sy1 , uv [ 2 * i1 + 0 ] , uv [ 2 * i1 + 1 ] ) ; raw . fill ( argb1 ) ; raw . vertex ( sx2 , sy2 , uv [ 2 * i2 + 0 ] , uv [ 2 * i2 + 1 ] ) ; } } else { if ( raw . is3D ( ) ) { raw . fill ( argb0 ) ; raw . vertex ( pt0 [ X ] , pt0 [ Y ] , pt0 [ Z ] ) ; raw . fill ( argb1 ) ; raw . vertex ( pt1 [ X ] , pt1 [ Y ] , pt1 [ Z ] ) ; raw . fill ( argb2 ) ; raw . vertex ( pt2 [ X ] , pt2 [ Y ] , pt2 [ Z ] ) ; } else if ( raw . is2D ( ) ) { float sx0 = screenXImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sy0 = screenYImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sx1 = screenXImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sy1 = screenYImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sx2 = screenXImpl ( pt2 [ 0 ] , pt2 [ 1 ] , pt2 [ 2 ] , pt2 [ 3 ] ) ; float sy2 = screenYImpl ( pt2 [ 0 ] , pt2 [ 1 ] , pt2 [ 2 ] , pt2 [ 3 ] ) ; raw . fill ( argb0 ) ; raw . vertex ( sx0 , sy0 ) ; raw . fill ( argb1 ) ; raw . vertex ( sx1 , sy1 ) ; raw . fill ( argb2 ) ; raw . vertex ( sx2 , sy2 ) ; } } } } } raw . endShape ( ) ; } void rawSortedPolys ( ) { raw . colorMode ( RGB ) ; raw . noStroke ( ) ; raw . beginShape ( TRIANGLES ) ; float [ ] vertices = tessGeo . polyVertices ; int [ ] color = tessGeo . polyColors ; float [ ] uv = tessGeo . polyTexCoords ; short [ ] indices = tessGeo . polyIndices ; sorter . sort ( tessGeo ) ; int [ ] triangleIndices = sorter . triangleIndices ; int [ ] texCacheMap = sorter . texCacheMap ; int [ ] indexCacheMap = sorter . indexCacheMap ; for ( int i = 0 ; i < tessGeo . polyIndexCount / 3 ; i ++ ) { int ti = triangleIndices [ i ] ; PImage tex = texCache . getTextureImage ( texCacheMap [ ti ] ) ; int voffset = tessGeo . polyIndexCache . vertexOffset [ indexCacheMap [ ti ] ] ; int i0 = voffset + indices [ 3 * ti + 0 ] ; int i1 = voffset + indices [ 3 * ti + 1 ] ; int i2 = voffset + indices [ 3 * ti + 2 ] ; float [ ] pt0 = { 0 , 0 , 0 , 0 } ; float [ ] pt1 = { 0 , 0 , 0 , 0 } ; float [ ] pt2 = { 0 , 0 , 0 , 0 } ; int argb0 = PGL . nativeToJavaARGB ( color [ i0 ] ) ; int argb1 = PGL . nativeToJavaARGB ( color [ i1 ] ) ; int argb2 = PGL . nativeToJavaARGB ( color [ i2 ] ) ; if ( flushMode == FLUSH_CONTINUOUSLY ) { float [ ] src0 = { 0 , 0 , 0 , 0 } ; float [ ] src1 = { 0 , 0 , 0 , 0 } ; float [ ] src2 = { 0 , 0 , 0 , 0 } ; PApplet . arrayCopy ( vertices , 4 * i0 , src0 , 0 , 4 ) ; PApplet . arrayCopy ( vertices , 4 * i1 , src1 , 0 , 4 ) ; PApplet . arrayCopy ( vertices , 4 * i2 , src2 , 0 , 4 ) ; modelview . mult ( src0 , pt0 ) ; modelview . mult ( src1 , pt1 ) ; modelview . mult ( src2 , pt2 ) ; } else { PApplet . arrayCopy ( vertices , 4 * i0 , pt0 , 0 , 4 ) ; PApplet . arrayCopy ( vertices , 4 * i1 , pt1 , 0 , 4 ) ; PApplet . arrayCopy ( vertices , 4 * i2 , pt2 , 0 , 4 ) ; } if ( tex != null ) { raw . texture ( tex ) ; if ( raw . is3D ( ) ) { raw . fill ( argb0 ) ; raw . vertex ( pt0 [ X ] , pt0 [ Y ] , pt0 [ Z ] , uv [ 2 * i0 + 0 ] , uv [ 2 * i0 + 1 ] ) ; raw . fill ( argb1 ) ; raw . vertex ( pt1 [ X ] , pt1 [ Y ] , pt1 [ Z ] , uv [ 2 * i1 + 0 ] , uv [ 2 * i1 + 1 ] ) ; raw . fill ( argb2 ) ; raw . vertex ( pt2 [ X ] , pt2 [ Y ] , pt2 [ Z ] , uv [ 2 * i2 + 0 ] , uv [ 2 * i2 + 1 ] ) ; } else if ( raw . is2D ( ) ) { float sx0 = screenXImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sy0 = screenYImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sx1 = screenXImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sy1 = screenYImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sx2 = screenXImpl ( pt2 [ 0 ] , pt2 [ 1 ] , pt2 [ 2 ] , pt2 [ 3 ] ) ; float sy2 = screenYImpl ( pt2 [ 0 ] , pt2 [ 1 ] , pt2 [ 2 ] , pt2 [ 3 ] ) ; raw . fill ( argb0 ) ; raw . vertex ( sx0 , sy0 , uv [ 2 * i0 + 0 ] , uv [ 2 * i0 + 1 ] ) ; raw . fill ( argb1 ) ; raw . vertex ( sx1 , sy1 , uv [ 2 * i1 + 0 ] , uv [ 2 * i1 + 1 ] ) ; raw . fill ( argb1 ) ; raw . vertex ( sx2 , sy2 , uv [ 2 * i2 + 0 ] , uv [ 2 * i2 + 1 ] ) ; } } else { if ( raw . is3D ( ) ) { raw . fill ( argb0 ) ; raw . vertex ( pt0 [ X ] , pt0 [ Y ] , pt0 [ Z ] ) ; raw . fill ( argb1 ) ; raw . vertex ( pt1 [ X ] , pt1 [ Y ] , pt1 [ Z ] ) ; raw . fill ( argb2 ) ; raw . vertex ( pt2 [ X ] , pt2 [ Y ] , pt2 [ Z ] ) ; } else if ( raw . is2D ( ) ) { float sx0 = screenXImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sy0 = screenYImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sx1 = screenXImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sy1 = screenYImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sx2 = screenXImpl ( pt2 [ 0 ] , pt2 [ 1 ] , pt2 [ 2 ] , pt2 [ 3 ] ) ; float sy2 = screenYImpl ( pt2 [ 0 ] , pt2 [ 1 ] , pt2 [ 2 ] , pt2 [ 3 ] ) ; raw . fill ( argb0 ) ; raw . vertex ( sx0 , sy0 ) ; raw . fill ( argb1 ) ; raw . vertex ( sx1 , sy1 ) ; raw . fill ( argb2 ) ; raw . vertex ( sx2 , sy2 ) ; } } } raw . endShape ( ) ; } protected void flushLines ( ) { updateLineBuffers ( ) ; PShader shader = getLineShader ( ) ; shader . bind ( ) ; IndexCache cache = tessGeo . lineIndexCache ; for ( int n = 0 ; n < cache . size ; n ++ ) { int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int voffset = cache . vertexOffset [ n ] ; shader . setVertexAttribute ( glLineVertex , 4 , PGL . FLOAT , 0 , 4 * voffset * PGL . SIZEOF_FLOAT ) ; shader . setColorAttribute ( glLineColor , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; shader . setLineAttribute ( glLineAttrib , 4 , PGL . FLOAT , 0 , 4 * voffset * PGL . SIZEOF_FLOAT ) ; shader . draw ( glLineIndex , icount , ioffset ) ; } shader . unbind ( ) ; unbindLineBuffers ( ) ; } void rawLines ( ) { raw . colorMode ( RGB ) ; raw . noFill ( ) ; raw . strokeCap ( strokeCap ) ; raw . strokeJoin ( strokeJoin ) ; raw . beginShape ( LINES ) ; float [ ] vertices = tessGeo . lineVertices ; int [ ] color = tessGeo . lineColors ; float [ ] attribs = tessGeo . lineDirections ; short [ ] indices = tessGeo . lineIndices ; IndexCache cache = tessGeo . lineIndexCache ; for ( int n = 0 ; n < cache . size ; n ++ ) { int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int voffset = cache . vertexOffset [ n ] ; for ( int ln = ioffset / 6 ; ln < ( ioffset + icount ) / 6 ; ln ++ ) { int i0 = voffset + indices [ 6 * ln + 0 ] ; int i1 = voffset + indices [ 6 * ln + 5 ] ; float sw0 = 2 * attribs [ 4 * i0 + 3 ] ; float sw1 = 2 * attribs [ 4 * i1 + 3 ] ; if ( zero ( sw0 ) ) continue ; float [ ] pt0 = { 0 , 0 , 0 , 0 } ; float [ ] pt1 = { 0 , 0 , 0 , 0 } ; int argb0 = PGL . nativeToJavaARGB ( color [ i0 ] ) ; int argb1 = PGL . nativeToJavaARGB ( color [ i1 ] ) ; if ( flushMode == FLUSH_CONTINUOUSLY ) { float [ ] src0 = { 0 , 0 , 0 , 0 } ; float [ ] src1 = { 0 , 0 , 0 , 0 } ; PApplet . arrayCopy ( vertices , 4 * i0 , src0 , 0 , 4 ) ; PApplet . arrayCopy ( vertices , 4 * i1 , src1 , 0 , 4 ) ; modelview . mult ( src0 , pt0 ) ; modelview . mult ( src1 , pt1 ) ; } else { PApplet . arrayCopy ( vertices , 4 * i0 , pt0 , 0 , 4 ) ; PApplet . arrayCopy ( vertices , 4 * i1 , pt1 , 0 , 4 ) ; } if ( raw . is3D ( ) ) { raw . strokeWeight ( sw0 ) ; raw . stroke ( argb0 ) ; raw . vertex ( pt0 [ X ] , pt0 [ Y ] , pt0 [ Z ] ) ; raw . strokeWeight ( sw1 ) ; raw . stroke ( argb1 ) ; raw . vertex ( pt1 [ X ] , pt1 [ Y ] , pt1 [ Z ] ) ; } else if ( raw . is2D ( ) ) { float sx0 = screenXImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sy0 = screenYImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sx1 = screenXImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; float sy1 = screenYImpl ( pt1 [ 0 ] , pt1 [ 1 ] , pt1 [ 2 ] , pt1 [ 3 ] ) ; raw . strokeWeight ( sw0 ) ; raw . stroke ( argb0 ) ; raw . vertex ( sx0 , sy0 ) ; raw . strokeWeight ( sw1 ) ; raw . stroke ( argb1 ) ; raw . vertex ( sx1 , sy1 ) ; } } } raw . endShape ( ) ; } protected void flushPoints ( ) { updatePointBuffers ( ) ; PShader shader = getPointShader ( ) ; shader . bind ( ) ; IndexCache cache = tessGeo . pointIndexCache ; for ( int n = 0 ; n < cache . size ; n ++ ) { int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int voffset = cache . vertexOffset [ n ] ; shader . setVertexAttribute ( glPointVertex , 4 , PGL . FLOAT , 0 , 4 * voffset * PGL . SIZEOF_FLOAT ) ; shader . setColorAttribute ( glPointColor , 4 , PGL . UNSIGNED_BYTE , 0 , 4 * voffset * PGL . SIZEOF_BYTE ) ; shader . setPointAttribute ( glPointAttrib , 2 , PGL . FLOAT , 0 , 2 * voffset * PGL . SIZEOF_FLOAT ) ; shader . draw ( glPointIndex , icount , ioffset ) ; } shader . unbind ( ) ; unbindPointBuffers ( ) ; } void rawPoints ( ) { raw . colorMode ( RGB ) ; raw . noFill ( ) ; raw . strokeCap ( strokeCap ) ; raw . beginShape ( POINTS ) ; float [ ] vertices = tessGeo . pointVertices ; int [ ] color = tessGeo . pointColors ; float [ ] attribs = tessGeo . pointOffsets ; short [ ] indices = tessGeo . pointIndices ; IndexCache cache = tessGeo . pointIndexCache ; for ( int n = 0 ; n < cache . size ; n ++ ) { int ioffset = cache . indexOffset [ n ] ; int icount = cache . indexCount [ n ] ; int voffset = cache . vertexOffset [ n ] ; int pt = ioffset ; while ( pt < ( ioffset + icount ) / 3 ) { float size = attribs [ 2 * pt + 2 ] ; float weight ; int perim ; if ( 0 < size ) { weight = + size / 0.5f ; perim = PApplet . min ( MAX_POINT_ACCURACY , PApplet . max ( MIN_POINT_ACCURACY , ( int ) ( TWO_PI * weight / POINT_ACCURACY_FACTOR ) ) ) + 1 ; } else { weight = - size / 0.5f ; perim = 5 ; } int i0 = voffset + indices [ 3 * pt ] ; int argb0 = PGL . nativeToJavaARGB ( color [ i0 ] ) ; float [ ] pt0 = { 0 , 0 , 0 , 0 } ; if ( flushMode == FLUSH_CONTINUOUSLY ) { float [ ] src0 = { 0 , 0 , 0 , 0 } ; PApplet . arrayCopy ( vertices , 4 * i0 , src0 , 0 , 4 ) ; modelview . mult ( src0 , pt0 ) ; } else { PApplet . arrayCopy ( vertices , 4 * i0 , pt0 , 0 , 4 ) ; } if ( raw . is3D ( ) ) { raw . strokeWeight ( weight ) ; raw . stroke ( argb0 ) ; raw . vertex ( pt0 [ X ] , pt0 [ Y ] , pt0 [ Z ] ) ; } else if ( raw . is2D ( ) ) { float sx0 = screenXImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; float sy0 = screenYImpl ( pt0 [ 0 ] , pt0 [ 1 ] , pt0 [ 2 ] , pt0 [ 3 ] ) ; raw . strokeWeight ( weight ) ; raw . stroke ( argb0 ) ; raw . vertex ( sx0 , sy0 ) ; } pt += perim ; } } raw . endShape ( ) ; } @ Override public void bezierVertex ( float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { bezierVertexImpl ( x2 , y2 , 0 , x3 , y3 , 0 , x4 , y4 , 0 ) ; } @ Override public void bezierVertex ( float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { bezierVertexImpl ( x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; } protected void bezierVertexImpl ( float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { bezierVertexCheck ( shape , inGeo . vertexCount ) ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addBezierVertex ( x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 , vertexBreak ( ) ) ; } @ Override public void quadraticVertex ( float cx , float cy , float x3 , float y3 ) { quadraticVertexImpl ( cx , cy , 0 , x3 , y3 , 0 ) ; } @ Override public void quadraticVertex ( float cx , float cy , float cz , float x3 , float y3 , float z3 ) { quadraticVertexImpl ( cx , cy , cz , x3 , y3 , z3 ) ; } protected void quadraticVertexImpl ( float cx , float cy , float cz , float x3 , float y3 , float z3 ) { bezierVertexCheck ( shape , inGeo . vertexCount ) ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addQuadraticVertex ( cx , cy , cz , x3 , y3 , z3 , vertexBreak ( ) ) ; } @ Override public void curveVertex ( float x , float y ) { curveVertexImpl ( x , y , 0 ) ; } @ Override public void curveVertex ( float x , float y , float z ) { curveVertexImpl ( x , y , z ) ; } protected void curveVertexImpl ( float x , float y , float z ) { curveVertexCheck ( shape ) ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addCurveVertex ( x , y , z , vertexBreak ( ) ) ; } @ Override public void point ( float x , float y ) { pointImpl ( x , y , 0 ) ; } @ Override public void point ( float x , float y , float z ) { pointImpl ( x , y , z ) ; } protected void pointImpl ( float x , float y , float z ) { beginShape ( POINTS ) ; defaultEdges = false ; normalMode = NORMAL_MODE_SHAPE ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addPoint ( x , y , z , fill , stroke ) ; endShape ( ) ; } @ Override public void line ( float x1 , float y1 , float x2 , float y2 ) { lineImpl ( x1 , y1 , 0 , x2 , y2 , 0 ) ; } @ Override public void line ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { lineImpl ( x1 , y1 , z1 , x2 , y2 , z2 ) ; } protected void lineImpl ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { beginShape ( LINES ) ; defaultEdges = false ; normalMode = NORMAL_MODE_SHAPE ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addLine ( x1 , y1 , z1 , x2 , y2 , z2 , fill , stroke ) ; endShape ( ) ; } @ Override public void triangle ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { beginShape ( TRIANGLES ) ; defaultEdges = false ; normalMode = NORMAL_MODE_SHAPE ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addTriangle ( x1 , y1 , 0 , x2 , y2 , 0 , x3 , y3 , 0 , fill , stroke ) ; endShape ( ) ; } @ Override public void quad ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { beginShape ( QUADS ) ; defaultEdges = false ; normalMode = NORMAL_MODE_SHAPE ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addQuad ( x1 , y1 , 0 , x2 , y2 , 0 , x3 , y3 , 0 , x4 , y4 , 0 , stroke ) ; endShape ( ) ; } @ Override protected void rectImpl ( float x1 , float y1 , float x2 , float y2 , float tl , float tr , float br , float bl ) { beginShape ( POLYGON ) ; defaultEdges = false ; normalMode = NORMAL_MODE_SHAPE ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addRect ( x1 , y1 , x2 , y2 , tl , tr , br , bl , stroke ) ; endShape ( CLOSE ) ; } @ Override public void ellipseImpl ( float a , float b , float c , float d ) { beginShape ( TRIANGLE_FAN ) ; defaultEdges = false ; normalMode = NORMAL_MODE_SHAPE ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addEllipse ( a , b , c , d , fill , stroke ) ; endShape ( ) ; } @ Override protected void arcImpl ( float x , float y , float w , float h , float start , float stop , int mode ) { beginShape ( TRIANGLE_FAN ) ; defaultEdges = false ; normalMode = NORMAL_MODE_SHAPE ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . setNormal ( normalX , normalY , normalZ ) ; inGeo . addArc ( x , y , w , h , start , stop , fill , stroke , mode ) ; endShape ( ) ; } @ Override public void box ( float w , float h , float d ) { beginShape ( QUADS ) ; defaultEdges = false ; normalMode = NORMAL_MODE_VERTEX ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; inGeo . addBox ( w , h , d , fill , stroke ) ; endShape ( ) ; } @ Override public void sphere ( float r ) { if ( ( sphereDetailU < 3 ) || ( sphereDetailV < 2 ) ) { sphereDetail ( 30 ) ; } beginShape ( TRIANGLES ) ; defaultEdges = false ; normalMode = NORMAL_MODE_VERTEX ; inGeo . setMaterial ( fillColor , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininess ) ; int [ ] indices = inGeo . addSphere ( r , sphereDetailU , sphereDetailV , fill , stroke ) ; endShape ( indices ) ; } @ Override protected void shape ( PShape shape , float x , float y , float z ) { if ( shape . isVisible ( ) ) { flush ( ) ; pushMatrix ( ) ; if ( shapeMode == CENTER ) { translate ( x - shape . getWidth ( ) / 2 , y - shape . getHeight ( ) / 2 , z - shape . getDepth ( ) / 2 ) ; } else if ( ( shapeMode == CORNER ) || ( shapeMode == CORNERS ) ) { translate ( x , y , z ) ; } shape . draw ( this ) ; popMatrix ( ) ; } } @ Override protected void shape ( PShape shape , float x , float y , float z , float c , float d , float e ) { if ( shape . isVisible ( ) ) { flush ( ) ; pushMatrix ( ) ; if ( shapeMode == CENTER ) { translate ( x - c / 2f , y - d / 2f , z - e / 2f ) ; scale ( c / shape . getWidth ( ) , d / shape . getHeight ( ) , e / shape . getDepth ( ) ) ; } else if ( shapeMode == CORNER ) { translate ( x , y , z ) ; scale ( c / shape . getWidth ( ) , d / shape . getHeight ( ) , e / shape . getDepth ( ) ) ; } else if ( shapeMode == CORNERS ) { c -= x ; d -= y ; e -= z ; translate ( x , y , z ) ; scale ( c / shape . getWidth ( ) , d / shape . getHeight ( ) , e / shape . getDepth ( ) ) ; } shape . draw ( this ) ; popMatrix ( ) ; } } @ Override public PShape loadShape ( String filename ) { String ext = PApplet . getExtension ( filename ) ; if ( PGraphics2D . isSupportedExtension ( ext ) ) { return PGraphics2D . loadShapeImpl ( this , filename , ext ) ; } if ( PGraphics3D . isSupportedExtension ( ext ) ) { return PGraphics3D . loadShapeImpl ( this , filename , ext ) ; } else { PGraphics . showWarning ( UNSUPPORTED_SHAPE_FORMAT_ERROR ) ; return null ; } } @ Override protected boolean textModeCheck ( int mode ) { return mode == MODEL || ( mode == SHAPE && PGL . SHAPE_TEXT_SUPPORTED ) ; } @ Override public float textAscent ( ) { if ( textFont == null ) defaultFontOrDeath ( "textAscent" ) ; Font font = ( Font ) textFont . getNative ( ) ; float ascent = 0 ; if ( font != null ) ascent = pgl . getFontAscent ( font ) ; if ( ascent == 0 ) ascent = super . textAscent ( ) ; return ascent ; } @ Override public float textDescent ( ) { if ( textFont == null ) defaultFontOrDeath ( "textAscent" ) ; Font font = ( Font ) textFont . getNative ( ) ; float descent = 0 ; if ( font != null ) descent = pgl . getFontDescent ( font ) ; if ( descent == 0 ) descent = super . textDescent ( ) ; return descent ; } @ Override protected float textWidthImpl ( char buffer [ ] , int start , int stop ) { Font font = ( Font ) textFont . getNative ( ) ; float twidth = 0 ; if ( font != null ) twidth = pgl . getTextWidth ( font , buffer , start , stop ) ; if ( twidth == 0 ) twidth = super . textWidthImpl ( buffer , start , stop ) ; return twidth ; } @ Override public void textSize ( float size ) { if ( textFont == null ) defaultFontOrDeath ( "textSize" , size ) ; Font font = ( Font ) textFont . getNative ( ) ; if ( font != null ) { Object dfont = pgl . getDerivedFont ( font , size ) ; textFont . setNative ( dfont ) ; } super . textSize ( size ) ; } @ Override protected void textLineImpl ( char buffer [ ] , int start , int stop , float x , float y ) { if ( textMode == MODEL ) { textTex = getFontTexture ( textFont ) ; if ( textTex == null || textTex . contextIsOutdated ( ) ) { textTex = new FontTexture ( this , textFont , is3D ( ) ) ; setFontTexture ( textFont , textTex ) ; } textTex . begin ( ) ; int savedTextureMode = textureMode ; boolean savedStroke = stroke ; float savedNormalX = normalX ; float savedNormalY = normalY ; float savedNormalZ = normalZ ; boolean savedTint = tint ; int savedTintColor = tintColor ; int savedBlendMode = blendMode ; textureMode = NORMAL ; stroke = false ; normalX = 0 ; normalY = 0 ; normalZ = 1 ; tint = true ; tintColor = fillColor ; blendMode ( BLEND ) ; super . textLineImpl ( buffer , start , stop , x , y ) ; textureMode = savedTextureMode ; stroke = savedStroke ; normalX = savedNormalX ; normalY = savedNormalY ; normalZ = savedNormalZ ; tint = savedTint ; tintColor = savedTintColor ; blendMode ( savedBlendMode ) ; textTex . end ( ) ; } else if ( textMode == SHAPE ) { super . textLineImpl ( buffer , start , stop , x , y ) ; } } @ Override protected void textCharImpl ( char ch , float x , float y ) { PFont . Glyph glyph = textFont . getGlyph ( ch ) ; if ( glyph != null ) { if ( textMode == MODEL ) { FontTexture . TextureInfo tinfo = textTex . getTexInfo ( glyph ) ; if ( tinfo == null ) { tinfo = textTex . addToTexture ( this , glyph ) ; } float high = glyph . height / ( float ) textFont . getSize ( ) ; float bwidth = glyph . width / ( float ) textFont . getSize ( ) ; float lextent = glyph . leftExtent / ( float ) textFont . getSize ( ) ; float textent = glyph . topExtent / ( float ) textFont . getSize ( ) ; float x1 = x + lextent * textSize ; float y1 = y - textent * textSize ; float x2 = x1 + bwidth * textSize ; float y2 = y1 + high * textSize ; textCharModelImpl ( tinfo , x1 , y1 , x2 , y2 ) ; } else if ( textMode == SHAPE ) { textCharShapeImpl ( ch , x , y ) ; } } } protected void textCharModelImpl ( FontTexture . TextureInfo info , float x0 , float y0 , float x1 , float y1 ) { if ( textTex . currentTex != info . texIndex ) { textTex . setTexture ( info . texIndex ) ; } beginShape ( QUADS ) ; texture ( textTex . getCurrentTexture ( ) ) ; vertex ( x0 , y0 , info . u0 , info . v0 ) ; vertex ( x1 , y0 , info . u1 , info . v0 ) ; vertex ( x1 , y1 , info . u1 , info . v1 ) ; vertex ( x0 , y1 , info . u0 , info . v1 ) ; endShape ( ) ; } protected void textCharShapeImpl ( char ch , float x , float y ) { boolean strokeSaved = stroke ; stroke = false ; PGL . FontOutline outline = pgl . createFontOutline ( ch , textFont . getNative ( ) ) ; float textPoints [ ] = new float [ 6 ] ; float lastX = 0 ; float lastY = 0 ; boolean open = false ; beginShape ( ) ; while ( ! outline . isDone ( ) ) { int type = outline . currentSegment ( textPoints ) ; if ( ! open ) { beginContour ( ) ; open = true ; } if ( type == PGL . SEG_MOVETO || type == PGL . SEG_LINETO ) { vertex ( x + textPoints [ 0 ] , y + textPoints [ 1 ] ) ; lastX = textPoints [ 0 ] ; lastY = textPoints [ 1 ] ; } else if ( type == PGL . SEG_QUADTO ) { for ( int i = 1 ; i < bezierDetail ; i ++ ) { float t = ( float ) i / ( float ) bezierDetail ; vertex ( x + bezierPoint ( lastX , lastX + ( float ) ( ( textPoints [ 0 ] - lastX ) * 2 / 3.0 ) , textPoints [ 2 ] + ( float ) ( ( textPoints [ 0 ] - textPoints [ 2 ] ) * 2 / 3.0 ) , textPoints [ 2 ] , t ) , y + bezierPoint ( lastY , lastY + ( float ) ( ( textPoints [ 1 ] - lastY ) * 2 / 3.0 ) , textPoints [ 3 ] + ( float ) ( ( textPoints [ 1 ] - textPoints [ 3 ] ) * 2 / 3.0 ) , textPoints [ 3 ] , t ) ) ; } lastX = textPoints [ 2 ] ; lastY = textPoints [ 3 ] ; } else if ( type == PGL . SEG_CUBICTO ) { for ( int i = 1 ; i < bezierDetail ; i ++ ) { float t = ( float ) i / ( float ) bezierDetail ; vertex ( x + bezierPoint ( lastX , textPoints [ 0 ] , textPoints [ 2 ] , textPoints [ 4 ] , t ) , y + bezierPoint ( lastY , textPoints [ 1 ] , textPoints [ 3 ] , textPoints [ 5 ] , t ) ) ; } lastX = textPoints [ 4 ] ; lastY = textPoints [ 5 ] ; } else if ( type == PGL . SEG_CLOSE ) { endContour ( ) ; open = false ; } outline . next ( ) ; } endShape ( ) ; stroke = strokeSaved ; } @ Override public void pushMatrix ( ) { if ( modelviewStackDepth == MATRIX_STACK_DEPTH ) { throw new RuntimeException ( ERROR_PUSHMATRIX_OVERFLOW ) ; } modelview . get ( modelviewStack [ modelviewStackDepth ] ) ; modelviewInv . get ( modelviewInvStack [ modelviewStackDepth ] ) ; camera . get ( cameraStack [ modelviewStackDepth ] ) ; cameraInv . get ( cameraInvStack [ modelviewStackDepth ] ) ; modelviewStackDepth ++ ; } @ Override public void popMatrix ( ) { if ( modelviewStackDepth == 0 ) { throw new RuntimeException ( ERROR_PUSHMATRIX_UNDERFLOW ) ; } modelviewStackDepth -- ; modelview . set ( modelviewStack [ modelviewStackDepth ] ) ; modelviewInv . set ( modelviewInvStack [ modelviewStackDepth ] ) ; camera . set ( cameraStack [ modelviewStackDepth ] ) ; cameraInv . set ( cameraInvStack [ modelviewStackDepth ] ) ; updateProjmodelview ( ) ; } @ Override public void translate ( float tx , float ty ) { translateImpl ( tx , ty , 0 ) ; } @ Override public void translate ( float tx , float ty , float tz ) { translateImpl ( tx , ty , tz ) ; } protected void translateImpl ( float tx , float ty , float tz ) { modelview . translate ( tx , ty , tz ) ; invTranslate ( modelviewInv , tx , ty , tz ) ; projmodelview . translate ( tx , ty , tz ) ; } static protected void invTranslate ( PMatrix3D matrix , float tx , float ty , float tz ) { matrix . preApply ( 1 , 0 , 0 , - tx , 0 , 1 , 0 , - ty , 0 , 0 , 1 , - tz , 0 , 0 , 0 , 1 ) ; } @ Override public void rotate ( float angle ) { rotateImpl ( angle , 0 , 0 , 1 ) ; } @ Override public void rotateX ( float angle ) { rotateImpl ( angle , 1 , 0 , 0 ) ; } @ Override public void rotateY ( float angle ) { rotateImpl ( angle , 0 , 1 , 0 ) ; } @ Override public void rotateZ ( float angle ) { rotateImpl ( angle , 0 , 0 , 1 ) ; } @ Override public void rotate ( float angle , float v0 , float v1 , float v2 ) { rotateImpl ( angle , v0 , v1 , v2 ) ; } protected void rotateImpl ( float angle , float v0 , float v1 , float v2 ) { float norm2 = v0 * v0 + v1 * v1 + v2 * v2 ; if ( zero ( norm2 ) ) { return ; } if ( diff ( norm2 , 1 ) ) { float norm = PApplet . sqrt ( norm2 ) ; v0 /= norm ; v1 /= norm ; v2 /= norm ; } modelview . rotate ( angle , v0 , v1 , v2 ) ; invRotate ( modelviewInv , angle , v0 , v1 , v2 ) ; updateProjmodelview ( ) ; } static private void invRotate ( PMatrix3D matrix , float angle , float v0 , float v1 , float v2 ) { float c = PApplet . cos ( - angle ) ; float s = PApplet . sin ( - angle ) ; float t = 1.0f - c ; matrix . preApply ( ( t * v0 * v0 ) + c , ( t * v0 * v1 ) - ( s * v2 ) , ( t * v0 * v2 ) + ( s * v1 ) , 0 , ( t * v0 * v1 ) + ( s * v2 ) , ( t * v1 * v1 ) + c , ( t * v1 * v2 ) - ( s * v0 ) , 0 , ( t * v0 * v2 ) - ( s * v1 ) , ( t * v1 * v2 ) + ( s * v0 ) , ( t * v2 * v2 ) + c , 0 , 0 , 0 , 0 , 1 ) ; } @ Override public void scale ( float s ) { scaleImpl ( s , s , s ) ; } @ Override public void scale ( float sx , float sy ) { scaleImpl ( sx , sy , 1 ) ; } @ Override public void scale ( float sx , float sy , float sz ) { scaleImpl ( sx , sy , sz ) ; } protected void scaleImpl ( float sx , float sy , float sz ) { modelview . scale ( sx , sy , sz ) ; invScale ( modelviewInv , sx , sy , sz ) ; projmodelview . scale ( sx , sy , sz ) ; } static protected void invScale ( PMatrix3D matrix , float x , float y , float z ) { matrix . preApply ( 1 / x , 0 , 0 , 0 , 0 , 1 / y , 0 , 0 , 0 , 0 , 1 / z , 0 , 0 , 0 , 0 , 1 ) ; } @ Override public void shearX ( float angle ) { float t = ( float ) Math . tan ( angle ) ; applyMatrixImpl ( 1 , t , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } @ Override public void shearY ( float angle ) { float t = ( float ) Math . tan ( angle ) ; applyMatrixImpl ( 1 , 0 , 0 , 0 , t , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } @ Override public void resetMatrix ( ) { modelview . reset ( ) ; modelviewInv . reset ( ) ; projmodelview . set ( projection ) ; camera . reset ( ) ; cameraInv . reset ( ) ; } @ Override public void applyMatrix ( PMatrix2D source ) { applyMatrixImpl ( source . m00 , source . m01 , 0 , source . m02 , source . m10 , source . m11 , 0 , source . m12 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } @ Override public void applyMatrix ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) { applyMatrixImpl ( n00 , n01 , 0 , n02 , n10 , n11 , 0 , n12 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } @ Override public void applyMatrix ( PMatrix3D source ) { applyMatrixImpl ( source . m00 , source . m01 , source . m02 , source . m03 , source . m10 , source . m11 , source . m12 , source . m13 , source . m20 , source . m21 , source . m22 , source . m23 , source . m30 , source . m31 , source . m32 , source . m33 ) ; } @ Override public void applyMatrix ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { applyMatrixImpl ( n00 , n01 , n02 , n03 , n10 , n11 , n12 , n13 , n20 , n21 , n22 , n23 , n30 , n31 , n32 , n33 ) ; } protected void applyMatrixImpl ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { modelview . apply ( n00 , n01 , n02 , n03 , n10 , n11 , n12 , n13 , n20 , n21 , n22 , n23 , n30 , n31 , n32 , n33 ) ; modelviewInv . set ( modelview ) ; modelviewInv . invert ( ) ; projmodelview . apply ( n00 , n01 , n02 , n03 , n10 , n11 , n12 , n13 , n20 , n21 , n22 , n23 , n30 , n31 , n32 , n33 ) ; } protected void begin2D ( ) { } protected void end2D ( ) { } @ Override public PMatrix getMatrix ( ) { return modelview . get ( ) ; } @ Override public PMatrix3D getMatrix ( PMatrix3D target ) { if ( target == null ) { target = new PMatrix3D ( ) ; } target . set ( modelview ) ; return target ; } @ Override public void setMatrix ( PMatrix2D source ) { resetMatrix ( ) ; applyMatrix ( source ) ; } @ Override public void setMatrix ( PMatrix3D source ) { resetMatrix ( ) ; applyMatrix ( source ) ; } @ Override public void printMatrix ( ) { modelview . print ( ) ; } public void pushProjection ( ) { if ( projectionStackDepth == MATRIX_STACK_DEPTH ) { throw new RuntimeException ( ERROR_PUSHMATRIX_OVERFLOW ) ; } projection . get ( projectionStack [ projectionStackDepth ] ) ; projectionStackDepth ++ ; } public void popProjection ( ) { flush ( ) ; if ( projectionStackDepth == 0 ) { throw new RuntimeException ( ERROR_PUSHMATRIX_UNDERFLOW ) ; } projectionStackDepth -- ; projection . set ( projectionStack [ projectionStackDepth ] ) ; updateProjmodelview ( ) ; } public void resetProjection ( ) { flush ( ) ; projection . reset ( ) ; updateProjmodelview ( ) ; } public void applyProjection ( PMatrix3D mat ) { flush ( ) ; projection . apply ( mat ) ; updateProjmodelview ( ) ; } public void applyProjection ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { flush ( ) ; projection . apply ( n00 , n01 , n02 , n03 , n10 , n11 , n12 , n13 , n20 , n21 , n22 , n23 , n30 , n31 , n32 , n33 ) ; updateProjmodelview ( ) ; } public void setProjection ( PMatrix3D mat ) { flush ( ) ; projection . set ( mat ) ; updateProjmodelview ( ) ; } protected boolean orthoProjection ( ) { return zero ( projection . m01 ) && zero ( projection . m02 ) && zero ( projection . m10 ) && zero ( projection . m12 ) && zero ( projection . m20 ) && zero ( projection . m21 ) && zero ( projection . m30 ) && zero ( projection . m31 ) && zero ( projection . m32 ) && same ( projection . m33 , 1 ) ; } protected boolean nonOrthoProjection ( ) { return nonZero ( projection . m01 ) || nonZero ( projection . m02 ) || nonZero ( projection . m10 ) || nonZero ( projection . m12 ) || nonZero ( projection . m20 ) || nonZero ( projection . m21 ) || nonZero ( projection . m30 ) || nonZero ( projection . m31 ) || nonZero ( projection . m32 ) || diff ( projection . m33 , 1 ) ; } protected static boolean same ( float a , float b ) { return Math . abs ( a - b ) < PGL . FLOAT_EPS ; } protected static boolean diff ( float a , float b ) { return PGL . FLOAT_EPS <= Math . abs ( a - b ) ; } protected static boolean zero ( float a ) { return Math . abs ( a ) < PGL . FLOAT_EPS ; } protected static boolean nonZero ( float a ) { return PGL . FLOAT_EPS <= Math . abs ( a ) ; } @ Override public void beginCamera ( ) { if ( manipulatingCamera ) { throw new RuntimeException ( "beginCamera() cannot be called again " + "before endCamera()" ) ; } else { manipulatingCamera = true ; } } @ Override public void endCamera ( ) { if ( ! manipulatingCamera ) { throw new RuntimeException ( "Cannot call endCamera() " + "without first calling beginCamera()" ) ; } camera . set ( modelview ) ; cameraInv . set ( modelviewInv ) ; manipulatingCamera = false ; } @ Override public void camera ( ) { camera ( cameraX , cameraY , cameraZ , cameraX , cameraY , 0 , 0 , 1 , 0 ) ; } @ Override public void camera ( float eyeX , float eyeY , float eyeZ , float centerX , float centerY , float centerZ , float upX , float upY , float upZ ) { float z0 = eyeX - centerX ; float z1 = eyeY - centerY ; float z2 = eyeZ - centerZ ; eyeDist = PApplet . sqrt ( z0 * z0 + z1 * z1 + z2 * z2 ) ; if ( nonZero ( eyeDist ) ) { z0 /= eyeDist ; z1 /= eyeDist ; z2 /= eyeDist ; } float y0 = upX ; float y1 = upY ; float y2 = upZ ; float x0 = y1 * z2 - y2 * z1 ; float x1 = - y0 * z2 + y2 * z0 ; float x2 = y0 * z1 - y1 * z0 ; y0 = z1 * x2 - z2 * x1 ; y1 = - z0 * x2 + z2 * x0 ; y2 = z0 * x1 - z1 * x0 ; float xmag = PApplet . sqrt ( x0 * x0 + x1 * x1 + x2 * x2 ) ; if ( nonZero ( xmag ) ) { x0 /= xmag ; x1 /= xmag ; x2 /= xmag ; } float ymag = PApplet . sqrt ( y0 * y0 + y1 * y1 + y2 * y2 ) ; if ( nonZero ( ymag ) ) { y0 /= ymag ; y1 /= ymag ; y2 /= ymag ; } modelview . set ( x0 , x1 , x2 , 0 , y0 , y1 , y2 , 0 , z0 , z1 , z2 , 0 , 0 , 0 , 0 , 1 ) ; float tx = - eyeX ; float ty = - eyeY ; float tz = - eyeZ ; modelview . translate ( tx , ty , tz ) ; modelviewInv . set ( modelview ) ; modelviewInv . invert ( ) ; camera . set ( modelview ) ; cameraInv . set ( modelviewInv ) ; updateProjmodelview ( ) ; } @ Override public void printCamera ( ) { camera . print ( ) ; } protected void defaultCamera ( ) { camera ( ) ; } @ Override public void ortho ( ) { ortho ( - width / 2f , width / 2f , - height / 2f , height / 2f , 0 , eyeDist * 10 ) ; } @ Override public void ortho ( float left , float right , float bottom , float top ) { ortho ( left , right , bottom , top , 0 , eyeDist * 10 ) ; } @ Override public void ortho ( float left , float right , float bottom , float top , float near , float far ) { float w = right - left ; float h = top - bottom ; float d = far - near ; flush ( ) ; float x = + 2.0f / w ; float y = + 2.0f / h ; float z = - 2.0f / d ; float tx = - ( right + left ) / w ; float ty = - ( top + bottom ) / h ; float tz = - ( far + near ) / d ; projection . set ( x , 0 , 0 , tx , 0 , - y , 0 , ty , 0 , 0 , z , tz , 0 , 0 , 0 , 1 ) ; updateProjmodelview ( ) ; } @ Override public void perspective ( ) { perspective ( cameraFOV , cameraAspect , cameraNear , cameraFar ) ; } @ Override public void perspective ( float fov , float aspect , float zNear , float zFar ) { float ymax = zNear * ( float ) Math . tan ( fov / 2 ) ; float ymin = - ymax ; float xmin = ymin * aspect ; float xmax = ymax * aspect ; frustum ( xmin , xmax , ymin , ymax , zNear , zFar ) ; } @ Override public void frustum ( float left , float right , float bottom , float top , float znear , float zfar ) { flush ( ) ; float n2 = 2 * znear ; float w = right - left ; float h = top - bottom ; float d = zfar - znear ; projection . set ( n2 / w , 0 , ( right + left ) / w , 0 , 0 , - n2 / h , ( top + bottom ) / h , 0 , 0 , 0 , - ( zfar + znear ) / d , - ( n2 * zfar ) / d , 0 , 0 , - 1 , 0 ) ; updateProjmodelview ( ) ; } @ Override public void printProjection ( ) { projection . print ( ) ; } protected void defaultPerspective ( ) { perspective ( ) ; } @ Override public float screenX ( float x , float y ) { return screenXImpl ( x , y , 0 ) ; } @ Override public float screenY ( float x , float y ) { return screenYImpl ( x , y , 0 ) ; } @ Override public float screenX ( float x , float y , float z ) { return screenXImpl ( x , y , z ) ; } @ Override public float screenY ( float x , float y , float z ) { return screenYImpl ( x , y , z ) ; } @ Override public float screenZ ( float x , float y , float z ) { return screenZImpl ( x , y , z ) ; } protected float screenXImpl ( float x , float y , float z ) { float ax = modelview . m00 * x + modelview . m01 * y + modelview . m02 * z + modelview . m03 ; float ay = modelview . m10 * x + modelview . m11 * y + modelview . m12 * z + modelview . m13 ; float az = modelview . m20 * x + modelview . m21 * y + modelview . m22 * z + modelview . m23 ; float aw = modelview . m30 * x + modelview . m31 * y + modelview . m32 * z + modelview . m33 ; return screenXImpl ( ax , ay , az , aw ) ; } protected float screenXImpl ( float x , float y , float z , float w ) { float ox = projection . m00 * x + projection . m01 * y + projection . m02 * z + projection . m03 * w ; float ow = projection . m30 * x + projection . m31 * y + projection . m32 * z + projection . m33 * w ; if ( nonZero ( ow ) ) { ox /= ow ; } float sx = width * ( 1 + ox ) / 2.0f ; return sx ; } protected float screenYImpl ( float x , float y , float z ) { float ax = modelview . m00 * x + modelview . m01 * y + modelview . m02 * z + modelview . m03 ; float ay = modelview . m10 * x + modelview . m11 * y + modelview . m12 * z + modelview . m13 ; float az = modelview . m20 * x + modelview . m21 * y + modelview . m22 * z + modelview . m23 ; float aw = modelview . m30 * x + modelview . m31 * y + modelview . m32 * z + modelview . m33 ; return screenYImpl ( ax , ay , az , aw ) ; } protected float screenYImpl ( float x , float y , float z , float w ) { float oy = projection . m10 * x + projection . m11 * y + projection . m12 * z + projection . m13 * w ; float ow = projection . m30 * x + projection . m31 * y + projection . m32 * z + projection . m33 * w ; if ( nonZero ( ow ) ) { oy /= ow ; } float sy = height * ( 1 + oy ) / 2.0f ; sy = height - sy ; return sy ; } protected float screenZImpl ( float x , float y , float z ) { float ax = modelview . m00 * x + modelview . m01 * y + modelview . m02 * z + modelview . m03 ; float ay = modelview . m10 * x + modelview . m11 * y + modelview . m12 * z + modelview . m13 ; float az = modelview . m20 * x + modelview . m21 * y + modelview . m22 * z + modelview . m23 ; float aw = modelview . m30 * x + modelview . m31 * y + modelview . m32 * z + modelview . m33 ; return screenZImpl ( ax , ay , az , aw ) ; } protected float screenZImpl ( float x , float y , float z , float w ) { float oz = projection . m20 * x + projection . m21 * y + projection . m22 * z + projection . m23 * w ; float ow = projection . m30 * x + projection . m31 * y + projection . m32 * z + projection . m33 * w ; if ( nonZero ( ow ) ) { oz /= ow ; } float sz = ( oz + 1 ) / 2.0f ; return sz ; } @ Override public float modelX ( float x , float y , float z ) { float ax = modelview . m00 * x + modelview . m01 * y + modelview . m02 * z + modelview . m03 ; float ay = modelview . m10 * x + modelview . m11 * y + modelview . m12 * z + modelview . m13 ; float az = modelview . m20 * x + modelview . m21 * y + modelview . m22 * z + modelview . m23 ; float aw = modelview . m30 * x + modelview . m31 * y + modelview . m32 * z + modelview . m33 ; float ox = cameraInv . m00 * ax + cameraInv . m01 * ay + cameraInv . m02 * az + cameraInv . m03 * aw ; float ow = cameraInv . m30 * ax + cameraInv . m31 * ay + cameraInv . m32 * az + cameraInv . m33 * aw ; return nonZero ( ow ) ? ox / ow : ox ; } @ Override public float modelY ( float x , float y , float z ) { float ax = modelview . m00 * x + modelview . m01 * y + modelview . m02 * z + modelview . m03 ; float ay = modelview . m10 * x + modelview . m11 * y + modelview . m12 * z + modelview . m13 ; float az = modelview . m20 * x + modelview . m21 * y + modelview . m22 * z + modelview . m23 ; float aw = modelview . m30 * x + modelview . m31 * y + modelview . m32 * z + modelview . m33 ; float oy = cameraInv . m10 * ax + cameraInv . m11 * ay + cameraInv . m12 * az + cameraInv . m13 * aw ; float ow = cameraInv . m30 * ax + cameraInv . m31 * ay + cameraInv . m32 * az + cameraInv . m33 * aw ; return nonZero ( ow ) ? oy / ow : oy ; } @ Override public float modelZ ( float x , float y , float z ) { float ax = modelview . m00 * x + modelview . m01 * y + modelview . m02 * z + modelview . m03 ; float ay = modelview . m10 * x + modelview . m11 * y + modelview . m12 * z + modelview . m13 ; float az = modelview . m20 * x + modelview . m21 * y + modelview . m22 * z + modelview . m23 ; float aw = modelview . m30 * x + modelview . m31 * y + modelview . m32 * z + modelview . m33 ; float oz = cameraInv . m20 * ax + cameraInv . m21 * ay + cameraInv . m22 * az + cameraInv . m23 * aw ; float ow = cameraInv . m30 * ax + cameraInv . m31 * ay + cameraInv . m32 * az + cameraInv . m33 * aw ; return nonZero ( ow ) ? oz / ow : oz ; } @ Override public void popStyle ( ) { boolean savedSetAmbient = setAmbient ; super . popStyle ( ) ; if ( ! savedSetAmbient ) setAmbient = false ; } @ Override public void strokeWeight ( float weight ) { this . strokeWeight = weight ; } @ Override public void strokeJoin ( int join ) { this . strokeJoin = join ; } @ Override public void strokeCap ( int cap ) { this . strokeCap = cap ; } @ Override protected void fillFromCalc ( ) { super . fillFromCalc ( ) ; if ( ! setAmbient ) { ambientFromCalc ( ) ; setAmbient = false ; } } @ Override public void lights ( ) { enableLighting ( ) ; lightCount = 0 ; int colorModeSaved = colorMode ; colorMode = RGB ; lightFalloff ( 1 , 0 , 0 ) ; lightSpecular ( 0 , 0 , 0 ) ; ambientLight ( colorModeX * 0.5f , colorModeY * 0.5f , colorModeZ * 0.5f ) ; directionalLight ( colorModeX * 0.5f , colorModeY * 0.5f , colorModeZ * 0.5f , 0 , 0 , - 1 ) ; colorMode = colorModeSaved ; } @ Override public void noLights ( ) { disableLighting ( ) ; lightCount = 0 ; } @ Override public void ambientLight ( float r , float g , float b ) { ambientLight ( r , g , b , 0 , 0 , 0 ) ; } @ Override public void ambientLight ( float r , float g , float b , float x , float y , float z ) { enableLighting ( ) ; if ( lightCount == PGL . MAX_LIGHTS ) { throw new RuntimeException ( "can only create " + PGL . MAX_LIGHTS + " lights" ) ; } lightType [ lightCount ] = AMBIENT ; lightPosition ( lightCount , x , y , z , false ) ; lightNormal ( lightCount , 0 , 0 , 0 ) ; lightAmbient ( lightCount , r , g , b ) ; noLightDiffuse ( lightCount ) ; noLightSpecular ( lightCount ) ; noLightSpot ( lightCount ) ; lightFalloff ( lightCount , currentLightFalloffConstant , currentLightFalloffLinear , currentLightFalloffQuadratic ) ; lightCount ++ ; } @ Override public void directionalLight ( float r , float g , float b , float dx , float dy , float dz ) { enableLighting ( ) ; if ( lightCount == PGL . MAX_LIGHTS ) { throw new RuntimeException ( "can only create " + PGL . MAX_LIGHTS + " lights" ) ; } lightType [ lightCount ] = DIRECTIONAL ; lightPosition ( lightCount , 0 , 0 , 0 , true ) ; lightNormal ( lightCount , dx , dy , dz ) ; noLightAmbient ( lightCount ) ; lightDiffuse ( lightCount , r , g , b ) ; lightSpecular ( lightCount , currentLightSpecular [ 0 ] , currentLightSpecular [ 1 ] , currentLightSpecular [ 2 ] ) ; noLightSpot ( lightCount ) ; noLightFalloff ( lightCount ) ; lightCount ++ ; } @ Override public void pointLight ( float r , float g , float b , float x , float y , float z ) { enableLighting ( ) ; if ( lightCount == PGL . MAX_LIGHTS ) { throw new RuntimeException ( "can only create " + PGL . MAX_LIGHTS + " lights" ) ; } lightType [ lightCount ] = POINT ; lightPosition ( lightCount , x , y , z , false ) ; lightNormal ( lightCount , 0 , 0 , 0 ) ; noLightAmbient ( lightCount ) ; lightDiffuse ( lightCount , r , g , b ) ; lightSpecular ( lightCount , currentLightSpecular [ 0 ] , currentLightSpecular [ 1 ] , currentLightSpecular [ 2 ] ) ; noLightSpot ( lightCount ) ; lightFalloff ( lightCount , currentLightFalloffConstant , currentLightFalloffLinear , currentLightFalloffQuadratic ) ; lightCount ++ ; } @ Override public void spotLight ( float r , float g , float b , float x , float y , float z , float dx , float dy , float dz , float angle , float concentration ) { enableLighting ( ) ; if ( lightCount == PGL . MAX_LIGHTS ) { throw new RuntimeException ( "can only create " + PGL . MAX_LIGHTS + " lights" ) ; } lightType [ lightCount ] = SPOT ; lightPosition ( lightCount , x , y , z , false ) ; lightNormal ( lightCount , dx , dy , dz ) ; noLightAmbient ( lightCount ) ; lightDiffuse ( lightCount , r , g , b ) ; lightSpecular ( lightCount , currentLightSpecular [ 0 ] , currentLightSpecular [ 1 ] , currentLightSpecular [ 2 ] ) ; lightSpot ( lightCount , angle , concentration ) ; lightFalloff ( lightCount , currentLightFalloffConstant , currentLightFalloffLinear , currentLightFalloffQuadratic ) ; lightCount ++ ; } @ Override public void lightFalloff ( float constant , float linear , float quadratic ) { currentLightFalloffConstant = constant ; currentLightFalloffLinear = linear ; currentLightFalloffQuadratic = quadratic ; } @ Override public void lightSpecular ( float x , float y , float z ) { colorCalc ( x , y , z ) ; currentLightSpecular [ 0 ] = calcR ; currentLightSpecular [ 1 ] = calcG ; currentLightSpecular [ 2 ] = calcB ; } protected void enableLighting ( ) { if ( ! lights ) { flush ( ) ; lights = true ; } } protected void disableLighting ( ) { if ( lights ) { flush ( ) ; lights = false ; } } protected void lightPosition ( int num , float x , float y , float z , boolean dir ) { lightPosition [ 4 * num + 0 ] = x * modelview . m00 + y * modelview . m01 + z * modelview . m02 + modelview . m03 ; lightPosition [ 4 * num + 1 ] = x * modelview . m10 + y * modelview . m11 + z * modelview . m12 + modelview . m13 ; lightPosition [ 4 * num + 2 ] = x * modelview . m20 + y * modelview . m21 + z * modelview . m22 + modelview . m23 ; lightPosition [ 4 * num + 3 ] = dir ? 1 : 0 ; } protected void lightNormal ( int num , float dx , float dy , float dz ) { float nx = dx * modelviewInv . m00 + dy * modelviewInv . m10 + dz * modelviewInv . m20 ; float ny = dx * modelviewInv . m01 + dy * modelviewInv . m11 + dz * modelviewInv . m21 ; float nz = dx * modelviewInv . m02 + dy * modelviewInv . m12 + dz * modelviewInv . m22 ; float d = PApplet . dist ( 0 , 0 , 0 , nx , ny , nz ) ; if ( 0 < d ) { float invn = 1.0f / d ; lightNormal [ 3 * num + 0 ] = invn * nx ; lightNormal [ 3 * num + 1 ] = invn * ny ; lightNormal [ 3 * num + 2 ] = invn * nz ; } else { lightNormal [ 3 * num + 0 ] = 0 ; lightNormal [ 3 * num + 1 ] = 0 ; lightNormal [ 3 * num + 2 ] = 0 ; } } protected void lightAmbient ( int num , float r , float g , float b ) { colorCalc ( r , g , b ) ; lightAmbient [ 3 * num + 0 ] = calcR ; lightAmbient [ 3 * num + 1 ] = calcG ; lightAmbient [ 3 * num + 2 ] = calcB ; } protected void noLightAmbient ( int num ) { lightAmbient [ 3 * num + 0 ] = 0 ; lightAmbient [ 3 * num + 1 ] = 0 ; lightAmbient [ 3 * num + 2 ] = 0 ; } protected void lightDiffuse ( int num , float r , float g , float b ) { colorCalc ( r , g , b ) ; lightDiffuse [ 3 * num + 0 ] = calcR ; lightDiffuse [ 3 * num + 1 ] = calcG ; lightDiffuse [ 3 * num + 2 ] = calcB ; } protected void noLightDiffuse ( int num ) { lightDiffuse [ 3 * num + 0 ] = 0 ; lightDiffuse [ 3 * num + 1 ] = 0 ; lightDiffuse [ 3 * num + 2 ] = 0 ; } protected void lightSpecular ( int num , float r , float g , float b ) { lightSpecular [ 3 * num + 0 ] = r ; lightSpecular [ 3 * num + 1 ] = g ; lightSpecular [ 3 * num + 2 ] = b ; } protected void noLightSpecular ( int num ) { lightSpecular [ 3 * num + 0 ] = 0 ; lightSpecular [ 3 * num + 1 ] = 0 ; lightSpecular [ 3 * num + 2 ] = 0 ; } protected void lightFalloff ( int num , float c0 , float c1 , float c2 ) { lightFalloffCoefficients [ 3 * num + 0 ] = c0 ; lightFalloffCoefficients [ 3 * num + 1 ] = c1 ; lightFalloffCoefficients [ 3 * num + 2 ] = c2 ; } protected void noLightFalloff ( int num ) { lightFalloffCoefficients [ 3 * num + 0 ] = 1 ; lightFalloffCoefficients [ 3 * num + 1 ] = 0 ; lightFalloffCoefficients [ 3 * num + 2 ] = 0 ; } protected void lightSpot ( int num , float angle , float exponent ) { lightSpotParameters [ 2 * num + 0 ] = Math . max ( 0 , PApplet . cos ( angle ) ) ; lightSpotParameters [ 2 * num + 1 ] = exponent ; } protected void noLightSpot ( int num ) { lightSpotParameters [ 2 * num + 0 ] = 0 ; lightSpotParameters [ 2 * num + 1 ] = 0 ; } @ Override protected void backgroundImpl ( PImage image ) { backgroundImpl ( ) ; set ( 0 , 0 , image ) ; if ( 0 < parent . frameCount ) { clearColorBuffer = true ; } backgroundA = 1 ; } @ Override protected void backgroundImpl ( ) { flush ( ) ; if ( ! hints [ DISABLE_DEPTH_MASK ] ) { pgl . clearDepth ( 1 ) ; pgl . clear ( PGL . DEPTH_BUFFER_BIT ) ; } pgl . clearColor ( backgroundR , backgroundG , backgroundB , backgroundA ) ; pgl . clear ( PGL . COLOR_BUFFER_BIT ) ; if ( 0 < parent . frameCount ) { clearColorBuffer = true ; } } protected void report ( String where ) { if ( ! hints [ DISABLE_OPENGL_ERRORS ] ) { int err = pgl . getError ( ) ; if ( err != 0 ) { String errString = pgl . errorString ( err ) ; String msg = "OpenGL error " + err + " at " + where + ": " + errString ; PGraphics . showWarning ( msg ) ; } } } @ Override public boolean isGL ( ) { return true ; } @ Override public void loadPixels ( ) { if ( primaryGraphics && sized ) { return ; } boolean needEndDraw = false ; if ( ! drawing ) { beginDraw ( ) ; needEndDraw = true ; } if ( ! arePixelsUpToDate ) { flush ( ) ; } allocatePixels ( ) ; if ( ! arePixelsUpToDate ) { readPixels ( ) ; } arePixelsUpToDate = true ; if ( needEndDraw ) { endDraw ( ) ; } } protected void allocatePixels ( ) { updatePixelSize ( ) ; if ( ( pixels == null ) || ( pixels . length != pixelWidth * pixelHeight ) ) { pixels = new int [ pixelWidth * pixelHeight ] ; pixelBuffer = PGL . allocateIntBuffer ( pixels ) ; } } protected void saveSurfaceToPixels ( ) { allocatePixels ( ) ; readPixels ( ) ; } protected void restoreSurfaceFromPixels ( ) { drawPixels ( 0 , 0 , width , height ) ; } protected void readPixels ( ) { updatePixelSize ( ) ; beginPixelsOp ( OP_READ ) ; try { pgl . readPixelsImpl ( 0 , 0 , pixelWidth , pixelHeight , PGL . RGBA , PGL . UNSIGNED_BYTE , pixelBuffer ) ; } catch ( IndexOutOfBoundsException e ) { } endPixelsOp ( ) ; try { PGL . getIntArray ( pixelBuffer , pixels ) ; PGL . nativeToJavaARGB ( pixels , pixelWidth , pixelHeight ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } } protected void drawPixels ( int x , int y , int w , int h ) { int f = ( int ) getPixelScale ( ) ; int len = f * w * h ; if ( nativePixels == null || nativePixels . length < len ) { nativePixels = new int [ len ] ; nativePixelBuffer = PGL . allocateIntBuffer ( nativePixels ) ; } try { if ( 0 < x || 0 < y || w < width || h < height ) { int offset0 = f * ( y * width + x ) ; int offset1 = 0 ; for ( int yc = f * y ; yc < f * ( y + h ) ; yc ++ ) { System . arraycopy ( pixels , offset0 , nativePixels , offset1 , f * w ) ; offset0 += f * width ; offset1 += f * w ; } } else { PApplet . arrayCopy ( pixels , 0 , nativePixels , 0 , len ) ; } PGL . javaToNativeARGB ( nativePixels , f * w , f * h ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } PGL . putIntArray ( nativePixelBuffer , nativePixels ) ; if ( primaryGraphics && ! pgl . isFBOBacked ( ) ) { loadTextureImpl ( POINT , false ) ; } boolean needToDrawTex = primaryGraphics && ( ! pgl . isFBOBacked ( ) || ( pgl . isFBOBacked ( ) && pgl . isMultisampled ( ) ) ) || offscreenMultisample ; if ( needToDrawTex ) { int tw = PApplet . min ( texture . glWidth - f * x , f * w ) ; int th = PApplet . min ( texture . glHeight - f * y , f * h ) ; pgl . copyToTexture ( texture . glTarget , texture . glFormat , texture . glName , f * x , f * y , tw , th , nativePixelBuffer ) ; beginPixelsOp ( OP_WRITE ) ; drawTexture ( x , y , w , h ) ; endPixelsOp ( ) ; } else { pgl . copyToTexture ( texture . glTarget , texture . glFormat , texture . glName , f * x , f * ( height - ( y + h ) ) , f * w , f * h , nativePixelBuffer ) ; } } @ Override public int get ( int x , int y ) { loadPixels ( ) ; return super . get ( x , y ) ; } @ Override protected void getImpl ( int sourceX , int sourceY , int sourceWidth , int sourceHeight , PImage target , int targetX , int targetY ) { loadPixels ( ) ; super . getImpl ( sourceX , sourceY , sourceWidth , sourceHeight , target , targetX , targetY ) ; } @ Override public void set ( int x , int y , int argb ) { loadPixels ( ) ; super . set ( x , y , argb ) ; } @ Override protected void setImpl ( PImage sourceImage , int sourceX , int sourceY , int sourceWidth , int sourceHeight , int targetX , int targetY ) { updatePixelSize ( ) ; loadPixels ( ) ; int sourceOffset = sourceY * sourceImage . pixelWidth + sourceX ; int targetOffset = targetY * pixelWidth + targetX ; for ( int y = sourceY ; y < sourceY + sourceHeight ; y ++ ) { System . arraycopy ( sourceImage . pixels , sourceOffset , pixels , targetOffset , sourceWidth ) ; sourceOffset += sourceImage . pixelWidth ; targetOffset += pixelWidth ; } copy ( sourceImage , sourceX , sourceY , sourceWidth , sourceHeight , targetX , targetY , sourceWidth , sourceHeight ) ; } @ Override public boolean save ( String filename ) { if ( primaryGraphics ) { int prevFormat = format ; format = RGB ; boolean result = super . save ( filename ) ; format = prevFormat ; return result ; } return super . save ( filename ) ; } public void loadTexture ( ) { boolean needEndDraw = false ; if ( ! drawing ) { beginDraw ( ) ; needEndDraw = true ; } flush ( ) ; if ( primaryGraphics ) { updatePixelSize ( ) ; if ( pgl . isFBOBacked ( ) ) { pgl . syncBackTexture ( ) ; } else { loadTextureImpl ( Texture . POINT , false ) ; if ( nativePixels == null || nativePixels . length < pixelWidth * pixelHeight ) { nativePixels = new int [ pixelWidth * pixelHeight ] ; nativePixelBuffer = PGL . allocateIntBuffer ( nativePixels ) ; } beginPixelsOp ( OP_READ ) ; try { pgl . readPixelsImpl ( 0 , 0 , pixelWidth , pixelHeight , PGL . RGBA , PGL . UNSIGNED_BYTE , nativePixelBuffer ) ; } catch ( IndexOutOfBoundsException e ) { } endPixelsOp ( ) ; texture . setNative ( nativePixelBuffer , 0 , 0 , pixelWidth , pixelHeight ) ; } } else if ( offscreenMultisample ) { multisampleFramebuffer . copyColor ( offscreenFramebuffer ) ; } if ( needEndDraw ) { endDraw ( ) ; } } public void updateTexture ( ) { texture . updateTexels ( ) ; } public void updateTexture ( int x , int y , int w , int h ) { texture . updateTexels ( x , y , w , h ) ; } public void updateDisplay ( ) { flush ( ) ; beginPixelsOp ( OP_WRITE ) ; drawTexture ( ) ; endPixelsOp ( ) ; } protected void loadTextureImpl ( int sampling , boolean mipmap ) { updatePixelSize ( ) ; if ( pixelWidth == 0 || pixelHeight == 0 ) return ; if ( texture == null || texture . contextIsOutdated ( ) ) { Texture . Parameters params = new Texture . Parameters ( ARGB , sampling , mipmap ) ; texture = new Texture ( this , pixelWidth , pixelHeight , params ) ; texture . invertedY ( true ) ; texture . colorBuffer ( true ) ; setCache ( this , texture ) ; } } protected void createPTexture ( ) { updatePixelSize ( ) ; ptexture = new Texture ( this , pixelWidth , pixelHeight , texture . getParameters ( ) ) ; ptexture . invertedY ( true ) ; ptexture . colorBuffer ( true ) ; } protected void swapOffscreenTextures ( ) { if ( ptexture != null ) { int temp = texture . glName ; texture . glName = ptexture . glName ; ptexture . glName = temp ; offscreenFramebuffer . setColorBuffer ( texture ) ; } } protected void drawTexture ( ) { pgl . disable ( PGL . BLEND ) ; pgl . drawTexture ( texture . glTarget , texture . glName , texture . glWidth , texture . glHeight , 0 , 0 , width , height ) ; pgl . enable ( PGL . BLEND ) ; } protected void drawTexture ( int x , int y , int w , int h ) { pgl . disable ( PGL . BLEND ) ; pgl . drawTexture ( texture . glTarget , texture . glName , texture . glWidth , texture . glHeight , 0 , 0 , width , height , x , y , x + w , y + h , x , height - ( y + h ) , x + w , height - y ) ; pgl . enable ( PGL . BLEND ) ; } protected void drawPTexture ( ) { if ( ptexture != null ) { pgl . disable ( PGL . BLEND ) ; pgl . drawTexture ( ptexture . glTarget , ptexture . glName , ptexture . glWidth , ptexture . glHeight , 0 , 0 , width , height ) ; pgl . enable ( PGL . BLEND ) ; } } @ Override public void mask ( PImage alpha ) { updatePixelSize ( ) ; if ( alpha . width != pixelWidth || alpha . height != pixelHeight ) { throw new RuntimeException ( "The PImage used with mask() must be " + "the same size as the applet." ) ; } PGraphicsOpenGL ppg = getPrimaryPG ( ) ; if ( ppg . maskShader == null ) { ppg . maskShader = new PShader ( parent , defTextureShaderVertURL , maskShaderFragURL ) ; } ppg . maskShader . set ( "mask" , alpha ) ; filter ( ppg . maskShader ) ; } @ Override public void filter ( int kind ) { PImage temp = get ( ) ; temp . filter ( kind ) ; set ( 0 , 0 , temp ) ; } @ Override public void filter ( int kind , float param ) { PImage temp = get ( ) ; temp . filter ( kind , param ) ; set ( 0 , 0 , temp ) ; } @ Override public void filter ( PShader shader ) { if ( ! shader . isPolyShader ( ) ) { PGraphics . showWarning ( INVALID_FILTER_SHADER_ERROR ) ; return ; } boolean needEndDraw = false ; if ( primaryGraphics ) pgl . requestFBOLayer ( ) ; else if ( ! drawing ) { beginDraw ( ) ; needEndDraw = true ; } loadTexture ( ) ; if ( filterTexture == null || filterTexture . contextIsOutdated ( ) ) { filterTexture = new Texture ( this , texture . width , texture . height , texture . getParameters ( ) ) ; filterTexture . invertedY ( true ) ; filterImage = wrapTexture ( filterTexture ) ; } filterTexture . set ( texture ) ; pgl . depthMask ( false ) ; pgl . disable ( PGL . DEPTH_TEST ) ; begin2D ( ) ; boolean prevLights = lights ; lights = false ; int prevTextureMode = textureMode ; textureMode = NORMAL ; boolean prevStroke = stroke ; stroke = false ; int prevBlendMode = blendMode ; blendMode ( REPLACE ) ; PShader prevShader = polyShader ; polyShader = shader ; beginShape ( QUADS ) ; texture ( filterImage ) ; vertex ( 0 , 0 , 0 , 0 ) ; vertex ( width , 0 , 1 , 0 ) ; vertex ( width , height , 1 , 1 ) ; vertex ( 0 , height , 0 , 1 ) ; endShape ( ) ; end2D ( ) ; polyShader = prevShader ; stroke = prevStroke ; lights = prevLights ; textureMode = prevTextureMode ; blendMode ( prevBlendMode ) ; if ( ! hints [ DISABLE_DEPTH_TEST ] ) { pgl . enable ( PGL . DEPTH_TEST ) ; } if ( ! hints [ DISABLE_DEPTH_MASK ] ) { pgl . depthMask ( true ) ; } if ( needEndDraw ) { endDraw ( ) ; } } @ Override public void copy ( int sx , int sy , int sw , int sh , int dx , int dy , int dw , int dh ) { if ( primaryGraphics ) pgl . requestFBOLayer ( ) ; loadTexture ( ) ; if ( filterTexture == null || filterTexture . contextIsOutdated ( ) ) { filterTexture = new Texture ( this , texture . width , texture . height , texture . getParameters ( ) ) ; filterTexture . invertedY ( true ) ; filterImage = wrapTexture ( filterTexture ) ; } filterTexture . put ( texture , sx , height - ( sy + sh ) , sw , height - sy ) ; copy ( filterImage , sx , sy , sw , sh , dx , dy , dw , dh ) ; } @ Override public void copy ( PImage src , int sx , int sy , int sw , int sh , int dx , int dy , int dw , int dh ) { boolean needEndDraw = false ; if ( ! drawing ) { beginDraw ( ) ; needEndDraw = true ; } flush ( ) ; Texture tex = getTexture ( src ) ; boolean invX = tex . invertedX ( ) ; boolean invY = tex . invertedY ( ) ; int scrX0 , scrX1 ; int scrY0 , scrY1 ; if ( invX ) { scrX0 = dx + dw ; scrX1 = dx ; } else { scrX0 = dx ; scrX1 = dx + dw ; } int texX0 = sx ; int texX1 = sx + sw ; int texY0 , texY1 ; if ( invY ) { scrY0 = height - ( dy + dh ) ; scrY1 = height - dy ; texY0 = tex . height - ( sy + sh ) ; texY1 = tex . height - sy ; } else { scrY0 = height - dy ; scrY1 = height - ( dy + dh ) ; texY0 = sy ; texY1 = sy + sh ; } pgl . drawTexture ( tex . glTarget , tex . glName , tex . glWidth , tex . glHeight , 0 , 0 , width , height , texX0 , texY0 , texX1 , texY1 , scrX0 , scrY0 , scrX1 , scrY1 ) ; if ( needEndDraw ) { endDraw ( ) ; } } @ Override protected void blendModeImpl ( ) { if ( blendMode != lastBlendMode ) { flush ( ) ; } pgl . enable ( PGL . BLEND ) ; if ( blendMode == REPLACE ) { if ( blendEqSupported ) { pgl . blendEquation ( PGL . FUNC_ADD ) ; } pgl . blendFunc ( PGL . ONE , PGL . ZERO ) ; } else if ( blendMode == BLEND ) { if ( blendEqSupported ) { pgl . blendEquationSeparate ( PGL . FUNC_ADD , PGL . FUNC_ADD ) ; } pgl . blendFuncSeparate ( PGL . SRC_ALPHA , PGL . ONE_MINUS_SRC_ALPHA , PGL . ONE , PGL . ONE ) ; } else if ( blendMode == ADD ) { if ( blendEqSupported ) { pgl . blendEquationSeparate ( PGL . FUNC_ADD , PGL . FUNC_ADD ) ; } pgl . blendFuncSeparate ( PGL . SRC_ALPHA , PGL . ONE , PGL . ONE , PGL . ONE ) ; } else if ( blendMode == SUBTRACT ) { if ( blendEqSupported ) { pgl . blendEquationSeparate ( PGL . FUNC_REVERSE_SUBTRACT , PGL . FUNC_ADD ) ; pgl . blendFuncSeparate ( PGL . SRC_ALPHA , PGL . ONE , PGL . ONE , PGL . ONE ) ; } else { PGraphics . showWarning ( BLEND_DRIVER_ERROR , "SUBTRACT" ) ; } } else if ( blendMode == LIGHTEST ) { if ( blendEqSupported ) { pgl . blendEquationSeparate ( PGL . FUNC_MAX , PGL . FUNC_ADD ) ; pgl . blendFuncSeparate ( PGL . ONE , PGL . ONE , PGL . ONE , PGL . ONE ) ; } else { PGraphics . showWarning ( BLEND_DRIVER_ERROR , "LIGHTEST" ) ; } } else if ( blendMode == DARKEST ) { if ( blendEqSupported ) { pgl . blendEquationSeparate ( PGL . FUNC_MIN , PGL . FUNC_ADD ) ; pgl . blendFuncSeparate ( PGL . ONE , PGL . ONE , PGL . ONE , PGL . ONE ) ; } else { PGraphics . showWarning ( BLEND_DRIVER_ERROR , "DARKEST" ) ; } } else if ( blendMode == EXCLUSION ) { if ( blendEqSupported ) { pgl . blendEquationSeparate ( PGL . FUNC_ADD , PGL . FUNC_ADD ) ; } pgl . blendFuncSeparate ( PGL . ONE_MINUS_DST_COLOR , PGL . ONE_MINUS_SRC_COLOR , PGL . ONE , PGL . ONE ) ; } else if ( blendMode == MULTIPLY ) { if ( blendEqSupported ) { pgl . blendEquationSeparate ( PGL . FUNC_ADD , PGL . FUNC_ADD ) ; } pgl . blendFuncSeparate ( PGL . ZERO , PGL . SRC_COLOR , PGL . ONE , PGL . ONE ) ; } else if ( blendMode == SCREEN ) { if ( blendEqSupported ) { pgl . blendEquationSeparate ( PGL . FUNC_ADD , PGL . FUNC_ADD ) ; } pgl . blendFuncSeparate ( PGL . ONE_MINUS_DST_COLOR , PGL . ONE , PGL . ONE , PGL . ONE ) ; } else if ( blendMode == DIFFERENCE ) { PGraphics . showWarning ( BLEND_RENDERER_ERROR , "DIFFERENCE" ) ; } else if ( blendMode == OVERLAY ) { PGraphics . showWarning ( BLEND_RENDERER_ERROR , "OVERLAY" ) ; } else if ( blendMode == HARD_LIGHT ) { PGraphics . showWarning ( BLEND_RENDERER_ERROR , "HARD_LIGHT" ) ; } else if ( blendMode == SOFT_LIGHT ) { PGraphics . showWarning ( BLEND_RENDERER_ERROR , "SOFT_LIGHT" ) ; } else if ( blendMode == DODGE ) { PGraphics . showWarning ( BLEND_RENDERER_ERROR , "DODGE" ) ; } else if ( blendMode == BURN ) { PGraphics . showWarning ( BLEND_RENDERER_ERROR , "BURN" ) ; } lastBlendMode = blendMode ; } public Texture getTexture ( ) { return getTexture ( true ) ; } public Texture getTexture ( boolean load ) { if ( load ) loadTexture ( ) ; return texture ; } public Texture getTexture ( PImage img ) { Texture tex = ( Texture ) initCache ( img ) ; if ( tex == null ) return null ; if ( img . isModified ( ) || img . isLoaded ( ) ) { if ( img . width != tex . width || img . height != tex . height ) { tex . init ( img . width , img . height ) ; } updateTexture ( img , tex ) ; } if ( tex . hasBuffers ( ) ) { tex . bufferUpdate ( ) ; } checkTexture ( tex ) ; return tex ; } public FrameBuffer getFrameBuffer ( ) { return getFrameBuffer ( false ) ; } public FrameBuffer getFrameBuffer ( boolean multi ) { if ( multi ) { return multisampleFramebuffer ; } else { return offscreenFramebuffer ; } } protected Object initCache ( PImage img ) { if ( ! checkGLThread ( ) ) { return null ; } Texture tex = ( Texture ) getCache ( img ) ; if ( tex == null || tex . contextIsOutdated ( ) ) { tex = addTexture ( img ) ; if ( tex != null ) { img . loadPixels ( ) ; tex . set ( img . pixels , img . format ) ; img . setLoaded ( false ) ; } } return tex ; } protected void bindFrontTexture ( ) { if ( primaryGraphics ) { pgl . bindFrontTexture ( ) ; } else { if ( ptexture == null ) createPTexture ( ) ; ptexture . bind ( ) ; } } protected void unbindFrontTexture ( ) { if ( primaryGraphics ) { pgl . unbindFrontTexture ( ) ; } else { ptexture . unbind ( ) ; } } protected Texture addTexture ( PImage img ) { Texture . Parameters params = new Texture . Parameters ( ARGB , textureSampling , getHint ( ENABLE_TEXTURE_MIPMAPS ) , textureWrap ) ; return addTexture ( img , params ) ; } protected Texture addTexture ( PImage img , Texture . Parameters params ) { if ( img . width == 0 || img . height == 0 ) { return null ; } if ( img . parent == null ) { img . parent = parent ; } Texture tex = new Texture ( this , img . width , img . height , params ) ; setCache ( img , tex ) ; return tex ; } protected void checkTexture ( Texture tex ) { if ( ! tex . colorBuffer ( ) && ( tex . usingMipmaps == hints [ DISABLE_TEXTURE_MIPMAPS ] || tex . currentSampling ( ) != textureSampling ) ) { if ( hints [ DISABLE_TEXTURE_MIPMAPS ] ) { tex . usingMipmaps ( false , textureSampling ) ; } else { tex . usingMipmaps ( true , textureSampling ) ; } } if ( ( tex . usingRepeat && textureWrap == CLAMP ) || ( ! tex . usingRepeat && textureWrap == REPEAT ) ) { if ( textureWrap == CLAMP ) { tex . usingRepeat ( false ) ; } else { tex . usingRepeat ( true ) ; } } } protected PImage wrapTexture ( Texture tex ) { PImage img = new PImage ( ) ; img . parent = parent ; img . width = tex . width ; img . height = tex . height ; img . format = ARGB ; setCache ( img , tex ) ; return img ; } protected void updateTexture ( PImage img , Texture tex ) { if ( tex != null ) { if ( img . isModified ( ) ) { int x = img . getModifiedX1 ( ) ; int y = img . getModifiedY1 ( ) ; int w = img . getModifiedX2 ( ) - x ; int h = img . getModifiedY2 ( ) - y ; tex . set ( img . pixels , x , y , w , h , img . format ) ; } else if ( img . isLoaded ( ) ) { tex . set ( img . pixels , 0 , 0 , img . width , img . height , img . format ) ; } } img . setModified ( false ) ; img . setLoaded ( false ) ; } protected void deleteSurfaceTextures ( ) { if ( texture != null ) { texture . dispose ( ) ; } if ( ptexture != null ) { ptexture . dispose ( ) ; } if ( filterTexture != null ) { filterTexture . dispose ( ) ; } } protected boolean checkGLThread ( ) { if ( pgl . threadIsCurrent ( ) ) { return true ; } else { PGraphics . showWarning ( OPENGL_THREAD_ERROR ) ; return false ; } } @ Override public void resize ( int wide , int high ) { PGraphics . showMethodWarning ( "resize" ) ; } protected void initPrimary ( ) { if ( texture != null ) { removeCache ( this ) ; texture = ptexture = null ; } initialized = true ; } protected void beginOnscreenDraw ( ) { updatePixelSize ( ) ; pgl . beginDraw ( clearColorBuffer ) ; if ( drawFramebuffer == null ) { drawFramebuffer = new FrameBuffer ( this , pixelWidth , pixelHeight , true ) ; } drawFramebuffer . setFBO ( pgl . getDrawFramebuffer ( ) ) ; if ( readFramebuffer == null ) { readFramebuffer = new FrameBuffer ( this , pixelWidth , pixelHeight , true ) ; } readFramebuffer . setFBO ( pgl . getReadFramebuffer ( ) ) ; if ( currentFramebuffer == null ) { setFramebuffer ( drawFramebuffer ) ; } if ( pgl . isFBOBacked ( ) ) { texture = pgl . wrapBackTexture ( texture ) ; ptexture = pgl . wrapFrontTexture ( ptexture ) ; } } protected void endOnscreenDraw ( ) { pgl . endDraw ( clearColorBuffer0 , parent . sketchWindowColor ( ) ) ; } protected void initOffscreen ( ) { loadTextureImpl ( textureSampling , false ) ; if ( offscreenFramebuffer != null ) { offscreenFramebuffer . dispose ( ) ; } if ( multisampleFramebuffer != null ) { multisampleFramebuffer . dispose ( ) ; } boolean packed = depthBits == 24 && stencilBits == 8 && packedDepthStencilSupported ; if ( PGraphicsOpenGL . fboMultisampleSupported && 1 < PGL . smoothToSamples ( smooth ) ) { multisampleFramebuffer = new FrameBuffer ( this , texture . glWidth , texture . glHeight , PGL . smoothToSamples ( smooth ) , 0 , depthBits , stencilBits , packed , false ) ; multisampleFramebuffer . clear ( ) ; offscreenMultisample = true ; offscreenFramebuffer = new FrameBuffer ( this , texture . glWidth , texture . glHeight , 1 , 1 , 0 , 0 , false , false ) ; } else { smooth = 0 ; offscreenFramebuffer = new FrameBuffer ( this , texture . glWidth , texture . glHeight , 1 , 1 , depthBits , stencilBits , packed , false ) ; offscreenMultisample = false ; } offscreenFramebuffer . setColorBuffer ( texture ) ; offscreenFramebuffer . clear ( ) ; initialized = true ; } protected void beginOffscreenDraw ( ) { if ( ! initialized ) { initOffscreen ( ) ; } else { boolean outdated = offscreenFramebuffer != null && offscreenFramebuffer . contextIsOutdated ( ) ; boolean outdatedMulti = multisampleFramebuffer != null && multisampleFramebuffer . contextIsOutdated ( ) ; if ( outdated || outdatedMulti ) { restartPGL ( ) ; initOffscreen ( ) ; } else { swapOffscreenTextures ( ) ; } } pushFramebuffer ( ) ; if ( offscreenMultisample ) { setFramebuffer ( multisampleFramebuffer ) ; } else { setFramebuffer ( offscreenFramebuffer ) ; } drawPTexture ( ) ; if ( clip ) { pgl . enable ( PGL . SCISSOR_TEST ) ; pgl . scissor ( clipRect [ 0 ] , clipRect [ 1 ] , clipRect [ 2 ] , clipRect [ 3 ] ) ; } else { pgl . disable ( PGL . SCISSOR_TEST ) ; } } protected void endOffscreenDraw ( ) { if ( offscreenMultisample ) { multisampleFramebuffer . copyColor ( offscreenFramebuffer ) ; } popFramebuffer ( ) ; if ( backgroundA == 1 ) { pgl . colorMask ( false , false , false , true ) ; pgl . clearColor ( 0 , 0 , 0 , backgroundA ) ; pgl . clear ( PGL . COLOR_BUFFER_BIT ) ; pgl . colorMask ( true , true , true , true ) ; } texture . updateTexels ( ) ; getPrimaryPG ( ) . restoreGL ( ) ; } protected void setViewport ( ) { viewport . put ( 0 , 0 ) ; viewport . put ( 1 , 0 ) ; viewport . put ( 2 , width ) ; viewport . put ( 3 , height ) ; pgl . viewport ( viewport . get ( 0 ) , viewport . get ( 1 ) , viewport . get ( 2 ) , viewport . get ( 3 ) ) ; } protected void setDrawDefaults ( ) { inGeo . clear ( ) ; tessGeo . clear ( ) ; texCache . clear ( ) ; super . noTexture ( ) ; blendModeImpl ( ) ; if ( hints [ DISABLE_DEPTH_TEST ] ) { pgl . disable ( PGL . DEPTH_TEST ) ; } else { pgl . enable ( PGL . DEPTH_TEST ) ; } pgl . depthFunc ( PGL . LEQUAL ) ; if ( hints [ DISABLE_OPTIMIZED_STROKE ] ) { flushMode = FLUSH_CONTINUOUSLY ; } else { flushMode = FLUSH_WHEN_FULL ; } if ( primaryGraphics ) { } if ( smooth < 1 ) { pgl . disable ( PGL . MULTISAMPLE ) ; } else { pgl . enable ( PGL . MULTISAMPLE ) ; } pgl . disable ( PGL . POLYGON_SMOOTH ) ; if ( sized ) { if ( primaryGraphics ) { background ( backgroundColor ) ; } else { background ( 0x00 < < 24 | ( backgroundColor & 0xFFFFFF ) ) ; } defaultPerspective ( ) ; defaultCamera ( ) ; sized = false ; } else { modelview . set ( camera ) ; modelviewInv . set ( cameraInv ) ; updateProjmodelview ( ) ; } if ( is3D ( ) ) { noLights ( ) ; lightFalloff ( 1 , 0 , 0 ) ; lightSpecular ( 0 , 0 , 0 ) ; } pgl . frontFace ( PGL . CW ) ; pgl . disable ( PGL . CULL_FACE ) ; pgl . activeTexture ( PGL . TEXTURE0 ) ; normalX = normalY = 0 ; normalZ = 1 ; pgl . depthMask ( true ) ; pgl . clearDepth ( 1 ) ; pgl . clearStencil ( 0 ) ; pgl . clear ( PGL . DEPTH_BUFFER_BIT | PGL . STENCIL_BUFFER_BIT ) ; if ( ! settingsInited ) { defaultSettings ( ) ; } if ( restoreSurface ) { restoreSurfaceFromPixels ( ) ; restoreSurface = false ; } if ( hints [ DISABLE_DEPTH_MASK ] ) { pgl . depthMask ( false ) ; } else { pgl . depthMask ( true ) ; } pixelsOp = OP_NONE ; clearColorBuffer0 = clearColorBuffer ; clearColorBuffer = false ; modified = false ; arePixelsUpToDate = false ; } protected void getGLParameters ( ) { OPENGL_VENDOR = pgl . getString ( PGL . VENDOR ) ; OPENGL_RENDERER = pgl . getString ( PGL . RENDERER ) ; OPENGL_VERSION = pgl . getString ( PGL . VERSION ) ; OPENGL_EXTENSIONS = pgl . getString ( PGL . EXTENSIONS ) ; GLSL_VERSION = pgl . getString ( PGL . SHADING_LANGUAGE_VERSION ) ; npotTexSupported = pgl . hasNpotTexSupport ( ) ; autoMipmapGenSupported = pgl . hasAutoMipmapGenSupport ( ) ; fboMultisampleSupported = pgl . hasFboMultisampleSupport ( ) ; packedDepthStencilSupported = pgl . hasPackedDepthStencilSupport ( ) ; anisoSamplingSupported = pgl . hasAnisoSamplingSupport ( ) ; try { pgl . blendEquation ( PGL . FUNC_ADD ) ; blendEqSupported = true ; } catch ( Exception e ) { blendEqSupported = false ; } depthBits = pgl . getDepthBits ( ) ; stencilBits = pgl . getStencilBits ( ) ; pgl . getIntegerv ( PGL . MAX_TEXTURE_SIZE , intBuffer ) ; maxTextureSize = intBuffer . get ( 0 ) ; pgl . getIntegerv ( PGL . MAX_SAMPLES , intBuffer ) ; maxSamples = intBuffer . get ( 0 ) ; if ( anisoSamplingSupported ) { pgl . getFloatv ( PGL . MAX_TEXTURE_MAX_ANISOTROPY , floatBuffer ) ; maxAnisoAmount = floatBuffer . get ( 0 ) ; } glParamsRead = true ; } @ Override public PShader loadShader ( String fragFilename ) { if ( fragFilename == null || fragFilename . equals ( "" ) ) { PGraphics . showWarning ( MISSING_FRAGMENT_SHADER ) ; return null ; } int type = PShader . getShaderType ( parent . loadStrings ( fragFilename ) , PShader . POLY ) ; PShader shader = new PShader ( parent ) ; shader . setType ( type ) ; shader . setFragmentShader ( fragFilename ) ; if ( type == PShader . POINT ) { String [ ] vertSource = pgl . loadVertexShader ( defPointShaderVertURL , 120 ) ; shader . setVertexShader ( vertSource ) ; } else if ( type == PShader . LINE ) { String [ ] vertSource = pgl . loadVertexShader ( defLineShaderVertURL , 120 ) ; shader . setVertexShader ( vertSource ) ; } else if ( type == PShader . TEXLIGHT ) { String [ ] vertSource = pgl . loadVertexShader ( defTexlightShaderVertURL , 120 ) ; shader . setVertexShader ( vertSource ) ; } else if ( type == PShader . LIGHT ) { String [ ] vertSource = pgl . loadVertexShader ( defLightShaderVertURL , 120 ) ; shader . setVertexShader ( vertSource ) ; } else if ( type == PShader . TEXTURE ) { String [ ] vertSource = pgl . loadVertexShader ( defTextureShaderVertURL , 120 ) ; shader . setVertexShader ( vertSource ) ; } else if ( type == PShader . COLOR ) { String [ ] vertSource = pgl . loadVertexShader ( defColorShaderVertURL , 120 ) ; shader . setVertexShader ( vertSource ) ; } else { String [ ] vertSource = pgl . loadVertexShader ( defTextureShaderVertURL , 120 ) ; shader . setVertexShader ( vertSource ) ; } return shader ; } @ Override public PShader loadShader ( String fragFilename , String vertFilename ) { PShader shader = null ; if ( fragFilename == null || fragFilename . equals ( "" ) ) { PGraphics . showWarning ( MISSING_FRAGMENT_SHADER ) ; } else if ( vertFilename == null || vertFilename . equals ( "" ) ) { PGraphics . showWarning ( MISSING_VERTEX_SHADER ) ; } else { shader = new PShader ( parent , vertFilename , fragFilename ) ; } return shader ; } @ Override public void shader ( PShader shader ) { flush ( ) ; if ( shader != null ) shader . init ( ) ; if ( shader . isPolyShader ( ) ) polyShader = shader ; else if ( shader . isLineShader ( ) ) lineShader = shader ; else if ( shader . isPointShader ( ) ) pointShader = shader ; else PGraphics . showWarning ( UNKNOWN_SHADER_KIND_ERROR ) ; } @ Override public void shader ( PShader shader , int kind ) { flush ( ) ; if ( shader != null ) shader . init ( ) ; if ( kind == TRIANGLES ) polyShader = shader ; else if ( kind == LINES ) lineShader = shader ; else if ( kind == POINTS ) pointShader = shader ; else PGraphics . showWarning ( UNKNOWN_SHADER_KIND_ERROR ) ; } @ Override public void resetShader ( ) { resetShader ( TRIANGLES ) ; } @ Override public void resetShader ( int kind ) { flush ( ) ; if ( kind == TRIANGLES || kind == QUADS || kind == POLYGON ) { polyShader = null ; } else if ( kind == LINES ) { lineShader = null ; } else if ( kind == POINTS ) { pointShader = null ; } else { PGraphics . showWarning ( UNKNOWN_SHADER_KIND_ERROR ) ; } } protected void deleteDefaultShaders ( ) { defColorShader = null ; defTextureShader = null ; defLightShader = null ; defTexlightShader = null ; defLineShader = null ; defPointShader = null ; maskShader = null ; } protected PShader getPolyShader ( boolean lit , boolean tex ) { PShader shader ; PGraphicsOpenGL ppg = getPrimaryPG ( ) ; boolean useDefault = polyShader == null ; if ( polyShader != null ) { polyShader . setRenderer ( this ) ; polyShader . loadAttributes ( ) ; polyShader . loadUniforms ( ) ; } if ( lit ) { if ( tex ) { if ( useDefault || ! polyShader . checkPolyType ( PShader . TEXLIGHT ) ) { if ( ppg . defTexlightShader == null ) { String [ ] vertSource = pgl . loadVertexShader ( defTexlightShaderVertURL , 120 ) ; String [ ] fragSource = pgl . loadFragmentShader ( defTexlightShaderFragURL , 120 ) ; ppg . defTexlightShader = new PShader ( parent , vertSource , fragSource ) ; } shader = ppg . defTexlightShader ; } else { shader = polyShader ; } } else { if ( useDefault || ! polyShader . checkPolyType ( PShader . LIGHT ) ) { if ( ppg . defLightShader == null ) { String [ ] vertSource = pgl . loadVertexShader ( defLightShaderVertURL , 120 ) ; String [ ] fragSource = pgl . loadFragmentShader ( defLightShaderFragURL , 120 ) ; ppg . defLightShader = new PShader ( parent , vertSource , fragSource ) ; } shader = ppg . defLightShader ; } else { shader = polyShader ; } } } else { if ( polyShader != null && polyShader . accessLightAttribs ( ) ) { PGraphics . showWarning ( SHADER_NEED_LIGHT_ATTRIBS ) ; useDefault = true ; } if ( tex ) { if ( useDefault || ! polyShader . checkPolyType ( PShader . TEXTURE ) ) { if ( ppg . defTextureShader == null ) { String [ ] vertSource = pgl . loadVertexShader ( defTextureShaderVertURL , 120 ) ; String [ ] fragSource = pgl . loadFragmentShader ( defTextureShaderFragURL , 120 ) ; ppg . defTextureShader = new PShader ( parent , vertSource , fragSource ) ; } shader = ppg . defTextureShader ; } else { shader = polyShader ; } } else { if ( useDefault || ! polyShader . checkPolyType ( PShader . COLOR ) ) { if ( ppg . defColorShader == null ) { String [ ] vertSource = pgl . loadVertexShader ( defColorShaderVertURL , 120 ) ; String [ ] fragSource = pgl . loadFragmentShader ( defColorShaderFragURL , 120 ) ; ppg . defColorShader = new PShader ( parent , vertSource , fragSource ) ; } shader = ppg . defColorShader ; } else { shader = polyShader ; } } } if ( shader != polyShader ) { shader . setRenderer ( this ) ; shader . loadAttributes ( ) ; shader . loadUniforms ( ) ; } return shader ; } protected PShader getLineShader ( ) { PShader shader ; PGraphicsOpenGL ppg = getPrimaryPG ( ) ; if ( lineShader == null ) { if ( ppg . defLineShader == null ) { String [ ] vertSource = pgl . loadVertexShader ( defLineShaderVertURL , 120 ) ; String [ ] fragSource = pgl . loadFragmentShader ( defLineShaderFragURL , 120 ) ; ppg . defLineShader = new PShader ( parent , vertSource , fragSource ) ; } shader = ppg . defLineShader ; } else { shader = lineShader ; } shader . setRenderer ( this ) ; shader . loadAttributes ( ) ; shader . loadUniforms ( ) ; return shader ; } protected PShader getPointShader ( ) { PShader shader ; PGraphicsOpenGL ppg = getPrimaryPG ( ) ; if ( pointShader == null ) { if ( ppg . defPointShader == null ) { String [ ] vertSource = pgl . loadVertexShader ( defPointShaderVertURL , 120 ) ; String [ ] fragSource = pgl . loadFragmentShader ( defPointShaderFragURL , 120 ) ; ppg . defPointShader = new PShader ( parent , vertSource , fragSource ) ; } shader = ppg . defPointShader ; } else { shader = pointShader ; } shader . setRenderer ( this ) ; shader . loadAttributes ( ) ; shader . loadUniforms ( ) ; return shader ; } static protected int expandArraySize ( int currSize , int newMinSize ) { int newSize = currSize ; while ( newSize < newMinSize ) { newSize <<= 1 ; } return newSize ; } static protected AttributeMap newAttributeMap ( ) { return new AttributeMap ( ) ; } static protected class AttributeMap extends HashMap < String , VertexAttribute > { public ArrayList < String > names = new ArrayList < String > ( ) ; public int numComp = 0 ; @ Override public VertexAttribute put ( String key , VertexAttribute value ) { VertexAttribute prev = super . put ( key , value ) ; names . add ( key ) ; if ( value . kind == VertexAttribute . COLOR ) numComp += 4 ; else numComp += value . size ; return prev ; } public VertexAttribute get ( int i ) { return super . get ( names . get ( i ) ) ; } } static protected class VertexAttribute { static final int POSITION = 0 ; static final int NORMAL = 1 ; static final int COLOR = 2 ; static final int OTHER = 3 ; String name ; int kind ; int type ; int size ; int tessSize ; int elementSize ; int glName ; int glLoc ; float [ ] fvalues ; int [ ] ivalues ; byte [ ] bvalues ; boolean modified ; int firstModified ; int lastModified ; boolean active ; VertexAttribute ( String name , int type , int size ) { this . name = name ; this . type = type ; this . size = size ; tessSize = size ; if ( name . indexOf ( "pos" ) == 0 && type == PGL . FLOAT && size == 3 ) { kind = POSITION ; tessSize = 4 ; } else if ( name . indexOf ( "norm" ) == 0 && type == PGL . FLOAT && size == 3 ) { kind = NORMAL ; } else if ( name . indexOf ( "color" ) == 0 && type == PGL . INT && size == 1 ) { kind = COLOR ; } else { kind = OTHER ; } if ( type == PGL . FLOAT ) { elementSize = PGL . SIZEOF_FLOAT ; fvalues = new float [ size ] ; } else if ( type == PGL . INT ) { elementSize = PGL . SIZEOF_INT ; ivalues = new int [ size ] ; } else if ( type == PGL . BOOL ) { elementSize = PGL . SIZEOF_INT ; bvalues = new byte [ size ] ; } glName = 0 ; glLoc = - 1 ; modified = false ; firstModified = PConstants . MAX_INT ; lastModified = PConstants . MIN_INT ; active = true ; } public boolean diff ( VertexAttribute attr ) { return ! name . equals ( attr . name ) || kind != attr . kind || type != attr . type || size != attr . size || tessSize != attr . tessSize || elementSize != attr . elementSize ; } boolean isPosition ( ) { return kind == POSITION ; } boolean isNormal ( ) { return kind == NORMAL ; } boolean isColor ( ) { return kind == COLOR ; } boolean isOther ( ) { return kind == OTHER ; } boolean isFloat ( ) { return type == PGL . FLOAT ; } boolean isInt ( ) { return type == PGL . INT ; } boolean isBool ( ) { return type == PGL . BOOL ; } boolean bufferCreated ( ) { return 0 < glName ; } void createBuffer ( PGL pgl ) { int ctx = pgl . getCurrentContext ( ) ; glName = createVertexBufferObject ( ctx , pgl ) ; pgl . bindBuffer ( PGL . ARRAY_BUFFER , glName ) ; pgl . bufferData ( PGL . ARRAY_BUFFER , size * INIT_VERTEX_BUFFER_SIZE * elementSize , null , PGL . STATIC_DRAW ) ; } void deleteBuffer ( PGL pgl ) { if ( glName != 0 ) { int ctx = pgl . getCurrentContext ( ) ; PGraphicsOpenGL . deleteVertexBufferObject ( glName , ctx , pgl ) ; } } void bind ( PGL pgl ) { pgl . enableVertexAttribArray ( glLoc ) ; } void unbind ( PGL pgl ) { pgl . disableVertexAttribArray ( glLoc ) ; } boolean active ( PShader shader ) { if ( active ) { if ( glLoc == - 1 ) { glLoc = shader . getAttributeLoc ( name ) ; if ( glLoc == - 1 ) active = false ; } } return active ; } int sizeInBytes ( int length ) { return length * tessSize * elementSize ; } void set ( float [ ] values ) { PApplet . arrayCopy ( values , 0 , fvalues , 0 , size ) ; } void set ( int [ ] values ) { PApplet . arrayCopy ( values , 0 , ivalues , 0 , size ) ; } void set ( boolean [ ] values ) { for ( int i = 0 ; i < values . length ; i ++ ) { bvalues [ i ] = ( byte ) ( values [ i ] ? 1 : 0 ) ; } } void add ( float [ ] dstValues , int dstIdx ) { PApplet . arrayCopy ( fvalues , 0 , dstValues , dstIdx , size ) ; } void add ( int [ ] dstValues , int dstIdx ) { PApplet . arrayCopy ( ivalues , 0 , dstValues , dstIdx , size ) ; } void add ( byte [ ] dstValues , int dstIdx ) { PApplet . arrayCopy ( bvalues , 0 , dstValues , dstIdx , size ) ; } } static protected InGeometry newInGeometry ( PGraphicsOpenGL pg , AttributeMap attr , int mode ) { return new InGeometry ( pg , attr , mode ) ; } static protected TessGeometry newTessGeometry ( PGraphicsOpenGL pg , AttributeMap attr , int mode ) { return new TessGeometry ( pg , attr , mode ) ; } static protected TexCache newTexCache ( PGraphicsOpenGL pg ) { return new TexCache ( pg ) ; } static protected class TexCache { PGraphicsOpenGL pg ; int size ; PImage [ ] textures ; int [ ] firstIndex ; int [ ] lastIndex ; int [ ] firstCache ; int [ ] lastCache ; boolean hasTextures ; TexCache ( PGraphicsOpenGL pg ) { this . pg = pg ; allocate ( ) ; } void allocate ( ) { textures = new PImage [ PGL . DEFAULT_IN_TEXTURES ] ; firstIndex = new int [ PGL . DEFAULT_IN_TEXTURES ] ; lastIndex = new int [ PGL . DEFAULT_IN_TEXTURES ] ; firstCache = new int [ PGL . DEFAULT_IN_TEXTURES ] ; lastCache = new int [ PGL . DEFAULT_IN_TEXTURES ] ; size = 0 ; hasTextures = false ; } void clear ( ) { java . util . Arrays . fill ( textures , 0 , size , null ) ; size = 0 ; hasTextures = false ; } boolean containsTexture ( PImage img ) { for ( int i = 0 ; i < size ; i ++ ) { if ( textures [ i ] == img ) return true ; } return false ; } PImage getTextureImage ( int i ) { return textures [ i ] ; } Texture getTexture ( int i ) { PImage img = textures [ i ] ; Texture tex = null ; if ( img != null ) { tex = pg . getTexture ( img ) ; } return tex ; } void addTexture ( PImage img , int firsti , int firstb , int lasti , int lastb ) { arrayCheck ( ) ; textures [ size ] = img ; firstIndex [ size ] = firsti ; lastIndex [ size ] = lasti ; firstCache [ size ] = firstb ; lastCache [ size ] = lastb ; hasTextures |= img != null ; size ++ ; } void setLastIndex ( int lasti , int lastb ) { lastIndex [ size - 1 ] = lasti ; lastCache [ size - 1 ] = lastb ; } void arrayCheck ( ) { if ( size == textures . length ) { int newSize = size < < 1 ; expandTextures ( newSize ) ; expandFirstIndex ( newSize ) ; expandLastIndex ( newSize ) ; expandFirstCache ( newSize ) ; expandLastCache ( newSize ) ; } } void expandTextures ( int n ) { PImage [ ] temp = new PImage [ n ] ; PApplet . arrayCopy ( textures , 0 , temp , 0 , size ) ; textures = temp ; } void expandFirstIndex ( int n ) { int [ ] temp = new int [ n ] ; PApplet . arrayCopy ( firstIndex , 0 , temp , 0 , size ) ; firstIndex = temp ; } void expandLastIndex ( int n ) { int [ ] temp = new int [ n ] ; PApplet . arrayCopy ( lastIndex , 0 , temp , 0 , size ) ; lastIndex = temp ; } void expandFirstCache ( int n ) { int [ ] temp = new int [ n ] ; PApplet . arrayCopy ( firstCache , 0 , temp , 0 , size ) ; firstCache = temp ; } void expandLastCache ( int n ) { int [ ] temp = new int [ n ] ; PApplet . arrayCopy ( lastCache , 0 , temp , 0 , size ) ; lastCache = temp ; } } static protected class IndexCache { int size ; int [ ] indexCount ; int [ ] indexOffset ; int [ ] vertexCount ; int [ ] vertexOffset ; IndexCache ( ) { allocate ( ) ; } void allocate ( ) { indexCount = new int [ 2 ] ; indexOffset = new int [ 2 ] ; vertexCount = new int [ 2 ] ; vertexOffset = new int [ 2 ] ; size = 0 ; } void clear ( ) { size = 0 ; } int addNew ( ) { arrayCheck ( ) ; init ( size ) ; size ++ ; return size - 1 ; } int addNew ( int index ) { arrayCheck ( ) ; indexCount [ size ] = indexCount [ index ] ; indexOffset [ size ] = indexOffset [ index ] ; vertexCount [ size ] = vertexCount [ index ] ; vertexOffset [ size ] = vertexOffset [ index ] ; size ++ ; return size - 1 ; } int getLast ( ) { if ( size == 0 ) { arrayCheck ( ) ; init ( 0 ) ; size = 1 ; } return size - 1 ; } void incCounts ( int index , int icount , int vcount ) { indexCount [ index ] += icount ; vertexCount [ index ] += vcount ; } void init ( int n ) { if ( 0 < n ) { indexOffset [ n ] = indexOffset [ n - 1 ] + indexCount [ n - 1 ] ; vertexOffset [ n ] = vertexOffset [ n - 1 ] + vertexCount [ n - 1 ] ; } else { indexOffset [ n ] = 0 ; vertexOffset [ n ] = 0 ; } indexCount [ n ] = 0 ; vertexCount [ n ] = 0 ; } void arrayCheck ( ) { if ( size == indexCount . length ) { int newSize = size < < 1 ; expandIndexCount ( newSize ) ; expandIndexOffset ( newSize ) ; expandVertexCount ( newSize ) ; expandVertexOffset ( newSize ) ; } } void expandIndexCount ( int n ) { int [ ] temp = new int [ n ] ; PApplet . arrayCopy ( indexCount , 0 , temp , 0 , size ) ; indexCount = temp ; } void expandIndexOffset ( int n ) { int [ ] temp = new int [ n ] ; PApplet . arrayCopy ( indexOffset , 0 , temp , 0 , size ) ; indexOffset = temp ; } void expandVertexCount ( int n ) { int [ ] temp = new int [ n ] ; PApplet . arrayCopy ( vertexCount , 0 , temp , 0 , size ) ; vertexCount = temp ; } void expandVertexOffset ( int n ) { int [ ] temp = new int [ n ] ; PApplet . arrayCopy ( vertexOffset , 0 , temp , 0 , size ) ; vertexOffset = temp ; } } static protected class InGeometry { PGraphicsOpenGL pg ; int renderMode ; AttributeMap attribs ; int vertexCount ; int codeCount ; int edgeCount ; float [ ] vertices ; int [ ] colors ; float [ ] normals ; float [ ] texcoords ; int [ ] strokeColors ; float [ ] strokeWeights ; int [ ] codes ; int [ ] [ ] edges ; int [ ] ambient ; int [ ] specular ; int [ ] emissive ; float [ ] shininess ; HashMap < String , float [ ] > fattribs ; HashMap < String , int [ ] > iattribs ; HashMap < String , byte [ ] > battribs ; int fillColor ; int strokeColor ; float strokeWeight ; int ambientColor ; int specularColor ; int emissiveColor ; float shininessFactor ; float normalX , normalY , normalZ ; InGeometry ( PGraphicsOpenGL pg , AttributeMap attr , int mode ) { this . pg = pg ; this . attribs = attr ; renderMode = mode ; allocate ( ) ; } void clear ( ) { vertexCount = 0 ; codeCount = 0 ; edgeCount = 0 ; } void clearEdges ( ) { edgeCount = 0 ; } void allocate ( ) { vertices = new float [ 3 * PGL . DEFAULT_IN_VERTICES ] ; colors = new int [ PGL . DEFAULT_IN_VERTICES ] ; normals = new float [ 3 * PGL . DEFAULT_IN_VERTICES ] ; texcoords = new float [ 2 * PGL . DEFAULT_IN_VERTICES ] ; strokeColors = new int [ PGL . DEFAULT_IN_VERTICES ] ; strokeWeights = new float [ PGL . DEFAULT_IN_VERTICES ] ; ambient = new int [ PGL . DEFAULT_IN_VERTICES ] ; specular = new int [ PGL . DEFAULT_IN_VERTICES ] ; emissive = new int [ PGL . DEFAULT_IN_VERTICES ] ; shininess = new float [ PGL . DEFAULT_IN_VERTICES ] ; edges = new int [ PGL . DEFAULT_IN_EDGES ] [ 3 ] ; fattribs = new HashMap < String , float [ ] > ( ) ; iattribs = new HashMap < String , int [ ] > ( ) ; battribs = new HashMap < String , byte [ ] > ( ) ; clear ( ) ; } void initAttrib ( VertexAttribute attrib ) { if ( attrib . type == PGL . FLOAT ) { float [ ] temp = new float [ attrib . size * PGL . DEFAULT_IN_VERTICES ] ; fattribs . put ( attrib . name , temp ) ; } else if ( attrib . type == PGL . INT ) { int [ ] temp = new int [ attrib . size * PGL . DEFAULT_IN_VERTICES ] ; iattribs . put ( attrib . name , temp ) ; } else if ( attrib . type == PGL . BOOL ) { byte [ ] temp = new byte [ attrib . size * PGL . DEFAULT_IN_VERTICES ] ; battribs . put ( attrib . name , temp ) ; } } void vertexCheck ( ) { if ( vertexCount == vertices . length / 3 ) { int newSize = vertexCount < < 1 ; expandVertices ( newSize ) ; expandColors ( newSize ) ; expandNormals ( newSize ) ; expandTexCoords ( newSize ) ; expandStrokeColors ( newSize ) ; expandStrokeWeights ( newSize ) ; expandAmbient ( newSize ) ; expandSpecular ( newSize ) ; expandEmissive ( newSize ) ; expandShininess ( newSize ) ; expandAttribs ( newSize ) ; } } void codeCheck ( ) { if ( codeCount == codes . length ) { int newLen = codeCount < < 1 ; expandCodes ( newLen ) ; } } void edgeCheck ( ) { if ( edgeCount == edges . length ) { int newLen = edgeCount < < 1 ; expandEdges ( newLen ) ; } } float getVertexX ( int idx ) { return vertices [ 3 * idx + 0 ] ; } float getVertexY ( int idx ) { return vertices [ 3 * idx + 1 ] ; } float getVertexZ ( int idx ) { return vertices [ 3 * idx + 2 ] ; } float getLastVertexX ( ) { return vertices [ 3 * ( vertexCount - 1 ) + 0 ] ; } float getLastVertexY ( ) { return vertices [ 3 * ( vertexCount - 1 ) + 1 ] ; } float getLastVertexZ ( ) { return vertices [ 3 * ( vertexCount - 1 ) + 2 ] ; } int getNumEdgeClosures ( ) { int count = 0 ; for ( int i = 0 ; i < edgeCount ; i ++ ) { if ( edges [ i ] [ 2 ] == EDGE_CLOSE ) count ++ ; } return count ; } int getNumEdgeVertices ( boolean bevel ) { int segVert = edgeCount ; int bevVert = 0 ; if ( bevel ) { for ( int i = 0 ; i < edgeCount ; i ++ ) { int [ ] edge = edges [ i ] ; if ( edge [ 2 ] == EDGE_MIDDLE || edge [ 2 ] == EDGE_START ) bevVert ++ ; if ( edge [ 2 ] == EDGE_CLOSE ) segVert -- ; } } else { segVert -= getNumEdgeClosures ( ) ; } return 4 * segVert + bevVert ; } int getNumEdgeIndices ( boolean bevel ) { int segInd = edgeCount ; int bevInd = 0 ; if ( bevel ) { for ( int i = 0 ; i < edgeCount ; i ++ ) { int [ ] edge = edges [ i ] ; if ( edge [ 2 ] == EDGE_MIDDLE || edge [ 2 ] == EDGE_START ) bevInd ++ ; if ( edge [ 2 ] == EDGE_CLOSE ) segInd -- ; } } else { segInd -= getNumEdgeClosures ( ) ; } return 6 * ( segInd + bevInd ) ; } void getVertexMin ( PVector v ) { int index ; for ( int i = 0 ; i < vertexCount ; i ++ ) { index = 4 * i ; v . x = PApplet . min ( v . x , vertices [ index ++ ] ) ; v . y = PApplet . min ( v . y , vertices [ index ++ ] ) ; v . z = PApplet . min ( v . z , vertices [ index ] ) ; } } void getVertexMax ( PVector v ) { int index ; for ( int i = 0 ; i < vertexCount ; i ++ ) { index = 4 * i ; v . x = PApplet . max ( v . x , vertices [ index ++ ] ) ; v . y = PApplet . max ( v . y , vertices [ index ++ ] ) ; v . z = PApplet . max ( v . z , vertices [ index ] ) ; } } int getVertexSum ( PVector v ) { int index ; for ( int i = 0 ; i < vertexCount ; i ++ ) { index = 4 * i ; v . x += vertices [ index ++ ] ; v . y += vertices [ index ++ ] ; v . z += vertices [ index ] ; } return vertexCount ; } double [ ] getAttribVector ( int idx ) { double [ ] vector = new double [ attribs . numComp ] ; int vidx = 0 ; for ( int i = 0 ; i < attribs . size ( ) ; i ++ ) { VertexAttribute attrib = attribs . get ( i ) ; String name = attrib . name ; int aidx = attrib . size * idx ; if ( attrib . isColor ( ) ) { int [ ] iarray = iattribs . get ( name ) ; int col = iarray [ aidx ] ; vector [ vidx ++ ] = ( col > > 24 ) & 0xFF ; vector [ vidx ++ ] = ( col > > 16 ) & 0xFF ; vector [ vidx ++ ] = ( col > > 8 ) & 0xFF ; vector [ vidx ++ ] = ( col > > 0 ) & 0xFF ; } else { if ( attrib . isFloat ( ) ) { float [ ] farray = fattribs . get ( name ) ; for ( int n = 0 ; n < attrib . size ; n ++ ) { vector [ vidx ++ ] = farray [ aidx ++ ] ; } } else if ( attrib . isInt ( ) ) { int [ ] iarray = iattribs . get ( name ) ; for ( int n = 0 ; n < attrib . size ; n ++ ) { vector [ vidx ++ ] = iarray [ aidx ++ ] ; } } else if ( attrib . isBool ( ) ) { byte [ ] barray = battribs . get ( name ) ; for ( int n = 0 ; n < attrib . size ; n ++ ) { vector [ vidx ++ ] = barray [ aidx ++ ] ; } } } } return vector ; } void expandVertices ( int n ) { float temp [ ] = new float [ 3 * n ] ; PApplet . arrayCopy ( vertices , 0 , temp , 0 , 3 * vertexCount ) ; vertices = temp ; } void expandColors ( int n ) { int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( colors , 0 , temp , 0 , vertexCount ) ; colors = temp ; } void expandNormals ( int n ) { float temp [ ] = new float [ 3 * n ] ; PApplet . arrayCopy ( normals , 0 , temp , 0 , 3 * vertexCount ) ; normals = temp ; } void expandTexCoords ( int n ) { float temp [ ] = new float [ 2 * n ] ; PApplet . arrayCopy ( texcoords , 0 , temp , 0 , 2 * vertexCount ) ; texcoords = temp ; } void expandStrokeColors ( int n ) { int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( strokeColors , 0 , temp , 0 , vertexCount ) ; strokeColors = temp ; } void expandStrokeWeights ( int n ) { float temp [ ] = new float [ n ] ; PApplet . arrayCopy ( strokeWeights , 0 , temp , 0 , vertexCount ) ; strokeWeights = temp ; } void expandAmbient ( int n ) { int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( ambient , 0 , temp , 0 , vertexCount ) ; ambient = temp ; } void expandSpecular ( int n ) { int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( specular , 0 , temp , 0 , vertexCount ) ; specular = temp ; } void expandEmissive ( int n ) { int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( emissive , 0 , temp , 0 , vertexCount ) ; emissive = temp ; } void expandShininess ( int n ) { float temp [ ] = new float [ n ] ; PApplet . arrayCopy ( shininess , 0 , temp , 0 , vertexCount ) ; shininess = temp ; } void expandAttribs ( int n ) { for ( String name : attribs . keySet ( ) ) { VertexAttribute attrib = attribs . get ( name ) ; if ( attrib . type == PGL . FLOAT ) { expandFloatAttrib ( attrib , n ) ; } else if ( attrib . type == PGL . INT ) { expandIntAttrib ( attrib , n ) ; } else if ( attrib . type == PGL . BOOL ) { expandBoolAttrib ( attrib , n ) ; } } } void expandFloatAttrib ( VertexAttribute attrib , int n ) { float [ ] values = fattribs . get ( attrib . name ) ; float temp [ ] = new float [ attrib . size * n ] ; PApplet . arrayCopy ( values , 0 , temp , 0 , attrib . size * vertexCount ) ; fattribs . put ( attrib . name , temp ) ; } void expandIntAttrib ( VertexAttribute attrib , int n ) { int [ ] values = iattribs . get ( attrib . name ) ; int temp [ ] = new int [ attrib . size * n ] ; PApplet . arrayCopy ( values , 0 , temp , 0 , attrib . size * vertexCount ) ; iattribs . put ( attrib . name , temp ) ; } void expandBoolAttrib ( VertexAttribute attrib , int n ) { byte [ ] values = battribs . get ( attrib . name ) ; byte temp [ ] = new byte [ attrib . size * n ] ; PApplet . arrayCopy ( values , 0 , temp , 0 , attrib . size * vertexCount ) ; battribs . put ( attrib . name , temp ) ; } void expandCodes ( int n ) { int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( codes , 0 , temp , 0 , codeCount ) ; codes = temp ; } void expandEdges ( int n ) { int temp [ ] [ ] = new int [ n ] [ 3 ] ; PApplet . arrayCopy ( edges , 0 , temp , 0 , edgeCount ) ; edges = temp ; } void trim ( ) { if ( 0 < vertexCount && vertexCount < vertices . length / 3 ) { trimVertices ( ) ; trimColors ( ) ; trimNormals ( ) ; trimTexCoords ( ) ; trimStrokeColors ( ) ; trimStrokeWeights ( ) ; trimAmbient ( ) ; trimSpecular ( ) ; trimEmissive ( ) ; trimShininess ( ) ; trimAttribs ( ) ; } if ( 0 < codeCount && codeCount < codes . length ) { trimCodes ( ) ; } if ( 0 < edgeCount && edgeCount < edges . length ) { trimEdges ( ) ; } } void trimVertices ( ) { float temp [ ] = new float [ 3 * vertexCount ] ; PApplet . arrayCopy ( vertices , 0 , temp , 0 , 3 * vertexCount ) ; vertices = temp ; } void trimColors ( ) { int temp [ ] = new int [ vertexCount ] ; PApplet . arrayCopy ( colors , 0 , temp , 0 , vertexCount ) ; colors = temp ; } void trimNormals ( ) { float temp [ ] = new float [ 3 * vertexCount ] ; PApplet . arrayCopy ( normals , 0 , temp , 0 , 3 * vertexCount ) ; normals = temp ; } void trimTexCoords ( ) { float temp [ ] = new float [ 2 * vertexCount ] ; PApplet . arrayCopy ( texcoords , 0 , temp , 0 , 2 * vertexCount ) ; texcoords = temp ; } void trimStrokeColors ( ) { int temp [ ] = new int [ vertexCount ] ; PApplet . arrayCopy ( strokeColors , 0 , temp , 0 , vertexCount ) ; strokeColors = temp ; } void trimStrokeWeights ( ) { float temp [ ] = new float [ vertexCount ] ; PApplet . arrayCopy ( strokeWeights , 0 , temp , 0 , vertexCount ) ; strokeWeights = temp ; } void trimAmbient ( ) { int temp [ ] = new int [ vertexCount ] ; PApplet . arrayCopy ( ambient , 0 , temp , 0 , vertexCount ) ; ambient = temp ; } void trimSpecular ( ) { int temp [ ] = new int [ vertexCount ] ; PApplet . arrayCopy ( specular , 0 , temp , 0 , vertexCount ) ; specular = temp ; } void trimEmissive ( ) { int temp [ ] = new int [ vertexCount ] ; PApplet . arrayCopy ( emissive , 0 , temp , 0 , vertexCount ) ; emissive = temp ; } void trimShininess ( ) { float temp [ ] = new float [ vertexCount ] ; PApplet . arrayCopy ( shininess , 0 , temp , 0 , vertexCount ) ; shininess = temp ; } void trimCodes ( ) { int temp [ ] = new int [ codeCount ] ; PApplet . arrayCopy ( codes , 0 , temp , 0 , codeCount ) ; codes = temp ; } void trimEdges ( ) { int temp [ ] [ ] = new int [ edgeCount ] [ 3 ] ; PApplet . arrayCopy ( edges , 0 , temp , 0 , edgeCount ) ; edges = temp ; } void trimAttribs ( ) { for ( String name : attribs . keySet ( ) ) { VertexAttribute attrib = attribs . get ( name ) ; if ( attrib . type == PGL . FLOAT ) { trimFloatAttrib ( attrib ) ; } else if ( attrib . type == PGL . INT ) { trimIntAttrib ( attrib ) ; } else if ( attrib . type == PGL . BOOL ) { trimBoolAttrib ( attrib ) ; } } } void trimFloatAttrib ( VertexAttribute attrib ) { float [ ] values = fattribs . get ( attrib . name ) ; float temp [ ] = new float [ attrib . size * vertexCount ] ; PApplet . arrayCopy ( values , 0 , temp , 0 , attrib . size * vertexCount ) ; fattribs . put ( attrib . name , temp ) ; } void trimIntAttrib ( VertexAttribute attrib ) { int [ ] values = iattribs . get ( attrib . name ) ; int temp [ ] = new int [ attrib . size * vertexCount ] ; PApplet . arrayCopy ( values , 0 , temp , 0 , attrib . size * vertexCount ) ; iattribs . put ( attrib . name , temp ) ; } void trimBoolAttrib ( VertexAttribute attrib ) { byte [ ] values = battribs . get ( attrib . name ) ; byte temp [ ] = new byte [ attrib . size * vertexCount ] ; PApplet . arrayCopy ( values , 0 , temp , 0 , attrib . size * vertexCount ) ; battribs . put ( attrib . name , temp ) ; } int addVertex ( float x , float y , boolean brk ) { return addVertex ( x , y , VERTEX , brk ) ; } int addVertex ( float x , float y , int code , boolean brk ) { return addVertex ( x , y , 0 , fillColor , normalX , normalY , normalZ , 0 , 0 , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininessFactor , code , brk ) ; } int addVertex ( float x , float y , float u , float v , boolean brk ) { return addVertex ( x , y , u , v , VERTEX , brk ) ; } int addVertex ( float x , float y , float u , float v , int code , boolean brk ) { return addVertex ( x , y , 0 , fillColor , normalX , normalY , normalZ , u , v , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininessFactor , code , brk ) ; } int addVertex ( float x , float y , float z , boolean brk ) { return addVertex ( x , y , z , VERTEX , brk ) ; } int addVertex ( float x , float y , float z , int code , boolean brk ) { return addVertex ( x , y , z , fillColor , normalX , normalY , normalZ , 0 , 0 , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininessFactor , code , brk ) ; } int addVertex ( float x , float y , float z , float u , float v , boolean brk ) { return addVertex ( x , y , z , u , v , VERTEX , brk ) ; } int addVertex ( float x , float y , float z , float u , float v , int code , boolean brk ) { return addVertex ( x , y , z , fillColor , normalX , normalY , normalZ , u , v , strokeColor , strokeWeight , ambientColor , specularColor , emissiveColor , shininessFactor , code , brk ) ; } int addVertex ( float x , float y , float z , int fcolor , float nx , float ny , float nz , float u , float v , int scolor , float sweight , int am , int sp , int em , float shine , int code , boolean brk ) { vertexCheck ( ) ; int index ; index = 3 * vertexCount ; vertices [ index ++ ] = x ; vertices [ index ++ ] = y ; vertices [ index ] = z ; colors [ vertexCount ] = PGL . javaToNativeARGB ( fcolor ) ; index = 3 * vertexCount ; normals [ index ++ ] = nx ; normals [ index ++ ] = ny ; normals [ index ] = nz ; index = 2 * vertexCount ; texcoords [ index ++ ] = u ; texcoords [ index ] = v ; strokeColors [ vertexCount ] = PGL . javaToNativeARGB ( scolor ) ; strokeWeights [ vertexCount ] = sweight ; ambient [ vertexCount ] = PGL . javaToNativeARGB ( am ) ; specular [ vertexCount ] = PGL . javaToNativeARGB ( sp ) ; emissive [ vertexCount ] = PGL . javaToNativeARGB ( em ) ; shininess [ vertexCount ] = shine ; for ( String name : attribs . keySet ( ) ) { VertexAttribute attrib = attribs . get ( name ) ; index = attrib . size * vertexCount ; if ( attrib . type == PGL . FLOAT ) { float [ ] values = fattribs . get ( name ) ; attrib . add ( values , index ) ; } else if ( attrib . type == PGL . INT ) { int [ ] values = iattribs . get ( name ) ; attrib . add ( values , index ) ; } else if ( attrib . type == PGL . BOOL ) { byte [ ] values = battribs . get ( name ) ; attrib . add ( values , index ) ; } } if ( brk || ( code == VERTEX && codes != null ) || code == BEZIER_VERTEX || code == QUADRATIC_VERTEX || code == CURVE_VERTEX ) { if ( codes == null ) { codes = new int [ PApplet . max ( PGL . DEFAULT_IN_VERTICES , vertexCount ) ] ; Arrays . fill ( codes , 0 , vertexCount , VERTEX ) ; codeCount = vertexCount ; } if ( brk ) { codeCheck ( ) ; codes [ codeCount ] = BREAK ; codeCount ++ ; } if ( code != - 1 ) { codeCheck ( ) ; codes [ codeCount ] = code ; codeCount ++ ; } } vertexCount ++ ; return vertexCount - 1 ; } public void addBezierVertex ( float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 , boolean brk ) { addVertex ( x2 , y2 , z2 , BEZIER_VERTEX , brk ) ; addVertex ( x3 , y3 , z3 , - 1 , false ) ; addVertex ( x4 , y4 , z4 , - 1 , false ) ; } public void addQuadraticVertex ( float cx , float cy , float cz , float x3 , float y3 , float z3 , boolean brk ) { addVertex ( cx , cy , cz , QUADRATIC_VERTEX , brk ) ; addVertex ( x3 , y3 , z3 , - 1 , false ) ; } public void addCurveVertex ( float x , float y , float z , boolean brk ) { addVertex ( x , y , z , CURVE_VERTEX , brk ) ; } float [ ] [ ] getVertexData ( ) { float [ ] [ ] data = new float [ vertexCount ] [ VERTEX_FIELD_COUNT ] ; for ( int i = 0 ; i < vertexCount ; i ++ ) { float [ ] vert = data [ i ] ; vert [ X ] = vertices [ 3 * i + 0 ] ; vert [ Y ] = vertices [ 3 * i + 1 ] ; vert [ Z ] = vertices [ 3 * i + 2 ] ; vert [ R ] = ( ( colors [ i ] > > 16 ) & 0xFF ) / 255.0f ; vert [ G ] = ( ( colors [ i ] > > 8 ) & 0xFF ) / 255.0f ; vert [ B ] = ( ( colors [ i ] > > 0 ) & 0xFF ) / 255.0f ; vert [ A ] = ( ( colors [ i ] > > 24 ) & 0xFF ) / 255.0f ; vert [ U ] = texcoords [ 2 * i + 0 ] ; vert [ V ] = texcoords [ 2 * i + 1 ] ; vert [ NX ] = normals [ 3 * i + 0 ] ; vert [ NY ] = normals [ 3 * i + 1 ] ; vert [ NZ ] = normals [ 3 * i + 2 ] ; vert [ SR ] = ( ( strokeColors [ i ] > > 16 ) & 0xFF ) / 255.0f ; vert [ SG ] = ( ( strokeColors [ i ] > > 8 ) & 0xFF ) / 255.0f ; vert [ SB ] = ( ( strokeColors [ i ] > > 0 ) & 0xFF ) / 255.0f ; vert [ SA ] = ( ( strokeColors [ i ] > > 24 ) & 0xFF ) / 255.0f ; vert [ SW ] = strokeWeights [ i ] ; } return data ; } boolean hasBezierVertex ( ) { for ( int i = 0 ; i < codeCount ; i ++ ) { if ( codes [ i ] == BEZIER_VERTEX ) return true ; } return false ; } boolean hasQuadraticVertex ( ) { for ( int i = 0 ; i < codeCount ; i ++ ) { if ( codes [ i ] == QUADRATIC_VERTEX ) return true ; } return false ; } boolean hasCurveVertex ( ) { for ( int i = 0 ; i < codeCount ; i ++ ) { if ( codes [ i ] == CURVE_VERTEX ) return true ; } return false ; } int addEdge ( int i , int j , boolean start , boolean end ) { edgeCheck ( ) ; int [ ] edge = edges [ edgeCount ] ; edge [ 0 ] = i ; edge [ 1 ] = j ; edge [ 2 ] = ( start ? 1 : 0 ) + 2 * ( end ? 1 : 0 ) ; edgeCount ++ ; return edgeCount - 1 ; } int closeEdge ( int i , int j ) { edgeCheck ( ) ; int [ ] edge = edges [ edgeCount ] ; edge [ 0 ] = i ; edge [ 1 ] = j ; edge [ 2 ] = EDGE_CLOSE ; edgeCount ++ ; return edgeCount - 1 ; } void addTrianglesEdges ( ) { for ( int i = 0 ; i < vertexCount / 3 ; i ++ ) { int i0 = 3 * i + 0 ; int i1 = 3 * i + 1 ; int i2 = 3 * i + 2 ; addEdge ( i0 , i1 , true , false ) ; addEdge ( i1 , i2 , false , false ) ; addEdge ( i2 , i0 , false , false ) ; closeEdge ( i2 , i0 ) ; } } void addTriangleFanEdges ( ) { for ( int i = 1 ; i < vertexCount - 1 ; i ++ ) { int i0 = 0 ; int i1 = i ; int i2 = i + 1 ; addEdge ( i0 , i1 , true , false ) ; addEdge ( i1 , i2 , false , false ) ; addEdge ( i2 , i0 , false , false ) ; closeEdge ( i2 , i0 ) ; } } void addTriangleStripEdges ( ) { for ( int i = 1 ; i < vertexCount - 1 ; i ++ ) { int i0 = i ; int i1 , i2 ; if ( i % 2 == 0 ) { i1 = i - 1 ;
i2 = i + 1 ; } else { i1 = i + 1 ; i2 = i - 1 ; } addEdge ( i0 , i1 , true , false ) ; addEdge ( i1 , i2 , false , false ) ; addEdge ( i2 , i0 , false , false ) ; closeEdge ( i2 , i0 ) ; } } void addQuadsEdges ( ) { for ( int i = 0 ; i < vertexCount / 4 ; i ++ ) { int i0 = 4 * i + 0 ; int i1 = 4 * i + 1 ; int i2 = 4 * i + 2 ; int i3 = 4 * i + 3 ; addEdge ( i0 , i1 , true , false ) ; addEdge ( i1 , i2 , false , false ) ; addEdge ( i2 , i3 , false , false ) ; addEdge ( i3 , i0 , false , false ) ; closeEdge ( i3 , i0 ) ; } } void addQuadStripEdges ( ) { for ( int qd = 1 ; qd < vertexCount / 2 ; qd ++ ) { int i0 = 2 * ( qd - 1 ) ; int i1 = 2 * ( qd - 1 ) + 1 ; int i2 = 2 * qd + 1 ; int i3 = 2 * qd ; addEdge ( i0 , i1 , true , false ) ; addEdge ( i1 , i2 , false , false ) ; addEdge ( i2 , i3 , false , false ) ; addEdge ( i3 , i0 , false , true ) ; closeEdge ( i3 , i0 ) ; } } void calcTriangleNormal ( int i0 , int i1 , int i2 ) { int index ; index = 3 * i0 ; float x0 = vertices [ index ++ ] ; float y0 = vertices [ index ++ ] ; float z0 = vertices [ index ] ; index = 3 * i1 ; float x1 = vertices [ index ++ ] ; float y1 = vertices [ index ++ ] ; float z1 = vertices [ index ] ; index = 3 * i2 ; float x2 = vertices [ index ++ ] ; float y2 = vertices [ index ++ ] ; float z2 = vertices [ index ] ; float v12x = x2 - x1 ; float v12y = y2 - y1 ; float v12z = z2 - z1 ; float v10x = x0 - x1 ; float v10y = y0 - y1 ; float v10z = z0 - z1 ; float nx = v12y * v10z - v10y * v12z ; float ny = v12z * v10x - v10z * v12x ; float nz = v12x * v10y - v10x * v12y ; float d = PApplet . sqrt ( nx * nx + ny * ny + nz * nz ) ; nx /= d ; ny /= d ; nz /= d ; index = 3 * i0 ; normals [ index ++ ] = nx ; normals [ index ++ ] = ny ; normals [ index ] = nz ; index = 3 * i1 ; normals [ index ++ ] = nx ; normals [ index ++ ] = ny ; normals [ index ] = nz ; index = 3 * i2 ; normals [ index ++ ] = nx ; normals [ index ++ ] = ny ; normals [ index ] = nz ; } void calcTrianglesNormals ( ) { for ( int i = 0 ; i < vertexCount / 3 ; i ++ ) { int i0 = 3 * i + 0 ; int i1 = 3 * i + 1 ; int i2 = 3 * i + 2 ; calcTriangleNormal ( i0 , i1 , i2 ) ; } } void calcTriangleFanNormals ( ) { for ( int i = 1 ; i < vertexCount - 1 ; i ++ ) { int i0 = 0 ; int i1 = i ; int i2 = i + 1 ; calcTriangleNormal ( i0 , i1 , i2 ) ; } } void calcTriangleStripNormals ( ) { for ( int i = 1 ; i < vertexCount - 1 ; i ++ ) { int i1 = i ; int i0 , i2 ; if ( i % 2 == 1 ) { i0 = i - 1 ; i2 = i + 1 ; } else { i0 = i + 1 ; i2 = i - 1 ; } calcTriangleNormal ( i0 , i1 , i2 ) ; } } void calcQuadsNormals ( ) { for ( int i = 0 ; i < vertexCount / 4 ; i ++ ) { int i0 = 4 * i + 0 ; int i1 = 4 * i + 1 ; int i2 = 4 * i + 2 ; int i3 = 4 * i + 3 ; calcTriangleNormal ( i0 , i1 , i2 ) ; calcTriangleNormal ( i2 , i3 , i0 ) ; } } void calcQuadStripNormals ( ) { for ( int qd = 1 ; qd < vertexCount / 2 ; qd ++ ) { int i0 = 2 * ( qd - 1 ) ; int i1 = 2 * ( qd - 1 ) + 1 ; int i2 = 2 * qd ; int i3 = 2 * qd + 1 ; calcTriangleNormal ( i0 , i1 , i2 ) ; calcTriangleNormal ( i2 , i1 , i3 ) ; } } void setMaterial ( int fillColor , int strokeColor , float strokeWeight , int ambientColor , int specularColor , int emissiveColor , float shininessFactor ) { this . fillColor = fillColor ; this . strokeColor = strokeColor ; this . strokeWeight = strokeWeight ; this . ambientColor = ambientColor ; this . specularColor = specularColor ; this . emissiveColor = emissiveColor ; this . shininessFactor = shininessFactor ; } void setNormal ( float normalX , float normalY , float normalZ ) { this . normalX = normalX ; this . normalY = normalY ; this . normalZ = normalZ ; } void addPoint ( float x , float y , float z , boolean fill , boolean stroke ) { addVertex ( x , y , z , VERTEX , true ) ; } void addLine ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , boolean fill , boolean stroke ) { int idx1 = addVertex ( x1 , y1 , z1 , VERTEX , true ) ; int idx2 = addVertex ( x2 , y2 , z2 , VERTEX , false ) ; if ( stroke ) addEdge ( idx1 , idx2 , true , true ) ; } void addTriangle ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , boolean fill , boolean stroke ) { int idx1 = addVertex ( x1 , y1 , z1 , VERTEX , true ) ; int idx2 = addVertex ( x2 , y2 , z2 , VERTEX , false ) ; int idx3 = addVertex ( x3 , y3 , z3 , VERTEX , false ) ; if ( stroke ) { addEdge ( idx1 , idx2 , true , false ) ; addEdge ( idx2 , idx3 , false , false ) ; addEdge ( idx3 , idx1 , false , false ) ; closeEdge ( idx3 , idx1 ) ; } } void addQuad ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 , boolean stroke ) { int idx1 = addVertex ( x1 , y1 , z1 , 0 , 0 , VERTEX , true ) ; int idx2 = addVertex ( x2 , y2 , z2 , 1 , 0 , VERTEX , false ) ; int idx3 = addVertex ( x3 , y3 , z3 , 1 , 1 , VERTEX , false ) ; int idx4 = addVertex ( x4 , y4 , z4 , 0 , 1 , VERTEX , false ) ; if ( stroke ) { addEdge ( idx1 , idx2 , true , false ) ; addEdge ( idx2 , idx3 , false , false ) ; addEdge ( idx3 , idx4 , false , false ) ; addEdge ( idx4 , idx1 , false , false ) ; closeEdge ( idx4 , idx1 ) ; } } void addRect ( float a , float b , float c , float d , boolean stroke ) { addQuad ( a , b , 0 , c , b , 0 , c , d , 0 , a , d , 0 , stroke ) ; } void addRect ( float a , float b , float c , float d , float tl , float tr , float br , float bl , boolean stroke ) { if ( nonZero ( tr ) ) { addVertex ( c - tr , b , VERTEX , true ) ; addQuadraticVertex ( c , b , 0 , c , b + tr , 0 , false ) ; } else { addVertex ( c , b , VERTEX , true ) ; } if ( nonZero ( br ) ) { addVertex ( c , d - br , VERTEX , false ) ; addQuadraticVertex ( c , d , 0 , c - br , d , 0 , false ) ; } else { addVertex ( c , d , VERTEX , false ) ; } if ( nonZero ( bl ) ) { addVertex ( a + bl , d , VERTEX , false ) ; addQuadraticVertex ( a , d , 0 , a , d - bl , 0 , false ) ; } else { addVertex ( a , d , VERTEX , false ) ; } if ( nonZero ( tl ) ) { addVertex ( a , b + tl , VERTEX , false ) ; addQuadraticVertex ( a , b , 0 , a + tl , b , 0 , false ) ; } else { addVertex ( a , b , VERTEX , false ) ; } } void addEllipse ( float x , float y , float w , float h , boolean fill , boolean stroke ) { float radiusH = w / 2 ; float radiusV = h / 2 ; float centerX = x + radiusH ; float centerY = y + radiusV ; float sx1 = pg . screenX ( x , y ) ; float sy1 = pg . screenY ( x , y ) ; float sx2 = pg . screenX ( x + w , y + h ) ; float sy2 = pg . screenY ( x + w , y + h ) ; int accuracy = PApplet . min ( MAX_POINT_ACCURACY , PApplet . max ( MIN_POINT_ACCURACY , ( int ) ( TWO_PI * PApplet . dist ( sx1 , sy1 , sx2 , sy2 ) / POINT_ACCURACY_FACTOR ) ) ) ; float inc = ( float ) SINCOS_LENGTH / accuracy ; if ( fill ) { addVertex ( centerX , centerY , VERTEX , true ) ; } int idx0 , pidx , idx ; idx0 = pidx = idx = 0 ; float val = 0 ; for ( int i = 0 ; i < accuracy ; i ++ ) { idx = addVertex ( centerX + cosLUT [ ( int ) val ] * radiusH , centerY + sinLUT [ ( int ) val ] * radiusV , VERTEX , i == 0 && ! fill ) ; val = ( val + inc ) % SINCOS_LENGTH ; if ( 0 < i ) { if ( stroke ) addEdge ( pidx , idx , i == 1 , false ) ; } else { idx0 = idx ; } pidx = idx ; } addVertex ( centerX + cosLUT [ 0 ] * radiusH , centerY + sinLUT [ 0 ] * radiusV , VERTEX , false ) ; if ( stroke ) { addEdge ( idx , idx0 , false , false ) ; closeEdge ( idx , idx0 ) ; } } void addArc ( float x , float y , float w , float h , float start , float stop , boolean fill , boolean stroke , int arcMode ) { float hr = w / 2f ; float vr = h / 2f ; float centerX = x + hr ; float centerY = y + vr ; int startLUT = ( int ) ( 0.5f + ( start / TWO_PI ) * SINCOS_LENGTH ) ; int stopLUT = ( int ) ( 0.5f + ( stop / TWO_PI ) * SINCOS_LENGTH ) ; int length = PApplet . constrain ( stopLUT - startLUT , 0 , SINCOS_LENGTH ) ; boolean fullCircle = length == SINCOS_LENGTH ; if ( fullCircle && arcMode == CHORD ) { length -= 1 ; stopLUT -= 1 ; } { startLUT %= SINCOS_LENGTH ; if ( startLUT < 0 ) startLUT += SINCOS_LENGTH ; stopLUT %= SINCOS_LENGTH ; if ( stopLUT < 0 ) stopLUT += SINCOS_LENGTH ; } int idx0 ; if ( arcMode == CHORD || arcMode == OPEN ) { float relX = ( cosLUT [ startLUT ] + cosLUT [ stopLUT ] ) * 0.5f * hr ; float relY = ( sinLUT [ startLUT ] + sinLUT [ stopLUT ] ) * 0.5f * vr ; idx0 = addVertex ( centerX + relX , centerY + relY , VERTEX , true ) ; } else { idx0 = addVertex ( centerX , centerY , VERTEX , true ) ; } int inc ; { float sx1 = pg . screenX ( x , y ) ; float sy1 = pg . screenY ( x , y ) ; float sx2 = pg . screenX ( x + w , y + h ) ; float sy2 = pg . screenY ( x + w , y + h ) ; int accuracy = PApplet . min ( MAX_POINT_ACCURACY , PApplet . max ( MIN_POINT_ACCURACY , ( int ) ( TWO_PI * PApplet . dist ( sx1 , sy1 , sx2 , sy2 ) / POINT_ACCURACY_FACTOR ) ) ) ; inc = PApplet . max ( 1 , SINCOS_LENGTH / accuracy ) ; } int idx = idx0 ; int pidx ; int i = - inc ; int ii ; do { i += inc ; i = PApplet . min ( i , length ) ; ii = startLUT + i ; if ( ii >= SINCOS_LENGTH ) ii -= SINCOS_LENGTH ; pidx = idx ; idx = addVertex ( centerX + cosLUT [ ii ] * hr , centerY + sinLUT [ ii ] * vr , VERTEX , i == 0 && ! fill ) ; if ( stroke ) { if ( arcMode == CHORD || arcMode == PIE ) { addEdge ( pidx , idx , i == 0 , false ) ; } else if ( 0 < i ) { addEdge ( pidx , idx , i == PApplet . min ( inc , length ) , i == length && ! fullCircle ) ; } } } while ( i < length ) ; if ( stroke ) { if ( arcMode == CHORD || arcMode == PIE ) { addEdge ( idx , idx0 , false , false ) ; closeEdge ( idx , idx0 ) ; } else if ( fullCircle ) { closeEdge ( pidx , idx ) ; } } } void addBox ( float w , float h , float d , boolean fill , boolean stroke ) { boolean invertNormX = ( h > 0 ) != ( d > 0 ) ; boolean invertNormY = ( w > 0 ) != ( d > 0 ) ; boolean invertNormZ = ( w > 0 ) != ( h > 0 ) ; int normX = invertNormX ? - 1 : 1 ; int normY = invertNormY ? - 1 : 1 ; int normZ = invertNormZ ? - 1 : 1 ; float x1 = - w / 2f ; float x2 = w / 2f ; float y1 = - h / 2f ; float y2 = h / 2f ; float z1 = - d / 2f ; float z2 = d / 2f ; int idx1 = 0 , idx2 = 0 , idx3 = 0 , idx4 = 0 ; if ( fill || stroke ) { setNormal ( 0 , 0 , - normZ ) ; idx1 = addVertex ( x1 , y1 , z1 , 0 , 0 , VERTEX , true ) ; idx2 = addVertex ( x1 , y2 , z1 , 0 , 1 , VERTEX , false ) ; idx3 = addVertex ( x2 , y2 , z1 , 1 , 1 , VERTEX , false ) ; idx4 = addVertex ( x2 , y1 , z1 , 1 , 0 , VERTEX , false ) ; if ( stroke ) { addEdge ( idx1 , idx2 , true , false ) ; addEdge ( idx2 , idx3 , false , false ) ; addEdge ( idx3 , idx4 , false , false ) ; addEdge ( idx4 , idx1 , false , false ) ; closeEdge ( idx4 , idx1 ) ; } setNormal ( 0 , 0 , normZ ) ; idx1 = addVertex ( x1 , y2 , z2 , 1 , 1 , VERTEX , false ) ; idx2 = addVertex ( x1 , y1 , z2 , 1 , 0 , VERTEX , false ) ; idx3 = addVertex ( x2 , y1 , z2 , 0 , 0 , VERTEX , false ) ; idx4 = addVertex ( x2 , y2 , z2 , 0 , 1 , VERTEX , false ) ; if ( stroke ) { addEdge ( idx1 , idx2 , true , false ) ; addEdge ( idx2 , idx3 , false , false ) ; addEdge ( idx3 , idx4 , false , false ) ; addEdge ( idx4 , idx1 , false , false ) ; closeEdge ( idx4 , idx1 ) ; } setNormal ( normX , 0 , 0 ) ; idx1 = addVertex ( x2 , y1 , z1 , 0 , 0 , VERTEX , false ) ; idx2 = addVertex ( x2 , y2 , z1 , 0 , 1 , VERTEX , false ) ; idx3 = addVertex ( x2 , y2 , z2 , 1 , 1 , VERTEX , false ) ; idx4 = addVertex ( x2 , y1 , z2 , 1 , 0 , VERTEX , false ) ; if ( stroke ) { addEdge ( idx1 , idx2 , true , false ) ; addEdge ( idx2 , idx3 , false , false ) ; addEdge ( idx3 , idx4 , false , false ) ; addEdge ( idx4 , idx1 , false , false ) ; closeEdge ( idx4 , idx1 ) ; } setNormal ( - normX , 0 , 0 ) ; idx1 = addVertex ( x1 , y2 , z1 , 1 , 1 , VERTEX , false ) ; idx2 = addVertex ( x1 , y1 , z1 , 1 , 0 , VERTEX , false ) ; idx3 = addVertex ( x1 , y1 , z2 , 0 , 0 , VERTEX , false ) ; idx4 = addVertex ( x1 , y2 , z2 , 0 , 1 , VERTEX , false ) ; if ( stroke ) { addEdge ( idx1 , idx2 , true , false ) ; addEdge ( idx2 , idx3 , false , false ) ; addEdge ( idx3 , idx4 , false , false ) ; addEdge ( idx4 , idx1 , false , false ) ; closeEdge ( idx4 , idx1 ) ; } setNormal ( 0 , - normY , 0 ) ; idx1 = addVertex ( x2 , y1 , z1 , 1 , 1 , VERTEX , false ) ; idx2 = addVertex ( x2 , y1 , z2 , 1 , 0 , VERTEX , false ) ; idx3 = addVertex ( x1 , y1 , z2 , 0 , 0 , VERTEX , false ) ; idx4 = addVertex ( x1 , y1 , z1 , 0 , 1 , VERTEX , false ) ; if ( stroke ) { addEdge ( idx1 , idx2 , true , false ) ; addEdge ( idx2 , idx3 , false , false ) ; addEdge ( idx3 , idx4 , false , false ) ; addEdge ( idx4 , idx1 , false , false ) ; closeEdge ( idx4 , idx1 ) ; } setNormal ( 0 , normY , 0 ) ; idx1 = addVertex ( x1 , y2 , z1 , 0 , 0 , VERTEX , false ) ; idx2 = addVertex ( x1 , y2 , z2 , 0 , 1 , VERTEX , false ) ; idx3 = addVertex ( x2 , y2 , z2 , 1 , 1 , VERTEX , false ) ; idx4 = addVertex ( x2 , y2 , z1 , 1 , 0 , VERTEX , false ) ; if ( stroke ) { addEdge ( idx1 , idx2 , true , false ) ; addEdge ( idx2 , idx3 , false , false ) ; addEdge ( idx3 , idx4 , false , false ) ; addEdge ( idx4 , idx1 , false , false ) ; closeEdge ( idx4 , idx1 ) ; } } } int [ ] addSphere ( float r , int detailU , int detailV , boolean fill , boolean stroke ) { int nind = 3 * detailU + ( 6 * detailU + 3 ) * ( detailV - 2 ) + 3 * detailU ; int [ ] indices = new int [ nind ] ; int vertCount = 0 ; int indCount = 0 ; int vert0 , vert1 ; float u , v ; float du = 1.0f / ( detailU ) ; float dv = 1.0f / ( detailV ) ; u = 1 ; v = 1 ; for ( int i = 0 ; i < detailU ; i ++ ) { setNormal ( 0 , 1 , 0 ) ; addVertex ( 0 , r , 0 , u , v , VERTEX , true ) ; u -= du ; } vertCount = detailU ; vert0 = vertCount ; u = 1 ; v -= dv ; for ( int i = 0 ; i < detailU ; i ++ ) { setNormal ( pg . sphereX [ i ] , pg . sphereY [ i ] , pg . sphereZ [ i ] ) ; addVertex ( r * pg . sphereX [ i ] , r * pg . sphereY [ i ] , r * pg . sphereZ [ i ] , u , v , VERTEX , false ) ; u -= du ; } vertCount += detailU ; vert1 = vertCount ; setNormal ( pg . sphereX [ 0 ] , pg . sphereY [ 0 ] , pg . sphereZ [ 0 ] ) ; addVertex ( r * pg . sphereX [ 0 ] , r * pg . sphereY [ 0 ] , r * pg . sphereZ [ 0 ] , u , v , VERTEX , false ) ; vertCount ++ ; for ( int i = 0 ; i < detailU ; i ++ ) { int i1 = vert0 + i ; int i0 = vert0 + i - detailU ; indices [ 3 * i + 0 ] = i1 ; indices [ 3 * i + 1 ] = i0 ; indices [ 3 * i + 2 ] = i1 + 1 ; addEdge ( i0 , i1 , true , true ) ; addEdge ( i1 , i1 + 1 , true , true ) ; } indCount += 3 * detailU ; int offset = 0 ; for ( int j = 2 ; j < detailV ; j ++ ) { offset += detailU ; vert0 = vertCount ; u = 1 ; v -= dv ; for ( int i = 0 ; i < detailU ; i ++ ) { int ioff = offset + i ; setNormal ( pg . sphereX [ ioff ] , pg . sphereY [ ioff ] , pg . sphereZ [ ioff ] ) ; addVertex ( r * pg . sphereX [ ioff ] , r * pg . sphereY [ ioff ] , r * pg . sphereZ [ ioff ] , u , v , VERTEX , false ) ; u -= du ; } vertCount += detailU ; vert1 = vertCount ; setNormal ( pg . sphereX [ offset ] , pg . sphereY [ offset ] , pg . sphereZ [ offset ] ) ; addVertex ( r * pg . sphereX [ offset ] , r * pg . sphereY [ offset ] , r * pg . sphereZ [ offset ] , u , v , VERTEX , false ) ; vertCount ++ ; for ( int i = 0 ; i < detailU ; i ++ ) { int i1 = vert0 + i ; int i0 = vert0 + i - detailU - 1 ; indices [ indCount + 6 * i + 0 ] = i1 ; indices [ indCount + 6 * i + 1 ] = i0 ; indices [ indCount + 6 * i + 2 ] = i0 + 1 ; indices [ indCount + 6 * i + 3 ] = i1 ; indices [ indCount + 6 * i + 4 ] = i0 + 1 ; indices [ indCount + 6 * i + 5 ] = i1 + 1 ; addEdge ( i0 , i1 , true , true ) ; addEdge ( i1 , i1 + 1 , true , true ) ; addEdge ( i0 + 1 , i1 , true , true ) ; } indCount += 6 * detailU ; indices [ indCount + 0 ] = vert1 ; indices [ indCount + 1 ] = vert1 - detailU ; indices [ indCount + 2 ] = vert1 - 1 ; indCount += 3 ; } u = 1 ; v = 0 ; for ( int i = 0 ; i < detailU ; i ++ ) { setNormal ( 0 , - 1 , 0 ) ; addVertex ( 0 , - r , 0 , u , v , VERTEX , false ) ; u -= du ; } vertCount += detailU ; for ( int i = 0 ; i < detailU ; i ++ ) { int i0 = vert0 + i ; int i1 = vert0 + i + detailU + 1 ; indices [ indCount + 3 * i + 0 ] = i1 ; indices [ indCount + 3 * i + 1 ] = i0 ; indices [ indCount + 3 * i + 2 ] = i0 + 1 ; addEdge ( i0 , i0 + 1 , true , true ) ; addEdge ( i0 , i1 , true , true ) ; } indCount += 3 * detailU ; return indices ; } } static protected class TessGeometry { int renderMode ; PGraphicsOpenGL pg ; AttributeMap polyAttribs ; int polyVertexCount ; int firstPolyVertex ; int lastPolyVertex ; FloatBuffer polyVerticesBuffer ; IntBuffer polyColorsBuffer ; FloatBuffer polyNormalsBuffer ; FloatBuffer polyTexCoordsBuffer ; IntBuffer polyAmbientBuffer ; IntBuffer polySpecularBuffer ; IntBuffer polyEmissiveBuffer ; FloatBuffer polyShininessBuffer ; HashMap < String , Buffer > polyAttribBuffers = new HashMap < String , Buffer > ( ) ; int polyIndexCount ; int firstPolyIndex ; int lastPolyIndex ; ShortBuffer polyIndicesBuffer ; IndexCache polyIndexCache = new IndexCache ( ) ; int lineVertexCount ; int firstLineVertex ; int lastLineVertex ; FloatBuffer lineVerticesBuffer ; IntBuffer lineColorsBuffer ; FloatBuffer lineDirectionsBuffer ; int lineIndexCount ; int firstLineIndex ; int lastLineIndex ; ShortBuffer lineIndicesBuffer ; IndexCache lineIndexCache = new IndexCache ( ) ; int pointVertexCount ; int firstPointVertex ; int lastPointVertex ; FloatBuffer pointVerticesBuffer ; IntBuffer pointColorsBuffer ; FloatBuffer pointOffsetsBuffer ; int pointIndexCount ; int firstPointIndex ; int lastPointIndex ; ShortBuffer pointIndicesBuffer ; IndexCache pointIndexCache = new IndexCache ( ) ; float [ ] polyVertices ; int [ ] polyColors ; float [ ] polyNormals ; float [ ] polyTexCoords ; int [ ] polyAmbient ; int [ ] polySpecular ; int [ ] polyEmissive ; float [ ] polyShininess ; short [ ] polyIndices ; float [ ] lineVertices ; int [ ] lineColors ; float [ ] lineDirections ; short [ ] lineIndices ; float [ ] pointVertices ; int [ ] pointColors ; float [ ] pointOffsets ; short [ ] pointIndices ; HashMap < String , float [ ] > fpolyAttribs = new HashMap < String , float [ ] > ( ) ; HashMap < String , int [ ] > ipolyAttribs = new HashMap < String , int [ ] > ( ) ; HashMap < String , byte [ ] > bpolyAttribs = new HashMap < String , byte [ ] > ( ) ; TessGeometry ( PGraphicsOpenGL pg , AttributeMap attr , int mode ) { this . pg = pg ; this . polyAttribs = attr ; renderMode = mode ; allocate ( ) ; } void allocate ( ) { polyVertices = new float [ 4 * PGL . DEFAULT_TESS_VERTICES ] ; polyColors = new int [ PGL . DEFAULT_TESS_VERTICES ] ; polyNormals = new float [ 3 * PGL . DEFAULT_TESS_VERTICES ] ; polyTexCoords = new float [ 2 * PGL . DEFAULT_TESS_VERTICES ] ; polyAmbient = new int [ PGL . DEFAULT_TESS_VERTICES ] ; polySpecular = new int [ PGL . DEFAULT_TESS_VERTICES ] ; polyEmissive = new int [ PGL . DEFAULT_TESS_VERTICES ] ; polyShininess = new float [ PGL . DEFAULT_TESS_VERTICES ] ; polyIndices = new short [ PGL . DEFAULT_TESS_VERTICES ] ; lineVertices = new float [ 4 * PGL . DEFAULT_TESS_VERTICES ] ; lineColors = new int [ PGL . DEFAULT_TESS_VERTICES ] ; lineDirections = new float [ 4 * PGL . DEFAULT_TESS_VERTICES ] ; lineIndices = new short [ PGL . DEFAULT_TESS_VERTICES ] ; pointVertices = new float [ 4 * PGL . DEFAULT_TESS_VERTICES ] ; pointColors = new int [ PGL . DEFAULT_TESS_VERTICES ] ; pointOffsets = new float [ 2 * PGL . DEFAULT_TESS_VERTICES ] ; pointIndices = new short [ PGL . DEFAULT_TESS_VERTICES ] ; polyVerticesBuffer = PGL . allocateFloatBuffer ( polyVertices ) ; polyColorsBuffer = PGL . allocateIntBuffer ( polyColors ) ; polyNormalsBuffer = PGL . allocateFloatBuffer ( polyNormals ) ; polyTexCoordsBuffer = PGL . allocateFloatBuffer ( polyTexCoords ) ; polyAmbientBuffer = PGL . allocateIntBuffer ( polyAmbient ) ; polySpecularBuffer = PGL . allocateIntBuffer ( polySpecular ) ; polyEmissiveBuffer = PGL . allocateIntBuffer ( polyEmissive ) ; polyShininessBuffer = PGL . allocateFloatBuffer ( polyShininess ) ; polyIndicesBuffer = PGL . allocateShortBuffer ( polyIndices ) ; lineVerticesBuffer = PGL . allocateFloatBuffer ( lineVertices ) ; lineColorsBuffer = PGL . allocateIntBuffer ( lineColors ) ; lineDirectionsBuffer = PGL . allocateFloatBuffer ( lineDirections ) ; lineIndicesBuffer = PGL . allocateShortBuffer ( lineIndices ) ; pointVerticesBuffer = PGL . allocateFloatBuffer ( pointVertices ) ; pointColorsBuffer = PGL . allocateIntBuffer ( pointColors ) ; pointOffsetsBuffer = PGL . allocateFloatBuffer ( pointOffsets ) ; pointIndicesBuffer = PGL . allocateShortBuffer ( pointIndices ) ; clear ( ) ; } void initAttrib ( VertexAttribute attrib ) { if ( attrib . type == PGL . FLOAT && ! fpolyAttribs . containsKey ( attrib . name ) ) { float [ ] temp = new float [ attrib . tessSize * PGL . DEFAULT_TESS_VERTICES ] ; fpolyAttribs . put ( attrib . name , temp ) ; polyAttribBuffers . put ( attrib . name , PGL . allocateFloatBuffer ( temp ) ) ; } else if ( attrib . type == PGL . INT && ! ipolyAttribs . containsKey ( attrib . name ) ) { int [ ] temp = new int [ attrib . tessSize * PGL . DEFAULT_TESS_VERTICES ] ; ipolyAttribs . put ( attrib . name , temp ) ; polyAttribBuffers . put ( attrib . name , PGL . allocateIntBuffer ( temp ) ) ; } else if ( attrib . type == PGL . BOOL && ! bpolyAttribs . containsKey ( attrib . name ) ) { byte [ ] temp = new byte [ attrib . tessSize * PGL . DEFAULT_TESS_VERTICES ] ; bpolyAttribs . put ( attrib . name , temp ) ; polyAttribBuffers . put ( attrib . name , PGL . allocateByteBuffer ( temp ) ) ; } } void clear ( ) { firstPolyVertex = lastPolyVertex = polyVertexCount = 0 ; firstPolyIndex = lastPolyIndex = polyIndexCount = 0 ; firstLineVertex = lastLineVertex = lineVertexCount = 0 ; firstLineIndex = lastLineIndex = lineIndexCount = 0 ; firstPointVertex = lastPointVertex = pointVertexCount = 0 ; firstPointIndex = lastPointIndex = pointIndexCount = 0 ; polyIndexCache . clear ( ) ; lineIndexCache . clear ( ) ; pointIndexCache . clear ( ) ; } void polyVertexCheck ( ) { if ( polyVertexCount == polyVertices . length / 4 ) { int newSize = polyVertexCount < < 1 ; expandPolyVertices ( newSize ) ; expandPolyColors ( newSize ) ; expandPolyNormals ( newSize ) ; expandPolyTexCoords ( newSize ) ; expandPolyAmbient ( newSize ) ; expandPolySpecular ( newSize ) ; expandPolyEmissive ( newSize ) ; expandPolyShininess ( newSize ) ; expandAttributes ( newSize ) ; } firstPolyVertex = polyVertexCount ; polyVertexCount ++ ; lastPolyVertex = polyVertexCount - 1 ; } void polyVertexCheck ( int count ) { int oldSize = polyVertices . length / 4 ; if ( polyVertexCount + count > oldSize ) { int newSize = expandArraySize ( oldSize , polyVertexCount + count ) ; expandPolyVertices ( newSize ) ; expandPolyColors ( newSize ) ; expandPolyNormals ( newSize ) ; expandPolyTexCoords ( newSize ) ; expandPolyAmbient ( newSize ) ; expandPolySpecular ( newSize ) ; expandPolyEmissive ( newSize ) ; expandPolyShininess ( newSize ) ; expandAttributes ( newSize ) ; } firstPolyVertex = polyVertexCount ; polyVertexCount += count ; lastPolyVertex = polyVertexCount - 1 ; } void polyIndexCheck ( int count ) { int oldSize = polyIndices . length ; if ( polyIndexCount + count > oldSize ) { int newSize = expandArraySize ( oldSize , polyIndexCount + count ) ; expandPolyIndices ( newSize ) ; } firstPolyIndex = polyIndexCount ; polyIndexCount += count ; lastPolyIndex = polyIndexCount - 1 ; } void polyIndexCheck ( ) { if ( polyIndexCount == polyIndices . length ) { int newSize = polyIndexCount < < 1 ; expandPolyIndices ( newSize ) ; } firstPolyIndex = polyIndexCount ; polyIndexCount ++ ; lastPolyIndex = polyIndexCount - 1 ; } void lineVertexCheck ( int count ) { int oldSize = lineVertices . length / 4 ; if ( lineVertexCount + count > oldSize ) { int newSize = expandArraySize ( oldSize , lineVertexCount + count ) ; expandLineVertices ( newSize ) ; expandLineColors ( newSize ) ; expandLineDirections ( newSize ) ; } firstLineVertex = lineVertexCount ; lineVertexCount += count ; lastLineVertex = lineVertexCount - 1 ; } void lineIndexCheck ( int count ) { int oldSize = lineIndices . length ; if ( lineIndexCount + count > oldSize ) { int newSize = expandArraySize ( oldSize , lineIndexCount + count ) ; expandLineIndices ( newSize ) ; } firstLineIndex = lineIndexCount ; lineIndexCount += count ; lastLineIndex = lineIndexCount - 1 ; } void pointVertexCheck ( int count ) { int oldSize = pointVertices . length / 4 ; if ( pointVertexCount + count > oldSize ) { int newSize = expandArraySize ( oldSize , pointVertexCount + count ) ; expandPointVertices ( newSize ) ; expandPointColors ( newSize ) ; expandPointOffsets ( newSize ) ; } firstPointVertex = pointVertexCount ; pointVertexCount += count ; lastPointVertex = pointVertexCount - 1 ; } void pointIndexCheck ( int count ) { int oldSize = pointIndices . length ; if ( pointIndexCount + count > oldSize ) { int newSize = expandArraySize ( oldSize , pointIndexCount + count ) ; expandPointIndices ( newSize ) ; } firstPointIndex = pointIndexCount ; pointIndexCount += count ; lastPointIndex = pointIndexCount - 1 ; } boolean isFull ( ) { return PGL . FLUSH_VERTEX_COUNT <= polyVertexCount || PGL . FLUSH_VERTEX_COUNT <= lineVertexCount || PGL . FLUSH_VERTEX_COUNT <= pointVertexCount ; } void getPolyVertexMin ( PVector v , int first , int last ) { for ( int i = first ; i <= last ; i ++ ) { int index = 4 * i ; v . x = PApplet . min ( v . x , polyVertices [ index ++ ] ) ; v . y = PApplet . min ( v . y , polyVertices [ index ++ ] ) ; v . z = PApplet . min ( v . z , polyVertices [ index ] ) ; } } void getLineVertexMin ( PVector v , int first , int last ) { for ( int i = first ; i <= last ; i ++ ) { int index = 4 * i ; v . x = PApplet . min ( v . x , lineVertices [ index ++ ] ) ; v . y = PApplet . min ( v . y , lineVertices [ index ++ ] ) ; v . z = PApplet . min ( v . z , lineVertices [ index ] ) ; } } void getPointVertexMin ( PVector v , int first , int last ) { for ( int i = first ; i <= last ; i ++ ) { int index = 4 * i ; v . x = PApplet . min ( v . x , pointVertices [ index ++ ] ) ; v . y = PApplet . min ( v . y , pointVertices [ index ++ ] ) ; v . z = PApplet . min ( v . z , pointVertices [ index ] ) ; } } void getPolyVertexMax ( PVector v , int first , int last ) { for ( int i = first ; i <= last ; i ++ ) { int index = 4 * i ; v . x = PApplet . max ( v . x , polyVertices [ index ++ ] ) ; v . y = PApplet . max ( v . y , polyVertices [ index ++ ] ) ; v . z = PApplet . max ( v . z , polyVertices [ index ] ) ; } } void getLineVertexMax ( PVector v , int first , int last ) { for ( int i = first ; i <= last ; i ++ ) { int index = 4 * i ; v . x = PApplet . max ( v . x , lineVertices [ index ++ ] ) ; v . y = PApplet . max ( v . y , lineVertices [ index ++ ] ) ; v . z = PApplet . max ( v . z , lineVertices [ index ] ) ; } } void getPointVertexMax ( PVector v , int first , int last ) { for ( int i = first ; i <= last ; i ++ ) { int index = 4 * i ; v . x = PApplet . max ( v . x , pointVertices [ index ++ ] ) ; v . y = PApplet . max ( v . y , pointVertices [ index ++ ] ) ; v . z = PApplet . max ( v . z , pointVertices [ index ] ) ; } } int getPolyVertexSum ( PVector v , int first , int last ) { for ( int i = first ; i <= last ; i ++ ) { int index = 4 * i ; v . x += polyVertices [ index ++ ] ; v . y += polyVertices [ index ++ ] ; v . z += polyVertices [ index ] ; } return last - first + 1 ; } int getLineVertexSum ( PVector v , int first , int last ) { for ( int i = first ; i <= last ; i ++ ) { int index = 4 * i ; v . x += lineVertices [ index ++ ] ; v . y += lineVertices [ index ++ ] ; v . z += lineVertices [ index ] ; } return last - first + 1 ; } int getPointVertexSum ( PVector v , int first , int last ) { for ( int i = first ; i <= last ; i ++ ) { int index = 4 * i ; v . x += pointVertices [ index ++ ] ; v . y += pointVertices [ index ++ ] ; v . z += pointVertices [ index ] ; } return last - first + 1 ; } protected void updatePolyVerticesBuffer ( ) { updatePolyVerticesBuffer ( 0 , polyVertexCount ) ; } protected void updatePolyVerticesBuffer ( int offset , int size ) { PGL . updateFloatBuffer ( polyVerticesBuffer , polyVertices , 4 * offset , 4 * size ) ; } protected void updatePolyColorsBuffer ( ) { updatePolyColorsBuffer ( 0 , polyVertexCount ) ; } protected void updatePolyColorsBuffer ( int offset , int size ) { PGL . updateIntBuffer ( polyColorsBuffer , polyColors , offset , size ) ; } protected void updatePolyNormalsBuffer ( ) { updatePolyNormalsBuffer ( 0 , polyVertexCount ) ; } protected void updatePolyNormalsBuffer ( int offset , int size ) { PGL . updateFloatBuffer ( polyNormalsBuffer , polyNormals , 3 * offset , 3 * size ) ; } protected void updatePolyTexCoordsBuffer ( ) { updatePolyTexCoordsBuffer ( 0 , polyVertexCount ) ; } protected void updatePolyTexCoordsBuffer ( int offset , int size ) { PGL . updateFloatBuffer ( polyTexCoordsBuffer , polyTexCoords , 2 * offset , 2 * size ) ; } protected void updatePolyAmbientBuffer ( ) { updatePolyAmbientBuffer ( 0 , polyVertexCount ) ; } protected void updatePolyAmbientBuffer ( int offset , int size ) { PGL . updateIntBuffer ( polyAmbientBuffer , polyAmbient , offset , size ) ; } protected void updatePolySpecularBuffer ( ) { updatePolySpecularBuffer ( 0 , polyVertexCount ) ; } protected void updatePolySpecularBuffer ( int offset , int size ) { PGL . updateIntBuffer ( polySpecularBuffer , polySpecular , offset , size ) ; } protected void updatePolyEmissiveBuffer ( ) { updatePolyEmissiveBuffer ( 0 , polyVertexCount ) ; } protected void updatePolyEmissiveBuffer ( int offset , int size ) { PGL . updateIntBuffer ( polyEmissiveBuffer , polyEmissive , offset , size ) ; } protected void updatePolyShininessBuffer ( ) { updatePolyShininessBuffer ( 0 , polyVertexCount ) ; } protected void updatePolyShininessBuffer ( int offset , int size ) { PGL . updateFloatBuffer ( polyShininessBuffer , polyShininess , offset , size ) ; } protected void updateAttribBuffer ( String name ) { updateAttribBuffer ( name , 0 , polyVertexCount ) ; } protected void updateAttribBuffer ( String name , int offset , int size ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( attrib . type == PGL . FLOAT ) { FloatBuffer buffer = ( FloatBuffer ) polyAttribBuffers . get ( name ) ; float [ ] array = fpolyAttribs . get ( name ) ; PGL . updateFloatBuffer ( buffer , array , attrib . tessSize * offset , attrib . tessSize * size ) ; } else if ( attrib . type == PGL . INT ) { IntBuffer buffer = ( IntBuffer ) polyAttribBuffers . get ( name ) ; int [ ] array = ipolyAttribs . get ( name ) ; PGL . updateIntBuffer ( buffer , array , attrib . tessSize * offset , attrib . tessSize * size ) ; } else if ( attrib . type == PGL . BOOL ) { ByteBuffer buffer = ( ByteBuffer ) polyAttribBuffers . get ( name ) ; byte [ ] array = bpolyAttribs . get ( name ) ; PGL . updateByteBuffer ( buffer , array , attrib . tessSize * offset , attrib . tessSize * size ) ; } } protected void updatePolyIndicesBuffer ( ) { updatePolyIndicesBuffer ( 0 , polyIndexCount ) ; } protected void updatePolyIndicesBuffer ( int offset , int size ) { PGL . updateShortBuffer ( polyIndicesBuffer , polyIndices , offset , size ) ; } protected void updateLineVerticesBuffer ( ) { updateLineVerticesBuffer ( 0 , lineVertexCount ) ; } protected void updateLineVerticesBuffer ( int offset , int size ) { PGL . updateFloatBuffer ( lineVerticesBuffer , lineVertices , 4 * offset , 4 * size ) ; } protected void updateLineColorsBuffer ( ) { updateLineColorsBuffer ( 0 , lineVertexCount ) ; } protected void updateLineColorsBuffer ( int offset , int size ) { PGL . updateIntBuffer ( lineColorsBuffer , lineColors , offset , size ) ; } protected void updateLineDirectionsBuffer ( ) { updateLineDirectionsBuffer ( 0 , lineVertexCount ) ; } protected void updateLineDirectionsBuffer ( int offset , int size ) { PGL . updateFloatBuffer ( lineDirectionsBuffer , lineDirections , 4 * offset , 4 * size ) ; } protected void updateLineIndicesBuffer ( ) { updateLineIndicesBuffer ( 0 , lineIndexCount ) ; } protected void updateLineIndicesBuffer ( int offset , int size ) { PGL . updateShortBuffer ( lineIndicesBuffer , lineIndices , offset , size ) ; } protected void updatePointVerticesBuffer ( ) { updatePointVerticesBuffer ( 0 , pointVertexCount ) ; } protected void updatePointVerticesBuffer ( int offset , int size ) { PGL . updateFloatBuffer ( pointVerticesBuffer , pointVertices , 4 * offset , 4 * size ) ; } protected void updatePointColorsBuffer ( ) { updatePointColorsBuffer ( 0 , pointVertexCount ) ; } protected void updatePointColorsBuffer ( int offset , int size ) { PGL . updateIntBuffer ( pointColorsBuffer , pointColors , offset , size ) ; } protected void updatePointOffsetsBuffer ( ) { updatePointOffsetsBuffer ( 0 , pointVertexCount ) ; } protected void updatePointOffsetsBuffer ( int offset , int size ) { PGL . updateFloatBuffer ( pointOffsetsBuffer , pointOffsets , 2 * offset , 2 * size ) ; } protected void updatePointIndicesBuffer ( ) { updatePointIndicesBuffer ( 0 , pointIndexCount ) ; } protected void updatePointIndicesBuffer ( int offset , int size ) { PGL . updateShortBuffer ( pointIndicesBuffer , pointIndices , offset , size ) ; } void expandPolyVertices ( int n ) { float temp [ ] = new float [ 4 * n ] ; PApplet . arrayCopy ( polyVertices , 0 , temp , 0 , 4 * polyVertexCount ) ; polyVertices = temp ; polyVerticesBuffer = PGL . allocateFloatBuffer ( polyVertices ) ; } void expandPolyColors ( int n ) { int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( polyColors , 0 , temp , 0 , polyVertexCount ) ; polyColors = temp ; polyColorsBuffer = PGL . allocateIntBuffer ( polyColors ) ; } void expandPolyNormals ( int n ) { float temp [ ] = new float [ 3 * n ] ; PApplet . arrayCopy ( polyNormals , 0 , temp , 0 , 3 * polyVertexCount ) ; polyNormals = temp ; polyNormalsBuffer = PGL . allocateFloatBuffer ( polyNormals ) ; } void expandPolyTexCoords ( int n ) { float temp [ ] = new float [ 2 * n ] ; PApplet . arrayCopy ( polyTexCoords , 0 , temp , 0 , 2 * polyVertexCount ) ; polyTexCoords = temp ; polyTexCoordsBuffer = PGL . allocateFloatBuffer ( polyTexCoords ) ; } void expandPolyAmbient ( int n ) { int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( polyAmbient , 0 , temp , 0 , polyVertexCount ) ; polyAmbient = temp ; polyAmbientBuffer = PGL . allocateIntBuffer ( polyAmbient ) ; } void expandPolySpecular ( int n ) { int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( polySpecular , 0 , temp , 0 , polyVertexCount ) ; polySpecular = temp ; polySpecularBuffer = PGL . allocateIntBuffer ( polySpecular ) ; } void expandPolyEmissive ( int n ) { int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( polyEmissive , 0 , temp , 0 , polyVertexCount ) ; polyEmissive = temp ; polyEmissiveBuffer = PGL . allocateIntBuffer ( polyEmissive ) ; } void expandPolyShininess ( int n ) { float temp [ ] = new float [ n ] ; PApplet . arrayCopy ( polyShininess , 0 , temp , 0 , polyVertexCount ) ; polyShininess = temp ; polyShininessBuffer = PGL . allocateFloatBuffer ( polyShininess ) ; } void expandAttributes ( int n ) { for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( attrib . type == PGL . FLOAT ) { expandFloatAttribute ( attrib , n ) ; } else if ( attrib . type == PGL . INT ) { expandIntAttribute ( attrib , n ) ; } else if ( attrib . type == PGL . BOOL ) { expandBoolAttribute ( attrib , n ) ; } } } void expandFloatAttribute ( VertexAttribute attrib , int n ) { float [ ] array = fpolyAttribs . get ( attrib . name ) ; float temp [ ] = new float [ attrib . tessSize * n ] ; PApplet . arrayCopy ( array , 0 , temp , 0 , attrib . tessSize * polyVertexCount ) ; fpolyAttribs . put ( attrib . name , temp ) ; polyAttribBuffers . put ( attrib . name , PGL . allocateFloatBuffer ( temp ) ) ; } void expandIntAttribute ( VertexAttribute attrib , int n ) { int [ ] array = ipolyAttribs . get ( attrib . name ) ; int temp [ ] = new int [ attrib . tessSize * n ] ; PApplet . arrayCopy ( array , 0 , temp , 0 , attrib . tessSize * polyVertexCount ) ; ipolyAttribs . put ( attrib . name , temp ) ; polyAttribBuffers . put ( attrib . name , PGL . allocateIntBuffer ( temp ) ) ; } void expandBoolAttribute ( VertexAttribute attrib , int n ) { byte [ ] array = bpolyAttribs . get ( attrib . name ) ; byte temp [ ] = new byte [ attrib . tessSize * n ] ; PApplet . arrayCopy ( array , 0 , temp , 0 , attrib . tessSize * polyVertexCount ) ; bpolyAttribs . put ( attrib . name , temp ) ; polyAttribBuffers . put ( attrib . name , PGL . allocateByteBuffer ( temp ) ) ; } void expandPolyIndices ( int n ) { short temp [ ] = new short [ n ] ; PApplet . arrayCopy ( polyIndices , 0 , temp , 0 , polyIndexCount ) ; polyIndices = temp ; polyIndicesBuffer = PGL . allocateShortBuffer ( polyIndices ) ; } void expandLineVertices ( int n ) { float temp [ ] = new float [ 4 * n ] ; PApplet . arrayCopy ( lineVertices , 0 , temp , 0 , 4 * lineVertexCount ) ; lineVertices = temp ; lineVerticesBuffer = PGL . allocateFloatBuffer ( lineVertices ) ; } void expandLineColors ( int n ) { int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( lineColors , 0 , temp , 0 , lineVertexCount ) ; lineColors = temp ; lineColorsBuffer = PGL . allocateIntBuffer ( lineColors ) ; } void expandLineDirections ( int n ) { float temp [ ] = new float [ 4 * n ] ; PApplet . arrayCopy ( lineDirections , 0 , temp , 0 , 4 * lineVertexCount ) ; lineDirections = temp ; lineDirectionsBuffer = PGL . allocateFloatBuffer ( lineDirections ) ; } void expandLineIndices ( int n ) { short temp [ ] = new short [ n ] ; PApplet . arrayCopy ( lineIndices , 0 , temp , 0 , lineIndexCount ) ; lineIndices = temp ; lineIndicesBuffer = PGL . allocateShortBuffer ( lineIndices ) ; } void expandPointVertices ( int n ) { float temp [ ] = new float [ 4 * n ] ; PApplet . arrayCopy ( pointVertices , 0 , temp , 0 , 4 * pointVertexCount ) ; pointVertices = temp ; pointVerticesBuffer = PGL . allocateFloatBuffer ( pointVertices ) ; } void expandPointColors ( int n ) { int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( pointColors , 0 , temp , 0 , pointVertexCount ) ; pointColors = temp ; pointColorsBuffer = PGL . allocateIntBuffer ( pointColors ) ; } void expandPointOffsets ( int n ) { float temp [ ] = new float [ 2 * n ] ; PApplet . arrayCopy ( pointOffsets , 0 , temp , 0 , 2 * pointVertexCount ) ; pointOffsets = temp ; pointOffsetsBuffer = PGL . allocateFloatBuffer ( pointOffsets ) ; } void expandPointIndices ( int n ) { short temp [ ] = new short [ n ] ; PApplet . arrayCopy ( pointIndices , 0 , temp , 0 , pointIndexCount ) ; pointIndices = temp ; pointIndicesBuffer = PGL . allocateShortBuffer ( pointIndices ) ; } void trim ( ) { if ( 0 < polyVertexCount && polyVertexCount < polyVertices . length / 4 ) { trimPolyVertices ( ) ; trimPolyColors ( ) ; trimPolyNormals ( ) ; trimPolyTexCoords ( ) ; trimPolyAmbient ( ) ; trimPolySpecular ( ) ; trimPolyEmissive ( ) ; trimPolyShininess ( ) ; trimAttributes ( ) ; } if ( 0 < polyIndexCount && polyIndexCount < polyIndices . length ) { trimPolyIndices ( ) ; } if ( 0 < lineVertexCount && lineVertexCount < lineVertices . length / 4 ) { trimLineVertices ( ) ; trimLineColors ( ) ; trimLineDirections ( ) ; } if ( 0 < lineIndexCount && lineIndexCount < lineIndices . length ) { trimLineIndices ( ) ; } if ( 0 < pointVertexCount && pointVertexCount < pointVertices . length / 4 ) { trimPointVertices ( ) ; trimPointColors ( ) ; trimPointOffsets ( ) ; } if ( 0 < pointIndexCount && pointIndexCount < pointIndices . length ) { trimPointIndices ( ) ; } } void trimPolyVertices ( ) { float temp [ ] = new float [ 4 * polyVertexCount ] ; PApplet . arrayCopy ( polyVertices , 0 , temp , 0 , 4 * polyVertexCount ) ; polyVertices = temp ; polyVerticesBuffer = PGL . allocateFloatBuffer ( polyVertices ) ; } void trimPolyColors ( ) { int temp [ ] = new int [ polyVertexCount ] ; PApplet . arrayCopy ( polyColors , 0 , temp , 0 , polyVertexCount ) ; polyColors = temp ; polyColorsBuffer = PGL . allocateIntBuffer ( polyColors ) ; } void trimPolyNormals ( ) { float temp [ ] = new float [ 3 * polyVertexCount ] ; PApplet . arrayCopy ( polyNormals , 0 , temp , 0 , 3 * polyVertexCount ) ; polyNormals = temp ; polyNormalsBuffer = PGL . allocateFloatBuffer ( polyNormals ) ; } void trimPolyTexCoords ( ) { float temp [ ] = new float [ 2 * polyVertexCount ] ; PApplet . arrayCopy ( polyTexCoords , 0 , temp , 0 , 2 * polyVertexCount ) ; polyTexCoords = temp ; polyTexCoordsBuffer = PGL . allocateFloatBuffer ( polyTexCoords ) ; } void trimPolyAmbient ( ) { int temp [ ] = new int [ polyVertexCount ] ; PApplet . arrayCopy ( polyAmbient , 0 , temp , 0 , polyVertexCount ) ; polyAmbient = temp ; polyAmbientBuffer = PGL . allocateIntBuffer ( polyAmbient ) ; } void trimPolySpecular ( ) { int temp [ ] = new int [ polyVertexCount ] ; PApplet . arrayCopy ( polySpecular , 0 , temp , 0 , polyVertexCount ) ; polySpecular = temp ; polySpecularBuffer = PGL . allocateIntBuffer ( polySpecular ) ; } void trimPolyEmissive ( ) { int temp [ ] = new int [ polyVertexCount ] ; PApplet . arrayCopy ( polyEmissive , 0 , temp , 0 , polyVertexCount ) ; polyEmissive = temp ; polyEmissiveBuffer = PGL . allocateIntBuffer ( polyEmissive ) ; } void trimPolyShininess ( ) { float temp [ ] = new float [ polyVertexCount ] ; PApplet . arrayCopy ( polyShininess , 0 , temp , 0 , polyVertexCount ) ; polyShininess = temp ; polyShininessBuffer = PGL . allocateFloatBuffer ( polyShininess ) ; } void trimAttributes ( ) { for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( attrib . type == PGL . FLOAT ) { trimFloatAttribute ( attrib ) ; } else if ( attrib . type == PGL . INT ) { trimIntAttribute ( attrib ) ; } else if ( attrib . type == PGL . BOOL ) { trimBoolAttribute ( attrib ) ; } } } void trimFloatAttribute ( VertexAttribute attrib ) { float [ ] array = fpolyAttribs . get ( attrib . name ) ; float temp [ ] = new float [ attrib . tessSize * polyVertexCount ] ; PApplet . arrayCopy ( array , 0 , temp , 0 , attrib . tessSize * polyVertexCount ) ; fpolyAttribs . put ( attrib . name , temp ) ; polyAttribBuffers . put ( attrib . name , PGL . allocateFloatBuffer ( temp ) ) ; } void trimIntAttribute ( VertexAttribute attrib ) { int [ ] array = ipolyAttribs . get ( attrib . name ) ; int temp [ ] = new int [ attrib . tessSize * polyVertexCount ] ; PApplet . arrayCopy ( array , 0 , temp , 0 , attrib . tessSize * polyVertexCount ) ; ipolyAttribs . put ( attrib . name , temp ) ; polyAttribBuffers . put ( attrib . name , PGL . allocateIntBuffer ( temp ) ) ; } void trimBoolAttribute ( VertexAttribute attrib ) { byte [ ] array = bpolyAttribs . get ( attrib . name ) ; byte temp [ ] = new byte [ attrib . tessSize * polyVertexCount ] ; PApplet . arrayCopy ( array , 0 , temp , 0 , attrib . tessSize * polyVertexCount ) ; bpolyAttribs . put ( attrib . name , temp ) ; polyAttribBuffers . put ( attrib . name , PGL . allocateByteBuffer ( temp ) ) ; } void trimPolyIndices ( ) { short temp [ ] = new short [ polyIndexCount ] ; PApplet . arrayCopy ( polyIndices , 0 , temp , 0 , polyIndexCount ) ; polyIndices = temp ; polyIndicesBuffer = PGL . allocateShortBuffer ( polyIndices ) ; } void trimLineVertices ( ) { float temp [ ] = new float [ 4 * lineVertexCount ] ; PApplet . arrayCopy ( lineVertices , 0 , temp , 0 , 4 * lineVertexCount ) ; lineVertices = temp ; lineVerticesBuffer = PGL . allocateFloatBuffer ( lineVertices ) ; } void trimLineColors ( ) { int temp [ ] = new int [ lineVertexCount ] ; PApplet . arrayCopy ( lineColors , 0 , temp , 0 , lineVertexCount ) ; lineColors = temp ; lineColorsBuffer = PGL . allocateIntBuffer ( lineColors ) ; } void trimLineDirections ( ) { float temp [ ] = new float [ 4 * lineVertexCount ] ; PApplet . arrayCopy ( lineDirections , 0 , temp , 0 , 4 * lineVertexCount ) ; lineDirections = temp ; lineDirectionsBuffer = PGL . allocateFloatBuffer ( lineDirections ) ; } void trimLineIndices ( ) { short temp [ ] = new short [ lineIndexCount ] ; PApplet . arrayCopy ( lineIndices , 0 , temp , 0 , lineIndexCount ) ; lineIndices = temp ; lineIndicesBuffer = PGL . allocateShortBuffer ( lineIndices ) ; } void trimPointVertices ( ) { float temp [ ] = new float [ 4 * pointVertexCount ] ; PApplet . arrayCopy ( pointVertices , 0 , temp , 0 , 4 * pointVertexCount ) ; pointVertices = temp ; pointVerticesBuffer = PGL . allocateFloatBuffer ( pointVertices ) ; } void trimPointColors ( ) { int temp [ ] = new int [ pointVertexCount ] ; PApplet . arrayCopy ( pointColors , 0 , temp , 0 , pointVertexCount ) ; pointColors = temp ; pointColorsBuffer = PGL . allocateIntBuffer ( pointColors ) ; } void trimPointOffsets ( ) { float temp [ ] = new float [ 2 * pointVertexCount ] ; PApplet . arrayCopy ( pointOffsets , 0 , temp , 0 , 2 * pointVertexCount ) ; pointOffsets = temp ; pointOffsetsBuffer = PGL . allocateFloatBuffer ( pointOffsets ) ; } void trimPointIndices ( ) { short temp [ ] = new short [ pointIndexCount ] ; PApplet . arrayCopy ( pointIndices , 0 , temp , 0 , pointIndexCount ) ; pointIndices = temp ; pointIndicesBuffer = PGL . allocateShortBuffer ( pointIndices ) ; } void incPolyIndices ( int first , int last , int inc ) { for ( int i = first ; i <= last ; i ++ ) { polyIndices [ i ] += inc ; } } void incLineIndices ( int first , int last , int inc ) { for ( int i = first ; i <= last ; i ++ ) { lineIndices [ i ] += inc ; } } void incPointIndices ( int first , int last , int inc ) { for ( int i = first ; i <= last ; i ++ ) { pointIndices [ i ] += inc ; } } void calcPolyNormal ( int i0 , int i1 , int i2 ) { int index ; index = 4 * i0 ; float x0 = polyVertices [ index ++ ] ; float y0 = polyVertices [ index ++ ] ; float z0 = polyVertices [ index ] ; index = 4 * i1 ; float x1 = polyVertices [ index ++ ] ; float y1 = polyVertices [ index ++ ] ; float z1 = polyVertices [ index ] ; index = 4 * i2 ; float x2 = polyVertices [ index ++ ] ; float y2 = polyVertices [ index ++ ] ; float z2 = polyVertices [ index ] ; float v12x = x2 - x1 ; float v12y = y2 - y1 ; float v12z = z2 - z1 ; float v10x = x0 - x1 ; float v10y = y0 - y1 ; float v10z = z0 - z1 ; float nx = v12y * v10z - v10y * v12z ; float ny = v12z * v10x - v10z * v12x ; float nz = v12x * v10y - v10x * v12y ; float d = PApplet . sqrt ( nx * nx + ny * ny + nz * nz ) ; nx /= d ; ny /= d ; nz /= d ; index = 3 * i0 ; polyNormals [ index ++ ] = nx ; polyNormals [ index ++ ] = ny ; polyNormals [ index ] = nz ; index = 3 * i1 ; polyNormals [ index ++ ] = nx ; polyNormals [ index ++ ] = ny ; polyNormals [ index ] = nz ; index = 3 * i2 ; polyNormals [ index ++ ] = nx ; polyNormals [ index ++ ] = ny ; polyNormals [ index ] = nz ; } void setPointVertex ( int tessIdx , InGeometry in , int inIdx ) { int index ; index = 3 * inIdx ; float x = in . vertices [ index ++ ] ; float y = in . vertices [ index ++ ] ; float z = in . vertices [ index ] ; if ( renderMode == IMMEDIATE && pg . flushMode == FLUSH_WHEN_FULL ) { PMatrix3D mm = pg . modelview ; index = 4 * tessIdx ; pointVertices [ index ++ ] = x * mm . m00 + y * mm . m01 + z * mm . m02 + mm . m03 ; pointVertices [ index ++ ] = x * mm . m10 + y * mm . m11 + z * mm . m12 + mm . m13 ; pointVertices [ index ++ ] = x * mm . m20 + y * mm . m21 + z * mm . m22 + mm . m23 ; pointVertices [ index ] = x * mm . m30 + y * mm . m31 + z * mm . m32 + mm . m33 ; } else { index = 4 * tessIdx ; pointVertices [ index ++ ] = x ; pointVertices [ index ++ ] = y ; pointVertices [ index ++ ] = z ; pointVertices [ index ] = 1 ; } pointColors [ tessIdx ] = in . strokeColors [ inIdx ] ; } void setLineVertex ( int tessIdx , float [ ] vertices , int inIdx0 , int rgba ) { int index ; index = 3 * inIdx0 ; float x0 = vertices [ index ++ ] ; float y0 = vertices [ index ++ ] ; float z0 = vertices [ index ] ; if ( renderMode == IMMEDIATE && pg . flushMode == FLUSH_WHEN_FULL ) { PMatrix3D mm = pg . modelview ; index = 4 * tessIdx ; lineVertices [ index ++ ] = x0 * mm . m00 + y0 * mm . m01 + z0 * mm . m02 + mm . m03 ; lineVertices [ index ++ ] = x0 * mm . m10 + y0 * mm . m11 + z0 * mm . m12 + mm . m13 ; lineVertices [ index ++ ] = x0 * mm . m20 + y0 * mm . m21 + z0 * mm . m22 + mm . m23 ; lineVertices [ index ] = x0 * mm . m30 + y0 * mm . m31 + z0 * mm . m32 + mm . m33 ; } else { index = 4 * tessIdx ; lineVertices [ index ++ ] = x0 ; lineVertices [ index ++ ] = y0 ; lineVertices [ index ++ ] = z0 ; lineVertices [ index ] = 1 ; } lineColors [ tessIdx ] = rgba ; index = 4 * tessIdx ; lineDirections [ index ++ ] = 0 ; lineDirections [ index ++ ] = 0 ; lineDirections [ index ++ ] = 0 ; lineDirections [ index ] = 0 ; } void setLineVertex ( int tessIdx , float [ ] vertices , int inIdx0 , int inIdx1 , int rgba , float weight ) { int index ; index = 3 * inIdx0 ; float x0 = vertices [ index ++ ] ; float y0 = vertices [ index ++ ] ; float z0 = vertices [ index ] ; index = 3 * inIdx1 ; float x1 = vertices [ index ++ ] ; float y1 = vertices [ index ++ ] ; float z1 = vertices [ index ] ; float dx = x1 - x0 ; float dy = y1 - y0 ; float dz = z1 - z0 ; if ( renderMode == IMMEDIATE && pg . flushMode == FLUSH_WHEN_FULL ) { PMatrix3D mm = pg . modelview ; index = 4 * tessIdx ; lineVertices [ index ++ ] = x0 * mm . m00 + y0 * mm . m01 + z0 * mm . m02 + mm . m03 ; lineVertices [ index ++ ] = x0 * mm . m10 + y0 * mm . m11 + z0 * mm . m12 + mm . m13 ; lineVertices [ index ++ ] = x0 * mm . m20 + y0 * mm . m21 + z0 * mm . m22 + mm . m23 ; lineVertices [ index ] = x0 * mm . m30 + y0 * mm . m31 + z0 * mm . m32 + mm . m33 ; index = 4 * tessIdx ; lineDirections [ index ++ ] = dx * mm . m00 + dy * mm . m01 + dz * mm . m02 ; lineDirections [ index ++ ] = dx * mm . m10 + dy * mm . m11 + dz * mm . m12 ; lineDirections [ index ] = dx * mm . m20 + dy * mm . m21 + dz * mm . m22 ; } else { index = 4 * tessIdx ; lineVertices [ index ++ ] = x0 ; lineVertices [ index ++ ] = y0 ; lineVertices [ index ++ ] = z0 ; lineVertices [ index ] = 1 ; index = 4 * tessIdx ; lineDirections [ index ++ ] = dx ; lineDirections [ index ++ ] = dy ; lineDirections [ index ] = dz ; } lineColors [ tessIdx ] = rgba ; lineDirections [ 4 * tessIdx + 3 ] = weight ; } void addPolyVertex ( double [ ] d , boolean clampXY ) { int fcolor = ( int ) d [ 3 ] < < 24 | ( int ) d [ 4 ] < < 16 | ( int ) d [ 5 ] < < 8 | ( int ) d [ 6 ] ; int acolor = ( int ) d [ 12 ] < < 24 | ( int ) d [ 13 ] < < 16 | ( int ) d [ 14 ] < < 8 | ( int ) d [ 15 ] ; int scolor = ( int ) d [ 16 ] < < 24 | ( int ) d [ 17 ] < < 16 | ( int ) d [ 18 ] < < 8 | ( int ) d [ 19 ] ; int ecolor = ( int ) d [ 20 ] < < 24 | ( int ) d [ 21 ] < < 16 | ( int ) d [ 22 ] < < 8 | ( int ) d [ 23 ] ; addPolyVertex ( ( float ) d [ 0 ] , ( float ) d [ 1 ] , ( float ) d [ 2 ] , fcolor , ( float ) d [ 7 ] , ( float ) d [ 8 ] , ( float ) d [ 9 ] , ( float ) d [ 10 ] , ( float ) d [ 11 ] , acolor , scolor , ecolor , ( float ) d [ 24 ] , clampXY ) ; if ( 25 < d . length ) { PMatrix3D mm = pg . modelview ; PMatrix3D nm = pg . modelviewInv ; int tessIdx = polyVertexCount - 1 ; int index ; int pos = 25 ; for ( int i = 0 ; i < polyAttribs . size ( ) ; i ++ ) { VertexAttribute attrib = polyAttribs . get ( i ) ; String name = attrib . name ; index = attrib . tessSize * tessIdx ; if ( attrib . isColor ( ) ) { int color = ( int ) d [ pos + 0 ] < < 24 | ( int ) d [ pos + 1 ] < < 16 | ( int ) d [ pos + 2 ] < < 8 | ( int ) d [ pos + 3 ] ; int [ ] tessValues = ipolyAttribs . get ( name ) ; tessValues [ index ] = color ; pos += 4 ; } else if ( attrib . isPosition ( ) ) { float [ ] farray = fpolyAttribs . get ( name ) ; float x = ( float ) d [ pos ++ ] ; float y = ( float ) d [ pos ++ ] ; float z = ( float ) d [ pos ++ ] ; if ( renderMode == IMMEDIATE && pg . flushMode == FLUSH_WHEN_FULL ) { if ( clampXY ) { farray [ index ++ ] = PApplet . ceil ( x * mm . m00 + y * mm . m01 + z * mm . m02 + mm . m03 ) ; farray [ index ++ ] = PApplet . ceil ( x * mm . m10 + y * mm . m11 + z * mm . m12 + mm . m13 ) ; } else { farray [ index ++ ] = x * mm . m00 + y * mm . m01 + z * mm . m02 + mm . m03 ; farray [ index ++ ] = x * mm . m10 + y * mm . m11 + z * mm . m12 + mm . m13 ; } farray [ index ++ ] = x * mm . m20 + y * mm . m21 + z * mm . m22 + mm . m23 ; farray [ index ] = x * mm . m30 + y * mm . m31 + z * mm . m32 + mm . m33 ; } else { farray [ index ++ ] = x ; farray [ index ++ ] = y ; farray [ index ++ ] = z ; farray [ index ] = 1 ; } } else if ( attrib . isNormal ( ) ) { float [ ] farray = fpolyAttribs . get ( name ) ; float x = ( float ) d [ pos + 0 ] ; float y = ( float ) d [ pos + 1 ] ; float z = ( float ) d [ pos + 2 ] ; if ( renderMode == IMMEDIATE && pg . flushMode == FLUSH_WHEN_FULL ) { farray [ index ++ ] = x * nm . m00 + y * nm . m10 + z * nm . m20 ; farray [ index ++ ] = x * nm . m01 + y * nm . m11 + z * nm . m21 ; farray [ index ] = x * nm . m02 + y * nm . m12 + z * nm . m22 ; } else { farray [ index ++ ] = x ; farray [ index ++ ] = y ; farray [ index ] = z ; } pos += 3 ; } else { if ( attrib . isFloat ( ) ) { float [ ] farray = fpolyAttribs . get ( name ) ; for ( int n = 0 ; n < attrib . size ; n ++ ) { farray [ index ++ ] = ( float ) d [ pos ++ ] ; } } else if ( attrib . isInt ( ) ) { int [ ] iarray = ipolyAttribs . get ( name ) ; for ( int n = 0 ; n < attrib . size ; n ++ ) { iarray [ index ++ ] = ( int ) d [ pos ++ ] ; } } else if ( attrib . isBool ( ) ) { byte [ ] barray = bpolyAttribs . get ( name ) ; for ( int n = 0 ; n < attrib . size ; n ++ ) { barray [ index ++ ] = ( byte ) d [ pos ++ ] ; } } pos += attrib . size ; } } } } void addPolyVertex ( float x , float y , float z , int rgba , float nx , float ny , float nz , float u , float v , int am , int sp , int em , float shine , boolean clampXY ) { polyVertexCheck ( ) ; int tessIdx = polyVertexCount - 1 ; setPolyVertex ( tessIdx , x , y , z , rgba , nx , ny , nz , u , v , am , sp , em , shine , clampXY ) ; } void setPolyVertex ( int tessIdx , float x , float y , float z , int rgba , boolean clampXY ) { setPolyVertex ( tessIdx , x , y , z , rgba , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , clampXY ) ; } void setPolyVertex ( int tessIdx , float x , float y , float z , int rgba , float nx , float ny , float nz , float u , float v , int am , int sp , int em , float shine , boolean clampXY ) { int index ; if ( renderMode == IMMEDIATE && pg . flushMode == FLUSH_WHEN_FULL ) { PMatrix3D mm = pg . modelview ; PMatrix3D nm = pg . modelviewInv ; index = 4 * tessIdx ; if ( clampXY ) { polyVertices [ index ++ ] = PApplet . ceil ( x * mm . m00 + y * mm . m01 + z * mm . m02 + mm . m03 ) ; polyVertices [ index ++ ] = PApplet . ceil ( x * mm . m10 + y * mm . m11 + z * mm . m12 + mm . m13 ) ; } else { polyVertices [ index ++ ] = x * mm . m00 + y * mm . m01 + z * mm . m02 + mm . m03 ; polyVertices [ index ++ ] = x * mm . m10 + y * mm . m11 + z * mm . m12 + mm . m13 ; } polyVertices [ index ++ ] = x * mm . m20 + y * mm . m21 + z * mm . m22 + mm . m23 ; polyVertices [ index ] = x * mm . m30 + y * mm . m31 + z * mm . m32 + mm . m33 ; index = 3 * tessIdx ; polyNormals [ index ++ ] = nx * nm . m00 + ny * nm . m10 + nz * nm . m20 ; polyNormals [ index ++ ] = nx * nm . m01 + ny * nm . m11 + nz * nm . m21 ; polyNormals [ index ] = nx * nm . m02 + ny * nm . m12 + nz * nm . m22 ; } else { index = 4 * tessIdx ; polyVertices [ index ++ ] = x ; polyVertices [ index ++ ] = y ; polyVertices [ index ++ ] = z ; polyVertices [ index ] = 1 ; index = 3 * tessIdx ; polyNormals [ index ++ ] = nx ; polyNormals [ index ++ ] = ny ; polyNormals [ index ] = nz ; } polyColors [ tessIdx ] = rgba ; index = 2 * tessIdx ; polyTexCoords [ index ++ ] = u ; polyTexCoords [ index ] = v ; polyAmbient [ tessIdx ] = am ; polySpecular [ tessIdx ] = sp ; polyEmissive [ tessIdx ] = em ; polyShininess [ tessIdx ] = shine ; } void addPolyVertices ( InGeometry in , boolean clampXY ) { addPolyVertices ( in , 0 , in . vertexCount - 1 , clampXY ) ; } void addPolyVertex ( InGeometry in , int i , boolean clampXY ) { addPolyVertices ( in , i , i , clampXY ) ; } void addPolyVertices ( InGeometry in , int i0 , int i1 , boolean clampXY ) { int index ; int nvert = i1 - i0 + 1 ; polyVertexCheck ( nvert ) ; if ( renderMode == IMMEDIATE && pg . flushMode == FLUSH_WHEN_FULL ) { PMatrix3D mm = pg . modelview ; PMatrix3D nm = pg . modelviewInv ; for ( int i = 0 ; i < nvert ; i ++ ) { int inIdx = i0 + i ; int tessIdx = firstPolyVertex + i ; index = 3 * inIdx ; float x = in . vertices [ index ++ ] ; float y = in . vertices [ index ++ ] ; float z = in . vertices [ index ] ; index = 3 * inIdx ; float nx = in . normals [ index ++ ] ; float ny = in . normals [ index ++ ] ; float nz = in . normals [ index ] ; index = 4 * tessIdx ; if ( clampXY ) { polyVertices [ index ++ ] = PApplet . ceil ( x * mm . m00 + y * mm . m01 + z * mm . m02 + mm . m03 ) ; polyVertices [ index ++ ] = PApplet . ceil ( x * mm . m10 + y * mm . m11 + z * mm . m12 + mm . m13 ) ; } else { polyVertices [ index ++ ] = x * mm . m00 + y * mm . m01 + z * mm . m02 + mm . m03 ; polyVertices [ index ++ ] = x * mm . m10 + y * mm . m11 + z * mm . m12 + mm . m13 ; } polyVertices [ index ++ ] = x * mm . m20 + y * mm . m21 + z * mm . m22 + mm . m23 ; polyVertices [ index ] = x * mm . m30 + y * mm . m31 + z * mm . m32 + mm . m33 ; index = 3 * tessIdx ; polyNormals [ index ++ ] = nx * nm . m00 + ny * nm . m10 + nz * nm . m20 ; polyNormals [ index ++ ] = nx * nm . m01 + ny * nm . m11 + nz * nm . m21 ; polyNormals [ index ] = nx * nm . m02 + ny * nm . m12 + nz * nm . m22 ; for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( attrib . isColor ( ) || attrib . isOther ( ) ) continue ; float [ ] inValues = in . fattribs . get ( name ) ; index = 3 * inIdx ; x = inValues [ index ++ ] ; y = inValues [ index ++ ] ; z = inValues [ index ] ; float [ ] tessValues = fpolyAttribs . get ( name ) ; if ( attrib . isPosition ( ) ) { index = 4 * tessIdx ; if ( clampXY ) { tessValues [ index ++ ] = PApplet . ceil ( x * mm . m00 + y * mm . m01 + z * mm . m02 + mm . m03 ) ; tessValues [ index ++ ] = PApplet . ceil ( x * mm . m10 + y * mm . m11 + z * mm . m12 + mm . m13 ) ; } else { tessValues [ index ++ ] = x * mm . m00 + y * mm . m01 + z * mm . m02 + mm . m03 ; tessValues [ index ++ ] = x * mm . m10 + y * mm . m11 + z * mm . m12 + mm . m13 ; } tessValues [ index ++ ] = x * mm . m20 + y * mm . m21 + z * mm . m22 + mm . m23 ; tessValues [ index ] = x * mm . m30 + y * mm . m31 + z * mm . m32 + mm . m33 ; } else { index = 3 * tessIdx ; tessValues [ index ++ ] = x * nm . m00 + y * nm . m10 + z * nm . m20 ; tessValues [ index ++ ] = x * nm . m01 + y * nm . m11 + z * nm . m21 ; tessValues [ index ] = x * nm . m02 + y * nm . m12 + z * nm . m22 ; } } } } else { if ( nvert <= PGL . MIN_ARRAYCOPY_SIZE ) { for ( int i = 0 ; i < nvert ; i ++ ) { int inIdx = i0 + i ; int tessIdx = firstPolyVertex + i ; index = 3 * inIdx ; float x = in . vertices [ index ++ ] ; float y = in . vertices [ index ++ ] ; float z = in . vertices [ index ] ; index = 3 * inIdx ; float nx = in . normals [ index ++ ] ; float ny = in . normals [ index ++ ] ; float nz = in . normals [ index ] ; index = 4 * tessIdx ; polyVertices [ index ++ ] = x ; polyVertices [ index ++ ] = y ; polyVertices [ index ++ ] = z ; polyVertices [ index ] = 1 ; index = 3 * tessIdx ; polyNormals [ index ++ ] = nx ; polyNormals [ index ++ ] = ny ; polyNormals [ index ] = nz ; for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( attrib . isColor ( ) || attrib . isOther ( ) ) continue ; float [ ] inValues = in . fattribs . get ( name ) ; index = 3 * inIdx ; x = inValues [ index ++ ] ; y = inValues [ index ++ ] ; z = inValues [ index ] ; float [ ] tessValues = fpolyAttribs . get ( name ) ; if ( attrib . isPosition ( ) ) { index = 4 * tessIdx ; tessValues [ index ++ ] = x ; tessValues [ index ++ ] = y ; tessValues [ index ++ ] = z ; tessValues [ index ] = 1 ; } else { index = 3 * tessIdx ; tessValues [ index ++ ] = x ; tessValues [ index ++ ] = y ; tessValues [ index ] = z ; } } } } else { for ( int i = 0 ; i < nvert ; i ++ ) { int inIdx = i0 + i ; int tessIdx = firstPolyVertex + i ; PApplet . arrayCopy ( in . vertices , 3 * inIdx , polyVertices , 4 * tessIdx , 3 ) ; polyVertices [ 4 * tessIdx + 3 ] = 1 ; for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( ! attrib . isPosition ( ) ) continue ; float [ ] inValues = in . fattribs . get ( name ) ; float [ ] tessValues = fpolyAttribs . get ( name ) ; PApplet . arrayCopy ( inValues , 3 * inIdx , tessValues , 4 * tessIdx , 3 ) ; tessValues [ 4 * tessIdx + 3 ] = 1 ; } } PApplet . arrayCopy ( in . normals , 3 * i0 , polyNormals , 3 * firstPolyVertex , 3 * nvert ) ; for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( ! attrib . isPosition ( ) ) continue ; float [ ] inValues = in . fattribs . get ( name ) ; float [ ] tessValues = fpolyAttribs . get ( name ) ; PApplet . arrayCopy ( inValues , 3 * i0 , tessValues , 3 * firstPolyVertex , 3 * nvert ) ; } } } if ( nvert <= PGL . MIN_ARRAYCOPY_SIZE ) { for ( int i = 0 ; i < nvert ; i ++ ) { int inIdx = i0 + i ; int tessIdx = firstPolyVertex + i ; index = 2 * inIdx ; float u = in . texcoords [ index ++ ] ; float v = in . texcoords [ index ] ; polyColors [ tessIdx ] = in . colors [ inIdx ] ; index = 2 * tessIdx ; polyTexCoords [ index ++ ] = u ; polyTexCoords [ index ] = v ; polyAmbient [ tessIdx ] = in . ambient [ inIdx ] ; polySpecular [ tessIdx ] = in . specular [ inIdx ] ; polyEmissive [ tessIdx ] = in . emissive [ inIdx ] ; polyShininess [ tessIdx ] = in . shininess [ inIdx ] ; for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( attrib . isPosition ( ) || attrib . isNormal ( ) ) continue ; int index0 = attrib . size * inIdx ; int index1 = attrib . size * tessIdx ; if ( attrib . isFloat ( ) ) { float [ ] inValues = in . fattribs . get ( name ) ; float [ ] tessValues = fpolyAttribs . get ( name ) ; for ( int n = 0 ; n < attrib . size ; n ++ ) { tessValues [ index1 ++ ] = inValues [ index0 ++ ] ; } } else if ( attrib . isInt ( ) ) { int [ ] inValues = in . iattribs . get ( name ) ; int [ ] tessValues = ipolyAttribs . get ( name ) ; for ( int n = 0 ; n < attrib . size ; n ++ ) { tessValues [ index1 ++ ] = inValues [ index0 ++ ] ; } } else if ( attrib . isBool ( ) ) { byte [ ] inValues = in . battribs . get ( name ) ; byte [ ] tessValues = bpolyAttribs . get ( name ) ; for ( int n = 0 ; n < attrib . size ; n ++ ) { tessValues [ index1 ++ ] = inValues [ index0 ++ ] ; } } } } } else { PApplet . arrayCopy ( in . colors , i0 , polyColors , firstPolyVertex , nvert ) ; PApplet . arrayCopy ( in . texcoords , 2 * i0 , polyTexCoords , 2 * firstPolyVertex , 2 * nvert ) ; PApplet . arrayCopy ( in . ambient , i0 , polyAmbient , firstPolyVertex , nvert ) ; PApplet . arrayCopy ( in . specular , i0 , polySpecular , firstPolyVertex , nvert ) ; PApplet . arrayCopy ( in . emissive , i0 , polyEmissive , firstPolyVertex , nvert ) ; PApplet . arrayCopy ( in . shininess , i0 , polyShininess , firstPolyVertex , nvert ) ; for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( attrib . isPosition ( ) || attrib . isNormal ( ) ) continue ; Object inValues = null ; Object tessValues = null ; if ( attrib . isFloat ( ) ) { inValues = in . fattribs . get ( name ) ; tessValues = fpolyAttribs . get ( name ) ; } else if ( attrib . isInt ( ) ) { inValues = in . iattribs . get ( name ) ; tessValues = ipolyAttribs . get ( name ) ; } else if ( attrib . isBool ( ) ) { inValues = in . battribs . get ( name ) ; tessValues = bpolyAttribs . get ( name ) ; } PApplet . arrayCopy ( inValues , attrib . size * i0 , tessValues , attrib . tessSize * firstPolyVertex , attrib . size * nvert ) ; } } } void applyMatrixOnPolyGeometry ( PMatrix tr , int first , int last ) { if ( tr instanceof PMatrix2D ) { applyMatrixOnPolyGeometry ( ( PMatrix2D ) tr , first , last ) ; } else if ( tr instanceof PMatrix3D ) { applyMatrixOnPolyGeometry ( ( PMatrix3D ) tr , first , last ) ; } } void applyMatrixOnLineGeometry ( PMatrix tr , int first , int last ) { if ( tr instanceof PMatrix2D ) { applyMatrixOnLineGeometry ( ( PMatrix2D ) tr , first , last ) ; } else if ( tr instanceof PMatrix3D ) { applyMatrixOnLineGeometry ( ( PMatrix3D ) tr , first , last ) ; } } void applyMatrixOnPointGeometry ( PMatrix tr , int first , int last ) { if ( tr instanceof PMatrix2D ) { applyMatrixOnPointGeometry ( ( PMatrix2D ) tr , first , last ) ; } else if ( tr instanceof PMatrix3D ) { applyMatrixOnPointGeometry ( ( PMatrix3D ) tr , first , last ) ; } } void applyMatrixOnPolyGeometry ( PMatrix2D tr , int first , int last ) { if ( first < last ) { int index ; for ( int i = first ; i <= last ; i ++ ) { index = 4 * i ; float x = polyVertices [ index ++ ] ; float y = polyVertices [ index ] ; index = 3 * i ; float nx = polyNormals [ index ++ ] ; float ny = polyNormals [ index ] ; index = 4 * i ; polyVertices [ index ++ ] = x * tr . m00 + y * tr . m01 + tr . m02 ; polyVertices [ index ] = x * tr . m10 + y * tr . m11 + tr . m12 ; index = 3 * i ; polyNormals [ index ++ ] = nx * tr . m00 + ny * tr . m01 ; polyNormals [ index ] = nx * tr . m10 + ny * tr . m11 ; for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( attrib . isColor ( ) || attrib . isOther ( ) ) continue ; float [ ] values = fpolyAttribs . get ( name ) ; if ( attrib . isPosition ( ) ) { index = 4 * i ; x = values [ index ++ ] ; y = values [ index ] ; index = 4 * i ; values [ index ++ ] = x * tr . m00 + y * tr . m01 + tr . m02 ; values [ index ] = x * tr . m10 + y * tr . m11 + tr . m12 ; } else { index = 3 * i ; nx = values [ index ++ ] ; ny = values [ index ] ; index = 3 * i ; values [ index ++ ] = nx * tr . m00 + ny * tr . m01 ; values [ index ] = nx * tr . m10 + ny * tr . m11 ; } } } } } void applyMatrixOnLineGeometry ( PMatrix2D tr , int first , int last ) { if ( first < last ) { int index ; for ( int i = first ; i <= last ; i ++ ) { index = 4 * i ; float x = lineVertices [ index ++ ] ; float y = lineVertices [ index ] ; index = 4 * i ; float xa = lineDirections [ index ++ ] ; float ya = lineDirections [ index ] ; float dx = xa - x ; float dy = ya - y ; index = 4 * i ; lineVertices [ index ++ ] = x * tr . m00 + y * tr . m01 + tr . m02 ; lineVertices [ index ] = x * tr . m10 + y * tr . m11 + tr . m12 ; index = 4 * i ; lineDirections [ index ++ ] = dx * tr . m00 + dy * tr . m01 ; lineDirections [ index ] = dx * tr . m10 + dy * tr . m11 ; } } } void applyMatrixOnPointGeometry ( PMatrix2D tr , int first , int last ) { if ( first < last ) { int index ; for ( int i = first ; i <= last ; i ++ ) { index = 4 * i ; float x = pointVertices [ index ++ ] ; float y = pointVertices [ index ] ; index = 4 * i ; pointVertices [ index ++ ] = x * tr . m00 + y * tr . m01 + tr . m02 ; pointVertices [ index ] = x * tr . m10 + y * tr . m11 + tr . m12 ; } } } void applyMatrixOnPolyGeometry ( PMatrix3D tr , int first , int last ) { if ( first < last ) { int index ; for ( int i = first ; i <= last ; i ++ ) { index = 4 * i ; float x = polyVertices [ index ++ ] ; float y = polyVertices [ index ++ ] ; float z = polyVertices [ index ++ ] ; float w = polyVertices [ index ] ; index = 3 * i ; float nx = polyNormals [ index ++ ] ; float ny = polyNormals [ index ++ ] ; float nz = polyNormals [ index ] ; index = 4 * i ; polyVertices [ index ++ ] = x * tr . m00 + y * tr . m01 + z * tr . m02 + w * tr . m03 ; polyVertices [ index ++ ] = x * tr . m10 + y * tr . m11 + z * tr . m12 + w * tr . m13 ; polyVertices [ index ++ ] = x * tr . m20 + y * tr . m21 + z * tr . m22 + w * tr . m23 ; polyVertices [ index ] = x * tr . m30 + y * tr . m31 + z * tr . m32 + w * tr . m33 ; index = 3 * i ; polyNormals [ index ++ ] = nx * tr . m00 + ny * tr . m01 + nz * tr . m02 ; polyNormals [ index ++ ] = nx * tr . m10 + ny * tr . m11 + nz * tr . m12 ; polyNormals [ index ] = nx * tr . m20 + ny * tr . m21 + nz * tr . m22 ; for ( String name : polyAttribs . keySet ( ) ) { VertexAttribute attrib = polyAttribs . get ( name ) ; if ( attrib . isColor ( ) || attrib . isOther ( ) ) continue ; float [ ] values = fpolyAttribs . get ( name ) ; if ( attrib . isPosition ( ) ) { index = 4 * i ; x = values [ index ++ ] ; y = values [ index ++ ] ; z = values [ index ++ ] ; w = values [ index ] ; index = 4 * i ; values [ index ++ ] = x * tr . m00 + y * tr . m01 + z * tr . m02 + w * tr . m03 ; values [ index ++ ] = x * tr . m10 + y * tr . m11 + z * tr . m12 + w * tr . m13 ; values [ index ++ ] = x * tr . m20 + y * tr . m21 + z * tr . m22 + w * tr . m23 ; values [ index ] = x * tr . m30 + y * tr . m31 + z * tr . m32 + w * tr . m33 ; } else { index = 3 * i ; nx = values [ index ++ ] ; ny = values [ index ++ ] ; nz = values [ index ] ; index = 3 * i ; values [ index ++ ] = nx * tr . m00 + ny * tr . m01 + nz * tr . m02 ; values [ index ++ ] = nx * tr . m10 + ny * tr . m11 + nz * tr . m12 ; values [ index ] = nx * tr . m20 + ny * tr . m21 + nz * tr . m22 ; } } } } } void applyMatrixOnLineGeometry ( PMatrix3D tr , int first , int last ) { if ( first < last ) { int index ; for ( int i = first ; i <= last ; i ++ ) { index = 4 * i ; float x = lineVertices [ index ++ ] ; float y = lineVertices [ index ++ ] ; float z = lineVertices [ index ++ ] ; float w = lineVertices [ index ] ; index = 4 * i ; float xa = lineDirections [ index ++ ] ; float ya = lineDirections [ index ++ ] ; float za = lineDirections [ index ] ; float dx = xa - x ; float dy = ya - y ; float dz = za - z ; index = 4 * i ; lineVertices [ index ++ ] = x * tr . m00 + y * tr . m01 + z * tr . m02 + w * tr . m03 ; lineVertices [ index ++ ] = x * tr . m10 + y * tr . m11 + z * tr . m12 + w * tr . m13 ; lineVertices [ index ++ ] = x * tr . m20 + y * tr . m21 + z * tr . m22 + w * tr . m23 ; lineVertices [ index ] = x * tr . m30 + y * tr . m31 + z * tr . m32 + w * tr . m33 ; index = 4 * i ; lineDirections [ index ++ ] = dx * tr . m00 + dy * tr . m01 + dz * tr . m02 ; lineDirections [ index ++ ] = dx * tr . m10 + dy * tr . m11 + dz * tr . m12 ; lineDirections [ index ] = dx * tr . m20 + dy * tr . m21 + dz * tr . m22 ; } } } void applyMatrixOnPointGeometry ( PMatrix3D tr , int first , int last ) { if ( first < last ) { int index ; for ( int i = first ; i <= last ; i ++ ) { index = 4 * i ; float x = pointVertices [ index ++ ] ; float y = pointVertices [ index ++ ] ; float z = pointVertices [ index ++ ] ; float w = pointVertices [ index ] ; index = 4 * i ; pointVertices [ index ++ ] = x * tr . m00 + y * tr . m01 + z * tr . m02 + w * tr . m03 ; pointVertices [ index ++ ] = x * tr . m10 + y * tr . m11 + z * tr . m12 + w * tr . m13 ; pointVertices [ index ++ ] = x * tr . m20 + y * tr . m21 + z * tr . m22 + w * tr . m23 ; pointVertices [ index ] = x * tr . m30 + y * tr . m31 + z * tr . m32 + w * tr . m33 ; } } } } static protected class Tessellator { InGeometry in ; TessGeometry tess ; TexCache texCache ; PImage prevTexImage ; PImage newTexImage ; int firstTexIndex ; int firstTexCache ; PGL . Tessellator gluTess ; TessellatorCallback callback ; boolean fill ; boolean stroke ; int strokeColor ; float strokeWeight ; int strokeJoin ; int strokeCap ; boolean accurate2DStrokes ; PMatrix transform ; float transformScale ; boolean is2D , is3D ; protected PGraphicsOpenGL pg ; int [ ] rawIndices ; int rawSize ; int [ ] dupIndices ; int dupCount ; int firstPolyIndexCache ; int lastPolyIndexCache ; int firstLineIndexCache ; int lastLineIndexCache ; int firstPointIndexCache ; int lastPointIndexCache ; float [ ] strokeVertices ; int [ ] strokeColors ; float [ ] strokeWeights ; int pathVertexCount ; float [ ] pathVertices ; int [ ] pathColors ; float [ ] pathWeights ; int beginPath ; public Tessellator ( ) { rawIndices = new int [ 512 ] ; accurate2DStrokes = true ; transform = null ; is2D = false ; is3D = true ; } void initGluTess ( ) { if ( gluTess == null ) { callback = new TessellatorCallback ( tess . polyAttribs ) ; gluTess = pg . pgl . createTessellator ( callback ) ; } } void setInGeometry ( InGeometry in ) { this . in = in ; firstPolyIndexCache = - 1 ; lastPolyIndexCache = - 1 ; firstLineIndexCache = - 1 ; lastLineIndexCache = - 1 ; firstPointIndexCache = - 1 ; lastPointIndexCache = - 1 ; } void setTessGeometry ( TessGeometry tess ) { this . tess = tess ; } void setFill ( boolean fill ) { this . fill = fill ; } void setTexCache ( TexCache texCache , PImage newTexImage ) { this . texCache = texCache ; this . newTexImage = newTexImage ; } void setStroke ( boolean stroke ) { this . stroke = stroke ; } void setStrokeColor ( int color ) { this . strokeColor = PGL . javaToNativeARGB ( color ) ; } void setStrokeWeight ( float weight ) { this . strokeWeight = weight ; } void setStrokeCap ( int strokeCap ) { this . strokeCap = strokeCap ; } void setStrokeJoin ( int strokeJoin ) { this . strokeJoin = strokeJoin ; } void setAccurate2DStrokes ( boolean accurate ) { this . accurate2DStrokes = accurate ; } protected void setRenderer ( PGraphicsOpenGL pg ) { this . pg = pg ; } void set3D ( boolean value ) { if ( value ) { this . is2D = false ; this . is3D = true ; } else { this . is2D = true ; this . is3D = false ; } } void setTransform ( PMatrix transform ) { this . transform = transform ; transformScale = - 1 ; } void resetCurveVertexCount ( ) { pg . curveVertexCount = 0 ; } void tessellatePoints ( ) { if ( strokeCap == ROUND ) { tessellateRoundPoints ( ) ; } else { tessellateSquarePoints ( ) ; } } void tessellateRoundPoints ( ) { int nInVert = in . vertexCount ; if ( stroke && 1 <= nInVert ) { int nPtVert = PApplet . min ( MAX_POINT_ACCURACY , PApplet . max ( MIN_POINT_ACCURACY , ( int ) ( TWO_PI * strokeWeight / POINT_ACCURACY_FACTOR ) ) ) + 1 ; if ( PGL . MAX_VERTEX_INDEX1 <= nPtVert ) { throw new RuntimeException ( "Error in point tessellation." ) ; } updateTex ( ) ; int nvertTot = nPtVert * nInVert ; int nindTot = 3 * ( nPtVert - 1 ) * nInVert ; if ( is3D ) { tessellateRoundPoints3D ( nvertTot , nindTot , nPtVert ) ; } else if ( is2D ) { beginNoTex ( ) ; tessellateRoundPoints2D ( nvertTot , nindTot , nPtVert ) ; endNoTex ( ) ; } } } void tessellateRoundPoints3D ( int nvertTot , int nindTot , int nPtVert ) { int perim = nPtVert - 1 ; tess . pointVertexCheck ( nvertTot ) ; tess . pointIndexCheck ( nindTot ) ; int vertIdx = tess . firstPointVertex ; int attribIdx = tess . firstPointVertex ; int indIdx = tess . firstPointIndex ; IndexCache cache = tess . pointIndexCache ; int index = in . renderMode == RETAINED ? cache . addNew ( ) : cache . getLast ( ) ; firstPointIndexCache = index ; for ( int i = 0 ; i < in . vertexCount ; i ++ ) { int count = cache . vertexCount [ index ] ; if ( PGL . MAX_VERTEX_INDEX1 <= count + nPtVert ) { index = cache . addNew ( ) ; count = 0 ; } for ( int k = 0 ; k < nPtVert ; k ++ ) { tess . setPointVertex ( vertIdx , in , i ) ; vertIdx ++ ; } tess . pointOffsets [ 2 * attribIdx + 0 ] = 0 ; tess . pointOffsets [ 2 * attribIdx + 1 ] = 0 ; attribIdx ++ ; float val = 0 ; float inc = ( float ) SINCOS_LENGTH / perim ; for ( int k = 0 ; k < perim ; k ++ ) { tess . pointOffsets [ 2 * attribIdx + 0 ] = 0.5f * cosLUT [ ( int ) val ] * strokeWeight ; tess . pointOffsets [ 2 * attribIdx + 1 ] = 0.5f * sinLUT [ ( int ) val ] * strokeWeight ; val = ( val + inc ) % SINCOS_LENGTH ; attribIdx ++ ; } for ( int k = 1 ; k < nPtVert - 1 ; k ++ ) { tess . pointIndices [ indIdx ++ ] = ( short ) ( count + 0 ) ; tess . pointIndices [ indIdx ++ ] = ( short ) ( count + k ) ; tess . pointIndices [ indIdx ++ ] = ( short ) ( count + k + 1 ) ; } tess . pointIndices [ indIdx ++ ] = ( short ) ( count + 0 ) ; tess . pointIndices [ indIdx ++ ] = ( short ) ( count + 1 ) ; tess . pointIndices [ indIdx ++ ] = ( short ) ( count + nPtVert - 1 ) ; cache . incCounts ( index , 3 * ( nPtVert - 1 ) , nPtVert ) ; } lastPointIndexCache = index ; } void tessellateRoundPoints2D ( int nvertTot , int nindTot , int nPtVert ) { int perim = nPtVert - 1 ; tess . polyVertexCheck ( nvertTot ) ; tess . polyIndexCheck ( nindTot ) ; int vertIdx = tess . firstPolyVertex ; int indIdx = tess . firstPolyIndex ; IndexCache cache = tess . polyIndexCache ; int index = in . renderMode == RETAINED ? cache . addNew ( ) : cache . getLast ( ) ; firstPointIndexCache = index ; if ( firstPolyIndexCache == - 1 ) firstPolyIndexCache = index ; for ( int i = 0 ; i < in . vertexCount ; i ++ ) { int count = cache . vertexCount [ index ] ; if ( PGL . MAX_VERTEX_INDEX1 <= count + nPtVert ) { index = cache . addNew ( ) ; count = 0 ; } float x0 = in . vertices [ 3 * i + 0 ] ; float y0 = in . vertices [ 3 * i + 1 ] ; int rgba = in . strokeColors [ i ] ; float val = 0 ; float inc = ( float ) SINCOS_LENGTH / perim ; tess . setPolyVertex ( vertIdx , x0 , y0 , 0 , rgba , false ) ; vertIdx ++ ; for ( int k = 0 ; k < perim ; k ++ ) { tess . setPolyVertex ( vertIdx , x0 + 0.5f * cosLUT [ ( int ) val ] * strokeWeight , y0 + 0.5f * sinLUT [ ( int ) val ] * strokeWeight , 0 , rgba , false ) ; vertIdx ++ ; val = ( val + inc ) % SINCOS_LENGTH ; } for ( int k = 1 ; k < nPtVert - 1 ; k ++ ) { tess . polyIndices [ indIdx ++ ] = ( short ) ( count + 0 ) ; tess . polyIndices [ indIdx ++ ] = ( short ) ( count + k ) ; tess . polyIndices [ indIdx ++ ] = ( short ) ( count + k + 1 ) ; } tess . polyIndices [ indIdx ++ ] = ( short ) ( count + 0 ) ; tess . polyIndices [ indIdx ++ ] = ( short ) ( count + 1 ) ; tess . polyIndices [ indIdx ++ ] = ( short ) ( count + nPtVert - 1 ) ; cache . incCounts ( index , 3 * ( nPtVert - 1 ) , nPtVert ) ; } lastPointIndexCache = lastPolyIndexCache = index ; } void tessellateSquarePoints ( ) { int nInVert = in . vertexCount ; if ( stroke && 1 <= nInVert ) { updateTex ( ) ; int quadCount = nInVert ; int nvertTot = 5 * quadCount ; int nindTot = 12 * quadCount ; if ( is3D ) { tessellateSquarePoints3D ( nvertTot , nindTot ) ; } else if ( is2D ) { beginNoTex ( ) ; tessellateSquarePoints2D ( nvertTot , nindTot ) ; endNoTex ( ) ; } } } void tessellateSquarePoints3D ( int nvertTot , int nindTot ) { tess . pointVertexCheck ( nvertTot ) ; tess . pointIndexCheck ( nindTot ) ; int vertIdx = tess . firstPointVertex ; int attribIdx = tess . firstPointVertex ; int indIdx = tess . firstPointIndex ; IndexCache cache = tess . pointIndexCache ; int index = in . renderMode == RETAINED ? cache . addNew ( ) : cache . getLast ( ) ; firstPointIndexCache = index ; for ( int i = 0 ; i < in . vertexCount ; i ++ ) { int nvert = 5 ; int count = cache . vertexCount [ index ] ; if ( PGL . MAX_VERTEX_INDEX1 <= count + nvert ) { index = cache . addNew ( ) ; count = 0 ; } for ( int k = 0 ; k < nvert ; k ++ ) { tess . setPointVertex ( vertIdx , in , i ) ; vertIdx ++ ; } tess . pointOffsets [ 2 * attribIdx + 0 ] = 0 ; tess . pointOffsets [ 2 * attribIdx + 1 ] = 0 ; attribIdx ++ ; for ( int k = 0 ; k < 4 ; k ++ ) { tess . pointOffsets [ 2 * attribIdx + 0 ] = 0.5f * QUAD_POINT_SIGNS [ k ] [ 0 ] * strokeWeight ; tess . pointOffsets [ 2 * attribIdx + 1 ] = 0.5f * QUAD_POINT_SIGNS [ k ] [ 1 ] * strokeWeight ; attribIdx ++ ; } for ( int k = 1 ; k < nvert - 1 ; k ++ ) { tess . pointIndices [ indIdx ++ ] = ( short ) ( count + 0 ) ; tess . pointIndices [ indIdx ++ ] = ( short ) ( count + k ) ; tess . pointIndices [ indIdx ++ ] = ( short ) ( count + k + 1 ) ; } tess . pointIndices [ indIdx ++ ] = ( short ) ( count + 0 ) ; tess . pointIndices [ indIdx ++ ] = ( short ) ( count + 1 ) ; tess . pointIndices [ indIdx ++ ] = ( short ) ( count + nvert - 1 ) ; cache . incCounts ( index , 12 , 5 ) ; } lastPointIndexCache = index ; } void tessellateSquarePoints2D ( int nvertTot , int nindTot ) { tess . polyVertexCheck ( nvertTot ) ; tess . polyIndexCheck ( nindTot ) ; boolean clamp = clampSquarePoints2D ( ) ; int vertIdx = tess . firstPolyVertex ; int indIdx = tess . firstPolyIndex ; IndexCache cache = tess . polyIndexCache ; int index = in . renderMode == RETAINED ? cache . addNew ( ) : cache . getLast ( ) ; firstPointIndexCache = index ; if ( firstPolyIndexCache == - 1 ) firstPolyIndexCache = index ; for ( int i = 0 ; i < in . vertexCount ; i ++ ) { int nvert = 5 ; int count = cache . vertexCount [ index ] ; if ( PGL . MAX_VERTEX_INDEX1 <= count + nvert ) { index = cache . addNew ( ) ; count = 0 ; } float x0 = in . vertices [ 3 * i + 0 ] ; float y0 = in . vertices [ 3 * i + 1 ] ; int rgba = in . strokeColors [ i ] ; tess . setPolyVertex ( vertIdx , x0 , y0 , 0 , rgba , clamp ) ; vertIdx ++ ; for ( int k = 0 ; k < nvert - 1 ; k ++ ) { tess . setPolyVertex ( vertIdx , x0 + 0.5f * QUAD_POINT_SIGNS [ k ] [ 0 ] * strokeWeight , y0 + 0.5f * QUAD_POINT_SIGNS [ k ] [ 1 ] * strokeWeight , 0 , rgba , clamp ) ; vertIdx ++ ; } for ( int k = 1 ; k < nvert - 1 ; k ++ ) { tess . polyIndices [ indIdx ++ ] = ( short ) ( count + 0 ) ; tess . polyIndices [ indIdx ++ ] = ( short ) ( count + k ) ; tess . polyIndices [ indIdx ++ ] = ( short ) ( count + k + 1 ) ; } tess . polyIndices [ indIdx ++ ] = ( short ) ( count + 0 ) ; tess . polyIndices [ indIdx ++ ] = ( short ) ( count + 1 ) ; tess . polyIndices [ indIdx ++ ] = ( short ) ( count + nvert - 1 ) ; cache . incCounts ( index , 12 , 5 ) ; } lastPointIndexCache = lastPolyIndexCache = index ; } boolean clamp2D ( ) { return is2D && tess . renderMode == IMMEDIATE && zero ( pg . modelview . m01 ) && zero ( pg . modelview . m10 ) ; } boolean clampSquarePoints2D ( ) { return clamp2D ( ) ; } void tessellateLines ( ) { int nInVert = in . vertexCount ; if ( stroke && 2 <= nInVert ) { strokeVertices = in . vertices ; strokeColors = in . strokeColors ; strokeWeights = in . strokeWeights ; updateTex ( ) ; int lineCount = nInVert / 2 ; if ( is3D ) { tessellateLines3D ( lineCount ) ; } else if ( is2D ) { beginNoTex ( ) ; tessellateLines2D ( lineCount ) ; endNoTex ( ) ; } } } void tessellateLines3D ( int lineCount ) { int nvert = lineCount * 4 ; int nind = lineCount * 2 * 3 ; tess . lineVertexCheck ( nvert ) ; tess . lineIndexCheck ( nind ) ; int index = in . renderMode == RETAINED ? tess . lineIndexCache . addNew ( ) : tess . lineIndexCache . getLast ( ) ; firstLineIndexCache = index ; for ( int ln = 0 ; ln < lineCount ; ln ++ ) { int i0 = 2 * ln + 0 ; int i1 = 2 * ln + 1 ; index = addLineSegment3D ( i0 , i1 , i0 - 2 , i1 - 1 , index , null , false ) ; } lastLineIndexCache = index ; } void tessellateLines2D ( int lineCount ) { int nvert = lineCount * 4 ; int nind = lineCount * 2 * 3 ; if ( noCapsJoins ( nvert ) ) { tess . polyVertexCheck ( nvert ) ; tess . polyIndexCheck ( nind ) ; int index = in . renderMode == RETAINED ? tess . polyIndexCache . addNew ( ) : tess . polyIndexCache . getLast ( ) ; firstLineIndexCache = index ; if ( firstPolyIndexCache == - 1 ) firstPolyIndexCache = index ; boolean clamp = clampLines2D ( lineCount ) ; for ( int ln = 0 ; ln < lineCount ; ln ++ ) { int i0 = 2 * ln + 0 ; int i1 = 2 * ln + 1 ; index = addLineSegment2D ( i0 , i1 , index , false , clamp ) ; } lastLineIndexCache = lastPolyIndexCache = index ; } else { LinePath path = new LinePath ( LinePath . WIND_NON_ZERO ) ; for ( int ln = 0 ; ln < lineCount ; ln ++ ) { int i0 = 2 * ln + 0 ; int i1 = 2 * ln + 1 ; path . moveTo ( in . vertices [ 3 * i0 + 0 ] , in . vertices [ 3 * i0 + 1 ] , in . strokeColors [ i0 ] ) ; path . lineTo ( in . vertices [ 3 * i1 + 0 ] , in . vertices [ 3 * i1 + 1 ] , in . strokeColors [ i1 ] ) ; } tessellateLinePath ( path ) ; } } boolean clampLines2D ( int lineCount ) { boolean res = clamp2D ( ) ; if ( res ) { for ( int ln = 0 ; ln < lineCount ; ln ++ ) { int i0 = 2 * ln + 0 ; int i1 = 2 * ln + 1 ; res = segmentIsAxisAligned ( i0 , i1 ) ; if ( ! res ) break ; } } return res ; } void tessellateLineStrip ( ) { int nInVert = in . vertexCount ; if ( stroke && 2 <= nInVert ) { strokeVertices = in . vertices ; strokeColors = in . strokeColors ; strokeWeights = in . strokeWeights ; updateTex ( ) ; int lineCount = nInVert - 1 ; if ( is3D ) { tessellateLineStrip3D ( lineCount ) ; } else if ( is2D ) { beginNoTex ( ) ; tessellateLineStrip2D ( lineCount ) ; endNoTex ( ) ; } } } void tessellateLineStrip3D ( int lineCount ) { int nBevelTr = noCapsJoins ( ) ? 0 : ( lineCount - 1 ) ; int nvert = lineCount * 4 + nBevelTr ; int nind = lineCount * 2 * 3 + nBevelTr * 2 * 3 ; tess . lineVertexCheck ( nvert ) ; tess . lineIndexCheck ( nind ) ; int index = in . renderMode == RETAINED ? tess . lineIndexCache . addNew ( ) : tess . lineIndexCache . getLast ( ) ; firstLineIndexCache = index ; int i0 = 0 ; short [ ] lastInd = { - 1 , - 1 } ; for ( int ln = 0 ; ln < lineCount ; ln ++ ) { int i1 = ln + 1 ; if ( 0 < nBevelTr ) { index = addLineSegment3D ( i0 , i1 , i1 - 2 , i1 - 1 , index , lastInd , false ) ; } else { index = addLineSegment3D ( i0 , i1 , i1 - 2 , i1 - 1 , index , null , false ) ; } i0 = i1 ; } lastLineIndexCache = index ; } void tessellateLineStrip2D ( int lineCount ) { int nvert = lineCount * 4 ; int nind = lineCount * 2 * 3 ; if ( noCapsJoins ( nvert ) ) { tess . polyVertexCheck ( nvert ) ; tess . polyIndexCheck ( nind ) ; int index = in . renderMode == RETAINED ? tess . polyIndexCache . addNew ( ) : tess . polyIndexCache . getLast ( ) ; firstLineIndexCache = index ; if ( firstPolyIndexCache == - 1 ) firstPolyIndexCache = index ; int i0 = 0 ; boolean clamp = clampLineStrip2D ( lineCount ) ; for ( int ln = 0 ; ln < lineCount ; ln ++ ) { int i1 = ln + 1 ; index = addLineSegment2D ( i0 , i1 , index , false , clamp ) ; i0 = i1 ; } lastLineIndexCache = lastPolyIndexCache = index ; } else { LinePath path = new LinePath ( LinePath . WIND_NON_ZERO ) ; path . moveTo ( in . vertices [ 0 ] , in . vertices [ 1 ] , in . strokeColors [ 0 ] ) ; for ( int ln = 0 ; ln < lineCount ; ln ++ ) { int i1 = ln + 1 ; path . lineTo ( in . vertices [ 3 * i1 + 0 ] , in . vertices [ 3 * i1 + 1 ] , in . strokeColors [ i1 ] ) ; } tessellateLinePath ( path ) ; } } boolean clampLineStrip2D ( int lineCount ) { boolean res = clamp2D ( ) ; if ( res ) { for ( int ln = 0 ; ln < lineCount ; ln ++ ) { res = segmentIsAxisAligned ( 0 , ln + 1 ) ; if ( ! res ) break ; } } return res ; } void tessellateLineLoop ( ) { int nInVert = in . vertexCount ; if ( stroke && 2 <= nInVert ) { strokeVertices = in . vertices ; strokeColors = in . strokeColors ; strokeWeights = in . strokeWeights ; updateTex ( ) ; int lineCount = nInVert ; if ( is3D ) { tessellateLineLoop3D ( lineCount ) ; } else if ( is2D ) { beginNoTex ( ) ; tessellateLineLoop2D ( lineCount ) ; endNoTex ( ) ; } } } void tessellateLineLoop3D ( int lineCount ) { int nBevelTr = noCapsJoins ( ) ? 0 : lineCount ; int nvert = lineCount * 4 + nBevelTr ; int nind = lineCount * 2 * 3 + nBevelTr * 2 * 3 ; tess . lineVertexCheck ( nvert ) ; tess . lineIndexCheck ( nind ) ; int index = in . renderMode == RETAINED ? tess . lineIndexCache . addNew ( ) : tess . lineIndexCache . getLast ( ) ; firstLineIndexCache = index ; int i0 = 0 ; int i1 = - 1 ; short [ ] lastInd = { - 1 , - 1 } ; short firstInd = - 1 ; for ( int ln = 0 ; ln < lineCount - 1 ; ln ++ ) { i1 = ln + 1 ; if ( 0 < nBevelTr ) { index = addLineSegment3D ( i0 , i1 , i1 - 2 , i1 - 1 , index , lastInd , false ) ; if ( ln == 0 ) firstInd = ( short ) ( lastInd [ 0 ] - 2 ) ; } else { index = addLineSegment3D ( i0 , i1 , i1 - 2 , i1 - 1 , index , null , false ) ; } i0 = i1 ; } index = addLineSegment3D ( 0 , in . vertexCount - 1 , i1 - 2 , i1 - 1 , index , lastInd , false ) ; if ( 0 < nBevelTr ) { index = addBevel3D ( 0 , 0 , in . vertexCount - 1 , index , lastInd , firstInd , false ) ; } lastLineIndexCache = index ; } void tessellateLineLoop2D ( int lineCount ) { int nvert = lineCount * 4 ; int nind = lineCount * 2 * 3 ; if ( noCapsJoins ( nvert ) ) { tess . polyVertexCheck ( nvert ) ; tess . polyIndexCheck ( nind ) ; int index = in . renderMode == RETAINED ? tess . polyIndexCache . addNew ( ) : tess . polyIndexCache . getLast ( ) ; firstLineIndexCache = index ; if ( firstPolyIndexCache == - 1 ) firstPolyIndexCache = index ; int i0 = 0 ; boolean clamp = clampLineLoop2D ( lineCount ) ; for ( int ln = 0 ; ln < lineCount - 1 ; ln ++ ) { int i1 = ln + 1 ; index = addLineSegment2D ( i0 , i1 , index , false , clamp ) ; i0 = i1 ; } index = addLineSegment2D ( 0 , in . vertexCount - 1 , index , false , clamp ) ; lastLineIndexCache = lastPolyIndexCache = index ; } else { LinePath path = new LinePath ( LinePath . WIND_NON_ZERO ) ; path . moveTo ( in . vertices [ 0 ] , in . vertices [ 1 ] , in . strokeColors [ 0 ] ) ; for ( int ln = 0 ; ln < lineCount - 1 ; ln ++ ) { int i1 = ln + 1 ; path . lineTo ( in . vertices [ 3 * i1 + 0 ] , in . vertices [ 3 * i1 + 1 ] , in . strokeColors [ i1 ] ) ; } path . closePath ( ) ; tessellateLinePath ( path ) ; } } boolean clampLineLoop2D ( int lineCount ) { boolean res = clamp2D ( ) ; if ( res ) { for ( int ln = 0 ; ln < lineCount ; ln ++ ) { res = segmentIsAxisAligned ( 0 , ln + 1 ) ; if ( ! res ) break ; } } return res ; } void tessellateEdges ( ) { if ( stroke ) { if ( in . edgeCount == 0 ) return ; strokeVertices = in . vertices ; strokeColors = in . strokeColors ; strokeWeights = in . strokeWeights ; if ( is3D ) { tessellateEdges3D ( ) ; } else if ( is2D ) { beginNoTex ( ) ; tessellateEdges2D ( ) ; endNoTex ( ) ; } } } void tessellateEdges3D ( ) { boolean bevel = ! noCapsJoins ( ) ; int nInVert = in . getNumEdgeVertices ( bevel ) ; int nInInd = in . getNumEdgeIndices ( bevel ) ; tess . lineVertexCheck ( nInVert ) ; tess . lineIndexCheck ( nInInd ) ; int index = in . renderMode == RETAINED ? tess . lineIndexCache . addNew ( ) : tess . lineIndexCache . getLast ( ) ; firstLineIndexCache = index ; short [ ] lastInd = { - 1 , - 1 } ; short firstInd = - 1 ; int pi0 = - 1 ; int pi1 = - 1 ; for ( int i = 0 ; i <= in . edgeCount - 1 ; i ++ ) { int [ ] edge = in . edges [ i ] ; int i0 = edge [ 0 ] ; int i1 = edge [ 1 ] ; if ( bevel ) { if ( edge [ 2 ] == EDGE_CLOSE ) { index = addBevel3D ( edge [ 1 ] , pi0 , pi1 , index , lastInd , firstInd , false ) ; lastInd [ 0 ] = lastInd [ 1 ] = - 1 ; } else { index = addLineSegment3D ( i0 , i1 , pi0 , pi1 , index , lastInd , false ) ; if ( edge [ 2 ] == EDGE_START ) firstInd = ( short ) ( lastInd [ 0 ] - 2 ) ; if ( edge [ 2 ] == EDGE_STOP || edge [ 2 ] == EDGE_SINGLE ) { lastInd [ 0 ] = lastInd [ 1 ] = - 1 ; } } } else if ( edge [ 2 ] != EDGE_CLOSE ) { index = addLineSegment3D ( i0 , i1 , pi0 , pi1 , index , null , false ) ; } pi0 = i0 ; pi1 = i1 ; } lastLineIndexCache = index ; } void tessellateEdges2D ( ) { int nInVert = in . getNumEdgeVertices ( false ) ; if ( noCapsJoins ( nInVert ) ) { int nInInd = in . getNumEdgeIndices ( false ) ; tess . polyVertexCheck ( nInVert ) ; tess . polyIndexCheck ( nInInd ) ; int index = in . renderMode == RETAINED ? tess . polyIndexCache . addNew ( ) : tess . polyIndexCache . getLast ( ) ; firstLineIndexCache = index ; if ( firstPolyIndexCache == - 1 ) firstPolyIndexCache = index ; boolean clamp = clampEdges2D ( ) ; for ( int i = 0 ; i <= in . edgeCount - 1 ; i ++ ) { int [ ] edge = in . edges [ i ] ; if ( edge [ 2 ] == EDGE_CLOSE ) continue ; int i0 = edge [ 0 ] ; int i1 = edge [ 1 ] ; index = addLineSegment2D ( i0 , i1 , index , false , clamp ) ; } lastLineIndexCache = lastPolyIndexCache = index ; } else { LinePath path = new LinePath ( LinePath . WIND_NON_ZERO ) ; for ( int i = 0 ; i <= in . edgeCount - 1 ; i ++ ) { int [ ] edge = in . edges [ i ] ; int i0 = edge [ 0 ] ; int i1 = edge [ 1 ] ; switch ( edge [ 2 ] ) { case EDGE_MIDDLE : path . lineTo ( strokeVertices [ 3 * i1 + 0 ] , strokeVertices [ 3 * i1 + 1 ] , strokeColors [ i1 ] ) ; break ; case EDGE_START : path . moveTo ( strokeVertices [ 3 * i0 + 0 ] , strokeVertices [ 3 * i0 + 1 ] , strokeColors [ i0 ] ) ; path . lineTo ( strokeVertices [ 3 * i1 + 0 ] , strokeVertices [ 3 * i1 + 1 ] , strokeColors [ i1 ] ) ; break ; case EDGE_STOP : path . lineTo ( strokeVertices [ 3 * i1 + 0 ] , strokeVertices [ 3 * i1 + 1 ] , strokeColors [ i1 ] ) ; path . moveTo ( strokeVertices [ 3 * i1 + 0 ] , strokeVertices [ 3 * i1 + 1 ] , strokeColors [ i1 ] ) ; break ; case EDGE_SINGLE : path . moveTo ( strokeVertices [ 3 * i0 + 0 ] , strokeVertices [ 3 * i0 + 1 ] , strokeColors [ i0 ] ) ; path . lineTo ( strokeVertices [ 3 * i1 + 0 ] , strokeVertices [ 3 * i1 + 1 ] , strokeColors [ i1 ] ) ; path . moveTo ( strokeVertices [ 3 * i1 + 0 ] , strokeVertices [ 3 * i1 + 1 ] , strokeColors [ i1 ] ) ; break ; case EDGE_CLOSE : path . closePath ( ) ; break ; } } tessellateLinePath ( path ) ; } } boolean clampEdges2D ( ) { boolean res = clamp2D ( ) ; if ( res ) { for ( int i = 0 ; i <= in . edgeCount - 1 ; i ++ ) { int [ ] edge = in . edges [ i ] ; if ( edge [ 2 ] == EDGE_CLOSE ) continue ; int i0 = edge [ 0 ] ; int i1 = edge [ 1 ] ; res = segmentIsAxisAligned ( strokeVertices , i0 , i1 ) ; if ( ! res ) break ; } } return res ; } int addLineSegment3D ( int i0 , int i1 , int pi0 , int pi1 , int index , short [ ] lastInd , boolean constStroke ) { IndexCache cache = tess . lineIndexCache ; int count = cache . vertexCount [ index ] ; boolean addBevel = lastInd != null && - 1 < lastInd [ 0 ] && - 1 < lastInd [ 1 ] ; boolean newCache = false ; if ( PGL . MAX_VERTEX_INDEX1 <= count + 4 + ( addBevel ? 1 : 0 ) ) { index = cache . addNew ( ) ; count = 0 ; newCache = true ; } int iidx = cache . indexOffset [ index ] + cache . indexCount [ index ] ; int vidx = cache . vertexOffset [ index ] + cache . vertexCount [ index ] ; int color , color0 ; float weight ; color0 = color = constStroke ? strokeColor : strokeColors [ i0 ] ; weight = constStroke ? strokeWeight : strokeWeights [ i0 ] ; weight *= transformScale ( ) ; tess . setLineVertex ( vidx ++ , strokeVertices , i0 , i1 , color , + weight / 2 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 0 ) ; tess . setLineVertex ( vidx ++ , strokeVertices , i0 , i1 , color , - weight / 2 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 1 ) ; color = constStroke ? strokeColor : strokeColors [ i1 ] ; weight = constStroke ? strokeWeight : strokeWeights [ i1 ] ; weight *= transformScale ( ) ; tess . setLineVertex ( vidx ++ , strokeVertices , i1 , i0 , color , - weight / 2 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 2 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 2 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 1 ) ; tess . setLineVertex ( vidx ++ , strokeVertices , i1 , i0 , color , + weight / 2 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 3 ) ; cache . incCounts ( index , 6 , 4 ) ; if ( lastInd != null ) { if ( - 1 < lastInd [ 0 ] && - 1 < lastInd [ 1 ] ) { if ( newCache ) { if ( - 1 < pi0 && - 1 <= pi1 ) { tess . setLineVertex ( vidx , strokeVertices , i0 , color0 ) ; color = constStroke ? strokeColor : strokeColors [ pi0 ] ; weight = constStroke ? strokeWeight : strokeWeights [ pi0 ] ; weight *= transformScale ( ) ; tess . setLineVertex ( vidx ++ , strokeVertices , pi1 , pi0 , color , - weight / 2 ) ; tess . setLineVertex ( vidx ++ , strokeVertices , pi1 , pi0 , color , + weight / 2 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 4 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 5 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 0 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 4 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 6 ) ; tess . lineIndices [ iidx ] = ( short ) ( count + 1 ) ; cache . incCounts ( index , 6 , 3 ) ; } } else { tess . setLineVertex ( vidx , strokeVertices , i0 , color0 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 4 ) ; tess . lineIndices [ iidx ++ ] = lastInd [ 0 ] ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 0 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 4 ) ; tess . lineIndices [ iidx ++ ] = lastInd [ 1 ] ; tess . lineIndices [ iidx ] = ( short ) ( count + 1 ) ; cache . incCounts ( index , 6 , 1 ) ; } lastInd [ 0 ] = ( short ) ( count + 2 ) ; lastInd [ 1 ] = ( short ) ( count + 3 ) ; } } return index ; } int addBevel3D ( int i0 , int pi0 , int pi1 , int index , short [ ] lastInd , short firstInd , boolean constStroke ) { IndexCache cache = tess . lineIndexCache ; int count = cache . vertexCount [ index ] ; boolean addBevel = lastInd != null && - 1 < lastInd [ 0 ] && - 1 < lastInd [ 1 ] ; boolean newCache = false ; if ( PGL . MAX_VERTEX_INDEX1 <= count + ( addBevel ? 1 : 0 ) ) { index = cache . addNew ( ) ; count = 0 ; newCache = true ; } int iidx = cache . indexOffset [ index ] + cache . indexCount [ index ] ; int vidx = cache . vertexOffset [ index ] + cache . vertexCount [ index ] ; int color0 = constStroke ? strokeColor : strokeColors [ i0 ] ; if ( lastInd != null ) { if ( - 1 < lastInd [ 0 ] && - 1 < lastInd [ 1 ] ) { tess . setLineVertex ( vidx , strokeVertices , i0 , color0 ) ; if ( newCache ) { if ( - 1 < pi0 && - 1 <= pi1 ) { int color1 = constStroke ? strokeColor : strokeColors [ pi1 ] ; tess . setLineVertex ( vidx , strokeVertices , pi0 , color0 ) ; tess . setLineVertex ( vidx , strokeVertices , pi1 , color1 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 4 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 5 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 0 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 4 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 6 ) ; tess . lineIndices [ iidx ] = ( short ) ( count + 1 ) ; cache . incCounts ( index , 6 , 3 ) ; } } else { tess . lineIndices [ iidx ++ ] = ( short ) ( count + 0 ) ; tess . lineIndices [ iidx ++ ] = lastInd [ 0 ] ; tess . lineIndices [ iidx ++ ] = ( short ) ( firstInd + 0 ) ; tess . lineIndices [ iidx ++ ] = ( short ) ( count + 0 ) ; tess . lineIndices [ iidx ++ ] = lastInd [ 1 ] ; tess . lineIndices [ iidx ] = ( short ) ( firstInd + 1 ) ; cache . incCounts ( index , 6 , 1 ) ; } } } return index ; } int addLineSegment2D ( int i0 , int i1 , int index , boolean constStroke , boolean clamp ) { IndexCache cache = tess . polyIndexCache ; int count = cache . vertexCount [ index ] ; if ( PGL . MAX_VERTEX_INDEX1 <= count + 4 ) { index = cache . addNew ( ) ; count = 0 ; } int iidx = cache . indexOffset [ index ] + cache . indexCount [ index ] ; int vidx = cache . vertexOffset [ index ] + cache . vertexCount [ index ] ; int color = constStroke ? strokeColor : strokeColors [ i0 ] ; float weight = constStroke ? strokeWeight : strokeWeights [ i0 ] ; if ( subPixelStroke ( weight ) ) clamp = false ; float x0 = strokeVertices [ 3 * i0 + 0 ] ; float y0 = strokeVertices [ 3 * i0 + 1 ] ; float x1 = strokeVertices [ 3 * i1 + 0 ] ; float y1 = strokeVertices [ 3 * i1 + 1 ] ; float dirx = x1 - x0 ; float diry = y1 - y0 ; float llen = PApplet . sqrt ( dirx * dirx + diry * diry ) ; float normx = 0 , normy = 0 ; float dirdx = 0 , dirdy = 0 ; if ( nonZero ( llen ) ) { normx = - diry / llen ; normy = + dirx / llen ; dirdx = ( dirx / llen ) * PApplet . min ( 0.75f , weight / 2 ) ; dirdy = ( diry / llen ) * PApplet . min ( 0.75f , weight / 2 ) ; } float normdx = normx * weight / 2 ; float normdy = normy * weight / 2 ; tess . setPolyVertex ( vidx ++ , x0 + normdx - dirdx , y0 + normdy - dirdy , 0 , color , clamp ) ; tess . polyIndices [ iidx ++ ] = ( short ) ( count + 0 ) ; tess . setPolyVertex ( vidx ++ , x0 - normdx - dirdx , y0 - normdy - dirdy , 0 , color , clamp ) ; tess . polyIndices [ iidx ++ ] = ( short ) ( count + 1 ) ; if ( clamp ) { float xac = tess . polyVertices [ 4 * ( vidx - 2 ) + 0 ] ; float yac = tess . polyVertices [ 4 * ( vidx - 2 ) + 1 ] ; float xbc = tess . polyVertices [ 4 * ( vidx - 1 ) + 0 ] ; float ybc = tess . polyVertices [ 4 * ( vidx - 1 ) + 1 ] ; if ( same ( xac , xbc ) && same ( yac , ybc ) ) { unclampLine2D ( vidx - 2 , x0 + normdx - dirdx , y0 + normdy - dirdy ) ; unclampLine2D ( vidx - 1 , x0 - normdx - dirdx , y0 - normdy - dirdy ) ; } } if ( ! constStroke ) { color = strokeColors [ i1 ] ; weight = strokeWeights [ i1 ] ; normdx = normx * weight / 2 ; normdy = normy * weight / 2 ; if ( subPixelStroke ( weight ) ) clamp = false ; } tess . setPolyVertex ( vidx ++ , x1 - normdx + dirdx , y1 - normdy + dirdy , 0 , color , clamp ) ; tess . polyIndices [ iidx ++ ] = ( short ) ( count + 2 ) ; tess . polyIndices [ iidx ++ ] = ( short ) ( count + 2 ) ; tess . polyIndices [ iidx ++ ] = ( short ) ( count + 0 ) ; tess . setPolyVertex ( vidx ++ , x1 + normdx + dirdx , y1 + normdy + dirdy , 0 , color , clamp ) ; tess . polyIndices [ iidx ++ ] = ( short ) ( count + 3 ) ; if ( clamp ) { float xac = tess . polyVertices [ 4 * ( vidx - 2 ) + 0 ] ; float yac = tess . polyVertices [ 4 * ( vidx - 2 ) + 1 ] ; float xbc = tess . polyVertices [ 4 * ( vidx - 1 ) + 0 ] ; float ybc = tess . polyVertices [ 4 * ( vidx - 1 ) + 1 ] ; if ( same ( xac , xbc ) && same ( yac , ybc ) ) { unclampLine2D ( vidx - 2 , x1 - normdx + dirdx , y1 - normdy + dirdy ) ; unclampLine2D ( vidx - 1 , x1 + normdx + dirdx , y1 + normdy + dirdy ) ; } } cache . incCounts ( index , 6 , 4 ) ; return index ; } void unclampLine2D ( int tessIdx , float x , float y ) { PMatrix3D mm = pg . modelview ; int index = 4 * tessIdx ; tess . polyVertices [ index ++ ] = x * mm . m00 + y * mm . m01 + mm . m03 ; tess . polyVertices [ index ++ ] = x * mm . m10 + y * mm . m11 + mm . m13 ; } boolean noCapsJoins ( int nInVert ) { if ( ! accurate2DStrokes ) { return true ; } else if ( PGL . MAX_CAPS_JOINS_LENGTH <= nInVert ) { return true ; } else { return noCapsJoins ( ) ; } } boolean subPixelStroke ( float weight ) { float sw = transformScale ( ) * weight ; return PApplet . abs ( sw - ( int ) sw ) > 0 ; } boolean noCapsJoins ( ) { return tess . renderMode == IMMEDIATE && transformScale ( ) * strokeWeight < PGL . MIN_CAPS_JOINS_WEIGHT ; } float transformScale ( ) { if ( - 1 < transformScale ) return transformScale ; float factor = 1 ; if ( transform != null ) { if ( transform instanceof PMatrix2D ) { PMatrix2D tr = ( PMatrix2D ) transform ; float areaScaleFactor = Math . abs ( tr . m00 * tr . m11 - tr . m01 * tr . m10 ) ; factor = ( float ) Math . sqrt ( areaScaleFactor ) ; } else if ( transform instanceof PMatrix3D ) { PMatrix3D tr = ( PMatrix3D ) transform ; float volumeScaleFactor = Math . abs ( tr . m00 * ( tr . m11 * tr . m22 - tr . m12 * tr . m21 ) + tr . m01 * ( tr . m12 * tr . m20 - tr . m10 * tr . m22 ) + tr . m02 * ( tr . m10 * tr . m21 - tr . m11 * tr . m20 ) ) ; factor = ( float ) Math . pow ( volumeScaleFactor , 1.0f / 3.0f ) ; } } return transformScale = factor ; } boolean segmentIsAxisAligned ( int i0 , int i1 ) { return zero ( in . vertices [ 3 * i0 + 0 ] - in . vertices [ 3 * i1 + 0 ] ) || zero ( in . vertices [ 3 * i0 + 1 ] - in . vertices [ 3 * i1 + 1 ] ) ; } boolean segmentIsAxisAligned ( float [ ] vertices , int i0 , int i1 ) { return zero ( vertices [ 3 * i0 + 0 ] - vertices [ 3 * i1 + 0 ] ) || zero ( vertices [ 3 * i0 + 1 ] - vertices [ 3 * i1 + 1 ] ) ; } void tessellateTriangles ( ) { beginTex ( ) ; int nTri = in . vertexCount / 3 ; if ( fill && 1 <= nTri ) { int nInInd = 3 * nTri ; setRawSize ( nInInd ) ; int idx = 0 ; boolean clamp = clampTriangles ( ) ; for ( int i = 0 ; i < 3 * nTri ; i ++ ) { rawIndices [ idx ++ ] = i ; } splitRawIndices ( clamp ) ; } endTex ( ) ; tessellateEdges ( ) ; } boolean clampTriangles ( ) { boolean res = clamp2D ( ) ; if ( res ) { int nTri = in . vertexCount / 3 ; for ( int i = 0 ; i < nTri ; i ++ ) { int i0 = 3 * i + 0 ; int i1 = 3 * i + 1 ; int i2 = 3 * i + 2 ; int count = 0 ; if ( segmentIsAxisAligned ( i0 , i1 ) ) count ++ ; if ( segmentIsAxisAligned ( i0 , i2 ) ) count ++ ; if ( segmentIsAxisAligned ( i1 , i2 ) ) count ++ ; res = 1 < count ; if ( ! res ) break ; } } return res ; } void tessellateTriangles ( int [ ] indices ) { beginTex ( ) ; int nInVert = in . vertexCount ; if ( fill && 3 <= nInVert ) { int nInInd = indices . length ; setRawSize ( nInInd ) ; PApplet . arrayCopy ( indices , rawIndices , nInInd ) ; boolean clamp = clampTriangles ( indices ) ; splitRawIndices ( clamp ) ; } endTex ( ) ; tessellateEdges ( ) ; } boolean clampTriangles ( int [ ] indices ) { boolean res = clamp2D ( ) ; if ( res ) { int nTri = indices . length ; for ( int i = 0 ; i < nTri ; i ++ ) { int i0 = indices [ 3 * i + 0 ] ; int i1 = indices [ 3 * i + 1 ] ; int i2 = indices [ 3 * i + 2 ] ; int count = 0 ; if ( segmentIsAxisAligned ( i0 , i1 ) ) count ++ ; if ( segmentIsAxisAligned ( i0 , i2 ) ) count ++ ; if ( segmentIsAxisAligned ( i1 , i2 ) ) count ++ ; res = 1 < count ; if ( ! res ) break ; } } return res ; } void tessellateTriangleFan ( ) { beginTex ( ) ; int nInVert = in . vertexCount ; if ( fill && 3 <= nInVert ) { int nInInd = 3 * ( nInVert - 2 ) ; setRawSize ( nInInd ) ; int idx = 0 ; boolean clamp = clampTriangleFan ( ) ; for ( int i = 1 ; i < in . vertexCount - 1 ; i ++ ) { rawIndices [ idx ++ ] = 0 ; rawIndices [ idx ++ ] = i ; rawIndices [ idx ++ ] = i + 1 ; } splitRawIndices ( clamp ) ; } endTex ( ) ; tessellateEdges ( ) ; } boolean clampTriangleFan ( ) { boolean res = clamp2D ( ) ; if ( res ) { for ( int i = 1 ; i < in . vertexCount - 1 ; i ++ ) { int i0 = 0 ; int i1 = i ; int i2 = i + 1 ; int count = 0 ; if ( segmentIsAxisAligned ( i0 , i1 ) ) count ++ ; if ( segmentIsAxisAligned ( i0 , i2 ) ) count ++ ; if ( segmentIsAxisAligned ( i1 , i2 ) ) count ++ ; res = 1 < count ; if ( ! res ) break ; } } return res ; } void tessellateTriangleStrip ( ) { beginTex ( ) ; int nInVert = in . vertexCount ; if ( fill && 3 <= nInVert ) { int nInInd = 3 * ( nInVert - 2 ) ; setRawSize ( nInInd ) ; int idx = 0 ; boolean clamp = clampTriangleStrip ( ) ; for ( int i = 1 ; i < in . vertexCount - 1 ; i ++ ) { rawIndices [ idx ++ ] = i ; if ( i % 2 == 0 ) { rawIndices [ idx ++ ] = i - 1 ; rawIndices [ idx ++ ] = i + 1 ; } else { rawIndices [ idx ++ ] = i + 1 ; rawIndices [ idx ++ ] = i - 1 ; } } splitRawIndices ( clamp ) ; } endTex ( ) ; tessellateEdges ( ) ; } boolean clampTriangleStrip ( ) { boolean res = clamp2D ( ) ; if ( res ) { for ( int i = 1 ; i < in . vertexCount - 1 ; i ++ ) { int i0 = i ; int i1 , i2 ; if ( i % 2 == 0 ) { i1 = i - 1 ; i2 = i + 1 ; } else { i1 = i + 1 ; i2 = i - 1 ; } int count = 0 ; if ( segmentIsAxisAligned ( i0 , i1 ) ) count ++ ; if ( segmentIsAxisAligned ( i0 , i2 ) ) count ++ ; if ( segmentIsAxisAligned ( i1 , i2 ) ) count ++ ; res = 1 < count ; if ( ! res ) break ; } } return res ; } void tessellateQuads ( ) { beginTex ( ) ; int quadCount = in . vertexCount / 4 ; if ( fill && 1 <= quadCount ) { int nInInd = 6 * quadCount ; setRawSize ( nInInd ) ; int idx = 0 ; boolean clamp = clampQuads ( quadCount ) ; for ( int qd = 0 ; qd < quadCount ; qd ++ ) { int i0 = 4 * qd + 0 ; int i1 = 4 * qd + 1 ; int i2 = 4 * qd + 2 ; int i3 = 4 * qd + 3 ; rawIndices [ idx ++ ] = i0 ; rawIndices [ idx ++ ] = i1 ; rawIndices [ idx ++ ] = i2 ; rawIndices [ idx ++ ] = i2 ; rawIndices [ idx ++ ] = i3 ; rawIndices [ idx ++ ] = i0 ; } splitRawIndices ( clamp ) ; } endTex ( ) ; tessellateEdges ( ) ; } boolean clampQuads ( int quadCount ) { boolean res = clamp2D ( ) ; if ( res ) { for ( int qd = 0 ; qd < quadCount ; qd ++ ) { int i0 = 4 * qd + 0 ; int i1 = 4 * qd + 1 ; int i2 = 4 * qd + 2 ; int i3 = 4 * qd + 3 ; res = segmentIsAxisAligned ( i0 , i1 ) && segmentIsAxisAligned ( i1 , i2 ) && segmentIsAxisAligned ( i2 , i3 ) ; if ( ! res ) break ; } } return res ; } void tessellateQuadStrip ( ) { beginTex ( ) ; int quadCount = in . vertexCount / 2 - 1 ; if ( fill && 1 <= quadCount ) { int nInInd = 6 * quadCount ; setRawSize ( nInInd ) ; int idx = 0 ; boolean clamp = clampQuadStrip ( quadCount ) ; for ( int qd = 1 ; qd < quadCount + 1 ; qd ++ ) { int i0 = 2 * ( qd - 1 ) ; int i1 = 2 * ( qd - 1 ) + 1 ; int i2 = 2 * qd + 1 ; int i3 = 2 * qd ; rawIndices [ idx ++ ] = i0 ; rawIndices [ idx ++ ] = i1 ; rawIndices [ idx ++ ] = i3 ; rawIndices [ idx ++ ] = i1 ; rawIndices [ idx ++ ] = i2 ; rawIndices [ idx ++ ] = i3 ; } splitRawIndices ( clamp ) ; } endTex ( ) ; tessellateEdges ( ) ; } boolean clampQuadStrip ( int quadCount ) { boolean res = clamp2D ( ) ; if ( res ) { for ( int qd = 1 ; qd < quadCount + 1 ; qd ++ ) { int i0 = 2 * ( qd - 1 ) ; int i1 = 2 * ( qd - 1 ) + 1 ; int i2 = 2 * qd + 1 ; int i3 = 2 * qd ; res = segmentIsAxisAligned ( i0 , i1 ) && segmentIsAxisAligned ( i1 , i2 ) && segmentIsAxisAligned ( i2 , i3 ) ; if ( ! res ) break ; } } return res ; } void splitRawIndices ( boolean clamp ) { tess . polyIndexCheck ( rawSize ) ; int offset = tess . firstPolyIndex ; int inInd0 = 0 , inInd1 = 0 ; int inMaxVert0 = 0 , inMaxVert1 = 0 ; int inMaxVertRef = inMaxVert0 ; int inMaxVertRel = - 1 ; dupCount = 0 ; IndexCache cache = tess . polyIndexCache ; int index = in . renderMode == RETAINED ? cache . addNew ( ) : cache . getLast ( ) ; firstPolyIndexCache = index ; int trCount = rawSize / 3 ; for ( int tr = 0 ; tr < trCount ; tr ++ ) { if ( index == - 1 ) index = cache . addNew ( ) ; int i0 = rawIndices [ 3 * tr + 0 ] ; int i1 = rawIndices [ 3 * tr + 1 ] ; int i2 = rawIndices [ 3 * tr + 2 ] ; int ii0 = i0 - inMaxVertRef ; int ii1 = i1 - inMaxVertRef ; int ii2 = i2 - inMaxVertRef ; int count = cache . vertexCount [ index ] ; int ri0 , ri1 , ri2 ; if ( ii0 < 0 ) { addDupIndex ( ii0 ) ; ri0 = ii0 ; } else ri0 = count + ii0 ; if ( ii1 < 0 ) { addDupIndex ( ii1 ) ; ri1 = ii1 ; } else ri1 = count + ii1 ; if ( ii2 < 0 ) { addDupIndex ( ii2 ) ; ri2 = ii2 ; } else ri2 = count + ii2 ; tess . polyIndices [ offset + 3 * tr + 0 ] = ( short ) ri0 ; tess . polyIndices [ offset + 3 * tr + 1 ] = ( short ) ri1 ; tess . polyIndices [ offset + 3 * tr + 2 ] = ( short ) ri2 ; inInd1 = 3 * tr + 2 ; inMaxVert1 = PApplet . max ( inMaxVert1 , PApplet . max ( i0 , i1 , i2 ) ) ; inMaxVert0 = PApplet . min ( inMaxVert0 , PApplet . min ( i0 , i1 , i2 ) ) ; inMaxVertRel = PApplet . max ( inMaxVertRel , PApplet . max ( ri0 , ri1 , ri2 ) ) ; if ( ( PGL . MAX_VERTEX_INDEX1 - 3 <= inMaxVertRel + dupCount && inMaxVertRel + dupCount < PGL . MAX_VERTEX_INDEX1 ) || ( tr == trCount - 1 ) ) { int nondupCount = 0 ; if ( 0 < dupCount ) { for ( int i = inInd0 ; i <= inInd1 ; i ++ ) { int ri = tess . polyIndices [ offset + i ] ; if ( ri < 0 ) { tess . polyIndices [ offset + i ] = ( short ) ( inMaxVertRel + 1 + dupIndexPos ( ri ) ) ; } } if ( inMaxVertRef <= inMaxVert1 ) { tess . addPolyVertices ( in , inMaxVertRef , inMaxVert1 , clamp ) ; nondupCount = inMaxVert1 - inMaxVertRef + 1 ; } for ( int i = 0 ; i < dupCount ; i ++ ) { tess . addPolyVertex ( in , dupIndices [ i ] + inMaxVertRef , clamp ) ; } } else { tess . addPolyVertices ( in , inMaxVert0 , inMaxVert1 , clamp ) ; nondupCount = inMaxVert1 - inMaxVert0 + 1 ; } cache . incCounts ( index , inInd1 - inInd0 + 1 , nondupCount + dupCount ) ; lastPolyIndexCache = index ; index = - 1 ; inMaxVertRel = - 1 ; inMaxVertRef = inMaxVert1 + 1 ; inMaxVert0 = inMaxVertRef ; inInd0 = inInd1 + 1 ; if ( dupIndices != null ) Arrays . fill ( dupIndices , 0 , dupCount , 0 ) ; dupCount = 0 ; } } } void addDupIndex ( int idx ) { if ( dupIndices == null ) { dupIndices = new int [ 16 ] ; } if ( dupIndices . length == dupCount ) { int n = dupCount < < 1 ; int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( dupIndices , 0 , temp , 0 , dupCount ) ; dupIndices = temp ; } if ( idx < dupIndices [ 0 ] ) { for ( int i = dupCount ; i > 0 ; i -- ) dupIndices [ i ] = dupIndices [ i - 1 ] ; dupIndices [ 0 ] = idx ; dupCount ++ ; } else if ( dupIndices [ dupCount - 1 ] < idx ) { dupIndices [ dupCount ] = idx ; dupCount ++ ; } else { for ( int i = 0 ; i < dupCount - 1 ; i ++ ) { if ( dupIndices [ i ] == idx ) break ; if ( dupIndices [ i ] < idx && idx < dupIndices [ i + 1 ] ) { for ( int j = dupCount ; j > i + 1 ; j -- ) { dupIndices [ j ] = dupIndices [ j - 1 ] ; } dupIndices [ i + 1 ] = idx ; dupCount ++ ; break ; } } } } int dupIndexPos ( int idx ) { for ( int i = 0 ; i < dupCount ; i ++ ) { if ( dupIndices [ i ] == idx ) return i ; } return 0 ; } void setRawSize ( int size ) { int size0 = rawIndices . length ; if ( size0 < size ) { int size1 = expandArraySize ( size0 , size ) ; expandRawIndices ( size1 ) ; } rawSize = size ; } void expandRawIndices ( int n ) { int temp [ ] = new int [ n ] ; PApplet . arrayCopy ( rawIndices , 0 , temp , 0 , rawSize ) ; rawIndices = temp ; } void beginTex ( ) { setFirstTexIndex ( tess . polyIndexCount , tess . polyIndexCache . size - 1 ) ; } void endTex ( ) { setLastTexIndex ( tess . lastPolyIndex , tess . polyIndexCache . size - 1 ) ; } void beginNoTex ( ) { newTexImage = null ; setFirstTexIndex ( tess . polyIndexCount , tess . polyIndexCache . size - 1 ) ; } void endNoTex ( ) { setLastTexIndex ( tess . lastPolyIndex , tess . polyIndexCache . size - 1 ) ; } void updateTex ( ) { beginTex ( ) ; endTex ( ) ; } void setFirstTexIndex ( int firstIndex , int firstCache ) { if ( texCache != null ) { firstTexIndex = firstIndex ; firstTexCache = PApplet . max ( 0 , firstCache ) ; } } void setLastTexIndex ( int lastIndex , int lastCache ) { if ( texCache != null ) { if ( prevTexImage != newTexImage || texCache . size == 0 ) { texCache . addTexture ( newTexImage , firstTexIndex , firstTexCache , lastIndex , lastCache ) ; } else { texCache . setLastIndex ( lastIndex , lastCache ) ; } } prevTexImage = newTexImage ; } void tessellatePolygon ( boolean solid , boolean closed , boolean calcNormals ) { beginTex ( ) ; int nInVert = in . vertexCount ; if ( 3 <= nInVert ) { firstPolyIndexCache = - 1 ; initGluTess ( ) ; boolean clamp = clampPolygon ( ) ; callback . init ( in . renderMode == RETAINED , false , calcNormals , clamp ) ; if ( fill ) { gluTess . beginPolygon ( ) ; if ( solid ) { gluTess . setWindingRule ( PGL . TESS_WINDING_NONZERO ) ; } else { gluTess . setWindingRule ( PGL . TESS_WINDING_ODD ) ; } gluTess . beginContour ( ) ; } if ( stroke ) { beginPolygonStroke ( ) ; beginStrokePath ( ) ; } int i = 0 ; int c = 0 ; while ( i < in . vertexCount ) { int code = VERTEX ; boolean brk = false ; if ( in . codes != null && c < in . codeCount ) { code = in . codes [ c ++ ] ; if ( code == BREAK && c < in . codeCount ) { brk = true ; code = in . codes [ c ++ ] ; } } if ( brk ) { if ( stroke ) { endStrokePath ( closed ) ; beginStrokePath ( ) ; } if ( fill ) { gluTess . endContour ( ) ; gluTess . beginContour ( ) ; } } if ( code == BEZIER_VERTEX ) { addBezierVertex ( i ) ; i += 3 ; } else if ( code == QUADRATIC_VERTEX ) { addQuadraticVertex ( i ) ; i += 2 ; } else if ( code == CURVE_VERTEX ) { addCurveVertex ( i ) ; i ++ ; } else { addVertex ( i ) ; i ++ ; } } if ( stroke ) { endStrokePath ( closed ) ; endPolygonStroke ( ) ; } if ( fill ) { gluTess . endContour ( ) ; gluTess . endPolygon ( ) ; } } endTex ( ) ; if ( stroke ) tessellateStrokePath ( ) ; } void addBezierVertex ( int i ) { pg . curveVertexCount = 0 ; pg . bezierInitCheck ( ) ; pg . bezierVertexCheck ( POLYGON , i ) ; PMatrix3D draw = pg . bezierDrawMatrix ; int i1 = i - 1 ; float x1 = in . vertices [ 3 * i1 + 0 ] ; float y1 = in . vertices [ 3 * i1 + 1 ] ; float z1 = in . vertices [ 3 * i1 + 2 ] ; int strokeColor = 0 ; float strokeWeight = 0 ; if ( stroke ) { strokeColor = in . strokeColors [ i ] ; strokeWeight = in . strokeWeights [ i ] ; } int fcol = 0 , fa = 0 , fr = 0 , fg = 0 , fb = 0 ; int acol = 0 , aa = 0 , ar = 0 , ag = 0 , ab = 0 ; int scol = 0 , sa = 0 , sr = 0 , sg = 0 , sb = 0 ; int ecol = 0 , ea = 0 , er = 0 , eg = 0 , eb = 0 ; float nx = 0 , ny = 0 , nz = 0 , u = 0 , v = 0 , sh = 0 ; if ( fill ) { fcol = in . colors [ i ] ; fa = ( fcol > > 24 ) & 0xFF ; fr = ( fcol > > 16 ) & 0xFF ; fg = ( fcol > > 8 ) & 0xFF ; fb = ( fcol > > 0 ) & 0xFF ; acol = in . ambient [ i ] ; aa = ( acol > > 24 ) & 0xFF ; ar = ( acol > > 16 ) & 0xFF ; ag = ( acol > > 8 ) & 0xFF ; ab = ( acol > > 0 ) & 0xFF ; scol = in . specular [ i ] ; sa = ( scol > > 24 ) & 0xFF ; sr = ( scol > > 16 ) & 0xFF ; sg = ( scol > > 8 ) & 0xFF ; sb = ( scol > > 0 ) & 0xFF ; ecol = in . emissive [ i ] ; ea = ( ecol > > 24 ) & 0xFF ; er = ( ecol > > 16 ) & 0xFF ; eg = ( ecol > > 8 ) & 0xFF ; eb = ( ecol > > 0 ) & 0xFF ; nx = in . normals [ 3 * i + 0 ] ; ny = in . normals [ 3 * i + 1 ] ; nz = in . normals [ 3 * i + 2 ] ; u = in . texcoords [ 2 * i + 0 ] ; v = in . texcoords [ 2 * i + 1 ] ; sh = in . shininess [ i ] ; } float x2 = in . vertices [ 3 * i + 0 ] ; float y2 = in . vertices [ 3 * i + 1 ] ; float z2 = in . vertices [ 3 * i + 2 ] ; float x3 = in . vertices [ 3 * ( i + 1 ) + 0 ] ; float y3 = in . vertices [ 3 * ( i + 1 ) + 1 ] ; float z3 = in . vertices [ 3 * ( i + 1 ) + 2 ] ; float x4 = in . vertices [ 3 * ( i + 2 ) + 0 ] ; float y4 = in . vertices [ 3 * ( i + 2 ) + 1 ] ; float z4 = in . vertices [ 3 * ( i + 2 ) + 2 ] ; float xplot1 = draw . m10 * x1 + draw . m11 * x2 + draw . m12 * x3 + draw . m13 * x4 ; float xplot2 = draw . m20 * x1 + draw . m21 * x2 + draw . m22 * x3 + draw . m23 * x4 ; float xplot3 = draw . m30 * x1 + draw . m31 * x2 + draw . m32 * x3 + draw . m33 * x4 ; float yplot1 = draw . m10 * y1 + draw . m11 * y2 + draw . m12 * y3 + draw . m13 * y4 ; float yplot2 = draw . m20 * y1 + draw . m21 * y2 + draw . m22 * y3 + draw . m23 * y4 ; float yplot3 = draw . m30 * y1 + draw . m31 * y2 + draw . m32 * y3 + draw . m33 * y4 ; float zplot1 = draw . m10 * z1 + draw . m11 * z2 + draw . m12 * z3 + draw . m13 * z4 ; float zplot2 = draw . m20 * z1 + draw . m21 * z2 + draw . m22 * z3 + draw . m23 * z4 ; float zplot3 = draw . m30 * z1 + draw . m31 * z2 + draw . m32 * z3 + draw . m33 * z4 ; for ( int j = 0 ; j < pg . bezierDetail ; j ++ ) { x1 += xplot1 ; xplot1 += xplot2 ; xplot2 += xplot3 ; y1 += yplot1 ; yplot1 += yplot2 ; yplot2 += yplot3 ; z1 += zplot1 ; zplot1 += zplot2 ; zplot2 += zplot3 ; if ( fill ) { double [ ] vertex = new double [ ] { x1 , y1 , z1 , fa , fr , fg , fb , nx , ny , nz , u , v , aa , ar , ag , ab , sa , sr , sg , sb , ea , er , eg , eb , sh } ; double [ ] avect = in . getAttribVector ( i ) ; if ( 0 < avect . length ) { double temp [ ] = new double [ vertex . length + avect . length ] ; PApplet . arrayCopy ( vertex , 0 , temp , 0 , vertex . length ) ; PApplet . arrayCopy ( avect , 0 , temp , vertex . length , avect . length ) ; vertex = temp ; } gluTess . addVertex ( vertex ) ; } if ( stroke ) addStrokeVertex ( x1 , y1 , z1 , strokeColor , strokeWeight ) ; } } void addQuadraticVertex ( int i ) { pg . curveVertexCount = 0 ; pg . bezierInitCheck ( ) ; pg . bezierVertexCheck ( POLYGON , i ) ; PMatrix3D draw = pg . bezierDrawMatrix ; int i1 = i - 1 ; float x1 = in . vertices [ 3 * i1 + 0 ] ; float y1 = in . vertices [ 3 * i1 + 1 ] ; float z1 = in . vertices [ 3 * i1 + 2 ] ; int strokeColor = 0 ; float strokeWeight = 0 ; if ( stroke ) { strokeColor = in . strokeColors [ i ] ; strokeWeight = in . strokeWeights [ i ] ; } int fcol = 0 , fa = 0 , fr = 0 , fg = 0 , fb = 0 ; int acol = 0 , aa = 0 , ar = 0 , ag = 0 , ab = 0 ; int scol = 0 , sa = 0 , sr = 0 , sg = 0 , sb = 0 ; int ecol = 0 , ea = 0 , er = 0 , eg = 0 , eb = 0 ; float nx = 0 , ny = 0 , nz = 0 , u = 0 , v = 0 , sh = 0 ; if ( fill ) { fcol = in . colors [ i ] ; fa = ( fcol > > 24 ) & 0xFF ; fr = ( fcol > > 16 ) & 0xFF ; fg = ( fcol > > 8 ) & 0xFF ; fb = ( fcol > > 0 ) & 0xFF ; acol = in . ambient [ i ] ; aa = ( acol > > 24 ) & 0xFF ; ar = ( acol > > 16 ) & 0xFF ; ag = ( acol > > 8 ) & 0xFF ; ab = ( acol > > 0 ) & 0xFF ; scol = in . specular [ i ] ; sa = ( scol > > 24 ) & 0xFF ; sr = ( scol > > 16 ) & 0xFF ; sg = ( scol > > 8 ) & 0xFF ; sb = ( scol > > 0 ) & 0xFF ; ecol = in . emissive [ i ] ; ea = ( ecol > > 24 ) & 0xFF ; er = ( ecol > > 16 ) & 0xFF ; eg = ( ecol > > 8 ) & 0xFF ; eb = ( ecol > > 0 ) & 0xFF ; nx = in . normals [ 3 * i + 0 ] ; ny = in . normals [ 3 * i + 1 ] ; nz = in . normals [ 3 * i + 2 ] ; u = in . texcoords [ 2 * i + 0 ] ; v = in . texcoords [ 2 * i + 1 ] ; sh = in . shininess [ i ] ; } float cx = in . vertices [ 3 * i + 0 ] ; float cy = in . vertices [ 3 * i + 1 ] ; float cz = in . vertices [ 3 * i + 2 ] ; float x = in . vertices [ 3 * ( i + 1 ) + 0 ] ; float y = in . vertices [ 3 * ( i + 1 ) + 1 ] ; float z = in . vertices [ 3 * ( i + 1 ) + 2 ] ; float x2 = x1 + ( ( cx - x1 ) * 2 / 3.0f ) ; float y2 = y1 + ( ( cy - y1 ) * 2 / 3.0f ) ; float z2 = z1 + ( ( cz - z1 ) * 2 / 3.0f ) ; float x3 = x + ( ( cx - x ) * 2 / 3.0f ) ; float y3 = y + ( ( cy - y ) * 2 / 3.0f ) ; float z3 = z + ( ( cz - z ) * 2 / 3.0f ) ; float x4 = x ; float y4 = y ; float z4 = z ; float xplot1 = draw . m10 * x1 + draw . m11 * x2 + draw . m12 * x3 + draw . m13 * x4 ; float xplot2 = draw . m20 * x1 + draw . m21 * x2 + draw . m22 * x3 + draw . m23 * x4 ; float xplot3 = draw . m30 * x1 + draw . m31 * x2 + draw . m32 * x3 + draw . m33 * x4 ; float yplot1 = draw . m10 * y1 + draw . m11 * y2 + draw . m12 * y3 + draw . m13 * y4 ; float yplot2 = draw . m20 * y1 + draw . m21 * y2 + draw . m22 * y3 + draw . m23 * y4 ; float yplot3 = draw . m30 * y1 + draw . m31 * y2 + draw . m32 * y3 + draw . m33 * y4 ; float zplot1 = draw . m10 * z1 + draw . m11 * z2 + draw . m12 * z3 + draw . m13 * z4 ; float zplot2 = draw . m20 * z1 + draw . m21 * z2 + draw . m22 * z3 + draw . m23 * z4 ; float zplot3 = draw . m30 * z1 + draw . m31 * z2 + draw . m32 * z3 + draw . m33 * z4 ; for ( int j = 0 ; j < pg . bezierDetail ; j ++ ) { x1 += xplot1 ; xplot1 += xplot2 ; xplot2 += xplot3 ; y1 += yplot1 ; yplot1 += yplot2 ; yplot2 += yplot3 ; z1 += zplot1 ; zplot1 += zplot2 ; zplot2 += zplot3 ; if ( fill ) { double [ ] vertex = new double [ ] { x1 , y1 , z1 , fa , fr , fg , fb , nx , ny , nz , u , v , aa , ar , ag , ab , sa , sr , sg , sb , ea , er , eg , eb , sh } ; double [ ] avect = in . getAttribVector ( i ) ; if ( 0 < avect . length ) { double temp [ ] = new double [ vertex . length + avect . length ] ; PApplet . arrayCopy ( vertex , 0 , temp , 0 , vertex . length ) ; PApplet . arrayCopy ( avect , 0 , temp , vertex . length , avect . length ) ; vertex = temp ; } gluTess . addVertex ( vertex ) ; } if ( stroke ) addStrokeVertex ( x1 , y1 , z1 , strokeColor , strokeWeight ) ; } } void addCurveVertex ( int i ) { pg . curveVertexCheck ( POLYGON ) ; float [ ] vertex = pg . curveVertices [ pg . curveVertexCount ] ; vertex [ X ] = in . vertices [ 3 * i + 0 ] ; vertex [ Y ] = in . vertices [ 3 * i + 1 ] ; vertex [ Z ] = in . vertices [ 3 * i + 2 ] ; pg . curveVertexCount ++ ; if ( pg . curveVertexCount > 3 ) { float [ ] v1 = pg . curveVertices [ pg . curveVertexCount - 4 ] ; float [ ] v2 = pg . curveVertices [ pg . curveVertexCount - 3 ] ; float [ ] v3 = pg . curveVertices [ pg . curveVertexCount - 2 ] ; float [ ] v4 = pg . curveVertices [ pg . curveVertexCount - 1 ] ; addCurveVertexSegment ( i , v1 [ X ] , v1 [ Y ] , v1 [ Z ] , v2 [ X ] , v2 [ Y ] , v2 [ Z ] , v3 [ X ] , v3 [ Y ] , v3 [ Z ] , v4 [ X ] , v4 [ Y ] , v4 [ Z ] ) ; } } void addCurveVertexSegment ( int i , float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { int strokeColor = 0 ; float strokeWeight = 0 ; if ( stroke ) { strokeColor = in . strokeColors [ i ] ; strokeWeight = in . strokeWeights [ i ] ; } int fcol = 0 , fa = 0 , fr = 0 , fg = 0 , fb = 0 ; int acol = 0 , aa = 0 , ar = 0 , ag = 0 , ab = 0 ; int scol = 0 , sa = 0 , sr = 0 , sg = 0 , sb = 0 ; int ecol = 0 , ea = 0 , er = 0 , eg = 0 , eb = 0 ; float nx = 0 , ny = 0 , nz = 0 , u = 0 , v = 0 , sh = 0 ; if ( fill ) { fcol = in . colors [ i ] ; fa = ( fcol > > 24 ) & 0xFF ; fr = ( fcol > > 16 ) & 0xFF ; fg = ( fcol > > 8 ) & 0xFF ; fb = ( fcol > > 0 ) & 0xFF ; acol = in . ambient [ i ] ; aa = ( acol > > 24 ) & 0xFF ; ar = ( acol > > 16 ) & 0xFF ; ag = ( acol > > 8 ) & 0xFF ; ab = ( acol > > 0 ) & 0xFF ; scol = in . specular [ i ] ; sa = ( scol > > 24 ) & 0xFF ; sr = ( scol > > 16 ) & 0xFF ; sg = ( scol > > 8 ) & 0xFF ; sb = ( scol > > 0 ) & 0xFF ; ecol = in . emissive [ i ] ; ea = ( ecol > > 24 ) & 0xFF ; er = ( ecol > > 16 ) & 0xFF ; eg = ( ecol > > 8 ) & 0xFF ; eb = ( ecol > > 0 ) & 0xFF ; nx = in . normals [ 3 * i + 0 ] ; ny = in . normals [ 3 * i + 1 ] ; nz = in . normals [ 3 * i + 2 ] ; u = in . texcoords [ 2 * i + 0 ] ; v = in . texcoords [ 2 * i + 1 ] ; sh = in . shininess [ i ] ; } float x = x2 ; float y = y2 ; float z = z2 ; PMatrix3D draw = pg . curveDrawMatrix ; float xplot1 = draw . m10 * x1 + draw . m11 * x2 + draw . m12 * x3 + draw . m13 * x4 ; float xplot2 = draw . m20 * x1 + draw . m21 * x2 + draw . m22 * x3 + draw . m23 * x4 ; float xplot3 = draw . m30 * x1 + draw . m31 * x2 + draw . m32 * x3 + draw . m33 * x4 ; float yplot1 = draw . m10 * y1 + draw . m11 * y2 + draw . m12 * y3 + draw . m13 * y4 ; float yplot2 = draw . m20 * y1 + draw . m21 * y2 + draw . m22 * y3 + draw . m23 * y4 ; float yplot3 = draw . m30 * y1 + draw . m31 * y2 + draw . m32 * y3 + draw . m33 * y4 ; float zplot1 = draw . m10 * z1 + draw . m11 * z2 + draw . m12 * z3 + draw . m13 * z4 ; float zplot2 = draw . m20 * z1 + draw . m21 * z2 + draw . m22 * z3 + draw . m23 * z4 ; float zplot3 = draw . m30 * z1 + draw . m31 * z2 + draw . m32 * z3 + draw . m33 * z4 ; if ( fill ) { double [ ] vertex0 = new double [ ] { x , y , z , fa , fr , fg , fb , nx , ny , nz , u , v , aa , ar , ag , ab , sa , sr , sg , sb , ea , er , eg , eb , sh } ; double [ ] avect = in . getAttribVector ( i ) ; if ( 0 < avect . length ) { double temp [ ] = new double [ vertex0 . length + avect . length ] ; PApplet . arrayCopy ( vertex0 , 0 , temp , 0 , vertex0 . length ) ; PApplet . arrayCopy ( avect , 0 , temp , vertex0 . length , avect . length ) ; vertex0 = temp ; } gluTess . addVertex ( vertex0 ) ; } if ( stroke ) addStrokeVertex ( x , y , z , strokeColor , strokeWeight ) ; for ( int j = 0 ; j < pg . curveDetail ; j ++ ) { x += xplot1 ; xplot1 += xplot2 ; xplot2 += xplot3 ; y += yplot1 ; yplot1 += yplot2 ; yplot2 += yplot3 ; z += zplot1 ; zplot1 += zplot2 ; zplot2 += zplot3 ; if ( fill ) { double [ ] vertex1 = new double [ ] { x , y , z , fa , fr , fg , fb , nx , ny , nz , u , v , aa , ar , ag , ab , sa , sr , sg , sb , ea , er , eg , eb , sh } ; double [ ] avect = in . getAttribVector ( i ) ; if ( 0 < avect . length ) { double temp [ ] = new double [ vertex1 . length + avect . length ] ; PApplet . arrayCopy ( vertex1 , 0 , temp , 0 , vertex1 . length ) ; PApplet . arrayCopy ( avect , 0 , temp , vertex1 . length , avect . length ) ; vertex1 = temp ; } gluTess . addVertex ( vertex1 ) ; } if ( stroke ) addStrokeVertex ( x , y , z , strokeColor , strokeWeight ) ; } } void addVertex ( int i ) { pg . curveVertexCount = 0 ; float x = in . vertices [ 3 * i + 0 ] ; float y = in . vertices [ 3 * i + 1 ] ; float z = in . vertices [ 3 * i + 2 ] ; int strokeColor = 0 ; float strokeWeight = 0 ; if ( stroke ) { strokeColor = in . strokeColors [ i ] ; strokeWeight = in . strokeWeights [ i ] ; } if ( fill ) { int fcol = in . colors [ i ] ; int fa = ( fcol > > 24 ) & 0xFF ; int fr = ( fcol > > 16 ) & 0xFF ; int fg = ( fcol > > 8 ) & 0xFF ; int fb = ( fcol > > 0 ) & 0xFF ; int acol = in . ambient [ i ] ; int aa = ( acol > > 24 ) & 0xFF ; int ar = ( acol > > 16 ) & 0xFF ; int ag = ( acol > > 8 ) & 0xFF ; int ab = ( acol > > 0 ) & 0xFF ; int scol = in . specular [ i ] ; int sa = ( scol > > 24 ) & 0xFF ; int sr = ( scol > > 16 ) & 0xFF ; int sg = ( scol > > 8 ) & 0xFF ; int sb = ( scol > > 0 ) & 0xFF ; int ecol = in . emissive [ i ] ; int ea = ( ecol > > 24 ) & 0xFF ; int er = ( ecol > > 16 ) & 0xFF ; int eg = ( ecol > > 8 ) & 0xFF ; int eb = ( ecol > > 0 ) & 0xFF ; float nx = in . normals [ 3 * i + 0 ] ; float ny = in . normals [ 3 * i + 1 ] ; float nz = in . normals [ 3 * i + 2 ] ; float u = in . texcoords [ 2 * i + 0 ] ; float v = in . texcoords [ 2 * i + 1 ] ; float sh = in . shininess [ i ] ; double [ ] vertex = new double [ ] { x , y , z , fa , fr , fg , fb , nx , ny , nz , u , v , aa , ar , ag , ab , sa , sr , sg , sb , ea , er , eg , eb , sh } ; double [ ] avect = in . getAttribVector ( i ) ; if ( 0 < avect . length ) { double temp [ ] = new double [ vertex . length + avect . length ] ; PApplet . arrayCopy ( vertex , 0 , temp , 0 , vertex . length ) ; PApplet . arrayCopy ( avect , 0 , temp , vertex . length , avect . length ) ; vertex = temp ; } gluTess . addVertex ( vertex ) ; } if ( stroke ) addStrokeVertex ( x , y , z , strokeColor , strokeWeight ) ; } void beginPolygonStroke ( ) { pathVertexCount = 0 ; if ( pathVertices == null ) { pathVertices = new float [ 3 * PGL . DEFAULT_IN_VERTICES ] ; pathColors = new int [ PGL . DEFAULT_IN_VERTICES ] ; pathWeights = new float [ PGL . DEFAULT_IN_VERTICES ] ; } } void endPolygonStroke ( ) { } void beginStrokePath ( ) { beginPath = pathVertexCount ; } void endStrokePath ( boolean closed ) { int idx = pathVertexCount ; if ( beginPath + 1 < idx ) { boolean begin = beginPath == idx - 2 ; boolean end = begin || ! closed ; in . addEdge ( idx - 2 , idx - 1 , begin , end ) ; if ( ! end ) { in . addEdge ( idx - 1 , beginPath , false , false ) ; in . closeEdge ( idx - 1 , beginPath ) ; } } } void addStrokeVertex ( float x , float y , float z , int c , float w ) { int idx = pathVertexCount ; if ( beginPath + 1 < idx ) { in . addEdge ( idx - 2 , idx - 1 , beginPath == idx - 2 , false ) ; } if ( pathVertexCount == pathVertices . length / 3 ) { int newSize = pathVertexCount < < 1 ; float vtemp [ ] = new float [ 3 * newSize ] ; PApplet . arrayCopy ( pathVertices , 0 , vtemp , 0 , 3 * pathVertexCount ) ; pathVertices = vtemp ; int ctemp [ ] = new int [ newSize ] ; PApplet . arrayCopy ( pathColors , 0 , ctemp , 0 , pathVertexCount ) ; pathColors = ctemp ; float wtemp [ ] = new float [ newSize ] ; PApplet . arrayCopy ( pathWeights , 0 , wtemp , 0 , pathVertexCount ) ; pathWeights = wtemp ; } pathVertices [ 3 * idx + 0 ] = x ; pathVertices [ 3 * idx + 1 ] = y ; pathVertices [ 3 * idx + 2 ] = z ; pathColors [ idx ] = c ; pathWeights [ idx ] = w ; pathVertexCount ++ ; } void tessellateStrokePath ( ) { if ( in . edgeCount == 0 ) return ; strokeVertices = pathVertices ; strokeColors = pathColors ; strokeWeights = pathWeights ; if ( is3D ) { tessellateEdges3D ( ) ; } else if ( is2D ) { beginNoTex ( ) ; tessellateEdges2D ( ) ; endNoTex ( ) ; } } boolean clampPolygon ( ) { return false ; } public void tessellateLinePath ( LinePath path ) { initGluTess ( ) ; boolean clamp = clampLinePath ( ) ; callback . init ( in . renderMode == RETAINED , true , false , clamp ) ; int cap = strokeCap == ROUND ? LinePath . CAP_ROUND : strokeCap == PROJECT ? LinePath . CAP_SQUARE : LinePath . CAP_BUTT ; int join = strokeJoin == ROUND ? LinePath . JOIN_ROUND : strokeJoin == BEVEL ? LinePath . JOIN_BEVEL : LinePath . JOIN_MITER ; LinePath strokedPath = LinePath . createStrokedPath ( path , strokeWeight , cap , join ) ; gluTess . beginPolygon ( ) ; double [ ] vertex ; float [ ] coords = new float [ 6 ] ; LinePath . PathIterator iter = strokedPath . getPathIterator ( ) ; int rule = iter . getWindingRule ( ) ; switch ( rule ) { case LinePath . WIND_EVEN_ODD : gluTess . setWindingRule ( PGL . TESS_WINDING_ODD ) ; break ; case LinePath . WIND_NON_ZERO : gluTess . setWindingRule ( PGL . TESS_WINDING_NONZERO ) ; break ; } while ( ! iter . isDone ( ) ) { switch ( iter . currentSegment ( coords ) ) { case LinePath . SEG_MOVETO : gluTess . beginContour ( ) ; case LinePath . SEG_LINETO : vertex = new double [ ] { coords [ 0 ] , coords [ 1 ] , 0 , coords [ 2 ] , coords [ 3 ] , coords [ 4 ] , coords [ 5 ] , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; gluTess . addVertex ( vertex ) ; break ; case LinePath . SEG_CLOSE : gluTess . endContour ( ) ; break ; } iter . next ( ) ; } gluTess . endPolygon ( ) ; } boolean clampLinePath ( ) { return clamp2D ( ) && strokeCap == PROJECT && strokeJoin == BEVEL && ! subPixelStroke ( strokeWeight ) ; } protected class TessellatorCallback implements PGL . TessellatorCallback { AttributeMap attribs ; boolean calcNormals ; boolean strokeTess ; boolean clampXY ; IndexCache cache ; int cacheIndex ; int vertFirst ; int vertCount ; int vertOffset ; int primitive ; public TessellatorCallback ( AttributeMap attribs ) { this . attribs = attribs ; } public void init ( boolean addCache , boolean strokeTess , boolean calcNorm , boolean clampXY ) { this . strokeTess = strokeTess ; this . calcNormals = calcNorm ; this . clampXY = clampXY ; cache = tess . polyIndexCache ; if ( addCache ) { cache . addNew ( ) ; } } public void begin ( int type ) { cacheIndex = cache . getLast ( ) ; if ( firstPolyIndexCache == - 1 ) { firstPolyIndexCache = cacheIndex ; } if ( strokeTess && firstLineIndexCache == - 1 ) { firstLineIndexCache = cacheIndex ; } vertFirst = cache . vertexCount [ cacheIndex ] ; vertOffset = cache . vertexOffset [ cacheIndex ] ; vertCount = 0 ; if ( type == PGL . TRIANGLE_FAN ) primitive = TRIANGLE_FAN ; else if ( type == PGL . TRIANGLE_STRIP ) primitive = TRIANGLE_STRIP ; else if ( type == PGL . TRIANGLES ) primitive = TRIANGLES ; } public void end ( ) { if ( PGL . MAX_VERTEX_INDEX1 <= vertFirst + vertCount ) { cacheIndex = cache . addNew ( ) ; vertFirst = cache . vertexCount [ cacheIndex ] ; vertOffset = cache . vertexOffset [ cacheIndex ] ; } int indCount = 0 ; switch ( primitive ) { case TRIANGLE_FAN : indCount = 3 * ( vertCount - 2 ) ; for ( int i = 1 ; i < vertCount - 1 ; i ++ ) { addIndex ( 0 ) ; addIndex ( i ) ; addIndex ( i + 1 ) ; if ( calcNormals ) calcTriNormal ( 0 , i , i + 1 ) ; } break ; case TRIANGLE_STRIP : indCount = 3 * ( vertCount - 2 ) ; for ( int i = 1 ; i < vertCount - 1 ; i ++ ) { if ( i % 2 == 0 ) { addIndex ( i + 1 ) ; addIndex ( i ) ; addIndex ( i - 1 ) ; if ( calcNormals ) calcTriNormal ( i + 1 , i , i - 1 ) ; } else { addIndex ( i - 1 ) ; addIndex ( i ) ; addIndex ( i + 1 ) ; if ( calcNormals ) calcTriNormal ( i - 1 , i , i + 1 ) ; } } break ; case TRIANGLES : indCount = vertCount ; for ( int i = 0 ; i < vertCount ; i ++ ) { addIndex ( i ) ; } if ( calcNormals ) { for ( int tr = 0 ; tr < vertCount / 3 ; tr ++ ) { int i0 = 3 * tr + 0 ; int i1 = 3 * tr + 1 ; int i2 = 3 * tr + 2 ; calcTriNormal ( i0 , i1 , i2 ) ; } } break ; } cache . incCounts ( cacheIndex , indCount , vertCount ) ; lastPolyIndexCache = cacheIndex ; if ( strokeTess ) { lastLineIndexCache = cacheIndex ; } } protected void addIndex ( int tessIdx ) { tess . polyIndexCheck ( ) ; tess . polyIndices [ tess . polyIndexCount - 1 ] = ( short ) ( vertFirst + tessIdx ) ; } protected void calcTriNormal ( int tessIdx0 , int tessIdx1 , int tessIdx2 ) { tess . calcPolyNormal ( vertFirst + vertOffset + tessIdx0 , vertFirst + vertOffset + tessIdx1 , vertFirst + vertOffset + tessIdx2 ) ; } public void vertex ( Object data ) { if ( data instanceof double [ ] ) { double [ ] d = ( double [ ] ) data ; int l = d . length ; if ( l < 25 ) { throw new RuntimeException ( "TessCallback vertex() data is " + "too small" ) ; } if ( vertCount < PGL . MAX_VERTEX_INDEX1 ) { tess . addPolyVertex ( d , clampXY ) ; vertCount ++ ; } else { throw new RuntimeException ( "The tessellator is generating too " + "many vertices, reduce complexity of " + "shape." ) ; } } else { throw new RuntimeException ( "TessCallback vertex() data not " + "understood" ) ; } } public void error ( int errnum ) { String estring = pg . pgl . tessError ( errnum ) ; PGraphics . showWarning ( TESSELLATION_ERROR , estring ) ; } public void combine ( double [ ] coords , Object [ ] data , float [ ] weight , Object [ ] outData ) { int n = ( ( double [ ] ) data [ 0 ] ) . length ; double [ ] vertex = new double [ n ] ; vertex [ 0 ] = coords [ 0 ] ; vertex [ 1 ] = coords [ 1 ] ; vertex [ 2 ] = coords [ 2 ] ; for ( int i = 3 ; i < n ; i ++ ) { vertex [ i ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { double [ ] vertData = ( double [ ] ) data [ j ] ; if ( vertData != null ) { vertex [ i ] += weight [ j ] * vertData [ i ] ; } } } normalize ( vertex , 7 ) ; if ( 25 < n ) { int pos = 25 ; for ( int i = 0 ; i < attribs . size ( ) ; i ++ ) { VertexAttribute attrib = attribs . get ( i ) ; if ( attrib . isNormal ( ) ) { normalize ( vertex , pos ) ; pos += 3 ; } else { pos += attrib . size ; } } } outData [ 0 ] = vertex ; } private void normalize ( double [ ] v , int i ) { double sum = v [ i ] * v [ i ] + v [ i + 1 ] * v [ i + 1 ] + v [ i + 2 ] * v [ i + 2 ] ; double len = Math . sqrt ( sum ) ; if ( 0 < len ) { v [ i ] /= len ; v [ i + 1 ] /= len ; v [ i + 2 ] /= len ; } } } } static protected class DepthSorter { static final int X = 0 ; static final int Y = 1 ; static final int Z = 2 ; static final int W = 3 ; int [ ] triangleIndices ; int [ ] texCacheMap ; int [ ] indexCacheMap ; float [ ] screenVertices ; int [ ] swapped ; int [ ] marked ; PGraphicsOpenGL pg ; TessGeometry tessGeo ; DepthSorter ( PGraphicsOpenGL pg ) { this . pg = pg ; int triangleCount = 256 ; triangleIndices = new int [ triangleCount ] ; texCacheMap = new int [ triangleCount ] ; indexCacheMap = new int [ triangleCount ] ; screenVertices = new float [ 9 * triangleCount ] ; swapped = new int [ 8 ] ; marked = new int [ 8 ] ; } void sort ( TessGeometry tessGeo ) { this . tessGeo = tessGeo ; int triangleCount = tessGeo . polyIndexCount / 3 ; { float [ ] polyVertices = tessGeo . polyVertices ; int polyVertexCount = tessGeo . polyVertexCount ; if ( screenVertices . length < 3 * polyVertexCount ) { screenVertices = new float [ 3 * polyVertexCount ] ; } for ( int i = 0 ; i < polyVertexCount ; i ++ ) { float x = polyVertices [ 4 * i + X ] ; float y = polyVertices [ 4 * i + Y ] ; float z = polyVertices [ 4 * i + Z ] ; float w = polyVertices [ 4 * i + W ] ; screenVertices [ 3 * i + X ] = pg . screenXImpl ( x , y , z , w ) ; screenVertices [ 3 * i + Y ] = pg . screenYImpl ( x , y , z , w ) ; screenVertices [ 3 * i + Z ] = - pg . screenZImpl ( x , y , z , w ) * ( pg . cameraFar - pg . cameraNear ) ; } } { for ( int i = 0 ; i < pg . texCache . size ; i ++ ) { int first = pg . texCache . firstCache [ i ] ; int last = pg . texCache . lastCache [ i ] ; IndexCache cache = tessGeo . polyIndexCache ; for ( int n = first ; n <= last ; n ++ ) { int ioffset = n == first ? pg . texCache . firstIndex [ i ] : cache . indexOffset [ n ] ; int icount = n == last ? pg . texCache . lastIndex [ i ] - ioffset + 1 : cache . indexOffset [ n ] + cache . indexCount [ n ] - ioffset ; for ( int tr = ioffset / 3 ; tr < ( ioffset + icount ) / 3 ; tr ++ ) { texCacheMap [ tr ] = i ; indexCacheMap [ tr ] = n ; } } } } { if ( triangleIndices . length < triangleCount ) { triangleIndices = new int [ triangleCount ] ; } for ( int i = 0 ; i < triangleCount ; i ++ ) { triangleIndices [ i ] = i ; } } sortByMinZ ( 0 , triangleCount - 1 ) ; int activeTid = 0 ; int markedCount = 0 ; while ( activeTid < triangleCount ) { int testTid = activeTid + 1 ; boolean draw = false ; int swappedCount = 0 ; while ( ! draw && testTid < triangleCount ) { int ati = triangleIndices [ activeTid ] ; int bti = triangleIndices [ testTid ] ; if ( maxCoord ( ati , Z ) <= minCoord ( bti , Z ) && ! contains ( marked , markedCount , triangleIndices [ testTid ] ) && ! contains ( marked , markedCount , triangleIndices [ activeTid ] ) ) { draw = true ; } else if ( maxCoord ( ati , X ) <= minCoord ( bti , X ) || maxCoord ( ati , Y ) <= minCoord ( bti , Y ) || minCoord ( ati , X ) >= maxCoord ( bti , X ) || minCoord ( ati , Y ) >= maxCoord ( bti , Y ) ) { testTid ++ ; } else if ( side ( bti , ati , - 1 ) > 0 ) { testTid ++ ; } else if ( side ( ati , bti , 1 ) > 0 ) { testTid ++ ; } else { rotateRight ( triangleIndices , activeTid , testTid ) ; marked = arrayCheck ( marked , markedCount , 1 ) ; if ( insert ( marked , markedCount , triangleIndices [ activeTid ] ) ) { markedCount ++ ; } swapped = arrayCheck ( swapped , swappedCount , 1 ) ; if ( insert ( swapped , swappedCount , triangleIndices [ activeTid ] ) ) { swappedCount ++ ; testTid = activeTid + 1 ; } else { draw = true ; } } } if ( remove ( marked , markedCount , activeTid ) ) { markedCount -- ; } if ( draw || testTid >= triangleCount ) { activeTid ++ ; } } } void sortByMinZ ( int leftTid , int rightTid ) { swap ( triangleIndices , leftTid , ( ( leftTid + rightTid ) / 2 ) ) ; int k = leftTid ; float leftMinZ = minCoord ( triangleIndices [ leftTid ] , Z ) ; for ( int tid = leftTid + 1 ; tid <= rightTid ; tid ++ ) { if ( minCoord ( triangleIndices [ tid ] , Z ) < leftMinZ ) { swap ( triangleIndices , ++ k , tid ) ; } } swap ( triangleIndices , leftTid , k ) ; if ( leftTid < k - 1 ) sortByMinZ ( leftTid , k - 1 ) ; if ( k + 1 < rightTid ) sortByMinZ ( k + 1 , rightTid ) ; } float minCoord ( int ti , int off ) { int voffset = tessGeo . polyIndexCache . vertexOffset [ indexCacheMap [ ti ] ] ; short [ ] is = tessGeo . polyIndices ; float [ ] vs = screenVertices ; int i0 = voffset + is [ 3 * ti + 0 ] ; int i1 = voffset + is [ 3 * ti + 1 ] ; int i2 = voffset + is [ 3 * ti + 2 ] ; return Math . min ( vs [ 3 * i0 + off ] , Math . min ( vs [ 3 * i1 + off ] , vs [ 3 * i2 + off ] ) ) ; } float maxCoord ( int ti , int off ) { int voffset = tessGeo . polyIndexCache . vertexOffset [ indexCacheMap [ ti ] ] ; short [ ] is = tessGeo . polyIndices ; float [ ] vs = screenVertices ; int i0 = voffset + is [ 3 * ti + 0 ] ; int i1 = voffset + is [ 3 * ti + 1 ] ; int i2 = voffset + is [ 3 * ti + 2 ] ; return Math . max ( vs [ 3 * i0 + off ] , Math . max ( vs [ 3 * i1 + off ] , vs [ 3 * i2 + off ] ) ) ; } int side ( int ti , int testTi , float tz ) { short [ ] is = tessGeo . polyIndices ; float [ ] vs = screenVertices ; int avoffset = tessGeo . polyIndexCache . vertexOffset [ indexCacheMap [ ti ] ] ; int bvoffset = tessGeo . polyIndexCache . vertexOffset [ indexCacheMap [ testTi ] ] ; int ia0 = avoffset + is [ 3 * ti + 0 ] ; int ia1 = avoffset + is [ 3 * ti + 1 ] ; int ia2 = avoffset + is [ 3 * ti + 2 ] ; int ib0 = bvoffset + is [ 3 * testTi + 0 ] ; int ib1 = bvoffset + is [ 3 * testTi + 1 ] ; int ib2 = bvoffset + is [ 3 * testTi + 2 ] ; float Dx , Dy , Dz , Dw ; { float ABx = vs [ 3 * ia1 + X ] - vs [ 3 * ia0 + X ] , ACx = vs [ 3 * ia2 + X ] - vs [ 3 * ia0 + X ] , ABy = vs [ 3 * ia1 + Y ] - vs [ 3 * ia0 + Y ] , ACy = vs [ 3 * ia2 + Y ] - vs [ 3 * ia0 + Y ] , ABz = vs [ 3 * ia1 + Z ] - vs [ 3 * ia0 + Z ] , ACz = vs [ 3 * ia2 + Z ] - vs [ 3 * ia0 + Z ] ; Dx = ABy * ACz - ABz * ACy ; Dy = ABz * ACx - ABx * ACz ; Dz = ABx * ACy - ABy * ACx ; float rMag = 1.0f / ( float ) Math . sqrt ( Dx * Dx + Dy * Dy + Dz * Dz ) ; Dx *= rMag ; Dy *= rMag ; Dz *= rMag ; Dw = - dot ( Dx , Dy , Dz , vs [ 3 * ia0 + X ] , vs [ 3 * ia0 + Y ] , vs [ 3 * ia0 + Z ] ) ; } float distTest = dot ( Dx , Dy , Dz , vs [ 3 * ia0 + X ] , vs [ 3 * ia0 + Y ] , vs [ 3 * ia0 + Z ] + 100 * tz ) + Dw ; float distA = dot ( Dx , Dy , Dz , vs [ 3 * ib0 + X ] , vs [ 3 * ib0 + Y ] , vs [ 3 * ib0 + Z ] ) + Dw ; float distB = dot ( Dx , Dy , Dz , vs [ 3 * ib1 + X ] , vs [ 3 * ib1 + Y ] , vs [ 3 * ib1 + Z ] ) + Dw ; float distC = dot ( Dx , Dy , Dz , vs [ 3 * ib2 + X ] , vs [ 3 * ib2 + Y ] , vs [ 3 * ib2 + Z ] ) + Dw ; { float maxDist = Math . max ( Math . abs ( distA ) , Math . max ( Math . abs ( distB ) , Math . abs ( distC ) ) ) ; float eps = maxDist * 0.1f ; if ( Math . abs ( distA ) < eps ) distA = 0.0f ; if ( Math . abs ( distB ) < eps ) distB = 0.0f ; if ( Math . abs ( distC ) < eps ) distC = 0.0f ; } float sideA = distA * distTest ; float sideB = distB * distTest ; float sideC = distC * distTest ; boolean sameSide = sideA >= 0 && sideB >= 0 && sideC >= 0 ; boolean notSameSide = sideA <= 0 && sideB <= 0 && sideC <= 0 ; return sameSide ? 1 : notSameSide ? - 1 : 0 ; } static float dot ( float a1 , float a2 , float a3 , float b1 , float b2 , float b3 ) { return a1 * b1 + a2 * b2 + a3 * b3 ; } static int [ ] arrayCheck ( int [ ] array , int size , int requested ) { if ( size + requested > array . length ) { int newLength = Math . max ( size + requested , 2 * array . length ) ; int [ ] temp = new int [ newLength ] ; PApplet . arrayCopy ( array , 0 , temp , 0 , size ) ; array = temp ; } return array ; } static void swap ( int [ ] array , int i1 , int i2 ) { int temp = array [ i1 ] ; array [ i1 ] = array [ i2 ] ; array [ i2 ] = temp ; } static void rotateRight ( int [ ] array , int i1 , int i2 ) { if ( i1 == i2 ) return ; int temp = array [ i2 ] ; if ( i2 - i1 < 100 ) { for ( int i = i2 ; i > i1 ; i -- ) { array [ i ] = array [ i - 1 ] ; } } else { PApplet . arrayCopy ( array , i1 , array , i2 , i2 - i1 ) ; } array [ i1 ] = temp ; } static boolean insert ( int [ ] array , int count , int value ) { int index = Arrays . binarySearch ( array , 0 , count , value ) ; if ( index >= 0 ) return false ; index = - ( index + 1 ) ; if ( count - index > 100 ) { System . arraycopy ( array , index , array , index + 1 , count - index ) ; } else { for ( int i = count ; i > index ; i -- ) { array [ i ] = array [ i - 1 ] ; } } array [ index ] = value ; return true ; } static boolean remove ( int [ ] array , int count , int value ) { int index = Arrays . binarySearch ( array , 0 , count , value ) ; if ( index < 0 ) return false ; if ( count - index > 100 ) { System . arraycopy ( array , index + 1 , array , index , count - index - 1 ) ; } else { for ( int i = index ; i < count - 1 ; i ++ ) { array [ i ] = array [ i + 1 ] ; } } return true ; } static boolean contains ( int [ ] array , int count , int value ) { return Arrays . binarySearch ( array , 0 , count , value ) >= 0 ; } } }
package processing . opengl ; import processing . core . PMatrix2D ; public class LinePath { public static final int WIND_EVEN_ODD = 0 ; public static final int WIND_NON_ZERO = 1 ; public static final byte SEG_MOVETO = 0 ; public static final byte SEG_LINETO = 1 ; public static final byte SEG_CLOSE = 2 ; public final static int JOIN_MITER = 0 ; public final static int JOIN_ROUND = 1 ; public final static int JOIN_BEVEL = 2 ; public final static int CAP_BUTT = 0 ; public final static int CAP_ROUND = 1 ; public final static int CAP_SQUARE = 2 ; private static PMatrix2D identity = new PMatrix2D ( ) ; private static float defaultMiterlimit = 10.0f ; static final int INIT_SIZE = 20 ; static final int EXPAND_MAX = 500 ; protected byte [ ] pointTypes ; protected float [ ] floatCoords ; protected int [ ] pointColors ; protected int numTypes ; protected int numCoords ; protected int windingRule ; public LinePath ( ) { this ( WIND_NON_ZERO , INIT_SIZE ) ; } public LinePath ( int rule ) { this ( rule , INIT_SIZE ) ; } public LinePath ( int rule , int initialCapacity ) { setWindingRule ( rule ) ; this . pointTypes = new byte [ initialCapacity ] ; floatCoords = new float [ initialCapacity * 2 ] ; pointColors = new int [ initialCapacity ] ; } void needRoom ( boolean needMove , int newPoints ) { if ( needMove && numTypes == 0 ) { throw new RuntimeException ( "missing initial moveto " + "in path definition" ) ; } int size = pointTypes . length ; if ( numTypes >= size ) { int grow = size ; if ( grow > EXPAND_MAX ) { grow = EXPAND_MAX ; } pointTypes = copyOf ( pointTypes , size + grow ) ; } size = floatCoords . length ; if ( numCoords + newPoints * 2 > size ) { int grow = size ; if ( grow > EXPAND_MAX * 2 ) { grow = EXPAND_MAX * 2 ; } if ( grow < newPoints * 2 ) { grow = newPoints * 2 ; } floatCoords = copyOf ( floatCoords , size + grow ) ; } size = pointColors . length ; if ( numCoords / 2 + newPoints > size ) { int grow = size ; if ( grow > EXPAND_MAX ) { grow = EXPAND_MAX ; } if ( grow < newPoints ) { grow = newPoints ; } pointColors = copyOf ( pointColors , size + grow ) ; } } public final void moveTo ( float x , float y , int c ) { if ( numTypes > 0 && pointTypes [ numTypes - 1 ] == SEG_MOVETO ) { floatCoords [ numCoords - 2 ] = x ; floatCoords [ numCoords - 1 ] = y ; pointColors [ numCoords / 2 - 1 ] = c ; } else { needRoom ( false , 1 ) ; pointTypes [ numTypes ++ ] = SEG_MOVETO ; floatCoords [ numCoords ++ ] = x ; floatCoords [ numCoords ++ ] = y ; pointColors [ numCoords / 2 - 1 ] = c ; } } public final void lineTo ( float x , float y , int c ) { needRoom ( true , 1 ) ; pointTypes [ numTypes ++ ] = SEG_LINETO ; floatCoords [ numCoords ++ ] = x ; floatCoords [ numCoords ++ ] = y ; pointColors [ numCoords / 2 - 1 ] = c ; } public PathIterator getPathIterator ( ) { return new PathIterator ( this ) ; } public final void closePath ( ) { if ( numTypes == 0 || pointTypes [ numTypes - 1 ] != SEG_CLOSE ) { needRoom ( false , 0 ) ; pointTypes [ numTypes ++ ] = SEG_CLOSE ; } } public final int getWindingRule ( ) { return windingRule ; } public final void setWindingRule ( int rule ) { if ( rule != WIND_EVEN_ODD && rule != WIND_NON_ZERO ) { throw new IllegalArgumentException ( "winding rule must be " + "WIND_EVEN_ODD or " + "WIND_NON_ZERO" ) ; } windingRule = rule ; } public final void reset ( ) { numTypes = numCoords = 0 ; } static public class PathIterator { float floatCoords [ ] ; int typeIdx ; int pointIdx ; int colorIdx ; LinePath path ; static final int curvecoords [ ] = { 2 , 2 , 0 } ; PathIterator ( LinePath p2df ) { this . path = p2df ; this . floatCoords = p2df . floatCoords ; pointIdx = 0 ; colorIdx = 0 ; } public int currentSegment ( float [ ] coords ) { int type = path . pointTypes [ typeIdx ] ; int numCoords = curvecoords [ type ] ; if ( numCoords > 0 ) { System . arraycopy ( floatCoords , pointIdx , coords , 0 , numCoords ) ; int color = path . pointColors [ colorIdx ] ; coords [ numCoords + 0 ] = ( color > > 24 ) & 0xFF ; coords [ numCoords + 1 ] = ( color > > 16 ) & 0xFF ; coords [ numCoords + 2 ] = ( color > > 8 ) & 0xFF ; coords [ numCoords + 3 ] = ( color > > 0 ) & 0xFF ; } return type ; } public int currentSegment ( double [ ] coords ) { int type = path . pointTypes [ typeIdx ] ; int numCoords = curvecoords [ type ] ; if ( numCoords > 0 ) { for ( int i = 0 ; i < numCoords ; i ++ ) { coords [ i ] = floatCoords [ pointIdx + i ] ; } int color = path . pointColors [ colorIdx ] ; coords [ numCoords + 0 ] = ( color > > 24 ) & 0xFF ; coords [ numCoords + 1 ] = ( color > > 16 ) & 0xFF ; coords [ numCoords + 2 ] = ( color > > 8 ) & 0xFF ; coords [ numCoords + 3 ] = ( color > > 0 ) & 0xFF ; } return type ; } public int getWindingRule ( ) { return path . getWindingRule ( ) ; } public boolean isDone ( ) { return ( typeIdx >= path . numTypes ) ; } public void next ( ) { int type = path . pointTypes [ typeIdx ++ ] ; if ( 0 < curvecoords [ type ] ) { pointIdx += curvecoords [ type ] ; colorIdx ++ ; } } } static public LinePath createStrokedPath ( LinePath src , float weight , int caps , int join ) { return createStrokedPath ( src , weight , caps , join , defaultMiterlimit , null ) ; } static public LinePath createStrokedPath ( LinePath src , float weight , int caps , int join , float miterlimit ) { return createStrokedPath ( src , weight , caps , join , miterlimit , null ) ; } static public LinePath createStrokedPath ( LinePath src , float weight , int caps , int join , float miterlimit , PMatrix2D transform ) { final LinePath dest = new LinePath ( ) ; strokeTo ( src , weight , caps , join , miterlimit , transform , new LineStroker ( ) { @ Override public void moveTo ( int x0 , int y0 , int c0 ) { dest . moveTo ( S15_16ToFloat ( x0 ) , S15_16ToFloat ( y0 ) , c0 ) ; } @ Override public void lineJoin ( ) { } @ Override public void lineTo ( int x1 , int y1 , int c1 ) { dest . lineTo ( S15_16ToFloat ( x1 ) , S15_16ToFloat ( y1 ) , c1 ) ; } @ Override public void close ( ) { dest . closePath ( ) ; } @ Override public void end ( ) { } } ) ; return dest ; } private static void strokeTo ( LinePath src , float width , int caps , int join , float miterlimit , PMatrix2D transform , LineStroker lsink ) { lsink = new LineStroker ( lsink , FloatToS15_16 ( width ) , caps , join , FloatToS15_16 ( miterlimit ) , transform == null ? identity : transform ) ; PathIterator pi = src . getPathIterator ( ) ; pathTo ( pi , lsink ) ; } private static void pathTo ( PathIterator pi , LineStroker lsink ) { float coords [ ] = new float [ 6 ] ; while ( ! pi . isDone ( ) ) { int color ; switch ( pi . currentSegment ( coords ) ) { case SEG_MOVETO : color = ( ( int ) coords [ 2 ] < < 24 ) | ( ( int ) coords [ 3 ] < < 16 ) | ( ( int ) coords [ 4 ] < < 8 ) | ( int ) coords [ 5 ] ; lsink . moveTo ( FloatToS15_16 ( coords [ 0 ] ) , FloatToS15_16 ( coords [ 1 ] ) , color ) ; break ; case SEG_LINETO : color = ( ( int ) coords [ 2 ] < < 24 ) | ( ( int ) coords [ 3 ] < < 16 ) | ( ( int ) coords [ 4 ] < < 8 ) | ( int ) coords [ 5 ] ; lsink . lineJoin ( ) ; lsink . lineTo ( FloatToS15_16 ( coords [ 0 ] ) , FloatToS15_16 ( coords [ 1 ] ) , color ) ; break ; case SEG_CLOSE : lsink . lineJoin ( ) ; lsink . close ( ) ; break ; default : throw new InternalError ( "unknown flattened segment type" ) ; } pi . next ( ) ; } lsink . end ( ) ; } public static float [ ] copyOf ( float [ ] source , int length ) { float [ ] target = new float [ length ] ; for ( int i = 0 ; i < target . length ; i ++ ) { if ( i > source . length - 1 ) target [ i ] = 0f ; else target [ i ] = source [ i ] ; } return target ; } public static byte [ ] copyOf ( byte [ ] source , int length ) { byte [ ] target = new byte [ length ] ; for ( int i = 0 ; i < target . length ; i ++ ) { if ( i > source . length - 1 ) target [ i ] = 0 ; else target [ i ] = source [ i ] ; } return target ; } public static int [ ] copyOf ( int [ ] source , int length ) { int [ ] target = new int [ length ] ; for ( int i = 0 ; i < target . length ; i ++ ) { if ( i > source . length - 1 ) target [ i ] = 0 ; else target [ i ] = source [ i ] ; } return target ; } public static int isqrt ( int x ) { int fracbits = 16 ; int root = 0 ; int remHi = 0 ; int remLo = x ; int count = 15 + fracbits / 2 ; do { remHi = ( remHi < < 2 ) | ( remLo > > > 30 ) ; remLo <<= 2 ; root <<= 1 ; int testdiv = ( root < < 1 ) + 1 ; if ( remHi >= testdiv ) { remHi -= testdiv ; root ++ ; } } while ( count -- != 0 ) ; return root ; } public static long lsqrt ( long x ) { int fracbits = 16 ; long root = 0 ; long remHi = 0 ; long remLo = x ; int count = 31 + fracbits / 2 ; do { remHi = ( remHi < < 2 ) | ( remLo > > > 62 ) ; remLo <<= 2 ; root <<= 1 ; long testDiv = ( root < < 1 ) + 1 ; if ( remHi >= testDiv ) { remHi -= testDiv ; root ++ ; } } while ( count -- != 0 ) ; return root ; } public static double hypot ( double x , double y ) { return Math . sqrt ( x * x + y * y ) ; } public static int hypot ( int x , int y ) { return ( int ) ( ( lsqrt ( ( long ) x * x + ( long ) y * y ) + 128 ) > > 8 ) ; } public static long hypot ( long x , long y ) { return ( lsqrt ( x * x + y * y ) + 128 ) > > 8 ; } static int FloatToS15_16 ( float flt ) { flt = flt * 65536f + 0.5f ; if ( flt <= - ( 65536f * 65536f ) ) { return Integer . MIN_VALUE ; } else if ( flt >= ( 65536f * 65536f ) ) { return Integer . MAX_VALUE ; } else { return ( int ) Math . floor ( flt ) ; } } static float S15_16ToFloat ( int fix ) { return ( fix / 65536f ) ; } }
package processing . opengl ; import processing . core . PApplet ; import processing . core . PConstants ; import processing . core . PFont ; import processing . core . PGraphics ; import processing . core . PImage ; import java . util . HashMap ; class FontTexture implements PConstants { protected PGL pgl ; protected boolean is3D ; protected int minSize ; protected int maxSize ; protected int offsetX ; protected int offsetY ; protected int lineHeight ; protected Texture [ ] textures = null ; protected PImage [ ] images = null ; protected int currentTex ; protected int lastTex ; protected TextureInfo [ ] glyphTexinfos ; protected HashMap < PFont . Glyph , TextureInfo > texinfoMap ; public FontTexture ( PGraphicsOpenGL pg , PFont font , boolean is3D ) { pgl = pg . pgl ; this . is3D = is3D ; initTexture ( pg , font ) ; } protected void allocate ( ) { } protected void dispose ( ) { for ( int i = 0 ; i < textures . length ; i ++ ) { textures [ i ] . dispose ( ) ; } } protected void initTexture ( PGraphicsOpenGL pg , PFont font ) { currentTex = - 1 ; lastTex = - 1 ; int spow = PGL . nextPowerOfTwo ( font . getSize ( ) ) ; minSize = PApplet . min ( PGraphicsOpenGL . maxTextureSize , PApplet . max ( PGL . MIN_FONT_TEX_SIZE , spow ) ) ; maxSize = PApplet . min ( PGraphicsOpenGL . maxTextureSize , PApplet . max ( PGL . MAX_FONT_TEX_SIZE , 2 * spow ) ) ; if ( maxSize < spow ) { PGraphics . showWarning ( "The font size is too large to be properly " + "displayed with OpenGL" ) ; } addTexture ( pg ) ; offsetX = 0 ; offsetY = 0 ; lineHeight = 0 ; texinfoMap = new HashMap < PFont . Glyph , TextureInfo > ( ) ; glyphTexinfos = new TextureInfo [ font . getGlyphCount ( ) ] ; addAllGlyphsToTexture ( pg , font ) ; } public boolean addTexture ( PGraphicsOpenGL pg ) { int w , h ; boolean resize ; w = maxSize ; if ( - 1 < currentTex && textures [ currentTex ] . glHeight < maxSize ) { h = PApplet . min ( 2 * textures [ currentTex ] . glHeight , maxSize ) ; resize = true ; } else { h = minSize ; resize = false ; } Texture tex ; if ( is3D ) { tex = new Texture ( pg , w , h , new Texture . Parameters ( ARGB , Texture . BILINEAR , false ) ) ; } else { tex = new Texture ( pg , w , h , new Texture . Parameters ( ARGB , Texture . LINEAR , false ) ) ; } if ( textures == null ) { textures = new Texture [ 1 ] ; textures [ 0 ] = tex ; images = new PImage [ 1 ] ; images [ 0 ] = pg . wrapTexture ( tex ) ; currentTex = 0 ; } else if ( resize ) { Texture tex0 = textures [ currentTex ] ; tex . pg . pushStyle ( ) ; tex . pg . blendMode ( REPLACE ) ; tex . put ( tex0 ) ; tex . pg . popStyle ( ) ; textures [ currentTex ] = tex ; pg . setCache ( images [ currentTex ] , tex ) ; images [ currentTex ] . width = tex . width ; images [ currentTex ] . height = tex . height ; } else { Texture [ ] tempTex = textures ; textures = new Texture [ textures . length + 1 ] ; PApplet . arrayCopy ( tempTex , textures , tempTex . length ) ; textures [ tempTex . length ] = tex ; currentTex = textures . length - 1 ; PImage [ ] tempImg = images ; images = new PImage [ textures . length ] ; PApplet . arrayCopy ( tempImg , images , tempImg . length ) ; images [ tempImg . length ] = pg . wrapTexture ( tex ) ; } lastTex = currentTex ; tex . bind ( ) ; return resize ; } public void begin ( ) { setTexture ( 0 ) ; } public void end ( ) { for ( int i = 0 ; i < textures . length ; i ++ ) { pgl . disableTexturing ( textures [ i ] . glTarget ) ; } } public void setTexture ( int idx ) { if ( 0 <= idx && idx < textures . length ) { currentTex = idx ; } } public PImage getTexture ( int idx ) { if ( 0 <= idx && idx < images . length ) { return images [ idx ] ; } return null ; } public PImage getCurrentTexture ( ) { return getTexture ( currentTex ) ; } public void addAllGlyphsToTexture ( PGraphicsOpenGL pg , PFont font ) { for ( int i = 0 ; i < font . getGlyphCount ( ) ; i ++ ) { addToTexture ( pg , i , font . getGlyph ( i ) ) ; } } public void updateGlyphsTexCoords ( ) { for ( int i = 0 ; i < glyphTexinfos . length ; i ++ ) { TextureInfo tinfo = glyphTexinfos [ i ] ; if ( tinfo != null && tinfo . texIndex == currentTex ) { tinfo . updateUV ( ) ; } } } public TextureInfo getTexInfo ( PFont . Glyph glyph ) { TextureInfo info = texinfoMap . get ( glyph ) ; return info ; } public TextureInfo addToTexture ( PGraphicsOpenGL pg , PFont . Glyph glyph ) { int n = glyphTexinfos . length ; if ( n == 0 ) { glyphTexinfos = new TextureInfo [ 1 ] ; } addToTexture ( pg , n , glyph ) ; return glyphTexinfos [ n ] ; } public boolean contextIsOutdated ( ) { boolean outdated = false ; for ( int i = 0 ; i < textures . length ; i ++ ) { if ( textures [ i ] . contextIsOutdated ( ) ) { outdated = true ; } } if ( outdated ) { for ( int i = 0 ; i < textures . length ; i ++ ) { PGraphicsOpenGL . removeTextureObject ( textures [ i ] . glName , textures [ i ] . context ) ; textures [ i ] . glName = 0 ; } } return outdated ; } protected void addToTexture ( PGraphicsOpenGL pg , int idx , PFont . Glyph glyph ) { int w = 1 + glyph . width + 1 ; int h = 1 + glyph . height + 1 ; int [ ] rgba = new int [ w * h ] ; int t = 0 ; int p = 0 ; if ( PGL . BIG_ENDIAN ) { java . util . Arrays . fill ( rgba , 0 , w , 0xFFFFFF00 ) ; t = w ; for ( int y = 0 ; y < glyph . height ; y ++ ) { rgba [ t ++ ] = 0xFFFFFF00 ; for ( int x = 0 ; x < glyph . width ; x ++ ) { rgba [ t ++ ] = 0xFFFFFF00 | glyph . image . pixels [ p ++ ] ; } rgba [ t ++ ] = 0xFFFFFF00 ; } java . util . Arrays . fill ( rgba , ( h - 1 ) * w , h * w , 0xFFFFFF00 ) ; } else { java . util . Arrays . fill ( rgba , 0 , w , 0x00FFFFFF ) ; t = w ; for ( int y = 0 ; y < glyph . height ; y ++ ) { rgba [ t ++ ] = 0x00FFFFFF ; for ( int x = 0 ; x < glyph . width ; x ++ ) { rgba [ t ++ ] = ( glyph . image . pixels [ p ++ ] < < 24 ) | 0x00FFFFFF ; } rgba [ t ++ ] = 0x00FFFFFF ; } java . util . Arrays . fill ( rgba , ( h - 1 ) * w , h * w , 0x00FFFFFF ) ; } if ( offsetX + w > textures [ currentTex ] . glWidth ) { offsetX = 0 ; offsetY += lineHeight ; lineHeight = 0 ; } lineHeight = Math . max ( lineHeight , h ) ; boolean resized = false ; if ( offsetY + lineHeight > textures [ currentTex ] . glHeight ) { resized = addTexture ( pg ) ; if ( resized ) { updateGlyphsTexCoords ( ) ; } else { offsetX = 0 ; offsetY = 0 ; lineHeight = 0 ; } } TextureInfo tinfo = new TextureInfo ( currentTex , offsetX , offsetY , w , h , rgba ) ; offsetX += w ; if ( idx == glyphTexinfos . length ) { TextureInfo [ ] temp = new TextureInfo [ glyphTexinfos . length + 1 ] ; System . arraycopy ( glyphTexinfos , 0 , temp , 0 , glyphTexinfos . length ) ; glyphTexinfos = temp ; } glyphTexinfos [ idx ] = tinfo ; texinfoMap . put ( glyph , tinfo ) ; } class TextureInfo { int texIndex ; int width ; int height ; int [ ] crop ; float u0 , u1 ; float v0 , v1 ; int [ ] pixels ; TextureInfo ( int tidx , int cropX , int cropY , int cropW , int cropH , int [ ] pix ) { texIndex = tidx ; crop = new int [ 4 ] ; crop [ 0 ] = cropX + 1 ; crop [ 1 ] = cropY + 1 + cropH - 2 ; crop [ 2 ] = cropW - 2 ; crop [ 3 ] = - cropH + 2 ; pixels = pix ; updateUV ( ) ; updateTex ( ) ; } void updateUV ( ) { width = textures [ texIndex ] . glWidth ; height = textures [ texIndex ] . glHeight ; u0 = ( float ) crop [ 0 ] / ( float ) width ; u1 = u0 + ( float ) crop [ 2 ] / ( float ) width ; v0 = ( float ) ( crop [ 1 ] + crop [ 3 ] ) / ( float ) height ; v1 = v0 - ( float ) crop [ 3 ] / ( float ) height ; } void updateTex ( ) { textures [ texIndex ] . setNative ( pixels , crop [ 0 ] - 1 , crop [ 1 ] + crop [ 3 ] - 1 , crop [ 2 ] + 2 , - crop [ 3 ] + 2 ) ; } } }
package processing . opengl ; import java . awt . Component ; import java . awt . GraphicsDevice ; import java . awt . GraphicsEnvironment ; import java . awt . Point ; import java . awt . Rectangle ; import java . util . ArrayList ; import java . util . List ; import com . jogamp . common . util . IOUtil . ClassResources ; import com . jogamp . nativewindow . NativeSurface ; import com . jogamp . nativewindow . ScalableSurface ; import com . jogamp . opengl . GLAnimatorControl ; import com . jogamp . opengl . GLAutoDrawable ; import com . jogamp . opengl . GLCapabilities ; import com . jogamp . opengl . GLEventListener ; import com . jogamp . opengl . GLException ; import com . jogamp . opengl . GLProfile ; import com . jogamp . nativewindow . MutableGraphicsConfiguration ; import com . jogamp . newt . Display ; import com . jogamp . newt . MonitorDevice ; import com . jogamp . newt . NewtFactory ; import com . jogamp . newt . Screen ; import com . jogamp . newt . awt . NewtCanvasAWT ; import com . jogamp . newt . event . InputEvent ; import com . jogamp . newt . opengl . GLWindow ; import com . jogamp . opengl . util . FPSAnimator ; import processing . core . PApplet ; import processing . core . PConstants ; import processing . core . PGraphics ; import processing . core . PImage ; import processing . core . PSurface ; import processing . event . KeyEvent ; import processing . event . MouseEvent ; import processing . opengl . PGraphicsOpenGL ; import processing . opengl . PGL ; public class PSurfaceJOGL implements PSurface { public static GLProfile profile ; PJOGL pgl ; GLWindow window ; FPSAnimator animator ; Rectangle screenRect ; PApplet sketch ; PGraphics graphics ; int sketchX ; int sketchY ; int sketchWidth ; int sketchHeight ; Display display ; Screen screen ; List < MonitorDevice > monitors ; MonitorDevice displayDevice ; Throwable drawException ; Object waitObject = new Object ( ) ; NewtCanvasAWT canvas ; float [ ] currentPixelScale = { 0 , 0 } ; boolean presentMode = false ; float offsetX ; float offsetY ; public PSurfaceJOGL ( PGraphics graphics ) { this . graphics = graphics ; this . pgl = ( PJOGL ) ( ( PGraphicsOpenGL ) graphics ) . pgl ; } public void initOffscreen ( PApplet sketch ) { this . sketch = sketch ; sketchWidth = sketch . sketchWidth ( ) ; sketchHeight = sketch . sketchHeight ( ) ; if ( window != null ) { canvas = new NewtCanvasAWT ( window ) ; canvas . setBounds ( 0 , 0 , window . getWidth ( ) , window . getHeight ( ) ) ; canvas . setFocusable ( true ) ; } } public void initFrame ( PApplet sketch ) { this . sketch = sketch ; initIcons ( ) ; initScreen ( ) ; initGL ( ) ; initWindow ( ) ; initListeners ( ) ; initAnimator ( ) ; window . setVisible ( true ) ; } protected void initScreen ( ) { display = NewtFactory . createDisplay ( null ) ; display . addReference ( ) ; screen = NewtFactory . createScreen ( display , 0 ) ; screen . addReference ( ) ; monitors = new ArrayList < MonitorDevice > ( ) ; GraphicsEnvironment environment = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice [ ] devices = environment . getScreenDevices ( ) ; for ( GraphicsDevice device : devices ) { String did = device . getIDstring ( ) ; String [ ] parts = did . split ( "Display" ) ; String id1 = "" ; if ( 1 < parts . length ) { id1 = parts [ 1 ] . trim ( ) ; } MonitorDevice monitor = null ; for ( int i = 0 ; i < screen . getMonitorDevices ( ) . size ( ) ; i ++ ) { MonitorDevice mon = screen . getMonitorDevices ( ) . get ( i ) ; String mid = String . valueOf ( mon . getId ( ) ) ; if ( id1 . equals ( mid ) ) { monitor = mon ; break ; } } if ( monitor == null ) { for ( int i = 0 ; i < screen . getMonitorDevices ( ) . size ( ) ; i ++ ) { MonitorDevice mon = screen . getMonitorDevices ( ) . get ( i ) ; String mid = String . valueOf ( mon . getId ( ) ) ; if ( - 1 < did . indexOf ( mid ) ) { monitor = mon ; break ; } } } if ( monitor != null ) { monitors . add ( monitor ) ; } } } protected void initGL ( ) { if ( profile == null ) { if ( PJOGL . PROFILE == 2 ) { try { profile = GLProfile . getGL2ES1 ( ) ; } catch ( GLException ex ) { profile = GLProfile . getMaxFixedFunc ( true ) ; } } else if ( PJOGL . PROFILE == 3 ) { try { profile = GLProfile . getGL2GL3 ( ) ; } catch ( GLException ex ) { profile = GLProfile . getMaxProgrammable ( true ) ; } if ( ! profile . isGL3 ( ) ) { PGraphics . showWarning ( "Requested profile GL3 but is not available, got: " + profile ) ; } } else if ( PJOGL . PROFILE == 4 ) { try { profile = GLProfile . getGL4ES3 ( ) ; } catch ( GLException ex ) { profile = GLProfile . getMaxProgrammable ( true ) ; } if ( ! profile . isGL4 ( ) ) { PGraphics . showWarning ( "Requested profile GL4 but is not available, got: " + profile ) ; } } else throw new RuntimeException ( PGL . UNSUPPORTED_GLPROF_ERROR ) ; } GLCapabilities caps = new GLCapabilities ( profile ) ; caps . setAlphaBits ( PGL . REQUESTED_ALPHA_BITS ) ; caps . setDepthBits ( PGL . REQUESTED_DEPTH_BITS ) ; caps . setStencilBits ( PGL . REQUESTED_STENCIL_BITS ) ; pgl . reqNumSamples = PGL . smoothToSamples ( graphics . smooth ) ; caps . setSampleBuffers ( true ) ; caps . setNumSamples ( pgl . reqNumSamples ) ; caps . setBackgroundOpaque ( true ) ; caps . setOnscreen ( true ) ; pgl . capabilities = caps ; } protected void initWindow ( ) { window = GLWindow . create ( screen , pgl . capabilities ) ; if ( displayDevice == null ) { displayDevice = window . getMainMonitor ( ) ; } int displayNum = sketch . sketchDisplay ( ) ; if ( displayNum > 0 ) { if ( displayNum <= monitors . size ( ) ) { displayDevice = monitors . get ( displayNum - 1 ) ; } else { System . err . format ( "Display %d does not exist, " + "using the default display instead.%n" , displayNum ) ; for ( int i = 0 ; i < monitors . size ( ) ; i ++ ) { System . err . format ( "Display %d is %s%n" , i + 1 , monitors . get ( i ) ) ; } } } boolean spanDisplays = sketch . sketchDisplay ( ) == PConstants . SPAN ; screenRect = spanDisplays ? new Rectangle ( 0 , 0 , screen . getWidth ( ) , screen . getHeight ( ) ) : new Rectangle ( 0 , 0 , displayDevice . getViewportInWindowUnits ( ) . getWidth ( ) , displayDevice . getViewportInWindowUnits ( ) . getHeight ( ) ) ; sketch . displayWidth = screenRect . width ; sketch . displayHeight = screenRect . height ; sketchWidth = sketch . sketchWidth ( ) ; sketchHeight = sketch . sketchHeight ( ) ; boolean fullScreen = sketch . sketchFullScreen ( ) ; if ( screenRect . width == sketchWidth && screenRect . height == sketchHeight ) { fullScreen = true ; sketch . fullScreen ( ) ; } if ( fullScreen || spanDisplays ) { sketchWidth = screenRect . width ; sketchHeight = screenRect . height ; } float [ ] reqSurfacePixelScale ; if ( graphics . is2X ( ) ) { reqSurfacePixelScale = new float [ ] { ScalableSurface . AUTOMAX_PIXELSCALE , ScalableSurface . AUTOMAX_PIXELSCALE } ; } else { reqSurfacePixelScale = new float [ ] { ScalableSurface . IDENTITY_PIXELSCALE , ScalableSurface . IDENTITY_PIXELSCALE } ; } window . setSurfaceScale ( reqSurfacePixelScale ) ; window . setSize ( sketchWidth , sketchHeight ) ; setSize ( sketchWidth , sketchHeight ) ; sketchX = displayDevice . getViewportInWindowUnits ( ) . getX ( ) ; sketchY = displayDevice . getViewportInWindowUnits ( ) . getY ( ) ; if ( fullScreen ) { PApplet . hideMenuBar ( ) ; window . setTopLevelPosition ( sketchX , sketchY ) ; if ( spanDisplays ) { window . setFullscreen ( monitors ) ; } else { window . setFullscreen ( true ) ; } } } protected void initListeners ( ) { NEWTMouseListener mouseListener = new NEWTMouseListener ( ) ; window . addMouseListener ( mouseListener ) ; NEWTKeyListener keyListener = new NEWTKeyListener ( ) ; window . addKeyListener ( keyListener ) ; NEWTWindowListener winListener = new NEWTWindowListener ( ) ; window . addWindowListener ( winListener ) ; DrawListener drawlistener = new DrawListener ( ) ; window . addGLEventListener ( drawlistener ) ; } protected void initAnimator ( ) { animator = new FPSAnimator ( window , 60 ) ; drawException = null ; animator . setUncaughtExceptionHandler ( new GLAnimatorControl . UncaughtExceptionHandler ( ) { @ Override public void uncaughtException ( final GLAnimatorControl animator , final GLAutoDrawable drawable , final Throwable cause ) { synchronized ( waitObject ) { drawException = cause ; waitObject . notify ( ) ; } } } ) ; new Thread ( new Runnable ( ) { public void run ( ) { synchronized ( waitObject ) { try { if ( drawException == null ) waitObject . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } if ( drawException != null ) { Throwable cause = drawException . getCause ( ) ; if ( cause instanceof ThreadDeath ) { } else if ( cause instanceof RuntimeException ) { throw ( RuntimeException ) cause ; } else { throw new RuntimeException ( cause ) ; } } } } } ) . start ( ) ; } @ Override public void setTitle ( String title ) { window . setTitle ( title ) ; } @ Override public void setVisible ( boolean visible ) { window . setVisible ( visible ) ; } @ Override public void setResizable ( boolean resizable ) { } private void setFrameCentered ( ) { int sketchX = displayDevice . getViewportInWindowUnits ( ) . getX ( ) ; int sketchY = displayDevice . getViewportInWindowUnits ( ) . getY ( ) ; int w = sketchWidth ; int h = sketchHeight ; window . setTopLevelPosition ( sketchX + screenRect . x + ( screenRect . width - w ) / 2 , sketchY + screenRect . y + ( screenRect . height - h ) / 2 ) ; } @ Override public void placeWindow ( int [ ] location , int [ ] editorLocation ) { int x = window . getX ( ) - window . getInsets ( ) . getLeftWidth ( ) ; int y = window . getY ( ) - window . getInsets ( ) . getTopHeight ( ) ; int w = window . getWidth ( ) + window . getInsets ( ) . getTotalWidth ( ) ; int h = window . getHeight ( ) + window . getInsets ( ) . getTotalHeight ( ) ; if ( location != null ) { window . setTopLevelPosition ( location [ 0 ] , location [ 1 ] ) ; } else if ( editorLocation != null ) { int locationX = editorLocation [ 0 ] - 20 ; int locationY = editorLocation [ 1 ] ; if ( locationX - w > 10 ) { window . setTopLevelPosition ( locationX - w , locationY ) ; } else { locationX = editorLocation [ 0 ] + 66 ; locationY = editorLocation [ 1 ] + 66 ; if ( ( locationX + w > sketch . displayWidth - 33 ) || ( locationY + h > sketch . displayHeight - 33 ) ) { locationX = ( sketch . displayWidth - w ) / 2 ; locationY = ( sketch . displayHeight - h ) / 2 ; } window . setTopLevelPosition ( locationX , locationY ) ; } } else { setFrameCentered ( ) ; } Point frameLoc = new Point ( x , y ) ; if ( frameLoc . y < 0 ) { window . setTopLevelPosition ( frameLoc . x , 30 ) ; } } public void placePresent ( int stopColor ) { presentMode = pgl . presentMode = true ; offsetX = pgl . offsetX = 0.5f * ( screenRect . width - sketchWidth ) ; offsetY = pgl . offsetY = 0.5f * ( screenRect . height - sketchHeight ) ; pgl . requestFBOLayer ( ) ; window . setSize ( screenRect . width , screenRect . height ) ; PApplet . hideMenuBar ( ) ; window . setTopLevelPosition ( sketchX + screenRect . x , sketchY + screenRect . y ) ; window . setFullscreen ( true ) ; } protected void initIcons ( ) { final int [ ] sizes = { 16 , 32 , 48 , 64 , 128 , 256 , 512 } ; String [ ] iconImages = new String [ sizes . length ] ; for ( int i = 0 ; i < sizes . length ; i ++ ) { iconImages [ i ] = "/icon/icon-" + sizes [ i ] + ".png" ; } NewtFactory . setWindowIcons ( new ClassResources ( PApplet . class , iconImages ) ) ; } public void setupExternalMessages ( ) { } public void startThread ( ) { if ( animator != null ) { animator . start ( ) ; if ( 0 < sketchX && 0 < sketchY ) { window . setTopLevelPosition ( sketchX , sketchY ) ; sketchX = sketchY = 0 ; } } } public void pauseThread ( ) { if ( animator != null ) { animator . pause ( ) ; } } public void resumeThread ( ) { if ( animator != null ) { animator . resume ( ) ; } } public boolean stopThread ( ) { if ( animator != null ) { return animator . stop ( ) ; } else { return false ; } } public boolean isStopped ( ) { if ( animator != null ) { return ! animator . isAnimating ( ) ; } else { return true ; } } public void setSize ( int width , int height ) { if ( width == sketch . width && height == sketch . height ) { return ; } if ( ! presentMode ) { sketch . setSize ( width , height ) ; sketchWidth = width ; sketchHeight = height ; graphics . setSize ( width , height ) ; } } public float getPixelScale ( ) { if ( graphics . is2X ( ) ) { window . getCurrentSurfaceScale ( currentPixelScale ) ; return currentPixelScale [ 0 ] ; } else { return 1 ; } } public Component getComponent ( ) { return canvas ; } public void setSmooth ( int level ) { pgl . reqNumSamples = level ; GLCapabilities caps = new GLCapabilities ( profile ) ; caps . setAlphaBits ( PGL . REQUESTED_ALPHA_BITS ) ; caps . setDepthBits ( PGL . REQUESTED_DEPTH_BITS ) ; caps . setStencilBits ( PGL . REQUESTED_STENCIL_BITS ) ; caps . setSampleBuffers ( true ) ; caps . setNumSamples ( pgl . reqNumSamples ) ; caps . setBackgroundOpaque ( true ) ; caps . setOnscreen ( true ) ; NativeSurface target = window . getNativeSurface ( ) ; MutableGraphicsConfiguration config = ( MutableGraphicsConfiguration ) target . getGraphicsConfiguration ( ) ; config . setChosenCapabilities ( caps ) ; } public void setFrameRate ( float fps ) { if ( animator != null ) { animator . stop ( ) ; animator . setFPS ( ( int ) fps ) ; pgl . setFps ( fps ) ; animator . start ( ) ; } } public void requestFocus ( ) { window . requestFocus ( ) ; } class DrawListener implements GLEventListener { public void display ( GLAutoDrawable drawable ) { pgl . getGL ( drawable ) ; sketch . handleDraw ( ) ; if ( sketch . frameCount == 1 ) { requestFocus ( ) ; } if ( sketch . exitCalled ( ) ) { animator . stop ( ) ; sketch . dispose ( ) ; sketch . exitActual ( ) ; } } public void dispose ( GLAutoDrawable drawable ) { sketch . dispose ( ) ; } public void init ( GLAutoDrawable drawable ) { pgl . getGL ( drawable ) ; pgl . init ( drawable ) ; sketch . start ( ) ; int c = graphics . backgroundColor ; pgl . clearColor ( ( ( c > > 16 ) & 0xff ) / 255f , ( ( c > > 8 ) & 0xff ) / 255f , ( ( c > > 0 ) & 0xff ) / 255f , ( ( c > > 24 ) & 0xff ) / 255f ) ; pgl . clear ( PGL . COLOR_BUFFER_BIT ) ; } public void reshape ( GLAutoDrawable drawable , int x , int y , int w , int h ) { window . getCurrentSurfaceScale ( currentPixelScale ) ; pgl . getGL ( drawable ) ; setSize ( ( int ) ( w / currentPixelScale [ 0 ] ) , ( int ) ( h / currentPixelScale [ 1 ] ) ) ; } } protected class NEWTWindowListener implements com . jogamp . newt . event . WindowListener { public NEWTWindowListener ( ) { super ( ) ; } @ Override public void windowGainedFocus ( com . jogamp . newt . event . WindowEvent arg0 ) { } @ Override public void windowLostFocus ( com . jogamp . newt . event . WindowEvent arg0 ) { } @ Override public void windowDestroyNotify ( com . jogamp . newt . event . WindowEvent arg0 ) { PSurfaceJOGL . this . sketch . dispose ( ) ; PSurfaceJOGL . this . sketch . exitActual ( ) ; } @ Override public void windowDestroyed ( com . jogamp . newt . event . WindowEvent arg0 ) { } @ Override public void windowMoved ( com . jogamp . newt . event . WindowEvent arg0 ) { } @ Override public void windowRepaint ( com . jogamp . newt . event . WindowUpdateEvent arg0 ) { } @ Override public void windowResized ( com . jogamp . newt . event . WindowEvent arg0 ) { } } protected class NEWTMouseListener extends com . jogamp . newt . event . MouseAdapter { public NEWTMouseListener ( ) { super ( ) ; } @ Override public void mousePressed ( com . jogamp . newt . event . MouseEvent e ) { nativeMouseEvent ( e , MouseEvent . PRESS ) ; } @ Override public void mouseReleased ( com . jogamp . newt . event . MouseEvent e ) { nativeMouseEvent ( e , MouseEvent . RELEASE ) ; } @ Override public void mouseClicked ( com . jogamp . newt . event . MouseEvent e ) { nativeMouseEvent ( e , MouseEvent . CLICK ) ; } @ Override public void mouseDragged ( com . jogamp . newt . event . MouseEvent e ) { nativeMouseEvent ( e , MouseEvent . DRAG ) ; } @ Override public void mouseMoved ( com . jogamp . newt . event . MouseEvent e ) { nativeMouseEvent ( e , MouseEvent . MOVE ) ; } @ Override public void mouseWheelMoved ( com . jogamp . newt . event . MouseEvent e ) { nativeMouseEvent ( e , MouseEvent . WHEEL ) ; } @ Override public void mouseEntered ( com . jogamp . newt . event . MouseEvent e ) { nativeMouseEvent ( e , MouseEvent . ENTER ) ; } @ Override public void mouseExited ( com . jogamp . newt . event . MouseEvent e ) { nativeMouseEvent ( e , MouseEvent . EXIT ) ; } } protected class NEWTKeyListener extends com . jogamp . newt . event . KeyAdapter { public NEWTKeyListener ( ) { super ( ) ; } @ Override public void keyPressed ( com . jogamp . newt . event . KeyEvent e ) { nativeKeyEvent ( e , KeyEvent . PRESS ) ; } @ Override public void keyReleased ( com . jogamp . newt . event . KeyEvent e ) { nativeKeyEvent ( e , KeyEvent . RELEASE ) ; } public void keyTyped ( com . jogamp . newt . event . KeyEvent e ) { nativeKeyEvent ( e , KeyEvent . TYPE ) ; } } protected void nativeMouseEvent ( com . jogamp . newt . event . MouseEvent nativeEvent , int peAction ) { int modifiers = nativeEvent . getModifiers ( ) ; int peModifiers = modifiers & ( InputEvent . SHIFT_MASK | InputEvent . CTRL_MASK | InputEvent . META_MASK | InputEvent . ALT_MASK ) ; int peButton = 0 ; if ( ( modifiers & InputEvent . BUTTON1_MASK ) != 0 ) { peButton = PConstants . LEFT ; } else if ( ( modifiers & InputEvent . BUTTON2_MASK ) != 0 ) { peButton = PConstants . CENTER ; } else if ( ( modifiers & InputEvent . BUTTON3_MASK ) != 0 ) { peButton = PConstants . RIGHT ; } if ( PApplet . platform == PConstants . MACOSX ) { if ( ( modifiers & InputEvent . CTRL_MASK ) != 0 ) { peButton = PConstants . RIGHT ; } } int peCount = 0 ; if ( peAction == MouseEvent . WHEEL ) { peCount = nativeEvent . isShiftDown ( ) ? ( int ) nativeEvent . getRotation ( ) [ 0 ] : ( int ) nativeEvent . getRotation ( ) [ 1 ] ; } else { peCount = nativeEvent . getClickCount ( ) ; } window . getCurrentSurfaceScale ( currentPixelScale ) ; int sx = ( int ) ( nativeEvent . getX ( ) / currentPixelScale [ 0 ] ) ; int sy = ( int ) ( nativeEvent . getY ( ) / currentPixelScale [ 1 ] ) ; int mx = sx - ( int ) offsetX ; int my = sy - ( int ) offsetY ; if ( presentMode ) { if ( peAction == KeyEvent . RELEASE && 20 < sx && sx < 20 + 100 && screenRect . height - 70 < sy && sy < screenRect . height - 20 ) { sketch . exit ( ) ; } if ( mx < 0 || sketchWidth < mx || my < 0 || sketchHeight < my ) { return ; } } MouseEvent me = new MouseEvent ( nativeEvent , nativeEvent . getWhen ( ) , peAction , peModifiers , mx , my , peButton , peCount ) ; sketch . postEvent ( me ) ; } protected void nativeKeyEvent ( com . jogamp . newt . event . KeyEvent nativeEvent , int peAction ) { int peModifiers = nativeEvent . getModifiers ( ) & ( InputEvent . SHIFT_MASK | InputEvent . CTRL_MASK | InputEvent . META_MASK | InputEvent . ALT_MASK ) ; short code = nativeEvent . getKeyCode ( ) ; char keyChar ; int keyCode ; if ( isPCodedKey ( code ) ) { keyCode = mapToPConst ( code ) ; keyChar = PConstants . CODED ; } else if ( isHackyKey ( code ) ) { keyCode = code ; keyChar = hackToChar ( code , nativeEvent . getKeyChar ( ) ) ; } else { keyCode = code ; keyChar = nativeEvent . getKeyChar ( ) ; } KeyEvent ke = new KeyEvent ( nativeEvent , nativeEvent . getWhen ( ) , peAction , peModifiers , keyChar , keyCode ) ; sketch . postEvent ( ke ) ; } private static boolean isPCodedKey ( short code ) { return code == com . jogamp . newt . event . KeyEvent . VK_UP || code == com . jogamp . newt . event . KeyEvent . VK_DOWN || code == com . jogamp . newt . event . KeyEvent . VK_LEFT || code == com . jogamp . newt . event . KeyEvent . VK_RIGHT || code == com . jogamp . newt . event . KeyEvent . VK_ALT || code == com . jogamp . newt . event . KeyEvent . VK_CONTROL || code == com . jogamp . newt . event . KeyEvent . VK_SHIFT || code == com . jogamp . newt . event . KeyEvent . VK_WINDOWS ; } private static int mapToPConst ( short code ) { if ( code == com . jogamp . newt . event . KeyEvent . VK_UP ) { return PConstants . UP ; } else if ( code == com . jogamp . newt . event . KeyEvent . VK_DOWN ) { return PConstants . DOWN ; } else if ( code == com . jogamp . newt . event . KeyEvent . VK_LEFT ) { return PConstants . LEFT ; } else if ( code == com . jogamp . newt . event . KeyEvent . VK_RIGHT ) { return PConstants . RIGHT ; } else if ( code == com . jogamp . newt . event . KeyEvent . VK_ALT ) { return PConstants . ALT ; } else if ( code == com . jogamp . newt . event . KeyEvent . VK_CONTROL ) { return PConstants . CONTROL ; } else if ( code == com . jogamp . newt . event . KeyEvent . VK_SHIFT ) { return PConstants . SHIFT ; } else if ( code == com . jogamp . newt . event . KeyEvent . VK_WINDOWS ) { return java . awt . event . KeyEvent . VK_META ; } return code ; } private static boolean isHackyKey ( short code ) { return code == com . jogamp . newt . event . KeyEvent . VK_BACK_SPACE || code == com . jogamp . newt . event . KeyEvent . VK_TAB ; } private static char hackToChar ( short code , char def ) { if ( code == com . jogamp . newt . event . KeyEvent . VK_BACK_SPACE ) { return '\b' ; } else if ( code == com . jogamp . newt . event . KeyEvent . VK_TAB ) { return '\t' ; } return def ; } public void setCursor ( int kind ) { System . err . println ( "Cursor types not supported in OpenGL, provide your cursor image" ) ; } public void setCursor ( PImage image , int hotspotX , int hotspotY ) { final Display disp = window . getScreen ( ) . getDisplay ( ) ; disp . createNative ( ) ; } public void showCursor ( ) { window . setPointerVisible ( true ) ; } public void hideCursor ( ) { window . setPointerVisible ( false ) ; } }
package processing . opengl ; import processing . core . PGraphics ; import processing . core . PMatrix3D ; import processing . core . PShape ; import processing . core . PShapeSVG ; public class PGraphics2D extends PGraphicsOpenGL { public PGraphics2D ( ) { super ( ) ; } @ Override public boolean is2D ( ) { return true ; } @ Override public boolean is3D ( ) { return false ; } @ Override public void hint ( int which ) { if ( which == ENABLE_STROKE_PERSPECTIVE ) { showWarning ( "Strokes cannot be perspective-corrected in 2D." ) ; return ; } super . hint ( which ) ; } @ Override public void ortho ( ) { showMethodWarning ( "ortho" ) ; } @ Override public void ortho ( float left , float right , float bottom , float top ) { showMethodWarning ( "ortho" ) ; } @ Override public void ortho ( float left , float right , float bottom , float top , float near , float far ) { showMethodWarning ( "ortho" ) ; } @ Override public void perspective ( ) { showMethodWarning ( "perspective" ) ; } @ Override public void perspective ( float fov , float aspect , float zNear , float zFar ) { showMethodWarning ( "perspective" ) ; } @ Override public void frustum ( float left , float right , float bottom , float top , float znear , float zfar ) { showMethodWarning ( "frustum" ) ; } @ Override protected void defaultPerspective ( ) { super . ortho ( 0 , width , - height , 0 , - 1 , + 1 ) ; } @ Override public void beginCamera ( ) { showMethodWarning ( "beginCamera" ) ; } @ Override public void endCamera ( ) { showMethodWarning ( "endCamera" ) ; } @ Override public void camera ( ) { showMethodWarning ( "camera" ) ; } @ Override public void camera ( float eyeX , float eyeY , float eyeZ , float centerX , float centerY , float centerZ , float upX , float upY , float upZ ) { showMethodWarning ( "camera" ) ; } @ Override protected void defaultCamera ( ) { eyeDist = 1 ; resetMatrix ( ) ; } @ Override protected void begin2D ( ) { pushProjection ( ) ; defaultPerspective ( ) ; pushMatrix ( ) ; defaultCamera ( ) ; } @ Override protected void end2D ( ) { popMatrix ( ) ; popProjection ( ) ; } @ Override public void shape ( PShape shape ) { if ( shape . is2D ( ) ) { super . shape ( shape ) ; } else { showWarning ( "The shape object is not 2D, cannot be displayed with " + "this renderer" ) ; } } @ Override public void shape ( PShape shape , float x , float y ) { if ( shape . is2D ( ) ) { super . shape ( shape , x , y ) ; } else { showWarning ( "The shape object is not 2D, cannot be displayed with " + "this renderer" ) ; } } @ Override public void shape ( PShape shape , float a , float b , float c , float d ) { if ( shape . is2D ( ) ) { super . shape ( shape , a , b , c , d ) ; } else { showWarning ( "The shape object is not 2D, cannot be displayed with " + "this renderer" ) ; } } @ Override public void shape ( PShape shape , float x , float y , float z ) { showDepthWarningXYZ ( "shape" ) ; } @ Override public void shape ( PShape shape , float x , float y , float z , float c , float d , float e ) { showDepthWarningXYZ ( "shape" ) ; } static protected boolean isSupportedExtension ( String extension ) { return extension . equals ( "svg" ) || extension . equals ( "svgz" ) ; } static protected PShape loadShapeImpl ( PGraphics pg , String filename , String extension ) { if ( extension . equals ( "svg" ) || extension . equals ( "svgz" ) ) { PShapeSVG svg = new PShapeSVG ( pg . parent . loadXML ( filename ) ) ; return PShapeOpenGL . createShape ( ( PGraphicsOpenGL ) pg , svg ) ; } return null ; } @ Override public void bezierVertex ( float x2 , float y2 , float z2 , float x3 , float y3 , float z3 , float x4 , float y4 , float z4 ) { showDepthWarningXYZ ( "bezierVertex" ) ; } @ Override public void quadraticVertex ( float x2 , float y2 , float z2 , float x4 , float y4 , float z4 ) { showDepthWarningXYZ ( "quadVertex" ) ; } @ Override public void curveVertex ( float x , float y , float z ) { showDepthWarningXYZ ( "curveVertex" ) ; } @ Override public void box ( float w , float h , float d ) { showMethodWarning ( "box" ) ; } @ Override public void sphere ( float r ) { showMethodWarning ( "sphere" ) ; } @ Override public void vertex ( float x , float y , float z ) { showDepthWarningXYZ ( "vertex" ) ; } @ Override public void vertex ( float x , float y , float z , float u , float v ) { showDepthWarningXYZ ( "vertex" ) ; } @ Override public void translate ( float tx , float ty , float tz ) { showDepthWarningXYZ ( "translate" ) ; } @ Override public void rotateX ( float angle ) { showDepthWarning ( "rotateX" ) ; } @ Override public void rotateY ( float angle ) { showDepthWarning ( "rotateY" ) ; } @ Override public void rotateZ ( float angle ) { showDepthWarning ( "rotateZ" ) ; } @ Override public void rotate ( float angle , float vx , float vy , float vz ) { showVariationWarning ( "rotate" ) ; } @ Override public void applyMatrix ( PMatrix3D source ) { showVariationWarning ( "applyMatrix" ) ; } @ Override public void applyMatrix ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { showVariationWarning ( "applyMatrix" ) ; } @ Override public void scale ( float sx , float sy , float sz ) { showDepthWarningXYZ ( "scale" ) ; } @ Override public float screenX ( float x , float y , float z ) { showDepthWarningXYZ ( "screenX" ) ; return 0 ; } @ Override public float screenY ( float x , float y , float z ) { showDepthWarningXYZ ( "screenY" ) ; return 0 ; } @ Override public float screenZ ( float x , float y , float z ) { showDepthWarningXYZ ( "screenZ" ) ; return 0 ; } @ Override public PMatrix3D getMatrix ( PMatrix3D target ) { showVariationWarning ( "getMatrix" ) ; return target ; } @ Override public void setMatrix ( PMatrix3D source ) { showVariationWarning ( "setMatrix" ) ; } @ Override public void lights ( ) { showMethodWarning ( "lights" ) ; } @ Override public void noLights ( ) { showMethodWarning ( "noLights" ) ; } @ Override public void ambientLight ( float red , float green , float blue ) { showMethodWarning ( "ambientLight" ) ; } @ Override public void ambientLight ( float red , float green , float blue , float x , float y , float z ) { showMethodWarning ( "ambientLight" ) ; } @ Override public void directionalLight ( float red , float green , float blue , float nx , float ny , float nz ) { showMethodWarning ( "directionalLight" ) ; } @ Override public void pointLight ( float red , float green , float blue , float x , float y , float z ) { showMethodWarning ( "pointLight" ) ; } @ Override public void spotLight ( float red , float green , float blue , float x , float y , float z , float nx , float ny , float nz , float angle , float concentration ) { showMethodWarning ( "spotLight" ) ; } @ Override public void lightFalloff ( float constant , float linear , float quadratic ) { showMethodWarning ( "lightFalloff" ) ; } @ Override public void lightSpecular ( float v1 , float v2 , float v3 ) { showMethodWarning ( "lightSpecular" ) ; } }
package processing . opengl ; import processing . core . PApplet ; import processing . core . PConstants ; import processing . core . PGraphics ; import java . lang . reflect . Method ; import java . nio . ByteBuffer ; import java . nio . IntBuffer ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . NoSuchElementException ; public class Texture implements PConstants { protected static final int TEX2D = 0 ; protected static final int TEXRECT = 1 ; protected static final int POINT = 2 ; protected static final int LINEAR = 3 ; protected static final int BILINEAR = 4 ; protected static final int TRILINEAR = 5 ; protected static final int MAX_UPDATES = 10 ; protected static final int MIN_MEMORY = 5 ; public int width , height ; public int glName ; public int glTarget ; public int glFormat ; public int glMinFilter ; public int glMagFilter ; public int glWrapS ; public int glWrapT ; public int glWidth ; public int glHeight ; protected PGraphicsOpenGL pg ; protected PGL pgl ; protected int context ; protected boolean colorBuffer ; protected boolean usingMipmaps ; protected boolean usingRepeat ; protected float maxTexcoordU ; protected float maxTexcoordV ; protected boolean bound ; protected boolean invertedX ; protected boolean invertedY ; protected int [ ] rgbaPixels = null ; protected IntBuffer pixelBuffer = null ; protected int [ ] edgePixels = null ; protected IntBuffer edgeBuffer = null ; protected FrameBuffer tempFbo = null ; protected int pixBufUpdateCount = 0 ; protected int rgbaPixUpdateCount = 0 ; protected boolean modified ; protected int mx1 , my1 , mx2 , my2 ; protected Object bufferSource ; protected LinkedList < BufferData > bufferCache = null ; protected LinkedList < BufferData > usedBuffers = null ; protected Method disposeBufferMethod ; public static final int MAX_BUFFER_CACHE_SIZE = 3 ; public Texture ( PGraphicsOpenGL pg ) { this . pg = pg ; pgl = pg . pgl ; context = pgl . createEmptyContext ( ) ; colorBuffer = false ; glName = 0 ; } public Texture ( PGraphicsOpenGL pg , int width , int height ) { this ( pg , width , height , new Parameters ( ) ) ; } public Texture ( PGraphicsOpenGL pg , int width , int height , Object params ) { this . pg = pg ; pgl = pg . pgl ; context = pgl . createEmptyContext ( ) ; colorBuffer = false ; glName = 0 ; init ( width , height , ( Parameters ) params ) ; } @ Override protected void finalize ( ) throws Throwable { try { if ( glName != 0 ) { PGraphicsOpenGL . finalizeTextureObject ( glName , context ) ; } } finally { super . finalize ( ) ; } } public void init ( int width , int height ) { Parameters params ; if ( 0 < glName ) { params = getParameters ( ) ; } else { params = new Parameters ( ) ; } init ( width , height , params ) ; } public void init ( int width , int height , Parameters params ) { setParameters ( params ) ; setSize ( width , height ) ; allocate ( ) ; } public void init ( int width , int height , int glName , int glTarget , int glFormat , int glWidth , int glHeight , int glMinFilter , int glMagFilter , int glWrapS , int glWrapT ) { this . width = width ; this . height = height ; this . glName = glName ; this . glTarget = glTarget ; this . glFormat = glFormat ; this . glWidth = glWidth ; this . glHeight = glHeight ; this . glMinFilter = glMinFilter ; this . glMagFilter = glMagFilter ; this . glWrapS = glWrapS ; this . glWrapT = glWrapT ; maxTexcoordU = ( float ) width / glWidth ; maxTexcoordV = ( float ) height / glHeight ; usingMipmaps = glMinFilter == PGL . LINEAR_MIPMAP_NEAREST || glMinFilter == PGL . LINEAR_MIPMAP_LINEAR ; usingRepeat = glWrapS == PGL . REPEAT || glWrapT == PGL . REPEAT ; } public void resize ( int wide , int high ) { dispose ( ) ; Texture tex = new Texture ( pg , wide , high , getParameters ( ) ) ; tex . set ( this ) ; copyObject ( tex ) ; tempFbo = null ; } public boolean available ( ) { return 0 < glName ; } public void set ( Texture tex ) { copyTexture ( tex , 0 , 0 , tex . width , tex . height , true ) ; } public void set ( Texture tex , int x , int y , int w , int h ) { copyTexture ( tex , x , y , w , h , true ) ; } public void set ( int texTarget , int texName , int texWidth , int texHeight , int w , int h ) { copyTexture ( texTarget , texName , texWidth , texHeight , 0 , 0 , w , h , true ) ; } public void set ( int texTarget , int texName , int texWidth , int texHeight , int target , int tex , int x , int y , int w , int h ) { copyTexture ( texTarget , texName , texWidth , texHeight , x , y , w , h , true ) ; } public void set ( int [ ] pixels ) { set ( pixels , 0 , 0 , width , height , ARGB ) ; } public void set ( int [ ] pixels , int format ) { set ( pixels , 0 , 0 , width , height , format ) ; } public void set ( int [ ] pixels , int x , int y , int w , int h ) { set ( pixels , x , y , w , h , ARGB ) ; } public void set ( int [ ] pixels , int x , int y , int w , int h , int format ) { if ( pixels == null ) { PGraphics . showWarning ( "The pixels array is null." ) ; return ; } if ( pixels . length < w * h ) { PGraphics . showWarning ( "The pixel array has a length of " + pixels . length + ", but it should be at least " + w * h ) ; return ; } if ( pixels . length == 0 || w == 0 || h == 0 ) { return ; } boolean enabledTex = false ; if ( ! pgl . texturingIsEnabled ( glTarget ) ) { pgl . enableTexturing ( glTarget ) ; enabledTex = true ; } pgl . bindTexture ( glTarget , glName ) ; loadPixels ( w * h ) ; convertToRGBA ( pixels , format , w , h ) ; updatePixelBuffer ( rgbaPixels ) ; pgl . texSubImage2D ( glTarget , 0 , x , y , w , h , PGL . RGBA , PGL . UNSIGNED_BYTE , pixelBuffer ) ; fillEdges ( x , y , w , h ) ; if ( usingMipmaps ) { if ( PGraphicsOpenGL . autoMipmapGenSupported ) { pgl . generateMipmap ( glTarget ) ; } else { manualMipmap ( ) ; } } pgl . bindTexture ( glTarget , 0 ) ; if ( enabledTex ) { pgl . disableTexturing ( glTarget ) ; } releasePixelBuffer ( ) ; releaseRGBAPixels ( ) ; updateTexels ( x , y , w , h ) ; } public void setNative ( int [ ] pixels ) { setNative ( pixels , 0 , 0 , width , height ) ; } public void setNative ( int [ ] pixels , int x , int y , int w , int h ) { updatePixelBuffer ( pixels ) ; setNative ( pixelBuffer , x , y , w , h ) ; releasePixelBuffer ( ) ; } public void setNative ( IntBuffer pixBuf , int x , int y , int w , int h ) { if ( pixBuf == null ) { pixBuf = null ; PGraphics . showWarning ( "The pixel buffer is null." ) ; return ; } if ( pixBuf . capacity ( ) < w * h ) { PGraphics . showWarning ( "The pixel bufer has a length of " + pixBuf . capacity ( ) + ", but it should be at least " + w * h ) ; return ; } if ( pixBuf . capacity ( ) == 0 ) { return ; } boolean enabledTex = false ; if ( ! pgl . texturingIsEnabled ( glTarget ) ) { pgl . enableTexturing ( glTarget ) ; enabledTex = true ; } pgl . bindTexture ( glTarget , glName ) ; pgl . texSubImage2D ( glTarget , 0 , x , y , w , h , PGL . RGBA , PGL . UNSIGNED_BYTE , pixBuf ) ; fillEdges ( x , y , w , h ) ; if ( usingMipmaps ) { if ( PGraphicsOpenGL . autoMipmapGenSupported ) { pgl . generateMipmap ( glTarget ) ; } else { manualMipmap ( ) ; } } pgl . bindTexture ( glTarget , 0 ) ; if ( enabledTex ) { pgl . disableTexturing ( glTarget ) ; } updateTexels ( x , y , w , h ) ; } public void get ( int [ ] pixels ) { if ( pixels == null ) { throw new RuntimeException ( "Trying to copy texture to null pixels array" ) ; } if ( pixels . length != width * height ) { throw new RuntimeException ( "Trying to copy texture to pixels array of " + "wrong size" ) ; } if ( tempFbo == null ) { tempFbo = new FrameBuffer ( pg , glWidth , glHeight ) ; } tempFbo . setColorBuffer ( this ) ; pg . pushFramebuffer ( ) ; pg . setFramebuffer ( tempFbo ) ; tempFbo . readPixels ( ) ; pg . popFramebuffer ( ) ; tempFbo . getPixels ( pixels ) ; convertToARGB ( pixels ) ; if ( invertedX ) flipArrayOnX ( pixels , 1 ) ; if ( invertedY ) flipArrayOnY ( pixels , 1 ) ; } public void put ( Texture tex ) { copyTexture ( tex , 0 , 0 , tex . width , tex . height , false ) ; } public void put ( Texture tex , int x , int y , int w , int h ) { copyTexture ( tex , x , y , w , h , false ) ; } public void put ( int texTarget , int texName , int texWidth , int texHeight , int w , int h ) { copyTexture ( texTarget , texName , texWidth , texHeight , 0 , 0 , w , h , false ) ; } public void put ( int texTarget , int texName , int texWidth , int texHeight , int target , int tex , int x , int y , int w , int h ) { copyTexture ( texTarget , texName , texWidth , texHeight , x , y , w , h , false ) ; } public boolean usingMipmaps ( ) { return usingMipmaps ; } public void usingMipmaps ( boolean mipmaps , int sampling ) { int glMagFilter0 = glMagFilter ; int glMinFilter0 = glMinFilter ; if ( mipmaps ) { if ( sampling == POINT ) { glMagFilter = PGL . NEAREST ; glMinFilter = PGL . NEAREST ; usingMipmaps = false ; } else if ( sampling == LINEAR ) { glMagFilter = PGL . NEAREST ; glMinFilter = PGL . MIPMAPS_ENABLED ? PGL . LINEAR_MIPMAP_NEAREST : PGL . LINEAR ; usingMipmaps = true ; } else if ( sampling == BILINEAR ) { glMagFilter = PGL . LINEAR ; glMinFilter = PGL . MIPMAPS_ENABLED ? PGL . LINEAR_MIPMAP_NEAREST : PGL . LINEAR ; usingMipmaps = true ; } else if ( sampling == TRILINEAR ) { glMagFilter = PGL . LINEAR ; glMinFilter = PGL . MIPMAPS_ENABLED ? PGL . LINEAR_MIPMAP_LINEAR : PGL . LINEAR ; usingMipmaps = true ; } else { throw new RuntimeException ( "Unknown texture filtering mode" ) ; } } else { usingMipmaps = false ; if ( sampling == POINT ) { glMagFilter = PGL . NEAREST ; glMinFilter = PGL . NEAREST ; } else if ( sampling == LINEAR ) { glMagFilter = PGL . NEAREST ; glMinFilter = PGL . LINEAR ; } else if ( sampling == BILINEAR || sampling == TRILINEAR ) { glMagFilter = PGL . LINEAR ; glMinFilter = PGL . LINEAR ; } else { throw new RuntimeException ( "Unknown texture filtering mode" ) ; } } if ( glMagFilter0 != glMagFilter || glMinFilter0 != glMinFilter ) { bind ( ) ; pgl . texParameteri ( glTarget , PGL . TEXTURE_MIN_FILTER , glMinFilter ) ; pgl . texParameteri ( glTarget , PGL . TEXTURE_MAG_FILTER , glMagFilter ) ; if ( usingMipmaps ) { if ( PGraphicsOpenGL . autoMipmapGenSupported ) { pgl . generateMipmap ( glTarget ) ; } else { manualMipmap ( ) ; } } unbind ( ) ; } } public boolean usingRepeat ( ) { return usingRepeat ; } public void usingRepeat ( boolean repeat ) { if ( repeat ) { glWrapS = PGL . REPEAT ; glWrapT = PGL . REPEAT ; usingRepeat = true ; } else { glWrapS = PGL . CLAMP_TO_EDGE ; glWrapT = PGL . CLAMP_TO_EDGE ; usingRepeat = false ; } bind ( ) ; pgl . texParameteri ( glTarget , PGL . TEXTURE_WRAP_S , glWrapS ) ; pgl . texParameteri ( glTarget , PGL . TEXTURE_WRAP_T , glWrapT ) ; unbind ( ) ; } public float maxTexcoordU ( ) { return maxTexcoordU ; } public float maxTexcoordV ( ) { return maxTexcoordV ; } public boolean invertedX ( ) { return invertedX ; } public void invertedX ( boolean v ) { invertedX = v ; } public boolean invertedY ( ) { return invertedY ; } public void invertedY ( boolean v ) { invertedY = v ; } public int currentSampling ( ) { if ( glMagFilter == PGL . NEAREST && glMinFilter == PGL . NEAREST ) { return POINT ; } else if ( glMagFilter == PGL . NEAREST && glMinFilter == ( PGL . MIPMAPS_ENABLED ? PGL . LINEAR_MIPMAP_NEAREST : PGL . LINEAR ) ) { return LINEAR ; } else if ( glMagFilter == PGL . LINEAR && glMinFilter == ( PGL . MIPMAPS_ENABLED ? PGL . LINEAR_MIPMAP_NEAREST : PGL . LINEAR ) ) { return BILINEAR ; } else if ( glMagFilter == PGL . LINEAR && glMinFilter == PGL . LINEAR_MIPMAP_LINEAR ) { return TRILINEAR ; } else { return - 1 ; } } public void bind ( ) { if ( ! pgl . texturingIsEnabled ( glTarget ) ) { pgl . enableTexturing ( glTarget ) ; } pgl . bindTexture ( glTarget , glName ) ; bound = true ; } public void unbind ( ) { if ( pgl . textureIsBound ( glTarget , glName ) ) { if ( ! pgl . texturingIsEnabled ( glTarget ) ) { pgl . enableTexturing ( glTarget ) ; pgl . bindTexture ( glTarget , 0 ) ; pgl . disableTexturing ( glTarget ) ; } else { pgl . bindTexture ( glTarget , 0 ) ; } } bound = false ; } public boolean bound ( ) { return bound ; } public boolean isModified ( ) { return modified ; } public void setModified ( ) { modified = true ; } public void setModified ( boolean m ) { modified = m ; } public int getModifiedX1 ( ) { return mx1 ; } public int getModifiedX2 ( ) { return mx2 ; } public int getModifiedY1 ( ) { return my1 ; } public int getModifiedY2 ( ) { return my2 ; } public void updateTexels ( ) { updateTexelsImpl ( 0 , 0 , width , height ) ; } public void updateTexels ( int x , int y , int w , int h ) { updateTexelsImpl ( x , y , w , h ) ; } protected void updateTexelsImpl ( int x , int y , int w , int h ) { int x2 = x + w ; int y2 = y + h ; if ( ! modified ) { mx1 = PApplet . max ( 0 , x ) ; mx2 = PApplet . min ( width - 1 , x2 ) ; my1 = PApplet . max ( 0 , y ) ; my2 = PApplet . min ( height - 1 , y2 ) ; modified = true ; } else { if ( x < mx1 ) mx1 = PApplet . max ( 0 , x ) ; if ( x > mx2 ) mx2 = PApplet . min ( width - 1 , x ) ; if ( y < my1 ) my1 = PApplet . max ( 0 , y ) ; if ( y > my2 ) my2 = y ; if ( x2 < mx1 ) mx1 = PApplet . max ( 0 , x2 ) ; if ( x2 > mx2 ) mx2 = PApplet . min ( width - 1 , x2 ) ; if ( y2 < my1 ) my1 = PApplet . max ( 0 , y2 ) ; if ( y2 > my2 ) my2 = PApplet . min ( height - 1 , y2 ) ; } } protected void loadPixels ( int len ) { if ( rgbaPixels == null || rgbaPixels . length < len ) { rgbaPixels = new int [ len ] ; } } protected void updatePixelBuffer ( int [ ] pixels ) { pixelBuffer = PGL . updateIntBuffer ( pixelBuffer , pixels , true ) ; pixBufUpdateCount ++ ; } protected void manualMipmap ( ) { } public void setBufferSource ( Object source ) { bufferSource = source ; getSourceMethods ( ) ; } public void copyBufferFromSource ( Object natRef , ByteBuffer byteBuf , int w , int h ) { if ( bufferCache == null ) { bufferCache = new LinkedList < BufferData > ( ) ; } if ( bufferCache . size ( ) + 1 <= MAX_BUFFER_CACHE_SIZE ) { bufferCache . add ( new BufferData ( natRef , byteBuf . asIntBuffer ( ) , w , h ) ) ; } else { try { usedBuffers . add ( new BufferData ( natRef , byteBuf . asIntBuffer ( ) , w , h ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void disposeSourceBuffer ( ) { if ( usedBuffers == null ) return ; while ( 0 < usedBuffers . size ( ) ) { BufferData data = null ; try { data = usedBuffers . remove ( 0 ) ; } catch ( NoSuchElementException ex ) { PGraphics . showWarning ( "Cannot remove used buffer" ) ; } if ( data != null ) { data . dispose ( ) ; } } } public void getBufferPixels ( int [ ] pixels ) { BufferData data = null ; if ( usedBuffers != null && 0 < usedBuffers . size ( ) ) { data = usedBuffers . getLast ( ) ; } else if ( bufferCache != null && 0 < bufferCache . size ( ) ) { data = bufferCache . getLast ( ) ; } if ( data != null ) { if ( ( data . w != width ) || ( data . h != height ) ) { init ( data . w , data . h ) ; } data . rgbBuf . rewind ( ) ; data . rgbBuf . get ( pixels ) ; convertToARGB ( pixels ) ; if ( usedBuffers == null ) { usedBuffers = new LinkedList < BufferData > ( ) ; } while ( 0 < bufferCache . size ( ) ) { data = bufferCache . remove ( 0 ) ; usedBuffers . add ( data ) ; } } } public boolean hasBufferSource ( ) { return bufferSource != null ; } public boolean hasBuffers ( ) { return bufferSource != null && bufferCache != null && 0 < bufferCache . size ( ) ; } protected boolean bufferUpdate ( ) { BufferData data = null ; try { data = bufferCache . remove ( 0 ) ; } catch ( NoSuchElementException ex ) { PGraphics . showWarning ( "Don't have pixel data to copy to texture" ) ; } if ( data != null ) { if ( ( data . w != width ) || ( data . h != height ) ) { init ( data . w , data . h ) ; } data . rgbBuf . rewind ( ) ; setNative ( data . rgbBuf , 0 , 0 , width , height ) ; if ( usedBuffers == null ) { usedBuffers = new LinkedList < BufferData > ( ) ; } usedBuffers . add ( data ) ; return true ; } else { return false ; } } protected void getSourceMethods ( ) { try { disposeBufferMethod = bufferSource . getClass ( ) . getMethod ( "disposeBuffer" , new Class [ ] { Object . class } ) ; } catch ( Exception e ) { throw new RuntimeException ( "Provided source object doesn't have a " + "disposeBuffer method." ) ; } } protected void flipArrayOnX ( int [ ] intArray , int mult ) { int index = 0 ; int xindex = mult * ( width - 1 ) ; for ( int x = 0 ; x < width / 2 ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { int i = index + mult * y * width ; int j = xindex + mult * y * width ; for ( int c = 0 ; c < mult ; c ++ ) { int temp = intArray [ i ] ; intArray [ i ] = intArray [ j ] ; intArray [ j ] = temp ; i ++ ; j ++ ; } } index += mult ; xindex -= mult ; } } protected void flipArrayOnY ( int [ ] intArray , int mult ) { int index = 0 ; int yindex = mult * ( height - 1 ) * width ; for ( int y = 0 ; y < height / 2 ; y ++ ) { for ( int x = 0 ; x < mult * width ; x ++ ) { int temp = intArray [ index ] ; intArray [ index ] = intArray [ yindex ] ; intArray [ yindex ] = temp ; index ++ ; yindex ++ ; } yindex -= mult * width * 2 ; } } protected void convertToRGBA ( int [ ] pixels , int format , int w , int h ) { if ( PGL . BIG_ENDIAN ) { switch ( format ) { case ALPHA : for ( int i = 0 ; i < pixels . length ; i ++ ) { rgbaPixels [ i ] = 0xFFFFFF00 | pixels [ i ] ; } break ; case RGB : for ( int i = 0 ; i < pixels . length ; i ++ ) { int pixel = pixels [ i ] ; rgbaPixels [ i ] = ( pixel < < 8 ) | 0xFF ; } break ; case ARGB : for ( int i = 0 ; i < pixels . length ; i ++ ) { int pixel = pixels [ i ] ; rgbaPixels [ i ] = ( pixel < < 8 ) | ( ( pixel > > 24 ) & 0xFF ) ; } break ; } } else { switch ( format ) { case ALPHA : for ( int i = 0 ; i < pixels . length ; i ++ ) { rgbaPixels [ i ] = ( pixels [ i ] < < 24 ) | 0x00FFFFFF ; } break ; case RGB : for ( int i = 0 ; i < pixels . length ; i ++ ) { int pixel = pixels [ i ] ; rgbaPixels [ i ] = 0xFF000000 | ( ( pixel & 0xFF ) < < 16 ) | ( ( pixel & 0xFF0000 ) > > 16 ) | ( pixel & 0x0000FF00 ) ; } break ; case ARGB : for ( int i = 0 ; i < pixels . length ; i ++ ) { int pixel = pixels [ i ] ; rgbaPixels [ i ] = ( ( pixel & 0xFF ) < < 16 ) | ( ( pixel & 0xFF0000 ) > > 16 ) | ( pixel & 0xFF00FF00 ) ; } break ; } } rgbaPixUpdateCount ++ ; } protected void convertToARGB ( int [ ] pixels ) { int t = 0 ; int p = 0 ; if ( PGL . BIG_ENDIAN ) { for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { int pixel = pixels [ p ++ ] ; pixels [ t ++ ] = ( pixel > > > 8 ) | ( ( pixel < < 24 ) & 0xFF000000 ) ; } } } else { for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { int pixel = pixels [ p ++ ] ; pixels [ t ++ ] = ( ( pixel & 0xFF ) < < 16 ) | ( ( pixel & 0xFF0000 ) > > 16 ) | ( pixel & 0xFF00FF00 ) ; } } } } protected void setSize ( int w , int h ) { width = w ; height = h ; if ( PGraphicsOpenGL . npotTexSupported ) { glWidth = w ; glHeight = h ; } else { glWidth = PGL . nextPowerOfTwo ( w ) ; glHeight = PGL . nextPowerOfTwo ( h ) ; } if ( glWidth > PGraphicsOpenGL . maxTextureSize || glHeight > PGraphicsOpenGL . maxTextureSize ) { glWidth = glHeight = 0 ; throw new RuntimeException ( "Image width and height cannot be" + " larger than " + PGraphicsOpenGL . maxTextureSize + " with this graphics card." ) ; } maxTexcoordU = ( float ) width / glWidth ; maxTexcoordV = ( float ) height / glHeight ; } protected void allocate ( ) { dispose ( ) ; boolean enabledTex = false ; if ( ! pgl . texturingIsEnabled ( glTarget ) ) { pgl . enableTexturing ( glTarget ) ; enabledTex = true ; } context = pgl . getCurrentContext ( ) ; glName = PGraphicsOpenGL . createTextureObject ( context , pgl ) ; pgl . bindTexture ( glTarget , glName ) ; pgl . texParameteri ( glTarget , PGL . TEXTURE_MIN_FILTER , glMinFilter ) ; pgl . texParameteri ( glTarget , PGL . TEXTURE_MAG_FILTER , glMagFilter ) ; pgl . texParameteri ( glTarget , PGL . TEXTURE_WRAP_S , glWrapS ) ; pgl . texParameteri ( glTarget , PGL . TEXTURE_WRAP_T , glWrapT ) ; if ( PGraphicsOpenGL . anisoSamplingSupported ) { pgl . texParameterf ( glTarget , PGL . TEXTURE_MAX_ANISOTROPY , PGraphicsOpenGL . maxAnisoAmount ) ; } pgl . texImage2D ( glTarget , 0 , glFormat , glWidth , glHeight , 0 , PGL . RGBA , PGL . UNSIGNED_BYTE , null ) ; pgl . initTexture ( glTarget , PGL . RGBA , width , height ) ; pgl . bindTexture ( glTarget , 0 ) ; if ( enabledTex ) { pgl . disableTexturing ( glTarget ) ; } bound = false ; } protected void dispose ( ) { if ( glName != 0 ) { PGraphicsOpenGL . finalizeTextureObject ( glName , context ) ; glName = 0 ; } } protected boolean contextIsOutdated ( ) { boolean outdated = ! pgl . contextIsCurrent ( context ) ; if ( outdated ) { PGraphicsOpenGL . removeTextureObject ( glName , context ) ; glName = 0 ; } return outdated ; } public void colorBuffer ( boolean value ) { colorBuffer = value ; } public boolean colorBuffer ( ) { return colorBuffer ; } protected void copyTexture ( Texture tex , int x , int y , int w , int h , boolean scale ) { if ( tex == null ) { throw new RuntimeException ( "Source texture is null" ) ; } if ( tempFbo == null ) { tempFbo = new FrameBuffer ( pg , glWidth , glHeight ) ; } tempFbo . setColorBuffer ( this ) ; tempFbo . disableDepthTest ( ) ; pg . pushFramebuffer ( ) ; pg . setFramebuffer ( tempFbo ) ; pgl . clearColor ( 0 , 0 , 0 , 0 ) ; pgl . clear ( PGL . COLOR_BUFFER_BIT ) ; if ( scale ) { pgl . drawTexture ( tex . glTarget , tex . glName , tex . glWidth , tex . glHeight , 0 , 0 , tempFbo . width , tempFbo . height , x , y , x + w , y + h , 0 , 0 , width , height ) ; } else { pgl . drawTexture ( tex . glTarget , tex . glName , tex . glWidth , tex . glHeight , 0 , 0 , tempFbo . width , tempFbo . height , x , y , x + w , y + h , x , y , x + w , y + h ) ; } pg . popFramebuffer ( ) ; updateTexels ( x , y , w , h ) ; } protected void copyTexture ( int texTarget , int texName , int texWidth , int texHeight , int x , int y , int w , int h , boolean scale ) { if ( tempFbo == null ) { tempFbo = new FrameBuffer ( pg , glWidth , glHeight ) ; } tempFbo . setColorBuffer ( this ) ; tempFbo . disableDepthTest ( ) ; pg . pushFramebuffer ( ) ; pg . setFramebuffer ( tempFbo ) ; if ( scale ) { pgl . drawTexture ( texTarget , texName , texWidth , texHeight , 0 , 0 , tempFbo . width , tempFbo . height , x , y , w , h , 0 , 0 , width , height ) ; } else { pgl . drawTexture ( texTarget , texName , texWidth , texHeight , 0 , 0 , tempFbo . width , tempFbo . height , x , y , w , h , x , y , w , h ) ; } pg . popFramebuffer ( ) ; updateTexels ( x , y , w , h ) ; } protected void copyObject ( Texture src ) { dispose ( ) ; width = src . width ; height = src . height ; glName = src . glName ; glTarget = src . glTarget ; glFormat = src . glFormat ; glMinFilter = src . glMinFilter ; glMagFilter = src . glMagFilter ; glWidth = src . glWidth ; glHeight = src . glHeight ; usingMipmaps = src . usingMipmaps ; usingRepeat = src . usingRepeat ; maxTexcoordU = src . maxTexcoordU ; maxTexcoordV = src . maxTexcoordV ; invertedX = src . invertedX ; invertedY = src . invertedY ; } protected void releasePixelBuffer ( ) { double freeMB = Runtime . getRuntime ( ) . freeMemory ( ) / 1E6 ; if ( pixBufUpdateCount < MAX_UPDATES || freeMB < MIN_MEMORY ) { pixelBuffer = null ; } } protected void releaseRGBAPixels ( ) { double freeMB = Runtime . getRuntime ( ) . freeMemory ( ) / 1E6 ; if ( rgbaPixUpdateCount < MAX_UPDATES || freeMB < MIN_MEMORY ) { rgbaPixels = null ; } } public Parameters getParameters ( ) { Parameters res = new Parameters ( ) ; if ( glTarget == PGL . TEXTURE_2D ) { res . target = TEX2D ; } if ( glFormat == PGL . RGB ) { res . format = RGB ; } else if ( glFormat == PGL . RGBA ) { res . format = ARGB ; } else if ( glFormat == PGL . ALPHA ) { res . format = ALPHA ; } if ( glMagFilter == PGL . NEAREST && glMinFilter == PGL . NEAREST ) { res . sampling = POINT ; res . mipmaps = false ; } else if ( glMagFilter == PGL . NEAREST && glMinFilter == PGL . LINEAR ) { res . sampling = LINEAR ; res . mipmaps = false ; } else if ( glMagFilter == PGL . NEAREST && glMinFilter == PGL . LINEAR_MIPMAP_NEAREST ) { res . sampling = LINEAR ; res . mipmaps = true ; } else if ( glMagFilter == PGL . LINEAR && glMinFilter == PGL . LINEAR ) { res . sampling = BILINEAR ; res . mipmaps = false ; } else if ( glMagFilter == PGL . LINEAR && glMinFilter == PGL . LINEAR_MIPMAP_NEAREST ) { res . sampling = BILINEAR ; res . mipmaps = true ; } else if ( glMagFilter == PGL . LINEAR && glMinFilter == PGL . LINEAR_MIPMAP_LINEAR ) { res . sampling = TRILINEAR ; res . mipmaps = true ; } if ( glWrapS == PGL . CLAMP_TO_EDGE ) { res . wrapU = CLAMP ; } else if ( glWrapS == PGL . REPEAT ) { res . wrapU = REPEAT ; } if ( glWrapT == PGL . CLAMP_TO_EDGE ) { res . wrapV = CLAMP ; } else if ( glWrapT == PGL . REPEAT ) { res . wrapV = REPEAT ; } return res ; } protected void setParameters ( Parameters params ) { if ( params . target == TEX2D ) { glTarget = PGL . TEXTURE_2D ; } else { throw new RuntimeException ( "Unknown texture target" ) ; } if ( params . format == RGB ) { glFormat = PGL . RGB ; } else if ( params . format == ARGB ) { glFormat = PGL . RGBA ; } else if ( params . format == ALPHA ) { glFormat = PGL . ALPHA ; } else { throw new RuntimeException ( "Unknown texture format" ) ; } boolean mipmaps = params . mipmaps && PGL . MIPMAPS_ENABLED ; if ( mipmaps && ! PGraphicsOpenGL . autoMipmapGenSupported ) { PGraphics . showWarning ( "Mipmaps were requested but automatic mipmap " + "generation is not supported and manual " + "generation still not implemented, so mipmaps " + "will be disabled." ) ; mipmaps = false ; } if ( params . sampling == POINT ) { glMagFilter = PGL . NEAREST ; glMinFilter = PGL . NEAREST ; } else if ( params . sampling == LINEAR ) { glMagFilter = PGL . NEAREST ; glMinFilter = mipmaps ? PGL . LINEAR_MIPMAP_NEAREST : PGL . LINEAR ; } else if ( params . sampling == BILINEAR ) { glMagFilter = PGL . LINEAR ; glMinFilter = mipmaps ? PGL . LINEAR_MIPMAP_NEAREST : PGL . LINEAR ; } else if ( params . sampling == TRILINEAR ) { glMagFilter = PGL . LINEAR ; glMinFilter = mipmaps ? PGL . LINEAR_MIPMAP_LINEAR : PGL . LINEAR ; } else { throw new RuntimeException ( "Unknown texture filtering mode" ) ; } if ( params . wrapU == CLAMP ) { glWrapS = PGL . CLAMP_TO_EDGE ; } else if ( params . wrapU == REPEAT ) { glWrapS = PGL . REPEAT ; } else { throw new RuntimeException ( "Unknown wrapping mode" ) ; } if ( params . wrapV == CLAMP ) { glWrapT = PGL . CLAMP_TO_EDGE ; } else if ( params . wrapV == REPEAT ) { glWrapT = PGL . REPEAT ; } else { throw new RuntimeException ( "Unknown wrapping mode" ) ; } usingMipmaps = glMinFilter == PGL . LINEAR_MIPMAP_NEAREST || glMinFilter == PGL . LINEAR_MIPMAP_LINEAR ; usingRepeat = glWrapS == PGL . REPEAT || glWrapT == PGL . REPEAT ; invertedX = false ; invertedY = false ; } protected void fillEdges ( int x , int y , int w , int h ) { if ( ( width < glWidth || height < glHeight ) && ( x + w == width || y + h == height ) ) { if ( x + w == width ) { int ew = glWidth - width ; edgePixels = new int [ h * ew ] ; for ( int i = 0 ; i < h ; i ++ ) { int c = rgbaPixels [ i * w + ( w - 1 ) ] ; Arrays . fill ( edgePixels , i * ew , ( i + 1 ) * ew , c ) ; } edgeBuffer = PGL . updateIntBuffer ( edgeBuffer , edgePixels , true ) ; pgl . texSubImage2D ( glTarget , 0 , width , y , ew , h , PGL . RGBA , PGL . UNSIGNED_BYTE , edgeBuffer ) ; } if ( y + h == height ) { int eh = glHeight - height ; edgePixels = new int [ eh * w ] ; for ( int i = 0 ; i < eh ; i ++ ) { System . arraycopy ( rgbaPixels , ( h - 1 ) * w , edgePixels , i * w , w ) ; } edgeBuffer = PGL . updateIntBuffer ( edgeBuffer , edgePixels , true ) ; pgl . texSubImage2D ( glTarget , 0 , x , height , w , eh , PGL . RGBA , PGL . UNSIGNED_BYTE , edgeBuffer ) ; } if ( x + w == width && y + h == height ) { int ew = glWidth - width ; int eh = glHeight - height ; int c = rgbaPixels [ w * h - 1 ] ; edgePixels = new int [ eh * ew ] ; Arrays . fill ( edgePixels , 0 , eh * ew , c ) ; edgeBuffer = PGL . updateIntBuffer ( edgeBuffer , edgePixels , true ) ; pgl . texSubImage2D ( glTarget , 0 , width , height , ew , eh , PGL . RGBA , PGL . UNSIGNED_BYTE , edgeBuffer ) ; } } } static public class Parameters { public int target ; public int format ; public int sampling ; public boolean mipmaps ; public int wrapU ; public int wrapV ; public Parameters ( ) { this . target = TEX2D ; this . format = ARGB ; this . sampling = BILINEAR ; this . mipmaps = true ; this . wrapU = CLAMP ; this . wrapV = CLAMP ; } public Parameters ( int format ) { this . target = TEX2D ; this . format = format ; this . sampling = BILINEAR ; this . mipmaps = true ; this . wrapU = CLAMP ; this . wrapV = CLAMP ; } public Parameters ( int format , int sampling ) { this . target = TEX2D ; this . format = format ; this . sampling = sampling ; this . mipmaps = true ; this . wrapU = CLAMP ; this . wrapV = CLAMP ; } public Parameters ( int format , int sampling , boolean mipmaps ) { this . target = TEX2D ; this . format = format ; this . mipmaps = mipmaps ; if ( sampling == TRILINEAR && ! mipmaps ) { this . sampling = BILINEAR ; } else { this . sampling = sampling ; } this . wrapU = CLAMP ; this . wrapV = CLAMP ; } public Parameters ( int format , int sampling , boolean mipmaps , int wrap ) { this . target = TEX2D ; this . format = format ; this . mipmaps = mipmaps ; if ( sampling == TRILINEAR && ! mipmaps ) { this . sampling = BILINEAR ; } else { this . sampling = sampling ; } this . wrapU = wrap ; this . wrapV = wrap ; } public Parameters ( Parameters src ) { set ( src ) ; } public void set ( int format ) { this . format = format ; } public void set ( int format , int sampling ) { this . format = format ; this . sampling = sampling ; } public void set ( int format , int sampling , boolean mipmaps ) { this . format = format ; this . sampling = sampling ; this . mipmaps = mipmaps ; } public void set ( Parameters src ) { this . target = src . target ; this . format = src . format ; this . sampling = src . sampling ; this . mipmaps = src . mipmaps ; this . wrapU = src . wrapU ; this . wrapV = src . wrapV ; } } protected class BufferData { int w , h ; Object natBuf ; IntBuffer rgbBuf ; BufferData ( Object nat , IntBuffer rgb , int w , int h ) { natBuf = nat ; rgbBuf = rgb ; this . w = w ; this . h = h ; } void dispose ( ) { try { disposeBufferMethod . invoke ( bufferSource , new Object [ ] { natBuf } ) ; natBuf = null ; rgbBuf = null ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } }
package processing . core ; import java . awt . * ; import java . awt . font . FontRenderContext ; import java . awt . font . GlyphVector ; import java . awt . geom . PathIterator ; import java . awt . image . * ; import java . io . * ; import java . util . Arrays ; import java . util . HashMap ; public class PFont implements PConstants { protected int glyphCount ; protected Glyph [ ] glyphs ; protected String name ; protected String psname ; private int size ; protected int density ; protected boolean smooth ; protected int ascent ; protected int descent ; protected int [ ] ascii ; protected boolean lazy ; protected Font font ; protected boolean stream ; protected boolean subsetting ; protected boolean fontSearched ; static protected Font [ ] fonts ; static protected HashMap < String , Font > fontDifferent ; protected BufferedImage lazyImage ; protected Graphics2D lazyGraphics ; protected FontMetrics lazyMetrics ; protected int [ ] lazySamples ; public PFont ( ) { } public PFont ( Font font , boolean smooth ) { this ( font , smooth , null ) ; } public PFont ( Font font , boolean smooth , char charset [ ] ) { this . font = font ; this . smooth = smooth ; name = font . getName ( ) ; psname = font . getPSName ( ) ; size = font . getSize ( ) ; int initialCount = 10 ; glyphs = new Glyph [ initialCount ] ; ascii = new int [ 128 ] ; Arrays . fill ( ascii , - 1 ) ; int mbox3 = size * 3 ; lazyImage = new BufferedImage ( mbox3 , mbox3 , BufferedImage . TYPE_INT_RGB ) ; lazyGraphics = ( Graphics2D ) lazyImage . getGraphics ( ) ; lazyGraphics . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , smooth ? RenderingHints . VALUE_ANTIALIAS_ON : RenderingHints . VALUE_ANTIALIAS_OFF ) ; lazyGraphics . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , smooth ? RenderingHints . VALUE_TEXT_ANTIALIAS_ON : RenderingHints . VALUE_TEXT_ANTIALIAS_OFF ) ; lazyGraphics . setFont ( font ) ; lazyMetrics = lazyGraphics . getFontMetrics ( ) ; lazySamples = new int [ mbox3 * mbox3 ] ; if ( charset == null ) { lazy = true ; } else { Arrays . sort ( charset ) ; glyphs = new Glyph [ charset . length ] ; glyphCount = 0 ; for ( char c : charset ) { if ( font . canDisplay ( c ) ) { Glyph glyf = new Glyph ( c ) ; if ( glyf . value < 128 ) { ascii [ glyf . value ] = glyphCount ; } glyf . index = glyphCount ; glyphs [ glyphCount ++ ] = glyf ; } } if ( glyphCount != charset . length ) { glyphs = ( Glyph [ ] ) PApplet . subset ( glyphs , 0 , glyphCount ) ; } } if ( ascent == 0 ) { if ( font . canDisplay ( 'd' ) ) { new Glyph ( 'd' ) ; } else { ascent = lazyMetrics . getAscent ( ) ; } } if ( descent == 0 ) { if ( font . canDisplay ( 'p' ) ) { new Glyph ( 'p' ) ; } else { descent = lazyMetrics . getDescent ( ) ; } } } public PFont ( Font font , boolean smooth , char charset [ ] , boolean stream , int density ) { this ( font , smooth , charset ) ; this . stream = stream ; this . density = density ; } public PFont ( InputStream input ) throws IOException { DataInputStream is = new DataInputStream ( input ) ; glyphCount = is . readInt ( ) ; int version = is . readInt ( ) ; size = is . readInt ( ) ; is . readInt ( ) ; ascent = is . readInt ( ) ; descent = is . readInt ( ) ; glyphs = new Glyph [ glyphCount ] ; ascii = new int [ 128 ] ; Arrays . fill ( ascii , - 1 ) ; for ( int i = 0 ; i < glyphCount ; i ++ ) { Glyph glyph = new Glyph ( is ) ; if ( glyph . value < 128 ) { ascii [ glyph . value ] = i ; } glyph . index = i ; glyphs [ i ] = glyph ; } if ( ( ascent == 0 ) && ( descent == 0 ) ) { throw new RuntimeException ( "Please use \"Create Font\" to " + "re-create this font." ) ; } for ( Glyph glyph : glyphs ) { glyph . readBitmap ( is ) ; } if ( version >= 10 ) { name = is . readUTF ( ) ; psname = is . readUTF ( ) ; } if ( version == 11 ) { smooth = is . readBoolean ( ) ; } } public void save ( OutputStream output ) throws IOException { DataOutputStream os = new DataOutputStream ( output ) ; os . writeInt ( glyphCount ) ; if ( ( name == null ) || ( psname == null ) ) { name = "" ; psname = "" ; } os . writeInt ( 11 ) ; os . writeInt ( size ) ; os . writeInt ( 0 ) ; os . writeInt ( ascent ) ; os . writeInt ( descent ) ; for ( int i = 0 ; i < glyphCount ; i ++ ) { glyphs [ i ] . writeHeader ( os ) ; } for ( int i = 0 ; i < glyphCount ; i ++ ) { glyphs [ i ] . writeBitmap ( os ) ; } os . writeUTF ( name ) ; os . writeUTF ( psname ) ; os . writeBoolean ( smooth ) ; os . flush ( ) ; } protected void addGlyph ( char c ) { Glyph glyph = new Glyph ( c ) ; if ( glyphCount == glyphs . length ) { glyphs = ( Glyph [ ] ) PApplet . expand ( glyphs ) ; } if ( glyphCount == 0 ) { glyph . index = 0 ; glyphs [ glyphCount ] = glyph ; if ( glyph . value < 128 ) { ascii [ glyph . value ] = 0 ; } } else if ( glyphs [ glyphCount - 1 ] . value < glyph . value ) { glyphs [ glyphCount ] = glyph ; if ( glyph . value < 128 ) { ascii [ glyph . value ] = glyphCount ; } } else { for ( int i = 0 ; i < glyphCount ; i ++ ) { if ( glyphs [ i ] . value > c ) { for ( int j = glyphCount ; j > i ; -- j ) { glyphs [ j ] = glyphs [ j - 1 ] ; if ( glyphs [ j ] . value < 128 ) { ascii [ glyphs [ j ] . value ] = j ; } } glyph . index = i ; glyphs [ i ] = glyph ; if ( c < 128 ) ascii [ c ] = i ; break ; } } } glyphCount ++ ; } public String getName ( ) { return name ; } public String getPostScriptName ( ) { return psname ; } public void setNative ( Object font ) { this . font = ( Font ) font ; } @ Deprecated public Font getFont ( ) { return font ; } public Object getNative ( ) { if ( subsetting ) { return null ; } return font ; } public int getSize ( ) { return size ; } public int getDefaultSize ( ) { return size / density ; } public boolean isStream ( ) { return stream ; } public void setSubsetting ( ) { subsetting = true ; } public Object findNative ( ) { if ( font == null ) { if ( ! fontSearched ) { font = new Font ( name , Font . PLAIN , size ) ; if ( ! font . getPSName ( ) . equals ( psname ) ) { font = new Font ( psname , Font . PLAIN , size ) ; } if ( ! font . getPSName ( ) . equals ( psname ) ) { font = null ; } fontSearched = true ; } } return font ; } public Glyph getGlyph ( char c ) { int index = index ( c ) ; return ( index == - 1 ) ? null : glyphs [ index ] ; } protected int index ( char c ) { if ( lazy ) { int index = indexActual ( c ) ; if ( index != - 1 ) { return index ; } if ( font != null && font . canDisplay ( c ) ) { addGlyph ( c ) ; return indexActual ( c ) ; } else { return - 1 ; } } else { return indexActual ( c ) ; } } protected int indexActual ( char c ) { if ( glyphCount == 0 ) return - 1 ; if ( c < 128 ) return ascii [ c ] ; return indexHunt ( c , 0 , glyphCount - 1 ) ; } protected int indexHunt ( int c , int start , int stop ) { int pivot = ( start + stop ) / 2 ; if ( c == glyphs [ pivot ] . value ) return pivot ; if ( start >= stop ) return - 1 ; if ( c < glyphs [ pivot ] . value ) return indexHunt ( c , start , pivot - 1 ) ; return indexHunt ( c , pivot + 1 , stop ) ; } public float kern ( char a , char b ) { return 0 ; } public float ascent ( ) { return ( ( float ) ascent / ( float ) size ) ; } public float descent ( ) { return ( ( float ) descent / ( float ) size ) ; } public float width ( char c ) { if ( c == 32 ) return width ( 'i' ) ; int cc = index ( c ) ; if ( cc == - 1 ) return 0 ; return ( ( float ) glyphs [ cc ] . setWidth / ( float ) size ) ; } public int getGlyphCount ( ) { return glyphCount ; } public Glyph getGlyph ( int i ) { return glyphs [ i ] ; } public PShape getShape ( char ch ) { return getShape ( ch , 0 ) ; } public PShape getShape ( char ch , float detail ) { Font font = ( Font ) getNative ( ) ; if ( font == null ) { throw new IllegalArgumentException ( "getShape() only works on fonts loaded with createFont()" ) ; } PShape s = new PShape ( PShape . PATH ) ; float [ ] iterPoints = new float [ 6 ] ; char [ ] textArray = new char [ ] { ch } ; @ SuppressWarnings ( "deprecation" ) FontRenderContext frc = Toolkit . getDefaultToolkit ( ) . getFontMetrics ( font ) . getFontRenderContext ( ) ; GlyphVector gv = font . createGlyphVector ( frc , textArray ) ; Shape shp = gv . getOutline ( ) ; PathIterator iter = ( detail == 0 ) ? shp . getPathIterator ( null ) : shp . getPathIterator ( null , detail ) ; int contours = 0 ; while ( ! iter . isDone ( ) ) { int type = iter . currentSegment ( iterPoints ) ; switch ( type ) { case PathIterator . SEG_MOVETO : if ( contours == 0 ) { s . beginShape ( ) ; } else { s . beginContour ( ) ; } contours ++ ; s . vertex ( iterPoints [ 0 ] , iterPoints [ 1 ] ) ; break ; case PathIterator . SEG_LINETO : s . vertex ( iterPoints [ 0 ] , iterPoints [ 1 ] ) ; break ; case PathIterator . SEG_QUADTO : s . quadraticVertex ( iterPoints [ 0 ] , iterPoints [ 1 ] , iterPoints [ 2 ] , iterPoints [ 3 ] ) ; break ; case PathIterator . SEG_CUBICTO : s . quadraticVertex ( iterPoints [ 0 ] , iterPoints [ 1 ] , iterPoints [ 2 ] , iterPoints [ 3 ] , iterPoints [ 4 ] , iterPoints [ 5 ] ) ; break ; case PathIterator . SEG_CLOSE : if ( contours > 1 ) { s . endContour ( ) ; } break ; } iter . next ( ) ; } s . endShape ( CLOSE ) ; return s ; } static final char [ ] EXTRA_CHARS = { 0x0080 , 0x0081 , 0x0082 , 0x0083 , 0x0084 , 0x0085 , 0x0086 , 0x0087 , 0x0088 , 0x0089 , 0x008A , 0x008B , 0x008C , 0x008D , 0x008E , 0x008F , 0x0090 , 0x0091 , 0x0092 , 0x0093 , 0x0094 , 0x0095 , 0x0096 , 0x0097 , 0x0098 , 0x0099 , 0x009A , 0x009B , 0x009C , 0x009D , 0x009E , 0x009F , 0x00A0 , 0x00A1 , 0x00A2 , 0x00A3 , 0x00A4 , 0x00A5 , 0x00A6 , 0x00A7 , 0x00A8 , 0x00A9 , 0x00AA , 0x00AB , 0x00AC , 0x00AD , 0x00AE , 0x00AF , 0x00B0 , 0x00B1 , 0x00B4 , 0x00B5 , 0x00B6 , 0x00B7 , 0x00B8 , 0x00BA , 0x00BB , 0x00BF , 0x00C0 , 0x00C1 , 0x00C2 , 0x00C3 , 0x00C4 , 0x00C5 , 0x00C6 , 0x00C7 , 0x00C8 , 0x00C9 , 0x00CA , 0x00CB , 0x00CC , 0x00CD , 0x00CE , 0x00CF , 0x00D1 , 0x00D2 , 0x00D3 , 0x00D4 , 0x00D5 , 0x00D6 , 0x00D7 , 0x00D8 , 0x00D9 , 0x00DA , 0x00DB , 0x00DC , 0x00DD , 0x00DF , 0x00E0 , 0x00E1 , 0x00E2 , 0x00E3 , 0x00E4 , 0x00E5 , 0x00E6 , 0x00E7 , 0x00E8 , 0x00E9 , 0x00EA , 0x00EB , 0x00EC , 0x00ED , 0x00EE , 0x00EF , 0x00F1 , 0x00F2 , 0x00F3 , 0x00F4 , 0x00F5 , 0x00F6 , 0x00F7 , 0x00F8 , 0x00F9 , 0x00FA , 0x00FB , 0x00FC , 0x00FD , 0x00FF , 0x0102 , 0x0103 , 0x0104 , 0x0105 , 0x0106 , 0x0107 , 0x010C , 0x010D , 0x010E , 0x010F , 0x0110 , 0x0111 , 0x0118 , 0x0119 , 0x011A , 0x011B , 0x0131 , 0x0139 , 0x013A , 0x013D , 0x013E , 0x0141 , 0x0142 , 0x0143 , 0x0144 , 0x0147 , 0x0148 , 0x0150 , 0x0151 , 0x0152 , 0x0153 , 0x0154 , 0x0155 , 0x0158 , 0x0159 , 0x015A , 0x015B , 0x015E , 0x015F , 0x0160 , 0x0161 , 0x0162 , 0x0163 , 0x0164 , 0x0165 , 0x016E , 0x016F , 0x0170 , 0x0171 , 0x0178 , 0x0179 , 0x017A , 0x017B , 0x017C , 0x017D , 0x017E , 0x0192 , 0x02C6 , 0x02C7 , 0x02D8 , 0x02D9 , 0x02DA , 0x02DB , 0x02DC , 0x02DD , 0x03A9 , 0x03C0 , 0x2013 , 0x2014 , 0x2018 , 0x2019 , 0x201A , 0x201C , 0x201D , 0x201E , 0x2020 , 0x2021 , 0x2022 , 0x2026 , 0x2030 , 0x2039 , 0x203A , 0x2044 , 0x20AC , 0x2122 , 0x2202 , 0x2206 , 0x220F , 0x2211 , 0x221A , 0x221E , 0x222B , 0x2248 , 0x2260 , 0x2264 , 0x2265 , 0x25CA , 0xF8FF , 0xFB01 , 0xFB02 } ; static public char [ ] CHARSET ; static { CHARSET = new char [ 126 - 33 + 1 + EXTRA_CHARS . length ] ; int index = 0 ; for ( int i = 33 ; i <= 126 ; i ++ ) { CHARSET [ index ++ ] = ( char ) i ; } for ( int i = 0 ; i < EXTRA_CHARS . length ; i ++ ) { CHARSET [ index ++ ] = EXTRA_CHARS [ i ] ; } } ; static public String [ ] list ( ) { loadFonts ( ) ; String list [ ] = new String [ fonts . length ] ; for ( int i = 0 ; i < list . length ; i ++ ) { list [ i ] = fonts [ i ] . getName ( ) ; } return list ; } static public void loadFonts ( ) { if ( fonts == null ) { GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; fonts = ge . getAllFonts ( ) ; if ( PApplet . platform == PConstants . MACOSX ) { fontDifferent = new HashMap < String , Font > ( ) ; for ( Font font : fonts ) { fontDifferent . put ( font . getName ( ) , font ) ; } } } } static public Font findFont ( String name ) { loadFonts ( ) ; if ( PApplet . platform == PConstants . MACOSX ) { Font maybe = fontDifferent . get ( name ) ; if ( maybe != null ) { return maybe ; } } return new Font ( name , Font . PLAIN , 1 ) ; } public class Glyph { public PImage image ; public int value ; public int height ; public int width ; public int index ; public int setWidth ; public int topExtent ; public int leftExtent ; public Glyph ( ) { index = - 1 ; } public Glyph ( DataInputStream is ) throws IOException { index = - 1 ; readHeader ( is ) ; } protected void readHeader ( DataInputStream is ) throws IOException { value = is . readInt ( ) ; height = is . readInt ( ) ; width = is . readInt ( ) ; setWidth = is . readInt ( ) ; topExtent = is . readInt ( ) ; leftExtent = is . readInt ( ) ; is . readInt ( ) ; if ( value == 'd' ) { if ( ascent == 0 ) ascent = topExtent ; } if ( value == 'p' ) { if ( descent == 0 ) descent = - topExtent + height ; } } protected void writeHeader ( DataOutputStream os ) throws IOException { os . writeInt ( value ) ; os . writeInt ( height ) ; os . writeInt ( width ) ; os . writeInt ( setWidth ) ; os . writeInt ( topExtent ) ; os . writeInt ( leftExtent ) ; os . writeInt ( 0 ) ; } protected void readBitmap ( DataInputStream is ) throws IOException { image = new PImage ( width , height , ALPHA ) ; int bitmapSize = width * height ; byte [ ] temp = new byte [ bitmapSize ] ; is . readFully ( temp ) ; int w = width ; int h = height ; int [ ] pixels = image . pixels ; for ( int y = 0 ; y < h ; y ++ ) { for ( int x = 0 ; x < w ; x ++ ) { pixels [ y * width + x ] = temp [ y * w + x ] & 0xff ; } } } protected void writeBitmap ( DataOutputStream os ) throws IOException { int [ ] pixels = image . pixels ; for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { os . write ( pixels [ y * width + x ] & 0xff ) ; } } } protected Glyph ( char c ) { int mbox3 = size * 3 ; lazyGraphics . setColor ( Color . white ) ; lazyGraphics . fillRect ( 0 , 0 , mbox3 , mbox3 ) ; lazyGraphics . setColor ( Color . black ) ; lazyGraphics . drawString ( String . valueOf ( c ) , size , size * 2 ) ; WritableRaster raster = lazyImage . getRaster ( ) ; raster . getDataElements ( 0 , 0 , mbox3 , mbox3 , lazySamples ) ; int minX = 1000 , maxX = 0 ; int minY = 1000 , maxY = 0 ; boolean pixelFound = false ; for ( int y = 0 ; y < mbox3 ; y ++ ) { for ( int x = 0 ; x < mbox3 ; x ++ ) { int sample = lazySamples [ y * mbox3 + x ] & 0xff ; if ( sample != 255 ) { if ( x < minX ) minX = x ; if ( y < minY ) minY = y ; if ( x > maxX ) maxX = x ; if ( y > maxY ) maxY = y ; pixelFound = true ; } } } if ( ! pixelFound ) { minX = minY = 0 ; maxX = maxY = 0 ; } value = c ; height = ( maxY - minY ) + 1 ; width = ( maxX - minX ) + 1 ; setWidth = lazyMetrics . charWidth ( c ) ; topExtent = size * 2 - minY ; leftExtent = minX - size ; image = new PImage ( width , height , ALPHA ) ; int [ ] pixels = image . pixels ; for ( int y = minY ; y <= maxY ; y ++ ) { for ( int x = minX ; x <= maxX ; x ++ ) { int val = 255 - ( lazySamples [ y * mbox3 + x ] & 0xff ) ; int pindex = ( y - minY ) * width + ( x - minX ) ; pixels [ pindex ] = val ; } } if ( value == 'd' ) { if ( ascent == 0 ) ascent = topExtent ; } if ( value == 'p' ) { if ( descent == 0 ) descent = - topExtent + height ; } } } }
package processing . opengl ; import processing . core . * ; import java . net . URL ; import java . nio . FloatBuffer ; import java . nio . IntBuffer ; import java . util . HashMap ; public class PShader implements PConstants { static protected final int POINT = 0 ; static protected final int LINE = 1 ; static protected final int POLY = 2 ; static protected final int COLOR = 3 ; static protected final int LIGHT = 4 ; static protected final int TEXTURE = 5 ; static protected final int TEXLIGHT = 6 ; static protected String pointShaderAttrRegexp = "attribute *vec2 *offset" ; static protected String lineShaderAttrRegexp = "attribute *vec4 *direction" ; static protected String pointShaderDefRegexp = "#define *PROCESSING_POINT_SHADER" ; static protected String lineShaderDefRegexp = "#define *PROCESSING_LINE_SHADER" ; static protected String colorShaderDefRegexp = "#define *PROCESSING_COLOR_SHADER" ; static protected String lightShaderDefRegexp = "#define *PROCESSING_LIGHT_SHADER" ; static protected String texShaderDefRegexp = "#define *PROCESSING_TEXTURE_SHADER" ; static protected String texlightShaderDefRegexp = "#define *PROCESSING_TEXLIGHT_SHADER" ; static protected String polyShaderDefRegexp = "#define *PROCESSING_POLYGON_SHADER" ; static protected String triShaderAttrRegexp = "#define *PROCESSING_TRIANGLES_SHADER" ; static protected String quadShaderAttrRegexp = "#define *PROCESSING_QUADS_SHADER" ; protected PApplet parent ; protected PGraphicsOpenGL primaryPG ; protected PGraphicsOpenGL currentPG ; protected PGL pgl ; protected int context ; protected int type ; public int glProgram ; public int glVertex ; public int glFragment ; protected URL vertexURL ; protected URL fragmentURL ; protected String vertexFilename ; protected String fragmentFilename ; protected String [ ] vertexShaderSource ; protected String [ ] fragmentShaderSource ; protected boolean bound ; protected HashMap < Integer , UniformValue > uniformValues = null ; protected HashMap < Integer , Texture > textures ; protected HashMap < Integer , Integer > texUnits ; protected IntBuffer intBuffer ; protected FloatBuffer floatBuffer ; protected boolean loadedAttributes = false ; protected boolean loadedUniforms = false ; protected int transformMatLoc ; protected int modelviewMatLoc ; protected int projectionMatLoc ; protected int ppixelsLoc ; protected int ppixelsUnit ; protected int viewportLoc ; protected int perspectiveLoc ; protected int scaleLoc ; protected int lightCountLoc ; protected int lightPositionLoc ; protected int lightNormalLoc ; protected int lightAmbientLoc ; protected int lightDiffuseLoc ; protected int lightSpecularLoc ; protected int lightFalloffLoc ; protected int lightSpotLoc ; protected Texture texture ; protected int texUnit ; protected int textureLoc ; protected int texMatrixLoc ; protected int texOffsetLoc ; protected float [ ] tcmat ; protected int vertexLoc ; protected int colorLoc ; protected int normalLoc ; protected int texCoordLoc ; protected int normalMatLoc ; protected int directionLoc ; protected int offsetLoc ; protected int ambientLoc ; protected int specularLoc ; protected int emissiveLoc ; protected int shininessLoc ; public PShader ( ) { parent = null ; pgl = null ; context = - 1 ; this . vertexURL = null ; this . fragmentURL = null ; this . vertexFilename = null ; this . fragmentFilename = null ; glProgram = 0 ; glVertex = 0 ; glFragment = 0 ; intBuffer = PGL . allocateIntBuffer ( 1 ) ; floatBuffer = PGL . allocateFloatBuffer ( 1 ) ; bound = false ; type = - 1 ; } public PShader ( PApplet parent ) { this ( ) ; this . parent = parent ; primaryPG = ( PGraphicsOpenGL ) parent . g ; pgl = primaryPG . pgl ; context = pgl . createEmptyContext ( ) ; } public PShader ( PApplet parent , String vertFilename , String fragFilename ) { this . parent = parent ; primaryPG = ( PGraphicsOpenGL ) parent . g ; pgl = primaryPG . pgl ; this . vertexURL = null ; this . fragmentURL = null ; this . vertexFilename = vertFilename ; this . fragmentFilename = fragFilename ; fragmentShaderSource = pgl . loadFragmentShader ( fragFilename ) ; vertexShaderSource = pgl . loadVertexShader ( vertFilename ) ; glProgram = 0 ; glVertex = 0 ; glFragment = 0 ; intBuffer = PGL . allocateIntBuffer ( 1 ) ; floatBuffer = PGL . allocateFloatBuffer ( 1 ) ; int vertType = getShaderType ( vertexShaderSource , - 1 ) ; int fragType = getShaderType ( fragmentShaderSource , - 1 ) ; if ( vertType == - 1 && fragType == - 1 ) { type = PShader . POLY ; } else if ( vertType == - 1 ) { type = fragType ; } else if ( fragType == - 1 ) { type = vertType ; } else if ( fragType == vertType ) { type = vertType ; } else { PGraphics . showWarning ( PGraphicsOpenGL . INCONSISTENT_SHADER_TYPES ) ; } } public PShader ( PApplet parent , URL vertURL , URL fragURL ) { this . parent = parent ; primaryPG = ( PGraphicsOpenGL ) parent . g ; pgl = primaryPG . pgl ; this . vertexURL = vertURL ; this . fragmentURL = fragURL ; this . vertexFilename = null ; this . fragmentFilename = null ; fragmentShaderSource = pgl . loadFragmentShader ( fragURL ) ; vertexShaderSource = pgl . loadVertexShader ( vertURL ) ; glProgram = 0 ; glVertex = 0 ; glFragment = 0 ; intBuffer = PGL . allocateIntBuffer ( 1 ) ; floatBuffer = PGL . allocateFloatBuffer ( 1 ) ; int vertType = getShaderType ( vertexShaderSource , - 1 ) ; int fragType = getShaderType ( fragmentShaderSource , - 1 ) ; if ( vertType == - 1 && fragType == - 1 ) { type = PShader . POLY ; } else if ( vertType == - 1 ) { type = fragType ; } else if ( fragType == - 1 ) { type = vertType ; } else if ( fragType == vertType ) { type = vertType ; } else { PGraphics . showWarning ( PGraphicsOpenGL . INCONSISTENT_SHADER_TYPES ) ; } } public PShader ( PApplet parent , String [ ] vertSource , String [ ] fragSource ) { this . parent = parent ; primaryPG = ( PGraphicsOpenGL ) parent . g ; pgl = primaryPG . pgl ; this . vertexURL = null ; this . fragmentURL = null ; this . vertexFilename = null ; this . fragmentFilename = null ; vertexShaderSource = vertSource ; fragmentShaderSource = fragSource ; glProgram = 0 ; glVertex = 0 ; glFragment = 0 ; intBuffer = PGL . allocateIntBuffer ( 1 ) ; floatBuffer = PGL . allocateFloatBuffer ( 1 ) ; int vertType = getShaderType ( vertexShaderSource , - 1 ) ; int fragType = getShaderType ( fragmentShaderSource , - 1 ) ; if ( vertType == - 1 && fragType == - 1 ) { type = PShader . POLY ; } else if ( vertType == - 1 ) { type = fragType ; } else if ( fragType == - 1 ) { type = vertType ; } else if ( fragType == vertType ) { type = vertType ; } else { PGraphics . showWarning ( PGraphicsOpenGL . INCONSISTENT_SHADER_TYPES ) ; } } @ Override protected void finalize ( ) throws Throwable { try { if ( glVertex != 0 ) { PGraphicsOpenGL . finalizeGLSLVertShaderObject ( glVertex , context ) ; } if ( glFragment != 0 ) { PGraphicsOpenGL . finalizeGLSLFragShaderObject ( glFragment , context ) ; } if ( glProgram != 0 ) { PGraphicsOpenGL . finalizeGLSLProgramObject ( glProgram , context ) ; } } finally { super . finalize ( ) ; } } public void setVertexShader ( String vertFilename ) { this . vertexFilename = vertFilename ; vertexShaderSource = pgl . loadFragmentShader ( vertFilename ) ; } public void setVertexShader ( URL vertURL ) { this . vertexURL = vertURL ; vertexShaderSource = pgl . loadVertexShader ( vertURL ) ; } public void setVertexShader ( String [ ] vertSource ) { vertexShaderSource = vertSource ; } public void setFragmentShader ( String fragFilename ) { this . fragmentFilename = fragFilename ; fragmentShaderSource = pgl . loadVertexShader ( fragFilename ) ; } public void setFragmentShader ( URL fragURL ) { this . fragmentURL = fragURL ; fragmentShaderSource = pgl . loadVertexShader ( fragURL ) ; } public void setFragmentShader ( String [ ] fragSource ) { fragmentShaderSource = fragSource ; } public void bind ( ) { init ( ) ; if ( ! bound ) { pgl . useProgram ( glProgram ) ; bound = true ; consumeUniforms ( ) ; bindTextures ( ) ; } if ( hasType ( ) ) bindTyped ( ) ; } public void unbind ( ) { if ( hasType ( ) ) unbindTyped ( ) ; if ( bound ) { unbindTextures ( ) ; pgl . useProgram ( 0 ) ; bound = false ; } } public boolean bound ( ) { return bound ; } public void set ( String name , int x ) { setUniformImpl ( name , UniformValue . INT1 , new int [ ] { x } ) ; } public void set ( String name , int x , int y ) { setUniformImpl ( name , UniformValue . INT2 , new int [ ] { x , y } ) ; } public void set ( String name , int x , int y , int z ) { setUniformImpl ( name , UniformValue . INT3 , new int [ ] { x , y , z } ) ; } public void set ( String name , int x , int y , int z , int w ) { setUniformImpl ( name , UniformValue . INT4 , new int [ ] { x , y , z , w } ) ; } public void set ( String name , float x ) { setUniformImpl ( name , UniformValue . FLOAT1 , new float [ ] { x } ) ; } public void set ( String name , float x , float y ) { setUniformImpl ( name , UniformValue . FLOAT2 , new float [ ] { x , y } ) ; } public void set ( String name , float x , float y , float z ) { setUniformImpl ( name , UniformValue . FLOAT3 , new float [ ] { x , y , z } ) ; } public void set ( String name , float x , float y , float z , float w ) { setUniformImpl ( name , UniformValue . FLOAT4 , new float [ ] { x , y , z , w } ) ; } public void set ( String name , PVector vec ) { setUniformImpl ( name , UniformValue . FLOAT3 , new float [ ] { vec . x , vec . y , vec . z } ) ; } public void set ( String name , boolean x ) { setUniformImpl ( name , UniformValue . INT1 , new int [ ] { ( x ) ? 1 : 0 } ) ; } public void set ( String name , boolean x , boolean y ) { setUniformImpl ( name , UniformValue . INT2 , new int [ ] { ( x ) ? 1 : 0 , ( y ) ? 1 : 0 } ) ; } public void set ( String name , boolean x , boolean y , boolean z ) { setUniformImpl ( name , UniformValue . INT3 , new int [ ] { ( x ) ? 1 : 0 , ( y ) ? 1 : 0 , ( z ) ? 1 : 0 } ) ; } public void set ( String name , boolean x , boolean y , boolean z , boolean w ) { setUniformImpl ( name , UniformValue . INT4 , new int [ ] { ( x ) ? 1 : 0 , ( y ) ? 1 : 0 , ( z ) ? 1 : 0 , ( w ) ? 1 : 0 } ) ; } public void set ( String name , int [ ] vec ) { set ( name , vec , 1 ) ; } public void set ( String name , int [ ] vec , int ncoords ) { if ( ncoords == 1 ) { setUniformImpl ( name , UniformValue . INT1VEC , vec ) ; } else if ( ncoords == 2 ) { setUniformImpl ( name , UniformValue . INT2VEC , vec ) ; } else if ( ncoords == 3 ) { setUniformImpl ( name , UniformValue . INT3VEC , vec ) ; } else if ( ncoords == 4 ) { setUniformImpl ( name , UniformValue . INT4VEC , vec ) ; } else if ( 4 < ncoords ) { PGraphics . showWarning ( "Only up to 4 coordinates per element are " + "supported." ) ; } else { PGraphics . showWarning ( "Wrong number of coordinates: it is negative!" ) ; } } public void set ( String name , float [ ] vec ) { set ( name , vec , 1 ) ; } public void set ( String name , float [ ] vec , int ncoords ) { if ( ncoords == 1 ) { setUniformImpl ( name , UniformValue . FLOAT1VEC , vec ) ; } else if ( ncoords == 2 ) { setUniformImpl ( name , UniformValue . FLOAT2VEC , vec ) ; } else if ( ncoords == 3 ) { setUniformImpl ( name , UniformValue . FLOAT3VEC , vec ) ; } else if ( ncoords == 4 ) { setUniformImpl ( name , UniformValue . FLOAT4VEC , vec ) ; } else if ( 4 < ncoords ) { PGraphics . showWarning ( "Only up to 4 coordinates per element are " + "supported." ) ; } else { PGraphics . showWarning ( "Wrong number of coordinates: it is negative!" ) ; } } public void set ( String name , boolean [ ] vec ) { set ( name , vec , 1 ) ; } public void set ( String name , boolean [ ] boolvec , int ncoords ) { int [ ] vec = new int [ boolvec . length ] ; for ( int i = 0 ; i < boolvec . length ; i ++ ) { vec [ i ] = ( boolvec [ i ] ) ? 1 : 0 ; } set ( name , vec , ncoords ) ; } public void set ( String name , PMatrix2D mat ) { float [ ] matv = { mat . m00 , mat . m01 , mat . m10 , mat . m11 } ; setUniformImpl ( name , UniformValue . MAT2 , matv ) ; } public void set ( String name , PMatrix3D mat ) { set ( name , mat , false ) ; } public void set ( String name , PMatrix3D mat , boolean use3x3 ) { if ( use3x3 ) { float [ ] matv = { mat . m00 , mat . m01 , mat . m02 , mat . m10 , mat . m11 , mat . m12 , mat . m20 , mat . m21 , mat . m22 } ; setUniformImpl ( name , UniformValue . MAT3 , matv ) ; } else { float [ ] matv = { mat . m00 , mat . m01 , mat . m02 , mat . m03 , mat . m10 , mat . m11 , mat . m12 , mat . m13 , mat . m20 , mat . m21 , mat . m22 , mat . m23 , mat . m30 , mat . m31 , mat . m32 , mat . m33 } ; setUniformImpl ( name , UniformValue . MAT4 , matv ) ; } } public void set ( String name , PImage tex ) { setUniformImpl ( name , UniformValue . SAMPLER2D , tex ) ; } protected void setup ( ) { } protected void draw ( int idxId , int count , int offset ) { pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , idxId ) ; pgl . drawElements ( PGL . TRIANGLES , count , PGL . INDEX_TYPE , offset * PGL . SIZEOF_INDEX ) ; pgl . bindBuffer ( PGL . ELEMENT_ARRAY_BUFFER , 0 ) ; } protected int getAttributeLoc ( String name ) { init ( ) ; return pgl . getAttribLocation ( glProgram , name ) ; } protected int getUniformLoc ( String name ) { init ( ) ; return pgl . getUniformLocation ( glProgram , name ) ; } protected void setAttributeVBO ( int loc , int vboId , int size , int type , boolean normalized , int stride , int offset ) { if ( - 1 < loc ) { pgl . bindBuffer ( PGL . ARRAY_BUFFER , vboId ) ; pgl . vertexAttribPointer ( loc , size , type , normalized , stride , offset ) ; } } protected void setUniformValue ( int loc , int x ) { if ( - 1 < loc ) { pgl . uniform1i ( loc , x ) ; } } protected void setUniformValue ( int loc , int x , int y ) { if ( - 1 < loc ) { pgl . uniform2i ( loc , x , y ) ; } } protected void setUniformValue ( int loc , int x , int y , int z ) { if ( - 1 < loc ) { pgl . uniform3i ( loc , x , y , z ) ; } } protected void setUniformValue ( int loc , int x , int y , int z , int w ) { if ( - 1 < loc ) { pgl . uniform4i ( loc , x , y , z , w ) ; } } protected void setUniformValue ( int loc , float x ) { if ( - 1 < loc ) { pgl . uniform1f ( loc , x ) ; } } protected void setUniformValue ( int loc , float x , float y ) { if ( - 1 < loc ) { pgl . uniform2f ( loc , x , y ) ; } } protected void setUniformValue ( int loc , float x , float y , float z ) { if ( - 1 < loc ) { pgl . uniform3f ( loc , x , y , z ) ; } } protected void setUniformValue ( int loc , float x , float y , float z , float w ) { if ( - 1 < loc ) { pgl . uniform4f ( loc , x , y , z , w ) ; } } protected void setUniformVector ( int loc , int [ ] vec , int ncoords , int length ) { if ( - 1 < loc ) { updateIntBuffer ( vec ) ; if ( ncoords == 1 ) { pgl . uniform1iv ( loc , length , intBuffer ) ; } else if ( ncoords == 2 ) { pgl . uniform2iv ( loc , length , intBuffer ) ; } else if ( ncoords == 3 ) { pgl . uniform3iv ( loc , length , intBuffer ) ; } else if ( ncoords == 4 ) { pgl . uniform3iv ( loc , length , intBuffer ) ; } } } protected void setUniformVector ( int loc , float [ ] vec , int ncoords , int length ) { if ( - 1 < loc ) { updateFloatBuffer ( vec ) ; if ( ncoords == 1 ) { pgl . uniform1fv ( loc , length , floatBuffer ) ; } else if ( ncoords == 2 ) { pgl . uniform2fv ( loc , length , floatBuffer ) ; } else if ( ncoords == 3 ) { pgl . uniform3fv ( loc , length , floatBuffer ) ; } else if ( ncoords == 4 ) { pgl . uniform4fv ( loc , length , floatBuffer ) ; } } } protected void setUniformMatrix ( int loc , float [ ] mat ) { if ( - 1 < loc ) { updateFloatBuffer ( mat ) ; if ( mat . length == 4 ) { pgl . uniformMatrix2fv ( loc , 1 , false , floatBuffer ) ; } else if ( mat . length == 9 ) { pgl . uniformMatrix3fv ( loc , 1 , false , floatBuffer ) ; } else if ( mat . length == 16 ) { pgl . uniformMatrix4fv ( loc , 1 , false , floatBuffer ) ; } } } protected void setUniformTex ( int loc , Texture tex ) { if ( texUnits != null ) { Integer unit = texUnits . get ( loc ) ; if ( unit != null ) { pgl . activeTexture ( PGL . TEXTURE0 + unit ) ; tex . bind ( ) ; } else { throw new RuntimeException ( "Cannot find unit for texture " + tex ) ; } } } protected void setUniformImpl ( String name , int type , Object value ) { int loc = getUniformLoc ( name ) ; if ( - 1 < loc ) { if ( uniformValues == null ) { uniformValues = new HashMap < Integer , UniformValue > ( ) ; } uniformValues . put ( loc , new UniformValue ( type , value ) ) ; } else { PGraphics . showWarning ( "The shader doesn't have a uniform called \"" + name + "\" OR the uniform was removed during " + "compilation because it was unused." ) ; } } protected void consumeUniforms ( ) { if ( uniformValues != null && 0 < uniformValues . size ( ) ) { int unit = 0 ; for ( Integer loc : uniformValues . keySet ( ) ) { UniformValue val = uniformValues . get ( loc ) ; if ( val . type == UniformValue . INT1 ) { int [ ] v = ( ( int [ ] ) val . value ) ; pgl . uniform1i ( loc , v [ 0 ] ) ; } else if ( val . type == UniformValue . INT2 ) { int [ ] v = ( ( int [ ] ) val . value ) ; pgl . uniform2i ( loc , v [ 0 ] , v [ 1 ] ) ; } else if ( val . type == UniformValue . INT3 ) { int [ ] v = ( ( int [ ] ) val . value ) ; pgl . uniform3i ( loc , v [ 0 ] , v [ 1 ] , v [ 2 ] ) ; } else if ( val . type == UniformValue . INT4 ) { int [ ] v = ( ( int [ ] ) val . value ) ; pgl . uniform4i ( loc , v [ 0 ] , v [ 1 ] , v [ 2 ] , v [ 3 ] ) ; } else if ( val . type == UniformValue . FLOAT1 ) { float [ ] v = ( ( float [ ] ) val . value ) ; pgl . uniform1f ( loc , v [ 0 ] ) ; } else if ( val . type == UniformValue . FLOAT2 ) { float [ ] v = ( ( float [ ] ) val . value ) ; pgl . uniform2f ( loc , v [ 0 ] , v [ 1 ] ) ; } else if ( val . type == UniformValue . FLOAT3 ) { float [ ] v = ( ( float [ ] ) val . value ) ; pgl . uniform3f ( loc , v [ 0 ] , v [ 1 ] , v [ 2 ] ) ; } else if ( val . type == UniformValue . FLOAT4 ) { float [ ] v = ( ( float [ ] ) val . value ) ; pgl . uniform4f ( loc , v [ 0 ] , v [ 1 ] , v [ 2 ] , v [ 3 ] ) ; } else if ( val . type == UniformValue . INT1VEC ) { int [ ] v = ( ( int [ ] ) val . value ) ; updateIntBuffer ( v ) ; pgl . uniform1iv ( loc , v . length , intBuffer ) ; } else if ( val . type == UniformValue . INT2VEC ) { int [ ] v = ( ( int [ ] ) val . value ) ; updateIntBuffer ( v ) ; pgl . uniform2iv ( loc , v . length / 2 , intBuffer ) ; } else if ( val . type == UniformValue . INT3VEC ) { int [ ] v = ( ( int [ ] ) val . value ) ; updateIntBuffer ( v ) ; pgl . uniform3iv ( loc , v . length / 3 , intBuffer ) ; } else if ( val . type == UniformValue . INT4VEC ) { int [ ] v = ( ( int [ ] ) val . value ) ; updateIntBuffer ( v ) ; pgl . uniform4iv ( loc , v . length / 4 , intBuffer ) ; } else if ( val . type == UniformValue . FLOAT1VEC ) { float [ ] v = ( ( float [ ] ) val . value ) ; updateFloatBuffer ( v ) ; pgl . uniform1fv ( loc , v . length , floatBuffer ) ; } else if ( val . type == UniformValue . FLOAT2VEC ) { float [ ] v = ( ( float [ ] ) val . value ) ; updateFloatBuffer ( v ) ; pgl . uniform2fv ( loc , v . length / 2 , floatBuffer ) ; } else if ( val . type == UniformValue . FLOAT3VEC ) { float [ ] v = ( ( float [ ] ) val . value ) ; updateFloatBuffer ( v ) ; pgl . uniform3fv ( loc , v . length / 3 , floatBuffer ) ; } else if ( val . type == UniformValue . FLOAT4VEC ) { float [ ] v = ( ( float [ ] ) val . value ) ; updateFloatBuffer ( v ) ; pgl . uniform4fv ( loc , v . length / 4 , floatBuffer ) ; } else if ( val . type == UniformValue . MAT2 ) { float [ ] v = ( ( float [ ] ) val . value ) ; updateFloatBuffer ( v ) ; pgl . uniformMatrix2fv ( loc , 1 , false , floatBuffer ) ; } else if ( val . type == UniformValue . MAT3 ) { float [ ] v = ( ( float [ ] ) val . value ) ; updateFloatBuffer ( v ) ; pgl . uniformMatrix3fv ( loc , 1 , false , floatBuffer ) ; } else if ( val . type == UniformValue . MAT4 ) { float [ ] v = ( ( float [ ] ) val . value ) ; updateFloatBuffer ( v ) ; pgl . uniformMatrix4fv ( loc , 1 , false , floatBuffer ) ; } else if ( val . type == UniformValue . SAMPLER2D ) { PImage img = ( PImage ) val . value ; Texture tex = currentPG . getTexture ( img ) ; if ( textures == null ) textures = new HashMap < Integer , Texture > ( ) ; textures . put ( loc , tex ) ; if ( texUnits == null ) texUnits = new HashMap < Integer , Integer > ( ) ; if ( texUnits . containsKey ( loc ) ) { unit = texUnits . get ( loc ) ; pgl . uniform1i ( loc , unit ) ; } else { texUnits . put ( loc , unit ) ; pgl . uniform1i ( loc , unit ) ; } unit ++ ; } } uniformValues . clear ( ) ; } } protected void updateIntBuffer ( int [ ] vec ) { intBuffer = PGL . updateIntBuffer ( intBuffer , vec , false ) ; } protected void updateFloatBuffer ( float [ ] vec ) { floatBuffer = PGL . updateFloatBuffer ( floatBuffer , vec , false ) ; } protected void bindTextures ( ) { if ( textures != null && texUnits != null ) { for ( int loc : textures . keySet ( ) ) { Texture tex = textures . get ( loc ) ; Integer unit = texUnits . get ( loc ) ; if ( unit != null ) { pgl . activeTexture ( PGL . TEXTURE0 + unit ) ; tex . bind ( ) ; } else { throw new RuntimeException ( "Cannot find unit for texture " + tex ) ; } } } } protected void unbindTextures ( ) { if ( textures != null && texUnits != null ) { for ( int loc : textures . keySet ( ) ) { Texture tex = textures . get ( loc ) ; Integer unit = texUnits . get ( loc ) ; if ( unit != null ) { pgl . activeTexture ( PGL . TEXTURE0 + unit ) ; tex . unbind ( ) ; } else { throw new RuntimeException ( "Cannot find unit for texture " + tex ) ; } } pgl . activeTexture ( PGL . TEXTURE0 ) ; } } public void init ( ) { if ( glProgram == 0 || contextIsOutdated ( ) ) { create ( ) ; if ( compile ( ) ) { pgl . attachShader ( glProgram , glVertex ) ; pgl . attachShader ( glProgram , glFragment ) ; setup ( ) ; pgl . linkProgram ( glProgram ) ; validate ( ) ; } } } protected void create ( ) { context = pgl . getCurrentContext ( ) ; glProgram = PGraphicsOpenGL . createGLSLProgramObject ( context , pgl ) ; } protected boolean compile ( ) { boolean vertRes = true ; if ( hasVertexShader ( ) ) { vertRes = compileVertexShader ( ) ; } else { PGraphics . showException ( "Doesn't have a vertex shader" ) ; } boolean fragRes = true ; if ( hasFragmentShader ( ) ) { fragRes = compileFragmentShader ( ) ; } else { PGraphics . showException ( "Doesn't have a fragment shader" ) ; } return vertRes && fragRes ; } protected void validate ( ) { pgl . getProgramiv ( glProgram , PGL . LINK_STATUS , intBuffer ) ; boolean linked = intBuffer . get ( 0 ) == 0 ? false : true ; if ( ! linked ) { PGraphics . showException ( "Cannot link shader program:\n" + pgl . getProgramInfoLog ( glProgram ) ) ; } pgl . validateProgram ( glProgram ) ; pgl . getProgramiv ( glProgram , PGL . VALIDATE_STATUS , intBuffer ) ; boolean validated = intBuffer . get ( 0 ) == 0 ? false : true ; if ( ! validated ) { PGraphics . showException ( "Cannot validate shader program:\n" + pgl . getProgramInfoLog ( glProgram ) ) ; } } protected boolean contextIsOutdated ( ) { boolean outdated = ! pgl . contextIsCurrent ( context ) ; if ( outdated ) { PGraphicsOpenGL . removeGLSLProgramObject ( glProgram , context ) ; PGraphicsOpenGL . removeGLSLVertShaderObject ( glVertex , context ) ; PGraphicsOpenGL . removeGLSLFragShaderObject ( glFragment , context ) ; glProgram = 0 ; glVertex = 0 ; glFragment = 0 ; } return outdated ; } protected boolean hasVertexShader ( ) { return vertexShaderSource != null && 0 < vertexShaderSource . length ; } protected boolean hasFragmentShader ( ) { return fragmentShaderSource != null && 0 < fragmentShaderSource . length ; } protected boolean compileVertexShader ( ) { glVertex = PGraphicsOpenGL . createGLSLVertShaderObject ( context , pgl ) ; pgl . shaderSource ( glVertex , PApplet . join ( vertexShaderSource , "\n" ) ) ; pgl . compileShader ( glVertex ) ; pgl . getShaderiv ( glVertex , PGL . COMPILE_STATUS , intBuffer ) ; boolean compiled = intBuffer . get ( 0 ) == 0 ? false : true ; if ( ! compiled ) { PGraphics . showException ( "Cannot compile vertex shader:\n" + pgl . getShaderInfoLog ( glVertex ) ) ; return false ; } else { return true ; } } protected boolean compileFragmentShader ( ) { glFragment = PGraphicsOpenGL . createGLSLFragShaderObject ( context , pgl ) ; pgl . shaderSource ( glFragment , PApplet . join ( fragmentShaderSource , "\n" ) ) ; pgl . compileShader ( glFragment ) ; pgl . getShaderiv ( glFragment , PGL . COMPILE_STATUS , intBuffer ) ; boolean compiled = intBuffer . get ( 0 ) == 0 ? false : true ; if ( ! compiled ) { PGraphics . showException ( "Cannot compile fragment shader:\n" + pgl . getShaderInfoLog ( glFragment ) ) ; return false ; } else { return true ; } } protected void dispose ( ) { if ( glVertex != 0 ) { PGraphicsOpenGL . deleteGLSLVertShaderObject ( glVertex , context , pgl ) ; glVertex = 0 ; } if ( glFragment != 0 ) { PGraphicsOpenGL . deleteGLSLFragShaderObject ( glFragment , context , pgl ) ; glFragment = 0 ; } if ( glProgram != 0 ) { PGraphicsOpenGL . deleteGLSLProgramObject ( glProgram , context , pgl ) ; glProgram = 0 ; } } static protected int getShaderType ( String [ ] source , int defaultType ) { for ( int i = 0 ; i < source . length ; i ++ ) { String line = source [ i ] . trim ( ) ; if ( PApplet . match ( line , pointShaderAttrRegexp ) != null ) return PShader . POINT ; else if ( PApplet . match ( line , lineShaderAttrRegexp ) != null ) return PShader . LINE ; else if ( PApplet . match ( line , pointShaderDefRegexp ) != null ) return PShader . POINT ; else if ( PApplet . match ( line , lineShaderDefRegexp ) != null ) return PShader . LINE ; else if ( PApplet . match ( line , colorShaderDefRegexp ) != null ) return PShader . COLOR ; else if ( PApplet . match ( line , lightShaderDefRegexp ) != null ) return PShader . LIGHT ; else if ( PApplet . match ( line , texShaderDefRegexp ) != null ) return PShader . TEXTURE ; else if ( PApplet . match ( line , texlightShaderDefRegexp ) != null ) return PShader . TEXLIGHT ; else if ( PApplet . match ( line , polyShaderDefRegexp ) != null ) return PShader . POLY ; else if ( PApplet . match ( line , triShaderAttrRegexp ) != null ) return PShader . POLY ; else if ( PApplet . match ( line , quadShaderAttrRegexp ) != null ) return PShader . POLY ; } return defaultType ; } protected int getType ( ) { return type ; } protected void setType ( int type ) { this . type = type ; } protected boolean hasType ( ) { return POINT <= type && type <= TEXLIGHT ; } protected boolean isPointShader ( ) { return type == POINT ; } protected boolean isLineShader ( ) { return type == LINE ; } protected boolean isPolyShader ( ) { return POLY <= type && type <= TEXLIGHT ; } protected boolean checkPolyType ( int type ) { if ( getType ( ) == PShader . POLY ) return true ; if ( getType ( ) != type ) { if ( type == TEXLIGHT ) { PGraphics . showWarning ( PGraphicsOpenGL . NO_TEXLIGHT_SHADER_ERROR ) ; } else if ( type == LIGHT ) { PGraphics . showWarning ( PGraphicsOpenGL . NO_LIGHT_SHADER_ERROR ) ; } else if ( type == TEXTURE ) { PGraphics . showWarning ( PGraphicsOpenGL . NO_TEXTURE_SHADER_ERROR ) ; } else if ( type == COLOR ) { PGraphics . showWarning ( PGraphicsOpenGL . NO_COLOR_SHADER_ERROR ) ; } return false ; } return true ; } protected int getLastTexUnit ( ) { return texUnits == null ? - 1 : texUnits . size ( ) - 1 ; } protected void setRenderer ( PGraphicsOpenGL pg ) { this . currentPG = pg ; } protected void loadAttributes ( ) { if ( loadedAttributes ) return ; vertexLoc = getAttributeLoc ( "vertex" ) ; if ( vertexLoc == - 1 ) vertexLoc = getAttributeLoc ( "position" ) ; colorLoc = getAttributeLoc ( "color" ) ; texCoordLoc = getAttributeLoc ( "texCoord" ) ; normalLoc = getAttributeLoc ( "normal" ) ; ambientLoc = getAttributeLoc ( "ambient" ) ; specularLoc = getAttributeLoc ( "specular" ) ; emissiveLoc = getAttributeLoc ( "emissive" ) ; shininessLoc = getAttributeLoc ( "shininess" ) ; directionLoc = getAttributeLoc ( "direction" ) ; offsetLoc = getAttributeLoc ( "offset" ) ; directionLoc = getAttributeLoc ( "direction" ) ; offsetLoc = getAttributeLoc ( "offset" ) ; loadedAttributes = true ; } protected void loadUniforms ( ) { if ( loadedUniforms ) return ; transformMatLoc = getUniformLoc ( "transform" ) ; if ( transformMatLoc == - 1 ) transformMatLoc = getUniformLoc ( "transformMatrix" ) ; modelviewMatLoc = getUniformLoc ( "modelview" ) ; if ( modelviewMatLoc == - 1 ) modelviewMatLoc = getUniformLoc ( "modelviewMatrix" ) ; projectionMatLoc = getUniformLoc ( "projection" ) ; if ( projectionMatLoc == - 1 ) projectionMatLoc = getUniformLoc ( "projectionMatrix" ) ; viewportLoc = getUniformLoc ( "viewport" ) ; ppixelsLoc = getUniformLoc ( "ppixels" ) ; normalMatLoc = getUniformLoc ( "normalMatrix" ) ; lightCountLoc = getUniformLoc ( "lightCount" ) ; lightPositionLoc = getUniformLoc ( "lightPosition" ) ; lightNormalLoc = getUniformLoc ( "lightNormal" ) ; lightAmbientLoc = getUniformLoc ( "lightAmbient" ) ; lightDiffuseLoc = getUniformLoc ( "lightDiffuse" ) ; lightSpecularLoc = getUniformLoc ( "lightSpecular" ) ; lightFalloffLoc = getUniformLoc ( "lightFalloff" ) ; lightSpotLoc = getUniformLoc ( "lightSpot" ) ; textureLoc = getUniformLoc ( "texture" ) ; if ( textureLoc == - 1 ) { textureLoc = getUniformLoc ( "texMap" ) ; } texMatrixLoc = getUniformLoc ( "texMatrix" ) ; texOffsetLoc = getUniformLoc ( "texOffset" ) ; perspectiveLoc = getUniformLoc ( "perspective" ) ; scaleLoc = getUniformLoc ( "scale" ) ; loadedUniforms = true ; } protected void setCommonUniforms ( ) { if ( - 1 < transformMatLoc ) { currentPG . updateGLProjmodelview ( ) ; setUniformMatrix ( transformMatLoc , currentPG . glProjmodelview ) ; } if ( - 1 < modelviewMatLoc ) { currentPG . updateGLModelview ( ) ; setUniformMatrix ( modelviewMatLoc , currentPG . glModelview ) ; } if ( - 1 < projectionMatLoc ) { currentPG . updateGLProjection ( ) ; setUniformMatrix ( projectionMatLoc , currentPG . glProjection ) ; } if ( - 1 < viewportLoc ) { float x = currentPG . viewport . get ( 0 ) ; float y = currentPG . viewport . get ( 1 ) ; float w = currentPG . viewport . get ( 2 ) ; float h = currentPG . viewport . get ( 3 ) ; setUniformValue ( viewportLoc , x , y , w , h ) ; } if ( - 1 < ppixelsLoc ) { ppixelsUnit = getLastTexUnit ( ) + 1 ; setUniformValue ( ppixelsLoc , ppixelsUnit ) ; pgl . activeTexture ( PGL . TEXTURE0 + ppixelsUnit ) ; currentPG . bindFrontTexture ( ) ; } else { ppixelsUnit = - 1 ; } } protected void bindTyped ( ) { if ( currentPG == null ) { setRenderer ( primaryPG . getCurrentPG ( ) ) ; loadAttributes ( ) ; loadUniforms ( ) ; } setCommonUniforms ( ) ; if ( - 1 < vertexLoc ) pgl . enableVertexAttribArray ( vertexLoc ) ; if ( - 1 < colorLoc ) pgl . enableVertexAttribArray ( colorLoc ) ; if ( - 1 < texCoordLoc ) pgl . enableVertexAttribArray ( texCoordLoc ) ; if ( - 1 < normalLoc ) pgl . enableVertexAttribArray ( normalLoc ) ; if ( - 1 < normalMatLoc ) { currentPG . updateGLNormal ( ) ; setUniformMatrix ( normalMatLoc , currentPG . glNormal ) ; } if ( - 1 < ambientLoc ) pgl . enableVertexAttribArray ( ambientLoc ) ; if ( - 1 < specularLoc ) pgl . enableVertexAttribArray ( specularLoc ) ; if ( - 1 < emissiveLoc ) pgl . enableVertexAttribArray ( emissiveLoc ) ; if ( - 1 < shininessLoc ) pgl . enableVertexAttribArray ( shininessLoc ) ; int count = currentPG . lightCount ; setUniformValue ( lightCountLoc , count ) ; if ( 0 < count ) { setUniformVector ( lightPositionLoc , currentPG . lightPosition , 4 , count ) ; setUniformVector ( lightNormalLoc , currentPG . lightNormal , 3 , count ) ; setUniformVector ( lightAmbientLoc , currentPG . lightAmbient , 3 , count ) ; setUniformVector ( lightDiffuseLoc , currentPG . lightDiffuse , 3 , count ) ; setUniformVector ( lightSpecularLoc , currentPG . lightSpecular , 3 , count ) ; setUniformVector ( lightFalloffLoc , currentPG . lightFalloffCoefficients , 3 , count ) ; setUniformVector ( lightSpotLoc , currentPG . lightSpotParameters , 2 , count ) ; } if ( - 1 < directionLoc ) pgl . enableVertexAttribArray ( directionLoc ) ; if ( - 1 < offsetLoc ) pgl . enableVertexAttribArray ( offsetLoc ) ; if ( - 1 < perspectiveLoc ) { if ( currentPG . getHint ( ENABLE_STROKE_PERSPECTIVE ) && currentPG . nonOrthoProjection ( ) ) { setUniformValue ( perspectiveLoc , 1 ) ; } else { setUniformValue ( perspectiveLoc , 0 ) ; } } if ( - 1 < scaleLoc ) { if ( currentPG . getHint ( DISABLE_OPTIMIZED_STROKE ) ) { setUniformValue ( scaleLoc , 1.0f , 1.0f , 1.0f ) ; } else { float f = PGL . STROKE_DISPLACEMENT ; if ( currentPG . orthoProjection ( ) ) { setUniformValue ( scaleLoc , 1 , 1 , f ) ; } else { setUniformValue ( scaleLoc , f , f , f ) ; } } } } protected void unbindTyped ( ) { if ( - 1 < offsetLoc ) pgl . disableVertexAttribArray ( offsetLoc ) ; if ( - 1 < directionLoc ) pgl . disableVertexAttribArray ( directionLoc ) ; if ( - 1 < textureLoc && texture != null ) { pgl . activeTexture ( PGL . TEXTURE0 + texUnit ) ; texture . unbind ( ) ; pgl . activeTexture ( PGL . TEXTURE0 ) ; texture = null ; } if ( - 1 < ambientLoc ) pgl . disableVertexAttribArray ( ambientLoc ) ; if ( - 1 < specularLoc ) pgl . disableVertexAttribArray ( specularLoc ) ; if ( - 1 < emissiveLoc ) pgl . disableVertexAttribArray ( emissiveLoc ) ; if ( - 1 < shininessLoc ) pgl . disableVertexAttribArray ( shininessLoc ) ; if ( - 1 < vertexLoc ) pgl . disableVertexAttribArray ( vertexLoc ) ; if ( - 1 < colorLoc ) pgl . disableVertexAttribArray ( colorLoc ) ; if ( - 1 < texCoordLoc ) pgl . disableVertexAttribArray ( texCoordLoc ) ; if ( - 1 < normalLoc ) pgl . disableVertexAttribArray ( normalLoc ) ; if ( - 1 < ppixelsLoc ) { pgl . requestFBOLayer ( ) ; pgl . activeTexture ( PGL . TEXTURE0 + ppixelsUnit ) ; currentPG . unbindFrontTexture ( ) ; pgl . activeTexture ( PGL . TEXTURE0 ) ; } pgl . bindBuffer ( PGL . ARRAY_BUFFER , 0 ) ; } protected void setTexture ( Texture tex ) { texture = tex ; float scaleu = 1 ; float scalev = 1 ; float dispu = 0 ; float dispv = 0 ; if ( tex != null ) { if ( tex . invertedX ( ) ) { scaleu = - 1 ; dispu = 1 ; } if ( tex . invertedY ( ) ) { scalev = - 1 ; dispv = 1 ; } scaleu *= tex . maxTexcoordU ( ) ; dispu *= tex . maxTexcoordU ( ) ; scalev *= tex . maxTexcoordV ( ) ; dispv *= tex . maxTexcoordV ( ) ; setUniformValue ( texOffsetLoc , 1.0f / tex . width , 1.0f / tex . height ) ; if ( - 1 < textureLoc ) { texUnit = - 1 < ppixelsUnit ? ppixelsUnit + 1 : getLastTexUnit ( ) + 1 ; setUniformValue ( textureLoc , texUnit ) ; pgl . activeTexture ( PGL . TEXTURE0 + texUnit ) ; tex . bind ( ) ; } } if ( - 1 < texMatrixLoc ) { if ( tcmat == null ) { tcmat = new float [ 16 ] ; } tcmat [ 0 ] = scaleu ; tcmat [ 4 ] = 0 ; tcmat [ 8 ] = 0 ; tcmat [ 12 ] = dispu ; tcmat [ 1 ] = 0 ; tcmat [ 5 ] = scalev ; tcmat [ 9 ] = 0 ; tcmat [ 13 ] = dispv ; tcmat [ 2 ] = 0 ; tcmat [ 6 ] = 0 ; tcmat [ 10 ] = 0 ; tcmat [ 14 ] = 0 ; tcmat [ 3 ] = 0 ; tcmat [ 7 ] = 0 ; tcmat [ 11 ] = 0 ; tcmat [ 15 ] = 0 ; setUniformMatrix ( texMatrixLoc , tcmat ) ; } } protected boolean supportsTexturing ( ) { return - 1 < textureLoc ; } protected boolean supportLighting ( ) { return - 1 < lightCountLoc || - 1 < lightPositionLoc || - 1 < lightNormalLoc ; } protected boolean accessTexCoords ( ) { return - 1 < texCoordLoc ; } protected boolean accessNormals ( ) { return - 1 < normalLoc ; } protected boolean accessLightAttribs ( ) { return - 1 < ambientLoc || - 1 < specularLoc || - 1 < emissiveLoc || - 1 < shininessLoc ; } protected void setVertexAttribute ( int vboId , int size , int type , int stride , int offset ) { setAttributeVBO ( vertexLoc , vboId , size , type , false , stride , offset ) ; } protected void setColorAttribute ( int vboId , int size , int type , int stride , int offset ) { setAttributeVBO ( colorLoc , vboId , size , type , true , stride , offset ) ; } protected void setNormalAttribute ( int vboId , int size , int type , int stride , int offset ) { setAttributeVBO ( normalLoc , vboId , size , type , false , stride , offset ) ; } protected void setTexcoordAttribute ( int vboId , int size , int type , int stride , int offset ) { setAttributeVBO ( texCoordLoc , vboId , size , type , false , stride , offset ) ; } protected void setAmbientAttribute ( int vboId , int size , int type , int stride , int offset ) { setAttributeVBO ( ambientLoc , vboId , size , type , true , stride , offset ) ; } protected void setSpecularAttribute ( int vboId , int size , int type , int stride , int offset ) { setAttributeVBO ( specularLoc , vboId , size , type , true , stride , offset ) ; } protected void setEmissiveAttribute ( int vboId , int size , int type , int stride , int offset ) { setAttributeVBO ( emissiveLoc , vboId , size , type , true , stride , offset ) ; } protected void setShininessAttribute ( int vboId , int size , int type , int stride , int offset ) { setAttributeVBO ( shininessLoc , vboId , size , type , false , stride , offset ) ; } protected void setLineAttribute ( int vboId , int size , int type , int stride , int offset ) { setAttributeVBO ( directionLoc , vboId , size , type , false , stride , offset ) ; } protected void setPointAttribute ( int vboId , int size , int type , int stride , int offset ) { setAttributeVBO ( offsetLoc , vboId , size , type , false , stride , offset ) ; } protected static class UniformValue { static final int INT1 = 0 ; static final int INT2 = 1 ; static final int INT3 = 2 ; static final int INT4 = 3 ; static final int FLOAT1 = 4 ; static final int FLOAT2 = 5 ; static final int FLOAT3 = 6 ; static final int FLOAT4 = 7 ; static final int INT1VEC = 8 ; static final int INT2VEC = 9 ; static final int INT3VEC = 10 ; static final int INT4VEC = 11 ; static final int FLOAT1VEC = 12 ; static final int FLOAT2VEC = 13 ; static final int FLOAT3VEC = 14 ; static final int FLOAT4VEC = 15 ; static final int MAT2 = 16 ; static final int MAT3 = 17 ; static final int MAT4 = 18 ; static final int SAMPLER2D = 19 ; int type ; Object value ; UniformValue ( int type , Object value ) { this . type = type ; this . value = value ; } } }
package processing . opengl ; import processing . core . PGraphics ; import processing . core . PShape ; import processing . core . PShapeOBJ ; public class PGraphics3D extends PGraphicsOpenGL { public PGraphics3D ( ) { super ( ) ; } @ Override public boolean is2D ( ) { return false ; } @ Override public boolean is3D ( ) { return true ; } @ Override protected void defaultPerspective ( ) { perspective ( ) ; } @ Override protected void defaultCamera ( ) { camera ( ) ; } @ Override protected void begin2D ( ) { pushProjection ( ) ; ortho ( 0 , width , 0 , height , - 1 , + 1 ) ; pushMatrix ( ) ; float centerX = width / 2 ; float centerY = height / 2 ; modelview . reset ( ) ; modelview . translate ( - centerX , - centerY ) ; modelviewInv . set ( modelview ) ; modelviewInv . invert ( ) ; camera . set ( modelview ) ; cameraInv . set ( modelviewInv ) ; updateProjmodelview ( ) ; } @ Override protected void end2D ( ) { popMatrix ( ) ; popProjection ( ) ; } static protected boolean isSupportedExtension ( String extension ) { return extension . equals ( "obj" ) ; } static protected PShape loadShapeImpl ( PGraphics pg , String filename , String extension ) { PShapeOBJ obj = null ; if ( extension . equals ( "obj" ) ) { obj = new PShapeOBJ ( pg . parent , filename ) ; int prevTextureMode = pg . textureMode ; pg . textureMode = NORMAL ; PShapeOpenGL p3d = PShapeOpenGL . createShape ( ( PGraphicsOpenGL ) pg , obj ) ; pg . textureMode = prevTextureMode ; return p3d ; } return null ; } }
package processing . opengl ; import processing . core . PMatrix2D ; public class LineStroker { private LineStroker output ; private int capStyle ; private int joinStyle ; private int m00 , m01 ; private int m10 , m11 ; private int lineWidth2 ; private long scaledLineWidth2 ; private int numPenSegments ; private int [ ] pen_dx ; private int [ ] pen_dy ; private boolean [ ] penIncluded ; private int [ ] join ; private int [ ] offset = new int [ 2 ] ; private int [ ] reverse = new int [ 100 ] ; private int [ ] miter = new int [ 2 ] ; private long miterLimitSq ; private int prev ; private int rindex ; private boolean started ; private boolean lineToOrigin ; private boolean joinToOrigin ; private int sx0 , sy0 , sx1 , sy1 , x0 , y0 ; private int scolor0 , pcolor0 , color0 ; private int mx0 , my0 , omx , omy ; private int px0 , py0 ; private double m00_2_m01_2 ; private double m10_2_m11_2 ; private double m00_m10_m01_m11 ; public LineStroker ( ) { } public LineStroker ( LineStroker output , int lineWidth , int capStyle , int joinStyle , int miterLimit , PMatrix2D transform ) { setOutput ( output ) ; setParameters ( lineWidth , capStyle , joinStyle , miterLimit , transform ) ; } public void setOutput ( LineStroker output ) { this . output = output ; } public void setParameters ( int lineWidth , int capStyle , int joinStyle , int miterLimit , PMatrix2D transform ) { this . m00 = LinePath . FloatToS15_16 ( transform . m00 ) ; this . m01 = LinePath . FloatToS15_16 ( transform . m01 ) ; this . m10 = LinePath . FloatToS15_16 ( transform . m10 ) ; this . m11 = LinePath . FloatToS15_16 ( transform . m11 ) ; this . lineWidth2 = lineWidth > > 1 ; this . scaledLineWidth2 = ( ( long ) m00 * lineWidth2 ) > > 16 ; this . capStyle = capStyle ; this . joinStyle = joinStyle ; this . m00_2_m01_2 = ( double ) m00 * m00 + ( double ) m01 * m01 ; this . m10_2_m11_2 = ( double ) m10 * m10 + ( double ) m11 * m11 ; this . m00_m10_m01_m11 = ( double ) m00 * m10 + ( double ) m01 * m11 ; double dm00 = m00 / 65536.0 ; double dm01 = m01 / 65536.0 ; double dm10 = m10 / 65536.0 ; double dm11 = m11 / 65536.0 ; double determinant = dm00 * dm11 - dm01 * dm10 ; if ( joinStyle == LinePath . JOIN_MITER ) { double limit = ( miterLimit / 65536.0 ) * ( lineWidth2 / 65536.0 ) * determinant ; double limitSq = limit * limit ; this . miterLimitSq = ( long ) ( limitSq * 65536.0 * 65536.0 ) ; } this . numPenSegments = ( int ) ( 3.14159f * lineWidth / 65536.0f ) ; if ( pen_dx == null || pen_dx . length < numPenSegments ) { this . pen_dx = new int [ numPenSegments ] ; this . pen_dy = new int [ numPenSegments ] ; this . penIncluded = new boolean [ numPenSegments ] ; this . join = new int [ 2 * numPenSegments ] ; } for ( int i = 0 ; i < numPenSegments ; i ++ ) { double r = lineWidth / 2.0 ; double theta = i * 2 * Math . PI / numPenSegments ; double cos = Math . cos ( theta ) ; double sin = Math . sin ( theta ) ; pen_dx [ i ] = ( int ) ( r * ( dm00 * cos + dm01 * sin ) ) ; pen_dy [ i ] = ( int ) ( r * ( dm10 * cos + dm11 * sin ) ) ; } prev = LinePath . SEG_CLOSE ; rindex = 0 ; started = false ; lineToOrigin = false ; } private void computeOffset ( int x0 , int y0 , int x1 , int y1 , int [ ] m ) { long lx = ( long ) x1 - ( long ) x0 ; long ly = ( long ) y1 - ( long ) y0 ; int dx , dy ; if ( m00 > 0 && m00 == m11 && m01 == 0 & m10 == 0 ) { long ilen = LinePath . hypot ( lx , ly ) ; if ( ilen == 0 ) { dx = dy = 0 ; } else { dx = ( int ) ( ( ly * scaledLineWidth2 ) / ilen ) ; dy = ( int ) ( - ( lx * scaledLineWidth2 ) / ilen ) ; } } else { double dlx = x1 - x0 ; double dly = y1 - y0 ; double det = ( double ) m00 * m11 - ( double ) m01 * m10 ; int sdet = ( det > 0 ) ? 1 : - 1 ; double a = dly * m00 - dlx * m10 ; double b = dly * m01 - dlx * m11 ; double dh = LinePath . hypot ( a , b ) ; double div = sdet * lineWidth2 / ( 65536.0 * dh ) ; double ddx = dly * m00_2_m01_2 - dlx * m00_m10_m01_m11 ; double ddy = dly * m00_m10_m01_m11 - dlx * m10_2_m11_2 ; dx = ( int ) ( ddx * div ) ; dy = ( int ) ( ddy * div ) ; } m [ 0 ] = dx ; m [ 1 ] = dy ; } private void ensureCapacity ( int newrindex ) { if ( reverse . length < newrindex ) { int [ ] tmp = new int [ Math . max ( newrindex , 6 * reverse . length / 5 ) ] ; System . arraycopy ( reverse , 0 , tmp , 0 , rindex ) ; this . reverse = tmp ; } } private boolean isCCW ( int x0 , int y0 , int x1 , int y1 , int x2 , int y2 ) { int dx0 = x1 - x0 ; int dy0 = y1 - y0 ; int dx1 = x2 - x1 ; int dy1 = y2 - y1 ; return ( long ) dx0 * dy1 < ( long ) dy0 * dx1 ; } private boolean side ( int x , int y , int x0 , int y0 , int x1 , int y1 ) { long lx = x ; long ly = y ; long lx0 = x0 ; long ly0 = y0 ; long lx1 = x1 ; long ly1 = y1 ; return ( ly0 - ly1 ) * lx + ( lx1 - lx0 ) * ly + ( lx0 * ly1 - lx1 * ly0 ) > 0 ; } private int computeRoundJoin ( int cx , int cy , int xa , int ya , int xb , int yb , int side , boolean flip , int [ ] join ) { int px , py ; int ncoords = 0 ; boolean centerSide ; if ( side == 0 ) { centerSide = side ( cx , cy , xa , ya , xb , yb ) ; } else { centerSide = ( side == 1 ) ? true : false ; } for ( int i = 0 ; i < numPenSegments ; i ++ ) { px = cx + pen_dx [ i ] ; py = cy + pen_dy [ i ] ; boolean penSide = side ( px , py , xa , ya , xb , yb ) ; if ( penSide != centerSide ) { penIncluded [ i ] = true ; } else { penIncluded [ i ] = false ; } } int start = - 1 , end = - 1 ; for ( int i = 0 ; i < numPenSegments ; i ++ ) { if ( penIncluded [ i ] && ! penIncluded [ ( i + numPenSegments - 1 ) % numPenSegments ] ) { start = i ; } if ( penIncluded [ i ] && ! penIncluded [ ( i + 1 ) % numPenSegments ] ) { end = i ; } } if ( end < start ) { end += numPenSegments ; } if ( start != - 1 && end != - 1 ) { long dxa = cx + pen_dx [ start ] - xa ; long dya = cy + pen_dy [ start ] - ya ; long dxb = cx + pen_dx [ start ] - xb ; long dyb = cy + pen_dy [ start ] - yb ; boolean rev = ( dxa * dxa + dya * dya > dxb * dxb + dyb * dyb ) ; int i = rev ? end : start ; int incr = rev ? - 1 : 1 ; while ( true ) { int idx = i % numPenSegments ; px = cx + pen_dx [ idx ] ; py = cy + pen_dy [ idx ] ; join [ ncoords ++ ] = px ; join [ ncoords ++ ] = py ; if ( i == ( rev ? start : end ) ) { break ; } i += incr ; } } return ncoords / 2 ; } private static final long ROUND_JOIN_THRESHOLD = 100000000L ; private static final long ROUND_JOIN_INTERNAL_THRESHOLD = 1000000000L ; private void drawRoundJoin ( int x , int y , int omx , int omy , int mx , int my , int side , int color , boolean flip , boolean rev , long threshold ) { if ( ( omx == 0 && omy == 0 ) || ( mx == 0 && my == 0 ) ) { return ; } long domx = ( long ) omx - mx ; long domy = ( long ) omy - my ; long len = domx * domx + domy * domy ; if ( len < threshold ) { return ; } if ( rev ) { omx = - omx ; omy = - omy ; mx = - mx ; my = - my ; } int bx0 = x + omx ; int by0 = y + omy ; int bx1 = x + mx ; int by1 = y + my ; int npoints = computeRoundJoin ( x , y , bx0 , by0 , bx1 , by1 , side , flip , join ) ; for ( int i = 0 ; i < npoints ; i ++ ) { emitLineTo ( join [ 2 * i ] , join [ 2 * i + 1 ] , color , rev ) ; } } private void computeMiter ( int ix0 , int iy0 , int ix1 , int iy1 , int ix0p , int iy0p , int ix1p , int iy1p , int [ ] m ) { long x0 = ix0 ; long y0 = iy0 ; long x1 = ix1 ; long y1 = iy1 ; long x0p = ix0p ; long y0p = iy0p ; long x1p = ix1p ; long y1p = iy1p ; long x10 = x1 - x0 ; long y10 = y1 - y0 ; long x10p = x1p - x0p ; long y10p = y1p - y0p ; long den = ( x10 * y10p - x10p * y10 ) > > 16 ; if ( den == 0 ) { m [ 0 ] = ix0 ; m [ 1 ] = iy0 ; return ; } long t = ( x1p * ( y0 - y0p ) - x0 * y10p + x0p * ( y1p - y0 ) ) > > 16 ; m [ 0 ] = ( int ) ( x0 + ( t * x10 ) / den ) ; m [ 1 ] = ( int ) ( y0 + ( t * y10 ) / den ) ; } private void drawMiter ( int px0 , int py0 , int x0 , int y0 , int x1 , int y1 , int omx , int omy , int mx , int my , int color , boolean rev ) { if ( mx == omx && my == omy ) { return ; } if ( px0 == x0 && py0 == y0 ) { return ; } if ( x0 == x1 && y0 == y1 ) { return ; } if ( rev ) { omx = - omx ; omy = - omy ; mx = - mx ; my = - my ; } computeMiter ( px0 + omx , py0 + omy , x0 + omx , y0 + omy , x0 + mx , y0 + my , x1 + mx , y1 + my , miter ) ; long dx = ( long ) miter [ 0 ] - x0 ; long dy = ( long ) miter [ 1 ] - y0 ; long a = ( dy * m00 - dx * m10 ) > > 16 ; long b = ( dy * m01 - dx * m11 ) > > 16 ; long lenSq = a * a + b * b ; if ( lenSq < miterLimitSq ) { emitLineTo ( miter [ 0 ] , miter [ 1 ] , color , rev ) ; } } public void moveTo ( int x0 , int y0 , int c0 ) { if ( lineToOrigin ) { lineToImpl ( sx0 , sy0 , scolor0 , joinToOrigin ) ; lineToOrigin = false ; } if ( prev == LinePath . SEG_LINETO ) { finish ( ) ; } this . sx0 = this . x0 = x0 ; this . sy0 = this . y0 = y0 ; this . scolor0 = this . color0 = c0 ; this . rindex = 0 ; this . started = false ; this . joinSegment = false ; this . prev = LinePath . SEG_MOVETO ; } boolean joinSegment = false ; public void lineJoin ( ) { this . joinSegment = true ; } public void lineTo ( int x1 , int y1 , int c1 ) { if ( lineToOrigin ) { if ( x1 == sx0 && y1 == sy0 ) { return ; } lineToImpl ( sx0 , sy0 , scolor0 , joinToOrigin ) ; lineToOrigin = false ; } else if ( x1 == x0 && y1 == y0 ) { return ; } else if ( x1 == sx0 && y1 == sy0 ) { lineToOrigin = true ; joinToOrigin = joinSegment ; joinSegment = false ; return ; } lineToImpl ( x1 , y1 , c1 , joinSegment ) ; joinSegment = false ; } private void lineToImpl ( int x1 , int y1 , int c1 , boolean joinSegment ) { computeOffset ( x0 , y0 , x1 , y1 , offset ) ; int mx = offset [ 0 ] ; int my = offset [ 1 ] ; if ( ! started ) { emitMoveTo ( x0 + mx , y0 + my , color0 ) ; this . sx1 = x1 ; this . sy1 = y1 ; this . mx0 = mx ; this . my0 = my ; started = true ; } else { boolean ccw = isCCW ( px0 , py0 , x0 , y0 , x1 , y1 ) ; if ( joinSegment ) { if ( joinStyle == LinePath . JOIN_MITER ) { drawMiter ( px0 , py0 , x0 , y0 , x1 , y1 , omx , omy , mx , my , color0 , ccw ) ; } else if ( joinStyle == LinePath . JOIN_ROUND ) { drawRoundJoin ( x0 , y0 , omx , omy , mx , my , 0 , color0 , false , ccw , ROUND_JOIN_THRESHOLD ) ; } } else { drawRoundJoin ( x0 , y0 , omx , omy , mx , my , 0 , color0 , false , ccw , ROUND_JOIN_INTERNAL_THRESHOLD ) ; } emitLineTo ( x0 , y0 , color0 , ! ccw ) ; } emitLineTo ( x0 + mx , y0 + my , color0 , false ) ; emitLineTo ( x1 + mx , y1 + my , c1 , false ) ; emitLineTo ( x0 - mx , y0 - my , color0 , true ) ; emitLineTo ( x1 - mx , y1 - my , c1 , true ) ; this . omx = mx ; this . omy = my ; this . px0 = x0 ; this . py0 = y0 ; this . pcolor0 = color0 ; this . x0 = x1 ; this . y0 = y1 ; this . color0 = c1 ; this . prev = LinePath . SEG_LINETO ; } public void close ( ) { if ( lineToOrigin ) { lineToOrigin = false ; } if ( ! started ) { finish ( ) ; return ; } computeOffset ( x0 , y0 , sx0 , sy0 , offset ) ; int mx = offset [ 0 ] ; int my = offset [ 1 ] ; boolean ccw = isCCW ( px0 , py0 , x0 , y0 , sx0 , sy0 ) ; if ( joinSegment ) { if ( joinStyle == LinePath . JOIN_MITER ) { drawMiter ( px0 , py0 , x0 , y0 , sx0 , sy0 , omx , omy , mx , my , pcolor0 , ccw ) ; } else if ( joinStyle == LinePath . JOIN_ROUND ) { drawRoundJoin ( x0 , y0 , omx , omy , mx , my , 0 , color0 , false , ccw , ROUND_JOIN_THRESHOLD ) ; } } else { drawRoundJoin ( x0 , y0 , omx , omy , mx , my , 0 , color0 , false , ccw , ROUND_JOIN_INTERNAL_THRESHOLD ) ; } emitLineTo ( x0 + mx , y0 + my , color0 ) ; emitLineTo ( sx0 + mx , sy0 + my , scolor0 ) ; ccw = isCCW ( x0 , y0 , sx0 , sy0 , sx1 , sy1 ) ; if ( ! ccw ) { if ( joinStyle == LinePath . JOIN_MITER ) { drawMiter ( x0 , y0 , sx0 , sy0 , sx1 , sy1 , mx , my , mx0 , my0 , color0 , false ) ; } else if ( joinStyle == LinePath . JOIN_ROUND ) { drawRoundJoin ( sx0 , sy0 , mx , my , mx0 , my0 , 0 , scolor0 , false , false , ROUND_JOIN_THRESHOLD ) ; } } emitLineTo ( sx0 + mx0 , sy0 + my0 , scolor0 ) ; emitLineTo ( sx0 - mx0 , sy0 - my0 , scolor0 ) ; if ( ccw ) { if ( joinStyle == LinePath . JOIN_MITER ) { drawMiter ( x0 , y0 , sx0 , sy0 , sx1 , sy1 , - mx , - my , - mx0 , - my0 , color0 , false ) ; } else if ( joinStyle == LinePath . JOIN_ROUND ) { drawRoundJoin ( sx0 , sy0 , - mx , - my , - mx0 , - my0 , 0 , scolor0 , true , false , ROUND_JOIN_THRESHOLD ) ; } } emitLineTo ( sx0 - mx , sy0 - my , scolor0 ) ; emitLineTo ( x0 - mx , y0 - my , color0 ) ; for ( int i = rindex - 3 ; i >= 0 ; i -= 3 ) { emitLineTo ( reverse [ i ] , reverse [ i + 1 ] , reverse [ i + 2 ] ) ; } this . x0 = this . sx0 ; this . y0 = this . sy0 ; this . rindex = 0 ; this . started = false ; this . joinSegment = false ; this . prev = LinePath . SEG_CLOSE ; emitClose ( ) ; } public void end ( ) { if ( lineToOrigin ) { lineToImpl ( sx0 , sy0 , scolor0 , joinToOrigin ) ; lineToOrigin = false ; } if ( prev == LinePath . SEG_LINETO ) { finish ( ) ; } output . end ( ) ; this . joinSegment = false ; this . prev = LinePath . SEG_MOVETO ; } long lineLength ( long ldx , long ldy ) { long ldet = ( ( long ) m00 * m11 - ( long ) m01 * m10 ) > > 16 ; long la = ( ldy * m00 - ldx * m10 ) / ldet ; long lb = ( ldy * m01 - ldx * m11 ) / ldet ; long llen = ( int ) LinePath . hypot ( la , lb ) ; return llen ; } private void finish ( ) { if ( capStyle == LinePath . CAP_ROUND ) { drawRoundJoin ( x0 , y0 , omx , omy , - omx , - omy , 1 , color0 , false , false , ROUND_JOIN_THRESHOLD ) ; } else if ( capStyle == LinePath . CAP_SQUARE ) { long ldx = px0 - x0 ; long ldy = py0 - y0 ; long llen = lineLength ( ldx , ldy ) ; if ( 0 < llen ) { long s = ( long ) lineWidth2 * 65536 / llen ; int capx = x0 - ( int ) ( ldx * s > > 16 ) ; int capy = y0 - ( int ) ( ldy * s > > 16 ) ; emitLineTo ( capx + omx , capy + omy , color0 ) ; emitLineTo ( capx - omx , capy - omy , color0 ) ; } } for ( int i = rindex - 3 ; i >= 0 ; i -= 3 ) { emitLineTo ( reverse [ i ] , reverse [ i + 1 ] , reverse [ i + 2 ] ) ; } this . rindex = 0 ; if ( capStyle == LinePath . CAP_ROUND ) { drawRoundJoin ( sx0 , sy0 , - mx0 , - my0 , mx0 , my0 , 1 , scolor0 , false , false , ROUND_JOIN_THRESHOLD ) ; } else if ( capStyle == LinePath . CAP_SQUARE ) { long ldx = sx1 - sx0 ; long ldy = sy1 - sy0 ; long llen = lineLength ( ldx , ldy ) ; if ( 0 < llen ) { long s = ( long ) lineWidth2 * 65536 / llen ; int capx = sx0 - ( int ) ( ldx * s > > 16 ) ; int capy = sy0 - ( int ) ( ldy * s > > 16 ) ; emitLineTo ( capx - mx0 , capy - my0 , scolor0 ) ; emitLineTo ( capx + mx0 , capy + my0 , scolor0 ) ; } } emitClose ( ) ; this . joinSegment = false ; } private void emitMoveTo ( int x0 , int y0 , int c0 ) { output . moveTo ( x0 , y0 , c0 ) ; } private void emitLineTo ( int x1 , int y1 , int c1 ) { output . lineTo ( x1 , y1 , c1 ) ; } private void emitLineTo ( int x1 , int y1 , int c1 , boolean rev ) { if ( rev ) { ensureCapacity ( rindex + 3 ) ; reverse [ rindex ++ ] = x1 ; reverse [ rindex ++ ] = y1 ; reverse [ rindex ++ ] = c1 ; } else { emitLineTo ( x1 , y1 , c1 ) ; } } private void emitClose ( ) { output . close ( ) ; } }
import java . io . BufferedReader ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintStream ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class PAppletMethods extends Task { private File baseDir ; private boolean includeRecorder ; public PAppletMethods ( ) { } public void setDir ( String dir ) { baseDir = new File ( dir ) ; } public void setRecorder ( boolean rec ) { includeRecorder = rec ; } public void execute ( ) throws BuildException { if ( baseDir == null ) { throw new BuildException ( "dir parameter must be set!" ) ; } File graphicsFile = new File ( baseDir , "PGraphics.java" ) ; File appletFile = new File ( baseDir , "PApplet.java" ) ; File imageFile = new File ( baseDir , "PImage.java" ) ; if ( ! graphicsFile . exists ( ) || ! graphicsFile . canRead ( ) ) { throw new BuildException ( "PGraphics file not readable: " + graphicsFile . getAbsolutePath ( ) ) ; } if ( ! appletFile . exists ( ) || ! appletFile . canRead ( ) || ! appletFile . canWrite ( ) ) { throw new BuildException ( "PApplet file not read/writeable: " + appletFile . getAbsolutePath ( ) ) ; } if ( ! imageFile . exists ( ) || ! imageFile . canRead ( ) ) { throw new BuildException ( "PImage file not readable: " + imageFile . getAbsolutePath ( ) ) ; } StringBuilder out = new StringBuilder ( ) ; StringBuilder content = new StringBuilder ( ) ; try { BufferedReader applet = createReader ( appletFile ) ; String line ; while ( ( line = applet . readLine ( ) ) != null ) { out . append ( line ) ; out . append ( '\n' ) ; content . append ( line ) ; content . append ( '\n' ) ; if ( line . indexOf ( "public functions for processing.core" ) >= 0 ) { break ; } } while ( ( line = applet . readLine ( ) ) != null ) { content . append ( line ) ; content . append ( '\n' ) ; } applet . close ( ) ; process ( out , graphicsFile ) ; process ( out , imageFile ) ; out . append ( '}' ) ; out . append ( '\n' ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } String outString = out . toString ( ) ; if ( content . toString ( ) . equals ( outString ) ) { System . out . println ( "No changes to PApplet API." ) ; } else { System . out . println ( "Updating PApplet with API changes " + "from PImage or PGraphics." ) ; try { PrintStream temp = new PrintStream ( appletFile , "UTF-8" ) ; temp . print ( outString ) ; temp . flush ( ) ; temp . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } private void process ( StringBuilder out , File input ) throws IOException { BufferedReader in = createReader ( input ) ; int comments = 0 ; String line = null ; StringBuilder commentBuffer = new StringBuilder ( ) ; while ( ( line = in . readLine ( ) ) != null ) { String decl = "" ; if ( line . indexOf ( "/*" ) != - 1 ) { comments ++ ; } if ( line . indexOf ( "*/" ) != - 1 ) { commentBuffer . append ( line ) ; commentBuffer . append ( '\n' ) ; comments -- ; continue ; } if ( comments > 0 ) { commentBuffer . append ( line ) ; commentBuffer . append ( '\n' ) ; continue ; } boolean gotSomething = false ; boolean gotStatic = false ; Matcher result ; if ( ( result = Pattern . compile ( "^\\s*public ([\\w\\[\\]]+) [a-zA-z_]+\\(.*$" ) . matcher ( line ) ) . matches ( ) ) { gotSomething = true ; } else if ( ( result = Pattern . compile ( "^\\s*abstract public ([\\w\\[\\]]+) [a-zA-z_]+\\(.*$" ) . matcher ( line ) ) . matches ( ) ) { gotSomething = true ; } else if ( ( result = Pattern . compile ( "^\\s*public final ([\\w\\[\\]]+) [a-zA-z_]+\\(.*$" ) . matcher ( line ) ) . matches ( ) ) { gotSomething = true ; } else if ( ( result = Pattern . compile ( "^\\s*static public ([\\w\\[\\]]+) [a-zA-z_]+\\(.*$" ) . matcher ( line ) ) . matches ( ) ) { gotSomething = true ; gotStatic = true ; } if ( gotSomething && line . indexOf ( "// ignore" ) >= 0 ) { gotSomething = false ; } String returns = "" ; if ( gotSomething ) { if ( result . group ( 1 ) . equals ( "void" ) ) { returns = "" ; } else { returns = "return " ; } line = line . replaceFirst ( Pattern . quote ( "abstract" ) , " " ) ; line = line . replaceAll ( Pattern . quote ( ";" ) , " {\n" ) ; out . append ( '\n' ) ; out . append ( '\n' ) ; out . append ( commentBuffer . toString ( ) ) ; commentBuffer . setLength ( 0 ) ; out . append ( line ) ; out . append ( '\n' ) ; decl += line ; while ( line . indexOf ( ')' ) == - 1 ) { line = in . readLine ( ) ; decl += line ; line = line . replaceAll ( "\\;\\s*$" , " {\n" ) ; out . append ( line ) ; out . append ( '\n' ) ; } result = Pattern . compile ( ".*?\\s(\\S+)\\(.*?" ) . matcher ( decl ) ; result . matches ( ) ; String declName = result . group ( 1 ) ; String gline = "" ; String rline = "" ; if ( gotStatic ) { gline = " " + returns + "PGraphics." + declName + "(" ; } else { rline = " if (recorder != null) recorder." + declName + "(" ; gline = " " + returns + "g." + declName + "(" ; } decl = decl . replaceAll ( "\\s+" , " " ) ; decl = decl . replaceFirst ( "^.*\\(" , "" ) ; decl = decl . replaceFirst ( "\\).*$" , "" ) ; int prev = 0 ; String parts [ ] = decl . split ( "\\, " ) ; for ( String part : parts ) { if ( ! part . trim ( ) . equals ( "" ) ) { String blargh [ ] = part . split ( " " ) ; String theArg = blargh [ 1 ] . replaceAll ( "[\\[\\]]" , "" ) ; if ( prev != 0 ) { gline += ", " ; rline += ", " ; } gline += theArg ; rline += theArg ; prev = 1 ; } } gline += ");" ; rline += ");" ; if ( ! gotStatic && returns . equals ( "" ) && includeRecorder ) { out . append ( rline ) ; out . append ( '\n' ) ; } out . append ( gline ) ; out . append ( '\n' ) ; out . append ( " }" ) ; out . append ( '\n' ) ; } else { commentBuffer . setLength ( 0 ) ; } } in . close ( ) ; } static BufferedReader createReader ( File file ) throws IOException { FileInputStream fis = new FileInputStream ( file ) ; return new BufferedReader ( new InputStreamReader ( fis , "UTF-8" ) ) ; } }
package processing . app ; import processing . core . * ; import java . awt . Component ; import java . awt . Container ; import java . awt . FileDialog ; import java . awt . event . ActionListener ; import java . awt . event . KeyAdapter ; import java . awt . event . KeyEvent ; import java . io . * ; import java . util . List ; import javax . swing . * ; public class Sketch { private Editor editor ; private Mode mode ; private File primaryFile ; private String name ; private boolean modified ; private File folder ; private File dataFolder ; private File codeFolder ; private SketchCode current ; private int currentIndex ; private int codeCount ; private SketchCode [ ] code ; private boolean untitled ; public Sketch ( String path , Mode mode ) { this . editor = null ; this . mode = mode ; load ( path ) ; } public Sketch ( String path , Editor editor ) throws IOException { this . editor = editor ; this . mode = editor . getMode ( ) ; load ( path ) ; } protected void load ( String path ) { primaryFile = new File ( path ) ; String mainFilename = primaryFile . getName ( ) ; int suffixLength = mode . getDefaultExtension ( ) . length ( ) + 1 ; name = mainFilename . substring ( 0 , mainFilename . length ( ) - suffixLength ) ; folder = new File ( new File ( path ) . getParent ( ) ) ; load ( ) ; } protected void load ( ) { codeFolder = new File ( folder , "code" ) ; dataFolder = new File ( folder , "data" ) ; String list [ ] = folder . list ( ) ; codeCount = 0 ; code = new SketchCode [ list . length ] ; String [ ] extensions = mode . getExtensions ( ) ; for ( String filename : list ) { if ( filename . startsWith ( "." ) ) continue ; if ( new File ( folder , filename ) . isDirectory ( ) ) continue ; String base = filename ; for ( String extension : extensions ) { if ( base . toLowerCase ( ) . endsWith ( "." + extension ) ) { base = base . substring ( 0 , base . length ( ) - ( extension . length ( ) + 1 ) ) ; if ( isSanitaryName ( base ) ) { code [ codeCount ++ ] = new SketchCode ( new File ( folder , filename ) , extension ) ; } } } } code = ( SketchCode [ ] ) PApplet . subset ( code , 0 , codeCount ) ; for ( int i = 1 ; i < codeCount ; i ++ ) { if ( code [ i ] . getFile ( ) . equals ( primaryFile ) ) { SketchCode temp = code [ 0 ] ; code [ 0 ] = code [ i ] ; code [ i ] = temp ; break ; } } sortCode ( ) ; if ( editor != null ) { setCurrentCode ( 0 ) ; } } public void reload ( ) { current = null ; load ( ) ; } protected void replaceCode ( SketchCode newCode ) { for ( int i = 0 ; i < codeCount ; i ++ ) { if ( code [ i ] . getFileName ( ) . equals ( newCode . getFileName ( ) ) ) { code [ i ] = newCode ; break ; } } } protected void insertCode ( SketchCode newCode ) { ensureExistence ( ) ; code = ( SketchCode [ ] ) PApplet . append ( code , newCode ) ; codeCount ++ ; } protected void sortCode ( ) { for ( int i = 1 ; i < codeCount ; i ++ ) { int who = i ; for ( int j = i + 1 ; j < codeCount ; j ++ ) { if ( code [ j ] . getFileName ( ) . compareTo ( code [ who ] . getFileName ( ) ) < 0 ) { who = j ; } } if ( who != i ) { SketchCode temp = code [ who ] ; code [ who ] = code [ i ] ; code [ i ] = temp ; } } } boolean renamingCode ; public void handleNewCode ( ) { ensureExistence ( ) ; if ( isReadOnly ( ) ) { Base . showMessage ( Language . text ( "new.messages.is_read_only" ) , Language . text ( "new.messages.is_read_only.description" ) ) ; return ; } renamingCode = false ; promptForTabName ( Language . text ( "editor.tab.rename.description" ) + ":" , "" ) ; } public void handleRenameCode ( ) { ensureExistence ( ) ; if ( currentIndex == 0 && isUntitled ( ) ) { Base . showMessage ( Language . text ( "rename.messages.is_untitled" ) , Language . text ( "rename.messages.is_untitled.description" ) ) ; return ; } if ( isModified ( ) ) { Base . showMessage ( Language . text ( "menu.file.save" ) , Language . text ( "rename.messages.is_modified" ) ) ; return ; } if ( isReadOnly ( ) ) { Base . showMessage ( Language . text ( "rename.messages.is_read_only" ) , Language . text ( "rename.messages.is_read_only.description" ) ) ; return ; } renamingCode = true ; String prompt = ( currentIndex == 0 ) ? Language . text ( "editor.sketch.rename.description" ) : Language . text ( "editor.tab.rename.description" ) ; String oldName = ( current . isExtension ( mode . getDefaultExtension ( ) ) ) ? current . getPrettyName ( ) : current . getFileName ( ) ; promptForTabName ( prompt + ":" , oldName ) ; } protected void promptForTabName ( String prompt , String oldName ) { final JTextField field = new JTextField ( oldName ) ; field . addKeyListener ( new KeyAdapter ( ) { public void keyTyped ( KeyEvent event ) { char ch = event . getKeyChar ( ) ; if ( ( ch == '_' ) || ( ch == '.' ) || ( ( 'A' <= ch ) && ( ch <= 'Z' ) ) || ( ( 'a' <= ch ) && ( ch <= 'z' ) ) ) { } else if ( ch == ' ' ) { String t = field . getText ( ) ; int start = field . getSelectionStart ( ) ; int end = field . getSelectionEnd ( ) ; field . setText ( t . substring ( 0 , start ) + "_" + t . substring ( end ) ) ; field . setCaretPosition ( start + 1 ) ; event . consume ( ) ; } else if ( ( ch >= '0' ) && ( ch <= '9' ) ) { if ( field . getCaretPosition ( ) == 0 || field . getSelectionStart ( ) == 0 ) { event . consume ( ) ; } } else if ( ch == KeyEvent . VK_ENTER ) { Container parent = field . getParent ( ) ; while ( ! ( parent instanceof JOptionPane ) ) { parent = parent . getParent ( ) ; } JOptionPane pane = ( JOptionPane ) parent ; final JPanel pnlBottom = ( JPanel ) pane . getComponent ( pane . getComponentCount ( ) - 1 ) ; for ( int i = 0 ; i < pnlBottom . getComponents ( ) . length ; i ++ ) { Component component = pnlBottom . getComponents ( ) [ i ] ; if ( component instanceof JButton ) { final JButton okButton = ( JButton ) component ; if ( okButton . getText ( ) . equalsIgnoreCase ( "OK" ) ) { ActionListener [ ] actionListeners = okButton . getActionListeners ( ) ; if ( actionListeners . length > 0 ) { actionListeners [ 0 ] . actionPerformed ( null ) ; event . consume ( ) ; } } } } } else { event . consume ( ) ; } } } ) ; int userReply = JOptionPane . showOptionDialog ( editor , new Object [ ] { prompt , field } , Language . text ( "editor.tab.new" ) , JOptionPane . OK_CANCEL_OPTION , JOptionPane . PLAIN_MESSAGE , null , new Object [ ] { Preferences . PROMPT_OK , Preferences . PROMPT_CANCEL } , field ) ; if ( userReply == JOptionPane . OK_OPTION ) { nameCode ( field . getText ( ) ) ; } } protected void nameCode ( String newName ) { newName = newName . trim ( ) ; if ( newName . length ( ) == 0 ) { return ; } ensureExistence ( ) ; if ( newName . indexOf ( '.' ) == - 1 ) { newName += "." + ( renamingCode ? mode . getDefaultExtension ( ) : mode . getModuleExtension ( ) ) ; } if ( renamingCode ) { if ( newName . equalsIgnoreCase ( current . getFileName ( ) ) ) { return ; } } if ( newName . startsWith ( "." ) ) { Base . showWarning ( "Problem with rename" , "The name cannot start with a period." ) ; return ; } int dot = newName . lastIndexOf ( '.' ) ; String newExtension = newName . substring ( dot + 1 ) . toLowerCase ( ) ; if ( ! mode . validExtension ( newExtension ) ) { Base . showWarning ( "Problem with rename" , "\"." + newExtension + "\"" + "is not a valid extension." ) ; return ; } if ( ! mode . isDefaultExtension ( newExtension ) ) { if ( renamingCode ) { if ( current == code [ 0 ] ) { Base . showWarning ( "Problem with rename" , "The first tab cannot be a ." + newExtension + " file.\n" + "(It may be time for you to graduate to a\n" + "\"real\" programming environment, hotshot.)" ) ; return ; } } } String shortName = newName . substring ( 0 , dot ) ; String sanitaryName = Sketch . sanitizeName ( shortName ) ; if ( ! shortName . equals ( sanitaryName ) ) { newName = sanitaryName + "." + newExtension ; } if ( ! ( renamingCode && sanitaryName . equals ( current . getPrettyName ( ) ) ) ) { for ( SketchCode c : code ) { if ( c != current && sanitaryName . equalsIgnoreCase ( c . getPrettyName ( ) ) ) { Base . showMessage ( "Nope" , "A file named \"" + c . getFileName ( ) + "\" already exists at\n" + "\"" + folder . getAbsolutePath ( ) + "\"" ) ; return ; } } } File newFile = new File ( folder , newName ) ; if ( renamingCode ) { if ( currentIndex == 0 ) { String folderName = newName . substring ( 0 , newName . indexOf ( '.' ) ) ; File newFolder = new File ( folder . getParentFile ( ) , folderName ) ; if ( newFolder . exists ( ) ) { Base . showWarning ( "Cannot Rename" , "Sorry, a sketch (or folder) named " + "\"" + newName + "\" already exists." ) ; return ; } boolean success = folder . renameTo ( newFolder ) ; if ( ! success ) { Base . showWarning ( "Error" , "Could not rename the sketch folder." ) ; return ; } current . setFolder ( newFolder ) ; newFile = new File ( newFolder , newName ) ; if ( ! current . renameTo ( newFile , newExtension ) ) { Base . showWarning ( "Error" , "Could not rename \"" + current . getFileName ( ) + "\" to \"" + newFile . getName ( ) + "\"" ) ; return ; } for ( int i = 1 ; i < codeCount ; i ++ ) { code [ i ] . setFolder ( newFolder ) ; } updateInternal ( sanitaryName , newFolder ) ; } else { if ( ! current . renameTo ( newFile , newExtension ) ) { Base . showWarning ( "Error" , "Could not rename \"" + current . getFileName ( ) + "\" to \"" + newFile . getName ( ) + "\"" ) ; return ; } } } else { try { if ( ! newFile . createNewFile ( ) ) { throw new IOException ( "createNewFile() returned false" ) ; } } catch ( IOException e ) { Base . showWarning ( "Error" , "Could not create the file \"" + newFile + "\"\n" + "in \"" + folder . getAbsolutePath ( ) + "\"" , e ) ; return ; } SketchCode newCode = new SketchCode ( newFile , newExtension ) ; insertCode ( newCode ) ; } sortCode ( ) ; setCurrentCode ( newName ) ; editor . header . rebuild ( ) ; } public void handleDeleteCode ( ) { ensureExistence ( ) ; if ( isReadOnly ( ) ) { Base . showMessage ( Language . text ( "delete.messages.is_read_only" ) , Language . text ( "delete.messages.is_read_only.description" ) ) ; return ; } if ( currentIndex == 0 && isUntitled ( ) ) { Base . showMessage ( Language . text ( "delete.messages.cannot_delete" ) , Language . text ( "delete.messages.cannot_delete.description" ) ) ; return ; } Object [ ] options = { Language . text ( "prompt.ok" ) , Language . text ( "prompt.cancel" ) } ; String prompt = ( currentIndex == 0 ) ? Language . text ( "warn.delete.sketch" ) : Language . interpolate ( "warn.delete.file" , current . getPrettyName ( ) ) ; int result = JOptionPane . showOptionDialog ( editor , prompt , Language . text ( "warn.delete" ) , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , options [ 0 ] ) ; if ( result == JOptionPane . YES_OPTION ) { if ( currentIndex == 0 ) { Base . removeDir ( folder ) ; editor . base . handleClose ( editor , false ) ; } else { if ( ! current . deleteFile ( ) ) { Base . showMessage ( Language . text ( "delete.messages.cannot_delete.file" ) , Language . text ( "delete.messages.cannot_delete.file.description" ) + " \"" + current . getFileName ( ) + "\"." ) ; return ; } removeCode ( current ) ; setCurrentCode ( 0 ) ; editor . header . repaint ( ) ; } } } protected void removeCode ( SketchCode which ) { for ( int i = 0 ; i < codeCount ; i ++ ) { if ( code [ i ] == which ) { for ( int j = i ; j < codeCount - 1 ; j ++ ) { code [ j ] = code [ j + 1 ] ; } codeCount -- ; code = ( SketchCode [ ] ) PApplet . shorten ( code ) ; return ; } } System . err . println ( "removeCode: internal error.. could not find code" ) ; } public void handlePrevCode ( ) { int prev = currentIndex - 1 ; if ( prev < 0 ) prev = codeCount - 1 ; setCurrentCode ( prev ) ; } public void handleNextCode ( ) { setCurrentCode ( ( currentIndex + 1 ) % codeCount ) ; } public void setModified ( boolean state ) { if ( current . isModified ( ) != state ) { current . setModified ( state ) ; calcModified ( ) ; } } protected void calcModified ( ) { modified = false ; for ( int i = 0 ; i < codeCount ; i ++ ) { if ( code [ i ] . isModified ( ) ) { modified = true ; break ; } } editor . header . repaint ( ) ; if ( Base . isMacOS ( ) ) { Object modifiedParam = modified ? Boolean . TRUE : Boolean . FALSE ; editor . getRootPane ( ) . putClientProperty ( "Window.documentModified" , modifiedParam ) ; } } public boolean isModified ( ) { return modified ; } public boolean save ( ) throws IOException { ensureExistence ( ) ; current . setProgram ( editor . getText ( ) ) ; if ( isReadOnly ( ) ) { Base . showMessage ( "Sketch is read-only" , "Some files are marked \"read-only\", so you'll\n" + "need to re-save this sketch to another location." ) ; if ( ! saveAs ( ) ) return false ; } for ( int i = 0 ; i < codeCount ; i ++ ) { if ( code [ i ] . isModified ( ) ) code [ i ] . save ( ) ; } calcModified ( ) ; return true ; } protected boolean saveAs ( ) throws IOException { String newParentDir = null ; String newName = null ; final String oldName2 = folder . getName ( ) ; final String PROMPT = Language . text ( "save" ) ; if ( Preferences . getBoolean ( "chooser.files.native" ) ) { FileDialog fd = new FileDialog ( editor , PROMPT , FileDialog . SAVE ) ; if ( isReadOnly ( ) || isUntitled ( ) ) { fd . setDirectory ( Preferences . getSketchbookPath ( ) ) ; } else { fd . setDirectory ( folder . getParent ( ) ) ; } String oldName = folder . getName ( ) ; fd . setFile ( oldName ) ; fd . setVisible ( true ) ; newParentDir = fd . getDirectory ( ) ; newName = fd . getFile ( ) ; } else { JFileChooser fc = new JFileChooser ( ) ; fc . setDialogTitle ( PROMPT ) ; if ( isReadOnly ( ) || isUntitled ( ) ) { fc . setCurrentDirectory ( new File ( Preferences . getSketchbookPath ( ) ) ) ; } else { fc . setCurrentDirectory ( folder . getParentFile ( ) ) ; } int result = fc . showSaveDialog ( editor ) ; if ( result == JFileChooser . APPROVE_OPTION ) { File selection = fc . getSelectedFile ( ) ; newParentDir = selection . getParent ( ) ; newName = selection . getName ( ) ; } } if ( newName == null ) return false ; String sanitaryName = Sketch . checkName ( newName ) ; File newFolder = new File ( newParentDir , sanitaryName ) ; if ( ! sanitaryName . equals ( newName ) && newFolder . exists ( ) ) { Base . showMessage ( "Cannot Save" , "A sketch with the cleaned name\n" + "" + sanitaryName + " already exists." ) ; return false ; } newName = sanitaryName ; for ( int i = 1 ; i < codeCount ; i ++ ) { if ( newName . equalsIgnoreCase ( code [ i ] . getPrettyName ( ) ) ) { Base . showMessage ( "Nope" , "You can't save the sketch as \"" + newName + "\"\n" + "because the sketch already has a tab with that name." ) ; return false ; } } if ( newFolder . equals ( folder ) ) { return save ( ) ; } try { String newPath = newFolder . getCanonicalPath ( ) + File . separator ; String oldPath = folder . getCanonicalPath ( ) + File . separator ; if ( newPath . indexOf ( oldPath ) == 0 ) { Base . showWarning ( "How very Borges of you" , "You cannot save the sketch into a folder\n" + "inside itself. This would go on forever." , null ) ; return false ; } } catch ( IOException e ) { } if ( newFolder . exists ( ) ) { Base . removeDir ( newFolder ) ; } newFolder . mkdirs ( ) ; if ( current . isModified ( ) ) { current . setProgram ( editor . getText ( ) ) ; } File [ ] copyItems = folder . listFiles ( new FileFilter ( ) { public boolean accept ( File file ) { String name = file . getName ( ) ; if ( name . equals ( "." ) || name . equals ( ".." ) ) { return false ; } for ( String ignorable : mode . getIgnorable ( ) ) { if ( name . equals ( ignorable ) ) { return false ; } } for ( String ext : mode . getExtensions ( ) ) { if ( name . endsWith ( ext ) ) { return false ; } } if ( name . startsWith ( "screen-" ) ) { return false ; } return true ; } } ) ; final File newFolder2 = newFolder ; final File [ ] copyItems2 = copyItems ; final String newName2 = newName ; javax . swing . SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { new ProgressFrame ( copyItems2 , newFolder2 , oldName2 , newName2 , editor ) ; } } ) ; for ( int i = 1 ; i < codeCount ; i ++ ) { File newFile = new File ( newFolder , code [ i ] . getFileName ( ) ) ; code [ i ] . saveAs ( newFile ) ; } if ( ! isUntitled ( ) ) { editor . removeRecent ( ) ; } File newFile = new File ( newFolder , newName + "." + mode . getDefaultExtension ( ) ) ; code [ 0 ] . saveAs ( newFile ) ; updateInternal ( newName , newFolder ) ; setUntitled ( false ) ; editor . addRecent ( ) ; return true ; } protected void updateInternal ( String sketchName , File sketchFolder ) { String oldPath = getMainFilePath ( ) ; primaryFile = code [ 0 ] . getFile ( ) ; name = sketchName ; folder = sketchFolder ; codeFolder = new File ( folder , "code" ) ; dataFolder = new File ( folder , "data" ) ; calcModified ( ) ; editor . updateTitle ( ) ; editor . base . rebuildSketchbookMenus ( ) ; editor . base . handleRecentRename ( editor , oldPath ) ; } public void handleAddFile ( ) { ensureExistence ( ) ; if ( isReadOnly ( ) ) { Base . showMessage ( "Sketch is Read-Only" , "Some files are marked \"read-only\", so you'll\n" + "need to re-save the sketch in another location,\n" + "and try again." ) ; return ; } String prompt = Language . text ( "file" ) ; FileDialog fd = new FileDialog ( editor , prompt , FileDialog . LOAD ) ; fd . setVisible ( true ) ; String directory = fd . getDirectory ( ) ; String filename = fd . getFile ( ) ; if ( filename == null ) return ; File sourceFile = new File ( directory , filename ) ; boolean result = addFile ( sourceFile ) ; if ( result ) { } } public boolean addFile ( File sourceFile ) { String filename = sourceFile . getName ( ) ; File destFile = null ; String codeExtension = null ; boolean replacement = false ; if ( filename . toLowerCase ( ) . endsWith ( ".class" ) || filename . toLowerCase ( ) . endsWith ( ".jar" ) || filename . toLowerCase ( ) . endsWith ( ".dll" ) || filename . toLowerCase ( ) . endsWith ( ".jnilib" ) || filename . toLowerCase ( ) . endsWith ( ".so" ) ) { prepareCodeFolder ( ) ; destFile = new File ( codeFolder , filename ) ; } else { for ( String extension : mode . getExtensions ( ) ) { String lower = filename . toLowerCase ( ) ; if ( lower . endsWith ( "." + extension ) ) { destFile = new File ( this . folder , filename ) ; codeExtension = extension ; } } if ( codeExtension == null ) { prepareDataFolder ( ) ; destFile = new File ( dataFolder , filename ) ; } } if ( destFile . exists ( ) ) { Object [ ] options = { Language . text ( "prompt.ok" ) , Language . text ( "prompt.cancel" ) } ; String prompt = "Replace the existing version of " + filename + "?" ; int result = JOptionPane . showOptionDialog ( editor , prompt , "Replace" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , options [ 0 ] ) ; if ( result == JOptionPane . YES_OPTION ) { replacement = true ; } else { return false ; } } if ( replacement ) { boolean muchSuccess = destFile . delete ( ) ; if ( ! muchSuccess ) { Base . showWarning ( "Error adding file" , "Could not delete the existing '" + filename + "' file." , null ) ; return false ; } } if ( ( codeExtension == null ) && sourceFile . equals ( destFile ) ) { Base . showWarning ( "You can't fool me" , "This file has already been copied to the\n" + "location from which where you're trying to add it.\n" + "I ain't not doin nuthin'." , null ) ; return false ; } if ( ! sourceFile . equals ( destFile ) ) { try { Base . copyFile ( sourceFile , destFile ) ; } catch ( IOException e ) { Base . showWarning ( "Error adding file" , "Could not add '" + filename + "' to the sketch." , e ) ; return false ; } } if ( codeExtension != null ) { SketchCode newCode = new SketchCode ( destFile , codeExtension ) ; if ( replacement ) { replaceCode ( newCode ) ; } else { insertCode ( newCode ) ; sortCode ( ) ; } setCurrentCode ( filename ) ; editor . header . repaint ( ) ; if ( isUntitled ( ) ) { current . setModified ( true ) ; } } else { if ( isUntitled ( ) ) { code [ 0 ] . setModified ( true ) ; } } return true ; } public void setCurrentCode ( int which ) { if ( ( ( currentIndex == which ) && ( current != null ) ) || which >= codeCount || which < 0 ) { return ; } if ( current != null ) { current . setState ( editor . getText ( ) , editor . getSelectionStart ( ) , editor . getSelectionStop ( ) , editor . getScrollPosition ( ) ) ; } current = code [ which ] ; currentIndex = which ; current . visited = System . currentTimeMillis ( ) ; editor . setCode ( current ) ; editor . header . repaint ( ) ; } protected void setCurrentCode ( String findName ) { for ( int i = 0 ; i < codeCount ; i ++ ) { if ( findName . equals ( code [ i ] . getFileName ( ) ) || findName . equals ( code [ i ] . getPrettyName ( ) ) ) { setCurrentCode ( i ) ; return ; } } } public File makeTempFolder ( ) { try { File buildFolder = Base . createTempFolder ( name , "temp" , null ) ; return buildFolder ; } catch ( IOException e ) { Base . showWarning ( "Build folder bad" , "Could not find a place to build the sketch." , e ) ; } return null ; } public void ensureExistence ( ) { if ( ! folder . exists ( ) ) { Base . showWarning ( "Sketch Disappeared" , "The sketch folder has disappeared.\n " + "Will attempt to re-save in the same location,\n" + "but anything besides the code will be lost." , null ) ; try { folder . mkdirs ( ) ; modified = true ; for ( int i = 0 ; i < codeCount ; i ++ ) { code [ i ] . save ( ) ; } calcModified ( ) ; } catch ( Exception e ) { Base . showWarning ( "Could not re-save sketch" , "Could not properly re-save the sketch. " + "You may be in trouble at this point,\n" + "and it might be time to copy and paste " + "your code to another text editor." , e ) ; } } } public boolean isReadOnly ( ) { String apath = folder . getAbsolutePath ( ) ; List < Mode > modes = editor . getBase ( ) . getModeList ( ) ; for ( Mode mode : modes ) { if ( apath . startsWith ( mode . getExamplesFolder ( ) . getAbsolutePath ( ) ) || apath . startsWith ( mode . getLibrariesFolder ( ) . getAbsolutePath ( ) ) ) { return true ; } } for ( int i = 0 ; i < codeCount ; i ++ ) { if ( code [ i ] . isModified ( ) && code [ i ] . fileReadOnly ( ) && code [ i ] . fileExists ( ) ) { return true ; } } return false ; } public String getName ( ) { return name ; } public File getMainFile ( ) { return primaryFile ; } public String getMainFilePath ( ) { return primaryFile . getAbsolutePath ( ) ; } public File getFolder ( ) { return folder ; } public File getDataFolder ( ) { return dataFolder ; } public boolean hasDataFolder ( ) { return dataFolder . exists ( ) ; } public File prepareDataFolder ( ) { if ( ! dataFolder . exists ( ) ) { dataFolder . mkdirs ( ) ; } return dataFolder ; } public File getCodeFolder ( ) { return codeFolder ; } public boolean hasCodeFolder ( ) { return ( codeFolder != null ) && codeFolder . exists ( ) ; } public File prepareCodeFolder ( ) { if ( ! codeFolder . exists ( ) ) { codeFolder . mkdirs ( ) ; } return codeFolder ; } public SketchCode [ ] getCode ( ) { return code ; } public int getCodeCount ( ) { return codeCount ; } public SketchCode getCode ( int index ) { return code [ index ] ; } public int getCodeIndex ( SketchCode who ) { for ( int i = 0 ; i < codeCount ; i ++ ) { if ( who == code [ i ] ) { return i ; } } return - 1 ; } public SketchCode getCurrentCode ( ) { return current ; } public int getCurrentCodeIndex ( ) { return currentIndex ; } public String getMainProgram ( ) { return getCode ( 0 ) . getProgram ( ) ; } public void setUntitled ( boolean untitled ) { this . untitled = untitled ; editor . updateTitle ( ) ; } public boolean isUntitled ( ) { return untitled ; } static public String checkName ( String origName ) { String newName = sanitizeName ( origName ) ; if ( ! newName . equals ( origName ) ) { String msg = "The sketch name had to be modified. Sketch names can only consist\n" + "of ASCII characters and numbers (but cannot start with a number).\n" + "They should also be less than 64 characters long." ; System . out . println ( msg ) ; } return newName ; } public static boolean isSanitaryName ( String name ) { final int dot = name . lastIndexOf ( '.' ) ; if ( dot >= 0 ) { name = name . substring ( 0 , dot ) ; } return sanitizeName ( name ) . equals ( name ) ; } static final boolean asciiLetter ( char c ) { return ( c >= 'a' && c <= 'z' ) || ( c >= 'A' && c <= 'Z' ) ; } static public String sanitizeName ( String origName ) { char orig [ ] = origName . toCharArray ( ) ; StringBuilder sb = new StringBuilder ( ) ; if ( ! asciiLetter ( orig [ 0 ] ) ) { sb . append ( "sketch_" ) ; } for ( char c : orig ) { if ( asciiLetter ( c ) || ( c >= '0' && c <= '9' ) ) { sb . append ( c ) ; } else { sb . append ( '_' ) ; } } if ( sb . length ( ) > 63 ) { sb . setLength ( 63 ) ; } int underscore = 0 ; while ( underscore < sb . length ( ) && sb . charAt ( underscore ) == '_' ) { underscore ++ ; } if ( underscore == sb . length ( ) ) { return "bad_sketch_name_please_fix" ; } else if ( underscore != 0 ) { return sb . substring ( underscore ) ; } return sb . toString ( ) ; } public Mode getMode ( ) { return mode ; } }
package processing . app ; public interface RunnerListener { public void statusError ( String message ) ; public void statusError ( Exception exception ) ; public void statusNotice ( String message ) ; public void startIndeterminate ( ) ; public void stopIndeterminate ( ) ; public void statusHalt ( ) ; public boolean isHalted ( ) ; }
package processing . app ; import java . awt . * ; import java . awt . event . * ; import javax . swing . * ; import javax . swing . GroupLayout . Group ; import javax . swing . text . BadLocationException ; import javax . swing . text . Document ; public class FindReplace extends JFrame { static final int BORDER = Base . isMacOS ( ) ? 20 : 13 ; Editor editor ; JTextField findField ; JTextField replaceField ; static String findString ; static String replaceString ; JButton replaceButton ; JButton replaceAllButton ; JButton replaceAndFindButton ; JButton previousButton ; JButton findButton ; JCheckBox ignoreCaseBox ; static boolean ignoreCase = true ; JCheckBox allTabsBox ; static boolean allTabs = false ; JCheckBox wrapAroundBox ; static boolean wrapAround = true ; public FindReplace ( Editor editor ) { super ( Language . text ( "find" ) ) ; this . editor = editor ; Container pain = getContentPane ( ) ; JLabel findLabel = new JLabel ( Language . text ( "find.find" ) ) ; JLabel replaceLabel = new JLabel ( Language . text ( "find.replace_with" ) ) ; findField = new JTextField ( ) ; replaceField = new JTextField ( ) ; if ( findString != null ) findField . setText ( findString ) ; if ( replaceString != null ) replaceField . setText ( replaceString ) ; ignoreCaseBox = new JCheckBox ( Language . text ( "find.ignore_case" ) ) ; ignoreCaseBox . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { ignoreCase = ignoreCaseBox . isSelected ( ) ; } } ) ; ignoreCaseBox . setSelected ( ignoreCase ) ; allTabsBox = new JCheckBox ( Language . text ( "find.all_tabs" ) ) ; allTabsBox . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { allTabs = allTabsBox . isSelected ( ) ; } } ) ; allTabsBox . setSelected ( allTabs ) ; allTabsBox . setEnabled ( true ) ; wrapAroundBox = new JCheckBox ( Language . text ( "find.wrap_around" ) ) ; wrapAroundBox . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { wrapAround = wrapAroundBox . isSelected ( ) ; } } ) ; wrapAroundBox . setSelected ( wrapAround ) ; GroupLayout layout = new GroupLayout ( pain ) ; pain . setLayout ( layout ) ; layout . setAutoCreateGaps ( true ) ; layout . setAutoCreateContainerGaps ( true ) ; Group buttonsHorizontalGroup = layout . createSequentialGroup ( ) ; replaceAllButton = new JButton ( Language . text ( "find.btn.replace_all" ) ) ; replaceButton = new JButton ( Language . text ( "find.btn.replace" ) ) ; replaceAndFindButton = new JButton ( Language . text ( "find.btn.replace_and_find" ) ) ; previousButton = new JButton ( Language . text ( "find.btn.previous" ) ) ; findButton = new JButton ( Language . text ( "find.btn.find" ) ) ; if ( Base . isMacOS ( ) ) { buttonsHorizontalGroup . addComponent ( replaceAllButton ) . addComponent ( replaceButton ) . addComponent ( replaceAndFindButton ) . addComponent ( previousButton ) . addComponent ( findButton ) ; } else { buttonsHorizontalGroup . addComponent ( findButton ) . addComponent ( previousButton ) . addComponent ( replaceAndFindButton ) . addComponent ( replaceButton ) . addComponent ( replaceAllButton ) ; } setFound ( false ) ; Group buttonsVerticalGroup = layout . createParallelGroup ( ) ; buttonsVerticalGroup . addComponent ( findButton ) . addComponent ( previousButton ) . addComponent ( replaceAndFindButton ) . addComponent ( replaceButton ) . addComponent ( replaceAllButton ) ; layout . setHorizontalGroup ( layout . createSequentialGroup ( ) . addGap ( BORDER ) . addGroup ( layout . createParallelGroup ( ) . addGroup ( GroupLayout . Alignment . TRAILING , layout . createSequentialGroup ( ) . addGap ( replaceLabel . getPreferredSize ( ) . width - findLabel . getPreferredSize ( ) . width ) . addComponent ( findLabel ) . addComponent ( findField ) ) . addGroup ( GroupLayout . Alignment . TRAILING , layout . createSequentialGroup ( ) . addComponent ( replaceLabel ) . addGroup ( layout . createParallelGroup ( ) . addComponent ( replaceField ) . addGroup ( GroupLayout . Alignment . LEADING , layout . createSequentialGroup ( ) . addComponent ( ignoreCaseBox ) . addComponent ( allTabsBox ) . addComponent ( wrapAroundBox ) . addGap ( 0 ) ) ) ) . addGroup ( GroupLayout . Alignment . CENTER , buttonsHorizontalGroup ) ) . addGap ( BORDER ) ) ; layout . setVerticalGroup ( layout . createSequentialGroup ( ) . addGap ( BORDER ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . CENTER ) . addComponent ( findLabel ) . addComponent ( findField ) ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . CENTER ) . addComponent ( replaceLabel ) . addComponent ( replaceField ) ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . CENTER ) . addComponent ( ignoreCaseBox ) . addComponent ( allTabsBox ) . addComponent ( wrapAroundBox ) ) . addGroup ( buttonsVerticalGroup ) . addGap ( BORDER ) ) ; setLocationRelativeTo ( null ) ; Dimension size = layout . preferredLayoutSize ( pain ) ; setSize ( size . width , size . height ) ; Dimension screen = Toolkit . getScreenSize ( ) ; setLocation ( ( screen . width - size . width ) / 2 , ( screen . height - size . height ) / 2 ) ; replaceButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { replace ( ) ; } } ) ; replaceAllButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { replaceAll ( ) ; } } ) ; replaceAndFindButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { replaceAndFindNext ( ) ; } } ) ; findButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { findNext ( ) ; } } ) ; previousButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { findPrevious ( ) ; } } ) ; getRootPane ( ) . setDefaultButton ( findButton ) ; setDefaultCloseOperation ( WindowConstants . DO_NOTHING_ON_CLOSE ) ; addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { handleClose ( ) ; } } ) ; Toolkit . registerWindowCloseKeys ( getRootPane ( ) , new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { handleClose ( ) ; } } ) ; Toolkit . setIcon ( this ) ; addWindowListener ( new WindowAdapter ( ) { public void windowActivated ( WindowEvent e ) { findField . requestFocusInWindow ( ) ; findField . selectAll ( ) ; } } ) ; pack ( ) ; setResizable ( true ) ; setLocationRelativeTo ( null ) ; } public void handleClose ( ) { findString = findField . getText ( ) ; replaceString = replaceField . getText ( ) ; setVisible ( false ) ; } private boolean find ( boolean wrap , boolean backwards ) { String searchTerm = findField . getText ( ) ; if ( searchTerm . length ( ) != 0 ) { String text = editor . getText ( ) ; Sketch sketch = editor . getSketch ( ) ; int tabIndex = sketch . getCurrentCodeIndex ( ) ; if ( ignoreCase ) { searchTerm = searchTerm . toLowerCase ( ) ; text = text . toLowerCase ( ) ; } int nextIndex ; if ( ! backwards ) { int selectionEnd = editor . getSelectionStop ( ) ; nextIndex = text . indexOf ( searchTerm , selectionEnd ) ; if ( nextIndex == - 1 && wrap && ! allTabs ) { nextIndex = text . indexOf ( searchTerm , 0 ) ; } else if ( nextIndex == - 1 && allTabs ) { int tempIndex = tabIndex ; while ( tabIndex <= sketch . getCodeCount ( ) - 1 ) { if ( tabIndex == sketch . getCodeCount ( ) - 1 ) { tabIndex = - 1 ; } else if ( tabIndex == sketch . getCodeCount ( ) - 1 ) { break ; } try { Document doc = sketch . getCode ( tabIndex + 1 ) . getDocument ( ) ; if ( doc != null ) { text = doc . getText ( 0 , doc . getLength ( ) ) ; } else { text = sketch . getCode ( tabIndex + 1 ) . getProgram ( ) ; } } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } tabIndex ++ ; if ( ignoreCase ) { text = text . toLowerCase ( ) ; } nextIndex = text . indexOf ( searchTerm , 0 ) ; if ( nextIndex != - 1 || tabIndex == tempIndex ) { break ; } } if ( nextIndex == - 1 ) { tabIndex = tempIndex ; } } } else { int selectionStart = editor . getSelectionStart ( ) - 1 ; if ( selectionStart >= 0 ) { nextIndex = text . lastIndexOf ( searchTerm , selectionStart ) ; } else { nextIndex = - 1 ; } if ( wrap && ! allTabs && nextIndex == - 1 ) { nextIndex = text . lastIndexOf ( searchTerm ) ; } else if ( nextIndex == - 1 && allTabs ) { int tempIndex = tabIndex ; while ( tabIndex >= 0 ) { if ( tabIndex == 0 ) { tabIndex = sketch . getCodeCount ( ) ; } else if ( tabIndex == 0 ) { break ; } try { Document doc = sketch . getCode ( tabIndex - 1 ) . getDocument ( ) ; if ( doc != null ) { text = doc . getText ( 0 , doc . getLength ( ) ) ; } else { text = sketch . getCode ( tabIndex - 1 ) . getProgram ( ) ; } } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } tabIndex -- ; if ( ignoreCase ) { text = text . toLowerCase ( ) ; } nextIndex = text . lastIndexOf ( searchTerm ) ; if ( nextIndex != - 1 || tabIndex == tempIndex ) { break ; } } if ( nextIndex == - 1 ) { tabIndex = tempIndex ; } } } if ( nextIndex != - 1 ) { if ( allTabs ) { sketch . setCurrentCode ( tabIndex ) ; } editor . setSelection ( nextIndex , nextIndex + searchTerm . length ( ) ) ; } else { } if ( nextIndex != - 1 ) { setFound ( true ) ; return true ; } } setFound ( false ) ; return false ; } protected void setFound ( boolean found ) { replaceButton . setEnabled ( found ) ; replaceAndFindButton . setEnabled ( found ) ; } public void replace ( ) { editor . setSelectedText ( replaceField . getText ( ) ) ; editor . getSketch ( ) . setModified ( true ) ; setFound ( false ) ; } public void replaceAndFindNext ( ) { replace ( ) ; findNext ( ) ; } public void replaceAll ( ) { editor . setSelection ( 0 , 0 ) ; boolean foundAtLeastOne = false ; int startTab = - 1 , startIndex = - 1 , c = 50000 ; while ( -- c > 0 ) { if ( find ( false , false ) ) { if ( editor . getSketch ( ) . getCurrentCodeIndex ( ) == startTab && editor . getSelectionStart ( ) == startIndex ) { Toolkit . beep ( ) ; editor . statusNotice ( "Reached beginning of search!" ) ; break ; } if ( ! foundAtLeastOne ) { foundAtLeastOne = true ; startTab = editor . getSketch ( ) . getCurrentCodeIndex ( ) ; startIndex = editor . getSelectionStart ( ) ; } replace ( ) ; } else { break ; } } if ( ! foundAtLeastOne ) { Toolkit . beep ( ) ; } setFound ( false ) ; } public void setFindText ( String t ) { findField . setText ( t ) ; findString = t ; } public void findNext ( ) { if ( ! find ( wrapAround , false ) ) { Toolkit . beep ( ) ; } } public void findPrevious ( ) { if ( ! find ( wrapAround , true ) ) { Toolkit . beep ( ) ; } } }
package processing . app ; import processing . app . contrib . ToolContribution ; import processing . app . syntax . * ; import processing . app . tools . * ; import processing . core . * ; import java . awt . BorderLayout ; import java . awt . Component ; import java . awt . Dimension ; import java . awt . EventQueue ; import java . awt . Frame ; import java . awt . Image ; import java . awt . Point ; import java . awt . datatransfer . * ; import java . awt . event . * ; import java . awt . print . * ; import java . io . * ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Stack ; import java . util . Timer ; import java . util . TimerTask ; import javax . swing . * ; import javax . swing . event . * ; import javax . swing . plaf . basic . * ; import javax . swing . text . * ; import javax . swing . undo . * ; public abstract class Editor extends JFrame implements RunnerListener { protected Base base ; protected EditorState state ; protected Mode mode ; static public final int LEFT_GUTTER = 44 ; static public final int RIGHT_GUTTER = 20 ; static public final int GUTTER_MARGIN = 3 ; static protected final String EMPTY = " " + " " + " " ; private PageFormat pageFormat ; private PrinterJob printerJob ; private JMenu fileMenu ; private JMenu sketchMenu ; protected EditorHeader header ; protected EditorToolbar toolbar ; protected JEditTextArea textarea ; protected EditorStatus status ; protected JSplitPane splitPane ; protected EditorFooter footer ; protected EditorConsole console ; protected Sketch sketch ; private Point sketchWindowLocation ; private JMenuItem undoItem , redoItem , copyItems , cutItems ; protected UndoAction undoAction ; protected RedoAction redoAction ; protected CopyAction copyAction ; protected CutAction cutAction ; private UndoManager undo ; private CompoundEdit compoundEdit ; private Timer timer ; private TimerTask endUndoEvent ; private boolean isInserting ; private final Stack < Integer > caretUndoStack = new Stack < Integer > ( ) ; private final Stack < Integer > caretRedoStack = new Stack < Integer > ( ) ; private FindReplace find ; JMenu toolsMenu ; JMenu modeMenu ; List < ToolContribution > coreTools ; List < ToolContribution > contribTools ; Image backgroundGradient ; protected Editor ( final Base base , String path , EditorState state , final Mode mode ) { super ( "Processing" , state . checkConfig ( ) ) ; this . base = base ; this . state = state ; this . mode = mode ; Toolkit . setIcon ( this ) ; addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { base . handleClose ( Editor . this , false ) ; } } ) ; setDefaultCloseOperation ( WindowConstants . DO_NOTHING_ON_CLOSE ) ; addWindowListener ( new WindowAdapter ( ) { public void windowActivated ( WindowEvent e ) { base . handleActivated ( Editor . this ) ; fileMenu . insert ( base . getRecentMenu ( ) , 2 ) ; Toolkit . setMenuMnemsInside ( fileMenu ) ; mode . insertImportMenu ( sketchMenu ) ; Toolkit . setMenuMnemsInside ( sketchMenu ) ; mode . insertToolbarRecentMenu ( ) ; } public void windowDeactivated ( WindowEvent e ) { fileMenu . remove ( base . getRecentMenu ( ) ) ; mode . removeImportMenu ( sketchMenu ) ; mode . removeToolbarRecentMenu ( ) ; } } ) ; timer = new Timer ( ) ; buildMenuBar ( ) ; JPanel contentPain = new JPanel ( ) ; setContentPane ( contentPain ) ; contentPain . setLayout ( new BorderLayout ( ) ) ; Box box = Box . createVerticalBox ( ) ; Box upper = Box . createVerticalBox ( ) ; initModeMenu ( ) ; toolbar = createToolbar ( ) ; upper . add ( toolbar ) ; header = createHeader ( ) ; upper . add ( header ) ; textarea = createTextArea ( ) ; textarea . setRightClickPopup ( new TextAreaPopup ( ) ) ; textarea . setHorizontalOffset ( JEditTextArea . leftHandGutter ) ; footer = createFooter ( ) ; upper . add ( textarea ) ; splitPane = new JSplitPane ( JSplitPane . VERTICAL_SPLIT , upper , footer ) ; splitPane . setOneTouchExpandable ( false ) ; splitPane . setContinuousLayout ( true ) ; splitPane . setResizeWeight ( 1D ) ; splitPane . setBorder ( null ) ; UIManager . getDefaults ( ) . put ( "SplitPane.border" , BorderFactory . createEmptyBorder ( ) ) ; splitPane . setDividerSize ( EditorStatus . HIGH ) ; splitPane . setUI ( new BasicSplitPaneUI ( ) { public BasicSplitPaneDivider createDefaultDivider ( ) { status = new EditorStatus ( this , Editor . this ) ; return status ; } } ) ; box . add ( splitPane ) ; contentPain . add ( box ) ; textarea . addCaretListener ( new CaretListener ( ) { String lastText = textarea . getText ( ) ; public void caretUpdate ( CaretEvent e ) { String newText = textarea . getText ( ) ; if ( lastText . equals ( newText ) && isDirectEdit ( ) ) { endTextEditHistory ( ) ; } lastText = newText ; } } ) ; contentPain . setTransferHandler ( new FileDropHandler ( ) ) ; pack ( ) ; state . apply ( this ) ; setMinimumSize ( new Dimension ( Preferences . getInteger ( "editor.window.width.min" ) , Preferences . getInteger ( "editor.window.height.min" ) ) ) ; applyPreferences ( ) ; addWindowFocusListener ( new WindowAdapter ( ) { public void windowGainedFocus ( WindowEvent e ) { textarea . requestFocusInWindow ( ) ; } } ) ; boolean loaded = handleOpenInternal ( path ) ; if ( ! loaded ) { sketch = null ; } addWindowFocusListener ( new ChangeDetector ( this ) ) ; } protected List < ToolContribution > getCoreTools ( ) { return coreTools ; } public List < ToolContribution > getToolContribs ( ) { return contribTools ; } public void removeToolContrib ( ToolContribution tc ) { contribTools . remove ( tc ) ; } protected JEditTextArea createTextArea ( ) { return new JEditTextArea ( new PdeTextAreaDefaults ( mode ) , new PdeInputHandler ( ) ) ; } public EditorFooter createFooter ( ) { EditorFooter ef = new EditorFooter ( this ) ; console = new EditorConsole ( this ) ; ef . addPanel ( Language . text ( "editor.footer.console" ) , console ) ; return ef ; } public EditorState getEditorState ( ) { return state ; } public void removeRecent ( ) { base . removeRecent ( this ) ; } public void addRecent ( ) { base . handleRecent ( this ) ; } class FileDropHandler extends TransferHandler { public boolean canImport ( TransferHandler . TransferSupport support ) { return ! sketch . isReadOnly ( ) ; } @ SuppressWarnings ( "unchecked" ) public boolean importData ( TransferHandler . TransferSupport support ) { int successful = 0 ; if ( ! canImport ( support ) ) { return false ; } try { Transferable transferable = support . getTransferable ( ) ; DataFlavor uriListFlavor = new DataFlavor ( "text/uri-list;class=java.lang.String" ) ; if ( transferable . isDataFlavorSupported ( DataFlavor . javaFileListFlavor ) ) { List list = ( List ) transferable . getTransferData ( DataFlavor . javaFileListFlavor ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { File file = ( File ) list . get ( i ) ; if ( sketch . addFile ( file ) ) { successful ++ ; } } } else if ( transferable . isDataFlavorSupported ( uriListFlavor ) ) { String data = ( String ) transferable . getTransferData ( uriListFlavor ) ; String [ ] pieces = PApplet . splitTokens ( data , "\r\n" ) ; for ( int i = 0 ; i < pieces . length ; i ++ ) { if ( pieces [ i ] . startsWith ( "#" ) ) continue ; String path = null ; if ( pieces [ i ] . startsWith ( "file:///" ) ) { path = pieces [ i ] . substring ( 7 ) ; } else if ( pieces [ i ] . startsWith ( "file:/" ) ) { path = pieces [ i ] . substring ( 5 ) ; } if ( sketch . addFile ( new File ( path ) ) ) { successful ++ ; } } } } catch ( Exception e ) { Base . showWarning ( "Drag & Drop Problem" , "An error occurred while trying to add files to the sketch." , e ) ; return false ; } statusNotice ( Language . pluralize ( "editor.status.drag_and_drop.files_added" , successful ) ) ; return true ; } } public Base getBase ( ) { return base ; } public Mode getMode ( ) { return mode ; } protected void initModeMenu ( ) { modeMenu = new JMenu ( ) ; ButtonGroup modeGroup = new ButtonGroup ( ) ; for ( final Mode m : base . getModeList ( ) ) { JRadioButtonMenuItem item = new JRadioButtonMenuItem ( m . getTitle ( ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( ! sketch . isModified ( ) ) { base . changeMode ( m ) ; } else { Base . showWarning ( "Save" , "Please save the sketch before changing the mode." , null ) ; for ( Component c : modeMenu . getPopupMenu ( ) . getComponents ( ) ) { if ( c instanceof JRadioButtonMenuItem ) { if ( ( ( JRadioButtonMenuItem ) c ) . getText ( ) == mode . getTitle ( ) ) { ( ( JRadioButtonMenuItem ) c ) . setSelected ( true ) ; break ; } } } } } } ) ; modeMenu . add ( item ) ; modeGroup . add ( item ) ; if ( mode == m ) { item . setSelected ( true ) ; } } modeMenu . addSeparator ( ) ; JMenuItem addLib = new JMenuItem ( Language . text ( "toolbar.add_mode" ) ) ; addLib . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . handleOpenModeManager ( ) ; } } ) ; modeMenu . add ( addLib ) ; Toolkit . setMenuMnemsInside ( modeMenu ) ; } public void rebuildModeMenu ( ) { initModeMenu ( ) ; } public JMenu getModeMenu ( ) { return modeMenu ; } public EditorConsole getConsole ( ) { return console ; } public EditorHeader createHeader ( ) { return new EditorHeader ( this ) ; } abstract public EditorToolbar createToolbar ( ) ; public void rebuildToolbar ( ) { toolbar . rebuild ( ) ; toolbar . revalidate ( ) ; } abstract public Formatter createFormatter ( ) ; protected void setDividerLocation ( int pos ) { splitPane . setDividerLocation ( pos ) ; } protected int getDividerLocation ( ) { return splitPane . getDividerLocation ( ) ; } protected void applyPreferences ( ) { textarea . getPainter ( ) . updateAppearance ( ) ; textarea . repaint ( ) ; console . updateAppearance ( ) ; } protected void buildMenuBar ( ) { JMenuBar menubar = new JMenuBar ( ) ; fileMenu = buildFileMenu ( ) ; menubar . add ( fileMenu ) ; menubar . add ( buildEditMenu ( ) ) ; menubar . add ( buildSketchMenu ( ) ) ; JMenu modeMenu = buildModeMenu ( ) ; if ( modeMenu != null ) { menubar . add ( modeMenu ) ; } rebuildToolMenu ( ) ; menubar . add ( getToolMenu ( ) ) ; menubar . add ( buildHelpMenu ( ) ) ; Toolkit . setMenuMnemonics ( menubar ) ; setJMenuBar ( menubar ) ; } abstract public JMenu buildFileMenu ( ) ; protected JMenu buildFileMenu ( JMenuItem [ ] exportItems ) { JMenuItem item ; JMenu fileMenu = new JMenu ( Language . text ( "menu.file" ) ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.file.new" ) , 'N' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . handleNew ( ) ; } } ) ; fileMenu . add ( item ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.file.open" ) , 'O' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . handleOpenPrompt ( ) ; } } ) ; fileMenu . add ( item ) ; item = Toolkit . newJMenuItemShift ( Language . text ( "menu.file.sketchbook" ) , 'K' ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { mode . showSketchbookFrame ( ) ; } } ) ; fileMenu . add ( item ) ; item = Toolkit . newJMenuItemShift ( Language . text ( "menu.file.examples" ) , 'O' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { mode . showExamplesFrame ( ) ; } } ) ; fileMenu . add ( item ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.file.close" ) , 'W' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . handleClose ( Editor . this , false ) ; } } ) ; fileMenu . add ( item ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.file.save" ) , 'S' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleSave ( false ) ; } } ) ; fileMenu . add ( item ) ; item = Toolkit . newJMenuItemShift ( Language . text ( "menu.file.save_as" ) , 'S' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleSaveAs ( ) ; } } ) ; fileMenu . add ( item ) ; if ( exportItems != null ) { for ( JMenuItem ei : exportItems ) { fileMenu . add ( ei ) ; } } fileMenu . addSeparator ( ) ; item = Toolkit . newJMenuItemShift ( Language . text ( "menu.file.page_setup" ) , 'P' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handlePageSetup ( ) ; } } ) ; fileMenu . add ( item ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.file.print" ) , 'P' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handlePrint ( ) ; } } ) ; fileMenu . add ( item ) ; if ( ! Base . isMacOS ( ) ) { fileMenu . addSeparator ( ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.file.preferences" ) , ',' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . handlePrefs ( ) ; } } ) ; fileMenu . add ( item ) ; fileMenu . addSeparator ( ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.file.quit" ) , 'Q' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . handleQuit ( ) ; } } ) ; fileMenu . add ( item ) ; } return fileMenu ; } protected JMenu buildEditMenu ( ) { JMenu menu = new JMenu ( Language . text ( "menu.edit" ) ) ; JMenuItem item ; undoItem = Toolkit . newJMenuItem ( Language . text ( "menu.edit.undo" ) , 'Z' ) ; undoItem . addActionListener ( undoAction = new UndoAction ( ) ) ; menu . add ( undoItem ) ; if ( Base . isWindows ( ) ) { redoItem = Toolkit . newJMenuItem ( Language . text ( "menu.edit.redo" ) , 'Y' ) ; } else { redoItem = Toolkit . newJMenuItemShift ( Language . text ( "menu.edit.redo" ) , 'Z' ) ; } redoItem . addActionListener ( redoAction = new RedoAction ( ) ) ; menu . add ( redoItem ) ; menu . addSeparator ( ) ; cutItems = Toolkit . newJMenuItem ( Language . text ( "menu.edit.cut" ) , 'X' ) ; cutItems . addActionListener ( cutAction = new CutAction ( ) ) ; menu . add ( cutItems ) ; copyItems = Toolkit . newJMenuItem ( Language . text ( "menu.edit.copy" ) , 'C' ) ; copyItems . addActionListener ( copyAction = new CopyAction ( ) ) ; menu . add ( copyItems ) ; item = Toolkit . newJMenuItemShift ( Language . text ( "menu.edit.copy_as_html" ) , 'C' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleCopyAsHTML ( ) ; } } ) ; menu . add ( item ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.edit.paste" ) , 'V' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { textarea . paste ( ) ; sketch . setModified ( true ) ; } } ) ; menu . add ( item ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.edit.select_all" ) , 'A' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { textarea . selectAll ( ) ; } } ) ; menu . add ( item ) ; menu . addSeparator ( ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.edit.auto_format" ) , 'T' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleAutoFormat ( ) ; } } ) ; menu . add ( item ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.edit.comment_uncomment" ) , '/' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleCommentUncomment ( ) ; } } ) ; menu . add ( item ) ; item = Toolkit . newJMenuItem ( "\u2192 " + Language . text ( "menu.edit.increase_indent" ) , ']' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleIndentOutdent ( true ) ; } } ) ; menu . add ( item ) ; item = Toolkit . newJMenuItem ( "\u2190 " + Language . text ( "menu.edit.decrease_indent" ) , '[' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleIndentOutdent ( false ) ; } } ) ; menu . add ( item ) ; menu . addSeparator ( ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.edit.find" ) , 'F' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( find == null ) { find = new FindReplace ( Editor . this ) ; } find . setVisible ( true ) ; } } ) ; menu . add ( item ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.edit.find_next" ) , 'G' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( find != null ) { find . findNext ( ) ; } } } ) ; menu . add ( item ) ; item = Toolkit . newJMenuItemShift ( Language . text ( "menu.edit.find_previous" ) , 'G' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( find != null ) { find . findPrevious ( ) ; } } } ) ; menu . add ( item ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.edit.use_selection_for_find" ) , 'E' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( find == null ) { find = new FindReplace ( Editor . this ) ; } find . setFindText ( getSelectedText ( ) ) ; } } ) ; menu . add ( item ) ; menu . addMenuListener ( new MenuListener ( ) { @ Override public void menuCanceled ( MenuEvent e ) { copyItems . setEnabled ( true ) ; cutItems . setEnabled ( true ) ; } @ Override public void menuDeselected ( MenuEvent e ) { copyItems . setEnabled ( true ) ; cutItems . setEnabled ( true ) ; } @ Override public void menuSelected ( MenuEvent e ) { copyAction . updateCopyState ( ) ; cutAction . updateCutState ( ) ; } } ) ; return menu ; } abstract public JMenu buildSketchMenu ( ) ; protected JMenu buildSketchMenu ( JMenuItem [ ] runItems ) { JMenuItem item ; sketchMenu = new JMenu ( Language . text ( "menu.sketch" ) ) ; for ( JMenuItem mi : runItems ) { sketchMenu . add ( mi ) ; } sketchMenu . addSeparator ( ) ; sketchMenu . add ( mode . getImportMenu ( ) ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.sketch.show_sketch_folder" ) , 'K' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Base . openFolder ( sketch . getFolder ( ) ) ; } } ) ; sketchMenu . add ( item ) ; item . setEnabled ( Base . openFolderAvailable ( ) ) ; item = new JMenuItem ( Language . text ( "menu.sketch.add_file" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { sketch . handleAddFile ( ) ; } } ) ; sketchMenu . add ( item ) ; if ( runItems != null && runItems . length != 0 ) { sketchMenu . addSeparator ( ) ; } sketchMenu . addMenuListener ( new MenuListener ( ) { List < JMenuItem > menuList = new ArrayList < JMenuItem > ( ) ; @ Override public void menuSelected ( MenuEvent event ) { JMenuItem item ; for ( final Editor editor : base . getEditors ( ) ) { if ( getSketch ( ) . getMainFilePath ( ) . equals ( editor . getSketch ( ) . getMainFilePath ( ) ) ) { item = new JCheckBoxMenuItem ( editor . getSketch ( ) . getName ( ) ) ; item . setSelected ( true ) ; } else { item = new JMenuItem ( editor . getSketch ( ) . getName ( ) ) ; } item . setText ( editor . getSketch ( ) . getName ( ) + " (" + editor . getMode ( ) . getTitle ( ) + ")" ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { editor . setState ( Frame . NORMAL ) ; editor . setVisible ( true ) ; editor . toFront ( ) ; } } ) ; sketchMenu . add ( item ) ; menuList . add ( item ) ; Toolkit . setMenuMnemsInside ( sketchMenu ) ; } } @ Override public void menuDeselected ( MenuEvent event ) { for ( JMenuItem item : menuList ) { sketchMenu . remove ( item ) ; } menuList . clear ( ) ; } @ Override public void menuCanceled ( MenuEvent event ) { menuDeselected ( event ) ; } } ) ; return sketchMenu ; } abstract public void handleImportLibrary ( String name ) ; public JMenu getToolMenu ( ) { if ( toolsMenu == null ) { rebuildToolMenu ( ) ; } return toolsMenu ; } public void rebuildToolMenu ( ) { if ( toolsMenu == null ) { toolsMenu = new JMenu ( Language . text ( "menu.tools" ) ) ; } else { toolsMenu . removeAll ( ) ; } coreTools = ToolContribution . loadAll ( Base . getToolsFolder ( ) ) ; contribTools = ToolContribution . loadAll ( Base . getSketchbookToolsFolder ( ) ) ; addInternalTools ( toolsMenu ) ; addTools ( toolsMenu , coreTools ) ; addTools ( toolsMenu , contribTools ) ; toolsMenu . addSeparator ( ) ; JMenuItem item = new JMenuItem ( Language . text ( "menu.tools.add_tool" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . handleOpenToolManager ( ) ; } } ) ; toolsMenu . add ( item ) ; } public void clearToolMenu ( ) { toolsMenu . removeAll ( ) ; System . gc ( ) ; } public void removeTool ( ) { rebuildToolMenu ( ) ; } void addToolItem ( final Tool tool , Map < String , JMenuItem > toolItems ) { String title = tool . getMenuTitle ( ) ; final JMenuItem item = new JMenuItem ( title ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { try { tool . run ( ) ; } catch ( NoSuchMethodError nsme ) { statusError ( "\"" + tool . getMenuTitle ( ) + "\" is not" + "compatible with this version of Processing" ) ; Base . loge ( "Incompatible tool found during tool.run()" , nsme ) ; item . setEnabled ( false ) ; } catch ( Exception ex ) { statusError ( "An error occurred inside \"" + tool . getMenuTitle ( ) + "\"" ) ; ex . printStackTrace ( ) ; item . setEnabled ( false ) ; } } } ) ; toolItems . put ( title , item ) ; } protected void addTools ( JMenu menu , List < ToolContribution > tools ) { Map < String , JMenuItem > toolItems = new HashMap < String , JMenuItem > ( ) ; for ( final ToolContribution tool : tools ) { try { tool . init ( Editor . this ) ; addToolItem ( tool , toolItems ) ; } catch ( VerifyError ve ) { System . err . println ( "\"" + tool . getMenuTitle ( ) + "\" is not " + "compatible with this version of Processing" ) ; } catch ( NoSuchMethodError nsme ) { System . err . println ( "\"" + tool . getMenuTitle ( ) + "\" is not " + "compatible with this version of Processing" ) ; System . err . println ( "The " + nsme . getMessage ( ) + " method no longer exists." ) ; Base . loge ( "Incompatible Tool found during tool.init()" , nsme ) ; } catch ( NoClassDefFoundError ncdfe ) { System . err . println ( "\"" + tool . getMenuTitle ( ) + "\" is not " + "compatible with this version of Processing" ) ; System . err . println ( "The " + ncdfe . getMessage ( ) + " class is no longer available." ) ; Base . loge ( "Incompatible Tool found during tool.init()" , ncdfe ) ; } catch ( Error err ) { System . err . println ( "An error occurred inside \"" + tool . getMenuTitle ( ) + "\"" ) ; err . printStackTrace ( ) ; } catch ( Exception ex ) { System . err . println ( "An exception occurred inside \"" + tool . getMenuTitle ( ) + "\"" ) ; ex . printStackTrace ( ) ; } } ArrayList < String > toolList = new ArrayList < String > ( toolItems . keySet ( ) ) ; if ( toolList . size ( ) > 0 ) { menu . addSeparator ( ) ; Collections . sort ( toolList ) ; for ( String title : toolList ) { menu . add ( toolItems . get ( title ) ) ; } } } public JMenu buildModeMenu ( ) { return null ; } protected void addToolMenuItem ( JMenu menu , String className ) { try { Class < ? > toolClass = Class . forName ( className ) ; final Tool tool = ( Tool ) toolClass . newInstance ( ) ; JMenuItem item = new JMenuItem ( tool . getMenuTitle ( ) ) ; tool . init ( Editor . this ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { EventQueue . invokeLater ( tool ) ; } } ) ; menu . add ( item ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } protected JMenu addInternalTools ( JMenu menu ) { addToolMenuItem ( menu , "processing.app.tools.CreateFont" ) ; addToolMenuItem ( menu , "processing.app.tools.ColorSelector" ) ; addToolMenuItem ( menu , "processing.app.tools.Archiver" ) ; if ( Base . isMacOS ( ) ) { addToolMenuItem ( menu , "processing.app.tools.InstallCommander" ) ; } return menu ; } abstract public JMenu buildHelpMenu ( ) ; public void showReference ( String filename ) { File file = new File ( mode . getReferenceFolder ( ) , filename ) ; showReferenceFile ( file ) ; } public void showReferenceFile ( File file ) { try { file = file . getCanonicalFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } Base . openURL ( file . toURI ( ) . toString ( ) ) ; } static public void showChanges ( ) { if ( ! Base . isCommandLine ( ) ) { Base . openURL ( "http://wiki.processing.org/w/Changes" ) ; } } class CutAction extends AbstractAction { public CutAction ( ) { super ( Language . text ( "menu.edit.cut" ) ) ; this . setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { handleCut ( ) ; } public void updateCutState ( ) { cutItems . setEnabled ( canCut ( ) ) ; } public boolean canCut ( ) { return textarea . isSelectionActive ( ) ; } } class CopyAction extends AbstractAction { public CopyAction ( ) { super ( Language . text ( "menu.edit.copy" ) ) ; this . setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { textarea . copy ( ) ; } public void updateCopyState ( ) { copyItems . setEnabled ( canCopy ( ) ) ; } public boolean canCopy ( ) { return textarea . isSelectionActive ( ) ; } } class UndoAction extends AbstractAction { public UndoAction ( ) { super ( Language . text ( "menu.edit.undo" ) ) ; this . setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { stopCompoundEdit ( ) ; try { final Integer caret = caretUndoStack . pop ( ) ; caretRedoStack . push ( caret ) ; textarea . setCaretPosition ( caret ) ; textarea . scrollToCaret ( ) ; } catch ( Exception ignore ) { } try { undo . undo ( ) ; } catch ( CannotUndoException ex ) { } updateUndoState ( ) ; redoAction . updateRedoState ( ) ; if ( sketch != null ) { sketch . setModified ( ! getText ( ) . equals ( sketch . getCurrentCode ( ) . getSavedProgram ( ) ) ) ; } } protected void updateUndoState ( ) { if ( undo . canUndo ( ) || compoundEdit != null && compoundEdit . isInProgress ( ) ) { this . setEnabled ( true ) ; undoItem . setEnabled ( true ) ; String newUndoPresentationName = Language . text ( "menu.edit.undo" ) ; if ( undo . getUndoPresentationName ( ) . equals ( "Undo addition" ) ) { newUndoPresentationName += " " + Language . text ( "menu.edit.action.addition" ) ; } else if ( undo . getUndoPresentationName ( ) . equals ( "Undo deletion" ) ) { newUndoPresentationName += " " + Language . text ( "menu.edit.action.deletion" ) ; } undoItem . setText ( newUndoPresentationName ) ; putValue ( Action . NAME , newUndoPresentationName ) ; } else { this . setEnabled ( false ) ; undoItem . setEnabled ( false ) ; undoItem . setText ( Language . text ( "menu.edit.undo" ) ) ; putValue ( Action . NAME , Language . text ( "menu.edit.undo" ) ) ; } } } class RedoAction extends AbstractAction { public RedoAction ( ) { super ( Language . text ( "menu.edit.redo" ) ) ; this . setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { stopCompoundEdit ( ) ; try { undo . redo ( ) ; } catch ( CannotRedoException ex ) { } try { final Integer caret = caretRedoStack . pop ( ) ; caretUndoStack . push ( caret ) ; textarea . setCaretPosition ( caret ) ; } catch ( Exception ignore ) { } updateRedoState ( ) ; undoAction . updateUndoState ( ) ; if ( sketch != null ) { sketch . setModified ( ! getText ( ) . equals ( sketch . getCurrentCode ( ) . getSavedProgram ( ) ) ) ; } } protected void updateRedoState ( ) { if ( undo . canRedo ( ) ) { redoItem . setEnabled ( true ) ; String newRedoPresentationName = Language . text ( "menu.edit.redo" ) ; if ( undo . getRedoPresentationName ( ) . equals ( "Redo addition" ) ) { newRedoPresentationName += " " + Language . text ( "menu.edit.action.addition" ) ; } else if ( undo . getRedoPresentationName ( ) . equals ( "Redo deletion" ) ) { newRedoPresentationName += " " + Language . text ( "menu.edit.action.deletion" ) ; } redoItem . setText ( newRedoPresentationName ) ; putValue ( Action . NAME , newRedoPresentationName ) ; } else { this . setEnabled ( false ) ; redoItem . setEnabled ( false ) ; redoItem . setText ( Language . text ( "menu.edit.redo" ) ) ; putValue ( Action . NAME , Language . text ( "menu.edit.redo" ) ) ; } } } public Sketch getSketch ( ) { return sketch ; } public JEditTextArea getTextArea ( ) { return textarea ; } public String getText ( ) { return textarea . getText ( ) ; } public String getText ( int start , int stop ) { return textarea . getText ( start , stop - start ) ; } public void setText ( String what ) { startCompoundEdit ( ) ; textarea . setText ( what ) ; stopCompoundEdit ( ) ; } public void insertText ( String what ) { startCompoundEdit ( ) ; int caret = getCaretOffset ( ) ; setSelection ( caret , caret ) ; textarea . setSelectedText ( what ) ; stopCompoundEdit ( ) ; } public String getSelectedText ( ) { return textarea . getSelectedText ( ) ; } public void setSelectedText ( String what ) { textarea . setSelectedText ( what ) ; } public void setSelection ( int start , int stop ) { start = PApplet . constrain ( start , 0 , textarea . getDocumentLength ( ) ) ; stop = PApplet . constrain ( stop , 0 , textarea . getDocumentLength ( ) ) ; textarea . select ( start , stop ) ; } public int getCaretOffset ( ) { return textarea . getCaretPosition ( ) ; } public boolean isSelectionActive ( ) { return textarea . isSelectionActive ( ) ; } public int getSelectionStart ( ) { return textarea . getSelectionStart ( ) ; } public int getSelectionStop ( ) { return textarea . getSelectionStop ( ) ; } public String getLineText ( int line ) { return textarea . getLineText ( line ) ; } public void setLineText ( int line , String what ) { startCompoundEdit ( ) ; textarea . select ( getLineStartOffset ( line ) , getLineStopOffset ( line ) ) ; textarea . setSelectedText ( what ) ; stopCompoundEdit ( ) ; } public int getLineStartOffset ( int line ) { return textarea . getLineStartOffset ( line ) ; } public int getLineStopOffset ( int line ) { return textarea . getLineStopOffset ( line ) ; } public int getLineCount ( ) { return textarea . getLineCount ( ) ; } public void startCompoundEdit ( ) { stopCompoundEdit ( ) ; compoundEdit = new CompoundEdit ( ) ; } public void stopCompoundEdit ( ) { if ( compoundEdit != null ) { compoundEdit . end ( ) ; undo . addEdit ( compoundEdit ) ; caretUndoStack . push ( textarea . getCaretPosition ( ) ) ; caretRedoStack . clear ( ) ; undoAction . updateUndoState ( ) ; redoAction . updateRedoState ( ) ; compoundEdit = null ; } } public int getScrollPosition ( ) { return textarea . getVerticalScrollPosition ( ) ; } protected void setCode ( SketchCode code ) { SyntaxDocument document = ( SyntaxDocument ) code . getDocument ( ) ; if ( document == null ) { document = new SyntaxDocument ( ) ; code . setDocument ( document ) ; document . setTokenMarker ( mode . getTokenMarker ( ) ) ; try { document . insertString ( 0 , code . getProgram ( ) , null ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } document . addDocumentListener ( new DocumentListener ( ) { public void removeUpdate ( DocumentEvent e ) { if ( isInserting && isDirectEdit ( ) ) { endTextEditHistory ( ) ; } isInserting = false ; } public void insertUpdate ( DocumentEvent e ) { if ( ! isInserting && isDirectEdit ( ) ) { endTextEditHistory ( ) ; } isInserting = true ; } public void changedUpdate ( DocumentEvent e ) { endTextEditHistory ( ) ; } } ) ; document . addUndoableEditListener ( new UndoableEditListener ( ) { public void undoableEditHappened ( UndoableEditEvent e ) { if ( endUndoEvent != null ) { endUndoEvent . cancel ( ) ; endUndoEvent = null ; startTimerEvent ( ) ; } if ( compoundEdit == null ) { startCompoundEdit ( ) ; startTimerEvent ( ) ; } compoundEdit . addEdit ( e . getEdit ( ) ) ; undoAction . updateUndoState ( ) ; redoAction . updateRedoState ( ) ; } } ) ; } textarea . setDocument ( document , code . getSelectionStart ( ) , code . getSelectionStop ( ) , code . getScrollPosition ( ) ) ; textarea . requestFocusInWindow ( ) ; this . undo = code . getUndo ( ) ; undoAction . updateUndoState ( ) ; redoAction . updateRedoState ( ) ; } boolean isDirectEdit ( ) { return endUndoEvent != null ; } void startTimerEvent ( ) { endUndoEvent = new TimerTask ( ) { public void run ( ) { endTextEditHistory ( ) ; } } ; timer . schedule ( endUndoEvent , 3000 ) ; timer . purge ( ) ; } void endTextEditHistory ( ) { if ( endUndoEvent != null ) { endUndoEvent . cancel ( ) ; endUndoEvent = null ; } stopCompoundEdit ( ) ; } public void handleCut ( ) { textarea . cut ( ) ; sketch . setModified ( true ) ; } public void handleCopy ( ) { textarea . copy ( ) ; } public void handleCopyAsHTML ( ) { textarea . copyAsHTML ( ) ; statusNotice ( Language . text ( "editor.status.copy_as_html" ) ) ; } public void handlePaste ( ) { textarea . paste ( ) ; sketch . setModified ( true ) ; } public void handleSelectAll ( ) { textarea . selectAll ( ) ; } public void handleAutoFormat ( ) { final String source = getText ( ) ; try { final String formattedText = createFormatter ( ) . format ( source ) ; int selectionEnd = getSelectionStop ( ) ; if ( formattedText . length ( ) < selectionEnd - 1 ) { selectionEnd = formattedText . length ( ) - 1 ; } if ( formattedText . equals ( source ) ) { statusNotice ( Language . text ( "editor.status.autoformat.no_changes" ) ) ; } else { int scrollPos = textarea . getVerticalScrollPosition ( ) ; setText ( formattedText ) ; setSelection ( selectionEnd , selectionEnd ) ; if ( scrollPos != textarea . getVerticalScrollPosition ( ) ) { textarea . setVerticalScrollPosition ( scrollPos ) ; } getSketch ( ) . setModified ( true ) ; statusNotice ( Language . text ( "editor.status.autoformat.finished" ) ) ; } } catch ( final Exception e ) { statusError ( e ) ; } } abstract public String getCommentPrefix ( ) ; protected void handleCommentUncomment ( ) { startCompoundEdit ( ) ; String prefix = getCommentPrefix ( ) ; int prefixLen = prefix . length ( ) ; int startLine = textarea . getSelectionStartLine ( ) ; int stopLine = textarea . getSelectionStopLine ( ) ; int lastLineStart = textarea . getLineStartOffset ( stopLine ) ; int selectionStop = textarea . getSelectionStop ( ) ; if ( selectionStop == lastLineStart ) { if ( textarea . isSelectionActive ( ) ) { stopLine -- ; } } boolean commented = true ; for ( int i = startLine ; commented && ( i <= stopLine ) ; i ++ ) { String lineText = textarea . getLineText ( i ) . trim ( ) ; if ( lineText . length ( ) == 0 ) { continue ; } commented = lineText . startsWith ( prefix ) ; } int lso = Math . abs ( textarea . getLineStartNonWhiteSpaceOffset ( startLine ) - textarea . getLineStartOffset ( startLine ) ) ; for ( int line = startLine ; line <= stopLine ; line ++ ) { int location = textarea . getLineStartNonWhiteSpaceOffset ( line ) ; String lineText = textarea . getLineText ( line ) ; if ( lineText . trim ( ) . length ( ) == 0 ) continue ; if ( commented ) { if ( lineText . trim ( ) . startsWith ( prefix + " " ) ) { textarea . select ( location , location + prefixLen + 1 ) ; } else { textarea . select ( location , location + prefixLen ) ; } textarea . setSelectedText ( "" ) ; } else { location = textarea . getLineStartOffset ( line ) + lso ; textarea . select ( location , location ) ; textarea . setSelectedText ( prefix ) ; } } textarea . select ( textarea . getLineStartOffset ( startLine ) , textarea . getLineStopOffset ( stopLine ) - 1 ) ; stopCompoundEdit ( ) ; sketch . setModified ( true ) ; } public void handleIndent ( ) { handleIndentOutdent ( true ) ; } public void handleOutdent ( ) { handleIndentOutdent ( false ) ; } public void handleIndentOutdent ( boolean indent ) { int tabSize = Preferences . getInteger ( "editor.tabs.size" ) ; String tabString = Editor . EMPTY . substring ( 0 , tabSize ) ; startCompoundEdit ( ) ; int startLine = textarea . getSelectionStartLine ( ) ; int stopLine = textarea . getSelectionStopLine ( ) ; int lastLineStart = textarea . getLineStartOffset ( stopLine ) ; int selectionStop = textarea . getSelectionStop ( ) ; if ( selectionStop == lastLineStart ) { if ( textarea . isSelectionActive ( ) ) { stopLine -- ; } } for ( int line = startLine ; line <= stopLine ; line ++ ) { int location = textarea . getLineStartOffset ( line ) ; if ( indent ) { textarea . select ( location , location ) ; textarea . setSelectedText ( tabString ) ; } else { int last = Math . min ( location + tabSize , textarea . getDocumentLength ( ) ) ; textarea . select ( location , last ) ; if ( textarea . getSelectedText ( ) . equals ( tabString ) ) { textarea . setSelectedText ( "" ) ; } } } textarea . select ( textarea . getLineStartOffset ( startLine ) , textarea . getLineStopOffset ( stopLine ) - 1 ) ; stopCompoundEdit ( ) ; sketch . setModified ( true ) ; } static public boolean checkParen ( char [ ] array , int index , int stop ) { while ( index < stop ) { switch ( array [ index ] ) { case '(' : return true ; case ' ' : case '\t' : case '\n' : case '\r' : index ++ ; break ; default : return false ; } } return false ; } protected boolean functionable ( char c ) { return ( c == '_' ) || ( c >= 'a' && c <= 'z' ) || ( c >= 'A' && c <= 'Z' ) ; } protected String referenceCheck ( boolean selectIfFound ) { int start = textarea . getSelectionStart ( ) ; int stop = textarea . getSelectionStop ( ) ; if ( stop < start ) { int temp = stop ; stop = start ; start = temp ; } char [ ] c = textarea . getText ( ) . toCharArray ( ) ; if ( start == stop ) { while ( start > 0 && functionable ( c [ start - 1 ] ) ) { start -- ; } while ( stop < c . length && functionable ( c [ stop ] ) ) { stop ++ ; } } String text = new String ( c , start , stop - start ) . trim ( ) ; if ( checkParen ( c , stop , c . length ) ) { text += "_" ; } String ref = mode . lookupReference ( text ) ; if ( selectIfFound ) { textarea . select ( start , stop ) ; } return ref ; } protected void handleFindReference ( ) { String ref = referenceCheck ( true ) ; if ( ref != null ) { showReference ( ref + ".html" ) ; } else { String text = textarea . getSelectedText ( ) . trim ( ) ; if ( text . length ( ) == 0 ) { statusNotice ( Language . text ( "editor.status.find_reference.select_word_first" ) ) ; } else { statusNotice ( Language . interpolate ( "editor.status.find_reference.not_available" , text ) ) ; } } } public void setSketchLocation ( Point p ) { sketchWindowLocation = p ; } public Point getSketchLocation ( ) { return sketchWindowLocation ; } protected boolean checkModified ( ) { if ( ! sketch . isModified ( ) ) return true ; toFront ( ) ; String prompt = Language . text ( "close.unsaved_changes" ) + " " + sketch . getName ( ) + "? " ; if ( ! Base . isMacOS ( ) ) { int result = JOptionPane . showConfirmDialog ( this , prompt , Language . text ( "menu.file.close" ) , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( result == JOptionPane . YES_OPTION ) { return handleSave ( true ) ; } else if ( result == JOptionPane . NO_OPTION ) { return true ; } else if ( result == JOptionPane . CANCEL_OPTION || result == JOptionPane . CLOSED_OPTION ) { return false ; } else { throw new IllegalStateException ( ) ; } } else { JOptionPane pane = new JOptionPane ( "<html> " + "<head> <style type=\"text/css\">" + "b { font: 13pt \"Lucida Grande\" }" + "p { font: 11pt \"Lucida Grande\"; margin-top: 8px }" + "</style> </head>" + "<b>" + Language . text ( "save.title" ) + "</b>" + "<p>" + Language . text ( "save.hint" ) + "</p>" , JOptionPane . QUESTION_MESSAGE ) ; String [ ] options = new String [ ] { Language . text ( "save.btn.save" ) , Language . text ( "prompt.cancel" ) , Language . text ( "save.btn.dont_save" ) } ; pane . setOptions ( options ) ; pane . setInitialValue ( options [ 0 ] ) ; pane . putClientProperty ( "Quaqua.OptionPane.destructiveOption" , new Integer ( 2 ) ) ; JDialog dialog = pane . createDialog ( this , null ) ; dialog . setVisible ( true ) ; Object result = pane . getValue ( ) ; if ( result == options [ 0 ] ) { return handleSave ( true ) ; } else if ( result == options [ 2 ] ) { return true ; } else { return false ; } } } protected boolean handleOpenInternal ( String path ) { final File file = new File ( path ) ; final File parentFile = new File ( file . getParent ( ) ) ; final String parentName = parentFile . getName ( ) ; final String defaultName = parentName + "." + mode . getDefaultExtension ( ) ; final File altFile = new File ( file . getParent ( ) , defaultName ) ; if ( defaultName . equals ( file . getName ( ) ) ) { } else if ( altFile . exists ( ) ) { path = altFile . getAbsolutePath ( ) ; } else if ( ! mode . canEdit ( file ) ) { final String modeName = ( mode . getTitle ( ) . equals ( "Java" ) ) ? "Processing" : mode . getTitle ( ) ; Base . showWarning ( "Bad file selected" , modeName + " can only open its own sketches\nand other files ending in " + mode . getDefaultExtension ( ) , null ) ; return false ; } else { final String properParent = file . getName ( ) . substring ( 0 , file . getName ( ) . lastIndexOf ( '.' ) ) ; Object [ ] options = { Language . text ( "prompt.ok" ) , Language . text ( "prompt.cancel" ) } ; String prompt = "The file \"" + file . getName ( ) + "\" needs to be inside\n" + "a sketch folder named \"" + properParent + "\".\n" + "Create this folder, move the file, and continue?" ; int result = JOptionPane . showOptionDialog ( this , prompt , "Moving" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , options [ 0 ] ) ; if ( result == JOptionPane . YES_OPTION ) { File properFolder = new File ( file . getParent ( ) , properParent ) ; if ( properFolder . exists ( ) ) { Base . showWarning ( "Error" , "A folder named \"" + properParent + "\" " + "already exists. Can't open sketch." , null ) ; return false ; } if ( ! properFolder . mkdirs ( ) ) { Base . showWarning ( "Error" , "Could not create the sketch folder." , null ) ; return false ; } File properPdeFile = new File ( properFolder , file . getName ( ) ) ; File origPdeFile = new File ( path ) ; try { Base . copyFile ( origPdeFile , properPdeFile ) ; } catch ( IOException e ) { Base . showWarning ( "Error" , "Could not copy to a proper location." , e ) ; return false ; } origPdeFile . delete ( ) ; path = properPdeFile . getAbsolutePath ( ) ; } else if ( result == JOptionPane . NO_OPTION ) { return false ; } } try { sketch = new Sketch ( path , this ) ; } catch ( IOException e ) { Base . showWarning ( "Error" , "Could not create the sketch." , e ) ; return false ; } header . rebuild ( ) ; updateTitle ( ) ; Preferences . save ( ) ; return true ; } public void updateTitle ( ) { setTitle ( sketch . getName ( ) + " | Processing " + Base . getVersionName ( ) ) ; if ( ! sketch . isUntitled ( ) ) { File sketchFile = sketch . getMainFile ( ) ; getRootPane ( ) . putClientProperty ( "Window.documentFile" , sketchFile ) ; } else { getRootPane ( ) . putClientProperty ( "Window.documentFile" , null ) ; } } public boolean handleSave ( boolean immediately ) { if ( sketch . isUntitled ( ) ) { return handleSaveAs ( ) ; } else if ( immediately ) { handleSaveImpl ( ) ; } else { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { handleSaveImpl ( ) ; } } ) ; } return true ; } protected void handleSaveImpl ( ) { statusNotice ( Language . text ( "editor.status.saving" ) ) ; try { if ( sketch . save ( ) ) { statusNotice ( Language . text ( "editor.status.saving.done" ) ) ; } else { statusEmpty ( ) ; } } catch ( Exception e ) { statusError ( e ) ; } } public boolean handleSaveAs ( ) { statusNotice ( Language . text ( "editor.status.saving" ) ) ; try { if ( sketch . saveAs ( ) ) { } else { statusNotice ( Language . text ( "editor.status.saving.canceled" ) ) ; return false ; } } catch ( Exception e ) { statusError ( e ) ; } return true ; } public void handlePageSetup ( ) { if ( printerJob == null ) { printerJob = PrinterJob . getPrinterJob ( ) ; } if ( pageFormat == null ) { pageFormat = printerJob . defaultPage ( ) ; } pageFormat = printerJob . pageDialog ( pageFormat ) ; } public void handlePrint ( ) { statusNotice ( Language . text ( "editor.status.printing" ) ) ; if ( printerJob == null ) { printerJob = PrinterJob . getPrinterJob ( ) ; } if ( pageFormat != null ) { printerJob . setPrintable ( textarea . getPrintable ( ) , pageFormat ) ; } else { printerJob . setPrintable ( textarea . getPrintable ( ) ) ; } printerJob . setJobName ( sketch . getCurrentCode ( ) . getPrettyName ( ) ) ; if ( printerJob . printDialog ( ) ) { try { printerJob . print ( ) ; statusNotice ( Language . text ( "editor.status.printing.done" ) ) ; } catch ( PrinterException pe ) { statusError ( Language . text ( "editor.status.printing.error" ) ) ; pe . printStackTrace ( ) ; } } else { statusNotice ( Language . text ( "editor.status.printing.canceled" ) ) ; } } public void prepareRun ( ) { internalCloseRunner ( ) ; statusEmpty ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) System . out . println ( ) ; if ( Preferences . getBoolean ( "console.auto_clear" ) ) { console . clear ( ) ; } sketch . ensureExistence ( ) ; sketch . getCurrentCode ( ) . setProgram ( getText ( ) ) ; } abstract public void internalCloseRunner ( ) ; abstract public void deactivateRun ( ) ; public void statusError ( String what ) { status . error ( what ) ; } public void statusError ( Exception e ) { e . printStackTrace ( ) ; if ( e instanceof SketchException ) { SketchException re = ( SketchException ) e ; if ( re . hasCodeIndex ( ) ) { sketch . setCurrentCode ( re . getCodeIndex ( ) ) ; } if ( re . hasCodeLine ( ) ) { int line = re . getCodeLine ( ) ; if ( line >= textarea . getLineCount ( ) ) { line = textarea . getLineCount ( ) - 1 ; if ( textarea . getLineText ( line ) . length ( ) == 0 ) { line -- ; } } if ( line < 0 || line >= textarea . getLineCount ( ) ) { System . err . println ( "Bad error line: " + line ) ; } else { textarea . select ( textarea . getLineStartOffset ( line ) , textarea . getLineStopOffset ( line ) - 1 ) ; } } } String mess = e . getMessage ( ) ; if ( mess != null ) { String javaLang = "java.lang." ; if ( mess . indexOf ( javaLang ) == 0 ) { mess = mess . substring ( javaLang . length ( ) ) ; } String rxString = "RuntimeException: " ; if ( mess . startsWith ( rxString ) ) { mess = mess . substring ( rxString . length ( ) ) ; } String illString = "IllegalArgumentException: " ; if ( mess . startsWith ( illString ) ) { mess = mess . substring ( illString . length ( ) ) ; } statusError ( mess ) ; } } public void statusNotice ( String msg ) { if ( msg == null ) { new IllegalArgumentException ( "This code called statusNotice(null)" ) . printStackTrace ( ) ; msg = "" ; } status . notice ( msg ) ; } public void clearNotice ( String msg ) { if ( status . message . equals ( msg ) ) { statusEmpty ( ) ; } } public String getStatusMessage ( ) { return status . message ; } public int getStatusMode ( ) { return status . mode ; } public void statusEmpty ( ) { statusNotice ( EMPTY ) ; } public void startIndeterminate ( ) { status . startIndeterminate ( ) ; } public void stopIndeterminate ( ) { status . stopIndeterminate ( ) ; } public void statusHalt ( ) { } public boolean isHalted ( ) { return false ; } class TextAreaPopup extends JPopupMenu { JMenuItem cutItem , copyItem , discourseItem , pasteItem , selectAllItem , commUncommItem , incIndItem , decIndItem , referenceItem ; public TextAreaPopup ( ) { JMenuItem item ; cutItem = new JMenuItem ( Language . text ( "menu.edit.cut" ) ) ; cutItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleCut ( ) ; } } ) ; this . add ( cutItem ) ; copyItem = new JMenuItem ( Language . text ( "menu.edit.copy" ) ) ; copyItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleCopy ( ) ; } } ) ; this . add ( copyItem ) ; discourseItem = new JMenuItem ( Language . text ( "menu.edit.copy_as_html" ) ) ; discourseItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleCopyAsHTML ( ) ; } } ) ; this . add ( discourseItem ) ; item = new JMenuItem ( Language . text ( "menu.edit.paste" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handlePaste ( ) ; } } ) ; this . add ( item ) ; item = new JMenuItem ( Language . text ( "menu.edit.select_all" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleSelectAll ( ) ; } } ) ; this . add ( item ) ; this . addSeparator ( ) ; item = new JMenuItem ( Language . text ( "menu.edit.comment_uncomment" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleCommentUncomment ( ) ; } } ) ; this . add ( item ) ; item = new JMenuItem ( "\u2192 " + Language . text ( "menu.edit.increase_indent" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleIndentOutdent ( true ) ; } } ) ; this . add ( item ) ; item = new JMenuItem ( "\u2190 " + Language . text ( "menu.edit.decrease_indent" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleIndentOutdent ( false ) ; } } ) ; this . add ( item ) ; this . addSeparator ( ) ; referenceItem = new JMenuItem ( Language . text ( "find_in_reference" ) ) ; referenceItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { handleFindReference ( ) ; } } ) ; this . add ( referenceItem ) ; Toolkit . setMenuMnemonics ( this ) ; } public void show ( Component component , int x , int y ) { boolean active = textarea . isSelectionActive ( ) ; cutItem . setEnabled ( active ) ; copyItem . setEnabled ( active ) ; discourseItem . setEnabled ( active ) ; referenceItem . setEnabled ( referenceCheck ( false ) != null ) ; super . show ( component , x , y ) ; } } }
package processing . app ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import javax . swing . JFrame ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . JProgressBar ; import javax . swing . SwingWorker ; public class ProgressFrame extends JFrame implements PropertyChangeListener { private JProgressBar progressBar ; private JLabel label ; private File [ ] copyItems ; private File newFolder ; private File addFile , sourceFile ; private Editor editor ; public class TaskSaveAs extends SwingWorker < Void , Void > { @ Override protected Void doInBackground ( ) throws Exception { long totalSize = 0 ; for ( File copyable : copyItems ) { totalSize += calcSize ( copyable ) ; } long progress = 0 ; setProgress ( 0 ) ; for ( File copyable : ProgressFrame . this . copyItems ) { if ( copyable . isDirectory ( ) ) { copyDir ( copyable , new File ( ProgressFrame . this . newFolder , copyable . getName ( ) ) , progress , totalSize ) ; progress += calcSize ( copyable ) ; } else { copyFile ( copyable , new File ( ProgressFrame . this . newFolder , copyable . getName ( ) ) , progress , totalSize ) ; if ( calcSize ( copyable ) < 524288 ) { progress += calcSize ( copyable ) ; setProgress ( ( int ) ( progress * 100L / totalSize ) ) ; } } } return null ; } private void copyFile ( File sourceFile , File targetFile , double progress , long totalSize ) throws IOException { BufferedInputStream from = new BufferedInputStream ( new FileInputStream ( sourceFile ) ) ; BufferedOutputStream to = new BufferedOutputStream ( new FileOutputStream ( targetFile ) ) ; byte [ ] buffer = new byte [ 16 * 1024 ] ; int bytesRead ; int totalRead = 0 ; while ( ( bytesRead = from . read ( buffer ) ) != - 1 ) { to . write ( buffer , 0 , bytesRead ) ; totalRead += bytesRead ; if ( totalRead >= 512 * 1024 ) { progress += totalRead ; setProgressBarStatus ( ( int ) Math . min ( Math . ceil ( progress * 100.0 / totalSize ) , 100 ) ) ; totalRead = 0 ; } } if ( sourceFile . length ( ) > 512 * 1024 ) { progress += totalRead ; setProgressBarStatus ( ( int ) Math . min ( Math . ceil ( progress * 100.0 / totalSize ) , 100 ) ) ; } from . close ( ) ; from = null ; to . flush ( ) ; to . close ( ) ; to = null ; targetFile . setLastModified ( sourceFile . lastModified ( ) ) ; targetFile . setExecutable ( sourceFile . canExecute ( ) ) ; } private double copyDir ( File sourceDir , File targetDir , double progress , long totalSize ) throws IOException { if ( sourceDir . equals ( targetDir ) ) { final String urDum = "source and target directories are identical" ; throw new IllegalArgumentException ( urDum ) ; } targetDir . mkdirs ( ) ; String files [ ] = sourceDir . list ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . charAt ( 0 ) == '.' ) continue ; File source = new File ( sourceDir , files [ i ] ) ; File target = new File ( targetDir , files [ i ] ) ; if ( source . isDirectory ( ) ) { progress = copyDir ( source , target , progress , totalSize ) ; setProgressBarStatus ( ( int ) Math . min ( Math . ceil ( progress * 100.0 / totalSize ) , 100 ) ) ; target . setLastModified ( source . lastModified ( ) ) ; } else { copyFile ( source , target , progress , totalSize ) ; progress += source . length ( ) ; setProgressBarStatus ( ( int ) Math . min ( Math . ceil ( progress * 100.0 / totalSize ) , 100 ) ) ; } } return progress ; } public void setProgressBarStatus ( int status ) { setProgress ( status ) ; } @ Override public void done ( ) { editor . statusNotice ( Language . text ( "editor.status.saving.done" ) ) ; dispose ( ) ; } } public class TaskAddFile extends SwingWorker < Void , Void > { @ Override protected Void doInBackground ( ) throws Exception { setProgress ( 0 ) ; copyFile ( sourceFile , addFile ) ; if ( addFile . length ( ) < 1024 ) { setProgress ( 100 ) ; } return null ; } private void copyFile ( File sourceFile , File targetFile ) throws IOException { long totalSize = sourceFile . length ( ) ; int progress = 0 ; BufferedInputStream from = new BufferedInputStream ( new FileInputStream ( sourceFile ) ) ; BufferedOutputStream to = new BufferedOutputStream ( new FileOutputStream ( targetFile ) ) ; byte [ ] buffer = new byte [ 16 * 1024 ] ; int bytesRead ; int totalRead = 0 ; while ( ( bytesRead = from . read ( buffer ) ) != - 1 ) { to . write ( buffer , 0 , bytesRead ) ; totalRead += bytesRead ; if ( totalRead >= 1024 ) { progress += totalRead ; setProgressBarStatus ( ( int ) Math . min ( Math . ceil ( progress * 100.0 / totalSize ) , 100 ) ) ; totalRead = 0 ; } } if ( sourceFile . length ( ) > 1024 ) { progress += totalRead ; setProgressBarStatus ( ( int ) Math . min ( Math . ceil ( progress * 100.0 / totalSize ) , 100 ) ) ; } from . close ( ) ; from = null ; to . flush ( ) ; to . close ( ) ; to = null ; targetFile . setLastModified ( sourceFile . lastModified ( ) ) ; targetFile . setExecutable ( sourceFile . canExecute ( ) ) ; } public void setProgressBarStatus ( int status ) { setProgress ( status ) ; } @ Override public void done ( ) { dispose ( ) ; } } public ProgressFrame ( File [ ] c , File nf , String oldName , String newName , Editor editor ) { copyItems = c ; newFolder = nf ; this . editor = editor ; setDefaultCloseOperation ( HIDE_ON_CLOSE ) ; setBounds ( 200 , 200 , 400 , 140 ) ; setResizable ( false ) ; setTitle ( "Saving As..." ) ; JPanel panel = new JPanel ( null ) ; add ( panel ) ; setContentPane ( panel ) ; label = new JLabel ( "Saving " + oldName + " as " + newName + "..." ) ; label . setBounds ( 40 , 20 , 300 , 20 ) ; progressBar = new JProgressBar ( 0 , 100 ) ; progressBar . setValue ( 0 ) ; progressBar . setBounds ( 40 , 50 , 300 , 30 ) ; progressBar . setStringPainted ( true ) ; panel . add ( progressBar ) ; panel . add ( label ) ; Toolkit . setIcon ( this ) ; this . setVisible ( true ) ; TaskSaveAs t = new TaskSaveAs ( ) ; t . addPropertyChangeListener ( this ) ; t . execute ( ) ; } public ProgressFrame ( File sf , File add , Editor editor ) { addFile = add ; sourceFile = sf ; this . editor = editor ; setDefaultCloseOperation ( HIDE_ON_CLOSE ) ; setBounds ( 200 , 200 , 400 , 140 ) ; setResizable ( false ) ; setTitle ( "Adding File..." ) ; JPanel panel = new JPanel ( null ) ; add ( panel ) ; setContentPane ( panel ) ; label = new JLabel ( "Adding " + addFile . getName ( ) ) ; label . setBounds ( 40 , 20 , 300 , 20 ) ; progressBar = new JProgressBar ( 0 , 100 ) ; progressBar . setValue ( 0 ) ; progressBar . setBounds ( 40 , 50 , 300 , 30 ) ; progressBar . setStringPainted ( true ) ; panel . add ( progressBar ) ; panel . add ( label ) ; Toolkit . setIcon ( this ) ; this . setVisible ( true ) ; TaskAddFile task = new TaskAddFile ( ) ; task . addPropertyChangeListener ( this ) ; task . execute ( ) ; } long calcSize ( File file ) { return file . isFile ( ) ? file . length ( ) : Base . calcFolderSize ( file ) ; } public void propertyChange ( PropertyChangeEvent evt ) { if ( "progress" . equals ( evt . getPropertyName ( ) ) ) { progressBar . setValue ( ( Integer ) evt . getNewValue ( ) ) ; } } }
package processing . app ; import java . awt . * ; import java . io . * ; import java . util . * ; import processing . core . * ; public class Settings { HashMap < String , String > defaults ; HashMap < String , String > table = new HashMap < String , String > ( ) ; ; File file ; public Settings ( File file ) throws IOException { this . file = file ; if ( file . exists ( ) ) { load ( ) ; } defaults = ( HashMap < String , String > ) table . clone ( ) ; } public void load ( ) { load ( file ) ; } public void load ( File additions ) { String [ ] lines = PApplet . loadStrings ( additions ) ; for ( String line : lines ) { if ( ( line . length ( ) == 0 ) || ( line . charAt ( 0 ) == '#' ) ) continue ; int equals = line . indexOf ( '=' ) ; if ( equals != - 1 ) { String key = line . substring ( 0 , equals ) . trim ( ) ; String value = line . substring ( equals + 1 ) . trim ( ) ; table . put ( key , value ) ; } } String platformExt = "." + Base . getPlatformName ( ) ; int platformExtLength = platformExt . length ( ) ; for ( String key : table . keySet ( ) ) { if ( key . endsWith ( platformExt ) ) { String actualKey = key . substring ( 0 , key . length ( ) - platformExtLength ) ; String value = get ( key ) ; table . put ( actualKey , value ) ; } } } public void save ( ) { PrintWriter writer = PApplet . createWriter ( file ) ; for ( String key : table . keySet ( ) ) { writer . println ( key + "=" + table . get ( key ) ) ; } writer . flush ( ) ; writer . close ( ) ; } public String get ( String attribute ) { return table . get ( attribute ) ; } public String getDefault ( String attribute ) { return defaults . get ( attribute ) ; } public void set ( String attribute , String value ) { table . put ( attribute , value ) ; } public boolean getBoolean ( String attribute ) { String value = get ( attribute ) ; if ( value == null ) { System . err . println ( "Boolean not found: " + attribute ) ; return false ; } return Boolean . parseBoolean ( value ) ; } public void setBoolean ( String attribute , boolean value ) { set ( attribute , value ? "true" : "false" ) ; } public int getInteger ( String attribute ) { String value = get ( attribute ) ; if ( value == null ) { System . err . println ( "Integer not found: " + attribute ) ; return 0 ; } return Integer . parseInt ( value ) ; } public void setInteger ( String key , int value ) { set ( key , String . valueOf ( value ) ) ; } public Color getColor ( String attribute ) { Color parsed = null ; String s = get ( attribute ) ; if ( ( s != null ) && ( s . indexOf ( "#" ) == 0 ) ) { try { int v = Integer . parseInt ( s . substring ( 1 ) , 16 ) ; parsed = new Color ( v ) ; } catch ( Exception e ) { } } return parsed ; } public void setColor ( String attr , Color what ) { set ( attr , "#" + PApplet . hex ( what . getRGB ( ) & 0xffffff , 6 ) ) ; } public Font getFont ( String attr ) { try { boolean replace = false ; String value = get ( attr ) ; if ( value == null ) { value = getDefault ( attr ) ; replace = true ; } String [ ] pieces = PApplet . split ( value , ',' ) ; if ( pieces . length != 3 ) { value = getDefault ( attr ) ; pieces = PApplet . split ( value , ',' ) ; replace = true ; } String name = pieces [ 0 ] ; int style = Font . PLAIN ; if ( pieces [ 1 ] . indexOf ( "bold" ) != - 1 ) { style |= Font . BOLD ; } if ( pieces [ 1 ] . indexOf ( "italic" ) != - 1 ) { style |= Font . ITALIC ; } int size = PApplet . parseInt ( pieces [ 2 ] , 12 ) ; if ( replace ) { set ( attr , value ) ; } if ( ! name . startsWith ( "processing." ) ) { return new Font ( name , style , size ) ; } else { if ( pieces [ 0 ] . equals ( "processing.sans" ) ) { return Toolkit . getSansFont ( size , style ) ; } else if ( pieces [ 0 ] . equals ( "processing.mono" ) ) { return Toolkit . getMonoFont ( size , style ) ; } } } catch ( Exception e ) { Base . log ( "Error with font " + get ( attr ) + " for attribute " + attr ) ; } return new Font ( "Dialog" , Font . PLAIN , 12 ) ; } }
package processing . core ; public final class PMatrix3D implements PMatrix { public float m00 , m01 , m02 , m03 ; public float m10 , m11 , m12 , m13 ; public float m20 , m21 , m22 , m23 ; public float m30 , m31 , m32 , m33 ; protected PMatrix3D inverseCopy ; public PMatrix3D ( ) { reset ( ) ; } public PMatrix3D ( float m00 , float m01 , float m02 , float m10 , float m11 , float m12 ) { set ( m00 , m01 , m02 , 0 , m10 , m11 , m12 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } public PMatrix3D ( float m00 , float m01 , float m02 , float m03 , float m10 , float m11 , float m12 , float m13 , float m20 , float m21 , float m22 , float m23 , float m30 , float m31 , float m32 , float m33 ) { set ( m00 , m01 , m02 , m03 , m10 , m11 , m12 , m13 , m20 , m21 , m22 , m23 , m30 , m31 , m32 , m33 ) ; } public PMatrix3D ( PMatrix matrix ) { set ( matrix ) ; } public void reset ( ) { set ( 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } public PMatrix3D get ( ) { PMatrix3D outgoing = new PMatrix3D ( ) ; outgoing . set ( this ) ; return outgoing ; } public float [ ] get ( float [ ] target ) { if ( ( target == null ) || ( target . length != 16 ) ) { target = new float [ 16 ] ; } target [ 0 ] = m00 ; target [ 1 ] = m01 ; target [ 2 ] = m02 ; target [ 3 ] = m03 ; target [ 4 ] = m10 ; target [ 5 ] = m11 ; target [ 6 ] = m12 ; target [ 7 ] = m13 ; target [ 8 ] = m20 ; target [ 9 ] = m21 ; target [ 10 ] = m22 ; target [ 11 ] = m23 ; target [ 12 ] = m30 ; target [ 13 ] = m31 ; target [ 14 ] = m32 ; target [ 15 ] = m33 ; return target ; } public void set ( PMatrix matrix ) { if ( matrix instanceof PMatrix3D ) { PMatrix3D src = ( PMatrix3D ) matrix ; set ( src . m00 , src . m01 , src . m02 , src . m03 , src . m10 , src . m11 , src . m12 , src . m13 , src . m20 , src . m21 , src . m22 , src . m23 , src . m30 , src . m31 , src . m32 , src . m33 ) ; } else { PMatrix2D src = ( PMatrix2D ) matrix ; set ( src . m00 , src . m01 , 0 , src . m02 , src . m10 , src . m11 , 0 , src . m12 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } } public void set ( float [ ] source ) { if ( source . length == 6 ) { set ( source [ 0 ] , source [ 1 ] , source [ 2 ] , source [ 3 ] , source [ 4 ] , source [ 5 ] ) ; } else if ( source . length == 16 ) { m00 = source [ 0 ] ; m01 = source [ 1 ] ; m02 = source [ 2 ] ; m03 = source [ 3 ] ; m10 = source [ 4 ] ; m11 = source [ 5 ] ; m12 = source [ 6 ] ; m13 = source [ 7 ] ; m20 = source [ 8 ] ; m21 = source [ 9 ] ; m22 = source [ 10 ] ; m23 = source [ 11 ] ; m30 = source [ 12 ] ; m31 = source [ 13 ] ; m32 = source [ 14 ] ; m33 = source [ 15 ] ; } } public void set ( float m00 , float m01 , float m02 , float m10 , float m11 , float m12 ) { set ( m00 , m01 , 0 , m02 , m10 , m11 , 0 , m12 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } public void set ( float m00 , float m01 , float m02 , float m03 , float m10 , float m11 , float m12 , float m13 , float m20 , float m21 , float m22 , float m23 , float m30 , float m31 , float m32 , float m33 ) { this . m00 = m00 ; this . m01 = m01 ; this . m02 = m02 ; this . m03 = m03 ; this . m10 = m10 ; this . m11 = m11 ; this . m12 = m12 ; this . m13 = m13 ; this . m20 = m20 ; this . m21 = m21 ; this . m22 = m22 ; this . m23 = m23 ; this . m30 = m30 ; this . m31 = m31 ; this . m32 = m32 ; this . m33 = m33 ; } public void translate ( float tx , float ty ) { translate ( tx , ty , 0 ) ; } public void translate ( float tx , float ty , float tz ) { m03 += tx * m00 + ty * m01 + tz * m02 ; m13 += tx * m10 + ty * m11 + tz * m12 ; m23 += tx * m20 + ty * m21 + tz * m22 ; m33 += tx * m30 + ty * m31 + tz * m32 ; } public void rotate ( float angle ) { rotateZ ( angle ) ; } public void rotateX ( float angle ) { float c = cos ( angle ) ; float s = sin ( angle ) ; apply ( 1 , 0 , 0 , 0 , 0 , c , - s , 0 , 0 , s , c , 0 , 0 , 0 , 0 , 1 ) ; } public void rotateY ( float angle ) { float c = cos ( angle ) ; float s = sin ( angle ) ; apply ( c , 0 , s , 0 , 0 , 1 , 0 , 0 , - s , 0 , c , 0 , 0 , 0 , 0 , 1 ) ; } public void rotateZ ( float angle ) { float c = cos ( angle ) ; float s = sin ( angle ) ; apply ( c , - s , 0 , 0 , s , c , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } public void rotate ( float angle , float v0 , float v1 , float v2 ) { float norm2 = v0 * v0 + v1 * v1 + v2 * v2 ; if ( norm2 < PConstants . EPSILON ) { return ; } if ( Math . abs ( norm2 - 1 ) > PConstants . EPSILON ) { float norm = PApplet . sqrt ( norm2 ) ; v0 /= norm ; v1 /= norm ; v2 /= norm ; } float c = cos ( angle ) ; float s = sin ( angle ) ; float t = 1.0f - c ; apply ( ( t * v0 * v0 ) + c , ( t * v0 * v1 ) - ( s * v2 ) , ( t * v0 * v2 ) + ( s * v1 ) , 0 , ( t * v0 * v1 ) + ( s * v2 ) , ( t * v1 * v1 ) + c , ( t * v1 * v2 ) - ( s * v0 ) , 0 , ( t * v0 * v2 ) - ( s * v1 ) , ( t * v1 * v2 ) + ( s * v0 ) , ( t * v2 * v2 ) + c , 0 , 0 , 0 , 0 , 1 ) ; } public void scale ( float s ) { scale ( s , s , s ) ; } public void scale ( float sx , float sy ) { scale ( sx , sy , 1 ) ; } public void scale ( float x , float y , float z ) { m00 *= x ; m01 *= y ; m02 *= z ; m10 *= x ; m11 *= y ; m12 *= z ; m20 *= x ; m21 *= y ; m22 *= z ; m30 *= x ; m31 *= y ; m32 *= z ; } public void shearX ( float angle ) { float t = ( float ) Math . tan ( angle ) ; apply ( 1 , t , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } public void shearY ( float angle ) { float t = ( float ) Math . tan ( angle ) ; apply ( 1 , 0 , 0 , 0 , t , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } public void apply ( PMatrix source ) { if ( source instanceof PMatrix2D ) { apply ( ( PMatrix2D ) source ) ; } else if ( source instanceof PMatrix3D ) { apply ( ( PMatrix3D ) source ) ; } } public void apply ( PMatrix2D source ) { apply ( source . m00 , source . m01 , 0 , source . m02 , source . m10 , source . m11 , 0 , source . m12 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } public void apply ( PMatrix3D source ) { apply ( source . m00 , source . m01 , source . m02 , source . m03 , source . m10 , source . m11 , source . m12 , source . m13 , source . m20 , source . m21 , source . m22 , source . m23 , source . m30 , source . m31 , source . m32 , source . m33 ) ; } public void apply ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) { apply ( n00 , n01 , 0 , n02 , n10 , n11 , 0 , n12 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } public void apply ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { float r00 = m00 * n00 + m01 * n10 + m02 * n20 + m03 * n30 ; float r01 = m00 * n01 + m01 * n11 + m02 * n21 + m03 * n31 ; float r02 = m00 * n02 + m01 * n12 + m02 * n22 + m03 * n32 ; float r03 = m00 * n03 + m01 * n13 + m02 * n23 + m03 * n33 ; float r10 = m10 * n00 + m11 * n10 + m12 * n20 + m13 * n30 ; float r11 = m10 * n01 + m11 * n11 + m12 * n21 + m13 * n31 ; float r12 = m10 * n02 + m11 * n12 + m12 * n22 + m13 * n32 ; float r13 = m10 * n03 + m11 * n13 + m12 * n23 + m13 * n33 ; float r20 = m20 * n00 + m21 * n10 + m22 * n20 + m23 * n30 ; float r21 = m20 * n01 + m21 * n11 + m22 * n21 + m23 * n31 ; float r22 = m20 * n02 + m21 * n12 + m22 * n22 + m23 * n32 ; float r23 = m20 * n03 + m21 * n13 + m22 * n23 + m23 * n33 ; float r30 = m30 * n00 + m31 * n10 + m32 * n20 + m33 * n30 ; float r31 = m30 * n01 + m31 * n11 + m32 * n21 + m33 * n31 ; float r32 = m30 * n02 + m31 * n12 + m32 * n22 + m33 * n32 ; float r33 = m30 * n03 + m31 * n13 + m32 * n23 + m33 * n33 ; m00 = r00 ; m01 = r01 ; m02 = r02 ; m03 = r03 ; m10 = r10 ; m11 = r11 ; m12 = r12 ; m13 = r13 ; m20 = r20 ; m21 = r21 ; m22 = r22 ; m23 = r23 ; m30 = r30 ; m31 = r31 ; m32 = r32 ; m33 = r33 ; } public void preApply ( PMatrix2D left ) { preApply ( left . m00 , left . m01 , 0 , left . m02 , left . m10 , left . m11 , 0 , left . m12 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } public void preApply ( PMatrix source ) { if ( source instanceof PMatrix2D ) { preApply ( ( PMatrix2D ) source ) ; } else if ( source instanceof PMatrix3D ) { preApply ( ( PMatrix3D ) source ) ; } } public void preApply ( PMatrix3D left ) { preApply ( left . m00 , left . m01 , left . m02 , left . m03 , left . m10 , left . m11 , left . m12 , left . m13 , left . m20 , left . m21 , left . m22 , left . m23 , left . m30 , left . m31 , left . m32 , left . m33 ) ; } public void preApply ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) { preApply ( n00 , n01 , 0 , n02 , n10 , n11 , 0 , n12 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } public void preApply ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { float r00 = n00 * m00 + n01 * m10 + n02 * m20 + n03 * m30 ; float r01 = n00 * m01 + n01 * m11 + n02 * m21 + n03 * m31 ; float r02 = n00 * m02 + n01 * m12 + n02 * m22 + n03 * m32 ; float r03 = n00 * m03 + n01 * m13 + n02 * m23 + n03 * m33 ; float r10 = n10 * m00 + n11 * m10 + n12 * m20 + n13 * m30 ; float r11 = n10 * m01 + n11 * m11 + n12 * m21 + n13 * m31 ; float r12 = n10 * m02 + n11 * m12 + n12 * m22 + n13 * m32 ; float r13 = n10 * m03 + n11 * m13 + n12 * m23 + n13 * m33 ; float r20 = n20 * m00 + n21 * m10 + n22 * m20 + n23 * m30 ; float r21 = n20 * m01 + n21 * m11 + n22 * m21 + n23 * m31 ; float r22 = n20 * m02 + n21 * m12 + n22 * m22 + n23 * m32 ; float r23 = n20 * m03 + n21 * m13 + n22 * m23 + n23 * m33 ; float r30 = n30 * m00 + n31 * m10 + n32 * m20 + n33 * m30 ; float r31 = n30 * m01 + n31 * m11 + n32 * m21 + n33 * m31 ; float r32 = n30 * m02 + n31 * m12 + n32 * m22 + n33 * m32 ; float r33 = n30 * m03 + n31 * m13 + n32 * m23 + n33 * m33 ; m00 = r00 ; m01 = r01 ; m02 = r02 ; m03 = r03 ; m10 = r10 ; m11 = r11 ; m12 = r12 ; m13 = r13 ; m20 = r20 ; m21 = r21 ; m22 = r22 ; m23 = r23 ; m30 = r30 ; m31 = r31 ; m32 = r32 ; m33 = r33 ; } public PVector mult ( PVector source , PVector target ) { if ( target == null ) { target = new PVector ( ) ; } target . set ( m00 * source . x + m01 * source . y + m02 * source . z + m03 , m10 * source . x + m11 * source . y + m12 * source . z + m13 , m20 * source . x + m21 * source . y + m22 * source . z + m23 ) ; return target ; } public float [ ] mult ( float [ ] source , float [ ] target ) { if ( target == null || target . length < 3 ) { target = new float [ 3 ] ; } if ( source == target ) { throw new RuntimeException ( "The source and target vectors used in " + "PMatrix3D.mult() cannot be identical." ) ; } if ( target . length == 3 ) { target [ 0 ] = m00 * source [ 0 ] + m01 * source [ 1 ] + m02 * source [ 2 ] + m03 ; target [ 1 ] = m10 * source [ 0 ] + m11 * source [ 1 ] + m12 * source [ 2 ] + m13 ; target [ 2 ] = m20 * source [ 0 ] + m21 * source [ 1 ] + m22 * source [ 2 ] + m23 ; } else if ( target . length > 3 ) { target [ 0 ] = m00 * source [ 0 ] + m01 * source [ 1 ] + m02 * source [ 2 ] + m03 * source [ 3 ] ; target [ 1 ] = m10 * source [ 0 ] + m11 * source [ 1 ] + m12 * source [ 2 ] + m13 * source [ 3 ] ; target [ 2 ] = m20 * source [ 0 ] + m21 * source [ 1 ] + m22 * source [ 2 ] + m23 * source [ 3 ] ; target [ 3 ] = m30 * source [ 0 ] + m31 * source [ 1 ] + m32 * source [ 2 ] + m33 * source [ 3 ] ; } return target ; } public float multX ( float x , float y ) { return m00 * x + m01 * y + m03 ; } public float multY ( float x , float y ) { return m10 * x + m11 * y + m13 ; } public float multX ( float x , float y , float z ) { return m00 * x + m01 * y + m02 * z + m03 ; } public float multY ( float x , float y , float z ) { return m10 * x + m11 * y + m12 * z + m13 ; } public float multZ ( float x , float y , float z ) { return m20 * x + m21 * y + m22 * z + m23 ; } public float multW ( float x , float y , float z ) { return m30 * x + m31 * y + m32 * z + m33 ; } public float multX ( float x , float y , float z , float w ) { return m00 * x + m01 * y + m02 * z + m03 * w ; } public float multY ( float x , float y , float z , float w ) { return m10 * x + m11 * y + m12 * z + m13 * w ; } public float multZ ( float x , float y , float z , float w ) { return m20 * x + m21 * y + m22 * z + m23 * w ; } public float multW ( float x , float y , float z , float w ) { return m30 * x + m31 * y + m32 * z + m33 * w ; } public void transpose ( ) { float temp ; temp = m01 ; m01 = m10 ; m10 = temp ; temp = m02 ; m02 = m20 ; m20 = temp ; temp = m03 ; m03 = m30 ; m30 = temp ; temp = m12 ; m12 = m21 ; m21 = temp ; temp = m13 ; m13 = m31 ; m31 = temp ; temp = m23 ; m23 = m32 ; m32 = temp ; } public boolean invert ( ) { float determinant = determinant ( ) ; if ( determinant == 0 ) { return false ; } float t00 = determinant3x3 ( m11 , m12 , m13 , m21 , m22 , m23 , m31 , m32 , m33 ) ; float t01 = - determinant3x3 ( m10 , m12 , m13 , m20 , m22 , m23 , m30 , m32 , m33 ) ; float t02 = determinant3x3 ( m10 , m11 , m13 , m20 , m21 , m23 , m30 , m31 , m33 ) ; float t03 = - determinant3x3 ( m10 , m11 , m12 , m20 , m21 , m22 , m30 , m31 , m32 ) ; float t10 = - determinant3x3 ( m01 , m02 , m03 , m21 , m22 , m23 , m31 , m32 , m33 ) ; float t11 = determinant3x3 ( m00 , m02 , m03 , m20 , m22 , m23 , m30 , m32 , m33 ) ; float t12 = - determinant3x3 ( m00 , m01 , m03 , m20 , m21 , m23 , m30 , m31 , m33 ) ; float t13 = determinant3x3 ( m00 , m01 , m02 , m20 , m21 , m22 , m30 , m31 , m32 ) ; float t20 = determinant3x3 ( m01 , m02 , m03 , m11 , m12 , m13 , m31 , m32 , m33 ) ; float t21 = - determinant3x3 ( m00 , m02 , m03 , m10 , m12 , m13 , m30 , m32 , m33 ) ; float t22 = determinant3x3 ( m00 , m01 , m03 , m10 , m11 , m13 , m30 , m31 , m33 ) ; float t23 = - determinant3x3 ( m00 , m01 , m02 , m10 , m11 , m12 , m30 , m31 , m32 ) ; float t30 = - determinant3x3 ( m01 , m02 , m03 , m11 , m12 , m13 , m21 , m22 , m23 ) ; float t31 = determinant3x3 ( m00 , m02 , m03 , m10 , m12 , m13 , m20 , m22 , m23 ) ; float t32 = - determinant3x3 ( m00 , m01 , m03 , m10 , m11 , m13 , m20 , m21 , m23 ) ; float t33 = determinant3x3 ( m00 , m01 , m02 , m10 , m11 , m12 , m20 , m21 , m22 ) ; m00 = t00 / determinant ; m01 = t10 / determinant ; m02 = t20 / determinant ; m03 = t30 / determinant ; m10 = t01 / determinant ; m11 = t11 / determinant ; m12 = t21 / determinant ; m13 = t31 / determinant ; m20 = t02 / determinant ; m21 = t12 / determinant ; m22 = t22 / determinant ; m23 = t32 / determinant ; m30 = t03 / determinant ; m31 = t13 / determinant ; m32 = t23 / determinant ; m33 = t33 / determinant ; return true ; } private float determinant3x3 ( float t00 , float t01 , float t02 , float t10 , float t11 , float t12 , float t20 , float t21 , float t22 ) { return ( t00 * ( t11 * t22 - t12 * t21 ) + t01 * ( t12 * t20 - t10 * t22 ) + t02 * ( t10 * t21 - t11 * t20 ) ) ; } public float determinant ( ) { float f = m00 * ( ( m11 * m22 * m33 + m12 * m23 * m31 + m13 * m21 * m32 ) - m13 * m22 * m31 - m11 * m23 * m32 - m12 * m21 * m33 ) ; f -= m01 * ( ( m10 * m22 * m33 + m12 * m23 * m30 + m13 * m20 * m32 ) - m13 * m22 * m30 - m10 * m23 * m32 - m12 * m20 * m33 ) ; f += m02 * ( ( m10 * m21 * m33 + m11 * m23 * m30 + m13 * m20 * m31 ) - m13 * m21 * m30 - m10 * m23 * m31 - m11 * m20 * m33 ) ; f -= m03 * ( ( m10 * m21 * m32 + m11 * m22 * m30 + m12 * m20 * m31 ) - m12 * m21 * m30 - m10 * m22 * m31 - m11 * m20 * m32 ) ; return f ; } protected void invTranslate ( float tx , float ty , float tz ) { preApply ( 1 , 0 , 0 , - tx , 0 , 1 , 0 , - ty , 0 , 0 , 1 , - tz , 0 , 0 , 0 , 1 ) ; } protected void invRotateX ( float angle ) { float c = cos ( - angle ) ; float s = sin ( - angle ) ; preApply ( 1 , 0 , 0 , 0 , 0 , c , - s , 0 , 0 , s , c , 0 , 0 , 0 , 0 , 1 ) ; } protected void invRotateY ( float angle ) { float c = cos ( - angle ) ; float s = sin ( - angle ) ; preApply ( c , 0 , s , 0 , 0 , 1 , 0 , 0 , - s , 0 , c , 0 , 0 , 0 , 0 , 1 ) ; } protected void invRotateZ ( float angle ) { float c = cos ( - angle ) ; float s = sin ( - angle ) ; preApply ( c , - s , 0 , 0 , s , c , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ; } protected void invRotate ( float angle , float v0 , float v1 , float v2 ) { float c = cos ( - angle ) ; float s = sin ( - angle ) ; float t = 1.0f - c ; preApply ( ( t * v0 * v0 ) + c , ( t * v0 * v1 ) - ( s * v2 ) , ( t * v0 * v2 ) + ( s * v1 ) , 0 , ( t * v0 * v1 ) + ( s * v2 ) , ( t * v1 * v1 ) + c , ( t * v1 * v2 ) - ( s * v0 ) , 0 , ( t * v0 * v2 ) - ( s * v1 ) , ( t * v1 * v2 ) + ( s * v0 ) , ( t * v2 * v2 ) + c , 0 , 0 , 0 , 0 , 1 ) ; } protected void invScale ( float x , float y , float z ) { preApply ( 1 / x , 0 , 0 , 0 , 0 , 1 / y , 0 , 0 , 0 , 0 , 1 / z , 0 , 0 , 0 , 0 , 1 ) ; } protected boolean invApply ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { if ( inverseCopy == null ) { inverseCopy = new PMatrix3D ( ) ; } inverseCopy . set ( n00 , n01 , n02 , n03 , n10 , n11 , n12 , n13 , n20 , n21 , n22 , n23 , n30 , n31 , n32 , n33 ) ; if ( ! inverseCopy . invert ( ) ) { return false ; } preApply ( inverseCopy ) ; return true ; } public void print ( ) { int big = ( int ) Math . abs ( max ( max ( max ( max ( abs ( m00 ) , abs ( m01 ) ) , max ( abs ( m02 ) , abs ( m03 ) ) ) , max ( max ( abs ( m10 ) , abs ( m11 ) ) , max ( abs ( m12 ) , abs ( m13 ) ) ) ) , max ( max ( max ( abs ( m20 ) , abs ( m21 ) ) , max ( abs ( m22 ) , abs ( m23 ) ) ) , max ( max ( abs ( m30 ) , abs ( m31 ) ) , max ( abs ( m32 ) , abs ( m33 ) ) ) ) ) ) ; int digits = 1 ; if ( Float . isNaN ( big ) || Float . isInfinite ( big ) ) { digits = 5 ; } else { while ( ( big /= 10 ) != 0 ) digits ++ ; } System . out . println ( PApplet . nfs ( m00 , digits , 4 ) + " " + PApplet . nfs ( m01 , digits , 4 ) + " " + PApplet . nfs ( m02 , digits , 4 ) + " " + PApplet . nfs ( m03 , digits , 4 ) ) ; System . out . println ( PApplet . nfs ( m10 , digits , 4 ) + " " + PApplet . nfs ( m11 , digits , 4 ) + " " + PApplet . nfs ( m12 , digits , 4 ) + " " + PApplet . nfs ( m13 , digits , 4 ) ) ; System . out . println ( PApplet . nfs ( m20 , digits , 4 ) + " " + PApplet . nfs ( m21 , digits , 4 ) + " " + PApplet . nfs ( m22 , digits , 4 ) + " " + PApplet . nfs ( m23 , digits , 4 ) ) ; System . out . println ( PApplet . nfs ( m30 , digits , 4 ) + " " + PApplet . nfs ( m31 , digits , 4 ) + " " + PApplet . nfs ( m32 , digits , 4 ) + " " + PApplet . nfs ( m33 , digits , 4 ) ) ; System . out . println ( ) ; } static private final float max ( float a , float b ) { return ( a > b ) ? a : b ; } static private final float abs ( float a ) { return ( a < 0 ) ? - a : a ; } static private final float sin ( float angle ) { return ( float ) Math . sin ( angle ) ; } static private final float cos ( float angle ) { return ( float ) Math . cos ( angle ) ; } }
package processing . app ; import java . awt . event . * ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import javax . swing . * ; import processing . core . PApplet ; public class Recent { static final String FILENAME = "recent.txt" ; static final String VERSION = "2" ; Base base ; File file ; int remember ; ArrayList < Record > records ; JMenu mainMenu ; JMenu toolbarMenu ; public Recent ( Base base ) { this . base = base ; remember = Preferences . getInteger ( "recent.count" ) ; file = Base . getSettingsFile ( FILENAME ) ; mainMenu = new JMenu ( Language . text ( "menu.file.recent" ) ) ; toolbarMenu = new JMenu ( Language . text ( "menu.file.open" ) ) ; try { load ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } protected void load ( ) throws IOException { records = new ArrayList < Record > ( ) ; if ( file . exists ( ) ) { BufferedReader reader = PApplet . createReader ( file ) ; String version = reader . readLine ( ) ; if ( version != null && version . equals ( VERSION ) ) { String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( new File ( line ) . exists ( ) ) { records . add ( new Record ( line ) ) ; } else { Base . log ( this , "ghost file: " + line ) ; } } } reader . close ( ) ; } updateMenu ( mainMenu ) ; updateMenu ( toolbarMenu ) ; } protected void save ( ) { PrintWriter writer = PApplet . createWriter ( file ) ; writer . println ( VERSION ) ; for ( Record record : records ) { writer . println ( record . path ) ; } writer . flush ( ) ; writer . close ( ) ; updateMenu ( mainMenu ) ; updateMenu ( toolbarMenu ) ; } public JMenu getMenu ( ) { return mainMenu ; } public JMenu getToolbarMenu ( ) { return toolbarMenu ; } private void updateMenu ( JMenu menu ) { menu . removeAll ( ) ; String sketchbookPath = Base . getSketchbookFolder ( ) . getAbsolutePath ( ) ; for ( Record rec : records ) { updateMenuRecord ( menu , rec , sketchbookPath ) ; } } private void updateMenuRecord ( JMenu menu , final Record rec , String sketchbookPath ) { try { String recPath = new File ( rec . getPath ( ) ) . getParent ( ) ; String purtyPath = null ; if ( recPath . startsWith ( sketchbookPath ) ) { purtyPath = "sketchbook \u2192 " + recPath . substring ( sketchbookPath . length ( ) + 1 ) ; } else { List < Mode > modes = base . getModeList ( ) ; for ( Mode mode : modes ) { File examplesFolder = mode . getExamplesFolder ( ) ; String examplesPath = examplesFolder . getAbsolutePath ( ) ; if ( recPath . startsWith ( examplesPath ) ) { String modePrefix = mode . getTitle ( ) + " " ; if ( mode . getTitle ( ) . equals ( "Standard" ) ) { modePrefix = "" ; } purtyPath = modePrefix + "examples \u2192 " + recPath . substring ( examplesPath . length ( ) + 1 ) ; break ; } if ( mode . coreLibraries != null ) { for ( Library lib : mode . coreLibraries ) { examplesFolder = lib . getExamplesFolder ( ) ; examplesPath = examplesFolder . getAbsolutePath ( ) ; if ( recPath . startsWith ( examplesPath ) ) { purtyPath = lib . getName ( ) + " examples \u2192 " + recPath . substring ( examplesPath . length ( ) + 1 ) ; break ; } } } if ( mode . contribLibraries != null ) { for ( Library lib : mode . contribLibraries ) { examplesFolder = lib . getExamplesFolder ( ) ; examplesPath = examplesFolder . getAbsolutePath ( ) ; if ( recPath . startsWith ( examplesPath ) ) { purtyPath = lib . getName ( ) + " examples \u2192 " + recPath . substring ( examplesPath . length ( ) + 1 ) ; break ; } } } } } if ( purtyPath == null ) { String homePath = System . getProperty ( "user.home" ) ; if ( recPath . startsWith ( homePath ) ) { purtyPath = "\u2302 \u2192 " + recPath . substring ( homePath . length ( ) + 1 ) ; } else { purtyPath = recPath ; } } JMenuItem item = new JMenuItem ( purtyPath ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . handleOpen ( rec . path ) ; } } ) ; menu . insert ( item , 0 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } synchronized void remove ( Editor editor ) { int index = findRecord ( editor . getSketch ( ) . getMainFilePath ( ) ) ; if ( index != - 1 ) { records . remove ( index ) ; } } synchronized void handle ( Editor editor ) { if ( ! editor . getSketch ( ) . isUntitled ( ) ) { remove ( editor ) ; if ( records . size ( ) == remember ) { records . remove ( 0 ) ; } records . add ( new Record ( editor ) ) ; save ( ) ; } } synchronized void handleRename ( Editor editor , String oldPath ) { if ( records . size ( ) == remember ) { records . remove ( 0 ) ; } int index = findRecord ( oldPath ) ; if ( index != - 1 ) { records . remove ( index ) ; } records . add ( new Record ( editor ) ) ; save ( ) ; } int findRecord ( String path ) { for ( int i = 0 ; i < records . size ( ) ; i ++ ) { if ( path . equals ( records . get ( i ) . path ) ) { return i ; } } return - 1 ; } static class Record { String path ; Editor editor ; Record ( String path ) { this . path = path ; } Record ( Editor editor ) { this . editor = editor ; this . path = editor . getSketch ( ) . getMainFilePath ( ) ; } String getName ( ) { if ( editor != null ) { return editor . getSketch ( ) . getName ( ) ; } String name = path . substring ( path . lastIndexOf ( File . separatorChar ) + 1 ) ; return name . substring ( 0 , name . indexOf ( '.' ) ) ; } String getPath ( ) { return path ; } } }
package processing . app ; import java . awt . Color ; import java . awt . Dimension ; import java . awt . Font ; import java . awt . Frame ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . Image ; import java . awt . RenderingHints ; import java . awt . Window ; import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; public class About extends Window { Image image ; int width , height ; public About ( Frame frame ) { super ( frame ) ; if ( Toolkit . highResDisplay ( ) ) { image = Toolkit . getLibImage ( "about-2x.jpg" ) ; width = image . getWidth ( null ) / 2 ; height = image . getHeight ( null ) / 2 ; } else { image = Toolkit . getLibImage ( "about.jpg" ) ; width = image . getWidth ( null ) ; height = image . getHeight ( null ) ; } addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent e ) { dispose ( ) ; } } ) ; Dimension screen = Toolkit . getScreenSize ( ) ; setBounds ( ( screen . width - width ) / 2 , ( screen . height - height ) / 2 , width , height ) ; setVisible ( true ) ; } public void paint ( Graphics g ) { g . drawImage ( image , 0 , 0 , width , height , null ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_OFF ) ; g . setFont ( new Font ( "SansSerif" , Font . PLAIN , 10 ) ) ; g . setColor ( Color . white ) ; g . drawString ( Base . getVersionName ( ) , 90 , 29 ) ; } }
package processing . app ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . PrintWriter ; import java . net . InetAddress ; import java . net . ServerSocket ; import java . net . Socket ; import javax . swing . SwingUtilities ; import processing . core . PApplet ; public class SingleInstance { static final String SERVER_PORT = "instance_server.port" ; static final String SERVER_KEY = "instance_server.key" ; static boolean alreadyRunning ( String [ ] args ) { return Preferences . get ( SERVER_PORT ) != null && sendArguments ( args ) ; } static void startServer ( final Base base ) { try { final ServerSocket ss = new ServerSocket ( 0 , 0 , InetAddress . getByName ( null ) ) ; Preferences . set ( SERVER_PORT , "" + ss . getLocalPort ( ) ) ; final String key = "" + Math . random ( ) ; Preferences . set ( SERVER_KEY , key ) ; Preferences . save ( ) ; new Thread ( new Runnable ( ) { public void run ( ) { while ( true ) { try { Socket s = ss . accept ( ) ; final BufferedReader reader = PApplet . createReader ( s . getInputStream ( ) ) ; String receivedKey = reader . readLine ( ) ; Base . log ( this , "key is " + key + ", received is " + receivedKey ) ; if ( key . equals ( receivedKey ) ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { try { Base . log ( this , "about to read line" ) ; String path = reader . readLine ( ) ; if ( path == null ) { Base . log ( this , "opening new empty sketch" ) ; base . handleNew ( ) ; } else { do { Base . log ( this , "calling open with " + path ) ; base . handleOpen ( path ) ; path = reader . readLine ( ) ; } while ( path != null ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } } ) ; } else { Base . log ( this , "keys do not match" ) ; } } catch ( IOException e ) { Base . loge ( "SingleInstance error while listening" , e ) ; } } } } , "SingleInstance Server" ) . start ( ) ; } catch ( IOException e ) { Base . loge ( "Could not create single instance server." , e ) ; } } static boolean sendArguments ( String [ ] args ) { try { int port = Preferences . getInteger ( SERVER_PORT ) ; String key = Preferences . get ( SERVER_KEY ) ; Socket socket = null ; try { socket = new Socket ( InetAddress . getByName ( null ) , port ) ; } catch ( Exception ignored ) { } if ( socket != null ) { PrintWriter writer = PApplet . createWriter ( socket . getOutputStream ( ) ) ; writer . println ( key ) ; for ( String arg : args ) { writer . println ( arg ) ; } writer . flush ( ) ; writer . close ( ) ; return true ; } } catch ( IOException e ) { System . err . println ( "Error sending commands to other instance." ) ; e . printStackTrace ( ) ; } return false ; } }
package processing . app ; import java . awt . Component ; import java . awt . Dimension ; import java . awt . Font ; import java . awt . FontFormatException ; import java . awt . FontMetrics ; import java . awt . Frame ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . GraphicsDevice ; import java . awt . GraphicsEnvironment ; import java . awt . Image ; import java . awt . RenderingHints ; import java . awt . Shape ; import java . awt . Window ; import java . awt . datatransfer . Clipboard ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . event . KeyEvent ; import java . awt . font . FontRenderContext ; import java . awt . font . TextLayout ; import java . awt . geom . AffineTransform ; import java . awt . geom . GeneralPath ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Comparator ; import java . util . HashSet ; import java . util . List ; import java . util . regex . Pattern ; import javax . swing . ImageIcon ; import javax . swing . JCheckBoxMenuItem ; import javax . swing . JComponent ; import javax . swing . JMenu ; import javax . swing . JMenuBar ; import javax . swing . JMenuItem ; import javax . swing . JPopupMenu ; import javax . swing . JRootPane ; import javax . swing . KeyStroke ; public class Toolkit { static final java . awt . Toolkit awtToolkit = java . awt . Toolkit . getDefaultToolkit ( ) ; static final int SHORTCUT_KEY_MASK = awtToolkit . getMenuShortcutKeyMask ( ) ; public static final KeyStroke WINDOW_CLOSE_KEYSTROKE = KeyStroke . getKeyStroke ( 'W' , SHORTCUT_KEY_MASK ) ; static final int SHORTCUT_ALT_KEY_MASK = ActionEvent . ALT_MASK | SHORTCUT_KEY_MASK ; static final int SHORTCUT_SHIFT_KEY_MASK = ActionEvent . SHIFT_MASK | SHORTCUT_KEY_MASK ; static public JMenuItem newJMenuItem ( String title , int what ) { JMenuItem menuItem = new JMenuItem ( title ) ; int modifiers = awtToolkit . getMenuShortcutKeyMask ( ) ; menuItem . setAccelerator ( KeyStroke . getKeyStroke ( what , modifiers ) ) ; return menuItem ; } static public JMenuItem newJMenuItemShift ( String title , int what ) { JMenuItem menuItem = new JMenuItem ( title ) ; int modifiers = awtToolkit . getMenuShortcutKeyMask ( ) ; modifiers |= ActionEvent . SHIFT_MASK ; menuItem . setAccelerator ( KeyStroke . getKeyStroke ( what , modifiers ) ) ; return menuItem ; } static public JMenuItem newJMenuItemAlt ( String title , int what ) { JMenuItem menuItem = new JMenuItem ( title ) ; menuItem . setAccelerator ( KeyStroke . getKeyStroke ( what , SHORTCUT_ALT_KEY_MASK ) ) ; return menuItem ; } static public JCheckBoxMenuItem newJCheckBoxMenuItem ( String title , int what ) { JCheckBoxMenuItem menuItem = new JCheckBoxMenuItem ( title ) ; int modifiers = awtToolkit . getMenuShortcutKeyMask ( ) ; menuItem . setAccelerator ( KeyStroke . getKeyStroke ( what , modifiers ) ) ; return menuItem ; } static public void addDisabledItem ( JMenu menu , String title ) { JMenuItem item = new JMenuItem ( title ) ; item . setEnabled ( false ) ; menu . add ( item ) ; } static public void setMenuMnemonics ( JMenuItem ... menu ) { if ( Base . isMacOS ( ) ) return ; if ( menu . length == 0 ) return ; final String [ ] kdePreDefStrs = { "&file" , "&new" , "&open" , "open&recent" , "&save" , "save&as" , "saveacop&y" , "saveas&template" , "savea&ll" , "reloa&d" , "&print" , "printpre&view" , "&import" , "e&xport" , "&closefile" , "clos&eallfiles" , "&quit" , "&edit" , "&undo" , "re&do" , "cu&t" , "&copy" , "&paste" , "&delete" , "select&all" , "dese&lect" , "&find" , "find&next" , "findpre&vious" , "&replace" , "&gotoline" , "&view" , "&newview" , "close&allviews" , "&splitview" , "&removeview" , "splitter&orientation" , "&horizontal" , "&vertical" , "view&mode" , "&fullscreenmode" , "&zoom" , "zoom&in" , "zoom&out" , "zoomtopage&width" , "zoomwhole&page" , "zoom&factor" , "&insert" , "&format" , "&go" , "&up" , "&back" , "&forward" , "&home" , "&go" , "&previouspage" , "&nextpage" , "&firstpage" , "&lastpage" , "read&updocument" , "read&downdocument" , "&back" , "&forward" , "&gotopage" , "&bookmarks" , "&addbookmark" , "bookmark&tabsasfolder" , "&editbookmarks" , "&newbookmarksfolder" , "&tools" , "&settings" , "&toolbars" , "configure&shortcuts" , "configuretool&bars" , "&configure.*" , "&help" , ".+&handbook" , "&whatsthis" , "report&bug" , "&aboutprocessing" , "about&kde" , "&beenden" , "&suchen" , "&preferncias" , "&sair" , "&rechercher" } ; Pattern [ ] kdePreDefPats = new Pattern [ kdePreDefStrs . length ] ; for ( int i = 0 ; i < kdePreDefStrs . length ; i ++ ) { kdePreDefPats [ i ] = Pattern . compile ( kdePreDefStrs [ i ] . replace ( "&" , "" ) ) ; } final Pattern nonAAlpha = Pattern . compile ( "[^A-Za-z]" ) ; FontMetrics fmTmp = null ; for ( JMenuItem m : menu ) { if ( m != null ) { fmTmp = m . getFontMetrics ( m . getFont ( ) ) ; break ; } } if ( fmTmp == null ) return ; final FontMetrics fm = fmTmp ; final Comparator < Character > charComparator = new Comparator < Character > ( ) { char [ ] baddies = "qypgjaeiouQAEIOU" . toCharArray ( ) ; public int compare ( Character ch1 , Character ch2 ) { float w1 = fm . charWidth ( ch1 ) , w2 = fm . charWidth ( ch2 ) ; for ( char bad : baddies ) { if ( bad == ch1 ) w1 *= 0.66f ; if ( bad == ch2 ) w2 *= 0.66f ; } return ( int ) Math . signum ( w2 - w1 ) ; } } ; final List < Character > taken = new ArrayList < Character > ( menu . length ) ; char firstChar ; char [ ] cleanChars ; Character [ ] cleanCharas ; for ( JMenuItem jmi : menu ) { if ( jmi == null ) continue ; if ( jmi . getText ( ) == null ) continue ; jmi . setMnemonic ( 0 ) ; String asciiName = nonAAlpha . matcher ( jmi . getText ( ) ) . replaceAll ( "" ) ; String lAsciiName = asciiName . toLowerCase ( ) ; for ( int i = 0 ; i < kdePreDefStrs . length ; i ++ ) { if ( kdePreDefPats [ i ] . matcher ( lAsciiName ) . matches ( ) ) { char mnem = asciiName . charAt ( kdePreDefStrs [ i ] . indexOf ( "&" ) ) ; jmi . setMnemonic ( mnem ) ; jmi . setDisplayedMnemonicIndex ( jmi . getText ( ) . indexOf ( mnem ) ) ; taken . add ( ( char ) ( mnem | 32 ) ) ; break ; } } } algorithmicAssignment : for ( JMenuItem jmi : menu ) { if ( jmi == null ) continue ; if ( jmi . getText ( ) == null ) continue ; if ( jmi . getMnemonic ( ) != 0 ) continue ; String cleanString = jmi . getText ( ) ; if ( cleanString . startsWith ( "sketchbook \u2192 " ) ) cleanString = cleanString . substring ( 13 ) ; if ( cleanString . length ( ) == 0 ) continue ; final List < Character > banned = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < cleanString . length ( ) ; i ++ ) { if ( cleanString . charAt ( i ) == '_' ) { if ( i > 0 ) banned . add ( Character . toLowerCase ( cleanString . charAt ( i - 1 ) ) ) ; if ( i + 1 < cleanString . length ( ) ) banned . add ( Character . toLowerCase ( cleanString . charAt ( i + 1 ) ) ) ; } } for ( String wd : cleanString . split ( "[^\\p{IsAlphabetic}]" ) ) { if ( wd . length ( ) == 0 ) continue ; firstChar = wd . charAt ( 0 ) ; if ( taken . contains ( Character . toLowerCase ( firstChar ) ) ) continue ; if ( banned . contains ( Character . toLowerCase ( firstChar ) ) ) continue ; if ( 'A' <= firstChar && firstChar <= 'Z' ) { jmi . setMnemonic ( firstChar ) ; jmi . setDisplayedMnemonicIndex ( jmi . getText ( ) . indexOf ( firstChar ) ) ; taken . add ( ( char ) ( firstChar | 32 ) ) ; continue algorithmicAssignment ; } } for ( String wd : cleanString . split ( "[^\\p{IsAlphabetic}]" ) ) { if ( wd . length ( ) == 0 ) continue ; firstChar = wd . charAt ( 0 ) ; if ( taken . contains ( Character . toLowerCase ( firstChar ) ) ) continue ; if ( banned . contains ( Character . toLowerCase ( firstChar ) ) ) continue ; if ( 'a' <= firstChar && firstChar <= 'z' ) { jmi . setMnemonic ( firstChar ) ; jmi . setDisplayedMnemonicIndex ( jmi . getText ( ) . indexOf ( firstChar ) ) ; taken . add ( firstChar ) ; continue algorithmicAssignment ; } } cleanString = nonAAlpha . matcher ( jmi . getText ( ) ) . replaceAll ( "" ) ; if ( cleanString . length ( ) >= 2 ) { char ascii2nd = cleanString . charAt ( 1 ) ; if ( ! taken . contains ( ( char ) ( ascii2nd | 32 ) ) && ! banned . contains ( ( char ) ( ascii2nd | 32 ) ) && fm . charWidth ( 'A' ) <= 2 * fm . charWidth ( ascii2nd ) ) { jmi . setMnemonic ( ascii2nd ) ; jmi . setDisplayedMnemonicIndex ( jmi . getText ( ) . indexOf ( ascii2nd ) ) ; taken . add ( ( char ) ( ascii2nd | 32 ) ) ; continue algorithmicAssignment ; } } cleanChars = cleanString . toCharArray ( ) ; cleanCharas = new Character [ cleanChars . length ] ; for ( int i = 0 ; i < cleanChars . length ; i ++ ) { cleanCharas [ i ] = new Character ( cleanChars [ i ] ) ; } Arrays . sort ( cleanCharas , charComparator ) ; for ( char mnem : cleanCharas ) { if ( taken . contains ( Character . toLowerCase ( mnem ) ) ) continue ; if ( banned . contains ( Character . toLowerCase ( mnem ) ) ) continue ; jmi . setMnemonic ( mnem ) ; jmi . setDisplayedMnemonicIndex ( jmi . getText ( ) . indexOf ( mnem ) ) ; taken . add ( Character . toLowerCase ( mnem ) ) ; continue algorithmicAssignment ; } for ( char digit : jmi . getText ( ) . replaceAll ( "[^0-9]" , "" ) . toCharArray ( ) ) { if ( taken . contains ( digit ) ) continue ; if ( banned . contains ( digit ) ) continue ; jmi . setMnemonic ( KeyEvent . VK_0 + digit - '0' ) ; taken . add ( digit ) ; continue algorithmicAssignment ; } } for ( JMenuItem jmi : menu ) { if ( jmi instanceof JMenu ) setMenuMnemsInside ( ( JMenu ) jmi ) ; } } static public void setMenuMnemonics ( JMenuBar menubar ) { JMenuItem [ ] items = new JMenuItem [ menubar . getMenuCount ( ) ] ; for ( int i = 0 ; i < items . length ; i ++ ) { items [ i ] = menubar . getMenu ( i ) ; } setMenuMnemonics ( items ) ; } static public void setMenuMnemonics ( JPopupMenu menu ) { ArrayList < JMenuItem > items = new ArrayList < JMenuItem > ( ) ; for ( Component c : menu . getComponents ( ) ) { if ( c instanceof JMenuItem ) items . add ( ( JMenuItem ) c ) ; } setMenuMnemonics ( items . toArray ( new JMenuItem [ items . size ( ) ] ) ) ; } static public void setMenuMnemsInside ( JMenu menu ) { JMenuItem [ ] items = new JMenuItem [ menu . getItemCount ( ) ] ; for ( int i = 0 ; i < items . length ; i ++ ) { items [ i ] = menu . getItem ( i ) ; } setMenuMnemonics ( items ) ; } static public Dimension getScreenSize ( ) { return awtToolkit . getScreenSize ( ) ; } static public Image getLibImage ( String filename ) { ImageIcon icon = getLibIcon ( filename ) ; return ( icon == null ) ? null : icon . getImage ( ) ; } static public ImageIcon getLibIcon ( String filename ) { File file = Base . getContentFile ( "lib/" + filename ) ; if ( ! file . exists ( ) ) { return null ; } return new ImageIcon ( file . getAbsolutePath ( ) ) ; } static List < Image > iconImages ; static public void setIcon ( Frame frame ) { setIcon ( ( Window ) frame ) ; } static public void setIcon ( Window window ) { if ( ! Base . isMacOS ( ) ) { if ( iconImages == null ) { iconImages = new ArrayList < Image > ( ) ; final int [ ] sizes = { 16 , 32 , 48 , 64 , 128 , 256 , 512 } ; for ( int sz : sizes ) { iconImages . add ( Toolkit . getLibImage ( "icons/pde-" + sz + ".png" ) ) ; } } window . setIconImages ( iconImages ) ; } } static public Shape createRoundRect ( float x1 , float y1 , float x2 , float y2 , float tl , float tr , float br , float bl ) { GeneralPath path = new GeneralPath ( ) ; if ( tr != 0 ) { path . moveTo ( x2 - tr , y1 ) ; path . quadTo ( x2 , y1 , x2 , y1 + tr ) ; } else { path . moveTo ( x2 , y1 ) ; } if ( br != 0 ) { path . lineTo ( x2 , y2 - br ) ; path . quadTo ( x2 , y2 , x2 - br , y2 ) ; } else { path . lineTo ( x2 , y2 ) ; } if ( bl != 0 ) { path . lineTo ( x1 + bl , y2 ) ; path . quadTo ( x1 , y2 , x1 , y2 - bl ) ; } else { path . lineTo ( x1 , y2 ) ; } if ( tl != 0 ) { path . lineTo ( x1 , y1 + tl ) ; path . quadTo ( x1 , y1 , x1 + tl , y1 ) ; } else { path . lineTo ( x1 , y1 ) ; } path . closePath ( ) ; return path ; } static public void registerWindowCloseKeys ( JRootPane root , ActionListener disposer ) { KeyStroke stroke = KeyStroke . getKeyStroke ( KeyEvent . VK_ESCAPE , 0 ) ; root . registerKeyboardAction ( disposer , stroke , JComponent . WHEN_IN_FOCUSED_WINDOW ) ; int modifiers = awtToolkit . getMenuShortcutKeyMask ( ) ; stroke = KeyStroke . getKeyStroke ( 'W' , modifiers ) ; root . registerKeyboardAction ( disposer , stroke , JComponent . WHEN_IN_FOCUSED_WINDOW ) ; } static public void beep ( ) { awtToolkit . beep ( ) ; } static public Clipboard getSystemClipboard ( ) { return awtToolkit . getSystemClipboard ( ) ; } static public Graphics2D prepareGraphics ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( Toolkit . highResDisplay ( ) ) { g2 . scale ( 2 , 2 ) ; } g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; if ( Toolkit . highResDisplay ( ) ) { g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_GASP ) ; } return g2 ; } static Boolean highResProp ; static public boolean highResDisplay ( ) { if ( highResProp == null ) { highResProp = checkRetina ( ) ; } return highResProp ; } static private boolean checkRetina ( ) { if ( Base . isMacOS ( ) ) { GraphicsEnvironment env = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice device = env . getDefaultScreenDevice ( ) ; try { Field field = device . getClass ( ) . getDeclaredField ( "scale" ) ; if ( field != null ) { field . setAccessible ( true ) ; Object scale = field . get ( device ) ; if ( scale instanceof Integer && ( ( Integer ) scale ) . intValue ( ) == 2 ) { return true ; } } } catch ( Exception ignore ) { } } return false ; } static final char GREEK_SMALL_LETTER_ALPHA = '\u03B1' ; static final char GREEK_CAPITAL_LETTER_OMEGA = '\u03A9' ; static private List < Font > getMonoFontList ( ) { GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; Font [ ] fonts = ge . getAllFonts ( ) ; ArrayList < Font > outgoing = new ArrayList < Font > ( ) ; FontRenderContext frc = new FontRenderContext ( new AffineTransform ( ) , Preferences . getBoolean ( "editor.antialias" ) , true ) ; for ( Font font : fonts ) { if ( font . getStyle ( ) == Font . PLAIN && font . canDisplay ( 'i' ) && font . canDisplay ( 'M' ) && font . canDisplay ( ' ' ) && font . canDisplay ( '.' ) ) { double w = font . getStringBounds ( " " , frc ) . getWidth ( ) ; if ( w == font . getStringBounds ( "i" , frc ) . getWidth ( ) && w == font . getStringBounds ( "M" , frc ) . getWidth ( ) && w == font . getStringBounds ( "." , frc ) . getWidth ( ) ) { outgoing . add ( font ) ; } } } return outgoing ; } static public String [ ] getMonoFontFamilies ( ) { HashSet < String > families = new HashSet < String > ( ) ; for ( Font font : getMonoFontList ( ) ) { families . add ( font . getFamily ( ) ) ; } String [ ] names = families . toArray ( new String [ 0 ] ) ; Arrays . sort ( names ) ; return names ; } static Font monoFont ; static Font monoBoldFont ; static Font sansFont ; static Font sansBoldFont ; static public String getMonoFontName ( ) { if ( monoFont == null ) { getMonoFont ( 12 , Font . PLAIN ) ; } return monoFont . getName ( ) ; } static public Font getMonoFont ( int size , int style ) { if ( monoFont == null ) { try { monoFont = createFont ( "SourceCodePro-Regular.ttf" , size ) ; monoBoldFont = createFont ( "SourceCodePro-Bold.ttf" , size ) ; if ( "el" . equals ( Language . getLanguage ( ) ) ) { if ( ! monoFont . canDisplay ( GREEK_SMALL_LETTER_ALPHA ) || ! monoFont . canDisplay ( GREEK_CAPITAL_LETTER_OMEGA ) ) { monoFont = createFont ( "AnonymousPro-Regular.ttf" , size ) ; monoBoldFont = createFont ( "AnonymousPro-Bold.ttf" , size ) ; } } } catch ( Exception e ) { Base . loge ( "Could not load mono font" , e ) ; monoFont = new Font ( "Monospaced" , Font . PLAIN , size ) ; monoBoldFont = new Font ( "Monospaced" , Font . BOLD , size ) ; } } if ( style == Font . BOLD ) { if ( size == monoBoldFont . getSize ( ) ) { return monoBoldFont ; } else { return monoBoldFont . deriveFont ( ( float ) size ) ; } } else { if ( size == monoFont . getSize ( ) ) { return monoFont ; } else { return monoFont . deriveFont ( ( float ) size ) ; } } } static public Font getSansFont ( int size , int style ) { if ( sansFont == null ) { try { sansFont = createFont ( "SourceSansPro-Regular.ttf" , size ) ; sansBoldFont = createFont ( "SourceSansPro-Semibold.ttf" , size ) ; if ( "el" . equals ( Language . getLanguage ( ) ) ) { if ( ! sansFont . canDisplay ( GREEK_SMALL_LETTER_ALPHA ) || ! sansFont . canDisplay ( GREEK_CAPITAL_LETTER_OMEGA ) ) { sansFont = createFont ( "Carlito-Regular.ttf" , size ) ; sansBoldFont = createFont ( "Carlito-Bold.ttf" , size ) ; } } } catch ( Exception e ) { Base . loge ( "Could not load sans font" , e ) ; sansFont = new Font ( "SansSerif" , Font . PLAIN , size ) ; sansBoldFont = new Font ( "SansSerif" , Font . BOLD , size ) ; } } if ( style == Font . BOLD ) { if ( size == sansBoldFont . getSize ( ) ) { return sansBoldFont ; } else { return sansBoldFont . deriveFont ( ( float ) size ) ; } } else { if ( size == sansFont . getSize ( ) ) { return sansFont ; } else { return sansFont . deriveFont ( ( float ) size ) ; } } } static private Font createFont ( String filename , int size ) throws IOException , FontFormatException { File fontFile = new File ( System . getProperty ( "java.home" ) , "lib/fonts/" + filename ) ; if ( ! fontFile . exists ( ) ) { fontFile = new File ( System . getProperty ( "user.dir" ) , "../build/shared/lib/fonts/" + filename ) ; } if ( ! fontFile . exists ( ) ) { fontFile = new File ( System . getProperty ( "user.dir" ) , "../../shared/lib/fonts/" + filename ) ; } if ( ! fontFile . exists ( ) ) { Base . showError ( "Font Sadness" , "Could not find required fonts" , null ) ; } BufferedInputStream input = new BufferedInputStream ( new FileInputStream ( fontFile ) ) ; Font font = Font . createFont ( Font . TRUETYPE_FONT , input ) ; input . close ( ) ; return font . deriveFont ( ( float ) size ) ; } static double getAscent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; FontRenderContext frc = g2 . getFontRenderContext ( ) ; return new TextLayout ( "H" , g . getFont ( ) , frc ) . getBounds ( ) . getHeight ( ) ; } static public void debugOpacity ( Component comp ) { while ( comp != null ) { System . out . println ( comp . getClass ( ) . getName ( ) + " " + ( comp . isOpaque ( ) ? "OPAQUE" : "" ) ) ; comp = comp . getParent ( ) ; } System . out . println ( ) ; } static public int getMenuItemIndex ( JMenu menu , JMenuItem item ) { int index = 0 ; for ( Component comp : menu . getMenuComponents ( ) ) { if ( comp == item ) { return index ; } index ++ ; } return - 1 ; } }
package processing . app ; public class SketchException extends Exception { protected String message ; protected int codeIndex ; protected int codeLine ; protected int codeColumn ; protected boolean showStackTrace ; public SketchException ( String message ) { this ( message , true ) ; } public SketchException ( String message , boolean showStackTrace ) { this ( message , - 1 , - 1 , - 1 , showStackTrace ) ; } public SketchException ( String message , int file , int line ) { this ( message , file , line , - 1 , true ) ; } public SketchException ( String message , int file , int line , int column ) { this ( message , file , line , column , true ) ; } public SketchException ( String message , int file , int line , int column , boolean showStackTrace ) { this . message = message ; this . codeIndex = file ; this . codeLine = line ; this . codeColumn = column ; this . showStackTrace = showStackTrace ; } public String getMessage ( ) { return message ; } public void setMessage ( String message ) { this . message = message ; } public int getCodeIndex ( ) { return codeIndex ; } public void setCodeIndex ( int index ) { codeIndex = index ; } public boolean hasCodeIndex ( ) { return codeIndex != - 1 ; } public int getCodeLine ( ) { return codeLine ; } public void setCodeLine ( int line ) { this . codeLine = line ; } public boolean hasCodeLine ( ) { return codeLine != - 1 ; } public void setCodeColumn ( int column ) { this . codeColumn = column ; } public int getCodeColumn ( ) { return codeColumn ; } public void showStackTrace ( ) { showStackTrace = true ; } public void hideStackTrace ( ) { showStackTrace = false ; } public void printStackTrace ( ) { if ( showStackTrace ) { super . printStackTrace ( ) ; } } }
package processing . app ; import java . awt . EventQueue ; import java . awt . Frame ; import java . awt . event . WindowEvent ; import java . awt . event . WindowFocusListener ; import java . io . File ; import java . io . FilenameFilter ; import java . lang . reflect . InvocationTargetException ; import javax . swing . JOptionPane ; public class ChangeDetector implements WindowFocusListener { private Sketch sketch ; private Editor editor ; private final int MODIFIED_TIME_BUFFER = 1000 ; private boolean skip = false ; public ChangeDetector ( Editor editor ) { this . sketch = editor . sketch ; this . editor = editor ; } @ Override public void windowGainedFocus ( WindowEvent e ) { if ( Preferences . getBoolean ( "editor.watcher" ) ) { if ( skip ) { skip = false ; } else { new Thread ( new Runnable ( ) { @ Override public void run ( ) { checkFileChange ( ) ; } } ) . start ( ) ; } } } @ Override public void windowLostFocus ( WindowEvent e ) { } private void checkFileChange ( ) { if ( sketch == null ) { return ; } sketch . ensureExistence ( ) ; File sketchFolder = sketch . getFolder ( ) ; File [ ] sketchFiles = sketchFolder . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String name ) { for ( String s : editor . getMode ( ) . getExtensions ( ) ) { if ( name . toLowerCase ( ) . endsWith ( s . toLowerCase ( ) ) ) { return true ; } } return false ; } } ) ; int fileCount = sketchFiles . length ; if ( fileCount != sketch . getCodeCount ( ) ) { if ( reloadSketch ( null ) && fileCount < 1 ) { try { sketch . getMainFile ( ) . createNewFile ( ) ; } catch ( Exception e1 ) { showErrorEDT ( "Reload failed" , "The sketch contains no code files." , e1 ) ; skip = true ; return ; } sketch . reload ( ) ; showWarningEDT ( "Modified Reload" , "You cannot delete the last code file in a sketch.\n" + "A new blank sketch file has been generated for you." ) ; } return ; } SketchCode [ ] codes = sketch . getCode ( ) ; for ( SketchCode sc : codes ) { File sketchFile = sc . getFile ( ) ; if ( sketchFile . exists ( ) ) { long diff = sketchFile . lastModified ( ) - sc . lastModified ( ) ; if ( diff > MODIFIED_TIME_BUFFER ) { reloadSketch ( sc ) ; } } else { reloadSketch ( sc ) ; } } } private void setSketchCodeModified ( SketchCode sc ) { sc . setModified ( true ) ; sketch . setModified ( true ) ; } private boolean reloadSketch ( SketchCode changed ) { int response = blockingYesNoPrompt ( editor , "File Modified" , "Your sketch has been modified externally.<br>" + "Would you like to reload the sketch?" , "If you reload the sketch, any unsaved changes will be lost." ) ; if ( response == JOptionPane . YES_OPTION ) { sketch . reload ( ) ; rebuildHeaderEDT ( ) ; return true ; } if ( changed != null ) { setSketchCodeModified ( changed ) ; } else { for ( SketchCode sc : sketch . getCode ( ) ) { if ( ! sc . getFile ( ) . exists ( ) ) { setSketchCodeModified ( sc ) ; } } } rebuildHeaderEDT ( ) ; skip = true ; return false ; } private void showErrorEDT ( final String title , final String message , final Exception e ) { EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { Base . showError ( title , message , e ) ; } } ) ; } private void showWarningEDT ( final String title , final String message ) { EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { Base . showWarning ( title , message ) ; } } ) ; } private int blockingYesNoPrompt ( final Frame editor , final String title , final String message1 , final String message2 ) { final int [ ] result = { - 1 } ; try { EventQueue . invokeAndWait ( new Runnable ( ) { @ Override public void run ( ) { result [ 0 ] = Base . showYesNoQuestion ( editor , title , message1 , message2 ) ; } } ) ; } catch ( InvocationTargetException e ) { e . getTargetException ( ) . printStackTrace ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } return result [ 0 ] ; } private void rebuildHeaderEDT ( ) { EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { editor . header . rebuild ( ) ; } } ) ; } }
package processing . app ; import java . io . * ; import java . util . * ; import processing . app . contrib . * ; import processing . core . * ; public class Library extends LocalContribution { static final String [ ] platformNames = PConstants . platformNames ; protected File libraryFolder ; protected File examplesFolder ; protected File referenceFile ; protected String group ; String [ ] packageList ; HashMap < String , String [ ] > exportList ; String [ ] appletExportList ; String [ ] androidExportList ; boolean [ ] multipleArch = new boolean [ platformNames . length ] ; String nativeLibraryPath ; static public final String propertiesFileName = "library.properties" ; static FilenameFilter standardFilter = new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { if ( name . charAt ( 0 ) == '.' ) return false ; if ( name . equals ( "CVS" ) ) return false ; if ( name . equals ( "export.txt" ) ) return false ; File file = new File ( dir , name ) ; if ( file . isDirectory ( ) ) { if ( name . equals ( "macosx" ) ) return false ; if ( name . equals ( "macosx32" ) ) return false ; if ( name . equals ( "macosx64" ) ) return false ; if ( name . equals ( "windows" ) ) return false ; if ( name . equals ( "windows32" ) ) return false ; if ( name . equals ( "windows64" ) ) return false ; if ( name . equals ( "linux" ) ) return false ; if ( name . equals ( "linux32" ) ) return false ; if ( name . equals ( "linux64" ) ) return false ; if ( name . equals ( "android" ) ) return false ; } return true ; } } ; static FilenameFilter jarFilter = new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { if ( name . charAt ( 0 ) == '.' ) return false ; if ( new File ( dir , name ) . isDirectory ( ) ) return false ; String lc = name . toLowerCase ( ) ; return lc . endsWith ( ".jar" ) || lc . endsWith ( ".zip" ) ; } } ; static public Library load ( File folder ) { try { return new Library ( folder ) ; } catch ( Error err ) { err . printStackTrace ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return null ; } public Library ( File folder ) { this ( folder , null ) ; } private Library ( File folder , String groupName ) { super ( folder ) ; this . group = groupName ; libraryFolder = new File ( folder , "library" ) ; examplesFolder = new File ( folder , "examples" ) ; referenceFile = new File ( folder , "reference/index.html" ) ; File exportSettings = new File ( libraryFolder , "export.txt" ) ; Map < String , String > exportTable = exportSettings . exists ( ) ? Base . readSettings ( exportSettings ) : new HashMap < String , String > ( ) ; exportList = new HashMap < String , String [ ] > ( ) ; String [ ] baseList = libraryFolder . list ( standardFilter ) ; String appletExportStr = exportTable . get ( "applet" ) ; if ( appletExportStr != null ) { appletExportList = PApplet . splitTokens ( appletExportStr , ", " ) ; } else { appletExportList = baseList ; } String androidExportStr = exportTable . get ( "android" ) ; if ( androidExportStr != null ) { androidExportList = PApplet . splitTokens ( androidExportStr , ", " ) ; } else { androidExportList = baseList ; } File nativeLibraryFolder = libraryFolder ; String hostPlatform = Base . getPlatformName ( ) ; File hostLibrary = new File ( libraryFolder , hostPlatform ) ; if ( hostLibrary . exists ( ) ) { nativeLibraryFolder = hostLibrary ; } hostLibrary = new File ( libraryFolder , hostPlatform + Base . getNativeBits ( ) ) ; if ( hostLibrary . exists ( ) ) { nativeLibraryFolder = hostLibrary ; } nativeLibraryPath = nativeLibraryFolder . getAbsolutePath ( ) ; for ( int i = 1 ; i < platformNames . length ; i ++ ) { String platformName = platformNames [ i ] ; String platformName32 = platformName + "32" ; String platformName64 = platformName + "64" ; String platformAll = exportTable . get ( "application." + platformName ) ; String [ ] platformList = platformAll == null ? null : PApplet . splitTokens ( platformAll , ", " ) ; String platform32 = exportTable . get ( "application." + platformName + "32" ) ; String [ ] platformList32 = platform32 == null ? null : PApplet . splitTokens ( platform32 , ", " ) ; String platform64 = exportTable . get ( "application." + platformName + "64" ) ; String [ ] platformList64 = platform64 == null ? null : PApplet . splitTokens ( platform64 , ", " ) ; if ( platformAll == null ) { platformList = listPlatformEntries ( libraryFolder , platformName , baseList ) ; } if ( platform32 == null ) { platformList32 = listPlatformEntries ( libraryFolder , platformName32 , baseList ) ; } if ( platform64 == null ) { platformList64 = listPlatformEntries ( libraryFolder , platformName64 , baseList ) ; } if ( platformList32 != null || platformList64 != null ) { multipleArch [ i ] = true ; } if ( platformList == null && platformList32 == null && platformList64 == null ) { exportList . put ( platformName , baseList ) ; } else { if ( platformList != null ) { exportList . put ( platformName , platformList ) ; } if ( platformList32 != null ) { exportList . put ( platformName32 , platformList32 ) ; } if ( platformList64 != null ) { exportList . put ( platformName64 , platformList64 ) ; } } } packageList = Base . packageListFromClassPath ( getClassPath ( ) ) ; } static String [ ] listPlatformEntries ( File libraryFolder , String folderName , String [ ] baseList ) { File folder = new File ( libraryFolder , folderName ) ; if ( folder . exists ( ) ) { String [ ] entries = folder . list ( standardFilter ) ; if ( entries != null ) { String [ ] outgoing = new String [ entries . length + baseList . length ] ; for ( int i = 0 ; i < entries . length ; i ++ ) { outgoing [ i ] = folderName + "/" + entries [ i ] ; } System . arraycopy ( baseList , 0 , outgoing , entries . length , baseList . length ) ; return outgoing ; } } return null ; } static protected HashMap < String , Object > packageWarningMap = new HashMap < String , Object > ( ) ; public void addPackageList ( HashMap < String , ArrayList < Library > > importToLibraryTable ) { for ( String pkg : packageList ) { ArrayList < Library > libraries = importToLibraryTable . get ( pkg ) ; if ( libraries == null ) { libraries = new ArrayList < Library > ( ) ; importToLibraryTable . put ( pkg , libraries ) ; } else { if ( Base . DEBUG ) { System . err . println ( "The library found in" ) ; System . err . println ( getPath ( ) ) ; System . err . println ( "conflicts with" ) ; for ( Library library : libraries ) { System . err . println ( library . getPath ( ) ) ; } System . err . println ( "which already define(s) the package " + pkg ) ; System . err . println ( "If you have a line in your sketch that reads" ) ; System . err . println ( "import " + pkg + ".*;" ) ; System . err . println ( "Then you'll need to first remove one of those libraries." ) ; System . err . println ( ) ; } } libraries . add ( this ) ; } } public boolean hasExamples ( ) { return examplesFolder . exists ( ) ; } public File getExamplesFolder ( ) { return examplesFolder ; } public String getGroup ( ) { return group ; } public String getPath ( ) { return folder . getAbsolutePath ( ) ; } public String getLibraryPath ( ) { return libraryFolder . getAbsolutePath ( ) ; } public String getJarPath ( ) { return new File ( libraryFolder , folder . getName ( ) + ".jar" ) . getAbsolutePath ( ) ; } public String getClassPath ( ) { StringBuilder cp = new StringBuilder ( ) ; String [ ] jarHeads = libraryFolder . list ( jarFilter ) ; for ( String jar : jarHeads ) { cp . append ( File . pathSeparatorChar ) ; cp . append ( new File ( libraryFolder , jar ) . getAbsolutePath ( ) ) ; } jarHeads = new File ( nativeLibraryPath ) . list ( jarFilter ) ; for ( String jar : jarHeads ) { cp . append ( File . pathSeparatorChar ) ; cp . append ( new File ( nativeLibraryPath , jar ) . getAbsolutePath ( ) ) ; } return cp . toString ( ) ; } public String getNativePath ( ) { return nativeLibraryPath ; } protected File [ ] wrapFiles ( String [ ] list ) { File [ ] outgoing = new File [ list . length ] ; for ( int i = 0 ; i < list . length ; i ++ ) { outgoing [ i ] = new File ( libraryFolder , list [ i ] ) ; } return outgoing ; } public File [ ] getAppletExports ( ) { return wrapFiles ( appletExportList ) ; } public File [ ] getApplicationExports ( int platform , int bits ) { String [ ] list = getApplicationExportList ( platform , bits ) ; return wrapFiles ( list ) ; } public String [ ] getApplicationExportList ( int platform , int bits ) { String platformName = PConstants . platformNames [ platform ] ; if ( bits == 32 ) { String [ ] pieces = exportList . get ( platformName + "32" ) ; if ( pieces != null ) return pieces ; } else if ( bits == 64 ) { String [ ] pieces = exportList . get ( platformName + "64" ) ; if ( pieces != null ) return pieces ; } return exportList . get ( platformName ) ; } public File [ ] getAndroidExports ( ) { return wrapFiles ( androidExportList ) ; } public boolean hasMultipleArch ( int platform ) { return multipleArch [ platform ] ; } public boolean supportsArch ( int platform , int bits ) { if ( multipleArch [ platform ] == false ) { return true ; } return getApplicationExportList ( platform , bits ) != null ; } static public boolean hasMultipleArch ( int platform , ArrayList < Library > libraries ) { for ( Library library : libraries ) { if ( library . hasMultipleArch ( platform ) ) { return true ; } } return false ; } static protected FilenameFilter junkFolderFilter = new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { if ( name . charAt ( 0 ) == '.' ) return false ; if ( name . equals ( "CVS" ) ) return false ; return ( new File ( dir , name ) . isDirectory ( ) ) ; } } ; static public ArrayList < File > discover ( File folder ) { ArrayList < File > libraries = new ArrayList < File > ( ) ; discover ( folder , libraries ) ; return libraries ; } static public void discover ( File folder , ArrayList < File > libraries ) { String [ ] list = folder . list ( junkFolderFilter ) ; if ( list != null ) { Arrays . sort ( list , String . CASE_INSENSITIVE_ORDER ) ; for ( String potentialName : list ) { File baseFolder = new File ( folder , potentialName ) ; File libraryFolder = new File ( baseFolder , "library" ) ; File libraryJar = new File ( libraryFolder , potentialName + ".jar" ) ; if ( libraryJar . exists ( ) ) { String sanityCheck = Sketch . sanitizeName ( potentialName ) ; if ( sanityCheck . equals ( potentialName ) ) { libraries . add ( baseFolder ) ; } else { String mess = "The library \"" + potentialName + "\" cannot be used.\n" + "Library names must contain only basic letters and numbers.\n" + "(ASCII only and no spaces, and it cannot start with a number)" ; Base . showMessage ( "Ignoring bad library name" , mess ) ; continue ; } } } } } static protected ArrayList < Library > list ( File folder ) { ArrayList < Library > libraries = new ArrayList < Library > ( ) ; list ( folder , libraries ) ; return libraries ; } static protected void list ( File folder , ArrayList < Library > libraries ) { ArrayList < File > librariesFolders = new ArrayList < File > ( ) ; discover ( folder , librariesFolders ) ; for ( File baseFolder : librariesFolders ) { libraries . add ( new Library ( baseFolder ) ) ; } String [ ] list = folder . list ( junkFolderFilter ) ; if ( list != null ) { for ( String subfolderName : list ) { File subfolder = new File ( folder , subfolderName ) ; if ( ! librariesFolders . contains ( subfolder ) ) { ArrayList < File > discoveredLibFolders = new ArrayList < File > ( ) ; discover ( subfolder , discoveredLibFolders ) ; for ( File discoveredFolder : discoveredLibFolders ) { libraries . add ( new Library ( discoveredFolder , subfolderName ) ) ; } } } } } public ContributionType getType ( ) { return ContributionType . LIBRARY ; } public File getReferenceIndexFile ( ) { return referenceFile ; } public boolean hasReference ( ) { return referenceFile . exists ( ) ; } }
package processing . app ; import java . awt . * ; import java . awt . event . * ; import java . io . * ; import javax . swing . * ; import javax . swing . text . * ; import processing . core . PApplet ; import java . text . SimpleDateFormat ; import java . util . * ; public class EditorConsole extends JScrollPane { Editor editor ; JTextPane consoleTextPane ; BufferedStyledDocument consoleDoc ; MutableAttributeSet stdStyle ; MutableAttributeSet errStyle ; int maxLineCount ; PrintStream sketchOut ; PrintStream sketchErr ; static PrintStream systemOut ; static PrintStream systemErr ; static PrintStream consoleOut ; static PrintStream consoleErr ; static OutputStream stdoutFile ; static OutputStream stderrFile ; static EditorConsole currentConsole ; static { systemOut = System . out ; systemErr = System . err ; try { SimpleDateFormat formatter = new SimpleDateFormat ( "yyMMdd" ) ; String randy = PApplet . nf ( ( int ) ( 1000 * Math . random ( ) ) , 4 ) ; String stamp = formatter . format ( new Date ( ) ) + "_" + randy ; File consoleDir = Base . getSettingsFile ( "console" ) ; consoleDir . mkdirs ( ) ; File outFile = new File ( consoleDir , stamp + ".out" ) ; stdoutFile = new FileOutputStream ( outFile ) ; File errFile = new File ( consoleDir , stamp + ".err" ) ; stderrFile = new FileOutputStream ( errFile ) ; consoleOut = new PrintStream ( new EditorConsoleStream ( false , null ) ) ; consoleErr = new PrintStream ( new EditorConsoleStream ( true , null ) ) ; System . setOut ( consoleOut ) ; System . setErr ( consoleErr ) ; } catch ( Exception e ) { stdoutFile = null ; stderrFile = null ; consoleOut = null ; consoleErr = null ; System . setOut ( systemOut ) ; System . setErr ( systemErr ) ; e . printStackTrace ( systemErr ) ; } } public EditorConsole ( Editor editor ) { this . editor = editor ; maxLineCount = Preferences . getInteger ( "console.length" ) ; consoleDoc = new BufferedStyledDocument ( 10000 , maxLineCount ) ; consoleTextPane = new JTextPane ( consoleDoc ) ; consoleTextPane . setEditable ( false ) ; updateMode ( ) ; this . setViewportView ( consoleTextPane ) ; if ( Base . isMacOS ( ) ) { setBorder ( null ) ; } sketchOut = new PrintStream ( new EditorConsoleStream ( false , this ) ) ; sketchErr = new PrintStream ( new EditorConsoleStream ( true , this ) ) ; new javax . swing . Timer ( 250 , new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { if ( consoleDoc . hasAppendage ) { consoleDoc . insertAll ( ) ; consoleTextPane . setCaretPosition ( consoleDoc . getLength ( ) ) ; } } } ) . start ( ) ; setBorder ( null ) ; } public PrintStream getOut ( ) { return sketchOut ; } public PrintStream getErr ( ) { return sketchErr ; } protected void updateAppearance ( ) { String fontFamily = Preferences . get ( "editor.font.family" ) ; int fontSize = Preferences . getInteger ( "console.font.size" ) ; StyleConstants . setFontFamily ( stdStyle , fontFamily ) ; StyleConstants . setFontSize ( stdStyle , fontSize ) ; StyleConstants . setFontFamily ( errStyle , fontFamily ) ; StyleConstants . setFontSize ( errStyle , fontSize ) ; clear ( ) ; } protected void updateMode ( ) { Mode mode = editor . getMode ( ) ; MutableAttributeSet standard = new SimpleAttributeSet ( ) ; StyleConstants . setAlignment ( standard , StyleConstants . ALIGN_LEFT ) ; consoleDoc . setParagraphAttributes ( 0 , 0 , standard , true ) ; Font font = Preferences . getFont ( "console.font" ) ; Color bgColor = mode . getColor ( "console.color" ) ; Color fgColorOut = mode . getColor ( "console.output.color" ) ; Color fgColorErr = mode . getColor ( "console.error.color" ) ; stdStyle = new SimpleAttributeSet ( ) ; StyleConstants . setForeground ( stdStyle , fgColorOut ) ; StyleConstants . setBackground ( stdStyle , bgColor ) ; StyleConstants . setFontSize ( stdStyle , font . getSize ( ) ) ; StyleConstants . setFontFamily ( stdStyle , font . getFamily ( ) ) ; StyleConstants . setBold ( stdStyle , font . isBold ( ) ) ; StyleConstants . setItalic ( stdStyle , font . isItalic ( ) ) ; errStyle = new SimpleAttributeSet ( ) ; StyleConstants . setForeground ( errStyle , fgColorErr ) ; StyleConstants . setBackground ( errStyle , bgColor ) ; StyleConstants . setFontSize ( errStyle , font . getSize ( ) ) ; StyleConstants . setFontFamily ( errStyle , font . getFamily ( ) ) ; StyleConstants . setBold ( errStyle , font . isBold ( ) ) ; StyleConstants . setItalic ( errStyle , font . isItalic ( ) ) ; if ( UIManager . getLookAndFeel ( ) . getID ( ) . equals ( "Nimbus" ) ) { getViewport ( ) . setBackground ( bgColor ) ; consoleTextPane . setOpaque ( false ) ; consoleTextPane . setBackground ( new Color ( 0 , 0 , 0 , 0 ) ) ; } else { consoleTextPane . setBackground ( bgColor ) ; } FontMetrics metrics = this . getFontMetrics ( font ) ; int height = metrics . getAscent ( ) + metrics . getDescent ( ) ; int lines = Preferences . getInteger ( "console.lines" ) ; int sizeFudge = 6 ; setPreferredSize ( new Dimension ( 1024 , ( height * lines ) + sizeFudge ) ) ; setMinimumSize ( new Dimension ( 1024 , ( height * 4 ) + sizeFudge ) ) ; } static public void setEditor ( Editor editor ) { currentConsole = editor . console ; } public static void handleQuit ( ) { System . setOut ( systemOut ) ; System . setErr ( systemErr ) ; try { if ( consoleOut != null ) consoleOut . close ( ) ; if ( consoleErr != null ) consoleErr . close ( ) ; if ( stdoutFile != null ) stdoutFile . close ( ) ; if ( stderrFile != null ) stderrFile . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( systemErr ) ; } } synchronized public void message ( String what , boolean err ) { if ( err ) { systemErr . print ( what ) ; } else { systemOut . print ( what ) ; } if ( err && ( what . contains ( "invalid context 0x0" ) || ( what . contains ( "invalid drawable" ) ) ) ) { } else if ( err && what . contains ( "Make pbuffer:" ) ) { } else if ( err && what . contains ( "XInitThreads() called for concurrent" ) ) { } else if ( ! err && what . contains ( "Listening for transport dt_socket at address" ) ) { } else { consoleDoc . appendString ( what , err ? errStyle : stdStyle ) ; } } public void clear ( ) { try { consoleDoc . remove ( 0 , consoleDoc . getLength ( ) ) ; } catch ( BadLocationException e ) { } } private static class EditorConsoleStream extends OutputStream { final boolean err ; final byte single [ ] = new byte [ 1 ] ; EditorConsole console ; public EditorConsoleStream ( boolean err , EditorConsole console ) { this . err = err ; this . console = console ; } public void close ( ) { } public void flush ( ) { } public void write ( byte b [ ] ) { write ( b , 0 , b . length ) ; } public void write ( byte b [ ] , int offset , int length ) { if ( console != null ) { console . message ( new String ( b , offset , length ) , err ) ; } else if ( currentConsole != null ) { currentConsole . message ( new String ( b , offset , length ) , err ) ; } else { if ( err ) { systemErr . write ( b , offset , length ) ; } else { systemOut . write ( b , offset , length ) ; } } final OutputStream echo = err ? stderrFile : stdoutFile ; if ( echo != null ) { try { echo . write ( b , offset , length ) ; echo . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } public void write ( int b ) { single [ 0 ] = ( byte ) b ; write ( single , 0 , 1 ) ; } } } class BufferedStyledDocument extends DefaultStyledDocument { ArrayList < ElementSpec > elements = new ArrayList < ElementSpec > ( ) ; int maxLineLength , maxLineCount ; int currentLineLength = 0 ; boolean needLineBreak = false ; boolean hasAppendage = false ; public BufferedStyledDocument ( int maxLineLength , int maxLineCount ) { this . maxLineLength = maxLineLength ; this . maxLineCount = maxLineCount ; } public synchronized void appendString ( String str , AttributeSet a ) { hasAppendage = true ; while ( str . length ( ) > 0 ) { if ( needLineBreak || currentLineLength > maxLineLength ) { elements . add ( new ElementSpec ( a , ElementSpec . EndTagType ) ) ; elements . add ( new ElementSpec ( a , ElementSpec . StartTagType ) ) ; currentLineLength = 0 ; } if ( str . indexOf ( '\n' ) == - 1 ) { elements . add ( new ElementSpec ( a , ElementSpec . ContentType , str . toCharArray ( ) , 0 , str . length ( ) ) ) ; currentLineLength += str . length ( ) ; needLineBreak = false ; str = str . substring ( str . length ( ) ) ; } else { elements . add ( new ElementSpec ( a , ElementSpec . ContentType , str . toCharArray ( ) , 0 , str . indexOf ( '\n' ) + 1 ) ) ; needLineBreak = true ; str = str . substring ( str . indexOf ( '\n' ) + 1 ) ; } } } public synchronized void insertAll ( ) { ElementSpec [ ] elementArray = new ElementSpec [ elements . size ( ) ] ; elements . toArray ( elementArray ) ; try { Element element = super . getDefaultRootElement ( ) ; int lineCount = element . getElementCount ( ) ; int overage = lineCount - maxLineCount ; if ( overage > 0 ) { Element lineElement = element . getElement ( overage ) ; if ( lineElement == null ) return ; int endOffset = lineElement . getEndOffset ( ) ; super . remove ( 0 , endOffset ) ; } super . insert ( super . getLength ( ) , elementArray ) ; } catch ( BadLocationException e ) { } elements . clear ( ) ; hasAppendage = false ; } }
package processing . app ; import java . io . * ; import java . net . * ; import java . util . * ; import java . util . zip . * ; public class WebServer implements HttpConstants { static Vector threads = new Vector ( ) ; static int timeout = 10000 ; static int workers = 5 ; protected static void log ( String s ) { if ( false ) { System . out . println ( s ) ; } } static public int launch ( String zipPath ) throws IOException { final ZipFile zip = new ZipFile ( zipPath ) ; final Map < String , ZipEntry > entries = new HashMap < String , ZipEntry > ( ) ; Enumeration en = zip . entries ( ) ; while ( en . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) en . nextElement ( ) ; entries . put ( entry . getName ( ) , entry ) ; } for ( int i = 0 ; i < workers ; ++ i ) { WebServerWorker w = new WebServerWorker ( zip , entries ) ; Thread t = new Thread ( w , "Web Server Worker #" + i ) ; t . start ( ) ; threads . addElement ( w ) ; } final int port = 8080 ; Runnable r = new Runnable ( ) { public void run ( ) { try { ServerSocket ss = new ServerSocket ( port ) ; while ( true ) { Socket s = ss . accept ( ) ; WebServerWorker w = null ; synchronized ( threads ) { if ( threads . isEmpty ( ) ) { WebServerWorker ws = new WebServerWorker ( zip , entries ) ; ws . setSocket ( s ) ; ( new Thread ( ws , "additional worker" ) ) . start ( ) ; } else { w = ( WebServerWorker ) threads . elementAt ( 0 ) ; threads . removeElementAt ( 0 ) ; w . setSocket ( s ) ; } } } } catch ( IOException e ) { e . printStackTrace ( ) ; } } } ; new Thread ( r ) . start ( ) ; return port ; } } class WebServerWorker implements HttpConstants , Runnable { private final ZipFile zip ; private final Map < String , ZipEntry > entries ; final static int BUF_SIZE = 2048 ; static final byte [ ] EOL = { ( byte ) '\r' , ( byte ) '\n' } ; byte [ ] buf ; private Socket s ; WebServerWorker ( ZipFile zip , Map < String , ZipEntry > entries ) { this . entries = entries ; this . zip = zip ; buf = new byte [ BUF_SIZE ] ; s = null ; } synchronized void setSocket ( Socket s ) { this . s = s ; notify ( ) ; } public synchronized void run ( ) { while ( true ) { if ( s == null ) { try { wait ( ) ; } catch ( InterruptedException e ) { continue ; } } try { handleClient ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } s = null ; Vector pool = WebServer . threads ; synchronized ( pool ) { if ( pool . size ( ) >= WebServer . workers ) { return ; } else { pool . addElement ( this ) ; } } } } void handleClient ( ) throws IOException { InputStream is = new BufferedInputStream ( s . getInputStream ( ) ) ; PrintStream ps = new PrintStream ( s . getOutputStream ( ) ) ; s . setSoTimeout ( WebServer . timeout ) ; s . setTcpNoDelay ( true ) ; for ( int i = 0 ; i < BUF_SIZE ; i ++ ) { buf [ i ] = 0 ; } try { int nread = 0 , r = 0 ; outerloop : while ( nread < BUF_SIZE ) { r = is . read ( buf , nread , BUF_SIZE - nread ) ; if ( r == - 1 ) { return ; } int i = nread ; nread += r ; for ( ; i < nread ; i ++ ) { if ( buf [ i ] == ( byte ) '\n' || buf [ i ] == ( byte ) '\r' ) { break outerloop ; } } } boolean doingGet ; int index ; if ( buf [ 0 ] == ( byte ) 'G' && buf [ 1 ] == ( byte ) 'E' && buf [ 2 ] == ( byte ) 'T' && buf [ 3 ] == ( byte ) ' ' ) { doingGet = true ; index = 4 ; } else if ( buf [ 0 ] == ( byte ) 'H' && buf [ 1 ] == ( byte ) 'E' && buf [ 2 ] == ( byte ) 'A' && buf [ 3 ] == ( byte ) 'D' && buf [ 4 ] == ( byte ) ' ' ) { doingGet = false ; index = 5 ; } else { ps . print ( "HTTP/1.0 " + HTTP_BAD_METHOD + " unsupported method type: " ) ; ps . write ( buf , 0 , 5 ) ; ps . write ( EOL ) ; ps . flush ( ) ; s . close ( ) ; return ; } int i = 0 ; for ( i = index ; i < nread ; i ++ ) { if ( buf [ i ] == ( byte ) ' ' ) { break ; } } String fname = new String ( buf , index , i - index ) ; ZipEntry entry = entries . get ( fname . substring ( 1 ) ) ; boolean ok = printHeaders ( entry , ps ) ; if ( entry != null ) { InputStream stream = zip . getInputStream ( entry ) ; if ( doingGet && ok ) { sendFile ( stream , ps ) ; } } else { send404 ( ps ) ; } } finally { s . close ( ) ; } } boolean printHeaders ( ZipEntry targ , PrintStream ps ) throws IOException { boolean ret = false ; int rCode = 0 ; if ( targ == null ) { rCode = HTTP_NOT_FOUND ; ps . print ( "HTTP/1.0 " + HTTP_NOT_FOUND + " Not Found" ) ; ps . write ( EOL ) ; ret = false ; } else { rCode = HTTP_OK ; ps . print ( "HTTP/1.0 " + HTTP_OK + " OK" ) ; ps . write ( EOL ) ; ret = true ; } if ( targ != null ) { WebServer . log ( "From " + s . getInetAddress ( ) . getHostAddress ( ) + ": GET " + targ . getName ( ) + " --> " + rCode ) ; } ps . print ( "Server: Processing Documentation Server" ) ; ps . write ( EOL ) ; ps . print ( "Date: " + ( new Date ( ) ) ) ; ps . write ( EOL ) ; if ( ret ) { if ( ! targ . isDirectory ( ) ) { ps . print ( "Content-length: " + targ . getSize ( ) ) ; ps . write ( EOL ) ; ps . print ( "Last Modified: " + new Date ( targ . getTime ( ) ) ) ; ps . write ( EOL ) ; String name = targ . getName ( ) ; int ind = name . lastIndexOf ( '.' ) ; String ct = null ; if ( ind > 0 ) { ct = map . get ( name . substring ( ind ) ) ; } if ( ct == null ) { ct = "application/x-unknown-content-type" ; } ps . print ( "Content-type: " + ct ) ; ps . write ( EOL ) ; } else { ps . print ( "Content-type: text/html" ) ; ps . write ( EOL ) ; } } ps . write ( EOL ) ; return ret ; } boolean printHeaders ( File targ , PrintStream ps ) throws IOException { boolean ret = false ; int rCode = 0 ; if ( ! targ . exists ( ) ) { rCode = HTTP_NOT_FOUND ; ps . print ( "HTTP/1.0 " + HTTP_NOT_FOUND + " Not Found" ) ; ps . write ( EOL ) ; ret = false ; } else { rCode = HTTP_OK ; ps . print ( "HTTP/1.0 " + HTTP_OK + " OK" ) ; ps . write ( EOL ) ; ret = true ; } WebServer . log ( "From " + s . getInetAddress ( ) . getHostAddress ( ) + ": GET " + targ . getAbsolutePath ( ) + "-->" + rCode ) ; ps . print ( "Server: Simple java" ) ; ps . write ( EOL ) ; ps . print ( "Date: " + ( new Date ( ) ) ) ; ps . write ( EOL ) ; if ( ret ) { if ( ! targ . isDirectory ( ) ) { ps . print ( "Content-length: " + targ . length ( ) ) ; ps . write ( EOL ) ; ps . print ( "Last Modified: " + new Date ( targ . lastModified ( ) ) ) ; ps . write ( EOL ) ; String name = targ . getName ( ) ; int ind = name . lastIndexOf ( '.' ) ; String ct = null ; if ( ind > 0 ) { ct = map . get ( name . substring ( ind ) ) ; } if ( ct == null ) { ct = "unknown/unknown" ; } ps . print ( "Content-type: " + ct ) ; ps . write ( EOL ) ; } else { ps . print ( "Content-type: text/html" ) ; ps . write ( EOL ) ; } } return ret ; } void send404 ( PrintStream ps ) throws IOException { ps . write ( EOL ) ; ps . write ( EOL ) ; ps . print ( "<html><body><h1>404 Not Found</h1>" + "The requested resource was not found.</body></html>" ) ; ps . write ( EOL ) ; ps . write ( EOL ) ; } void sendFile ( File targ , PrintStream ps ) throws IOException { InputStream is = null ; ps . write ( EOL ) ; if ( targ . isDirectory ( ) ) { listDirectory ( targ , ps ) ; return ; } else { is = new FileInputStream ( targ . getAbsolutePath ( ) ) ; } sendFile ( is , ps ) ; } void sendFile ( InputStream is , PrintStream ps ) throws IOException { try { int n ; while ( ( n = is . read ( buf ) ) > 0 ) { ps . write ( buf , 0 , n ) ; } } finally { is . close ( ) ; } } static Map < String , String > map = new HashMap < String , String > ( ) ; static { fillMap ( ) ; } static void setSuffix ( String k , String v ) { map . put ( k , v ) ; } static void fillMap ( ) { setSuffix ( "" , "content/unknown" ) ; setSuffix ( ".uu" , "application/octet-stream" ) ; setSuffix ( ".exe" , "application/octet-stream" ) ; setSuffix ( ".ps" , "application/postscript" ) ; setSuffix ( ".zip" , "application/zip" ) ; setSuffix ( ".sh" , "application/x-shar" ) ; setSuffix ( ".tar" , "application/x-tar" ) ; setSuffix ( ".snd" , "audio/basic" ) ; setSuffix ( ".au" , "audio/basic" ) ; setSuffix ( ".wav" , "audio/x-wav" ) ; setSuffix ( ".gif" , "image/gif" ) ; setSuffix ( ".jpg" , "image/jpeg" ) ; setSuffix ( ".jpeg" , "image/jpeg" ) ; setSuffix ( ".htm" , "text/html" ) ; setSuffix ( ".html" , "text/html" ) ; setSuffix ( ".css" , "text/css" ) ; setSuffix ( ".java" , "text/javascript" ) ; setSuffix ( ".txt" , "text/plain" ) ; setSuffix ( ".java" , "text/plain" ) ; setSuffix ( ".c" , "text/plain" ) ; setSuffix ( ".cc" , "text/plain" ) ; setSuffix ( ".c++" , "text/plain" ) ; setSuffix ( ".h" , "text/plain" ) ; setSuffix ( ".pl" , "text/plain" ) ; } void listDirectory ( File dir , PrintStream ps ) throws IOException { ps . println ( "<TITLE>Directory listing</TITLE><P>\n" ) ; ps . println ( "<A HREF=\"..\">Parent Directory</A><BR>\n" ) ; String [ ] list = dir . list ( ) ; for ( int i = 0 ; list != null && i < list . length ; i ++ ) { File f = new File ( dir , list [ i ] ) ; if ( f . isDirectory ( ) ) { ps . println ( "<A HREF=\"" + list [ i ] + "/\">" + list [ i ] + "/</A><BR>" ) ; } else { ps . println ( "<A HREF=\"" + list [ i ] + "\">" + list [ i ] + "</A><BR" ) ; } } ps . println ( "<P><HR><BR><I>" + ( new Date ( ) ) + "</I>" ) ; } } interface HttpConstants { public static final int HTTP_OK = 200 ; public static final int HTTP_CREATED = 201 ; public static final int HTTP_ACCEPTED = 202 ; public static final int HTTP_NOT_AUTHORITATIVE = 203 ; public static final int HTTP_NO_CONTENT = 204 ; public static final int HTTP_RESET = 205 ; public static final int HTTP_PARTIAL = 206 ; public static final int HTTP_MULT_CHOICE = 300 ; public static final int HTTP_MOVED_PERM = 301 ; public static final int HTTP_MOVED_TEMP = 302 ; public static final int HTTP_SEE_OTHER = 303 ; public static final int HTTP_NOT_MODIFIED = 304 ; public static final int HTTP_USE_PROXY = 305 ; public static final int HTTP_BAD_REQUEST = 400 ; public static final int HTTP_UNAUTHORIZED = 401 ; public static final int HTTP_PAYMENT_REQUIRED = 402 ; public static final int HTTP_FORBIDDEN = 403 ; public static final int HTTP_NOT_FOUND = 404 ; public static final int HTTP_BAD_METHOD = 405 ; public static final int HTTP_NOT_ACCEPTABLE = 406 ; public static final int HTTP_PROXY_AUTH = 407 ; public static final int HTTP_CLIENT_TIMEOUT = 408 ; public static final int HTTP_CONFLICT = 409 ; public static final int HTTP_GONE = 410 ; public static final int HTTP_LENGTH_REQUIRED = 411 ; public static final int HTTP_PRECON_FAILED = 412 ; public static final int HTTP_ENTITY_TOO_LARGE = 413 ; public static final int HTTP_REQ_TOO_LONG = 414 ; public static final int HTTP_UNSUPPORTED_TYPE = 415 ; public static final int HTTP_SERVER_ERROR = 500 ; public static final int HTTP_INTERNAL_ERROR = 501 ; public static final int HTTP_BAD_GATEWAY = 502 ; public static final int HTTP_UNAVAILABLE = 503 ; public static final int HTTP_GATEWAY_TIMEOUT = 504 ; public static final int HTTP_VERSION = 505 ; }
package processing . app ; import java . io . * ; import javax . swing . text . Document ; import javax . swing . undo . * ; public class SketchCode { private String prettyName ; private File file ; private String extension ; private String program ; private String savedProgram ; private Document document ; long visited ; private long lastModified ; private UndoManager undo = new UndoManager ( ) ; private int selectionStart ; private int selectionStop ; private int scrollPosition ; private boolean modified ; private int preprocOffset ; public SketchCode ( File file , String extension ) { this . file = file ; this . extension = extension ; makePrettyName ( ) ; try { load ( ) ; } catch ( IOException e ) { System . err . println ( "Error while loading code " + file . getName ( ) ) ; } } protected void makePrettyName ( ) { prettyName = file . getName ( ) ; int dot = prettyName . lastIndexOf ( '.' ) ; prettyName = prettyName . substring ( 0 , dot ) ; } public File getFile ( ) { return file ; } protected boolean fileExists ( ) { return file . exists ( ) ; } protected boolean fileReadOnly ( ) { return ! file . canWrite ( ) ; } protected boolean deleteFile ( ) { return file . delete ( ) ; } protected boolean renameTo ( File what , String ext ) { boolean success = file . renameTo ( what ) ; if ( success ) { this . file = what ; this . extension = ext ; makePrettyName ( ) ; } return success ; } public void copyTo ( File dest ) throws IOException { Base . saveFile ( program , dest ) ; } public String getFileName ( ) { return file . getName ( ) ; } public String getPrettyName ( ) { return prettyName ; } public String getExtension ( ) { return extension ; } public boolean isExtension ( String what ) { return extension . equals ( what ) ; } public String getProgram ( ) { return program ; } public void setProgram ( String replacement ) { program = replacement ; } public String getSavedProgram ( ) { return savedProgram ; } public int getLineCount ( ) { return Base . countLines ( program ) ; } public void setModified ( boolean modified ) { this . modified = modified ; } public boolean isModified ( ) { return modified ; } public void setPreprocOffset ( int preprocOffset ) { this . preprocOffset = preprocOffset ; } public int getPreprocOffset ( ) { return preprocOffset ; } public void addPreprocOffset ( int extra ) { preprocOffset += extra ; } public Document getDocument ( ) { return document ; } public void setDocument ( Document d ) { document = d ; } public UndoManager getUndo ( ) { return undo ; } public int getSelectionStart ( ) { return selectionStart ; } public int getSelectionStop ( ) { return selectionStop ; } public int getScrollPosition ( ) { return scrollPosition ; } protected void setState ( String p , int start , int stop , int pos ) { program = p ; selectionStart = start ; selectionStop = stop ; scrollPosition = pos ; } public long lastVisited ( ) { return visited ; } public void load ( ) throws IOException { program = Base . loadFile ( file ) ; if ( program . indexOf ( '\0' ) != - 1 ) { program = program . replaceAll ( "\0" , "" ) ; } savedProgram = program ; if ( program . indexOf ( '\uFFFD' ) != - 1 ) { System . err . println ( file . getName ( ) + " contains unrecognized characters." ) ; System . err . println ( "You should re-open " + file . getName ( ) + " with a text editor," ) ; System . err . println ( "and re-save it in UTF-8 format. Otherwise, you can" ) ; System . err . println ( "delete the bad characters to get rid of this warning." ) ; System . err . println ( ) ; } lastModified = file . lastModified ( ) ; setModified ( false ) ; } public void save ( ) throws IOException { Base . saveFile ( program , file ) ; savedProgram = program ; lastModified = file . lastModified ( ) ; setModified ( false ) ; } public void saveAs ( File newFile ) throws IOException { Base . saveFile ( program , newFile ) ; savedProgram = program ; file = newFile ; makePrettyName ( ) ; lastModified = file . lastModified ( ) ; setModified ( false ) ; } public void setFolder ( File sketchFolder ) { file = new File ( sketchFolder , file . getName ( ) ) ; } public long lastModified ( ) { return lastModified ; } }
package processing . core ; import processing . data . * ; import java . awt . Paint ; import java . awt . PaintContext ; import java . awt . Rectangle ; import java . awt . RenderingHints ; import java . awt . geom . AffineTransform ; import java . awt . geom . Point2D ; import java . awt . geom . Rectangle2D ; import java . awt . image . ColorModel ; import java . awt . image . Raster ; import java . awt . image . WritableRaster ; import java . util . HashMap ; public class PShapeSVG extends PShape { XML element ; float opacity ; float strokeOpacity ; float fillOpacity ; protected float svgWidth ; protected float svgHeight ; protected float svgXYSize ; Gradient strokeGradient ; Paint strokeGradientPaint ; String strokeName ; Gradient fillGradient ; Paint fillGradientPaint ; String fillName ; public PShapeSVG ( XML svg ) { this ( null , svg , true ) ; if ( ! svg . getName ( ) . equals ( "svg" ) ) { throw new RuntimeException ( "The root node is not <svg>, it's <" + svg . getName ( ) + ">." + ( svg . getName ( ) . toLowerCase ( ) . equals ( "html" ) ? " That means it's just a webpage. Did you download it right?" : "" ) ) ; } } protected PShapeSVG ( PShapeSVG parent , XML properties , boolean parseKids ) { this . parent = parent ; if ( parent == null ) { stroke = false ; strokeColor = 0xff000000 ; strokeWeight = 1 ; strokeCap = PConstants . SQUARE ; strokeJoin = PConstants . MITER ; strokeGradient = null ; strokeGradientPaint = null ; strokeName = null ; fill = true ; fillColor = 0xff000000 ; fillGradient = null ; fillGradientPaint = null ; fillName = null ; strokeOpacity = 1 ; fillOpacity = 1 ; opacity = 1 ; } else { stroke = parent . stroke ; strokeColor = parent . strokeColor ; strokeWeight = parent . strokeWeight ; strokeCap = parent . strokeCap ; strokeJoin = parent . strokeJoin ; strokeGradient = parent . strokeGradient ; strokeGradientPaint = parent . strokeGradientPaint ; strokeName = parent . strokeName ; fill = parent . fill ; fillColor = parent . fillColor ; fillGradient = parent . fillGradient ; fillGradientPaint = parent . fillGradientPaint ; fillName = parent . fillName ; svgWidth = parent . svgWidth ; svgHeight = parent . svgHeight ; svgXYSize = parent . svgXYSize ; opacity = parent . opacity ; } if ( properties . getName ( ) . equals ( "svg" ) ) { String unitWidth = properties . getString ( "width" ) ; String unitHeight = properties . getString ( "height" ) ; if ( unitWidth != null ) width = parseUnitSize ( unitWidth , 100 ) ; if ( unitHeight != null ) height = parseUnitSize ( unitHeight , 100 ) ; String viewBoxStr = properties . getString ( "viewBox" ) ; if ( viewBoxStr != null ) { float [ ] viewBox = PApplet . parseFloat ( PApplet . splitTokens ( viewBoxStr ) ) ; if ( unitWidth == null || unitHeight == null ) { width = viewBox [ 2 ] ; height = viewBox [ 3 ] ; } else { if ( matrix == null ) matrix = new PMatrix2D ( ) ; matrix . scale ( width / viewBox [ 2 ] , height / viewBox [ 3 ] ) ; matrix . translate ( - viewBox [ 0 ] , - viewBox [ 1 ] ) ; } } if ( width < 0 || height < 0 ) throw new RuntimeException ( "<svg>: width (" + width + ") and height (" + height + ") must not be negative." ) ; if ( ( unitWidth == null || unitHeight == null ) && viewBoxStr == null ) { PGraphics . showWarning ( "The width and/or height is not " + "readable in the <svg> tag of this file." ) ; width = 1 ; height = 1 ; } svgWidth = width ; svgHeight = height ; svgXYSize = PApplet . sqrt ( ( svgWidth * svgWidth + svgHeight * svgHeight ) / 2.0f ) ; } element = properties ; name = properties . getString ( "id" ) ; if ( name != null ) { while ( true ) { String [ ] m = PApplet . match ( name , "_x([A-Za-z0-9]{2})_" ) ; if ( m == null ) break ; char repair = ( char ) PApplet . unhex ( m [ 1 ] ) ; name = name . replace ( m [ 0 ] , "" + repair ) ; } } String displayStr = properties . getString ( "display" , "inline" ) ; visible = ! displayStr . equals ( "none" ) ; String transformStr = properties . getString ( "transform" ) ; if ( transformStr != null ) { if ( matrix == null ) { matrix = parseTransform ( transformStr ) ; } else { matrix . preApply ( parseTransform ( transformStr ) ) ; } } if ( parseKids ) { parseColors ( properties ) ; parseChildren ( properties ) ; } } protected void parseChildren ( XML graphics ) { XML [ ] elements = graphics . getChildren ( ) ; children = new PShape [ elements . length ] ; childCount = 0 ; for ( XML elem : elements ) { PShape kid = parseChild ( elem ) ; if ( kid != null ) addChild ( kid ) ; } children = ( PShape [ ] ) PApplet . subset ( children , 0 , childCount ) ; } protected PShape parseChild ( XML elem ) { String name = elem . getName ( ) ; PShapeSVG shape = null ; if ( name == null ) { } else if ( name . equals ( "g" ) ) { shape = new PShapeSVG ( this , elem , true ) ; } else if ( name . equals ( "defs" ) ) { shape = new PShapeSVG ( this , elem , true ) ; } else if ( name . equals ( "line" ) ) { shape = new PShapeSVG ( this , elem , true ) ; shape . parseLine ( ) ; } else if ( name . equals ( "circle" ) ) { shape = new PShapeSVG ( this , elem , true ) ; shape . parseEllipse ( true ) ; } else if ( name . equals ( "ellipse" ) ) { shape = new PShapeSVG ( this , elem , true ) ; shape . parseEllipse ( false ) ; } else if ( name . equals ( "rect" ) ) { shape = new PShapeSVG ( this , elem , true ) ; shape . parseRect ( ) ; } else if ( name . equals ( "polygon" ) ) { shape = new PShapeSVG ( this , elem , true ) ; shape . parsePoly ( true ) ; } else if ( name . equals ( "polyline" ) ) { shape = new PShapeSVG ( this , elem , true ) ; shape . parsePoly ( false ) ; } else if ( name . equals ( "path" ) ) { shape = new PShapeSVG ( this , elem , true ) ; shape . parsePath ( ) ; } else if ( name . equals ( "radialGradient" ) ) { return new RadialGradient ( this , elem ) ; } else if ( name . equals ( "linearGradient" ) ) { return new LinearGradient ( this , elem ) ; } else if ( name . equals ( "font" ) ) { return new Font ( this , elem ) ; } else if ( name . equals ( "text" ) ) { PGraphics . showWarning ( "Text and fonts in SVG files are " + "not currently supported, convert text to outlines instead." ) ; } else if ( name . equals ( "filter" ) ) { PGraphics . showWarning ( "Filters are not supported." ) ; } else if ( name . equals ( "mask" ) ) { PGraphics . showWarning ( "Masks are not supported." ) ; } else if ( name . equals ( "pattern" ) ) { PGraphics . showWarning ( "Patterns are not supported." ) ; } else if ( name . equals ( "stop" ) ) { } else if ( name . equals ( "sodipodi:namedview" ) ) { } else if ( name . equals ( "metadata" ) || name . equals ( "title" ) || name . equals ( "desc" ) ) { return null ; } else if ( ! name . startsWith ( "#" ) ) { PGraphics . showWarning ( "Ignoring <" + name + "> tag." ) ; } return shape ; } protected void parseLine ( ) { kind = LINE ; family = PRIMITIVE ; params = new float [ ] { getFloatWithUnit ( element , "x1" , svgWidth ) , getFloatWithUnit ( element , "y1" , svgHeight ) , getFloatWithUnit ( element , "x2" , svgWidth ) , getFloatWithUnit ( element , "y2" , svgHeight ) } ; } protected void parseEllipse ( boolean circle ) { kind = ELLIPSE ; family = PRIMITIVE ; params = new float [ 4 ] ; params [ 0 ] = getFloatWithUnit ( element , "cx" , svgWidth ) ; params [ 1 ] = getFloatWithUnit ( element , "cy" , svgHeight ) ; float rx , ry ; if ( circle ) { rx = ry = getFloatWithUnit ( element , "r" , svgXYSize ) ; } else { rx = getFloatWithUnit ( element , "rx" , svgWidth ) ; ry = getFloatWithUnit ( element , "ry" , svgHeight ) ; } params [ 0 ] -= rx ; params [ 1 ] -= ry ; params [ 2 ] = rx * 2 ; params [ 3 ] = ry * 2 ; } protected void parseRect ( ) { kind = RECT ; family = PRIMITIVE ; params = new float [ ] { getFloatWithUnit ( element , "x" , svgWidth ) , getFloatWithUnit ( element , "y" , svgHeight ) , getFloatWithUnit ( element , "width" , svgWidth ) , getFloatWithUnit ( element , "height" , svgHeight ) } ; } protected void parsePoly ( boolean close ) { family = PATH ; this . close = close ; String pointsAttr = element . getString ( "points" ) ; if ( pointsAttr != null ) { String [ ] pointsBuffer = PApplet . splitTokens ( pointsAttr ) ; vertexCount = pointsBuffer . length ; vertices = new float [ vertexCount ] [ 2 ] ; for ( int i = 0 ; i < vertexCount ; i ++ ) { String pb [ ] = PApplet . splitTokens ( pointsBuffer [ i ] , ", \t\r\n" ) ; vertices [ i ] [ X ] = Float . parseFloat ( pb [ 0 ] ) ; vertices [ i ] [ Y ] = Float . parseFloat ( pb [ 1 ] ) ; } } } protected void parsePath ( ) { family = PATH ; kind = 0 ; String pathData = element . getString ( "d" ) ; if ( pathData == null || PApplet . trim ( pathData ) . length ( ) == 0 ) { return ; } char [ ] pathDataChars = pathData . toCharArray ( ) ; StringBuilder pathBuffer = new StringBuilder ( ) ; boolean lastSeparate = false ; for ( int i = 0 ; i < pathDataChars . length ; i ++ ) { char c = pathDataChars [ i ] ; boolean separate = false ; if ( c == 'M' || c == 'm' || c == 'L' || c == 'l' || c == 'H' || c == 'h' || c == 'V' || c == 'v' || c == 'C' || c == 'c' || c == 'S' || c == 's' || c == 'Q' || c == 'q' || c == 'T' || c == 't' || c == 'A' || c == 'a' || c == 'Z' || c == 'z' || c == ',' ) { separate = true ; if ( i != 0 ) { pathBuffer . append ( "|" ) ; } } if ( c == 'Z' || c == 'z' ) { separate = false ; } if ( c == '-' && ! lastSeparate ) { if ( i == 0 || pathDataChars [ i - 1 ] != 'e' ) { pathBuffer . append ( "|" ) ; } } if ( c != ',' ) { pathBuffer . append ( c ) ; } if ( separate && c != ',' && c != '-' ) { pathBuffer . append ( "|" ) ; } lastSeparate = separate ; } String [ ] pathTokens = PApplet . splitTokens ( pathBuffer . toString ( ) , "|" + WHITESPACE ) ; vertices = new float [ pathTokens . length ] [ 2 ] ; vertexCodes = new int [ pathTokens . length ] ; float cx = 0 ; float cy = 0 ; int i = 0 ; char implicitCommand = '\0' ; boolean prevCurve = false ; float ctrlX , ctrlY ; float movetoX = 0 ; float movetoY = 0 ; while ( i < pathTokens . length ) { char c = pathTokens [ i ] . charAt ( 0 ) ; if ( ( ( c >= '0' && c <= '9' ) || ( c == '-' ) ) && implicitCommand != '\0' ) { c = implicitCommand ; i -- ; } else { implicitCommand = c ; } switch ( c ) { case 'M' : cx = PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; cy = PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; movetoX = cx ; movetoY = cy ; parsePathMoveto ( cx , cy ) ; implicitCommand = 'L' ; i += 3 ; break ; case 'm' : cx = cx + PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; cy = cy + PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; movetoX = cx ; movetoY = cy ; parsePathMoveto ( cx , cy ) ; implicitCommand = 'l' ; i += 3 ; break ; case 'L' : cx = PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; cy = PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; parsePathLineto ( cx , cy ) ; i += 3 ; break ; case 'l' : cx = cx + PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; cy = cy + PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; parsePathLineto ( cx , cy ) ; i += 3 ; break ; case 'H' : cx = PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; parsePathLineto ( cx , cy ) ; i += 2 ; break ; case 'h' : cx = cx + PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; parsePathLineto ( cx , cy ) ; i += 2 ; break ; case 'V' : cy = PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; parsePathLineto ( cx , cy ) ; i += 2 ; break ; case 'v' : cy = cy + PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; parsePathLineto ( cx , cy ) ; i += 2 ; break ; case 'C' : { float ctrlX1 = PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; float ctrlY1 = PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; float ctrlX2 = PApplet . parseFloat ( pathTokens [ i + 3 ] ) ; float ctrlY2 = PApplet . parseFloat ( pathTokens [ i + 4 ] ) ; float endX = PApplet . parseFloat ( pathTokens [ i + 5 ] ) ; float endY = PApplet . parseFloat ( pathTokens [ i + 6 ] ) ; parsePathCurveto ( ctrlX1 , ctrlY1 , ctrlX2 , ctrlY2 , endX , endY ) ; cx = endX ; cy = endY ; i += 7 ; prevCurve = true ; } break ; case 'c' : { float ctrlX1 = cx + PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; float ctrlY1 = cy + PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; float ctrlX2 = cx + PApplet . parseFloat ( pathTokens [ i + 3 ] ) ; float ctrlY2 = cy + PApplet . parseFloat ( pathTokens [ i + 4 ] ) ; float endX = cx + PApplet . parseFloat ( pathTokens [ i + 5 ] ) ; float endY = cy + PApplet . parseFloat ( pathTokens [ i + 6 ] ) ; parsePathCurveto ( ctrlX1 , ctrlY1 , ctrlX2 , ctrlY2 , endX , endY ) ; cx = endX ; cy = endY ; i += 7 ; prevCurve = true ; } break ; case 'S' : { if ( ! prevCurve ) { ctrlX = cx ; ctrlY = cy ; } else { float ppx = vertices [ vertexCount - 2 ] [ X ] ; float ppy = vertices [ vertexCount - 2 ] [ Y ] ; float px = vertices [ vertexCount - 1 ] [ X ] ; float py = vertices [ vertexCount - 1 ] [ Y ] ; ctrlX = px + ( px - ppx ) ; ctrlY = py + ( py - ppy ) ; } float ctrlX2 = PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; float ctrlY2 = PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; float endX = PApplet . parseFloat ( pathTokens [ i + 3 ] ) ; float endY = PApplet . parseFloat ( pathTokens [ i + 4 ] ) ; parsePathCurveto ( ctrlX , ctrlY , ctrlX2 , ctrlY2 , endX , endY ) ; cx = endX ; cy = endY ; i += 5 ; prevCurve = true ; } break ; case 's' : { if ( ! prevCurve ) { ctrlX = cx ; ctrlY = cy ; } else { float ppx = vertices [ vertexCount - 2 ] [ X ] ; float ppy = vertices [ vertexCount - 2 ] [ Y ] ; float px = vertices [ vertexCount - 1 ] [ X ] ; float py = vertices [ vertexCount - 1 ] [ Y ] ; ctrlX = px + ( px - ppx ) ; ctrlY = py + ( py - ppy ) ; } float ctrlX2 = cx + PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; float ctrlY2 = cy + PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; float endX = cx + PApplet . parseFloat ( pathTokens [ i + 3 ] ) ; float endY = cy + PApplet . parseFloat ( pathTokens [ i + 4 ] ) ; parsePathCurveto ( ctrlX , ctrlY , ctrlX2 , ctrlY2 , endX , endY ) ; cx = endX ; cy = endY ; i += 5 ; prevCurve = true ; } break ; case 'Q' : { ctrlX = PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; ctrlY = PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; float endX = PApplet . parseFloat ( pathTokens [ i + 3 ] ) ; float endY = PApplet . parseFloat ( pathTokens [ i + 4 ] ) ; parsePathQuadto ( ctrlX , ctrlY , endX , endY ) ; cx = endX ; cy = endY ; i += 5 ; prevCurve = true ; } break ; case 'q' : { ctrlX = cx + PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; ctrlY = cy + PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; float endX = cx + PApplet . parseFloat ( pathTokens [ i + 3 ] ) ; float endY = cy + PApplet . parseFloat ( pathTokens [ i + 4 ] ) ; parsePathQuadto ( ctrlX , ctrlY , endX , endY ) ; cx = endX ; cy = endY ; i += 5 ; prevCurve = true ; } break ; case 'T' : { if ( ! prevCurve ) { ctrlX = cx ; ctrlY = cy ; } else { float ppx = vertices [ vertexCount - 2 ] [ X ] ; float ppy = vertices [ vertexCount - 2 ] [ Y ] ; float px = vertices [ vertexCount - 1 ] [ X ] ; float py = vertices [ vertexCount - 1 ] [ Y ] ; ctrlX = px + ( px - ppx ) ; ctrlY = py + ( py - ppy ) ; } float endX = PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; float endY = PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; parsePathQuadto ( ctrlX , ctrlY , endX , endY ) ; cx = endX ; cy = endY ; i += 3 ; prevCurve = true ; } break ; case 't' : { if ( ! prevCurve ) { ctrlX = cx ; ctrlY = cy ; } else { float ppx = vertices [ vertexCount - 2 ] [ X ] ; float ppy = vertices [ vertexCount - 2 ] [ Y ] ; float px = vertices [ vertexCount - 1 ] [ X ] ; float py = vertices [ vertexCount - 1 ] [ Y ] ; ctrlX = px + ( px - ppx ) ; ctrlY = py + ( py - ppy ) ; } float endX = cx + PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; float endY = cy + PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; parsePathQuadto ( ctrlX , ctrlY , endX , endY ) ; cx = endX ; cy = endY ; i += 3 ; prevCurve = true ; } break ; case 'A' : { float rx = PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; float ry = PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; float angle = PApplet . parseFloat ( pathTokens [ i + 3 ] ) ; boolean fa = PApplet . parseFloat ( pathTokens [ i + 4 ] ) != 0 ; boolean fs = PApplet . parseFloat ( pathTokens [ i + 5 ] ) != 0 ; float endX = PApplet . parseFloat ( pathTokens [ i + 6 ] ) ; float endY = PApplet . parseFloat ( pathTokens [ i + 7 ] ) ; parsePathArcto ( cx , cy , rx , ry , angle , fa , fs , endX , endY ) ; cx = endX ; cy = endY ; i += 8 ; prevCurve = true ; } break ; case 'a' : { float rx = PApplet . parseFloat ( pathTokens [ i + 1 ] ) ; float ry = PApplet . parseFloat ( pathTokens [ i + 2 ] ) ; float angle = PApplet . parseFloat ( pathTokens [ i + 3 ] ) ; boolean fa = PApplet . parseFloat ( pathTokens [ i + 4 ] ) != 0 ; boolean fs = PApplet . parseFloat ( pathTokens [ i + 5 ] ) != 0 ; float endX = cx + PApplet . parseFloat ( pathTokens [ i + 6 ] ) ; float endY = cy + PApplet . parseFloat ( pathTokens [ i + 7 ] ) ; parsePathArcto ( cx , cy , rx , ry , angle , fa , fs , endX , endY ) ; cx = endX ; cy = endY ; i += 8 ; prevCurve = true ; } break ; case 'Z' : case 'z' : cx = movetoX ; cy = movetoY ; close = true ; i ++ ; break ; default : String parsed = PApplet . join ( PApplet . subset ( pathTokens , 0 , i ) , "," ) ; String unparsed = PApplet . join ( PApplet . subset ( pathTokens , i ) , "," ) ; System . err . println ( "parsed: " + parsed ) ; System . err . println ( "unparsed: " + unparsed ) ; throw new RuntimeException ( "shape command not handled: " + pathTokens [ i ] ) ; } } } private void parsePathVertex ( float x , float y ) { if ( vertexCount == vertices . length ) { float [ ] [ ] temp = new float [ vertexCount < < 1 ] [ 2 ] ; System . arraycopy ( vertices , 0 , temp , 0 , vertexCount ) ; vertices = temp ; } vertices [ vertexCount ] [ X ] = x ; vertices [ vertexCount ] [ Y ] = y ; vertexCount ++ ; } private void parsePathCode ( int what ) { if ( vertexCodeCount == vertexCodes . length ) { vertexCodes = PApplet . expand ( vertexCodes ) ; } vertexCodes [ vertexCodeCount ++ ] = what ; } private void parsePathMoveto ( float px , float py ) { if ( vertexCount > 0 ) { parsePathCode ( BREAK ) ; } parsePathCode ( VERTEX ) ; parsePathVertex ( px , py ) ; } private void parsePathLineto ( float px , float py ) { parsePathCode ( VERTEX ) ; parsePathVertex ( px , py ) ; } private void parsePathCurveto ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { parsePathCode ( BEZIER_VERTEX ) ; parsePathVertex ( x1 , y1 ) ; parsePathVertex ( x2 , y2 ) ; parsePathVertex ( x3 , y3 ) ; } private void parsePathQuadto ( float cx , float cy , float x2 , float y2 ) { parsePathCode ( QUADRATIC_VERTEX ) ; parsePathVertex ( cx , cy ) ; parsePathVertex ( x2 , y2 ) ; } private void parsePathArcto ( float x1 , float y1 , float rx , float ry , float angle , boolean fa , boolean fs , float x2 , float y2 ) { if ( x1 == x2 && y1 == y2 ) return ; if ( rx == 0 || ry == 0 ) { parsePathLineto ( x2 , y2 ) ; return ; } rx = PApplet . abs ( rx ) ; ry = PApplet . abs ( ry ) ; float phi = PApplet . radians ( ( ( angle % 360 ) + 360 ) % 360 ) ; float cosPhi = PApplet . cos ( phi ) , sinPhi = PApplet . sin ( phi ) ; float x1r = ( cosPhi * ( x1 - x2 ) + sinPhi * ( y1 - y2 ) ) / 2 ; float y1r = ( - sinPhi * ( x1 - x2 ) + cosPhi * ( y1 - y2 ) ) / 2 ; float cxr , cyr ; { float A = ( x1r * x1r ) / ( rx * rx ) + ( y1r * y1r ) / ( ry * ry ) ; if ( A > 1 ) { float sqrtA = PApplet . sqrt ( A ) ; rx *= sqrtA ; cxr = 0 ; ry *= sqrtA ; cyr = 0 ; } else { float k = ( ( fa == fs ) ? - 1f : 1f ) * PApplet . sqrt ( ( rx * rx * ry * ry ) / ( ( rx * rx * y1r * y1r ) + ( ry * ry * x1r * x1r ) ) - 1f ) ; cxr = k * rx * y1r / ry ; cyr = - k * ry * x1r / rx ; } } float cx = cosPhi * cxr - sinPhi * cyr + ( x1 + x2 ) / 2 ; float cy = sinPhi * cxr + cosPhi * cyr + ( y1 + y2 ) / 2 ; float phi1 , phiDelta ; { float sx = ( x1r - cxr ) / rx , sy = ( y1r - cyr ) / ry ; float tx = ( - x1r - cxr ) / rx , ty = ( - y1r - cyr ) / ry ; phi1 = PApplet . atan2 ( sy , sx ) ; phiDelta = ( ( ( PApplet . atan2 ( ty , tx ) - phi1 ) % TWO_PI ) + TWO_PI ) % TWO_PI ; if ( ! fs ) phiDelta -= TWO_PI ; } int segmentCount = PApplet . ceil ( PApplet . abs ( phiDelta ) / TWO_PI * 4 ) ; float inc = phiDelta / segmentCount ; float a = PApplet . sin ( inc ) * ( PApplet . sqrt ( 4 + 3 * PApplet . sq ( PApplet . tan ( inc / 2 ) ) ) - 1 ) / 3 ; float sinPhi1 = PApplet . sin ( phi1 ) , cosPhi1 = PApplet . cos ( phi1 ) ; float p1x = x1 ; float p1y = y1 ; float relq1x = a * ( - rx * cosPhi * sinPhi1 - ry * sinPhi * cosPhi1 ) ; float relq1y = a * ( - rx * sinPhi * sinPhi1 + ry * cosPhi * cosPhi1 ) ; for ( int i = 0 ; i < segmentCount ; i ++ ) { float eta = phi1 + ( i + 1 ) * inc ; float sinEta = PApplet . sin ( eta ) , cosEta = PApplet . cos ( eta ) ; float p2x = cx + rx * cosPhi * cosEta - ry * sinPhi * sinEta ; float p2y = cy + rx * sinPhi * cosEta + ry * cosPhi * sinEta ; float relq2x = a * ( - rx * cosPhi * sinEta - ry * sinPhi * cosEta ) ; float relq2y = a * ( - rx * sinPhi * sinEta + ry * cosPhi * cosEta ) ; if ( i == segmentCount - 1 ) { p2x = x2 ; p2y = y2 ; } parsePathCode ( BEZIER_VERTEX ) ; parsePathVertex ( p1x + relq1x , p1y + relq1y ) ; parsePathVertex ( p2x - relq2x , p2y - relq2y ) ; parsePathVertex ( p2x , p2y ) ; p1x = p2x ; relq1x = relq2x ; p1y = p2y ; relq1y = relq2y ; } } static protected PMatrix2D parseTransform ( String matrixStr ) { matrixStr = matrixStr . trim ( ) ; PMatrix2D outgoing = null ; int start = 0 ; int stop = - 1 ; while ( ( stop = matrixStr . indexOf ( ')' , start ) ) != - 1 ) { PMatrix2D m = parseSingleTransform ( matrixStr . substring ( start , stop + 1 ) ) ; if ( outgoing == null ) { outgoing = m ; } else { outgoing . apply ( m ) ; } start = stop + 1 ; } return outgoing ; } static protected PMatrix2D parseSingleTransform ( String matrixStr ) { String [ ] pieces = PApplet . match ( matrixStr , "[,\\s]*(\\w+)\\((.*)\\)" ) ; if ( pieces == null ) { System . err . println ( "Could not parse transform " + matrixStr ) ; return null ; } float [ ] m = PApplet . parseFloat ( PApplet . splitTokens ( pieces [ 2 ] , ", " ) ) ; if ( pieces [ 1 ] . equals ( "matrix" ) ) { return new PMatrix2D ( m [ 0 ] , m [ 2 ] , m [ 4 ] , m [ 1 ] , m [ 3 ] , m [ 5 ] ) ; } else if ( pieces [ 1 ] . equals ( "translate" ) ) { float tx = m [ 0 ] ; float ty = ( m . length == 2 ) ? m [ 1 ] : m [ 0 ] ; return new PMatrix2D ( 1 , 0 , tx , 0 , 1 , ty ) ; } else if ( pieces [ 1 ] . equals ( "scale" ) ) { float sx = m [ 0 ] ; float sy = ( m . length == 2 ) ? m [ 1 ] : m [ 0 ] ; return new PMatrix2D ( sx , 0 , 0 , 0 , sy , 0 ) ; } else if ( pieces [ 1 ] . equals ( "rotate" ) ) { float angle = m [ 0 ] ; if ( m . length == 1 ) { float c = PApplet . cos ( angle ) ; float s = PApplet . sin ( angle ) ; return new PMatrix2D ( c , - s , 0 , s , c , 0 ) ; } else if ( m . length == 3 ) { PMatrix2D mat = new PMatrix2D ( 0 , 1 , m [ 1 ] , 1 , 0 , m [ 2 ] ) ; mat . rotate ( m [ 0 ] ) ; mat . translate ( - m [ 1 ] , - m [ 2 ] ) ; return mat ; } } else if ( pieces [ 1 ] . equals ( "skewX" ) ) { return new PMatrix2D ( 1 , 0 , 1 , PApplet . tan ( m [ 0 ] ) , 0 , 0 ) ; } else if ( pieces [ 1 ] . equals ( "skewY" ) ) { return new PMatrix2D ( 1 , 0 , 1 , 0 , PApplet . tan ( m [ 0 ] ) , 0 ) ; } return null ; } protected void parseColors ( XML properties ) { if ( properties . hasAttribute ( "opacity" ) ) { String opacityText = properties . getString ( "opacity" ) ; setOpacity ( opacityText ) ; } if ( properties . hasAttribute ( "stroke" ) ) { String strokeText = properties . getString ( "stroke" ) ; setColor ( strokeText , false ) ; } if ( properties . hasAttribute ( "stroke-opacity" ) ) { String strokeOpacityText = properties . getString ( "stroke-opacity" ) ; setStrokeOpacity ( strokeOpacityText ) ; } if ( properties . hasAttribute ( "stroke-width" ) ) { String lineweight = properties . getString ( "stroke-width" ) ; setStrokeWeight ( lineweight ) ; } if ( properties . hasAttribute ( "stroke-linejoin" ) ) { String linejoin = properties . getString ( "stroke-linejoin" ) ; setStrokeJoin ( linejoin ) ; } if ( properties . hasAttribute ( "stroke-linecap" ) ) { String linecap = properties . getString ( "stroke-linecap" ) ; setStrokeCap ( linecap ) ; } if ( properties . hasAttribute ( "fill" ) ) { String fillText = properties . getString ( "fill" ) ; setColor ( fillText , true ) ; } if ( properties . hasAttribute ( "fill-opacity" ) ) { String fillOpacityText = properties . getString ( "fill-opacity" ) ; setFillOpacity ( fillOpacityText ) ; } if ( properties . hasAttribute ( "style" ) ) { String styleText = properties . getString ( "style" ) ; String [ ] styleTokens = PApplet . splitTokens ( styleText , ";" ) ; for ( int i = 0 ; i < styleTokens . length ; i ++ ) { String [ ] tokens = PApplet . splitTokens ( styleTokens [ i ] , ":" ) ; tokens [ 0 ] = PApplet . trim ( tokens [ 0 ] ) ; if ( tokens [ 0 ] . equals ( "fill" ) ) { setColor ( tokens [ 1 ] , true ) ; } else if ( tokens [ 0 ] . equals ( "fill-opacity" ) ) { setFillOpacity ( tokens [ 1 ] ) ; } else if ( tokens [ 0 ] . equals ( "stroke" ) ) { setColor ( tokens [ 1 ] , false ) ; } else if ( tokens [ 0 ] . equals ( "stroke-width" ) ) { setStrokeWeight ( tokens [ 1 ] ) ; } else if ( tokens [ 0 ] . equals ( "stroke-linecap" ) ) { setStrokeCap ( tokens [ 1 ] ) ; } else if ( tokens [ 0 ] . equals ( "stroke-linejoin" ) ) { setStrokeJoin ( tokens [ 1 ] ) ; } else if ( tokens [ 0 ] . equals ( "stroke-opacity" ) ) { setStrokeOpacity ( tokens [ 1 ] ) ; } else if ( tokens [ 0 ] . equals ( "opacity" ) ) { setOpacity ( tokens [ 1 ] ) ; } else { } } } } void setOpacity ( String opacityText ) { opacity = PApplet . parseFloat ( opacityText ) ; strokeColor = ( ( int ) ( opacity * 255 ) ) < < 24 | strokeColor & 0xFFFFFF ; fillColor = ( ( int ) ( opacity * 255 ) ) < < 24 | fillColor & 0xFFFFFF ; } void setStrokeWeight ( String lineweight ) { strokeWeight = parseUnitSize ( lineweight , svgXYSize ) ; } void setStrokeOpacity ( String opacityText ) { strokeOpacity = PApplet . parseFloat ( opacityText ) ; strokeColor = ( ( int ) ( strokeOpacity * 255 ) ) < < 24 | strokeColor & 0xFFFFFF ; } void setStrokeJoin ( String linejoin ) { if ( linejoin . equals ( "inherit" ) ) { } else if ( linejoin . equals ( "miter" ) ) { strokeJoin = PConstants . MITER ; } else if ( linejoin . equals ( "round" ) ) { strokeJoin = PConstants . ROUND ; } else if ( linejoin . equals ( "bevel" ) ) { strokeJoin = PConstants . BEVEL ; } } void setStrokeCap ( String linecap ) { if ( linecap . equals ( "inherit" ) ) { } else if ( linecap . equals ( "butt" ) ) { strokeCap = PConstants . SQUARE ; } else if ( linecap . equals ( "round" ) ) { strokeCap = PConstants . ROUND ; } else if ( linecap . equals ( "square" ) ) { strokeCap = PConstants . PROJECT ; } } void setFillOpacity ( String opacityText ) { fillOpacity = PApplet . parseFloat ( opacityText ) ; fillColor = ( ( int ) ( fillOpacity * 255 ) ) < < 24 | fillColor & 0xFFFFFF ; } void setColor ( String colorText , boolean isFill ) { colorText = colorText . trim ( ) ; int opacityMask = fillColor & 0xFF000000 ; boolean visible = true ; int color = 0 ; String name = "" ; Gradient gradient = null ; Paint paint = null ; if ( colorText . equals ( "none" ) ) { visible = false ; } else if ( colorText . startsWith ( "url(#" ) ) { name = colorText . substring ( 5 , colorText . length ( ) - 1 ) ; Object object = findChild ( name ) ; if ( object instanceof Gradient ) { gradient = ( Gradient ) object ; paint = calcGradientPaint ( gradient ) ; } else { System . err . println ( "url " + name + " refers to unexpected data: " + object ) ; } } else { color = opacityMask | parseSimpleColor ( colorText ) ; } if ( isFill ) { fill = visible ; fillColor = color ; fillName = name ; fillGradient = gradient ; fillGradientPaint = paint ; } else { stroke = visible ; strokeColor = color ; strokeName = name ; strokeGradient = gradient ; strokeGradientPaint = paint ; } } static protected int parseSimpleColor ( String colorText ) { colorText = colorText . toLowerCase ( ) . trim ( ) ; if ( colorNames . containsKey ( colorText ) ) { return colorNames . get ( colorText ) ; } else if ( colorText . startsWith ( "#" ) ) { if ( colorText . length ( ) == 4 ) { colorText = colorText . replaceAll ( "^#(.)(.)(.)$" , "#$1$1$2$2$3$3" ) ; } return ( Integer . parseInt ( colorText . substring ( 1 ) , 16 ) ) & 0xFFFFFF ; } else if ( colorText . startsWith ( "rgb" ) ) { return parseRGB ( colorText ) ; } else { System . err . println ( "Cannot parse \"" + colorText + "\"." ) ; return 0 ; } } static protected HashMap < String , Integer > colorNames ; static { colorNames = new HashMap < String , Integer > ( ) ; colorNames . put ( "aqua" , 0x00ffff ) ; colorNames . put ( "black" , 0x000000 ) ; colorNames . put ( "blue" , 0x0000ff ) ; colorNames . put ( "fuchsia" , 0xff00ff ) ; colorNames . put ( "gray" , 0x808080 ) ; colorNames . put ( "grey" , 0x808080 ) ; colorNames . put ( "green" , 0x008000 ) ; colorNames . put ( "lime" , 0x00ff00 ) ; colorNames . put ( "maroon" , 0x800000 ) ; colorNames . put ( "navy" , 0x000080 ) ; colorNames . put ( "olive" , 0x808000 ) ; colorNames . put ( "purple" , 0x800080 ) ; colorNames . put ( "red" , 0xff0000 ) ; colorNames . put ( "silver" , 0xc0c0c0 ) ; colorNames . put ( "teal" , 0x008080 ) ; colorNames . put ( "white" , 0xffffff ) ; colorNames . put ( "yellow" , 0xffff00 ) ; } static protected int parseRGB ( String what ) { int leftParen = what . indexOf ( '(' ) + 1 ; int rightParen = what . indexOf ( ')' ) ; String sub = what . substring ( leftParen , rightParen ) ; String [ ] values = PApplet . splitTokens ( sub , ", " ) ; int rgbValue = 0 ; if ( values . length == 3 ) { for ( int i = 0 ; i < 3 ; i ++ ) { rgbValue <<= 8 ; if ( values [ i ] . endsWith ( "%" ) ) { rgbValue |= ( int ) ( PApplet . constrain ( 255 * parseFloatOrPercent ( values [ i ] ) , 0 , 255 ) ) ; } else { rgbValue |= PApplet . constrain ( PApplet . parseInt ( values [ i ] ) , 0 , 255 ) ; } } } else System . err . println ( "Could not read color \"" + what + "\"." ) ; return rgbValue ; } static protected HashMap < String , String > parseStyleAttributes ( String style ) { HashMap < String , String > table = new HashMap < String , String > ( ) ; if ( style == null ) return table ; String [ ] pieces = style . split ( ";" ) ; for ( int i = 0 ; i < pieces . length ; i ++ ) { String [ ] parts = pieces [ i ] . split ( ":" ) ; table . put ( parts [ 0 ] , parts [ 1 ] ) ; } return table ; } static protected float getFloatWithUnit ( XML element , String attribute , float relativeTo ) { String val = element . getString ( attribute ) ; return ( val == null ) ? 0 : parseUnitSize ( val , relativeTo ) ; } static protected float parseUnitSize ( String text , float relativeTo ) { int len = text . length ( ) - 2 ; if ( text . endsWith ( "pt" ) ) { return PApplet . parseFloat ( text . substring ( 0 , len ) ) * 1.25f ; } else if ( text . endsWith ( "pc" ) ) { return PApplet . parseFloat ( text . substring ( 0 , len ) ) * 15 ; } else if ( text . endsWith ( "mm" ) ) { return PApplet . parseFloat ( text . substring ( 0 , len ) ) * 3.543307f ; } else if ( text . endsWith ( "cm" ) ) { return PApplet . parseFloat ( text . substring ( 0 , len ) ) * 35.43307f ; } else if ( text . endsWith ( "in" ) ) { return PApplet . parseFloat ( text . substring ( 0 , len ) ) * 90 ; } else if ( text . endsWith ( "px" ) ) { return PApplet . parseFloat ( text . substring ( 0 , len ) ) ; } else if ( text . endsWith ( "%" ) ) { return relativeTo * parseFloatOrPercent ( text ) ; } else { return PApplet . parseFloat ( text ) ; } } static protected float parseFloatOrPercent ( String text ) { text = text . trim ( ) ; if ( text . endsWith ( "%" ) ) { return Float . parseFloat ( text . substring ( 0 , text . length ( ) - 1 ) ) / 100.0f ; } else { return Float . parseFloat ( text ) ; } } static class Gradient extends PShapeSVG { AffineTransform transform ; float [ ] offset ; int [ ] color ; int count ; public Gradient ( PShapeSVG parent , XML properties ) { super ( parent , properties , true ) ; XML elements [ ] = properties . getChildren ( ) ; offset = new float [ elements . length ] ; color = new int [ elements . length ] ; for ( int i = 0 ; i < elements . length ; i ++ ) { XML elem = elements [ i ] ; String name = elem . getName ( ) ; if ( name . equals ( "stop" ) ) { String offsetAttr = elem . getString ( "offset" ) ; offset [ count ] = parseFloatOrPercent ( offsetAttr ) ; String style = elem . getString ( "style" ) ; HashMap < String , String > styles = parseStyleAttributes ( style ) ; String colorStr = styles . get ( "stop-color" ) ; if ( colorStr == null ) { colorStr = elem . getString ( "stop-color" ) ; if ( colorStr == null ) colorStr = "#000000" ; } String opacityStr = styles . get ( "stop-opacity" ) ; if ( opacityStr == null ) { opacityStr = elem . getString ( "stop-opacity" ) ; if ( opacityStr == null ) opacityStr = "1" ; } int tupacity = PApplet . constrain ( ( int ) ( PApplet . parseFloat ( opacityStr ) * 255 ) , 0 , 255 ) ; color [ count ] = ( tupacity < < 24 ) | parseSimpleColor ( colorStr ) ; count ++ ; } } offset = PApplet . subset ( offset , 0 , count ) ; color = PApplet . subset ( color , 0 , count ) ; } } static class LinearGradient extends Gradient { float x1 , y1 , x2 , y2 ; public LinearGradient ( PShapeSVG parent , XML properties ) { super ( parent , properties ) ; this . x1 = getFloatWithUnit ( properties , "x1" , svgWidth ) ; this . y1 = getFloatWithUnit ( properties , "y1" , svgHeight ) ; this . x2 = getFloatWithUnit ( properties , "x2" , svgWidth ) ; this . y2 = getFloatWithUnit ( properties , "y2" , svgHeight ) ; String transformStr = properties . getString ( "gradientTransform" ) ; if ( transformStr != null ) { float t [ ] = parseTransform ( transformStr ) . get ( null ) ; this . transform = new AffineTransform ( t [ 0 ] , t [ 3 ] , t [ 1 ] , t [ 4 ] , t [ 2 ] , t [ 5 ] ) ; Point2D t1 = transform . transform ( new Point2D . Float ( x1 , y1 ) , null ) ; Point2D t2 = transform . transform ( new Point2D . Float ( x2 , y2 ) , null ) ; this . x1 = ( float ) t1 . getX ( ) ; this . y1 = ( float ) t1 . getY ( ) ; this . x2 = ( float ) t2 . getX ( ) ; this . y2 = ( float ) t2 . getY ( ) ; } } } static class RadialGradient extends Gradient { float cx , cy , r ; public RadialGradient ( PShapeSVG parent , XML properties ) { super ( parent , properties ) ; this . cx = getFloatWithUnit ( properties , "cx" , svgWidth ) ; this . cy = getFloatWithUnit ( properties , "cy" , svgHeight ) ; this . r = getFloatWithUnit ( properties , "r" , svgXYSize ) ; String transformStr = properties . getString ( "gradientTransform" ) ; if ( transformStr != null ) { float t [ ] = parseTransform ( transformStr ) . get ( null ) ; this . transform = new AffineTransform ( t [ 0 ] , t [ 3 ] , t [ 1 ] , t [ 4 ] , t [ 2 ] , t [ 5 ] ) ; Point2D t1 = transform . transform ( new Point2D . Float ( cx , cy ) , null ) ; Point2D t2 = transform . transform ( new Point2D . Float ( cx + r , cy ) , null ) ; this . cx = ( float ) t1 . getX ( ) ; this . cy = ( float ) t1 . getY ( ) ; this . r = ( float ) ( t2 . getX ( ) - t1 . getX ( ) ) ; } } } static class LinearGradientPaint implements Paint { float x1 , y1 , x2 , y2 ; float [ ] offset ; int [ ] color ; int count ; float opacity ; public LinearGradientPaint ( float x1 , float y1 , float x2 , float y2 , float [ ] offset , int [ ] color , int count , float opacity ) { this . x1 = x1 ; this . y1 = y1 ; this . x2 = x2 ; this . y2 = y2 ; this . offset = offset ; this . color = color ; this . count = count ; this . opacity = opacity ; } public PaintContext createContext ( ColorModel cm , Rectangle deviceBounds , Rectangle2D userBounds , AffineTransform xform , RenderingHints hints ) { Point2D t1 = xform . transform ( new Point2D . Float ( x1 , y1 ) , null ) ; Point2D t2 = xform . transform ( new Point2D . Float ( x2 , y2 ) , null ) ; return new LinearGradientContext ( ( float ) t1 . getX ( ) , ( float ) t1 . getY ( ) , ( float ) t2 . getX ( ) , ( float ) t2 . getY ( ) ) ; } public int getTransparency ( ) { return TRANSLUCENT ; } public class LinearGradientContext implements PaintContext { int ACCURACY = 2 ; float tx1 , ty1 , tx2 , ty2 ; public LinearGradientContext ( float tx1 , float ty1 , float tx2 , float ty2 ) { this . tx1 = tx1 ; this . ty1 = ty1 ; this . tx2 = tx2 ; this . ty2 = ty2 ; } public void dispose ( ) { } public ColorModel getColorModel ( ) { return ColorModel . getRGBdefault ( ) ; } public Raster getRaster ( int x , int y , int w , int h ) { WritableRaster raster = getColorModel ( ) . createCompatibleWritableRaster ( w , h ) ; int [ ] data = new int [ w * h * 4 ] ; float nx = tx2 - tx1 ; float ny = ty2 - ty1 ; float len = ( float ) Math . sqrt ( nx * nx + ny * ny ) ; if ( len != 0 ) { nx /= len ; ny /= len ; } int span = ( int ) PApplet . dist ( tx1 , ty1 , tx2 , ty2 ) * ACCURACY ; if ( span <= 0 ) { int index = 0 ; for ( int j = 0 ; j < h ; j ++ ) { for ( int i = 0 ; i < w ; i ++ ) { data [ index ++ ] = 0 ; data [ index ++ ] = 0 ; data [ index ++ ] = 0 ; data [ index ++ ] = 255 ; } } } else { int [ ] [ ] interp = new int [ span ] [ 4 ] ; int prev = 0 ; for ( int i = 1 ; i < count ; i ++ ) { int c0 = color [ i - 1 ] ; int c1 = color [ i ] ; int last = ( int ) ( offset [ i ] * ( span - 1 ) ) ; for ( int j = prev ; j <= last ; j ++ ) { float btwn = PApplet . norm ( j , prev , last ) ; interp [ j ] [ 0 ] = ( int ) PApplet . lerp ( ( c0 > > 16 ) & 0xff , ( c1 > > 16 ) & 0xff , btwn ) ; interp [ j ] [ 1 ] = ( int ) PApplet . lerp ( ( c0 > > 8 ) & 0xff , ( c1 > > 8 ) & 0xff , btwn ) ; interp [ j ] [ 2 ] = ( int ) PApplet . lerp ( c0 & 0xff , c1 & 0xff , btwn ) ; interp [ j ] [ 3 ] = ( int ) ( PApplet . lerp ( ( c0 > > 24 ) & 0xff , ( c1 > > 24 ) & 0xff , btwn ) * opacity ) ; } prev = last ; } int index = 0 ; for ( int j = 0 ; j < h ; j ++ ) { for ( int i = 0 ; i < w ; i ++ ) { float px = ( x + i ) - tx1 ; float py = ( y + j ) - ty1 ; int which = ( int ) ( ( px * nx + py * ny ) * ACCURACY ) ; if ( which < 0 ) which = 0 ; if ( which > interp . length - 1 ) which = interp . length - 1 ; data [ index ++ ] = interp [ which ] [ 0 ] ; data [ index ++ ] = interp [ which ] [ 1 ] ; data [ index ++ ] = interp [ which ] [ 2 ] ; data [ index ++ ] = interp [ which ] [ 3 ] ; } } } raster . setPixels ( 0 , 0 , w , h , data ) ; return raster ; } } } static class RadialGradientPaint implements Paint { float cx , cy , radius ; float [ ] offset ; int [ ] color ; int count ; float opacity ; public RadialGradientPaint ( float cx , float cy , float radius , float [ ] offset , int [ ] color , int count , float opacity ) { this . cx = cx ; this . cy = cy ; this . radius = radius ; this . offset = offset ; this . color = color ; this . count = count ; this . opacity = opacity ; } public PaintContext createContext ( ColorModel cm , Rectangle deviceBounds , Rectangle2D userBounds , AffineTransform xform , RenderingHints hints ) { return new RadialGradientContext ( ) ; } public int getTransparency ( ) { return TRANSLUCENT ; } public class RadialGradientContext implements PaintContext { int ACCURACY = 5 ; public void dispose ( ) { } public ColorModel getColorModel ( ) { return ColorModel . getRGBdefault ( ) ; } public Raster getRaster ( int x , int y , int w , int h ) { WritableRaster raster = getColorModel ( ) . createCompatibleWritableRaster ( w , h ) ; int span = ( int ) radius * ACCURACY ; int [ ] [ ] interp = new int [ span ] [ 4 ] ; int prev = 0 ; for ( int i = 1 ; i < count ; i ++ ) { int c0 = color [ i - 1 ] ; int c1 = color [ i ] ; int last = ( int ) ( offset [ i ] * ( span - 1 ) ) ; for ( int j = prev ; j <= last ; j ++ ) { float btwn = PApplet . norm ( j , prev , last ) ; interp [ j ] [ 0 ] = ( int ) PApplet . lerp ( ( c0 > > 16 ) & 0xff , ( c1 > > 16 ) & 0xff , btwn ) ; interp [ j ] [ 1 ] = ( int ) PApplet . lerp ( ( c0 > > 8 ) & 0xff , ( c1 > > 8 ) & 0xff , btwn ) ; interp [ j ] [ 2 ] = ( int ) PApplet . lerp ( c0 & 0xff , c1 & 0xff , btwn ) ; interp [ j ] [ 3 ] = ( int ) ( PApplet . lerp ( ( c0 > > 24 ) & 0xff , ( c1 > > 24 ) & 0xff , btwn ) * opacity ) ; } prev = last ; } int [ ] data = new int [ w * h * 4 ] ; int index = 0 ; for ( int j = 0 ; j < h ; j ++ ) { for ( int i = 0 ; i < w ; i ++ ) { float distance = PApplet . dist ( cx , cy , x + i , y + j ) ; int which = PApplet . min ( ( int ) ( distance * ACCURACY ) , interp . length - 1 ) ; data [ index ++ ] = interp [ which ] [ 0 ] ; data [ index ++ ] = interp [ which ] [ 1 ] ; data [ index ++ ] = interp [ which ] [ 2 ] ; data [ index ++ ] = interp [ which ] [ 3 ] ; } } raster . setPixels ( 0 , 0 , w , h , data ) ; return raster ; } } } protected Paint calcGradientPaint ( Gradient gradient ) { if ( gradient instanceof LinearGradient ) { LinearGradient grad = ( LinearGradient ) gradient ; return new LinearGradientPaint ( grad . x1 , grad . y1 , grad . x2 , grad . y2 , grad . offset , grad . color , grad . count , opacity ) ; } else if ( gradient instanceof RadialGradient ) { RadialGradient grad = ( RadialGradient ) gradient ; return new RadialGradientPaint ( grad . cx , grad . cy , grad . r , grad . offset , grad . color , grad . count , opacity ) ; } return null ; } @ Override protected void styles ( PGraphics g ) { super . styles ( g ) ; if ( g instanceof PGraphicsJava2D ) { PGraphicsJava2D p2d = ( PGraphicsJava2D ) g ; if ( strokeGradient != null ) { p2d . strokeGradient = true ; p2d . strokeGradientObject = strokeGradientPaint ; } else { } if ( fillGradient != null ) { p2d . fillGradient = true ; p2d . fillGradientObject = fillGradientPaint ; } else { } } } public static class Font extends PShapeSVG { public FontFace face ; public HashMap < String , FontGlyph > namedGlyphs ; public HashMap < Character , FontGlyph > unicodeGlyphs ; public int glyphCount ; public FontGlyph [ ] glyphs ; public FontGlyph missingGlyph ; int horizAdvX ; public Font ( PShapeSVG parent , XML properties ) { super ( parent , properties , false ) ; XML [ ] elements = properties . getChildren ( ) ; horizAdvX = properties . getInt ( "horiz-adv-x" , 0 ) ; namedGlyphs = new HashMap < String , FontGlyph > ( ) ; unicodeGlyphs = new HashMap < Character , FontGlyph > ( ) ; glyphCount = 0 ; glyphs = new FontGlyph [ elements . length ] ; for ( int i = 0 ; i < elements . length ; i ++ ) { String name = elements [ i ] . getName ( ) ; XML elem = elements [ i ] ; if ( name == null ) { } else if ( name . equals ( "glyph" ) ) { FontGlyph fg = new FontGlyph ( this , elem , this ) ; if ( fg . isLegit ( ) ) { if ( fg . name != null ) { namedGlyphs . put ( fg . name , fg ) ; } if ( fg . unicode != 0 ) { unicodeGlyphs . put ( Character . valueOf ( fg . unicode ) , fg ) ; } } glyphs [ glyphCount ++ ] = fg ; } else if ( name . equals ( "missing-glyph" ) ) { missingGlyph = new FontGlyph ( this , elem , this ) ; } else if ( name . equals ( "font-face" ) ) { face = new FontFace ( this , elem ) ; } else { System . err . println ( "Ignoring " + name + " inside <font>" ) ; } } } protected void drawShape ( ) { } public void drawString ( PGraphics g , String str , float x , float y , float size ) { g . pushMatrix ( ) ; float s = size / face . unitsPerEm ; g . translate ( x , y ) ; g . scale ( s , - s ) ; char [ ] c = str . toCharArray ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { FontGlyph fg = unicodeGlyphs . get ( Character . valueOf ( c [ i ] ) ) ; if ( fg != null ) { fg . draw ( g ) ; g . translate ( fg . horizAdvX , 0 ) ; } else { System . err . println ( "'" + c [ i ] + "' not available." ) ; } } g . popMatrix ( ) ; } public void drawChar ( PGraphics g , char c , float x , float y , float size ) { g . pushMatrix ( ) ; float s = size / face . unitsPerEm ; g . translate ( x , y ) ; g . scale ( s , - s ) ; FontGlyph fg = unicodeGlyphs . get ( Character . valueOf ( c ) ) ; if ( fg != null ) g . shape ( fg ) ; g . popMatrix ( ) ; } public float textWidth ( String str , float size ) { float w = 0 ; char [ ] c = str . toCharArray ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { FontGlyph fg = unicodeGlyphs . get ( Character . valueOf ( c [ i ] ) ) ; if ( fg != null ) { w += ( float ) fg . horizAdvX / face . unitsPerEm ; } } return w * size ; } } static class FontFace extends PShapeSVG { int horizOriginX ; int horizOriginY ; int vertOriginX ; int vertOriginY ; int vertAdvY ; String fontFamily ; int fontWeight ; String fontStretch ; int unitsPerEm ; int [ ] panose1 ; int ascent ; int descent ; int [ ] bbox ; int underlineThickness ; int underlinePosition ; public FontFace ( PShapeSVG parent , XML properties ) { super ( parent , properties , true ) ; unitsPerEm = properties . getInt ( "units-per-em" , 1000 ) ; } protected void drawShape ( ) { } } public static class FontGlyph extends PShapeSVG { public String name ; char unicode ; int horizAdvX ; public FontGlyph ( PShapeSVG parent , XML properties , Font font ) { super ( parent , properties , true ) ; super . parsePath ( ) ; name = properties . getString ( "glyph-name" ) ; String u = properties . getString ( "unicode" ) ; unicode = 0 ; if ( u != null ) { if ( u . length ( ) == 1 ) { unicode = u . charAt ( 0 ) ; } else { System . err . println ( "unicode for " + name + " is more than one char: " + u ) ; } } if ( properties . hasAttribute ( "horiz-adv-x" ) ) { horizAdvX = properties . getInt ( "horiz-adv-x" ) ; } else { horizAdvX = font . horizAdvX ; } } protected boolean isLegit ( ) { return vertexCount != 0 ; } } @ Override public PShape getChild ( String name ) { PShape found = super . getChild ( name ) ; if ( found == null ) { found = super . getChild ( name . replace ( ' ' , '_' ) ) ; } if ( found != null ) { found . width = this . width ; found . height = this . height ; } return found ; } public void print ( ) { PApplet . println ( element . toString ( ) ) ; } }
package processing . app ; import java . awt . BorderLayout ; import java . awt . Color ; import java . awt . Dimension ; import java . awt . Font ; import java . awt . FontMetrics ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . Image ; import java . awt . event . * ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import javax . swing . Box ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . JPopupMenu ; abstract public class EditorToolbar extends JPanel { static final int HIGH = 53 ; static final int GAP = 9 ; static final int RADIUS = 3 ; protected Editor editor ; protected Base base ; protected Mode mode ; protected EditorButton runButton ; protected EditorButton stopButton ; protected Box box ; protected JLabel label ; protected Image gradient ; public EditorToolbar ( Editor editor ) { this . editor = editor ; base = editor . getBase ( ) ; mode = editor . getMode ( ) ; gradient = mode . makeGradient ( "toolbar" , 400 , HIGH ) ; rebuild ( ) ; } public void rebuild ( ) { removeAll ( ) ; List < EditorButton > buttons = createButtons ( ) ; box = Box . createHorizontalBox ( ) ; box . add ( Box . createHorizontalStrut ( Editor . LEFT_GUTTER ) ) ; label = new JLabel ( ) ; label . setFont ( mode . getFont ( "toolbar.rollover.font" ) ) ; label . setForeground ( mode . getColor ( "toolbar.rollover.color" ) ) ; for ( EditorButton button : buttons ) { box . add ( button ) ; box . add ( Box . createHorizontalStrut ( GAP ) ) ; button . setRolloverLabel ( label ) ; } box . add ( label ) ; box . add ( Box . createHorizontalGlue ( ) ) ; addModeButtons ( box ) ; ModeSelector ms = new ModeSelector ( ) ; box . add ( ms ) ; box . add ( Box . createHorizontalStrut ( Editor . RIGHT_GUTTER ) ) ; setLayout ( new BorderLayout ( ) ) ; add ( box , BorderLayout . CENTER ) ; } public void paintComponent ( Graphics g ) { Dimension size = getSize ( ) ; g . drawImage ( gradient , 0 , 0 , size . width , size . height , this ) ; } public List < EditorButton > createButtons ( ) { runButton = new EditorButton ( mode , "/lib/toolbar/run" , Language . text ( "toolbar.run" ) , Language . text ( "toolbar.present" ) ) { @ Override public void actionPerformed ( ActionEvent e ) { handleRun ( e . getModifiers ( ) ) ; } } ; stopButton = new EditorButton ( mode , "/lib/toolbar/stop" , Language . text ( "toolbar.stop" ) ) { @ Override public void actionPerformed ( ActionEvent e ) { handleStop ( ) ; } } ; return new ArrayList < > ( Arrays . asList ( runButton , stopButton ) ) ; } public void addModeButtons ( Box box ) { } public void addGap ( Box box ) { box . add ( Box . createHorizontalStrut ( GAP ) ) ; } public void activateRun ( ) { runButton . setSelected ( true ) ; repaint ( ) ; } public void deactivateRun ( ) { runButton . setSelected ( false ) ; repaint ( ) ; } public void activateStop ( ) { stopButton . setSelected ( true ) ; repaint ( ) ; } public void deactivateStop ( ) { stopButton . setSelected ( false ) ; repaint ( ) ; } abstract public void handleRun ( int modifiers ) ; abstract public void handleStop ( ) ; public Dimension getPreferredSize ( ) { return new Dimension ( super . getPreferredSize ( ) . width , HIGH ) ; } public Dimension getMinimumSize ( ) { return new Dimension ( super . getMinimumSize ( ) . width , HIGH ) ; } public Dimension getMaximumSize ( ) { return new Dimension ( super . getMaximumSize ( ) . width , HIGH ) ; } class ModeSelector extends JPanel { Image offscreen ; int width , height ; String title ; Font titleFont ; Color titleColor ; int titleAscent ; int titleWidth ; final int MODE_GAP_WIDTH = 13 ; final int ARROW_GAP_WIDTH = 6 ; final int ARROW_WIDTH = 6 ; final int ARROW_TOP = 12 ; final int ARROW_BOTTOM = 18 ; int [ ] triangleX = new int [ 3 ] ; int [ ] triangleY = new int [ ] { ARROW_TOP , ARROW_TOP , ARROW_BOTTOM } ; Color backgroundColor ; Color outlineColor ; @ SuppressWarnings ( "deprecation" ) public ModeSelector ( ) { title = mode . getTitle ( ) ; titleFont = mode . getFont ( "mode.title.font" ) ; titleColor = mode . getColor ( "mode.title.color" ) ; titleWidth = getToolkit ( ) . getFontMetrics ( titleFont ) . stringWidth ( title ) ; addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent event ) { JPopupMenu popup = editor . getModeMenu ( ) . getPopupMenu ( ) ; popup . show ( ModeSelector . this , event . getX ( ) , event . getY ( ) ) ; } } ) ; backgroundColor = mode . getColor ( "mode.background.color" ) ; outlineColor = mode . getColor ( "mode.outline.color" ) ; } @ Override public void paintComponent ( Graphics screen ) { Dimension size = getSize ( ) ; width = 0 ; if ( width != size . width || height != size . height ) { if ( Toolkit . highResDisplay ( ) ) { offscreen = createImage ( size . width * 2 , size . height * 2 ) ; } else { offscreen = createImage ( size . width , size . height ) ; } width = size . width ; height = size . height ; } Graphics g = offscreen . getGraphics ( ) ; Graphics2D g2 = Toolkit . prepareGraphics ( g ) ; g . setFont ( titleFont ) ; if ( titleAscent == 0 ) { titleAscent = ( int ) Toolkit . getAscent ( g ) ; } FontMetrics metrics = g . getFontMetrics ( ) ; titleWidth = metrics . stringWidth ( title ) ; g . setColor ( backgroundColor ) ; g . fillRect ( 0 , 0 , width , height ) ; g . setColor ( outlineColor ) ; g2 . draw ( Toolkit . createRoundRect ( 1 , 1 , width - 1 , height - 1 , RADIUS , RADIUS , RADIUS , RADIUS ) ) ; g . setColor ( titleColor ) ; g . drawString ( title , MODE_GAP_WIDTH , ( height + titleAscent ) / 2 ) ; int x = MODE_GAP_WIDTH + titleWidth + ARROW_GAP_WIDTH ; triangleX [ 0 ] = x ; triangleX [ 1 ] = x + ARROW_WIDTH ; triangleX [ 2 ] = x + ARROW_WIDTH / 2 ; g . fillPolygon ( triangleX , triangleY , 3 ) ; screen . drawImage ( offscreen , 0 , 0 , width , height , this ) ; } @ Override public Dimension getPreferredSize ( ) { return new Dimension ( MODE_GAP_WIDTH + titleWidth + ARROW_GAP_WIDTH + ARROW_WIDTH + MODE_GAP_WIDTH , EditorButton . DIM ) ; } @ Override public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } @ Override public Dimension getMaximumSize ( ) { return getPreferredSize ( ) ; } } }
package processing . app ; import java . awt . EventQueue ; import java . awt . FileDialog ; import java . awt . Frame ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . io . * ; import java . text . SimpleDateFormat ; import java . util . * ; import java . util . zip . * ; import javax . swing . JDialog ; import javax . swing . JFileChooser ; import javax . swing . JFrame ; import javax . swing . JMenu ; import javax . swing . JMenuItem ; import javax . swing . JOptionPane ; import javax . swing . JPopupMenu ; import javax . swing . tree . DefaultMutableTreeNode ; import processing . app . contrib . * ; import processing . core . * ; public class Base { static private final int REVISION = 238 ; static private String VERSION_NAME = "0238" ; static public boolean DEBUG = false ; static HashMap < Integer , String > platformNames = new HashMap < Integer , String > ( ) ; static { platformNames . put ( PConstants . WINDOWS , "windows" ) ; platformNames . put ( PConstants . MACOSX , "macosx" ) ; platformNames . put ( PConstants . LINUX , "linux" ) ; } static HashMap < String , Integer > platformIndices = new HashMap < String , Integer > ( ) ; static { platformIndices . put ( "windows" , PConstants . WINDOWS ) ; platformIndices . put ( "macosx" , PConstants . MACOSX ) ; platformIndices . put ( "linux" , PConstants . LINUX ) ; } static Platform platform ; static int nativeBits ; static { nativeBits = 32 ; String bits = System . getProperty ( "sun.arch.data.model" ) ; if ( bits != null ) { if ( bits . equals ( "64" ) ) { nativeBits = 64 ; } } else { if ( System . getProperty ( "java.vm.name" ) . contains ( "64" ) ) { nativeBits = 64 ; } } } static private boolean commandLine ; PreferencesFrame preferencesFrame ; ContributionManagerDialog libraryManagerFrame ; ContributionManagerDialog toolManagerFrame ; ContributionManagerDialog modeManagerFrame ; ContributionManagerDialog exampleManagerFrame ; ContributionManagerDialog updateManagerFrame ; static File untitledFolder ; protected List < Editor > editors = Collections . synchronizedList ( new ArrayList < Editor > ( ) ) ; protected Editor activeEditor ; static public JMenu defaultFileMenu ; private Mode nextMode ; private Mode [ ] coreModes ; protected ArrayList < ModeContribution > modeContribs ; protected ArrayList < ExamplesContribution > exampleContribs ; private JMenu sketchbookMenu ; private Recent recent ; private JFileChooser openChooser ; static protected File sketchbookFolder ; static public void main ( final String [ ] args ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { createAndShowGUI ( args ) ; } catch ( Throwable t ) { showBadnessTrace ( "It was not meant to be" , "A serious problem happened during startup. Please report:\n" + "http://github.com/processing/processing/issues/new" , t , true ) ; } } } ) ; } static private void createAndShowGUI ( String [ ] args ) { try { File versionFile = getContentFile ( "lib/version.txt" ) ; if ( versionFile . exists ( ) ) { String version = PApplet . loadStrings ( versionFile ) [ 0 ] ; if ( ! version . equals ( VERSION_NAME ) ) { VERSION_NAME = version ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } initPlatform ( ) ; JPopupMenu . setDefaultLightWeightPopupEnabled ( false ) ; Language . init ( ) ; Preferences . init ( ) ; locateSketchbookFolder ( ) ; if ( ! SingleInstance . alreadyRunning ( args ) ) { try { platform . setLookAndFeel ( ) ; } catch ( Exception e ) { loge ( "Could not set the Look & Feel" , e ) ; } try { untitledFolder = Base . createTempFolder ( "untitled" , "sketches" , null ) ; untitledFolder . deleteOnExit ( ) ; } catch ( IOException e ) { Base . showError ( "Trouble without a name" , "Could not create a place to store untitled sketches.\n" + "That's gonna prevent us from continuing." , e ) ; } log ( "about to create base..." ) ; try { Base base = new Base ( args ) ; SingleInstance . startServer ( base ) ; } catch ( Throwable t ) { showBadnessTrace ( "We're off on the wrong foot" , "An error occurred during startup." , t , true ) ; } log ( "done creating base..." ) ; } } public static void setCommandLine ( ) { commandLine = true ; } static protected boolean isCommandLine ( ) { return commandLine ; } static public void initPlatform ( ) { try { Class < ? > platformClass = Class . forName ( "processing.app.Platform" ) ; if ( Base . isMacOS ( ) ) { platformClass = Class . forName ( "processing.app.platform.MacPlatform" ) ; } else if ( Base . isWindows ( ) ) { platformClass = Class . forName ( "processing.app.platform.WindowsPlatform" ) ; } else if ( Base . isLinux ( ) ) { platformClass = Class . forName ( "processing.app.platform.LinuxPlatform" ) ; } platform = ( Platform ) platformClass . newInstance ( ) ; } catch ( Exception e ) { Base . showError ( "Problem Setting the Platform" , "An unknown error occurred while trying to load\n" + "platform-specific code for your machine." , e ) ; } } private String getDefaultModeIdentifier ( ) { return "processing.mode.java.JavaMode" ; } private void buildCoreModes ( ) { Mode javaMode = ModeContribution . load ( this , getContentFile ( "modes/java" ) , getDefaultModeIdentifier ( ) ) . getMode ( ) ; coreModes = new Mode [ ] { javaMode } ; } void rebuildContribModes ( ) { if ( modeContribs == null ) { modeContribs = new ArrayList < ModeContribution > ( ) ; } ModeContribution . loadMissing ( this ) ; } void rebuildContribExamples ( ) { if ( exampleContribs == null ) { exampleContribs = new ArrayList < ExamplesContribution > ( ) ; } ExamplesContribution . loadMissing ( this ) ; } public Base ( String [ ] args ) throws Exception { ContributionManager . cleanup ( this ) ; buildCoreModes ( ) ; rebuildContribModes ( ) ; rebuildContribExamples ( ) ; recent = new Recent ( this ) ; String lastModeIdentifier = Preferences . get ( "mode.last" ) ; if ( lastModeIdentifier == null ) { nextMode = getDefaultMode ( ) ; log ( "Nothing set for last.sketch.mode, using default." ) ; } else { for ( Mode m : getModeList ( ) ) { if ( m . getIdentifier ( ) . equals ( lastModeIdentifier ) ) { logf ( "Setting next mode to %s." , lastModeIdentifier ) ; nextMode = m ; } } if ( nextMode == null ) { nextMode = getDefaultMode ( ) ; logf ( "Could not find mode %s, using default." , lastModeIdentifier ) ; } } libraryManagerFrame = new ContributionManagerDialog ( ContributionType . LIBRARY ) ; toolManagerFrame = new ContributionManagerDialog ( ContributionType . TOOL ) ; modeManagerFrame = new ContributionManagerDialog ( ContributionType . MODE ) ; exampleManagerFrame = new ContributionManagerDialog ( ContributionType . EXAMPLES ) ; updateManagerFrame = new ContributionManagerDialog ( null ) ; nextMode . rebuildLibraryList ( ) ; platform . init ( this ) ; boolean opened = false ; for ( int i = 0 ; i < args . length ; i ++ ) { String path = args [ i ] ; if ( isWindows ( ) ) { try { File file = new File ( args [ i ] ) ; path = file . getCanonicalPath ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( handleOpen ( path ) != null ) { opened = true ; } } if ( ! opened ) { handleNew ( ) ; } if ( Preferences . getBoolean ( "update.check" ) ) { new UpdateCheck ( this ) ; } } public Editor getActiveEditor ( ) { return activeEditor ; } public List < Editor > getEditors ( ) { return editors ; } protected void changeMode ( Mode mode ) { if ( activeEditor . getMode ( ) != mode ) { Sketch sketch = activeEditor . getSketch ( ) ; nextMode = mode ; if ( sketch . isUntitled ( ) ) { handleClose ( activeEditor , true ) ; handleNew ( ) ; } else { boolean newModeCanHandleCurrentSource = true ; for ( final SketchCode code : sketch . getCode ( ) ) { if ( ! mode . validExtension ( code . getExtension ( ) ) ) { newModeCanHandleCurrentSource = false ; break ; } } if ( newModeCanHandleCurrentSource ) { final File props = new File ( sketch . getCodeFolder ( ) , "sketch.properties" ) ; saveModeSettings ( props , nextMode ) ; handleClose ( activeEditor , true ) ; handleOpen ( sketch . getMainFilePath ( ) ) ; } } } } public List < ModeContribution > getModeContribs ( ) { return modeContribs ; } public List < Mode > getModeList ( ) { ArrayList < Mode > allModes = new ArrayList < Mode > ( ) ; allModes . addAll ( Arrays . asList ( coreModes ) ) ; if ( modeContribs != null ) { for ( ModeContribution contrib : modeContribs ) { allModes . add ( contrib . getMode ( ) ) ; } } return allModes ; } public List < ExamplesContribution > getExampleContribs ( ) { return exampleContribs ; } protected void handleActivated ( Editor whichEditor ) { activeEditor = whichEditor ; EditorConsole . setEditor ( activeEditor ) ; nextMode = whichEditor . getMode ( ) ; Preferences . set ( "mode.last" , nextMode . getIdentifier ( ) ) ; } boolean breakTime = false ; String [ ] months = { "jan" , "feb" , "mar" , "apr" , "may" , "jun" , "jul" , "aug" , "sep" , "oct" , "nov" , "dec" } ; public void handleNew ( ) { try { File newbieDir = null ; String newbieName = null ; File newbieParentDir = untitledFolder ; String prefix = Preferences . get ( "editor.untitled.prefix" ) ; int index = 0 ; String format = Preferences . get ( "editor.untitled.suffix" ) ; String suffix = null ; if ( format == null ) { Calendar cal = Calendar . getInstance ( ) ; int day = cal . get ( Calendar . DAY_OF_MONTH ) ; int month = cal . get ( Calendar . MONTH ) ; suffix = months [ month ] + PApplet . nf ( day , 2 ) ; } else { SimpleDateFormat formatter = new SimpleDateFormat ( format ) ; suffix = formatter . format ( new Date ( ) ) ; } do { if ( index == 26 ) { if ( ! breakTime ) { Base . showWarning ( "Time for a Break" , "You've reached the limit for auto naming of new sketches\n" + "for the day. How about going for a walk instead?" , null ) ; breakTime = true ; } else { Base . showWarning ( "Sunshine" , "No really, time for some fresh air for you." , null ) ; } return ; } newbieName = prefix + suffix + ( ( char ) ( 'a' + index ) ) ; newbieName = Sketch . sanitizeName ( newbieName ) ; newbieDir = new File ( newbieParentDir , newbieName ) ; index ++ ; } while ( newbieDir . exists ( ) || new File ( sketchbookFolder , newbieName ) . exists ( ) ) ; newbieDir . mkdirs ( ) ; File newbieFile = new File ( newbieDir , newbieName + "." + nextMode . getDefaultExtension ( ) ) ; if ( ! newbieFile . createNewFile ( ) ) { throw new IOException ( newbieFile + " already exists." ) ; } if ( ! nextMode . equals ( getDefaultMode ( ) ) ) { saveModeSettings ( new File ( newbieDir , "sketch.properties" ) , nextMode ) ; } String path = newbieFile . getAbsolutePath ( ) ; handleOpen ( path , true ) ; } catch ( IOException e ) { Base . showWarning ( "That's new to me" , "A strange and unexplainable error occurred\n" + "while trying to create a new sketch." , e ) ; } } private void saveModeSettings ( final File sketchProps , final Mode mode ) { try { final Settings settings = new Settings ( sketchProps ) ; settings . set ( "mode" , mode . getTitle ( ) ) ; settings . set ( "mode.id" , mode . getIdentifier ( ) ) ; settings . save ( ) ; } catch ( IOException e ) { System . err . println ( "While creating " + sketchProps + ": " + e . getMessage ( ) ) ; } } public Mode getDefaultMode ( ) { return coreModes [ 0 ] ; } public Mode getNextMode ( ) { return nextMode ; } public void handleOpenPrompt ( ) { final ArrayList < String > extensions = new ArrayList < String > ( ) ; for ( Mode mode : getModeList ( ) ) { extensions . add ( mode . getDefaultExtension ( ) ) ; } final String prompt = Language . text ( "open" ) ; if ( Preferences . getBoolean ( "chooser.files.native" ) ) { FileDialog openDialog = new FileDialog ( activeEditor , prompt , FileDialog . LOAD ) ; openDialog . setFilenameFilter ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { for ( String ext : extensions ) { if ( name . toLowerCase ( ) . endsWith ( "." + ext ) ) { return true ; } } return false ; } } ) ; openDialog . setVisible ( true ) ; String directory = openDialog . getDirectory ( ) ; String filename = openDialog . getFile ( ) ; if ( filename != null ) { File inputFile = new File ( directory , filename ) ; handleOpen ( inputFile . getAbsolutePath ( ) ) ; } } else { if ( openChooser == null ) { openChooser = new JFileChooser ( ) ; } openChooser . setDialogTitle ( prompt ) ; openChooser . setFileFilter ( new javax . swing . filechooser . FileFilter ( ) { public boolean accept ( File file ) { if ( file . isDirectory ( ) ) { return true ; } for ( String ext : extensions ) { if ( file . getName ( ) . toLowerCase ( ) . endsWith ( "." + ext ) ) { return true ; } } return false ; } public String getDescription ( ) { return "Processing Sketch" ; } } ) ; if ( openChooser . showOpenDialog ( activeEditor ) == JFileChooser . APPROVE_OPTION ) { handleOpen ( openChooser . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } } } public Editor handleOpen ( String path ) { return handleOpen ( path , false ) ; } public Editor handleOpen ( String path , boolean untitled ) { return handleOpen ( path , untitled , new EditorState ( editors ) ) ; } protected Editor handleOpen ( String path , boolean untitled , EditorState state ) { try { final File file = new File ( path ) ; if ( ! file . exists ( ) ) { return null ; } for ( Editor editor : editors ) { for ( SketchCode tab : editor . getSketch ( ) . getCode ( ) ) { if ( tab . getFile ( ) . equals ( file ) ) { editor . toFront ( ) ; handleRecent ( editor ) ; return editor ; } } } if ( ! Sketch . isSanitaryName ( file . getName ( ) ) ) { Base . showWarning ( "You're tricky, but not tricky enough" , file . getName ( ) + " is not a valid name for a sketch.\n" + "Better to stick to ASCII, no spaces, and make sure\n" + "it doesn't start with a number." , null ) ; return null ; } if ( ! nextMode . canEdit ( file ) ) { final Mode mode = selectMode ( file ) ; if ( mode == null ) { return null ; } nextMode = mode ; } Editor editor = null ; try { editor = nextMode . createEditor ( this , path , state ) ; } catch ( NoSuchMethodError nsme ) { Base . showWarning ( "Mode out of date" , nextMode . getTitle ( ) + " is not compatible with this version of Processing.\n" + "Try updating the Mode or contact its author for a new version." , nsme ) ; } catch ( Throwable t ) { showBadnessTrace ( "Mode Problems" , "A nasty error occurred while trying to use " + nextMode . getTitle ( ) + ".\n" + "It may not be compatible with this version of Processing.\n" + "Try updating the Mode or contact its author for a new version." , t , false ) ; } if ( editor == null ) { Mode defaultMode = getDefaultMode ( ) ; if ( nextMode == defaultMode ) { Base . showError ( "Editor Problems" , "An error occurred while trying to change modes.\n" + "We'll have to quit for now because it's an\n" + "unfortunate bit of indigestion with the default Mode." , null ) ; } else { editor = defaultMode . createEditor ( this , path , state ) ; } } Sketch sketch = editor . getSketch ( ) ; if ( sketch == null ) { return null ; } sketch . setUntitled ( untitled ) ; editors . add ( editor ) ; handleRecent ( editor ) ; editor . setVisible ( true ) ; return editor ; } catch ( Throwable t ) { showBadnessTrace ( "Terrible News" , "A serious error occurred while " + "trying to create a new editor window." , t , nextMode == getDefaultMode ( ) ) ; nextMode = getDefaultMode ( ) ; return null ; } } private static class ModeInfo { public final String title ; public final String id ; public ModeInfo ( String id , String title ) { this . id = id ; this . title = title ; } } private static ModeInfo modeInfoFor ( final File sketch ) { final File sketchFolder = sketch . getParentFile ( ) ; final File sketchProps = new File ( sketchFolder , "sketch.properties" ) ; if ( ! sketchProps . exists ( ) ) { return null ; } try { final Settings settings = new Settings ( sketchProps ) ; final String title = settings . get ( "mode" ) ; final String id = settings . get ( "mode.id" ) ; if ( title == null || id == null ) { return null ; } return new ModeInfo ( id , title ) ; } catch ( IOException e ) { System . err . println ( "While trying to read " + sketchProps + ": " + e . getMessage ( ) ) ; } return null ; } private Mode promptForMode ( final File sketch , final ModeInfo preferredMode ) { final String extension = sketch . getName ( ) . substring ( sketch . getName ( ) . lastIndexOf ( '.' ) + 1 ) ; final List < Mode > possibleModes = new ArrayList < Mode > ( ) ; for ( final Mode mode : getModeList ( ) ) { if ( mode . canEdit ( sketch ) ) { possibleModes . add ( mode ) ; } } if ( possibleModes . size ( ) == 1 && possibleModes . get ( 0 ) . getIdentifier ( ) . equals ( getDefaultModeIdentifier ( ) ) ) { return possibleModes . get ( 0 ) ; } if ( possibleModes . size ( ) == 0 ) { if ( preferredMode == null ) { Base . showWarning ( "Modeless Dialog" , "I don't know how to open a sketch with the \"" + extension + "\"\nfile extension. You'll have to install a different" + "\nProcessing mode for that." ) ; } else { Base . showWarning ( "Modeless Dialog" , "You'll have to install " + preferredMode . title + " Mode " + "\nin order to open that sketch." ) ; } return null ; } final Mode [ ] modes = possibleModes . toArray ( new Mode [ possibleModes . size ( ) ] ) ; final String message = preferredMode == null ? ( nextMode . getTitle ( ) + " Mode can't open ." + extension + " files, " + "but you have one or more modes\ninstalled that can. " + "Would you like to try one?" ) : ( "That's a " + preferredMode . title + " Mode sketch, " + "but you don't have " + preferredMode . title + " installed.\n" + "Would you like to try a different mode for opening a " + "." + extension + " sketch?" ) ; return ( Mode ) JOptionPane . showInputDialog ( null , message , "Choose Wisely" , JOptionPane . QUESTION_MESSAGE , null , modes , modes [ 0 ] ) ; } private Mode selectMode ( final File sketch ) { final ModeInfo modeInfo = modeInfoFor ( sketch ) ; final Mode specifiedMode = modeInfo == null ? null : findMode ( modeInfo . id ) ; if ( specifiedMode != null ) { return specifiedMode ; } return promptForMode ( sketch , modeInfo ) ; } protected Mode findMode ( String id ) { for ( Mode mode : getModeList ( ) ) { if ( mode . getIdentifier ( ) . equals ( id ) ) { return mode ; } } return null ; } public boolean handleClose ( Editor editor , boolean modeSwitch ) { if ( ! editor . checkModified ( ) ) { return false ; } editor . internalCloseRunner ( ) ; if ( editors . size ( ) == 1 ) { if ( Base . isMacOS ( ) ) { if ( defaultFileMenu == null ) { Object [ ] options = { Language . text ( "prompt.ok" ) , Language . text ( "prompt.cancel" ) } ; String prompt = "<html> " + "<head> <style type=\"text/css\">" + "b { font: 13pt \"Lucida Grande\" }" + "p { font: 11pt \"Lucida Grande\"; margin-top: 8px; width: 300px }" + "</style> </head>" + "<b>Are you sure you want to Quit?</b>" + "<p>Closing the last open sketch will quit Processing." ; int result = JOptionPane . showOptionDialog ( editor , prompt , "Quit" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , options [ 0 ] ) ; if ( result == JOptionPane . NO_OPTION || result == JOptionPane . CLOSED_OPTION ) { return false ; } } } Preferences . unset ( "server.port" ) ; Preferences . unset ( "server.key" ) ; editors . remove ( editor ) ; Preferences . save ( ) ; if ( defaultFileMenu == null ) { if ( modeSwitch ) { editor . setVisible ( false ) ; editor . dispose ( ) ; activeEditor = null ; editors . remove ( editor ) ; } else { System . exit ( 0 ) ; } } else { editor . setVisible ( false ) ; editor . dispose ( ) ; defaultFileMenu . insert ( getRecentMenu ( ) , 2 ) ; activeEditor = null ; editors . remove ( editor ) ; } } else { editor . setVisible ( false ) ; editor . dispose ( ) ; editors . remove ( editor ) ; } return true ; } public boolean handleQuit ( ) { if ( handleQuitEach ( ) ) { for ( Editor editor : editors ) { editor . internalCloseRunner ( ) ; } Preferences . save ( ) ; if ( ! Base . isMacOS ( ) ) { System . exit ( 0 ) ; } return true ; } return false ; } protected boolean handleQuitEach ( ) { for ( Editor editor : editors ) { if ( ! editor . checkModified ( ) ) { return false ; } } return true ; } protected void rebuildSketchbookMenusAsync ( ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { rebuildSketchbookMenus ( ) ; } } ) ; } public void thinkDifferentExamples ( ) { nextMode . showExamplesFrame ( ) ; } protected void rebuildSketchbookMenus ( ) { for ( Mode mode : getModeList ( ) ) { mode . rebuildImportMenu ( ) ; mode . rebuildToolbarMenu ( ) ; mode . rebuildExamplesFrame ( ) ; mode . rebuildSketchbookFrame ( ) ; } } protected void rebuildSketchbookMenu ( ) { sketchbookMenu . removeAll ( ) ; populateSketchbookMenu ( sketchbookMenu ) ; } public void populateSketchbookMenu ( JMenu menu ) { boolean found = false ; try { found = addSketches ( menu , sketchbookFolder , false ) ; } catch ( IOException e ) { Base . showWarning ( "Sketchbook Menu Error" , "An error occurred while trying to list the sketchbook." , e ) ; } if ( ! found ) { JMenuItem empty = new JMenuItem ( Language . text ( "menu.file.sketchbook.empty" ) ) ; empty . setEnabled ( false ) ; menu . add ( empty ) ; } } public JMenu getRecentMenu ( ) { return recent . getMenu ( ) ; } public JMenu getToolbarRecentMenu ( ) { return recent . getToolbarMenu ( ) ; } public void handleRecent ( Editor editor ) { recent . handle ( editor ) ; } public void handleRecentRename ( Editor editor , String oldPath ) { recent . handleRename ( editor , oldPath ) ; } public void removeRecent ( Editor editor ) { recent . remove ( editor ) ; } protected boolean addSketches ( JMenu menu , File folder , final boolean replaceExisting ) throws IOException { if ( ! folder . isDirectory ( ) ) { return false ; } if ( folder . getName ( ) . equals ( "libraries" ) ) { return false ; } String [ ] list = folder . list ( ) ; if ( list == null ) { return false ; } Arrays . sort ( list , String . CASE_INSENSITIVE_ORDER ) ; ActionListener listener = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { String path = e . getActionCommand ( ) ; if ( new File ( path ) . exists ( ) ) { boolean replace = replaceExisting ; if ( ( e . getModifiers ( ) & ActionEvent . SHIFT_MASK ) != 0 ) { replace = ! replace ; } handleOpen ( path ) ; } else { showWarning ( "Sketch Disappeared" , "The selected sketch no longer exists.\n" + "You may need to restart Processing to update\n" + "the sketchbook menu." , null ) ; } } } ; boolean found = false ; for ( String name : list ) { if ( name . charAt ( 0 ) == '.' ) { continue ; } File subfolder = new File ( folder , name ) ; if ( subfolder . isDirectory ( ) ) { File entry = checkSketchFolder ( subfolder , name ) ; if ( entry != null ) { JMenuItem item = new JMenuItem ( name ) ; item . addActionListener ( listener ) ; item . setActionCommand ( entry . getAbsolutePath ( ) ) ; menu . add ( item ) ; found = true ; } else { JMenu submenu = new JMenu ( name ) ; boolean anything = addSketches ( submenu , subfolder , replaceExisting ) ; if ( anything && ! name . equals ( "old" ) ) { menu . add ( submenu ) ; found = true ; } } } } return found ; } protected boolean addSketches ( DefaultMutableTreeNode node , File folder ) throws IOException { if ( ! folder . isDirectory ( ) ) { return false ; } if ( folder . getName ( ) . equals ( "libraries" ) ) { return false ; } String [ ] fileList = folder . list ( ) ; if ( fileList == null ) { return false ; } Arrays . sort ( fileList , String . CASE_INSENSITIVE_ORDER ) ; boolean found = false ; for ( String name : fileList ) { if ( name . charAt ( 0 ) == '.' ) { continue ; } File subfolder = new File ( folder , name ) ; if ( subfolder . isDirectory ( ) ) { File entry = checkSketchFolder ( subfolder , name ) ; if ( entry != null ) { DefaultMutableTreeNode item = new DefaultMutableTreeNode ( new SketchReference ( name , entry ) ) ; node . add ( item ) ; found = true ; } else { DefaultMutableTreeNode subnode = new DefaultMutableTreeNode ( name ) ; boolean anything = addSketches ( subnode , subfolder ) ; if ( anything ) { node . add ( subnode ) ; found = true ; } } } } return found ; } File checkSketchFolder ( File subfolder , String item ) { for ( Mode mode : getModeList ( ) ) { File entry = new File ( subfolder , item + "." + mode . getDefaultExtension ( ) ) ; if ( entry . exists ( ) ) { return entry ; } } return null ; } public void handlePrefs ( ) { if ( preferencesFrame == null ) { preferencesFrame = new PreferencesFrame ( this ) ; } preferencesFrame . showFrame ( ) ; } public void handleOpenLibraryManager ( ) { libraryManagerFrame . showFrame ( activeEditor ) ; } public void handleOpenToolManager ( ) { toolManagerFrame . showFrame ( activeEditor ) ; } public void handleOpenModeManager ( ) { modeManagerFrame . showFrame ( activeEditor ) ; } public void handleOpenExampleManager ( ) { exampleManagerFrame . showFrame ( activeEditor ) ; } public void handleShowUpdates ( ) { updateManagerFrame . showFrame ( activeEditor ) ; } static public int getRevision ( ) { return REVISION ; } static public String getVersionName ( ) { return VERSION_NAME ; } static public Platform getPlatform ( ) { return platform ; } static public String getPlatformName ( ) { return PConstants . platformNames [ PApplet . platform ] ; } static public int getNativeBits ( ) { return nativeBits ; } static public String getPlatformName ( int which ) { return platformNames . get ( which ) ; } static public int getPlatformIndex ( String what ) { Integer entry = platformIndices . get ( what ) ; return ( entry == null ) ? - 1 : entry . intValue ( ) ; } static public boolean isMacOS ( ) { return System . getProperty ( "os.name" ) . indexOf ( "Mac" ) != - 1 ; } static public boolean isWindows ( ) { return System . getProperty ( "os.name" ) . indexOf ( "Windows" ) != - 1 ; } static public boolean isLinux ( ) { return System . getProperty ( "os.name" ) . indexOf ( "Linux" ) != - 1 ; } static public File getSettingsFolder ( ) { File settingsFolder = null ; try { settingsFolder = platform . getSettingsFolder ( ) ; } catch ( Exception e ) { showError ( "Problem getting the settings folder" , "Error getting the Processing the settings folder." , e ) ; } if ( ! settingsFolder . exists ( ) ) { if ( ! settingsFolder . mkdirs ( ) ) { showError ( "Settings issues" , "Processing cannot run because it could not\n" + "create a folder to store your settings." , null ) ; } } return settingsFolder ; } static public File getSettingsFile ( String filename ) { return new File ( getSettingsFolder ( ) , filename ) ; } static public File createTempFolder ( String prefix , String suffix , File directory ) throws IOException { int fillChars = 3 - prefix . length ( ) ; for ( int i = 0 ; i < fillChars ; i ++ ) { prefix += '_' ; } File folder = File . createTempFile ( prefix , suffix , directory ) ; folder . delete ( ) ; folder . mkdirs ( ) ; return folder ; } static public File getToolsFolder ( ) { return getContentFile ( "tools" ) ; } static public void locateSketchbookFolder ( ) { String sketchbookPath = Preferences . getSketchbookPath ( ) ; if ( sketchbookPath != null ) { sketchbookFolder = new File ( sketchbookPath ) ; if ( ! sketchbookFolder . exists ( ) ) { Base . showWarning ( "Sketchbook folder disappeared" , "The sketchbook folder no longer exists.\n" + "Processing will switch to the default sketchbook\n" + "location, and create a new sketchbook folder if\n" + "necessary. Processing will then stop talking\n" + "about himself in the third person." , null ) ; sketchbookFolder = null ; } } if ( sketchbookFolder == null ) { sketchbookFolder = getDefaultSketchbookFolder ( ) ; Preferences . setSketchbookPath ( sketchbookFolder . getAbsolutePath ( ) ) ; if ( ! sketchbookFolder . exists ( ) ) { sketchbookFolder . mkdirs ( ) ; } } getSketchbookLibrariesFolder ( ) . mkdir ( ) ; getSketchbookToolsFolder ( ) . mkdir ( ) ; getSketchbookModesFolder ( ) . mkdir ( ) ; getSketchbookExamplesFolder ( ) . mkdir ( ) ; } public void setSketchbookFolder ( File folder ) { sketchbookFolder = folder ; Preferences . setSketchbookPath ( folder . getAbsolutePath ( ) ) ; rebuildSketchbookMenus ( ) ; } static public File getSketchbookFolder ( ) { return sketchbookFolder ; } static public File getSketchbookLibrariesFolder ( ) { return new File ( sketchbookFolder , "libraries" ) ; } static public File getSketchbookToolsFolder ( ) { return new File ( sketchbookFolder , "tools" ) ; } static public File getSketchbookModesFolder ( ) { return new File ( sketchbookFolder , "modes" ) ; } static public File getSketchbookExamplesFolder ( ) { return new File ( sketchbookFolder , "examples" ) ; } static protected File getDefaultSketchbookFolder ( ) { File sketchbookFolder = null ; try { sketchbookFolder = platform . getDefaultSketchbookFolder ( ) ; } catch ( Exception e ) { } if ( sketchbookFolder == null ) { showError ( "No sketchbook" , "Problem while trying to get the sketchbook" , null ) ; } boolean result = true ; if ( ! sketchbookFolder . exists ( ) ) { result = sketchbookFolder . mkdirs ( ) ; } if ( ! result ) { showError ( "You forgot your sketchbook" , "Processing cannot run because it could not\n" + "create a folder to store your sketchbook." , null ) ; } return sketchbookFolder ; } static public void openURL ( String url ) { try { platform . openURL ( url ) ; } catch ( Exception e ) { showWarning ( "Problem Opening URL" , "Could not open the URL\n" + url , e ) ; } } static protected boolean openFolderAvailable ( ) { return platform . openFolderAvailable ( ) ; } static public void openFolder ( File file ) { try { platform . openFolder ( file ) ; } catch ( Exception e ) { showWarning ( "Problem Opening Folder" , "Could not open the folder\n" + file . getAbsolutePath ( ) , e ) ; } } static public void showMessage ( String title , String message ) { if ( title == null ) title = "Message" ; if ( commandLine ) { System . out . println ( title + ": " + message ) ; } else { JOptionPane . showMessageDialog ( new Frame ( ) , message , title , JOptionPane . INFORMATION_MESSAGE ) ; } } static public void showWarning ( String title , String message ) { showWarning ( title , message , null ) ; } static public void showWarning ( String title , String message , Throwable e ) { if ( title == null ) title = "Warning" ; if ( commandLine ) { System . out . println ( title + ": " + message ) ; } else { JOptionPane . showMessageDialog ( new Frame ( ) , message , title , JOptionPane . WARNING_MESSAGE ) ; } if ( e != null ) e . printStackTrace ( ) ; } static public void showWarningTiered ( String title , String primary , String secondary , Throwable e ) { if ( title == null ) title = "Warning" ; final String message = primary + "\n" + secondary ; if ( commandLine ) { System . out . println ( title + ": " + message ) ; } else { if ( ! Base . isMacOS ( ) ) { JOptionPane . showMessageDialog ( new JFrame ( ) , "<html><body>" + "<b>" + primary + "</b>" + "<br>" + secondary , title , JOptionPane . WARNING_MESSAGE ) ; } else { JOptionPane pane = new JOptionPane ( "<html> " + "<head> <style type=\"text/css\">" + "b { font: 13pt \"Lucida Grande\" }" + "p { font: 11pt \"Lucida Grande\"; margin-top: 8px; width: 300px }" + "</style> </head>" + "<b>" + primary + "</b>" + "<p>" + secondary + "</p>" , JOptionPane . WARNING_MESSAGE ) ; JDialog dialog = pane . createDialog ( new JFrame ( ) , null ) ; dialog . setVisible ( true ) ; } } if ( e != null ) e . printStackTrace ( ) ; } static public void showError ( String title , String message , Throwable e ) { if ( title == null ) title = "Error" ; if ( commandLine ) { System . err . println ( title + ": " + message ) ; } else { JOptionPane . showMessageDialog ( new Frame ( ) , message , title , JOptionPane . ERROR_MESSAGE ) ; } if ( e != null ) e . printStackTrace ( ) ; System . exit ( 1 ) ; } static private void showBadnessTrace ( String title , String message , Throwable t , boolean fatal ) { if ( title == null ) title = fatal ? "Error" : "Warning" ; if ( commandLine ) { System . err . println ( title + ": " + message ) ; if ( t != null ) { t . printStackTrace ( ) ; } } else { StringWriter sw = new StringWriter ( ) ; t . printStackTrace ( new PrintWriter ( sw ) ) ; message = ( "<html>" + message + "<br/><font size=2><br/>" + sw + "</html>" ) . replaceAll ( "\n" , "<br/>" ) ; JOptionPane . showMessageDialog ( new Frame ( ) , message , title , fatal ? JOptionPane . ERROR_MESSAGE : JOptionPane . WARNING_MESSAGE ) ; if ( fatal ) { System . exit ( 1 ) ; } } } static public int showYesNoCancelQuestion ( Editor editor , String title , String primary , String secondary ) { if ( ! Base . isMacOS ( ) ) { int result = JOptionPane . showConfirmDialog ( null , primary + "\n" + secondary , title , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) ; return result ; } else { JOptionPane pane = new JOptionPane ( "<html> " + "<head> <style type=\"text/css\">" + "b { font: 13pt \"Lucida Grande\" }" + "p { font: 11pt \"Lucida Grande\"; margin-top: 8px; width: 300px }" + "</style> </head>" + "<b>" + Language . text ( "save.title" ) + "</b>" + "<p>" + Language . text ( "save.hint" ) + "</p>" , JOptionPane . QUESTION_MESSAGE ) ; String [ ] options = new String [ ] { Language . text ( "save.btn.save" ) , Language . text ( "prompt.cancel" ) , Language . text ( "save.btn.dont_save" ) } ; pane . setOptions ( options ) ; pane . setInitialValue ( options [ 0 ] ) ; pane . putClientProperty ( "Quaqua.OptionPane.destructiveOption" , Integer . valueOf ( 2 ) ) ; JDialog dialog = pane . createDialog ( editor , null ) ; dialog . setVisible ( true ) ; Object result = pane . getValue ( ) ; if ( result == options [ 0 ] ) { return JOptionPane . YES_OPTION ; } else if ( result == options [ 1 ] ) { return JOptionPane . CANCEL_OPTION ; } else if ( result == options [ 2 ] ) { return JOptionPane . NO_OPTION ; } else { return JOptionPane . CLOSED_OPTION ; } } } static public int showYesNoQuestion ( Frame editor , String title , String primary , String secondary ) { if ( ! Base . isMacOS ( ) ) { return JOptionPane . showConfirmDialog ( editor , "<html><body>" + "<b>" + primary + "</b>" + "<br>" + secondary , title , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; } else { JOptionPane pane = new JOptionPane ( "<html> " + "<head> <style type=\"text/css\">" + "b { font: 13pt \"Lucida Grande\" }" + "p { font: 11pt \"Lucida Grande\"; margin-top: 8px; width: 300px }" + "</style> </head>" + "<b>" + primary + "</b>" + "<p>" + secondary + "</p>" , JOptionPane . QUESTION_MESSAGE ) ; String [ ] options = new String [ ] { "Yes" , "No" } ; pane . setOptions ( options ) ; pane . setInitialValue ( options [ 0 ] ) ; JDialog dialog = pane . createDialog ( editor , null ) ; dialog . setVisible ( true ) ; Object result = pane . getValue ( ) ; if ( result == options [ 0 ] ) { return JOptionPane . YES_OPTION ; } else if ( result == options [ 1 ] ) { return JOptionPane . NO_OPTION ; } else { return JOptionPane . CLOSED_OPTION ; } } } static protected File processingRoot ; static public File getContentFile ( String name ) { if ( processingRoot == null ) { String path = Base . class . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) . getPath ( ) ; String decodedPath = PApplet . urlDecode ( path ) ; if ( decodedPath . contains ( "/app/bin" ) ) { if ( Base . isMacOS ( ) ) { processingRoot = new File ( path , "../../build/macosx/work/Processing.app/Contents/Java" ) ; } else if ( Base . isWindows ( ) ) { processingRoot = new File ( path , "../../build/windows/work" ) ; } else if ( Base . isLinux ( ) ) { processingRoot = new File ( path , "../../build/linux/work" ) ; } } else { File jarFolder = new File ( decodedPath ) . getParentFile ( ) ; if ( jarFolder . getName ( ) . equals ( "lib" ) ) { processingRoot = jarFolder . getParentFile ( ) ; } else if ( Base . isMacOS ( ) ) { processingRoot = jarFolder ; } if ( processingRoot == null || ! processingRoot . exists ( ) ) { System . err . println ( "Could not find lib folder via " + jarFolder . getAbsolutePath ( ) + ", switching to user.dir" ) ; processingRoot = new File ( System . getProperty ( "user.dir" ) ) ; } } } return new File ( processingRoot , name ) ; } static public File getJavaHome ( ) { if ( isMacOS ( ) ) { File [ ] plugins = getContentFile ( "../PlugIns" ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return dir . isDirectory ( ) && name . endsWith ( ".jdk" ) && ! name . startsWith ( "." ) ; } } ) ; return new File ( plugins [ 0 ] , "Contents/Home/jre" ) ; } return getContentFile ( "java" ) ; } static public String getJavaPath ( ) { String javaPath = "bin/java" + ( isWindows ( ) ? ".exe" : "" ) ; File javaFile = new File ( getJavaHome ( ) , javaPath ) ; try { return javaFile . getCanonicalPath ( ) ; } catch ( IOException e ) { return javaFile . getAbsolutePath ( ) ; } } static public File getLibFile ( String filename ) throws IOException { return new File ( getContentFile ( "lib" ) , filename ) ; } static public InputStream getLibStream ( String filename ) throws IOException { return new FileInputStream ( getLibFile ( filename ) ) ; } static public int countLines ( String what ) { int count = 1 ; for ( char c : what . toCharArray ( ) ) { if ( c == '\n' ) count ++ ; } return count ; } static public byte [ ] loadBytesRaw ( File file ) throws IOException { int size = ( int ) file . length ( ) ; FileInputStream input = new FileInputStream ( file ) ; byte buffer [ ] = new byte [ size ] ; int offset = 0 ; int bytesRead ; while ( ( bytesRead = input . read ( buffer , offset , size - offset ) ) != - 1 ) { offset += bytesRead ; if ( bytesRead == 0 ) break ; } input . close ( ) ; input = null ; return buffer ; } static public Map < String , String > readSettings ( File inputFile ) { if ( ! inputFile . exists ( ) ) { if ( DEBUG ) System . err . println ( inputFile + " does not exist." ) ; return null ; } String lines [ ] = PApplet . loadStrings ( inputFile ) ; if ( lines == null ) { System . err . println ( "Could not read " + inputFile ) ; return null ; } return readSettings ( inputFile . toString ( ) , lines ) ; } static public Map < String , String > readSettings ( String filename , String [ ] lines ) { Map < String , String > settings = new HashMap < > ( ) ; for ( String line : lines ) { int commentMarker = line . indexOf ( '#' ) ; if ( commentMarker != - 1 ) { line = line . substring ( 0 , commentMarker ) ; } line = line . trim ( ) ; if ( line . length ( ) != 0 ) { int equals = line . indexOf ( '=' ) ; if ( equals == - 1 ) { if ( filename != null ) { System . err . println ( "Ignoring illegal line in " + filename ) ; System . err . println ( " " + line ) ; } } else { String attr = line . substring ( 0 , equals ) . trim ( ) ; String valu = line . substring ( equals + 1 ) . trim ( ) ; settings . put ( attr , valu ) ; } } } return settings ; } static public void copyFile ( File sourceFile , File targetFile ) throws IOException { BufferedInputStream from = new BufferedInputStream ( new FileInputStream ( sourceFile ) ) ; BufferedOutputStream to = new BufferedOutputStream ( new FileOutputStream ( targetFile ) ) ; byte [ ] buffer = new byte [ 16 * 1024 ] ; int bytesRead ; while ( ( bytesRead = from . read ( buffer ) ) != - 1 ) { to . write ( buffer , 0 , bytesRead ) ; } from . close ( ) ; from = null ; to . flush ( ) ; to . close ( ) ; to = null ; targetFile . setLastModified ( sourceFile . lastModified ( ) ) ; targetFile . setExecutable ( sourceFile . canExecute ( ) ) ; } static public String loadFile ( File file ) throws IOException { String [ ] contents = PApplet . loadStrings ( file ) ; if ( contents == null ) return null ; return PApplet . join ( contents , "\n" ) ; } static public void saveFile ( String str , File file ) throws IOException { File temp = File . createTempFile ( file . getName ( ) , null , file . getParentFile ( ) ) ; try { File canon = file . getCanonicalFile ( ) ; file = canon ; } catch ( IOException e ) { throw new IOException ( "Could not resolve canonical representation of " + file . getAbsolutePath ( ) ) ; } PrintWriter writer = PApplet . createWriter ( temp ) ; writer . print ( str ) ; boolean error = writer . checkError ( ) ; writer . close ( ) ; if ( error ) { throw new IOException ( "Error while trying to save " + file ) ; } if ( file . exists ( ) ) { boolean result = file . delete ( ) ; if ( ! result ) { throw new IOException ( "Could not remove old version of " + file . getAbsolutePath ( ) ) ; } } boolean result = temp . renameTo ( file ) ; if ( ! result ) { throw new IOException ( "Could not replace " + file . getAbsolutePath ( ) + " with " + temp . getAbsolutePath ( ) ) ; } } static public void copyDir ( File sourceDir , File targetDir ) throws IOException { if ( sourceDir . equals ( targetDir ) ) { final String urDum = "source and target directories are identical" ; throw new IllegalArgumentException ( urDum ) ; } targetDir . mkdirs ( ) ; String files [ ] = sourceDir . list ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . charAt ( 0 ) == '.' ) continue ; File source = new File ( sourceDir , files [ i ] ) ; File target = new File ( targetDir , files [ i ] ) ; if ( source . isDirectory ( ) ) { copyDir ( source , target ) ; target . setLastModified ( source . lastModified ( ) ) ; } else { copyFile ( source , target ) ; } } } static public void copyDirNative ( File sourceDir , File targetDir ) throws IOException { Process process = null ; if ( Base . isMacOS ( ) || Base . isLinux ( ) ) { process = Runtime . getRuntime ( ) . exec ( new String [ ] { "cp" , "-a" , sourceDir . getAbsolutePath ( ) , targetDir . getAbsolutePath ( ) } ) ; } else { throw new RuntimeException ( "Not yet implemented on Windows" ) ; } try { int result = process . waitFor ( ) ; if ( result != 0 ) { throw new IOException ( "Error while copying (result " + result + ")" ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } static public boolean platformDelete ( File file ) throws IOException { return platform . deleteFile ( file ) ; } static public void removeDir ( File dir ) { if ( dir . exists ( ) ) { removeDescendants ( dir ) ; if ( ! dir . delete ( ) ) { System . err . println ( "Could not delete " + dir ) ; } } } static public void removeDescendants ( File dir ) { if ( ! dir . exists ( ) ) return ; String files [ ] = dir . list ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . equals ( "." ) || files [ i ] . equals ( ".." ) ) continue ; File dead = new File ( dir , files [ i ] ) ; if ( ! dead . isDirectory ( ) ) { if ( ! Preferences . getBoolean ( "compiler.save_build_files" ) ) { if ( ! dead . delete ( ) ) { System . err . println ( "Could not delete " + dead ) ; } } } else { removeDir ( dead ) ; } } } static public int calcFolderSize ( File folder ) { int size = 0 ; String files [ ] = folder . list ( ) ; if ( files == null ) return - 1 ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . equals ( "." ) || files [ i ] . equals ( ".." ) || files [ i ] . equals ( ".DS_Store" ) ) continue ; File fella = new File ( folder , files [ i ] ) ; if ( fella . isDirectory ( ) ) { size += calcFolderSize ( fella ) ; } else { size += ( int ) fella . length ( ) ; } } return size ; } static public String [ ] listFiles ( File folder , boolean relative ) { String path = folder . getAbsolutePath ( ) ; Vector < String > vector = new Vector < String > ( ) ; listFiles ( relative ? ( path + File . separator ) : "" , path , null , vector ) ; String outgoing [ ] = new String [ vector . size ( ) ] ; vector . copyInto ( outgoing ) ; return outgoing ; } static public String [ ] listFiles ( File folder , boolean relative , String extension ) { String path = folder . getAbsolutePath ( ) ; Vector < String > vector = new Vector < String > ( ) ; if ( extension != null ) { if ( ! extension . startsWith ( "." ) ) { extension = "." + extension ; } } listFiles ( relative ? ( path + File . separator ) : "" , path , extension , vector ) ; String outgoing [ ] = new String [ vector . size ( ) ] ; vector . copyInto ( outgoing ) ; return outgoing ; } static protected void listFiles ( String basePath , String path , String extension , Vector < String > vector ) { File folder = new File ( path ) ; String [ ] list = folder . list ( ) ; if ( list != null ) { for ( String item : list ) { if ( item . charAt ( 0 ) == '.' ) continue ; if ( extension == null || item . toLowerCase ( ) . endsWith ( extension ) ) { File file = new File ( path , item ) ; String newPath = file . getAbsolutePath ( ) ; if ( newPath . startsWith ( basePath ) ) { newPath = newPath . substring ( basePath . length ( ) ) ; } if ( extension == null || item . toLowerCase ( ) . endsWith ( extension ) ) { vector . add ( newPath ) ; } if ( file . isDirectory ( ) ) { listFiles ( basePath , file . getAbsolutePath ( ) , extension , vector ) ; } } } } } static public File [ ] listJarFiles ( File folder ) { return folder . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return ( ! name . startsWith ( "." ) && ( name . toLowerCase ( ) . endsWith ( ".jar" ) || name . toLowerCase ( ) . endsWith ( ".zip" ) ) ) ; } } ) ; } static public String contentsToClassPath ( File folder ) { if ( folder == null ) return "" ; StringBuilder sb = new StringBuilder ( ) ; String sep = System . getProperty ( "path.separator" ) ; try { String path = folder . getCanonicalPath ( ) ; if ( ! path . endsWith ( File . separator ) ) { path += File . separator ; } String list [ ] = folder . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { if ( list [ i ] . startsWith ( "." ) ) continue ; if ( list [ i ] . toLowerCase ( ) . endsWith ( ".jar" ) || list [ i ] . toLowerCase ( ) . endsWith ( ".zip" ) ) { sb . append ( sep ) ; sb . append ( path ) ; sb . append ( list [ i ] ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; } static public String [ ] packageListFromClassPath ( String path ) { Map < String , Object > map = new HashMap < String , Object > ( ) ; String pieces [ ] = PApplet . split ( path , File . pathSeparatorChar ) ; for ( int i = 0 ; i < pieces . length ; i ++ ) { if ( pieces [ i ] . length ( ) == 0 ) continue ; if ( pieces [ i ] . toLowerCase ( ) . endsWith ( ".jar" ) || pieces [ i ] . toLowerCase ( ) . endsWith ( ".zip" ) ) { packageListFromZip ( pieces [ i ] , map ) ; } else { File dir = new File ( pieces [ i ] ) ; if ( dir . exists ( ) && dir . isDirectory ( ) ) { packageListFromFolder ( dir , null , map ) ; } } } int mapCount = map . size ( ) ; String output [ ] = new String [ mapCount ] ; int index = 0 ; Set < String > set = map . keySet ( ) ; for ( String s : set ) { output [ index ++ ] = s . replace ( '/' , '.' ) ; } return output ; } static private void packageListFromZip ( String filename , Map < String , Object > map ) { try { ZipFile file = new ZipFile ( filename ) ; Enumeration entries = file . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) entries . nextElement ( ) ; if ( ! entry . isDirectory ( ) ) { String name = entry . getName ( ) ; if ( name . endsWith ( ".class" ) ) { int slash = name . lastIndexOf ( '/' ) ; if ( slash == - 1 ) continue ; String pname = name . substring ( 0 , slash ) ; if ( map . get ( pname ) == null ) { map . put ( pname , new Object ( ) ) ; } } } } file . close ( ) ; } catch ( IOException e ) { System . err . println ( "Ignoring " + filename + " (" + e . getMessage ( ) + ")" ) ; } } static private void packageListFromFolder ( File dir , String sofar , Map < String , Object > map ) { boolean foundClass = false ; String files [ ] = dir . list ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . equals ( "." ) || files [ i ] . equals ( ".." ) ) continue ; File sub = new File ( dir , files [ i ] ) ; if ( sub . isDirectory ( ) ) { String nowfar = ( sofar == null ) ? files [ i ] : ( sofar + "." + files [ i ] ) ; packageListFromFolder ( sub , nowfar , map ) ; } else if ( ! foundClass ) { if ( files [ i ] . endsWith ( ".class" ) ) { map . put ( sofar , new Object ( ) ) ; foundClass = true ; } } } } static public void unzip ( File zipFile , File dest ) { try { FileInputStream fis = new FileInputStream ( zipFile ) ; CheckedInputStream checksum = new CheckedInputStream ( fis , new Adler32 ( ) ) ; ZipInputStream zis = new ZipInputStream ( new BufferedInputStream ( checksum ) ) ; ZipEntry next = null ; while ( ( next = zis . getNextEntry ( ) ) != null ) { File currentFile = new File ( dest , next . getName ( ) ) ; if ( next . isDirectory ( ) ) { currentFile . mkdirs ( ) ; } else { File parentDir = currentFile . getParentFile ( ) ; if ( ! parentDir . exists ( ) ) { parentDir . mkdirs ( ) ; } currentFile . createNewFile ( ) ; unzipEntry ( zis , currentFile ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } static protected void unzipEntry ( ZipInputStream zin , File f ) throws IOException { FileOutputStream out = new FileOutputStream ( f ) ; byte [ ] b = new byte [ 512 ] ; int len = 0 ; while ( ( len = zin . read ( b ) ) != - 1 ) { out . write ( b , 0 , len ) ; } out . flush ( ) ; out . close ( ) ; } static public void log ( Object from , String message ) { if ( DEBUG ) { System . out . println ( from . getClass ( ) . getName ( ) + ": " + message ) ; } } static public void log ( String message ) { if ( DEBUG ) { System . out . println ( message ) ; } } static public void logf ( String message , Object ... args ) { if ( DEBUG ) { System . out . println ( String . format ( message , args ) ) ; } } static public void loge ( String message , Throwable e ) { if ( DEBUG ) { System . err . println ( message ) ; e . printStackTrace ( ) ; } } static public void loge ( String message ) { if ( DEBUG ) { System . out . println ( message ) ; } } }
package processing . app ; import java . awt . * ; import javax . swing . plaf . basic . BasicSplitPaneDivider ; import javax . swing . plaf . basic . BasicSplitPaneUI ; public class EditorStatus extends BasicSplitPaneDivider { static final int HIGH = 28 ; Color [ ] bgcolor ; Color [ ] fgcolor ; static public final int NOTICE = 0 ; static public final int ERR = 1 ; static public final int EDIT = 2 ; static final int YES = 1 ; static final int NO = 2 ; static final int CANCEL = 3 ; static final int OK = 4 ; static final String NO_MESSAGE = "" ; Editor editor ; int mode ; String message ; Font font ; FontMetrics metrics ; int ascent ; Image offscreen ; int sizeW , sizeH ; int response ; boolean indeterminate ; Thread thread ; public EditorStatus ( BasicSplitPaneUI ui , Editor editor ) { super ( ui ) ; this . editor = editor ; empty ( ) ; updateMode ( ) ; } public void updateMode ( ) { Mode mode = editor . getMode ( ) ; bgcolor = new Color [ ] { mode . getColor ( "status.notice.bgcolor" ) , mode . getColor ( "status.error.bgcolor" ) , mode . getColor ( "status.edit.bgcolor" ) } ; fgcolor = new Color [ ] { mode . getColor ( "status.notice.fgcolor" ) , mode . getColor ( "status.error.fgcolor" ) , mode . getColor ( "status.edit.fgcolor" ) } ; font = mode . getFont ( "status.font" ) ; metrics = null ; } public void empty ( ) { mode = NOTICE ; message = NO_MESSAGE ; repaint ( ) ; } public void notice ( String message ) { mode = NOTICE ; this . message = message ; repaint ( ) ; } public void unnotice ( String unmessage ) { if ( message . equals ( unmessage ) ) empty ( ) ; } public void error ( String message ) { mode = ERR ; this . message = message ; repaint ( ) ; } public void startIndeterminate ( ) { indeterminate = true ; thread = new Thread ( ) { public void run ( ) { while ( Thread . currentThread ( ) == thread ) { repaint ( ) ; try { Thread . sleep ( 1000 / 10 ) ; } catch ( InterruptedException e ) { } } } } ; thread . setName ( "Editor Status" ) ; thread . start ( ) ; } public void stopIndeterminate ( ) { indeterminate = false ; thread = null ; repaint ( ) ; } public void paint ( Graphics screen ) { Dimension size = getSize ( ) ; if ( ( size . width != sizeW ) || ( size . height != sizeH ) ) { offscreen = null ; } if ( offscreen == null ) { sizeW = size . width ; sizeH = size . height ; if ( Toolkit . highResDisplay ( ) ) { offscreen = createImage ( sizeW * 2 , sizeH * 2 ) ; } else { offscreen = createImage ( sizeW , sizeH ) ; } } Graphics g = offscreen . getGraphics ( ) ; Toolkit . prepareGraphics ( g ) ; g . setFont ( font ) ; if ( metrics == null ) { metrics = g . getFontMetrics ( ) ; ascent = metrics . getAscent ( ) ; } g . setColor ( bgcolor [ mode ] ) ; g . fillRect ( 0 , 0 , sizeW , sizeH ) ; g . setColor ( fgcolor [ mode ] ) ; if ( message != null ) { g . setFont ( font ) ; g . drawString ( message , Preferences . GUI_SMALL , ( sizeH + ascent ) / 2 ) ; } if ( indeterminate ) { int w = Preferences . BUTTON_WIDTH ; int x = getWidth ( ) - Preferences . GUI_SMALL - w ; int y = getHeight ( ) / 3 ; int h = getHeight ( ) / 3 ; g . setColor ( new Color ( 0x80000000 , true ) ) ; g . drawRect ( x , y , w , h ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int r = ( int ) ( x + Math . random ( ) * w ) ; g . drawLine ( r , y , r , y + h ) ; } } screen . drawImage ( offscreen , 0 , 0 , sizeW , sizeH , null ) ; } public Dimension getPreferredSize ( ) { return getMinimumSize ( ) ; } public Dimension getMinimumSize ( ) { return new Dimension ( 300 , HIGH ) ; } public Dimension getMaximumSize ( ) { return new Dimension ( super . getMaximumSize ( ) . width , HIGH ) ; } }
package processing . app ; import java . awt . * ; import java . awt . event . * ; import javax . swing . * ; abstract public class EditorButton extends JComponent implements MouseListener , MouseMotionListener , ActionListener { static public final int DIM = 30 ; protected String title ; protected String titleShift ; protected String titleAlt ; protected boolean pressed ; protected boolean selected ; protected boolean rollover ; protected JLabel rolloverLabel ; protected boolean shift ; protected Image enabledImage ; protected Image disabledImage ; protected Image selectedImage ; protected Image rolloverImage ; protected Image pressedImage ; protected Image gradient ; protected Mode mode ; public EditorButton ( Mode mode , String name , String title ) { this ( mode , name , title , title , title ) ; } public EditorButton ( Mode mode , String name , String title , String titleShift ) { this ( mode , name , title , titleShift , title ) ; } public EditorButton ( Mode mode , String name , String title , String titleShift , String titleAlt ) { this . mode = mode ; this . title = title ; this . titleShift = titleShift ; this . titleAlt = titleAlt ; final int res = Toolkit . highResDisplay ( ) ? 2 : 1 ; disabledImage = mode . loadImage ( name + "-disabled-" + res + "x.png" ) ; enabledImage = mode . loadImage ( name + "-enabled-" + res + "x.png" ) ; selectedImage = mode . loadImage ( name + "-selected-" + res + "x.png" ) ; pressedImage = mode . loadImage ( name + "-pressed-" + res + "x.png" ) ; rolloverImage = mode . loadImage ( name + "-rollover-" + res + "x.png" ) ; if ( disabledImage == null ) { disabledImage = enabledImage ; } if ( selectedImage == null ) { selectedImage = enabledImage ; } if ( pressedImage == null ) { pressedImage = enabledImage ; } if ( rolloverImage == null ) { rolloverImage = enabledImage ; } addMouseListener ( this ) ; addMouseMotionListener ( this ) ; } @ Override public void paintComponent ( Graphics g ) { Image image = enabledImage ; if ( ! isEnabled ( ) ) { image = disabledImage ; } else if ( selected ) { image = selectedImage ; } else if ( pressed ) { image = pressedImage ; } else if ( rollover ) { image = rolloverImage ; } if ( gradient != null ) { g . drawImage ( gradient , 0 , 0 , DIM , DIM , this ) ; } g . drawImage ( image , 0 , 0 , DIM , DIM , this ) ; } public void setReverse ( ) { gradient = mode . makeGradient ( "reversed" , DIM , DIM ) ; } public void setRolloverLabel ( JLabel label ) { rolloverLabel = label ; } @ Override public void mouseClicked ( MouseEvent e ) { if ( isEnabled ( ) ) { shift = e . isShiftDown ( ) ; actionPerformed ( new ActionEvent ( this , ActionEvent . ACTION_PERFORMED , null , e . getModifiers ( ) ) ) ; } } public boolean isShiftDown ( ) { return shift ; } @ Override public void mousePressed ( MouseEvent e ) { setPressed ( true ) ; } @ Override public void mouseReleased ( MouseEvent e ) { setPressed ( false ) ; } public void setPressed ( boolean pressed ) { if ( isEnabled ( ) ) { this . pressed = pressed ; repaint ( ) ; } } public void setSelected ( boolean selected ) { this . selected = selected ; } @ Override public void mouseEntered ( MouseEvent e ) { rollover = true ; if ( rolloverLabel != null ) { if ( e . isShiftDown ( ) ) { rolloverLabel . setText ( titleShift ) ; } else if ( e . isAltDown ( ) ) { rolloverLabel . setText ( titleAlt ) ; } else { rolloverLabel . setText ( title ) ; } } repaint ( ) ; } @ Override public void mouseExited ( MouseEvent e ) { rollover = false ; if ( rolloverLabel != null ) { rolloverLabel . setText ( "" ) ; } repaint ( ) ; } @ Override public void mouseDragged ( MouseEvent e ) { } @ Override public void mouseMoved ( MouseEvent e ) { } abstract public void actionPerformed ( ActionEvent e ) ; @ Override public Dimension getPreferredSize ( ) { return new Dimension ( DIM , DIM ) ; } @ Override public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } @ Override public Dimension getMaximumSize ( ) { return getPreferredSize ( ) ; } }
package processing . app ; import java . awt . * ; import java . awt . event . * ; import java . io . * ; import java . util . * ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; import processing . app . ColorChooser ; import processing . app . Language ; import processing . core . * ; public class PreferencesFrame { JFrame frame ; GroupLayout layout ; static final Integer [ ] FONT_SIZES = { 10 , 12 , 14 , 18 , 24 , 36 , 48 } ; JTextField sketchbookLocationField ; JTextField presentColor ; JTextField presentColorHex ; JCheckBox editorAntialiasBox ; JCheckBox deletePreviousBox ; JCheckBox memoryOverrideBox ; JTextField memoryField ; JCheckBox checkUpdatesBox ; JComboBox < Integer > fontSizeField ; JComboBox < Integer > consoleFontSizeField ; JCheckBox inputMethodBox ; JCheckBox autoAssociateBox ; ColorChooser selector ; JCheckBox errorCheckerBox ; JCheckBox warningsCheckerBox ; JCheckBox codeCompletionBox ; JCheckBox importSuggestionsBox ; JComboBox < String > displaySelectionBox ; JComboBox < String > languageSelectionBox ; int displayCount ; String [ ] monoFontFamilies ; JComboBox < String > fontSelectionBox ; JButton okButton ; Base base ; public PreferencesFrame ( Base base ) { this . base = base ; frame = new JFrame ( Language . text ( "preferences" ) ) ; Container pain = frame . getContentPane ( ) ; layout = new GroupLayout ( pain ) ; layout . setAutoCreateGaps ( true ) ; layout . setAutoCreateContainerGaps ( true ) ; pain . setLayout ( layout ) ; final int BUTTON_WIDTH = Preferences . BUTTON_WIDTH ; final int BORDER = Base . isMacOS ( ) ? 20 : 13 ; JLabel sketchbookLocationLabel , restartProcessingLabel ; JButton browseButton ; sketchbookLocationLabel = new JLabel ( Language . text ( "preferences.sketchbook_location" ) + ":" ) ; sketchbookLocationField = new JTextField ( 40 ) ; browseButton = new JButton ( Preferences . PROMPT_BROWSE ) ; browseButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { File dflt = new File ( sketchbookLocationField . getText ( ) ) ; PApplet . selectFolder ( Language . text ( "preferences.sketchbook_location.popup" ) , "sketchbookCallback" , dflt , PreferencesFrame . this , frame ) ; } } ) ; JLabel languageLabel = new JLabel ( Language . text ( "preferences.language" ) + ": " ) ; languageSelectionBox = new JComboBox < String > ( ) ; Map < String , String > languages = Language . getLanguages ( ) ; String [ ] languageSelection = new String [ languages . size ( ) ] ; languageSelection [ 0 ] = languages . get ( Language . getLanguage ( ) ) ; int i = 1 ; for ( Map . Entry < String , String > lang : languages . entrySet ( ) ) { if ( ! lang . getKey ( ) . equals ( Language . getLanguage ( ) ) ) { languageSelection [ i ++ ] = lang . getValue ( ) ; } } languageSelectionBox . setModel ( new DefaultComboBoxModel < String > ( languageSelection ) ) ; restartProcessingLabel = new JLabel ( " (" + Language . text ( "preferences.requires_restart" ) + ")" ) ; JLabel fontLabel = new JLabel ( Language . text ( "preferences.editor_and_console_font" ) + ": " ) ; final String fontTip = "<html>" + Language . text ( "preferences.editor_and_console_font.tip" ) ; fontLabel . setToolTipText ( fontTip ) ; fontSelectionBox = new JComboBox < String > ( new String [ ] { Toolkit . getMonoFontName ( ) } ) ; fontSelectionBox . setToolTipText ( fontTip ) ; fontSelectionBox . setEnabled ( false ) ; JLabel fontSizelabel = new JLabel ( Language . text ( "preferences.editor_font_size" ) + ": " ) ; fontSizeField = new JComboBox < Integer > ( FONT_SIZES ) ; JLabel consoleFontSizeLabel = new JLabel ( Language . text ( "preferences.console_font_size" ) + ": " ) ; consoleFontSizeField = new JComboBox < Integer > ( FONT_SIZES ) ; fontSizeField . setSelectedItem ( Preferences . getFont ( "editor.font.size" ) ) ; JLabel backgroundColorLabel = new JLabel ( Language . text ( "preferences.background_color" ) + ": " ) ; final String colorTip = "<html>" + Language . text ( "preferences.background_color.tip" ) ; backgroundColorLabel . setToolTipText ( colorTip ) ; presentColor = new JTextField ( " " ) ; presentColor . setOpaque ( true ) ; presentColor . setEnabled ( false ) ; Border cb = new CompoundBorder ( BorderFactory . createMatteBorder ( 1 , 1 , 0 , 0 , new Color ( 195 , 195 , 195 ) ) , BorderFactory . createMatteBorder ( 0 , 0 , 1 , 1 , new Color ( 54 , 54 , 54 ) ) ) ; presentColor . setBorder ( cb ) ; presentColor . setBackground ( Preferences . getColor ( "run.present.bgcolor" ) ) ; presentColorHex = new JTextField ( 6 ) ; presentColorHex . setText ( Preferences . get ( "run.present.bgcolor" ) . substring ( 1 ) ) ; presentColorHex . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { @ Override public void removeUpdate ( DocumentEvent e ) { final String colorValue = presentColorHex . getText ( ) . toUpperCase ( ) ; if ( colorValue . length ( ) == 7 && ( colorValue . startsWith ( "#" ) ) ) EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { presentColorHex . setText ( colorValue . substring ( 1 ) ) ; } } ) ; if ( colorValue . length ( ) == 6 && colorValue . matches ( "[0123456789ABCDEF]*" ) ) { presentColor . setBackground ( new Color ( PApplet . unhex ( colorValue ) ) ) ; if ( ! colorValue . equals ( presentColorHex . getText ( ) ) ) EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { presentColorHex . setText ( colorValue ) ; } } ) ; } } @ Override public void insertUpdate ( DocumentEvent e ) { final String colorValue = presentColorHex . getText ( ) . toUpperCase ( ) ; if ( colorValue . length ( ) == 7 && ( colorValue . startsWith ( "#" ) ) ) EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { presentColorHex . setText ( colorValue . substring ( 1 ) ) ; } } ) ; if ( colorValue . length ( ) == 6 && colorValue . matches ( "[0123456789ABCDEF]*" ) ) { presentColor . setBackground ( new Color ( PApplet . unhex ( colorValue ) ) ) ; if ( ! colorValue . equals ( presentColorHex . getText ( ) ) ) EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { presentColorHex . setText ( colorValue ) ; } } ) ; } } @ Override public void changedUpdate ( DocumentEvent e ) { } } ) ; selector = new ColorChooser ( frame , false , Preferences . getColor ( "run.present.bgcolor" ) , Language . text ( "prompt.ok" ) , new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { String colorValue = selector . getHexColor ( ) ; colorValue = colorValue . substring ( 1 ) ; presentColorHex . setText ( colorValue ) ; presentColor . setBackground ( new Color ( PApplet . unhex ( colorValue ) ) ) ; selector . hide ( ) ; } } ) ; presentColor . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseExited ( MouseEvent e ) { frame . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } @ Override public void mouseEntered ( MouseEvent e ) { frame . setCursor ( Cursor . getPredefinedCursor ( Cursor . HAND_CURSOR ) ) ; } @ Override public void mouseClicked ( MouseEvent e ) { selector . show ( ) ; } } ) ; JLabel hashLabel = new JLabel ( "#" ) ; editorAntialiasBox = new JCheckBox ( Language . text ( "preferences.use_smooth_text" ) ) ; inputMethodBox = new JCheckBox ( Language . text ( "preferences.enable_complex_text_input" ) + " (" + Language . text ( "preferences.enable_complex_text_input_example" ) + ", " + Language . text ( "preferences.requires_restart" ) + ")" ) ; errorCheckerBox = new JCheckBox ( Language . text ( "preferences.continuously_check" ) ) ; warningsCheckerBox = new JCheckBox ( Language . text ( "preferences.show_warnings" ) ) ; codeCompletionBox = new JCheckBox ( Language . text ( "preferences.code_completion" ) + " Ctrl-" + Language . text ( "preferences.cmd_space" ) ) ; importSuggestionsBox = new JCheckBox ( Language . text ( "preferences.suggest_imports" ) ) ; memoryOverrideBox = new JCheckBox ( Language . text ( "preferences.increase_max_memory" ) + ": " ) ; memoryField = new JTextField ( 4 ) ; memoryOverrideBox . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { memoryField . setEnabled ( memoryOverrideBox . isSelected ( ) ) ; } } ) ; JLabel mbLabel = new JLabel ( "MB" ) ; deletePreviousBox = new JCheckBox ( Language . text ( "preferences.delete_previous_folder_on_export" ) ) ; checkUpdatesBox = new JCheckBox ( Language . text ( "preferences.check_for_updates_on_startup" ) ) ; JLabel displayLabel = new JLabel ( Language . text ( "preferences.run_sketches_on_display" ) + ": " ) ; final String tip = "<html>" + Language . text ( "preferences.run_sketches_on_display.tip" ) ; displayLabel . setToolTipText ( tip ) ; displaySelectionBox = new JComboBox < String > ( ) ; updateDisplayList ( ) ; autoAssociateBox = new JCheckBox ( Language . text ( "preferences.automatically_associate_pde_files" ) ) ; autoAssociateBox . setVisible ( false ) ; JLabel morePreferenceLabel = new JLabel ( Language . text ( "preferences.file" ) + ":" ) ; morePreferenceLabel . setForeground ( Color . gray ) ; JLabel preferencePathLabel = new JLabel ( Preferences . getPreferencesPath ( ) ) ; final JLabel clickable = preferencePathLabel ; preferencePathLabel . addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent e ) { Base . openFolder ( Base . getSettingsFolder ( ) ) ; } public void mouseEntered ( MouseEvent e ) { clickable . setForeground ( new Color ( 0 , 0 , 140 ) ) ; } public void mouseExited ( MouseEvent e ) { clickable . setForeground ( Color . BLACK ) ; } } ) ; JLabel preferenceHintLabel = new JLabel ( "(" + Language . text ( "preferences.file.hint" ) + ")" ) ; preferenceHintLabel . setForeground ( Color . gray ) ; okButton = new JButton ( Preferences . PROMPT_OK ) ; okButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { applyFrame ( ) ; disposeFrame ( ) ; } } ) ; JButton cancelButton = new JButton ( Preferences . PROMPT_CANCEL ) ; cancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { disposeFrame ( ) ; } } ) ; layout . setHorizontalGroup ( layout . createSequentialGroup ( ) . addGap ( BORDER ) . addGroup ( layout . createParallelGroup ( ) . addComponent ( sketchbookLocationLabel ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( sketchbookLocationField ) . addComponent ( browseButton ) ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( languageLabel ) . addComponent ( languageSelectionBox , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addComponent ( restartProcessingLabel ) ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( fontLabel ) . addComponent ( fontSelectionBox , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) ) . addGroup ( GroupLayout . Alignment . LEADING , layout . createSequentialGroup ( ) . addComponent ( fontSizelabel ) . addComponent ( fontSizeField , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addComponent ( consoleFontSizeLabel ) . addComponent ( consoleFontSizeField , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( backgroundColorLabel ) . addComponent ( hashLabel , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addGap ( 0 ) . addComponent ( presentColorHex , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addComponent ( presentColor , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) ) . addComponent ( editorAntialiasBox ) . addComponent ( inputMethodBox ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( errorCheckerBox ) . addComponent ( warningsCheckerBox ) ) . addComponent ( codeCompletionBox ) . addComponent ( importSuggestionsBox ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( memoryOverrideBox ) . addComponent ( memoryField , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) . addComponent ( mbLabel ) ) . addComponent ( deletePreviousBox ) . addComponent ( checkUpdatesBox ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( displayLabel ) . addComponent ( displaySelectionBox , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) ) . addComponent ( autoAssociateBox ) . addComponent ( morePreferenceLabel ) . addComponent ( preferencePathLabel ) . addComponent ( preferenceHintLabel ) . addGroup ( GroupLayout . Alignment . TRAILING , layout . createSequentialGroup ( ) . addComponent ( okButton , BUTTON_WIDTH , GroupLayout . DEFAULT_SIZE , BUTTON_WIDTH ) . addComponent ( cancelButton , BUTTON_WIDTH , GroupLayout . DEFAULT_SIZE , BUTTON_WIDTH ) ) ) . addGap ( BORDER ) ) ; layout . setVerticalGroup ( layout . createSequentialGroup ( ) . addGap ( BORDER ) . addComponent ( sketchbookLocationLabel ) . addGroup ( layout . createParallelGroup ( ) . addComponent ( sketchbookLocationField ) . addComponent ( browseButton ) ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . CENTER ) . addComponent ( languageLabel ) . addComponent ( languageSelectionBox ) . addComponent ( restartProcessingLabel ) ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . CENTER ) . addComponent ( fontLabel ) . addComponent ( fontSelectionBox ) ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . CENTER ) . addComponent ( fontSizelabel ) . addComponent ( fontSizeField ) . addComponent ( consoleFontSizeLabel ) . addComponent ( consoleFontSizeField ) ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . CENTER ) . addComponent ( backgroundColorLabel ) . addComponent ( hashLabel ) . addComponent ( presentColorHex ) . addComponent ( presentColor ) ) . addComponent ( editorAntialiasBox ) . addComponent ( inputMethodBox ) . addGroup ( layout . createParallelGroup ( ) . addComponent ( errorCheckerBox ) . addComponent ( warningsCheckerBox ) ) . addComponent ( codeCompletionBox ) . addComponent ( importSuggestionsBox ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . CENTER ) . addComponent ( memoryOverrideBox ) . addComponent ( memoryField ) . addComponent ( mbLabel ) ) . addComponent ( deletePreviousBox ) . addComponent ( checkUpdatesBox ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . CENTER ) . addComponent ( displayLabel ) . addComponent ( displaySelectionBox ) ) . addComponent ( autoAssociateBox ) . addComponent ( morePreferenceLabel ) . addGap ( 0 ) . addComponent ( preferencePathLabel ) . addGap ( 0 ) . addComponent ( preferenceHintLabel ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . CENTER ) . addComponent ( okButton ) . addComponent ( cancelButton ) ) . addGap ( BORDER ) ) ; if ( Base . isWindows ( ) ) { autoAssociateBox . setVisible ( true ) ; } frame . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { disposeFrame ( ) ; } } ) ; ActionListener disposer = new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { disposeFrame ( ) ; } } ; Toolkit . registerWindowCloseKeys ( frame . getRootPane ( ) , disposer ) ; Toolkit . setIcon ( frame ) ; frame . setResizable ( false ) ; frame . pack ( ) ; frame . setLocationRelativeTo ( null ) ; fontSizeField . setEditable ( true ) ; consoleFontSizeField . setEditable ( true ) ; pain . addKeyListener ( new KeyAdapter ( ) { public void keyPressed ( KeyEvent e ) { KeyStroke wc = Toolkit . WINDOW_CLOSE_KEYSTROKE ; if ( ( e . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) || ( KeyStroke . getKeyStrokeForEvent ( e ) . equals ( wc ) ) ) { disposeFrame ( ) ; } } } ) ; } public void sketchbookCallback ( File file ) { if ( file != null ) { sketchbookLocationField . setText ( file . getAbsolutePath ( ) ) ; } } protected void disposeFrame ( ) { frame . dispose ( ) ; } protected void applyFrame ( ) { Preferences . setBoolean ( "editor.smooth" , editorAntialiasBox . isSelected ( ) ) ; Preferences . setBoolean ( "export.delete_target_folder" , deletePreviousBox . isSelected ( ) ) ; String oldPath = Preferences . getSketchbookPath ( ) ; String newPath = sketchbookLocationField . getText ( ) ; if ( ! newPath . equals ( oldPath ) ) { base . setSketchbookFolder ( new File ( newPath ) ) ; } Preferences . setBoolean ( "update.check" , checkUpdatesBox . isSelected ( ) ) ; Map < String , String > languages = Language . getLanguages ( ) ; String language = "" ; for ( Map . Entry < String , String > lang : languages . entrySet ( ) ) { if ( lang . getValue ( ) . equals ( String . valueOf ( languageSelectionBox . getSelectedItem ( ) ) ) ) { language = lang . getKey ( ) . trim ( ) . toLowerCase ( ) ; break ; } } if ( ! language . equals ( Language . getLanguage ( ) ) && ! language . equals ( "" ) ) { Language . saveLanguage ( language ) ; } if ( displaySelectionBox . isEnabled ( ) ) { int oldDisplayNum = Preferences . getInteger ( "run.display" ) ; int displayNum = - 1 ; for ( int d = 0 ; d < displaySelectionBox . getItemCount ( ) ; d ++ ) { if ( displaySelectionBox . getSelectedIndex ( ) == d ) { displayNum = d + 1 ; } } if ( ( displayNum != - 1 ) && ( displayNum != oldDisplayNum ) ) { Preferences . setInteger ( "run.display" , displayNum ) ; for ( Editor editor : base . getEditors ( ) ) { editor . setSketchLocation ( null ) ; } } } Preferences . setBoolean ( "run.options.memory" , memoryOverrideBox . isSelected ( ) ) ; int memoryMin = Preferences . getInteger ( "run.options.memory.initial" ) ; int memoryMax = Preferences . getInteger ( "run.options.memory.maximum" ) ; try { memoryMax = Integer . parseInt ( memoryField . getText ( ) . trim ( ) ) ; if ( memoryMax < memoryMin ) memoryMax = memoryMin ; Preferences . setInteger ( "run.options.memory.maximum" , memoryMax ) ; } catch ( NumberFormatException e ) { System . err . println ( "Ignoring bad memory setting" ) ; } if ( fontSelectionBox . isEnabled ( ) ) { String fontFamily = ( String ) fontSelectionBox . getSelectedItem ( ) ; Preferences . set ( "editor.font.family" , fontFamily ) ; } try { Object selection = fontSizeField . getSelectedItem ( ) ; if ( selection instanceof String ) { selection = Integer . parseInt ( ( String ) selection ) ; } Preferences . set ( "editor.font.size" , String . valueOf ( selection ) ) ; } catch ( NumberFormatException e ) { Base . log ( "Ignoring invalid font size " + fontSizeField ) ; fontSizeField . setSelectedItem ( Preferences . getInteger ( "editor.font.size" ) ) ; } try { Object selection = consoleFontSizeField . getSelectedItem ( ) ; if ( selection instanceof String ) { selection = Integer . parseInt ( ( String ) selection ) ; } Preferences . set ( "console.font.size" , String . valueOf ( selection ) ) ; } catch ( NumberFormatException e ) { Base . log ( "Ignoring invalid font size " + consoleFontSizeField ) ; consoleFontSizeField . setSelectedItem ( Preferences . getInteger ( "console.font.size" ) ) ; } Preferences . setColor ( "run.present.bgcolor" , presentColor . getBackground ( ) ) ; Preferences . setBoolean ( "editor.input_method_support" , inputMethodBox . isSelected ( ) ) ; if ( autoAssociateBox != null ) { Preferences . setBoolean ( "platform.auto_file_type_associations" , autoAssociateBox . isSelected ( ) ) ; } Preferences . setBoolean ( "pdex.errorCheckEnabled" , errorCheckerBox . isSelected ( ) ) ; Preferences . setBoolean ( "pdex.warningsEnabled" , warningsCheckerBox . isSelected ( ) ) ; Preferences . setBoolean ( "pdex.completion" , codeCompletionBox . isSelected ( ) ) ; Preferences . setBoolean ( "pdex.importSuggestEnabled" , importSuggestionsBox . isSelected ( ) ) ; for ( Editor editor : base . getEditors ( ) ) { editor . applyPreferences ( ) ; } } protected void showFrame ( ) { editorAntialiasBox . setSelected ( Preferences . getBoolean ( "editor.smooth" ) ) ; inputMethodBox . setSelected ( Preferences . getBoolean ( "editor.input_method_support" ) ) ; errorCheckerBox . setSelected ( Preferences . getBoolean ( "pdex.errorCheckEnabled" ) ) ; warningsCheckerBox . setSelected ( Preferences . getBoolean ( "pdex.warningsEnabled" ) ) ; codeCompletionBox . setSelected ( Preferences . getBoolean ( "pdex.completion" ) ) ; importSuggestionsBox . setSelected ( Preferences . getBoolean ( "pdex.importSuggestEnabled" ) ) ; deletePreviousBox . setSelected ( Preferences . getBoolean ( "export.delete_target_folder" ) ) ; sketchbookLocationField . setText ( Preferences . getSketchbookPath ( ) ) ; checkUpdatesBox . setSelected ( Preferences . getBoolean ( "update.check" ) ) ; int defaultDisplayNum = updateDisplayList ( ) ; int displayNum = Preferences . getInteger ( "run.display" ) ; if ( displayNum < 1 || displayNum > displayCount ) { displayNum = defaultDisplayNum ; Preferences . setInteger ( "run.display" , displayNum ) ; } displaySelectionBox . setSelectedIndex ( displayNum - 1 ) ; new Thread ( new Runnable ( ) { public void run ( ) { initFontList ( ) ; } } ) . start ( ) ; fontSizeField . setSelectedItem ( Preferences . getInteger ( "editor.font.size" ) ) ; consoleFontSizeField . setSelectedItem ( Preferences . getInteger ( "console.font.size" ) ) ; presentColor . setBackground ( Preferences . getColor ( "run.present.bgcolor" ) ) ; presentColorHex . setText ( Preferences . get ( "run.present.bgcolor" ) . substring ( 1 ) ) ; memoryOverrideBox . setSelected ( Preferences . getBoolean ( "run.options.memory" ) ) ; memoryField . setText ( Preferences . get ( "run.options.memory.maximum" ) ) ; memoryField . setEnabled ( memoryOverrideBox . isSelected ( ) ) ; if ( autoAssociateBox != null ) { autoAssociateBox . setSelected ( Preferences . getBoolean ( "platform.auto_file_type_associations" ) ) ; } frame . getRootPane ( ) . setDefaultButton ( okButton ) ; frame . pack ( ) ; frame . setVisible ( true ) ; } static class FontNamer extends JLabel implements ListCellRenderer < Font > { public Component getListCellRendererComponent ( JList < ? extends Font > list , Font value , int index , boolean isSelected , boolean cellHasFocus ) { setText ( value . getFamily ( ) + " / " + value . getName ( ) + " (" + value . getPSName ( ) + ")" ) ; return this ; } } void initFontList ( ) { if ( monoFontFamilies == null ) { monoFontFamilies = Toolkit . getMonoFontFamilies ( ) ; EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { fontSelectionBox . setModel ( new DefaultComboBoxModel < String > ( monoFontFamilies ) ) ; String family = Preferences . get ( "editor.font.family" ) ; fontSelectionBox . setSelectedItem ( "Monospaced" ) ; fontSelectionBox . setSelectedItem ( family ) ; fontSelectionBox . setEnabled ( true ) ; } } ) ; } } int updateDisplayList ( ) { GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice defaultDevice = ge . getDefaultScreenDevice ( ) ; GraphicsDevice [ ] devices = ge . getScreenDevices ( ) ; int defaultNum = - 1 ; displayCount = devices . length ; String [ ] items = new String [ displayCount ] ; for ( int i = 0 ; i < displayCount ; i ++ ) { DisplayMode mode = devices [ i ] . getDisplayMode ( ) ; String title = String . format ( "%d (%d \u2715 %d)" , i + 1 , mode . getWidth ( ) , mode . getHeight ( ) ) ; if ( devices [ i ] == defaultDevice ) { title += " default" ; defaultNum = i + 1 ; } items [ i ] = title ; } displaySelectionBox . setModel ( new DefaultComboBoxModel < String > ( items ) ) ; displaySelectionBox . setEnabled ( displayCount != 1 ) ; return defaultNum ; } }
package processing . app ; public interface Formatter { public String format ( String text ) ; }
package processing . app ; import java . awt . Desktop ; import java . io . File ; import java . io . IOException ; import java . net . URI ; import javax . swing . UIManager ; import com . sun . jna . Library ; import com . sun . jna . Native ; import com . sun . jna . platform . FileUtils ; public class Platform { Base base ; public void init ( Base base ) { this . base = base ; } public void setLookAndFeel ( ) throws Exception { String laf = Preferences . get ( "editor.laf" ) ; if ( laf == null || laf . length ( ) == 0 ) { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } else { UIManager . setLookAndFeel ( laf ) ; } } public void saveLanguage ( String languageCode ) { } public File getSettingsFolder ( ) throws Exception { File home = new File ( System . getProperty ( "user.home" ) ) ; return new File ( home , ".processing" ) ; } public File getDefaultSketchbookFolder ( ) throws Exception { return new File ( System . getProperty ( "user.home" ) , "sketchbook" ) ; } public void openURL ( String url ) throws Exception { Desktop . getDesktop ( ) . browse ( new URI ( url ) ) ; } public boolean openFolderAvailable ( ) { return Desktop . isDesktopSupported ( ) ; } public void openFolder ( File file ) throws Exception { Desktop . getDesktop ( ) . open ( file ) ; } final public boolean deleteFile ( File file ) throws IOException { FileUtils fu = FileUtils . getInstance ( ) ; if ( fu . hasTrash ( ) ) { fu . moveToTrash ( new File [ ] { file } ) ; return true ; } else if ( file . isDirectory ( ) ) { Base . removeDir ( file ) ; return true ; } else { return file . delete ( ) ; } } public interface CLibrary extends Library { CLibrary INSTANCE = ( CLibrary ) Native . loadLibrary ( "c" , CLibrary . class ) ; int setenv ( String name , String value , int overwrite ) ; String getenv ( String name ) ; int unsetenv ( String name ) ; int putenv ( String string ) ; } public void setenv ( String variable , String value ) { CLibrary clib = CLibrary . INSTANCE ; clib . setenv ( variable , value , 1 ) ; } public String getenv ( String variable ) { CLibrary clib = CLibrary . INSTANCE ; return clib . getenv ( variable ) ; } public int unsetenv ( String variable ) { CLibrary clib = CLibrary . INSTANCE ; return clib . unsetenv ( variable ) ; } }
package processing . app ; import java . io . * ; import java . util . * ; import processing . core . PApplet ; public class Language { static protected final String PREF_FILE = "language.txt" ; static protected final File prefFile = Base . getSettingsFile ( PREF_FILE ) ; static private volatile Language instance ; private String language ; private HashMap < String , String > languages ; private LanguageBundle bundle ; private Language ( ) { String systemLanguage = Locale . getDefault ( ) . getLanguage ( ) ; language = loadLanguage ( ) ; boolean writePrefs = false ; if ( language == null ) { language = systemLanguage ; writePrefs = true ; } languages = new HashMap < String , String > ( ) ; for ( String code : listSupported ( ) ) { Locale locale = Locale . forLanguageTag ( code ) ; languages . put ( code , locale . getDisplayLanguage ( locale ) ) ; } if ( ! languages . containsKey ( language ) ) { language = "en" ; writePrefs = true ; } if ( writePrefs ) { saveLanguage ( language ) ; } try { bundle = new LanguageBundle ( language ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } static private String [ ] listSupported ( ) { final String [ ] SUPPORTED = { "de" , "en" , "el" , "es" , "fr" , "ja" , "ko" , "nl" , "pt" , "tr" , "zh" } ; return SUPPORTED ; } static private String loadLanguage ( ) { try { if ( prefFile . exists ( ) ) { String language = PApplet . loadStrings ( prefFile ) [ 0 ] ; language = language . trim ( ) . toLowerCase ( ) ; if ( language . trim ( ) . length ( ) != 0 ) { return language ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } static public void saveLanguage ( String language ) { try { Base . saveFile ( language , prefFile ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } Base . getPlatform ( ) . saveLanguage ( language ) ; } static public Language init ( ) { if ( instance == null ) { synchronized ( Language . class ) { if ( instance == null ) { instance = new Language ( ) ; } } } return instance ; } static private String get ( String key ) { LanguageBundle bundle = init ( ) . bundle ; try { String value = bundle . getString ( key ) ; if ( value != null ) { return value ; } } catch ( MissingResourceException e ) { } return null ; } static public String text ( String key ) { String value = get ( key ) ; if ( value == null ) { return key ; } return value ; } static public String interpolate ( String key , Object ... arguments ) { String value = get ( key ) ; if ( value == null ) { return key ; } return String . format ( value , arguments ) ; } static public String pluralize ( String key , int count ) { String customKey = key + "." + count ; String value = get ( customKey ) ; if ( value != null ) { return String . format ( value , count ) ; } return interpolate ( key + ".n" , count ) ; } static public Map < String , String > getLanguages ( ) { return init ( ) . languages ; } static public String getLanguage ( ) { return init ( ) . language ; } static class LanguageBundle { Map < String , String > table ; LanguageBundle ( String language ) throws IOException { table = new HashMap < String , String > ( ) ; String baseFilename = "languages/PDE.properties" ; String langFilename = "languages/PDE_" + language + ".properties" ; File baseFile = Base . getLibFile ( baseFilename ) ; File userBaseFile = new File ( Base . getSketchbookFolder ( ) , baseFilename ) ; if ( userBaseFile . exists ( ) ) { baseFile = userBaseFile ; } File langFile = Base . getLibFile ( langFilename ) ; File userLangFile = new File ( Base . getSketchbookFolder ( ) , langFilename ) ; if ( userLangFile . exists ( ) ) { langFile = userLangFile ; } read ( baseFile ) ; read ( langFile ) ; } void read ( File additions ) { String [ ] lines = PApplet . loadStrings ( additions ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { String line = lines [ i ] ; if ( ( line . length ( ) == 0 ) || ( line . charAt ( 0 ) == '#' ) ) continue ; int equals = line . indexOf ( '=' ) ; if ( equals != - 1 ) { String key = line . substring ( 0 , equals ) . trim ( ) ; String value = line . substring ( equals + 1 ) . trim ( ) ; value = value . replaceAll ( "\\\\n" , "\n" ) ; value = value . replaceAll ( "\\\\'" , "'" ) ; table . put ( key , value ) ; } } } String getString ( String key ) { return table . get ( key ) ; } boolean containsKey ( String key ) { return table . containsKey ( key ) ; } } }
package processing . app ; import java . awt . CardLayout ; import java . awt . Color ; import java . awt . Component ; import java . awt . Dimension ; import java . awt . Font ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . Image ; import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; import java . util . ArrayList ; import java . util . List ; import javax . swing . * ; public class EditorFooter extends Box { static final int HIGH = 29 ; static final int CURVE_RADIUS = 6 ; static final int TAB_TOP = 0 ; static final int TAB_BOTTOM = 23 ; static final int TAB_BETWEEN = 3 ; static final int TEXT_MARGIN = 16 ; Color [ ] textColor = new Color [ 2 ] ; Color [ ] tabColor = new Color [ 2 ] ; Color errorColor ; Editor editor ; List < Tab > tabs = new ArrayList < > ( ) ; Font font ; int fontAscent ; JMenu menu ; JPopupMenu popup ; static final int UNSELECTED = 0 ; static final int SELECTED = 1 ; Image offscreen ; int sizeW , sizeH ; int imageW , imageH ; Image gradient ; JPanel cardPanel ; CardLayout cardLayout ; Controller controller ; public EditorFooter ( Editor eddie ) { super ( BoxLayout . Y_AXIS ) ; this . editor = eddie ; updateMode ( ) ; cardLayout = new CardLayout ( ) ; cardPanel = new JPanel ( cardLayout ) ; add ( cardPanel ) ; controller = new Controller ( ) ; add ( controller ) ; } public void addPanel ( String name , Component comp ) { tabs . add ( new Tab ( name , comp ) ) ; cardPanel . add ( name , comp ) ; } public void setPanel ( Component comp ) { for ( Tab tab : tabs ) { if ( tab . comp == comp ) { cardLayout . show ( cardPanel , tab . name ) ; repaint ( ) ; } } } public void setNotification ( Component comp , boolean note ) { for ( Tab tab : tabs ) { if ( tab . comp == comp ) { tab . notification = note ; repaint ( ) ; } } } public void updateMode ( ) { Mode mode = editor . getMode ( ) ; textColor [ SELECTED ] = mode . getColor ( "footer.text.selected.color" ) ; textColor [ UNSELECTED ] = mode . getColor ( "footer.text.unselected.color" ) ; font = mode . getFont ( "footer.text.font" ) ; tabColor [ SELECTED ] = mode . getColor ( "footer.tab.selected.color" ) ; tabColor [ UNSELECTED ] = mode . getColor ( "footer.tab.unselected.color" ) ; errorColor = mode . getColor ( "status.error.bgcolor" ) ; gradient = mode . makeGradient ( "footer" , 400 , HIGH ) ; } class Controller extends JComponent { Controller ( ) { addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent e ) { int x = e . getX ( ) ; for ( Tab tab : tabs ) { if ( tab . contains ( x ) ) { cardLayout . show ( cardPanel , tab . name ) ; repaint ( ) ; } } } } ) ; } public void paintComponent ( Graphics screen ) { if ( screen == null ) return ; Sketch sketch = editor . getSketch ( ) ; if ( sketch == null ) return ; Dimension size = getSize ( ) ; if ( ( size . width != sizeW ) || ( size . height != sizeH ) ) { if ( ( size . width > imageW ) || ( size . height > imageH ) ) { offscreen = null ; } else { sizeW = size . width ; sizeH = size . height ; } } if ( offscreen == null ) { sizeW = size . width ; sizeH = size . height ; imageW = sizeW ; imageH = sizeH ; if ( Toolkit . highResDisplay ( ) ) { offscreen = createImage ( imageW * 2 , imageH * 2 ) ; } else { offscreen = createImage ( imageW , imageH ) ; } } Graphics g = offscreen . getGraphics ( ) ; g . setFont ( font ) ; if ( fontAscent == 0 ) { fontAscent = ( int ) Toolkit . getAscent ( g ) ; } Graphics2D g2 = Toolkit . prepareGraphics ( g ) ; g . drawImage ( gradient , 0 , 0 , imageW , imageH , this ) ; for ( Tab tab : tabs ) { tab . textWidth = ( int ) font . getStringBounds ( tab . name , g2 . getFontRenderContext ( ) ) . getWidth ( ) ; } placeTabs ( Editor . LEFT_GUTTER , g2 ) ; screen . drawImage ( offscreen , 0 , 0 , imageW , imageH , null ) ; } private void placeTabs ( int left , Graphics2D g ) { int x = left ; for ( Tab tab : tabs ) { int state = tab . isCurrent ( ) ? SELECTED : UNSELECTED ; tab . left = x ; x += TEXT_MARGIN ; x += tab . textWidth + TEXT_MARGIN ; tab . right = x ; if ( g != null ) { g . setColor ( tabColor [ state ] ) ; if ( tab . notification ) { g . setColor ( errorColor ) ; } drawTab ( g , tab . left , tab . right , tab . isFirst ( ) , tab . isLast ( ) ) ; int textLeft = tab . left + ( ( tab . right - tab . left ) - tab . textWidth ) / 2 ; if ( tab . notification && state == UNSELECTED ) { g . setColor ( Color . LIGHT_GRAY ) ; } else { g . setColor ( textColor [ state ] ) ; } int tabHeight = TAB_BOTTOM - TAB_TOP ; int baseline = TAB_TOP + ( tabHeight + fontAscent ) / 2 ; g . drawString ( tab . name , textLeft , baseline ) ; } x += TAB_BETWEEN ; } } private void drawTab ( Graphics g , int left , int right , boolean leftNotch , boolean rightNotch ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . fill ( Toolkit . createRoundRect ( left , TAB_TOP , right , TAB_BOTTOM , 0 , 0 , rightNotch ? CURVE_RADIUS : 0 , leftNotch ? CURVE_RADIUS : 0 ) ) ; } public Dimension getPreferredSize ( ) { return new Dimension ( 300 , HIGH ) ; } public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } public Dimension getMaximumSize ( ) { return new Dimension ( super . getMaximumSize ( ) . width , HIGH ) ; } } class Tab { String name ; Component comp ; boolean notification ; int left ; int right ; int textWidth ; Tab ( String name , Component comp ) { this . name = name ; this . comp = comp ; } boolean contains ( int x ) { return x >= left && x <= right ; } boolean isCurrent ( ) { return comp . isVisible ( ) ; } boolean isFirst ( ) { return tabs . get ( 0 ) == this ; } boolean isLast ( ) { return tabs . get ( tabs . size ( ) - 1 ) == this ; } } }
package processing . app ; import java . awt . Frame ; import java . awt . GraphicsConfiguration ; import java . awt . GraphicsDevice ; import java . awt . GraphicsEnvironment ; import java . awt . Rectangle ; import java . io . * ; import java . util . List ; import processing . core . PApplet ; public class EditorState { Rectangle editorBounds ; int dividerLocation ; Rectangle deviceBounds ; boolean isMaximized ; static final int WINDOW_OFFSET = 28 ; EditorState ( List < Editor > editors ) { defaultConfig ( ) ; defaultLocation ( editors ) ; } EditorState ( String info ) throws IOException { String [ ] pieces = PApplet . split ( info , ',' ) ; editorBounds = new Rectangle ( Integer . parseInt ( pieces [ 0 ] ) , Integer . parseInt ( pieces [ 1 ] ) , Integer . parseInt ( pieces [ 2 ] ) , Integer . parseInt ( pieces [ 3 ] ) ) ; dividerLocation = Integer . parseInt ( pieces [ 4 ] ) ; deviceBounds = new Rectangle ( Integer . parseInt ( pieces [ 5 ] ) , Integer . parseInt ( pieces [ 6 ] ) , Integer . parseInt ( pieces [ 7 ] ) , Integer . parseInt ( pieces [ 8 ] ) ) ; } public String toString ( ) { return ( editorBounds . x + "," + editorBounds . y + "," + editorBounds . width + "," + editorBounds . height + "," + dividerLocation + "," + deviceBounds . x + "," + deviceBounds . y + "," + deviceBounds . width + "," + deviceBounds . height ) ; } GraphicsConfiguration checkConfig ( ) { if ( deviceBounds != null ) { GraphicsEnvironment graphicsEnvironment = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice [ ] screenDevices = graphicsEnvironment . getScreenDevices ( ) ; for ( GraphicsDevice device : screenDevices ) { GraphicsConfiguration [ ] configurations = device . getConfigurations ( ) ; for ( GraphicsConfiguration config : configurations ) { if ( config . getBounds ( ) . equals ( deviceBounds ) ) { return config ; } } } } return defaultConfig ( ) ; } GraphicsConfiguration defaultConfig ( ) { GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice device = ge . getDefaultScreenDevice ( ) ; GraphicsConfiguration config = device . getDefaultConfiguration ( ) ; deviceBounds = config . getBounds ( ) ; return config ; } void defaultLocation ( List < Editor > editors ) { int defaultWidth = Preferences . getInteger ( "editor.window.width.default" ) ; int defaultHeight = Preferences . getInteger ( "editor.window.height.default" ) ; if ( editors . size ( ) == 0 ) { int editorX = deviceBounds . x + ( deviceBounds . width - defaultWidth ) / 2 ; int editorY = deviceBounds . y + ( deviceBounds . height - defaultHeight ) / 2 ; editorBounds = new Rectangle ( editorX , editorY , defaultWidth , defaultHeight ) ; dividerLocation = 0 ; } else { synchronized ( editors ) { Editor lastOpened = editors . get ( editors . size ( ) - 1 ) ; isMaximized = ( lastOpened . getExtendedState ( ) == Frame . MAXIMIZED_BOTH ) ; editorBounds = lastOpened . getBounds ( ) ; editorBounds . x += WINDOW_OFFSET ; editorBounds . y += WINDOW_OFFSET ; dividerLocation = lastOpened . getDividerLocation ( ) ; if ( ! deviceBounds . contains ( editorBounds ) ) { editorBounds . x = deviceBounds . x + ( int ) ( Math . random ( ) * ( deviceBounds . width - defaultWidth ) ) ; editorBounds . y = deviceBounds . y + ( int ) ( Math . random ( ) * ( deviceBounds . height - defaultHeight ) ) ; } if ( isMaximized ) { editorBounds . width = defaultWidth ; editorBounds . height = defaultHeight ; } } } } void update ( Editor editor ) { editorBounds = editor . getBounds ( ) ; dividerLocation = editor . getDividerLocation ( ) ; GraphicsConfiguration config = editor . getGraphicsConfiguration ( ) ; deviceBounds = config . getBounds ( ) ; } void apply ( Editor editor ) { editor . setBounds ( editorBounds ) ; if ( dividerLocation != 0 ) { editor . setDividerLocation ( dividerLocation ) ; } if ( isMaximized ) { editor . setExtendedState ( Frame . MAXIMIZED_BOTH ) ; } } }
package processing . core ; public class PMatrix2D implements PMatrix { public float m00 , m01 , m02 ; public float m10 , m11 , m12 ; public PMatrix2D ( ) { reset ( ) ; } public PMatrix2D ( float m00 , float m01 , float m02 , float m10 , float m11 , float m12 ) { set ( m00 , m01 , m02 , m10 , m11 , m12 ) ; } public PMatrix2D ( PMatrix matrix ) { set ( matrix ) ; } public void reset ( ) { set ( 1 , 0 , 0 , 0 , 1 , 0 ) ; } public PMatrix2D get ( ) { PMatrix2D outgoing = new PMatrix2D ( ) ; outgoing . set ( this ) ; return outgoing ; } public float [ ] get ( float [ ] target ) { if ( ( target == null ) || ( target . length != 6 ) ) { target = new float [ 6 ] ; } target [ 0 ] = m00 ; target [ 1 ] = m01 ; target [ 2 ] = m02 ; target [ 3 ] = m10 ; target [ 4 ] = m11 ; target [ 5 ] = m12 ; return target ; } public void set ( PMatrix matrix ) { if ( matrix instanceof PMatrix2D ) { PMatrix2D src = ( PMatrix2D ) matrix ; set ( src . m00 , src . m01 , src . m02 , src . m10 , src . m11 , src . m12 ) ; } else { throw new IllegalArgumentException ( "PMatrix2D.set() only accepts PMatrix2D objects." ) ; } } public void set ( PMatrix3D src ) { } public void set ( float [ ] source ) { m00 = source [ 0 ] ; m01 = source [ 1 ] ; m02 = source [ 2 ] ; m10 = source [ 3 ] ; m11 = source [ 4 ] ; m12 = source [ 5 ] ; } public void set ( float m00 , float m01 , float m02 , float m10 , float m11 , float m12 ) { this . m00 = m00 ; this . m01 = m01 ; this . m02 = m02 ; this . m10 = m10 ; this . m11 = m11 ; this . m12 = m12 ; } public void set ( float m00 , float m01 , float m02 , float m03 , float m10 , float m11 , float m12 , float m13 , float m20 , float m21 , float m22 , float m23 , float m30 , float m31 , float m32 , float m33 ) { } public void translate ( float tx , float ty ) { m02 = tx * m00 + ty * m01 + m02 ; m12 = tx * m10 + ty * m11 + m12 ; } public void translate ( float x , float y , float z ) { throw new IllegalArgumentException ( "Cannot use translate(x, y, z) on a PMatrix2D." ) ; } public void rotate ( float angle ) { float s = sin ( angle ) ; float c = cos ( angle ) ; float temp1 = m00 ; float temp2 = m01 ; m00 = c * temp1 + s * temp2 ; m01 = - s * temp1 + c * temp2 ; temp1 = m10 ; temp2 = m11 ; m10 = c * temp1 + s * temp2 ; m11 = - s * temp1 + c * temp2 ; } public void rotateX ( float angle ) { throw new IllegalArgumentException ( "Cannot use rotateX() on a PMatrix2D." ) ; } public void rotateY ( float angle ) { throw new IllegalArgumentException ( "Cannot use rotateY() on a PMatrix2D." ) ; } public void rotateZ ( float angle ) { rotate ( angle ) ; } public void rotate ( float angle , float v0 , float v1 , float v2 ) { throw new IllegalArgumentException ( "Cannot use this version of rotate() on a PMatrix2D." ) ; } public void scale ( float s ) { scale ( s , s ) ; } public void scale ( float sx , float sy ) { m00 *= sx ; m01 *= sy ; m10 *= sx ; m11 *= sy ; } public void scale ( float x , float y , float z ) { throw new IllegalArgumentException ( "Cannot use this version of scale() on a PMatrix2D." ) ; } public void shearX ( float angle ) { apply ( 1 , 0 , 1 , tan ( angle ) , 0 , 0 ) ; } public void shearY ( float angle ) { apply ( 1 , 0 , 1 , 0 , tan ( angle ) , 0 ) ; } public void apply ( PMatrix source ) { if ( source instanceof PMatrix2D ) { apply ( ( PMatrix2D ) source ) ; } else if ( source instanceof PMatrix3D ) { apply ( ( PMatrix3D ) source ) ; } } public void apply ( PMatrix2D source ) { apply ( source . m00 , source . m01 , source . m02 , source . m10 , source . m11 , source . m12 ) ; } public void apply ( PMatrix3D source ) { throw new IllegalArgumentException ( "Cannot use apply(PMatrix3D) on a PMatrix2D." ) ; } public void apply ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) { float t0 = m00 ; float t1 = m01 ; m00 = n00 * t0 + n10 * t1 ; m01 = n01 * t0 + n11 * t1 ; m02 += n02 * t0 + n12 * t1 ; t0 = m10 ; t1 = m11 ; m10 = n00 * t0 + n10 * t1 ; m11 = n01 * t0 + n11 * t1 ; m12 += n02 * t0 + n12 * t1 ; } public void apply ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { throw new IllegalArgumentException ( "Cannot use this version of apply() on a PMatrix2D." ) ; } public void preApply ( PMatrix source ) { if ( source instanceof PMatrix2D ) { preApply ( ( PMatrix2D ) source ) ; } else if ( source instanceof PMatrix3D ) { preApply ( ( PMatrix3D ) source ) ; } } public void preApply ( PMatrix2D left ) { preApply ( left . m00 , left . m01 , left . m02 , left . m10 , left . m11 , left . m12 ) ; } public void preApply ( PMatrix3D left ) { throw new IllegalArgumentException ( "Cannot use preApply(PMatrix3D) on a PMatrix2D." ) ; } public void preApply ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) { float t0 = m02 ; float t1 = m12 ; n02 += t0 * n00 + t1 * n01 ; n12 += t0 * n10 + t1 * n11 ; m02 = n02 ; m12 = n12 ; t0 = m00 ; t1 = m10 ; m00 = t0 * n00 + t1 * n01 ; m10 = t0 * n10 + t1 * n11 ; t0 = m01 ; t1 = m11 ; m01 = t0 * n00 + t1 * n01 ; m11 = t0 * n10 + t1 * n11 ; } public void preApply ( float n00 , float n01 , float n02 , float n03 , float n10 , float n11 , float n12 , float n13 , float n20 , float n21 , float n22 , float n23 , float n30 , float n31 , float n32 , float n33 ) { throw new IllegalArgumentException ( "Cannot use this version of preApply() on a PMatrix2D." ) ; } public PVector mult ( PVector source , PVector target ) { if ( target == null ) { target = new PVector ( ) ; } target . x = m00 * source . x + m01 * source . y + m02 ; target . y = m10 * source . x + m11 * source . y + m12 ; return target ; } public float [ ] mult ( float vec [ ] , float out [ ] ) { if ( out == null || out . length != 2 ) { out = new float [ 2 ] ; } if ( vec == out ) { float tx = m00 * vec [ 0 ] + m01 * vec [ 1 ] + m02 ; float ty = m10 * vec [ 0 ] + m11 * vec [ 1 ] + m12 ; out [ 0 ] = tx ; out [ 1 ] = ty ; } else { out [ 0 ] = m00 * vec [ 0 ] + m01 * vec [ 1 ] + m02 ; out [ 1 ] = m10 * vec [ 0 ] + m11 * vec [ 1 ] + m12 ; } return out ; } public float multX ( float x , float y ) { return m00 * x + m01 * y + m02 ; } public float multY ( float x , float y ) { return m10 * x + m11 * y + m12 ; } public void transpose ( ) { } public boolean invert ( ) { float determinant = determinant ( ) ; if ( Math . abs ( determinant ) <= Float . MIN_VALUE ) { return false ; } float t00 = m00 ; float t01 = m01 ; float t02 = m02 ; float t10 = m10 ; float t11 = m11 ; float t12 = m12 ; m00 = t11 / determinant ; m10 = - t10 / determinant ; m01 = - t01 / determinant ; m11 = t00 / determinant ; m02 = ( t01 * t12 - t11 * t02 ) / determinant ; m12 = ( t10 * t02 - t00 * t12 ) / determinant ; return true ; } public float determinant ( ) { return m00 * m11 - m01 * m10 ; } public void print ( ) { int big = ( int ) abs ( max ( PApplet . max ( abs ( m00 ) , abs ( m01 ) , abs ( m02 ) ) , PApplet . max ( abs ( m10 ) , abs ( m11 ) , abs ( m12 ) ) ) ) ; int digits = 1 ; if ( Float . isNaN ( big ) || Float . isInfinite ( big ) ) { digits = 5 ; } else { while ( ( big /= 10 ) != 0 ) digits ++ ; } System . out . println ( PApplet . nfs ( m00 , digits , 4 ) + " " + PApplet . nfs ( m01 , digits , 4 ) + " " + PApplet . nfs ( m02 , digits , 4 ) ) ; System . out . println ( PApplet . nfs ( m10 , digits , 4 ) + " " + PApplet . nfs ( m11 , digits , 4 ) + " " + PApplet . nfs ( m12 , digits , 4 ) ) ; System . out . println ( ) ; } protected boolean isIdentity ( ) { return ( ( m00 == 1 ) && ( m01 == 0 ) && ( m02 == 0 ) && ( m10 == 0 ) && ( m11 == 1 ) && ( m12 == 0 ) ) ; } protected boolean isWarped ( ) { return ( ( m00 != 1 ) || ( m01 != 0 ) && ( m10 != 0 ) || ( m11 != 1 ) ) ; } static private final float max ( float a , float b ) { return ( a > b ) ? a : b ; } static private final float abs ( float a ) { return ( a < 0 ) ? - a : a ; } static private final float sin ( float angle ) { return ( float ) Math . sin ( angle ) ; } static private final float cos ( float angle ) { return ( float ) Math . cos ( angle ) ; } static private final float tan ( float angle ) { return ( float ) Math . tan ( angle ) ; } }
package processing . app ; import java . awt . * ; import java . io . * ; import java . util . * ; import processing . core . * ; public class Preferences { static final String DEFAULTS_FILE = "defaults.txt" ; static final String PREFS_FILE = "preferences.txt" ; static HashMap < String , String > defaults ; static HashMap < String , String > table = new HashMap < String , String > ( ) ; static File preferencesFile ; static final String PROMPT_YES = Language . text ( "prompt.yes" ) ; static final String PROMPT_NO = Language . text ( "prompt.no" ) ; static final String PROMPT_CANCEL = Language . text ( "prompt.cancel" ) ; static final String PROMPT_OK = Language . text ( "prompt.ok" ) ; static final String PROMPT_BROWSE = Language . text ( "prompt.browse" ) ; static public int BUTTON_WIDTH = Integer . parseInt ( Language . text ( "preferences.button.width" ) ) ; static final int GUI_BIG = 13 ; static final int GUI_BETWEEN = 8 ; static final int GUI_SMALL = 6 ; static public void init ( ) { try { load ( Base . getLibStream ( DEFAULTS_FILE ) ) ; } catch ( Exception e ) { Base . showError ( null , "Could not read default settings.\n" + "You'll need to reinstall Processing." , e ) ; } defaults = new HashMap < String , String > ( table ) ; setColor ( "run.window.bgcolor" , SystemColor . control ) ; preferencesFile = Base . getSettingsFile ( PREFS_FILE ) ; if ( preferencesFile . exists ( ) ) { try { load ( new FileInputStream ( preferencesFile ) ) ; } catch ( Exception ex ) { Base . showError ( "Error reading preferences" , "Error reading the preferences file. " + "Please delete (or move)\n" + preferencesFile . getAbsolutePath ( ) + " and restart Processing." , ex ) ; } } if ( checkSketchbookPref ( ) || ! preferencesFile . exists ( ) ) { save ( ) ; } PApplet . useNativeSelect = Preferences . getBoolean ( "chooser.files.native" ) ; System . setProperty ( "java.net.useSystemProxies" , "true" ) ; handleProxy ( "http" , "http.proxyHost" , "http.proxyPort" ) ; handleProxy ( "https" , "https.proxyHost" , "https.proxyPort" ) ; handleProxy ( "socks" , "socksProxyHost" , "socksProxyPort" ) ; } static void handleProxy ( String protocol , String hostProp , String portProp ) { String proxyHost = get ( "proxy." + protocol + ".host" ) ; String proxyPort = get ( "proxy." + protocol + ".port" ) ; if ( proxyHost != null && proxyHost . length ( ) != 0 && proxyPort != null && proxyPort . length ( ) != 0 ) { System . setProperty ( hostProp , proxyHost ) ; System . setProperty ( portProp , proxyPort ) ; } } static protected String getPreferencesPath ( ) { return preferencesFile . getAbsolutePath ( ) ; } static public void load ( InputStream input ) throws IOException { HashMap < String , String > platformSpecific = new HashMap < > ( ) ; String [ ] lines = PApplet . loadStrings ( input ) ; for ( String line : lines ) { if ( ( line . length ( ) == 0 ) || ( line . charAt ( 0 ) == '#' ) ) continue ; int equals = line . indexOf ( '=' ) ; if ( equals != - 1 ) { String key = line . substring ( 0 , equals ) . trim ( ) ; String value = line . substring ( equals + 1 ) . trim ( ) ; if ( ! isPlatformSpecific ( key , value , platformSpecific ) ) { table . put ( key , value ) ; } } } for ( String key : platformSpecific . keySet ( ) ) { table . put ( key , platformSpecific . get ( key ) ) ; } } static protected boolean isPlatformSpecific ( String key , String value , Map < String , String > specific ) { for ( String platform : PConstants . platformNames ) { String ext = "." + platform ; if ( key . endsWith ( ext ) ) { String thisPlatform = PConstants . platformNames [ PApplet . platform ] ; if ( platform . equals ( thisPlatform ) ) { key = key . substring ( 0 , key . lastIndexOf ( ext ) ) ; specific . put ( key , value ) ; } else { } return true ; } } return false ; } static protected void save ( ) { if ( preferencesFile == null ) return ; PrintWriter writer = PApplet . createWriter ( preferencesFile ) ; String [ ] keyList = table . keySet ( ) . toArray ( new String [ table . size ( ) ] ) ; keyList = PApplet . sort ( keyList ) ; for ( String key : keyList ) { writer . println ( key + "=" + table . get ( key ) ) ; } writer . flush ( ) ; writer . close ( ) ; } static public String get ( String attribute ) { return table . get ( attribute ) ; } static public String getDefault ( String attribute ) { return defaults . get ( attribute ) ; } static public void set ( String attribute , String value ) { table . put ( attribute , value ) ; } static public void unset ( String attribute ) { table . remove ( attribute ) ; } static public boolean getBoolean ( String attribute ) { String value = get ( attribute ) ; return Boolean . parseBoolean ( value ) ; } static public void setBoolean ( String attribute , boolean value ) { set ( attribute , value ? "true" : "false" ) ; } static public int getInteger ( String attribute ) { return Integer . parseInt ( get ( attribute ) ) ; } static public void setInteger ( String key , int value ) { set ( key , String . valueOf ( value ) ) ; } static public Color getColor ( String name ) { Color parsed = Color . GRAY ; String s = get ( name ) ; if ( ( s != null ) && ( s . indexOf ( "#" ) == 0 ) ) { try { parsed = new Color ( Integer . parseInt ( s . substring ( 1 ) , 16 ) ) ; } catch ( Exception e ) { } } return parsed ; } static public void setColor ( String attr , Color what ) { set ( attr , "#" + PApplet . hex ( what . getRGB ( ) & 0xffffff , 6 ) ) ; } static public Font getFont ( String attr ) { try { boolean replace = false ; String value = get ( attr ) ; if ( value == null ) { value = getDefault ( attr ) ; replace = true ; } String [ ] pieces = PApplet . split ( value , ',' ) ; if ( pieces . length != 3 ) { value = getDefault ( attr ) ; pieces = PApplet . split ( value , ',' ) ; replace = true ; } String name = pieces [ 0 ] ; int style = Font . PLAIN ; if ( pieces [ 1 ] . indexOf ( "bold" ) != - 1 ) { style |= Font . BOLD ; } if ( pieces [ 1 ] . indexOf ( "italic" ) != - 1 ) { style |= Font . ITALIC ; } int size = PApplet . parseInt ( pieces [ 2 ] , 12 ) ; if ( replace ) { set ( attr , value ) ; } if ( ! name . startsWith ( "processing." ) ) { return new Font ( name , style , size ) ; } else { if ( pieces [ 0 ] . equals ( "processing.sans" ) ) { return Toolkit . getSansFont ( size , style ) ; } else if ( pieces [ 0 ] . equals ( "processing.mono" ) ) { return Toolkit . getMonoFont ( size , style ) ; } } } catch ( Exception e ) { Base . log ( "Error with font " + get ( attr ) + " for attribute " + attr ) ; } return new Font ( "Dialog" , Font . PLAIN , 12 ) ; } static protected boolean checkSketchbookPref ( ) { if ( getSketchbookPath ( ) == null ) { String twoPath = get ( "sketchbook.path" ) ; if ( twoPath != null ) { setSketchbookPath ( twoPath ) ; return true ; } } return false ; } static protected String getSketchbookPath ( ) { return get ( "sketchbook.path.three" ) ; } static protected void setSketchbookPath ( String path ) { set ( "sketchbook.path.three" , path ) ; } }
package processing . app ; import java . awt . * ; import java . awt . event . * ; import java . awt . geom . GeneralPath ; import java . util . Arrays ; import javax . swing . * ; public class EditorHeader extends JComponent { static final int HIGH = 29 ; static final int ARROW_TAB_WIDTH = 18 ; static final int ARROW_TOP = 11 ; static final int ARROW_BOTTOM = 18 ; static final int ARROW_WIDTH = 6 ; static final int CURVE_RADIUS = 6 ; static final int TAB_TOP = 0 ; static final int TAB_BOTTOM = 27 ; static final int TAB_BETWEEN = 3 ; static final int TEXT_MARGIN = 16 ; static final int NO_TEXT_WIDTH = 16 ; Color textColor [ ] = new Color [ 2 ] ; Color tabColor [ ] = new Color [ 2 ] ; Color modifiedColor ; Color arrowColor ; Editor editor ; Tab [ ] tabs = new Tab [ 0 ] ; Tab [ ] visitOrder ; Font font ; int fontAscent ; JMenu menu ; JPopupMenu popup ; int menuLeft ; int menuRight ; static final int UNSELECTED = 0 ; static final int SELECTED = 1 ; Image offscreen ; int sizeW , sizeH ; int imageW , imageH ; String lastNoticeName ; Image gradient ; public EditorHeader ( Editor eddie ) { this . editor = eddie ; updateMode ( ) ; addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent e ) { int x = e . getX ( ) ; int y = e . getY ( ) ; if ( ( x > menuLeft ) && ( x < menuRight ) ) { popup . show ( EditorHeader . this , x , y ) ; } else { Sketch sketch = editor . getSketch ( ) ; for ( Tab tab : tabs ) { if ( tab . contains ( x ) ) { sketch . setCurrentCode ( tab . index ) ; repaint ( ) ; } } } } public void mouseExited ( MouseEvent e ) { if ( lastNoticeName != null ) { editor . clearNotice ( lastNoticeName ) ; lastNoticeName = null ; } } } ) ; addMouseMotionListener ( new MouseMotionAdapter ( ) { public void mouseMoved ( MouseEvent e ) { int x = e . getX ( ) ; for ( Tab tab : tabs ) { if ( tab . contains ( x ) && ! tab . textVisible ) { lastNoticeName = editor . getSketch ( ) . getCode ( tab . index ) . getPrettyName ( ) ; editor . statusNotice ( lastNoticeName ) ; } } } } ) ; } public void updateMode ( ) { Mode mode = editor . getMode ( ) ; textColor [ SELECTED ] = mode . getColor ( "header.text.selected.color" ) ; textColor [ UNSELECTED ] = mode . getColor ( "header.text.unselected.color" ) ; font = mode . getFont ( "header.text.font" ) ; tabColor [ SELECTED ] = mode . getColor ( "header.tab.selected.color" ) ; tabColor [ UNSELECTED ] = mode . getColor ( "header.tab.unselected.color" ) ; arrowColor = mode . getColor ( "header.tab.arrow.color" ) ; modifiedColor = mode . getColor ( "editor.selection.color" ) ; gradient = mode . makeGradient ( "header" , 400 , HIGH ) ; } public void paintComponent ( Graphics screen ) { if ( screen == null ) return ; Sketch sketch = editor . getSketch ( ) ; if ( sketch == null ) return ; Dimension size = getSize ( ) ; if ( ( size . width != sizeW ) || ( size . height != sizeH ) ) { if ( ( size . width > imageW ) || ( size . height > imageH ) ) { offscreen = null ; } else { sizeW = size . width ; sizeH = size . height ; } } if ( offscreen == null ) { sizeW = size . width ; sizeH = size . height ; imageW = sizeW ; imageH = sizeH ; if ( Toolkit . highResDisplay ( ) ) { offscreen = createImage ( imageW * 2 , imageH * 2 ) ; } else { offscreen = createImage ( imageW , imageH ) ; } } Graphics g = offscreen . getGraphics ( ) ; g . setFont ( font ) ; if ( fontAscent == 0 ) { fontAscent = ( int ) Toolkit . getAscent ( g ) ; } Graphics2D g2 = Toolkit . prepareGraphics ( g ) ; g . drawImage ( gradient , 0 , 0 , imageW , imageH , this ) ; if ( tabs . length != sketch . getCodeCount ( ) ) { tabs = new Tab [ sketch . getCodeCount ( ) ] ; for ( int i = 0 ; i < tabs . length ; i ++ ) { tabs [ i ] = new Tab ( i ) ; } visitOrder = new Tab [ sketch . getCodeCount ( ) - 1 ] ; } int leftover = TAB_BETWEEN + ARROW_TAB_WIDTH ; int tabMax = getWidth ( ) - leftover ; for ( Tab tab : tabs ) { SketchCode code = sketch . getCode ( tab . index ) ; tab . textVisible = true ; tab . lastVisited = code . lastVisited ( ) ; boolean hide = editor . getMode ( ) . hideExtension ( code . getExtension ( ) ) ; tab . text = hide ? code . getPrettyName ( ) : code . getFileName ( ) ; tab . textWidth = ( int ) font . getStringBounds ( tab . text , g2 . getFontRenderContext ( ) ) . getWidth ( ) ; } if ( ! placeTabs ( Editor . LEFT_GUTTER , tabMax , null ) ) { int index = 0 ; for ( int i = tabs . length - 1 ; i > 0 ; -- i ) { visitOrder [ index ++ ] = tabs [ i ] ; } Arrays . sort ( visitOrder ) ; for ( int i = 0 ; i < visitOrder . length ; i ++ ) { tabs [ visitOrder [ i ] . index ] . textVisible = false ; if ( placeTabs ( Editor . LEFT_GUTTER , tabMax , null ) ) { break ; } } } if ( ! placeTabs ( Editor . LEFT_GUTTER , tabMax - ARROW_TAB_WIDTH , g2 ) ) { menuRight = tabMax ; menuLeft = menuRight - ARROW_TAB_WIDTH ; } else { menuLeft = tabs [ tabs . length - 1 ] . right + TAB_BETWEEN ; menuRight = menuLeft + ARROW_TAB_WIDTH ; } g . setColor ( tabColor [ SELECTED ] ) ; g . fillRect ( Editor . LEFT_GUTTER , TAB_BOTTOM , editor . getTextArea ( ) . getWidth ( ) - Editor . LEFT_GUTTER , 2 ) ; g . setColor ( tabColor [ UNSELECTED ] ) ; drawTab ( g , menuLeft , menuRight , false , true ) ; g . setColor ( arrowColor ) ; GeneralPath trianglePath = new GeneralPath ( ) ; float x1 = menuLeft + ( ARROW_TAB_WIDTH - ARROW_WIDTH ) / 2f ; float x2 = menuLeft + ( ARROW_TAB_WIDTH + ARROW_WIDTH ) / 2f ; trianglePath . moveTo ( x1 , ARROW_TOP ) ; trianglePath . lineTo ( x2 , ARROW_TOP ) ; trianglePath . lineTo ( ( x1 + x2 ) / 2 , ARROW_BOTTOM ) ; trianglePath . closePath ( ) ; g2 . fill ( trianglePath ) ; screen . drawImage ( offscreen , 0 , 0 , imageW , imageH , null ) ; } private boolean placeTabs ( int left , int right , Graphics2D g ) { Sketch sketch = editor . getSketch ( ) ; int x = left ; for ( int i = 0 ; i < sketch . getCodeCount ( ) ; i ++ ) { SketchCode code = sketch . getCode ( i ) ; Tab tab = tabs [ i ] ; int state = ( code == sketch . getCurrentCode ( ) ) ? SELECTED : UNSELECTED ; tab . left = x ; x += TEXT_MARGIN ; int drawWidth = tab . textVisible ? tab . textWidth : NO_TEXT_WIDTH ; x += drawWidth + TEXT_MARGIN ; tab . right = x ; if ( g != null && tab . right < right ) { g . setColor ( tabColor [ state ] ) ; drawTab ( g , tab . left , tab . right , i == 0 , false ) ; if ( tab . textVisible ) { int textLeft = tab . left + ( ( tab . right - tab . left ) - tab . textWidth ) / 2 ; g . setColor ( textColor [ state ] ) ; int tabHeight = TAB_BOTTOM - TAB_TOP ; int baseline = TAB_TOP + ( tabHeight + fontAscent ) / 2 ; g . drawString ( tab . text , textLeft , baseline ) ; } if ( code . isModified ( ) ) { g . setColor ( modifiedColor ) ; g . drawLine ( tab . left + ( i == 0 ? CURVE_RADIUS : 0 ) , TAB_TOP , tab . right - 1 , TAB_TOP ) ; } } x += TAB_BETWEEN ; } return x <= right ; } private void drawTab ( Graphics g , int left , int right , boolean leftNotch , boolean rightNotch ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . fill ( Toolkit . createRoundRect ( left , TAB_TOP , right , TAB_BOTTOM , leftNotch ? CURVE_RADIUS : 0 , rightNotch ? CURVE_RADIUS : 0 , 0 , 0 ) ) ; } public void rebuild ( ) { rebuildMenu ( ) ; repaint ( ) ; } public void rebuildMenu ( ) { if ( menu != null ) { menu . removeAll ( ) ; } else { menu = new JMenu ( ) ; popup = menu . getPopupMenu ( ) ; add ( popup ) ; popup . setLightWeightPopupEnabled ( true ) ; } JMenuItem item ; InputMap inputMap = editor . getRootPane ( ) . getInputMap ( JComponent . WHEN_ANCESTOR_OF_FOCUSED_COMPONENT ) ; ActionMap actionMap = editor . getRootPane ( ) . getActionMap ( ) ; Action action ; String mapKey ; KeyStroke keyStroke ; item = Toolkit . newJMenuItemShift ( Language . text ( "editor.header.new_tab" ) , KeyEvent . VK_N ) ; action = new AbstractAction ( ) { @ Override public void actionPerformed ( ActionEvent e ) { editor . getSketch ( ) . handleNewCode ( ) ; } } ; mapKey = "editor.header.new_tab" ; keyStroke = KeyStroke . getKeyStroke ( KeyEvent . VK_N , Toolkit . SHORTCUT_SHIFT_KEY_MASK ) ; inputMap . put ( keyStroke , mapKey ) ; actionMap . put ( mapKey , action ) ; item . addActionListener ( action ) ; menu . add ( item ) ; item = new JMenuItem ( Language . text ( "editor.header.rename" ) ) ; action = new AbstractAction ( ) { @ Override public void actionPerformed ( ActionEvent e ) { editor . getSketch ( ) . handleRenameCode ( ) ; } } ; item . addActionListener ( action ) ; menu . add ( item ) ; item = Toolkit . newJMenuItemShift ( Language . text ( "editor.header.delete" ) , KeyEvent . VK_D ) ; action = new AbstractAction ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Sketch sketch = editor . getSketch ( ) ; if ( ! Base . isMacOS ( ) && editor . base . editors . size ( ) == 1 && sketch . getCurrentCodeIndex ( ) == 0 ) { Base . showWarning ( Language . text ( "editor.header.delete.warning.title" ) , Language . text ( "editor.header.delete.warning.text" ) , null ) ; } else { editor . getSketch ( ) . handleDeleteCode ( ) ; } } } ; mapKey = "editor.header.delete" ; keyStroke = KeyStroke . getKeyStroke ( KeyEvent . VK_D , Toolkit . SHORTCUT_ALT_KEY_MASK ) ; inputMap . put ( keyStroke , mapKey ) ; actionMap . put ( mapKey , action ) ; item . addActionListener ( action ) ; menu . add ( item ) ; menu . addSeparator ( ) ; item = Toolkit . newJMenuItemAlt ( Language . text ( "editor.header.previous_tab" ) , KeyEvent . VK_LEFT ) ; action = new AbstractAction ( ) { @ Override public void actionPerformed ( ActionEvent e ) { editor . getSketch ( ) . handlePrevCode ( ) ; } } ; mapKey = "editor.header.previous_tab" ; keyStroke = KeyStroke . getKeyStroke ( KeyEvent . VK_LEFT , Toolkit . SHORTCUT_ALT_KEY_MASK ) ; inputMap . put ( keyStroke , mapKey ) ; actionMap . put ( mapKey , action ) ; item . addActionListener ( action ) ; menu . add ( item ) ; item = Toolkit . newJMenuItemAlt ( Language . text ( "editor.header.next_tab" ) , KeyEvent . VK_RIGHT ) ; action = new AbstractAction ( ) { @ Override public void actionPerformed ( ActionEvent e ) { editor . getSketch ( ) . handleNextCode ( ) ; } } ; mapKey = "editor.header.next_tab" ; keyStroke = KeyStroke . getKeyStroke ( KeyEvent . VK_RIGHT , Toolkit . SHORTCUT_ALT_KEY_MASK ) ; inputMap . put ( keyStroke , mapKey ) ; actionMap . put ( mapKey , action ) ; item . addActionListener ( action ) ; menu . add ( item ) ; Sketch sketch = editor . getSketch ( ) ; if ( sketch != null ) { menu . addSeparator ( ) ; ActionListener jumpListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { editor . getSketch ( ) . setCurrentCode ( e . getActionCommand ( ) ) ; } } ; for ( SketchCode code : sketch . getCode ( ) ) { item = new JMenuItem ( code . getPrettyName ( ) ) ; item . addActionListener ( jumpListener ) ; menu . add ( item ) ; } } Toolkit . setMenuMnemonics ( menu ) ; } public void deselectMenu ( ) { repaint ( ) ; } public Dimension getPreferredSize ( ) { return new Dimension ( 300 , HIGH ) ; } public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } public Dimension getMaximumSize ( ) { return new Dimension ( super . getMaximumSize ( ) . width , HIGH ) ; } static class Tab implements Comparable { int index ; int left ; int right ; String text ; int textWidth ; boolean textVisible ; long lastVisited ; Tab ( int index ) { this . index = index ; } boolean contains ( int x ) { return x >= left && x <= right ; } public int compareTo ( Object o ) { Tab other = ( Tab ) o ; if ( lastVisited == other . lastVisited ) { return 0 ; } if ( lastVisited == 0 ) { return - 1 ; } if ( other . lastVisited == 0 ) { return 1 ; } return ( int ) ( lastVisited - other . lastVisited ) ; } } }
package processing . app ; import java . io . BufferedReader ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . IOException ; import java . net . URL ; import java . util . Random ; import javax . swing . JOptionPane ; import processing . core . PApplet ; public class UpdateCheck { private final Base base ; static private final String DOWNLOAD_URL = "http://processing.org/download/" ; static private final String LATEST_URL = "http://processing.org/download/latest.txt" ; static private final long ONE_DAY = 24 * 60 * 60 * 1000 ; public UpdateCheck ( Base base ) { this . base = base ; new Thread ( new Runnable ( ) { public void run ( ) { try { Thread . sleep ( 20 * 1000 ) ; updateCheck ( ) ; } catch ( Exception e ) { } } } , "Update Checker" ) . start ( ) ; } public void updateCheck ( ) throws IOException , InterruptedException { Random r = new Random ( ) ; long id = r . nextLong ( ) ; String idString = Preferences . get ( "update.id" ) ; if ( idString != null ) { id = Long . parseLong ( idString ) ; } else { Preferences . set ( "update.id" , String . valueOf ( id ) ) ; } String info = PApplet . urlEncode ( id + "\t" + PApplet . nf ( Base . getRevision ( ) , 4 ) + "\t" + System . getProperty ( "java.version" ) + "\t" + System . getProperty ( "java.vendor" ) + "\t" + System . getProperty ( "os.name" ) + "\t" + System . getProperty ( "os.version" ) + "\t" + System . getProperty ( "os.arch" ) ) ; int latest = readInt ( LATEST_URL + "?" + info ) ; String lastString = Preferences . get ( "update.last" ) ; long now = System . currentTimeMillis ( ) ; if ( lastString != null ) { long when = Long . parseLong ( lastString ) ; if ( now - when < ONE_DAY ) { return ; } } Preferences . set ( "update.last" , String . valueOf ( now ) ) ; if ( base . activeEditor != null ) { boolean offerToUpdateContributions = true ; if ( latest > Base . getRevision ( ) ) { System . out . println ( "You are running Processing revision 0" + Base . getRevision ( ) + ", the latest build is 0" + latest + "." ) ; offerToUpdateContributions = ! promptToVisitDownloadPage ( ) ; } if ( offerToUpdateContributions ) { Thread . sleep ( 5 * 1000 ) ; if ( ( ! base . libraryManagerFrame . hasAlreadyBeenOpened ( ) && ! base . toolManagerFrame . hasAlreadyBeenOpened ( ) && ! base . modeManagerFrame . hasAlreadyBeenOpened ( ) && ! base . exampleManagerFrame . hasAlreadyBeenOpened ( ) ) && ( base . libraryManagerFrame . hasUpdates ( base ) || base . toolManagerFrame . hasUpdates ( base ) || base . modeManagerFrame . hasUpdates ( base ) || base . exampleManagerFrame . hasUpdates ( base ) ) ) { promptToOpenContributionManager ( ) ; } } } } protected boolean promptToVisitDownloadPage ( ) { String prompt = Language . text ( "update_check.updates_available.core" ) ; Object [ ] options = { Language . text ( "prompt.yes" ) , Language . text ( "prompt.no" ) } ; int result = JOptionPane . showOptionDialog ( base . activeEditor , prompt , Language . text ( "update_check" ) , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , options [ 0 ] ) ; if ( result == JOptionPane . YES_OPTION ) { Base . openURL ( DOWNLOAD_URL ) ; return true ; } return false ; } protected boolean promptToOpenContributionManager ( ) { String contributionPrompt = Language . text ( "update_check.updates_available.contributions" ) ; Object [ ] options = { Language . text ( "prompt.yes" ) , Language . text ( "prompt.no" ) } ; int result = JOptionPane . showOptionDialog ( base . activeEditor , contributionPrompt , Language . text ( "update_check" ) , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , options [ 0 ] ) ; if ( result == JOptionPane . YES_OPTION ) { base . handleShowUpdates ( ) ; return true ; } return false ; } protected int readInt ( String filename ) throws IOException { URL url = new URL ( filename ) ; InputStream stream = url . openStream ( ) ; InputStreamReader isr = new InputStreamReader ( stream ) ; BufferedReader reader = new BufferedReader ( isr ) ; return Integer . parseInt ( reader . readLine ( ) ) ; } }
package processing . app ; import java . io . File ; public class SketchReference { String name ; File pde ; public SketchReference ( String name , File pde ) { this . name = name ; this . pde = pde ; } public String getPath ( ) { return pde . getAbsolutePath ( ) ; } public String toString ( ) { return name ; } }
package processing . app ; import java . awt . * ; import java . awt . event . * ; import java . awt . image . BufferedImage ; import java . awt . image . WritableRaster ; import java . io . * ; import java . util . * ; import javax . swing . * ; import javax . swing . border . Border ; import javax . swing . border . EmptyBorder ; import javax . swing . event . TreeExpansionEvent ; import javax . swing . event . TreeExpansionListener ; import javax . swing . tree . * ; import processing . app . syntax . * ; import processing . core . PApplet ; import processing . core . PConstants ; public abstract class Mode { protected Base base ; protected File folder ; protected TokenMarker tokenMarker ; protected HashMap < String , String > keywordToReference = new HashMap < String , String > ( ) ; protected Settings theme ; protected HashMap < String , ArrayList < Library > > importToLibraryTable ; protected JMenu examplesMenu ; protected JMenu importMenu ; protected JFrame examplesFrame ; protected JMenu toolbarMenu ; protected File examplesFolder ; protected File librariesFolder ; protected File referenceFolder ; protected File examplesContribFolder ; public ArrayList < Library > coreLibraries ; public ArrayList < Library > contribLibraries ; protected Library coreLibrary ; protected ClassLoader classLoader ; static final int BACKGROUND_WIDTH = 1025 ; static final int BACKGROUND_HEIGHT = 65 ; protected Image backgroundImage ; public Mode ( Base base , File folder ) { this . base = base ; this . folder = folder ; tokenMarker = createTokenMarker ( ) ; examplesFolder = new File ( folder , "examples" ) ; librariesFolder = new File ( folder , "libraries" ) ; referenceFolder = new File ( folder , "reference" ) ; examplesContribFolder = Base . getSketchbookExamplesFolder ( ) ; rebuildLibraryList ( ) ; try { for ( File file : getKeywordFiles ( ) ) { loadKeywords ( file ) ; } } catch ( IOException e ) { Base . showWarning ( "Problem loading keywords" , "Could not load keywords file for " + getTitle ( ) + " mode." , e ) ; } } public File [ ] getKeywordFiles ( ) { return new File [ ] { new File ( folder , "keywords.txt" ) } ; } protected void loadKeywords ( File keywordFile ) throws IOException { loadKeywords ( keywordFile , "#" ) ; } protected void loadKeywords ( File keywordFile , String commentPrefix ) throws IOException { BufferedReader reader = PApplet . createReader ( keywordFile ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . trim ( ) . startsWith ( commentPrefix ) ) { String [ ] pieces = PApplet . splitTokens ( line ) ; if ( pieces . length >= 2 ) { String keyword = pieces [ 0 ] ; String coloring = pieces [ 1 ] ; if ( coloring . length ( ) > 0 ) { tokenMarker . addColoring ( keyword , coloring ) ; } if ( pieces . length == 3 ) { String htmlFilename = pieces [ 2 ] ; if ( htmlFilename . length ( ) > 0 ) { if ( htmlFilename . endsWith ( "_" ) ) { keyword += "_" ; } keywordToReference . put ( keyword , htmlFilename ) ; } } } } } reader . close ( ) ; } public void setClassLoader ( ClassLoader loader ) { this . classLoader = loader ; } public ClassLoader getClassLoader ( ) { return classLoader ; } public void setupGUI ( ) { try { theme = new Settings ( Base . getContentFile ( "lib/theme.txt" ) ) ; File modeTheme = new File ( folder , "theme/theme.txt" ) ; if ( modeTheme . exists ( ) ) { theme . load ( modeTheme ) ; } theme . setColor ( "run.window.bgcolor" , SystemColor . control ) ; } catch ( IOException e ) { Base . showError ( "Problem loading theme.txt" , "Could not load theme.txt, please re-install Processing" , e ) ; } } public File getContentFile ( String path ) { return new File ( folder , path ) ; } public InputStream getContentStream ( String path ) throws FileNotFoundException { return new FileInputStream ( getContentFile ( path ) ) ; } abstract public String getTitle ( ) ; public String getIdentifier ( ) { return getClass ( ) . getCanonicalName ( ) ; } abstract public Editor createEditor ( Base base , String path , EditorState state ) ; public File getFolder ( ) { return folder ; } public File getExamplesFolder ( ) { return examplesFolder ; } public File getLibrariesFolder ( ) { return librariesFolder ; } public File getReferenceFolder ( ) { return referenceFolder ; } public void rebuildLibraryList ( ) { importToLibraryTable = new HashMap < String , ArrayList < Library > > ( ) ; coreLibraries = Library . list ( librariesFolder ) ; for ( Library lib : coreLibraries ) { lib . addPackageList ( importToLibraryTable ) ; } File contribLibrariesFolder = Base . getSketchbookLibrariesFolder ( ) ; if ( contribLibrariesFolder != null ) { contribLibraries = Library . list ( contribLibrariesFolder ) ; for ( Library lib : contribLibraries ) { lib . addPackageList ( importToLibraryTable ) ; } } } public Library getCoreLibrary ( ) { return null ; } public Library getLibrary ( String pkgName ) throws SketchException { ArrayList < Library > libraries = importToLibraryTable . get ( pkgName ) ; if ( libraries == null ) { return null ; } else if ( libraries . size ( ) > 1 ) { String primary = "More than one library is competing for this sketch." ; String secondary = "The import " + pkgName + " points to multiple libraries:<br>" ; for ( Library library : libraries ) { String location = library . getPath ( ) ; if ( location . startsWith ( getLibrariesFolder ( ) . getAbsolutePath ( ) ) ) { location = "part of Processing" ; } secondary += "<b>" + library . getName ( ) + "</b> (" + location + ")<br>" ; } secondary += "Extra libraries need to be removed before this sketch can be used." ; Base . showWarningTiered ( "Duplicate Library Problem" , primary , secondary , null ) ; throw new SketchException ( "Duplicate libraries found for " + pkgName + "." ) ; } else { return libraries . get ( 0 ) ; } } public JMenu getToolbarMenu ( ) { if ( toolbarMenu == null ) { rebuildToolbarMenu ( ) ; } return toolbarMenu ; } public void insertToolbarRecentMenu ( ) { if ( toolbarMenu == null ) { rebuildToolbarMenu ( ) ; } else { toolbarMenu . insert ( base . getToolbarRecentMenu ( ) , 1 ) ; } } public void removeToolbarRecentMenu ( ) { toolbarMenu . remove ( base . getToolbarRecentMenu ( ) ) ; } protected void rebuildToolbarMenu ( ) { JMenuItem item ; if ( toolbarMenu == null ) { toolbarMenu = new JMenu ( ) ; } else { toolbarMenu . removeAll ( ) ; } item = Toolkit . newJMenuItem ( "Open..." , 'O' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . handleOpenPrompt ( ) ; } } ) ; toolbarMenu . add ( item ) ; insertToolbarRecentMenu ( ) ; item = Toolkit . newJMenuItemShift ( "Examples..." , 'O' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { showExamplesFrame ( ) ; } } ) ; toolbarMenu . add ( item ) ; item = new JMenuItem ( Language . text ( "examples.add_examples" ) ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . handleOpenExampleManager ( ) ; } } ) ; toolbarMenu . add ( item ) ; toolbarMenu . addSeparator ( ) ; base . populateSketchbookMenu ( toolbarMenu ) ; } protected int importMenuIndex = - 1 ; public void removeImportMenu ( JMenu sketchMenu ) { JMenu importMenu = getImportMenu ( ) ; importMenuIndex = Toolkit . getMenuItemIndex ( sketchMenu , importMenu ) ; sketchMenu . remove ( importMenu ) ; } public void insertImportMenu ( JMenu sketchMenu ) { if ( importMenuIndex != - 1 ) { sketchMenu . insert ( getImportMenu ( ) , importMenuIndex ) ; } } public JMenu getImportMenu ( ) { if ( importMenu == null ) { rebuildImportMenu ( ) ; } return importMenu ; } public void rebuildImportMenu ( ) { if ( importMenu == null ) { importMenu = new JMenu ( Language . text ( "menu.library" ) ) ; } else { importMenu . removeAll ( ) ; } JMenuItem addLib = new JMenuItem ( Language . text ( "menu.library.add_library" ) ) ; addLib . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . handleOpenLibraryManager ( ) ; } } ) ; importMenu . add ( addLib ) ; importMenu . addSeparator ( ) ; rebuildLibraryList ( ) ; ActionListener listener = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . activeEditor . handleImportLibrary ( e . getActionCommand ( ) ) ; } } ; if ( coreLibraries . size ( ) == 0 ) { JMenuItem item = new JMenuItem ( getTitle ( ) + " " + Language . text ( "menu.library.no_core_libraries" ) ) ; item . setEnabled ( false ) ; importMenu . add ( item ) ; } else { for ( Library library : coreLibraries ) { JMenuItem item = new JMenuItem ( library . getName ( ) ) ; item . addActionListener ( listener ) ; item . setActionCommand ( library . getName ( ) ) ; importMenu . add ( item ) ; } } if ( contribLibraries . size ( ) != 0 ) { importMenu . addSeparator ( ) ; JMenuItem contrib = new JMenuItem ( Language . text ( "menu.library.contributed" ) ) ; contrib . setEnabled ( false ) ; importMenu . add ( contrib ) ; HashMap < String , JMenu > subfolders = new HashMap < String , JMenu > ( ) ; for ( Library library : contribLibraries ) { JMenuItem item = new JMenuItem ( library . getName ( ) ) ; item . addActionListener ( listener ) ; item . setActionCommand ( library . getName ( ) ) ; String group = library . getGroup ( ) ; if ( group != null ) { JMenu subMenu = subfolders . get ( group ) ; if ( subMenu == null ) { subMenu = new JMenu ( group ) ; importMenu . add ( subMenu ) ; subfolders . put ( group , subMenu ) ; } subMenu . add ( item ) ; } else { importMenu . add ( item ) ; } } } } public File [ ] getExampleCategoryFolders ( ) { return examplesFolder . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return dir . isDirectory ( ) && name . charAt ( 0 ) != '.' ; } } ) ; } public DefaultMutableTreeNode buildExamplesTree ( ) { DefaultMutableTreeNode root = new DefaultMutableTreeNode ( "Examples" ) ; try { File [ ] examples = getExampleCategoryFolders ( ) ; for ( File subFolder : examples ) { DefaultMutableTreeNode subNode = new DefaultMutableTreeNode ( subFolder . getName ( ) ) ; if ( base . addSketches ( subNode , subFolder ) ) { root . add ( subNode ) ; } } DefaultMutableTreeNode foundationLibraries = new DefaultMutableTreeNode ( Language . text ( "examples.core_libraries" ) ) ; for ( Library lib : coreLibraries ) { if ( lib . hasExamples ( ) ) { DefaultMutableTreeNode libNode = new DefaultMutableTreeNode ( lib . getName ( ) ) ; if ( base . addSketches ( libNode , lib . getExamplesFolder ( ) ) ) foundationLibraries . add ( libNode ) ; } } if ( foundationLibraries . getChildCount ( ) > 0 ) { root . add ( foundationLibraries ) ; } DefaultMutableTreeNode contributed = new DefaultMutableTreeNode ( Language . text ( "examples.libraries" ) ) ; for ( Library lib : contribLibraries ) { if ( lib . hasExamples ( ) ) { DefaultMutableTreeNode libNode = new DefaultMutableTreeNode ( lib . getName ( ) ) ; base . addSketches ( libNode , lib . getExamplesFolder ( ) ) ; contributed . add ( libNode ) ; } } if ( contributed . getChildCount ( ) > 0 ) { root . add ( contributed ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return root ; } public void rebuildExamplesFrame ( ) { if ( examplesFrame != null ) { boolean visible = examplesFrame . isVisible ( ) ; Rectangle bounds = null ; if ( visible ) { bounds = examplesFrame . getBounds ( ) ; examplesFrame . setVisible ( false ) ; } examplesFrame = null ; if ( visible ) { showExamplesFrame ( ) ; examplesFrame . setBounds ( bounds ) ; } } } public void showExamplesFrame ( ) { if ( examplesFrame == null ) { examplesFrame = new JFrame ( getTitle ( ) + " " + Language . text ( "examples" ) ) ; Toolkit . setIcon ( examplesFrame ) ; Toolkit . registerWindowCloseKeys ( examplesFrame . getRootPane ( ) , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { examplesFrame . setVisible ( false ) ; } } ) ; JPanel examplesPanel = new JPanel ( ) ; examplesPanel . setLayout ( new BorderLayout ( ) ) ; examplesPanel . setBackground ( Color . WHITE ) ; final JPanel openExamplesManagerPanel = new JPanel ( new FlowLayout ( FlowLayout . CENTER ) ) ; JButton addExamplesButton = new JButton ( Language . text ( "examples.add_examples" ) ) ; openExamplesManagerPanel . add ( addExamplesButton ) ; openExamplesManagerPanel . setOpaque ( false ) ; Border lineBorder = BorderFactory . createMatteBorder ( 0 , 0 , 1 , 0 , Color . BLACK ) ; Border paddingBorder = BorderFactory . createEmptyBorder ( 3 , 5 , 1 , 4 ) ; openExamplesManagerPanel . setBorder ( BorderFactory . createCompoundBorder ( lineBorder , paddingBorder ) ) ; openExamplesManagerPanel . setAlignmentX ( Component . LEFT_ALIGNMENT ) ; openExamplesManagerPanel . setCursor ( new Cursor ( Cursor . HAND_CURSOR ) ) ; addExamplesButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { base . handleOpenExampleManager ( ) ; } } ) ; final JTree tree = new JTree ( buildExamplesTree ( ) ) ; tree . setOpaque ( true ) ; tree . setAlignmentX ( Component . LEFT_ALIGNMENT ) ; tree . getSelectionModel ( ) . setSelectionMode ( TreeSelectionModel . SINGLE_TREE_SELECTION ) ; tree . setShowsRootHandles ( true ) ; tree . expandRow ( 0 ) ; tree . setRootVisible ( false ) ; tree . addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent e ) { if ( e . getClickCount ( ) == 2 ) { DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) tree . getLastSelectedPathComponent ( ) ; int selRow = tree . getRowForLocation ( e . getX ( ) , e . getY ( ) ) ; if ( node != null && node . isLeaf ( ) && selRow != - 1 ) { SketchReference sketch = ( SketchReference ) node . getUserObject ( ) ; base . handleOpen ( sketch . getPath ( ) ) ; } } } } ) ; tree . addKeyListener ( new KeyAdapter ( ) { public void keyPressed ( KeyEvent e ) { if ( e . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) { examplesFrame . setVisible ( false ) ; } } public void keyTyped ( KeyEvent e ) { if ( e . getKeyChar ( ) == KeyEvent . VK_ENTER ) { DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) tree . getLastSelectedPathComponent ( ) ; if ( node != null && node . isLeaf ( ) ) { SketchReference sketch = ( SketchReference ) node . getUserObject ( ) ; base . handleOpen ( sketch . getPath ( ) ) ; } } } } ) ; tree . addTreeExpansionListener ( new TreeExpansionListener ( ) { @ Override public void treeExpanded ( TreeExpansionEvent event ) { updateExpanded ( tree ) ; } @ Override public void treeCollapsed ( TreeExpansionEvent event ) { updateExpanded ( tree ) ; } } ) ; tree . setBorder ( new EmptyBorder ( 0 , 5 , 5 , 5 ) ) ; if ( Base . isMacOS ( ) ) { tree . setToggleClickCount ( 2 ) ; } else { tree . setToggleClickCount ( 1 ) ; } JScrollPane treePane = new JScrollPane ( tree ) ; treePane . setPreferredSize ( new Dimension ( 250 , 300 ) ) ; treePane . setBorder ( new EmptyBorder ( 2 , 0 , 0 , 0 ) ) ; treePane . setOpaque ( true ) ; treePane . setBackground ( Color . WHITE ) ; treePane . setAlignmentX ( Component . LEFT_ALIGNMENT ) ; examplesPanel . add ( openExamplesManagerPanel , BorderLayout . PAGE_START ) ; examplesPanel . add ( treePane , BorderLayout . CENTER ) ; examplesFrame . getContentPane ( ) . add ( examplesPanel ) ; examplesFrame . pack ( ) ; restoreExpanded ( tree ) ; } int roughWidth = examplesFrame . getWidth ( ) + 20 ; Point p = null ; if ( base . activeEditor == null || ( p = base . activeEditor . getLocation ( ) ) . x < roughWidth ) { examplesFrame . setLocationRelativeTo ( null ) ; } else { examplesFrame . setLocation ( p . x - roughWidth , p . y ) ; } examplesFrame . setVisible ( true ) ; } protected void updateExpanded ( JTree tree ) { Enumeration en = tree . getExpandedDescendants ( new TreePath ( tree . getModel ( ) . getRoot ( ) ) ) ; StringBuilder s = new StringBuilder ( ) ; while ( en . hasMoreElements ( ) ) { TreePath tp = ( TreePath ) en . nextElement ( ) ; Object [ ] path = tp . getPath ( ) ; for ( Object o : path ) { DefaultMutableTreeNode p = ( DefaultMutableTreeNode ) o ; String name = ( String ) p . getUserObject ( ) ; s . append ( name ) ; s . append ( File . separatorChar ) ; } s . setCharAt ( s . length ( ) - 1 , File . pathSeparatorChar ) ; } s . setLength ( s . length ( ) - 1 ) ; String pref = "examples." + getClass ( ) . getName ( ) + ".visible" ; Preferences . set ( pref , s . toString ( ) ) ; Preferences . save ( ) ; } protected void restoreExpanded ( JTree tree ) { String pref = "examples." + getClass ( ) . getName ( ) + ".visible" ; String value = Preferences . get ( pref ) ; if ( value != null ) { String [ ] paths = PApplet . split ( value , File . pathSeparator ) ; for ( String path : paths ) { String [ ] items = PApplet . split ( path , File . separator ) ; DefaultMutableTreeNode [ ] nodes = new DefaultMutableTreeNode [ items . length ] ; expandTree ( tree , null , items , nodes , 0 ) ; } } } void expandTree ( JTree tree , Object object , String [ ] items , DefaultMutableTreeNode [ ] nodes , int index ) { TreeModel model = tree . getModel ( ) ; if ( index == 0 ) { nodes [ 0 ] = ( DefaultMutableTreeNode ) model . getRoot ( ) ; expandTree ( tree , nodes [ 0 ] , items , nodes , 1 ) ; } else if ( index < items . length ) { DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) object ; int count = model . getChildCount ( node ) ; for ( int i = 0 ; i < count ; i ++ ) { DefaultMutableTreeNode child = ( DefaultMutableTreeNode ) model . getChild ( node , i ) ; if ( items [ index ] . equals ( child . getUserObject ( ) ) ) { nodes [ index ] = child ; expandTree ( tree , child , items , nodes , index + 1 ) ; } } } else { tree . expandPath ( new TreePath ( nodes ) ) ; } } protected JFrame sketchbookFrame ; public DefaultMutableTreeNode buildSketchbookTree ( ) { DefaultMutableTreeNode sbNode = new DefaultMutableTreeNode ( Language . text ( "sketchbook.tree" ) ) ; try { base . addSketches ( sbNode , Base . getSketchbookFolder ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return sbNode ; } public void rebuildSketchbookFrame ( ) { boolean visible = ( sketchbookFrame == null ) ? false : sketchbookFrame . isVisible ( ) ; sketchbookFrame = null ; if ( visible ) { showSketchbookFrame ( ) ; } } public void showSketchbookFrame ( ) { if ( sketchbookFrame == null ) { sketchbookFrame = new JFrame ( Language . text ( "sketchbook" ) ) ; Toolkit . setIcon ( sketchbookFrame ) ; final ActionListener listener = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { sketchbookFrame . setVisible ( false ) ; } } ; Toolkit . registerWindowCloseKeys ( sketchbookFrame . getRootPane ( ) , listener ) ; final JTree tree = new JTree ( buildSketchbookTree ( ) ) ; tree . getSelectionModel ( ) . setSelectionMode ( TreeSelectionModel . SINGLE_TREE_SELECTION ) ; tree . setShowsRootHandles ( true ) ; tree . expandRow ( 0 ) ; tree . setRootVisible ( false ) ; tree . addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent e ) { if ( e . getClickCount ( ) == 2 ) { DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) tree . getLastSelectedPathComponent ( ) ; int selRow = tree . getRowForLocation ( e . getX ( ) , e . getY ( ) ) ; if ( node != null && node . isLeaf ( ) && selRow != - 1 ) { SketchReference sketch = ( SketchReference ) node . getUserObject ( ) ; base . handleOpen ( sketch . getPath ( ) ) ; } } } } ) ; tree . addKeyListener ( new KeyAdapter ( ) { public void keyPressed ( KeyEvent e ) { if ( e . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) { sketchbookFrame . setVisible ( false ) ; } } public void keyTyped ( KeyEvent e ) { if ( e . getKeyChar ( ) == KeyEvent . VK_ENTER ) { DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) tree . getLastSelectedPathComponent ( ) ; if ( node != null && node . isLeaf ( ) ) { SketchReference sketch = ( SketchReference ) node . getUserObject ( ) ; base . handleOpen ( sketch . getPath ( ) ) ; } } } } ) ; tree . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; if ( Base . isMacOS ( ) ) { tree . setToggleClickCount ( 2 ) ; } else { tree . setToggleClickCount ( 1 ) ; } JScrollPane treePane = new JScrollPane ( tree ) ; treePane . setPreferredSize ( new Dimension ( 250 , 450 ) ) ; treePane . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 0 ) ) ; sketchbookFrame . getContentPane ( ) . add ( treePane ) ; sketchbookFrame . pack ( ) ; } EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { int roughWidth = sketchbookFrame . getWidth ( ) + 20 ; Point p = null ; if ( base . activeEditor == null || ( p = base . activeEditor . getLocation ( ) ) . x < roughWidth ) { sketchbookFrame . setLocationRelativeTo ( null ) ; } else { sketchbookFrame . setLocation ( p . x - roughWidth , p . y ) ; } sketchbookFrame . setVisible ( true ) ; } } ) ; } public ImageIcon loadIcon ( String filename ) { if ( filename . startsWith ( "/lib/" ) ) { return Toolkit . getLibIcon ( filename . substring ( 5 ) ) ; } File file = new File ( folder , filename ) ; if ( ! file . exists ( ) ) { return null ; } return new ImageIcon ( file . getAbsolutePath ( ) ) ; } public Image loadImage ( String filename ) { ImageIcon icon = loadIcon ( filename ) ; if ( icon != null ) { return icon . getImage ( ) ; } return null ; } public String lookupReference ( String keyword ) { return keywordToReference . get ( keyword ) ; } public TokenMarker getTokenMarker ( ) { return tokenMarker ; } protected TokenMarker createTokenMarker ( ) { return new PdeKeywords ( ) ; } public String getString ( String attribute ) { return theme . get ( attribute ) ; } public boolean getBoolean ( String attribute ) { return theme . getBoolean ( attribute ) ; } public int getInteger ( String attribute ) { return theme . getInteger ( attribute ) ; } public Color getColor ( String attribute ) { return theme . getColor ( attribute ) ; } public Font getFont ( String attribute ) { return theme . getFont ( attribute ) ; } public SyntaxStyle getStyle ( String attribute ) { String str = Preferences . get ( "editor.token." + attribute + ".style" ) ; if ( str == null ) { throw new IllegalArgumentException ( "No style found for " + attribute ) ; } StringTokenizer st = new StringTokenizer ( str , "," ) ; String s = st . nextToken ( ) ; if ( s . indexOf ( "#" ) == 0 ) s = s . substring ( 1 ) ; Color color = new Color ( Integer . parseInt ( s , 16 ) ) ; s = st . nextToken ( ) ; boolean bold = ( s . indexOf ( "bold" ) != - 1 ) ; return new SyntaxStyle ( color , bold ) ; } public Image makeGradient ( String attribute , int wide , int high ) { int top = getColor ( attribute + ".gradient.top" ) . getRGB ( ) ; int bot = getColor ( attribute + ".gradient.bottom" ) . getRGB ( ) ; BufferedImage outgoing = new BufferedImage ( wide , high , BufferedImage . TYPE_INT_RGB ) ; int [ ] row = new int [ wide ] ; WritableRaster wr = outgoing . getRaster ( ) ; for ( int i = 0 ; i < high ; i ++ ) { int rgb = PApplet . lerpColor ( top , bot , i / ( float ) ( high - 1 ) , PConstants . RGB ) ; Arrays . fill ( row , rgb ) ; wr . setDataElements ( 0 , i , wide , 1 , row ) ; } return outgoing ; } public boolean hideExtension ( String what ) { return what . equals ( getDefaultExtension ( ) ) ; } public boolean isDefaultExtension ( SketchCode code ) { return code . getExtension ( ) . equals ( getDefaultExtension ( ) ) ; } public boolean isDefaultExtension ( String what ) { return what . equals ( getDefaultExtension ( ) ) ; } public boolean canEdit ( final File f ) { final int dot = f . getName ( ) . lastIndexOf ( '.' ) ; if ( dot < 0 ) { return false ; } return validExtension ( f . getName ( ) . substring ( dot + 1 ) ) ; } public boolean validExtension ( String what ) { String [ ] ext = getExtensions ( ) ; for ( int i = 0 ; i < ext . length ; i ++ ) { if ( ext [ i ] . equals ( what ) ) return true ; } return false ; } abstract public String getDefaultExtension ( ) ; public String getModuleExtension ( ) { return getDefaultExtension ( ) ; } abstract public String [ ] getExtensions ( ) ; abstract public String [ ] getIgnorable ( ) ; public Library findLibraryByName ( String libName ) { for ( Library lib : this . coreLibraries ) { if ( libName . equals ( lib . getName ( ) ) ) return lib ; } for ( Library lib : this . contribLibraries ) { if ( libName . equals ( lib . getName ( ) ) ) return lib ; } return null ; } public void prepareExportFolder ( File targetFolder ) { if ( targetFolder != null ) { if ( Preferences . getBoolean ( "export.delete_target_folder" ) ) { Base . removeDir ( targetFolder ) ; } targetFolder . mkdirs ( ) ; } } @ Override public String toString ( ) { return getTitle ( ) ; } }
package processing . app ; import processing . core . * ; import java . awt . BorderLayout ; import java . awt . Color ; import java . awt . Container ; import java . awt . Cursor ; import java . awt . Dimension ; import java . awt . Frame ; import java . awt . Graphics ; import java . awt . event . * ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . text . * ; public class ColorChooser { int hue , saturation , brightness ; int red , green , blue ; ColorRange range ; ColorSlider slider ; JTextField hueField , saturationField , brightnessField ; JTextField redField , greenField , blueField ; JTextField hexField ; JPanel colorPanel ; DocumentListener colorListener ; JDialog window ; public ColorChooser ( Frame owner , boolean modal , Color initialColor , String buttonName , ActionListener buttonListener ) { window = new JDialog ( owner , Language . text ( "color_chooser" ) , modal ) ; window . getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; Box box = Box . createHorizontalBox ( ) ; box . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; range = new ColorRange ( ) ; Box rangeBox = new Box ( BoxLayout . Y_AXIS ) ; rangeBox . setAlignmentY ( 0 ) ; rangeBox . setBorder ( BorderFactory . createBevelBorder ( BevelBorder . LOWERED ) ) ; rangeBox . add ( range ) ; box . add ( rangeBox ) ; box . add ( Box . createHorizontalStrut ( 10 ) ) ; slider = new ColorSlider ( ) ; Box sliderBox = new Box ( BoxLayout . Y_AXIS ) ; sliderBox . setAlignmentY ( 0 ) ; sliderBox . setBorder ( BorderFactory . createBevelBorder ( BevelBorder . LOWERED ) ) ; sliderBox . add ( slider ) ; box . add ( sliderBox ) ; box . add ( Box . createHorizontalStrut ( 10 ) ) ; box . add ( createColorFields ( buttonName , buttonListener ) ) ; box . add ( Box . createHorizontalStrut ( 10 ) ) ; window . getContentPane ( ) . add ( box , BorderLayout . CENTER ) ; window . pack ( ) ; window . setResizable ( false ) ; window . setLocationRelativeTo ( null ) ; window . setDefaultCloseOperation ( WindowConstants . DO_NOTHING_ON_CLOSE ) ; window . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { hide ( ) ; } } ) ; Toolkit . registerWindowCloseKeys ( window . getRootPane ( ) , new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { hide ( ) ; } } ) ; Toolkit . setIcon ( window ) ; colorListener = new ColorListener ( ) ; hueField . getDocument ( ) . addDocumentListener ( colorListener ) ; saturationField . getDocument ( ) . addDocumentListener ( colorListener ) ; brightnessField . getDocument ( ) . addDocumentListener ( colorListener ) ; redField . getDocument ( ) . addDocumentListener ( colorListener ) ; greenField . getDocument ( ) . addDocumentListener ( colorListener ) ; blueField . getDocument ( ) . addDocumentListener ( colorListener ) ; hexField . getDocument ( ) . addDocumentListener ( colorListener ) ; setColor ( initialColor ) ; } public void show ( ) { window . setVisible ( true ) ; } public void hide ( ) { window . setVisible ( false ) ; } public Color getColor ( ) { return new Color ( red , green , blue ) ; } public void setColor ( Color color ) { updateRGB ( color . getRGB ( ) ) ; } public String getHexColor ( ) { return "#" + PApplet . hex ( red , 2 ) + PApplet . hex ( green , 2 ) + PApplet . hex ( blue , 2 ) ; } public class ColorListener implements DocumentListener { public void changedUpdate ( DocumentEvent e ) { } public void removeUpdate ( DocumentEvent e ) { } boolean updating ; public void insertUpdate ( DocumentEvent e ) { if ( updating ) return ; updating = true ; Document doc = e . getDocument ( ) ; if ( doc == hueField . getDocument ( ) ) { hue = bounded ( hue , hueField , 359 ) ; updateRGB ( ) ; updateHex ( ) ; } else if ( doc == saturationField . getDocument ( ) ) { saturation = bounded ( saturation , saturationField , 99 ) ; updateRGB ( ) ; updateHex ( ) ; } else if ( doc == brightnessField . getDocument ( ) ) { brightness = bounded ( brightness , brightnessField , 99 ) ; updateRGB ( ) ; updateHex ( ) ; } else if ( doc == redField . getDocument ( ) ) { red = bounded ( red , redField , 255 ) ; updateHSB ( ) ; updateHex ( ) ; } else if ( doc == greenField . getDocument ( ) ) { green = bounded ( green , greenField , 255 ) ; updateHSB ( ) ; updateHex ( ) ; } else if ( doc == blueField . getDocument ( ) ) { blue = bounded ( blue , blueField , 255 ) ; updateHSB ( ) ; updateHex ( ) ; } else if ( doc == hexField . getDocument ( ) ) { String str = hexField . getText ( ) ; if ( str . startsWith ( "#" ) ) { str = str . substring ( 1 ) ; } while ( str . length ( ) < 6 ) { str += "0" ; } if ( str . length ( ) > 6 ) { str = str . substring ( 0 , 6 ) ; } updateRGB ( Integer . parseInt ( str , 16 ) ) ; updateHSB ( ) ; } range . repaint ( ) ; slider . repaint ( ) ; colorPanel . repaint ( ) ; updating = false ; } } protected void updateRGB ( ) { updateRGB ( Color . HSBtoRGB ( hue / 359f , saturation / 99f , brightness / 99f ) ) ; } protected void updateRGB ( int rgb ) { red = ( rgb > > 16 ) & 0xff ; green = ( rgb > > 8 ) & 0xff ; blue = rgb & 0xff ; redField . setText ( String . valueOf ( red ) ) ; greenField . setText ( String . valueOf ( green ) ) ; blueField . setText ( String . valueOf ( blue ) ) ; } protected void updateHSB ( ) { float hsb [ ] = new float [ 3 ] ; Color . RGBtoHSB ( red , green , blue , hsb ) ; hue = ( int ) ( hsb [ 0 ] * 359.0f ) ; saturation = ( int ) ( hsb [ 1 ] * 99.0f ) ; brightness = ( int ) ( hsb [ 2 ] * 99.0f ) ; hueField . setText ( String . valueOf ( hue ) ) ; saturationField . setText ( String . valueOf ( saturation ) ) ; brightnessField . setText ( String . valueOf ( brightness ) ) ; } protected void updateHex ( ) { hexField . setText ( getHexColor ( ) ) ; } protected int bounded ( int current , final JTextField field , final int max ) { String text = field . getText ( ) ; if ( text . length ( ) == 0 ) { return 0 ; } try { int value = Integer . parseInt ( text ) ; if ( value > max ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { field . setText ( String . valueOf ( max ) ) ; } } ) ; return max ; } return value ; } catch ( NumberFormatException e ) { return current ; } } protected Container createColorFields ( String buttonName , ActionListener buttonListener ) { Box box = Box . createVerticalBox ( ) ; box . setAlignmentY ( 0 ) ; final int GAP = Base . isWindows ( ) ? 5 : 0 ; final int BETWEEN = Base . isWindows ( ) ? 8 : 6 ; Box row ; row = Box . createHorizontalBox ( ) ; if ( Base . isMacOS ( ) ) { row . add ( Box . createHorizontalStrut ( 17 ) ) ; } else { row . add ( createFixedLabel ( "" ) ) ; } colorPanel = new JPanel ( ) { public void paintComponent ( Graphics g ) { g . setColor ( new Color ( red , green , blue ) ) ; Dimension size = getSize ( ) ; g . fillRect ( 0 , 0 , size . width , size . height ) ; } } ; colorPanel . setBorder ( BorderFactory . createBevelBorder ( BevelBorder . LOWERED ) ) ; Dimension dim = new Dimension ( 70 , 25 ) ; colorPanel . setMinimumSize ( dim ) ; colorPanel . setMaximumSize ( dim ) ; colorPanel . setPreferredSize ( dim ) ; row . add ( colorPanel ) ; row . add ( Box . createHorizontalGlue ( ) ) ; box . add ( row ) ; box . add ( Box . createVerticalStrut ( BETWEEN ) ) ; row = Box . createHorizontalBox ( ) ; row . add ( createFixedLabel ( "H" ) ) ; row . add ( hueField = new NumberField ( 4 , false ) ) ; row . add ( new JLabel ( " \u00B0" ) ) ; row . add ( Box . createHorizontalGlue ( ) ) ; box . add ( row ) ; box . add ( Box . createVerticalStrut ( GAP ) ) ; row = Box . createHorizontalBox ( ) ; row . add ( createFixedLabel ( "S" ) ) ; row . add ( saturationField = new NumberField ( 4 , false ) ) ; row . add ( new JLabel ( " %" ) ) ; row . add ( Box . createHorizontalGlue ( ) ) ; box . add ( row ) ; box . add ( Box . createVerticalStrut ( GAP ) ) ; row = Box . createHorizontalBox ( ) ; row . add ( createFixedLabel ( "B" ) ) ; row . add ( brightnessField = new NumberField ( 4 , false ) ) ; row . add ( new JLabel ( " %" ) ) ; row . add ( Box . createHorizontalGlue ( ) ) ; box . add ( row ) ; box . add ( Box . createVerticalStrut ( BETWEEN ) ) ; row = Box . createHorizontalBox ( ) ; row . add ( createFixedLabel ( "R" ) ) ; row . add ( redField = new NumberField ( 4 , false ) ) ; row . add ( Box . createHorizontalGlue ( ) ) ; box . add ( row ) ; box . add ( Box . createVerticalStrut ( GAP ) ) ; row = Box . createHorizontalBox ( ) ; row . add ( createFixedLabel ( "G" ) ) ; row . add ( greenField = new NumberField ( 4 , false ) ) ; row . add ( Box . createHorizontalGlue ( ) ) ; box . add ( row ) ; box . add ( Box . createVerticalStrut ( GAP ) ) ; row = Box . createHorizontalBox ( ) ; row . add ( createFixedLabel ( "B" ) ) ; row . add ( blueField = new NumberField ( 4 , false ) ) ; row . add ( Box . createHorizontalGlue ( ) ) ; box . add ( row ) ; box . add ( Box . createVerticalStrut ( BETWEEN ) ) ; row = Box . createHorizontalBox ( ) ; row . add ( createFixedLabel ( "" ) ) ; final int hexCount = Base . isWindows ( ) ? 7 : 6 ; row . add ( hexField = new NumberField ( hexCount , true ) ) ; row . add ( Box . createHorizontalGlue ( ) ) ; box . add ( row ) ; box . add ( Box . createVerticalStrut ( GAP ) ) ; row = Box . createHorizontalBox ( ) ; if ( Base . isMacOS ( ) ) { row . add ( Box . createHorizontalStrut ( 11 ) ) ; } else { row . add ( createFixedLabel ( "" ) ) ; } JButton button = new JButton ( buttonName ) ; button . addActionListener ( buttonListener ) ; row . add ( button ) ; row . add ( Box . createHorizontalGlue ( ) ) ; box . add ( row ) ; row = Box . createHorizontalBox ( ) ; if ( Base . isMacOS ( ) ) { row . add ( Box . createHorizontalStrut ( 11 ) ) ; } else { row . add ( createFixedLabel ( "" ) ) ; } button = new JButton ( Language . text ( "prompt.cancel" ) ) ; button . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { ColorChooser . this . hide ( ) ; } } ) ; row . add ( button ) ; row . add ( Box . createHorizontalGlue ( ) ) ; box . add ( row ) ; box . add ( Box . createVerticalGlue ( ) ) ; return box ; } int labelH ; protected JLabel createFixedLabel ( String title ) { JLabel label = new JLabel ( title ) ; if ( labelH == 0 ) { labelH = label . getPreferredSize ( ) . height ; } Dimension dim = new Dimension ( 15 , labelH ) ; label . setPreferredSize ( dim ) ; label . setMinimumSize ( dim ) ; label . setMaximumSize ( dim ) ; return label ; } public class ColorRange extends JComponent { static final int WIDE = 256 ; static final int HIGH = 256 ; private int lastX , lastY ; public ColorRange ( ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . CROSSHAIR_CURSOR ) ) ; addMouseListener ( new MouseAdapter ( ) { @ Override public void mousePressed ( MouseEvent e ) { updateMouse ( e ) ; } } ) ; addMouseMotionListener ( new MouseMotionAdapter ( ) { @ Override public void mouseDragged ( MouseEvent e ) { updateMouse ( e ) ; } } ) ; addKeyListener ( new KeyAdapter ( ) { @ Override public void keyPressed ( KeyEvent e ) { super . keyPressed ( e ) ; if ( e . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) { ColorChooser . this . hide ( ) ; } } } ) ; } private void updateMouse ( MouseEvent e ) { int mouseX = e . getX ( ) ; int mouseY = e . getY ( ) ; if ( ( mouseX >= 0 ) && ( mouseX < WIDE ) && ( mouseY >= 0 ) && ( mouseY < HIGH ) ) { int nsaturation = ( int ) ( 100 * ( mouseX / 255.0f ) ) ; int nbrightness = 100 - ( ( int ) ( 100 * ( mouseY / 255.0f ) ) ) ; saturationField . setText ( String . valueOf ( nsaturation ) ) ; brightnessField . setText ( String . valueOf ( nbrightness ) ) ; lastX = mouseX ; lastY = mouseY ; } } @ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; for ( int j = 0 ; j < WIDE ; j ++ ) { for ( int i = 0 ; i < HIGH ; i ++ ) { g . setColor ( Color . getHSBColor ( hue / 360f , i / 256f , ( 255 - j ) / 256f ) ) ; g . fillRect ( i , j , 1 , 1 ) ; } } g . setColor ( ( brightness > 50 ) ? Color . BLACK : Color . WHITE ) ; g . drawRect ( lastX - 5 , lastY - 5 , 10 , 10 ) ; } @ Override public Dimension getPreferredSize ( ) { return new Dimension ( WIDE , HIGH ) ; } @ Override public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } @ Override public Dimension getMaximumSize ( ) { return getPreferredSize ( ) ; } } public class ColorSlider extends JComponent { static final int WIDE = 20 ; static final int HIGH = 256 ; public ColorSlider ( ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . CROSSHAIR_CURSOR ) ) ; addMouseListener ( new MouseAdapter ( ) { @ Override public void mousePressed ( MouseEvent e ) { updateMouse ( e ) ; } } ) ; addMouseMotionListener ( new MouseMotionAdapter ( ) { @ Override public void mouseDragged ( MouseEvent e ) { updateMouse ( e ) ; } } ) ; addKeyListener ( new KeyAdapter ( ) { @ Override public void keyPressed ( KeyEvent e ) { super . keyPressed ( e ) ; if ( e . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) { ColorChooser . this . hide ( ) ; } } } ) ; } private void updateMouse ( MouseEvent e ) { int mouseX = e . getX ( ) ; int mouseY = e . getY ( ) ; if ( ( mouseX >= 0 ) && ( mouseX < WIDE ) && ( mouseY >= 0 ) && ( mouseY < HIGH ) ) { int nhue = 359 - ( int ) ( 359 * ( mouseY / 255.0f ) ) ; hueField . setText ( String . valueOf ( nhue ) ) ; } } public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; int sel = 255 - ( int ) ( 255 * ( hue / 359.0 ) ) ; for ( int j = 0 ; j < HIGH ; j ++ ) { Color color = Color . getHSBColor ( ( 255 - j ) / 256f , 1 , 1 ) ; if ( j == sel ) { color = Color . BLACK ; } g . setColor ( color ) ; g . drawRect ( 0 , j , WIDE , 1 ) ; } } public Dimension getPreferredSize ( ) { return new Dimension ( WIDE , HIGH ) ; } public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } public Dimension getMaximumSize ( ) { return getPreferredSize ( ) ; } } static class NumberField extends JTextField { public boolean allowHex ; public NumberField ( int cols , boolean allowHex ) { super ( cols ) ; this . allowHex = allowHex ; } protected Document createDefaultModel ( ) { return new NumberDocument ( this ) ; } public Dimension getPreferredSize ( ) { if ( ! allowHex ) { return new Dimension ( 45 , super . getPreferredSize ( ) . height ) ; } return super . getPreferredSize ( ) ; } public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } public Dimension getMaximumSize ( ) { return getPreferredSize ( ) ; } } static class NumberDocument extends PlainDocument { NumberField parentField ; public NumberDocument ( NumberField parentField ) { this . parentField = parentField ; } public void insertString ( int offs , String str , AttributeSet a ) throws BadLocationException { if ( str == null ) return ; char chars [ ] = str . toCharArray ( ) ; int charCount = 0 ; for ( int i = 0 ; i < chars . length ; i ++ ) { boolean ok = Character . isDigit ( chars [ i ] ) ; if ( parentField . allowHex ) { if ( ( chars [ i ] >= 'A' ) && ( chars [ i ] <= 'F' ) ) ok = true ; if ( ( chars [ i ] >= 'a' ) && ( chars [ i ] <= 'f' ) ) ok = true ; if ( ( offs == 0 ) && ( i == 0 ) && ( chars [ i ] == '#' ) ) ok = true ; } if ( ok ) { if ( charCount != i ) { chars [ charCount ] = chars [ i ] ; } charCount ++ ; } } super . insertString ( offs , new String ( chars , 0 , charCount ) , a ) ; } } }
package processing . app . platform ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import com . apple . eio . FileManager ; import processing . app . Base ; import processing . app . Platform ; public class MacPlatform extends Platform { public void saveLanguage ( String language ) { String [ ] cmdarray = new String [ ] { "defaults" , "write" , System . getProperty ( "user.home" ) + "/Library/Preferences/org.processing.app" , "AppleLanguages" , "-array" , language } ; try { Runtime . getRuntime ( ) . exec ( cmdarray ) ; } catch ( IOException e ) { Base . log ( "Error saving platform language: " + e . getMessage ( ) ) ; } } public void init ( Base base ) { super . init ( base ) ; System . setProperty ( "apple.laf.useScreenMenuBar" , "true" ) ; ThinkDifferent . init ( base ) ; } public File getSettingsFolder ( ) throws Exception { return new File ( getLibraryFolder ( ) , "Processing" ) ; } public File getDefaultSketchbookFolder ( ) throws Exception { return new File ( getDocumentsFolder ( ) , "Processing" ) ; } static final int kDocumentsFolderType = ( 'd' < < 24 ) | ( 'o' < < 16 ) | ( 'c' < < 8 ) | 's' ; static final int kDomainLibraryFolderType = ( 'd' < < 24 ) | ( 'l' < < 16 ) | ( 'i' < < 8 ) | 'b' ; static final short kUserDomain = - 32763 ; protected String getLibraryFolder ( ) throws FileNotFoundException { return FileManager . findFolder ( kUserDomain , kDomainLibraryFolderType ) ; } protected String getDocumentsFolder ( ) throws FileNotFoundException { return FileManager . findFolder ( kUserDomain , kDocumentsFolderType ) ; } }
package processing . app . platform ; import java . io . File ; import java . awt . Toolkit ; import processing . app . Base ; import processing . app . Platform ; import processing . app . Preferences ; public class LinuxPlatform extends Platform { public void init ( Base base ) { super . init ( base ) ; String javaVendor = System . getProperty ( "java.vendor" ) ; String javaVM = System . getProperty ( "java.vm.name" ) ; if ( javaVendor == null || ( ! javaVendor . contains ( "Sun" ) && ! javaVendor . contains ( "Oracle" ) ) || javaVM == null || ! javaVM . contains ( "Java" ) ) { Base . showWarning ( "Not fond of this Java VM" , "Processing requires Java 7 from Sun (i.e. the sun-java-jdk\n" + "package on Ubuntu). Other versions such as OpenJDK, IcedTea,\n" + "and GCJ are strongly discouraged. Among other things, you're\n" + "likely to run into problems with sketch window size and\n" + "placement. For more background, please read the wiki:\n" + "https://github.com/processing/processing/wiki/Supported-Platforms#Linux" , null ) ; } try { Toolkit xToolkit = Toolkit . getDefaultToolkit ( ) ; java . lang . reflect . Field awtAppClassNameField = xToolkit . getClass ( ) . getDeclaredField ( "awtAppClassName" ) ; awtAppClassNameField . setAccessible ( true ) ; awtAppClassNameField . set ( xToolkit , "Processing" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void openURL ( String url ) throws Exception { if ( openFolderAvailable ( ) ) { String launcher = Preferences . get ( "launcher" ) ; if ( launcher != null ) { Runtime . getRuntime ( ) . exec ( new String [ ] { launcher , url } ) ; } } } public boolean openFolderAvailable ( ) { if ( Preferences . get ( "launcher" ) != null ) { return true ; } try { Process p = Runtime . getRuntime ( ) . exec ( new String [ ] { "xdg-open" } ) ; p . waitFor ( ) ; Preferences . set ( "launcher" , "xdg-open" ) ; return true ; } catch ( Exception e ) { } try { Process p = Runtime . getRuntime ( ) . exec ( new String [ ] { "gnome-open" } ) ; p . waitFor ( ) ; Preferences . set ( "launcher" , "gnome-open" ) ; return true ; } catch ( Exception e ) { } try { Process p = Runtime . getRuntime ( ) . exec ( new String [ ] { "kde-open" } ) ; p . waitFor ( ) ; Preferences . set ( "launcher" , "kde-open" ) ; return true ; } catch ( Exception e ) { } return false ; } public void openFolder ( File file ) throws Exception { if ( openFolderAvailable ( ) ) { String lunch = Preferences . get ( "launcher" ) ; try { String [ ] params = new String [ ] { lunch , file . getAbsolutePath ( ) } ; Runtime . getRuntime ( ) . exec ( params ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "No launcher set, cannot open " + file . getAbsolutePath ( ) ) ; } } }
package processing . app . platform ; import java . awt . event . * ; import java . io . File ; import javax . swing . * ; import com . apple . eawt . * ; import com . apple . eawt . AppEvent . * ; import processing . app . * ; public class ThinkDifferent { private static ThinkDifferent adapter ; private static Application application ; static protected void init ( final Base base ) { if ( application == null ) { application = Application . getApplication ( ) ; } if ( adapter == null ) { adapter = new ThinkDifferent ( ) ; } application . setAboutHandler ( new AboutHandler ( ) { public void handleAbout ( AboutEvent ae ) { new About ( null ) ; } } ) ; application . setPreferencesHandler ( new PreferencesHandler ( ) { public void handlePreferences ( PreferencesEvent arg0 ) { base . handlePrefs ( ) ; } } ) ; application . setOpenFileHandler ( new OpenFilesHandler ( ) { public void openFiles ( OpenFilesEvent event ) { for ( File file : event . getFiles ( ) ) { base . handleOpen ( file . getAbsolutePath ( ) ) ; } } } ) ; application . setPrintFileHandler ( new PrintFilesHandler ( ) { public void printFiles ( PrintFilesEvent event ) { } } ) ; application . setQuitHandler ( new QuitHandler ( ) { public void handleQuitRequestWith ( QuitEvent event , QuitResponse response ) { if ( base . handleQuit ( ) ) { response . performQuit ( ) ; } else { response . cancelQuit ( ) ; } } } ) ; JMenuBar defaultMenuBar = new JMenuBar ( ) ; JMenu fileMenu = buildFileMenu ( base ) ; defaultMenuBar . add ( fileMenu ) ; Base . defaultFileMenu = fileMenu ; try { application . setDefaultMenuBar ( defaultMenuBar ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } static protected JMenu buildFileMenu ( final Base base ) { JMenuItem item ; JMenu fileMenu = new JMenu ( Language . text ( "menu.file" ) ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.file.new" ) , 'N' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . handleNew ( ) ; } } ) ; fileMenu . add ( item ) ; item = Toolkit . newJMenuItem ( Language . text ( "menu.file.open" ) , 'O' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . handleOpenPrompt ( ) ; } } ) ; fileMenu . add ( item ) ; item = Toolkit . newJMenuItemShift ( Language . text ( "menu.file.sketchbook" ) , 'K' ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { base . getNextMode ( ) . showSketchbookFrame ( ) ; } } ) ; fileMenu . add ( item ) ; item = Toolkit . newJMenuItemShift ( Language . text ( "menu.file.examples" ) , 'O' ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { base . thinkDifferentExamples ( ) ; } } ) ; fileMenu . add ( item ) ; return fileMenu ; } }
package processing . app . platform ; import java . io . UnsupportedEncodingException ; import java . util . HashMap ; import java . util . TreeMap ; import java . util . TreeSet ; import com . sun . jna . platform . win32 . Advapi32 ; import com . sun . jna . platform . win32 . WinBase ; import com . sun . jna . platform . win32 . WinError ; import com . sun . jna . platform . win32 . WinNT ; import com . sun . jna . platform . win32 . WinReg ; import com . sun . jna . platform . win32 . WinReg . HKEY ; import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; import com . sun . jna . ptr . IntByReference ; public class WindowsRegistry { static public enum REGISTRY_ROOT_KEY { CLASSES_ROOT , CURRENT_USER , LOCAL_MACHINE , USERS } ; private final static HashMap < REGISTRY_ROOT_KEY , WinReg . HKEY > rootKeyMap = new HashMap < REGISTRY_ROOT_KEY , WinReg . HKEY > ( ) ; static { rootKeyMap . put ( REGISTRY_ROOT_KEY . CLASSES_ROOT , WinReg . HKEY_CLASSES_ROOT ) ; rootKeyMap . put ( REGISTRY_ROOT_KEY . CURRENT_USER , WinReg . HKEY_CURRENT_USER ) ; rootKeyMap . put ( REGISTRY_ROOT_KEY . LOCAL_MACHINE , WinReg . HKEY_LOCAL_MACHINE ) ; rootKeyMap . put ( REGISTRY_ROOT_KEY . USERS , WinReg . HKEY_USERS ) ; } private static HKEY getRegistryRootKey ( REGISTRY_ROOT_KEY key ) { Advapi32 advapi32 = Advapi32 . INSTANCE ; HKEYByReference pHandle = new WinReg . HKEYByReference ( ) ; HKEY handle = null ; if ( advapi32 . RegOpenKeyEx ( rootKeyMap . get ( key ) , null , 0 , 0 , pHandle ) == WinError . ERROR_SUCCESS ) { handle = pHandle . getValue ( ) ; } return handle ; } private static HKEY openKey ( REGISTRY_ROOT_KEY rootKey , String subKeyName , int access ) { Advapi32 advapi32 = Advapi32 . INSTANCE ; HKEY rootKeyHandle = getRegistryRootKey ( rootKey ) ; HKEYByReference pHandle = new HKEYByReference ( ) ; if ( advapi32 . RegOpenKeyEx ( rootKeyHandle , subKeyName , 0 , access , pHandle ) == WinError . ERROR_SUCCESS ) { return pHandle . getValue ( ) ; } else { return null ; } } private static String convertBufferToString ( byte [ ] buf ) throws UnsupportedEncodingException { return new String ( buf , 0 , buf . length - 2 , "UTF-16LE" ) ; } private static int convertBufferToInt ( byte [ ] buf ) { return ( ( buf [ 0 ] & 0xff ) + ( ( buf [ 1 ] & 0xff ) < < 8 ) + ( ( buf [ 2 ] & 0xff ) < < 16 ) + ( ( buf [ 3 ] & 0xff ) < < 24 ) ) ; } static public String getStringValue ( REGISTRY_ROOT_KEY rootKey , String subKeyName , String name ) throws UnsupportedEncodingException { byte [ ] lpData = new byte [ 1 ] ; Advapi32 advapi32 = Advapi32 . INSTANCE ; IntByReference pType = new IntByReference ( ) ; IntByReference lpcbData = new IntByReference ( ) ; HKEY handle = openKey ( rootKey , subKeyName , WinNT . KEY_READ ) ; String ret = null ; if ( handle != null ) { if ( advapi32 . RegQueryValueEx ( handle , name , 0 , pType , lpData , lpcbData ) == WinError . ERROR_MORE_DATA ) { lpData = new byte [ lpcbData . getValue ( ) ] ; if ( advapi32 . RegQueryValueEx ( handle , name , 0 , pType , lpData , lpcbData ) == WinError . ERROR_SUCCESS ) { ret = convertBufferToString ( lpData ) ; } } advapi32 . RegCloseKey ( handle ) ; } return ret ; } static public int getIntValue ( REGISTRY_ROOT_KEY rootKey , String subKeyName , String name ) { Advapi32 advapi32 = Advapi32 . INSTANCE ; IntByReference pType = new IntByReference ( ) ; IntByReference lpcbData = new IntByReference ( ) ; HKEY handle = openKey ( rootKey , subKeyName , WinNT . KEY_READ ) ; int ret = 0 ; byte [ ] lpData = new byte [ 1 ] ; if ( handle != null ) { if ( advapi32 . RegQueryValueEx ( handle , name , 0 , pType , lpData , lpcbData ) == WinError . ERROR_MORE_DATA ) { lpData = new byte [ lpcbData . getValue ( ) ] ; if ( advapi32 . RegQueryValueEx ( handle , name , 0 , pType , lpData , lpcbData ) == WinError . ERROR_SUCCESS ) { ret = convertBufferToInt ( lpData ) ; } } advapi32 . RegCloseKey ( handle ) ; } return ret ; } static public boolean deleteValue ( REGISTRY_ROOT_KEY rootKey , String subKeyName , String name ) { Advapi32 advapi32 = Advapi32 . INSTANCE ; HKEY handle = openKey ( rootKey , subKeyName , WinNT . KEY_READ | WinNT . KEY_WRITE ) ; boolean ret = true ; if ( handle != null ) { if ( advapi32 . RegDeleteValue ( handle , name ) == WinError . ERROR_SUCCESS ) { ret = true ; } advapi32 . RegCloseKey ( handle ) ; } return ret ; } static public boolean setStringValue ( REGISTRY_ROOT_KEY rootKey , String subKeyName , String name , String value ) throws UnsupportedEncodingException { byte [ ] data = new byte [ value . length ( ) * 2 + 2 ] ; byte [ ] src = value . getBytes ( "UTF-16LE" ) ; System . arraycopy ( src , 0 , data , 0 , src . length ) ; Advapi32 advapi32 = Advapi32 . INSTANCE ; HKEY handle = openKey ( rootKey , subKeyName , WinNT . KEY_READ | WinNT . KEY_WRITE ) ; boolean ret = false ; if ( handle != null ) { if ( advapi32 . RegSetValueEx ( handle , name , 0 , WinNT . REG_SZ , data , data . length ) == WinError . ERROR_SUCCESS ) { ret = true ; } advapi32 . RegCloseKey ( handle ) ; } return ret ; } static public boolean setIntValue ( REGISTRY_ROOT_KEY rootKey , String subKeyName , String name , int value ) { byte [ ] data = new byte [ 4 ] ; data [ 0 ] = ( byte ) ( value & 0xff ) ; data [ 1 ] = ( byte ) ( ( value > > 8 ) & 0xff ) ; data [ 2 ] = ( byte ) ( ( value > > 16 ) & 0xff ) ; data [ 3 ] = ( byte ) ( ( value > > 24 ) & 0xff ) ; Advapi32 advapi32 = Advapi32 . INSTANCE ; HKEY handle = openKey ( rootKey , subKeyName , WinNT . KEY_READ | WinNT . KEY_WRITE ) ; boolean ret = false ; if ( handle != null ) { if ( advapi32 . RegSetValueEx ( handle , name , 0 , WinNT . REG_DWORD , data , data . length ) == WinError . ERROR_SUCCESS ) { ret = true ; } advapi32 . RegCloseKey ( handle ) ; } return ret ; } static public boolean valueExists ( REGISTRY_ROOT_KEY rootKey , String subKeyName , String name ) { Advapi32 advapi32 = Advapi32 . INSTANCE ; IntByReference pType = new IntByReference ( ) ; IntByReference lpcbData = new IntByReference ( ) ; HKEY handle = openKey ( rootKey , subKeyName , WinNT . KEY_READ ) ; byte [ ] lpData = new byte [ 1 ] ; boolean ret = false ; if ( handle != null ) { if ( advapi32 . RegQueryValueEx ( handle , name , 0 , pType , lpData , lpcbData ) != WinError . ERROR_FILE_NOT_FOUND ) { ret = true ; } else { ret = false ; } advapi32 . RegCloseKey ( handle ) ; } return ret ; } static public boolean createKey ( REGISTRY_ROOT_KEY rootKey , String parent , String name ) { Advapi32 advapi32 = Advapi32 . INSTANCE ; HKEYByReference hkResult = new HKEYByReference ( ) ; IntByReference dwDisposition = new IntByReference ( ) ; HKEY handle = openKey ( rootKey , parent , WinNT . KEY_READ ) ; boolean ret = false ; if ( handle != null ) { if ( advapi32 . RegCreateKeyEx ( handle , name , 0 , null , WinNT . REG_OPTION_NON_VOLATILE , WinNT . KEY_READ , null , hkResult , dwDisposition ) == WinError . ERROR_SUCCESS ) { ret = true ; advapi32 . RegCloseKey ( hkResult . getValue ( ) ) ; } else { ret = false ; } advapi32 . RegCloseKey ( handle ) ; } return ret ; } static public boolean deleteKey ( REGISTRY_ROOT_KEY rootKey , String parent , String name ) { Advapi32 advapi32 = Advapi32 . INSTANCE ; HKEY handle = openKey ( rootKey , parent , WinNT . KEY_READ ) ; boolean ret = false ; if ( handle != null ) { if ( advapi32 . RegDeleteKey ( handle , name ) == WinError . ERROR_SUCCESS ) { ret = true ; } else { ret = false ; } advapi32 . RegCloseKey ( handle ) ; } return ret ; } static public String [ ] getSubKeys ( REGISTRY_ROOT_KEY rootKey , String parent ) { TreeSet < String > subKeys = new TreeSet < String > ( ) ; Advapi32 advapi32 = Advapi32 . INSTANCE ; HKEY handle = openKey ( rootKey , parent , WinNT . KEY_READ ) ; char [ ] lpName = new char [ 256 ] ; IntByReference lpcName = new IntByReference ( 256 ) ; WinBase . FILETIME lpftLastWriteTime = new WinBase . FILETIME ( ) ; if ( handle != null ) { int dwIndex = 0 ; while ( advapi32 . RegEnumKeyEx ( handle , dwIndex , lpName , lpcName , null , null , null , lpftLastWriteTime ) == WinError . ERROR_SUCCESS ) { subKeys . add ( new String ( lpName , 0 , lpcName . getValue ( ) ) ) ; lpcName . setValue ( 256 ) ; dwIndex ++ ; } advapi32 . RegCloseKey ( handle ) ; } return subKeys . toArray ( new String [ ] { } ) ; } static public TreeMap < String , Object > getValues ( REGISTRY_ROOT_KEY rootKey , String key ) throws UnsupportedEncodingException { TreeMap < String , Object > values = new TreeMap < String , Object > ( String . CASE_INSENSITIVE_ORDER ) ; Advapi32 advapi32 = Advapi32 . INSTANCE ; HKEY handle = openKey ( rootKey , key , WinNT . KEY_READ ) ; char [ ] lpValueName = new char [ 16384 ] ; IntByReference lpcchValueName = new IntByReference ( 16384 ) ; IntByReference lpType = new IntByReference ( ) ; byte [ ] lpData = new byte [ 1 ] ; IntByReference lpcbData = new IntByReference ( ) ; if ( handle != null ) { int dwIndex = 0 ; int result = 0 ; String name ; do { lpcbData . setValue ( 0 ) ; result = advapi32 . RegEnumValue ( handle , dwIndex , lpValueName , lpcchValueName , null , lpType , lpData , lpcbData ) ; if ( result == WinError . ERROR_MORE_DATA ) { lpData = new byte [ lpcbData . getValue ( ) ] ; lpcchValueName = new IntByReference ( 16384 ) ; result = advapi32 . RegEnumValue ( handle , dwIndex , lpValueName , lpcchValueName , null , lpType , lpData , lpcbData ) ; if ( result == WinError . ERROR_SUCCESS ) { name = new String ( lpValueName , 0 , lpcchValueName . getValue ( ) ) ; switch ( lpType . getValue ( ) ) { case WinNT . REG_SZ : values . put ( name , convertBufferToString ( lpData ) ) ; break ; case WinNT . REG_DWORD : values . put ( name , convertBufferToInt ( lpData ) ) ; break ; default : break ; } } } dwIndex ++ ; } while ( result == WinError . ERROR_SUCCESS ) ; advapi32 . RegCloseKey ( handle ) ; } return values ; } }
package processing . core ; import java . awt . Image ; import com . apple . eawt . AppEvent . QuitEvent ; import com . apple . eawt . Application ; import com . apple . eawt . QuitHandler ; import com . apple . eawt . QuitResponse ; public class ThinkDifferent { private static Application application ; static boolean attemptedQuit ; static public void init ( final PApplet sketch ) { if ( application == null ) { application = Application . getApplication ( ) ; } application . setQuitHandler ( new QuitHandler ( ) { public void handleQuitRequestWith ( QuitEvent event , QuitResponse response ) { sketch . exit ( ) ; if ( ! attemptedQuit ) { response . cancelQuit ( ) ; attemptedQuit = true ; } else { response . performQuit ( ) ; } } } ) ; } static void setIconImage ( Image image ) { application . setDockIconImage ( image ) ; } }
package processing . app . platform ; import java . io . File ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import com . sun . jna . Library ; import com . sun . jna . Native ; import com . sun . jna . platform . win32 . Kernel32Util ; import com . sun . jna . platform . win32 . Shell32 ; import com . sun . jna . platform . win32 . ShlObj ; import com . sun . jna . platform . win32 . WinDef ; import com . sun . jna . platform . win32 . WinError ; import com . sun . jna . platform . win32 . WinNT . HRESULT ; import processing . app . Base ; import processing . app . Platform ; import processing . app . Preferences ; import processing . app . platform . WindowsRegistry . REGISTRY_ROOT_KEY ; import processing . core . PApplet ; public class WindowsPlatform extends Platform { static final String APP_NAME = "Processing" ; static final String REG_OPEN_COMMAND = System . getProperty ( "user.dir" ) . replace ( '/' , '\\' ) + "\\" + APP_NAME . toLowerCase ( ) + ".exe \"%1\"" ; static final String REG_DOC = APP_NAME + ".Document" ; public void init ( Base base ) { super . init ( base ) ; checkAssociations ( ) ; checkPath ( ) ; } protected void checkAssociations ( ) { try { if ( Preferences . getBoolean ( "platform.auto_file_type_associations" ) ) { String knownCommand = WindowsRegistry . getStringValue ( REGISTRY_ROOT_KEY . CURRENT_USER , "Software\\Classes\\" + REG_DOC + "\\shell\\open\\command" , "" ) ; if ( knownCommand == null || ! knownCommand . equals ( REG_OPEN_COMMAND ) ) { setAssociations ( ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } protected void setAssociations ( ) throws UnsupportedEncodingException { final REGISTRY_ROOT_KEY rootKey = REGISTRY_ROOT_KEY . CURRENT_USER ; final String docPrefix = "Software\\Classes\\" + REG_DOC ; if ( WindowsRegistry . createKey ( rootKey , "Software\\Classes" , ".pde" ) && WindowsRegistry . setStringValue ( rootKey , "Software\\Classes\\.pde" , "" , REG_DOC ) && WindowsRegistry . createKey ( rootKey , "Software\\Classes" , REG_DOC ) && WindowsRegistry . setStringValue ( rootKey , docPrefix , "" , APP_NAME + " Source Code" ) && WindowsRegistry . createKey ( rootKey , docPrefix , "shell" ) && WindowsRegistry . createKey ( rootKey , docPrefix + "\\shell" , "open" ) && WindowsRegistry . createKey ( rootKey , docPrefix + "\\shell\\open" , "command" ) && WindowsRegistry . setStringValue ( rootKey , docPrefix + "\\shell\\open\\command" , "" , REG_OPEN_COMMAND ) ) { } else { Base . log ( "Could not associate files, turning off auto-associate pref." ) ; Preferences . setBoolean ( "platform.auto_file_type_associations" , false ) ; } } protected void checkPath ( ) { String path = System . getProperty ( "java.library.path" ) ; String [ ] pieces = PApplet . split ( path , File . pathSeparatorChar ) ; String [ ] legit = new String [ pieces . length ] ; int legitCount = 0 ; for ( String item : pieces ) { if ( item . startsWith ( "\"" ) ) { item = item . substring ( 1 ) ; } if ( item . endsWith ( "\"" ) ) { item = item . substring ( 0 , item . length ( ) - 1 ) ; } if ( item . endsWith ( File . separator ) ) { item = item . substring ( 0 , item . length ( ) - File . separator . length ( ) ) ; } File directory = new File ( item ) ; if ( ! directory . exists ( ) ) { continue ; } if ( item . trim ( ) . length ( ) == 0 ) { continue ; } legit [ legitCount ++ ] = item ; } legit = PApplet . subset ( legit , 0 , legitCount ) ; String newPath = PApplet . join ( legit , File . pathSeparator ) ; if ( ! newPath . equals ( path ) ) { System . setProperty ( "java.library.path" , newPath ) ; } } public File getSettingsFolder ( ) throws Exception { String appData = getAppDataPath ( ) ; if ( appData != null ) { return new File ( appData , APP_NAME ) ; } throw new IOException ( "Could not get the Application Data folder" ) ; } static private String getAppDataPath ( ) throws Exception { char [ ] pszPath = new char [ WinDef . MAX_PATH ] ; HRESULT hResult = Shell32 . INSTANCE . SHGetFolderPath ( null , ShlObj . CSIDL_APPDATA , null , ShlObj . SHGFP_TYPE_CURRENT , pszPath ) ; if ( ! hResult . equals ( WinError . S_OK ) ) { System . err . println ( Kernel32Util . formatMessageFromHR ( hResult ) ) ; throw new Exception ( "Problem city, population: your computer." ) ; } String appDataPath = new String ( pszPath ) ; int len = appDataPath . indexOf ( "\0" ) ; return appDataPath . substring ( 0 , len ) ; } public File getDefaultSketchbookFolder ( ) throws Exception { String documentsPath = getDocumentsPath ( ) ; if ( documentsPath != null ) { return new File ( documentsPath , APP_NAME ) ; } return null ; } static private String getDocumentsPath ( ) throws Exception { char [ ] pszPath = new char [ WinDef . MAX_PATH ] ; HRESULT hResult = Shell32 . INSTANCE . SHGetFolderPath ( null , ShlObj . CSIDL_PERSONAL , null , ShlObj . SHGFP_TYPE_CURRENT , pszPath ) ; if ( ! hResult . equals ( WinError . S_OK ) ) { System . err . println ( Kernel32Util . formatMessageFromHR ( hResult ) ) ; throw new Exception ( "Problem city, population: your computer." ) ; } String personalPath = new String ( pszPath ) ; int len = personalPath . indexOf ( "\0" ) ; return personalPath . substring ( 0 , len ) ; } static WinLibC clib = ( WinLibC ) Native . loadLibrary ( "msvcrt" , WinLibC . class ) ; public interface WinLibC extends Library { public int _putenv ( String name ) ; } public void setenv ( String variable , String value ) { clib . _putenv ( variable + "=" + value ) ; } public String getenv ( String variable ) { return System . getenv ( variable ) ; } public int unsetenv ( String variable ) { return clib . _putenv ( variable + "=" ) ; } }
package processing . app . tools ; import processing . app . Editor ; public interface Tool extends Runnable { public void init ( Editor editor ) ; public void run ( ) ; public String getMenuTitle ( ) ; }
package processing . app . tools ; import processing . app . * ; import processing . core . PApplet ; import java . io . * ; import java . text . * ; import java . util . * ; import java . util . zip . * ; public class Archiver implements Tool { Editor editor ; boolean useDate ; int digits = 3 ; NumberFormat numberFormat ; SimpleDateFormat dateFormat ; public String getMenuTitle ( ) { return Language . text ( "menu.tools.archive_sketch" ) ; } public void init ( Editor editor ) { this . editor = editor ; numberFormat = NumberFormat . getInstance ( ) ; numberFormat . setGroupingUsed ( false ) ; numberFormat . setMinimumIntegerDigits ( digits ) ; dateFormat = new SimpleDateFormat ( "yyMMdd" ) ; } public void run ( ) { Sketch sketch = editor . getSketch ( ) ; if ( sketch . isModified ( ) ) { Base . showWarning ( "Save" , "Please save the sketch before archiving." , null ) ; return ; } File location = sketch . getFolder ( ) ; String name = location . getName ( ) ; File parent = new File ( location . getParent ( ) ) ; File newbie = null ; String namely = null ; int index = 0 ; do { useDate = ! name . startsWith ( "sketch_" ) ; if ( useDate ) { String purty = dateFormat . format ( new Date ( ) ) ; String stamp = purty + ( ( char ) ( 'a' + index ) ) ; namely = name + "-" + stamp ; newbie = new File ( parent , namely + ".zip" ) ; } else { String diggie = numberFormat . format ( index + 1 ) ; namely = name + "-" + diggie ; newbie = new File ( parent , namely + ".zip" ) ; } index ++ ; } while ( newbie . exists ( ) ) ; PApplet . selectOutput ( Language . text ( "archive_sketch" ) , "fileSelected" , newbie , this , editor ) ; } public void fileSelected ( File newbie ) { if ( newbie != null ) { try { if ( ! newbie . getName ( ) . toLowerCase ( ) . endsWith ( ".zip" ) ) { newbie = new File ( newbie . getAbsolutePath ( ) + ".zip" ) ; } FileOutputStream zipOutputFile = new FileOutputStream ( newbie ) ; ZipOutputStream zos = new ZipOutputStream ( zipOutputFile ) ; File sketchFolder = editor . getSketch ( ) . getFolder ( ) ; buildZip ( sketchFolder , sketchFolder . getName ( ) , zos ) ; zos . flush ( ) ; zos . close ( ) ; final String msg = Language . interpolate ( "editor.status.archiver.create" , newbie . getName ( ) ) ; editor . statusNotice ( msg ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { editor . statusNotice ( Language . text ( "editor.status.archiver.cancel" ) ) ; } } public void buildZip ( File dir , String sofar , ZipOutputStream zos ) throws IOException { String files [ ] = dir . list ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . equals ( "." ) || files [ i ] . equals ( ".." ) ) continue ; File sub = new File ( dir , files [ i ] ) ; String nowfar = ( sofar == null ) ? files [ i ] : ( sofar + "/" + files [ i ] ) ; if ( sub . isDirectory ( ) ) { ZipEntry entry = new ZipEntry ( nowfar + "/" ) ; zos . putNextEntry ( entry ) ; zos . closeEntry ( ) ; buildZip ( sub , nowfar , zos ) ; } else { ZipEntry entry = new ZipEntry ( nowfar ) ; entry . setTime ( sub . lastModified ( ) ) ; zos . putNextEntry ( entry ) ; zos . write ( Base . loadBytesRaw ( sub ) ) ; zos . closeEntry ( ) ; } } } }
package processing . app . tools ; import processing . app . * ; import java . awt . Color ; import java . awt . datatransfer . Clipboard ; import java . awt . datatransfer . StringSelection ; import java . awt . event . * ; public class ColorSelector implements Tool { private static volatile ColorChooser selector ; private Editor editor ; public String getMenuTitle ( ) { return Language . text ( "menu.tools.color_selector" ) ; } public void init ( Editor editor ) { this . editor = editor ; } public void run ( ) { if ( selector == null ) { synchronized ( ColorSelector . class ) { if ( selector == null ) { selector = new ColorChooser ( editor , false , Color . WHITE , Language . text ( "menu.edit.copy" ) , new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Clipboard clipboard = Toolkit . getSystemClipboard ( ) ; clipboard . setContents ( new StringSelection ( selector . getHexColor ( ) ) , null ) ; } } ) ; } } } selector . show ( ) ; } }
package processing . app . tools ; import processing . app . * ; import processing . core . * ; import java . awt . Component ; import java . awt . Dimension ; import java . awt . BorderLayout ; import java . awt . Color ; import java . awt . Container ; import java . awt . Font ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . GraphicsEnvironment ; import java . awt . RenderingHints ; import java . awt . event . * ; import java . io . * ; import java . util . * ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; public class CreateFont extends JFrame implements Tool { Editor editor ; JList < String > fontSelector ; JTextField sizeSelector ; JButton charsetButton ; JCheckBox smoothBox ; JComponent sample ; JButton okButton ; JTextField filenameField ; HashMap < String , Font > table ; boolean smooth = true ; Font font ; String [ ] list ; int selection = - 1 ; CharacterSelector charSelector ; public CreateFont ( ) { super ( Language . text ( "create_font" ) ) ; } public String getMenuTitle ( ) { return Language . text ( "menu.tools.create_font" ) ; } public void init ( Editor editor ) { this . editor = editor ; Container paine = getContentPane ( ) ; paine . setLayout ( new BorderLayout ( ) ) ; JPanel pain = new JPanel ( ) ; pain . setBorder ( new EmptyBorder ( 13 , 13 , 13 , 13 ) ) ; paine . add ( pain , BorderLayout . CENTER ) ; pain . setLayout ( new BoxLayout ( pain , BoxLayout . Y_AXIS ) ) ; String labelText = Language . text ( "create_font.label" ) ; JTextArea textarea = new JTextArea ( labelText ) ; textarea . setBorder ( new EmptyBorder ( 10 , 10 , 20 , 10 ) ) ; textarea . setBackground ( null ) ; textarea . setEditable ( false ) ; textarea . setHighlighter ( null ) ; textarea . setFont ( new Font ( "Dialog" , Font . PLAIN , 12 ) ) ; pain . add ( textarea ) ; GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; Font [ ] fonts = ge . getAllFonts ( ) ; if ( false ) { ArrayList < Font > fontList = new ArrayList < Font > ( ) ; File folderList = new File ( "/Users/fry/coconut/sys/fonts/web" ) ; for ( File folder : folderList . listFiles ( ) ) { if ( folder . isDirectory ( ) ) { File [ ] items = folder . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { if ( name . charAt ( 0 ) == '.' ) return false ; return ( name . toLowerCase ( ) . endsWith ( ".ttf" ) || name . toLowerCase ( ) . endsWith ( ".otf" ) ) ; } } ) ; for ( File fontFile : items ) { try { FileInputStream fis = new FileInputStream ( fontFile ) ; BufferedInputStream input = new BufferedInputStream ( fis ) ; Font font = Font . createFont ( Font . TRUETYPE_FONT , input ) ; input . close ( ) ; fontList . add ( font ) ; } catch ( Exception e ) { System . out . println ( "Ignoring " + fontFile . getName ( ) ) ; } } } } fonts = fontList . toArray ( new Font [ fontList . size ( ) ] ) ; } String flist [ ] = new String [ fonts . length ] ; table = new HashMap < String , Font > ( ) ; int index = 0 ; for ( int i = 0 ; i < fonts . length ; i ++ ) { try { flist [ index ++ ] = fonts [ i ] . getPSName ( ) ; table . put ( fonts [ i ] . getPSName ( ) , fonts [ i ] ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } list = new String [ index ] ; System . arraycopy ( flist , 0 , list , 0 , index ) ; fontSelector = new JList < String > ( list ) ; fontSelector . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent e ) { if ( e . getValueIsAdjusting ( ) == false ) { selection = fontSelector . getSelectedIndex ( ) ; okButton . setEnabled ( true ) ; update ( ) ; } } } ) ; fontSelector . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; fontSelector . setVisibleRowCount ( 12 ) ; JScrollPane fontScroller = new JScrollPane ( fontSelector ) ; pain . add ( fontScroller ) ; Dimension d1 = new Dimension ( 13 , 13 ) ; pain . add ( new Box . Filler ( d1 , d1 , d1 ) ) ; sample = new SampleComponent ( this ) ; sample . setFont ( new Font ( "Dialog" , Font . PLAIN , 12 ) ) ; pain . add ( sample ) ; Dimension d2 = new Dimension ( 6 , 6 ) ; pain . add ( new Box . Filler ( d2 , d2 , d2 ) ) ; JPanel panel = new JPanel ( ) ; panel . add ( new JLabel ( Language . text ( "create_font.size" ) + ":" ) ) ; sizeSelector = new JTextField ( " 48 " ) ; sizeSelector . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { public void insertUpdate ( DocumentEvent e ) { update ( ) ; } public void removeUpdate ( DocumentEvent e ) { update ( ) ; } public void changedUpdate ( DocumentEvent e ) { } } ) ; panel . add ( sizeSelector ) ; smoothBox = new JCheckBox ( Language . text ( "create_font.smooth" ) ) ; smoothBox . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { smooth = smoothBox . isSelected ( ) ; update ( ) ; } } ) ; smoothBox . setSelected ( smooth ) ; panel . add ( smoothBox ) ; charsetButton = new JButton ( Language . text ( "create_font.characters" ) ) ; charsetButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { charSelector . setVisible ( true ) ; } } ) ; panel . add ( charsetButton ) ; pain . add ( panel ) ; JPanel filestuff = new JPanel ( ) ; filestuff . add ( new JLabel ( Language . text ( "create_font.filename" ) + ":" ) ) ; filestuff . add ( filenameField = new JTextField ( 20 ) ) ; filestuff . add ( new JLabel ( ".vlw" ) ) ; pain . add ( filestuff ) ; JPanel buttons = new JPanel ( ) ; JButton cancelButton = new JButton ( Language . text ( "prompt.cancel" ) ) ; cancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { setVisible ( false ) ; } } ) ; okButton = new JButton ( Language . text ( "prompt.ok" ) ) ; okButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { build ( ) ; } } ) ; okButton . setEnabled ( false ) ; buttons . add ( cancelButton ) ; buttons . add ( okButton ) ; pain . add ( buttons ) ; JRootPane root = getRootPane ( ) ; root . setDefaultButton ( okButton ) ; ActionListener disposer = new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { setVisible ( false ) ; } } ; Toolkit . registerWindowCloseKeys ( root , disposer ) ; Toolkit . setIcon ( this ) ; pack ( ) ; setResizable ( false ) ; sample . setFont ( new Font ( list [ 0 ] , Font . PLAIN , 48 ) ) ; fontSelector . setSelectedIndex ( 0 ) ; setLocationRelativeTo ( null ) ; charSelector = new CharacterSelector ( ) ; } public void run ( ) { setVisible ( true ) ; } public void update ( ) { int fontsize = 0 ; try { fontsize = Integer . parseInt ( sizeSelector . getText ( ) . trim ( ) ) ; } catch ( NumberFormatException e2 ) { } if ( ( fontsize > 0 ) && ( fontsize < 256 ) && ( selection != - 1 ) ) { Font instance = table . get ( list [ selection ] ) ; font = instance . deriveFont ( ( float ) fontsize ) ; sample . setFont ( font ) ; String filenameSuggestion = list [ selection ] . replace ( ' ' , '_' ) ; filenameSuggestion += "-" + fontsize ; filenameField . setText ( filenameSuggestion ) ; } } public void build ( ) { int fontsize = 0 ; try { fontsize = Integer . parseInt ( sizeSelector . getText ( ) . trim ( ) ) ; } catch ( NumberFormatException e ) { } if ( fontsize <= 0 ) { JOptionPane . showMessageDialog ( this , "Bad font size, try again." , "Badness" , JOptionPane . WARNING_MESSAGE ) ; return ; } String filename = filenameField . getText ( ) . trim ( ) ; if ( filename . length ( ) == 0 ) { JOptionPane . showMessageDialog ( this , "Enter a file name for the font." , "Lameness" , JOptionPane . WARNING_MESSAGE ) ; return ; } if ( ! filename . endsWith ( ".vlw" ) ) { filename += ".vlw" ; } try { Font instance = table . get ( list [ selection ] ) ; font = instance . deriveFont ( Font . PLAIN , fontsize ) ; PFont f = new PFont ( font , smooth , charSelector . getCharacters ( ) ) ; File folder = editor . getSketch ( ) . prepareDataFolder ( ) ; f . save ( new FileOutputStream ( new File ( folder , filename ) ) ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( CreateFont . this , "An error occurred while creating font." , "No font for you" , JOptionPane . WARNING_MESSAGE ) ; e . printStackTrace ( ) ; } setVisible ( false ) ; } } class SampleComponent extends JComponent { String text = "Forsaking monastic tradition, twelve jovial friars gave up their " + "vocation for a questionable existence on the flying trapeze." ; int high = 80 ; CreateFont parent ; public SampleComponent ( CreateFont p ) { this . parent = p ; addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent e ) { String input = ( String ) JOptionPane . showInputDialog ( parent , "Enter new sample text:" , "Sample Text" , JOptionPane . PLAIN_MESSAGE , null , null , text ) ; if ( input != null ) { text = input ; parent . repaint ( ) ; } } } ) ; } public void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setColor ( Color . WHITE ) ; Dimension dim = getSize ( ) ; g2 . fillRect ( 0 , 0 , dim . width , dim . height ) ; g2 . setColor ( Color . BLACK ) ; g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , parent . smooth ? RenderingHints . VALUE_TEXT_ANTIALIAS_ON : RenderingHints . VALUE_TEXT_ANTIALIAS_OFF ) ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , parent . smooth ? RenderingHints . VALUE_ANTIALIAS_ON : RenderingHints . VALUE_ANTIALIAS_OFF ) ; Font font = getFont ( ) ; int ascent = g2 . getFontMetrics ( ) . getAscent ( ) ; g2 . setFont ( font ) ; g2 . drawString ( text , 5 , dim . height - ( dim . height - ascent ) / 2 ) ; } public Dimension getPreferredSize ( ) { return new Dimension ( 400 , high ) ; } public Dimension getMaximumSize ( ) { return new Dimension ( 10000 , high ) ; } public Dimension getMinimumSize ( ) { return new Dimension ( 100 , high ) ; } } class CharacterSelector extends JFrame { JRadioButton defaultCharsButton ; JRadioButton allCharsButton ; JRadioButton unicodeCharsButton ; JScrollPane unicodeBlockScroller ; JList < JCheckBox > charsetList ; public CharacterSelector ( ) { super ( Language . text ( "create_font.character_selector" ) ) ; charsetList = new CheckBoxList ( ) ; DefaultListModel < JCheckBox > model = new DefaultListModel < JCheckBox > ( ) ; charsetList . setModel ( model ) ; for ( String item : blockNames ) { model . addElement ( new JCheckBox ( item ) ) ; } unicodeBlockScroller = new JScrollPane ( charsetList , ScrollPaneConstants . VERTICAL_SCROLLBAR_ALWAYS , ScrollPaneConstants . HORIZONTAL_SCROLLBAR_NEVER ) ; Container outer = getContentPane ( ) ; outer . setLayout ( new BorderLayout ( ) ) ; JPanel pain = new JPanel ( ) ; pain . setBorder ( new EmptyBorder ( 13 , 13 , 13 , 13 ) ) ; outer . add ( pain , BorderLayout . CENTER ) ; pain . setLayout ( new BoxLayout ( pain , BoxLayout . Y_AXIS ) ) ; String labelText = Language . text ( "create_font.character_selector.label" ) ; JTextArea textarea = new JTextArea ( labelText ) ; textarea . setBorder ( new EmptyBorder ( 13 , 8 , 13 , 8 ) ) ; textarea . setBackground ( null ) ; textarea . setEditable ( false ) ; textarea . setHighlighter ( null ) ; textarea . setFont ( new Font ( "Dialog" , Font . PLAIN , 12 ) ) ; pain . add ( textarea ) ; ActionListener listener = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { charsetList . setEnabled ( unicodeCharsButton . isSelected ( ) ) ; } } ; defaultCharsButton = new JRadioButton ( Language . text ( "create_font.default_characters" ) ) ; allCharsButton = new JRadioButton ( Language . text ( "create_font.all_characters" ) ) ; unicodeCharsButton = new JRadioButton ( Language . text ( "create_font.specific_unicode" ) ) ; defaultCharsButton . addActionListener ( listener ) ; allCharsButton . addActionListener ( listener ) ; unicodeCharsButton . addActionListener ( listener ) ; ButtonGroup group = new ButtonGroup ( ) ; group . add ( defaultCharsButton ) ; group . add ( allCharsButton ) ; group . add ( unicodeCharsButton ) ; JPanel radioPanel = new JPanel ( ) ; radioPanel . setLayout ( new BoxLayout ( radioPanel , BoxLayout . Y_AXIS ) ) ; radioPanel . add ( defaultCharsButton ) ; radioPanel . add ( allCharsButton ) ; radioPanel . add ( unicodeCharsButton ) ; JPanel rightStuff = new JPanel ( ) ; rightStuff . setLayout ( new BoxLayout ( rightStuff , BoxLayout . X_AXIS ) ) ; rightStuff . add ( radioPanel ) ; rightStuff . add ( Box . createHorizontalGlue ( ) ) ; pain . add ( rightStuff ) ; pain . add ( Box . createVerticalStrut ( 13 ) ) ; defaultCharsButton . setSelected ( true ) ; charsetList . setEnabled ( false ) ; pain . add ( unicodeBlockScroller ) ; pain . add ( Box . createVerticalStrut ( 8 ) ) ; JPanel buttons = new JPanel ( ) ; JButton okButton = new JButton ( Language . text ( "prompt.ok" ) ) ; okButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { setVisible ( false ) ; } } ) ; okButton . setEnabled ( true ) ; buttons . add ( okButton ) ; pain . add ( buttons ) ; JRootPane root = getRootPane ( ) ; root . setDefaultButton ( okButton ) ; ActionListener disposer = new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { setVisible ( false ) ; } } ; Toolkit . registerWindowCloseKeys ( root , disposer ) ; Toolkit . setIcon ( this ) ; pack ( ) ; Dimension screen = Toolkit . getScreenSize ( ) ; Dimension windowSize = getSize ( ) ; setLocation ( ( screen . width - windowSize . width ) / 2 , ( screen . height - windowSize . height ) / 2 ) ; } protected char [ ] getCharacters ( ) { if ( defaultCharsButton . isSelected ( ) ) { return PFont . CHARSET ; } char [ ] charset = new char [ 65536 ] ; if ( allCharsButton . isSelected ( ) ) { for ( int i = 0 ; i < 0xFFFF ; i ++ ) { charset [ i ] = ( char ) i ; } } else { DefaultListModel model = ( DefaultListModel ) charsetList . getModel ( ) ; int index = 0 ; for ( int i = 0 ; i < BLOCKS . length ; i ++ ) { if ( ( ( JCheckBox ) model . get ( i ) ) . isSelected ( ) ) { for ( int j = blockStart [ i ] ; j <= blockStop [ i ] ; j ++ ) { charset [ index ++ ] = ( char ) j ; } } } charset = PApplet . subset ( charset , 0 , index ) ; } return charset ; } static final String [ ] BLOCKS = { "0000..007F; Basic Latin" , "0080..00FF; Latin-1 Supplement" , "0100..017F; Latin Extended-A" , "0180..024F; Latin Extended-B" , "0250..02AF; IPA Extensions" , "02B0..02FF; Spacing Modifier Letters" , "0300..036F; Combining Diacritical Marks" , "0370..03FF; Greek and Coptic" , "0400..04FF; Cyrillic" , "0500..052F; Cyrillic Supplement" , "0530..058F; Armenian" , "0590..05FF; Hebrew" , "0600..06FF; Arabic" , "0700..074F; Syriac" , "0750..077F; Arabic Supplement" , "0780..07BF; Thaana" , "07C0..07FF; NKo" , "0800..083F; Samaritan" , "0900..097F; Devanagari" , "0980..09FF; Bengali" , "0A00..0A7F; Gurmukhi" , "0A80..0AFF; Gujarati" , "0B00..0B7F; Oriya" , "0B80..0BFF; Tamil" , "0C00..0C7F; Telugu" , "0C80..0CFF; Kannada" , "0D00..0D7F; Malayalam" , "0D80..0DFF; Sinhala" , "0E00..0E7F; Thai" , "0E80..0EFF; Lao" , "0F00..0FFF; Tibetan" , "1000..109F; Myanmar" , "10A0..10FF; Georgian" , "1100..11FF; Hangul Jamo" , "1200..137F; Ethiopic" , "1380..139F; Ethiopic Supplement" , "13A0..13FF; Cherokee" , "1400..167F; Unified Canadian Aboriginal Syllabics" , "1680..169F; Ogham" , "16A0..16FF; Runic" , "1700..171F; Tagalog" , "1720..173F; Hanunoo" , "1740..175F; Buhid" , "1760..177F; Tagbanwa" , "1780..17FF; Khmer" , "1800..18AF; Mongolian" , "18B0..18FF; Unified Canadian Aboriginal Syllabics Extended" , "1900..194F; Limbu" , "1950..197F; Tai Le" , "1980..19DF; New Tai Lue" , "19E0..19FF; Khmer Symbols" , "1A00..1A1F; Buginese" , "1A20..1AAF; Tai Tham" , "1B00..1B7F; Balinese" , "1B80..1BBF; Sundanese" , "1C00..1C4F; Lepcha" , "1C50..1C7F; Ol Chiki" , "1CD0..1CFF; Vedic Extensions" , "1D00..1D7F; Phonetic Extensions" , "1D80..1DBF; Phonetic Extensions Supplement" , "1DC0..1DFF; Combining Diacritical Marks Supplement" , "1E00..1EFF; Latin Extended Additional" , "1F00..1FFF; Greek Extended" , "2000..206F; General Punctuation" , "2070..209F; Superscripts and Subscripts" , "20A0..20CF; Currency Symbols" , "20D0..20FF; Combining Diacritical Marks for Symbols" , "2100..214F; Letterlike Symbols" , "2150..218F; Number Forms" , "2190..21FF; Arrows" , "2200..22FF; Mathematical Operators" , "2300..23FF; Miscellaneous Technical" , "2400..243F; Control Pictures" , "2440..245F; Optical Character Recognition" , "2460..24FF; Enclosed Alphanumerics" , "2500..257F; Box Drawing" , "2580..259F; Block Elements" , "25A0..25FF; Geometric Shapes" , "2600..26FF; Miscellaneous Symbols" , "2700..27BF; Dingbats" , "27C0..27EF; Miscellaneous Mathematical Symbols-A" , "27F0..27FF; Supplemental Arrows-A" , "2800..28FF; Braille Patterns" , "2900..297F; Supplemental Arrows-B" , "2980..29FF; Miscellaneous Mathematical Symbols-B" , "2A00..2AFF; Supplemental Mathematical Operators" , "2B00..2BFF; Miscellaneous Symbols and Arrows" , "2C00..2C5F; Glagolitic" , "2C60..2C7F; Latin Extended-C" , "2C80..2CFF; Coptic" , "2D00..2D2F; Georgian Supplement" , "2D30..2D7F; Tifinagh" , "2D80..2DDF; Ethiopic Extended" , "2DE0..2DFF; Cyrillic Extended-A" , "2E00..2E7F; Supplemental Punctuation" , "2E80..2EFF; CJK Radicals Supplement" , "2F00..2FDF; Kangxi Radicals" , "2FF0..2FFF; Ideographic Description Characters" , "3000..303F; CJK Symbols and Punctuation" , "3040..309F; Hiragana" , "30A0..30FF; Katakana" , "3100..312F; Bopomofo" , "3130..318F; Hangul Compatibility Jamo" , "3190..319F; Kanbun" , "31A0..31BF; Bopomofo Extended" , "31C0..31EF; CJK Strokes" , "31F0..31FF; Katakana Phonetic Extensions" , "3200..32FF; Enclosed CJK Letters and Months" , "3300..33FF; CJK Compatibility" , "3400..4DBF; CJK Unified Ideographs Extension A" , "4DC0..4DFF; Yijing Hexagram Symbols" , "4E00..9FFF; CJK Unified Ideographs" , "A000..A48F; Yi Syllables" , "A490..A4CF; Yi Radicals" , "A4D0..A4FF; Lisu" , "A500..A63F; Vai" , "A640..A69F; Cyrillic Extended-B" , "A6A0..A6FF; Bamum" , "A700..A71F; Modifier Tone Letters" , "A720..A7FF; Latin Extended-D" , "A800..A82F; Syloti Nagri" , "A830..A83F; Common Indic Number Forms" , "A840..A87F; Phags-pa" , "A880..A8DF; Saurashtra" , "A8E0..A8FF; Devanagari Extended" , "A900..A92F; Kayah Li" , "A930..A95F; Rejang" , "A960..A97F; Hangul Jamo Extended-A" , "A980..A9DF; Javanese" , "AA00..AA5F; Cham" , "AA60..AA7F; Myanmar Extended-A" , "AA80..AADF; Tai Viet" , "ABC0..ABFF; Meetei Mayek" , "AC00..D7AF; Hangul Syllables" , "D7B0..D7FF; Hangul Jamo Extended-B" , "D800..DB7F; High Surrogates" , "DB80..DBFF; High Private Use Surrogates" , "DC00..DFFF; Low Surrogates" , "E000..F8FF; Private Use Area" , "F900..FAFF; CJK Compatibility Ideographs" , "FB00..FB4F; Alphabetic Presentation Forms" , "FB50..FDFF; Arabic Presentation Forms-A" , "FE00..FE0F; Variation Selectors" , "FE10..FE1F; Vertical Forms" , "FE20..FE2F; Combining Half Marks" , "FE30..FE4F; CJK Compatibility Forms" , "FE50..FE6F; Small Form Variants" , "FE70..FEFF; Arabic Presentation Forms-B" , "FF00..FFEF; Halfwidth and Fullwidth Forms" , "FFF0..FFFF; Specials" } ; static String [ ] blockNames ; static int [ ] blockStart ; static int [ ] blockStop ; static { int count = BLOCKS . length ; blockNames = new String [ count ] ; blockStart = new int [ count ] ; blockStop = new int [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { String line = BLOCKS [ i ] ; blockStart [ i ] = PApplet . unhex ( line . substring ( 0 , 4 ) ) ; blockStop [ i ] = PApplet . unhex ( line . substring ( 6 , 10 ) ) ; blockNames [ i ] = line . substring ( 12 ) ; } } } class CheckBoxList extends JList < JCheckBox > { protected static Border noFocusBorder = new EmptyBorder ( 1 , 1 , 1 , 1 ) ; public CheckBoxList ( ) { setCellRenderer ( new CellRenderer ( ) ) ; addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent e ) { if ( isEnabled ( ) ) { int index = locationToIndex ( e . getPoint ( ) ) ; if ( index != - 1 ) { JCheckBox checkbox = getModel ( ) . getElementAt ( index ) ; checkbox . setSelected ( ! checkbox . isSelected ( ) ) ; repaint ( ) ; } } } } ) ; setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; } protected class CellRenderer implements ListCellRenderer { public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { JCheckBox checkbox = ( JCheckBox ) value ; checkbox . setBackground ( isSelected ? getSelectionBackground ( ) : getBackground ( ) ) ; checkbox . setForeground ( isSelected ? getSelectionForeground ( ) : getForeground ( ) ) ; checkbox . setEnabled ( list . isEnabled ( ) ) ; checkbox . setFont ( getFont ( ) ) ; checkbox . setFocusPainted ( false ) ; checkbox . setBorderPainted ( true ) ; checkbox . setBorder ( isSelected ? UIManager . getBorder ( "List.focusCellHighlightBorder" ) : noFocusBorder ) ; return checkbox ; } } }
package processing . app . tools ; import java . io . File ; import java . io . FilenameFilter ; import java . io . IOException ; import java . io . PrintWriter ; import javax . swing . JOptionPane ; import processing . app . Base ; import processing . app . Editor ; import processing . app . Language ; import processing . core . PApplet ; import processing . data . StringList ; public class InstallCommander implements Tool { Editor editor ; public String getMenuTitle ( ) { return Language . text ( "menu.tools.install_processing_java" ) ; } public void init ( Editor editor ) { this . editor = editor ; } public void run ( ) { try { final String primary = "Install processing-java for all users?" ; final String secondary = "This will install the processing-java program, which is capable " + "of building and running Java Mode sketches from the command line. " + "Click Yes to install it for all users (an administrator password " + "is required), or No to place the program in your home directory. " + "If you rename or move Processing.app, " + "you'll need to reinstall the tool." ; int result = JOptionPane . showConfirmDialog ( editor , "<html> " + "<head> <style type=\"text/css\">" + "b { font: 13pt \"Lucida Grande\" }" + "p { font: 11pt \"Lucida Grande\"; margin-top: 8px; width: 300px }" + "</style> </head>" + "<b>" + primary + "</b>" + "<p>" + secondary + "</p>" , "Commander" , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( result == JOptionPane . CANCEL_OPTION ) { return ; } File file = File . createTempFile ( "processing" , "commander" ) ; PrintWriter writer = PApplet . createWriter ( file ) ; writer . println ( "#!/bin/sh" ) ; String javaRoot = Base . getContentFile ( "." ) . getCanonicalPath ( ) ; StringList jarList = new StringList ( ) ; addJarList ( jarList , new File ( javaRoot ) ) ; addJarList ( jarList , new File ( javaRoot , "core/library" ) ) ; addJarList ( jarList , new File ( javaRoot , "modes/java/mode" ) ) ; String classPath = jarList . join ( ":" ) . replaceAll ( javaRoot + "\\/?" , "" ) ; writer . println ( "cd \"" + javaRoot + "\" && " + Base . getJavaPath ( ) + " -Djna.nosys=true" + " -cp \"" + classPath + "\"" + " processing.mode.java.Commander \"$@\"" ) ; writer . flush ( ) ; writer . close ( ) ; file . setExecutable ( true ) ; String sourcePath = file . getAbsolutePath ( ) ; if ( result == JOptionPane . YES_OPTION ) { String targetPath = "/usr/bin/processing-java" ; String shellScript = "/bin/mv " + sourcePath + " " + targetPath ; String appleScript = "do shell script \"" + shellScript + "\" with administrator privileges" ; PApplet . exec ( new String [ ] { "osascript" , "-e" , appleScript } ) ; } else if ( result == JOptionPane . NO_OPTION ) { File targetFile = new File ( System . getProperty ( "user.home" ) , "processing-java" ) ; String targetPath = targetFile . getAbsolutePath ( ) ; if ( targetFile . exists ( ) ) { Base . showWarning ( "File Already Exists" , "The processing-java program already exists at:\n" + targetPath + "\n" + "Please remove it and try again." , null ) ; } else { PApplet . exec ( new String [ ] { "mv" , sourcePath , targetPath } ) ; } } editor . statusNotice ( "Finished." ) ; } catch ( IOException e ) { Base . showWarning ( "Error while installing" , "An error occurred and the tools were not installed." , e ) ; } } static private void addJarList ( StringList list , File dir ) { File [ ] jars = dir . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . toLowerCase ( ) . endsWith ( ".jar" ) && ! name . startsWith ( "." ) ; } } ) ; for ( File jar : jars ) { list . append ( jar . getAbsolutePath ( ) ) ; } } }
package processing . app . exec ; import java . io . * ; public class StreamRedirectThread extends Thread { private final Reader in ; private final Writer out ; private static final int BUFFER_SIZE = 2048 ; public StreamRedirectThread ( String name , InputStream in , OutputStream out ) { super ( name ) ; this . in = new InputStreamReader ( in ) ; this . out = new OutputStreamWriter ( out ) ; setPriority ( Thread . MAX_PRIORITY - 1 ) ; } public StreamRedirectThread ( String name , Reader in , Writer out ) { super ( name ) ; this . in = in ; this . out = out ; setPriority ( Thread . MAX_PRIORITY - 1 ) ; } public void run ( ) { try { char [ ] cbuf = new char [ BUFFER_SIZE ] ; int count ; while ( ( count = in . read ( cbuf , 0 , BUFFER_SIZE ) ) >= 0 ) { out . write ( cbuf , 0 , count ) ; out . flush ( ) ; } out . flush ( ) ; } catch ( IOException exc ) { System . err . println ( "Child I/O Transfer - " + exc ) ; } } }
package processing . app . exec ; import java . util . Collections ; import java . util . HashSet ; import java . util . Set ; public class ProcessRegistry { private static final Set < Process > REGISTRY = Collections . synchronizedSet ( new HashSet < Process > ( ) ) ; static { Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { @ Override public void run ( ) { synchronized ( REGISTRY ) { for ( final Process p : REGISTRY ) { try { p . destroy ( ) ; } catch ( final Exception drop ) { } } } } } ) ; } public static void watch ( final Process p ) { REGISTRY . add ( p ) ; } public static void unwatch ( final Process p ) { REGISTRY . remove ( p ) ; } }
package processing . app . exec ; import java . io . * ; public class SystemOutSiphon implements Runnable { InputStream input ; Thread thread ; public SystemOutSiphon ( InputStream input ) { this . input = input ; thread = new Thread ( this ) ; thread . start ( ) ; } public void run ( ) { byte boofer [ ] = new byte [ 256 ] ; while ( Thread . currentThread ( ) == thread ) { try { int count = input . read ( boofer , 0 , boofer . length ) ; if ( count == - 1 ) { thread = null ; } else { System . out . print ( new String ( boofer , 0 , count ) ) ; } } catch ( IOException e ) { thread = null ; } catch ( Exception e ) { thread = null ; } } } }
package processing . app . exec ; public interface LineProcessor { void processLine ( final String line ) ; }
package processing . core ; import java . awt . Canvas ; import java . awt . Graphics2D ; import java . awt . image . BufferStrategy ; public class PSurfaceDanger extends PSurfaceAWT { public PSurfaceDanger ( PGraphics graphics ) { super ( graphics ) ; } @ Override public Thread createThread ( ) { return new AnimationThread ( ) { @ Override public void render ( ) { blit ( ) ; } } ; } @ Override protected synchronized void render ( ) { if ( ! canvas . isDisplayable ( ) ) { return ; } Canvas c = ( Canvas ) canvas ; if ( c . getBufferStrategy ( ) == null ) { c . createBufferStrategy ( 2 ) ; } BufferStrategy strategy = c . getBufferStrategy ( ) ; if ( strategy == null ) { return ; } do { do { Graphics2D draw = ( Graphics2D ) strategy . getDrawGraphics ( ) ; ( ( PGraphicsJava2D ) sketch . g ) . g2 = draw ; sketch . handleDraw ( ) ; draw . dispose ( ) ; } while ( strategy . contentsRestored ( ) ) ; strategy . show ( ) ; } while ( strategy . contentsLost ( ) ) ; } }
