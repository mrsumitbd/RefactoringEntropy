package com . puppycrawl . tools . checkstyle ; import com . google . common . io . Files ; import org . junit . Assert ; import org . junit . Test ; import java . io . File ; import java . io . IOException ; import java . util . Arrays ; import java . util . List ; import static java . nio . charset . StandardCharsets . UTF_8 ; public class AllChecksPresentOnAvailableChecksPageTest { private static final File JAVA_SOURCES_DIRECTORY = new File ( "src/main/java" ) ; private static final String AVAILABLE_CHECKS_PATH = "src/xdocs/checks.xml" ; private static final File AVAILABLE_CHECKS_FILE = new File ( AVAILABLE_CHECKS_PATH ) ; private static final String CHECK_FILE_NAME = ".+Check.java$" ; private static final String CHECK_SUFFIX = "Check.java" ; private static final String LINK_TEMPLATE = "(?s).*<a href=\"config_\\w+\\.html#%1$s\">%1$s</a>.*" ; private static final String NAMING_LINK_TEMPLATE = "(?s).*<a href=\"config_naming\\.html#Modules\">%s</a>.*" ; private static final List < String > IGNORE_LIST = Arrays . asList ( "AbstractAccessControlNameCheck.java" , "AbstractClassCouplingCheck.java" , "AbstractComplexityCheck.java" , "AbstractFileSetCheck.java" , "AbstractFormatCheck.java" , "AbstractHeaderCheck.java" , "AbstractIllegalCheck.java" , "AbstractIllegalMethodCheck.java" , "AbstractJavadocCheck.java" , "AbstractNameCheck.java" , "AbstractNestedDepthCheck.java" , "AbstractOptionCheck.java" , "AbstractParenPadCheck.java" , "AbstractSuperCheck.java" , "AbstractTypeAwareCheck.java" , "AbstractTypeParameterNameCheck.java" , "FileSetCheck.java" ) ; @ Test public void testAllChecksPresentOnAvailableChecksPage ( ) throws IOException { final String availableChecks = Files . toString ( AVAILABLE_CHECKS_FILE , UTF_8 ) ; for ( File file : Files . fileTreeTraverser ( ) . preOrderTraversal ( JAVA_SOURCES_DIRECTORY ) ) { final String fileName = file . getName ( ) ; if ( fileName . matches ( CHECK_FILE_NAME ) && ! IGNORE_LIST . contains ( fileName ) ) { final String checkName = fileName . replace ( CHECK_SUFFIX , "" ) ; if ( ! isPresent ( availableChecks , checkName ) ) { Assert . fail ( checkName + " is not correctly listed on Available Checks page" + " - add it to " + AVAILABLE_CHECKS_PATH ) ; } } } } private static boolean isPresent ( String availableChecks , String checkName ) { final String linkPattern = String . format ( LINK_TEMPLATE , checkName ) ; final String namingLinkPattern = String . format ( NAMING_LINK_TEMPLATE , checkName ) ; return availableChecks . matches ( linkPattern ) || checkName . endsWith ( "Name" ) && availableChecks . matches ( namingLinkPattern ) ; } }
package com . google . checkstyle . test . chapter3filestructure . rule333orderingandsoacing ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . sun . accessibility . internal . resources . * ; import org . apache . commons . beanutils . converters . AbstractArrayConverter ; import java . util . Arrays ; import java . util . BitSet ; import java . util . Map ; import java . util . Map . Entry ; import java . util . NoSuchElementException ; import javax . accessibility . Accessible ; public class CustomImportOrderValidInput { }
package com . google . checkstyle . test . chapter3filestructure . toolongpackagetotestcoveragegooglesjavastylerool ; import java . io . * ; final class LineLengthInput2 { public static final int badConstant = 2 ; public static final int MAX_ROWS = 2 ; private static int badStatic = 2 ; private static int sNumCreated = 0 ; private int badMember = 2 ; private int mNumCreated1 = 0 ; protected int mNumCreated2 = 0 ; private int [ ] mInts = new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 } ; public void fooMethod ( ) { } public void fooMethodLongFtp ( ) { } public void fooLongStringUrl ( ) { String url = "https://github.com/checkstyle/checkstyle/blob/master/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java" ; processUrl ( "https://github.com/checkstyle/checkstyle/blob/master/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java" ) ; processUrl ( "some line" + "https://github.com/checkstyle/checkstyle/blob/master/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java" + "+ long fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo00000000000o line" ) ; processUrl ( "Some long foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo line" ) ; String [ ] soooooooooooooooooooooooooooooooooooolongfooooooooooooooooooooooooooooooooooooooooooo = { "http://github.com/checkstyle/checkstyle/blob/master/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java" , "Some long foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo line" , } ; String fakehttps = "Some long foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo line" ; processUrl ( new String [ ] { "http://github.com/checkstyle/checkstyle/blob/master/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java" , "Some long foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo line" , } ) ; String s = "text" + "text" + "text something more.. <a href=\"https://groups.google.com/forum/#!topic/checkstyle-devel/E0z89fzvxGs%5B226-250-false%5D\">long url name, long url name, long url name</a>" + "other text" ; } public void processUrl ( String url ) { } public void processUrl ( String [ ] urls ) { } }
package com . google . checkstyle . test . chapter3filestructure . rule341onetoplevel ; public class OneTopLevelClassInputGood { public OneTopLevelClassInputGood ( ) throws CloneNotSupportedException { super . equals ( new String ( ) ) ; super . clone ( ) ; } public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } public void method ( ) throws CloneNotSupportedException { super . clone ( ) ; } { super . clone ( ) ; } }
package com . google . checkstyle . test . chapter3filestructure . rule341onetoplevel ; public enum OneTopLevelClassBad3 { } interface FooIn { } class FooClass { }
package com . google . checkstyle . test . chapter3filestructure . rule341onetoplevel ; class Foo { } enum FooEnum { }
package com . google . checkstyle . test . chapter3filestructure . rule341onetoplevel ; public class OneTopLevelClassInput_Basic { public OneTopLevelClassInput_Basic ( ) throws CloneNotSupportedException { super . equals ( new String ( ) ) ; super . clone ( ) ; } public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } public void method ( ) throws CloneNotSupportedException { super . clone ( ) ; } { super . clone ( ) ; } } class NoSuperClone { public Object clone ( ) { return null ; } } class InnerClone { public Object clone ( ) { class Inner { public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } } return null ; } } class CloneWithTypeArguments { } class CloneWithTypeArgumentsAndNoSuper { } class MyClassWithGenericSuperMethod { void someMethod ( java . util . List < ? super java . util . Map > l ) { } public static Object clone ( Object o ) { return null ; } } class AnotherClass { public < T > T clone ( T t ) { return null ; } }
package com . google . checkstyle . test . chapter3filestructure . rule3sourcefilestructure ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import java . util . Collections ; import com . google . common . base . CharMatcher ; import com . google . common . io . CharSource ; import javax . swing . AbstractAction ; import org . apache . commons . beanutils . locale . converters . ByteLocaleConverter ; class InputEmptyLineSeparatorCheck { public static final double FOO_PI = 3.1415 ; private boolean flag = true ; static { } { } private InputEmptyLineSeparatorCheck ( ) { } public int compareTo ( InputEmptyLineSeparatorCheck aObject ) { int number = 0 ; return 0 ; } public static < T > Callable < T > callable ( Runnable task , T result ) { return null ; } public int getBeastNumber ( ) { return 666 ; } interface IntEnum { } class InnerClass { public static final double FOO_PI_INNER = 3.1415 ; private boolean flagInner = true ; { } private InnerClass ( ) { } } class InnerClass2 { private InnerClass2 ( ) { } } class InnerClass3 { public int compareTo ( InputEmptyLineSeparatorCheck aObject ) { int number = 0 ; return 0 ; } } } class Class { private Class ( ) { } } class Class2 { public int compareTo ( InputEmptyLineSeparatorCheck aObject ) { int number = 0 ; return 0 ; } Class2 anon = new Class2 ( ) { public int compareTo ( InputEmptyLineSeparatorCheck aObject ) { int number = 0 ; return 0 ; } } ; }
package com . google . checkstyle . test . chapter3filestructure . rule3421overloadsplit ; class OverloadInput { public void overloadMethod ( int i ) { } public void overloadMethod ( String s ) { } public void overloadMethod ( boolean b ) { } public void fooMethod ( ) { } public void overloadMethod ( String s , Boolean b , int i ) { } OverloadInput anonynous = new OverloadInput ( ) { public void overloadMethod ( int i ) { } public void overloadMethod ( String s ) { } public void overloadMethod ( boolean b ) { } public void fooMethod ( ) { } public void overloadMethod ( String s , Boolean b , int i ) { } } ; } interface Fooable { public abstract void foo ( int i ) ; public abstract void foo ( String s ) ; public abstract void noFoo ( ) ; public abstract void foo ( String s , Boolean b , int i ) ; } enum FooType { Strategy ( "" ) , Shooter ( "" ) , RPG ( "" ) ; private String description ; private FooType ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } public void overloadMethod ( int i ) { } public void overloadMethod ( String s ) { } public void overloadMethod ( boolean b ) { } public void fooMethod ( ) { } public void overloadMethod ( String s , Boolean b , int i ) { } }
package com . google . checkstyle . test . chapter5naming . rule521packageNames ; final class PackageNameInputBad { }
package com . google . checkstyle . test . chapter5naming . rule528typevariablenames ; import java . io . Serializable ; class InputTypeParameterName1 < t > { public < TT > void foo ( ) { } < e_e > void foo ( int i ) { } } class Other2 < foo extends Serializable & Cloneable > { foo getOne ( ) { return null ; } < Tfo$o2T extends foo > Tfo$o2T getTwo ( Tfo$o2T a ) { return null ; } < foo_ extends Runnable > foo getShadow ( ) { return null ; } static class Junk < $foo > { < _abc extends $foo > void getMoreFoo ( ) { } } } class MoreOther3 < T extends Cloneable > { < E extends T > void getMore ( ) { new Other2 ( ) { < T$ > void getMoreFoo ( ) { } } ; Other2 o = new Other2 ( ) { < EE > void getMoreFoo ( ) { } } ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import static com . puppycrawl . tools . checkstyle . checks . naming . AbstractNameCheck . MSG_INVALID_PATTERN ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ParameterNameCheckTest extends BaseCheckTestSupport { @ Test public void testCatch ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParameterNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^NO_WAY_MATEY$" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputLeftCurlyOther.java" ) , expected ) ; } @ Test public void testSpecified ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParameterNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^a[A-Z][a-zA-Z0-9]*$" ) ; final String pattern = "^a[A-Z][a-zA-Z0-9]*$" ; final String [ ] expected = { "71:19: " + getCheckMessage ( MSG_INVALID_PATTERN , "badFormat1" , pattern ) , "71:34: " + getCheckMessage ( MSG_INVALID_PATTERN , "badFormat2" , pattern ) , "72:25: " + getCheckMessage ( MSG_INVALID_PATTERN , "badFormat3" , pattern ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParameterNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { ParameterNameCheck parameterNameCheckObj = new ParameterNameCheck ( ) ; int [ ] actual = parameterNameCheckObj . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . PARAMETER_DEF , } ; Assert . assertNotNull ( actual ) ; Assert . assertArrayEquals ( expected , actual ) ; } }
package com . google . checkstyle . test . chapter5naming . rule528typevariablenames ; import java . io . Serializable ; class InputTypeParameterName < t > { public < TT > void foo ( ) { } < e_e > void foo ( int i ) { } } class Other < foo extends Serializable & Cloneable > { foo getOne ( ) { return null ; } < Tfo$o2T extends foo > Tfo$o2T getTwo ( Tfo$o2T a ) { return null ; } < foo_ extends Runnable > foo getShadow ( ) { return null ; } static class Junk < $foo > { < _abc extends $foo > void getMoreFoo ( ) { } } } class MoreOther < T extends Cloneable > { < E extends T > void getMore ( ) { new Other ( ) { < T$ > void getMoreFoo ( ) { } } ; Other o = new Other ( ) { < EE > void getMoreFoo ( ) { } } ; } }
package com . google . checkstyle . test . chapter5naming . rule521_packagenames ; final class BadPackageNameInput2 { }
package com . google . checkstyle . test . chapter5naming . rule522typenames ; class inputHeaderClass { public interface InputHeader___Interface { } ; public enum inputHeaderEnum { one , two } ; class NoValid$Name { } class $NoValidName { } class NoValidName$ { } } class ValidName { } class _ValidName { } class Valid_Name { } class ValidName_ { } interface Foo { } interface _Foo { } interface Fo_o { } interface Foo_ { } interface $Foo { } interface Fo$o { } interface Foo$ { } enum FooEnum { } enum _FooEnum { } enum Foo_Enum { } enum FooEnum_ { } enum $FooEnum { } enum Foo$Enum { } enum FooEnum$ { } class aaa { } interface bbb { } enum ccc { } @ interface Annotation { } @ interface _Annotation { } @ interface Annot_ation { } @ interface Annotation_ { } @ interface $Annotation { } @ interface Annot$ation { } @ interface Annotation$ { }
package com . google . checkstyle . test . chapter5naming . rule523methodnames ; public class InputMethodName { void foo ( ) { } void Foo ( ) { } void fOo ( ) { } void f0o ( ) { } void f$o ( ) { } void f_oo ( ) { } void f ( ) { } void fO ( ) { } class InnerFoo { void foo ( ) { } void Foo ( ) { } void fOo ( ) { } void f0o ( ) { } void f$o ( ) { } void f_oo ( ) { } void f ( ) { } void fO ( ) { } } InnerFoo anon = new InnerFoo ( ) { void foo ( ) { } void Foo ( ) { } void fOo ( ) { } void f0o ( ) { } void f$o ( ) { } void f_oo ( ) { } void f ( ) { } void fO ( ) { } } ; } interface FooIn { void foo ( ) ; void Foo ( ) ; void fOo ( ) ; void f0o ( ) ; void f$o ( ) ; void f_oo ( ) ; void f ( ) ; void fO ( ) ; }
package com . google . checkstyle . test . chapter5naming . rule526parameternames ; import java . io . * ; final class InputSimple { void toManyArgs ( int $arg1 , int ar$g2 , int arg3$ , int a_rg4 , int _arg5 , int arg6_ , int aArg7 , int aArg8 , int aar_g ) { } } class InputSimple2 { public void doSomething ( int aaa , int abn , String aaA , boolean bB ) { for ( Object O : new java . util . ArrayList ( ) ) { } } } enum MyEnum1 { ABC , XYZ ; private int someMember ; public void doEnum ( int aaaL , long llll_llll , boolean bB ) { } }
package com . google . checkstyle . test . chapter5naming . rule53camelcase ; class AbbrevationsCorrect { int newCustomerId ; String innerStopwatch ; boolean supportsIpv6OnIos ; void XmlHttpRequest ( ) { } void YouTubeImporter ( ) { } void YoutubeImporter ( ) { } class InnerGood { int newCustomerId ; String innerStopwatch ; boolean supportsIpv6OnIos ; void XmlHttpRequest ( ) { } void YouTubeImporter ( ) { } void YoutubeImporter ( ) { } } AbbrevationsCorrect anonumousGood = new AbbrevationsCorrect ( ) { int newCustomerId ; String innerStopwatch ; boolean supportsIpv6OnIos ; void XmlHttpRequest ( ) { } void YouTubeImporter ( ) { } void YoutubeImporter ( ) { } } ; } class AbbrevationsIncorrect { int newCustomerID ; boolean supportsIPv6OnIOS ; void XMLHTTPRequest ( ) { } class InnerBad { int newCustomerID ; boolean supportsIPv6OnIOS ; void XMLHTTPRequest ( ) { } } AbbrevationsCorrect anonumousBad = new AbbrevationsCorrect ( ) { int newCustomerID ; boolean supportsIPv6OnIOS ; void XMLHTTPRequest ( ) { } } ; }
package com . google . checkstyle . test . chapter5naming . rule525nonconstantfieldnames ; public class MemberNameInput_Basic { public int mPublic ; protected int mProtected ; int mPackage ; private int mPrivate ; public int _public ; protected int prot_ected ; int package_ ; private int priva$te ; public int ppublic ; protected int pprotected ; int ppackage ; private int pprivate ; int ABC = 0 ; final int C_D_E = 0 ; public int $mPublic ; protected int mPro$tected ; int mPackage$ ; }
package com . google . checkstyle . test . chapter5naming . rule525nonconstantfieldnames ; import java . io . * ; final class InputSimple { public static final int badConstant = 2 ; public static final int MAX_ROWS = 2 ; private int bad$Static = 2 ; private static int sum_Created = 0 ; private int bad_Member = 2 ; private int m = 0 ; protected int m_M = 0 ; private int [ ] m$nts = new int [ ] { 1 , 2 , 3 , 4 } ; public static int sTest1 ; protected static int sTest3 ; static int sTest2 ; int mTest1 ; public int mTest2 ; public int $mTest2 ; public int mTes$t2 ; public int mTest2$ ; private void localVariables ( ) { int a ; int aA ; int a1_a ; int A_A ; int aa2_a ; int _a ; int _aa ; int aa_ ; int aaa$aaa ; int $aaaaaa ; int aaaaaa$ ; int aa ; int aaAa1a ; int aaAaaAa2a1 ; } interface Foo { public void greet ( ) ; } class InnerClass { public static final int badConstant = 2 ; public static final int MAX_ROWS = 2 ; private int bad$Static = 2 ; private int sum_Created = 0 ; private int bad_Member = 2 ; private int m = 0 ; protected int m_M = 0 ; private int [ ] m$nts = new int [ ] { 1 , 2 , 3 , 4 } ; int mTest1 ; public int mTest2 ; public int $mTest2 ; public int mTes$t2 ; public int mTest2$ ; void fooMethod ( ) { Foo foo = new Foo ( ) { int bad$Static = 2 ; int sum_Created = 0 ; int bad_Member = 2 ; int m = 0 ; int m_M = 0 ; int [ ] m$nts = new int [ ] { 1 , 2 , 3 , 4 } ; int mTest1 ; int mTest2 ; int $mTest2 ; int mTes$t2 ; int mTest2$ ; public void greet ( ) { } } ; } } }
package com . google . checkstyle . test . chapter5naming . rule527localvariablenames ; final class InputSimple { public static final int badConstant = 2 ; public static final int MAX_ROWS = 2 ; private static int badStatic = 2 ; private static int sNumCreated = 0 ; private int badMember = 2 ; private int mNumCreated1 = 0 ; protected int mNumCreated2 = 0 ; private int [ ] mInts = new int [ ] { 1 , 2 , 3 , 4 } ; private void localVariables ( ) { int a ; int aA ; int a1_a ; int A_A ; int aa2_a ; int _a ; int _aa ; int aa_ ; int aaa$aaa ; int $aaaaaa ; int aaaaaa$ ; int aa ; int aaAa1a ; int aaAaaAa2a1 ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import static com . puppycrawl . tools . checkstyle . checks . naming . AbstractNameCheck . MSG_INVALID_PATTERN ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class PackageNameCheckTest extends BaseCheckTestSupport { @ Test public void testSpecified ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( PackageNameCheck . class ) ; checkConfig . addAttribute ( "format" , "[A-Z]+" ) ; final String pattern = "[A-Z]+" ; final String [ ] expected = { "6:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "com.puppycrawl.tools.checkstyle" , pattern ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( PackageNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { PackageNameCheck packageNameCheckObj = new PackageNameCheck ( ) ; int [ ] actual = packageNameCheckObj . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . PACKAGE_DEF , } ; Assert . assertNotNull ( actual ) ; Assert . assertArrayEquals ( expected , actual ) ; } }
package com . google . checkstyle . test . chapter5naming . rule527localvariablenames ; import java . io . * ; import java . util . HashMap ; import java . util . Map ; class InputOneCharInintVarName { public void fooMethod ( ) { for ( int i = 1 ; i < 10 ; i ++ ) { } int i = 0 ; for ( int index = 1 ; index < 10 ; index ++ ) { } for ( int I_ndex = 1 ; I_ndex < 10 ; I_ndex ++ ) { } int index = 1 ; for ( ; index < 10 ; index ++ ) { } for ( ; i < 12 ; i ++ ) { } Map < String , String > map = new HashMap < String , String > ( ) ; for ( Map . Entry < String , String > e : map . entrySet ( ) ) { } for ( int a = 0 , b [ ] = { 1 } , c [ ] [ ] = { { 1 } , { 2 } } ; a < 10 ; a ++ ) { } for ( int i_ndex = 1 ; i_ndex < 10 ; i_ndex ++ ) { } for ( int ii_i1 = 1 ; ii_i1 < 10 ; ii_i1 ++ ) { } for ( int $index = 1 ; $index < 10 ; $index ++ ) { } for ( int in$dex = 1 ; in$dex < 10 ; in$dex ++ ) { } for ( int index$ = 1 ; index$ < 10 ; index$ ++ ) { } } }
package com . google . checkstyle . test . chapter5naming . rule521packagenames ; final class PackageNameInputGood { }
package com . google . checkstyle . test . chapter4formatting . rule412nonemptyblocks ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; import java . util . ArrayList ; import java . util . List ; @ TestClassAnnotation class LeftCurlyInput_Annotations { private static final int X = 10 ; @ Override public boolean equals ( Object other ) { return false ; } @ Override @ SuppressWarnings ( "unused" ) public int hashCode ( ) { int a = 10 ; return 1 ; } @ Override @ SuppressWarnings ( { "unused" , "unchecked" , "static-access" } ) public String toString ( ) { Integer i = this . X ; List < String > l = new ArrayList ( ) ; return "SomeString" ; } } @ TestClassAnnotation class InputLeftCurlyAnnotations2 { private static final int X = 10 ; @ Override public boolean equals ( Object other ) { return false ; } @ Override @ SuppressWarnings ( "unused" ) public int hashCode ( ) { int a = 10 ; return 1 ; } @ Override @ SuppressWarnings ( { "unused" , "unchecked" , "static-access" } ) public String toString ( ) { Integer i = this . X ; List < String > l = new ArrayList ( ) ; return "SomeString" ; } } @ Target ( ElementType . TYPE ) @ interface TestClassAnnotation { }
package com . google . checkstyle . test . chapter4formatting . rule412nonemptyblocks ; class RightCurlyInput_Other { int foo ( ) throws InterruptedException { int x = 1 ; int a = 2 ; while ( true ) { try { if ( x > 0 ) { break ; } else if ( x < 0 ) { ; } else { break ; } switch ( a ) { case 0 : break ; default : break ; } } catch ( Exception e ) { break ; } } synchronized ( this ) { do { x = 2 ; } while ( x == 2 ) ; } this . wait ( 666 ) ; for ( int k = 0 ; k < 1 ; k ++ ) { String innerBlockVariable = "" ; } if ( System . currentTimeMillis ( ) > 1000 ) return 1 ; else return 2 ; } static { int x = 1 ; } public enum GreetingsEnum { HELLO , GOODBYE } ; void method2 ( ) { boolean flag = true ; if ( flag ) { System . out . println ( "heh" ) ; flag = ! flag ; } System . err . println ( "Xe-xe" ) ; if ( flag ) { System . err . println ( "some foo" ) ; } } } class FooCtor { int i ; public FooCtor ( ) { i = 1 ; } } class FooMethod { public void fooMethod ( ) { int i = 1 ; } } class FooInner { class InnerFoo { public void fooInnerMethod ( ) { } } } class EnumContainer { private enum Suit { CLUBS , HEARTS , SPADES , DIAMONDS } } class WithArrays { String [ ] s = { "" } ; String [ ] empty = { } ; String [ ] s1 = { "foo" , "foo" , } ; String [ ] s2 = { "foo" , "foo" , } ; String [ ] s3 = { "foo" , "foo" , } ; String [ ] s4 = { "foo" , "foo" } ; }
package com . google . checkstyle . test . chapter4formatting . rule412nonemptyblocks ; class LeftCurlyInput_Braces { boolean condition ( ) { return false ; } void testDoWhile ( ) { do { testDoWhile ( ) ; } while ( condition ( ) ) ; do testDoWhile ( ) ; while ( condition ( ) ) ; } void testWhile ( ) { while ( condition ( ) ) { testWhile ( ) ; } while ( condition ( ) ) ; while ( condition ( ) ) testWhile ( ) ; while ( condition ( ) ) if ( condition ( ) ) testWhile ( ) ; } void testFor ( ) { for ( int i = 1 ; i < 5 ; i ++ ) { testFor ( ) ; } for ( int i = 1 ; i < 5 ; i ++ ) ; for ( int i = 1 ; i < 5 ; i ++ ) testFor ( ) ; for ( int i = 1 ; i < 5 ; i ++ ) if ( i > 2 ) testFor ( ) ; } public void testIf ( ) { if ( condition ( ) ) { testIf ( ) ; } else if ( condition ( ) ) { testIf ( ) ; } else { testIf ( ) ; } if ( condition ( ) ) ; if ( condition ( ) ) testIf ( ) ; if ( condition ( ) ) testIf ( ) ; else testIf ( ) ; if ( condition ( ) ) testIf ( ) ; else { testIf ( ) ; } if ( condition ( ) ) { testIf ( ) ; } else testIf ( ) ; if ( condition ( ) ) if ( condition ( ) ) testIf ( ) ; } void whitespaceAfterSemi ( ) { int i = 1 ; int j = 2 ; for ( ; ; ) { } } public LeftCurlyInput_Braces ( ) { } public void emptyImplementation ( ) { } } class EnumContainerLeft { private enum Suit { CLUBS , HEARTS , SPADES , DIAMONDS } } class WithArraysLeft { String [ ] s = { "" } ; String [ ] empty = { } ; String [ ] s1 = { "foo" , "foo" , } ; String [ ] s2 = { "foo" , "foo" , } ; String [ ] s3 = { "foo" , "foo" , } ; String [ ] s4 = { "foo" , "foo" } ; }
package com . google . checkstyle . test . chapter4formatting . rule412nonemptyblocks ; class LeftCurlyInput_Method { LeftCurlyInput_Method ( ) { } LeftCurlyInput_Method ( String aOne ) { } LeftCurlyInput_Method ( int aOne ) { } void method1 ( ) { } void method2 ( ) { } void method3 ( ) { } void method4 ( ) { } void method5 ( String aOne , String aTwo ) { } void method6 ( String aOne , String aTwo ) { } } enum InputLeftCurlyMethodEnum { CONSTANT1 ( "hello" ) { void method1 ( ) { } void method2 ( ) { } void method3 ( ) { } void method4 ( ) { } void method5 ( String aOne , String aTwo ) { } void method6 ( String aOne , String aTwo ) { } } , CONSTANT2 ( "hello" ) { } , CONSTANT3 ( "hellohellohellohellohellohellohellohellohellohellohellohellohellohello" ) { } ; private InputLeftCurlyMethodEnum ( String value ) { } void method1 ( ) { } void method2 ( ) { } void method3 ( ) { } void method4 ( ) { } void method5 ( String aOne , String aTwo ) { } void method6 ( String aOne , String aTwo ) { } }
package com . google . checkstyle . test . chapter4formatting . rule462horizontalwhitespace ; import com . google . common . base . Function ; import com . google . common . base . Supplier ; class myFoo { private void foo ( ) { int i = 0 ; String [ ] [ ] x = { { "foo" } } ; for ( int first = 0 ; first < 5 ; first ++ ) { } int j = 0 ; while ( j == 1 ) { } do { } while ( i == 1 ) ; } } interface SupplierFunction < T > extends Function < Supplier < T > , T > { } class EmptyFoo { } enum EmptyFooEnum { }
package com . google . checkstyle . test . chapter4formatting . rule462horizontalwhitespace ; class InputWhitespace { private int mVar1 = 1 ; private int mVar2 = 1 ; private int mVar3 = 1 ; void method1 ( ) { final int a = 1 ; int b = 1 ; b = 1 ; b += 1 ; b -= - 1 + ( + b ) ; b = b ++ + b -- ; b = ++ b - -- b ; } void method2 ( ) { synchronized ( this ) { } try { } catch ( RuntimeException e ) { } } private int mVar4 = 1 ; private void fastExit ( ) { boolean complicatedStuffNeeded = true ; if ( ! complicatedStuffNeeded ) { return ; } else { } } private int nonVoid ( ) { if ( true ) { return ( 2 ) ; } else { return 2 ; } } private void testCasts ( ) { Object o = ( Object ) new Object ( ) ; o = ( Object ) o ; o = ( Object ) o ; o = ( Object ) o ; } private void testQuestions ( ) { boolean b = ( 1 == 2 ) ? false : true ; } private void starTest ( ) { int x = 2 * 3 * 4 ; } private void boolTest ( ) { boolean a = true ; boolean x = ! a ; int z = ~ 1 + ~ 2 ; } private void divTest ( ) { int a = 4 % 2 ; int b = 4 % 2 ; int c = 4 % 2 ; int d = 4 % 2 ; int e = 4 / 2 ; int f = 4 / 2 ; int g = 4 / 2 ; } private java . lang . String dotTest ( ) { Object o = new java . lang . Object ( ) ; o . toString ( ) ; o . toString ( ) ; o . toString ( ) ; return o . toString ( ) ; } public void assertTest ( ) { assert true ; assert true : "Whups" ; assert "OK" . equals ( null ) ? false : true : "Whups" ; assert ( true ) ; assert true : "Whups" ; } void donBradman ( Runnable aRun ) { donBradman ( new Runnable ( ) { public void run ( ) { } } ) ; final Runnable r = new Runnable ( ) { public void run ( ) { } } ; } void rfe521323 ( ) { doStuff ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { } } private int i ; private int i1 , i2 , i3 ; private int i4 , i5 , i6 ; void bug806243 ( ) { Object o = new InputWhitespace ( ) { private int j ; } ; } void doStuff ( ) { } } interface IFoo { void foo ( ) ; } class SpecialCasesInForLoop { void forIterator ( ) { for ( int i = 0 ; i ++ < 5 ; ) { } int i = 0 ; for ( ; i < 5 ; i ++ ) { } for ( int anInt : getSomeInts ( ) ) { } } int [ ] getSomeInts ( ) { int i = ( int ) ( 2 / 3 ) ; return null ; } }
package com . google . checkstyle . test . chapter4formatting . rule462horizontalwhitespace ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import java . util . Collections ; class GenericWhitespaceInput implements Comparable < GenericWhitespaceInput > , Serializable { void meth ( ) { List < Integer > x = new ArrayList < Integer > ( ) ; List < List < Integer > > y = new ArrayList < List < Integer > > ( ) ; List < Integer > a = new ArrayList < Integer > ( ) ; List < List < Integer > > b = new ArrayList < List < Integer > > ( ) ; } public int compareTo ( GenericWhitespaceInput aObject ) { return 0 ; } public static < T > Callable < T > callable ( Runnable task , T result ) { return null ; } public static < T > Callable < T > callable2 ( Runnable task , T result ) { Map < Class < ? > , Integer > x = new HashMap < Class < ? > , Integer > ( ) ; for ( final Map . Entry < Class < ? > , Integer > entry : x . entrySet ( ) ) { entry . getValue ( ) ; } Class < ? > [ ] parameterClasses = new Class < ? > [ 0 ] ; return null ; } public int getConstructor ( Class < ? > ... parameterTypes ) { Collections . < Object > emptySet ( ) ; Collections . < Object > emptySet ( ) ; return 666 ; } < T > GenericWhitespaceInput ( List < T > things , int i ) { } public < T > GenericWhitespaceInput ( List < T > things ) { } public interface IntEnum { } public static class IntEnumValueType < E extends Enum < E > & IntEnum > { } public static class IntEnumValueType2 < E extends Enum < E > & IntEnum > { } public static class IntEnumValueType3 < E extends Enum < E > & IntEnum > { } }
package com . google . checkstyle . test . chapter4formatting . rule462horizontalwhitespace ; import java . util . Collection ; import java . util . Map ; public class WhitespaceAroundInput_Generics { } class BadCommas < A , B , C extends Map < A , String > > { private java . util . Hashtable < Integer , D > p = new java . util . Hashtable < Integer , D > ( ) ; } class Wildcard { public static void foo ( Collection < ? extends Wildcard [ ] > collection ) { collection . size ( ) ; } public static void foo2 ( Collection < ? extends Wildcard [ ] > collection ) { collection . size ( ) ; } } interface D { } interface E { }
package com . puppycrawl . tools . checkstyle . checks . naming ; import static com . puppycrawl . tools . checkstyle . checks . naming . AbstractNameCheck . MSG_INVALID_PATTERN ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class MemberNameCheckTest extends BaseCheckTestSupport { @ Test public void testSpecified ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^m[A-Z][a-zA-Z0-9]*$" ) ; final String pattern = "^m[A-Z][a-zA-Z0-9]*$" ; final String [ ] expected = { "35:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "badMember" , pattern ) , "224:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "someMember" , pattern ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testInnerClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String pattern = "^[a-z][a-zA-Z0-9]*$" ; final String [ ] expected = { "56:25: " + getCheckMessage ( MSG_INVALID_PATTERN , "ABC" , pattern ) , } ; verify ( checkConfig , getPath ( "InputInner.java" ) , expected ) ; } @ Test public void testDefaults ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String pattern = "^[a-z][a-zA-Z0-9]*$" ; final String [ ] expected = { "10:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "_public" , pattern ) , "11:19: " + getCheckMessage ( MSG_INVALID_PATTERN , "_protected" , pattern ) , "12:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "_package" , pattern ) , "13:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "_private" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputMemberName.java" ) , expected ) ; } @ Test public void testUnderlined ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^_[a-z]*$" ) ; final String pattern = "^_[a-z]*$" ; final String [ ] expected = { "5:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPublic" , pattern ) , "6:19: " + getCheckMessage ( MSG_INVALID_PATTERN , "mProtected" , pattern ) , "7:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPackage" , pattern ) , "8:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPrivate" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputMemberName.java" ) , expected ) ; } @ Test public void testPublicOnly ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^_[a-z]*$" ) ; checkConfig . addAttribute ( "applyToProtected" , "false" ) ; checkConfig . addAttribute ( "applyToPackage" , "false" ) ; checkConfig . addAttribute ( "applyToPrivate" , "false" ) ; final String pattern = "^_[a-z]*$" ; final String [ ] expected = { "5:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPublic" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputMemberName.java" ) , expected ) ; } @ Test public void testProtectedOnly ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^_[a-z]*$" ) ; checkConfig . addAttribute ( "applyToPublic" , "false" ) ; checkConfig . addAttribute ( "applyToPackage" , "false" ) ; checkConfig . addAttribute ( "applyToPrivate" , "false" ) ; final String pattern = "^_[a-z]*$" ; final String [ ] expected = { "6:19: " + getCheckMessage ( MSG_INVALID_PATTERN , "mProtected" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputMemberName.java" ) , expected ) ; } @ Test public void testPackageOnly ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^_[a-z]*$" ) ; checkConfig . addAttribute ( "applyToPublic" , "false" ) ; checkConfig . addAttribute ( "applyToProtected" , "false" ) ; checkConfig . addAttribute ( "applyToPrivate" , "false" ) ; final String pattern = "^_[a-z]*$" ; final String [ ] expected = { "7:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPackage" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputMemberName.java" ) , expected ) ; } @ Test public void testPrivateOnly ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^_[a-z]*$" ) ; checkConfig . addAttribute ( "applyToPublic" , "false" ) ; checkConfig . addAttribute ( "applyToProtected" , "false" ) ; checkConfig . addAttribute ( "applyToPackage" , "false" ) ; final String pattern = "^_[a-z]*$" ; final String [ ] expected = { "8:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPrivate" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputMemberName.java" ) , expected ) ; } @ Test public void testNotPrivate ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; checkConfig . addAttribute ( "applyToPrivate" , "false" ) ; final String pattern = "^[a-z][a-zA-Z0-9]*$" ; final String [ ] expected = { "10:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "_public" , pattern ) , "11:19: " + getCheckMessage ( MSG_INVALID_PATTERN , "_protected" , pattern ) , "12:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "_package" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputMemberName.java" ) , expected ) ; } @ Test public void memberNameExtended ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^[a-z][a-z0-9][a-zA-Z0-9]*$" ) ; final String pattern = "^[a-z][a-z0-9][a-zA-Z0-9]*$" ; final String [ ] expected = { "8:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPublic" , pattern ) , "9:19: " + getCheckMessage ( MSG_INVALID_PATTERN , "mProtected" , pattern ) , "10:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPackage" , pattern ) , "11:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPrivate" , pattern ) , "13:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "_public" , pattern ) , "14:19: " + getCheckMessage ( MSG_INVALID_PATTERN , "_protected" , pattern ) , "15:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "_package" , pattern ) , "16:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "_private" , pattern ) , "19:20: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPublic" , pattern ) , "20:23: " + getCheckMessage ( MSG_INVALID_PATTERN , "mProtected" , pattern ) , "21:13: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPackage" , pattern ) , "22:21: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPrivate" , pattern ) , "24:20: " + getCheckMessage ( MSG_INVALID_PATTERN , "_public" , pattern ) , "25:23: " + getCheckMessage ( MSG_INVALID_PATTERN , "_protected" , pattern ) , "26:13: " + getCheckMessage ( MSG_INVALID_PATTERN , "_package" , pattern ) , "27:21: " + getCheckMessage ( MSG_INVALID_PATTERN , "_private" , pattern ) , "31:20: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPublic" , pattern ) , "32:23: " + getCheckMessage ( MSG_INVALID_PATTERN , "mProtected" , pattern ) , "33:13: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPackage" , pattern ) , "34:21: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPrivate" , pattern ) , "36:20: " + getCheckMessage ( MSG_INVALID_PATTERN , "_public" , pattern ) , "37:23: " + getCheckMessage ( MSG_INVALID_PATTERN , "_protected" , pattern ) , "38:13: " + getCheckMessage ( MSG_INVALID_PATTERN , "_package" , pattern ) , "39:21: " + getCheckMessage ( MSG_INVALID_PATTERN , "_private" , pattern ) , "63:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPublic" , pattern ) , "64:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "mProtected" , pattern ) , "65:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPackage" , pattern ) , "66:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPrivate" , pattern ) , "68:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "_public" , pattern ) , "69:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "_protected" , pattern ) , "70:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "_package" , pattern ) , "71:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "_private" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputMemberNameExtended.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { MemberNameCheck memberNameCheckObj = new MemberNameCheck ( ) ; int [ ] actual = memberNameCheckObj . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . VARIABLE_DEF , } ; Assert . assertNotNull ( actual ) ; Assert . assertArrayEquals ( expected , actual ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule461verticalwhitespace ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import java . util . Collections ; import com . google . common . base . CharMatcher ; import com . google . common . io . CharSource ; import javax . swing . AbstractAction ; import org . apache . commons . beanutils . locale . converters . ByteLocaleConverter ; class InputEmptyLineSeparatorCheck { public static final double FOO_PI = 3.1415 ; private boolean flag = true ; static { } { } private InputEmptyLineSeparatorCheck ( ) { } public int compareTo ( InputEmptyLineSeparatorCheck aObject ) { int number = 0 ; return 0 ; } public static < T > Callable < T > callable ( Runnable task , T result ) { return null ; } public int getBeastNumber ( ) { return 666 ; } interface IntEnum { } class InnerClass { public static final double FOO_PI_INNER = 3.1415 ; private boolean flagInner = true ; { } private InnerClass ( ) { } } class InnerClass2 { private InnerClass2 ( ) { } } class InnerClass3 { public int compareTo ( InputEmptyLineSeparatorCheck aObject ) { int number = 0 ; return 0 ; } } } class Class { private Class ( ) { } } class Class2 { public int compareTo ( InputEmptyLineSeparatorCheck aObject ) { int number = 0 ; return 0 ; } Class2 anon = new Class2 ( ) { public int compareTo ( InputEmptyLineSeparatorCheck aObject ) { int number = 0 ; return 0 ; } } ; }
package com . google . checkstyle . test . chapter4formatting . rule4832nocstylearray ; public class ArrayTypeStyleInput { private int [ ] javaStyle = new int [ 0 ] ; private int cStyle [ ] = new int [ 0 ] ; public static void mainJava ( String [ ] aJavaStyle ) { } public static void mainC ( String aCStyle [ ] ) { final int [ ] blah = new int [ 0 ] ; final boolean isOK1 = aCStyle instanceof String [ ] ; final boolean isOK2 = aCStyle instanceof java . lang . String [ ] ; final boolean isOK3 = blah instanceof int [ ] ; int [ ] array [ ] = new int [ 2 ] [ 2 ] ; int array2 [ ] [ ] [ ] = new int [ 3 ] [ 3 ] [ 3 ] ; } public class Test { public Test [ ] variable ; public Test [ ] getTests ( ) { return null ; } public Test [ ] getNewTest ( ) { return null ; } } int [ ] array [ ] = new int [ 2 ] [ 2 ] ; int array2 [ ] [ ] [ ] = new int [ 3 ] [ 3 ] [ 3 ] ; }
package com . google . checkstyle . test . chapter4formatting . rule411bracesareused ; import java . io . * ; import javax . script . * ; import java . util . concurrent . * ; import java . nio . channels . * ; import java . awt . print . * ; import java . lang . management . * ; import javax . lang . model . element . * ; class NeedBracesInput { boolean condition ( ) { return false ; } void testDoWhile ( ) { do { testDoWhile ( ) ; } while ( condition ( ) ) ; do testDoWhile ( ) ; while ( condition ( ) ) ; } void testWhile ( ) { while ( condition ( ) ) { testWhile ( ) ; } while ( condition ( ) ) ; while ( condition ( ) ) testWhile ( ) ; while ( condition ( ) ) if ( condition ( ) ) testWhile ( ) ; } void testFor ( ) { for ( int i = 1 ; i < 5 ; i ++ ) { testFor ( ) ; } for ( int i = 1 ; i < 5 ; i ++ ) ; for ( int i = 1 ; i < 5 ; i ++ ) testFor ( ) ; for ( int i = 1 ; i < 5 ; i ++ ) if ( i > 2 ) testFor ( ) ; } public void testIf ( ) { if ( condition ( ) ) { testIf ( ) ; } else if ( condition ( ) ) { testIf ( ) ; } else { testIf ( ) ; } if ( condition ( ) ) ; if ( condition ( ) ) testIf ( ) ; if ( condition ( ) ) testIf ( ) ; else testIf ( ) ; if ( condition ( ) ) testIf ( ) ; else { testIf ( ) ; } if ( condition ( ) ) { testIf ( ) ; } else testIf ( ) ; if ( condition ( ) ) if ( condition ( ) ) testIf ( ) ; } void whitespaceAfterSemi ( ) { int i = 1 ; int j = 2 ; for ( ; ; ) { } } public NeedBracesInput ( ) { } public void emptyImplementation ( ) { } } class EmptyBlocks { boolean flag = true ; int [ ] a = { 1 , 2 , 3 , 4 , } ; void foo ( ) { while ( flag ) ; while ( flag ) { } while ( flag ) { } do ; while ( flag ) ; do { } while ( flag ) ; do { } while ( flag ) ; if ( flag ) ; if ( flag ) { } if ( flag ) { } if ( flag ) ; else ; if ( flag ) { } else { } if ( flag ) { } else { } for ( int i = 0 ; i < 10 ; i ++ ) ; for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int b : a ) ; for ( int b : a ) { } for ( int b : a ) { } } class InnerEmptyBlocks { boolean flag = true ; int [ ] a = { 1 , 2 , 3 , 4 , } ; void foo ( ) { while ( flag ) ; while ( flag ) { } while ( flag ) { } do ; while ( flag ) ; do { } while ( flag ) ; do { } while ( flag ) ; if ( flag ) ; if ( flag ) { } if ( flag ) { } if ( flag ) ; else ; if ( flag ) { } else { } if ( flag ) { } else { } for ( int i = 0 ; i < 10 ; i ++ ) ; for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int b : a ) ; for ( int b : a ) { } for ( int b : a ) { } } } InnerEmptyBlocks anon = new InnerEmptyBlocks ( ) { boolean flag = true ; int [ ] a = { 1 , 2 , 3 , 4 , } ; void foo ( ) { while ( flag ) ; while ( flag ) { } while ( flag ) { } do ; while ( flag ) ; do { } while ( flag ) ; do { } while ( flag ) ; if ( flag ) ; if ( flag ) { } if ( flag ) { } if ( flag ) ; else ; if ( flag ) { } else { } if ( flag ) { } else { } for ( int i = 0 ; i < 10 ; i ++ ) ; for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int b : a ) ; for ( int b : a ) { } for ( int b : a ) { } } } ; }
package com . google . checkstyle . test . chapter4formatting . rule4843defaultcasepresent ; public class MissingSwitchDefaultInput { public void foo ( ) { int i = 1 ; switch ( i ) { case 1 : i ++ ; break ; case 2 : i -- ; break ; default : return ; } switch ( i ) { } } } class bad_test { public void foo ( ) { int i = 1 ; switch ( i ) { case 1 : i ++ ; break ; case 2 : i -- ; break ; } switch ( i ) { } } class inner { public void foo1 ( ) { int i = 1 ; switch ( i ) { case 1 : i ++ ; break ; case 2 : i -- ; break ; } Foo foo = new Foo ( ) { public void foo ( ) { int i = 1 ; switch ( i ) { case 1 : i ++ ; break ; case 2 : i -- ; break ; } switch ( i ) { } } } ; } } } interface Foo { public void foo ( ) ; }
package com . google . checkstyle . test . chapter4formatting . rule42blockindentaion ; import java . util . Iterator ; public class IndentationCorrectClassInput implements Runnable , Cloneable { class InnerClass implements Iterable < String > , Cloneable { @ Override public Iterator < String > iterator ( ) { return null ; } } class InnerClass2 extends SecondClassReturnWithVeryVeryVeryLongName { public InnerClass2 ( String string ) { super ( string ) ; } } @ Override public void run ( ) { SecondClassWithLongLongLongLongName anon = new SecondClassWithLongLongLongLongName ( ) { } ; SecondClassWithLongLongLongLongName anon2 = new SecondClassWithLongLongLongLongName ( ) { } ; } } class SecondClassWithLongLongLongLongName extends IndentationCorrectClassInput { }
package com . google . checkstyle . test . chapter4formatting . rule42blockindentaion ; class FooReturnClass { String getString ( int someInt , String someString ) { return "String" ; } boolean fooMethodWithIf ( ) { return conditionSecond ( 10000000000.0 , new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooReturnClass ( ) , new SecondClassReturnWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooReturnClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooReturnClass ( ) , false ) ) || conditionFifth ( true , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooReturnClass ( ) , true ) ) || conditionSixth ( false , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondClassReturnWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { boolean fooMethodWithIf ( ) { return conditionFirst ( "Loooooooooooooooooong" , new SecondClassReturnWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooReturnClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; } boolean fooReturn ( ) { return conditionSecond ( 10000000000.0 , new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooReturnClass ( ) , new SecondClassReturnWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooReturnClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooReturnClass ( ) , false ) ) || conditionFifth ( true , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooReturnClass ( ) , true ) ) || conditionSixth ( false , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; } FooReturnClass anonymousClass = new FooReturnClass ( ) { boolean fooMethodWithIf ( String stringStringStringStringLooooongString , int intIntIntVeryLongNameForIntVariable , boolean fooooooooobooleanBooleanVeryLongName ) { return conditionSecond ( 10000000000.0 , new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooReturnClass ( ) , new SecondClassReturnWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooReturnClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooReturnClass ( ) , false ) ) || conditionFifth ( true , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooReturnClass ( ) , true ) ) || conditionSixth ( false , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ; } boolean fooReturn ( ) { return conditionFirst ( "Loooooooooooooooooong" , new SecondClassReturnWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooReturnClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; } } ; } } class SecondClassReturnWithVeryVeryVeryLongName { public SecondClassReturnWithVeryVeryVeryLongName ( String string ) { } String getString ( FooReturnClass instance , int integer ) { return "String" ; } int getInteger ( FooReturnClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooReturnClass instance , boolean flag ) { return false ; } SecondClassReturnWithVeryVeryVeryLongName getInstanse ( ) { return new SecondClassReturnWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule42blockindentaion ; class FooWhileClass { String getString ( int someInt , String someString ) { return "String" ; } void fooMethodWithIf ( ) { while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } do { } while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) ; while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } do { } while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) ; } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondWhileClassWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { void fooMethodWithIf ( ) { while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } do { } while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) ; while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } do { } while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) ; } FooWhileClass anonymousClass = new FooWhileClass ( ) { void fooMethodWithIf ( String stringStringStringStringLooooongString , int intIntIntVeryLongNameForIntVariable , boolean fooooooooobooleanBooleanVeryLongName ) { while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } do { } while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) ; while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ) { } do { } while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ) ; } } ; } } class SecondWhileClassWithVeryVeryVeryLongName { public SecondWhileClassWithVeryVeryVeryLongName ( String string ) { } String getString ( FooWhileClass instance , int integer ) { return "String" ; } int getInteger ( FooWhileClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooWhileClass instance , boolean flag ) { return false ; } SecondWhileClassWithVeryVeryVeryLongName getInstanse ( ) { return new SecondWhileClassWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule42blockindentaion ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; class FooForClass { String getString ( int someInt , String someString ) { return "String" ; } void fooMethodWithIf ( ) { for ( int i = 1 ; i < 10 ; i ++ ) { } for ( int i = new SecondForClassWithVeryVeryVeryLongName ( "Loooooooooooooooooooo" + "oong" ) . getInteger ( new FooForClass ( ) , getString ( 1000000000 , "Loooooooooooooooong" ) ) ; i < 10 ; i ++ ) { } for ( Map . Entry < String , String > entry : new SecondForClassWithVeryVeryVeryLongName ( "Loo" + "ooooooooooooooooooooong" ) . getMap ( new FooForClass ( ) , 10000000 , getString ( 10000 , "Loooooooooo" + "ooooong" ) ) . entrySet ( ) ) { } for ( Map . Entry < String , String > entry : new SecondForClassWithVeryVeryVeryLongName ( "Loo" + "ooooooooooooooooooooong" ) . getMap ( new FooForClass ( ) , 10000000 , getString ( 10000 , "Loooooooooo" + "ooooong" ) ) . entrySet ( ) ) { } for ( String string : new SecondForClassWithVeryVeryVeryLongName ( getString ( 1024 , "Looooooooooooooooooong" ) ) . getList ( new FooForClass ( ) , 1000 , getString ( 1024 , "Loooooooooooooooooooooooooooooooo" + "oooooooooooooooooooooooooooooooooooooooo" + "oooooooooong" ) ) ) { } for ( String string : new SecondForClassWithVeryVeryVeryLongName ( getString ( 1024 , "Looooooooooooooooooong" ) ) . getList ( new FooForClass ( ) , 1000 , getString ( 1024 , "Loooooooooooooooooooooooooooooooo" + "oooooooooooooooooooooooooooooooooooooooo" + "oooooooooong" ) ) ) { } } class InnerClassFoo { void fooMethodWithIf ( ) { for ( int i = 1 ; i < 10 ; i ++ ) { } for ( int i = new SecondForClassWithVeryVeryVeryLongName ( "Loooooooooooooooooooo" + "oong" ) . getInteger ( new FooForClass ( ) , getString ( 1000000000 , "Loooooooooooooooong" ) ) ; i < 10 ; i ++ ) { } for ( Map . Entry < String , String > entry : new SecondForClassWithVeryVeryVeryLongName ( "Loo" + "ooooooooooooooooooooong" ) . getMap ( new FooForClass ( ) , 10000000 , getString ( 10000 , "Loooooooooo" + "ooooong" ) ) . entrySet ( ) ) { } for ( Map . Entry < String , String > entry : new SecondForClassWithVeryVeryVeryLongName ( "Loo" + "ooooooooooooooooooooong" ) . getMap ( new FooForClass ( ) , 10000000 , getString ( 10000 , "Loooooooooo" + "ooooong" ) ) . entrySet ( ) ) { } for ( String string : new SecondForClassWithVeryVeryVeryLongName ( getString ( 1024 , "Looooooooooooooooooong" ) ) . getList ( new FooForClass ( ) , 1000 , getString ( 1024 , "Loooooooooooooooooooooooooooooooo" + "oooooooooooooooooooooooooooooooooooooooo" + "oooooooooong" ) ) ) { } for ( String string : new SecondForClassWithVeryVeryVeryLongName ( getString ( 1024 , "Looooooooooooooooooong" ) ) . getList ( new FooForClass ( ) , 1000 , getString ( 1024 , "Loooooooooooooooooooooooooooooooo" + "oooooooooooooooooooooooooooooooooooooooo" + "oooooooooong" ) ) ) { } } } } class SecondForClassWithVeryVeryVeryLongName implements Iterable < String > { public SecondForClassWithVeryVeryVeryLongName ( String string ) { } int getInteger ( FooForClass instance , String string ) { return - 1 ; } Map < String , String > getMap ( FooForClass instance , int integer , String string ) { return new HashMap < String , String > ( ) ; } List < String > getList ( FooForClass instance , long longLong , String string ) { return new ArrayList < String > ( ) ; } public Iterator < String > iterator ( ) { return null ; } }
package com . google . checkstyle . test . chapter4formatting . rule42blockindentaion ; import java . util . Map ; import java . util . ArrayList ; public abstract class IndentationCorrectInput { static int i ; int [ ] c = { 1 , 2 , 3 , 4 , 5 , 6 } ; int b ; static { i = 0 ; } { b = 2 ; } private static abstract class RangesMatcher { private static final String ZEROES = "0\u0660\u06f0" + "\u0c66\u0ce6" + "\u1c40\u1c50" ; public static final IndentationCorrectInput JAVA_LETTER_OR_DIGIT = new IndentationCorrectInput ( ) { @ Override public boolean matches ( char c ) { return Character . isLetterOrDigit ( c ) ; } } ; public static final FastMatcher NONE = new FastMatcher ( ) { @ Override public boolean matches ( char c ) { return false ; } @ Override public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { checkNotNull ( replacement ) ; return sequence . toString ( ) ; } private void checkNotNull ( CharSequence replacement ) { } @ Override public String collapseFrom ( CharSequence sequence , char replacement ) { return sequence . toString ( ) ; } @ Override public String trimTrailingFrom ( CharSequence sequence ) { return sequence . toString ( ) ; } } ; } public boolean matches ( char c ) { return false ; } public void foo ( ) { int i = 0 ; for ( ; i < 9 ; i ++ ) { if ( veryLongLongLongCondition ( ) || veryLongLongLongCondition2 ( ) ) { someFooMethod ( "longString" , "veryLongString" , "superVeryExtraLongString" ) ; if ( veryLongLongLongCondition ( ) ) { while ( veryLongLongLongCondition2 ( ) && veryLongLongLongCondition2 ( ) ) { try { doSmth ( ) ; } catch ( Exception e ) { throw new AssertionError ( e ) ; } } } } } } public boolean veryLongLongLongCondition ( ) { if ( veryLongLongLongCondition2 ( ) ) { return true ; } return false ; } public boolean veryLongLongLongCondition2 ( ) { return false ; } public void someFooMethod ( String longString , String superLongString , String exraSuperLongString ) { } public void fooThrowMethod ( ) throws Exception { } public void doSmth ( ) { for ( int h : c ) { someFooMethod ( "longString" , "veryLongString" , "superVeryExtraLongString" ) ; } } }
package com . google . checkstyle . test . chapter4formatting . rule42blockindentaion ; public class FastMatcher { public boolean matches ( char c ) { return false ; } public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { return null ; } public String collapseFrom ( CharSequence sequence , char replacement ) { return null ; } public String trimFrom ( CharSequence s ) { return null ; } public String trimLeadingFrom ( CharSequence sequence ) { return null ; } public String trimTrailingFrom ( CharSequence sequence ) { return null ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import java . io . File ; import java . io . IOException ; import com . puppycrawl . tools . checkstyle . Utils ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import static com . puppycrawl . tools . checkstyle . checks . naming . AbstractNameCheck . MSG_INVALID_PATTERN ; import static com . puppycrawl . tools . checkstyle . checks . naming . TypeNameCheck . DEFAULT_PATTERN ; public class TypeNameCheckTest extends BaseCheckTestSupport { private final String inputFilename ; public TypeNameCheckTest ( ) throws IOException { inputFilename = getPath ( "naming" + File . separator + "InputTypeName.java" ) ; } @ Test public void testSpecified ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( TypeNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^inputHe" ) ; final String [ ] expected = { } ; verify ( checkConfig , inputFilename , expected ) ; } @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( TypeNameCheck . class ) ; final String [ ] expected = { "3:7: " + getCheckMessage ( MSG_INVALID_PATTERN , "inputHeaderClass" , DEFAULT_PATTERN ) , "5:22: " + getCheckMessage ( MSG_INVALID_PATTERN , "inputHeaderInterface" , DEFAULT_PATTERN ) , "7:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "inputHeaderEnum" , DEFAULT_PATTERN ) , "9:23: " + getCheckMessage ( MSG_INVALID_PATTERN , "inputHeaderAnnotation" , DEFAULT_PATTERN ) , } ; verify ( checkConfig , inputFilename , expected ) ; } @ Test public void testClassSpecific ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( TypeNameCheck . class ) ; checkConfig . addAttribute ( "tokens" , Utils . getTokenName ( TokenTypes . CLASS_DEF ) ) ; final String [ ] expected = { "3:7: " + getCheckMessage ( MSG_INVALID_PATTERN , "inputHeaderClass" , DEFAULT_PATTERN ) , } ; verify ( checkConfig , inputFilename , expected ) ; } @ Test public void testInterfaceSpecific ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( TypeNameCheck . class ) ; checkConfig . addAttribute ( "tokens" , Utils . getTokenName ( TokenTypes . INTERFACE_DEF ) ) ; final String [ ] expected = { "5:22: " + getCheckMessage ( MSG_INVALID_PATTERN , "inputHeaderInterface" , DEFAULT_PATTERN ) , } ; verify ( checkConfig , inputFilename , expected ) ; } @ Test public void testEnumSpecific ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( TypeNameCheck . class ) ; checkConfig . addAttribute ( "tokens" , Utils . getTokenName ( TokenTypes . ENUM_DEF ) ) ; final String [ ] expected = { "7:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "inputHeaderEnum" , DEFAULT_PATTERN ) , } ; verify ( checkConfig , inputFilename , expected ) ; } @ Test public void testAnnotationSpecific ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( TypeNameCheck . class ) ; checkConfig . addAttribute ( "tokens" , Utils . getTokenName ( TokenTypes . ANNOTATION_DEF ) ) ; final String [ ] expected = { "9:23: " + getCheckMessage ( MSG_INVALID_PATTERN , "inputHeaderAnnotation" , DEFAULT_PATTERN ) , } ; verify ( checkConfig , inputFilename , expected ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule42blockindentaion ; class FooFieldClass { boolean flag = conditionFirst ( "Loooooooooooooooooong" , new SecondFieldClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooFieldClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; boolean secondFlag = conditionSecond ( 10000000000.0 , new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooFieldClass ( ) , new SecondFieldClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooFieldClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooFieldClass ( ) , false ) ) || conditionFifth ( true , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooFieldClass ( ) , true ) ) || conditionSixth ( false , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; String getString ( int someInt , String someString ) { return "String" ; } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondFieldClassWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { boolean flag = conditionFirst ( "Loooooooooooooooooong" , new SecondFieldClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooFieldClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; boolean secondFlag = conditionSecond ( 10000000000.0 , new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooFieldClass ( ) , new SecondFieldClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooFieldClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooFieldClass ( ) , false ) ) || conditionFifth ( true , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooFieldClass ( ) , true ) ) || conditionSixth ( false , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; FooFieldClass anonymousClass = new FooFieldClass ( ) { boolean secondFlag = conditionSecond ( 10000000000.0 , new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooFieldClass ( ) , new SecondFieldClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooFieldClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooFieldClass ( ) , false ) ) || conditionFifth ( true , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooFieldClass ( ) , true ) ) || conditionSixth ( false , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; } ; } } class SecondFieldClassWithVeryVeryVeryLongName { public SecondFieldClassWithVeryVeryVeryLongName ( String string ) { } String getString ( FooFieldClass instance , int integer ) { return "String" ; } int getInteger ( FooFieldClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooFieldClass instance , boolean flag ) { return false ; } SecondFieldClassWithVeryVeryVeryLongName getInstanse ( ) { return new SecondFieldClassWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule42blockindentaion ; class FooIfClass { String getString ( int someInt , String someString ) { return "String" ; } void fooMethodWithIf ( ) { if ( conditionFirst ( "Loooooooooooooooooong" , new SecondClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooIfClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } if ( conditionSecond ( 10000000000.0 , new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooIfClass ( ) , new SecondClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooIfClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooIfClass ( ) , false ) ) || conditionFifth ( true , new SecondClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooIfClass ( ) , true ) ) || conditionSixth ( false , new SecondClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondClassWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { void fooMethodWithIf ( ) { if ( conditionFirst ( "Loooooooooooooooooong" , new SecondClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooIfClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } if ( conditionSecond ( 10000000000.0 , new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooIfClass ( ) , new SecondClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooIfClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooIfClass ( ) , false ) ) || conditionFifth ( true , new SecondClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooIfClass ( ) , true ) ) || conditionSixth ( false , new SecondClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } } FooIfClass anonymousClass = new FooIfClass ( ) { void fooMethodWithIf ( String stringStringStringStringLooooongString , int intIntIntVeryLongNameForIntVariable , boolean fooooooooobooleanBooleanVeryLongName ) { if ( conditionFirst ( "Loooooooooooooooooong" , new SecondClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooIfClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } if ( conditionSecond ( 10000000000.0 , new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooIfClass ( ) , new SecondClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooIfClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooIfClass ( ) , false ) ) || conditionFifth ( true , new SecondClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooIfClass ( ) , true ) ) || conditionSixth ( false , new SecondClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ) { } } } ; } } class SecondClassWithVeryVeryVeryLongName { public SecondClassWithVeryVeryVeryLongName ( String string ) { } String getString ( FooIfClass instance , int integer ) { return "String" ; } int getInteger ( FooIfClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooIfClass instance , boolean flag ) { return false ; } SecondClassWithVeryVeryVeryLongName getInstanse ( ) { return new SecondClassWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule4822variabledistance ; import java . util . * ; public class InputVariableDeclarationUsageDistanceCheck { private static int test1 = 0 ; static { int b = 0 ; int d = 0 ; { d = ++ b ; } } static { int c = 0 ; int a = 3 ; int b = 2 ; { a = a + b ; c = b ; } { c -- ; } a = 7 ; } static { int a = - 1 ; int b = 2 ; b ++ ; int c = -- b ; a = b ; } public InputVariableDeclarationUsageDistanceCheck ( int test1 ) { int temp = - 1 ; this . test1 = test1 ; temp = test1 ; } public boolean testMethod ( ) { int temp = 7 ; new InputVariableDeclarationUsageDistanceCheck ( 2 ) ; String . valueOf ( temp ) ; boolean result = false ; String str = "" ; if ( test1 > 1 ) { str = "123" ; result = true ; } return result ; } public void testMethod2 ( ) { int count ; int a = 3 ; int b = 2 ; { a = a + b - 5 + 2 * a ; count = b ; } } public void testMethod3 ( ) { int count ; int a = 3 ; int b = 3 ; a = a + b ; b = a + a ; testMethod2 ( ) ; count = b ; } public void testMethod4 ( int arg ) { int d = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { d ++ ; if ( i > 5 ) { d += arg ; } } String ar [ ] = { "1" , "2" } ; for ( String st : ar ) { System . out . println ( st ) ; } } public void testMethod5 ( ) { int arg = 7 ; boolean b = true ; boolean bb = false ; if ( b ) if ( ! bb ) b = false ; testMethod4 ( arg ) ; } public void testMethod6 ( ) { int blockNumWithSimilarVar = 3 ; int dist = 0 ; int index = 0 ; int block = 0 ; if ( blockNumWithSimilarVar <= 1 ) { do { dist ++ ; if ( block > 4 ) { break ; } index ++ ; block ++ ; } while ( index < 7 ) ; } else { while ( index < 8 ) { dist += block ; index ++ ; block ++ ; } } } public boolean testMethod7 ( int a ) { boolean res ; switch ( a ) { case 1 : res = true ; break ; default : res = false ; } return res ; } public void testMethod8 ( ) { int b = 0 ; int c = 0 ; int m = 0 ; int n = 0 ; { c ++ ; b ++ ; } { n ++ ; m ++ ; b ++ ; } } public void testMethod9 ( ) { boolean result = false ; boolean b1 = true ; boolean b2 = false ; if ( b1 ) { if ( ! b2 ) { result = true ; } result = true ; } } public boolean testMethod10 ( ) { boolean result ; try { result = true ; } catch ( Exception e ) { result = false ; } finally { result = false ; } return result ; } public void testMethod11 ( ) { int a = 0 ; int b = 10 ; boolean result ; try { b -- ; } catch ( Exception e ) { b ++ ; result = false ; } finally { a ++ ; } } public void testMethod12 ( ) { boolean result = false ; boolean b3 = true ; boolean b1 = true ; boolean b2 = false ; if ( b1 ) { if ( b3 ) { if ( ! b2 ) { result = true ; } result = true ; } } } public void testMethod13 ( ) { int i = 9 ; int j = 6 ; int g = i + 8 ; int k = j + 10 ; } public void testMethod14 ( ) { Session s = openSession ( ) ; Transaction t = s . beginTransaction ( ) ; A a = new A ( ) ; E d1 = new E ( ) ; C1 c = new C1 ( ) ; E d2 = new E ( ) ; a . setForward ( d1 ) ; d1 . setReverse ( a ) ; c . setForward ( d2 ) ; d2 . setReverse ( c ) ; Serializable aid = s . save ( a ) ; Serializable d2id = s . save ( d2 ) ; t . commit ( ) ; s . close ( ) ; } public boolean isCheckBoxEnabled ( int path ) { String model = "" ; if ( true ) { for ( int index = 0 ; index < path ; ++ index ) { int nodeIndex = model . codePointAt ( path ) ; if ( model . contains ( "" ) ) { return false ; } } } else { int nodeIndex = model . codePointAt ( path ) ; if ( model . contains ( "" ) ) { return false ; } } return true ; } public Object readObject ( String in ) throws Exception { String startDay = new String ( "" ) ; String endDay = new String ( "" ) ; return new String ( startDay + endDay ) ; } public int [ ] getSelectedIndices ( ) { int [ ] selected = new int [ 5 ] ; String model = "" ; int a = 0 ; a ++ ; for ( int index = 0 ; index < 5 ; ++ index ) { selected [ index ] = Integer . parseInt ( model . valueOf ( a ) ) ; } return selected ; } public void testMethod15 ( ) { String confDebug = "" ; if ( ! confDebug . equals ( "" ) && ! confDebug . equals ( "null" ) ) { LogLog . warn ( "The \"" + "\" attribute is deprecated." ) ; LogLog . warn ( "Use the \"" + "\" attribute instead." ) ; LogLog . setInternalDebugging ( confDebug , true ) ; } int i = 0 ; int k = 7 ; boolean b = false ; for ( ; i < k ; i ++ ) { b = true ; k ++ ; } int sw ; switch ( i ) { case 0 : k ++ ; sw = 0 ; break ; case 1 : b = false ; break ; default : b = true ; } int wh = 0 ; b = true ; do { k -- ; i ++ ; } while ( wh > 0 ) ; if ( wh > 0 ) { k ++ ; } else if ( ! b ) { i ++ ; } else { i -- ; } } public void testMethod16 ( ) { int wh = 1 , i = 4 , k = 0 ; if ( i > 0 ) { k ++ ; } else if ( wh > 0 ) { i ++ ; } else { i -- ; } } protected JMenuItem createSubMenuItem ( LogLevel level ) { final JMenuItem result = new JMenuItem ( level . toString ( ) ) ; final LogLevel logLevel = level ; result . setMnemonic ( level . toString ( ) . charAt ( 0 ) ) ; result . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { showLogLevelColorChangeDialog ( result , logLevel ) ; } } ) ; return result ; } public static Color darker ( Color color , double fraction ) { int red = ( int ) Math . round ( color . getRed ( ) * ( 1.0 - fraction ) ) ; int green = ( int ) Math . round ( color . getGreen ( ) * ( 1.0 - fraction ) ) ; int blue = ( int ) Math . round ( color . getBlue ( ) * ( 1.0 - fraction ) ) ; if ( red < 0 ) { red = 0 ; } else if ( red > 255 ) { red = 255 ; } if ( green < 0 ) { green = 0 ; } else if ( green > 255 ) { green = 255 ; } if ( blue < 0 ) { } int alpha = color . getAlpha ( ) ; return new Color ( red , green , blue , alpha ) ; } public void testFinal ( ) { AuthUpdateTask authUpdateTask = null ; final long intervalMs = 30 * 60000L ; Object authCheckUrl = null , authInfo = null ; authUpdateTask = new AuthUpdateTask ( authCheckUrl , authInfo , new IAuthListener ( ) { @ Override public void authTokenChanged ( String cookie , String token ) { fireAuthTokenChanged ( cookie , token ) ; } } ) ; Timer authUpdateTimer = new Timer ( "Auth Guard" , true ) ; authUpdateTimer . schedule ( authUpdateTask , intervalMs / 2 , intervalMs ) ; } public void testForCycle ( ) { int filterCount = 0 ; for ( int i = 0 ; i < 10 ; i ++ , filterCount ++ ) { int abc = 0 ; System . out . println ( abc ) ; for ( int j = 0 ; j < 10 ; j ++ ) { abc = filterCount ; System . out . println ( abc ) ; } } } public void testIssue32_1 ( ) { Option srcDdlFile = OptionBuilder . create ( "f" ) ; Option logDdlFile = OptionBuilder . create ( "o" ) ; Option help = OptionBuilder . create ( "h" ) ; Options options = new Options ( ) ; options . something ( ) ; options . something ( ) ; options . something ( ) ; options . something ( ) ; options . addOption ( srcDdlFile , logDdlFile , help ) ; } public void testIssue32_2 ( ) { int mm = Integer . parseInt ( "2" ) ; long timeNow = 0 ; Calendar cal = Calendar . getInstance ( ) ; cal . setTimeInMillis ( timeNow ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; cal . set ( Calendar . HOUR_OF_DAY , mm ) ; cal . set ( Calendar . MINUTE , mm ) ; } public void testIssue32_3 ( MyObject [ ] objects ) { Calendar cal = Calendar . getInstance ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { objects [ i ] . setEnabled ( true ) ; objects [ i ] . setColor ( 0x121212 ) ; objects [ i ] . setUrl ( "http://google.com" ) ; objects [ i ] . setSize ( 789 ) ; objects [ i ] . setCalendar ( cal ) ; } } public String testIssue32_4 ( boolean flag ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( "flag is " ) ; builder . append ( flag ) ; final String line = "" ; if ( flag ) { builder . append ( "line of AST is:" ) ; builder . append ( "\n" ) ; builder . append ( String . valueOf ( line ) ) ; builder . append ( "\n" ) ; } return builder . toString ( ) ; } public void testIssue32_5 ( ) { Option a = null ; Option b = null ; Option c = null ; boolean isCNull = isNull ( c ) ; boolean isBNull = isNull ( b ) ; boolean isANull = isNull ( a ) ; } public void testIssue32_6 ( ) { Option aOpt = null ; Option bOpt = null ; Option cOpt = null ; isNull ( cOpt ) ; isNull ( bOpt ) ; isNull ( aOpt ) ; } public void testIssue32_7 ( ) { String line = "abc" ; writer . write ( line ) ; line . charAt ( 1 ) ; builder . append ( line ) ; test ( line , line , line ) ; } public void testIssue32_8 ( Writer w1 , Writer w2 , Writer w3 ) { String l1 = "1" ; w3 . write ( l1 ) ; } public void testIssue32_9 ( ) { Options options = new Options ( ) ; Option myOption = null ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; System . out . println ( "message" ) ; myOption . setArgName ( "abc" ) ; } public void testIssue32_10 ( ) { Options options = new Options ( ) ; Option myOption = null ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; myOption . setArgName ( "q" ) ; } public int testIssue32_11 ( String toDir ) throws Exception { int count = 0 ; String [ ] files = { } ; System . out . println ( "Data archivation started" ) ; files . notify ( ) ; System . out . println ( "sss" ) ; if ( files == null || files . length == 0 ) { System . out . println ( "No files on a remote site" ) ; } else { System . out . println ( "Files on remote site: " + files . length ) ; for ( String ftpFile : files ) { if ( files . length == 0 ) { "" . concat ( "" ) ; ftpFile . concat ( files [ 2 ] ) ; count ++ ; } } } System . out . println ( ) ; return count ; } private Session openSession ( ) { return null ; } class Session { public Transaction beginTransaction ( ) { return null ; } public void close ( ) { } public Serializable save ( E d2 ) { return null ; } public Serializable save ( A a ) { return null ; } } class Transaction { public void commit ( ) { } } class A { public void setForward ( E d1 ) { } } class E { public void setReverse ( C1 c ) { } public void setReverse ( A a ) { } } class C1 { public void setForward ( E d2 ) { } } class Serializable { } class JMenuItem { public JMenuItem ( String string ) { } public void addActionListener ( ActionListener actionListener ) { } public void setMnemonic ( char charAt ) { } } class LogLevel { } class ActionListener { } class ActionEvent { } private void showLogLevelColorChangeDialog ( JMenuItem j , LogLevel l ) { } static class Color { public Color ( int red , int green , int blue , int alpha ) { } public double getRed ( ) { return 0 ; } public int getAlpha ( ) { return 0 ; } public double getBlue ( ) { return 0 ; } public double getGreen ( ) { return 0 ; } } class AuthUpdateTask { public AuthUpdateTask ( Object authCheckUrl , Object authInfo , IAuthListener iAuthListener ) { } } interface IAuthListener { void authTokenChanged ( String cookie , String token ) ; } void fireAuthTokenChanged ( String s , String s1 ) { } class Timer { public Timer ( String string , boolean b ) { } public void schedule ( AuthUpdateTask authUpdateTask , long l , long intervalMs ) { } } class Option { public void setArgName ( String string ) { } } boolean isNull ( Option o ) { return false ; } class Writer { public void write ( String l3 ) { } } class Options { public void addBindFile ( Object object ) { } public void addOption ( Option srcDdlFile , Option logDdlFile , Option help ) { } public void something ( ) { } } class TreeMapNode { public TreeMapNode ( String label , double d , DefaultValue defaultValue ) { } public TreeMapNode ( String label ) { } } class DefaultValue { public DefaultValue ( double d ) { } } static class LogLog { public static void warn ( String string ) { } public static void setInternalDebugging ( String confDebug , boolean b ) { } } static class OptionBuilder { public static Option create ( String string ) { return null ; } } class MyObject { public void setEnabled ( boolean b ) { } public void setCalendar ( Calendar cal ) { } public void setSize ( int i ) { } public void setUrl ( String string ) { } public void setColor ( int i ) { } } static class writer { public static void write ( String line ) { } } void test ( String s , String s1 , String s2 ) { } static class builder { public static void append ( String line ) { } } }
package com . google . checkstyle . test . chapter4formatting . rule4821onevariablepreline ; public class MultipleVariableDeclarationsInput { int i , j ; int i1 ; int j1 ; void method1 ( ) { String str , str1 ; java . lang . Object obj ; Object obj1 ; } java . lang . String string ; java . lang . String strings [ ] ; java . lang . String string1 ; java . lang . String strings1 [ ] ; void method2 ( ) { for ( int i = 0 , j = 0 ; i < 10 ; i ++ , j -- ) { } for ( int i = 0 ; i < 4 ; i ++ ) { } } class Inner { int i , j ; int i1 ; int j1 ; void method1 ( ) { String str , str1 ; java . lang . Object obj ; Object obj1 ; } java . lang . String string ; java . lang . String strings [ ] ; java . lang . String string1 ; java . lang . String strings1 [ ] ; void method2 ( ) { for ( int i = 0 , j = 0 ; i < 10 ; i ++ , j -- ) { } for ( int i = 0 ; i < 4 ; i ++ ) { } } Inner anon = new Inner ( ) { int i , j ; int i1 ; int j1 ; void method1 ( ) { String str , str1 ; java . lang . Object obj ; Object obj1 ; } java . lang . String string ; java . lang . String strings [ ] ; java . lang . String string1 ; java . lang . String strings1 [ ] ; void method2 ( ) { for ( int i = 0 , j = 0 ; i < 10 ; i ++ , j -- ) { } for ( int i = 0 ; i < 4 ; i ++ ) { } } } ; } } class Suppress { @ SuppressWarnings ( "unused" ) long q1 , q2 , q3 ; @ SuppressWarnings ( "unused" ) long q4 , q5 , q6 ; }
package com . google . checkstyle . test . chapter4formatting . rule44cloumunlimit ; import com . google . checkstyle . test . chapter3filestructure . toolongpackagetotestcoveragegooglesjavastylerool . * ; final class LineLengthInput { public static final int badConstant = 2 ; public static final int MAX_ROWS = 2 ; private static int badStatic = 2 ; private static int sNumCreated = 0 ; private int badMember = 2 ; private int mNumCreated1 = 0 ; protected int mNumCreated2 = 0 ; private int [ ] mInts = new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , } ; public static int sTest1 ; protected static int sTest3 ; static int sTest2 ; int mTest1 ; public int mTest2 ; int test1 ( int badFormat1 , int badFormat2 , final int badFormat3 ) throws java . lang . Exception { return 0 ; } private void longMethod ( ) { } private LineLengthInput ( ) { } private void localVariables ( ) { int abc = 0 ; int ABC = 0 ; final int cde = 0 ; final int CDE = 0 ; for ( int k = 0 ; k < 1 ; k ++ ) { String innerBlockVariable = "" ; } for ( int I = 0 ; I < 1 ; I ++ ) { String InnerBlockVariable = "" ; } } void ALL_UPPERCASE_METHOD ( ) { } private static final int BAD__NAME = 3 ; void errorColumnAfterTabs ( ) { int tab0 = 1 ; int tab1 = 1 ; int tab2 = 1 ; int tab3 = 1 ; int tab4 = 1 ; int tab5 = 1 ; } void veryLong ( ) { } void toManyArgs ( int aArg1 , int aArg2 , int aArg3 , int aArg4 , int aArg5 , int aArg6 , int aArg7 , int aArg8 , int aArg9 ) { } } class InputSimple2 { public void doSomething ( ) { for ( Object O : new java . util . ArrayList ( ) ) { } } } enum MyEnum1 { ABC , XYZ ; private int someMember ; }
package com . google . checkstyle . test . chapter4formatting . rule488numericliterals ; class UpperEllInput { private final long IGNORE = 666l + 666L ; private String notWarn = "666l" ; private long foo ( ) { processUpperEll ( 66l ) ; processUpperEll ( 66L ) ; processUpperEll ( "s" , 66l ) ; processUpperEll ( "s" , 66L ) ; return 666l + 666L ; } private void processUpperEll ( long aLong ) { long bad = ( 4 + 5 * 7 ^ 66l / 7 + 890 ) & ( 88l + 78 * 4 ) ; long good = ( 4 + 5 * 7 ^ 66L / 7 + 890 ) & ( 88L + 78 * 4 ) ; long [ ] array = { 66l , 66L , } ; } private void processUpperEll ( String s , long l ) { } class Inner { private static final long IGNORE = 666l + 666L ; private static final String notWarn = "666l" ; private long foo ( ) { processUpperEll ( 66l ) ; processUpperEll ( 66L ) ; processUpperEll ( "s" , 66l ) ; processUpperEll ( "s" , 66L ) ; return 666l + 666L ; } private void processUpperEll ( long aLong ) { long bad = ( 4 + 5 * 7 ^ 66l / 7 + 890 ) & ( 88l + 78 * 4 ) ; long good = ( 4 + 5 * 7 ^ 66L / 7 + 890 ) & ( 88L + 78 * 4 ) ; } private void processUpperEll ( String s , long l ) { long [ ] array = { 66l , 66L , } ; } void fooMethod ( ) { Foo foo = new Foo ( ) { private final long IGNORE = 666l + 666L ; private String notWarn = "666l" ; private long foo ( ) { processUpperEll ( 66l ) ; processUpperEll ( 66L ) ; processUpperEll ( "s" , 66l ) ; processUpperEll ( "s" , 66L ) ; return 666l + 666L ; } private void processUpperEll ( long aLong ) { long bad = ( 4 + 5 * 7 ^ 66l / 7 + 890 ) & ( 88l + 78 * 4 ) ; long good = ( 4 + 5 * 7 ^ 66L / 7 + 890 ) & ( 88L + 78 * 4 ) ; long [ ] array = { 66l , 66L , } ; } private void processUpperEll ( String s , long aLong ) { } } ; } } class Foo { } interface Long { public static final long IGNORE = 666l + 666L ; public static final String notWarn = "666l" ; long bad = ( 4 + 5 * 7 ^ 66l / 7 + 890 ) & ( 88l + 78 * 4 ) ; long good = ( 4 + 5 * 7 ^ 66L / 7 + 890 ) & ( 88L + 78 * 4 ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule4842fallthrow ; public class FallThroughInput { void method ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : case 1 : i ++ ; break ; case 2 : i ++ ; case 3 : i ++ ; break ; case 4 : return ; case 5 : throw new RuntimeException ( "" ) ; case 6 : continue ; case 7 : { break ; } case 8 : { return ; } case 9 : { throw new RuntimeException ( "" ) ; } case 10 : { continue ; } case 11 : { i ++ ; } case 12 : if ( false ) break ; else break ; case 13 : if ( true ) { return ; } case 14 : if ( true ) { return ; } else { } case 15 : do { System . out . println ( "something" ) ; return ; } while ( true ) ; case 16 : for ( int j1 = 0 ; j1 < 10 ; j1 ++ ) { System . err . println ( "something" ) ; return ; } case 17 : while ( true ) throw new RuntimeException ( "" ) ; case 18 : while ( cond ) { break ; } case 19 : try { i ++ ; break ; } catch ( RuntimeException e ) { break ; } catch ( Error e ) { return ; } case 20 : try { i ++ ; break ; } catch ( RuntimeException e ) { } catch ( Error e ) { return ; } case 21 : try { i ++ ; } catch ( RuntimeException e ) { i -- ; } finally { break ; } case 22 : try { i ++ ; break ; } catch ( RuntimeException e ) { i -- ; break ; } finally { i ++ ; } case 23 : switch ( j ) { case 1 : continue ; case 2 : return ; default : return ; } case 24 : switch ( j ) { case 1 : continue ; case 2 : break ; default : return ; } default : i ++ ; } } } void methodFallThru ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case - 1 : case 0 : case 1 : i ++ ; break ; case 2 : i ++ ; case 3 : i ++ ; break ; case 4 : return ; case 5 : throw new RuntimeException ( "" ) ; case 6 : continue ; case 7 : { break ; } case 8 : { return ; } case 9 : { throw new RuntimeException ( "" ) ; } case 10 : { continue ; } case 11 : { i ++ ; } case 12 : if ( false ) break ; else break ; case 13 : if ( true ) { return ; } case 14 : if ( true ) { return ; } else { } case 15 : do { System . out . println ( "something" ) ; return ; } while ( true ) ; case 16 : for ( int j1 = 0 ; j1 < 10 ; j1 ++ ) { System . err . println ( "something" ) ; return ; } case 17 : while ( cond ) throw new RuntimeException ( "" ) ; case 18 : while ( cond ) { break ; } case 19 : try { i ++ ; break ; } catch ( RuntimeException e ) { break ; } catch ( Error e ) { return ; } case 20 : try { i ++ ; break ; } catch ( RuntimeException e ) { } catch ( Error e ) { return ; } case 21 : try { i ++ ; } catch ( RuntimeException e ) { i -- ; } finally { break ; } case 22 : try { i ++ ; break ; } catch ( RuntimeException e ) { i -- ; break ; } finally { i ++ ; } case 23 : switch ( j ) { case 1 : continue ; case 2 : return ; default : return ; } case 24 : i ++ ; case 25 : i ++ ; break ; case 26 : switch ( j ) { case 1 : continue ; case 2 : break ; default : return ; } default : i ++ ; } } } void methodFallThruCC ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : i ++ ; case 1 : i ++ ; case 2 : { i ++ ; } case 3 : i ++ ; case 4 : break ; case 5 : i ++ ; } } } void methodFallThruC ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : i ++ ; case 1 : i ++ ; case 2 : i ++ ; case 3 : break ; case 4 : i ++ ; } } } void methodFallThruC2 ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : i ++ ; case 1 : i ++ ; case 2 : i ++ ; case 3 : break ; case 4 : i ++ ; } } } void methodFallThruCOtherWords ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : i ++ ; case 1 : i ++ ; case 2 : i ++ ; case 3 : break ; case 4 : i ++ ; } } } void methodFallThruCCustomWords ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : i ++ ; case 1 : i ++ ; case 2 : i ++ ; case 3 : break ; case 4 : i ++ ; } } } void methodFallThruLastCaseGroup ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : i ++ ; } switch ( i ) { case 0 : i ++ ; } switch ( i ) { case 0 : i ++ ; } } } void method1472228 ( int i ) { switch ( i ) { case 2 : break ; default : } } }
package com . google . checkstyle . test . chapter4formatting . rule4841indentation ; import java . util . Iterator ; public class IndentationCorrectClassInput implements Runnable , Cloneable { class InnerClass implements Iterable < String > , Cloneable { @ Override public Iterator < String > iterator ( ) { return null ; } } class InnerClass2 extends SecondClassReturnWithVeryVeryVeryLongName { public InnerClass2 ( String string ) { super ( string ) ; } } @ Override public void run ( ) { SecondClassWithLongLongLongLongName anon = new SecondClassWithLongLongLongLongName ( ) { } ; SecondClassWithLongLongLongLongName anon2 = new SecondClassWithLongLongLongLongName ( ) { } ; } } class SecondClassWithLongLongLongLongName extends IndentationCorrectClassInput { }
package com . google . checkstyle . test . chapter4formatting . rule4841indentation ; class FooReturnClass { String getString ( int someInt , String someString ) { return "String" ; } boolean fooMethodWithIf ( ) { return conditionSecond ( 10000000000.0 , new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooReturnClass ( ) , new SecondClassReturnWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooReturnClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooReturnClass ( ) , false ) ) || conditionFifth ( true , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooReturnClass ( ) , true ) ) || conditionSixth ( false , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondClassReturnWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { boolean fooMethodWithIf ( ) { return conditionFirst ( "Loooooooooooooooooong" , new SecondClassReturnWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooReturnClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; } boolean fooReturn ( ) { return conditionSecond ( 10000000000.0 , new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooReturnClass ( ) , new SecondClassReturnWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooReturnClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooReturnClass ( ) , false ) ) || conditionFifth ( true , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooReturnClass ( ) , true ) ) || conditionSixth ( false , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; } FooReturnClass anonymousClass = new FooReturnClass ( ) { boolean fooMethodWithIf ( String stringStringStringStringLooooongString , int intIntIntVeryLongNameForIntVariable , boolean fooooooooobooleanBooleanVeryLongName ) { return conditionSecond ( 10000000000.0 , new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooReturnClass ( ) , new SecondClassReturnWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooReturnClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooReturnClass ( ) , false ) ) || conditionFifth ( true , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooReturnClass ( ) , true ) ) || conditionSixth ( false , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ; } boolean fooReturn ( ) { return conditionFirst ( "Loooooooooooooooooong" , new SecondClassReturnWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooReturnClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; } } ; } } class SecondClassReturnWithVeryVeryVeryLongName { public SecondClassReturnWithVeryVeryVeryLongName ( String string ) { } String getString ( FooReturnClass instance , int integer ) { return "String" ; } int getInteger ( FooReturnClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooReturnClass instance , boolean flag ) { return false ; } SecondClassReturnWithVeryVeryVeryLongName getInstanse ( ) { return new SecondClassReturnWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule4841indentation ; class FooWhileClass { String getString ( int someInt , String someString ) { return "String" ; } void fooMethodWithIf ( ) { while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } do { } while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) ; while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } do { } while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) ; } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondWhileClassWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { void fooMethodWithIf ( ) { while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } do { } while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) ; while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } do { } while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) ; } FooWhileClass anonymousClass = new FooWhileClass ( ) { void fooMethodWithIf ( String stringStringStringStringLooooongString , int intIntIntVeryLongNameForIntVariable , boolean fooooooooobooleanBooleanVeryLongName ) { while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } do { } while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) ; while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ) { } do { } while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ) ; } } ; } } class SecondWhileClassWithVeryVeryVeryLongName { public SecondWhileClassWithVeryVeryVeryLongName ( String string ) { } String getString ( FooWhileClass instance , int integer ) { return "String" ; } int getInteger ( FooWhileClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooWhileClass instance , boolean flag ) { return false ; } SecondWhileClassWithVeryVeryVeryLongName getInstanse ( ) { return new SecondWhileClassWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import static com . puppycrawl . tools . checkstyle . checks . naming . AbstractNameCheck . MSG_INVALID_PATTERN ; import static org . junit . Assert . fail ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ConstantNameCheckTest extends BaseCheckTestSupport { @ Test public void testIllegalRegexp ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ConstantNameCheck . class ) ; checkConfig . addAttribute ( "format" , "\\" ) ; try { createChecker ( checkConfig ) ; fail ( ) ; } catch ( CheckstyleException ex ) { } } @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ConstantNameCheck . class ) ; final String pattern = "^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$" ; final String [ ] expected = { "25:29: " + getCheckMessage ( MSG_INVALID_PATTERN , "badConstant" , pattern ) , "142:30: " + getCheckMessage ( MSG_INVALID_PATTERN , "BAD__NAME" , pattern ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testAccessControlTuning ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ConstantNameCheck . class ) ; checkConfig . addAttribute ( "applyToPublic" , "false" ) ; checkConfig . addAttribute ( "applyToProtected" , "false" ) ; checkConfig . addAttribute ( "applyToPackage" , "false" ) ; final String pattern = "^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$" ; final String [ ] expected = { "142:30: " + getCheckMessage ( MSG_INVALID_PATTERN , "BAD__NAME" , pattern ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testInterfaceAndAnnotation ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ConstantNameCheck . class ) ; final String pattern = "^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$" ; final String [ ] expected = { "24:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "data" , pattern ) , "64:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "data" , pattern ) , } ; verify ( checkConfig , getPath ( "InputInner.java" ) , expected ) ; } @ Test public void testDefault1 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ConstantNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputConstantNames.java" ) , expected ) ; } @ Test public void testIntoInterface ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ConstantNameCheck . class ) ; final String pattern = "^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$" ; final String [ ] expected = { "45:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPublic" , pattern ) , "46:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "mProtected" , pattern ) , "47:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPackage" , pattern ) , "48:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "mPrivate" , pattern ) , "50:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "_public" , pattern ) , "51:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "_protected" , pattern ) , "52:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "_package" , pattern ) , "53:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "_private" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputMemberNameExtended.java" ) , expected ) ; } @ Test public void testStaticMethodInInterface ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ConstantNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/InputStaticModifierInInterface.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { ConstantNameCheck constantNameCheckObj = new ConstantNameCheck ( ) ; int [ ] actual = constantNameCheckObj . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . VARIABLE_DEF , } ; Assert . assertNotNull ( actual ) ; Assert . assertArrayEquals ( expected , actual ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule4841indentation ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; class FooForClass { String getString ( int someInt , String someString ) { return "String" ; } void fooMethodWithIf ( ) { for ( int i = 1 ; i < 10 ; i ++ ) { } for ( int i = new SecondForClassWithVeryVeryVeryLongName ( "Loooooooooooooooooooo" + "oong" ) . getInteger ( new FooForClass ( ) , getString ( 1000000000 , "Loooooooooooooooong" ) ) ; i < 10 ; i ++ ) { } for ( Map . Entry < String , String > entry : new SecondForClassWithVeryVeryVeryLongName ( "Loo" + "ooooooooooooooooooooong" ) . getMap ( new FooForClass ( ) , 10000000 , getString ( 10000 , "Loooooooooo" + "ooooong" ) ) . entrySet ( ) ) { } for ( Map . Entry < String , String > entry : new SecondForClassWithVeryVeryVeryLongName ( "Loo" + "ooooooooooooooooooooong" ) . getMap ( new FooForClass ( ) , 10000000 , getString ( 10000 , "Loooooooooo" + "ooooong" ) ) . entrySet ( ) ) { } for ( String string : new SecondForClassWithVeryVeryVeryLongName ( getString ( 1024 , "Looooooooooooooooooong" ) ) . getList ( new FooForClass ( ) , 1000 , getString ( 1024 , "Loooooooooooooooooooooooooooooooo" + "oooooooooooooooooooooooooooooooooooooooo" + "oooooooooong" ) ) ) { } for ( String string : new SecondForClassWithVeryVeryVeryLongName ( getString ( 1024 , "Looooooooooooooooooong" ) ) . getList ( new FooForClass ( ) , 1000 , getString ( 1024 , "Loooooooooooooooooooooooooooooooo" + "oooooooooooooooooooooooooooooooooooooooo" + "oooooooooong" ) ) ) { } } class InnerClassFoo { void fooMethodWithIf ( ) { for ( int i = 1 ; i < 10 ; i ++ ) { } for ( int i = new SecondForClassWithVeryVeryVeryLongName ( "Loooooooooooooooooooo" + "oong" ) . getInteger ( new FooForClass ( ) , getString ( 1000000000 , "Loooooooooooooooong" ) ) ; i < 10 ; i ++ ) { } for ( Map . Entry < String , String > entry : new SecondForClassWithVeryVeryVeryLongName ( "Loo" + "ooooooooooooooooooooong" ) . getMap ( new FooForClass ( ) , 10000000 , getString ( 10000 , "Loooooooooo" + "ooooong" ) ) . entrySet ( ) ) { } for ( Map . Entry < String , String > entry : new SecondForClassWithVeryVeryVeryLongName ( "Loo" + "ooooooooooooooooooooong" ) . getMap ( new FooForClass ( ) , 10000000 , getString ( 10000 , "Loooooooooo" + "ooooong" ) ) . entrySet ( ) ) { } for ( String string : new SecondForClassWithVeryVeryVeryLongName ( getString ( 1024 , "Looooooooooooooooooong" ) ) . getList ( new FooForClass ( ) , 1000 , getString ( 1024 , "Loooooooooooooooooooooooooooooooo" + "oooooooooooooooooooooooooooooooooooooooo" + "oooooooooong" ) ) ) { } for ( String string : new SecondForClassWithVeryVeryVeryLongName ( getString ( 1024 , "Looooooooooooooooooong" ) ) . getList ( new FooForClass ( ) , 1000 , getString ( 1024 , "Loooooooooooooooooooooooooooooooo" + "oooooooooooooooooooooooooooooooooooooooo" + "oooooooooong" ) ) ) { } } } } class SecondForClassWithVeryVeryVeryLongName implements Iterable < String > { public SecondForClassWithVeryVeryVeryLongName ( String string ) { } int getInteger ( FooForClass instance , String string ) { return - 1 ; } Map < String , String > getMap ( FooForClass instance , int integer , String string ) { return new HashMap < String , String > ( ) ; } List < String > getList ( FooForClass instance , long longLong , String string ) { return new ArrayList < String > ( ) ; } public Iterator < String > iterator ( ) { return null ; } }
package com . google . checkstyle . test . chapter4formatting . rule4841indentation ; import java . util . Map ; import java . util . ArrayList ; public abstract class IndentationCorrectInput { static int i ; int [ ] c = { 1 , 2 , 3 , 4 , 5 , 6 } ; int b ; static { i = 0 ; } { b = 2 ; } private static abstract class RangesMatcher { private static final String ZEROES = "0\u0660\u06f0" + "\u0c66\u0ce6" + "\u1c40\u1c50" ; public static final IndentationCorrectInput JAVA_LETTER_OR_DIGIT = new IndentationCorrectInput ( ) { @ Override public boolean matches ( char c ) { return Character . isLetterOrDigit ( c ) ; } } ; public static final FastMatcher NONE = new FastMatcher ( ) { @ Override public boolean matches ( char c ) { return false ; } @ Override public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { checkNotNull ( replacement ) ; return sequence . toString ( ) ; } private void checkNotNull ( CharSequence replacement ) { } @ Override public String collapseFrom ( CharSequence sequence , char replacement ) { return sequence . toString ( ) ; } @ Override public String trimTrailingFrom ( CharSequence sequence ) { return sequence . toString ( ) ; } } ; } public boolean matches ( char c ) { return false ; } public void foo ( ) { int i = 0 ; for ( ; i < 9 ; i ++ ) { if ( veryLongLongLongCondition ( ) || veryLongLongLongCondition2 ( ) ) { someFooMethod ( "longString" , "veryLongString" , "superVeryExtraLongString" ) ; if ( veryLongLongLongCondition ( ) ) { while ( veryLongLongLongCondition2 ( ) && veryLongLongLongCondition2 ( ) ) { try { doSmth ( ) ; } catch ( Exception e ) { throw new AssertionError ( e ) ; } } } } } } public boolean veryLongLongLongCondition ( ) { if ( veryLongLongLongCondition2 ( ) ) { return true ; } return false ; } public boolean veryLongLongLongCondition2 ( ) { return false ; } public void someFooMethod ( String longString , String superLongString , String exraSuperLongString ) { } public void fooThrowMethod ( ) throws Exception { } public void doSmth ( ) { for ( int h : c ) { someFooMethod ( "longString" , "veryLongString" , "superVeryExtraLongString" ) ; } } }
package com . google . checkstyle . test . chapter4formatting . rule4841indentation ; public class FastMatcher { public boolean matches ( char c ) { return false ; } public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { return null ; } public String collapseFrom ( CharSequence sequence , char replacement ) { return null ; } public String trimFrom ( CharSequence s ) { return null ; } public String trimLeadingFrom ( CharSequence sequence ) { return null ; } public String trimTrailingFrom ( CharSequence sequence ) { return null ; } }
package com . google . checkstyle . test . chapter4formatting . rule4841indentation ; class FooFieldClass { boolean flag = conditionFirst ( "Loooooooooooooooooong" , new SecondFieldClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooFieldClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; boolean secondFlag = conditionSecond ( 10000000000.0 , new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooFieldClass ( ) , new SecondFieldClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooFieldClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooFieldClass ( ) , false ) ) || conditionFifth ( true , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooFieldClass ( ) , true ) ) || conditionSixth ( false , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; String getString ( int someInt , String someString ) { return "String" ; } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondFieldClassWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { boolean flag = conditionFirst ( "Loooooooooooooooooong" , new SecondFieldClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooFieldClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; boolean secondFlag = conditionSecond ( 10000000000.0 , new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooFieldClass ( ) , new SecondFieldClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooFieldClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooFieldClass ( ) , false ) ) || conditionFifth ( true , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooFieldClass ( ) , true ) ) || conditionSixth ( false , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; FooFieldClass anonymousClass = new FooFieldClass ( ) { boolean secondFlag = conditionSecond ( 10000000000.0 , new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooFieldClass ( ) , new SecondFieldClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooFieldClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooFieldClass ( ) , false ) ) || conditionFifth ( true , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooFieldClass ( ) , true ) ) || conditionSixth ( false , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; } ; } } class SecondFieldClassWithVeryVeryVeryLongName { public SecondFieldClassWithVeryVeryVeryLongName ( String string ) { } String getString ( FooFieldClass instance , int integer ) { return "String" ; } int getInteger ( FooFieldClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooFieldClass instance , boolean flag ) { return false ; } SecondFieldClassWithVeryVeryVeryLongName getInstanse ( ) { return new SecondFieldClassWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule4841indentation ; class FooIfClass { String getString ( int someInt , String someString ) { return "String" ; } void fooMethodWithIf ( ) { if ( conditionFirst ( "Loooooooooooooooooong" , new SecondClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooIfClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } if ( conditionSecond ( 10000000000.0 , new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooIfClass ( ) , new SecondClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooIfClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooIfClass ( ) , false ) ) || conditionFifth ( true , new SecondClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooIfClass ( ) , true ) ) || conditionSixth ( false , new SecondClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondClassWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { void fooMethodWithIf ( ) { if ( conditionFirst ( "Loooooooooooooooooong" , new SecondClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooIfClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } if ( conditionSecond ( 10000000000.0 , new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooIfClass ( ) , new SecondClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooIfClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooIfClass ( ) , false ) ) || conditionFifth ( true , new SecondClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooIfClass ( ) , true ) ) || conditionSixth ( false , new SecondClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } } FooIfClass anonymousClass = new FooIfClass ( ) { void fooMethodWithIf ( String stringStringStringStringLooooongString , int intIntIntVeryLongNameForIntVariable , boolean fooooooooobooleanBooleanVeryLongName ) { if ( conditionFirst ( "Loooooooooooooooooong" , new SecondClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooIfClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } if ( conditionSecond ( 10000000000.0 , new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooIfClass ( ) , new SecondClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooIfClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooIfClass ( ) , false ) ) || conditionFifth ( true , new SecondClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooIfClass ( ) , true ) ) || conditionSixth ( false , new SecondClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ) { } } } ; } } class SecondClassWithVeryVeryVeryLongName { public SecondClassWithVeryVeryVeryLongName ( String string ) { } String getString ( FooIfClass instance , int integer ) { return "String" ; } int getInteger ( FooIfClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooIfClass instance , boolean flag ) { return false ; } SecondClassWithVeryVeryVeryLongName getInstanse ( ) { return new SecondClassWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule452indentcontinuationlines ; import java . util . Iterator ; public class IndentationCorrectClassInput implements Runnable , Cloneable { class InnerClass implements Iterable < String > , Cloneable { @ Override public Iterator < String > iterator ( ) { return null ; } } class InnerClass2 extends SecondClassReturnWithVeryVeryVeryLongName { public InnerClass2 ( String string ) { super ( string ) ; } } @ Override public void run ( ) { SecondClassWithLongLongLongLongName anon = new SecondClassWithLongLongLongLongName ( ) { } ; SecondClassWithLongLongLongLongName anon2 = new SecondClassWithLongLongLongLongName ( ) { } ; } } class SecondClassWithLongLongLongLongName extends IndentationCorrectClassInput { }
package com . google . checkstyle . test . chapter4formatting . rule452indentcontinuationlines ; class FooReturnClass { String getString ( int someInt , String someString ) { return "String" ; } boolean fooMethodWithIf ( ) { return conditionSecond ( 10000000000.0 , new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooReturnClass ( ) , new SecondClassReturnWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooReturnClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooReturnClass ( ) , false ) ) || conditionFifth ( true , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooReturnClass ( ) , true ) ) || conditionSixth ( false , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondClassReturnWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { boolean fooMethodWithIf ( ) { return conditionFirst ( "Loooooooooooooooooong" , new SecondClassReturnWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooReturnClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; } boolean fooReturn ( ) { return conditionSecond ( 10000000000.0 , new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooReturnClass ( ) , new SecondClassReturnWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooReturnClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooReturnClass ( ) , false ) ) || conditionFifth ( true , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooReturnClass ( ) , true ) ) || conditionSixth ( false , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; } FooReturnClass anonymousClass = new FooReturnClass ( ) { boolean fooMethodWithIf ( String stringStringStringStringLooooongString , int intIntIntVeryLongNameForIntVariable , boolean fooooooooobooleanBooleanVeryLongName ) { return conditionSecond ( 10000000000.0 , new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooReturnClass ( ) , new SecondClassReturnWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooReturnClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassReturnWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooReturnClass ( ) , false ) ) || conditionFifth ( true , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooReturnClass ( ) , true ) ) || conditionSixth ( false , new SecondClassReturnWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ; } boolean fooReturn ( ) { return conditionFirst ( "Loooooooooooooooooong" , new SecondClassReturnWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooReturnClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; } } ; } } class SecondClassReturnWithVeryVeryVeryLongName { public SecondClassReturnWithVeryVeryVeryLongName ( String string ) { } String getString ( FooReturnClass instance , int integer ) { return "String" ; } int getInteger ( FooReturnClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooReturnClass instance , boolean flag ) { return false ; } SecondClassReturnWithVeryVeryVeryLongName getInstanse ( ) { return new SecondClassReturnWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule452indentcontinuationlines ; class FooWhileClass { String getString ( int someInt , String someString ) { return "String" ; } void fooMethodWithIf ( ) { while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } do { } while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) ; while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } do { } while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) ; } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondWhileClassWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { void fooMethodWithIf ( ) { while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } do { } while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) ; while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } do { } while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) ; } FooWhileClass anonymousClass = new FooWhileClass ( ) { void fooMethodWithIf ( String stringStringStringStringLooooongString , int intIntIntVeryLongNameForIntVariable , boolean fooooooooobooleanBooleanVeryLongName ) { while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } do { } while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) ; while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ) { } do { } while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ) ; } } ; } } class SecondWhileClassWithVeryVeryVeryLongName { public SecondWhileClassWithVeryVeryVeryLongName ( String string ) { } String getString ( FooWhileClass instance , int integer ) { return "String" ; } int getInteger ( FooWhileClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooWhileClass instance , boolean flag ) { return false ; } SecondWhileClassWithVeryVeryVeryLongName getInstanse ( ) { return new SecondWhileClassWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule452indentcontinuationlines ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; class FooForClass { String getString ( int someInt , String someString ) { return "String" ; } void fooMethodWithIf ( ) { for ( int i = 1 ; i < 10 ; i ++ ) { } for ( int i = new SecondForClassWithVeryVeryVeryLongName ( "Loooooooooooooooooooo" + "oong" ) . getInteger ( new FooForClass ( ) , getString ( 1000000000 , "Loooooooooooooooong" ) ) ; i < 10 ; i ++ ) { } for ( Map . Entry < String , String > entry : new SecondForClassWithVeryVeryVeryLongName ( "Loo" + "ooooooooooooooooooooong" ) . getMap ( new FooForClass ( ) , 10000000 , getString ( 10000 , "Loooooooooo" + "ooooong" ) ) . entrySet ( ) ) { } for ( Map . Entry < String , String > entry : new SecondForClassWithVeryVeryVeryLongName ( "Loo" + "ooooooooooooooooooooong" ) . getMap ( new FooForClass ( ) , 10000000 , getString ( 10000 , "Loooooooooo" + "ooooong" ) ) . entrySet ( ) ) { } for ( String string : new SecondForClassWithVeryVeryVeryLongName ( getString ( 1024 , "Looooooooooooooooooong" ) ) . getList ( new FooForClass ( ) , 1000 , getString ( 1024 , "Loooooooooooooooooooooooooooooooo" + "oooooooooooooooooooooooooooooooooooooooo" + "oooooooooong" ) ) ) { } for ( String string : new SecondForClassWithVeryVeryVeryLongName ( getString ( 1024 , "Looooooooooooooooooong" ) ) . getList ( new FooForClass ( ) , 1000 , getString ( 1024 , "Loooooooooooooooooooooooooooooooo" + "oooooooooooooooooooooooooooooooooooooooo" + "oooooooooong" ) ) ) { } } class InnerClassFoo { void fooMethodWithIf ( ) { for ( int i = 1 ; i < 10 ; i ++ ) { } for ( int i = new SecondForClassWithVeryVeryVeryLongName ( "Loooooooooooooooooooo" + "oong" ) . getInteger ( new FooForClass ( ) , getString ( 1000000000 , "Loooooooooooooooong" ) ) ; i < 10 ; i ++ ) { } for ( Map . Entry < String , String > entry : new SecondForClassWithVeryVeryVeryLongName ( "Loo" + "ooooooooooooooooooooong" ) . getMap ( new FooForClass ( ) , 10000000 , getString ( 10000 , "Loooooooooo" + "ooooong" ) ) . entrySet ( ) ) { } for ( Map . Entry < String , String > entry : new SecondForClassWithVeryVeryVeryLongName ( "Loo" + "ooooooooooooooooooooong" ) . getMap ( new FooForClass ( ) , 10000000 , getString ( 10000 , "Loooooooooo" + "ooooong" ) ) . entrySet ( ) ) { } for ( String string : new SecondForClassWithVeryVeryVeryLongName ( getString ( 1024 , "Looooooooooooooooooong" ) ) . getList ( new FooForClass ( ) , 1000 , getString ( 1024 , "Loooooooooooooooooooooooooooooooo" + "oooooooooooooooooooooooooooooooooooooooo" + "oooooooooong" ) ) ) { } for ( String string : new SecondForClassWithVeryVeryVeryLongName ( getString ( 1024 , "Looooooooooooooooooong" ) ) . getList ( new FooForClass ( ) , 1000 , getString ( 1024 , "Loooooooooooooooooooooooooooooooo" + "oooooooooooooooooooooooooooooooooooooooo" + "oooooooooong" ) ) ) { } } } } class SecondForClassWithVeryVeryVeryLongName implements Iterable < String > { public SecondForClassWithVeryVeryVeryLongName ( String string ) { } int getInteger ( FooForClass instance , String string ) { return - 1 ; } Map < String , String > getMap ( FooForClass instance , int integer , String string ) { return new HashMap < String , String > ( ) ; } List < String > getList ( FooForClass instance , long longLong , String string ) { return new ArrayList < String > ( ) ; } public Iterator < String > iterator ( ) { return null ; } }
package com . google . checkstyle . test . chapter4formatting . rule452indentcontinuationlines ; import java . util . Map ; import java . util . ArrayList ; public abstract class IndentationCorrectInput { static int i ; int [ ] c = { 1 , 2 , 3 , 4 , 5 , 6 } ; int b ; static { i = 0 ; } { b = 2 ; } private static abstract class RangesMatcher { private static final String ZEROES = "0\u0660\u06f0" + "\u0c66\u0ce6" + "\u1c40\u1c50" ; public static final IndentationCorrectInput JAVA_LETTER_OR_DIGIT = new IndentationCorrectInput ( ) { @ Override public boolean matches ( char c ) { return Character . isLetterOrDigit ( c ) ; } } ; public static final FastMatcher NONE = new FastMatcher ( ) { @ Override public boolean matches ( char c ) { return false ; } @ Override public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { checkNotNull ( replacement ) ; return sequence . toString ( ) ; } private void checkNotNull ( CharSequence replacement ) { } @ Override public String collapseFrom ( CharSequence sequence , char replacement ) { return sequence . toString ( ) ; } @ Override public String trimTrailingFrom ( CharSequence sequence ) { return sequence . toString ( ) ; } } ; } public boolean matches ( char c ) { return false ; } public void foo ( ) { int i = 0 ; for ( ; i < 9 ; i ++ ) { if ( veryLongLongLongCondition ( ) || veryLongLongLongCondition2 ( ) ) { someFooMethod ( "longString" , "veryLongString" , "superVeryExtraLongString" ) ; if ( veryLongLongLongCondition ( ) ) { while ( veryLongLongLongCondition2 ( ) && veryLongLongLongCondition2 ( ) ) { try { doSmth ( ) ; } catch ( Exception e ) { throw new AssertionError ( e ) ; } } } } } } public boolean veryLongLongLongCondition ( ) { if ( veryLongLongLongCondition2 ( ) ) { return true ; } return false ; } public boolean veryLongLongLongCondition2 ( ) { return false ; } public void someFooMethod ( String longString , String superLongString , String exraSuperLongString ) { } public void fooThrowMethod ( ) throws Exception { } public void doSmth ( ) { for ( int h : c ) { someFooMethod ( "longString" , "veryLongString" , "superVeryExtraLongString" ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import static com . puppycrawl . tools . checkstyle . checks . naming . AbstractNameCheck . MSG_INVALID_PATTERN ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class LocalFinalVariableNameCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( LocalFinalVariableNameCheck . class ) ; final String pattern = "^[a-z][a-zA-Z0-9]*$" ; final String [ ] expected = { "123:19: " + getCheckMessage ( MSG_INVALID_PATTERN , "CDE" , pattern ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testSet ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( LocalFinalVariableNameCheck . class ) ; checkConfig . addAttribute ( "format" , "[A-Z]+" ) ; final String pattern = "[A-Z]+" ; final String [ ] expected = { "122:19: " + getCheckMessage ( MSG_INVALID_PATTERN , "cde" , pattern ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testInnerClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( LocalFinalVariableNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputInner.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { LocalFinalVariableNameCheck localFinalVariableNameCheckObj = new LocalFinalVariableNameCheck ( ) ; int [ ] actual = localFinalVariableNameCheckObj . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . PARAMETER_DEF , } ; Assert . assertNotNull ( actual ) ; Assert . assertArrayEquals ( expected , actual ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule452indentcontinuationlines ; public class FastMatcher { public boolean matches ( char c ) { return false ; } public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { return null ; } public String collapseFrom ( CharSequence sequence , char replacement ) { return null ; } public String trimFrom ( CharSequence s ) { return null ; } public String trimLeadingFrom ( CharSequence sequence ) { return null ; } public String trimTrailingFrom ( CharSequence sequence ) { return null ; } }
package com . google . checkstyle . test . chapter4formatting . rule452indentcontinuationlines ; class FooFieldClass { boolean flag = conditionFirst ( "Loooooooooooooooooong" , new SecondFieldClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooFieldClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; boolean secondFlag = conditionSecond ( 10000000000.0 , new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooFieldClass ( ) , new SecondFieldClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooFieldClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooFieldClass ( ) , false ) ) || conditionFifth ( true , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooFieldClass ( ) , true ) ) || conditionSixth ( false , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; String getString ( int someInt , String someString ) { return "String" ; } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondFieldClassWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { boolean flag = conditionFirst ( "Loooooooooooooooooong" , new SecondFieldClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooFieldClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; boolean secondFlag = conditionSecond ( 10000000000.0 , new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooFieldClass ( ) , new SecondFieldClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooFieldClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooFieldClass ( ) , false ) ) || conditionFifth ( true , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooFieldClass ( ) , true ) ) || conditionSixth ( false , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; FooFieldClass anonymousClass = new FooFieldClass ( ) { boolean secondFlag = conditionSecond ( 10000000000.0 , new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooFieldClass ( ) , new SecondFieldClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooFieldClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooFieldClass ( ) , false ) ) || conditionFifth ( true , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooFieldClass ( ) , true ) ) || conditionSixth ( false , new SecondFieldClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ; } ; } } class SecondFieldClassWithVeryVeryVeryLongName { public SecondFieldClassWithVeryVeryVeryLongName ( String string ) { } String getString ( FooFieldClass instance , int integer ) { return "String" ; } int getInteger ( FooFieldClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooFieldClass instance , boolean flag ) { return false ; } SecondFieldClassWithVeryVeryVeryLongName getInstanse ( ) { return new SecondFieldClassWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule452indentcontinuationlines ; class FooIfClass { String getString ( int someInt , String someString ) { return "String" ; } void fooMethodWithIf ( ) { if ( conditionFirst ( "Loooooooooooooooooong" , new SecondClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooIfClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } if ( conditionSecond ( 10000000000.0 , new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooIfClass ( ) , new SecondClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooIfClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooIfClass ( ) , false ) ) || conditionFifth ( true , new SecondClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooIfClass ( ) , true ) ) || conditionSixth ( false , new SecondClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondClassWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { void fooMethodWithIf ( ) { if ( conditionFirst ( "Loooooooooooooooooong" , new SecondClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooIfClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } if ( conditionSecond ( 10000000000.0 , new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooIfClass ( ) , new SecondClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooIfClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooIfClass ( ) , false ) ) || conditionFifth ( true , new SecondClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooIfClass ( ) , true ) ) || conditionSixth ( false , new SecondClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } } FooIfClass anonymousClass = new FooIfClass ( ) { void fooMethodWithIf ( String stringStringStringStringLooooongString , int intIntIntVeryLongNameForIntVariable , boolean fooooooooobooleanBooleanVeryLongName ) { if ( conditionFirst ( "Loooooooooooooooooong" , new SecondClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooIfClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } if ( conditionSecond ( 10000000000.0 , new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooIfClass ( ) , new SecondClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooIfClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooIfClass ( ) , false ) ) || conditionFifth ( true , new SecondClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooIfClass ( ) , true ) ) || conditionSixth ( false , new SecondClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ) { } } } ; } } class SecondClassWithVeryVeryVeryLongName { public SecondClassWithVeryVeryVeryLongName ( String string ) { } String getString ( FooIfClass instance , int integer ) { return "String" ; } int getInteger ( FooIfClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooIfClass instance , boolean flag ) { return false ; } SecondClassWithVeryVeryVeryLongName getInstanse ( ) { return new SecondClassWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule413emptyblocks ; import java . io . * ; import java . awt . Dimension ; import java . awt . Color ; class UpdateClass { static { } public void fooMethod ( ) { UpdateClass r = new UpdateClass ( ) ; int a = 1 ; if ( a == 1 ) { } char [ ] s = { '1' , '2' } ; int index = 2 ; if ( doSideEffect ( ) == 1 ) { } IO in = new IO ( ) ; while ( ( r = in . read ( ) ) != null ) { } for ( ; index < s . length && s [ index ] != 'x' ; index ++ ) { } if ( a == 1 ) { } else { System . out . println ( "a" ) ; } do { } while ( a == 1 ) ; switch ( a ) { } int [ ] z = { } ; } public int doSideEffect ( ) { return 1 ; } public void emptyMethod ( ) { } } class IO { public UpdateClass read ( ) { return new UpdateClass ( ) ; } } class Empty { } interface EmptyImplement { } class WithInner { static { } public void emptyMethod ( ) { } public int doSideEffect ( ) { return 1 ; } class Inner { private void withEmpty ( ) { UpdateClass r = new UpdateClass ( ) ; int a = 1 ; if ( a == 1 ) { } char [ ] s = { '1' , '2' } ; int index = 2 ; if ( doSideEffect ( ) == 1 ) { } IO in = new IO ( ) ; while ( ( r = in . read ( ) ) != null ) { } for ( ; index < s . length && s [ index ] != 'x' ; index ++ ) { } if ( a == 1 ) { } else { System . out . println ( "a" ) ; } do { } while ( a == 1 ) ; switch ( a ) { } int [ ] z = { } ; } } } class WithAnon { interface AnonWithEmpty { public void fooEmpty ( ) ; } void method ( ) { AnonWithEmpty foo = new AnonWithEmpty ( ) { public void emptyMethod ( ) { } public void fooEmpty ( ) { UpdateClass r = new UpdateClass ( ) ; int a = 1 ; if ( a == 1 ) { } char [ ] s = { '1' , '2' } ; int index = 2 ; if ( doSideEffect ( ) == 1 ) { } IO in = new IO ( ) ; while ( ( r = in . read ( ) ) != null ) { } for ( ; index < s . length && s [ index ] != 'x' ; index ++ ) { } if ( a == 1 ) { } else { System . out . println ( "a" ) ; } do { } while ( a == 1 ) ; switch ( a ) { } int [ ] z = { } ; } public int doSideEffect ( ) { return 1 ; } } ; } } class NewClass { void foo ( ) { int a = 1 ; if ( a == 1 ) { System . out . println ( "a" ) ; } else { } if ( a == 1 ) { System . out . println ( "a" ) ; } else { } if ( a == 1 ) { } else { System . out . println ( "a" ) ; } if ( a == 1 ) { System . out . println ( "a" ) ; } else if ( a != 1 ) { } else { } if ( a == 1 ) { } else if ( a != 1 ) { System . out . println ( "a" ) ; } else { } if ( a == 1 ) { } else if ( a != 1 ) { } else { System . out . println ( "a" ) ; } if ( a == 1 ) { } else if ( a != 1 ) { } else { } if ( a == 1 ) { } else if ( a != 1 ) { } else { } if ( a == 1 ) { } else if ( a != 1 ) { } else { } if ( a == 1 ) { } else if ( a != 1 ) { } else { } } class NewInner { void foo ( ) { int a = 1 ; if ( a == 1 ) { System . out . println ( "a" ) ; } else { } if ( a == 1 ) { System . out . println ( "a" ) ; } else { } if ( a == 1 ) { } else { System . out . println ( "a" ) ; } if ( a == 1 ) { System . out . println ( "a" ) ; } else if ( a != 1 ) { } else { } if ( a == 1 ) { } else if ( a != 1 ) { System . out . println ( "a" ) ; } else { } if ( a == 1 ) { } else if ( a != 1 ) { } else { System . out . println ( "a" ) ; } if ( a == 1 ) { } else if ( a != 1 ) { } else { } if ( a == 1 ) { } else if ( a != 1 ) { } else { } if ( a == 1 ) { } else if ( a != 1 ) { } else { } if ( a == 1 ) { } else if ( a != 1 ) { } else { } } NewInner anon = new NewInner ( ) { void foo ( ) { int a = 1 ; if ( a == 1 ) { System . out . println ( "a" ) ; } else { } if ( a == 1 ) { System . out . println ( "a" ) ; } else { } if ( a == 1 ) { } else { System . out . println ( "a" ) ; } if ( a == 1 ) { System . out . println ( "a" ) ; } else if ( a != 1 ) { } else { } if ( a == 1 ) { } else if ( a != 1 ) { System . out . println ( "a" ) ; } else { } if ( a == 1 ) { } else if ( a != 1 ) { } else { System . out . println ( "a" ) ; } if ( a == 1 ) { } else if ( a != 1 ) { } else { } if ( a == 1 ) { } else if ( a != 1 ) { } else { } if ( a == 1 ) { } else if ( a != 1 ) { } else { } if ( a == 1 ) { } else if ( a != 1 ) { } else { } } } ; } }
package com . google . checkstyle . test . chapter4formatting . rule413emptyblocks ; import java . io . * ; import java . awt . Dimension ; import java . awt . Color ; class Catch { boolean flag ; void doSm ( ) { } void foo ( ) { try { if ( ! flag ) { doSm ( ) ; } } catch ( Exception e ) { } finally { } } void foo2 ( ) { try { if ( ! flag ) { doSm ( ) ; } } catch ( Exception e ) { } finally { } } class Inner { boolean flag ; void doSm ( ) { } void foo ( ) { try { if ( ! flag ) { doSm ( ) ; } } catch ( Exception e ) { } finally { } } void foo2 ( ) { try { if ( ! flag ) { doSm ( ) ; } } catch ( Exception e ) { } finally { } } } Inner anon = new Inner ( ) { boolean flag ; void doSm ( ) { } void foo ( ) { try { if ( ! flag ) { doSm ( ) ; } } catch ( Exception e ) { } finally { } } void foo2 ( ) { try { if ( ! flag ) { doSm ( ) ; } } catch ( Exception e ) { } finally { } } } ; }
package com . google . checkstyle . test . chapter4formatting . rule413emptyblocks ; import java . io . IOException ; public class EmptyCatchBlockNoViolationsInput { private void foo6 ( ) { try { throw new IOException ( ) ; } catch ( IOException expected ) { int k = 0 ; } } public void testTryCatch ( ) { try { int y = 0 ; int u = 8 ; int e = u - y ; return ; } catch ( Exception e ) { System . out . println ( e ) ; return ; } finally { return ; } } public void testTryCatch3 ( ) { try { int y = 0 ; int u = 8 ; int e = u - y ; } catch ( IllegalArgumentException e ) { System . out . println ( e ) ; return ; } catch ( IllegalStateException ex ) { System . out . println ( ex ) ; return ; } } public void testTryCatch4 ( ) { int y = 0 ; int u = 8 ; try { int e = u - y ; } catch ( IllegalArgumentException e ) { System . out . println ( e ) ; return ; } } public void setFormats ( ) { try { int k = 4 ; } catch ( Exception e ) { Object k = null ; if ( k != null ) k = "ss" ; else { return ; } } } }
package com . google . checkstyle . test . chapter4formatting . rule413emptyblocks ; import java . io . IOException ; public class EmptyCatchBlockViolationsByVariableNameInput { private void foo ( ) { try { throw new RuntimeException ( ) ; } catch ( Exception expected ) { } } private void foo1 ( ) { try { throw new RuntimeException ( ) ; } catch ( Exception e ) { } } private void foo2 ( ) { try { throw new IOException ( ) ; } catch ( IOException | NullPointerException | ArithmeticException expected ) { } } private void foo3 ( ) { try { throw new IOException ( ) ; } catch ( IOException | NullPointerException | ArithmeticException e ) { } } private void foo4 ( ) { try { throw new IOException ( ) ; } catch ( IOException | NullPointerException | ArithmeticException expected ) { } } private void foo5 ( ) { try { throw new IOException ( ) ; } catch ( IOException | NullPointerException | ArithmeticException e ) { } } private void some ( ) { try { throw new IOException ( ) ; } catch ( IOException e ) { } } }
package com . google . checkstyle . test . chapter4formatting . rule413emptyblocks ; import java . io . IOException ; public class EmptyCatchBlockViolationsByCommentInput { private void foo ( ) { try { throw new RuntimeException ( ) ; } catch ( Exception expected ) { } } private void foo1 ( ) { try { throw new RuntimeException ( ) ; } catch ( Exception e ) { } } private void foo2 ( ) { try { throw new IOException ( ) ; } catch ( IOException | NullPointerException | ArithmeticException ignore ) { } } private void foo3 ( ) { try { throw new IOException ( ) ; } catch ( IOException | NullPointerException | ArithmeticException e ) { } } private void foo4 ( ) { try { throw new IOException ( ) ; } catch ( IOException | NullPointerException | ArithmeticException e ) { } } private void foo5 ( ) { try { throw new IOException ( ) ; } catch ( IOException | NullPointerException | ArithmeticException e ) { } } private void some ( ) { try { throw new IOException ( ) ; } catch ( IOException e ) { } } private void some1 ( ) { try { throw new IOException ( ) ; } catch ( IOException e ) { } } private void some2 ( ) { try { throw new IOException ( ) ; } catch ( IOException e ) { } } private void some3 ( ) { try { throw new IOException ( ) ; } catch ( IOException e ) { } } private void some4 ( ) { try { throw new IOException ( ) ; } catch ( IOException e ) { } } private void some5 ( ) { try { throw new IOException ( ) ; } catch ( IOException e ) { } } }
package com . google . checkstyle . test . chapter4formatting . rule487modifiers ; strictfp abstract class ModifierOrderInput { transient private String dontSaveMe ; volatile public int whatImReading ; public volatile boolean sModifierOrderVar = false ; strictfp private void doStuff ( ) { } @ MyAnnotation2 void someMethod ( ) { } private @ MyAnnotation2 void someMethod2 ( ) { } private @ MyAnnotation2 strictfp void someMethod3 ( ) { } @ MyAnnotation2 private strictfp void someMethod4 ( ) { } @ MyAnnotation2 public static @ MyAnnotation4 strictfp void someMethod5 ( ) { } @ MyAnnotation2 public static final synchronized strictfp void fooMethod ( ) { } ; strictfp protected final @ MyAnnotation2 static synchronized void fooMethod1 ( ) { } ; synchronized @ MyAnnotation2 strictfp private final static void fooMethod2 ( ) { } ; @ MyAnnotation2 static synchronized final strictfp protected void fooMethod3 ( ) { } ; @ MyAnnotation2 strictfp static final synchronized private void fooMethod4 ( ) { } ; synchronized final strictfp @ MyAnnotation2 static public void fooMethod5 ( ) { } ; @ MyAnnotation2 static synchronized strictfp private final void fooMethod6 ( ) { } ; final strictfp synchronized static protected @ MyAnnotation2 void fooMethod7 ( ) { } ; @ MyAnnotation2 abstract protected void fooMet ( ) ; abstract @ MyAnnotation2 public void fooMet1 ( ) ; public static interface InputRedundantPublicModifier { public void a ( ) ; void b ( ) ; abstract void c ( ) ; public float PI_PUBLIC = ( float ) 3.14 ; final float PI_FINAL = ( float ) 3.14 ; float PI_OK = ( float ) 3.14 ; } final private void method ( ) { } } final class RedundantFinalClass { public final void finalMethod ( ) { } public void method ( ) { } protected @ MyAnnotation2 static synchronized native void fooMethod ( ) ; static protected @ MyAnnotation2 synchronized native void fooMethod1 ( ) ; @ MyAnnotation2 protected synchronized native void fooMethod2 ( ) ; native synchronized protected static @ MyAnnotation2 void fooMethod3 ( ) ; native @ MyAnnotation2 protected static synchronized void fooMethod4 ( ) ; public static @ MyAnnotation2 synchronized native void fooMethod5 ( ) ; synchronized static native @ MyAnnotation2 public void fooMethod6 ( ) ; static synchronized private native @ MyAnnotation2 void fooMethod7 ( ) ; } interface InnerImplementation { InnerImplementation inner = new InnerImplementation ( ) { public void method ( ) { } } ; void method ( ) ; } class WithInner { class Inner { transient private String dontSaveMe ; volatile public int whatImReading ; @ MyAnnotation2 protected synchronized native void fooMethod ( ) ; protected @ MyAnnotation2 synchronized native void fooMethod1 ( ) ; synchronized protected @ MyAnnotation2 native void fooMethod2 ( ) ; native synchronized protected @ MyAnnotation2 void fooMethod3 ( ) ; native @ MyAnnotation2 protected synchronized void fooMethod4 ( ) ; public @ MyAnnotation2 synchronized native void fooMethod5 ( ) ; synchronized native @ MyAnnotation2 public void fooMethod6 ( ) ; synchronized private native @ MyAnnotation2 void fooMethod7 ( ) ; InnerImplementation foo = new InnerImplementation ( ) { public void method ( ) { } transient private String dontSaveMe ; volatile public int whatImReading ; protected @ MyAnnotation2 synchronized native void fooMethod ( ) ; protected @ MyAnnotation2 synchronized native void fooMethod1 ( ) ; synchronized protected @ MyAnnotation2 native void fooMethod2 ( ) ; native synchronized protected @ MyAnnotation2 void fooMethod3 ( ) ; @ MyAnnotation2 protected synchronized native void fooMethod4 ( ) ; public @ MyAnnotation2 synchronized native void fooMethod5 ( ) ; synchronized native @ MyAnnotation2 public void fooMethod6 ( ) ; synchronized private native @ MyAnnotation2 void fooMethod7 ( ) ; } ; } abstract class AbsInner { transient private String dontSaveMe ; volatile public int whatImReading ; @ MyAnnotation2 public final synchronized strictfp void fooMethod ( ) { } ; strictfp protected final @ MyAnnotation2 synchronized void fooMethod1 ( ) { } ; synchronized @ MyAnnotation2 strictfp private final void fooMethod2 ( ) { } ; @ MyAnnotation2 synchronized final strictfp protected void fooMethod3 ( ) { } ; @ MyAnnotation2 strictfp final synchronized private void fooMethod4 ( ) { } ; synchronized final strictfp @ MyAnnotation2 public void fooMethod5 ( ) { } ; @ MyAnnotation2 synchronized strictfp private final void fooMethod6 ( ) { } ; final strictfp synchronized protected @ MyAnnotation2 void fooMethod7 ( ) { } ; @ MyAnnotation2 abstract protected void fooMet ( ) ; abstract @ MyAnnotation2 public void fooMet1 ( ) ; } } @ interface Annotation { public String s1 = "" ; final String s2 = "" ; static String s3 = "" ; String s4 = "" ; public String blah ( ) ; abstract String blah2 ( ) ; } @ interface MyAnnotation2 { } @ interface MyAnnotation4 { }
package com . google . checkstyle . test . chapter4formatting . rule43onestatement ; public class OneStatementPerLineInput { private int one = 0 ; private int two = 0 ; public void doLegal ( ) { one = 1 ; two = 2 ; } public void doLegalString ( ) { one = 1 ; two = 2 ; System . out . println ( "one = 1; two = 2" ) ; } public void doLegalForLoop ( ) { for ( int i = 0 , j = 0 , k = 1 ; i < 20 ; i ++ ) { one = i ; } } public void doIllegal ( ) { one = 1 ; two = 2 ; if ( one == 1 ) { one ++ ; two ++ ; } if ( one != 1 ) { one ++ ; } else { one -- ; } int n = 10 ; doLegal ( ) ; doLegal ( ) ; while ( one == 1 ) { one ++ ; two -- ; } for ( int i = 0 , j = 0 , k = 1 ; i < 20 ; i ++ ) { one = i ; } } public void doIllegal2 ( ) { one = 1 ; two = 2 ; } class Inner { private int one = 0 ; private int two = 0 ; public void doLegal ( ) { one = 1 ; two = 2 ; } public void doIllegal ( ) { one = 1 ; two = 2 ; if ( one == 1 ) { one ++ ; two ++ ; } if ( one != 1 ) { one ++ ; } else { one -- ; } int n = 10 ; doLegal ( ) ; doLegal ( ) ; while ( one == 1 ) { one ++ ; two -- ; } for ( int i = 0 , j = 0 , k = 1 ; i < 20 ; i ++ ) { one = i ; } } } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import static com . puppycrawl . tools . checkstyle . checks . naming . AbstractNameCheck . MSG_INVALID_PATTERN ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class StaticVariableNameCheckTest extends BaseCheckTestSupport { @ Test public void testSpecified ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( StaticVariableNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^s[A-Z][a-zA-Z0-9]*$" ) ; final String pattern = "^s[A-Z][a-zA-Z0-9]*$" ; final String [ ] expected = { "30:24: " + getCheckMessage ( MSG_INVALID_PATTERN , "badStatic" , pattern ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testAccessTuning ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( StaticVariableNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^s[A-Z][a-zA-Z0-9]*$" ) ; checkConfig . addAttribute ( "applyToPrivate" , "false" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testInterfaceOrAnnotationBlock ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( StaticVariableNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources/com/puppycrawl/tools/" + "checkstyle/naming/InputStaticVariableName.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { StaticVariableNameCheck staticVariableNameCheckObj = new StaticVariableNameCheck ( ) ; int [ ] actual = staticVariableNameCheckObj . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . VARIABLE_DEF , } ; Assert . assertNotNull ( actual ) ; Assert . assertArrayEquals ( expected , actual ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule451wheretobreack ; import java . util . HashMap ; import java . util . Map ; class OperatorWrapAssignInput { void test ( ) { int x = 1 + 2 - 3 - 4 ; x = x + 2 ; boolean y = true && false ; y = true && false ; y = false && true ; } void testAssignment ( ) { int x = 0 ; int y = 0 ; } < T extends Comparable & java . io . Serializable > void testGenerics1 ( ) { Comparable < String > c = new String ( ) ; Map < String , String > map = new HashMap < String , String > ( ) ; boolean flag = false ; int init = 9 ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { int i = flag == true ? 1 : 2 ; } if ( init != 9 ) { } while ( init == 10 ) { } if ( init > 10 ) { } else { } while ( init < 10 || ! flag ) { } } class Inner { void testGenerics1 ( ) { Comparable < String > c = new String ( ) ; Map < String , String > map = new HashMap < String , String > ( ) ; boolean flag = false ; int init = 9 ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { int i = flag == true ? 1 : 2 ; } if ( init != 9 ) { } while ( init == 10 ) { } if ( init > 10 ) { } else { } while ( init < 10 || ! flag ) { } } } Inner anon = new Inner ( ) { void testGenerics1 ( ) { Comparable < String > c = new String ( ) ; Map < String , String > map = new HashMap < String , String > ( ) ; boolean flag = false ; int init = 9 ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { int i = flag == true ? 1 : 2 ; } if ( init != 9 ) { } while ( init == 10 ) { } if ( init > 10 ) { } else { } while ( init < 10 || ! flag ) { } } } ; } class AsInput3 { int abc = 0 ; String string = "string" ; double PI = 3.1415 ; } class Ternary4 { void foo ( ) { boolean flag = true ; int i = flag == true ? 1 : 2 ; int i2 = flag == true ? 1 : 2 ; int i3 = flag == true ? 1 : 2 ; } } class AssignClass5 { void foo ( ) { int i = 0 ; int j = 0 ; i += 1 ; j += 2 ; i -= 1 ; j -= 2 ; i /= 1 ; j /= 2 ; i *= 1 ; j *= 2 ; i %= 1 ; j %= 2 ; i ^= 1 ; j ^= 2 ; i |= 1 ; j |= 2 ; i &= 1 ; j &= 2 ; i >>= 1 ; j >>= 2 ; i >>>= 1 ; j >>>= 2 ; i <<= 1 ; j <<= 2 ; } class InnerClass { void foo ( ) { int i = 0 ; int j = 0 ; i += 1 ; j += 2 ; i -= 1 ; j -= 2 ; i /= 1 ; j /= 2 ; i *= 1 ; j *= 2 ; i %= 1 ; j %= 2 ; i ^= 1 ; j ^= 2 ; i |= 1 ; j |= 2 ; i &= 1 ; j &= 2 ; i >>= 1 ; j >>= 2 ; i >>>= 1 ; j >>>= 2 ; i <<= 1 ; j <<= 2 ; } } InnerClass anon = new InnerClass ( ) { void foo ( ) { int i = 0 ; int j = 0 ; i += 1 ; j += 2 ; i -= 1 ; j -= 2 ; i /= 1 ; j /= 2 ; i *= 1 ; j *= 2 ; i %= 1 ; j %= 2 ; i ^= 1 ; j ^= 2 ; i |= 1 ; j |= 2 ; i &= 1 ; j &= 2 ; i >>= 1 ; j >>= 2 ; i >>>= 1 ; j >>>= 2 ; i <<= 1 ; j <<= 2 ; } } ; }
package com . google . checkstyle . test . chapter4formatting . rule451wheretobreack ; import java . util . HashMap ; import java . util . Map ; class MethodParamPadInput { void test ( ) { int x = 1 + 2 - 3 - 4 ; x = x + 2 ; boolean y = true && false ; y = true && false ; y = false && true ; } void testAssignment ( ) { int x = 0 ; int y = 0 ; } < T extends Comparable & java . io . Serializable > void testGenerics1 ( ) { Comparable < String > c = new String ( ) ; Map < String , String > map = new HashMap < String , String > ( ) ; boolean flag = false ; int init = 9 ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { int i = flag == true ? 1 : 2 ; } if ( init != 9 ) { } while ( init == 10 ) { } if ( init > 10 ) { } else { } while ( init < 10 || ! flag ) { } } class Inner { void testGenerics1 ( ) { Comparable < String > c = new String ( ) ; Map < String , String > map = new HashMap < String , String > ( ) ; boolean flag = false ; int init = 9 ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { int i = flag == true ? 1 : 2 ; } if ( init != 9 ) { } while ( init == 10 ) { } if ( init > 10 ) { } else { } while ( init < 10 || ! flag ) { } } } Inner anon = new Inner ( ) { void testGenerics1 ( ) { Comparable < String > c = new String ( ) ; Map < String , String > map = new HashMap < String , String > ( ) ; boolean flag = false ; int init = 9 ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { int i = flag == true ? 1 : 2 ; } if ( init != 9 ) { } while ( init == 10 ) { } if ( init > 10 ) { } else { } while ( init < 10 || ! flag ) { } } } ; } class AsInput1 { int abc = 0 ; String string = "string" ; double PI = 3.1415 ; } class Ternary2 { void foo ( ) { boolean flag = true ; int i = flag == true ? 1 : 2 ; int i2 = flag == true ? 1 : 2 ; int i3 = flag == true ? 1 : 2 ; } } class AssignClass3 { void foo ( ) { int i = 0 ; int j = 0 ; i += 1 ; j += 2 ; i -= 1 ; j -= 2 ; i /= 1 ; j /= 2 ; i *= 1 ; j *= 2 ; i %= 1 ; j %= 2 ; i ^= 1 ; j ^= 2 ; i |= 1 ; j |= 2 ; i &= 1 ; j &= 2 ; i >>= 1 ; j >>= 2 ; i >>>= 1 ; j >>>= 2 ; i <<= 1 ; j <<= 2 ; } class InnerClass { void foo ( ) { int i = 0 ; int j = 0 ; i += 1 ; j += 2 ; i -= 1 ; j -= 2 ; i /= 1 ; j /= 2 ; i *= 1 ; j *= 2 ; i %= 1 ; j %= 2 ; i ^= 1 ; j ^= 2 ; i |= 1 ; j |= 2 ; i &= 1 ; j &= 2 ; i >>= 1 ; j >>= 2 ; i >>>= 1 ; j >>>= 2 ; i <<= 1 ; j <<= 2 ; } } InnerClass anon = new InnerClass ( ) { void foo ( ) { int i = 0 ; int j = 0 ; i += 1 ; j += 2 ; i -= 1 ; j -= 2 ; i /= 1 ; j /= 2 ; i *= 1 ; j *= 2 ; i %= 1 ; j %= 2 ; i ^= 1 ; j ^= 2 ; i |= 1 ; j |= 2 ; i &= 1 ; j &= 2 ; i >>= 1 ; j >>= 2 ; i >>>= 1 ; j >>>= 2 ; i <<= 1 ; j <<= 2 ; } } ; }
package com . google . checkstyle . test . chapter4formatting . rule451wheretobreack ; public class SeparatorWrapInput { public void goodCase ( ) { int i = 0 ; String s = "ffffooooString" ; s . isEmpty ( ) ; s . isEmpty ( ) ; foo ( i , s ) ; } public static void foo ( int i , String s ) { } } class badCase { public void goodCase ( int ... aFoo ) { int i = 0 ; String s = "ffffooooString" ; boolean b = s . isEmpty ( ) ; foo ( i , s ) ; int [ ] j ; } public static String foo ( int i , String s ) { String maxLength = "123" ; int truncationLength = 1 ; CharSequence seq = null ; Object truncationIndicator = null ; return new StringBuilder ( maxLength ) . append ( seq , 0 , truncationLength ) . append ( truncationIndicator ) . toString ( ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule451wheretobreack ; import java . util . HashMap ; import java . util . Map ; class OperatorWrapInput { void test ( ) { int x = 1 + 2 - 3 - 4 ; x = x + 2 ; boolean y = true && false ; y = true && false ; y = false && true ; } void testAssignment ( ) { int x = 0 ; int y = 0 ; } < T extends Comparable & java . io . Serializable > void testGenerics1 ( ) { Comparable < String > c = new String ( ) ; Map < String , String > map = new HashMap < String , String > ( ) ; boolean flag = false ; int init = 9 ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { int i = flag == true ? 1 : 2 ; } if ( init != 9 ) { } while ( init == 10 ) { } if ( init > 10 ) { } else { } while ( init < 10 || ! flag ) { } } class Inner { void testGenerics1 ( ) { Comparable < String > c = new String ( ) ; Map < String , String > map = new HashMap < String , String > ( ) ; boolean flag = false ; int init = 9 ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { int i = flag == true ? 1 : 2 ; } if ( init != 9 ) { } while ( init == 10 ) { } if ( init > 10 ) { } else { } while ( init < 10 || ! flag ) { } } } Inner anon = new Inner ( ) { void testGenerics1 ( ) { Comparable < String > c = new String ( ) ; Map < String , String > map = new HashMap < String , String > ( ) ; boolean flag = false ; int init = 9 ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { int i = flag == true ? 1 : 2 ; } if ( init != 9 ) { } while ( init == 10 ) { } if ( init > 10 ) { } else { } while ( init < 10 || ! flag ) { } } } ; } class AsInput { int abc = 0 ; String string = "string" ; double PI = 3.1415 ; } class Ternary { void foo ( ) { boolean flag = true ; int i = flag == true ? 1 : 2 ; int i2 = flag == true ? 1 : 2 ; int i3 = flag == true ? 1 : 2 ; } } class AssignClass { void foo ( ) { int i = 0 ; int j = 0 ; i += 1 ; j += 2 ; i -= 1 ; j -= 2 ; i /= 1 ; j /= 2 ; i *= 1 ; j *= 2 ; i %= 1 ; j %= 2 ; i ^= 1 ; j ^= 2 ; i |= 1 ; j |= 2 ; i &= 1 ; j &= 2 ; i >>= 1 ; j >>= 2 ; i >>>= 1 ; j >>>= 2 ; i <<= 1 ; j <<= 2 ; } class InnerClass { void foo ( ) { int i = 0 ; int j = 0 ; i += 1 ; j += 2 ; i -= 1 ; j -= 2 ; i /= 1 ; j /= 2 ; i *= 1 ; j *= 2 ; i %= 1 ; j %= 2 ; i ^= 1 ; j ^= 2 ; i |= 1 ; j |= 2 ; i &= 1 ; j &= 2 ; i >>= 1 ; j >>= 2 ; i >>>= 1 ; j >>>= 2 ; i <<= 1 ; j <<= 2 ; } } InnerClass anon = new InnerClass ( ) { void foo ( ) { int i = 0 ; int j = 0 ; i += 1 ; j += 2 ; i -= 1 ; j -= 2 ; i /= 1 ; j /= 2 ; i *= 1 ; j *= 2 ; i %= 1 ; j %= 2 ; i ^= 1 ; j ^= 2 ; i |= 1 ; j |= 2 ; i &= 1 ; j &= 2 ; i >>= 1 ; j >>= 2 ; i >>>= 1 ; j >>>= 2 ; i <<= 1 ; j <<= 2 ; } } ; }
package com . google . checkstyle . test . chapter4formatting . rule485annotations ; @ MyAnnotation2 @ MyAnnotation1 class InputCorrectAnnotationIndentation { @ MyAnnotation2 @ MyAnnotation1 public int a ; @ MyAnnotation1 public int b ; @ MyAnnotation2 @ MyAnnotation1 public int c ; @ MyAnnotation1 public int d ; @ MyAnnotation2 @ MyAnnotation1 public InputCorrectAnnotationIndentation ( ) { } @ MyAnnotationWithParam ( "foo" ) @ MyAnnotation2 void foo1 ( ) { } @ MyAnnotation1 @ MyAnnotation2 void foo2 ( ) { } @ MyAnnotation1 @ MyAnnotation2 @ MyAnnotation3 @ MyAnnotation4 class InnerClass { @ MyAnnotation2 @ MyAnnotation1 public int a ; @ MyAnnotation1 public int b ; @ MyAnnotation2 @ MyAnnotation1 public int c ; @ MyAnnotation1 public int d ; @ MyAnnotation2 @ MyAnnotation1 public InnerClass ( ) { } @ MyAnnotation1 @ MyAnnotation2 void foo1 ( ) { } @ MyAnnotation1 @ MyAnnotation2 void foo2 ( ) { } } @ MyAnnotation1 @ MyAnnotation2 InnerClass anon = new InnerClass ( ) { @ MyAnnotation2 @ MyAnnotation1 public int a ; @ MyAnnotation1 public int b ; @ MyAnnotation2 @ MyAnnotation1 public int c ; @ MyAnnotation1 public int d ; @ MyAnnotation1 @ MyAnnotation2 void foo1 ( ) { } @ MyAnnotation1 @ MyAnnotation2 void foo2 ( ) { } @ MyAnnotation1 void foo42 ( ) { } } ; } @ MyAnnotation1 @ MyAnnotation2 class Foo { } @ interface MyAnnotation1 { } @ interface MyAnnotation2 { } @ interface MyAnnotation3 { } @ interface MyAnnotation4 { } @ interface MyAnnotationWithParam { String value ( ) ; }
package com . google . checkstyle . test . chapter6programpractice . rule64finalizers ; public class NoFinalizerInput { public void finalize ( ) { Runnable runnable = new Runnable ( ) { public void run ( ) { reallyFinalize ( "hi" ) ; } private void reallyFinalize ( String s ) { } } ; runnable . run ( ) ; } public void finalize ( String x ) { } }
package com . google . checkstyle . test . chapter6programpractice . rule64finalizers ; class NormalFinalizer { public static void doStuff ( ) { } protected void finalize ( ) throws Throwable { try { doStuff ( ) ; } finally { super . finalize ( ) ; } } } class EmptyFinalizer { protected void finalize ( ) throws Throwable { } } class WithoutTryCatchFinalizer { public static void doStuff ( ) { } protected void finalize ( ) throws Throwable { doStuff ( ) ; } } class PublicFinalizer { public static void doStuff ( ) { } public void finalize ( ) throws Throwable { try { doStuff ( ) ; } finally { super . finalize ( ) ; } } } class SuperFinalizer { protected void finalize ( ) throws Throwable { super . finalize ( ) ; } } class StaticFinalizer { public static void doStuff ( ) { } protected void finalize ( ) { try { doStuff ( ) ; } finally { } } class InnerFinalizer { protected void finalize ( ) { try { doStuff ( ) ; } finally { } } } } class WithoutFinalize { public void doStuff ( ) { } public void finalizeMe ( ) { } public void doFinalize ( ) { } } class WithoutMethods { } class WithAnonymousClass { public static void doStuff ( ) { } public void foo ( ) { Ball b = new Ball ( ) { public void hit ( ) { System . out . println ( "You hit it!" ) ; } protected void finalize ( ) { try { doStuff ( ) ; } finally { } } } ; b . hit ( ) ; } interface Ball { void hit ( ) ; } } interface WithFinalizer { void finalize ( ) ; }
package com . google . checkstyle . test . chapter6programpractice . rule62caughtexceptions ; import java . io . * ; import java . awt . Dimension ; import java . awt . Color ; class Catch { boolean flag ; void doSm ( ) { } void foo ( ) { try { if ( ! flag ) { doSm ( ) ; } } catch ( Exception e ) { } finally { } } void foo2 ( ) { try { if ( ! flag ) { doSm ( ) ; } } catch ( Exception e ) { } finally { } } class Inner { boolean flag ; void doSm ( ) { } void foo ( ) { try { if ( ! flag ) { doSm ( ) ; } } catch ( Exception e ) { } finally { } } void foo2 ( ) { try { if ( ! flag ) { doSm ( ) ; } } catch ( Exception e ) { } finally { } } } Inner anon = new Inner ( ) { boolean flag ; void doSm ( ) { } void foo ( ) { try { if ( ! flag ) { doSm ( ) ; } } catch ( Exception e ) { } finally { } } void foo2 ( ) { try { if ( ! flag ) { doSm ( ) ; } } catch ( Exception e ) { } finally { } } } ; }
package com . google . checkstyle . test . chapter2filebasic . rule232specialescape ; public class IllegalTokenTextInput { public void methodWithLiterals ( ) { final String ref = "<a href=\"" ; final String refCase = "<A hReF=\"" ; } public String wrongEscapeSequences ( ) { final String r1 = "\u0008" ; final String r2 = "\u0009" ; final String r3 = "\u000csssdfsd" ; final String r4 = "\u1111sdfsd\444" ; final char r5 = '\012' ; final char r6 = '\u0022' ; final char r7 = '\b' ; return "\u000csssdfsd" ; } public void specialCharsWithoutWarn ( ) { String r1 = "\b" ; String r2 = "\t" ; String r3 = "\n" ; String r4 = "\f" ; String r5 = "\r" ; String r6 = "\"" ; String r7 = "\'" ; String r8 = "\\" ; } public void specialCharsWithWarn ( ) { String r1 = "\\u0008" ; String r2 = "\\u0009" ; String r3 = "\\u000a" ; String r4 = "\\u000c" ; String r5 = "\\u000d" ; String r6 = "\\u0022" ; String r7 = "\\u0027" ; String r8 = "\\u005c" ; } public void specialCharsWithWarn2 ( ) { String r1 = "\\010" ; String r2 = "\\011" ; String r3 = "\\012" ; String r4 = "\\014" ; String r5 = "\\015" ; String r6 = "\\042" ; String r7 = "\\047" ; String r8 = "\\134" ; } class Inner { public String wrongEscapeSequences ( ) { final String r1 = "\u0008" ; final String r2 = "\u0009" ; final String r3 = "\u000csssdfsd" ; final String r4 = "\u1111sdfsd\444" ; final char r5 = '\012' ; final char r6 = '\u0022' ; final char r7 = '\b' ; return "\u000csssdfsd" ; } public void specialCharsWithoutWarn ( ) { String r1 = "\b" ; String r2 = "\t" ; String r3 = "\n" ; String r4 = "\f" ; String r5 = "\r" ; String r6 = "\"" ; String r7 = "\'" ; String r8 = "\\" ; } public void specialCharsWithWarn ( ) { String r1 = "\\u0008" ; String r2 = "\\u0009" ; String r3 = "\\u000a" ; String r4 = "\\u000c" ; String r5 = "\\u000d" ; String r6 = "\\u0022" ; String r7 = "\\u0027" ; String r8 = "\\u005c" ; } public void specialCharsWithWarn2 ( ) { String r1 = "\\010" ; String r2 = "\\011" ; String r3 = "\\012" ; String r4 = "\\014" ; String r5 = "\\015" ; String r6 = "\\042" ; String r7 = "\\047" ; String r8 = "\\134" ; } Inner anoInner = new Inner ( ) { public String wrongEscapeSequences ( ) { final String r1 = "\u0008" ; final String r2 = "\u0009" ; final String r3 = "\u000csssdfsd" ; final String r4 = "\u1111sdfsd\444" ; final char r5 = '\012' ; final char r6 = '\u0022' ; final char r7 = '\b' ; return "\u000csssdfsd" ; } public void specialCharsWithoutWarn ( ) { String r1 = "\b" ; String r2 = "\t" ; String r3 = "\n" ; String r4 = "\f" ; String r5 = "\r" ; String r6 = "\"" ; String r7 = "\'" ; String r8 = "\\" ; } public void specialCharsWithWarn ( ) { String r1 = "\\u0008" ; String r2 = "\\u0009" ; String r3 = "\\u000a" ; String r4 = "\\u000c" ; String r5 = "\\u000d" ; String r6 = "\\u0022" ; String r7 = "\\u0027" ; String r8 = "\\u005c" ; } public void specialCharsWithWarn2 ( ) { String r1 = "\\010" ; String r2 = "\\011" ; String r3 = "\\012" ; String r4 = "\\014" ; String r5 = "\\015" ; String r6 = "\\042" ; String r7 = "\\047" ; String r8 = "\\134" ; } } ; } }
package com . google . checkstyle . test . chapter2filebasic . rule231filetab ; import java . io . * ; final class FileTabCharacterInput { public static final int badConstant = 2 ; public static final int MAX_ROWS = 2 ; private static int badStatic = 2 ; private static int sNumCreated = 0 ; private int badMember = 2 ; private int mNumCreated1 = 0 ; protected int mNumCreated2 = 0 ; private int [ ] mInts = new int [ ] { 1 , 2 , 3 , 4 } ; public static int sTest1 ; protected static int sTest3 ; static int sTest2 ; int mTest1 ; public int mTest2 ; int test1 ( int badFormat1 , int badFormat2 , final int badFormat3 ) throws java . lang . Exception { return 0 ; } private void longMethod ( ) { } private FileTabCharacterInput ( ) { } private void localVariables ( ) { int abc = 0 ; int ABC = 0 ; final int cde = 0 ; final int CDE = 0 ; for ( int k = 0 ; k < 1 ; k ++ ) { String innerBlockVariable = "" ; } for ( int I = 0 ; I < 1 ; I ++ ) { String InnerBlockVariable = "" ; } } void ALL_UPPERCASE_METHOD ( ) { } private static final int BAD__NAME = 3 ; void errorColumnAfterTabs ( ) { int tab0 = 1 ; int tab1 = 1 ; int tab2 = 1 ; int tab3 = 1 ; int tab4 = 1 ; int tab5 = 1 ; } void veryLong ( ) { } void toManyArgs ( int aArg1 , int aArg2 , int aArg3 , int aArg4 , int aArg5 , int aArg6 , int aArg7 , int aArg8 , int aArg9 ) { } } class InputSimple2 { public void doSomething ( ) { for ( Object O : new java . util . ArrayList ( ) ) { } } } enum MyEnum1 { ABC , XYZ ; private int someMember ; }
package com . puppycrawl . tools . checkstyle . checks . metrics ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . metrics . ClassFanOutComplexityCheck . MSG_KEY ; public class ClassFanOutComplexityCheckTest extends BaseCheckTestSupport { @ Test public void test ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( ClassFanOutComplexityCheck . class ) ; checkConfig . addAttribute ( "max" , "0" ) ; String [ ] expected = { "6:1: " + getCheckMessage ( MSG_KEY , 3 , 0 ) , } ; verify ( checkConfig , getPath ( "metrics" + File . separator + "ClassCouplingCheckTestInput.java" ) , expected ) ; } @ Test public void test15 ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( ClassFanOutComplexityCheck . class ) ; checkConfig . addAttribute ( "max" , "0" ) ; String [ ] expected = { } ; verify ( checkConfig , getPath ( "Input15Extensions.java" ) , expected ) ; } }
package com . google . checkstyle . test . chapter2filebasic . rule233nonascii ; public class AvoidEscapedUnicodeCharactersInput { private String unitAbbrev2 = "\u03bcs" ; private String unitAbbrev3 = "\u03bcs" ; private String unitAbbrev4 = "\u03bcs" ; public Object fooString ( ) { String unitAbbrev = "μs" ; String unitAbbrev2 = "\u03bcs" ; String unitAbbrev3 = "\u03bcs" ; String fakeUnicode = "asd\tsasd" ; String fakeUnicode2 = "\\u23\\u123i\\u" ; String content = "" ; return "\ufeff" + content ; } public Object fooChar ( ) { char unitAbbrev2 = '\u03bc' ; char unitAbbrev3 = '\u03bc' ; String content = "" ; return '\ufeff' + content ; } public void multiplyString ( ) { String unitAbbrev2 = "asd\u03bcsasd" ; String unitAbbrev3 = "aBc\u03bcssdf\u03bc" ; String unitAbbrev4 = "\u03bcaBc\u03bcssdf\u03bc" ; String allCharactersEscaped = "\u03bc\u03bc" ; } }
package com . google . checkstyle . test . chapter2filebasic . rule21filename ; @ interface MyAnnotation2 { String name ( ) ; int version ( ) ; } @ MyAnnotation2 ( name = "ABC" , version = 1 ) class OuterTypeFilenameInput_3 { } enum Enum2 { A , B , C ; Enum2 ( ) { } public String toString ( ) { return "" ; } } interface TestRequireThisEnum2 { enum DAY_OF_WEEK { SUNDAY , MONDAY , TUESDAY , WEDNESDAY , THURSDAY , FRIDAY , SATURDAY } }
package com . google . checkstyle . test . chapter2filebasic . rule21filename ; @ interface MyAnnotation1 { String name ( ) ; int version ( ) ; } @ MyAnnotation1 ( name = "ABC" , version = 1 ) public class OuterTypeFilenameInput_1 { } enum Enum1 { A , B , C ; Enum1 ( ) { } public String toString ( ) { return "" ; } } interface TestRequireThisEnum { enum DAY_OF_WEEK { SUNDAY , MONDAY , TUESDAY , WEDNESDAY , THURSDAY , FRIDAY , SATURDAY } }
package com . google . checkstyle . test . chapter2filebasic . rule21filename ; public class OuterTypeFilenameInput_2 { public void defaultMethod ( ) { int i = 0 ; switch ( i ) { default : i -- ; i ++ ; break ; } } public native void nativeMethod ( ) ; public void methodWithLiterals ( ) { final String ref = "<a href=\"" ; final String refCase = "<A hReF=\"" ; } }
package com . google . checkstyle . test . chapter7javadoc . rule732overrides ; public class InputJavadocMethodCheck extends OverrideClass { int foo1 ( ) { return 1 ; } String foo2 ( ) { return "Fooooooooooooooo" + "ooooo" + "ooo" ; } void foo3 ( ) { foo2 ( ) ; } void foo4 ( ) { } int foo5 ( ) { return 1 ; } String foo6 ( ) { return "Fooooooooooooooo" + "oooooooo" ; } public String foo7 ( ) { return "Fooooooooooooooo" + "ooooo" + "ooo" ; } void foo81 ( ) { foo2 ( ) ; } void foo82 ( ) { } @ MyAnnotation String foo91 ( ) { return "Fooooooooooooooo" + "ooooo" + "ooo" ; } @ Override public String foo92 ( ) { return "Fooooo" + "ooo" + "ooooooo" + "ooooo" + "ooo" ; } } class OverrideClass { public String foo92 ( ) { return "Fooooo" + "ooo" + "ooooooo" + "ooooo" + "ooo" ; } } @ interface MyAnnotation { }
package com . google . checkstyle . test . chapter7javadoc . rule73wherejavadocused ; public class InputJavadocMethodCheck extends OverrideClass { int foo1 ( ) { return 1 ; } String foo2 ( ) { return "Fooooooooooooooo" + "ooooo" + "ooo" ; } void foo3 ( ) { foo2 ( ) ; } void foo4 ( ) { } int foo5 ( ) { return 1 ; } String foo6 ( ) { return "Fooooooooooooooo" + "oooooooo" ; } public String foo7 ( ) { return "Fooooooooooooooo" + "ooooo" + "ooo" ; } void foo81 ( ) { foo2 ( ) ; } void foo82 ( ) { } @ MyAnnotation String foo91 ( ) { return "Fooooooooooooooo" + "ooooo" + "ooo" ; } @ Override public String foo92 ( ) { return "Fooooo" + "ooo" + "ooooooo" + "ooooo" + "ooo" ; } } class OverrideClass { public String foo92 ( ) { return "Fooooo" + "ooo" + "ooooooo" + "ooooo" + "ooo" ; } } @ interface MyAnnotation { }
package com . google . checkstyle . test . chapter7javadoc . rule712paragraphs ; class InputCorrectJavadocParagraphCheck { public static final byte NUL = 0 ; boolean emulated ( ) { return false ; } class InnerInputCorrectJavaDocParagraphCheck { public static final byte NUL = 0 ; boolean emulated ( ) { return false ; } } InnerInputCorrectJavaDocParagraphCheck anon = new InnerInputCorrectJavaDocParagraphCheck ( ) { public static final byte NUL = 0 ; boolean emulated ( ) { return false ; } } ; }
package com . google . checkstyle . test . chapter7javadoc . rule712paragraphs ; class InputCorrectJavaDocParagraphCheck1 { public static final byte NUL = 0 ; boolean emulated ( ) { return false ; } class InnerInputCorrectJavaDocParagraphCheck { public static final byte NUL = 0 ; boolean emulated ( ) { return false ; } } InnerInputCorrectJavaDocParagraphCheck anon = new InnerInputCorrectJavaDocParagraphCheck ( ) { public static final byte NUL = 0 ; boolean emulated ( ) { return false ; } } ; }
package com . google . checkstyle . test . chapter7javadoc . rule72thesummaryfragment ; class InputCorrectJavaDocParagraphCheck { public static final byte NUL = 0 ; void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } void foo6 ( ) { } class InnerInputCorrectJavaDocParagraphCheck { public static final byte NUL = 0 ; public static final byte NUL_2 = 0 ; int getId ( ) { return 666 ; } void foo2 ( ) { } void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } void foo6 ( ) { } } InnerInputCorrectJavaDocParagraphCheck anon = new InnerInputCorrectJavaDocParagraphCheck ( ) { public static final byte NUL = 0 ; boolean emulated ( String s ) { return false ; } void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } void foo6 ( ) { } boolean emulated ( ) { return false ; } boolean emulated1 ( ) { return false ; } int geId ( ) { return 666 ; } } ; }
package com . google . checkstyle . test . chapter7javadoc . rule72thesummaryfragment ; class InputCorrectJavaDocParagraphCheck12 { void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } void foo6 ( ) { } public static final byte NUL = 0 ; class InnerInputCorrectJavaDocParagraphCheck { public static final byte NUL = 0 ; public static final byte NUL_2 = 0 ; boolean emulated ( ) { return false ; } void foo2 ( ) { } int geId ( ) { return 666 ; } void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } void foo6 ( ) { } } InnerInputCorrectJavaDocParagraphCheck anon = new InnerInputCorrectJavaDocParagraphCheck ( ) { public static final byte NUL = 0 ; void emulated ( String s ) { } void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } void foo6 ( ) { } } ; }
package com . puppycrawl . tools . checkstyle . checks . metrics ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . metrics . ClassDataAbstractionCouplingCheck . MSG_KEY ; public class ClassDataAbstractionCouplingCheckTest extends BaseCheckTestSupport { @ Test public void test ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( ClassDataAbstractionCouplingCheck . class ) ; checkConfig . addAttribute ( "max" , "0" ) ; checkConfig . addAttribute ( "excludedClasses" , "InnerClass" ) ; String [ ] expected = { "6:1: " + getCheckMessage ( MSG_KEY , 4 , 0 , "[AnotherInnerClass, HashMap, HashSet, int]" ) , "7:5: " + getCheckMessage ( MSG_KEY , 1 , 0 , "[ArrayList]" ) , "27:1: " + getCheckMessage ( MSG_KEY , 2 , 0 , "[HashMap, HashSet]" ) , } ; verify ( checkConfig , getPath ( "metrics" + File . separator + "ClassCouplingCheckTestInput.java" ) , expected ) ; } }
package com . google . checkstyle . test . chapter7javadoc . rule713atclauses ; class InputNonEmptyAtclauseDescriptionCheck { public InputNonEmptyAtclauseDescriptionCheck ( String a , int b ) { } public InputNonEmptyAtclauseDescriptionCheck ( String a ) { } public InputNonEmptyAtclauseDescriptionCheck ( String a , int b , double c ) { } public InputNonEmptyAtclauseDescriptionCheck ( String a , boolean e ) { } public int foo1 ( String a , int b , double c ) throws Exception { return 1 ; } public int foo2 ( String a , int b , double c ) throws Exception { return 1 ; } public int foo3 ( String a , int b , double c ) throws Exception { return 1 ; } public int foo4 ( String a , int b , double c ) throws Exception { return 1 ; } }
package com . google . checkstyle . test . chapter7javadoc . rule713atclauses ; import java . io . Serializable ; class WithAnnotations implements Serializable { private String fFirstName ; private String sSecondName ; private String tThirdName ; String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } class InnerClassWithAnnotations { String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } } InnerClassWithAnnotations anon = new InnerClassWithAnnotations ( ) { String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } } ; } enum Foo { } interface FooIn { }
package com . google . checkstyle . test . chapter7javadoc . rule713atclauses ; import java . io . Serializable ; class WithAnnotations12 implements Serializable { private String fFirstName ; private String sSecondName ; private String tThirdName ; String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } class InnerClassWithAnnotations { String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } } InnerClassWithAnnotations anon = new InnerClassWithAnnotations ( ) { String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } } ; } enum Foo5 { } interface FooIn1 { }
package com . google . checkstyle . test . chapter7javadoc . rule713atclauses ; import java . io . Serializable ; class JavaDocTagContinuationIndentation implements Serializable { private String fFirstName ; private String sSecondName ; private String tThirdName ; String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } class InnerClassWithAnnotations { String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } } InnerClassWithAnnotations anon = new InnerClassWithAnnotations ( ) { String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } } ; } enum Foo3 { } interface FooIn5 { }
package com . google . checkstyle . test . chapter7javadoc . rule711generalform ; class Foo { void foo1 ( ) { } void foo2 ( ) { } void foo3 ( ) { } void foo4 ( ) { } void foo5 ( ) { } void foo6 ( ) { } void foo7 ( ) { } void foo8 ( ) { } void bar ( ) { } void bar2 ( ) { } void bar3 ( ) { } }
package com . google . checkstyle . test . chapter7javadoc . rule711generalform ; public class InputSingleLineJavadocCheckError { void bar ( ) { } }
package com . google . checkstyle . test . chapter7javadoc . rule731selfexplanatory ; public class InputJavadocMethodCheck extends OverrideClass { int foo1 ( ) { return 1 ; } String foo2 ( ) { return "Fooooooooooooooo" + "ooooo" + "ooo" ; } void foo3 ( ) { foo2 ( ) ; } void foo4 ( ) { } int foo5 ( ) { return 1 ; } String foo6 ( ) { return "Fooooooooooooooo" + "oooooooo" ; } public String foo7 ( ) { return "Fooooooooooooooo" + "ooooo" + "ooo" ; } void foo81 ( ) { foo2 ( ) ; } void foo82 ( ) { } @ MyAnnotation String foo91 ( ) { return "Fooooooooooooooo" + "ooooo" + "ooo" ; } @ Override public String foo92 ( ) { return "Fooooo" + "ooo" + "ooooooo" + "ooooo" + "ooo" ; } } class OverrideClass { public String foo92 ( ) { return "Fooooo" + "ooo" + "ooooooo" + "ooooo" + "ooo" ; } } @ interface MyAnnotation { }
package com . puppycrawl . tools . checkstyle . checks . metrics ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . metrics . CyclomaticComplexityCheck . MSG_KEY ; public class CyclomaticComplexityCheckTest extends BaseCheckTestSupport { @ Test public void test ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CyclomaticComplexityCheck . class ) ; checkConfig . addAttribute ( "max" , "0" ) ; final String [ ] expected = { "4:5: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , "7:17: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , "17:5: " + getCheckMessage ( MSG_KEY , 6 , 0 ) , "27:5: " + getCheckMessage ( MSG_KEY , 3 , 0 ) , "34:5: " + getCheckMessage ( MSG_KEY , 5 , 0 ) , "48:5: " + getCheckMessage ( MSG_KEY , 3 , 0 ) , "58:5: " + getCheckMessage ( MSG_KEY , 3 , 0 ) , "67:5: " + getCheckMessage ( MSG_KEY , 3 , 0 ) , "76:5: " + getCheckMessage ( MSG_KEY , 1 , 0 ) , "79:13: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , } ; verify ( checkConfig , getPath ( "ComplexityCheckTestInput.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle ; import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; import java . lang . reflect . InvocationTargetException ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class AnnotationUtilityTest { @ Test public void testIsProperUtilsClass ( ) throws ReflectiveOperationException { try { assertUtilsClassHasPrivateConstructor ( AnnotationUtility . class ) ; } catch ( InvocationTargetException ex ) { Assert . assertTrue ( "do not instantiate." . equals ( ex . getCause ( ) . getMessage ( ) ) ) ; } } @ Test public void testContainsAnnotationNull ( ) throws ReflectiveOperationException { try { AnnotationUtility . containsAnnotation ( null ) ; Assert . fail ( ) ; } catch ( IllegalArgumentException ex ) { Assert . assertTrue ( "the ast is null" . equals ( ex . getMessage ( ) ) ) ; } } @ Test public void testContainsAnnotationNull2 ( ) throws ReflectiveOperationException { try { AnnotationUtility . containsAnnotation ( null , "" ) ; Assert . fail ( ) ; } catch ( IllegalArgumentException ex ) { Assert . assertTrue ( "the ast is null" . equals ( ex . getMessage ( ) ) ) ; } } @ Test public void testContainsAnnotationFalse ( ) throws ReflectiveOperationException { DetailAST ast = new DetailAST ( ) ; ast . setType ( 1 ) ; Assert . assertFalse ( AnnotationUtility . containsAnnotation ( ast ) ) ; } @ Test public void testContainsAnnotationFalse2 ( ) throws ReflectiveOperationException { DetailAST ast = new DetailAST ( ) ; ast . setType ( 1 ) ; DetailAST ast2 = new DetailAST ( ) ; ast2 . setType ( TokenTypes . MODIFIERS ) ; ast . addChild ( ast2 ) ; Assert . assertFalse ( AnnotationUtility . containsAnnotation ( ast ) ) ; } @ Test public void testContainsAnnotationTrue ( ) throws ReflectiveOperationException { DetailAST ast = new DetailAST ( ) ; ast . setType ( 1 ) ; DetailAST ast2 = new DetailAST ( ) ; ast2 . setType ( TokenTypes . MODIFIERS ) ; ast . addChild ( ast2 ) ; DetailAST ast3 = new DetailAST ( ) ; ast3 . setType ( TokenTypes . ANNOTATION ) ; ast2 . addChild ( ast3 ) ; Assert . assertTrue ( AnnotationUtility . containsAnnotation ( ast ) ) ; } @ Test public void testAnnotationHolderNull ( ) throws ReflectiveOperationException { try { AnnotationUtility . getAnnotationHolder ( null ) ; Assert . fail ( ) ; } catch ( IllegalArgumentException ex ) { Assert . assertTrue ( "the ast is null" . equals ( ex . getMessage ( ) ) ) ; } } @ Test public void testAnnotationNull ( ) throws ReflectiveOperationException { try { AnnotationUtility . getAnnotation ( null , null ) ; Assert . fail ( ) ; } catch ( IllegalArgumentException ex ) { Assert . assertTrue ( "the ast is null" . equals ( ex . getMessage ( ) ) ) ; } } @ Test public void testAnnotationNull2 ( ) throws ReflectiveOperationException { try { AnnotationUtility . getAnnotation ( new DetailAST ( ) , null ) ; Assert . fail ( ) ; } catch ( IllegalArgumentException ex ) { Assert . assertTrue ( "the annotation is null" . equals ( ex . getMessage ( ) ) ) ; } } @ Test public void testAnnotationEmpty ( ) throws ReflectiveOperationException { try { AnnotationUtility . getAnnotation ( new DetailAST ( ) , "" ) ; Assert . fail ( ) ; } catch ( IllegalArgumentException ex ) { Assert . assertTrue ( "the annotation is empty or spaces" . equals ( ex . getMessage ( ) ) ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . metrics ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . metrics . BooleanExpressionComplexityCheck . MSG_KEY ; public class BooleanExpressionComplexityCheckTest extends BaseCheckTestSupport { @ Test public void test ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( BooleanExpressionComplexityCheck . class ) ; String [ ] expected = { "13:9: " + getCheckMessage ( MSG_KEY , 4 , 3 ) , "32:9: " + getCheckMessage ( MSG_KEY , 6 , 3 ) , "38:34: " + getCheckMessage ( MSG_KEY , 4 , 3 ) , "40:34: " + getCheckMessage ( MSG_KEY , 4 , 3 ) , } ; verify ( checkConfig , getPath ( "metrics" + File . separator + "BooleanExpressionComplexityCheckTestInput.java" ) , expected ) ; } @ Test public void testNoBitwise ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( BooleanExpressionComplexityCheck . class ) ; checkConfig . addAttribute ( "max" , "5" ) ; checkConfig . addAttribute ( "tokens" , "BXOR,LAND,LOR" ) ; String [ ] expected = { } ; verify ( checkConfig , getPath ( "metrics" + File . separator + "BooleanExpressionComplexityCheckTestInput.java" ) , expected ) ; } @ Test public void testNPE ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( BooleanExpressionComplexityCheck . class ) ; String [ ] expected = { } ; verify ( checkConfig , getPath ( "metrics" + File . separator + "InputBooleanExpressionComplexityNPE.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . metrics ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . text . NumberFormat ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . metrics . NPathComplexityCheck . MSG_KEY ; public class NPathComplexityCheckTest extends BaseCheckTestSupport { @ Test public void testCalculation ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( NPathComplexityCheck . class ) ; checkConfig . addAttribute ( "max" , "0" ) ; String [ ] expected = { "4:5: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , "7:17: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , "17:5: " + getCheckMessage ( MSG_KEY , 5 , 0 ) , "27:5: " + getCheckMessage ( MSG_KEY , 3 , 0 ) , "34:5: " + getCheckMessage ( MSG_KEY , 7 , 0 ) , "48:5: " + getCheckMessage ( MSG_KEY , 3 , 0 ) , "58:5: " + getCheckMessage ( MSG_KEY , 3 , 0 ) , "67:5: " + getCheckMessage ( MSG_KEY , 3 , 0 ) , "76:5: " + getCheckMessage ( MSG_KEY , 1 , 0 ) , "79:13: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , } ; verify ( checkConfig , getPath ( "ComplexityCheckTestInput.java" ) , expected ) ; } @ Test public void testIntegerOverflow ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( NPathComplexityCheck . class ) ; checkConfig . addAttribute ( "max" , "0" ) ; final long largerThanMaxInt = 3486784401L ; final String expectedComplexity = NumberFormat . getInstance ( ) . format ( largerThanMaxInt ) ; String [ ] expected = { "9:5: " + getCheckMessage ( MSG_KEY , largerThanMaxInt , 0 ) , } ; verify ( checkConfig , getPath ( "ComplexityOverflow.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . metrics ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . metrics . JavaNCSSCheck . MSG_CLASS ; import static com . puppycrawl . tools . checkstyle . checks . metrics . JavaNCSSCheck . MSG_FILE ; import static com . puppycrawl . tools . checkstyle . checks . metrics . JavaNCSSCheck . MSG_METHOD ; public class JavaNCSSCheckTest extends BaseCheckTestSupport { @ Test public void test ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( JavaNCSSCheck . class ) ; checkConfig . addAttribute ( "methodMaximum" , "0" ) ; checkConfig . addAttribute ( "classMaximum" , "1" ) ; checkConfig . addAttribute ( "fileMaximum" , "2" ) ; String [ ] expected = { "2:1: " + getCheckMessage ( MSG_FILE , 35 , 2 ) , "9:1: " + getCheckMessage ( MSG_CLASS , 22 , 1 ) , "14:5: " + getCheckMessage ( MSG_METHOD , 2 , 0 ) , "21:5: " + getCheckMessage ( MSG_METHOD , 4 , 0 ) , "30:5: " + getCheckMessage ( MSG_METHOD , 12 , 0 ) , "42:13: " + getCheckMessage ( MSG_METHOD , 2 , 0 ) , "49:5: " + getCheckMessage ( MSG_CLASS , 2 , 1 ) , "56:1: " + getCheckMessage ( MSG_CLASS , 10 , 1 ) , "61:5: " + getCheckMessage ( MSG_METHOD , 8 , 0 ) , } ; verify ( checkConfig , getPath ( "metrics" + File . separator + "JavaNCSSCheckTestInput.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; public class Input_02 { class TestException1 extends Exception { TestException1 ( String messg ) { super ( messg ) ; } } public static class TestException2 extends Exception { TestException2 ( String messg ) { super ( messg ) ; } } public void doStuff1 ( ) throws TestException1 { try { doStuff2 ( ) ; } catch ( final TestException2 e ) { } throw new Input_02 ( ) . new TestException1 ( "" ) ; } private static void doStuff2 ( ) throws TestException2 { throw new TestException2 ( "" ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocTagContinuationIndentationCheck . MSG_KEY ; public class JavadocTagContinuationIndentationCheckTest extends BaseCheckTestSupport { @ Test public void testFP ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTagContinuationIndentationCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "javadoc/GuavaFP.java" ) , expected ) ; } @ Test public void testCheck ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTagContinuationIndentationCheck . class ) ; final String [ ] expected = { "47: " + getCheckMessage ( MSG_KEY , 4 ) , "109: " + getCheckMessage ( MSG_KEY , 4 ) , "112: " + getCheckMessage ( MSG_KEY , 4 ) , "203: " + getCheckMessage ( MSG_KEY , 4 ) , "206: " + getCheckMessage ( MSG_KEY , 4 ) , "221: " + getCheckMessage ( MSG_KEY , 4 ) , "223: " + getCheckMessage ( MSG_KEY , 4 ) , "285: " + getCheckMessage ( MSG_KEY , 4 ) , "288: " + getCheckMessage ( MSG_KEY , 4 ) , "290: " + getCheckMessage ( MSG_KEY , 4 ) , "310: " + getCheckMessage ( MSG_KEY , 4 ) , "322: " + getCheckMessage ( MSG_KEY , 4 ) , } ; verify ( checkConfig , getPath ( "javadoc/InputJavaDocTagContinuationIndentation.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . AtclauseOrderCheck . MSG_KEY ; public class AtclauseOrderCheckTest extends BaseCheckTestSupport { @ Test public void testCorrect ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AtclauseOrderCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "javadoc/InputCorrectAtClauseOrderCheck.java" ) , expected ) ; } @ Test public void testIncorrect ( ) throws Exception { final String tagOrder = "[@author, @version, @param, @return, @throws, @exception, @see," + " @since, @serial, @serialField, @serialData, @deprecated]" ; DefaultConfiguration checkConfig = createCheckConfig ( AtclauseOrderCheck . class ) ; final String [ ] expected = { "9: " + getCheckMessage ( MSG_KEY , tagOrder ) , "11: " + getCheckMessage ( MSG_KEY , tagOrder ) , "12: " + getCheckMessage ( MSG_KEY , tagOrder ) , "40: " + getCheckMessage ( MSG_KEY , tagOrder ) , "50: " + getCheckMessage ( MSG_KEY , tagOrder ) , "51: " + getCheckMessage ( MSG_KEY , tagOrder ) , "62: " + getCheckMessage ( MSG_KEY , tagOrder ) , "69: " + getCheckMessage ( MSG_KEY , tagOrder ) , "86: " + getCheckMessage ( MSG_KEY , tagOrder ) , "87: " + getCheckMessage ( MSG_KEY , tagOrder ) , "99: " + getCheckMessage ( MSG_KEY , tagOrder ) , "101: " + getCheckMessage ( MSG_KEY , tagOrder ) , "115: " + getCheckMessage ( MSG_KEY , tagOrder ) , "123: " + getCheckMessage ( MSG_KEY , tagOrder ) , "134: " + getCheckMessage ( MSG_KEY , tagOrder ) , "135: " + getCheckMessage ( MSG_KEY , tagOrder ) , "145: " + getCheckMessage ( MSG_KEY , tagOrder ) , "153: " + getCheckMessage ( MSG_KEY , tagOrder ) , "161: " + getCheckMessage ( MSG_KEY , tagOrder ) , "172: " + getCheckMessage ( MSG_KEY , tagOrder ) , "183: " + getCheckMessage ( MSG_KEY , tagOrder ) , "185: " + getCheckMessage ( MSG_KEY , tagOrder ) , "199: " + getCheckMessage ( MSG_KEY , tagOrder ) , "202: " + getCheckMessage ( MSG_KEY , tagOrder ) , "213: " + getCheckMessage ( MSG_KEY , tagOrder ) , "223: " + getCheckMessage ( MSG_KEY , tagOrder ) , "230: " + getCheckMessage ( MSG_KEY , tagOrder ) , "237: " + getCheckMessage ( MSG_KEY , tagOrder ) , "247: " + getCheckMessage ( MSG_KEY , tagOrder ) , "248: " + getCheckMessage ( MSG_KEY , tagOrder ) , "259: " + getCheckMessage ( MSG_KEY , tagOrder ) , "261: " + getCheckMessage ( MSG_KEY , tagOrder ) , "275: " + getCheckMessage ( MSG_KEY , tagOrder ) , "277: " + getCheckMessage ( MSG_KEY , tagOrder ) , "278: " + getCheckMessage ( MSG_KEY , tagOrder ) , "288: " + getCheckMessage ( MSG_KEY , tagOrder ) , } ; verify ( checkConfig , getPath ( "javadoc/InputIncorrectAtClauseOrderCheck.java" ) , expected ) ; } @ Test public void testIncorrectCustom ( ) throws Exception { final String tagOrder = "[@since, @version, @param, @return, @throws, @exception," + " @deprecated, @see, @serial, @serialField, @serialData, @author]" ; final String customOrder = " @since, @version, @param,@return,@throws, @exception," + "@deprecated, @see,@serial, @serialField, @serialData,@author" ; DefaultConfiguration checkConfig = createCheckConfig ( AtclauseOrderCheck . class ) ; checkConfig . addAttribute ( "target" , "CLASS_DEF" ) ; checkConfig . addAttribute ( "tagOrder" , customOrder ) ; final String [ ] expected = { "113: " + getCheckMessage ( MSG_KEY , tagOrder ) , } ; verify ( checkConfig , getPath ( "javadoc/InputIncorrectAtClauseOrderCheck.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . Checker ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; import java . util . Collections ; import java . util . List ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . WriteTagCheck . MISSING_TAG ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . WriteTagCheck . TAG_FORMAT ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . WriteTagCheck . WRITE_TAG ; public class WriteTagCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( WriteTagCheck . class ) ; } @ Test public void testDefaultSettings ( ) throws Exception { final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputWriteTag.java" ) , expected ) ; } @ Test public void testTag ( ) throws Exception { checkConfig . addAttribute ( "tag" , "@author" ) ; checkConfig . addAttribute ( "tagFormat" , "\\S" ) ; final String [ ] expected = { "10: " + getCheckMessage ( WRITE_TAG , "@author" , "Daniel Grenner" ) , } ; verify ( checkConfig , getPath ( "InputWriteTag.java" ) , expected ) ; } @ Test public void testMissingFormat ( ) throws Exception { checkConfig . addAttribute ( "tag" , "@author" ) ; final String [ ] expected = { "10: " + getCheckMessage ( WRITE_TAG , "@author" , "Daniel Grenner" ) , } ; verify ( checkConfig , getPath ( "InputWriteTag.java" ) , expected ) ; } @ Test public void testTagSeverity ( ) throws Exception { checkConfig . addAttribute ( "tag" , "@incomplete" ) ; checkConfig . addAttribute ( "tagFormat" , "\\S" ) ; checkConfig . addAttribute ( "tagSeverity" , "warning" ) ; final String [ ] expected = { "11: " + getCheckMessage ( WRITE_TAG , "warning: @incomplete" , "This class needs more code..." ) , } ; verify ( checkConfig , getPath ( "InputWriteTag.java" ) , expected ) ; } @ Test public void testDoubleTag ( ) throws Exception { checkConfig . addAttribute ( "tag" , "@doubletag" ) ; checkConfig . addAttribute ( "tagFormat" , "\\S" ) ; final String [ ] expected = { "12: " + getCheckMessage ( WRITE_TAG , "@doubletag" , "first text" ) , "13: " + getCheckMessage ( WRITE_TAG , "@doubletag" , "second text" ) , } ; verify ( checkConfig , getPath ( "InputWriteTag.java" ) , expected ) ; } @ Test public void testEmptyTag ( ) throws Exception { checkConfig . addAttribute ( "tag" , "@emptytag" ) ; checkConfig . addAttribute ( "tagFormat" , "" ) ; final String [ ] expected = { "14: " + getCheckMessage ( WRITE_TAG , "@emptytag" , "" ) , } ; verify ( checkConfig , getPath ( "InputWriteTag.java" ) , expected ) ; } @ Test public void testMissingTag ( ) throws Exception { checkConfig . addAttribute ( "tag" , "@missingtag" ) ; final String [ ] expected = { "16: " + getCheckMessage ( MISSING_TAG , "@missingtag" ) , } ; verify ( checkConfig , getPath ( "InputWriteTag.java" ) , expected ) ; } @ Test public void testMethod ( ) throws Exception { checkConfig . addAttribute ( "tag" , "@todo" ) ; checkConfig . addAttribute ( "tagFormat" , "\\S" ) ; checkConfig . addAttribute ( "tokens" , "INTERFACE_DEF, CLASS_DEF, METHOD_DEF, CTOR_DEF" ) ; checkConfig . addAttribute ( "severity" , "ignore" ) ; final String [ ] expected = { "19: " + getCheckMessage ( WRITE_TAG , "@todo" , "Add a constructor comment" ) , "30: " + getCheckMessage ( WRITE_TAG , "@todo" , "Add a comment" ) , } ; verify ( checkConfig , getPath ( "InputWriteTag.java" ) , expected ) ; } @ Test public void testSeverity ( ) throws Exception { checkConfig . addAttribute ( "tag" , "@author" ) ; checkConfig . addAttribute ( "tagFormat" , "\\S" ) ; checkConfig . addAttribute ( "severity" , "ignore" ) ; final String [ ] expected = { "10: " + getCheckMessage ( WRITE_TAG , "@author" , "Daniel Grenner" ) , } ; verify ( checkConfig , getPath ( "InputWriteTag.java" ) , expected ) ; } @ Test public void testIgnoreMissing ( ) throws Exception { checkConfig . addAttribute ( "tag" , "@todo2" ) ; checkConfig . addAttribute ( "tagFormat" , "\\S" ) ; checkConfig . addAttribute ( "severity" , "ignore" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputWriteTag.java" ) , expected ) ; } @ Test public void testRegularEx ( ) throws Exception { checkConfig . addAttribute ( "tag" , "@author" ) ; checkConfig . addAttribute ( "tagFormat" , "0*" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputWriteTag.java" ) , expected ) ; } @ Test public void testRegularExError ( ) throws Exception { checkConfig . addAttribute ( "tag" , "@author" ) ; checkConfig . addAttribute ( "tagFormat" , "ABC" ) ; final String [ ] expected = { "10: " + getCheckMessage ( TAG_FORMAT , "@author" , "ABC" ) , } ; verify ( checkConfig , getPath ( "InputWriteTag.java" ) , expected ) ; } @ Test public void testEnumsAndAnnotations ( ) throws Exception { checkConfig . addAttribute ( "tag" , "@incomplete" ) ; checkConfig . addAttribute ( "tagFormat" , ".*" ) ; checkConfig . addAttribute ( "severity" , "ignore" ) ; checkConfig . addAttribute ( "tagSeverity" , "error" ) ; checkConfig . addAttribute ( "tokens" , "ANNOTATION_DEF, ENUM_DEF, ANNOTATION_FIELD_DEF, ENUM_CONSTANT_DEF" ) ; final String [ ] expected = { "9: " + getCheckMessage ( WRITE_TAG , "@incomplete" , "This enum needs more code..." ) , "13: " + getCheckMessage ( WRITE_TAG , "@incomplete" , "This enum constant needs more code..." ) , "19: " + getCheckMessage ( WRITE_TAG , "@incomplete" , "This annotation needs more code..." ) , "23: " + getCheckMessage ( WRITE_TAG , "@incomplete" , "This annotation field needs more code..." ) , } ; verify ( checkConfig , getPath ( "InputWriteTag2.java" ) , expected ) ; } @ Override protected void verify ( Checker c , File [ ] processedFiles , String messageFileName , String [ ] expected ) throws Exception { stream . flush ( ) ; final List < File > theFiles = Lists . newArrayList ( ) ; Collections . addAll ( theFiles , processedFiles ) ; final int errs = c . process ( theFiles ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( BAOS . toByteArray ( ) ) ; final LineNumberReader lnr = new LineNumberReader ( new InputStreamReader ( bais ) ) ; for ( int i = 0 ; i < expected . length ; i ++ ) { final String expectedResult = messageFileName + ":" + expected [ i ] ; final String actual = lnr . readLine ( ) ; assertEquals ( "error message " + i , expectedResult , actual ) ; } assertTrue ( "unexpected output: " + lnr . readLine ( ) , expected . length >= errs ) ; c . destroy ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . AbstractJavadocCheck . PARSE_ERROR_MESSAGE_KEY ; public class AbstractJavadocCheckTest extends BaseCheckTestSupport { public static class TempCheck extends AbstractJavadocCheck { @ Override public int [ ] getDefaultJavadocTokens ( ) { return null ; } } @ Test public void testNumberFormatException ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( TempCheck . class ) ; final String [ ] expected = { "3: " + getCheckMessage ( PARSE_ERROR_MESSAGE_KEY , 52 , "no viable " + "alternative at input '<ul><li>a' {@link EntityEntry} (by way of {@link #;' " + "while parsing HTML_TAG" ) , } ; verify ( checkConfig , getPath ( "javadoc/InputTestNumberFomatException.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . NonEmptyAtclauseDescriptionCheck . MSG_KEY ; public class NonEmptyAtclauseDescriptionCheckTest extends BaseCheckTestSupport { @ Test public void testCheck ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NonEmptyAtclauseDescriptionCheck . class ) ; final String [ ] expected = { "26: " + getCheckMessage ( MSG_KEY ) , "27: " + getCheckMessage ( MSG_KEY ) , "28: " + getCheckMessage ( MSG_KEY ) , "37: " + getCheckMessage ( MSG_KEY ) , "38: " + getCheckMessage ( MSG_KEY ) , "39: " + getCheckMessage ( MSG_KEY ) , "75: " + getCheckMessage ( MSG_KEY ) , "76: " + getCheckMessage ( MSG_KEY ) , "77: " + getCheckMessage ( MSG_KEY ) , "78: " + getCheckMessage ( MSG_KEY ) , "79: " + getCheckMessage ( MSG_KEY ) , "80: " + getCheckMessage ( MSG_KEY ) , "89: " + getCheckMessage ( MSG_KEY ) , "90: " + getCheckMessage ( MSG_KEY ) , "91: " + getCheckMessage ( MSG_KEY ) , "92: " + getCheckMessage ( MSG_KEY ) , "93: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "javadoc/InputNonEmptyAtclauseDescriptionCheck.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . SingleLineJavadocCheck . MSG_KEY ; public class SingleLineJavadocCheckTest extends BaseCheckTestSupport { @ Test public void simpleTest ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( SingleLineJavadocCheck . class ) ; final String [ ] expected = { "12: " + getCheckMessage ( MSG_KEY ) , "28: " + getCheckMessage ( MSG_KEY ) , "40: " + getCheckMessage ( MSG_KEY ) , "43: " + getCheckMessage ( MSG_KEY ) , "49: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "javadoc/InputSingleLineJavadocCheck.java" ) , expected ) ; } @ Test public void testIgnoredTags ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( SingleLineJavadocCheck . class ) ; checkConfig . addAttribute ( "ignoredTags" , "@inheritDoc, @throws, " + "@ignoredCustomTag" ) ; checkConfig . addAttribute ( "ignoreInlineTags" , "false" ) ; final String [ ] expected = { "4: " + getCheckMessage ( MSG_KEY ) , "34: " + getCheckMessage ( MSG_KEY ) , "37: " + getCheckMessage ( MSG_KEY ) , "40: " + getCheckMessage ( MSG_KEY ) , "46: " + getCheckMessage ( MSG_KEY ) , "49: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "javadoc/InputSingleLineJavadocCheck.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle ; import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; import static com . puppycrawl . tools . checkstyle . Utils . baseClassname ; import static com . puppycrawl . tools . checkstyle . Utils . relativizeAndNormalizePath ; import static com . puppycrawl . tools . checkstyle . Utils . fileExtensionMatches ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import java . io . File ; import java . io . IOException ; import org . apache . commons . beanutils . ConversionException ; import org . junit . Test ; public class UtilsTest { private static final String PATH_DENORMALIZER = "/levelDown/.././" ; @ Test public void testLengthExpandedTabs ( ) throws Exception { final String s1 = "\t" ; assertEquals ( 8 , Utils . lengthExpandedTabs ( s1 , s1 . length ( ) , 8 ) ) ; final String s2 = " \t" ; assertEquals ( 8 , Utils . lengthExpandedTabs ( s2 , s2 . length ( ) , 8 ) ) ; final String s3 = "\t\t" ; assertEquals ( 16 , Utils . lengthExpandedTabs ( s3 , s3 . length ( ) , 8 ) ) ; final String s4 = " \t " ; assertEquals ( 9 , Utils . lengthExpandedTabs ( s4 , s4 . length ( ) , 8 ) ) ; assertEquals ( 0 , Utils . lengthMinusTrailingWhitespace ( "" ) ) ; assertEquals ( 0 , Utils . lengthMinusTrailingWhitespace ( " \t " ) ) ; assertEquals ( 3 , Utils . lengthMinusTrailingWhitespace ( " 23" ) ) ; assertEquals ( 3 , Utils . lengthMinusTrailingWhitespace ( " 23 \t " ) ) ; } @ Test ( expected = ConversionException . class ) public void testBadRegex ( ) { Utils . createPattern ( "[" ) ; } @ Test public void testFileExtensions ( ) { final String [ ] fileExtensions = { "java" } ; File file = new File ( "file.pdf" ) ; assertFalse ( fileExtensionMatches ( file , fileExtensions ) ) ; assertTrue ( fileExtensionMatches ( file , null ) ) ; file = new File ( "file.java" ) ; assertTrue ( fileExtensionMatches ( file , fileExtensions ) ) ; file = new File ( "file." ) ; assertTrue ( fileExtensionMatches ( file , "" ) ) ; } @ Test public void testBaseClassnameForCanonicalName ( ) { assertEquals ( "List" , baseClassname ( "java.util.List" ) ) ; } @ Test public void testBaseClassnameForSimpleName ( ) { assertEquals ( "Set" , baseClassname ( "Set" ) ) ; } @ Test public void testRelativeNormalizedPath ( ) { final String relativePath = relativizeAndNormalizePath ( "/home" , "/home/test" ) ; assertEquals ( "test" , relativePath ) ; } @ Test public void testRelativeNormalizedPathWithNullBaseDirectory ( ) { final String relativePath = relativizeAndNormalizePath ( null , "/tmp" ) ; assertEquals ( "/tmp" , relativePath ) ; } @ Test public void testRelativeNormalizedPathWithDenormalizedBaseDirectory ( ) throws IOException { final String sampleAbsolutePath = new File ( "src/main/java" ) . getCanonicalPath ( ) ; final String absoluteFilePath = sampleAbsolutePath + "/SampleFile.java" ; final String basePath = sampleAbsolutePath + PATH_DENORMALIZER ; final String relativePath = relativizeAndNormalizePath ( basePath , absoluteFilePath ) ; assertEquals ( "SampleFile.java" , relativePath ) ; } @ Test public void testIsProperUtilsClass ( ) throws ReflectiveOperationException { assertUtilsClassHasPrivateConstructor ( Utils . class ) ; } @ Test public void testInvalidPattern ( ) { boolean result = Utils . isPatternValid ( "some[invalidPattern" ) ; assertFalse ( result ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . puppycrawl . tools . checkstyle . api . JavadocTokenTypes ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; public class JavadocNodeImplTest { @ Test public void testToString ( ) { JavadocNodeImpl javadocNode = new JavadocNodeImpl ( ) ; javadocNode . setType ( JavadocTokenTypes . CODE_LITERAL ) ; javadocNode . setLineNumber ( 1 ) ; javadocNode . setColumnNumber ( 2 ) ; String result = javadocNode . toString ( ) ; assertEquals ( "CODE_LITERAL[1x2]" , result ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; public class JavadocTagTest { @ Test public void testToString ( ) { JavadocTag javadocTag = new JavadocTag ( 0 , 1 , "author" , "arg1" ) ; String result = javadocTag . toString ( ) ; assertEquals ( "JavadocTag{tag='author' lineNo=0, columnNo=1, arg1='arg1'}" , result ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocMethodCheck . MSG_DUPLICATE_TAG ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocMethodCheck . MSG_EXCPECTED_TAG ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocMethodCheck . MSG_INVALID_INHERIT_DOC ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocMethodCheck . MSG_JAVADOC_MISSING ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocMethodCheck . MSG_RETURN_EXPECTED ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocMethodCheck . MSG_UNUSED_TAG ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocMethodCheck . MSG_UNUSED_TAG_GENERAL ; import java . io . File ; import org . junit . Before ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . Scope ; public class JavadocMethodCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( JavadocMethodCheck . class ) ; checkConfig . addAttribute ( "validateThrows" , "true" ) ; } @ Test public void extendAnnotationTest ( ) throws Exception { DefaultConfiguration config = createCheckConfig ( JavadocMethodCheck . class ) ; config . addAttribute ( "allowedAnnotations" , "MyAnnotation, Override" ) ; config . addAttribute ( "minLineCount" , "2" ) ; final String [ ] expected = { "46:1: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , } ; verify ( config , getPath ( "javadoc/ExtendAnnotation.java" ) , expected ) ; } @ Test public void newTest ( ) throws Exception { DefaultConfiguration config = createCheckConfig ( JavadocMethodCheck . class ) ; config . addAttribute ( "allowedAnnotations" , "MyAnnotation, Override" ) ; config . addAttribute ( "minLineCount" , "2" ) ; final String [ ] expected = { "57:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , } ; verify ( config , getPath ( "javadoc/InputJavadocMethodCheck_SmallMethods.java" ) , expected ) ; } @ Test public void allowedAnnotationsTest ( ) throws Exception { DefaultConfiguration config = createCheckConfig ( JavadocMethodCheck . class ) ; config . addAttribute ( "allowedAnnotations" , "Override,ThisIsOk, \t\n\t ThisIsOkToo" ) ; final String [ ] expected = { } ; verify ( config , getPath ( "javadoc/AllowedAnnotations.java" ) , expected ) ; } @ Test public void testTags ( ) throws Exception { final String [ ] expected = { "14:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "18:9: " + getCheckMessage ( MSG_UNUSED_TAG , "@param" , "unused" ) , "24: " + getCheckMessage ( MSG_RETURN_EXPECTED ) , "33: " + getCheckMessage ( MSG_RETURN_EXPECTED ) , "40:16: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "Exception" ) , "49:16: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "Exception" ) , "53:9: " + getCheckMessage ( MSG_UNUSED_TAG , "@throws" , "WrongException" ) , "55:16: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "Exception" ) , "55:27: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "NullPointerException" ) , "60:22: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aOne" ) , "68:22: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aOne" ) , "72:9: " + getCheckMessage ( MSG_UNUSED_TAG , "@param" , "WrongParam" ) , "73:23: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aOne" ) , "73:33: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aTwo" ) , "78:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@param" , "Unneeded" ) , "79: " + getCheckMessage ( MSG_UNUSED_TAG_GENERAL ) , "87:8: " + getCheckMessage ( MSG_DUPLICATE_TAG , "@return" ) , "109:23: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aOne" ) , "109:55: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aFour" ) , "109:66: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aFive" ) , "178:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@throws" , "ThreadDeath" ) , "179:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@throws" , "ArrayStoreException" ) , "236:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@throws" , "java.io.FileNotFoundException" ) , "254:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@throws" , "java.io.FileNotFoundException" ) , "256:28: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "IOException" ) , "262:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@param" , "aParam" ) , "320:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "329:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "333: " + getCheckMessage ( MSG_UNUSED_TAG_GENERAL ) , } ; verify ( checkConfig , getPath ( "checks/javadoc/InputTags.java" ) , expected ) ; } @ Test public void testTagsWithResolver ( ) throws Exception { checkConfig . addAttribute ( "allowUndeclaredRTE" , "true" ) ; final String [ ] expected = { "14:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "18:9: " + getCheckMessage ( MSG_UNUSED_TAG , "@param" , "unused" ) , "24: " + getCheckMessage ( MSG_RETURN_EXPECTED ) , "33: " + getCheckMessage ( MSG_RETURN_EXPECTED ) , "40:16: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "Exception" ) , "49:16: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "Exception" ) , "55:16: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "Exception" ) , "55:27: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "NullPointerException" ) , "60:22: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aOne" ) , "68:22: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aOne" ) , "72:9: " + getCheckMessage ( MSG_UNUSED_TAG , "@param" , "WrongParam" ) , "73:23: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aOne" ) , "73:33: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aTwo" ) , "78:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@param" , "Unneeded" ) , "79: " + getCheckMessage ( MSG_UNUSED_TAG_GENERAL ) , "87:8: " + getCheckMessage ( MSG_DUPLICATE_TAG , "@return" ) , "109:23: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aOne" ) , "109:55: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aFour" ) , "109:66: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aFive" ) , "236:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@throws" , "java.io.FileNotFoundException" ) , "254:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@throws" , "java.io.FileNotFoundException" ) , "256:28: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "IOException" ) , "262:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@param" , "aParam" ) , "320:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "329:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "333: " + getCheckMessage ( MSG_UNUSED_TAG_GENERAL ) , } ; verify ( checkConfig , getPath ( "checks/javadoc/InputTags.java" ) , expected ) ; } @ Test public void testStrictJavadoc ( ) throws Exception { final String [ ] expected = { "12:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "18:13: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "25:13: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "38:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "49:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "54:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "59:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "64:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "69:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "74:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "79:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "84:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "94:32: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aA" ) , } ; verify ( checkConfig , getPath ( "InputPublicOnly.java" ) , expected ) ; } @ Test public void testNoJavadoc ( ) throws Exception { checkConfig . addAttribute ( "scope" , Scope . NOTHING . getName ( ) ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputPublicOnly.java" ) , expected ) ; } @ Test public void testRelaxedJavadoc ( ) throws Exception { checkConfig . addAttribute ( "scope" , Scope . PROTECTED . getName ( ) ) ; final String [ ] expected = { "59:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "64:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "79:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "84:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "InputPublicOnly.java" ) , expected ) ; } @ Test public void testScopeInnerInterfacesPublic ( ) throws Exception { checkConfig . addAttribute ( "scope" , Scope . PUBLIC . getName ( ) ) ; final String [ ] expected = { "43:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "44:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "InputScopeInnerInterfaces.java" ) , expected ) ; } @ Test public void testScopeAnonInnerPrivate ( ) throws Exception { checkConfig . addAttribute ( "scope" , Scope . PRIVATE . getName ( ) ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputScopeAnonInner.java" ) , expected ) ; } @ Test public void testScopeAnonInnerAnonInner ( ) throws Exception { checkConfig . addAttribute ( "scope" , Scope . ANONINNER . getName ( ) ) ; final String [ ] expected = { "26:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "39:17: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "53:17: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "InputScopeAnonInner.java" ) , expected ) ; } @ Test public void testScopeAnonInnerWithResolver ( ) throws Exception { checkConfig . addAttribute ( "allowUndeclaredRTE" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputScopeAnonInner.java" ) , expected ) ; } @ Test public void testTagsWithSubclassesAllowed ( ) throws Exception { checkConfig . addAttribute ( "allowThrowsTagsForSubclasses" , "true" ) ; final String [ ] expected = { "14:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "18:9: " + getCheckMessage ( MSG_UNUSED_TAG , "@param" , "unused" ) , "24: " + getCheckMessage ( MSG_RETURN_EXPECTED ) , "33: " + getCheckMessage ( MSG_RETURN_EXPECTED ) , "40:16: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "Exception" ) , "49:16: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "Exception" ) , "55:16: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "Exception" ) , "55:27: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "NullPointerException" ) , "60:22: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aOne" ) , "68:22: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aOne" ) , "72:9: " + getCheckMessage ( MSG_UNUSED_TAG , "@param" , "WrongParam" ) , "73:23: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aOne" ) , "73:33: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aTwo" ) , "78:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@param" , "Unneeded" ) , "79: " + getCheckMessage ( MSG_UNUSED_TAG_GENERAL ) , "87:8: " + getCheckMessage ( MSG_DUPLICATE_TAG , "@return" ) , "109:23: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aOne" ) , "109:55: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aFour" ) , "109:66: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "aFive" ) , "178:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@throws" , "ThreadDeath" ) , "179:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@throws" , "ArrayStoreException" ) , "256:28: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "IOException" ) , "262:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@param" , "aParam" ) , "320:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "329:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "333: " + getCheckMessage ( MSG_UNUSED_TAG_GENERAL ) , } ; verify ( checkConfig , getPath ( "checks/javadoc/InputTags.java" ) , expected ) ; } @ Test public void testScopes ( ) throws Exception { final String [ ] expected = { "10:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "11:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "12:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "13:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "21:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "22:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "23:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "24:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "33:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "34:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "35:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "36:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "45:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "46:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "47:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "48:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "58:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "59:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "60:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "61:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "69:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "70:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "71:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "72:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "81:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "82:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "83:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "84:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "93:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "94:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "95:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "96:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "105:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "106:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "107:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "108:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputNoJavadoc.java" ) , expected ) ; } @ Test public void testScopes2 ( ) throws Exception { checkConfig . addAttribute ( "scope" , Scope . PROTECTED . getName ( ) ) ; final String [ ] expected = { "10:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "11:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "21:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "22:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputNoJavadoc.java" ) , expected ) ; } @ Test public void testExcludeScope ( ) throws Exception { checkConfig . addAttribute ( "scope" , Scope . PRIVATE . getName ( ) ) ; checkConfig . addAttribute ( "excludeScope" , Scope . PROTECTED . getName ( ) ) ; final String [ ] expected = { "12:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "13:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "23:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "24:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "33:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "34:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "35:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "36:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "45:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "46:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "47:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "48:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "58:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "59:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "60:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "61:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "69:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "70:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "71:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "72:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "81:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "82:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "83:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "84:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "93:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "94:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "95:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "96:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "105:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "106:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "107:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "108:9: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputNoJavadoc.java" ) , expected ) ; } @ Test public void testAllowMissingJavadoc ( ) throws Exception { checkConfig . addAttribute ( "allowMissingJavadoc" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputNoJavadoc.java" ) , expected ) ; } @ Test public void testSetterGetterOff ( ) throws Exception { final String [ ] expected = { "7:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "12:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "17:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "22:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "28:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "32:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "37:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "43:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "48:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "53:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputSetterGetter.java" ) , expected ) ; } @ Test public void testSetterGetterOn ( ) throws Exception { checkConfig . addAttribute ( "allowMissingPropertyJavadoc" , "true" ) ; final String [ ] expected = { "17:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "22:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "28:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "32:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "37:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "43:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , "53:5: " + getCheckMessage ( MSG_JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputSetterGetter.java" ) , expected ) ; } @ Test public void testTypeParamsTags ( ) throws Exception { final String [ ] expected = { "26:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@param" , "<BB>" ) , "28:13: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "<Z>" ) , } ; verify ( checkConfig , getPath ( "InputTypeParamsTags.java" ) , expected ) ; } @ Test public void test_1168408_1 ( ) throws Exception { final String [ ] expected = { } ; verify ( checkConfig , getSrcPath ( "checks/javadoc/Input_01.java" ) , expected ) ; } @ Test public void test_1168408_2 ( ) throws Exception { final String [ ] expected = { } ; verify ( checkConfig , getSrcPath ( "checks/javadoc/Input_02.java" ) , expected ) ; } @ Test public void test_1168408_3 ( ) throws Exception { checkConfig . addAttribute ( "allowThrowsTagsForSubclasses" , "true" ) ; checkConfig . addAttribute ( "allowUndeclaredRTE" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getSrcPath ( "checks/javadoc/Input_03.java" ) , expected ) ; } @ Test public void test_generics_1 ( ) throws Exception { checkConfig . addAttribute ( "allowThrowsTagsForSubclasses" , "true" ) ; checkConfig . addAttribute ( "allowUndeclaredRTE" , "true" ) ; final String [ ] expected = { "17:34: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "RE" ) , "33:13: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "<NPE>" ) , "40:12: " + getCheckMessage ( MSG_UNUSED_TAG , "@throws" , "E" ) , "43:38: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "RuntimeException" ) , "44:13: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "java.lang.RuntimeException" ) , } ; verify ( checkConfig , getPath ( "javadoc/TestGenerics.java" ) , expected ) ; } @ Test public void test_generics_2 ( ) throws Exception { checkConfig . addAttribute ( "allowThrowsTagsForSubclasses" , "true" ) ; final String [ ] expected = { "17:34: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "RE" ) , "33:13: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "<NPE>" ) , "40:12: " + getCheckMessage ( MSG_UNUSED_TAG , "@throws" , "E" ) , "43:38: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "RuntimeException" ) , "44:13: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "java.lang.RuntimeException" ) , } ; verify ( checkConfig , getPath ( "javadoc/TestGenerics.java" ) , expected ) ; } @ Test public void test_generics_3 ( ) throws Exception { final String [ ] expected = { "8:8: " + getCheckMessage ( MSG_UNUSED_TAG , "@throws" , "RE" ) , "17:34: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "RE" ) , "33:13: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@param" , "<NPE>" ) , "40:12: " + getCheckMessage ( MSG_UNUSED_TAG , "@throws" , "E" ) , "43:38: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "RuntimeException" ) , "44:13: " + getCheckMessage ( MSG_EXCPECTED_TAG , "@throws" , "java.lang.RuntimeException" ) , } ; verify ( checkConfig , getPath ( "javadoc/TestGenerics.java" ) , expected ) ; } @ Test public void test_1379666 ( ) throws Exception { checkConfig . addAttribute ( "allowThrowsTagsForSubclasses" , "true" ) ; checkConfig . addAttribute ( "allowUndeclaredRTE" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getSrcPath ( "checks/javadoc/Input_1379666.java" ) , expected ) ; } @ Test public void testInheritDoc ( ) throws Exception { final String [ ] expected = { "6:5: " + getCheckMessage ( MSG_INVALID_INHERIT_DOC ) , "11:5: " + getCheckMessage ( MSG_INVALID_INHERIT_DOC ) , "31:5: " + getCheckMessage ( MSG_INVALID_INHERIT_DOC ) , "36:5: " + getCheckMessage ( MSG_INVALID_INHERIT_DOC ) , "41:5: " + getCheckMessage ( MSG_INVALID_INHERIT_DOC ) , "46:5: " + getCheckMessage ( MSG_INVALID_INHERIT_DOC ) , } ; verify ( checkConfig , getPath ( "javadoc/InputInheritDoc.java" ) , expected ) ; } @ Test public void testSkipCertainMethods ( ) throws Exception { checkConfig . addAttribute ( "ignoreMethodNamesRegex" , "^foo.*$" ) ; String [ ] expected = { } ; verify ( checkConfig , getPath ( "javadoc/InputJavadocMethodIgnoreNameRegex.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocParagraphCheck . MSG_LINE_BEFORE ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocParagraphCheck . MSG_REDUNDANT_PARAGRAPH ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocParagraphCheck . MSG_TAG_AFTER ; public class JavadocParagraphCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( JavadocParagraphCheck . class ) ; } @ Test public void testCorrect ( ) throws Exception { final String [ ] expected = { } ; verify ( checkConfig , getPath ( "javadoc/InputCorrectJavaDocParagraphCheck.java" ) , expected ) ; } @ Test public void testIncorrect ( ) throws Exception { final String [ ] expected = { "7: " + getCheckMessage ( MSG_LINE_BEFORE ) , "8: " + getCheckMessage ( MSG_LINE_BEFORE ) , "14: " + getCheckMessage ( MSG_LINE_BEFORE ) , "23: " + getCheckMessage ( MSG_LINE_BEFORE ) , "32: " + getCheckMessage ( MSG_LINE_BEFORE ) , "32: " + getCheckMessage ( MSG_REDUNDANT_PARAGRAPH ) , "33: " + getCheckMessage ( MSG_LINE_BEFORE ) , "34: " + getCheckMessage ( MSG_LINE_BEFORE ) , "35: " + getCheckMessage ( MSG_LINE_BEFORE ) , "39: " + getCheckMessage ( MSG_LINE_BEFORE ) , "45: " + getCheckMessage ( MSG_REDUNDANT_PARAGRAPH ) , "50: " + getCheckMessage ( MSG_LINE_BEFORE ) , "51: " + getCheckMessage ( MSG_LINE_BEFORE ) , "61: " + getCheckMessage ( MSG_REDUNDANT_PARAGRAPH ) , "62: " + getCheckMessage ( MSG_TAG_AFTER ) , "70: " + getCheckMessage ( MSG_LINE_BEFORE ) , "75: " + getCheckMessage ( MSG_LINE_BEFORE ) , } ; verify ( checkConfig , getPath ( "javadoc/InputIncorrectJavaDocParagraphCheck.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import org . antlr . v4 . runtime . CommonToken ; import org . antlr . v4 . runtime . tree . ParseTree ; import com . puppycrawl . tools . checkstyle . api . JavadocTokenTypes ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . AttributeContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . BrTagContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . DescriptionContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . HtmlCommentContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . HtmlElementCloseContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . HtmlElementContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . HtmlElementOpenContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . HtmlTagContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . JavadocContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . JavadocInlineTagContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . JavadocTagContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . LiContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . LiTagCloseContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . LiTagOpenContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . PTagCloseContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . PTagOpenContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . ParagraphContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . ParametersContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . ReferenceContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . SingletonElementContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . TextContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . TrContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . TrTagCloseContext ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser . TrTagOpenContext ; public class ParseTreeBuilder { private static final String LINE_SEPARATOR = System . getProperty ( "line.separator" ) ; public static ParseTree treeOneSimpleHtmlTag ( ) { JavadocContext Rohae = new JavadocContext ( null , 0 ) ; HtmlElementContext qazLp = new HtmlElementContext ( Rohae , 0 ) ; HtmlTagContext tShZn = new HtmlTagContext ( qazLp , 0 ) ; HtmlElementOpenContext mcNfy = new HtmlElementOpenContext ( tShZn , 0 ) ; CommonToken skbCU = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; mcNfy . addChild ( skbCU ) ; CommonToken eOKbB = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "g" ) ; mcNfy . addChild ( eOKbB ) ; CommonToken kSmfa = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; mcNfy . addChild ( kSmfa ) ; tShZn . addChild ( mcNfy ) ; TextContext NyvuY = new TextContext ( tShZn , 0 ) ; CommonToken vYGan = new CommonToken ( JavadocTokenTypes . CHAR , "b" ) ; NyvuY . addChild ( vYGan ) ; CommonToken DjqdT = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; NyvuY . addChild ( DjqdT ) ; CommonToken jSNqm = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; NyvuY . addChild ( jSNqm ) ; CommonToken Sqmta = new CommonToken ( JavadocTokenTypes . CHAR , "b" ) ; NyvuY . addChild ( Sqmta ) ; CommonToken ugpch = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; NyvuY . addChild ( ugpch ) ; CommonToken NIRMy = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; NyvuY . addChild ( NIRMy ) ; tShZn . addChild ( NyvuY ) ; HtmlElementCloseContext ttSqx = new HtmlElementCloseContext ( tShZn , 0 ) ; CommonToken QJJgO = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; ttSqx . addChild ( QJJgO ) ; CommonToken tCdKm = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; ttSqx . addChild ( tCdKm ) ; CommonToken IvHnz = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "g" ) ; ttSqx . addChild ( IvHnz ) ; CommonToken iudHS = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; ttSqx . addChild ( iudHS ) ; tShZn . addChild ( ttSqx ) ; qazLp . addChild ( tShZn ) ; Rohae . addChild ( qazLp ) ; CommonToken okEpH = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; Rohae . addChild ( okEpH ) ; return Rohae ; } public static ParseTree treeTextBeforeJavadocTags ( ) { JavadocContext gfEDH = new JavadocContext ( null , 0 ) ; CommonToken rpeYD = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; gfEDH . addChild ( rpeYD ) ; CommonToken QCYfG = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; gfEDH . addChild ( QCYfG ) ; TextContext tlLMb = new TextContext ( gfEDH , 0 ) ; CommonToken JYrge = new CommonToken ( JavadocTokenTypes . WS , " " ) ; tlLMb . addChild ( JYrge ) ; CommonToken Vobgp = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; tlLMb . addChild ( Vobgp ) ; CommonToken BMvCq = new CommonToken ( JavadocTokenTypes . WS , " " ) ; tlLMb . addChild ( BMvCq ) ; CommonToken ZaeOY = new CommonToken ( JavadocTokenTypes . CHAR , "b" ) ; tlLMb . addChild ( ZaeOY ) ; gfEDH . addChild ( tlLMb ) ; CommonToken csKKg = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; gfEDH . addChild ( csKKg ) ; CommonToken LxsKm = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; gfEDH . addChild ( LxsKm ) ; TextContext Shhcm = new TextContext ( gfEDH , 0 ) ; CommonToken DcHmn = new CommonToken ( JavadocTokenTypes . WS , " " ) ; Shhcm . addChild ( DcHmn ) ; CommonToken aQnuA = new CommonToken ( JavadocTokenTypes . CHAR , "c" ) ; Shhcm . addChild ( aQnuA ) ; gfEDH . addChild ( Shhcm ) ; CommonToken QPmcl = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; gfEDH . addChild ( QPmcl ) ; CommonToken HETZU = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; gfEDH . addChild ( HETZU ) ; CommonToken ZzZPO = new CommonToken ( JavadocTokenTypes . WS , " " ) ; gfEDH . addChild ( ZzZPO ) ; JavadocTagContext SjBMb = new JavadocTagContext ( gfEDH , 0 ) ; CommonToken smqzs = new CommonToken ( JavadocTokenTypes . SEE_LITERAL , "@see" ) ; SjBMb . addChild ( smqzs ) ; CommonToken bYsfI = new CommonToken ( JavadocTokenTypes . WS , " " ) ; SjBMb . addChild ( bYsfI ) ; ReferenceContext tWOgn = new ReferenceContext ( SjBMb , 0 ) ; CommonToken yJSrg = new CommonToken ( JavadocTokenTypes . CLASS , "Integer" ) ; tWOgn . addChild ( yJSrg ) ; SjBMb . addChild ( tWOgn ) ; CommonToken frxBx = new CommonToken ( JavadocTokenTypes . WS , " " ) ; SjBMb . addChild ( frxBx ) ; DescriptionContext HLhWc = new DescriptionContext ( SjBMb , 0 ) ; TextContext VNWAJ = new TextContext ( HLhWc , 0 ) ; CommonToken jjtPq = new CommonToken ( JavadocTokenTypes . CHAR , "I" ) ; VNWAJ . addChild ( jjtPq ) ; CommonToken xOBWx = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; VNWAJ . addChild ( xOBWx ) ; CommonToken OGSiY = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; VNWAJ . addChild ( OGSiY ) ; HLhWc . addChild ( VNWAJ ) ; CommonToken FXyBf = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; HLhWc . addChild ( FXyBf ) ; SjBMb . addChild ( HLhWc ) ; gfEDH . addChild ( SjBMb ) ; CommonToken VVAcP = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; gfEDH . addChild ( VVAcP ) ; CommonToken WjPJx = new CommonToken ( JavadocTokenTypes . WS , " " ) ; gfEDH . addChild ( WjPJx ) ; JavadocTagContext evKhl = new JavadocTagContext ( gfEDH , 0 ) ; CommonToken jZLvn = new CommonToken ( JavadocTokenTypes . AUTHOR_LITERAL , "@author" ) ; evKhl . addChild ( jZLvn ) ; CommonToken odstf = new CommonToken ( JavadocTokenTypes . WS , " " ) ; evKhl . addChild ( odstf ) ; DescriptionContext kLuAB = new DescriptionContext ( evKhl , 0 ) ; TextContext bvsMR = new TextContext ( kLuAB , 0 ) ; CommonToken fcFlB = new CommonToken ( JavadocTokenTypes . CHAR , "W" ) ; bvsMR . addChild ( fcFlB ) ; CommonToken iZyOh = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; bvsMR . addChild ( iZyOh ) ; CommonToken TsXte = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; bvsMR . addChild ( TsXte ) ; CommonToken hdyiE = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; bvsMR . addChild ( hdyiE ) ; CommonToken OldJO = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; bvsMR . addChild ( OldJO ) ; CommonToken PYvdd = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; bvsMR . addChild ( PYvdd ) ; CommonToken caQfZ = new CommonToken ( JavadocTokenTypes . WS , " " ) ; bvsMR . addChild ( caQfZ ) ; CommonToken ktrNT = new CommonToken ( JavadocTokenTypes . CHAR , "W" ) ; bvsMR . addChild ( ktrNT ) ; CommonToken VfpDF = new CommonToken ( JavadocTokenTypes . CHAR , "h" ) ; bvsMR . addChild ( VfpDF ) ; CommonToken NtTSj = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; bvsMR . addChild ( NtTSj ) ; CommonToken iqUhK = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; bvsMR . addChild ( iqUhK ) ; CommonToken UHgfY = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; bvsMR . addChild ( UHgfY ) ; kLuAB . addChild ( bvsMR ) ; CommonToken LiOmQ = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; kLuAB . addChild ( LiOmQ ) ; evKhl . addChild ( kLuAB ) ; gfEDH . addChild ( evKhl ) ; CommonToken tiegF = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; gfEDH . addChild ( tiegF ) ; CommonToken ktgJS = new CommonToken ( JavadocTokenTypes . WS , " " ) ; gfEDH . addChild ( ktgJS ) ; JavadocTagContext WyRvi = new JavadocTagContext ( gfEDH , 0 ) ; CommonToken yItAZ = new CommonToken ( JavadocTokenTypes . AUTHOR_LITERAL , "@author" ) ; WyRvi . addChild ( yItAZ ) ; CommonToken VsNbv = new CommonToken ( JavadocTokenTypes . WS , " " ) ; WyRvi . addChild ( VsNbv ) ; DescriptionContext KadGv = new DescriptionContext ( WyRvi , 0 ) ; TextContext fsYhy = new TextContext ( KadGv , 0 ) ; CommonToken QLquB = new CommonToken ( JavadocTokenTypes . CHAR , "J" ) ; fsYhy . addChild ( QLquB ) ; CommonToken tpwVU = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; fsYhy . addChild ( tpwVU ) ; CommonToken QvluV = new CommonToken ( JavadocTokenTypes . CHAR , "h" ) ; fsYhy . addChild ( QvluV ) ; CommonToken cQlIs = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; fsYhy . addChild ( cQlIs ) ; CommonToken ZQDPr = new CommonToken ( JavadocTokenTypes . WS , " " ) ; fsYhy . addChild ( ZQDPr ) ; CommonToken WMWeU = new CommonToken ( JavadocTokenTypes . CHAR , "S" ) ; fsYhy . addChild ( WMWeU ) ; CommonToken xXCnc = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; fsYhy . addChild ( xXCnc ) ; CommonToken BGIhA = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; fsYhy . addChild ( BGIhA ) ; CommonToken XmTzP = new CommonToken ( JavadocTokenTypes . CHAR , "w" ) ; fsYhy . addChild ( XmTzP ) ; KadGv . addChild ( fsYhy ) ; CommonToken NhsCl = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; KadGv . addChild ( NhsCl ) ; TextContext TZrfl = new TextContext ( KadGv , 0 ) ; CommonToken QLNbu = new CommonToken ( JavadocTokenTypes . WS , " " ) ; TZrfl . addChild ( QLNbu ) ; KadGv . addChild ( TZrfl ) ; WyRvi . addChild ( KadGv ) ; gfEDH . addChild ( WyRvi ) ; CommonToken cnrjp = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; gfEDH . addChild ( cnrjp ) ; return gfEDH ; } public static ParseTree treeCustomJavadocTags ( ) { JavadocContext vqeRv = new JavadocContext ( null , 0 ) ; CommonToken kUYEj = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; vqeRv . addChild ( kUYEj ) ; CommonToken VOJHC = new CommonToken ( JavadocTokenTypes . WS , " " ) ; vqeRv . addChild ( VOJHC ) ; JavadocTagContext DYThx = new JavadocTagContext ( vqeRv , 0 ) ; CommonToken ctenR = new CommonToken ( JavadocTokenTypes . CUSTOM_NAME , "@myTag" ) ; DYThx . addChild ( ctenR ) ; CommonToken ObxYB = new CommonToken ( JavadocTokenTypes . WS , " " ) ; DYThx . addChild ( ObxYB ) ; DescriptionContext WuoxQ = new DescriptionContext ( DYThx , 0 ) ; TextContext FaQUX = new TextContext ( WuoxQ , 0 ) ; CommonToken fpyzz = new CommonToken ( JavadocTokenTypes . CHAR , "y" ) ; FaQUX . addChild ( fpyzz ) ; CommonToken lbwtC = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; FaQUX . addChild ( lbwtC ) ; CommonToken xCpJd = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; FaQUX . addChild ( xCpJd ) ; CommonToken OOdfd = new CommonToken ( JavadocTokenTypes . WS , " " ) ; FaQUX . addChild ( OOdfd ) ; CommonToken jTWwf = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; FaQUX . addChild ( jTWwf ) ; CommonToken tYuft = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; FaQUX . addChild ( tYuft ) ; CommonToken Rjpiw = new CommonToken ( JavadocTokenTypes . WS , " " ) ; FaQUX . addChild ( Rjpiw ) ; CommonToken eumTC = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; FaQUX . addChild ( eumTC ) ; CommonToken SUdyR = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; FaQUX . addChild ( SUdyR ) ; WuoxQ . addChild ( FaQUX ) ; CommonToken ZcIzE = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; WuoxQ . addChild ( ZcIzE ) ; DYThx . addChild ( WuoxQ ) ; vqeRv . addChild ( DYThx ) ; CommonToken kMCCR = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; vqeRv . addChild ( kMCCR ) ; CommonToken pFtfc = new CommonToken ( JavadocTokenTypes . WS , " " ) ; vqeRv . addChild ( pFtfc ) ; JavadocTagContext mYbvf = new JavadocTagContext ( vqeRv , 0 ) ; CommonToken JUVPH = new CommonToken ( JavadocTokenTypes . CUSTOM_NAME , "@anotherTagWithoutParameter" ) ; mYbvf . addChild ( JUVPH ) ; CommonToken mDykX = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; mYbvf . addChild ( mDykX ) ; vqeRv . addChild ( mYbvf ) ; CommonToken oHnTB = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; vqeRv . addChild ( oHnTB ) ; CommonToken aLlHU = new CommonToken ( JavadocTokenTypes . WS , " " ) ; vqeRv . addChild ( aLlHU ) ; JavadocTagContext MVTCW = new JavadocTagContext ( vqeRv , 0 ) ; CommonToken ipxcL = new CommonToken ( JavadocTokenTypes . AUTHOR_LITERAL , "@author" ) ; MVTCW . addChild ( ipxcL ) ; CommonToken AfLyL = new CommonToken ( JavadocTokenTypes . WS , " " ) ; MVTCW . addChild ( AfLyL ) ; DescriptionContext ZXuuK = new DescriptionContext ( MVTCW , 0 ) ; TextContext uXOoV = new TextContext ( ZXuuK , 0 ) ; CommonToken PzlFR = new CommonToken ( JavadocTokenTypes . CHAR , "I" ) ; uXOoV . addChild ( PzlFR ) ; ZXuuK . addChild ( uXOoV ) ; CommonToken VNXPi = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; ZXuuK . addChild ( VNXPi ) ; TextContext vUStO = new TextContext ( ZXuuK , 0 ) ; CommonToken yLjDi = new CommonToken ( JavadocTokenTypes . WS , " " ) ; vUStO . addChild ( yLjDi ) ; ZXuuK . addChild ( vUStO ) ; MVTCW . addChild ( ZXuuK ) ; vqeRv . addChild ( MVTCW ) ; CommonToken QNmAS = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; vqeRv . addChild ( QNmAS ) ; return vqeRv ; } public static ParseTree treeJavadocTagDescriptionWithInlineTags ( ) { JavadocContext ckejg = new JavadocContext ( null , 0 ) ; JavadocTagContext HBaud = new JavadocTagContext ( ckejg , 0 ) ; CommonToken YeyWs = new CommonToken ( JavadocTokenTypes . DEPRECATED_LITERAL , "@deprecated" ) ; HBaud . addChild ( YeyWs ) ; CommonToken plGhl = new CommonToken ( JavadocTokenTypes . WS , " " ) ; HBaud . addChild ( plGhl ) ; DescriptionContext roovx = new DescriptionContext ( HBaud , 0 ) ; TextContext lCvIq = new TextContext ( roovx , 0 ) ; CommonToken OlFdS = new CommonToken ( JavadocTokenTypes . CHAR , "u" ) ; lCvIq . addChild ( OlFdS ) ; CommonToken lCAos = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; lCvIq . addChild ( lCAos ) ; CommonToken hqFBO = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; lCvIq . addChild ( hqFBO ) ; CommonToken DWiAh = new CommonToken ( JavadocTokenTypes . WS , " " ) ; lCvIq . addChild ( DWiAh ) ; roovx . addChild ( lCvIq ) ; JavadocInlineTagContext FVbYW = new JavadocInlineTagContext ( roovx , 0 ) ; CommonToken nHbXu = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; FVbYW . addChild ( nHbXu ) ; CommonToken jmpgq = new CommonToken ( JavadocTokenTypes . LINK_LITERAL , "@link" ) ; FVbYW . addChild ( jmpgq ) ; CommonToken MDzSX = new CommonToken ( JavadocTokenTypes . WS , " " ) ; FVbYW . addChild ( MDzSX ) ; ReferenceContext HMaDA = new ReferenceContext ( FVbYW , 0 ) ; CommonToken Jhqym = new CommonToken ( JavadocTokenTypes . PACKAGE , "java.lang" ) ; HMaDA . addChild ( Jhqym ) ; CommonToken PLrXL = new CommonToken ( JavadocTokenTypes . DOT , "." ) ; HMaDA . addChild ( PLrXL ) ; CommonToken ktXCU = new CommonToken ( JavadocTokenTypes . CLASS , "Integer" ) ; HMaDA . addChild ( ktXCU ) ; FVbYW . addChild ( HMaDA ) ; DescriptionContext ztrDY = new DescriptionContext ( FVbYW , 0 ) ; TextContext IGcNX = new TextContext ( ztrDY , 0 ) ; CommonToken CyJjh = new CommonToken ( JavadocTokenTypes . WS , " " ) ; IGcNX . addChild ( CyJjh ) ; CommonToken YZFRh = new CommonToken ( JavadocTokenTypes . CHAR , "I" ) ; IGcNX . addChild ( YZFRh ) ; CommonToken uuLgj = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; IGcNX . addChild ( uuLgj ) ; CommonToken hKAOH = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; IGcNX . addChild ( hKAOH ) ; CommonToken XeMhP = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; IGcNX . addChild ( XeMhP ) ; CommonToken JWZxb = new CommonToken ( JavadocTokenTypes . CHAR , "g" ) ; IGcNX . addChild ( JWZxb ) ; CommonToken sXOYk = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; IGcNX . addChild ( sXOYk ) ; CommonToken NZnjU = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; IGcNX . addChild ( NZnjU ) ; ztrDY . addChild ( IGcNX ) ; JavadocInlineTagContext nUzga = new JavadocInlineTagContext ( ztrDY , 0 ) ; CommonToken CRuAH = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; nUzga . addChild ( CRuAH ) ; CommonToken ZzRot = new CommonToken ( JavadocTokenTypes . CODE_LITERAL , "@code" ) ; nUzga . addChild ( ZzRot ) ; CommonToken hzHqq = new CommonToken ( JavadocTokenTypes . WS , " " ) ; nUzga . addChild ( hzHqq ) ; TextContext zSjXd = new TextContext ( nUzga , 0 ) ; CommonToken KTIhG = new CommonToken ( JavadocTokenTypes . CHAR , "<" ) ; zSjXd . addChild ( KTIhG ) ; CommonToken oDeiQ = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; zSjXd . addChild ( oDeiQ ) ; CommonToken bCRuf = new CommonToken ( JavadocTokenTypes . CHAR , ">" ) ; zSjXd . addChild ( bCRuf ) ; CommonToken WyGtD = new CommonToken ( JavadocTokenTypes . CHAR , "W" ) ; zSjXd . addChild ( WyGtD ) ; CommonToken BUUWH = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; zSjXd . addChild ( BUUWH ) ; CommonToken gBlIs = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; zSjXd . addChild ( gBlIs ) ; CommonToken LIhFs = new CommonToken ( JavadocTokenTypes . CHAR , "<" ) ; zSjXd . addChild ( LIhFs ) ; CommonToken uovUc = new CommonToken ( JavadocTokenTypes . CHAR , "/" ) ; zSjXd . addChild ( uovUc ) ; CommonToken DZKDL = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; zSjXd . addChild ( DZKDL ) ; CommonToken gYaGe = new CommonToken ( JavadocTokenTypes . CHAR , ">" ) ; zSjXd . addChild ( gYaGe ) ; nUzga . addChild ( zSjXd ) ; CommonToken FlbFQ = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; nUzga . addChild ( FlbFQ ) ; ztrDY . addChild ( nUzga ) ; FVbYW . addChild ( ztrDY ) ; CommonToken SwxUk = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; FVbYW . addChild ( SwxUk ) ; roovx . addChild ( FVbYW ) ; TextContext oGDof = new TextContext ( roovx , 0 ) ; CommonToken fWqMz = new CommonToken ( JavadocTokenTypes . WS , " " ) ; oGDof . addChild ( fWqMz ) ; CommonToken HoYCn = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; oGDof . addChild ( HoYCn ) ; CommonToken dkbfF = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; oGDof . addChild ( dkbfF ) ; CommonToken TBKXz = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; oGDof . addChild ( TBKXz ) ; CommonToken RTDDh = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; oGDof . addChild ( RTDDh ) ; CommonToken IonJK = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; oGDof . addChild ( IonJK ) ; CommonToken JSCTa = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; oGDof . addChild ( JSCTa ) ; CommonToken waeey = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; oGDof . addChild ( waeey ) ; roovx . addChild ( oGDof ) ; HBaud . addChild ( roovx ) ; ckejg . addChild ( HBaud ) ; CommonToken mDnxb = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; ckejg . addChild ( mDnxb ) ; return ckejg ; } public static ParseTree treeLeadingAsterisks ( ) { JavadocContext ESHfJ = new JavadocContext ( null , 0 ) ; CommonToken avwXT = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; ESHfJ . addChild ( avwXT ) ; CommonToken RlzJr = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; ESHfJ . addChild ( RlzJr ) ; TextContext mDTfc = new TextContext ( ESHfJ , 0 ) ; CommonToken TCVnz = new CommonToken ( JavadocTokenTypes . WS , " " ) ; mDTfc . addChild ( TCVnz ) ; CommonToken Eecil = new CommonToken ( JavadocTokenTypes . CHAR , "L" ) ; mDTfc . addChild ( Eecil ) ; CommonToken jiYGz = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; mDTfc . addChild ( jiYGz ) ; CommonToken dJXCd = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; mDTfc . addChild ( dJXCd ) ; CommonToken hcsGh = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; mDTfc . addChild ( hcsGh ) ; CommonToken HDIpw = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; mDTfc . addChild ( HDIpw ) ; CommonToken rIybq = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; mDTfc . addChild ( rIybq ) ; CommonToken vxdRh = new CommonToken ( JavadocTokenTypes . CHAR , "g" ) ; mDTfc . addChild ( vxdRh ) ; CommonToken WMJXY = new CommonToken ( JavadocTokenTypes . WS , " " ) ; mDTfc . addChild ( WMJXY ) ; CommonToken zqREY = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; mDTfc . addChild ( zqREY ) ; CommonToken PdPMn = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; mDTfc . addChild ( PdPMn ) ; CommonToken nHhZd = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; mDTfc . addChild ( nHhZd ) ; CommonToken YACET = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; mDTfc . addChild ( YACET ) ; CommonToken GPryT = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; mDTfc . addChild ( GPryT ) ; CommonToken RMGmz = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; mDTfc . addChild ( RMGmz ) ; CommonToken pktyX = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; mDTfc . addChild ( pktyX ) ; CommonToken ihpJN = new CommonToken ( JavadocTokenTypes . CHAR , "k" ) ; mDTfc . addChild ( ihpJN ) ; ESHfJ . addChild ( mDTfc ) ; CommonToken nuxOz = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; ESHfJ . addChild ( nuxOz ) ; CommonToken jqMyc = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; ESHfJ . addChild ( jqMyc ) ; TextContext wkaXz = new TextContext ( ESHfJ , 0 ) ; CommonToken qwSBF = new CommonToken ( JavadocTokenTypes . WS , " " ) ; wkaXz . addChild ( qwSBF ) ; CommonToken Nkbgp = new CommonToken ( JavadocTokenTypes . CHAR , "A" ) ; wkaXz . addChild ( Nkbgp ) ; CommonToken rDueW = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; wkaXz . addChild ( rDueW ) ; CommonToken tojhr = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; wkaXz . addChild ( tojhr ) ; CommonToken kuktV = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; wkaXz . addChild ( kuktV ) ; CommonToken SvKGl = new CommonToken ( JavadocTokenTypes . CHAR , "h" ) ; wkaXz . addChild ( SvKGl ) ; CommonToken CRGcP = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; wkaXz . addChild ( CRGcP ) ; CommonToken laMGd = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; wkaXz . addChild ( laMGd ) ; CommonToken QIVBU = new CommonToken ( JavadocTokenTypes . WS , " " ) ; wkaXz . addChild ( QIVBU ) ; CommonToken inUyg = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; wkaXz . addChild ( inUyg ) ; CommonToken MrCDK = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; wkaXz . addChild ( MrCDK ) ; CommonToken ibqGj = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; wkaXz . addChild ( ibqGj ) ; ESHfJ . addChild ( wkaXz ) ; CommonToken CvXeG = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; ESHfJ . addChild ( CvXeG ) ; return ESHfJ ; } public static ParseTree treeAuthorWithMailto ( ) { JavadocContext TGTbm = new JavadocContext ( null , 0 ) ; JavadocTagContext dzPuU = new JavadocTagContext ( TGTbm , 0 ) ; CommonToken KeavR = new CommonToken ( JavadocTokenTypes . AUTHOR_LITERAL , "@author" ) ; dzPuU . addChild ( KeavR ) ; CommonToken czLfR = new CommonToken ( JavadocTokenTypes . WS , " " ) ; dzPuU . addChild ( czLfR ) ; DescriptionContext bTGWe = new DescriptionContext ( dzPuU , 0 ) ; HtmlElementContext aoBuh = new HtmlElementContext ( bTGWe , 0 ) ; HtmlTagContext vFKpv = new HtmlTagContext ( aoBuh , 0 ) ; HtmlElementOpenContext HMTTi = new HtmlElementOpenContext ( vFKpv , 0 ) ; CommonToken SSVZC = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; HMTTi . addChild ( SSVZC ) ; CommonToken NnpgO = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "a" ) ; HMTTi . addChild ( NnpgO ) ; CommonToken iyonf = new CommonToken ( JavadocTokenTypes . WS , " " ) ; HMTTi . addChild ( iyonf ) ; AttributeContext vxDGj = new AttributeContext ( HMTTi , 0 ) ; CommonToken OEFMv = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "href" ) ; vxDGj . addChild ( OEFMv ) ; CommonToken HrHJF = new CommonToken ( JavadocTokenTypes . EQUALS , "=" ) ; vxDGj . addChild ( HrHJF ) ; CommonToken ntbkP = new CommonToken ( JavadocTokenTypes . ATTR_VALUE , "\"mailto:barataliba@gmail.com\"" ) ; vxDGj . addChild ( ntbkP ) ; HMTTi . addChild ( vxDGj ) ; CommonToken xPeiD = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; HMTTi . addChild ( xPeiD ) ; vFKpv . addChild ( HMTTi ) ; TextContext Auskd = new TextContext ( vFKpv , 0 ) ; CommonToken QZOWF = new CommonToken ( JavadocTokenTypes . CHAR , "B" ) ; Auskd . addChild ( QZOWF ) ; CommonToken aHoKe = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; Auskd . addChild ( aHoKe ) ; CommonToken KmPGt = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; Auskd . addChild ( KmPGt ) ; CommonToken IkYYT = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; Auskd . addChild ( IkYYT ) ; CommonToken qHAgD = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; Auskd . addChild ( qHAgD ) ; CommonToken hzsoO = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; Auskd . addChild ( hzsoO ) ; CommonToken Ypeux = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; Auskd . addChild ( Ypeux ) ; CommonToken jjUpd = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; Auskd . addChild ( jjUpd ) ; CommonToken KgHqO = new CommonToken ( JavadocTokenTypes . WS , " " ) ; Auskd . addChild ( KgHqO ) ; CommonToken fwvwj = new CommonToken ( JavadocTokenTypes . CHAR , "I" ) ; Auskd . addChild ( fwvwj ) ; CommonToken uPhgY = new CommonToken ( JavadocTokenTypes . CHAR , "z" ) ; Auskd . addChild ( uPhgY ) ; CommonToken xTCuL = new CommonToken ( JavadocTokenTypes . CHAR , "m" ) ; Auskd . addChild ( xTCuL ) ; CommonToken BwdLV = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; Auskd . addChild ( BwdLV ) ; CommonToken AdkMH = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; Auskd . addChild ( AdkMH ) ; CommonToken qNtQc = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; Auskd . addChild ( qNtQc ) ; CommonToken PFiZu = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; Auskd . addChild ( PFiZu ) ; CommonToken ZQZPQ = new CommonToken ( JavadocTokenTypes . CHAR , "v" ) ; Auskd . addChild ( ZQZPQ ) ; vFKpv . addChild ( Auskd ) ; HtmlElementCloseContext SgyXZ = new HtmlElementCloseContext ( vFKpv , 0 ) ; CommonToken KfwXW = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; SgyXZ . addChild ( KfwXW ) ; CommonToken FjjTR = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; SgyXZ . addChild ( FjjTR ) ; CommonToken RjDMC = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "a" ) ; SgyXZ . addChild ( RjDMC ) ; CommonToken bxeIt = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; SgyXZ . addChild ( bxeIt ) ; vFKpv . addChild ( SgyXZ ) ; aoBuh . addChild ( vFKpv ) ; bTGWe . addChild ( aoBuh ) ; dzPuU . addChild ( bTGWe ) ; TGTbm . addChild ( dzPuU ) ; CommonToken OPdHU = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; TGTbm . addChild ( OPdHU ) ; return TGTbm ; } public static ParseTree treeHtmlTagsInParagraph ( ) { JavadocContext GAVYr = new JavadocContext ( null , 0 ) ; CommonToken rEvDw = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; GAVYr . addChild ( rEvDw ) ; CommonToken HuQwG = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; GAVYr . addChild ( HuQwG ) ; TextContext kTCYp = new TextContext ( GAVYr , 0 ) ; CommonToken JvENn = new CommonToken ( JavadocTokenTypes . WS , " " ) ; kTCYp . addChild ( JvENn ) ; GAVYr . addChild ( kTCYp ) ; HtmlElementContext lMaBP = new HtmlElementContext ( GAVYr , 0 ) ; ParagraphContext VJfJM = new ParagraphContext ( lMaBP , 0 ) ; PTagOpenContext ETZjr = new PTagOpenContext ( VJfJM , 0 ) ; CommonToken KMkyi = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; ETZjr . addChild ( KMkyi ) ; CommonToken SkNYf = new CommonToken ( JavadocTokenTypes . P_HTML_TAG_NAME , "p" ) ; ETZjr . addChild ( SkNYf ) ; CommonToken fiGyP = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; ETZjr . addChild ( fiGyP ) ; VJfJM . addChild ( ETZjr ) ; CommonToken vANOl = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; VJfJM . addChild ( vANOl ) ; CommonToken hOBKf = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; VJfJM . addChild ( hOBKf ) ; TextContext nCSrv = new TextContext ( VJfJM , 0 ) ; CommonToken ypYEx = new CommonToken ( JavadocTokenTypes . WS , " " ) ; nCSrv . addChild ( ypYEx ) ; VJfJM . addChild ( nCSrv ) ; HtmlTagContext mdIKq = new HtmlTagContext ( VJfJM , 0 ) ; HtmlElementOpenContext gAuWp = new HtmlElementOpenContext ( mdIKq , 0 ) ; CommonToken cNfXF = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; gAuWp . addChild ( cNfXF ) ; CommonToken JReVR = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "b" ) ; gAuWp . addChild ( JReVR ) ; CommonToken UEroP = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; gAuWp . addChild ( UEroP ) ; mdIKq . addChild ( gAuWp ) ; TextContext MHmsA = new TextContext ( mdIKq , 0 ) ; CommonToken hMUIk = new CommonToken ( JavadocTokenTypes . CHAR , "D" ) ; MHmsA . addChild ( hMUIk ) ; CommonToken KeTWR = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; MHmsA . addChild ( KeTWR ) ; CommonToken rtXnS = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; MHmsA . addChild ( rtXnS ) ; CommonToken JAFgc = new CommonToken ( JavadocTokenTypes . CHAR , "c" ) ; MHmsA . addChild ( JAFgc ) ; CommonToken PvbLM = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; MHmsA . addChild ( PvbLM ) ; CommonToken wzZFJ = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; MHmsA . addChild ( wzZFJ ) ; CommonToken ecrVB = new CommonToken ( JavadocTokenTypes . CHAR , "p" ) ; MHmsA . addChild ( ecrVB ) ; CommonToken EoWQC = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; MHmsA . addChild ( EoWQC ) ; CommonToken wBECH = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; MHmsA . addChild ( wBECH ) ; CommonToken yEVLE = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; MHmsA . addChild ( yEVLE ) ; CommonToken IeRpy = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; MHmsA . addChild ( IeRpy ) ; mdIKq . addChild ( MHmsA ) ; HtmlElementCloseContext lnLwP = new HtmlElementCloseContext ( mdIKq , 0 ) ; CommonToken dsyIx = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; lnLwP . addChild ( dsyIx ) ; CommonToken ByJND = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; lnLwP . addChild ( ByJND ) ; CommonToken pMJUi = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "b" ) ; lnLwP . addChild ( pMJUi ) ; CommonToken UzqYH = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; lnLwP . addChild ( UzqYH ) ; mdIKq . addChild ( lnLwP ) ; VJfJM . addChild ( mdIKq ) ; TextContext dilJr = new TextContext ( VJfJM , 0 ) ; CommonToken hruoj = new CommonToken ( JavadocTokenTypes . WS , " " ) ; dilJr . addChild ( hruoj ) ; VJfJM . addChild ( dilJr ) ; HtmlTagContext AAXLm = new HtmlTagContext ( VJfJM , 0 ) ; HtmlElementOpenContext IXdVA = new HtmlElementOpenContext ( AAXLm , 0 ) ; CommonToken AfTBP = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; IXdVA . addChild ( AfTBP ) ; CommonToken aiLsy = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "i" ) ; IXdVA . addChild ( aiLsy ) ; CommonToken AYjDn = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; IXdVA . addChild ( AYjDn ) ; AAXLm . addChild ( IXdVA ) ; TextContext mLewg = new TextContext ( AAXLm , 0 ) ; CommonToken UYEUR = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; mLewg . addChild ( UYEUR ) ; CommonToken mKGhH = new CommonToken ( JavadocTokenTypes . CHAR , "f" ) ; mLewg . addChild ( mKGhH ) ; AAXLm . addChild ( mLewg ) ; HtmlElementCloseContext VBmkt = new HtmlElementCloseContext ( AAXLm , 0 ) ; CommonToken OLLhv = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; VBmkt . addChild ( OLLhv ) ; CommonToken HUGCV = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; VBmkt . addChild ( HUGCV ) ; CommonToken tWOaB = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "i" ) ; VBmkt . addChild ( tWOaB ) ; CommonToken RXdLh = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; VBmkt . addChild ( RXdLh ) ; AAXLm . addChild ( VBmkt ) ; VJfJM . addChild ( AAXLm ) ; TextContext WqkTu = new TextContext ( VJfJM , 0 ) ; CommonToken hBQwt = new CommonToken ( JavadocTokenTypes . WS , " " ) ; WqkTu . addChild ( hBQwt ) ; CommonToken YAkEY = new CommonToken ( JavadocTokenTypes . CHAR , "m" ) ; WqkTu . addChild ( YAkEY ) ; CommonToken Jxywu = new CommonToken ( JavadocTokenTypes . CHAR , "y" ) ; WqkTu . addChild ( Jxywu ) ; CommonToken ZHNCp = new CommonToken ( JavadocTokenTypes . WS , " " ) ; WqkTu . addChild ( ZHNCp ) ; CommonToken ebPuR = new CommonToken ( JavadocTokenTypes . CHAR , "c" ) ; WqkTu . addChild ( ebPuR ) ; CommonToken sjCYh = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; WqkTu . addChild ( sjCYh ) ; CommonToken ndQgs = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; WqkTu . addChild ( ndQgs ) ; CommonToken rNMlu = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; WqkTu . addChild ( rNMlu ) ; CommonToken xagsR = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; WqkTu . addChild ( xagsR ) ; CommonToken Ihivy = new CommonToken ( JavadocTokenTypes . CHAR , "." ) ; WqkTu . addChild ( Ihivy ) ; VJfJM . addChild ( WqkTu ) ; CommonToken WylwX = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; VJfJM . addChild ( WylwX ) ; CommonToken tpZma = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; VJfJM . addChild ( tpZma ) ; TextContext NBrTT = new TextContext ( VJfJM , 0 ) ; CommonToken pgfvt = new CommonToken ( JavadocTokenTypes . WS , " " ) ; NBrTT . addChild ( pgfvt ) ; VJfJM . addChild ( NBrTT ) ; PTagCloseContext mrwRr = new PTagCloseContext ( VJfJM , 0 ) ; CommonToken DSGYS = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; mrwRr . addChild ( DSGYS ) ; CommonToken NhROI = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; mrwRr . addChild ( NhROI ) ; CommonToken Epgpc = new CommonToken ( JavadocTokenTypes . P_HTML_TAG_NAME , "p" ) ; mrwRr . addChild ( Epgpc ) ; CommonToken yTmrB = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; mrwRr . addChild ( yTmrB ) ; VJfJM . addChild ( mrwRr ) ; lMaBP . addChild ( VJfJM ) ; GAVYr . addChild ( lMaBP ) ; CommonToken ydCCN = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; GAVYr . addChild ( ydCCN ) ; CommonToken EIVXE = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; GAVYr . addChild ( EIVXE ) ; TextContext FHTtd = new TextContext ( GAVYr , 0 ) ; CommonToken ROEZF = new CommonToken ( JavadocTokenTypes . WS , " " ) ; FHTtd . addChild ( ROEZF ) ; CommonToken CelZP = new CommonToken ( JavadocTokenTypes . CHAR , "A" ) ; FHTtd . addChild ( CelZP ) ; CommonToken FlqMi = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; FHTtd . addChild ( FlqMi ) ; CommonToken GxqHT = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; FHTtd . addChild ( GxqHT ) ; CommonToken vrZWK = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; FHTtd . addChild ( vrZWK ) ; CommonToken LsrlV = new CommonToken ( JavadocTokenTypes . CHAR , "h" ) ; FHTtd . addChild ( LsrlV ) ; CommonToken rtcPS = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; FHTtd . addChild ( rtcPS ) ; CommonToken rdVEq = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; FHTtd . addChild ( rdVEq ) ; CommonToken MhFIL = new CommonToken ( JavadocTokenTypes . WS , " " ) ; FHTtd . addChild ( MhFIL ) ; CommonToken fwjvl = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; FHTtd . addChild ( fwjvl ) ; CommonToken lhwtC = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; FHTtd . addChild ( lhwtC ) ; CommonToken pmTuO = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; FHTtd . addChild ( pmTuO ) ; CommonToken QfZjq = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; FHTtd . addChild ( QfZjq ) ; CommonToken eKctL = new CommonToken ( JavadocTokenTypes . WS , " " ) ; FHTtd . addChild ( eKctL ) ; CommonToken NgmFS = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; FHTtd . addChild ( NgmFS ) ; CommonToken HJTxt = new CommonToken ( JavadocTokenTypes . CHAR , "f" ) ; FHTtd . addChild ( HJTxt ) ; CommonToken WoTri = new CommonToken ( JavadocTokenTypes . WS , " " ) ; FHTtd . addChild ( WoTri ) ; CommonToken TBgVL = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; FHTtd . addChild ( TBgVL ) ; CommonToken tNnPr = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; FHTtd . addChild ( tNnPr ) ; CommonToken veOAh = new CommonToken ( JavadocTokenTypes . CHAR , "x" ) ; FHTtd . addChild ( veOAh ) ; CommonToken TTqzU = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; FHTtd . addChild ( TTqzU ) ; GAVYr . addChild ( FHTtd ) ; CommonToken esJKC = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; GAVYr . addChild ( esJKC ) ; TextContext foSFm = new TextContext ( GAVYr , 0 ) ; CommonToken RkviD = new CommonToken ( JavadocTokenTypes . WS , " " ) ; foSFm . addChild ( RkviD ) ; GAVYr . addChild ( foSFm ) ; CommonToken ZdVEY = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; GAVYr . addChild ( ZdVEY ) ; return GAVYr ; } public static ParseTree treeLinkInlineTags ( ) { JavadocContext qUDSi = new JavadocContext ( null , 0 ) ; JavadocInlineTagContext qrmKv = new JavadocInlineTagContext ( qUDSi , 0 ) ; CommonToken nyjfF = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; qrmKv . addChild ( nyjfF ) ; CommonToken HXSDY = new CommonToken ( JavadocTokenTypes . LINK_LITERAL , "@link" ) ; qrmKv . addChild ( HXSDY ) ; CommonToken LbsbA = new CommonToken ( JavadocTokenTypes . WS , " " ) ; qrmKv . addChild ( LbsbA ) ; ReferenceContext qNvtx = new ReferenceContext ( qrmKv , 0 ) ; CommonToken cPKhb = new CommonToken ( JavadocTokenTypes . PACKAGE , "java.lang" ) ; qNvtx . addChild ( cPKhb ) ; CommonToken FXimU = new CommonToken ( JavadocTokenTypes . DOT , "." ) ; qNvtx . addChild ( FXimU ) ; CommonToken VmBeR = new CommonToken ( JavadocTokenTypes . CLASS , "Integer" ) ; qNvtx . addChild ( VmBeR ) ; CommonToken ZQmZl = new CommonToken ( JavadocTokenTypes . HASH , "#" ) ; qNvtx . addChild ( ZQmZl ) ; CommonToken LqBEr = new CommonToken ( JavadocTokenTypes . MEMBER , "valueOf" ) ; qNvtx . addChild ( LqBEr ) ; qrmKv . addChild ( qNvtx ) ; CommonToken AMFgL = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; qrmKv . addChild ( AMFgL ) ; qUDSi . addChild ( qrmKv ) ; CommonToken Soygb = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; qUDSi . addChild ( Soygb ) ; JavadocInlineTagContext TkOkF = new JavadocInlineTagContext ( qUDSi , 0 ) ; CommonToken PkzAI = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; TkOkF . addChild ( PkzAI ) ; CommonToken kFrQb = new CommonToken ( JavadocTokenTypes . LINK_LITERAL , "@link" ) ; TkOkF . addChild ( kFrQb ) ; CommonToken fVQnP = new CommonToken ( JavadocTokenTypes . WS , " " ) ; TkOkF . addChild ( fVQnP ) ; ReferenceContext Mwbat = new ReferenceContext ( TkOkF , 0 ) ; CommonToken oHQua = new CommonToken ( JavadocTokenTypes . PACKAGE , "java.lang" ) ; Mwbat . addChild ( oHQua ) ; CommonToken YvNhB = new CommonToken ( JavadocTokenTypes . DOT , "." ) ; Mwbat . addChild ( YvNhB ) ; CommonToken dsmbF = new CommonToken ( JavadocTokenTypes . CLASS , "Integer" ) ; Mwbat . addChild ( dsmbF ) ; CommonToken HZVQi = new CommonToken ( JavadocTokenTypes . HASH , "#" ) ; Mwbat . addChild ( HZVQi ) ; CommonToken FUOOd = new CommonToken ( JavadocTokenTypes . MEMBER , "valueOf" ) ; Mwbat . addChild ( FUOOd ) ; TkOkF . addChild ( Mwbat ) ; DescriptionContext WchCg = new DescriptionContext ( TkOkF , 0 ) ; TextContext fcThJ = new TextContext ( WchCg , 0 ) ; CommonToken aDhfF = new CommonToken ( JavadocTokenTypes . WS , " " ) ; fcThJ . addChild ( aDhfF ) ; CommonToken vdvFW = new CommonToken ( JavadocTokenTypes . CHAR , "v" ) ; fcThJ . addChild ( vdvFW ) ; CommonToken IHqck = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; fcThJ . addChild ( IHqck ) ; CommonToken xHjyx = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; fcThJ . addChild ( xHjyx ) ; CommonToken oKzoC = new CommonToken ( JavadocTokenTypes . CHAR , "u" ) ; fcThJ . addChild ( oKzoC ) ; CommonToken wnkTX = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; fcThJ . addChild ( wnkTX ) ; CommonToken WAjRZ = new CommonToken ( JavadocTokenTypes . CHAR , "O" ) ; fcThJ . addChild ( WAjRZ ) ; CommonToken mFsnr = new CommonToken ( JavadocTokenTypes . CHAR , "f" ) ; fcThJ . addChild ( mFsnr ) ; WchCg . addChild ( fcThJ ) ; TkOkF . addChild ( WchCg ) ; CommonToken vtWLP = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; TkOkF . addChild ( vtWLP ) ; qUDSi . addChild ( TkOkF ) ; CommonToken NyyJM = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; qUDSi . addChild ( NyyJM ) ; return qUDSi ; } public static ParseTree treeSeeReferenceWithFewNestedClasses ( ) { JavadocContext CzKVl = new JavadocContext ( null , 0 ) ; JavadocTagContext gokiA = new JavadocTagContext ( CzKVl , 0 ) ; CommonToken grzaZ = new CommonToken ( JavadocTokenTypes . SEE_LITERAL , "@see" ) ; gokiA . addChild ( grzaZ ) ; CommonToken DtaeI = new CommonToken ( JavadocTokenTypes . WS , " " ) ; gokiA . addChild ( DtaeI ) ; ReferenceContext vLDJC = new ReferenceContext ( gokiA , 0 ) ; CommonToken BkKRp = new CommonToken ( JavadocTokenTypes . PACKAGE , "java.lang" ) ; vLDJC . addChild ( BkKRp ) ; CommonToken yvOze = new CommonToken ( JavadocTokenTypes . DOT , "." ) ; vLDJC . addChild ( yvOze ) ; CommonToken ohJtl = new CommonToken ( JavadocTokenTypes . CLASS , "Integer" ) ; vLDJC . addChild ( ohJtl ) ; CommonToken hNAVA = new CommonToken ( JavadocTokenTypes . DOT , "." ) ; vLDJC . addChild ( hNAVA ) ; CommonToken jdqIJ = new CommonToken ( JavadocTokenTypes . CLASS , "Nested" ) ; vLDJC . addChild ( jdqIJ ) ; CommonToken vaNBW = new CommonToken ( JavadocTokenTypes . DOT , "." ) ; vLDJC . addChild ( vaNBW ) ; CommonToken PDCAI = new CommonToken ( JavadocTokenTypes . CLASS , "AnotherNested" ) ; vLDJC . addChild ( PDCAI ) ; CommonToken CagoX = new CommonToken ( JavadocTokenTypes . HASH , "#" ) ; vLDJC . addChild ( CagoX ) ; CommonToken WuYrh = new CommonToken ( JavadocTokenTypes . MEMBER , "someMethod" ) ; vLDJC . addChild ( WuYrh ) ; ParametersContext udWrc = new ParametersContext ( vLDJC , 0 ) ; CommonToken PJtRP = new CommonToken ( JavadocTokenTypes . LEFT_BRACE , "(" ) ; udWrc . addChild ( PJtRP ) ; CommonToken JwhMR = new CommonToken ( JavadocTokenTypes . ARGUMENT , "String" ) ; udWrc . addChild ( JwhMR ) ; CommonToken DaAVO = new CommonToken ( JavadocTokenTypes . COMMA , "," ) ; udWrc . addChild ( DaAVO ) ; CommonToken QvLje = new CommonToken ( JavadocTokenTypes . WS , " " ) ; udWrc . addChild ( QvLje ) ; CommonToken BZorC = new CommonToken ( JavadocTokenTypes . ARGUMENT , "int" ) ; udWrc . addChild ( BZorC ) ; CommonToken exiFE = new CommonToken ( JavadocTokenTypes . RIGHT_BRACE , ")" ) ; udWrc . addChild ( exiFE ) ; vLDJC . addChild ( udWrc ) ; gokiA . addChild ( vLDJC ) ; CommonToken ximEY = new CommonToken ( JavadocTokenTypes . WS , " " ) ; gokiA . addChild ( ximEY ) ; DescriptionContext SXOzr = new DescriptionContext ( gokiA , 0 ) ; TextContext BfJtl = new TextContext ( SXOzr , 0 ) ; CommonToken wmLGH = new CommonToken ( JavadocTokenTypes . CHAR , "D" ) ; BfJtl . addChild ( wmLGH ) ; CommonToken LINKE = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; BfJtl . addChild ( LINKE ) ; CommonToken DdOuv = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; BfJtl . addChild ( DdOuv ) ; CommonToken JDbnR = new CommonToken ( JavadocTokenTypes . CHAR , "c" ) ; BfJtl . addChild ( JDbnR ) ; CommonToken FVehl = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; BfJtl . addChild ( FVehl ) ; CommonToken GxRCH = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; BfJtl . addChild ( GxRCH ) ; CommonToken XtRVj = new CommonToken ( JavadocTokenTypes . CHAR , "p" ) ; BfJtl . addChild ( XtRVj ) ; CommonToken BCuFj = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; BfJtl . addChild ( BCuFj ) ; CommonToken oWHAD = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; BfJtl . addChild ( oWHAD ) ; CommonToken OnPFw = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; BfJtl . addChild ( OnPFw ) ; CommonToken MQjqh = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; BfJtl . addChild ( MQjqh ) ; CommonToken HzkOh = new CommonToken ( JavadocTokenTypes . WS , " " ) ; BfJtl . addChild ( HzkOh ) ; CommonToken ftfOv = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; BfJtl . addChild ( ftfOv ) ; CommonToken ieURc = new CommonToken ( JavadocTokenTypes . CHAR , "f" ) ; BfJtl . addChild ( ieURc ) ; CommonToken CXbGx = new CommonToken ( JavadocTokenTypes . WS , " " ) ; BfJtl . addChild ( CXbGx ) ; CommonToken lYpCr = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; BfJtl . addChild ( lYpCr ) ; CommonToken gWUOV = new CommonToken ( JavadocTokenTypes . CHAR , "h" ) ; BfJtl . addChild ( gWUOV ) ; CommonToken eXjmT = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; BfJtl . addChild ( eXjmT ) ; CommonToken ZQQin = new CommonToken ( JavadocTokenTypes . WS , " " ) ; BfJtl . addChild ( ZQQin ) ; CommonToken uGKkF = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; BfJtl . addChild ( uGKkF ) ; CommonToken gJoli = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; BfJtl . addChild ( gJoli ) ; CommonToken JGDoa = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; BfJtl . addChild ( JGDoa ) ; CommonToken qLyDc = new CommonToken ( JavadocTokenTypes . CHAR , "k" ) ; BfJtl . addChild ( qLyDc ) ; SXOzr . addChild ( BfJtl ) ; gokiA . addChild ( SXOzr ) ; CzKVl . addChild ( gokiA ) ; CommonToken gjaAk = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; CzKVl . addChild ( gjaAk ) ; return CzKVl ; } public static ParseTree treeParamWithGeneric ( ) { JavadocContext QPFRD = new JavadocContext ( null , 0 ) ; JavadocTagContext aGEJG = new JavadocTagContext ( QPFRD , 0 ) ; CommonToken KeLjt = new CommonToken ( JavadocTokenTypes . PARAM_LITERAL , "@param" ) ; aGEJG . addChild ( KeLjt ) ; CommonToken rOSWG = new CommonToken ( JavadocTokenTypes . WS , " " ) ; aGEJG . addChild ( rOSWG ) ; CommonToken lsjiD = new CommonToken ( JavadocTokenTypes . PARAMETER_NAME , "<E>" ) ; aGEJG . addChild ( lsjiD ) ; CommonToken NffOe = new CommonToken ( JavadocTokenTypes . WS , " " ) ; aGEJG . addChild ( NffOe ) ; DescriptionContext xpcWl = new DescriptionContext ( aGEJG , 0 ) ; TextContext YlCSA = new TextContext ( xpcWl , 0 ) ; CommonToken DrEbu = new CommonToken ( JavadocTokenTypes . CHAR , "m" ) ; YlCSA . addChild ( DrEbu ) ; CommonToken KZAJu = new CommonToken ( JavadocTokenTypes . CHAR , "y" ) ; YlCSA . addChild ( KZAJu ) ; CommonToken dwXkJ = new CommonToken ( JavadocTokenTypes . WS , " " ) ; YlCSA . addChild ( dwXkJ ) ; CommonToken bckfp = new CommonToken ( JavadocTokenTypes . CHAR , "f" ) ; YlCSA . addChild ( bckfp ) ; CommonToken kiXWZ = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; YlCSA . addChild ( kiXWZ ) ; CommonToken PfsCl = new CommonToken ( JavadocTokenTypes . CHAR , "v" ) ; YlCSA . addChild ( PfsCl ) ; CommonToken svxAz = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; YlCSA . addChild ( svxAz ) ; CommonToken kusoJ = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; YlCSA . addChild ( kusoJ ) ; CommonToken XhYWE = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; YlCSA . addChild ( XhYWE ) ; CommonToken KLVPT = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; YlCSA . addChild ( KLVPT ) ; CommonToken yDyzh = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; YlCSA . addChild ( yDyzh ) ; CommonToken Jcrop = new CommonToken ( JavadocTokenTypes . WS , " " ) ; YlCSA . addChild ( Jcrop ) ; CommonToken NwSnD = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; YlCSA . addChild ( NwSnD ) ; CommonToken WocUM = new CommonToken ( JavadocTokenTypes . CHAR , "y" ) ; YlCSA . addChild ( WocUM ) ; CommonToken pIlOU = new CommonToken ( JavadocTokenTypes . CHAR , "p" ) ; YlCSA . addChild ( pIlOU ) ; CommonToken DzOSR = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; YlCSA . addChild ( DzOSR ) ; xpcWl . addChild ( YlCSA ) ; aGEJG . addChild ( xpcWl ) ; QPFRD . addChild ( aGEJG ) ; CommonToken TBVcX = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; QPFRD . addChild ( TBVcX ) ; return QPFRD ; } public static ParseTree treeSerial ( ) { JavadocContext LvQLs = new JavadocContext ( null , 0 ) ; JavadocTagContext zgAMl = new JavadocTagContext ( LvQLs , 0 ) ; CommonToken dbPvj = new CommonToken ( JavadocTokenTypes . SERIAL_LITERAL , "@serial" ) ; zgAMl . addChild ( dbPvj ) ; CommonToken DRIij = new CommonToken ( JavadocTokenTypes . WS , " " ) ; zgAMl . addChild ( DRIij ) ; DescriptionContext uXKxL = new DescriptionContext ( zgAMl , 0 ) ; TextContext qPraT = new TextContext ( uXKxL , 0 ) ; CommonToken ZLilS = new CommonToken ( JavadocTokenTypes . CHAR , "f" ) ; qPraT . addChild ( ZLilS ) ; CommonToken OZlGT = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; qPraT . addChild ( OZlGT ) ; CommonToken LWDAH = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; qPraT . addChild ( LWDAH ) ; CommonToken nDCGv = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; qPraT . addChild ( nDCGv ) ; CommonToken hfOJi = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; qPraT . addChild ( hfOJi ) ; CommonToken utdDS = new CommonToken ( JavadocTokenTypes . WS , " " ) ; qPraT . addChild ( utdDS ) ; CommonToken MVYkh = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; qPraT . addChild ( MVYkh ) ; CommonToken vMwZL = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; qPraT . addChild ( vMwZL ) ; CommonToken SRiIb = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; qPraT . addChild ( SRiIb ) ; CommonToken yuoQZ = new CommonToken ( JavadocTokenTypes . CHAR , "c" ) ; qPraT . addChild ( yuoQZ ) ; CommonToken Zudaz = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; qPraT . addChild ( Zudaz ) ; CommonToken STXeh = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; qPraT . addChild ( STXeh ) ; CommonToken gmYRM = new CommonToken ( JavadocTokenTypes . CHAR , "p" ) ; qPraT . addChild ( gmYRM ) ; CommonToken xWdnG = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; qPraT . addChild ( xWdnG ) ; CommonToken hsYvL = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; qPraT . addChild ( hsYvL ) ; CommonToken sIfpi = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; qPraT . addChild ( sIfpi ) ; CommonToken WktVb = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; qPraT . addChild ( WktVb ) ; uXKxL . addChild ( qPraT ) ; CommonToken Uyspp = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; uXKxL . addChild ( Uyspp ) ; TextContext yifGB = new TextContext ( uXKxL , 0 ) ; CommonToken ULTcH = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; yifGB . addChild ( ULTcH ) ; CommonToken ZLgyj = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; yifGB . addChild ( ZLgyj ) ; CommonToken IoEIX = new CommonToken ( JavadocTokenTypes . WS , " " ) ; yifGB . addChild ( IoEIX ) ; CommonToken jVYKa = new CommonToken ( JavadocTokenTypes . CHAR , "f" ) ; yifGB . addChild ( jVYKa ) ; CommonToken dDbNJ = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; yifGB . addChild ( dDbNJ ) ; CommonToken HyjuJ = new CommonToken ( JavadocTokenTypes . CHAR , "w" ) ; yifGB . addChild ( HyjuJ ) ; CommonToken dndXf = new CommonToken ( JavadocTokenTypes . WS , " " ) ; yifGB . addChild ( dndXf ) ; CommonToken PRLDO = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; yifGB . addChild ( PRLDO ) ; CommonToken OfyTR = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; yifGB . addChild ( OfyTR ) ; CommonToken aCnSH = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; yifGB . addChild ( aCnSH ) ; CommonToken WQbTi = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; yifGB . addChild ( WQbTi ) ; CommonToken ggkUg = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; yifGB . addChild ( ggkUg ) ; uXKxL . addChild ( yifGB ) ; CommonToken HcLGZ = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; uXKxL . addChild ( HcLGZ ) ; TextContext wCPDd = new TextContext ( uXKxL , 0 ) ; CommonToken jlmsv = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; wCPDd . addChild ( jlmsv ) ; CommonToken VkHlF = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; wCPDd . addChild ( VkHlF ) ; CommonToken ZEixZ = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; wCPDd . addChild ( ZEixZ ) ; CommonToken htlfA = new CommonToken ( JavadocTokenTypes . WS , " " ) ; wCPDd . addChild ( htlfA ) ; CommonToken zEwmF = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; wCPDd . addChild ( zEwmF ) ; CommonToken xBxPL = new CommonToken ( JavadocTokenTypes . CHAR , "v" ) ; wCPDd . addChild ( xBxPL ) ; CommonToken NBmII = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; wCPDd . addChild ( NBmII ) ; CommonToken PDgHr = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; wCPDd . addChild ( PDgHr ) ; CommonToken DCHka = new CommonToken ( JavadocTokenTypes . WS , " " ) ; wCPDd . addChild ( DCHka ) ; CommonToken OZRlA = new CommonToken ( JavadocTokenTypes . CHAR , "h" ) ; wCPDd . addChild ( OZRlA ) ; CommonToken rnSjj = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; wCPDd . addChild ( rnSjj ) ; CommonToken ujRwV = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; wCPDd . addChild ( ujRwV ) ; CommonToken JidCa = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; wCPDd . addChild ( JidCa ) ; uXKxL . addChild ( wCPDd ) ; CommonToken HGXSo = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; uXKxL . addChild ( HGXSo ) ; zgAMl . addChild ( uXKxL ) ; LvQLs . addChild ( zgAMl ) ; JavadocTagContext UEpeG = new JavadocTagContext ( LvQLs , 0 ) ; CommonToken jRjUd = new CommonToken ( JavadocTokenTypes . SERIAL_LITERAL , "@serial" ) ; UEpeG . addChild ( jRjUd ) ; CommonToken MauPY = new CommonToken ( JavadocTokenTypes . WS , " " ) ; UEpeG . addChild ( MauPY ) ; CommonToken MCtfs = new CommonToken ( JavadocTokenTypes . LITERAL_INCLUDE , "include" ) ; UEpeG . addChild ( MCtfs ) ; DescriptionContext Xesvo = new DescriptionContext ( UEpeG , 0 ) ; CommonToken SAcJI = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; Xesvo . addChild ( SAcJI ) ; UEpeG . addChild ( Xesvo ) ; LvQLs . addChild ( UEpeG ) ; JavadocTagContext byhHa = new JavadocTagContext ( LvQLs , 0 ) ; CommonToken hRTgV = new CommonToken ( JavadocTokenTypes . SERIAL_LITERAL , "@serial" ) ; byhHa . addChild ( hRTgV ) ; CommonToken lsZTf = new CommonToken ( JavadocTokenTypes . WS , " " ) ; byhHa . addChild ( lsZTf ) ; CommonToken xmTtW = new CommonToken ( JavadocTokenTypes . LITERAL_EXCLUDE , "exclude" ) ; byhHa . addChild ( xmTtW ) ; DescriptionContext LozZq = new DescriptionContext ( byhHa , 0 ) ; CommonToken LsuSn = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; LozZq . addChild ( LsuSn ) ; byhHa . addChild ( LozZq ) ; LvQLs . addChild ( byhHa ) ; JavadocTagContext WkhrE = new JavadocTagContext ( LvQLs , 0 ) ; CommonToken mPZzA = new CommonToken ( JavadocTokenTypes . SERIAL_FIELD_LITERAL , "@serialField" ) ; WkhrE . addChild ( mPZzA ) ; CommonToken uvrEg = new CommonToken ( JavadocTokenTypes . WS , " " ) ; WkhrE . addChild ( uvrEg ) ; CommonToken aIkVx = new CommonToken ( JavadocTokenTypes . FIELD_NAME , "myField" ) ; WkhrE . addChild ( aIkVx ) ; CommonToken TuyMj = new CommonToken ( JavadocTokenTypes . WS , " " ) ; WkhrE . addChild ( TuyMj ) ; CommonToken EgsBp = new CommonToken ( JavadocTokenTypes . FIELD_TYPE , "myObjectStreamField" ) ; WkhrE . addChild ( EgsBp ) ; CommonToken NMYXM = new CommonToken ( JavadocTokenTypes . WS , " " ) ; WkhrE . addChild ( NMYXM ) ; DescriptionContext hhzpC = new DescriptionContext ( WkhrE , 0 ) ; TextContext zGdBL = new TextContext ( hhzpC , 0 ) ; CommonToken Gwjnn = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; zGdBL . addChild ( Gwjnn ) ; CommonToken FdTsQ = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; zGdBL . addChild ( FdTsQ ) ; CommonToken buZAu = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; zGdBL . addChild ( buZAu ) ; CommonToken vKnrL = new CommonToken ( JavadocTokenTypes . CHAR , "c" ) ; zGdBL . addChild ( vKnrL ) ; CommonToken iTgMV = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; zGdBL . addChild ( iTgMV ) ; CommonToken OetXa = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; zGdBL . addChild ( OetXa ) ; CommonToken bBVjn = new CommonToken ( JavadocTokenTypes . CHAR , "p" ) ; zGdBL . addChild ( bBVjn ) ; CommonToken lEPyw = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; zGdBL . addChild ( lEPyw ) ; CommonToken cxPZo = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; zGdBL . addChild ( cxPZo ) ; CommonToken mUgvS = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; zGdBL . addChild ( mUgvS ) ; CommonToken tZuSm = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; zGdBL . addChild ( tZuSm ) ; CommonToken CZjXB = new CommonToken ( JavadocTokenTypes . WS , " " ) ; zGdBL . addChild ( CZjXB ) ; CommonToken iatjx = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; zGdBL . addChild ( iatjx ) ; CommonToken qFzoz = new CommonToken ( JavadocTokenTypes . CHAR , "f" ) ; zGdBL . addChild ( qFzoz ) ; CommonToken SSyvy = new CommonToken ( JavadocTokenTypes . WS , " " ) ; zGdBL . addChild ( SSyvy ) ; CommonToken SCJTX = new CommonToken ( JavadocTokenTypes . CHAR , "m" ) ; zGdBL . addChild ( SCJTX ) ; CommonToken vnNEr = new CommonToken ( JavadocTokenTypes . CHAR , "y" ) ; zGdBL . addChild ( vnNEr ) ; CommonToken gRAfW = new CommonToken ( JavadocTokenTypes . WS , " " ) ; zGdBL . addChild ( gRAfW ) ; CommonToken BtaKP = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; zGdBL . addChild ( BtaKP ) ; CommonToken ICcPu = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; zGdBL . addChild ( ICcPu ) ; CommonToken EkuDz = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; zGdBL . addChild ( EkuDz ) ; CommonToken EbkiO = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; zGdBL . addChild ( EbkiO ) ; CommonToken xXCgE = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; zGdBL . addChild ( xXCgE ) ; CommonToken MyRqM = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; zGdBL . addChild ( MyRqM ) ; CommonToken EVAnU = new CommonToken ( JavadocTokenTypes . WS , " " ) ; zGdBL . addChild ( EVAnU ) ; CommonToken mirjt = new CommonToken ( JavadocTokenTypes . CHAR , "f" ) ; zGdBL . addChild ( mirjt ) ; CommonToken qrXUD = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; zGdBL . addChild ( qrXUD ) ; CommonToken NfURD = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; zGdBL . addChild ( NfURD ) ; CommonToken MqiBb = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; zGdBL . addChild ( MqiBb ) ; CommonToken DJVTC = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; zGdBL . addChild ( DJVTC ) ; hhzpC . addChild ( zGdBL ) ; CommonToken LAQNT = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; hhzpC . addChild ( LAQNT ) ; WkhrE . addChild ( hhzpC ) ; LvQLs . addChild ( WkhrE ) ; JavadocTagContext xRNrk = new JavadocTagContext ( LvQLs , 0 ) ; CommonToken SJUoL = new CommonToken ( JavadocTokenTypes . SERIAL_DATA_LITERAL , "@serialData" ) ; xRNrk . addChild ( SJUoL ) ; CommonToken DlWOc = new CommonToken ( JavadocTokenTypes . WS , " " ) ; xRNrk . addChild ( DlWOc ) ; DescriptionContext jqmSx = new DescriptionContext ( xRNrk , 0 ) ; TextContext PpvsC = new TextContext ( jqmSx , 0 ) ; CommonToken HeGrl = new CommonToken ( JavadocTokenTypes . CHAR , "T" ) ; PpvsC . addChild ( HeGrl ) ; CommonToken SYOSO = new CommonToken ( JavadocTokenTypes . CHAR , "h" ) ; PpvsC . addChild ( SYOSO ) ; CommonToken JyLUh = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; PpvsC . addChild ( JyLUh ) ; CommonToken aCiib = new CommonToken ( JavadocTokenTypes . WS , " " ) ; PpvsC . addChild ( aCiib ) ; CommonToken zgZVm = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; PpvsC . addChild ( zgZVm ) ; CommonToken WcmSt = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; PpvsC . addChild ( WcmSt ) ; CommonToken DpAmW = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; PpvsC . addChild ( DpAmW ) ; CommonToken ILDhQ = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; PpvsC . addChild ( ILDhQ ) ; CommonToken VBhyT = new CommonToken ( JavadocTokenTypes . CHAR , "-" ) ; PpvsC . addChild ( VBhyT ) ; CommonToken bwwxO = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; PpvsC . addChild ( bwwxO ) ; CommonToken CUCYe = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; PpvsC . addChild ( CUCYe ) ; CommonToken eLJfo = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; PpvsC . addChild ( eLJfo ) ; CommonToken LupgP = new CommonToken ( JavadocTokenTypes . CHAR , "c" ) ; PpvsC . addChild ( LupgP ) ; CommonToken sdfFv = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; PpvsC . addChild ( sdfFv ) ; CommonToken HkxXq = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; PpvsC . addChild ( HkxXq ) ; CommonToken jqFoE = new CommonToken ( JavadocTokenTypes . CHAR , "p" ) ; PpvsC . addChild ( jqFoE ) ; CommonToken jTwSJ = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; PpvsC . addChild ( jTwSJ ) ; CommonToken gfbAe = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; PpvsC . addChild ( gfbAe ) ; CommonToken pSoPO = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; PpvsC . addChild ( pSoPO ) ; CommonToken HYvXz = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; PpvsC . addChild ( HYvXz ) ; CommonToken OpEdq = new CommonToken ( JavadocTokenTypes . WS , " " ) ; PpvsC . addChild ( OpEdq ) ; CommonToken EpyRF = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; PpvsC . addChild ( EpyRF ) ; CommonToken KHnHf = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; PpvsC . addChild ( KHnHf ) ; CommonToken zRtDf = new CommonToken ( JavadocTokenTypes . CHAR , "c" ) ; PpvsC . addChild ( zRtDf ) ; CommonToken mHGvX = new CommonToken ( JavadocTokenTypes . CHAR , "u" ) ; PpvsC . addChild ( mHGvX ) ; CommonToken NjhfY = new CommonToken ( JavadocTokenTypes . CHAR , "m" ) ; PpvsC . addChild ( NjhfY ) ; CommonToken sJsAg = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; PpvsC . addChild ( sJsAg ) ; CommonToken jCkuJ = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; PpvsC . addChild ( jCkuJ ) ; CommonToken jboPH = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; PpvsC . addChild ( jboPH ) ; CommonToken qxKeT = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; PpvsC . addChild ( qxKeT ) ; jqmSx . addChild ( PpvsC ) ; xRNrk . addChild ( jqmSx ) ; LvQLs . addChild ( xRNrk ) ; CommonToken lJyJx = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; LvQLs . addChild ( lJyJx ) ; return LvQLs ; } public static ParseTree treeSince ( ) { JavadocContext KzwtL = new JavadocContext ( null , 0 ) ; CommonToken KBdjc = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , "*" ) ; KzwtL . addChild ( KBdjc ) ; CommonToken bumXm = new CommonToken ( JavadocTokenTypes . WS , " " ) ; KzwtL . addChild ( bumXm ) ; JavadocTagContext yxgFX = new JavadocTagContext ( KzwtL , 0 ) ; CommonToken YHnJx = new CommonToken ( JavadocTokenTypes . SINCE_LITERAL , "@since" ) ; yxgFX . addChild ( YHnJx ) ; CommonToken VnMhH = new CommonToken ( JavadocTokenTypes . WS , " " ) ; yxgFX . addChild ( VnMhH ) ; DescriptionContext hfUJs = new DescriptionContext ( yxgFX , 0 ) ; TextContext KDFKH = new TextContext ( hfUJs , 0 ) ; CommonToken HzQdJ = new CommonToken ( JavadocTokenTypes . CHAR , "1" ) ; KDFKH . addChild ( HzQdJ ) ; CommonToken dQvjG = new CommonToken ( JavadocTokenTypes . CHAR , "." ) ; KDFKH . addChild ( dQvjG ) ; CommonToken xEdyg = new CommonToken ( JavadocTokenTypes . CHAR , "5" ) ; KDFKH . addChild ( xEdyg ) ; hfUJs . addChild ( KDFKH ) ; CommonToken IXuHo = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; hfUJs . addChild ( IXuHo ) ; yxgFX . addChild ( hfUJs ) ; KzwtL . addChild ( yxgFX ) ; CommonToken PkBux = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; KzwtL . addChild ( PkBux ) ; CommonToken KpMIW = new CommonToken ( JavadocTokenTypes . WS , " " ) ; KzwtL . addChild ( KpMIW ) ; JavadocTagContext OcuEn = new JavadocTagContext ( KzwtL , 0 ) ; CommonToken SehKa = new CommonToken ( JavadocTokenTypes . SINCE_LITERAL , "@since" ) ; OcuEn . addChild ( SehKa ) ; CommonToken JURQC = new CommonToken ( JavadocTokenTypes . WS , " " ) ; OcuEn . addChild ( JURQC ) ; DescriptionContext NYzVK = new DescriptionContext ( OcuEn , 0 ) ; TextContext KYmTj = new TextContext ( NYzVK , 0 ) ; CommonToken XeINZ = new CommonToken ( JavadocTokenTypes . CHAR , "R" ) ; KYmTj . addChild ( XeINZ ) ; CommonToken yaphV = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; KYmTj . addChild ( yaphV ) ; CommonToken fWGhu = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; KYmTj . addChild ( fWGhu ) ; CommonToken kWDEz = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; KYmTj . addChild ( kWDEz ) ; CommonToken xrhZk = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; KYmTj . addChild ( xrhZk ) ; CommonToken rrnjf = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; KYmTj . addChild ( rrnjf ) ; CommonToken hMbVu = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; KYmTj . addChild ( hMbVu ) ; CommonToken WEbWM = new CommonToken ( JavadocTokenTypes . WS , " " ) ; KYmTj . addChild ( WEbWM ) ; CommonToken NFvZb = new CommonToken ( JavadocTokenTypes . CHAR , "3" ) ; KYmTj . addChild ( NFvZb ) ; CommonToken rWLUe = new CommonToken ( JavadocTokenTypes . CHAR , "." ) ; KYmTj . addChild ( rWLUe ) ; CommonToken sZzJq = new CommonToken ( JavadocTokenTypes . CHAR , "4" ) ; KYmTj . addChild ( sZzJq ) ; CommonToken fpHMf = new CommonToken ( JavadocTokenTypes . CHAR , "." ) ; KYmTj . addChild ( fpHMf ) ; CommonToken ukVDH = new CommonToken ( JavadocTokenTypes . CHAR , "5" ) ; KYmTj . addChild ( ukVDH ) ; NYzVK . addChild ( KYmTj ) ; OcuEn . addChild ( NYzVK ) ; KzwtL . addChild ( OcuEn ) ; CommonToken lWOPi = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; KzwtL . addChild ( lWOPi ) ; return KzwtL ; } public static ParseTree treeUnclosedAndClosedParagraphs ( ) { JavadocContext YgctO = new JavadocContext ( null , 0 ) ; HtmlElementContext uErtB = new HtmlElementContext ( YgctO , 0 ) ; PTagOpenContext GFcZu = new PTagOpenContext ( uErtB , 0 ) ; CommonToken sGJxY = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; GFcZu . addChild ( sGJxY ) ; CommonToken NucrT = new CommonToken ( JavadocTokenTypes . P_HTML_TAG_NAME , "p" ) ; GFcZu . addChild ( NucrT ) ; CommonToken RDdJM = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; GFcZu . addChild ( RDdJM ) ; uErtB . addChild ( GFcZu ) ; YgctO . addChild ( uErtB ) ; CommonToken FyXjz = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; YgctO . addChild ( FyXjz ) ; TextContext IeeMb = new TextContext ( YgctO , 0 ) ; CommonToken bNebr = new CommonToken ( JavadocTokenTypes . CHAR , "f" ) ; IeeMb . addChild ( bNebr ) ; CommonToken kmRZY = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; IeeMb . addChild ( kmRZY ) ; CommonToken lkBYc = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; IeeMb . addChild ( lkBYc ) ; CommonToken qNbrs = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; IeeMb . addChild ( qNbrs ) ; CommonToken ETzPx = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; IeeMb . addChild ( ETzPx ) ; CommonToken svoMq = new CommonToken ( JavadocTokenTypes . WS , " " ) ; IeeMb . addChild ( svoMq ) ; CommonToken rkEPh = new CommonToken ( JavadocTokenTypes . CHAR , "p" ) ; IeeMb . addChild ( rkEPh ) ; CommonToken osfyp = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; IeeMb . addChild ( osfyp ) ; CommonToken UMrJI = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; IeeMb . addChild ( UMrJI ) ; CommonToken hhJNH = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; IeeMb . addChild ( hhJNH ) ; CommonToken YDrVU = new CommonToken ( JavadocTokenTypes . CHAR , "g" ) ; IeeMb . addChild ( YDrVU ) ; CommonToken rpuIO = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; IeeMb . addChild ( rpuIO ) ; CommonToken svmqX = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; IeeMb . addChild ( svmqX ) ; CommonToken PAofj = new CommonToken ( JavadocTokenTypes . CHAR , "p" ) ; IeeMb . addChild ( PAofj ) ; CommonToken kskXI = new CommonToken ( JavadocTokenTypes . CHAR , "h" ) ; IeeMb . addChild ( kskXI ) ; YgctO . addChild ( IeeMb ) ; CommonToken BVeon = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; YgctO . addChild ( BVeon ) ; HtmlElementContext kpCbZ = new HtmlElementContext ( YgctO , 0 ) ; ParagraphContext Gcoxj = new ParagraphContext ( kpCbZ , 0 ) ; PTagOpenContext deNJt = new PTagOpenContext ( Gcoxj , 0 ) ; CommonToken yIMdO = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; deNJt . addChild ( yIMdO ) ; CommonToken iWEcF = new CommonToken ( JavadocTokenTypes . P_HTML_TAG_NAME , "p" ) ; deNJt . addChild ( iWEcF ) ; CommonToken UNDgj = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; deNJt . addChild ( UNDgj ) ; Gcoxj . addChild ( deNJt ) ; CommonToken UpOeJ = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; Gcoxj . addChild ( UpOeJ ) ; TextContext ehZXo = new TextContext ( Gcoxj , 0 ) ; CommonToken SGFxd = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; ehZXo . addChild ( SGFxd ) ; CommonToken fJXkB = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; ehZXo . addChild ( fJXkB ) ; CommonToken NWrMe = new CommonToken ( JavadocTokenTypes . CHAR , "c" ) ; ehZXo . addChild ( NWrMe ) ; CommonToken jGsrk = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; ehZXo . addChild ( jGsrk ) ; CommonToken wtvmu = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; ehZXo . addChild ( wtvmu ) ; CommonToken BAmnp = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; ehZXo . addChild ( BAmnp ) ; CommonToken QXpdx = new CommonToken ( JavadocTokenTypes . WS , " " ) ; ehZXo . addChild ( QXpdx ) ; CommonToken vfSMJ = new CommonToken ( JavadocTokenTypes . CHAR , "p" ) ; ehZXo . addChild ( vfSMJ ) ; CommonToken CrmdJ = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; ehZXo . addChild ( CrmdJ ) ; CommonToken vtWes = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; ehZXo . addChild ( vtWes ) ; CommonToken bvVyo = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; ehZXo . addChild ( bvVyo ) ; CommonToken LanAa = new CommonToken ( JavadocTokenTypes . CHAR , "g" ) ; ehZXo . addChild ( LanAa ) ; CommonToken HYbDb = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; ehZXo . addChild ( HYbDb ) ; CommonToken JvwBo = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; ehZXo . addChild ( JvwBo ) ; CommonToken lbfyR = new CommonToken ( JavadocTokenTypes . CHAR , "p" ) ; ehZXo . addChild ( lbfyR ) ; CommonToken vKKaB = new CommonToken ( JavadocTokenTypes . CHAR , "h" ) ; ehZXo . addChild ( vKKaB ) ; Gcoxj . addChild ( ehZXo ) ; CommonToken qmqSq = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; Gcoxj . addChild ( qmqSq ) ; PTagCloseContext fOGBD = new PTagCloseContext ( Gcoxj , 0 ) ; CommonToken uXPjS = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; fOGBD . addChild ( uXPjS ) ; CommonToken ljvet = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; fOGBD . addChild ( ljvet ) ; CommonToken JbBQX = new CommonToken ( JavadocTokenTypes . P_HTML_TAG_NAME , "p" ) ; fOGBD . addChild ( JbBQX ) ; CommonToken gOMRW = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; fOGBD . addChild ( gOMRW ) ; Gcoxj . addChild ( fOGBD ) ; kpCbZ . addChild ( Gcoxj ) ; YgctO . addChild ( kpCbZ ) ; CommonToken bSvLk = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; YgctO . addChild ( bSvLk ) ; return YgctO ; } public static ParseTree treeListWithUnclosedItemInUnclosedParagraph ( ) { JavadocContext cQkWm = new JavadocContext ( null , 0 ) ; HtmlElementContext xNsDD = new HtmlElementContext ( cQkWm , 0 ) ; PTagOpenContext BqpVW = new PTagOpenContext ( xNsDD , 0 ) ; CommonToken FkBWc = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; BqpVW . addChild ( FkBWc ) ; CommonToken pGbVS = new CommonToken ( JavadocTokenTypes . P_HTML_TAG_NAME , "p" ) ; BqpVW . addChild ( pGbVS ) ; CommonToken iCTxl = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; BqpVW . addChild ( iCTxl ) ; xNsDD . addChild ( BqpVW ) ; cQkWm . addChild ( xNsDD ) ; CommonToken ifvNd = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; cQkWm . addChild ( ifvNd ) ; HtmlElementContext Dwasm = new HtmlElementContext ( cQkWm , 0 ) ; HtmlTagContext zKmgq = new HtmlTagContext ( Dwasm , 0 ) ; HtmlElementOpenContext UJmda = new HtmlElementOpenContext ( zKmgq , 0 ) ; CommonToken qAeVG = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; UJmda . addChild ( qAeVG ) ; CommonToken xwJDa = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "ul" ) ; UJmda . addChild ( xwJDa ) ; CommonToken bCakN = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; UJmda . addChild ( bCakN ) ; zKmgq . addChild ( UJmda ) ; CommonToken PbiAM = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; zKmgq . addChild ( PbiAM ) ; TextContext puddm = new TextContext ( zKmgq , 0 ) ; CommonToken YwCWd = new CommonToken ( JavadocTokenTypes . WS , "\t" ) ; puddm . addChild ( YwCWd ) ; zKmgq . addChild ( puddm ) ; HtmlElementContext SPdzM = new HtmlElementContext ( zKmgq , 0 ) ; LiTagOpenContext WFeMQ = new LiTagOpenContext ( SPdzM , 0 ) ; CommonToken NHBGq = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; WFeMQ . addChild ( NHBGq ) ; CommonToken ZIRFJ = new CommonToken ( JavadocTokenTypes . LI_HTML_TAG_NAME , "li" ) ; WFeMQ . addChild ( ZIRFJ ) ; CommonToken eeonI = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; WFeMQ . addChild ( eeonI ) ; SPdzM . addChild ( WFeMQ ) ; zKmgq . addChild ( SPdzM ) ; TextContext dMWLw = new TextContext ( zKmgq , 0 ) ; CommonToken UJcMj = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; dMWLw . addChild ( UJcMj ) ; CommonToken CBBTp = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; dMWLw . addChild ( CBBTp ) ; CommonToken MMQaK = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; dMWLw . addChild ( MMQaK ) ; CommonToken ItkBE = new CommonToken ( JavadocTokenTypes . CHAR , "m" ) ; dMWLw . addChild ( ItkBE ) ; CommonToken utBdQ = new CommonToken ( JavadocTokenTypes . WS , " " ) ; dMWLw . addChild ( utBdQ ) ; CommonToken OOEjD = new CommonToken ( JavadocTokenTypes . CHAR , "1" ) ; dMWLw . addChild ( OOEjD ) ; zKmgq . addChild ( dMWLw ) ; CommonToken lWorP = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; zKmgq . addChild ( lWorP ) ; TextContext jDxVf = new TextContext ( zKmgq , 0 ) ; CommonToken PnoKJ = new CommonToken ( JavadocTokenTypes . WS , "\t" ) ; jDxVf . addChild ( PnoKJ ) ; zKmgq . addChild ( jDxVf ) ; HtmlElementContext wjQOv = new HtmlElementContext ( zKmgq , 0 ) ; LiContext pjUbB = new LiContext ( wjQOv , 0 ) ; LiTagOpenContext UnLuf = new LiTagOpenContext ( pjUbB , 0 ) ; CommonToken DXhyD = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; UnLuf . addChild ( DXhyD ) ; CommonToken iaVCp = new CommonToken ( JavadocTokenTypes . LI_HTML_TAG_NAME , "li" ) ; UnLuf . addChild ( iaVCp ) ; CommonToken OPKTS = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; UnLuf . addChild ( OPKTS ) ; pjUbB . addChild ( UnLuf ) ; TextContext OdjuX = new TextContext ( pjUbB , 0 ) ; CommonToken AUIXJ = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; OdjuX . addChild ( AUIXJ ) ; CommonToken iKVgk = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; OdjuX . addChild ( iKVgk ) ; CommonToken xfYtg = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; OdjuX . addChild ( xfYtg ) ; CommonToken qrNcC = new CommonToken ( JavadocTokenTypes . CHAR , "m" ) ; OdjuX . addChild ( qrNcC ) ; CommonToken jyIKm = new CommonToken ( JavadocTokenTypes . WS , " " ) ; OdjuX . addChild ( jyIKm ) ; CommonToken GWlXZ = new CommonToken ( JavadocTokenTypes . CHAR , "2" ) ; OdjuX . addChild ( GWlXZ ) ; pjUbB . addChild ( OdjuX ) ; LiTagCloseContext tawdc = new LiTagCloseContext ( pjUbB , 0 ) ; CommonToken JMpwx = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; tawdc . addChild ( JMpwx ) ; CommonToken FnJCw = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; tawdc . addChild ( FnJCw ) ; CommonToken zYYWy = new CommonToken ( JavadocTokenTypes . LI_HTML_TAG_NAME , "li" ) ; tawdc . addChild ( zYYWy ) ; CommonToken GYple = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; tawdc . addChild ( GYple ) ; pjUbB . addChild ( tawdc ) ; wjQOv . addChild ( pjUbB ) ; zKmgq . addChild ( wjQOv ) ; CommonToken WyYHG = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; zKmgq . addChild ( WyYHG ) ; HtmlElementCloseContext sXgAY = new HtmlElementCloseContext ( zKmgq , 0 ) ; CommonToken VcTUH = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; sXgAY . addChild ( VcTUH ) ; CommonToken TOttT = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; sXgAY . addChild ( TOttT ) ; CommonToken gpiJj = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "ul" ) ; sXgAY . addChild ( gpiJj ) ; CommonToken Glqvw = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; sXgAY . addChild ( Glqvw ) ; zKmgq . addChild ( sXgAY ) ; Dwasm . addChild ( zKmgq ) ; cQkWm . addChild ( Dwasm ) ; CommonToken BDwlx = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; cQkWm . addChild ( BDwlx ) ; return cQkWm ; } public static ParseTree treeUnclosedParagraphFollowedByJavadocTag ( ) { JavadocContext toAar = new JavadocContext ( null , 0 ) ; HtmlElementContext FmXNr = new HtmlElementContext ( toAar , 0 ) ; PTagOpenContext ryFvE = new PTagOpenContext ( FmXNr , 0 ) ; CommonToken HdDOX = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; ryFvE . addChild ( HdDOX ) ; CommonToken nYJUI = new CommonToken ( JavadocTokenTypes . P_HTML_TAG_NAME , "p" ) ; ryFvE . addChild ( nYJUI ) ; CommonToken KDRaQ = new CommonToken ( JavadocTokenTypes . WS , " " ) ; ryFvE . addChild ( KDRaQ ) ; AttributeContext gTKLk = new AttributeContext ( ryFvE , 0 ) ; CommonToken cqEmn = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "style" ) ; gTKLk . addChild ( cqEmn ) ; CommonToken ltvVB = new CommonToken ( JavadocTokenTypes . EQUALS , "=" ) ; gTKLk . addChild ( ltvVB ) ; CommonToken VMpFN = new CommonToken ( JavadocTokenTypes . ATTR_VALUE , "\"color: red;\"" ) ; gTKLk . addChild ( VMpFN ) ; ryFvE . addChild ( gTKLk ) ; CommonToken DqXAR = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; ryFvE . addChild ( DqXAR ) ; FmXNr . addChild ( ryFvE ) ; toAar . addChild ( FmXNr ) ; CommonToken gDtSy = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; toAar . addChild ( gDtSy ) ; TextContext AUKAx = new TextContext ( toAar , 0 ) ; CommonToken yvWdA = new CommonToken ( JavadocTokenTypes . WS , "\t" ) ; AUKAx . addChild ( yvWdA ) ; CommonToken OYedt = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; AUKAx . addChild ( OYedt ) ; CommonToken JzDTB = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; AUKAx . addChild ( JzDTB ) ; CommonToken oDIJN = new CommonToken ( JavadocTokenTypes . CHAR , "x" ) ; AUKAx . addChild ( oDIJN ) ; CommonToken Rqlbw = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; AUKAx . addChild ( Rqlbw ) ; CommonToken tCDRR = new CommonToken ( JavadocTokenTypes . WS , " " ) ; AUKAx . addChild ( tCDRR ) ; CommonToken pffyu = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; AUKAx . addChild ( pffyu ) ; CommonToken NYaCv = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; AUKAx . addChild ( NYaCv ) ; CommonToken hqUjd = new CommonToken ( JavadocTokenTypes . CHAR , "x" ) ; AUKAx . addChild ( hqUjd ) ; CommonToken KRkis = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; AUKAx . addChild ( KRkis ) ; toAar . addChild ( AUKAx ) ; CommonToken HqAee = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; toAar . addChild ( HqAee ) ; JavadocTagContext XFxtS = new JavadocTagContext ( toAar , 0 ) ; CommonToken yXsKP = new CommonToken ( JavadocTokenTypes . AUTHOR_LITERAL , "@author" ) ; XFxtS . addChild ( yXsKP ) ; CommonToken RmrHi = new CommonToken ( JavadocTokenTypes . WS , " " ) ; XFxtS . addChild ( RmrHi ) ; DescriptionContext SAUHr = new DescriptionContext ( XFxtS , 0 ) ; TextContext mKYlo = new TextContext ( SAUHr , 0 ) ; CommonToken zoqVb = new CommonToken ( JavadocTokenTypes . CHAR , "B" ) ; mKYlo . addChild ( zoqVb ) ; CommonToken qltjj = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; mKYlo . addChild ( qltjj ) ; CommonToken FtRxi = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; mKYlo . addChild ( FtRxi ) ; CommonToken IJzqI = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; mKYlo . addChild ( IJzqI ) ; CommonToken FcrDM = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; mKYlo . addChild ( FcrDM ) ; CommonToken QNyou = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; mKYlo . addChild ( QNyou ) ; CommonToken qasHc = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; mKYlo . addChild ( qasHc ) ; CommonToken acnQH = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; mKYlo . addChild ( acnQH ) ; SAUHr . addChild ( mKYlo ) ; XFxtS . addChild ( SAUHr ) ; toAar . addChild ( XFxtS ) ; CommonToken tONCM = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; toAar . addChild ( tONCM ) ; return toAar ; } public static ParseTree treeAllJavadocInlineTags ( ) { JavadocContext XCFCp = new JavadocContext ( null , 0 ) ; JavadocInlineTagContext vvMvz = new JavadocInlineTagContext ( XCFCp , 0 ) ; CommonToken tyjLa = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; vvMvz . addChild ( tyjLa ) ; CommonToken KRltG = new CommonToken ( JavadocTokenTypes . CODE_LITERAL , "@code" ) ; vvMvz . addChild ( KRltG ) ; CommonToken FGHtI = new CommonToken ( JavadocTokenTypes . WS , " " ) ; vvMvz . addChild ( FGHtI ) ; TextContext yGTsf = new TextContext ( vvMvz , 0 ) ; CommonToken jnFVB = new CommonToken ( JavadocTokenTypes . CHAR , "<" ) ; yGTsf . addChild ( jnFVB ) ; CommonToken JJqPx = new CommonToken ( JavadocTokenTypes . CHAR , "c" ) ; yGTsf . addChild ( JJqPx ) ; CommonToken GVmVW = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; yGTsf . addChild ( GVmVW ) ; CommonToken rqpRz = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; yGTsf . addChild ( rqpRz ) ; CommonToken qWwRJ = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; yGTsf . addChild ( qWwRJ ) ; CommonToken miwjG = new CommonToken ( JavadocTokenTypes . CHAR , ">" ) ; yGTsf . addChild ( miwjG ) ; vvMvz . addChild ( yGTsf ) ; CommonToken MBkdQ = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; vvMvz . addChild ( MBkdQ ) ; XCFCp . addChild ( vvMvz ) ; TextContext foQHe = new TextContext ( XCFCp , 0 ) ; CommonToken kCgcb = new CommonToken ( JavadocTokenTypes . WS , " " ) ; foQHe . addChild ( kCgcb ) ; XCFCp . addChild ( foQHe ) ; JavadocInlineTagContext FyBGO = new JavadocInlineTagContext ( XCFCp , 0 ) ; CommonToken lfXcG = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; FyBGO . addChild ( lfXcG ) ; CommonToken LOsYk = new CommonToken ( JavadocTokenTypes . LITERAL_LITERAL , "@literal" ) ; FyBGO . addChild ( LOsYk ) ; CommonToken vfZxY = new CommonToken ( JavadocTokenTypes . WS , " " ) ; FyBGO . addChild ( vfZxY ) ; TextContext iQXrF = new TextContext ( FyBGO , 0 ) ; CommonToken iWwOe = new CommonToken ( JavadocTokenTypes . CHAR , "<" ) ; iQXrF . addChild ( iWwOe ) ; CommonToken LJzjh = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; iQXrF . addChild ( LJzjh ) ; CommonToken NldLf = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; iQXrF . addChild ( NldLf ) ; CommonToken lFviM = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; iQXrF . addChild ( lFviM ) ; CommonToken xJWOR = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; iQXrF . addChild ( xJWOR ) ; CommonToken Adfst = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; iQXrF . addChild ( Adfst ) ; CommonToken zFutg = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; iQXrF . addChild ( zFutg ) ; CommonToken crGkI = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; iQXrF . addChild ( crGkI ) ; CommonToken FAHoz = new CommonToken ( JavadocTokenTypes . CHAR , ">" ) ; iQXrF . addChild ( FAHoz ) ; FyBGO . addChild ( iQXrF ) ; CommonToken LGgQr = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; FyBGO . addChild ( LGgQr ) ; XCFCp . addChild ( FyBGO ) ; TextContext HBepk = new TextContext ( XCFCp , 0 ) ; CommonToken lXwuG = new CommonToken ( JavadocTokenTypes . WS , " " ) ; HBepk . addChild ( lXwuG ) ; XCFCp . addChild ( HBepk ) ; JavadocInlineTagContext BpaCl = new JavadocInlineTagContext ( XCFCp , 0 ) ; CommonToken Sgsns = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; BpaCl . addChild ( Sgsns ) ; CommonToken JvJig = new CommonToken ( JavadocTokenTypes . DOC_ROOT_LITERAL , "@docRoot" ) ; BpaCl . addChild ( JvJig ) ; CommonToken mWdmB = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; BpaCl . addChild ( mWdmB ) ; XCFCp . addChild ( BpaCl ) ; TextContext qcEFG = new TextContext ( XCFCp , 0 ) ; CommonToken EdLPJ = new CommonToken ( JavadocTokenTypes . WS , " " ) ; qcEFG . addChild ( EdLPJ ) ; XCFCp . addChild ( qcEFG ) ; JavadocInlineTagContext NnMRn = new JavadocInlineTagContext ( XCFCp , 0 ) ; CommonToken NfGZi = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; NnMRn . addChild ( NfGZi ) ; CommonToken WQTCA = new CommonToken ( JavadocTokenTypes . INHERIT_DOC_LITERAL , "@inheritDoc" ) ; NnMRn . addChild ( WQTCA ) ; CommonToken gMbXT = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; NnMRn . addChild ( gMbXT ) ; XCFCp . addChild ( NnMRn ) ; TextContext xsdSg = new TextContext ( XCFCp , 0 ) ; CommonToken AuLBM = new CommonToken ( JavadocTokenTypes . WS , " " ) ; xsdSg . addChild ( AuLBM ) ; XCFCp . addChild ( xsdSg ) ; JavadocInlineTagContext uDaZc = new JavadocInlineTagContext ( XCFCp , 0 ) ; CommonToken mFELI = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; uDaZc . addChild ( mFELI ) ; CommonToken XNwqz = new CommonToken ( JavadocTokenTypes . LINK_LITERAL , "@link" ) ; uDaZc . addChild ( XNwqz ) ; CommonToken qqVCG = new CommonToken ( JavadocTokenTypes . WS , " " ) ; uDaZc . addChild ( qqVCG ) ; ReferenceContext cnPBx = new ReferenceContext ( uDaZc , 0 ) ; CommonToken bkuIn = new CommonToken ( JavadocTokenTypes . CLASS , "A" ) ; cnPBx . addChild ( bkuIn ) ; uDaZc . addChild ( cnPBx ) ; DescriptionContext Nwwzw = new DescriptionContext ( uDaZc , 0 ) ; TextContext aoYeF = new TextContext ( Nwwzw , 0 ) ; CommonToken BbcMv = new CommonToken ( JavadocTokenTypes . WS , " " ) ; aoYeF . addChild ( BbcMv ) ; CommonToken wvBIr = new CommonToken ( JavadocTokenTypes . CHAR , "A" ) ; aoYeF . addChild ( wvBIr ) ; CommonToken bIaEN = new CommonToken ( JavadocTokenTypes . WS , " " ) ; aoYeF . addChild ( bIaEN ) ; CommonToken WihsX = new CommonToken ( JavadocTokenTypes . CHAR , "c" ) ; aoYeF . addChild ( WihsX ) ; CommonToken CYnHa = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; aoYeF . addChild ( CYnHa ) ; CommonToken mReSU = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; aoYeF . addChild ( mReSU ) ; CommonToken ZpHCT = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; aoYeF . addChild ( ZpHCT ) ; CommonToken gRXzZ = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; aoYeF . addChild ( gRXzZ ) ; Nwwzw . addChild ( aoYeF ) ; uDaZc . addChild ( Nwwzw ) ; CommonToken pjqJa = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; uDaZc . addChild ( pjqJa ) ; XCFCp . addChild ( uDaZc ) ; TextContext YNADS = new TextContext ( XCFCp , 0 ) ; CommonToken IputF = new CommonToken ( JavadocTokenTypes . WS , " " ) ; YNADS . addChild ( IputF ) ; XCFCp . addChild ( YNADS ) ; JavadocInlineTagContext eAcRt = new JavadocInlineTagContext ( XCFCp , 0 ) ; CommonToken iEPsH = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; eAcRt . addChild ( iEPsH ) ; CommonToken PcAvQ = new CommonToken ( JavadocTokenTypes . LINKPLAIN_LITERAL , "@linkplain" ) ; eAcRt . addChild ( PcAvQ ) ; CommonToken IMvdy = new CommonToken ( JavadocTokenTypes . WS , " " ) ; eAcRt . addChild ( IMvdy ) ; ReferenceContext fqHhC = new ReferenceContext ( eAcRt , 0 ) ; CommonToken qYmAk = new CommonToken ( JavadocTokenTypes . CLASS , "A" ) ; fqHhC . addChild ( qYmAk ) ; eAcRt . addChild ( fqHhC ) ; DescriptionContext brtoS = new DescriptionContext ( eAcRt , 0 ) ; TextContext dGiZw = new TextContext ( brtoS , 0 ) ; CommonToken AbrxL = new CommonToken ( JavadocTokenTypes . WS , " " ) ; dGiZw . addChild ( AbrxL ) ; CommonToken WDSsS = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; dGiZw . addChild ( WDSsS ) ; CommonToken tPLRW = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; dGiZw . addChild ( tPLRW ) ; CommonToken cvRSk = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; dGiZw . addChild ( cvRSk ) ; CommonToken AbPnu = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; dGiZw . addChild ( AbPnu ) ; CommonToken WOWlF = new CommonToken ( JavadocTokenTypes . CHAR , "h" ) ; dGiZw . addChild ( WOWlF ) ; CommonToken SYLiT = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; dGiZw . addChild ( SYLiT ) ; CommonToken AtRDz = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; dGiZw . addChild ( AtRDz ) ; CommonToken mmKkp = new CommonToken ( JavadocTokenTypes . WS , " " ) ; dGiZw . addChild ( mmKkp ) ; CommonToken ygfxc = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; dGiZw . addChild ( ygfxc ) ; CommonToken bJzTl = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; dGiZw . addChild ( bJzTl ) ; CommonToken LhWRW = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; dGiZw . addChild ( LhWRW ) ; CommonToken bmeId = new CommonToken ( JavadocTokenTypes . CHAR , "k" ) ; dGiZw . addChild ( bmeId ) ; brtoS . addChild ( dGiZw ) ; eAcRt . addChild ( brtoS ) ; CommonToken fRkUC = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; eAcRt . addChild ( fRkUC ) ; XCFCp . addChild ( eAcRt ) ; TextContext cNtKT = new TextContext ( XCFCp , 0 ) ; CommonToken gGmoz = new CommonToken ( JavadocTokenTypes . WS , " " ) ; cNtKT . addChild ( gGmoz ) ; XCFCp . addChild ( cNtKT ) ; JavadocInlineTagContext DcRUm = new JavadocInlineTagContext ( XCFCp , 0 ) ; CommonToken kCjvD = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; DcRUm . addChild ( kCjvD ) ; CommonToken HUUCy = new CommonToken ( JavadocTokenTypes . VALUE_LITERAL , "@value" ) ; DcRUm . addChild ( HUUCy ) ; CommonToken dixxI = new CommonToken ( JavadocTokenTypes . WS , " " ) ; DcRUm . addChild ( dixxI ) ; ReferenceContext NDRFQ = new ReferenceContext ( DcRUm , 0 ) ; CommonToken ULKmS = new CommonToken ( JavadocTokenTypes . PACKAGE , "lang" ) ; NDRFQ . addChild ( ULKmS ) ; CommonToken BLKoL = new CommonToken ( JavadocTokenTypes . DOT , "." ) ; NDRFQ . addChild ( BLKoL ) ; CommonToken uAzxT = new CommonToken ( JavadocTokenTypes . CLASS , "Integer" ) ; NDRFQ . addChild ( uAzxT ) ; CommonToken chhNN = new CommonToken ( JavadocTokenTypes . HASH , "#" ) ; NDRFQ . addChild ( chhNN ) ; CommonToken WQzYZ = new CommonToken ( JavadocTokenTypes . MEMBER , "MAX_VALUE" ) ; NDRFQ . addChild ( WQzYZ ) ; DcRUm . addChild ( NDRFQ ) ; CommonToken emAFs = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; DcRUm . addChild ( emAFs ) ; XCFCp . addChild ( DcRUm ) ; CommonToken zqHMX = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; XCFCp . addChild ( zqHMX ) ; return XCFCp ; } public static ParseTree treeDocRootInheritDoc ( ) { JavadocContext CAWJW = new JavadocContext ( null , 0 ) ; CommonToken yedSF = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; CAWJW . addChild ( yedSF ) ; CommonToken HyKaf = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; CAWJW . addChild ( HyKaf ) ; TextContext WCKlI = new TextContext ( CAWJW , 0 ) ; CommonToken UujlQ = new CommonToken ( JavadocTokenTypes . WS , " " ) ; WCKlI . addChild ( UujlQ ) ; CAWJW . addChild ( WCKlI ) ; JavadocInlineTagContext ebZsC = new JavadocInlineTagContext ( CAWJW , 0 ) ; CommonToken gdFio = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; ebZsC . addChild ( gdFio ) ; CommonToken IhYHt = new CommonToken ( JavadocTokenTypes . DOC_ROOT_LITERAL , "@docRoot" ) ; ebZsC . addChild ( IhYHt ) ; CommonToken AJgDf = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; ebZsC . addChild ( AJgDf ) ; CAWJW . addChild ( ebZsC ) ; CommonToken gsDNo = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; CAWJW . addChild ( gsDNo ) ; CommonToken ygMhD = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; CAWJW . addChild ( ygMhD ) ; TextContext eqDaT = new TextContext ( CAWJW , 0 ) ; CommonToken VmFHe = new CommonToken ( JavadocTokenTypes . WS , " " ) ; eqDaT . addChild ( VmFHe ) ; CAWJW . addChild ( eqDaT ) ; JavadocInlineTagContext NDzGJ = new JavadocInlineTagContext ( CAWJW , 0 ) ; CommonToken arrQW = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; NDzGJ . addChild ( arrQW ) ; CommonToken oaYWJ = new CommonToken ( JavadocTokenTypes . DOC_ROOT_LITERAL , "@docRoot" ) ; NDzGJ . addChild ( oaYWJ ) ; CommonToken jKhIo = new CommonToken ( JavadocTokenTypes . WS , " " ) ; NDzGJ . addChild ( jKhIo ) ; CommonToken dGiJA = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; NDzGJ . addChild ( dGiJA ) ; CAWJW . addChild ( NDzGJ ) ; CommonToken ddkKe = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; CAWJW . addChild ( ddkKe ) ; CommonToken TQjjV = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; CAWJW . addChild ( TQjjV ) ; TextContext UQHgC = new TextContext ( CAWJW , 0 ) ; CommonToken PwuNM = new CommonToken ( JavadocTokenTypes . WS , " " ) ; UQHgC . addChild ( PwuNM ) ; CAWJW . addChild ( UQHgC ) ; JavadocInlineTagContext gwexf = new JavadocInlineTagContext ( CAWJW , 0 ) ; CommonToken bpYBO = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; gwexf . addChild ( bpYBO ) ; CommonToken cvvJR = new CommonToken ( JavadocTokenTypes . DOC_ROOT_LITERAL , "@docRoot" ) ; gwexf . addChild ( cvvJR ) ; CommonToken qLnrF = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; gwexf . addChild ( qLnrF ) ; CommonToken zoQlm = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; gwexf . addChild ( zoQlm ) ; CommonToken rvDVd = new CommonToken ( JavadocTokenTypes . WS , " " ) ; gwexf . addChild ( rvDVd ) ; CommonToken gPoTc = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; gwexf . addChild ( gPoTc ) ; CAWJW . addChild ( gwexf ) ; CommonToken BhBNy = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; CAWJW . addChild ( BhBNy ) ; CommonToken yayju = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; CAWJW . addChild ( yayju ) ; TextContext mPEov = new TextContext ( CAWJW , 0 ) ; CommonToken wCOca = new CommonToken ( JavadocTokenTypes . WS , " " ) ; mPEov . addChild ( wCOca ) ; CAWJW . addChild ( mPEov ) ; JavadocInlineTagContext sNwft = new JavadocInlineTagContext ( CAWJW , 0 ) ; CommonToken jAmAp = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; sNwft . addChild ( jAmAp ) ; CommonToken tKJbI = new CommonToken ( JavadocTokenTypes . INHERIT_DOC_LITERAL , "@inheritDoc" ) ; sNwft . addChild ( tKJbI ) ; CommonToken WtIyH = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; sNwft . addChild ( WtIyH ) ; CAWJW . addChild ( sNwft ) ; CommonToken qUwTF = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; CAWJW . addChild ( qUwTF ) ; CommonToken bewgL = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; CAWJW . addChild ( bewgL ) ; TextContext BMFSS = new TextContext ( CAWJW , 0 ) ; CommonToken IiXZA = new CommonToken ( JavadocTokenTypes . WS , " " ) ; BMFSS . addChild ( IiXZA ) ; CAWJW . addChild ( BMFSS ) ; JavadocInlineTagContext sQPCX = new JavadocInlineTagContext ( CAWJW , 0 ) ; CommonToken rdCpq = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; sQPCX . addChild ( rdCpq ) ; CommonToken jHPxn = new CommonToken ( JavadocTokenTypes . INHERIT_DOC_LITERAL , "@inheritDoc" ) ; sQPCX . addChild ( jHPxn ) ; CommonToken tHuBm = new CommonToken ( JavadocTokenTypes . WS , " " ) ; sQPCX . addChild ( tHuBm ) ; CommonToken XpuUV = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; sQPCX . addChild ( XpuUV ) ; CAWJW . addChild ( sQPCX ) ; CommonToken NQibo = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; CAWJW . addChild ( NQibo ) ; CommonToken aicIl = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; CAWJW . addChild ( aicIl ) ; TextContext vJtDV = new TextContext ( CAWJW , 0 ) ; CommonToken JqMgW = new CommonToken ( JavadocTokenTypes . WS , " " ) ; vJtDV . addChild ( JqMgW ) ; CAWJW . addChild ( vJtDV ) ; JavadocInlineTagContext rpBUl = new JavadocInlineTagContext ( CAWJW , 0 ) ; CommonToken EAMJR = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; rpBUl . addChild ( EAMJR ) ; CommonToken oRHfO = new CommonToken ( JavadocTokenTypes . INHERIT_DOC_LITERAL , "@inheritDoc" ) ; rpBUl . addChild ( oRHfO ) ; CommonToken yRNLA = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; rpBUl . addChild ( yRNLA ) ; CommonToken jDlgz = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; rpBUl . addChild ( jDlgz ) ; CommonToken SNisJ = new CommonToken ( JavadocTokenTypes . WS , " " ) ; rpBUl . addChild ( SNisJ ) ; CommonToken wtLbm = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; rpBUl . addChild ( wtLbm ) ; CAWJW . addChild ( rpBUl ) ; CommonToken cBiEm = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; CAWJW . addChild ( cBiEm ) ; TextContext JvFEl = new TextContext ( CAWJW , 0 ) ; CommonToken zZnAN = new CommonToken ( JavadocTokenTypes . WS , " " ) ; JvFEl . addChild ( zZnAN ) ; CAWJW . addChild ( JvFEl ) ; CommonToken qNjgf = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; CAWJW . addChild ( qNjgf ) ; return CAWJW ; } public static ParseTree treeFewWhiteSpacesAsSeparator ( ) { JavadocContext zKyCD = new JavadocContext ( null , 0 ) ; CommonToken WeoVx = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; zKyCD . addChild ( WeoVx ) ; CommonToken QteMJ = new CommonToken ( JavadocTokenTypes . WS , " " ) ; zKyCD . addChild ( QteMJ ) ; JavadocTagContext phPgN = new JavadocTagContext ( zKyCD , 0 ) ; CommonToken wYBWS = new CommonToken ( JavadocTokenTypes . PARAM_LITERAL , "@param" ) ; phPgN . addChild ( wYBWS ) ; CommonToken iETjL = new CommonToken ( JavadocTokenTypes . WS , " " ) ; phPgN . addChild ( iETjL ) ; CommonToken jGVhZ = new CommonToken ( JavadocTokenTypes . PARAMETER_NAME , "initialCapacity" ) ; phPgN . addChild ( jGVhZ ) ; CommonToken cynpc = new CommonToken ( JavadocTokenTypes . WS , " " ) ; phPgN . addChild ( cynpc ) ; DescriptionContext kNtol = new DescriptionContext ( phPgN , 0 ) ; TextContext zjtGu = new TextContext ( kNtol , 0 ) ; CommonToken wUQJx = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; zjtGu . addChild ( wUQJx ) ; CommonToken RPclX = new CommonToken ( JavadocTokenTypes . CHAR , "h" ) ; zjtGu . addChild ( RPclX ) ; CommonToken JGrRW = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; zjtGu . addChild ( JGrRW ) ; CommonToken pYSMU = new CommonToken ( JavadocTokenTypes . WS , " " ) ; zjtGu . addChild ( pYSMU ) ; CommonToken nGslU = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; zjtGu . addChild ( nGslU ) ; CommonToken qzSja = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; zjtGu . addChild ( qzSja ) ; CommonToken vJKCZ = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; zjtGu . addChild ( vJKCZ ) ; CommonToken zQFvS = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; zjtGu . addChild ( zQFvS ) ; CommonToken mHDMH = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; zjtGu . addChild ( mHDMH ) ; CommonToken ZJFWk = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; zjtGu . addChild ( ZJFWk ) ; CommonToken qRgTv = new CommonToken ( JavadocTokenTypes . CHAR , "l" ) ; zjtGu . addChild ( qRgTv ) ; CommonToken lfDIk = new CommonToken ( JavadocTokenTypes . WS , " " ) ; zjtGu . addChild ( lfDIk ) ; CommonToken ltHHj = new CommonToken ( JavadocTokenTypes . CHAR , "c" ) ; zjtGu . addChild ( ltHHj ) ; CommonToken SfvKC = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; zjtGu . addChild ( SfvKC ) ; CommonToken wzveD = new CommonToken ( JavadocTokenTypes . CHAR , "p" ) ; zjtGu . addChild ( wzveD ) ; CommonToken zUCyE = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; zjtGu . addChild ( zUCyE ) ; CommonToken rloQS = new CommonToken ( JavadocTokenTypes . CHAR , "c" ) ; zjtGu . addChild ( rloQS ) ; CommonToken MuTvI = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; zjtGu . addChild ( MuTvI ) ; CommonToken fewur = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; zjtGu . addChild ( fewur ) ; CommonToken igxlx = new CommonToken ( JavadocTokenTypes . CHAR , "y" ) ; zjtGu . addChild ( igxlx ) ; CommonToken beBno = new CommonToken ( JavadocTokenTypes . WS , " " ) ; zjtGu . addChild ( beBno ) ; CommonToken avZOW = new CommonToken ( JavadocTokenTypes . CHAR , "o" ) ; zjtGu . addChild ( avZOW ) ; CommonToken XUQGy = new CommonToken ( JavadocTokenTypes . CHAR , "f" ) ; zjtGu . addChild ( XUQGy ) ; CommonToken BSIkL = new CommonToken ( JavadocTokenTypes . WS , " " ) ; zjtGu . addChild ( BSIkL ) ; CommonToken wIFNM = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; zjtGu . addChild ( wIFNM ) ; CommonToken wJSuh = new CommonToken ( JavadocTokenTypes . CHAR , "h" ) ; zjtGu . addChild ( wJSuh ) ; CommonToken KUQLO = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; zjtGu . addChild ( KUQLO ) ; CommonToken ElRYS = new CommonToken ( JavadocTokenTypes . WS , " " ) ; zjtGu . addChild ( ElRYS ) ; CommonToken gUTyH = new CommonToken ( JavadocTokenTypes . CHAR , "B" ) ; zjtGu . addChild ( gUTyH ) ; CommonToken xCkwE = new CommonToken ( JavadocTokenTypes . CHAR , "y" ) ; zjtGu . addChild ( xCkwE ) ; CommonToken qzUYG = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; zjtGu . addChild ( qzUYG ) ; CommonToken UGNjY = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; zjtGu . addChild ( UGNjY ) ; CommonToken QgUhb = new CommonToken ( JavadocTokenTypes . CHAR , "B" ) ; zjtGu . addChild ( QgUhb ) ; CommonToken RVnZl = new CommonToken ( JavadocTokenTypes . CHAR , "u" ) ; zjtGu . addChild ( RVnZl ) ; CommonToken yXxEO = new CommonToken ( JavadocTokenTypes . CHAR , "f" ) ; zjtGu . addChild ( yXxEO ) ; CommonToken LuMth = new CommonToken ( JavadocTokenTypes . CHAR , "f" ) ; zjtGu . addChild ( LuMth ) ; CommonToken kYaOA = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; zjtGu . addChild ( kYaOA ) ; CommonToken DIeTP = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; zjtGu . addChild ( DIeTP ) ; CommonToken WJHrR = new CommonToken ( JavadocTokenTypes . CHAR , "." ) ; zjtGu . addChild ( WJHrR ) ; kNtol . addChild ( zjtGu ) ; phPgN . addChild ( kNtol ) ; zKyCD . addChild ( phPgN ) ; CommonToken JrVuu = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; zKyCD . addChild ( JrVuu ) ; return zKyCD ; } public static ParseTree treeMixedCaseOfHtmlTags ( ) { JavadocContext iWKZR = new JavadocContext ( null , 0 ) ; HtmlElementContext fcyyo = new HtmlElementContext ( iWKZR , 0 ) ; PTagOpenContext UKnca = new PTagOpenContext ( fcyyo , 0 ) ; CommonToken XAMcR = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; UKnca . addChild ( XAMcR ) ; CommonToken xrTlP = new CommonToken ( JavadocTokenTypes . P_HTML_TAG_NAME , "P" ) ; UKnca . addChild ( xrTlP ) ; CommonToken zyyyF = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; UKnca . addChild ( zyyyF ) ; fcyyo . addChild ( UKnca ) ; iWKZR . addChild ( fcyyo ) ; CommonToken OmCfP = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; iWKZR . addChild ( OmCfP ) ; HtmlElementContext aVnVE = new HtmlElementContext ( iWKZR , 0 ) ; SingletonElementContext COIii = new SingletonElementContext ( aVnVE , 0 ) ; BrTagContext pwdAu = new BrTagContext ( COIii , 0 ) ; CommonToken jmHHr = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; pwdAu . addChild ( jmHHr ) ; CommonToken jfwgB = new CommonToken ( JavadocTokenTypes . BR_HTML_TAG_NAME , "br" ) ; pwdAu . addChild ( jfwgB ) ; CommonToken RcwAS = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; pwdAu . addChild ( RcwAS ) ; COIii . addChild ( pwdAu ) ; aVnVE . addChild ( COIii ) ; iWKZR . addChild ( aVnVE ) ; CommonToken gMBGa = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; iWKZR . addChild ( gMBGa ) ; HtmlElementContext vRfGV = new HtmlElementContext ( iWKZR , 0 ) ; SingletonElementContext qGQrO = new SingletonElementContext ( vRfGV , 0 ) ; BrTagContext KiLID = new BrTagContext ( qGQrO , 0 ) ; CommonToken nXCGP = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; KiLID . addChild ( nXCGP ) ; CommonToken WYgcd = new CommonToken ( JavadocTokenTypes . BR_HTML_TAG_NAME , "br" ) ; KiLID . addChild ( WYgcd ) ; CommonToken hSevb = new CommonToken ( JavadocTokenTypes . SLASH_CLOSE , "/>" ) ; KiLID . addChild ( hSevb ) ; qGQrO . addChild ( KiLID ) ; vRfGV . addChild ( qGQrO ) ; iWKZR . addChild ( vRfGV ) ; CommonToken rUaNb = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; iWKZR . addChild ( rUaNb ) ; HtmlElementContext vJpux = new HtmlElementContext ( iWKZR , 0 ) ; SingletonElementContext ONaVf = new SingletonElementContext ( vJpux , 0 ) ; BrTagContext eIkvB = new BrTagContext ( ONaVf , 0 ) ; CommonToken nziuT = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; eIkvB . addChild ( nziuT ) ; CommonToken PTbiF = new CommonToken ( JavadocTokenTypes . BR_HTML_TAG_NAME , "BR" ) ; eIkvB . addChild ( PTbiF ) ; CommonToken ALhtL = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; eIkvB . addChild ( ALhtL ) ; ONaVf . addChild ( eIkvB ) ; vJpux . addChild ( ONaVf ) ; iWKZR . addChild ( vJpux ) ; CommonToken XTOYg = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; iWKZR . addChild ( XTOYg ) ; HtmlElementContext ZYoHu = new HtmlElementContext ( iWKZR , 0 ) ; SingletonElementContext ftheU = new SingletonElementContext ( ZYoHu , 0 ) ; BrTagContext Jwgnv = new BrTagContext ( ftheU , 0 ) ; CommonToken iXKFh = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; Jwgnv . addChild ( iXKFh ) ; CommonToken TKFsU = new CommonToken ( JavadocTokenTypes . BR_HTML_TAG_NAME , "BR" ) ; Jwgnv . addChild ( TKFsU ) ; CommonToken rPsaG = new CommonToken ( JavadocTokenTypes . SLASH_CLOSE , "/>" ) ; Jwgnv . addChild ( rPsaG ) ; ftheU . addChild ( Jwgnv ) ; ZYoHu . addChild ( ftheU ) ; iWKZR . addChild ( ZYoHu ) ; CommonToken zxDCq = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; iWKZR . addChild ( zxDCq ) ; HtmlElementContext MJUQw = new HtmlElementContext ( iWKZR , 0 ) ; HtmlTagContext CDWDd = new HtmlTagContext ( MJUQw , 0 ) ; HtmlElementOpenContext mjIHv = new HtmlElementOpenContext ( CDWDd , 0 ) ; CommonToken fJdVi = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; mjIHv . addChild ( fJdVi ) ; CommonToken AsDEE = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "TABLE" ) ; mjIHv . addChild ( AsDEE ) ; CommonToken zGfzL = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; mjIHv . addChild ( zGfzL ) ; CDWDd . addChild ( mjIHv ) ; CommonToken sHICO = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; CDWDd . addChild ( sHICO ) ; TextContext Apukr = new TextContext ( CDWDd , 0 ) ; CommonToken UbyVP = new CommonToken ( JavadocTokenTypes . WS , "\t" ) ; Apukr . addChild ( UbyVP ) ; CDWDd . addChild ( Apukr ) ; HtmlElementContext skMou = new HtmlElementContext ( CDWDd , 0 ) ; TrContext xEPjY = new TrContext ( skMou , 0 ) ; TrTagOpenContext vXsny = new TrTagOpenContext ( xEPjY , 0 ) ; CommonToken IUMkk = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; vXsny . addChild ( IUMkk ) ; CommonToken tTVAD = new CommonToken ( JavadocTokenTypes . TR_HTML_TAG_NAME , "tr" ) ; vXsny . addChild ( tTVAD ) ; CommonToken gFXXE = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; vXsny . addChild ( gFXXE ) ; xEPjY . addChild ( vXsny ) ; TrTagCloseContext bGFGg = new TrTagCloseContext ( xEPjY , 0 ) ; CommonToken GJxfQ = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; bGFGg . addChild ( GJxfQ ) ; CommonToken ZsVqW = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; bGFGg . addChild ( ZsVqW ) ; CommonToken UOZJv = new CommonToken ( JavadocTokenTypes . TR_HTML_TAG_NAME , "TR" ) ; bGFGg . addChild ( UOZJv ) ; CommonToken PaVuy = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; bGFGg . addChild ( PaVuy ) ; xEPjY . addChild ( bGFGg ) ; skMou . addChild ( xEPjY ) ; CDWDd . addChild ( skMou ) ; CommonToken WwOSH = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; CDWDd . addChild ( WwOSH ) ; TextContext lxufe = new TextContext ( CDWDd , 0 ) ; CommonToken zVXtI = new CommonToken ( JavadocTokenTypes . WS , "\t" ) ; lxufe . addChild ( zVXtI ) ; CDWDd . addChild ( lxufe ) ; HtmlElementContext KHArY = new HtmlElementContext ( CDWDd , 0 ) ; TrContext vUNkt = new TrContext ( KHArY , 0 ) ; TrTagOpenContext NLtsg = new TrTagOpenContext ( vUNkt , 0 ) ; CommonToken mJQNR = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; NLtsg . addChild ( mJQNR ) ; CommonToken mYTax = new CommonToken ( JavadocTokenTypes . TR_HTML_TAG_NAME , "TR" ) ; NLtsg . addChild ( mYTax ) ; CommonToken iCjrM = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; NLtsg . addChild ( iCjrM ) ; vUNkt . addChild ( NLtsg ) ; TrTagCloseContext tNsiD = new TrTagCloseContext ( vUNkt , 0 ) ; CommonToken bDRHE = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; tNsiD . addChild ( bDRHE ) ; CommonToken ioVxv = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; tNsiD . addChild ( ioVxv ) ; CommonToken YMIDT = new CommonToken ( JavadocTokenTypes . TR_HTML_TAG_NAME , "tr" ) ; tNsiD . addChild ( YMIDT ) ; CommonToken LjVWd = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; tNsiD . addChild ( LjVWd ) ; vUNkt . addChild ( tNsiD ) ; KHArY . addChild ( vUNkt ) ; CDWDd . addChild ( KHArY ) ; CommonToken RISaK = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; CDWDd . addChild ( RISaK ) ; HtmlElementCloseContext mqaGZ = new HtmlElementCloseContext ( CDWDd , 0 ) ; CommonToken SqSNI = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; mqaGZ . addChild ( SqSNI ) ; CommonToken GJDIc = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; mqaGZ . addChild ( GJDIc ) ; CommonToken bDitP = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "table" ) ; mqaGZ . addChild ( bDitP ) ; CommonToken uldXk = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; mqaGZ . addChild ( uldXk ) ; CDWDd . addChild ( mqaGZ ) ; MJUQw . addChild ( CDWDd ) ; iWKZR . addChild ( MJUQw ) ; CommonToken WTQzF = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; iWKZR . addChild ( WTQzF ) ; HtmlElementContext YhgCO = new HtmlElementContext ( iWKZR , 0 ) ; PTagCloseContext METvc = new PTagCloseContext ( YhgCO , 0 ) ; CommonToken CeBJB = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; METvc . addChild ( CeBJB ) ; CommonToken tmkjM = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; METvc . addChild ( tmkjM ) ; CommonToken BPLVF = new CommonToken ( JavadocTokenTypes . P_HTML_TAG_NAME , "p" ) ; METvc . addChild ( BPLVF ) ; CommonToken PcolG = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; METvc . addChild ( PcolG ) ; YhgCO . addChild ( METvc ) ; iWKZR . addChild ( YhgCO ) ; CommonToken iclNb = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; iWKZR . addChild ( iclNb ) ; return iWKZR ; } public static ParseTree treeComments ( ) { JavadocContext kbtaA = new JavadocContext ( null , 0 ) ; CommonToken Tiacl = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; kbtaA . addChild ( Tiacl ) ; TextContext bBREf = new TextContext ( kbtaA , 0 ) ; CommonToken SsCzG = new CommonToken ( JavadocTokenTypes . WS , " " ) ; bBREf . addChild ( SsCzG ) ; CommonToken WVwTr = new CommonToken ( JavadocTokenTypes . CHAR , "U" ) ; bBREf . addChild ( WVwTr ) ; CommonToken JPJOo = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; bBREf . addChild ( JPJOo ) ; CommonToken EdUnY = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; bBREf . addChild ( EdUnY ) ; CommonToken Qlkhf = new CommonToken ( JavadocTokenTypes . WS , " " ) ; bBREf . addChild ( Qlkhf ) ; kbtaA . addChild ( bBREf ) ; HtmlCommentContext LCIXU = new HtmlCommentContext ( kbtaA , 0 ) ; CommonToken lSOjO = new CommonToken ( JavadocTokenTypes . HTML_COMMENT_START , "<!--" ) ; LCIXU . addChild ( lSOjO ) ; TextContext kCboV = new TextContext ( LCIXU , 0 ) ; CommonToken phgvJ = new CommonToken ( JavadocTokenTypes . WS , " " ) ; kCboV . addChild ( phgvJ ) ; CommonToken ijFZy = new CommonToken ( JavadocTokenTypes . CHAR , "s" ) ; kCboV . addChild ( ijFZy ) ; CommonToken SvgWX = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; kCboV . addChild ( SvgWX ) ; CommonToken khSeV = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; kCboV . addChild ( khSeV ) ; CommonToken HpdsX = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; kCboV . addChild ( HpdsX ) ; CommonToken byUpo = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; kCboV . addChild ( byUpo ) ; CommonToken ejrVd = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; kCboV . addChild ( ejrVd ) ; CommonToken SACAY = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; kCboV . addChild ( SACAY ) ; CommonToken vhRxs = new CommonToken ( JavadocTokenTypes . CHAR , "d" ) ; kCboV . addChild ( vhRxs ) ; LCIXU . addChild ( kCboV ) ; CommonToken dIidq = new CommonToken ( JavadocTokenTypes . NEWLINE , LINE_SEPARATOR ) ; LCIXU . addChild ( dIidq ) ; CommonToken Pnmfd = new CommonToken ( JavadocTokenTypes . LEADING_ASTERISK , " *" ) ; LCIXU . addChild ( Pnmfd ) ; TextContext ruWbh = new TextContext ( LCIXU , 0 ) ; CommonToken bPeNs = new CommonToken ( JavadocTokenTypes . WS , " " ) ; ruWbh . addChild ( bPeNs ) ; CommonToken ejJDn = new CommonToken ( JavadocTokenTypes . CHAR , "j" ) ; ruWbh . addChild ( ejJDn ) ; CommonToken XNwPC = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; ruWbh . addChild ( XNwPC ) ; CommonToken DLtbb = new CommonToken ( JavadocTokenTypes . CHAR , "v" ) ; ruWbh . addChild ( DLtbb ) ; CommonToken ucCCq = new CommonToken ( JavadocTokenTypes . CHAR , "a" ) ; ruWbh . addChild ( ucCCq ) ; CommonToken vwoBx = new CommonToken ( JavadocTokenTypes . WS , " " ) ; ruWbh . addChild ( vwoBx ) ; CommonToken fqkbz = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; ruWbh . addChild ( fqkbz ) ; CommonToken tDnUV = new CommonToken ( JavadocTokenTypes . CHAR , "y" ) ; ruWbh . addChild ( tDnUV ) ; CommonToken zTKNB = new CommonToken ( JavadocTokenTypes . CHAR , "p" ) ; ruWbh . addChild ( zTKNB ) ; CommonToken LEzJL = new CommonToken ( JavadocTokenTypes . CHAR , "e" ) ; ruWbh . addChild ( LEzJL ) ; CommonToken KWDwS = new CommonToken ( JavadocTokenTypes . WS , " " ) ; ruWbh . addChild ( KWDwS ) ; LCIXU . addChild ( ruWbh ) ; CommonToken LTByZ = new CommonToken ( JavadocTokenTypes . HTML_COMMENT_END , "-->" ) ; LCIXU . addChild ( LTByZ ) ; kbtaA . addChild ( LCIXU ) ; TextContext glSuR = new TextContext ( kbtaA , 0 ) ; CommonToken QgXTG = new CommonToken ( JavadocTokenTypes . WS , " " ) ; glSuR . addChild ( QgXTG ) ; kbtaA . addChild ( glSuR ) ; HtmlElementContext oRcel = new HtmlElementContext ( kbtaA , 0 ) ; HtmlTagContext UhfHH = new HtmlTagContext ( oRcel , 0 ) ; HtmlElementOpenContext DedYq = new HtmlElementOpenContext ( UhfHH , 0 ) ; CommonToken rhJNK = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; DedYq . addChild ( rhJNK ) ; CommonToken lpWPM = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "b" ) ; DedYq . addChild ( lpWPM ) ; CommonToken eUuDS = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; DedYq . addChild ( eUuDS ) ; UhfHH . addChild ( DedYq ) ; TextContext HiteM = new TextContext ( UhfHH , 0 ) ; CommonToken SJbtR = new CommonToken ( JavadocTokenTypes . CHAR , "S" ) ; HiteM . addChild ( SJbtR ) ; CommonToken PnWOY = new CommonToken ( JavadocTokenTypes . CHAR , "t" ) ; HiteM . addChild ( PnWOY ) ; CommonToken QflON = new CommonToken ( JavadocTokenTypes . CHAR , "r" ) ; HiteM . addChild ( QflON ) ; CommonToken MRxLQ = new CommonToken ( JavadocTokenTypes . CHAR , "i" ) ; HiteM . addChild ( MRxLQ ) ; CommonToken zXygz = new CommonToken ( JavadocTokenTypes . CHAR , "n" ) ; HiteM . addChild ( zXygz ) ; CommonToken weOIq = new CommonToken ( JavadocTokenTypes . CHAR , "g" ) ; HiteM . addChild ( weOIq ) ; UhfHH . addChild ( HiteM ) ; HtmlElementCloseContext rNLDy = new HtmlElementCloseContext ( UhfHH , 0 ) ; CommonToken tkpfX = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; rNLDy . addChild ( tkpfX ) ; CommonToken rKfgq = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; rNLDy . addChild ( rKfgq ) ; CommonToken OKZCw = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "b" ) ; rNLDy . addChild ( OKZCw ) ; CommonToken bZkaD = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; rNLDy . addChild ( bZkaD ) ; UhfHH . addChild ( rNLDy ) ; oRcel . addChild ( UhfHH ) ; kbtaA . addChild ( oRcel ) ; CommonToken jHAfX = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; kbtaA . addChild ( jHAfX ) ; return kbtaA ; } public static ParseTree treeNegativeNumberInAttribute ( ) { JavadocContext vfDcF = new JavadocContext ( null , 0 ) ; HtmlElementContext wKROF = new HtmlElementContext ( vfDcF , 0 ) ; HtmlTagContext EYqee = new HtmlTagContext ( wKROF , 0 ) ; HtmlElementOpenContext aSmSu = new HtmlElementOpenContext ( EYqee , 0 ) ; CommonToken xNCtb = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; aSmSu . addChild ( xNCtb ) ; CommonToken imaPh = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "font" ) ; aSmSu . addChild ( imaPh ) ; CommonToken ogMrA = new CommonToken ( JavadocTokenTypes . WS , " " ) ; aSmSu . addChild ( ogMrA ) ; AttributeContext KmAMH = new AttributeContext ( aSmSu , 0 ) ; CommonToken KJHXR = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "size" ) ; KmAMH . addChild ( KJHXR ) ; CommonToken DdHka = new CommonToken ( JavadocTokenTypes . EQUALS , "=" ) ; KmAMH . addChild ( DdHka ) ; CommonToken VZrDv = new CommonToken ( JavadocTokenTypes . ATTR_VALUE , "-2" ) ; KmAMH . addChild ( VZrDv ) ; aSmSu . addChild ( KmAMH ) ; CommonToken SfwJg = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; aSmSu . addChild ( SfwJg ) ; EYqee . addChild ( aSmSu ) ; TextContext CVQte = new TextContext ( EYqee , 0 ) ; CommonToken aNhAy = new CommonToken ( JavadocTokenTypes . CHAR , "T" ) ; CVQte . addChild ( aNhAy ) ; CommonToken PMnir = new CommonToken ( JavadocTokenTypes . CHAR , "M" ) ; CVQte . addChild ( PMnir ) ; EYqee . addChild ( CVQte ) ; HtmlElementCloseContext TaBhY = new HtmlElementCloseContext ( EYqee , 0 ) ; CommonToken FPzZT = new CommonToken ( JavadocTokenTypes . OPEN , "<" ) ; TaBhY . addChild ( FPzZT ) ; CommonToken UGqrj = new CommonToken ( JavadocTokenTypes . SLASH , "/" ) ; TaBhY . addChild ( UGqrj ) ; CommonToken TnwEH = new CommonToken ( JavadocTokenTypes . HTML_TAG_NAME , "font" ) ; TaBhY . addChild ( TnwEH ) ; CommonToken naGPO = new CommonToken ( JavadocTokenTypes . CLOSE , ">" ) ; TaBhY . addChild ( naGPO ) ; EYqee . addChild ( TaBhY ) ; wKROF . addChild ( EYqee ) ; vfDcF . addChild ( wKROF ) ; CommonToken rrjXS = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; vfDcF . addChild ( rrjXS ) ; return vfDcF ; } public static ParseTree treeDollarInLink ( ) { JavadocContext yCrNh = new JavadocContext ( null , 0 ) ; JavadocInlineTagContext yZEPk = new JavadocInlineTagContext ( yCrNh , 0 ) ; CommonToken QaRFV = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_START , "{" ) ; yZEPk . addChild ( QaRFV ) ; CommonToken LnzvV = new CommonToken ( JavadocTokenTypes . LINK_LITERAL , "@link" ) ; yZEPk . addChild ( LnzvV ) ; CommonToken WcdhT = new CommonToken ( JavadocTokenTypes . WS , " " ) ; yZEPk . addChild ( WcdhT ) ; ReferenceContext yPHKq = new ReferenceContext ( yZEPk , 0 ) ; CommonToken tfKuW = new CommonToken ( JavadocTokenTypes . CLASS , "My$Class" ) ; yPHKq . addChild ( tfKuW ) ; CommonToken asCBP = new CommonToken ( JavadocTokenTypes . HASH , "#" ) ; yPHKq . addChild ( asCBP ) ; CommonToken VfpBA = new CommonToken ( JavadocTokenTypes . MEMBER , "$$simple_$Method" ) ; yPHKq . addChild ( VfpBA ) ; ParametersContext zUjHC = new ParametersContext ( yPHKq , 0 ) ; CommonToken evbHg = new CommonToken ( JavadocTokenTypes . LEFT_BRACE , "(" ) ; zUjHC . addChild ( evbHg ) ; CommonToken mpzxn = new CommonToken ( JavadocTokenTypes . ARGUMENT , "_A78" ) ; zUjHC . addChild ( mpzxn ) ; CommonToken kOOdW = new CommonToken ( JavadocTokenTypes . COMMA , "," ) ; zUjHC . addChild ( kOOdW ) ; CommonToken LvnuO = new CommonToken ( JavadocTokenTypes . WS , " " ) ; zUjHC . addChild ( LvnuO ) ; CommonToken IScAu = new CommonToken ( JavadocTokenTypes . ARGUMENT , "$8$" ) ; zUjHC . addChild ( IScAu ) ; CommonToken aULsN = new CommonToken ( JavadocTokenTypes . RIGHT_BRACE , ")" ) ; zUjHC . addChild ( aULsN ) ; yPHKq . addChild ( zUjHC ) ; yZEPk . addChild ( yPHKq ) ; CommonToken DCMuM = new CommonToken ( JavadocTokenTypes . JAVADOC_INLINE_TAG_END , "}" ) ; yZEPk . addChild ( DCMuM ) ; yCrNh . addChild ( yZEPk ) ; CommonToken AcQbE = new CommonToken ( JavadocTokenTypes . EOF , "<EOF>" ) ; yCrNh . addChild ( AcQbE ) ; return yCrNh ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . Scope ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocVariableCheck . JAVADOC_MISSING ; public class JavadocVariableCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocVariableCheck . class ) ; final String [ ] expected = { "11:5: " + getCheckMessage ( JAVADOC_MISSING ) , "304:5: " + getCheckMessage ( JAVADOC_MISSING ) , "311:5: " + getCheckMessage ( JAVADOC_MISSING ) , "330:5: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "checks/javadoc/InputTags.java" ) , expected ) ; } @ Test public void testAnother ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocVariableCheck . class ) ; final String [ ] expected = { "17:9: " + getCheckMessage ( JAVADOC_MISSING ) , "24:9: " + getCheckMessage ( JAVADOC_MISSING ) , "30:13: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "InputInner.java" ) , expected ) ; } @ Test public void testAnother2 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocVariableCheck . class ) ; checkConfig . addAttribute ( "scope" , Scope . PUBLIC . getName ( ) ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputInner.java" ) , expected ) ; } @ Test public void testAnother3 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocVariableCheck . class ) ; final String [ ] expected = { "11:9: " + getCheckMessage ( JAVADOC_MISSING ) , "16:13: " + getCheckMessage ( JAVADOC_MISSING ) , "36:9: " + getCheckMessage ( JAVADOC_MISSING ) , "43:5: " + getCheckMessage ( JAVADOC_MISSING ) , "44:5: " + getCheckMessage ( JAVADOC_MISSING ) , "45:5: " + getCheckMessage ( JAVADOC_MISSING ) , "46:5: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "InputPublicOnly.java" ) , expected ) ; } @ Test public void testAnother4 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocVariableCheck . class ) ; checkConfig . addAttribute ( "scope" , Scope . PUBLIC . getName ( ) ) ; final String [ ] expected = { "46:5: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "InputPublicOnly.java" ) , expected ) ; } @ Test public void testScopes ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocVariableCheck . class ) ; final String [ ] expected = { "5:5: " + getCheckMessage ( JAVADOC_MISSING ) , "6:5: " + getCheckMessage ( JAVADOC_MISSING ) , "7:5: " + getCheckMessage ( JAVADOC_MISSING ) , "8:5: " + getCheckMessage ( JAVADOC_MISSING ) , "16:9: " + getCheckMessage ( JAVADOC_MISSING ) , "17:9: " + getCheckMessage ( JAVADOC_MISSING ) , "18:9: " + getCheckMessage ( JAVADOC_MISSING ) , "19:9: " + getCheckMessage ( JAVADOC_MISSING ) , "28:9: " + getCheckMessage ( JAVADOC_MISSING ) , "29:9: " + getCheckMessage ( JAVADOC_MISSING ) , "30:9: " + getCheckMessage ( JAVADOC_MISSING ) , "31:9: " + getCheckMessage ( JAVADOC_MISSING ) , "40:9: " + getCheckMessage ( JAVADOC_MISSING ) , "41:9: " + getCheckMessage ( JAVADOC_MISSING ) , "42:9: " + getCheckMessage ( JAVADOC_MISSING ) , "43:9: " + getCheckMessage ( JAVADOC_MISSING ) , "53:5: " + getCheckMessage ( JAVADOC_MISSING ) , "54:5: " + getCheckMessage ( JAVADOC_MISSING ) , "55:5: " + getCheckMessage ( JAVADOC_MISSING ) , "56:5: " + getCheckMessage ( JAVADOC_MISSING ) , "64:9: " + getCheckMessage ( JAVADOC_MISSING ) , "65:9: " + getCheckMessage ( JAVADOC_MISSING ) , "66:9: " + getCheckMessage ( JAVADOC_MISSING ) , "67:9: " + getCheckMessage ( JAVADOC_MISSING ) , "76:9: " + getCheckMessage ( JAVADOC_MISSING ) , "77:9: " + getCheckMessage ( JAVADOC_MISSING ) , "78:9: " + getCheckMessage ( JAVADOC_MISSING ) , "79:9: " + getCheckMessage ( JAVADOC_MISSING ) , "88:9: " + getCheckMessage ( JAVADOC_MISSING ) , "89:9: " + getCheckMessage ( JAVADOC_MISSING ) , "90:9: " + getCheckMessage ( JAVADOC_MISSING ) , "91:9: " + getCheckMessage ( JAVADOC_MISSING ) , "100:9: " + getCheckMessage ( JAVADOC_MISSING ) , "101:9: " + getCheckMessage ( JAVADOC_MISSING ) , "102:9: " + getCheckMessage ( JAVADOC_MISSING ) , "103:9: " + getCheckMessage ( JAVADOC_MISSING ) , "113:9: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputNoJavadoc.java" ) , expected ) ; } @ Test public void testScopes2 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocVariableCheck . class ) ; checkConfig . addAttribute ( "scope" , Scope . PROTECTED . getName ( ) ) ; final String [ ] expected = { "5:5: " + getCheckMessage ( JAVADOC_MISSING ) , "6:5: " + getCheckMessage ( JAVADOC_MISSING ) , "16:9: " + getCheckMessage ( JAVADOC_MISSING ) , "17:9: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputNoJavadoc.java" ) , expected ) ; } @ Test public void testExcludeScope ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocVariableCheck . class ) ; checkConfig . addAttribute ( "scope" , Scope . PRIVATE . getName ( ) ) ; checkConfig . addAttribute ( "excludeScope" , Scope . PROTECTED . getName ( ) ) ; final String [ ] expected = { "7:5: " + getCheckMessage ( JAVADOC_MISSING ) , "8:5: " + getCheckMessage ( JAVADOC_MISSING ) , "18:9: " + getCheckMessage ( JAVADOC_MISSING ) , "19:9: " + getCheckMessage ( JAVADOC_MISSING ) , "28:9: " + getCheckMessage ( JAVADOC_MISSING ) , "29:9: " + getCheckMessage ( JAVADOC_MISSING ) , "30:9: " + getCheckMessage ( JAVADOC_MISSING ) , "31:9: " + getCheckMessage ( JAVADOC_MISSING ) , "40:9: " + getCheckMessage ( JAVADOC_MISSING ) , "41:9: " + getCheckMessage ( JAVADOC_MISSING ) , "42:9: " + getCheckMessage ( JAVADOC_MISSING ) , "43:9: " + getCheckMessage ( JAVADOC_MISSING ) , "53:5: " + getCheckMessage ( JAVADOC_MISSING ) , "54:5: " + getCheckMessage ( JAVADOC_MISSING ) , "55:5: " + getCheckMessage ( JAVADOC_MISSING ) , "56:5: " + getCheckMessage ( JAVADOC_MISSING ) , "64:9: " + getCheckMessage ( JAVADOC_MISSING ) , "65:9: " + getCheckMessage ( JAVADOC_MISSING ) , "66:9: " + getCheckMessage ( JAVADOC_MISSING ) , "67:9: " + getCheckMessage ( JAVADOC_MISSING ) , "76:9: " + getCheckMessage ( JAVADOC_MISSING ) , "77:9: " + getCheckMessage ( JAVADOC_MISSING ) , "78:9: " + getCheckMessage ( JAVADOC_MISSING ) , "79:9: " + getCheckMessage ( JAVADOC_MISSING ) , "88:9: " + getCheckMessage ( JAVADOC_MISSING ) , "89:9: " + getCheckMessage ( JAVADOC_MISSING ) , "90:9: " + getCheckMessage ( JAVADOC_MISSING ) , "91:9: " + getCheckMessage ( JAVADOC_MISSING ) , "100:9: " + getCheckMessage ( JAVADOC_MISSING ) , "101:9: " + getCheckMessage ( JAVADOC_MISSING ) , "102:9: " + getCheckMessage ( JAVADOC_MISSING ) , "103:9: " + getCheckMessage ( JAVADOC_MISSING ) , "113:9: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputNoJavadoc.java" ) , expected ) ; } @ Test public void testIgnoredVariableNames ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocVariableCheck . class ) ; checkConfig . addAttribute ( "ignoreNamePattern" , "log|logger" ) ; final String [ ] expected = { "5:5: " + getCheckMessage ( JAVADOC_MISSING ) , "6:5: " + getCheckMessage ( JAVADOC_MISSING ) , "7:5: " + getCheckMessage ( JAVADOC_MISSING ) , "8:5: " + getCheckMessage ( JAVADOC_MISSING ) , "16:9: " + getCheckMessage ( JAVADOC_MISSING ) , "17:9: " + getCheckMessage ( JAVADOC_MISSING ) , "18:9: " + getCheckMessage ( JAVADOC_MISSING ) , "19:9: " + getCheckMessage ( JAVADOC_MISSING ) , "28:9: " + getCheckMessage ( JAVADOC_MISSING ) , "29:9: " + getCheckMessage ( JAVADOC_MISSING ) , "30:9: " + getCheckMessage ( JAVADOC_MISSING ) , "31:9: " + getCheckMessage ( JAVADOC_MISSING ) , "40:9: " + getCheckMessage ( JAVADOC_MISSING ) , "41:9: " + getCheckMessage ( JAVADOC_MISSING ) , "42:9: " + getCheckMessage ( JAVADOC_MISSING ) , "43:9: " + getCheckMessage ( JAVADOC_MISSING ) , "53:5: " + getCheckMessage ( JAVADOC_MISSING ) , "54:5: " + getCheckMessage ( JAVADOC_MISSING ) , "55:5: " + getCheckMessage ( JAVADOC_MISSING ) , "56:5: " + getCheckMessage ( JAVADOC_MISSING ) , "64:9: " + getCheckMessage ( JAVADOC_MISSING ) , "65:9: " + getCheckMessage ( JAVADOC_MISSING ) , "66:9: " + getCheckMessage ( JAVADOC_MISSING ) , "67:9: " + getCheckMessage ( JAVADOC_MISSING ) , "76:9: " + getCheckMessage ( JAVADOC_MISSING ) , "77:9: " + getCheckMessage ( JAVADOC_MISSING ) , "78:9: " + getCheckMessage ( JAVADOC_MISSING ) , "79:9: " + getCheckMessage ( JAVADOC_MISSING ) , "88:9: " + getCheckMessage ( JAVADOC_MISSING ) , "89:9: " + getCheckMessage ( JAVADOC_MISSING ) , "90:9: " + getCheckMessage ( JAVADOC_MISSING ) , "91:9: " + getCheckMessage ( JAVADOC_MISSING ) , "100:9: " + getCheckMessage ( JAVADOC_MISSING ) , "101:9: " + getCheckMessage ( JAVADOC_MISSING ) , "102:9: " + getCheckMessage ( JAVADOC_MISSING ) , "103:9: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputNoJavadoc.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocStyleCheck . EXTRA_HTML ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocStyleCheck . UNCLOSED_HTML ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocStyleCheck . INCOMPLETE_TAG ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocStyleCheck . NO_PERIOD ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocStyleCheck . EMPTY ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocStyleCheck . JAVADOC_MISSING ; public class JavadocStyleCheckTest extends BaseCheckTestSupport { @ Test public void testDefaultSettings ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; final String [ ] expected = { "20: " + getCheckMessage ( NO_PERIOD ) , "53: " + getCheckMessage ( NO_PERIOD ) , "63:11: " + getCheckMessage ( UNCLOSED_HTML , "<b>This guy is missing end of bold tag" ) , "66:7: " + getCheckMessage ( EXTRA_HTML , "</td>Extra tag shouldn't be here" ) , "68:19: " + getCheckMessage ( UNCLOSED_HTML , "<code>dummy." ) , "74: " + getCheckMessage ( NO_PERIOD ) , "75:23: " + getCheckMessage ( UNCLOSED_HTML , "<b>should fail" ) , "81: " + getCheckMessage ( NO_PERIOD ) , "82:31: " + getCheckMessage ( UNCLOSED_HTML , "<b>should fail" ) , "88: " + getCheckMessage ( NO_PERIOD ) , "89:31: " + getCheckMessage ( EXTRA_HTML , "</code>" ) , "90: " + getCheckMessage ( INCOMPLETE_TAG , " * should fail <" ) , "109:39: " + getCheckMessage ( EXTRA_HTML , "</img>" ) , "186:8: " + getCheckMessage ( UNCLOSED_HTML , "<blockquote>" ) , "193: " + getCheckMessage ( NO_PERIOD ) , "238: " + getCheckMessage ( NO_PERIOD ) , "335:33: " + getCheckMessage ( EXTRA_HTML , "</string>" ) , } ; verify ( checkConfig , getPath ( "InputJavadocStyleCheck.java" ) , expected ) ; } @ Test public void testFirstSentence ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; checkConfig . addAttribute ( "checkFirstSentence" , "true" ) ; checkConfig . addAttribute ( "checkHtml" , "false" ) ; final String [ ] expected = { "20: " + getCheckMessage ( NO_PERIOD ) , "53: " + getCheckMessage ( NO_PERIOD ) , "74: " + getCheckMessage ( NO_PERIOD ) , "81: " + getCheckMessage ( NO_PERIOD ) , "88: " + getCheckMessage ( NO_PERIOD ) , "193: " + getCheckMessage ( NO_PERIOD ) , "238: " + getCheckMessage ( NO_PERIOD ) , } ; verify ( checkConfig , getPath ( "InputJavadocStyleCheck.java" ) , expected ) ; } @ Test public void testFirstSentenceFormat ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; checkConfig . addAttribute ( "checkFirstSentence" , "true" ) ; checkConfig . addAttribute ( "checkHtml" , "false" ) ; checkConfig . addAttribute ( "endOfSentenceFormat" , "([.][ \t\n\r\f<])|([.]$)" ) ; final String [ ] expected = { "20: " + getCheckMessage ( NO_PERIOD ) , "32: " + getCheckMessage ( NO_PERIOD ) , "39: " + getCheckMessage ( NO_PERIOD ) , "53: " + getCheckMessage ( NO_PERIOD ) , "74: " + getCheckMessage ( NO_PERIOD ) , "81: " + getCheckMessage ( NO_PERIOD ) , "88: " + getCheckMessage ( NO_PERIOD ) , "193: " + getCheckMessage ( NO_PERIOD ) , "238: " + getCheckMessage ( NO_PERIOD ) , } ; verify ( checkConfig , getPath ( "InputJavadocStyleCheck.java" ) , expected ) ; } @ Test public void testHtml ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; checkConfig . addAttribute ( "checkFirstSentence" , "false" ) ; checkConfig . addAttribute ( "checkHtml" , "true" ) ; final String [ ] expected = { "63:11: " + getCheckMessage ( UNCLOSED_HTML , "<b>This guy is missing end of bold tag" ) , "66:7: " + getCheckMessage ( EXTRA_HTML , "</td>Extra tag shouldn't be here" ) , "68:19: " + getCheckMessage ( UNCLOSED_HTML , "<code>dummy." ) , "75:23: " + getCheckMessage ( UNCLOSED_HTML , "<b>should fail" ) , "82:31: " + getCheckMessage ( UNCLOSED_HTML , "<b>should fail" ) , "89:31: " + getCheckMessage ( EXTRA_HTML , "</code>" ) , "90: " + getCheckMessage ( INCOMPLETE_TAG , " * should fail <" ) , "109:39: " + getCheckMessage ( EXTRA_HTML , "</img>" ) , "186:8: " + getCheckMessage ( UNCLOSED_HTML , "<blockquote>" ) , "335:33: " + getCheckMessage ( EXTRA_HTML , "</string>" ) , } ; verify ( checkConfig , getPath ( "InputJavadocStyleCheck.java" ) , expected ) ; } @ Test public void testHtmlComment ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; checkConfig . addAttribute ( "checkFirstSentence" , "false" ) ; checkConfig . addAttribute ( "checkHtml" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputJavadocStyleCheckHtmlComment.java" ) , expected ) ; } @ Test public void testScopePublic ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; checkConfig . addAttribute ( "checkFirstSentence" , "true" ) ; checkConfig . addAttribute ( "checkHtml" , "true" ) ; checkConfig . addAttribute ( "checkEmptyJavadoc" , "true" ) ; checkConfig . addAttribute ( "scope" , "public" ) ; final String [ ] expected = { "88: " + getCheckMessage ( NO_PERIOD ) , "89:31: " + getCheckMessage ( EXTRA_HTML , "</code>" ) , "90: " + getCheckMessage ( INCOMPLETE_TAG , " * should fail <" ) , "205: " + getCheckMessage ( EMPTY ) , "230: " + getCheckMessage ( EMPTY ) , "238: " + getCheckMessage ( NO_PERIOD ) , "335:33: " + getCheckMessage ( EXTRA_HTML , "</string>" ) , } ; verify ( checkConfig , getPath ( "InputJavadocStyleCheck.java" ) , expected ) ; } @ Test public void testScopeProtected ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; checkConfig . addAttribute ( "checkFirstSentence" , "true" ) ; checkConfig . addAttribute ( "checkHtml" , "true" ) ; checkConfig . addAttribute ( "checkEmptyJavadoc" , "true" ) ; checkConfig . addAttribute ( "scope" , "protected" ) ; final String [ ] expected = { "74: " + getCheckMessage ( NO_PERIOD ) , "75:23: " + getCheckMessage ( UNCLOSED_HTML , "<b>should fail" ) , "88: " + getCheckMessage ( NO_PERIOD ) , "89:31: " + getCheckMessage ( EXTRA_HTML , "</code>" ) , "90: " + getCheckMessage ( INCOMPLETE_TAG , " * should fail <" ) , "205: " + getCheckMessage ( EMPTY ) , "211: " + getCheckMessage ( EMPTY ) , "230: " + getCheckMessage ( EMPTY ) , "238: " + getCheckMessage ( NO_PERIOD ) , "335:33: " + getCheckMessage ( EXTRA_HTML , "</string>" ) , } ; verify ( checkConfig , getPath ( "InputJavadocStyleCheck.java" ) , expected ) ; } @ Test public void testScopePackage ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; checkConfig . addAttribute ( "checkFirstSentence" , "true" ) ; checkConfig . addAttribute ( "checkHtml" , "true" ) ; checkConfig . addAttribute ( "checkEmptyJavadoc" , "true" ) ; checkConfig . addAttribute ( "scope" , "package" ) ; final String [ ] expected = { "74: " + getCheckMessage ( NO_PERIOD ) , "75:23: " + getCheckMessage ( UNCLOSED_HTML , "<b>should fail" ) , "81: " + getCheckMessage ( NO_PERIOD ) , "82:31: " + getCheckMessage ( UNCLOSED_HTML , "<b>should fail" ) , "88: " + getCheckMessage ( NO_PERIOD ) , "89:31: " + getCheckMessage ( EXTRA_HTML , "</code>" ) , "90: " + getCheckMessage ( INCOMPLETE_TAG , " * should fail <" ) , "205: " + getCheckMessage ( EMPTY ) , "211: " + getCheckMessage ( EMPTY ) , "218: " + getCheckMessage ( EMPTY ) , "230: " + getCheckMessage ( EMPTY ) , "238: " + getCheckMessage ( NO_PERIOD ) , "335:33: " + getCheckMessage ( EXTRA_HTML , "</string>" ) , } ; verify ( checkConfig , getPath ( "InputJavadocStyleCheck.java" ) , expected ) ; } @ Test public void testEmptyJavadoc ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; checkConfig . addAttribute ( "checkFirstSentence" , "false" ) ; checkConfig . addAttribute ( "checkHtml" , "false" ) ; checkConfig . addAttribute ( "checkEmptyJavadoc" , "true" ) ; final String [ ] expected = { "205: " + getCheckMessage ( EMPTY ) , "211: " + getCheckMessage ( EMPTY ) , "218: " + getCheckMessage ( EMPTY ) , "225: " + getCheckMessage ( EMPTY ) , "230: " + getCheckMessage ( EMPTY ) , } ; verify ( checkConfig , getPath ( "InputJavadocStyleCheck.java" ) , expected ) ; } @ Test public void testExcludeScope ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; checkConfig . addAttribute ( "scope" , "private" ) ; checkConfig . addAttribute ( "excludeScope" , "protected" ) ; final String [ ] expected = { "20: " + getCheckMessage ( NO_PERIOD ) , "53: " + getCheckMessage ( NO_PERIOD ) , "63:11: " + getCheckMessage ( UNCLOSED_HTML , "<b>This guy is missing end of bold tag" ) , "66:7: " + getCheckMessage ( EXTRA_HTML , "</td>Extra tag shouldn't be here" ) , "68:19: " + getCheckMessage ( UNCLOSED_HTML , "<code>dummy." ) , "81: " + getCheckMessage ( NO_PERIOD ) , "82:31: " + getCheckMessage ( UNCLOSED_HTML , "<b>should fail" ) , "109:39: " + getCheckMessage ( EXTRA_HTML , "</img>" ) , "186:8: " + getCheckMessage ( UNCLOSED_HTML , "<blockquote>" ) , "193: " + getCheckMessage ( NO_PERIOD ) , } ; verify ( checkConfig , getPath ( "InputJavadocStyleCheck.java" ) , expected ) ; } @ Test public void packageInfoInheritDoc ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; final String [ ] expected = { "1: " + getCheckMessage ( NO_PERIOD ) , } ; String basePath = "javadoc" + File . separator + "pkginfo" + File . separator + "invalidinherit" + File . separator ; verify ( createChecker ( checkConfig ) , getPath ( basePath + "package-info.java" ) , expected ) ; } @ Test public void packageInfoInvalid ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; final String [ ] expected = { "1: " + getCheckMessage ( NO_PERIOD ) , } ; String basePath = "javadoc" + File . separator + "pkginfo" + File . separator + "invalidformat" + File . separator ; verify ( createChecker ( checkConfig ) , getPath ( basePath + "package-info.java" ) , expected ) ; } @ Test public void packageInfoAnnotation ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; final String [ ] expected = { } ; String basePath = "javadoc" + File . separator + "pkginfo" + File . separator + "annotation" + File . separator ; verify ( createChecker ( checkConfig ) , getPath ( basePath + "package-info.java" ) , expected ) ; } @ Test public void packageInfoMissing ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; final String [ ] expected = { "1: " + getCheckMessage ( JAVADOC_MISSING ) , } ; String basePath = "javadoc" + File . separator + "bothfiles" + File . separator ; verify ( createChecker ( checkConfig ) , getPath ( basePath + "package-info.java" ) , expected ) ; } @ Test public void packageInfoValid ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocStyleCheck . class ) ; final String [ ] expected = { } ; String basePath = "javadoc" + File . separator + "pkginfo" + File . separator + "valid" + File . separator ; verify ( createChecker ( checkConfig ) , getPath ( basePath + "package-info.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocPackageCheck . MSG_LEGACY_PACKAGE_HTML ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocPackageCheck . MSG_PACKAGE_INFO ; public class JavadocPackageCheckTest extends BaseCheckTestSupport { @ Override protected DefaultConfiguration createCheckerConfig ( Configuration aCheckConfig ) { final DefaultConfiguration dc = new DefaultConfiguration ( "root" ) ; dc . addChild ( aCheckConfig ) ; return dc ; } @ Test public void testMissing ( ) throws Exception { final Configuration checkConfig = createCheckConfig ( JavadocPackageCheck . class ) ; final String [ ] expected = { "0: " + getCheckMessage ( MSG_PACKAGE_INFO ) , } ; verify ( createChecker ( checkConfig ) , getSrcPath ( "checks/javadoc/BadCls.java" ) , getSrcPath ( "checks/javadoc/BadCls.java" ) , expected ) ; } @ Test public void testBoth ( ) throws Exception { final Configuration checkConfig = createCheckConfig ( JavadocPackageCheck . class ) ; final String [ ] expected = { "0: " + getCheckMessage ( MSG_LEGACY_PACKAGE_HTML ) , } ; verify ( createChecker ( checkConfig ) , getPath ( "javadoc/bothfiles/Ignored.java" ) , getPath ( "javadoc/bothfiles/Ignored.java" ) , expected ) ; } @ Test public void testHtmlDisallowed ( ) throws Exception { final Configuration checkConfig = createCheckConfig ( JavadocPackageCheck . class ) ; final String [ ] expected = { "0: Missing package-info.java file." , } ; verify ( createChecker ( checkConfig ) , getPath ( "javadoc/pkghtml/Ignored.java" ) , getPath ( "javadoc/pkghtml/Ignored.java" ) , expected ) ; } @ Test public void testHtmlAllowed ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocPackageCheck . class ) ; checkConfig . addAttribute ( "allowLegacy" , "true" ) ; final String [ ] expected = { } ; verify ( createChecker ( checkConfig ) , getPath ( "javadoc/pkghtml/Ignored.java" ) , getPath ( "javadoc/pkghtml/package-info.java" ) , expected ) ; } @ Test public void testAnnotation ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocPackageCheck . class ) ; final String [ ] expected = { } ; verify ( createChecker ( checkConfig ) , getPath ( "javadoc/pkginfo/annotation/package-info.java" ) , getPath ( "javadoc/pkginfo/annotation/package-info.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import java . util . List ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . api . Comment ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . JavadocTagInfo ; import com . puppycrawl . tools . checkstyle . api . JavadocTokenTypes ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class JavadocUtilsTest { @ Test public void testTags ( ) { final String [ ] text = { "/** @see elsewhere " , " * {@link List }, {@link List link text }" , " {@link List#add(Object) link text}" , " * {@link Class link text}" , } ; final Comment comment = new Comment ( text , 1 , 4 , text [ 3 ] . length ( ) ) ; final JavadocTags allTags = JavadocUtils . getJavadocTags ( comment , JavadocUtils . JavadocTagType . ALL ) ; assertEquals ( 5 , allTags . getValidTags ( ) . size ( ) ) ; } @ Test public void testTagType ( ) { final String [ ] text = { "/** @see block" , " * {@link List inline}, {@link List#add(Object)}" , } ; final Comment comment = new Comment ( text , 1 , 2 , text [ 1 ] . length ( ) ) ; final JavadocTags blockTags = JavadocUtils . getJavadocTags ( comment , JavadocUtils . JavadocTagType . BLOCK ) ; final JavadocTags inlineTags = JavadocUtils . getJavadocTags ( comment , JavadocUtils . JavadocTagType . INLINE ) ; assertEquals ( 1 , blockTags . getValidTags ( ) . size ( ) ) ; assertEquals ( 2 , inlineTags . getValidTags ( ) . size ( ) ) ; } @ Test public void testInlineTagLinkText ( ) { final String [ ] text = { "/** {@link List link text }" , } ; final Comment comment = new Comment ( text , 1 , 1 , text [ 0 ] . length ( ) ) ; final List < JavadocTag > tags = JavadocUtils . getJavadocTags ( comment , JavadocUtils . JavadocTagType . ALL ) . getValidTags ( ) ; assertEquals ( "List link text" , tags . get ( 0 ) . getArg1 ( ) ) ; } @ Test public void testInlineTagMethodRef ( ) { final String [ ] text = { "/** {@link List#add(Object)}" , } ; final Comment comment = new Comment ( text , 1 , 1 , text [ 0 ] . length ( ) ) ; final List < JavadocTag > tags = JavadocUtils . getJavadocTags ( comment , JavadocUtils . JavadocTagType . ALL ) . getValidTags ( ) ; assertEquals ( "List#add(Object)" , tags . get ( 0 ) . getArg1 ( ) ) ; } @ Test public void testTagPositions ( ) { final String [ ] text = { "/** @see elsewhere" , " also {@link Name value} */" , } ; final Comment comment = new Comment ( text , 1 , 2 , text [ 1 ] . length ( ) ) ; final List < JavadocTag > tags = JavadocUtils . getJavadocTags ( comment , JavadocUtils . JavadocTagType . ALL ) . getValidTags ( ) ; assertEquals ( 2 , tags . size ( ) ) ; for ( final JavadocTag tag : tags ) { if ( JavadocTagInfo . SEE . getName ( ) . equals ( tag . getTagName ( ) ) ) { assertEquals ( 1 , tag . getLineNo ( ) ) ; assertEquals ( 5 , tag . getColumnNo ( ) ) ; } else if ( JavadocTagInfo . LINK . getName ( ) . equals ( tag . getTagName ( ) ) ) { assertEquals ( 2 , tag . getLineNo ( ) ) ; assertEquals ( 10 , tag . getColumnNo ( ) ) ; } else { fail ( "Unexpected tag: " + tag ) ; } } } @ Test public void testInvalidTags ( ) { final String [ ] text = { "/** @fake block" , " * {@bogus inline}" , " * {@link List valid}" , } ; final Comment comment = new Comment ( text , 1 , 3 , text [ 2 ] . length ( ) ) ; final JavadocTags allTags = JavadocUtils . getJavadocTags ( comment , JavadocUtils . JavadocTagType . ALL ) ; assertEquals ( 2 , allTags . getInvalidTags ( ) . size ( ) ) ; assertEquals ( 1 , allTags . getValidTags ( ) . size ( ) ) ; } @ Test public void testEmptyBlockComment ( ) { final String emptyComment = "" ; assertFalse ( JavadocUtils . isJavadocComment ( emptyComment ) ) ; } @ Test public void testEmptyBlockCommentAst ( ) { DetailAST commentBegin = new DetailAST ( ) ; commentBegin . setType ( TokenTypes . BLOCK_COMMENT_BEGIN ) ; commentBegin . setText ( "/*" ) ; DetailAST commentContent = new DetailAST ( ) ; commentContent . setType ( TokenTypes . COMMENT_CONTENT ) ; commentContent . setText ( "" ) ; DetailAST commentEnd = new DetailAST ( ) ; commentEnd . setType ( TokenTypes . BLOCK_COMMENT_END ) ; commentEnd . setText ( "*/" ) ; commentBegin . setFirstChild ( commentContent ) ; commentContent . setNextSibling ( commentEnd ) ; assertFalse ( JavadocUtils . isJavadocComment ( commentBegin ) ) ; } @ Test public void testEmptyJavadocComment ( ) { final String emptyJavadocComment = "*" ; assertTrue ( JavadocUtils . isJavadocComment ( emptyJavadocComment ) ) ; } @ Test public void testEmptyJavadocCommentAst ( ) { DetailAST commentBegin = new DetailAST ( ) ; commentBegin . setType ( TokenTypes . BLOCK_COMMENT_BEGIN ) ; commentBegin . setText ( "/*" ) ; DetailAST javadocCommentContent = new DetailAST ( ) ; javadocCommentContent . setType ( TokenTypes . COMMENT_CONTENT ) ; javadocCommentContent . setText ( "*" ) ; DetailAST commentEnd = new DetailAST ( ) ; commentEnd . setType ( TokenTypes . BLOCK_COMMENT_END ) ; commentEnd . setText ( "*/" ) ; commentBegin . setFirstChild ( javadocCommentContent ) ; javadocCommentContent . setNextSibling ( commentEnd ) ; assertTrue ( JavadocUtils . isJavadocComment ( commentBegin ) ) ; } @ Test public void testIsProperUtilsClass ( ) throws ReflectiveOperationException { assertUtilsClassHasPrivateConstructor ( JavadocUtils . class ) ; } @ Test public void testBranchContains ( ) { JavadocNodeImpl node = new JavadocNodeImpl ( ) ; JavadocNodeImpl firstChild = new JavadocNodeImpl ( ) ; JavadocNodeImpl secondChild = new JavadocNodeImpl ( ) ; node . setType ( JavadocTokenTypes . JAVADOC ) ; firstChild . setType ( JavadocTokenTypes . BODY_TAG_OPEN ) ; secondChild . setType ( JavadocTokenTypes . CODE_LITERAL ) ; node . setChildren ( firstChild , secondChild ) ; assertFalse ( JavadocUtils . branchContains ( node , JavadocTokenTypes . AUTHOR_LITERAL ) ) ; firstChild . setParent ( node ) ; secondChild . setParent ( node ) ; assertFalse ( JavadocUtils . branchContains ( node , JavadocTokenTypes . AUTHOR_LITERAL ) ) ; secondChild . setType ( JavadocTokenTypes . AUTHOR_LITERAL ) ; assertTrue ( JavadocUtils . branchContains ( node , JavadocTokenTypes . AUTHOR_LITERAL ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; public class Input_01 { public void doStuff1 ( ) throws TestException1 { try { doStuff2 ( ) ; } catch ( final TestException2 e ) { } throw new Input_01 ( ) . new TestException1 ( "" ) ; } private static void doStuff2 ( ) throws TestException2 { throw new TestException2 ( "" ) ; } class TestException1 extends Exception { TestException1 ( String messg ) { super ( messg ) ; } } public static class TestException2 extends Exception { TestException2 ( String messg ) { super ( messg ) ; } } }
package com . puppycrawl . tools . checkstyle ; import com . puppycrawl . tools . checkstyle . api . Configuration ; public class BaseFileSetCheckTestSupport extends BaseCheckTestSupport { @ Override protected DefaultConfiguration createCheckerConfig ( Configuration aCheckConfig ) { final DefaultConfiguration dc = new DefaultConfiguration ( "root" ) ; dc . addChild ( aCheckConfig ) ; return dc ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . SummaryJavadocCheck . SUMMARY_FIRST_SENTENCE ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . SummaryJavadocCheck . SUMMARY_JAVADOC ; public class SummaryJavadocCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( SummaryJavadocCheck . class ) ; } @ Test public void testCorrect ( ) throws Exception { checkConfig . addAttribute ( "forbiddenSummaryFragments" , "^@return the *|^This method returns *|^A [{]@code [a-zA-Z0-9]+[}]( is a )" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "javadoc/InputCorrectSummaryJavaDocCheck.java" ) , expected ) ; } @ Test public void testIncorrect ( ) throws Exception { checkConfig . addAttribute ( "forbiddenSummaryFragments" , "^@return the *|^This method returns |^A [{]@code [a-zA-Z0-9]+[}]( is a )" ) ; final String [ ] expected = { "14: " + getCheckMessage ( SUMMARY_FIRST_SENTENCE ) , "37: " + getCheckMessage ( SUMMARY_FIRST_SENTENCE ) , "47: " + getCheckMessage ( SUMMARY_JAVADOC ) , "58: " + getCheckMessage ( SUMMARY_JAVADOC ) , "69: " + getCheckMessage ( SUMMARY_FIRST_SENTENCE ) , "83: " + getCheckMessage ( SUMMARY_JAVADOC ) , "103: " + getCheckMessage ( SUMMARY_FIRST_SENTENCE ) , } ; verify ( checkConfig , getPath ( "javadoc/InputIncorrectSummaryJavaDocCheck.java" ) , expected ) ; } @ Test public void testPeriod ( ) throws Exception { checkConfig . addAttribute ( "period" , "_" ) ; final String [ ] expected = { "5: " + getCheckMessage ( SUMMARY_FIRST_SENTENCE ) , "10: " + getCheckMessage ( SUMMARY_FIRST_SENTENCE ) , } ; verify ( checkConfig , getPath ( "javadoc/InputSummaryJavadocCheckPeriod.java" ) , expected ) ; } @ Test public void testNoPeriod ( ) throws Exception { checkConfig . addAttribute ( "period" , "" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "javadoc/InputSummaryJavadocCheckNoPeriod.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; public class Input_1379666 { public void ok ( ) throws BadStringFormat { } public void error1 ( ) throws com . puppycrawl . tools . checkstyle . checks . javadoc . Input_1379666 . BadStringFormat { } public void error2 ( ) throws Input_1379666 . BadStringFormat { } public static class BadStringFormat extends Exception { BadStringFormat ( String s ) { super ( s ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; public class Input_03 { public void doStuff1 ( ) throws TestException1 , TestException2 { try { doStuff2 ( ) ; } catch ( final TestException2 e ) { } throw new Input_03 ( ) . new TestException1 ( "" ) ; } private static void doStuff2 ( ) throws TestException2 { throw new TestException2 ( "" ) ; } class TestException1 extends Exception { TestException1 ( String messg ) { super ( messg ) ; } } public static class TestException2 extends Exception { TestException2 ( String messg ) { super ( messg ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; class BadCls { class X extends Exception { } void m ( ) throws X { } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocTypeCheck . JAVADOC_MISSING ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocTypeCheck . MISSING_TAG ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocTypeCheck . TAG_FORMAT ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocTypeCheck . UNKNOWN_TAG ; import static com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocTypeCheck . UNUSED_TAG ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . Scope ; public class JavadocTypeCheckTest extends BaseCheckTestSupport { @ Test public void testTags ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; final String [ ] expected = { "8: " + getCheckMessage ( JAVADOC_MISSING ) , "302: " + getCheckMessage ( JAVADOC_MISSING ) , "327: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "checks/javadoc/InputTags.java" ) , expected ) ; } @ Test public void testInner ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; final String [ ] expected = { "14: " + getCheckMessage ( JAVADOC_MISSING ) , "21: " + getCheckMessage ( JAVADOC_MISSING ) , "27: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "InputInner.java" ) , expected ) ; } @ Test public void testStrict ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; final String [ ] expected = { "7: " + getCheckMessage ( JAVADOC_MISSING ) , "9: " + getCheckMessage ( JAVADOC_MISSING ) , "14: " + getCheckMessage ( JAVADOC_MISSING ) , "34: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "InputPublicOnly.java" ) , expected ) ; } @ Test public void testProtected ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "scope" , Scope . PROTECTED . getName ( ) ) ; final String [ ] expected = { "7: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "InputPublicOnly.java" ) , expected ) ; } @ Test public void testPublic ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "scope" , Scope . PUBLIC . getName ( ) ) ; final String [ ] expected = { "7: " + getCheckMessage ( JAVADOC_MISSING ) , "38: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "InputScopeInnerInterfaces.java" ) , expected ) ; } @ Test public void testProtest ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "scope" , Scope . PROTECTED . getName ( ) ) ; final String [ ] expected = { "7: " + getCheckMessage ( JAVADOC_MISSING ) , "29: " + getCheckMessage ( JAVADOC_MISSING ) , "38: " + getCheckMessage ( JAVADOC_MISSING ) , "65: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "InputScopeInnerInterfaces.java" ) , expected ) ; } @ Test public void testPkg ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "scope" , Scope . getInstance ( "package" ) . getName ( ) ) ; final String [ ] expected = { "18: " + getCheckMessage ( JAVADOC_MISSING ) , "20: " + getCheckMessage ( JAVADOC_MISSING ) , "22: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "InputScopeInnerClasses.java" ) , expected ) ; } @ Test public void testEclipse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "scope" , Scope . getInstance ( "public" ) . getName ( ) ) ; final String [ ] expected = { "18: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "InputScopeInnerClasses.java" ) , expected ) ; } @ Test public void testAuthorRequired ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "authorFormat" , "\\S" ) ; final String [ ] expected = { "13: " + getCheckMessage ( MISSING_TAG , "@author" ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void testAuthorRegularEx ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "authorFormat" , "0*" ) ; final String [ ] expected = { "22: " + getCheckMessage ( MISSING_TAG , "@author" ) , "58: " + getCheckMessage ( MISSING_TAG , "@author" ) , "94: " + getCheckMessage ( MISSING_TAG , "@author" ) , } ; verify ( checkConfig , getPath ( "InputJavadoc.java" ) , expected ) ; } @ Test public void testAuthorRegularExError ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "authorFormat" , "ABC" ) ; final String [ ] expected = { "13: " + getCheckMessage ( TAG_FORMAT , "@author" , "ABC" ) , "22: " + getCheckMessage ( MISSING_TAG , "@author" ) , "31: " + getCheckMessage ( TAG_FORMAT , "@author" , "ABC" ) , "49: " + getCheckMessage ( TAG_FORMAT , "@author" , "ABC" ) , "58: " + getCheckMessage ( MISSING_TAG , "@author" ) , "67: " + getCheckMessage ( TAG_FORMAT , "@author" , "ABC" ) , "85: " + getCheckMessage ( TAG_FORMAT , "@author" , "ABC" ) , "94: " + getCheckMessage ( MISSING_TAG , "@author" ) , "103: " + getCheckMessage ( TAG_FORMAT , "@author" , "ABC" ) , } ; verify ( checkConfig , getPath ( "InputJavadoc.java" ) , expected ) ; } @ Test public void testVersionRequired ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "versionFormat" , "\\S" ) ; final String [ ] expected = { "13: " + getCheckMessage ( MISSING_TAG , "@version" ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void testVersionRegularEx ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "versionFormat" , "^\\p{Digit}+\\.\\p{Digit}+$" ) ; final String [ ] expected = { "22: " + getCheckMessage ( MISSING_TAG , "@version" ) , "58: " + getCheckMessage ( MISSING_TAG , "@version" ) , "94: " + getCheckMessage ( MISSING_TAG , "@version" ) , } ; verify ( checkConfig , getPath ( "InputJavadoc.java" ) , expected ) ; } @ Test public void testVersionRegularExError ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "versionFormat" , "\\$Revision.*\\$" ) ; final String [ ] expected = { "13: " + getCheckMessage ( TAG_FORMAT , "@version" , "\\$Revision.*\\$" ) , "22: " + getCheckMessage ( MISSING_TAG , "@version" ) , "31: " + getCheckMessage ( TAG_FORMAT , "@version" , "\\$Revision.*\\$" ) , "40: " + getCheckMessage ( TAG_FORMAT , "@version" , "\\$Revision.*\\$" ) , "49: " + getCheckMessage ( TAG_FORMAT , "@version" , "\\$Revision.*\\$" ) , "58: " + getCheckMessage ( MISSING_TAG , "@version" ) , "67: " + getCheckMessage ( TAG_FORMAT , "@version" , "\\$Revision.*\\$" ) , "76: " + getCheckMessage ( TAG_FORMAT , "@version" , "\\$Revision.*\\$" ) , "85: " + getCheckMessage ( TAG_FORMAT , "@version" , "\\$Revision.*\\$" ) , "94: " + getCheckMessage ( MISSING_TAG , "@version" ) , "103: " + getCheckMessage ( TAG_FORMAT , "@version" , "\\$Revision.*\\$" ) , "112: " + getCheckMessage ( TAG_FORMAT , "@version" , "\\$Revision.*\\$" ) , } ; verify ( checkConfig , getPath ( "InputJavadoc.java" ) , expected ) ; } @ Test public void testScopes ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; final String [ ] expected = { "3: " + getCheckMessage ( JAVADOC_MISSING ) , "15: " + getCheckMessage ( JAVADOC_MISSING ) , "27: " + getCheckMessage ( JAVADOC_MISSING ) , "39: " + getCheckMessage ( JAVADOC_MISSING ) , "52: " + getCheckMessage ( JAVADOC_MISSING ) , "63: " + getCheckMessage ( JAVADOC_MISSING ) , "75: " + getCheckMessage ( JAVADOC_MISSING ) , "87: " + getCheckMessage ( JAVADOC_MISSING ) , "99: " + getCheckMessage ( JAVADOC_MISSING ) , "111: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputNoJavadoc.java" ) , expected ) ; } @ Test public void testScopes2 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "scope" , Scope . PROTECTED . getName ( ) ) ; final String [ ] expected = { "3: " + getCheckMessage ( JAVADOC_MISSING ) , "15: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputNoJavadoc.java" ) , expected ) ; } @ Test public void testExcludeScope ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "scope" , Scope . PRIVATE . getName ( ) ) ; checkConfig . addAttribute ( "excludeScope" , Scope . PROTECTED . getName ( ) ) ; final String [ ] expected = { "27: " + getCheckMessage ( JAVADOC_MISSING ) , "39: " + getCheckMessage ( JAVADOC_MISSING ) , "52: " + getCheckMessage ( JAVADOC_MISSING ) , "63: " + getCheckMessage ( JAVADOC_MISSING ) , "75: " + getCheckMessage ( JAVADOC_MISSING ) , "87: " + getCheckMessage ( JAVADOC_MISSING ) , "99: " + getCheckMessage ( JAVADOC_MISSING ) , "111: " + getCheckMessage ( JAVADOC_MISSING ) , } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputNoJavadoc.java" ) , expected ) ; } @ Test public void testTypeParameters ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; final String [ ] expected = { "7:4: " + getCheckMessage ( UNUSED_TAG , "@param" , "<D123>" ) , "11: " + getCheckMessage ( MISSING_TAG , "@param <C456>" ) , } ; verify ( checkConfig , getPath ( "InputTypeParamsTags.java" ) , expected ) ; } @ Test public void testAllowMissingTypeParameters ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "allowMissingParamTags" , "true" ) ; final String [ ] expected = { "7:4: " + getCheckMessage ( UNUSED_TAG , "@param" , "<D123>" ) , } ; verify ( checkConfig , getPath ( "InputTypeParamsTags.java" ) , expected ) ; } @ Test public void testBadTag ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; final String [ ] expected = { "5:4: " + getCheckMessage ( UNKNOWN_TAG , "mytag" ) , } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputBadTag.java" ) , expected ) ; } @ Test public void testBadTagSuppress ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocTypeCheck . class ) ; checkConfig . addAttribute ( "allowUnknownTags" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "javadoc" + File . separator + "InputBadTag.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . nio . charset . Charset ; import org . antlr . v4 . runtime . ANTLRInputStream ; import org . antlr . v4 . runtime . BaseErrorListener ; import org . antlr . v4 . runtime . CommonTokenStream ; import org . antlr . v4 . runtime . RecognitionException ; import org . antlr . v4 . runtime . Recognizer ; import org . antlr . v4 . runtime . tree . ParseTree ; import org . junit . Assert ; import org . junit . Test ; import com . google . common . base . Charsets ; import com . google . common . io . Files ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocLexer ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser ; public class JavadocParseTreeTest { private final File folderWithInputFiles = new File ( "src/test/resources/com/puppycrawl/tools/checkstyle/grammars/javadoc" ) ; private JavadocParser parser ; private final BaseErrorListener errorListener = new FailOnErrorListener ( ) ; public ParseTree parseJavadoc ( String aBlockComment ) throws IOException { final Charset utf8Charset = Charset . forName ( "UTF-8" ) ; final InputStream in = new ByteArrayInputStream ( aBlockComment . getBytes ( utf8Charset ) ) ; final ANTLRInputStream input = new ANTLRInputStream ( in ) ; final JavadocLexer lexer = new JavadocLexer ( input ) ; lexer . removeErrorListeners ( ) ; lexer . addErrorListener ( errorListener ) ; final CommonTokenStream tokens = new CommonTokenStream ( lexer ) ; parser = new JavadocParser ( tokens ) ; parser . removeErrorListeners ( ) ; parser . addErrorListener ( errorListener ) ; return parser . javadoc ( ) ; } public static String getFileContent ( File filename ) throws IOException { return Files . toString ( filename , Charsets . UTF_8 ) ; } @ Test public void oneSimpleHtmlTag ( ) throws IOException { String filename = folderWithInputFiles + "/htmlTags/OneSimpleHtmlTag.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeOneSimpleHtmlTag ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void textBeforeJavadocTags ( ) throws IOException { String filename = folderWithInputFiles + "/javadocTags/TextBeforeJavadocTags.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeTextBeforeJavadocTags ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void customJavadocTags ( ) throws IOException { String filename = folderWithInputFiles + "/javadocTags/CustomJavadocTags.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeCustomJavadocTags ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void javadocTagDescriptionWithInlineTags ( ) throws IOException { String filename = folderWithInputFiles + "/javadocTags/JavadocTagDescriptionWithInlineTags.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeJavadocTagDescriptionWithInlineTags ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void leadingAsterisks ( ) throws IOException { String filename = folderWithInputFiles + "/LeadingAsterisks.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeLeadingAsterisks ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void authorWithMailto ( ) throws IOException { String filename = folderWithInputFiles + "/javadocTags/AuthorWithMailto.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeAuthorWithMailto ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void htmlTagsInParagraph ( ) throws IOException { String filename = folderWithInputFiles + "/htmlTags/HtmlTagsInParagraph.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeHtmlTagsInParagraph ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void linkInlineTags ( ) throws IOException { String filename = folderWithInputFiles + "/javadocTags/LinkInlineTags.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeLinkInlineTags ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void seeReferenceWithFewNestedClasses ( ) throws IOException { String filename = folderWithInputFiles + "/javadocTags/SeeReferenceWithFewNestedClasses.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeSeeReferenceWithFewNestedClasses ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void paramWithGeneric ( ) throws IOException { String filename = folderWithInputFiles + "/javadocTags/ParamWithGeneric.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeParamWithGeneric ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void serial ( ) throws IOException { String filename = folderWithInputFiles + "/javadocTags/Serial.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeSerial ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void since ( ) throws IOException { String filename = folderWithInputFiles + "/javadocTags/Since.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeSince ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void unclosedAndClosedParagraphs ( ) throws IOException { String filename = folderWithInputFiles + "/htmlTags/UnclosedAndClosedParagraphs.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeUnclosedAndClosedParagraphs ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void listWithUnclosedItemInUnclosedParagraph ( ) throws IOException { String filename = folderWithInputFiles + "/htmlTags/ListWithUnclosedItemInUnclosedParagraph.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeListWithUnclosedItemInUnclosedParagraph ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void unclosedParagraphFollowedByJavadocTag ( ) throws IOException { String filename = folderWithInputFiles + "/htmlTags/UnclosedParagraphFollowedByJavadocTag.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeUnclosedParagraphFollowedByJavadocTag ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void allJavadocInlineTags ( ) throws IOException { String filename = folderWithInputFiles + "/javadocTags/AllJavadocInlineTags.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeAllJavadocInlineTags ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void docRootInheritDoc ( ) throws IOException { String filename = folderWithInputFiles + "/javadocTags/DocRootInheritDoc.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeDocRootInheritDoc ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void fewWhiteSpacesAsSeparator ( ) throws IOException { String filename = folderWithInputFiles + "/javadocTags/FewWhiteSpacesAsSeparator.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeFewWhiteSpacesAsSeparator ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void mixedCaseOfHtmlTags ( ) throws IOException { String filename = folderWithInputFiles + "/htmlTags/MixedCaseOfHtmlTags.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeMixedCaseOfHtmlTags ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void htmlComments ( ) throws IOException { String filename = folderWithInputFiles + "/htmlTags/Comments.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeComments ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void negativeNumberInAttribute ( ) throws IOException { String filename = folderWithInputFiles + "/htmlTags/NegativeNumberInAttribute.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeNegativeNumberInAttribute ( ) ; compareTrees ( expectedTree , generatedTree ) ; } @ Test public void dollarInLink ( ) throws IOException { String filename = folderWithInputFiles + "/javadocTags/DollarInLink.txt" ; ParseTree generatedTree = parseJavadoc ( getFileContent ( new File ( filename ) ) ) ; ParseTree expectedTree = ParseTreeBuilder . treeDollarInLink ( ) ; compareTrees ( expectedTree , generatedTree ) ; } private void compareTrees ( ParseTree t1 , ParseTree t2 ) { Assert . assertEquals ( t1 . toStringTree ( parser ) , t2 . toStringTree ( parser ) ) ; } public static class FailOnErrorListener extends BaseErrorListener { @ Override public void syntaxError ( Recognizer < ? , ? > aRecognizer , Object aOffendingSymbol , int aLine , int aCharPositionInLine , String aMsg , RecognitionException aEx ) { Assert . fail ( "[" + aLine + ", " + aCharPositionInLine + "] " + aMsg ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNull ; import org . junit . Before ; import org . junit . Test ; public class PkgControlRegExpTest { private final PkgControl pcRoot = new PkgControl ( "com.kazgroup.courtlink" ) ; private final PkgControl pcCommon = new PkgControl ( pcRoot , "common" ) ; @ Before public void setUp ( ) throws Exception { pcRoot . addGuard ( new Guard ( false , false , ".*\\.(spring|lui)framework" , false , true ) ) ; pcRoot . addGuard ( new Guard ( false , false , "org\\.hibernate" , false , true ) ) ; pcRoot . addGuard ( new Guard ( true , false , "org\\.(apache|lui)\\.commons" , false , true ) ) ; pcCommon . addGuard ( new Guard ( true , false , "org\\.h.*" , false , true ) ) ; } @ Test public void testFullPkg ( ) { assertEquals ( "com.kazgroup.courtlink" , pcRoot . getFullPackage ( ) ) ; assertEquals ( "com.kazgroup.courtlink.common" , pcCommon . getFullPackage ( ) ) ; } @ Test public void testLocateFinest ( ) { assertEquals ( pcRoot , pcRoot . locateFinest ( "com.kazgroup.courtlink.domain" ) ) ; assertEquals ( pcCommon , pcRoot . locateFinest ( "com.kazgroup.courtlink.common.api" ) ) ; assertNull ( pcRoot . locateFinest ( "com" ) ) ; } @ Test public void testCheckAccess ( ) { assertEquals ( AccessResult . DISALLOWED , pcCommon . checkAccess ( "org.springframework.something" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . DISALLOWED , pcCommon . checkAccess ( "org.luiframework.something" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . DISALLOWED , pcCommon . checkAccess ( "de.springframework.something" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . DISALLOWED , pcCommon . checkAccess ( "de.luiframework.something" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . ALLOWED , pcCommon . checkAccess ( "org.apache.commons.something" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . ALLOWED , pcCommon . checkAccess ( "org.lui.commons.something" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . DISALLOWED , pcCommon . checkAccess ( "org.apache.commons" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . DISALLOWED , pcCommon . checkAccess ( "org.lui.commons" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . ALLOWED , pcCommon . checkAccess ( "org.hibernate.something" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . DISALLOWED , pcCommon . checkAccess ( "com.badpackage.something" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . DISALLOWED , pcRoot . checkAccess ( "org.hibernate.something" , "com.kazgroup.courtlink" ) ) ; } @ Test public void testUnknownPkg ( ) { assertNull ( pcRoot . locateFinest ( "net.another" ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNull ; import org . junit . Before ; import org . junit . Test ; public class PkgControlTest { private final PkgControl pcRoot = new PkgControl ( "com.kazgroup.courtlink" ) ; private final PkgControl pcCommon = new PkgControl ( pcRoot , "common" ) ; @ Before public void setUp ( ) throws Exception { pcRoot . addGuard ( new Guard ( false , false , "org.springframework" , false , false ) ) ; pcRoot . addGuard ( new Guard ( false , false , "org.hibernate" , false , false ) ) ; pcRoot . addGuard ( new Guard ( true , false , "org.apache.commons" , false , false ) ) ; pcCommon . addGuard ( new Guard ( true , false , "org.hibernate" , false , false ) ) ; } @ Test public void testFullPkg ( ) { assertEquals ( "com.kazgroup.courtlink" , pcRoot . getFullPackage ( ) ) ; assertEquals ( "com.kazgroup.courtlink.common" , pcCommon . getFullPackage ( ) ) ; } @ Test public void testLocateFinest ( ) { assertEquals ( pcRoot , pcRoot . locateFinest ( "com.kazgroup.courtlink.domain" ) ) ; assertEquals ( pcCommon , pcRoot . locateFinest ( "com.kazgroup.courtlink.common.api" ) ) ; assertNull ( pcRoot . locateFinest ( "com" ) ) ; } @ Test public void testCheckAccess ( ) { assertEquals ( AccessResult . DISALLOWED , pcCommon . checkAccess ( "org.springframework.something" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . ALLOWED , pcCommon . checkAccess ( "org.apache.commons.something" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . DISALLOWED , pcCommon . checkAccess ( "org.apache.commons" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . ALLOWED , pcCommon . checkAccess ( "org.hibernate.something" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . DISALLOWED , pcCommon . checkAccess ( "com.badpackage.something" , "com.kazgroup.courtlink.common" ) ) ; assertEquals ( AccessResult . DISALLOWED , pcRoot . checkAccess ( "org.hibernate.something" , "com.kazgroup.courtlink" ) ) ; } @ Test public void testUnknownPkg ( ) { assertNull ( pcRoot . locateFinest ( "net.another" ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import org . junit . Test ; public class GuardTest { @ Test public void testPkgGuard1 ( ) { final Guard g = new Guard ( true , false , "pkg" , false , false ) ; assertNotNull ( g ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "asda" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "p" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkga" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "pkg.a" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "pkg.a.b" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg" ) ) ; } @ Test public void testPkgGuard2 ( ) { final Guard g = new Guard ( true , false , "pkg" , true , false ) ; assertNotNull ( g ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "asda" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "p" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "pkg.a" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg.a.b" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg" ) ) ; } @ Test public void testClassGuard ( ) { final Guard g = new Guard ( true , false , "pkg.a" , false ) ; assertNotNull ( g ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "asda" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "p" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkga" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "pkg.a" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg.a.b" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg" ) ) ; } @ Test public void testPkgGuard1re ( ) { final Guard g = new Guard ( true , false , "pkg" , false , true ) ; assertNotNull ( g ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "asda" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "p" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkga" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "pkg.a" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "pkg.a.b" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg" ) ) ; } @ Test public void testPkgGuard2re ( ) { final Guard g = new Guard ( true , false , "pkg" , true , true ) ; assertNotNull ( g ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "asda" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "p" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "pkg.a" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg.a.b" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg" ) ) ; } @ Test public void testClassGuardre ( ) { final Guard g = new Guard ( true , false , "pkg.a" , true ) ; assertNotNull ( g ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "asda" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "p" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkga" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "pkg.a" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg.a.b" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg" ) ) ; } @ Test public void testPkgGuard1re2 ( ) { final Guard g = new Guard ( true , false , "(pkg|hallo)" , false , true ) ; assertNotNull ( g ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "asda" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "p" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkga" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "pkg.a" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "pkg.a.b" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "halloa" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "hallo.a" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "hallo.a.b" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "hallo" ) ) ; } @ Test public void testPkgGuard2re2 ( ) { final Guard g = new Guard ( true , false , "(pkg|hallo)" , true , true ) ; assertNotNull ( g ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "asda" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "p" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "pkg.a" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg.a.b" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "hallo.a" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "hallo.a.b" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "hallo" ) ) ; } @ Test public void testClassGuardre2 ( ) { final Guard g = new Guard ( true , false , "pk[gx]\\.a" , true ) ; assertNotNull ( g ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "asda" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "p" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkga" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "pkg.a" ) ) ; assertEquals ( AccessResult . ALLOWED , g . verifyImport ( "pkx.a" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg.a.b" ) ) ; assertEquals ( AccessResult . UNKNOWN , g . verifyImport ( "pkg" ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import static org . junit . Assert . assertNotNull ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import java . io . File ; import org . junit . Test ; public class ImportControlLoaderTest { @ Test public void testLoad ( ) throws CheckstyleException { final PkgControl root = ImportControlLoader . load ( new File ( "src/test/resources/com/puppycrawl/tools/checkstyle/import-control_complete.xml" ) . toURI ( ) ) ; assertNotNull ( root ) ; } }
package com . puppycrawl . tools . checkstyle ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . fail ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . checks . naming . ConstantNameCheck ; import java . util . HashSet ; import org . junit . Test ; public class PackageObjectFactoryTest { private final PackageObjectFactory factory = new PackageObjectFactory ( new HashSet < String > ( ) , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; @ Test public void testMakeObjectFromName ( ) throws CheckstyleException { final Checker checker = ( Checker ) factory . createModule ( "com.puppycrawl.tools.checkstyle.Checker" ) ; assertNotNull ( checker ) ; } @ Test public void testMakeCheckFromName ( ) throws CheckstyleException { final ConstantNameCheck check = ( ConstantNameCheck ) factory . createModule ( "com.puppycrawl.tools.checkstyle.checks.naming.ConstantName" ) ; assertNotNull ( check ) ; } @ Test public void testMakeObectFromList ( ) throws CheckstyleException { factory . addPackage ( "com." ) ; final Checker checker = ( Checker ) factory . createModule ( "puppycrawl.tools.checkstyle.Checker" ) ; assertNotNull ( checker ) ; } @ Test public void testMakeObectNoClass ( ) { try { factory . createModule ( "NoClass" ) ; fail ( "Instantiated non-existant class" ) ; } catch ( CheckstyleException ex ) { assertEquals ( "CheckstyleException.message" , "Unable to instantiate NoClass" , ex . getMessage ( ) ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . io . File ; import java . lang . reflect . Method ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . imports . CustomImportOrderCheck . MSG_LEX ; import static com . puppycrawl . tools . checkstyle . checks . imports . CustomImportOrderCheck . MSG_LINE_SEPARATOR ; import static com . puppycrawl . tools . checkstyle . checks . imports . CustomImportOrderCheck . MSG_NONGROUP_IMPORT ; import static com . puppycrawl . tools . checkstyle . checks . imports . CustomImportOrderCheck . MSG_ORDER ; import static org . junit . Assert . assertArrayEquals ; import static org . junit . Assert . assertEquals ; public class CustomImportOrderCheckTest extends BaseCheckTestSupport { @ Test public void testCustom ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "standardPackageRegExp" , "^(java|javax)\\." ) ; checkConfig . addAttribute ( "thirdPartyPackageRegExp" , "com|org" ) ; checkConfig . addAttribute ( "customImportOrderRules" , "STATIC###SAME_PACKAGE(3)###THIRD_PARTY_PACKAGE###STANDARD_JAVA_PACKAGE" ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "true" ) ; final String [ ] expected = { "4: " + getCheckMessage ( MSG_LEX , "java.awt.Button.ABORT" ) , "8: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "9: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "10: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "11: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "12: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "13: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "14: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "15: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "16: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "17: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "18: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputCustomImportOrder.java" ) , expected ) ; } @ Test public void testGoogleStyleguideConfiguraiton ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "thirdPartyPackageRegExp" , "com.|org." ) ; checkConfig . addAttribute ( "customImportOrderRules" , "STATIC###STANDARD_JAVA_PACKAGE###THIRD_PARTY_PACKAGE" ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "true" ) ; final String [ ] expected = { "4: " + getCheckMessage ( MSG_LEX , "java.awt.Button.ABORT" ) , "10: " + getCheckMessage ( MSG_LEX , "java.awt.Dialog" ) , "15: " + getCheckMessage ( MSG_LEX , "java.io.File" ) , "22: " + getCheckMessage ( MSG_LEX , "com.google.common.collect.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputCustomImportOrder.java" ) , expected ) ; } @ Test public void testNonSpecifiedImports ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "thirdPartyPackageRegExp" , "org." ) ; checkConfig . addAttribute ( "customImportOrderRules" , "STATIC###STANDARD_JAVA_PACKAGE###THIRD_PARTY_PACKAGE###SAME_PACKAGE(3)" ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "true" ) ; final String [ ] expected = { "4: " + getCheckMessage ( MSG_LEX , "java.awt.Button.ABORT" ) , "10: " + getCheckMessage ( MSG_LEX , "java.awt.Dialog" ) , "15: " + getCheckMessage ( MSG_LEX , "java.io.File" ) , "20: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "22: " + getCheckMessage ( MSG_NONGROUP_IMPORT ) , "23: " + getCheckMessage ( MSG_LINE_SEPARATOR , "org.junit.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputCustomImportOrder.java" ) , expected ) ; } @ Test public void testOrderRuleWithOneGroup ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "thirdPartyPackageRegExp" , "org." ) ; checkConfig . addAttribute ( "customImportOrderRules" , "STANDARD_JAVA_PACKAGE" ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "true" ) ; final String [ ] expected = { "7: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "8: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "9: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "10: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "11: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputCustomImportOrder2.java" ) , expected ) ; } @ Test public void testSamePackageAndStatic ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "thirdPartyPackageRegExp" , "org." ) ; checkConfig . addAttribute ( "customImportOrderRules" , "STATIC###SAME_PACKAGE(3)" ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "true" ) ; final String [ ] expected = { "4: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "5: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "6: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "7: " + getCheckMessage ( MSG_ORDER , "STATIC" ) , "8: " + getCheckMessage ( MSG_ORDER , "STATIC" ) , "10: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "11: " + getCheckMessage ( MSG_ORDER , "STATIC" ) , } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/imports/" + "InputCustomImportOrderSamePackage.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testOnlySamePackage ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "customImportOrderRules" , "SAME_PACKAGE(3)" ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "true" ) ; final String [ ] expected = { "4: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "6: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "7: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "8: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "9: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/imports/" + "InputCustomImportOrderSamePackage2.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithoutLineSeparator ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "thirdPartyPackageRegExp" , "org." ) ; checkConfig . addAttribute ( "separateLineBetweenGroups" , "false" ) ; checkConfig . addAttribute ( "customImportOrderRules" , "STATIC###SAME_PACKAGE(3)" ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "true" ) ; final String [ ] expected = { "4: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "5: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "6: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "7: " + getCheckMessage ( MSG_ORDER , "STATIC" ) , "8: " + getCheckMessage ( MSG_ORDER , "STATIC" ) , "10: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "11: " + getCheckMessage ( MSG_ORDER , "STATIC" ) , } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/imports/" + "InputCustomImportOrderSamePackage.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testNoValid ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "thirdPartyPackageRegExp" , ".*" ) ; checkConfig . addAttribute ( "specialImportsRegExp" , "com.google" ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "true" ) ; checkConfig . addAttribute ( "customImportOrderRules" , "STATIC###SPECIAL_IMPORTS###THIRD_PARTY_PACKAGE###STANDARD_JAVA_PACKAGE" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputCustomImportOrderNoValid.java" ) , expected ) ; } @ Test public void testPossibleIndexOutOfBoundsException ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "thirdPartyPackageRegExp" , ".*" ) ; checkConfig . addAttribute ( "specialImportsRegExp" , "com.google" ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "true" ) ; checkConfig . addAttribute ( "customImportOrderRules" , "STATIC###SPECIAL_IMPORTS###THIRD_PARTY_PACKAGE###STANDARD_JAVA_PACKAGE" ) ; final String [ ] expected = { "5: " + getCheckMessage ( MSG_ORDER , "THIRD_PARTY_PACKAGE" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "DOMSource.java" ) , expected ) ; } @ Test public void testDefaultPackage2 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "thirdPartyPackageRegExp" , "com|org" ) ; checkConfig . addAttribute ( "customImportOrderRules" , "STATIC###SAME_PACKAGE(3)###THIRD_PARTY_PACKAGE###STANDARD_JAVA_PACKAGE" ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "true" ) ; final String [ ] expected = { "7: " + getCheckMessage ( MSG_LEX , "java.awt.Button.ABORT" ) , "10: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "11: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "12: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "13: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "14: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "15: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "16: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "17: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "18: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "19: " + getCheckMessage ( MSG_ORDER , "STANDARD_JAVA_PACKAGE" ) , "23: " + getCheckMessage ( MSG_LEX , "com.google.common.*" ) , } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/imports/InputDefaultPackage.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithoutThirdPartyPackage ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "true" ) ; checkConfig . addAttribute ( "separateLineBetweenGroups" , "true" ) ; checkConfig . addAttribute ( "customImportOrderRules" , "SAME_PACKAGE(3)###THIRD_PARTY_PACKAGE###STANDARD_JAVA_PACKAGE###STATIC" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputCustomImportOrderThirdPartyPackage.java" ) , expected ) ; } @ Test public void testThirdPartyAndSpecialImports ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "specialImportsRegExp" , "antlr.*" ) ; checkConfig . addAttribute ( "customImportOrderRules" , "SAME_PACKAGE(3)###THIRD_PARTY_PACKAGE###STATIC###" + "SPECIAL_IMPORTS" ) ; final String [ ] expected = { "11: " + getCheckMessage ( MSG_ORDER , "THIRD_PARTY_PACKAGE" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputCustomImportOrderThirdPartyAndSpecial.java" ) , expected ) ; } @ Test public void testImportsContainingJava ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "customImportOrderRules" , "STANDARD_JAVA_PACKAGE###THIRD_PARTY_PACKAGE" ) ; final String [ ] expected = { "5: " + getCheckMessage ( MSG_LINE_SEPARATOR , "com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputCustomImportOrderImportsContainingJava.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { CustomImportOrderCheck testCheckObject = new CustomImportOrderCheck ( ) ; int [ ] actual = testCheckObject . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT , TokenTypes . PACKAGE_DEF , } ; assertArrayEquals ( expected , actual ) ; } @ Test public void testGetFullImportIdent ( ) { Object actual ; try { Class < ? > c = Class . forName ( "com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck" ) ; Object t = c . newInstance ( ) ; Method m = c . getDeclaredMethod ( "getFullImportIdent" , DetailAST . class ) ; m . setAccessible ( true ) ; actual = m . invoke ( t , ( DetailAST ) null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; actual = null ; } String expected = "" ; assertEquals ( expected , ( String ) actual ) ; } @ Test ( expected = CheckstyleException . class ) public void testSamePackageDepthNegative ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "false" ) ; checkConfig . addAttribute ( "separateLineBetweenGroups" , "false" ) ; checkConfig . addAttribute ( "customImportOrderRules" , "SAME_PACKAGE(-1)" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputCustomImportOrder.java" ) , expected ) ; } @ Test ( expected = CheckstyleException . class ) public void testSamePackageDepthZero ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "false" ) ; checkConfig . addAttribute ( "separateLineBetweenGroups" , "false" ) ; checkConfig . addAttribute ( "customImportOrderRules" , "SAME_PACKAGE(0)" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputCustomImportOrder.java" ) , expected ) ; } @ Test ( expected = CheckstyleException . class ) public void testUnsupportedRule ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "customImportOrderRules" , "SAME_PACKAGE(3)###UNSUPPORTED_RULE" ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "true" ) ; final String [ ] expected = { "4: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "6: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "7: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "8: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , "9: " + getCheckMessage ( MSG_ORDER , "SAME_PACKAGE" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputCustomImportOrder.java" ) , expected ) ; } @ Test ( expected = CheckstyleException . class ) public void testSamePackageDepthNotInt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "customImportOrderRules" , "SAME_PACKAGE(INT_IS_REQUIRED_HERE)" ) ; checkConfig . addAttribute ( "sortImportsInGroupAlphabetically" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputCustomImportOrder.java" ) , expected ) ; } @ Test public void testNoImports ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CustomImportOrderCheck . class ) ; checkConfig . addAttribute ( "customImportOrderRules" , "SAME_PACKAGE(3)" ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources/com/puppycrawl/tools/" + "checkstyle/imports/" + "InputCustomImportOrder_NoImports.java" ) . getCanonicalPath ( ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . imports . ImportOrderCheck . MSG_ORDERING ; import static com . puppycrawl . tools . checkstyle . checks . imports . ImportOrderCheck . MSG_SEPARATION ; public class ImportOrderCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; final String [ ] expected = { "5: " + getCheckMessage ( MSG_ORDERING , "java.awt.Dialog" ) , "9: " + getCheckMessage ( MSG_ORDERING , "javax.swing.JComponent" ) , "11: " + getCheckMessage ( MSG_ORDERING , "java.io.File" ) , "13: " + getCheckMessage ( MSG_ORDERING , "java.io.IOException" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrder.java" ) , expected ) ; } @ Test public void testGroups ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "groups" , "java.awt" ) ; checkConfig . addAttribute ( "groups" , "javax.swing" ) ; checkConfig . addAttribute ( "groups" , "java.io" ) ; final String [ ] expected = { "5: " + getCheckMessage ( MSG_ORDERING , "java.awt.Dialog" ) , "13: " + getCheckMessage ( MSG_ORDERING , "java.io.IOException" ) , "16: " + getCheckMessage ( MSG_ORDERING , "javax.swing.WindowConstants.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrder.java" ) , expected ) ; } @ Test public void testGroupsRegexp ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "groups" , "java, /^javax?\\.(awt|swing)\\./" ) ; checkConfig . addAttribute ( "ordered" , "false" ) ; final String [ ] expected = { "11: " + getCheckMessage ( MSG_ORDERING , "java.io.File" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrder.java" ) , expected ) ; } @ Test public void testSeparated ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "groups" , "java.awt, javax.swing, java.io" ) ; checkConfig . addAttribute ( "separated" , "true" ) ; checkConfig . addAttribute ( "ordered" , "false" ) ; final String [ ] expected = { "9: " + getCheckMessage ( MSG_SEPARATION , "javax.swing.JComponent" ) , "11: " + getCheckMessage ( MSG_SEPARATION , "java.io.File" ) , "16: " + getCheckMessage ( MSG_ORDERING , "javax.swing.WindowConstants.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrder.java" ) , expected ) ; } @ Test public void testCaseInsensitive ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "caseSensitive" , "false" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrderCaseInsensitive.java" ) , expected ) ; } @ Test public void testTop ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "top" ) ; final String [ ] expected = { "4: " + getCheckMessage ( MSG_ORDERING , "java.awt.Button.ABORT" ) , "18: " + getCheckMessage ( MSG_ORDERING , "java.io.File.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrder_Top.java" ) , expected ) ; } @ Test public void testAbove ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "above" ) ; final String [ ] expected = { "5: " + getCheckMessage ( MSG_ORDERING , "java.awt.Button.ABORT" ) , "8: " + getCheckMessage ( MSG_ORDERING , "java.awt.Dialog" ) , "13: " + getCheckMessage ( MSG_ORDERING , "java.io.File" ) , "14: " + getCheckMessage ( MSG_ORDERING , "java.io.File.createTempFile" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrder_Above.java" ) , expected ) ; } @ Test public void testInFlow ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "inflow" ) ; final String [ ] expected = { "6: " + getCheckMessage ( MSG_ORDERING , "java.awt.Dialog" ) , "11: " + getCheckMessage ( MSG_ORDERING , "javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE" ) , "12: " + getCheckMessage ( MSG_ORDERING , "javax.swing.WindowConstants.*" ) , "13: " + getCheckMessage ( MSG_ORDERING , "javax.swing.JTable" ) , "15: " + getCheckMessage ( MSG_ORDERING , "java.io.File.createTempFile" ) , "16: " + getCheckMessage ( MSG_ORDERING , "java.io.File" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrder_InFlow.java" ) , expected ) ; } @ Test public void testUnder ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "under" ) ; final String [ ] expected = { "5: Wrong order for 'java.awt.Dialog' import." , "11: " + getCheckMessage ( MSG_ORDERING , "java.awt.Button.ABORT" ) , "14: " + getCheckMessage ( MSG_ORDERING , "java.io.File" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrder_Under.java" ) , expected ) ; } @ Test public void testBottom ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "bottom" ) ; final String [ ] expected = { "15: " + getCheckMessage ( MSG_ORDERING , "java.io.File" ) , "18: " + getCheckMessage ( MSG_ORDERING , "java.awt.Button.ABORT" ) , "21: " + getCheckMessage ( MSG_ORDERING , "java.io.Reader" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrder_Bottom.java" ) , expected ) ; } @ Test public void testHonorsTokenProperty ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "tokens" , "IMPORT" ) ; final String [ ] expected = { "6: " + getCheckMessage ( MSG_ORDERING , "java.awt.Button" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrder_HonorsTokensProperty.java" ) , expected ) ; } @ Test public void testWildcard ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "groups" , "com,*,java" ) ; final String [ ] expected = { "9: " + getCheckMessage ( MSG_ORDERING , "javax.crypto.Cipher" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrder_Wildcard.java" ) , expected ) ; } @ Test public void testWildcardUnspecified ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "groups" , "java,javax,org" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrder_WildcardUnspecified.java" ) , expected ) ; } @ Test public void testNoFailureForRedundantImports ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrder_NoFailureForRedundantImports.java" ) , expected ) ; } @ Test public void testStaticGroupsAlphabeticalOrder ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "top" ) ; checkConfig . addAttribute ( "groups" , "org, java" ) ; checkConfig . addAttribute ( "sortStaticImportsAlphabetically" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrderStaticGroupOrder.java" ) , expected ) ; } @ Test public void testStaticGroupsOrder ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "top" ) ; checkConfig . addAttribute ( "groups" , "org, java" ) ; final String [ ] expected = { "4: " + getCheckMessage ( MSG_ORDERING , "org.abego.treelayout.Configuration.AlignmentInLevel" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrderStaticGroupOrder.java" ) , expected ) ; } @ Test public void testStaticGroupsAlphabeticalOrderBottom ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "bottom" ) ; checkConfig . addAttribute ( "groups" , "org, java" ) ; checkConfig . addAttribute ( "sortStaticImportsAlphabetically" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrderStaticGroupOrderBottom.java" ) , expected ) ; } @ Test public void testStaticGroupsOrderBottom ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "bottom" ) ; checkConfig . addAttribute ( "groups" , "org, java" ) ; final String [ ] expected = { "8: " + getCheckMessage ( MSG_ORDERING , "org.abego.treelayout.Configuration.AlignmentInLevel" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrderStaticGroupOrderBottom.java" ) , expected ) ; } @ Test public void testStaticGroupsOrderAbove ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "above" ) ; checkConfig . addAttribute ( "groups" , "org, java" ) ; checkConfig . addAttribute ( "sortStaticImportsAlphabetically" , "true" ) ; final String [ ] expected = { "7: " + getCheckMessage ( MSG_ORDERING , "java.lang.Math.PI" ) , "8: " + getCheckMessage ( MSG_ORDERING , "org.abego.treelayout.Configuration.AlignmentInLevel" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrderStaticGroupOrderBottom.java" ) , expected ) ; } @ Test public void testStaticOnDemandGroupsOrder ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "top" ) ; checkConfig . addAttribute ( "groups" , "org, java" ) ; final String [ ] expected = { "4: " + getCheckMessage ( MSG_ORDERING , "org.abego.treelayout.Configuration.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrderStaticOnDemandGroupOrder.java" ) , expected ) ; } @ Test public void testStaticOnDemandGroupsAlphabeticalOrder ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "top" ) ; checkConfig . addAttribute ( "groups" , "org, java" ) ; checkConfig . addAttribute ( "sortStaticImportsAlphabetically" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrderStaticOnDemandGroupOrder.java" ) , expected ) ; } @ Test public void testStaticOnDemandGroupsOrderBottom ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "bottom" ) ; checkConfig . addAttribute ( "groups" , "org, java" ) ; final String [ ] expected = { "8: " + getCheckMessage ( MSG_ORDERING , "org.abego.treelayout.Configuration.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrderStaticOnDemandGroupOrderBottom.java" ) , expected ) ; } @ Test public void testStaticOnDemandGroupsAlphabeticalOrderBottom ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "bottom" ) ; checkConfig . addAttribute ( "groups" , "org, java" ) ; checkConfig . addAttribute ( "sortStaticImportsAlphabetically" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrderStaticOnDemandGroupOrderBottom.java" ) , expected ) ; } @ Test public void testStaticOnDemandGroupsOrderAbove ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportOrderCheck . class ) ; checkConfig . addAttribute ( "option" , "above" ) ; checkConfig . addAttribute ( "groups" , "org, java" ) ; checkConfig . addAttribute ( "sortStaticImportsAlphabetically" , "true" ) ; final String [ ] expected = { "7: " + getCheckMessage ( MSG_ORDERING , "java.lang.Math.*" ) , "8: " + getCheckMessage ( MSG_ORDERING , "org.abego.treelayout.Configuration.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportOrderStaticOnDemandGroupOrderBottom.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . imports . IllegalImportCheck . MSG_KEY ; import static org . junit . Assert . assertArrayEquals ; public class IllegalImportCheckTest extends BaseCheckTestSupport { @ Test public void testWithSupplied ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IllegalImportCheck . class ) ; checkConfig . addAttribute ( "illegalPkgs" , "java.io" ) ; final String [ ] expected = { "9:1: " + getCheckMessage ( MSG_KEY , "java.io.*" ) , "23:1: " + getCheckMessage ( MSG_KEY , "java.io.File.listRoots" ) , "27:1: " + getCheckMessage ( MSG_KEY , "java.io.File.createTempFile" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputIllegalImportCheck.java" ) , expected ) ; } @ Test public void testWithDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IllegalImportCheck . class ) ; final String [ ] expected = { "15:1: " + getCheckMessage ( MSG_KEY , "sun.applet.*" ) , "28:1: " + getCheckMessage ( MSG_KEY , "sun.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputIllegalImportCheck.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { IllegalImportCheck testCheckObject = new IllegalImportCheck ( ) ; int [ ] actual = testCheckObject . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT } ; assertArrayEquals ( expected , actual ) ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . imports . UnusedImportsCheck . MSG_KEY ; import static org . junit . Assert . assertArrayEquals ; public class UnusedImportsCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( UnusedImportsCheck . class ) ; final String [ ] expected = { "8:45: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.InputImportBug" ) , "11:8: " + getCheckMessage ( MSG_KEY , "java.lang.String" ) , "13:8: " + getCheckMessage ( MSG_KEY , "java.util.List" ) , "14:8: " + getCheckMessage ( MSG_KEY , "java.util.List" ) , "17:8: " + getCheckMessage ( MSG_KEY , "java.util.Enumeration" ) , "20:8: " + getCheckMessage ( MSG_KEY , "javax.swing.JToggleButton" ) , "22:8: " + getCheckMessage ( MSG_KEY , "javax.swing.BorderFactory" ) , "27:15: " + getCheckMessage ( MSG_KEY , "java.io.File.createTempFile" ) , "30:8: " + getCheckMessage ( MSG_KEY , "java.awt.Graphics2D" ) , "31:8: " + getCheckMessage ( MSG_KEY , "java.awt.HeadlessException" ) , "32:8: " + getCheckMessage ( MSG_KEY , "java.awt.Label" ) , "33:8: " + getCheckMessage ( MSG_KEY , "java.util.Date" ) , "34:8: " + getCheckMessage ( MSG_KEY , "java.util.Calendar" ) , "35:8: " + getCheckMessage ( MSG_KEY , "java.util.BitSet" ) , "37:8: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.Checker" ) , "38:8: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.CheckerTest" ) , "39:8: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.BaseFileSetCheckTestSupport" ) , "40:8: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.Definitions" ) , "41:8: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.Input15Extensions" ) , "42:8: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.ConfigurationLoaderTest" ) , "43:8: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.PackageNamesLoader" ) , "44:8: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.DefaultConfiguration" ) , "45:8: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.DefaultLogger" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputUnusedImportsCheck.java" ) , expected ) ; } @ Test public void testProcessJavadoc ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( UnusedImportsCheck . class ) ; checkConfig . addAttribute ( "processJavadoc" , "true" ) ; final String [ ] expected = { "8:45: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.InputImportBug" ) , "11:8: " + getCheckMessage ( MSG_KEY , "java.lang.String" ) , "13:8: " + getCheckMessage ( MSG_KEY , "java.util.List" ) , "14:8: " + getCheckMessage ( MSG_KEY , "java.util.List" ) , "17:8: " + getCheckMessage ( MSG_KEY , "java.util.Enumeration" ) , "20:8: " + getCheckMessage ( MSG_KEY , "javax.swing.JToggleButton" ) , "22:8: " + getCheckMessage ( MSG_KEY , "javax.swing.BorderFactory" ) , "27:15: " + getCheckMessage ( MSG_KEY , "java.io.File.createTempFile" ) , "32:8: " + getCheckMessage ( MSG_KEY , "java.awt.Label" ) , "45:8: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.DefaultLogger" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputUnusedImportsCheck.java" ) , expected ) ; } @ Test public void testAnnotations ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( UnusedImportsCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "package-info.java" ) , expected ) ; } @ Test public void testBug ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( UnusedImportsCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportBug.java" ) , expected ) ; } @ Test public void testGetRequiredTokens ( ) { UnusedImportsCheck testCheckObject = new UnusedImportsCheck ( ) ; int [ ] actual = testCheckObject . getRequiredTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . IDENT , TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT , TokenTypes . PACKAGE_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . ANNOTATION_FIELD_DEF , TokenTypes . ENUM_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . VARIABLE_DEF , } ; assertArrayEquals ( expected , actual ) ; } @ Test public void testGetAcceptableTokens ( ) { UnusedImportsCheck testCheckObject = new UnusedImportsCheck ( ) ; int [ ] actual = testCheckObject . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . IDENT , TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT , TokenTypes . PACKAGE_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . ANNOTATION_FIELD_DEF , TokenTypes . ENUM_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . VARIABLE_DEF , } ; assertArrayEquals ( expected , actual ) ; } @ Test public void testFileInUnnamedPackage ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( UnusedImportsCheck . class ) ; final String [ ] expected = { "3:8: " + getCheckMessage ( MSG_KEY , "java.util.Arrays" ) , "4:8: " + getCheckMessage ( MSG_KEY , "java.lang.String" ) , } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/imports/" + "InputRedundantImportCheck_UnnamedPackage.java" ) . getCanonicalPath ( ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . io . File ; import org . junit . Test ; import static org . junit . Assert . assertArrayEquals ; import static com . puppycrawl . tools . checkstyle . checks . imports . AvoidStaticImportCheck . MSG_KEY ; public class AvoidStaticImportTest extends BaseCheckTestSupport { @ Test public void testDefaultOperation ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AvoidStaticImportCheck . class ) ; final String [ ] expected = { "23: " + getCheckMessage ( MSG_KEY , "java.io.File.listRoots" ) , "25: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "26: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "27: " + getCheckMessage ( MSG_KEY , "java.io.File.createTempFile" ) , "28: " + getCheckMessage ( MSG_KEY , "java.io.File.pathSeparator" ) , "29: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.InputAvoidStaticImportNestedClass.InnerClass" ) , "30: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.InputAvoidStaticImportNestedClass.InnerClass.one" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputAvoidStaticImportCheck.java" ) , expected ) ; } @ Test public void testStarExcludes ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AvoidStaticImportCheck . class ) ; checkConfig . addAttribute ( "excludes" , "java.io.File.*,sun.net.ftpclient.FtpClient.*" ) ; final String [ ] expected = { "25: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "26: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "29: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.InputAvoidStaticImportNestedClass.InnerClass" ) , "30: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.InputAvoidStaticImportNestedClass.InnerClass.one" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputAvoidStaticImportCheck.java" ) , expected ) ; } @ Test public void testMemberExcludes ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AvoidStaticImportCheck . class ) ; checkConfig . addAttribute ( "excludes" , "java.io.File.listRoots" ) ; final String [ ] expected = { "25: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "26: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "27: " + getCheckMessage ( MSG_KEY , "java.io.File.createTempFile" ) , "28: " + getCheckMessage ( MSG_KEY , "java.io.File.pathSeparator" ) , "29: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.InputAvoidStaticImportNestedClass.InnerClass" ) , "30: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.InputAvoidStaticImportNestedClass.InnerClass.one" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputAvoidStaticImportCheck.java" ) , expected ) ; } @ Test public void testBogusMemberExcludes ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AvoidStaticImportCheck . class ) ; checkConfig . addAttribute ( "excludes" , "java.io.File.listRoots.listRoots, javax.swing.WindowConstants, javax.swing.*," + "sun.net.ftpclient.FtpClient.*FtpClient, sun.net.ftpclient.FtpClientjunk, java.io.File.listRootsmorejunk" ) ; final String [ ] expected = { "23: " + getCheckMessage ( MSG_KEY , "java.io.File.listRoots" ) , "25: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "26: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "27: " + getCheckMessage ( MSG_KEY , "java.io.File.createTempFile" ) , "28: " + getCheckMessage ( MSG_KEY , "java.io.File.pathSeparator" ) , "29: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.InputAvoidStaticImportNestedClass.InnerClass" ) , "30: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.InputAvoidStaticImportNestedClass.InnerClass.one" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputAvoidStaticImportCheck.java" ) , expected ) ; } @ Test public void testInnerClassMemberExcludesStar ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AvoidStaticImportCheck . class ) ; checkConfig . addAttribute ( "excludes" , "com.puppycrawl.tools.checkstyle.imports.InputAvoidStaticImportNestedClass.InnerClass.*" ) ; final String [ ] expected = { "23: " + getCheckMessage ( MSG_KEY , "java.io.File.listRoots" ) , "25: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "26: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "27: " + getCheckMessage ( MSG_KEY , "java.io.File.createTempFile" ) , "28: " + getCheckMessage ( MSG_KEY , "java.io.File.pathSeparator" ) , "29: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.InputAvoidStaticImportNestedClass.InnerClass" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputAvoidStaticImportCheck.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { AvoidStaticImportCheck testCheckObject = new AvoidStaticImportCheck ( ) ; int [ ] actual = testCheckObject . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . STATIC_IMPORT } ; assertArrayEquals ( expected , actual ) ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import static org . junit . Assert . assertArrayEquals ; import static org . junit . Assert . fail ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . imports . ImportControlCheck . MSG_DISALLOWED ; import static com . puppycrawl . tools . checkstyle . checks . imports . ImportControlCheck . MSG_UNKNOWN_PKG ; import static com . puppycrawl . tools . checkstyle . checks . imports . ImportControlCheck . MSG_MISSING_FILE ; public class ImportControlCheckTest extends BaseCheckTestSupport { @ Test public void testOne ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportControlCheck . class ) ; checkConfig . addAttribute ( "file" , "src/test/resources/com/puppycrawl/tools/checkstyle/import-control_one.xml" ) ; final String [ ] expected = { "5:1: " + getCheckMessage ( MSG_DISALLOWED , "java.io.File" ) } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportControl.java" ) , expected ) ; } @ Test public void testTwo ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportControlCheck . class ) ; checkConfig . addAttribute ( "file" , "src/test/resources/com/puppycrawl/tools/checkstyle/import-control_two.xml" ) ; final String [ ] expected = { "3:1: " + getCheckMessage ( MSG_DISALLOWED , "java.awt.Image" ) , "4:1: " + getCheckMessage ( MSG_DISALLOWED , "javax.swing.border.*" ) , "6:1: " + getCheckMessage ( MSG_DISALLOWED , "java.awt.Button.ABORT" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportControl.java" ) , expected ) ; } @ Test public void testWrong ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportControlCheck . class ) ; checkConfig . addAttribute ( "file" , "src/test/resources/com/puppycrawl/tools/checkstyle/import-control_wrong.xml" ) ; final String [ ] expected = { "1:40: " + getCheckMessage ( MSG_UNKNOWN_PKG ) } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportControl.java" ) , expected ) ; } @ Test public void testMissing ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportControlCheck . class ) ; final String [ ] expected = { "1:40: " + getCheckMessage ( MSG_MISSING_FILE ) } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportControl.java" ) , expected ) ; } @ Test public void testEmpty ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportControlCheck . class ) ; checkConfig . addAttribute ( "file" , " " ) ; final String [ ] expected = { "1:40: " + getCheckMessage ( MSG_MISSING_FILE ) } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportControl.java" ) , expected ) ; } @ Test public void testUnknown ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportControlCheck . class ) ; checkConfig . addAttribute ( "file" , "unknown-file" ) ; final String [ ] expected = { } ; try { verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportControl.java" ) , expected ) ; fail ( "should fail" ) ; } catch ( CheckstyleException ex ) { } } @ Test public void testBroken ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportControlCheck . class ) ; checkConfig . addAttribute ( "file" , "src/test/resources/com/puppycrawl/tools/checkstyle/import-control_broken.xml" ) ; final String [ ] expected = { } ; try { verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportControl.java" ) , expected ) ; fail ( "should fail" ) ; } catch ( CheckstyleException ex ) { } } @ Test public void testGetAcceptableTokens ( ) { ImportControlCheck testCheckObject = new ImportControlCheck ( ) ; int [ ] actual = testCheckObject . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . PACKAGE_DEF , TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT , } ; assertArrayEquals ( expected , actual ) ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . imports . ImportControlCheck . MSG_DISALLOWED ; public class ImportControlCheckRegExTest extends BaseCheckTestSupport { @ Test public void testOne ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportControlCheck . class ) ; checkConfig . addAttribute ( "file" , "src/test/resources/com/puppycrawl/tools/checkstyle/import-control_one-re.xml" ) ; final String [ ] expected = { "5:1: " + getCheckMessage ( MSG_DISALLOWED , "java.io.File" ) } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportControl.java" ) , expected ) ; } @ Test public void testTwo ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ImportControlCheck . class ) ; checkConfig . addAttribute ( "file" , "src/test/resources/com/puppycrawl/tools/checkstyle/import-control_two-re.xml" ) ; final String [ ] expected = { "3:1: " + getCheckMessage ( MSG_DISALLOWED , "java.awt.Image" ) , "4:1: " + getCheckMessage ( MSG_DISALLOWED , "javax.swing.border.*" ) , "6:1: " + getCheckMessage ( MSG_DISALLOWED , "java.awt.Button.ABORT" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputImportControl.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . imports . RedundantImportCheck . MSG_DUPLICATE ; import static com . puppycrawl . tools . checkstyle . checks . imports . RedundantImportCheck . MSG_LANG ; import static com . puppycrawl . tools . checkstyle . checks . imports . RedundantImportCheck . MSG_SAME ; import static org . junit . Assert . assertArrayEquals ; public class RedundantImportCheckTest extends BaseCheckTestSupport { @ Test public void testWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RedundantImportCheck . class ) ; final String [ ] expected = { "7:1: " + getCheckMessage ( MSG_SAME , "com.puppycrawl.tools.checkstyle.imports.*" ) , "8:1: " + getCheckMessage ( MSG_SAME , "com.puppycrawl.tools.checkstyle.imports.InputImportBug" ) , "10:1: " + getCheckMessage ( MSG_LANG , "java.lang.*" ) , "11:1: " + getCheckMessage ( MSG_LANG , "java.lang.String" ) , "14:1: " + getCheckMessage ( MSG_DUPLICATE , 13 , "java.util.List" ) , "26:1: " + getCheckMessage ( MSG_DUPLICATE , 25 , "javax.swing.WindowConstants.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputRedundantImportCheck.java" ) , expected ) ; } @ Test public void testUnnamedPackage ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RedundantImportCheck . class ) ; final String [ ] expected = { "2:1: " + getCheckMessage ( MSG_DUPLICATE , 1 , "java.util.List" ) , "4:1: " + getCheckMessage ( MSG_LANG , "java.lang.String" ) , } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/imports/" + "InputRedundantImportCheck_UnnamedPackage.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { RedundantImportCheck testCheckObject = new RedundantImportCheck ( ) ; int [ ] actual = testCheckObject . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT , TokenTypes . PACKAGE_DEF , } ; assertArrayEquals ( expected , actual ) ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import static org . junit . Assert . assertArrayEquals ; import static com . puppycrawl . tools . checkstyle . checks . imports . AvoidStarImportCheck . MSG_KEY ; public class AvoidStarImportTest extends BaseCheckTestSupport { @ Test public void testDefaultOperation ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AvoidStarImportCheck . class ) ; final String [ ] expected = { "7: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.*" ) , "9: " + getCheckMessage ( MSG_KEY , "java.io.*" ) , "10: " + getCheckMessage ( MSG_KEY , "java.lang.*" ) , "25: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "26: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "28: " + getCheckMessage ( MSG_KEY , "java.io.File.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputAvoidStarImportCheck.java" ) , expected ) ; } @ Test public void testExcludes ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AvoidStarImportCheck . class ) ; checkConfig . addAttribute ( "excludes" , "java.io,java.lang,javax.swing.WindowConstants.*, javax.swing.WindowConstants" ) ; final String [ ] expected2 = new String [ ] { "7: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.*" ) , "28: " + getCheckMessage ( MSG_KEY , "java.io.File.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputAvoidStarImportCheck.java" ) , expected2 ) ; } @ Test public void testAllowClassImports ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AvoidStarImportCheck . class ) ; checkConfig . addAttribute ( "allowClassImports" , "true" ) ; final String [ ] expected2 = new String [ ] { "25: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "26: " + getCheckMessage ( MSG_KEY , "javax.swing.WindowConstants.*" ) , "28: " + getCheckMessage ( MSG_KEY , "java.io.File.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputAvoidStarImportCheck.java" ) , expected2 ) ; } @ Test public void testAllowStaticMemberImports ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AvoidStarImportCheck . class ) ; checkConfig . addAttribute ( "allowStaticMemberImports" , "true" ) ; final String [ ] expected2 = new String [ ] { "7: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.imports.*" ) , "9: " + getCheckMessage ( MSG_KEY , "java.io.*" ) , "10: " + getCheckMessage ( MSG_KEY , "java.lang.*" ) , } ; verify ( checkConfig , getPath ( "imports" + File . separator + "InputAvoidStarImportCheck.java" ) , expected2 ) ; } @ Test public void testGetAcceptableTokens ( ) { AvoidStarImportCheck testCheckObject = new AvoidStarImportCheck ( ) ; int [ ] actual = testCheckObject . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT } ; assertArrayEquals ( expected , actual ) ; } @ Test public void testGetRequiredTokens ( ) { AvoidStarImportCheck testCheckObject = new AvoidStarImportCheck ( ) ; int [ ] actual = testCheckObject . getRequiredTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT } ; assertArrayEquals ( expected , actual ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; public class LineSetTest { @ Test public void testToStringShowingFirstAndLastLine ( ) { LineSet lineSet = new LineSet ( ) ; lineSet . addLineAndCol ( 0 , 1 ) ; lineSet . addLineAndCol ( 2 , 3 ) ; String result = lineSet . toString ( ) ; assertEquals ( "LineSet[firstLine=0, lastLine=2]" , result ) ; } }
package com . puppycrawl . tools . checkstyle ; import static org . junit . Assert . assertEquals ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import java . util . Arrays ; import java . util . Set ; import org . junit . Test ; public class PackageNamesLoaderTest { @ Test public void testDefault ( ) throws CheckstyleException { final Set < String > packageNames = PackageNamesLoader . getPackageNames ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; validatePackageNames ( packageNames ) ; } private void validatePackageNames ( Set < String > pkgNames ) { final String [ ] checkstylePackages = { "com.puppycrawl.tools.checkstyle." , "com.puppycrawl.tools.checkstyle.checks." , "com.puppycrawl.tools.checkstyle.checks.annotation." , "com.puppycrawl.tools.checkstyle.checks.blocks." , "com.puppycrawl.tools.checkstyle.checks.coding." , "com.puppycrawl.tools.checkstyle.checks.design." , "com.puppycrawl.tools.checkstyle.checks.header." , "com.puppycrawl.tools.checkstyle.checks.imports." , "com.puppycrawl.tools.checkstyle.checks.indentation." , "com.puppycrawl.tools.checkstyle.checks.javadoc." , "com.puppycrawl.tools.checkstyle.checks.metrics." , "com.puppycrawl.tools.checkstyle.checks.modifier." , "com.puppycrawl.tools.checkstyle.checks.naming." , "com.puppycrawl.tools.checkstyle.checks.regexp." , "com.puppycrawl.tools.checkstyle.checks.sizes." , "com.puppycrawl.tools.checkstyle.checks.whitespace." , "com.puppycrawl.tools.checkstyle.filters." , } ; assertEquals ( "pkgNames.length." , checkstylePackages . length , pkgNames . size ( ) ) ; final Set < String > checkstylePackagesSet = Sets . newHashSet ( Arrays . asList ( checkstylePackages ) ) ; assertEquals ( "names set." , checkstylePackagesSet , pkgNames ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class NewHandlerTest extends BaseCheckTestSupport { @ Test public void testInvalidLabel ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/indentation/NewHandlerTestInput.java" ) . getCanonicalPath ( ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import static com . puppycrawl . tools . checkstyle . checks . indentation . AbstractExpressionHandler . MSG_CHILD_ERROR ; import static com . puppycrawl . tools . checkstyle . checks . indentation . AbstractExpressionHandler . MSG_CHILD_ERROR_MULTI ; import static com . puppycrawl . tools . checkstyle . checks . indentation . AbstractExpressionHandler . MSG_ERROR ; import static com . puppycrawl . tools . checkstyle . checks . indentation . AbstractExpressionHandler . MSG_ERROR_MULTI ; import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . Utils ; public class IndentationCheckTest extends BaseCheckTestSupport { private static final Pattern NONEMPTY_LINE_REGEX = Pattern . compile ( ".*?\\S+.*?" ) ; private static final Pattern LINE_WITH_COMMENT_REGEX = Pattern . compile ( ".*?\\S+.*?(//indent:(\\d+) exp:((>=\\d+)|(\\d+(,\\d+)*?))( warn)?)" ) ; private static final Pattern GET_INDENT_FROM_COMMENT_REGEX = Pattern . compile ( "//indent:(\\d+).*?" ) ; private static final Pattern MULTILEVEL_COMMENT_REGEX = Pattern . compile ( "//indent:\\d+ exp:(\\d+(,\\d+)+?)( warn)?" ) ; private static final Pattern SINGLELEVEL_COMMENT_REGEX = Pattern . compile ( "//indent:\\d+ exp:(\\d+)( warn)?" ) ; private static final Pattern NONSTRICT_LEVEL_COMMENT_REGEX = Pattern . compile ( "//indent:\\d+ exp:>=(\\d+)( warn)?" ) ; protected static Integer [ ] getLinesWithWarnAndCheckComments ( String aFileName , final int tabWidth ) throws IOException { int lineNumber = 1 ; List < Integer > result = new ArrayList < > ( ) ; try ( BufferedReader br = new BufferedReader ( new FileReader ( aFileName ) ) ) { for ( String line = br . readLine ( ) ; line != null ; line = br . readLine ( ) ) { Matcher match = LINE_WITH_COMMENT_REGEX . matcher ( line ) ; if ( match . matches ( ) ) { final String comment = match . group ( 1 ) ; final int indentInComment = getIndentFromComment ( comment ) ; final int actualIndent = getLineStart ( line , tabWidth ) ; if ( actualIndent != indentInComment ) { throw new RuntimeException ( String . format ( "File \"%1$s\" has incorrect indentation in comment." + "Line %2$d: comment:%3$d, actual:%4$d." , aFileName , lineNumber , indentInComment , actualIndent ) ) ; } if ( isWarnComment ( comment ) ) { result . add ( lineNumber ) ; } if ( ! isCommentConsistent ( comment ) ) { throw new RuntimeException ( String . format ( "File \"%1$s\" has inconsistent comment on line %2$d" , aFileName , lineNumber ) ) ; } } else if ( NONEMPTY_LINE_REGEX . matcher ( line ) . matches ( ) ) { throw new RuntimeException ( String . format ( "File \"%1$s\" has no indentation comment or its format " + "malformed. Error on line: %2$d" , aFileName , lineNumber ) ) ; } lineNumber ++ ; } } return result . toArray ( new Integer [ result . size ( ) ] ) ; } private static int getIndentFromComment ( String comment ) { final Matcher match = GET_INDENT_FROM_COMMENT_REGEX . matcher ( comment ) ; match . matches ( ) ; return Integer . parseInt ( match . group ( 1 ) ) ; } private static boolean isWarnComment ( String comment ) { return comment . endsWith ( " warn" ) ; } private static boolean isCommentConsistent ( String comment ) { final int indentInComment = getIndentFromComment ( comment ) ; final boolean isWarnComment = isWarnComment ( comment ) ; Matcher match ; match = MULTILEVEL_COMMENT_REGEX . matcher ( comment ) ; if ( match . matches ( ) ) { final String [ ] levels = match . group ( 1 ) . split ( "," ) ; final String indentInCommentStr = String . valueOf ( indentInComment ) ; final boolean containsActualLevel = Arrays . asList ( levels ) . contains ( indentInCommentStr ) ; return containsActualLevel && ! isWarnComment || ! containsActualLevel && isWarnComment ; } match = SINGLELEVEL_COMMENT_REGEX . matcher ( comment ) ; if ( match . matches ( ) ) { final int expectedLevel = Integer . parseInt ( match . group ( 1 ) ) ; return expectedLevel == indentInComment && ! isWarnComment || expectedLevel != indentInComment && isWarnComment ; } match = NONSTRICT_LEVEL_COMMENT_REGEX . matcher ( comment ) ; if ( match . matches ( ) ) { final int expectedMinimalIndent = Integer . parseInt ( match . group ( 1 ) ) ; return indentInComment >= expectedMinimalIndent && ! isWarnComment || indentInComment < expectedMinimalIndent && isWarnComment ; } throw new IllegalArgumentException ( ) ; } private static int getLineStart ( String line , final int tabWidth ) { for ( int index = 0 ; index < line . length ( ) ; ++ index ) { if ( ! Character . isWhitespace ( line . charAt ( index ) ) ) { return Utils . lengthExpandedTabs ( line , index , tabWidth ) ; } } return 0 ; } private void verifyWarns ( Configuration config , String filePath , String [ ] expected , int warnCountCorrection ) throws Exception { final int tabWidth = Integer . parseInt ( config . getAttribute ( "tabWidth" ) ) ; Integer [ ] linesWithWarn = getLinesWithWarnAndCheckComments ( filePath , tabWidth ) ; Assert . assertEquals ( "Expected warning count in UT does not match warn" + " comment count in input file" , linesWithWarn . length + warnCountCorrection , expected . length ) ; verify ( config , filePath , expected ) ; } private void verifyWarns ( Configuration config , String filePath , String [ ] expected ) throws Exception { verifyWarns ( config , filePath , expected , 0 ) ; } @ Test public void forbidCStyle ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "true" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "8" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "8" ) ; final String [ ] expected = { "20: " + getCheckMessage ( MSG_ERROR , "int" , 29 , 12 ) , "21: " + getCheckMessage ( MSG_ERROR , "int" , 29 , 12 ) , } ; verifyWarns ( checkConfig , getPath ( "indentation/InputMethodCStyle.java" ) , expected ) ; } @ Test public void testZeroCaseLevel ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "0" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/InputZeroCaseLevel.java" ) , expected ) ; } @ Test public void testAndroidStyle ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "8" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "8" ) ; final String [ ] expected = { "42: " + getCheckMessage ( MSG_ERROR , "extends" , 3 , 8 ) , "44: " + getCheckMessage ( MSG_ERROR , "member def type" , 3 , 4 ) , "47: " + getCheckMessage ( MSG_ERROR , "foo" , 8 , 12 ) , "50: " + getCheckMessage ( MSG_ERROR , "int" , 8 , 12 ) , "53: " + getCheckMessage ( MSG_ERROR , "true" , 13 , 16 ) , "56: " + getCheckMessage ( MSG_ERROR , "+" , 16 , 20 ) , "57: " + getCheckMessage ( MSG_ERROR , "if" , 8 , 12 ) , "60: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 11 , 12 ) , "62: " + getCheckMessage ( MSG_CHILD_ERROR , "method def" , 7 , 8 ) , } ; verifyWarns ( checkConfig , getPath ( "indentation/InputAndroidStyle.java" ) , expected ) ; } @ Test public void testMethodCallLineWrap ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { "51: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 18 , 20 ) , "52: " + getCheckMessage ( MSG_ERROR , "method call rparen" , 14 , 16 ) , } ; verifyWarns ( checkConfig , getPath ( "indentation/InputMethodCallLineWrap.java" ) , expected ) ; } @ Test public void testDifficultAnnotations ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { "40: " + getCheckMessage ( MSG_ERROR , "@" , 0 , 4 ) , "41: " + getCheckMessage ( MSG_ERROR , "@" , 0 , 4 ) , "50: " + getCheckMessage ( MSG_ERROR , "@" , 6 , 8 ) , } ; verifyWarns ( checkConfig , getPath ( "indentation/InputDifficultAnnotations.java" ) , expected ) ; } @ Test public void testAnonClassesFromGuava ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "2" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/FromGuava2.java" ) , expected ) ; } @ Test public void testAnnotatins ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "2" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/FromGuava.java" ) , expected ) ; } @ Test public void testCorrectIfAndParameters ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "2" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/IndentationCorrectIfAndParameterInput.java" ) , expected ) ; } @ Test public void testAnonymousClasses ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "2" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/InputAnonymousClasses.java" ) , expected ) ; } @ Test public void testArrays ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "2" ) ; checkConfig . addAttribute ( "basicOffset" , "2" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/InputArrays.java" ) , expected ) ; } @ Test public void testLables ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "2" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/InputLabels.java" ) , expected ) ; } @ Test public void testClassesAndMethods ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "2" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/InputClassesMethods.java" ) , expected ) ; } @ Test public void testMembers ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "2" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { "22: " + getCheckMessage ( MSG_ERROR , "=" , 5 , 6 ) , "57: " + getCheckMessage ( MSG_ERROR , "class def rcurly" , 3 , 2 ) , } ; verifyWarns ( checkConfig , getPath ( "indentation/InputMembers.java" ) , expected ) ; } @ Test public void testInvalidLabel ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { "24: " + getCheckMessage ( MSG_CHILD_ERROR_MULTI , "label" , 10 , "8, 12" ) , "33: " + getCheckMessage ( MSG_CHILD_ERROR_MULTI , "label" , 2 , "4, 8" ) , "36: " + getCheckMessage ( MSG_CHILD_ERROR_MULTI , "label" , 18 , "8, 12" ) , "37: " + getCheckMessage ( MSG_CHILD_ERROR , "ctor def" , 18 , 8 ) , "39: " + getCheckMessage ( MSG_CHILD_ERROR_MULTI , "label" , 6 , "8, 12" ) , "41: " + getCheckMessage ( MSG_CHILD_ERROR_MULTI , "label" , 6 , "8, 12" ) , } ; verifyWarns ( checkConfig , getPath ( "indentation/InputInvalidLabelIndent.java" ) , expected ) ; } @ Test public void testValidLabel ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/InputValidLabelIndent.java" ) , expected ) ; } @ Test public void testValidIfWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidIfIndent.java" ) ; final String [ ] expected = { "231: " + getCheckMessage ( MSG_ERROR , "(" , 8 , 12 ) , } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testValidDotWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidDotIndent.java" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testValidMethodWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidMethodIndent.java" ) ; final String [ ] expected = { "129: " + getCheckMessage ( MSG_ERROR , "void" , 4 , 8 ) , "130: " + getCheckMessage ( MSG_ERROR , "method5" , 4 , 8 ) , } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testInvalidMethodWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputInvalidMethodIndent.java" ) ; final String [ ] expected = { "23: " + getCheckMessage ( MSG_ERROR , "ctor def rcurly" , 6 , 4 ) , "26: " + getCheckMessage ( MSG_ERROR , "ctor def modifier" , 6 , 4 ) , "27: " + getCheckMessage ( MSG_ERROR , "ctor def lcurly" , 2 , 4 ) , "28: " + getCheckMessage ( MSG_ERROR , "ctor def rcurly" , 6 , 4 ) , "31: " + getCheckMessage ( MSG_ERROR , "method def modifier" , 2 , 4 ) , "32: " + getCheckMessage ( MSG_ERROR , "method def rcurly" , 6 , 4 ) , "69: " + getCheckMessage ( MSG_ERROR , "method def modifier" , 5 , 4 ) , "70: " + getCheckMessage ( MSG_ERROR , "final" , 5 , 9 ) , "71: " + getCheckMessage ( MSG_ERROR , "void" , 5 , 9 ) , "72: " + getCheckMessage ( MSG_ERROR , "method5" , 4 , 9 ) , "80: " + getCheckMessage ( MSG_ERROR , "method def modifier" , 3 , 4 ) , "81: " + getCheckMessage ( MSG_ERROR , "final" , 3 , 7 ) , "82: " + getCheckMessage ( MSG_ERROR , "void" , 3 , 7 ) , "83: " + getCheckMessage ( MSG_ERROR , "method6" , 5 , 7 ) , "93: " + getCheckMessage ( MSG_CHILD_ERROR , "ctor def" , 4 , 8 ) , "93: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 4 , 8 ) , "98: " + getCheckMessage ( MSG_ERROR , "member def type" , 6 , 8 ) , "98: " + getCheckMessage ( MSG_CHILD_ERROR , "method def" , 6 , 8 ) , "99: " + getCheckMessage ( MSG_ERROR , "if" , 6 , 8 ) , "100: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 10 , 12 ) , "100: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "101: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 6 , 8 ) , "104: " + getCheckMessage ( MSG_ERROR , "Arrays" , 10 , 12 ) , "113: " + getCheckMessage ( MSG_ERROR , "+" , 10 , 12 ) , "113: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "122: " + getCheckMessage ( MSG_ERROR , "new" , 10 , 12 ) , "126: " + getCheckMessage ( MSG_ERROR , "new" , 10 , 12 ) , "127: " + getCheckMessage ( MSG_ERROR , ")" , 6 , 8 ) , "131: " + getCheckMessage ( MSG_ERROR , "method call rparen" , 6 , 8 ) , "145: " + getCheckMessage ( MSG_ERROR , "6" , 10 , 12 ) , "145: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "148: " + getCheckMessage ( MSG_ERROR , "6" , 10 , 12 ) , "148: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "158: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 6 , 12 ) , "170: " + getCheckMessage ( MSG_CHILD_ERROR , "method def" , 4 , 8 ) , "175: " + getCheckMessage ( MSG_CHILD_ERROR , "method def" , 4 , 8 ) , "179: " + getCheckMessage ( MSG_ERROR , "int" , 0 , 8 ) , "180: " + getCheckMessage ( MSG_ERROR , "method9" , 4 , 8 ) , "190: " + getCheckMessage ( MSG_CHILD_ERROR , "method def" , 12 , 8 ) , } ; verifyWarns ( checkConfig , fname , expected , 6 ) ; } @ Test public void testInvalidSwitchWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputInvalidSwitchIndent.java" ) ; final String [ ] expected = { "30: " + getCheckMessage ( MSG_ERROR , "switch" , 6 , 8 ) , "32: " + getCheckMessage ( MSG_CHILD_ERROR , "case" , 10 , 12 ) , "33: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 14 , 16 ) , "33: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 14 , 16 ) , "37: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 14 , 16 ) , "39: " + getCheckMessage ( MSG_CHILD_ERROR , "case" , 14 , 12 ) , "40: " + getCheckMessage ( MSG_CHILD_ERROR , "case" , 10 , 12 ) , "43: " + getCheckMessage ( MSG_CHILD_ERROR , "case" , 10 , 12 ) , "44: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 14 , 16 ) , "44: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 14 , 16 ) , "45: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 14 , 16 ) , "53: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 14 , 16 ) , "53: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 14 , 16 ) , "54: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 18 , 16 ) , "55: " + getCheckMessage ( MSG_ERROR , "block rcurly" , 10 , 12 ) , "59: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 10 , 12 ) , "62: " + getCheckMessage ( MSG_ERROR , "block rcurly" , 14 , 12 ) , "66: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 14 , 12 ) , "69: " + getCheckMessage ( MSG_ERROR , "block rcurly" , 10 , 12 ) , "76: " + getCheckMessage ( MSG_CHILD_ERROR , "case" , 14 , 16 ) , "81: " + getCheckMessage ( MSG_CHILD_ERROR , "case" , 14 , 16 ) , "89: " + getCheckMessage ( MSG_ERROR , "switch rcurly" , 6 , 8 ) , "92: " + getCheckMessage ( MSG_ERROR , "switch lcurly" , 6 , 8 ) , "93: " + getCheckMessage ( MSG_ERROR , "switch rcurly" , 10 , 8 ) , "95: " + getCheckMessage ( MSG_ERROR , "switch lcurly" , 10 , 8 ) , "96: " + getCheckMessage ( MSG_ERROR , "switch rcurly" , 6 , 8 ) , } ; verifyWarns ( checkConfig , fname , expected , 3 ) ; } @ Test public void testValidSwitchWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidSwitchIndent.java" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testValidArrayInitDefaultIndentWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidArrayInitDefaultIndent.java" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testValidArrayInitWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "8" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidArrayInitIndent.java" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testInvalidArrayInitWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputInvalidArrayInitIndent.java" ) ; final String [ ] expected = { "21: " + getCheckMessage ( MSG_ERROR , "member def type" , 2 , 4 ) , "22: " + getCheckMessage ( MSG_ERROR , "member def type" , 6 , 4 ) , "24: " + getCheckMessage ( MSG_ERROR , "member def type" , 2 , 4 ) , "28: " + getCheckMessage ( MSG_ERROR , "member def type" , 6 , 4 ) , "29: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 8 , 10 ) , "30: " + getCheckMessage ( MSG_ERROR_MULTI , "array initialization rcurly" , 4 , "6, 10" ) , "33: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 9 , 8 ) , "34: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 7 , 8 ) , "35: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 9 , 8 ) , "40: " + getCheckMessage ( MSG_ERROR , "array initialization lcurly" , 2 , 4 ) , "44: " + getCheckMessage ( MSG_ERROR_MULTI , "array initialization rcurly" , 6 , "4, 8" ) , "48: " + getCheckMessage ( MSG_ERROR , "array initialization lcurly" , 2 , 4 ) , "52: " + getCheckMessage ( MSG_CHILD_ERROR_MULTI , "array initialization" , 20 , "8, 31, 33" ) , "53: " + getCheckMessage ( MSG_CHILD_ERROR_MULTI , "array initialization" , 4 , "8, 31, 33" ) , "58: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 6 , 8 ) , "63: " + getCheckMessage ( MSG_ERROR , "member def type" , 2 , 4 ) , "65: " + getCheckMessage ( MSG_ERROR , "member def type" , 6 , 4 ) , "66: " + getCheckMessage ( MSG_ERROR_MULTI , "array initialization rcurly" , 2 , "6, 10" ) , "69: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 6 , 8 ) , "76: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 10 , 12 ) , "89: " + getCheckMessage ( MSG_ERROR , "1" , 8 , 12 ) , "89: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 8 , 12 ) , "100: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 10 , 12 ) , "101: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 14 , 12 ) , "104: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 10 , 12 ) , "105: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 14 , 12 ) , "106: " + getCheckMessage ( MSG_ERROR_MULTI , "array initialization rcurly" , 6 , "8, 12" ) , "109: " + getCheckMessage ( MSG_ERROR , "array initialization lcurly" , 6 , 8 ) , "110: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 14 , 12 ) , "111: " + getCheckMessage ( MSG_CHILD_ERROR , "array initialization" , 10 , 12 ) , "112: " + getCheckMessage ( MSG_ERROR_MULTI , "array initialization rcurly" , 6 , "8, 12" ) , } ; verify ( checkConfig , fname , expected ) ; } @ Test public void testValidTryWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidTryIndent.java" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testInvalidTryWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputInvalidTryIndent.java" ) ; final String [ ] expected = { "25: " + getCheckMessage ( MSG_ERROR , "try" , 9 , 8 ) , "26: " + getCheckMessage ( MSG_ERROR , "try rcurly" , 7 , 8 ) , "28: " + getCheckMessage ( MSG_ERROR , "catch rcurly" , 7 , 8 ) , "30: " + getCheckMessage ( MSG_ERROR , "try" , 4 , 8 ) , "31: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 8 , 12 ) , "31: " + getCheckMessage ( MSG_CHILD_ERROR , "try" , 8 , 12 ) , "32: " + getCheckMessage ( MSG_ERROR , "try rcurly" , 4 , 8 ) , "33: " + getCheckMessage ( MSG_CHILD_ERROR , "finally" , 8 , 12 ) , "33: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 8 , 12 ) , "38: " + getCheckMessage ( MSG_CHILD_ERROR , "catch" , 8 , 12 ) , "38: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 8 , 12 ) , "43: " + getCheckMessage ( MSG_ERROR , "try rcurly" , 10 , 8 ) , "45: " + getCheckMessage ( MSG_ERROR , "catch rcurly" , 6 , 8 ) , "52: " + getCheckMessage ( MSG_ERROR , "catch rcurly" , 5 , 8 ) , "59: " + getCheckMessage ( MSG_CHILD_ERROR , "catch" , 10 , 12 ) , "59: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "60: " + getCheckMessage ( MSG_CHILD_ERROR , "catch" , 14 , 12 ) , "61: " + getCheckMessage ( MSG_CHILD_ERROR , "catch" , 10 , 12 ) , "61: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "63: " + getCheckMessage ( MSG_ERROR , "catch" , 6 , 8 ) , "70: " + getCheckMessage ( MSG_ERROR , "try lcurly" , 10 , 8 ) , "72: " + getCheckMessage ( MSG_ERROR , "try rcurly" , 10 , 8 ) , "74: " + getCheckMessage ( MSG_ERROR , "catch lcurly" , 6 , 8 ) , "77: " + getCheckMessage ( MSG_ERROR , "catch rcurly" , 10 , 8 ) , "80: " + getCheckMessage ( MSG_CHILD_ERROR , "catch" , 10 , 12 ) , "80: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , } ; verifyWarns ( checkConfig , fname , expected , 6 ) ; } @ Test public void testInvalidClassDefWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputInvalidClassDefIndent.java" ) ; final String [ ] expected = { "22: " + getCheckMessage ( MSG_ERROR , "class def modifier" , 2 , 0 ) , "28: " + getCheckMessage ( MSG_ERROR , "class def lcurly" , 2 , 0 ) , "31: " + getCheckMessage ( MSG_ERROR , "class def rcurly" , 2 , 0 ) , "34: " + getCheckMessage ( MSG_ERROR , "class def ident" , 2 , 0 ) , "38: " + getCheckMessage ( MSG_ERROR , "class def rcurly" , 2 , 0 ) , "43: " + getCheckMessage ( MSG_ERROR , "extends" , 2 , 4 ) , "44: " + getCheckMessage ( MSG_ERROR , "implements" , 2 , 4 ) , "50: " + getCheckMessage ( MSG_ERROR , "extends" , 2 , 4 ) , "58: " + getCheckMessage ( MSG_ERROR , "implements" , 2 , 4 ) , "59: " + getCheckMessage ( MSG_ERROR , "java" , 2 , 4 ) , "64: " + getCheckMessage ( MSG_ERROR , "class def modifier" , 2 , 0 ) , "65: " + getCheckMessage ( MSG_ERROR , "class def lcurly" , 2 , 0 ) , "73: " + getCheckMessage ( MSG_ERROR , "class def rcurly" , 2 , 0 ) , "77: " + getCheckMessage ( MSG_ERROR , "extends" , 2 , 4 ) , "86: " + getCheckMessage ( MSG_ERROR , "class def ident" , 2 , 4 ) , "88: " + getCheckMessage ( MSG_ERROR , "class def ident" , 6 , 4 ) , "91: " + getCheckMessage ( MSG_ERROR , "class def ident" , 2 , 4 ) , "95: " + getCheckMessage ( MSG_ERROR , "member def modifier" , 6 , 8 ) , "101: " + getCheckMessage ( MSG_ERROR , "int" , 10 , 12 ) , "106: " + getCheckMessage ( MSG_ERROR , "member def modifier" , 6 , 8 ) , "111: " + getCheckMessage ( MSG_ERROR , "class def rcurly" , 6 , 4 ) , "113: " + getCheckMessage ( MSG_ERROR , "class def ident" , 6 , 4 ) , "119: " + getCheckMessage ( MSG_ERROR , "class def ident" , 6 , 8 ) , "122: " + getCheckMessage ( MSG_ERROR , "class def ident" , 10 , 8 ) , "124: " + getCheckMessage ( MSG_ERROR , "class def rcurly" , 10 , 8 ) , "127: " + getCheckMessage ( MSG_ERROR , "member def type" , 10 , 12 ) , "132: " + getCheckMessage ( MSG_CHILD_ERROR , "method def" , 10 , 8 ) , "133: " + getCheckMessage ( MSG_ERROR_MULTI , "object def lcurly" , 8 , "10, 14" ) , "137: " + getCheckMessage ( MSG_ERROR_MULTI , "object def rcurly" , 8 , "10, 14" ) , "141: " + getCheckMessage ( MSG_ERROR_MULTI , "object def lcurly" , 6 , "8, 12" ) , "142: " + getCheckMessage ( MSG_ERROR , "method def modifier" , 12 , 10 ) , "144: " + getCheckMessage ( MSG_ERROR , "method def rcurly" , 12 , 10 ) , "145: " + getCheckMessage ( MSG_ERROR_MULTI , "object def rcurly" , 6 , "8, 12" ) , "150: " + getCheckMessage ( MSG_ERROR , "method def modifier" , 10 , 12 ) , "152: " + getCheckMessage ( MSG_ERROR , "method def rcurly" , 10 , 12 ) , "188: " + getCheckMessage ( MSG_ERROR , "class" , 0 , 4 ) , } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testInvalidBlockWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputInvalidBlockIndent.java" ) ; final String [ ] expected = { "26: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 7 , 8 ) , "27: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 9 , 8 ) , "29: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 9 , 8 ) , "30: " + getCheckMessage ( MSG_ERROR , "block rcurly" , 7 , 8 ) , "32: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 6 , 8 ) , "34: " + getCheckMessage ( MSG_ERROR , "block rcurly" , 6 , 8 ) , "35: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 6 , 8 ) , "38: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 9 , 8 ) , "39: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 13 , 12 ) , "39: " + getCheckMessage ( MSG_ERROR , "member def type" , 13 , 12 ) , "41: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 13 , 12 ) , "42: " + getCheckMessage ( MSG_ERROR , "block rcurly" , 9 , 8 ) , "45: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 6 , 8 ) , "46: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 10 , 12 ) , "46: " + getCheckMessage ( MSG_ERROR , "member def type" , 10 , 12 ) , "48: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 10 , 12 ) , "49: " + getCheckMessage ( MSG_ERROR , "block rcurly" , 6 , 8 ) , "52: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 6 , 8 ) , "55: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 10 , 12 ) , "55: " + getCheckMessage ( MSG_ERROR , "member def type" , 10 , 12 ) , "59: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 10 , 12 ) , "63: " + getCheckMessage ( MSG_ERROR , "block rcurly" , 10 , 12 ) , "68: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 10 , 12 ) , "70: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 10 , 12 ) , "71: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 14 , 16 ) , "71: " + getCheckMessage ( MSG_ERROR , "member def type" , 14 , 16 ) , "86: " + getCheckMessage ( MSG_ERROR , "block rcurly" , 10 , 12 ) , "95: " + getCheckMessage ( MSG_ERROR , "static initialization" , 2 , 4 ) , "96: " + getCheckMessage ( MSG_ERROR , "static initialization" , 6 , 4 ) , "100: " + getCheckMessage ( MSG_ERROR , "member def type" , 7 , 8 ) , "100: " + getCheckMessage ( MSG_CHILD_ERROR , "static initialization" , 7 , 8 ) , "103: " + getCheckMessage ( MSG_ERROR , "static initialization" , 6 , 4 ) , "105: " + getCheckMessage ( MSG_ERROR , "static initialization rcurly" , 2 , 4 ) , "107: " + getCheckMessage ( MSG_ERROR , "static initialization" , 2 , 4 ) , "109: " + getCheckMessage ( MSG_ERROR , "static initialization rcurly" , 6 , 4 ) , "111: " + getCheckMessage ( MSG_ERROR , "static initialization" , 2 , 4 ) , "113: " + getCheckMessage ( MSG_ERROR , "member def type" , 6 , 8 ) , "113: " + getCheckMessage ( MSG_CHILD_ERROR , "static initialization" , 6 , 8 ) , "116: " + getCheckMessage ( MSG_ERROR , "static initialization lcurly" , 2 , 4 ) , "117: " + getCheckMessage ( MSG_ERROR , "member def type" , 6 , 8 ) , "117: " + getCheckMessage ( MSG_CHILD_ERROR , "static initialization" , 6 , 8 ) , "118: " + getCheckMessage ( MSG_ERROR , "static initialization rcurly" , 6 , 4 ) , "123: " + getCheckMessage ( MSG_ERROR , "member def type" , 6 , 8 ) , "123: " + getCheckMessage ( MSG_CHILD_ERROR , "static initialization" , 6 , 8 ) , "128: " + getCheckMessage ( MSG_ERROR , "member def type" , 4 , 8 ) , "128: " + getCheckMessage ( MSG_CHILD_ERROR , "static initialization" , 4 , 8 ) , "129: " + getCheckMessage ( MSG_ERROR , "static initialization rcurly" , 2 , 4 ) , "134: " + getCheckMessage ( MSG_ERROR , "static initialization rcurly" , 6 , 4 ) , "137: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 2 , 4 ) , "138: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 6 , 4 ) , "141: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 2 , 4 ) , "143: " + getCheckMessage ( MSG_ERROR , "block rcurly" , 6 , 4 ) , "145: " + getCheckMessage ( MSG_ERROR , "block lcurly" , 6 , 4 ) , "147: " + getCheckMessage ( MSG_ERROR , "block rcurly" , 2 , 4 ) , "150: " + getCheckMessage ( MSG_CHILD_ERROR , "block" , 6 , 8 ) , "150: " + getCheckMessage ( MSG_ERROR , "member def type" , 6 , 8 ) , } ; verifyWarns ( checkConfig , fname , expected , 10 ) ; } @ Test public void testInvalidIfWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputInvalidIfIndent.java" ) ; final String [ ] expected = { "55: " + getCheckMessage ( MSG_ERROR , "if" , 1 , 8 ) , "60: " + getCheckMessage ( MSG_ERROR , "if" , 9 , 8 ) , "61: " + getCheckMessage ( MSG_ERROR , "if lcurly" , 9 , 8 ) , "62: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 7 , 8 ) , "64: " + getCheckMessage ( MSG_ERROR , "if" , 6 , 8 ) , "65: " + getCheckMessage ( MSG_ERROR , "if lcurly" , 5 , 8 ) , "66: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 5 , 8 ) , "70: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 10 , 8 ) , "71: " + getCheckMessage ( MSG_ERROR , "else rcurly" , 7 , 8 ) , "74: " + getCheckMessage ( MSG_ERROR , "if" , 9 , 8 ) , "75: " + getCheckMessage ( MSG_ERROR , "if lcurly" , 7 , 8 ) , "77: " + getCheckMessage ( MSG_ERROR , "else" , 9 , 8 ) , "79: " + getCheckMessage ( MSG_ERROR , "else rcurly" , 9 , 8 ) , "82: " + getCheckMessage ( MSG_ERROR , "if" , 10 , 8 ) , "83: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 7 , 8 ) , "84: " + getCheckMessage ( MSG_ERROR , "else" , 9 , 8 ) , "85: " + getCheckMessage ( MSG_ERROR , "else lcurly" , 7 , 8 ) , "86: " + getCheckMessage ( MSG_ERROR , "else rcurly" , 9 , 8 ) , "90: " + getCheckMessage ( MSG_ERROR , "if" , 9 , 8 ) , "91: " + getCheckMessage ( MSG_ERROR , "if lcurly" , 9 , 8 ) , "92: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 9 , 8 ) , "93: " + getCheckMessage ( MSG_ERROR , "else lcurly" , 7 , 8 ) , "94: " + getCheckMessage ( MSG_ERROR , "else rcurly" , 10 , 8 ) , "97: " + getCheckMessage ( MSG_ERROR , "if" , 6 , 8 ) , "98: " + getCheckMessage ( MSG_ERROR , "if lcurly" , 10 , 8 ) , "99: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 10 , 8 ) , "100: " + getCheckMessage ( MSG_ERROR , "else rcurly" , 7 , 8 ) , "103: " + getCheckMessage ( MSG_ERROR , "if" , 5 , 8 ) , "104: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 11 , 8 ) , "105: " + getCheckMessage ( MSG_ERROR , "else" , 5 , 8 ) , "106: " + getCheckMessage ( MSG_ERROR , "else rcurly" , 11 , 8 ) , "126: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 14 , 12 ) , "131: " + getCheckMessage ( MSG_ERROR , "if lcurly" , 10 , 8 ) , "132: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 10 , 12 ) , "132: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "137: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 14 , 12 ) , "138: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "140: " + getCheckMessage ( MSG_CHILD_ERROR , "else" , 10 , 12 ) , "140: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "141: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 8 , 12 ) , "148: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 16 , 12 ) , "149: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 9 , 8 ) , "152: " + getCheckMessage ( MSG_CHILD_ERROR , "else" , 16 , 12 ) , "158: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 0 , 12 ) , "158: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 0 , 12 ) , "162: " + getCheckMessage ( MSG_CHILD_ERROR , "else" , 40 , 12 ) , "169: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 14 , 12 ) , "172: " + getCheckMessage ( MSG_CHILD_ERROR , "else" , 14 , 12 ) , "178: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 10 , 12 ) , "178: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "180: " + getCheckMessage ( MSG_CHILD_ERROR , "else" , 10 , 12 ) , "180: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "184: " + getCheckMessage ( MSG_ERROR , "if" , 10 , 8 ) , "185: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 14 , 12 ) , "186: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 10 , 8 ) , "187: " + getCheckMessage ( MSG_ERROR , "else" , 10 , 8 ) , "188: " + getCheckMessage ( MSG_CHILD_ERROR , "else" , 14 , 12 ) , "189: " + getCheckMessage ( MSG_ERROR , "else rcurly" , 10 , 8 ) , "192: " + getCheckMessage ( MSG_ERROR , "&&" , 9 , 12 ) , "192: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 9 , 12 ) , "193: " + getCheckMessage ( MSG_ERROR , "&&" , 11 , 12 ) , "193: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 11 , 12 ) , "197: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 10 , 12 ) , "200: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 7 , 8 ) , "207: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 10 , 12 ) , "207: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "209: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 10 , 12 ) , "209: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "225: " + getCheckMessage ( MSG_ERROR , "if" , 10 , 12 ) , "229: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 18 , 20 ) , "229: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 18 , 20 ) , "233: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 40 , 8 ) , "240: " + getCheckMessage ( MSG_ERROR , "if rparen" , 10 , 8 ) , "245: " + getCheckMessage ( MSG_ERROR , "if rparen" , 6 , 8 ) , "251: " + getCheckMessage ( MSG_ERROR , "(" , 6 , 12 ) , "251: " + getCheckMessage ( MSG_ERROR , "if lparen" , 6 , 8 ) , "253: " + getCheckMessage ( MSG_ERROR , "if rparen" , 6 , 8 ) , } ; verifyWarns ( checkConfig , fname , expected , 11 ) ; } @ Test public void testInvalidWhileWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputInvalidWhileIndent.java" ) ; final String [ ] expected = { "25: " + getCheckMessage ( MSG_ERROR , "while" , 9 , 8 ) , "26: " + getCheckMessage ( MSG_ERROR , "while rcurly" , 7 , 8 ) , "28: " + getCheckMessage ( MSG_ERROR , "while" , 7 , 8 ) , "29: " + getCheckMessage ( MSG_ERROR , "while lcurly" , 9 , 8 ) , "30: " + getCheckMessage ( MSG_ERROR , "while rcurly" , 9 , 8 ) , "32: " + getCheckMessage ( MSG_ERROR , "while" , 9 , 8 ) , "33: " + getCheckMessage ( MSG_ERROR , "while lcurly" , 6 , 8 ) , "34: " + getCheckMessage ( MSG_CHILD_ERROR , "while" , 14 , 12 ) , "35: " + getCheckMessage ( MSG_ERROR , "while rcurly" , 6 , 8 ) , "37: " + getCheckMessage ( MSG_ERROR , "while" , 10 , 8 ) , "39: " + getCheckMessage ( MSG_ERROR , "while rcurly" , 10 , 8 ) , "41: " + getCheckMessage ( MSG_ERROR , "while" , 10 , 8 ) , "44: " + getCheckMessage ( MSG_ERROR , "while rcurly" , 10 , 8 ) , "46: " + getCheckMessage ( MSG_ERROR , "while" , 6 , 8 ) , "47: " + getCheckMessage ( MSG_ERROR , "while lcurly" , 10 , 8 ) , "50: " + getCheckMessage ( MSG_ERROR , "while rcurly" , 6 , 8 ) , "53: " + getCheckMessage ( MSG_ERROR , "if" , 14 , 12 ) , "54: " + getCheckMessage ( MSG_CHILD_ERROR , "if" , 18 , 16 ) , "55: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 14 , 12 ) , "56: " + getCheckMessage ( MSG_CHILD_ERROR , "while" , 14 , 12 ) , "57: " + getCheckMessage ( MSG_ERROR , "while rcurly" , 10 , 8 ) , "60: " + getCheckMessage ( MSG_CHILD_ERROR , "while" , 10 , 12 ) , "66: " + getCheckMessage ( MSG_CHILD_ERROR , "while" , 10 , 12 ) , "71: " + getCheckMessage ( MSG_CHILD_ERROR , "while" , 10 , 12 ) , "78: " + getCheckMessage ( MSG_ERROR , "while rparen" , 5 , 8 ) , "85: " + getCheckMessage ( MSG_ERROR , "while rparen" , 10 , 8 ) , "92: " + getCheckMessage ( MSG_ERROR , "while rparen" , 10 , 8 ) , "99: " + getCheckMessage ( MSG_CHILD_ERROR , "while" , 8 , 12 ) , } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testInvalidForWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputInvalidForIndent.java" ) ; final String [ ] expected = { "26: " + getCheckMessage ( MSG_ERROR , "for" , 6 , 8 ) , "27: " + getCheckMessage ( MSG_ERROR , "for rcurly" , 10 , 8 ) , "29: " + getCheckMessage ( MSG_ERROR , "for" , 9 , 8 ) , "30: " + getCheckMessage ( MSG_ERROR , "for lcurly" , 6 , 8 ) , "31: " + getCheckMessage ( MSG_ERROR , "for rcurly" , 6 , 8 ) , "35: " + getCheckMessage ( MSG_CHILD_ERROR , "for" , 10 , 12 ) , "35: " + getCheckMessage ( MSG_CHILD_ERROR , "method call" , 10 , 12 ) , "36: " + getCheckMessage ( MSG_ERROR , "for rcurly" , 10 , 8 ) , "39: " + getCheckMessage ( MSG_ERROR , "for lcurly" , 10 , 8 ) , "40: " + getCheckMessage ( MSG_CHILD_ERROR , "for" , 10 , 12 ) , "40: " + getCheckMessage ( MSG_ERROR , "member def type" , 10 , 12 ) , "48: " + getCheckMessage ( MSG_CHILD_ERROR , "for" , 10 , 12 ) , "48: " + getCheckMessage ( MSG_ERROR , "i" , 10 , 12 ) , "54: " + getCheckMessage ( MSG_ERROR , "for" , 7 , 8 ) , "55: " + getCheckMessage ( MSG_CHILD_ERROR , "for" , 10 , 12 ) , "55: " + getCheckMessage ( MSG_ERROR , "int" , 10 , 11 ) , "55: " + getCheckMessage ( MSG_ERROR , "member def type" , 10 , 12 ) , "64: " + getCheckMessage ( MSG_CHILD_ERROR , "for" , 7 , 12 ) , "64: " + getCheckMessage ( MSG_ERROR , "i" , 7 , 12 ) , "69: " + getCheckMessage ( MSG_ERROR , "for" , 6 , 8 ) , "70: " + getCheckMessage ( MSG_CHILD_ERROR , "for" , 10 , 12 ) , "71: " + getCheckMessage ( MSG_CHILD_ERROR , "for" , 14 , 16 ) , "72: " + getCheckMessage ( MSG_CHILD_ERROR , "for" , 10 , 12 ) , "77: " + getCheckMessage ( MSG_ERROR , "for rcurly" , 39 , 8 ) , "81: " + getCheckMessage ( MSG_ERROR , "for rparen" , 12 , 8 ) , } ; verifyWarns ( checkConfig , fname , expected , 6 ) ; } @ Test public void testValidForWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidForIndent.java" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testValidDoWhileWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidDoWhileIndent.java" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testValidBlockWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidBlockIndent.java" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testValidWhileWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidWhileIndent.java" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testValidClassDefWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidClassDefIndent.java" ) ; final String [ ] expected = { "49: " + getCheckMessage ( MSG_ERROR , "class" , 0 , 4 ) , "71: " + getCheckMessage ( MSG_ERROR , "int" , 8 , 12 ) , } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testValidInterfaceDefWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidInterfaceDefIndent.java" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testValidCommaWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String fname = getPath ( "indentation/InputValidCommaIndent.java" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , fname , expected ) ; } @ Test public void testTabs ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { "29: " + getCheckMessage ( MSG_CHILD_ERROR , "ctor def" , 9 , 8 ) , } ; verifyWarns ( checkConfig , getPath ( "indentation/InputUseTabs.java" ) , expected ) ; } @ Test public void testIndentationLevel ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "2" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "2" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { "29: " + getCheckMessage ( MSG_CHILD_ERROR , "ctor def" , 5 , 4 ) , } ; verifyWarns ( checkConfig , getPath ( "indentation/InputUseTwoSpaces.java" ) , expected ) ; } @ Test public void testThrowsIndentationLevel ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "8" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/InvalidInputThrowsIndent.java" ) , expected ) ; } @ Test public void testCaseLevel ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "0" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { "27: " + getCheckMessage ( MSG_CHILD_ERROR , "case" , 10 , 8 ) , } ; verifyWarns ( checkConfig , getPath ( "indentation/InputCaseLevel.java" ) , expected ) ; } @ Test public void testBraceAdjustment ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "2" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { "28: " + getCheckMessage ( MSG_ERROR , "if rcurly" , 8 , 10 ) , } ; verifyWarns ( checkConfig , getPath ( "indentation/InputBraceAdjustment.java" ) , expected ) ; } @ Test public void testInvalidAssignWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { "22: " + getCheckMessage ( MSG_ERROR , "getLineNo" , 10 , 12 ) , "24: " + getCheckMessage ( MSG_ERROR , "getLine" , 10 , 12 ) , "28: " + getCheckMessage ( MSG_ERROR , "=" , 9 , 12 ) , "29: " + getCheckMessage ( MSG_ERROR , "1" , 10 , 12 ) , } ; verifyWarns ( checkConfig , getPath ( "indentation/InputInvalidAssignIndent.java" ) , expected ) ; } @ Test public void testValidAssignWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/InputValidAssignIndent.java" ) , expected ) ; } @ Test public void test15Extensions ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/Input15Extensions.java" ) , expected ) ; } @ Test public void testTryResources ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "4" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "4" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/InputValidTryResourcesIndent.java" ) , expected ) ; } @ Test public void testSwitchCustom ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "8" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "8" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/InputSwitchCustom.java" ) , expected ) ; } @ Test public void testSynchronizedStatement ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "8" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "8" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/InputSynchronizedStatement.java" ) , expected ) ; } @ Test public void testSynchronizedMethod ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; checkConfig . addAttribute ( "arrayInitIndent" , "4" ) ; checkConfig . addAttribute ( "basicOffset" , "4" ) ; checkConfig . addAttribute ( "braceAdjustment" , "0" ) ; checkConfig . addAttribute ( "caseIndent" , "4" ) ; checkConfig . addAttribute ( "forceStrictCondition" , "false" ) ; checkConfig . addAttribute ( "lineWrappingIndentation" , "8" ) ; checkConfig . addAttribute ( "tabWidth" , "4" ) ; checkConfig . addAttribute ( "throwsIndent" , "8" ) ; final String [ ] expected = { } ; verifyWarns ( checkConfig , getPath ( "indentation/InputSynchronizedMethod.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . coding . IllegalTokenCheck . MSG_KEY ; public class IllegalTokenCheckTest extends BaseCheckTestSupport { @ Test public void testCheckWithDefaultSettings ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IllegalTokenCheck . class ) ; final String [ ] expected = { "29:14: " + getCheckMessage ( MSG_KEY , "label:" ) , "31:25: " + getCheckMessage ( MSG_KEY , "anotherLabel:" ) , } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } @ Test public void testPreviouslyIllegalTokens ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IllegalTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_SWITCH,POST_INC,POST_DEC" ) ; final String [ ] expected = { "11:9: " + getCheckMessage ( MSG_KEY , "switch" ) , "14:18: " + getCheckMessage ( MSG_KEY , "--" ) , "15:18: " + getCheckMessage ( MSG_KEY , "++" ) , } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } @ Test public void testNative ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IllegalTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_NATIVE" ) ; final String [ ] expected = { "20:12: " + getCheckMessage ( MSG_KEY , "native" ) , } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . ModifiedControlVariableCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class ModifiedControlVariableCheckTest extends BaseCheckTestSupport { @ Test public void testModifiedControlVariable ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ModifiedControlVariableCheck . class ) ; final String [ ] expected = { "14:14: " + getCheckMessage ( MSG_KEY , "i" ) , "17:15: " + getCheckMessage ( MSG_KEY , "i" ) , "20:37: " + getCheckMessage ( MSG_KEY , "i" ) , "21:17: " + getCheckMessage ( MSG_KEY , "i" ) , "49:15: " + getCheckMessage ( MSG_KEY , "s" ) , "56:14: " + getCheckMessage ( MSG_KEY , "m" ) , "67:15: " + getCheckMessage ( MSG_KEY , "i" ) , "68:15: " + getCheckMessage ( MSG_KEY , "k" ) , } ; verify ( checkConfig , getPath ( "coding/InputModifiedControl.java" ) , expected ) ; } @ Test public void testEnhancedForLoopVariableTrue ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ModifiedControlVariableCheck . class ) ; checkConfig . addAttribute ( "skipEnhancedForLoopVariable" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "coding/InputModifiedControlVariableEnhancedForLoopVariable.java" ) , expected ) ; } @ Test public void testEnhancedForLoopVariableFalse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ModifiedControlVariableCheck . class ) ; final String [ ] expected = { "9:18: " + getCheckMessage ( MSG_KEY , "line" ) , } ; verify ( checkConfig , getPath ( "coding/InputModifiedControlVariableEnhancedForLoopVariable.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { ModifiedControlVariableCheck check = new ModifiedControlVariableCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . MissingSwitchDefaultCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Before ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class MissingSwitchDefaultCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( MissingSwitchDefaultCheck . class ) ; } @ Test public void testMissingSwitchDefault ( ) throws Exception { final String [ ] expected = { "17:9: " + getCheckMessage ( MSG_KEY , "default" ) , } ; verify ( checkConfig , getPath ( "InputMissingSwitchDefault.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { MissingSwitchDefaultCheck check = new MissingSwitchDefaultCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . EqualsAvoidNullCheck . MSG_EQUALS_AVOID_NULL ; import static com . puppycrawl . tools . checkstyle . checks . coding . EqualsAvoidNullCheck . MSG_EQUALS_IGNORE_CASE_AVOID_NULL ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class EqualsAvoidNullCheckTest extends BaseCheckTestSupport { @ Test public void testEqualsWithDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( EqualsAvoidNullCheck . class ) ; final String [ ] expected = { "18:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "20:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "22:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "24:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "26:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "28:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "37:27: " + getCheckMessage ( MSG_EQUALS_IGNORE_CASE_AVOID_NULL ) , "39:27: " + getCheckMessage ( MSG_EQUALS_IGNORE_CASE_AVOID_NULL ) , "41:27: " + getCheckMessage ( MSG_EQUALS_IGNORE_CASE_AVOID_NULL ) , "43:27: " + getCheckMessage ( MSG_EQUALS_IGNORE_CASE_AVOID_NULL ) , "45:27: " + getCheckMessage ( MSG_EQUALS_IGNORE_CASE_AVOID_NULL ) , "47:27: " + getCheckMessage ( MSG_EQUALS_IGNORE_CASE_AVOID_NULL ) , "57:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "59:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "61:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "63:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "65:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "67:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "69:27: " + getCheckMessage ( MSG_EQUALS_IGNORE_CASE_AVOID_NULL ) , "71:27: " + getCheckMessage ( MSG_EQUALS_IGNORE_CASE_AVOID_NULL ) , "73:27: " + getCheckMessage ( MSG_EQUALS_IGNORE_CASE_AVOID_NULL ) , "75:27: " + getCheckMessage ( MSG_EQUALS_IGNORE_CASE_AVOID_NULL ) , "77:27: " + getCheckMessage ( MSG_EQUALS_IGNORE_CASE_AVOID_NULL ) , "79:27: " + getCheckMessage ( MSG_EQUALS_IGNORE_CASE_AVOID_NULL ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputEqualsAvoidNull.java" ) , expected ) ; } @ Test public void testEqualsWithoutEqualsIgnoreCase ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( EqualsAvoidNullCheck . class ) ; checkConfig . addAttribute ( "ignoreEqualsIgnoreCase" , "true" ) ; final String [ ] expected = { "18:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "20:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "22:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "24:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "26:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "28:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "57:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "59:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "61:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "63:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "65:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , "67:17: " + getCheckMessage ( MSG_EQUALS_AVOID_NULL ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputEqualsAvoidNull.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { EqualsAvoidNullCheck check = new EqualsAvoidNullCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . coding . AbstractSuperCheck . MSG_KEY ; public class SuperCloneCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( SuperCloneCheck . class ) ; final String [ ] expected = { "27:19: " + getCheckMessage ( MSG_KEY , "clone" , "super.clone" ) , "35:19: " + getCheckMessage ( MSG_KEY , "clone" , "super.clone" ) , "60:48: " + getCheckMessage ( MSG_KEY , "clone" , "super.clone" ) , } ; verify ( checkConfig , getPath ( "coding/InputClone.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . NestedForDepthCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class NestedForDepthCheckTest extends BaseCheckTestSupport { @ Test public void testNestedTooDeep ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NestedForDepthCheck . class ) ; checkConfig . addAttribute ( "max" , "2" ) ; final String [ ] expected = { "43:11: " + getCheckMessage ( MSG_KEY , 3 , 2 ) , "44:13: " + getCheckMessage ( MSG_KEY , 4 , 2 ) , } ; verify ( checkConfig , getPath ( "coding/InputNestedForDepth.java" ) , expected ) ; } @ Test public void testNestedOk ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NestedForDepthCheck . class ) ; checkConfig . addAttribute ( "max" , "4" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "coding/InputNestedForDepth.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { NestedForDepthCheck check = new NestedForDepthCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . coding . ReturnCountCheck . MSG_KEY ; public class ReturnCountCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ReturnCountCheck . class ) ; final String [ ] expected = { "18:5: " + getCheckMessage ( MSG_KEY , 7 , 2 ) , "35:17: " + getCheckMessage ( MSG_KEY , 6 , 2 ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputReturnCount.java" ) , expected ) ; } @ Test public void testFormat ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ReturnCountCheck . class ) ; checkConfig . addAttribute ( "format" , "^$" ) ; final String [ ] expected = { "5:5: " + getCheckMessage ( MSG_KEY , 7 , 2 ) , "18:5: " + getCheckMessage ( MSG_KEY , 7 , 2 ) , "35:17: " + getCheckMessage ( MSG_KEY , 6 , 2 ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputReturnCount.java" ) , expected ) ; } @ Test public void testMethodsAndLambdas ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ReturnCountCheck . class ) ; checkConfig . addAttribute ( "max" , "1" ) ; final String [ ] expected = { "14:55: " + getCheckMessage ( MSG_KEY , 2 , 1 ) , "26:49: " + getCheckMessage ( MSG_KEY , 2 , 1 ) , "33:42: " + getCheckMessage ( MSG_KEY , 3 , 1 ) , "40:5: " + getCheckMessage ( MSG_KEY , 2 , 1 ) , "48:57: " + getCheckMessage ( MSG_KEY , 2 , 1 ) , } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/coding/InputReturnCountLambda.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testLambdasOnly ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ReturnCountCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LAMBDA" ) ; final String [ ] expected = { "33:42: " + getCheckMessage ( MSG_KEY , 3 , 2 ) , } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/coding/InputReturnCountLambda.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testMethodsOnly ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ReturnCountCheck . class ) ; checkConfig . addAttribute ( "tokens" , "METHOD_DEF" ) ; final String [ ] expected = { "25:5: " + getCheckMessage ( MSG_KEY , 3 , 2 ) , "32:5: " + getCheckMessage ( MSG_KEY , 4 , 2 ) , "40:5: " + getCheckMessage ( MSG_KEY , 4 , 2 ) , "55:5: " + getCheckMessage ( MSG_KEY , 3 , 2 ) , } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/coding/InputReturnCountLambda.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithReturnOnlyAsTokens ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ReturnCountCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_RETURN" ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/coding/InputReturnCountLambda.java" ) . getCanonicalPath ( ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . SimplifyBooleanExpressionCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class SimplifyBooleanExpressionCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( SimplifyBooleanExpressionCheck . class ) ; final String [ ] expected = { "20:18: " + getCheckMessage ( MSG_KEY ) , "41:36: " + getCheckMessage ( MSG_KEY ) , "42:36: " + getCheckMessage ( MSG_KEY ) , "43:16: " + getCheckMessage ( MSG_KEY ) , "43:32: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputSimplifyBoolean.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { SimplifyBooleanExpressionCheck check = new SimplifyBooleanExpressionCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileWriter ; import java . io . Writer ; import com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocPackageCheck ; import org . junit . Assert ; import org . junit . Rule ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . checks . coding . HiddenFieldCheck ; import com . puppycrawl . tools . checkstyle . checks . naming . ConstantNameCheck ; import org . junit . rules . TemporaryFolder ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class TreeWalkerTest extends BaseCheckTestSupport { @ Rule public TemporaryFolder temporaryFolder = new TemporaryFolder ( ) ; @ Test public void testProperFileExtension ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ConstantNameCheck . class ) ; final String content = "public class Main { public static final int k = 5 + 4; }" ; final File file = temporaryFolder . newFile ( "file.java" ) ; final Writer writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( content ) ; writer . close ( ) ; final String [ ] expected1 = { "1:45: Name 'k' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , } ; verify ( checkConfig , file . getPath ( ) , expected1 ) ; } @ Test public void testImproperFileExtension ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ConstantNameCheck . class ) ; final File file = temporaryFolder . newFile ( "file.pdf" ) ; final String content = "public class Main { public static final int k = 5 + 4; }" ; final BufferedWriter writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( content ) ; writer . close ( ) ; final String [ ] expected = { } ; verify ( checkConfig , file . getPath ( ) , expected ) ; } @ Test public void testAcceptableTokens ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HiddenFieldCheck . class ) ; checkConfig . addAttribute ( "tokens" , "VARIABLE_DEF, ENUM_DEF, CLASS_DEF, METHOD_DEF," + "IMPORT" ) ; final String [ ] expected = { } ; try { verify ( checkConfig , getPath ( "InputHiddenField.java" ) , expected ) ; Assert . fail ( ) ; } catch ( CheckstyleException e ) { String errorMsg = e . getMessage ( ) ; Assert . assertTrue ( errorMsg . contains ( "cannot initialize module" + " com.puppycrawl.tools.checkstyle.TreeWalker - Token \"IMPORT\"" + " was not found in Acceptable tokens list in check" + " com.puppycrawl.tools.checkstyle.checks.coding.HiddenFieldCheck" ) ) ; } } @ Test public void testOnEmptyFile ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HiddenFieldCheck . class ) ; final String pathToEmptyFile = temporaryFolder . newFile ( "file.java" ) . getPath ( ) ; final String [ ] expected = { } ; verify ( checkConfig , pathToEmptyFile , expected ) ; } @ Test public void testWithCheckNotHavingTreeWalkerAsParent ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( JavadocPackageCheck . class ) ; final String [ ] expected = { } ; try { verify ( checkConfig , temporaryFolder . newFile ( ) . getPath ( ) , expected ) ; fail ( ) ; } catch ( CheckstyleException exception ) { assertTrue ( exception . getMessage ( ) . contains ( "TreeWalker is not allowed as a parent of" ) ) ; } } @ Test public void testSettersForParameters ( ) throws Exception { final TreeWalker treeWalker = new TreeWalker ( ) ; treeWalker . setTabWidth ( 1 ) ; treeWalker . setCacheFile ( temporaryFolder . newFile ( ) . getPath ( ) ) ; } @ Test public void testNonExistingCacheFileDoesNotThrowException ( ) { final TreeWalker treeWalker = new TreeWalker ( ) ; treeWalker . setCacheFile ( "/invalid" ) ; treeWalker . destroy ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . DeclarationOrderCheck . MSG_ACCESS ; import static com . puppycrawl . tools . checkstyle . checks . coding . DeclarationOrderCheck . MSG_CONSTRUCTOR ; import static com . puppycrawl . tools . checkstyle . checks . coding . DeclarationOrderCheck . MSG_INSTANCE ; import static com . puppycrawl . tools . checkstyle . checks . coding . DeclarationOrderCheck . MSG_STATIC ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class DeclarationOrderCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DeclarationOrderCheck . class ) ; final String [ ] expected = { "8:5: " + getCheckMessage ( MSG_ACCESS ) , "13:5: " + getCheckMessage ( MSG_ACCESS ) , "18:5: " + getCheckMessage ( MSG_ACCESS ) , "21:5: " + getCheckMessage ( MSG_ACCESS ) , "27:5: " + getCheckMessage ( MSG_STATIC ) , "27:5: " + getCheckMessage ( MSG_ACCESS ) , "34:9: " + getCheckMessage ( MSG_ACCESS ) , "45:9: " + getCheckMessage ( MSG_STATIC ) , "45:9: " + getCheckMessage ( MSG_ACCESS ) , "54:5: " + getCheckMessage ( MSG_CONSTRUCTOR ) , "80:5: " + getCheckMessage ( MSG_INSTANCE ) , "92:9: " + getCheckMessage ( MSG_ACCESS ) , "100:9: " + getCheckMessage ( MSG_STATIC ) , "100:9: " + getCheckMessage ( MSG_ACCESS ) , "106:5: " + getCheckMessage ( MSG_ACCESS ) , "111:5: " + getCheckMessage ( MSG_ACCESS ) , "116:5: " + getCheckMessage ( MSG_ACCESS ) , "119:5: " + getCheckMessage ( MSG_ACCESS ) , "125:5: " + getCheckMessage ( MSG_STATIC ) , "125:5: " + getCheckMessage ( MSG_ACCESS ) , "132:9: " + getCheckMessage ( MSG_ACCESS ) , "143:9: " + getCheckMessage ( MSG_STATIC ) , "143:9: " + getCheckMessage ( MSG_ACCESS ) , "152:5: " + getCheckMessage ( MSG_CONSTRUCTOR ) , "178:5: " + getCheckMessage ( MSG_INSTANCE ) , } ; verify ( checkConfig , getPath ( "coding/InputDeclarationOrder.java" ) , expected ) ; } @ Test public void testOnlyConstructors ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DeclarationOrderCheck . class ) ; checkConfig . addAttribute ( "ignoreConstructors" , "false" ) ; checkConfig . addAttribute ( "ignoreMethods" , "true" ) ; checkConfig . addAttribute ( "ignoreModifiers" , "true" ) ; final String [ ] expected = { "45:9: " + getCheckMessage ( MSG_STATIC ) , "54:5: " + getCheckMessage ( MSG_CONSTRUCTOR ) , "80:5: " + getCheckMessage ( MSG_INSTANCE ) , "100:9: " + getCheckMessage ( MSG_STATIC ) , "143:9: " + getCheckMessage ( MSG_STATIC ) , "152:5: " + getCheckMessage ( MSG_CONSTRUCTOR ) , "178:5: " + getCheckMessage ( MSG_INSTANCE ) , } ; verify ( checkConfig , getPath ( "coding/InputDeclarationOrder.java" ) , expected ) ; } @ Test public void testOnlyModifiers ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DeclarationOrderCheck . class ) ; checkConfig . addAttribute ( "ignoreConstructors" , "true" ) ; checkConfig . addAttribute ( "ignoreMethods" , "true" ) ; checkConfig . addAttribute ( "ignoreModifiers" , "false" ) ; final String [ ] expected = { "8:5: " + getCheckMessage ( MSG_ACCESS ) , "13:5: " + getCheckMessage ( MSG_ACCESS ) , "18:5: " + getCheckMessage ( MSG_ACCESS ) , "21:5: " + getCheckMessage ( MSG_ACCESS ) , "27:5: " + getCheckMessage ( MSG_STATIC ) , "27:5: " + getCheckMessage ( MSG_ACCESS ) , "34:9: " + getCheckMessage ( MSG_ACCESS ) , "45:9: " + getCheckMessage ( MSG_STATIC ) , "45:9: " + getCheckMessage ( MSG_ACCESS ) , "80:5: " + getCheckMessage ( MSG_INSTANCE ) , "92:9: " + getCheckMessage ( MSG_ACCESS ) , "100:9: " + getCheckMessage ( MSG_STATIC ) , "100:9: " + getCheckMessage ( MSG_ACCESS ) , "106:5: " + getCheckMessage ( MSG_ACCESS ) , "111:5: " + getCheckMessage ( MSG_ACCESS ) , "116:5: " + getCheckMessage ( MSG_ACCESS ) , "119:5: " + getCheckMessage ( MSG_ACCESS ) , "125:5: " + getCheckMessage ( MSG_STATIC ) , "125:5: " + getCheckMessage ( MSG_ACCESS ) , "132:9: " + getCheckMessage ( MSG_ACCESS ) , "143:9: " + getCheckMessage ( MSG_STATIC ) , "143:9: " + getCheckMessage ( MSG_ACCESS ) , "178:5: " + getCheckMessage ( MSG_INSTANCE ) , } ; verify ( checkConfig , getPath ( "coding/InputDeclarationOrder.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { DeclarationOrderCheck check = new DeclarationOrderCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . ArrayTrailingCommaCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class ArrayTrailingCommaCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ArrayTrailingCommaCheck . class ) ; final String [ ] expected = { "17: " + getCheckMessage ( MSG_KEY ) , "34: " + getCheckMessage ( MSG_KEY ) , "37: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputArrayTrailingComma.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { ArrayTrailingCommaCheck check = new ArrayTrailingCommaCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . MultipleVariableDeclarationsCheck . MSG_MULTIPLE ; import static com . puppycrawl . tools . checkstyle . checks . coding . MultipleVariableDeclarationsCheck . MSG_MULTIPLE_COMMA ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class MultipleVariableDeclarationsCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MultipleVariableDeclarationsCheck . class ) ; final String [ ] expected = { "4:5: " + getCheckMessage ( MSG_MULTIPLE_COMMA ) , "5:5: " + getCheckMessage ( MSG_MULTIPLE ) , "8:9: " + getCheckMessage ( MSG_MULTIPLE_COMMA ) , "9:9: " + getCheckMessage ( MSG_MULTIPLE ) , "13:5: " + getCheckMessage ( MSG_MULTIPLE ) , "16:5: " + getCheckMessage ( MSG_MULTIPLE ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputMultipleVariableDeclarations.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { MultipleVariableDeclarationsCheck check = new MultipleVariableDeclarationsCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . InnerAssignmentCheck . MSG_KEY ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class InnerAssignmentCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( InnerAssignmentCheck . class ) ; final String [ ] expected = { "16:15: " + getCheckMessage ( MSG_KEY ) , "16:19: " + getCheckMessage ( MSG_KEY ) , "18:39: " + getCheckMessage ( MSG_KEY ) , "20:35: " + getCheckMessage ( MSG_KEY ) , "38:16: " + getCheckMessage ( MSG_KEY ) , "39:24: " + getCheckMessage ( MSG_KEY ) , "40:19: " + getCheckMessage ( MSG_KEY ) , "41:17: " + getCheckMessage ( MSG_KEY ) , "42:29: " + getCheckMessage ( MSG_KEY ) , "43:20: " + getCheckMessage ( MSG_KEY ) , "44:17: " + getCheckMessage ( MSG_KEY ) , "44:31: " + getCheckMessage ( MSG_KEY ) , "44:41: " + getCheckMessage ( MSG_KEY ) , "45:16: " + getCheckMessage ( MSG_KEY ) , "45:27: " + getCheckMessage ( MSG_KEY ) , "46:32: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputInnerAssignment.java" ) , expected ) ; } @ Test public void testLambdexpression ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( InnerAssignmentCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/coding/" + "InputInnerAssignmentLambdaExpressions.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testTokensNotNull ( ) { InnerAssignmentCheck check = new InnerAssignmentCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . OneStatementPerLineCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class OneStatementPerLineCheckTest extends BaseCheckTestSupport { @ Test public void testMultiCaseClass ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( OneStatementPerLineCheck . class ) ; final String [ ] expected = { "99:18: " + getCheckMessage ( MSG_KEY ) , "127:11: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "checks/coding/OneStatementPerLineCheckInput.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { OneStatementPerLineCheck check = new OneStatementPerLineCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . DefaultComesLastCheck . MSG_KEY ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class DefaultComesLastCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DefaultComesLastCheck . class ) ; final String [ ] expected = { "24:9: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputDefaultComesLast.java" ) , expected ) ; } @ Test public void testDefaultMethodsInJava8 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DefaultComesLastCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/coding/InputDefaultComesLast2.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testTokensNotNull ( ) { DefaultComesLastCheck check = new DefaultComesLastCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . coding . NoFinalizerCheck . MSG_KEY ; public class NoFinalizerCheckTest extends BaseCheckTestSupport { @ Test public void testHasFinalizer ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NoFinalizerCheck . class ) ; final String [ ] expected = { "5: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "coding/InputHasFinalizer.java" ) , expected ) ; } @ Test public void testHasNoFinalizer ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NoFinalizerCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "coding/InputFallThrough.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . RequireThisCheck . MSG_METHOD ; import static com . puppycrawl . tools . checkstyle . checks . coding . RequireThisCheck . MSG_VARIABLE ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class RequireThisCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RequireThisCheck . class ) ; final String [ ] expected = { "11:9: " + getCheckMessage ( MSG_VARIABLE , "i" , "\"this\"" ) , "17:9: " + getCheckMessage ( MSG_METHOD , "method1" , "\"this\"" ) , "31:9: " + getCheckMessage ( MSG_VARIABLE , "i" , "\"this\"" ) , "49:13: " + getCheckMessage ( MSG_VARIABLE , "z" , "\"this\"" ) , "56:9: " + getCheckMessage ( MSG_VARIABLE , "z" , "\"this\"" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputRequireThis.java" ) , expected ) ; } @ Test public void testMethodsOnly ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RequireThisCheck . class ) ; checkConfig . addAttribute ( "checkFields" , "false" ) ; final String [ ] expected = { "17:9: " + getCheckMessage ( MSG_METHOD , "method1" , "\"this\"" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputRequireThis.java" ) , expected ) ; } @ Test public void testFieldsOnly ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RequireThisCheck . class ) ; checkConfig . addAttribute ( "checkMethods" , "false" ) ; final String [ ] expected = { "11:9: " + getCheckMessage ( MSG_VARIABLE , "i" , "\"this\"" ) , "31:9: " + getCheckMessage ( MSG_VARIABLE , "i" , "\"this\"" ) , "49:13: " + getCheckMessage ( MSG_VARIABLE , "z" , "\"this\"" ) , "56:9: " + getCheckMessage ( MSG_VARIABLE , "z" , "\"this\"" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputRequireThis.java" ) , expected ) ; } @ Test public void testGenerics ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RequireThisCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "Input15Extensions.java" ) , expected ) ; } @ Test public void testGithubIssue41 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RequireThisCheck . class ) ; final String [ ] expected = { "7:19: " + getCheckMessage ( MSG_VARIABLE , "number" , "\"this\"" ) , "8:16: " + getCheckMessage ( MSG_METHOD , "other" , "\"this\"" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputRequireThis2.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { RequireThisCheck check = new RequireThisCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . PackageDeclarationCheck . MSG_KEY ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class PackageDeclarationCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( PackageDeclarationCheck . class ) ; String [ ] expected = { "4: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/coding/InputNoPackage.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testOnFileWithCommentOnly ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( PackageDeclarationCheck . class ) ; String [ ] expected = { "1: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputWithCommentOnly.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { PackageDeclarationCheck check = new PackageDeclarationCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . NestedIfDepthCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class NestedIfDepthCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NestedIfDepthCheck . class ) ; final String [ ] expected = { "18:17: " + getCheckMessage ( MSG_KEY , 2 , 1 ) , "44:17: " + getCheckMessage ( MSG_KEY , 2 , 1 ) , } ; verify ( checkConfig , getPath ( "coding/InputNestedIfDepth.java" ) , expected ) ; } @ Test public void testCustonestingDepth ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NestedIfDepthCheck . class ) ; checkConfig . addAttribute ( "max" , "2" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "coding/InputNestedIfDepth.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { NestedIfDepthCheck check = new NestedIfDepthCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle ; import org . junit . Assert ; import java . lang . reflect . Constructor ; import java . lang . reflect . Modifier ; public class TestUtils { private TestUtils ( ) { } public static void assertUtilsClassHasPrivateConstructor ( final Class < ? > utilClass ) throws ReflectiveOperationException { final Constructor < ? > constructor = utilClass . getDeclaredConstructor ( ) ; if ( ! Modifier . isPrivate ( constructor . getModifiers ( ) ) ) { Assert . fail ( "Constructor is not private" ) ; } constructor . setAccessible ( true ) ; constructor . newInstance ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . IllegalCatchCheck . MSG_KEY ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class IllegalCatchCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( IllegalCatchCheck . class ) ; String [ ] expected = { "6:11: " + getCheckMessage ( MSG_KEY , "RuntimeException" ) , "7:11: " + getCheckMessage ( MSG_KEY , "Exception" ) , "8:11: " + getCheckMessage ( MSG_KEY , "Throwable" ) , "14:11: " + getCheckMessage ( MSG_KEY , "java.lang.RuntimeException" ) , "15:11: " + getCheckMessage ( MSG_KEY , "java.lang.Exception" ) , "16:11: " + getCheckMessage ( MSG_KEY , "java.lang.Throwable" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalCatchCheck.java" ) , expected ) ; } @ Test public void testIllegalClassNames ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( IllegalCatchCheck . class ) ; checkConfig . addAttribute ( "illegalClassNames" , "java.lang.Error, java.lang.Exception, java.lang.Throwable" ) ; String [ ] expected = { "7:11: " + getCheckMessage ( MSG_KEY , "Exception" ) , "8:11: " + getCheckMessage ( MSG_KEY , "Throwable" ) , "15:11: " + getCheckMessage ( MSG_KEY , "java.lang.Exception" ) , "16:11: " + getCheckMessage ( MSG_KEY , "java.lang.Throwable" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalCatchCheck.java" ) , expected ) ; } @ Test public void testMultipleTypes ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( IllegalCatchCheck . class ) ; String [ ] expected = { "7:11: " + getCheckMessage ( MSG_KEY , "RuntimeException" ) , "10:11: " + getCheckMessage ( MSG_KEY , "RuntimeException" ) , "13:11: " + getCheckMessage ( MSG_KEY , "RuntimeException" ) , "16:11: " + getCheckMessage ( MSG_KEY , "RuntimeException" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalCatchCheck2.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { IllegalCatchCheck check = new IllegalCatchCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . MultipleStringLiteralsCheck . MSG_KEY ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class MultipleStringLiteralsCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MultipleStringLiteralsCheck . class ) ; checkConfig . addAttribute ( "allowedDuplicates" , "2" ) ; checkConfig . addAttribute ( "ignoreStringsRegexp" , "" ) ; final String [ ] expected = { "5:16: " + getCheckMessage ( MSG_KEY , "\"StringContents\"" , 3 ) , "8:17: " + getCheckMessage ( MSG_KEY , "\"\"" , 4 ) , "10:23: " + getCheckMessage ( MSG_KEY , "\", \"" , 3 ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputMultipleStringLiterals.java" ) , expected ) ; } @ Test public void testItIgnoreEmpty ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MultipleStringLiteralsCheck . class ) ; checkConfig . addAttribute ( "allowedDuplicates" , "2" ) ; final String [ ] expected = { "5:16: " + getCheckMessage ( MSG_KEY , "\"StringContents\"" , 3 ) , "10:23: " + getCheckMessage ( MSG_KEY , "\", \"" , 3 ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputMultipleStringLiterals.java" ) , expected ) ; } @ Test public void testItIgnoreEmptyAndComspace ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MultipleStringLiteralsCheck . class ) ; checkConfig . addAttribute ( "allowedDuplicates" , "2" ) ; checkConfig . addAttribute ( "ignoreStringsRegexp" , "^((\"\")|(\", \"))$" ) ; final String [ ] expected = { "5:16: " + getCheckMessage ( MSG_KEY , "\"StringContents\"" , 3 ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputMultipleStringLiterals.java" ) , expected ) ; } @ Test public void testItWithoutIgnoringAnnotations ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MultipleStringLiteralsCheck . class ) ; checkConfig . addAttribute ( "allowedDuplicates" , "3" ) ; checkConfig . addAttribute ( "ignoreOccurrenceContext" , "" ) ; final String [ ] expected = { "19:23: " + getCheckMessage ( MSG_KEY , "\"unchecked\"" , 4 ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputMultipleStringLiterals.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { MultipleStringLiteralsCheck check = new MultipleStringLiteralsCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . CovariantEqualsCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class CovariantEqualsCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( CovariantEqualsCheck . class ) ; final String [ ] expected = { "11:24: " + getCheckMessage ( MSG_KEY ) , "30:20: " + getCheckMessage ( MSG_KEY ) , "64:20: " + getCheckMessage ( MSG_KEY ) , "78:28: " + getCheckMessage ( MSG_KEY ) , "134:20: " + getCheckMessage ( MSG_KEY ) , "138:9: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputCovariant.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { CovariantEqualsCheck check = new CovariantEqualsCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . IllegalTypeCheck . MSG_KEY ; import java . io . File ; import org . junit . Assert ; import org . junit . Before ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class IllegalTypeCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( IllegalTypeCheck . class ) ; } @ Test public void testDefaults ( ) throws Exception { String [ ] expected = { "6:13: " + getCheckMessage ( MSG_KEY , "AbstractClass" ) , "9:13: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.coding.InputIllegalType.AbstractClass" ) , "16:13: " + getCheckMessage ( MSG_KEY , "java.util.TreeSet" ) , "17:13: " + getCheckMessage ( MSG_KEY , "TreeSet" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalType.java" ) , expected ) ; } @ Test public void testIgnoreMethodNames ( ) throws Exception { checkConfig . addAttribute ( "ignoredMethodNames" , "table2" ) ; String [ ] expected = { "6:13: " + getCheckMessage ( MSG_KEY , "AbstractClass" ) , "9:13: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.coding.InputIllegalType.AbstractClass" ) , "16:13: " + getCheckMessage ( MSG_KEY , "java.util.TreeSet" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalType.java" ) , expected ) ; } @ Test public void testFormat ( ) throws Exception { checkConfig . addAttribute ( "format" , "^$" ) ; String [ ] expected = { "16:13: " + getCheckMessage ( MSG_KEY , "java.util.TreeSet" ) , "17:13: " + getCheckMessage ( MSG_KEY , "TreeSet" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalType.java" ) , expected ) ; } @ Test public void testLegalAbstractClassNames ( ) throws Exception { checkConfig . addAttribute ( "legalAbstractClassNames" , "AbstractClass" ) ; String [ ] expected = { "9:13: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.coding.InputIllegalType.AbstractClass" ) , "16:13: " + getCheckMessage ( MSG_KEY , "java.util.TreeSet" ) , "17:13: " + getCheckMessage ( MSG_KEY , "TreeSet" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalType.java" ) , expected ) ; } @ Test public void testSameFileNameFalsePositive ( ) throws Exception { checkConfig . addAttribute ( "illegalClassNames" , "java.util.GregorianCalendar, SubCalendar, " + "java.util.List" ) ; String [ ] expected = { "12:5: " + getCheckMessage ( MSG_KEY , "SubCalendar" ) , "27:5: " + getCheckMessage ( MSG_KEY , "java.util.List" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalTypeSameFileName.java" ) , expected ) ; } @ Test public void testSameFileNameGeneral ( ) throws Exception { checkConfig . addAttribute ( "illegalClassNames" , "List, GregorianCalendar, java.io.File, ArrayList" ) ; String [ ] expected = { "10:5: " + getCheckMessage ( MSG_KEY , "GregorianCalendar" ) , "16:23: " + getCheckMessage ( MSG_KEY , "GregorianCalendar" ) , "24:9: " + getCheckMessage ( MSG_KEY , "List" ) , "25:9: " + getCheckMessage ( MSG_KEY , "java.io.File" ) , "27:5: " + getCheckMessage ( MSG_KEY , "java.util.List" ) , "28:13: " + getCheckMessage ( MSG_KEY , "ArrayList" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalTypeSameFileName.java" ) , expected ) ; } @ Test public void testStarImports ( ) throws Exception { checkConfig . addAttribute ( "illegalClassNames" , "List" ) ; String [ ] expected = { "10:5: " + getCheckMessage ( MSG_KEY , "List" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalTypeStarImports.java" ) , expected ) ; } @ Test public void testStaticImports ( ) throws Exception { checkConfig . addAttribute ( "illegalClassNames" , "SomeStaticClass" ) ; checkConfig . addAttribute ( "ignoredMethodNames" , "foo1" ) ; String [ ] expected = { "13:6: " + getCheckMessage ( MSG_KEY , "SomeStaticClass" ) , "15:31: " + getCheckMessage ( MSG_KEY , "SomeStaticClass" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalTypeStaticImports.java" ) , expected ) ; } @ Test public void testMemberModifiers ( ) throws Exception { checkConfig . addAttribute ( "memberModifiers" , "LITERAL_PRIVATE, LITERAL_PROTECTED," + " LITERAL_STATIC" ) ; String [ ] expected = { "6:13: " + getCheckMessage ( MSG_KEY , "AbstractClass" ) , "9:13: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.coding.InputIllegalTypeMemberModifiers.AbstractClass" ) , "16:13: " + getCheckMessage ( MSG_KEY , "java.util.TreeSet" ) , "17:13: " + getCheckMessage ( MSG_KEY , "TreeSet" ) , "23:15: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.coding.InputIllegalTypeMemberModifiers.AbstractClass" ) , "25:25: " + getCheckMessage ( MSG_KEY , "java.util.TreeSet" ) , "33:15: " + getCheckMessage ( MSG_KEY , "AbstractClass" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalTypeMemberModifiers.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { IllegalTypeCheck check = new IllegalTypeCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . EmptyStatementCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class EmptyStatementCheckTest extends BaseCheckTestSupport { @ Test public void testEmptyStatements ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( EmptyStatementCheck . class ) ; final String [ ] expected = { "12:7: " + getCheckMessage ( MSG_KEY ) , "17:7: " + getCheckMessage ( MSG_KEY ) , "22:19: " + getCheckMessage ( MSG_KEY ) , "26:10: " + getCheckMessage ( MSG_KEY ) , "29:16: " + getCheckMessage ( MSG_KEY ) , "33:10: " + getCheckMessage ( MSG_KEY ) , "43:10: " + getCheckMessage ( MSG_KEY ) , "49:13: " + getCheckMessage ( MSG_KEY ) , "51:13: " + getCheckMessage ( MSG_KEY ) , "54:19: " + getCheckMessage ( MSG_KEY ) , "58:10: " + getCheckMessage ( MSG_KEY ) , "61:9: " + getCheckMessage ( MSG_KEY ) , "66:10: " + getCheckMessage ( MSG_KEY ) , "72:10: " + getCheckMessage ( MSG_KEY ) , "76:10: " + getCheckMessage ( MSG_KEY ) , "80:10: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputEmptyStatement.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { EmptyStatementCheck check = new EmptyStatementCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . coding . NoCloneCheck . MSG_KEY ; public class NoCloneCheckTest extends BaseCheckTestSupport { @ Test public void testHasClone ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NoCloneCheck . class ) ; final String [ ] expected = { "10: " + getCheckMessage ( MSG_KEY ) , "27: " + getCheckMessage ( MSG_KEY ) , "35: " + getCheckMessage ( MSG_KEY ) , "39: " + getCheckMessage ( MSG_KEY ) , "52: " + getCheckMessage ( MSG_KEY ) , "60: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputClone.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . coding . MagicNumberCheck . MSG_KEY ; public class MagicNumberCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MagicNumberCheck . class ) ; final String [ ] expected = { "41:26: " + getCheckMessage ( MSG_KEY , "3_000" ) , "42:32: " + getCheckMessage ( MSG_KEY , "1.5_0" ) , "43:27: " + getCheckMessage ( MSG_KEY , "3" ) , "43:31: " + getCheckMessage ( MSG_KEY , "4" ) , "45:29: " + getCheckMessage ( MSG_KEY , "3" ) , "47:23: " + getCheckMessage ( MSG_KEY , "3" ) , "48:26: " + getCheckMessage ( MSG_KEY , "1.5" ) , "50:22: " + getCheckMessage ( MSG_KEY , "3" ) , "50:29: " + getCheckMessage ( MSG_KEY , "5" ) , "50:37: " + getCheckMessage ( MSG_KEY , "3" ) , "54:26: " + getCheckMessage ( MSG_KEY , "3" ) , "55:39: " + getCheckMessage ( MSG_KEY , "3" ) , "60:25: " + getCheckMessage ( MSG_KEY , "010" ) , "61:25: " + getCheckMessage ( MSG_KEY , "011" ) , "63:30: " + getCheckMessage ( MSG_KEY , "0_10L" ) , "64:30: " + getCheckMessage ( MSG_KEY , "011l" ) , "68:24: " + getCheckMessage ( MSG_KEY , "0x10" ) , "69:24: " + getCheckMessage ( MSG_KEY , "0X011" ) , "71:29: " + getCheckMessage ( MSG_KEY , "0x10L" ) , "72:29: " + getCheckMessage ( MSG_KEY , "0X11l" ) , "85:28: " + getCheckMessage ( MSG_KEY , "3" ) , "92:14: " + getCheckMessage ( MSG_KEY , "0xffffffffL" ) , "100:30: " + getCheckMessage ( MSG_KEY , "+3" ) , "101:29: " + getCheckMessage ( MSG_KEY , "-2" ) , "102:35: " + getCheckMessage ( MSG_KEY , "+3.5" ) , "103:36: " + getCheckMessage ( MSG_KEY , "-2.5" ) , "111:35: " + getCheckMessage ( MSG_KEY , "0x80000000" ) , "112:36: " + getCheckMessage ( MSG_KEY , "0x8000000000000000L" ) , "115:37: " + getCheckMessage ( MSG_KEY , "020000000000" ) , "116:38: " + getCheckMessage ( MSG_KEY , "01000000000000000000000L" ) , "131:20: " + getCheckMessage ( MSG_KEY , "378" ) , "160:16: " + getCheckMessage ( MSG_KEY , "31" ) , "165:16: " + getCheckMessage ( MSG_KEY , "42" ) , "170:16: " + getCheckMessage ( MSG_KEY , "13" ) , "174:15: " + getCheckMessage ( MSG_KEY , "21" ) , "178:15: " + getCheckMessage ( MSG_KEY , "37" ) , "182:15: " + getCheckMessage ( MSG_KEY , "101" ) , "185:26: " + getCheckMessage ( MSG_KEY , "42" ) , "189:32: " + getCheckMessage ( MSG_KEY , "43" ) , "193:26: " + getCheckMessage ( MSG_KEY , "-44" ) , "197:32: " + getCheckMessage ( MSG_KEY , "-45" ) , } ; verify ( checkConfig , getPath ( "InputMagicNumber.java" ) , expected ) ; } @ Test public void testIgnoreSome ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MagicNumberCheck . class ) ; checkConfig . addAttribute ( "ignoreNumbers" , "0, 1, 3.0, 8, 16, 3000" ) ; checkConfig . addAttribute ( "ignoreAnnotation" , "true" ) ; final String [ ] expected = { "22:25: " + getCheckMessage ( MSG_KEY , "2" ) , "28:35: " + getCheckMessage ( MSG_KEY , "2" ) , "30:24: " + getCheckMessage ( MSG_KEY , "2" ) , "32:29: " + getCheckMessage ( MSG_KEY , "2.0" ) , "34:29: " + getCheckMessage ( MSG_KEY , "2" ) , "36:17: " + getCheckMessage ( MSG_KEY , "2" ) , "38:19: " + getCheckMessage ( MSG_KEY , "2.0" ) , "42:32: " + getCheckMessage ( MSG_KEY , "1.5_0" ) , "43:31: " + getCheckMessage ( MSG_KEY , "4" ) , "48:26: " + getCheckMessage ( MSG_KEY , "1.5" ) , "50:29: " + getCheckMessage ( MSG_KEY , "5" ) , "61:25: " + getCheckMessage ( MSG_KEY , "011" ) , "64:30: " + getCheckMessage ( MSG_KEY , "011l" ) , "69:24: " + getCheckMessage ( MSG_KEY , "0X011" ) , "72:29: " + getCheckMessage ( MSG_KEY , "0X11l" ) , "92:14: " + getCheckMessage ( MSG_KEY , "0xffffffffL" ) , "101:29: " + getCheckMessage ( MSG_KEY , "-2" ) , "102:35: " + getCheckMessage ( MSG_KEY , "+3.5" ) , "103:36: " + getCheckMessage ( MSG_KEY , "-2.5" ) , "109:34: " + getCheckMessage ( MSG_KEY , "0xffffffff" ) , "110:36: " + getCheckMessage ( MSG_KEY , "0xffffffffffffffffL" ) , "111:35: " + getCheckMessage ( MSG_KEY , "0x80000000" ) , "112:36: " + getCheckMessage ( MSG_KEY , "0x8000000000000000L" ) , "113:36: " + getCheckMessage ( MSG_KEY , "037777777777" ) , "114:38: " + getCheckMessage ( MSG_KEY , "01777777777777777777777L" ) , "115:37: " + getCheckMessage ( MSG_KEY , "020000000000" ) , "116:38: " + getCheckMessage ( MSG_KEY , "01000000000000000000000L" ) , "131:20: " + getCheckMessage ( MSG_KEY , "378" ) , "160:16: " + getCheckMessage ( MSG_KEY , "31" ) , "165:16: " + getCheckMessage ( MSG_KEY , "42" ) , "170:16: " + getCheckMessage ( MSG_KEY , "13" ) , "174:15: " + getCheckMessage ( MSG_KEY , "21" ) , "178:15: " + getCheckMessage ( MSG_KEY , "37" ) , "182:15: " + getCheckMessage ( MSG_KEY , "101" ) , } ; verify ( checkConfig , getPath ( "InputMagicNumber.java" ) , expected ) ; } @ Test public void testIgnoreNone ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MagicNumberCheck . class ) ; checkConfig . addAttribute ( "ignoreNumbers" , "" ) ; checkConfig . addAttribute ( "ignoreAnnotation" , "true" ) ; final String [ ] expected = { "21:24: " + getCheckMessage ( MSG_KEY , "1" ) , "22:25: " + getCheckMessage ( MSG_KEY , "2" ) , "23:26: " + getCheckMessage ( MSG_KEY , "0L" ) , "24:26: " + getCheckMessage ( MSG_KEY , "0l" ) , "25:30: " + getCheckMessage ( MSG_KEY , "0D" ) , "26:30: " + getCheckMessage ( MSG_KEY , "0d" ) , "28:35: " + getCheckMessage ( MSG_KEY , "2" ) , "30:20: " + getCheckMessage ( MSG_KEY , "1" ) , "30:24: " + getCheckMessage ( MSG_KEY , "2" ) , "31:21: " + getCheckMessage ( MSG_KEY , "1" ) , "32:23: " + getCheckMessage ( MSG_KEY , "1.0" ) , "32:29: " + getCheckMessage ( MSG_KEY , "2.0" ) , "34:22: " + getCheckMessage ( MSG_KEY , "0" ) , "34:29: " + getCheckMessage ( MSG_KEY , "2" ) , "36:13: " + getCheckMessage ( MSG_KEY , "1" ) , "36:17: " + getCheckMessage ( MSG_KEY , "2" ) , "38:13: " + getCheckMessage ( MSG_KEY , "1.0" ) , "38:19: " + getCheckMessage ( MSG_KEY , "2.0" ) , "41:26: " + getCheckMessage ( MSG_KEY , "3_000" ) , "42:32: " + getCheckMessage ( MSG_KEY , "1.5_0" ) , "43:27: " + getCheckMessage ( MSG_KEY , "3" ) , "43:31: " + getCheckMessage ( MSG_KEY , "4" ) , "45:29: " + getCheckMessage ( MSG_KEY , "3" ) , "47:23: " + getCheckMessage ( MSG_KEY , "3" ) , "48:26: " + getCheckMessage ( MSG_KEY , "1.5" ) , "50:22: " + getCheckMessage ( MSG_KEY , "3" ) , "50:29: " + getCheckMessage ( MSG_KEY , "5" ) , "50:37: " + getCheckMessage ( MSG_KEY , "3" ) , "54:26: " + getCheckMessage ( MSG_KEY , "3" ) , "55:39: " + getCheckMessage ( MSG_KEY , "3" ) , "59:25: " + getCheckMessage ( MSG_KEY , "00" ) , "60:25: " + getCheckMessage ( MSG_KEY , "010" ) , "61:25: " + getCheckMessage ( MSG_KEY , "011" ) , "63:30: " + getCheckMessage ( MSG_KEY , "0_10L" ) , "64:30: " + getCheckMessage ( MSG_KEY , "011l" ) , "67:23: " + getCheckMessage ( MSG_KEY , "0x0" ) , "68:24: " + getCheckMessage ( MSG_KEY , "0x10" ) , "69:24: " + getCheckMessage ( MSG_KEY , "0X011" ) , "70:28: " + getCheckMessage ( MSG_KEY , "0x0L" ) , "71:29: " + getCheckMessage ( MSG_KEY , "0x10L" ) , "72:29: " + getCheckMessage ( MSG_KEY , "0X11l" ) , "85:28: " + getCheckMessage ( MSG_KEY , "3" ) , "92:14: " + getCheckMessage ( MSG_KEY , "0xffffffffL" ) , "100:30: " + getCheckMessage ( MSG_KEY , "+3" ) , "101:29: " + getCheckMessage ( MSG_KEY , "-2" ) , "102:35: " + getCheckMessage ( MSG_KEY , "+3.5" ) , "103:36: " + getCheckMessage ( MSG_KEY , "-2.5" ) , "109:34: " + getCheckMessage ( MSG_KEY , "0xffffffff" ) , "110:36: " + getCheckMessage ( MSG_KEY , "0xffffffffffffffffL" ) , "111:35: " + getCheckMessage ( MSG_KEY , "0x80000000" ) , "112:36: " + getCheckMessage ( MSG_KEY , "0x8000000000000000L" ) , "113:36: " + getCheckMessage ( MSG_KEY , "037777777777" ) , "114:38: " + getCheckMessage ( MSG_KEY , "01777777777777777777777L" ) , "115:37: " + getCheckMessage ( MSG_KEY , "020000000000" ) , "116:38: " + getCheckMessage ( MSG_KEY , "01000000000000000000000L" ) , "131:20: " + getCheckMessage ( MSG_KEY , "378" ) , "160:16: " + getCheckMessage ( MSG_KEY , "31" ) , "165:16: " + getCheckMessage ( MSG_KEY , "42" ) , "170:16: " + getCheckMessage ( MSG_KEY , "13" ) , "174:15: " + getCheckMessage ( MSG_KEY , "21" ) , "178:15: " + getCheckMessage ( MSG_KEY , "37" ) , "182:15: " + getCheckMessage ( MSG_KEY , "101" ) , } ; verify ( checkConfig , getPath ( "InputMagicNumber.java" ) , expected ) ; } @ Test public void testIntegersOnly ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MagicNumberCheck . class ) ; checkConfig . addAttribute ( "tokens" , "NUM_INT, NUM_LONG" ) ; checkConfig . addAttribute ( "ignoreAnnotation" , "true" ) ; final String [ ] expected = { "41:26: " + getCheckMessage ( MSG_KEY , "3_000" ) , "43:27: " + getCheckMessage ( MSG_KEY , "3" ) , "43:31: " + getCheckMessage ( MSG_KEY , "4" ) , "45:29: " + getCheckMessage ( MSG_KEY , "3" ) , "47:23: " + getCheckMessage ( MSG_KEY , "3" ) , "50:22: " + getCheckMessage ( MSG_KEY , "3" ) , "50:29: " + getCheckMessage ( MSG_KEY , "5" ) , "50:37: " + getCheckMessage ( MSG_KEY , "3" ) , "54:26: " + getCheckMessage ( MSG_KEY , "3" ) , "55:39: " + getCheckMessage ( MSG_KEY , "3" ) , "60:25: " + getCheckMessage ( MSG_KEY , "010" ) , "61:25: " + getCheckMessage ( MSG_KEY , "011" ) , "63:30: " + getCheckMessage ( MSG_KEY , "0_10L" ) , "64:30: " + getCheckMessage ( MSG_KEY , "011l" ) , "68:24: " + getCheckMessage ( MSG_KEY , "0x10" ) , "69:24: " + getCheckMessage ( MSG_KEY , "0X011" ) , "71:29: " + getCheckMessage ( MSG_KEY , "0x10L" ) , "72:29: " + getCheckMessage ( MSG_KEY , "0X11l" ) , "85:28: " + getCheckMessage ( MSG_KEY , "3" ) , "92:14: " + getCheckMessage ( MSG_KEY , "0xffffffffL" ) , "100:30: " + getCheckMessage ( MSG_KEY , "+3" ) , "101:29: " + getCheckMessage ( MSG_KEY , "-2" ) , "111:35: " + getCheckMessage ( MSG_KEY , "0x80000000" ) , "112:36: " + getCheckMessage ( MSG_KEY , "0x8000000000000000L" ) , "115:37: " + getCheckMessage ( MSG_KEY , "020000000000" ) , "116:38: " + getCheckMessage ( MSG_KEY , "01000000000000000000000L" ) , "131:20: " + getCheckMessage ( MSG_KEY , "378" ) , "160:16: " + getCheckMessage ( MSG_KEY , "31" ) , "165:16: " + getCheckMessage ( MSG_KEY , "42" ) , "170:16: " + getCheckMessage ( MSG_KEY , "13" ) , "174:15: " + getCheckMessage ( MSG_KEY , "21" ) , "178:15: " + getCheckMessage ( MSG_KEY , "37" ) , "182:15: " + getCheckMessage ( MSG_KEY , "101" ) , } ; verify ( checkConfig , getPath ( "InputMagicNumber.java" ) , expected ) ; } @ Test public void testIgnoreNegativeOctalHex ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MagicNumberCheck . class ) ; checkConfig . addAttribute ( "ignoreNumbers" , "-9223372036854775808, -2147483648, -1, 0, 1, 2" ) ; checkConfig . addAttribute ( "tokens" , "NUM_INT, NUM_LONG" ) ; checkConfig . addAttribute ( "ignoreAnnotation" , "true" ) ; final String [ ] expected = { "41:26: " + getCheckMessage ( MSG_KEY , "3_000" ) , "43:27: " + getCheckMessage ( MSG_KEY , "3" ) , "43:31: " + getCheckMessage ( MSG_KEY , "4" ) , "45:29: " + getCheckMessage ( MSG_KEY , "3" ) , "47:23: " + getCheckMessage ( MSG_KEY , "3" ) , "50:22: " + getCheckMessage ( MSG_KEY , "3" ) , "50:29: " + getCheckMessage ( MSG_KEY , "5" ) , "50:37: " + getCheckMessage ( MSG_KEY , "3" ) , "54:26: " + getCheckMessage ( MSG_KEY , "3" ) , "55:39: " + getCheckMessage ( MSG_KEY , "3" ) , "60:25: " + getCheckMessage ( MSG_KEY , "010" ) , "61:25: " + getCheckMessage ( MSG_KEY , "011" ) , "63:30: " + getCheckMessage ( MSG_KEY , "0_10L" ) , "64:30: " + getCheckMessage ( MSG_KEY , "011l" ) , "68:24: " + getCheckMessage ( MSG_KEY , "0x10" ) , "69:24: " + getCheckMessage ( MSG_KEY , "0X011" ) , "71:29: " + getCheckMessage ( MSG_KEY , "0x10L" ) , "72:29: " + getCheckMessage ( MSG_KEY , "0X11l" ) , "85:28: " + getCheckMessage ( MSG_KEY , "3" ) , "92:14: " + getCheckMessage ( MSG_KEY , "0xffffffffL" ) , "100:30: " + getCheckMessage ( MSG_KEY , "+3" ) , "101:29: " + getCheckMessage ( MSG_KEY , "-2" ) , "131:20: " + getCheckMessage ( MSG_KEY , "378" ) , "160:16: " + getCheckMessage ( MSG_KEY , "31" ) , "165:16: " + getCheckMessage ( MSG_KEY , "42" ) , "170:16: " + getCheckMessage ( MSG_KEY , "13" ) , "174:15: " + getCheckMessage ( MSG_KEY , "21" ) , "178:15: " + getCheckMessage ( MSG_KEY , "37" ) , "182:15: " + getCheckMessage ( MSG_KEY , "101" ) , } ; verify ( checkConfig , getPath ( "InputMagicNumber.java" ) , expected ) ; } @ Test public void testIgnoreHashCodeMethod ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MagicNumberCheck . class ) ; checkConfig . addAttribute ( "ignoreHashCodeMethod" , "true" ) ; checkConfig . addAttribute ( "ignoreAnnotation" , "true" ) ; final String [ ] expected = { "41:26: " + getCheckMessage ( MSG_KEY , "3_000" ) , "42:32: " + getCheckMessage ( MSG_KEY , "1.5_0" ) , "43:27: " + getCheckMessage ( MSG_KEY , "3" ) , "43:31: " + getCheckMessage ( MSG_KEY , "4" ) , "45:29: " + getCheckMessage ( MSG_KEY , "3" ) , "47:23: " + getCheckMessage ( MSG_KEY , "3" ) , "48:26: " + getCheckMessage ( MSG_KEY , "1.5" ) , "50:22: " + getCheckMessage ( MSG_KEY , "3" ) , "50:29: " + getCheckMessage ( MSG_KEY , "5" ) , "50:37: " + getCheckMessage ( MSG_KEY , "3" ) , "54:26: " + getCheckMessage ( MSG_KEY , "3" ) , "55:39: " + getCheckMessage ( MSG_KEY , "3" ) , "60:25: " + getCheckMessage ( MSG_KEY , "010" ) , "61:25: " + getCheckMessage ( MSG_KEY , "011" ) , "63:30: " + getCheckMessage ( MSG_KEY , "0_10L" ) , "64:30: " + getCheckMessage ( MSG_KEY , "011l" ) , "68:24: " + getCheckMessage ( MSG_KEY , "0x10" ) , "69:24: " + getCheckMessage ( MSG_KEY , "0X011" ) , "71:29: " + getCheckMessage ( MSG_KEY , "0x10L" ) , "72:29: " + getCheckMessage ( MSG_KEY , "0X11l" ) , "85:28: " + getCheckMessage ( MSG_KEY , "3" ) , "92:14: " + getCheckMessage ( MSG_KEY , "0xffffffffL" ) , "100:30: " + getCheckMessage ( MSG_KEY , "+3" ) , "101:29: " + getCheckMessage ( MSG_KEY , "-2" ) , "102:35: " + getCheckMessage ( MSG_KEY , "+3.5" ) , "103:36: " + getCheckMessage ( MSG_KEY , "-2.5" ) , "111:35: " + getCheckMessage ( MSG_KEY , "0x80000000" ) , "112:36: " + getCheckMessage ( MSG_KEY , "0x8000000000000000L" ) , "115:37: " + getCheckMessage ( MSG_KEY , "020000000000" ) , "116:38: " + getCheckMessage ( MSG_KEY , "01000000000000000000000L" ) , "131:20: " + getCheckMessage ( MSG_KEY , "378" ) , "165:16: " + getCheckMessage ( MSG_KEY , "42" ) , "170:16: " + getCheckMessage ( MSG_KEY , "13" ) , "174:15: " + getCheckMessage ( MSG_KEY , "21" ) , "178:15: " + getCheckMessage ( MSG_KEY , "37" ) , "182:15: " + getCheckMessage ( MSG_KEY , "101" ) , } ; verify ( checkConfig , getPath ( "InputMagicNumber.java" ) , expected ) ; } @ Test public void testIgnoreFieldDeclaration ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MagicNumberCheck . class ) ; checkConfig . addAttribute ( "ignoreFieldDeclaration" , "true" ) ; final String [ ] expected = { "41:26: " + getCheckMessage ( MSG_KEY , "3_000" ) , "42:32: " + getCheckMessage ( MSG_KEY , "1.5_0" ) , "43:27: " + getCheckMessage ( MSG_KEY , "3" ) , "43:31: " + getCheckMessage ( MSG_KEY , "4" ) , "45:29: " + getCheckMessage ( MSG_KEY , "3" ) , "47:23: " + getCheckMessage ( MSG_KEY , "3" ) , "48:26: " + getCheckMessage ( MSG_KEY , "1.5" ) , "50:22: " + getCheckMessage ( MSG_KEY , "3" ) , "50:29: " + getCheckMessage ( MSG_KEY , "5" ) , "50:37: " + getCheckMessage ( MSG_KEY , "3" ) , "54:26: " + getCheckMessage ( MSG_KEY , "3" ) , "55:39: " + getCheckMessage ( MSG_KEY , "3" ) , "60:25: " + getCheckMessage ( MSG_KEY , "010" ) , "61:25: " + getCheckMessage ( MSG_KEY , "011" ) , "63:30: " + getCheckMessage ( MSG_KEY , "0_10L" ) , "64:30: " + getCheckMessage ( MSG_KEY , "011l" ) , "68:24: " + getCheckMessage ( MSG_KEY , "0x10" ) , "69:24: " + getCheckMessage ( MSG_KEY , "0X011" ) , "71:29: " + getCheckMessage ( MSG_KEY , "0x10L" ) , "72:29: " + getCheckMessage ( MSG_KEY , "0X11l" ) , "131:20: " + getCheckMessage ( MSG_KEY , "378" ) , "160:16: " + getCheckMessage ( MSG_KEY , "31" ) , "165:16: " + getCheckMessage ( MSG_KEY , "42" ) , "170:16: " + getCheckMessage ( MSG_KEY , "13" ) , "174:15: " + getCheckMessage ( MSG_KEY , "21" ) , "178:15: " + getCheckMessage ( MSG_KEY , "37" ) , "182:15: " + getCheckMessage ( MSG_KEY , "101" ) , "185:26: " + getCheckMessage ( MSG_KEY , "42" ) , "189:32: " + getCheckMessage ( MSG_KEY , "43" ) , "193:26: " + getCheckMessage ( MSG_KEY , "-44" ) , "197:32: " + getCheckMessage ( MSG_KEY , "-45" ) , } ; verify ( checkConfig , getPath ( "InputMagicNumber.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . AvoidInlineConditionalsCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class AvoidInlineConditionalsCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AvoidInlineConditionalsCheck . class ) ; final String [ ] expected = { "97:29: " + getCheckMessage ( MSG_KEY ) , "98:20: " + getCheckMessage ( MSG_KEY ) , "150:34: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { AvoidInlineConditionalsCheck check = new AvoidInlineConditionalsCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . UnnecessaryParenthesesCheck . MSG_ASSIGN ; import static com . puppycrawl . tools . checkstyle . checks . coding . UnnecessaryParenthesesCheck . MSG_EXPR ; import static com . puppycrawl . tools . checkstyle . checks . coding . UnnecessaryParenthesesCheck . MSG_IDENT ; import static com . puppycrawl . tools . checkstyle . checks . coding . UnnecessaryParenthesesCheck . MSG_LITERAL ; import static com . puppycrawl . tools . checkstyle . checks . coding . UnnecessaryParenthesesCheck . MSG_RETURN ; import static com . puppycrawl . tools . checkstyle . checks . coding . UnnecessaryParenthesesCheck . MSG_STRING ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class UnnecessaryParenthesesCheckTest extends BaseCheckTestSupport { private static final String TEST_FILE = "coding" + File . separator + "InputUnnecessaryParentheses.java" ; @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( UnnecessaryParenthesesCheck . class ) ; final String [ ] expected = { "5:22: " + getCheckMessage ( MSG_ASSIGN ) , "5:29: " + getCheckMessage ( MSG_EXPR ) , "5:31: " + getCheckMessage ( MSG_IDENT , "i" ) , "5:46: " + getCheckMessage ( MSG_ASSIGN ) , "6:15: " + getCheckMessage ( MSG_ASSIGN ) , "7:14: " + getCheckMessage ( MSG_IDENT , "x" ) , "7:17: " + getCheckMessage ( MSG_ASSIGN ) , "8:15: " + getCheckMessage ( MSG_ASSIGN ) , "9:14: " + getCheckMessage ( MSG_IDENT , "x" ) , "9:17: " + getCheckMessage ( MSG_ASSIGN ) , "12:22: " + getCheckMessage ( MSG_ASSIGN ) , "12:30: " + getCheckMessage ( MSG_IDENT , "i" ) , "12:46: " + getCheckMessage ( MSG_ASSIGN ) , "16:17: " + getCheckMessage ( MSG_LITERAL , "0" ) , "26:11: " + getCheckMessage ( MSG_ASSIGN ) , "30:11: " + getCheckMessage ( MSG_ASSIGN ) , "32:11: " + getCheckMessage ( MSG_ASSIGN ) , "34:11: " + getCheckMessage ( MSG_ASSIGN ) , "35:16: " + getCheckMessage ( MSG_IDENT , "a" ) , "36:14: " + getCheckMessage ( MSG_IDENT , "a" ) , "36:20: " + getCheckMessage ( MSG_IDENT , "b" ) , "36:26: " + getCheckMessage ( MSG_LITERAL , "600" ) , "36:40: " + getCheckMessage ( MSG_LITERAL , "12.5f" ) , "36:56: " + getCheckMessage ( MSG_IDENT , "arg2" ) , "37:14: " + getCheckMessage ( MSG_STRING , "\"this\"" ) , "37:25: " + getCheckMessage ( MSG_STRING , "\"that\"" ) , "38:11: " + getCheckMessage ( MSG_ASSIGN ) , "38:14: " + getCheckMessage ( MSG_STRING , "\"this is a really, really...\"" ) , "40:16: " + getCheckMessage ( MSG_RETURN ) , "44:21: " + getCheckMessage ( MSG_LITERAL , "1" ) , "44:26: " + getCheckMessage ( MSG_LITERAL , "13.5" ) , "45:22: " + getCheckMessage ( MSG_LITERAL , "true" ) , "46:17: " + getCheckMessage ( MSG_IDENT , "b" ) , "50:17: " + getCheckMessage ( MSG_ASSIGN ) , "52:11: " + getCheckMessage ( MSG_ASSIGN ) , "54:16: " + getCheckMessage ( MSG_RETURN ) , "64:13: " + getCheckMessage ( MSG_EXPR ) , "68:16: " + getCheckMessage ( MSG_EXPR ) , "73:19: " + getCheckMessage ( MSG_EXPR ) , "74:23: " + getCheckMessage ( MSG_LITERAL , "4000" ) , "79:19: " + getCheckMessage ( MSG_ASSIGN ) , "81:11: " + getCheckMessage ( MSG_ASSIGN ) , "81:16: " + getCheckMessage ( MSG_LITERAL , "3" ) , "82:27: " + getCheckMessage ( MSG_ASSIGN ) , } ; verify ( checkConfig , getPath ( TEST_FILE ) , expected ) ; } @ Test public void test15Extensions ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( UnnecessaryParenthesesCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "Input15Extensions.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { UnnecessaryParenthesesCheck check = new UnnecessaryParenthesesCheck ( ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . IllegalInstantiationCheck . MSG_KEY ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class IllegalInstantiationCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IllegalInstantiationCheck . class ) ; checkConfig . addAttribute ( "classes" , "java.lang.Boolean," + "com.puppycrawl.tools.checkstyle.InputModifier," + "java.io.File," + "java.awt.Color" ) ; final String [ ] expected = { "19:21: " + getCheckMessage ( MSG_KEY , "java.lang.Boolean" ) , "24:21: " + getCheckMessage ( MSG_KEY , "java.lang.Boolean" ) , "31:16: " + getCheckMessage ( MSG_KEY , "java.lang.Boolean" ) , "38:21: " + getCheckMessage ( MSG_KEY , "com.puppycrawl.tools.checkstyle.InputModifier" ) , "41:18: " + getCheckMessage ( MSG_KEY , "java.io.File" ) , "44:21: " + getCheckMessage ( MSG_KEY , "java.awt.Color" ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testJava8 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IllegalInstantiationCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/checkstyle/" + "coding/InputIllegalInstantiationCheckTest2.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testTokensNotNull ( ) { IllegalInstantiationCheck check = new IllegalInstantiationCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; import static org . junit . Assert . assertEquals ; import com . puppycrawl . tools . checkstyle . Utils ; import org . junit . Test ; public class TokenTypesTest { @ Test public void testGetShortDescription ( ) { assertEquals ( "short description for EQUAL" , "The <code>==</code> (equal) operator." , Utils . getShortDescription ( "EQUAL" ) ) ; } @ Test public void testIsProperUtilsClass ( ) throws ReflectiveOperationException { assertUtilsClassHasPrivateConstructor ( TokenTypes . class ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . NestedTryDepthCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class NestedTryDepthCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NestedTryDepthCheck . class ) ; final String [ ] expected = { "22:17: " + getCheckMessage ( MSG_KEY , 2 , 1 ) , "33:17: " + getCheckMessage ( MSG_KEY , 2 , 1 ) , "34:21: " + getCheckMessage ( MSG_KEY , 3 , 1 ) , } ; verify ( checkConfig , getPath ( "coding/InputNestedTryDepth.java" ) , expected ) ; } @ Test public void testCustonestingDepth ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NestedTryDepthCheck . class ) ; checkConfig . addAttribute ( "max" , "2" ) ; final String [ ] expected = { "34:21: " + getCheckMessage ( MSG_KEY , 3 , 2 ) , } ; verify ( checkConfig , getPath ( "coding/InputNestedTryDepth.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { NestedTryDepthCheck check = new NestedTryDepthCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . SimplifyBooleanReturnCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class SimplifyBooleanReturnCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( SimplifyBooleanReturnCheck . class ) ; final String [ ] expected = { "20:9: " + getCheckMessage ( MSG_KEY ) , "33:9: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputSimplifyBoolean.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { SimplifyBooleanReturnCheck check = new SimplifyBooleanReturnCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . HiddenFieldCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class HiddenFieldCheckTest extends BaseCheckTestSupport { @ Test public void testNoParameters ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HiddenFieldCheck . class ) ; checkConfig . addAttribute ( "tokens" , "VARIABLE_DEF" ) ; final String [ ] expected = { "18:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "27:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "32:18: " + getCheckMessage ( MSG_KEY , "hidden" ) , "46:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "55:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "56:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "61:22: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "64:22: " + getCheckMessage ( MSG_KEY , "hidden" ) , "76:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "77:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "82:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "138:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "143:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "148:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "152:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "200:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "217:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "223:13: " + getCheckMessage ( MSG_KEY , "hiddenStatic" ) , } ; verify ( checkConfig , getPath ( "InputHiddenField.java" ) , expected ) ; } @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HiddenFieldCheck . class ) ; final String [ ] expected = { "18:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "21:33: " + getCheckMessage ( MSG_KEY , "hidden" ) , "27:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "32:18: " + getCheckMessage ( MSG_KEY , "hidden" ) , "36:33: " + getCheckMessage ( MSG_KEY , "hidden" ) , "46:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "49:26: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "55:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "56:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "61:22: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "64:22: " + getCheckMessage ( MSG_KEY , "hidden" ) , "69:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "70:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "76:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "77:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "82:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "100:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "106:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "112:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "124:28: " + getCheckMessage ( MSG_KEY , "prop" ) , "138:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "143:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "148:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "152:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "179:23: " + getCheckMessage ( MSG_KEY , "y" ) , "200:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "210:20: " + getCheckMessage ( MSG_KEY , "hidden" ) , "217:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "223:13: " + getCheckMessage ( MSG_KEY , "hiddenStatic" ) , "230:41: " + getCheckMessage ( MSG_KEY , "x" ) , "236:30: " + getCheckMessage ( MSG_KEY , "xAxis" ) , "253:40: " + getCheckMessage ( MSG_KEY , "prop" ) , "267:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "278:41: " + getCheckMessage ( MSG_KEY , "prop2" ) , "290:19: " + getCheckMessage ( MSG_KEY , "i" ) , } ; verify ( checkConfig , getPath ( "InputHiddenField.java" ) , expected ) ; } @ Test public void testIgnoreFormat ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HiddenFieldCheck . class ) ; checkConfig . addAttribute ( "ignoreFormat" , "^i.*$" ) ; Assert . assertNotNull ( checkConfig . getAttribute ( "ignoreFormat" ) ) ; final String [ ] expected = { "18:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "21:33: " + getCheckMessage ( MSG_KEY , "hidden" ) , "27:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "32:18: " + getCheckMessage ( MSG_KEY , "hidden" ) , "36:33: " + getCheckMessage ( MSG_KEY , "hidden" ) , "56:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "64:22: " + getCheckMessage ( MSG_KEY , "hidden" ) , "70:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "77:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "82:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "100:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "106:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "112:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "124:28: " + getCheckMessage ( MSG_KEY , "prop" ) , "138:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "143:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "148:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "152:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "179:23: " + getCheckMessage ( MSG_KEY , "y" ) , "200:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "210:20: " + getCheckMessage ( MSG_KEY , "hidden" ) , "217:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "223:13: " + getCheckMessage ( MSG_KEY , "hiddenStatic" ) , "230:41: " + getCheckMessage ( MSG_KEY , "x" ) , "236:30: " + getCheckMessage ( MSG_KEY , "xAxis" ) , "253:40: " + getCheckMessage ( MSG_KEY , "prop" ) , "267:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "278:41: " + getCheckMessage ( MSG_KEY , "prop2" ) , } ; verify ( checkConfig , getPath ( "InputHiddenField.java" ) , expected ) ; } @ Test public void testIgnoreSetter ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HiddenFieldCheck . class ) ; checkConfig . addAttribute ( "ignoreSetter" , "true" ) ; final String [ ] expected = { "18:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "21:33: " + getCheckMessage ( MSG_KEY , "hidden" ) , "27:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "32:18: " + getCheckMessage ( MSG_KEY , "hidden" ) , "36:33: " + getCheckMessage ( MSG_KEY , "hidden" ) , "46:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "49:26: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "55:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "56:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "61:22: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "64:22: " + getCheckMessage ( MSG_KEY , "hidden" ) , "69:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "70:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "76:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "77:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "82:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "106:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "112:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "124:28: " + getCheckMessage ( MSG_KEY , "prop" ) , "138:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "143:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "148:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "152:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "179:23: " + getCheckMessage ( MSG_KEY , "y" ) , "200:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "210:20: " + getCheckMessage ( MSG_KEY , "hidden" ) , "217:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "223:13: " + getCheckMessage ( MSG_KEY , "hiddenStatic" ) , "230:41: " + getCheckMessage ( MSG_KEY , "x" ) , "253:40: " + getCheckMessage ( MSG_KEY , "prop" ) , "278:41: " + getCheckMessage ( MSG_KEY , "prop2" ) , } ; verify ( checkConfig , getPath ( "InputHiddenField.java" ) , expected ) ; } @ Test public void testIgnoreChainSetter ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HiddenFieldCheck . class ) ; checkConfig . addAttribute ( "ignoreSetter" , "true" ) ; checkConfig . addAttribute ( "setterCanReturnItsClass" , "true" ) ; final String [ ] expected = { "18:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "21:33: " + getCheckMessage ( MSG_KEY , "hidden" ) , "27:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "32:18: " + getCheckMessage ( MSG_KEY , "hidden" ) , "36:33: " + getCheckMessage ( MSG_KEY , "hidden" ) , "46:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "49:26: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "55:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "56:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "61:22: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "64:22: " + getCheckMessage ( MSG_KEY , "hidden" ) , "69:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "70:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "76:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "77:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "82:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "106:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "112:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "124:28: " + getCheckMessage ( MSG_KEY , "prop" ) , "138:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "143:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "148:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "152:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "179:23: " + getCheckMessage ( MSG_KEY , "y" ) , "200:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "210:20: " + getCheckMessage ( MSG_KEY , "hidden" ) , "217:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "223:13: " + getCheckMessage ( MSG_KEY , "hiddenStatic" ) , "230:41: " + getCheckMessage ( MSG_KEY , "x" ) , } ; verify ( checkConfig , getPath ( "InputHiddenField.java" ) , expected ) ; } @ Test public void testIgnoreConstructorParameter ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HiddenFieldCheck . class ) ; checkConfig . addAttribute ( "ignoreConstructorParameter" , "true" ) ; final String [ ] expected = { "18:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "27:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "32:18: " + getCheckMessage ( MSG_KEY , "hidden" ) , "36:33: " + getCheckMessage ( MSG_KEY , "hidden" ) , "46:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "55:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "56:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "61:22: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "64:22: " + getCheckMessage ( MSG_KEY , "hidden" ) , "69:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "70:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "76:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "77:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "82:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "100:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "106:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "112:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "124:28: " + getCheckMessage ( MSG_KEY , "prop" ) , "138:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "143:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "148:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "152:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "179:23: " + getCheckMessage ( MSG_KEY , "y" ) , "200:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "217:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "223:13: " + getCheckMessage ( MSG_KEY , "hiddenStatic" ) , "230:41: " + getCheckMessage ( MSG_KEY , "x" ) , "236:30: " + getCheckMessage ( MSG_KEY , "xAxis" ) , "253:40: " + getCheckMessage ( MSG_KEY , "prop" ) , "267:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "278:41: " + getCheckMessage ( MSG_KEY , "prop2" ) , "290:19: " + getCheckMessage ( MSG_KEY , "i" ) , } ; verify ( checkConfig , getPath ( "InputHiddenField.java" ) , expected ) ; } @ Test public void testReordered ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HiddenFieldCheck . class ) ; final String [ ] expected = { "18:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "21:40: " + getCheckMessage ( MSG_KEY , "hidden" ) , "27:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "32:18: " + getCheckMessage ( MSG_KEY , "hidden" ) , "36:33: " + getCheckMessage ( MSG_KEY , "hidden" ) , "46:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "49:26: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "55:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "56:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "61:22: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "64:22: " + getCheckMessage ( MSG_KEY , "hidden" ) , "69:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "70:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "76:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "77:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "83:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "105:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "118:21: " + getCheckMessage ( MSG_KEY , "hidden" ) , "125:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "131:13: " + getCheckMessage ( MSG_KEY , "hiddenStatic" ) , } ; verify ( checkConfig , getPath ( "InputHiddenFieldReorder.java" ) , expected ) ; } @ Test public void testIgnoreAbstractMethods ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HiddenFieldCheck . class ) ; checkConfig . addAttribute ( "ignoreAbstractMethods" , "true" ) ; final String [ ] expected = { "18:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "21:33: " + getCheckMessage ( MSG_KEY , "hidden" ) , "27:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "32:18: " + getCheckMessage ( MSG_KEY , "hidden" ) , "36:33: " + getCheckMessage ( MSG_KEY , "hidden" ) , "46:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "49:26: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "55:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "56:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "61:22: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "64:22: " + getCheckMessage ( MSG_KEY , "hidden" ) , "69:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "70:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "76:17: " + getCheckMessage ( MSG_KEY , "innerHidden" ) , "77:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "82:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "100:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "106:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "112:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "124:28: " + getCheckMessage ( MSG_KEY , "prop" ) , "138:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "143:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "148:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "152:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "179:23: " + getCheckMessage ( MSG_KEY , "y" ) , "200:17: " + getCheckMessage ( MSG_KEY , "hidden" ) , "210:20: " + getCheckMessage ( MSG_KEY , "hidden" ) , "217:13: " + getCheckMessage ( MSG_KEY , "hidden" ) , "223:13: " + getCheckMessage ( MSG_KEY , "hiddenStatic" ) , "236:30: " + getCheckMessage ( MSG_KEY , "xAxis" ) , "253:40: " + getCheckMessage ( MSG_KEY , "prop" ) , "267:29: " + getCheckMessage ( MSG_KEY , "prop" ) , "278:41: " + getCheckMessage ( MSG_KEY , "prop2" ) , "290:19: " + getCheckMessage ( MSG_KEY , "i" ) , } ; verify ( checkConfig , getPath ( "InputHiddenField.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . FinalLocalVariableCheck . MSG_KEY ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class FinalLocalVariableCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalLocalVariableCheck . class ) ; final String [ ] expected = { "9:13: " + getCheckMessage ( MSG_KEY , "i" ) , "9:16: " + getCheckMessage ( MSG_KEY , "j" ) , "10:18: " + getCheckMessage ( MSG_KEY , "runnable" ) , "20:13: " + getCheckMessage ( MSG_KEY , "i" ) , "24:13: " + getCheckMessage ( MSG_KEY , "z" ) , "26:16: " + getCheckMessage ( MSG_KEY , "obj" ) , "30:16: " + getCheckMessage ( MSG_KEY , "x" ) , "36:18: " + getCheckMessage ( MSG_KEY , "runnable" ) , "40:21: " + getCheckMessage ( MSG_KEY , "q" ) , "56:13: " + getCheckMessage ( MSG_KEY , "i" ) , "60:13: " + getCheckMessage ( MSG_KEY , "z" ) , "62:16: " + getCheckMessage ( MSG_KEY , "obj" ) , "66:16: " + getCheckMessage ( MSG_KEY , "x" ) , "74:21: " + getCheckMessage ( MSG_KEY , "w" ) , "75:26: " + getCheckMessage ( MSG_KEY , "runnable" ) , "96:17: " + getCheckMessage ( MSG_KEY , "weird" ) , "97:17: " + getCheckMessage ( MSG_KEY , "j" ) , "98:17: " + getCheckMessage ( MSG_KEY , "k" ) , } ; verify ( checkConfig , getPath ( "coding/InputFinalLocalVariable.java" ) , expected ) ; } @ Test public void testParameter ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalLocalVariableCheck . class ) ; checkConfig . addAttribute ( "tokens" , "PARAMETER_DEF" ) ; final String [ ] expected = { "45:28: " + getCheckMessage ( MSG_KEY , "aArg" ) , "149:36: " + getCheckMessage ( MSG_KEY , "_o" ) , "154:37: " + getCheckMessage ( MSG_KEY , "_o1" ) , } ; verify ( checkConfig , getPath ( "coding/InputFinalLocalVariable.java" ) , expected ) ; } @ Test public void testNativeMethods ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalLocalVariableCheck . class ) ; checkConfig . addAttribute ( "tokens" , "PARAMETER_DEF" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "coding/InputFinalLocalVariableNativeMethods.java" ) , expected ) ; } @ Test public void testFalsePositive ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalLocalVariableCheck . class ) ; checkConfig . addAttribute ( "tokens" , "VARIABLE_DEF, PARAMETER_DEF" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "coding/InputFinalLocalVariableCheckFalsePositive.java" ) , expected ) ; } @ Test public void testEnhancedForLoopVariableTrue ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalLocalVariableCheck . class ) ; checkConfig . addAttribute ( "tokens" , "VARIABLE_DEF, PARAMETER_DEF" ) ; checkConfig . addAttribute ( "validateEnhancedForLoopVariable" , "true" ) ; final String [ ] expected = { "8:20: " + "Variable 'a' should be declared final." , "15:13: " + "Variable 'x' should be declared final." , } ; verify ( checkConfig , getPath ( "coding/InputFinalLocalVariableEnhancedForLoopVariable.java" ) , expected ) ; } @ Test public void testEnhancedForLoopVariableFalse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalLocalVariableCheck . class ) ; checkConfig . addAttribute ( "tokens" , "VARIABLE_DEF, PARAMETER_DEF" ) ; final String [ ] expected = { "15:13: " + "Variable 'x' should be declared final." , } ; verify ( checkConfig , getPath ( "coding/InputFinalLocalVariableEnhancedForLoopVariable.java" ) , expected ) ; } @ Test public void testLambda ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalLocalVariableCheck . class ) ; checkConfig . addAttribute ( "tokens" , "PARAMETER_DEF,VARIABLE_DEF" ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/naming/InputFinalLocalVariableNameLambda.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testVariableNameShadowing ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalLocalVariableCheck . class ) ; checkConfig . addAttribute ( "tokens" , "PARAMETER_DEF,VARIABLE_DEF" ) ; final String [ ] expected = { "4:28: " + "Variable 'text' should be declared final." , "17:13: " + "Variable 'x' should be declared final." , } ; verify ( checkConfig , getPath ( "coding/InputFinalLocalVariableNameShadowing.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . ExplicitInitializationCheck . MSG_KEY ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class ExplicitInitializationCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ExplicitInitializationCheck . class ) ; final String [ ] expected = { "4:17: " + getCheckMessage ( MSG_KEY , "x" , 0 ) , "5:20: " + getCheckMessage ( MSG_KEY , "bar" , "null" ) , "9:18: " + getCheckMessage ( MSG_KEY , "y4" , 0 ) , "10:21: " + getCheckMessage ( MSG_KEY , "b1" , "false" ) , "14:22: " + getCheckMessage ( MSG_KEY , "str1" , "null" ) , "14:35: " + getCheckMessage ( MSG_KEY , "str3" , "null" ) , "15:9: " + getCheckMessage ( MSG_KEY , "ar1" , "null" ) , "18:11: " + getCheckMessage ( MSG_KEY , "f1" , 0 ) , "19:12: " + getCheckMessage ( MSG_KEY , "d1" , 0 ) , "22:17: " + getCheckMessage ( MSG_KEY , "ch1" , "\\0" ) , "23:17: " + getCheckMessage ( MSG_KEY , "ch2" , "\\0" ) , "39:25: " + getCheckMessage ( MSG_KEY , "bar" , "null" ) , "40:27: " + getCheckMessage ( MSG_KEY , "barArray" , "null" ) , "47:21: " + getCheckMessage ( MSG_KEY , "x" , 0 ) , "48:29: " + getCheckMessage ( MSG_KEY , "bar" , "null" ) , "49:31: " + getCheckMessage ( MSG_KEY , "barArray" , "null" ) , "52:17: " + getCheckMessage ( MSG_KEY , "x" , 0 ) , "53:25: " + getCheckMessage ( MSG_KEY , "bar" , "null" ) , "54:27: " + getCheckMessage ( MSG_KEY , "barArray" , "null" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputExplicitInit.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { ExplicitInitializationCheck check = new ExplicitInitializationCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . EqualsHashCodeCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class EqualsHashCodeCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( EqualsHashCodeCheck . class ) ; final String [ ] expected = { "126:9: " + getCheckMessage ( MSG_KEY ) , "163:13: " + getCheckMessage ( MSG_KEY ) , "191:9: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { EqualsHashCodeCheck check = new EqualsHashCodeCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . MissingCtorCheck . MSG_KEY ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class MissingCtorCheckTest extends BaseCheckTestSupport { @ Test public void testMissingSwitchDefault ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingCtorCheck . class ) ; final String [ ] expected = { "3:1: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputMissingCtor.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { MissingCtorCheck check = new MissingCtorCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . FallThroughCheck . MSG_FALL_THROUGH ; import static com . puppycrawl . tools . checkstyle . checks . coding . FallThroughCheck . MSG_FALL_THROUGH_LAST ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class FallThroughCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( FallThroughCheck . class ) ; final String [ ] expected = { "14:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "38:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "53:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "70:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "87:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "105:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "123:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "369:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "372:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "374:40: " + getCheckMessage ( MSG_FALL_THROUGH ) , "416:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputFallThrough.java" ) , expected ) ; } @ Test public void testLastCaseGroup ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( FallThroughCheck . class ) ; checkConfig . addAttribute ( "checkLastCaseGroup" , "true" ) ; final String [ ] expected = { "14:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "38:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "53:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "70:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "87:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "105:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "123:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "123:13: " + getCheckMessage ( MSG_FALL_THROUGH_LAST ) , "369:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "372:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "374:40: " + getCheckMessage ( MSG_FALL_THROUGH ) , "376:11: " + getCheckMessage ( MSG_FALL_THROUGH_LAST ) , "416:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputFallThrough.java" ) , expected ) ; } @ Test public void testOwnPattern ( ) throws Exception { final String ownPattern = "Continue with next case" ; final DefaultConfiguration checkConfig = createCheckConfig ( FallThroughCheck . class ) ; checkConfig . addAttribute ( "reliefPattern" , ownPattern ) ; final String [ ] expected = { "14:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "38:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "53:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "70:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "87:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "105:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "123:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , "145:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "170:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "186:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "204:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "222:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "241:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "252:26: " + getCheckMessage ( MSG_FALL_THROUGH ) , "266:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "281:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "284:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "288:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "290:25: " + getCheckMessage ( MSG_FALL_THROUGH ) , "306:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "309:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "311:25: " + getCheckMessage ( MSG_FALL_THROUGH ) , "327:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "330:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "332:23: " + getCheckMessage ( MSG_FALL_THROUGH ) , "348:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "351:11: " + getCheckMessage ( MSG_FALL_THROUGH ) , "353:30: " + getCheckMessage ( MSG_FALL_THROUGH ) , "416:13: " + getCheckMessage ( MSG_FALL_THROUGH ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputFallThrough.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { FallThroughCheck check = new FallThroughCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . IllegalTokenTextCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class IllegalTokenTextCheckTest extends BaseCheckTestSupport { @ Test public void testCaseSensitive ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IllegalTokenTextCheck . class ) ; checkConfig . addAttribute ( "tokens" , "STRING_LITERAL" ) ; checkConfig . addAttribute ( "format" , "a href" ) ; final String [ ] expected = { "24:28: " + getCheckMessage ( MSG_KEY , "a href" ) , } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } @ Test public void testCaseInSensitive ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( IllegalTokenTextCheck . class ) ; checkConfig . addAttribute ( "tokens" , "STRING_LITERAL" ) ; checkConfig . addAttribute ( "format" , "a href" ) ; checkConfig . addAttribute ( "ignoreCase" , "true" ) ; final String [ ] expected = { "24:28: " + getCheckMessage ( MSG_KEY , "a href" ) , "25:32: " + getCheckMessage ( MSG_KEY , "a href" ) , } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { IllegalTokenTextCheck check = new IllegalTokenTextCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . coding . AbstractSuperCheck . MSG_KEY ; public class SuperFinalizeCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( SuperFinalizeCheck . class ) ; final String [ ] expected = { "27:17: " + getCheckMessage ( MSG_KEY , "finalize" , "super.finalize" ) , "34:17: " + getCheckMessage ( MSG_KEY , "finalize" , "super.finalize" ) , } ; verify ( checkConfig , getPath ( "coding/InputFinalize.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import nl . jqno . equalsverifier . EqualsVerifier ; import org . junit . After ; import org . junit . Test ; import java . util . Locale ; import static org . junit . Assert . assertEquals ; public class LocalizedMessageTest { private static final Locale DEFAULT_LOCALE = Locale . getDefault ( ) ; @ Test public void testEqualsAndHashCode ( ) { EqualsVerifier . forClass ( LocalizedMessage . class ) . usingGetClass ( ) . verify ( ) ; } @ Test public void testGetModuleId ( ) { LocalizedMessage localizedMessage = createSampleLocalizedMessage ( ) ; assertEquals ( "module" , localizedMessage . getModuleId ( ) ) ; } @ Test public void testMessageInEnglish ( ) { LocalizedMessage localizedMessage = createSampleLocalizedMessage ( ) ; LocalizedMessage . setLocale ( Locale . ENGLISH ) ; assertEquals ( "Empty statement." , localizedMessage . getMessage ( ) ) ; } @ Test public void testMessageInFrench ( ) { LocalizedMessage localizedMessage = createSampleLocalizedMessage ( ) ; LocalizedMessage . setLocale ( Locale . FRENCH ) ; assertEquals ( "Instruction vide." , localizedMessage . getMessage ( ) ) ; } @ Test public void testEnforceEnglishLanguageBySettingUnitedStatesLocale ( ) { Locale . setDefault ( Locale . FRENCH ) ; LocalizedMessage . setLocale ( Locale . US ) ; LocalizedMessage localizedMessage = createSampleLocalizedMessage ( ) ; assertEquals ( "Empty statement." , localizedMessage . getMessage ( ) ) ; } @ Test public void testEnforceEnglishLanguageBySettingRootLocale ( ) { Locale . setDefault ( Locale . FRENCH ) ; LocalizedMessage . setLocale ( Locale . ROOT ) ; LocalizedMessage localizedMessage = createSampleLocalizedMessage ( ) ; assertEquals ( "Empty statement." , localizedMessage . getMessage ( ) ) ; } private static LocalizedMessage createSampleLocalizedMessage ( ) { return new LocalizedMessage ( 0 , "com.puppycrawl.tools.checkstyle.checks.coding.messages" , "empty.statement" , new Object [ ] { } , "module" , LocalizedMessage . class , null ) ; } @ After public void tearDown ( ) { Locale . setDefault ( DEFAULT_LOCALE ) ; LocalizedMessage . clearCache ( ) ; LocalizedMessage . setLocale ( DEFAULT_LOCALE ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . IllegalThrowsCheck . MSG_KEY ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class IllegalThrowsCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( IllegalThrowsCheck . class ) ; String [ ] expected = { "9:51: " + getCheckMessage ( MSG_KEY , "RuntimeException" ) , "14:45: " + getCheckMessage ( MSG_KEY , "java.lang.RuntimeException" ) , "14:73: " + getCheckMessage ( MSG_KEY , "java.lang.Error" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalThrowsCheck.java" ) , expected ) ; } @ Test public void testIllegalClassNames ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( IllegalThrowsCheck . class ) ; checkConfig . addAttribute ( "illegalClassNames" , "java.lang.Error, java.lang.Exception, NullPointerException" ) ; checkConfig . addAttribute ( "illegalClassNames" , "java.lang.IOException." ) ; String [ ] expected = { "5:33: " + getCheckMessage ( MSG_KEY , "NullPointerException" ) , "14:73: " + getCheckMessage ( MSG_KEY , "java.lang.Error" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalThrowsCheck.java" ) , expected ) ; } @ Test public void testIgnoreMethodNames ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( IllegalThrowsCheck . class ) ; checkConfig . addAttribute ( "ignoredMethodNames" , "methodTwo" ) ; String [ ] expected = { "9:51: " + getCheckMessage ( MSG_KEY , "RuntimeException" ) , "18:35: " + getCheckMessage ( MSG_KEY , "Throwable" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalThrowsCheck.java" ) , expected ) ; } @ Test public void testIllegalClassNamesWithIgnoreMethodNames ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( IllegalThrowsCheck . class ) ; checkConfig . addAttribute ( "illegalClassNames" , "java.lang.Error, java.lang.Exception, NullPointerException, Throwable" ) ; checkConfig . addAttribute ( "ignoredMethodNames" , "methodTwo" ) ; String [ ] expected = { "5:33: " + getCheckMessage ( MSG_KEY , "NullPointerException" ) , "18:35: " + getCheckMessage ( MSG_KEY , "Throwable" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalThrowsCheck.java" ) , expected ) ; } @ Test public void testIgnoreOverriddenMethods ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( IllegalThrowsCheck . class ) ; checkConfig . addAttribute ( "ignoreOverriddenMethods" , "true" ) ; String [ ] expected = { } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalThrowsCheckIgnoreOverriddenMethods.java" ) , expected ) ; } @ Test public void testNotIgnoreOverriddenMethods ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( IllegalThrowsCheck . class ) ; checkConfig . addAttribute ( "ignoreOverriddenMethods" , "false" ) ; String [ ] expected = { "7:36: " + getCheckMessage ( MSG_KEY , "RuntimeException" ) , "12:51: " + getCheckMessage ( MSG_KEY , "RuntimeException" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputIllegalThrowsCheckIgnoreOverriddenMethods.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { IllegalThrowsCheck check = new IllegalThrowsCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . StringLiteralEqualityCheck . MSG_KEY ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class StringLiteralEqualityCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( StringLiteralEqualityCheck . class ) ; final String [ ] expected = { "11:18: " + getCheckMessage ( MSG_KEY , "==" ) , "16:20: " + getCheckMessage ( MSG_KEY , "==" ) , "21:22: " + getCheckMessage ( MSG_KEY , "==" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputStringLiteralEquality.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { StringLiteralEqualityCheck check = new StringLiteralEqualityCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . VariableDeclarationUsageDistanceCheck . MSG_KEY ; import static com . puppycrawl . tools . checkstyle . checks . coding . VariableDeclarationUsageDistanceCheck . MSG_KEY_EXT ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class VariableDeclarationUsageDistanceCheckTest extends BaseCheckTestSupport { @ Test public void testGeneralLogic ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VariableDeclarationUsageDistanceCheck . class ) ; checkConfig . addAttribute ( "allowedDistance" , "1" ) ; checkConfig . addAttribute ( "ignoreVariablePattern" , "" ) ; checkConfig . addAttribute ( "validateBetweenScopes" , "true" ) ; checkConfig . addAttribute ( "ignoreFinal" , "false" ) ; final String [ ] expected = { "30: " + getCheckMessage ( MSG_KEY , "a" , 2 , 1 ) , "38: " + getCheckMessage ( MSG_KEY , "temp" , 2 , 1 ) , "44: " + getCheckMessage ( MSG_KEY , "temp" , 2 , 1 ) , "57: " + getCheckMessage ( MSG_KEY , "count" , 2 , 1 ) , "71: " + getCheckMessage ( MSG_KEY , "count" , 4 , 1 ) , "96: " + getCheckMessage ( MSG_KEY , "arg" , 2 , 1 ) , "144: " + getCheckMessage ( MSG_KEY , "m" , 3 , 1 ) , "145: " + getCheckMessage ( MSG_KEY , "n" , 2 , 1 ) , "184: " + getCheckMessage ( MSG_KEY , "result" , 2 , 1 ) , "219: " + getCheckMessage ( MSG_KEY , "t" , 5 , 1 ) , "222: " + getCheckMessage ( MSG_KEY , "c" , 3 , 1 ) , "223: " + getCheckMessage ( MSG_KEY , "d2" , 3 , 1 ) , "260: " + getCheckMessage ( MSG_KEY , "selected" , 2 , 1 ) , "261: " + getCheckMessage ( MSG_KEY , "model" , 2 , 1 ) , "287: " + getCheckMessage ( MSG_KEY , "sw" , 2 , 1 ) , "300: " + getCheckMessage ( MSG_KEY , "wh" , 2 , 1 ) , "343: " + getCheckMessage ( MSG_KEY , "green" , 2 , 1 ) , "344: " + getCheckMessage ( MSG_KEY , "blue" , 3 , 1 ) , "367: " + getCheckMessage ( MSG_KEY , "intervalMs" , 2 , 1 ) , "454: " + getCheckMessage ( MSG_KEY , "aOpt" , 3 , 1 ) , "455: " + getCheckMessage ( MSG_KEY , "bOpt" , 2 , 1 ) , "471: " + getCheckMessage ( MSG_KEY , "l1" , 3 , 1 ) , "471: " + getCheckMessage ( MSG_KEY , "l2" , 2 , 1 ) , "479: " + getCheckMessage ( MSG_KEY , "myOption" , 7 , 1 ) , "491: " + getCheckMessage ( MSG_KEY , "myOption" , 6 , 1 ) , "504: " + getCheckMessage ( MSG_KEY , "count" , 4 , 1 ) , "505: " + getCheckMessage ( MSG_KEY , "files" , 2 , 1 ) , "540: " + getCheckMessage ( MSG_KEY , "id" , 2 , 1 ) , "542: " + getCheckMessage ( MSG_KEY , "parentId" , 3 , 1 ) , } ; verify ( checkConfig , getPath ( "coding/InputVariableDeclarationUsageDistanceCheck.java" ) , expected ) ; } @ Test public void testDistance ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VariableDeclarationUsageDistanceCheck . class ) ; checkConfig . addAttribute ( "allowedDistance" , "3" ) ; checkConfig . addAttribute ( "ignoreVariablePattern" , "" ) ; checkConfig . addAttribute ( "validateBetweenScopes" , "true" ) ; checkConfig . addAttribute ( "ignoreFinal" , "false" ) ; final String [ ] expected = { "71: " + getCheckMessage ( MSG_KEY , "count" , 4 , 3 ) , "219: " + getCheckMessage ( MSG_KEY , "t" , 5 , 3 ) , "479: " + getCheckMessage ( MSG_KEY , "myOption" , 7 , 3 ) , "491: " + getCheckMessage ( MSG_KEY , "myOption" , 6 , 3 ) , "504: " + getCheckMessage ( MSG_KEY , "count" , 4 , 3 ) , } ; verify ( checkConfig , getPath ( "coding/InputVariableDeclarationUsageDistanceCheck.java" ) , expected ) ; } @ Test public void testVariableRegExp ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VariableDeclarationUsageDistanceCheck . class ) ; checkConfig . addAttribute ( "allowedDistance" , "1" ) ; checkConfig . addAttribute ( "ignoreVariablePattern" , "a|b|c|d|block|dist|t|m" ) ; checkConfig . addAttribute ( "validateBetweenScopes" , "true" ) ; checkConfig . addAttribute ( "ignoreFinal" , "false" ) ; final String [ ] expected = { "38: " + getCheckMessage ( MSG_KEY , "temp" , 2 , 1 ) , "44: " + getCheckMessage ( MSG_KEY , "temp" , 2 , 1 ) , "57: " + getCheckMessage ( MSG_KEY , "count" , 2 , 1 ) , "71: " + getCheckMessage ( MSG_KEY , "count" , 4 , 1 ) , "96: " + getCheckMessage ( MSG_KEY , "arg" , 2 , 1 ) , "145: " + getCheckMessage ( MSG_KEY , "n" , 2 , 1 ) , "184: " + getCheckMessage ( MSG_KEY , "result" , 2 , 1 ) , "223: " + getCheckMessage ( MSG_KEY , "d2" , 3 , 1 ) , "260: " + getCheckMessage ( MSG_KEY , "selected" , 2 , 1 ) , "261: " + getCheckMessage ( MSG_KEY , "model" , 2 , 1 ) , "287: " + getCheckMessage ( MSG_KEY , "sw" , 2 , 1 ) , "300: " + getCheckMessage ( MSG_KEY , "wh" , 2 , 1 ) , "343: " + getCheckMessage ( MSG_KEY , "green" , 2 , 1 ) , "344: " + getCheckMessage ( MSG_KEY , "blue" , 3 , 1 ) , "367: " + getCheckMessage ( MSG_KEY , "intervalMs" , 2 , 1 ) , "454: " + getCheckMessage ( MSG_KEY , "aOpt" , 3 , 1 ) , "455: " + getCheckMessage ( MSG_KEY , "bOpt" , 2 , 1 ) , "471: " + getCheckMessage ( MSG_KEY , "l1" , 3 , 1 ) , "471: " + getCheckMessage ( MSG_KEY , "l2" , 2 , 1 ) , "479: " + getCheckMessage ( MSG_KEY , "myOption" , 7 , 1 ) , "491: " + getCheckMessage ( MSG_KEY , "myOption" , 6 , 1 ) , "504: " + getCheckMessage ( MSG_KEY , "count" , 4 , 1 ) , "505: " + getCheckMessage ( MSG_KEY , "files" , 2 , 1 ) , "540: " + getCheckMessage ( MSG_KEY , "id" , 2 , 1 ) , "542: " + getCheckMessage ( MSG_KEY , "parentId" , 3 , 1 ) , } ; verify ( checkConfig , getPath ( "coding/InputVariableDeclarationUsageDistanceCheck.java" ) , expected ) ; } @ Test public void testValidateBetweenScopesOption ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VariableDeclarationUsageDistanceCheck . class ) ; checkConfig . addAttribute ( "allowedDistance" , "1" ) ; checkConfig . addAttribute ( "ignoreVariablePattern" , "" ) ; checkConfig . addAttribute ( "validateBetweenScopes" , "false" ) ; checkConfig . addAttribute ( "ignoreFinal" , "false" ) ; final String [ ] expected = { "30: " + getCheckMessage ( MSG_KEY , "a" , 2 , 1 ) , "38: " + getCheckMessage ( MSG_KEY , "temp" , 2 , 1 ) , "44: " + getCheckMessage ( MSG_KEY , "temp" , 2 , 1 ) , "71: " + getCheckMessage ( MSG_KEY , "count" , 4 , 1 ) , "96: " + getCheckMessage ( MSG_KEY , "arg" , 2 , 1 ) , "219: " + getCheckMessage ( MSG_KEY , "t" , 5 , 1 ) , "222: " + getCheckMessage ( MSG_KEY , "c" , 3 , 1 ) , "223: " + getCheckMessage ( MSG_KEY , "d2" , 3 , 1 ) , "300: " + getCheckMessage ( MSG_KEY , "wh" , 2 , 1 ) , "343: " + getCheckMessage ( MSG_KEY , "green" , 2 , 1 ) , "344: " + getCheckMessage ( MSG_KEY , "blue" , 3 , 1 ) , "367: " + getCheckMessage ( MSG_KEY , "intervalMs" , 2 , 1 ) , "454: " + getCheckMessage ( MSG_KEY , "aOpt" , 3 , 1 ) , "455: " + getCheckMessage ( MSG_KEY , "bOpt" , 2 , 1 ) , "471: " + getCheckMessage ( MSG_KEY , "l1" , 3 , 1 ) , "471: " + getCheckMessage ( MSG_KEY , "l2" , 2 , 1 ) , "479: " + getCheckMessage ( MSG_KEY , "myOption" , 7 , 1 ) , "491: Distance between variable 'myOption' declaration and its first usage is 6, but allowed 1." , "505: Distance between variable 'files' declaration and its first usage is 2, but allowed 1." , "540: Distance between variable 'id' declaration and its first usage is 2, but allowed 1." , "542: Distance between variable 'parentId' declaration and its first usage is 4, but allowed 1." , } ; verify ( checkConfig , getPath ( "coding/InputVariableDeclarationUsageDistanceCheck.java" ) , expected ) ; } @ Test public void testIgnoreFinalOption ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VariableDeclarationUsageDistanceCheck . class ) ; checkConfig . addAttribute ( "allowedDistance" , "1" ) ; checkConfig . addAttribute ( "ignoreVariablePattern" , "" ) ; checkConfig . addAttribute ( "validateBetweenScopes" , "true" ) ; checkConfig . addAttribute ( "ignoreFinal" , "true" ) ; final String [ ] expected = { "30: " + getCheckMessage ( MSG_KEY_EXT , "a" , 2 , 1 ) , "38: " + getCheckMessage ( MSG_KEY_EXT , "temp" , 2 , 1 ) , "44: " + getCheckMessage ( MSG_KEY_EXT , "temp" , 2 , 1 ) , "57: " + getCheckMessage ( MSG_KEY_EXT , "count" , 2 , 1 ) , "71: " + getCheckMessage ( MSG_KEY_EXT , "count" , 4 , 1 ) , "96: " + getCheckMessage ( MSG_KEY_EXT , "arg" , 2 , 1 ) , "144: " + getCheckMessage ( MSG_KEY_EXT , "m" , 3 , 1 ) , "145: " + getCheckMessage ( MSG_KEY_EXT , "n" , 2 , 1 ) , "184: " + getCheckMessage ( MSG_KEY_EXT , "result" , 2 , 1 ) , "219: " + getCheckMessage ( MSG_KEY_EXT , "t" , 5 , 1 ) , "222: " + getCheckMessage ( MSG_KEY_EXT , "c" , 3 , 1 ) , "223: " + getCheckMessage ( MSG_KEY_EXT , "d2" , 3 , 1 ) , "260: " + getCheckMessage ( MSG_KEY_EXT , "selected" , 2 , 1 ) , "261: " + getCheckMessage ( MSG_KEY_EXT , "model" , 2 , 1 ) , "287: " + getCheckMessage ( MSG_KEY_EXT , "sw" , 2 , 1 ) , "300: " + getCheckMessage ( MSG_KEY_EXT , "wh" , 2 , 1 ) , "343: " + getCheckMessage ( MSG_KEY_EXT , "green" , 2 , 1 ) , "344: " + getCheckMessage ( MSG_KEY_EXT , "blue" , 3 , 1 ) , "454: " + getCheckMessage ( MSG_KEY_EXT , "aOpt" , 3 , 1 ) , "455: " + getCheckMessage ( MSG_KEY_EXT , "bOpt" , 2 , 1 ) , "471: " + getCheckMessage ( MSG_KEY_EXT , "l1" , 3 , 1 ) , "471: " + getCheckMessage ( MSG_KEY_EXT , "l2" , 2 , 1 ) , "479: " + getCheckMessage ( MSG_KEY_EXT , "myOption" , 7 , 1 ) , "491: " + getCheckMessage ( MSG_KEY_EXT , "myOption" , 6 , 1 ) , "504: " + getCheckMessage ( MSG_KEY_EXT , "count" , 4 , 1 ) , "505: " + getCheckMessage ( MSG_KEY_EXT , "files" , 2 , 1 ) , "540: " + getCheckMessage ( MSG_KEY_EXT , "id" , 2 , 1 ) , "542: " + getCheckMessage ( MSG_KEY_EXT , "parentId" , 3 , 1 ) , } ; verify ( checkConfig , getPath ( "coding/InputVariableDeclarationUsageDistanceCheck.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { VariableDeclarationUsageDistanceCheck check = new VariableDeclarationUsageDistanceCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . OverloadMethodsDeclarationOrderCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class OverloadMethodsDeclarationOrderCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OverloadMethodsDeclarationOrderCheck . class ) ; final String [ ] expected = { "28: " + getCheckMessage ( MSG_KEY , 17 ) , "56: " + getCheckMessage ( MSG_KEY , 45 ) , "68: " + getCheckMessage ( MSG_KEY , 66 ) , "111: " + getCheckMessage ( MSG_KEY , 100 ) , } ; verify ( checkConfig , getPath ( "coding/InputOverloadMethodsDeclarationOrder.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { OverloadMethodsDeclarationOrderCheck check = new OverloadMethodsDeclarationOrderCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import static com . puppycrawl . tools . checkstyle . checks . coding . ParameterAssignmentCheck . MSG_KEY ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class ParameterAssignmentCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParameterAssignmentCheck . class ) ; final String [ ] expected = { "9:15: " + getCheckMessage ( MSG_KEY , "field" ) , "10:15: " + getCheckMessage ( MSG_KEY , "field" ) , "12:14: " + getCheckMessage ( MSG_KEY , "field" ) , "20:30: " + getCheckMessage ( MSG_KEY , "field1" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputParameterAssignment.java" ) , expected ) ; } @ Test public void testTokensNotNull ( ) { ParameterAssignmentCheck check = new ParameterAssignmentCheck ( ) ; Assert . assertNotNull ( check . getAcceptableTokens ( ) ) ; Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . annotation ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . annotation . SuppressWarningsCheck . MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED ; public class SuppressWarningsCheckTest extends BaseCheckTestSupport { @ Test public void testSingleDefault ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; final String [ ] expected = { "8:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "11:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "53:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "64:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:37: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "72:46: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "77:60: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:93: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:106: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsSingle.java" ) , expected ) ; } @ Test public void testSingleAll ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , ".*" ) ; final String [ ] expected = { "5:19: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "8:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "11:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "17:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "20:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unforgiven" ) , "25:31: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "29:35: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "37:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "abcun" ) , "44:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "abcun" ) , "47:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "53:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "56:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:33: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:37: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:42: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:46: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "72:54: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:65: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:37: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:60: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "77:68: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:93: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:98: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "foo" ) , "82:106: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:115: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsSingle.java" ) , expected ) ; } @ Test public void testSingleNoUnchecked ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "^unchecked$*" ) ; final String [ ] expected = { "5:19: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "29:35: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "56:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:33: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "67:42: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:65: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:37: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsSingle.java" ) , expected ) ; } @ Test public void testSingleNoUncheckedTokens ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "^unchecked$*" ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF,METHOD_DEF" ) ; final String [ ] expected = { "5:19: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "29:35: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:33: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:65: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:37: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsSingle.java" ) , expected ) ; } @ Test public void testSingleNoUnWildcard ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , ".*un.*" ) ; final String [ ] expected = { "5:19: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "17:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "20:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unforgiven" ) , "25:31: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "29:35: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "37:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "abcun" ) , "44:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "abcun" ) , "47:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "56:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:33: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "67:42: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:54: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:65: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:37: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:68: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:115: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsSingle.java" ) , expected ) ; } @ Test public void testSingleNoUncheckedUnused ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "^unchecked$*|^unused$" ) ; final String [ ] expected = { "5:19: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "17:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "25:31: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "29:35: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "47:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "56:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:33: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "67:42: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:54: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:65: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:37: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:68: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:115: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsSingle.java" ) , expected ) ; } @ Test public void testSingleNoUncheckedUnusedAll ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "^unchecked$*|^unused$*|.*" ) ; final String [ ] expected = { "5:19: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "8:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "11:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "17:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "20:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unforgiven" ) , "25:31: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "29:35: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "37:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "abcun" ) , "44:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "abcun" ) , "47:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "53:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "56:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:33: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:37: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:42: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:46: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "72:54: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:65: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:37: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:60: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "77:68: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:93: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:98: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "foo" ) , "82:106: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:115: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsSingle.java" ) , expected ) ; } @ Test public void testCompactDefault ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; final String [ ] expected = { "8:24: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "11:41: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "44:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "53:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "64:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "64:76: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "72:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "72:98: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "77:61: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:94: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:107: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:181: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:194: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsCompact.java" ) , expected ) ; } @ Test public void testCompactAll ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , ".*" ) ; final String [ ] expected = { "5:20: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "5:33: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "8:24: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "11:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "11:41: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "17:24: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "20:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unforgiven" ) , "20:42: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " un" ) , "25:32: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "29:36: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "37:24: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "abcun" ) , "44:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "47:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "47:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "bleh" ) , "53:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "56:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:49: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "64:62: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:76: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:43: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "72:55: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:66: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:98: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "72:106: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:117: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:61: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "77:69: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:94: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:99: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "foo" ) , "82:107: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:115: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:135: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:181: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:186: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "foo" ) , "82:194: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:202: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsCompact.java" ) , expected ) ; } @ Test public void testCompactNoUnchecked ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "^unchecked$*" ) ; final String [ ] expected = { "5:20: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "11:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "29:36: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "56:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:49: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:62: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "67:43: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:66: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:117: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:135: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsCompact.java" ) , expected ) ; } @ Test public void testCompactNoUncheckedTokens ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "^unchecked$*" ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF" ) ; final String [ ] expected = { "5:20: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:62: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsCompact.java" ) , expected ) ; } @ Test public void testCompactNoUnWildcard ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "un.*" ) ; final String [ ] expected = { "5:20: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "5:33: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "11:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "17:24: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "20:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unforgiven" ) , "25:32: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "29:36: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "47:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "56:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:49: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:62: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "67:43: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:55: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:66: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:106: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:117: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:69: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:115: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:135: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:202: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsCompact.java" ) , expected ) ; } @ Test public void testCompactNoUncheckedUnused ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "^unchecked$*|^unused$" ) ; final String [ ] expected = { "5:20: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "5:33: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "11:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "17:24: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "25:32: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "29:36: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "47:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "56:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:49: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:62: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "67:43: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:55: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:66: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:106: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:117: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:69: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:115: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:135: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:202: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsCompact.java" ) , expected ) ; } @ Test public void testCompactNoUncheckedUnusedAll ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "^unchecked$*|^unused$*|.*" ) ; final String [ ] expected = { "5:20: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "5:33: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "8:24: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "11:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "11:41: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "17:24: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "20:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unforgiven" ) , "20:42: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " un" ) , "25:32: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "29:36: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "37:24: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "abcun" ) , "44:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "47:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "47:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "bleh" ) , "53:27: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "56:28: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:49: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "64:62: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:76: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:43: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "72:55: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:66: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:98: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "72:106: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:117: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:61: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "77:69: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:94: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:99: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "foo" ) , "82:107: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:115: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:135: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:181: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:186: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "foo" ) , "82:194: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:202: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsCompact.java" ) , expected ) ; } @ Test public void testExpandedDefault ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; final String [ ] expected = { "8:30: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "11:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "44:29: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "53:33: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "64:54: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "64:82: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:44: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "72:53: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "72:104: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "77:67: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:100: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:113: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:187: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:200: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsExpanded.java" ) , expected ) ; } @ Test public void testExpandedAll ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , ".*" ) ; final String [ ] expected = { "5:26: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "5:39: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "8:30: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "11:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "11:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "17:30: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "20:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unforgiven" ) , "20:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " un" ) , "25:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "29:42: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "37:30: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "abcun" ) , "44:29: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "47:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "47:44: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "bleh" ) , "53:33: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "56:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:55: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:40: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:54: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "64:68: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:82: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:44: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:49: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:53: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "72:61: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:72: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:104: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "72:112: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:123: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:44: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:67: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "77:75: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:54: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:100: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:105: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "foo" ) , "82:113: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:121: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:141: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:187: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:192: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "foo" ) , "82:200: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:208: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsExpanded.java" ) , expected ) ; } @ Test public void testExpandedNoUnchecked ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "^unchecked$*" ) ; final String [ ] expected = { "5:26: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "11:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "29:42: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "56:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:55: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:40: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:68: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "67:49: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:72: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:123: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:44: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:54: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:141: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsExpanded.java" ) , expected ) ; } @ Test public void testExpandedNoUncheckedTokens ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "^unchecked$*" ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF" ) ; final String [ ] expected = { "5:26: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:40: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:68: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsExpanded.java" ) , expected ) ; } @ Test public void testExpandedNoUnWildcard ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "un.*" ) ; final String [ ] expected = { "5:26: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "5:39: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "11:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "17:30: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "20:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unforgiven" ) , "25:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "29:42: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "47:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "56:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:55: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:40: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:68: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "67:49: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:61: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:72: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:112: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:123: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:44: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:75: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:54: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:121: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:141: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:208: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsExpanded.java" ) , expected ) ; } @ Test public void testExpandedNoUncheckedUnused ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "^unchecked$*|^unused$" ) ; final String [ ] expected = { "5:26: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "5:39: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "11:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "17:30: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "25:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "29:42: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "47:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "56:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:55: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:40: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:68: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "67:49: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:61: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:72: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:112: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:123: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:44: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:75: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:54: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:121: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:141: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:208: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsExpanded.java" ) , expected ) ; } @ Test public void testExpandedNoUncheckedUnusedAll ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; checkConfig . addAttribute ( "format" , "^unchecked$*|^unused$*|.*" ) ; final String [ ] expected = { "5:26: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "5:39: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "8:30: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "11:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "11:47: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "17:30: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "20:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unforgiven" ) , "20:48: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " un" ) , "25:38: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "29:42: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "37:30: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "abcun" ) , "44:29: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "47:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "47:44: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "bleh" ) , "53:33: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "56:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "59:55: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:40: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:54: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "64:68: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "64:82: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:44: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "67:49: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:53: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "72:61: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:72: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "72:104: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "72:112: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "72:123: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:44: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "77:67: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "77:75: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:54: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:100: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:105: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "foo" ) , "82:113: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:121: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , "82:141: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unchecked" ) , "82:187: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "82:192: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "foo" ) , "82:200: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , " " ) , "82:208: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "unused" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsExpanded.java" ) , expected ) ; } @ Test public void testUncheckedInConstant ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsConstants.java" ) , expected ) ; } @ Test public void testValuePairAnnotation ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SuppressWarningsValuePair.java" ) , expected ) ; } @ Test public void testWorkingProperlyOnComplexAnnotations ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SuppressWarningsCheck . class ) ; String [ ] expected = { "18:34: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "24:23: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "28:52: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , "33:5: " + getCheckMessage ( MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , "" ) , } ; verify ( checkConfig , getPath ( "InputSuppressWarningsHolder.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . annotation ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import static com . puppycrawl . tools . checkstyle . checks . annotation . AnnotationLocationCheck . MSG_KEY_ANNOTATION_LOCATION_ALONE ; import static com . puppycrawl . tools . checkstyle . checks . annotation . AnnotationLocationCheck . MSG_KEY_ANNOTATION_LOCATION ; public class AnnotationLocationCheckTest extends BaseCheckTestSupport { @ Test public void testCorrect ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AnnotationLocationCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation/InputCorrectAnnotationLocation.java" ) , expected ) ; } @ Test public void testIncorrect ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AnnotationLocationCheck . class ) ; final String [ ] expected = { "6: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION_ALONE , "MyAnnotation1" ) , "11: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION_ALONE , "MyAnnotation1" ) , "17: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION , "MyAnnotation1" , 8 , 4 ) , "25: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION , "MyAnnotation1" , 8 , 4 ) , "29: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION_ALONE , "MyAnnotation1" ) , "29: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION_ALONE , "MyAnnotation2" ) , "32: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION , "MyAnnotation2" , 7 , 4 ) , "36: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION , "MyAnnotation2" , 8 , 4 ) , "37: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION , "MyAnnotation3" , 6 , 4 ) , "38: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION , "MyAnnotation4" , 10 , 4 ) , "41: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION_ALONE , "MyAnnotation1" ) , "48: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION , "MyAnnotation1" , 12 , 8 ) , "61: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION , "MyAnnotation2" , 12 , 8 ) , "65: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION , "MyAnnotation2" , 12 , 8 ) , "70: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION , "MyAnnotation2" , 7 , 4 ) , "73: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION_ALONE , "MyAnnotation1" ) , "85: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION , "MyAnnotation2" , 11 , 8 ) , "88: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION , "MyAnnotation2" , 10 , 8 ) , "98: " + getCheckMessage ( MSG_KEY_ANNOTATION_LOCATION , "MyAnnotation2" , 0 , 3 ) , } ; verify ( checkConfig , getPath ( "annotation/InputIncorrectAnnotationLocation.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . annotation ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import static com . puppycrawl . tools . checkstyle . checks . annotation . AnnotationUseStyleCheck . MSG_KEY_ANNOTATION_INCORRECT_STYLE ; import static com . puppycrawl . tools . checkstyle . checks . annotation . AnnotationUseStyleCheck . MSG_KEY_ANNOTATION_PARENS_MISSING ; import static com . puppycrawl . tools . checkstyle . checks . annotation . AnnotationUseStyleCheck . MSG_KEY_ANNOTATION_PARENS_PRESENT ; import static com . puppycrawl . tools . checkstyle . checks . annotation . AnnotationUseStyleCheck . MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ; import static com . puppycrawl . tools . checkstyle . checks . annotation . AnnotationUseStyleCheck . MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT ; public class AnnotationUseStyleTest extends BaseCheckTestSupport { @ Test public void testParansAlways ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AnnotationUseStyleCheck . class ) ; checkConfig . addAttribute ( "closingParens" , "ALWAYS" ) ; checkConfig . addAttribute ( "elementStyle" , "ignore" ) ; checkConfig . addAttribute ( "trailingArrayComma" , "ignore" ) ; final String [ ] expected = { "3: " + getCheckMessage ( MSG_KEY_ANNOTATION_PARENS_MISSING ) , "18: " + getCheckMessage ( MSG_KEY_ANNOTATION_PARENS_MISSING ) , "23: " + getCheckMessage ( MSG_KEY_ANNOTATION_PARENS_MISSING ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "DifferentUseStyles.java" ) , expected ) ; } @ Test public void testParansNever ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AnnotationUseStyleCheck . class ) ; checkConfig . addAttribute ( "closingParens" , "NEVER" ) ; checkConfig . addAttribute ( "elementStyle" , "ignore" ) ; checkConfig . addAttribute ( "trailingArrayComma" , "ignore" ) ; final String [ ] expected = { "13: " + getCheckMessage ( MSG_KEY_ANNOTATION_PARENS_PRESENT ) , "30: " + getCheckMessage ( MSG_KEY_ANNOTATION_PARENS_PRESENT ) , "33: " + getCheckMessage ( MSG_KEY_ANNOTATION_PARENS_PRESENT ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "DifferentUseStyles.java" ) , expected ) ; } @ Test public void testStyleExpanded ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AnnotationUseStyleCheck . class ) ; checkConfig . addAttribute ( "closingParens" , "ignore" ) ; checkConfig . addAttribute ( "elementStyle" , "EXPANDED" ) ; checkConfig . addAttribute ( "trailingArrayComma" , "ignore" ) ; final String [ ] expected = { "5: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "EXPANDED" ) , "12: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "EXPANDED" ) , "20: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "EXPANDED" ) , "26: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "EXPANDED" ) , "39: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "EXPANDED" ) , "41: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "EXPANDED" ) , "58: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "EXPANDED" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "DifferentUseStyles.java" ) , expected ) ; } @ Test public void testStyleCompact ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AnnotationUseStyleCheck . class ) ; checkConfig . addAttribute ( "closingParens" , "ignore" ) ; checkConfig . addAttribute ( "elementStyle" , "COMPACT" ) ; checkConfig . addAttribute ( "trailingArrayComma" , "ignore" ) ; final String [ ] expected = { "43: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "COMPACT" ) , "47: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "COMPACT" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "DifferentUseStyles.java" ) , expected ) ; } @ Test public void testStyleCompactNoArray ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AnnotationUseStyleCheck . class ) ; checkConfig . addAttribute ( "closingParens" , "ignore" ) ; checkConfig . addAttribute ( "elementStyle" , "COMPACT_NO_ARRAY" ) ; checkConfig . addAttribute ( "trailingArrayComma" , "ignore" ) ; final String [ ] expected = { "5: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "COMPACT_NO_ARRAY" ) , "20: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "COMPACT_NO_ARRAY" ) , "41: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "COMPACT_NO_ARRAY" ) , "43: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "COMPACT_NO_ARRAY" ) , "47: " + getCheckMessage ( MSG_KEY_ANNOTATION_INCORRECT_STYLE , "COMPACT_NO_ARRAY" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "DifferentUseStyles.java" ) , expected ) ; } @ Test public void testCommaAlwaysViolations ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AnnotationUseStyleCheck . class ) ; checkConfig . addAttribute ( "closingParens" , "ignore" ) ; checkConfig . addAttribute ( "elementStyle" , "ignore" ) ; checkConfig . addAttribute ( "trailingArrayComma" , "ALWAYS" ) ; final String [ ] expected = { "3:20: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) , "6:30: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) , "10:40: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) , "13:44: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) , "16:54: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) , "24:37: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) , "24:65: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) , "26:21: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) , "26:30: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) , "29:39: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) , "29:49: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) , "32:21: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) , "32:56: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "AnnotationUseNoTrailingComma.java" ) , expected ) ; } @ Test public void testCommaAlwaysNoViolations ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AnnotationUseStyleCheck . class ) ; checkConfig . addAttribute ( "closingParens" , "ignore" ) ; checkConfig . addAttribute ( "elementStyle" , "ignore" ) ; checkConfig . addAttribute ( "trailingArrayComma" , "ALWAYS" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "AnnotationUseWithTrailingComma.java" ) , expected ) ; } @ Test public void testCommaNeverViolations ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AnnotationUseStyleCheck . class ) ; checkConfig . addAttribute ( "closingParens" , "ignore" ) ; checkConfig . addAttribute ( "elementStyle" , "ignore" ) ; checkConfig . addAttribute ( "trailingArrayComma" , "NEVER" ) ; final String [ ] expected = { "9:32: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT ) , "13:42: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT ) , "16:46: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT ) , "19:56: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT ) , "27:38: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT ) , "27:67: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT ) , "33:39: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT ) , "33:50: " + getCheckMessage ( MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "AnnotationUseWithTrailingComma.java" ) , expected ) ; } @ Test public void testCommaNeverNoViolations ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AnnotationUseStyleCheck . class ) ; checkConfig . addAttribute ( "closingParens" , "ignore" ) ; checkConfig . addAttribute ( "elementStyle" , "ignore" ) ; checkConfig . addAttribute ( "trailingArrayComma" , "NEVER" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "AnnotationUseNoTrailingComma.java" ) , expected ) ; } @ Test public void testEverythingMixed ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AnnotationUseStyleCheck . class ) ; checkConfig . addAttribute ( "closingParens" , "ignore" ) ; checkConfig . addAttribute ( "elementStyle" , "ignore" ) ; checkConfig . addAttribute ( "trailingArrayComma" , "ignore" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "DifferentUseStyles.java" ) , expected ) ; } @ Test public void testAnnotationsWithoutDefaultValues ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AnnotationUseStyleCheck . class ) ; checkConfig . addAttribute ( "closingParens" , "NEVER" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "AnnotationsUseStyleParams.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . annotation ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class PackageAnnotationTest extends BaseCheckTestSupport { @ Test public void testGoodPackageAnnotation ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( PackageAnnotationCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "package-info.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . annotation ; import java . io . File ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . annotation . MissingOverrideCheck . MSG_KEY_ANNOTATION_MISSING_OVERRIDE ; import static com . puppycrawl . tools . checkstyle . checks . annotation . MissingOverrideCheck . MSG_KEY_TAG_NOT_VALID_ON ; public class MissingOverrideCheckTest extends BaseCheckTestSupport { @ Test public void testBadOverrideFromObject ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingOverrideCheck . class ) ; checkConfig . addAttribute ( "javaFiveCompatibility" , "false" ) ; final String [ ] expected = { "8: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "30: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "41: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "50: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "BadOverrideFromObject.java" ) , expected ) ; } @ Test public void testBadOverrideFromObjectJ5Compat ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingOverrideCheck . class ) ; checkConfig . addAttribute ( "javaFiveCompatibility" , "true" ) ; final String [ ] expected = { "8: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "30: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "41: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "50: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "BadOverrideFromObject.java" ) , expected ) ; } @ Test public void testBadOverrideFromOther ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingOverrideCheck . class ) ; final String [ ] expected = { "10: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "26: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "34: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "40: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "47: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "53: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "63: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "BadOverrideFromOther.java" ) , expected ) ; } @ Test public void testBadOverrideFromOtherJ5Compat ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingOverrideCheck . class ) ; checkConfig . addAttribute ( "javaFiveCompatibility" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "BadOverrideFromOther.java" ) , expected ) ; } @ Test public void testBadAnnonOverride ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingOverrideCheck . class ) ; final String [ ] expected = { "10: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "16: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "29: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , "35: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "BadAnnonOverride.java" ) , expected ) ; } @ Test public void testBadAnnonOverrideJ5Compat ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingOverrideCheck . class ) ; checkConfig . addAttribute ( "javaFiveCompatibility" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "BadAnnonOverride.java" ) , expected ) ; } @ Test public void testNotOverride ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingOverrideCheck . class ) ; final String [ ] expected = { "8: " + getCheckMessage ( MSG_KEY_TAG_NOT_VALID_ON , "{@inheritDoc}" ) , "15: " + getCheckMessage ( MSG_KEY_TAG_NOT_VALID_ON , "{@inheritDoc}" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "NotOverride.java" ) , expected ) ; } @ Test public void testGoodOverrideFromObject ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingOverrideCheck . class ) ; checkConfig . addAttribute ( "javaFiveCompatibility" , "false" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "GoodOverrideFromObject.java" ) , expected ) ; } @ Test public void testGoodOverrideFromObjectJ5Compat ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingOverrideCheck . class ) ; checkConfig . addAttribute ( "javaFiveCompatibility" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "GoodOverrideFromObject.java" ) , expected ) ; } @ Test public void testGoodOverrideFromOther ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingOverrideCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "GoodOverrideFromOther.java" ) , expected ) ; } @ Test public void testGoodOverrideFromOtherJ5Compat ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingOverrideCheck . class ) ; checkConfig . addAttribute ( "javaFiveCompatibility" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "GoodOverrideFromOther.java" ) , expected ) ; } @ Test public void testGoodAnnonOverride ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingOverrideCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "GoodAnnonOverride.java" ) , expected ) ; } @ Test public void testGoodAnnonOverrideJ5Compat ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingOverrideCheck . class ) ; checkConfig . addAttribute ( "javaFiveCompatibility" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "GoodAnnonOverride.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNull ; import com . puppycrawl . tools . checkstyle . TreeWalker ; import java . io . File ; import java . io . FileFilter ; import java . text . MessageFormat ; import org . junit . Test ; public class DetailASTTest { @ Test public void testGetChildCount ( ) { final DetailAST root = new DetailAST ( ) ; final DetailAST firstLevelA = new DetailAST ( ) ; final DetailAST firstLevelB = new DetailAST ( ) ; final DetailAST secondLevelA = new DetailAST ( ) ; root . setFirstChild ( firstLevelA ) ; firstLevelA . setParent ( root ) ; firstLevelA . setFirstChild ( secondLevelA ) ; firstLevelA . setNextSibling ( firstLevelB ) ; firstLevelB . setParent ( root ) ; secondLevelA . setParent ( firstLevelA ) ; assertEquals ( 0 , secondLevelA . getChildCount ( ) ) ; assertEquals ( 0 , firstLevelB . getChildCount ( ) ) ; assertEquals ( 1 , firstLevelA . getChildCount ( ) ) ; assertEquals ( 2 , root . getChildCount ( ) ) ; assertEquals ( 2 , root . getChildCount ( ) ) ; assertNull ( root . getPreviousSibling ( ) ) ; assertNull ( firstLevelA . getPreviousSibling ( ) ) ; assertNull ( secondLevelA . getPreviousSibling ( ) ) ; assertEquals ( firstLevelA , firstLevelB . getPreviousSibling ( ) ) ; } @ Test public void testTreeStructure ( ) throws Exception { checkDir ( new File ( "src/test/resources/com/puppycrawl/tools/checkstyle" ) ) ; } private void checkDir ( File dir ) throws Exception { File [ ] files = dir . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( File file ) { return ( file . getName ( ) . endsWith ( ".java" ) || file . isDirectory ( ) ) && ! file . getName ( ) . endsWith ( "InputGrammar.java" ) ; } } ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . isFile ( ) ) { checkFile ( files [ i ] . getCanonicalPath ( ) ) ; } else if ( files [ i ] . isDirectory ( ) ) { checkDir ( files [ i ] ) ; } } } private void checkFile ( String filename ) throws Exception { final FileText text = new FileText ( new File ( filename ) , System . getProperty ( "file.encoding" , "UTF-8" ) ) ; final FileContents contents = new FileContents ( text ) ; final DetailAST rootAST = TreeWalker . parse ( contents ) ; if ( rootAST != null ) { checkTree ( rootAST , null , null , filename , rootAST ) ; } } private void checkTree ( final DetailAST node , final DetailAST parent , final DetailAST prev , final String filename , final DetailAST root ) { Object [ ] params = new Object [ ] { node , parent , prev , filename , root , } ; String msg = MessageFormat . format ( "Bad parent node={0} parent={1} filename={3} root={4}" , params ) ; assertEquals ( msg , parent , node . getParent ( ) ) ; msg = MessageFormat . format ( "Bad prev node={0} prev={2} parent={1} filename={3} root={4}" , params ) ; assertEquals ( msg , prev , node . getPreviousSibling ( ) ) ; if ( node . getFirstChild ( ) != null ) { checkTree ( node . getFirstChild ( ) , node , null , filename , root ) ; } if ( node . getNextSibling ( ) != null ) { checkTree ( node . getNextSibling ( ) , parent , node , filename , root ) ; } } }
package com . puppycrawl . tools . checkstyle ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; class DebugChecker extends Checker { public DebugChecker ( ) throws CheckstyleException { } @ Override public void fireAuditFinished ( ) { super . fireAuditFinished ( ) ; } @ Override public void fireAuditStarted ( ) { super . fireAuditStarted ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . annotation ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import static com . puppycrawl . tools . checkstyle . checks . annotation . MissingDeprecatedCheck . MSG_KEY_ANNOTATION_MISSING_DEPRECATED ; import static com . puppycrawl . tools . checkstyle . checks . annotation . MissingDeprecatedCheck . MSG_KEY_JAVADOC_DUPLICATE_TAG ; import static com . puppycrawl . tools . checkstyle . checks . annotation . MissingDeprecatedCheck . MSG_KEY_JAVADOC_MISSING ; public class MissingDeprecatedTest extends BaseCheckTestSupport { @ Test public void testBadDeprecatedAnnotation ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingDeprecatedCheck . class ) ; final String [ ] expected = { "7: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "12: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "19: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "26: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "31: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "38: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "43: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "51: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "56: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "BadDeprecatedAnnotation.java" ) , expected ) ; } @ Test public void testBadDeprecatedJavadoc ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingDeprecatedCheck . class ) ; final String [ ] expected = { "5: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "11: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "16: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "23: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "29: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "38: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "40: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "48: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "55: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "BadDeprecatedJavadoc.java" ) , expected ) ; } @ Test public void testSpecialCaseDeprecated ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingDeprecatedCheck . class ) ; final String [ ] expected = { "5: " + getCheckMessage ( MSG_KEY_JAVADOC_DUPLICATE_TAG , "@deprecated" ) , "12: " + getCheckMessage ( MSG_KEY_JAVADOC_DUPLICATE_TAG , "@deprecated" ) , "14: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "17: " + getCheckMessage ( MSG_KEY_JAVADOC_MISSING ) , "19: " + getCheckMessage ( MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) , "24: " + getCheckMessage ( MSG_KEY_JAVADOC_MISSING ) , "32: " + getCheckMessage ( MSG_KEY_JAVADOC_MISSING ) , "33: " + getCheckMessage ( MSG_KEY_JAVADOC_DUPLICATE_TAG , "@deprecated" ) , "33: " + getCheckMessage ( MSG_KEY_JAVADOC_MISSING ) , "42: " + getCheckMessage ( MSG_KEY_JAVADOC_DUPLICATE_TAG , "@deprecated" ) , "42: " + getCheckMessage ( MSG_KEY_JAVADOC_MISSING ) , "50: " + getCheckMessage ( MSG_KEY_JAVADOC_MISSING ) , "51: " + getCheckMessage ( MSG_KEY_JAVADOC_DUPLICATE_TAG , "@deprecated" ) , } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "SpecialCaseDeprecated.java" ) , expected ) ; } @ Test public void testGoodDeprecated ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MissingDeprecatedCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "annotation" + File . separator + "GoodDeprecated.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . design ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import static com . puppycrawl . tools . checkstyle . checks . design . OneTopLevelClassCheck . MSG_KEY ; public class OneTopLevelClassCheckTest extends BaseCheckTestSupport { @ Test public void testAcceptableTokens ( ) throws Exception { final OneTopLevelClassCheck check = new OneTopLevelClassCheck ( ) ; check . getAcceptableTokens ( ) ; Assert . assertEquals ( 0 , check . getAcceptableTokens ( ) . length ) ; } @ Test public void testFileWithOneTopLevelClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OneTopLevelClassCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputOneTopLevelClass.java" ) , expected ) ; } @ Test public void testFileWithOneTopLevelInterface ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OneTopLevelClassCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputOneTopLevelInterface.java" ) , expected ) ; } @ Test public void testFileWithOneTopLevelEnum ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OneTopLevelClassCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputOneTopLevelEnum.java" ) , expected ) ; } @ Test public void testFileWithNoPublicTopLevelClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OneTopLevelClassCheck . class ) ; final String [ ] expected = { "8: " + getCheckMessage ( MSG_KEY , "InputOneTopLevelClassNoPublic2" ) , } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputOneTopLevelClassNoPublic.java" ) , expected ) ; } @ Test public void testFileWithThreeTopLevelInterface ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OneTopLevelClassCheck . class ) ; final String [ ] expected = { "3: " + getCheckMessage ( MSG_KEY , "InputOneTopLevelInterface2inner1" ) , "11: " + getCheckMessage ( MSG_KEY , "InputOneTopLevelInterface2inner2" ) , } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputOneTopLevelInterface2.java" ) , expected ) ; } @ Test public void testFileWithThreeTopLevelEnum ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OneTopLevelClassCheck . class ) ; final String [ ] expected = { "3: " + getCheckMessage ( MSG_KEY , "InputOneTopLevelEnum2inner1" ) , "11: " + getCheckMessage ( MSG_KEY , "InputOneTopLevelEnum2inner2" ) , } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputOneTopLevelEnum2.java" ) , expected ) ; } @ Test public void testFileWithFewTopLevelClasses ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OneTopLevelClassCheck . class ) ; final String [ ] expected = { "25: " + getCheckMessage ( MSG_KEY , "NoSuperClone" ) , "33: " + getCheckMessage ( MSG_KEY , "InnerClone" ) , "50: " + getCheckMessage ( MSG_KEY , "CloneWithTypeArguments" ) , "58: " + getCheckMessage ( MSG_KEY , "CloneWithTypeArgumentsAndNoSuper" ) , "67: " + getCheckMessage ( MSG_KEY , "MyClassWithGenericSuperMethod" ) , "84: " + getCheckMessage ( MSG_KEY , "AnotherClass" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputClone.java" ) , expected ) ; } @ Test public void testFileWithSecondEnumTopLevelClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OneTopLevelClassCheck . class ) ; final String [ ] expected = { "83: " + getCheckMessage ( MSG_KEY , "InputDeclarationOrderEnum" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputDeclarationOrder.java" ) , expected ) ; } @ Test public void testPackageInfoWithNoTypesDeclared ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OneTopLevelClassCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "design" + File . separator + "package-info.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . design ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; import java . io . File ; import static com . puppycrawl . tools . checkstyle . checks . design . InnerTypeLastCheck . MSG_KEY ; import static org . junit . Assert . assertArrayEquals ; public class InnerTypeLastCheckTest extends BaseCheckTestSupport { @ Test public void testMembersBeforeInner ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( InnerTypeLastCheck . class ) ; final String [ ] expected = { "44:9: " + getCheckMessage ( MSG_KEY ) , "65:9: " + getCheckMessage ( MSG_KEY ) , "69:9: " + getCheckMessage ( MSG_KEY ) , "78:5: " + getCheckMessage ( MSG_KEY ) , "95:9: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputInnerClassCheck.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { InnerTypeLastCheck obj = new InnerTypeLastCheck ( ) ; int [ ] expected = { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF } ; assertArrayEquals ( expected , obj . getAcceptableTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . design ; import antlr . CommonHiddenStreamToken ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; import java . io . File ; import static com . puppycrawl . tools . checkstyle . checks . design . MutableExceptionCheck . MSG_KEY ; import static org . junit . Assert . assertArrayEquals ; import static org . junit . Assert . fail ; public class MutableExceptionCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MutableExceptionCheck . class ) ; String [ ] expected = { "6:9: " + getCheckMessage ( MSG_KEY , "errorCode" ) , "23:9: " + getCheckMessage ( MSG_KEY , "errorCode" ) , "46:9: " + getCheckMessage ( MSG_KEY , "errorCode" ) , } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputMutableException.java" ) , expected ) ; } @ Test public void testFormat ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( MutableExceptionCheck . class ) ; checkConfig . addAttribute ( "format" , "^.*Failure$" ) ; checkConfig . addAttribute ( "extendedClassNameFormat" , "^.*ThreadDeath$" ) ; String [ ] expected = { "34:13: " + getCheckMessage ( MSG_KEY , "errorCode" ) , } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputMutableException.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { MutableExceptionCheck obj = new MutableExceptionCheck ( ) ; int [ ] expected = { TokenTypes . CLASS_DEF , TokenTypes . VARIABLE_DEF } ; assertArrayEquals ( expected , obj . getAcceptableTokens ( ) ) ; } @ Test public void testGetRequiredTokens ( ) { MutableExceptionCheck obj = new MutableExceptionCheck ( ) ; int [ ] expected = { TokenTypes . CLASS_DEF , TokenTypes . VARIABLE_DEF } ; assertArrayEquals ( expected , obj . getRequiredTokens ( ) ) ; } @ Test public void testWrongTokenType ( ) { MutableExceptionCheck obj = new MutableExceptionCheck ( ) ; DetailAST ast = new DetailAST ( ) ; ast . initialize ( new CommonHiddenStreamToken ( TokenTypes . INTERFACE_DEF , "interface" ) ) ; try { obj . visitToken ( ast ) ; fail ( ) ; } catch ( IllegalStateException e ) { } } }
package com . puppycrawl . tools . checkstyle . checks . design ; import antlr . CommonHiddenStreamToken ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; import java . io . File ; import static com . puppycrawl . tools . checkstyle . checks . design . ThrowsCountCheck . MSG_KEY ; import static org . junit . Assert . assertArrayEquals ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . fail ; public class ThrowsCountCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( ThrowsCountCheck . class ) ; String [ ] expected = { "17:20: " + getCheckMessage ( MSG_KEY , 5 , 4 ) , "22:20: " + getCheckMessage ( MSG_KEY , 5 , 4 ) , "27:20: " + getCheckMessage ( MSG_KEY , 6 , 4 ) , "55:43: " + getCheckMessage ( MSG_KEY , 5 , 4 ) , } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputThrowsCount.java" ) , expected ) ; } @ Test public void testMax ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( ThrowsCountCheck . class ) ; checkConfig . addAttribute ( "max" , "5" ) ; String [ ] expected = { "27:20: " + getCheckMessage ( MSG_KEY , 6 , 5 ) , } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputThrowsCount.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { ThrowsCountCheck obj = new ThrowsCountCheck ( ) ; int [ ] expected = { TokenTypes . LITERAL_THROWS } ; assertArrayEquals ( expected , obj . getAcceptableTokens ( ) ) ; } @ Test public void testGetRequiredTokens ( ) { ThrowsCountCheck obj = new ThrowsCountCheck ( ) ; int [ ] expected = { TokenTypes . LITERAL_THROWS } ; assertArrayEquals ( expected , obj . getRequiredTokens ( ) ) ; } @ Test public void testWrongTokenType ( ) { ThrowsCountCheck obj = new ThrowsCountCheck ( ) ; DetailAST ast = new DetailAST ( ) ; ast . initialize ( new CommonHiddenStreamToken ( TokenTypes . CLASS_DEF , "class" ) ) ; try { obj . visitToken ( ast ) ; fail ( ) ; } catch ( IllegalStateException e ) { assertEquals ( ast . toString ( ) , e . getMessage ( ) ) ; } } @ Test public void testNotIgnorePrivateMethod ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( ThrowsCountCheck . class ) ; checkConfig . addAttribute ( "ignorePrivateMethods" , "false" ) ; String [ ] expected = { "17:20: " + getCheckMessage ( MSG_KEY , 5 , 4 ) , "22:20: " + getCheckMessage ( MSG_KEY , 5 , 4 ) , "27:20: " + getCheckMessage ( MSG_KEY , 6 , 4 ) , "35:28: " + getCheckMessage ( MSG_KEY , 5 , 4 ) , "55:43: " + getCheckMessage ( MSG_KEY , 5 , 4 ) , } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputThrowsCount.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . design ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . design . DesignForExtensionCheck . MSG_KEY ; import static org . junit . Assert . assertArrayEquals ; public class DesignForExtensionCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DesignForExtensionCheck . class ) ; final String [ ] expected = { "46:5: " + getCheckMessage ( MSG_KEY , "doh" ) , "54:5: " + getCheckMessage ( MSG_KEY , "aNativeMethod" ) , "105:9: " + getCheckMessage ( MSG_KEY , "someMethod" ) , } ; verify ( checkConfig , getPath ( "InputDesignForExtension.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { DesignForExtensionCheck obj = new DesignForExtensionCheck ( ) ; int [ ] expected = { TokenTypes . METHOD_DEF } ; assertArrayEquals ( expected , obj . getAcceptableTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . design ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . design . FinalClassCheck . MSG_KEY ; import static org . junit . Assert . assertArrayEquals ; public class FinalClassCheckTest extends BaseCheckTestSupport { @ Test public void testFianlClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalClassCheck . class ) ; final String [ ] expected = { "7: " + getCheckMessage ( MSG_KEY , "InputFinalClass" ) , "15: " + getCheckMessage ( MSG_KEY , "test4" ) , "109: " + getCheckMessage ( MSG_KEY , "someinnerClass" ) , } ; verify ( checkConfig , getPath ( "InputFinalClass.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { FinalClassCheck obj = new FinalClassCheck ( ) ; int [ ] expected = { TokenTypes . CLASS_DEF , TokenTypes . CTOR_DEF } ; assertArrayEquals ( expected , obj . getAcceptableTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . design ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . design . InterfaceIsTypeCheck . MSG_KEY ; import static org . junit . Assert . assertArrayEquals ; public class InterfaceIsTypeCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( InterfaceIsTypeCheck . class ) ; final String [ ] expected = { "25: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputInterfaceIsType.java" ) , expected ) ; } @ Test public void testAllowMarker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( InterfaceIsTypeCheck . class ) ; checkConfig . addAttribute ( "allowMarkerInterfaces" , "false" ) ; final String [ ] expected = { "20: " + getCheckMessage ( MSG_KEY ) , "25: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputInterfaceIsType.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { InterfaceIsTypeCheck obj = new InterfaceIsTypeCheck ( ) ; int [ ] expected = { TokenTypes . INTERFACE_DEF } ; assertArrayEquals ( expected , obj . getAcceptableTokens ( ) ) ; } @ Test public void testGetRequiredTokens ( ) { InterfaceIsTypeCheck obj = new InterfaceIsTypeCheck ( ) ; int [ ] expected = { TokenTypes . INTERFACE_DEF } ; assertArrayEquals ( expected , obj . getRequiredTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . design ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . io . File ; import static com . puppycrawl . tools . checkstyle . checks . design . HideUtilityClassConstructorCheck . MSG_KEY ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; import static org . junit . Assert . assertArrayEquals ; public class HideUtilityClassConstructorCheckTest extends BaseCheckTestSupport { @ Test public void testUtilClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HideUtilityClassConstructorCheck . class ) ; final String [ ] expected = { "3:1: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "design" + File . separator + "UtilityClassConstructor.java" ) , expected ) ; } @ Test public void testUtilClassPublicCtor ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HideUtilityClassConstructorCheck . class ) ; final String [ ] expected = { "3:1: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "design" + File . separator + "UtilityClassConstructorPublic.java" ) , expected ) ; } @ Test public void testUtilClassPrivateCtor ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HideUtilityClassConstructorCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "design" + File . separator + "UtilityClassConstructorPrivate.java" ) , expected ) ; } @ Test public void testNonUtilClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HideUtilityClassConstructorCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputDesignForExtension.java" ) , expected ) ; } @ Test public void testDerivedNonUtilClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HideUtilityClassConstructorCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputNonUtilityClass.java" ) , expected ) ; } @ Test public void testOnlyNonstaticFieldNonUtilClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HideUtilityClassConstructorCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "design" + File . separator + "InputRegression1762702.java" ) , expected ) ; } @ Test public void testEmptyAbstractClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HideUtilityClassConstructorCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "design" + File . separator + "HideUtilityClassContructor3041574_1.java" ) , expected ) ; } @ Test public void testEmptyClassWithOnlyPrivateFields ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HideUtilityClassConstructorCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "design" + File . separator + "HideUtilityClassContructor3041574_2.java" ) , expected ) ; } @ Test public void testClassWithStaticInnerClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HideUtilityClassConstructorCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "design" + File . separator + "HideUtilityClassContructor3041574_3.java" ) , expected ) ; } @ Test public void testProtectedCtor ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HideUtilityClassConstructorCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "design" + File . separator + "HideUtilityClassConstructor.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { HideUtilityClassConstructorCheck obj = new HideUtilityClassConstructorCheck ( ) ; int [ ] expected = { TokenTypes . CLASS_DEF } ; assertArrayEquals ( expected , obj . getAcceptableTokens ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . design ; import static com . puppycrawl . tools . checkstyle . checks . design . VisibilityModifierCheck . MSG_KEY ; import static org . junit . Assert . assertArrayEquals ; import antlr . CommonHiddenStreamToken ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . Checker ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class VisibilityModifierCheckTest extends BaseCheckTestSupport { private Checker getChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; checkConfig . addAttribute ( "publicMemberPattern" , "^f[A-Z][a-zA-Z0-9]*$" ) ; return createChecker ( checkConfig ) ; } @ Test public void testInner ( ) throws Exception { final String [ ] expected = { "30:24: " + getCheckMessage ( MSG_KEY , "rData" ) , "33:27: " + getCheckMessage ( MSG_KEY , "protectedVariable" ) , "36:17: " + getCheckMessage ( MSG_KEY , "packageVariable" ) , "41:29: " + getCheckMessage ( MSG_KEY , "sWeird" ) , "43:19: " + getCheckMessage ( MSG_KEY , "sWeird2" ) , "77:20: " + getCheckMessage ( MSG_KEY , "someValue" ) , } ; verify ( getChecker ( ) , getPath ( "InputInner.java" ) , expected ) ; } @ Test public void testIgnoreAccess ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; checkConfig . addAttribute ( "publicMemberPattern" , "^r[A-Z]" ) ; checkConfig . addAttribute ( "protectedAllowed" , "true" ) ; checkConfig . addAttribute ( "packageAllowed" , "true" ) ; final String [ ] expected = { "17:20: " + getCheckMessage ( MSG_KEY , "fData" ) , "77:20: " + getCheckMessage ( MSG_KEY , "someValue" ) , } ; verify ( checkConfig , getPath ( "InputInner.java" ) , expected ) ; } @ Test public void testSimple ( ) throws Exception { final String [ ] expected = { "39:19: " + getCheckMessage ( MSG_KEY , "mNumCreated2" ) , "49:23: " + getCheckMessage ( MSG_KEY , "sTest1" ) , "51:26: " + getCheckMessage ( MSG_KEY , "sTest3" ) , "53:16: " + getCheckMessage ( MSG_KEY , "sTest2" ) , "56:9: " + getCheckMessage ( MSG_KEY , "mTest1" ) , "58:16: " + getCheckMessage ( MSG_KEY , "mTest2" ) , } ; verify ( getChecker ( ) , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testStrictJavadoc ( ) throws Exception { final String [ ] expected = { "44:9: " + getCheckMessage ( MSG_KEY , "mLen" ) , "45:19: " + getCheckMessage ( MSG_KEY , "mDeer" ) , "46:16: " + getCheckMessage ( MSG_KEY , "aFreddo" ) , } ; verify ( getChecker ( ) , getPath ( "InputPublicOnly.java" ) , expected ) ; } @ Test public void testAllowPublicFinalFieldsInImmutableClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; final String [ ] expected = { "12:39: " + getCheckMessage ( MSG_KEY , "includes" ) , "13:39: " + getCheckMessage ( MSG_KEY , "excludes" ) , "16:23: " + getCheckMessage ( MSG_KEY , "list" ) , "34:20: " + getCheckMessage ( MSG_KEY , "value" ) , "36:24: " + getCheckMessage ( MSG_KEY , "bValue" ) , "37:31: " + getCheckMessage ( MSG_KEY , "longValue" ) , } ; verify ( checkConfig , getPath ( "InputImmutable.java" ) , expected ) ; } @ Test public void testUserSpecifiedImmutableClassesList ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; checkConfig . addAttribute ( "immutableClassCanonicalNames" , "java.util.List," + "com.google.common.collect.ImmutableSet" ) ; final String [ ] expected = { "14:35: " + getCheckMessage ( MSG_KEY , "notes" ) , "15:29: " + getCheckMessage ( MSG_KEY , "value" ) , "32:35: " + getCheckMessage ( MSG_KEY , "uri" ) , "33:35: " + getCheckMessage ( MSG_KEY , "file" ) , "34:20: " + getCheckMessage ( MSG_KEY , "value" ) , "35:35: " + getCheckMessage ( MSG_KEY , "url" ) , "36:24: " + getCheckMessage ( MSG_KEY , "bValue" ) , "37:31: " + getCheckMessage ( MSG_KEY , "longValue" ) , } ; verify ( checkConfig , getPath ( "InputImmutable.java" ) , expected ) ; } @ Test public void testImmutableSpecifiedSameTypeName ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; checkConfig . addAttribute ( "immutableClassCanonicalNames" , "com.puppycrawl.tools.checkstyle.coding.GregorianCalendar," + "com.puppycrawl.tools.checkstyle.InetSocketAddress" ) ; final String [ ] expected = { "7:46: " + getCheckMessage ( MSG_KEY , "calendar" ) , "11:45: " + getCheckMessage ( MSG_KEY , "adr" ) , } ; verify ( checkConfig , getPath ( "InputImmutableSameTypeName.java" ) , expected ) ; } @ Test public void testImmutableDefaultValueSameTypeName ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; final String [ ] expected = { "7:46: " + getCheckMessage ( MSG_KEY , "calendar" ) , "8:36: " + getCheckMessage ( MSG_KEY , "calendar2" ) , "9:75: " + getCheckMessage ( MSG_KEY , "calendar3" ) , "10:36: " + getCheckMessage ( MSG_KEY , "address" ) , } ; verify ( checkConfig , getPath ( "InputImmutableSameTypeName.java" ) , expected ) ; } @ Test public void testImmutableStarImportFalseNegative ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; checkConfig . addAttribute ( "immutableClassCanonicalNames" , "java.util.Arrays" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputImmutableStarImport.java" ) , expected ) ; } @ Test public void testImmutableStarImportNoWarn ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; checkConfig . addAttribute ( "immutableClassCanonicalNames" , "com.google.common.collect.ImmutableSet" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputImmutableStarImport2.java" ) , expected ) ; } @ Test public void testDefaultAnnotationPatterns ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; final String [ ] expected = { "39:19: " + getCheckMessage ( MSG_KEY , "customAnnotatedPublic" ) , "42:12: " + getCheckMessage ( MSG_KEY , "customAnnotatedPackage" ) , "45:22: " + getCheckMessage ( MSG_KEY , "customAnnotatedProtected" ) , "47:19: " + getCheckMessage ( MSG_KEY , "unannotatedPublic" ) , "48:12: " + getCheckMessage ( MSG_KEY , "unannotatedPackage" ) , "49:22: " + getCheckMessage ( MSG_KEY , "unannotatedProtected" ) , } ; verify ( checkConfig , getPath ( "AnnotatedVisibility.java" ) , expected ) ; } @ Test public void testCustomAnnotationPatterns ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; checkConfig . addAttribute ( "ignoreAnnotationCanonicalNames" , "com.puppycrawl.tools.checkstyle.AnnotatedVisibility.CustomAnnotation" ) ; final String [ ] expected = { "15:28: " + getCheckMessage ( MSG_KEY , "publicJUnitRule" ) , "18:28: " + getCheckMessage ( MSG_KEY , "fqPublicJUnitRule" ) , "21:19: " + getCheckMessage ( MSG_KEY , "googleCommonsAnnotatedPublic" ) , "24:12: " + getCheckMessage ( MSG_KEY , "googleCommonsAnnotatedPackage" ) , "27:22: " + getCheckMessage ( MSG_KEY , "googleCommonsAnnotatedProtected" ) , "30:19: " + getCheckMessage ( MSG_KEY , "fqGoogleCommonsAnnotatedPublic" ) , "33:12: " + getCheckMessage ( MSG_KEY , "fqGoogleCommonsAnnotatedPackage" ) , "36:22: " + getCheckMessage ( MSG_KEY , "fqGoogleCommonsAnnotatedProtected" ) , "47:19: " + getCheckMessage ( MSG_KEY , "unannotatedPublic" ) , "48:12: " + getCheckMessage ( MSG_KEY , "unannotatedPackage" ) , "49:22: " + getCheckMessage ( MSG_KEY , "unannotatedProtected" ) , } ; verify ( checkConfig , getPath ( "AnnotatedVisibility.java" ) , expected ) ; } @ Test public void testIgnoreAnnotationNoPattern ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; checkConfig . addAttribute ( "ignoreAnnotationCanonicalNames" , "" ) ; final String [ ] expected = { "15:28: " + getCheckMessage ( MSG_KEY , "publicJUnitRule" ) , "18:28: " + getCheckMessage ( MSG_KEY , "fqPublicJUnitRule" ) , "21:19: " + getCheckMessage ( MSG_KEY , "googleCommonsAnnotatedPublic" ) , "24:12: " + getCheckMessage ( MSG_KEY , "googleCommonsAnnotatedPackage" ) , "27:22: " + getCheckMessage ( MSG_KEY , "googleCommonsAnnotatedProtected" ) , "30:19: " + getCheckMessage ( MSG_KEY , "fqGoogleCommonsAnnotatedPublic" ) , "33:12: " + getCheckMessage ( MSG_KEY , "fqGoogleCommonsAnnotatedPackage" ) , "36:22: " + getCheckMessage ( MSG_KEY , "fqGoogleCommonsAnnotatedProtected" ) , "39:19: " + getCheckMessage ( MSG_KEY , "customAnnotatedPublic" ) , "42:12: " + getCheckMessage ( MSG_KEY , "customAnnotatedPackage" ) , "45:22: " + getCheckMessage ( MSG_KEY , "customAnnotatedProtected" ) , "47:19: " + getCheckMessage ( MSG_KEY , "unannotatedPublic" ) , "48:12: " + getCheckMessage ( MSG_KEY , "unannotatedPackage" ) , "49:22: " + getCheckMessage ( MSG_KEY , "unannotatedProtected" ) , } ; verify ( checkConfig , getPath ( "AnnotatedVisibility.java" ) , expected ) ; } @ Test public void testIgnoreAnnotationSameName ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; final String [ ] expected = { "10:28: " + getCheckMessage ( MSG_KEY , "publicJUnitRule" ) , } ; verify ( checkConfig , getPath ( "AnnotatedVisibilitySameTypeName.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { VisibilityModifierCheck obj = new VisibilityModifierCheck ( ) ; int [ ] expected = { TokenTypes . VARIABLE_DEF , TokenTypes . OBJBLOCK , TokenTypes . IMPORT , } ; assertArrayEquals ( expected , obj . getAcceptableTokens ( ) ) ; } @ Test public void testPublicImmutableFieldsNotAllowed ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; checkConfig . addAttribute ( "allowPublicImmutableFields" , "false" ) ; final String [ ] expected = { "10:22: " + getCheckMessage ( MSG_KEY , "someIntValue" ) , "11:39: " + getCheckMessage ( MSG_KEY , "includes" ) , "12:35: " + getCheckMessage ( MSG_KEY , "notes" ) , "13:29: " + getCheckMessage ( MSG_KEY , "value" ) , "14:23: " + getCheckMessage ( MSG_KEY , "list" ) , } ; verify ( checkConfig , getPath ( "InputPublicImmutable.java" ) , expected ) ; } @ Test ( expected = IllegalArgumentException . class ) public void testWrongTokenType ( ) { VisibilityModifierCheck obj = new VisibilityModifierCheck ( ) ; DetailAST ast = new DetailAST ( ) ; ast . initialize ( new CommonHiddenStreamToken ( TokenTypes . CLASS_DEF , "class" ) ) ; obj . visitToken ( ast ) ; } @ Test public void testNullModifiers ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( VisibilityModifierCheck . class ) ; final String [ ] expected = { "11:50: " + getCheckMessage ( MSG_KEY , "i" ) , } ; verify ( checkConfig , getPath ( "InputNullModifiers.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; import java . util . Locale ; import org . junit . Test ; public class ScopeTest { @ Test ( expected = IllegalArgumentException . class ) public void testMisc ( ) { final Scope o = Scope . getInstance ( "public" ) ; assertNotNull ( o ) ; assertEquals ( "public" , o . toString ( ) ) ; assertEquals ( "public" , o . getName ( ) ) ; Scope . getInstance ( "unknown" ) ; } @ Test public void testMixedCaseSpaces ( ) { Scope . getInstance ( "NothinG " ) ; Scope . getInstance ( " PuBlic" ) ; Scope . getInstance ( " ProteCted" ) ; Scope . getInstance ( " PackAge " ) ; Scope . getInstance ( "privaTe " ) ; Scope . getInstance ( "AnonInner" ) ; } @ Test public void testMixedCaseSpacesWithDifferentLocales ( ) { Locale [ ] differentLocales = new Locale [ ] { new Locale ( "TR" , "tr" ) } ; Locale defaultLocale = Locale . getDefault ( ) ; try { for ( Locale differentLocale : differentLocales ) { Locale . setDefault ( differentLocale ) ; testMixedCaseSpaces ( ) ; } } finally { Locale . setDefault ( defaultLocale ) ; } } @ Test public void testIsInAnonInner ( ) { assertTrue ( Scope . NOTHING . isIn ( Scope . ANONINNER ) ) ; assertTrue ( Scope . PUBLIC . isIn ( Scope . ANONINNER ) ) ; assertTrue ( Scope . PROTECTED . isIn ( Scope . ANONINNER ) ) ; assertTrue ( Scope . PACKAGE . isIn ( Scope . ANONINNER ) ) ; assertTrue ( Scope . PRIVATE . isIn ( Scope . ANONINNER ) ) ; assertTrue ( Scope . ANONINNER . isIn ( Scope . ANONINNER ) ) ; } @ Test public void testIsInPrivate ( ) { assertTrue ( Scope . NOTHING . isIn ( Scope . PRIVATE ) ) ; assertTrue ( Scope . PUBLIC . isIn ( Scope . PRIVATE ) ) ; assertTrue ( Scope . PROTECTED . isIn ( Scope . PRIVATE ) ) ; assertTrue ( Scope . PACKAGE . isIn ( Scope . PRIVATE ) ) ; assertTrue ( Scope . PRIVATE . isIn ( Scope . PRIVATE ) ) ; assertTrue ( ! Scope . ANONINNER . isIn ( Scope . PRIVATE ) ) ; } @ Test public void testIsInPackage ( ) { assertTrue ( Scope . NOTHING . isIn ( Scope . PACKAGE ) ) ; assertTrue ( Scope . PUBLIC . isIn ( Scope . PACKAGE ) ) ; assertTrue ( Scope . PROTECTED . isIn ( Scope . PACKAGE ) ) ; assertTrue ( Scope . PACKAGE . isIn ( Scope . PACKAGE ) ) ; assertTrue ( ! Scope . PRIVATE . isIn ( Scope . PACKAGE ) ) ; assertTrue ( ! Scope . ANONINNER . isIn ( Scope . PACKAGE ) ) ; } @ Test public void testIsInProtected ( ) { assertTrue ( Scope . NOTHING . isIn ( Scope . PROTECTED ) ) ; assertTrue ( Scope . PUBLIC . isIn ( Scope . PROTECTED ) ) ; assertTrue ( Scope . PROTECTED . isIn ( Scope . PROTECTED ) ) ; assertTrue ( ! Scope . PACKAGE . isIn ( Scope . PROTECTED ) ) ; assertTrue ( ! Scope . PRIVATE . isIn ( Scope . PROTECTED ) ) ; assertTrue ( ! Scope . ANONINNER . isIn ( Scope . PROTECTED ) ) ; } @ Test public void testIsInPublic ( ) { assertTrue ( Scope . NOTHING . isIn ( Scope . PUBLIC ) ) ; assertTrue ( Scope . PUBLIC . isIn ( Scope . PUBLIC ) ) ; assertTrue ( ! Scope . PROTECTED . isIn ( Scope . PUBLIC ) ) ; assertTrue ( ! Scope . PACKAGE . isIn ( Scope . PUBLIC ) ) ; assertTrue ( ! Scope . PRIVATE . isIn ( Scope . PUBLIC ) ) ; assertTrue ( ! Scope . ANONINNER . isIn ( Scope . PUBLIC ) ) ; } @ Test public void testIsInNothing ( ) { assertTrue ( Scope . NOTHING . isIn ( Scope . NOTHING ) ) ; assertTrue ( ! Scope . PUBLIC . isIn ( Scope . NOTHING ) ) ; assertTrue ( ! Scope . PROTECTED . isIn ( Scope . NOTHING ) ) ; assertTrue ( ! Scope . PACKAGE . isIn ( Scope . NOTHING ) ) ; assertTrue ( ! Scope . PRIVATE . isIn ( Scope . NOTHING ) ) ; assertTrue ( ! Scope . ANONINNER . isIn ( Scope . NOTHING ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . regexp ; import com . google . common . base . Charsets ; import com . google . common . io . Files ; import com . puppycrawl . tools . checkstyle . BaseFileSetCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; import java . io . File ; import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . REGEXP_EXCEEDED ; import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . EMPTY ; import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . STACKOVERFLOW ; public class RegexpMultilineCheckTest extends BaseFileSetCheckTestSupport { @ Rule public TemporaryFolder temporaryFolder = new TemporaryFolder ( ) ; private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( RegexpMultilineCheck . class ) ; } @ Test public void testIt ( ) throws Exception { final String illegal = "System\\.(out)|(err)\\.print(ln)?\\(" ; checkConfig . addAttribute ( "format" , illegal ) ; final String [ ] expected = { "69: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testMessageProperty ( ) throws Exception { final String illegal = "System\\.(out)|(err)\\.print(ln)?\\(" ; final String message = "Bad line :(" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "message" , message ) ; final String [ ] expected = { "69: " + message , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testIgnoreCaseTrue ( ) throws Exception { final String illegal = "SYSTEM\\.(OUT)|(ERR)\\.PRINT(LN)?\\(" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreCase" , "true" ) ; final String [ ] expected = { "69: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testIgnoreCaseFalse ( ) throws Exception { final String illegal = "SYSTEM\\.(OUT)|(ERR)\\.PRINT(LN)?\\(" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreCase" , "false" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testIllegalFailBelowErrorLimit ( ) throws Exception { final String illegal = "^import" ; checkConfig . addAttribute ( "format" , illegal ) ; final String [ ] expected = { "7: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , "8: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , "9: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testCarriageReturn ( ) throws Exception { final String illegal = "\\r" ; checkConfig . addAttribute ( "format" , illegal ) ; final String [ ] expected = { "1: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , "3: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , } ; final File file = temporaryFolder . newFile ( ) ; Files . write ( "first line \r\n second line \n\r third line" , file , Charsets . UTF_8 ) ; verify ( checkConfig , file . getPath ( ) , expected ) ; } @ Test public void testDefaultConfiguration ( ) throws Exception { final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testEmptyFormat ( ) throws Exception { checkConfig . addAttribute ( "format" , null ) ; final String [ ] expected = { "0: " + getCheckMessage ( EMPTY ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testNoStackOverflowError ( ) throws Exception { checkConfig . addAttribute ( "format" , "(x|y)*" ) ; final String [ ] expected = { "0: " + getCheckMessage ( STACKOVERFLOW ) , } ; final File file = temporaryFolder . newFile ( ) ; Files . write ( makeLargeXYString ( ) , file , Charsets . UTF_8 ) ; verify ( checkConfig , file . getPath ( ) , expected ) ; } private CharSequence makeLargeXYString ( ) { final int size = 100000 ; StringBuffer largeString = new StringBuffer ( size ) ; for ( int i = 0 ; i < size / 2 ; i ++ ) { largeString . append ( "xy" ) ; } return largeString ; } }
package com . puppycrawl . tools . checkstyle . checks . regexp ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . REGEXP_EXCEEDED ; import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . REGEXP_MINIMUM ; public class RegexpSinglelineJavaCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( RegexpSinglelineJavaCheck . class ) ; } @ Test public void testIt ( ) throws Exception { final String illegal = "System\\.(out)|(err)\\.print(ln)?\\(" ; checkConfig . addAttribute ( "format" , illegal ) ; final String [ ] expected = { "69: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testMessageProperty ( ) throws Exception { final String illegal = "System\\.(out)|(err)\\.print(ln)?\\(" ; final String message = "Bad line :(" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "message" , message ) ; final String [ ] expected = { "69: " + message , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testIgnoreCaseTrue ( ) throws Exception { final String illegal = "SYSTEM\\.(OUT)|(ERR)\\.PRINT(LN)?\\(" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreCase" , "true" ) ; final String [ ] expected = { "69: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testIgnoreCaseFalse ( ) throws Exception { final String illegal = "SYSTEM\\.(OUT)|(ERR)\\.PRINT(LN)?\\(" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreCase" , "false" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testIgnoreCommentsCppStyle ( ) throws Exception { final String illegal = "don't use trailing comments" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsFalseCppStyle ( ) throws Exception { final String illegal = "don't use trailing comments" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreComments" , "false" ) ; final String [ ] expected = { "4: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsCStyle ( ) throws Exception { final String illegal = "c-style 1" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsFalseCStyle ( ) throws Exception { final String illegal = "c-style 1" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreComments" , "false" ) ; final String [ ] expected = { "19: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsMultipleCStyle ( ) throws Exception { final String illegal = "c-style 2" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsMultiLine ( ) throws Exception { final String illegal = "Let's check multi-line comments" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsInlineStart ( ) throws Exception { final String illegal = "long ms /" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsInlineEnd ( ) throws Exception { final String illegal = "int z" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { "22: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsInlineMiddle ( ) throws Exception { final String illegal = "int y" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { "23: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsNoSpaces ( ) throws Exception { final String illegal = "long ms " ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void test1371588 ( ) throws Exception { final String illegal = "\\s+$" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testExistingInDoc ( ) throws Exception { final String required = "Test case file" ; checkConfig . addAttribute ( "format" , required ) ; checkConfig . addAttribute ( "minimum" , "1" ) ; checkConfig . addAttribute ( "maximum" , "1000" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testExistingInCode ( ) throws Exception { final String required = "package" ; checkConfig . addAttribute ( "format" , required ) ; checkConfig . addAttribute ( "minimum" , "1" ) ; checkConfig . addAttribute ( "maximum" , "1000" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testMissing ( ) throws Exception { final String required = "This text is not in the file" ; checkConfig . addAttribute ( "format" , required ) ; checkConfig . addAttribute ( "minimum" , "1" ) ; checkConfig . addAttribute ( "maximum" , "1000" ) ; final String [ ] expected = { "0: " + getCheckMessage ( REGEXP_MINIMUM , 1 , required ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . regexp ; import com . puppycrawl . tools . checkstyle . BaseFileSetCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . REGEXP_EXCEEDED ; public class RegexpSinglelineCheckTest extends BaseFileSetCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( RegexpSinglelineCheck . class ) ; } @ Test public void testIt ( ) throws Exception { final String illegal = "System\\.(out)|(err)\\.print(ln)?\\(" ; checkConfig . addAttribute ( "format" , illegal ) ; final String [ ] expected = { "69: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testMessageProperty ( ) throws Exception { final String illegal = "System\\.(out)|(err)\\.print(ln)?\\(" ; final String message = "Bad line :(" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "message" , message ) ; final String [ ] expected = { "69: " + message , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testIgnoreCaseTrue ( ) throws Exception { final String illegal = "SYSTEM\\.(OUT)|(ERR)\\.PRINT(LN)?\\(" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreCase" , "true" ) ; final String [ ] expected = { "69: " + getCheckMessage ( REGEXP_EXCEEDED , illegal ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testIgnoreCaseFalse ( ) throws Exception { final String illegal = "SYSTEM\\.(OUT)|(ERR)\\.PRINT(LN)?\\(" ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "ignoreCase" , "false" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . regexp ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . regexp . RegexpCheck . MSG_ILLEGAL_REGEXP ; import static com . puppycrawl . tools . checkstyle . checks . regexp . RegexpCheck . MSG_DUPLICATE_REGEXP ; import static com . puppycrawl . tools . checkstyle . checks . regexp . RegexpCheck . MSG_REQUIRED_REGEXP ; public class RegexpCheckTest extends BaseCheckTestSupport { @ Test public void testRequiredPass ( ) throws Exception { final String required = "Test case file" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , required ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testRequiredFail ( ) throws Exception { final String required = "This text is not in the file" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , required ) ; final String [ ] expected = { "0: " + getCheckMessage ( MSG_REQUIRED_REGEXP , required ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testRequiredNoDuplicatesPass ( ) throws Exception { final String required = "Test case file" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , required ) ; checkConfig . addAttribute ( "duplicateLimit" , "0" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testRequiredNoDuplicatesFail ( ) throws Exception { final String required = "Boolean x = new Boolean" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , required ) ; checkConfig . addAttribute ( "duplicateLimit" , "0" ) ; final String [ ] expected = { "24: " + getCheckMessage ( MSG_DUPLICATE_REGEXP , required ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testIllegalPass ( ) throws Exception { final String illegal = "This text is not in the file" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testIllegalFailBelowErrorLimit ( ) throws Exception { final String illegal = "^import" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "errorLimit" , "4" ) ; final String [ ] expected = { "7: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , illegal ) , "8: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , illegal ) , "9: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , illegal ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testIllegalFailAboveErrorLimit ( ) throws Exception { final String illegal = "^import" ; final String error = "The error limit has been exceeded, " + "the check is aborting, there may be more unreported errors." ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "errorLimit" , "3" ) ; final String [ ] expected = { "7: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , illegal ) , "8: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , illegal ) , "9: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , error + illegal ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testMessagePropertyGood ( ) throws Exception { final String illegal = "System\\.(out)|(err)\\.print(ln)?\\(" ; final String message = "Bad line :(" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "message" , message ) ; final String [ ] expected = { "69: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , message ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testMessagePropertyBad ( ) throws Exception { final String illegal = "System\\.(out)|(err)\\.print(ln)?\\(" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "message" , null ) ; final String [ ] expected = { "69: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , illegal ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testIgnoreCaseTrue ( ) throws Exception { final String illegal = "(?i)SYSTEM\\.(OUT)|(ERR)\\.PRINT(LN)?\\(" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; final String [ ] expected = { "69: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , illegal ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testIgnoreCaseFalse ( ) throws Exception { final String illegalTrue = "(?i)SYSTEM\\.(OUT)|(ERR)\\.PRINT(LN)?\\(" ; final DefaultConfiguration checkConfigTrue = createCheckConfig ( RegexpCheck . class ) ; checkConfigTrue . addAttribute ( "format" , illegalTrue ) ; checkConfigTrue . addAttribute ( "illegalPattern" , "true" ) ; final String [ ] expectedTrue = { "69: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , illegalTrue ) , } ; verify ( checkConfigTrue , getPath ( "InputSemantic.java" ) , expectedTrue ) ; final String illegalFalse = "SYSTEM\\.(OUT)|(ERR)\\.PRINT(LN)?\\(" ; final DefaultConfiguration checkConfigFalse = createCheckConfig ( RegexpCheck . class ) ; checkConfigFalse . addAttribute ( "format" , illegalFalse ) ; checkConfigFalse . addAttribute ( "illegalPattern" , "true" ) ; final String [ ] expectedFalse = { } ; verify ( checkConfigFalse , getPath ( "InputSemantic.java" ) , expectedFalse ) ; } @ Test public void testIgnoreCommentsCppStyle ( ) throws Exception { final String illegal = "don't use trailing comments" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsFalseCppStyle ( ) throws Exception { final String illegal = "don't use trailing comments" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "ignoreComments" , "false" ) ; final String [ ] expected = { "4: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , illegal ) , } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsCStyle ( ) throws Exception { final String illegal = "c-style 1" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsFalseCStyle ( ) throws Exception { final String illegal = "c-style 1" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "ignoreComments" , "false" ) ; final String [ ] expected = { "19: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , illegal ) , } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsMultipleCStyle ( ) throws Exception { final String illegal = "c-style 2" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsMultiLine ( ) throws Exception { final String illegal = "Let's check multi-line comments" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsInlineStart ( ) throws Exception { final String illegal = "long ms /" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsInlineEnd ( ) throws Exception { final String illegal = "int z" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { "22: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , illegal ) , } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsInlineMiddle ( ) throws Exception { final String illegal = "int y" ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { "23: " + getCheckMessage ( MSG_ILLEGAL_REGEXP , illegal ) , } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testIgnoreCommentsNoSpaces ( ) throws Exception { final String illegal = "long ms " ; final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; checkConfig . addAttribute ( "format" , illegal ) ; checkConfig . addAttribute ( "illegalPattern" , "true" ) ; checkConfig . addAttribute ( "ignoreComments" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testOnFileStartingWithEmptyLine ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RegexpCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputStartingWithEmptyLine.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . header ; import static org . junit . Assert . fail ; import java . io . File ; import java . net . URI ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseFileSetCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import static com . puppycrawl . tools . checkstyle . checks . header . HeaderCheck . MSG_MISMATCH ; import static com . puppycrawl . tools . checkstyle . checks . header . HeaderCheck . MSG_MISSING ; public class HeaderCheckTest extends BaseFileSetCheckTestSupport { @ Test public void testStaticHeader ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HeaderCheck . class ) ; checkConfig . addAttribute ( "headerFile" , getPath ( "configs/java.header" ) ) ; checkConfig . addAttribute ( "ignoreLines" , "" ) ; final String [ ] expected = { "1: " + getCheckMessage ( MSG_MISSING ) , } ; verify ( checkConfig , getPath ( "inputHeader.java" ) , expected ) ; } @ Test public void testRegexpHeader ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RegexpHeaderCheck . class ) ; checkConfig . addAttribute ( "headerFile" , getPath ( "regexp.header" ) ) ; final String [ ] expected = { "3: " + getCheckMessage ( MSG_MISMATCH , "// Created: 2002" ) , } ; verify ( checkConfig , getPath ( "InputScopeAnonInner.java" ) , expected ) ; } @ Test public void testRegexpHeaderURL ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RegexpHeaderCheck . class ) ; URI uri = new File ( getPath ( "regexp.header" ) ) . toURI ( ) ; checkConfig . addAttribute ( "headerFile" , uri . toString ( ) ) ; final String [ ] expected = { "3: " + getCheckMessage ( MSG_MISMATCH , "// Created: 2002" ) , } ; verify ( checkConfig , getPath ( "InputScopeAnonInner.java" ) , expected ) ; } @ Test public void testInlineRegexpHeader ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RegexpHeaderCheck . class ) ; checkConfig . addAttribute ( "header" , "^/*$\\n// .*\\n// Created: 2002\\n^//.*\\n^//.*" ) ; final String [ ] expected = { "3: " + getCheckMessage ( MSG_MISMATCH , "// Created: 2002" ) , } ; verify ( checkConfig , getPath ( "InputScopeAnonInner.java" ) , expected ) ; } @ Test public void testFailureForMultilineRegexp ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RegexpHeaderCheck . class ) ; checkConfig . addAttribute ( "header" , "^(.*\\n.*)" ) ; try { createChecker ( checkConfig ) ; fail ( "Checker creation should not succeed when regexp spans multiple lines" ) ; } catch ( CheckstyleException ex ) { } } @ Test public void testRegexpHeaderIgnore ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RegexpHeaderCheck . class ) ; checkConfig . addAttribute ( "headerFile" , getPath ( "regexp.header1" ) ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputScopeAnonInner.java" ) , expected ) ; } @ Test public void testRegexpHeaderMulti1 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RegexpHeaderCheck . class ) ; checkConfig . addAttribute ( "headerFile" , getPath ( "regexp.header2" ) ) ; checkConfig . addAttribute ( "multiLines" , "3, 6" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputRegexpHeader1.java" ) , expected ) ; } @ Test public void testRegexpHeaderMulti2 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RegexpHeaderCheck . class ) ; checkConfig . addAttribute ( "headerFile" , getPath ( "regexp.header2" ) ) ; checkConfig . addAttribute ( "multiLines" , "3, 6" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputRegexpHeader2.java" ) , expected ) ; } @ Test public void testRegexpHeaderMulti3 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RegexpHeaderCheck . class ) ; checkConfig . addAttribute ( "headerFile" , getPath ( "regexp.header2" ) ) ; checkConfig . addAttribute ( "multiLines" , "3, 7" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputRegexpHeader1.java" ) , expected ) ; } @ Test public void testRegexpHeaderMulti4 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RegexpHeaderCheck . class ) ; checkConfig . addAttribute ( "headerFile" , getPath ( "regexp.header2" ) ) ; checkConfig . addAttribute ( "multiLines" , "3, 5, 6, 7" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputRegexpHeader3.java" ) , expected ) ; } @ Test public void testRegexpHeaderMulti5 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RegexpHeaderCheck . class ) ; checkConfig . addAttribute ( "headerFile" , getPath ( "regexp.header2" ) ) ; checkConfig . addAttribute ( "multiLines" , "3" ) ; final String [ ] expected = { "1: " + getCheckMessage ( MSG_MISSING ) , } ; verify ( checkConfig , getPath ( "InputRegexpHeader4.java" ) , expected ) ; } @ Test public void testRegexpHeaderSmallHeader ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RegexpHeaderCheck . class ) ; checkConfig . addAttribute ( "headerFile" , getPath ( "regexp.header2" ) ) ; checkConfig . addAttribute ( "multiLines" , "3, 6" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputRegexpSmallHeader.java" ) , expected ) ; } @ Test public void testNoHeader ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HeaderCheck . class ) ; try { createChecker ( checkConfig ) ; fail ( ) ; } catch ( CheckstyleException ex ) { } } @ Test public void testNonExistingHeaderFile ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HeaderCheck . class ) ; checkConfig . addAttribute ( "headerFile" , getPath ( "nonexisting.file" ) ) ; try { createChecker ( checkConfig ) ; fail ( ) ; } catch ( CheckstyleException ex ) { } } @ Test public void testInvalidCharset ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HeaderCheck . class ) ; checkConfig . addAttribute ( "headerFile" , getPath ( "config/java.header" ) ) ; checkConfig . addAttribute ( "charset" , "XSO-8859-1" ) ; try { createChecker ( checkConfig ) ; fail ( ) ; } catch ( CheckstyleException ex ) { } } @ Test public void testEmptyFilename ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( HeaderCheck . class ) ; checkConfig . addAttribute ( "headerFile" , "" ) ; try { createChecker ( checkConfig ) ; fail ( "Checker creation should not succeed with invalid headerFile" ) ; } catch ( CheckstyleException ex ) { } } }
package com . puppycrawl . tools . checkstyle . checks . header ; import org . apache . commons . beanutils . ConversionException ; import org . junit . Assert ; import org . junit . Test ; public class RegexpHeaderCheckTest { public RegexpHeaderCheckTest ( ) { } @ Test public void testSetHeaderNull ( ) { RegexpHeaderCheck instance = new RegexpHeaderCheck ( ) ; String header = null ; instance . setHeader ( header ) ; } @ Test public void testSetHeaderEmpty ( ) { RegexpHeaderCheck instance = new RegexpHeaderCheck ( ) ; instance = new RegexpHeaderCheck ( ) ; String header = "" ; instance . setHeader ( header ) ; } @ Test public void testSetHeaderSimple ( ) { RegexpHeaderCheck instance = new RegexpHeaderCheck ( ) ; instance = new RegexpHeaderCheck ( ) ; String header = "abc.*" ; instance . setHeader ( header ) ; } @ Test public void testSetHeader ( ) { RegexpHeaderCheck instance = new RegexpHeaderCheck ( ) ; String header = "^/**\\n * Licensed to the Apache Software Foundation (ASF)" ; try { instance . setHeader ( header ) ; Assert . fail ( String . format ( "%s should have been thrown" , ConversionException . class ) ) ; } catch ( ConversionException ex ) { } } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . sizes . LineLengthCheck . MSG_KEY ; public class LineLengthCheckTest extends BaseCheckTestSupport { @ Test public void testSimple ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( LineLengthCheck . class ) ; checkConfig . addAttribute ( "max" , "80" ) ; checkConfig . addAttribute ( "ignorePattern" , "^.*is OK.*regexp.*$" ) ; final String [ ] expected = { "18: " + getCheckMessage ( MSG_KEY , 80 , 81 ) , "145: " + getCheckMessage ( MSG_KEY , 80 , 83 ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void shouldLogActualLineLength ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( LineLengthCheck . class ) ; checkConfig . addAttribute ( "max" , "80" ) ; checkConfig . addAttribute ( "ignorePattern" , "^.*is OK.*regexp.*$" ) ; checkConfig . addMessage ( "maxLineLen" , "{0},{1}" ) ; final String [ ] expected = { "18: 80,81" , "145: 80,83" , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import static com . puppycrawl . tools . checkstyle . checks . sizes . MethodLengthCheck . MSG_KEY ; import static org . junit . Assert . assertArrayEquals ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; public class MethodLengthCheckTest extends BaseCheckTestSupport { @ Test public void testGetAcceptableTokens ( ) { MethodLengthCheck methodLengthCheckObj = new MethodLengthCheck ( ) ; int [ ] actual = methodLengthCheckObj . getAcceptableTokens ( ) ; int [ ] expected = { TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , } ; assertArrayEquals ( expected , actual ) ; } @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodLengthCheck . class ) ; checkConfig . addAttribute ( "max" , "19" ) ; final String [ ] expected = { "79:5: " + getCheckMessage ( MSG_KEY , 20 , 19 ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testcountEmpty ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodLengthCheck . class ) ; checkConfig . addAttribute ( "max" , "19" ) ; checkConfig . addAttribute ( "countEmpty" , "false" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testAbstract ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodLengthCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputModifier.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import static org . junit . Assert . fail ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . sizes . FileLengthCheck . MSG_KEY ; public class FileLengthCheckTest extends BaseCheckTestSupport { @ Override protected DefaultConfiguration createCheckerConfig ( Configuration aCheckConfig ) { DefaultConfiguration dc = new DefaultConfiguration ( "root" ) ; dc . addChild ( aCheckConfig ) ; return dc ; } @ Test public void testAlarm ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( FileLengthCheck . class ) ; checkConfig . addAttribute ( "max" , "20" ) ; final String [ ] expected = { "1: " + getCheckMessage ( MSG_KEY , 225 , 20 ) , } ; verify ( createChecker ( checkConfig ) , getPath ( "InputSimple.java" ) , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testOK ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( FileLengthCheck . class ) ; checkConfig . addAttribute ( "max" , "2000" ) ; final String [ ] expected = { } ; verify ( createChecker ( checkConfig ) , getPath ( "InputSimple.java" ) , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testArgs ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FileLengthCheck . class ) ; try { checkConfig . addAttribute ( "max" , "abc" ) ; createChecker ( checkConfig ) ; fail ( "Should indicate illegal args" ) ; } catch ( CheckstyleException ex ) { } } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import static com . puppycrawl . tools . checkstyle . checks . sizes . ParameterNumberCheck . MSG_KEY ; import static org . junit . Assert . assertArrayEquals ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; public class ParameterNumberCheckTest extends BaseCheckTestSupport { @ Test public void testGetAcceptableTokens ( ) { ParameterNumberCheck paramNumberCheckObj = new ParameterNumberCheck ( ) ; int [ ] actual = paramNumberCheckObj . getAcceptableTokens ( ) ; int [ ] expected = { TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , } ; assertArrayEquals ( expected , actual ) ; } @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParameterNumberCheck . class ) ; final String [ ] expected = { "194:10: " + getCheckMessage ( MSG_KEY , 7 , 9 ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testNum ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParameterNumberCheck . class ) ; checkConfig . addAttribute ( "max" , "2" ) ; final String [ ] expected = { "71:9: " + getCheckMessage ( MSG_KEY , 2 , 3 ) , "194:10: " + getCheckMessage ( MSG_KEY , 2 , 9 ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void shouldLogActualParameterNumber ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParameterNumberCheck . class ) ; checkConfig . addMessage ( "maxParam" , "{0},{1}" ) ; final String [ ] expected = { "194:10: 7,9" , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void shouldIgnoreMethodsWithOverrideAnnotation ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParameterNumberCheck . class ) ; checkConfig . addAttribute ( "ignoreOverriddenMethods" , "true" ) ; final String [ ] expected = { "6:10: " + getCheckMessage ( MSG_KEY , 7 , 8 ) , "11:10: " + getCheckMessage ( MSG_KEY , 7 , 8 ) , } ; verify ( checkConfig , getPath ( "InputParameterNumberCheck.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import nl . jqno . equalsverifier . EqualsVerifier ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; public class LineColumnTest { @ Test public void testCompareToBothEqual ( ) { assertEquals ( 0 , new LineColumn ( 0 , 0 ) . compareTo ( new LineColumn ( 0 , 0 ) ) ) ; } @ Test public void testCompareToFirstLarger ( ) { LineColumn lineColumn = new LineColumn ( 0 , 0 ) ; assertEquals ( 1 , new LineColumn ( 1 , 0 ) . compareTo ( lineColumn ) ) ; assertEquals ( 1 , new LineColumn ( 0 , 1 ) . compareTo ( lineColumn ) ) ; } @ Test public void testCompareToFirstSmaller ( ) { Comparable < LineColumn > lineColumn = new LineColumn ( 0 , 0 ) ; assertEquals ( - 1 , lineColumn . compareTo ( new LineColumn ( 1 , 0 ) ) ) ; assertEquals ( - 1 , lineColumn . compareTo ( new LineColumn ( 0 , 1 ) ) ) ; } @ Test public void testEqualsAndHashCode ( ) { EqualsVerifier . forClass ( LineColumn . class ) . usingGetClass ( ) . verify ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; public enum MethodCountCheckInput2 { RED { @ Override void something ( ) { } ; } , BLUE { @ Override void something ( ) { } ; protected void other1 ( ) { } ; private void other2 ( ) { } ; } ; @ Override public String toString ( ) { return "" ; } ; abstract void something ( ) ; }
package com . puppycrawl . tools . checkstyle . checks . sizes ; public class MethodCountCheckInput { public class PublicMethodsInnerclassInnerclass { public void doNothing50 ( ) { } public void doNothing51 ( ) { } public void doNothing52 ( ) { } public void doNothing53 ( ) { } public void doNothing54 ( ) { } } public interface PublicMethodsInnerInterface { public void doNothing60 ( ) ; public void doNothing61 ( ) ; public abstract void doNothing62 ( ) ; abstract void doNothing63 ( ) ; void doNothing64 ( ) ; } public void doNothing00 ( ) { } public void doNothing01 ( ) { } public void doNothing02 ( ) { } public void doNothing03 ( ) { } public void doNothing04 ( ) { } protected void doNothing10 ( ) { } protected void doNothing11 ( ) { } protected void doNothing12 ( ) { } protected void doNothing13 ( ) { } protected void doNothing14 ( ) { } void doNothing20 ( ) { } void doNothing21 ( ) { } void doNothing22 ( ) { } void doNothing23 ( ) { } void doNothing24 ( ) { } private void doNothing30 ( ) { } private void doNothing31 ( ) { } private void doNothing32 ( ) { } private void doNothing33 ( ) { } private void doNothing34 ( ) { } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import static com . puppycrawl . tools . checkstyle . checks . sizes . MethodCountCheck . MSG_MANY_METHODS ; import static com . puppycrawl . tools . checkstyle . checks . sizes . MethodCountCheck . MSG_PACKAGE_METHODS ; import static com . puppycrawl . tools . checkstyle . checks . sizes . MethodCountCheck . MSG_PRIVATE_METHODS ; import static com . puppycrawl . tools . checkstyle . checks . sizes . MethodCountCheck . MSG_PROTECTED_METHODS ; import static com . puppycrawl . tools . checkstyle . checks . sizes . MethodCountCheck . MSG_PUBLIC_METHODS ; import static org . junit . Assert . assertArrayEquals ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; public class MethodCountCheckTest extends BaseCheckTestSupport { @ Test public void testGetAcceptableTokens ( ) { MethodCountCheck methodCountCheckObj = new MethodCountCheck ( ) ; int [ ] actual = methodCountCheckObj . getAcceptableTokens ( ) ; int [ ] expected = { TokenTypes . CLASS_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . ENUM_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . METHOD_DEF , } ; assertArrayEquals ( expected , actual ) ; } @ Test public void testDefaults ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodCountCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getSrcPath ( "checks/sizes/MethodCountCheckInput.java" ) , expected ) ; } @ Test public void testThrees ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodCountCheck . class ) ; checkConfig . addAttribute ( "maxPrivate" , "3" ) ; checkConfig . addAttribute ( "maxPackage" , "3" ) ; checkConfig . addAttribute ( "maxProtected" , "3" ) ; checkConfig . addAttribute ( "maxPublic" , "3" ) ; checkConfig . addAttribute ( "maxTotal" , "3" ) ; final String [ ] expected = { "3: " + getCheckMessage ( MSG_PACKAGE_METHODS , 5 , 3 ) , "3: " + getCheckMessage ( MSG_PRIVATE_METHODS , 5 , 3 ) , "3: " + getCheckMessage ( MSG_PROTECTED_METHODS , 5 , 3 ) , "3: " + getCheckMessage ( MSG_PUBLIC_METHODS , 5 , 3 ) , "3: " + getCheckMessage ( MSG_MANY_METHODS , 20 , 3 ) , "9: " + getCheckMessage ( MSG_PUBLIC_METHODS , 5 , 3 ) , "9: " + getCheckMessage ( MSG_MANY_METHODS , 5 , 3 ) , "45: " + getCheckMessage ( MSG_PUBLIC_METHODS , 5 , 3 ) , "45: " + getCheckMessage ( MSG_MANY_METHODS , 5 , 3 ) , } ; verify ( checkConfig , getSrcPath ( "checks/sizes/MethodCountCheckInput.java" ) , expected ) ; } @ Test public void testEnum ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodCountCheck . class ) ; checkConfig . addAttribute ( "maxPrivate" , "0" ) ; checkConfig . addAttribute ( "maxTotal" , "2" ) ; final String [ ] expected = { "9: " + getCheckMessage ( MSG_PRIVATE_METHODS , 1 , 0 ) , "9: " + getCheckMessage ( MSG_MANY_METHODS , 3 , 2 ) , } ; verify ( checkConfig , getSrcPath ( "checks/sizes/MethodCountCheckInput2.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import static com . puppycrawl . tools . checkstyle . checks . sizes . ExecutableStatementCountCheck . MSG_KEY ; import antlr . CommonHiddenStreamToken ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; public class ExecutableStatementCountCheckTest extends BaseCheckTestSupport { @ Test public void testMaxZero ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ExecutableStatementCountCheck . class ) ; checkConfig . addAttribute ( "max" , "0" ) ; final String [ ] expected = { "4:5: " + getCheckMessage ( MSG_KEY , 3 , 0 ) , "7:17: " + getCheckMessage ( MSG_KEY , 1 , 0 ) , "17:5: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , "27:5: " + getCheckMessage ( MSG_KEY , 1 , 0 ) , "34:5: " + getCheckMessage ( MSG_KEY , 3 , 0 ) , "48:5: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , "58:5: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , "67:5: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , "76:5: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , "79:13: " + getCheckMessage ( MSG_KEY , 1 , 0 ) , } ; verify ( checkConfig , getPath ( "ExecutableStatementCountInput.java" ) , expected ) ; } @ Test public void testMethodDef ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ExecutableStatementCountCheck . class ) ; checkConfig . addAttribute ( "max" , "0" ) ; checkConfig . addAttribute ( "tokens" , "METHOD_DEF" ) ; final String [ ] expected = { "4:5: " + getCheckMessage ( MSG_KEY , 3 , 0 ) , "7:17: " + getCheckMessage ( MSG_KEY , 1 , 0 ) , "17:5: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , "27:5: " + getCheckMessage ( MSG_KEY , 1 , 0 ) , "34:5: " + getCheckMessage ( MSG_KEY , 3 , 0 ) , "79:13: " + getCheckMessage ( MSG_KEY , 1 , 0 ) , } ; verify ( checkConfig , getPath ( "ExecutableStatementCountInput.java" ) , expected ) ; } @ Test public void testCtorDef ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ExecutableStatementCountCheck . class ) ; checkConfig . addAttribute ( "max" , "0" ) ; checkConfig . addAttribute ( "tokens" , "CTOR_DEF" ) ; final String [ ] expected = { "48:5: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , "76:5: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , } ; verify ( checkConfig , getPath ( "ExecutableStatementCountInput.java" ) , expected ) ; } @ Test public void testStaticInit ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ExecutableStatementCountCheck . class ) ; checkConfig . addAttribute ( "max" , "0" ) ; checkConfig . addAttribute ( "tokens" , "STATIC_INIT" ) ; final String [ ] expected = { "58:5: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , } ; verify ( checkConfig , getPath ( "ExecutableStatementCountInput.java" ) , expected ) ; } @ Test public void testInstanceInit ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ExecutableStatementCountCheck . class ) ; checkConfig . addAttribute ( "max" , "0" ) ; checkConfig . addAttribute ( "tokens" , "INSTANCE_INIT" ) ; final String [ ] expected = { "67:5: " + getCheckMessage ( MSG_KEY , 2 , 0 ) , } ; verify ( checkConfig , getPath ( "ExecutableStatementCountInput.java" ) , expected ) ; } @ Test ( expected = IllegalStateException . class ) public void testVisitTokenWhithWrongTokenType ( ) { ExecutableStatementCountCheck checkObj = new ExecutableStatementCountCheck ( ) ; DetailAST ast = new DetailAST ( ) ; ast . initialize ( new CommonHiddenStreamToken ( TokenTypes . ENUM , "ENUM" ) ) ; checkObj . visitToken ( ast ) ; } @ Test ( expected = IllegalStateException . class ) public void testLeaveTokenWithWrongTokenType ( ) { ExecutableStatementCountCheck checkObj = new ExecutableStatementCountCheck ( ) ; DetailAST ast = new DetailAST ( ) ; ast . initialize ( new CommonHiddenStreamToken ( TokenTypes . ENUM , "ENUM" ) ) ; checkObj . leaveToken ( ast ) ; } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import static com . puppycrawl . tools . checkstyle . checks . sizes . OuterTypeNumberCheck . MSG_KEY ; import static org . junit . Assert . assertArrayEquals ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; public class OuterTypeNumberCheckTest extends BaseCheckTestSupport { @ Test public void testGetAcceptableTokens ( ) { OuterTypeNumberCheck outerTypeNumberObj = new OuterTypeNumberCheck ( ) ; int [ ] actual = outerTypeNumberObj . getAcceptableTokens ( ) ; int [ ] expected = { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , } ; assertArrayEquals ( expected , actual ) ; } @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OuterTypeNumberCheck . class ) ; final String [ ] expected = { "6:1: " + getCheckMessage ( MSG_KEY , 3 , 1 ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testMax30 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OuterTypeNumberCheck . class ) ; checkConfig . addAttribute ( "max" , "30" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testWithInnerClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OuterTypeNumberCheck . class ) ; checkConfig . addAttribute ( "max" , "1" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "OuterTypeNumberCheckInput.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import static com . puppycrawl . tools . checkstyle . checks . sizes . AnonInnerLengthCheck . MSG_KEY ; import static org . junit . Assert . assertArrayEquals ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Test ; public class AnonInnerLengthCheckTest extends BaseCheckTestSupport { @ Test public void testGetAcceptableTokens ( ) { AnonInnerLengthCheck anonInnerLengthCheckObj = new AnonInnerLengthCheck ( ) ; int [ ] actual = anonInnerLengthCheckObj . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . LITERAL_NEW } ; assertArrayEquals ( expected , actual ) ; } @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AnonInnerLengthCheck . class ) ; final String [ ] expected = { "50:35: " + getCheckMessage ( MSG_KEY , 21 , 20 ) , } ; verify ( checkConfig , getPath ( "InputAnonInnerLength.java" ) , expected ) ; } @ Test public void testNonDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AnonInnerLengthCheck . class ) ; checkConfig . addAttribute ( "max" , "6" ) ; final String [ ] expected = { "50:35: " + getCheckMessage ( MSG_KEY , 21 , 6 ) , "75:35: " + getCheckMessage ( MSG_KEY , 20 , 6 ) , } ; verify ( checkConfig , getPath ( "InputAnonInnerLength.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle ; public class InputUncommentedMain { public static void main ( String [ ] args ) { System . out . println ( "InputUncommentedMain.main()" ) ; } } class Main1 { public static void main ( String [ ] args ) { System . out . println ( "Main.main()" ) ; } } class UncommentedMainTest1 { public static void main ( java . lang . String [ ] args ) { System . out . println ( "test1.main()" ) ; } } class UncommentedMainTest2 { public static void main ( int args ) { System . out . println ( "test2.main()" ) ; } } class UncommentedMainTest3 { static void main ( String [ ] args ) { System . out . println ( "test3.main()" ) ; } } class UncommentedMainTest4 { public void main ( String [ ] args ) { System . out . println ( "test4.main()" ) ; } } class UncommentedMainTest5 { public static int main ( String [ ] args ) { System . out . println ( "test5.main()" ) ; return 1 ; } } class UncommentedMainTest6 { public static void main ( String [ ] args , int param ) { System . out . println ( "test6.main()" ) ; } } class UncommentedMainTest7 { public static void main ( ) { System . out . println ( "test7.main()" ) ; } }
package com . puppycrawl . tools . checkstyle ; import java . math . BigDecimal ; import java . util . Collection ; import java . util . List ; import com . google . common . collect . ImmutableSet ; public final class InputImmutable { public final int someIntValue ; public final ImmutableSet < String > includes ; public final ImmutableSet < String > excludes ; public final java . lang . String notes ; public final BigDecimal value ; public final List list ; public InputImmutable ( Collection < String > includes , Collection < String > excludes , BigDecimal value , String notes , int someValue , List l ) { this . includes = ImmutableSet . copyOf ( includes ) ; this . excludes = ImmutableSet . copyOf ( excludes ) ; this . value = value ; this . notes = notes ; this . someIntValue = someValue ; this . list = l ; } final class Immutable { public final float f = 4 ; public final boolean bool = false ; public final java . net . URI uri = null ; public final java . io . File file = null ; public int value = 42 ; public final java . net . URL url = null ; public boolean bValue = false ; public java . lang . Long longValue = 1L ; } }
package com . puppycrawl . tools . checkstyle ; @ TestClassAnnotation class InputRightCurlyAnnotations { private static final int X = 10 ; @ Deprecated @ Override public boolean equals ( Object other ) { return false ; } @ Override public String toString ( ) { return "InputRightCurlyAnnotations{}" ; } public String foo ( ) { return "foo" ; } @ Override @ SuppressWarnings ( "unused" ) public int hashCode ( ) { int a = 10 ; return 1 ; } }
package com . puppycrawl . tools . checkstyle ; import javax . swing . AbstractAction ; import javax . swing . Action ; import java . awt . event . ActionEvent ; class InputFinalParameters { InputFinalParameters ( ) { } InputFinalParameters ( String s ) { } InputFinalParameters ( final Integer i ) { } InputFinalParameters ( final @ MyAnnotation3 Class i ) { } InputFinalParameters ( @ MyAnnotation3 Boolean i ) { } InputFinalParameters ( String s , final Integer i ) { } void method ( ) { } void method ( String s ) { } void method ( final Integer i ) { } void method ( @ MyAnnotation3 final Object s ) { } void method ( @ MyAnnotation3 Class s ) { } void method ( String s , final Integer i ) { } interface TestInterface { void method ( String s ) ; } void holder ( ) { Action a = new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { } void somethingElse ( @ MyAnnotation3 ActionEvent e ) { } } ; Action b = new AbstractAction ( ) { public void actionPerformed ( final ActionEvent e ) { } void somethingElse ( @ MyAnnotation3 final ActionEvent e ) { } } ; } void methodA ( java . lang . String aParam ) { } void methodB ( String [ ] args ) { } void methodC ( java . lang . String [ ] args ) { } void method1 ( ) { try { System . err . println ( "" ) ; } catch ( java . lang . NullPointerException npe ) { npe . printStackTrace ( ) ; } catch ( @ MyAnnotation3 final ClassCastException e ) { e . printStackTrace ( ) ; } catch ( RuntimeException e ) { e . printStackTrace ( ) ; } catch ( @ MyAnnotation3 NoClassDefFoundError e ) { e . printStackTrace ( ) ; } } } abstract class AbstractClass { public abstract void abstractMethod ( int aParam ) ; } class Foo { public void Bar ( ) { for ( String s : someExpression ( ) ) { } for ( final String s : someExpression ( ) ) { } for ( @ MyAnnotation3 String s : someExpression ( ) ) { } for ( @ MyAnnotation3 final String s : someExpression ( ) ) { } } private String [ ] someExpression ( ) { return null ; } } @ interface MyAnnotation3 { }
package com . puppycrawl . tools . checkstyle . api ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; public class AutomaticBeanTest { private static class TestBean extends AutomaticBean { public void setName ( String name ) { } } private final DefaultConfiguration conf = new DefaultConfiguration ( "testConf" ) ; private final TestBean testBean = new TestBean ( ) ; @ Test ( expected = CheckstyleException . class ) public void testNoSuchAttribute ( ) throws CheckstyleException { conf . addAttribute ( "NonExisting" , "doesn't matter" ) ; testBean . configure ( conf ) ; } }
package com . puppycrawl . tools . checkstyle ; abstract class CharSequenceReader { abstract void moveTo ( double deltaX , double deltaY ) ; void foo ( ) { while ( true ) ; } }
package com . puppycrawl . tools . checkstyle ; class InputInner { class InnerInner2 { public int fData ; } interface InnerInterface2 { String data = "zxzc" ; class InnerInterfaceInnerClass { public int rData ; protected int protectedVariable ; int packageVariable ; } } protected static Object sWeird = new Object ( ) ; static Object sWeird2 = new Object ( ) ; public interface Inter { } public static void main ( ) { Inter m = new Inter ( ) { private static final int CDS = 1 ; private int ABC ; } ; } @ interface InnerAnnotation { String data = "zxzc" ; } enum InnerEnum { A , B ; public int someValue ; } }
package com . puppycrawl . tools . checkstyle ; public class InputPublicOnly { private interface InnerInterface { String CONST = "InnerInterface" ; void method ( ) ; class InnerInnerClass { private int mData ; private InnerInnerClass ( ) { final Runnable r = new Runnable ( ) { public void run ( ) { } ; } ; } void method2 ( ) { final Runnable r = new Runnable ( ) { public void run ( ) { } ; } ; } } } private class InnerClass { private int mDiff ; void method ( ) { } } private int mSize ; int mLen ; protected int mDeer ; public int aFreddo ; private InputPublicOnly ( int aA ) { } InputPublicOnly ( String aA ) { } protected InputPublicOnly ( Object aA ) { } public InputPublicOnly ( Class aA ) { } private void method ( int aA ) { } void method ( Long aA ) { } protected void method ( Class aA ) { } public void method ( StringBuffer aA ) { } private void method ( String aA ) { } public class InnerWithoutAuthor { } public String toString ( ) { return super . toString ( ) ; } @ Deprecated @ Override public int hashCode ( ) { return super . hashCode ( ) ; } }
package com . puppycrawl . tools . checkstyle ; public class InetSocketAddress { class Arrays { } }
package com . puppycrawl . tools . checkstyle ; public interface InputNewlineLfAtEndOfFile { }
package com . puppycrawl . tools . checkstyle ; public class InputRegexpSmallHeader { }
package com . puppycrawl . tools . checkstyle ; public class InputScopeInnerClasses { public class InnerPublic { protected class InnerProtected { class InnerPackage { private class InnerPrivate { class PrivateHiddenPackage { } protected class PrivateHiddenProtected { } public class PrivateHiddenPublic { } } } } } }
package com . puppycrawl . tools . checkstyle ; public class InputFinalClass { private InputFinalClass ( ) { } } final class test2 { } class test3 { class test4 { private test4 ( ) { } } } class test5 { private test5 ( ) { } test5 ( int i ) { } } class test6 { public test6 ( ) { } } abstract class Operation { abstract double eval ( double a , double b ) ; public static final Operation PLUS = new Operation ( "+" ) { double eval ( double a , double b ) { return a + b ; } } ; public static final Operation MINUS = new Operation ( "-" ) { double eval ( double a , double b ) { return a - b ; } } ; private String _name ; private Operation ( String name ) { this . _name = name ; } } interface Evaluatable { double eval ( double a , double b ) ; } abstract class Operation2 implements Evaluatable { public static final Operation2 PLUS = new Operation2 ( "+" ) { public double eval ( double a , double b ) { return a + b ; } } ; public static final Operation2 MINUS = new Operation2 ( "-" ) { public double eval ( double a , double b ) { return a - b ; } } ; private String _name ; private Operation2 ( String name ) { this . _name = name ; } } enum testenum1 { A , B ; testenum1 ( ) { } } enum testenum2 { A , B ; public static class someinnerClass { private someinnerClass ( ) { } } }
package com . puppycrawl . tools . checkstyle ; class InputNestedBlocks { static { } public void method ( ) { int x = 0 ; { int z = 1 ; int y = z ; } if ( x == 1 ) { x = 2 ; } switch ( x ) { case 0 : x = 3 ; break ; case 1 : { x = 1 ; } break ; case 2 : { x = 1 ; break ; } case 3 : default : System . out . println ( "Hello" ) ; { x = 2 ; } } } }
package com . puppycrawl . tools . checkstyle ; import java . io . * ; import java . awt . Dimension ; import java . awt . Color ; class InputSemantic { static { Boolean x = new Boolean ( true ) ; } { Boolean x = new Boolean ( true ) ; Boolean [ ] y = new Boolean [ ] { Boolean . TRUE , Boolean . FALSE } ; } Boolean getBoolean ( ) { return new java . lang . Boolean ( true ) ; } void otherInstantiations ( ) { Object o1 = new InputBraces ( ) ; Object o2 = new InputModifier ( ) ; ByteArrayOutputStream s = new ByteArrayOutputStream ( ) ; File f = new File ( "/tmp" ) ; Dimension dim = new Dimension ( ) ; Color col = new Color ( 0 , 0 , 0 ) ; } void exHandlerTest ( ) { try { ; } catch ( IllegalStateException emptyCatchIsAlwaysAnError ) { } catch ( NullPointerException ex ) { } catch ( ArrayIndexOutOfBoundsException ex ) { ; } catch ( NegativeArraySizeException ex ) { { } } catch ( UnsupportedOperationException handledException ) { System . out . println ( handledException . getMessage ( ) ) ; } catch ( SecurityException ex ) { } catch ( StringIndexOutOfBoundsException ex ) { } catch ( IllegalArgumentException ex ) { } try { } finally { } try { } finally { } try { ; } finally { ; } } private static final long IGNORE = 666l + 666L ; public class EqualsVsHashCode1 { public boolean equals ( int a ) { return a == 1 ; } } public class EqualsVsHashCode2 { public boolean equals ( String a ) { return true ; } } public class EqualsVsHashCode3 { public boolean equals ( Object a ) { return true ; } public int hashCode ( ) { return 0 ; } } public class EqualsVsHashCode4 { ByteArrayOutputStream bos1 = new ByteArrayOutputStream ( ) { public boolean equals ( Object a ) { return true ; } public int hashCode ( ) { return 0 ; } } ; ByteArrayOutputStream bos2 = new ByteArrayOutputStream ( ) { public boolean equals ( Object a ) { return true ; } } ; } public void triggerEmptyBlockWithoutBlock ( ) { if ( true ) return ; } { } public class EqualsVsHashCode5 { public < A > boolean equals ( int a ) { return a == 1 ; } } public class EqualsVsHashCode6 { public < A > boolean equals ( Comparable < A > a ) { return true ; } } private class InputBraces { } private class InputModifier { } synchronized void foo ( ) { synchronized ( this ) { } synchronized ( Class . class ) { synchronized ( new Object ( ) ) { } } } }
package com . puppycrawl . tools . checkstyle . api ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; public class JavadocTokenTypesTest { @ Test public void testIsProperUtilsClass ( ) throws ReflectiveOperationException { assertUtilsClassHasPrivateConstructor ( JavadocTokenTypes . class ) ; } }
package com . puppycrawl . tools . checkstyle ; public class InputEmptyStatement { public InputEmptyStatement ( ) { ; } public void EmptyMethod ( ) { ; } public void EmptyStatements ( boolean cond ) { for ( ; cond ; ) ; for ( ; cond ; ) { ; } if ( true ) ; if ( true ) { ; } if ( cond ) { int i ; } else { ; } switch ( 1 ) { case 1 : ; default : ; } while ( cond ) ; while ( cond ) { ; } do ; while ( cond ) ; do { ; } while ( cond ) ; try { ; } catch ( Exception ex ) { ; } finally { ; } } }
package com . puppycrawl . tools . checkstyle ; public class InputJavadocStyleCheck { private String first ; private String second ; public InputJavadocStyleCheck ( ) { } private void method1 ( ) { } private void method2 ( ) { } private void method3 ( ) { } private void method4 ( ) { } private void method5 ( int arg1 ) { } protected void method6 ( ) { } void method7 ( ) { } public void method8 ( ) { } public void method9 ( ) { } private void method10 ( ) { } private void method11 ( ) { } private void method12 ( ) { } private void method13 ( ) { } private void method14 ( ) { } private void method15 ( ) { } public static final int dummy = 4911 ; public void method16 ( ) { } protected void method17 ( String a ) { } void method18 ( String a ) { } private static int ASDF = 0 ; public void method19 ( ) { } public enum Test { value1 , value2 , } public class TestClass < T1 , KEY_T > { public T1 getX ( ) { return null ; } public < V > V getY ( ) { return null ; } public < KEY_T1 > KEY_T getZ_1649020_1 ( ) { return null ; } public < KEY_T_$_1_t > KEY_T_$_1_t getEh_1649020_2 ( ) { return null ; } public < $_12_xY_z > $_12_xY_z getUmmm_1649020_3 ( ) { return null ; } } public void foo_1291847_1 ( ) { } public void foo_1291847_2 ( ) { } public void method20 ( ) { } public void method21 ( ) { } }
package com . puppycrawl . tools . checkstyle ; class InputJavadoc { } class InputJavadoc1 { } class InputJavadoc2 { } class InputJavadocType { } enum InputJavadocEnum { } enum InputJavadocEnum1 { } enum InputJavadocEnum2 { } @ interface InputJavadocInterfaceType { } @ interface InputJavadocInterface { } @ interface InputJavadocInterface1 { } @ interface InputJavadocInterface2 { } @ interface InputJavadocInterfaceType1 { }
package com . puppycrawl . tools . checkstyle ; public class InputScopeInnerInterfaces { private interface PrivateInterface { public String CA = "CONST A" ; String CB = "CONST b" ; public void ma ( ) ; void mb ( ) ; } interface PackageInnerInterface { public String CA = "CONST A" ; String CB = "CONST b" ; public void ma ( ) ; void mb ( ) ; } protected interface ProtectedInnerInterface { public String CA = "CONST A" ; String CB = "CONST b" ; public void ma ( ) ; void mb ( ) ; } public interface PublicInnerInterface { public String CA = "CONST A" ; String CB = "CONST b" ; public void ma ( ) ; void mb ( ) ; } private class MyClass1 { } class MyClass2 { } private interface MyInterface1 { } interface MyInterface2 { } protected enum MyEnum { } private @ interface MyAnnotation { } }
package com . puppycrawl . tools . checkstyle ; class inputHeader { }
package com . puppycrawl . tools . checkstyle ; class InputInterfaceIsType { interface OK { void method ( ) ; } interface Marker { } interface ConstantPool { boolean BAD = true ; } }
package com . puppycrawl . tools . checkstyle ; import org . junit . rules . TemporaryFolder ; import com . puppycrawl . tools . checkstyle . LocalAnnotations . Rule ; public class AnnotatedVisibilitySameTypeName { @ Rule public TemporaryFolder publicJUnitRule = new TemporaryFolder ( ) ; }
package com . puppycrawl . tools . checkstyle ; import java . awt . event . MouseEvent ; import java . awt . event . MouseAdapter ; import javax . swing . JButton ; public class InputScopeAnonInner { private JButton mButton = new JButton ( ) ; private Runnable mRunnable = new Runnable ( ) { public void run ( ) { System . out . println ( "running" ) ; } } ; InputScopeAnonInner ( ) { mButton . addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent aEv ) { System . out . println ( "click" ) ; } } ) ; } public void addInputAnonInner ( ) { mButton . addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent aEv ) { System . out . println ( "click" ) ; } } ) ; } }
package com . puppycrawl . tools . checkstyle ; public class InputIllegalTokens { public void methodWithPreviouslyIllegalTokens ( ) { int i = 0 ; switch ( i ) { default : i -- ; i ++ ; break ; } } public native void nativeMethod ( ) ; public void methodWithLiterals ( ) { final String ref = "<a href=\"" ; final String refCase = "<A hReF=\"" ; } public void methodWithLabels ( ) { label : { anotherLabel : do { continue anotherLabel ; } while ( false ) ; break label ; } } }
package com . puppycrawl . tools . checkstyle ; public class ComplexityCheckTestInput { public void foo ( ) { while ( true ) { Runnable runnable = new Runnable ( ) { public void run ( ) { while ( true ) { } } } ; new Thread ( runnable ) . start ( ) ; } } public void bar ( ) { if ( System . currentTimeMillis ( ) == 0 ) { if ( System . currentTimeMillis ( ) == 0 && System . currentTimeMillis ( ) == 0 ) { } if ( System . currentTimeMillis ( ) == 0 || System . currentTimeMillis ( ) == 0 ) { } } } public void simpleElseIf ( ) { if ( System . currentTimeMillis ( ) == 0 ) { } else if ( System . currentTimeMillis ( ) == 0 ) { } else { } } public void stupidElseIf ( ) { if ( System . currentTimeMillis ( ) == 0 ) { } else { if ( System . currentTimeMillis ( ) == 0 ) { } else { if ( System . currentTimeMillis ( ) == 0 ) { } } if ( System . currentTimeMillis ( ) == 0 ) { } } } public ComplexityCheckTestInput ( ) { int i = 1 ; if ( System . currentTimeMillis ( ) == 0 ) { } else if ( System . currentTimeMillis ( ) == 0 ) { } else { } } static { int i = 1 ; if ( System . currentTimeMillis ( ) == 0 ) { } else if ( System . currentTimeMillis ( ) == 0 ) { } else { } } { int i = 1 ; if ( System . currentTimeMillis ( ) == 0 ) { } else if ( System . currentTimeMillis ( ) == 0 ) { } else { } } public ComplexityCheckTestInput ( int aParam ) { Runnable runnable = new Runnable ( ) { public void run ( ) { while ( true ) { } } } ; new Thread ( runnable ) . start ( ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import java . util . Locale ; import org . junit . Test ; public class SeverityLevelTest { @ Test ( expected = IllegalArgumentException . class ) public void testMisc ( ) { final SeverityLevel o = SeverityLevel . getInstance ( "info" ) ; assertNotNull ( o ) ; assertEquals ( "info" , o . toString ( ) ) ; assertEquals ( "info" , o . getName ( ) ) ; SeverityLevel . getInstance ( "unknown" ) ; } @ Test public void testMixedCaseSpaces ( ) { SeverityLevel . getInstance ( "IgnoRe " ) ; SeverityLevel . getInstance ( " iNfo" ) ; SeverityLevel . getInstance ( " WarniNg" ) ; SeverityLevel . getInstance ( " ERROR " ) ; } @ Test public void testMixedCaseSpacesWithDifferentLocales ( ) { Locale [ ] differentLocales = new Locale [ ] { new Locale ( "TR" , "tr" ) } ; Locale defaultLocale = Locale . getDefault ( ) ; try { for ( Locale differentLocale : differentLocales ) { Locale . setDefault ( differentLocale ) ; testMixedCaseSpaces ( ) ; } } finally { Locale . setDefault ( defaultLocale ) ; } } }
package com . puppycrawl . tools . checkstyle ; import java . util . Collection ; import java . util . Map ; public class InputGenerics < A , B extends Collection < ? > , C extends D & E , F extends Collection < ? extends InputGenerics [ ] > > { } class BadCommas < A , B , C extends Map < A , String > > { private java . util . Hashtable < Integer , D > p = new java . util . Hashtable < Integer , D > ( ) ; } class Wildcard { public static void foo ( Collection < ? extends Wildcard [ ] > collection ) { collection . size ( ) ; } } interface D { } interface E { }
package com . puppycrawl . tools . checkstyle ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; import java . util . ArrayList ; import java . util . List ; class InputLeftCurlyLineBreakAfter { int foo ( ) throws InterruptedException { int x = 1 ; int a = 2 ; while ( true ) { try { if ( x > 0 ) { break ; } else if ( x < 0 ) { ; } else { break ; } switch ( a ) { case 0 : break ; default : break ; } } catch ( Exception e ) { break ; } finally { break ; } } synchronized ( this ) { do { x = 2 ; } while ( x == 2 ) ; } synchronized ( this ) { do { } while ( x == 2 ) ; } for ( int k = 0 ; k < 1 ; k ++ ) { String innerBlockVariable = "" ; } for ( int k = 0 ; k < 1 ; k ++ ) { } return a ; } static { int x = 1 ; } void method2 ( ) { boolean flag = false ; if ( flag ) { System . err . println ( "foo" ) ; } } } class Absent_CustomFieldSerializer1 { public static void serialize ( ) { } } class Absent_CustomFieldSerializer2 { public Absent_CustomFieldSerializer2 ( ) { } } class EmptyClass1 { } interface EmptyInterface1 { } enum KnownOrder { KNOWN_ORDER , UNKNOWN_ORDER }
package com . puppycrawl . tools . checkstyle ; class InputLeftCurlyMethod { InputLeftCurlyMethod ( ) { } InputLeftCurlyMethod ( String aOne ) { } InputLeftCurlyMethod ( int aOne ) { } void method1 ( ) { } void method2 ( ) { } void method3 ( ) { } void method4 ( ) { } void method5 ( String aOne , String aTwo ) { } void method6 ( String aOne , String aTwo ) { } } enum InputLeftCurlyMethodEnum { CONSTANT1 ( "hello" ) { void method1 ( ) { } void method2 ( ) { } void method3 ( ) { } void method4 ( ) { } void method5 ( String aOne , String aTwo ) { } void method6 ( String aOne , String aTwo ) { } } , CONSTANT2 ( "hello" ) { } , CONSTANT3 ( "hellohellohellohellohellohellohellohellohellohellohellohellohellohello" ) { } ; private InputLeftCurlyMethodEnum ( String value ) { } void method1 ( ) { } void method2 ( ) { } void method3 ( ) { } void method4 ( ) { } void method5 ( String aOne , String aTwo ) { } void method6 ( String aOne , String aTwo ) { } }
package com . puppycrawl . tools . checkstyle ; import com . google . common . annotations . VisibleForTesting ; import org . junit . Rule ; import org . junit . rules . TemporaryFolder ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; public class AnnotatedVisibility { @ Rule public TemporaryFolder publicJUnitRule = new TemporaryFolder ( ) ; @ org . junit . Rule public TemporaryFolder fqPublicJUnitRule = new TemporaryFolder ( ) ; @ VisibleForTesting public String googleCommonsAnnotatedPublic ; @ VisibleForTesting String googleCommonsAnnotatedPackage ; @ VisibleForTesting protected String googleCommonsAnnotatedProtected ; @ com . google . common . annotations . VisibleForTesting public String fqGoogleCommonsAnnotatedPublic ; @ com . google . common . annotations . VisibleForTesting String fqGoogleCommonsAnnotatedPackage ; @ com . google . common . annotations . VisibleForTesting protected String fqGoogleCommonsAnnotatedProtected ; @ CustomAnnotation public String customAnnotatedPublic ; @ CustomAnnotation String customAnnotatedPackage ; @ CustomAnnotation protected String customAnnotatedProtected ; public String unannotatedPublic ; String unannotatedPackage ; protected String unannotatedProtected ; private String unannotatedPrivate ; @ Retention ( value = RetentionPolicy . RUNTIME ) @ Target ( value = { ElementType . FIELD } ) public @ interface CustomAnnotation { } }
package com . puppycrawl . tools . checkstyle ; import java . io . * ; final class InputSimple { public static final int badConstant = 2 ; public static final int MAX_ROWS = 2 ; private static int badStatic = 2 ; private static int sNumCreated = 0 ; private int badMember = 2 ; private int mNumCreated1 = 0 ; protected int mNumCreated2 = 0 ; private int [ ] mInts = new int [ ] { 1 , 2 , 3 , 4 } ; public static int sTest1 ; protected static int sTest3 ; static int sTest2 ; int mTest1 ; public int mTest2 ; int test1 ( int badFormat1 , int badFormat2 , final int badFormat3 ) throws java . lang . Exception { return 0 ; } private void longMethod ( ) { } private InputSimple ( ) { } private void localVariables ( ) { int abc = 0 ; int ABC = 0 ; final int cde = 0 ; final int CDE = 0 ; for ( int k = 0 ; k < 1 ; k ++ ) { String innerBlockVariable = "" ; } for ( int I = 0 ; I < 1 ; I ++ ) { String InnerBlockVariable = "" ; } } void ALL_UPPERCASE_METHOD ( ) { } private static final int BAD__NAME = 3 ; void errorColumnAfterTabs ( ) { int tab0 = 1 ; int tab1 = 1 ; int tab2 = 1 ; int tab3 = 1 ; int tab4 = 1 ; int tab5 = 1 ; } void veryLong ( ) { } void toManyArgs ( int aArg1 , int aArg2 , int aArg3 , int aArg4 , int aArg5 , int aArg6 , int aArg7 , int aArg8 , int aArg9 ) { } } class InputSimple2 { public void doSomething ( ) { for ( Object O : new java . util . ArrayList ( ) ) { } } } enum MyEnum1 { ABC , XYZ ; private int someMember ; }
package com . puppycrawl . tools . checkstyle ;
package com . puppycrawl . tools . checkstyle ; public interface InputNoNewlineAtEndOfFile { }
package com . puppycrawl . tools . checkstyle ; import java . awt . * ; public class InputRegexpHeader1 { }
package com . puppycrawl . tools . checkstyle ; public class ExecutableStatementCountInput { public void foo ( ) { while ( true ) { Runnable runnable = new Runnable ( ) { public void run ( ) { while ( true ) { } } } ; new Thread ( runnable ) . start ( ) ; } } public void bar ( ) { if ( System . currentTimeMillis ( ) == 0 ) { if ( System . currentTimeMillis ( ) == 0 && System . currentTimeMillis ( ) == 0 ) { } if ( System . currentTimeMillis ( ) == 0 || System . currentTimeMillis ( ) == 0 ) { } } } public void simpleElseIf ( ) { if ( System . currentTimeMillis ( ) == 0 ) { } else if ( System . currentTimeMillis ( ) == 0 ) { } else { } } public void stupidElseIf ( ) { if ( System . currentTimeMillis ( ) == 0 ) { } else { if ( System . currentTimeMillis ( ) == 0 ) { } else { if ( System . currentTimeMillis ( ) == 0 ) { } } if ( System . currentTimeMillis ( ) == 0 ) { } } } public ExecutableStatementCountInput ( ) { int i = 1 ; if ( System . currentTimeMillis ( ) == 0 ) { } else if ( System . currentTimeMillis ( ) == 0 ) { } else { } } static { int i = 1 ; if ( System . currentTimeMillis ( ) == 0 ) { } else if ( System . currentTimeMillis ( ) == 0 ) { } else { } } { int i = 1 ; if ( System . currentTimeMillis ( ) == 0 ) { } else if ( System . currentTimeMillis ( ) == 0 ) { } else { } } public ExecutableStatementCountInput ( int aParam ) { Runnable runnable = new Runnable ( ) { public void run ( ) { while ( true ) { } } } ; new Thread ( runnable ) . start ( ) ; } public ExecutableStatementCountInput ( String someString ) { } }
package com . puppycrawl . tools . checkstyle ; class InputLeftCurlyOther { int foo ( ) throws InterruptedException { int x = 1 ; int a = 2 ; while ( true ) { try { if ( x > 0 ) { break ; } else if ( x < 0 ) { ; } else { break ; } switch ( a ) { case 0 : break ; default : break ; } } catch ( Exception e ) { break ; } finally { break ; } } synchronized ( this ) { do { x = 2 ; } while ( x == 2 ) ; } this . wait ( 666 ) ; for ( int k = 0 ; k < 1 ; k ++ ) { String innerBlockVariable = "" ; } if ( System . currentTimeMillis ( ) > 1000 ) return 1 ; else return 2 ; } static { int x = 1 ; } public enum GreetingsEnum { HELLO , GOODBYE } ; void method2 ( ) { boolean flag = true ; if ( flag ) { System . out . println ( "heh" ) ; flag = ! flag ; } System . err . println ( "Xe-xe" ) ; if ( flag ) { System . err . println ( "it is ok." ) ; } } } class FooCtor { int i ; public FooCtor ( ) { i = 1 ; } } class FooMethod { public void fooMethod ( ) { int i = 1 ; } } class FooInner { class InnerFoo { public void fooInnerMethod ( ) { } } } class Absent_CustomFieldSerializer3 { public static void serialize ( ) { } } class Absent_CustomFieldSerializer4 { public Absent_CustomFieldSerializer4 ( ) { } } class EmptyClass2 { } interface EmptyInterface3 { } class ClassWithStaticInitializers { static { } static { } static class Inner { static { int i = 1 ; } } }
package com . puppycrawl . tools . checkstyle . api ; import static org . junit . Assert . assertEquals ; import java . util . SortedSet ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Assert ; import org . junit . Test ; public class AbstractViolationReporterTest extends BaseCheckTestSupport { private final Check emptyCheck = new Check ( ) { @ Override public int [ ] getDefaultTokens ( ) { return new int [ 0 ] ; } } ; @ Test public void testGetMessageBundleWithPackage ( ) { assertEquals ( "com.mycompany.checks.messages" , emptyCheck . getMessageBundle ( "com.mycompany.checks.MyCoolCheck" ) ) ; } @ Test public void testGetMessageBundleWithoutPackage ( ) { assertEquals ( "messages" , emptyCheck . getMessageBundle ( "MyCoolCheck" ) ) ; } @ Test public void testCustomMessage ( ) throws Exception { DefaultConfiguration config = createCheckConfig ( emptyCheck . getClass ( ) ) ; config . addMessage ( "msgKey" , "This is a custom message." ) ; emptyCheck . configure ( config ) ; LocalizedMessages collector = new LocalizedMessages ( ) ; emptyCheck . setMessages ( collector ) ; emptyCheck . log ( 0 , "msgKey" ) ; SortedSet < LocalizedMessage > messages = collector . getMessages ( ) ; Assert . assertTrue ( messages . size ( ) == 1 ) ; Assert . assertEquals ( "This is a custom message." , messages . first ( ) . getMessage ( ) ) ; } @ Test public void testCustomMessageWithParameters ( ) throws Exception { DefaultConfiguration config = createCheckConfig ( emptyCheck . getClass ( ) ) ; config . addMessage ( "msgKey" , "This is a custom message with {0}." ) ; emptyCheck . configure ( config ) ; LocalizedMessages collector = new LocalizedMessages ( ) ; emptyCheck . setMessages ( collector ) ; emptyCheck . log ( 0 , "msgKey" , "TestParam" ) ; SortedSet < LocalizedMessage > messages = collector . getMessages ( ) ; Assert . assertTrue ( messages . size ( ) == 1 ) ; Assert . assertEquals ( "This is a custom message with TestParam." , messages . first ( ) . getMessage ( ) ) ; } @ Test ( expected = IllegalArgumentException . class ) public void testCustomMessageWithParametersNegative ( ) throws Exception { DefaultConfiguration config = createCheckConfig ( emptyCheck . getClass ( ) ) ; config . addMessage ( "msgKey" , "This is a custom message {0." ) ; emptyCheck . configure ( config ) ; LocalizedMessages collector = new LocalizedMessages ( ) ; emptyCheck . setMessages ( collector ) ; emptyCheck . log ( 0 , "msgKey" , "TestParam" ) ; SortedSet < LocalizedMessage > messages = collector . getMessages ( ) ; Assert . assertTrue ( messages . size ( ) == 1 ) ; messages . first ( ) . getMessage ( ) ; } }
package com . puppycrawl . tools . checkstyle ; public class InputBracesSingleLineStatements { private static class SomeClass { boolean flag = true ; private static boolean test ( boolean k ) { return k ; } } private int foo ( ) { if ( SomeClass . test ( true ) == true ) return 4 ; return 0 ; } private int foo1 ( ) { if ( SomeClass . test ( true ) == true ) return 4 ; int k = 3 ; return 0 ; } private int foo2 ( ) { if ( SomeClass . test ( true ) == true ) return 4 ; return 0 ; } private int foo3 ( ) { if ( SomeClass . test ( true ) == true ) if ( true ) return 4 ; return 0 ; } private void foo ( Object o ) { if ( o != null ) this . notify ( ) ; } private void foo2 ( Object o ) { if ( o != null ) this . notify ( ) ; } private void loopTest ( Object o ) { while ( o != null ) { this . notify ( ) ; } while ( o != null ) this . notify ( ) ; while ( o != null ) this . notify ( ) ; do { this . notify ( ) ; } while ( o != null ) ; do this . notify ( ) ; while ( o != null ) ; do this . notify ( ) ; while ( o != null ) ; for ( int i = 0 ; i < 10 ; i ++ ) { this . notify ( ) ; } for ( int i = 0 ; i < 10 ; i ++ ) this . notify ( ) ; for ( int i = 0 ; ; ) this . notify ( ) ; } private int getSmth ( int num ) { int counter = 0 ; switch ( num ) { case 1 : counter ++ ; break ; case 2 : counter += 2 ; break ; case 3 : counter += 3 ; break ; case 6 : counter += 10 ; break ; default : counter = 100 ; break ; } return counter ; } private void testElse ( int k ) { if ( k == 4 ) System . out . println ( "yes" ) ; else System . out . println ( "no" ) ; for ( ; ; ) ; } private int testMissingWarnings ( ) { if ( true ) throw new RuntimeException ( ) ; if ( true ) { return 1 ; } else return 2 ; } }
package com . puppycrawl . tools . checkstyle ; class InputParameterNumberCheckBase { void myMethod ( int a , int b , int c , int d , int e , int f , int g , int h ) { } void myMethod2 ( int a , int b , int c , int d , int e , int f , int g , int h ) { } } public class InputParameterNumberCheck extends InputParameterNumberCheckBase { @ Override void myMethod ( int a , int b , int c , int d , int e , int f , int g , int h ) { } @ java . lang . Override void myMethod2 ( int a , int b , int c , int d , int e , int f , int g , int h ) { } }
package com . puppycrawl . tools . checkstyle ; class InputWriteTag { public InputWriteTag ( ) { } public void method ( ) { } public void anotherMethod ( ) { } }
package com . puppycrawl . tools . checkstyle ; import java . io . * ; import java . util . * ; class StringEntrySet { private final Set < Map . Entry < Integer , Integer > > s ; public StringEntrySet ( Set < Map . Entry < Integer , Integer > > s ) { this . s = s ; } public Iterator < Map . Entry < String , String > > iterator ( ) { return new Iterator < Map . Entry < String , String > > ( ) { Iterator < Map . Entry < Integer , Integer > > i = s . iterator ( ) ; public boolean hasNext ( ) { return i . hasNext ( ) ; } public Map . Entry < String , String > next ( ) { return null ; } public void remove ( ) { i . remove ( ) ; } } ; } }
package com . puppycrawl . tools . checkstyle ; import java . io . IOException ; public class InputEmptyCatchBlockCheck { private void foo ( ) { try { throw new RuntimeException ( ) ; } catch ( Exception expected ) { } } private void foo1 ( ) { try { throw new RuntimeException ( ) ; } catch ( Exception e ) { } } private void foo2 ( ) { try { throw new IOException ( ) ; } catch ( IOException | NullPointerException | ArithmeticException ignore ) { } } private void foo3 ( ) { try { throw new IOException ( ) ; } catch ( IOException | NullPointerException | ArithmeticException e ) { } } private void foo4 ( ) { try { throw new IOException ( ) ; } catch ( IOException | NullPointerException | ArithmeticException e ) { } } private void foo5 ( ) { try { throw new IOException ( ) ; } catch ( IOException | NullPointerException | ArithmeticException e ) { } } private void foo6 ( ) { try { throw new IOException ( ) ; } catch ( IOException expected ) { int k = 0 ; } } public void testTryCatch ( ) { try { int y = 0 ; int u = 8 ; int e = u - y ; return ; } catch ( Exception e ) { System . out . println ( e ) ; return ; } finally { return ; } } public void testTryCatch2 ( ) { try { } catch ( Exception e ) { } finally { } } public void testTryCatch3 ( ) { try { int y = 0 ; int u = 8 ; int e = u - y ; } catch ( IllegalArgumentException e ) { System . out . println ( e ) ; return ; } catch ( IllegalStateException ex ) { System . out . println ( ex ) ; return ; } } public void testTryCatch4 ( ) { int y = 0 ; int u = 8 ; try { int e = u - y ; } catch ( IllegalArgumentException e ) { System . out . println ( e ) ; return ; } } public void setFormats ( ) { try { int k = 4 ; } catch ( Exception e ) { Object k = null ; if ( k != null ) k = "ss" ; else { return ; } } } public void setFormats1 ( ) { try { int k = 4 ; } catch ( Exception e ) { Object k = null ; if ( k != null ) { k = "ss" ; } else { return ; } } } public void setFormats2 ( ) { try { int k = 4 ; } catch ( Exception e ) { Object k = null ; if ( k != null ) { k = "ss" ; return ; } } } public void setFormats3 ( ) { try { int k = 4 ; } catch ( Exception e ) { Object k = null ; if ( k != null ) { k = "ss" ; } } } private void some ( ) { try { throw new IOException ( ) ; } catch ( IOException e ) { } } private void some1 ( ) { try { throw new IOException ( ) ; } catch ( IOException e ) { } } private void some2 ( ) { try { throw new IOException ( ) ; } catch ( IOException e ) { } } private void some3 ( ) { try { throw new IOException ( ) ; } catch ( IOException e ) { } } private void some4 ( ) { try { throw new IOException ( ) ; } catch ( IOException e ) { } } private void some5 ( ) { try { throw new IOException ( ) ; } catch ( IOException e ) { } } }
package com . puppycrawl . tools . checkstyle ; public abstract class InputDesignForExtension { public interface InterfaceOK { void implicitlyAbstract ( ) ; } final class ClassOK { protected void finalThroughClassDef ( ) { System . out . println ( "no way to override" ) ; } } protected void nonFinalButEmpty ( ) { } public void nonFinalButEmpty2 ( ) { } private void aPrivateMethod ( ) { System . out . println ( "no way to override" ) ; } protected abstract void nonFinalButAbstract ( ) ; protected void doh ( ) { System . out . println ( "nonempty and overriding possible" ) ; } public native void aNativeMethod ( ) ; public final void aFinalMethod ( ) { System . out . println ( "no way to override" ) ; } public static void aStaticMethod ( ) { System . out . println ( "no way to override" ) ; } private class MyComparator implements java . util . Comparator { public int compare ( Object o1 , Object o2 ) { if ( o1 . hashCode ( ) > o2 . hashCode ( ) ) { return - 1 ; } else { return 1 ; } } } public final class aFinalClass { public void someMethod ( ) { System . out . println ( "nonempty and overriding is possible" ) ; } } public class nonFinalClass { private nonFinalClass ( ) { } public void someMethod ( ) { System . out . println ( "nonempty and overriding is possible" ) ; } } public class anotherNonFinalClass { public anotherNonFinalClass ( ) { } public void someMethod ( ) { System . out . println ( "nonempty and overriding is possible" ) ; } } public enum TEnum { FIRST , SECOND ; public int value ( ) { return 3 ; } } }
package com . puppycrawl . tools . checkstyle ; public class LocalAnnotations { public @ interface Rule { } }
package com . puppycrawl . tools . checkstyle ; import java . math . BigDecimal ; import java . util . Collection ; import java . util . List ; import com . google . common . collect . ImmutableSet ; public class InputPublicImmutable { public final int someIntValue ; public final ImmutableSet < String > includes ; public final java . lang . String notes ; public final BigDecimal value ; public final List list ; public InputPublicImmutable ( Collection < String > includes , BigDecimal value , String notes , int someValue , List l ) { this . includes = ImmutableSet . copyOf ( includes ) ; this . value = value ; this . notes = notes ; this . someIntValue = someValue ; this . list = l ; } }
package com . puppycrawl . tools . checkstyle ; public class InputTrailingComment { int i ; int j ; void method1 ( ) { Runnable r = ( new Runnable ( ) { public void run ( ) { } } ) ; } void method2 ( long ms ) { int z ; int y ; } final static public String NAME = "Some Name" ; }
package com . puppycrawl . tools . checkstyle ; import java . util . concurrent . TimeUnit ; public class InputAvoidEscapedUnicodeCharactersCheck { private String unitAbbrev2 = "\u03bcs" ; private String unitAbbrev3 = "\u03bcs" ; private String unitAbbrev4 = "\u03bcs" ; public Object fooString ( ) { String unitAbbrev = "Î¼s" ; String unitAbbrev2 = "\u03bcs" ; String unitAbbrev3 = "\u03bcs" ; String fakeUnicode = "asd\tsasd" ; String fakeUnicode2 = "\\u23\\u123i\\u" ; String content = null ; return "\ufeff" + content ; } public Object fooChar ( ) { char unitAbbrev2 = '\u03bc' ; char unitAbbrev3 = '\u03bc' ; char content = 0 ; return '\ufeff' + content ; } public void multiplyString ( ) { String unitAbbrev2 = "asd\u03bcsasd" ; String unitAbbrev3 = "aBc\u03bcssdf\u03bc" ; String unitAbbrev4 = "\u03bcaBc\u03bcssdf\u03bc" ; String allCharactersEscaped = "\u03bc\u03bc" ; } private static String abbreviate ( TimeUnit unit ) { switch ( unit ) { case NANOSECONDS : return "ns" ; case MICROSECONDS : return "\u03bcs" ; case MILLISECONDS : return "ms" ; case SECONDS : return "s" ; case MINUTES : return "min" ; case HOURS : return "h" ; case DAYS : return "d" ; default : throw new AssertionError ( ) ; } } static final String WHITESPACE_TABLE = "" + "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\\" + "\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680" + "\u0009\u0020\u2006\u2001\u202F\u00A0\u000C\u2009" + "\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000" ; public boolean matches ( char c ) { switch ( c ) { case '\t' : case '\n' : case '\013' : case '\f' : case '\r' : case ' ' : case '\u0085' : case '\u1680' : case '\u2028' : case '\u2029' : case '\u205f' : case '\u3000' : return true ; case '\u2007' : return false ; default : return c >= '\u2000' && c <= '\u200a' ; } } }
package com . puppycrawl . tools . checkstyle . comments ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . BLOCK_COMMENT_BEGIN ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . BLOCK_COMMENT_END ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . CLASS_DEF ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . COMMENT_CONTENT ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . IDENT ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . LCURLY ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . LITERAL_CLASS ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . LITERAL_PROTECTED ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . LITERAL_PUBLIC ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . LPAREN ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . METHOD_DEF ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . MODIFIERS ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . OBJBLOCK ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . PARAMETERS ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . RCURLY ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . RPAREN ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . SINGLE_LINE_COMMENT ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . SLIST ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . TYPE ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . PACKAGE_DEF ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . ANNOTATIONS ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . DOT ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . SEMI ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . LITERAL_RETURN ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . EXPR ; import static com . puppycrawl . tools . checkstyle . api . TokenTypes . LITERAL_NULL ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class CommentsTest extends BaseCheckTestSupport { private static final String LINE_SEPARATOR = System . getProperty ( "line.separator" ) ; private static DetailAST buildInput_1 ( ) { DetailAST packageDef = new DetailAST ( ) ; packageDef . setType ( PACKAGE_DEF ) ; packageDef . setText ( "package" ) ; packageDef . setLineNo ( 1 ) ; packageDef . setColumnNo ( 0 ) ; DetailAST annotationsDef = new DetailAST ( ) ; annotationsDef . setType ( ANNOTATIONS ) ; annotationsDef . setText ( "ANNOTATIONS" ) ; annotationsDef . setLineNo ( 1 ) ; annotationsDef . setColumnNo ( 39 ) ; DetailAST dotDef = new DetailAST ( ) ; dotDef . setType ( DOT ) ; dotDef . setText ( "." ) ; dotDef . setLineNo ( 1 ) ; dotDef . setColumnNo ( 39 ) ; DetailAST subDotDef = new DetailAST ( ) ; subDotDef . setType ( DOT ) ; subDotDef . setText ( "." ) ; subDotDef . setLineNo ( 1 ) ; subDotDef . setColumnNo ( 28 ) ; DetailAST subDotDef1 = new DetailAST ( ) ; subDotDef1 . setType ( DOT ) ; subDotDef1 . setText ( "." ) ; subDotDef1 . setLineNo ( 1 ) ; subDotDef1 . setColumnNo ( 22 ) ; DetailAST subDotDef2 = new DetailAST ( ) ; subDotDef2 . setType ( DOT ) ; subDotDef2 . setText ( "." ) ; subDotDef2 . setLineNo ( 1 ) ; subDotDef2 . setColumnNo ( 11 ) ; DetailAST identDef = new DetailAST ( ) ; identDef . setType ( IDENT ) ; identDef . setText ( "com" ) ; identDef . setLineNo ( 1 ) ; identDef . setColumnNo ( 8 ) ; DetailAST identDef2 = new DetailAST ( ) ; identDef2 . setType ( IDENT ) ; identDef2 . setText ( "puppycrawl" ) ; identDef2 . setLineNo ( 1 ) ; identDef2 . setColumnNo ( 12 ) ; DetailAST identDef3 = new DetailAST ( ) ; identDef3 . setType ( IDENT ) ; identDef3 . setText ( "tools" ) ; identDef3 . setLineNo ( 1 ) ; identDef3 . setColumnNo ( 23 ) ; DetailAST semiDef = new DetailAST ( ) ; semiDef . setType ( SEMI ) ; semiDef . setText ( ";" ) ; semiDef . setLineNo ( 1 ) ; semiDef . setColumnNo ( 48 ) ; DetailAST identDef4 = new DetailAST ( ) ; identDef4 . setType ( IDENT ) ; identDef4 . setText ( "checkstyle" ) ; identDef4 . setLineNo ( 1 ) ; identDef4 . setColumnNo ( 29 ) ; DetailAST identDef5 = new DetailAST ( ) ; identDef5 . setType ( IDENT ) ; identDef5 . setText ( "comments" ) ; identDef5 . setLineNo ( 1 ) ; identDef5 . setColumnNo ( 40 ) ; DetailAST classDef = new DetailAST ( ) ; classDef . setType ( CLASS_DEF ) ; classDef . setText ( "CLASS_DEF" ) ; classDef . setLineNo ( 2 ) ; classDef . setColumnNo ( 0 ) ; DetailAST modifiers = new DetailAST ( ) ; modifiers . setType ( MODIFIERS ) ; modifiers . setText ( "MODIFIERS" ) ; modifiers . setLineNo ( 2 ) ; modifiers . setColumnNo ( 0 ) ; DetailAST literalPublic = new DetailAST ( ) ; literalPublic . setType ( LITERAL_PUBLIC ) ; literalPublic . setText ( "public" ) ; literalPublic . setLineNo ( 2 ) ; literalPublic . setColumnNo ( 0 ) ; DetailAST literalClass = new DetailAST ( ) ; literalClass . setType ( LITERAL_CLASS ) ; literalClass . setText ( "class" ) ; literalClass . setLineNo ( 2 ) ; literalClass . setColumnNo ( 7 ) ; DetailAST blockCommentStart = new DetailAST ( ) ; blockCommentStart . setType ( BLOCK_COMMENT_BEGIN ) ; blockCommentStart . setText ( "/*" ) ; blockCommentStart . setLineNo ( 2 ) ; blockCommentStart . setColumnNo ( 13 ) ; DetailAST blockCommentContent = new DetailAST ( ) ; blockCommentContent . setType ( COMMENT_CONTENT ) ; blockCommentContent . setText ( LINE_SEPARATOR + " i'mcomment567" + LINE_SEPARATOR + " " ) ; blockCommentContent . setLineNo ( 2 ) ; blockCommentContent . setColumnNo ( 15 ) ; DetailAST blockCommentEnd = new DetailAST ( ) ; blockCommentEnd . setType ( BLOCK_COMMENT_END ) ; blockCommentEnd . setText ( "*/" ) ; blockCommentEnd . setLineNo ( 4 ) ; blockCommentEnd . setColumnNo ( 4 ) ; DetailAST ident = new DetailAST ( ) ; ident . setType ( IDENT ) ; ident . setText ( "InputCommentsTest_1" ) ; ident . setLineNo ( 5 ) ; ident . setColumnNo ( 0 ) ; DetailAST objBlock = new DetailAST ( ) ; objBlock . setType ( OBJBLOCK ) ; objBlock . setText ( "OBJBLOCK" ) ; objBlock . setLineNo ( 6 ) ; objBlock . setColumnNo ( 0 ) ; DetailAST lcurly = new DetailAST ( ) ; lcurly . setType ( LCURLY ) ; lcurly . setText ( "{" ) ; lcurly . setLineNo ( 6 ) ; lcurly . setColumnNo ( 0 ) ; DetailAST slComment = new DetailAST ( ) ; slComment . setType ( SINGLE_LINE_COMMENT ) ; slComment . setText ( "//" ) ; slComment . setLineNo ( 6 ) ; slComment . setColumnNo ( 2 ) ; DetailAST slCommentContent = new DetailAST ( ) ; slCommentContent . setType ( COMMENT_CONTENT ) ; slCommentContent . setText ( " comment to left curly brace" + LINE_SEPARATOR ) ; slCommentContent . setLineNo ( 6 ) ; slCommentContent . setColumnNo ( 4 ) ; DetailAST rcurly = new DetailAST ( ) ; rcurly . setType ( RCURLY ) ; rcurly . setText ( "}" ) ; rcurly . setLineNo ( 7 ) ; rcurly . setColumnNo ( 0 ) ; packageDef . setFirstChild ( annotationsDef ) ; annotationsDef . setNextSibling ( dotDef ) ; dotDef . setFirstChild ( subDotDef ) ; subDotDef . setFirstChild ( subDotDef1 ) ; subDotDef1 . setFirstChild ( subDotDef2 ) ; subDotDef2 . setFirstChild ( identDef ) ; identDef . setNextSibling ( identDef2 ) ; subDotDef2 . setNextSibling ( identDef3 ) ; subDotDef1 . setNextSibling ( identDef4 ) ; subDotDef . setNextSibling ( identDef5 ) ; dotDef . setNextSibling ( semiDef ) ; packageDef . setNextSibling ( classDef ) ; classDef . setFirstChild ( modifiers ) ; modifiers . setNextSibling ( literalClass ) ; literalClass . setNextSibling ( blockCommentStart ) ; blockCommentStart . setNextSibling ( ident ) ; ident . setNextSibling ( objBlock ) ; modifiers . setFirstChild ( literalPublic ) ; blockCommentStart . setFirstChild ( blockCommentContent ) ; blockCommentContent . setNextSibling ( blockCommentEnd ) ; objBlock . setFirstChild ( lcurly ) ; lcurly . setNextSibling ( slComment ) ; slComment . setNextSibling ( rcurly ) ; slComment . setFirstChild ( slCommentContent ) ; return packageDef ; } private static DetailAST buildInput_2 ( ) { DetailAST packageDef = new DetailAST ( ) ; packageDef . setType ( PACKAGE_DEF ) ; packageDef . setText ( "package" ) ; packageDef . setLineNo ( 1 ) ; packageDef . setColumnNo ( 0 ) ; DetailAST annotationsDef = new DetailAST ( ) ; annotationsDef . setType ( ANNOTATIONS ) ; annotationsDef . setText ( "ANNOTATIONS" ) ; annotationsDef . setLineNo ( 1 ) ; annotationsDef . setColumnNo ( 39 ) ; DetailAST dotDef = new DetailAST ( ) ; dotDef . setType ( DOT ) ; dotDef . setText ( "." ) ; dotDef . setLineNo ( 1 ) ; dotDef . setColumnNo ( 39 ) ; DetailAST subDotDef = new DetailAST ( ) ; subDotDef . setType ( DOT ) ; subDotDef . setText ( "." ) ; subDotDef . setLineNo ( 1 ) ; subDotDef . setColumnNo ( 28 ) ; DetailAST subDotDef1 = new DetailAST ( ) ; subDotDef1 . setType ( DOT ) ; subDotDef1 . setText ( "." ) ; subDotDef1 . setLineNo ( 1 ) ; subDotDef1 . setColumnNo ( 22 ) ; DetailAST subDotDef2 = new DetailAST ( ) ; subDotDef2 . setType ( DOT ) ; subDotDef2 . setText ( "." ) ; subDotDef2 . setLineNo ( 1 ) ; subDotDef2 . setColumnNo ( 11 ) ; DetailAST identDef = new DetailAST ( ) ; identDef . setType ( IDENT ) ; identDef . setText ( "com" ) ; identDef . setLineNo ( 1 ) ; identDef . setColumnNo ( 8 ) ; DetailAST identDef2 = new DetailAST ( ) ; identDef2 . setType ( IDENT ) ; identDef2 . setText ( "puppycrawl" ) ; identDef2 . setLineNo ( 1 ) ; identDef2 . setColumnNo ( 12 ) ; DetailAST identDef3 = new DetailAST ( ) ; identDef3 . setType ( IDENT ) ; identDef3 . setText ( "tools" ) ; identDef3 . setLineNo ( 1 ) ; identDef3 . setColumnNo ( 23 ) ; DetailAST semiDef = new DetailAST ( ) ; semiDef . setType ( SEMI ) ; semiDef . setText ( ";" ) ; semiDef . setLineNo ( 1 ) ; semiDef . setColumnNo ( 48 ) ; DetailAST identDef4 = new DetailAST ( ) ; identDef4 . setType ( IDENT ) ; identDef4 . setText ( "checkstyle" ) ; identDef4 . setLineNo ( 1 ) ; identDef4 . setColumnNo ( 29 ) ; DetailAST identDef5 = new DetailAST ( ) ; identDef5 . setType ( IDENT ) ; identDef5 . setText ( "comments" ) ; identDef5 . setLineNo ( 1 ) ; identDef5 . setColumnNo ( 40 ) ; DetailAST classDef = new DetailAST ( ) ; classDef . setType ( CLASS_DEF ) ; classDef . setText ( "CLASS_DEF" ) ; classDef . setLineNo ( 3 ) ; classDef . setColumnNo ( 0 ) ; DetailAST modifiers = new DetailAST ( ) ; modifiers . setType ( MODIFIERS ) ; modifiers . setText ( "MODIFIERS" ) ; modifiers . setLineNo ( 3 ) ; modifiers . setColumnNo ( 0 ) ; classDef . setFirstChild ( modifiers ) ; DetailAST slComment = new DetailAST ( ) ; slComment . setType ( SINGLE_LINE_COMMENT ) ; slComment . setText ( "//" ) ; slComment . setLineNo ( 2 ) ; slComment . setColumnNo ( 0 ) ; DetailAST slCommentContent = new DetailAST ( ) ; slCommentContent . setType ( COMMENT_CONTENT ) ; slCommentContent . setText ( " my class" + LINE_SEPARATOR ) ; slCommentContent . setLineNo ( 2 ) ; slCommentContent . setColumnNo ( 2 ) ; slComment . setFirstChild ( slCommentContent ) ; modifiers . setNextSibling ( slComment ) ; DetailAST literalClass = new DetailAST ( ) ; literalClass . setType ( LITERAL_CLASS ) ; literalClass . setText ( "class" ) ; literalClass . setLineNo ( 3 ) ; literalClass . setColumnNo ( 0 ) ; slComment . setNextSibling ( literalClass ) ; DetailAST identClassName = new DetailAST ( ) ; identClassName . setType ( IDENT ) ; identClassName . setText ( "InputCommentsTest_2" ) ; identClassName . setLineNo ( 3 ) ; identClassName . setColumnNo ( 6 ) ; literalClass . setNextSibling ( identClassName ) ; DetailAST objBlock = new DetailAST ( ) ; objBlock . setType ( OBJBLOCK ) ; objBlock . setText ( "OBJBLOCK" ) ; objBlock . setLineNo ( 4 ) ; objBlock . setColumnNo ( 0 ) ; identClassName . setNextSibling ( objBlock ) ; DetailAST lcurly = new DetailAST ( ) ; lcurly . setType ( LCURLY ) ; lcurly . setText ( "{" ) ; lcurly . setLineNo ( 4 ) ; lcurly . setColumnNo ( 0 ) ; objBlock . setFirstChild ( lcurly ) ; DetailAST methodDef = new DetailAST ( ) ; methodDef . setType ( METHOD_DEF ) ; methodDef . setText ( "METHOD_DEF" ) ; methodDef . setLineNo ( 10 ) ; methodDef . setColumnNo ( 4 ) ; lcurly . setNextSibling ( methodDef ) ; DetailAST rcurly = new DetailAST ( ) ; rcurly . setType ( RCURLY ) ; rcurly . setText ( "}" ) ; rcurly . setLineNo ( 14 ) ; rcurly . setColumnNo ( 0 ) ; methodDef . setNextSibling ( rcurly ) ; DetailAST methodModifiers = new DetailAST ( ) ; methodModifiers . setType ( MODIFIERS ) ; methodModifiers . setText ( "MODIFIERS" ) ; methodModifiers . setLineNo ( 10 ) ; methodModifiers . setColumnNo ( 4 ) ; methodDef . setFirstChild ( methodModifiers ) ; DetailAST methodType = new DetailAST ( ) ; methodType . setType ( TYPE ) ; methodType . setText ( "TYPE" ) ; methodType . setLineNo ( 10 ) ; methodType . setColumnNo ( 14 ) ; methodModifiers . setNextSibling ( methodType ) ; DetailAST identMethodType = new DetailAST ( ) ; identMethodType . setType ( IDENT ) ; identMethodType . setText ( "String" ) ; identMethodType . setLineNo ( 10 ) ; identMethodType . setColumnNo ( 14 ) ; methodType . setFirstChild ( identMethodType ) ; DetailAST identMethodName = new DetailAST ( ) ; identMethodName . setType ( IDENT ) ; identMethodName . setText ( "line" ) ; identMethodName . setLineNo ( 10 ) ; identMethodName . setColumnNo ( 21 ) ; methodType . setNextSibling ( identMethodName ) ; DetailAST lparen = new DetailAST ( ) ; lparen . setType ( LPAREN ) ; lparen . setText ( "(" ) ; lparen . setLineNo ( 10 ) ; lparen . setColumnNo ( 25 ) ; identMethodName . setNextSibling ( lparen ) ; DetailAST parameters = new DetailAST ( ) ; parameters . setType ( PARAMETERS ) ; parameters . setText ( "PARAMETERS" ) ; parameters . setLineNo ( 10 ) ; parameters . setColumnNo ( 26 ) ; lparen . setNextSibling ( parameters ) ; DetailAST returnDef = new DetailAST ( ) ; returnDef . setType ( LITERAL_RETURN ) ; returnDef . setText ( "return" ) ; returnDef . setLineNo ( 12 ) ; returnDef . setColumnNo ( 2 ) ; DetailAST exprDef = new DetailAST ( ) ; exprDef . setType ( EXPR ) ; exprDef . setText ( "EXPR" ) ; exprDef . setLineNo ( 12 ) ; exprDef . setColumnNo ( 9 ) ; DetailAST nullDef = new DetailAST ( ) ; nullDef . setType ( LITERAL_NULL ) ; nullDef . setText ( "null" ) ; nullDef . setLineNo ( 12 ) ; nullDef . setColumnNo ( 9 ) ; DetailAST rparen = new DetailAST ( ) ; rparen . setType ( RPAREN ) ; rparen . setText ( ")" ) ; rparen . setLineNo ( 10 ) ; rparen . setColumnNo ( 26 ) ; parameters . setNextSibling ( rparen ) ; DetailAST slist = new DetailAST ( ) ; slist . setType ( SLIST ) ; slist . setText ( "{" ) ; slist . setLineNo ( 11 ) ; slist . setColumnNo ( 4 ) ; DetailAST semiDef1 = new DetailAST ( ) ; semiDef1 . setType ( SEMI ) ; semiDef1 . setText ( ";" ) ; semiDef1 . setLineNo ( 12 ) ; semiDef1 . setColumnNo ( 13 ) ; rparen . setNextSibling ( slist ) ; DetailAST methodRcurly = new DetailAST ( ) ; methodRcurly . setType ( RCURLY ) ; methodRcurly . setText ( "}" ) ; methodRcurly . setLineNo ( 13 ) ; methodRcurly . setColumnNo ( 4 ) ; slist . setFirstChild ( returnDef ) ; returnDef . setNextSibling ( methodRcurly ) ; returnDef . setFirstChild ( exprDef ) ; exprDef . setFirstChild ( nullDef ) ; exprDef . setNextSibling ( semiDef1 ) ; DetailAST blockCommentStart = new DetailAST ( ) ; blockCommentStart . setType ( BLOCK_COMMENT_BEGIN ) ; blockCommentStart . setText ( "/*" ) ; blockCommentStart . setLineNo ( 5 ) ; blockCommentStart . setColumnNo ( 4 ) ; DetailAST blockCommentContent = new DetailAST ( ) ; blockCommentContent . setType ( COMMENT_CONTENT ) ; blockCommentContent . setText ( "*" + LINE_SEPARATOR + " * Lines <b>method</b>." + LINE_SEPARATOR + " * " + LINE_SEPARATOR + " * @return string." + LINE_SEPARATOR + " " ) ; blockCommentContent . setLineNo ( 5 ) ; blockCommentContent . setColumnNo ( 6 ) ; blockCommentStart . setFirstChild ( blockCommentContent ) ; DetailAST blockCommentEnd = new DetailAST ( ) ; blockCommentEnd . setType ( BLOCK_COMMENT_END ) ; blockCommentEnd . setText ( "*/" ) ; blockCommentEnd . setLineNo ( 9 ) ; blockCommentEnd . setColumnNo ( 5 ) ; blockCommentContent . setNextSibling ( blockCommentEnd ) ; methodModifiers . setFirstChild ( blockCommentStart ) ; DetailAST literalProtected = new DetailAST ( ) ; literalProtected . setType ( LITERAL_PROTECTED ) ; literalProtected . setText ( "protected" ) ; literalProtected . setLineNo ( 10 ) ; literalProtected . setColumnNo ( 4 ) ; packageDef . setFirstChild ( annotationsDef ) ; annotationsDef . setNextSibling ( dotDef ) ; dotDef . setFirstChild ( subDotDef ) ; subDotDef . setFirstChild ( subDotDef1 ) ; subDotDef1 . setFirstChild ( subDotDef2 ) ; subDotDef2 . setFirstChild ( identDef ) ; identDef . setNextSibling ( identDef2 ) ; subDotDef2 . setNextSibling ( identDef3 ) ; subDotDef1 . setNextSibling ( identDef4 ) ; subDotDef . setNextSibling ( identDef5 ) ; dotDef . setNextSibling ( semiDef ) ; packageDef . setNextSibling ( classDef ) ; blockCommentStart . setNextSibling ( literalProtected ) ; return packageDef ; } @ Test public void testCompareExpectedTreeWithInput_1 ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( CompareTreesWithComments . class ) ; CompareTreesWithComments . expectedTree = buildInput_1 ( ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "comments" + File . separator + "InputCommentsTest_1.java" ) , expected ) ; } @ Test public void testCompareExpectedTreeWithInput_2 ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( CompareTreesWithComments . class ) ; CompareTreesWithComments . expectedTree = buildInput_2 ( ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "comments" + File . separator + "InputCommentsTest_2.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle ; import java . io . * ; import java . awt . Dimension ; import java . awt . Color ; class UpdateClass { public void fooMethod ( ) { int a = 1 ; if ( a == 1 ) { } char [ ] s = { '1' , '2' } ; int index = 2 ; if ( doSideEffect ( ) == 1 ) { } while ( ( a = index - 1 ) != 0 ) { } for ( ; index < s . length && s [ index ] != 'x' ; index ++ ) { } if ( a == 1 ) { } else { System . out . println ( "a" ) ; } switch ( a ) { } switch ( a ) { case 1 : a = 2 ; case 2 : a = 3 ; default : a = 0 ; } } public int doSideEffect ( ) { return 1 ; } }
package com . puppycrawl . tools . checkstyle ; public class OuterTypeNumberCheckInput { private class InnerClass { } }
package com . puppycrawl . tools . checkstyle ; import com . google . common . collect . * ; public final class InputImmutableStarImport2 { public final ImmutableSet < String > set = null ; }
package com . puppycrawl . tools . checkstyle ; import com . puppycrawl . tools . checkstyle . InputImmutable ; import com . puppycrawl . tools . checkstyle . InetSocketAddress . * ; public final class InputImmutableStarImport { public final Arrays f = null ; }
package com . puppycrawl . tools . checkstyle ; class InputHiddenField { private int hidden = 0 ; public InputHiddenField ( ) { int hidden = 0 ; } public InputHiddenField ( int hidden ) { } public void shadow ( ) { int hidden = 0 ; } public void shadowFor ( ) { for ( int hidden = 0 ; hidden < 1 ; hidden ++ ) { } } public void shadowParam ( int hidden ) { } public class Inner { private int innerHidden = 0 ; public Inner ( ) { int innerHidden = 0 ; } public Inner ( int innerHidden ) { } private void innerShadow ( ) { int innerHidden = 0 ; int hidden = 0 ; } private void innerShadowFor ( ) { for ( int innerHidden = 0 ; innerHidden < 1 ; innerHidden ++ ) { } for ( int hidden = 0 ; hidden < 1 ; hidden ++ ) { } } private void shadowParam ( int innerHidden , int hidden ) { } { int innerHidden = 0 ; int hidden = 0 ; } } { int hidden = 0 ; } } interface NothingHidden { public static int notHidden = 0 ; public void noShadow ( int notHidden ) ; } class PropertySetter { private int prop ; public void setProp ( int prop ) { this . prop = prop ; } public void setprop ( int prop ) { this . prop = prop ; } public void setProp ( int prop , int extra ) { this . prop = prop ; } } class PropertySetter2 { private int prop ; public int setProp ( int prop ) { this . prop = prop ; return 0 ; } } class StaticFields { private static int hidden ; public static void staticMethod ( ) { int hidden ; } public void method ( ) { int hidden ; } static { int hidden ; } { int hidden ; } } class StaticMethods { private int notHidden ; public static void method ( ) { int notHidden ; } static { int notHidden ; } private int x ; private static int y ; static class Inner { void useX ( int x ) { x ++ ; } void useY ( int y ) { y ++ ; } } } enum HiddenEnum { A ( 129 ) , B ( 283 ) , C ( 1212 ) { int hidden ; public void doSomething ( ) { int hidden = 0 ; } } ; int hidden ; static int hiddenStatic ; HiddenEnum ( int hidden ) { } public void doSomething ( ) { int hidden = 0 ; } public static void doSomethingStatic ( ) { int hiddenStatic = 0 ; } } abstract class InputHiddenFieldBug1084512 { String x ; public abstract void methodA ( String x ) ; } class Bug3370946 { private int xAxis ; public void setxAxis ( int xAxis ) { this . xAxis = xAxis ; } } class PropertySetter3 { private int prop ; public PropertySetter3 setProp ( int prop ) { this . prop = prop ; return this ; } } enum PropertySetter4 { INSTANCE ; private int prop ; private int prop2 ; public void setProp ( int prop ) { this . prop = prop ; } public PropertySetter4 setProp2 ( int prop2 ) { this . prop2 = prop2 ; return this ; } } class OneLetterField { int i ; void setI ( int i ) { this . i = i ; } }
package com . puppycrawl . tools . checkstyle ; public class InputMissingSwitchDefault { public void foo ( ) { int i = 1 ; switch ( i ) { case 1 : i ++ ; break ; case 2 : i -- ; break ; default : return ; } } } class bad_test { public void foo ( ) { int i = 1 ; switch ( i ) { case 1 : i ++ ; break ; case 2 : i -- ; break ; } } }
package com . puppycrawl . tools . checkstyle ; class InputForWhitespace { void method1 ( ) { for ( int i = 0 ; i < 1 ; i ++ ) { } for ( int i = 0 ; i < 1 ; i ++ ) { } for ( int i = 0 ; i < 1 ; i ++ ) { } for ( int i = 0 ; i < 1 ; i ++ ) { } for ( int i = 0 ; i < 1 ; ) { i ++ ; } for ( int i = 0 ; i < 1 ; ) { i ++ ; } for ( int i = 0 ; i < 1 ; ) { i ++ ; } } void method2 ( ) { for ( int i = 0 ; i < 1 ; i ++ ) { } for ( int i = 0 ; i < 1 ; ) { i ++ ; } int i = 0 ; for ( ; i < 1 ; i ++ ) { } for ( ; i < 2 ; i ++ ) { } } }
package com . puppycrawl . tools . checkstyle ; public class ComplexityOverflow { public void provokeNpathIntegerOverflow ( ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { } } } } } } } } if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { } } } } } } } } if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { } } } } } } } } if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { } } } } } } } } if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { } } } } } } } } if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { } } } } } } } } if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { } } } } } } } } if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { } } } } } } } } if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { } } } } } } } } if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { if ( true ) { } } } } } } } } } }
package com . puppycrawl . tools . checkstyle ; public class InputCovariant { private class Inner { public boolean equals ( Inner aInner ) { return false ; } } private class Inner2 { public boolean equals ( Inner2 aInner2 ) { return false ; } public boolean equals ( Object aObj ) { return false ; } } public boolean equals ( InputCovariant aInputCovariant ) { return false ; } } class InputCovariant2 { public boolean equals ( InputCovariant2 aInputCovariant2 ) { return false ; } public boolean equals ( Object aObject ) { return false ; } } class InputCovariant3 { public boolean equals ( InputCovariant3 aInputCovariant3 ) { return false ; } public boolean equals ( java . lang . Object aObject ) { return false ; } } class InputCovariant4 { public boolean equals ( int i ) { return false ; } } class Anonymous { Comparable comp = new Comparable ( ) { public int compareTo ( Object aObject ) { return 0 ; } public boolean equals ( String aString ) { return false ; } } ; public boolean equals ( Object aObject ) { return false ; } public void method ( ) { Double d = new Double ( 1 ) ; } } abstract class InputCovariant5 { public abstract boolean equals ( InputCovariant4 aInputCovariant4 ) ; } interface InputCovariant6 { public boolean equals ( InputCovariant5 aInputCovariant5 ) ; } class InputGenericCovariant7 { public < A > boolean equals ( InputGenericCovariant7 aInputCovariant7 ) { return true ; } public boolean equals ( Object aObject ) { return false ; } } class InputGenericCovariant8 { public < A > boolean equals ( InputGenericCovariant8 aInputCovariant8 ) { return true ; } public boolean equals ( Object aObject ) { return false ; } } enum InputEnumCovariant { EQUALS ; public boolean equals ( InputEnumCovariant inputEnumCovariant ) { return false ; } int equals ( Integer integer ) { return 0 ; } }
package com . puppycrawl . tools . checkstyle . comments ; import java . io . File ; import java . util . Arrays ; import java . util . Set ; import org . junit . Assert ; import org . junit . Test ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class AllBlockCommentsTest extends BaseCheckTestSupport { protected static final Set < String > allComments = Sets . newLinkedHashSet ( ) ; private static final String LINE_SEPARATOR = System . getProperty ( "line.separator" ) ; public static class BlockCommentListenerCheck extends Check { @ Override public boolean isCommentNodesRequired ( ) { return true ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . BLOCK_COMMENT_BEGIN } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . BLOCK_COMMENT_BEGIN } ; } @ Override public void init ( ) { allComments . addAll ( Arrays . asList ( "0" , "1" , "2" , "3" , "4" , "5" , "6" , "7" , "8" , "9" , "10" , "11" , "12" , "13" , "14" , "15" , "16" , "17" , "18" , "19" , "20" , LINE_SEPARATOR + "21" + LINE_SEPARATOR , "22" , "23" , "24" , "25" , "26" , "27" , "28" , "29" , "30" , "31" , "32" , "33" , "34" , "35" , "36" , "37" , "38" , " 39 " , "40" , "41" , "42" , "43" , "44" , "45" , "46" , "47" , "48" , "49" , "50" , "51" , "52" , "53" , "54" , "55" , "56" , "57" , "58" , "59" , "60" , "61" ) ) ; } @ Override public void visitToken ( DetailAST aAST ) { String commentContent = aAST . getFirstChild ( ) . getText ( ) ; if ( ! allComments . remove ( commentContent ) ) { Assert . fail ( "Unexpected comment: " + commentContent ) ; } } } @ Test public void testAllBlockComments ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( BlockCommentListenerCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "comments" + File . separator + "InputFullOfBlockComments.java" ) , expected ) ; Assert . assertTrue ( allComments . isEmpty ( ) ) ; } }
package com . puppycrawl . tools . checkstyle ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; import java . util . ArrayList ; import java . util . List ; @ TestClassAnnotation class InputLeftCurlyAnnotations { private static final int X = 10 ; @ Override public boolean equals ( Object other ) { return false ; } @ Override @ SuppressWarnings ( "unused" ) public int hashCode ( ) { int a = 10 ; return 1 ; } @ Override @ SuppressWarnings ( { "unused" , "unchecked" , "static-access" } ) public String toString ( ) { Integer i = this . X ; List < String > l = new ArrayList ( ) ; return "SomeString" ; } } @ TestClassAnnotation class InputLeftCurlyAnnotations2 { private static final int X = 10 ; @ Override public boolean equals ( Object other ) { return false ; } @ Override @ SuppressWarnings ( "unused" ) public int hashCode ( ) { int a = 10 ; return 1 ; } @ Override @ SuppressWarnings ( { "unused" , "unchecked" , "static-access" } ) public String toString ( ) { Integer i = this . X ; List < String > l = new ArrayList ( ) ; return "SomeString" ; } } @ Target ( ElementType . TYPE ) @ interface TestClassAnnotation { }
package com . puppycrawl . tools . checkstyle ; import com . puppycrawl . tools . checkstyle . coding . GregorianCalendar ; import com . puppycrawl . tools . checkstyle . InetSocketAddress ; public final class InputImmutableSameTypeName { public final java . util . GregorianCalendar calendar = null ; public final GregorianCalendar calendar2 = null ; public final com . puppycrawl . tools . checkstyle . coding . GregorianCalendar calendar3 = null ; public final InetSocketAddress address = null ; public final java . net . InetSocketAddress adr = null ; }
package com . puppycrawl . tools . checkstyle ; public class InputArrayTrailingComma { int [ ] a1 = new int [ ] { 1 , 2 , 3 , } ; int [ ] a2 = new int [ ] { 1 , 2 , 3 } ; int [ ] b1 = new int [ ] { 1 , 2 , 3 , } ; int [ ] b2 = new int [ ] { 1 , 2 , 3 } ; int [ ] [ ] c1 = new int [ ] [ ] { { 1 , 2 , } , { 3 , 3 , } , { 5 , 6 , } , } ; int [ ] [ ] c2 = new int [ ] [ ] { { 1 , 2 } , { 3 , 3 , } , { 5 , 6 , } } ; int [ ] [ ] d1 = new int [ ] [ ] { { 1 , 2 , } , { 3 , 3 , } , { 5 , 6 , } , } ; int [ ] [ ] d2 = new int [ ] [ ] { { 1 , 2 } , { 3 , 3 , } , { 5 , 6 , } } ; int [ ] e1 = new int [ ] { } ; }
package com . puppycrawl . tools . checkstyle ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Target ( value = ElementType . PACKAGE ) public @ interface MyAnnotation { }
package com . puppycrawl . tools . checkstyle ; strictfp final class InputModifier { static private boolean sModifierOrderVar = false ; strictfp private void doStuff ( ) { } @ MyAnnotation2 void someMethod ( ) { } private @ MyAnnotation2 void someMethod2 ( ) { } private @ MyAnnotation2 strictfp void someMethod3 ( ) { } @ MyAnnotation2 private strictfp void someMethod4 ( ) { } @ MyAnnotation2 private static @ MyAnnotation4 strictfp void someMethod5 ( ) { } public static interface InputRedundantPublicModifier { public void a ( ) ; void b ( ) ; abstract void c ( ) ; public float PI_PUBLIC = ( float ) 3.14 ; final float PI_FINAL = ( float ) 3.14 ; float PI_OK = ( float ) 3.14 ; } private final void method ( ) { } } final class RedundantFinalClass { public final void finalMethod ( ) { } public void method ( ) { } } abstract interface InnerImplementation { InnerImplementation inner = new InnerImplementation ( ) { public void method ( ) { } } ; void method ( ) ; } @ interface Annotation { public String s1 = "" ; final String s2 = "" ; static String s3 = "" ; String s4 = "" ; public String blah ( ) ; abstract String blah2 ( ) ; } @ interface MyAnnotation2 { } @ interface MyAnnotation4 { } class SafeVarargsUsage { @ Deprecated @ SafeVarargs private final void foo ( int ... k ) { } @ Deprecated @ SafeVarargs @ SuppressWarnings ( "" ) private final void foo1 ( Object ... obj ) { } }
package com . puppycrawl . tools . checkstyle ; public class InputMethNameEqualClsName { public int InputMethNameEqualClsName ( ) { return 0 ; } private int PRIVATEInputMethNameEqualClsName ( ) { return 0 ; } class Inner { public int Inner ( ) { return 0 ; } public int InputMethNameEqualClsName ( ) { return 0 ; } } public void anotherMethod ( ) { new InputMethNameEqualClsName ( ) { public int InputMethNameEqualClsName ( ) { return 1 ; } } ; } } interface SweetInterface { int SweetInterface ( ) ; } class Outter { public void Outter ( ) { } }
package com . puppycrawl . tools . checkstyle ; enum InputWriteTag2 { FOO ; } @ interface InputWriteTag3 { int foo ( ) default 0 ; }
package com . puppycrawl . tools . checkstyle ; import java . awt . event . MouseEvent ; import java . awt . event . MouseAdapter ; import javax . swing . JButton ; public class InputAnonInnerLength { private JButton mButton = new JButton ( ) ; private class MyInner { private MyInner ( int [ ] anArray ) { } } private MyInner myInner = new MyInner ( new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , } ) ; private Runnable mRunnable1 = new Runnable ( ) { public void run ( ) { System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; } } ; private Runnable mRunnable2 = new Runnable ( ) { public void run ( ) { System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; System . out . println ( "running" ) ; } } ; InputAnonInnerLength ( ) { mButton . addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent aEv ) { System . out . println ( "click" ) ; } } ) ; } public void addInputAnonInner ( ) { mButton . addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent aEv ) { System . out . println ( "click" ) ; } } ) ; } }
package com . puppycrawl . tools . checkstyle ; public class InputArrayTypeStyle { private int [ ] javaStyle = new int [ 0 ] ; private int cStyle [ ] = new int [ 0 ] ; public static void mainJava ( String [ ] aJavaStyle ) { } public static void mainC ( String aCStyle [ ] ) { final int [ ] blah = new int [ 0 ] ; final boolean isOK1 = aCStyle instanceof String [ ] ; final boolean isOK2 = aCStyle instanceof java . lang . String [ ] ; final boolean isOK3 = blah instanceof int [ ] ; } public class Test { public Test [ ] variable ; public Test [ ] getTests ( ) { return null ; } public Test [ ] getNewTest ( ) { return null ; } } }
package com . puppycrawl . tools . checkstyle . comments ; import java . io . File ; import java . util . Set ; import org . junit . Assert ; import org . junit . Test ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class AllSinglelineCommentsTest extends BaseCheckTestSupport { protected static final Set < String > allComments = Sets . newLinkedHashSet ( ) ; private static final String LINE_SEPARATOR = System . getProperty ( "line.separator" ) ; public static class SinglelineCommentListenerCheck extends Check { @ Override public boolean isCommentNodesRequired ( ) { return true ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . SINGLE_LINE_COMMENT } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . SINGLE_LINE_COMMENT } ; } @ Override public void init ( ) { int lines = 63 ; for ( int i = 0 ; i < lines ; i ++ ) { allComments . add ( i + LINE_SEPARATOR ) ; } allComments . add ( String . valueOf ( lines ) ) ; } @ Override public void visitToken ( DetailAST aAST ) { String commentContent = aAST . getFirstChild ( ) . getText ( ) ; if ( ! allComments . remove ( commentContent ) ) { Assert . fail ( "Unexpected comment: " + commentContent ) ; } } } @ Test public void testAllBlockComments ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( SinglelineCommentListenerCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "comments" + File . separator + "InputFullOfSinglelineComments.java" ) , expected ) ; Assert . assertTrue ( allComments . isEmpty ( ) ) ; } }
package com . puppycrawl . tools . checkstyle ; class InputHiddenFieldReorder { public InputHiddenFieldReorder ( ) { int hidden = 0 ; } public InputHiddenFieldReorder ( int hidden ) { } public void shadow ( ) { int hidden = 0 ; } public void shadowFor ( ) { for ( int hidden = 0 ; hidden < 1 ; hidden ++ ) { } } public void shadowParam ( int hidden ) { } public class Inner { public Inner ( ) { int innerHidden = 0 ; } public Inner ( int innerHidden ) { } private void innerShadow ( ) { int innerHidden = 0 ; int hidden = 0 ; } private void innerShadowFor ( ) { for ( int innerHidden = 0 ; innerHidden < 1 ; innerHidden ++ ) { } for ( int hidden = 0 ; hidden < 1 ; hidden ++ ) { } } private void shadowParam ( int innerHidden , int hidden ) { } { int innerHidden = 0 ; int hidden = 0 ; } private int innerHidden = 0 ; } { int hidden = 0 ; } private int hidden = 0 ; } interface NothingHiddenReorder { public static int notHidden = 0 ; public void noShadow ( int notHidden ) ; } enum HiddenEnum1 { A ( 129 ) , B ( 283 ) , C ( 1212 ) { public void doSomething ( ) { int hidden = 0 ; } int hidden ; } ; HiddenEnum1 ( int hidden ) { } public void doSomething ( ) { int hidden = 0 ; } public static void doSomethingStatic ( ) { int hiddenStatic = 0 ; } int hidden ; static int hiddenStatic ; }
package com . puppycrawl . tools . checkstyle ; class InputBraces { boolean condition ( ) { return false ; } void testDoWhile ( ) { do { testDoWhile ( ) ; } while ( condition ( ) ) ; do testDoWhile ( ) ; while ( condition ( ) ) ; } void testWhile ( ) { while ( condition ( ) ) { testWhile ( ) ; } while ( condition ( ) ) ; while ( condition ( ) ) testWhile ( ) ; while ( condition ( ) ) if ( condition ( ) ) testWhile ( ) ; } void testFor ( ) { for ( int i = 1 ; i < 5 ; i ++ ) { testFor ( ) ; } for ( int i = 1 ; i < 5 ; i ++ ) ; for ( int i = 1 ; i < 5 ; i ++ ) testFor ( ) ; for ( int i = 1 ; i < 5 ; i ++ ) if ( i > 2 ) testFor ( ) ; } public void testIf ( ) { if ( condition ( ) ) { testIf ( ) ; } else if ( condition ( ) ) { testIf ( ) ; } else { testIf ( ) ; } if ( condition ( ) ) ; if ( condition ( ) ) testIf ( ) ; if ( condition ( ) ) testIf ( ) ; else testIf ( ) ; if ( condition ( ) ) testIf ( ) ; else { testIf ( ) ; } if ( condition ( ) ) { testIf ( ) ; } else testIf ( ) ; if ( condition ( ) ) if ( condition ( ) ) testIf ( ) ; } void whitespaceAfterSemi ( ) { int i = 1 ; int j = 2 ; for ( ; ; ) { } } public InputBraces ( ) { } public void emptyImplementation ( ) { } }
package com . puppycrawl . tools . checkstyle ; public class InputTypeParamsTags < A , B1 , C456 extends Comparable > { public < X , Y1 > String doSomething ( ) { return null ; } public < Z > void doSomethingElse ( ) { } public < L > void doSomethingElse2 ( L aAnEl ) { } }
package com . puppycrawl . tools . checkstyle ; public class InputJavadocStyleCheckHtmlComment { private void method1 ( ) { } private void method2 ( ) { } private void method3 ( ) { } private void method4 ( ) { } private void method5 ( ) { } }
package com . puppycrawl . tools . checkstyle ; @ interface MyAnnotation1 { String name ( ) ; int version ( ) ; } @ MyAnnotation1 ( name = "ABC" , version = 1 ) public class Input15Extensions { } enum Enum1 { A , B , C ; Enum1 ( ) { } public String toString ( ) { return "" ; } } interface TestRequireThisEnum { enum DAY_OF_WEEK { SUNDAY , MONDAY , TUESDAY , WEDNESDAY , THURSDAY , FRIDAY , SATURDAY } }
package com . puppycrawl . tools . checkstyle ; class InputOpWrap { void test ( ) { int x = 1 + 2 - 3 - 4 ; x = x + 2 ; boolean y = true && false ; y = true && false ; y = false && true ; } void testAssignment ( ) { int x = 0 ; int y = 0 ; } < T extends Comparable & java . io . Serializable > void testGenerics1 ( ) { Comparable < String > c = new String ( ) ; } } class badCase < T extends Foo & Bar > { } class goodCase < T extends Foo & Bar > { } interface Bar { }
package com . puppycrawl . tools . checkstyle ; import java . awt . * ; public class InputRegexpHeader3 { }
package com . puppycrawl . tools . checkstyle ; public class InputSuppressWarningsHolder { static final String UNUSED = "unused" ; @ SuppressWarnings ( UNUSED ) int a ; @ SuppressWarnings ( InputSuppressWarningsHolder . UNUSED ) int b ; @ SuppressWarnings ( com . puppycrawl . tools . checkstyle . InputSuppressWarningsHolder . UNUSED ) int c ; @ SuppressWarnings ( value = UNUSED ) int d ; @ SuppressWarnings ( value = InputSuppressWarningsHolder . UNUSED ) int e ; @ SuppressWarnings ( value = com . puppycrawl . tools . checkstyle . InputSuppressWarningsHolder . UNUSED ) int f ; @ SuppressWarnings ( ( 1 != 1 ) ? "" : "unused" ) int g ; @ SuppressWarnings ( "un" + "used" ) int h ; @ SuppressWarnings ( ( String ) "unused" ) int i ; @ SuppressWarnings ( { } ) int j ; @ SuppressWarnings ( { UNUSED } ) int k ; @ SuppressWarnings ( { "unused" , true ? "unused" : "" } ) int l ; } class CustomSuppressWarnings { @ SuppressWarnings private @ interface SuppressWarnings { } }
package com . puppycrawl . tools . checkstyle ; public class InputMain { } class InputMainInner { }
package com . puppycrawl . tools . checkstyle ; public interface InputNewlineCrlfAtEndOfFile { }
package com . puppycrawl . tools . checkstyle . comments ; import org . junit . Assert ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class CompareTreesWithComments extends Check { protected static DetailAST expectedTree ; @ Override public boolean isCommentNodesRequired ( ) { return true ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { } ; } @ Override public void beginTree ( DetailAST aRootAST ) { Assert . assertTrue ( isAstEquals ( expectedTree , aRootAST ) ) ; } private boolean isAstEquals ( DetailAST expected , DetailAST actual ) { boolean result = false ; if ( expected == actual ) { result = true ; } else if ( actual == null || expected == null ) { result = false ; } else { if ( expected . getType ( ) == actual . getType ( ) && expected . getLineNo ( ) == actual . getLineNo ( ) && expected . getColumnNo ( ) == actual . getColumnNo ( ) ) { if ( expected . getText ( ) == null ) { result = actual . getText ( ) == null ; } else if ( expected . getText ( ) . equals ( actual . getText ( ) ) ) { result = true ; } } if ( result ) { DetailAST childExpected = expected . getFirstChild ( ) ; DetailAST childActual = actual . getFirstChild ( ) ; result = isAstEquals ( childExpected , childActual ) ; if ( result ) { DetailAST nextSiblingExpected = expected . getNextSibling ( ) ; DetailAST nextSiblingActual = actual . getNextSibling ( ) ; result = isAstEquals ( nextSiblingExpected , nextSiblingActual ) ; } } } if ( ! result ) { System . out . println ( "Expected: " + expected + " | Actual: " + actual ) ; } return result ; } }
package com . puppycrawl . tools . checkstyle ; import org . junit . Rule ; import org . junit . Test ; import org . junit . contrib . java . lang . system . Assertion ; import org . junit . contrib . java . lang . system . ExpectedSystemExit ; import org . junit . contrib . java . lang . system . LogMode ; import org . junit . contrib . java . lang . system . StandardErrorStreamLog ; import org . junit . contrib . java . lang . system . StandardOutputStreamLog ; import org . junit . rules . TemporaryFolder ; import java . io . File ; import java . io . IOException ; import java . util . ResourceBundle ; import static org . junit . Assert . assertEquals ; public class MainTest { @ Rule public TemporaryFolder temporaryFolder = new TemporaryFolder ( ) ; @ Rule public final ExpectedSystemExit exit = ExpectedSystemExit . none ( ) ; @ Rule public final StandardErrorStreamLog errorLog = new StandardErrorStreamLog ( LogMode . LOG_ONLY ) ; @ Rule public final StandardOutputStreamLog standardLog = new StandardOutputStreamLog ( LogMode . LOG_ONLY ) ; @ Test public void testVersionPrint ( ) throws Exception { exit . expectSystemExitWithStatus ( 0 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) { assertEquals ( "Checkstyle version: null" + System . lineSeparator ( ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-v" ) ; } @ Test public void testWrongArgument ( ) throws Exception { exit . expectSystemExitWithStatus ( - 1 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) { String usage = String . format ( "Unrecognized option: -w%n" + "usage: java com.puppycrawl.tools.checkstyle.Main [options] -c <config.xml>%n" + " file...%n" + " -c <arg> Sets the check configuration file to use.%n" + " -f <arg> Sets the output format. (plain|xml). Defaults to plain%n" + " -o <arg> Sets the output file. Defaults to stdout%n" + " -p <arg> Loads the properties file%n" + " -v Print product version and exit%n" ) ; assertEquals ( usage , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-w" ) ; } @ Test public void testNoConfigSpecified ( ) throws Exception { exit . expectSystemExitWithStatus ( - 1 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) { assertEquals ( "Must specify a config XML file." + System . lineSeparator ( ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } @ Test public void testNonExistingTargetFile ( ) throws Exception { exit . expectSystemExitWithStatus ( - 1 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) { assertEquals ( "Must specify files to process, found 0." + System . lineSeparator ( ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "/google_checks.xml" , "NonexistingFile.java" ) ; } @ Test public void testNonExistingConfigFile ( ) throws Exception { exit . expectSystemExitWithStatus ( - 2 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) { assertEquals ( String . format ( "unable to find src/main/resources/non_existing_config.xml%n" + "Checkstyle ends with 1 errors.%n" ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "src/main/resources/non_existing_config.xml" , "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } @ Test public void testNonExistingOutputFormat ( ) throws Exception { exit . expectSystemExitWithStatus ( - 1 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) { assertEquals ( String . format ( "Invalid output format. " + "Found 'xmlp' but expected 'plain' or 'xml'.%n" ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "/google_checks.xml" , "-f" , "xmlp" , "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } @ Test public void testExistingTargetFile ( ) throws Exception { exit . expectSystemExitWithStatus ( 0 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) { assertEquals ( String . format ( "Starting audit...%n" + "Audit done.%n" ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "src/test/resources/com/puppycrawl/tools/checkstyle/config-classname.xml" , "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } @ Test public void testExistingTargetFileXmlOutput ( ) throws Exception { exit . expectSystemExitWithStatus ( 0 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) throws IOException { String currentPath = new File ( "." ) . getCanonicalPath ( ) ; String expectedPath = currentPath + "/src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" . replace ( "/" , File . separator ) ; final ResourceBundle compilationProperties = ResourceBundle . getBundle ( "checkstylecompilation" ) ; String version = compilationProperties . getString ( "checkstyle.compile.version" ) ; assertEquals ( String . format ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>%n" + "<checkstyle version=\"" + version + "\">%n" + "<file name=\"" + expectedPath + "\">%n" + "</file>%n" + "</checkstyle>%n" ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "src/test/resources/com/puppycrawl/tools/checkstyle/config-classname.xml" , "-f" , "xml" , "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } @ Test public void testExistingTargetFilePlainOutput ( ) throws Exception { exit . expectSystemExitWithStatus ( 0 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) { assertEquals ( String . format ( "Starting audit...%n" + "Audit done.%n" ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "src/test/resources/com/puppycrawl/tools/checkstyle/config-classname.xml" , "-f" , "plain" , "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } @ Test public void testExistingTargetFileWithViolations ( ) throws Exception { exit . expectSystemExitWithStatus ( 0 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) throws IOException { String currentPath = new File ( "." ) . getCanonicalPath ( ) ; String expectedPath = currentPath + "/src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" . replace ( "/" , File . separator ) ; assertEquals ( String . format ( "Starting audit...%n" + expectedPath + ":3:14: " + "warning: Name 'InputMain' must match pattern '^[a-z0-9]*$'.%n" + expectedPath + ":5:7: " + "warning: Name 'InputMainInner' must match pattern '^[a-z0-9]*$'.%n" + "Audit done.%n" ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "src/test/resources/com/puppycrawl/tools/checkstyle/config-classname2.xml" , "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } @ Test public void testExistingTargetFileWithError ( ) throws Exception { exit . expectSystemExitWithStatus ( 2 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) throws IOException { String currentPath = new File ( "." ) . getCanonicalPath ( ) ; String expectedPath = currentPath + "/src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" . replace ( "/" , File . separator ) ; assertEquals ( String . format ( "Starting audit...%n" + expectedPath + ":3:14: " + "Name 'InputMain' must match pattern '^[a-z0-9]*$'.%n" + expectedPath + ":5:7: " + "Name 'InputMainInner' must match pattern '^[a-z0-9]*$'.%n" + "Audit done.%n" + "Checkstyle ends with 2 errors.%n" ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "src/test/resources/com/puppycrawl/tools/checkstyle/config-classname2-error.xml" , "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } @ Test public void testExistingTargetFilePlainOutputToNonExistingFile ( ) throws Exception { exit . expectSystemExitWithStatus ( 0 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) { assertEquals ( "" , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "src/test/resources/com/puppycrawl/tools/checkstyle/config-classname.xml" , "-f" , "plain" , "-o" , temporaryFolder . getRoot ( ) + "/output.txt" , "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } @ Test public void testExistingTargetFilePlainOutputToFile ( ) throws Exception { final File file = temporaryFolder . newFile ( "file.output" ) ; exit . expectSystemExitWithStatus ( 0 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) { assertEquals ( "" , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "src/test/resources/com/puppycrawl/tools/checkstyle/config-classname.xml" , "-f" , "plain" , "-o" , file . getCanonicalPath ( ) , "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } @ Test public void testExistingTargetFilePlainOutputToFileWithoutRwPermissions ( ) throws Exception { final File file = temporaryFolder . newFile ( "file.output" ) ; file . setReadable ( false , false ) ; file . setWritable ( false , false ) ; exit . expectSystemExitWithStatus ( - 1 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) throws IOException { assertEquals ( "Permission denied : '" + file . getCanonicalPath ( ) + "'." + System . lineSeparator ( ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "src/test/resources/com/puppycrawl/tools/checkstyle/config-classname.xml" , "-f" , "plain" , "-o" , file . getCanonicalPath ( ) , "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } @ Test public void testExistingTargetFilePlainOutputProperties ( ) throws Exception { exit . expectSystemExitWithStatus ( 0 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) { assertEquals ( String . format ( "Starting audit...%n" + "Audit done.%n" ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "src/test/resources/com/puppycrawl/tools/checkstyle/" + "config-classname-prop.xml" , "-p" , "src/test/resources/com/puppycrawl/tools/checkstyle/mycheckstyle.properties" , "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } @ Test public void testExistingTargetFilePlainOutputNonexistingProperties ( ) throws Exception { exit . expectSystemExitWithStatus ( - 1 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) { assertEquals ( "Could not find file 'nonexisting.properties'." + System . lineSeparator ( ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "src/test/resources/com/puppycrawl/tools/checkstyle/" + "config-classname-prop.xml" , "-p" , "nonexisting.properties" , "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } @ Test public void testExistingIncorrectConfigFile ( ) throws Exception { exit . expectSystemExitWithStatus ( - 2 ) ; exit . checkAssertionAfterwards ( new Assertion ( ) { public void checkAssertion ( ) { assertEquals ( String . format ( "unable to parse configuration stream - Content is not allowed in prolog.:7:1%n" + "Checkstyle ends with 1 errors.%n" ) , standardLog . getLog ( ) ) ; assertEquals ( "" , errorLog . getLog ( ) ) ; } } ) ; Main . main ( "-c" , "src/test/resources/com/puppycrawl/tools/checkstyle/" + "config-Incorrect.xml" , "src/test/resources/com/puppycrawl/tools/checkstyle/InputMain.java" ) ; } }
package com . puppycrawl . tools . checkstyle ; public class InputSimplifyBoolean { public static boolean isOddMillis ( ) { boolean even = System . currentTimeMillis ( ) % 2 == 0 ; if ( even == true ) { return false ; } else { return true ; } } public static boolean isOddMillis2 ( ) { boolean even = System . currentTimeMillis ( ) % 2 == 0 ; if ( ! even ) return true ; else return false ; } public static boolean giveMeTrue ( ) { boolean tt = isOddMillis ( ) || true ; boolean ff = isOddMillis ( ) && false ; return ! false || ( true != false ) ; } public void tryToProvokeNPE ( ) { if ( true ) { } else { } if ( true ) { return ; } else { return ; } } public boolean ifNoElse ( ) { if ( isOddMillis ( ) ) { return true ; } return false ; } }
package com . puppycrawl . tools . checkstyle ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; import java . util . ArrayList ; import java . util . List ; class InputRightCurlyLineBreakBefore { int foo ( ) throws InterruptedException { int x = 1 ; int a = 2 ; while ( true ) { try { if ( x > 0 ) { break ; } else if ( x < 0 ) { ; } else { break ; } switch ( a ) { case 0 : break ; default : break ; } } catch ( Exception e ) { break ; } finally { break ; } } synchronized ( this ) { do { x = 2 ; } while ( x == 2 ) ; } synchronized ( this ) { do { } while ( x == 2 ) ; } for ( int k = 0 ; k < 1 ; k ++ ) { String innerBlockVariable = "" ; } for ( int k = 0 ; k < 1 ; k ++ ) { } return a ; } static { int x = 1 ; } void method2 ( ) { boolean flag = false ; if ( flag ) { System . err . println ( "foo" ) ; } } } class Absent_CustomFieldSerializer { public static void serialize ( ) { } } class Absent_CustomFieldSerializer10 { public Absent_CustomFieldSerializer10 ( ) { } } class EmptyClass { } interface EmptyInterface { }
package com . puppycrawl . tools . checkstyle ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . METHOD ) public @ interface IntMethodAnnotation { int value ( ) ; }
package com . puppycrawl . tools . checkstyle ; public class InputFinalParametersPrimitiveTypes { void foo ( int i ) { } void foo1 ( int i , String k , float s ) { } void foo2 ( String s , Object o , long l ) { } void foo3 ( int [ ] array ) { } void foo4 ( int i , float x , int [ ] s ) { } void foo5 ( int x , long [ ] l , String s ) { } }
package com . puppycrawl . tools . checkstyle ; import java . awt . * ; import java . awt . * ; import java . awt . * ; import java . awt . * ;
package com . puppycrawl . tools . checkstyle ; import java . awt . * ; import java . awt . event . * ; import java . io . * ; public class InputRegexpHeader2 { }
package com . puppycrawl . tools . checkstyle ; public class InputMagicNumber { public void magicMethod ( ) { final int INT_CONST = 101_000 ; final long LONG_CONST1 = 100_000L ; final long LONG_CONST2 = 100l ; final float FLOAT_CONST1 = 1.500_0F ; final float FLOAT_CONST2 = 1.5f ; final double DOUBLE_CONST1 = 1.500_0D ; final double DOUBLE_CONST2 = 1.5d ; final double DOUBLE_CONST3 = 1.5 ; int int_var1 = 1 ; int int_var2 = ( 2 ) ; long long_var1 = 0L ; long long_var2 = 0l ; double double_var1 = 0D ; double double_var2 = 0d ; int [ ] int_array = new int [ 2 ] ; int_var1 = 1 + 2 ; int_var1 += 1 ; double_var1 = 1.0 + 2.0 ; for ( int i = 0 ; i < 2 ; i ++ ) ; if ( 1 < 2 ) ; if ( 1.0 < 2.0 ) ; int int_magic1 = 3_000 ; double double_magic1 = 1.5_0 ; int int_magic2 = ( 3 + 4 ) ; int_array = new int [ 3 ] ; int_magic1 += 3 ; double_magic1 *= 1.5 ; for ( int j = 3 ; j < 5 ; j += 3 ) { int_magic1 ++ ; } if ( int_magic1 < 3 ) { int_magic1 = int_magic1 + 3 ; } int octalVar0 = 00 ; int octalVar8 = 010 ; int octalVar9 = 011 ; long longOctalVar8 = 0_10L ; long longOctalVar9 = 011l ; int hexVar0 = 0x0 ; int hexVar16 = 0x10 ; int hexVar17 = 0X011 ; long longHexVar0 = 0x0L ; long longHexVar16 = 0x10L ; long longHexVar17 = 0X11l ; } } interface Blah { int LOW = 5 ; int HIGH = 78 ; } class ArrayMagicTest { private static final int [ ] NONMAGIC = { 3 } ; private int [ ] magic = { 3 } ; private static final int [ ] [ ] NONMAGIC2 = { { 1 } , { 2 } , { 3 } } ; } class LongHex { long l = 0xffffffffL ; } class Signed { public static final int CONST_PLUS_THREE = + 3 ; public static final int CONST_MINUS_TWO = - 2 ; private int mPlusThree = + 3 ; private int mMinusTwo = - 2 ; private double mPlusDecimal = + 3.5 ; private double mMinusDecimal = - 2.5 ; } class NegativeOctalHex { private int hexIntMinusOne = 0xffffffff ; private long hexLongMinusOne = 0xffffffffffffffffL ; private long hexIntMinValue = 0x80000000 ; private long hexLongMinValue = 0x8000000000000000L ; private int octalIntMinusOne = 037777777777 ; private long octalLongMinusOne = 01777777777777777777777L ; private long octalIntMinValue = 020000000000 ; private long octalLongMinValue = 01000000000000000000000L ; } class Cast { public static final int TESTINTVAL = ( byte ) 0x80 ; } class ComplexAndFlagged { public static final java . util . List MYLIST = new java . util . ArrayList ( ) { public int size ( ) { return 378 ; } } ; } class ComplexButNotFlagged { public static final double SPECIAL_SUM = 2 + 1e10 , SPECIAL_DIFFERENCE = 4 - java . lang . Math . PI ; public static final Integer DEFAULT_INT = new Integer ( 27 ) ; public static final int SECS_PER_DAY = 24 * 60 * 60 , SPECIAL_RATIO = 4 / 3 ; public static final javax . swing . border . Border STD_BORDER = javax . swing . BorderFactory . createEmptyBorder ( 3 , 3 , 3 , 3 ) ; } enum MyEnum { A ( 3 ) , B ( 54 ) ; private MyEnum ( int value ) { } } class TestHashCodeMethod { public int hashCode ( ) { return 31 ; } public int hashCode ( int val ) { return 42 ; } public int hashcode ( ) { return 13 ; } static { int x = 21 ; } { int y = 37 ; } public TestHashCodeMethod ( ) { int z = 101 ; } @ IntMethodAnnotation ( 42 ) public void another ( ) { } @ IntMethodAnnotation ( value = 43 ) public void another2 ( ) { } @ IntMethodAnnotation ( - 44 ) public void anotherNegative ( ) { } @ IntMethodAnnotation ( value = - 45 ) public void anotherNegative2 ( ) { } }
package com . puppycrawl . tools . checkstyle ; class InputWhitespace { private int mVar1 = 1 ; private int mVar2 = 1 ; private int mVar3 = 1 ; void method1 ( ) { final int a = 1 ; int b = 1 ; b = 1 ; b += 1 ; b -= - 1 + ( + b ) ; b = b ++ + b -- ; b = ++ b - -- b ; } void method2 ( ) { synchronized ( this ) { } try { } catch ( RuntimeException e ) { } } private int mVar4 = 1 ; private void fastExit ( ) { boolean complicatedStuffNeeded = true ; if ( ! complicatedStuffNeeded ) { return ; } else { } } private int nonVoid ( ) { if ( true ) { return ( 2 ) ; } else { return 2 ; } } private void testCasts ( ) { Object o = ( Object ) new Object ( ) ; o = ( Object ) o ; o = ( Object ) o ; o = ( Object ) o ; } private void testQuestions ( ) { boolean b = ( 1 == 2 ) ? true : false ; b = ( 1 == 2 ) ? false : true ; } private void starTest ( ) { int x = 2 * 3 * 4 ; } private void boolTest ( ) { boolean a = true ; boolean x = ! a ; int z = ~ 1 + ~ 2 ; } private void divTest ( ) { int a = 4 % 2 ; int b = 4 % 2 ; int c = 4 % 2 ; int d = 4 % 2 ; int e = 4 / 2 ; int f = 4 / 2 ; int g = 4 / 2 ; int h = 4 / 2 ; } private java . lang . String dotTest ( ) { Object o = new java . lang . Object ( ) ; o . toString ( ) ; o . toString ( ) ; o . toString ( ) ; return o . toString ( ) ; } public void assertTest ( ) { assert true ; assert true : "Whups" ; assert "OK" . equals ( null ) ? false : true : "Whups" ; assert ( true ) ; assert true : "Whups" ; } void donBradman ( Runnable aRun ) { donBradman ( new Runnable ( ) { public void run ( ) { } } ) ; final Runnable r = new Runnable ( ) { public void run ( ) { } } ; } void rfe521323 ( ) { doStuff ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { } } private int i ; private int i1 , i2 , i3 ; private int i4 , i5 , i6 ; void bug806243 ( ) { Object o = new InputWhitespace ( ) { private int j ; } ; } void doStuff ( ) { } } interface IFoo { void foo ( ) ; } class SpecialCasesInForLoop { void forIterator ( ) { for ( int i = 0 ; i ++ < 5 ; ) { } int i = 0 ; for ( ; i < 5 ; i ++ ) { } for ( int anInt : getSomeInts ( ) ) { } } int [ ] getSomeInts ( ) { int i = ( int ) ( 2 / 3 ) ; return null ; } public void myMethod ( ) { new Thread ( ) { public void run ( ) { } } . start ( ) ; } public void foo ( java . util . List < ? extends String [ ] > bar , Comparable < ? super Object [ ] > baz ) { } }
package com . puppycrawl . tools . checkstyle ; import java . io . * ; import java . util . HashMap ; import java . util . Map ; class InputOneCharInintVarName { public void fooMethod ( ) { for ( int i = 1 ; i < 10 ; i ++ ) { } int i = 0 ; for ( int index = 1 ; index < 10 ; index ++ ) { } for ( int Index = 1 ; Index < 10 ; Index ++ ) { } int index = 1 ; for ( ; index < 10 ; index ++ ) { } for ( ; i < 12 ; i ++ ) { } Map < String , String > map = new HashMap < String , String > ( ) ; for ( Map . Entry < String , String > e : map . entrySet ( ) ) { } } }
package com . puppycrawl . tools . checkstyle . whitespace ; public class InputSeparatorWrap < T extends Foo & Bar > { public void goodCase ( ) throws FooException , BarException { int i = 0 ; String s = "ffffooooString" ; s . isEmpty ( ) ; s . isEmpty ( ) ; try { foo ( i , s ) ; } catch ( FooException | BarException e ) { } foo ( i , s ) ; } public static void foo ( int i , String s ) throws FooException , BarException { } } class badCase < T extends Foo & Bar > { public void goodCase ( int ... aFoo ) throws FooException , BarException { String s = "ffffooooString" ; s . isEmpty ( ) ; try { foo ( 1 , s ) ; } catch ( FooException | BarException e ) { } foo ( 1 , s ) ; int [ ] i ; } public static String foo ( int i , String s ) throws FooException , BarException { return new StringBuilder ( "" ) . append ( "" , 0 , 1 ) . append ( "" ) . toString ( ) ; } } interface Foo { } interface Bar { } class FooException extends Exception { } class BarException extends Exception { }
package com . puppycrawl . tools . checkstyle . grammars ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; import org . junit . Test ; public class UnicodeEscapeTest extends BaseCheckTestSupport { @ Test public void testCanParse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "grammars/UnicodeEscape.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . whitespace ; public class InputNoWhiteSpaceAfterCheckFormerNpe { private int [ ] getSome ( ) { return new int [ 4 ] ; } }
package com . puppycrawl . tools . checkstyle . whitespace ; public class InputEmptyLineSeparatorFormerException { }
package com . puppycrawl . tools . checkstyle . whitespace ; public class ParenPadWithSpace { protected ParenPadWithSpace ( int i ) { this ( ) ; toString ( ) ; } protected ParenPadWithSpace ( ) { super ( ) ; } public void enhancedFor ( ) { int [ ] i = new int [ 2 ] ; for ( int j : i ) { System . out . println ( j ) ; } } }
package com . puppycrawl . tools . checkstyle . whitespace ; import java . util . List ; public class InputGenericWhitespaceInnerClassCheck < T > { private List < InputGenericWhitespaceInnerClassCheck < ? extends T > . InnerClass > field ; public class InnerClass { } }
package com . puppycrawl . tools . checkstyle . whitespace ; import com . google . common . annotations . Beta ; import javax . accessibility . AccessibleAttributeSequence ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; public class NoLineWrapGoodInput { public void fooMethod ( ) { } }
package com . puppycrawl . tools . checkstyle . whitespace ; import java . io . IOException ; import java . io . StringWriter ; import java . io . Writer ; public class InputParenPad { class ParenPadNoSpace { ParenPadNoSpace ( ) { this ( 0 ) ; } ParenPadNoSpace ( int i ) { super ( ) ; } @ SuppressWarnings ( "" ) void method ( boolean status ) { try ( Writer writer = new StringWriter ( ) ) { do { writer . append ( "a" ) ; } while ( status ) ; } catch ( IOException e ) { while ( status ) { for ( int i = 0 ; i < ( long ) ( 2 * ( 4 / 2 ) ) ; i ++ ) { if ( i > 2 ) { synchronized ( this ) { switch ( i ) { case 3 : case ( 4 ) : case 5 : break ; } } } } } } } } class ParenPadSpaceLeft { ParenPadSpaceLeft ( ) { this ( 0 ) ; } ParenPadSpaceLeft ( int i ) { super ( ) ; } @ SuppressWarnings ( "" ) void method ( boolean status ) { try ( Writer writer = new StringWriter ( ) ) { do { writer . append ( "a" ) ; } while ( status ) ; } catch ( IOException e ) { while ( status ) { for ( int i = 0 ; i < ( long ) ( 2 * ( 4 / 2 ) ) ; i ++ ) { if ( i > 2 ) { synchronized ( this ) { switch ( i ) { case 3 : case ( 4 ) : case 5 : break ; } } } } } } } } class ParenPadSpaceRight { ParenPadSpaceRight ( ) { this ( 0 ) ; } ParenPadSpaceRight ( int i ) { super ( ) ; } @ SuppressWarnings ( "" ) void method ( boolean status ) { try ( Writer writer = new StringWriter ( ) ) { do { writer . append ( "a" ) ; } while ( status ) ; } catch ( IOException e ) { while ( status ) { for ( int i = 0 ; i < ( long ) ( 2 * ( 4 / 2 ) ) ; i ++ ) { if ( i > 2 ) { synchronized ( this ) { switch ( i ) { case 3 : case ( 4 ) : case 5 : break ; } } } } } } } } String foo ( ) { return ( ( Object ) bar ( ( 1 > 2 ) ? ( ( 3 < 4 ) ? false : true ) : ( ( 1 == 1 ) ? false : true ) ) ) . toString ( ) ; } @ MyAnnotation public boolean bar ( boolean a ) { assert ( true ) ; return true ; } boolean fooo = this . bar ( ( true && false ) && true ) ; } @ interface MyAnnotation { String someField ( ) default "Hello world" ; } enum MyEnum { SOME_CONSTANT ( ) { int i = ( int ) ( 2 * ( 4 / 2 ) ) ; } ; }
package com . puppycrawl . tools . checkstyle . whitespace ; import com . google . common . annotations . Beta ; import javax . accessibility . AccessibleAttributeSequence ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; public class NoLineWrapBadInput { public void fooMethod ( ) { final int foo = 0 ; } } enum FooFoo { } interface InterFoo { }
package com . puppycrawl . tools . checkstyle . whitespace ; public class InputEmptyLineSeparatorMultipleFieldsInClass { int first ; int second ; }
package com . puppycrawl . tools . checkstyle . whitespace ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import java . util . Collections ; class InputGenericWhitespaceCheck implements Comparable < InputGenericWhitespaceCheck > , Serializable { void meth ( ) { List < Integer > x = new ArrayList < Integer > ( ) ; List < List < Integer > > y = new ArrayList < List < Integer > > ( ) ; List < Integer > a = new ArrayList < Integer > ( ) ; List < List < Integer > > b = new ArrayList < List < Integer > > ( ) ; } public int compareTo ( InputGenericWhitespaceCheck aObject ) { return 0 ; } public static < T > Callable < T > callable ( Runnable task , T result ) { return null ; } public static < T > Callable < T > callable2 ( Runnable task , T result ) { Map < Class < ? > , Integer > x = new HashMap < Class < ? > , Integer > ( ) ; for ( final Map . Entry < Class < ? > , Integer > entry : x . entrySet ( ) ) { entry . getValue ( ) ; } Class < ? > [ ] parameterClasses = new Class < ? > [ 0 ] ; return null ; } public int getConstructor ( Class < ? > ... parameterTypes ) { Collections . < Object > emptySet ( ) ; Collections . < Object > emptySet ( ) ; return 666 ; } < T > InputGenericWhitespaceCheck ( List < T > things , int i ) { } public < T > InputGenericWhitespaceCheck ( List < T > things ) { } public interface IntEnum { } public static class IntEnumValueType < E extends Enum < E > & IntEnum > { } public static class IntEnumValueType2 < E extends Enum < E > & IntEnum > { } public static class IntEnumValueType3 < E extends Enum < E > & IntEnum > { } }
package com . puppycrawl . tools . checkstyle . whitespace ; public class InputDoWhileWhitespaceAround { public void doWhileTest ( int n ) { int k = 0 ; do { ++ k ; } while ( k < n ) ; } }
package com . puppycrawl . tools . checkstyle . grammars ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; import org . junit . Test ; public class Java7DiamondTest extends BaseCheckTestSupport { @ Test public void testCanParse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "grammars/InputJava7Diamond.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . whitespace ; import java . util . Calendar ; import java . util . Date ; public class InputEmptyLineSeparatorMultipleImportEmptyClass { }
package com . puppycrawl . tools . checkstyle . whitespace ; @ SuppressWarnings ( { "this" , "that" } ) public class InputWhitespaceAround { protected InputWhitespaceAround ( int i ) { this ( ) ; toString ( ) ; } protected InputWhitespaceAround ( ) { super ( ) ; } public void enhancedFor ( ) { int [ ] i = new int [ 2 ] ; for ( int j : i ) { System . out . println ( j ) ; } } } @ interface CronExpression { Class < ? > [ ] groups ( ) default { } ; } @ interface CronExpression1 { Class < ? > [ ] groups ( ) default { } ; }
package com . puppycrawl . tools . checkstyle . whitespace ; class InputEmptyLineSeparatorCheckHeader { }
package com . puppycrawl . tools . checkstyle . whitespace ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import java . util . Collections ; import com . google . common . io . CharSource ; import javax . swing . AbstractAction ; import org . apache . commons . beanutils . locale . converters . ByteLocaleConverter ; import org . apache . commons . beanutils . BasicDynaBean ; class InputEmptyLineSeparatorCheck { public static final double FOO_PI = 3.1415 ; private boolean flag = true ; static { } { } private InputEmptyLineSeparatorCheck ( ) { } public int compareTo ( Object aObject ) { int number = 0 ; return 0 ; } public static < T > Callable < T > callable ( Runnable task , T result ) { return null ; } public int getBeastNumber ( ) { return 666 ; } interface IntEnum { } class InnerClass { public static final double FOO_PI_INNER = 3.1415 ; private boolean flagInner = true ; { } private InnerClass ( ) { } } } class Class2 { public int compareTo ( InputEmptyLineSeparatorCheck aObject ) { int number = 0 ; return 0 ; } Class2 anon = new Class2 ( ) { public int compareTo ( InputEmptyLineSeparatorCheck aObject ) { int number = 0 ; return 0 ; } } ; }
package com . puppycrawl . tools . checkstyle . whitespace ; import java . util . List ; public class Gh47 { public List < List < String > [ ] > listOfListOFArrays ; }
package com . puppycrawl . tools . checkstyle . whitespace ; import java . util . Vector ; public class InputMethodParamPad { public InputMethodParamPad ( ) { super ( ) ; } public InputMethodParamPad ( int aParam ) { super ( ) ; } public InputMethodParamPad ( double aParam ) { super ( ) ; } public void method ( ) { } public void method ( int aParam ) { } public void method ( double aParam ) { InputMethodParamPad pad = new InputMethodParamPad ( ) ; pad = new InputMethodParamPad ( ) ; pad = new InputMethodParamPad ( ) ; method ( ) ; method ( ) ; method ( ) ; } public void dottedCalls ( ) { this . method ( ) ; this . method ( ) ; this . method ( ) ; InputMethodParamPad p = new InputMethodParamPad ( ) ; p . method ( ) ; p . method ( ) ; p . method ( ) ; java . lang . Integer . parseInt ( "0" ) ; java . lang . Integer . parseInt ( "0" ) ; java . lang . Integer . parseInt ( "0" ) ; } public void newArray ( ) { int [ ] a = new int [ ] { 0 , 1 } ; java . util . Vector < String > v = new java . util . Vector < String > ( ) ; java . util . Vector < String > v1 = new Vector < String > ( ) ; } }
package com . puppycrawl . tools . checkstyle . whitespace ; public class InputNoWhitespaceAfterArrayDeclarations { Object [ ] someStuff = { } ; Object [ ] someStuff1 = { } ; Object someStuff2 [ ] = { } ; Object someStuff3 [ ] = { } ; int [ ] a = { } ; String s [ ] = { } ; double d [ ] = { } ; char [ ] c = { } ; short sh [ ] = { } ; long [ ] l = { } ; byte b [ ] = { } ; int get ( ) [ ] { return a ; } int [ ] receive ( ) { return a ; } int get1 ( int k , int c , int b ) [ ] { return null ; } private String [ ] getLines ( ) { return new String [ ] { "s" } ; } String aOptions [ ] [ ] ; int [ ] [ ] [ ] abc ; int cba [ ] [ ] [ ] ; private String [ ] [ ] [ ] getSeveralLines ( ) { return new String [ ] [ ] [ ] { new String [ ] [ ] { new String [ ] { "s" } } } ; } int ar [ ] = new int [ ] { 1 , 2 } ; private int [ ] [ ] [ ] getMultArray ( ) { return null ; } private long getLongMultArray ( int someParam , String value ) [ ] [ ] [ ] { return null ; } }
package com . puppycrawl . tools . checkstyle . whitespace ; import java . util . * ; import java . io . * ; public class InputEmptyLineSeparatorCheckMultipleEmptyLines { private int counter ; private Object obj = null ; private int k ; private static void foo ( ) { } private static void foo1 ( ) { } }
package com . puppycrawl . tools . checkstyle . whitespace ; public class InputSwitchWhitespaceAround { public void switchTest ( int k ) { switch ( k ) { default : break ; } } }
package com . puppycrawl . tools . checkstyle . whitespace ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Function ; import com . google . common . base . Supplier ; class myFoo { private static final String ALLOWS_NULL_KEYS = "" ; private static final String ALLOWS_NULL_VALUES = "" ; @ MapFeature . Require ( { ALLOWS_NULL_KEYS , ALLOWS_NULL_VALUES } ) private void foo ( ) { int i = 0 ; String [ ] [ ] x = { { "foo" } } ; int len = 0 ; String sequence = null ; for ( int first = 0 ; first < len && matches ( sequence . charAt ( first ) ) ; first ++ ) { } while ( i == 1 ) { } do { } while ( i == 1 ) ; } private boolean matches ( char charAt ) { return false ; } } interface SupplierFunction < T > extends Function < Supplier < T > , T > { } class EmptyFoo { } enum EmptyFooEnum { } class WithEmptyAnonymous { private void foo ( ) { MyClass c = new MyClass ( ) { } ; } } @ Retention ( value = RetentionPolicy . CLASS ) @ Target ( ElementType . ANNOTATION_TYPE ) @ Documented @ GwtCompatible @ interface Beta { } @ interface MapFeature { @ interface Require { String [ ] value ( ) ; } } class MyClass { }
package com . puppycrawl . tools . checkstyle . grammars ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; import org . junit . Test ; public class Java7NumericalLiteralsTest extends BaseCheckTestSupport { @ Test public void testCanParse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "grammars/InputJava7NumericalLiterals.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . naming ; abstract public class InputAbstractClassName { } abstract class NonAbstractClassName { } abstract class AbstractClassName { abstract class NonAbstractInnerClass { } } class NonAbstractClass { } class AbstractClass { } abstract class AbstractClassName2 { class AbstractInnerClass { } }
package com . puppycrawl . tools . checkstyle . naming ; public abstract class AbstractMultisetSetCountTester < E > { private static final String SUPPORTS_REMOVE = "" ; @ CollectionFeature . Require ( absent = SUPPORTS_REMOVE ) public void testSetCount_negative_removeUnsupported ( ) { } } @ interface CollectionFeature { public @ interface Require { String absent ( ) ; } }
package com . puppycrawl . tools . checkstyle . naming ; public class InputMemberNameExtended { public int mPublic ; protected int mProtected ; int mPackage ; private int mPrivate ; public int _public ; protected int _protected ; int _package ; private int _private ; class Inner { public int mPublic ; protected int mProtected ; int mPackage ; private int mPrivate ; public int _public ; protected int _protected ; int _package ; private int _private ; } Inner anon = new Inner ( ) { public int mPublic ; protected int mProtected ; int mPackage ; private int mPrivate ; public int _public ; protected int _protected ; int _package ; private int _private ; } ; } interface In { public int mPublic = 0 ; int mProtected = 0 ; int mPackage = 0 ; int mPrivate = 0 ; public int _public = 0 ; int _protected = 0 ; int _package = 0 ; int _private = 0 ; } enum Direction { NORTH ( 1 ) , SOUTH ( - 1 ) , EAST ( - 2 ) , WEST ( 2 ) ; public int mPublic = 0 ; int mProtected = 0 ; int mPackage = 0 ; int mPrivate = 0 ; public int _public = 0 ; int _protected = 0 ; int _package = 0 ; int _private = 0 ; Direction ( int code ) { this . code = code ; } protected int code ; public int getCode ( ) { return this . code ; } static Direction getOppositeDirection ( Direction d ) { return null ; } }
package com . puppycrawl . tools . checkstyle . naming ; abstract class IIIInputAbstractClassName { } abstract class NonAAAAbstractClassName { } abstract class FactoryWithBADNAme { } abstract class AbstractCLASSName { abstract class NonAbstractInnerClass { } } abstract class ClassFactory1 { abstract class WellNamedFactory { } } class NonAbstractClass1 { } class AbstractClass1 { } class Class1Factory1 { } abstract class AbstractClassName3 { class AbstractINNERRClass { } } abstract class Class3Factory { class WellNamedFACTORY { public void marazmaticMETHODName ( ) { int marazmaticVARIABLEName = 2 ; int MARAZMATICVariableName = 1 ; } } } interface Directions { int RIGHT = 1 ; int LEFT = 2 ; int UP = 3 ; int DOWN = 4 ; } interface BadNameForInterfeis { void interfaceMethod ( ) ; } abstract class NonAAAAbstractClassName2 { public int serialNUMBER = 6 ; public final int s1erialNUMBER = 6 ; private static int s2erialNUMBER = 6 ; private static final int s3erialNUMBER = 6 ; } interface Interface1 { String VALUEEEE = "value" ; } interface Interface2 { static String VALUEEEE = "value" ; } interface Interface3 { final String VALUEEEE = "value" ; } interface Interface4 { final static String VALUEEEE = "value" ; } class FIleNameFormatException extends Exception { private static final long serialVersionUID = 1L ; public FIleNameFormatException ( Exception e ) { super ( e ) ; } } class StateX { int userID ; int scaleX , scaleY , scaleZ ; int getScaleX ( ) { return this . scaleX ; } }
package com . puppycrawl . tools . checkstyle . naming ; import java . io . Serializable ; public class InputTypeParameterName < t > { public < TT > void foo ( ) { } < e_e > void foo ( int i ) { } } class Other < foo extends Serializable & Cloneable > { foo getOne ( ) { return null ; } < Tfo$o2T extends foo > Tfo$o2T getTwo ( Tfo$o2T a ) { return null ; } < foo extends Runnable > foo getShadow ( ) { return null ; } static class Junk < foo > { < _fo extends foo > void getMoreFoo ( ) { } } } class MoreOther < T extends Cloneable > { < E extends T > void getMore ( ) { new Other ( ) { < T > void getMoreFoo ( ) { } } ; } } interface Boo < Input > { Input boo ( ) ; } interface FooInterface < T > { T foo ( ) ; } interface FooInterface2 { Input foo ( ) ; } class Input { }
package com . puppycrawl . tools . checkstyle . naming ; class inputHeaderClass { public interface inputHeaderInterface { } ; public enum inputHeaderEnum { one , two } ; public @ interface inputHeaderAnnotation { } ; }
package com . puppycrawl . tools . checkstyle . naming ; import java . io . ObjectStreamField ; public class InputConstantNames { private static final long serialVersionUID = 1L ; private static final ObjectStreamField [ ] serialPersistentFields = { } ; }
package com . puppycrawl . tools . checkstyle . naming ; import org . junit . Before ; abstract class NonAAAAbstractClassName1 extends Class1 { public int serialNUMBER = 6 ; public final int s1erialNUMBER = 6 ; private static int s2erialNUMBER = 6 ; private static final int s3erialNUMBER = 6 ; @ Override @ SuppressWarnings ( value = { "" } ) @ Before protected void oveRRRRRrriddenMethod ( ) { int a = 0 ; } } class Class1 { @ SuppressWarnings ( value = { "" } ) protected void oveRRRRRrriddenMethod ( ) { int a = 0 ; } } class Class2 extends Class1 { @ Override @ SuppressWarnings ( value = { "" } ) @ Before protected void oveRRRRRrriddenMethod ( ) { int a = 0 ; } }
package com . puppycrawl . tools . checkstyle . naming ; public class InputStaticVariableName { interface A { public static int VAL_0 = 1 ; } @ interface B { String name ( ) default "" ; int version ( ) default 0 ; public static int VAL_1 = 0 ; } }
package com . puppycrawl . tools . checkstyle . naming ; public class InputMethodNameExtra { public void doit ( ) { Object historyDetails = null ; Object previousNameService = null ; Object entityId = null ; Object agencyName = null ; createNameHistoryDetails ( historyDetails , previousNameService , entityId , new More . ViewChangeHistoryBaseAction . ChangeHistoryDisplayName ( agencyName ) { String getDisplayName ( ) { return getPreviousName ( ) ; } } ) ; } private void createNameHistoryDetails ( Object historyDetails , Object previousNameService , Object entityId , More . ViewChangeHistoryBaseAction . ChangeHistoryDisplayName changeHistoryDisplayName ) { } protected String getPreviousName ( ) { return null ; } private void createNameHistoryDetails ( Object historyDetails , Object previousNameService , Object entityId , ChangeHistoryDisplayName changeHistoryDisplayName ) { } private static class More { public static class ViewChangeHistoryBaseAction { public static class ChangeHistoryDisplayName { public ChangeHistoryDisplayName ( Object agencyName ) { } } } } private class ChangeHistoryDisplayName { } }
package com . puppycrawl . tools . checkstyle . grammars ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; import org . junit . Test ; public class EmbeddedNullCharTest extends BaseCheckTestSupport { @ Test public void testCanParse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "grammars/InputEmbeddedNullChar.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . naming ; public class InputMemberName { public int mPublic ; protected int mProtected ; int mPackage ; private int mPrivate ; public int _public ; protected int _protected ; int _package ; private int _private ; }
package com . puppycrawl . tools . checkstyle . naming ; public class InputAbstractClassNameFormerFalsePositive { class Abstract { } class AbstractClass { } }
package com . puppycrawl . tools . checkstyle . naming ; public class InputMethodNameOverridenMethods extends SomeClass { @ Override public void PUBLICfoo ( ) { } @ java . lang . Override protected void PROTECTEDfoo ( ) { } } class SomeClass { public void PUBLICfoo ( ) { } protected void PROTECTEDfoo ( ) { } }
package com . puppycrawl . tools . checkstyle . metrics ; public class BooleanExpressionComplexityCheckTestInput { private boolean _a = false ; private boolean _b = false ; private boolean _c = false ; private boolean _d = false ; public void foo ( ) { if ( _a && _b || _c ^ _d ) { } if ( ( ( _a && ( _b & _c ) ) || ( _c ^ _d ) ) ) { } if ( _a && _b && _c ) { } if ( _a & _b ) { } if ( _a ) { } } public boolean equals ( Object object ) { return ( ( ( _a && ( _b & _c ) ) || ( _c ^ _d ) || ( _a && _d ) ) ) ; } public boolean bitwise ( ) { return ( ( ( _a & ( _b & _c ) ) | ( _c ^ _d ) | ( _a & _d ) ) ) ; } public void notIgnoredMethodParameters ( ) { new Settings ( Settings . FALSE && Settings . FALSE && Settings . FALSE && Settings . TRUE && Settings . TRUE ) ; new Settings ( Settings . FALSE || Settings . FALSE || Settings . FALSE || Settings . TRUE || Settings . TRUE ) ; } public void ignoredMethodParameters ( ) { new Settings ( Settings . RESIZABLE | Settings . SCROLLBARS | Settings . LOCATION_BAR | Settings . MENU_BAR | Settings . TOOL_BAR ) ; new Settings ( Settings . RESIZABLE & Settings . SCROLLBARS & Settings . LOCATION_BAR & Settings . MENU_BAR & Settings . TOOL_BAR ) ; new Settings ( Settings . RESIZABLE ^ Settings . SCROLLBARS ^ Settings . LOCATION_BAR ^ Settings . MENU_BAR ^ Settings . TOOL_BAR ) ; } private class Settings { public final static int RESIZABLE = 1 ; public final static int SCROLLBARS = 2 ; public final static int LOCATION_BAR = 3 ; public final static int MENU_BAR = 4 ; public final static int TOOL_BAR = 5 ; public final static boolean TRUE = true ; public final static boolean FALSE = false ; public Settings ( int flag ) { } public Settings ( boolean flag ) { } } }
package com . puppycrawl . tools . checkstyle . metrics ; public class InputBooleanExpressionComplexityNPE { static { try { System . out . println ( "a" ) ; } catch ( IllegalStateException | IllegalArgumentException e ) { throw new RuntimeException ( e ) ; } } }
package com . puppycrawl . tools . checkstyle . metrics ; import java . awt . event . ItemEvent ; import java . awt . event . ItemListener ; public class JavaNCSSCheckTestInput { private Object mObject ; private void testMethod1 ( ) { int x = 1 , y = 2 ; } private void testMethod2 ( ) { int abc = 0 ; testLabel : abc = 1 ; } private void testMethod3 ( ) { int a = 0 ; switch ( a ) { case 1 : case 2 : System . out . println ( "Hello" ) ; break ; default : break ; } ItemListener lis = new ItemListener ( ) { public void itemStateChanged ( ItemEvent e ) { System . out . println ( "Hello" ) ; } } ; } private class TestInnerClass { private Object test ; } } class TestTopLevelNestedClass { private Object mObject ; private void testMethod ( ) { for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == 0 ) { int x = 1 , y = 2 ; } else { int abc = 0 ; testLabel : abc = 1 ; } } } }
package com . puppycrawl . tools . checkstyle . metrics ; import javax . naming . * ; import java . util . * ; public class ClassCouplingCheckTestInput { private class InnerClass { public List _list = new ArrayList ( ) ; } private class AnotherInnerClass { public String _string = "" ; } public Set _set = new HashSet ( ) ; public Map _map = new HashMap ( ) ; public String _string = "" ; public int [ ] _intArray = new int [ 0 ] ; public InnerClass _innerClass = new InnerClass ( ) ; public AnotherInnerClass _anotherInnerClass = new AnotherInnerClass ( ) ; public void foo ( ) throws NamingException { } } enum InnerEnum { VALUE1 ; private InnerEnum ( ) { map2 = new HashMap ( ) ; } private Set map1 = new HashSet ( ) ; private Map map2 ; }
package com . puppycrawl . tools . checkstyle . comments ; class InputCommentsTest_2 { protected String line ( ) { return null ; } }
package com . puppycrawl . tools . checkstyle . comments ; public class InputCommentsTest_1 { }
package com . puppycrawl . tools . checkstyle . comments ; public class InputFullOfBlockComments { public static String main ( String [ ] args ) { String line = "/*I'm NOT comment*/blabla" ; System . out . println ( line ) ; Integer [ ] array = null ; for ( Integer i : array ) { } return line ; } }
package com . puppycrawl . tools . checkstyle . grammars ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; import org . junit . Test ; public class LineCommentAtTheEndOfFileTest extends BaseCheckTestSupport { @ Test public void testCanParse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "grammars/LineCommentAtTheEndOfFile.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . comments ; public class InputFullOfSinglelineComments { public static void main ( String [ ] args ) { for ( int i = 0 ; i <= 10 ; i ++ ) { String line = i + "" ; System . out . println ( line ) ; } } }
package com . puppycrawl . tools . checkstyle . javadoc ; class Foo { void foo ( ) { } void foo1 ( ) { } void foo2 ( ) { } void foo3 ( ) { } void foo4 ( ) { } void foo5 ( ) { } void foo6 ( ) { } void foo7 ( ) { } void foo8 ( ) { } void foo9 ( ) { } void bar ( ) { } void bar1 ( ) { } void bar2 ( ) { } void bar3 ( ) { } }
package com . puppycrawl . tools . checkstyle . javadoc ; public class InputSummaryJavadocCheckNoPeriod { void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } }
package com . puppycrawl . tools . checkstyle . javadoc ; public class InputInheritDoc { InputInheritDoc ( ) { } private void privateMethod ( ) { } void packageMethod ( ) { } protected void protectedMethod ( ) { } public void publicMethod ( ) { } private static void privateStaticMethod ( ) { } static void packageStaticMethod ( ) { } protected static void protectedStaticMethod ( ) { } public static void publicStaticMethod ( ) { } }
package com . puppycrawl . tools . checkstyle . javadoc ; class InputNonEmptyAtclauseDescriptionCheck { public InputNonEmptyAtclauseDescriptionCheck ( String a , int b ) { } public InputNonEmptyAtclauseDescriptionCheck ( String a ) { } public InputNonEmptyAtclauseDescriptionCheck ( String a , int b , double c ) { } public InputNonEmptyAtclauseDescriptionCheck ( String a , boolean e ) { } public int foo1 ( String a , int b , double c ) throws Exception { return 1 ; } public int foo2 ( String a , int b , double c ) throws Exception { return 1 ; } public int foo3 ( String a , int b , double c ) throws Exception { return 1 ; } public int foo4 ( String a , int b , double c ) throws Exception { return 1 ; } }
package com . puppycrawl . tools . checkstyle . javadoc ; public class InputJavadocMethodCheck_SmallMethods extends Some { int foo1 ( ) { return 1 ; } String foo2 ( ) { return "Fooooooooooooooo" + "ooooo" + "ooo" ; } void foo3 ( ) { foo2 ( ) ; } void foo4 ( ) { } int foo5 ( ) { return 1 ; } String foo6 ( ) { return "Fooooooooooooooo" + "oooooooo" ; } String foo7 ( ) { return "Fooooooooooooooo" + "ooooo" + "ooo" ; } void foo8 ( ) { foo2 ( ) ; } void foo9 ( ) { } @ MyAnnotation String foo10 ( ) { return "Fooooooooooooooo" + "ooooo" + "ooo" ; } @ Override protected String foo11 ( ) { return "Fooooo" + "ooo" + "ooooooo" + "ooooo" + "ooo" ; } } @ interface MyAnnotation { } class Some { protected String foo11 ( ) { return "4" ; } }
package com . puppycrawl . tools . checkstyle . javadoc ; public class TestGenerics < E extends java . lang . Exception , RE extends RuntimeException & java . io . Serializable > { public void method1 ( ) throws E { } public void method2 ( ) throws RE { } public void method3 ( ) throws E , RE { } public < NPE extends NullPointerException > void method4 ( ) throws NPE , RE { } public class InnerClass < RuntimeException extends ClassCastException > { public void method1 ( ) throws RuntimeException , RE , java . lang . RuntimeException { } } public interface InnerInterface < T , E2 extends Throwable > { public abstract String doStuff ( T t ) throws E2 ; } }
package com . puppycrawl . tools . checkstyle . javadoc ; import java . io . Serializable ; class WithAnnotations implements Serializable { private String fFirstName ; private String sSecondName ; private String tThirdName ; String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } class InnerClassWithAnnotations { String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } } InnerClassWithAnnotations anon = new InnerClassWithAnnotations ( ) { String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } } ; } enum Foo3 { } interface FooIn3 { }
package com . puppycrawl . tools . checkstyle . javadoc ; public class InputSummaryJavadocCheckPeriod { void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } void foo6 ( ) { } }
package com . puppycrawl . tools . checkstyle . javadoc ; class InputCorrectJavaDocParagraphCheck { public static final byte NUL = 0 ; boolean emulated ( ) { return false ; } class InnerInputCorrectJavaDocParagraphCheck { public static final byte NUL = 0 ; boolean emulated ( ) { return false ; } } InnerInputCorrectJavaDocParagraphCheck anon = new InnerInputCorrectJavaDocParagraphCheck ( ) { public static final byte NUL = 0 ; boolean emulated ( ) { return false ; } } ; }
package com . puppycrawl . tools . checkstyle . grammars ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; public class MultiDimensionalArraysInGenericsTest extends BaseCheckTestSupport { @ Test public void testCanParse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "grammars/MultiDimensionalArraysInGenericsTestInput.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . javadoc ; class InputCorrectSummaryJavaDocCheck { public static final byte NUL = 0 ; void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } void foo6 ( ) { } class InnerInputCorrectJavaDocParagraphCheck { public static final byte NUL = 0 ; public static final byte NUL_2 = 0 ; int getId ( ) { return 666 ; } void foo2 ( ) { } void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } void foo6 ( ) { } } InnerInputCorrectJavaDocParagraphCheck anon = new InnerInputCorrectJavaDocParagraphCheck ( ) { public static final byte NUL = 0 ; boolean emulated ( String s ) { return false ; } void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } void foo6 ( ) { } boolean emulated ( ) { return false ; } boolean emulated1 ( ) { return false ; } int geId ( ) { return 666 ; } } ; }
package com . puppycrawl . tools . checkstyle . javadoc ; public class InputBadTag { }
package com . puppycrawl . tools . checkstyle . javadoc ; public class InputSetterGetter { private int mNumber ; public void setNumber ( final int number ) { mNumber = number ; } public int getNumber ( ) { return mNumber ; } public void setNumber1 ( ) { mNumber = mNumber ; } public void setNumber2 ( int number ) { mNumber = number ; firePropertyChanged ( ) ; } public void getNumber2 ( ) { } public int getCost1 ( int forMe ) { return 666 ; } public int getCost2 ( ) { mNumber = 4 ; return 666 ; } public int getCost3 ( ) throws Exception { return 666 ; } public boolean isSomething ( ) { return false ; } private void firePropertyChanged ( ) { } }
package com . puppycrawl . tools . checkstyle . javadoc ; class InputInCorrectJavaDocParagraphCheck { public static final byte NUL = 0 ; boolean emulated ( ) { return false ; } class InnerInputCorrectJavaDocParagraphCheck { public static final byte NUL = 0 ; boolean emulated ( ) { return false ; } } InnerInputCorrectJavaDocParagraphCheck anon = new InnerInputCorrectJavaDocParagraphCheck ( ) { public static final byte NUL = 0 ; boolean emulated ( ) { return false ; } } ; }
package com . puppycrawl . tools . checkstyle . javadoc ; import java . io . Serializable ; class WithAnnotations1 implements Serializable { private String fFirstName ; private String sSecondName ; private String tThirdName ; String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } class InnerClassWithAnnotations { String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } } InnerClassWithAnnotations anon = new InnerClassWithAnnotations ( ) { String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } } ; } enum Foo4 { } interface FooIn { }
package com . puppycrawl . tools . checkstyle . javadoc ; class InputInCorrectSummaryJavaDocCheck { void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } void foo6 ( ) { } public static final byte NUL = 0 ; class InnerInputCorrectJavaDocParagraphCheck { public static final byte NUL = 0 ; public static final byte NUL_2 = 0 ; boolean emulated ( ) { return false ; } void foo2 ( ) { } int geId ( ) { return 666 ; } void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } void foo6 ( ) { } } InnerInputCorrectJavaDocParagraphCheck anon = new InnerInputCorrectJavaDocParagraphCheck ( ) { public static final byte NUL = 0 ; void emulated ( String s ) { } void foo3 ( ) { } void foo4 ( ) throws Exception { } void foo5 ( ) { } void foo6 ( ) { } } ; }
package com . puppycrawl . tools . checkstyle . javadoc ; class InputTestNumberFomatException { }
package com . puppycrawl . tools . checkstyle . javadoc ; import com . google . common . base . Function ; class Foo5 { public static < T extends Enum < T > > Function < String , T > valueOfFunction ( Class < T > enumClass ) { return null ; } }
package com . puppycrawl . tools . checkstyle . javadoc ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . Multiset ; import com . google . common . collect . Multiset . Entry ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . List ; @ GwtCompatible ( emulated = true ) public abstract class ExtendAnnotation < E > { private static final String SUPPORTS_ADD = "" ; private static final String SUPPORTS_REMOVE = null ; @ CollectionFeature . Require public void testSetCount_zeroToZero_unsupported ( ) { try { assertZeroToZero ( ) ; } catch ( UnsupportedOperationException tolerated ) { } } private void assertZeroToZero ( ) { } @ interface CollectionFeature { @ interface Require { } } }
package com . puppycrawl . tools . checkstyle . javadoc ; public class InputNoJavadoc { public int i1 ; protected int i2 ; int i3 ; private int i4 ; public void foo1 ( ) { } protected void foo2 ( ) { } void foo3 ( ) { } private void foo4 ( ) { } protected class ProtectedInner { public int i1 ; protected int i2 ; int i3 ; private int i4 ; public void foo1 ( ) { } protected void foo2 ( ) { } void foo3 ( ) { } private void foo4 ( ) { } } class PackageInner { public int i1 ; protected int i2 ; int i3 ; private int i4 ; public void foo1 ( ) { } protected void foo2 ( ) { } void foo3 ( ) { } private void foo4 ( ) { } } private class PrivateInner { public int i1 ; protected int i2 ; int i3 ; private int i4 ; public void foo1 ( ) { } protected void foo2 ( ) { } void foo3 ( ) { } private void foo4 ( ) { } } } class PackageClass { public int i1 ; protected int i2 ; int i3 ; private int i4 ; public void foo1 ( ) { } protected void foo2 ( ) { } void foo3 ( ) { } private void foo4 ( ) { } public class PublicInner { public int i1 ; protected int i2 ; int i3 ; private int i4 ; public void foo1 ( ) { } protected void foo2 ( ) { } void foo3 ( ) { } private void foo4 ( ) { } } protected class ProtectedInner { public int i1 ; protected int i2 ; int i3 ; private int i4 ; public void foo1 ( ) { } protected void foo2 ( ) { } void foo3 ( ) { } private void foo4 ( ) { } } class PackageInner { public int i1 ; protected int i2 ; int i3 ; private int i4 ; public void foo1 ( ) { } protected void foo2 ( ) { } void foo3 ( ) { } private void foo4 ( ) { } } private class PrivateInner { public int i1 ; protected int i2 ; int i3 ; private int i4 ; public void foo1 ( ) { } protected void foo2 ( ) { } void foo3 ( ) { } private void foo4 ( ) { } } class IgnoredName { private int logger ; } }
package com . puppycrawl . tools . checkstyle . grammars ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; import org . junit . Test ; public class Java7MultiCatchTest extends BaseCheckTestSupport { @ Test public void testCanParse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "grammars/InputJava7MultiCatch.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . javadoc ; public class AllowedAnnotations implements SomeInterface { @ ThisIsOk public void allowed1 ( ) { } @ ThisIsOkToo public void allowed2 ( ) { } @ com . puppycrawl . tools . checkstyle . javadoc . ThisIsOk public void allowed3 ( ) { } @ Override public void method ( ) { } } interface SomeInterface { void method ( ) ; } @ interface ThisIsOk { } @ interface ThisIsOkToo { }
package com . puppycrawl . tools . checkstyle . javadoc ; public class InputJavadocMethodIgnoreNameRegex { private void foo ( ) { } private void foo88 ( ) { } private void foo2 ( ) { int x = 0 ; int k = x > > 2 ; String s = String . valueOf ( k ) ; boolean b = false ; } }
package com . puppycrawl . tools . checkstyle . javadoc ; import java . io . Serializable ; class JavaDocTagContinuationIndentation implements Serializable { private String fFirstName ; private String sSecondName ; private String tThirdName ; String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } class InnerClassWithAnnotations { String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } } InnerClassWithAnnotations anon = new InnerClassWithAnnotations ( ) { String method ( String aString ) throws Exception { return "null" ; } String method1 ( String aString ) throws Exception { return "null" ; } void method2 ( String aString ) throws Exception { } void method3 ( ) throws Exception { } String method4 ( ) throws Exception { return "null" ; } String method5 ( String aString ) { return "null" ; } String method6 ( String aString , int aInt , boolean aBoolean ) throws Exception { return "null" ; } } ; } enum Foo1 { } interface FooIn1 { }
package com . puppycrawl . tools . checkstyle . javadoc . pkginfo . invalidinherit ;
package com . puppycrawl . tools . checkstyle . javadoc . pkginfo . invalidformat ;
@ Deprecated package com . puppycrawl . tools . checkstyle . javadoc . pkginfo . annotation ;
package com . puppycrawl . tools . checkstyle . javadoc . pkginfo . valid ;
package com . puppycrawl . tools . checkstyle . javadoc . pkghtml ; class Ignored { }
package com . puppycrawl . tools . checkstyle . javadoc . bothfiles ;
package com . puppycrawl . tools . checkstyle . javadoc . bothfiles ; class Ignored { }
package com . puppycrawl . tools . checkstyle . grammars ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; import org . junit . Test ; public class VarargTest extends BaseCheckTestSupport { @ Test public void testCanParse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "grammars/InputVararg.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . imports ; import java . awt . Button ; import static java . awt . Button . ABORT ; import java . awt . Frame ; import java . awt . Dialog ; import java . awt . event . ActionEvent ; import javax . swing . JComponent ; import static javax . swing . WindowConstants . HIDE_ON_CLOSE ; import static javax . swing . WindowConstants . DO_NOTHING_ON_CLOSE ; import static javax . swing . WindowConstants . * ; import javax . swing . JTable ; import static java . io . File . createTempFile ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; public class InputImportOrder_InFlow { }
package com . puppycrawl . tools . checkstyle . imports ; import java . awt . Button ; import java . awt . Dialog ; import java . awt . Frame ; import java . awt . event . ActionEvent ; import java . io . IOException ; import java . io . InputStream ; import javax . swing . JComponent ; import javax . swing . JTable ; import static java . io . File . * ; import java . io . File ; import static java . io . File . createTempFile ; import static java . awt . Button . ABORT ; import static javax . swing . WindowConstants . * ; import java . io . Reader ; public class InputImportOrder_Bottom { }
@ MyAnnotation package com . puppycrawl . tools . checkstyle . imports ; import com . puppycrawl . tools . checkstyle . MyAnnotation ;
package com . puppycrawl . tools . checkstyle . imports ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . Beta ; import com . google . common . annotations . VisibleForTesting ; import org . abego . treelayout . Configuration ; import static sun . tools . util . ModifierFilter . ALL_ACCESS ; import com . google . common . annotations . GwtCompatible ; import antlr . * ; public class InputCustomImportOrderThirdPartyAndSpecial { }
package com . puppycrawl . tools . checkstyle . imports ; import org . * ; import java . util . Set ; import static java . lang . Math . PI ; import static org . abego . treelayout . Configuration . AlignmentInLevel ; public class InputImportOrderStaticGroupOrderBottom { }
package com . puppycrawl . tools . checkstyle . imports ; import javax . xml . transform . Source ; import org . w3c . dom . Node ; class DOMSource { }
package com . puppycrawl . tools . checkstyle . imports ; import com . google . common . annotations . VisibleForTesting ; import java . io . Closeable ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . lang . ref . PhantomReference ; import java . lang . ref . Reference ; import java . lang . ref . ReferenceQueue ; import java . lang . reflect . Method ; import java . net . URL ; import java . net . URLClassLoader ; import java . util . logging . Level ; import java . util . logging . Logger ; public class InputCustomImportOrderTemp { }
package com . puppycrawl . tools . checkstyle . imports ; import com . puppycrawl . tools . checkstyle . imports . * ; import com . puppycrawl . tools . checkstyle . imports . InputImportBug ; import java . io . * ; import java . lang . * ; import java . lang . String ; import java . util . List ; import java . util . List ; import java . util . Iterator ; import java . util . Enumeration ; import java . util . Arrays ; import javax . swing . JToolBar ; import javax . swing . JToggleButton ; import javax . swing . ScrollPaneLayout ; import javax . swing . BorderFactory ; import static java . io . File . listRoots ; import static javax . swing . WindowConstants . * ; import static javax . swing . WindowConstants . * ; import static java . io . File . createTempFile ; import static java . io . File . pathSeparator ; import java . awt . Component ; import java . awt . Graphics2D ; import java . awt . HeadlessException ; import java . awt . Label ; import java . util . Date ; import java . util . Calendar ; import java . util . BitSet ; import com . puppycrawl . tools . checkstyle . Checker ; import com . puppycrawl . tools . checkstyle . CheckerTest ; import com . puppycrawl . tools . checkstyle . BaseFileSetCheckTestSupport ; import com . puppycrawl . tools . checkstyle . Definitions ; import com . puppycrawl . tools . checkstyle . Input15Extensions ; import com . puppycrawl . tools . checkstyle . ConfigurationLoaderTest ; import com . puppycrawl . tools . checkstyle . PackageNamesLoader ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . DefaultLogger ; import static java . lang . Math . PI ; import static com . puppycrawl . tools . checkstyle . checks . imports . RedundantImportCheck . MSG_SAME ; class InputRedundantImportCheck { private Class mUse1 = null ; private Class mUse2 = java . io . File . class ; private Class mUse3 = Iterator [ ] . class ; private Class mUse4 = java . util . Enumeration [ ] . class ; private String ftpClient = null ; { int [ ] x = { } ; Arrays . sort ( x ) ; Object obj = javax . swing . BorderFactory . createEmptyBorder ( ) ; File [ ] files = listRoots ( ) ; } private JToolBar . Separator mSep = null ; private Object mUse5 = new Object ( ) ; private Object mUse6 = new javax . swing . JToggleButton . ToggleButtonModel ( ) ; private int Component ; public void Label ( ) { } public void render ( ) { } public void aMethodWithManyLinks ( ) { } }
package com . puppycrawl . tools . checkstyle . imports ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import java . io . Reader ; import static java . io . InputStream . * ; import static java . io . IOException . * ; public class InputImportOrderCaseInsensitive { }
package com . puppycrawl . tools . checkstyle . imports ; import static java . io . File . createTempFile ; import static java . awt . Button . ABORT ; import static javax . swing . WindowConstants . * ; import com . puppycrawl . tools . * ; import java . util . StringTokenizer ; import java . util . * ; import java . util . concurrent . AbstractExecutorService ; import java . util . concurrent . * ; import com . puppycrawl . tools . * ; import com . * ; import com . google . common . * ; import org . junit . * ; public class InputCustomImportOrder3 { }
package com . puppycrawl . tools . checkstyle . grammars ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; import org . junit . Test ; public class HexFloatsTest extends BaseCheckTestSupport { @ Test public void testCanParse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "grammars/InputHexFloat.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . imports ; import org . * ; import java . util . Set ; import static java . lang . Math . * ; import static org . abego . treelayout . Configuration . * ; public class InputImportOrderStaticOnDemandGroupOrderBottom { }
package com . puppycrawl . tools . checkstyle . imports ; import static java . lang . Math . abs ; import static org . abego . treelayout . Configuration . AlignmentInLevel ; import org . * ; import java . util . Set ; public class InputImportOrderStaticGroupOrder { }
package com . puppycrawl . tools . checkstyle . imports ; import com . puppycrawl . tools . checkstyle . imports . * ; import java . io . * ; import java . lang . * ; import java . sql . Connection ; import java . util . List ; import java . util . List ; import java . lang . AbstractMethodError ; import java . util . Iterator ; import java . util . Enumeration ; import java . util . Arrays ; import javax . swing . JToolBar ; import javax . swing . JToggleButton ; import javax . swing . ScrollPaneLayout ; import javax . swing . BorderFactory ; import static java . io . File . listRoots ; import static javax . swing . WindowConstants . * ; import static javax . swing . WindowConstants . * ; import static java . io . File . createTempFile ; import static java . io . File . * ; import java . awt . Component ; import java . awt . Graphics2D ; import java . awt . HeadlessException ; import java . awt . Label ; import java . util . Date ; import java . util . Calendar ; import java . util . BitSet ; import com . puppycrawl . tools . checkstyle . Checker ; import com . puppycrawl . tools . checkstyle . CheckerTest ; import com . puppycrawl . tools . checkstyle . BaseFileSetCheckTestSupport ; import com . puppycrawl . tools . checkstyle . Definitions ; import com . puppycrawl . tools . checkstyle . Input15Extensions ; import com . puppycrawl . tools . checkstyle . ConfigurationLoaderTest ; import com . puppycrawl . tools . checkstyle . PackageNamesLoader ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . DefaultLogger ; class InputAvoidStarImportCheck { private Class mUse1 = Connection . class ; private Class mUse2 = java . io . File . class ; private Class mUse3 = Iterator [ ] . class ; private Class mUse4 = java . util . Enumeration [ ] . class ; private String ftpClient = null ; { int [ ] x = { } ; Arrays . sort ( x ) ; Object obj = javax . swing . BorderFactory . createEmptyBorder ( ) ; File [ ] files = listRoots ( ) ; } private JToolBar . Separator mSep = null ; private Object mUse5 = new Object ( ) ; private Object mUse6 = new javax . swing . JToggleButton . ToggleButtonModel ( ) ; private int Component ; public void Label ( ) { } public void render ( ) { } public void aMethodWithManyLinks ( ) { } }
package com . puppycrawl . tools . checkstyle . imports ; import com . puppycrawl . tools . checkstyle . imports . * ; import java . io . * ; import java . lang . * ; import java . sql . Connection ; import java . util . List ; import java . util . List ; import java . lang . * ; import java . util . Iterator ; import java . util . Enumeration ; import java . util . Arrays ; import javax . swing . JToolBar ; import javax . swing . JToggleButton ; import javax . swing . ScrollPaneLayout ; import javax . swing . BorderFactory ; import static java . io . File . listRoots ; import static javax . swing . WindowConstants . * ; import static javax . swing . WindowConstants . * ; import static java . io . File . createTempFile ; import static java . io . File . pathSeparator ; import static com . puppycrawl . tools . checkstyle . imports . InputAvoidStaticImportNestedClass . InnerClass ; import static com . puppycrawl . tools . checkstyle . imports . InputAvoidStaticImportNestedClass . InnerClass . one ; import java . awt . Component ; import java . awt . Graphics2D ; import java . awt . HeadlessException ; import java . awt . Label ; import java . util . Date ; import java . util . Calendar ; import java . util . BitSet ; import com . puppycrawl . tools . checkstyle . Checker ; import com . puppycrawl . tools . checkstyle . CheckerTest ; import com . puppycrawl . tools . checkstyle . BaseFileSetCheckTestSupport ; import com . puppycrawl . tools . checkstyle . Definitions ; import com . puppycrawl . tools . checkstyle . Input15Extensions ; import com . puppycrawl . tools . checkstyle . ConfigurationLoaderTest ; import com . puppycrawl . tools . checkstyle . PackageNamesLoader ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . DefaultLogger ; class InputAvoidStaticImportCheck { private Class mUse1 = Connection . class ; private Class mUse2 = java . io . File . class ; private Class mUse3 = Iterator [ ] . class ; private Class mUse4 = java . util . Enumeration [ ] . class ; private String ftpClient = null ; { int [ ] x = { } ; Arrays . sort ( x ) ; Object obj = javax . swing . BorderFactory . createEmptyBorder ( ) ; File [ ] files = listRoots ( ) ; } private JToolBar . Separator mSep = null ; private Object mUse5 = new Object ( ) ; private Object mUse6 = new javax . swing . JToggleButton . ToggleButtonModel ( ) ; private int Component ; public void Label ( ) { } public void render ( ) { } public void aMethodWithManyLinks ( ) { } }
package com . puppycrawl . tools . checkstyle . imports ; import java . awt . Button ; import java . awt . Button ; public class InputImportOrder_NoFailureForRedundantImports { }
package com . puppycrawl . tools . checkstyle . imports ; import java . awt . Button ; import java . awt . Frame ; import java . awt . Dialog ; import java . awt . event . ActionEvent ; import static java . awt . Button . ABORT ; import javax . swing . JComponent ; import javax . swing . JTable ; import java . io . File ; import static java . io . File . createTempFile ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import static javax . swing . WindowConstants . * ; public class InputImportOrder { }
package com . puppycrawl . tools . checkstyle . imports ; import java . io . File ; import java . io . IOException ; import java . util . Iterator ; import com . puppycrawl . tools . checkstyle . imports . InputImportBug ; public class InputImportOrder_WildcardUnspecified { }
package com . puppycrawl . tools . checkstyle . imports ; import static java . io . File . createTempFile ; import static java . awt . Button . ABORT ; import static javax . swing . WindowConstants . * ; import java . awt . Button ; import java . awt . Dialog ; import java . awt . Frame ; import java . awt . event . ActionEvent ; import java . io . IOException ; import java . io . InputStream ; import javax . swing . JComponent ; import javax . swing . JTable ; import static java . io . File . * ; import java . io . File ; import java . io . Reader ; public class InputImportOrder_Top { }
package com . puppycrawl . tools . checkstyle . imports ; public class InputCustomImportOrder_NoImports { }
package com . puppycrawl . tools . checkstyle . imports ; import static java . lang . Math . * ; import static org . abego . treelayout . Configuration . * ; import org . * ; import java . util . Set ; public class InputImportOrderStaticOnDemandGroupOrder { }
package com . puppycrawl . tools . checkstyle . grammars ; import java . io . File ; import java . io . IOException ; import org . apache . commons . lang3 . SystemUtils ; import org . junit . Assume ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; public class GeneratedJava14LexerTest extends BaseCheckTestSupport { @ Test public void testUnexpectedChar ( ) throws IOException , Exception { Assume . assumeFalse ( SystemUtils . IS_OS_WINDOWS ) ; final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { "7:9: Name 'ÃЯ' must match pattern '^[a-z][a-zA-Z0-9]*$'." , } ; verify ( checkConfig , getPath ( "grammars/InputGrammar.java" ) , expected ) ; } @ Test public void testSemicolonBetweenImports ( ) throws IOException , Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/grammars/SemicolonBetweenImports.java" ) . getCanonicalPath ( ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . LocalizedMessage ; import com . puppycrawl . tools . checkstyle . api . SeverityLevel ; import java . io . BufferedReader ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . List ; import java . util . regex . Pattern ; import org . junit . Test ; public class XMLLoggerTest { private final ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; @ Test public void testEncode ( ) throws IOException { final XMLLogger logger = new XMLLogger ( outStream , false ) ; final String [ ] [ ] encodings = { { "<" , "&lt;" } , { ">" , "&gt;" } , { "'" , "&apos;" } , { "\"" , "&quot;" } , { "&" , "&amp;" } , { "&lt;" , "&lt;" } , { "abc;" , "abc;" } , } ; for ( int i = 0 ; i < encodings . length ; i ++ ) { final String encoded = logger . encode ( encodings [ i ] [ 0 ] ) ; assertEquals ( "\"" + encodings [ i ] [ 0 ] + "\"" , encodings [ i ] [ 1 ] , encoded ) ; } outStream . close ( ) ; } @ Test public void testIsReference ( ) throws IOException { final XMLLogger logger = new XMLLogger ( outStream , false ) ; final String [ ] reference = { "&#0;" , "&#x0;" , } ; for ( int i = 0 ; i < reference . length ; i ++ ) { assertTrue ( "reference: " + reference [ i ] , logger . isReference ( reference [ i ] ) ) ; } final String [ ] noReference = { "&" , "&;" , "&#;" , "&#a;" , "&#X0;" , "&#x;" , "&#xg;" , } ; for ( int i = 0 ; i < noReference . length ; i ++ ) { assertFalse ( "no reference: " + noReference [ i ] , logger . isReference ( noReference [ i ] ) ) ; } outStream . close ( ) ; } @ Test public void testCloseStream ( ) throws IOException { final XMLLogger logger = new XMLLogger ( outStream , true ) ; logger . auditStarted ( null ) ; logger . auditFinished ( null ) ; final String [ ] expectedLines = { } ; verifyLines ( expectedLines ) ; } @ Test public void testNoCloseStream ( ) throws IOException { final XMLLogger logger = new XMLLogger ( outStream , false ) ; logger . auditStarted ( null ) ; logger . auditFinished ( null ) ; outStream . close ( ) ; final String [ ] expectedLines = { } ; verifyLines ( expectedLines ) ; } @ Test public void testFileStarted ( ) throws IOException { final XMLLogger logger = new XMLLogger ( outStream , true ) ; logger . auditStarted ( null ) ; final AuditEvent ev = new AuditEvent ( this , "Test.java" ) ; logger . fileStarted ( ev ) ; logger . auditFinished ( null ) ; final String [ ] expectedLines = { "<file name=\"Test.java\">" } ; verifyLines ( expectedLines ) ; } @ Test public void testFileFinished ( ) throws IOException { final XMLLogger logger = new XMLLogger ( outStream , true ) ; logger . auditStarted ( null ) ; final AuditEvent ev = new AuditEvent ( this , "Test.java" ) ; logger . fileFinished ( ev ) ; logger . auditFinished ( null ) ; final String [ ] expectedLines = { "</file>" } ; verifyLines ( expectedLines ) ; } @ Test public void testAddError ( ) throws IOException { final XMLLogger logger = new XMLLogger ( outStream , true ) ; logger . auditStarted ( null ) ; final LocalizedMessage message = new LocalizedMessage ( 1 , 1 , "messages.properties" , "key" , null , SeverityLevel . ERROR , null , this . getClass ( ) , null ) ; final AuditEvent ev = new AuditEvent ( this , "Test.java" , message ) ; logger . addError ( ev ) ; logger . auditFinished ( null ) ; final String [ ] expectedLines = { "<error line=\"1\" column=\"1\" severity=\"error\" message=\"key\" source=\"com.puppycrawl.tools.checkstyle.XMLLoggerTest\"/>" , } ; verifyLines ( expectedLines ) ; } @ Test public void testAddException ( ) throws IOException { final XMLLogger logger = new XMLLogger ( outStream , true ) ; logger . auditStarted ( null ) ; final LocalizedMessage message = new LocalizedMessage ( 1 , 1 , "messages.properties" , null , null , null , this . getClass ( ) , null ) ; final AuditEvent ev = new AuditEvent ( this , "Test.java" , message ) ; logger . addException ( ev , new TestThrowable ( ) ) ; logger . auditFinished ( null ) ; final String [ ] expectedLines = { "&lt;exception&gt;" , "&lt;![CDATA[" , "stackTrace]]&gt;" , "&lt;/exception&gt;" , "" , } ; verifyLines ( expectedLines ) ; } private String [ ] getOutStreamLines ( ) throws IOException { final byte [ ] bytes = outStream . toByteArray ( ) ; final ByteArrayInputStream inStream = new ByteArrayInputStream ( bytes ) ; final BufferedReader reader = new BufferedReader ( new InputStreamReader ( inStream ) ) ; final List < String > lineList = Lists . newArrayList ( ) ; while ( true ) { final String line = reader . readLine ( ) ; if ( line == null ) { break ; } lineList . add ( line ) ; } reader . close ( ) ; return lineList . toArray ( new String [ lineList . size ( ) ] ) ; } private void verifyLines ( String [ ] expectedLines ) throws IOException { final String [ ] lines = getOutStreamLines ( ) ; assertEquals ( "length." , expectedLines . length + 3 , lines . length ) ; assertEquals ( "first line." , "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" , lines [ 0 ] ) ; Pattern checkstyleOpenTag = Pattern . compile ( "^<checkstyle version=\".*\">$" ) ; assertTrue ( "second line." , checkstyleOpenTag . matcher ( lines [ 1 ] ) . matches ( ) ) ; for ( int i = 0 ; i < expectedLines . length ; i ++ ) { assertEquals ( "line " + i + "." , expectedLines [ i ] , lines [ i + 2 ] ) ; } assertEquals ( "last line." , "</checkstyle>" , lines [ lines . length - 1 ] ) ; } private static class TestThrowable extends Exception { @ Override public void printStackTrace ( PrintWriter s ) { s . print ( "stackTrace" ) ; } } }
package com . puppycrawl . tools . checkstyle . imports ; import java . io . File ; import javax . lang . model . SourceVersion ; import com . puppycrawl . tools . checkstyle . checks . javadoc . AbstractJavadocCheck ; public class InputCustomImportOrderImportsContainingJava { }
package com . puppycrawl . tools . checkstyle . imports ; import com . puppycrawl . tools . checkstyle . imports . InputImportOrder_Above ; import javax . crypto . BadPaddingException ; import java . util . List ; import javax . crypto . Cipher ; public class InputImportOrder_Wildcard { }
package com . puppycrawl . tools . checkstyle . imports ; public class InputAvoidStaticImportNestedClass { public static Integer zero = 0 ; public static class InnerClass { public static Integer one = 1 ; } }
package com . puppycrawl . tools . checkstyle . imports ; import java . awt . Image ; import javax . swing . border . * ; import java . io . File ; import static java . awt . Button . ABORT ; public class InputImportControl { }
package com . puppycrawl . tools . checkstyle . imports ; import com . puppycrawl . tools . checkstyle . imports . * ; import com . puppycrawl . tools . checkstyle . imports . InputImportBug ; import java . io . * ; import java . lang . * ; import java . lang . String ; import java . util . List ; import java . util . List ; import java . lang . * ; import java . util . Iterator ; import java . util . Enumeration ; import java . util . Arrays ; import javax . swing . JToolBar ; import javax . swing . JToggleButton ; import javax . swing . BorderFactory ; import static java . io . File . listRoots ; import static javax . swing . WindowConstants . * ; import static java . io . File . createTempFile ; import java . awt . Graphics2D ; import java . awt . HeadlessException ; import java . awt . Label ; import java . util . Date ; import java . util . Calendar ; import java . util . BitSet ; import com . puppycrawl . tools . checkstyle . Checker ; import com . puppycrawl . tools . checkstyle . CheckerTest ; import com . puppycrawl . tools . checkstyle . BaseFileSetCheckTestSupport ; import com . puppycrawl . tools . checkstyle . Definitions ; import com . puppycrawl . tools . checkstyle . Input15Extensions ; import com . puppycrawl . tools . checkstyle . ConfigurationLoaderTest ; import com . puppycrawl . tools . checkstyle . PackageNamesLoader ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . DefaultLogger ; class InputUnusedImportsCheck { private Class mUse1 = null ; private Class mUse2 = java . io . File . class ; private Class mUse3 = Iterator [ ] . class ; private Class mUse4 = java . util . Enumeration [ ] . class ; private Object ftpClient = null ; { int [ ] x = { } ; Arrays . sort ( x ) ; Object obj = javax . swing . BorderFactory . createEmptyBorder ( ) ; File [ ] files = listRoots ( ) ; } private JToolBar . Separator mSep = null ; private Object mUse5 = new Object ( ) ; private Object mUse6 = new javax . swing . JToggleButton . ToggleButtonModel ( ) ; private int Component ; public void Label ( ) { } public void render ( ) { } public void aMethodWithManyLinks ( ) { } }
package com . puppycrawl . tools . checkstyle . imports ; import static javax . swing . WindowConstants . DISPOSE_ON_CLOSE ; import static java . awt . Button . ABORT ; import java . awt . Dialog ; import java . awt . Button ; public class InputImportOrder_HonorsTokensProperty { }
package com . puppycrawl . tools . checkstyle . imports ; import static java . io . File . createTempFile ; import static java . awt . Button . ABORT ; import static java . awt . print . Paper . * ; import static javax . swing . WindowConstants . * ; import java . awt . Button ; import java . awt . Frame ; import java . awt . Dialog ; import java . awt . color . ColorSpace ; import java . awt . event . ActionEvent ; import javax . swing . JComponent ; import javax . swing . JTable ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import com . puppycrawl . tools . * ; import com . google . common . collect . * ; import org . junit . * ; public class InputCustomImportOrder { }
package com . puppycrawl . tools . checkstyle . imports ; import com . puppycrawl . tools . checkstyle . imports . * ; import java . io . * ; import java . lang . * ; import java . sql . Connection ; import java . util . List ; import java . util . List ; import java . lang . ArithmeticException ; import sun . applet . * ; import java . util . Enumeration ; import java . util . Arrays ; import javax . swing . JToolBar ; import javax . swing . JToggleButton ; import javax . swing . ScrollPaneLayout ; import javax . swing . BorderFactory ; import static java . io . File . listRoots ; import static javax . swing . WindowConstants . * ; import static javax . swing . WindowConstants . * ; import static java . io . File . createTempFile ; import sun . * ; import java . awt . Component ; import java . awt . Graphics2D ; import java . awt . HeadlessException ; import java . awt . Label ; import java . util . Date ; import java . util . Calendar ; import java . util . BitSet ; import com . puppycrawl . tools . checkstyle . Checker ; import com . puppycrawl . tools . checkstyle . CheckerTest ; import com . puppycrawl . tools . checkstyle . BaseFileSetCheckTestSupport ; import com . puppycrawl . tools . checkstyle . Definitions ; import com . puppycrawl . tools . checkstyle . Input15Extensions ; import com . puppycrawl . tools . checkstyle . ConfigurationLoaderTest ; import com . puppycrawl . tools . checkstyle . PackageNamesLoader ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . DefaultLogger ; class InputIllegalImportCheck { private Class mUse1 = Connection . class ; private Class mUse2 = java . io . File . class ; private Class mUse3 = null ; private Class mUse4 = java . util . Enumeration [ ] . class ; private String ftpClient = null ; { int [ ] x = { } ; Arrays . sort ( x ) ; Object obj = javax . swing . BorderFactory . createEmptyBorder ( ) ; File [ ] files = listRoots ( ) ; } private JToolBar . Separator mSep = null ; private Object mUse5 = new Object ( ) ; private Object mUse6 = new javax . swing . JToggleButton . ToggleButtonModel ( ) ; private int Component ; public void Label ( ) { } public void render ( ) { } public void aMethodWithManyLinks ( ) { } }
package com . puppycrawl . tools . checkstyle . imports ; import java . awt . Button ; import java . awt . Frame ; import java . awt . Dialog ; import java . awt . event . ActionEvent ; import javax . swing . JComponent ; import javax . swing . JTable ; import static java . awt . Button . ABORT ; import static javax . swing . WindowConstants . * ; import static java . awt . Button . ABORT ; import static java . io . File . createTempFile ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; public class InputImportOrder_Under { }
package com . puppycrawl . tools . checkstyle . imports ; import org . abego . treelayout . * ; import org . junit . * ; import java . * ; import javax . swing . * ; import static sun . tools . util . CommandLine . parse ; import static sun . tools . util . ModifierFilter . ALL_ACCESS ; import static sun . tools . util . ModifierFilter . ALL_ACCESS ; public class InputCustomImportOrderThirdPartyPackage { }
package com . puppycrawl . tools . checkstyle . grammars ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; import org . junit . Test ; public class Java7TryWithResourcesTest extends BaseCheckTestSupport { @ Test public void testCanParse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "grammars/InputJava7TryWithResources.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . imports ; import static java . awt . Button . ABORT ; import static javax . swing . WindowConstants . * ; import static java . awt . Button . ABORT ; import java . awt . Button ; import java . awt . Frame ; import java . awt . Dialog ; import java . awt . event . ActionEvent ; import javax . swing . JComponent ; import javax . swing . JTable ; import java . io . File ; import static java . io . File . createTempFile ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; public class InputImportOrder_Above { }
package com . puppycrawl . tools . checkstyle . imports ; import static java . io . File . createTempFile ; import static java . awt . Button . ABORT ; import static javax . swing . WindowConstants . * ; import java . util . List ; import java . util . StringTokenizer ; import java . util . * ; import java . util . concurrent . AbstractExecutorService ; import java . util . concurrent . * ; import com . puppycrawl . tools . * ; import com . * ; import com . google . common . * ; import org . junit . * ; public class InputCustomImportOrder2 { }
package com . puppycrawl . tools . checkstyle . imports ; import java . util . Map ; import java . util . Map . Entry ; import java . util . NoSuchElementException ; public class InputCustomImportOrderNoValid { }
package com . puppycrawl . tools . checkstyle . imports ; import java . net . URL ; public class InputImportBug { private static String URL = "This is a String object" ; public InputImportBug ( ) throws Exception { URL url = new URL ( "file://this.is.a.url.object" ) ; } }
package com . puppycrawl . tools . checkstyle . grammars ; public class LineCommentAtTheEndOfFile { }
package com . puppycrawl . tools . checkstyle . grammars ; public class InputEmbeddedNullChar { public void doSomething ( ) { String cctCxlMsg = ":ET:OE:}} " ; } }
package com . puppycrawl . tools . checkstyle . grammars ; import java . lang . reflect . GenericArrayType ; import java . lang . reflect . GenericDeclaration ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . lang . reflect . TypeVariable ; import java . lang . reflect . WildcardType ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class MultiDimensionalArraysInGenericsTestInput { @ SuppressWarnings ( "unused" ) void withUpperBound ( List < ? extends int [ ] [ ] > list ) { } @ SuppressWarnings ( "unused" ) void withLowerBound ( List < ? super String [ ] [ ] > list ) { } @ SuppressWarnings ( "unused" ) void withLowerBound2 ( List < ? super String [ ] [ ] [ ] > list ) { } static WildcardType getWildcardType ( String methodName ) throws Exception { ParameterizedType parameterType = ( ParameterizedType ) WildcardType . class . getDeclaredMethod ( methodName , List . class ) . getGenericParameterTypes ( ) [ 0 ] ; return ( WildcardType ) parameterType . getActualTypeArguments ( ) [ 0 ] ; } }
package com . puppycrawl . tools . checkstyle . grammars ; public class InputGrammar { int Я = 1 ; }
package com . puppycrawl . tools . checkstyle . grammars ; public class InputJava7StringSwitch { public static void main ( String [ ] args ) { String mystr = "value" + "2" ; switch ( mystr ) { case "value1" : break ; case "value2" : break ; default : break ; } } }
package com . puppycrawl . tools . checkstyle . grammars ; class EofBug1667137 { void checkstyleIsBroken ( ) { EofBug1667137 borkage = new EofBug1667137 ( ) { < T extends EofBug1667137 > T borked ( T brokenness ) { return brokenness ; } } ; } }
package com . puppycrawl . tools . checkstyle . grammars ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; import org . junit . Test ; public class Java7StringSwitchTest extends BaseCheckTestSupport { @ Test public void testCanParse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "grammars/InputJava7StringSwitch.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . grammars ; import java . io . * ; public class InputJava7MultiCatch { public static class CustomException extends Exception { } public static class AnotherCustomException extends RuntimeException { } public static void logException ( Exception e ) { } public static void main ( String [ ] args ) { try { FileInputStream in = new FileInputStream ( "InputJava7MultiCatch.java" ) ; throw new CustomException ( ) ; } catch ( FileNotFoundException | CustomException e ) { logException ( e ) ; } try { FileInputStream in = new FileInputStream ( "InputJava7MultiCatch.java" ) ; throw new CustomException ( ) ; } catch ( final FileNotFoundException | CustomException | com . puppycrawl . tools . checkstyle . grammars . InputJava7MultiCatch . AnotherCustomException e ) { logException ( e ) ; } } }
package com . puppycrawl . tools . checkstyle . grammars ; import java . util . * ; public class InputJava7Diamond { HashMap < String , Integer > map = new HashMap < String , Integer > ( ) ; HashMap < String , Integer > map2 = new HashMap < > ( ) ; HashMap < String , HashMap < Integer , Integer > > map3 = new HashMap < > ( ) ; ArrayList < String > list = new ArrayList < > ( ) ; }
package com . puppycrawl . tools . checkstyle . grammars ; public class UnicodeEscape { char a = char b = char c = char d = uu005cn char e = u005c char f = '\u005c' char g = '"' ; String h = "\u005c" "; String i = " char j = '\"' ; String k = "\'" ; char l = '\u005C' char m = '\uABCD' ; char n = '\u00AB' ; char o = '\u005B' ; char p = uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu005cr // Tests the lookahead char q = uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu005D char wtf1 = u005c // This is a legal backslash String wtf2 = "\\u005c" ; // = "\u005c", with a single backslash, and != a backslash! // There is an ambiguity in the grammar, the interpretation is done as "\\" + "u005c" //char wtf3 = '\\u005c'; // This is therefore, illegal //char z = '\u005cu005c'; /* This is illegal */ }
package com . puppycrawl . tools . checkstyle . grammars ; public class InputVararg { public static void main ( String ... args ) { } }
package com . puppycrawl . tools . checkstyle . grammars ; public class InputHexFloat { double f1 = 0x.0P10 ; double f2 = 0x1.P-1 ; double f3 = 0Xab1P0 ; double f4 = 0Xab1ap+20 ; double f5 = 0Xab1ap+20D ; double f6 = 0Xab1ap+20d ; double f7 = 0Xab1ap+20f ; double f8 = 0Xab1ap+20F ; }
package com . puppycrawl . tools . checkstyle . grammars ; public class InputJava7TryWithResources { public static class MyResource implements AutoCloseable { @ Override public void close ( ) throws Exception { } } public static void main ( String [ ] args ) throws Exception { try ( MyResource resource = new MyResource ( ) ) { } try ( MyResource resource = new MyResource ( ) ) { } finally { } try ( MyResource resource = new MyResource ( ) ; ) { } catch ( Exception e ) { } try ( MyResource resource = new MyResource ( ) ; ) { } catch ( Exception e ) { } catch ( Throwable t ) { } finally { } try ( MyResource resource = new MyResource ( ) ; MyResource resource2 = new MyResource ( ) ) { } catch ( Exception e ) { } catch ( Throwable t ) { } finally { } try ( MyResource resource = new MyResource ( ) ; MyResource resource2 = new MyResource ( ) ; ) { } catch ( Exception e ) { } catch ( Throwable t ) { } finally { } try ( @ SuppressWarnings ( "all" ) final MyResource resource = new MyResource ( ) ) { } } }
package com . puppycrawl . tools . checkstyle . grammars ; import java . util . List ; import java . util . ArrayList ; class Bug3553541 { List < ? super long [ ] > a ; { a = new ArrayList < long [ ] > ( ) ; } List < ? super Integer [ ] > b ; { b = new ArrayList < Integer [ ] > ( ) ; } }
package com . puppycrawl . tools . checkstyle . grammars ; public class InputJava7NumericalLiterals { int i1 = 0b00011110 ; int i2 = 0B00011110 ; int i3 = 0xA ; int i4 = 0x1___A_F ; int i5 = 0b1 ; int i6 = 0b1___1_0 ; int i7 = 0 ; int i8 = 02 ; int i9 = 0_123 ; int i10 = 1 ; int i11 = 1___3 ; int i12 = 1_43_43598_7 ; long l1 = 0b00011110L ; long l2 = 0B00011110l ; long l3 = 0xAL ; long l4 = 0x1___A_FL ; long l5 = 0b1L ; long l6 = 0b1___1_0L ; long l7 = 0l ; long l8 = 02L ; long l9 = 0_123l ; long l10 = 1l ; long l11 = 1___3l ; long l12 = 1_43_43598_7L ; long l13 = 1_43_43598_7 ; float f1 = .1f ; float f2 = ( float ) 1. ; float f3 = 0f ; float f4 = ( float ) 1e0 ; float f5 = 1e0f ; float f6 = 12.345F ; float f7 = ( float ) .5____2_1 ; float f8 = ( float ) 1__42__3. ; float f9 = 0__2_4__324f ; float f10 = ( float ) 1_34e0 ; float f11 = 1__1_2e0f ; float f12 = 2_1___2.3__4_5F ; float f13 = ( float ) 1_34e0__4__3 ; float f14 = 1__1_2e00__000_4f ; float f15 = 2_1___2.3__4_5e00______0_5F ; double d1 = .1d ; double d2 = 1.D ; double d3 = 0d ; double d4 = 1e0D ; double d5 = 1e0d ; double d6 = 12.345D ; double d7 = .5____2_1d ; double d8 = 1__42__3.D ; double d9 = 0__2_4__324d ; double d10 = 1_34e0d ; double d11 = 1__1_2e0d ; double d12 = 2_1___2.3__4_5D ; double d13 = 1_34e0__4__3d ; double d14 = 1__1_2e00__000_4d ; double d15 = 2_1___2.3__4_5e00______0_5D ; double d16 = 0.12___34 ; float hf1 = ( float ) 0x.1___AFp1 ; float hf2 = 0x.1___AFp0__0__0f ; float hf3 = 0x2__3_34.4___AFP00_00f ; double hd1 = 0x.1___AFp1 ; double hd2 = 0x.1___AFp0__0__0d ; double hd3 = 0x2__3_34.4___AFP00_00d ; int doc1 = 1234_5678 ; long doc2 = 1_2_3_4__5_6_7_8L ; int doc3 = 0b0001_0010_0100_1000 ; double doc4 = 3.141_592_653_589_793d ; double doc5 = 0x1.ffff_ffff_ffff_fP1_023 ; }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; public class InputDefaultMethodsTest2 { public void doSomething ( ) { int a = 5 ; switch ( a ) { case 0 : break ; default : break ; } } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . util . List ; public class InputAnnotationsTest1 { @ NonNull List < Integer > numbers ; @ interface NonNull { } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; public class LambdaTest extends BaseCheckTestSupport { @ Test public void testLambdaInVariableInitialization ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest1.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithoutArgsOneLineLambdaBody ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest2.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithoutArgsFullLambdaBody ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest3.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithOneArgWithOneLineBody ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest4.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithOneArgWithFullBody ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest5.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithOneArgWIthoutTypeOneLineBody ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest6.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithOneArgWIthoutTypeFullBody ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest7.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithFewArgsWithoutTypeOneLineBody ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest8.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithFewArgsWithoutTypeFullBody ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest9.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithOneArgWIthoutParenthesesWithoutTypeOneLineBody ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest10.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithOneArgWIthoutParenthesesWithoutTypeFullBody ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest11.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithFewArgWIthTypeOneLine ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest12.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithFewArgWithTypeFullBody ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest13.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWIthMultilineBody ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest14.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testCasesFromSpec ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest15.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testWithTypecast ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest16.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testInAssignment ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest17.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testInTernary ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/grammars/java8/InputLambdaTest18.java" ) . getCanonicalPath ( ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputBraceAdjustment { public InputBraceAdjustment ( ) { boolean uglyGnuStyle = true ; if ( uglyGnuStyle ) { System . out . println ( "ugly GNU style braces" ) ; } } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputInvalidBlockIndent { public InputInvalidBlockIndent ( ) { } public void method1 ( ) { { } { } { } { } { } { } { int var = 3 ; var += 3 ; } { int var = 3 ; var += 3 ; } { int var = 5 ; } { int var = 3 ; var += 3 ; { int innerVar = 4 ; innerVar += var ; } } { int var = 3 ; var += 3 ; { int innerVar = 4 ; innerVar += var ; } } { int var = 3 ; var += 3 ; { int innerVar = 4 ; innerVar += var ; } } } static { int var = 4 ; } static { int var = 4 ; } static { int var = 4 ; } static { int var = 4 ; } static { int var = 4 ; } static { int var = 4 ; } static { int var = 4 ; } static { int var = 4 ; } static { int var = 4 ; } static { int var = 4 ; } { int var = 4 ; } { int var = 4 ; } { int var = 4 ; } { int var = 4 ; } { int var = 4 ; } }
package com . puppycrawl . tools . checkstyle . indentation ; import java . util . AbstractMap ; import java . util . Set ; import java . util . concurrent . ConcurrentMap ; import org . antlr . v4 . runtime . misc . Nullable ; import com . google . common . base . Equivalence ; class LocalCache < K , V > extends AbstractMap < K , V > implements ConcurrentMap < K , V > { enum Strength { STRONG { < K , V > Object referenceValue ( Segment < K , V > segment , ReferenceEntry < K , V > entry , int value , int weight ) { return ( weight == 1 ) ? new StrongValueReference < K , V > ( value ) : new WeightedStrongValueReference < K , V > ( value , weight ) ; } @ Override Equivalence < Object > defaultEquivalence ( ) { return Equivalence . equals ( ) ; } @ Override < K , V > ValueReference < K , V > referenceValue ( Segment < K , V > segment , ReferenceEntry < K , V > entry , V value , int weight ) { return null ; } } , SOFT { < K , V > Object referenceValue1 ( Segment < K , V > segment , ReferenceEntry < Integer , Integer > entry , int value , int weight ) { return ( weight == 1 ) ? new SoftValueReference < K , V > ( segment . valueReferenceQueue , value , entry ) : new WeightedSoftValueReference < K , V > ( ) ; } @ Override Equivalence < Object > defaultEquivalence ( ) { return Equivalence . identity ( ) ; } @ Override < K , V > Object referenceValue ( Segment < K , V > segment , ReferenceEntry < K , V > entry , V value , int weight ) { return null ; } } , WEAK { @ Override < K , V > Object referenceValue ( Segment < K , V > segment , ReferenceEntry < K , V > entry , V value , int weight ) { return ( weight == 1 ) ? new WeakValueReference < K , V > ( ) : new WeightedWeakValueReference < K , V > ( ) ; } @ Override Equivalence < Object > defaultEquivalence ( ) { return Equivalence . identity ( ) ; } } ; abstract < K , V > Object referenceValue ( Segment < K , V > segment , ReferenceEntry < K , V > entry , V value , int weight ) ; abstract Equivalence < Object > defaultEquivalence ( ) ; } enum EntryFactory { STRONG { < K , V > StrongEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @ Nullable ReferenceEntry < K , V > next ) { return new StrongEntry < K , V > ( ) ; } } , STRONG_ACCESS { < K , V > StrongAccessEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @ Nullable ReferenceEntry < K , V > next ) { return new StrongAccessEntry < K , V > ( key , hash , next ) ; } < K , V > ReferenceEntry < K , V > copyEntry ( Segment < K , V > segment , ReferenceEntry < K , V > original , ReferenceEntry < K , V > newNext ) { return newNext ; } { ; } } , STRONG_WRITE { < K , V > StrongEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @ Nullable ReferenceEntry < K , V > next ) { return new StrongEntry < K , V > ( ) ; } < K , V > ReferenceEntry < K , V > copyEntry ( Segment < K , V > segment , ReferenceEntry < K , V > original , ReferenceEntry < K , V > newNext ) { return newNext ; } } , STRONG_ACCESS_WRITE { < K , V > StrongEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @ Nullable ReferenceEntry < K , V > next ) { return new StrongEntry < K , V > ( ) ; } < K , V > ReferenceEntry < K , V > copyEntry ( Segment < K , V > segment , ReferenceEntry < K , V > original , ReferenceEntry < K , V > newNext ) { return newNext ; } } , WEAK { < K , V > StrongEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @ Nullable ReferenceEntry < K , V > next ) { return new StrongEntry < K , V > ( ) ; } } , WEAK_ACCESS { < K , V > StrongEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @ Nullable ReferenceEntry < K , V > next ) { return new StrongEntry < K , V > ( ) ; } < K , V > ReferenceEntry < K , V > copyEntry ( Segment < K , V > segment , ReferenceEntry < K , V > original , ReferenceEntry < K , V > newNext ) { return newNext ; } } , WEAK_WRITE { < K , V > StrongEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @ Nullable ReferenceEntry < K , V > next ) { return new StrongEntry < K , V > ( ) ; } < K , V > ReferenceEntry < K , V > copyEntry ( Segment < K , V > segment , ReferenceEntry < K , V > original , ReferenceEntry < K , V > newNext ) { return newNext ; } } , WEAK_ACCESS_WRITE { < K , V > StrongEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @ Nullable ReferenceEntry < K , V > next ) { return new StrongEntry < K , V > ( ) ; } < K , V > ReferenceEntry < K , V > copyEntry ( Segment < K , V > segment , ReferenceEntry < K , V > original , ReferenceEntry < K , V > newNext ) { return newNext ; } } ; } @ Override public Set < java . util . Map . Entry < K , V > > entrySet ( ) { return null ; } @ Override public V putIfAbsent ( K key , V value ) { return null ; } @ Override public boolean remove ( Object key , Object value ) { return false ; } @ Override public boolean replace ( K key , V oldValue , V newValue ) { return false ; } @ Override public V replace ( K key , V value ) { return null ; } private static class ValueReference < T1 , T2 > { } private static class ReferenceEntry < T1 , T2 > { } private static class Segment < T1 , T2 > { protected Object valueReferenceQueue ; } private static class StrongAccessEntry < T1 , T2 > { public StrongAccessEntry ( T1 key , int hash , ReferenceEntry < T1 , T2 > next ) { } } private static class StrongValueReference < T1 , T2 > { public StrongValueReference ( int value ) { } } private static class WeightedStrongValueReference < T1 , T2 > { public WeightedStrongValueReference ( int value , int weight ) { } } private static class SoftValueReference < T1 , T2 > { public SoftValueReference ( Object valueReferenceQueue , int value , ReferenceEntry < Integer , Integer > entry ) { } } private static class WeightedSoftValueReference < T1 , T2 > { } private static class WeakValueReference < T1 , T2 > { } private static class WeightedWeakValueReference < T1 , T2 > { } private static class StrongEntry < T1 , T2 > { } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputValidDoWhileIndent { public InputValidDoWhileIndent ( ) { } public void method1 ( ) { boolean test = true ; do System . getProperty ( "foo" ) ; while ( test ) ; do System . getProperty ( "foo" ) ; while ( test ) ; do { } while ( test ) ; do { } while ( test ) ; do { System . getProperty ( "foo" ) ; } while ( test ) ; do { System . getProperty ( "foo" ) ; } while ( test ) ; do { System . getProperty ( "foo" ) ; } while ( test ) ; do { System . getProperty ( "foo" ) ; System . getProperty ( "foo" ) ; } while ( test ) ; do { System . getProperty ( "foo" ) ; System . getProperty ( "foo" ) ; } while ( test ) ; do { if ( test ) { System . getProperty ( "foo" ) ; } System . getProperty ( "foo" ) ; } while ( test ) ; do System . getProperty ( "foo" ) ; while ( test ) ; if ( test ) { do System . getProperty ( "foo" ) ; while ( test ) ; } do { } while ( test && 7 < 8 && 5 < 6 && 9 < 10 ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; import java . util . Arrays ; public class InputInvalidMethodIndent { public InputInvalidMethodIndent ( ) { } public InputInvalidMethodIndent ( int dummy ) { } public void method ( ) { } public void method2 ( ) { } public int method2 ( int x , int y , int w , int h ) { return 1 ; } public void method2 ( int x , int y , int w , int h , int x1 , int y1 , int w1 , int h1 ) { } public void method3 ( int x , int y , int w , int h , int x1 , int y1 , int w1 , int h1 ) { System . getProperty ( "foo" ) ; } public void method4 ( int x , int y , int w , int h , int x1 , int y1 , int w1 , int h1 ) { boolean test = true ; if ( test ) { System . getProperty ( "foo" ) ; } } public final void method5 ( ) { boolean test = true ; if ( test ) { System . getProperty ( "foo" ) ; } } public final void method6 ( ) { boolean test = true ; if ( test ) { System . getProperty ( "foo" ) ; } } public InputInvalidMethodIndent ( int dummy , int dummy2 ) { System . getProperty ( "foo" ) ; } void method6a ( ) { boolean test = true ; if ( test ) { System . getProperty ( "foo" ) ; } System . out . println ( "methods are: " + Arrays . asList ( new String [ ] { "method" } ) . toString ( ) ) ; System . out . println ( "methods are: " + Arrays . asList ( new String [ ] { "method" } ) . toString ( ) ) ; System . out . println ( "methods are: " + Arrays . asList ( new String [ ] { "method" } ) . toString ( ) ) ; System . out . println ( "methods are: " + Arrays . asList ( new String [ ] { "method" } ) . toString ( ) ) ; String blah = ( String ) System . getProperty ( new String ( "type" ) ) ; String blah1 = ( String ) System . getProperty ( new String ( "type" ) ) ; System . out . println ( "methods are: " + Arrays . asList ( new String [ ] { "method" } ) . toString ( ) ) ; } private void myfunc2 ( int a , int b , int c , int d , int e , int f , int g ) { } private int myfunc3 ( int a , int b , int c , int d ) { return 1 ; } private void myMethod ( ) { myfunc2 ( 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; myfunc2 ( 3 , 4 , method2 ( 3 , 4 , 5 , 6 ) + 5 , 6 , 7 , 8 , 9 ) ; System . out . toString ( ) . equals ( "blah" ) ; } private void myFunc ( ) throws Exception { } void method7 ( ) { return ; } void method8 ( ) { throw new RuntimeException ( "" ) ; } public int [ ] method9 ( ) { return null ; } private int [ ] getArray ( ) { return new int [ ] { 1 } ; } private void indexTest ( ) { getArray ( ) [ 0 ] = 2 ; } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputZeroCaseLevel { protected void begin ( ) { int i = 0 ; switch ( i ) { case 1 : i ++ ; default : i ++ ; } } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputValidWhileIndent { public InputValidWhileIndent ( ) { } private void method1 ( ) { boolean test = true ; while ( test ) System . getProperty ( "foo" ) ; while ( test ) System . getProperty ( "foo" ) ; while ( test ) { } while ( test ) { } while ( test ) { System . getProperty ( "foo" ) ; } while ( test ) { System . getProperty ( "foo" ) ; } while ( test ) { System . getProperty ( "foo" ) ; System . getProperty ( "foo" ) ; } while ( test ) { System . getProperty ( "foo" ) ; System . getProperty ( "foo" ) ; } while ( test ) { if ( test ) { System . getProperty ( "foo" ) ; } System . getProperty ( "foo" ) ; } while ( test ) System . getProperty ( "foo" ) ; if ( test ) { while ( test ) System . getProperty ( "foo" ) ; } while ( test && 4 < 7 && 8 < 9 && 3 < 4 ) { } } }
package com . puppycrawl . tools . checkstyle . indentation ; class InputLabels { void foo ( ) { while ( true ) { } } void foo2 ( ) { positions : while ( true ) { } } void foo3 ( ) { OUT1 : for ( ; ; ) { if ( true ) { break OUT1 ; } } } void foo4 ( ) { OUT1 : for ( ; ; ) { if ( true ) { break OUT1 ; } } } void fooo ( ) { IN : if ( true ) { } } void fooo1 ( ) { IN : if ( true ) { } } void foooo ( ) { IN : do { } while ( true ) ; } void foooo1 ( ) { IN : do { } while ( true ) ; } class Inner { void foo ( ) { OUT : while ( true ) { } } void foo2 ( ) { positions : while ( true ) { } } void foo5 ( ) { OUT1 : for ( ; ; ) { if ( true ) { break OUT1 ; } } } void foo6 ( ) { OUT1 : for ( ; ; ) { if ( true ) { break OUT1 ; } } } void fooo11 ( ) { IN : if ( true ) { } } void fooo12 ( ) { IN : if ( true ) { } } void foooo3 ( ) { IN : do { } while ( true ) ; } void foooo4 ( ) { IN : do { } while ( true ) ; } } InputLabels anon = new InputLabels ( ) { void foo ( ) { OUT : while ( true ) { } } void foo2 ( ) { positions : while ( true ) { } } void foo5 ( ) { OUT1 : for ( ; ; ) { if ( true ) { break OUT1 ; } } } void foo6 ( ) { OUT1 : for ( ; ; ) { if ( true ) { break OUT1 ; } } } void fooo11 ( ) { IN : if ( true ) { } } void fooo12 ( ) { IN : if ( true ) { } } void foooo3 ( ) { IN : do { } while ( true ) ; } void foooo4 ( ) { IN : do { } while ( true ) ; } } ; }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputMethodCallLineWrap { void foo ( ) { new String ( ) . substring ( 0 , 100 ) . substring ( 0 , 50 ) ; } class InnerFoo { void foo ( ) { new String ( ) . substring ( 0 , 100 ) . substring ( 0 , 50 ) ; } } InnerFoo anon = new InnerFoo ( ) { void foo ( ) { new String ( ) . substring ( 0 , 100 ) . substring ( 0 , 50 ) ; } } ; }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputSwitchCustom { private static final int ABC1 = 0 ; private static final int ABC2 = 0 ; private static final int ABC3 = 0 ; public int getValue ( int value ) { switch ( value ) { case 0 : return ABC1 ; case 1 : return ABC2 ; case 2 : return ABC3 ; } return 0 ; } public int getValue1 ( int value ) { switch ( value ) { case 0 : return ABC1 ; case 1 : return ABC2 ; case 2 : return ABC3 ; } return 0 ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; public class DefaulMethodsTest extends BaseCheckTestSupport { @ Test public void testCanParse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/checkstyle/" + "grammars/java8/" + "InputDefaultMethodsTest.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testSwitch ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "grammars/java8/InputDefaultMethodsTest2.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputValidCommaIndent { public InputValidCommaIndent ( ) { } public void method1 ( int x , int y , int z ) { boolean test = true ; int i , j = 2 , k = 4 , l , m = 4 ; boolean longVarName = true ; boolean myotherLongVariableName = false ; if ( j == 2 || longVarName == true || myotherLongVariableName == true || myotherLongVariableName == false || longVarName == true ) { } if ( ( j == 2 && k == 3 ) || test ) { System . out . println ( "test" ) ; } } public void method1 ( int a , int x , int y , int z ) { } }
package com . puppycrawl . tools . checkstyle . indentation ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import javax . swing . JButton ; public class InputValidClassDefIndent extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } class InputValidClassDefIndent2 extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } class InputValidClassDefIndent3 extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } final class InputValidClassDefIndent4 extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } final class InputValidClassDefIndent4a extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } final class InputValidClassDefIndent5 extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } final class InputValidClassDefIndent6 extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { class foo { } class foo2 { public int x ; } class foo3 { public int x ; } class foo4 { public int x ; } private void myMethod ( ) { class localFoo { } class localFoo2 { int x ; int func ( ) { return 3 ; } } new JButton ( ) . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { } } ) ; new JButton ( ) . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { int i = 2 ; } } ) ; Object o = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { } } ; myfunc2 ( 10 , 10 , 10 , myfunc3 ( 11 , 11 , 11 , 11 ) , 10 , 10 , 10 ) ; } private void myfunc2 ( int a , int b , int c , int d , int e , int f , int g ) { } private int myfunc3 ( int a , int b , int c , int d ) { return 1 ; } public static final Operator LT_OR_EQUAL = new Operator ( "<=" , new OperatorHelper ( ) { public boolean compare ( int value1 , int value2 ) { return ( value1 <= value2 ) ; } public boolean compare ( Comparable obj1 , Comparable obj2 ) { return ( obj1 . compareTo ( obj2 ) <= 0 ) ; } } ) ; } class HashingContainer < K , V > { @ Deprecated public Object [ ] table ; @ Override public String toString ( ) { return "" ; } } class Operator { public Operator ( String str , OperatorHelper handler ) { } } class OperatorHelper { }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputValidArrayInitIndent { private static char [ ] sHexChars = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; int [ ] array = new int [ ] { 1 , 2 , 3 } ; int [ ] array2 = new int [ ] { 1 , 2 , 3 } ; int [ ] array3 = new int [ ] { 1 , 2 , 3 } ; int [ ] array4 = new int [ ] { 1 , 2 , 3 } ; int [ ] array5 = new int [ ] { 1 , 2 , 3 } ; int [ ] array6 = new int [ ] { 1 , 2 , 3 } ; int [ ] array6a = new int [ ] { 1 , 2 , 3 , 4 } ; int [ ] array7 = new int [ ] { 1 , 2 , 3 } ; String [ ] [ ] mStuff = new String [ ] [ ] { { "key" , "value" } } ; String [ ] [ ] mStuff1 = new String [ ] [ ] { { "key" , "value" } } ; int [ ] array8 = new int [ ] { } ; int [ ] array9 = new int [ ] { } ; int [ ] [ ] array10 = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 } , new int [ ] { 1 , 2 , 3 } , } ; int [ ] [ ] array10b = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 } , new int [ ] { 1 , 2 , 3 } , } ; private void func1 ( int [ ] arg ) { char [ ] sHexChars2 = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; char [ ] sHexChars3 = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; char [ ] sHexChars4 = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; } public InputValidArrayInitIndent ( ) { func1 ( new int [ ] { 1 , 2 } ) ; func1 ( new int [ ] { } ) ; func1 ( new int [ ] { 1 , 2 , 3 } ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; import javax . swing . border . BevelBorder ; public class InputValidDotIndent { public InputValidDotIndent ( ) { System . out . println ( ) ; System . out . println ( ) ; System . out . println ( ) ; System . out . println ( ) ; System . out . println ( ) ; BevelBorder border = new javax . swing . border . BevelBorder ( BevelBorder . LOWERED ) ; border = new javax . swing . border . BevelBorder ( BevelBorder . LOWERED ) ; border = new javax . swing . border . BevelBorder ( BevelBorder . LOWERED ) ; border = new javax . swing . border . BevelBorder ( BevelBorder . LOWERED ) ; border = new javax . swing . border . BevelBorder ( BevelBorder . LOWERED ) ; border = new javax . swing . border . BevelBorder ( BevelBorder . LOWERED ) ; Class c = javax . swing . plaf . metal . MetalButtonUI . class ; Class c1 = javax . swing . plaf . metal . MetalButtonUI . class ; Class c2 = javax . swing . plaf . metal . MetalButtonUI . class ; Class c3 = javax . swing . plaf . metal . MetalButtonUI . class ; Class c4 = javax . swing . plaf . metal . MetalButtonUI . class ; border = new javax . swing . border . BevelBorder ( BevelBorder . LOWERED ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputInvalidIfIndent { public InputInvalidIfIndent ( ) { } public InputInvalidIfIndent ( int dummy ) { } public void method ( ) { } public void method2 ( ) { } public void method2 ( int x , int y , int w , int h ) { } public void method2 ( int x , int y , int w , int h , int x1 , int y1 , int w1 , int h1 ) { } public void emptyIfTest ( ) { boolean test = true ; if ( test ) { } if ( test ) { } if ( test ) { } if ( test ) { } else { } if ( test ) { } else { } if ( test ) { } else { } if ( test ) { } else { } if ( test ) { } else { } if ( test ) { } else { } } public void populatedIfTest ( ) { boolean test = false ; if ( test ) System . getProperty ( "blah" ) ; if ( test ) System . getProperty ( "blah" ) ; else System . getProperty ( "blah" ) ; if ( test ) { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } else { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; System . getProperty ( "blah" ) ; } else { System . getProperty ( "blah" ) ; System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } else { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } else { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } else { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } else { System . getProperty ( "blah" ) ; } if ( test && 7 < 8 && 8 < 9 && 10 < 11 ) { } if ( test ) return ; if ( test ) { } else if ( 7 < 8 ) { } else if ( 8 < 9 ) { } if ( test ) { System . getProperty ( "blah" ) ; } else if ( 7 < 8 ) { System . getProperty ( "blah" ) ; } else if ( 8 < 9 ) { System . getProperty ( "blah" ) ; } if ( test ) System . getProperty ( "blah" ) ; else if ( 7 < 8 ) System . getProperty ( "blah" ) ; else if ( 8 < 9 ) System . getProperty ( "blah" ) ; if ( test ) { System . getProperty ( "blah" ) ; } else if ( 7 < 8 ) { System . getProperty ( "blah" ) ; } else if ( 8 < 9 ) { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } } public void parenIfTest ( ) { boolean test = true ; if ( test ) { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputValidIfIndent { public void emptyIfTest ( ) { boolean test = true ; if ( test ) { } if ( test ) { } if ( test ) { } else { } if ( test ) { } else { } if ( test ) { } else { } if ( test ) { } else { } if ( test ) { } else { } if ( test ) { } else { } if ( foo ( ) || test || test ) { } } public void populatedIfTest ( ) { boolean test = false ; if ( test ) System . getProperty ( "blah" ) ; if ( test ) System . getProperty ( "blah" ) ; else System . getProperty ( "blah" ) ; if ( test ) { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } else { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; System . getProperty ( "blah" ) ; } else { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } else { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } else { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } else { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } else { System . getProperty ( "blah" ) ; } if ( test ) System . getProperty ( "blah" ) ; if ( test ) System . getProperty ( "blah" ) ; else System . getProperty ( "foo" ) ; if ( test ) System . getProperty ( "blah" ) ; else System . getProperty ( "foo" ) ; if ( test ) System . getProperty ( "blah" ) ; else System . getProperty ( "foo" ) ; if ( test && 7 < 8 && 8 < 9 && 10 < 11 ) { } if ( test ) return ; if ( test ) { } else if ( 7 < 8 ) { } else if ( 8 < 9 ) { } if ( test ) { System . getProperty ( "blah" ) ; } else if ( 7 < 8 ) { System . getProperty ( "blah" ) ; } else if ( 8 < 9 ) { System . getProperty ( "blah" ) ; } if ( test ) System . getProperty ( "blah" ) ; else if ( 7 < 8 ) System . getProperty ( "blah" ) ; else if ( 8 < 9 ) System . getProperty ( "blah" ) ; if ( test ) { System . getProperty ( "blah" ) ; } else if ( 7 < 8 ) { System . getProperty ( "blah" ) ; } else if ( 8 < 9 ) { System . getProperty ( "blah" ) ; } } public void parenIfTest ( ) { boolean test = true ; if ( test ) { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } if ( test ) { System . getProperty ( "blah" ) ; } if ( test ) { } } boolean foo ( ) { return true ; } } class FooFoo { void foo42 ( ) { boolean test = false ; if ( test ) { System . getProperty ( "blah" ) ; } else if ( 7 < 8 && 8 < 9 ) { System . getProperty ( "blah" ) ; } else if ( 8 < 9 ) { System . getProperty ( "blah" ) ; } } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputUseTabs { public InputUseTabs ( ) { boolean test = true ; if ( test ) { while ( test == false ) { System . exit ( 2 ) ; } } System . exit ( 3 ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; @ MyAnnotation1 public class InputAnonymousClasses { public InputAnonymousClasses ( String longString , String secondLongString ) { } public boolean foo ( ) { return false ; } void foo2 ( StrangeInstance instance ) { } } class WithAnonnymousClass { public static final InputAnonymousClasses anon = new InputAnonymousClasses ( "Looooooooooooooooong" , "SecondLoooooooooooong" ) { @ Override public boolean foo ( ) { return false ; } } ; InputAnonymousClasses foo ( ) { return new InputAnonymousClasses ( "Loooooooooooooooong" , "SecondLoooooooooong" ) { @ Override public boolean foo ( ) { InputAnonymousClasses InputAnonymousClasses = new InputAnonymousClasses ( "" , "" ) ; InputAnonymousClasses . equals ( new StrangeInstance ( new InputAnonymousClasses ( "" , "" ) ) { @ Override void foo ( String loongString , String secondLongString ) { } } ) ; return false ; } } ; } } class StrangeInstance { public StrangeInstance ( InputAnonymousClasses InputAnonymousClasses ) { } void foo ( String loongString , String secondLongString ) { } } @ interface MyAnnotation1 { }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputCaseLevel { public InputCaseLevel ( ) { int test = 4 ; switch ( test ) { case 4 : break ; case 2 : break ; default : break ; } } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputMethodCStyle { public InputMethodCStyle ( int appleCount , int bananaCount , int pearsCount ) { } public InputMethodCStyle ( String appleCount , int bananaCount , int pearsCount ) { } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; public class AnnotationTest extends BaseCheckTestSupport { @ Test public void testSimpleTypeAnnotation ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "grammars/java8/InputAnnotationsTest1.java" ) , expected ) ; } @ Test public void testAnnotationOnClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/grammars/java8/" + "InputAnnotationsTest2.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testClassCastTypeAnnotation ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/grammars/java8/" + "InputAnnotationsTest3.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testMethodParametersTypeAnnotation ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/grammars/java8/" + "InputAnnotationsTest4.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testAnnotationInThrows ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/grammars/java8/" + "InputAnnotationsTest5.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testAnnotationInGeneric ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/grammars/java8/" + "InputAnnotationsTest6.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testAnnotationOnConstructorCall ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/grammars/java8/" + "InputAnnotationsTest7.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testAnnotationNestedCall ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/grammars/java8/" + "InputAnnotationsTest8.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testAnnotationOnWildcards ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/grammars/java8/" + "InputAnnotationsTest9.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testAnnotationInCatchParameters ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/grammars/java8/" + "InputAnnotationsTest10.java" ) . getCanonicalPath ( ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputValidLabelIndent { public InputValidLabelIndent ( ) { boolean test = true ; while ( test ) { label : System . out . println ( "label test" ) ; if ( test ) { unusedLabel : System . out . println ( "more testing" ) ; } } label2 : System . out . println ( "toplevel" ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; class InputArrays { static final int [ ] factories = { 666666 , 666666 , 666666 , 666666 , 666666 , 666666 , 666666 , 666666 , } ; static final int [ ] [ ] factories1 = { { 666666 , 666666 , 666666 , 666666 } , { } , { 666666 , 666666 , 666666 , 666666 } } ; static int [ ] biggestBinomials = { Integer . MAX_VALUE , Integer . MAX_VALUE , 65536 , 2345 , 477 , 193 , 110 , 75 , 58 , 49 , 43 , 39 , 37 , 35 , 34 , 34 , 33 } ; @ VisibleForTesting static final int [ ] halfPowersOf10 = { 3 , 31 , 316 , 3162 , 31622 , 316227 , 3162277 , 31622776 , 316227766 , Integer . MAX_VALUE } ; public byte [ ] asBytes ( ) { byte hash = 0 ; return new byte [ ] { ( byte ) hash , ( byte ) ( hash > > 8 ) , ( byte ) ( hash > > 16 ) , ( byte ) ( hash > > 24 ) , ( byte ) ( hash > > 32 ) , ( byte ) ( hash > > 40 ) , ( byte ) ( hash > > 48 ) , ( byte ) ( hash > > 56 ) } ; } } @ interface VisibleForTesting { }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputInvalidArrayInitIndent { int [ ] array = new int [ ] { 1 , 2 , 3 } ; int [ ] arrayb = new int [ ] { 1 , 2 , 3 } ; int [ ] arrayc = new int [ ] { 1 , 2 , 3 } ; int [ ] array2 = new int [ ] { 1 , 2 , 3 } ; int [ ] array2b = new int [ ] { 1 , 2 , 3 } ; int [ ] array3 = new int [ ] { 1 , 2 , 3 } ; int [ ] array4 = new int [ ] { 1 , 2 , 3 } ; int [ ] array5 = new int [ ] { 1 , 2 , 3 } ; int [ ] array6 = new int [ ] { 1 , 2 , 3 , 4 , } ; int [ ] array7 = new int [ ] { 1 , 2 , 3 } ; int [ ] array8 = new int [ ] { } ; int [ ] array9 = new int [ ] { } ; int [ ] [ ] array10 = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 } , new int [ ] { 1 , 2 , 3 } , } ; int [ ] [ ] array10b = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 } , new int [ ] { 1 , 2 , 3 } , } ; private void func1 ( int [ ] arg ) { } public InputInvalidArrayInitIndent ( ) { func1 ( new int [ ] { 1 , 2 , 3 } ) ; } private static char [ ] sHexChars = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; private void myFunc3 ( ) { char [ ] sHexChars2 = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; char [ ] sHexChars3 = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; char [ ] sHexChars4 = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; } }
package com . puppycrawl . tools . checkstyle . indentation ; class FooWhileClass { String getString ( int someInt , String someString ) { return "String" ; } void fooMethodWithIf ( ) { while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } do { } while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) ; while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } do { } while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) ; } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondWhileClassWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { void fooMethodWithIf ( ) { while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } do { } while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) ; while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } do { } while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) ; } FooWhileClass anonymousClass = new FooWhileClass ( ) { void fooMethodWithIf ( String stringStringStringStringLooooongString , int intIntIntVeryLongNameForIntVariable , boolean fooooooooobooleanBooleanVeryLongName ) { while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } do { } while ( conditionFirst ( "Loooooooooooooooooong" , new SecondWhileClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooWhileClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) ; while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ) { } do { } while ( conditionSecond ( 10000000000.0 , new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooWhileClass ( ) , new SecondWhileClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooWhileClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondWhileClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooWhileClass ( ) , false ) ) || conditionFifth ( true , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooWhileClass ( ) , true ) ) || conditionSixth ( false , new SecondWhileClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ) ; } } ; } } class SecondWhileClassWithVeryVeryVeryLongName { public SecondWhileClassWithVeryVeryVeryLongName ( String string ) { } String getString ( FooWhileClass instance , int integer ) { return "String" ; } int getInteger ( FooWhileClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooWhileClass instance , boolean flag ) { return false ; } SecondWhileClassWithVeryVeryVeryLongName getInstanse ( ) { return new SecondWhileClassWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; import java . util . Map ; import java . util . Map . Entry ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Range ; import com . google . common . collect . RangeMap ; public class FromGuava2 < K extends Comparable < ? > , V > implements RangeMap < K , V > { public FromGuava2 < K , V > subRangeMap1 ( final Range < K > range ) { Range < K > ranges = null ; if ( checkNotNull ( range ) . isEmpty ( ) ) { } else if ( ranges . isEmpty ( ) || range . encloses ( span ( ) ) ) { return this ; } int lowerIndex = SortedLists . binarySearch ( ) ; int upperIndex = SortedLists . binarySearch ( ) ; if ( lowerIndex >= upperIndex ) { return null ; } final int off = lowerIndex ; final int len = upperIndex - lowerIndex ; FromGuava2 < K , V > outer = null ; return outer ; } public V get ( int index ) { K key = null ; int len = 0 ; checkElementIndex ( index , len ) ; int off ; RangeMap < K , V > ranges = null ; if ( index == 0 || index == len - 1 ) { Object range ; return ranges . get ( key ) ; } else { return ranges . get ( key ) ; } } private void checkElementIndex ( int index , Object len ) { } boolean isPartialView ( ) { return true ; } private Range < K > checkNotNull ( Range < K > range ) { return null ; } @ Override public V get ( K key ) { return null ; } public Range < K > span ( ) { return null ; } @ Override public void put ( Range < K > range , V value ) { } @ Override public void putAll ( RangeMap < K , V > rangeMap ) { } @ Override public void clear ( ) { } @ Override public void remove ( Range < K > range ) { } @ Override public Map < Range < K > , V > asMapOfRanges ( ) { return null ; } @ Override public RangeMap < K , V > subRangeMap ( Range < K > range ) { return null ; } @ Override public Entry < Range < K > , V > getEntry ( K key ) { return null ; } private static class SortedLists { public static int binarySearch ( ) { return 4 ; } } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InvalidInputThrowsIndent { public InvalidInputThrowsIndent ( ) { } private void myFunc ( ) throws Exception { } private void myFunc2 ( ) throws Exception { } }
package com . puppycrawl . tools . checkstyle . indentation ; import java . util . Iterator ; class IndentationCorrectClassInput implements Runnable , Cloneable { class InnerClass implements Iterable < String > , Cloneable { @ Override public Iterator < String > iterator ( ) { return null ; } } class InnerClass2 extends SecondClassWithLongLongLongLongName { public InnerClass2 ( String string ) { } } @ Override public void run ( ) { SecondClassWithLongLongLongLongName anon = new SecondClassWithLongLongLongLongName ( ) { @ MyAnnotation2 String longLongLongLongLongMethodName ( ) { return "String" ; } } ; SecondClassWithLongLongLongLongName anon2 = new SecondClassWithLongLongLongLongName ( ) { } ; } } class SecondClassWithLongLongLongLongName extends IndentationCorrectClassInput { private boolean conditionFirst ( String longString , int integer , InnerClass someInstance ) { return false ; } private boolean conditionFirst1 ( String longString , int integer , InnerClass someInstance ) throws Exception { return false ; } } @ interface MyAnnotation2 { } @ MyAnnotation2 class Foo { }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputValidAssignIndent { void foo ( String [ ] args ) { int i = 1 + 2 + 3 ; String line = mIndentCheck [ getLineNo ( ) ] ; String line1 = getLine ( ) ; line1 = getLine ( ) ; int i1 = 1 ; i = 3 ; Integer brace = ( candidate == SLIST ) ? candidate : null ; AnInterfaceFooWithALongName f = new AnInterfaceFooWithALongName ( ) { public void bar ( ) { } } ; AnInterfaceFooWithALongName f1 = new AnInterfaceFooWithALongName ( ) { public void bar ( ) { } } ; } private interface AnInterfaceFooWithALongName { void bar ( ) ; } private static final int SLIST = 1 ; private static final int parameters = 1 ; int candidate = 0 ; private String [ ] mIndentCheck = null ; private InputValidAssignIndent function = null ; int getLineNo ( ) { return 1 ; } String getLine ( ) { return "" ; } InputValidAssignIndent lastArgument ( ) { return this ; } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputValidSwitchIndent { private static final int CONST = 5 ; private static final int CONST2 = 2 ; private static final int CONST3 = 3 ; public InputValidSwitchIndent ( ) { } private void method1 ( ) { int s = 3 ; switch ( s ) { case 4 : System . out . println ( "" ) ; break ; case CONST : break ; case CONST2 : case CONST3 : break ; default : System . out . println ( "" ) ; break ; } switch ( s ) { case 4 : { System . out . println ( "" ) ; break ; } case CONST : break ; case CONST2 : case CONST3 : { System . out . println ( "" ) ; break ; } default : break ; } switch ( s ) { case 4 : { System . out . println ( "" ) ; break ; } case CONST : break ; case CONST2 : case CONST3 : { System . out . println ( "" ) ; break ; } default : break ; } switch ( s ) { } switch ( s ) { default : System . out . println ( "" ) ; break ; } } }
package com . puppycrawl . tools . checkstyle . indentation ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . jar . JarInputStream ; import java . util . jar . Manifest ; class InputValidTryResourcesIndent { private static Manifest loadManifest ( String fn ) { try ( FileInputStream fis = new FileInputStream ( fn ) ; JarInputStream jis = new JarInputStream ( fis , false ) ) { return jis . getManifest ( ) ; } catch ( IOException e ) { return null ; } } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; public class MethodReferencesTest extends BaseCheckTestSupport { @ Test public void testCanParse ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/" + "puppycrawl/tools/checkstyle/grammars/java8/" + "InputMethodReferencesTest.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testFromSpec ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/" + "puppycrawl/tools/checkstyle/grammars/java8/" + "InputMethodReferencesTest2.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testGenericInPostfixExpressionBeforeReference ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MemberNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/" + "puppycrawl/tools/checkstyle/grammars/java8/" + "InputMethodReferencesTest3.java" ) . getCanonicalPath ( ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputInvalidAssignIndent { void foo ( String [ ] args ) { String line = mIndentCheck [ getLineNo ( ) ] ; String line1 = getLine ( ) ; line1 = getLine ( ) ; int i = 1 ; i = 3 ; } private String [ ] mIndentCheck = null ; int getLineNo ( ) { return 1 ; } String getLine ( ) { return "" ; } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputInvalidForIndent { public InputInvalidForIndent ( ) { } private void method1 ( ) { for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int i = 0 ; i < 10 ; i ++ ) { System . getProperty ( "foo" ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { boolean test = true ; if ( test ) { System . getProperty ( "foo" ) ; } } for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int i = 0 ; i < 10 && 4 < 5 && 7 < 8 ; i ++ ) { } for ( int i = 0 ; i < 10 ; i ++ ) { System . getProperty ( "foo" ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { System . getProperty ( "foo" ) ; } } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputInvalidLabelIndent { public InputInvalidLabelIndent ( ) { boolean test = true ; while ( test ) { label : System . out . println ( "label test" ) ; if ( test ) { unusedLabel : System . out . println ( "more testing" ) ; } } label2 : System . out . println ( "toplevel" ) ; label3 : System . out . println ( "toplevel" ) ; System . out . println ( "toplevel" ) ; label4 : System . out . println ( "toplevel" ) ; label5 : System . out . println ( "toplevel" ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; @ DifficultAnnotation ( { @ MyType ( value = Boolean . class , name = "boolean" ) , @ MyType ( value = String . class , name = "string" ) } ) @ SimpleAnnotation public class InputDifficultAnnotations { @ DifficultAnnotation ( { @ MyType ( value = Boolean . class , name = "boolean" ) , @ MyType ( value = String . class , name = "string" ) } ) @ SimpleAnnotation String foo = "foo" ; @ DifficultAnnotation ( { @ MyType ( value = Boolean . class , name = "boolean" ) , @ MyType ( value = String . class , name = "string" ) } ) @ SimpleAnnotation void foo ( ) { } } @ DifficultAnnotation ( { @ MyType ( value = Boolean . class , name = "boolean" ) , @ MyType ( value = String . class , name = "string" ) } ) class IncorrectClass { @ DifficultAnnotation ( { @ MyType ( value = Boolean . class , name = "boolean" ) , @ MyType ( value = String . class , name = "string" ) } ) String foo = "foo" ; @ DifficultAnnotation ( { @ MyType ( value = Boolean . class , name = "boolean" ) , @ MyType ( value = String . class , name = "string" ) } ) void foo ( ) { } } @ interface DifficultAnnotation { MyType [ ] value ( ) ; } @ interface MyType { Class < ? > value ( ) ; String name ( ) ; } @ interface SimpleAnnotation { }
package com . puppycrawl . tools . checkstyle . indentation ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import javax . swing . JButton ; public class InputInvalidClassDefIndent extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } class InputInvalidClassDefIndentB extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } class InputInvalidClassDefIndentC { } class InputValidClassDefIndent22 extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } class InputValidClassDefIndent33 extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } final class InputValidClassDefIndent44 extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } final class InputValidClassDefIndent55 extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } final class InputValidClassDefIndent5b extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } class InputInvalidClassDefIndentc extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { } final class InputValidClassDefIndent66 extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { class foo { } class fooBS { } class foo2 { public int x ; } class foo3 { public int x ; } class foo3b { public int x ; } class foo4 { public int x ; } class foo4c { public int x ; } class foo4b { public int x ; } private void myMethod ( ) { class localFoo { } class localFoo1 { } class localFoo2 { int x ; int func ( ) { return 3 ; } } new JButton ( ) . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { } } ) ; new JButton ( ) . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { } } ) ; new JButton ( ) . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { } } ) ; new JButton ( ) . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { int i = 2 ; } } ) ; Object o = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { } } ; myfunc2 ( 10 , 10 , 10 , myfunc3 ( 11 , 11 , 11 , 11 ) , 10 , 10 , 10 ) ; } private void myfunc2 ( int a , int b , int c , int d , int e , int f , int g ) { } private int myfunc3 ( int a , int b , int c , int d ) { return 1 ; } } final class InputValidClassDefIndent4d extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputSynchronizedStatement { private static InputSynchronizedStatement instance ; public static InputSynchronizedStatement getInstance ( ) { if ( instance == null ) synchronized ( InputSynchronizedStatement . class ) { if ( instance == null ) instance = new InputSynchronizedStatement ( ) ; } return instance ; } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputValidBlockIndent { public InputValidBlockIndent ( ) { } public void method1 ( ) { { } { } { int var = 3 ; var += 3 ; } { int var = 5 ; } { int var = 3 ; var += 3 ; { int innerVar = 4 ; innerVar += var ; } } } static { int var = 4 ; } static { int var = 4 ; } static { int var = 4 ; } { int var = 4 ; } { int var = 4 ; } { int var = 4 ; } } enum EquivalenceTester { OBJECT_ATTRIBUTES { public boolean areEqual ( final Object first , final Object second ) { return true ; } public int hashCode ( final Object target ) { return 1 ; } } , OBJECT_IDENTITIES { public boolean areEqual ( final Object first , final Object second ) { return first == second ; } public int hashCode ( final Object target ) { return System . identityHashCode ( target ) ; } } ; public abstract boolean areEqual ( Object first , Object second ) ; public abstract int hashCode ( Object target ) ; } class bug1251988 { private int a ; { if ( a == 1 ) { } } } class bug1260079 { public bug1260079 ( ) { new Thread ( ) { public void run ( ) { System . out . println ( "ran" ) ; } } . start ( ) ; } } class bug1336737 { private static enum Command { IMPORT ( "import" ) , LIST ( "list" ) ; private final String c ; Command ( String c ) { this . c = c ; } public String toString ( ) { return c ; } } }
package com . puppycrawl . tools . checkstyle . indentation ; public interface InputValidInterfaceDefIndent { void myfunc ( ) ; interface myInterface2 { } public interface myInterface3 extends myInterface2 { } public interface myInterface4 extends myInterface2 { void myFunc2 ( ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; import java . util . Arrays ; public class InputValidMethodIndent extends java . awt . event . MouseAdapter implements java . awt . event . MouseListener { public InputValidMethodIndent ( ) { } private InputValidMethodIndent ( boolean test ) { boolean test2 = true ; int i = 4 + 4 ; } private InputValidMethodIndent ( boolean test , boolean test2 ) { boolean test3 = true ; int i = 4 + 4 ; } private InputValidMethodIndent ( boolean test , boolean test2 , boolean test3 ) { boolean test4 = true ; int i = 4 + 4 ; } public InputValidMethodIndent ( int dummy ) { } public String method1 ( ) { return "hi" ; } public void method2 ( ) { } public int method2 ( int x , int y , int w , int h ) { return 1 ; } public void method2 ( int x , int y , int w , int h , int x1 , int y1 , int w1 , int h1 ) { } public void method3 ( int x , int y , int w , int h , int x1 , int y1 , int w1 , int h1 ) { System . getProperty ( "foo" ) ; } public void method4 ( int x , int y , int w , int h , int x1 , int y1 , int w1 , int h1 ) { boolean test = true ; int i = 4 + 4 ; i += 5 ; i += 5 + 4 ; if ( test ) { System . getProperty ( "foo" ) ; } else { System . getProperty ( "foo" ) ; } for ( int j = 0 ; j < 10 ; j ++ ) { System . getProperty ( "foo" ) ; } myfunc2 ( 10 , 10 , 10 , myfunc3 ( 11 , 11 , 11 , 11 ) , 10 , 10 , 10 ) ; myfunc3 ( 11 , 11 , Integer . getInteger ( "mytest" ) . intValue ( ) , 11 ) ; myfunc3 ( 1 , 2 , 3 , 4 ) ; } public void method5 ( ) { } private void myfunc2 ( int a , int b , int c , int d , int e , int f , int g ) { } private int myfunc3 ( int a , int b , int c , int d ) { return 1 ; } void method6 ( ) { System . out . println ( "methods are: " + Arrays . asList ( new String [ ] { "method" } ) . toString ( ) ) ; System . out . println ( "methods are: " + Arrays . asList ( new String [ ] { "method" } ) . toString ( ) ) ; System . out . println ( "methods are: " + Arrays . asList ( new String [ ] { "method" } ) . toString ( ) ) ; myfunc2 ( 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; myfunc2 ( 3 , 4 , method2 ( 3 , 4 , 5 , 6 ) + 5 , 6 , 7 , 8 , 9 ) ; System . out . println ( "methods are: " + Arrays . asList ( new String [ ] { "method" } ) . toString ( ) ) ; System . out . println ( "methods are: " + Arrays . asList ( new String [ ] { "method" } ) . toString ( ) ) ; String blah = ( String ) System . getProperty ( new String ( "type" ) ) ; System . out . println ( method1 ( ) + "mytext" + " at indentation level not at correct indentation, " + method1 ( ) ) ; System . out . println ( method1 ( ) + "mytext" + " at indentation level not at correct indentation, " + method1 ( ) ) ; System . out . toString ( ) . equals ( "blah" ) ; } private int [ ] getArray ( ) { return new int [ ] { 1 } ; } private void indexTest ( ) { getArray ( ) [ 0 ] = 2 ; } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputValidBinaryOpIndent { public InputValidBinaryOpIndent ( ) { } private void method1 ( ) { boolean test = true ; int i , j , k = 4 ; int x = 4 ; int y = 7 ; i = x + k ; j = y + x + k ; int one = 1 , two = 2 , three = 3 , four = 4 ; int answer ; answer = ( one + one ) / 2 ; answer = ( one + one ) / 2 ; answer = ( one + one ) / 2 ; answer = ( one + one ) / 2 ; answer = ( ( one + one ) / 2 ) + 4 ; if ( one + one == two ) { System . out . println ( "true" ) ; } if ( one + one == two ) { } if ( one + one == two && 1 + 1 == two ) { } if ( one + one == two && 1 + 1 == two ) { } if ( ( one + one ) == two && ( 1 + 1 ) == two ) { } if ( ( one + one ) == two && ( 1 + 1 ) == two ) { } if ( ( one + one ) == two && ( 1 + 1 ) == two ) { } } }
package com . puppycrawl . tools . checkstyle . filters ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import com . puppycrawl . tools . checkstyle . api . FilterSet ; import nl . jqno . equalsverifier . EqualsVerifier ; import org . junit . Before ; import org . junit . Test ; public class FilterSetTest { private CSVFilter filter ; @ Before public void setUp ( ) { filter = new CSVFilter ( "" ) ; } @ Test public void testEmptyChain ( ) { assertFalse ( "0" , filter . accept ( Integer . valueOf ( 0 ) ) ) ; } @ Test public void testOneFilter ( ) { filter . addFilter ( new IntMatchFilter ( 0 ) ) ; assertTrue ( "0" , filter . accept ( Integer . valueOf ( 0 ) ) ) ; assertFalse ( "1" , filter . accept ( Integer . valueOf ( 1 ) ) ) ; } @ Test public void testMultipleFilter ( ) { filter . addFilter ( new IntMatchFilter ( 0 ) ) ; filter . addFilter ( new IntRangeFilter ( 0 , 2 ) ) ; assertTrue ( "0" , filter . accept ( Integer . valueOf ( 0 ) ) ) ; assertTrue ( "1" , filter . accept ( Integer . valueOf ( 1 ) ) ) ; filter . addFilter ( new IntRangeFilter ( 3 , 4 ) ) ; assertTrue ( "0 is in [3,4]" , filter . accept ( Integer . valueOf ( 0 ) ) ) ; } @ Test public void testEqualsAndHashCode ( ) { EqualsVerifier . forClass ( FilterSet . class ) . usingGetClass ( ) . verify ( ) ; } @ Test public void testGetFilters ( ) { filter . addFilter ( new IntMatchFilter ( 0 ) ) ; assertTrue ( "size is the same" , filter . getFilters ( ) . size ( ) == 1 ) ; } @ Test public void testToString ( ) { filter . addFilter ( new IntMatchFilter ( 0 ) ) ; assertTrue ( "toString works" , filter . toString ( ) != null ) ; } @ Test public void testGetFilters2 ( ) { FilterSet filterSet = new FilterSet ( ) ; filterSet . addFilter ( new SeverityMatchFilter ( ) ) ; assertTrue ( "size is the same" , filterSet . getFilters ( ) . size ( ) == 1 ) ; } @ Test public void testToString2 ( ) { FilterSet filterSet = new FilterSet ( ) ; filterSet . addFilter ( new SeverityMatchFilter ( ) ) ; assertTrue ( "size is the same" , filterSet . toString ( ) != null ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputInvalidTryIndent { public InputInvalidTryIndent ( ) { } public void method ( ) { try { } catch ( Throwable t ) { System . out . println ( "err" ) ; } try { System . out . println ( "test" ) ; } finally { System . out . println ( "finally" ) ; } try { } catch ( Throwable t ) { System . out . println ( "err" ) ; } finally { } try { } catch ( Exception t ) { System . out . println ( "err" ) ; } catch ( Throwable t ) { System . out . println ( "err" ) ; } try { } catch ( Exception t ) { } catch ( Throwable t ) { } try { System . out . println ( "try" ) ; } catch ( Exception t ) { System . out . println ( "err" ) ; System . out . println ( "err" ) ; System . out . println ( "err" ) ; } catch ( Throwable t ) { System . out . println ( "err" ) ; } finally { } try { System . out . println ( "try" ) ; } catch ( Exception t ) { System . out . println ( "err" ) ; System . out . println ( "err" ) ; } catch ( Throwable t ) { System . out . println ( "err" ) ; } finally { } } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputValidTryIndent { public InputValidTryIndent ( ) { } public void method ( ) { try { } catch ( Throwable t ) { System . out . println ( "err" ) ; } try { System . out . println ( "test" ) ; } finally { System . out . println ( "finally" ) ; } try { } catch ( Throwable t ) { System . out . println ( "err" ) ; } finally { } try { } catch ( Exception t ) { System . out . println ( "err" ) ; } catch ( Throwable t ) { System . out . println ( "err" ) ; } try { } catch ( Exception t ) { } catch ( Throwable t ) { } try { System . out . println ( "try" ) ; } catch ( Exception t ) { System . out . println ( "err" ) ; System . out . println ( "err" ) ; } catch ( Throwable t ) { System . out . println ( "err" ) ; } finally { } try { System . out . println ( "try" ) ; } catch ( Exception t ) { System . out . println ( "err" ) ; System . out . println ( "err" ) ; } catch ( Throwable t ) { System . out . println ( "err" ) ; } finally { } } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputValidArrayInitDefaultIndent { private static char [ ] sHexChars = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; int [ ] array = new int [ ] { 1 , 2 , 3 } ; int [ ] array2 = new int [ ] { 1 , 2 , 3 } ; int [ ] array3 = new int [ ] { 1 , 2 , 3 } ; int [ ] array4 = new int [ ] { 1 , 2 , 3 } ; int [ ] array5 = new int [ ] { 1 , 2 , 3 } ; int [ ] array6 = new int [ ] { 1 , 2 , 3 } ; int [ ] array6a = new int [ ] { 1 , 2 , 3 , 4 } ; int [ ] array7 = new int [ ] { 1 , 2 , 3 } ; String [ ] [ ] mStuff = new String [ ] [ ] { { "key" , "value" } } ; String [ ] [ ] mStuff1 = new String [ ] [ ] { { "key" , "value" } } ; int [ ] array8 = new int [ ] { } ; int [ ] array9 = new int [ ] { } ; int [ ] [ ] array10 = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 } , new int [ ] { 1 , 2 , 3 } , } ; int [ ] [ ] array10b = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 } , new int [ ] { 1 , 2 , 3 } , } ; private void func1 ( int [ ] arg ) { char [ ] sHexChars2 = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; char [ ] sHexChars3 = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; char [ ] sHexChars4 = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; } public InputValidArrayInitDefaultIndent ( ) { func1 ( new int [ ] { 1 , 2 } ) ; func1 ( new int [ ] { } ) ; func1 ( new int [ ] { 1 , 2 , 3 } ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputSynchronizedMethod { public synchronized InputSynchronizedMethod calculate ( ) { return null ; } }
package com . puppycrawl . tools . checkstyle . indentation ; @ interface MyAnnotation3 { String name ( ) ; int version ( ) ; } @ MyAnnotation3 ( name = "ABC" , version = 1 ) public class Input15Extensions { } enum Enum1 { A , B , C ; Enum1 ( ) { } public String toString ( ) { return "" ; } } interface TestRequireThisEnum { enum DAY_OF_WEEK { SUNDAY , MONDAY , TUESDAY , WEDNESDAY , THURSDAY , FRIDAY , SATURDAY } }
package com . puppycrawl . tools . checkstyle . indentation ; import java . util . HashMap ; import java . util . Map ; class FooFieldClass { boolean flag = conditionFirst ( "Loooooooooooooooooong" , new SecondFieldClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooFieldClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; String getString ( int someInt , String someString ) { return "String" ; } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } class InnerClassFoo { boolean flag = conditionFirst ( "Loooooooooooooooooong" , new SecondFieldClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooFieldClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ; FooFieldClass anonymousClass = new FooFieldClass ( ) { boolean secondFlag = conditionSecond ( 10000000000.0 , new SecondFieldClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooFieldClass ( ) , new SecondFieldClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooFieldClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) ; } ; } } class SecondFieldClassWithVeryVeryVeryLongName { public SecondFieldClassWithVeryVeryVeryLongName ( String string ) { } String getString ( FooFieldClass instance , int integer ) { return "String" ; } int getInteger ( FooFieldClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooFieldClass instance , boolean flag ) { return false ; } SecondFieldClassWithVeryVeryVeryLongName getInstanse ( ) { return new SecondFieldClassWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } } abstract class WithAnnotations { @ GwtIncompatible ( "Non-UTF-8" + "Charset" ) public static final int FOO_CONSTANT = 111 ; private void foo34 ( ) { } final Map < String , String > comeMapWithLongName = new HashMap < String , String > ( ) ; @ MyAnnotation byte [ ] getBytesInternal ( ) { return new byte [ ] { } ; } @ MyAnnotation public abstract < K , V > Map < K , V > rowMap ( ) ; } @ interface GwtIncompatible { String value ( ) ; } @ interface MyAnnotation { } @ MyAnnotation enum MyEnum { }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputValidForIndent { public InputValidForIndent ( ) { } private void method1 ( int [ ] indices ) { for ( int i = 0 ; i < 10 ; i ++ ) System . getProperty ( "foo" ) ; for ( int i = 0 ; i < 10 ; i ++ ) System . getProperty ( "foo" ) ; for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int i = 0 ; i < 10 ; i ++ ) { System . getProperty ( "foo" ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { boolean test = true ; if ( test ) { System . getProperty ( "foo" ) ; } } for ( int i = 0 ; i < 10 ; i ++ ) { } for ( int i = 0 ; i < 10 && 4 < 5 && 7 < 8 ; i ++ ) { } for ( int i = 0 ; i < 10 && 4 < 5 && 7 < 8 ; i ++ ) { } for ( int i = 0 ; i < 10 && 4 < 5 && 7 < 8 ; i ++ ) { } for ( int i = 0 ; i < 10 ; i ++ ) { System . getProperty ( "foo" ) ; } for ( final int index : indices ) { System . err . println ( index ) ; } for ( final int index : indices ) { System . err . println ( index ) ; } } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputUseTwoSpaces { public InputUseTwoSpaces ( ) { boolean test = true ; if ( test ) { while ( test == false ) { System . exit ( 2 ) ; } } System . exit ( 3 ) ; } } class Test { public static void main ( String [ ] args ) { System . out . println ( " Hello" + new Object ( ) { public String toString ( ) { return "World" ; } } ) ; new Object ( ) . toString ( ) . toString ( ) . toString ( ) . toString ( ) . toString ( ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputInvalidSwitchIndent { private static final int CONST = 5 ; private static final int CONST2 = 2 ; private static final int CONST3 = 3 ; public InputInvalidSwitchIndent ( ) { } private void method1 ( ) { int s = 3 ; switch ( s ) { case 4 : System . out . println ( "" ) ; break ; case CONST : break ; case CONST2 : case CONST3 : break ; default : System . out . println ( "" ) ; break ; } switch ( s ) { case 4 : { System . out . println ( "" ) ; break ; } case CONST2 : case CONST3 : { System . out . println ( "" ) ; break ; } case 22 : { System . out . println ( "" ) ; break ; } } switch ( s ) { case CONST : break ; case CONST2 : case CONST3 : { System . out . println ( "" ) ; break ; } } switch ( s ) { } switch ( s ) { } switch ( s ) { } } }
package com . puppycrawl . tools . checkstyle . indentation ; class FooIfClass { String getString ( int someInt , String someString ) { return "String" ; } void fooMethodWithIf ( ) { if ( conditionFirst ( "Loooooooooooooooooong" , new SecondClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooIfClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } if ( conditionSecond ( 10000000000.0 , new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooIfClass ( ) , new SecondClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooIfClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooIfClass ( ) , false ) ) || conditionFifth ( true , new SecondClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooIfClass ( ) , true ) ) || conditionSixth ( false , new SecondClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } } private boolean conditionFirst ( String longString , int integer , InnerClassFoo someInstance ) { return false ; } private boolean conditionSecond ( double longLongLongDoubleValue , String longLongLongString , String secondLongLongString ) { return false ; } private boolean conditionThird ( long veryLongValue ) { return false ; } private boolean conditionFourth ( boolean flag ) { return false ; } private boolean conditionFifth ( boolean flag1 , boolean flag2 ) { return false ; } private boolean conditionSixth ( boolean flag , SecondClassWithVeryVeryVeryLongName instance ) { return false ; } private boolean conditionNoArg ( ) { return false ; } class InnerClassFoo { void fooMethodWithIf ( ) { if ( conditionFirst ( "Loooooooooooooooooong" , new SecondClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooIfClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } if ( conditionSecond ( 10000000000.0 , new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooIfClass ( ) , new SecondClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooIfClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooIfClass ( ) , false ) ) || conditionFifth ( true , new SecondClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooIfClass ( ) , true ) ) || conditionSixth ( false , new SecondClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) ) { } } FooIfClass anonymousClass = new FooIfClass ( ) { void fooMethodWithIf ( String stringStringStringStringLooooongString , int intIntIntVeryLongNameForIntVariable , boolean fooooooooobooleanBooleanVeryLongName ) { if ( conditionFirst ( "Loooooooooooooooooong" , new SecondClassWithVeryVeryVeryLongName ( "Loooooooooooooooooog" ) . getInteger ( new FooIfClass ( ) , "Loooooooooooooooooog" ) , new InnerClassFoo ( ) ) ) { } if ( conditionSecond ( 10000000000.0 , new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooo" + "oooooooooooong" ) . getString ( new FooIfClass ( ) , new SecondClassWithVeryVeryVeryLongName ( "loooooooooong" ) . getInteger ( new FooIfClass ( ) , "loooooooooooooong" ) ) , "loooooooooooong" ) || conditionThird ( 2048 ) || conditionFourth ( new SecondClassWithVeryVeryVeryLongName ( "Looooooooooooooo" + "ooooooooooooong" ) . getBoolean ( new FooIfClass ( ) , false ) ) || conditionFifth ( true , new SecondClassWithVeryVeryVeryLongName ( getString ( 2048 , "Looo" + "ooooooooooooooooooooooooooooooooooooooooooong" ) ) . getBoolean ( new FooIfClass ( ) , true ) ) || conditionSixth ( false , new SecondClassWithVeryVeryVeryLongName ( getString ( 100000 , "Loooooong" + "Fooooooo><" ) ) ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) || conditionNoArg ( ) && fooooooooobooleanBooleanVeryLongName ) { } } } ; } } class SecondClassWithVeryVeryVeryLongName { public SecondClassWithVeryVeryVeryLongName ( String string ) { } String getString ( FooIfClass instance , int integer ) { return "String" ; } int getInteger ( FooIfClass instance , String string ) { return - 1 ; } boolean getBoolean ( FooIfClass instance , boolean flag ) { return false ; } SecondClassWithVeryVeryVeryLongName getInstanse ( ) { return new SecondClassWithVeryVeryVeryLongName ( "VeryLoooooooooo" + "oongString" ) ; } }
package com . puppycrawl . tools . checkstyle . filters ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . Checker ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . TreeWalker ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . FileContentsHolder ; import com . puppycrawl . tools . checkstyle . checks . coding . IllegalCatchCheck ; import com . puppycrawl . tools . checkstyle . checks . naming . ConstantNameCheck ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; import java . io . UnsupportedEncodingException ; import java . util . Arrays ; import java . util . Collection ; import java . util . Locale ; import nl . jqno . equalsverifier . EqualsVerifier ; import org . junit . Test ; public class SuppressWithNearbyCommentFilterTest extends BaseCheckTestSupport { private static String [ ] sAllMessages = { "14:17: Name 'A1' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "15:17: Name 'A2' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "16:59: Name 'A3' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "18:17: Name 'B1' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "19:17: Name 'B2' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "20:59: Name 'B3' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "22:17: Name 'C1' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "24:17: Name 'C2' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "25:17: Name 'C3' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "27:17: Name 'D1' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "28:17: Name 'D2' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "30:17: Name 'D3' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "32:30: Name 'e1' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , "33:17: Name 'E2' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "34:17: Name 'E3' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "35:30: Name 'e4' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , "36:17: Name 'E5' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "37:30: Name 'e6' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , "38:17: Name 'E7' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "39:17: Name 'E8' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "40:30: Name 'e9' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , "64:23: Catching 'Exception' is not allowed." , "66:23: Catching 'Throwable' is not allowed." , "73:11: Catching 'Exception' is not allowed." , } ; @ Test public void testNone ( ) throws Exception { final DefaultConfiguration filterConfig = null ; final String [ ] suppressed = { } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressWithNearbyCommentFilter . class ) ; final String [ ] suppressed = { "14:17: Name 'A1' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "15:17: Name 'A2' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "16:59: Name 'A3' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "18:17: Name 'B1' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "19:17: Name 'B2' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "20:59: Name 'B3' must match pattern '^[a-z][a-zA-Z0-9]*$'." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testCheckC ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressWithNearbyCommentFilter . class ) ; filterConfig . addAttribute ( "checkC" , "false" ) ; final String [ ] suppressed = { "14:17: Name 'A1' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "18:17: Name 'B1' must match pattern '^[a-z][a-zA-Z0-9]*$'." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testCheckCPP ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressWithNearbyCommentFilter . class ) ; filterConfig . addAttribute ( "checkCPP" , "false" ) ; final String [ ] suppressed = { "15:17: Name 'A2' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "16:59: Name 'A3' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "19:17: Name 'B2' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "20:59: Name 'B3' must match pattern '^[a-z][a-zA-Z0-9]*$'." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testUsingAVariableMessage ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressWithNearbyCommentFilter . class ) ; filterConfig . addAttribute ( "commentFormat" , "ALLOW CATCH (\\w+) BECAUSE" ) ; filterConfig . addAttribute ( "checkFormat" , "IllegalCatchCheck" ) ; filterConfig . addAttribute ( "messageFormat" , "$1" ) ; filterConfig . addAttribute ( "influenceFormat" , "-1" ) ; final String [ ] suppressed = { "66:23: Catching 'Throwable' is not allowed." , "73:11: Catching 'Exception' is not allowed." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testUsingAVariableCheckOnNextLine ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressWithNearbyCommentFilter . class ) ; filterConfig . addAttribute ( "commentFormat" , "ALLOW (\\w+) ON NEXT LINE" ) ; filterConfig . addAttribute ( "checkFormat" , "$1" ) ; filterConfig . addAttribute ( "influenceFormat" , "1" ) ; final String [ ] suppressed = { "24:17: Name 'C2' must match pattern '^[a-z][a-zA-Z0-9]*$'." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testUsingAVariableCheckOnPreviousLine ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressWithNearbyCommentFilter . class ) ; filterConfig . addAttribute ( "commentFormat" , "ALLOW (\\w+) ON PREVIOUS LINE" ) ; filterConfig . addAttribute ( "checkFormat" , "$1" ) ; filterConfig . addAttribute ( "influenceFormat" , "-1" ) ; final String [ ] suppressed = { "28:17: Name 'D2' must match pattern '^[a-z][a-zA-Z0-9]*$'." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testVariableCheckOnVariableNumberOfLines ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressWithNearbyCommentFilter . class ) ; filterConfig . addAttribute ( "commentFormat" , "ALLOW (\\w+) UNTIL THIS LINE([+-]\\d+)" ) ; filterConfig . addAttribute ( "checkFormat" , "$1" ) ; filterConfig . addAttribute ( "influenceFormat" , "$2" ) ; final String [ ] suppressed = { "35:30: Name 'e4' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , "36:17: Name 'E5' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "38:17: Name 'E7' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "39:17: Name 'E8' must match pattern '^[a-z][a-zA-Z0-9]*$'." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testEqualsAndHashCodeOfTagClass ( ) { EqualsVerifier . forClass ( SuppressWithNearbyCommentFilter . Tag . class ) . usingGetClass ( ) . verify ( ) ; } public static DefaultConfiguration createFilterConfig ( Class < ? > classObj ) { return new DefaultConfiguration ( classObj . getName ( ) ) ; } protected void verifySuppressed ( Configuration filterConfig , String [ ] suppressed ) throws Exception { verify ( createChecker ( filterConfig ) , getPath ( "filters/InputSuppressWithNearbyCommentFilter.java" ) , removeSuppressed ( sAllMessages , suppressed ) ) ; } @ Override protected Checker createChecker ( Configuration filterConfig ) throws CheckstyleException , UnsupportedEncodingException { final DefaultConfiguration checkerConfig = new DefaultConfiguration ( "configuration" ) ; final DefaultConfiguration checksConfig = createCheckConfig ( TreeWalker . class ) ; checksConfig . addChild ( createCheckConfig ( FileContentsHolder . class ) ) ; checksConfig . addChild ( createCheckConfig ( MemberNameCheck . class ) ) ; checksConfig . addChild ( createCheckConfig ( ConstantNameCheck . class ) ) ; checksConfig . addChild ( createCheckConfig ( IllegalCatchCheck . class ) ) ; checkerConfig . addChild ( checksConfig ) ; if ( filterConfig != null ) { checkerConfig . addChild ( filterConfig ) ; } final Checker checker = new Checker ( ) ; final Locale locale = Locale . ROOT ; checker . setLocaleCountry ( locale . getCountry ( ) ) ; checker . setLocaleLanguage ( locale . getLanguage ( ) ) ; checker . setModuleClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; checker . configure ( checkerConfig ) ; checker . addListener ( new BriefLogger ( stream ) ) ; return checker ; } private String [ ] removeSuppressed ( String [ ] from , String [ ] remove ) { final Collection < String > coll = Lists . newArrayList ( Arrays . asList ( from ) ) ; coll . removeAll ( Arrays . asList ( remove ) ) ; return coll . toArray ( new String [ coll . size ( ) ] ) ; } }
package com . puppycrawl . tools . checkstyle . indentation ; class InputAndroidStyleCorrect extends FooForExtend { String string = foo ( "fooooooooooooooo" , 0 , false ) ; String string1 = foo ( "fooooooooooooooo" , 0 , false ) ; String foo ( String aStr , int aNnum , boolean aFlag ) { if ( true && true && true && true ) { String string2 = foo ( "fooooooo" + "oooooooo" , 0 , false ) ; if ( false && false && false ) { } } return "string" ; } } class InputAndroidStyleIncorrect extends FooForExtend { String string = foo ( "fooooooooooooooo" , 0 , false ) ; String string1 = foo ( "fooooooooooooooo" , 0 , false ) ; String foo ( String aStr , int aNnum , boolean aFlag ) { if ( true && true && true && true ) { String string2 = foo ( "fooooooo" + "oooooooo" , 0 , false ) ; if ( false && false && false ) { } } return "string" ; } } class FooForExtend { }
package com . puppycrawl . tools . checkstyle . indentation ; public class InputInvalidWhileIndent { public InputInvalidWhileIndent ( ) { } private void method1 ( ) { boolean test = true ; while ( test ) { } while ( test ) { } while ( test ) { System . getProperty ( "foo" ) ; } while ( test ) { System . getProperty ( "foo" ) ; } while ( test ) { System . getProperty ( "foo" ) ; System . getProperty ( "foo" ) ; } while ( test ) { System . getProperty ( "foo" ) ; System . getProperty ( "foo" ) ; } while ( test ) { if ( test ) { System . getProperty ( "foo" ) ; } System . getProperty ( "foo" ) ; } while ( test && 4 < 7 && 8 < 9 && 3 < 4 ) { } while ( test && 4 < 7 && 8 < 9 && 3 < 4 ) { } while ( test && 4 < 7 && 8 < 9 && 3 < 4 ) { } while ( test && 4 < 7 && 8 < 9 && 3 < 4 ) { } while ( test && 4 < 7 && 8 < 9 && 3 < 4 ) { } while ( test && 4 < 7 && 8 < 9 && 3 < 4 ) { } while ( true ) { continue ; } } }
package com . puppycrawl . tools . checkstyle . coding ; import java . util . TreeSet ; import java . util . Hashtable ; public class InputIllegalType { private AbstractClass a = null ; private NotAnAbstractClass b = null ; private com . puppycrawl . tools . checkstyle . coding . InputIllegalType . AbstractClass c = null ; private com . puppycrawl . tools . checkstyle . coding . InputIllegalType . NotAnAbstractClass d = null ; private abstract class AbstractClass { } private class NotAnAbstractClass { } private java . util . TreeSet table1 ( ) { return null ; } private TreeSet table2 ( ) { return null ; } static class SomeStaticClass { } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputIllegalThrowsCheck { public void method ( ) throws NullPointerException { } public java . lang . Throwable methodOne ( ) throws RuntimeException { return null ; } public void methodTwo ( ) throws java . lang . RuntimeException , java . lang . Error { } public void finalize ( ) throws Throwable { } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputMultipleStringLiterals { String m = "StringContents" ; String m1 = "SingleString" ; String m2 = "DoubleString" + "DoubleString" ; String m3 = "" + "" ; String m4 = "" + "" ; String debugStr = ", " + ", " + ", " ; void method1 ( ) { String a1 = "StringContents" ; System . out . println ( "StringContents" ) ; String a2 = "String" + "Contents" ; } @ SuppressWarnings ( "unchecked" ) void method2 ( ) { } @ SuppressWarnings ( "unchecked" ) void method3 ( ) { } @ SuppressWarnings ( "unchecked" ) void method4 ( ) { } @ SuppressWarnings ( "unchecked" ) void method5 ( ) { } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputModifiedControlVariableEnhancedForLoopVariable { public void method2 ( ) { final String [ ] lines = { "line1" , "line2" , "line3" } ; for ( String line : lines ) { line = line . trim ( ) ; } } }
package com . puppycrawl . tools . checkstyle . coding ; import java . util . TreeSet ; import java . util . Hashtable ; public class InputIllegalTypeMemberModifiers { private AbstractClass a = null ; private NotAnAbstractClass b = null ; private com . puppycrawl . tools . checkstyle . coding . InputIllegalTypeMemberModifiers . AbstractClass c = null ; private com . puppycrawl . tools . checkstyle . coding . InputIllegalTypeMemberModifiers . NotAnAbstractClass d = null ; private abstract class AbstractClass { } private class NotAnAbstractClass { } private java . util . TreeSet table1 ( ) { return null ; } private TreeSet table2 ( ) { return null ; } static class SomeStaticClass { } protected com . puppycrawl . tools . checkstyle . coding . InputIllegalTypeMemberModifiers . AbstractClass c1 = null ; public final static java . util . TreeSet table3 ( ) { return null ; } java . util . TreeSet table4 ( ) { java . util . TreeSet treeSet = null ; return null ; } private class Some { java . util . TreeSet treeSet = null ; } protected AbstractClass a1 = null ; }
package com . puppycrawl . tools . checkstyle . coding ; public class InputExplicitInit { private int x = 0 ; private Object bar = null ; private int y = 1 ; private long y1 = 1 - 1 ; private long y3 ; private long y4 = 0L ; private boolean b1 = false ; private boolean b2 = true ; private boolean b3 ; private String str = "" ; java . lang . String str1 = null , str3 = null ; int ar1 [ ] = null ; int ar2 [ ] = new int [ 1 ] ; int ar3 [ ] ; float f1 = 0f ; double d1 = 0.0 ; static char ch ; static char ch1 = 0 ; static char ch2 = '\0' ; static char ch3 = '\1' ; void method ( ) { int xx = 0 ; String s = null ; } } interface interface1 { int TOKEN_first = 0x00 ; int TOKEN_second = 0x01 ; int TOKEN_third = 0x02 ; } class InputExplicitInit2 { private Bar < String > bar = null ; private Bar < String > [ ] barArray = null ; } enum InputExplicitInit3 { A , B { private int x = 0 ; private Bar < String > bar = null ; private Bar < String > [ ] barArray = null ; private int y = 1 ; } ; private int x = 0 ; private Bar < String > bar = null ; private Bar < String > [ ] barArray = null ; private int y = 1 ; } @ interface annotation1 { int TOKEN_first = 0x00 ; int TOKEN_second = 0x01 ; int TOKEN_third = 0x02 ; } class ForEach { public ForEach ( java . util . Collection < String > strings ) { for ( String s : strings ) { } } } class Bar < T > { }
package com . puppycrawl . tools . checkstyle . coding ; public class InputHasFinalizer { public void finalize ( ) { Runnable runnable = new Runnable ( ) { public void run ( ) { reallyFinalize ( "hi" ) ; } private void reallyFinalize ( String s ) { } } ; runnable . run ( ) ; } public void finalize ( String x ) { } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputDeclarationOrder { static final int FOO2 = 3 ; public static final int FOO = 3 ; private static final int FOO3 = 3 ; public static final int FOO4 = 3 ; private static final String ERROR = "error" ; protected static final String ERROR1 = "error" ; public static final String WARNING = "warning" ; private int mMaxInitVars = 3 ; public static final int MAX_ITER_VARS = 3 ; private class InnerClass { private static final int INNER_FOO = 2 ; public static final int INNER_FOO2 = 2 ; public InnerClass ( ) { int foo = INNER_FOO ; foo += INNER_FOO2 ; foo += INNER_FOO3 ; } public static final int INNER_FOO3 = 2 ; } public int getFoo1 ( ) { return mFoo ; } public InputDeclarationOrder ( ) { String foo = ERROR ; foo += ERROR1 ; foo += WARNING ; int fooInt = mMaxInitVars ; fooInt += MAX_ITER_VARS ; fooInt += mFoo ; } public static int getFoo2 ( ) { return 13 ; } public int getFoo ( ) { return mFoo ; } private static int getFoo21 ( ) { return 14 ; } private int mFoo = 0 ; } enum InputDeclarationOrderEnum { ENUM_VALUE_1 , ENUM_VALUE_2 , ENUM_VALUE_3 { private static final int INNER_FOO = 2 ; public static final int INNER_FOO2 = 2 ; public void doIt ( ) { } public static final int INNER_FOO3 = 2 ; } ; static final int FOO2 = 3 ; public static final int FOO = 3 ; private static final int FOO3 = 3 ; public static final int FOO4 = 3 ; private static final String ERROR = "error" ; protected static final String ERROR1 = "error" ; public static final String WARNING = "warning" ; private int mMaxInitVars = 3 ; public static final int MAX_ITER_VARS = 3 ; private class InnerClass { private static final int INNER_FOO = 2 ; public static final int INNER_FOO2 = 2 ; public InnerClass ( ) { int foo = INNER_FOO ; foo += INNER_FOO2 ; foo += INNER_FOO3 ; } public static final int INNER_FOO3 = 2 ; } public int getFoo1 ( ) { return mFoo ; } InputDeclarationOrderEnum ( ) { String foo = ERROR ; foo += ERROR1 ; foo += WARNING ; int fooInt = mMaxInitVars ; fooInt += MAX_ITER_VARS ; fooInt += mFoo ; } public static int getFoo2 ( ) { return 2 ; } public int getFoo ( ) { return mFoo ; } private static int getFoo21 ( ) { return 1 ; } private int mFoo = 0 ; }
package com . puppycrawl . tools . checkstyle . filters ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . Checker ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . TreeWalker ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . SuppressWarningsHolder ; import com . puppycrawl . tools . checkstyle . checks . coding . IllegalCatchCheck ; import com . puppycrawl . tools . checkstyle . checks . naming . ConstantNameCheck ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; import com . puppycrawl . tools . checkstyle . checks . sizes . ParameterNumberCheck ; import org . junit . Test ; import java . util . Arrays ; import java . util . Collection ; import java . util . Locale ; public class SuppressWarningsFilterTest extends BaseCheckTestSupport { private static String [ ] sAllMessages = { "22:45: Name 'I' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "24:17: Name 'J' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "25:17: Name 'K' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "29:17: Name 'L' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "29:32: Name 'X' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "33:30: Name 'm' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , "34:30: Name 'n' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , "39:17: More than 7 parameters (found 8)." , "45:9: Catching 'Exception' is not allowed." , "56:9: Catching 'Exception' is not allowed." , } ; @ Test public void testNone ( ) throws Exception { final DefaultConfiguration filterConfig = null ; final String [ ] suppressed = { } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressWarningsFilter . class ) ; final String [ ] suppressed = { "24:17: Name 'J' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "29:17: Name 'L' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "33:30: Name 'm' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , "39:17: More than 7 parameters (found 8)." , "56:9: Catching 'Exception' is not allowed." , } ; verifySuppressed ( filterConfig , suppressed ) ; } public static DefaultConfiguration createFilterConfig ( Class < ? > classObj ) { return new DefaultConfiguration ( classObj . getName ( ) ) ; } protected void verifySuppressed ( Configuration aFilterConfig , String [ ] aSuppressed ) throws Exception { verify ( createChecker ( aFilterConfig ) , getPath ( "filters/InputSuppressWarningsFilter.java" ) , removeSuppressed ( sAllMessages , aSuppressed ) ) ; } @ Override protected Checker createChecker ( Configuration filterConfig ) throws Exception { final DefaultConfiguration checkerConfig = new DefaultConfiguration ( "configuration" ) ; final DefaultConfiguration checksConfig = createCheckConfig ( TreeWalker . class ) ; final DefaultConfiguration holderConfig = createCheckConfig ( SuppressWarningsHolder . class ) ; holderConfig . addAttribute ( "aliasList" , "com.puppycrawl.tools.checkstyle.checks.sizes." + "ParameterNumberCheck=paramnum" ) ; checksConfig . addChild ( holderConfig ) ; checksConfig . addChild ( createCheckConfig ( MemberNameCheck . class ) ) ; checksConfig . addChild ( createCheckConfig ( ConstantNameCheck . class ) ) ; checksConfig . addChild ( createCheckConfig ( ParameterNumberCheck . class ) ) ; checksConfig . addChild ( createCheckConfig ( IllegalCatchCheck . class ) ) ; checkerConfig . addChild ( checksConfig ) ; if ( filterConfig != null ) { checkerConfig . addChild ( filterConfig ) ; } final Checker checker = new Checker ( ) ; final Locale locale = Locale . ROOT ; checker . setLocaleCountry ( locale . getCountry ( ) ) ; checker . setLocaleLanguage ( locale . getLanguage ( ) ) ; checker . setModuleClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; checker . configure ( checkerConfig ) ; checker . addListener ( new BriefLogger ( stream ) ) ; return checker ; } private String [ ] removeSuppressed ( String [ ] from , String [ ] remove ) { final Collection < String > coll = Lists . newArrayList ( Arrays . asList ( from ) ) ; coll . removeAll ( Arrays . asList ( remove ) ) ; return coll . toArray ( new String [ coll . size ( ) ] ) ; } }
package com . puppycrawl . tools . checkstyle . coding ; public class GregorianCalendar { class SubCalendar { } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputFinalLocalVariableEnhancedForLoopVariable { public void method1 ( ) { final java . util . List < Object > list = new java . util . ArrayList < > ( ) ; for ( Object a : list ) { } } public void method2 ( ) { final int [ ] squares = { 0 , 1 , 4 , 9 , 16 , 25 } ; int x ; for ( final int i : squares ) { } } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputFinalLocalVariableNativeMethods { public native String nativeFoo ( int a , int b ) ; private native double average ( int n1 , int n2 ) ; static { System . loadLibrary ( "foo" ) ; } public void print ( ) { String str = nativeFoo ( 1 , 4 ) ; System . out . println ( str ) ; } public static void main ( final String [ ] args ) { ( new InputFinalLocalVariableNativeMethods ( ) ) . print ( ) ; System . out . println ( "In Java, the average is " + new InputFinalLocalVariableNativeMethods ( ) . average ( 3 , 2 ) ) ; return ; } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputFinalize { public InputFinalize ( ) throws Throwable { super . equals ( new String ( ) ) ; super . finalize ( ) ; } public void finalize ( ) throws Throwable { super . finalize ( ) ; } public void method ( ) throws Throwable { super . finalize ( ) ; } { super . finalize ( ) ; } } class NoSuperFinalize { public void finalize ( ) { } } class InnerFinalize { public void finalize ( ) { class Inner { public void finalize ( ) throws Throwable { super . finalize ( ) ; } } } } class MyClassWithGenericSuperMethod1 { void someMethod ( java . util . List < ? super java . util . Map > l ) { } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputStringLiteralEquality { void foo ( String name ) { if ( name == "Lars" ) { } if ( "Oleg" == name ) { } if ( "Oliver" == "Oliver" ) { } String compare = "Rick" ; if ( name == compare ) { } if ( "Rick" . toUpperCase ( ) == "Rick" . toLowerCase ( ) ) { } } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputMultipleVariableDeclarations { int i , j ; int i1 ; int j1 ; void method1 ( ) { String str , str1 ; java . lang . Object obj ; Object obj1 ; } java . lang . String string ; java . lang . String strings [ ] ; java . lang . String string1 ; java . lang . String strings1 [ ] ; void method2 ( ) { for ( int i = 0 , j = 0 ; i < 10 ; i ++ , j -- ) { } for ( int i = 0 ; i < 4 ; i ++ ) { } } }
package com . puppycrawl . tools . checkstyle . coding ; import java . awt . Toolkit ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; public class InputRequireThis { int i ; void method1 ( ) { i = 3 ; } void method2 ( int i ) { i ++ ; this . i = i ; method1 ( ) ; try { this . method1 ( ) ; } catch ( RuntimeException e ) { e . printStackTrace ( ) ; } this . i -- ; Integer . toString ( 10 ) ; } < T > void method3 ( ) { i = 3 ; } void method4 ( ) { this . < String > method3 ( ) ; this . < I > method3 ( ) ; } int I = 0 ; private class I { } } enum MyEnum { A , B { void doSomething ( ) { z = 1 ; } } ; int z ; private MyEnum ( ) { z = 0 ; } } class Bug2123003 { @ Rock ( band = "GnR" ) private String band ; class Inner { @ Rock ( band = { "GnR" } ) private String band ; } class Inner2 { @ Rock ( band = { ( true ) ? "GnR" : "Tool" } ) private String band ; } @ interface Rock { String [ ] band ( ) default "Metallica" ; } } class Bug1155921 { private static int CONST = 1 ; private static int static_method ( ) { return 1 ; } private int method1 ( ) { return CONST ; } private int method2 ( ) { return static_method ( ) ; } } interface Issue155 { String BASE = "A" ; String EXT = BASE + "B" ; } class Issue257 { public void foo ( ) { try ( final InputStream foo = new ByteArrayInputStream ( new byte [ 512 ] ) ) { foo . read ( ) ; } catch ( final IOException e ) { e . printStackTrace ( ) ; } } }
package com . puppycrawl . tools . checkstyle . coding ; import java . * ; import java . util . * ; import org . abego . treelayout . * ; import com . * ; public class InputIllegalTypeStarImports { List < Integer > l = new LinkedList < > ( ) ; }
package com . puppycrawl . tools . checkstyle . coding ; class Foo1 { public void foo ( String text ) { System . out . println ( text ) ; class Bar { void bar ( String text ) { text = "xxx" ; } } } } class Foo2 { public void foo ( ) { int x ; class Bar { void bar ( ) { int x = 1 ; x ++ ; x ++ ; } } } } enum InputFinalLocalVariableNameShadowingEnum { test ; final String foo1 = "error" ; InputFinalLocalVariableNameShadowingEnum ( ) { String foo = foo1 ; foo += foo1 ; } }
package com . puppycrawl . tools . checkstyle . coding ; import java . io . Serializable ; class InputModifiedControl { int k ; void method1 ( ) { for ( int i = 0 ; i < 1 ; i ++ ) { i ++ ; } for ( int i = 0 ; i < 1 ; i ++ ) { i = i + 1 ; } for ( int i = 0 ; i < 1 ; i ++ ) { for ( int j = 0 ; j < 1 ; i ++ ) { -- i ; } } for ( int i = 0 , j = 0 ; i < 1 ; i ++ ) { j ++ ; } for ( int i = 0 ; i < 1 ; i ++ ) { } for ( int i = 0 ; i < 1 ; i ++ ) { int x = i ; } for ( int i = 0 ; i < 1 ; i ++ ) { Serializable s = new Serializable ( ) { int i = 3 ; void a ( ) { System . out . println ( i ++ ) ; } } ; } for ( int k = 0 ; k < 1 ; k ++ ) { this . k ++ ; } String [ ] sa = { "a" , "b" } ; for ( String s : sa ) { } for ( String s : sa ) { s = "new string" ; } for ( int i = 0 ; i < 10 ; ) { i ++ ; } for ( int i = 0 , l = 0 , m = 0 ; l < 10 ; i ++ , m = m + 2 ) { l ++ ; m ++ ; } for ( int i = 0 ; i < 10 ; ) { i = 11 ; } int w = 0 ; for ( int i = 0 ; i < 10 ; java . sql . Date . valueOf ( "" ) , this . i ++ , w ++ ) { i ++ ; w ++ ; } for ( int i = 0 , k = 0 ; i < 10 && k < 10 ; ++ i , ++ k ) { i = i + 3 ; k = k + 4 ; } for ( int i = 0 , j = 0 ; i < 10 ; i ++ ) { j ++ ; } } private int i ; } @ SuppressWarnings ( value = "this previously caused NullPointerException" ) class VariableDeclaredBeforeTheFirstBlockBegins { }
package com . puppycrawl . tools . checkstyle . filters ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import nl . jqno . equalsverifier . EqualsVerifier ; import org . junit . Test ; public class IntRangeFilterTest { @ Test public void testDecide ( ) { final IntFilter filter = new IntRangeFilter ( 0 , 10 ) ; assertFalse ( "less than" , filter . accept ( Integer . valueOf ( - 1 ) ) ) ; assertTrue ( "in range" , filter . accept ( Integer . valueOf ( 0 ) ) ) ; assertTrue ( "in range" , filter . accept ( Integer . valueOf ( 5 ) ) ) ; assertTrue ( "in range" , filter . accept ( Integer . valueOf ( 10 ) ) ) ; assertFalse ( "greater than" , filter . accept ( Integer . valueOf ( 11 ) ) ) ; } @ Test public void testDecideSingle ( ) { final IntFilter filter = new IntRangeFilter ( 0 , 0 ) ; assertFalse ( "less than" , filter . accept ( Integer . valueOf ( - 1 ) ) ) ; assertTrue ( "in range" , filter . accept ( Integer . valueOf ( 0 ) ) ) ; assertFalse ( "greater than" , filter . accept ( Integer . valueOf ( 1 ) ) ) ; } @ Test public void testDecideEmpty ( ) { final IntFilter filter = new IntRangeFilter ( 10 , 0 ) ; assertFalse ( "out" , filter . accept ( Integer . valueOf ( - 1 ) ) ) ; assertFalse ( "out" , filter . accept ( Integer . valueOf ( 0 ) ) ) ; assertFalse ( "out" , filter . accept ( Integer . valueOf ( 5 ) ) ) ; assertFalse ( "out" , filter . accept ( Integer . valueOf ( 10 ) ) ) ; assertFalse ( "out" , filter . accept ( Integer . valueOf ( 11 ) ) ) ; } @ Test public void testEquals ( ) { final IntFilter filter = new IntRangeFilter ( 0 , 2 ) ; final IntFilter filter2 = new IntRangeFilter ( 0 , 2 ) ; final IntFilter filter3 = new IntRangeFilter ( 0 , 1 ) ; final IntFilter filter4 = new IntRangeFilter ( 1 , 2 ) ; assertEquals ( "[0,2] == [0,2]" , filter , filter2 ) ; assertFalse ( "[0,2] != [0,1]" , filter . equals ( filter3 ) ) ; assertFalse ( "[0,2] != [1,2]" , filter . equals ( filter4 ) ) ; assertFalse ( "[0,2] != this" , filter . equals ( this ) ) ; assertFalse ( "[0,2] != null" , filter . equals ( null ) ) ; } @ Test public void testEqualsAndHashCode ( ) { EqualsVerifier . forClass ( IntRangeFilter . class ) . usingGetClass ( ) . verify ( ) ; } }
package com . puppycrawl . tools . checkstyle ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . LocalizedMessage ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; import java . util . TreeSet ; import org . junit . Test ; public class CheckerTest { @ Test public void testDestroy ( ) throws Exception { final DebugChecker c = new DebugChecker ( ) ; final DebugAuditAdapter aa = new DebugAuditAdapter ( ) ; c . addListener ( aa ) ; final DebugFilter f = new DebugFilter ( ) ; c . addFilter ( f ) ; c . destroy ( ) ; c . fireAuditStarted ( ) ; c . fireAuditFinished ( ) ; c . fireFileStarted ( "Some File Name" ) ; c . fireFileFinished ( "Some File Name" ) ; final TreeSet < LocalizedMessage > msgs = Sets . newTreeSet ( ) ; msgs . add ( new LocalizedMessage ( 0 , 0 , "a Bundle" , "message.key" , new Object [ ] { "arg" } , null , getClass ( ) , null ) ) ; c . fireErrors ( "Some File Name" , msgs ) ; assertFalse ( "Checker.destroy() doesn't remove listeners." , aa . wasCalled ( ) ) ; assertFalse ( "Checker.destroy() doesn't remove filters." , f . wasCalled ( ) ) ; } @ Test public void testAddListener ( ) throws Exception { final DebugChecker c = new DebugChecker ( ) ; final DebugAuditAdapter aa = new DebugAuditAdapter ( ) ; c . addListener ( aa ) ; c . fireAuditStarted ( ) ; assertTrue ( "Checker.fireAuditStarted() doesn't call listener" , aa . wasCalled ( ) ) ; aa . resetListener ( ) ; c . fireAuditFinished ( ) ; assertTrue ( "Checker.fireAuditFinished() doesn't call listener" , aa . wasCalled ( ) ) ; aa . resetListener ( ) ; c . fireFileStarted ( "Some File Name" ) ; assertTrue ( "Checker.fireFileStarted() doesn't call listener" , aa . wasCalled ( ) ) ; aa . resetListener ( ) ; c . fireFileFinished ( "Some File Name" ) ; assertTrue ( "Checker.fireFileFinished() doesn't call listener" , aa . wasCalled ( ) ) ; aa . resetListener ( ) ; final TreeSet < LocalizedMessage > msgs = Sets . newTreeSet ( ) ; msgs . add ( new LocalizedMessage ( 0 , 0 , "a Bundle" , "message.key" , new Object [ ] { "arg" } , null , getClass ( ) , null ) ) ; c . fireErrors ( "Some File Name" , msgs ) ; assertTrue ( "Checker.fireErrors() doesn't call listener" , aa . wasCalled ( ) ) ; } @ Test public void testRemoveListener ( ) throws Exception { final DebugChecker c = new DebugChecker ( ) ; final DebugAuditAdapter aa = new DebugAuditAdapter ( ) ; final DebugAuditAdapter aa2 = new DebugAuditAdapter ( ) ; c . addListener ( aa ) ; c . addListener ( aa2 ) ; c . removeListener ( aa ) ; c . fireAuditStarted ( ) ; assertTrue ( "Checker.fireAuditStarted() doesn't call listener" , aa2 . wasCalled ( ) ) ; assertFalse ( "Checker.fireAuditStarted() does call removed listener" , aa . wasCalled ( ) ) ; aa2 . resetListener ( ) ; c . fireAuditFinished ( ) ; assertTrue ( "Checker.fireAuditFinished() doesn't call listener" , aa2 . wasCalled ( ) ) ; assertFalse ( "Checker.fireAuditFinished() does call removed listener" , aa . wasCalled ( ) ) ; aa2 . resetListener ( ) ; c . fireFileStarted ( "Some File Name" ) ; assertTrue ( "Checker.fireFileStarted() doesn't call listener" , aa2 . wasCalled ( ) ) ; assertFalse ( "Checker.fireFileStarted() does call removed listener" , aa . wasCalled ( ) ) ; aa2 . resetListener ( ) ; c . fireFileFinished ( "Some File Name" ) ; assertTrue ( "Checker.fireFileFinished() doesn't call listener" , aa2 . wasCalled ( ) ) ; assertFalse ( "Checker.fireFileFinished() does call removed listener" , aa . wasCalled ( ) ) ; aa2 . resetListener ( ) ; final TreeSet < LocalizedMessage > msgs = Sets . newTreeSet ( ) ; msgs . add ( new LocalizedMessage ( 0 , 0 , "a Bundle" , "message.key" , new Object [ ] { "arg" } , null , getClass ( ) , null ) ) ; c . fireErrors ( "Some File Name" , msgs ) ; assertTrue ( "Checker.fireErrors() doesn't call listener" , aa2 . wasCalled ( ) ) ; assertFalse ( "Checker.fireErrors() does call removed listener" , aa . wasCalled ( ) ) ; } @ Test public void testAddFilter ( ) throws Exception { final DebugChecker c = new DebugChecker ( ) ; final DebugFilter f = new DebugFilter ( ) ; c . addFilter ( f ) ; f . resetFilter ( ) ; final TreeSet < LocalizedMessage > msgs = Sets . newTreeSet ( ) ; msgs . add ( new LocalizedMessage ( 0 , 0 , "a Bundle" , "message.key" , new Object [ ] { "arg" } , null , getClass ( ) , null ) ) ; c . fireErrors ( "Some File Name" , msgs ) ; assertTrue ( "Checker.fireErrors() doesn't call filter" , f . wasCalled ( ) ) ; } @ Test public void testRemoveFilter ( ) throws Exception { final DebugChecker c = new DebugChecker ( ) ; final DebugFilter f = new DebugFilter ( ) ; final DebugFilter f2 = new DebugFilter ( ) ; c . addFilter ( f ) ; c . addFilter ( f2 ) ; c . removeFilter ( f ) ; f2 . resetFilter ( ) ; final TreeSet < LocalizedMessage > msgs = Sets . newTreeSet ( ) ; msgs . add ( new LocalizedMessage ( 0 , 0 , "a Bundle" , "message.key" , new Object [ ] { "arg" } , null , getClass ( ) , null ) ) ; c . fireErrors ( "Some File Name" , msgs ) ; assertTrue ( "Checker.fireErrors() doesn't call filter" , f2 . wasCalled ( ) ) ; assertFalse ( "Checker.fireErrors() does call removed filter" , f . wasCalled ( ) ) ; } @ Test public void testFileExtensions ( ) throws Exception { final Checker c = new Checker ( ) ; final List < File > files = new ArrayList < > ( ) ; File f = new File ( "file.pdf" ) ; files . add ( f ) ; f = new File ( "file.java" ) ; files . add ( f ) ; final String [ ] fileExtensions = { "java" , "xml" , "properties" } ; c . setFileExtensions ( fileExtensions ) ; final int counter = c . process ( files ) ; assertEquals ( counter , 1 ) ; } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputReturnFromCatchCheck { public void foo ( ) { try { System . currentTimeMillis ( ) ; } catch ( Exception e ) { return ; } } public void bar ( ) { try { System . currentTimeMillis ( ) ; } catch ( Exception e ) { if ( System . currentTimeMillis ( ) == 0 ) { return ; } } } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputIllegalCatchCheck2 { public void foo ( ) throws OneMoreException { try { foo1 ( ) ; } catch ( RuntimeException | SQLException e ) { } try { foo1 ( ) ; } catch ( RuntimeException | SQLException | OneMoreException e ) { } try { foo1 ( ) ; } catch ( OneMoreException | RuntimeException | SQLException e ) { } try { foo1 ( ) ; } catch ( OneMoreException | SQLException | RuntimeException e ) { } } private void foo1 ( ) throws RuntimeException , SQLException , OneMoreException { } private class SQLException extends Exception { } private class OneMoreException extends Exception { } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputMissingCtor { } abstract class AbstactClass { } class CorrectClass { CorrectClass ( ) { } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputFinalLocalVariableCheckFalsePositive { public void method ( ) { final java . util . List < Object > list = new java . util . ArrayList < > ( ) ; for ( int i = 0 , s0 = list . size ( ) ; i < s0 ; i ++ ) { } } public void method1 ( ) { final java . util . List < Object > list = new java . util . ArrayList < > ( ) ; for ( int i = 0 , s0 = list . size ( ) ; i < s0 ; s0 ++ ) { } } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputNestedForDepth { public void nestedForFiveLevel ( ) { int i = 0 ; int i1 = 0 ; int i2 = 0 ; int i3 = 0 ; int i4 = 0 ; int i5 = 0 ; for ( i1 = 0 ; i1 < 10 ; i1 ++ ) { for ( i2 = 0 ; i2 < 10 ; i2 ++ ) { for ( i3 = 0 ; i3 < 10 ; i3 ++ ) { for ( i4 = 0 ; i4 < 10 ; i4 ++ ) { for ( i5 = 0 ; i5 < 10 ; i5 ++ ) { i += 1 ; } } } } } } }
package com . puppycrawl . tools . checkstyle . coding ; class OverloadInput { public void overloadMethod ( int i ) { } public void overloadMethod ( String s ) { } public void overloadMethod ( boolean b ) { } public void fooMethod ( ) { } public void overloadMethod ( String s , Boolean b , int i ) { } OverloadInput anonynous = new OverloadInput ( ) { public void overloadMethod ( int i ) { } public void overloadMethod ( String s ) { } public void overloadMethod ( boolean b ) { } public void fooMethod ( ) { } public void overloadMethod ( String s , Boolean b , int i ) { } } ; } interface Fooable { public abstract void foo ( int i ) ; public abstract void foo ( String s ) ; public abstract void noFoo ( ) ; public abstract void foo ( String s , Boolean b , int i ) ; } enum FooType { Strategy ( "" ) , Shooter ( "" ) , RPG ( "" ) ; private String description ; private FooType ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } public void overloadMethod ( int i ) { } public void overloadMethod ( String s ) { } public void overloadMethod ( boolean b ) { } public void fooMethod ( ) { } public void overloadMethod ( String s , Boolean b , int i ) { } }
package com . puppycrawl . tools . checkstyle . coding ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . jar . JarInputStream ; import java . util . jar . Manifest ; public class InputInnerAssignment { void innerAssignments ( ) { int a ; int b ; int c ; a = b = c = 1 ; String s = Integer . toString ( b = 2 ) ; Integer i = new Integer ( a += 5 ) ; c = b ++ ; for ( int j = 0 ; j < 6 ; j += 2 ) { a += j ; } } public void demoBug1195047Comment3 ( ) { int y = 1 ; int b = 0 ; boolean bb ; int i ; if ( bb = false ) { } for ( i = 0 ; bb = false ; i = i + 1 ) { } while ( bb = false ) { } if ( ( bb = false ) ) { } for ( int j = 0 ; ( bb = false ) ; j += 1 ) { } while ( ( bb = false ) ) { } i = ( bb = false ) ? ( b = 2 ) : ( b += 1 ) ; i = ( b += 1 ) + ( b -= 1 ) ; do { i += 1 ; } while ( bb = false ) ; } public static void demoInputStreamIdiom ( java . io . InputStream is ) throws java . io . IOException { int b ; while ( ( b = is . read ( ) ) != - 1 ) { } } public static void demoNoBrace ( ) { int sum = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) sum = sum + i ; if ( sum > 4 ) sum += 2 ; else if ( sum < 2 ) sum += 1 ; else sum += 100 ; while ( sum > 4 ) sum -= 1 ; do sum = sum + 1 ; while ( sum < 6 ) ; } @ SuppressWarnings ( value = "unchecked" ) public java . util . Collection < Object > allParams ( ) { java . util . ArrayList params = new java . util . ArrayList ( ) ; params . add ( "one" ) ; params . add ( "two" ) ; return params ; } private static Manifest loadManifest ( String fn ) { try ( FileInputStream fis = new FileInputStream ( fn ) ; JarInputStream jis = new JarInputStream ( fis , false ) ) { return jis . getManifest ( ) ; } catch ( IOException e ) { return null ; } } }
package com . puppycrawl . tools . checkstyle . coding ; import static com . puppycrawl . tools . checkstyle . checks . CheckUtils . isElseIf ; import static com . puppycrawl . tools . checkstyle . checks . CheckUtils . * ; import static com . puppycrawl . tools . checkstyle . coding . InputIllegalType . SomeStaticClass ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class InputIllegalTypeStaticImports { private boolean foo ( DetailAST ast ) { return isElseIf ( ast ) ; } SomeStaticClass staticClass ; private static SomeStaticClass foo1 ( ) { return null ; } private static void foo2 ( SomeStaticClass s ) { } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputFallThrough { void method ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : case 1 : i ++ ; break ; case 2 : i ++ ; case 3 : i ++ ; break ; case 4 : return ; case 5 : throw new RuntimeException ( "" ) ; case 6 : continue ; case 7 : { break ; } case 8 : { return ; } case 9 : { throw new RuntimeException ( "" ) ; } case 10 : { continue ; } case 11 : { i ++ ; } case 12 : if ( false ) break ; else break ; case 13 : if ( true ) { return ; } case 14 : if ( true ) { return ; } else { } case 15 : do { System . out . println ( "something" ) ; return ; } while ( true ) ; case 16 : for ( int j1 = 0 ; j1 < 10 ; j1 ++ ) { System . err . println ( "something" ) ; return ; } case 17 : while ( true ) throw new RuntimeException ( "" ) ; case 18 : while ( cond ) { break ; } case 19 : try { i ++ ; break ; } catch ( RuntimeException e ) { break ; } catch ( Error e ) { return ; } case 20 : try { i ++ ; break ; } catch ( RuntimeException e ) { } catch ( Error e ) { return ; } case 21 : try { i ++ ; } catch ( RuntimeException e ) { i -- ; } finally { break ; } case 22 : try { i ++ ; break ; } catch ( RuntimeException e ) { i -- ; break ; } finally { i ++ ; } case 23 : switch ( j ) { case 1 : continue ; case 2 : return ; default : return ; } case 24 : switch ( j ) { case 1 : continue ; case 2 : break ; default : return ; } default : i ++ ; } } } void methodFallThru ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case - 1 : case 0 : case 1 : i ++ ; break ; case 2 : i ++ ; case 3 : i ++ ; break ; case 4 : return ; case 5 : throw new RuntimeException ( "" ) ; case 6 : continue ; case 7 : { break ; } case 8 : { return ; } case 9 : { throw new RuntimeException ( "" ) ; } case 10 : { continue ; } case 11 : { i ++ ; } case 12 : if ( false ) break ; else break ; case 13 : if ( true ) { return ; } case 14 : if ( true ) { return ; } else { } case 15 : do { System . out . println ( "something" ) ; return ; } while ( true ) ; case 16 : for ( int j1 = 0 ; j1 < 10 ; j1 ++ ) { System . err . println ( "something" ) ; return ; } case 17 : while ( cond ) throw new RuntimeException ( "" ) ; case 18 : while ( cond ) { break ; } case 19 : try { i ++ ; break ; } catch ( RuntimeException e ) { break ; } catch ( Error e ) { return ; } case 20 : try { i ++ ; break ; } catch ( RuntimeException e ) { } catch ( Error e ) { return ; } case 21 : try { i ++ ; } catch ( RuntimeException e ) { i -- ; } finally { break ; } case 22 : try { i ++ ; break ; } catch ( RuntimeException e ) { i -- ; break ; } finally { i ++ ; } case 23 : switch ( j ) { case 1 : continue ; case 2 : return ; default : return ; } case 24 : i ++ ; case 25 : i ++ ; break ; case 26 : switch ( j ) { case 1 : continue ; case 2 : break ; default : return ; } default : i ++ ; } } } void methodFallThruCC ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : i ++ ; case 1 : i ++ ; case 2 : { i ++ ; } case 3 : i ++ ; case 4 : break ; case 5 : i ++ ; } } } void methodFallThruC ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : i ++ ; case 1 : i ++ ; case 2 : i ++ ; case 3 : break ; case 4 : i ++ ; } } } void methodFallThruC2 ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : i ++ ; case 1 : i ++ ; case 2 : i ++ ; case 3 : break ; case 4 : i ++ ; } } } void methodFallThruCOtherWords ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : i ++ ; case 1 : i ++ ; case 2 : i ++ ; case 3 : break ; case 4 : i ++ ; } } } void methodFallThruCCustomWords ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : i ++ ; case 1 : i ++ ; case 2 : i ++ ; case 3 : break ; case 4 : i ++ ; } } } void methodFallThruLastCaseGroup ( int i , int j , boolean cond ) { while ( true ) { switch ( i ) { case 0 : i ++ ; } switch ( i ) { case 0 : i ++ ; } switch ( i ) { case 0 : i ++ ; } } } void method1472228 ( int i ) { switch ( i ) { case 2 : break ; default : } } void nestedSwitches ( ) { switch ( hashCode ( ) ) { case 1 : switch ( hashCode ( ) ) { case 1 : } default : } } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputFinalLocalVariable { private int m_ClassVariable = 0 ; static { int i , j = 0 ; Runnable runnable = new Runnable ( ) { public void run ( ) { } } ; } public InputFinalLocalVariable ( ) { int i = 0 ; final int j = 2 ; int z ; Object obj = new Object ( ) ; int k = 0 ; String x = obj . toString ( ) ; k ++ ; k = 2 ; Runnable runnable = new Runnable ( ) { public void run ( ) { int q = 0 ; } } ; } public void method ( int aArg , final int aFinal , int aArg2 ) { int z = 0 ; z ++ ; aArg2 ++ ; } public void aMethod ( ) { int i = 0 ; final int j = 2 ; int z ; Object obj = new Object ( ) ; int k = 0 ; String x = obj . toString ( ) ; k ++ ; final class Inner { public Inner ( ) { int w = 0 ; Runnable runnable = new Runnable ( ) { public void run ( ) { } } ; } } } public void anotherMethod ( ) { boolean aBool = true ; for ( int i = 0 , j = 1 , k = 1 ; j < 10 ; j ++ ) { k ++ ; aBool = false ; } int l = 0 ; { int weird = 0 ; int j = 0 ; int k = 0 ; { l ++ ; } } int weird = 0 ; weird ++ ; final InnerClass ic = new InnerClass ( ) ; ic . mInner2 = 1 ; } class InnerClass { private int mInner = 0 ; public int mInner2 = 0 ; } } interface Inter { void method ( int aParam ) ; } abstract class AbstractClass { public abstract void abstractMethod ( int aParam ) ; } class Blah { static { for ( int a : getInts ( ) ) { } } static int [ ] getInts ( ) { return null ; } } class test_1241722 { private Object o_ ; public void doSomething ( Object _o ) { System . out . println ( _o ) ; } public void doSomething2 ( Object _o1 ) { o_ = _o1 ; } } class class1 { public class1 ( final int x ) { } }
package com . puppycrawl . tools . checkstyle . filters ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . LocalizedMessage ; import com . puppycrawl . tools . checkstyle . api . SeverityLevel ; import org . junit . Test ; public class SeverityMatchFilterTest { private final SeverityMatchFilter filter = new SeverityMatchFilter ( ) ; @ Test public void testDefault ( ) { final AuditEvent ev = new AuditEvent ( this , "Test.java" ) ; assertFalse ( "no message" , filter . accept ( ev ) ) ; SeverityLevel level = SeverityLevel . ERROR ; LocalizedMessage message = new LocalizedMessage ( 0 , 0 , "" , "" , null , level , null , this . getClass ( ) , null ) ; final AuditEvent ev2 = new AuditEvent ( this , "ATest.java" , message ) ; assertTrue ( "level:" + level , filter . accept ( ev2 ) ) ; level = SeverityLevel . INFO ; message = new LocalizedMessage ( 0 , 0 , "" , "" , null , level , null , this . getClass ( ) , null ) ; final AuditEvent ev3 = new AuditEvent ( this , "ATest.java" , message ) ; assertFalse ( "level:" + level , filter . accept ( ev3 ) ) ; } @ Test public void testSeverity ( ) { filter . setSeverity ( "info" ) ; final AuditEvent ev = new AuditEvent ( this , "Test.java" ) ; assertTrue ( "no message" , filter . accept ( ev ) ) ; SeverityLevel level = SeverityLevel . ERROR ; LocalizedMessage message = new LocalizedMessage ( 0 , 0 , "" , "" , null , level , null , this . getClass ( ) , null ) ; final AuditEvent ev2 = new AuditEvent ( this , "ATest.java" , message ) ; assertFalse ( "level:" + level , filter . accept ( ev2 ) ) ; level = SeverityLevel . INFO ; message = new LocalizedMessage ( 0 , 0 , "" , "" , null , level , null , this . getClass ( ) , null ) ; final AuditEvent ev3 = new AuditEvent ( this , "ATest.java" , message ) ; assertTrue ( "level:" + level , filter . accept ( ev3 ) ) ; } @ Test public void testAcceptOnMatch ( ) { filter . setSeverity ( "info" ) ; filter . setAcceptOnMatch ( false ) ; final AuditEvent ev = new AuditEvent ( this , "Test.java" ) ; assertFalse ( "no message" , filter . accept ( ev ) ) ; SeverityLevel level = SeverityLevel . ERROR ; LocalizedMessage message = new LocalizedMessage ( 0 , 0 , "" , "" , null , level , null , this . getClass ( ) , null ) ; final AuditEvent ev2 = new AuditEvent ( this , "ATest.java" , message ) ; assertTrue ( "level:" + level , filter . accept ( ev2 ) ) ; level = SeverityLevel . INFO ; message = new LocalizedMessage ( 0 , 0 , "" , "" , null , level , null , this . getClass ( ) , null ) ; final AuditEvent ev3 = new AuditEvent ( this , "ATest.java" , message ) ; assertFalse ( "level:" + level , filter . accept ( ev3 ) ) ; } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputReturnFromFinallyCheck { public void foo ( ) { try { System . currentTimeMillis ( ) ; } finally { return ; } } public void bar ( ) { try { System . currentTimeMillis ( ) ; } finally { if ( System . currentTimeMillis ( ) == 0 ) { return ; } } } public void thisNull ( ) { boolean result = ( this == null ) || ( null == this ) ; boolean result2 = ( this != null ) && ( null != this ) ; boolean result3 = ( this . getClass ( ) . getName ( ) == String . valueOf ( null == System . getProperty ( "abc" ) ) ) ; } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputNestedTryDepth { void foo ( ) { try { } catch ( Exception e ) { } try { try { } catch ( Exception e ) { } } catch ( Exception e ) { } try { try { try { } catch ( Exception e ) { } } catch ( Exception e ) { } } catch ( Exception e ) { } try { try { try { try { } catch ( Exception e ) { } } catch ( Exception e ) { } } catch ( Exception e ) { } } catch ( Exception e ) { } } }
package com . puppycrawl . tools . checkstyle . coding ; import java . util . * ; public class InputVariableDeclarationUsageDistanceCheck { private static int test1 = 0 ; static { int b = 0 ; int d = 0 ; { d = ++ b ; } } static { int c = 0 ; int a = 3 ; int b = 2 ; { a = a + b ; c = b ; } { c -- ; } a = 7 ; } static { int a = - 1 ; int b = 2 ; b ++ ; int c = -- b ; a = b ; } public InputVariableDeclarationUsageDistanceCheck ( int test1 ) { int temp = - 1 ; this . test1 = test1 ; temp = test1 ; } public boolean testMethod ( ) { int temp = 7 ; new InputVariableDeclarationUsageDistanceCheck ( 2 ) ; String . valueOf ( temp ) ; boolean result = false ; String str = "" ; if ( test1 > 1 ) { str = "123" ; result = true ; } return result ; } public void testMethod2 ( ) { int count ; int a = 3 ; int b = 2 ; { a = a + b - 5 + 2 * a ; count = b ; } } public void testMethod3 ( ) { int count ; int a = 3 ; int b = 3 ; a = a + b ; b = a + a ; testMethod2 ( ) ; count = b ; } public void testMethod4 ( int arg ) { int d = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { d ++ ; if ( i > 5 ) { d += arg ; } } String ar [ ] = { "1" , "2" } ; for ( String st : ar ) { System . out . println ( st ) ; } } public void testMethod5 ( ) { int arg = 7 ; boolean b = true ; boolean bb = false ; if ( b ) if ( ! bb ) b = false ; testMethod4 ( arg ) ; } public void testMethod6 ( ) { int blockNumWithSimilarVar = 3 ; int dist = 0 ; int index = 0 ; int block = 0 ; if ( blockNumWithSimilarVar <= 1 ) { do { dist ++ ; if ( block > 4 ) { break ; } index ++ ; block ++ ; } while ( index < 7 ) ; } else { while ( index < 8 ) { dist += block ; index ++ ; block ++ ; } } } public boolean testMethod7 ( int a ) { boolean res ; switch ( a ) { case 1 : res = true ; break ; default : res = false ; } return res ; } public void testMethod8 ( ) { int b = 0 ; int c = 0 ; int m = 0 ; int n = 0 ; { c ++ ; b ++ ; } { n ++ ; m ++ ; b ++ ; } } public void testMethod9 ( ) { boolean result = false ; boolean b1 = true ; boolean b2 = false ; if ( b1 ) { if ( ! b2 ) { result = true ; } result = true ; } } public boolean testMethod10 ( ) { boolean result ; try { result = true ; } catch ( Exception e ) { result = false ; } finally { result = false ; } return result ; } public void testMethod11 ( ) { int a = 0 ; int b = 10 ; boolean result ; try { b -- ; } catch ( Exception e ) { b ++ ; result = false ; } finally { a ++ ; } } public void testMethod12 ( ) { boolean result = false ; boolean b3 = true ; boolean b1 = true ; boolean b2 = false ; if ( b1 ) { if ( b3 ) { if ( ! b2 ) { result = true ; } result = true ; } } } public void testMethod13 ( ) { int i = 9 ; int j = 6 ; int g = i + 8 ; int k = j + 10 ; } public void testMethod14 ( ) { Session s = openSession ( ) ; Transaction t = s . beginTransaction ( ) ; A a = new A ( ) ; E d1 = new E ( ) ; C1 c = new C1 ( ) ; E d2 = new E ( ) ; a . setForward ( d1 ) ; d1 . setReverse ( a ) ; c . setForward ( d2 ) ; d2 . setReverse ( c ) ; Serializable aid = s . save ( a ) ; Serializable d2id = s . save ( d2 ) ; t . commit ( ) ; s . close ( ) ; } public boolean isCheckBoxEnabled ( int path ) { String model = "" ; if ( true ) { for ( int index = 0 ; index < path ; ++ index ) { int nodeIndex = model . codePointAt ( path ) ; if ( model . contains ( "" ) ) { return false ; } } } else { int nodeIndex = model . codePointAt ( path ) ; if ( model . contains ( "" ) ) { return false ; } } return true ; } public Object readObject ( String in ) throws Exception { String startDay = new String ( "" ) ; String endDay = new String ( "" ) ; return new String ( startDay + endDay ) ; } public int [ ] getSelectedIndices ( ) { int [ ] selected = new int [ 5 ] ; String model = "" ; int a = 0 ; a ++ ; for ( int index = 0 ; index < 5 ; ++ index ) { selected [ index ] = Integer . parseInt ( model . valueOf ( a ) ) ; } return selected ; } public void testMethod15 ( ) { String confDebug = "" ; if ( ! confDebug . equals ( "" ) && ! confDebug . equals ( "null" ) ) { LogLog . warn ( "The \"" + "\" attribute is deprecated." ) ; LogLog . warn ( "Use the \"" + "\" attribute instead." ) ; LogLog . setInternalDebugging ( confDebug , true ) ; } int i = 0 ; int k = 7 ; boolean b = false ; for ( ; i < k ; i ++ ) { b = true ; k ++ ; } int sw ; switch ( i ) { case 0 : k ++ ; sw = 0 ; break ; case 1 : b = false ; break ; default : b = true ; } int wh = 0 ; b = true ; do { k -- ; i ++ ; } while ( wh > 0 ) ; if ( wh > 0 ) { k ++ ; } else if ( ! b ) { i ++ ; } else { i -- ; } } public void testMethod16 ( ) { int wh = 1 , i = 4 , k = 0 ; if ( i > 0 ) { k ++ ; } else if ( wh > 0 ) { i ++ ; } else { i -- ; } } protected JMenuItem createSubMenuItem ( LogLevel level ) { final JMenuItem result = new JMenuItem ( level . toString ( ) ) ; final LogLevel logLevel = level ; result . setMnemonic ( level . toString ( ) . charAt ( 0 ) ) ; result . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { showLogLevelColorChangeDialog ( result , logLevel ) ; } } ) ; return result ; } public static Color darker ( Color color , double fraction ) { int red = ( int ) Math . round ( color . getRed ( ) * ( 1.0 - fraction ) ) ; int green = ( int ) Math . round ( color . getGreen ( ) * ( 1.0 - fraction ) ) ; int blue = ( int ) Math . round ( color . getBlue ( ) * ( 1.0 - fraction ) ) ; if ( red < 0 ) { red = 0 ; } else if ( red > 255 ) { red = 255 ; } if ( green < 0 ) { green = 0 ; } else if ( green > 255 ) { green = 255 ; } if ( blue < 0 ) { } int alpha = color . getAlpha ( ) ; return new Color ( red , green , blue , alpha ) ; } public void testFinal ( ) { AuthUpdateTask authUpdateTask = null ; final long intervalMs = 30 * 60000L ; Object authCheckUrl = null , authInfo = null ; authUpdateTask = new AuthUpdateTask ( authCheckUrl , authInfo , new IAuthListener ( ) { @ Override public void authTokenChanged ( String cookie , String token ) { fireAuthTokenChanged ( cookie , token ) ; } } ) ; Timer authUpdateTimer = new Timer ( "Auth Guard" , true ) ; authUpdateTimer . schedule ( authUpdateTask , intervalMs / 2 , intervalMs ) ; } public void testForCycle ( ) { int filterCount = 0 ; for ( int i = 0 ; i < 10 ; i ++ , filterCount ++ ) { int abc = 0 ; System . out . println ( abc ) ; for ( int j = 0 ; j < 10 ; j ++ ) { abc = filterCount ; System . out . println ( abc ) ; } } } public void testIssue32_1 ( ) { Option srcDdlFile = OptionBuilder . create ( "f" ) ; Option logDdlFile = OptionBuilder . create ( "o" ) ; Option help = OptionBuilder . create ( "h" ) ; Options options = new Options ( ) ; options . something ( ) ; options . something ( ) ; options . something ( ) ; options . something ( ) ; options . addOption ( srcDdlFile , logDdlFile , help ) ; } public void testIssue32_2 ( ) { int mm = Integer . parseInt ( "2" ) ; long timeNow = 0 ; Calendar cal = Calendar . getInstance ( ) ; cal . setTimeInMillis ( timeNow ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; cal . set ( Calendar . HOUR_OF_DAY , mm ) ; cal . set ( Calendar . MINUTE , mm ) ; } public void testIssue32_3 ( MyObject [ ] objects ) { Calendar cal = Calendar . getInstance ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { objects [ i ] . setEnabled ( true ) ; objects [ i ] . setColor ( 0x121212 ) ; objects [ i ] . setUrl ( "http://google.com" ) ; objects [ i ] . setSize ( 789 ) ; objects [ i ] . setCalendar ( cal ) ; } } public String testIssue32_4 ( boolean flag ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( "flag is " ) ; builder . append ( flag ) ; final String line = "" ; if ( flag ) { builder . append ( "line of AST is:" ) ; builder . append ( "\n" ) ; builder . append ( String . valueOf ( line ) ) ; builder . append ( "\n" ) ; } return builder . toString ( ) ; } public void testIssue32_5 ( ) { Option a = null ; Option b = null ; Option c = null ; boolean isCNull = isNull ( c ) ; boolean isBNull = isNull ( b ) ; boolean isANull = isNull ( a ) ; } public void testIssue32_6 ( ) { Option aOpt = null ; Option bOpt = null ; Option cOpt = null ; isNull ( cOpt ) ; isNull ( bOpt ) ; isNull ( aOpt ) ; } public void testIssue32_7 ( ) { String line = "abc" ; writer . write ( line ) ; line . charAt ( 1 ) ; builder . append ( line ) ; test ( line , line , line ) ; } public void testIssue32_8 ( Writer w1 , Writer w2 , Writer w3 ) { String l1 = "1" , l2 = "2" , l3 = "3" ; w1 . write ( l3 ) ; w2 . write ( l2 ) ; w3 . write ( l1 ) ; } public void testIssue32_9 ( ) { Options options = new Options ( ) ; Option myOption = null ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; System . out . println ( "message" ) ; myOption . setArgName ( "abc" ) ; } public void testIssue32_10 ( ) { Options options = new Options ( ) ; Option myOption = null ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; options . addBindFile ( null ) ; myOption . setArgName ( "q" ) ; } public int testIssue32_11 ( String toDir ) throws Exception { int count = 0 ; String [ ] files = { } ; System . out . println ( "Data archivation started" ) ; files . notify ( ) ; System . out . println ( "sss" ) ; if ( files == null || files . length == 0 ) { System . out . println ( "No files on a remote site" ) ; } else { System . out . println ( "Files on remote site: " + files . length ) ; for ( String ftpFile : files ) { if ( files . length == 0 ) { "" . concat ( "" ) ; ftpFile . concat ( files [ 2 ] ) ; count ++ ; } } } System . out . println ( ) ; return count ; } private TreeMapNode buildTree ( Object [ ] [ ] tree ) { int k = 0 ; tree . notify ( ) ; TreeMapNode root = null ; for ( Object [ ] s : tree ) { Integer id = ( Integer ) s [ 0 ] ; String label = ( String ) s [ 1 ] ; Integer parentId = ( Integer ) s [ 2 ] ; Number weight = ( Number ) s [ 3 ] ; Number value = ( Number ) s [ 4 ] ; Integer childCount = ( Integer ) s [ 5 ] ; TreeMapNode node ; if ( childCount == 0 ) { node = new TreeMapNode ( label , weight != null ? weight . doubleValue ( ) : 0.0 , new DefaultValue ( value != null ? value . doubleValue ( ) : 0.0 ) ) ; } else { node = new TreeMapNode ( label ) ; } System . out . println ( id . toString ( ) + node ) ; System . out . println ( node . toString ( ) + id ) ; if ( parentId == null || parentId == - 1 ) { root = node ; } else { System . out . println ( parentId . toString ( ) + node ) ; } } return root ; } private Session openSession ( ) { return null ; } class Session { public Transaction beginTransaction ( ) { return null ; } public void close ( ) { } public Serializable save ( E d2 ) { return null ; } public Serializable save ( A a ) { return null ; } } class Transaction { public void commit ( ) { } } class A { public void setForward ( E d1 ) { } } class E { public void setReverse ( C1 c ) { } public void setReverse ( A a ) { } } class C1 { public void setForward ( E d2 ) { } } class Serializable { } class JMenuItem { public JMenuItem ( String string ) { } public void addActionListener ( ActionListener actionListener ) { } public void setMnemonic ( char charAt ) { } } class LogLevel { } class ActionListener { } class ActionEvent { } private void showLogLevelColorChangeDialog ( JMenuItem j , LogLevel l ) { } static class Color { public Color ( int red , int green , int blue , int alpha ) { } public double getRed ( ) { return 0 ; } public int getAlpha ( ) { return 0 ; } public double getBlue ( ) { return 0 ; } public double getGreen ( ) { return 0 ; } } class AuthUpdateTask { public AuthUpdateTask ( Object authCheckUrl , Object authInfo , IAuthListener iAuthListener ) { } } interface IAuthListener { void authTokenChanged ( String cookie , String token ) ; } void fireAuthTokenChanged ( String s , String s1 ) { } class Timer { public Timer ( String string , boolean b ) { } public void schedule ( AuthUpdateTask authUpdateTask , long l , long intervalMs ) { } } class Option { public void setArgName ( String string ) { } } boolean isNull ( Option o ) { return false ; } class Writer { public void write ( String l3 ) { } } class Options { public void addBindFile ( Object object ) { } public void addOption ( Option srcDdlFile , Option logDdlFile , Option help ) { } public void something ( ) { } } class TreeMapNode { public TreeMapNode ( String label , double d , DefaultValue defaultValue ) { } public TreeMapNode ( String label ) { } } class DefaultValue { public DefaultValue ( double d ) { } } static class LogLog { public static void warn ( String string ) { } public static void setInternalDebugging ( String confDebug , boolean b ) { } } static class OptionBuilder { public static Option create ( String string ) { return null ; } } class MyObject { public void setEnabled ( boolean b ) { } public void setCalendar ( Calendar cal ) { } public void setSize ( int i ) { } public void setUrl ( String string ) { } public void setColor ( int i ) { } } static class writer { public static void write ( String line ) { } } void test ( String s , String s1 , String s2 ) { } static class builder { public static void append ( String line ) { } } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputDefaultComesLast { void method ( int i ) { switch ( i ) { case 1 : break ; case 2 : break ; default : } switch ( i ) { case 1 : break ; case 2 : break ; } switch ( i ) { case 1 : break ; default : break ; case 2 : break ; } } } @ interface InputDefaultComesLastAnnotation { int blag ( ) default 1 ; }
package com . puppycrawl . tools . checkstyle . coding ; public class InputUnnecessaryParentheses { int f1 ( ) { int x = 0 ; for ( int i = ( 0 + 1 ) ; ( ( i ) < ( 6 + 6 ) ) ; i += ( 1 + 0 ) ) { x += ( i + 100 ) ; ( x ) += ( i + 100 ) ; x = ( x + i + 100 ) ; ( x ) = ( x + i + 100 ) ; } for ( int i = ( 0 + 1 ) ; ( i ) < ( ( 6 + 6 ) ) ; i += ( 1 + 0 ) ) { System . out . println ( "hi" ) ; } return ( 0 ) ; } private int f2 ( int arg1 , double arg2 ) { int x , a , b , c , d ; String e , f ; x = 0 ; a = 0 ; b = 0 ; c = ( a + b ) ; d = c - 1 ; int i = ( int ) arg2 ; i = ( ( int ) arg2 ) ; x += ( i + 100 + arg1 ) ; a = ( a + b ) * ( c + d ) ; b = ( ( ( ( a + b ) * ( c + d ) ) ) ) ; c = ( ( ( a ) <= b ) ) ? 0 : 1 ; d = ( a ) + ( b ) * ( 600 ) / ( int ) ( 12.5f ) + ( int ) ( arg2 ) ; e = ( "this" ) + ( "that" ) + ( "is" + "other" ) ; f = ( "this is a really, really long string that should be truncated." ) ; return ( x + a + b + d ) ; } private boolean f3 ( ) { int x = f2 ( ( 1 ) , ( 13.5 ) ) ; boolean b = ( true ) ; return ( b ) ; } public static int f4 ( int z , int a ) { int r = ( z * a ) ; r = ( a > z ) ? a : z ; r = ( ( a > z ) ? a : z ) ; r = ( a > z ) ? a : ( z + z ) ; return ( r * r - 1 ) ; } public void f5 ( ) { int x , y ; x = 0 ; y = 0 ; if ( x == y ) { print ( x ) ; } if ( ( x > y ) ) { print ( y ) ; } while ( ( x < 10 ) ) { print ( x ++ ) ; } do { print ( ( y += 100 ) ) ; } while ( y < ( 4000 ) ) ; } private void f6 ( TypeA a ) { TypeB b = ( TypeB ) a ; TypeC c = ( ( TypeC ) a ) ; int r = 12345 ; r <<= ( 3 ) ; TypeD < String > d = ( ( TypeD < String > ) a ) ; } private void print ( int arg ) { System . out . println ( "arg = " + arg ) ; } static class TypeA { } static class TypeB extends TypeA { } static class TypeC extends TypeA { } static class TypeD < T > extends TypeA { } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputParameterAssignment { int field ; void foo1 ( int field ) { int i = field ; this . field = field ; i ++ ; field = 0 ; field += 1 ; this . field ++ ; field -- ; } void foo2 ( ) { field = 0 ; } void foo3 ( String field , int field1 ) { this . field = ( field1 += field . length ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputReturnCount { public boolean equals ( Object obj ) { int i = 1 ; switch ( i ) { case 1 : return true ; case 2 : return true ; case 3 : return true ; case 4 : return true ; case 5 : return true ; case 6 : return true ; } return false ; } void foo ( int i ) { switch ( i ) { case 1 : return ; case 2 : return ; case 3 : return ; case 4 : return ; case 5 : return ; case 6 : return ; } return ; } void foo1 ( int i ) { if ( i == 1 ) { return ; } Object obj = new Object ( ) { void method1 ( int i ) { switch ( i ) { case 1 : return ; case 2 : return ; case 3 : return ; case 4 : return ; case 5 : return ; } return ; } } ; return ; } } class Test { public Test ( ) { } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputIllegalCatchCheck { public void foo ( ) { try { } catch ( RuntimeException e ) { } catch ( Exception e ) { } catch ( Throwable e ) { } } public void bar ( ) { try { } catch ( java . lang . RuntimeException e ) { } catch ( java . lang . Exception e ) { } catch ( java . lang . Throwable e ) { } } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputIllegalThrowsCheckIgnoreOverriddenMethods extends InputIllegalThrowsCheck { @ Override public void methodTwo ( ) throws RuntimeException { } @ java . lang . Override public java . lang . Throwable methodOne ( ) throws RuntimeException { return null ; } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputEqualsAvoidNull { public boolean equals ( Object o ) { return false ; } public void flagForEquals ( ) { Object o = new Object ( ) ; String s = "pizza" ; o . equals ( "hot pizza" ) ; o . equals ( s = "cold pizza" ) ; o . equals ( ( ( s = "cold pizza" ) ) ) ; o . equals ( "cheese" + "ham" + "sauce" ) ; o . equals ( ( "cheese" + "ham" ) + "sauce" ) ; o . equals ( ( ( "cheese" + "ham" ) ) + "sauce" ) ; } public void flagForEqualsIgnoreCase ( ) { String s = "pizza" ; s . equalsIgnoreCase ( "hot pizza" ) ; s . equalsIgnoreCase ( s = "cold pizza" ) ; s . equalsIgnoreCase ( ( ( s = "cold pizza" ) ) ) ; s . equalsIgnoreCase ( "cheese" + "ham" + "sauce" ) ; s . equalsIgnoreCase ( ( "cheese" + "ham" ) + "sauce" ) ; s . equalsIgnoreCase ( ( ( "cheese" + "ham" ) ) + "sauce" ) ; } public void flagForBoth ( ) { Object o = new Object ( ) ; String s = "pizza" ; o . equals ( "hot pizza" ) ; o . equals ( s = "cold pizza" ) ; o . equals ( ( ( s = "cold pizza" ) ) ) ; o . equals ( "cheese" + "ham" + "sauce" ) ; o . equals ( ( "cheese" + "ham" ) + "sauce" ) ; o . equals ( ( ( "cheese" + "ham" ) ) + "sauce" ) ; s . equalsIgnoreCase ( "hot pizza" ) ; s . equalsIgnoreCase ( s = "cold pizza" ) ; s . equalsIgnoreCase ( ( ( s = "cold pizza" ) ) ) ; s . equalsIgnoreCase ( "cheese" + "ham" + "sauce" ) ; s . equalsIgnoreCase ( ( "cheese" + "ham" ) + "sauce" ) ; s . equalsIgnoreCase ( ( ( "cheese" + "ham" ) ) + "sauce" ) ; } public void noFlagForEquals ( ) { Object o = new Object ( ) ; String s = "peperoni" ; o . equals ( s += "mushrooms" ) ; ( s = "thin crust" ) . equals ( "thick crust" ) ; ( s += "garlic" ) . equals ( "basil" ) ; ( "Chicago Style" + "NY Style" ) . equals ( "California Style" + "Any Style" ) ; equals ( "peppers" ) ; "onions" . equals ( o ) ; o . equals ( new Object ( ) ) ; o . equals ( equals ( o ) ) ; equals ( "yummy" ) ; new Object ( ) . equals ( "more cheese" ) ; InputEqualsAvoidNullOutter outter = new InputEqualsAvoidNullOutter ( ) ; outter . new InputEqualsAvoidNullInner ( ) . equals ( "eat pizza and enjoy inner classes" ) ; } public void noFlagForEqualsIgnoreCase ( ) { String s = "peperoni" ; String s1 = "tasty" ; s . equalsIgnoreCase ( s += "mushrooms" ) ; s1 . equalsIgnoreCase ( s += "mushrooms" ) ; ( s = "thin crust" ) . equalsIgnoreCase ( "thick crust" ) ; ( s += "garlic" ) . equalsIgnoreCase ( "basil" ) ; ( "Chicago Style" + "NY Style" ) . equalsIgnoreCase ( "California Style" + "Any Style" ) ; "onions" . equalsIgnoreCase ( s ) ; s . equalsIgnoreCase ( new String ( ) ) ; s . equals ( s1 ) ; new String ( ) . equalsIgnoreCase ( "more cheese" ) ; } public void noFlagForBoth ( ) { Object o = new Object ( ) ; String s = "peperoni" ; String s1 = "tasty" ; o . equals ( s += "mushrooms" ) ; ( s = "thin crust" ) . equals ( "thick crust" ) ; ( s += "garlic" ) . equals ( "basil" ) ; ( "Chicago Style" + "NY Style" ) . equals ( "California Style" + "Any Style" ) ; equals ( "peppers" ) ; "onions" . equals ( o ) ; o . equals ( new Object ( ) ) ; o . equals ( equals ( o ) ) ; equals ( "yummy" ) ; new Object ( ) . equals ( "more cheese" ) ; InputEqualsAvoidNullOutter outter = new InputEqualsAvoidNullOutter ( ) ; outter . new InputEqualsAvoidNullInner ( ) . equals ( "eat pizza and enjoy inner classes" ) ; s . equalsIgnoreCase ( s += "mushrooms" ) ; s1 . equalsIgnoreCase ( s += "mushrooms" ) ; ( s = "thin crust" ) . equalsIgnoreCase ( "thick crust" ) ; ( s += "garlic" ) . equalsIgnoreCase ( "basil" ) ; ( "Chicago Style" + "NY Style" ) . equalsIgnoreCase ( "California Style" + "Any Style" ) ; "onions" . equalsIgnoreCase ( s ) ; s . equalsIgnoreCase ( new String ( ) ) ; s . equals ( s1 ) ; new String ( ) . equalsIgnoreCase ( "more cheese" ) ; } } class InputEqualsAvoidNullOutter { public class InputEqualsAvoidNullInner { public boolean equals ( Object o ) { return true ; } } }
package com . puppycrawl . tools . checkstyle . filters ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import org . junit . Test ; public class IntMatchFilterTest { @ Test public void testDecide ( ) { final IntFilter filter = new IntMatchFilter ( 0 ) ; assertFalse ( "less than" , filter . accept ( Integer . valueOf ( - 1 ) ) ) ; assertTrue ( "equal" , filter . accept ( Integer . valueOf ( 0 ) ) ) ; assertFalse ( "greater than" , filter . accept ( Integer . valueOf ( 1 ) ) ) ; } @ Test public void testEquals ( ) { final IntFilter filter = new IntMatchFilter ( 0 ) ; final IntFilter filter2 = new IntMatchFilter ( 0 ) ; final IntFilter filter3 = new IntMatchFilter ( 1 ) ; assertEquals ( "0" , filter , filter2 ) ; assertFalse ( "0 != 1" , filter . equals ( filter3 ) ) ; assertFalse ( "0 != this" , filter . equals ( this ) ) ; assertFalse ( "0 != null" , filter . equals ( null ) ) ; } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputClone { public InputClone ( ) throws CloneNotSupportedException { super . equals ( new String ( ) ) ; super . clone ( ) ; } public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } public void method ( ) throws CloneNotSupportedException { super . clone ( ) ; } { super . clone ( ) ; } } class NoSuperClone { public Object clone ( ) { return null ; } } class InnerClone { public Object clone ( ) { class Inner { public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } } return null ; } } class CloneWithTypeArguments < T > { public CloneWithTypeArguments < T > clone ( ) throws CloneNotSupportedException { return ( CloneWithTypeArguments < T > ) super . < T > clone ( ) ; } } class CloneWithTypeArgumentsAndNoSuper < T > { public CloneWithTypeArgumentsAndNoSuper < T > clone ( ) { return null ; } } class MyClassWithGenericSuperMethod { void someMethod ( java . util . List < ? super java . util . Map > l ) { } public static Object clone ( Object o ) { return null ; } } class AnotherClass { public < T > T clone ( T t ) { return null ; } }
package com . puppycrawl . tools . checkstyle . coding ; import java . util . ArrayList ; import java . awt . List ; import java . util . * ; import com . puppycrawl . tools . checkstyle . coding . GregorianCalendar ; import com . puppycrawl . tools . checkstyle . coding . GregorianCalendar . SubCalendar ; public class InputIllegalTypeSameFileName { GregorianCalendar cal = AnObject . getInstance ( ) ; java . util . Date date = null ; SubCalendar subCalendar = null ; private static class AnObject extends GregorianCalendar { public static GregorianCalendar getInstance ( ) { return null ; } } private void foo ( ) { List l ; java . io . File file = null ; } java . util . List < Integer > list = new ArrayList < > ( ) ; private ArrayList < String > values ; }
package com . puppycrawl . tools . checkstyle . coding ; public class InputNestedIfDepth { void foo ( ) { if ( true ) { } if ( true ) { if ( true ) { } } if ( true ) { if ( true ) { if ( true ) { } } } } void fooWithElse ( ) { if ( true ) { } else { } if ( true ) { if ( true ) { } else { } } else { if ( false ) { } else { } } if ( true ) { if ( true ) { if ( true ) { } else { } } else { if ( false ) { } else { } } } else { if ( true ) { if ( true ) { } else { } } else { if ( false ) { } else { } } } } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputRequireThis2 { private final int number = 1 ; public int check ( ) { int sum = number ; sum += other ( ) ; return sum ; } private int other ( ) { return 0 ; } }
package com . puppycrawl . tools . checkstyle . annotation ; public class BadAnnonOverride { Runnable r = new Runnable ( ) { public void run ( ) { Throwable t = new Throwable ( ) { public String toString ( ) { return "junk" ; } } ; } } ; void doFoo ( Runnable r ) { doFoo ( new Runnable ( ) { public void run ( ) { Throwable t = new Throwable ( ) { public String toString ( ) { return "junk" ; } } ; } } ) ; } }
@ Deprecated package com . puppycrawl . tools . checkstyle . annotation ;
package com . puppycrawl . tools . checkstyle . annotation ; import java . io . Serializable ; public class BadOverrideFromOther implements IFoo2 { public void doFoo ( ) { } public void doFoo2 ( ) { } } interface IFoo2 { void doFoo ( ) ; } interface IBar2 extends IFoo2 { public void doFoo ( ) ; } class MoreJunk2 extends BadOverrideFromOther { public void doFoo ( ) { } public void doFoo2 ( ) { } class EvenMoreJunk extends MoreJunk2 implements Serializable { public void doFoo ( ) { } public void doFoo2 ( ) { } } } enum Football2 implements IFoo2 , IBar2 { Detroit_Lions ; public void doFoo ( ) { } }
package com . puppycrawl . tools . checkstyle . annotation ; public class GoodAnnonOverride { Runnable r = new Runnable ( ) { public void run ( ) { Throwable t = new Throwable ( ) { @ Override public String toString ( ) { return "junk" ; } } ; } } ; void doFoo ( Runnable r ) { doFoo ( new Runnable ( ) { public void run ( ) { Throwable t = new Throwable ( ) { @ Override public String toString ( ) { return "junk" ; } } ; } } ) ; } void doFoo2 ( Runnable r ) { doFoo ( new Runnable ( ) { public void run ( ) { Throwable t = new Throwable ( ) { @ java . lang . Override public String toString ( ) { return "junk" ; } } ; } } ) ; } }
package com . puppycrawl . tools . checkstyle . annotation ; public class GoodOverrideFromObject { @ Override public boolean equals ( Object obj ) { return false ; } @ Override public int hashCode ( ) { return 1 ; } class Junk { @ Override protected void finalize ( ) throws Throwable { } } } interface HashEq { @ Override public int hashCode ( ) ; } enum Bleh1 { B ; @ Override public String toString ( ) { return "B" ; } } enum Bleh22 { B ; @ java . lang . Override public String toString ( ) { return "B" ; } }
package com . puppycrawl . tools . checkstyle . annotation ; @ Deprecated public class GoodDeprecated { @ Deprecated protected GoodDeprecated ( ) { } @ Deprecated @ Override public String toString ( ) { return "" ; } @ Deprecated enum Rock { @ Bleh2 ( bleh = 2 ) @ Deprecated Metallica } } @ Deprecated interface Foo5 { @ Deprecated interface Bar { } } @ Deprecated @ interface Bleh6 { @ Deprecated int bleh ( ) ; } @ java . lang . Deprecated @ interface FullName { @ java . lang . Deprecated int bleh ( ) ; }
package com . puppycrawl . tools . checkstyle . filters ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import nl . jqno . equalsverifier . EqualsVerifier ; import org . junit . Test ; public class CSVFilterTest { @ Test public void testDecideSingle ( ) { final IntFilter filter = new CSVFilter ( "0" ) ; assertFalse ( "less than" , filter . accept ( Integer . valueOf ( - 1 ) ) ) ; assertTrue ( "equal" , filter . accept ( Integer . valueOf ( 0 ) ) ) ; assertFalse ( "greater than" , filter . accept ( Integer . valueOf ( 1 ) ) ) ; } @ Test public void testDecidePair ( ) { final IntFilter filter = new CSVFilter ( "0, 2" ) ; assertFalse ( "less than" , filter . accept ( Integer . valueOf ( - 1 ) ) ) ; assertTrue ( "equal 0" , filter . accept ( Integer . valueOf ( 0 ) ) ) ; assertFalse ( "greater than" , filter . accept ( Integer . valueOf ( 1 ) ) ) ; assertTrue ( "equal 2" , filter . accept ( Integer . valueOf ( 2 ) ) ) ; } @ Test public void testDecideRange ( ) { final IntFilter filter = new CSVFilter ( "0-2" ) ; assertFalse ( "less than" , filter . accept ( Integer . valueOf ( - 1 ) ) ) ; assertTrue ( "equal 0" , filter . accept ( Integer . valueOf ( 0 ) ) ) ; assertTrue ( "equal 1" , filter . accept ( Integer . valueOf ( 1 ) ) ) ; assertTrue ( "equal 2" , filter . accept ( Integer . valueOf ( 2 ) ) ) ; assertFalse ( "greater than" , filter . accept ( Integer . valueOf ( 3 ) ) ) ; } @ Test public void testDecideEmptyRange ( ) { final IntFilter filter = new CSVFilter ( "2-0" ) ; assertFalse ( "less than" , filter . accept ( Integer . valueOf ( - 1 ) ) ) ; assertFalse ( "equal 0" , filter . accept ( Integer . valueOf ( 0 ) ) ) ; assertFalse ( "equal 1" , filter . accept ( Integer . valueOf ( 1 ) ) ) ; assertFalse ( "equal 2" , filter . accept ( Integer . valueOf ( 2 ) ) ) ; assertFalse ( "greater than" , filter . accept ( Integer . valueOf ( 3 ) ) ) ; } @ Test public void testDecideRangePlusValue ( ) { final IntFilter filter = new CSVFilter ( "0-2, 10" ) ; assertFalse ( "less than" , filter . accept ( Integer . valueOf ( - 1 ) ) ) ; assertTrue ( "equal 0" , filter . accept ( Integer . valueOf ( 0 ) ) ) ; assertTrue ( "equal 1" , filter . accept ( Integer . valueOf ( 1 ) ) ) ; assertTrue ( "equal 2" , filter . accept ( Integer . valueOf ( 2 ) ) ) ; assertFalse ( "greater than" , filter . accept ( Integer . valueOf ( 3 ) ) ) ; assertTrue ( "equal 10" , filter . accept ( Integer . valueOf ( 10 ) ) ) ; } @ Test public void testEqualsAndHashCode ( ) { EqualsVerifier . forClass ( CSVFilter . class ) . usingGetClass ( ) . verify ( ) ; } }
package com . puppycrawl . tools . checkstyle . annotation ; import java . io . Serializable ; public class GoodOverrideFromOther implements IFoo { public void doFoo ( ) { } public void doFoo2 ( ) { } } interface IFoo { void doFoo ( ) ; } interface IBar extends IFoo { public void doFoo ( ) ; } class MoreJunk extends GoodOverrideFromOther { @ Override public void doFoo ( ) { } @ Override public void doFoo2 ( ) { } class EvenMoreJunk extends MoreJunk implements Serializable { @ Override public void doFoo ( ) { } @ Override public void doFoo2 ( ) { } } class EvenMoreMoreJunk extends MoreJunk implements Serializable { @ java . lang . Override public void doFoo ( ) { } @ java . lang . Override public void doFoo2 ( ) { } } } enum Football implements IFoo , IBar { Detroit_Lions ; public void doFoo ( ) { } }
package com . puppycrawl . tools . checkstyle . annotation ; import java . util . List ; import java . util . ArrayList ; public class SuppressWarningsConstants { public static final String UNCHECKED = "unchecked" ; public static void test ( ) { @ SuppressWarnings ( UNCHECKED ) final List < String > dummyOne = ( List < String > ) new ArrayList ( ) ; @ SuppressWarnings ( SuppressWarningsConstants . UNCHECKED ) final List < String > dummyTwo = ( List < String > ) new ArrayList ( ) ; } }
package com . puppycrawl . tools . checkstyle . annotation ; import java . lang . annotation . Documented ; @ SuppressWarnings ( value = { "unchecked" , "unused" } ) public class SuppressWarningsExpanded { @ SuppressWarnings ( value = { " " } ) class Empty { @ SuppressWarnings ( value = { "unchecked" , "" } ) public Empty ( ) { } } @ SuppressWarnings ( value = { "unused" } ) enum Duh { @ SuppressWarnings ( value = { "unforgiven" , " un" } ) D ; public static void foo ( ) { @ SuppressWarnings ( value = { "unused" } ) Object o = new SuppressWarningsExpanded ( ) { @ Override @ SuppressWarnings ( value = { "unchecked" } ) public String toString ( ) { return "" ; } } ; } } @ SuppressWarnings ( value = { "abcun" } ) @ Documented @ interface Sweet { int cool ( ) ; } @ Documented @ SuppressWarnings ( value = { } ) @ interface MoreSweetness { @ SuppressWarnings ( value = { "unused" , "bleh" } ) int cool ( ) ; } public class Junk { @ SuppressWarnings ( value = { } ) int a = 1 ; @ SuppressWarnings ( value = { "unchecked" } ) @ Deprecated int b = 1 ; void doFoo ( String s , @ SuppressWarnings ( value = { "unchecked" } ) String y ) { } } @ SuppressWarnings ( value = { ( false ) ? "unchecked" : "" , ( false ) ? "unchecked" : "" } ) class Cond { @ SuppressWarnings ( value = { ( false ) ? "" : "unchecked" } ) public Cond ( ) { } @ SuppressWarnings ( value = { ( false ) ? ( true ) ? " " : "unused" : "unchecked" , ( false ) ? ( true ) ? " " : "unused" : "unchecked" } ) public void aCond1 ( ) { } @ SuppressWarnings ( value = { ( false ) ? "unchecked" : ( true ) ? " " : "unused" } ) public void aCond2 ( ) { } @ java . lang . SuppressWarnings ( value = { ( false ) ? "unchecked" : ( "" == "" ) ? ( false ) ? ( true ) ? "" : "foo" : " " : "unused" , ( false ) ? "unchecked" : ( "" == "" ) ? ( false ) ? ( true ) ? "" : "foo" : " " : "unused" } ) public void seriously ( ) { } } }
package com . puppycrawl . tools . checkstyle . annotation ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; public class AnnotationsUseStyleParams { @ Target ( { } ) public @ interface myAnn { } }
package com . puppycrawl . tools . checkstyle . annotation ; @ MyAnnotation6 @ MyAnnotation5 class InputCorrectAnnotationLocation { @ MyAnnotation6 @ MyAnnotation5 public int a ; @ MyAnnotation5 public int b ; @ MyAnnotation6 @ MyAnnotation5 public int c ; @ MyAnnotation5 public int d ; @ MyAnnotation6 @ MyAnnotation5 public InputCorrectAnnotationLocation ( ) { } @ MyAnnotation5 @ MyAnnotation6 void foo1 ( ) { } @ MyAnnotation5 @ MyAnnotation6 void foo2 ( ) { } @ MyAnnotation5 @ MyAnnotation6 @ MyAnnotation3 @ MyAnnotation4 class InnerClass { @ MyAnnotation6 @ MyAnnotation5 public int a ; @ MyAnnotation5 public int b ; @ MyAnnotation6 @ MyAnnotation5 public int c ; @ MyAnnotation5 public int d ; @ MyAnnotation6 public InnerClass ( ) { } @ MyAnnotation5 @ MyAnnotation6 void foo1 ( int a ) { } @ MyAnnotation5 @ MyAnnotation6 void foo2 ( ) { } } @ MyAnnotation5 @ MyAnnotation6 InnerClass anon = new InnerClass ( ) { @ MyAnnotation6 @ MyAnnotation5 public int a ; @ MyAnnotation5 public int b ; @ MyAnnotation6 @ MyAnnotation5 public int c ; @ MyAnnotation5 public int d ; @ MyAnnotation5 @ MyAnnotation6 void foo1 ( ) { } @ MyAnnotation5 @ MyAnnotation6 void foo2 ( ) { } } ; } @ MyAnnotation5 @ MyAnnotation6 class _Foo { } @ interface MyAnnotation5 { } @ interface MyAnnotation6 { }
package com . puppycrawl . tools . checkstyle . annotation ; @ SuppressWarnings ( { } ) public class AnnotationUseNoTrailingComma { @ SuppressWarnings ( { "common" } ) public void foo ( ) { @ SuppressWarnings ( { "common" , "foo" } ) Object o = new Object ( ) { @ SuppressWarnings ( value = { "common" } ) public String toString ( ) { @ SuppressWarnings ( value = { "leo" , "herbie" } ) final String pooches = "leo.herbie" ; return pooches ; } } ; } @ Test2 ( value = { ( false ) ? "" : "foo" } , more = { ( true ) ? "" : "bar" } ) @ Pooches2 ( tokens = { } , other = { } ) enum P { @ Pooches2 ( tokens = { Pooches2 . class } , other = { 1 } ) L , @ Test2 ( value = { } , more = { ( false ) ? "" : "unchecked" } ) Y ; } } @ interface Test2 { String [ ] value ( ) ; String [ ] more ( ) default { } ; } @ interface Pooches2 { Class < ? > [ ] tokens ( ) ; int [ ] other ( ) ; }
package com . puppycrawl . tools . checkstyle . annotation ; public class AnnotationUseWithTrailingComma { @ SuppressWarnings ( { "common" , } ) public void foo ( ) { @ SuppressWarnings ( { "common" , "foo" , } ) Object o = new Object ( ) { @ SuppressWarnings ( value = { "common" , } ) public String toString ( ) { @ SuppressWarnings ( value = { "leo" , "herbie" , } ) final String pooches = "leo.herbie" ; return pooches ; } } ; } @ Test ( value = { ( false ) ? "" : "foo" , } , more = { ( true ) ? "" : "bar" , } ) enum P { @ Pooches ( tokens = { Pooches . class , } , other = { 1 , } ) L , Y ; } } @ interface Test { String [ ] value ( ) ; String [ ] more ( ) default { } ; } @ interface Pooches { Class < ? > [ ] tokens ( ) ; int [ ] other ( ) ; }
package com . puppycrawl . tools . checkstyle . annotation ; import java . lang . annotation . Documented ; @ SuppressWarnings ( "unchecked" ) public class SuppressWarningsSingle { @ SuppressWarnings ( " " ) class Empty { @ SuppressWarnings ( "" ) public Empty ( ) { } } @ SuppressWarnings ( "unused" ) enum Duh { @ SuppressWarnings ( "unforgiven" ) D ; public static void foo ( ) { @ SuppressWarnings ( "unused" ) Object o = new SuppressWarningsSingle ( ) { @ Override @ SuppressWarnings ( "unchecked" ) public String toString ( ) { return "" ; } } ; } } @ SuppressWarnings ( "abcun" ) @ Documented @ interface Sweet { int cool ( ) ; } @ Documented @ SuppressWarnings ( "abcun" ) @ interface MoreSweetness { @ SuppressWarnings ( "unused" ) int cool ( ) ; } public class Junk { @ SuppressWarnings ( "" ) int a = 1 ; @ SuppressWarnings ( "unchecked" ) @ Deprecated int b = 1 ; void doFoo ( String s , @ SuppressWarnings ( "unchecked" ) String y ) { } } @ SuppressWarnings ( ( false ) ? "unchecked" : "" ) class Cond { @ SuppressWarnings ( ( false ) ? "" : "unchecked" ) public Cond ( ) { } @ SuppressWarnings ( ( false ) ? ( true ) ? " " : "unused" : "unchecked" ) public void aCond1 ( ) { } @ SuppressWarnings ( ( false ) ? "unchecked" : ( true ) ? " " : "unused" ) public void aCond2 ( ) { } @ java . lang . SuppressWarnings ( ( false ) ? "unchecked" : ( "" == "" ) ? ( false ) ? ( true ) ? "" : "foo" : " " : "unused" ) public void seriously ( ) { } } }
package com . puppycrawl . tools . checkstyle . annotation ; @ MyAnnotation2 @ MyAnnotation1 ( value = "" ) class InputIncorrectAnnotationLocation { @ MyAnnotation2 @ MyAnnotation1 ( value = "" ) public int a ; @ MyAnnotation1 ( value = "" ) public int b ; @ MyAnnotation2 @ MyAnnotation1 ( value = "" ) public int c ; @ MyAnnotation1 ( value = "" ) public int d ; @ MyAnnotation2 @ MyAnnotation1 ( value = "" ) public InputIncorrectAnnotationLocation ( ) { } @ MyAnnotation1 ( "foo" ) @ MyAnnotation2 void foo1 ( ) { } @ MyAnnotation1 ( value = "" ) @ MyAnnotation2 void foo2 ( ) { } @ MyAnnotation1 ( value = "" ) @ MyAnnotation2 @ MyAnnotation3 @ MyAnnotation4 class InnerClass { @ MyAnnotation2 @ MyAnnotation1 ( value = "" ) public int a ; @ MyAnnotation1 ( value = "" ) public int b ; @ MyAnnotation2 @ MyAnnotation1 ( value = "" ) public int c ; @ MyAnnotation1 ( value = "" ) public int d ; @ MyAnnotation2 @ MyAnnotation1 ( value = "" ) public InnerClass ( ) { } @ MyAnnotation1 ( value = "" ) @ MyAnnotation2 void foo1 ( ) { } @ MyAnnotation1 ( value = "" ) @ MyAnnotation2 void foo2 ( ) { } } @ MyAnnotation1 ( value = "" ) @ MyAnnotation2 InnerClass anon = new InnerClass ( ) { @ MyAnnotation2 @ MyAnnotation1 ( value = "" ) public int a ; @ MyAnnotation1 ( value = "" ) public int b ; @ MyAnnotation2 @ MyAnnotation1 ( value = "" ) public int c ; @ MyAnnotation1 ( value = "" ) public int d ; @ MyAnnotation1 ( value = "" ) @ MyAnnotation2 void foo1 ( ) { } @ MyAnnotation1 ( value = "" ) @ MyAnnotation2 void foo2 ( ) { } @ MyAnnotation1 ( value = "" ) void foo42 ( ) { } } ; } @ MyAnnotation1 ( value = "" ) @ MyAnnotation2 class Foo { } @ interface MyAnnotation1 { String value ( ) ; } @ interface MyAnnotation2 { } @ interface MyAnnotation3 { } @ interface MyAnnotation4 { }
package com . puppycrawl . tools . checkstyle . annotation ; import java . lang . annotation . Documented ; @ SuppressWarnings ( { "unchecked" , "unused" } ) public class SuppressWarningsCompact { @ SuppressWarnings ( { " " } ) class Empty { @ SuppressWarnings ( { "unchecked" , "" } ) public Empty ( ) { } } @ SuppressWarnings ( { "unused" } ) enum Duh { @ SuppressWarnings ( { "unforgiven" , " un" } ) D ; public static void foo ( ) { @ SuppressWarnings ( { "unused" } ) Object o = new SuppressWarningsCompact ( ) { @ Override @ SuppressWarnings ( { "unchecked" } ) public String toString ( ) { return "" ; } } ; } } @ SuppressWarnings ( { "abcun" } ) @ Documented @ interface Sweet { int cool ( ) ; } @ Documented @ SuppressWarnings ( { } ) @ interface MoreSweetness { @ SuppressWarnings ( { "unused" , "bleh" } ) int cool ( ) ; } public class Junk { @ SuppressWarnings ( { } ) int a = 1 ; @ SuppressWarnings ( { "unchecked" } ) @ Deprecated int b = 1 ; void doFoo ( String s , @ SuppressWarnings ( { "unchecked" } ) String y ) { } } @ SuppressWarnings ( { ( false ) ? "unchecked" : "" , ( false ) ? "unchecked" : "" } ) class Cond { @ SuppressWarnings ( { ( false ) ? "" : "unchecked" } ) public Cond ( ) { } @ SuppressWarnings ( { ( false ) ? ( true ) ? " " : "unused" : "unchecked" , ( false ) ? ( true ) ? " " : "unused" : "unchecked" } ) public void aCond1 ( ) { } @ SuppressWarnings ( { ( false ) ? "unchecked" : ( true ) ? " " : "unused" } ) public void aCond2 ( ) { } @ java . lang . SuppressWarnings ( { ( false ) ? "unchecked" : ( "" == "" ) ? ( false ) ? ( true ) ? "" : "foo" : " " : "unused" , ( false ) ? "unchecked" : ( "" == "" ) ? ( false ) ? ( true ) ? "" : "foo" : " " : "unused" } ) public void seriously ( ) { } } }
package com . puppycrawl . tools . checkstyle . filters ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . Checker ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . TreeWalker ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . FileContentsHolder ; import com . puppycrawl . tools . checkstyle . checks . coding . IllegalCatchCheck ; import com . puppycrawl . tools . checkstyle . checks . naming . ConstantNameCheck ; import com . puppycrawl . tools . checkstyle . checks . naming . MemberNameCheck ; import java . io . UnsupportedEncodingException ; import java . util . Arrays ; import java . util . Collection ; import java . util . Locale ; import nl . jqno . equalsverifier . EqualsVerifier ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; public class SuppressionCommentFilterTest extends BaseCheckTestSupport { private static String [ ] sAllMessages = { "13:17: Name 'I' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "16:17: Name 'J' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "19:17: Name 'K' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "22:17: Name 'L' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "23:30: Name 'm' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , "27:17: Name 'M2' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "28:30: Name 'n' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , "32:17: Name 'P' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "35:17: Name 'Q' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "38:17: Name 'R' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "39:30: Name 's' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , "43:17: Name 'T' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "64:23: Catching 'Exception' is not allowed." , "71:11: Catching 'Exception' is not allowed." , "77:11: Catching 'RuntimeException' is not allowed." , "78:11: Catching 'Exception' is not allowed." , } ; @ Test public void testNone ( ) throws Exception { final DefaultConfiguration filterConfig = null ; final String [ ] suppressed = { } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressionCommentFilter . class ) ; final String [ ] suppressed = { "16:17: Name 'J' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "43:17: Name 'T' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "64:23: Catching 'Exception' is not allowed." , "71:11: Catching 'Exception' is not allowed." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testCheckC ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressionCommentFilter . class ) ; filterConfig . addAttribute ( "checkC" , "false" ) ; final String [ ] suppressed = { "43:17: Name 'T' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "64:23: Catching 'Exception' is not allowed." , "71:11: Catching 'Exception' is not allowed." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testCheckCPP ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressionCommentFilter . class ) ; filterConfig . addAttribute ( "checkCPP" , "false" ) ; final String [ ] suppressed = { "16:17: Name 'J' must match pattern '^[a-z][a-zA-Z0-9]*$'." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testOffFormat ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressionCommentFilter . class ) ; filterConfig . addAttribute ( "offCommentFormat" , "CS_OFF" ) ; filterConfig . addAttribute ( "onCommentFormat" , "CS_ON" ) ; final String [ ] suppressed = { "32:17: Name 'P' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "38:17: Name 'R' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "39:30: Name 's' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , "42:17: Name 'T' must match pattern '^[a-z][a-zA-Z0-9]*$'." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testOffFormatCheck ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressionCommentFilter . class ) ; filterConfig . addAttribute ( "offCommentFormat" , "CS_OFF" ) ; filterConfig . addAttribute ( "onCommentFormat" , "CS_ON" ) ; filterConfig . addAttribute ( "checkFormat" , "ConstantNameCheck" ) ; final String [ ] suppressed = { "39:30: Name 's' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testArgumentSuppression ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressionCommentFilter . class ) ; filterConfig . addAttribute ( "offCommentFormat" , "IllegalCatchCheck OFF\\: (\\w+)" ) ; filterConfig . addAttribute ( "onCommentFormat" , "IllegalCatchCheck ON\\: (\\w+)" ) ; filterConfig . addAttribute ( "checkFormat" , "IllegalCatchCheck" ) ; filterConfig . addAttribute ( "messageFormat" , "^Catching '$1' is not allowed.*$" ) ; final String [ ] suppressed = { "78:11: Catching 'Exception' is not allowed." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testExpansion ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressionCommentFilter . class ) ; filterConfig . addAttribute ( "offCommentFormat" , "CSOFF\\: ([\\w\\|]+)" ) ; filterConfig . addAttribute ( "onCommentFormat" , "CSON\\: ([\\w\\|]+)" ) ; filterConfig . addAttribute ( "checkFormat" , "$1" ) ; final String [ ] suppressed = { "22:17: Name 'L' must match pattern '^[a-z][a-zA-Z0-9]*$'." , "23:30: Name 'm' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , "28:30: Name 'n' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'." , } ; verifySuppressed ( filterConfig , suppressed ) ; } @ Test public void testMessage ( ) throws Exception { final DefaultConfiguration filterConfig = createFilterConfig ( SuppressionCommentFilter . class ) ; filterConfig . addAttribute ( "onCommentFormat" , "UNUSED ON\\: (\\w+)" ) ; filterConfig . addAttribute ( "offCommentFormat" , "UNUSED OFF\\: (\\w+)" ) ; filterConfig . addAttribute ( "checkFormat" , "Unused" ) ; filterConfig . addAttribute ( "messageFormat" , "^Unused \\w+ '$1'.$" ) ; final String [ ] suppressed = { "47:34: Unused parameter 'aInt'." , } ; verifySuppressed ( filterConfig , suppressed ) ; } public static DefaultConfiguration createFilterConfig ( Class < ? > aClass ) { return new DefaultConfiguration ( aClass . getName ( ) ) ; } protected void verifySuppressed ( Configuration aFilterConfig , String [ ] aSuppressed ) throws Exception { verify ( createChecker ( aFilterConfig ) , getPath ( "filters/InputSuppressionCommentFilter.java" ) , removeSuppressed ( sAllMessages , aSuppressed ) ) ; } @ Override protected Checker createChecker ( Configuration aFilterConfig ) throws CheckstyleException , UnsupportedEncodingException { final DefaultConfiguration checkerConfig = new DefaultConfiguration ( "configuration" ) ; final DefaultConfiguration checksConfig = createCheckConfig ( TreeWalker . class ) ; checksConfig . addChild ( createCheckConfig ( FileContentsHolder . class ) ) ; checksConfig . addChild ( createCheckConfig ( MemberNameCheck . class ) ) ; checksConfig . addChild ( createCheckConfig ( ConstantNameCheck . class ) ) ; checksConfig . addChild ( createCheckConfig ( IllegalCatchCheck . class ) ) ; checkerConfig . addChild ( checksConfig ) ; if ( aFilterConfig != null ) { checkerConfig . addChild ( aFilterConfig ) ; } final Checker checker = new Checker ( ) ; final Locale locale = Locale . ROOT ; checker . setLocaleCountry ( locale . getCountry ( ) ) ; checker . setLocaleLanguage ( locale . getLanguage ( ) ) ; checker . setModuleClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; checker . configure ( checkerConfig ) ; checker . addListener ( new BriefLogger ( stream ) ) ; return checker ; } private String [ ] removeSuppressed ( String [ ] from , String [ ] remove ) { final Collection < String > coll = Lists . newArrayList ( Arrays . asList ( from ) ) ; coll . removeAll ( Arrays . asList ( remove ) ) ; return coll . toArray ( new String [ coll . size ( ) ] ) ; } @ Test public void testEqualsAndHashCodeOfTagClass ( ) { EqualsVerifier . forClass ( SuppressionCommentFilter . Tag . class ) . usingGetClass ( ) . verify ( ) ; } @ Test public void testToStringOfTagClass ( ) { SuppressionCommentFilter . Tag tag = new SuppressionCommentFilter . Tag ( 0 , 1 , "text" , false , new SuppressionCommentFilter ( ) ) ; assertEquals ( "Tag[line=0; col=1; on=false; text='text']" , tag . toString ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . annotation ; @ Deprecated public class SpecialCaseDeprecated { public int i ; public void foo ( ) { } @ Deprecated public void foo2 ( ) { } @ Deprecated public void foo3 ( ) { } @ Deprecated public void foo4 ( ) { } @ Deprecated public void foo5 ( ) { } void local ( @ Deprecated String s ) { } void local2 ( String s ) { } void local3 ( @ Deprecated String s ) { } void dontUse ( ) { } @ Deprecated void dontUse2 ( ) { } }
package com . puppycrawl . tools . checkstyle . annotation ; import java . util . ArrayList ; import java . util . List ; public class SuppressWarningsValuePair { public static final String UNCHECKED = "unchecked" ; public static void test ( ) { @ SuppressWarnings ( value = UNCHECKED ) final List < String > dummyOne = ( List < String > ) new ArrayList ( ) ; } }
package com . puppycrawl . tools . checkstyle . annotation ; public class NotOverride { private void bleh ( ) { } public static void eh ( ) { } public String junk = "" ; void dodoo ( ) { } }
package com . puppycrawl . tools . checkstyle . annotation ; import java . lang . annotation . Inherited ; @ Deprecated public class BadDeprecatedJavadoc { @ Deprecated protected BadDeprecatedJavadoc ( ) { } @ Deprecated @ Override public String toString ( ) { return "" ; } @ Deprecated enum Rock { @ Bleh2 ( bleh = 1 ) @ Deprecated Metallica } } @ Deprecated interface Foo2 { @ Deprecated interface Bar { } } @ Deprecated @ interface Bleh2 { @ Deprecated int bleh ( ) ; }
package com . puppycrawl . tools . checkstyle . annotation ; @ Deprecated @ SomeArrays ( pooches = { DOGS . LEO } ) @ SuppressWarnings ( { "" } ) public class DifferentUseStyles { } @ SomeArrays ( pooches = { DOGS . LEO } , um = { } , duh = { "bleh" } ) @ SuppressWarnings ( "" ) @ Deprecated ( ) class Dep { } @ Deprecated @ SomeArrays ( pooches = { DOGS . LEO } ) @ SuppressWarnings ( { "" } ) enum SON { @ Deprecated @ SomeArrays ( pooches = { DOGS . LEO } , um = { "" } , duh = { "bleh" } ) @ APooch ( dog = DOGS . HERBIE ) @ Another ( "" ) ETHAN } @ Deprecated ( ) enum DOGS { @ Deprecated ( ) LEO , HERBIE } @ interface SomeArrays { @ Another ( "" ) String [ ] um ( ) default { } ; @ Another ( { "" } ) String [ ] duh ( ) default { } ; @ Another ( value = { "" } ) DOGS [ ] pooches ( ) ; } @ Another ( value = { "" } ) enum E { } @ interface APooch { DOGS dog ( ) ; } @ interface Another { String [ ] value ( ) ; @ Another ( { "foo" , "bar" } ) String value1 ( ) default "" ; } @ SomeArrays ( pooches = { } ) @ Another ( { } ) class Closing { }
package com . puppycrawl . tools . checkstyle . annotation ; public class BadOverrideFromObject { public boolean equals ( Object obj ) { return false ; } public int hashCode ( ) { return 1 ; } class Junk { protected void finalize ( ) throws Throwable { } } } interface HashEq2 { public int hashCode ( ) ; } enum Bleh3 { B ; public String toString ( ) { return "B" ; } }
package com . puppycrawl . tools . checkstyle . annotation ; public class BadDeprecatedAnnotation { protected BadDeprecatedAnnotation ( ) { } public String toString ( ) { return "" ; } enum Rock { Metallica } } interface Foo1 { interface Bar { } } @ interface Bleh { int bleh ( ) ; }
package com . puppycrawl . tools . checkstyle . design ; import java . io . Serializable ; public class HideUtilityClassContructor3041574_3 implements Serializable { private static final long serialVersionUID = 1L ; public HideUtilityClassContructor3041574_3 ( int i ) { } public String getValue ( ) { return "" ; } @ SuppressWarnings ( "unused" ) public static class Event { private String ind ; private String ind1 ; public Event ( String value ) { } public static String getEmptyString ( ) { return "" ; } } @ SuppressWarnings ( "unused" ) public static class Event1 { private String ind ; private String ind1 ; private Event1 ( ) { } public static String getEmptyString ( ) { return "" ; } } }
package com . puppycrawl . tools . checkstyle . design ; interface InputOneTopLevelInterface2inner1 { int foo ( ) ; } public interface InputOneTopLevelInterface2 { int foo ( ) ; } interface InputOneTopLevelInterface2inner2 { int foo ( ) ; }
package com . puppycrawl . tools . checkstyle . design ;
package com . puppycrawl . tools . checkstyle . filters ; import nl . jqno . equalsverifier . EqualsVerifier ; import nl . jqno . equalsverifier . Warning ; import org . junit . Test ; public class SuppressionFilterTest { @ Test public void testEqualsAndHashCode ( ) { EqualsVerifier . forClass ( SuppressionFilter . class ) . usingGetClass ( ) . suppress ( Warning . NONFINAL_FIELDS ) . verify ( ) ; } }
package com . puppycrawl . tools . checkstyle . design ; import java . io . Serializable ; public class HideUtilityClassContructor3041574_2 implements Serializable { private static final long serialVersionUID = 1L ; }
package com . puppycrawl . tools . checkstyle . design ; public class UtilityClassConstructor { private static int value = 0 ; public static void foo ( int val ) { value = val ; } public static class Inner { public int foo ; } public static class Inner2 { public static int foo ; } }
package com . puppycrawl . tools . checkstyle . design ; class InputOneTopLevelClassNoPublic { } class InputOneTopLevelClassNoPublic2 { }
package com . puppycrawl . tools . checkstyle . design ; import java . awt . Dimension ; import javax . swing . JPanel ; public class InputNonUtilityClass extends JPanel { public InputNonUtilityClass ( ) { this . setPreferredSize ( new Dimension ( 100 , 100 ) ) ; } public static void utilMethod ( ) { System . out . println ( "I'm a utility method" ) ; } }
package com . puppycrawl . tools . checkstyle . design ; public class InputInnerClassCheck { public int test1 = 100 ; public void methodTestInner1 ( ) { double test2 = 200 ; class InnerInMethod1 { void methodTest1 ( ) { System . out . println ( "test1" ) ; } } int test3 = 300 ; } public void methodTestInner2 ( ) { int test5 = 500 ; class InnerInMethod2 { int test6 = 500 ; } int test6 = 600 ; int test8 = 800 ; } class Inner1 { int test4 = 400 ; public void methodTestInner3 ( ) { int test9 = 500 ; class InnerInMethod3 { int test10 = 500 ; } int test11 = 600 ; int test12 = 800 ; } } void methodTest2 ( ) { System . out . println ( "test2" ) ; } } class Temp2 { class Inner1 { int test4 = 400 ; public void methodTestInner3 ( ) { int test9 = 500 ; class InnerInMethod3 { int test10 = 500 ; } int test11 = 600 ; int test12 = 800 ; } } void methodTest2 ( ) { System . out . println ( "test2" ) ; } private int i = 0 ; } class Temp3 { class InnerCheck { private int I = 0 ; } public int [ ] getDefaultTokens ( ) { return new int [ ] { 1 , } ; } } class Temp4 { class InnerCheck { class InnerInnerCheck { private int a = 0 ; } class InnerInnerCheck2 { private int a = 0 ; } private int I = 0 ; } }
package com . puppycrawl . tools . checkstyle . design ; import java . io . Serializable ; public abstract class HideUtilityClassContructor3041574_1 implements Serializable { private static final long serialVersionUID = 1L ; }
package com . puppycrawl . tools . checkstyle . design ; import java . awt . AWTException ; import java . io . EOFException ; import java . io . FileNotFoundException ; import java . sql . SQLException ; public class InputThrowsCount { void method1 ( ) throws Exception { } void methdo2 ( ) throws java . awt . AWTException { } void method3 ( ) throws Exception , AWTException , SQLException , FileNotFoundException , EOFException { } void method4 ( ) throws Exception , java . awt . AWTException , java . sql . SQLException , java . io . FileNotFoundException , java . io . EOFException { } void method5 ( ) throws Exception , AWTException , Throwable , SQLException , FileNotFoundException , EOFException { } void method6 ( ) { } private void method7 ( ) throws Exception , AWTException , SQLException , FileNotFoundException , EOFException { } } class SubClass extends InputThrowsCount { @ Override void method1 ( ) { } @ Deprecated @ Override void method4 ( ) throws Exception , java . awt . AWTException { } @ Override void method5 ( ) throws Exception , AWTException , Throwable { } @ SuppressWarnings ( "deprecation" ) final void method2 ( Object ... objects ) throws Exception , AWTException , SQLException , FileNotFoundException , EOFException { } @ java . lang . Override void method3 ( ) throws Exception { } }
package com . puppycrawl . tools . checkstyle . design ; public class InputOneTopLevelClass { static final int FOO2 = 3 ; public static final int FOO = 3 ; private static final int FOO3 = 3 ; public static final int FOO4 = 3 ; private static final String ERROR = "error" ; protected static final String ERROR1 = "error" ; public static final String WARNING = "warning" ; private int mMaxInitVars = 3 ; public static final int MAX_ITER_VARS = 3 ; private class InnerClass { private static final int INNER_FOO = 2 ; public static final int INNER_FOO2 = 2 ; public InnerClass ( ) { int foo = INNER_FOO ; foo += INNER_FOO2 ; foo += INNER_FOO3 ; } public static final int INNER_FOO3 = 2 ; } public int getFoo1 ( ) { return mFoo ; } public InputOneTopLevelClass ( ) { String foo = ERROR ; foo += ERROR1 ; foo += WARNING ; int fooInt = mMaxInitVars ; fooInt += MAX_ITER_VARS ; fooInt += mFoo ; } public static int getFoo2 ( ) { return 13 ; } public int getFoo ( ) { return mFoo ; } private static int getFoo21 ( ) { return 14 ; } private int mFoo = 0 ; }
package com . puppycrawl . tools . checkstyle . design ; public enum InputOneTopLevelEnum { VALUE1 , VALUE2 ; }
package com . puppycrawl . tools . checkstyle . design ; enum InputOneTopLevelEnum2inner1 { VALUE1 , VALUE2 ; } public enum InputOneTopLevelEnum2 { VALUE1 , VALUE2 ; } enum InputOneTopLevelEnum2inner2 { VALUE1 , VALUE2 ; }
package com . puppycrawl . tools . checkstyle . filters ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import java . io . IOException ; import java . net . HttpURLConnection ; import java . net . URL ; import java . util . regex . PatternSyntaxException ; import org . junit . Assume ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . FilterSet ; public class SuppressionsLoaderTest { @ Test public void testNoSuppressions ( ) throws CheckstyleException { final FilterSet fc = SuppressionsLoader . loadSuppressions ( "src/test/resources/com/puppycrawl/tools/checkstyle/suppressions_none.xml" ) ; final FilterSet fc2 = new FilterSet ( ) ; assertEquals ( fc , fc2 ) ; } @ Test public void testLoadFromURL ( ) throws CheckstyleException , InterruptedException { boolean online = isInternetReachable ( ) ; Assume . assumeTrue ( online ) ; FilterSet fc = null ; int attemptCount = 0 ; final int attemptLimit = 5 ; while ( attemptCount <= attemptLimit ) { try { fc = SuppressionsLoader . loadSuppressions ( "http://checkstyle.sourceforge.net/files/suppressions_none.xml" ) ; break ; } catch ( CheckstyleException ex ) { if ( attemptCount < attemptLimit && ex . getMessage ( ) . contains ( "unable to read" ) ) { attemptCount ++ ; Thread . sleep ( 1000 ) ; } else { throw ex ; } } } final FilterSet fc2 = new FilterSet ( ) ; assertEquals ( fc , fc2 ) ; } @ Test ( expected = CheckstyleException . class ) public void testLoadFromMalformedURL ( ) throws CheckstyleException { SuppressionsLoader . loadSuppressions ( "http" ) ; } @ Test ( expected = CheckstyleException . class ) public void testLoadFromNonExistingURL ( ) throws CheckstyleException { SuppressionsLoader . loadSuppressions ( "http://^%$^* %&% %^&" ) ; } @ Test public void testMultipleSuppression ( ) throws CheckstyleException , PatternSyntaxException { final FilterSet fc = SuppressionsLoader . loadSuppressions ( "src/test/resources/com/puppycrawl/tools/checkstyle/suppressions_multiple.xml" ) ; final FilterSet fc2 = new FilterSet ( ) ; SuppressElement se0 = new SuppressElement ( "file0" ) ; se0 . setChecks ( "check0" ) ; fc2 . addFilter ( se0 ) ; SuppressElement se1 = new SuppressElement ( "file1" ) ; se1 . setChecks ( "check1" ) ; se1 . setLines ( "1,2-3" ) ; fc2 . addFilter ( se1 ) ; SuppressElement se2 = new SuppressElement ( "file2" ) ; se2 . setChecks ( "check2" ) ; se2 . setColumns ( "1,2-3" ) ; fc2 . addFilter ( se2 ) ; SuppressElement se3 = new SuppressElement ( "file3" ) ; se3 . setChecks ( "check3" ) ; se3 . setLines ( "1,2-3" ) ; se3 . setColumns ( "1,2-3" ) ; fc2 . addFilter ( se3 ) ; assertEquals ( fc , fc2 ) ; } @ Test public void testNoFile ( ) { final String fn = "src/test/resources/com/puppycrawl/tools/checkstyle/suppressions_no_file.xml" ; try { SuppressionsLoader . loadSuppressions ( fn ) ; } catch ( CheckstyleException ex ) { assertEquals ( "unable to parse " + fn + " - Attribute \"files\" is required and must be specified for element type \"suppress\"." , ex . getMessage ( ) ) ; } } @ Test public void testNoCheck ( ) { final String fn = "src/test/resources/com/puppycrawl/tools/checkstyle/suppressions_no_check.xml" ; try { SuppressionsLoader . loadSuppressions ( fn ) ; } catch ( CheckstyleException ex ) { assertEquals ( "unable to parse " + fn + " - Attribute \"checks\" is required and must be specified for element type \"suppress\"." , ex . getMessage ( ) ) ; } } @ Test public void testBadInt ( ) { final String fn = "src/test/resources/com/puppycrawl/tools/checkstyle/suppressions_bad_int.xml" ; try { SuppressionsLoader . loadSuppressions ( fn ) ; } catch ( CheckstyleException ex ) { assertTrue ( ex . getMessage ( ) , ex . getMessage ( ) . startsWith ( "number format exception " + fn + " - " ) ) ; } } private static boolean isInternetReachable ( ) { try { URL url = new URL ( "http://www.yahoo.com" ) ; HttpURLConnection urlConnect = ( HttpURLConnection ) url . openConnection ( ) ; @ SuppressWarnings ( "unused" ) Object objData = urlConnect . getContent ( ) ; } catch ( IOException e ) { return false ; } return true ; } }
package com . puppycrawl . tools . checkstyle . design ; public class InputMutableException { public class FooException extends Exception { private final int finalErrorCode ; private int errorCode = 1 ; public FooException ( ) { finalErrorCode = 1 ; } public class FooExceptionThisIsNot extends RuntimeException { private final int finalErrorCode ; private int errorCode = 1 ; public FooExceptionThisIsNot ( ) { finalErrorCode = 1 ; } } } public class BarError extends Throwable { private int errorCode ; } public class BazDoesNotExtendError { private int errorCode ; } public class CustomProblem extends ThreadDeath { private int errorCode ; public class CustomFailure extends ThreadDeath { private int errorCode ; public void someMethod ( ) { if ( true ) { final int i = 0 ; } } } } class CustomException extends java . lang . Exception { } class CustomMutableException extends java . lang . Exception { int errorCode ; } }
package com . puppycrawl . tools . checkstyle . design ; public class InputRegression1762702 { public long constructionTime = System . currentTimeMillis ( ) ; public static InputRegression1762702 create ( ) { return new InputRegression1762702 ( ) ; } }
package com . puppycrawl . tools . checkstyle . design ; public class HideUtilityClassConstructor { protected HideUtilityClassConstructor ( ) { } }
package com . puppycrawl . tools . checkstyle . design ; public class UtilityClassConstructorPrivate { private UtilityClassConstructorPrivate ( ) { } private static int value = 0 ; public static void foo ( int val ) { value = val ; } }
package com . puppycrawl . tools . checkstyle . design ; public class UtilityClassConstructorPublic { public UtilityClassConstructorPublic ( ) { } private static int value = 0 ; public static void foo ( int val ) { value = val ; } }
package com . puppycrawl . tools . checkstyle . design ; public interface InputOneTopLevelInterface { int foo ( ) ; }
package com . puppycrawl . tools . checkstyle . filters ; class InputSuppressionCommentFilter { private int I ; private int J ; private int K ; private int L ; private static final int m = 0 ; private int M2 ; private static final int n = 0 ; private int P ; private int Q ; private int R ; private static final int s = 0 ; private int T ; public static void doit1 ( int aInt ) { } public static void doit2 ( int aInt ) { } public void doit3 ( ) { try { for ( int i = 0 ; i < 10 ; i ++ ) { while ( true ) { try { } catch ( Exception e ) { } } } } catch ( Exception ex ) { } try { } catch ( RuntimeException ex ) { } catch ( Exception ex ) { } } }
package com . puppycrawl . tools . checkstyle . filters ; @ SuppressWarnings ( "foo" ) class InputSuppressWarningsFilter { @ SuppressWarnings ( "foo" ) interface I { } @ SuppressWarnings ( "foo" ) enum E { } @ SuppressWarnings ( "foo" ) InputSuppressWarningsFilter ( ) { } @ SuppressWarnings ( "foo" ) @ interface A { } @ SuppressWarnings ( "unused" ) private int I ; @ SuppressWarnings ( { "membername" } ) private int J ; private int K ; @ SuppressWarnings ( value = "membername" ) private int L ; private int X ; @ SuppressWarnings ( "checkstyle:constantname" ) private static final int m = 0 ; private static final int n = 0 ; @ SuppressWarnings ( "paramnum" ) public void needsLotsOfParameters ( @ SuppressWarnings ( "unused" ) int a , int b , int c , int d , int e , int f , int g , int h ) { @ SuppressWarnings ( "unused" ) int z ; try { } catch ( Exception ex ) { } } @ java . lang . SuppressWarnings ( "illegalcatch" ) public void needsToCatchException ( ) { try { } catch ( Exception ex ) { } } enum AnEnum { @ SuppressWarnings ( "rawtypes" ) ELEMENT ; } private static final String UNUSED = "UnusedDeclaration" ; @ SuppressWarnings ( UNUSED ) public void annotationUsingStringConstantValue ( ) { } }
package com . puppycrawl . tools . checkstyle . filters ; class InputSuppressWithNearbyCommentFilter { private int A1 ; private int A2 ; private int A3 ; private int B1 ; private int B2 ; private int B3 ; private int C1 ; private int C2 ; private int C3 ; private int D1 ; private int D2 ; private int D3 ; private static final int e1 = 0 ; private int E2 ; private int E3 ; private static final int e4 = 0 ; private int E5 ; private static final int e6 = 0 ; private int E7 ; private int E8 ; private static final int e9 = 0 ; public static void doit1 ( int aInt ) { } public static void doit2 ( int aInt ) { } public static void doit3 ( int aInt ) { } public void doit4 ( ) { try { for ( int i = 0 ; i < 10 ; i ++ ) { while ( true ) { try { } catch ( Exception e ) { } catch ( Throwable t ) { } } } } catch ( Exception ex ) { } } }
package com . puppycrawl . tools . checkstyle . header ; public class H1 { }
package com . puppycrawl . tools . checkstyle . filters ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . LocalizedMessage ; import java . util . regex . PatternSyntaxException ; import nl . jqno . equalsverifier . EqualsVerifier ; import nl . jqno . equalsverifier . Warning ; import org . junit . Before ; import org . junit . Test ; public class SuppressElementTest { private SuppressElement filter ; @ Before public void setUp ( ) throws PatternSyntaxException { filter = new SuppressElement ( "Test" ) ; filter . setChecks ( "Test" ) ; } @ Test public void testDecideDefault ( ) { final AuditEvent ev = new AuditEvent ( this , "Test.java" ) ; assertTrue ( ev . getFileName ( ) , filter . accept ( ev ) ) ; } @ Test public void testDecideLocalizedMessage ( ) { LocalizedMessage message = new LocalizedMessage ( 0 , 0 , "" , "" , null , null , this . getClass ( ) , null ) ; final AuditEvent ev = new AuditEvent ( this , "ATest.java" , message ) ; assertFalse ( "Names match" , filter . accept ( ev ) ) ; } @ Test public void testDecideByLine ( ) { LocalizedMessage message = new LocalizedMessage ( 10 , 10 , "" , "" , null , null , this . getClass ( ) , null ) ; final AuditEvent ev = new AuditEvent ( this , "ATest.java" , message ) ; filter . setLines ( "1-10" ) ; assertFalse ( "In range 1-10" , filter . accept ( ev ) ) ; filter . setLines ( "1-9, 11" ) ; assertTrue ( "Not in 1-9, 11" , filter . accept ( ev ) ) ; } @ Test public void testDecideByColumn ( ) { LocalizedMessage message = new LocalizedMessage ( 10 , 10 , "" , "" , null , null , this . getClass ( ) , null ) ; final AuditEvent ev = new AuditEvent ( this , "ATest.java" , message ) ; filter . setColumns ( "1-10" ) ; assertFalse ( "In range 1-10" , filter . accept ( ev ) ) ; filter . setColumns ( "1-9, 11" ) ; assertTrue ( "Not in 1-9, 1)" , filter . accept ( ev ) ) ; } @ Test public void testEquals ( ) throws PatternSyntaxException { final SuppressElement filter2 = new SuppressElement ( "Test" ) ; filter2 . setChecks ( "Test" ) ; assertEquals ( "filter, filter2" , filter , filter2 ) ; final SuppressElement filter3 = new SuppressElement ( "Test" ) ; filter3 . setChecks ( "Test3" ) ; assertFalse ( "filter, filter3" , filter . equals ( filter3 ) ) ; filter . setColumns ( "1-10" ) ; assertFalse ( "filter, filter2" , filter . equals ( filter2 ) ) ; filter2 . setColumns ( "1-10" ) ; assertEquals ( "filter, filter2" , filter , filter2 ) ; filter . setColumns ( null ) ; assertFalse ( "filter, filter2" , filter . equals ( filter2 ) ) ; filter2 . setColumns ( null ) ; filter . setLines ( "3,4" ) ; assertFalse ( "filter, filter2" , filter . equals ( filter2 ) ) ; filter2 . setLines ( "3,4" ) ; assertEquals ( "filter, filter2" , filter , filter2 ) ; filter . setColumns ( "1-10" ) ; assertFalse ( "filter, filter2" , filter . equals ( filter2 ) ) ; filter2 . setColumns ( "1-10" ) ; assertEquals ( "filter, filter2" , filter , filter2 ) ; } @ Test public void testEqualsAndHashCode ( ) { EqualsVerifier . forClass ( SuppressElement . class ) . usingGetClass ( ) . suppress ( Warning . NONFINAL_FIELDS ) . verify ( ) ; } }
package com . puppycrawl . tools . checkstyle . header ; public class H2 { }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import java . io . IOException ; class InputTags1 { private int mMissingJavadoc ; void method1 ( ) { } void method2 ( ) { } int method3 ( ) { return 3 ; } int method4 ( int aOne ) { return aOne ; } void method5 ( ) throws Exception { } void method6 ( ) throws Exception { } void method7 ( ) throws Exception , NullPointerException { } void method8 ( int aOne ) { } void method9 ( int aOne ) { } void method10 ( int aOne , int aTwo ) { } void method11 ( ) { } int method12 ( ) { return 0 ; } void method13 ( int aOne , int aTwo , int aThree , int aFour , int aFive ) { } void method14 ( int aOne ) { } void method14 ( ) throws java . io . IOException { } static { int x = 1 ; } { int z = 2 ; } private static final int ON_SECOND_LINE = 2 ; void method15 ( ) throws java . io . IOException { } public String toString ( ) { return super . toString ( ) ; } static final int serialVersionUID = 666 ; void method16 ( int aOne ) { } void method17 ( ) throws IllegalMonitorStateException { } void method18 ( ) throws IOException { throw new IOException ( "to make compiler happy" ) ; } void method19 ( ) throws java . io . IOException { throw new IOException ( "to make compiler happy" ) ; } int method20 ( ) { return 579190 ; } void method21 ( ) throws IOException { } void method22 ( ) throws IOException { } void method23 ( ) throws WrongException { } void method24 ( ) throws IOException { } void method25 ( ) { } int method26 ( ) { return 0 ; } int method27 ( int aParam ) { return 0 ; } int method28 ( int aParam ) { return 0 ; } public int foo ( Object _arg ) { return 1 ; } } enum InputTagsEnum { CONSTANT_A , CONSTANT_B , CONSTANT_C { public void someMethod ( ) { } public void someOtherMethod ( ) { } } } @ interface InputTagsAnnotation { String someField ( ) ; int A_CONSTANT = 0 ; int B_CONSTANT = 1 ; String someField2 ( ) ; } public class InputTags { public InputTags ( ) { } public final String myMethod ( final String arg1 , final Object arg2 ) throws Exception { return null ; } } class WrongException extends RuntimeException { }
package com . puppycrawl . tools . checkstyle . checks . coding ; public class OneStatementPerLineCheckInput { class SmallTalkStyle { SmallTalkStyle doSomething1 ( ) { return this ; } SmallTalkStyle doSomething2 ( ) { return this ; } SmallTalkStyle doSomething3 ( ) { return this ; } } private int one = 0 ; private int two = 0 ; public void doLegal ( ) { one = 1 ; two = 2 ; } public void doLegalComment ( ) { one = 1 ; two = 2 ; } public void doLegalString ( ) { one = 1 ; two = 2 ; System . out . println ( "one = 1; two = 2" ) ; } public void doLegalForLoop ( ) { for ( int i = 0 ; i < 20 ; i ++ ) { one = i ; } } public void doIllegal ( ) { one = 1 ; two = 2 ; } public void doIllegalSmallTalk ( ) { SmallTalkStyle smalltalker = new SmallTalkStyle ( ) ; smalltalker . doSomething1 ( ) . doSomething2 ( ) . doSomething3 ( ) ; } public void doIllegalSmallTalk2 ( ) { SmallTalkStyle smalltalker = new SmallTalkStyle ( ) ; smalltalker . doSomething1 ( ) . doSomething2 ( ) . doSomething3 ( ) ; } public void doIllegal2 ( ) { one = 1 ; two = 2 ; } public void doStringBuffer ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "test " ) ; sb . append ( "test2 " ) . append ( "test3 " ) ; appendToSpringBuffer ( sb , "test4" ) ; } private void appendToSpringBuffer ( StringBuffer sb , String text ) { sb . append ( text ) ; } }
package com . puppycrawl . tools . checkstyle ; import java . util . Comparator ; public interface InputModifier2 extends Comparator < Integer > { @ Override default int compare ( Integer a , Integer b ) { return 0 ; } }
public interface MyInterface { final int k = 5 ; default int defaultMethod ( final int x ) { if ( k == 5 ) { final int t = 24 ; for ( ; ; ) { final String s = "some" ; } } final int square = x * x ; return square ; } }
package com . puppycrawl . tools . checkstyle ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; import java . util . List ; import java . util . Map ; public class InputSuppressWarningsHolder { public static Object foo1 ( @ SuppressWarnings ( "unsused" ) Object str ) { String myString = ( @ SuppressWarnings ( "unsused" ) String ) str ; Object object = new @ SuppressWarnings ( "unsused" ) Object ( ) ; try { return null ; } catch ( @ SuppressWarnings ( "unsused" ) Exception ex ) { return "" ; } } void foo2 ( ) throws @ SuppressWarnings ( "unsused" ) Exception { } public void foo3 ( ) { Map . @ SuppressWarnings ( "unsused" ) Entry entry ; MyObject myObject = new MyObject ( ) ; myObject . < @ SuppressWarnings ( "unsused" ) String > myMethod ( ) ; myObject . new @ SuppressWarnings ( "unsused" ) MyObject2 ( ) ; } public static < T > void foo4 ( Object str ) { List < @ SuppressWarnings ( "unsused" ) ? extends Comparable < T > > unchangeable ; } abstract class UnmodifiableList < T > implements @ SuppressWarnings ( "unsused" ) List < @ SuppressWarnings ( "unsused" ) T > { } class MyObject { public void myMethod ( ) { } ; class MyObject2 { } } @ Target ( ElementType . TYPE_USE ) @ interface SuppressWarnings { String value ( ) ; } }
public interface InputStaticModifierInInterface { static int f ( ) { int someName = 5 ; return someName ; } }
package com . puppycrawl . tools . checkstyle . whitespace ; public class InputGenericWhitespaceMethodRef { final Supplier < Optional < Integer > > function = Optional : : < Integer > empty ; final Supplier < Optional < Integer > > function = Optional : : < Integer > empty ; }
package com . puppycrawl . tools . checkstyle . blocks ; public class InputSingleLineLambda { static Runnable r1 = ( ) - > System . out . println ( "Hello world one!" ) ; static Runnable r2 = ( ) - > System . out . println ( "Hello world two!" ) ; }
package com . puppycrawl . tools . checkstyle . naming ; public class InputFinalLocalVariableNameLambda { private void addTotalValueOfOrder ( final AugmentedOrder order ) { final BigDecimal totalValueOfOrder = order . getTransactions ( ) . stream ( ) . reduce ( BigDecimal . ZERO , ( t , u ) - > t . add ( u . getAmount ( ) ) , BigDecimal : : add ) ; order . setTotalValueOfOrder ( totalValueOfOrder . toPlainString ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks ; import static org . junit . Assert . assertTrue ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . Checker ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . TreeWalker ; import com . puppycrawl . tools . checkstyle . api . AbstractFileSetCheck ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import java . io . File ; import java . util . List ; import java . util . Locale ; import com . puppycrawl . tools . checkstyle . checks . imports . AvoidStarImportCheck ; import org . junit . Test ; public class FileSetCheckLifecycleTest extends BaseCheckTestSupport { @ Override protected DefaultConfiguration createCheckerConfig ( Configuration checkConfig ) { final DefaultConfiguration dc = new DefaultConfiguration ( "root" ) ; dc . addChild ( checkConfig ) ; return dc ; } public static class TestFileSetCheck extends AbstractFileSetCheck { private static boolean destroyed ; private static boolean fileContentAvailable ; @ Override public void destroy ( ) { destroyed = true ; } public static boolean isDestroyed ( ) { return destroyed ; } public static boolean isFileContentAvailable ( ) { return fileContentAvailable ; } @ Override protected void processFiltered ( File file , List < String > lines ) { } @ Override public void finishProcessing ( ) { fileContentAvailable = FileContentsHolder . getContents ( ) != null ; } } @ Test public void testTranslation ( ) throws Exception { final Configuration checkConfig = createCheckConfig ( TestFileSetCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputScopeAnonInner.java" ) , expected ) ; assertTrue ( "destroy() not called by Checker" , TestFileSetCheck . isDestroyed ( ) ) ; } @ Test public void testProcessCallsFinishBeforeCallingDestroy ( ) throws Exception { DefaultConfiguration dc = new DefaultConfiguration ( "configuration" ) ; DefaultConfiguration twConf = createCheckConfig ( TreeWalker . class ) ; dc . addAttribute ( "charset" , "UTF-8" ) ; dc . addChild ( twConf ) ; twConf . addChild ( new DefaultConfiguration ( FileContentsHolder . class . getName ( ) ) ) ; twConf . addChild ( new DefaultConfiguration ( AvoidStarImportCheck . class . getName ( ) ) ) ; final Checker checker = new Checker ( ) ; final Locale locale = Locale . ROOT ; checker . setLocaleCountry ( locale . getCountry ( ) ) ; checker . setLocaleLanguage ( locale . getLanguage ( ) ) ; checker . setModuleClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; checker . configure ( dc ) ; checker . addListener ( new BriefLogger ( stream ) ) ; checker . addFileSetCheck ( new TestFileSetCheck ( ) ) ; final String [ ] expected = { } ; verify ( checker , getPath ( "InputScopeAnonInner.java" ) , expected ) ; assertTrue ( "FileContent should be available during finishProcessing() call" , TestFileSetCheck . isFileContentAvailable ( ) ) ; } }
import java . util . List ; import java . util . List ; import java . util . Arrays ; import java . lang . String ; import static java . lang . Math . PI ; public class InputRedundantImportCheck_UnnamedPackage { public static double pi = PI ; public List myList ; }
package java . util . concurrent ; import com . google . common . * ; import java . util . StringTokenizer ; import java . util . * ; import java . util . concurrent . * ; import static java . awt . Button . ABORT ; import static javax . swing . WindowConstants . * ; import com . puppycrawl . tools . * ; import java . util . concurrent . AbstractExecutorService ; import static java . io . File . createTempFile ; import com . * ; import org . apache . * ; public class InputCustomImportOrderSamePackage { }
package java . util . concurrent ; import java . util . regex . Pattern ; import java . util . List ; import java . util . regex . Matcher ; import java . util . StringTokenizer ; import java . util . * ; import java . util . concurrent . AbstractExecutorService ; import java . util . concurrent . * ; public class InputCustomImportOrderSamePackage2 { }
import static java . io . File . createTempFile ; import static java . awt . Button . ABORT ; import static javax . swing . WindowConstants . * ; import java . awt . Button ; import java . awt . Frame ; import java . awt . Dialog ; import java . awt . event . ActionEvent ; import javax . swing . JComponent ; import javax . swing . JTable ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import com . puppycrawl . tools . * ; import com . google . common . * ; import org . apache . * ; public class InputImportOrder { }
package com . puppycrawl . tools . checkstyle . grammars ; import java . util . Arrays ; ; import java . util . ArrayList ; public class SemicolonBetweenImports { }
import java . util . function . Supplier ; public class InputLambdaTest17 { void initPartialTraversalState ( ) { SpinedBuffer < P_OUT > b = new SpinedBuffer < > ( ) ; P_OUT spliterator = new P_OUT ( ) ; Supplier pusher = ( ) - > spliterator . tryAdvance ( b ) ; } private class P_OUT { public Object tryAdvance ( SpinedBuffer < P_OUT > b ) { return null ; } } class SpinedBuffer < T > { } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . util . Arrays ; import java . util . List ; public class InputLambdaTest4 { public void doSomething ( ) { List < Integer > numbers = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 ) ; numbers . forEach ( ( Integer value ) - > System . out . println ( value ) ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; public class InputLambdaTest11 { public static void testVoidLambda ( TestOfVoidLambdas test ) { System . out . println ( "Method called" ) ; test . doSmth ( "fef" ) ; } public static void main ( String [ ] args ) { testVoidLambda ( s1 - > { System . out . println ( s1 ) ; } ) ; } private interface TestOfVoidLambdas { public void doSmth ( String first ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; public class InputAnnotationsTest3 { public static void methodName ( Object str ) { String myString = ( @ NonNull String ) str ; } @ Target ( ElementType . TYPE_USE ) @ interface NonNull { } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; @ Schedule public class InputAnnotationsTest2 { } @ Target ( { ElementType . TYPE_USE , ElementType . TYPE_PARAMETER } ) @ interface Schedule { }
package com . puppycrawl . tools . checkstyle . checks ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class OuterTypeFilenameCheckTest extends BaseCheckTestSupport { @ Test public void testGood1 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OuterTypeFilenameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } @ Test public void testGood2 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( OuterTypeFilenameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "Input15Extensions.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; import java . util . List ; public class InputAnnotationsTest9 { public static < T > void methodName ( Object str ) { List < @ Immutable ? extends Comparable < T > > unchangeable ; } @ Target ( ElementType . TYPE_USE ) @ interface Immutable { } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; public class InputLambdaTest8 { public static void testVoidLambda ( TestOfVoidLambdas test ) { System . out . println ( "Method called" ) ; test . doSmth ( "fef" , 2 ) ; } public static void main ( String [ ] args ) { testVoidLambda ( ( s1 , s2 ) - > System . out . println ( s1 + s2 ) ) ; } private interface TestOfVoidLambdas { public void doSmth ( String first , Integer second ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . util . function . Supplier ; public static class InputMethodReferencesTest3 { public static class SomeClass { public static class Nested < V > { public Nested ( ) { } } } public < V > void methodName ( V value ) { MyClass < T > : : myMethod ; Supplier < SomeClass . Nested < V > > passes = SomeClass . Nested : : new ; Supplier < SomeClass . Nested < V > > fails = SomeClass . Nested < V > : : new ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; public class InputLambdaTest9 { public static void testVoidLambda ( TestOfVoidLambdas test ) { System . out . println ( "Method called" ) ; test . doSmth ( "fef" , 2 ) ; } public static void main ( String [ ] args ) { testVoidLambda ( ( s1 , s2 ) - > { System . out . println ( s1 + s2 ) ; } ) ; } private interface TestOfVoidLambdas { public void doSmth ( String first , Integer second ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . util . function . Function ; import java . util . function . Supplier ; import com . sun . corba . se . impl . protocol . giopmsgheaders . Message ; public class InputMethodReferencesTest2 { public static void main ( String [ ] args ) { Supplier < InputMethodReferencesTest2 > supplier = InputMethodReferencesTest2 : : new ; Supplier < InputMethodReferencesTest2 > suppl = InputMethodReferencesTest2 : : < Integer > new ; Function < Integer , Message [ ] > messageArrayFactory = Message [ ] : : new ; } private class Bar < T > { } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; public class InputLambdaTest1 { static Runnable r1 = ( ) - > System . out . println ( "Hello world one!" ) ; static Runnable r2 = ( ) - > System . out . println ( "Hello world two!" ) ; public static void main ( String [ ] args ) { r1 . run ( ) ; r2 . run ( ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . util . Arrays ; import java . util . List ; import java . util . function . Supplier ; import com . sun . corba . se . impl . protocol . giopmsgheaders . Message ; public class InputMethodReferencesTest < T > extends ParentClass { public void main ( String [ ] args ) { List < Integer > numbers = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 ) ; numbers . forEach ( System . out : : println ) ; InputMethodReferencesTest tl = new InputMethodReferencesTest ( ) ; String roster = new String ( ) ; Supplier < InputMethodReferencesTest > supplier = InputMethodReferencesTest < String > : : new ; numbers . forEach ( this : : println ) ; numbers . forEach ( super : : println ) ; Supplier < InputMethodReferencesTest2 > supplier = InputMethodReferencesTest2 : : new ; Supplier < InputMethodReferencesTest2 > suppl = InputMethodReferencesTest2 : : < Integer > new ; Function < Integer , Message [ ] > messageArrayFactory = Message [ ] : : new ; } } class ParentClass { public String println ( Integer i ) { return null ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; public class InputLambdaTest13 { public static void testVoidLambda ( TestOfVoidLambdas test ) { System . out . println ( "Method called" ) ; test . doSmth ( "fef" , 5 ) ; } public static void main ( String [ ] args ) { testVoidLambda ( ( String s1 , Integer i2 ) - > { System . out . println ( s1 ) ; } ) ; } private interface TestOfVoidLambdas { public void doSmth ( String first , Integer second ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . util . Arrays ; import java . util . List ; public class InputLambdaTest5 { public void doSomething ( ) { List < Integer > numbers = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 ) ; numbers . forEach ( ( Integer value ) - > { System . out . println ( value ) ; } ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; import java . util . List ; public class InputAnnotationsTest7 { public static void main ( String [ ] args ) { Object object = new @ Interned Object ( ) ; } @ Target ( ElementType . TYPE_USE ) @ interface Interned { } }
package com . puppycrawl . tools . checkstyle . checks ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . SortedSet ; import org . junit . Assert ; import org . junit . Before ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseFileSetCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . LocalizedMessage ; import static com . puppycrawl . tools . checkstyle . checks . UniquePropertiesCheck . IO_EXCEPTION_KEY ; import static com . puppycrawl . tools . checkstyle . checks . UniquePropertiesCheck . MSG_KEY ; public class UniquePropertiesCheckTest extends BaseFileSetCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( UniquePropertiesCheck . class ) ; } @ Test public void testDefault ( ) throws Exception { final String [ ] expected = { "3: " + getCheckMessage ( MSG_KEY , "general.exception" , 2 ) , "5: " + getCheckMessage ( MSG_KEY , "DefaultLogger.auditStarted" , 2 ) , "11: " + getCheckMessage ( MSG_KEY , "onlineManual" , 3 ) , "22: " + getCheckMessage ( MSG_KEY , "time stamp" , 3 ) , "28: " + getCheckMessage ( MSG_KEY , "Support Link " , 2 ) , "34: " + getCheckMessage ( MSG_KEY , "failed" , 2 ) , } ; verify ( checkConfig , getPath ( "InputUniquePropertiesCheck.properties" ) , expected ) ; } @ Test public void testNotFoundKey ( ) throws Exception { final UniquePropertiesCheck check = new UniquePropertiesCheck ( ) ; final List < String > testStrings = new ArrayList < > ( 3 ) ; testStrings . add ( "" ) ; testStrings . add ( "0 = 0" ) ; testStrings . add ( "445" ) ; final int stringNumber = check . getLineNumber ( testStrings , "some key" ) ; Assert . assertEquals ( stringNumber , 0 ) ; } @ Test public void testIOException ( ) throws Exception { final UniquePropertiesCheck check = new UniquePropertiesCheck ( ) ; check . configure ( checkConfig ) ; final String fileName = getPath ( "InputUniquePropertiesCheckNotExisting.properties" ) ; final File file = new File ( fileName ) ; final SortedSet < LocalizedMessage > messages = check . process ( file , Collections . < String > emptyList ( ) ) ; Assert . assertEquals ( "Wrong messages count: " + messages . size ( ) , messages . size ( ) , 1 ) ; final LocalizedMessage message = messages . iterator ( ) . next ( ) ; final String retrievedMessage = messages . iterator ( ) . next ( ) . getKey ( ) ; Assert . assertEquals ( "Message key '" + retrievedMessage + "' is not valid" , retrievedMessage , "unable.open.cause" ) ; Assert . assertEquals ( "Message '" + message . getMessage ( ) + "' is not valid" , message . getMessage ( ) , getCheckMessage ( IO_EXCEPTION_KEY , fileName , getFileNotFoundDetail ( file ) ) ) ; } private String getFileNotFoundDetail ( File file ) throws Exception { try { final InputStream stream = new FileInputStream ( file ) ; stream . close ( ) ; throw new Exception ( "File " + file . getPath ( ) + " should not exist" ) ; } catch ( FileNotFoundException ex ) { return ex . getLocalizedMessage ( ) ; } } }
package com . puppycrawl . tools . checkstyle ; import static java . text . MessageFormat . format ; import static org . junit . Assert . assertEquals ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; import java . io . OutputStream ; import java . io . PrintStream ; import java . io . UnsupportedEncodingException ; import java . util . Collections ; import java . util . List ; import java . util . Locale ; import java . util . Properties ; public abstract class BaseCheckTestSupport { protected static class BriefLogger extends DefaultLogger { public BriefLogger ( OutputStream out ) throws UnsupportedEncodingException { super ( out , true ) ; } @ Override public void auditStarted ( AuditEvent evt ) { } @ Override public void fileFinished ( AuditEvent evt ) { } @ Override public void fileStarted ( AuditEvent evt ) { } } protected final ByteArrayOutputStream BAOS = new ByteArrayOutputStream ( ) ; protected final PrintStream stream = new PrintStream ( BAOS ) ; protected final Properties props = new Properties ( ) ; public static DefaultConfiguration createCheckConfig ( Class < ? > clazz ) { final DefaultConfiguration checkConfig = new DefaultConfiguration ( clazz . getName ( ) ) ; return checkConfig ; } protected Checker createChecker ( Configuration checkConfig ) throws Exception { final DefaultConfiguration dc = createCheckerConfig ( checkConfig ) ; final Checker c = new Checker ( ) ; final Locale locale = Locale . ROOT ; c . setLocaleCountry ( locale . getCountry ( ) ) ; c . setLocaleLanguage ( locale . getLanguage ( ) ) ; c . setModuleClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; c . configure ( dc ) ; c . addListener ( new BriefLogger ( stream ) ) ; return c ; } protected DefaultConfiguration createCheckerConfig ( Configuration config ) { final DefaultConfiguration dc = new DefaultConfiguration ( "configuration" ) ; final DefaultConfiguration twConf = createCheckConfig ( TreeWalker . class ) ; dc . addAttribute ( "charset" , "UTF-8" ) ; dc . addChild ( twConf ) ; twConf . addChild ( config ) ; return dc ; } protected static String getPath ( String filename ) throws IOException { return new File ( "src/test/resources/com/puppycrawl/tools/checkstyle/" + filename ) . getCanonicalPath ( ) ; } protected static String getSrcPath ( String filename ) throws IOException { return new File ( "src/test/java/com/puppycrawl/tools/checkstyle/" + filename ) . getCanonicalPath ( ) ; } protected void verify ( Configuration aConfig , String fileName , String [ ] expected ) throws Exception { verify ( createChecker ( aConfig ) , fileName , fileName , expected ) ; } protected void verify ( Checker c , String fileName , String [ ] expected ) throws Exception { verify ( c , fileName , fileName , expected ) ; } protected void verify ( Checker c , String processedFilename , String messageFileName , String [ ] expected ) throws Exception { verify ( c , new File [ ] { new File ( processedFilename ) } , messageFileName , expected ) ; } protected void verify ( Checker c , File [ ] processedFiles , String messageFileName , String [ ] expected ) throws Exception { stream . flush ( ) ; final List < File > theFiles = Lists . newArrayList ( ) ; Collections . addAll ( theFiles , processedFiles ) ; final int errs = c . process ( theFiles ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( BAOS . toByteArray ( ) ) ; final LineNumberReader lnr = new LineNumberReader ( new InputStreamReader ( bais ) ) ; for ( int i = 0 ; i < expected . length ; i ++ ) { final String expectedResult = messageFileName + ":" + expected [ i ] ; final String actual = lnr . readLine ( ) ; assertEquals ( "error message " + i , expectedResult , actual ) ; } assertEquals ( "unexpected output: " + lnr . readLine ( ) , expected . length , errs ) ; c . destroy ( ) ; } public String getCheckMessage ( String messageKey , Object ... arguments ) { Properties pr = new Properties ( ) ; try { pr . load ( getClass ( ) . getResourceAsStream ( "messages.properties" ) ) ; } catch ( IOException e ) { return null ; } return format ( pr . getProperty ( messageKey ) , arguments ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . util . Arrays ; import java . util . List ; public class InputLambdaTest14 { public static void main ( String args [ ] ) { List < Integer > numbers = Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ; numbers . forEach ( first - > { System . out . println ( "first" ) ; System . out . println ( "second" ) ; System . out . println ( "third" ) ; } ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; public class InputAnnotationsTest4 { public static void methodName ( @ NotNull String args ) { } @ Target ( ElementType . TYPE_USE ) @ interface NotNull { } }
import java . util . function . Predicate ; public class InputLambdaTest19 { static < T > Predicate < T > isEqual ( Object targetRef ) { return ( null == targetRef ) ? null : object - > targetRef . equals ( object ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; public class InputLambdaTest2 { public static void testVoidLambda ( TestOfVoidLambdas test ) { System . out . println ( "Method called" ) ; test . doSmth ( ) ; } public static void main ( String [ ] args ) { testVoidLambda ( ( ) - > System . out . println ( "Method in interface called" ) ) ; } private interface TestOfVoidLambdas { public void doSmth ( ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; public class InputAnnotationsTest10 { public static Object methodName ( Object str ) { try { return null ; } catch ( @ MyAnnotation1 ( name = "ABC" , version = 1 ) Exception ex ) { return "" ; } } @ Target ( ElementType . TYPE_USE ) @ interface MyAnnotation1 { String name ( ) ; int version ( ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; public class InputLambdaTest12 { public static void testVoidLambda ( TestOfVoidLambdas test ) { System . out . println ( "Method called" ) ; test . doSmth ( "fef" , 5 ) ; } public static void main ( String [ ] args ) { testVoidLambda ( ( String s1 , Integer i2 ) - > System . out . println ( s1 ) ) ; } private interface TestOfVoidLambdas { public void doSmth ( String first , Integer second ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; import java . util . List ; public class InputAnnotationsTest6 { abstract class UnmodifiableList < T > implements @ Readonly List < @ Readonly T > { } @ Target ( ElementType . TYPE_USE ) @ interface Readonly { } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . util . Arrays ; import java . util . List ; public class InputLambdaTest7 { public void doSomething ( ) { List < Integer > numbers = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 ) ; numbers . forEach ( ( value ) - > { System . out . println ( value ) ; } ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; public class InputAnnotationsTest5 { void monitorTemperature ( ) throws @ Critical Exception { } @ Target ( ElementType . TYPE_USE ) @ interface Critical { } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; import java . util . Map ; public class InputAnnotationsTest8 { public void main ( String [ ] args ) { Map . @ NotNull Entry entry ; MyObject myObject = new MyObject ( ) ; myObject . < @ NotBlank String > myMethod ( ) ; myObject . new @ NotNull MyObject2 ( ) ; } @ Target ( ElementType . TYPE_USE ) @ interface NotNull { } @ Target ( ElementType . TYPE_USE ) @ interface NotBlank { } class MyObject { public void myMethod ( ) { } ; class MyObject2 { } } }
package com . puppycrawl . tools . checkstyle . checks ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . fail ; import com . google . common . collect . Sets ; import java . util . Set ; import org . junit . Test ; public class ClassResolverTest { @ Test public void testMisc ( ) throws ClassNotFoundException { final Set < String > imps = Sets . newHashSet ( ) ; imps . add ( "java.io.File" ) ; imps . add ( "nothing.will.match.*" ) ; imps . add ( "java.applet.*" ) ; ClassResolver cr = new ClassResolver ( Thread . currentThread ( ) . getContextClassLoader ( ) , null , imps ) ; assertNotNull ( cr ) ; try { cr . resolve ( "who.will.win.the.world.cup" , "" ) ; fail ( "Should not resolve class" ) ; } catch ( ClassNotFoundException e ) { } cr . resolve ( "java.lang.String" , "" ) ; cr . resolve ( "StringBuffer" , "" ) ; cr . resolve ( "AppletContext" , "" ) ; try { cr . resolve ( "ChoiceFormat" , "" ) ; fail ( ) ; } catch ( ClassNotFoundException e ) { } imps . add ( "java.text.ChoiceFormat" ) ; cr . resolve ( "ChoiceFormat" , "" ) ; cr = new ClassResolver ( Thread . currentThread ( ) . getContextClassLoader ( ) , "java.util" , imps ) ; cr . resolve ( "List" , "" ) ; try { cr . resolve ( "two.nil.england" , "" ) ; fail ( ) ; } catch ( ClassNotFoundException e ) { } } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . util . Arrays ; import java . util . List ; public class InputLambdaTest6 { public void doSomething ( ) { List < Integer > numbers = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 ) ; numbers . forEach ( ( value ) - > System . out . println ( value ) ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; public class InputLambdaTest3 { public static void testVoidLambda ( TestOfVoidLambdas test ) { System . out . println ( "Method called" ) ; test . doSmth ( ) ; } public static void main ( String [ ] args ) { testVoidLambda ( ( ) - > { System . out . println ( "Method in interface called" ) ; } ) ; } private interface TestOfVoidLambdas { public void doSmth ( ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; public class InputLambdaTest10 { public static void testVoidLambda ( TestOfVoidLambdas test ) { System . out . println ( "Method called" ) ; test . doSmth ( "fef" ) ; } public static void main ( String [ ] args ) { testVoidLambda ( s1 - > System . out . println ( s1 ) ) ; } private interface TestOfVoidLambdas { public void doSmth ( String first ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; public interface InputDefaultMethodsTest { default public void doSomething ( ) { System . out . println ( "Something done." ) ; } public void doOneMoreThing ( ) ; }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . util . function . Function ; public class InputLambdaTest15 { public static void main ( String [ ] args ) { InputLambdaTest15 ex = new InputLambdaTest15 ( ) ; Function < Double , Double > sin = d - > ex . sin ( d ) ; Function < Double , Double > log = d - > ex . log ( d ) ; Function < Double , Double > exp = d - > ex . exp ( d ) ; InputLambdaTest15 compose = new InputLambdaTest15 ( ) ; System . out . println ( compose . calculate ( sin . compose ( log ) , 0.8 ) ) ; System . out . println ( compose . calculate ( sin . andThen ( log ) , 0.8 ) ) ; System . out . println ( compose . calculate ( sin . compose ( log ) . andThen ( exp ) , 0.8 ) ) ; System . out . println ( compose . calculate ( sin . compose ( log ) . compose ( exp ) , 0.8 ) ) ; System . out . println ( compose . calculate ( sin . andThen ( log ) . compose ( exp ) , 0.8 ) ) ; System . out . println ( compose . calculate ( sin . andThen ( log ) . andThen ( exp ) , 0.8 ) ) ; } public Double calculate ( Function < Double , Double > operator , Double d ) { return operator . apply ( d ) ; } public Double sin ( Double d ) { System . out . print ( "sin:" ) ; return Math . sin ( d ) ; } public Double log ( Double d ) { System . out . print ( "log:" ) ; return Math . log ( d ) ; } public Double exp ( Double d ) { System . out . print ( "exp:" ) ; return Math . exp ( d ) ; } }
package com . puppycrawl . tools . checkstyle . grammars . java8 ; import java . time . chrono . ChronoLocalDate ; import java . time . chrono . ChronoLocalDateTime ; import java . util . Comparator ; public class InputLambdaTest16 { static final Comparator < ChronoLocalDateTime < ? extends ChronoLocalDate > > DATE_TIME_ORDER = ( Comparator < ChronoLocalDateTime < ? extends ChronoLocalDate > > ) ( dateTime1 , dateTime2 ) - > { int cmp = Long . compare ( dateTime1 . toLocalDate ( ) . toEpochDay ( ) , dateTime2 . toLocalDate ( ) . toEpochDay ( ) ) ; if ( cmp == 0 ) { cmp = Long . compare ( dateTime1 . toLocalTime ( ) . toNanoOfDay ( ) , dateTime2 . toLocalTime ( ) . toNanoOfDay ( ) ) ; } return cmp ; } ; public static void main ( String args [ ] ) { } }
package com . puppycrawl . tools . checkstyle . indentation ; public class NewHandlerTestInput { public static void test ( ) { method ( ArrayList : : new ) ; } }
package com . puppycrawl . tools . checkstyle . coding ; import java . util . Optional ; import java . util . concurrent . Callable ; import java . util . function . Supplier ; public class InputReturnCountLambda { Runnable fieldWithOneReturnInLambda = ( ) - > { return ; } ; Callable < Integer > fieldWithTwoReturnInLambda = ( ) - > { if ( hashCode ( ) == 0 ) return 0 ; else return 1 ; } ; Optional < Integer > methodWithOneReturnInLambda ( ) { return Optional . of ( hashCode ( ) ) . filter ( i - > { return i > 0 ; } ) ; } Optional < Integer > methodWithTwoReturnInLambda ( ) { return Optional . of ( hashCode ( ) ) . filter ( i - > { if ( i > 0 ) return true ; else return false ; } ) ; } Optional < Boolean > methodWithThreeReturnInLambda ( int number ) { return Optional . of ( number ) . map ( i - > { if ( i == 42 ) return true ; else if ( i == 7 ) return true ; else return false ; } ) ; } int methodWithTwoReturnWithLambdas ( final int number ) { if ( hashCode ( ) > 0 ) { new Thread ( ( ) - > { } ) . start ( ) ; return number ; } else { return Optional . of ( hashCode ( ) ) . orElseGet ( ( ) - > { if ( number > 0 ) return number ; else return 0 ; } ) ; } } Supplier < Supplier < Integer > > methodWithOneReturnPerLambda ( ) { return ( ) - > { return ( ) - > { return 1 ; } ; } ; } }
package com . puppycrawl . tools . checkstyle . coding ; public class InputInnerAssignmentLambdaExpressions { private void setAction ( ) { button . setOnAction ( e - > pressed = true ) ; button . setOnAction ( e - > { pressed = true ; } ) ; } }
package com . puppycrawl . tools . checkstyle . coding ; public interface JsonTranslator { String toJson ( Response one , Response two , Response three ) ; String toJson ( Document document ) ; default String toJson ( Response one ) { return toJson ( one , one , one ) ; } default String toJson ( Response one , Response two ) { return toJson ( one , one , two ) ; } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . UpperEllCheck . MSG_KEY ; public class UpperEllCheckTest extends BaseCheckTestSupport { @ Test public void testWithChecker ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( UpperEllCheck . class ) ; final String [ ] expected = { "94:43: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } }
public class InputNoPackage { }
package com . puppycrawl . tools . checkstyle . coding ; import com . sun . corba . se . impl . protocol . giopmsgheaders . Message ; public class InputIllegalInstantiationCheckTest2 { public static void main ( String [ ] args ) { Supplier < InputMethodReferencesTest2 > supplier = InputMethodReferencesTest2 : : new ; Supplier < InputMethodReferencesTest2 > suppl = InputMethodReferencesTest2 : : < Integer > new ; Function < Integer , Message [ ] > messageArrayFactory = Message [ ] : : new ; } private class Bar < T > { } }
package com . puppycrawl . tools . checkstyle ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import java . util . ResourceBundle ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . AuditListener ; import com . puppycrawl . tools . checkstyle . api . AutomaticBean ; import com . puppycrawl . tools . checkstyle . api . SeverityLevel ; public class XMLLogger extends AutomaticBean implements AuditListener { private static final int BASE_10 = 10 ; private static final int BASE_16 = 16 ; private static final String [ ] ENTITIES = { "gt" , "amp" , "lt" , "apos" , "quot" , } ; private boolean closeStream ; private PrintWriter writer ; public XMLLogger ( OutputStream os , boolean closeStream ) { setOutputStream ( os ) ; this . closeStream = closeStream ; } private void setOutputStream ( OutputStream oS ) { try { final OutputStreamWriter osw = new OutputStreamWriter ( oS , "UTF-8" ) ; writer = new PrintWriter ( osw ) ; } catch ( final UnsupportedEncodingException e ) { throw new ExceptionInInitializerError ( e ) ; } } @ Override public void auditStarted ( AuditEvent evt ) { writer . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; final ResourceBundle compilationProperties = ResourceBundle . getBundle ( "checkstylecompilation" ) ; final String version = compilationProperties . getString ( "checkstyle.compile.version" ) ; writer . println ( "<checkstyle version=\"" + version + "\">" ) ; } @ Override public void auditFinished ( AuditEvent evt ) { writer . println ( "</checkstyle>" ) ; if ( closeStream ) { writer . close ( ) ; } else { writer . flush ( ) ; } } @ Override public void fileStarted ( AuditEvent evt ) { writer . println ( "<file name=\"" + encode ( evt . getFileName ( ) ) + "\">" ) ; } @ Override public void fileFinished ( AuditEvent evt ) { writer . println ( "</file>" ) ; } @ Override public void addError ( AuditEvent evt ) { if ( SeverityLevel . IGNORE != evt . getSeverityLevel ( ) ) { writer . print ( "<error" + " line=\"" + evt . getLine ( ) + "\"" ) ; if ( evt . getColumn ( ) > 0 ) { writer . print ( " column=\"" + evt . getColumn ( ) + "\"" ) ; } writer . print ( " severity=\"" + evt . getSeverityLevel ( ) . getName ( ) + "\"" ) ; writer . print ( " message=\"" + encode ( evt . getMessage ( ) ) + "\"" ) ; writer . println ( " source=\"" + encode ( evt . getSourceName ( ) ) + "\"/>" ) ; } } @ Override public void addException ( AuditEvent evt , Throwable throwable ) { final StringWriter sw = new StringWriter ( ) ; final PrintWriter pw = new PrintWriter ( sw ) ; pw . println ( "<exception>" ) ; pw . println ( "<![CDATA[" ) ; throwable . printStackTrace ( pw ) ; pw . println ( "]]>" ) ; pw . println ( "</exception>" ) ; pw . flush ( ) ; writer . println ( encode ( sw . toString ( ) ) ) ; } public String encode ( String value ) { final StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < value . length ( ) ; i ++ ) { final char c = value . charAt ( i ) ; switch ( c ) { case '<' : sb . append ( "&lt;" ) ; break ; case '>' : sb . append ( "&gt;" ) ; break ; case '\'' : sb . append ( "&apos;" ) ; break ; case '\"' : sb . append ( "&quot;" ) ; break ; case '&' : final int nextSemi = value . indexOf ( ';' , i ) ; if ( nextSemi < 0 || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) { sb . append ( "&amp;" ) ; } else { sb . append ( '&' ) ; } break ; default : sb . append ( c ) ; break ; } } return sb . toString ( ) ; } public boolean isReference ( String ent ) { if ( ent . charAt ( 0 ) != '&' || ! Utils . endsWithChar ( ent , ';' ) ) { return false ; } if ( ent . charAt ( 1 ) == '#' ) { int prefixLength = 2 ; int radix = BASE_10 ; if ( ent . charAt ( 2 ) == 'x' ) { prefixLength ++ ; radix = BASE_16 ; } try { Integer . parseInt ( ent . substring ( prefixLength , ent . length ( ) - 1 ) , radix ) ; return true ; } catch ( final NumberFormatException nfe ) { return false ; } } final String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( String element : ENTITIES ) { if ( name . equals ( element ) ) { return true ; } } return false ; } }
package com . puppycrawl . tools . checkstyle ;
package com . puppycrawl . tools . checkstyle ; import java . io . File ; import java . io . Reader ; import java . io . StringReader ; import java . util . AbstractMap . SimpleEntry ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Map . Entry ; import java . util . Set ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import antlr . CommonHiddenStreamToken ; import antlr . RecognitionException ; import antlr . Token ; import antlr . TokenStreamException ; import antlr . TokenStreamHiddenTokenFilter ; import antlr . TokenStreamRecognitionException ; import com . google . common . collect . HashMultimap ; import com . google . common . collect . Multimap ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . AbstractFileSetCheck ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . api . Context ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FileContents ; import com . puppycrawl . tools . checkstyle . api . FileText ; import com . puppycrawl . tools . checkstyle . api . LocalizedMessage ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . grammars . GeneratedJavaLexer ; import com . puppycrawl . tools . checkstyle . grammars . GeneratedJavaRecognizer ; public final class TreeWalker extends AbstractFileSetCheck { private static enum AstState { ORDINARY , WITH_COMMENTS } private static final int DEFAULT_TAB_WIDTH = 8 ; private static final Log LOG = LogFactory . getLog ( TreeWalker . class ) ; private final Multimap < String , Check > tokenToOrdinaryChecks = HashMultimap . create ( ) ; private final Multimap < String , Check > tokenToCommentChecks = HashMultimap . create ( ) ; private final Set < Check > ordinaryChecks = Sets . newHashSet ( ) ; private final Set < Check > commentChecks = Sets . newHashSet ( ) ; private int tabWidth = DEFAULT_TAB_WIDTH ; private PropertyCacheFile cache = new PropertyCacheFile ( null , null ) ; private ClassLoader classLoader ; private Context childContext ; private ModuleFactory moduleFactory ; public TreeWalker ( ) { setFileExtensions ( "java" ) ; } public void setTabWidth ( int tabWidth ) { this . tabWidth = tabWidth ; } public void setCacheFile ( String fileName ) { final Configuration configuration = getConfiguration ( ) ; cache = new PropertyCacheFile ( configuration , fileName ) ; } public void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } public void setModuleFactory ( ModuleFactory moduleFactory ) { this . moduleFactory = moduleFactory ; } @ Override public void finishLocalSetup ( ) { final DefaultContext checkContext = new DefaultContext ( ) ; checkContext . add ( "classLoader" , classLoader ) ; checkContext . add ( "messages" , getMessageCollector ( ) ) ; checkContext . add ( "severity" , getSeverity ( ) ) ; checkContext . add ( "tabWidth" , String . valueOf ( tabWidth ) ) ; childContext = checkContext ; } @ Override public void setupChild ( Configuration childConf ) throws CheckstyleException { final String name = childConf . getName ( ) ; final Object module = moduleFactory . createModule ( name ) ; if ( ! ( module instanceof Check ) ) { throw new CheckstyleException ( "TreeWalker is not allowed as a parent of " + name ) ; } final Check c = ( Check ) module ; c . contextualize ( childContext ) ; c . configure ( childConf ) ; c . init ( ) ; registerCheck ( c ) ; } @ Override protected void processFiltered ( File file , List < String > lines ) { final String fileName = file . getPath ( ) ; final long timestamp = file . lastModified ( ) ; if ( cache . alreadyChecked ( fileName , timestamp ) || ! Utils . fileExtensionMatches ( file , getFileExtensions ( ) ) ) { return ; } final String msg = "%s occurred during the analysis of file %s." ; try { final FileText text = FileText . fromLines ( file , lines ) ; final FileContents contents = new FileContents ( text ) ; final DetailAST rootAST = TreeWalker . parse ( contents ) ; getMessageCollector ( ) . reset ( ) ; walk ( rootAST , contents , AstState . ORDINARY ) ; final DetailAST astWithComments = appendHiddenCommentNodes ( rootAST ) ; walk ( astWithComments , contents , AstState . WITH_COMMENTS ) ; } catch ( final TokenStreamRecognitionException tre ) { final String exceptionMsg = String . format ( msg , "TokenStreamRecognitionException" , fileName ) ; LOG . error ( exceptionMsg ) ; final RecognitionException re = tre . recog ; String message = "TokenStreamRecognitionException occured" ; if ( re != null ) { message = re . getMessage ( ) ; } getMessageCollector ( ) . add ( createLocalizedMessage ( message ) ) ; } catch ( Throwable ex ) { final String exceptionMsg = String . format ( msg , ex . getClass ( ) . getSimpleName ( ) , fileName ) ; LOG . error ( exceptionMsg , ex ) ; getMessageCollector ( ) . add ( createLocalizedMessage ( ex . getMessage ( ) ) ) ; } if ( getMessageCollector ( ) . size ( ) == 0 ) { cache . checkedOk ( fileName , timestamp ) ; } } private LocalizedMessage createLocalizedMessage ( String message ) { return new LocalizedMessage ( 0 , Definitions . CHECKSTYLE_BUNDLE , "general.exception" , new String [ ] { message } , getId ( ) , this . getClass ( ) , null ) ; } private void registerCheck ( Check check ) throws CheckstyleException { final int [ ] tokens ; final Set < String > checkTokens = check . getTokenNames ( ) ; if ( ! checkTokens . isEmpty ( ) ) { tokens = check . getRequiredTokens ( ) ; final int [ ] acceptableTokens = check . getAcceptableTokens ( ) ; Arrays . sort ( acceptableTokens ) ; for ( String token : checkTokens ) { final int tokenId = Utils . getTokenId ( token ) ; if ( Arrays . binarySearch ( acceptableTokens , tokenId ) >= 0 ) { registerCheck ( token , check ) ; } else { throw new CheckstyleException ( "Token \"" + token + "\" was not found in Acceptable tokens list" + " in check " + check ) ; } } } else { tokens = check . getDefaultTokens ( ) ; } for ( int element : tokens ) { registerCheck ( element , check ) ; } if ( check . isCommentNodesRequired ( ) ) { commentChecks . add ( check ) ; } else { ordinaryChecks . add ( check ) ; } } private void registerCheck ( int tokenID , Check check ) { registerCheck ( Utils . getTokenName ( tokenID ) , check ) ; } private void registerCheck ( String token , Check check ) { if ( check . isCommentNodesRequired ( ) ) { tokenToCommentChecks . put ( token , check ) ; } else if ( Utils . isCommentType ( token ) ) { final String message = String . format ( "Check '%s' waits for comment type " + "token ('%s') and should override 'isCommentNodesRequred()' " + "method to return 'true'" , check . getClass ( ) . getName ( ) , token ) ; LOG . warn ( message ) ; } else { tokenToOrdinaryChecks . put ( token , check ) ; } } private void walk ( DetailAST ast , FileContents contents , AstState astState ) { notifyBegin ( ast , contents , astState ) ; if ( ast != null ) { processIter ( ast , astState ) ; } notifyEnd ( ast , astState ) ; } private void notifyBegin ( DetailAST rootAST , FileContents contents , AstState astState ) { Set < Check > checks ; if ( astState == AstState . WITH_COMMENTS ) { checks = commentChecks ; } else { checks = ordinaryChecks ; } for ( Check ch : checks ) { ch . setFileContents ( contents ) ; ch . beginTree ( rootAST ) ; } } private void notifyEnd ( DetailAST rootAST , AstState astState ) { Set < Check > checks ; if ( astState == AstState . WITH_COMMENTS ) { checks = commentChecks ; } else { checks = ordinaryChecks ; } for ( Check ch : checks ) { ch . finishTree ( rootAST ) ; } } private void notifyVisit ( DetailAST ast , AstState astState ) { Collection < Check > visitors ; final String tokenType = Utils . getTokenName ( ast . getType ( ) ) ; if ( astState == AstState . WITH_COMMENTS ) { if ( ! tokenToCommentChecks . containsKey ( tokenType ) ) { return ; } visitors = tokenToCommentChecks . get ( tokenType ) ; } else { if ( ! tokenToOrdinaryChecks . containsKey ( tokenType ) ) { return ; } visitors = tokenToOrdinaryChecks . get ( tokenType ) ; } for ( Check c : visitors ) { c . visitToken ( ast ) ; } } private void notifyLeave ( DetailAST ast , AstState astState ) { Collection < Check > visitors ; final String tokenType = Utils . getTokenName ( ast . getType ( ) ) ; if ( astState == AstState . WITH_COMMENTS ) { if ( ! tokenToCommentChecks . containsKey ( tokenType ) ) { return ; } visitors = tokenToCommentChecks . get ( tokenType ) ; } else { if ( ! tokenToOrdinaryChecks . containsKey ( tokenType ) ) { return ; } visitors = tokenToOrdinaryChecks . get ( tokenType ) ; } for ( Check ch : visitors ) { ch . leaveToken ( ast ) ; } } public static DetailAST parse ( FileContents contents ) throws RecognitionException , TokenStreamException { final String fullText = contents . getText ( ) . getFullText ( ) . toString ( ) ; final Reader sr = new StringReader ( fullText ) ; final GeneratedJavaLexer lexer = new GeneratedJavaLexer ( sr ) ; lexer . setFilename ( contents . getFileName ( ) ) ; lexer . setCommentListener ( contents ) ; lexer . setTreatAssertAsKeyword ( true ) ; lexer . setTreatEnumAsKeyword ( true ) ; lexer . setTokenObjectClass ( "antlr.CommonHiddenStreamToken" ) ; final TokenStreamHiddenTokenFilter filter = new TokenStreamHiddenTokenFilter ( lexer ) ; filter . hide ( TokenTypes . SINGLE_LINE_COMMENT ) ; filter . hide ( TokenTypes . BLOCK_COMMENT_BEGIN ) ; final GeneratedJavaRecognizer parser = new GeneratedJavaRecognizer ( filter ) ; parser . setFilename ( contents . getFileName ( ) ) ; parser . setASTNodeClass ( DetailAST . class . getName ( ) ) ; parser . compilationUnit ( ) ; return ( DetailAST ) parser . getAST ( ) ; } @ Override public void destroy ( ) { for ( Check c : ordinaryChecks ) { c . destroy ( ) ; } for ( Check c : commentChecks ) { c . destroy ( ) ; } cache . destroy ( ) ; super . destroy ( ) ; } private void processIter ( DetailAST root , AstState astState ) { DetailAST curNode = root ; while ( curNode != null ) { notifyVisit ( curNode , astState ) ; DetailAST toVisit = curNode . getFirstChild ( ) ; while ( curNode != null && toVisit == null ) { notifyLeave ( curNode , astState ) ; toVisit = curNode . getNextSibling ( ) ; if ( toVisit == null ) { curNode = curNode . getParent ( ) ; } } curNode = toVisit ; } } private static DetailAST appendHiddenCommentNodes ( DetailAST root ) { DetailAST result = root ; DetailAST curNode = root ; DetailAST lastNode = root ; while ( curNode != null ) { if ( isPositionGreater ( curNode , lastNode ) ) { lastNode = curNode ; } CommonHiddenStreamToken tokenBefore = curNode . getHiddenBefore ( ) ; DetailAST currentSibling = curNode ; while ( tokenBefore != null ) { final DetailAST newCommentNode = createCommentAstFromToken ( tokenBefore ) ; currentSibling . addPreviousSibling ( newCommentNode ) ; if ( currentSibling == result ) { result = newCommentNode ; } currentSibling = newCommentNode ; tokenBefore = tokenBefore . getHiddenBefore ( ) ; } DetailAST toVisit = curNode . getFirstChild ( ) ; while ( curNode != null && toVisit == null ) { toVisit = curNode . getNextSibling ( ) ; if ( toVisit == null ) { curNode = curNode . getParent ( ) ; } } curNode = toVisit ; } if ( lastNode != null ) { CommonHiddenStreamToken tokenAfter = lastNode . getHiddenAfter ( ) ; DetailAST currentSibling = lastNode ; while ( tokenAfter != null ) { final DetailAST newCommentNode = createCommentAstFromToken ( tokenAfter ) ; currentSibling . addNextSibling ( newCommentNode ) ; currentSibling = newCommentNode ; tokenAfter = tokenAfter . getHiddenAfter ( ) ; } } return result ; } private static boolean isPositionGreater ( DetailAST ast1 , DetailAST ast2 ) { if ( ast1 . getLineNo ( ) > ast2 . getLineNo ( ) ) { return true ; } else if ( ast1 . getLineNo ( ) < ast2 . getLineNo ( ) ) { return false ; } else { if ( ast1 . getColumnNo ( ) > ast2 . getColumnNo ( ) ) { return true ; } } return false ; } private static DetailAST createCommentAstFromToken ( Token token ) { switch ( token . getType ( ) ) { case TokenTypes . SINGLE_LINE_COMMENT : return createSlCommentNode ( token ) ; case TokenTypes . BLOCK_COMMENT_BEGIN : return createBlockCommentNode ( token ) ; default : throw new IllegalArgumentException ( "Unknown comment type" ) ; } } private static DetailAST createSlCommentNode ( Token token ) { final DetailAST slComment = new DetailAST ( ) ; slComment . setType ( TokenTypes . SINGLE_LINE_COMMENT ) ; slComment . setText ( "//" ) ; slComment . setColumnNo ( token . getColumn ( ) - 1 ) ; slComment . setLineNo ( token . getLine ( ) ) ; final DetailAST slCommentContent = new DetailAST ( ) ; slCommentContent . initialize ( token ) ; slCommentContent . setType ( TokenTypes . COMMENT_CONTENT ) ; slCommentContent . setColumnNo ( token . getColumn ( ) - 1 + 2 ) ; slCommentContent . setLineNo ( token . getLine ( ) ) ; slCommentContent . setText ( token . getText ( ) ) ; slComment . addChild ( slCommentContent ) ; return slComment ; } private static DetailAST createBlockCommentNode ( Token token ) { final DetailAST blockComment = new DetailAST ( ) ; blockComment . initialize ( TokenTypes . BLOCK_COMMENT_BEGIN , "/*" ) ; blockComment . setColumnNo ( token . getColumn ( ) - 1 ) ; blockComment . setLineNo ( token . getLine ( ) ) ; final DetailAST blockCommentContent = new DetailAST ( ) ; blockCommentContent . initialize ( token ) ; blockCommentContent . setType ( TokenTypes . COMMENT_CONTENT ) ; blockCommentContent . setColumnNo ( token . getColumn ( ) - 1 + 2 ) ; blockCommentContent . setLineNo ( token . getLine ( ) ) ; blockCommentContent . setText ( token . getText ( ) ) ; final DetailAST blockCommentClose = new DetailAST ( ) ; blockCommentClose . initialize ( TokenTypes . BLOCK_COMMENT_END , "*/" ) ; final Entry < Integer , Integer > linesColumns = countLinesColumns ( token . getText ( ) , token . getLine ( ) , token . getColumn ( ) ) ; blockCommentClose . setLineNo ( linesColumns . getKey ( ) ) ; blockCommentClose . setColumnNo ( linesColumns . getValue ( ) ) ; blockComment . addChild ( blockCommentContent ) ; blockComment . addChild ( blockCommentClose ) ; return blockComment ; } private static Entry < Integer , Integer > countLinesColumns ( String text , int initialLinesCnt , int initialColumnsCnt ) { int lines = initialLinesCnt ; int columns = initialColumnsCnt ; for ( char c : text . toCharArray ( ) ) { if ( c == '\n' ) { lines ++ ; columns = 0 ; } else { columns ++ ; } } return new SimpleEntry < > ( lines , columns ) ; } }
package com . puppycrawl . tools . checkstyle ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; public interface PropertyResolver { String resolve ( String name ) throws CheckstyleException ; }
package com . puppycrawl . tools . checkstyle ; import com . google . common . collect . Sets ; import com . google . common . io . Closeables ; import com . puppycrawl . tools . checkstyle . api . AbstractLoader ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . Set ; import javax . xml . parsers . ParserConfigurationException ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public final class PackageNamesLoader extends AbstractLoader { private static final String DTD_PUBLIC_ID = "-//Puppy Crawl//DTD Package Names 1.0//EN" ; private static final String DTD_RESOURCE_NAME = "com/puppycrawl/tools/checkstyle/packages_1_0.dtd" ; private static final String CHECKSTYLE_PACKAGES = "checkstyle_packages.xml" ; private final Deque < String > packageStack = new ArrayDeque < > ( ) ; private final Set < String > packageNames = Sets . newLinkedHashSet ( ) ; private PackageNamesLoader ( ) throws ParserConfigurationException , SAXException { super ( DTD_PUBLIC_ID , DTD_RESOURCE_NAME ) ; } private Set < String > getPackageNames ( ) { return packageNames ; } @ Override public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws SAXException { if ( "package" . equals ( qName ) ) { final String name = atts . getValue ( "name" ) ; if ( name == null ) { throw new SAXException ( "missing package name" ) ; } packageStack . push ( name ) ; } } private String getPackageName ( ) { final StringBuilder buf = new StringBuilder ( ) ; final Iterator < String > iterator = packageStack . descendingIterator ( ) ; while ( iterator . hasNext ( ) ) { final String subPackage = iterator . next ( ) ; buf . append ( subPackage ) ; if ( ! Utils . endsWithChar ( subPackage , '.' ) ) { buf . append ( '.' ) ; } } return buf . toString ( ) ; } @ Override public void endElement ( String namespaceURI , String localName , String qName ) { if ( "package" . equals ( qName ) ) { packageNames . add ( getPackageName ( ) ) ; packageStack . pop ( ) ; } } public static Set < String > getPackageNames ( ClassLoader classLoader ) throws CheckstyleException { Enumeration < URL > packageFiles = null ; try { packageFiles = classLoader . getResources ( CHECKSTYLE_PACKAGES ) ; } catch ( IOException e ) { throw new CheckstyleException ( "unable to get package file resources" , e ) ; } final PackageNamesLoader namesLoader = newPackageNamesLoader ( ) ; while ( packageFiles . hasMoreElements ( ) ) { final URL packageFile = packageFiles . nextElement ( ) ; InputStream stream = null ; try { stream = new BufferedInputStream ( packageFile . openStream ( ) ) ; final InputSource source = new InputSource ( stream ) ; loadPackageNamesSource ( source , "default package names" , namesLoader ) ; } catch ( IOException e ) { throw new CheckstyleException ( "unable to open " + packageFile , e ) ; } finally { Closeables . closeQuietly ( stream ) ; } } return namesLoader . getPackageNames ( ) ; } private static PackageNamesLoader newPackageNamesLoader ( ) throws CheckstyleException { try { return new PackageNamesLoader ( ) ; } catch ( final ParserConfigurationException | SAXException e ) { throw new CheckstyleException ( "unable to create PackageNamesLoader - " + e . getMessage ( ) , e ) ; } } private static void loadPackageNamesSource ( InputSource source , String sourceName , PackageNamesLoader nameLoader ) throws CheckstyleException { try { nameLoader . parseInputSource ( source ) ; } catch ( final SAXException | IOException e ) { throw new CheckstyleException ( "Unable to parse " + sourceName + " - " + e . getMessage ( ) , e ) ; } } }
package com . puppycrawl . tools . checkstyle ; import antlr . collections . AST ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . Scope ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public final class ScopeUtils { private ScopeUtils ( ) { } public static Scope getScopeFromMods ( DetailAST aMods ) { Scope retVal = Scope . PACKAGE ; for ( AST token = aMods . getFirstChild ( ) ; token != null ; token = token . getNextSibling ( ) ) { if ( "public" . equals ( token . getText ( ) ) ) { retVal = Scope . PUBLIC ; break ; } else if ( "protected" . equals ( token . getText ( ) ) ) { retVal = Scope . PROTECTED ; break ; } else if ( "private" . equals ( token . getText ( ) ) ) { retVal = Scope . PRIVATE ; break ; } } return retVal ; } public static Scope getSurroundingScope ( DetailAST aAST ) { Scope retVal = null ; for ( DetailAST token = aAST . getParent ( ) ; token != null ; token = token . getParent ( ) ) { final int type = token . getType ( ) ; if ( type == TokenTypes . CLASS_DEF || type == TokenTypes . INTERFACE_DEF || type == TokenTypes . ANNOTATION_DEF || type == TokenTypes . ENUM_DEF ) { final DetailAST mods = token . findFirstToken ( TokenTypes . MODIFIERS ) ; final Scope modScope = ScopeUtils . getScopeFromMods ( mods ) ; if ( retVal == null || retVal . isIn ( modScope ) ) { retVal = modScope ; } } else if ( type == TokenTypes . LITERAL_NEW ) { retVal = Scope . ANONINNER ; break ; } } return retVal ; } public static boolean inInterfaceBlock ( DetailAST aAST ) { boolean retVal = false ; for ( DetailAST token = aAST . getParent ( ) ; token != null ; token = token . getParent ( ) ) { final int type = token . getType ( ) ; if ( type == TokenTypes . CLASS_DEF || type == TokenTypes . ENUM_DEF || type == TokenTypes . ANNOTATION_DEF ) { break ; } else if ( type == TokenTypes . LITERAL_NEW ) { break ; } else if ( type == TokenTypes . INTERFACE_DEF ) { retVal = true ; break ; } } return retVal ; } public static boolean inAnnotationBlock ( DetailAST aAST ) { boolean retVal = false ; for ( DetailAST token = aAST . getParent ( ) ; token != null ; token = token . getParent ( ) ) { final int type = token . getType ( ) ; if ( type == TokenTypes . CLASS_DEF || type == TokenTypes . ENUM_DEF || type == TokenTypes . INTERFACE_DEF ) { break ; } else if ( type == TokenTypes . LITERAL_NEW ) { break ; } else if ( type == TokenTypes . ANNOTATION_DEF ) { retVal = true ; break ; } } return retVal ; } public static boolean inInterfaceOrAnnotationBlock ( DetailAST aAST ) { return inInterfaceBlock ( aAST ) || inAnnotationBlock ( aAST ) ; } public static boolean inEnumBlock ( DetailAST aAST ) { boolean retVal = false ; for ( DetailAST token = aAST . getParent ( ) ; token != null ; token = token . getParent ( ) ) { final int type = token . getType ( ) ; if ( type == TokenTypes . INTERFACE_DEF || type == TokenTypes . ANNOTATION_DEF || type == TokenTypes . CLASS_DEF ) { break ; } else if ( type == TokenTypes . LITERAL_NEW ) { break ; } else if ( type == TokenTypes . ENUM_DEF ) { retVal = true ; break ; } } return retVal ; } public static boolean inCodeBlock ( DetailAST aAST ) { boolean retVal = false ; for ( DetailAST token = aAST . getParent ( ) ; token != null ; token = token . getParent ( ) ) { final int type = token . getType ( ) ; if ( type == TokenTypes . METHOD_DEF || type == TokenTypes . CTOR_DEF || type == TokenTypes . INSTANCE_INIT || type == TokenTypes . STATIC_INIT ) { retVal = true ; break ; } } return retVal ; } public static boolean isOuterMostType ( DetailAST aAST ) { boolean retVal = true ; for ( DetailAST parent = aAST . getParent ( ) ; parent != null ; parent = parent . getParent ( ) ) { if ( parent . getType ( ) == TokenTypes . CLASS_DEF || parent . getType ( ) == TokenTypes . INTERFACE_DEF || parent . getType ( ) == TokenTypes . ANNOTATION_DEF || parent . getType ( ) == TokenTypes . ENUM_DEF ) { retVal = false ; break ; } } return retVal ; } public static boolean isLocalVariableDef ( DetailAST aAST ) { if ( aAST . getType ( ) == TokenTypes . VARIABLE_DEF ) { final DetailAST parent = aAST . getParent ( ) ; if ( parent != null ) { final int type = parent . getType ( ) ; return type == TokenTypes . SLIST || type == TokenTypes . FOR_INIT || type == TokenTypes . FOR_EACH_CLAUSE ; } } else if ( aAST . getType ( ) == TokenTypes . PARAMETER_DEF ) { final DetailAST parent = aAST . getParent ( ) ; if ( parent != null ) { return parent . getType ( ) == TokenTypes . LITERAL_CATCH ; } } return false ; } }
package com . puppycrawl . tools . checkstyle ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . AuditListener ; import com . puppycrawl . tools . checkstyle . api . AutomaticBean ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . api . Context ; import com . puppycrawl . tools . checkstyle . api . FileSetCheck ; import com . puppycrawl . tools . checkstyle . api . FileText ; import com . puppycrawl . tools . checkstyle . api . Filter ; import com . puppycrawl . tools . checkstyle . api . FilterSet ; import com . puppycrawl . tools . checkstyle . api . LocalizedMessage ; import com . puppycrawl . tools . checkstyle . api . MessageDispatcher ; import com . puppycrawl . tools . checkstyle . api . SeverityLevel ; import com . puppycrawl . tools . checkstyle . api . SeverityLevelCounter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . nio . charset . Charset ; import java . util . List ; import java . util . Locale ; import java . util . Set ; import java . util . SortedSet ; public class Checker extends AutomaticBean implements MessageDispatcher { private static final Log LOG = LogFactory . getLog ( Checker . class ) ; private final SeverityLevelCounter counter = new SeverityLevelCounter ( SeverityLevel . ERROR ) ; private final List < AuditListener > listeners = Lists . newArrayList ( ) ; private final List < FileSetCheck > fileSetChecks = Lists . newArrayList ( ) ; private ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; private String basedir ; private String localeCountry = Locale . getDefault ( ) . getCountry ( ) ; private String localeLanguage = Locale . getDefault ( ) . getLanguage ( ) ; private ModuleFactory moduleFactory ; private ClassLoader moduleClassLoader ; private Context childContext ; private final FilterSet filters = new FilterSet ( ) ; private String [ ] fileExtensions = { } ; private SeverityLevel severityLevel = SeverityLevel . ERROR ; private String charset = System . getProperty ( "file.encoding" , "UTF-8" ) ; public Checker ( ) throws CheckstyleException { addListener ( counter ) ; } @ Override public void finishLocalSetup ( ) throws CheckstyleException { final Locale locale = new Locale ( localeLanguage , localeCountry ) ; LocalizedMessage . setLocale ( locale ) ; if ( moduleFactory == null ) { if ( moduleClassLoader == null ) { throw new CheckstyleException ( "if no custom moduleFactory is set, " + "moduleClassLoader must be specified" ) ; } final Set < String > packageNames = PackageNamesLoader . getPackageNames ( moduleClassLoader ) ; moduleFactory = new PackageObjectFactory ( packageNames , moduleClassLoader ) ; } final DefaultContext context = new DefaultContext ( ) ; context . add ( "charset" , charset ) ; context . add ( "classLoader" , loader ) ; context . add ( "moduleFactory" , moduleFactory ) ; context . add ( "severity" , severityLevel . getName ( ) ) ; context . add ( "basedir" , basedir ) ; childContext = context ; } @ Override protected void setupChild ( Configuration childConf ) throws CheckstyleException { final String name = childConf . getName ( ) ; try { final Object child = moduleFactory . createModule ( name ) ; if ( child instanceof AutomaticBean ) { final AutomaticBean bean = ( AutomaticBean ) child ; bean . contextualize ( childContext ) ; bean . configure ( childConf ) ; } if ( child instanceof FileSetCheck ) { final FileSetCheck fsc = ( FileSetCheck ) child ; addFileSetCheck ( fsc ) ; } else if ( child instanceof Filter ) { final Filter filter = ( Filter ) child ; addFilter ( filter ) ; } else if ( child instanceof AuditListener ) { final AuditListener listener = ( AuditListener ) child ; addListener ( listener ) ; } else { throw new CheckstyleException ( name + " is not allowed as a child in Checker" ) ; } } catch ( final Exception ex ) { throw new CheckstyleException ( "cannot initialize module " + name + " - " + ex . getMessage ( ) , ex ) ; } } public void addFileSetCheck ( FileSetCheck fileSetCheck ) { fileSetCheck . setMessageDispatcher ( this ) ; fileSetChecks . add ( fileSetCheck ) ; } public void addFilter ( Filter filter ) { filters . addFilter ( filter ) ; } public void removeFilter ( Filter filter ) { filters . removeFilter ( filter ) ; } public void destroy ( ) { listeners . clear ( ) ; filters . clear ( ) ; } public final void addListener ( AuditListener listener ) { listeners . add ( listener ) ; } public void removeListener ( AuditListener listener ) { listeners . remove ( listener ) ; } public int process ( List < File > files ) { fireAuditStarted ( ) ; for ( final FileSetCheck fsc : fileSetChecks ) { fsc . beginProcessing ( charset ) ; } for ( final File f : files ) { if ( ! Utils . fileExtensionMatches ( f , fileExtensions ) ) { continue ; } final String fileName = f . getAbsolutePath ( ) ; fireFileStarted ( fileName ) ; final SortedSet < LocalizedMessage > fileMessages = Sets . newTreeSet ( ) ; try { final FileText theText = new FileText ( f . getAbsoluteFile ( ) , charset ) ; for ( final FileSetCheck fsc : fileSetChecks ) { fileMessages . addAll ( fsc . process ( f , theText ) ) ; } } catch ( final FileNotFoundException fnfe ) { LOG . debug ( "FileNotFoundException occured." , fnfe ) ; fileMessages . add ( new LocalizedMessage ( 0 , Definitions . CHECKSTYLE_BUNDLE , "general.fileNotFound" , null , null , this . getClass ( ) , null ) ) ; } catch ( final IOException ioe ) { LOG . debug ( "IOException occured." , ioe ) ; fileMessages . add ( new LocalizedMessage ( 0 , Definitions . CHECKSTYLE_BUNDLE , "general.exception" , new String [ ] { ioe . getMessage ( ) } , null , this . getClass ( ) , null ) ) ; } fireErrors ( fileName , fileMessages ) ; fireFileFinished ( fileName ) ; } for ( final FileSetCheck fsc : fileSetChecks ) { fsc . finishProcessing ( ) ; } for ( final FileSetCheck fsc : fileSetChecks ) { fsc . destroy ( ) ; } final int errorCount = counter . getCount ( ) ; fireAuditFinished ( ) ; return errorCount ; } public void setBasedir ( String basedir ) { this . basedir = basedir ; } protected void fireAuditStarted ( ) { final AuditEvent evt = new AuditEvent ( this ) ; for ( final AuditListener listener : listeners ) { listener . auditStarted ( evt ) ; } } protected void fireAuditFinished ( ) { final AuditEvent evt = new AuditEvent ( this ) ; for ( final AuditListener listener : listeners ) { listener . auditFinished ( evt ) ; } } @ Override public void fireFileStarted ( String fileName ) { final String stripped = Utils . relativizeAndNormalizePath ( basedir , fileName ) ; final AuditEvent evt = new AuditEvent ( this , stripped ) ; for ( final AuditListener listener : listeners ) { listener . fileStarted ( evt ) ; } } @ Override public void fireFileFinished ( String fileName ) { final String stripped = Utils . relativizeAndNormalizePath ( basedir , fileName ) ; final AuditEvent evt = new AuditEvent ( this , stripped ) ; for ( final AuditListener listener : listeners ) { listener . fileFinished ( evt ) ; } } @ Override public void fireErrors ( String fileName , SortedSet < LocalizedMessage > errors ) { final String stripped = Utils . relativizeAndNormalizePath ( basedir , fileName ) ; for ( final LocalizedMessage element : errors ) { final AuditEvent evt = new AuditEvent ( this , stripped , element ) ; if ( filters . accept ( evt ) ) { for ( final AuditListener listener : listeners ) { listener . addError ( evt ) ; } } } } public final void setFileExtensions ( String ... extensions ) { if ( extensions == null ) { fileExtensions = null ; return ; } fileExtensions = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { final String extension = extensions [ i ] ; if ( Utils . startsWithChar ( extension , '.' ) ) { fileExtensions [ i ] = extension ; } else { fileExtensions [ i ] = "." + extension ; } } } public void setModuleFactory ( ModuleFactory moduleFactory ) { this . moduleFactory = moduleFactory ; } public void setLocaleCountry ( String localeCountry ) { this . localeCountry = localeCountry ; } public void setLocaleLanguage ( String localeLanguage ) { this . localeLanguage = localeLanguage ; } public final void setSeverity ( String severity ) { severityLevel = SeverityLevel . getInstance ( severity ) ; } public final void setClassLoader ( ClassLoader loader ) { this . loader = loader ; } @ Deprecated public final void setClassloader ( ClassLoader loader ) { setClassLoader ( loader ) ; } public final void setModuleClassLoader ( ClassLoader moduleClassLoader ) { this . moduleClassLoader = moduleClassLoader ; } public void setCharset ( String charset ) throws UnsupportedEncodingException { if ( ! Charset . isSupported ( charset ) ) { final String message = "unsupported charset: '" + charset + "'" ; throw new UnsupportedEncodingException ( message ) ; } this . charset = charset ; } }
package com . puppycrawl . tools . checkstyle ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableCollection ; import com . google . common . collect . Maps ; import com . puppycrawl . tools . checkstyle . api . Context ; import java . util . Map ; public final class DefaultContext implements Context { private final Map < String , Object > entries = Maps . newHashMap ( ) ; @ Override public Object get ( String key ) { return entries . get ( key ) ; } @ Override public ImmutableCollection < String > getAttributeNames ( ) { return ImmutableList . copyOf ( entries . keySet ( ) ) ; } public void add ( String key , Object value ) { entries . put ( key , value ) ; } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . NewlineAtEndOfFileCheck . MSG_KEY_NO_NEWLINE_EOF ; public class NewlineAtEndOfFileCheckTest extends BaseCheckTestSupport { @ Override protected DefaultConfiguration createCheckerConfig ( Configuration checkConfig ) { final DefaultConfiguration dc = new DefaultConfiguration ( "root" ) ; dc . addChild ( checkConfig ) ; return dc ; } @ Test public void testNewlineLfAtEndOfFile ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NewlineAtEndOfFileCheck . class ) ; checkConfig . addAttribute ( "lineSeparator" , LineSeparatorOption . LF . toString ( ) ) ; final String [ ] expected = { } ; verify ( createChecker ( checkConfig ) , getPath ( "InputNewlineLfAtEndOfFile.java" ) , expected ) ; } @ Test public void testNewlineCrlfAtEndOfFile ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NewlineAtEndOfFileCheck . class ) ; checkConfig . addAttribute ( "lineSeparator" , LineSeparatorOption . CRLF . toString ( ) ) ; final String [ ] expected = { } ; verify ( createChecker ( checkConfig ) , getPath ( "InputNewlineCrlfAtEndOfFile.java" ) , expected ) ; } @ Test public void testNewlineCrAtEndOfFile ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NewlineAtEndOfFileCheck . class ) ; checkConfig . addAttribute ( "lineSeparator" , LineSeparatorOption . CR . toString ( ) ) ; final String [ ] expected = { } ; verify ( createChecker ( checkConfig ) , getPath ( "InputNewlineCrAtEndOfFile.java" ) , expected ) ; } @ Test public void testAnyNewlineAtEndOfFile ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NewlineAtEndOfFileCheck . class ) ; checkConfig . addAttribute ( "lineSeparator" , LineSeparatorOption . LF_CR_CRLF . toString ( ) ) ; final String [ ] expected = { } ; verify ( createChecker ( checkConfig ) , getPath ( "InputNewlineCrlfAtEndOfFile.java" ) , expected ) ; verify ( createChecker ( checkConfig ) , getPath ( "InputNewlineLfAtEndOfFile.java" ) , expected ) ; verify ( createChecker ( checkConfig ) , getPath ( "InputNewlineCrAtEndOfFile.java" ) , expected ) ; } @ Test public void testNoNewlineLfAtEndOfFile ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NewlineAtEndOfFileCheck . class ) ; checkConfig . addAttribute ( "lineSeparator" , LineSeparatorOption . LF . toString ( ) ) ; final String [ ] expected = { "0: " + getCheckMessage ( MSG_KEY_NO_NEWLINE_EOF ) , } ; verify ( createChecker ( checkConfig ) , getPath ( "InputNoNewlineAtEndOfFile.java" ) , expected ) ; } @ Test public void testNoNewlineAtEndOfFile ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NewlineAtEndOfFileCheck . class ) ; checkConfig . addAttribute ( "lineSeparator" , LineSeparatorOption . LF_CR_CRLF . toString ( ) ) ; final String [ ] expected = { "0: " + getCheckMessage ( MSG_KEY_NO_NEWLINE_EOF ) , } ; verify ( createChecker ( checkConfig ) , getPath ( "InputNoNewlineAtEndOfFile.java" ) , expected ) ; } @ Test ( expected = CheckstyleException . class ) public void testSetLineSeparatorFailure ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NewlineAtEndOfFileCheck . class ) ; checkConfig . addAttribute ( "lineSeparator" , "ct" ) ; createChecker ( checkConfig ) ; } @ Test public void testEmptyFileFile ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NewlineAtEndOfFileCheck . class ) ; checkConfig . addAttribute ( "lineSeparator" , LineSeparatorOption . LF . toString ( ) ) ; final String [ ] expected = { "0: " + getCheckMessage ( MSG_KEY_NO_NEWLINE_EOF ) , } ; verify ( createChecker ( checkConfig ) , getPath ( "InputEmptyFile.txt" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; public interface ModuleFactory { Object createModule ( String name ) throws CheckstyleException ; }
package com . puppycrawl . tools . checkstyle ; public final class Definitions { public static final String CHECKSTYLE_BUNDLE = "com.puppycrawl.tools.checkstyle.messages" ; private Definitions ( ) { } }
package com . puppycrawl . tools . checkstyle ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . api . AuditListener ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . util . ArrayList ; import java . util . List ; import java . util . Properties ; import org . apache . commons . cli . CommandLine ; import org . apache . commons . cli . CommandLineParser ; import org . apache . commons . cli . DefaultParser ; import org . apache . commons . cli . HelpFormatter ; import org . apache . commons . cli . Options ; import org . apache . commons . cli . ParseException ; public final class Main { private Main ( ) { } public static void main ( String ... args ) throws UnsupportedEncodingException , FileNotFoundException { int errorCounter = 0 ; boolean cliViolations = false ; final int exitWithCliViolation = - 1 ; final int exitWithCheckstyleException = - 2 ; int exitStatus = 0 ; try { final CommandLine commandLine = parseCli ( args ) ; if ( commandLine . hasOption ( "v" ) ) { System . out . println ( "Checkstyle version: " + Main . class . getPackage ( ) . getImplementationVersion ( ) ) ; exitStatus = 0 ; } else { final List < String > messages = validateCli ( commandLine ) ; cliViolations = ! messages . isEmpty ( ) ; if ( ! cliViolations ) { final CliOptions config = convertCliToPojo ( commandLine ) ; errorCounter = runCheckstyle ( config ) ; exitStatus = errorCounter ; } else { exitStatus = exitWithCliViolation ; errorCounter = 1 ; for ( String message : messages ) { System . out . println ( message ) ; } } } } catch ( ParseException pex ) { cliViolations = true ; exitStatus = exitWithCliViolation ; errorCounter = 1 ; System . out . println ( pex . getMessage ( ) ) ; printUsage ( ) ; } catch ( CheckstyleException e ) { exitStatus = exitWithCheckstyleException ; errorCounter = 1 ; System . out . println ( e . getMessage ( ) ) ; } finally { if ( errorCounter != 0 && ! cliViolations ) { System . out . println ( String . format ( "Checkstyle ends with %d errors." , errorCounter ) ) ; } System . exit ( exitStatus ) ; } } private static CommandLine parseCli ( String ... args ) throws ParseException { final CommandLineParser clp = new DefaultParser ( ) ; return clp . parse ( buildOptions ( ) , args ) ; } private static List < String > validateCli ( CommandLine cmdLine ) { final List < String > result = new ArrayList < > ( ) ; if ( ! cmdLine . hasOption ( "c" ) ) { result . add ( "Must specify a config XML file." ) ; } else { if ( cmdLine . hasOption ( "f" ) ) { final String format = cmdLine . getOptionValue ( "f" ) ; if ( ! "plain" . equals ( format ) && ! "xml" . equals ( format ) ) { result . add ( String . format ( "Invalid output format." + " Found '%s' but expected 'plain' or 'xml'." , format ) ) ; } } if ( cmdLine . hasOption ( "p" ) ) { final String propertiesLocation = cmdLine . getOptionValue ( "p" ) ; final File file = new File ( propertiesLocation ) ; if ( ! file . exists ( ) ) { result . add ( String . format ( "Could not find file '%s'." , propertiesLocation ) ) ; } } if ( cmdLine . hasOption ( "o" ) ) { final String outputLocation = cmdLine . getOptionValue ( "o" ) ; final File file = new File ( outputLocation ) ; if ( file . exists ( ) && ! ( file . canRead ( ) && file . canWrite ( ) ) ) { result . add ( String . format ( "Permission denied : '%s'." , outputLocation ) ) ; } } final List < File > files = getFilesToProcess ( cmdLine . getArgs ( ) ) ; if ( files . isEmpty ( ) ) { result . add ( "Must specify files to process, found 0." ) ; } } return result ; } private static CliOptions convertCliToPojo ( CommandLine cmdLine ) { final CliOptions conf = new CliOptions ( ) ; conf . format = cmdLine . getOptionValue ( "f" ) ; if ( conf . format == null ) { conf . format = "plain" ; } conf . outputLocation = cmdLine . getOptionValue ( "o" ) ; conf . configLocation = cmdLine . getOptionValue ( "c" ) ; conf . propertiesLocation = cmdLine . getOptionValue ( "p" ) ; conf . files = getFilesToProcess ( cmdLine . getArgs ( ) ) ; return conf ; } private static int runCheckstyle ( CliOptions cliOptions ) throws CheckstyleException , UnsupportedEncodingException , FileNotFoundException { final Properties props = cliOptions . propertiesLocation != null ? loadProperties ( new File ( cliOptions . propertiesLocation ) ) : System . getProperties ( ) ; final Configuration config = ConfigurationLoader . loadConfiguration ( cliOptions . configLocation , new PropertiesExpander ( props ) ) ; final AuditListener listener = createListener ( cliOptions . format , cliOptions . outputLocation ) ; int errorCounter = 0 ; final Checker checker = new Checker ( ) ; try { final ClassLoader moduleClassLoader = Checker . class . getClassLoader ( ) ; checker . setModuleClassLoader ( moduleClassLoader ) ; checker . configure ( config ) ; checker . addListener ( listener ) ; errorCounter = checker . process ( cliOptions . files ) ; } finally { checker . destroy ( ) ; } return errorCounter ; } private static Properties loadProperties ( File file ) throws CheckstyleException { final Properties properties = new Properties ( ) ; try ( FileInputStream fis = new FileInputStream ( file ) ) { properties . load ( fis ) ; } catch ( final IOException e ) { throw new CheckstyleException ( String . format ( "Unable to load properties from file '%s'." , file . getAbsolutePath ( ) ) , e ) ; } return properties ; } private static AuditListener createListener ( String format , String outputLocation ) throws UnsupportedEncodingException , FileNotFoundException { OutputStream out = null ; boolean closeOut = false ; if ( outputLocation != null ) { out = new FileOutputStream ( outputLocation ) ; closeOut = true ; } else { out = System . out ; closeOut = false ; } AuditListener listener = null ; switch ( format ) { case "xml" : listener = new XMLLogger ( out , closeOut ) ; break ; case "plain" : listener = new DefaultLogger ( out , closeOut ) ; break ; default : throw new IllegalStateException ( "Invalid output format. Found '" + format + "' but expected 'plain' or 'xml'." ) ; } return listener ; } private static List < File > getFilesToProcess ( String ... filesToProcess ) { final List < File > files = Lists . newLinkedList ( ) ; for ( String element : filesToProcess ) { files . addAll ( listFiles ( new File ( element ) ) ) ; } return files ; } private static List < File > listFiles ( File node ) { final List < File > result = Lists . newLinkedList ( ) ; if ( node . canRead ( ) ) { if ( node . isDirectory ( ) ) { final File [ ] files = node . listFiles ( ) ; if ( files != null ) { for ( File element : files ) { result . addAll ( listFiles ( element ) ) ; } } } else if ( node . isFile ( ) ) { result . add ( node ) ; } } return result ; } private static void printUsage ( ) { final HelpFormatter hf = new HelpFormatter ( ) ; hf . printHelp ( String . format ( "java %s [options] -c <config.xml> file..." , Main . class . getName ( ) ) , buildOptions ( ) ) ; } private static Options buildOptions ( ) { final Options options = new Options ( ) ; options . addOption ( "c" , true , "Sets the check configuration file to use." ) ; options . addOption ( "o" , true , "Sets the output file. Defaults to stdout" ) ; options . addOption ( "p" , true , "Loads the properties file" ) ; options . addOption ( "f" , true , "Sets the output format. (plain|xml). Defaults to plain" ) ; options . addOption ( "v" , false , "Print product version and exit" ) ; return options ; } private static class CliOptions { private String propertiesLocation ; private String configLocation ; private String format ; private String outputLocation ; private List < File > files ; } }
package com . puppycrawl . tools . checkstyle ; import com . google . common . collect . ImmutableMap ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . apache . commons . beanutils . ConversionException ; import java . io . File ; import java . lang . reflect . Field ; import java . nio . file . Path ; import java . nio . file . Paths ; import java . util . ResourceBundle ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; public final class Utils { private static final ImmutableMap < String , Integer > TOKEN_NAME_TO_VALUE ; private static final String [ ] TOKEN_VALUE_TO_NAME ; static { final ImmutableMap . Builder < String , Integer > builder = ImmutableMap . builder ( ) ; final Field [ ] fields = TokenTypes . class . getDeclaredFields ( ) ; String [ ] tempTokenValueToName = new String [ 0 ] ; for ( final Field f : fields ) { if ( f . getType ( ) != Integer . TYPE ) { continue ; } final String name = f . getName ( ) ; try { final int tokenValue = f . getInt ( name ) ; builder . put ( name , tokenValue ) ; if ( tokenValue > tempTokenValueToName . length - 1 ) { final String [ ] temp = new String [ tokenValue + 1 ] ; System . arraycopy ( tempTokenValueToName , 0 , temp , 0 , tempTokenValueToName . length ) ; tempTokenValueToName = temp ; } tempTokenValueToName [ tokenValue ] = name ; } catch ( final IllegalArgumentException | IllegalAccessException e ) { throw new IllegalStateException ( "Failed to instantiate collection of Java tokens" , e ) ; } } TOKEN_NAME_TO_VALUE = builder . build ( ) ; TOKEN_VALUE_TO_NAME = tempTokenValueToName ; } private Utils ( ) { } public static boolean fileExtensionMatches ( File file , String ... fileExtensions ) { boolean result = false ; if ( fileExtensions == null || fileExtensions . length == 0 ) { result = true ; } else { final String [ ] withDotExtensions = new String [ fileExtensions . length ] ; for ( int i = 0 ; i < fileExtensions . length ; i ++ ) { final String extension = fileExtensions [ i ] ; if ( startsWithChar ( extension , '.' ) ) { withDotExtensions [ i ] = extension ; } else { withDotExtensions [ i ] = "." + extension ; } } final String fileName = file . getName ( ) ; for ( final String fileExtension : withDotExtensions ) { if ( fileName . endsWith ( fileExtension ) ) { result = true ; } } } return result ; } public static boolean whitespaceBefore ( int index , String line ) { for ( int i = 0 ; i < index ; i ++ ) { if ( ! Character . isWhitespace ( line . charAt ( i ) ) ) { return false ; } } return true ; } public static int lengthMinusTrailingWhitespace ( String line ) { int len = line . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( ! Character . isWhitespace ( line . charAt ( i ) ) ) { break ; } len -- ; } return len ; } public static int lengthExpandedTabs ( String string , int toIdx , int tabWidth ) { int len = 0 ; for ( int idx = 0 ; idx < toIdx ; idx ++ ) { if ( string . charAt ( idx ) == '\t' ) { len = ( len / tabWidth + 1 ) * tabWidth ; } else { len ++ ; } } return len ; } public static boolean isPatternValid ( String pattern ) { try { Pattern . compile ( pattern ) ; } catch ( final PatternSyntaxException e ) { return false ; } return true ; } public static Pattern createPattern ( String pattern ) throws ConversionException { try { return Pattern . compile ( pattern ) ; } catch ( final PatternSyntaxException e ) { throw new ConversionException ( "Failed to initialise regular expression " + pattern , e ) ; } } public static String baseClassname ( String type ) { final int i = type . lastIndexOf ( '.' ) ; return i == - 1 ? type : type . substring ( i + 1 ) ; } public static String relativizeAndNormalizePath ( final String baseDirectory , final String path ) { if ( baseDirectory == null ) { return path ; } final Path pathAbsolute = Paths . get ( path ) . normalize ( ) ; final Path pathBase = Paths . get ( baseDirectory ) . normalize ( ) ; return pathBase . relativize ( pathAbsolute ) . toString ( ) ; } public static boolean startsWithChar ( String string , char prefix ) { return string . length ( ) > 0 && string . charAt ( 0 ) == prefix ; } public static boolean endsWithChar ( String string , char suffix ) { return string . length ( ) > 0 && string . charAt ( string . length ( ) - 1 ) == suffix ; } public static String getTokenName ( int iD ) { if ( iD > TOKEN_VALUE_TO_NAME . length - 1 ) { throw new IllegalArgumentException ( "given id " + iD ) ; } final String name = TOKEN_VALUE_TO_NAME [ iD ] ; if ( name == null ) { throw new IllegalArgumentException ( "given id " + iD ) ; } return name ; } public static int getTokenId ( String name ) { final Integer id = TOKEN_NAME_TO_VALUE . get ( name ) ; if ( id == null ) { throw new IllegalArgumentException ( "given name " + name ) ; } return id . intValue ( ) ; } public static String getShortDescription ( String name ) { if ( ! TOKEN_NAME_TO_VALUE . containsKey ( name ) ) { throw new IllegalArgumentException ( "given name " + name ) ; } final String tokentypes = "com.puppycrawl.tools.checkstyle.api.tokentypes" ; final ResourceBundle bundle = ResourceBundle . getBundle ( tokentypes ) ; return bundle . getString ( name ) ; } public static boolean isCommentType ( int type ) { return type == TokenTypes . SINGLE_LINE_COMMENT || type == TokenTypes . BLOCK_COMMENT_BEGIN || type == TokenTypes . BLOCK_COMMENT_END || type == TokenTypes . COMMENT_CONTENT ; } public static boolean isCommentType ( String type ) { return isCommentType ( getTokenId ( type ) ) ; } }
package com . puppycrawl . tools . checkstyle ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . ByteArrayOutputStream ; import java . io . ObjectOutputStream ; import java . io . OutputStream ; import java . io . Serializable ; import java . security . NoSuchAlgorithmException ; import java . util . Properties ; import java . security . MessageDigest ; import com . google . common . io . Closeables ; import com . google . common . io . Flushables ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; final class PropertyCacheFile { private static final Log LOG = LogFactory . getLog ( PropertyCacheFile . class ) ; private static final String CONFIG_HASH_KEY = "configuration*?" ; private static final char [ ] HEX_CHARS = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , } ; private static final int MASK_0X0F = 0x0F ; private static final int SHIFT_4 = 4 ; private final String detailsFile ; private final Properties details = new Properties ( ) ; PropertyCacheFile ( Configuration currentConfig , String fileName ) { boolean setInActive = true ; if ( fileName != null ) { FileInputStream inStream = null ; final String currentConfigHash = getConfigHashCode ( currentConfig ) ; try { inStream = new FileInputStream ( fileName ) ; details . load ( inStream ) ; final String cachedConfigHash = details . getProperty ( CONFIG_HASH_KEY ) ; setInActive = false ; if ( cachedConfigHash == null || ! cachedConfigHash . equals ( currentConfigHash ) ) { details . clear ( ) ; details . put ( CONFIG_HASH_KEY , currentConfigHash ) ; } } catch ( final FileNotFoundException e ) { setInActive = false ; details . put ( CONFIG_HASH_KEY , currentConfigHash ) ; } catch ( final IOException e ) { LOG . debug ( "Unable to open cache file, ignoring." , e ) ; } finally { Closeables . closeQuietly ( inStream ) ; } } detailsFile = setInActive ? null : fileName ; } void destroy ( ) { if ( detailsFile != null ) { FileOutputStream out = null ; try { out = new FileOutputStream ( detailsFile ) ; details . store ( out , null ) ; } catch ( final IOException e ) { LOG . debug ( "Unable to save cache file." , e ) ; } finally { if ( out != null ) { this . flushAndCloseOutStream ( out ) ; } } } } private void flushAndCloseOutStream ( OutputStream stream ) { try { Flushables . flush ( stream , false ) ; Closeables . close ( stream , false ) ; } catch ( final IOException ex ) { LOG . debug ( "Unable to flush and close output stream." , ex ) ; } } boolean alreadyChecked ( String fileName , long timestamp ) { final String lastChecked = details . getProperty ( fileName ) ; return lastChecked != null && lastChecked . equals ( Long . toString ( timestamp ) ) ; } void checkedOk ( String fileName , long timestamp ) { details . put ( fileName , Long . toString ( timestamp ) ) ; } private String getConfigHashCode ( Serializable configuration ) { try { final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = null ; try { oos = new ObjectOutputStream ( baos ) ; oos . writeObject ( configuration ) ; } finally { this . flushAndCloseOutStream ( oos ) ; } final MessageDigest md = MessageDigest . getInstance ( "SHA-1" ) ; md . update ( baos . toByteArray ( ) ) ; return hexEncode ( md . digest ( ) ) ; } catch ( final IOException | NoSuchAlgorithmException ex ) { throw new IllegalStateException ( "Unable to calculate hashcode." , ex ) ; } } private static String hexEncode ( byte ... byteArray ) { final StringBuilder buf = new StringBuilder ( 2 * byteArray . length ) ; for ( final byte b : byteArray ) { final int low = b & MASK_0X0F ; final int high = b > > SHIFT_4 & MASK_0X0F ; buf . append ( HEX_CHARS [ high ] ) ; buf . append ( HEX_CHARS [ low ] ) ; } return buf . toString ( ) ; } }
package com . puppycrawl . tools . checkstyle ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . AuditListener ; import com . puppycrawl . tools . checkstyle . api . AutomaticBean ; import com . puppycrawl . tools . checkstyle . api . SeverityLevel ; public class DefaultLogger extends AutomaticBean implements AuditListener { private static final int BUFFER_CUSHION = 12 ; private final PrintWriter infoWriter ; private final boolean closeInfo ; private final PrintWriter errorWriter ; private final boolean closeError ; public DefaultLogger ( OutputStream os , boolean closeStreamsAfterUse ) throws UnsupportedEncodingException { this ( os , closeStreamsAfterUse , os , false ) ; } public DefaultLogger ( OutputStream infoStream , boolean closeInfoAfterUse , OutputStream errorStream , boolean closeErrorAfterUse ) throws UnsupportedEncodingException { closeInfo = closeInfoAfterUse ; closeError = closeErrorAfterUse ; final Writer infoStreamWriter = new OutputStreamWriter ( infoStream , "UTF-8" ) ; final Writer errorStreamWriter = new OutputStreamWriter ( errorStream , "UTF-8" ) ; infoWriter = new PrintWriter ( infoStreamWriter ) ; errorWriter = infoStream == errorStream ? infoWriter : new PrintWriter ( errorStreamWriter ) ; } @ Override public void addError ( AuditEvent evt ) { final SeverityLevel severityLevel = evt . getSeverityLevel ( ) ; if ( SeverityLevel . IGNORE != severityLevel ) { final String fileName = evt . getFileName ( ) ; final String message = evt . getMessage ( ) ; final int bufLen = fileName . length ( ) + message . length ( ) + BUFFER_CUSHION ; final StringBuilder sb = new StringBuilder ( bufLen ) ; sb . append ( fileName ) . append ( ':' ) . append ( evt . getLine ( ) ) ; if ( evt . getColumn ( ) > 0 ) { sb . append ( ':' ) . append ( evt . getColumn ( ) ) ; } if ( SeverityLevel . WARNING == severityLevel ) { sb . append ( ": warning" ) ; } sb . append ( ": " ) . append ( message ) ; errorWriter . println ( sb . toString ( ) ) ; } } @ Override public void addException ( AuditEvent evt , Throwable throwable ) { synchronized ( errorWriter ) { errorWriter . println ( "Error auditing " + evt . getFileName ( ) ) ; throwable . printStackTrace ( errorWriter ) ; } } @ Override public void auditStarted ( AuditEvent evt ) { infoWriter . println ( "Starting audit..." ) ; } @ Override public void fileFinished ( AuditEvent evt ) { } @ Override public void fileStarted ( AuditEvent evt ) { } @ Override public void auditFinished ( AuditEvent evt ) { infoWriter . println ( "Audit done." ) ; closeStreams ( ) ; } protected void closeStreams ( ) { infoWriter . flush ( ) ; if ( closeInfo ) { infoWriter . close ( ) ; } errorWriter . flush ( ) ; if ( closeError ) { errorWriter . close ( ) ; } } }
package com . puppycrawl . tools . checkstyle ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . Set ; class PackageObjectFactory implements ModuleFactory { private static final Log LOG = LogFactory . getLog ( PackageObjectFactory . class ) ; private final Set < String > packages ; private final ClassLoader moduleClassLoader ; public PackageObjectFactory ( Set < String > packageNames , ClassLoader moduleClassLoader ) { if ( moduleClassLoader == null ) { throw new IllegalArgumentException ( "moduleClassLoader must not be null" ) ; } packages = Sets . newLinkedHashSet ( packageNames ) ; this . moduleClassLoader = moduleClassLoader ; } void addPackage ( String packageName ) { packages . add ( packageName ) ; } private Object doMakeObject ( String name ) throws CheckstyleException { try { return createObject ( name ) ; } catch ( final CheckstyleException ex ) { LOG . debug ( "Keep looking, ignoring exception" , ex ) ; } for ( String packageName : packages ) { final String className = packageName + name ; try { return createObject ( className ) ; } catch ( final CheckstyleException ex ) { LOG . debug ( "Keep looking, ignoring exception" , ex ) ; } } throw new CheckstyleException ( "Unable to instantiate " + name ) ; } private Object createObject ( String className ) throws CheckstyleException { try { final Class < ? > clazz = Class . forName ( className , true , moduleClassLoader ) ; return clazz . newInstance ( ) ; } catch ( final ClassNotFoundException | InstantiationException | IllegalAccessException e ) { throw new CheckstyleException ( "Unable to find class for " + className , e ) ; } } @ Override public Object createModule ( String name ) throws CheckstyleException { try { return doMakeObject ( name ) ; } catch ( final CheckstyleException ex ) { try { return doMakeObject ( name + "Check" ) ; } catch ( final CheckstyleException ex2 ) { throw new CheckstyleException ( "Unable to instantiate " + name , ex2 ) ; } } } }
package com . puppycrawl . tools . checkstyle ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . apache . commons . lang3 . StringUtils ; public final class AnnotationUtility { private static final String THE_AST_IS_NULL = "the ast is null" ; private AnnotationUtility ( ) { throw new UnsupportedOperationException ( "do not instantiate." ) ; } public static boolean containsAnnotation ( final DetailAST ast , String annotation ) { if ( ast == null ) { throw new IllegalArgumentException ( THE_AST_IS_NULL ) ; } return AnnotationUtility . getAnnotation ( ast , annotation ) != null ; } public static boolean containsAnnotation ( final DetailAST ast ) { if ( ast == null ) { throw new IllegalArgumentException ( THE_AST_IS_NULL ) ; } final DetailAST holder = AnnotationUtility . getAnnotationHolder ( ast ) ; return holder != null && holder . branchContains ( TokenTypes . ANNOTATION ) ; } public static DetailAST getAnnotationHolder ( DetailAST ast ) { if ( ast == null ) { throw new IllegalArgumentException ( THE_AST_IS_NULL ) ; } final DetailAST annotationHolder ; if ( ast . getType ( ) == TokenTypes . ENUM_CONSTANT_DEF || ast . getType ( ) == TokenTypes . PACKAGE_DEF ) { annotationHolder = ast . findFirstToken ( TokenTypes . ANNOTATIONS ) ; } else { annotationHolder = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; } return annotationHolder ; } public static DetailAST getAnnotation ( final DetailAST ast , String annotation ) { if ( ast == null ) { throw new IllegalArgumentException ( THE_AST_IS_NULL ) ; } if ( annotation == null ) { throw new IllegalArgumentException ( "the annotation is null" ) ; } if ( StringUtils . isBlank ( annotation ) ) { throw new IllegalArgumentException ( "the annotation is empty or spaces" ) ; } final DetailAST holder = AnnotationUtility . getAnnotationHolder ( ast ) ; for ( DetailAST child = holder . getFirstChild ( ) ; child != null ; child = child . getNextSibling ( ) ) { if ( child . getType ( ) == TokenTypes . ANNOTATION ) { final DetailAST at = child . getFirstChild ( ) ; final String name = FullIdent . createFullIdent ( at . getNextSibling ( ) ) . getText ( ) ; if ( annotation . equals ( name ) ) { return child ; } } } return null ; } }
package com . puppycrawl . tools . checkstyle ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import java . util . List ; import java . util . Map ; import java . util . Set ; public final class DefaultConfiguration implements Configuration { private static final long serialVersionUID = 1157875385356127169L ; private final String name ; private final List < Configuration > children = Lists . newArrayList ( ) ; private final Map < String , String > attributeMap = Maps . newHashMap ( ) ; private final Map < String , String > messages = Maps . newHashMap ( ) ; public DefaultConfiguration ( String name ) { this . name = name ; } @ Override public String [ ] getAttributeNames ( ) { final Set < String > keySet = attributeMap . keySet ( ) ; return keySet . toArray ( new String [ keySet . size ( ) ] ) ; } @ Override public String getAttribute ( String name ) throws CheckstyleException { if ( ! attributeMap . containsKey ( name ) ) { throw new CheckstyleException ( "missing key '" + name + "' in " + getName ( ) ) ; } return attributeMap . get ( name ) ; } @ Override public Configuration [ ] getChildren ( ) { return children . toArray ( new Configuration [ children . size ( ) ] ) ; } @ Override public String getName ( ) { return name ; } public void addChild ( Configuration configuration ) { children . add ( configuration ) ; } public void removeChild ( final Configuration configuration ) { children . remove ( configuration ) ; } public void addAttribute ( String name , String value ) { final String current = attributeMap . put ( name , value ) ; if ( null == current ) { attributeMap . put ( name , value ) ; } else { attributeMap . put ( name , current + "," + value ) ; } } public void addMessage ( String key , String value ) { messages . put ( key , value ) ; } @ Override public ImmutableMap < String , String > getMessages ( ) { return ImmutableMap . copyOf ( messages ) ; } }
package com . puppycrawl . tools . checkstyle ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . puppycrawl . tools . checkstyle . api . AbstractLoader ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . api . SeverityLevel ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import javax . xml . parsers . ParserConfigurationException ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; public final class ConfigurationLoader { private static final Log LOG = LogFactory . getLog ( ConfigurationLoader . class ) ; private static final String DTD_PUBLIC_ID_1_0 = "-//Puppy Crawl//DTD Check Configuration 1.0//EN" ; private static final String DTD_RESOURCE_NAME_1_0 = "com/puppycrawl/tools/checkstyle/configuration_1_0.dtd" ; private static final String DTD_PUBLIC_ID_1_1 = "-//Puppy Crawl//DTD Check Configuration 1.1//EN" ; private static final String DTD_RESOURCE_NAME_1_1 = "com/puppycrawl/tools/checkstyle/configuration_1_1.dtd" ; private static final String DTD_PUBLIC_ID_1_2 = "-//Puppy Crawl//DTD Check Configuration 1.2//EN" ; private static final String DTD_RESOURCE_NAME_1_2 = "com/puppycrawl/tools/checkstyle/configuration_1_2.dtd" ; private static final String DTD_PUBLIC_ID_1_3 = "-//Puppy Crawl//DTD Check Configuration 1.3//EN" ; private static final String DTD_RESOURCE_NAME_1_3 = "com/puppycrawl/tools/checkstyle/configuration_1_3.dtd" ; private final class InternalLoader extends AbstractLoader { private static final String MODULE = "module" ; private static final String NAME = "name" ; private static final String PROPERTY = "property" ; private static final String VALUE = "value" ; private static final String DEFAULT = "default" ; private static final String SEVERITY = "severity" ; private static final String MESSAGE = "message" ; private static final String KEY = "key" ; public InternalLoader ( ) throws SAXException , ParserConfigurationException { super ( createIdToResourceNameMap ( ) ) ; } @ Override public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws SAXException { if ( qName . equals ( MODULE ) ) { final String name = atts . getValue ( NAME ) ; final DefaultConfiguration conf = new DefaultConfiguration ( name ) ; if ( configuration == null ) { configuration = conf ; } if ( ! configStack . isEmpty ( ) ) { final DefaultConfiguration top = configStack . peek ( ) ; top . addChild ( conf ) ; } configStack . push ( conf ) ; } else if ( qName . equals ( PROPERTY ) ) { final String value ; try { value = replaceProperties ( atts . getValue ( VALUE ) , overridePropsResolver , atts . getValue ( DEFAULT ) ) ; } catch ( final CheckstyleException ex ) { throw new SAXException ( ex . getMessage ( ) ) ; } final String name = atts . getValue ( NAME ) ; final DefaultConfiguration top = configStack . peek ( ) ; top . addAttribute ( name , value ) ; } else if ( qName . equals ( MESSAGE ) ) { final String key = atts . getValue ( KEY ) ; final String value = atts . getValue ( VALUE ) ; final DefaultConfiguration top = configStack . peek ( ) ; top . addMessage ( key , value ) ; } } @ Override public void endElement ( String namespaceURI , String localName , String qName ) throws SAXException { if ( qName . equals ( MODULE ) ) { final Configuration recentModule = configStack . pop ( ) ; SeverityLevel level = null ; try { final String severity = recentModule . getAttribute ( SEVERITY ) ; level = SeverityLevel . getInstance ( severity ) ; } catch ( final CheckstyleException e ) { LOG . debug ( "Severity not set, ignoring exception" , e ) ; } final boolean omitModule = omitIgnoredModules && SeverityLevel . IGNORE == level ; if ( omitModule && ! configStack . isEmpty ( ) ) { final DefaultConfiguration parentModule = configStack . peek ( ) ; parentModule . removeChild ( recentModule ) ; } } } } private final InternalLoader saxHandler ; private final PropertyResolver overridePropsResolver ; private final Deque < DefaultConfiguration > configStack = new ArrayDeque < > ( ) ; private Configuration configuration ; private final boolean omitIgnoredModules ; private ConfigurationLoader ( final PropertyResolver overrideProps , final boolean omitIgnoredModules ) throws ParserConfigurationException , SAXException { saxHandler = new InternalLoader ( ) ; overridePropsResolver = overrideProps ; this . omitIgnoredModules = omitIgnoredModules ; } private static Map < String , String > createIdToResourceNameMap ( ) { final Map < String , String > map = Maps . newHashMap ( ) ; map . put ( DTD_PUBLIC_ID_1_0 , DTD_RESOURCE_NAME_1_0 ) ; map . put ( DTD_PUBLIC_ID_1_1 , DTD_RESOURCE_NAME_1_1 ) ; map . put ( DTD_PUBLIC_ID_1_2 , DTD_RESOURCE_NAME_1_2 ) ; map . put ( DTD_PUBLIC_ID_1_3 , DTD_RESOURCE_NAME_1_3 ) ; return map ; } private void parseInputSource ( InputSource source ) throws IOException , SAXException { saxHandler . parseInputSource ( source ) ; } public static Configuration loadConfiguration ( String config , PropertyResolver overridePropsResolver ) throws CheckstyleException { return loadConfiguration ( config , overridePropsResolver , false ) ; } public static Configuration loadConfiguration ( String config , PropertyResolver overridePropsResolver , boolean omitIgnoredModules ) throws CheckstyleException { URI uri ; try { final URL url = new URL ( config ) ; uri = url . toURI ( ) ; } catch ( final MalformedURLException ex ) { uri = null ; } catch ( final URISyntaxException ex ) { uri = null ; } if ( uri == null ) { final File file = new File ( config ) ; if ( file . exists ( ) ) { uri = file . toURI ( ) ; } else { try { final URL configUrl = ConfigurationLoader . class . getResource ( config ) ; if ( configUrl == null ) { throw new CheckstyleException ( "unable to find " + config ) ; } uri = configUrl . toURI ( ) ; } catch ( final URISyntaxException e ) { throw new CheckstyleException ( "unable to find " + config ) ; } } } final InputSource source = new InputSource ( uri . toString ( ) ) ; return loadConfiguration ( source , overridePropsResolver , omitIgnoredModules ) ; } @ Deprecated public static Configuration loadConfiguration ( InputStream configStream , PropertyResolver overridePropsResolver , boolean omitIgnoredModules ) throws CheckstyleException { return loadConfiguration ( new InputSource ( configStream ) , overridePropsResolver , omitIgnoredModules ) ; } public static Configuration loadConfiguration ( InputSource configSource , PropertyResolver overridePropsResolver , boolean omitIgnoredModules ) throws CheckstyleException { try { final ConfigurationLoader loader = new ConfigurationLoader ( overridePropsResolver , omitIgnoredModules ) ; loader . parseInputSource ( configSource ) ; return loader . getConfiguration ( ) ; } catch ( final ParserConfigurationException e ) { throw new CheckstyleException ( "unable to parse configuration stream" , e ) ; } catch ( final SAXParseException e ) { throw new CheckstyleException ( "unable to parse configuration stream" + " - " + e . getMessage ( ) + ":" + e . getLineNumber ( ) + ":" + e . getColumnNumber ( ) , e ) ; } catch ( final SAXException e ) { throw new CheckstyleException ( "unable to parse configuration stream" + " - " + e . getMessage ( ) , e ) ; } catch ( final IOException e ) { throw new CheckstyleException ( "unable to read from stream" , e ) ; } } private Configuration getConfiguration ( ) { return configuration ; } static String replaceProperties ( String value , PropertyResolver props , String defaultValue ) throws CheckstyleException { if ( value == null ) { return null ; } final List < String > fragments = Lists . newArrayList ( ) ; final List < String > propertyRefs = Lists . newArrayList ( ) ; parsePropertyString ( value , fragments , propertyRefs ) ; final StringBuilder sb = new StringBuilder ( ) ; final Iterator < String > i = fragments . iterator ( ) ; final Iterator < String > j = propertyRefs . iterator ( ) ; while ( i . hasNext ( ) ) { String fragment = i . next ( ) ; if ( fragment == null ) { final String propertyName = j . next ( ) ; fragment = props . resolve ( propertyName ) ; if ( fragment == null ) { if ( defaultValue != null ) { return defaultValue ; } throw new CheckstyleException ( "Property ${" + propertyName + "} has not been set" ) ; } } sb . append ( fragment ) ; } return sb . toString ( ) ; } private static void parsePropertyString ( String value , List < String > fragments , List < String > propertyRefs ) throws CheckstyleException { int prev = 0 ; int pos = value . indexOf ( '$' , prev ) ; while ( pos >= 0 ) { if ( pos > 0 ) { fragments . add ( value . substring ( prev , pos ) ) ; } if ( pos == value . length ( ) - 1 ) { fragments . add ( "$" ) ; prev = pos + 1 ; } else if ( value . charAt ( pos + 1 ) != '{' ) { if ( value . charAt ( pos + 1 ) == '$' ) { fragments . add ( "$" ) ; prev = pos + 2 ; } else { fragments . add ( value . substring ( pos , pos + 2 ) ) ; prev = pos + 2 ; } } else { final int endName = value . indexOf ( '}' , pos ) ; if ( endName < 0 ) { throw new CheckstyleException ( "Syntax error in property: " + value ) ; } final String propertyName = value . substring ( pos + 2 , endName ) ; fragments . add ( null ) ; propertyRefs . add ( propertyName ) ; prev = endName + 1 ; } pos = value . indexOf ( '$' , prev ) ; } if ( prev < value . length ( ) ) { fragments . add ( value . substring ( prev ) ) ; } } }
package com . puppycrawl . tools . checkstyle . checks ; import static com . puppycrawl . tools . checkstyle . checks . DescendantTokenCheck . MSG_KEY_MAX ; import static com . puppycrawl . tools . checkstyle . checks . DescendantTokenCheck . MSG_KEY_MIN ; import static com . puppycrawl . tools . checkstyle . checks . DescendantTokenCheck . MSG_KEY_SUM_MAX ; import java . io . File ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class DescendantTokenCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } @ Test public void testMaximumNumber ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_NATIVE" ) ; checkConfig . addAttribute ( "limitedTokens" , "LITERAL_NATIVE" ) ; checkConfig . addAttribute ( "maximumNumber" , "0" ) ; final String [ ] expected = { "20:12: " + getCheckMessage ( MSG_KEY_MAX , 1 , 0 , "LITERAL_NATIVE" , "LITERAL_NATIVE" ) , } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } @ Test public void testMessage ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_NATIVE" ) ; checkConfig . addAttribute ( "limitedTokens" , "LITERAL_NATIVE" ) ; checkConfig . addAttribute ( "maximumNumber" , "0" ) ; checkConfig . addAttribute ( "maximumMessage" , "Using ''native'' is not allowed." ) ; final String [ ] expected = { "20:12: Using 'native' is not allowed." , } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } @ Test public void testMinimumNumber ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_SWITCH" ) ; checkConfig . addAttribute ( "limitedTokens" , "LITERAL_DEFAULT" ) ; checkConfig . addAttribute ( "minimumNumber" , "2" ) ; final String [ ] expected = { "11:9: " + getCheckMessage ( MSG_KEY_MIN , 1 , 2 , "LITERAL_SWITCH" , "LITERAL_DEFAULT" ) , } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } @ Test public void testMinimumDepth ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_SWITCH" ) ; checkConfig . addAttribute ( "limitedTokens" , "LITERAL_DEFAULT" ) ; checkConfig . addAttribute ( "maximumNumber" , "0" ) ; checkConfig . addAttribute ( "minimumDepth" , "3" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } @ Test public void testMaximumDepth ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_SWITCH" ) ; checkConfig . addAttribute ( "limitedTokens" , "LITERAL_DEFAULT" ) ; checkConfig . addAttribute ( "maximumNumber" , "0" ) ; checkConfig . addAttribute ( "maximumDepth" , "1" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } @ Test public void testEmptyStatements ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "EMPTY_STAT" ) ; checkConfig . addAttribute ( "limitedTokens" , "EMPTY_STAT" ) ; checkConfig . addAttribute ( "maximumNumber" , "0" ) ; checkConfig . addAttribute ( "maximumDepth" , "0" ) ; checkConfig . addAttribute ( "maximumMessage" , "Empty statement." ) ; final String [ ] expected = { "12:7: Empty statement." , "17:7: Empty statement." , "22:19: Empty statement." , "26:10: Empty statement." , "29:16: Empty statement." , "33:10: Empty statement." , "43:10: Empty statement." , "49:13: Empty statement." , "51:13: Empty statement." , "54:19: Empty statement." , "58:10: Empty statement." , "61:9: Empty statement." , "66:10: Empty statement." , "72:10: Empty statement." , "76:10: Empty statement." , "80:10: Empty statement." , } ; verify ( checkConfig , getPath ( "InputEmptyStatement.java" ) , expected ) ; } @ Test public void testMissingSwitchDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_SWITCH" ) ; checkConfig . addAttribute ( "limitedTokens" , "LITERAL_DEFAULT" ) ; checkConfig . addAttribute ( "minimumNumber" , "1" ) ; checkConfig . addAttribute ( "maximumDepth" , "2" ) ; checkConfig . addAttribute ( "minimumMessage" , "switch without \"default\" clause." ) ; final String [ ] expected = { "17:9: switch without \"default\" clause." , } ; verify ( checkConfig , getPath ( "InputMissingSwitchDefault.java" ) , expected ) ; } @ Test public void testStringLiteralEquality ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "EQUAL,NOT_EQUAL" ) ; checkConfig . addAttribute ( "limitedTokens" , "STRING_LITERAL" ) ; checkConfig . addAttribute ( "maximumNumber" , "0" ) ; checkConfig . addAttribute ( "maximumDepth" , "1" ) ; checkConfig . addAttribute ( "maximumMessage" , "Literal Strings should be compared using equals(), not ''==''." ) ; final String [ ] expected = { "11:18: Literal Strings should be compared using equals(), not '=='." , "16:20: Literal Strings should be compared using equals(), not '=='." , "21:22: Literal Strings should be compared using equals(), not '=='." , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputStringLiteralEquality.java" ) , expected ) ; } @ Test public void testIllegalTokenDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_SWITCH, POST_INC, POST_DEC" ) ; checkConfig . addAttribute ( "limitedTokens" , "LITERAL_SWITCH, POST_INC, POST_DEC" ) ; checkConfig . addAttribute ( "maximumNumber" , "0" ) ; checkConfig . addAttribute ( "maximumDepth" , "0" ) ; checkConfig . addAttribute ( "maximumMessage" , "Using ''{2}'' is not allowed." ) ; final String [ ] expected = { "11:9: Using 'LITERAL_SWITCH' is not allowed." , "14:18: Using 'POST_DEC' is not allowed." , "15:18: Using 'POST_INC' is not allowed." , } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } @ Test public void testIllegalTokenNative ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_NATIVE" ) ; checkConfig . addAttribute ( "limitedTokens" , "LITERAL_NATIVE" ) ; checkConfig . addAttribute ( "maximumNumber" , "0" ) ; checkConfig . addAttribute ( "maximumDepth" , "0" ) ; checkConfig . addAttribute ( "maximumMessage" , "Using ''{2}'' is not allowed." ) ; final String [ ] expected = { "20:12: Using 'LITERAL_NATIVE' is not allowed." , } ; verify ( checkConfig , getPath ( "InputIllegalTokens.java" ) , expected ) ; } @ Test public void testReturnFromCatch ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_CATCH" ) ; checkConfig . addAttribute ( "limitedTokens" , "LITERAL_RETURN" ) ; checkConfig . addAttribute ( "maximumNumber" , "0" ) ; checkConfig . addAttribute ( "maximumMessage" , "Return from catch is not allowed." ) ; String [ ] expected = { "7:11: Return from catch is not allowed." , "15:11: Return from catch is not allowed." , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputReturnFromCatchCheck.java" ) , expected ) ; } @ Test public void testReturnFromFinally ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_FINALLY" ) ; checkConfig . addAttribute ( "limitedTokens" , "LITERAL_RETURN" ) ; checkConfig . addAttribute ( "maximumNumber" , "0" ) ; checkConfig . addAttribute ( "maximumMessage" , "Return from finally is not allowed." ) ; String [ ] expected = { "7:11: Return from finally is not allowed." , "15:11: Return from finally is not allowed." , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputReturnFromFinallyCheck.java" ) , expected ) ; } @ Test public void testNoSum ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "NOT_EQUAL,EQUAL" ) ; checkConfig . addAttribute ( "limitedTokens" , "LITERAL_THIS,LITERAL_NULL" ) ; checkConfig . addAttribute ( "maximumNumber" , "1" ) ; checkConfig . addAttribute ( "maximumMessage" , "What are you doing?" ) ; String [ ] expected = { } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputReturnFromFinallyCheck.java" ) , expected ) ; } @ Test public void testWithSumCustomMsg ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "NOT_EQUAL,EQUAL" ) ; checkConfig . addAttribute ( "limitedTokens" , "LITERAL_THIS,LITERAL_NULL" ) ; checkConfig . addAttribute ( "maximumNumber" , "1" ) ; checkConfig . addAttribute ( "maximumDepth" , "1" ) ; checkConfig . addAttribute ( "maximumMessage" , "this cannot be null." ) ; checkConfig . addAttribute ( "sumTokenCounts" , "true" ) ; String [ ] expected = { "22:32: this cannot be null." , "22:50: this cannot be null." , "23:33: this cannot be null." , "23:51: this cannot be null." , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputReturnFromFinallyCheck.java" ) , expected ) ; } @ Test public void testWithSumDefaultMsg ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( DescendantTokenCheck . class ) ; checkConfig . addAttribute ( "tokens" , "NOT_EQUAL,EQUAL" ) ; checkConfig . addAttribute ( "limitedTokens" , "LITERAL_THIS,LITERAL_NULL" ) ; checkConfig . addAttribute ( "maximumNumber" , "1" ) ; checkConfig . addAttribute ( "maximumDepth" , "1" ) ; checkConfig . addAttribute ( "sumTokenCounts" , "true" ) ; String [ ] expected = { "22:32: " + getCheckMessage ( MSG_KEY_SUM_MAX , 2 , 1 , "EQUAL" ) , "22:50: " + getCheckMessage ( MSG_KEY_SUM_MAX , 2 , 1 , "EQUAL" ) , "23:33: " + getCheckMessage ( MSG_KEY_SUM_MAX , 2 , 1 , "NOT_EQUAL" ) , "23:51: " + getCheckMessage ( MSG_KEY_SUM_MAX , 2 , 1 , "NOT_EQUAL" ) , } ; verify ( checkConfig , getPath ( "coding" + File . separator + "InputReturnFromFinallyCheck.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle ; import java . util . Properties ; public final class PropertiesExpander implements PropertyResolver { private final Properties properties ; public PropertiesExpander ( Properties properties ) { if ( properties == null ) { throw new IllegalArgumentException ( "cannot pass null" ) ; } this . properties = properties ; } @ Override public String resolve ( String propertyName ) { return properties . getProperty ( propertyName ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import com . google . common . collect . Sets ; import java . util . Objects ; import java . util . Set ; public class FilterSet implements Filter { private final Set < Filter > filters = Sets . newHashSet ( ) ; public void addFilter ( Filter filter ) { filters . add ( filter ) ; } public void removeFilter ( Filter filter ) { filters . remove ( filter ) ; } public Set < Filter > getFilters ( ) { return filters ; } @ Override public String toString ( ) { return filters . toString ( ) ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } final FilterSet filterSet = ( FilterSet ) o ; return Objects . equals ( filters , filterSet . filters ) ; } @ Override public int hashCode ( ) { return Objects . hash ( filters ) ; } @ Override public boolean accept ( AuditEvent event ) { for ( Filter filter : filters ) { if ( ! filter . accept ( event ) ) { return false ; } } return true ; } public void clear ( ) { filters . clear ( ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocNodeImpl ; public interface DetailNode { int getType ( ) ; String getText ( ) ; int getLineNumber ( ) ; int getColumnNumber ( ) ; DetailNode [ ] getChildren ( ) ; DetailNode getParent ( ) ; int getIndex ( ) ; }
package com . puppycrawl . tools . checkstyle . api ; import com . google . common . collect . Lists ; import java . beans . PropertyDescriptor ; import java . lang . reflect . InvocationTargetException ; import java . util . Collection ; import java . util . List ; import java . util . StringTokenizer ; import org . apache . commons . beanutils . BeanUtilsBean ; import org . apache . commons . beanutils . ConversionException ; import org . apache . commons . beanutils . ConvertUtilsBean ; import org . apache . commons . beanutils . Converter ; import org . apache . commons . beanutils . PropertyUtils ; import org . apache . commons . beanutils . PropertyUtilsBean ; import org . apache . commons . beanutils . converters . ArrayConverter ; import org . apache . commons . beanutils . converters . BooleanConverter ; import org . apache . commons . beanutils . converters . ByteConverter ; import org . apache . commons . beanutils . converters . CharacterConverter ; import org . apache . commons . beanutils . converters . DoubleConverter ; import org . apache . commons . beanutils . converters . FloatConverter ; import org . apache . commons . beanutils . converters . IntegerConverter ; import org . apache . commons . beanutils . converters . LongConverter ; import org . apache . commons . beanutils . converters . ShortConverter ; public class AutomaticBean implements Configurable , Contextualizable { private Configuration configuration ; private static BeanUtilsBean createBeanUtilsBean ( ) { final ConvertUtilsBean cub = new ConvertUtilsBean ( ) ; cub . register ( new BooleanConverter ( ) , Boolean . TYPE ) ; cub . register ( new BooleanConverter ( ) , Boolean . class ) ; cub . register ( new ArrayConverter ( boolean [ ] . class , new BooleanConverter ( ) ) , boolean [ ] . class ) ; cub . register ( new ByteConverter ( ) , Byte . TYPE ) ; cub . register ( new ByteConverter ( ) , Byte . class ) ; cub . register ( new ArrayConverter ( byte [ ] . class , new ByteConverter ( ) ) , byte [ ] . class ) ; cub . register ( new CharacterConverter ( ) , Character . TYPE ) ; cub . register ( new CharacterConverter ( ) , Character . class ) ; cub . register ( new ArrayConverter ( char [ ] . class , new CharacterConverter ( ) ) , char [ ] . class ) ; cub . register ( new DoubleConverter ( ) , Double . TYPE ) ; cub . register ( new DoubleConverter ( ) , Double . class ) ; cub . register ( new ArrayConverter ( double [ ] . class , new DoubleConverter ( ) ) , double [ ] . class ) ; cub . register ( new FloatConverter ( ) , Float . TYPE ) ; cub . register ( new FloatConverter ( ) , Float . class ) ; cub . register ( new ArrayConverter ( float [ ] . class , new FloatConverter ( ) ) , float [ ] . class ) ; cub . register ( new IntegerConverter ( ) , Integer . TYPE ) ; cub . register ( new IntegerConverter ( ) , Integer . class ) ; cub . register ( new ArrayConverter ( int [ ] . class , new IntegerConverter ( ) ) , int [ ] . class ) ; cub . register ( new LongConverter ( ) , Long . TYPE ) ; cub . register ( new LongConverter ( ) , Long . class ) ; cub . register ( new ArrayConverter ( long [ ] . class , new LongConverter ( ) ) , long [ ] . class ) ; cub . register ( new ShortConverter ( ) , Short . TYPE ) ; cub . register ( new ShortConverter ( ) , Short . class ) ; cub . register ( new ArrayConverter ( short [ ] . class , new ShortConverter ( ) ) , short [ ] . class ) ; cub . register ( new RelaxedStringArrayConverter ( ) , String [ ] . class ) ; return new BeanUtilsBean ( cub , new PropertyUtilsBean ( ) ) ; } @ Override public final void configure ( Configuration configuration ) throws CheckstyleException { this . configuration = configuration ; final BeanUtilsBean beanUtils = createBeanUtilsBean ( ) ; final String [ ] attributes = configuration . getAttributeNames ( ) ; for ( final String key : attributes ) { final String value = configuration . getAttribute ( key ) ; try { final PropertyDescriptor pd = PropertyUtils . getPropertyDescriptor ( this , key ) ; if ( pd == null || pd . getWriteMethod ( ) == null ) { throw new CheckstyleException ( "Property '" + key + "' in module " + configuration . getName ( ) + " does not exist, please check the documentation" ) ; } beanUtils . copyProperty ( this , key , value ) ; } catch ( final InvocationTargetException e ) { throw new CheckstyleException ( "Cannot set property '" + key + "' in module " + configuration . getName ( ) + " to '" + value + "': " + e . getTargetException ( ) . getMessage ( ) , e ) ; } catch ( final IllegalAccessException | NoSuchMethodException e ) { throw new CheckstyleException ( "cannot access " + key + " in " + this . getClass ( ) . getName ( ) , e ) ; } catch ( final IllegalArgumentException | ConversionException e ) { throw new CheckstyleException ( "illegal value '" + value + "' for property '" + key + "' of module " + configuration . getName ( ) , e ) ; } } finishLocalSetup ( ) ; final Configuration [ ] childConfigs = configuration . getChildren ( ) ; for ( final Configuration childConfig : childConfigs ) { setupChild ( childConfig ) ; } } @ Override public final void contextualize ( Context context ) throws CheckstyleException { final BeanUtilsBean beanUtils = createBeanUtilsBean ( ) ; final Collection < String > attributes = context . getAttributeNames ( ) ; for ( final String key : attributes ) { final Object value = context . get ( key ) ; try { beanUtils . copyProperty ( this , key , value ) ; } catch ( final InvocationTargetException e ) { throw new CheckstyleException ( "cannot set property " + key + " to value " + value + " in bean " + this . getClass ( ) . getName ( ) , e ) ; } catch ( final IllegalAccessException e ) { throw new CheckstyleException ( "cannot access " + key + " in " + this . getClass ( ) . getName ( ) , e ) ; } catch ( final IllegalArgumentException | ConversionException e ) { throw new CheckstyleException ( "illegal value '" + value + "' for property '" + key + "' of bean " + this . getClass ( ) . getName ( ) , e ) ; } } } protected final Configuration getConfiguration ( ) { return configuration ; } protected void finishLocalSetup ( ) throws CheckstyleException { } protected void setupChild ( Configuration childConf ) throws CheckstyleException { } private static class RelaxedStringArrayConverter implements Converter { @ Override public Object convert ( @ SuppressWarnings ( "rawtypes" ) Class type , Object value ) { if ( null == type ) { throw new ConversionException ( "Cannot convert from null." ) ; } final StringTokenizer st = new StringTokenizer ( value . toString ( ) . trim ( ) , "," ) ; final List < String > result = Lists . newArrayList ( ) ; while ( st . hasMoreTokens ( ) ) { final String token = st . nextToken ( ) ; result . add ( token . trim ( ) ) ; } return result . toArray ( new String [ result . size ( ) ] ) ; } } }
package com . puppycrawl . tools . checkstyle . api ;
package com . puppycrawl . tools . checkstyle . api ; public final class SeverityLevelCounter implements AuditListener { private SeverityLevel level ; private int count ; public SeverityLevelCounter ( SeverityLevel level ) { if ( level == null ) { throw new IllegalArgumentException ( ) ; } this . level = level ; } @ Override public void addError ( AuditEvent evt ) { if ( level == evt . getSeverityLevel ( ) ) { count ++ ; } } @ Override public void addException ( AuditEvent evt , Throwable throwable ) { if ( SeverityLevel . ERROR == level ) { count ++ ; } } @ Override public void auditStarted ( AuditEvent evt ) { count = 0 ; } @ Override public void fileStarted ( AuditEvent evt ) { } @ Override public void auditFinished ( AuditEvent evt ) { } @ Override public void fileFinished ( AuditEvent evt ) { } public int getCount ( ) { return count ; } }
package com . puppycrawl . tools . checkstyle . api ; import com . puppycrawl . tools . checkstyle . grammars . GeneratedJavaTokenTypes ; public final class TokenTypes { public static final int EOF = GeneratedJavaTokenTypes . EOF ; public static final int MODIFIERS = GeneratedJavaTokenTypes . MODIFIERS ; public static final int OBJBLOCK = GeneratedJavaTokenTypes . OBJBLOCK ; public static final int SLIST = GeneratedJavaTokenTypes . SLIST ; public static final int CTOR_DEF = GeneratedJavaTokenTypes . CTOR_DEF ; public static final int METHOD_DEF = GeneratedJavaTokenTypes . METHOD_DEF ; public static final int VARIABLE_DEF = GeneratedJavaTokenTypes . VARIABLE_DEF ; public static final int INSTANCE_INIT = GeneratedJavaTokenTypes . INSTANCE_INIT ; public static final int STATIC_INIT = GeneratedJavaTokenTypes . STATIC_INIT ; public static final int TYPE = GeneratedJavaTokenTypes . TYPE ; public static final int CLASS_DEF = GeneratedJavaTokenTypes . CLASS_DEF ; public static final int INTERFACE_DEF = GeneratedJavaTokenTypes . INTERFACE_DEF ; public static final int PACKAGE_DEF = GeneratedJavaTokenTypes . PACKAGE_DEF ; public static final int ARRAY_DECLARATOR = GeneratedJavaTokenTypes . ARRAY_DECLARATOR ; public static final int EXTENDS_CLAUSE = GeneratedJavaTokenTypes . EXTENDS_CLAUSE ; public static final int IMPLEMENTS_CLAUSE = GeneratedJavaTokenTypes . IMPLEMENTS_CLAUSE ; public static final int PARAMETERS = GeneratedJavaTokenTypes . PARAMETERS ; public static final int PARAMETER_DEF = GeneratedJavaTokenTypes . PARAMETER_DEF ; public static final int LABELED_STAT = GeneratedJavaTokenTypes . LABELED_STAT ; public static final int TYPECAST = GeneratedJavaTokenTypes . TYPECAST ; public static final int INDEX_OP = GeneratedJavaTokenTypes . INDEX_OP ; public static final int POST_INC = GeneratedJavaTokenTypes . POST_INC ; public static final int POST_DEC = GeneratedJavaTokenTypes . POST_DEC ; public static final int METHOD_CALL = GeneratedJavaTokenTypes . METHOD_CALL ; public static final int METHOD_REF = GeneratedJavaTokenTypes . METHOD_REF ; public static final int EXPR = GeneratedJavaTokenTypes . EXPR ; public static final int ARRAY_INIT = GeneratedJavaTokenTypes . ARRAY_INIT ; public static final int IMPORT = GeneratedJavaTokenTypes . IMPORT ; public static final int UNARY_MINUS = GeneratedJavaTokenTypes . UNARY_MINUS ; public static final int UNARY_PLUS = GeneratedJavaTokenTypes . UNARY_PLUS ; public static final int CASE_GROUP = GeneratedJavaTokenTypes . CASE_GROUP ; public static final int ELIST = GeneratedJavaTokenTypes . ELIST ; public static final int FOR_INIT = GeneratedJavaTokenTypes . FOR_INIT ; public static final int FOR_CONDITION = GeneratedJavaTokenTypes . FOR_CONDITION ; public static final int FOR_ITERATOR = GeneratedJavaTokenTypes . FOR_ITERATOR ; public static final int EMPTY_STAT = GeneratedJavaTokenTypes . EMPTY_STAT ; public static final int FINAL = GeneratedJavaTokenTypes . FINAL ; public static final int ABSTRACT = GeneratedJavaTokenTypes . ABSTRACT ; public static final int STRICTFP = GeneratedJavaTokenTypes . STRICTFP ; public static final int SUPER_CTOR_CALL = GeneratedJavaTokenTypes . SUPER_CTOR_CALL ; public static final int CTOR_CALL = GeneratedJavaTokenTypes . CTOR_CALL ; public static final int SEMI = GeneratedJavaTokenTypes . SEMI ; public static final int RBRACK = GeneratedJavaTokenTypes . RBRACK ; public static final int LITERAL_VOID = GeneratedJavaTokenTypes . LITERAL_void ; public static final int LITERAL_BOOLEAN = GeneratedJavaTokenTypes . LITERAL_boolean ; public static final int LITERAL_BYTE = GeneratedJavaTokenTypes . LITERAL_byte ; public static final int LITERAL_CHAR = GeneratedJavaTokenTypes . LITERAL_char ; public static final int LITERAL_SHORT = GeneratedJavaTokenTypes . LITERAL_short ; public static final int LITERAL_INT = GeneratedJavaTokenTypes . LITERAL_int ; public static final int LITERAL_FLOAT = GeneratedJavaTokenTypes . LITERAL_float ; public static final int LITERAL_LONG = GeneratedJavaTokenTypes . LITERAL_long ; public static final int LITERAL_DOUBLE = GeneratedJavaTokenTypes . LITERAL_double ; public static final int IDENT = GeneratedJavaTokenTypes . IDENT ; public static final int DOT = GeneratedJavaTokenTypes . DOT ; public static final int STAR = GeneratedJavaTokenTypes . STAR ; public static final int LITERAL_PRIVATE = GeneratedJavaTokenTypes . LITERAL_private ; public static final int LITERAL_PUBLIC = GeneratedJavaTokenTypes . LITERAL_public ; public static final int LITERAL_PROTECTED = GeneratedJavaTokenTypes . LITERAL_protected ; public static final int LITERAL_STATIC = GeneratedJavaTokenTypes . LITERAL_static ; public static final int LITERAL_TRANSIENT = GeneratedJavaTokenTypes . LITERAL_transient ; public static final int LITERAL_NATIVE = GeneratedJavaTokenTypes . LITERAL_native ; public static final int LITERAL_SYNCHRONIZED = GeneratedJavaTokenTypes . LITERAL_synchronized ; public static final int LITERAL_VOLATILE = GeneratedJavaTokenTypes . LITERAL_volatile ; public static final int LITERAL_CLASS = GeneratedJavaTokenTypes . LITERAL_class ; public static final int LITERAL_INTERFACE = GeneratedJavaTokenTypes . LITERAL_interface ; public static final int LCURLY = GeneratedJavaTokenTypes . LCURLY ; public static final int RCURLY = GeneratedJavaTokenTypes . RCURLY ; public static final int COMMA = GeneratedJavaTokenTypes . COMMA ; public static final int LPAREN = GeneratedJavaTokenTypes . LPAREN ; public static final int RPAREN = GeneratedJavaTokenTypes . RPAREN ; public static final int LITERAL_THIS = GeneratedJavaTokenTypes . LITERAL_this ; public static final int LITERAL_SUPER = GeneratedJavaTokenTypes . LITERAL_super ; public static final int ASSIGN = GeneratedJavaTokenTypes . ASSIGN ; public static final int LITERAL_THROWS = GeneratedJavaTokenTypes . LITERAL_throws ; public static final int COLON = GeneratedJavaTokenTypes . COLON ; public static final int DOUBLE_COLON = GeneratedJavaTokenTypes . DOUBLE_COLON ; public static final int LITERAL_IF = GeneratedJavaTokenTypes . LITERAL_if ; public static final int LITERAL_FOR = GeneratedJavaTokenTypes . LITERAL_for ; public static final int LITERAL_WHILE = GeneratedJavaTokenTypes . LITERAL_while ; public static final int LITERAL_DO = GeneratedJavaTokenTypes . LITERAL_do ; public static final int DO_WHILE = GeneratedJavaTokenTypes . DO_WHILE ; public static final int LITERAL_BREAK = GeneratedJavaTokenTypes . LITERAL_break ; public static final int LITERAL_CONTINUE = GeneratedJavaTokenTypes . LITERAL_continue ; public static final int LITERAL_RETURN = GeneratedJavaTokenTypes . LITERAL_return ; public static final int LITERAL_SWITCH = GeneratedJavaTokenTypes . LITERAL_switch ; public static final int LITERAL_THROW = GeneratedJavaTokenTypes . LITERAL_throw ; public static final int LITERAL_ELSE = GeneratedJavaTokenTypes . LITERAL_else ; public static final int LITERAL_CASE = GeneratedJavaTokenTypes . LITERAL_case ; public static final int LITERAL_DEFAULT = GeneratedJavaTokenTypes . LITERAL_default ; public static final int LITERAL_TRY = GeneratedJavaTokenTypes . LITERAL_try ; public static final int RESOURCE_SPECIFICATION = GeneratedJavaTokenTypes . RESOURCE_SPECIFICATION ; public static final int RESOURCES = GeneratedJavaTokenTypes . RESOURCES ; public static final int RESOURCE = GeneratedJavaTokenTypes . RESOURCE ; public static final int LITERAL_CATCH = GeneratedJavaTokenTypes . LITERAL_catch ; public static final int LITERAL_FINALLY = GeneratedJavaTokenTypes . LITERAL_finally ; public static final int PLUS_ASSIGN = GeneratedJavaTokenTypes . PLUS_ASSIGN ; public static final int MINUS_ASSIGN = GeneratedJavaTokenTypes . MINUS_ASSIGN ; public static final int STAR_ASSIGN = GeneratedJavaTokenTypes . STAR_ASSIGN ; public static final int DIV_ASSIGN = GeneratedJavaTokenTypes . DIV_ASSIGN ; public static final int MOD_ASSIGN = GeneratedJavaTokenTypes . MOD_ASSIGN ; public static final int SR_ASSIGN = GeneratedJavaTokenTypes . SR_ASSIGN ; public static final int BSR_ASSIGN = GeneratedJavaTokenTypes . BSR_ASSIGN ; public static final int SL_ASSIGN = GeneratedJavaTokenTypes . SL_ASSIGN ; public static final int BAND_ASSIGN = GeneratedJavaTokenTypes . BAND_ASSIGN ; public static final int BXOR_ASSIGN = GeneratedJavaTokenTypes . BXOR_ASSIGN ; public static final int BOR_ASSIGN = GeneratedJavaTokenTypes . BOR_ASSIGN ; public static final int QUESTION = GeneratedJavaTokenTypes . QUESTION ; public static final int LOR = GeneratedJavaTokenTypes . LOR ; public static final int LAND = GeneratedJavaTokenTypes . LAND ; public static final int BOR = GeneratedJavaTokenTypes . BOR ; public static final int BXOR = GeneratedJavaTokenTypes . BXOR ; public static final int BAND = GeneratedJavaTokenTypes . BAND ; public static final int NOT_EQUAL = GeneratedJavaTokenTypes . NOT_EQUAL ; public static final int EQUAL = GeneratedJavaTokenTypes . EQUAL ; public static final int LT = GeneratedJavaTokenTypes . LT ; public static final int GT = GeneratedJavaTokenTypes . GT ; public static final int LE = GeneratedJavaTokenTypes . LE ; public static final int GE = GeneratedJavaTokenTypes . GE ; public static final int LITERAL_INSTANCEOF = GeneratedJavaTokenTypes . LITERAL_instanceof ; public static final int SL = GeneratedJavaTokenTypes . SL ; public static final int SR = GeneratedJavaTokenTypes . SR ; public static final int BSR = GeneratedJavaTokenTypes . BSR ; public static final int PLUS = GeneratedJavaTokenTypes . PLUS ; public static final int MINUS = GeneratedJavaTokenTypes . MINUS ; public static final int DIV = GeneratedJavaTokenTypes . DIV ; public static final int MOD = GeneratedJavaTokenTypes . MOD ; public static final int INC = GeneratedJavaTokenTypes . INC ; public static final int DEC = GeneratedJavaTokenTypes . DEC ; public static final int BNOT = GeneratedJavaTokenTypes . BNOT ; public static final int LNOT = GeneratedJavaTokenTypes . LNOT ; public static final int LITERAL_TRUE = GeneratedJavaTokenTypes . LITERAL_true ; public static final int LITERAL_FALSE = GeneratedJavaTokenTypes . LITERAL_false ; public static final int LITERAL_NULL = GeneratedJavaTokenTypes . LITERAL_null ; public static final int LITERAL_NEW = GeneratedJavaTokenTypes . LITERAL_new ; public static final int NUM_INT = GeneratedJavaTokenTypes . NUM_INT ; public static final int CHAR_LITERAL = GeneratedJavaTokenTypes . CHAR_LITERAL ; public static final int STRING_LITERAL = GeneratedJavaTokenTypes . STRING_LITERAL ; public static final int NUM_FLOAT = GeneratedJavaTokenTypes . NUM_FLOAT ; public static final int NUM_LONG = GeneratedJavaTokenTypes . NUM_LONG ; public static final int NUM_DOUBLE = GeneratedJavaTokenTypes . NUM_DOUBLE ; public static final int LITERAL_ASSERT = GeneratedJavaTokenTypes . ASSERT ; public static final int STATIC_IMPORT = GeneratedJavaTokenTypes . STATIC_IMPORT ; public static final int ENUM_DEF = GeneratedJavaTokenTypes . ENUM_DEF ; public static final int ENUM = GeneratedJavaTokenTypes . ENUM ; public static final int ENUM_CONSTANT_DEF = GeneratedJavaTokenTypes . ENUM_CONSTANT_DEF ; public static final int FOR_EACH_CLAUSE = GeneratedJavaTokenTypes . FOR_EACH_CLAUSE ; public static final int ANNOTATION_DEF = GeneratedJavaTokenTypes . ANNOTATION_DEF ; public static final int ANNOTATION_FIELD_DEF = GeneratedJavaTokenTypes . ANNOTATION_FIELD_DEF ; public static final int ANNOTATIONS = GeneratedJavaTokenTypes . ANNOTATIONS ; public static final int ANNOTATION = GeneratedJavaTokenTypes . ANNOTATION ; public static final int ANNOTATION_MEMBER_VALUE_PAIR = GeneratedJavaTokenTypes . ANNOTATION_MEMBER_VALUE_PAIR ; public static final int ANNOTATION_ARRAY_INIT = GeneratedJavaTokenTypes . ANNOTATION_ARRAY_INIT ; public static final int TYPE_PARAMETERS = GeneratedJavaTokenTypes . TYPE_PARAMETERS ; public static final int TYPE_PARAMETER = GeneratedJavaTokenTypes . TYPE_PARAMETER ; public static final int TYPE_ARGUMENTS = GeneratedJavaTokenTypes . TYPE_ARGUMENTS ; public static final int TYPE_ARGUMENT = GeneratedJavaTokenTypes . TYPE_ARGUMENT ; public static final int WILDCARD_TYPE = GeneratedJavaTokenTypes . WILDCARD_TYPE ; public static final int TYPE_UPPER_BOUNDS = GeneratedJavaTokenTypes . TYPE_UPPER_BOUNDS ; public static final int TYPE_LOWER_BOUNDS = GeneratedJavaTokenTypes . TYPE_LOWER_BOUNDS ; public static final int AT = GeneratedJavaTokenTypes . AT ; public static final int ELLIPSIS = GeneratedJavaTokenTypes . ELLIPSIS ; public static final int TYPE_EXTENSION_AND = GeneratedJavaTokenTypes . TYPE_EXTENSION_AND ; public static final int GENERIC_START = GeneratedJavaTokenTypes . GENERIC_START ; public static final int GENERIC_END = GeneratedJavaTokenTypes . GENERIC_END ; public static final int LAMBDA = GeneratedJavaTokenTypes . LAMBDA ; public static final int SINGLE_LINE_COMMENT = GeneratedJavaTokenTypes . SINGLE_LINE_COMMENT ; public static final int BLOCK_COMMENT_BEGIN = GeneratedJavaTokenTypes . BLOCK_COMMENT_BEGIN ; public static final int BLOCK_COMMENT_END = GeneratedJavaTokenTypes . BLOCK_COMMENT_END ; public static final int COMMENT_CONTENT = GeneratedJavaTokenTypes . COMMENT_CONTENT ; private TokenTypes ( ) { } }
package com . puppycrawl . tools . checkstyle . api ; import com . google . common . collect . ImmutableMap ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import java . util . Map ; public enum JavadocTagInfo { AUTHOR ( "@author" , "author" , Type . BLOCK , true , true ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . PACKAGE_DEF || type == TokenTypes . CLASS_DEF || type == TokenTypes . INTERFACE_DEF || type == TokenTypes . ENUM_DEF || type == TokenTypes . ANNOTATION_DEF ; } } , CODE ( "{@code}" , "code" , Type . INLINE , true , true ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . PACKAGE_DEF || type == TokenTypes . CLASS_DEF || type == TokenTypes . INTERFACE_DEF || type == TokenTypes . ENUM_DEF || type == TokenTypes . ANNOTATION_DEF || type == TokenTypes . METHOD_DEF || type == TokenTypes . CTOR_DEF || type == TokenTypes . VARIABLE_DEF && ! ScopeUtils . isLocalVariableDef ( ast ) ; } } , DOC_ROOT ( "{@docRoot}" , "docRoot" , Type . INLINE , true , true ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . PACKAGE_DEF || type == TokenTypes . CLASS_DEF || type == TokenTypes . INTERFACE_DEF || type == TokenTypes . ENUM_DEF || type == TokenTypes . ANNOTATION_DEF || type == TokenTypes . METHOD_DEF || type == TokenTypes . CTOR_DEF || type == TokenTypes . VARIABLE_DEF && ! ScopeUtils . isLocalVariableDef ( ast ) ; } } , DEPRECATED ( "@deprecated" , "deprecated" , Type . BLOCK , false , false ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . CLASS_DEF || type == TokenTypes . INTERFACE_DEF || type == TokenTypes . ENUM_DEF || type == TokenTypes . ANNOTATION_DEF || type == TokenTypes . METHOD_DEF || type == TokenTypes . CTOR_DEF || type == TokenTypes . ENUM_CONSTANT_DEF || type == TokenTypes . ANNOTATION_FIELD_DEF || type == TokenTypes . VARIABLE_DEF && ! ScopeUtils . isLocalVariableDef ( ast ) ; } } , EXCEPTION ( "@exception" , "exception" , Type . BLOCK , false , false ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . METHOD_DEF || type == TokenTypes . CTOR_DEF ; } } , INHERIT_DOC ( "{@inheritDoc}" , "inheritDoc" , Type . INLINE , false , false ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . METHOD_DEF && ! ast . branchContains ( TokenTypes . LITERAL_STATIC ) && ScopeUtils . getScopeFromMods ( ast . findFirstToken ( TokenTypes . MODIFIERS ) ) != Scope . PRIVATE ; } } , LINK ( "{@link}" , "link" , Type . INLINE , true , true ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . PACKAGE_DEF || type == TokenTypes . CLASS_DEF || type == TokenTypes . INTERFACE_DEF || type == TokenTypes . ENUM_DEF || type == TokenTypes . ANNOTATION_DEF || type == TokenTypes . METHOD_DEF || type == TokenTypes . CTOR_DEF || type == TokenTypes . VARIABLE_DEF && ! ScopeUtils . isLocalVariableDef ( ast ) ; } } , LINKPLAIN ( "{@linkplain}" , "linkplain" , Type . INLINE , true , true ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . PACKAGE_DEF || type == TokenTypes . CLASS_DEF || type == TokenTypes . INTERFACE_DEF || type == TokenTypes . ENUM_DEF || type == TokenTypes . ANNOTATION_DEF || type == TokenTypes . METHOD_DEF || type == TokenTypes . CTOR_DEF || type == TokenTypes . VARIABLE_DEF && ! ScopeUtils . isLocalVariableDef ( ast ) ; } } , LITERAL ( "{@literal}" , "literal" , Type . INLINE , true , true ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . PACKAGE_DEF || type == TokenTypes . CLASS_DEF || type == TokenTypes . INTERFACE_DEF || type == TokenTypes . ENUM_DEF || type == TokenTypes . ANNOTATION_DEF || type == TokenTypes . METHOD_DEF || type == TokenTypes . CTOR_DEF || type == TokenTypes . VARIABLE_DEF && ! ScopeUtils . isLocalVariableDef ( ast ) ; } } , PARAM ( "@param" , "param" , Type . BLOCK , false , false ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . CLASS_DEF || type == TokenTypes . INTERFACE_DEF || type == TokenTypes . METHOD_DEF || type == TokenTypes . CTOR_DEF ; } } , RETURN ( "@return" , "return" , Type . BLOCK , false , false ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; final DetailAST returnType = ast . findFirstToken ( TokenTypes . TYPE ) ; return type == TokenTypes . METHOD_DEF && returnType . getFirstChild ( ) . getType ( ) != TokenTypes . LITERAL_VOID ; } } , SEE ( "@see" , "see" , Type . BLOCK , true , true ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . PACKAGE_DEF || type == TokenTypes . CLASS_DEF || type == TokenTypes . INTERFACE_DEF || type == TokenTypes . ENUM_DEF || type == TokenTypes . ANNOTATION_DEF || type == TokenTypes . METHOD_DEF || type == TokenTypes . CTOR_DEF || type == TokenTypes . VARIABLE_DEF && ! ScopeUtils . isLocalVariableDef ( ast ) ; } } , SERIAL ( "@serial" , "serial" , Type . BLOCK , true , false ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . VARIABLE_DEF && ! ScopeUtils . isLocalVariableDef ( ast ) ; } } , SERIAL_DATA ( "@serialData" , "serialData" , Type . BLOCK , false , false ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; final DetailAST methodNameAst = ast . findFirstToken ( TokenTypes . IDENT ) ; final String methodName = methodNameAst . getText ( ) ; return type == TokenTypes . METHOD_DEF && ( "writeObject" . equals ( methodName ) || "readObject" . equals ( methodName ) || "writeExternal" . equals ( methodName ) || "readExternal" . equals ( methodName ) || "writeReplace" . equals ( methodName ) || "readResolve" . equals ( methodName ) ) ; } } , SERIAL_FIELD ( "@serialField" , "serialField" , Type . BLOCK , false , false ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; final DetailAST varType = ast . findFirstToken ( TokenTypes . TYPE ) ; return type == TokenTypes . VARIABLE_DEF && varType . getType ( ) == TokenTypes . ARRAY_DECLARATOR && "ObjectStreafield" . equals ( varType . getFirstChild ( ) . getText ( ) ) ; } } , SINCE ( "@since" , "since" , Type . BLOCK , true , true ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . PACKAGE_DEF || type == TokenTypes . CLASS_DEF || type == TokenTypes . INTERFACE_DEF || type == TokenTypes . ENUM_DEF || type == TokenTypes . ANNOTATION_DEF || type == TokenTypes . METHOD_DEF || type == TokenTypes . CTOR_DEF || type == TokenTypes . VARIABLE_DEF && ! ScopeUtils . isLocalVariableDef ( ast ) ; } } , THROWS ( "@throws" , "throws" , Type . BLOCK , false , false ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . METHOD_DEF || type == TokenTypes . CTOR_DEF ; } } , VALUE ( "{@value}" , "value" , Type . INLINE , true , true ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . PACKAGE_DEF || type == TokenTypes . CLASS_DEF || type == TokenTypes . INTERFACE_DEF || type == TokenTypes . ENUM_DEF || type == TokenTypes . ANNOTATION_DEF || type == TokenTypes . METHOD_DEF || type == TokenTypes . CTOR_DEF || type == TokenTypes . VARIABLE_DEF && ! ScopeUtils . isLocalVariableDef ( ast ) ; } } , VERSION ( "@version" , "version" , Type . BLOCK , true , true ) { @ Override public boolean isValidOn ( final DetailAST ast ) { final int type = ast . getType ( ) ; return type == TokenTypes . PACKAGE_DEF || type == TokenTypes . CLASS_DEF || type == TokenTypes . INTERFACE_DEF || type == TokenTypes . ENUM_DEF || type == TokenTypes . ANNOTATION_DEF ; } } ; private static final Map < String , JavadocTagInfo > TEXT_TO_TAG ; private static final Map < String , JavadocTagInfo > NAME_TO_TAG ; static { final ImmutableMap . Builder < String , JavadocTagInfo > textToTagBuilder = new ImmutableMap . Builder < > ( ) ; final ImmutableMap . Builder < String , JavadocTagInfo > nameToTagBuilder = new ImmutableMap . Builder < > ( ) ; for ( final JavadocTagInfo tag : JavadocTagInfo . values ( ) ) { textToTagBuilder . put ( tag . getText ( ) , tag ) ; nameToTagBuilder . put ( tag . getName ( ) , tag ) ; } TEXT_TO_TAG = textToTagBuilder . build ( ) ; NAME_TO_TAG = nameToTagBuilder . build ( ) ; } private final String text ; private final String name ; private final Type type ; private final boolean validInPackageHtml ; private final boolean validInOverviewHtml ; private JavadocTagInfo ( final String text , final String name , final Type type , final boolean validInPackageHtml , final boolean validInOverviewHtml ) { this . text = text ; this . name = name ; this . type = type ; this . validInPackageHtml = validInPackageHtml ; this . validInOverviewHtml = validInOverviewHtml ; } public abstract boolean isValidOn ( DetailAST ast ) ; public boolean isValidInPackageHtml ( ) { return this . validInPackageHtml ; } public boolean isValidInOverviewHtml ( ) { return this . validInOverviewHtml ; } public String getText ( ) { return this . text ; } public String getName ( ) { return this . name ; } public Type getType ( ) { return this . type ; } public static JavadocTagInfo fromText ( final String text ) { if ( text == null ) { throw new IllegalArgumentException ( "the text is null" ) ; } final JavadocTagInfo tag = TEXT_TO_TAG . get ( text ) ; if ( tag == null ) { throw new IllegalArgumentException ( "the text [" + text + "] is not a valid Javadoc tag text" ) ; } return tag ; } public static JavadocTagInfo fromName ( final String name ) { if ( name == null ) { throw new IllegalArgumentException ( "the name is null" ) ; } final JavadocTagInfo tag = NAME_TO_TAG . get ( name ) ; if ( tag == null ) { throw new IllegalArgumentException ( "the name [" + name + "] is not a valid Javadoc tag name" ) ; } return tag ; } public static boolean isValidName ( final String name ) { return NAME_TO_TAG . containsKey ( name ) ; } @ Override public String toString ( ) { return "text [" + this . text + "] name [" + this . name + "] type [" + this . type + "] validInPackageHtml [" + this . validInPackageHtml + "] validInOverviewHtml [" + this . validInOverviewHtml + "]" ; } public enum Type { BLOCK , INLINE } }
package com . puppycrawl . tools . checkstyle . api ; public class Comment implements TextBlock { private final String [ ] text ; private final int firstLine ; private final int lastLine ; private final int firstCol ; private final int lastCol ; public Comment ( final String [ ] text , final int firstCol , final int lastLine , final int lastCol ) { this . text = new String [ text . length ] ; System . arraycopy ( text , 0 , this . text , 0 , this . text . length ) ; firstLine = lastLine - this . text . length + 1 ; this . lastLine = lastLine ; this . firstCol = firstCol ; this . lastCol = lastCol ; } @ Override public final String [ ] getText ( ) { return text . clone ( ) ; } @ Override public final int getStartLineNo ( ) { return firstLine ; } @ Override public final int getEndLineNo ( ) { return lastLine ; } @ Override public int getStartColNo ( ) { return firstCol ; } @ Override public int getEndColNo ( ) { return lastCol ; } @ Override public boolean intersects ( int startLineNo , int startColNo , int endLineNo , int endColNo ) { final long multiplier = Integer . MAX_VALUE ; final long thisStart = firstLine * multiplier + firstCol ; final long thisEnd = lastLine * multiplier + lastCol ; final long inStart = startLineNo * multiplier + startColNo ; final long inEnd = endLineNo * multiplier + endColNo ; return ! ( thisEnd < inStart || inEnd < thisStart ) ; } @ Override public String toString ( ) { return "Comment[" + firstLine + ":" + firstCol + "-" + lastLine + ":" + lastCol + "]" ; } }
package com . puppycrawl . tools . checkstyle . api ; import java . util . EventObject ; public final class AuditEvent extends EventObject { private static final long serialVersionUID = - 3774725606973812736L ; private final String fileName ; private final LocalizedMessage message ; public AuditEvent ( Object source ) { this ( source , null ) ; } public AuditEvent ( Object src , String fileName ) { this ( src , fileName , null ) ; } public AuditEvent ( Object src , String fileName , LocalizedMessage message ) { super ( src ) ; this . fileName = fileName ; this . message = message ; } public String getFileName ( ) { return fileName ; } public int getLine ( ) { return message . getLineNo ( ) ; } public String getMessage ( ) { return message . getMessage ( ) ; } public int getColumn ( ) { return message . getColumnNo ( ) ; } public SeverityLevel getSeverityLevel ( ) { return message == null ? SeverityLevel . INFO : message . getSeverityLevel ( ) ; } public String getModuleId ( ) { return message . getModuleId ( ) ; } public String getSourceName ( ) { return message . getSourceName ( ) ; } public LocalizedMessage getLocalizedMessage ( ) { return message ; } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . TodoCommentCheck . MSG_KEY ; public class TodoCommentCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( TodoCommentCheck . class ) ; checkConfig . addAttribute ( "format" , "FIXME:" ) ; final String [ ] expected = { "161: " + getCheckMessage ( MSG_KEY , "FIXME:" ) , "162: " + getCheckMessage ( MSG_KEY , "FIXME:" ) , "163: " + getCheckMessage ( MSG_KEY , "FIXME:" ) , "167: " + getCheckMessage ( MSG_KEY , "FIXME:" ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser ; public final class JavadocTokenTypes { private static final int RULE_TYPES_OFFSET = 10000 ; public static final int JAVADOC = JavadocParser . RULE_javadoc + RULE_TYPES_OFFSET ; public static final int JAVADOC_TAG = JavadocParser . RULE_javadocTag + RULE_TYPES_OFFSET ; public static final int JAVADOC_INLINE_TAG = JavadocParser . RULE_javadocInlineTag + RULE_TYPES_OFFSET ; public static final int RETURN_LITERAL = JavadocParser . RETURN_LITERAL ; public static final int DEPRECATED_LITERAL = JavadocParser . DEPRECATED_LITERAL ; public static final int SINCE_LITERAL = JavadocParser . SINCE_LITERAL ; public static final int SERIAL_DATA_LITERAL = JavadocParser . SERIAL_DATA_LITERAL ; public static final int SERIAL_FIELD_LITERAL = JavadocParser . SERIAL_FIELD_LITERAL ; public static final int PARAM_LITERAL = JavadocParser . PARAM_LITERAL ; public static final int SEE_LITERAL = JavadocParser . SEE_LITERAL ; public static final int SERIAL_LITERAL = JavadocParser . SERIAL_LITERAL ; public static final int VERSION_LITERAL = JavadocParser . VERSION_LITERAL ; public static final int EXCEPTION_LITERAL = JavadocParser . EXCEPTION_LITERAL ; public static final int THROWS_LITERAL = JavadocParser . THROWS_LITERAL ; public static final int AUTHOR_LITERAL = JavadocParser . AUTHOR_LITERAL ; public static final int CUSTOM_NAME = JavadocParser . CUSTOM_NAME ; public static final int JAVADOC_INLINE_TAG_START = JavadocParser . JAVADOC_INLINE_TAG_START ; public static final int JAVADOC_INLINE_TAG_END = JavadocParser . JAVADOC_INLINE_TAG_END ; public static final int CODE_LITERAL = JavadocParser . CODE_LITERAL ; public static final int DOC_ROOT_LITERAL = JavadocParser . DOC_ROOT_LITERAL ; public static final int LINK_LITERAL = JavadocParser . LINK_LITERAL ; public static final int INHERIT_DOC_LITERAL = JavadocParser . INHERIT_DOC_LITERAL ; public static final int LINKPLAIN_LITERAL = JavadocParser . LINKPLAIN_LITERAL ; public static final int LITERAL_LITERAL = JavadocParser . LITERAL_LITERAL ; public static final int VALUE_LITERAL = JavadocParser . VALUE_LITERAL ; public static final int REFERENCE = JavadocParser . RULE_reference + RULE_TYPES_OFFSET ; public static final int PACKAGE = JavadocParser . PACKAGE ; public static final int CLASS = JavadocParser . CLASS ; public static final int DOT = JavadocParser . DOT ; public static final int HASH = JavadocParser . HASH ; public static final int MEMBER = JavadocParser . MEMBER ; public static final int PARAMETERS = JavadocParser . RULE_parameters + RULE_TYPES_OFFSET ; public static final int LEFT_BRACE = JavadocParser . LEFT_BRACE ; public static final int RIGHT_BRACE = JavadocParser . RIGHT_BRACE ; public static final int ARGUMENT = JavadocParser . ARGUMENT ; public static final int COMMA = JavadocParser . COMMA ; public static final int STRING = JavadocParser . STRING ; public static final int DESCRIPTION = JavadocParser . RULE_description + RULE_TYPES_OFFSET ; public static final int CLASS_NAME = JavadocParser . CLASS_NAME ; public static final int PARAMETER_NAME = JavadocParser . PARAMETER_NAME ; public static final int LITERAL_EXCLUDE = JavadocParser . LITERAL_EXCLUDE ; public static final int LITERAL_INCLUDE = JavadocParser . LITERAL_INCLUDE ; public static final int FIELD_NAME = JavadocParser . FIELD_NAME ; public static final int FIELD_TYPE = JavadocParser . FIELD_TYPE ; public static final int HTML_ELEMENT = JavadocParser . RULE_htmlElement + RULE_TYPES_OFFSET ; public static final int HTML_ELEMENT_OPEN = JavadocParser . RULE_htmlElementOpen + RULE_TYPES_OFFSET + RULE_TYPES_OFFSET ; public static final int HTML_ELEMENT_CLOSE = JavadocParser . RULE_htmlElementClose + RULE_TYPES_OFFSET ; public static final int HTML_TAG = JavadocParser . RULE_htmlTag + RULE_TYPES_OFFSET ; public static final int HTML_TAG_NAME = JavadocParser . HTML_TAG_NAME ; public static final int ATTRIBUTE = JavadocParser . RULE_attribute + RULE_TYPES_OFFSET + RULE_TYPES_OFFSET ; public static final int OPEN = JavadocParser . OPEN ; public static final int SLASH = JavadocParser . SLASH ; public static final int CLOSE = JavadocParser . CLOSE ; public static final int SLASH_CLOSE = JavadocParser . SLASH_CLOSE ; public static final int EQUALS = JavadocParser . EQUALS ; public static final int ATTR_VALUE = JavadocParser . ATTR_VALUE ; public static final int PARAGRAPH = JavadocParser . RULE_paragraph + RULE_TYPES_OFFSET ; public static final int P_TAG_OPEN = JavadocParser . RULE_pTagOpen + RULE_TYPES_OFFSET ; public static final int P_TAG_CLOSE = JavadocParser . RULE_pTagClose + RULE_TYPES_OFFSET ; public static final int P_HTML_TAG_NAME = JavadocParser . P_HTML_TAG_NAME ; public static final int LI = JavadocParser . RULE_li + RULE_TYPES_OFFSET ; public static final int LI_TAG_OPEN = JavadocParser . RULE_liTagOpen + RULE_TYPES_OFFSET ; public static final int LI_TAG_CLOSE = JavadocParser . RULE_liTagClose + RULE_TYPES_OFFSET ; public static final int LI_HTML_TAG_NAME = JavadocParser . LI_HTML_TAG_NAME ; public static final int TR = JavadocParser . RULE_tr + RULE_TYPES_OFFSET ; public static final int TR_TAG_OPEN = JavadocParser . RULE_trTagOpen + RULE_TYPES_OFFSET ; public static final int TR_TAG_CLOSE = JavadocParser . RULE_trTagClose + RULE_TYPES_OFFSET ; public static final int TR_HTML_TAG_NAME = JavadocParser . TR_HTML_TAG_NAME ; public static final int TD = JavadocParser . RULE_td + RULE_TYPES_OFFSET ; public static final int TD_TAG_OPEN = JavadocParser . RULE_tdTagOpen + RULE_TYPES_OFFSET ; public static final int TD_TAG_CLOSE = JavadocParser . RULE_tdTagClose + RULE_TYPES_OFFSET ; public static final int TD_HTML_TAG_NAME = JavadocParser . TD_HTML_TAG_NAME ; public static final int TH = JavadocParser . RULE_th + RULE_TYPES_OFFSET ; public static final int TH_TAG_OPEN = JavadocParser . RULE_thTagOpen + RULE_TYPES_OFFSET ; public static final int TH_TAG_CLOSE = JavadocParser . RULE_thTagClose + RULE_TYPES_OFFSET ; public static final int TH_HTML_TAG_NAME = JavadocParser . TH_HTML_TAG_NAME ; public static final int BODY = JavadocParser . RULE_body + RULE_TYPES_OFFSET ; public static final int BODY_TAG_OPEN = JavadocParser . RULE_bodyTagOpen + RULE_TYPES_OFFSET ; public static final int BODY_TAG_CLOSE = JavadocParser . RULE_bodyTagClose + RULE_TYPES_OFFSET ; public static final int BODY_HTML_TAG_NAME = JavadocParser . BODY_HTML_TAG_NAME ; public static final int COLGROUP = JavadocParser . RULE_colgroup + RULE_TYPES_OFFSET ; public static final int COLGROUP_TAG_OPEN = JavadocParser . RULE_colgroupTagOpen + RULE_TYPES_OFFSET ; public static final int COLGROUP_TAG_CLOSE = JavadocParser . RULE_colgroupTagClose + RULE_TYPES_OFFSET ; public static final int COLGROUP_HTML_TAG_NAME = JavadocParser . COLGROUP_HTML_TAG_NAME ; public static final int DD = JavadocParser . RULE_dd + RULE_TYPES_OFFSET ; public static final int DD_TAG_OPEN = JavadocParser . RULE_ddTagOpen + RULE_TYPES_OFFSET ; public static final int DD_TAG_CLOSE = JavadocParser . RULE_ddTagClose + RULE_TYPES_OFFSET ; public static final int DD_HTML_TAG_NAME = JavadocParser . DD_HTML_TAG_NAME ; public static final int DT = JavadocParser . RULE_dt + RULE_TYPES_OFFSET ; public static final int DT_TAG_OPEN = JavadocParser . RULE_dtTagOpen + RULE_TYPES_OFFSET ; public static final int DT_TAG_CLOSE = JavadocParser . RULE_dtTagClose + RULE_TYPES_OFFSET ; public static final int DT_HTML_TAG_NAME = JavadocParser . DT_HTML_TAG_NAME ; public static final int HEAD = JavadocParser . RULE_head + RULE_TYPES_OFFSET ; public static final int HEAD_TAG_OPEN = JavadocParser . RULE_headTagOpen + RULE_TYPES_OFFSET ; public static final int HEAD_TAG_CLOSE = JavadocParser . RULE_headTagClose + RULE_TYPES_OFFSET ; public static final int HEAD_HTML_TAG_NAME = JavadocParser . HEAD_HTML_TAG_NAME ; public static final int HTML = JavadocParser . RULE_html + RULE_TYPES_OFFSET ; public static final int HTML_TAG_OPEN = JavadocParser . RULE_htmlTagOpen + RULE_TYPES_OFFSET ; public static final int HTML_TAG_CLOSE = JavadocParser . RULE_htmlTagClose + RULE_TYPES_OFFSET ; public static final int HTML_HTML_TAG_NAME = JavadocParser . HTML_HTML_TAG_NAME ; public static final int OPTION = JavadocParser . RULE_option + RULE_TYPES_OFFSET ; public static final int OPTION_TAG_OPEN = JavadocParser . RULE_optionTagOpen + RULE_TYPES_OFFSET ; public static final int OPTION_TAG_CLOSE = JavadocParser . RULE_optionTagClose + RULE_TYPES_OFFSET ; public static final int OPTION_HTML_TAG_NAME = JavadocParser . OPTION_HTML_TAG_NAME ; public static final int TBODY = JavadocParser . RULE_tbody + RULE_TYPES_OFFSET ; public static final int TBODY_TAG_OPEN = JavadocParser . RULE_tbodyTagOpen + RULE_TYPES_OFFSET ; public static final int TBODY_TAG_CLOSE = JavadocParser . RULE_tbodyTagClose + RULE_TYPES_OFFSET ; public static final int TBODY_HTML_TAG_NAME = JavadocParser . TBODY_HTML_TAG_NAME ; public static final int TFOOT = JavadocParser . RULE_tfoot + RULE_TYPES_OFFSET ; public static final int TFOOT_TAG_OPEN = JavadocParser . RULE_tfootTagOpen + RULE_TYPES_OFFSET ; public static final int TFOOT_TAG_CLOSE = JavadocParser . RULE_tfootTagClose + RULE_TYPES_OFFSET ; public static final int TFOOT_HTML_TAG_NAME = JavadocParser . TFOOT_HTML_TAG_NAME ; public static final int THEAD = JavadocParser . RULE_thead + RULE_TYPES_OFFSET ; public static final int THEAD_TAG_OPEN = JavadocParser . RULE_theadTagOpen + RULE_TYPES_OFFSET ; public static final int THEAD_TAG_CLOSE = JavadocParser . RULE_theadTagClose + RULE_TYPES_OFFSET ; public static final int THEAD_HTML_TAG_NAME = JavadocParser . THEAD_HTML_TAG_NAME ; public static final int SINGLETON_ELEMENT = JavadocParser . RULE_singletonElement + RULE_TYPES_OFFSET ; public static final int SINGLETON_TAG = JavadocParser . RULE_singletonTag + RULE_TYPES_OFFSET ; public static final int AREA_TAG = JavadocParser . RULE_areaTag + RULE_TYPES_OFFSET ; public static final int AREA_HTML_TAG_NAME = JavadocParser . AREA_HTML_TAG_NAME ; public static final int BASE_TAG = JavadocParser . RULE_baseTag + RULE_TYPES_OFFSET ; public static final int BASE_HTML_TAG_NAME = JavadocParser . BASE_HTML_TAG_NAME ; public static final int BASEFRONT_TAG = JavadocParser . RULE_basefrontTag + RULE_TYPES_OFFSET ; public static final int BASEFRONT_HTML_TAG_NAME = JavadocParser . BASEFRONT_HTML_TAG_NAME ; public static final int BR_TAG = JavadocParser . RULE_brTag + RULE_TYPES_OFFSET ; public static final int BR_HTML_TAG_NAME = JavadocParser . BR_HTML_TAG_NAME ; public static final int COL_TAG = JavadocParser . RULE_colTag + RULE_TYPES_OFFSET ; public static final int COL_HTML_TAG_NAME = JavadocParser . COL_HTML_TAG_NAME ; public static final int FRAME_TAG = JavadocParser . RULE_frameTag + RULE_TYPES_OFFSET ; public static final int FRAME_HTML_TAG_NAME = JavadocParser . FRAME_HTML_TAG_NAME ; public static final int HR_TAG = JavadocParser . RULE_hrTag + RULE_TYPES_OFFSET ; public static final int HR_HTML_TAG_NAME = JavadocParser . HR_HTML_TAG_NAME ; public static final int IMG_TAG = JavadocParser . RULE_imgTag + RULE_TYPES_OFFSET ; public static final int IMG_HTML_TAG_NAME = JavadocParser . IMG_HTML_TAG_NAME ; public static final int INPUT_TAG = JavadocParser . RULE_inputTag + RULE_TYPES_OFFSET ; public static final int INPUT_HTML_TAG_NAME = JavadocParser . INPUT_HTML_TAG_NAME ; public static final int ISINDEX_TAG = JavadocParser . RULE_isindexTag + RULE_TYPES_OFFSET ; public static final int ISINDEX_HTML_TAG_NAME = JavadocParser . ISINDEX_HTML_TAG_NAME ; public static final int LINK_TAG = JavadocParser . RULE_linkTag + RULE_TYPES_OFFSET ; public static final int LINK_HTML_TAG_NAME = JavadocParser . LINK_HTML_TAG_NAME ; public static final int META_TAG = JavadocParser . RULE_metaTag + RULE_TYPES_OFFSET ; public static final int META_HTML_TAG_NAME = JavadocParser . META_HTML_TAG_NAME ; public static final int PARAM_TAG = JavadocParser . RULE_paramTag + RULE_TYPES_OFFSET ; public static final int PARAM_HTML_TAG_NAME = JavadocParser . PARAM_HTML_TAG_NAME ; public static final int HTML_COMMENT = JavadocParser . RULE_htmlComment + RULE_TYPES_OFFSET + RULE_TYPES_OFFSET ; public static final int HTML_COMMENT_START = JavadocParser . HTML_COMMENT_START ; public static final int HTML_COMMENT_END = JavadocParser . HTML_COMMENT_END ; public static final int CDATA = JavadocParser . CDATA ; public static final int LEADING_ASTERISK = JavadocParser . LEADING_ASTERISK ; public static final int NEWLINE = JavadocParser . NEWLINE ; public static final int CHAR = JavadocParser . CHAR ; public static final int WS = JavadocParser . WS ; public static final int TEXT = JavadocParser . RULE_text + RULE_TYPES_OFFSET ; public static final int EOF = JavadocParser . EOF ; private JavadocTokenTypes ( ) { } }
package com . puppycrawl . tools . checkstyle . api ; import java . util . Objects ; public class LineColumn implements Comparable < LineColumn > { private final int line ; private final int col ; public LineColumn ( int line , int col ) { this . line = line ; this . col = col ; } public int getLine ( ) { return line ; } public int getColumn ( ) { return col ; } @ Override public int compareTo ( LineColumn lineColumn ) { return this . getLine ( ) != lineColumn . getLine ( ) ? this . getLine ( ) - lineColumn . getLine ( ) : this . getColumn ( ) - lineColumn . getColumn ( ) ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } final LineColumn that = ( LineColumn ) o ; return Objects . equals ( line , that . line ) && Objects . equals ( col , that . col ) ; } @ Override public int hashCode ( ) { return Objects . hash ( line , col ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import java . util . Locale ; public enum Scope { NOTHING , PUBLIC , PROTECTED , PACKAGE , PRIVATE , ANONINNER ; @ Override public String toString ( ) { return getName ( ) ; } public String getName ( ) { return name ( ) . toLowerCase ( Locale . ENGLISH ) ; } public boolean isIn ( Scope scope ) { return compareTo ( scope ) <= 0 ; } public static Scope getInstance ( String scopeName ) { return valueOf ( Scope . class , scopeName . trim ( ) . toUpperCase ( Locale . ENGLISH ) ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import java . io . File ; import java . util . Arrays ; import java . util . List ; import java . util . SortedSet ; import com . puppycrawl . tools . checkstyle . Utils ; public abstract class AbstractFileSetCheck extends AbstractViolationReporter implements FileSetCheck { private MessageDispatcher dispatcher ; private String [ ] fileExtensions = { } ; private final LocalizedMessages messages = new LocalizedMessages ( ) ; protected abstract void processFiltered ( File file , List < String > lines ) ; @ Override public void init ( ) { } @ Override public void destroy ( ) { } @ Override public void beginProcessing ( String charset ) { } @ Override public final SortedSet < LocalizedMessage > process ( File file , List < String > lines ) { getMessageCollector ( ) . reset ( ) ; if ( Utils . fileExtensionMatches ( file , fileExtensions ) ) { processFiltered ( file , lines ) ; } return getMessageCollector ( ) . getMessages ( ) ; } @ Override public void finishProcessing ( ) { } @ Override public final void setMessageDispatcher ( MessageDispatcher dispatcher ) { this . dispatcher = dispatcher ; } protected final MessageDispatcher getMessageDispatcher ( ) { return dispatcher ; } public String [ ] getFileExtensions ( ) { return Arrays . copyOf ( fileExtensions , fileExtensions . length ) ; } public final void setFileExtensions ( String ... extensions ) { if ( extensions == null ) { fileExtensions = null ; return ; } fileExtensions = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { final String extension = extensions [ i ] ; if ( Utils . startsWithChar ( extension , '.' ) ) { fileExtensions [ i ] = extension ; } else { fileExtensions [ i ] = "." + extension ; } } } protected final LocalizedMessages getMessageCollector ( ) { return messages ; } @ Override public final void log ( int line , String key , Object ... args ) { log ( line , 0 , key , args ) ; } @ Override public final void log ( int lineNo , int colNo , String key , Object ... args ) { getMessageCollector ( ) . add ( new LocalizedMessage ( lineNo , colNo , getMessageBundle ( ) , key , args , getSeverityLevel ( ) , getId ( ) , this . getClass ( ) , this . getCustomMessages ( ) . get ( key ) ) ) ; } protected final void fireErrors ( String fileName ) { final SortedSet < LocalizedMessage > errors = getMessageCollector ( ) . getMessages ( ) ; getMessageCollector ( ) . reset ( ) ; getMessageDispatcher ( ) . fireErrors ( fileName , errors ) ; } }
package com . puppycrawl . tools . checkstyle . api ; public interface Filter { boolean accept ( AuditEvent event ) ; }
package com . puppycrawl . tools . checkstyle . api ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . io . UnsupportedEncodingException ; import java . nio . ByteBuffer ; import java . nio . charset . Charset ; import java . nio . charset . CharsetDecoder ; import java . nio . charset . CodingErrorAction ; import java . nio . charset . UnsupportedCharsetException ; import java . util . AbstractList ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . ConcurrentModificationException ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import com . google . common . io . Closeables ; public final class FileText extends AbstractList < String > { private static final int READ_BUFFER_SIZE = 1024 ; private static final Pattern LINE_TERMINATOR = Pattern . compile ( "\\n|\\r\\n?" ) ; private final File file ; private final Charset charset ; private final String fullText ; private final String [ ] lines ; private int [ ] lineBreaks ; public FileText ( File file , String charsetName ) throws IOException { this . file = file ; final CharsetDecoder decoder ; try { charset = Charset . forName ( charsetName ) ; decoder = charset . newDecoder ( ) ; decoder . onMalformedInput ( CodingErrorAction . REPLACE ) ; decoder . onUnmappableCharacter ( CodingErrorAction . REPLACE ) ; } catch ( final UnsupportedCharsetException ex ) { final String message = "Unsupported charset: " + charsetName ; final UnsupportedEncodingException ex2 ; ex2 = new UnsupportedEncodingException ( message ) ; ex2 . initCause ( ex ) ; throw ex2 ; } final char [ ] chars = new char [ READ_BUFFER_SIZE ] ; final StringBuilder buf = new StringBuilder ( ) ; final FileInputStream stream = new FileInputStream ( file ) ; final Reader reader = new InputStreamReader ( stream , decoder ) ; try { while ( true ) { final int len = reader . read ( chars ) ; if ( len < 0 ) { break ; } buf . append ( chars , 0 , len ) ; } } finally { Closeables . closeQuietly ( reader ) ; } fullText = buf . toString ( ) ; final ArrayList < String > lines = new ArrayList < > ( ) ; final BufferedReader br = new BufferedReader ( new StringReader ( fullText ) ) ; for ( ; ; ) { final String l = br . readLine ( ) ; if ( null == l ) { break ; } lines . add ( l ) ; } this . lines = lines . toArray ( new String [ lines . size ( ) ] ) ; } private FileText ( File file , List < String > lines ) { final StringBuilder buf = new StringBuilder ( ) ; for ( final String line : lines ) { buf . append ( line ) . append ( '\n' ) ; } buf . trimToSize ( ) ; this . file = file ; charset = null ; fullText = buf . toString ( ) ; this . lines = lines . toArray ( new String [ lines . size ( ) ] ) ; } public static FileText fromLines ( File file , List < String > lines ) { return lines instanceof FileText ? ( FileText ) lines : new FileText ( file , lines ) ; } public File getFile ( ) { return file ; } public Charset getCharset ( ) { return charset ; } public ByteBuffer getBytes ( ) throws IOException { if ( file == null ) { return null ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IOException ( "File too large." ) ; } byte [ ] bytes = new byte [ ( int ) file . length ( ) + 1 ] ; final FileInputStream stream = new FileInputStream ( file ) ; try { int fill = 0 ; while ( true ) { if ( fill >= bytes . length ) { final byte [ ] newBytes = new byte [ bytes . length * 2 + 1 ] ; System . arraycopy ( bytes , 0 , newBytes , 0 , fill ) ; bytes = newBytes ; } final int len = stream . read ( bytes , fill , bytes . length - fill ) ; if ( len == - 1 ) { break ; } fill += len ; } return ByteBuffer . wrap ( bytes , 0 , fill ) . asReadOnlyBuffer ( ) ; } finally { Closeables . closeQuietly ( stream ) ; } } public CharSequence getFullText ( ) { return fullText ; } public String [ ] toLinesArray ( ) { return lines . clone ( ) ; } private int [ ] findLineBreaks ( ) { if ( lineBreaks == null ) { final int [ ] lineBreaks = new int [ size ( ) + 1 ] ; lineBreaks [ 0 ] = 0 ; int lineNo = 1 ; final Matcher matcher = LINE_TERMINATOR . matcher ( fullText ) ; while ( matcher . find ( ) ) { lineBreaks [ lineNo ++ ] = matcher . end ( ) ; } if ( lineNo < lineBreaks . length ) { lineBreaks [ lineNo ++ ] = fullText . length ( ) ; } if ( lineNo != lineBreaks . length ) { throw new ConcurrentModificationException ( "Text changed." ) ; } this . lineBreaks = lineBreaks ; } return lineBreaks ; } public LineColumn lineColumn ( int pos ) { final int [ ] lineBreaks = findLineBreaks ( ) ; int lineNo = Arrays . binarySearch ( lineBreaks , pos ) ; if ( lineNo < 0 ) { lineNo = - lineNo - 2 ; } final int startOfLine = lineBreaks [ lineNo ] ; final int columnNo = pos - startOfLine ; return new LineColumn ( lineNo + 1 , columnNo ) ; } @ Override public String get ( final int lineNo ) { return lines [ lineNo ] ; } @ Override public int size ( ) { return lines . length ; } }
package com . puppycrawl . tools . checkstyle . api ; public class CheckstyleException extends Exception { private static final long serialVersionUID = - 3517342299748221108L ; public CheckstyleException ( String message ) { super ( message ) ; } public CheckstyleException ( String message , Throwable cause ) { super ( message , cause ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import java . util . Map ; public abstract class AbstractViolationReporter extends AutomaticBean { private SeverityLevel severityLevel = SeverityLevel . ERROR ; private String id ; public final SeverityLevel getSeverityLevel ( ) { return severityLevel ; } public final void setSeverity ( String severity ) { severityLevel = SeverityLevel . getInstance ( severity ) ; } public final String getSeverity ( ) { return severityLevel . getName ( ) ; } public final String getId ( ) { return id ; } public final void setId ( final String id ) { this . id = id ; } protected final void log ( DetailAST ast , String key , Object ... args ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , key , args ) ; } protected String getMessageBundle ( ) { final String className = this . getClass ( ) . getName ( ) ; return getMessageBundle ( className ) ; } protected Map < String , String > getCustomMessages ( ) { return getConfiguration ( ) . getMessages ( ) ; } String getMessageBundle ( final String className ) { final int endIndex = className . lastIndexOf ( '.' ) ; final String messages = "messages" ; if ( endIndex < 0 ) { return messages ; } final String packageName = className . substring ( 0 , endIndex ) ; return packageName + "." + messages ; } public abstract void log ( int line , String key , Object ... args ) ; public abstract void log ( int line , int col , String key , Object ... args ) ; }
package com . puppycrawl . tools . checkstyle . api ; import com . google . common . collect . ImmutableCollection ; public interface Context { Object get ( String key ) ; ImmutableCollection < String > getAttributeNames ( ) ; }
package com . puppycrawl . tools . checkstyle . api ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . puppycrawl . tools . checkstyle . grammars . CommentListener ; import java . io . File ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . regex . Pattern ; public final class FileContents implements CommentListener { private static final String MATCH_SINGLELINE_COMMENT_PAT = "^\\s*//.*$" ; private static final Pattern MATCH_SINGLELINE_COMMENT = Pattern . compile ( MATCH_SINGLELINE_COMMENT_PAT ) ; private final String fileName ; private final FileText text ; private final Map < Integer , TextBlock > javadocComments = Maps . newHashMap ( ) ; private final Map < Integer , TextBlock > cppComments = Maps . newHashMap ( ) ; private final Map < Integer , List < TextBlock > > clangComments = Maps . newHashMap ( ) ; @ Deprecated public FileContents ( String filename , String ... lines ) { this . fileName = filename ; text = FileText . fromLines ( new File ( filename ) , Arrays . asList ( lines ) ) ; } public FileContents ( FileText text ) { fileName = text . getFile ( ) . toString ( ) ; this . text = text ; } @ Override public void reportSingleLineComment ( String type , int startLineNo , int startColNo ) { reportCppComment ( startLineNo , startColNo ) ; } @ Override public void reportBlockComment ( String type , int startLineNo , int startColNo , int endLineNo , int endColNo ) { reportCComment ( startLineNo , startColNo , endLineNo , endColNo ) ; } public void reportCppComment ( int startLineNo , int startColNo ) { final String line = line ( startLineNo - 1 ) ; final String [ ] txt = new String [ ] { line . substring ( startColNo ) } ; final Comment comment = new Comment ( txt , startColNo , startLineNo , line . length ( ) - 1 ) ; cppComments . put ( startLineNo , comment ) ; } public ImmutableMap < Integer , TextBlock > getCppComments ( ) { return ImmutableMap . copyOf ( cppComments ) ; } public void reportCComment ( int startLineNo , int startColNo , int endLineNo , int endColNo ) { final String [ ] cc = extractCComment ( startLineNo , startColNo , endLineNo , endColNo ) ; final Comment comment = new Comment ( cc , startColNo , endLineNo , endColNo ) ; if ( clangComments . containsKey ( startLineNo ) ) { final List < TextBlock > entries = clangComments . get ( startLineNo ) ; entries . add ( comment ) ; } else { final List < TextBlock > entries = Lists . newArrayList ( ) ; entries . add ( comment ) ; clangComments . put ( startLineNo , entries ) ; } if ( line ( startLineNo - 1 ) . indexOf ( "/**" , startColNo ) != - 1 ) { javadocComments . put ( endLineNo - 1 , comment ) ; } } public ImmutableMap < Integer , List < TextBlock > > getCComments ( ) { return ImmutableMap . copyOf ( clangComments ) ; } private String [ ] extractCComment ( int startLineNo , int startColNo , int endLineNo , int endColNo ) { String [ ] retVal ; if ( startLineNo == endLineNo ) { retVal = new String [ 1 ] ; retVal [ 0 ] = line ( startLineNo - 1 ) . substring ( startColNo , endColNo + 1 ) ; } else { retVal = new String [ endLineNo - startLineNo + 1 ] ; retVal [ 0 ] = line ( startLineNo - 1 ) . substring ( startColNo ) ; for ( int i = startLineNo ; i < endLineNo ; i ++ ) { retVal [ i - startLineNo + 1 ] = line ( i ) ; } retVal [ retVal . length - 1 ] = line ( endLineNo - 1 ) . substring ( 0 , endColNo + 1 ) ; } return retVal ; } public TextBlock getJavadocBefore ( int lineNoBefore ) { int lineNo = lineNoBefore - 2 ; while ( lineNo > 0 && ( lineIsBlank ( lineNo ) || lineIsComment ( lineNo ) ) ) { lineNo -- ; } return javadocComments . get ( lineNo ) ; } private String line ( int lineNo ) { return text . get ( lineNo ) ; } public FileText getText ( ) { return text ; } public String [ ] getLines ( ) { return text . toLinesArray ( ) ; } public String getLine ( int index ) { return text . get ( index ) ; } public String getFileName ( ) { return fileName ; } @ Deprecated public String getFilename ( ) { return getFileName ( ) ; } public boolean lineIsBlank ( int lineNo ) { return "" . equals ( line ( lineNo ) . trim ( ) ) ; } public boolean lineIsComment ( int lineNo ) { return MATCH_SINGLELINE_COMMENT . matcher ( line ( lineNo ) ) . matches ( ) ; } public boolean hasIntersectionWithComment ( int startLineNo , int startColNo , int endLineNo , int endColNo ) { final Collection < List < TextBlock > > values = clangComments . values ( ) ; for ( final List < TextBlock > row : values ) { for ( final TextBlock comment : row ) { if ( comment . intersects ( startLineNo , startColNo , endLineNo , endColNo ) ) { return true ; } } } for ( int lineNumber = startLineNo ; lineNumber <= endLineNo ; lineNumber ++ ) { final TextBlock comment = cppComments . get ( lineNumber ) ; if ( comment != null && comment . intersects ( startLineNo , startColNo , endLineNo , endColNo ) ) { return true ; } } return false ; } public boolean inPackageInfo ( ) { return this . getFileName ( ) . endsWith ( "package-info.java" ) ; } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . UncommentedMainCheck . MSG_KEY ; public class UncommentedMainCheckTest extends BaseCheckTestSupport { @ Test public void testDefaults ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( UncommentedMainCheck . class ) ; final String [ ] expected = { "14: " + getCheckMessage ( MSG_KEY ) , "23: " + getCheckMessage ( MSG_KEY ) , "32: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputUncommentedMain.java" ) , expected ) ; } @ Test public void testExcludedClasses ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( UncommentedMainCheck . class ) ; checkConfig . addAttribute ( "excludedClasses" , "\\.Main.*$" ) ; final String [ ] expected = { "14: " + getCheckMessage ( MSG_KEY ) , "32: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputUncommentedMain.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import java . io . File ; import java . util . List ; import java . util . SortedSet ; public interface FileSetCheck extends Configurable , Contextualizable { void setMessageDispatcher ( MessageDispatcher dispatcher ) ; void init ( ) ; void destroy ( ) ; void beginProcessing ( String charset ) ; SortedSet < LocalizedMessage > process ( File file , List < String > lines ) ; void finishProcessing ( ) ; }
package com . puppycrawl . tools . checkstyle . api ; import java . util . SortedSet ; public interface MessageDispatcher { void fireFileStarted ( String fileName ) ; void fireFileFinished ( String fileName ) ; void fireErrors ( String fileName , SortedSet < LocalizedMessage > errors ) ; }
package com . puppycrawl . tools . checkstyle . api ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public final class FullIdent { private final List < String > elements = new ArrayList < > ( ) ; private int lineNo ; private int colNo ; private FullIdent ( ) { } public String getText ( ) { return StringUtils . join ( elements , "" ) ; } public int getLineNo ( ) { return lineNo ; } public int getColumnNo ( ) { return colNo ; } private void append ( String text ) { elements . add ( text ) ; } private void append ( DetailAST ast ) { elements . add ( ast . getText ( ) ) ; if ( lineNo == 0 ) { lineNo = ast . getLineNo ( ) ; } else if ( ast . getLineNo ( ) > 0 ) { lineNo = Math . min ( lineNo , ast . getLineNo ( ) ) ; } if ( colNo == 0 ) { colNo = ast . getColumnNo ( ) ; } else if ( ast . getColumnNo ( ) > 0 ) { colNo = Math . min ( colNo , ast . getColumnNo ( ) ) ; } } public static FullIdent createFullIdent ( DetailAST ast ) { final FullIdent fi = new FullIdent ( ) ; extractFullIdent ( fi , ast ) ; return fi ; } public static FullIdent createFullIdentBelow ( DetailAST ast ) { return createFullIdent ( ast . getFirstChild ( ) ) ; } private static void extractFullIdent ( FullIdent full , DetailAST ast ) { if ( ast == null ) { return ; } if ( ast . getType ( ) == TokenTypes . DOT ) { extractFullIdent ( full , ast . getFirstChild ( ) ) ; full . append ( "." ) ; extractFullIdent ( full , ast . getFirstChild ( ) . getNextSibling ( ) ) ; } else { full . append ( ast ) ; } } @ Override public String toString ( ) { return getText ( ) + "[" + getLineNo ( ) + "x" + getColumnNo ( ) + "]" ; } }
package com . puppycrawl . tools . checkstyle . api ; public interface TextBlock { String [ ] getText ( ) ; int getStartLineNo ( ) ; int getEndLineNo ( ) ; int getStartColNo ( ) ; int getEndColNo ( ) ; boolean intersects ( int startLineNo , int startColNo , int endLineNo , int endColNo ) ; }
package com . puppycrawl . tools . checkstyle . api ; public interface Contextualizable { void contextualize ( Context context ) throws CheckstyleException ; }
package com . puppycrawl . tools . checkstyle . api ; import java . util . EventListener ; public interface AuditListener extends EventListener { void auditStarted ( AuditEvent evt ) ; void auditFinished ( AuditEvent evt ) ; void fileStarted ( AuditEvent evt ) ; void fileFinished ( AuditEvent evt ) ; void addError ( AuditEvent evt ) ; void addException ( AuditEvent evt , Throwable throwable ) ; }
package com . puppycrawl . tools . checkstyle . api ; import com . google . common . collect . Maps ; import java . io . IOException ; import java . io . InputStream ; import java . util . HashMap ; import java . util . Map ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParserFactory ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . DefaultHandler ; public abstract class AbstractLoader extends DefaultHandler { private final Map < String , String > publicIdToResourceNameMap ; private final XMLReader parser ; protected AbstractLoader ( String publicId , String dtdResourceName ) throws SAXException , ParserConfigurationException { this ( new HashMap < String , String > ( 1 ) ) ; publicIdToResourceNameMap . put ( publicId , dtdResourceName ) ; } protected AbstractLoader ( Map < String , String > publicIdToResourceNameMap ) throws SAXException , ParserConfigurationException { this . publicIdToResourceNameMap = Maps . newHashMap ( publicIdToResourceNameMap ) ; final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; factory . setValidating ( true ) ; factory . setNamespaceAware ( true ) ; parser = factory . newSAXParser ( ) . getXMLReader ( ) ; parser . setContentHandler ( this ) ; parser . setEntityResolver ( this ) ; parser . setErrorHandler ( this ) ; } public void parseInputSource ( InputSource inputSource ) throws IOException , SAXException { parser . parse ( inputSource ) ; } @ Override public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( publicIdToResourceNameMap . keySet ( ) . contains ( publicId ) ) { final String dtdResourceName = publicIdToResourceNameMap . get ( publicId ) ; final ClassLoader loader = this . getClass ( ) . getClassLoader ( ) ; final InputStream dtdIS = loader . getResourceAsStream ( dtdResourceName ) ; if ( dtdIS == null ) { throw new SAXException ( "Unable to load internal dtd " + dtdResourceName ) ; } return new InputSource ( dtdIS ) ; } return super . resolveEntity ( publicId , systemId ) ; } @ Override public void warning ( SAXParseException ex ) throws SAXException { throw ex ; } @ Override public void error ( SAXParseException ex ) throws SAXException { throw ex ; } @ Override public void fatalError ( SAXParseException ex ) throws SAXException { throw ex ; } }
package com . puppycrawl . tools . checkstyle . api ; public interface Configurable { void configure ( Configuration configuration ) throws CheckstyleException ; }
package com . puppycrawl . tools . checkstyle . api ; import com . google . common . collect . ImmutableMap ; import java . io . Serializable ; public interface Configuration extends Serializable { String [ ] getAttributeNames ( ) ; String getAttribute ( String name ) throws CheckstyleException ; Configuration [ ] getChildren ( ) ; String getName ( ) ; ImmutableMap < String , String > getMessages ( ) ; }
package com . puppycrawl . tools . checkstyle . api ; import com . google . common . collect . Sets ; import java . util . Set ; import java . util . SortedSet ; public final class LocalizedMessages { private final Set < LocalizedMessage > messages = Sets . newTreeSet ( ) ; public SortedSet < LocalizedMessage > getMessages ( ) { return Sets . newTreeSet ( messages ) ; } public void reset ( ) { messages . clear ( ) ; } public void add ( LocalizedMessage aMsg ) { messages . add ( aMsg ) ; } public int size ( ) { return messages . size ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks ; import java . io . File ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import org . junit . Test ; public class SuppressWarningsHolderTest extends BaseCheckTestSupport { @ Test public void testOnComplexAnnotations ( ) throws Exception { Configuration checkConfig = createCheckConfig ( SuppressWarningsHolder . class ) ; String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputSuppressWarningsHolder.java" ) , expected ) ; } @ Test public void testCustomAnnotation ( ) throws Exception { Configuration checkConfig = createCheckConfig ( SuppressWarningsHolder . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/InputSuppressWarningsHolder.java" ) . getCanonicalPath ( ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import java . util . Collections ; import java . util . Set ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . Utils ; public abstract class Check extends AbstractViolationReporter { private static final int DEFAULT_TAB_WIDTH = 8 ; private FileContents fileContents ; private final Set < String > tokens = Sets . newHashSet ( ) ; private LocalizedMessages messages ; private int tabWidth = DEFAULT_TAB_WIDTH ; private ClassLoader loader ; public boolean isCommentNodesRequired ( ) { return false ; } public abstract int [ ] getDefaultTokens ( ) ; public int [ ] getAcceptableTokens ( ) { final int [ ] defaultTokens = getDefaultTokens ( ) ; final int [ ] copy = new int [ defaultTokens . length ] ; System . arraycopy ( defaultTokens , 0 , copy , 0 , defaultTokens . length ) ; return copy ; } public int [ ] getRequiredTokens ( ) { return new int [ ] { } ; } public final void setTokens ( String ... strRep ) { Collections . addAll ( tokens , strRep ) ; } public final Set < String > getTokenNames ( ) { return tokens ; } public final void setMessages ( LocalizedMessages messages ) { this . messages = messages ; } public void init ( ) { } public void destroy ( ) { } public void beginTree ( DetailAST rootAST ) { } public void finishTree ( DetailAST rootAST ) { } public void visitToken ( DetailAST ast ) { } public void leaveToken ( DetailAST ast ) { } public final String [ ] getLines ( ) { return getFileContents ( ) . getLines ( ) ; } public final String getLine ( int index ) { return getFileContents ( ) . getLine ( index ) ; } public final void setFileContents ( FileContents contents ) { fileContents = contents ; } public final FileContents getFileContents ( ) { return fileContents ; } public final void setClassLoader ( ClassLoader loader ) { this . loader = loader ; } public final ClassLoader getClassLoader ( ) { return loader ; } protected final int getTabWidth ( ) { return tabWidth ; } public final void setTabWidth ( int tabWidth ) { this . tabWidth = tabWidth ; } @ Override public final void log ( int line , String key , Object ... args ) { messages . add ( new LocalizedMessage ( line , getMessageBundle ( ) , key , args , getSeverityLevel ( ) , getId ( ) , this . getClass ( ) , this . getCustomMessages ( ) . get ( key ) ) ) ; } @ Override public final void log ( int lineNo , int colNo , String key , Object ... args ) { final int col = 1 + Utils . lengthExpandedTabs ( getLines ( ) [ lineNo - 1 ] , colNo , getTabWidth ( ) ) ; messages . add ( new LocalizedMessage ( lineNo , col , getMessageBundle ( ) , key , args , getSeverityLevel ( ) , getId ( ) , this . getClass ( ) , this . getCustomMessages ( ) . get ( key ) ) ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . Serializable ; import java . net . URL ; import java . net . URLConnection ; import java . text . MessageFormat ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import java . util . MissingResourceException ; import java . util . Objects ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; import java . util . ResourceBundle . Control ; public final class LocalizedMessage implements Comparable < LocalizedMessage > , Serializable { private static final long serialVersionUID = 5675176836184862150L ; private static Locale sLocale = Locale . getDefault ( ) ; private static final Map < String , ResourceBundle > BUNDLE_CACHE = Collections . synchronizedMap ( new HashMap < String , ResourceBundle > ( ) ) ; private static final SeverityLevel DEFAULT_SEVERITY = SeverityLevel . ERROR ; private final int lineNo ; private final int colNo ; private final SeverityLevel severityLevel ; private final String moduleId ; private final String key ; private final Object [ ] args ; private final String bundle ; private final Class < ? > sourceClass ; private final String customMessage ; public LocalizedMessage ( int lineNo , int colNo , String bundle , String key , Object [ ] args , SeverityLevel severityLevel , String moduleId , Class < ? > sourceClass , String customMessage ) { this . lineNo = lineNo ; this . colNo = colNo ; this . key = key ; this . args = null == args ? null : args . clone ( ) ; this . bundle = bundle ; this . severityLevel = severityLevel ; this . moduleId = moduleId ; this . sourceClass = sourceClass ; this . customMessage = customMessage ; } public LocalizedMessage ( int lineNo , int colNo , String bundle , String key , Object [ ] args , String moduleId , Class < ? > sourceClass , String customMessage ) { this ( lineNo , colNo , bundle , key , args , DEFAULT_SEVERITY , moduleId , sourceClass , customMessage ) ; } public LocalizedMessage ( int lineNo , String bundle , String key , Object [ ] args , SeverityLevel severityLevel , String moduleId , Class < ? > sourceClass , String customMessage ) { this ( lineNo , 0 , bundle , key , args , severityLevel , moduleId , sourceClass , customMessage ) ; } public LocalizedMessage ( int lineNo , String bundle , String key , Object [ ] args , String moduleId , Class < ? > sourceClass , String customMessage ) { this ( lineNo , 0 , bundle , key , args , DEFAULT_SEVERITY , moduleId , sourceClass , customMessage ) ; } @ Override public boolean equals ( Object object ) { if ( this == object ) { return true ; } if ( object == null || getClass ( ) != object . getClass ( ) ) { return false ; } final LocalizedMessage that = ( LocalizedMessage ) object ; return Objects . equals ( lineNo , that . lineNo ) && Objects . equals ( colNo , that . colNo ) && Objects . equals ( severityLevel , that . severityLevel ) && Objects . equals ( moduleId , that . moduleId ) && Objects . equals ( key , that . key ) && Objects . equals ( bundle , that . bundle ) && Objects . equals ( sourceClass , that . sourceClass ) && Objects . equals ( customMessage , that . customMessage ) && Arrays . equals ( args , that . args ) ; } @ Override public int hashCode ( ) { return Objects . hash ( lineNo , colNo , severityLevel , moduleId , key , bundle , sourceClass , customMessage , Arrays . hashCode ( args ) ) ; } public static void clearCache ( ) { synchronized ( BUNDLE_CACHE ) { BUNDLE_CACHE . clear ( ) ; } } public String getMessage ( ) { final String customMessage = getCustomMessage ( ) ; if ( customMessage != null ) { return customMessage ; } try { final ResourceBundle bundle = getBundle ( this . bundle ) ; final String pattern = bundle . getString ( key ) ; return MessageFormat . format ( pattern , args ) ; } catch ( final MissingResourceException ex ) { return MessageFormat . format ( key , args ) ; } } private String getCustomMessage ( ) { if ( customMessage == null ) { return null ; } return MessageFormat . format ( customMessage , args ) ; } private ResourceBundle getBundle ( String bundleName ) { synchronized ( BUNDLE_CACHE ) { ResourceBundle bundle = BUNDLE_CACHE . get ( bundleName ) ; if ( bundle == null ) { bundle = ResourceBundle . getBundle ( bundleName , sLocale , sourceClass . getClassLoader ( ) , new UTF8Control ( ) ) ; BUNDLE_CACHE . put ( bundleName , bundle ) ; } return bundle ; } } public int getLineNo ( ) { return lineNo ; } public int getColumnNo ( ) { return colNo ; } public SeverityLevel getSeverityLevel ( ) { return severityLevel ; } public String getModuleId ( ) { return moduleId ; } public String getKey ( ) { return key ; } public String getSourceName ( ) { return sourceClass . getName ( ) ; } public static void setLocale ( Locale locale ) { if ( Locale . ENGLISH . getLanguage ( ) . equals ( locale . getLanguage ( ) ) ) { sLocale = Locale . ROOT ; } else { sLocale = locale ; } } @ Override public int compareTo ( LocalizedMessage other ) { if ( getLineNo ( ) == other . getLineNo ( ) ) { if ( getColumnNo ( ) == other . getColumnNo ( ) ) { return getMessage ( ) . compareTo ( other . getMessage ( ) ) ; } return getColumnNo ( ) < other . getColumnNo ( ) ? - 1 : 1 ; } return getLineNo ( ) < other . getLineNo ( ) ? - 1 : 1 ; } private static class UTF8Control extends Control { @ Override public ResourceBundle newBundle ( String aBaseName , Locale aLocale , String aFormat , ClassLoader aLoader , boolean aReload ) throws IOException { final String bundleName = toBundleName ( aBaseName , aLocale ) ; final String resourceName = toResourceName ( bundleName , "properties" ) ; ResourceBundle bundle = null ; InputStream stream = null ; if ( aReload ) { final URL url = aLoader . getResource ( resourceName ) ; if ( url != null ) { final URLConnection connection = url . openConnection ( ) ; if ( connection != null ) { connection . setUseCaches ( false ) ; stream = connection . getInputStream ( ) ; } } } else { stream = aLoader . getResourceAsStream ( resourceName ) ; } if ( stream != null ) { try ( Reader streamReader = new InputStreamReader ( stream , "UTF-8" ) ) { bundle = new PropertyResourceBundle ( streamReader ) ; } finally { stream . close ( ) ; } } return bundle ; } } }
package com . puppycrawl . tools . checkstyle . api ; import java . util . Locale ; public enum SeverityLevel { IGNORE , INFO , WARNING , ERROR ; @ Override public String toString ( ) { return getName ( ) ; } public String getName ( ) { return name ( ) . toLowerCase ( Locale . ENGLISH ) ; } public static SeverityLevel getInstance ( String securityLevelName ) { return valueOf ( SeverityLevel . class , securityLevelName . trim ( ) . toUpperCase ( Locale . ENGLISH ) ) ; } }
package com . puppycrawl . tools . checkstyle . api ; import java . util . BitSet ; import antlr . CommonASTWithHiddenTokens ; import antlr . Token ; import antlr . collections . AST ; import com . puppycrawl . tools . checkstyle . Utils ; public final class DetailAST extends CommonASTWithHiddenTokens { private static final long serialVersionUID = - 2580884815577559874L ; private static final int NOT_INITIALIZED = Integer . MIN_VALUE ; private int lineNo = NOT_INITIALIZED ; private int columnNo = NOT_INITIALIZED ; private int childCount = NOT_INITIALIZED ; private DetailAST parent ; private DetailAST previousSibling ; private BitSet branchTokenTypes ; @ Override public void initialize ( Token tok ) { super . initialize ( tok ) ; lineNo = tok . getLine ( ) ; columnNo = tok . getColumn ( ) - 1 ; } @ Override public void initialize ( AST ast ) { final DetailAST da = ( DetailAST ) ast ; setText ( da . getText ( ) ) ; setType ( da . getType ( ) ) ; lineNo = da . getLineNo ( ) ; columnNo = da . getColumnNo ( ) ; hiddenAfter = da . getHiddenAfter ( ) ; hiddenBefore = da . getHiddenBefore ( ) ; } @ Override public void setFirstChild ( AST ast ) { childCount = NOT_INITIALIZED ; super . setFirstChild ( ast ) ; if ( ast != null ) { ( ( DetailAST ) ast ) . setParent ( this ) ; } } @ Override public void setNextSibling ( AST ast ) { super . setNextSibling ( ast ) ; if ( ast != null && parent != null ) { ( ( DetailAST ) ast ) . setParent ( parent ) ; } if ( ast != null ) { ( ( DetailAST ) ast ) . setPreviousSibling ( this ) ; } } public void addPreviousSibling ( DetailAST ast ) { if ( ast != null ) { ast . setParent ( parent ) ; final DetailAST previousSibling = this . getPreviousSibling ( ) ; if ( previousSibling != null ) { ast . setPreviousSibling ( previousSibling ) ; previousSibling . setNextSibling ( ast ) ; } else if ( parent != null ) { parent . setFirstChild ( ast ) ; } ast . setNextSibling ( this ) ; this . setPreviousSibling ( ast ) ; } } public void addNextSibling ( DetailAST ast ) { if ( ast != null ) { ast . setParent ( parent ) ; final DetailAST nextSibling = this . getNextSibling ( ) ; if ( nextSibling != null ) { ast . setNextSibling ( nextSibling ) ; nextSibling . setPreviousSibling ( ast ) ; } ast . setPreviousSibling ( this ) ; this . setNextSibling ( ast ) ; } } void setPreviousSibling ( DetailAST ast ) { previousSibling = ast ; } @ Override public void addChild ( AST ast ) { super . addChild ( ast ) ; if ( ast != null ) { ( ( DetailAST ) ast ) . setParent ( this ) ; getFirstChild ( ) . setParent ( this ) ; } } public int getChildCount ( ) { if ( childCount == NOT_INITIALIZED ) { childCount = 0 ; AST child = getFirstChild ( ) ; while ( child != null ) { childCount += 1 ; child = child . getNextSibling ( ) ; } } return childCount ; } void setParent ( DetailAST parent ) { this . parent = parent ; final DetailAST nextSibling = getNextSibling ( ) ; if ( nextSibling != null ) { nextSibling . setParent ( parent ) ; nextSibling . setPreviousSibling ( this ) ; } } public DetailAST getParent ( ) { return parent ; } public int getLineNo ( ) { if ( lineNo == NOT_INITIALIZED ) { DetailAST child = getFirstChild ( ) ; while ( child != null ) { if ( Utils . isCommentType ( child . getType ( ) ) ) { child = child . getNextSibling ( ) ; } else { return child . getLineNo ( ) ; } } DetailAST sibling = getNextSibling ( ) ; while ( sibling != null ) { if ( Utils . isCommentType ( sibling . getType ( ) ) ) { sibling = sibling . getNextSibling ( ) ; } else { return sibling . getLineNo ( ) ; } } } return lineNo ; } public void setLineNo ( int lineNo ) { this . lineNo = lineNo ; } public int getColumnNo ( ) { if ( columnNo == NOT_INITIALIZED ) { DetailAST child = getFirstChild ( ) ; while ( child != null ) { if ( Utils . isCommentType ( child . getType ( ) ) ) { child = child . getNextSibling ( ) ; } else { return child . getColumnNo ( ) ; } } DetailAST sibling = getNextSibling ( ) ; while ( sibling != null ) { if ( Utils . isCommentType ( sibling . getType ( ) ) ) { sibling = sibling . getNextSibling ( ) ; } else { return sibling . getColumnNo ( ) ; } } } return columnNo ; } public void setColumnNo ( int columnNo ) { this . columnNo = columnNo ; } public DetailAST getLastChild ( ) { DetailAST ast = getFirstChild ( ) ; while ( ast != null && ast . getNextSibling ( ) != null ) { ast = ast . getNextSibling ( ) ; } return ast ; } private BitSet getBranchTokenTypes ( ) { if ( branchTokenTypes == null ) { branchTokenTypes = new BitSet ( ) ; branchTokenTypes . set ( getType ( ) ) ; DetailAST child = getFirstChild ( ) ; while ( child != null ) { final BitSet childTypes = child . getBranchTokenTypes ( ) ; branchTokenTypes . or ( childTypes ) ; child = child . getNextSibling ( ) ; } } return branchTokenTypes ; } public boolean branchContains ( int type ) { return getBranchTokenTypes ( ) . get ( type ) ; } public int getChildCount ( int type ) { int count = 0 ; for ( AST i = getFirstChild ( ) ; i != null ; i = i . getNextSibling ( ) ) { if ( i . getType ( ) == type ) { count ++ ; } } return count ; } public DetailAST getPreviousSibling ( ) { return previousSibling ; } public DetailAST findFirstToken ( int type ) { DetailAST retVal = null ; for ( DetailAST i = getFirstChild ( ) ; i != null ; i = i . getNextSibling ( ) ) { if ( i . getType ( ) == type ) { retVal = i ; break ; } } return retVal ; } @ Override public String toString ( ) { return super . toString ( ) + "[" + getLineNo ( ) + "x" + getColumnNo ( ) + "]" ; } @ Override public DetailAST getNextSibling ( ) { return ( DetailAST ) super . getNextSibling ( ) ; } @ Override public DetailAST getFirstChild ( ) { return ( DetailAST ) super . getFirstChild ( ) ; } }
package com . puppycrawl . tools . checkstyle . gui ; import java . awt . BorderLayout ; import java . awt . Component ; import java . awt . GridLayout ; import java . awt . event . ActionEvent ; import java . awt . event . KeyEvent ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . TooManyListenersException ; import javax . swing . * ; import javax . swing . filechooser . FileFilter ; import antlr . ANTLRException ; import com . puppycrawl . tools . checkstyle . TreeWalker ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FileContents ; import com . puppycrawl . tools . checkstyle . api . FileText ; public class ParseTreeInfoPanel extends JPanel { private static final long serialVersionUID = - 4243405131202059043L ; private final transient ParseTreeModel parseTreeModel ; private final JTextArea jTextArea ; private File lastDirectory ; private File currentFile ; private final Action reloadAction ; private final List < Integer > lines2position = new ArrayList < > ( ) ; private static class JavaFileFilter extends FileFilter { @ Override public boolean accept ( File f ) { if ( f == null ) { return false ; } return f . isDirectory ( ) || f . getName ( ) . endsWith ( ".java" ) ; } @ Override public String getDescription ( ) { return "Java Source Code" ; } } public void openAst ( DetailAST parseTree , final Component parent ) { parseTreeModel . setParseTree ( parseTree ) ; reloadAction . setEnabled ( true ) ; getLines2position ( ) . clear ( ) ; getLines2position ( ) . add ( 0 ) ; if ( jTextArea . getText ( ) . length ( ) != 0 ) { jTextArea . replaceRange ( "" , 0 , jTextArea . getText ( ) . length ( ) ) ; } jTextArea . moveCaretPosition ( 0 ) ; } private class FileSelectionAction extends AbstractAction { private static final long serialVersionUID = - 1926935338069418119L ; public FileSelectionAction ( ) { super ( "Select Java File" ) ; putValue ( Action . MNEMONIC_KEY , KeyEvent . VK_S ) ; } @ Override public void actionPerformed ( ActionEvent e ) { final JFileChooser fc = new JFileChooser ( lastDirectory ) ; final FileFilter filter = new JavaFileFilter ( ) ; fc . setFileFilter ( filter ) ; final Component parent = SwingUtilities . getRoot ( ParseTreeInfoPanel . this ) ; fc . showDialog ( parent , "Open" ) ; final File file = fc . getSelectedFile ( ) ; openFile ( file , parent ) ; } } private class ReloadAction extends AbstractAction { private static final long serialVersionUID = - 1021880396046355863L ; public ReloadAction ( ) { super ( "Reload Java File" ) ; putValue ( Action . MNEMONIC_KEY , KeyEvent . VK_R ) ; } @ Override public void actionPerformed ( ActionEvent e ) { final Component parent = SwingUtilities . getRoot ( ParseTreeInfoPanel . this ) ; openFile ( currentFile , parent ) ; } } private class FileDropListener implements FileDrop . Listener { private final JScrollPane mSp ; @ Override public void filesDropped ( File ... files ) { if ( files != null && files . length > 0 ) { final File file = files [ 0 ] ; openFile ( file , mSp ) ; } } public FileDropListener ( JScrollPane aSp ) { mSp = aSp ; } } public void openFile ( File file , final Component parent ) { if ( file != null ) { try { Main . frame . setTitle ( "Checkstyle : " + file . getName ( ) ) ; final FileText text = new FileText ( file . getAbsoluteFile ( ) , getEncoding ( ) ) ; final DetailAST parseTree = parseFile ( text ) ; parseTreeModel . setParseTree ( parseTree ) ; currentFile = file ; lastDirectory = file . getParentFile ( ) ; reloadAction . setEnabled ( true ) ; final String [ ] sourceLines = text . toLinesArray ( ) ; getLines2position ( ) . clear ( ) ; getLines2position ( ) . add ( 0 ) ; for ( String element : sourceLines ) { getLines2position ( ) . add ( jTextArea . getText ( ) . length ( ) ) ; jTextArea . append ( element + "\n" ) ; } if ( jTextArea . getText ( ) . length ( ) != 0 ) { jTextArea . replaceRange ( "" , 0 , jTextArea . getText ( ) . length ( ) ) ; } for ( final String element : sourceLines ) { jTextArea . append ( element + "\n" ) ; } jTextArea . moveCaretPosition ( 0 ) ; } catch ( final IOException | ANTLRException ex ) { showErrorDialog ( parent , "Could not parse" + file + ": " + ex . getMessage ( ) ) ; } } } @ Deprecated public static DetailAST parseFile ( String fileName ) throws IOException , ANTLRException { return parseFile ( new FileText ( new File ( fileName ) , getEncoding ( ) ) ) ; } public static DetailAST parseFile ( FileText text ) throws ANTLRException { final FileContents contents = new FileContents ( text ) ; return TreeWalker . parse ( contents ) ; } private static String getEncoding ( ) { return System . getProperty ( "file.encoding" , "UTF-8" ) ; } public ParseTreeInfoPanel ( ) { setLayout ( new BorderLayout ( ) ) ; parseTreeModel = new ParseTreeModel ( null ) ; JTreeTable treeTable = new JTreeTable ( parseTreeModel ) ; final JScrollPane sp = new JScrollPane ( treeTable ) ; this . add ( sp , BorderLayout . NORTH ) ; final JButton fileSelectionButton = new JButton ( new FileSelectionAction ( ) ) ; reloadAction = new ReloadAction ( ) ; reloadAction . setEnabled ( false ) ; final JButton reloadButton = new JButton ( reloadAction ) ; jTextArea = new JTextArea ( 20 , 15 ) ; jTextArea . setEditable ( false ) ; treeTable . setEditor ( jTextArea ) ; treeTable . setLinePositionMap ( lines2position ) ; final JScrollPane sp2 = new JScrollPane ( jTextArea ) ; this . add ( sp2 , BorderLayout . CENTER ) ; final JPanel p = new JPanel ( new GridLayout ( 1 , 2 ) ) ; this . add ( p , BorderLayout . SOUTH ) ; p . add ( fileSelectionButton ) ; p . add ( reloadButton ) ; try { new FileDrop ( sp , new FileDropListener ( sp ) ) ; } catch ( final TooManyListenersException ex ) { showErrorDialog ( null , "Cannot initialize Drag and Drop support" ) ; } } private void showErrorDialog ( final Component parent , final String msg ) { final Runnable showError = new FrameShower ( parent , msg ) ; SwingUtilities . invokeLater ( showError ) ; } public List < Integer > getLines2position ( ) { return lines2position ; } private static class FrameShower implements Runnable { final Component parent ; final String msg ; public FrameShower ( Component parent , final String msg ) { this . parent = parent ; this . msg = msg ; } public void run ( ) { JOptionPane . showMessageDialog ( parent , msg ) ; } } }
package com . puppycrawl . tools . checkstyle . gui ;
package com . puppycrawl . tools . checkstyle . gui ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import java . awt . Color ; import java . util . List ; import javax . swing . JTextArea ; public class CodeSelector { private final DetailAST ast ; private final JTextArea editor ; private final List < Integer > lines2position ; public CodeSelector ( final DetailAST ast , final JTextArea editor , final List < Integer > lines2position ) { this . ast = ast ; this . editor = editor ; this . lines2position = lines2position ; } public void select ( ) { int start = lines2position . get ( ast . getLineNo ( ) ) + ast . getColumnNo ( ) ; int end = findLastPosition ( ast ) ; editor . setSelectedTextColor ( Color . blue ) ; editor . requestFocusInWindow ( ) ; editor . setSelectionStart ( start ) ; editor . setSelectionEnd ( end ) ; editor . transferFocusBackward ( ) ; } private int findLastPosition ( final DetailAST ast ) { if ( ast . getChildCount ( ) == 0 ) { return lines2position . get ( ast . getLineNo ( ) ) + ast . getColumnNo ( ) + ast . getText ( ) . length ( ) ; } else { return findLastPosition ( ast . getLastChild ( ) ) ; } } }
package com . puppycrawl . tools . checkstyle . gui ; import java . awt . Component ; import java . awt . Dimension ; import java . awt . Graphics ; import java . awt . event . ActionEvent ; import java . awt . event . MouseEvent ; import java . util . EventObject ; import java . util . List ; import javax . swing . Action ; import javax . swing . AbstractAction ; import javax . swing . JTable ; import javax . swing . JTextArea ; import javax . swing . JTree ; import javax . swing . KeyStroke ; import javax . swing . ListSelectionModel ; import javax . swing . LookAndFeel ; import javax . swing . UIManager ; import javax . swing . event . ListSelectionEvent ; import javax . swing . event . ListSelectionListener ; import javax . swing . table . TableCellEditor ; import javax . swing . table . TableCellRenderer ; import javax . swing . tree . DefaultTreeCellRenderer ; import javax . swing . tree . DefaultTreeSelectionModel ; import javax . swing . tree . TreeCellRenderer ; import javax . swing . tree . TreeModel ; import javax . swing . tree . TreePath ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class JTreeTable extends JTable { private static final long serialVersionUID = - 8493693409423365387L ; protected TreeTableCellRenderer tree ; private JTextArea editor ; private List < Integer > lines2position ; public JTreeTable ( TreeTableModel treeTableModel ) { super ( ) ; tree = new TreeTableCellRenderer ( treeTableModel ) ; super . setModel ( new TreeTableModelAdapter ( treeTableModel , tree ) ) ; final ListToTreeSelectionModelWrapper selectionWrapper = new ListToTreeSelectionModelWrapper ( ) ; tree . setSelectionModel ( selectionWrapper ) ; setSelectionModel ( selectionWrapper . getListSelectionModel ( ) ) ; setDefaultRenderer ( TreeTableModel . class , tree ) ; setDefaultEditor ( TreeTableModel . class , new TreeTableCellEditor ( ) ) ; setShowGrid ( false ) ; setIntercellSpacing ( new Dimension ( 0 , 0 ) ) ; if ( tree . getRowHeight ( ) < 1 ) { setRowHeight ( getRowHeight ( ) ) ; } final Action expand = new AbstractAction ( ) { private static final long serialVersionUID = - 5859674518660156121L ; @ Override public void actionPerformed ( ActionEvent e ) { final TreePath selected = tree . getSelectionPath ( ) ; DetailAST ast = ( DetailAST ) selected . getLastPathComponent ( ) ; new CodeSelector ( ast , editor , lines2position ) . select ( ) ; if ( tree . isExpanded ( selected ) ) { tree . collapsePath ( selected ) ; } else { tree . expandPath ( selected ) ; } tree . setSelectionPath ( selected ) ; } } ; final KeyStroke stroke = KeyStroke . getKeyStroke ( "ENTER" ) ; final String command = "expand/collapse" ; getInputMap ( ) . put ( stroke , command ) ; getActionMap ( ) . put ( command , expand ) ; } @ Override public void updateUI ( ) { super . updateUI ( ) ; if ( tree != null ) { tree . updateUI ( ) ; } LookAndFeel . installColorsAndFont ( this , "Tree.background" , "Tree.foreground" , "Tree.font" ) ; } @ Override public int getEditingRow ( ) { final Class < ? > editingClass = getColumnClass ( editingColumn ) ; return editingClass == TreeTableModel . class ? - 1 : editingRow ; } @ Override public void setRowHeight ( int newRowHeight ) { super . setRowHeight ( newRowHeight ) ; if ( tree != null && tree . getRowHeight ( ) != newRowHeight ) { tree . setRowHeight ( getRowHeight ( ) ) ; } } public JTree getTree ( ) { return tree ; } class TreeTableCellRenderer extends JTree implements TableCellRenderer { private static final long serialVersionUID = 4324031590789321581L ; protected int visibleRow ; public TreeTableCellRenderer ( TreeModel model ) { super ( model ) ; } @ Override public void updateUI ( ) { super . updateUI ( ) ; final TreeCellRenderer tcr = getCellRenderer ( ) ; if ( tcr instanceof DefaultTreeCellRenderer ) { final DefaultTreeCellRenderer dtcr = ( DefaultTreeCellRenderer ) tcr ; dtcr . setTextSelectionColor ( UIManager . getColor ( "Table.selectionForeground" ) ) ; dtcr . setBackgroundSelectionColor ( UIManager . getColor ( "Table.selectionBackground" ) ) ; } } @ Override public void setRowHeight ( int newRowHeight ) { if ( newRowHeight > 0 ) { super . setRowHeight ( newRowHeight ) ; if ( JTreeTable . this != null && JTreeTable . this . getRowHeight ( ) != newRowHeight ) { JTreeTable . this . setRowHeight ( getRowHeight ( ) ) ; } } } @ Override public void setBounds ( int x , int y , int w , int h ) { super . setBounds ( x , 0 , w , JTreeTable . this . getHeight ( ) ) ; } @ Override public void paint ( Graphics g ) { g . translate ( 0 , - visibleRow * getRowHeight ( ) ) ; super . paint ( g ) ; } @ Override public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { if ( isSelected ) { setBackground ( table . getSelectionBackground ( ) ) ; } else { setBackground ( table . getBackground ( ) ) ; } visibleRow = row ; return this ; } } public class TreeTableCellEditor extends AbstractCellEditor implements TableCellEditor { @ Override public Component getTableCellEditorComponent ( JTable table , Object value , boolean isSelected , int r , int c ) { return tree ; } @ Override public boolean isCellEditable ( EventObject e ) { if ( e instanceof MouseEvent ) { for ( int counter = getColumnCount ( ) - 1 ; counter >= 0 ; counter -- ) { if ( getColumnClass ( counter ) == TreeTableModel . class ) { final MouseEvent me = ( MouseEvent ) e ; final MouseEvent newME = new MouseEvent ( tree , me . getID ( ) , me . getWhen ( ) , me . getModifiers ( ) , me . getX ( ) - getCellRect ( 0 , counter , true ) . x , me . getY ( ) , me . getClickCount ( ) , me . isPopupTrigger ( ) ) ; tree . dispatchEvent ( newME ) ; break ; } } } return false ; } } class ListToTreeSelectionModelWrapper extends DefaultTreeSelectionModel { private static final long serialVersionUID = 2267930983939339510L ; protected boolean updatingListSelectionModel ; public ListToTreeSelectionModelWrapper ( ) { super ( ) ; getListSelectionModel ( ) . addListSelectionListener ( createListSelectionListener ( ) ) ; } ListSelectionModel getListSelectionModel ( ) { return listSelectionModel ; } @ Override public void resetRowSelection ( ) { if ( ! updatingListSelectionModel ) { updatingListSelectionModel = true ; try { super . resetRowSelection ( ) ; } finally { updatingListSelectionModel = false ; } } } private ListSelectionListener createListSelectionListener ( ) { return new ListSelectionHandler ( ) ; } protected void updateSelectedPathsFromSelectedRows ( ) { if ( ! updatingListSelectionModel ) { updatingListSelectionModel = true ; try { final int min = listSelectionModel . getMinSelectionIndex ( ) ; final int max = listSelectionModel . getMaxSelectionIndex ( ) ; clearSelection ( ) ; if ( min != - 1 && max != - 1 ) { for ( int counter = min ; counter <= max ; counter ++ ) { if ( listSelectionModel . isSelectedIndex ( counter ) ) { final TreePath selPath = tree . getPathForRow ( counter ) ; if ( selPath != null ) { addSelectionPath ( selPath ) ; } } } } } finally { updatingListSelectionModel = false ; } } } class ListSelectionHandler implements ListSelectionListener { @ Override public void valueChanged ( ListSelectionEvent e ) { updateSelectedPathsFromSelectedRows ( ) ; } } } public void setEditor ( JTextArea mJTextArea ) { this . editor = mJTextArea ; } public void setLinePositionMap ( List < Integer > lines2position ) { this . lines2position = lines2position ; } }
package com . puppycrawl . tools . checkstyle . gui ; import java . util . EventObject ; import javax . swing . CellEditor ; import javax . swing . event . CellEditorListener ; import javax . swing . event . ChangeEvent ; import javax . swing . event . EventListenerList ; public class AbstractCellEditor implements CellEditor { private final EventListenerList listenerList = new EventListenerList ( ) ; @ Override public Object getCellEditorValue ( ) { return null ; } @ Override public boolean isCellEditable ( EventObject e ) { return true ; } @ Override public boolean shouldSelectCell ( EventObject anEvent ) { return false ; } @ Override public boolean stopCellEditing ( ) { return true ; } @ Override public void cancelCellEditing ( ) { } @ Override public void addCellEditorListener ( CellEditorListener l ) { listenerList . add ( CellEditorListener . class , l ) ; } @ Override public void removeCellEditorListener ( CellEditorListener l ) { listenerList . remove ( CellEditorListener . class , l ) ; } protected void fireEditingStopped ( ) { final Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == CellEditorListener . class ) { ( ( CellEditorListener ) listeners [ i + 1 ] ) . editingStopped ( new ChangeEvent ( this ) ) ; } } } protected void fireEditingCanceled ( ) { final Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == CellEditorListener . class ) { ( ( CellEditorListener ) listeners [ i + 1 ] ) . editingCanceled ( new ChangeEvent ( this ) ) ; } } } }
package com . puppycrawl . tools . checkstyle . gui ; import java . awt . Color ; import java . awt . Component ; import java . awt . Container ; import java . awt . datatransfer . DataFlavor ; import java . awt . datatransfer . Transferable ; import java . awt . datatransfer . UnsupportedFlavorException ; import java . awt . dnd . DnDConstants ; import java . awt . dnd . DropTarget ; import java . awt . dnd . DropTargetDragEvent ; import java . awt . dnd . DropTargetDropEvent ; import java . awt . dnd . DropTargetEvent ; import java . awt . dnd . DropTargetListener ; import java . awt . event . HierarchyEvent ; import java . awt . event . HierarchyListener ; import java . io . File ; import java . io . IOException ; import java . util . List ; import java . util . TooManyListenersException ; import javax . swing . BorderFactory ; import javax . swing . JComponent ; import javax . swing . border . Border ; class FileDrop { private transient Border normalBorder ; private final transient DropTargetListener dropListener ; private static final Color DEFAULT_BORDER_COLOR = new Color ( 0f , 0f , 1f , 0.25f ) ; FileDrop ( final Component c , final Listener listener ) throws TooManyListenersException { this ( c , BorderFactory . createMatteBorder ( 2 , 2 , 2 , 2 , DEFAULT_BORDER_COLOR ) , true , listener ) ; } FileDrop ( final Component c , final Border dragBorder , final boolean recursive , final Listener listener ) throws TooManyListenersException { dropListener = new FileDropTargetListener ( c , dragBorder , listener ) ; makeDropTarget ( c , recursive ) ; } private void makeDropTarget ( final Component c , boolean recursive ) throws TooManyListenersException { final DropTarget dt = new DropTarget ( ) ; dt . addDropTargetListener ( dropListener ) ; c . addHierarchyListener ( new HierarchyListener ( ) { @ Override public void hierarchyChanged ( HierarchyEvent evt ) { final Component parent = c . getParent ( ) ; if ( parent == null ) { c . setDropTarget ( null ) ; } else { new DropTarget ( c , dropListener ) ; } } } ) ; if ( c . getParent ( ) != null ) { new DropTarget ( c , dropListener ) ; } if ( recursive && c instanceof Container ) { final Container cont = ( Container ) c ; final Component [ ] comps = cont . getComponents ( ) ; for ( Component element : comps ) { makeDropTarget ( element , recursive ) ; } } } private boolean isDragOk ( final DropTargetDragEvent evt ) { boolean ok = false ; final DataFlavor [ ] flavors = evt . getCurrentDataFlavors ( ) ; int i = 0 ; while ( ! ok && i < flavors . length ) { if ( flavors [ i ] . equals ( DataFlavor . javaFileListFlavor ) ) { ok = true ; } i ++ ; } return ok ; } static void remove ( Component c ) { remove ( c , true ) ; } static void remove ( Component c , boolean recursive ) { c . setDropTarget ( null ) ; if ( recursive && c instanceof Container ) { final Component [ ] comps = ( ( Container ) c ) . getComponents ( ) ; for ( Component element : comps ) { remove ( element , recursive ) ; } } } public interface Listener { void filesDropped ( File ... files ) ; } private class FileDropTargetListener implements DropTargetListener { private final Component component ; private final Border dragBorder ; private final Listener listener ; @ Override public void dragEnter ( DropTargetDragEvent evt ) { if ( isDragOk ( evt ) ) { if ( component instanceof JComponent ) { final JComponent jc = ( JComponent ) component ; normalBorder = jc . getBorder ( ) ; jc . setBorder ( dragBorder ) ; } evt . acceptDrag ( DnDConstants . ACTION_COPY ) ; } else { evt . rejectDrag ( ) ; } } @ Override @ SuppressWarnings ( "unchecked" ) public void drop ( DropTargetDropEvent evt ) { try { final Transferable tr = evt . getTransferable ( ) ; if ( tr . isDataFlavorSupported ( DataFlavor . javaFileListFlavor ) ) { evt . acceptDrop ( DnDConstants . ACTION_COPY ) ; final List < File > fileList = ( List < File > ) tr . getTransferData ( DataFlavor . javaFileListFlavor ) ; final File [ ] files = new File [ fileList . size ( ) ] ; fileList . toArray ( files ) ; if ( listener != null ) { listener . filesDropped ( files ) ; } evt . getDropTargetContext ( ) . dropComplete ( true ) ; } else { evt . rejectDrop ( ) ; } } catch ( final IOException | UnsupportedFlavorException io ) { evt . rejectDrop ( ) ; } finally { if ( component instanceof JComponent ) { final JComponent jc = ( JComponent ) component ; jc . setBorder ( normalBorder ) ; } } } @ Override public void dragExit ( DropTargetEvent evt ) { if ( component instanceof JComponent ) { final JComponent jc = ( JComponent ) component ; jc . setBorder ( normalBorder ) ; } } @ Override public void dropActionChanged ( DropTargetDragEvent evt ) { if ( isDragOk ( evt ) ) { evt . acceptDrag ( DnDConstants . ACTION_COPY ) ; } else { evt . rejectDrag ( ) ; } } @ Override public void dragOver ( DropTargetDragEvent dtde ) { } public FileDropTargetListener ( Component component , Border dragBorder , Listener listener ) { this . component = component ; this . dragBorder = dragBorder ; this . listener = listener ; } } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . FinalParametersCheck . MSG_KEY ; public class FinalParametersCheckTest extends BaseCheckTestSupport { @ Test public void testDefaultTokens ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalParametersCheck . class ) ; final String [ ] expected = { "23:26: " + getCheckMessage ( MSG_KEY , "s" ) , "38:26: " + getCheckMessage ( MSG_KEY , "i" ) , "43:26: " + getCheckMessage ( MSG_KEY , "s" ) , "53:17: " + getCheckMessage ( MSG_KEY , "s" ) , "69:17: " + getCheckMessage ( MSG_KEY , "s" ) , "75:17: " + getCheckMessage ( MSG_KEY , "s" ) , "90:45: " + getCheckMessage ( MSG_KEY , "e" ) , "93:36: " + getCheckMessage ( MSG_KEY , "e" ) , "110:18: " + getCheckMessage ( MSG_KEY , "aParam" ) , "113:18: " + getCheckMessage ( MSG_KEY , "args" ) , "116:18: " + getCheckMessage ( MSG_KEY , "args" ) , } ; verify ( checkConfig , getPath ( "InputFinalParameters.java" ) , expected ) ; } @ Test public void testCtorToken ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalParametersCheck . class ) ; checkConfig . addAttribute ( "tokens" , "CTOR_DEF" ) ; final String [ ] expected = { "23:26: " + getCheckMessage ( MSG_KEY , "s" ) , "38:26: " + getCheckMessage ( MSG_KEY , "i" ) , "43:26: " + getCheckMessage ( MSG_KEY , "s" ) , } ; verify ( checkConfig , getPath ( "InputFinalParameters.java" ) , expected ) ; } @ Test public void testMethodToken ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalParametersCheck . class ) ; checkConfig . addAttribute ( "tokens" , "METHOD_DEF" ) ; final String [ ] expected = { "53:17: " + getCheckMessage ( MSG_KEY , "s" ) , "69:17: " + getCheckMessage ( MSG_KEY , "s" ) , "75:17: " + getCheckMessage ( MSG_KEY , "s" ) , "90:45: " + getCheckMessage ( MSG_KEY , "e" ) , "93:36: " + getCheckMessage ( MSG_KEY , "e" ) , "110:18: " + getCheckMessage ( MSG_KEY , "aParam" ) , "113:18: " + getCheckMessage ( MSG_KEY , "args" ) , "116:18: " + getCheckMessage ( MSG_KEY , "args" ) , } ; verify ( checkConfig , getPath ( "InputFinalParameters.java" ) , expected ) ; } @ Test public void testCatchToken ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalParametersCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_CATCH" ) ; final String [ ] expected = { "125:16: " + getCheckMessage ( MSG_KEY , "npe" ) , "131:16: " + getCheckMessage ( MSG_KEY , "e" ) , "134:16: " + getCheckMessage ( MSG_KEY , "e" ) , } ; verify ( checkConfig , getPath ( "InputFinalParameters.java" ) , expected ) ; } @ Test public void testForEachClauseToken ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalParametersCheck . class ) ; checkConfig . addAttribute ( "tokens" , "FOR_EACH_CLAUSE" ) ; final String [ ] expected = { "150:13: " + getCheckMessage ( MSG_KEY , "s" ) , "158:13: " + getCheckMessage ( MSG_KEY , "s" ) , } ; verify ( checkConfig , getPath ( "InputFinalParameters.java" ) , expected ) ; } @ Test public void testIgnorePrimitiveTypesParameters ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( FinalParametersCheck . class ) ; checkConfig . addAttribute ( "ignorePrimitiveTypes" , "true" ) ; final String [ ] expected = { "6:22: " + getCheckMessage ( MSG_KEY , "k" ) , "7:15: " + getCheckMessage ( MSG_KEY , "s" ) , "7:25: " + getCheckMessage ( MSG_KEY , "o" ) , "8:15: " + getCheckMessage ( MSG_KEY , "array" ) , "9:31: " + getCheckMessage ( MSG_KEY , "s" ) , "10:22: " + getCheckMessage ( MSG_KEY , "l" ) , "10:32: " + getCheckMessage ( MSG_KEY , "s" ) , } ; verify ( checkConfig , getPath ( "InputFinalParametersPrimitiveTypes.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . gui ; import javax . swing . JTree ; import javax . swing . SwingUtilities ; import javax . swing . table . AbstractTableModel ; import javax . swing . tree . TreePath ; import javax . swing . event . TreeExpansionEvent ; import javax . swing . event . TreeExpansionListener ; import javax . swing . event . TreeModelEvent ; import javax . swing . event . TreeModelListener ; public class TreeTableModelAdapter extends AbstractTableModel { private static final long serialVersionUID = 8269213416115369275L ; private final JTree tree ; private final transient TreeTableModel treeTableModel ; public TreeTableModelAdapter ( TreeTableModel treeTableModel , JTree tree ) { this . tree = tree ; this . treeTableModel = treeTableModel ; tree . addTreeExpansionListener ( new TreeExpansionListener ( ) { @ Override public void treeExpanded ( TreeExpansionEvent event ) { fireTableDataChanged ( ) ; } @ Override public void treeCollapsed ( TreeExpansionEvent event ) { fireTableDataChanged ( ) ; } } ) ; treeTableModel . addTreeModelListener ( new TreeModelListener ( ) { @ Override public void treeNodesChanged ( TreeModelEvent e ) { delayedFireTableDataChanged ( ) ; } @ Override public void treeNodesInserted ( TreeModelEvent e ) { delayedFireTableDataChanged ( ) ; } @ Override public void treeNodesRemoved ( TreeModelEvent e ) { delayedFireTableDataChanged ( ) ; } @ Override public void treeStructureChanged ( TreeModelEvent e ) { delayedFireTableDataChanged ( ) ; } } ) ; } @ Override public int getColumnCount ( ) { return treeTableModel . getColumnCount ( ) ; } @ Override public String getColumnName ( int column ) { return treeTableModel . getColumnName ( column ) ; } @ Override public Class < ? > getColumnClass ( int column ) { return treeTableModel . getColumnClass ( column ) ; } @ Override public int getRowCount ( ) { return tree . getRowCount ( ) ; } protected Object nodeForRow ( int row ) { final TreePath treePath = tree . getPathForRow ( row ) ; return treePath . getLastPathComponent ( ) ; } @ Override public Object getValueAt ( int row , int column ) { return treeTableModel . getValueAt ( nodeForRow ( row ) , column ) ; } @ Override public boolean isCellEditable ( int row , int column ) { return treeTableModel . isCellEditable ( nodeForRow ( row ) , column ) ; } @ Override public void setValueAt ( Object value , int row , int column ) { treeTableModel . setValueAt ( value , nodeForRow ( row ) , column ) ; } protected void delayedFireTableDataChanged ( ) { SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { fireTableDataChanged ( ) ; } } ) ; } }
package com . puppycrawl . tools . checkstyle . gui ; import java . awt . * ; import java . io . File ; import javax . swing . JFrame ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class Main { static JFrame frame ; public static void main ( String ... args ) { frame = new JFrame ( "CheckStyle" ) ; final ParseTreeInfoPanel panel = new ParseTreeInfoPanel ( ) ; frame . getContentPane ( ) . add ( panel ) ; if ( args . length >= 1 ) { final File f = new File ( args [ 0 ] ) ; panel . openFile ( f , frame ) ; } frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; Runnable runner = new FrameShower ( frame ) ; EventQueue . invokeLater ( runner ) ; } public static void displayAst ( DetailAST ast ) { JFrame frame = new JFrame ( "CheckStyle" ) ; final ParseTreeInfoPanel panel = new ParseTreeInfoPanel ( ) ; frame . getContentPane ( ) . add ( panel ) ; panel . openAst ( ast , frame ) ; frame . setSize ( 1500 , 800 ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; } private static class FrameShower implements Runnable { final JFrame frame ; public FrameShower ( JFrame frame ) { this . frame = frame ; } public void run ( ) { frame . pack ( ) ; frame . setVisible ( true ) ; } } }
package com . puppycrawl . tools . checkstyle . gui ; import javax . swing . tree . TreeModel ; public interface TreeTableModel extends TreeModel { int getColumnCount ( ) ; String getColumnName ( int column ) ; Class < ? > getColumnClass ( int column ) ; Object getValueAt ( Object node , int column ) ; boolean isCellEditable ( Object node , int column ) ; void setValueAt ( Object aValue , Object node , int column ) ; }
package com . puppycrawl . tools . checkstyle . gui ; import javax . swing . tree . TreePath ; import antlr . ASTFactory ; import antlr . collections . AST ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ParseTreeModel extends AbstractTreeTableModel { private static final String [ ] COLUMN_NAMES = new String [ ] { "Tree" , "Type" , "Line" , "Column" , "Text" } ; public ParseTreeModel ( DetailAST parseTree ) { super ( createArtificialTreeRoot ( ) ) ; setParseTree ( parseTree ) ; } private static DetailAST createArtificialTreeRoot ( ) { final ASTFactory factory = new ASTFactory ( ) ; factory . setASTNodeClass ( DetailAST . class . getName ( ) ) ; return ( DetailAST ) factory . create ( TokenTypes . EOF , "ROOT" ) ; } void setParseTree ( DetailAST parseTree ) { final DetailAST root = ( DetailAST ) getRoot ( ) ; root . setFirstChild ( parseTree ) ; final Object [ ] path = { root } ; fireTreeStructureChanged ( this , path , null , ( Object [ ] ) null ) ; } @ Override public int getColumnCount ( ) { return COLUMN_NAMES . length ; } @ Override public String getColumnName ( int column ) { return COLUMN_NAMES [ column ] ; } @ Override public Class < ? > getColumnClass ( int column ) { switch ( column ) { case 0 : return TreeTableModel . class ; case 1 : return String . class ; case 2 : return Integer . class ; case 3 : return Integer . class ; case 4 : return String . class ; default : return Object . class ; } } @ Override public Object getValueAt ( Object node , int column ) { final DetailAST ast = ( DetailAST ) node ; switch ( column ) { case 0 : return null ; case 1 : return Utils . getTokenName ( ast . getType ( ) ) ; case 2 : return ast . getLineNo ( ) ; case 3 : return ast . getColumnNo ( ) ; case 4 : return ast . getText ( ) ; default : return null ; } } @ Override public void setValueAt ( Object aValue , Object node , int column ) { } @ Override public Object getChild ( Object parent , int index ) { final DetailAST ast = ( DetailAST ) parent ; int i = 0 ; AST child = ast . getFirstChild ( ) ; while ( i < index ) { child = child . getNextSibling ( ) ; i ++ ; } return child ; } @ Override public int getChildCount ( Object parent ) { final DetailAST ast = ( DetailAST ) parent ; return ast . getChildCount ( ) ; } @ Override public void valueForPathChanged ( TreePath path , Object newValue ) { } }
package com . puppycrawl . tools . checkstyle . gui ; import javax . swing . event . EventListenerList ; import javax . swing . event . TreeModelEvent ; import javax . swing . event . TreeModelListener ; import javax . swing . tree . TreePath ; public abstract class AbstractTreeTableModel implements TreeTableModel { private final Object root ; private final EventListenerList listenerList = new EventListenerList ( ) ; public AbstractTreeTableModel ( Object root ) { this . root = root ; } @ Override public Object getRoot ( ) { return root ; } @ Override public boolean isLeaf ( Object node ) { return getChildCount ( node ) == 0 ; } public abstract void valueForPathChanged ( TreePath path , Object newValue ) ; @ Override public int getIndexOfChild ( Object parent , Object child ) { for ( int i = 0 ; i < getChildCount ( parent ) ; i ++ ) { if ( getChild ( parent , i ) . equals ( child ) ) { return i ; } } return - 1 ; } @ Override public void addTreeModelListener ( TreeModelListener l ) { listenerList . add ( TreeModelListener . class , l ) ; } @ Override public void removeTreeModelListener ( TreeModelListener l ) { listenerList . remove ( TreeModelListener . class , l ) ; } protected void fireTreeNodesChanged ( Object source , Object [ ] path , int [ ] childIndices , Object ... children ) { final Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent e = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == TreeModelListener . class ) { if ( e == null ) { e = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeNodesChanged ( e ) ; } } } protected void fireTreeNodesInserted ( Object source , Object [ ] path , int [ ] childIndices , Object ... children ) { final Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent e = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == TreeModelListener . class ) { if ( e == null ) { e = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeNodesInserted ( e ) ; } } } protected void fireTreeNodesRemoved ( Object source , Object [ ] path , int [ ] childIndices , Object ... children ) { final Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent e = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == TreeModelListener . class ) { if ( e == null ) { e = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeNodesRemoved ( e ) ; } } } protected void fireTreeStructureChanged ( Object source , Object [ ] path , int [ ] childIndices , Object ... children ) { final Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent e = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == TreeModelListener . class ) { if ( e == null ) { e = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeStructureChanged ( e ) ; } } } @ Override public Class < ? > getColumnClass ( int column ) { return Object . class ; } @ Override public boolean isCellEditable ( Object node , int column ) { return getColumnClass ( column ) == TreeTableModel . class ; } public abstract void setValueAt ( Object value , Object node , int column ) ; }
package com . puppycrawl . tools . checkstyle . ant ;
package com . puppycrawl . tools . checkstyle . ant ; import com . google . common . collect . Lists ; import com . google . common . io . Closeables ; import com . puppycrawl . tools . checkstyle . Checker ; import com . puppycrawl . tools . checkstyle . ConfigurationLoader ; import com . puppycrawl . tools . checkstyle . DefaultContext ; import com . puppycrawl . tools . checkstyle . DefaultLogger ; import com . puppycrawl . tools . checkstyle . PropertiesExpander ; import com . puppycrawl . tools . checkstyle . XMLLogger ; import com . puppycrawl . tools . checkstyle . api . AuditListener ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . api . SeverityLevel ; import com . puppycrawl . tools . checkstyle . api . SeverityLevelCounter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . net . URL ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . ResourceBundle ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class CheckstyleAntTask extends Task { private static final String E_XML = "xml" ; private static final String E_PLAIN = "plain" ; private Path classpath ; private String fileName ; private String configLocation ; private boolean failOnViolation = true ; private String failureProperty ; private final List < FileSet > fileSets = Lists . newArrayList ( ) ; private final List < Formatter > formatters = Lists . newArrayList ( ) ; private final List < Property > overrideProps = Lists . newArrayList ( ) ; private File propertiesFile ; private int maxErrors ; private int maxWarnings = Integer . MAX_VALUE ; private boolean omitIgnoredModules = true ; public void setFailureProperty ( String propertyName ) { failureProperty = propertyName ; } public void setFailOnViolation ( boolean fail ) { failOnViolation = fail ; } public void setMaxErrors ( int maxErrors ) { this . maxErrors = maxErrors ; } public void setMaxWarnings ( int maxWarnings ) { this . maxWarnings = maxWarnings ; } public void addFileset ( FileSet fS ) { fileSets . add ( fS ) ; } public void addFormatter ( Formatter formatter ) { formatters . add ( formatter ) ; } public void addProperty ( Property property ) { overrideProps . add ( property ) ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public void setClasspathRef ( Reference classpathRef ) { createClasspath ( ) . setRefid ( classpathRef ) ; } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setFile ( File file ) { fileName = file . getAbsolutePath ( ) ; } public void setConfig ( File file ) { setConfigLocation ( file . getAbsolutePath ( ) ) ; } public void setConfigURL ( URL url ) { setConfigLocation ( url . toExternalForm ( ) ) ; } private void setConfigLocation ( String location ) { if ( configLocation != null ) { throw new BuildException ( "Attributes 'config' and 'configURL' " + "must not be set at the same time" ) ; } configLocation = location ; } public void setOmitIgnoredModules ( boolean omit ) { omitIgnoredModules = omit ; } public void setProperties ( File props ) { propertiesFile = props ; } @ Override public void execute ( ) throws BuildException { final long startTime = System . currentTimeMillis ( ) ; try { realExecute ( ) ; } finally { final long endTime = System . currentTimeMillis ( ) ; log ( "Total execution took " + ( endTime - startTime ) + " ms." , Project . MSG_VERBOSE ) ; } } private void realExecute ( ) { final ResourceBundle compilationProperties = ResourceBundle . getBundle ( "checkstylecompilation" ) ; final String version = compilationProperties . getString ( "checkstyle.compile.version" ) ; final String compileTimestamp = compilationProperties . getString ( "checkstyle.compile.timestamp" ) ; log ( "checkstyle version " + version , Project . MSG_VERBOSE ) ; log ( "compiled on " + compileTimestamp , Project . MSG_VERBOSE ) ; if ( fileName == null && fileSets . isEmpty ( ) ) { throw new BuildException ( "Must specify at least one of 'file' or nested 'fileset'." , getLocation ( ) ) ; } if ( configLocation == null ) { throw new BuildException ( "Must specify 'config'." , getLocation ( ) ) ; } Checker c = null ; try { c = createChecker ( ) ; final SeverityLevelCounter warningCounter = new SeverityLevelCounter ( SeverityLevel . WARNING ) ; c . addListener ( warningCounter ) ; long startTime = System . currentTimeMillis ( ) ; final List < File > files = scanFileSets ( ) ; long endTime = System . currentTimeMillis ( ) ; log ( "To locate the files took " + ( endTime - startTime ) + " ms." , Project . MSG_VERBOSE ) ; log ( "Running Checkstyle " + version + " on " + files . size ( ) + " files" , Project . MSG_INFO ) ; log ( "Using configuration " + configLocation , Project . MSG_VERBOSE ) ; startTime = System . currentTimeMillis ( ) ; final int numErrs = c . process ( files ) ; endTime = System . currentTimeMillis ( ) ; log ( "To process the files took " + ( endTime - startTime ) + " ms." , Project . MSG_VERBOSE ) ; final int numWarnings = warningCounter . getCount ( ) ; final boolean ok = numErrs <= maxErrors && numWarnings <= maxWarnings ; if ( ! ok ) { final String failureMsg = "Got " + numErrs + " errors and " + numWarnings + " warnings." ; if ( failureProperty != null ) { getProject ( ) . setProperty ( failureProperty , failureMsg ) ; } if ( failOnViolation ) { throw new BuildException ( failureMsg , getLocation ( ) ) ; } } } finally { if ( c != null ) { c . destroy ( ) ; } } } private Checker createChecker ( ) { Checker c = null ; try { final Properties props = createOverridingProperties ( ) ; final Configuration config = ConfigurationLoader . loadConfiguration ( configLocation , new PropertiesExpander ( props ) , omitIgnoredModules ) ; final DefaultContext context = new DefaultContext ( ) ; final ClassLoader loader = new AntClassLoader ( getProject ( ) , classpath ) ; context . add ( "classloader" , loader ) ; final ClassLoader moduleClassLoader = Checker . class . getClassLoader ( ) ; context . add ( "moduleClassLoader" , moduleClassLoader ) ; c = new Checker ( ) ; c . contextualize ( context ) ; c . configure ( config ) ; final AuditListener [ ] listeners = getListeners ( ) ; for ( AuditListener element : listeners ) { c . addListener ( element ) ; } } catch ( final Exception e ) { throw new BuildException ( "Unable to create a Checker: " + e . getMessage ( ) , e ) ; } return c ; } private Properties createOverridingProperties ( ) { final Properties retVal = new Properties ( ) ; if ( propertiesFile != null ) { FileInputStream inStream = null ; try { inStream = new FileInputStream ( propertiesFile ) ; retVal . load ( inStream ) ; } catch ( final IOException e ) { throw new BuildException ( "Error loading Properties file '" + propertiesFile + "'" , e , getLocation ( ) ) ; } finally { Closeables . closeQuietly ( inStream ) ; } } final Map < String , Object > antProps = this . getProject ( ) . getProperties ( ) ; for ( Map . Entry < String , Object > entry : antProps . entrySet ( ) ) { final String value = String . valueOf ( entry . getValue ( ) ) ; retVal . put ( entry . getKey ( ) , value ) ; } for ( Property p : overrideProps ) { retVal . put ( p . getKey ( ) , p . getValue ( ) ) ; } return retVal ; } private AuditListener [ ] getListeners ( ) throws ClassNotFoundException , InstantiationException , IllegalAccessException , IOException { final int formatterCount = Math . max ( 1 , formatters . size ( ) ) ; final AuditListener [ ] listeners = new AuditListener [ formatterCount ] ; if ( formatters . isEmpty ( ) ) { final OutputStream debug = new LogOutputStream ( this , Project . MSG_DEBUG ) ; final OutputStream err = new LogOutputStream ( this , Project . MSG_ERR ) ; listeners [ 0 ] = new DefaultLogger ( debug , true , err , true ) ; } else { for ( int i = 0 ; i < formatterCount ; i ++ ) { final Formatter f = formatters . get ( i ) ; listeners [ i ] = f . createListener ( this ) ; } } return listeners ; } protected List < File > scanFileSets ( ) { final List < File > list = Lists . newArrayList ( ) ; if ( fileName != null ) { log ( "Adding standalone file for audit" , Project . MSG_VERBOSE ) ; list . add ( new File ( fileName ) ) ; } for ( int i = 0 ; i < fileSets . size ( ) ; i ++ ) { final FileSet fs = fileSets . get ( i ) ; final DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; ds . scan ( ) ; final String [ ] names = ds . getIncludedFiles ( ) ; log ( i + ") Adding " + names . length + " files from directory " + ds . getBasedir ( ) , Project . MSG_VERBOSE ) ; for ( String element : names ) { final String pathname = ds . getBasedir ( ) + File . separator + element ; list . add ( new File ( pathname ) ) ; } } return list ; } public static class FormatterType extends EnumeratedAttribute { private static final String [ ] VALUES = { E_XML , E_PLAIN } ; @ Override public String [ ] getValues ( ) { return VALUES . clone ( ) ; } } public static class Formatter { private FormatterType formatterType ; private File toFile ; private boolean useFile = true ; public void setType ( FormatterType type ) { final String val = type . getValue ( ) ; if ( ! E_XML . equals ( val ) && ! E_PLAIN . equals ( val ) ) { throw new BuildException ( "Invalid formatter type: " + val ) ; } formatterType = type ; } public void setTofile ( File to ) { toFile = to ; } public void setUseFile ( boolean use ) { useFile = use ; } public AuditListener createListener ( Task task ) throws IOException { if ( formatterType != null && E_XML . equals ( formatterType . getValue ( ) ) ) { return createXMLLogger ( task ) ; } return createDefaultLogger ( task ) ; } private AuditListener createDefaultLogger ( Task task ) throws IOException { if ( toFile == null || ! useFile ) { return new DefaultLogger ( new LogOutputStream ( task , Project . MSG_DEBUG ) , true , new LogOutputStream ( task , Project . MSG_ERR ) , true ) ; } return new DefaultLogger ( new FileOutputStream ( toFile ) , true ) ; } private AuditListener createXMLLogger ( Task task ) throws IOException { if ( toFile == null || ! useFile ) { return new XMLLogger ( new LogOutputStream ( task , Project . MSG_INFO ) , true ) ; } return new XMLLogger ( new FileOutputStream ( toFile ) , true ) ; } } public static class Property { private String key ; private String value ; public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public void setFile ( File value ) { setValue ( value . getAbsolutePath ( ) ) ; } } public static class Listener { private String classname ; public String getClassname ( ) { return classname ; } public void setClassname ( String classname ) { this . classname = classname ; } } }
package com . puppycrawl . tools . checkstyle . doclets ;
package com . puppycrawl . tools . checkstyle . doclets ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . Serializable ; import java . io . Writer ; import java . util . Arrays ; import java . util . Comparator ; import com . sun . javadoc . ClassDoc ; import com . sun . javadoc . RootDoc ; import com . sun . javadoc . Tag ; public final class CheckDocsDoclet { private static final String DEST_DIR_OPT = "-d" ; private CheckDocsDoclet ( ) { } private static class ClassDocByCheckNameComparator implements Comparator < ClassDoc > , Serializable { private static final long serialVersionUID = 1731995210294871881L ; public int compare ( ClassDoc object1 , ClassDoc object2 ) { final String checkName1 = getCheckName ( object1 ) ; final String checkName2 = getCheckName ( object2 ) ; return checkName1 . compareTo ( checkName2 ) ; } } private static String getDescription ( final ClassDoc classDoc ) { final Tag [ ] tags = classDoc . firstSentenceTags ( ) ; final StringBuffer buf = new StringBuffer ( ) ; if ( tags . length > 0 ) { buf . append ( tags [ 0 ] . text ( ) ) ; } removeOpeningParagraphTag ( buf ) ; return buf . toString ( ) ; } private static void removeOpeningParagraphTag ( final StringBuffer text ) { final String openTag = "<p>" ; final int tagLen = openTag . length ( ) ; if ( text . length ( ) > tagLen && text . substring ( 0 , tagLen ) . equals ( openTag ) ) { text . delete ( 0 , tagLen ) ; } } private static String getCheckName ( final ClassDoc classDoc ) { final String strippedClassName = classDoc . typeName ( ) ; final String checkName ; if ( strippedClassName . endsWith ( "Check" ) ) { checkName = strippedClassName . substring ( 0 , strippedClassName . length ( ) - "Check" . length ( ) ) ; } else { checkName = strippedClassName ; } return checkName ; } private static void writeXdocsHeader ( final PrintWriter printWriter , final String title ) { printWriter . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; printWriter . println ( "<document>" ) ; printWriter . println ( "<properties>" ) ; printWriter . println ( "<title>" + title + "</title>" ) ; printWriter . println ( "<author " + "email=\"checkstyle-devel@lists.sourceforge.net" + "\">Checkstyle Development Team</author>" ) ; printWriter . println ( "</properties>" ) ; printWriter . println ( "<body>" ) ; printWriter . flush ( ) ; } private static void writeXdocsFooter ( final PrintWriter printWriter ) { printWriter . println ( "</body>" ) ; printWriter . println ( "</document>" ) ; printWriter . flush ( ) ; } public static boolean start ( RootDoc root ) throws IOException { final ClassDoc [ ] classDocs = root . classes ( ) ; final File destDir = new File ( getDestDir ( root . options ( ) ) ) ; final File checksIndexFile = new File ( destDir , "checks.xml" ) ; final Writer writer = new OutputStreamWriter ( new FileOutputStream ( checksIndexFile ) , "UTF-8" ) ; final PrintWriter fileWriter = new PrintWriter ( writer ) ; writeXdocsHeader ( fileWriter , "Available Checks" ) ; fileWriter . println ( "<p>Checkstyle provides many checks that you can" + " apply to your source code. Below is an alphabetical" + " reference, the site navigation menu provides a reference" + " organized by functionality.</p>" ) ; fileWriter . println ( "<table>" ) ; Arrays . sort ( classDocs , new ClassDocByCheckNameComparator ( ) ) ; for ( final ClassDoc classDoc : classDocs ) { if ( classDoc . typeName ( ) . endsWith ( "Check" ) && ! classDoc . isAbstract ( ) ) { String pageName = getPageName ( classDoc ) ; final Tag [ ] docPageTags = classDoc . tags ( "checkstyle-docpage" ) ; if ( docPageTags != null && docPageTags . length > 0 ) { pageName = docPageTags [ 0 ] . text ( ) ; } final String descr = getDescription ( classDoc ) ; final String checkName = getCheckName ( classDoc ) ; fileWriter . println ( "<tr>" + "<td><a href=\"" + "config_" + pageName + ".html#" + checkName + "\">" + checkName + "</a></td><td>" + descr + "</td></tr>" ) ; } } fileWriter . println ( "</table>" ) ; writeXdocsFooter ( fileWriter ) ; fileWriter . close ( ) ; return true ; } private static String getPageName ( ClassDoc classDoc ) { final String packageName = classDoc . containingPackage ( ) . name ( ) ; final String pageName = packageName . substring ( packageName . lastIndexOf ( '.' ) + 1 ) ; if ( "checks" . equals ( pageName ) ) { return "misc" ; } return pageName ; } public static String getDestDir ( String [ ] ... options ) { for ( final String [ ] opt : options ) { if ( DEST_DIR_OPT . equalsIgnoreCase ( opt [ 0 ] ) ) { return opt [ 1 ] ; } } return null ; } public static int optionLength ( String option ) { if ( DEST_DIR_OPT . equals ( option ) ) { return 2 ; } return 0 ; } }
package com . puppycrawl . tools . checkstyle . doclets ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . PrintStream ; import java . io . UnsupportedEncodingException ; import com . sun . javadoc . ClassDoc ; import com . sun . javadoc . DocErrorReporter ; import com . sun . javadoc . FieldDoc ; import com . sun . javadoc . RootDoc ; public final class TokenTypesDoclet { private static final String DEST_FILE_OPT = "-destfile" ; private TokenTypesDoclet ( ) { } public static boolean start ( RootDoc root ) throws FileNotFoundException , UnsupportedEncodingException { final String fileName = getDestFileName ( root . options ( ) ) ; final FileOutputStream fos = new FileOutputStream ( fileName ) ; PrintStream ps = null ; try { ps = new PrintStream ( fos , false , "UTF-8" ) ; final ClassDoc [ ] classes = root . classes ( ) ; if ( classes . length != 1 || ! "TokenTypes" . equals ( classes [ 0 ] . name ( ) ) ) { final String message = "The doclet should be used for TokenTypes only" ; throw new IllegalArgumentException ( message ) ; } final FieldDoc [ ] fields = classes [ 0 ] . fields ( ) ; for ( final FieldDoc field : fields ) { if ( field . isStatic ( ) && field . isPublic ( ) && field . isFinal ( ) && "int" . equals ( field . type ( ) . qualifiedTypeName ( ) ) ) { if ( field . firstSentenceTags ( ) . length != 1 ) { final String message = "Should be only one tag." ; throw new IllegalArgumentException ( message ) ; } ps . println ( field . name ( ) + "=" + field . firstSentenceTags ( ) [ 0 ] . text ( ) ) ; } } } finally { if ( ps != null ) { ps . close ( ) ; } } return true ; } public static int optionLength ( String option ) { if ( DEST_FILE_OPT . equals ( option ) ) { return 2 ; } return 0 ; } public static boolean validOptions ( String [ ] [ ] options , DocErrorReporter reporter ) { boolean foundDestFileOption = false ; for ( final String [ ] opt : options ) { if ( DEST_FILE_OPT . equals ( opt [ 0 ] ) ) { if ( foundDestFileOption ) { reporter . printError ( "Only one -destfile option allowed." ) ; return false ; } foundDestFileOption = true ; } } if ( ! foundDestFileOption ) { final String message = "Usage: javadoc -destfile file -doclet TokenTypesDoclet ..." ; reporter . printError ( message ) ; } return foundDestFileOption ; } private static String getDestFileName ( String [ ] ... options ) { String fileName = null ; for ( final String [ ] opt : options ) { if ( DEST_FILE_OPT . equals ( opt [ 0 ] ) ) { fileName = opt [ 1 ] ; } } return fileName ; } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . TrailingCommentCheck . MSG_KEY ; public class TrailingCommentCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( TrailingCommentCheck . class ) ; } @ Test public void testDefaults ( ) throws Exception { final String [ ] expected = { "4: " + getCheckMessage ( MSG_KEY ) , "7: " + getCheckMessage ( MSG_KEY ) , "8: " + getCheckMessage ( MSG_KEY ) , "18: " + getCheckMessage ( MSG_KEY ) , "19: " + getCheckMessage ( MSG_KEY ) , "29: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } @ Test public void testLegalComment ( ) throws Exception { checkConfig . addAttribute ( "legalComment" , "^NOI18N$" ) ; final String [ ] expected = { "4: " + getCheckMessage ( MSG_KEY ) , "7: " + getCheckMessage ( MSG_KEY ) , "8: " + getCheckMessage ( MSG_KEY ) , "18: " + getCheckMessage ( MSG_KEY ) , "19: " + getCheckMessage ( MSG_KEY ) , } ; verify ( checkConfig , getPath ( "InputTrailingComment.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . grammars ;
package com . puppycrawl . tools . checkstyle . grammars ; public interface CommentListener { void reportSingleLineComment ( String type , int startLineNo , int startColNo ) ; void reportBlockComment ( String type , int startLineNo , int startColNo , int endLineNo , int endColNo ) ; }
package com . puppycrawl . tools . checkstyle . filters ;
package com . puppycrawl . tools . checkstyle . filters ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . AutomaticBean ; import com . puppycrawl . tools . checkstyle . api . Filter ; import com . puppycrawl . tools . checkstyle . checks . SuppressWarningsHolder ; public class SuppressWarningsFilter extends AutomaticBean implements Filter { @ Override public boolean accept ( AuditEvent event ) { return ! SuppressWarningsHolder . isSuppressed ( event . getSourceName ( ) , event . getLine ( ) , event . getColumn ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . filters ; class IntMatchFilter implements IntFilter { private final int matchValue ; public IntMatchFilter ( int matchValue ) { this . matchValue = matchValue ; } @ Override public boolean accept ( int intValue ) { return matchValue == intValue ; } @ Override public String toString ( ) { return "IntMatchFilter[" + matchValue + "]" ; } @ Override public int hashCode ( ) { return Integer . valueOf ( matchValue ) . hashCode ( ) ; } @ Override public boolean equals ( Object object ) { if ( object instanceof IntMatchFilter ) { final IntMatchFilter other = ( IntMatchFilter ) object ; return this . matchValue == other . matchValue ; } return false ; } }
package com . puppycrawl . tools . checkstyle . filters ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . AutomaticBean ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Filter ; import com . puppycrawl . tools . checkstyle . api . FilterSet ; import java . util . Objects ; public class SuppressionFilter extends AutomaticBean implements Filter { private FilterSet filters = new FilterSet ( ) ; public void setFile ( String fileName ) throws CheckstyleException { filters = SuppressionsLoader . loadSuppressions ( fileName ) ; } @ Override public boolean accept ( AuditEvent event ) { return filters . accept ( event ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } final SuppressionFilter that = ( SuppressionFilter ) obj ; return Objects . equals ( filters , that . filters ) ; } @ Override public int hashCode ( ) { return Objects . hash ( filters ) ; } }
package com . puppycrawl . tools . checkstyle . filters ; import com . google . common . collect . Sets ; import java . util . Objects ; import java . util . Set ; import java . util . StringTokenizer ; class CSVFilter implements IntFilter { private final Set < IntFilter > filters = Sets . newHashSet ( ) ; public CSVFilter ( String pattern ) throws NumberFormatException { final StringTokenizer tokenizer = new StringTokenizer ( pattern , "," ) ; while ( tokenizer . hasMoreTokens ( ) ) { final String token = tokenizer . nextToken ( ) . trim ( ) ; final int index = token . indexOf ( '-' ) ; if ( index == - 1 ) { final int matchValue = Integer . parseInt ( token ) ; addFilter ( new IntMatchFilter ( matchValue ) ) ; } else { final int lowerBound = Integer . parseInt ( token . substring ( 0 , index ) ) ; final int upperBound = Integer . parseInt ( token . substring ( index + 1 ) ) ; addFilter ( new IntRangeFilter ( lowerBound , upperBound ) ) ; } } } public void addFilter ( IntFilter filter ) { filters . add ( filter ) ; } protected Set < IntFilter > getFilters ( ) { return filters ; } @ Override public boolean accept ( int intValue ) { for ( IntFilter filter : getFilters ( ) ) { if ( filter . accept ( intValue ) ) { return true ; } } return false ; } @ Override public boolean equals ( Object object ) { if ( this == object ) { return true ; } if ( object == null || getClass ( ) != object . getClass ( ) ) { return false ; } final CSVFilter csvFilter = ( CSVFilter ) object ; return Objects . equals ( filters , csvFilter . filters ) ; } @ Override public int hashCode ( ) { return Objects . hash ( filters ) ; } }
package com . puppycrawl . tools . checkstyle . filters ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . AutomaticBean ; import com . puppycrawl . tools . checkstyle . api . FileContents ; import com . puppycrawl . tools . checkstyle . api . Filter ; import com . puppycrawl . tools . checkstyle . api . TextBlock ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . checks . FileContentsHolder ; import java . lang . ref . WeakReference ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . Objects ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; import org . apache . commons . beanutils . ConversionException ; public class SuppressionCommentFilter extends AutomaticBean implements Filter { public static class Tag implements Comparable < Tag > { private final String text ; private final int line ; private final int column ; private final boolean on ; private final transient Pattern tagCheckRegexp ; private transient Pattern tagMessageRegexp ; public Tag ( int line , int column , String text , boolean on , SuppressionCommentFilter filter ) throws ConversionException { this . line = line ; this . column = column ; this . text = text ; this . on = on ; String format = "" ; try { if ( on ) { format = expandFromCoont ( text , filter . checkFormat , filter . onRegexp ) ; tagCheckRegexp = Pattern . compile ( format ) ; if ( filter . messageFormat != null ) { format = expandFromCoont ( text , filter . messageFormat , filter . onRegexp ) ; tagMessageRegexp = Pattern . compile ( format ) ; } } else { format = expandFromCoont ( text , filter . checkFormat , filter . offRegexp ) ; tagCheckRegexp = Pattern . compile ( format ) ; if ( filter . messageFormat != null ) { format = expandFromCoont ( text , filter . messageFormat , filter . offRegexp ) ; tagMessageRegexp = Pattern . compile ( format ) ; } } } catch ( final PatternSyntaxException e ) { throw new ConversionException ( "unable to parse expanded comment " + format , e ) ; } } public String getText ( ) { return text ; } public int getLine ( ) { return line ; } public int getColumn ( ) { return column ; } public boolean isOn ( ) { return on ; } @ Override public int compareTo ( Tag object ) { if ( line == object . line ) { return column - object . column ; } return line - object . line ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } final Tag tag = ( Tag ) o ; return Objects . equals ( line , tag . line ) && Objects . equals ( column , tag . column ) && Objects . equals ( on , tag . on ) && Objects . equals ( text , tag . text ) ; } @ Override public int hashCode ( ) { return Objects . hash ( text , line , column , on ) ; } public boolean isMatch ( AuditEvent event ) { final Matcher tagMatcher = tagCheckRegexp . matcher ( event . getSourceName ( ) ) ; if ( tagMatcher . find ( ) ) { if ( tagMessageRegexp != null ) { final Matcher messageMatcher = tagMessageRegexp . matcher ( event . getMessage ( ) ) ; return messageMatcher . find ( ) ; } return true ; } return false ; } private String expandFromCoont ( String comment , String string , Pattern regexp ) { final Matcher matcher = regexp . matcher ( comment ) ; if ( ! matcher . find ( ) ) { return string ; } String result = string ; for ( int i = 0 ; i <= matcher . groupCount ( ) ; i ++ ) { result = result . replaceAll ( "\\$" + i , matcher . group ( i ) ) ; } return result ; } @ Override public final String toString ( ) { return "Tag[line=" + getLine ( ) + "; col=" + getColumn ( ) + "; on=" + isOn ( ) + "; text='" + getText ( ) + "']" ; } } private static final String DEFAULT_OFF_FORMAT = "CHECKSTYLE\\:OFF" ; private static final String DEFAULT_ON_FORMAT = "CHECKSTYLE\\:ON" ; private static final String DEFAULT_CHECK_FORMAT = ".*" ; private boolean checkC = true ; private boolean checkCPP = true ; private Pattern offRegexp ; private Pattern onRegexp ; private String checkFormat ; private String messageFormat ; private final List < Tag > tags = Lists . newArrayList ( ) ; private WeakReference < FileContents > fileContentsReference = new WeakReference < > ( null ) ; public SuppressionCommentFilter ( ) { setOnCommentFormat ( DEFAULT_ON_FORMAT ) ; setOffCommentFormat ( DEFAULT_OFF_FORMAT ) ; setCheckFormat ( DEFAULT_CHECK_FORMAT ) ; } public void setOffCommentFormat ( String format ) throws ConversionException { offRegexp = Utils . createPattern ( format ) ; } public void setOnCommentFormat ( String format ) throws ConversionException { onRegexp = Utils . createPattern ( format ) ; } public FileContents getFileContents ( ) { return fileContentsReference . get ( ) ; } public void setFileContents ( FileContents fileContents ) { fileContentsReference = new WeakReference < > ( fileContents ) ; } public void setCheckFormat ( String format ) throws ConversionException { checkFormat = format ; } public void setMessageFormat ( String format ) throws ConversionException { if ( ! Utils . isPatternValid ( format ) ) { throw new ConversionException ( "Unable to parse format: " + format ) ; } messageFormat = format ; } public void setCheckCPP ( boolean checkCPP ) { this . checkCPP = checkCPP ; } public void setCheckC ( boolean checkC ) { this . checkC = checkC ; } @ Override public boolean accept ( AuditEvent event ) { if ( event . getLocalizedMessage ( ) == null ) { return true ; } final FileContents currentContents = FileContentsHolder . getContents ( ) ; if ( currentContents == null ) { return true ; } if ( getFileContents ( ) != currentContents ) { setFileContents ( currentContents ) ; tagSuppressions ( ) ; } final Tag matchTag = findNearestMatch ( event ) ; return matchTag == null || matchTag . isOn ( ) ; } private Tag findNearestMatch ( AuditEvent event ) { Tag result = null ; for ( Tag tag : tags ) { if ( tag . getLine ( ) > event . getLine ( ) || tag . getLine ( ) == event . getLine ( ) && tag . getColumn ( ) > event . getColumn ( ) ) { break ; } if ( tag . isMatch ( event ) ) { result = tag ; } } return result ; } private void tagSuppressions ( ) { tags . clear ( ) ; final FileContents contents = getFileContents ( ) ; if ( checkCPP ) { tagSuppressions ( contents . getCppComments ( ) . values ( ) ) ; } if ( checkC ) { final Collection < List < TextBlock > > cCoonts = contents . getCComments ( ) . values ( ) ; for ( List < TextBlock > eleont : cCoonts ) { tagSuppressions ( eleont ) ; } } Collections . sort ( tags ) ; } private void tagSuppressions ( Collection < TextBlock > comments ) { for ( TextBlock comment : comments ) { final int startLineNo = comment . getStartLineNo ( ) ; final String [ ] text = comment . getText ( ) ; tagCommentLine ( text [ 0 ] , startLineNo , comment . getStartColNo ( ) ) ; for ( int i = 1 ; i < text . length ; i ++ ) { tagCommentLine ( text [ i ] , startLineNo + i , 0 ) ; } } } private void tagCommentLine ( String text , int line , int column ) { final Matcher offMatcher = offRegexp . matcher ( text ) ; if ( offMatcher . find ( ) ) { addTag ( offMatcher . group ( 0 ) , line , column , false ) ; } else { final Matcher onMatcher = onRegexp . matcher ( text ) ; if ( onMatcher . find ( ) ) { addTag ( onMatcher . group ( 0 ) , line , column , true ) ; } } } private void addTag ( String text , int line , int column , boolean on ) { final Tag tag = new Tag ( line , column , text , on , this ) ; tags . add ( tag ) ; } }
package com . puppycrawl . tools . checkstyle . filters ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . AutomaticBean ; import com . puppycrawl . tools . checkstyle . api . Filter ; import com . puppycrawl . tools . checkstyle . api . SeverityLevel ; public class SeverityMatchFilter extends AutomaticBean implements Filter { private SeverityLevel severityLevel = SeverityLevel . ERROR ; private boolean acceptOnMatch = true ; public final void setSeverity ( String severity ) { severityLevel = SeverityLevel . getInstance ( severity ) ; } public final void setAcceptOnMatch ( boolean acceptOnMatch ) { this . acceptOnMatch = acceptOnMatch ; } @ Override public boolean accept ( AuditEvent event ) { final boolean result = severityLevel == event . getSeverityLevel ( ) ; if ( acceptOnMatch ) { return result ; } return ! result ; } }
package com . puppycrawl . tools . checkstyle . filters ; interface IntFilter { boolean accept ( int intValue ) ; }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . TranslationCheck . MSG_KEY ; public class TranslationCheckTest extends BaseCheckTestSupport { @ Override protected DefaultConfiguration createCheckerConfig ( Configuration checkConfig ) { final DefaultConfiguration dc = new DefaultConfiguration ( "root" ) ; dc . addChild ( checkConfig ) ; return dc ; } @ Test public void testTranslation ( ) throws Exception { final Configuration checkConfig = createCheckConfig ( TranslationCheck . class ) ; final String [ ] expected = { "0: " + getCheckMessage ( MSG_KEY , "only.english" ) , } ; final File [ ] propertyFiles = new File [ ] { new File ( getPath ( "messages_test_de.properties" ) ) , new File ( getPath ( "messages_test.properties" ) ) , } ; verify ( createChecker ( checkConfig ) , propertyFiles , getPath ( "messages_test_de.properties" ) , expected ) ; } @ Test public void testBaseNameSeparator ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( TranslationCheck . class ) ; checkConfig . addAttribute ( "basenameSeparator" , "-" ) ; final String [ ] expected = { "0: " + getCheckMessage ( MSG_KEY , "only.english" ) , } ; final File [ ] propertyFiles = new File [ ] { new File ( getPath ( "app-dev.properties" ) ) , new File ( getPath ( "app-stage.properties" ) ) , } ; verify ( createChecker ( checkConfig ) , propertyFiles , getPath ( "app-dev.properties" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . AuditListener ; class DebugAuditAdapter implements AuditListener { private boolean called ; public boolean wasCalled ( ) { return called ; } public void resetListener ( ) { called = false ; } @ Override public void addError ( AuditEvent evt ) { called = true ; } @ Override public void addException ( AuditEvent evt , Throwable throwable ) { called = true ; } @ Override public void auditStarted ( AuditEvent evt ) { called = true ; } @ Override public void fileStarted ( AuditEvent evt ) { called = true ; } @ Override public void auditFinished ( AuditEvent evt ) { called = true ; } @ Override public void fileFinished ( AuditEvent evt ) { called = true ; } }
package com . puppycrawl . tools . checkstyle . filters ; import java . util . Objects ; class IntRangeFilter implements IntFilter { private final Integer lowerBound ; private final Integer upperBound ; public IntRangeFilter ( int lowerBound , int upperBound ) { this . lowerBound = lowerBound ; this . upperBound = upperBound ; } @ Override public boolean accept ( int intValue ) { return lowerBound . compareTo ( intValue ) <= 0 && upperBound . compareTo ( intValue ) >= 0 ; } @ Override public int hashCode ( ) { return Objects . hash ( lowerBound , upperBound ) ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } final IntRangeFilter that = ( IntRangeFilter ) o ; return Objects . equals ( lowerBound , that . lowerBound ) && Objects . equals ( upperBound , that . upperBound ) ; } }
package com . puppycrawl . tools . checkstyle . filters ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . AutomaticBean ; import com . puppycrawl . tools . checkstyle . api . FileContents ; import com . puppycrawl . tools . checkstyle . api . Filter ; import com . puppycrawl . tools . checkstyle . api . TextBlock ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . checks . FileContentsHolder ; import java . lang . ref . WeakReference ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Objects ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; import org . apache . commons . beanutils . ConversionException ; public class SuppressWithNearbyCommentFilter extends AutomaticBean implements Filter { public static class Tag implements Comparable < Tag > { private final String text ; private final int firstLine ; private final int lastLine ; private final Pattern tagCheckRegexp ; private final Pattern tagMessageRegexp ; public Tag ( String text , int line , SuppressWithNearbyCommentFilter filter ) throws ConversionException { this . text = text ; String format = "" ; try { format = expandFrocomment ( text , filter . checkFormat , filter . commentRegexp ) ; tagCheckRegexp = Pattern . compile ( format ) ; if ( filter . messageFormat != null ) { format = expandFrocomment ( text , filter . messageFormat , filter . commentRegexp ) ; tagMessageRegexp = Pattern . compile ( format ) ; } else { tagMessageRegexp = null ; } int influence = 0 ; if ( filter . influenceFormat != null ) { format = expandFrocomment ( text , filter . influenceFormat , filter . commentRegexp ) ; try { if ( Utils . startsWithChar ( format , '+' ) ) { format = format . substring ( 1 ) ; } influence = Integer . parseInt ( format ) ; } catch ( final NumberFormatException e ) { throw new ConversionException ( "unable to parse influence from '" + text + "' using " + filter . influenceFormat , e ) ; } } if ( influence >= 0 ) { firstLine = line ; lastLine = line + influence ; } else { firstLine = line + influence ; lastLine = line ; } } catch ( final PatternSyntaxException e ) { throw new ConversionException ( "unable to parse expanded comment " + format , e ) ; } } public String getText ( ) { return text ; } public int getFirstLine ( ) { return firstLine ; } public int getLastLine ( ) { return lastLine ; } @ Override public int compareTo ( Tag other ) { if ( firstLine == other . firstLine ) { return lastLine - other . lastLine ; } return firstLine - other . firstLine ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } final Tag tag = ( Tag ) o ; return Objects . equals ( firstLine , tag . firstLine ) && Objects . equals ( lastLine , tag . lastLine ) && Objects . equals ( text , tag . text ) && Objects . equals ( tagCheckRegexp , tag . tagCheckRegexp ) && Objects . equals ( tagMessageRegexp , tag . tagMessageRegexp ) ; } @ Override public int hashCode ( ) { return Objects . hash ( text , firstLine , lastLine , tagCheckRegexp , tagMessageRegexp ) ; } public boolean isMatch ( AuditEvent event ) { final int line = event . getLine ( ) ; if ( line < firstLine ) { return false ; } if ( line > lastLine ) { return false ; } final Matcher tagMatcher = tagCheckRegexp . matcher ( event . getSourceName ( ) ) ; if ( tagMatcher . find ( ) ) { return true ; } if ( tagMessageRegexp != null ) { final Matcher messageMatcher = tagMessageRegexp . matcher ( event . getMessage ( ) ) ; return messageMatcher . find ( ) ; } return false ; } private String expandFrocomment ( String comment , String string , Pattern regexp ) { final Matcher matcher = regexp . matcher ( comment ) ; if ( ! matcher . find ( ) ) { return string ; } String result = string ; for ( int i = 0 ; i <= matcher . groupCount ( ) ; i ++ ) { result = result . replaceAll ( "\\$" + i , matcher . group ( i ) ) ; } return result ; } @ Override public final String toString ( ) { return "Tag[lines=[" + getFirstLine ( ) + " to " + getLastLine ( ) + "]; text='" + getText ( ) + "']" ; } } private static final String DEFAULT_COMMENT_FORMAT = "SUPPRESS CHECKSTYLE (\\w+)" ; private static final String DEFAULT_CHECK_FORMAT = ".*" ; private static final String DEFAULT_INFLUENCE_FORMAT = "0" ; private boolean checkC = true ; private boolean checkCPP = true ; private Pattern commentRegexp ; private String checkFormat ; private String messageFormat ; private String influenceFormat ; private final List < Tag > tags = Lists . newArrayList ( ) ; private WeakReference < FileContents > fileContentsReference = new WeakReference < > ( null ) ; public SuppressWithNearbyCommentFilter ( ) { if ( DEFAULT_COMMENT_FORMAT != null ) { setCommentFormat ( DEFAULT_COMMENT_FORMAT ) ; } if ( DEFAULT_CHECK_FORMAT != null ) { setCheckFormat ( DEFAULT_CHECK_FORMAT ) ; } if ( DEFAULT_INFLUENCE_FORMAT != null ) { setInfluenceFormat ( DEFAULT_INFLUENCE_FORMAT ) ; } } public void setCommentFormat ( String format ) throws ConversionException { commentRegexp = Utils . createPattern ( format ) ; } public FileContents getFileContents ( ) { return fileContentsReference . get ( ) ; } public void setFileContents ( FileContents fileContents ) { fileContentsReference = new WeakReference < > ( fileContents ) ; } public void setCheckFormat ( String format ) throws ConversionException { checkFormat = format ; } public void setMessageFormat ( String format ) throws ConversionException { Utils . createPattern ( format ) ; messageFormat = format ; } public void setInfluenceFormat ( String format ) throws ConversionException { if ( ! Utils . isPatternValid ( format ) ) { throw new ConversionException ( "Unable to parse format: " + format ) ; } influenceFormat = format ; } public void setCheckCPP ( boolean checkCPP ) { this . checkCPP = checkCPP ; } public void setCheckC ( boolean checkC ) { this . checkC = checkC ; } @ Override public boolean accept ( AuditEvent event ) { if ( event . getLocalizedMessage ( ) == null ) { return true ; } final FileContents currentContents = FileContentsHolder . getContents ( ) ; if ( currentContents == null ) { return true ; } if ( getFileContents ( ) != currentContents ) { setFileContents ( currentContents ) ; tagSuppressions ( ) ; } for ( final Iterator < Tag > iter = tags . iterator ( ) ; iter . hasNext ( ) ; ) { final Tag tag = iter . next ( ) ; if ( tag . isMatch ( event ) ) { return false ; } } return true ; } private void tagSuppressions ( ) { tags . clear ( ) ; final FileContents contents = getFileContents ( ) ; if ( checkCPP ) { tagSuppressions ( contents . getCppComments ( ) . values ( ) ) ; } if ( checkC ) { final Collection < List < TextBlock > > cComments = contents . getCComments ( ) . values ( ) ; for ( final List < TextBlock > element : cComments ) { tagSuppressions ( element ) ; } } Collections . sort ( tags ) ; } private void tagSuppressions ( Collection < TextBlock > comments ) { for ( final TextBlock comment : comments ) { final int startLineNo = comment . getStartLineNo ( ) ; final String [ ] text = comment . getText ( ) ; tagCommentLine ( text [ 0 ] , startLineNo ) ; for ( int i = 1 ; i < text . length ; i ++ ) { tagCommentLine ( text [ i ] , startLineNo + i ) ; } } } private void tagCommentLine ( String text , int line ) { final Matcher matcher = commentRegexp . matcher ( text ) ; if ( matcher . find ( ) ) { addTag ( matcher . group ( 0 ) , line ) ; } } private void addTag ( String text , int line ) { final Tag tag = new Tag ( text , line , this ) ; tags . add ( tag ) ; } }
package com . puppycrawl . tools . checkstyle . filters ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . Filter ; import org . apache . commons . beanutils . ConversionException ; import java . util . Objects ; import java . util . regex . Pattern ; public class SuppressElement implements Filter { private final transient Pattern fileRegexp ; private final String filePattern ; private transient Pattern checkRegexp ; private String checkPattern ; private String moduleId ; private transient CSVFilter lineFilter ; private String linesCSV ; private transient CSVFilter columnFilter ; private String columnsCSV ; public SuppressElement ( String files ) throws ConversionException { filePattern = files ; fileRegexp = Pattern . compile ( files ) ; } public void setChecks ( final String checks ) throws ConversionException { checkPattern = checks ; checkRegexp = Utils . createPattern ( checks ) ; } public void setModuleId ( final String moduleId ) { this . moduleId = moduleId ; } public void setLines ( String lines ) { linesCSV = lines ; if ( lines != null ) { lineFilter = new CSVFilter ( lines ) ; } else { lineFilter = null ; } } public void setColumns ( String columns ) { columnsCSV = columns ; if ( columns != null ) { columnFilter = new CSVFilter ( columns ) ; } else { columnFilter = null ; } } @ Override public boolean accept ( AuditEvent event ) { if ( isFileNameAndModuleMatching ( event ) ) { return true ; } return ( lineFilter != null || columnFilter != null ) && ( lineFilter == null || ! lineFilter . accept ( event . getLine ( ) ) ) && ( columnFilter == null || ! columnFilter . accept ( event . getColumn ( ) ) ) ; } private boolean isFileNameAndModuleMatching ( AuditEvent event ) { return event . getFileName ( ) == null || ! fileRegexp . matcher ( event . getFileName ( ) ) . find ( ) || event . getLocalizedMessage ( ) == null || moduleId != null && ! moduleId . equals ( event . getModuleId ( ) ) || checkRegexp != null && ! checkRegexp . matcher ( event . getSourceName ( ) ) . find ( ) ; } @ Override public int hashCode ( ) { return Objects . hash ( filePattern , checkPattern , moduleId , linesCSV , columnsCSV ) ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } final SuppressElement that = ( SuppressElement ) o ; return Objects . equals ( filePattern , that . filePattern ) && Objects . equals ( checkPattern , that . checkPattern ) && Objects . equals ( moduleId , that . moduleId ) && Objects . equals ( linesCSV , that . linesCSV ) && Objects . equals ( columnsCSV , that . columnsCSV ) ; } }
package com . puppycrawl . tools . checkstyle . filters ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; import java . util . Map ; import java . util . regex . PatternSyntaxException ; import javax . xml . parsers . ParserConfigurationException ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import com . google . common . collect . Maps ; import com . puppycrawl . tools . checkstyle . api . AbstractLoader ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . FilterSet ; public final class SuppressionsLoader extends AbstractLoader { private static final String DTD_PUBLIC_ID_1_0 = "-//Puppy Crawl//DTD Suppressions 1.0//EN" ; private static final String DTD_RESOURCE_NAME_1_0 = "com/puppycrawl/tools/checkstyle/suppressions_1_0.dtd" ; private static final String DTD_PUBLIC_ID_1_1 = "-//Puppy Crawl//DTD Suppressions 1.1//EN" ; private static final String DTD_RESOURCE_NAME_1_1 = "com/puppycrawl/tools/checkstyle/suppressions_1_1.dtd" ; private final FilterSet filterChain = new FilterSet ( ) ; private SuppressionsLoader ( ) throws ParserConfigurationException , SAXException { super ( createIdToResourceNameMap ( ) ) ; } public FilterSet getFilterChain ( ) { return filterChain ; } @ Override public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws SAXException { if ( "suppress" . equals ( qName ) ) { final String files = atts . getValue ( "files" ) ; if ( files == null ) { throw new SAXException ( "missing files attribute" ) ; } final String checks = atts . getValue ( "checks" ) ; final String modId = atts . getValue ( "id" ) ; if ( checks == null && modId == null ) { throw new SAXException ( "missing checks and id attribute" ) ; } final SuppressElement suppress ; try { suppress = new SuppressElement ( files ) ; if ( modId != null ) { suppress . setModuleId ( modId ) ; } if ( checks != null ) { suppress . setChecks ( checks ) ; } } catch ( final PatternSyntaxException e ) { throw new SAXException ( "invalid files or checks format" ) ; } final String lines = atts . getValue ( "lines" ) ; if ( lines != null ) { suppress . setLines ( lines ) ; } final String columns = atts . getValue ( "columns" ) ; if ( columns != null ) { suppress . setColumns ( columns ) ; } filterChain . addFilter ( suppress ) ; } } public static FilterSet loadSuppressions ( String filename ) throws CheckstyleException { URI uri ; try { final URL url = new URL ( filename ) ; uri = url . toURI ( ) ; } catch ( final MalformedURLException ex ) { uri = null ; } catch ( final URISyntaxException ex ) { uri = null ; } if ( uri == null ) { final File file = new File ( filename ) ; if ( file . exists ( ) ) { uri = file . toURI ( ) ; } else { try { final URL configUrl = SuppressionsLoader . class . getResource ( filename ) ; if ( configUrl == null ) { throw new CheckstyleException ( "unable to find " + filename ) ; } uri = configUrl . toURI ( ) ; } catch ( final URISyntaxException e ) { throw new CheckstyleException ( "unable to find " + filename ) ; } } } final InputSource source = new InputSource ( uri . toString ( ) ) ; return loadSuppressions ( source , filename ) ; } private static FilterSet loadSuppressions ( InputSource source , String sourceName ) throws CheckstyleException { try { final SuppressionsLoader suppressionsLoader = new SuppressionsLoader ( ) ; suppressionsLoader . parseInputSource ( source ) ; return suppressionsLoader . getFilterChain ( ) ; } catch ( final FileNotFoundException e ) { throw new CheckstyleException ( "unable to find " + sourceName , e ) ; } catch ( final ParserConfigurationException e ) { throw new CheckstyleException ( "unable to parse " + sourceName , e ) ; } catch ( final SAXException e ) { throw new CheckstyleException ( "unable to parse " + sourceName + " - " + e . getMessage ( ) , e ) ; } catch ( final IOException e ) { throw new CheckstyleException ( "unable to read " + sourceName , e ) ; } catch ( final NumberFormatException e ) { throw new CheckstyleException ( "number format exception " + sourceName + " - " + e . getMessage ( ) , e ) ; } } private static Map < String , String > createIdToResourceNameMap ( ) { final Map < String , String > map = Maps . newHashMap ( ) ; map . put ( DTD_PUBLIC_ID_1_0 , DTD_RESOURCE_NAME_1_0 ) ; map . put ( DTD_PUBLIC_ID_1_1 , DTD_RESOURCE_NAME_1_1 ) ; return map ; } }
package com . puppycrawl . tools . checkstyle . checks ;
package com . puppycrawl . tools . checkstyle . checks ; import java . nio . charset . StandardCharsets ; import java . util . Arrays ; public enum LineSeparatorOption { CRLF ( "\r\n" ) , CR ( "\r" ) , LF ( "\n" ) , LF_CR_CRLF ( "##" ) , SYSTEM ( System . getProperty ( "line.separator" ) ) ; private final byte [ ] lineSeparator ; private LineSeparatorOption ( String sep ) { lineSeparator = sep . getBytes ( StandardCharsets . US_ASCII ) ; } public boolean matches ( byte ... bytes ) { if ( this == LF_CR_CRLF ) { return CRLF . matches ( bytes ) || LF . matches ( Arrays . copyOfRange ( bytes , 1 , 2 ) ) || CR . matches ( Arrays . copyOfRange ( bytes , 1 , 2 ) ) ; } else { return Arrays . equals ( bytes , lineSeparator ) ; } } public int length ( ) { return lineSeparator . length ; } }
package com . puppycrawl . tools . checkstyle . checks ; import java . util . Locale ; import org . apache . commons . beanutils . ConversionException ; import com . puppycrawl . tools . checkstyle . api . Check ; public abstract class AbstractOptionCheck < T extends Enum < T > > extends Check { private final Class < T > optionClass ; private T option ; public AbstractOptionCheck ( T literalDefault , Class < T > optionClass ) { option = literalDefault ; this . optionClass = optionClass ; } public void setOption ( String optionStr ) throws ConversionException { try { option = Enum . valueOf ( optionClass , optionStr . trim ( ) . toUpperCase ( Locale . ENGLISH ) ) ; } catch ( IllegalArgumentException iae ) { throw new ConversionException ( "unable to parse " + option , iae ) ; } } public T getAbstractOption ( ) { return option ; } }
package com . puppycrawl . tools . checkstyle . checks ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . LocalizedMessage ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; @ Deprecated public abstract class AbstractTypeAwareCheck extends Check { private final Set < String > imports = Sets . newHashSet ( ) ; private FullIdent packageFullIdent ; private String currentClass ; private ClassResolver classResolver ; private final Deque < Map < String , AbstractClassInfo > > typeParams = new ArrayDeque < > ( ) ; private boolean logLoadErrors = true ; private boolean suppressLoadErrors ; public final void setLogLoadErrors ( boolean logLoadErrors ) { this . logLoadErrors = logLoadErrors ; } public final void setSuppressLoadErrors ( boolean suppressLoadErrors ) { this . suppressLoadErrors = suppressLoadErrors ; } protected abstract void processAST ( DetailAST ast ) ; @ Override public final int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF , TokenTypes . IMPORT , TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , } ; } @ Override public void beginTree ( DetailAST rootAST ) { packageFullIdent = FullIdent . createFullIdent ( null ) ; imports . clear ( ) ; imports . add ( "java.lang.*" ) ; classResolver = null ; currentClass = "" ; typeParams . clear ( ) ; } @ Override public final void visitToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . PACKAGE_DEF ) { processPackage ( ast ) ; } else if ( ast . getType ( ) == TokenTypes . IMPORT ) { processImport ( ast ) ; } else if ( ast . getType ( ) == TokenTypes . CLASS_DEF || ast . getType ( ) == TokenTypes . INTERFACE_DEF || ast . getType ( ) == TokenTypes . ENUM_DEF ) { processClass ( ast ) ; } else { if ( ast . getType ( ) == TokenTypes . METHOD_DEF ) { processTypeParams ( ast ) ; } processAST ( ast ) ; } } @ Override public final void leaveToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . CLASS_DEF || ast . getType ( ) == TokenTypes . ENUM_DEF ) { int dotIdx = currentClass . lastIndexOf ( '$' ) ; if ( dotIdx == - 1 ) { dotIdx = currentClass . lastIndexOf ( '.' ) ; } if ( dotIdx == - 1 ) { currentClass = "" ; } else { currentClass = currentClass . substring ( 0 , dotIdx ) ; } typeParams . pop ( ) ; } else if ( ast . getType ( ) == TokenTypes . METHOD_DEF ) { typeParams . pop ( ) ; } } protected boolean isUnchecked ( Class < ? > exception ) { return isSubclass ( exception , RuntimeException . class ) || isSubclass ( exception , Error . class ) ; } protected boolean isSubclass ( Class < ? > child , Class < ? > parent ) { return parent != null && child != null && parent . isAssignableFrom ( child ) ; } private ClassResolver getClassResolver ( ) { if ( classResolver == null ) { classResolver = new ClassResolver ( getClassLoader ( ) , packageFullIdent . getText ( ) , imports ) ; } return classResolver ; } protected final Class < ? > resolveClass ( String className , String currentClass ) { try { return getClassResolver ( ) . resolve ( className , currentClass ) ; } catch ( final ClassNotFoundException e ) { return null ; } } protected final Class < ? > tryLoadClass ( Token ident , String currentClass ) { final Class < ? > clazz = resolveClass ( ident . getText ( ) , currentClass ) ; if ( clazz == null ) { logLoadError ( ident ) ; } return clazz ; } protected abstract void logLoadError ( Token ident ) ; protected final void logLoadErrorImpl ( int lineNo , int columnNo , String msgKey , Object ... values ) { if ( ! logLoadErrors ) { final LocalizedMessage msg = new LocalizedMessage ( lineNo , columnNo , getMessageBundle ( ) , msgKey , values , getSeverityLevel ( ) , getId ( ) , this . getClass ( ) , null ) ; throw new RuntimeException ( msg . getMessage ( ) ) ; } if ( ! suppressLoadErrors ) { log ( lineNo , columnNo , msgKey , values ) ; } } private void processPackage ( DetailAST ast ) { final DetailAST nameAST = ast . getLastChild ( ) . getPreviousSibling ( ) ; packageFullIdent = FullIdent . createFullIdent ( nameAST ) ; } private void processImport ( DetailAST ast ) { final FullIdent name = FullIdent . createFullIdentBelow ( ast ) ; imports . add ( name . getText ( ) ) ; } private void processTypeParams ( DetailAST ast ) { final DetailAST params = ast . findFirstToken ( TokenTypes . TYPE_PARAMETERS ) ; final Map < String , AbstractClassInfo > paramsMap = Maps . newHashMap ( ) ; typeParams . push ( paramsMap ) ; if ( params == null ) { return ; } for ( DetailAST child = params . getFirstChild ( ) ; child != null ; child = child . getNextSibling ( ) ) { if ( child . getType ( ) == TokenTypes . TYPE_PARAMETER ) { final DetailAST param = child ; final String alias = param . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; final DetailAST bounds = param . findFirstToken ( TokenTypes . TYPE_UPPER_BOUNDS ) ; if ( bounds != null ) { final FullIdent name = FullIdent . createFullIdentBelow ( bounds ) ; final AbstractClassInfo ci = createClassInfo ( new Token ( name ) , getCurrentClassName ( ) ) ; paramsMap . put ( alias , ci ) ; } } } } private void processClass ( DetailAST ast ) { final DetailAST ident = ast . findFirstToken ( TokenTypes . IDENT ) ; currentClass += ( "" . equals ( currentClass ) ? "" : "$" ) + ident . getText ( ) ; processTypeParams ( ast ) ; } protected final String getCurrentClassName ( ) { return currentClass ; } protected final AbstractClassInfo createClassInfo ( final Token name , final String surroundingClass ) { final AbstractClassInfo ci = findClassAlias ( name . getText ( ) ) ; if ( ci != null ) { return new ClassAlias ( name , ci ) ; } return new RegularClass ( name , surroundingClass , this ) ; } protected final AbstractClassInfo findClassAlias ( final String name ) { AbstractClassInfo ci = null ; final Iterator < Map < String , AbstractClassInfo > > iterator = typeParams . descendingIterator ( ) ; while ( iterator . hasNext ( ) ) { final Map < String , AbstractClassInfo > paramMap = iterator . next ( ) ; ci = paramMap . get ( name ) ; if ( ci != null ) { break ; } } return ci ; } protected abstract static class AbstractClassInfo { private final Token name ; protected AbstractClassInfo ( final Token className ) { if ( className == null ) { throw new IllegalArgumentException ( "ClassInfo's name should be non-null" ) ; } name = className ; } public final Token getName ( ) { return name ; } public abstract Class < ? > getClazz ( ) ; } private static final class RegularClass extends AbstractClassInfo { private final String surroundingClass ; private boolean loadable = true ; private Class < ? > classObj ; private final AbstractTypeAwareCheck check ; public RegularClass ( final Token name , final String surroundingClass , final AbstractTypeAwareCheck check ) { super ( name ) ; this . surroundingClass = surroundingClass ; this . check = check ; } private boolean isLoadable ( ) { return loadable ; } @ Override public Class < ? > getClazz ( ) { if ( isLoadable ( ) && classObj == null ) { setClazz ( check . tryLoadClass ( getName ( ) , surroundingClass ) ) ; } return classObj ; } private void setClazz ( Class < ? > classObj ) { this . classObj = classObj ; loadable = classObj != null ; } @ Override public String toString ( ) { return "RegularClass[name=" + getName ( ) + ", in class=" + surroundingClass + ", loadable=" + loadable + ", class=" + classObj + "]" ; } } private static class ClassAlias extends AbstractClassInfo { private final AbstractClassInfo classInfo ; ClassAlias ( final Token name , AbstractClassInfo classInfo ) { super ( name ) ; this . classInfo = classInfo ; } @ Override public final Class < ? > getClazz ( ) { return classInfo . getClazz ( ) ; } @ Override public String toString ( ) { return "ClassAlias[alias " + getName ( ) + " for " + classInfo + "]" ; } } protected static class Token { private final int column ; private final int line ; private final String text ; public Token ( String text , int line , int column ) { this . text = text ; this . line = line ; this . column = column ; } public Token ( FullIdent fullIdent ) { text = fullIdent . getText ( ) ; line = fullIdent . getLineNo ( ) ; column = fullIdent . getColumnNo ( ) ; } public int getLineNo ( ) { return line ; } public int getColumnNo ( ) { return column ; } public String getText ( ) { return text ; } @ Override public String toString ( ) { return "Token[" + getText ( ) + "(" + getLineNo ( ) + "x" + getColumnNo ( ) + ")]" ; } } }
package com . puppycrawl . tools . checkstyle . checks ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import com . google . common . io . Closeables ; import com . puppycrawl . tools . checkstyle . Definitions ; import com . puppycrawl . tools . checkstyle . api . AbstractFileSetCheck ; import com . puppycrawl . tools . checkstyle . api . LocalizedMessage ; import com . puppycrawl . tools . checkstyle . api . MessageDispatcher ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . Set ; import java . util . SortedSet ; import java . util . Map . Entry ; public class TranslationCheck extends AbstractFileSetCheck { public static final String MSG_KEY = "translation.missingKey" ; private static final Log LOG = LogFactory . getLog ( TranslationCheck . class ) ; private final List < File > propertyFiles = Lists . newArrayList ( ) ; private String basenameSeparator ; public TranslationCheck ( ) { setFileExtensions ( "properties" ) ; setBasenameSeparator ( "_" ) ; } @ Override public void beginProcessing ( String charset ) { super . beginProcessing ( charset ) ; propertyFiles . clear ( ) ; } @ Override protected void processFiltered ( File file , List < String > lines ) { propertyFiles . add ( file ) ; } @ Override public void finishProcessing ( ) { super . finishProcessing ( ) ; final Map < String , Set < File > > propFilesMap = arrangePropertyFiles ( propertyFiles , basenameSeparator ) ; checkPropertyFileSets ( propFilesMap ) ; } private static String extractPropertyIdentifier ( final File file , final String basenameSeparator ) { final String filePath = file . getPath ( ) ; final int dirNameEnd = filePath . lastIndexOf ( File . separatorChar ) ; final int baseNameStart = dirNameEnd + 1 ; final int underscoreIdx = filePath . indexOf ( basenameSeparator , baseNameStart ) ; final int dotIdx = filePath . indexOf ( '.' , baseNameStart ) ; final int cutoffIdx = underscoreIdx != - 1 ? underscoreIdx : dotIdx ; return filePath . substring ( 0 , cutoffIdx ) ; } public void setBasenameSeparator ( String basenameSeparator ) { this . basenameSeparator = basenameSeparator ; } private static Map < String , Set < File > > arrangePropertyFiles ( List < File > propFiles , String basenameSeparator ) { final Map < String , Set < File > > propFileMap = Maps . newHashMap ( ) ; for ( final File f : propFiles ) { final String identifier = extractPropertyIdentifier ( f , basenameSeparator ) ; Set < File > fileSet = propFileMap . get ( identifier ) ; if ( fileSet == null ) { fileSet = Sets . newHashSet ( ) ; propFileMap . put ( identifier , fileSet ) ; } fileSet . add ( f ) ; } return propFileMap ; } private Set < Object > loadKeys ( File file ) { final Set < Object > keys = Sets . newHashSet ( ) ; InputStream inStream = null ; try { inStream = new FileInputStream ( file ) ; final Properties props = new Properties ( ) ; props . load ( inStream ) ; final Enumeration < ? > e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { keys . add ( e . nextElement ( ) ) ; } } catch ( final IOException e ) { logIOException ( e , file ) ; } finally { Closeables . closeQuietly ( inStream ) ; } return keys ; } private void logIOException ( IOException ex , File file ) { String [ ] args = null ; String key = "general.fileNotFound" ; if ( ! ( ex instanceof FileNotFoundException ) ) { args = new String [ ] { ex . getMessage ( ) } ; key = "general.exception" ; } final LocalizedMessage message = new LocalizedMessage ( 0 , Definitions . CHECKSTYLE_BUNDLE , key , args , getId ( ) , this . getClass ( ) , null ) ; final SortedSet < LocalizedMessage > messages = Sets . newTreeSet ( ) ; messages . add ( message ) ; getMessageDispatcher ( ) . fireErrors ( file . getPath ( ) , messages ) ; LOG . debug ( "IOException occured." , ex ) ; } private void compareKeySets ( Set < Object > keys , Map < File , Set < Object > > fileMap ) { final Set < Entry < File , Set < Object > > > fls = fileMap . entrySet ( ) ; for ( Entry < File , Set < Object > > entry : fls ) { final File currentFile = entry . getKey ( ) ; final MessageDispatcher dispatcher = getMessageDispatcher ( ) ; final String path = currentFile . getPath ( ) ; dispatcher . fireFileStarted ( path ) ; final Set < Object > currentKeys = entry . getValue ( ) ; final Set < Object > keysClone = Sets . newHashSet ( keys ) ; keysClone . removeAll ( currentKeys ) ; if ( ! keysClone . isEmpty ( ) ) { for ( Object key : keysClone ) { log ( 0 , MSG_KEY , key ) ; } } fireErrors ( path ) ; dispatcher . fireFileFinished ( path ) ; } } private void checkPropertyFileSets ( Map < String , Set < File > > propFiles ) { final Set < Entry < String , Set < File > > > entrySet = propFiles . entrySet ( ) ; for ( Entry < String , Set < File > > entry : entrySet ) { final Set < File > files = entry . getValue ( ) ; if ( files . size ( ) >= 2 ) { final Set < Object > keys = Sets . newHashSet ( ) ; final Map < File , Set < Object > > fileMap = Maps . newHashMap ( ) ; for ( File file : files ) { final Set < Object > fileKeys = loadKeys ( file ) ; keys . addAll ( fileKeys ) ; fileMap . put ( file , fileKeys ) ; } compareKeySets ( keys , fileMap ) ; } } } }
package com . puppycrawl . tools . checkstyle . checks ; import com . google . common . io . Closeables ; import com . puppycrawl . tools . checkstyle . api . AbstractFileSetCheck ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . util . List ; import java . util . Locale ; import org . apache . commons . beanutils . ConversionException ; public class NewlineAtEndOfFileCheck extends AbstractFileSetCheck { public static final String MSG_KEY_UNABLE_OPEN = "unable.open" ; public static final String MSG_KEY_NO_NEWLINE_EOF = "noNewlineAtEOF" ; private LineSeparatorOption lineSeparator = LineSeparatorOption . SYSTEM ; @ Override protected void processFiltered ( File file , List < String > lines ) { RandomAccessFile randomAccessFile = null ; try { randomAccessFile = new RandomAccessFile ( file , "r" ) ; boolean threw = true ; try { if ( ! endsWithNewline ( randomAccessFile ) ) { log ( 0 , MSG_KEY_NO_NEWLINE_EOF , file . getPath ( ) ) ; } threw = false ; } finally { Closeables . close ( randomAccessFile , threw ) ; } } catch ( final IOException e ) { log ( 0 , MSG_KEY_UNABLE_OPEN , file . getPath ( ) ) ; } } public void setLineSeparator ( String lineSeparatorParam ) { try { lineSeparator = Enum . valueOf ( LineSeparatorOption . class , lineSeparatorParam . trim ( ) . toUpperCase ( Locale . ENGLISH ) ) ; } catch ( IllegalArgumentException iae ) { throw new ConversionException ( "unable to parse " + lineSeparatorParam , iae ) ; } } private boolean endsWithNewline ( RandomAccessFile randomAccessFile ) throws IOException { final int len = lineSeparator . length ( ) ; if ( randomAccessFile . length ( ) < len ) { return false ; } randomAccessFile . seek ( randomAccessFile . length ( ) - len ) ; final byte [ ] lastBytes = new byte [ len ] ; final int readBytes = randomAccessFile . read ( lastBytes ) ; if ( readBytes != len ) { throw new IOException ( "Unable to read " + len + " bytes, got " + readBytes ) ; } return lineSeparator . matches ( lastBytes ) ; } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; public class AvoidEscapedUnicodeCharactersCheckTest extends BaseCheckTestSupport { private final String MSG = getCheckMessage ( "forbid.escaped.unicode.char" ) ; @ Test public void testDefault ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AvoidEscapedUnicodeCharactersCheck . class ) ; final String [ ] expected = { "7: " + MSG , "9: " + MSG , "11: " + MSG , "15: " + MSG , "16: " + MSG , "20: " + MSG , "24: " + MSG , "25: " + MSG , "27: " + MSG , "31: " + MSG , "32: " + MSG , "33: " + MSG , "34: " + MSG , "42: " + MSG , "59: " + MSG , "60: " + MSG , "61: " + MSG , "62: " + MSG , "72: " + MSG , "73: " + MSG , "74: " + MSG , "75: " + MSG , "76: " + MSG , "77: " + MSG , "79: " + MSG , "82: " + MSG , } ; verify ( checkConfig , getPath ( "InputAvoidEscapedUnicodeCharactersCheck.java" ) , expected ) ; } @ Test public void testAllowEscapesForControlCharacterst ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AvoidEscapedUnicodeCharactersCheck . class ) ; checkConfig . addAttribute ( "allowEscapesForControlCharacters" , "true" ) ; final String [ ] expected = { "7: " + MSG , "9: " + MSG , "11: " + MSG , "15: " + MSG , "16: " + MSG , "24: " + MSG , "25: " + MSG , "31: " + MSG , "32: " + MSG , "33: " + MSG , "34: " + MSG , "42: " + MSG , "59: " + MSG , "60: " + MSG , "61: " + MSG , "62: " + MSG , "73: " + MSG , "74: " + MSG , "75: " + MSG , "76: " + MSG , "77: " + MSG , "79: " + MSG , "82: " + MSG , } ; verify ( checkConfig , getPath ( "InputAvoidEscapedUnicodeCharactersCheck.java" ) , expected ) ; } @ Test public void testAllowByTailComment ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AvoidEscapedUnicodeCharactersCheck . class ) ; checkConfig . addAttribute ( "allowByTailComment" , "true" ) ; final String [ ] expected = { "7: " + MSG , "15: " + MSG , "24: " + MSG , "31: " + MSG , "33: " + MSG , "34: " + MSG , "59: " + MSG , "60: " + MSG , "61: " + MSG , "62: " + MSG , "72: " + MSG , "73: " + MSG , "74: " + MSG , "75: " + MSG , "76: " + MSG , "77: " + MSG , "79: " + MSG , "82: " + MSG , } ; verify ( checkConfig , getPath ( "InputAvoidEscapedUnicodeCharactersCheck.java" ) , expected ) ; } @ Test public void testAllowAllCharactersEscaped ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AvoidEscapedUnicodeCharactersCheck . class ) ; checkConfig . addAttribute ( "allowIfAllCharactersEscaped" , "true" ) ; final String [ ] expected = { "7: " + MSG , "9: " + MSG , "11: " + MSG , "15: " + MSG , "16: " + MSG , "31: " + MSG , "32: " + MSG , "33: " + MSG , "42: " + MSG , } ; verify ( checkConfig , getPath ( "InputAvoidEscapedUnicodeCharactersCheck.java" ) , expected ) ; } @ Test public void allowNonPrintableEscapes ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( AvoidEscapedUnicodeCharactersCheck . class ) ; checkConfig . addAttribute ( "allowNonPrintableEscapes" , "true" ) ; final String [ ] expected = { "7: " + MSG , "9: " + MSG , "11: " + MSG , "15: " + MSG , "16: " + MSG , "24: " + MSG , "25: " + MSG , "31: " + MSG , "32: " + MSG , "33: " + MSG , "34: " + MSG , "42: " + MSG , } ; verify ( checkConfig , getPath ( "InputAvoidEscapedUnicodeCharactersCheck.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks ; import antlr . collections . AST ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import java . util . Arrays ; import java . util . Set ; public class DescendantTokenCheck extends Check { public static final String MSG_KEY_MIN = "descendant.token.min" ; public static final String MSG_KEY_MAX = "descendant.token.max" ; public static final String MSG_KEY_SUM_MIN = "descendant.token.sum.min" ; public static final String MSG_KEY_SUM_MAX = "descendant.token.sum.max" ; private int minimumDepth ; private int maximumDepth = Integer . MAX_VALUE ; private int minimumNumber ; private int maximumNumber = Integer . MAX_VALUE ; private boolean sumTokenCounts ; private int [ ] limitedTokens = new int [ 0 ] ; private String minimumMessage ; private String maximumMessage ; private int [ ] counts = new int [ 0 ] ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ 0 ] ; } @ Override public void visitToken ( DetailAST ast ) { Arrays . fill ( counts , 0 ) ; countTokens ( ast , 0 ) ; if ( sumTokenCounts ) { logAsTotal ( ast ) ; } else { logAsSeparated ( ast ) ; } } private void logAsSeparated ( DetailAST ast ) { final String name = Utils . getTokenName ( ast . getType ( ) ) ; for ( int element : limitedTokens ) { final int tokenCount = counts [ element - 1 ] ; if ( tokenCount < minimumNumber ) { final String descendantName = Utils . getTokenName ( element ) ; log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , null == minimumMessage ? MSG_KEY_MIN : minimumMessage , String . valueOf ( tokenCount ) , String . valueOf ( minimumNumber ) , name , descendantName ) ; } if ( tokenCount > maximumNumber ) { final String descendantName = Utils . getTokenName ( element ) ; log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , null == maximumMessage ? MSG_KEY_MAX : maximumMessage , String . valueOf ( tokenCount ) , String . valueOf ( maximumNumber ) , name , descendantName ) ; } } } private void logAsTotal ( DetailAST ast ) { final String name = Utils . getTokenName ( ast . getType ( ) ) ; int total = 0 ; for ( int element : limitedTokens ) { total += counts [ element - 1 ] ; } if ( total < minimumNumber ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , null == minimumMessage ? MSG_KEY_SUM_MIN : minimumMessage , String . valueOf ( total ) , String . valueOf ( minimumNumber ) , name ) ; } if ( total > maximumNumber ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , null == maximumMessage ? MSG_KEY_SUM_MAX : maximumMessage , String . valueOf ( total ) , String . valueOf ( maximumNumber ) , name ) ; } } private void countTokens ( AST ast , int depth ) { if ( depth <= maximumDepth ) { if ( depth >= minimumDepth ) { final int type = ast . getType ( ) ; if ( type <= counts . length ) { counts [ type - 1 ] ++ ; } } AST child = ast . getFirstChild ( ) ; final int nextDepth = depth + 1 ; while ( child != null ) { countTokens ( child , nextDepth ) ; child = child . getNextSibling ( ) ; } } } @ Override public int [ ] getAcceptableTokens ( ) { final Set < String > tokenNames = getTokenNames ( ) ; final int [ ] result = new int [ tokenNames . size ( ) ] ; int i = 0 ; for ( String name : tokenNames ) { result [ i ++ ] = Utils . getTokenId ( name ) ; } return result ; } public void setLimitedTokens ( String ... limitedTokensParam ) { limitedTokens = new int [ limitedTokensParam . length ] ; int maxToken = 0 ; for ( int i = 0 ; i < limitedTokensParam . length ; i ++ ) { limitedTokens [ i ] = Utils . getTokenId ( limitedTokensParam [ i ] ) ; if ( limitedTokens [ i ] > maxToken ) { maxToken = limitedTokens [ i ] ; } } counts = new int [ maxToken ] ; } public void setMinimumDepth ( int minimumDepth ) { this . minimumDepth = minimumDepth ; } public void setMaximumDepth ( int maximumDepth ) { this . maximumDepth = maximumDepth ; } public void setMinimumNumber ( int minimumNumber ) { this . minimumNumber = minimumNumber ; } public void setMaximumNumber ( int maximumNumber ) { this . maximumNumber = maximumNumber ; } public void setMinimumMessage ( String message ) { minimumMessage = message ; } public void setMaximumMessage ( String message ) { maximumMessage = message ; } public void setSumTokenCounts ( boolean sum ) { sumTokenCounts = sum ; } }
package com . puppycrawl . tools . checkstyle . checks ; import java . util . Set ; public class ClassResolver { private final String pkg ; private final Set < String > imports ; private final ClassLoader loader ; public ClassResolver ( ClassLoader loader , String pkg , Set < String > imports ) { this . loader = loader ; this . pkg = pkg ; this . imports = imports ; imports . add ( "java.lang.*" ) ; } public Class < ? > resolve ( String name , String currentClass ) throws ClassNotFoundException { Class < ? > clazz = resolveQualifiedName ( name ) ; if ( clazz != null ) { return clazz ; } for ( String imp : imports ) { if ( imp . endsWith ( "." + name ) ) { clazz = resolveQualifiedName ( imp ) ; if ( clazz != null ) { return clazz ; } } } if ( ! "" . equals ( pkg ) ) { clazz = resolveQualifiedName ( pkg + "." + name ) ; if ( clazz != null ) { return clazz ; } } clazz = resolveInnerClass ( name , currentClass ) ; if ( clazz != null ) { return clazz ; } clazz = resolveByStarImports ( name ) ; if ( clazz != null ) { return clazz ; } return safeLoad ( name ) ; } private Class < ? > resolveInnerClass ( String name , String currentClass ) throws ClassNotFoundException { Class < ? > clazz = null ; if ( ! "" . equals ( currentClass ) ) { final String innerClass = ( ! "" . equals ( pkg ) ? pkg + "." : "" ) + currentClass + "$" + name ; if ( isLoadable ( innerClass ) ) { clazz = safeLoad ( innerClass ) ; } } return clazz ; } private Class < ? > resolveByStarImports ( String name ) { Class < ? > clazz = null ; for ( String imp : imports ) { if ( imp . endsWith ( ".*" ) ) { final String fqn = imp . substring ( 0 , imp . lastIndexOf ( '.' ) + 1 ) + name ; clazz = resolveQualifiedName ( fqn ) ; if ( clazz != null ) { break ; } } } return clazz ; } public boolean isLoadable ( String name ) { try { safeLoad ( name ) ; return true ; } catch ( final ClassNotFoundException | NoClassDefFoundError e ) { return false ; } } public Class < ? > safeLoad ( String name ) throws ClassNotFoundException , NoClassDefFoundError { return Class . forName ( name , false , loader ) ; } private Class < ? > resolveQualifiedName ( final String name ) { try { if ( isLoadable ( name ) ) { return safeLoad ( name ) ; } final int dot = name . lastIndexOf ( '.' ) ; if ( dot != - 1 ) { final String innerName = name . substring ( 0 , dot ) + "$" + name . substring ( dot + 1 ) ; if ( isLoadable ( innerName ) ) { return safeLoad ( innerName ) ; } } } catch ( final ClassNotFoundException ex ) { throw new RuntimeException ( ex ) ; } return null ; } }
package com . puppycrawl . tools . checkstyle . checks ; import java . util . regex . Pattern ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class TodoCommentCheck extends Check { public static final String MSG_KEY = "todo.match" ; private String format = "TODO:" ; private Pattern regexp = Pattern . compile ( format ) ; @ Override public boolean isCommentNodesRequired ( ) { return true ; } public void setFormat ( String format ) { this . format = format ; regexp = Utils . createPattern ( format ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . COMMENT_CONTENT } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . COMMENT_CONTENT } ; } @ Override public void visitToken ( DetailAST ast ) { final String [ ] lines = ast . getText ( ) . split ( "\n" ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { if ( regexp . matcher ( lines [ i ] ) . find ( ) ) { log ( ast . getLineNo ( ) + i , MSG_KEY , format ) ; } } } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . api . Check ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; import org . apache . commons . beanutils . ConversionException ; public abstract class AbstractFormatCheck extends Check { private int compileFlags ; private Pattern regexp ; private String format ; public AbstractFormatCheck ( String defaultFormat ) throws ConversionException { this ( defaultFormat , 0 ) ; } public AbstractFormatCheck ( String defaultFormat , int compileFlags ) throws ConversionException { updateRegexp ( defaultFormat , compileFlags ) ; } public final void setFormat ( String format ) throws ConversionException { updateRegexp ( format , compileFlags ) ; } public final void setCompileFlags ( int compileFlags ) { updateRegexp ( format , compileFlags ) ; } public final Pattern getRegexp ( ) { return regexp ; } public final String getFormat ( ) { return format ; } private void updateRegexp ( String format , int compileFlagsParam ) { try { regexp = Pattern . compile ( format , compileFlagsParam ) ; this . format = format ; compileFlags |= compileFlagsParam ; } catch ( final PatternSyntaxException e ) { throw new ConversionException ( "unable to parse " + format , e ) ; } } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FileContents ; public class FileContentsHolder extends Check { private static final ThreadLocal < FileContents > FILE_CONTENTS = new ThreadLocal < > ( ) ; public static FileContents getContents ( ) { return FILE_CONTENTS . get ( ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ 0 ] ; } @ Override public void beginTree ( DetailAST rootAST ) { FILE_CONTENTS . set ( getFileContents ( ) ) ; } @ Override public void destroy ( ) { FILE_CONTENTS . remove ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks ; import java . util . Set ; import com . google . common . collect . ImmutableSet ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class FinalParametersCheck extends Check { public static final String MSG_KEY = "final.parameter" ; private final Set < Integer > primitiveDataTypes = ImmutableSet . of ( TokenTypes . LITERAL_BYTE , TokenTypes . LITERAL_SHORT , TokenTypes . LITERAL_INT , TokenTypes . LITERAL_LONG , TokenTypes . LITERAL_FLOAT , TokenTypes . LITERAL_DOUBLE , TokenTypes . LITERAL_BOOLEAN , TokenTypes . LITERAL_CHAR ) ; private boolean ignorePrimitiveTypes ; public void setIgnorePrimitiveTypes ( boolean ignorePrimitiveTypes ) { this . ignorePrimitiveTypes = ignorePrimitiveTypes ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . LITERAL_CATCH , TokenTypes . FOR_EACH_CLAUSE , } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST container = ast . getParent ( ) . getParent ( ) ; if ( container . getType ( ) == TokenTypes . INTERFACE_DEF ) { return ; } if ( ast . getType ( ) == TokenTypes . LITERAL_CATCH ) { visitCatch ( ast ) ; } else if ( ast . getType ( ) == TokenTypes . FOR_EACH_CLAUSE ) { visitForEachClause ( ast ) ; } else { visitMethod ( ast ) ; } } private void visitMethod ( final DetailAST method ) { if ( ! method . branchContains ( TokenTypes . PARAMETER_DEF ) ) { return ; } final DetailAST modifiers = method . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( modifiers . branchContains ( TokenTypes . ABSTRACT ) ) { return ; } final DetailAST parameters = method . findFirstToken ( TokenTypes . PARAMETERS ) ; DetailAST child = parameters . getFirstChild ( ) ; while ( child != null ) { if ( child . getType ( ) == TokenTypes . PARAMETER_DEF ) { checkParam ( child ) ; } child = child . getNextSibling ( ) ; } } private void visitCatch ( final DetailAST catchClause ) { checkParam ( catchClause . findFirstToken ( TokenTypes . PARAMETER_DEF ) ) ; } private void visitForEachClause ( final DetailAST forEachClause ) { checkParam ( forEachClause . findFirstToken ( TokenTypes . VARIABLE_DEF ) ) ; } private void checkParam ( final DetailAST param ) { if ( ! param . branchContains ( TokenTypes . FINAL ) && ! isIgnoredParam ( param ) ) { final DetailAST paramName = param . findFirstToken ( TokenTypes . IDENT ) ; final DetailAST firstNode = CheckUtils . getFirstNode ( param ) ; log ( firstNode . getLineNo ( ) , firstNode . getColumnNo ( ) , MSG_KEY , paramName . getText ( ) ) ; } } private boolean isIgnoredParam ( DetailAST paramDef ) { boolean result = false ; if ( ignorePrimitiveTypes ) { final DetailAST parameterType = paramDef . findFirstToken ( TokenTypes . TYPE ) . getFirstChild ( ) ; if ( primitiveDataTypes . contains ( parameterType . getType ( ) ) ) { result = true ; } } return result ; } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . io . File ; public class OuterTypeFilenameCheck extends Check { private boolean seenFirstToken ; private String fileName ; private boolean hasPublic ; private boolean validFirst ; private DetailAST wrongType ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , } ; } @ Override public void beginTree ( DetailAST ast ) { fileName = getFileName ( ) ; seenFirstToken = false ; validFirst = false ; hasPublic = false ; wrongType = null ; } @ Override public void visitToken ( DetailAST ast ) { final String outerTypeName = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; if ( ! seenFirstToken ) { if ( fileName . equals ( outerTypeName ) ) { validFirst = true ; } else { wrongType = ast ; } } else { final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( modifiers . findFirstToken ( TokenTypes . LITERAL_PUBLIC ) != null && ast . getParent ( ) == null ) { hasPublic = true ; } } seenFirstToken = true ; } @ Override public void finishTree ( DetailAST rootAST ) { if ( ! ( validFirst || hasPublic ) && wrongType != null ) { log ( wrongType . getLineNo ( ) , "type.file.mismatch" ) ; } } private String getFileName ( ) { String fname = getFileContents ( ) . getFileName ( ) ; fname = fname . substring ( fname . lastIndexOf ( File . separatorChar ) + 1 ) ; fname = fname . replaceAll ( "\\.[^\\.]*$" , "" ) ; return fname ; } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; import java . util . regex . Pattern ; import org . apache . commons . beanutils . ConversionException ; public class UncommentedMainCheck extends Check { public static final String MSG_KEY = "uncommented.main" ; private String excludedClasses = "^$" ; private Pattern excludedClassesPattern = Utils . createPattern ( excludedClasses ) ; private String currentClass ; private FullIdent packageName ; private int classDepth ; public void setExcludedClasses ( String excludedClasses ) throws ConversionException { this . excludedClasses = excludedClasses ; excludedClassesPattern = Utils . createPattern ( excludedClasses ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . CLASS_DEF , TokenTypes . PACKAGE_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . CLASS_DEF , TokenTypes . PACKAGE_DEF , } ; } @ Override public int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public void beginTree ( DetailAST rootAST ) { packageName = FullIdent . createFullIdent ( null ) ; currentClass = null ; classDepth = 0 ; } @ Override public void leaveToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . CLASS_DEF ) { if ( classDepth == 1 ) { currentClass = null ; } classDepth -- ; } } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . PACKAGE_DEF : visitPackageDef ( ast ) ; break ; case TokenTypes . CLASS_DEF : visitClassDef ( ast ) ; break ; case TokenTypes . METHOD_DEF : visitMethodDef ( ast ) ; break ; default : throw new IllegalStateException ( ast . toString ( ) ) ; } } private void visitPackageDef ( DetailAST packageDef ) { packageName = FullIdent . createFullIdent ( packageDef . getLastChild ( ) . getPreviousSibling ( ) ) ; } private void visitClassDef ( DetailAST classDef ) { if ( classDepth == 0 ) { final DetailAST ident = classDef . findFirstToken ( TokenTypes . IDENT ) ; currentClass = packageName . getText ( ) + "." + ident . getText ( ) ; classDepth ++ ; } } private void visitMethodDef ( DetailAST method ) { if ( classDepth != 1 ) { return ; } if ( checkClassName ( ) && checkName ( method ) && checkModifiers ( method ) && checkType ( method ) && checkParams ( method ) ) { log ( method . getLineNo ( ) , MSG_KEY ) ; } } private boolean checkClassName ( ) { return ! excludedClassesPattern . matcher ( currentClass ) . find ( ) ; } private boolean checkName ( DetailAST method ) { final DetailAST ident = method . findFirstToken ( TokenTypes . IDENT ) ; return "main" . equals ( ident . getText ( ) ) ; } private boolean checkModifiers ( DetailAST method ) { final DetailAST modifiers = method . findFirstToken ( TokenTypes . MODIFIERS ) ; return modifiers . branchContains ( TokenTypes . LITERAL_PUBLIC ) && modifiers . branchContains ( TokenTypes . LITERAL_STATIC ) ; } private boolean checkType ( DetailAST method ) { final DetailAST type = method . findFirstToken ( TokenTypes . TYPE ) . getFirstChild ( ) ; return type . getType ( ) == TokenTypes . LITERAL_VOID ; } private boolean checkParams ( DetailAST method ) { final DetailAST params = method . findFirstToken ( TokenTypes . PARAMETERS ) ; if ( params . getChildCount ( ) != 1 ) { return false ; } final DetailAST paratype = params . getFirstChild ( ) . findFirstToken ( TokenTypes . TYPE ) ; final DetailAST arrayDecl = paratype . findFirstToken ( TokenTypes . ARRAY_DECLARATOR ) ; if ( arrayDecl == null ) { return false ; } final DetailAST arrayType = arrayDecl . getFirstChild ( ) ; if ( arrayType . getType ( ) == TokenTypes . IDENT || arrayType . getType ( ) == TokenTypes . DOT ) { final FullIdent type = FullIdent . createFullIdent ( arrayType ) ; return "String" . equals ( type . getText ( ) ) || "java.lang.String" . equals ( type . getText ( ) ) ; } return false ; } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ArrayTypeStyleCheck extends Check { private boolean javaStyle = true ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . ARRAY_DECLARATOR } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . ARRAY_DECLARATOR } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST typeAST = ast . getParent ( ) ; if ( typeAST . getType ( ) != TokenTypes . TYPE ) { return ; } final DetailAST declAST = typeAST . getParent ( ) ; if ( declAST . getType ( ) == TokenTypes . METHOD_DEF ) { return ; } final DetailAST variableAST = typeAST . getNextSibling ( ) ; if ( variableAST != null ) { final boolean isJavaStyle = variableAST . getLineNo ( ) > ast . getLineNo ( ) || variableAST . getColumnNo ( ) > ast . getColumnNo ( ) ; if ( isJavaStyle != javaStyle ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , "array.type.style" ) ; } } } public void setJavaStyle ( boolean javaStyle ) { this . javaStyle = javaStyle ; } }
package com . puppycrawl . tools . checkstyle . checks ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TextBlock ; import com . puppycrawl . tools . checkstyle . Utils ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . regex . Pattern ; import org . apache . commons . beanutils . ConversionException ; public class TrailingCommentCheck extends AbstractFormatCheck { public static final String MSG_KEY = "trailing.comments" ; private static final String DEFAULT_FORMAT = "^[\\s\\}\\);]*$" ; private Pattern legalComment ; public TrailingCommentCheck ( ) throws ConversionException { super ( DEFAULT_FORMAT ) ; } public void setLegalComment ( final String format ) throws ConversionException { legalComment = Utils . createPattern ( format ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ 0 ] ; } @ Override public void visitToken ( DetailAST ast ) { throw new IllegalStateException ( "visitToken() shouldn't be called." ) ; } @ Override public void beginTree ( DetailAST rootAST ) { final Pattern blankLinePattern = getRegexp ( ) ; final Map < Integer , TextBlock > cppComments = getFileContents ( ) . getCppComments ( ) ; final Map < Integer , List < TextBlock > > cComments = getFileContents ( ) . getCComments ( ) ; final Set < Integer > lines = Sets . newHashSet ( ) ; lines . addAll ( cppComments . keySet ( ) ) ; lines . addAll ( cComments . keySet ( ) ) ; for ( Integer lineNo : lines ) { final String line = getLines ( ) [ lineNo . intValue ( ) - 1 ] ; String lineBefore = "" ; TextBlock comment = null ; if ( cppComments . containsKey ( lineNo ) ) { comment = cppComments . get ( lineNo ) ; lineBefore = line . substring ( 0 , comment . getStartColNo ( ) ) ; } else if ( cComments . containsKey ( lineNo ) ) { final List < TextBlock > commentList = cComments . get ( lineNo ) ; comment = commentList . get ( commentList . size ( ) - 1 ) ; lineBefore = line . substring ( 0 , comment . getStartColNo ( ) ) ; if ( comment . getText ( ) . length == 1 ) { final String lineAfter = line . substring ( comment . getEndColNo ( ) + 1 ) . trim ( ) ; if ( ! "" . equals ( lineAfter ) ) { continue ; } } } if ( comment != null && ! blankLinePattern . matcher ( lineBefore ) . find ( ) && ! isLegalComment ( comment ) ) { log ( lineNo . intValue ( ) , MSG_KEY ) ; } } } private boolean isLegalComment ( final TextBlock comment ) { if ( legalComment == null ) { return false ; } if ( comment . getStartLineNo ( ) != comment . getEndLineNo ( ) ) { return false ; } String commentText = comment . getText ( ) [ 0 ] ; commentText = commentText . substring ( 2 ) ; if ( commentText . endsWith ( "*/" ) ) { commentText = commentText . substring ( 0 , commentText . length ( ) - 2 ) ; } commentText = commentText . trim ( ) ; return legalComment . matcher ( commentText ) . find ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; public class ArrayTypeStyleCheckTest extends BaseCheckTestSupport { @ Test public void testJavaStyle ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ArrayTypeStyleCheck . class ) ; final String [ ] expected = { "14:23: Array brackets at illegal position." , "20:44: Array brackets at illegal position." , } ; verify ( checkConfig , getPath ( "InputArrayTypeStyle.java" ) , expected ) ; } @ Test public void testCStyle ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ArrayTypeStyleCheck . class ) ; checkConfig . addAttribute ( "javaStyle" , "false" ) ; final String [ ] expected = { "13:16: Array brackets at illegal position." , "16:39: Array brackets at illegal position." , "22:18: Array brackets at illegal position." , "30:20: Array brackets at illegal position." , } ; verify ( checkConfig , getPath ( "InputArrayTypeStyle.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . List ; public final class CheckUtils { private static final int BASE_8 = 8 ; private static final int BASE_10 = 10 ; private static final int BASE_16 = 16 ; private CheckUtils ( ) { throw new UnsupportedOperationException ( ) ; } public static boolean isEqualsMethod ( DetailAST ast ) { if ( ast . getType ( ) != TokenTypes . METHOD_DEF ) { return false ; } final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( modifiers . branchContains ( TokenTypes . LITERAL_STATIC ) || modifiers . branchContains ( TokenTypes . ABSTRACT ) ) { return false ; } final DetailAST nameNode = ast . findFirstToken ( TokenTypes . IDENT ) ; final String name = nameNode . getText ( ) ; if ( ! "equals" . equals ( name ) ) { return false ; } final DetailAST paramsNode = ast . findFirstToken ( TokenTypes . PARAMETERS ) ; return paramsNode . getChildCount ( ) == 1 ; } public static boolean isElseIf ( DetailAST ast ) { final DetailAST parentAST = ast . getParent ( ) ; return ast . getType ( ) == TokenTypes . LITERAL_IF && ( isElse ( parentAST ) || isElseWithCurlyBraces ( parentAST ) ) ; } private static boolean isElse ( DetailAST ast ) { return ast . getType ( ) == TokenTypes . LITERAL_ELSE ; } private static boolean isElseWithCurlyBraces ( DetailAST ast ) { return ast . getType ( ) == TokenTypes . SLIST && ast . getChildCount ( ) == 2 && isElse ( ast . getParent ( ) ) ; } public static FullIdent createFullType ( DetailAST typeAST ) { final DetailAST arrayDeclAST = typeAST . findFirstToken ( TokenTypes . ARRAY_DECLARATOR ) ; return createFullTypeNoArrays ( arrayDeclAST == null ? typeAST : arrayDeclAST ) ; } private static FullIdent createFullTypeNoArrays ( DetailAST typeAST ) { return FullIdent . createFullIdent ( typeAST . getFirstChild ( ) ) ; } public static double parseDouble ( String text , int type ) { String txt = text . replaceAll ( "_" , "" ) ; double result = 0 ; switch ( type ) { case TokenTypes . NUM_FLOAT : case TokenTypes . NUM_DOUBLE : result = Double . parseDouble ( txt ) ; break ; case TokenTypes . NUM_INT : case TokenTypes . NUM_LONG : int radix = BASE_10 ; if ( txt . startsWith ( "0x" ) || txt . startsWith ( "0X" ) ) { radix = BASE_16 ; txt = txt . substring ( 2 ) ; } else if ( txt . charAt ( 0 ) == '0' ) { radix = BASE_8 ; txt = txt . substring ( 1 ) ; } if ( Utils . endsWithChar ( txt , 'L' ) || Utils . endsWithChar ( txt , 'l' ) ) { txt = txt . substring ( 0 , txt . length ( ) - 1 ) ; } if ( txt . length ( ) > 0 ) { if ( type == TokenTypes . NUM_INT ) { result = parseInt ( txt , radix ) ; } else { result = parseLong ( txt , radix ) ; } } break ; default : break ; } return result ; } public static int parseInt ( String text , int radix ) { int result = 0 ; final int max = text . length ( ) ; for ( int i = 0 ; i < max ; i ++ ) { final int digit = Character . digit ( text . charAt ( i ) , radix ) ; result *= radix ; result += digit ; } return result ; } public static long parseLong ( String text , int radix ) { long result = 0 ; final int max = text . length ( ) ; for ( int i = 0 ; i < max ; i ++ ) { final int digit = Character . digit ( text . charAt ( i ) , radix ) ; result *= radix ; result += digit ; } return result ; } public static double parseFloat ( String text , int type ) { return ( float ) parseDouble ( text , type ) ; } public static DetailAST getFirstNode ( final DetailAST node ) { DetailAST currentNode = node ; DetailAST child = node . getFirstChild ( ) ; while ( child != null ) { final DetailAST newNode = getFirstNode ( child ) ; if ( newNode . getLineNo ( ) < currentNode . getLineNo ( ) || newNode . getLineNo ( ) == currentNode . getLineNo ( ) && newNode . getColumnNo ( ) < currentNode . getColumnNo ( ) ) { currentNode = newNode ; } child = child . getNextSibling ( ) ; } return currentNode ; } public static List < String > getTypeParameterNames ( final DetailAST node ) { final DetailAST typeParameters = node . findFirstToken ( TokenTypes . TYPE_PARAMETERS ) ; final List < String > typeParanames = Lists . newArrayList ( ) ; if ( typeParameters != null ) { final DetailAST typeParam = typeParameters . findFirstToken ( TokenTypes . TYPE_PARAMETER ) ; typeParanames . add ( typeParam . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ) ; DetailAST sibling = typeParam . getNextSibling ( ) ; while ( sibling != null ) { if ( sibling . getType ( ) == TokenTypes . TYPE_PARAMETER ) { typeParanames . add ( sibling . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ) ; } sibling = sibling . getNextSibling ( ) ; } } return typeParanames ; } public static List < DetailAST > getTypeParameters ( final DetailAST node ) { final DetailAST typeParameters = node . findFirstToken ( TokenTypes . TYPE_PARAMETERS ) ; final List < DetailAST > typeParams = Lists . newArrayList ( ) ; if ( typeParameters != null ) { final DetailAST typeParam = typeParameters . findFirstToken ( TokenTypes . TYPE_PARAMETER ) ; typeParams . add ( typeParam ) ; DetailAST sibling = typeParam . getNextSibling ( ) ; while ( sibling != null ) { if ( sibling . getType ( ) == TokenTypes . TYPE_PARAMETER ) { typeParams . add ( sibling ) ; } sibling = sibling . getNextSibling ( ) ; } } return typeParams ; } }
package com . puppycrawl . tools . checkstyle . checks ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . List ; import java . util . Properties ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import com . google . common . collect . HashMultiset ; import com . google . common . collect . Multiset ; import com . google . common . collect . Multiset . Entry ; import com . puppycrawl . tools . checkstyle . api . AbstractFileSetCheck ; public class UniquePropertiesCheck extends AbstractFileSetCheck { public static final String MSG_KEY = "properties.duplicateproperty" ; public static final String IO_EXCEPTION_KEY = "unable.open.cause" ; public UniquePropertiesCheck ( ) { super . setFileExtensions ( "properties" ) ; } @ Override protected void processFiltered ( File file , List < String > lines ) { final UniqueProperties properties = new UniqueProperties ( ) ; try { final FileInputStream fileInputStream = new FileInputStream ( file ) ; try { properties . load ( fileInputStream ) ; } finally { fileInputStream . close ( ) ; } } catch ( IOException e ) { log ( 0 , IO_EXCEPTION_KEY , file . getPath ( ) , e . getLocalizedMessage ( ) ) ; } for ( Entry < String > duplication : properties . getDuplicatedStrings ( ) . entrySet ( ) ) { final String keyName = duplication . getElement ( ) ; final int lineNumber = getLineNumber ( lines , keyName ) ; log ( lineNumber , MSG_KEY , keyName , duplication . getCount ( ) + 1 ) ; } } protected int getLineNumber ( List < String > lines , String keyName ) { final String keyPatternString = "^" + keyName . replace ( " " , "\\\\ " ) + "[\\s:=].*$" ; final Pattern keyPattern = Pattern . compile ( keyPatternString ) ; int lineNumber = 1 ; final Matcher matcher = keyPattern . matcher ( "" ) ; for ( String line : lines ) { matcher . reset ( line ) ; if ( matcher . matches ( ) ) { break ; } ++ lineNumber ; } if ( lineNumber > lines . size ( ) ) { lineNumber = 0 ; } return lineNumber ; } private static class UniqueProperties extends Properties { private static final long serialVersionUID = 1L ; private final Multiset < String > duplicatedStrings = HashMultiset . create ( ) ; @ Override public Object put ( Object key , Object value ) { synchronized ( this ) { final Object oldValue = super . put ( key , value ) ; if ( oldValue != null && key instanceof String ) { final String keyString = ( String ) key ; duplicatedStrings . add ( keyString ) ; } return oldValue ; } } public Multiset < String > getDuplicatedStrings ( ) { return duplicatedStrings ; } } }
package com . puppycrawl . tools . checkstyle . checks ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class UpperEllCheck extends Check { public static final String MSG_KEY = "upperEll" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . NUM_LONG } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . NUM_LONG } ; } @ Override public void visitToken ( DetailAST ast ) { if ( Utils . endsWithChar ( ast . getText ( ) , 'l' ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) + ast . getText ( ) . length ( ) - 1 , MSG_KEY ) ; } } }
package com . puppycrawl . tools . checkstyle . checks ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . apache . commons . beanutils . ConversionException ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Locale ; import java . util . Map ; public class SuppressWarningsHolder extends Check { public static final String MSG_KEY = "suppress.warnings.invalid.target" ; public static final String CHECKSTYLE_PREFIX = "checkstyle:" ; private static final String JAVA_LANG_PREFIX = "java.lang." ; private static final String CHECK_SUFFIX = "Check" ; private static final Map < String , String > CHECK_ALIAS_MAP = new HashMap < > ( ) ; private static final ThreadLocal < List < Entry > > ENTRIES = new ThreadLocal < > ( ) ; private static class Entry { private final String checkName ; private final int firstLine ; private final int firstColumn ; private final int lastLine ; private final int lastColumn ; public Entry ( String checkName , int firstLine , int firstColumn , int lastLine , int lastColumn ) { this . checkName = checkName ; this . firstLine = firstLine ; this . firstColumn = firstColumn ; this . lastLine = lastLine ; this . lastColumn = lastColumn ; } public String getCheckName ( ) { return checkName ; } public int getFirstLine ( ) { return firstLine ; } public int getFirstColumn ( ) { return firstColumn ; } public int getLastLine ( ) { return lastLine ; } public int getLastColumn ( ) { return lastColumn ; } } public static String getDefaultAlias ( String sourceName ) { final int startIndex = sourceName . lastIndexOf ( '.' ) + 1 ; int endIndex = sourceName . length ( ) ; if ( sourceName . endsWith ( CHECK_SUFFIX ) ) { endIndex -= CHECK_SUFFIX . length ( ) ; } return sourceName . substring ( startIndex , endIndex ) . toLowerCase ( Locale . ENGLISH ) ; } public static String getAlias ( String sourceName ) { String checkAlias = CHECK_ALIAS_MAP . get ( sourceName ) ; if ( checkAlias == null ) { checkAlias = getDefaultAlias ( sourceName ) ; } return checkAlias ; } public static void registerAlias ( String sourceName , String checkAlias ) { CHECK_ALIAS_MAP . put ( sourceName , checkAlias ) ; } public void setAliasList ( String aliasList ) { for ( String sourceAlias : aliasList . split ( "," ) ) { final int index = sourceAlias . indexOf ( '=' ) ; if ( index > 0 ) { registerAlias ( sourceAlias . substring ( 0 , index ) , sourceAlias . substring ( index + 1 ) ) ; } else if ( sourceAlias . length ( ) > 0 ) { throw new ConversionException ( "'=' expected in alias list item: " + sourceAlias ) ; } } } public static boolean isSuppressed ( String sourceName , int line , int column ) { final List < Entry > entries = ENTRIES . get ( ) ; final String checkAlias = getAlias ( sourceName ) ; for ( Entry entry : entries ) { final boolean afterStart = entry . getFirstLine ( ) < line || entry . getFirstLine ( ) == line && entry . getFirstColumn ( ) <= column ; final boolean beforeEnd = entry . getLastLine ( ) > line || entry . getLastLine ( ) == line && entry . getLastColumn ( ) >= column ; final boolean nameMatches = entry . getCheckName ( ) . equals ( checkAlias ) ; if ( afterStart && beforeEnd && nameMatches ) { return true ; } } return false ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . ANNOTATION } ; } @ Override public void beginTree ( DetailAST rootAST ) { ENTRIES . set ( new LinkedList < Entry > ( ) ) ; } @ Override public void visitToken ( DetailAST ast ) { String identifier = getIdentifier ( getNthChild ( ast , 1 ) ) ; if ( identifier . startsWith ( JAVA_LANG_PREFIX ) ) { identifier = identifier . substring ( JAVA_LANG_PREFIX . length ( ) ) ; } if ( "SuppressWarnings" . equals ( identifier ) ) { final List < String > values = getAllAnnotationValues ( ast ) ; if ( isAnnotationEmpty ( values ) ) { return ; } final DetailAST targetAST = getAnnotationTarget ( ast ) ; if ( targetAST == null ) { log ( ast . getLineNo ( ) , MSG_KEY ) ; return ; } final int firstLine = targetAST . getLineNo ( ) ; final int firstColumn = targetAST . getColumnNo ( ) ; final DetailAST nextAST = targetAST . getNextSibling ( ) ; final int lastLine ; final int lastColumn ; if ( nextAST != null ) { lastLine = nextAST . getLineNo ( ) ; lastColumn = nextAST . getColumnNo ( ) - 1 ; } else { lastLine = Integer . MAX_VALUE ; lastColumn = Integer . MAX_VALUE ; } final List < Entry > entries = ENTRIES . get ( ) ; if ( entries != null ) { for ( String value : values ) { if ( value . startsWith ( CHECKSTYLE_PREFIX ) ) { value = value . substring ( CHECKSTYLE_PREFIX . length ( ) ) ; } entries . add ( new Entry ( value , firstLine , firstColumn , lastLine , lastColumn ) ) ; } } } } private List < String > getAllAnnotationValues ( DetailAST ast ) { List < String > values = null ; final DetailAST lparenAST = ast . findFirstToken ( TokenTypes . LPAREN ) ; if ( lparenAST != null ) { final DetailAST nextAST = lparenAST . getNextSibling ( ) ; if ( nextAST != null ) { final int nextType = nextAST . getType ( ) ; switch ( nextType ) { case TokenTypes . EXPR : case TokenTypes . ANNOTATION_ARRAY_INIT : values = getAnnotationValues ( nextAST ) ; break ; case TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR : values = getAnnotationValues ( getNthChild ( nextAST , 2 ) ) ; break ; case TokenTypes . RPAREN : break ; default : } } } return values ; } private boolean isAnnotationEmpty ( List < String > values ) { return values == null ; } private DetailAST getAnnotationTarget ( DetailAST ast ) { DetailAST targetAST = null ; DetailAST parentAST = ast . getParent ( ) ; if ( parentAST != null ) { switch ( parentAST . getType ( ) ) { case TokenTypes . MODIFIERS : case TokenTypes . ANNOTATIONS : parentAST = parentAST . getParent ( ) ; if ( parentAST != null ) { switch ( parentAST . getType ( ) ) { case TokenTypes . ANNOTATION_DEF : case TokenTypes . PACKAGE_DEF : case TokenTypes . CLASS_DEF : case TokenTypes . INTERFACE_DEF : case TokenTypes . ENUM_DEF : case TokenTypes . ENUM_CONSTANT_DEF : case TokenTypes . CTOR_DEF : case TokenTypes . METHOD_DEF : case TokenTypes . PARAMETER_DEF : case TokenTypes . VARIABLE_DEF : case TokenTypes . ANNOTATION_FIELD_DEF : case TokenTypes . TYPE : case TokenTypes . LITERAL_NEW : case TokenTypes . LITERAL_THROWS : case TokenTypes . TYPE_ARGUMENT : case TokenTypes . IMPLEMENTS_CLAUSE : case TokenTypes . DOT : targetAST = parentAST ; break ; default : } } break ; default : } } return targetAST ; } private static DetailAST getNthChild ( DetailAST ast , int index ) { DetailAST child = ast . getFirstChild ( ) ; if ( child != null ) { for ( int i = 0 ; i < index && child != null ; ++ i ) { child = child . getNextSibling ( ) ; } } return child ; } private static String getIdentifier ( DetailAST ast ) { if ( ast != null ) { if ( ast . getType ( ) == TokenTypes . IDENT ) { return ast . getText ( ) ; } else if ( ast . getType ( ) == TokenTypes . DOT ) { return getIdentifier ( ast . getFirstChild ( ) ) + "." + getIdentifier ( ast . getLastChild ( ) ) ; } } throw new IllegalArgumentException ( "Identifier AST expected: " + ast ) ; } private static String getStringExpr ( DetailAST ast ) { if ( ast != null && ast . getType ( ) == TokenTypes . EXPR ) { final DetailAST firstChild = ast . getFirstChild ( ) ; switch ( firstChild . getType ( ) ) { case TokenTypes . STRING_LITERAL : final String quotedText = firstChild . getText ( ) ; return quotedText . substring ( 1 , quotedText . length ( ) - 1 ) ; case TokenTypes . IDENT : return firstChild . getText ( ) ; case TokenTypes . DOT : return firstChild . getLastChild ( ) . getText ( ) ; default : return "" ; } } throw new IllegalArgumentException ( "Expression AST expected: " + ast ) ; } private static List < String > getAnnotationValues ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . EXPR : return ImmutableList . of ( getStringExpr ( ast ) ) ; case TokenTypes . ANNOTATION_ARRAY_INIT : final List < String > valueList = Lists . newLinkedList ( ) ; DetailAST childAST = ast . getFirstChild ( ) ; while ( childAST != null ) { if ( childAST . getType ( ) == TokenTypes . EXPR ) { valueList . add ( getStringExpr ( childAST ) ) ; } childAST = childAST . getNextSibling ( ) ; } return valueList ; default : } throw new IllegalArgumentException ( "Expression or annotation array initializer AST expected: " + ast ) ; } }
package com . puppycrawl . tools . checkstyle . checks ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . Deque ; import java . util . Map ; import java . util . Queue ; import java . util . Set ; public abstract class AbstractDeclarationCollector extends Check { private Map < DetailAST , LexicalFrame > frames ; private LexicalFrame current ; @ Override public void beginTree ( DetailAST rootAST ) { final Deque < LexicalFrame > frameStack = Lists . newLinkedList ( ) ; frameStack . add ( new GlobalFrame ( ) ) ; frames = Maps . newHashMap ( ) ; DetailAST curNode = rootAST ; while ( curNode != null ) { collectDeclarations ( frameStack , curNode ) ; DetailAST toVisit = curNode . getFirstChild ( ) ; while ( curNode != null && toVisit == null ) { endCollectingDeclarations ( frameStack , curNode ) ; toVisit = curNode . getNextSibling ( ) ; if ( toVisit == null ) { curNode = curNode . getParent ( ) ; } } curNode = toVisit ; } } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CLASS_DEF : case TokenTypes . INTERFACE_DEF : case TokenTypes . ENUM_DEF : case TokenTypes . ANNOTATION_DEF : case TokenTypes . SLIST : case TokenTypes . METHOD_DEF : case TokenTypes . CTOR_DEF : this . current = this . frames . get ( ast ) ; break ; default : } } private void collectDeclarations ( Deque < LexicalFrame > frameStack , DetailAST ast ) { final LexicalFrame frame = frameStack . peek ( ) ; switch ( ast . getType ( ) ) { case TokenTypes . VARIABLE_DEF : { collectVariableDeclarations ( ast , frame ) ; break ; } case TokenTypes . PARAMETER_DEF : { final DetailAST nameAST = ast . findFirstToken ( TokenTypes . IDENT ) ; frame . addName ( nameAST . getText ( ) ) ; break ; } case TokenTypes . CLASS_DEF : case TokenTypes . INTERFACE_DEF : case TokenTypes . ENUM_DEF : case TokenTypes . ANNOTATION_DEF : { final DetailAST nameAST = ast . findFirstToken ( TokenTypes . IDENT ) ; frame . addName ( nameAST . getText ( ) ) ; frameStack . addFirst ( new ClassFrame ( frame ) ) ; break ; } case TokenTypes . SLIST : frameStack . addFirst ( new BlockFrame ( frame ) ) ; break ; case TokenTypes . METHOD_DEF : final String name = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; if ( frame instanceof ClassFrame ) { final DetailAST mods = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( mods . branchContains ( TokenTypes . LITERAL_STATIC ) ) { ( ( ClassFrame ) frame ) . addStaticMethod ( name ) ; } else { ( ( ClassFrame ) frame ) . addInstanceMethod ( name ) ; } } frameStack . addFirst ( new MethodFrame ( frame ) ) ; break ; case TokenTypes . CTOR_DEF : frameStack . addFirst ( new MethodFrame ( frame ) ) ; break ; default : } } private void collectVariableDeclarations ( DetailAST ast , LexicalFrame frame ) { final String name = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; if ( frame instanceof ClassFrame ) { final DetailAST mods = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( ScopeUtils . inInterfaceBlock ( ast ) || mods . branchContains ( TokenTypes . LITERAL_STATIC ) ) { ( ( ClassFrame ) frame ) . addStaticMember ( name ) ; } else { ( ( ClassFrame ) frame ) . addInstanceMember ( name ) ; } } else { frame . addName ( name ) ; } } private void endCollectingDeclarations ( Queue < LexicalFrame > frameStack , DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CLASS_DEF : case TokenTypes . INTERFACE_DEF : case TokenTypes . ENUM_DEF : case TokenTypes . ANNOTATION_DEF : case TokenTypes . SLIST : case TokenTypes . METHOD_DEF : case TokenTypes . CTOR_DEF : this . frames . put ( ast , frameStack . poll ( ) ) ; break ; default : } } protected final boolean isClassField ( String name ) { final LexicalFrame frame = findFrame ( name ) ; return frame instanceof ClassFrame && ( ( ClassFrame ) frame ) . hasInstanceMember ( name ) ; } protected final boolean isClassMethod ( String name ) { final LexicalFrame frame = findFrame ( name ) ; return frame instanceof ClassFrame && ( ( ClassFrame ) frame ) . hasInstanceMethod ( name ) ; } private LexicalFrame findFrame ( String name ) { if ( current != null ) { return current . getIfContains ( name ) ; } else { return null ; } } private static class LexicalFrame { private final Set < String > varNames ; private final LexicalFrame parent ; protected LexicalFrame ( LexicalFrame parent ) { this . parent = parent ; varNames = Sets . newHashSet ( ) ; } void addName ( String nameToAdd ) { varNames . add ( nameToAdd ) ; } boolean contains ( String nameToFind ) { return varNames . contains ( nameToFind ) ; } LexicalFrame getIfContains ( String nameToFind ) { if ( contains ( nameToFind ) ) { return this ; } else if ( parent != null ) { return parent . getIfContains ( nameToFind ) ; } else { return null ; } } } private static class GlobalFrame extends LexicalFrame { protected GlobalFrame ( ) { super ( null ) ; } } private static class MethodFrame extends LexicalFrame { protected MethodFrame ( LexicalFrame parent ) { super ( parent ) ; } } private static class ClassFrame extends LexicalFrame { private final Set < String > instanceMembers ; private final Set < String > instanceMethods ; private final Set < String > staticMembers ; private final Set < String > staticMethods ; public ClassFrame ( LexicalFrame parent ) { super ( parent ) ; instanceMembers = Sets . newHashSet ( ) ; instanceMethods = Sets . newHashSet ( ) ; staticMembers = Sets . newHashSet ( ) ; staticMethods = Sets . newHashSet ( ) ; } public void addStaticMember ( final String name ) { staticMembers . add ( name ) ; } public void addStaticMethod ( final String name ) { staticMethods . add ( name ) ; } public void addInstanceMember ( final String name ) { instanceMembers . add ( name ) ; } public void addInstanceMethod ( final String name ) { instanceMethods . add ( name ) ; } public boolean hasInstanceMember ( final String name ) { return instanceMembers . contains ( name ) ; } public boolean hasInstanceMethod ( final String name ) { return instanceMethods . contains ( name ) ; } @ Override boolean contains ( String nameToFind ) { return super . contains ( nameToFind ) || instanceMembers . contains ( nameToFind ) || instanceMethods . contains ( nameToFind ) || staticMembers . contains ( nameToFind ) || staticMethods . contains ( nameToFind ) ; } } private static class BlockFrame extends LexicalFrame { protected BlockFrame ( LexicalFrame parent ) { super ( parent ) ; } } }
package com . puppycrawl . tools . checkstyle . checks ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class AvoidEscapedUnicodeCharactersCheck extends Check { private static Pattern sUnicodeRegexp = Pattern . compile ( "\\\\u[a-fA-F0-9]{4}" ) ; private static Pattern sUnicodeControl = Pattern . compile ( "\\\\(u|U)" + "(00[0-1][0-1A-Fa-f]|00[8-9][0-9A-Fa-f]|034(f|F)|070(f|F)" + "|180(e|E)|200[b-fB-F]|202[b-eB-E]|206[0-4a-fA-F]" + "|[fF]{3}[9a-bA-B]|[fF][eE][fF]{2})" ) ; private static Pattern sCommentRegexp = Pattern . compile ( ";[ ]*//+" + "[a-zA-Z0-9 ]*|;[ ]*/[*]{1}+[a-zA-Z0-9 ]*" ) ; private static Pattern sAllEscapedChars = Pattern . compile ( "^((\\\\u)[a-fA-F0-9]{4}" + "||\\\\b|\\\\t|\\\\n|\\\\f|\\\\r|\\\\|\\\"|\\\')+$" ) ; private static Pattern sNonPrintableChars = Pattern . compile ( "\\\\u1680|\\\\u2028" + "|\\\\u2029|\\\\u205(f|F)|\\\\u3000|\\\\u2007|\\\\u2000|\\\\u200(a|A)" + "|\\\\u007(F|f)|\\\\u009(f|F)|\\\\u(f|F){4}|\\\\u007(F|f)|\\\\u00(a|A)(d|D)" + "|\\\\u0600|\\\\u061(c|C)|\\\\u06(d|D){2}|\\\\u070(f|F)|\\\\u1680|\\\\u180(e|E)" + "|\\\\u2000|\\\\u2028|\\\\u205(f|F)|\\\\u2066|\\\\u2067|\\\\u2068|\\\\u2069" + "|\\\\u206(a|A)|\\\\u(d|D)800|\\\\u(f|F)(e|E)(f|F){2}|\\\\u(f|F){3}9" + "|\\\\u(f|F){3}(a|A)|\\\\u0020|\\\\u00(a|A)0|\\\\u00(a|A)(d|D)|\\\\u0604" + "|\\\\u061(c|C)|\\\\u06(d|D){2}|\\\\u070(f|F)|\\\\u1680|\\\\u180(e|E)|\\\\u200(f|F)" + "|\\\\u202(f|F)|\\\\u2064|\\\\u2066|\\\\u2067|\\\\u2068|\\\\u2069|\\\\u206(f|F)" + "|\\\\u(f|F)8(f|F){2}|\\\\u(f|F)(e|E)(f|F){2}|\\\\u(f|F){3}9|\\\\u(f|F){3}(b|B)" + "|\\\\u05(d|D)0|\\\\u05(f|F)3|\\\\u0600|\\\\u0750|\\\\u0(e|E)00|\\\\u1(e|E)00" + "|\\\\u2100|\\\\u(f|F)(b|B)50|\\\\u(f|F)(e|E)70|\\\\u(F|f){2}61|\\\\u04(f|F)9" + "|\\\\u05(b|B)(e|E)|\\\\u05(e|E)(a|A)|\\\\u05(f|F)4|\\\\u06(f|F){2}" + "|\\\\u077(f|F)|\\\\u0(e|E)7(f|F)|\\\\u20(a|A)(f|F)|\\\\u213(a|A)|\\\\u0000" + "|\\\\u(f|F)(d|D)(f|F){2}|\\\\u(f|F)(e|E)(f|F){2}|\\\\u(f|F){2}(d|D)(c|C)" + "|\\\\u2002|\\\\u0085|\\\\u200(a|A)|\\\\u2005|\\\\u2000|\\\\u2029|\\\\u000(B|b)" + "|\\\\u2008|\\\\u2003|\\\\u205(f|F)|\\\\u1680|\\\\u0009|\\\\u0020|\\\\u2006" + "|\\\\u2001|\\\\u202(f|F)|\\\\u00(a|A)0|\\\\u000(c|C)|\\\\u2009|\\\\u2004|\\\\u2028" + "|\\\\u2028|\\\\u2007|\\\\u2004|\\\\u2028|\\\\u2007|\\\\u2025" + "|\\\\u(f|F){2}0(e|E)|\\\\u(f|F){2}61" ) ; private boolean allowEscapesForControlCharacters ; private boolean allowByTailComment ; private boolean allowIfAllCharactersEscaped ; private boolean allowNonPrintableEscapes ; public final void setAllowEscapesForControlCharacters ( boolean allow ) { allowEscapesForControlCharacters = allow ; } public final void setAllowByTailComment ( boolean allow ) { allowByTailComment = allow ; } public final void setAllowIfAllCharactersEscaped ( boolean allow ) { allowIfAllCharactersEscaped = allow ; } public final void setAllowNonPrintableEscapes ( boolean allow ) { allowNonPrintableEscapes = allow ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . STRING_LITERAL , TokenTypes . CHAR_LITERAL } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . STRING_LITERAL , TokenTypes . CHAR_LITERAL } ; } @ Override public void visitToken ( DetailAST ast ) { final String literal = ast . getText ( ) ; if ( hasUnicodeChar ( literal ) && ! ( allowByTailComment && hasTrailComment ( ast ) || isAllCharactersEscaped ( literal ) || allowEscapesForControlCharacters && isOnlyUnicodeValidChars ( literal , sUnicodeControl ) || allowNonPrintableEscapes && isOnlyUnicodeValidChars ( literal , sNonPrintableChars ) ) ) { log ( ast . getLineNo ( ) , "forbid.escaped.unicode.char" ) ; } } private boolean hasUnicodeChar ( String literal ) { return sUnicodeRegexp . matcher ( literal ) . find ( ) ; } private boolean isOnlyUnicodeValidChars ( String literal , Pattern pattern ) { final int unicodeMatchesCounter = countMatches ( sUnicodeRegexp , literal ) ; final int unicodeValidMatchesCouter = countMatches ( pattern , literal ) ; return unicodeMatchesCounter - unicodeValidMatchesCouter == 0 ; } private boolean hasTrailComment ( DetailAST ast ) { boolean result = false ; final DetailAST variableDef = getVariableDef ( ast ) ; DetailAST semi ; if ( variableDef != null ) { semi = variableDef . getNextSibling ( ) ; if ( semi . getType ( ) != TokenTypes . SEMI ) { semi = variableDef . getLastChild ( ) ; } } else { semi = getSemi ( ast ) ; } if ( semi != null ) { final int lineNo = semi . getLineNo ( ) ; final String currentLine = getLine ( lineNo - 1 ) ; if ( currentLine != null && sCommentRegexp . matcher ( currentLine ) . find ( ) ) { result = true ; } } return result ; } private int countMatches ( Pattern pattern , String target ) { int matcherCounter = 0 ; final Matcher matcher = pattern . matcher ( target ) ; while ( matcher . find ( ) ) { matcherCounter ++ ; } return matcherCounter ; } private DetailAST getVariableDef ( DetailAST ast ) { DetailAST result = ast . getParent ( ) ; while ( result != null && result . getType ( ) != TokenTypes . VARIABLE_DEF ) { result = result . getParent ( ) ; } return result ; } private DetailAST getSemi ( DetailAST ast ) { DetailAST result = ast . getParent ( ) ; while ( result != null && result . getLastChild ( ) . getType ( ) != TokenTypes . SEMI ) { result = result . getParent ( ) ; } if ( result != null ) { result = result . getLastChild ( ) ; } return result ; } private boolean isAllCharactersEscaped ( String literal ) { return allowIfAllCharactersEscaped && sAllEscapedChars . matcher ( literal . substring ( 1 , literal . length ( ) - 1 ) ) . find ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class NoLineWrapCheck extends Check { public static final String MSG_KEY = "no.line.wrap" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF , TokenTypes . IMPORT } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . PACKAGE_DEF , TokenTypes . CLASS_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . ENUM_DEF , TokenTypes . INTERFACE_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( ast . getLineNo ( ) != ast . getLastChild ( ) . getLineNo ( ) ) { log ( ast . getLineNo ( ) , MSG_KEY , ast . getText ( ) ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ;
package com . puppycrawl . tools . checkstyle . checks . whitespace ; public enum WrapOption { NL , EOL }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class NoWhitespaceAfterCheck extends Check { public static final String MSG_KEY = "ws.followed" ; private boolean allowLineBreaks = true ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . ARRAY_INIT , TokenTypes . INC , TokenTypes . DEC , TokenTypes . UNARY_MINUS , TokenTypes . UNARY_PLUS , TokenTypes . BNOT , TokenTypes . LNOT , TokenTypes . DOT , TokenTypes . ARRAY_DECLARATOR , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . ARRAY_INIT , TokenTypes . INC , TokenTypes . DEC , TokenTypes . UNARY_MINUS , TokenTypes . UNARY_PLUS , TokenTypes . BNOT , TokenTypes . LNOT , TokenTypes . DOT , TokenTypes . TYPECAST , TokenTypes . ARRAY_DECLARATOR , } ; } @ Override public void visitToken ( DetailAST ast ) { DetailAST astNode = ast ; if ( ast . getType ( ) == TokenTypes . ARRAY_DECLARATOR || ast . getType ( ) == TokenTypes . TYPECAST ) { astNode = getPreceded ( ast ) ; } final String line = getLine ( ast . getLineNo ( ) - 1 ) ; final int after = getPositionAfter ( astNode ) ; if ( ( after >= line . length ( ) || Character . isWhitespace ( line . charAt ( after ) ) ) && hasRedundantWhitespace ( line , after ) ) { log ( astNode . getLineNo ( ) , after , MSG_KEY , astNode . getText ( ) ) ; } } private static DetailAST getPreceded ( DetailAST arrayOrTypeCast ) { DetailAST preceded = arrayOrTypeCast ; switch ( arrayOrTypeCast . getType ( ) ) { case TokenTypes . TYPECAST : preceded = arrayOrTypeCast . findFirstToken ( TokenTypes . RPAREN ) ; break ; case TokenTypes . ARRAY_DECLARATOR : preceded = getArrayTypeOrIdentifier ( arrayOrTypeCast ) ; break ; default : throw new IllegalStateException ( arrayOrTypeCast . toString ( ) ) ; } return preceded ; } private static int getPositionAfter ( DetailAST ast ) { int after ; if ( ast . getType ( ) == TokenTypes . IDENT && ast . getNextSibling ( ) != null && ast . getNextSibling ( ) . getType ( ) == TokenTypes . LPAREN ) { final DetailAST methodDef = ast . getParent ( ) ; final DetailAST endOfParams = methodDef . findFirstToken ( TokenTypes . RPAREN ) ; after = endOfParams . getColumnNo ( ) + 1 ; } else { after = ast . getColumnNo ( ) + ast . getText ( ) . length ( ) ; } return after ; } private static DetailAST getArrayTypeOrIdentifier ( DetailAST arrayDeclarator ) { DetailAST typeOrIdent = arrayDeclarator ; if ( isArrayInstantiation ( arrayDeclarator ) ) { typeOrIdent = arrayDeclarator . getParent ( ) . getFirstChild ( ) ; } else if ( isMultiDimensionalArray ( arrayDeclarator ) ) { if ( isCstyleMultiDimensionalArrayDeclaration ( arrayDeclarator ) ) { if ( arrayDeclarator . getParent ( ) . getType ( ) != TokenTypes . ARRAY_DECLARATOR ) { typeOrIdent = getArrayIdentifier ( arrayDeclarator ) ; } } else { DetailAST arrayIdentifier = arrayDeclarator . getFirstChild ( ) ; while ( arrayIdentifier != null ) { typeOrIdent = arrayIdentifier ; arrayIdentifier = arrayIdentifier . getFirstChild ( ) ; } } } else { if ( isCstyleArrayDeclaration ( arrayDeclarator ) ) { typeOrIdent = getArrayIdentifier ( arrayDeclarator ) ; } else { if ( isArrayUsedAsTypeForGenericBoundedWildcard ( arrayDeclarator ) ) { typeOrIdent = arrayDeclarator . getParent ( ) ; } else { typeOrIdent = arrayDeclarator . getFirstChild ( ) ; } } } return typeOrIdent ; } private static DetailAST getArrayIdentifier ( DetailAST arrayDeclarator ) { return arrayDeclarator . getParent ( ) . getNextSibling ( ) ; } private static boolean isMultiDimensionalArray ( DetailAST arrayDeclaration ) { return arrayDeclaration . getParent ( ) . getType ( ) == TokenTypes . ARRAY_DECLARATOR || arrayDeclaration . getFirstChild ( ) . getType ( ) == TokenTypes . ARRAY_DECLARATOR ; } private static boolean isArrayInstantiation ( DetailAST arrayDeclaration ) { return arrayDeclaration . getParent ( ) . getType ( ) == TokenTypes . LITERAL_NEW ; } private static boolean isArrayUsedAsTypeForGenericBoundedWildcard ( DetailAST arrayDeclarator ) { final int firstChildType = arrayDeclarator . getFirstChild ( ) . getType ( ) ; return firstChildType == TokenTypes . TYPE_UPPER_BOUNDS || firstChildType == TokenTypes . TYPE_LOWER_BOUNDS ; } public void setAllowLineBreaks ( boolean allowLineBreaks ) { this . allowLineBreaks = allowLineBreaks ; } private static boolean isCstyleArrayDeclaration ( DetailAST arrayDeclaration ) { boolean result = false ; final DetailAST identifier = getArrayIdentifier ( arrayDeclaration ) ; if ( identifier != null ) { final int arrayDeclarationStart = arrayDeclaration . getColumnNo ( ) ; final int identifierEnd = identifier . getColumnNo ( ) + identifier . getText ( ) . length ( ) ; result = arrayDeclarationStart == identifierEnd || arrayDeclarationStart > identifierEnd ; } return result ; } private static boolean isCstyleMultiDimensionalArrayDeclaration ( DetailAST arrayDeclaration ) { boolean result = false ; DetailAST parentArrayDeclaration = arrayDeclaration ; while ( parentArrayDeclaration != null ) { if ( parentArrayDeclaration . getParent ( ) != null && parentArrayDeclaration . getParent ( ) . getType ( ) == TokenTypes . TYPE ) { result = isCstyleArrayDeclaration ( parentArrayDeclaration ) ; } parentArrayDeclaration = parentArrayDeclaration . getParent ( ) ; } return result ; } private boolean hasRedundantWhitespace ( String line , int after ) { boolean result = ! allowLineBreaks ; for ( int i = after + 1 ; ! result && i < line . length ( ) ; i ++ ) { if ( ! Character . isWhitespace ( line . charAt ( i ) ) ) { result = true ; } } return result ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . NoWhitespaceBeforeCheck . MSG_KEY ; public class NoWhitespaceBeforeCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( NoWhitespaceBeforeCheck . class ) ; } @ Test public void testDefault ( ) throws Exception { final String [ ] expected = { "30:14: " + getCheckMessage ( MSG_KEY , "++" ) , "30:21: " + getCheckMessage ( MSG_KEY , "--" ) , "176:18: " + getCheckMessage ( MSG_KEY , ";" ) , "178:23: " + getCheckMessage ( MSG_KEY , ";" ) , "185:18: " + getCheckMessage ( MSG_KEY , ";" ) , "187:27: " + getCheckMessage ( MSG_KEY , ";" ) , "195:26: " + getCheckMessage ( MSG_KEY , ";" ) , "211:15: " + getCheckMessage ( MSG_KEY , ";" ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void testDot ( ) throws Exception { checkConfig . addAttribute ( "tokens" , "DOT" ) ; final String [ ] expected = { "5:12: " + getCheckMessage ( MSG_KEY , "." ) , "6:4: " + getCheckMessage ( MSG_KEY , "." ) , "129:17: " + getCheckMessage ( MSG_KEY , "." ) , "135:12: " + getCheckMessage ( MSG_KEY , "." ) , "136:10: " + getCheckMessage ( MSG_KEY , "." ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void testDotAllowLineBreaks ( ) throws Exception { checkConfig . addAttribute ( "tokens" , "DOT" ) ; checkConfig . addAttribute ( "allowLineBreaks" , "yes" ) ; final String [ ] expected = { "5:12: " + getCheckMessage ( MSG_KEY , "." ) , "129:17: " + getCheckMessage ( MSG_KEY , "." ) , "136:10: " + getCheckMessage ( MSG_KEY , "." ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class TypecastParenPadCheck extends AbstractParenPadCheck { @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . RPAREN , TokenTypes . TYPECAST } ; } @ Override public int [ ] getDefaultTokens ( ) { return getRequiredTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . RPAREN , TokenTypes . TYPECAST } ; } @ Override public void visitToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . TYPECAST ) { processLeft ( ast ) ; } else if ( ast . getParent ( ) != null && ast . getParent ( ) . getType ( ) == TokenTypes . TYPECAST && ast . getParent ( ) . findFirstToken ( TokenTypes . RPAREN ) == ast ) { processRight ( ast ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class WhitespaceAroundCheck extends Check { public static final String WS_NOT_PRECEDED = "ws.notPreceded" ; public static final String WS_NOT_FOLLOWED = "ws.notFollowed" ; private boolean allowEmptyCtors ; private boolean allowEmptyMethods ; private boolean allowEmptyTypes ; private boolean allowEmptyLoops ; private boolean ignoreEnhancedForColon = true ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . ASSIGN , TokenTypes . BAND , TokenTypes . BAND_ASSIGN , TokenTypes . BOR , TokenTypes . BOR_ASSIGN , TokenTypes . BSR , TokenTypes . BSR_ASSIGN , TokenTypes . BXOR , TokenTypes . BXOR_ASSIGN , TokenTypes . COLON , TokenTypes . DIV , TokenTypes . DIV_ASSIGN , TokenTypes . DO_WHILE , TokenTypes . EQUAL , TokenTypes . GE , TokenTypes . GT , TokenTypes . LAND , TokenTypes . LCURLY , TokenTypes . LE , TokenTypes . LITERAL_CATCH , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_ELSE , TokenTypes . LITERAL_FINALLY , TokenTypes . LITERAL_FOR , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_RETURN , TokenTypes . LITERAL_SWITCH , TokenTypes . LITERAL_SYNCHRONIZED , TokenTypes . LITERAL_TRY , TokenTypes . LITERAL_WHILE , TokenTypes . LOR , TokenTypes . LT , TokenTypes . MINUS , TokenTypes . MINUS_ASSIGN , TokenTypes . MOD , TokenTypes . MOD_ASSIGN , TokenTypes . NOT_EQUAL , TokenTypes . PLUS , TokenTypes . PLUS_ASSIGN , TokenTypes . QUESTION , TokenTypes . RCURLY , TokenTypes . SL , TokenTypes . SLIST , TokenTypes . SL_ASSIGN , TokenTypes . SR , TokenTypes . SR_ASSIGN , TokenTypes . STAR , TokenTypes . STAR_ASSIGN , TokenTypes . LITERAL_ASSERT , TokenTypes . TYPE_EXTENSION_AND , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . ASSIGN , TokenTypes . BAND , TokenTypes . BAND_ASSIGN , TokenTypes . BOR , TokenTypes . BOR_ASSIGN , TokenTypes . BSR , TokenTypes . BSR_ASSIGN , TokenTypes . BXOR , TokenTypes . BXOR_ASSIGN , TokenTypes . COLON , TokenTypes . DIV , TokenTypes . DIV_ASSIGN , TokenTypes . DO_WHILE , TokenTypes . EQUAL , TokenTypes . GE , TokenTypes . GT , TokenTypes . LAND , TokenTypes . LCURLY , TokenTypes . LE , TokenTypes . LITERAL_CATCH , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_ELSE , TokenTypes . LITERAL_FINALLY , TokenTypes . LITERAL_FOR , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_RETURN , TokenTypes . LITERAL_SWITCH , TokenTypes . LITERAL_SYNCHRONIZED , TokenTypes . LITERAL_TRY , TokenTypes . LITERAL_WHILE , TokenTypes . LOR , TokenTypes . LT , TokenTypes . MINUS , TokenTypes . MINUS_ASSIGN , TokenTypes . MOD , TokenTypes . MOD_ASSIGN , TokenTypes . NOT_EQUAL , TokenTypes . PLUS , TokenTypes . PLUS_ASSIGN , TokenTypes . QUESTION , TokenTypes . RCURLY , TokenTypes . SL , TokenTypes . SLIST , TokenTypes . SL_ASSIGN , TokenTypes . SR , TokenTypes . SR_ASSIGN , TokenTypes . STAR , TokenTypes . STAR_ASSIGN , TokenTypes . LITERAL_ASSERT , TokenTypes . TYPE_EXTENSION_AND , TokenTypes . WILDCARD_TYPE , } ; } public void setAllowEmptyMethods ( boolean allow ) { allowEmptyMethods = allow ; } public void setAllowEmptyConstructors ( boolean allow ) { allowEmptyCtors = allow ; } public void setIgnoreEnhancedForColon ( boolean ignore ) { ignoreEnhancedForColon = ignore ; } public void setAllowEmptyTypes ( boolean allow ) { allowEmptyTypes = allow ; } public void setAllowEmptyLoops ( boolean allow ) { allowEmptyLoops = allow ; } @ Override public void visitToken ( DetailAST ast ) { final int currentType = ast . getType ( ) ; if ( isNotRelevantSituation ( ast , currentType ) ) { return ; } final String line = getLine ( ast . getLineNo ( ) - 1 ) ; final int before = ast . getColumnNo ( ) - 1 ; final int after = ast . getColumnNo ( ) + ast . getText ( ) . length ( ) ; if ( before >= 0 && ! Character . isWhitespace ( line . charAt ( before ) ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , WS_NOT_PRECEDED , ast . getText ( ) ) ; } if ( after >= line . length ( ) ) { return ; } final char nextChar = line . charAt ( after ) ; if ( ! Character . isWhitespace ( nextChar ) && ! ( currentType == TokenTypes . LITERAL_RETURN && ast . getFirstChild ( ) . getType ( ) == TokenTypes . SEMI ) && ! isAnnonimousInnerClassEnd ( currentType , nextChar ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) + ast . getText ( ) . length ( ) , WS_NOT_FOLLOWED , ast . getText ( ) ) ; } } private boolean isAnnonimousInnerClassEnd ( int currentType , char nextChar ) { return currentType == TokenTypes . RCURLY && ( nextChar == ')' || nextChar == ';' || nextChar == ',' || nextChar == '.' ) ; } private boolean isNotRelevantSituation ( DetailAST ast , int currentType ) { final int parentType = ast . getParent ( ) . getType ( ) ; if ( isArrayInitialization ( currentType , parentType ) ) { return true ; } if ( currentType == TokenTypes . STAR && parentType == TokenTypes . DOT ) { return true ; } if ( currentType == TokenTypes . SLIST && parentType == TokenTypes . CASE_GROUP ) { return true ; } if ( isColonOfCaseOrDefault ( currentType , parentType ) ) { return true ; } if ( isEmptyBlock ( ast , parentType ) ) { return true ; } return allowEmptyTypes && isEmptyType ( ast , parentType ) ; } private boolean isEmptyBlock ( DetailAST ast , int parentType ) { return isEmptyMethodBlock ( ast , parentType ) || isEmptyCtorBlock ( ast , parentType ) || isEmptyLoop ( ast , parentType ) ; } private boolean isColonOfCaseOrDefault ( int currentType , int parentType ) { if ( currentType == TokenTypes . COLON ) { if ( parentType == TokenTypes . LITERAL_DEFAULT || parentType == TokenTypes . LITERAL_CASE ) { return true ; } else if ( parentType == TokenTypes . FOR_EACH_CLAUSE && this . ignoreEnhancedForColon ) { return true ; } } return false ; } private boolean isArrayInitialization ( int currentType , int parentType ) { return ( currentType == TokenTypes . RCURLY || currentType == TokenTypes . LCURLY ) && ( parentType == TokenTypes . ARRAY_INIT || parentType == TokenTypes . ANNOTATION_ARRAY_INIT ) ; } private boolean isEmptyMethodBlock ( DetailAST ast , int parentType ) { return allowEmptyMethods && isEmptyBlock ( ast , parentType , TokenTypes . METHOD_DEF ) ; } private boolean isEmptyCtorBlock ( DetailAST ast , int parentType ) { return allowEmptyCtors && isEmptyBlock ( ast , parentType , TokenTypes . CTOR_DEF ) ; } private boolean isEmptyLoop ( DetailAST ast , int parentType ) { return allowEmptyLoops && ( isEmptyBlock ( ast , parentType , TokenTypes . LITERAL_FOR ) || isEmptyBlock ( ast , parentType , TokenTypes . LITERAL_WHILE ) || isEmptyBlock ( ast , parentType , TokenTypes . LITERAL_DO ) ) ; } private boolean isEmptyType ( DetailAST ast , int parentType ) { final int type = ast . getType ( ) ; if ( ( type == TokenTypes . RCURLY || type == TokenTypes . LCURLY ) && parentType == TokenTypes . OBJBLOCK ) { final DetailAST typeNode = ast . getParent ( ) . getParent ( ) ; final int matchType = typeNode . getType ( ) ; if ( matchType == TokenTypes . CLASS_DEF || matchType == TokenTypes . INTERFACE_DEF || matchType == TokenTypes . ENUM_DEF || matchType == TokenTypes . LITERAL_NEW || matchType == TokenTypes . ANNOTATION_DEF ) { return true ; } } return false ; } private boolean isEmptyBlock ( DetailAST ast , int parentType , int match ) { final int type = ast . getType ( ) ; if ( type == TokenTypes . RCURLY ) { final DetailAST grandParent = ast . getParent ( ) . getParent ( ) ; return parentType == TokenTypes . SLIST && grandParent . getType ( ) == match ; } return type == TokenTypes . SLIST && parentType == match && ast . getFirstChild ( ) . getType ( ) == TokenTypes . RCURLY ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; public class GenericWhitespaceCheck extends Check { public static final String WS_PRECEDED = "ws.preceded" ; public static final String WS_FOLLOWED = "ws.followed" ; public static final String WS_NOT_PRECEDED = "ws.notPreceded" ; public static final String WS_ILLEGAL_FOLLOW = "ws.illegalFollow" ; private int depth ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . GENERIC_START , TokenTypes . GENERIC_END } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . GENERIC_START , TokenTypes . GENERIC_END } ; } @ Override public void beginTree ( DetailAST rootAST ) { depth = 0 ; } @ Override public void visitToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . GENERIC_START ) { processStart ( ast ) ; depth ++ ; } else if ( ast . getType ( ) == TokenTypes . GENERIC_END ) { processEnd ( ast ) ; depth -- ; } } private void processEnd ( DetailAST ast ) { final String line = getLine ( ast . getLineNo ( ) - 1 ) ; final int before = ast . getColumnNo ( ) - 1 ; final int after = ast . getColumnNo ( ) + 1 ; if ( 0 <= before && Character . isWhitespace ( line . charAt ( before ) ) && ! Utils . whitespaceBefore ( before , line ) ) { log ( ast . getLineNo ( ) , before , WS_PRECEDED , ">" ) ; } if ( after < line . length ( ) ) { if ( 1 == depth ) { processSingleGeneric ( ast , line , after ) ; } else { processNestedGenerics ( ast , line , after ) ; } } } private void processNestedGenerics ( DetailAST ast , String line , int after ) { final int indexOfAmp = line . indexOf ( '&' , after ) ; if ( indexOfAmp != - 1 && whitespaceBetween ( after , indexOfAmp , line ) ) { if ( indexOfAmp - after == 0 ) { log ( ast . getLineNo ( ) , after , WS_NOT_PRECEDED , "&" ) ; } else if ( indexOfAmp - after != 1 ) { log ( ast . getLineNo ( ) , after , WS_FOLLOWED , ">" ) ; } } else if ( line . charAt ( after ) == ' ' ) { log ( ast . getLineNo ( ) , after , WS_FOLLOWED , ">" ) ; } } private void processSingleGeneric ( DetailAST ast , String line , int after ) { final char charAfter = line . charAt ( after ) ; if ( isGenericBeforeMethod ( ast ) ) { if ( Character . isWhitespace ( charAfter ) ) { log ( ast . getLineNo ( ) , after , WS_FOLLOWED , ">" ) ; } } else if ( ! Character . isWhitespace ( charAfter ) && '(' != charAfter && ')' != charAfter && ',' != charAfter && '[' != charAfter && '.' != charAfter && ':' != charAfter && ! isAfterMethodReference ( ast ) ) { log ( ast . getLineNo ( ) , after , WS_ILLEGAL_FOLLOW , ">" ) ; } } private boolean isGenericBeforeMethod ( DetailAST ast ) { return ast . getParent ( ) . getType ( ) == TokenTypes . TYPE_ARGUMENTS && ast . getParent ( ) . getParent ( ) . getType ( ) == TokenTypes . DOT && ast . getParent ( ) . getParent ( ) . getParent ( ) . getType ( ) == TokenTypes . METHOD_CALL || isAfterMethodReference ( ast ) ; } private static boolean isAfterMethodReference ( DetailAST genericEnd ) { return genericEnd . getParent ( ) . getParent ( ) . getType ( ) == TokenTypes . METHOD_REF ; } private void processStart ( DetailAST ast ) { final String line = getLine ( ast . getLineNo ( ) - 1 ) ; final int before = ast . getColumnNo ( ) - 1 ; final int after = ast . getColumnNo ( ) + 1 ; if ( 0 <= before ) { final DetailAST parent = ast . getParent ( ) ; final DetailAST grandparent = parent . getParent ( ) ; if ( TokenTypes . TYPE_PARAMETERS == parent . getType ( ) && ( TokenTypes . CTOR_DEF == grandparent . getType ( ) || TokenTypes . METHOD_DEF == grandparent . getType ( ) ) ) { if ( ! Character . isWhitespace ( line . charAt ( before ) ) ) { log ( ast . getLineNo ( ) , before , WS_NOT_PRECEDED , "<" ) ; } } else if ( Character . isWhitespace ( line . charAt ( before ) ) && ! Utils . whitespaceBefore ( before , line ) ) { log ( ast . getLineNo ( ) , before , WS_PRECEDED , "<" ) ; } } if ( after < line . length ( ) && Character . isWhitespace ( line . charAt ( after ) ) ) { log ( ast . getLineNo ( ) , after , WS_FOLLOWED , "<" ) ; } } private static boolean whitespaceBetween ( int fromIndex , int toIndex , String line ) { for ( int i = fromIndex ; i < toIndex ; i ++ ) { if ( ! Character . isWhitespace ( line . charAt ( i ) ) ) { return false ; } } return true ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class WhitespaceAfterCheck extends Check { public static final String WS_NOT_FOLLOWED = "ws.notFollowed" ; public static final String WS_TYPECAST = "ws.typeCast" ; @ Override public int [ ] getDefaultTokens ( ) { return getAcceptableTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . COMMA , TokenTypes . SEMI , TokenTypes . TYPECAST , } ; } @ Override public void visitToken ( DetailAST ast ) { final String line = getLine ( ast . getLineNo ( ) - 1 ) ; if ( ast . getType ( ) == TokenTypes . TYPECAST ) { final DetailAST targetAST = ast . findFirstToken ( TokenTypes . RPAREN ) ; if ( ! isFollowedByWhitespace ( targetAST , line ) ) { log ( targetAST . getLineNo ( ) , targetAST . getColumnNo ( ) + targetAST . getText ( ) . length ( ) , WS_TYPECAST ) ; } } else { if ( ! isFollowedByWhitespace ( ast , line ) ) { final Object [ ] message = new Object [ ] { ast . getText ( ) } ; log ( ast . getLineNo ( ) , ast . getColumnNo ( ) + ast . getText ( ) . length ( ) , WS_NOT_FOLLOWED , message ) ; } } } private static boolean isFollowedByWhitespace ( DetailAST targetAST , String line ) { final int after = targetAST . getColumnNo ( ) + targetAST . getText ( ) . length ( ) ; boolean followedByWhitespace = true ; if ( after < line . length ( ) ) { final char charAfter = line . charAt ( after ) ; if ( targetAST . getType ( ) == TokenTypes . SEMI && ( charAfter == ';' || charAfter == ')' ) ) { followedByWhitespace = true ; } else if ( ! Character . isWhitespace ( charAfter ) && ! isEmptyForIterator ( targetAST ) ) { followedByWhitespace = false ; } } return followedByWhitespace ; } private static boolean isEmptyForIterator ( DetailAST targetAST ) { if ( targetAST . getType ( ) == TokenTypes . SEMI ) { final DetailAST sibling = targetAST . getNextSibling ( ) ; if ( sibling != null && sibling . getType ( ) == TokenTypes . FOR_ITERATOR && sibling . getChildCount ( ) == 0 ) { return true ; } } return false ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; public enum PadOption { NOSPACE , SPACE }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class NoWhitespaceBeforeCheck extends Check { public static final String MSG_KEY = "ws.preceded" ; private boolean allowLineBreaks ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . SEMI , TokenTypes . POST_INC , TokenTypes . POST_DEC , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . SEMI , TokenTypes . POST_INC , TokenTypes . POST_DEC , TokenTypes . DOT , } ; } @ Override public void visitToken ( DetailAST ast ) { final String line = getLine ( ast . getLineNo ( ) - 1 ) ; final int before = ast . getColumnNo ( ) - 1 ; if ( before < 0 || Character . isWhitespace ( line . charAt ( before ) ) ) { if ( ast . getType ( ) == TokenTypes . SEMI ) { final DetailAST sibling = ast . getPreviousSibling ( ) ; if ( sibling != null && sibling . getType ( ) == TokenTypes . FOR_INIT && sibling . getChildCount ( ) == 0 ) { return ; } } boolean flag = ! allowLineBreaks ; for ( int i = 0 ; ! flag && i < before ; i ++ ) { if ( ! Character . isWhitespace ( line . charAt ( i ) ) ) { flag = true ; } } if ( flag ) { log ( ast . getLineNo ( ) , before , MSG_KEY , ast . getText ( ) ) ; } } } public void setAllowLineBreaks ( boolean allowLineBreaks ) { this . allowLineBreaks = allowLineBreaks ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . AbstractOptionCheck ; public class EmptyForIteratorPadCheck extends AbstractOptionCheck < PadOption > { public static final String WS_FOLLOWED = "ws.followed" ; public static final String WS_NOT_FOLLOWED = "ws.notFollowed" ; public EmptyForIteratorPadCheck ( ) { super ( PadOption . NOSPACE , PadOption . class ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . FOR_ITERATOR , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . FOR_ITERATOR , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( ast . getChildCount ( ) == 0 ) { final DetailAST semi = ast . getPreviousSibling ( ) ; final String line = getLines ( ) [ semi . getLineNo ( ) - 1 ] ; final int after = semi . getColumnNo ( ) + 1 ; if ( after < line . length ( ) ) { if ( PadOption . NOSPACE == getAbstractOption ( ) && Character . isWhitespace ( line . charAt ( after ) ) ) { log ( semi . getLineNo ( ) , after , WS_FOLLOWED , ";" ) ; } else if ( PadOption . SPACE == getAbstractOption ( ) && ! Character . isWhitespace ( line . charAt ( after ) ) ) { log ( semi . getLineNo ( ) , after , WS_NOT_FOLLOWED , ";" ) ; } } } } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . AbstractOptionCheck ; public class SeparatorWrapCheck extends AbstractOptionCheck < WrapOption > { public static final String LINE_PREVIOUS = "line.previous" ; public static final String LINE_NEW = "line.new" ; public SeparatorWrapCheck ( ) { super ( WrapOption . EOL , WrapOption . class ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . DOT , TokenTypes . COMMA , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . DOT , TokenTypes . COMMA , TokenTypes . SEMI , TokenTypes . ELLIPSIS , TokenTypes . AT , TokenTypes . LPAREN , TokenTypes . RPAREN , TokenTypes . ARRAY_DECLARATOR , TokenTypes . RBRACK , } ; } @ Override public void visitToken ( DetailAST ast ) { final String text = ast . getText ( ) ; final int colNo = ast . getColumnNo ( ) ; final int lineNo = ast . getLineNo ( ) ; final String currentLine = getLines ( ) [ lineNo - 1 ] ; final String substringAfterToken = currentLine . substring ( colNo + text . length ( ) ) . trim ( ) ; final String substringBeforeToken = currentLine . substring ( 0 , colNo ) . trim ( ) ; final WrapOption wSp = getAbstractOption ( ) ; if ( wSp == WrapOption . EOL && substringBeforeToken . length ( ) == 0 ) { log ( lineNo , colNo , LINE_PREVIOUS , text ) ; } else if ( wSp == WrapOption . NL && substringAfterToken . length ( ) == 0 ) { log ( lineNo , colNo , LINE_NEW , text ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . checks . AbstractOptionCheck ; public class EmptyForInitializerPadCheck extends AbstractOptionCheck < PadOption > { public static final String MSG_PRECEDED = "ws.preceded" ; public static final String MSG_NOT_PRECEDED = "ws.notPreceded" ; public EmptyForInitializerPadCheck ( ) { super ( PadOption . NOSPACE , PadOption . class ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . FOR_INIT , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . FOR_INIT , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( ast . getChildCount ( ) == 0 ) { final DetailAST semi = ast . getNextSibling ( ) ; final int semiLineIdx = semi . getLineNo ( ) - 1 ; final String line = getLines ( ) [ semiLineIdx ] ; final int before = semi . getColumnNo ( ) - 1 ; if ( ! Utils . whitespaceBefore ( before , line ) ) { final PadOption option = getAbstractOption ( ) ; if ( PadOption . NOSPACE == option && Character . isWhitespace ( line . charAt ( before ) ) ) { log ( semi . getLineNo ( ) , before , MSG_PRECEDED , ";" ) ; } else if ( PadOption . SPACE == option && ! Character . isWhitespace ( line . charAt ( before ) ) ) { log ( semi . getLineNo ( ) , before , MSG_NOT_PRECEDED , ";" ) ; } } } } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . AbstractFileSetCheck ; import java . io . File ; import java . util . List ; public class FileTabCharacterCheck extends AbstractFileSetCheck { public static final String CONTAINS_TAB = "containsTab" ; public static final String FILE_CONTAINS_TAB = "file.containsTab" ; private boolean eachLine ; @ Override protected void processFiltered ( File file , List < String > lines ) { int lineNum = 0 ; for ( final String line : lines ) { lineNum ++ ; final int tabPosition = line . indexOf ( '\t' ) ; if ( tabPosition != - 1 ) { if ( eachLine ) { log ( lineNum , tabPosition + 1 , CONTAINS_TAB ) ; } else { log ( lineNum , tabPosition + 1 , FILE_CONTAINS_TAB ) ; break ; } } } } public void setEachLine ( boolean eachLine ) { this . eachLine = eachLine ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . MethodParamPadCheck . LINE_PREVIOUS ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . MethodParamPadCheck . WS_NOT_PRECEDED ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . MethodParamPadCheck . WS_PRECEDED ; public class MethodParamPadCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( MethodParamPadCheck . class ) ; } @ Test public void testDefault ( ) throws Exception { final String [ ] expected = { "11:32: " + getCheckMessage ( WS_PRECEDED , "(" ) , "13:15: " + getCheckMessage ( WS_PRECEDED , "(" ) , "17:9: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "20:13: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "27:24: " + getCheckMessage ( WS_PRECEDED , "(" ) , "32:9: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "36:39: " + getCheckMessage ( WS_PRECEDED , "(" ) , "38:13: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "42:16: " + getCheckMessage ( WS_PRECEDED , "(" ) , "44:13: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "50:21: " + getCheckMessage ( WS_PRECEDED , "(" ) , "52:13: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "56:18: " + getCheckMessage ( WS_PRECEDED , "(" ) , "58:13: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "61:36: " + getCheckMessage ( WS_PRECEDED , "(" ) , "63:13: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputMethodParamPad.java" ) , expected ) ; } @ Test public void testAllowLineBreaks ( ) throws Exception { checkConfig . addAttribute ( "allowLineBreaks" , "true" ) ; final String [ ] expected = { "11:32: " + getCheckMessage ( WS_PRECEDED , "(" ) , "13:15: " + getCheckMessage ( WS_PRECEDED , "(" ) , "27:24: " + getCheckMessage ( WS_PRECEDED , "(" ) , "36:39: " + getCheckMessage ( WS_PRECEDED , "(" ) , "42:16: " + getCheckMessage ( WS_PRECEDED , "(" ) , "50:21: " + getCheckMessage ( WS_PRECEDED , "(" ) , "56:18: " + getCheckMessage ( WS_PRECEDED , "(" ) , "61:36: " + getCheckMessage ( WS_PRECEDED , "(" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputMethodParamPad.java" ) , expected ) ; } @ Test public void testSpaceOption ( ) throws Exception { checkConfig . addAttribute ( "option" , "space" ) ; final String [ ] expected = { "6:31: " + getCheckMessage ( WS_NOT_PRECEDED , "(" ) , "8:14: " + getCheckMessage ( WS_NOT_PRECEDED , "(" ) , "17:9: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "20:13: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "23:23: " + getCheckMessage ( WS_NOT_PRECEDED , "(" ) , "32:9: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "35:58: " + getCheckMessage ( WS_NOT_PRECEDED , "(" ) , "38:13: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "41:15: " + getCheckMessage ( WS_NOT_PRECEDED , "(" ) , "44:13: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "47:28: " + getCheckMessage ( WS_NOT_PRECEDED , "(" ) , "49:20: " + getCheckMessage ( WS_NOT_PRECEDED , "(" ) , "52:13: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "54:56: " + getCheckMessage ( WS_NOT_PRECEDED , "(" ) , "55:17: " + getCheckMessage ( WS_NOT_PRECEDED , "(" ) , "58:13: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "60:35: " + getCheckMessage ( WS_NOT_PRECEDED , "(" ) , "63:13: " + getCheckMessage ( LINE_PREVIOUS , "(" ) , "66:25: " + getCheckMessage ( WS_NOT_PRECEDED , "(" ) , "69:66: " + getCheckMessage ( WS_NOT_PRECEDED , "(" ) , "70:57: " + getCheckMessage ( WS_NOT_PRECEDED , "(" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputMethodParamPad.java" ) , expected ) ; } @ Test public void test1322879 ( ) throws Exception { checkConfig . addAttribute ( "option" , PadOption . SPACE . toString ( ) ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "whitespace/InputWhitespaceAround.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . checks . AbstractOptionCheck ; abstract class AbstractParenPadCheck extends AbstractOptionCheck < PadOption > { public static final String WS_FOLLOWED = "ws.followed" ; public static final String WS_NOT_FOLLOWED = "ws.notFollowed" ; public static final String WS_PRECEDED = "ws.preceded" ; public static final String WS_NOT_PRECEDED = "ws.notPreceded" ; AbstractParenPadCheck ( ) { super ( PadOption . NOSPACE , PadOption . class ) ; } protected void processLeft ( DetailAST ast ) { final String line = getLines ( ) [ ast . getLineNo ( ) - 1 ] ; final int after = ast . getColumnNo ( ) + 1 ; if ( after < line . length ( ) ) { if ( PadOption . NOSPACE == getAbstractOption ( ) && Character . isWhitespace ( line . charAt ( after ) ) ) { log ( ast . getLineNo ( ) , after , WS_FOLLOWED , "(" ) ; } else if ( PadOption . SPACE == getAbstractOption ( ) && ! Character . isWhitespace ( line . charAt ( after ) ) && line . charAt ( after ) != ')' ) { log ( ast . getLineNo ( ) , after , WS_NOT_FOLLOWED , "(" ) ; } } } protected void processRight ( DetailAST ast ) { final String line = getLines ( ) [ ast . getLineNo ( ) - 1 ] ; final int before = ast . getColumnNo ( ) - 1 ; if ( before >= 0 ) { if ( PadOption . NOSPACE == getAbstractOption ( ) && Character . isWhitespace ( line . charAt ( before ) ) && ! Utils . whitespaceBefore ( before , line ) ) { log ( ast . getLineNo ( ) , before , WS_PRECEDED , ")" ) ; } else if ( PadOption . SPACE == getAbstractOption ( ) && ! Character . isWhitespace ( line . charAt ( before ) ) && line . charAt ( before ) != '(' ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , WS_NOT_PRECEDED , ")" ) ; } } } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . checks . AbstractOptionCheck ; public class MethodParamPadCheck extends AbstractOptionCheck < PadOption > { public static final String LINE_PREVIOUS = "line.previous" ; public static final String WS_PRECEDED = "ws.preceded" ; public static final String WS_NOT_PRECEDED = "ws.notPreceded" ; private boolean allowLineBreaks ; public MethodParamPadCheck ( ) { super ( PadOption . NOSPACE , PadOption . class ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . LITERAL_NEW , TokenTypes . METHOD_CALL , TokenTypes . METHOD_DEF , TokenTypes . SUPER_CTOR_CALL , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . LITERAL_NEW , TokenTypes . METHOD_CALL , TokenTypes . METHOD_DEF , TokenTypes . SUPER_CTOR_CALL , } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST parenAST ; if ( ast . getType ( ) == TokenTypes . METHOD_CALL ) { parenAST = ast ; } else { parenAST = ast . findFirstToken ( TokenTypes . LPAREN ) ; if ( parenAST == null ) { return ; } } final String line = getLines ( ) [ parenAST . getLineNo ( ) - 1 ] ; if ( Utils . whitespaceBefore ( parenAST . getColumnNo ( ) , line ) ) { if ( ! allowLineBreaks ) { log ( parenAST , LINE_PREVIOUS , parenAST . getText ( ) ) ; } } else { final int before = parenAST . getColumnNo ( ) - 1 ; if ( PadOption . NOSPACE == getAbstractOption ( ) && Character . isWhitespace ( line . charAt ( before ) ) ) { log ( parenAST , WS_PRECEDED , parenAST . getText ( ) ) ; } else if ( PadOption . SPACE == getAbstractOption ( ) && ! Character . isWhitespace ( line . charAt ( before ) ) ) { log ( parenAST , WS_NOT_PRECEDED , parenAST . getText ( ) ) ; } } } public void setAllowLineBreaks ( boolean allowLineBreaks ) { this . allowLineBreaks = allowLineBreaks ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import java . util . Arrays ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ParenPadCheck extends AbstractParenPadCheck { private final int [ ] acceptableTokens ; public ParenPadCheck ( ) { acceptableTokens = makeAcceptableTokens ( ) ; Arrays . sort ( acceptableTokens ) ; } @ Override public int [ ] getDefaultTokens ( ) { return getAcceptableTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return makeAcceptableTokens ( ) ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . METHOD_CALL : processLeft ( ast ) ; processRight ( ast . findFirstToken ( TokenTypes . RPAREN ) ) ; processExpression ( ast ) ; break ; case TokenTypes . EXPR : case TokenTypes . QUESTION : processExpression ( ast ) ; break ; case TokenTypes . LITERAL_FOR : visitLiteralFor ( ast ) ; break ; case TokenTypes . ANNOTATION : case TokenTypes . ENUM_CONSTANT_DEF : case TokenTypes . LITERAL_NEW : case TokenTypes . LITERAL_SYNCHRONIZED : visitNewEnumConstDefAnnotationSync ( ast ) ; break ; default : processLeft ( ast . findFirstToken ( TokenTypes . LPAREN ) ) ; processRight ( ast . findFirstToken ( TokenTypes . RPAREN ) ) ; } } private void visitNewEnumConstDefAnnotationSync ( DetailAST ast ) { final DetailAST parenAst = ast . findFirstToken ( TokenTypes . LPAREN ) ; if ( parenAst != null ) { processLeft ( parenAst ) ; processRight ( ast . findFirstToken ( TokenTypes . RPAREN ) ) ; } } private void visitLiteralFor ( DetailAST ast ) { DetailAST parenAst = ast . findFirstToken ( TokenTypes . LPAREN ) ; if ( ! isPreceedsEmptyForInit ( parenAst ) ) { processLeft ( parenAst ) ; } parenAst = ast . findFirstToken ( TokenTypes . RPAREN ) ; if ( ! isFollowsEmptyForIterator ( parenAst ) ) { processRight ( parenAst ) ; } } private void processExpression ( DetailAST ast ) { if ( ast . branchContains ( TokenTypes . LPAREN ) ) { DetailAST childAst = ast . getFirstChild ( ) ; while ( childAst != null ) { if ( childAst . getType ( ) == TokenTypes . LPAREN ) { processLeft ( childAst ) ; processExpression ( childAst ) ; } else if ( childAst . getType ( ) == TokenTypes . RPAREN && ! isInTypecast ( childAst ) ) { processRight ( childAst ) ; } else if ( ! isAcceptableToken ( childAst ) ) { processExpression ( childAst ) ; } childAst = childAst . getNextSibling ( ) ; } } } private boolean isAcceptableToken ( DetailAST ast ) { boolean result = false ; if ( Arrays . binarySearch ( acceptableTokens , ast . getType ( ) ) >= 0 ) { result = true ; } return result ; } private static int [ ] makeAcceptableTokens ( ) { return new int [ ] { TokenTypes . ANNOTATION , TokenTypes . ANNOTATION_FIELD_DEF , TokenTypes . CTOR_CALL , TokenTypes . CTOR_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . EXPR , TokenTypes . LITERAL_CATCH , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_FOR , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_NEW , TokenTypes . LITERAL_SWITCH , TokenTypes . LITERAL_SYNCHRONIZED , TokenTypes . LITERAL_WHILE , TokenTypes . METHOD_CALL , TokenTypes . METHOD_DEF , TokenTypes . QUESTION , TokenTypes . RESOURCE_SPECIFICATION , TokenTypes . SUPER_CTOR_CALL , } ; } private static boolean isInTypecast ( DetailAST ast ) { boolean result = false ; if ( ast . getParent ( ) . getType ( ) == TokenTypes . TYPECAST ) { final DetailAST firstRparen = ast . getParent ( ) . findFirstToken ( TokenTypes . RPAREN ) ; if ( firstRparen . getLineNo ( ) == ast . getLineNo ( ) && firstRparen . getColumnNo ( ) == ast . getColumnNo ( ) ) { result = true ; } } return result ; } private static boolean isFollowsEmptyForIterator ( DetailAST ast ) { boolean result = false ; final DetailAST parent = ast . getParent ( ) ; if ( parent . findFirstToken ( TokenTypes . FOR_EACH_CLAUSE ) == null ) { final DetailAST forIterator = parent . findFirstToken ( TokenTypes . FOR_ITERATOR ) ; result = forIterator . getChildCount ( ) == 0 ; } return result ; } private static boolean isPreceedsEmptyForInit ( DetailAST ast ) { boolean result = false ; final DetailAST parent = ast . getParent ( ) ; if ( parent . findFirstToken ( TokenTypes . FOR_EACH_CLAUSE ) == null ) { final DetailAST forIterator = parent . findFirstToken ( TokenTypes . FOR_INIT ) ; result = forIterator . getChildCount ( ) == 0 ; } return result ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class EmptyLineSeparatorCheck extends Check { public static final String MSG_SHOULD_BE_SEPARATED = "empty.line.separator" ; public static final String MSG_MULTIPLE_LINES = "empty.line.separator.multiple.lines" ; private boolean allowNoEmptyLineBetweenFields ; private boolean allowMultipleEmptyLines = true ; public final void setAllowNoEmptyLineBetweenFields ( boolean allow ) { allowNoEmptyLineBetweenFields = allow ; } public void setAllowMultipleEmptyLines ( boolean allow ) { allowMultipleEmptyLines = allow ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF , TokenTypes . IMPORT , TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . STATIC_INIT , TokenTypes . INSTANCE_INIT , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . VARIABLE_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF , TokenTypes . IMPORT , TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . STATIC_INIT , TokenTypes . INSTANCE_INIT , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . VARIABLE_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST nextToken = ast . getNextSibling ( ) ; if ( nextToken != null ) { final int astType = ast . getType ( ) ; switch ( astType ) { case TokenTypes . VARIABLE_DEF : processVariableDef ( ast , nextToken ) ; break ; case TokenTypes . IMPORT : processImport ( ast , nextToken , astType ) ; break ; case TokenTypes . PACKAGE_DEF : processPackage ( ast , nextToken ) ; break ; default : if ( nextToken . getType ( ) != TokenTypes . RCURLY && ! hasEmptyLineAfter ( ast ) ) { log ( nextToken . getLineNo ( ) , MSG_SHOULD_BE_SEPARATED , nextToken . getText ( ) ) ; } if ( hasNotAllowedTwoEmptyLinesBefore ( ast ) ) { log ( ast . getLineNo ( ) , MSG_MULTIPLE_LINES , ast . getText ( ) ) ; } } } } private void processPackage ( DetailAST ast , DetailAST nextToken ) { if ( ast . getLineNo ( ) > 1 && ! hasEmptyLineBefore ( ast ) ) { log ( ast . getLineNo ( ) , MSG_SHOULD_BE_SEPARATED , ast . getText ( ) ) ; } if ( ! hasEmptyLineAfter ( ast ) ) { log ( nextToken . getLineNo ( ) , MSG_SHOULD_BE_SEPARATED , nextToken . getText ( ) ) ; } if ( hasNotAllowedTwoEmptyLinesBefore ( ast ) ) { log ( ast . getLineNo ( ) , MSG_MULTIPLE_LINES , ast . getText ( ) ) ; } } private void processImport ( DetailAST ast , DetailAST nextToken , int astType ) { if ( astType != nextToken . getType ( ) && ! hasEmptyLineAfter ( ast ) || ast . getLineNo ( ) > 1 && ! hasEmptyLineBefore ( ast ) && ast . getPreviousSibling ( ) == null ) { log ( nextToken . getLineNo ( ) , MSG_SHOULD_BE_SEPARATED , nextToken . getText ( ) ) ; } if ( hasNotAllowedTwoEmptyLinesBefore ( ast ) ) { log ( ast . getLineNo ( ) , MSG_MULTIPLE_LINES , ast . getText ( ) ) ; } } private void processVariableDef ( DetailAST ast , DetailAST nextToken ) { if ( isTypeField ( ast ) && ! hasEmptyLineAfter ( ast ) ) { if ( allowNoEmptyLineBetweenFields && nextToken . getType ( ) != TokenTypes . VARIABLE_DEF && nextToken . getType ( ) != TokenTypes . RCURLY ) { log ( nextToken . getLineNo ( ) , MSG_SHOULD_BE_SEPARATED , nextToken . getText ( ) ) ; } else if ( ! allowNoEmptyLineBetweenFields && nextToken . getType ( ) != TokenTypes . RCURLY ) { log ( nextToken . getLineNo ( ) , MSG_SHOULD_BE_SEPARATED , nextToken . getText ( ) ) ; } } if ( isTypeField ( ast ) && hasNotAllowedTwoEmptyLinesBefore ( ast ) ) { log ( ast . getLineNo ( ) , MSG_MULTIPLE_LINES , ast . getText ( ) ) ; } } private boolean hasNotAllowedTwoEmptyLinesBefore ( DetailAST token ) { return ! allowMultipleEmptyLines && hasEmptyLineBefore ( token ) && isPrePreviousLineEmpty ( token ) ; } private boolean isPrePreviousLineEmpty ( DetailAST token ) { boolean result = false ; final int lineNo = token . getLineNo ( ) ; final int number = 3 ; if ( lineNo >= number ) { final String prePreviousLine = getLines ( ) [ lineNo - number ] ; result = prePreviousLine . trim ( ) . isEmpty ( ) ; } return result ; } private boolean hasEmptyLineAfter ( DetailAST token ) { DetailAST lastToken = token . getLastChild ( ) . getLastChild ( ) ; if ( null == lastToken ) { lastToken = token . getLastChild ( ) ; } return token . getNextSibling ( ) . getLineNo ( ) - lastToken . getLineNo ( ) > 1 ; } private boolean hasEmptyLineBefore ( DetailAST token ) { final int lineNo = token . getLineNo ( ) ; if ( lineNo == 1 ) { return false ; } final String lineBefore = getLines ( ) [ lineNo - 2 ] ; return lineBefore . trim ( ) . isEmpty ( ) ; } private boolean isTypeField ( DetailAST variableDef ) { final int parentType = variableDef . getParent ( ) . getParent ( ) . getType ( ) ; return parentType == TokenTypes . CLASS_DEF ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . checks . AbstractOptionCheck ; import org . apache . commons . lang3 . StringUtils ; public class OperatorWrapCheck extends AbstractOptionCheck < WrapOption > { public static final String LINE_NEW = "line.new" ; public static final String LINE_PREVIOUS = "line.previous" ; public OperatorWrapCheck ( ) { super ( WrapOption . NL , WrapOption . class ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . QUESTION , TokenTypes . COLON , TokenTypes . EQUAL , TokenTypes . NOT_EQUAL , TokenTypes . DIV , TokenTypes . PLUS , TokenTypes . MINUS , TokenTypes . STAR , TokenTypes . MOD , TokenTypes . SR , TokenTypes . BSR , TokenTypes . GE , TokenTypes . GT , TokenTypes . SL , TokenTypes . LE , TokenTypes . LT , TokenTypes . BXOR , TokenTypes . BOR , TokenTypes . LOR , TokenTypes . BAND , TokenTypes . LAND , TokenTypes . TYPE_EXTENSION_AND , TokenTypes . LITERAL_INSTANCEOF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . QUESTION , TokenTypes . COLON , TokenTypes . EQUAL , TokenTypes . NOT_EQUAL , TokenTypes . DIV , TokenTypes . PLUS , TokenTypes . MINUS , TokenTypes . STAR , TokenTypes . MOD , TokenTypes . SR , TokenTypes . BSR , TokenTypes . GE , TokenTypes . GT , TokenTypes . SL , TokenTypes . LE , TokenTypes . LT , TokenTypes . BXOR , TokenTypes . BOR , TokenTypes . LOR , TokenTypes . BAND , TokenTypes . LAND , TokenTypes . LITERAL_INSTANCEOF , TokenTypes . TYPE_EXTENSION_AND , TokenTypes . ASSIGN , TokenTypes . DIV_ASSIGN , TokenTypes . PLUS_ASSIGN , TokenTypes . MINUS_ASSIGN , TokenTypes . STAR_ASSIGN , TokenTypes . MOD_ASSIGN , TokenTypes . SR_ASSIGN , TokenTypes . BSR_ASSIGN , TokenTypes . SL_ASSIGN , TokenTypes . BXOR_ASSIGN , TokenTypes . BOR_ASSIGN , TokenTypes . BAND_ASSIGN , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . COLON ) { final DetailAST parent = ast . getParent ( ) ; if ( parent . getType ( ) == TokenTypes . LITERAL_DEFAULT || parent . getType ( ) == TokenTypes . LITERAL_CASE ) { return ; } } final WrapOption wOp = getAbstractOption ( ) ; final String text = ast . getText ( ) ; final int colNo = ast . getColumnNo ( ) ; final int lineNo = ast . getLineNo ( ) ; final String currentLine = getLine ( lineNo - 1 ) ; if ( wOp == WrapOption . NL && ! text . equals ( currentLine . trim ( ) ) && StringUtils . isBlank ( currentLine . substring ( colNo + text . length ( ) ) ) ) { log ( lineNo , colNo , LINE_NEW , text ) ; } else if ( wOp == WrapOption . EOL && Utils . whitespaceBefore ( colNo - 1 , currentLine ) ) { log ( lineNo , colNo , LINE_PREVIOUS , text ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . modifier ;
package com . puppycrawl . tools . checkstyle . checks . modifier ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . Iterator ; import java . util . List ; public class ModifierOrderCheck extends Check { public static final String MSG_ANNOTATION_ORDER = "annotation.order" ; public static final String MSG_MODIFIER_ORDER = "mod.order" ; private static final String [ ] JLS_ORDER = { "public" , "protected" , "private" , "abstract" , "static" , "final" , "transient" , "volatile" , "synchronized" , "native" , "strictfp" , "default" , } ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . MODIFIERS } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . MODIFIERS } ; } @ Override public void visitToken ( DetailAST ast ) { final List < DetailAST > mods = Lists . newArrayList ( ) ; DetailAST modifier = ast . getFirstChild ( ) ; while ( modifier != null ) { mods . add ( modifier ) ; modifier = modifier . getNextSibling ( ) ; } if ( ! mods . isEmpty ( ) ) { final DetailAST error = checkOrderSuggestedByJLS ( mods ) ; if ( error != null ) { if ( error . getType ( ) == TokenTypes . ANNOTATION ) { log ( error . getLineNo ( ) , error . getColumnNo ( ) , MSG_ANNOTATION_ORDER , error . getFirstChild ( ) . getText ( ) + error . getFirstChild ( ) . getNextSibling ( ) . getText ( ) ) ; } else { log ( error . getLineNo ( ) , error . getColumnNo ( ) , MSG_MODIFIER_ORDER , error . getText ( ) ) ; } } } } DetailAST checkOrderSuggestedByJLS ( List < DetailAST > modifiers ) { final Iterator < DetailAST > it = modifiers . iterator ( ) ; DetailAST modifier ; do { modifier = it . next ( ) ; } while ( it . hasNext ( ) && modifier . getType ( ) == TokenTypes . ANNOTATION ) ; if ( modifier . getType ( ) == TokenTypes . ANNOTATION ) { return null ; } int i = 0 ; while ( modifier != null ) { if ( modifier . getType ( ) == TokenTypes . ANNOTATION ) { return modifier ; } while ( i < JLS_ORDER . length && ! JLS_ORDER [ i ] . equals ( modifier . getText ( ) ) ) { i ++ ; } if ( i == JLS_ORDER . length ) { return modifier ; } else if ( it . hasNext ( ) ) { modifier = it . next ( ) ; } else { modifier = null ; } } return modifier ; } }
package com . puppycrawl . tools . checkstyle . checks . modifier ; import java . util . ArrayList ; import java . util . List ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class RedundantModifierCheck extends Check { public static final String MSG_KEY = "redundantModifier" ; private static final int [ ] TOKENS_FOR_INTERFACE_MODIFIERS = new int [ ] { TokenTypes . LITERAL_STATIC , TokenTypes . ABSTRACT , } ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . VARIABLE_DEF , TokenTypes . ANNOTATION_FIELD_DEF , TokenTypes . INTERFACE_DEF , } ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . VARIABLE_DEF , TokenTypes . ANNOTATION_FIELD_DEF , TokenTypes . INTERFACE_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( TokenTypes . INTERFACE_DEF == ast . getType ( ) ) { final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; for ( final int tokenType : TOKENS_FOR_INTERFACE_MODIFIERS ) { final DetailAST modifier = modifiers . findFirstToken ( tokenType ) ; if ( modifier != null ) { log ( modifier . getLineNo ( ) , modifier . getColumnNo ( ) , MSG_KEY , modifier . getText ( ) ) ; } } } else if ( isInterfaceOrAnnotationMember ( ast ) ) { processInterfaceOrAnnotation ( ast ) ; } else if ( ast . getType ( ) == TokenTypes . METHOD_DEF ) { processMethods ( ast ) ; } } private void processInterfaceOrAnnotation ( DetailAST ast ) { final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; DetailAST modifier = modifiers . getFirstChild ( ) ; while ( modifier != null ) { final int type = modifier . getType ( ) ; if ( type == TokenTypes . LITERAL_PUBLIC || type == TokenTypes . LITERAL_STATIC && ast . getType ( ) != TokenTypes . METHOD_DEF || type == TokenTypes . ABSTRACT || type == TokenTypes . FINAL ) { log ( modifier . getLineNo ( ) , modifier . getColumnNo ( ) , MSG_KEY , modifier . getText ( ) ) ; break ; } modifier = modifier . getNextSibling ( ) ; } } private void processMethods ( DetailAST ast ) { final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; boolean checkFinal = modifiers . branchContains ( TokenTypes . LITERAL_PRIVATE ) ; DetailAST parent = ast . getParent ( ) ; while ( parent != null ) { if ( parent . getType ( ) == TokenTypes . CLASS_DEF ) { final DetailAST classModifiers = parent . findFirstToken ( TokenTypes . MODIFIERS ) ; checkFinal |= classModifiers . branchContains ( TokenTypes . FINAL ) ; break ; } parent = parent . getParent ( ) ; } if ( checkFinal && ! isAnnotatedWithSafeVarargs ( ast ) ) { DetailAST modifier = modifiers . getFirstChild ( ) ; while ( modifier != null ) { final int type = modifier . getType ( ) ; if ( type == TokenTypes . FINAL ) { log ( modifier . getLineNo ( ) , modifier . getColumnNo ( ) , MSG_KEY , modifier . getText ( ) ) ; break ; } modifier = modifier . getNextSibling ( ) ; } } } private static boolean isInterfaceOrAnnotationMember ( DetailAST ast ) { final DetailAST parentTypeDef = ast . getParent ( ) . getParent ( ) ; return parentTypeDef . getType ( ) == TokenTypes . INTERFACE_DEF || parentTypeDef . getType ( ) == TokenTypes . ANNOTATION_DEF ; } private static boolean isAnnotatedWithSafeVarargs ( DetailAST methodDef ) { boolean result = false ; final List < DetailAST > methodAnnotationsList = getMethodAnnotationsList ( methodDef ) ; for ( DetailAST annotationNode : methodAnnotationsList ) { if ( "SafeVarargs" . equals ( annotationNode . getLastChild ( ) . getText ( ) ) ) { result = true ; break ; } } return result ; } private static List < DetailAST > getMethodAnnotationsList ( DetailAST methodDef ) { final List < DetailAST > annotationsList = new ArrayList < > ( ) ; final DetailAST modifiers = methodDef . findFirstToken ( TokenTypes . MODIFIERS ) ; DetailAST modifier = modifiers . getFirstChild ( ) ; while ( modifier != null ) { if ( modifier . getType ( ) == TokenTypes . ANNOTATION ) { annotationsList . add ( modifier ) ; } modifier = modifier . getNextSibling ( ) ; } return annotationsList ; } }
package com . puppycrawl . tools . checkstyle . checks . blocks ; import java . util . regex . Pattern ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class EmptyCatchBlockCheck extends Check { public static final String MSG_KEY_CATCH_BLOCK_EMPTY = "catch.block.empty" ; private String exceptionVariableName = "^$" ; private String commentFormat = ".*" ; private Pattern variableNameRegexp = Pattern . compile ( exceptionVariableName ) ; private Pattern commentRegexp = Pattern . compile ( commentFormat ) ; public void setExceptionVariableName ( String exceptionVariableName ) { this . exceptionVariableName = exceptionVariableName ; variableNameRegexp = Utils . createPattern ( exceptionVariableName ) ; } public void setCommentFormat ( String commentFormat ) { this . commentFormat = commentFormat ; commentRegexp = Utils . createPattern ( commentFormat ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_CATCH , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . LITERAL_CATCH , } ; } @ Override public boolean isCommentNodesRequired ( ) { return true ; } @ Override public void visitToken ( DetailAST ast ) { visitCatchBlock ( ast ) ; } private void visitCatchBlock ( DetailAST catchAst ) { if ( isEmptyCatchBlock ( catchAst ) ) { final String commentContent = getCommentFirstLine ( catchAst ) ; if ( isVerifiable ( catchAst , commentContent ) ) { log ( catchAst . getLineNo ( ) , MSG_KEY_CATCH_BLOCK_EMPTY ) ; } } } private static String getCommentFirstLine ( DetailAST catchAst ) { final DetailAST slistToken = catchAst . getLastChild ( ) ; final DetailAST firstElementInBlock = slistToken . getFirstChild ( ) ; String commentContent = "" ; if ( firstElementInBlock . getType ( ) == TokenTypes . SINGLE_LINE_COMMENT ) { commentContent = firstElementInBlock . getFirstChild ( ) . getText ( ) ; } else if ( firstElementInBlock . getType ( ) == TokenTypes . BLOCK_COMMENT_BEGIN ) { commentContent = firstElementInBlock . getFirstChild ( ) . getText ( ) ; final String [ ] lines = commentContent . split ( System . getProperty ( "line.separator" ) ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { if ( ! lines [ i ] . isEmpty ( ) ) { commentContent = lines [ i ] ; break ; } } } return commentContent ; } private boolean isVerifiable ( DetailAST emptyCatchAst , String commentContent ) { final String exceptionVariableName = getExceptionVariableName ( emptyCatchAst ) ; final boolean isMatchingVariableName = variableNameRegexp . matcher ( exceptionVariableName ) . find ( ) ; final boolean isMatchingCommentContent = ! commentContent . isEmpty ( ) && commentRegexp . matcher ( commentContent ) . find ( ) ; return ! isMatchingVariableName && ! isMatchingCommentContent ; } private static boolean isEmptyCatchBlock ( DetailAST catchAst ) { boolean result = true ; final DetailAST slistToken = catchAst . findFirstToken ( TokenTypes . SLIST ) ; DetailAST catchBlockStmt = slistToken . getFirstChild ( ) ; while ( catchBlockStmt . getType ( ) != TokenTypes . RCURLY ) { if ( catchBlockStmt . getType ( ) != TokenTypes . SINGLE_LINE_COMMENT && catchBlockStmt . getType ( ) != TokenTypes . BLOCK_COMMENT_BEGIN ) { result = false ; break ; } catchBlockStmt = catchBlockStmt . getNextSibling ( ) ; } return result ; } private static String getExceptionVariableName ( DetailAST catchAst ) { final DetailAST parameterDef = catchAst . findFirstToken ( TokenTypes . PARAMETER_DEF ) ; final DetailAST variableName = parameterDef . findFirstToken ( TokenTypes . IDENT ) ; return variableName . getText ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . blocks ;
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . EmptyForIteratorPadCheck . WS_FOLLOWED ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . EmptyForIteratorPadCheck . WS_NOT_FOLLOWED ; public class EmptyForIteratorPadCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( EmptyForIteratorPadCheck . class ) ; } @ Test public void testDefault ( ) throws Exception { final String [ ] expected = { "27:31: " + getCheckMessage ( WS_FOLLOWED , ";" ) , "43:32: " + getCheckMessage ( WS_FOLLOWED , ";" ) , } ; verify ( checkConfig , getPath ( "InputForWhitespace.java" ) , expected ) ; } @ Test public void testSpaceOption ( ) throws Exception { checkConfig . addAttribute ( "option" , PadOption . SPACE . toString ( ) ) ; final String [ ] expected = { "23:31: " + getCheckMessage ( WS_NOT_FOLLOWED , ";" ) , } ; verify ( checkConfig , getPath ( "InputForWhitespace.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . blocks ; public enum RightCurlyOption { ALONE , SAME }
package com . puppycrawl . tools . checkstyle . checks . blocks ; public enum BlockOption { TEXT , STMT }
package com . puppycrawl . tools . checkstyle . checks . blocks ; public enum LeftCurlyOption { EOL , NLOW , NL }
package com . puppycrawl . tools . checkstyle . checks . blocks ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class AvoidNestedBlocksCheck extends Check { public static final String MSG_KEY_BLOCK_NESTED = "block.nested" ; private boolean allowInSwitchCase ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . SLIST } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . SLIST } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST parent = ast . getParent ( ) ; if ( parent . getType ( ) == TokenTypes . SLIST ) { if ( allowInSwitchCase && parent . getParent ( ) . getType ( ) == TokenTypes . CASE_GROUP && parent . getNumberOfChildren ( ) == 1 ) { return ; } log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY_BLOCK_NESTED ) ; } } public void setAllowInSwitchCase ( boolean allowInSwitchCase ) { this . allowInSwitchCase = allowInSwitchCase ; } }
package com . puppycrawl . tools . checkstyle . checks . blocks ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . checks . AbstractOptionCheck ; public class LeftCurlyCheck extends AbstractOptionCheck < LeftCurlyOption > { public static final String MSG_KEY_LINE_NEW = "line.new" ; public static final String MSG_KEY_LINE_PREVIOUS = "line.previous" ; public static final String MSG_KEY_LINE_BREAK_AFTER = "line.break.after" ; private static final int DEFAULT_MAX_LINE_LENGTH = 80 ; private int maxLineLength = DEFAULT_MAX_LINE_LENGTH ; private boolean ignoreEnums = true ; public LeftCurlyCheck ( ) { super ( LeftCurlyOption . EOL , LeftCurlyOption . class ) ; } public void setMaxLineLength ( int maxLineLength ) { this . maxLineLength = maxLineLength ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . INTERFACE_DEF , TokenTypes . CLASS_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . ENUM_DEF , TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . LITERAL_WHILE , TokenTypes . LITERAL_TRY , TokenTypes . LITERAL_CATCH , TokenTypes . LITERAL_FINALLY , TokenTypes . LITERAL_SYNCHRONIZED , TokenTypes . LITERAL_SWITCH , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_ELSE , TokenTypes . LITERAL_FOR , TokenTypes . STATIC_INIT , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . INTERFACE_DEF , TokenTypes . CLASS_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . ENUM_DEF , TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . LITERAL_WHILE , TokenTypes . LITERAL_TRY , TokenTypes . LITERAL_CATCH , TokenTypes . LITERAL_FINALLY , TokenTypes . LITERAL_SYNCHRONIZED , TokenTypes . LITERAL_SWITCH , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_ELSE , TokenTypes . LITERAL_FOR , TokenTypes . STATIC_INIT , } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST startToken ; final DetailAST brace ; switch ( ast . getType ( ) ) { case TokenTypes . CTOR_DEF : case TokenTypes . METHOD_DEF : startToken = skipAnnotationOnlyLines ( ast ) ; brace = ast . findFirstToken ( TokenTypes . SLIST ) ; break ; case TokenTypes . INTERFACE_DEF : case TokenTypes . CLASS_DEF : case TokenTypes . ANNOTATION_DEF : case TokenTypes . ENUM_DEF : case TokenTypes . ENUM_CONSTANT_DEF : startToken = skipAnnotationOnlyLines ( ast ) ; final DetailAST objBlock = ast . findFirstToken ( TokenTypes . OBJBLOCK ) ; brace = objBlock == null ? null : objBlock . getFirstChild ( ) ; break ; case TokenTypes . LITERAL_WHILE : case TokenTypes . LITERAL_CATCH : case TokenTypes . LITERAL_SYNCHRONIZED : case TokenTypes . LITERAL_FOR : case TokenTypes . LITERAL_TRY : case TokenTypes . LITERAL_FINALLY : case TokenTypes . LITERAL_DO : case TokenTypes . LITERAL_IF : case TokenTypes . STATIC_INIT : startToken = ast ; brace = ast . findFirstToken ( TokenTypes . SLIST ) ; break ; case TokenTypes . LITERAL_ELSE : startToken = ast ; final DetailAST candidate = ast . getFirstChild ( ) ; brace = candidate . getType ( ) == TokenTypes . SLIST ? candidate : null ; break ; case TokenTypes . LITERAL_SWITCH : startToken = ast ; brace = ast . findFirstToken ( TokenTypes . LCURLY ) ; break ; default : startToken = null ; brace = null ; } if ( brace != null && startToken != null ) { verifyBrace ( brace , startToken ) ; } } private DetailAST skipAnnotationOnlyLines ( DetailAST ast ) { final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( modifiers == null ) { return ast ; } DetailAST lastAnnot = findLastAnnotation ( modifiers ) ; if ( lastAnnot == null ) { return ast ; } final DetailAST tokenAfterLast = lastAnnot . getNextSibling ( ) != null ? lastAnnot . getNextSibling ( ) : modifiers . getNextSibling ( ) ; if ( tokenAfterLast . getLineNo ( ) > lastAnnot . getLineNo ( ) ) { return tokenAfterLast ; } final int lastAnnotLineNumber = lastAnnot . getLineNo ( ) ; while ( lastAnnot . getPreviousSibling ( ) != null && lastAnnot . getPreviousSibling ( ) . getLineNo ( ) == lastAnnotLineNumber ) { lastAnnot = lastAnnot . getPreviousSibling ( ) ; } return lastAnnot ; } private DetailAST findLastAnnotation ( DetailAST modifiers ) { DetailAST annot = modifiers . findFirstToken ( TokenTypes . ANNOTATION ) ; while ( annot != null && annot . getNextSibling ( ) != null && annot . getNextSibling ( ) . getType ( ) == TokenTypes . ANNOTATION ) { annot = annot . getNextSibling ( ) ; } return annot ; } private void verifyBrace ( final DetailAST brace , final DetailAST startToken ) { final String braceLine = getLine ( brace . getLineNo ( ) - 1 ) ; final int prevLineLen = brace . getLineNo ( ) == 1 ? maxLineLength : Utils . lengthMinusTrailingWhitespace ( getLine ( brace . getLineNo ( ) - 2 ) ) ; if ( braceLine . length ( ) <= brace . getColumnNo ( ) + 1 || braceLine . charAt ( brace . getColumnNo ( ) + 1 ) != '}' ) { if ( getAbstractOption ( ) == LeftCurlyOption . NL ) { if ( ! Utils . whitespaceBefore ( brace . getColumnNo ( ) , braceLine ) ) { log ( brace . getLineNo ( ) , brace . getColumnNo ( ) , MSG_KEY_LINE_NEW , "{" ) ; } } else if ( getAbstractOption ( ) == LeftCurlyOption . EOL ) { validateEol ( brace , braceLine , prevLineLen ) ; } else if ( getAbstractOption ( ) == LeftCurlyOption . NLOW && startToken . getLineNo ( ) != brace . getLineNo ( ) ) { validateNewLinePosion ( brace , startToken , braceLine , prevLineLen ) ; } } } private void validateEol ( DetailAST brace , String braceLine , int prevLineLen ) { if ( Utils . whitespaceBefore ( brace . getColumnNo ( ) , braceLine ) && prevLineLen + 2 <= maxLineLength ) { log ( brace . getLineNo ( ) , brace . getColumnNo ( ) , MSG_KEY_LINE_PREVIOUS , "{" ) ; } if ( ! hasLineBreakAfter ( brace ) ) { log ( brace . getLineNo ( ) , brace . getColumnNo ( ) , MSG_KEY_LINE_BREAK_AFTER ) ; } } private void validateNewLinePosion ( DetailAST brace , DetailAST startToken , String braceLine , int prevLineLen ) { if ( startToken . getLineNo ( ) + 1 == brace . getLineNo ( ) ) { if ( ! Utils . whitespaceBefore ( brace . getColumnNo ( ) , braceLine ) ) { log ( brace . getLineNo ( ) , brace . getColumnNo ( ) , MSG_KEY_LINE_NEW , "{" ) ; } else if ( prevLineLen + 2 <= maxLineLength ) { log ( brace . getLineNo ( ) , brace . getColumnNo ( ) , MSG_KEY_LINE_PREVIOUS , "{" ) ; } } else if ( ! Utils . whitespaceBefore ( brace . getColumnNo ( ) , braceLine ) ) { log ( brace . getLineNo ( ) , brace . getColumnNo ( ) , MSG_KEY_LINE_NEW , "{" ) ; } } private boolean hasLineBreakAfter ( DetailAST leftCurly ) { DetailAST nextToken = null ; if ( leftCurly . getType ( ) == TokenTypes . SLIST ) { nextToken = leftCurly . getFirstChild ( ) ; } else { if ( leftCurly . getParent ( ) . getParent ( ) . getType ( ) == TokenTypes . ENUM_DEF && ! ignoreEnums ) { nextToken = leftCurly . getNextSibling ( ) ; } } return nextToken == null || nextToken . getType ( ) == TokenTypes . RCURLY || leftCurly . getLineNo ( ) != nextToken . getLineNo ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . blocks ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . checks . AbstractOptionCheck ; import com . puppycrawl . tools . checkstyle . checks . CheckUtils ; public class RightCurlyCheck extends AbstractOptionCheck < RightCurlyOption > { public static final String MSG_KEY_LINE_BREAK_BEFORE = "line.break.before" ; public static final String MSG_KEY_LINE_ALONE = "line.alone" ; public static final String MSG_KEY_LINE_SAME = "line.same" ; public static final String MSG_KEY_LINE_NEW = "line.new" ; private boolean shouldStartLine = true ; public RightCurlyCheck ( ) { super ( RightCurlyOption . SAME , RightCurlyOption . class ) ; } public void setShouldStartLine ( boolean flag ) { shouldStartLine = flag ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_TRY , TokenTypes . LITERAL_CATCH , TokenTypes . LITERAL_FINALLY , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_ELSE , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . LITERAL_TRY , TokenTypes . LITERAL_CATCH , TokenTypes . LITERAL_FINALLY , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_ELSE , TokenTypes . CLASS_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . LITERAL_FOR , TokenTypes . LITERAL_WHILE , TokenTypes . LITERAL_DO , TokenTypes . STATIC_INIT , TokenTypes . INSTANCE_INIT , } ; } @ Override public void visitToken ( DetailAST ast ) { final Details details = getDetails ( ast ) ; final DetailAST rcurly = details . rcurly ; if ( rcurly == null || rcurly . getType ( ) != TokenTypes . RCURLY ) { return ; } final DetailAST lcurly = details . lcurly ; validate ( details , rcurly , lcurly ) ; if ( ! shouldStartLine ) { return ; } final boolean startsLine = Utils . whitespaceBefore ( rcurly . getColumnNo ( ) , getLines ( ) [ rcurly . getLineNo ( ) - 1 ] ) ; if ( ! startsLine && lcurly . getLineNo ( ) != rcurly . getLineNo ( ) ) { log ( rcurly , MSG_KEY_LINE_NEW , "}" ) ; } } private void validate ( Details details , DetailAST rcurly , DetailAST lcurly ) { final DetailAST nextToken = details . nextToken ; final boolean shouldCheckLastRcurly = details . shouldCheckLastRcurly ; if ( getAbstractOption ( ) == RightCurlyOption . SAME && ! hasLineBreakBefore ( rcurly ) ) { log ( rcurly , MSG_KEY_LINE_BREAK_BEFORE ) ; } if ( shouldCheckLastRcurly ) { if ( rcurly . getLineNo ( ) == nextToken . getLineNo ( ) ) { log ( rcurly , MSG_KEY_LINE_ALONE , "}" ) ; } } else if ( getAbstractOption ( ) == RightCurlyOption . SAME && rcurly . getLineNo ( ) != nextToken . getLineNo ( ) ) { log ( rcurly , MSG_KEY_LINE_SAME , "}" ) ; } else if ( getAbstractOption ( ) == RightCurlyOption . ALONE && rcurly . getLineNo ( ) == nextToken . getLineNo ( ) && ! isEmptyBody ( lcurly ) ) { log ( rcurly , MSG_KEY_LINE_ALONE , "}" ) ; } } private Details getDetails ( DetailAST ast ) { boolean shouldCheckLastRcurly = false ; DetailAST rcurly = null ; DetailAST lcurly = null ; DetailAST nextToken = null ; switch ( ast . getType ( ) ) { case TokenTypes . LITERAL_TRY : lcurly = ast . getFirstChild ( ) ; nextToken = lcurly . getNextSibling ( ) ; rcurly = lcurly . getLastChild ( ) ; break ; case TokenTypes . LITERAL_CATCH : nextToken = ast . getNextSibling ( ) ; lcurly = ast . getLastChild ( ) ; rcurly = lcurly . getLastChild ( ) ; if ( nextToken == null ) { shouldCheckLastRcurly = true ; nextToken = getNextToken ( ast ) ; } break ; case TokenTypes . LITERAL_IF : nextToken = ast . findFirstToken ( TokenTypes . LITERAL_ELSE ) ; if ( nextToken != null ) { lcurly = nextToken . getPreviousSibling ( ) ; rcurly = lcurly . getLastChild ( ) ; } else { shouldCheckLastRcurly = true ; nextToken = getNextToken ( ast ) ; lcurly = ast . getLastChild ( ) ; rcurly = lcurly . getLastChild ( ) ; } break ; case TokenTypes . LITERAL_ELSE : case TokenTypes . LITERAL_FINALLY : shouldCheckLastRcurly = true ; nextToken = getNextToken ( ast ) ; lcurly = ast . getFirstChild ( ) ; rcurly = lcurly . getLastChild ( ) ; break ; case TokenTypes . CLASS_DEF : final DetailAST child = ast . getLastChild ( ) ; lcurly = child . getFirstChild ( ) ; rcurly = child . getLastChild ( ) ; nextToken = ast ; break ; case TokenTypes . CTOR_DEF : case TokenTypes . STATIC_INIT : case TokenTypes . INSTANCE_INIT : lcurly = ast . findFirstToken ( TokenTypes . SLIST ) ; rcurly = lcurly . getLastChild ( ) ; nextToken = ast ; break ; case TokenTypes . METHOD_DEF : case TokenTypes . LITERAL_FOR : case TokenTypes . LITERAL_WHILE : case TokenTypes . LITERAL_DO : lcurly = ast . findFirstToken ( TokenTypes . SLIST ) ; if ( lcurly != null ) { rcurly = lcurly . getLastChild ( ) ; } nextToken = lcurly ; break ; default : throw new IllegalStateException ( "Unexpected token type (" + Utils . getTokenName ( ast . getType ( ) ) + ")" ) ; } final Details details = new Details ( ) ; details . rcurly = rcurly ; details . lcurly = lcurly ; details . nextToken = nextToken ; details . shouldCheckLastRcurly = shouldCheckLastRcurly ; return details ; } private boolean isEmptyBody ( DetailAST lcurly ) { boolean result = false ; if ( lcurly . getParent ( ) . getType ( ) == TokenTypes . OBJBLOCK ) { if ( lcurly . getNextSibling ( ) . getType ( ) == TokenTypes . RCURLY ) { result = true ; } } else if ( lcurly . getFirstChild ( ) . getType ( ) == TokenTypes . RCURLY ) { result = true ; } return result ; } private DetailAST getNextToken ( DetailAST ast ) { DetailAST next = null ; DetailAST parent = ast ; while ( parent != null && next == null ) { next = parent . getNextSibling ( ) ; parent = parent . getParent ( ) ; } return CheckUtils . getFirstNode ( next ) ; } private boolean hasLineBreakBefore ( DetailAST rightCurly ) { if ( rightCurly != null ) { final DetailAST previousToken = rightCurly . getPreviousSibling ( ) ; if ( previousToken != null && rightCurly . getLineNo ( ) == previousToken . getLineNo ( ) ) { return false ; } } return true ; } static class Details { private DetailAST rcurly ; private DetailAST lcurly ; private DetailAST nextToken ; private boolean shouldCheckLastRcurly ; } }
package com . puppycrawl . tools . checkstyle . checks . blocks ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class NeedBracesCheck extends Check { public static final String MSG_KEY_NEED_BRACES = "needBraces" ; private boolean allowSingleLineStatement ; public void setAllowSingleLineStatement ( boolean allowSingleLineStatement ) { this . allowSingleLineStatement = allowSingleLineStatement ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_DO , TokenTypes . LITERAL_ELSE , TokenTypes . LITERAL_FOR , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_WHILE , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . LITERAL_DO , TokenTypes . LITERAL_ELSE , TokenTypes . LITERAL_FOR , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_WHILE , TokenTypes . LITERAL_CASE , TokenTypes . LITERAL_DEFAULT , TokenTypes . LAMBDA , } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST slistAST = ast . findFirstToken ( TokenTypes . SLIST ) ; boolean isElseIf = false ; if ( ast . getType ( ) == TokenTypes . LITERAL_ELSE && ast . findFirstToken ( TokenTypes . LITERAL_IF ) != null ) { isElseIf = true ; } final boolean skipStatement = isSkipStatement ( ast ) ; if ( slistAST == null && ! isElseIf && ! skipStatement ) { log ( ast . getLineNo ( ) , MSG_KEY_NEED_BRACES , ast . getText ( ) ) ; } } private boolean isSkipStatement ( DetailAST statement ) { return allowSingleLineStatement && isSingleLineStatement ( statement ) ; } private static boolean isSingleLineStatement ( DetailAST statement ) { boolean result = false ; switch ( statement . getType ( ) ) { case TokenTypes . LITERAL_IF : result = isSingleLineIf ( statement ) ; break ; case TokenTypes . LITERAL_FOR : result = isSingleLineFor ( statement ) ; break ; case TokenTypes . LITERAL_DO : result = isSingleLineDoWhile ( statement ) ; break ; case TokenTypes . LITERAL_WHILE : result = isSingleLineWhile ( statement ) ; break ; case TokenTypes . LAMBDA : result = isSingleLineLambda ( statement ) ; break ; case TokenTypes . LITERAL_CASE : result = isSingleLineCase ( statement ) ; break ; case TokenTypes . LITERAL_DEFAULT : result = isSingleLineDefault ( statement ) ; break ; case TokenTypes . LITERAL_ELSE : result = isSingleLineElse ( statement ) ; break ; default : final String exceptionMsg = statement . getText ( ) ; throw new IllegalArgumentException ( "Unsupported token: " + exceptionMsg ) ; } return result ; } private static boolean isSingleLineWhile ( DetailAST literalWhile ) { boolean result = false ; if ( literalWhile . getParent ( ) . getType ( ) == TokenTypes . SLIST && literalWhile . getLastChild ( ) . getType ( ) != TokenTypes . SLIST ) { final DetailAST block = literalWhile . getLastChild ( ) . getPreviousSibling ( ) ; result = literalWhile . getLineNo ( ) == block . getLineNo ( ) ; } return result ; } private static boolean isSingleLineDoWhile ( DetailAST literalDo ) { boolean result = false ; if ( literalDo . getParent ( ) . getType ( ) == TokenTypes . SLIST && literalDo . getFirstChild ( ) . getType ( ) != TokenTypes . SLIST ) { final DetailAST block = literalDo . getFirstChild ( ) ; result = block . getLineNo ( ) == literalDo . getLineNo ( ) ; } return result ; } private static boolean isSingleLineFor ( DetailAST literalFor ) { boolean result = false ; if ( literalFor . getLastChild ( ) . getType ( ) == TokenTypes . EMPTY_STAT ) { result = true ; } else if ( literalFor . getParent ( ) . getType ( ) == TokenTypes . SLIST && literalFor . getLastChild ( ) . getType ( ) != TokenTypes . SLIST ) { final DetailAST block = literalFor . findFirstToken ( TokenTypes . EXPR ) ; if ( block != null ) { result = literalFor . getLineNo ( ) == block . getLineNo ( ) ; } } return result ; } private static boolean isSingleLineIf ( DetailAST literalIf ) { boolean result = false ; final DetailAST ifCondition = literalIf . findFirstToken ( TokenTypes . EXPR ) ; if ( literalIf . getParent ( ) . getType ( ) == TokenTypes . SLIST ) { final DetailAST literalIfLastChild = literalIf . getLastChild ( ) ; final DetailAST block ; if ( literalIfLastChild . getType ( ) == TokenTypes . LITERAL_ELSE ) { block = literalIfLastChild . getPreviousSibling ( ) ; } else { block = literalIfLastChild ; } result = ifCondition . getLineNo ( ) == block . getLineNo ( ) ; } return result ; } private static boolean isSingleLineLambda ( DetailAST lambda ) { boolean result = false ; final DetailAST block = lambda . getLastChild ( ) ; if ( block . getType ( ) != TokenTypes . SLIST ) { result = lambda . getLineNo ( ) == block . getLineNo ( ) ; } return result ; } private static boolean isSingleLineCase ( DetailAST literalCase ) { boolean result = false ; final DetailAST slist = literalCase . getNextSibling ( ) ; final DetailAST block = slist . getFirstChild ( ) ; if ( block . getType ( ) != TokenTypes . SLIST ) { final DetailAST caseBreak = slist . findFirstToken ( TokenTypes . LITERAL_BREAK ) ; final boolean atOneLine = literalCase . getLineNo ( ) == block . getLineNo ( ) ; if ( caseBreak != null ) { result = atOneLine && block . getLineNo ( ) == caseBreak . getLineNo ( ) ; } } return result ; } private static boolean isSingleLineDefault ( DetailAST literalDefault ) { boolean result = false ; final DetailAST slist = literalDefault . getNextSibling ( ) ; final DetailAST block = slist . getFirstChild ( ) ; if ( block . getType ( ) != TokenTypes . SLIST ) { result = literalDefault . getLineNo ( ) == block . getLineNo ( ) ; } return result ; } private static boolean isSingleLineElse ( DetailAST literalElse ) { boolean result = false ; final DetailAST block = literalElse . getFirstChild ( ) ; if ( block . getType ( ) != TokenTypes . SLIST ) { result = literalElse . getLineNo ( ) == block . getLineNo ( ) ; } return result ; } }
package com . puppycrawl . tools . checkstyle . checks . blocks ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . AbstractOptionCheck ; import org . apache . commons . lang3 . StringUtils ; public class EmptyBlockCheck extends AbstractOptionCheck < BlockOption > { public static final String MSG_KEY_BLOCK_NO_STMT = "block.noStmt" ; public static final String MSG_KEY_BLOCK_EMPTY = "block.empty" ; public EmptyBlockCheck ( ) { super ( BlockOption . STMT , BlockOption . class ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_WHILE , TokenTypes . LITERAL_TRY , TokenTypes . LITERAL_FINALLY , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_ELSE , TokenTypes . LITERAL_FOR , TokenTypes . INSTANCE_INIT , TokenTypes . STATIC_INIT , TokenTypes . LITERAL_SWITCH , TokenTypes . LITERAL_SYNCHRONIZED , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . LITERAL_WHILE , TokenTypes . LITERAL_TRY , TokenTypes . LITERAL_CATCH , TokenTypes . LITERAL_FINALLY , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_ELSE , TokenTypes . LITERAL_FOR , TokenTypes . INSTANCE_INIT , TokenTypes . STATIC_INIT , TokenTypes . LITERAL_SWITCH , TokenTypes . LITERAL_SYNCHRONIZED , TokenTypes . LITERAL_CASE , TokenTypes . LITERAL_DEFAULT , TokenTypes . ARRAY_INIT , } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST slistToken = ast . findFirstToken ( TokenTypes . SLIST ) ; final DetailAST leftCurly = slistToken != null ? slistToken : ast . findFirstToken ( TokenTypes . LCURLY ) ; if ( leftCurly != null ) { if ( getAbstractOption ( ) == BlockOption . STMT ) { boolean emptyBlock ; if ( leftCurly . getType ( ) == TokenTypes . LCURLY ) { emptyBlock = leftCurly . getNextSibling ( ) . getType ( ) != TokenTypes . CASE_GROUP ; } else { emptyBlock = leftCurly . getChildCount ( ) <= 1 ; } if ( emptyBlock ) { log ( leftCurly . getLineNo ( ) , leftCurly . getColumnNo ( ) , MSG_KEY_BLOCK_NO_STMT , ast . getText ( ) ) ; } } else if ( getAbstractOption ( ) == BlockOption . TEXT && ! hasText ( leftCurly ) ) { log ( leftCurly . getLineNo ( ) , leftCurly . getColumnNo ( ) , MSG_KEY_BLOCK_EMPTY , ast . getText ( ) ) ; } } } protected boolean hasText ( final DetailAST slistAST ) { boolean retVal = false ; final DetailAST rightCurly = slistAST . findFirstToken ( TokenTypes . RCURLY ) ; final DetailAST rcurlyAST = rightCurly != null ? rightCurly : slistAST . getParent ( ) . findFirstToken ( TokenTypes . RCURLY ) ; if ( rcurlyAST != null ) { final int slistLineNo = slistAST . getLineNo ( ) ; final int slistColNo = slistAST . getColumnNo ( ) ; final int rcurlyLineNo = rcurlyAST . getLineNo ( ) ; final int rcurlyColNo = rcurlyAST . getColumnNo ( ) ; final String [ ] lines = getLines ( ) ; if ( slistLineNo == rcurlyLineNo ) { final String txt = lines [ slistLineNo - 1 ] . substring ( slistColNo + 1 , rcurlyColNo ) ; if ( StringUtils . isNotBlank ( txt ) ) { retVal = true ; } } else { if ( lines [ slistLineNo - 1 ] . substring ( slistColNo + 1 ) . trim ( ) . length ( ) != 0 || lines [ rcurlyLineNo - 1 ] . substring ( 0 , rcurlyColNo ) . trim ( ) . length ( ) != 0 ) { retVal = true ; } else { for ( int i = slistLineNo ; i < rcurlyLineNo - 1 ; i ++ ) { if ( lines [ i ] . trim ( ) . length ( ) > 0 ) { retVal = true ; break ; } } } } } return retVal ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ClassTypeParameterNameCheck extends AbstractTypeParameterNameCheck { public ClassTypeParameterNameCheck ( ) { super ( "^[A-Z]$" ) ; } @ Override protected final int getLocation ( ) { return TokenTypes . CLASS_DEF ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class LocalFinalVariableNameCheck extends AbstractNameCheck { public LocalFinalVariableNameCheck ( ) { super ( "^[a-z][a-zA-Z0-9]*$" ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . PARAMETER_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . PARAMETER_DEF , } ; } @ Override protected final boolean mustCheckName ( DetailAST ast ) { final DetailAST modifiersAST = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; final boolean isFinal = modifiersAST . branchContains ( TokenTypes . FINAL ) ; return isFinal && ScopeUtils . isLocalVariableDef ( ast ) ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . WhitespaceAfterCheck . WS_NOT_FOLLOWED ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . WhitespaceAfterCheck . WS_TYPECAST ; public class WhitespaceAfterCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( WhitespaceAfterCheck . class ) ; } @ Test public void testDefault ( ) throws Exception { final String [ ] expected = { "42:40: " + getCheckMessage ( WS_NOT_FOLLOWED , "," ) , "71:30: " + getCheckMessage ( WS_NOT_FOLLOWED , "," ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testCast ( ) throws Exception { final String [ ] expected = { "88:21: " + getCheckMessage ( WS_TYPECAST ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void testSemi ( ) throws Exception { final String [ ] expected = { "58:23: " + getCheckMessage ( WS_NOT_FOLLOWED , ";" ) , "58:29: " + getCheckMessage ( WS_NOT_FOLLOWED , ";" ) , "107:19: " + getCheckMessage ( WS_NOT_FOLLOWED , ";" ) , } ; verify ( checkConfig , getPath ( "InputBraces.java" ) , expected ) ; } @ Test public void testEmptyForIterator ( ) throws Exception { final String [ ] expected = { "14:31: " + getCheckMessage ( WS_NOT_FOLLOWED , ";" ) , "17:31: " + getCheckMessage ( WS_NOT_FOLLOWED , ";" ) , } ; verify ( checkConfig , getPath ( "InputForWhitespace.java" ) , expected ) ; } @ Test public void testTypeArgumentAndParameterCommas ( ) throws Exception { final String [ ] expected = { "11:21: " + getCheckMessage ( WS_NOT_FOLLOWED , "," ) , "11:23: " + getCheckMessage ( WS_NOT_FOLLOWED , "," ) , "11:41: " + getCheckMessage ( WS_NOT_FOLLOWED , "," ) , } ; verify ( checkConfig , getPath ( "InputGenerics.java" ) , expected ) ; } @ Test public void test1322879 ( ) throws Exception { final String [ ] expected = { } ; verify ( checkConfig , getPath ( "whitespace/InputWhitespaceAround.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ;
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ParameterNameCheck extends AbstractNameCheck { public ParameterNameCheck ( ) { super ( "^[a-z][a-zA-Z0-9]*$" ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . PARAMETER_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . PARAMETER_DEF } ; } @ Override protected boolean mustCheckName ( DetailAST ast ) { return ast . getParent ( ) . getType ( ) != TokenTypes . LITERAL_CATCH ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import java . util . regex . Pattern ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class LocalVariableNameCheck extends AbstractNameCheck { private static Pattern sSingleChar = Pattern . compile ( "^[a-z]$" ) ; private boolean allowOneCharVarInForLoop ; public LocalVariableNameCheck ( ) { super ( "^[a-z][a-zA-Z0-9]*$" ) ; } public final void setAllowOneCharVarInForLoop ( boolean allow ) { allowOneCharVarInForLoop = allow ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . PARAMETER_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . PARAMETER_DEF , } ; } @ Override protected final boolean mustCheckName ( DetailAST ast ) { if ( allowOneCharVarInForLoop && isForLoopVariable ( ast ) ) { final String variableName = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; return ! sSingleChar . matcher ( variableName ) . find ( ) ; } final DetailAST modifiersAST = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; final boolean isFinal = modifiersAST . branchContains ( TokenTypes . FINAL ) ; return ! isFinal && ScopeUtils . isLocalVariableDef ( ast ) ; } private boolean isForLoopVariable ( DetailAST variableDef ) { final int parentType = variableDef . getParent ( ) . getType ( ) ; return parentType == TokenTypes . FOR_INIT || parentType == TokenTypes . FOR_EACH_CLAUSE ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ConstantNameCheck extends AbstractAccessControlNameCheck { public ConstantNameCheck ( ) { super ( "^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$" ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF } ; } @ Override protected final boolean mustCheckName ( DetailAST ast ) { boolean retVal = false ; final DetailAST modifiersAST = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; final boolean isStatic = modifiersAST . branchContains ( TokenTypes . LITERAL_STATIC ) ; final boolean isFinal = modifiersAST . branchContains ( TokenTypes . FINAL ) ; if ( isStatic && isFinal && shouldCheckInScope ( modifiersAST ) || ScopeUtils . inAnnotationBlock ( ast ) || ScopeUtils . inInterfaceOrAnnotationBlock ( ast ) && ! ScopeUtils . inCodeBlock ( ast ) ) { final DetailAST nameAST = ast . findFirstToken ( TokenTypes . IDENT ) ; if ( ! "serialVersionUID" . equals ( nameAST . getText ( ) ) && ! "serialPersistentFields" . equals ( nameAST . getText ( ) ) ) { retVal = true ; } } return retVal ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . AbstractFormatCheck ; public final class AbstractClassNameCheck extends AbstractFormatCheck { public static final String ILLEGAL_ABSTRACT_CLASS_NAME = "illegal.abstract.class.name" ; public static final String NO_ABSTRACT_CLASS_MODIFIER = "no.abstract.class.modifier" ; private static final String DEFAULT_FORMAT = "^Abstract.+$" ; private boolean ignoreModifier ; private boolean ignoreName ; public AbstractClassNameCheck ( ) { super ( DEFAULT_FORMAT ) ; } public void setIgnoreModifier ( boolean value ) { ignoreModifier = value ; } public void setIgnoreName ( boolean value ) { ignoreName = value ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF } ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF } ; } @ Override public void visitToken ( DetailAST ast ) { visitClassDef ( ast ) ; } private void visitClassDef ( DetailAST ast ) { final String className = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; if ( isAbstract ( ast ) ) { if ( ! ignoreName && ! isMatchingClassName ( className ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , ILLEGAL_ABSTRACT_CLASS_NAME , className , getFormat ( ) ) ; } } else if ( ! ignoreModifier && isMatchingClassName ( className ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , NO_ABSTRACT_CLASS_MODIFIER , className ) ; } } private boolean isAbstract ( DetailAST ast ) { final DetailAST abstractAST = ast . findFirstToken ( TokenTypes . MODIFIERS ) . findFirstToken ( TokenTypes . ABSTRACT ) ; return abstractAST != null ; } private boolean isMatchingClassName ( String className ) { return getRegexp ( ) . matcher ( className ) . find ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class StaticVariableNameCheck extends AbstractAccessControlNameCheck { public StaticVariableNameCheck ( ) { super ( "^[a-z][a-zA-Z0-9]*$" ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF } ; } @ Override protected final boolean mustCheckName ( DetailAST ast ) { final DetailAST modifiersAST = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; final boolean isStatic = modifiersAST . branchContains ( TokenTypes . LITERAL_STATIC ) ; final boolean isFinal = modifiersAST . branchContains ( TokenTypes . FINAL ) ; return isStatic && ! isFinal && shouldCheckInScope ( modifiersAST ) && ! ScopeUtils . inInterfaceOrAnnotationBlock ( ast ) ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public abstract class AbstractAccessControlNameCheck extends AbstractNameCheck { private boolean applyToPublic = true ; private boolean applyToProtected = true ; private boolean applyToPackage = true ; private boolean applyToPrivate = true ; public AbstractAccessControlNameCheck ( String format ) { super ( format ) ; } @ Override protected boolean mustCheckName ( DetailAST ast ) { return shouldCheckInScope ( ast ) ; } protected boolean shouldCheckInScope ( DetailAST modifiers ) { final boolean isPublic = modifiers . branchContains ( TokenTypes . LITERAL_PUBLIC ) ; final boolean isProtected = modifiers . branchContains ( TokenTypes . LITERAL_PROTECTED ) ; final boolean isPrivate = modifiers . branchContains ( TokenTypes . LITERAL_PRIVATE ) ; final boolean isPackage = ! ( isPublic || isProtected || isPrivate ) ; return applyToPublic && isPublic || applyToProtected && isProtected || applyToPackage && isPackage || applyToPrivate && isPrivate ; } public void setApplyToPublic ( boolean applyTo ) { applyToPublic = applyTo ; } public void setApplyToProtected ( boolean applyTo ) { applyToProtected = applyTo ; } public void setApplyToPackage ( boolean applyTo ) { applyToPackage = applyTo ; } public void setApplyToPrivate ( boolean applyTo ) { applyToPrivate = applyTo ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class InterfaceTypeParameterNameCheck extends AbstractTypeParameterNameCheck { public InterfaceTypeParameterNameCheck ( ) { super ( "^[A-Z]$" ) ; } @ Override protected final int getLocation ( ) { return TokenTypes . INTERFACE_DEF ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . AnnotationUtility ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class MethodNameCheck extends AbstractAccessControlNameCheck { public static final String MSG_KEY = "method.name.equals.class.name" ; private static final String OVERRIDE = "Override" ; private static final String CANONICAL_OVERRIDE = "java.lang." + OVERRIDE ; private boolean allowClassName ; public MethodNameCheck ( ) { super ( "^[a-z][a-zA-Z0-9]*$" ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( ! AnnotationUtility . containsAnnotation ( ast , OVERRIDE ) && ! AnnotationUtility . containsAnnotation ( ast , CANONICAL_OVERRIDE ) ) { super . visitToken ( ast ) ; } if ( ! allowClassName ) { final DetailAST method = ast . findFirstToken ( TokenTypes . IDENT ) ; final DetailAST classDefOrNew = ast . getParent ( ) . getParent ( ) ; final DetailAST classIdent = classDefOrNew . findFirstToken ( TokenTypes . IDENT ) ; if ( null != classIdent && method . getText ( ) . equals ( classIdent . getText ( ) ) ) { log ( method . getLineNo ( ) , method . getColumnNo ( ) , MSG_KEY , method . getText ( ) ) ; } } } public void setAllowClassName ( boolean allowClassName ) { this . allowClassName = allowClassName ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public abstract class AbstractTypeParameterNameCheck extends AbstractNameCheck { public AbstractTypeParameterNameCheck ( String format ) { super ( format ) ; } @ Override public final int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . TYPE_PARAMETER , } ; } @ Override public final int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . TYPE_PARAMETER , } ; } @ Override protected final boolean mustCheckName ( DetailAST ast ) { final DetailAST location = ast . getParent ( ) . getParent ( ) ; return location . getType ( ) == getLocation ( ) ; } protected abstract int getLocation ( ) ; }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . google . common . collect . Maps ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import java . io . File ; import java . util . Map ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . GenericWhitespaceCheck . WS_FOLLOWED ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . GenericWhitespaceCheck . WS_ILLEGAL_FOLLOW ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . GenericWhitespaceCheck . WS_NOT_PRECEDED ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . GenericWhitespaceCheck . WS_PRECEDED ; public class GenericWhitespaceCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( GenericWhitespaceCheck . class ) ; Map < Class < ? > , Integer > x = Maps . newHashMap ( ) ; for ( final Map . Entry < Class < ? > , Integer > entry : x . entrySet ( ) ) { entry . getValue ( ) ; } } @ Test public void testDefault ( ) throws Exception { final String [ ] expected = { "16:13: " + getCheckMessage ( WS_PRECEDED , "<" ) , "16:15: " + getCheckMessage ( WS_FOLLOWED , "<" ) , "16:23: " + getCheckMessage ( WS_PRECEDED , ">" ) , "16:43: " + getCheckMessage ( WS_PRECEDED , "<" ) , "16:45: " + getCheckMessage ( WS_FOLLOWED , "<" ) , "16:53: " + getCheckMessage ( WS_PRECEDED , ">" ) , "17:13: " + getCheckMessage ( WS_PRECEDED , "<" ) , "17:15: " + getCheckMessage ( WS_FOLLOWED , "<" ) , "17:20: " + getCheckMessage ( WS_PRECEDED , "<" ) , "17:22: " + getCheckMessage ( WS_FOLLOWED , "<" ) , "17:30: " + getCheckMessage ( WS_PRECEDED , ">" ) , "17:32: " + getCheckMessage ( WS_FOLLOWED , ">" ) , "17:32: " + getCheckMessage ( WS_PRECEDED , ">" ) , "17:52: " + getCheckMessage ( WS_PRECEDED , "<" ) , "17:54: " + getCheckMessage ( WS_FOLLOWED , "<" ) , "17:59: " + getCheckMessage ( WS_PRECEDED , "<" ) , "17:61: " + getCheckMessage ( WS_FOLLOWED , "<" ) , "17:69: " + getCheckMessage ( WS_PRECEDED , ">" ) , "17:71: " + getCheckMessage ( WS_FOLLOWED , ">" ) , "17:71: " + getCheckMessage ( WS_PRECEDED , ">" ) , "30:17: " + getCheckMessage ( WS_NOT_PRECEDED , "<" ) , "30:21: " + getCheckMessage ( WS_ILLEGAL_FOLLOW , ">" ) , "42:21: " + getCheckMessage ( WS_PRECEDED , "<" ) , "42:30: " + getCheckMessage ( WS_FOLLOWED , ">" ) , "60:60: " + getCheckMessage ( WS_NOT_PRECEDED , "&" ) , "63:60: " + getCheckMessage ( WS_FOLLOWED , ">" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputGenericWhitespaceCheck.java" ) , expected ) ; } @ Test public void testGh47 ( ) throws Exception { final String [ ] expected = { } ; verify ( checkConfig , getPath ( "whitespace/Gh47.java" ) , expected ) ; } @ Test public void testInnerClass ( ) throws Exception { final String [ ] expected = { } ; verify ( checkConfig , getPath ( "whitespace/" + "InputGenericWhitespaceInnerClassCheck.java" ) , expected ) ; } @ Test public void testMethodReferences ( ) throws Exception { final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/grammars/java8/" + "InputMethodReferencesTest3.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testMethodReferences2 ( ) throws Exception { final String [ ] expected = { "7:69: " + getCheckMessage ( WS_FOLLOWED , ">" ) , } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/whitespace/" + "InputGenericWhitespaceMethodRef.java" ) . getCanonicalPath ( ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class MemberNameCheck extends AbstractAccessControlNameCheck { public MemberNameCheck ( ) { super ( "^[a-z][a-zA-Z0-9]*$" ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF } ; } @ Override protected final boolean mustCheckName ( DetailAST ast ) { final DetailAST modifiersAST = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; final boolean isStatic = modifiersAST . branchContains ( TokenTypes . LITERAL_STATIC ) ; return ! isStatic && ! ScopeUtils . inInterfaceOrAnnotationBlock ( ast ) && ! ScopeUtils . isLocalVariableDef ( ast ) && shouldCheckInScope ( modifiersAST ) ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class MethodTypeParameterNameCheck extends AbstractTypeParameterNameCheck { public MethodTypeParameterNameCheck ( ) { super ( "^[A-Z]$" ) ; } @ Override protected final int getLocation ( ) { return TokenTypes . METHOD_DEF ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . AbstractFormatCheck ; public class PackageNameCheck extends AbstractFormatCheck { public PackageNameCheck ( ) { super ( "^[a-z]+(\\.[a-zA-Z_][a-zA-Z0-9_]*)*$" ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST nameAST = ast . getLastChild ( ) . getPreviousSibling ( ) ; final FullIdent full = FullIdent . createFullIdent ( nameAST ) ; if ( ! getRegexp ( ) . matcher ( full . getText ( ) ) . find ( ) ) { log ( full . getLineNo ( ) , full . getColumnNo ( ) , "name.invalidPattern" , full . getText ( ) , getFormat ( ) ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . AbstractFormatCheck ; public abstract class AbstractNameCheck extends AbstractFormatCheck { public static final String MSG_INVALID_PATTERN = "name.invalidPattern" ; public AbstractNameCheck ( String format ) { super ( format ) ; } @ Override public void visitToken ( DetailAST ast ) { if ( mustCheckName ( ast ) ) { final DetailAST nameAST = ast . findFirstToken ( TokenTypes . IDENT ) ; if ( ! getRegexp ( ) . matcher ( nameAST . getText ( ) ) . find ( ) ) { log ( nameAST . getLineNo ( ) , nameAST . getColumnNo ( ) , MSG_INVALID_PATTERN , nameAST . getText ( ) , getFormat ( ) ) ; } } } protected abstract boolean mustCheckName ( DetailAST ast ) ; }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class TypeNameCheck extends AbstractAccessControlNameCheck { public static final String DEFAULT_PATTERN = "^[A-Z][a-zA-Z0-9]*$" ; public TypeNameCheck ( ) { super ( DEFAULT_PATTERN ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , } ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import java . util . Arrays ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class AbbreviationAsWordInNameCheck extends Check { public static final String MSG_KEY = "abbreviation.as.word" ; private static final int DEFAULT_ALLOWED_ABBREVIATIONS_LENGTH = 3 ; private int allowedAbbreviationLength = DEFAULT_ALLOWED_ABBREVIATIONS_LENGTH ; private Set < String > allowedAbbreviations = new HashSet < > ( ) ; private boolean ignoreFinal = true ; private boolean ignoreStatic = true ; private boolean ignoreOverriddenMethods = true ; public void setIgnoreFinal ( boolean ignoreFinal ) { this . ignoreFinal = ignoreFinal ; } public void setIgnoreStatic ( boolean ignoreStatic ) { this . ignoreStatic = ignoreStatic ; } public void setIgnoreOverriddenMethods ( boolean ignoreOverriddenMethods ) { this . ignoreOverriddenMethods = ignoreOverriddenMethods ; } public void setAllowedAbbreviationLength ( int allowedAbbreviationLength ) { this . allowedAbbreviationLength = allowedAbbreviationLength ; } public void setAllowedAbbreviations ( String allowedAbbreviations ) { if ( allowedAbbreviations != null ) { this . allowedAbbreviations = new HashSet < > ( Arrays . asList ( allowedAbbreviations . split ( "," ) ) ) ; } } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . ANNOTATION_FIELD_DEF , TokenTypes . PARAMETER_DEF , TokenTypes . VARIABLE_DEF , TokenTypes . METHOD_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . ANNOTATION_FIELD_DEF , TokenTypes . PARAMETER_DEF , TokenTypes . VARIABLE_DEF , TokenTypes . METHOD_DEF , TokenTypes . ENUM_CONSTANT_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( ! isIgnoreSituation ( ast ) ) { final DetailAST nameAst = ast . findFirstToken ( TokenTypes . IDENT ) ; final String typeName = nameAst . getText ( ) ; final String abbr = getDisallowedAbbreviation ( typeName ) ; if ( abbr != null ) { log ( nameAst . getLineNo ( ) , MSG_KEY , allowedAbbreviationLength ) ; } } } private boolean isIgnoreSituation ( DetailAST ast ) { final DetailAST modifiers = ast . getFirstChild ( ) ; boolean result = false ; if ( ast . getType ( ) == TokenTypes . VARIABLE_DEF ) { if ( ( ignoreFinal || ignoreStatic ) && isInterfaceDeclaration ( ast ) ) { result = true ; } else { result = ignoreFinal && modifiers . branchContains ( TokenTypes . FINAL ) || ignoreStatic && modifiers . branchContains ( TokenTypes . LITERAL_STATIC ) ; } } else if ( ast . getType ( ) == TokenTypes . METHOD_DEF ) { result = ignoreOverriddenMethods && hasOverrideAnnotation ( modifiers ) ; } return result ; } private static boolean isInterfaceDeclaration ( DetailAST variableDefAst ) { boolean result = false ; final DetailAST astBlock = variableDefAst . getParent ( ) ; final DetailAST astParent2 = astBlock . getParent ( ) ; if ( astParent2 . getType ( ) == TokenTypes . INTERFACE_DEF ) { result = true ; } return result ; } private static boolean hasOverrideAnnotation ( DetailAST methodModifiersAST ) { boolean result = false ; for ( DetailAST child : getChildren ( methodModifiersAST ) ) { if ( child . getType ( ) == TokenTypes . ANNOTATION ) { final DetailAST annotationIdent = child . findFirstToken ( TokenTypes . IDENT ) ; if ( annotationIdent != null && "Override" . equals ( annotationIdent . getText ( ) ) ) { result = true ; break ; } } } return result ; } private String getDisallowedAbbreviation ( String str ) { int beginIndex = 0 ; boolean abbrStarted = false ; String result = null ; for ( int index = 0 ; index < str . length ( ) ; index ++ ) { final char symbol = str . charAt ( index ) ; if ( Character . isUpperCase ( symbol ) ) { if ( ! abbrStarted ) { abbrStarted = true ; beginIndex = index ; } } else { if ( abbrStarted ) { abbrStarted = false ; final int endIndex = index - 1 ; result = getAbbreviationIfIllegal ( str , beginIndex , endIndex ) ; if ( result != null ) { break ; } beginIndex = - 1 ; } } } if ( abbrStarted && beginIndex != str . length ( ) - 1 ) { final int endIndex = str . length ( ) ; result = getAbbreviationIfIllegal ( str , beginIndex , endIndex ) ; } return result ; } private String getAbbreviationIfIllegal ( String str , int beginIndex , int endIndex ) { String result = null ; final int abbrLength = endIndex - beginIndex ; if ( abbrLength > allowedAbbreviationLength ) { final String abbr = str . substring ( beginIndex , endIndex ) ; if ( ! allowedAbbreviations . contains ( abbr ) ) { result = abbr ; } } return result ; } private static List < DetailAST > getChildren ( final DetailAST node ) { final List < DetailAST > result = new LinkedList < > ( ) ; DetailAST curNode = node . getFirstChild ( ) ; while ( curNode != null ) { result . add ( curNode ) ; curNode = curNode . getNextSibling ( ) ; } return result ; } }
package com . puppycrawl . tools . checkstyle . checks . metrics ;
package com . puppycrawl . tools . checkstyle . checks . metrics ; import java . math . BigInteger ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public final class NPathComplexityCheck extends AbstractComplexityCheck { public static final String MSG_KEY = "npathComplexity" ; private static final int DEFAULT_MAX = 200 ; public NPathComplexityCheck ( ) { super ( DEFAULT_MAX ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . STATIC_INIT , TokenTypes . INSTANCE_INIT , TokenTypes . LITERAL_WHILE , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_FOR , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_ELSE , TokenTypes . LITERAL_SWITCH , TokenTypes . LITERAL_CASE , TokenTypes . LITERAL_TRY , TokenTypes . LITERAL_CATCH , TokenTypes . QUESTION , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . STATIC_INIT , TokenTypes . INSTANCE_INIT , TokenTypes . LITERAL_WHILE , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_FOR , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_ELSE , TokenTypes . LITERAL_SWITCH , TokenTypes . LITERAL_CASE , TokenTypes . LITERAL_TRY , TokenTypes . LITERAL_CATCH , TokenTypes . QUESTION , } ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . LITERAL_WHILE : case TokenTypes . LITERAL_DO : case TokenTypes . LITERAL_FOR : case TokenTypes . LITERAL_IF : case TokenTypes . QUESTION : case TokenTypes . LITERAL_TRY : case TokenTypes . LITERAL_SWITCH : visitMultiplyingConditional ( ) ; break ; case TokenTypes . LITERAL_ELSE : case TokenTypes . LITERAL_CATCH : case TokenTypes . LITERAL_CASE : visitAddingConditional ( ) ; break ; default : super . visitToken ( ast ) ; } } @ Override public void leaveToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . LITERAL_WHILE : case TokenTypes . LITERAL_DO : case TokenTypes . LITERAL_FOR : case TokenTypes . LITERAL_IF : case TokenTypes . QUESTION : case TokenTypes . LITERAL_TRY : case TokenTypes . LITERAL_SWITCH : leaveMultiplyingConditional ( ) ; break ; case TokenTypes . LITERAL_ELSE : case TokenTypes . LITERAL_CATCH : case TokenTypes . LITERAL_CASE : leaveAddingConditional ( ) ; break ; default : super . leaveToken ( ast ) ; } } @ Override protected String getMessageID ( ) { return MSG_KEY ; } private void visitAddingConditional ( ) { pushValue ( ) ; } private void leaveAddingConditional ( ) { setCurrentValue ( getCurrentValue ( ) . subtract ( BigInteger . ONE ) . add ( popValue ( ) ) ) ; } private void visitMultiplyingConditional ( ) { pushValue ( ) ; } private void leaveMultiplyingConditional ( ) { setCurrentValue ( getCurrentValue ( ) . add ( BigInteger . ONE ) . multiply ( popValue ( ) ) ) ; } @ Override protected void visitTokenHook ( DetailAST ast ) { } @ Override protected void leaveTokenHook ( DetailAST ast ) { } }
package com . puppycrawl . tools . checkstyle . checks . metrics ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . CheckUtils ; import java . util . ArrayDeque ; import java . util . Deque ; public final class BooleanExpressionComplexityCheck extends Check { public static final String MSG_KEY = "booleanExpressionComplexity" ; private static final int DEFAULT_MAX = 3 ; private final Deque < Context > contextStack = new ArrayDeque < > ( ) ; private int max ; private Context context = new Context ( false ) ; public BooleanExpressionComplexityCheck ( ) { setMax ( DEFAULT_MAX ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . EXPR , TokenTypes . LAND , TokenTypes . BAND , TokenTypes . LOR , TokenTypes . BOR , TokenTypes . BXOR , } ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . EXPR , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . EXPR , TokenTypes . LAND , TokenTypes . BAND , TokenTypes . LOR , TokenTypes . BOR , TokenTypes . BXOR , } ; } public int getMax ( ) { return max ; } public void setMax ( int max ) { this . max = max ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CTOR_DEF : case TokenTypes . METHOD_DEF : visitMethodDef ( ast ) ; break ; case TokenTypes . EXPR : visitExpr ( ) ; break ; case TokenTypes . BOR : if ( ! isPipeOperator ( ast ) && ! isPassedInParameter ( ast ) ) { context . visitBooleanOperator ( ) ; } break ; case TokenTypes . BAND : case TokenTypes . BXOR : if ( ! isPassedInParameter ( ast ) ) { context . visitBooleanOperator ( ) ; } break ; case TokenTypes . LAND : case TokenTypes . LOR : context . visitBooleanOperator ( ) ; break ; default : throw new IllegalStateException ( ast . toString ( ) ) ; } } private boolean isPassedInParameter ( DetailAST logicalOperator ) { return logicalOperator . getParent ( ) . getType ( ) == TokenTypes . EXPR && logicalOperator . getParent ( ) . getParent ( ) . getType ( ) == TokenTypes . ELIST ; } private static boolean isPipeOperator ( DetailAST binaryOr ) { return binaryOr . getParent ( ) . getType ( ) == TokenTypes . TYPE ; } @ Override public void leaveToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CTOR_DEF : case TokenTypes . METHOD_DEF : leaveMethodDef ( ) ; break ; case TokenTypes . EXPR : leaveExpr ( ast ) ; break ; default : } } private void visitMethodDef ( DetailAST ast ) { contextStack . push ( context ) ; context = new Context ( ! CheckUtils . isEqualsMethod ( ast ) ) ; } private void leaveMethodDef ( ) { context = contextStack . pop ( ) ; } private void visitExpr ( ) { contextStack . push ( context ) ; context = new Context ( context == null || context . isChecking ( ) ) ; } private void leaveExpr ( DetailAST ast ) { context . checkCount ( ast ) ; context = contextStack . pop ( ) ; } private class Context { private final boolean checking ; private int count ; public Context ( boolean checking ) { this . checking = checking ; count = 0 ; } public boolean isChecking ( ) { return checking ; } public void visitBooleanOperator ( ) { ++ count ; } public void checkCount ( DetailAST ast ) { if ( checking && count > getMax ( ) ) { final DetailAST parentAST = ast . getParent ( ) ; log ( parentAST . getLineNo ( ) , parentAST . getColumnNo ( ) , MSG_KEY , count , getMax ( ) ) ; } } } }
package com . puppycrawl . tools . checkstyle . checks . metrics ; import java . math . BigInteger ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class CyclomaticComplexityCheck extends AbstractComplexityCheck { public static final String MSG_KEY = "cyclomaticComplexity" ; private static final int DEFAULT_VALUE = 10 ; public CyclomaticComplexityCheck ( ) { super ( DEFAULT_VALUE ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . INSTANCE_INIT , TokenTypes . STATIC_INIT , TokenTypes . LITERAL_WHILE , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_FOR , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_CASE , TokenTypes . LITERAL_CATCH , TokenTypes . QUESTION , TokenTypes . LAND , TokenTypes . LOR , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . INSTANCE_INIT , TokenTypes . STATIC_INIT , TokenTypes . LITERAL_WHILE , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_FOR , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_CASE , TokenTypes . LITERAL_CATCH , TokenTypes . QUESTION , TokenTypes . LAND , TokenTypes . LOR , } ; } @ Override protected final void visitTokenHook ( DetailAST ast ) { incrementCurrentValue ( BigInteger . ONE ) ; } @ Override protected final String getMessageID ( ) { return MSG_KEY ; } @ Override protected void leaveTokenHook ( DetailAST ast ) { } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . EmptyForInitializerPadCheck . MSG_NOT_PRECEDED ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . EmptyForInitializerPadCheck . MSG_PRECEDED ; public class EmptyForInitializerPadCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( EmptyForInitializerPadCheck . class ) ; } @ Test public void testDefault ( ) throws Exception { final String [ ] expected = { "48:14: " + getCheckMessage ( MSG_PRECEDED , ";" ) , } ; verify ( checkConfig , getPath ( "InputForWhitespace.java" ) , expected ) ; } @ Test public void testSpaceOption ( ) throws Exception { checkConfig . addAttribute ( "option" , PadOption . SPACE . toString ( ) ) ; final String [ ] expected = { "51:13: " + getCheckMessage ( MSG_NOT_PRECEDED , ";" ) , } ; verify ( checkConfig , getPath ( "InputForWhitespace.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . metrics ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . ArrayDeque ; import java . util . Deque ; public class JavaNCSSCheck extends Check { public static final String MSG_METHOD = "ncss.method" ; public static final String MSG_CLASS = "ncss.class" ; public static final String MSG_FILE = "ncss.file" ; private static final int FILE_MAX_NCSS = 2000 ; private static final int CLASS_MAX_NCSS = 1500 ; private static final int METHOD_MAX_NCSS = 50 ; private int fileMax = FILE_MAX_NCSS ; private int classMax = CLASS_MAX_NCSS ; private int methodMax = METHOD_MAX_NCSS ; private Deque < Counter > counters ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . INSTANCE_INIT , TokenTypes . STATIC_INIT , TokenTypes . PACKAGE_DEF , TokenTypes . IMPORT , TokenTypes . VARIABLE_DEF , TokenTypes . CTOR_CALL , TokenTypes . SUPER_CTOR_CALL , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_ELSE , TokenTypes . LITERAL_WHILE , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_FOR , TokenTypes . LITERAL_SWITCH , TokenTypes . LITERAL_BREAK , TokenTypes . LITERAL_CONTINUE , TokenTypes . LITERAL_RETURN , TokenTypes . LITERAL_THROW , TokenTypes . LITERAL_SYNCHRONIZED , TokenTypes . LITERAL_CATCH , TokenTypes . LITERAL_FINALLY , TokenTypes . EXPR , TokenTypes . LABELED_STAT , TokenTypes . LITERAL_CASE , TokenTypes . LITERAL_DEFAULT , } ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . INSTANCE_INIT , TokenTypes . STATIC_INIT , TokenTypes . PACKAGE_DEF , TokenTypes . IMPORT , TokenTypes . VARIABLE_DEF , TokenTypes . CTOR_CALL , TokenTypes . SUPER_CTOR_CALL , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_ELSE , TokenTypes . LITERAL_WHILE , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_FOR , TokenTypes . LITERAL_SWITCH , TokenTypes . LITERAL_BREAK , TokenTypes . LITERAL_CONTINUE , TokenTypes . LITERAL_RETURN , TokenTypes . LITERAL_THROW , TokenTypes . LITERAL_SYNCHRONIZED , TokenTypes . LITERAL_CATCH , TokenTypes . LITERAL_FINALLY , TokenTypes . EXPR , TokenTypes . LABELED_STAT , TokenTypes . LITERAL_CASE , TokenTypes . LITERAL_DEFAULT , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . INSTANCE_INIT , TokenTypes . STATIC_INIT , TokenTypes . PACKAGE_DEF , TokenTypes . IMPORT , TokenTypes . VARIABLE_DEF , TokenTypes . CTOR_CALL , TokenTypes . SUPER_CTOR_CALL , TokenTypes . LITERAL_IF , TokenTypes . LITERAL_ELSE , TokenTypes . LITERAL_WHILE , TokenTypes . LITERAL_DO , TokenTypes . LITERAL_FOR , TokenTypes . LITERAL_SWITCH , TokenTypes . LITERAL_BREAK , TokenTypes . LITERAL_CONTINUE , TokenTypes . LITERAL_RETURN , TokenTypes . LITERAL_THROW , TokenTypes . LITERAL_SYNCHRONIZED , TokenTypes . LITERAL_CATCH , TokenTypes . LITERAL_FINALLY , TokenTypes . EXPR , TokenTypes . LABELED_STAT , TokenTypes . LITERAL_CASE , TokenTypes . LITERAL_DEFAULT , } ; } @ Override public void beginTree ( DetailAST rootAST ) { counters = new ArrayDeque < > ( ) ; counters . push ( new Counter ( ) ) ; } @ Override public void visitToken ( DetailAST ast ) { final int tokenType = ast . getType ( ) ; if ( TokenTypes . CLASS_DEF == tokenType || TokenTypes . METHOD_DEF == tokenType || TokenTypes . CTOR_DEF == tokenType || TokenTypes . STATIC_INIT == tokenType || TokenTypes . INSTANCE_INIT == tokenType ) { counters . push ( new Counter ( ) ) ; } if ( isCountable ( ast ) ) { for ( final Counter c : counters ) { c . increment ( ) ; } } } @ Override public void leaveToken ( DetailAST ast ) { final int tokenType = ast . getType ( ) ; if ( TokenTypes . METHOD_DEF == tokenType || TokenTypes . CTOR_DEF == tokenType || TokenTypes . STATIC_INIT == tokenType || TokenTypes . INSTANCE_INIT == tokenType ) { final Counter counter = counters . pop ( ) ; final int count = counter . getCount ( ) ; if ( count > methodMax ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_METHOD , count , methodMax ) ; } } else if ( TokenTypes . CLASS_DEF == tokenType ) { final Counter counter = counters . pop ( ) ; final int count = counter . getCount ( ) ; if ( count > classMax ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_CLASS , count , classMax ) ; } } } @ Override public void finishTree ( DetailAST rootAST ) { final Counter counter = counters . pop ( ) ; final int count = counter . getCount ( ) ; if ( count > fileMax ) { log ( rootAST . getLineNo ( ) , rootAST . getColumnNo ( ) , MSG_FILE , count , fileMax ) ; } } public void setFileMaximum ( int fileMax ) { this . fileMax = fileMax ; } public void setClassMaximum ( int classMax ) { this . classMax = classMax ; } public void setMethodMaximum ( int methodMax ) { this . methodMax = methodMax ; } private boolean isCountable ( DetailAST ast ) { boolean countable = true ; final int tokenType = ast . getType ( ) ; if ( TokenTypes . EXPR == tokenType ) { countable = isExpressionCountable ( ast ) ; } else if ( TokenTypes . VARIABLE_DEF == tokenType ) { countable = isVariableDefCountable ( ast ) ; } return countable ; } private boolean isVariableDefCountable ( DetailAST ast ) { boolean countable = false ; final int parentType = ast . getParent ( ) . getType ( ) ; if ( TokenTypes . SLIST == parentType || TokenTypes . OBJBLOCK == parentType ) { final DetailAST prevSibling = ast . getPreviousSibling ( ) ; countable = prevSibling == null || TokenTypes . COMMA != prevSibling . getType ( ) ; } return countable ; } private boolean isExpressionCountable ( DetailAST ast ) { boolean countable = true ; final int parentType = ast . getParent ( ) . getType ( ) ; switch ( parentType ) { case TokenTypes . SLIST : case TokenTypes . LABELED_STAT : case TokenTypes . LITERAL_FOR : case TokenTypes . LITERAL_DO : case TokenTypes . LITERAL_WHILE : case TokenTypes . LITERAL_IF : case TokenTypes . LITERAL_ELSE : final DetailAST prevSibling = ast . getPreviousSibling ( ) ; countable = prevSibling == null || TokenTypes . LPAREN != prevSibling . getType ( ) ; break ; default : countable = false ; break ; } return countable ; } private static class Counter { private int ivCount ; public void increment ( ) { ivCount ++ ; } public int getCount ( ) { return ivCount ; } } }
package com . puppycrawl . tools . checkstyle . checks . metrics ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public final class ClassDataAbstractionCouplingCheck extends AbstractClassCouplingCheck { public static final String MSG_KEY = "classDataAbstractionCoupling" ; private static final int DEFAULT_MAX = 7 ; public ClassDataAbstractionCouplingCheck ( ) { super ( DEFAULT_MAX ) ; setTokens ( "LITERAL_NEW" ) ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF , TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . LITERAL_NEW , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF , TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . LITERAL_NEW , } ; } @ Override protected String getLogMessageId ( ) { return MSG_KEY ; } }
package com . puppycrawl . tools . checkstyle . checks . metrics ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . math . BigInteger ; import java . util . ArrayDeque ; import java . util . Deque ; public abstract class AbstractComplexityCheck extends Check { private static final BigInteger INITIAL_VALUE = BigInteger . ONE ; private final Deque < BigInteger > valueStack = new ArrayDeque < > ( ) ; private BigInteger currentValue = BigInteger . ZERO ; private int max ; public AbstractComplexityCheck ( int max ) { this . max = max ; } protected abstract String getMessageID ( ) ; protected abstract void visitTokenHook ( DetailAST ast ) ; protected abstract void leaveTokenHook ( DetailAST ast ) ; @ Override public final int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . INSTANCE_INIT , TokenTypes . STATIC_INIT , } ; } public final int getMax ( ) { return max ; } public final void setMax ( int max ) { this . max = max ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CTOR_DEF : case TokenTypes . METHOD_DEF : case TokenTypes . INSTANCE_INIT : case TokenTypes . STATIC_INIT : visitMethodDef ( ) ; break ; default : visitTokenHook ( ast ) ; } } @ Override public void leaveToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CTOR_DEF : case TokenTypes . METHOD_DEF : case TokenTypes . INSTANCE_INIT : case TokenTypes . STATIC_INIT : leaveMethodDef ( ast ) ; break ; default : leaveTokenHook ( ast ) ; } } protected final BigInteger getCurrentValue ( ) { return currentValue ; } protected final void setCurrentValue ( BigInteger value ) { currentValue = value ; } protected final void incrementCurrentValue ( BigInteger by ) { setCurrentValue ( getCurrentValue ( ) . add ( by ) ) ; } protected final void pushValue ( ) { valueStack . push ( currentValue ) ; currentValue = INITIAL_VALUE ; } protected final BigInteger popValue ( ) { currentValue = valueStack . pop ( ) ; return currentValue ; } private void visitMethodDef ( ) { pushValue ( ) ; } private void leaveMethodDef ( DetailAST ast ) { final BigInteger bigIntegerMax = BigInteger . valueOf ( max ) ; if ( currentValue . compareTo ( bigIntegerMax ) > 0 ) { log ( ast , getMessageID ( ) , currentValue , bigIntegerMax ) ; } popValue ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . metrics ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . CheckUtils ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . Set ; public abstract class AbstractClassCouplingCheck extends Check { private static final Set < String > DEFAULT_EXCLUDED_CLASSES = ImmutableSet . < String > builder ( ) . add ( "boolean" , "byte" , "char" , "double" , "float" , "int" ) . add ( "long" , "short" , "void" ) . add ( "Boolean" , "Byte" , "Character" , "Double" , "Float" ) . add ( "Integer" , "Long" , "Short" , "Void" ) . add ( "Object" , "Class" ) . add ( "String" , "StringBuffer" , "StringBuilder" ) . add ( "ArrayIndexOutOfBoundsException" , "Exception" ) . add ( "RuntimeException" , "IllegalArgumentException" ) . add ( "IllegalStateException" , "IndexOutOfBoundsException" ) . add ( "NullPointerException" , "Throwable" , "SecurityException" ) . add ( "UnsupportedOperationException" ) . add ( "List" , "ArrayList" , "Deque" , "Queue" , "LinkedList" ) . add ( "Set" , "HashSet" , "SortedSet" , "TreeSet" ) . add ( "Map" , "HashMap" , "SortedMap" , "TreeMap" ) . build ( ) ; private Set < String > excludedClasses = DEFAULT_EXCLUDED_CLASSES ; private int max ; private String packageName ; private final Deque < Context > contextStack = new ArrayDeque < > ( ) ; private Context context = new Context ( "" , 0 , 0 ) ; protected AbstractClassCouplingCheck ( int defaultMax ) { setMax ( defaultMax ) ; } @ Override public final int [ ] getDefaultTokens ( ) { return getRequiredTokens ( ) ; } public final int getMax ( ) { return max ; } public final void setMax ( int max ) { this . max = max ; } public final void setExcludedClasses ( String ... excludedClasses ) { this . excludedClasses = ImmutableSet . copyOf ( excludedClasses ) ; } @ Override public final void beginTree ( DetailAST ast ) { packageName = "" ; } protected abstract String getLogMessageId ( ) ; @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . PACKAGE_DEF : visitPackageDef ( ast ) ; break ; case TokenTypes . CLASS_DEF : case TokenTypes . INTERFACE_DEF : case TokenTypes . ANNOTATION_DEF : case TokenTypes . ENUM_DEF : visitClassDef ( ast ) ; break ; case TokenTypes . TYPE : context . visitType ( ast ) ; break ; case TokenTypes . LITERAL_NEW : context . visitLiteralNew ( ast ) ; break ; case TokenTypes . LITERAL_THROWS : context . visitLiteralThrows ( ast ) ; break ; default : throw new IllegalStateException ( ast . toString ( ) ) ; } } @ Override public void leaveToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CLASS_DEF : case TokenTypes . INTERFACE_DEF : case TokenTypes . ANNOTATION_DEF : case TokenTypes . ENUM_DEF : leaveClassDef ( ) ; break ; default : } } private void visitPackageDef ( DetailAST pkg ) { final FullIdent ident = FullIdent . createFullIdent ( pkg . getLastChild ( ) . getPreviousSibling ( ) ) ; packageName = ident . getText ( ) ; } private void visitClassDef ( DetailAST classDef ) { contextStack . push ( context ) ; final String className = classDef . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; context = new Context ( className , classDef . getLineNo ( ) , classDef . getColumnNo ( ) ) ; } private void leaveClassDef ( ) { context . checkCoupling ( ) ; context = contextStack . pop ( ) ; } private class Context { private final Set < String > referencedClassNames = Sets . newTreeSet ( ) ; private final String className ; private final int lineNo ; private final int columnNo ; public Context ( String className , int lineNo , int columnNo ) { this . className = className ; this . lineNo = lineNo ; this . columnNo = columnNo ; } public void visitLiteralThrows ( DetailAST literalThrows ) { for ( DetailAST childAST = literalThrows . getFirstChild ( ) ; childAST != null ; childAST = childAST . getNextSibling ( ) ) { if ( childAST . getType ( ) != TokenTypes . COMMA ) { addReferencedClassName ( childAST ) ; } } } public void visitType ( DetailAST ast ) { final String className = CheckUtils . createFullType ( ast ) . getText ( ) ; context . addReferencedClassName ( className ) ; } public void visitLiteralNew ( DetailAST ast ) { context . addReferencedClassName ( ast . getFirstChild ( ) ) ; } private void addReferencedClassName ( DetailAST ast ) { final String className = FullIdent . createFullIdent ( ast ) . getText ( ) ; addReferencedClassName ( className ) ; } private void addReferencedClassName ( String className ) { if ( isSignificant ( className ) ) { referencedClassNames . add ( className ) ; } } public void checkCoupling ( ) { referencedClassNames . remove ( className ) ; referencedClassNames . remove ( packageName + "." + className ) ; if ( referencedClassNames . size ( ) > max ) { log ( lineNo , columnNo , getLogMessageId ( ) , referencedClassNames . size ( ) , getMax ( ) , referencedClassNames . toString ( ) ) ; } } private boolean isSignificant ( String className ) { return className . length ( ) > 0 && ! excludedClasses . contains ( className ) && ! className . startsWith ( "java.lang." ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . metrics ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public final class ClassFanOutComplexityCheck extends AbstractClassCouplingCheck { public static final String MSG_KEY = "classFanOutComplexity" ; private static final int DEFAULT_MAX = 20 ; public ClassFanOutComplexityCheck ( ) { super ( DEFAULT_MAX ) ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF , TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . TYPE , TokenTypes . LITERAL_NEW , TokenTypes . LITERAL_THROWS , TokenTypes . ANNOTATION_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF , TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . TYPE , TokenTypes . LITERAL_NEW , TokenTypes . LITERAL_THROWS , TokenTypes . ANNOTATION_DEF , } ; } @ Override protected String getLogMessageId ( ) { return MSG_KEY ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ;
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import antlr . collections . AST ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FileContents ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . JavadocTagInfo ; import com . puppycrawl . tools . checkstyle . api . Scope ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TextBlock ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . checks . AbstractTypeAwareCheck ; import com . puppycrawl . tools . checkstyle . checks . CheckUtils ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . Set ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ SuppressWarnings ( "deprecation" ) public class JavadocMethodCheck extends AbstractTypeAwareCheck { public static final String MSG_JAVADOC_MISSING = "javadoc.missing" ; public static final String MSG_CLASS_INFO = "javadoc.classInfo" ; public static final String MSG_UNUSED_TAG_GENERAL = "javadoc.unusedTagGeneral" ; public static final String MSG_INVALID_INHERIT_DOC = "javadoc.invalidInheritDoc" ; public static final String MSG_UNUSED_TAG = "javadoc.unusedTag" ; public static final String MSG_EXCPECTED_TAG = "javadoc.expectedTag" ; public static final String MSG_RETURN_EXPECTED = "javadoc.return.expected" ; public static final String MSG_DUPLICATE_TAG = "javadoc.duplicateTag" ; private static final Pattern MATCH_JAVADOC_ARG = Utils . createPattern ( "@(throws|exception|param)\\s+(\\S+)\\s+\\S*" ) ; private static final Pattern MATCH_JAVADOC_ARG_MULTILINE_START = Utils . createPattern ( "@(throws|exception|param)\\s+(\\S+)\\s*$" ) ; private static final Pattern MATCH_JAVADOC_MULTILINE_CONT = Utils . createPattern ( "(\\*/|@|[^\\s\\*])" ) ; private static final String END_JAVADOC = "*/" ; private static final String NEXT_TAG = "@" ; private static final Pattern MATCH_JAVADOC_NOARG = Utils . createPattern ( "@(return|see)\\s+\\S" ) ; private static final Pattern MATCH_JAVADOC_NOARG_MULTILINE_START = Utils . createPattern ( "@(return|see)\\s*$" ) ; private static final Pattern MATCH_JAVADOC_NOARG_CURLY = Utils . createPattern ( "\\{\\s*@(inheritDoc)\\s*\\}" ) ; private static final int MAX_CHILDREN = 7 ; private static final int BODY_SIZE = 3 ; private static final int DEFAULT_MIN_LINE_COUNT = - 1 ; private Scope scope = Scope . PRIVATE ; private Scope excludeScope ; private int minLineCount = DEFAULT_MIN_LINE_COUNT ; private boolean allowUndeclaredRTE ; private boolean validateThrows ; private boolean allowThrowsTagsForSubclasses ; private boolean allowMissingParamTags ; private boolean allowMissingThrowsTags ; private boolean allowMissingReturnTag ; private boolean allowMissingJavadoc ; private boolean allowMissingPropertyJavadoc ; private List < String > allowedAnnotations = Arrays . asList ( "Override" ) ; private Pattern ignoreMethodNamesRegex ; public void setIgnoreMethodNamesRegex ( String regex ) { ignoreMethodNamesRegex = Utils . createPattern ( regex ) ; } public void setMinLineCount ( int value ) { minLineCount = value ; } public void setValidateThrows ( boolean value ) { validateThrows = value ; } public void setAllowedAnnotations ( String userAnnotations ) { final List < String > annotations = new ArrayList < > ( ) ; final String [ ] sAnnotations = userAnnotations . split ( "," ) ; for ( int i = 0 ; i < sAnnotations . length ; i ++ ) { sAnnotations [ i ] = sAnnotations [ i ] . trim ( ) ; } Collections . addAll ( annotations , sAnnotations ) ; allowedAnnotations = annotations ; } public void setScope ( String from ) { scope = Scope . getInstance ( from ) ; } public void setExcludeScope ( String scope ) { excludeScope = Scope . getInstance ( scope ) ; } public void setAllowUndeclaredRTE ( boolean flag ) { allowUndeclaredRTE = flag ; } public void setAllowThrowsTagsForSubclasses ( boolean flag ) { allowThrowsTagsForSubclasses = flag ; } public void setAllowMissingParamTags ( boolean flag ) { allowMissingParamTags = flag ; } public void setAllowMissingThrowsTags ( boolean flag ) { allowMissingThrowsTags = flag ; } public void setAllowMissingReturnTag ( boolean flag ) { allowMissingReturnTag = flag ; } public void setAllowMissingJavadoc ( boolean flag ) { allowMissingJavadoc = flag ; } public void setAllowMissingPropertyJavadoc ( final boolean flag ) { allowMissingPropertyJavadoc = flag ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF , TokenTypes . IMPORT , TokenTypes . CLASS_DEF , TokenTypes . ENUM_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . ANNOTATION_FIELD_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . ANNOTATION_FIELD_DEF , } ; } @ Override public boolean isCommentNodesRequired ( ) { return true ; } @ Override protected final void processAST ( DetailAST ast ) { if ( ( ast . getType ( ) == TokenTypes . METHOD_DEF || ast . getType ( ) == TokenTypes . CTOR_DEF ) && getMethodsNumberOfLine ( ast ) <= minLineCount || hasAllowedAnnotations ( ast ) ) { return ; } final Scope theScope = calculateScope ( ast ) ; if ( shouldCheck ( ast , theScope ) ) { final FileContents contents = getFileContents ( ) ; final TextBlock cmt = contents . getJavadocBefore ( ast . getLineNo ( ) ) ; if ( cmt == null ) { if ( ! isMissingJavadocAllowed ( ast ) ) { log ( ast , MSG_JAVADOC_MISSING ) ; } } else { checkComment ( ast , cmt ) ; } } } private boolean hasAllowedAnnotations ( DetailAST methodDef ) { final DetailAST modifiersNode = methodDef . findFirstToken ( TokenTypes . MODIFIERS ) ; DetailAST annotationNode = modifiersNode . findFirstToken ( TokenTypes . ANNOTATION ) ; while ( annotationNode != null && annotationNode . getType ( ) == TokenTypes . ANNOTATION ) { DetailAST identNode = annotationNode . findFirstToken ( TokenTypes . IDENT ) ; if ( identNode == null ) { identNode = annotationNode . findFirstToken ( TokenTypes . DOT ) . findFirstToken ( TokenTypes . IDENT ) ; } if ( allowedAnnotations . contains ( identNode . getText ( ) ) ) { return true ; } annotationNode = annotationNode . getNextSibling ( ) ; } return false ; } private int getMethodsNumberOfLine ( DetailAST methodDef ) { int numberOfLines ; final DetailAST lcurly = methodDef . getLastChild ( ) ; final DetailAST rcurly = lcurly . getLastChild ( ) ; if ( lcurly . getFirstChild ( ) == rcurly ) { numberOfLines = 1 ; } else { numberOfLines = rcurly . getLineNo ( ) - lcurly . getLineNo ( ) - 1 ; } return numberOfLines ; } @ Override protected final void logLoadError ( Token ident ) { logLoadErrorImpl ( ident . getLineNo ( ) , ident . getColumnNo ( ) , MSG_CLASS_INFO , JavadocTagInfo . THROWS . getText ( ) , ident . getText ( ) ) ; } protected boolean isMissingJavadocAllowed ( final DetailAST ast ) { return allowMissingJavadoc || allowMissingPropertyJavadoc && ( isSetterMethod ( ast ) || isGetterMethod ( ast ) ) || matchesSkipRegex ( ast ) ; } private boolean matchesSkipRegex ( DetailAST methodDef ) { if ( ignoreMethodNamesRegex != null ) { final DetailAST ident = methodDef . findFirstToken ( TokenTypes . IDENT ) ; final String methodName = ident . getText ( ) ; final Matcher matcher = ignoreMethodNamesRegex . matcher ( methodName ) ; if ( matcher . matches ( ) ) { return true ; } } return false ; } private boolean shouldCheck ( final DetailAST ast , final Scope scope ) { final Scope surroundingScope = ScopeUtils . getSurroundingScope ( ast ) ; return scope . isIn ( this . scope ) && surroundingScope . isIn ( this . scope ) && ( excludeScope == null || ! scope . isIn ( excludeScope ) || ! surroundingScope . isIn ( excludeScope ) ) ; } private void checkComment ( DetailAST ast , TextBlock comment ) { final List < JavadocTag > tags = getMethodTags ( comment ) ; if ( hasShortCircuitTag ( ast , tags ) ) { return ; } Iterator < JavadocTag > it = tags . iterator ( ) ; if ( ast . getType ( ) != TokenTypes . ANNOTATION_FIELD_DEF ) { boolean hasInheritDocTag = false ; while ( it . hasNext ( ) && ! hasInheritDocTag ) { hasInheritDocTag |= it . next ( ) . isInheritDocTag ( ) ; } checkParamTags ( tags , ast , ! hasInheritDocTag ) ; checkThrowsTags ( tags , getThrows ( ast ) , ! hasInheritDocTag ) ; if ( isFunction ( ast ) ) { checkReturnTag ( tags , ast . getLineNo ( ) , ! hasInheritDocTag ) ; } } it = tags . iterator ( ) ; while ( it . hasNext ( ) ) { final JavadocTag jt = it . next ( ) ; if ( ! jt . isSeeOrInheritDocTag ( ) ) { log ( jt . getLineNo ( ) , MSG_UNUSED_TAG_GENERAL ) ; } } } private boolean hasShortCircuitTag ( final DetailAST ast , final List < JavadocTag > tags ) { if ( tags . size ( ) != 1 || ! tags . get ( 0 ) . isInheritDocTag ( ) ) { return false ; } if ( ! JavadocTagInfo . INHERIT_DOC . isValidOn ( ast ) ) { log ( ast , MSG_INVALID_INHERIT_DOC ) ; } return true ; } private Scope calculateScope ( final DetailAST ast ) { final DetailAST mods = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; final Scope declaredScope = ScopeUtils . getScopeFromMods ( mods ) ; return ScopeUtils . inInterfaceOrAnnotationBlock ( ast ) ? Scope . PUBLIC : declaredScope ; } private List < JavadocTag > getMethodTags ( TextBlock comment ) { final String [ ] lines = comment . getText ( ) ; final List < JavadocTag > tags = Lists . newArrayList ( ) ; int currentLine = comment . getStartLineNo ( ) - 1 ; for ( int i = 0 ; i < lines . length ; i ++ ) { currentLine ++ ; final Matcher javadocArgMatcher = MATCH_JAVADOC_ARG . matcher ( lines [ i ] ) ; final Matcher javadocNoargMatcher = MATCH_JAVADOC_NOARG . matcher ( lines [ i ] ) ; final Matcher noargCurlyMatcher = MATCH_JAVADOC_NOARG_CURLY . matcher ( lines [ i ] ) ; final Matcher argMultilineStart = MATCH_JAVADOC_ARG_MULTILINE_START . matcher ( lines [ i ] ) ; final Matcher noargMultilineStart = MATCH_JAVADOC_NOARG_MULTILINE_START . matcher ( lines [ i ] ) ; if ( javadocArgMatcher . find ( ) ) { int col = javadocArgMatcher . start ( 1 ) - 1 ; if ( i == 0 ) { col += comment . getStartColNo ( ) ; } tags . add ( new JavadocTag ( currentLine , col , javadocArgMatcher . group ( 1 ) , javadocArgMatcher . group ( 2 ) ) ) ; } else if ( javadocNoargMatcher . find ( ) ) { int col = javadocNoargMatcher . start ( 1 ) - 1 ; if ( i == 0 ) { col += comment . getStartColNo ( ) ; } tags . add ( new JavadocTag ( currentLine , col , javadocNoargMatcher . group ( 1 ) ) ) ; } else if ( noargCurlyMatcher . find ( ) ) { int col = noargCurlyMatcher . start ( 1 ) - 1 ; if ( i == 0 ) { col += comment . getStartColNo ( ) ; } tags . add ( new JavadocTag ( currentLine , col , noargCurlyMatcher . group ( 1 ) ) ) ; } else if ( argMultilineStart . find ( ) ) { final String p1 = argMultilineStart . group ( 1 ) ; final String p2 = argMultilineStart . group ( 2 ) ; int col = argMultilineStart . start ( 1 ) - 1 ; if ( i == 0 ) { col += comment . getStartColNo ( ) ; } int remIndex = i + 1 ; while ( remIndex < lines . length ) { final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT . matcher ( lines [ remIndex ] ) ; if ( multilineCont . find ( ) ) { remIndex = lines . length ; final String lFin = multilineCont . group ( 1 ) ; if ( ! lFin . equals ( NEXT_TAG ) && ! lFin . equals ( END_JAVADOC ) ) { tags . add ( new JavadocTag ( currentLine , col , p1 , p2 ) ) ; } } remIndex ++ ; } } else if ( noargMultilineStart . find ( ) ) { final String p1 = noargMultilineStart . group ( 1 ) ; int col = noargMultilineStart . start ( 1 ) - 1 ; if ( i == 0 ) { col += comment . getStartColNo ( ) ; } int remIndex = i + 1 ; while ( remIndex < lines . length ) { final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT . matcher ( lines [ remIndex ] ) ; if ( multilineCont . find ( ) ) { remIndex = lines . length ; final String lFin = multilineCont . group ( 1 ) ; if ( ! lFin . equals ( NEXT_TAG ) && ! lFin . equals ( END_JAVADOC ) ) { tags . add ( new JavadocTag ( currentLine , col , p1 ) ) ; } } remIndex ++ ; } } } return tags ; } private List < DetailAST > getParameters ( DetailAST ast ) { final DetailAST params = ast . findFirstToken ( TokenTypes . PARAMETERS ) ; final List < DetailAST > retVal = Lists . newArrayList ( ) ; DetailAST child = params . getFirstChild ( ) ; while ( child != null ) { if ( child . getType ( ) == TokenTypes . PARAMETER_DEF ) { final DetailAST ident = child . findFirstToken ( TokenTypes . IDENT ) ; retVal . add ( ident ) ; } child = child . getNextSibling ( ) ; } return retVal ; } private List < ExceptionInfo > getThrows ( DetailAST ast ) { final List < ExceptionInfo > retVal = Lists . newArrayList ( ) ; final DetailAST throwsAST = ast . findFirstToken ( TokenTypes . LITERAL_THROWS ) ; if ( throwsAST != null ) { DetailAST child = throwsAST . getFirstChild ( ) ; while ( child != null ) { if ( child . getType ( ) == TokenTypes . IDENT || child . getType ( ) == TokenTypes . DOT ) { final FullIdent fi = FullIdent . createFullIdent ( child ) ; final ExceptionInfo ei = new ExceptionInfo ( createClassInfo ( new Token ( fi ) , getCurrentClassName ( ) ) ) ; retVal . add ( ei ) ; } child = child . getNextSibling ( ) ; } } return retVal ; } private void checkParamTags ( final List < JavadocTag > tags , final DetailAST parent , boolean reportExpectedTags ) { final List < DetailAST > params = getParameters ( parent ) ; final List < DetailAST > typeParams = CheckUtils . getTypeParameters ( parent ) ; final ListIterator < JavadocTag > tagIt = tags . listIterator ( ) ; while ( tagIt . hasNext ( ) ) { final JavadocTag tag = tagIt . next ( ) ; if ( ! tag . isParamTag ( ) ) { continue ; } tagIt . remove ( ) ; boolean found = false ; final Iterator < DetailAST > paramIt = params . iterator ( ) ; final String arg1 = tag . getArg1 ( ) ; while ( paramIt . hasNext ( ) ) { final DetailAST param = paramIt . next ( ) ; if ( param . getText ( ) . equals ( arg1 ) ) { found = true ; paramIt . remove ( ) ; break ; } } if ( Utils . startsWithChar ( arg1 , '<' ) && Utils . endsWithChar ( arg1 , '>' ) ) { final Iterator < DetailAST > typeParamsIt = typeParams . iterator ( ) ; while ( typeParamsIt . hasNext ( ) ) { final DetailAST typeParam = typeParamsIt . next ( ) ; if ( typeParam . findFirstToken ( TokenTypes . IDENT ) . getText ( ) . equals ( arg1 . substring ( 1 , arg1 . length ( ) - 1 ) ) ) { found = true ; typeParamsIt . remove ( ) ; break ; } } } if ( ! found ) { log ( tag . getLineNo ( ) , tag . getColumnNo ( ) , MSG_UNUSED_TAG , "@param" , arg1 ) ; } } if ( ! allowMissingParamTags && reportExpectedTags ) { for ( DetailAST param : params ) { log ( param , MSG_EXCPECTED_TAG , JavadocTagInfo . PARAM . getText ( ) , param . getText ( ) ) ; } for ( DetailAST typeParam : typeParams ) { log ( typeParam , MSG_EXCPECTED_TAG , JavadocTagInfo . PARAM . getText ( ) , "<" + typeParam . findFirstToken ( TokenTypes . IDENT ) . getText ( ) + ">" ) ; } } } private boolean isFunction ( DetailAST ast ) { boolean retVal = false ; if ( ast . getType ( ) == TokenTypes . METHOD_DEF ) { final DetailAST typeAST = ast . findFirstToken ( TokenTypes . TYPE ) ; if ( typeAST != null && typeAST . findFirstToken ( TokenTypes . LITERAL_VOID ) == null ) { retVal = true ; } } return retVal ; } private void checkReturnTag ( List < JavadocTag > tags , int lineNo , boolean reportExpectedTags ) { boolean found = false ; final ListIterator < JavadocTag > it = tags . listIterator ( ) ; while ( it . hasNext ( ) ) { final JavadocTag jt = it . next ( ) ; if ( jt . isReturnTag ( ) ) { if ( found ) { log ( jt . getLineNo ( ) , jt . getColumnNo ( ) , MSG_DUPLICATE_TAG , JavadocTagInfo . RETURN . getText ( ) ) ; } found = true ; it . remove ( ) ; } } if ( ! found && ! allowMissingReturnTag && reportExpectedTags ) { log ( lineNo , MSG_RETURN_EXPECTED ) ; } } private void checkThrowsTags ( List < JavadocTag > tags , List < ExceptionInfo > throwsList , boolean reportExpectedTags ) { final Set < String > foundThrows = Sets . newHashSet ( ) ; final ListIterator < JavadocTag > tagIt = tags . listIterator ( ) ; while ( tagIt . hasNext ( ) ) { final JavadocTag tag = tagIt . next ( ) ; if ( ! tag . isThrowsTag ( ) ) { continue ; } tagIt . remove ( ) ; final String documentedEx = tag . getArg1 ( ) ; final Token token = new Token ( tag . getArg1 ( ) , tag . getLineNo ( ) , tag . getColumnNo ( ) ) ; final AbstractClassInfo documentedCI = createClassInfo ( token , getCurrentClassName ( ) ) ; boolean found = foundThrows . contains ( documentedEx ) ; ListIterator < ExceptionInfo > throwIt = throwsList . listIterator ( ) ; while ( ! found && throwIt . hasNext ( ) ) { final ExceptionInfo ei = throwIt . next ( ) ; if ( ei . getName ( ) . getText ( ) . equals ( documentedCI . getName ( ) . getText ( ) ) ) { found = true ; ei . setFound ( ) ; foundThrows . add ( documentedEx ) ; } } throwIt = throwsList . listIterator ( ) ; while ( ! found && throwIt . hasNext ( ) ) { final ExceptionInfo ei = throwIt . next ( ) ; if ( documentedCI . getClazz ( ) == ei . getClazz ( ) ) { found = true ; ei . setFound ( ) ; foundThrows . add ( documentedEx ) ; } else if ( allowThrowsTagsForSubclasses ) { found = isSubclass ( documentedCI . getClazz ( ) , ei . getClazz ( ) ) ; } } if ( ! found ) { boolean reqd = true ; if ( allowUndeclaredRTE ) { reqd = ! isUnchecked ( documentedCI . getClazz ( ) ) ; } if ( reqd && validateThrows ) { log ( tag . getLineNo ( ) , tag . getColumnNo ( ) , MSG_UNUSED_TAG , JavadocTagInfo . THROWS . getText ( ) , tag . getArg1 ( ) ) ; } } } if ( ! allowMissingThrowsTags && reportExpectedTags ) { for ( ExceptionInfo ei : throwsList ) { if ( ! ei . isFound ( ) ) { final Token fi = ei . getName ( ) ; log ( fi . getLineNo ( ) , fi . getColumnNo ( ) , MSG_EXCPECTED_TAG , JavadocTagInfo . THROWS . getText ( ) , fi . getText ( ) ) ; } } } } private boolean isSetterMethod ( final DetailAST ast ) { if ( ast . getType ( ) != TokenTypes . METHOD_DEF || ast . getChildCount ( ) != MAX_CHILDREN ) { return false ; } final DetailAST type = ast . findFirstToken ( TokenTypes . TYPE ) ; final String name = type . getNextSibling ( ) . getText ( ) ; if ( ! name . matches ( "^set[A-Z].*" ) ) { return false ; } if ( type . getChildCount ( TokenTypes . LITERAL_VOID ) == 0 ) { return false ; } final DetailAST params = ast . findFirstToken ( TokenTypes . PARAMETERS ) ; if ( params == null || params . getChildCount ( TokenTypes . PARAMETER_DEF ) != 1 ) { return false ; } final DetailAST slist = ast . findFirstToken ( TokenTypes . SLIST ) ; if ( slist == null || slist . getChildCount ( ) != BODY_SIZE ) { return false ; } final AST expr = slist . getFirstChild ( ) ; return expr . getType ( ) == TokenTypes . EXPR && expr . getFirstChild ( ) . getType ( ) == TokenTypes . ASSIGN ; } private boolean isGetterMethod ( final DetailAST ast ) { if ( ast . getType ( ) != TokenTypes . METHOD_DEF || ast . getChildCount ( ) != MAX_CHILDREN ) { return false ; } final DetailAST type = ast . findFirstToken ( TokenTypes . TYPE ) ; final String name = type . getNextSibling ( ) . getText ( ) ; if ( ! name . matches ( "^(is|get)[A-Z].*" ) ) { return false ; } if ( type . getChildCount ( TokenTypes . LITERAL_VOID ) > 0 ) { return false ; } final DetailAST params = ast . findFirstToken ( TokenTypes . PARAMETERS ) ; if ( params == null || params . getChildCount ( TokenTypes . PARAMETER_DEF ) > 0 ) { return false ; } final DetailAST slist = ast . findFirstToken ( TokenTypes . SLIST ) ; if ( slist == null || slist . getChildCount ( ) != 2 ) { return false ; } final AST expr = slist . getFirstChild ( ) ; return expr . getType ( ) == TokenTypes . LITERAL_RETURN && expr . getFirstChild ( ) . getType ( ) == TokenTypes . EXPR ; } private static class ExceptionInfo { private boolean found ; private final AbstractClassInfo classInfo ; ExceptionInfo ( AbstractClassInfo classInfo ) { this . classInfo = classInfo ; } final void setFound ( ) { found = true ; } final boolean isFound ( ) { return found ; } final Token getName ( ) { return classInfo . getName ( ) ; } final Class < ? > getClazz ( ) { return classInfo . getClazz ( ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . google . common . collect . ImmutableSortedSet ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FileContents ; import com . puppycrawl . tools . checkstyle . api . JavadocTagInfo ; import com . puppycrawl . tools . checkstyle . api . Scope ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TextBlock ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . CheckUtils ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . List ; import java . util . Locale ; import java . util . Set ; import java . util . regex . Pattern ; public class JavadocStyleCheck extends Check { public static final String JAVADOC_MISSING = "javadoc.missing" ; public static final String EMPTY = "javadoc.empty" ; public static final String NO_PERIOD = "javadoc.noperiod" ; public static final String INCOMPLETE_TAG = "javadoc.incompleteTag" ; public static final String UNCLOSED_HTML = "javadoc.unclosedhtml" ; public static final String EXTRA_HTML = "javadoc.extrahtml" ; private static final Set < String > SINGLE_TAGS = ImmutableSortedSet . of ( "br" , "li" , "dt" , "dd" , "hr" , "img" , "p" , "td" , "tr" , "th" ) ; private static final Set < String > ALLOWED_TAGS = ImmutableSortedSet . of ( "a" , "abbr" , "acronym" , "address" , "area" , "b" , "bdo" , "big" , "blockquote" , "br" , "caption" , "cite" , "code" , "colgroup" , "dd" , "del" , "div" , "dfn" , "dl" , "dt" , "em" , "fieldset" , "font" , "h1" , "h2" , "h3" , "h4" , "h5" , "h6" , "hr" , "i" , "img" , "ins" , "kbd" , "li" , "ol" , "p" , "pre" , "q" , "samp" , "small" , "span" , "strong" , "style" , "sub" , "sup" , "table" , "tbody" , "td" , "tfoot" , "th" , "thead" , "tr" , "tt" , "u" , "ul" ) ; private Scope scope = Scope . PRIVATE ; private Scope excludeScope ; private String endOfSentenceFormat = "([.?!][ \t\n\r\f<])|([.?!]$)" ; private Pattern endOfSentencePattern ; private boolean checkingFirstSentence = true ; private boolean checkingHtml = true ; private boolean checkingEmptyJavadoc ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . INTERFACE_DEF , TokenTypes . CLASS_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . ENUM_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . VARIABLE_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . ANNOTATION_FIELD_DEF , TokenTypes . PACKAGE_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . INTERFACE_DEF , TokenTypes . CLASS_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . ENUM_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . VARIABLE_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . ANNOTATION_FIELD_DEF , TokenTypes . PACKAGE_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( shouldCheck ( ast ) ) { final FileContents contents = getFileContents ( ) ; final TextBlock cmt = contents . getJavadocBefore ( ast . getFirstChild ( ) . getLineNo ( ) ) ; checkComment ( ast , cmt ) ; } } private boolean shouldCheck ( final DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . PACKAGE_DEF ) { return getFileContents ( ) . inPackageInfo ( ) ; } if ( ScopeUtils . inCodeBlock ( ast ) ) { return false ; } final Scope declaredScope ; if ( ast . getType ( ) == TokenTypes . ENUM_CONSTANT_DEF ) { declaredScope = Scope . PUBLIC ; } else { declaredScope = ScopeUtils . getScopeFromMods ( ast . findFirstToken ( TokenTypes . MODIFIERS ) ) ; } final Scope scope = ScopeUtils . inInterfaceOrAnnotationBlock ( ast ) ? Scope . PUBLIC : declaredScope ; final Scope surroundingScope = ScopeUtils . getSurroundingScope ( ast ) ; return scope . isIn ( this . scope ) && ( surroundingScope == null || surroundingScope . isIn ( this . scope ) ) && ( excludeScope == null || ! scope . isIn ( excludeScope ) || surroundingScope != null && ! surroundingScope . isIn ( excludeScope ) ) ; } private void checkComment ( final DetailAST ast , final TextBlock comment ) { if ( comment == null ) { if ( getFileContents ( ) . inPackageInfo ( ) ) { log ( ast . getLineNo ( ) , JAVADOC_MISSING ) ; } return ; } if ( checkingFirstSentence ) { checkFirstSentence ( ast , comment ) ; } if ( checkingHtml ) { checkHtml ( ast , comment ) ; } if ( checkingEmptyJavadoc ) { checkEmptyJavadoc ( comment ) ; } } private void checkFirstSentence ( final DetailAST ast , TextBlock comment ) { final String commentText = getCommentText ( comment . getText ( ) ) ; if ( commentText . length ( ) != 0 && ! getEndOfSentencePattern ( ) . matcher ( commentText ) . find ( ) && ! ( "{@inheritDoc}" . equals ( commentText ) && JavadocTagInfo . INHERIT_DOC . isValidOn ( ast ) ) ) { log ( comment . getStartLineNo ( ) , NO_PERIOD ) ; } } private void checkEmptyJavadoc ( TextBlock comment ) { final String commentText = getCommentText ( comment . getText ( ) ) ; if ( commentText . length ( ) == 0 ) { log ( comment . getStartLineNo ( ) , EMPTY ) ; } } private String getCommentText ( String ... comments ) { final StringBuffer buffer = new StringBuffer ( ) ; for ( final String line : comments ) { final int textStart = findTextStart ( line ) ; if ( textStart != - 1 ) { if ( line . charAt ( textStart ) == '@' ) { break ; } buffer . append ( line . substring ( textStart ) ) ; trimTail ( buffer ) ; buffer . append ( '\n' ) ; } } return buffer . toString ( ) . trim ( ) ; } private int findTextStart ( String line ) { int textStart = - 1 ; for ( int i = 0 ; i < line . length ( ) ; i ++ ) { if ( ! Character . isWhitespace ( line . charAt ( i ) ) ) { if ( line . regionMatches ( i , "/**" , 0 , "/**" . length ( ) ) ) { i += 2 ; } else if ( line . regionMatches ( i , "*/" , 0 , 2 ) ) { i ++ ; } else if ( line . charAt ( i ) != '*' ) { textStart = i ; break ; } } } return textStart ; } private void trimTail ( StringBuffer buffer ) { for ( int i = buffer . length ( ) - 1 ; i >= 0 ; i -- ) { if ( Character . isWhitespace ( buffer . charAt ( i ) ) ) { buffer . deleteCharAt ( i ) ; } else if ( i > 0 && buffer . charAt ( i - 1 ) == '*' && buffer . charAt ( i ) == '/' ) { buffer . deleteCharAt ( i ) ; buffer . deleteCharAt ( i - 1 ) ; i -- ; while ( buffer . charAt ( i - 1 ) == '*' ) { buffer . deleteCharAt ( i - 1 ) ; i -- ; } } else { break ; } } } private void checkHtml ( final DetailAST ast , final TextBlock comment ) { final int lineno = comment . getStartLineNo ( ) ; final Deque < HtmlTag > htmlStack = new ArrayDeque < > ( ) ; final String [ ] text = comment . getText ( ) ; TagParser parser = null ; parser = new TagParser ( text , lineno ) ; while ( parser . hasNextTag ( ) ) { final HtmlTag tag = parser . nextTag ( ) ; if ( tag . isIncompleteTag ( ) ) { log ( tag . getLineNo ( ) , INCOMPLETE_TAG , text [ tag . getLineNo ( ) - lineno ] ) ; return ; } if ( tag . isClosedTag ( ) ) { continue ; } if ( ! tag . isCloseTag ( ) ) { if ( isAllowedTag ( tag ) ) { htmlStack . push ( tag ) ; } } else { if ( isExtraHtml ( tag . getId ( ) , htmlStack ) ) { log ( tag . getLineNo ( ) , tag . getPosition ( ) , EXTRA_HTML , tag ) ; } else { checkUnclosedTags ( htmlStack , tag . getId ( ) ) ; } } } String lastFound = "" ; final List < String > typeParameters = CheckUtils . getTypeParameterNames ( ast ) ; for ( final HtmlTag htag : htmlStack ) { if ( ! isSingleTag ( htag ) && ! htag . getId ( ) . equals ( lastFound ) && ! typeParameters . contains ( htag . getId ( ) ) ) { log ( htag . getLineNo ( ) , htag . getPosition ( ) , UNCLOSED_HTML , htag ) ; lastFound = htag . getId ( ) ; } } } private void checkUnclosedTags ( Deque < HtmlTag > htmlStack , String token ) { final Deque < HtmlTag > unclosedTags = new ArrayDeque < > ( ) ; HtmlTag lastOpenTag = htmlStack . pop ( ) ; while ( ! token . equalsIgnoreCase ( lastOpenTag . getId ( ) ) ) { if ( isSingleTag ( lastOpenTag ) ) { lastOpenTag = htmlStack . pop ( ) ; } else { unclosedTags . push ( lastOpenTag ) ; lastOpenTag = htmlStack . pop ( ) ; } } String lastFound = "" ; for ( final HtmlTag htag : unclosedTags ) { lastOpenTag = htag ; if ( lastOpenTag . getId ( ) . equals ( lastFound ) ) { continue ; } lastFound = lastOpenTag . getId ( ) ; log ( lastOpenTag . getLineNo ( ) , lastOpenTag . getPosition ( ) , UNCLOSED_HTML , lastOpenTag ) ; } } private boolean isSingleTag ( HtmlTag tag ) { return SINGLE_TAGS . contains ( tag . getId ( ) . toLowerCase ( Locale . ENGLISH ) ) ; } private boolean isAllowedTag ( HtmlTag tag ) { return ALLOWED_TAGS . contains ( tag . getId ( ) . toLowerCase ( Locale . ENGLISH ) ) ; } private boolean isExtraHtml ( String token , Deque < HtmlTag > htmlStack ) { boolean isExtra = true ; for ( final HtmlTag td : htmlStack ) { if ( token . equalsIgnoreCase ( td . getId ( ) ) ) { isExtra = false ; break ; } } return isExtra ; } public void setScope ( String from ) { scope = Scope . getInstance ( from ) ; } public void setExcludeScope ( String scope ) { excludeScope = Scope . getInstance ( scope ) ; } public void setEndOfSentenceFormat ( String format ) { endOfSentenceFormat = format ; } private Pattern getEndOfSentencePattern ( ) { if ( endOfSentencePattern == null ) { endOfSentencePattern = Pattern . compile ( endOfSentenceFormat ) ; } return endOfSentencePattern ; } public void setCheckFirstSentence ( boolean flag ) { checkingFirstSentence = flag ; } public void setCheckHtml ( boolean flag ) { checkingHtml = flag ; } public void setCheckEmptyJavadoc ( boolean flag ) { checkingEmptyJavadoc = flag ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . DetailNode ; import com . puppycrawl . tools . checkstyle . api . JavadocTokenTypes ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class AtclauseOrderCheck extends AbstractJavadocCheck { public static final String MSG_KEY = "at.clause.order" ; private static final String [ ] DEFAULT_ORDER = { "@author" , "@version" , "@param" , "@return" , "@throws" , "@exception" , "@see" , "@since" , "@serial" , "@serialField" , "@serialData" , "@deprecated" , } ; private List < Integer > target = Arrays . asList ( TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . VARIABLE_DEF ) ; private List < String > tagOrder = Arrays . asList ( DEFAULT_ORDER ) ; public void setTarget ( String target ) { final List < Integer > customTarget = new ArrayList < > ( ) ; final String [ ] sTarget = target . split ( "," ) ; for ( int i = 0 ; i < sTarget . length ; i ++ ) { customTarget . add ( Utils . getTokenId ( sTarget [ i ] . trim ( ) ) ) ; } this . target = customTarget ; } public void setTagOrder ( String order ) { final List < String > customOrder = new ArrayList < > ( ) ; final String [ ] sOrder = order . split ( "," ) ; for ( int i = 0 ; i < sOrder . length ; i ++ ) { customOrder . add ( sOrder [ i ] . trim ( ) ) ; } this . tagOrder = customOrder ; } @ Override public int [ ] getDefaultJavadocTokens ( ) { return new int [ ] { JavadocTokenTypes . JAVADOC , } ; } @ Override public void visitJavadocToken ( DetailNode ast ) { final int parentType = getParentType ( getBlockCommentAst ( ) ) ; if ( target . contains ( parentType ) ) { checkOrderInTagSection ( ast ) ; } } private void checkOrderInTagSection ( DetailNode javadoc ) { int indexOrderOfPreviousTag = 0 ; int indexOrderOfCurrentTag = 0 ; for ( DetailNode node : javadoc . getChildren ( ) ) { if ( node . getType ( ) == JavadocTokenTypes . JAVADOC_TAG ) { final String tagText = JavadocUtils . getFirstChild ( node ) . getText ( ) ; indexOrderOfCurrentTag = tagOrder . indexOf ( tagText ) ; if ( tagOrder . contains ( tagText ) && indexOrderOfCurrentTag < indexOrderOfPreviousTag ) { log ( node . getLineNumber ( ) , MSG_KEY , tagOrder . toString ( ) ) ; } indexOrderOfPreviousTag = indexOrderOfCurrentTag ; } } } private int getParentType ( DetailAST commentBlock ) { int type = 0 ; final DetailAST parentNode = commentBlock . getParent ( ) ; if ( parentNode != null ) { type = parentNode . getType ( ) ; if ( type == TokenTypes . TYPE || type == TokenTypes . MODIFIERS ) { type = parentNode . getParent ( ) . getType ( ) ; } } return type ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . puppycrawl . tools . checkstyle . api . JavadocTagInfo ; public class JavadocTag { private final int lineNo ; private int columnNo ; private final String arg1 ; private final JavadocTagInfo tagInfo ; public JavadocTag ( int line , int column , String tag , String arg1 ) { lineNo = line ; columnNo = column ; this . arg1 = arg1 ; tagInfo = JavadocTagInfo . fromName ( tag ) ; } public JavadocTag ( int line , int column , String tag ) { this ( line , column , tag , null ) ; } public String getTagName ( ) { return tagInfo . getName ( ) ; } public String getArg1 ( ) { return arg1 ; } public int getLineNo ( ) { return lineNo ; } public int getColumnNo ( ) { return columnNo ; } @ Override public String toString ( ) { return "JavadocTag{tag='" + getTagName ( ) + "' lineNo=" + lineNo + ", columnNo=" + columnNo + ", arg1='" + arg1 + "'}" ; } public boolean isAuthorTag ( ) { return JavadocTagInfo . AUTHOR == tagInfo ; } public boolean isReturnTag ( ) { return JavadocTagInfo . RETURN == tagInfo ; } public boolean isParamTag ( ) { return JavadocTagInfo . PARAM == tagInfo ; } public boolean isThrowsTag ( ) { return JavadocTagInfo . THROWS == tagInfo || JavadocTagInfo . EXCEPTION == tagInfo ; } public boolean isSeeOrInheritDocTag ( ) { return JavadocTagInfo . SEE == tagInfo || isInheritDocTag ( ) ; } public boolean isInheritDocTag ( ) { return JavadocTagInfo . INHERIT_DOC == tagInfo ; } public boolean canReferenceImports ( ) { return JavadocTagInfo . SEE == tagInfo || JavadocTagInfo . LINK == tagInfo || JavadocTagInfo . LINKPLAIN == tagInfo || JavadocTagInfo . THROWS == tagInfo || JavadocTagInfo . EXCEPTION == tagInfo ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . NoLineWrapCheck . MSG_KEY ; public class NoLineWrapCheckTest extends BaseCheckTestSupport { @ Test public void testCaseWithoutLineWrapping ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NoLineWrapCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "whitespace/NoLineWrapGoodInput.java" ) , expected ) ; } @ Test public void testDefaultTokensLineWrapping ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NoLineWrapCheck . class ) ; final String [ ] expected = { "1: " + getCheckMessage ( MSG_KEY , "package" ) , "6: " + getCheckMessage ( MSG_KEY , "import" ) , } ; verify ( checkConfig , getPath ( "whitespace/NoLineWrapBadInput.java" ) , expected ) ; } @ Test public void testCustomTokensLineWrapping ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NoLineWrapCheck . class ) ; checkConfig . addAttribute ( "tokens" , "IMPORT, CLASS_DEF, METHOD_DEF, ENUM_DEF" ) ; final String [ ] expected = { "6: " + getCheckMessage ( MSG_KEY , "import" ) , "10: " + getCheckMessage ( MSG_KEY , "CLASS_DEF" ) , "13: " + getCheckMessage ( MSG_KEY , "METHOD_DEF" ) , "20: " + getCheckMessage ( MSG_KEY , "ENUM_DEF" ) , } ; verify ( checkConfig , getPath ( "whitespace/NoLineWrapBadInput.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FileContents ; import com . puppycrawl . tools . checkstyle . api . SeverityLevel ; import com . puppycrawl . tools . checkstyle . api . TextBlock ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . apache . commons . beanutils . ConversionException ; public class WriteTagCheck extends Check { public static final String MISSING_TAG = "type.missingTag" ; public static final String WRITE_TAG = "javadoc.writeTag" ; public static final String TAG_FORMAT = "type.tagFormat" ; private Pattern tagRE ; private Pattern tagFormatRE ; private String tag ; private String tagFormat ; private SeverityLevel tagSeverityLevel = SeverityLevel . INFO ; public void setTag ( String tag ) throws ConversionException { this . tag = tag ; tagRE = Utils . createPattern ( tag + "\\s*(.*$)" ) ; } public void setTagFormat ( String format ) throws ConversionException { tagFormat = format ; tagFormatRE = Utils . createPattern ( format ) ; } public final void setTagSeverity ( String severity ) { tagSeverityLevel = SeverityLevel . getInstance ( severity ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . INTERFACE_DEF , TokenTypes . CLASS_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . INTERFACE_DEF , TokenTypes . CLASS_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . ANNOTATION_FIELD_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { final FileContents contents = getFileContents ( ) ; final int lineNo = ast . getLineNo ( ) ; final TextBlock cmt = contents . getJavadocBefore ( lineNo ) ; if ( cmt == null ) { log ( lineNo , MISSING_TAG , tag ) ; } else { checkTag ( lineNo , cmt . getText ( ) , tag , tagRE , tagFormatRE , tagFormat ) ; } } private void checkTag ( int lineNo , String [ ] comment , String tag , Pattern tagRE , Pattern formatRE , String format ) { if ( tagRE == null ) { return ; } int tagCount = 0 ; for ( int i = 0 ; i < comment . length ; i ++ ) { final String s = comment [ i ] ; final Matcher matcher = tagRE . matcher ( s ) ; if ( matcher . find ( ) ) { tagCount += 1 ; final int contentStart = matcher . start ( 1 ) ; final String content = s . substring ( contentStart ) ; if ( formatRE != null && ! formatRE . matcher ( content ) . find ( ) ) { log ( lineNo + i - comment . length , TAG_FORMAT , tag , format ) ; } else { logTag ( lineNo + i - comment . length , tag , content ) ; } } } if ( tagCount == 0 ) { log ( lineNo , MISSING_TAG , tag ) ; } } protected final void logTag ( int line , String tag , String tagValue ) { final String originalSeverity = getSeverity ( ) ; setSeverity ( tagSeverityLevel . getName ( ) ) ; log ( line , WRITE_TAG , tag , tagValue ) ; setSeverity ( originalSeverity ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import java . util . ArrayList ; import java . util . List ; import com . puppycrawl . tools . checkstyle . api . DetailNode ; import com . puppycrawl . tools . checkstyle . api . JavadocTokenTypes ; public class JavadocTagContinuationIndentationCheck extends AbstractJavadocCheck { public static final String MSG_KEY = "tag.continuation.indent" ; private static final int DEFAULT_INDENTATION = 4 ; private int offset = DEFAULT_INDENTATION ; public void setOffset ( int offset ) { this . offset = offset ; } @ Override public int [ ] getDefaultJavadocTokens ( ) { return new int [ ] { JavadocTokenTypes . DESCRIPTION } ; } @ Override public void visitJavadocToken ( DetailNode ast ) { if ( isInlineDescription ( ast ) ) { return ; } final List < DetailNode > textNodes = getAllNewlineNodes ( ast ) ; for ( DetailNode newlineNode : textNodes ) { final DetailNode textNode = JavadocUtils . getNextSibling ( JavadocUtils . getNextSibling ( newlineNode ) ) ; if ( textNode != null && textNode . getType ( ) == JavadocTokenTypes . TEXT && textNode . getChildren ( ) . length > 1 ) { final DetailNode whitespace = JavadocUtils . getFirstChild ( textNode ) ; if ( whitespace . getType ( ) == JavadocTokenTypes . WS && whitespace . getText ( ) . length ( ) - 1 < offset ) { log ( textNode . getLineNumber ( ) , MSG_KEY , offset ) ; } } } } private List < DetailNode > getAllNewlineNodes ( DetailNode descriptionNode ) { final List < DetailNode > textNodes = new ArrayList < > ( ) ; DetailNode node = JavadocUtils . getFirstChild ( descriptionNode ) ; while ( JavadocUtils . getNextSibling ( node ) != null ) { if ( node . getType ( ) == JavadocTokenTypes . NEWLINE ) { textNodes . add ( node ) ; } node = JavadocUtils . getNextSibling ( node ) ; } return textNodes ; } private boolean isInlineDescription ( DetailNode description ) { DetailNode inlineTag = description . getParent ( ) ; while ( inlineTag != null ) { if ( inlineTag . getType ( ) == JavadocTokenTypes . JAVADOC_INLINE_TAG ) { return true ; } inlineTag = inlineTag . getParent ( ) ; } return false ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . puppycrawl . tools . checkstyle . api . DetailNode ; import com . puppycrawl . tools . checkstyle . api . JavadocTokenTypes ; public class NonEmptyAtclauseDescriptionCheck extends AbstractJavadocCheck { public static final String MSG_KEY = "non.empty.atclause" ; @ Override public int [ ] getDefaultJavadocTokens ( ) { return new int [ ] { JavadocTokenTypes . PARAM_LITERAL , JavadocTokenTypes . RETURN_LITERAL , JavadocTokenTypes . THROWS_LITERAL , JavadocTokenTypes . DEPRECATED_LITERAL , } ; } @ Override public void visitJavadocToken ( DetailNode ast ) { if ( isEmptyTag ( ast . getParent ( ) ) ) { log ( ast . getLineNumber ( ) , MSG_KEY , ast . getText ( ) ) ; } } private boolean isEmptyTag ( DetailNode tagNode ) { final DetailNode tagDescription = JavadocUtils . findFirstToken ( tagNode , JavadocTokenTypes . DESCRIPTION ) ; return tagDescription == null ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . puppycrawl . tools . checkstyle . api . DetailNode ; import com . puppycrawl . tools . checkstyle . api . JavadocTokenTypes ; public class JavadocParagraphCheck extends AbstractJavadocCheck { public static final String MSG_TAG_AFTER = "javadoc.paragraph.tag.after" ; public static final String MSG_LINE_BEFORE = "javadoc.paragraph.line.before" ; public static final String MSG_REDUNDANT_PARAGRAPH = "javadoc.paragraph.redundant.paragraph" ; @ Override public int [ ] getDefaultJavadocTokens ( ) { return new int [ ] { JavadocTokenTypes . NEWLINE , JavadocTokenTypes . HTML_ELEMENT , } ; } @ Override public void visitJavadocToken ( DetailNode ast ) { if ( ast . getType ( ) == JavadocTokenTypes . NEWLINE && isEmptyLine ( ast ) ) { checkEmptyLine ( ast ) ; } else if ( ast . getType ( ) == JavadocTokenTypes . HTML_ELEMENT && JavadocUtils . getFirstChild ( ast ) . getType ( ) == JavadocTokenTypes . P_TAG_OPEN ) { checkParagraphTag ( ast ) ; } } private void checkEmptyLine ( DetailNode newline ) { final DetailNode nearestToken = getNearestNode ( newline ) ; if ( ! isLastEmptyLine ( newline ) && nearestToken != null && nearestToken . getType ( ) == JavadocTokenTypes . TEXT && nearestToken . getChildren ( ) . length > 1 ) { log ( newline . getLineNumber ( ) , MSG_TAG_AFTER ) ; } } private void checkParagraphTag ( DetailNode tag ) { final DetailNode newLine = getNearestEmptyLine ( tag ) ; if ( isFirstParagraph ( tag ) ) { log ( tag . getLineNumber ( ) , MSG_REDUNDANT_PARAGRAPH ) ; } else if ( newLine == null || tag . getLineNumber ( ) - newLine . getLineNumber ( ) != 1 ) { log ( tag . getLineNumber ( ) , MSG_LINE_BEFORE ) ; } } private DetailNode getNearestNode ( DetailNode node ) { DetailNode tag = JavadocUtils . getNextSibling ( node ) ; while ( tag != null && ( tag . getType ( ) == JavadocTokenTypes . LEADING_ASTERISK || tag . getType ( ) == JavadocTokenTypes . NEWLINE ) ) { tag = JavadocUtils . getNextSibling ( tag ) ; } return tag ; } private boolean isEmptyLine ( DetailNode newLine ) { DetailNode previousSibling = JavadocUtils . getPreviousSibling ( newLine ) ; if ( previousSibling == null || previousSibling . getParent ( ) . getType ( ) != JavadocTokenTypes . JAVADOC ) { return false ; } if ( previousSibling . getType ( ) == JavadocTokenTypes . TEXT && previousSibling . getChildren ( ) . length == 1 ) { previousSibling = JavadocUtils . getPreviousSibling ( previousSibling ) ; } return previousSibling != null && previousSibling . getType ( ) == JavadocTokenTypes . LEADING_ASTERISK ; } private boolean isFirstParagraph ( DetailNode paragraphTag ) { DetailNode previousNode = JavadocUtils . getPreviousSibling ( paragraphTag ) ; while ( previousNode != null ) { if ( previousNode . getType ( ) == JavadocTokenTypes . TEXT && previousNode . getChildren ( ) . length > 1 || previousNode . getType ( ) != JavadocTokenTypes . LEADING_ASTERISK && previousNode . getType ( ) != JavadocTokenTypes . NEWLINE && previousNode . getType ( ) != JavadocTokenTypes . TEXT ) { return false ; } previousNode = JavadocUtils . getPreviousSibling ( previousNode ) ; } return true ; } private DetailNode getNearestEmptyLine ( DetailNode node ) { DetailNode newLine = JavadocUtils . getPreviousSibling ( node ) ; while ( newLine != null ) { final DetailNode previousSibling = JavadocUtils . getPreviousSibling ( newLine ) ; if ( newLine . getType ( ) == JavadocTokenTypes . NEWLINE && isEmptyLine ( newLine ) ) { break ; } newLine = previousSibling ; } return newLine ; } private boolean isLastEmptyLine ( DetailNode newLine ) { DetailNode nextNode = JavadocUtils . getNextSibling ( newLine ) ; while ( nextNode != null && nextNode . getType ( ) != JavadocTokenTypes . JAVADOC_TAG ) { if ( nextNode . getType ( ) == JavadocTokenTypes . TEXT && nextNode . getChildren ( ) . length > 1 || nextNode . getType ( ) == JavadocTokenTypes . HTML_ELEMENT ) { return false ; } nextNode = JavadocUtils . getNextSibling ( nextNode ) ; } return true ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . puppycrawl . tools . checkstyle . api . DetailNode ; import java . util . Arrays ; public class JavadocNodeImpl implements DetailNode { private int index ; private int type ; private String text ; private int lineNumber ; private int columnNumber ; private DetailNode [ ] children ; private DetailNode parent ; @ Override public int getType ( ) { return type ; } @ Override public String getText ( ) { return text ; } @ Override public int getLineNumber ( ) { return lineNumber ; } @ Override public int getColumnNumber ( ) { return columnNumber ; } @ Override public DetailNode [ ] getChildren ( ) { if ( children == null ) { return new DetailNode [ 0 ] ; } else { return Arrays . copyOf ( children , children . length ) ; } } @ Override public DetailNode getParent ( ) { return parent ; } @ Override public int getIndex ( ) { return index ; } public void setType ( int type ) { this . type = type ; } public void setText ( String text ) { this . text = text ; } public void setLineNumber ( int lineNumber ) { this . lineNumber = lineNumber ; } public void setColumnNumber ( int columnNumber ) { this . columnNumber = columnNumber ; } public void setChildren ( DetailNode ... children ) { this . children = Arrays . copyOf ( children , children . length ) ; } public void setParent ( DetailNode parent ) { this . parent = parent ; } public void setIndex ( int index ) { this . index = index ; } @ Override public String toString ( ) { return JavadocUtils . getTokenName ( getType ( ) ) + "[" + getLineNumber ( ) + "x" + getColumnNumber ( ) + "]" ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import java . util . ArrayList ; import java . util . List ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . DetailNode ; import com . puppycrawl . tools . checkstyle . api . JavadocTokenTypes ; public class SingleLineJavadocCheck extends AbstractJavadocCheck { public static final String MSG_KEY = "singleline.javadoc" ; private List < String > ignoredTags = new ArrayList < > ( ) ; private boolean ignoreInlineTags = true ; public void setIgnoredTags ( String tags ) { final List < String > ignoredTags = new ArrayList < > ( ) ; final String [ ] sTags = tags . split ( "," ) ; for ( int i = 0 ; i < sTags . length ; i ++ ) { ignoredTags . add ( sTags [ i ] . trim ( ) ) ; } this . ignoredTags = ignoredTags ; } public void setIgnoreInlineTags ( boolean ignoreInlineTags ) { this . ignoreInlineTags = ignoreInlineTags ; } @ Override public int [ ] getDefaultJavadocTokens ( ) { return new int [ ] { JavadocTokenTypes . JAVADOC , } ; } @ Override public void visitJavadocToken ( DetailNode ast ) { if ( isSingleLineJavadoc ( getBlockCommentAst ( ) ) && ( hasJavadocTags ( ast ) || ! ignoreInlineTags && hasJavadocInlineTags ( ast ) ) ) { log ( ast . getLineNumber ( ) , "singleline.javadoc" ) ; } } private static boolean isSingleLineJavadoc ( DetailAST blockCommentStart ) { final DetailAST blockCommentEnd = blockCommentStart . getLastChild ( ) ; return blockCommentStart . getLineNo ( ) == blockCommentEnd . getLineNo ( ) ; } private boolean hasJavadocTags ( DetailNode javadocRoot ) { final DetailNode javadocTagSection = JavadocUtils . findFirstToken ( javadocRoot , JavadocTokenTypes . JAVADOC_TAG ) ; return javadocTagSection != null && ! isTagIgnored ( javadocTagSection ) ; } private boolean hasJavadocInlineTags ( DetailNode javadocRoot ) { DetailNode javadocTagSection = JavadocUtils . findFirstToken ( javadocRoot , JavadocTokenTypes . JAVADOC_INLINE_TAG ) ; boolean foundTag = false ; while ( javadocTagSection != null ) { if ( ! isTagIgnored ( javadocTagSection ) ) { foundTag = true ; break ; } javadocTagSection = JavadocUtils . getNextSibling ( javadocTagSection , JavadocTokenTypes . JAVADOC_INLINE_TAG ) ; } return foundTag ; } private boolean isTagIgnored ( DetailNode javadocTagSection ) { return ignoredTags . contains ( JavadocUtils . getTagName ( javadocTagSection ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . DetailNode ; import com . puppycrawl . tools . checkstyle . api . JavadocTagInfo ; import com . puppycrawl . tools . checkstyle . api . JavadocTokenTypes ; import com . puppycrawl . tools . checkstyle . api . TextBlock ; public final class JavadocUtils { private static final ImmutableMap < String , Integer > TOKEN_NAME_TO_VALUE ; private static final String [ ] TOKEN_VALUE_TO_NAME ; static { final ImmutableMap . Builder < String , Integer > builder = ImmutableMap . builder ( ) ; final Field [ ] fields = JavadocTokenTypes . class . getDeclaredFields ( ) ; String [ ] tempTokenValueToName = new String [ 0 ] ; for ( final Field f : fields ) { if ( ! Modifier . isPublic ( f . getModifiers ( ) ) || f . getType ( ) != Integer . TYPE ) { continue ; } final String name = f . getName ( ) ; try { final int tokenValue = f . getInt ( name ) ; builder . put ( name , tokenValue ) ; if ( tokenValue > tempTokenValueToName . length - 1 ) { final String [ ] temp = new String [ tokenValue + 1 ] ; System . arraycopy ( tempTokenValueToName , 0 , temp , 0 , tempTokenValueToName . length ) ; tempTokenValueToName = temp ; } if ( tokenValue == - 1 ) { tempTokenValueToName [ 0 ] = name ; } else { tempTokenValueToName [ tokenValue ] = name ; } } catch ( IllegalAccessException ex ) { throw new IllegalStateException ( "Failed to instantiate collection of Javadoc tokens" , ex ) ; } } TOKEN_NAME_TO_VALUE = builder . build ( ) ; TOKEN_VALUE_TO_NAME = tempTokenValueToName ; } private JavadocUtils ( ) { } public static JavadocTags getJavadocTags ( TextBlock cmt , JavadocTagType tagType ) { final String [ ] text = cmt . getText ( ) ; final List < JavadocTag > tags = Lists . newArrayList ( ) ; final List < InvalidJavadocTag > invalidTags = Lists . newArrayList ( ) ; Pattern blockTagPattern = Pattern . compile ( "/\\*{2,}\\s*@(\\p{Alpha}+)\\s" ) ; for ( int i = 0 ; i < text . length ; i ++ ) { final String s = text [ i ] ; final Matcher blockTagMatcher = blockTagPattern . matcher ( s ) ; if ( ( tagType == JavadocTagType . ALL || tagType == JavadocTagType . BLOCK ) && blockTagMatcher . find ( ) ) { final String tagName = blockTagMatcher . group ( 1 ) ; String content = s . substring ( blockTagMatcher . end ( 1 ) ) ; if ( content . endsWith ( "*/" ) ) { content = content . substring ( 0 , content . length ( ) - 2 ) ; } final int line = cmt . getStartLineNo ( ) + i ; int col = blockTagMatcher . start ( 1 ) - 1 ; if ( i == 0 ) { col += cmt . getStartColNo ( ) ; } if ( JavadocTagInfo . isValidName ( tagName ) ) { tags . add ( new JavadocTag ( line , col , tagName , content . trim ( ) ) ) ; } else { invalidTags . add ( new InvalidJavadocTag ( line , col , tagName ) ) ; } } else if ( tagType == JavadocTagType . ALL || tagType == JavadocTagType . INLINE ) { final Pattern commentPattern = Pattern . compile ( "^\\s*(?:/\\*{2,}|\\*+)\\s*(.*)" ) ; final Matcher commentMatcher = commentPattern . matcher ( s ) ; final String commentContents ; final int commentOffset ; if ( ! commentMatcher . find ( ) ) { commentContents = s ; commentOffset = 0 ; } else { commentContents = commentMatcher . group ( 1 ) ; commentOffset = commentMatcher . start ( 1 ) - 1 ; } final Pattern tagPattern = Pattern . compile ( ".*?\\{@(\\p{Alpha}+)\\s+(.*?)\\}" ) ; final Matcher tagMatcher = tagPattern . matcher ( commentContents ) ; while ( tagMatcher . find ( ) ) { if ( tagMatcher . groupCount ( ) == 2 ) { final String tagName = tagMatcher . group ( 1 ) ; final String tagValue = tagMatcher . group ( 2 ) . trim ( ) ; final int line = cmt . getStartLineNo ( ) + i ; int col = commentOffset + tagMatcher . start ( 1 ) - 1 ; if ( i == 0 ) { col += cmt . getStartColNo ( ) ; } if ( JavadocTagInfo . isValidName ( tagName ) ) { tags . add ( new JavadocTag ( line , col , tagName , tagValue ) ) ; } else { invalidTags . add ( new InvalidJavadocTag ( line , col , tagName ) ) ; } } } } blockTagPattern = Pattern . compile ( "^\\s*\\**\\s*@(\\p{Alpha}+)\\s" ) ; } return new JavadocTags ( tags , invalidTags ) ; } public enum JavadocTagType { BLOCK , INLINE , ALL } public static boolean isJavadocComment ( String commentContent ) { boolean result = false ; if ( ! commentContent . isEmpty ( ) ) { final char docCommentIdentificator = commentContent . charAt ( 0 ) ; result = docCommentIdentificator == '*' ; } return result ; } public static boolean isJavadocComment ( DetailAST blockCommentBegin ) { final String commentContent = getBlockCommentContent ( blockCommentBegin ) ; return isJavadocComment ( commentContent ) ; } public static String getBlockCommentContent ( DetailAST blockCommentBegin ) { final DetailAST commentContent = blockCommentBegin . getFirstChild ( ) ; return commentContent . getText ( ) ; } public static String getJavadocCommentContent ( DetailAST javdocCommentBegin ) { final DetailAST commentContent = javdocCommentBegin . getFirstChild ( ) ; return commentContent . getText ( ) . substring ( 1 ) ; } public static DetailNode findFirstToken ( DetailNode node , int type ) { DetailNode retVal = null ; for ( DetailNode i = getFirstChild ( node ) ; i != null ; i = getNextSibling ( i ) ) { if ( i . getType ( ) == type ) { retVal = i ; break ; } } return retVal ; } public static DetailNode getFirstChild ( DetailNode node ) { return node . getChildren ( ) . length > 0 ? node . getChildren ( ) [ 0 ] : null ; } public static boolean branchContains ( DetailNode node , int type ) { DetailNode curNode = node ; while ( curNode != null ) { if ( type == curNode . getType ( ) ) { return true ; } DetailNode toVisit = getFirstChild ( curNode ) ; while ( curNode != null && toVisit == null ) { toVisit = getNextSibling ( curNode ) ; if ( toVisit == null ) { curNode = curNode . getParent ( ) ; } } if ( curNode == toVisit ) { break ; } curNode = toVisit ; } return false ; } public static DetailNode getNextSibling ( DetailNode node ) { final DetailNode parent = node . getParent ( ) ; if ( parent != null ) { final int nextSiblingIndex = node . getIndex ( ) + 1 ; final DetailNode [ ] children = parent . getChildren ( ) ; if ( nextSiblingIndex <= children . length - 1 ) { return children [ nextSiblingIndex ] ; } } return null ; } public static DetailNode getNextSibling ( DetailNode node , int tokenType ) { DetailNode nextSibling = JavadocUtils . getNextSibling ( node ) ; while ( nextSibling != null && nextSibling . getType ( ) != tokenType ) { nextSibling = JavadocUtils . getNextSibling ( nextSibling ) ; } return nextSibling ; } public static DetailNode getPreviousSibling ( DetailNode node ) { final DetailNode parent = node . getParent ( ) ; if ( parent != null ) { final int previousSiblingIndex = node . getIndex ( ) - 1 ; final DetailNode [ ] children = parent . getChildren ( ) ; if ( previousSiblingIndex >= 0 ) { return children [ previousSiblingIndex ] ; } } return null ; } public static String getTokenName ( int iD ) { if ( iD == JavadocTokenTypes . EOF ) { return "EOF" ; } if ( iD > TOKEN_VALUE_TO_NAME . length - 1 ) { throw new IllegalArgumentException ( "Unknown javdoc token id. Given id: " + iD ) ; } final String name = TOKEN_VALUE_TO_NAME [ iD ] ; if ( name == null ) { throw new IllegalArgumentException ( "Unknown javdoc token id. Given id: " + iD ) ; } return name ; } public static int getTokenId ( String name ) { final Integer id = TOKEN_NAME_TO_VALUE . get ( name ) ; if ( id == null ) { throw new IllegalArgumentException ( "Unknown javdoc token name. Given name " + name ) ; } return id . intValue ( ) ; } public static String getTagName ( DetailNode javadocTagSection ) { String javadocTagName ; if ( javadocTagSection . getType ( ) == JavadocTokenTypes . JAVADOC_INLINE_TAG ) { javadocTagName = JavadocUtils . getNextSibling ( JavadocUtils . getFirstChild ( javadocTagSection ) ) . getText ( ) ; } else { javadocTagName = JavadocUtils . getFirstChild ( javadocTagSection ) . getText ( ) ; } return javadocTagName ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FileContents ; import com . puppycrawl . tools . checkstyle . api . JavadocTagInfo ; import com . puppycrawl . tools . checkstyle . api . Scope ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TextBlock ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . checks . CheckUtils ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . apache . commons . beanutils . ConversionException ; public class JavadocTypeCheck extends Check { public static final String JAVADOC_MISSING = "javadoc.missing" ; public static final String UNKNOWN_TAG = "javadoc.unknownTag" ; public static final String TAG_FORMAT = "type.tagFormat" ; public static final String MISSING_TAG = "type.missingTag" ; public static final String UNUSED_TAG = "javadoc.unusedTag" ; public static final String UNUSED_TAG_GENERAL = "javadoc.unusedTagGeneral" ; private Scope scope = Scope . PRIVATE ; private Scope excludeScope ; private Pattern authorFormatPattern ; private Pattern versionFormatPattern ; private String authorFormat ; private String versionFormat ; private boolean allowMissingParamTags ; private boolean allowUnknownTags ; public void setScope ( String from ) { scope = Scope . getInstance ( from ) ; } public void setExcludeScope ( String scope ) { excludeScope = Scope . getInstance ( scope ) ; } public void setAuthorFormat ( String format ) throws ConversionException { authorFormat = format ; authorFormatPattern = Utils . createPattern ( format ) ; } public void setVersionFormat ( String format ) throws ConversionException { versionFormat = format ; versionFormatPattern = Utils . createPattern ( format ) ; } public void setAllowMissingParamTags ( boolean flag ) { allowMissingParamTags = flag ; } public void setAllowUnknownTags ( boolean flag ) { allowUnknownTags = flag ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . INTERFACE_DEF , TokenTypes . CLASS_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . INTERFACE_DEF , TokenTypes . CLASS_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( shouldCheck ( ast ) ) { final FileContents contents = getFileContents ( ) ; final int lineNo = ast . getLineNo ( ) ; final TextBlock cmt = contents . getJavadocBefore ( lineNo ) ; if ( cmt == null ) { log ( lineNo , JAVADOC_MISSING ) ; } else if ( ScopeUtils . isOuterMostType ( ast ) ) { final List < JavadocTag > tags = getJavadocTags ( cmt ) ; checkTag ( lineNo , tags , JavadocTagInfo . AUTHOR . getName ( ) , authorFormatPattern , authorFormat ) ; checkTag ( lineNo , tags , JavadocTagInfo . VERSION . getName ( ) , versionFormatPattern , versionFormat ) ; final List < String > typeParamNames = CheckUtils . getTypeParameterNames ( ast ) ; if ( ! allowMissingParamTags ) { for ( final String string : typeParamNames ) { checkTypeParamTag ( lineNo , tags , string ) ; } } checkUnusedTypeParamTags ( tags , typeParamNames ) ; } } } private boolean shouldCheck ( final DetailAST ast ) { final DetailAST mods = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; final Scope declaredScope = ScopeUtils . getScopeFromMods ( mods ) ; final Scope scope = ScopeUtils . inInterfaceOrAnnotationBlock ( ast ) ? Scope . PUBLIC : declaredScope ; final Scope surroundingScope = ScopeUtils . getSurroundingScope ( ast ) ; return scope . isIn ( this . scope ) && ( surroundingScope == null || surroundingScope . isIn ( this . scope ) ) && ( excludeScope == null || ! scope . isIn ( excludeScope ) || surroundingScope != null && ! surroundingScope . isIn ( excludeScope ) ) ; } private List < JavadocTag > getJavadocTags ( TextBlock cmt ) { final JavadocTags tags = JavadocUtils . getJavadocTags ( cmt , JavadocUtils . JavadocTagType . BLOCK ) ; if ( ! allowUnknownTags ) { for ( final InvalidJavadocTag tag : tags . getInvalidTags ( ) ) { log ( tag . getLine ( ) , tag . getCol ( ) , UNKNOWN_TAG , tag . getName ( ) ) ; } } return tags . getValidTags ( ) ; } private void checkTag ( int lineNo , List < JavadocTag > tags , String tagName , Pattern formatPattern , String format ) { if ( formatPattern == null ) { return ; } int tagCount = 0 ; for ( int i = tags . size ( ) - 1 ; i >= 0 ; i -- ) { final JavadocTag tag = tags . get ( i ) ; if ( tag . getTagName ( ) . equals ( tagName ) ) { tagCount ++ ; if ( ! formatPattern . matcher ( tag . getArg1 ( ) ) . find ( ) ) { log ( lineNo , TAG_FORMAT , "@" + tagName , format ) ; } } } if ( tagCount == 0 ) { log ( lineNo , MISSING_TAG , "@" + tagName ) ; } } private void checkTypeParamTag ( final int lineNo , final List < JavadocTag > tags , final String typeParamName ) { boolean found = false ; for ( int i = tags . size ( ) - 1 ; i >= 0 ; i -- ) { final JavadocTag tag = tags . get ( i ) ; if ( tag . isParamTag ( ) && tag . getArg1 ( ) != null && tag . getArg1 ( ) . indexOf ( "<" + typeParamName + ">" ) == 0 ) { found = true ; } } if ( ! found ) { log ( lineNo , MISSING_TAG , JavadocTagInfo . PARAM . getText ( ) + " <" + typeParamName + ">" ) ; } } private void checkUnusedTypeParamTags ( final List < JavadocTag > tags , final List < String > typeParamNames ) { final Pattern pattern = Pattern . compile ( "\\s*<([^>]+)>.*" ) ; for ( int i = tags . size ( ) - 1 ; i >= 0 ; i -- ) { final JavadocTag tag = tags . get ( i ) ; if ( tag . isParamTag ( ) ) { if ( tag . getArg1 ( ) != null ) { final Matcher matcher = pattern . matcher ( tag . getArg1 ( ) ) ; String typeParamName = null ; if ( matcher . matches ( ) ) { typeParamName = matcher . group ( 1 ) . trim ( ) ; if ( ! typeParamNames . contains ( typeParamName ) ) { log ( tag . getLineNo ( ) , tag . getColumnNo ( ) , UNUSED_TAG , JavadocTagInfo . PARAM . getText ( ) , "<" + typeParamName + ">" ) ; } } else { log ( tag . getLineNo ( ) , tag . getColumnNo ( ) , UNUSED_TAG_GENERAL ) ; } } else { log ( tag . getLineNo ( ) , tag . getColumnNo ( ) , UNUSED_TAG_GENERAL ) ; } } } } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import java . util . regex . Pattern ; import com . google . common . base . CharMatcher ; import com . puppycrawl . tools . checkstyle . api . DetailNode ; import com . puppycrawl . tools . checkstyle . api . JavadocTokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; public class SummaryJavadocCheck extends AbstractJavadocCheck { public static final String SUMMARY_FIRST_SENTENCE = "summary.first.sentence" ; public static final String SUMMARY_JAVADOC = "summary.javaDoc" ; private Pattern forbiddenSummaryFragments = Utils . createPattern ( "^$" ) ; private String period = "." ; public void setForbiddenSummaryFragments ( String pattern ) { forbiddenSummaryFragments = Utils . createPattern ( pattern ) ; } public void setPeriod ( String period ) { this . period = period ; } @ Override public int [ ] getDefaultJavadocTokens ( ) { return new int [ ] { JavadocTokenTypes . JAVADOC , } ; } @ Override public void visitJavadocToken ( DetailNode ast ) { String firstSentence = getFirstSentence ( ast ) ; final int endOfSentence = firstSentence . lastIndexOf ( period ) ; if ( endOfSentence == - 1 ) { log ( ast . getLineNumber ( ) , SUMMARY_FIRST_SENTENCE ) ; } else { firstSentence = firstSentence . substring ( 0 , endOfSentence ) ; if ( containsForbiddenFragment ( firstSentence ) ) { log ( ast . getLineNumber ( ) , SUMMARY_JAVADOC ) ; } } } private String getFirstSentence ( DetailNode ast ) { final StringBuilder result = new StringBuilder ( ) ; for ( DetailNode child : ast . getChildren ( ) ) { if ( child . getType ( ) != JavadocTokenTypes . JAVADOC_INLINE_TAG && child . getText ( ) . contains ( ". " ) ) { result . append ( getCharsTillDot ( child ) ) ; break ; } else { result . append ( child . getText ( ) ) ; } } return result . toString ( ) ; } private String getCharsTillDot ( DetailNode textNode ) { final StringBuilder result = new StringBuilder ( ) ; for ( DetailNode child : textNode . getChildren ( ) ) { result . append ( child . getText ( ) ) ; if ( "." . equals ( child . getText ( ) ) && JavadocUtils . getNextSibling ( child ) . getType ( ) == JavadocTokenTypes . WS ) { break ; } } return result . toString ( ) ; } private boolean containsForbiddenFragment ( String firstSentence ) { String javadocText = firstSentence . replaceAll ( "\n[ ]+(\\*)|^[ ]+(\\*)" , " " ) ; javadocText = CharMatcher . WHITESPACE . trimAndCollapseFrom ( javadocText , ' ' ) ; return forbiddenSummaryFragments . matcher ( javadocText ) . find ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; class HtmlTag { private static final int MAX_TEXT_LEN = 60 ; private final String id ; private final int lineNo ; private final int position ; private final String text ; private final boolean closedTag ; private final boolean incomplete ; HtmlTag ( String id , int lineNo , int position , boolean closedTag , boolean incomplete , String text ) { this . id = ! "" . equals ( id ) && id . charAt ( 0 ) == '/' ? id . substring ( 1 ) : id ; this . lineNo = lineNo ; this . position = position ; this . text = text ; this . closedTag = closedTag ; this . incomplete = incomplete ; } public String getId ( ) { return id ; } public boolean isCloseTag ( ) { if ( position == text . length ( ) - 1 ) { return false ; } return text . charAt ( position + 1 ) == '/' ; } public boolean isClosedTag ( ) { return closedTag ; } public boolean isIncompleteTag ( ) { return incomplete ; } public int getLineNo ( ) { return lineNo ; } public int getPosition ( ) { return position ; } @ Override public String toString ( ) { final int startOfText = position ; final int endOfText = Math . min ( startOfText + HtmlTag . MAX_TEXT_LEN , text . length ( ) ) ; return text . substring ( startOfText , endOfText ) ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . OperatorWrapCheck . LINE_NEW ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . OperatorWrapCheck . LINE_PREVIOUS ; public class OperatorWrapCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( OperatorWrapCheck . class ) ; } @ Test public void testDefault ( ) throws Exception { final String [ ] expected = { "15:19: " + getCheckMessage ( LINE_NEW , "+" ) , "16:15: " + getCheckMessage ( LINE_NEW , "-" ) , "24:18: " + getCheckMessage ( LINE_NEW , "&&" ) , "39:30: " + getCheckMessage ( LINE_NEW , "&" ) , "52:29: " + getCheckMessage ( LINE_NEW , "&" ) , } ; verify ( checkConfig , getPath ( "InputOpWrap.java" ) , expected ) ; } @ Test public void testOpWrapEOL ( ) throws Exception { checkConfig . addAttribute ( "option" , WrapOption . EOL . toString ( ) ) ; final String [ ] expected = { "18:13: " + getCheckMessage ( LINE_PREVIOUS , "-" ) , "22:13: " + getCheckMessage ( LINE_PREVIOUS , "&&" ) , "27:13: " + getCheckMessage ( LINE_PREVIOUS , "&&" ) , } ; verify ( checkConfig , getPath ( "InputOpWrap.java" ) , expected ) ; } @ Test public void testAssignEOL ( ) throws Exception { checkConfig . addAttribute ( "tokens" , "ASSIGN" ) ; checkConfig . addAttribute ( "option" , WrapOption . EOL . toString ( ) ) ; final String [ ] expected = { "33:13: " + getCheckMessage ( LINE_PREVIOUS , "=" ) , } ; verify ( checkConfig , getPath ( "InputOpWrap.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . Filter ; class DebugFilter implements Filter { private boolean called ; @ Override public boolean accept ( AuditEvent event ) { called = true ; return true ; } public boolean wasCalled ( ) { return called ; } public void resetFilter ( ) { called = false ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . nio . charset . Charset ; import java . util . HashMap ; import java . util . Map ; import org . antlr . v4 . runtime . ANTLRInputStream ; import org . antlr . v4 . runtime . BailErrorStrategy ; import org . antlr . v4 . runtime . BaseErrorListener ; import org . antlr . v4 . runtime . CommonTokenStream ; import org . antlr . v4 . runtime . ParserRuleContext ; import org . antlr . v4 . runtime . RecognitionException ; import org . antlr . v4 . runtime . Recognizer ; import org . antlr . v4 . runtime . RuleContext ; import org . antlr . v4 . runtime . Token ; import org . antlr . v4 . runtime . misc . ParseCancellationException ; import org . antlr . v4 . runtime . tree . ParseTree ; import org . antlr . v4 . runtime . tree . TerminalNode ; import com . google . common . base . CaseFormat ; import com . google . common . primitives . Ints ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . DetailNode ; import com . puppycrawl . tools . checkstyle . api . JavadocTokenTypes ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocLexer ; import com . puppycrawl . tools . checkstyle . grammars . javadoc . JavadocParser ; public abstract class AbstractJavadocCheck extends Check { public static final String PARSE_ERROR_MESSAGE_KEY = "javadoc.parse.error" ; public static final String UNRECOGNIZED_ANTLR_ERROR_MESSAGE_KEY = "javadoc.unrecognized.antlr.error" ; private static final Map < String , ParseStatus > TREE_CACHE = new HashMap < > ( ) ; private final DescriptiveErrorListener errorListener = new DescriptiveErrorListener ( ) ; private DetailAST blockCommentAst ; public abstract int [ ] getDefaultJavadocTokens ( ) ; public void beginJavadocTree ( DetailNode rootAst ) { } public void finishJavadocTree ( DetailNode rootAst ) { } public void visitJavadocToken ( DetailNode ast ) { } public void leaveJavadocToken ( DetailNode ast ) { } @ Override public final int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . BLOCK_COMMENT_BEGIN } ; } @ Override public final int [ ] getAcceptableTokens ( ) { return super . getAcceptableTokens ( ) ; } @ Override public final int [ ] getRequiredTokens ( ) { return super . getRequiredTokens ( ) ; } @ Override public final boolean isCommentNodesRequired ( ) { return true ; } @ Override public final void beginTree ( DetailAST rootAST ) { TREE_CACHE . clear ( ) ; } @ Override public final void finishTree ( DetailAST rootAST ) { TREE_CACHE . clear ( ) ; } @ Override public final void leaveToken ( DetailAST ast ) { } @ Override public final void visitToken ( DetailAST blockCommentAst ) { if ( JavadocUtils . isJavadocComment ( blockCommentAst ) ) { this . blockCommentAst = blockCommentAst ; final String treeCacheKey = blockCommentAst . getLineNo ( ) + ":" + blockCommentAst . getColumnNo ( ) ; ParseStatus ps ; if ( TREE_CACHE . containsKey ( treeCacheKey ) ) { ps = TREE_CACHE . get ( treeCacheKey ) ; } else { ps = parseJavadocAsDetailNode ( blockCommentAst ) ; TREE_CACHE . put ( treeCacheKey , ps ) ; } if ( ps . getParseErrorMessage ( ) == null ) { processTree ( ps . getTree ( ) ) ; } else { final ParseErrorMessage parseErrorMessage = ps . getParseErrorMessage ( ) ; log ( parseErrorMessage . getLineNumber ( ) , parseErrorMessage . getMessageKey ( ) , parseErrorMessage . getMessageArguments ( ) ) ; } } } protected DetailAST getBlockCommentAst ( ) { return blockCommentAst ; } private ParseStatus parseJavadocAsDetailNode ( DetailAST javadocCommentAst ) { final String javadocComment = JavadocUtils . getJavadocCommentContent ( javadocCommentAst ) ; errorListener . setOffset ( javadocCommentAst . getLineNo ( ) - 1 ) ; final ParseStatus result = new ParseStatus ( ) ; ParseTree parseTree = null ; ParseErrorMessage parseErrorMessage = null ; try { parseTree = parseJavadocAsParseTree ( javadocComment ) ; } catch ( IOException e ) { parseErrorMessage = new ParseErrorMessage ( javadocCommentAst . getLineNo ( ) , PARSE_ERROR_MESSAGE_KEY , javadocCommentAst . getColumnNo ( ) , e . getMessage ( ) ) ; } catch ( ParseCancellationException e ) { parseErrorMessage = errorListener . getErrorMessage ( ) ; if ( parseErrorMessage == null ) { parseErrorMessage = new ParseErrorMessage ( javadocCommentAst . getLineNo ( ) , UNRECOGNIZED_ANTLR_ERROR_MESSAGE_KEY , javadocCommentAst . getColumnNo ( ) , e . getMessage ( ) ) ; } } if ( parseErrorMessage == null ) { final DetailNode tree = convertParseTree2DetailNode ( parseTree ) ; result . setTree ( tree ) ; } else { result . setParseErrorMessage ( parseErrorMessage ) ; } return result ; } private DetailNode convertParseTree2DetailNode ( ParseTree parseTreeNode ) { final JavadocNodeImpl rootJavadocNode = createJavadocNode ( parseTreeNode , null , - 1 ) ; int childCount = parseTreeNode . getChildCount ( ) ; JavadocNodeImpl [ ] children = new JavadocNodeImpl [ childCount ] ; for ( int i = 0 ; i < childCount ; i ++ ) { final JavadocNodeImpl child = createJavadocNode ( parseTreeNode . getChild ( i ) , rootJavadocNode , i ) ; children [ i ] = child ; } rootJavadocNode . setChildren ( children ) ; JavadocNodeImpl currentJavadocParent = rootJavadocNode ; ParseTree parseTreeParent = parseTreeNode ; while ( currentJavadocParent != null ) { children = ( JavadocNodeImpl [ ] ) currentJavadocParent . getChildren ( ) ; childCount = children . length ; for ( int i = 0 ; i < childCount ; i ++ ) { final JavadocNodeImpl currentJavadocNode = children [ i ] ; final ParseTree currentParseTreeNodeChild = parseTreeParent . getChild ( i ) ; final JavadocNodeImpl [ ] subChildren = new JavadocNodeImpl [ currentJavadocNode . getChildren ( ) . length ] ; for ( int j = 0 ; j < subChildren . length ; j ++ ) { final JavadocNodeImpl child = createJavadocNode ( currentParseTreeNodeChild . getChild ( j ) , currentJavadocNode , j ) ; subChildren [ j ] = child ; } currentJavadocNode . setChildren ( subChildren ) ; } if ( childCount > 0 ) { currentJavadocParent = children [ 0 ] ; parseTreeParent = parseTreeParent . getChild ( 0 ) ; } else { JavadocNodeImpl nextJavadocSibling = ( JavadocNodeImpl ) JavadocUtils . getNextSibling ( currentJavadocParent ) ; ParseTree nextParseTreeSibling = getNextSibling ( parseTreeParent ) ; if ( nextJavadocSibling == null ) { JavadocNodeImpl tempJavadocParent = ( JavadocNodeImpl ) currentJavadocParent . getParent ( ) ; ParseTree tempParseTreeParent = parseTreeParent . getParent ( ) ; while ( nextJavadocSibling == null && tempJavadocParent != null ) { nextJavadocSibling = ( JavadocNodeImpl ) JavadocUtils . getNextSibling ( tempJavadocParent ) ; nextParseTreeSibling = getNextSibling ( tempParseTreeParent ) ; tempJavadocParent = ( JavadocNodeImpl ) tempJavadocParent . getParent ( ) ; tempParseTreeParent = tempParseTreeParent . getParent ( ) ; } } currentJavadocParent = nextJavadocSibling ; parseTreeParent = nextParseTreeSibling ; } } return rootJavadocNode ; } private JavadocNodeImpl createJavadocNode ( ParseTree parseTree , DetailNode parent , int index ) { final JavadocNodeImpl node = new JavadocNodeImpl ( ) ; node . setText ( parseTree . getText ( ) ) ; node . setColumnNumber ( getColumn ( parseTree ) ) ; node . setLineNumber ( getLine ( parseTree ) + blockCommentAst . getLineNo ( ) ) ; node . setIndex ( index ) ; node . setType ( getTokenType ( parseTree ) ) ; node . setParent ( parent ) ; node . setChildren ( new JavadocNodeImpl [ parseTree . getChildCount ( ) ] ) ; return node ; } private static ParseTree getNextSibling ( ParseTree node ) { if ( node . getParent ( ) == null ) { return null ; } final ParseTree parent = node . getParent ( ) ; final int childCount = parent . getChildCount ( ) ; for ( int i = 0 ; i < childCount ; i ++ ) { final ParseTree currentNode = parent . getChild ( i ) ; if ( currentNode . equals ( node ) ) { if ( i == childCount - 1 ) { return null ; } return parent . getChild ( i + 1 ) ; } } return null ; } private static int getTokenType ( ParseTree node ) { int tokenType = Integer . MIN_VALUE ; if ( node . getChildCount ( ) == 0 ) { tokenType = ( ( TerminalNode ) node ) . getSymbol ( ) . getType ( ) ; } else { final String className = getNodeClassNameWithoutContext ( node ) ; final String typeName = CaseFormat . UPPER_CAMEL . to ( CaseFormat . UPPER_UNDERSCORE , className ) ; tokenType = JavadocUtils . getTokenId ( typeName ) ; } return tokenType ; } private static String getNodeClassNameWithoutContext ( ParseTree node ) { final String className = node . getClass ( ) . getSimpleName ( ) ; final int contextLength = 7 ; return className . substring ( 0 , className . length ( ) - contextLength ) ; } private static int getLine ( ParseTree tree ) { if ( tree instanceof TerminalNode ) { return ( ( TerminalNode ) tree ) . getSymbol ( ) . getLine ( ) - 1 ; } else { final ParserRuleContext rule = ( ParserRuleContext ) tree ; return rule . start . getLine ( ) - 1 ; } } private static int getColumn ( ParseTree tree ) { if ( tree instanceof TerminalNode ) { return ( ( TerminalNode ) tree ) . getSymbol ( ) . getCharPositionInLine ( ) ; } else { final ParserRuleContext rule = ( ParserRuleContext ) tree ; return rule . start . getCharPositionInLine ( ) ; } } private ParseTree parseJavadocAsParseTree ( String blockComment ) throws IOException { final Charset utf8Charset = Charset . forName ( "UTF-8" ) ; final InputStream in = new ByteArrayInputStream ( blockComment . getBytes ( utf8Charset ) ) ; final ANTLRInputStream input = new ANTLRInputStream ( in ) ; final JavadocLexer lexer = new JavadocLexer ( input ) ; lexer . removeErrorListeners ( ) ; lexer . addErrorListener ( errorListener ) ; final CommonTokenStream tokens = new CommonTokenStream ( lexer ) ; final JavadocParser parser = new JavadocParser ( tokens ) ; parser . removeErrorListeners ( ) ; parser . addErrorListener ( errorListener ) ; parser . setErrorHandler ( new BailErrorStrategy ( ) ) ; return parser . javadoc ( ) ; } private void processTree ( DetailNode root ) { beginJavadocTree ( root ) ; walk ( root ) ; finishJavadocTree ( root ) ; } private void walk ( DetailNode root ) { final int [ ] defaultTokenTypes = getDefaultJavadocTokens ( ) ; if ( defaultTokenTypes == null ) { return ; } DetailNode curNode = root ; while ( curNode != null ) { final boolean waitsFor = Ints . contains ( defaultTokenTypes , curNode . getType ( ) ) ; if ( waitsFor ) { visitJavadocToken ( curNode ) ; } DetailNode toVisit = JavadocUtils . getFirstChild ( curNode ) ; while ( curNode != null && toVisit == null ) { if ( waitsFor ) { leaveJavadocToken ( curNode ) ; } toVisit = JavadocUtils . getNextSibling ( curNode ) ; if ( toVisit == null ) { curNode = curNode . getParent ( ) ; } } curNode = toVisit ; } } static class DescriptiveErrorListener extends BaseErrorListener { private static final String JAVADOC_PARSE_TOKEN_ERROR = "javadoc.parse.token.error" ; private static final String JAVADOC_PARSE_RULE_ERROR = "javadoc.parse.rule.error" ; private static final String JAVADOC_MISSED_HTML_CLOSE = "javadoc.missed.html.close" ; private static final String JAVADOC_WRONG_SINGLETON_TAG = "javadoc.wrong.singleton.html.tag" ; private int offset ; private ParseErrorMessage errorMessage ; public ParseErrorMessage getErrorMessage ( ) { return errorMessage ; } public void setOffset ( int offset ) { this . offset = offset ; } @ Override public void syntaxError ( Recognizer < ? , ? > recognizer , Object offendingSymbol , int line , int charPositionInLine , String msg , RecognitionException ex ) { final int lineNumber = offset + line ; final Token token = ( Token ) offendingSymbol ; if ( JAVADOC_MISSED_HTML_CLOSE . equals ( msg ) ) { errorMessage = new ParseErrorMessage ( lineNumber , JAVADOC_MISSED_HTML_CLOSE , charPositionInLine , token . getText ( ) ) ; throw new ParseCancellationException ( ) ; } else if ( JAVADOC_WRONG_SINGLETON_TAG . equals ( msg ) ) { errorMessage = new ParseErrorMessage ( lineNumber , JAVADOC_WRONG_SINGLETON_TAG , charPositionInLine , token . getText ( ) ) ; throw new ParseCancellationException ( ) ; } else { final RuleContext ruleContext = ex . getCtx ( ) ; if ( ruleContext != null ) { final int ruleIndex = ex . getCtx ( ) . getRuleIndex ( ) ; final String ruleName = recognizer . getRuleNames ( ) [ ruleIndex ] ; final String upperCaseRuleName = CaseFormat . UPPER_CAMEL . to ( CaseFormat . UPPER_UNDERSCORE , ruleName ) ; errorMessage = new ParseErrorMessage ( lineNumber , JAVADOC_PARSE_RULE_ERROR , charPositionInLine , msg , upperCaseRuleName ) ; } else { errorMessage = new ParseErrorMessage ( lineNumber , JAVADOC_PARSE_TOKEN_ERROR , charPositionInLine , msg , charPositionInLine ) ; } } } } private static class ParseStatus { private DetailNode tree ; private ParseErrorMessage parseErrorMessage ; public DetailNode getTree ( ) { return tree ; } public void setTree ( DetailNode tree ) { this . tree = tree ; } public ParseErrorMessage getParseErrorMessage ( ) { return parseErrorMessage ; } public void setParseErrorMessage ( ParseErrorMessage parseErrorMessage ) { this . parseErrorMessage = parseErrorMessage ; } } private static class ParseErrorMessage { private int lineNumber ; private String messageKey ; private Object [ ] messageArguments ; public ParseErrorMessage ( int lineNumber , String messageKey , Object ... messageArguments ) { this . lineNumber = lineNumber ; this . messageKey = messageKey ; this . messageArguments = messageArguments ; } public int getLineNumber ( ) { return lineNumber ; } public String getMessageKey ( ) { return messageKey ; } public Object [ ] getMessageArguments ( ) { return messageArguments . clone ( ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FileContents ; import com . puppycrawl . tools . checkstyle . api . Scope ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TextBlock ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . regex . Pattern ; public class JavadocVariableCheck extends Check { public static final String JAVADOC_MISSING = "javadoc.missing" ; private Scope scope = Scope . PRIVATE ; private Scope excludeScope ; private String ignoreNameRegexp ; private Pattern ignoreNamePattern ; public void setScope ( String from ) { scope = Scope . getInstance ( from ) ; } public void setExcludeScope ( String scope ) { excludeScope = Scope . getInstance ( scope ) ; } public void setIgnoreNamePattern ( String regexp ) { ignoreNameRegexp = regexp ; if ( ! ( regexp == null || regexp . length ( ) == 0 ) ) { ignoreNamePattern = Utils . createPattern ( regexp ) ; } else { ignoreNamePattern = null ; } } public String getIgnoreNamePattern ( ) { return ignoreNameRegexp ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . ENUM_CONSTANT_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . ENUM_CONSTANT_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( shouldCheck ( ast ) ) { final FileContents contents = getFileContents ( ) ; final TextBlock cmt = contents . getJavadocBefore ( ast . getLineNo ( ) ) ; if ( cmt == null ) { log ( ast , JAVADOC_MISSING ) ; } } } private boolean isIgnored ( DetailAST ast ) { final String name = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; return ignoreNamePattern != null && ignoreNamePattern . matcher ( name ) . matches ( ) ; } private boolean shouldCheck ( final DetailAST ast ) { if ( ScopeUtils . inCodeBlock ( ast ) || isIgnored ( ast ) ) { return false ; } final Scope scope ; if ( ast . getType ( ) == TokenTypes . ENUM_CONSTANT_DEF ) { scope = Scope . PUBLIC ; } else { final DetailAST mods = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; final Scope declaredScope = ScopeUtils . getScopeFromMods ( mods ) ; scope = ScopeUtils . inInterfaceOrAnnotationBlock ( ast ) ? Scope . PUBLIC : declaredScope ; } final Scope surroundingScope = ScopeUtils . getSurroundingScope ( ast ) ; return scope . isIn ( this . scope ) && surroundingScope . isIn ( this . scope ) && ( excludeScope == null || ! scope . isIn ( excludeScope ) || ! surroundingScope . isIn ( excludeScope ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . AbstractFileSetCheck ; import java . io . File ; import java . util . List ; import java . util . Set ; public class JavadocPackageCheck extends AbstractFileSetCheck { public static final String MSG_LEGACY_PACKAGE_HTML = "javadoc.legacyPackageHtml" ; public static final String MSG_PACKAGE_INFO = "javadoc.packageInfo" ; private boolean allowLegacy ; private final Set < File > directoriesChecked = Sets . newHashSet ( ) ; public JavadocPackageCheck ( ) { setFileExtensions ( "java" ) ; } @ Override public void beginProcessing ( String charset ) { super . beginProcessing ( charset ) ; directoriesChecked . clear ( ) ; } @ Override protected void processFiltered ( File file , List < String > lines ) { final File dir = file . getParentFile ( ) ; if ( directoriesChecked . contains ( dir ) ) { return ; } directoriesChecked . add ( dir ) ; final File packageInfo = new File ( dir , "package-info.java" ) ; final File packageHtml = new File ( dir , "package.html" ) ; if ( packageInfo . exists ( ) ) { if ( packageHtml . exists ( ) ) { log ( 0 , MSG_LEGACY_PACKAGE_HTML ) ; } } else if ( ! allowLegacy || ! packageHtml . exists ( ) ) { log ( 0 , MSG_PACKAGE_INFO ) ; } } public void setAllowLegacy ( boolean allowLegacy ) { this . allowLegacy = allowLegacy ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import java . util . List ; public final class JavadocTags { private final List < JavadocTag > validTags ; private final List < InvalidJavadocTag > invalidTags ; public JavadocTags ( List < JavadocTag > tags , List < InvalidJavadocTag > invalidTags ) { validTags = tags ; this . invalidTags = invalidTags ; } public List < JavadocTag > getValidTags ( ) { return validTags ; } public List < InvalidJavadocTag > getInvalidTags ( ) { return invalidTags ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; public final class InvalidJavadocTag { private final int line ; private final int col ; private final String name ; public InvalidJavadocTag ( int line , int col , String name ) { this . line = line ; this . col = col ; this . name = name ; } public int getLine ( ) { return line ; } public int getCol ( ) { return col ; } public String getName ( ) { return name ; } }
package com . puppycrawl . tools . checkstyle . checks . javadoc ; import com . google . common . collect . Lists ; import java . util . List ; class TagParser { private final List < HtmlTag > tags = Lists . newLinkedList ( ) ; public TagParser ( String [ ] text , int lineNo ) { parseTags ( text , lineNo ) ; } public HtmlTag nextTag ( ) { return tags . remove ( 0 ) ; } public boolean hasNextTag ( ) { return ! tags . isEmpty ( ) ; } private void add ( HtmlTag tag ) { tags . add ( tag ) ; } private void parseTags ( String [ ] text , int lineNo ) { final int nLines = text . length ; Point position = new Point ( 0 , 0 ) ; position = findChar ( text , '<' , position ) ; while ( position . getLineNo ( ) < nLines ) { if ( isCommentTag ( text , position ) ) { position = skipHtmlComment ( text , position ) ; } else if ( ! isTag ( text , position ) ) { position = getNextCharPos ( text , position ) ; } else { final Point endTag = findChar ( text , '>' , position ) ; final boolean incompleteTag = endTag . getLineNo ( ) >= nLines ; final String tagId = incompleteTag ? "" : getTagId ( text , position ) ; final boolean closedTag = endTag . getLineNo ( ) < nLines && endTag . getColumnNo ( ) > 0 && text [ endTag . getLineNo ( ) ] . charAt ( endTag . getColumnNo ( ) - 1 ) == '/' ; add ( new HtmlTag ( tagId , position . getLineNo ( ) + lineNo , position . getColumnNo ( ) , closedTag , incompleteTag , text [ position . getLineNo ( ) ] ) ) ; position = endTag ; } position = findChar ( text , '<' , position ) ; } } private boolean isTag ( String [ ] javadocText , Point pos ) { final int column = pos . getColumnNo ( ) + 1 ; final String text = javadocText [ pos . getLineNo ( ) ] ; return column < text . length ( ) && ( Character . isJavaIdentifierStart ( text . charAt ( column ) ) || Character . isJavaIdentifierPart ( text . charAt ( column ) ) || text . charAt ( column ) == '/' ) || column >= text . length ( ) ; } private String getTagId ( String [ ] javadocText , Point tagStart ) { int column = tagStart . getColumnNo ( ) + 1 ; String text = javadocText [ tagStart . getLineNo ( ) ] ; if ( column >= text . length ( ) ) { return "" ; } if ( text . charAt ( column ) == '/' ) { column ++ ; } text = text . substring ( column ) . trim ( ) ; column = 0 ; while ( column < text . length ( ) && ( Character . isJavaIdentifierStart ( text . charAt ( column ) ) || Character . isJavaIdentifierPart ( text . charAt ( column ) ) ) ) { column ++ ; } return text . substring ( 0 , column ) ; } private boolean isCommentTag ( String [ ] text , Point pos ) { return text [ pos . getLineNo ( ) ] . startsWith ( "<!--" , pos . getColumnNo ( ) ) ; } private Point skipHtmlComment ( String [ ] text , Point from ) { Point to = from ; to = findChar ( text , '>' , to ) ; while ( to . getLineNo ( ) < text . length && ! text [ to . getLineNo ( ) ] . substring ( 0 , to . getColumnNo ( ) + 1 ) . endsWith ( "-->" ) ) { to = findChar ( text , '>' , getNextCharPos ( text , to ) ) ; } return to ; } private Point findChar ( String [ ] text , char character , Point from ) { Point curr = new Point ( from . getLineNo ( ) , from . getColumnNo ( ) ) ; while ( curr . getLineNo ( ) < text . length && text [ curr . getLineNo ( ) ] . charAt ( curr . getColumnNo ( ) ) != character ) { curr = getNextCharPos ( text , curr ) ; } return curr ; } private Point getNextCharPos ( String [ ] text , Point from ) { int line = from . getLineNo ( ) ; int column = from . getColumnNo ( ) + 1 ; while ( line < text . length && column >= text [ line ] . length ( ) ) { line ++ ; column = 0 ; if ( line < text . length ) { final String currentLine = text [ line ] ; while ( column < currentLine . length ( ) && ( Character . isWhitespace ( currentLine . charAt ( column ) ) || currentLine . charAt ( column ) == '*' ) ) { column ++ ; if ( column < currentLine . length ( ) && currentLine . charAt ( column - 1 ) == '*' && currentLine . charAt ( column ) == '/' ) { column = currentLine . length ( ) ; } } } } return new Point ( line , column ) ; } private static final class Point { private final int line ; private final int column ; public Point ( int lineNo , int columnNo ) { line = lineNo ; column = columnNo ; } public int getLineNo ( ) { return line ; } public int getColumnNo ( ) { return column ; } } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FileContents ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TextBlock ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocTag ; import com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocUtils ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UnusedImportsCheck extends Check { public static final String MSG_KEY = "import.unused" ; private static final Pattern CLASS_NAME = Pattern . compile ( "((:?[\\p{L}_$][\\p{L}\\p{N}_$]*\\.)*[\\p{L}_$][\\p{L}\\p{N}_$]*)" ) ; private static final Pattern FIRST_CLASS_NAME = Pattern . compile ( "^" + CLASS_NAME ) ; private static final Pattern ARGUMENT_NAME = Pattern . compile ( "[(,]\\s*" + CLASS_NAME . pattern ( ) ) ; private boolean collect ; private boolean processingJavadoc ; private final Set < FullIdent > imports = Sets . newHashSet ( ) ; private final Set < String > referenced = Sets . newHashSet ( ) ; public void setProcessJavadoc ( boolean value ) { processingJavadoc = value ; } @ Override public void beginTree ( DetailAST rootAST ) { collect = false ; imports . clear ( ) ; referenced . clear ( ) ; } @ Override public void finishTree ( DetailAST rootAST ) { for ( final FullIdent imp : imports ) { if ( ! referenced . contains ( Utils . baseClassname ( imp . getText ( ) ) ) ) { log ( imp . getLineNo ( ) , imp . getColumnNo ( ) , MSG_KEY , imp . getText ( ) ) ; } } } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . IDENT , TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT , TokenTypes . PACKAGE_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . ANNOTATION_FIELD_DEF , TokenTypes . ENUM_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . VARIABLE_DEF , } ; } @ Override public int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . IDENT , TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT , TokenTypes . PACKAGE_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . ANNOTATION_FIELD_DEF , TokenTypes . ENUM_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . VARIABLE_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . IDENT ) { if ( collect ) { processIdent ( ast ) ; } } else if ( ast . getType ( ) == TokenTypes . IMPORT ) { processImport ( ast ) ; } else if ( ast . getType ( ) == TokenTypes . STATIC_IMPORT ) { processStaticImport ( ast ) ; } else { collect = true ; if ( processingJavadoc ) { processJavadoc ( ast ) ; } } } private void processIdent ( DetailAST ast ) { final DetailAST parent = ast . getParent ( ) ; final int parentType = parent . getType ( ) ; if ( parentType != TokenTypes . DOT && parentType != TokenTypes . METHOD_DEF || parentType == TokenTypes . DOT && ast . getNextSibling ( ) != null ) { referenced . add ( ast . getText ( ) ) ; } } private void processImport ( DetailAST ast ) { final FullIdent name = FullIdent . createFullIdentBelow ( ast ) ; if ( ! name . getText ( ) . endsWith ( ".*" ) ) { imports . add ( name ) ; } } private void processStaticImport ( DetailAST ast ) { final FullIdent name = FullIdent . createFullIdent ( ast . getFirstChild ( ) . getNextSibling ( ) ) ; if ( ! name . getText ( ) . endsWith ( ".*" ) ) { imports . add ( name ) ; } } private void processJavadoc ( DetailAST ast ) { final FileContents contents = getFileContents ( ) ; final int lineNo = ast . getLineNo ( ) ; final TextBlock cmt = contents . getJavadocBefore ( lineNo ) ; if ( cmt != null ) { referenced . addAll ( processJavadoc ( cmt ) ) ; } } private Set < String > processJavadoc ( TextBlock cmt ) { final Set < String > references = new HashSet < > ( ) ; for ( final JavadocTag tag : getValidTags ( cmt , JavadocUtils . JavadocTagType . INLINE ) ) { if ( tag . canReferenceImports ( ) ) { references . addAll ( processJavadocTag ( tag ) ) ; } } for ( final JavadocTag tag : getValidTags ( cmt , JavadocUtils . JavadocTagType . BLOCK ) ) { if ( tag . canReferenceImports ( ) ) { references . addAll ( matchPattern ( tag . getArg1 ( ) , FIRST_CLASS_NAME ) ) ; } } return references ; } private List < JavadocTag > getValidTags ( TextBlock cmt , JavadocUtils . JavadocTagType tagType ) { return JavadocUtils . getJavadocTags ( cmt , tagType ) . getValidTags ( ) ; } private Set < String > processJavadocTag ( JavadocTag tag ) { final Set < String > references = new HashSet < > ( ) ; final String identifier = tag . getArg1 ( ) . trim ( ) ; for ( Pattern pattern : new Pattern [ ] { FIRST_CLASS_NAME , ARGUMENT_NAME } ) { references . addAll ( matchPattern ( identifier , pattern ) ) ; } return references ; } private Set < String > matchPattern ( String identifier , Pattern pattern ) { final Set < String > references = new HashSet < > ( ) ; final Matcher matcher = pattern . matcher ( identifier ) ; while ( matcher . find ( ) ) { references . add ( matcher . group ( 1 ) ) ; } return references ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ;
package com . puppycrawl . tools . checkstyle . checks . imports ; class Guard { private final boolean allowed ; private final String pkgName ; private final String className ; private final boolean exactMatch ; private final boolean localOnly ; private final boolean regExp ; Guard ( final boolean allow , final boolean localOnly , final String pkgName , final boolean exactMatch , final boolean regExp ) { allowed = allow ; this . localOnly = localOnly ; this . pkgName = pkgName ; this . regExp = regExp ; className = null ; this . exactMatch = exactMatch ; } Guard ( final boolean allow , final boolean localOnly , final String className , final boolean regExp ) { allowed = allow ; this . localOnly = localOnly ; this . regExp = regExp ; pkgName = null ; this . className = className ; exactMatch = true ; } AccessResult verifyImport ( final String forImport ) { if ( className != null ) { final boolean classMatch = regExp ? forImport . matches ( className ) : forImport . equals ( className ) ; return calculateResult ( classMatch ) ; } boolean pkgMatch ; if ( regExp ) { pkgMatch = forImport . matches ( pkgName + "\\..*" ) ; if ( pkgMatch && exactMatch ) { pkgMatch = ! forImport . matches ( pkgName + "\\..*\\..*" ) ; } } else { pkgMatch = forImport . startsWith ( pkgName + "." ) ; if ( pkgMatch && exactMatch ) { pkgMatch = forImport . indexOf ( '.' , pkgName . length ( ) + 1 ) == - 1 ; } } return calculateResult ( pkgMatch ) ; } boolean isLocalOnly ( ) { return localOnly ; } private AccessResult calculateResult ( final boolean matched ) { if ( matched ) { return allowed ? AccessResult . ALLOWED : AccessResult . DISALLOWED ; } return AccessResult . UNKNOWN ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; enum AccessResult { ALLOWED , DISALLOWED , UNKNOWN }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . WhitespaceAroundCheck . WS_NOT_FOLLOWED ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . WhitespaceAroundCheck . WS_NOT_PRECEDED ; public class WhitespaceAroundTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( WhitespaceAroundCheck . class ) ; } @ Test public void testIt ( ) throws Exception { final String [ ] expected = { "16:22: " + getCheckMessage ( WS_NOT_PRECEDED , "=" ) , "16:23: " + getCheckMessage ( WS_NOT_FOLLOWED , "=" ) , "18:24: " + getCheckMessage ( WS_NOT_FOLLOWED , "=" ) , "26:14: " + getCheckMessage ( WS_NOT_PRECEDED , "=" ) , "27:10: " + getCheckMessage ( WS_NOT_PRECEDED , "=" ) , "27:11: " + getCheckMessage ( WS_NOT_FOLLOWED , "=" ) , "28:10: " + getCheckMessage ( WS_NOT_PRECEDED , "+=" ) , "28:12: " + getCheckMessage ( WS_NOT_FOLLOWED , "+=" ) , "29:13: " + getCheckMessage ( WS_NOT_FOLLOWED , "-=" ) , "37:21: " + getCheckMessage ( WS_NOT_FOLLOWED , "synchronized" ) , "39:12: " + getCheckMessage ( WS_NOT_FOLLOWED , "try" ) , "39:12: " + getCheckMessage ( WS_NOT_PRECEDED , "{" ) , "41:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "catch" ) , "41:34: " + getCheckMessage ( WS_NOT_PRECEDED , "{" ) , "58:11: " + getCheckMessage ( WS_NOT_FOLLOWED , "if" ) , "76:19: " + getCheckMessage ( WS_NOT_FOLLOWED , "return" ) , "97:29: " + getCheckMessage ( WS_NOT_PRECEDED , "?" ) , "97:30: " + getCheckMessage ( WS_NOT_FOLLOWED , "?" ) , "97:34: " + getCheckMessage ( WS_NOT_PRECEDED , ":" ) , "97:35: " + getCheckMessage ( WS_NOT_FOLLOWED , ":" ) , "98:15: " + getCheckMessage ( WS_NOT_PRECEDED , "==" ) , "98:17: " + getCheckMessage ( WS_NOT_FOLLOWED , "==" ) , "104:20: " + getCheckMessage ( WS_NOT_FOLLOWED , "*" ) , "104:21: " + getCheckMessage ( WS_NOT_PRECEDED , "*" ) , "119:18: " + getCheckMessage ( WS_NOT_PRECEDED , "%" ) , "120:20: " + getCheckMessage ( WS_NOT_FOLLOWED , "%" ) , "121:18: " + getCheckMessage ( WS_NOT_PRECEDED , "%" ) , "121:19: " + getCheckMessage ( WS_NOT_FOLLOWED , "%" ) , "123:18: " + getCheckMessage ( WS_NOT_PRECEDED , "/" ) , "124:20: " + getCheckMessage ( WS_NOT_FOLLOWED , "/" ) , "125:18: " + getCheckMessage ( WS_NOT_PRECEDED , "/" ) , "125:19: " + getCheckMessage ( WS_NOT_FOLLOWED , "/" ) , "153:15: " + getCheckMessage ( WS_NOT_FOLLOWED , "assert" ) , "156:20: " + getCheckMessage ( WS_NOT_PRECEDED , ":" ) , "156:21: " + getCheckMessage ( WS_NOT_FOLLOWED , ":" ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void testIt2 ( ) throws Exception { final String [ ] expected = { "153:27: " + getCheckMessage ( WS_NOT_FOLLOWED , "=" ) , "154:27: " + getCheckMessage ( WS_NOT_FOLLOWED , "=" ) , "155:27: " + getCheckMessage ( WS_NOT_FOLLOWED , "=" ) , "156:27: " + getCheckMessage ( WS_NOT_FOLLOWED , "=" ) , "157:27: " + getCheckMessage ( WS_NOT_FOLLOWED , "=" ) , "158:27: " + getCheckMessage ( WS_NOT_FOLLOWED , "=" ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testIt3 ( ) throws Exception { final String [ ] expected = { "41:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "while" ) , "58:12: " + getCheckMessage ( WS_NOT_FOLLOWED , "for" ) , "115:27: " + getCheckMessage ( WS_NOT_FOLLOWED , "{" ) , "115:27: " + getCheckMessage ( WS_NOT_PRECEDED , "}" ) , "118:40: " + getCheckMessage ( WS_NOT_FOLLOWED , "{" ) , "118:40: " + getCheckMessage ( WS_NOT_PRECEDED , "}" ) , } ; verify ( checkConfig , getPath ( "InputBraces.java" ) , expected ) ; } @ Test public void testIt4 ( ) throws Exception { checkConfig . addAttribute ( "allowEmptyMethods" , "true" ) ; checkConfig . addAttribute ( "allowEmptyConstructors" , "true" ) ; final String [ ] expected = { "41:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "while" ) , "58:12: " + getCheckMessage ( WS_NOT_FOLLOWED , "for" ) , } ; verify ( checkConfig , getPath ( "InputBraces.java" ) , expected ) ; } @ Test public void testGenericsTokensAreFlagged ( ) throws Exception { final String [ ] expected = { "6:67: " + getCheckMessage ( WS_NOT_PRECEDED , "&" ) , "6:68: " + getCheckMessage ( WS_NOT_FOLLOWED , "&" ) , } ; verify ( checkConfig , getPath ( "InputGenerics.java" ) , expected ) ; } @ Test public void test1322879And1649038 ( ) throws Exception { final String [ ] expected = { } ; verify ( checkConfig , getPath ( "whitespace/InputWhitespaceAround.java" ) , expected ) ; } @ Test public void testIgnoreEnhancedForColon ( ) throws Exception { checkConfig . addAttribute ( "ignoreEnhancedForColon" , "false" ) ; final String [ ] expected = { "19:20: " + getCheckMessage ( WS_NOT_PRECEDED , ":" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputWhitespaceAround.java" ) , expected ) ; } @ Test public void testEmptyTypes ( ) throws Exception { checkConfig . addAttribute ( "allowEmptyTypes" , "true" ) ; final String [ ] expected = { "29:95: " + getCheckMessage ( WS_NOT_FOLLOWED , "{" ) , "29:95: " + getCheckMessage ( WS_NOT_PRECEDED , "}" ) , "30:33: " + getCheckMessage ( WS_NOT_FOLLOWED , "{" ) , "30:33: " + getCheckMessage ( WS_NOT_PRECEDED , "}" ) , "31:21: " + getCheckMessage ( WS_NOT_FOLLOWED , "{" ) , "31:21: " + getCheckMessage ( WS_NOT_PRECEDED , "}" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputEmptyTypesAndCycles.java" ) , expected ) ; } @ Test public void testEmptyLoops ( ) throws Exception { checkConfig . addAttribute ( "allowEmptyLoops" , "true" ) ; final String [ ] expected = { "40:65: " + getCheckMessage ( WS_NOT_FOLLOWED , "{" ) , "40:65: " + getCheckMessage ( WS_NOT_PRECEDED , "}" ) , "42:17: " + getCheckMessage ( WS_NOT_FOLLOWED , "{" ) , "42:17: " + getCheckMessage ( WS_NOT_PRECEDED , "}" ) , "44:20: " + getCheckMessage ( WS_NOT_FOLLOWED , "{" ) , "44:20: " + getCheckMessage ( WS_NOT_PRECEDED , "}" ) , "50:44: " + getCheckMessage ( WS_NOT_FOLLOWED , "{" ) , "50:44: " + getCheckMessage ( WS_NOT_PRECEDED , "}" ) , "60:18: " + getCheckMessage ( WS_NOT_FOLLOWED , "{" ) , "60:18: " + getCheckMessage ( WS_NOT_PRECEDED , "}" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputEmptyTypesAndCycles.java" ) , expected ) ; } @ Test public void testSwitchWhitespaceAround ( ) throws Exception { final String [ ] expected = { "6:15: " + getCheckMessage ( WS_NOT_FOLLOWED , "switch" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputSwitchWhitespaceAround.java" ) , expected ) ; } @ Test public void testDoWhileWhitespaceAround ( ) throws Exception { final String [ ] expected = { "9:16: " + getCheckMessage ( WS_NOT_FOLLOWED , "while" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputDoWhileWhitespaceAround.java" ) , expected ) ; } @ Test public void allowEmptyMethods ( ) throws Exception { checkConfig . addAttribute ( "allowEmptyMethods" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "whitespace/InputWhitespaceAround.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; public enum ImportOrderOption { TOP , ABOVE , INFLOW , UNDER , BOTTOM }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . google . common . collect . Lists ; import java . util . Deque ; import java . util . List ; class PkgControl { private final Deque < Guard > guards = Lists . newLinkedList ( ) ; private final List < PkgControl > children = Lists . newArrayList ( ) ; private final PkgControl parent ; private final String fullPackage ; PkgControl ( final String pkgName ) { parent = null ; fullPackage = pkgName ; } PkgControl ( final PkgControl parent , final String subPkg ) { this . parent = parent ; fullPackage = parent . getFullPackage ( ) + "." + subPkg ; parent . children . add ( this ) ; } void addGuard ( final Guard thug ) { guards . addFirst ( thug ) ; } String getFullPackage ( ) { return fullPackage ; } PkgControl locateFinest ( final String forPkg ) { if ( ! forPkg . startsWith ( getFullPackage ( ) ) ) { return null ; } for ( PkgControl pc : children ) { final PkgControl match = pc . locateFinest ( forPkg ) ; if ( match != null ) { return match ; } } return this ; } AccessResult checkAccess ( final String forImport , final String inPkg ) { final AccessResult retVal = localCheckAccess ( forImport , inPkg ) ; if ( retVal != AccessResult . UNKNOWN ) { return retVal ; } else if ( parent == null ) { return AccessResult . DISALLOWED ; } return parent . checkAccess ( forImport , inPkg ) ; } private AccessResult localCheckAccess ( final String forImport , final String inPkg ) { for ( Guard g : guards ) { if ( g . isLocalOnly ( ) && ! fullPackage . equals ( inPkg ) ) { continue ; } final AccessResult result = g . verifyImport ( forImport ) ; if ( result != AccessResult . UNKNOWN ) { return result ; } } return AccessResult . UNKNOWN ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import java . util . List ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class AvoidStarImportCheck extends Check { public static final String MSG_KEY = "import.avoidStar" ; private final List < String > excludes = Lists . newArrayList ( ) ; private boolean allowClassImports ; private boolean allowStaticMemberImports ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT } ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT } ; } public void setExcludes ( String ... excludesParam ) { excludes . clear ( ) ; for ( final String exclude : excludesParam ) { excludes . add ( exclude . endsWith ( ".*" ) ? exclude : exclude + ".*" ) ; } } public void setAllowClassImports ( boolean allow ) { allowClassImports = allow ; } public void setAllowStaticMemberImports ( boolean allow ) { allowStaticMemberImports = allow ; } @ Override public void visitToken ( final DetailAST ast ) { if ( ! allowClassImports && TokenTypes . IMPORT == ast . getType ( ) ) { final DetailAST startingDot = ast . getFirstChild ( ) ; logsStarredImportViolation ( startingDot ) ; } else if ( ! allowStaticMemberImports && TokenTypes . STATIC_IMPORT == ast . getType ( ) ) { final DetailAST startingDot = ast . getFirstChild ( ) . getNextSibling ( ) ; logsStarredImportViolation ( startingDot ) ; } } private void logsStarredImportViolation ( DetailAST startingDot ) { final FullIdent name = FullIdent . createFullIdent ( startingDot ) ; final String importText = name . getText ( ) ; if ( importText . endsWith ( ".*" ) && ! excludes . contains ( importText ) ) { log ( startingDot . getLineNo ( ) , MSG_KEY , importText ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . AbstractOptionCheck ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class ImportOrderCheck extends AbstractOptionCheck < ImportOrderOption > { public static final String MSG_SEPARATION = "import.separation" ; public static final String MSG_ORDERING = "import.ordering" ; private static final String WILDCARD_GROUP_NAME = "*" ; private Pattern [ ] groups = new Pattern [ 0 ] ; private boolean separated ; private boolean ordered = true ; private boolean caseSensitive = true ; private int lastGroup ; private int lastImportLine ; private String lastImport ; private boolean lastImportStatic ; private boolean beforeFirstImport ; private boolean sortStaticImportsAlphabetically ; public ImportOrderCheck ( ) { super ( ImportOrderOption . UNDER , ImportOrderOption . class ) ; } public void setGroups ( String ... packageGroups ) { groups = new Pattern [ packageGroups . length ] ; for ( int i = 0 ; i < packageGroups . length ; i ++ ) { String pkg = packageGroups [ i ] ; Pattern grp ; if ( WILDCARD_GROUP_NAME . equals ( pkg ) ) { grp = Pattern . compile ( "" ) ; } else if ( Utils . startsWithChar ( pkg , '/' ) ) { if ( ! Utils . endsWithChar ( pkg , '/' ) ) { throw new IllegalArgumentException ( "Invalid group" ) ; } pkg = pkg . substring ( 1 , pkg . length ( ) - 1 ) ; grp = Pattern . compile ( pkg ) ; } else { if ( ! Utils . endsWithChar ( pkg , '.' ) ) { pkg = pkg + "." ; } grp = Pattern . compile ( "^" + Pattern . quote ( pkg ) ) ; } groups [ i ] = grp ; } } public void setOrdered ( boolean ordered ) { this . ordered = ordered ; } public void setSeparated ( boolean separated ) { this . separated = separated ; } public void setCaseSensitive ( boolean caseSensitive ) { this . caseSensitive = caseSensitive ; } public void setSortStaticImportsAlphabetically ( boolean sortAlphabetically ) { this . sortStaticImportsAlphabetically = sortAlphabetically ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT } ; } @ Override public void beginTree ( DetailAST rootAST ) { lastGroup = Integer . MIN_VALUE ; lastImportLine = Integer . MIN_VALUE ; lastImport = "" ; lastImportStatic = false ; beforeFirstImport = true ; } @ Override public void visitToken ( DetailAST ast ) { final FullIdent ident ; final boolean isStatic ; if ( ast . getType ( ) == TokenTypes . IMPORT ) { ident = FullIdent . createFullIdentBelow ( ast ) ; isStatic = false ; } else { ident = FullIdent . createFullIdent ( ast . getFirstChild ( ) . getNextSibling ( ) ) ; isStatic = true ; } final boolean isStaticAndNotLastImport = isStatic && ! lastImportStatic ; final boolean isNotStaticAndLastImport = ! isStatic && lastImportStatic ; switch ( getAbstractOption ( ) ) { case TOP : if ( isNotStaticAndLastImport ) { lastGroup = Integer . MIN_VALUE ; lastImport = "" ; } doVisitToken ( ident , isStatic , isStaticAndNotLastImport ) ; break ; case ABOVE : doVisitToken ( ident , isStatic , isStaticAndNotLastImport ) ; break ; case INFLOW : doVisitToken ( ident , isStatic , true ) ; break ; case BOTTOM : if ( isStaticAndNotLastImport ) { lastGroup = Integer . MIN_VALUE ; lastImport = "" ; } doVisitToken ( ident , isStatic , isNotStaticAndLastImport ) ; break ; case UNDER : doVisitToken ( ident , isStatic , isNotStaticAndLastImport ) ; break ; default : break ; } lastImportLine = ast . findFirstToken ( TokenTypes . SEMI ) . getLineNo ( ) ; lastImportStatic = isStatic ; beforeFirstImport = false ; } private void doVisitToken ( FullIdent ident , boolean isStatic , boolean previous ) { if ( ident != null ) { final String name = ident . getText ( ) ; final int groupIdx = getGroupNumber ( name ) ; final int line = ident . getLineNo ( ) ; if ( groupIdx > lastGroup ) { if ( ! beforeFirstImport && separated && line - lastImportLine < 2 ) { log ( line , MSG_SEPARATION , name ) ; } } else if ( groupIdx == lastGroup || sortStaticImportsAlphabetically && isAlphabeticallySortableStaticImport ( isStatic ) ) { doVisitTokenInSameGroup ( isStatic , previous , name , line ) ; } else { log ( line , MSG_ORDERING , name ) ; } lastGroup = groupIdx ; lastImport = name ; } } private boolean isAlphabeticallySortableStaticImport ( boolean isStatic ) { boolean result = false ; if ( isStatic && ( getAbstractOption ( ) == ImportOrderOption . TOP || getAbstractOption ( ) == ImportOrderOption . BOTTOM ) ) { result = true ; } return result ; } private void doVisitTokenInSameGroup ( boolean isStatic , boolean previous , String name , int line ) { if ( ! ordered ) { return ; } if ( getAbstractOption ( ) == ImportOrderOption . INFLOW ) { if ( compare ( lastImport , name , caseSensitive ) > 0 ) { log ( line , MSG_ORDERING , name ) ; } } else { final boolean shouldFireError = ! ( lastImportStatic ^ isStatic ) && compare ( lastImport , name , caseSensitive ) > 0 || previous ; if ( shouldFireError ) { log ( line , MSG_ORDERING , name ) ; } } } private int getGroupNumber ( String name ) { int bestIndex = groups . length ; int bestLength = - 1 ; int bestPos = 0 ; for ( int i = 0 ; i < groups . length ; i ++ ) { final Matcher matcher = groups [ i ] . matcher ( name ) ; while ( matcher . find ( ) ) { final int length = matcher . end ( ) - matcher . start ( ) ; if ( length > bestLength || length == bestLength && matcher . start ( ) < bestPos ) { bestIndex = i ; bestLength = length ; bestPos = matcher . start ( ) ; } } } return bestIndex ; } private static int compare ( String string1 , String string2 , boolean caseSensitive ) { int result ; if ( caseSensitive ) { result = string1 . compareTo ( string2 ) ; } else { result = string1 . compareToIgnoreCase ( string2 ) ; } return result ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . puppycrawl . tools . checkstyle . api . AbstractLoader ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URI ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . HashMap ; import java . util . Map ; import javax . xml . parsers . ParserConfigurationException ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; final class ImportControlLoader extends AbstractLoader { private static final String DTD_PUBLIC_ID_1_0 = "-//Puppy Crawl//DTD Import Control 1.0//EN" ; private static final String DTD_PUBLIC_ID_1_1 = "-//Puppy Crawl//DTD Import Control 1.1//EN" ; private static final String DTD_RESOURCE_NAME_1_0 = "com/puppycrawl/tools/checkstyle/checks/imports/import_control_1_0.dtd" ; private static final String DTD_RESOURCE_NAME_1_1 = "com/puppycrawl/tools/checkstyle/checks/imports/import_control_1_1.dtd" ; private static final Map < String , String > DTD_RESOURCE_BY_ID = new HashMap < > ( ) ; private final Deque < PkgControl > stack = new ArrayDeque < > ( ) ; static { DTD_RESOURCE_BY_ID . put ( DTD_PUBLIC_ID_1_0 , DTD_RESOURCE_NAME_1_0 ) ; DTD_RESOURCE_BY_ID . put ( DTD_PUBLIC_ID_1_1 , DTD_RESOURCE_NAME_1_1 ) ; } private ImportControlLoader ( ) throws ParserConfigurationException , SAXException { super ( DTD_RESOURCE_BY_ID ) ; } @ Override public void startElement ( final String namespaceURI , final String locqName , final String qName , final Attributes atts ) throws SAXException { if ( "import-control" . equals ( qName ) ) { final String pkg = safeGet ( atts , "pkg" ) ; stack . push ( new PkgControl ( pkg ) ) ; } else if ( "subpackage" . equals ( qName ) ) { final String name = safeGet ( atts , "name" ) ; stack . push ( new PkgControl ( stack . peek ( ) , name ) ) ; } else if ( "allow" . equals ( qName ) || "disallow" . equals ( qName ) ) { final boolean isAllow = "allow" . equals ( qName ) ; final boolean isLocalOnly = atts . getValue ( "local-only" ) != null ; final String pkg = atts . getValue ( "pkg" ) ; final boolean regex = atts . getValue ( "regex" ) != null ; final Guard g ; if ( pkg != null ) { final boolean exactMatch = atts . getValue ( "exact-match" ) != null ; g = new Guard ( isAllow , isLocalOnly , pkg , exactMatch , regex ) ; } else { final String clazz = safeGet ( atts , "class" ) ; g = new Guard ( isAllow , isLocalOnly , clazz , regex ) ; } final PkgControl pc = stack . peek ( ) ; pc . addGuard ( g ) ; } } @ Override public void endElement ( final String namespaceURI , final String localName , final String qName ) { if ( "subpackage" . equals ( qName ) ) { stack . pop ( ) ; } } static PkgControl load ( final URI uri ) throws CheckstyleException { InputStream is = null ; try { is = uri . toURL ( ) . openStream ( ) ; } catch ( final MalformedURLException e ) { throw new CheckstyleException ( "syntax error in url " + uri , e ) ; } catch ( final IOException e ) { throw new CheckstyleException ( "unable to find " + uri , e ) ; } final InputSource source = new InputSource ( is ) ; return load ( source , uri ) ; } private static PkgControl load ( final InputSource source , final URI uri ) throws CheckstyleException { try { final ImportControlLoader loader = new ImportControlLoader ( ) ; loader . parseInputSource ( source ) ; return loader . getRoot ( ) ; } catch ( final ParserConfigurationException | SAXException e ) { throw new CheckstyleException ( "unable to parse " + uri + " - " + e . getMessage ( ) , e ) ; } catch ( final IOException e ) { throw new CheckstyleException ( "unable to read " + uri , e ) ; } } private PkgControl getRoot ( ) { return stack . peek ( ) ; } private String safeGet ( final Attributes atts , final String name ) throws SAXException { final String retVal = atts . getValue ( name ) ; if ( retVal == null ) { throw new SAXException ( "missing attribute " + name ) ; } return retVal ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class AvoidStaticImportCheck extends Check { public static final String MSG_KEY = "import.avoidStatic" ; private String [ ] excludes = new String [ 0 ] ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . STATIC_IMPORT } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . STATIC_IMPORT } ; } public void setExcludes ( String ... excludes ) { this . excludes = excludes . clone ( ) ; } @ Override public void visitToken ( final DetailAST ast ) { final DetailAST startingDot = ast . getFirstChild ( ) . getNextSibling ( ) ; final FullIdent name = FullIdent . createFullIdent ( startingDot ) ; if ( ! isExempt ( name . getText ( ) ) ) { log ( startingDot . getLineNo ( ) , MSG_KEY , name . getText ( ) ) ; } } private boolean isExempt ( String classOrStaticMember ) { for ( String exclude : excludes ) { if ( classOrStaticMember . equals ( exclude ) ) { return true ; } else if ( exclude . endsWith ( ".*" ) ) { final String excludeMinusDotStar = exclude . substring ( 0 , exclude . length ( ) - 2 ) ; if ( classOrStaticMember . startsWith ( excludeMinusDotStar ) && ! classOrStaticMember . equals ( excludeMinusDotStar ) ) { final String member = classOrStaticMember . substring ( excludeMinusDotStar . length ( ) + 1 ) ; if ( member . indexOf ( '.' ) == - 1 ) { return true ; } } } } return false ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import java . io . File ; import java . net . URI ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . apache . commons . beanutils . ConversionException ; import org . apache . commons . lang3 . StringUtils ; public class ImportControlCheck extends Check { public static final String MSG_MISSING_FILE = "import.control.missing.file" ; public static final String MSG_UNKNOWN_PKG = "import.control.unknown.pkg" ; public static final String MSG_DISALLOWED = "import.control.disallowed" ; private PkgControl root ; private String inPkg ; private PkgControl currentLeaf ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF , TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF , TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT , } ; } @ Override public void beginTree ( final DetailAST rootAST ) { currentLeaf = null ; } @ Override public void visitToken ( final DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . PACKAGE_DEF ) { final DetailAST nameAST = ast . getLastChild ( ) . getPreviousSibling ( ) ; final FullIdent full = FullIdent . createFullIdent ( nameAST ) ; if ( root == null ) { log ( nameAST , MSG_MISSING_FILE ) ; } else { inPkg = full . getText ( ) ; currentLeaf = root . locateFinest ( inPkg ) ; if ( currentLeaf == null ) { log ( nameAST , MSG_UNKNOWN_PKG ) ; } } } else if ( currentLeaf != null ) { final FullIdent imp ; if ( ast . getType ( ) == TokenTypes . IMPORT ) { imp = FullIdent . createFullIdentBelow ( ast ) ; } else { imp = FullIdent . createFullIdent ( ast . getFirstChild ( ) . getNextSibling ( ) ) ; } final AccessResult access = currentLeaf . checkAccess ( imp . getText ( ) , inPkg ) ; if ( AccessResult . ALLOWED != access ) { log ( ast , MSG_DISALLOWED , imp . getText ( ) ) ; } } } public void setUrl ( final String url ) { if ( StringUtils . isBlank ( url ) ) { return ; } final URI uri ; try { uri = URI . create ( url ) ; } catch ( final IllegalArgumentException ex ) { throw new ConversionException ( "syntax error in url " + url , ex ) ; } try { root = ImportControlLoader . load ( uri ) ; } catch ( final CheckstyleException ex ) { throw new ConversionException ( "Unable to load " + url , ex ) ; } } public void setFile ( final String name ) { if ( StringUtils . isBlank ( name ) ) { return ; } try { root = ImportControlLoader . load ( new File ( name ) . toURI ( ) ) ; } catch ( final CheckstyleException ex ) { throw new ConversionException ( "Unable to load " + name , ex ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import java . util . ArrayList ; import java . util . List ; import java . util . StringTokenizer ; import java . util . regex . Pattern ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; public class CustomImportOrderCheck extends Check { public static final String MSG_LINE_SEPARATOR = "custom.import.order.line.separator" ; public static final String MSG_LEX = "custom.import.order.lex" ; public static final String MSG_NONGROUP_IMPORT = "custom.import.order.nongroup.import" ; public static final String MSG_ORDER = "custom.import.order" ; private static final String STATIC_RULE_GROUP = "STATIC" ; private static final String SAME_PACKAGE_RULE_GROUP = "SAME_PACKAGE" ; private static final String THIRD_PARTY_PACKAGE_RULE_GROUP = "THIRD_PARTY_PACKAGE" ; private static final String STANDARD_JAVA_PACKAGE_RULE_GROUP = "STANDARD_JAVA_PACKAGE" ; private static final String SPECIAL_IMPORTS_RULE_GROUP = "SPECIAL_IMPORTS" ; private static final String NON_GROUP_RULE_GROUP = "NON_GROUP" ; private String samePackageDomainsRegExp = "" ; private Pattern standardPackageRegExp = Pattern . compile ( "^(java|javax)\\." ) ; private Pattern thirdPartyPackageRegExp = Pattern . compile ( ".*" ) ; private Pattern specialImportsRegExp = Pattern . compile ( "^$" ) ; private boolean separateLineBetweenGroups = true ; private boolean sortImportsInGroupAlphabetically ; private final List < String > customImportOrderRules = new ArrayList < > ( ) ; private int samePackageMatchingDepth = 2 ; private List < ImportDetails > importToGroupList = new ArrayList < > ( ) ; public final void setStandardPackageRegExp ( String regexp ) { standardPackageRegExp = Utils . createPattern ( regexp ) ; } public final void setThirdPartyPackageRegExp ( String regexp ) { thirdPartyPackageRegExp = Utils . createPattern ( regexp ) ; } public final void setSpecialImportsRegExp ( String regexp ) { specialImportsRegExp = Utils . createPattern ( regexp ) ; } public final void setSeparateLineBetweenGroups ( boolean value ) { separateLineBetweenGroups = value ; } public final void setSortImportsInGroupAlphabetically ( boolean value ) { sortImportsInGroupAlphabetically = value ; } public final void setCustomImportOrderRules ( final String inputCustomImportOrder ) { customImportOrderRules . clear ( ) ; for ( String currentState : inputCustomImportOrder . split ( "\\s*###\\s*" ) ) { addRuleastoList ( currentState ) ; } customImportOrderRules . add ( NON_GROUP_RULE_GROUP ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT , TokenTypes . PACKAGE_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT , TokenTypes . PACKAGE_DEF , } ; } @ Override public void beginTree ( DetailAST rootAST ) { importToGroupList . clear ( ) ; } @ Override public void visitToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . PACKAGE_DEF ) { if ( customImportOrderRules . contains ( SAME_PACKAGE_RULE_GROUP ) ) { samePackageDomainsRegExp = createSamePackageRegexp ( samePackageMatchingDepth , ast ) ; } } else { final String importFullPath = getFullImportIdent ( ast ) ; final int lineNo = ast . getLineNo ( ) ; final boolean isStatic = ast . getType ( ) == TokenTypes . STATIC_IMPORT ; importToGroupList . add ( new ImportDetails ( importFullPath , lineNo , getImportGroup ( isStatic , importFullPath ) , isStatic ) ) ; } } @ Override public void finishTree ( DetailAST rootAST ) { if ( importToGroupList . isEmpty ( ) ) { return ; } final ImportDetails firstImport = importToGroupList . get ( 0 ) ; String currentGroup = getImportGroup ( firstImport . isStaticImport ( ) , firstImport . getImportFullPath ( ) ) ; int groupNumber = customImportOrderRules . indexOf ( currentGroup ) ; String previousImport = null ; for ( ImportDetails importObject : importToGroupList ) { final String importGroup = importObject . getImportGroup ( ) ; final String fullImportIdent = importObject . importFullPath ; if ( ! importGroup . equals ( currentGroup ) ) { if ( customImportOrderRules . size ( ) > groupNumber + 1 ) { final String nextGroup = getNextImportGroup ( groupNumber + 1 ) ; if ( importGroup . equals ( nextGroup ) ) { if ( separateLineBetweenGroups && previousImport != null && ! hasEmptyLineBefore ( importObject . getLineNumber ( ) ) ) { log ( importObject . getLineNumber ( ) , MSG_LINE_SEPARATOR , fullImportIdent ) ; } currentGroup = nextGroup ; groupNumber = customImportOrderRules . indexOf ( nextGroup ) ; } else { logWrongImportGroupOrder ( importObject . getLineNumber ( ) , importGroup ) ; } } else { logWrongImportGroupOrder ( importObject . getLineNumber ( ) , importGroup ) ; } } else if ( sortImportsInGroupAlphabetically && previousImport != null && matchesImportGroup ( importObject . isStaticImport ( ) , fullImportIdent , currentGroup ) && compareImports ( fullImportIdent , previousImport ) < 0 ) { log ( importObject . getLineNumber ( ) , MSG_LEX , fullImportIdent ) ; } previousImport = fullImportIdent ; } } private void logWrongImportGroupOrder ( int currentImportLine , String importGroup ) { if ( NON_GROUP_RULE_GROUP . equals ( importGroup ) ) { log ( currentImportLine , MSG_NONGROUP_IMPORT ) ; } else { log ( currentImportLine , MSG_ORDER , importGroup ) ; } } private String getNextImportGroup ( int currentGroupNumber ) { int nextGroupNumber = currentGroupNumber ; while ( customImportOrderRules . size ( ) > nextGroupNumber + 1 ) { if ( hasAnyImportInCurrentGroup ( customImportOrderRules . get ( nextGroupNumber ) ) ) { break ; } nextGroupNumber ++ ; } return customImportOrderRules . get ( nextGroupNumber ) ; } private boolean hasAnyImportInCurrentGroup ( String currentGroup ) { for ( ImportDetails currentImport : importToGroupList ) { if ( currentGroup . equals ( currentImport . getImportGroup ( ) ) ) { return true ; } } return false ; } private String getImportGroup ( boolean isStatic , String importPath ) { for ( String group : customImportOrderRules ) { if ( matchesImportGroup ( isStatic , importPath , group ) ) { return group ; } } return NON_GROUP_RULE_GROUP ; } private boolean matchesImportGroup ( boolean isStatic , String importPath , String currentGroup ) { return matchesStaticImportGroup ( isStatic , currentGroup ) || matchesSamePackageImportGroup ( isStatic , importPath , currentGroup ) || matchesSpecialImportsGroup ( isStatic , importPath , currentGroup ) || matchesStandartImportGroup ( isStatic , importPath , currentGroup ) || matchesThirdPartyImportGroup ( isStatic , importPath , currentGroup ) ; } private boolean matchesStaticImportGroup ( boolean isStatic , String currentGroup ) { return isStatic && STATIC_RULE_GROUP . equals ( currentGroup ) ; } private boolean matchesSamePackageImportGroup ( boolean isStatic , String importFullPath , String currentGroup ) { final String importPath = importFullPath . substring ( 0 , importFullPath . lastIndexOf ( '.' ) ) ; return ! isStatic && SAME_PACKAGE_RULE_GROUP . equals ( currentGroup ) && samePackageDomainsRegExp . contains ( importPath ) ; } private boolean matchesStandartImportGroup ( boolean isStatic , String currentImport , String currentGroup ) { return ! isStatic && STANDARD_JAVA_PACKAGE_RULE_GROUP . equals ( currentGroup ) && standardPackageRegExp . matcher ( currentImport ) . find ( ) ; } private boolean matchesSpecialImportsGroup ( boolean isStatic , String currentImport , String currentGroup ) { return ! isStatic && SPECIAL_IMPORTS_RULE_GROUP . equals ( currentGroup ) && specialImportsRegExp . matcher ( currentImport ) . find ( ) ; } private boolean matchesThirdPartyImportGroup ( boolean isStatic , String currentImport , String currentGroup ) { return ! isStatic && THIRD_PARTY_PACKAGE_RULE_GROUP . equals ( currentGroup ) && thirdPartyPackageRegExp . matcher ( currentImport ) . find ( ) && ! standardPackageRegExp . matcher ( currentImport ) . find ( ) && ! specialImportsRegExp . matcher ( currentImport ) . find ( ) ; } private static int compareImports ( String import1 , String import2 ) { int result = 0 ; final String [ ] import1Tokens = import1 . split ( "\\." ) ; final String [ ] import2Tokens = import2 . split ( "\\." ) ; for ( int i = 0 ; i < import1Tokens . length ; i ++ ) { if ( i == import2Tokens . length ) { break ; } final String import1Token = import1Tokens [ i ] ; final String import2Token = import2Tokens [ i ] ; result = import1Token . compareTo ( import2Token ) ; if ( result != 0 ) { break ; } } return result ; } private boolean hasEmptyLineBefore ( int lineNo ) { final String lineBefore = getLine ( lineNo - 2 ) ; return lineBefore . trim ( ) . isEmpty ( ) ; } private static String getFullImportIdent ( DetailAST token ) { return token != null ? FullIdent . createFullIdent ( token . findFirstToken ( TokenTypes . DOT ) ) . getText ( ) : "" ; } private void addRuleastoList ( String ruleStr ) { if ( STATIC_RULE_GROUP . equals ( ruleStr ) || THIRD_PARTY_PACKAGE_RULE_GROUP . equals ( ruleStr ) || STANDARD_JAVA_PACKAGE_RULE_GROUP . equals ( ruleStr ) || SPECIAL_IMPORTS_RULE_GROUP . equals ( ruleStr ) ) { customImportOrderRules . add ( ruleStr ) ; } else if ( ruleStr . startsWith ( SAME_PACKAGE_RULE_GROUP ) ) { final String rule = ruleStr . substring ( ruleStr . indexOf ( '(' ) + 1 , ruleStr . indexOf ( ')' ) ) ; samePackageMatchingDepth = Integer . parseInt ( rule ) ; if ( samePackageMatchingDepth <= 0 ) { throw new IllegalArgumentException ( "SAME_PACKAGE rule parameter should be positive integer: " + ruleStr ) ; } customImportOrderRules . add ( SAME_PACKAGE_RULE_GROUP ) ; } else { throw new RuntimeException ( "Unexpected rule: " + ruleStr ) ; } } private static String createSamePackageRegexp ( int firstPackageDomainsCount , DetailAST packageNode ) { final StringBuilder builder = new StringBuilder ( ) ; final String packageFullPath = getFullImportIdent ( packageNode ) ; final StringTokenizer tokens = new StringTokenizer ( packageFullPath , "." ) ; int count = firstPackageDomainsCount ; while ( tokens . hasMoreTokens ( ) && count > 0 ) { builder . append ( tokens . nextToken ( ) ) . append ( '.' ) ; count -- ; } return builder . append ( "*" ) . toString ( ) ; } static class ImportDetails { private String importFullPath ; private int lineNumber ; private String importGroup ; private boolean staticImport ; public ImportDetails ( String importFullPath , int lineNumber , String importGroup , boolean staticImport ) { setImportFullPath ( importFullPath ) ; setLineNumber ( lineNumber ) ; setImportGroup ( importGroup ) ; setStaticImport ( staticImport ) ; } public String getImportFullPath ( ) { return importFullPath ; } public void setImportFullPath ( String importFullPath ) { this . importFullPath = importFullPath ; } public int getLineNumber ( ) { return lineNumber ; } public void setLineNumber ( int lineNumber ) { this . lineNumber = lineNumber ; } public String getImportGroup ( ) { return importGroup ; } public void setImportGroup ( String importGroup ) { this . importGroup = importGroup ; } public boolean isStaticImport ( ) { return staticImport ; } public void setStaticImport ( boolean isStatic ) { this . staticImport = isStatic ; } } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class IllegalImportCheck extends Check { public static final String MSG_KEY = "import.illegal" ; private String [ ] illegalPkgs ; public IllegalImportCheck ( ) { setIllegalPkgs ( "sun" ) ; } public void setIllegalPkgs ( String ... from ) { illegalPkgs = from . clone ( ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT } ; } @ Override public void visitToken ( DetailAST ast ) { final FullIdent imp ; if ( ast . getType ( ) == TokenTypes . IMPORT ) { imp = FullIdent . createFullIdentBelow ( ast ) ; } else { imp = FullIdent . createFullIdent ( ast . getFirstChild ( ) . getNextSibling ( ) ) ; } if ( isIllegalImport ( imp . getText ( ) ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY , imp . getText ( ) ) ; } } private boolean isIllegalImport ( String importText ) { for ( String element : illegalPkgs ) { if ( importText . startsWith ( element + "." ) ) { return true ; } } return false ; } }
package com . puppycrawl . tools . checkstyle . checks . imports ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . Set ; public class RedundantImportCheck extends Check { public static final String MSG_LANG = "import.lang" ; public static final String MSG_SAME = "import.same" ; public static final String MSG_DUPLICATE = "import.duplicate" ; private String pkgName ; private final Set < FullIdent > imports = Sets . newHashSet ( ) ; private final Set < FullIdent > staticImports = Sets . newHashSet ( ) ; @ Override public void beginTree ( DetailAST aRootAST ) { pkgName = null ; imports . clear ( ) ; staticImports . clear ( ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT , TokenTypes . PACKAGE_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . STATIC_IMPORT , TokenTypes . PACKAGE_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . PACKAGE_DEF ) { pkgName = FullIdent . createFullIdent ( ast . getLastChild ( ) . getPreviousSibling ( ) ) . getText ( ) ; } else if ( ast . getType ( ) == TokenTypes . IMPORT ) { final FullIdent imp = FullIdent . createFullIdentBelow ( ast ) ; if ( fromPackage ( imp . getText ( ) , "java.lang" ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_LANG , imp . getText ( ) ) ; } else if ( pkgName != null && fromPackage ( imp . getText ( ) , pkgName ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_SAME , imp . getText ( ) ) ; } for ( FullIdent full : imports ) { if ( imp . getText ( ) . equals ( full . getText ( ) ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_DUPLICATE , full . getLineNo ( ) , imp . getText ( ) ) ; } } imports . add ( imp ) ; } else { final FullIdent imp = FullIdent . createFullIdent ( ast . getLastChild ( ) . getPreviousSibling ( ) ) ; for ( FullIdent full : staticImports ) { if ( imp . getText ( ) . equals ( full . getText ( ) ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_DUPLICATE , full . getLineNo ( ) , imp . getText ( ) ) ; } } staticImports . add ( imp ) ; } } private static boolean fromPackage ( String importName , String pkg ) { boolean retVal = false ; final int index = importName . lastIndexOf ( '.' ) ; final String front = importName . substring ( 0 , index ) ; retVal = front . equals ( pkg ) ; return retVal ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . AbstractParenPadCheck . WS_FOLLOWED ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . AbstractParenPadCheck . WS_PRECEDED ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . AbstractParenPadCheck . WS_NOT_FOLLOWED ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . AbstractParenPadCheck . WS_NOT_PRECEDED ; public class ParenPadCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParenPadCheck . class ) ; final String [ ] expected = { "58:12: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "58:36: " + getCheckMessage ( WS_PRECEDED , ")" ) , "74:13: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "74:18: " + getCheckMessage ( WS_PRECEDED , ")" ) , "232:27: " + getCheckMessage ( WS_PRECEDED , ")" ) , "241:24: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "241:30: " + getCheckMessage ( WS_PRECEDED , ")" ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void testSpace ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParenPadCheck . class ) ; checkConfig . addAttribute ( "option" , PadOption . SPACE . toString ( ) ) ; final String [ ] expected = { "29:20: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "29:23: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "37:22: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "37:26: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "41:15: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "41:33: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "76:20: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "76:21: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "97:22: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "97:28: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "98:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "98:18: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "150:28: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "150:32: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "153:16: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "153:20: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "160:21: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "160:34: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "162:20: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "165:10: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "178:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "178:36: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "225:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "235:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "235:39: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "252:21: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "252:93: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void testDefaultForIterator ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParenPadCheck . class ) ; final String [ ] expected = { "17:34: " + getCheckMessage ( WS_PRECEDED , ")" ) , "20:35: " + getCheckMessage ( WS_PRECEDED , ")" ) , "40:14: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "40:36: " + getCheckMessage ( WS_PRECEDED , ")" ) , "43:14: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "48:27: " + getCheckMessage ( WS_PRECEDED , ")" ) , "51:26: " + getCheckMessage ( WS_PRECEDED , ")" ) , } ; verify ( checkConfig , getPath ( "InputForWhitespace.java" ) , expected ) ; } @ Test public void testSpaceEmptyForIterator ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParenPadCheck . class ) ; checkConfig . addAttribute ( "option" , PadOption . SPACE . toString ( ) ) ; final String [ ] expected = { "11:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "11:35: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "14:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "14:34: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "17:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "20:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "23:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "27:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "32:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , } ; verify ( checkConfig , getPath ( "InputForWhitespace.java" ) , expected ) ; } @ Test public void test1322879 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParenPadCheck . class ) ; checkConfig . addAttribute ( "option" , PadOption . SPACE . toString ( ) ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "whitespace/ParenPadWithSpace.java" ) , expected ) ; } @ Test public void testNospaceWithComplexInput ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParenPadCheck . class ) ; checkConfig . addAttribute ( "option" , PadOption . NOSPACE . toString ( ) ) ; final String [ ] expected = { "44:27: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "44:27: " + getCheckMessage ( WS_PRECEDED , ")" ) , "45:18: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "48:27: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "49:19: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "49:19: " + getCheckMessage ( WS_PRECEDED , ")" ) , "52:27: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "53:21: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "54:18: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "54:52: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "54:52: " + getCheckMessage ( WS_PRECEDED , ")" ) , "57:26: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "58:22: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "59:24: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "60:26: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "60:51: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "60:57: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "61:29: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "62:43: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "63:41: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "65:43: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "78:28: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "78:28: " + getCheckMessage ( WS_PRECEDED , ")" ) , "79:19: " + getCheckMessage ( WS_PRECEDED , ")" ) , "82:33: " + getCheckMessage ( WS_PRECEDED , ")" ) , "83:19: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "83:19: " + getCheckMessage ( WS_PRECEDED , ")" ) , "86:29: " + getCheckMessage ( WS_PRECEDED , ")" ) , "87:35: " + getCheckMessage ( WS_PRECEDED , ")" ) , "88:51: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "88:51: " + getCheckMessage ( WS_PRECEDED , ")" ) , "88:53: " + getCheckMessage ( WS_PRECEDED , ")" ) , "90:38: " + getCheckMessage ( WS_PRECEDED , ")" ) , "91:32: " + getCheckMessage ( WS_PRECEDED , ")" ) , "92:35: " + getCheckMessage ( WS_PRECEDED , ")" ) , "93:30: " + getCheckMessage ( WS_PRECEDED , ")" ) , "94:60: " + getCheckMessage ( WS_PRECEDED , ")" ) , "94:62: " + getCheckMessage ( WS_PRECEDED , ")" ) , "94:69: " + getCheckMessage ( WS_PRECEDED , ")" ) , "95:34: " + getCheckMessage ( WS_PRECEDED , ")" ) , "96:47: " + getCheckMessage ( WS_PRECEDED , ")" ) , "97:42: " + getCheckMessage ( WS_PRECEDED , ")" ) , "99:44: " + getCheckMessage ( WS_PRECEDED , ")" ) , "112:17: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "113:23: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "113:25: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "113:31: " + getCheckMessage ( WS_PRECEDED , ")" ) , "114:26: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "114:28: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "114:34: " + getCheckMessage ( WS_PRECEDED , ")" ) , "114:50: " + getCheckMessage ( WS_PRECEDED , ")" ) , "115:26: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "115:28: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "115:35: " + getCheckMessage ( WS_PRECEDED , ")" ) , "115:53: " + getCheckMessage ( WS_PRECEDED , ")" ) , "115:55: " + getCheckMessage ( WS_PRECEDED , ")" ) , "119:17: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "119:22: " + getCheckMessage ( WS_PRECEDED , ")" ) , "123:30: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "123:44: " + getCheckMessage ( WS_PRECEDED , ")" ) , "126:22: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "126:22: " + getCheckMessage ( WS_PRECEDED , ")" ) , "130:19: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "130:19: " + getCheckMessage ( WS_PRECEDED , ")" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputParenPad.java" ) , expected ) ; } @ Test public void testConfigureTokens ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ParenPadCheck . class ) ; checkConfig . addAttribute ( "tokens" , "METHOD_CALL" ) ; final String [ ] expected = { "90:38: " + getCheckMessage ( WS_PRECEDED , ")" ) , "112:17: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "113:23: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "115:53: " + getCheckMessage ( WS_PRECEDED , ")" ) , "115:55: " + getCheckMessage ( WS_PRECEDED , ")" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputParenPad.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class FinallyHandler extends BlockParentHandler { public FinallyHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "finally" , ast , parent ) ; } @ Override protected boolean toplevelMustStartLine ( ) { return false ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import java . util . ArrayDeque ; import java . util . Deque ; public class IndentationCheck extends Check { private static final int DEFAULT_INDENTATION = 4 ; private int basicOffset = DEFAULT_INDENTATION ; private int caseIndentationAmount = DEFAULT_INDENTATION ; private int braceAdjustment ; private int throwsIndentationAmount = DEFAULT_INDENTATION ; private int arrayInitIndentationAmount = DEFAULT_INDENTATION ; private int lineWrappingIndentation = DEFAULT_INDENTATION ; private boolean forceStrictCondition ; private final Deque < AbstractExpressionHandler > handlers = new ArrayDeque < > ( ) ; private final HandlerFactory handlerFactory = new HandlerFactory ( ) ; public boolean isForceStrictCondition ( ) { return forceStrictCondition ; } public void setForceStrictCondition ( boolean value ) { forceStrictCondition = value ; } public void setBasicOffset ( int basicOffset ) { this . basicOffset = basicOffset ; } public int getBasicOffset ( ) { return basicOffset ; } public void setBraceAdjustment ( int adjustmentAmount ) { braceAdjustment = adjustmentAmount ; } public int getBraceAdjustment ( ) { return braceAdjustment ; } public void setCaseIndent ( int amount ) { caseIndentationAmount = amount ; } public int getCaseIndent ( ) { return caseIndentationAmount ; } public void setThrowsIndent ( int throwsIndent ) { throwsIndentationAmount = throwsIndent ; } public int getThrowsIndent ( ) { return this . throwsIndentationAmount ; } public void setArrayInitIndent ( int arrayInitIndent ) { arrayInitIndentationAmount = arrayInitIndent ; } public int getArrayInitIndent ( ) { return this . arrayInitIndentationAmount ; } public int getLineWrappingIndentation ( ) { return lineWrappingIndentation ; } public void setLineWrappingIndentation ( int lineWrappingIndentation ) { this . lineWrappingIndentation = lineWrappingIndentation ; } public void indentationLog ( int line , String key , Object ... args ) { super . log ( line , key , args ) ; } public int getIndentationTabWidth ( ) { return getTabWidth ( ) ; } @ Override public int [ ] getDefaultTokens ( ) { return handlerFactory . getHandledTypes ( ) ; } @ Override public void beginTree ( DetailAST ast ) { handlerFactory . clearCreatedHandlers ( ) ; handlers . clear ( ) ; handlers . push ( new PrimordialHandler ( this ) ) ; } @ Override public void visitToken ( DetailAST ast ) { final AbstractExpressionHandler handler = handlerFactory . getHandler ( this , ast , handlers . peek ( ) ) ; handlers . push ( handler ) ; handler . checkIndentation ( ) ; } @ Override public void leaveToken ( DetailAST ast ) { handlers . pop ( ) ; } final HandlerFactory getHandlerFactory ( ) { return handlerFactory ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ;
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; import java . util . Arrays ; public abstract class AbstractExpressionHandler { public static final String MSG_ERROR = "indentation.error" ; public static final String MSG_ERROR_MULTI = "indentation.error.multi" ; public static final String MSG_CHILD_ERROR = "indentation.child.error" ; public static final String MSG_CHILD_ERROR_MULTI = "indentation.child.error.multi" ; private final IndentationCheck indentCheck ; private final DetailAST mainAst ; private final String typeName ; private final AbstractExpressionHandler parent ; private IndentLevel level ; public AbstractExpressionHandler ( IndentationCheck indentCheck , String typeName , DetailAST expr , AbstractExpressionHandler parent ) { this . indentCheck = indentCheck ; this . typeName = typeName ; mainAst = expr ; this . parent = parent ; } public final IndentLevel getLevel ( ) { if ( level == null ) { level = getLevelImpl ( ) ; } return level ; } protected IndentLevel getLevelImpl ( ) { return parent . suggestedChildLevel ( this ) ; } public IndentLevel suggestedChildLevel ( AbstractExpressionHandler child ) { return new IndentLevel ( getLevel ( ) , getBasicOffset ( ) ) ; } protected final void logError ( DetailAST ast , String subtypeName , int actualLevel ) { logError ( ast , subtypeName , actualLevel , getLevel ( ) ) ; } protected final void logError ( DetailAST ast , String subtypeName , int actualLevel , IndentLevel expectedLevel ) { final String typeStr = "" . equals ( subtypeName ) ? "" : " " + subtypeName ; String messageKey = MSG_ERROR ; if ( expectedLevel . isMultiLevel ( ) ) { messageKey = MSG_ERROR_MULTI ; } indentCheck . indentationLog ( ast . getLineNo ( ) , messageKey , typeName + typeStr , actualLevel , expectedLevel ) ; } private void logChildError ( int line , int actualLevel , IndentLevel expectedLevel ) { String messageKey = MSG_CHILD_ERROR ; if ( expectedLevel . isMultiLevel ( ) ) { messageKey = MSG_CHILD_ERROR_MULTI ; } indentCheck . indentationLog ( line , messageKey , typeName , actualLevel , expectedLevel ) ; } protected final boolean startsLine ( DetailAST ast ) { return getLineStart ( ast ) == expandedTabsColumnNo ( ast ) ; } static boolean areOnSameLine ( DetailAST ast1 , DetailAST ast2 ) { return ast1 != null && ast2 != null && ast1 . getLineNo ( ) == ast2 . getLineNo ( ) ; } static DetailAST getFirstToken ( DetailAST ast ) { DetailAST first = ast ; DetailAST child = ast . getFirstChild ( ) ; while ( child != null ) { final DetailAST toTest = getFirstToken ( child ) ; if ( toTest . getLineNo ( ) < first . getLineNo ( ) || toTest . getLineNo ( ) == first . getLineNo ( ) && toTest . getColumnNo ( ) < first . getColumnNo ( ) ) { first = toTest ; } child = child . getNextSibling ( ) ; } return first ; } protected final int getLineStart ( DetailAST ast ) { final String line = indentCheck . getLine ( ast . getLineNo ( ) - 1 ) ; return getLineStart ( line ) ; } protected final void checkLinesIndent ( int startLine , int endLine , IndentLevel indentLevel ) { checkSingleLine ( startLine , indentLevel ) ; final IndentLevel offsetLevel = new IndentLevel ( indentLevel , getBasicOffset ( ) ) ; for ( int i = startLine + 1 ; i <= endLine ; i ++ ) { checkSingleLine ( i , offsetLevel ) ; } } protected boolean shouldIncreaseIndent ( ) { return true ; } private void checkLinesIndent ( LineSet lines , IndentLevel indentLevel , boolean firstLineMatches , int firstLine ) { if ( lines . isEmpty ( ) ) { return ; } final int startLine = lines . firstLine ( ) ; final int endLine = lines . lastLine ( ) ; final int startCol = lines . firstLineCol ( ) ; final int realStartCol = getLineStart ( indentCheck . getLine ( startLine - 1 ) ) ; if ( realStartCol == startCol ) { checkSingleLine ( startLine , startCol , indentLevel , firstLineMatches ) ; } IndentLevel theLevel = indentLevel ; if ( firstLineMatches || firstLine > mainAst . getLineNo ( ) && shouldIncreaseIndent ( ) ) { theLevel = new IndentLevel ( indentLevel , getBasicOffset ( ) ) ; } for ( int i = startLine + 1 ; i <= endLine ; i ++ ) { final Integer col = lines . getStartColumn ( i ) ; if ( col != null ) { checkSingleLine ( i , col . intValue ( ) , theLevel , false ) ; } } } private void checkSingleLine ( int lineNum , IndentLevel indentLevel ) { final String line = indentCheck . getLine ( lineNum - 1 ) ; final int start = getLineStart ( line ) ; if ( indentLevel . greaterThan ( start ) ) { logChildError ( lineNum , start , indentLevel ) ; } } private void checkSingleLine ( int lineNum , int colNum , IndentLevel indentLevel , boolean mustMatch ) { final String line = indentCheck . getLine ( lineNum - 1 ) ; final int start = getLineStart ( line ) ; if ( mustMatch ? ! indentLevel . accept ( start ) : colNum == start && indentLevel . greaterThan ( start ) ) { logChildError ( lineNum , start , indentLevel ) ; } } protected final int getLineStart ( String line ) { for ( int start = 0 ; start < line . length ( ) ; start ++ ) { final char c = line . charAt ( start ) ; if ( ! Character . isWhitespace ( c ) ) { return Utils . lengthExpandedTabs ( line , start , indentCheck . getIndentationTabWidth ( ) ) ; } } return 0 ; } protected final void checkChildren ( DetailAST parent , int [ ] tokenTypes , IndentLevel startLevel , boolean firstLineMatches , boolean allowNesting ) { Arrays . sort ( tokenTypes ) ; for ( DetailAST child = parent . getFirstChild ( ) ; child != null ; child = child . getNextSibling ( ) ) { if ( Arrays . binarySearch ( tokenTypes , child . getType ( ) ) >= 0 ) { checkExpressionSubtree ( child , startLevel , firstLineMatches , allowNesting ) ; } } } protected final void checkExpressionSubtree ( DetailAST tree , IndentLevel level , boolean firstLineMatches , boolean allowNesting ) { final LineSet subtreeLines = new LineSet ( ) ; final int firstLine = getFirstLine ( Integer . MAX_VALUE , tree ) ; if ( firstLineMatches && ! allowNesting ) { subtreeLines . addLineAndCol ( firstLine , getLineStart ( indentCheck . getLine ( firstLine - 1 ) ) ) ; } findSubtreeLines ( subtreeLines , tree , allowNesting ) ; checkLinesIndent ( subtreeLines , level , firstLineMatches , firstLine ) ; } protected final int getFirstLine ( int startLine , DetailAST tree ) { int realStart = startLine ; final int currLine = tree . getLineNo ( ) ; if ( currLine < realStart ) { realStart = currLine ; } for ( DetailAST node = tree . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { realStart = getFirstLine ( realStart , node ) ; } return realStart ; } protected final int expandedTabsColumnNo ( DetailAST ast ) { final String line = indentCheck . getLine ( ast . getLineNo ( ) - 1 ) ; return Utils . lengthExpandedTabs ( line , ast . getColumnNo ( ) , indentCheck . getIndentationTabWidth ( ) ) ; } protected final void findSubtreeLines ( LineSet lines , DetailAST tree , boolean allowNesting ) { if ( getIndentCheck ( ) . getHandlerFactory ( ) . isHandledType ( tree . getType ( ) ) || tree . getLineNo ( ) < 0 ) { return ; } final int lineNum = tree . getLineNo ( ) ; final Integer colNum = lines . getStartColumn ( lineNum ) ; final int thisLineColumn = expandedTabsColumnNo ( tree ) ; if ( colNum == null || thisLineColumn < colNum . intValue ( ) ) { lines . addLineAndCol ( lineNum , thisLineColumn ) ; } for ( DetailAST node = tree . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { findSubtreeLines ( lines , node , allowNesting ) ; } } protected void checkModifiers ( ) { final DetailAST modifiers = mainAst . findFirstToken ( TokenTypes . MODIFIERS ) ; for ( DetailAST modifier = modifiers . getFirstChild ( ) ; modifier != null ; modifier = modifier . getNextSibling ( ) ) { if ( startsLine ( modifier ) && ! getLevel ( ) . accept ( expandedTabsColumnNo ( modifier ) ) ) { logError ( modifier , "modifier" , expandedTabsColumnNo ( modifier ) ) ; } } } public abstract void checkIndentation ( ) ; protected final IndentationCheck getIndentCheck ( ) { return indentCheck ; } protected final DetailAST getMainAst ( ) { return mainAst ; } protected final AbstractExpressionHandler getParent ( ) { return parent ; } protected final int getBasicOffset ( ) { return getIndentCheck ( ) . getBasicOffset ( ) ; } protected final int getBraceAdjustment ( ) { return getIndentCheck ( ) . getBraceAdjustment ( ) ; } protected final void checkRParen ( DetailAST lparen , DetailAST rparen ) { if ( rparen == null ) { return ; } final int rparenLevel = expandedTabsColumnNo ( rparen ) ; if ( getLevel ( ) . accept ( rparenLevel ) || ! startsLine ( rparen ) ) { return ; } final int lparenLevel = expandedTabsColumnNo ( lparen ) ; if ( rparenLevel == lparenLevel + 1 ) { return ; } logError ( rparen , "rparen" , rparenLevel ) ; } protected final void checkLParen ( final DetailAST lparen ) { if ( lparen == null || getLevel ( ) . accept ( expandedTabsColumnNo ( lparen ) ) || ! startsLine ( lparen ) ) { return ; } logError ( lparen , "lparen" , expandedTabsColumnNo ( lparen ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class NewHandler extends AbstractExpressionHandler { public NewHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "operator new" , ast , parent ) ; } @ Override public void checkIndentation ( ) { final DetailAST type = getMainAst ( ) . getFirstChild ( ) ; if ( type != null ) { checkExpressionSubtree ( type , getLevel ( ) , false , false ) ; } final DetailAST lparen = getMainAst ( ) . findFirstToken ( TokenTypes . LPAREN ) ; final DetailAST rparen = getMainAst ( ) . findFirstToken ( TokenTypes . RPAREN ) ; checkLParen ( lparen ) ; if ( rparen == null || lparen == null || rparen . getLineNo ( ) == lparen . getLineNo ( ) ) { return ; } if ( getMainAst ( ) . getType ( ) != TokenTypes . OBJBLOCK ) { return ; } checkExpressionSubtree ( getMainAst ( ) . findFirstToken ( TokenTypes . ELIST ) , new IndentLevel ( getLevel ( ) , getBasicOffset ( ) ) , false , true ) ; checkRParen ( lparen , rparen ) ; } @ Override protected IndentLevel getLevelImpl ( ) { if ( getLineStart ( getMainAst ( ) ) != getMainAst ( ) . getColumnNo ( ) ) { return new IndentLevel ( getLineStart ( getMainAst ( ) ) ) ; } return super . getLevelImpl ( ) ; } @ Override protected boolean shouldIncreaseIndent ( ) { return false ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ImportHandler extends AbstractExpressionHandler { public ImportHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "import" , ast , parent ) ; } @ Override public void checkIndentation ( ) { final int lineStart = getMainAst ( ) . getLineNo ( ) ; final DetailAST semi = getMainAst ( ) . findFirstToken ( TokenTypes . SEMI ) ; final int lineEnd = semi . getLineNo ( ) ; if ( getMainAst ( ) . getLineNo ( ) != lineEnd ) { checkLinesIndent ( lineStart , lineEnd , getLevel ( ) ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import java . util . BitSet ; public class IndentLevel { private final BitSet levels = new BitSet ( ) ; public IndentLevel ( int indent ) { levels . set ( indent ) ; } public IndentLevel ( IndentLevel base , int ... offsets ) { final BitSet src = base . levels ; for ( int i = src . nextSetBit ( 0 ) ; i >= 0 ; i = src . nextSetBit ( i + 1 ) ) { for ( int offset : offsets ) { levels . set ( i + offset ) ; } } } public final boolean isMultiLevel ( ) { return levels . cardinality ( ) > 1 ; } public boolean accept ( int indent ) { return levels . get ( indent ) ; } public boolean greaterThan ( int indent ) { return levels . nextSetBit ( 0 ) > indent ; } public void addAcceptedIndent ( int indent ) { levels . set ( indent ) ; } public void addAcceptedIndent ( IndentLevel indent ) { levels . or ( indent . levels ) ; } public int getFirstIndentLevel ( ) { return levels . nextSetBit ( 0 ) ; } public int getLastIndentLevel ( ) { return levels . length ( ) - 1 ; } @ Override public String toString ( ) { if ( levels . cardinality ( ) == 1 ) { return String . valueOf ( levels . nextSetBit ( 0 ) ) ; } final StringBuilder sb = new StringBuilder ( ) ; for ( int i = levels . nextSetBit ( 0 ) ; i >= 0 ; i = levels . nextSetBit ( i + 1 ) ) { if ( sb . length ( ) > 0 ) { sb . append ( ", " ) ; } sb . append ( i ) ; } return sb . toString ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class SynchronizedHandler extends BlockParentHandler { private boolean methodModifier ; public SynchronizedHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "synchronized" , ast , parent ) ; methodModifier = isMethodModifier ( ast ) ; } @ Override public void checkIndentation ( ) { if ( ! methodModifier ) { super . checkIndentation ( ) ; checkSynchronizedExpr ( ) ; final LineWrappingHandler lineWrap = new LineWrappingHandler ( getIndentCheck ( ) , getMainAst ( ) , getSynchronizedStatementRightParen ( getMainAst ( ) ) ) ; lineWrap . checkIndentation ( ) ; } } private void checkSynchronizedExpr ( ) { final DetailAST syncAst = getMainAst ( ) . findFirstToken ( TokenTypes . LPAREN ) . getNextSibling ( ) ; final IndentLevel expected = new IndentLevel ( getLevel ( ) , getBasicOffset ( ) ) ; checkExpressionSubtree ( syncAst , expected , false , false ) ; } private static boolean isMethodModifier ( DetailAST ast ) { return ast . getParent ( ) . getType ( ) == TokenTypes . MODIFIERS ; } private static DetailAST getSynchronizedStatementRightParen ( DetailAST syncStatementAST ) { return syncStatementAST . findFirstToken ( TokenTypes . RPAREN ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class MethodCallHandler extends AbstractExpressionHandler { public MethodCallHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , ast . getType ( ) == TokenTypes . METHOD_CALL ? "method call" : "ctor call" , ast , parent ) ; } @ Override protected IndentLevel getLevelImpl ( ) { if ( getParent ( ) instanceof MethodCallHandler ) { final MethodCallHandler container = ( MethodCallHandler ) getParent ( ) ; if ( container != null ) { if ( areOnSameLine ( container . getMainAst ( ) , getMainAst ( ) ) ) { return container . getLevel ( ) ; } if ( isChainedMethodCallWrapped ( ) ) { return container . getLevel ( ) ; } else { return new IndentLevel ( container . getLevel ( ) , getBasicOffset ( ) ) ; } } AbstractExpressionHandler p = getParent ( ) ; while ( p instanceof MethodCallHandler ) { p = p . getParent ( ) ; } return p . suggestedChildLevel ( this ) ; } final LineSet lines = new LineSet ( ) ; findSubtreeLines ( lines , getMainAst ( ) . getFirstChild ( ) , true ) ; final int firstCol = lines . firstLineCol ( ) ; final int lineStart = getLineStart ( getFirstAst ( getMainAst ( ) ) ) ; if ( lineStart != firstCol ) { return new IndentLevel ( lineStart ) ; } return super . getLevelImpl ( ) ; } private boolean isChainedMethodCallWrapped ( ) { boolean result = false ; final DetailAST main = getMainAst ( ) ; final DetailAST dot = main . getFirstChild ( ) ; final DetailAST target = dot . getFirstChild ( ) ; if ( dot . getType ( ) == TokenTypes . DOT && target . getType ( ) == TokenTypes . METHOD_CALL ) { final DetailAST dot1 = target . getFirstChild ( ) ; final DetailAST target1 = dot1 . getFirstChild ( ) ; if ( dot1 . getType ( ) == TokenTypes . DOT && target1 . getType ( ) == TokenTypes . METHOD_CALL ) { result = true ; } } return result ; } private DetailAST getFirstAst ( DetailAST ast ) { DetailAST astNode = ast . getFirstChild ( ) ; while ( astNode != null && astNode . getType ( ) == TokenTypes . DOT ) { astNode = astNode . getFirstChild ( ) ; } if ( astNode == null ) { astNode = ast ; } return astNode ; } @ Override public IndentLevel suggestedChildLevel ( AbstractExpressionHandler child ) { final DetailAST first = getMainAst ( ) . getFirstChild ( ) ; int indentLevel = getLineStart ( first ) ; if ( ! areOnSameLine ( child . getMainAst ( ) . getFirstChild ( ) , getMainAst ( ) . getFirstChild ( ) ) ) { indentLevel += getBasicOffset ( ) ; } return new IndentLevel ( indentLevel ) ; } @ Override public void checkIndentation ( ) { final DetailAST exprNode = getMainAst ( ) . getParent ( ) ; if ( exprNode . getParent ( ) . getType ( ) != TokenTypes . LCURLY && exprNode . getParent ( ) . getType ( ) != TokenTypes . SLIST ) { return ; } final DetailAST methodName = getMainAst ( ) . getFirstChild ( ) ; checkExpressionSubtree ( methodName , getLevel ( ) , false , false ) ; final DetailAST lparen = getMainAst ( ) ; final DetailAST rparen = getMainAst ( ) . findFirstToken ( TokenTypes . RPAREN ) ; checkLParen ( lparen ) ; if ( rparen . getLineNo ( ) == lparen . getLineNo ( ) ) { return ; } checkExpressionSubtree ( getMainAst ( ) . findFirstToken ( TokenTypes . ELIST ) , new IndentLevel ( getLevel ( ) , getBasicOffset ( ) ) , false , true ) ; checkRParen ( lparen , rparen ) ; final LineWrappingHandler lineWrap = new LineWrappingHandler ( getIndentCheck ( ) , getMainAst ( ) , getMethodCallLastNode ( getMainAst ( ) ) ) ; lineWrap . checkIndentation ( ) ; } @ Override protected boolean shouldIncreaseIndent ( ) { return false ; } private static DetailAST getMethodCallLastNode ( DetailAST firstNode ) { DetailAST lastNode ; if ( firstNode . getNextSibling ( ) == null ) { lastNode = firstNode . getLastChild ( ) ; } else { lastNode = firstNode . getNextSibling ( ) ; } return lastNode ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class BlockParentHandler extends AbstractExpressionHandler { private static final int [ ] CHECKED_CHILDREN = new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . EXPR , TokenTypes . OBJBLOCK , TokenTypes . LITERAL_BREAK , TokenTypes . LITERAL_RETURN , TokenTypes . LITERAL_THROW , TokenTypes . LITERAL_CONTINUE , } ; public BlockParentHandler ( IndentationCheck indentCheck , String name , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , name , ast , parent ) ; } protected int [ ] getCheckedChildren ( ) { return CHECKED_CHILDREN . clone ( ) ; } protected DetailAST getToplevelAST ( ) { return getMainAst ( ) ; } protected void checkToplevelToken ( ) { final DetailAST toplevel = getToplevelAST ( ) ; if ( toplevel == null || getLevel ( ) . accept ( expandedTabsColumnNo ( toplevel ) ) || hasLabelBefore ( ) ) { return ; } if ( ! toplevelMustStartLine ( ) && ! startsLine ( toplevel ) ) { return ; } logError ( toplevel , "" , expandedTabsColumnNo ( toplevel ) ) ; } protected boolean hasLabelBefore ( ) { final DetailAST parent = getToplevelAST ( ) . getParent ( ) ; return parent != null && parent . getType ( ) == TokenTypes . LABELED_STAT && parent . getLineNo ( ) == getToplevelAST ( ) . getLineNo ( ) ; } protected boolean toplevelMustStartLine ( ) { return true ; } protected boolean hasCurlys ( ) { return getLCurly ( ) != null && getRCurly ( ) != null ; } protected DetailAST getLCurly ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . SLIST ) ; } protected DetailAST getRCurly ( ) { final DetailAST slist = getMainAst ( ) . findFirstToken ( TokenTypes . SLIST ) ; if ( slist == null ) { return null ; } return slist . findFirstToken ( TokenTypes . RCURLY ) ; } protected void checkLCurly ( ) { final DetailAST lcurly = getLCurly ( ) ; final int lcurlyPos = expandedTabsColumnNo ( lcurly ) ; if ( curlyLevel ( ) . accept ( lcurlyPos ) || ! startsLine ( lcurly ) ) { return ; } logError ( lcurly , "lcurly" , lcurlyPos ) ; } protected IndentLevel curlyLevel ( ) { return new IndentLevel ( getLevel ( ) , getBraceAdjustment ( ) ) ; } protected boolean rcurlyMustStart ( ) { return true ; } protected boolean childrenMayNest ( ) { return false ; } protected void checkRCurly ( ) { final DetailAST lcurly = getLCurly ( ) ; final DetailAST rcurly = getRCurly ( ) ; final int rcurlyPos = expandedTabsColumnNo ( rcurly ) ; if ( curlyLevel ( ) . accept ( rcurlyPos ) || ! rcurlyMustStart ( ) && ! startsLine ( rcurly ) || areOnSameLine ( rcurly , lcurly ) ) { return ; } logError ( rcurly , "rcurly" , rcurlyPos , curlyLevel ( ) ) ; } protected DetailAST getNonlistChild ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . RPAREN ) . getNextSibling ( ) ; } private void checkNonlistChild ( ) { final DetailAST nonlist = getNonlistChild ( ) ; if ( nonlist == null ) { return ; } final IndentLevel expected = new IndentLevel ( getLevel ( ) , getBasicOffset ( ) ) ; checkExpressionSubtree ( nonlist , expected , false , false ) ; } protected DetailAST getListChild ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . SLIST ) ; } protected DetailAST getRParen ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . RPAREN ) ; } protected DetailAST getLParen ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . LPAREN ) ; } @ Override public void checkIndentation ( ) { checkToplevelToken ( ) ; checkLParen ( getLParen ( ) ) ; checkRParen ( getLParen ( ) , getRParen ( ) ) ; if ( hasCurlys ( ) ) { checkLCurly ( ) ; checkRCurly ( ) ; } final DetailAST listChild = getListChild ( ) ; if ( listChild != null ) { if ( ! hasCurlys ( ) || ! areOnSameLine ( getLCurly ( ) , getRCurly ( ) ) ) { checkChildren ( listChild , getCheckedChildren ( ) , getChildrenExpectedLevel ( ) , true , childrenMayNest ( ) ) ; } } else { checkNonlistChild ( ) ; } } protected IndentLevel getChildrenExpectedLevel ( ) { if ( getLevel ( ) . isMultiLevel ( ) && hasCurlys ( ) && ! areOnSameLine ( getLCurly ( ) , getRCurly ( ) ) ) { if ( startsLine ( getLCurly ( ) ) ) { return new IndentLevel ( expandedTabsColumnNo ( getLCurly ( ) ) + getBasicOffset ( ) ) ; } else if ( startsLine ( getRCurly ( ) ) ) { final IndentLevel level = new IndentLevel ( curlyLevel ( ) , getBasicOffset ( ) ) ; level . addAcceptedIndent ( level . getFirstIndentLevel ( ) + getLineWrappingIndent ( ) ) ; return level ; } } return new IndentLevel ( getLevel ( ) , getBasicOffset ( ) ) ; } @ Override public IndentLevel suggestedChildLevel ( AbstractExpressionHandler child ) { return getChildrenExpectedLevel ( ) ; } private int getLineWrappingIndent ( ) { return getIndentCheck ( ) . getLineWrappingIndentation ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . SeparatorWrapCheck . LINE_NEW ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . SeparatorWrapCheck . LINE_PREVIOUS ; public class SeparatorWrapCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( SeparatorWrapCheck . class ) ; } @ Test public void testDot ( ) throws Exception { checkConfig . addAttribute ( "option" , "NL" ) ; checkConfig . addAttribute ( "tokens" , "DOT" ) ; final String [ ] expected = { "31:10: " + getCheckMessage ( LINE_NEW , "." ) , } ; verify ( checkConfig , getPath ( "whitespace/InputSeparatorWrap.java" ) , expected ) ; } @ Test public void testComma ( ) throws Exception { checkConfig . addAttribute ( "option" , "EOL" ) ; checkConfig . addAttribute ( "tokens" , "COMMA" ) ; final String [ ] expected = { "39:17: " + getCheckMessage ( LINE_PREVIOUS , "," ) , } ; verify ( checkConfig , getPath ( "whitespace/InputSeparatorWrap.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class SlistHandler extends BlockParentHandler { public SlistHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "block" , ast , parent ) ; } @ Override public IndentLevel suggestedChildLevel ( AbstractExpressionHandler child ) { if ( getParent ( ) instanceof BlockParentHandler && ! ( getParent ( ) instanceof SlistHandler ) || getParent ( ) instanceof CaseHandler && child instanceof SlistHandler ) { return getParent ( ) . suggestedChildLevel ( child ) ; } return super . suggestedChildLevel ( child ) ; } @ Override protected DetailAST getNonlistChild ( ) { return null ; } @ Override protected DetailAST getListChild ( ) { return getMainAst ( ) ; } @ Override protected DetailAST getLCurly ( ) { return getMainAst ( ) ; } @ Override protected DetailAST getRCurly ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . RCURLY ) ; } @ Override protected DetailAST getToplevelAST ( ) { return null ; } private boolean hasBlockParent ( ) { final int parentType = getMainAst ( ) . getParent ( ) . getType ( ) ; return parentType == TokenTypes . LITERAL_IF || parentType == TokenTypes . LITERAL_FOR || parentType == TokenTypes . LITERAL_WHILE || parentType == TokenTypes . LITERAL_DO || parentType == TokenTypes . LITERAL_ELSE || parentType == TokenTypes . LITERAL_TRY || parentType == TokenTypes . LITERAL_CATCH || parentType == TokenTypes . LITERAL_FINALLY || parentType == TokenTypes . CTOR_DEF || parentType == TokenTypes . METHOD_DEF || parentType == TokenTypes . STATIC_INIT || parentType == TokenTypes . LITERAL_SYNCHRONIZED ; } @ Override public void checkIndentation ( ) { if ( hasBlockParent ( ) || isSameLineCaseGroup ( ) ) { return ; } super . checkIndentation ( ) ; } private boolean isSameLineCaseGroup ( ) { final DetailAST parentNode = getMainAst ( ) . getParent ( ) ; return parentNode . getType ( ) == TokenTypes . CASE_GROUP && getMainAst ( ) . getLineNo ( ) == parentNode . getLineNo ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ArrayInitHandler extends BlockParentHandler { public ArrayInitHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "array initialization" , ast , parent ) ; } @ Override protected IndentLevel getLevelImpl ( ) { final DetailAST parentAST = getMainAst ( ) . getParent ( ) ; final int type = parentAST . getType ( ) ; if ( type == TokenTypes . LITERAL_NEW || type == TokenTypes . ASSIGN ) { return new IndentLevel ( getLineStart ( parentAST ) ) ; } else if ( getParent ( ) instanceof ArrayInitHandler ) { return ( ( ArrayInitHandler ) getParent ( ) ) . getChildrenExpectedLevel ( ) ; } else { return getParent ( ) . getLevel ( ) ; } } @ Override protected DetailAST getToplevelAST ( ) { return null ; } @ Override protected DetailAST getLCurly ( ) { return getMainAst ( ) ; } @ Override protected IndentLevel curlyLevel ( ) { final IndentLevel level = new IndentLevel ( getLevel ( ) , getBraceAdjustment ( ) ) ; level . addAcceptedIndent ( level . getLastIndentLevel ( ) + getLineWrappingIndent ( ) ) ; return level ; } @ Override protected DetailAST getRCurly ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . RCURLY ) ; } @ Override protected boolean rcurlyMustStart ( ) { return false ; } @ Override protected boolean childrenMayNest ( ) { return true ; } @ Override protected DetailAST getListChild ( ) { return getMainAst ( ) ; } @ Override protected IndentLevel getChildrenExpectedLevel ( ) { final IndentLevel expectedIndent = new IndentLevel ( getLevel ( ) , getIndentCheck ( ) . getArrayInitIndent ( ) , getIndentCheck ( ) . getLineWrappingIndentation ( ) ) ; final int firstLine = getFirstLine ( Integer . MAX_VALUE , getListChild ( ) ) ; if ( hasCurlys ( ) && firstLine == getLCurly ( ) . getLineNo ( ) ) { final int lcurlyPos = expandedTabsColumnNo ( getLCurly ( ) ) ; final int firstChildPos = getNextFirstNonblankOnLineAfter ( firstLine , lcurlyPos ) ; if ( firstChildPos >= 0 ) { expectedIndent . addAcceptedIndent ( firstChildPos ) ; expectedIndent . addAcceptedIndent ( lcurlyPos + getLineWrappingIndent ( ) ) ; } } return expectedIndent ; } private int getNextFirstNonblankOnLineAfter ( int lineNo , int columnNo ) { int realColumnNo = columnNo + 1 ; final String line = getIndentCheck ( ) . getLines ( ) [ lineNo - 1 ] ; final int lineLength = line . length ( ) ; while ( realColumnNo < lineLength && Character . isWhitespace ( line . charAt ( realColumnNo ) ) ) { realColumnNo ++ ; } return realColumnNo == lineLength ? - 1 : realColumnNo ; } private int getLineWrappingIndent ( ) { return getIndentCheck ( ) . getLineWrappingIndentation ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ClassDefHandler extends BlockParentHandler { public ClassDefHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , ast . getType ( ) == TokenTypes . CLASS_DEF ? "class def" : ast . getType ( ) == TokenTypes . ENUM_DEF ? "enum def" : "interface def" , ast , parent ) ; } @ Override protected DetailAST getLCurly ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . OBJBLOCK ) . findFirstToken ( TokenTypes . LCURLY ) ; } @ Override protected DetailAST getRCurly ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . OBJBLOCK ) . findFirstToken ( TokenTypes . RCURLY ) ; } @ Override protected DetailAST getToplevelAST ( ) { return null ; } @ Override protected DetailAST getListChild ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . OBJBLOCK ) ; } @ Override public void checkIndentation ( ) { final DetailAST modifiers = getMainAst ( ) . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( modifiers . getChildCount ( ) == 0 ) { final DetailAST ident = getMainAst ( ) . findFirstToken ( TokenTypes . IDENT ) ; final int lineStart = getLineStart ( ident ) ; if ( ! getLevel ( ) . accept ( lineStart ) ) { logError ( ident , "ident" , lineStart ) ; } } else { checkModifiers ( ) ; } final LineWrappingHandler lineWrap = new LineWrappingHandler ( getIndentCheck ( ) , getMainAst ( ) , getMainAst ( ) . getLastChild ( ) ) ; lineWrap . checkIndentation ( ) ; super . checkIndentation ( ) ; } @ Override protected int [ ] getCheckedChildren ( ) { return new int [ ] { TokenTypes . EXPR , TokenTypes . OBJBLOCK , TokenTypes . LITERAL_BREAK , TokenTypes . LITERAL_RETURN , TokenTypes . LITERAL_THROW , TokenTypes . LITERAL_CONTINUE , } ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class IndexHandler extends AbstractExpressionHandler { public IndexHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "index op" , ast , parent ) ; } @ Override public void checkIndentation ( ) { } @ Override public IndentLevel suggestedChildLevel ( AbstractExpressionHandler child ) { return getLevel ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ElseHandler extends BlockParentHandler { public ElseHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "else" , ast , parent ) ; } @ Override protected void checkToplevelToken ( ) { final DetailAST ifAST = getMainAst ( ) . getParent ( ) ; if ( ifAST != null ) { final DetailAST slist = ifAST . findFirstToken ( TokenTypes . SLIST ) ; if ( slist != null ) { final DetailAST lcurly = slist . getLastChild ( ) ; if ( lcurly != null && lcurly . getLineNo ( ) == getMainAst ( ) . getLineNo ( ) ) { return ; } } } super . checkToplevelToken ( ) ; } @ Override protected DetailAST getNonlistChild ( ) { return getMainAst ( ) . getFirstChild ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class LabelHandler extends AbstractExpressionHandler { private static final int [ ] LABEL_CHILDREN = new int [ ] { TokenTypes . IDENT , } ; public LabelHandler ( IndentationCheck indentCheck , DetailAST expr , AbstractExpressionHandler parent ) { super ( indentCheck , "label" , expr , parent ) ; } @ Override protected IndentLevel getLevelImpl ( ) { final IndentLevel level = new IndentLevel ( super . getLevelImpl ( ) , - getBasicOffset ( ) ) ; level . addAcceptedIndent ( super . getLevelImpl ( ) ) ; return level ; } private void checkLabel ( ) { checkChildren ( getMainAst ( ) , LABEL_CHILDREN , getLevel ( ) , true , false ) ; } @ Override public void checkIndentation ( ) { checkLabel ( ) ; final DetailAST parent = getMainAst ( ) . getFirstChild ( ) . getNextSibling ( ) ; final IndentLevel expected = new IndentLevel ( getLevel ( ) , getBasicOffset ( ) ) ; checkExpressionSubtree ( parent , expected , true , false ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class MethodDefHandler extends BlockParentHandler { public MethodDefHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , ast . getType ( ) == TokenTypes . CTOR_DEF ? "ctor def" : "method def" , ast , parent ) ; } @ Override protected DetailAST getToplevelAST ( ) { return null ; } @ Override protected void checkModifiers ( ) { final DetailAST modifier = getMainAst ( ) . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( startsLine ( modifier ) && ! getLevel ( ) . accept ( expandedTabsColumnNo ( modifier ) ) ) { logError ( modifier , "modifier" , expandedTabsColumnNo ( modifier ) ) ; } } @ Override public void checkIndentation ( ) { checkModifiers ( ) ; final LineWrappingHandler lineWrap = new LineWrappingHandler ( getIndentCheck ( ) , getMainAst ( ) , getMethodDefParamRightParen ( getMainAst ( ) ) ) ; lineWrap . checkIndentation ( ) ; if ( getLCurly ( ) == null ) { return ; } super . checkIndentation ( ) ; } private static DetailAST getMethodDefParamRightParen ( DetailAST methodDefAst ) { return methodDefAst . findFirstToken ( TokenTypes . RPAREN ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; public class PrimordialHandler extends AbstractExpressionHandler { public PrimordialHandler ( IndentationCheck indentCheck ) { super ( indentCheck , null , null , null ) ; } @ Override public void checkIndentation ( ) { } @ Override public IndentLevel suggestedChildLevel ( AbstractExpressionHandler child ) { return new IndentLevel ( 0 ) ; } @ Override protected IndentLevel getLevelImpl ( ) { return new IndentLevel ( 0 ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class SwitchHandler extends BlockParentHandler { public SwitchHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "switch" , ast , parent ) ; } @ Override protected DetailAST getLCurly ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . LCURLY ) ; } @ Override protected DetailAST getRCurly ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . RCURLY ) ; } @ Override protected DetailAST getListChild ( ) { return null ; } @ Override protected DetailAST getNonlistChild ( ) { return null ; } private void checkSwitchExpr ( ) { checkExpressionSubtree ( getMainAst ( ) . findFirstToken ( TokenTypes . LPAREN ) . getNextSibling ( ) , getLevel ( ) , false , false ) ; } @ Override public void checkIndentation ( ) { checkSwitchExpr ( ) ; super . checkIndentation ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import java . util . Collection ; import java . util . Iterator ; import java . util . NavigableMap ; import java . util . TreeMap ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class LineWrappingHandler { private final IndentationCheck indentCheck ; private DetailAST firstNode ; private DetailAST lastNode ; private int indentLevel ; private boolean forceStrictCondition ; public LineWrappingHandler ( IndentationCheck instance , DetailAST firstNode , DetailAST lastNode ) { indentCheck = instance ; this . firstNode = firstNode ; this . lastNode = lastNode ; indentLevel = indentCheck . getLineWrappingIndentation ( ) ; forceStrictCondition = indentCheck . isForceStrictCondition ( ) ; } protected final DetailAST getLastNode ( ) { return lastNode ; } public void checkIndentation ( ) { final NavigableMap < Integer , DetailAST > firstNodesOnLines = collectFirstNodes ( ) ; final DetailAST firstNode = firstNodesOnLines . get ( firstNodesOnLines . firstKey ( ) ) ; if ( firstNode . getType ( ) == TokenTypes . AT ) { checkAnnotationIndentation ( firstNode , firstNodesOnLines ) ; } firstNodesOnLines . remove ( firstNodesOnLines . firstKey ( ) ) ; final int firstNodeIndent = getFirstNodeIndent ( firstNode ) ; final int currentIndent = firstNodeIndent + indentLevel ; for ( DetailAST node : firstNodesOnLines . values ( ) ) { final int currentType = node . getType ( ) ; if ( currentType == TokenTypes . RCURLY || currentType == TokenTypes . RPAREN || currentType == TokenTypes . ARRAY_INIT ) { logWarningMessage ( node , firstNodeIndent ) ; } else if ( currentType == TokenTypes . LITERAL_IF ) { final DetailAST parent = node . getParent ( ) ; if ( parent . getType ( ) == TokenTypes . LITERAL_ELSE ) { logWarningMessage ( parent , currentIndent ) ; } } else { logWarningMessage ( node , currentIndent ) ; } } } private int getFirstNodeIndent ( DetailAST node ) { int indentLevel = node . getColumnNo ( ) ; if ( node . getType ( ) == TokenTypes . LITERAL_IF && node . getParent ( ) . getType ( ) == TokenTypes . LITERAL_ELSE ) { final DetailAST lcurly = node . getParent ( ) . getPreviousSibling ( ) ; final DetailAST rcurly = lcurly . getLastChild ( ) ; if ( lcurly . getType ( ) == TokenTypes . SLIST && rcurly . getLineNo ( ) == node . getLineNo ( ) ) { indentLevel = rcurly . getColumnNo ( ) ; } else { indentLevel = node . getParent ( ) . getColumnNo ( ) ; } } return indentLevel ; } private NavigableMap < Integer , DetailAST > collectFirstNodes ( ) { final NavigableMap < Integer , DetailAST > result = new TreeMap < > ( ) ; result . put ( firstNode . getLineNo ( ) , firstNode ) ; DetailAST curNode = firstNode . getFirstChild ( ) ; while ( curNode != null && curNode != lastNode ) { if ( curNode . getType ( ) == TokenTypes . OBJBLOCK ) { curNode = curNode . getNextSibling ( ) ; } if ( curNode != null ) { final DetailAST firstTokenOnLine = result . get ( curNode . getLineNo ( ) ) ; if ( firstTokenOnLine == null || firstTokenOnLine != null && firstTokenOnLine . getColumnNo ( ) >= curNode . getColumnNo ( ) ) { result . put ( curNode . getLineNo ( ) , curNode ) ; } curNode = getNextCurNode ( curNode ) ; } } return result ; } private DetailAST getNextCurNode ( DetailAST curNode ) { DetailAST nodeToVisit = curNode . getFirstChild ( ) ; DetailAST currentNode = curNode ; while ( currentNode != null && nodeToVisit == null ) { nodeToVisit = currentNode . getNextSibling ( ) ; if ( nodeToVisit == null ) { currentNode = currentNode . getParent ( ) ; } } return nodeToVisit ; } private void checkAnnotationIndentation ( DetailAST atNode , NavigableMap < Integer , DetailAST > firstNodesOnLines ) { final int currentIndent = atNode . getColumnNo ( ) + indentLevel ; final int firstNodeIndent = atNode . getColumnNo ( ) ; final Collection < DetailAST > values = firstNodesOnLines . values ( ) ; final DetailAST lastAnnotationNode = getLastAnnotationNode ( atNode ) ; final int lastAnnotationLine = lastAnnotationNode . getLineNo ( ) ; final int lastAnnotattionColumn = lastAnnotationNode . getColumnNo ( ) ; final Iterator < DetailAST > itr = values . iterator ( ) ; while ( itr . hasNext ( ) && firstNodesOnLines . size ( ) > 1 ) { final DetailAST node = itr . next ( ) ; if ( node . getLineNo ( ) < lastAnnotationLine || node . getLineNo ( ) == lastAnnotationLine && node . getColumnNo ( ) <= lastAnnotattionColumn ) { final DetailAST parentNode = node . getParent ( ) ; if ( node . getType ( ) == TokenTypes . AT && parentNode . getParent ( ) . getType ( ) == TokenTypes . MODIFIERS ) { logWarningMessage ( node , firstNodeIndent ) ; } else { logWarningMessage ( node , currentIndent ) ; } itr . remove ( ) ; } else { break ; } } } private DetailAST getLastAnnotationNode ( DetailAST atNode ) { DetailAST lastAnnotation = atNode . getParent ( ) ; while ( lastAnnotation . getNextSibling ( ) != null && lastAnnotation . getNextSibling ( ) . getType ( ) == TokenTypes . ANNOTATION ) { lastAnnotation = lastAnnotation . getNextSibling ( ) ; } return lastAnnotation . getLastChild ( ) ; } private void logWarningMessage ( DetailAST currentNode , int currentIndent ) { if ( forceStrictCondition ) { if ( currentNode . getColumnNo ( ) != currentIndent ) { indentCheck . indentationLog ( currentNode . getLineNo ( ) , "indentation.error" , currentNode . getText ( ) , currentNode . getColumnNo ( ) , currentIndent ) ; } } else { if ( currentNode . getColumnNo ( ) < currentIndent ) { indentCheck . indentationLog ( currentNode . getLineNo ( ) , "indentation.error" , currentNode . getText ( ) , currentNode . getColumnNo ( ) , currentIndent ) ; } } } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . EmptyLineSeparatorCheck . MSG_MULTIPLE_LINES ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . EmptyLineSeparatorCheck . MSG_SHOULD_BE_SEPARATED ; public class EmptyLineSeparatorCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( EmptyLineSeparatorCheck . class ) ; final String [ ] expected = { "21: " + getCheckMessage ( MSG_SHOULD_BE_SEPARATED , "import" ) , "35: " + getCheckMessage ( MSG_SHOULD_BE_SEPARATED , "CLASS_DEF" ) , "38: " + getCheckMessage ( MSG_SHOULD_BE_SEPARATED , "VARIABLE_DEF" ) , "39: " + getCheckMessage ( MSG_SHOULD_BE_SEPARATED , "STATIC_INIT" ) , "77: " + getCheckMessage ( MSG_SHOULD_BE_SEPARATED , "INTERFACE_DEF" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputEmptyLineSeparatorCheck.java" ) , expected ) ; } @ Test public void testAllowNoEmptyLineBetweenFields ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( EmptyLineSeparatorCheck . class ) ; checkConfig . addAttribute ( "allowNoEmptyLineBetweenFields" , "true" ) ; final String [ ] expected = { "21: " + getCheckMessage ( MSG_SHOULD_BE_SEPARATED , "import" ) , "35: " + getCheckMessage ( MSG_SHOULD_BE_SEPARATED , "CLASS_DEF" ) , "39: " + getCheckMessage ( MSG_SHOULD_BE_SEPARATED , "STATIC_INIT" ) , "77: " + getCheckMessage ( MSG_SHOULD_BE_SEPARATED , "INTERFACE_DEF" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputEmptyLineSeparatorCheck.java" ) , expected ) ; } @ Test public void testHeader ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( EmptyLineSeparatorCheck . class ) ; final String [ ] expected = { "19: " + getCheckMessage ( MSG_SHOULD_BE_SEPARATED , "package" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputEmptyLineSeparatorCheckHeader.java" ) , expected ) ; } @ Test public void testMultipleEmptyLinesBetweenClassMembers ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( EmptyLineSeparatorCheck . class ) ; checkConfig . addAttribute ( "allowMultipleEmptyLines" , "false" ) ; final String [ ] expected = { "21: " + getCheckMessage ( MSG_MULTIPLE_LINES , "package" ) , "24: " + getCheckMessage ( MSG_MULTIPLE_LINES , "import" ) , "33: " + getCheckMessage ( MSG_MULTIPLE_LINES , "VARIABLE_DEF" ) , "38: " + getCheckMessage ( MSG_MULTIPLE_LINES , "VARIABLE_DEF" ) , "43: " + getCheckMessage ( MSG_MULTIPLE_LINES , "METHOD_DEF" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputEmptyLineSeparatorCheckMultipleEmptyLines.java" ) , expected ) ; } @ Test public void testFormerArrayIndexOutOfBounds ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( EmptyLineSeparatorCheck . class ) ; checkConfig . addAttribute ( "allowMultipleEmptyLines" , "false" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "whitespace/InputEmptyLineSeparatorFormerException.java" ) , expected ) ; } @ Test public void testAllowMultipleFieldInClass ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( EmptyLineSeparatorCheck . class ) ; checkConfig . addAttribute ( "allowMultipleEmptyLines" , "false" ) ; checkConfig . addAttribute ( "allowNoEmptyLineBetweenFields" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "whitespace/InputEmptyLineSeparatorMultipleFieldsInClass.java" ) , expected ) ; } @ Test public void testAllowMultipleImportSeparatedFromPackage ( ) throws Exception { DefaultConfiguration checkConfig = createCheckConfig ( EmptyLineSeparatorCheck . class ) ; checkConfig . addAttribute ( "allowMultipleEmptyLines" , "false" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "whitespace/InputEmptyLineSeparatorMultipleImportEmptyClass.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class DoWhileHandler extends BlockParentHandler { public DoWhileHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "do..while" , ast , parent ) ; } private void checkCondExpr ( ) { final DetailAST condAst = getMainAst ( ) . findFirstToken ( TokenTypes . LPAREN ) . getNextSibling ( ) ; checkExpressionSubtree ( condAst , getLevel ( ) , false , false ) ; } @ Override public void checkIndentation ( ) { super . checkIndentation ( ) ; checkCondExpr ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class CaseHandler extends AbstractExpressionHandler { private static final int [ ] CASE_CHILDREN = new int [ ] { TokenTypes . LITERAL_CASE , TokenTypes . LITERAL_DEFAULT , } ; public CaseHandler ( IndentationCheck indentCheck , DetailAST expr , AbstractExpressionHandler parent ) { super ( indentCheck , "case" , expr , parent ) ; } @ Override protected IndentLevel getLevelImpl ( ) { return new IndentLevel ( getParent ( ) . getLevel ( ) , getIndentCheck ( ) . getCaseIndent ( ) ) ; } private void checkCase ( ) { checkChildren ( getMainAst ( ) , CASE_CHILDREN , getLevel ( ) , true , false ) ; } @ Override public IndentLevel suggestedChildLevel ( AbstractExpressionHandler child ) { return getLevel ( ) ; } @ Override public void checkIndentation ( ) { checkCase ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class CatchHandler extends BlockParentHandler { public CatchHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "catch" , ast , parent ) ; } @ Override protected boolean toplevelMustStartLine ( ) { return false ; } private void checkCondExpr ( ) { final DetailAST condAst = getMainAst ( ) . findFirstToken ( TokenTypes . LPAREN ) . getNextSibling ( ) ; checkExpressionSubtree ( condAst , getLevel ( ) , false , false ) ; } @ Override public void checkIndentation ( ) { super . checkIndentation ( ) ; checkCondExpr ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class WhileHandler extends BlockParentHandler { public WhileHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "while" , ast , parent ) ; } private void checkCondExpr ( ) { final DetailAST condAst = getMainAst ( ) . findFirstToken ( TokenTypes . EXPR ) ; final IndentLevel expected = new IndentLevel ( getLevel ( ) , getBasicOffset ( ) ) ; checkExpressionSubtree ( condAst , expected , false , false ) ; } @ Override public void checkIndentation ( ) { checkCondExpr ( ) ; super . checkIndentation ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . google . common . collect . Maps ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . util . Map ; import java . util . Set ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class HandlerFactory { private static final Log LOG = LogFactory . getLog ( HandlerFactory . class ) ; private final Map < Integer , Constructor < ? > > typeHandlers = Maps . newHashMap ( ) ; private final Map < DetailAST , AbstractExpressionHandler > createdHandlers = Maps . newHashMap ( ) ; public HandlerFactory ( ) { register ( TokenTypes . CASE_GROUP , CaseHandler . class ) ; register ( TokenTypes . LITERAL_SWITCH , SwitchHandler . class ) ; register ( TokenTypes . SLIST , SlistHandler . class ) ; register ( TokenTypes . PACKAGE_DEF , PackageDefHandler . class ) ; register ( TokenTypes . LITERAL_ELSE , ElseHandler . class ) ; register ( TokenTypes . LITERAL_IF , IfHandler . class ) ; register ( TokenTypes . LITERAL_TRY , TryHandler . class ) ; register ( TokenTypes . LITERAL_CATCH , CatchHandler . class ) ; register ( TokenTypes . LITERAL_FINALLY , FinallyHandler . class ) ; register ( TokenTypes . LITERAL_DO , DoWhileHandler . class ) ; register ( TokenTypes . LITERAL_WHILE , WhileHandler . class ) ; register ( TokenTypes . LITERAL_FOR , ForHandler . class ) ; register ( TokenTypes . METHOD_DEF , MethodDefHandler . class ) ; register ( TokenTypes . CTOR_DEF , MethodDefHandler . class ) ; register ( TokenTypes . CLASS_DEF , ClassDefHandler . class ) ; register ( TokenTypes . ENUM_DEF , ClassDefHandler . class ) ; register ( TokenTypes . OBJBLOCK , ObjectBlockHandler . class ) ; register ( TokenTypes . INTERFACE_DEF , ClassDefHandler . class ) ; register ( TokenTypes . IMPORT , ImportHandler . class ) ; register ( TokenTypes . ARRAY_INIT , ArrayInitHandler . class ) ; register ( TokenTypes . METHOD_CALL , MethodCallHandler . class ) ; register ( TokenTypes . CTOR_CALL , MethodCallHandler . class ) ; register ( TokenTypes . LABELED_STAT , LabelHandler . class ) ; register ( TokenTypes . STATIC_INIT , StaticInitHandler . class ) ; register ( TokenTypes . INSTANCE_INIT , SlistHandler . class ) ; register ( TokenTypes . VARIABLE_DEF , MemberDefHandler . class ) ; register ( TokenTypes . LITERAL_NEW , NewHandler . class ) ; register ( TokenTypes . INDEX_OP , IndexHandler . class ) ; register ( TokenTypes . LITERAL_SYNCHRONIZED , SynchronizedHandler . class ) ; } private void register ( int type , Class < ? > handlerClass ) { try { final Constructor < ? > ctor = handlerClass . getConstructor ( new Class [ ] { IndentationCheck . class , DetailAST . class , AbstractExpressionHandler . class , } ) ; typeHandlers . put ( type , ctor ) ; } catch ( final NoSuchMethodException | SecurityException e ) { final String message = "couldn't find ctor for " + handlerClass ; LOG . debug ( message , e ) ; throw new RuntimeException ( message ) ; } } public boolean isHandledType ( int type ) { final Set < Integer > typeSet = typeHandlers . keySet ( ) ; return typeSet . contains ( type ) ; } public int [ ] getHandledTypes ( ) { final Set < Integer > typeSet = typeHandlers . keySet ( ) ; final int [ ] types = new int [ typeSet . size ( ) ] ; int index = 0 ; for ( final Integer val : typeSet ) { types [ index ++ ] = val ; } return types ; } public AbstractExpressionHandler getHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { final AbstractExpressionHandler handler = createdHandlers . get ( ast ) ; if ( handler != null ) { return handler ; } if ( ast . getType ( ) == TokenTypes . METHOD_CALL ) { return createMethodCallHandler ( indentCheck , ast , parent ) ; } AbstractExpressionHandler expHandler = null ; try { final Constructor < ? > handlerCtor = typeHandlers . get ( ast . getType ( ) ) ; if ( handlerCtor != null ) { expHandler = ( AbstractExpressionHandler ) handlerCtor . newInstance ( indentCheck , ast , parent ) ; } } catch ( final InstantiationException | InvocationTargetException e ) { final String message = "couldn't instantiate constructor for " + ast ; LOG . debug ( message , e ) ; throw new RuntimeException ( message ) ; } catch ( final IllegalAccessException e ) { final String message = "couldn't access constructor for " + ast ; LOG . debug ( message , e ) ; throw new RuntimeException ( message ) ; } if ( expHandler == null ) { throw new RuntimeException ( "no handler for type " + ast . getType ( ) ) ; } return expHandler ; } AbstractExpressionHandler createMethodCallHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { AbstractExpressionHandler theParent = parent ; DetailAST astNode = ast . getFirstChild ( ) ; while ( astNode != null && astNode . getType ( ) == TokenTypes . DOT ) { astNode = astNode . getFirstChild ( ) ; } if ( astNode != null && isHandledType ( astNode . getType ( ) ) ) { theParent = getHandler ( indentCheck , astNode , theParent ) ; createdHandlers . put ( astNode , theParent ) ; } return new MethodCallHandler ( indentCheck , ast , theParent ) ; } void clearCreatedHandlers ( ) { createdHandlers . clear ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ForHandler extends BlockParentHandler { public ForHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "for" , ast , parent ) ; } private void checkForParams ( ) { final IndentLevel expected = new IndentLevel ( getLevel ( ) , getBasicOffset ( ) ) ; final DetailAST init = getMainAst ( ) . findFirstToken ( TokenTypes . FOR_INIT ) ; if ( init != null ) { checkExpressionSubtree ( init , expected , false , false ) ; final DetailAST cond = getMainAst ( ) . findFirstToken ( TokenTypes . FOR_CONDITION ) ; checkExpressionSubtree ( cond , expected , false , false ) ; final DetailAST iter = getMainAst ( ) . findFirstToken ( TokenTypes . FOR_ITERATOR ) ; checkExpressionSubtree ( iter , expected , false , false ) ; } else { final DetailAST forEach = getMainAst ( ) . findFirstToken ( TokenTypes . FOR_EACH_CLAUSE ) ; checkExpressionSubtree ( forEach , expected , false , false ) ; } } @ Override public void checkIndentation ( ) { checkForParams ( ) ; super . checkIndentation ( ) ; final LineWrappingHandler lineWrap = new LineWrappingHandler ( getIndentCheck ( ) , getMainAst ( ) , getForLoopRightParen ( getMainAst ( ) ) ) ; lineWrap . checkIndentation ( ) ; } @ Override public IndentLevel suggestedChildLevel ( AbstractExpressionHandler child ) { if ( child instanceof ElseHandler ) { return getLevel ( ) ; } return super . suggestedChildLevel ( child ) ; } private static DetailAST getForLoopRightParen ( DetailAST literalForAst ) { return literalForAst . findFirstToken ( TokenTypes . RPAREN ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class MemberDefHandler extends AbstractExpressionHandler { public MemberDefHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "member def" , ast , parent ) ; } @ Override public void checkIndentation ( ) { final DetailAST modifiersNode = getMainAst ( ) . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( modifiersNode . getChildCount ( ) != 0 ) { checkModifiers ( ) ; } else { checkType ( ) ; } final LineWrappingHandler lineWrap = new LineWrappingHandler ( getIndentCheck ( ) , getMainAst ( ) , getVarDefStatementSemicolon ( getMainAst ( ) ) ) ; if ( lineWrap . getLastNode ( ) != null && ! isArrayDeclaration ( getMainAst ( ) ) ) { lineWrap . checkIndentation ( ) ; } } @ Override public IndentLevel suggestedChildLevel ( AbstractExpressionHandler child ) { return getLevel ( ) ; } @ Override protected void checkModifiers ( ) { final DetailAST modifier = getMainAst ( ) . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( startsLine ( modifier ) && ! getLevel ( ) . accept ( expandedTabsColumnNo ( modifier ) ) ) { logError ( modifier , "modifier" , expandedTabsColumnNo ( modifier ) ) ; } } private void checkType ( ) { final DetailAST type = getMainAst ( ) . findFirstToken ( TokenTypes . TYPE ) ; final DetailAST ident = AbstractExpressionHandler . getFirstToken ( type ) ; final int columnNo = expandedTabsColumnNo ( ident ) ; if ( startsLine ( ident ) && ! getLevel ( ) . accept ( columnNo ) ) { logError ( ident , "type" , columnNo ) ; } } private boolean isArrayDeclaration ( DetailAST variableDef ) { return variableDef . findFirstToken ( TokenTypes . TYPE ) . findFirstToken ( TokenTypes . ARRAY_DECLARATOR ) != null ; } private static DetailAST getVarDefStatementSemicolon ( DetailAST variableDef ) { DetailAST lastNode = variableDef . getLastChild ( ) ; if ( lastNode . getType ( ) != TokenTypes . SEMI ) { lastNode = variableDef . getNextSibling ( ) ; } return lastNode ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class IfHandler extends BlockParentHandler { public IfHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "if" , ast , parent ) ; } @ Override public IndentLevel suggestedChildLevel ( AbstractExpressionHandler child ) { if ( child instanceof ElseHandler ) { return getLevel ( ) ; } return super . suggestedChildLevel ( child ) ; } @ Override protected IndentLevel getLevelImpl ( ) { if ( isIfAfterElse ( ) ) { return getParent ( ) . getLevel ( ) ; } return super . getLevelImpl ( ) ; } private boolean isIfAfterElse ( ) { final DetailAST parent = getMainAst ( ) . getParent ( ) ; return parent . getType ( ) == TokenTypes . LITERAL_ELSE && parent . getLineNo ( ) == getMainAst ( ) . getLineNo ( ) ; } @ Override protected void checkToplevelToken ( ) { if ( isIfAfterElse ( ) ) { return ; } super . checkToplevelToken ( ) ; } private void checkCondExpr ( ) { final DetailAST condAst = getMainAst ( ) . findFirstToken ( TokenTypes . LPAREN ) . getNextSibling ( ) ; final IndentLevel expected = new IndentLevel ( getLevel ( ) , getBasicOffset ( ) ) ; checkExpressionSubtree ( condAst , expected , false , false ) ; } @ Override public void checkIndentation ( ) { super . checkIndentation ( ) ; checkCondExpr ( ) ; final LineWrappingHandler lineWrap = new LineWrappingHandler ( getIndentCheck ( ) , getMainAst ( ) , getIfStatementRightParen ( getMainAst ( ) ) ) ; lineWrap . checkIndentation ( ) ; } private static DetailAST getIfStatementRightParen ( DetailAST literalIfAst ) { return literalIfAst . findFirstToken ( TokenTypes . RPAREN ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class PackageDefHandler extends AbstractExpressionHandler { public PackageDefHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "package def" , ast , parent ) ; } @ Override public void checkIndentation ( ) { final int columnNo = expandedTabsColumnNo ( getMainAst ( ) ) ; if ( ! getLevel ( ) . accept ( columnNo ) ) { logError ( getMainAst ( ) , "" , columnNo ) ; } checkLinesIndent ( getMainAst ( ) . getLineNo ( ) , getMainAst ( ) . findFirstToken ( TokenTypes . SEMI ) . getLineNo ( ) , getLevel ( ) ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ObjectBlockHandler extends BlockParentHandler { public ObjectBlockHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "object def" , ast , parent ) ; } @ Override protected DetailAST getToplevelAST ( ) { return null ; } @ Override protected DetailAST getLCurly ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . LCURLY ) ; } @ Override protected DetailAST getRCurly ( ) { return getMainAst ( ) . findFirstToken ( TokenTypes . RCURLY ) ; } @ Override protected DetailAST getListChild ( ) { return getMainAst ( ) ; } @ Override protected IndentLevel getLevelImpl ( ) { final DetailAST parentAST = getMainAst ( ) . getParent ( ) ; IndentLevel indent = getParent ( ) . getLevel ( ) ; if ( parentAST . getType ( ) == TokenTypes . LITERAL_NEW ) { indent . addAcceptedIndent ( super . getLevelImpl ( ) ) ; } else if ( parentAST . getType ( ) == TokenTypes . ENUM_CONSTANT_DEF ) { indent = super . getLevelImpl ( ) ; } return indent ; } @ Override public void checkIndentation ( ) { final DetailAST parentAST = getMainAst ( ) . getParent ( ) ; if ( parentAST . getType ( ) != TokenTypes . LITERAL_NEW ) { return ; } super . checkIndentation ( ) ; } @ Override protected boolean rcurlyMustStart ( ) { return false ; } @ Override protected void checkRCurly ( ) { final DetailAST lcurly = getLCurly ( ) ; final DetailAST rcurly = getRCurly ( ) ; final int rcurlyPos = expandedTabsColumnNo ( rcurly ) ; final IndentLevel level = curlyLevel ( ) ; level . addAcceptedIndent ( level . getFirstIndentLevel ( ) + getLineWrappingIndent ( ) ) ; if ( ! level . accept ( rcurlyPos ) && ( rcurlyMustStart ( ) || startsLine ( rcurly ) ) && ! areOnSameLine ( rcurly , lcurly ) ) { logError ( rcurly , "rcurly" , rcurlyPos , curlyLevel ( ) ) ; } } private int getLineWrappingIndent ( ) { return getIndentCheck ( ) . getLineWrappingIndentation ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . NoWhitespaceAfterCheck . MSG_KEY ; public class NoWhitespaceAfterCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( NoWhitespaceAfterCheck . class ) ; } @ Test public void testDefault ( ) throws Exception { checkConfig . addAttribute ( "allowLineBreaks" , "false" ) ; final String [ ] expected = { "5:14: " + getCheckMessage ( MSG_KEY , "." ) , "6:12: " + getCheckMessage ( MSG_KEY , "." ) , "29:14: " + getCheckMessage ( MSG_KEY , "-" ) , "29:21: " + getCheckMessage ( MSG_KEY , "+" ) , "31:15: " + getCheckMessage ( MSG_KEY , "++" ) , "31:22: " + getCheckMessage ( MSG_KEY , "--" ) , "111:22: " + getCheckMessage ( MSG_KEY , "!" ) , "112:23: " + getCheckMessage ( MSG_KEY , "~" ) , "129:24: " + getCheckMessage ( MSG_KEY , "." ) , "132:11: " + getCheckMessage ( MSG_KEY , "." ) , "136:12: " + getCheckMessage ( MSG_KEY , "." ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void testDotAllowLineBreaks ( ) throws Exception { checkConfig . addAttribute ( "tokens" , "DOT" ) ; final String [ ] expected = { "5:14: " + getCheckMessage ( MSG_KEY , "." ) , "129:24: " + getCheckMessage ( MSG_KEY , "." ) , "136:12: " + getCheckMessage ( MSG_KEY , "." ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void testTypecast ( ) throws Exception { checkConfig . addAttribute ( "tokens" , "TYPECAST" ) ; final String [ ] expected = { "87:28: " + getCheckMessage ( MSG_KEY , ")" ) , "89:23: " + getCheckMessage ( MSG_KEY , ")" ) , "241:22: " + getCheckMessage ( MSG_KEY , ")" ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void testArrayDeclarations ( ) throws Exception { checkConfig . addAttribute ( "tokens" , "ARRAY_DECLARATOR" ) ; final String [ ] expected = { "6:11: " + getCheckMessage ( MSG_KEY , "Object" ) , "8:22: " + getCheckMessage ( MSG_KEY , "someStuff3" ) , "9:8: " + getCheckMessage ( MSG_KEY , "int" ) , "10:13: " + getCheckMessage ( MSG_KEY , "s" ) , "11:13: " + getCheckMessage ( MSG_KEY , "d" ) , "16:14: " + getCheckMessage ( MSG_KEY , "get" ) , "18:8: " + getCheckMessage ( MSG_KEY , "int" ) , "19:34: " + getCheckMessage ( MSG_KEY , "get1" ) , "28:8: " + getCheckMessage ( MSG_KEY , "int" ) , "29:12: " + getCheckMessage ( MSG_KEY , "cba" ) , "31:26: " + getCheckMessage ( MSG_KEY , "String" ) , "32:27: " + getCheckMessage ( MSG_KEY , "String" ) , "39:11: " + getCheckMessage ( MSG_KEY , "ar" ) , "39:24: " + getCheckMessage ( MSG_KEY , "int" ) , "40:16: " + getCheckMessage ( MSG_KEY , "int" ) , "43:63: " + getCheckMessage ( MSG_KEY , "getLongMultArray" ) , } ; verify ( checkConfig , getPath ( "whitespace/InputNoWhitespaceAfterArrayDeclarations.java" ) , expected ) ; } @ Test public void testNpe ( ) throws Exception { final String [ ] expected = { } ; verify ( checkConfig , getPath ( "whitespace/InputNoWhiteSpaceAfterCheckFormerNpe.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . google . common . collect . Maps ; import java . util . SortedMap ; public class LineSet { private final SortedMap < Integer , Integer > lines = Maps . newTreeMap ( ) ; public Integer getStartColumn ( Integer lineNum ) { return lines . get ( lineNum ) ; } public int firstLineCol ( ) { final Object firstLineKey = lines . firstKey ( ) ; return lines . get ( firstLineKey ) . intValue ( ) ; } public int firstLine ( ) { return lines . firstKey ( ) . intValue ( ) ; } public int lastLine ( ) { return lines . lastKey ( ) . intValue ( ) ; } public void addLineAndCol ( int lineNum , int col ) { lines . put ( lineNum , col ) ; } public boolean isEmpty ( ) { return lines . isEmpty ( ) ; } @ Override public String toString ( ) { return "LineSet[firstLine=" + firstLine ( ) + ", lastLine=" + lastLine ( ) + "]" ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class StaticInitHandler extends BlockParentHandler { public StaticInitHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "static initialization" , ast , parent ) ; } @ Override protected boolean toplevelMustStartLine ( ) { return false ; } }
package com . puppycrawl . tools . checkstyle . checks . indentation ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class TryHandler extends BlockParentHandler { public TryHandler ( IndentationCheck indentCheck , DetailAST ast , AbstractExpressionHandler parent ) { super ( indentCheck , "try" , ast , parent ) ; } @ Override public IndentLevel suggestedChildLevel ( AbstractExpressionHandler child ) { if ( child instanceof CatchHandler || child instanceof FinallyHandler ) { return getLevel ( ) ; } return super . suggestedChildLevel ( child ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class AvoidInlineConditionalsCheck extends Check { public static final String MSG_KEY = "inline.conditional.avoid" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . QUESTION } ; } @ Override public int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . QUESTION } ; } @ Override public void visitToken ( DetailAST ast ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . Check ; import java . util . Set ; public abstract class AbstractIllegalCheck extends Check { private final Set < String > illegalClassNames = Sets . newHashSet ( ) ; protected AbstractIllegalCheck ( final String ... initialNames ) { setIllegalClassNames ( initialNames ) ; } protected final boolean isIllegalClassName ( final String ident ) { return illegalClassNames . contains ( ident ) ; } public final void setIllegalClassNames ( final String ... classNames ) { illegalClassNames . clear ( ) ; for ( final String name : classNames ) { illegalClassNames . add ( name ) ; final int lastDot = name . lastIndexOf ( '.' ) ; if ( lastDot > 0 && lastDot < name . length ( ) - 1 ) { final String shortName = name . substring ( name . lastIndexOf ( '.' ) + 1 ) ; illegalClassNames . add ( shortName ) ; } } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; public class SuperCloneCheck extends AbstractSuperCheck { @ Override protected String getMethodName ( ) { return "clone" ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ;
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class DefaultComesLastCheck extends Check { public static final String MSG_KEY = "default.comes.last" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_DEFAULT , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return getDefaultTokens ( ) ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST defaultGroupAST = ast . getParent ( ) ; if ( defaultGroupAST . getType ( ) != TokenTypes . ANNOTATION_FIELD_DEF && defaultGroupAST . getType ( ) != TokenTypes . MODIFIERS ) { final DetailAST switchAST = defaultGroupAST . getParent ( ) ; final DetailAST lastGroupAST = switchAST . getLastChild ( ) . getPreviousSibling ( ) ; if ( defaultGroupAST . getLineNo ( ) != lastGroupAST . getLineNo ( ) || defaultGroupAST . getColumnNo ( ) != lastGroupAST . getColumnNo ( ) ) { log ( ast , MSG_KEY ) ; } } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public final class NestedTryDepthCheck extends AbstractNestedDepthCheck { public static final String MSG_KEY = "nested.try.depth" ; private static final int DEFAULT_MAX = 1 ; public NestedTryDepthCheck ( ) { super ( DEFAULT_MAX ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_TRY } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . LITERAL_TRY } ; } @ Override public void visitToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . LITERAL_TRY ) { visitLiteralTry ( ast ) ; } else { throw new IllegalStateException ( ast . toString ( ) ) ; } } @ Override public void leaveToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . LITERAL_TRY ) { leaveLiteralTry ( ) ; } else { throw new IllegalStateException ( ast . toString ( ) ) ; } } private void visitLiteralTry ( DetailAST literalTry ) { nestIn ( literalTry , MSG_KEY ) ; } private void leaveLiteralTry ( ) { nestOut ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import antlr . collections . AST ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; import java . util . Set ; import java . util . StringTokenizer ; public class IllegalInstantiationCheck extends Check { public static final String MSG_KEY = "instantiation.avoid" ; private static final String JAVA_LANG = "java.lang." ; private final Set < String > illegalClasses = Sets . newHashSet ( ) ; private String pkgName ; private final Set < FullIdent > imports = Sets . newHashSet ( ) ; private final Set < String > classNames = Sets . newHashSet ( ) ; private final Set < DetailAST > instantiations = Sets . newHashSet ( ) ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . LITERAL_NEW , TokenTypes . PACKAGE_DEF , TokenTypes . CLASS_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { } ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . IMPORT , TokenTypes . LITERAL_NEW , TokenTypes . PACKAGE_DEF , } ; } @ Override public void beginTree ( DetailAST rootAST ) { super . beginTree ( rootAST ) ; pkgName = null ; imports . clear ( ) ; instantiations . clear ( ) ; classNames . clear ( ) ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . LITERAL_NEW : processLiteralNew ( ast ) ; break ; case TokenTypes . PACKAGE_DEF : processPackageDef ( ast ) ; break ; case TokenTypes . IMPORT : processImport ( ast ) ; break ; case TokenTypes . CLASS_DEF : processClassDef ( ast ) ; break ; default : throw new IllegalArgumentException ( "Unknown type " + ast ) ; } } @ Override public void finishTree ( DetailAST rootAST ) { for ( DetailAST literalNewAST : instantiations ) { postprocessLiteralNew ( literalNewAST ) ; } } private void processClassDef ( DetailAST ast ) { final DetailAST identToken = ast . findFirstToken ( TokenTypes . IDENT ) ; final String className = identToken . getText ( ) ; classNames . add ( className ) ; } private void processImport ( DetailAST ast ) { final FullIdent name = FullIdent . createFullIdentBelow ( ast ) ; imports . add ( name ) ; } private void processPackageDef ( DetailAST ast ) { final DetailAST packageNameAST = ast . getLastChild ( ) . getPreviousSibling ( ) ; final FullIdent packageIdent = FullIdent . createFullIdent ( packageNameAST ) ; pkgName = packageIdent . getText ( ) ; } private void processLiteralNew ( DetailAST ast ) { if ( ast . getParent ( ) . getType ( ) == TokenTypes . METHOD_REF ) { return ; } instantiations . add ( ast ) ; } private void postprocessLiteralNew ( DetailAST ast ) { final DetailAST typeNameAST = ast . getFirstChild ( ) ; final AST nameSibling = typeNameAST . getNextSibling ( ) ; if ( nameSibling != null && nameSibling . getType ( ) == TokenTypes . ARRAY_DECLARATOR ) { return ; } final FullIdent typeIdent = FullIdent . createFullIdent ( typeNameAST ) ; final String typeName = typeIdent . getText ( ) ; final int lineNo = ast . getLineNo ( ) ; final int colNo = ast . getColumnNo ( ) ; final String fqClassName = getIllegalInstantiation ( typeName ) ; if ( fqClassName != null ) { log ( lineNo , colNo , MSG_KEY , fqClassName ) ; } } private String getIllegalInstantiation ( String className ) { if ( illegalClasses . contains ( className ) ) { return className ; } final int clsNameLen = className . length ( ) ; final int pkgNameLen = pkgName == null ? 0 : pkgName . length ( ) ; for ( String illegal : illegalClasses ) { final int illegalLen = illegal . length ( ) ; if ( isStandardClass ( className , clsNameLen , illegal , illegalLen ) ) { return illegal ; } if ( isSamePackage ( className , clsNameLen , pkgNameLen , illegal , illegalLen ) ) { return illegal ; } final String importArg = checkImportStatements ( className ) ; if ( importArg != null ) { return importArg ; } } return null ; } private String checkImportStatements ( String className ) { for ( FullIdent importLineText : imports ) { final String importArg = importLineText . getText ( ) ; if ( importArg . endsWith ( ".*" ) ) { final String fqClass = importArg . substring ( 0 , importArg . length ( ) - 1 ) + className ; if ( illegalClasses . contains ( fqClass ) ) { return fqClass ; } } else { if ( Utils . baseClassname ( importArg ) . equals ( className ) && illegalClasses . contains ( importArg ) ) { return importArg ; } } } return null ; } private boolean isSamePackage ( String className , int clsNameLen , int pkgNameLen , String illegal , int illegalLen ) { return pkgName != null && clsNameLen == illegalLen - pkgNameLen - 1 && illegal . charAt ( pkgNameLen ) == '.' && illegal . endsWith ( className ) && illegal . startsWith ( pkgName ) ; } private boolean isStandardClass ( String className , int clsNameLen , String illegal , int illegalLen ) { if ( illegalLen - JAVA_LANG . length ( ) == clsNameLen && illegal . endsWith ( className ) && illegal . startsWith ( JAVA_LANG ) ) { final boolean isSameFile = classNames . contains ( className ) ; final boolean isSamePackage = isSamePackage ( className ) ; if ( ! ( isSameFile || isSamePackage ) ) { return true ; } } return false ; } private boolean isSamePackage ( String className ) { boolean isSamePackage = false ; try { final ClassLoader classLoader = getClassLoader ( ) ; if ( classLoader != null ) { final String fqName = pkgName + "." + className ; classLoader . loadClass ( fqName ) ; isSamePackage = true ; } } catch ( final ClassNotFoundException ex ) { isSamePackage = false ; } return isSamePackage ; } public void setClasses ( String classNames ) { illegalClasses . clear ( ) ; final StringTokenizer tok = new StringTokenizer ( classNames , "," ) ; while ( tok . hasMoreTokens ( ) ) { illegalClasses . add ( tok . nextToken ( ) ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . AbstractParenPadCheck . WS_FOLLOWED ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . AbstractParenPadCheck . WS_PRECEDED ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . AbstractParenPadCheck . WS_NOT_FOLLOWED ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . AbstractParenPadCheck . WS_NOT_PRECEDED ; public class TypecastParenPadCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( TypecastParenPadCheck . class ) ; final String [ ] expected = { "89:14: " + getCheckMessage ( WS_FOLLOWED , "(" ) , "89:21: " + getCheckMessage ( WS_PRECEDED , ")" ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void testSpace ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( TypecastParenPadCheck . class ) ; checkConfig . addAttribute ( "option" , PadOption . SPACE . toString ( ) ) ; final String [ ] expected = { "87:21: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "87:27: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "88:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "88:20: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "90:14: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "90:20: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , "241:18: " + getCheckMessage ( WS_NOT_FOLLOWED , "(" ) , "241:21: " + getCheckMessage ( WS_NOT_PRECEDED , ")" ) , } ; verify ( checkConfig , getPath ( "InputWhitespace.java" ) , expected ) ; } @ Test public void test1322879 ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( TypecastParenPadCheck . class ) ; checkConfig . addAttribute ( "option" , PadOption . SPACE . toString ( ) ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "whitespace/InputWhitespaceAround.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; public final class ModifiedControlVariableCheck extends Check { public static final String MSG_KEY = "modified.control.variable" ; private static final String ILLEGAL_TYPE_OF_TOKEN = "Illegal type of token: " ; private static final Set < Integer > MUTATION_OPERATIONS = Sets . newHashSet ( TokenTypes . POST_INC , TokenTypes . POST_DEC , TokenTypes . DEC , TokenTypes . INC , TokenTypes . ASSIGN ) ; private final Deque < Deque < String > > variableStack = new ArrayDeque < > ( ) ; private boolean skipEnhancedForLoopVariable ; public void setSkipEnhancedForLoopVariable ( boolean skipEnhancedForLoopVariable ) { this . skipEnhancedForLoopVariable = skipEnhancedForLoopVariable ; } @ Override public int [ ] getDefaultTokens ( ) { return getAcceptableTokens ( ) ; } @ Override public int [ ] getRequiredTokens ( ) { return getAcceptableTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . OBJBLOCK , TokenTypes . LITERAL_FOR , TokenTypes . FOR_ITERATOR , TokenTypes . FOR_EACH_CLAUSE , TokenTypes . ASSIGN , TokenTypes . PLUS_ASSIGN , TokenTypes . MINUS_ASSIGN , TokenTypes . STAR_ASSIGN , TokenTypes . DIV_ASSIGN , TokenTypes . MOD_ASSIGN , TokenTypes . SR_ASSIGN , TokenTypes . BSR_ASSIGN , TokenTypes . SL_ASSIGN , TokenTypes . BAND_ASSIGN , TokenTypes . BXOR_ASSIGN , TokenTypes . BOR_ASSIGN , TokenTypes . INC , TokenTypes . POST_INC , TokenTypes . DEC , TokenTypes . POST_DEC , } ; } @ Override public void beginTree ( DetailAST rootAST ) { variableStack . clear ( ) ; variableStack . push ( new ArrayDeque < String > ( ) ) ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . OBJBLOCK : enterBlock ( ) ; break ; case TokenTypes . LITERAL_FOR : case TokenTypes . FOR_ITERATOR : case TokenTypes . FOR_EACH_CLAUSE : break ; case TokenTypes . ASSIGN : case TokenTypes . PLUS_ASSIGN : case TokenTypes . MINUS_ASSIGN : case TokenTypes . STAR_ASSIGN : case TokenTypes . DIV_ASSIGN : case TokenTypes . MOD_ASSIGN : case TokenTypes . SR_ASSIGN : case TokenTypes . BSR_ASSIGN : case TokenTypes . SL_ASSIGN : case TokenTypes . BAND_ASSIGN : case TokenTypes . BXOR_ASSIGN : case TokenTypes . BOR_ASSIGN : case TokenTypes . INC : case TokenTypes . POST_INC : case TokenTypes . DEC : case TokenTypes . POST_DEC : checkIdent ( ast ) ; break ; default : throw new IllegalStateException ( ILLEGAL_TYPE_OF_TOKEN + ast . toString ( ) ) ; } } @ Override public void leaveToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . FOR_ITERATOR : leaveForIter ( ast . getParent ( ) ) ; break ; case TokenTypes . FOR_EACH_CLAUSE : final DetailAST paramDef = ast . findFirstToken ( TokenTypes . VARIABLE_DEF ) ; if ( shouldCheckEnhancedForLoopVariable ( paramDef ) ) { leaveForEach ( paramDef ) ; } break ; case TokenTypes . LITERAL_FOR : if ( ! getCurrentVariables ( ) . isEmpty ( ) ) { leaveForDef ( ast ) ; } break ; case TokenTypes . OBJBLOCK : exitBlock ( ) ; break ; case TokenTypes . ASSIGN : case TokenTypes . PLUS_ASSIGN : case TokenTypes . MINUS_ASSIGN : case TokenTypes . STAR_ASSIGN : case TokenTypes . DIV_ASSIGN : case TokenTypes . MOD_ASSIGN : case TokenTypes . SR_ASSIGN : case TokenTypes . BSR_ASSIGN : case TokenTypes . SL_ASSIGN : case TokenTypes . BAND_ASSIGN : case TokenTypes . BXOR_ASSIGN : case TokenTypes . BOR_ASSIGN : case TokenTypes . INC : case TokenTypes . POST_INC : case TokenTypes . DEC : case TokenTypes . POST_DEC : break ; default : throw new IllegalStateException ( ILLEGAL_TYPE_OF_TOKEN + ast . toString ( ) ) ; } } private void enterBlock ( ) { variableStack . push ( new ArrayDeque < String > ( ) ) ; } private void exitBlock ( ) { variableStack . pop ( ) ; } private Deque < String > getCurrentVariables ( ) { return variableStack . peek ( ) ; } private void checkIdent ( DetailAST ast ) { if ( ! getCurrentVariables ( ) . isEmpty ( ) ) { final DetailAST identAST = ast . getFirstChild ( ) ; if ( identAST != null && identAST . getType ( ) == TokenTypes . IDENT && getCurrentVariables ( ) . contains ( identAST . getText ( ) ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY , identAST . getText ( ) ) ; } } } private void leaveForIter ( DetailAST ast ) { final Set < String > variablesToPutInScope = getVariablesManagedByForLoop ( ast ) ; for ( String variableName : variablesToPutInScope ) { getCurrentVariables ( ) . push ( variableName ) ; } } private Set < String > getVariablesManagedByForLoop ( DetailAST ast ) { final Set < String > initializedVariables = getForInitVariables ( ast ) ; final Set < String > iteratingVariables = getForIteratorVariables ( ast ) ; return Sets . intersection ( initializedVariables , iteratingVariables ) ; } private boolean shouldCheckEnhancedForLoopVariable ( DetailAST ast ) { return ! skipEnhancedForLoopVariable || ast . getParent ( ) . getType ( ) != TokenTypes . FOR_EACH_CLAUSE ; } private void leaveForEach ( DetailAST paramDef ) { final DetailAST paramName = paramDef . findFirstToken ( TokenTypes . IDENT ) ; getCurrentVariables ( ) . push ( paramName . getText ( ) ) ; } private void leaveForDef ( DetailAST ast ) { final DetailAST forInitAST = ast . findFirstToken ( TokenTypes . FOR_INIT ) ; if ( forInitAST != null ) { final Set < String > variablesManagedByForLoop = getVariablesManagedByForLoop ( ast ) ; popCurrentVariables ( variablesManagedByForLoop . size ( ) ) ; } else { getCurrentVariables ( ) . pop ( ) ; } } private void popCurrentVariables ( int count ) { for ( int i = 0 ; i < count ; i ++ ) { getCurrentVariables ( ) . pop ( ) ; } } private static Set < String > getForInitVariables ( DetailAST ast ) { final Set < String > initializedVariables = new HashSet < > ( ) ; final DetailAST forInitAST = ast . findFirstToken ( TokenTypes . FOR_INIT ) ; for ( DetailAST parameterDefAST = forInitAST . findFirstToken ( TokenTypes . VARIABLE_DEF ) ; parameterDefAST != null ; parameterDefAST = parameterDefAST . getNextSibling ( ) ) { if ( parameterDefAST . getType ( ) == TokenTypes . VARIABLE_DEF ) { final DetailAST param = parameterDefAST . findFirstToken ( TokenTypes . IDENT ) ; initializedVariables . add ( param . getText ( ) ) ; } } return initializedVariables ; } private static Set < String > getForIteratorVariables ( DetailAST ast ) { final Set < String > iteratorVariables = new HashSet < > ( ) ; final DetailAST forIteratorAST = ast . findFirstToken ( TokenTypes . FOR_ITERATOR ) ; final DetailAST forUpdateListAST = forIteratorAST . findFirstToken ( TokenTypes . ELIST ) ; for ( DetailAST iteratingExpressionAST : findChildrenOfExpressionType ( forUpdateListAST ) ) { if ( MUTATION_OPERATIONS . contains ( iteratingExpressionAST . getType ( ) ) ) { final DetailAST oneVariableOperatorChild = iteratingExpressionAST . getFirstChild ( ) ; if ( oneVariableOperatorChild . getType ( ) == TokenTypes . IDENT ) { iteratorVariables . add ( oneVariableOperatorChild . getText ( ) ) ; } } } return iteratorVariables ; } private static List < DetailAST > findChildrenOfExpressionType ( DetailAST ast ) { final List < DetailAST > foundExpressions = new LinkedList < > ( ) ; if ( ast != null ) { for ( DetailAST iteratingExpressionAST = ast . findFirstToken ( TokenTypes . EXPR ) ; iteratingExpressionAST != null ; iteratingExpressionAST = iteratingExpressionAST . getNextSibling ( ) ) { if ( iteratingExpressionAST . getType ( ) == TokenTypes . EXPR ) { foundExpressions . add ( iteratingExpressionAST . getFirstChild ( ) ) ; } } } return foundExpressions ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public abstract class AbstractIllegalMethodCheck extends Check { private final String methodName ; private final String errorKey ; public AbstractIllegalMethodCheck ( String methodName , String errorKey ) { this . methodName = methodName ; this . errorKey = errorKey ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF } ; } @ Override public void visitToken ( DetailAST aAST ) { final DetailAST mid = aAST . findFirstToken ( TokenTypes . IDENT ) ; final String name = mid . getText ( ) ; if ( methodName . equals ( name ) ) { final DetailAST params = aAST . findFirstToken ( TokenTypes . PARAMETERS ) ; final boolean hasEmptyParamList = ! params . branchContains ( TokenTypes . PARAMETER_DEF ) ; if ( hasEmptyParamList ) { log ( aAST . getLineNo ( ) , errorKey ) ; } } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . DescendantTokenCheck ; public class MissingCtorCheck extends DescendantTokenCheck { public static final String MSG_KEY = "missing.ctor" ; public MissingCtorCheck ( ) { setLimitedTokens ( Utils . getTokenName ( TokenTypes . CTOR_DEF ) ) ; setMinimumNumber ( 1 ) ; setMaximumDepth ( 2 ) ; setMinimumMessage ( MSG_KEY ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return getDefaultTokens ( ) ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( modifiers != null && modifiers . branchContains ( TokenTypes . ABSTRACT ) ) { return ; } super . visitToken ( ast ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class UnnecessaryParenthesesCheck extends Check { public static final String MSG_IDENT = "unnecessary.paren.ident" ; public static final String MSG_ASSIGN = "unnecessary.paren.assign" ; public static final String MSG_EXPR = "unnecessary.paren.expr" ; public static final String MSG_LITERAL = "unnecessary.paren.literal" ; public static final String MSG_STRING = "unnecessary.paren.string" ; public static final String MSG_RETURN = "unnecessary.paren.return" ; private static final int MAX_QUOTED_LENGTH = 25 ; private static final int [ ] LITERALS = { TokenTypes . NUM_DOUBLE , TokenTypes . NUM_FLOAT , TokenTypes . NUM_INT , TokenTypes . NUM_LONG , TokenTypes . STRING_LITERAL , TokenTypes . LITERAL_NULL , TokenTypes . LITERAL_FALSE , TokenTypes . LITERAL_TRUE , } ; private static final int [ ] ASSIGNMENTS = { TokenTypes . ASSIGN , TokenTypes . BAND_ASSIGN , TokenTypes . BOR_ASSIGN , TokenTypes . BSR_ASSIGN , TokenTypes . BXOR_ASSIGN , TokenTypes . DIV_ASSIGN , TokenTypes . MINUS_ASSIGN , TokenTypes . MOD_ASSIGN , TokenTypes . PLUS_ASSIGN , TokenTypes . SL_ASSIGN , TokenTypes . SR_ASSIGN , TokenTypes . STAR_ASSIGN , } ; private DetailAST parentToSkip ; private int assignDepth ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . EXPR , TokenTypes . IDENT , TokenTypes . NUM_DOUBLE , TokenTypes . NUM_FLOAT , TokenTypes . NUM_INT , TokenTypes . NUM_LONG , TokenTypes . STRING_LITERAL , TokenTypes . LITERAL_NULL , TokenTypes . LITERAL_FALSE , TokenTypes . LITERAL_TRUE , TokenTypes . ASSIGN , TokenTypes . BAND_ASSIGN , TokenTypes . BOR_ASSIGN , TokenTypes . BSR_ASSIGN , TokenTypes . BXOR_ASSIGN , TokenTypes . DIV_ASSIGN , TokenTypes . MINUS_ASSIGN , TokenTypes . MOD_ASSIGN , TokenTypes . PLUS_ASSIGN , TokenTypes . SL_ASSIGN , TokenTypes . SR_ASSIGN , TokenTypes . STAR_ASSIGN , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . EXPR , TokenTypes . IDENT , TokenTypes . NUM_DOUBLE , TokenTypes . NUM_FLOAT , TokenTypes . NUM_INT , TokenTypes . NUM_LONG , TokenTypes . STRING_LITERAL , TokenTypes . LITERAL_NULL , TokenTypes . LITERAL_FALSE , TokenTypes . LITERAL_TRUE , TokenTypes . ASSIGN , TokenTypes . BAND_ASSIGN , TokenTypes . BOR_ASSIGN , TokenTypes . BSR_ASSIGN , TokenTypes . BXOR_ASSIGN , TokenTypes . DIV_ASSIGN , TokenTypes . MINUS_ASSIGN , TokenTypes . MOD_ASSIGN , TokenTypes . PLUS_ASSIGN , TokenTypes . SL_ASSIGN , TokenTypes . SR_ASSIGN , TokenTypes . STAR_ASSIGN , } ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { } ; } @ Override public void visitToken ( DetailAST ast ) { final int type = ast . getType ( ) ; final DetailAST parent = ast . getParent ( ) ; if ( type == TokenTypes . ASSIGN && parent . getType ( ) == TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR ) { return ; } final boolean surrounded = isSurrounded ( ast ) ; if ( surrounded && type == TokenTypes . IDENT ) { parentToSkip = ast . getParent ( ) ; log ( ast , MSG_IDENT , ast . getText ( ) ) ; return ; } if ( surrounded && inTokenList ( type , LITERALS ) ) { parentToSkip = ast . getParent ( ) ; if ( type == TokenTypes . STRING_LITERAL ) { log ( ast , MSG_STRING , chopString ( ast . getText ( ) ) ) ; } else { log ( ast , MSG_LITERAL , ast . getText ( ) ) ; } return ; } if ( inTokenList ( type , ASSIGNMENTS ) ) { assignDepth ++ ; final DetailAST last = ast . getLastChild ( ) ; if ( last . getType ( ) == TokenTypes . RPAREN ) { log ( ast , MSG_ASSIGN ) ; } } } @ Override public void leaveToken ( DetailAST ast ) { final int type = ast . getType ( ) ; final DetailAST parent = ast . getParent ( ) ; if ( type == TokenTypes . ASSIGN && parent . getType ( ) == TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR ) { return ; } if ( type == TokenTypes . EXPR ) { if ( parentToSkip != ast && isExprSurrounded ( ast ) ) { if ( assignDepth >= 1 ) { log ( ast , MSG_ASSIGN ) ; } else if ( ast . getParent ( ) . getType ( ) == TokenTypes . LITERAL_RETURN ) { log ( ast , MSG_RETURN ) ; } else { log ( ast , MSG_EXPR ) ; } } parentToSkip = null ; } else if ( inTokenList ( type , ASSIGNMENTS ) ) { assignDepth -- ; } super . leaveToken ( ast ) ; } private boolean isSurrounded ( DetailAST ast ) { final DetailAST prev = ast . getPreviousSibling ( ) ; return prev != null && prev . getType ( ) == TokenTypes . LPAREN ; } private boolean isExprSurrounded ( DetailAST ast ) { return ast . getFirstChild ( ) . getType ( ) == TokenTypes . LPAREN ; } private boolean inTokenList ( int type , int ... tokens ) { boolean found = false ; for ( int i = 0 ; i < tokens . length && ! found ; i ++ ) { found = tokens [ i ] == type ; } return found ; } private String chopString ( String string ) { if ( string . length ( ) > MAX_QUOTED_LENGTH ) { return string . substring ( 0 , MAX_QUOTED_LENGTH ) + "...\"" ; } return string ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import antlr . collections . AST ; public class StringLiteralEqualityCheck extends Check { public static final String MSG_KEY = "string.literal.equality" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . EQUAL , TokenTypes . NOT_EQUAL } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . EQUAL , TokenTypes . NOT_EQUAL } ; } @ Override public void visitToken ( DetailAST ast ) { final AST firstChild = ast . getFirstChild ( ) ; final AST secondChild = firstChild . getNextSibling ( ) ; if ( firstChild . getType ( ) == TokenTypes . STRING_LITERAL || secondChild . getType ( ) == TokenTypes . STRING_LITERAL ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY , ast . getText ( ) ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import antlr . collections . AST ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class SimplifyBooleanReturnCheck extends Check { public static final String MSG_KEY = "simplify.boolreturn" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_IF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . LITERAL_IF } ; } @ Override public void visitToken ( DetailAST ast ) { final AST elseLiteral = ast . findFirstToken ( TokenTypes . LITERAL_ELSE ) ; if ( elseLiteral == null ) { return ; } final AST elseStatement = elseLiteral . getFirstChild ( ) ; final AST condition = ast . getFirstChild ( ) . getNextSibling ( ) ; final AST thenStatement = condition . getNextSibling ( ) . getNextSibling ( ) ; if ( returnsOnlyBooleanLiteral ( thenStatement ) && returnsOnlyBooleanLiteral ( elseStatement ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY ) ; } } private static boolean returnsOnlyBooleanLiteral ( AST ast ) { if ( isBooleanLiteralReturnStatement ( ast ) ) { return true ; } final AST firstStmnt = ast . getFirstChild ( ) ; return isBooleanLiteralReturnStatement ( firstStmnt ) ; } private static boolean isBooleanLiteralReturnStatement ( AST ast ) { if ( ast == null || ast . getType ( ) != TokenTypes . LITERAL_RETURN ) { return false ; } final AST expr = ast . getFirstChild ( ) ; if ( expr == null || expr . getType ( ) == TokenTypes . SEMI ) { return false ; } final AST value = expr . getFirstChild ( ) ; return isBooleanLiteralType ( value . getType ( ) ) ; } private static boolean isBooleanLiteralType ( final int tokenType ) { final boolean iastrue = tokenType == TokenTypes . LITERAL_TRUE ; final boolean isFalse = tokenType == TokenTypes . LITERAL_FALSE ; return iastrue || isFalse ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; public class NoCloneCheck extends AbstractIllegalMethodCheck { public static final String MSG_KEY = "avoid.clone.method" ; public NoCloneCheck ( ) { super ( "clone" , MSG_KEY ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; public class SuperFinalizeCheck extends AbstractSuperCheck { @ Override protected String getMethodName ( ) { return "finalize" ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . checks . AbstractFormatCheck ; import java . util . Set ; import java . util . regex . Pattern ; public class IllegalTokenTextCheck extends AbstractFormatCheck { public static final String MSG_KEY = "illegal.token.text" ; private String message = "" ; public IllegalTokenTextCheck ( ) { super ( "$^" ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ 0 ] ; } @ Override public int [ ] getAcceptableTokens ( ) { final Set < String > tokenNames = getTokenNames ( ) ; final int [ ] result = new int [ tokenNames . size ( ) ] ; int i = 0 ; for ( final String name : tokenNames ) { result [ i ] = Utils . getTokenId ( name ) ; i ++ ; } return result ; } @ Override public void visitToken ( DetailAST ast ) { final String text = ast . getText ( ) ; if ( getRegexp ( ) . matcher ( text ) . find ( ) ) { String message = getMessage ( ) ; if ( "" . equals ( message ) ) { message = MSG_KEY ; } log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , message , getFormat ( ) ) ; } } public void setMessage ( String message ) { this . message = null == message ? "" : message ; } public String getMessage ( ) { return message ; } public void setIgnoreCase ( boolean caseInsensitive ) { if ( caseInsensitive ) { setCompileFlags ( Pattern . CASE_INSENSITIVE ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . Set ; public class IllegalTokenCheck extends Check { public static final String MSG_KEY = "illegal.token" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LABELED_STAT , } ; } @ Override public int [ ] getAcceptableTokens ( ) { int [ ] tokensToCopy = getDefaultTokens ( ) ; final Set < String > tokenNames = getTokenNames ( ) ; if ( ! tokenNames . isEmpty ( ) ) { tokensToCopy = new int [ tokenNames . size ( ) ] ; int i = 0 ; for ( String name : tokenNames ) { tokensToCopy [ i ] = Utils . getTokenId ( name ) ; i ++ ; } } final int [ ] copy = new int [ tokensToCopy . length ] ; System . arraycopy ( tokensToCopy , 0 , copy , 0 , tokensToCopy . length ) ; return copy ; } @ Override public void visitToken ( DetailAST ast ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY , convertToString ( ast ) ) ; } private String convertToString ( DetailAST ast ) { final String tokenText ; if ( ast . getType ( ) == TokenTypes . LABELED_STAT ) { tokenText = ast . getFirstChild ( ) . getText ( ) + ast . getText ( ) ; } else { tokenText = ast . getText ( ) ; } return tokenText ; } }
package com . puppycrawl . tools . checkstyle . checks . whitespace ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import java . io . File ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . FileTabCharacterCheck . CONTAINS_TAB ; import static com . puppycrawl . tools . checkstyle . checks . whitespace . FileTabCharacterCheck . FILE_CONTAINS_TAB ; public class FileTabCharacterCheckTest extends BaseCheckTestSupport { @ Override protected DefaultConfiguration createCheckerConfig ( Configuration checkConfig ) { final DefaultConfiguration dc = new DefaultConfiguration ( "root" ) ; dc . addChild ( checkConfig ) ; return dc ; } @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createConfig ( false ) ; final String [ ] expected = { "19:25: " + getCheckMessage ( FILE_CONTAINS_TAB ) , } ; final File [ ] files = { new File ( getPath ( "InputSimple.java" ) ) , } ; verify ( createChecker ( checkConfig ) , files , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testVerbose ( ) throws Exception { final DefaultConfiguration checkConfig = createConfig ( true ) ; final String [ ] expected = { "19:25: " + getCheckMessage ( CONTAINS_TAB ) , "145:35: " + getCheckMessage ( CONTAINS_TAB ) , "146:64: " + getCheckMessage ( CONTAINS_TAB ) , "154:9: " + getCheckMessage ( CONTAINS_TAB ) , "155:10: " + getCheckMessage ( CONTAINS_TAB ) , "156:1: " + getCheckMessage ( CONTAINS_TAB ) , "157:3: " + getCheckMessage ( CONTAINS_TAB ) , "158:3: " + getCheckMessage ( CONTAINS_TAB ) , } ; final File [ ] files = { new File ( getPath ( "InputSimple.java" ) ) , } ; verify ( createChecker ( checkConfig ) , files , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testBadFile ( ) throws Exception { final DefaultConfiguration checkConfig = createConfig ( false ) ; final String path = getPath ( "Claira" ) ; final String [ ] expected = { "0: File not found!" , } ; final File [ ] files = { new File ( path ) , } ; verify ( createChecker ( checkConfig ) , files , path , expected ) ; } private DefaultConfiguration createConfig ( boolean verbose ) { final DefaultConfiguration checkConfig = createCheckConfig ( FileTabCharacterCheck . class ) ; checkConfig . addAttribute ( "eachLine" , Boolean . toString ( verbose ) ) ; return checkConfig ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; public class NoFinalizerCheck extends AbstractIllegalMethodCheck { public static final String MSG_KEY = "avoid.finalizer.method" ; public NoFinalizerCheck ( ) { super ( "finalize" , MSG_KEY ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . CheckUtils ; public class ExplicitInitializationCheck extends Check { public static final String MSG_KEY = "explicit.init" ; @ Override public final int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF } ; } @ Override public final int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public final int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF } ; } @ Override public void visitToken ( DetailAST ast ) { if ( isSkipCase ( ast ) ) { return ; } final DetailAST ident = ast . findFirstToken ( TokenTypes . IDENT ) ; final DetailAST assign = ast . findFirstToken ( TokenTypes . ASSIGN ) ; final DetailAST exprStart = assign . getFirstChild ( ) . getFirstChild ( ) ; final DetailAST type = ast . findFirstToken ( TokenTypes . TYPE ) ; if ( isObjectType ( type ) && exprStart . getType ( ) == TokenTypes . LITERAL_NULL ) { log ( ident , MSG_KEY , ident . getText ( ) , "null" ) ; } final int primitiveType = type . getFirstChild ( ) . getType ( ) ; if ( primitiveType == TokenTypes . LITERAL_BOOLEAN && exprStart . getType ( ) == TokenTypes . LITERAL_FALSE ) { log ( ident , MSG_KEY , ident . getText ( ) , "false" ) ; } if ( isNumericType ( primitiveType ) && isZero ( exprStart ) ) { log ( ident , MSG_KEY , ident . getText ( ) , "0" ) ; } if ( primitiveType == TokenTypes . LITERAL_CHAR && isZeroChar ( exprStart ) ) { log ( ident , MSG_KEY , ident . getText ( ) , "\\0" ) ; } } private boolean isZeroChar ( DetailAST exprStart ) { return isZero ( exprStart ) || exprStart . getType ( ) == TokenTypes . CHAR_LITERAL && "'\\0'" . equals ( exprStart . getText ( ) ) ; } private boolean isSkipCase ( DetailAST ast ) { if ( ScopeUtils . isLocalVariableDef ( ast ) || ScopeUtils . inInterfaceOrAnnotationBlock ( ast ) ) { return true ; } final DetailAST assign = ast . findFirstToken ( TokenTypes . ASSIGN ) ; if ( assign == null ) { return true ; } final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; return modifiers != null && modifiers . branchContains ( TokenTypes . FINAL ) ; } private boolean isObjectType ( DetailAST type ) { final int objectType = type . getFirstChild ( ) . getType ( ) ; return objectType == TokenTypes . IDENT || objectType == TokenTypes . DOT || objectType == TokenTypes . ARRAY_DECLARATOR ; } private boolean isNumericType ( int type ) { return type == TokenTypes . LITERAL_BYTE || type == TokenTypes . LITERAL_SHORT || type == TokenTypes . LITERAL_INT || type == TokenTypes . LITERAL_FLOAT || type == TokenTypes . LITERAL_LONG || type == TokenTypes . LITERAL_DOUBLE ; } private boolean isZero ( DetailAST expr ) { final int type = expr . getType ( ) ; switch ( type ) { case TokenTypes . NUM_FLOAT : case TokenTypes . NUM_DOUBLE : case TokenTypes . NUM_INT : case TokenTypes . NUM_LONG : final String text = expr . getText ( ) ; return 0 == CheckUtils . parseFloat ( text , type ) ; default : return false ; } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . CheckUtils ; import java . util . Set ; public class CovariantEqualsCheck extends Check { public static final String MSG_KEY = "covariant.equals" ; private final Set < DetailAST > equalsMethods = Sets . newHashSet ( ) ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . LITERAL_NEW , TokenTypes . ENUM_DEF , } ; } @ Override public int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . LITERAL_NEW , TokenTypes . ENUM_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { equalsMethods . clear ( ) ; boolean hasEqualsObject = false ; final DetailAST objBlock = ast . findFirstToken ( TokenTypes . OBJBLOCK ) ; if ( objBlock != null ) { DetailAST child = objBlock . getFirstChild ( ) ; while ( child != null ) { if ( child . getType ( ) == TokenTypes . METHOD_DEF && CheckUtils . isEqualsMethod ( child ) ) { if ( hasObjectParameter ( child ) ) { hasEqualsObject = true ; } else { equalsMethods . add ( child ) ; } } child = child . getNextSibling ( ) ; } if ( ! hasEqualsObject ) { for ( DetailAST equalsAST : equalsMethods ) { final DetailAST nameNode = equalsAST . findFirstToken ( TokenTypes . IDENT ) ; log ( nameNode . getLineNo ( ) , nameNode . getColumnNo ( ) , MSG_KEY ) ; } } } } private boolean hasObjectParameter ( DetailAST ast ) { final DetailAST paramsNode = ast . findFirstToken ( TokenTypes . PARAMETERS ) ; if ( paramsNode . getChildCount ( ) != 1 ) { return false ; } final DetailAST paramNode = paramsNode . findFirstToken ( TokenTypes . PARAMETER_DEF ) ; final DetailAST typeNode = paramNode . findFirstToken ( TokenTypes . TYPE ) ; final FullIdent fullIdent = FullIdent . createFullIdentBelow ( typeNode ) ; final String name = fullIdent . getText ( ) ; return "Object" . equals ( name ) || "java.lang.Object" . equals ( name ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . DescendantTokenCheck ; public class MissingSwitchDefaultCheck extends DescendantTokenCheck { public static final String MSG_KEY = "missing.switch.default" ; public MissingSwitchDefaultCheck ( ) { setLimitedTokens ( Utils . getTokenName ( TokenTypes . LITERAL_DEFAULT ) ) ; setMinimumNumber ( 1 ) ; setMaximumDepth ( 2 ) ; setMinimumMessage ( MSG_KEY ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_SWITCH } ; } @ Override public int [ ] getAcceptableTokens ( ) { return getDefaultTokens ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import java . util . LinkedList ; import java . util . List ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public final class IllegalCatchCheck extends AbstractIllegalCheck { public static final String MSG_KEY = "illegal.catch" ; public IllegalCatchCheck ( ) { super ( "Exception" , "Error" , "RuntimeException" , "Throwable" , "java.lang.Error" , "java.lang.Exception" , "java.lang.RuntimeException" , "java.lang.Throwable" ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_CATCH } ; } @ Override public int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . LITERAL_CATCH } ; } @ Override public void visitToken ( DetailAST detailAST ) { final DetailAST paradef = detailAST . findFirstToken ( TokenTypes . PARAMETER_DEF ) ; final DetailAST excTypeParent = paradef . findFirstToken ( TokenTypes . TYPE ) ; final List < DetailAST > excTypes = getAllExceptionTypes ( excTypeParent ) ; for ( DetailAST excType : excTypes ) { final FullIdent ident = FullIdent . createFullIdent ( excType ) ; if ( isIllegalClassName ( ident . getText ( ) ) ) { log ( detailAST , MSG_KEY , ident . getText ( ) ) ; } } } public List < DetailAST > getAllExceptionTypes ( DetailAST parentToken ) { DetailAST currentNode = parentToken . getFirstChild ( ) ; final List < DetailAST > exceptionTypes = new LinkedList < > ( ) ; if ( currentNode . getType ( ) == TokenTypes . BOR ) { exceptionTypes . addAll ( getAllExceptionTypes ( currentNode ) ) ; currentNode = currentNode . getNextSibling ( ) ; if ( currentNode != null ) { exceptionTypes . add ( currentNode ) ; } } else { exceptionTypes . add ( currentNode ) ; currentNode = currentNode . getNextSibling ( ) ; while ( currentNode != null ) { exceptionTypes . add ( currentNode ) ; currentNode = currentNode . getNextSibling ( ) ; } } return exceptionTypes ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . ArrayDeque ; import java . util . Collections ; import java . util . Deque ; import java . util . Set ; public final class ParameterAssignmentCheck extends Check { public static final String MSG_KEY = "parameter.assignment" ; private final Deque < Set < String > > parameterNamesStack = new ArrayDeque < > ( ) ; private Set < String > parameterNames ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . ASSIGN , TokenTypes . PLUS_ASSIGN , TokenTypes . MINUS_ASSIGN , TokenTypes . STAR_ASSIGN , TokenTypes . DIV_ASSIGN , TokenTypes . MOD_ASSIGN , TokenTypes . SR_ASSIGN , TokenTypes . BSR_ASSIGN , TokenTypes . SL_ASSIGN , TokenTypes . BAND_ASSIGN , TokenTypes . BXOR_ASSIGN , TokenTypes . BOR_ASSIGN , TokenTypes . INC , TokenTypes . POST_INC , TokenTypes . DEC , TokenTypes . POST_DEC , } ; } @ Override public int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . ASSIGN , TokenTypes . PLUS_ASSIGN , TokenTypes . MINUS_ASSIGN , TokenTypes . STAR_ASSIGN , TokenTypes . DIV_ASSIGN , TokenTypes . MOD_ASSIGN , TokenTypes . SR_ASSIGN , TokenTypes . BSR_ASSIGN , TokenTypes . SL_ASSIGN , TokenTypes . BAND_ASSIGN , TokenTypes . BXOR_ASSIGN , TokenTypes . BOR_ASSIGN , TokenTypes . INC , TokenTypes . POST_INC , TokenTypes . DEC , TokenTypes . POST_DEC , } ; } @ Override public void beginTree ( DetailAST rootAST ) { parameterNamesStack . clear ( ) ; parameterNames = Collections . emptySet ( ) ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CTOR_DEF : case TokenTypes . METHOD_DEF : visitMethodDef ( ast ) ; break ; case TokenTypes . ASSIGN : case TokenTypes . PLUS_ASSIGN : case TokenTypes . MINUS_ASSIGN : case TokenTypes . STAR_ASSIGN : case TokenTypes . DIV_ASSIGN : case TokenTypes . MOD_ASSIGN : case TokenTypes . SR_ASSIGN : case TokenTypes . BSR_ASSIGN : case TokenTypes . SL_ASSIGN : case TokenTypes . BAND_ASSIGN : case TokenTypes . BXOR_ASSIGN : case TokenTypes . BOR_ASSIGN : visitAssign ( ast ) ; break ; case TokenTypes . INC : case TokenTypes . POST_INC : case TokenTypes . DEC : case TokenTypes . POST_DEC : visitIncDec ( ast ) ; break ; default : throw new IllegalStateException ( ast . toString ( ) ) ; } } @ Override public void leaveToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CTOR_DEF : case TokenTypes . METHOD_DEF : leaveMethodDef ( ) ; break ; case TokenTypes . ASSIGN : case TokenTypes . PLUS_ASSIGN : case TokenTypes . MINUS_ASSIGN : case TokenTypes . STAR_ASSIGN : case TokenTypes . DIV_ASSIGN : case TokenTypes . MOD_ASSIGN : case TokenTypes . SR_ASSIGN : case TokenTypes . BSR_ASSIGN : case TokenTypes . SL_ASSIGN : case TokenTypes . BAND_ASSIGN : case TokenTypes . BXOR_ASSIGN : case TokenTypes . BOR_ASSIGN : case TokenTypes . INC : case TokenTypes . POST_INC : case TokenTypes . DEC : case TokenTypes . POST_DEC : break ; default : throw new IllegalStateException ( ast . toString ( ) ) ; } } private void visitAssign ( DetailAST ast ) { checkIdent ( ast ) ; } private void visitIncDec ( DetailAST ast ) { checkIdent ( ast ) ; } private void checkIdent ( DetailAST ast ) { if ( parameterNames != null && ! parameterNames . isEmpty ( ) ) { final DetailAST identAST = ast . getFirstChild ( ) ; if ( identAST != null && identAST . getType ( ) == TokenTypes . IDENT && parameterNames . contains ( identAST . getText ( ) ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY , identAST . getText ( ) ) ; } } } private void visitMethodDef ( DetailAST ast ) { parameterNamesStack . push ( parameterNames ) ; parameterNames = Sets . newHashSet ( ) ; visitMethodParameters ( ast . findFirstToken ( TokenTypes . PARAMETERS ) ) ; } private void leaveMethodDef ( ) { parameterNames = parameterNamesStack . pop ( ) ; } private void visitMethodParameters ( DetailAST ast ) { DetailAST parameterDefAST = ast . findFirstToken ( TokenTypes . PARAMETER_DEF ) ; for ( ; parameterDefAST != null ; parameterDefAST = parameterDefAST . getNextSibling ( ) ) { if ( parameterDefAST . getType ( ) == TokenTypes . PARAMETER_DEF ) { final DetailAST param = parameterDefAST . findFirstToken ( TokenTypes . IDENT ) ; parameterNames . add ( param . getText ( ) ) ; } } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import java . util . Arrays ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . CheckUtils ; public class MagicNumberCheck extends Check { public static final String MSG_KEY = "magic.number" ; private static final int [ ] ALLOWED_PATH_TOKENTYPES = { TokenTypes . ASSIGN , TokenTypes . ARRAY_INIT , TokenTypes . EXPR , TokenTypes . UNARY_PLUS , TokenTypes . UNARY_MINUS , TokenTypes . TYPECAST , TokenTypes . ELIST , TokenTypes . LITERAL_NEW , TokenTypes . METHOD_CALL , TokenTypes . STAR , TokenTypes . DIV , TokenTypes . PLUS , TokenTypes . MINUS , } ; static { Arrays . sort ( ALLOWED_PATH_TOKENTYPES ) ; } private double [ ] ignoreNumbers = { - 1 , 0 , 1 , 2 } ; private boolean ignoreHashCodeMethod ; private boolean ignoreAnnotation ; private boolean ignoreFieldDeclaration ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . NUM_DOUBLE , TokenTypes . NUM_FLOAT , TokenTypes . NUM_INT , TokenTypes . NUM_LONG , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . NUM_DOUBLE , TokenTypes . NUM_FLOAT , TokenTypes . NUM_INT , TokenTypes . NUM_LONG , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( ignoreAnnotation && isChildOf ( ast , TokenTypes . ANNOTATION ) ) { return ; } if ( inIgnoreList ( ast ) || ignoreHashCodeMethod && isInHashCodeMethod ( ast ) ) { return ; } final DetailAST constantDefAST = findContainingConstantDef ( ast ) ; if ( constantDefAST == null ) { if ( ! ( ignoreFieldDeclaration && isFieldDeclaration ( ast ) ) ) { reportMagicNumber ( ast ) ; } } else { final boolean found = isMagicNumberExists ( ast , constantDefAST ) ; if ( found ) { reportMagicNumber ( ast ) ; } } } private boolean isMagicNumberExists ( DetailAST ast , DetailAST constantDefAST ) { boolean found = false ; DetailAST astNode = ast . getParent ( ) ; while ( astNode != constantDefAST ) { final int type = astNode . getType ( ) ; if ( Arrays . binarySearch ( ALLOWED_PATH_TOKENTYPES , type ) < 0 ) { found = true ; break ; } astNode = astNode . getParent ( ) ; } return found ; } private DetailAST findContainingConstantDef ( DetailAST ast ) { DetailAST varDefAST = ast ; while ( varDefAST != null && varDefAST . getType ( ) != TokenTypes . VARIABLE_DEF && varDefAST . getType ( ) != TokenTypes . ENUM_CONSTANT_DEF ) { varDefAST = varDefAST . getParent ( ) ; } if ( varDefAST == null ) { return null ; } if ( ScopeUtils . inInterfaceOrAnnotationBlock ( varDefAST ) || varDefAST . getType ( ) == TokenTypes . ENUM_CONSTANT_DEF ) { return varDefAST ; } final DetailAST modifiersAST = varDefAST . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( modifiersAST . branchContains ( TokenTypes . FINAL ) ) { return varDefAST ; } return null ; } private void reportMagicNumber ( DetailAST ast ) { String text = ast . getText ( ) ; final DetailAST parent = ast . getParent ( ) ; DetailAST reportAST = ast ; if ( parent . getType ( ) == TokenTypes . UNARY_MINUS ) { reportAST = parent ; text = "-" + text ; } else if ( parent . getType ( ) == TokenTypes . UNARY_PLUS ) { reportAST = parent ; text = "+" + text ; } log ( reportAST . getLineNo ( ) , reportAST . getColumnNo ( ) , MSG_KEY , text ) ; } private boolean isInHashCodeMethod ( DetailAST ast ) { if ( ! ScopeUtils . inCodeBlock ( ast ) ) { return false ; } DetailAST methodDefAST = ast . getParent ( ) ; while ( null != methodDefAST && TokenTypes . METHOD_DEF != methodDefAST . getType ( ) ) { methodDefAST = methodDefAST . getParent ( ) ; } if ( null == methodDefAST ) { return false ; } final DetailAST identAST = methodDefAST . findFirstToken ( TokenTypes . IDENT ) ; if ( ! "hashCode" . equals ( identAST . getText ( ) ) ) { return false ; } final DetailAST paramAST = methodDefAST . findFirstToken ( TokenTypes . PARAMETERS ) ; return 0 == paramAST . getChildCount ( ) ; } private boolean inIgnoreList ( DetailAST ast ) { double value = CheckUtils . parseDouble ( ast . getText ( ) , ast . getType ( ) ) ; final DetailAST parent = ast . getParent ( ) ; if ( parent . getType ( ) == TokenTypes . UNARY_MINUS ) { value = - 1 * value ; } return Arrays . binarySearch ( ignoreNumbers , value ) >= 0 ; } private boolean isFieldDeclaration ( DetailAST ast ) { DetailAST varDefAST = ast ; while ( varDefAST != null && varDefAST . getType ( ) != TokenTypes . VARIABLE_DEF ) { varDefAST = varDefAST . getParent ( ) ; } return varDefAST != null && varDefAST . getParent ( ) . getParent ( ) . getType ( ) == TokenTypes . CLASS_DEF ; } public void setIgnoreNumbers ( double ... list ) { if ( list . length == 0 ) { ignoreNumbers = new double [ 0 ] ; } else { ignoreNumbers = new double [ list . length ] ; System . arraycopy ( list , 0 , ignoreNumbers , 0 , list . length ) ; Arrays . sort ( ignoreNumbers ) ; } } public void setIgnoreHashCodeMethod ( boolean ignoreHashCodeMethod ) { this . ignoreHashCodeMethod = ignoreHashCodeMethod ; } public void setIgnoreAnnotation ( boolean ignoreAnnotation ) { this . ignoreAnnotation = ignoreAnnotation ; } public void setIgnoreFieldDeclaration ( boolean ignoreFieldDeclaration ) { this . ignoreFieldDeclaration = ignoreFieldDeclaration ; } private static boolean isChildOf ( DetailAST ast , int type ) { boolean result = false ; DetailAST node = ast ; do { if ( node . getType ( ) == type ) { result = true ; } node = node . getParent ( ) ; } while ( node != null && ! result ) ; return result ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import antlr . collections . AST ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . Map ; import java . util . Set ; public class EqualsHashCodeCheck extends Check { public static final String MSG_KEY = "equals.noHashCode" ; private final Map < DetailAST , DetailAST > objBlockEquals = Maps . newHashMap ( ) ; private final Set < DetailAST > objBlockWithHashCode = Sets . newHashSet ( ) ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF } ; } @ Override public void beginTree ( DetailAST rootAST ) { objBlockEquals . clear ( ) ; objBlockWithHashCode . clear ( ) ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST modifiers = ast . getFirstChild ( ) ; final AST type = ast . findFirstToken ( TokenTypes . TYPE ) ; final AST methodName = ast . findFirstToken ( TokenTypes . IDENT ) ; final DetailAST parameters = ast . findFirstToken ( TokenTypes . PARAMETERS ) ; if ( type . getFirstChild ( ) . getType ( ) == TokenTypes . LITERAL_BOOLEAN && "equals" . equals ( methodName . getText ( ) ) && modifiers . branchContains ( TokenTypes . LITERAL_PUBLIC ) && parameters . getChildCount ( ) == 1 && isObjectParam ( parameters . getFirstChild ( ) ) ) { objBlockEquals . put ( ast . getParent ( ) , ast ) ; } else if ( type . getFirstChild ( ) . getType ( ) == TokenTypes . LITERAL_INT && "hashCode" . equals ( methodName . getText ( ) ) && modifiers . branchContains ( TokenTypes . LITERAL_PUBLIC ) && parameters . getFirstChild ( ) == null ) { objBlockWithHashCode . add ( ast . getParent ( ) ) ; } } private boolean isObjectParam ( AST firstChild ) { final AST modifiers = firstChild . getFirstChild ( ) ; final AST type = modifiers . getNextSibling ( ) ; switch ( type . getFirstChild ( ) . getType ( ) ) { case TokenTypes . LITERAL_BOOLEAN : case TokenTypes . LITERAL_BYTE : case TokenTypes . LITERAL_CHAR : case TokenTypes . LITERAL_DOUBLE : case TokenTypes . LITERAL_FLOAT : case TokenTypes . LITERAL_INT : case TokenTypes . LITERAL_LONG : case TokenTypes . LITERAL_SHORT : return false ; default : return true ; } } @ Override public void finishTree ( DetailAST rootAST ) { for ( Map . Entry < DetailAST , DetailAST > detailASTDetailASTEntry : objBlockEquals . entrySet ( ) ) { if ( ! objBlockWithHashCode . contains ( detailASTDetailASTEntry . getKey ( ) ) ) { final DetailAST equalsAST = detailASTDetailASTEntry . getValue ( ) ; log ( equalsAST . getLineNo ( ) , equalsAST . getColumnNo ( ) , MSG_KEY ) ; } } objBlockEquals . clear ( ) ; objBlockWithHashCode . clear ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class FinalLocalVariableCheck extends Check { public static final String MSG_KEY = "final.variable" ; private final Deque < Map < String , DetailAST > > scopeStack = new ArrayDeque < > ( ) ; private boolean validateEnhancedForLoopVariable ; public final void setValidateEnhancedForLoopVariable ( boolean validateEnhancedForLoopVariable ) { this . validateEnhancedForLoopVariable = validateEnhancedForLoopVariable ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . IDENT , TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . VARIABLE_DEF , TokenTypes . INSTANCE_INIT , TokenTypes . STATIC_INIT , TokenTypes . LITERAL_FOR , TokenTypes . SLIST , TokenTypes . OBJBLOCK , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . IDENT , TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . VARIABLE_DEF , TokenTypes . INSTANCE_INIT , TokenTypes . STATIC_INIT , TokenTypes . LITERAL_FOR , TokenTypes . SLIST , TokenTypes . OBJBLOCK , TokenTypes . PARAMETER_DEF , } ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . IDENT , TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . INSTANCE_INIT , TokenTypes . STATIC_INIT , TokenTypes . LITERAL_FOR , TokenTypes . SLIST , TokenTypes . OBJBLOCK , } ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . OBJBLOCK : case TokenTypes . SLIST : case TokenTypes . LITERAL_FOR : case TokenTypes . METHOD_DEF : case TokenTypes . CTOR_DEF : case TokenTypes . STATIC_INIT : case TokenTypes . INSTANCE_INIT : scopeStack . push ( new HashMap < String , DetailAST > ( ) ) ; break ; case TokenTypes . PARAMETER_DEF : if ( ScopeUtils . inInterfaceBlock ( ast ) || inAbstractOrNativeMethod ( ast ) || inLambda ( ast ) ) { break ; } case TokenTypes . VARIABLE_DEF : if ( ast . getParent ( ) . getType ( ) != TokenTypes . OBJBLOCK && shouldCheckEnhancedForLoopVariable ( ast ) && isVariableInForInit ( ast ) && ! ast . branchContains ( TokenTypes . FINAL ) ) { insertVariable ( ast ) ; } break ; case TokenTypes . IDENT : final int parentType = ast . getParent ( ) . getType ( ) ; if ( isAssignOperator ( parentType ) && ast . getParent ( ) . getFirstChild ( ) == ast ) { removeVariable ( ast ) ; } break ; default : } } private boolean isAssignOperator ( int parentType ) { return TokenTypes . POST_DEC == parentType || TokenTypes . DEC == parentType || TokenTypes . POST_INC == parentType || TokenTypes . INC == parentType || TokenTypes . ASSIGN == parentType || TokenTypes . PLUS_ASSIGN == parentType || TokenTypes . MINUS_ASSIGN == parentType || TokenTypes . DIV_ASSIGN == parentType || TokenTypes . STAR_ASSIGN == parentType || TokenTypes . MOD_ASSIGN == parentType || TokenTypes . SR_ASSIGN == parentType || TokenTypes . BSR_ASSIGN == parentType || TokenTypes . SL_ASSIGN == parentType || TokenTypes . BXOR_ASSIGN == parentType || TokenTypes . BOR_ASSIGN == parentType || TokenTypes . BAND_ASSIGN == parentType ; } private boolean shouldCheckEnhancedForLoopVariable ( DetailAST ast ) { return validateEnhancedForLoopVariable || ast . getParent ( ) . getType ( ) != TokenTypes . FOR_EACH_CLAUSE ; } private static boolean isVariableInForInit ( DetailAST variableDef ) { return variableDef . getParent ( ) . getType ( ) != TokenTypes . FOR_INIT ; } private static boolean inAbstractOrNativeMethod ( DetailAST ast ) { DetailAST parent = ast . getParent ( ) ; while ( parent != null ) { if ( parent . getType ( ) == TokenTypes . METHOD_DEF ) { final DetailAST modifiers = parent . findFirstToken ( TokenTypes . MODIFIERS ) ; return modifiers . branchContains ( TokenTypes . ABSTRACT ) || modifiers . branchContains ( TokenTypes . LITERAL_NATIVE ) ; } parent = parent . getParent ( ) ; } return false ; } private static boolean inLambda ( DetailAST paramDef ) { return paramDef . getParent ( ) . getParent ( ) . getType ( ) == TokenTypes . LAMBDA ; } private static DetailAST findClassOrConstructorOrMethodInWhichItIsDefined ( DetailAST ast ) { DetailAST astTraverse = ast ; while ( ! ( astTraverse . getType ( ) == TokenTypes . METHOD_DEF || astTraverse . getType ( ) == TokenTypes . CLASS_DEF || astTraverse . getType ( ) == TokenTypes . CTOR_DEF ) ) { astTraverse = astTraverse . getParent ( ) ; } return astTraverse ; } private static boolean isSameVariables ( DetailAST ast1 , DetailAST ast2 ) { final DetailAST classOrMethodOfAst1 = findClassOrConstructorOrMethodInWhichItIsDefined ( ast1 ) ; final DetailAST classOrMethodOfAst2 = findClassOrConstructorOrMethodInWhichItIsDefined ( ast2 ) ; final String identifierOfAst1 = classOrMethodOfAst1 . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; final String identifierOfAst2 = classOrMethodOfAst2 . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; return identifierOfAst1 . equals ( identifierOfAst2 ) ; } private void insertVariable ( DetailAST ast ) { final Map < String , DetailAST > state = scopeStack . peek ( ) ; final DetailAST astNode = ast . findFirstToken ( TokenTypes . IDENT ) ; state . put ( astNode . getText ( ) , astNode ) ; } private void removeVariable ( DetailAST ast ) { final Iterator < Map < String , DetailAST > > iterator = scopeStack . descendingIterator ( ) ; while ( iterator . hasNext ( ) ) { final Map < String , DetailAST > state = iterator . next ( ) ; final DetailAST storedVariable = state . get ( ast . getText ( ) ) ; if ( storedVariable != null && isSameVariables ( storedVariable , ast ) ) { state . remove ( ast . getText ( ) ) ; break ; } } } @ Override public void leaveToken ( DetailAST ast ) { super . leaveToken ( ast ) ; switch ( ast . getType ( ) ) { case TokenTypes . OBJBLOCK : case TokenTypes . SLIST : case TokenTypes . LITERAL_FOR : case TokenTypes . CTOR_DEF : case TokenTypes . STATIC_INIT : case TokenTypes . INSTANCE_INIT : case TokenTypes . METHOD_DEF : final Map < String , DetailAST > state = scopeStack . pop ( ) ; for ( DetailAST var : state . values ( ) ) { log ( var . getLineNo ( ) , var . getColumnNo ( ) , MSG_KEY , var . getText ( ) ) ; } break ; default : } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class FallThroughCheck extends Check { public static final String MSG_FALL_THROUGH = "fall.through" ; public static final String MSG_FALL_THROUGH_LAST = "fall.through.last" ; private boolean checkLastGroup ; private String reliefPattern = "fallthru|falls? ?through" ; private Pattern regExp ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CASE_GROUP } ; } @ Override public int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CASE_GROUP } ; } public void setReliefPattern ( String pattern ) { reliefPattern = pattern ; } public void setCheckLastCaseGroup ( boolean value ) { checkLastGroup = value ; } @ Override public void init ( ) { super . init ( ) ; regExp = Pattern . compile ( reliefPattern ) ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST nextGroup = ast . getNextSibling ( ) ; final boolean isLastGroup = nextGroup == null || nextGroup . getType ( ) != TokenTypes . CASE_GROUP ; if ( isLastGroup && ! checkLastGroup ) { return ; } final DetailAST slist = ast . findFirstToken ( TokenTypes . SLIST ) ; if ( slist != null && ! isTerminated ( slist , true , true ) && ! hasFallTruComment ( ast , nextGroup ) ) { if ( ! isLastGroup ) { log ( nextGroup , MSG_FALL_THROUGH ) ; } else { log ( ast , MSG_FALL_THROUGH_LAST ) ; } } } private boolean isTerminated ( final DetailAST ast , boolean useBreak , boolean useContinue ) { switch ( ast . getType ( ) ) { case TokenTypes . LITERAL_RETURN : case TokenTypes . LITERAL_THROW : return true ; case TokenTypes . LITERAL_BREAK : return useBreak ; case TokenTypes . LITERAL_CONTINUE : return useContinue ; case TokenTypes . SLIST : return checkSlist ( ast , useBreak , useContinue ) ; case TokenTypes . LITERAL_IF : return checkIf ( ast , useBreak , useContinue ) ; case TokenTypes . LITERAL_FOR : case TokenTypes . LITERAL_WHILE : case TokenTypes . LITERAL_DO : return checkLoop ( ast ) ; case TokenTypes . LITERAL_TRY : return checkTry ( ast , useBreak , useContinue ) ; case TokenTypes . LITERAL_SWITCH : return checkSwitch ( ast , useContinue ) ; default : return false ; } } private boolean checkSlist ( final DetailAST ast , boolean useBreak , boolean useContinue ) { DetailAST lastStmt = ast . getLastChild ( ) ; if ( lastStmt == null ) { return true ; } if ( lastStmt . getType ( ) == TokenTypes . RCURLY ) { lastStmt = lastStmt . getPreviousSibling ( ) ; } return lastStmt != null && isTerminated ( lastStmt , useBreak , useContinue ) ; } private boolean checkIf ( final DetailAST ast , boolean useBreak , boolean useContinue ) { final DetailAST thenStmt = ast . findFirstToken ( TokenTypes . RPAREN ) . getNextSibling ( ) ; final DetailAST elseStmt = thenStmt . getNextSibling ( ) ; boolean isTerminated = isTerminated ( thenStmt , useBreak , useContinue ) ; if ( isTerminated && elseStmt != null ) { isTerminated = isTerminated ( elseStmt . getFirstChild ( ) , useBreak , useContinue ) ; } return isTerminated ; } private boolean checkLoop ( final DetailAST ast ) { DetailAST loopBody = null ; if ( ast . getType ( ) == TokenTypes . LITERAL_DO ) { final DetailAST lparen = ast . findFirstToken ( TokenTypes . DO_WHILE ) ; loopBody = lparen . getPreviousSibling ( ) ; } else { final DetailAST rparen = ast . findFirstToken ( TokenTypes . RPAREN ) ; loopBody = rparen . getNextSibling ( ) ; } return isTerminated ( loopBody , false , false ) ; } private boolean checkTry ( final DetailAST ast , boolean useBreak , boolean useContinue ) { final DetailAST finalStmt = ast . getLastChild ( ) ; if ( finalStmt . getType ( ) == TokenTypes . LITERAL_FINALLY ) { return isTerminated ( finalStmt . findFirstToken ( TokenTypes . SLIST ) , useBreak , useContinue ) ; } boolean isTerminated = isTerminated ( ast . getFirstChild ( ) , useBreak , useContinue ) ; DetailAST catchStmt = ast . findFirstToken ( TokenTypes . LITERAL_CATCH ) ; while ( catchStmt != null && isTerminated ) { final DetailAST catchBody = catchStmt . findFirstToken ( TokenTypes . SLIST ) ; isTerminated &= isTerminated ( catchBody , useBreak , useContinue ) ; catchStmt = catchStmt . getNextSibling ( ) ; } return isTerminated ; } private boolean checkSwitch ( final DetailAST ast , boolean useContinue ) { DetailAST caseGroup = ast . findFirstToken ( TokenTypes . CASE_GROUP ) ; boolean isTerminated = caseGroup != null ; while ( isTerminated && caseGroup != null && caseGroup . getType ( ) != TokenTypes . RCURLY ) { final DetailAST caseBody = caseGroup . findFirstToken ( TokenTypes . SLIST ) ; isTerminated = caseBody != null && isTerminated ( caseBody , false , useContinue ) ; caseGroup = caseGroup . getNextSibling ( ) ; } return isTerminated ; } private boolean hasFallTruComment ( DetailAST currentCase , DetailAST nextCase ) { final int endLineNo = nextCase . getLineNo ( ) ; final int endColNo = nextCase . getColumnNo ( ) ; final String [ ] lines = getLines ( ) ; final String linepart = lines [ endLineNo - 1 ] . substring ( 0 , endColNo ) ; if ( commentMatch ( regExp , linepart , endLineNo ) ) { return true ; } final int startLineNo = currentCase . getLineNo ( ) ; for ( int i = endLineNo - 2 ; i > startLineNo - 1 ; i -- ) { if ( lines [ i ] . trim ( ) . length ( ) != 0 ) { return commentMatch ( regExp , lines [ i ] , i + 1 ) ; } } return false ; } private boolean commentMatch ( Pattern pattern , String line , int lineNo ) { final Matcher matcher = pattern . matcher ( line ) ; final boolean hit = matcher . find ( ) ; if ( hit ) { final int startMatch = matcher . start ( ) ; final int endMatch = matcher . end ( ) - 1 ; return getFileContents ( ) . hasIntersectionWithComment ( lineNo , startMatch , lineNo , endMatch ) ; } return false ; } }
package com . puppycrawl . tools . checkstyle . checks . modifier ; import java . io . File ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import static com . puppycrawl . tools . checkstyle . checks . modifier . ModifierOrderCheck . MSG_ANNOTATION_ORDER ; import static com . puppycrawl . tools . checkstyle . checks . modifier . ModifierOrderCheck . MSG_MODIFIER_ORDER ; public class ModifierOrderCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ModifierOrderCheck . class ) ; final String [ ] expected = { "14:10: " + getCheckMessage ( MSG_MODIFIER_ORDER , "final" ) , "18:12: " + getCheckMessage ( MSG_MODIFIER_ORDER , "private" ) , "24:14: " + getCheckMessage ( MSG_MODIFIER_ORDER , "private" ) , "34:13: " + getCheckMessage ( MSG_ANNOTATION_ORDER , "@MyAnnotation2" ) , "39:13: " + getCheckMessage ( MSG_ANNOTATION_ORDER , "@MyAnnotation2" ) , "49:35: " + getCheckMessage ( MSG_ANNOTATION_ORDER , "@MyAnnotation4" ) , } ; verify ( checkConfig , getPath ( "InputModifier.java" ) , expected ) ; } @ Test public void testDefaultMethods ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ModifierOrderCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools" + "/checkstyle/InputModifier2.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testGetDefaultTokens ( ) { ModifierOrderCheck modifierOrderCheckObj = new ModifierOrderCheck ( ) ; int [ ] actual = modifierOrderCheckObj . getDefaultTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . MODIFIERS } ; int [ ] unexpectedEmptyArray = new int [ ] { } ; int [ ] unexpectedArray = new int [ ] { TokenTypes . MODIFIERS , TokenTypes . OBJBLOCK , } ; Assert . assertArrayEquals ( expected , actual ) ; Assert . assertNotSame ( unexpectedEmptyArray , actual ) ; Assert . assertNotSame ( unexpectedArray , actual ) ; Assert . assertNotNull ( actual ) ; } @ Test public void testGetAcceptableTokens ( ) { ModifierOrderCheck modifierOrderCheckObj = new ModifierOrderCheck ( ) ; int [ ] actual = modifierOrderCheckObj . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . MODIFIERS } ; int [ ] unexpectedEmptyArray = new int [ ] { } ; int [ ] unexpectedArray = new int [ ] { TokenTypes . MODIFIERS , TokenTypes . OBJBLOCK , } ; Assert . assertArrayEquals ( expected , actual ) ; Assert . assertNotSame ( unexpectedEmptyArray , actual ) ; Assert . assertNotSame ( unexpectedArray , actual ) ; Assert . assertNotNull ( actual ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import java . util . HashMap ; import java . util . Map ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class OverloadMethodsDeclarationOrderCheck extends Check { public static final String MSG_KEY = "overload.methods.declaration" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . OBJBLOCK , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . OBJBLOCK , } ; } @ Override public void visitToken ( DetailAST ast ) { final int parentType = ast . getParent ( ) . getType ( ) ; if ( parentType == TokenTypes . CLASS_DEF || parentType == TokenTypes . ENUM_DEF || parentType == TokenTypes . INTERFACE_DEF || parentType == TokenTypes . LITERAL_NEW ) { checkOverloadMethodsGrouping ( ast ) ; } } private void checkOverloadMethodsGrouping ( DetailAST objectBlock ) { final int allowedDistance = 1 ; DetailAST currentToken = objectBlock . getFirstChild ( ) ; final Map < String , Integer > methodIndexMap = new HashMap < > ( ) ; final Map < String , Integer > methodLineNumberMap = new HashMap < > ( ) ; int currentIndex = 0 ; while ( currentToken != null ) { if ( currentToken . getType ( ) == TokenTypes . METHOD_DEF ) { currentIndex ++ ; final String methodName = currentToken . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; if ( methodIndexMap . containsKey ( methodName ) ) { final int priviousIndex = methodIndexMap . get ( methodName ) ; if ( currentIndex - priviousIndex > allowedDistance ) { final int previousLineWithOverloadMethod = methodLineNumberMap . get ( methodName ) ; log ( currentToken . getLineNo ( ) , MSG_KEY , previousLineWithOverloadMethod ) ; } } methodIndexMap . put ( methodName , currentIndex ) ; methodLineNumberMap . put ( methodName , currentToken . getLineNo ( ) ) ; } currentToken = currentToken . getNextSibling ( ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public final class PackageDeclarationCheck extends Check { public static final String MSG_KEY = "missing.package.declaration" ; private static final int DEFAULT_LINE_NUMBER = 1 ; private boolean defined ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF } ; } @ Override public int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF } ; } @ Override public void beginTree ( DetailAST ast ) { defined = false ; } @ Override public void finishTree ( DetailAST ast ) { if ( ! defined ) { int lineNumber = DEFAULT_LINE_NUMBER ; if ( ast != null ) { lineNumber = ast . getLineNo ( ) ; } log ( lineNumber , MSG_KEY ) ; } } @ Override public void visitToken ( DetailAST ast ) { defined = true ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . AbstractDeclarationCollector ; public class RequireThisCheck extends AbstractDeclarationCollector { public static final String MSG_METHOD = "require.this.method" ; public static final String MSG_VARIABLE = "require.this.variable" ; private boolean checkFields = true ; private boolean checkMethods = true ; public void setCheckFields ( boolean checkFields ) { this . checkFields = checkFields ; } public void setCheckMethods ( boolean checkMethods ) { this . checkMethods = checkMethods ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . CTOR_DEF , TokenTypes . ENUM_DEF , TokenTypes . IDENT , TokenTypes . INTERFACE_DEF , TokenTypes . METHOD_DEF , TokenTypes . PARAMETER_DEF , TokenTypes . SLIST , TokenTypes . VARIABLE_DEF , } ; } @ Override public int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . IDENT , } ; } @ Override public void visitToken ( DetailAST ast ) { super . visitToken ( ast ) ; if ( ast . getType ( ) == TokenTypes . IDENT ) { processIdent ( ast ) ; } } private void processIdent ( DetailAST ast ) { final int parentType = ast . getParent ( ) . getType ( ) ; switch ( parentType ) { case TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR : case TokenTypes . ANNOTATION : case TokenTypes . ANNOTATION_FIELD_DEF : break ; case TokenTypes . METHOD_CALL : { if ( checkMethods && isClassMethod ( ast . getText ( ) ) ) { log ( ast , "require.this.method" , ast . getText ( ) ) ; } break ; } default : { if ( checkFields ) { processField ( ast , parentType ) ; } break ; } } } private void processField ( DetailAST ast , int parentType ) { if ( ScopeUtils . getSurroundingScope ( ast ) == null ) { return ; } if ( parentType == TokenTypes . DOT && ast . getPreviousSibling ( ) != null ) { return ; } if ( parentType == TokenTypes . TYPE || parentType == TokenTypes . LITERAL_NEW ) { return ; } if ( isDeclarationToken ( parentType ) ) { return ; } final String name = ast . getText ( ) ; if ( isClassField ( name ) ) { log ( ast , "require.this.variable" , name ) ; } } private boolean isDeclarationToken ( int parentType ) { return parentType == TokenTypes . VARIABLE_DEF || parentType == TokenTypes . CTOR_DEF || parentType == TokenTypes . METHOD_DEF || parentType == TokenTypes . CLASS_DEF || parentType == TokenTypes . ENUM_DEF || parentType == TokenTypes . INTERFACE_DEF || parentType == TokenTypes . PARAMETER_DEF || parentType == TokenTypes . TYPE_ARGUMENT ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public final class NestedForDepthCheck extends AbstractNestedDepthCheck { public static final String MSG_KEY = "nested.for.depth" ; private static final int DEFAULT_MAX = 1 ; public NestedForDepthCheck ( ) { super ( DEFAULT_MAX ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_FOR } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . LITERAL_FOR } ; } @ Override public void visitToken ( DetailAST ast ) { if ( TokenTypes . LITERAL_FOR == ast . getType ( ) ) { nestIn ( ast , MSG_KEY ) ; } } @ Override public void leaveToken ( DetailAST ast ) { if ( TokenTypes . LITERAL_FOR == ast . getType ( ) ) { nestOut ( ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import java . util . AbstractMap . SimpleEntry ; import java . util . ArrayList ; import java . util . List ; import java . util . Map . Entry ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import antlr . collections . ASTEnumeration ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class VariableDeclarationUsageDistanceCheck extends Check { public static final String MSG_KEY = "variable.declaration.usage.distance" ; public static final String MSG_KEY_EXT = "variable.declaration.usage.distance.extend" ; private static final int DEFAULT_DISTANCE = 3 ; private int allowedDistance = DEFAULT_DISTANCE ; private Pattern ignoreVariablePattern = Pattern . compile ( "" ) ; private boolean validateBetweenScopes ; private boolean ignoreFinal = true ; public void setAllowedDistance ( int allowedDistance ) { this . allowedDistance = allowedDistance ; } public void setIgnoreVariablePattern ( String ignorePattern ) { this . ignoreVariablePattern = Utils . createPattern ( ignorePattern ) ; } public void setValidateBetweenScopes ( boolean validateBetweenScopes ) { this . validateBetweenScopes = validateBetweenScopes ; } public void setIgnoreFinal ( boolean ignoreFinal ) { this . ignoreFinal = ignoreFinal ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF } ; } @ Override public void visitToken ( DetailAST ast ) { final int parentType = ast . getParent ( ) . getType ( ) ; final DetailAST modifiers = ast . getFirstChild ( ) ; if ( ! ( ignoreFinal && modifiers . branchContains ( TokenTypes . FINAL ) || parentType == TokenTypes . OBJBLOCK ) ) { final DetailAST variable = ast . findFirstToken ( TokenTypes . IDENT ) ; if ( ! isVariableMatchesIgnorePattern ( variable . getText ( ) ) ) { final DetailAST semicolonAst = ast . getNextSibling ( ) ; Entry < DetailAST , Integer > entry = null ; if ( validateBetweenScopes ) { entry = calculateDistanceBetweenScopes ( semicolonAst , variable ) ; } else { entry = calculateDistanceInSingleScope ( semicolonAst , variable ) ; } final DetailAST variableUsageAst = entry . getKey ( ) ; final int dist = entry . getValue ( ) ; if ( dist > allowedDistance && ! isInitializationSequence ( variableUsageAst , variable . getText ( ) ) ) { if ( ignoreFinal ) { log ( variable . getLineNo ( ) , MSG_KEY_EXT , variable . getText ( ) , dist , allowedDistance ) ; } else { log ( variable . getLineNo ( ) , MSG_KEY , variable . getText ( ) , dist , allowedDistance ) ; } } } } } private static String getInstanceName ( DetailAST methodCallAst ) { final String methodCallName = FullIdent . createFullIdentBelow ( methodCallAst ) . getText ( ) ; final int lastDotIndex = methodCallName . lastIndexOf ( '.' ) ; String instanceName = "" ; if ( lastDotIndex != - 1 ) { instanceName = methodCallName . substring ( 0 , lastDotIndex ) ; } return instanceName ; } private static boolean isInitializationSequence ( DetailAST variableUsageAst , String variableName ) { boolean result = true ; boolean isUsedVariableDeclarationFound = false ; DetailAST currentSiblingAst = variableUsageAst ; String initInstanceName = "" ; while ( result && ! isUsedVariableDeclarationFound && currentSiblingAst != null ) { switch ( currentSiblingAst . getType ( ) ) { case TokenTypes . EXPR : final DetailAST methodCallAst = currentSiblingAst . getFirstChild ( ) ; if ( methodCallAst != null && methodCallAst . getType ( ) == TokenTypes . METHOD_CALL ) { final String instanceName = getInstanceName ( methodCallAst ) ; if ( instanceName . isEmpty ( ) ) { result = false ; } else if ( ! instanceName . equals ( initInstanceName ) ) { if ( ! initInstanceName . isEmpty ( ) ) { result = false ; } else { initInstanceName = instanceName ; } } } else { result = false ; } break ; case TokenTypes . VARIABLE_DEF : final String currentVariableName = currentSiblingAst . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; isUsedVariableDeclarationFound = variableName . equals ( currentVariableName ) ; break ; case TokenTypes . SEMI : break ; default : result = false ; } currentSiblingAst = currentSiblingAst . getPreviousSibling ( ) ; } return result ; } private Entry < DetailAST , Integer > calculateDistanceInSingleScope ( DetailAST semicolonAst , DetailAST variableIdentAst ) { int dist = 0 ; boolean firstUsageFound = false ; DetailAST currentAst = semicolonAst ; DetailAST variableUsageAst = null ; while ( ! firstUsageFound && currentAst != null && currentAst . getType ( ) != TokenTypes . RCURLY ) { if ( currentAst . getFirstChild ( ) != null ) { if ( isChild ( currentAst , variableIdentAst ) ) { switch ( currentAst . getType ( ) ) { case TokenTypes . VARIABLE_DEF : dist ++ ; break ; case TokenTypes . SLIST : dist = 0 ; break ; case TokenTypes . LITERAL_FOR : case TokenTypes . LITERAL_WHILE : case TokenTypes . LITERAL_DO : case TokenTypes . LITERAL_IF : case TokenTypes . LITERAL_SWITCH : if ( isVariableInOperatorExpr ( currentAst , variableIdentAst ) ) { dist ++ ; } else { dist = 0 ; } break ; default : if ( currentAst . branchContains ( TokenTypes . SLIST ) ) { dist = 0 ; } else { dist ++ ; } } variableUsageAst = currentAst ; firstUsageFound = true ; } else if ( currentAst . getType ( ) != TokenTypes . VARIABLE_DEF ) { dist ++ ; } } currentAst = currentAst . getNextSibling ( ) ; } if ( ! firstUsageFound ) { dist = 0 ; } return new SimpleEntry < > ( variableUsageAst , dist ) ; } private Entry < DetailAST , Integer > calculateDistanceBetweenScopes ( DetailAST ast , DetailAST variable ) { int dist = 0 ; DetailAST currentScopeAst = ast ; DetailAST variableUsageAst = null ; while ( currentScopeAst != null ) { final List < DetailAST > variableUsageExpressions = new ArrayList < > ( ) ; DetailAST currentStatementAst = currentScopeAst ; currentScopeAst = null ; while ( currentStatementAst != null && currentStatementAst . getType ( ) != TokenTypes . RCURLY ) { if ( currentStatementAst . getFirstChild ( ) != null ) { if ( isChild ( currentStatementAst , variable ) ) { variableUsageExpressions . add ( currentStatementAst ) ; } else if ( variableUsageExpressions . isEmpty ( ) && currentStatementAst . getType ( ) != TokenTypes . VARIABLE_DEF ) { dist ++ ; } } currentStatementAst = currentStatementAst . getNextSibling ( ) ; } if ( variableUsageExpressions . size ( ) == 1 ) { final DetailAST blockWithVariableUsage = variableUsageExpressions . get ( 0 ) ; DetailAST exprWithVariableUsage = null ; switch ( blockWithVariableUsage . getType ( ) ) { case TokenTypes . VARIABLE_DEF : case TokenTypes . EXPR : dist ++ ; break ; case TokenTypes . LITERAL_FOR : case TokenTypes . LITERAL_WHILE : case TokenTypes . LITERAL_DO : exprWithVariableUsage = getFirstNodeInsideForWhileDoWhileBlocks ( blockWithVariableUsage , variable ) ; break ; case TokenTypes . LITERAL_IF : exprWithVariableUsage = getFirstNodeInsideIfBlock ( blockWithVariableUsage , variable ) ; break ; case TokenTypes . LITERAL_SWITCH : exprWithVariableUsage = getFirstNodeInsideSwitchBlock ( blockWithVariableUsage , variable ) ; break ; case TokenTypes . LITERAL_TRY : exprWithVariableUsage = getFirstNodeInsideTryCatchFinallyBlocks ( blockWithVariableUsage , variable ) ; break ; default : exprWithVariableUsage = blockWithVariableUsage . getFirstChild ( ) ; } currentScopeAst = exprWithVariableUsage ; if ( exprWithVariableUsage != null ) { variableUsageAst = exprWithVariableUsage ; } else { variableUsageAst = blockWithVariableUsage ; } } else if ( variableUsageExpressions . size ( ) > 1 ) { dist ++ ; variableUsageAst = variableUsageExpressions . get ( 0 ) ; } else { variableUsageAst = null ; } } return new SimpleEntry < > ( variableUsageAst , dist ) ; } private DetailAST getFirstNodeInsideForWhileDoWhileBlocks ( DetailAST block , DetailAST variable ) { DetailAST firstNodeInsideBlock = null ; if ( ! isVariableInOperatorExpr ( block , variable ) ) { DetailAST currentNode = null ; if ( block . getType ( ) == TokenTypes . LITERAL_DO ) { currentNode = block . getFirstChild ( ) ; } else { currentNode = block . findFirstToken ( TokenTypes . RPAREN ) ; if ( currentNode != null ) { currentNode = currentNode . getNextSibling ( ) ; } } if ( currentNode != null ) { final int currentNodeType = currentNode . getType ( ) ; if ( currentNodeType == TokenTypes . SLIST ) { firstNodeInsideBlock = currentNode . getFirstChild ( ) ; } else if ( currentNodeType != TokenTypes . VARIABLE_DEF && currentNodeType != TokenTypes . EXPR ) { firstNodeInsideBlock = currentNode ; } } } return firstNodeInsideBlock ; } private DetailAST getFirstNodeInsideIfBlock ( DetailAST block , DetailAST variable ) { DetailAST firstNodeInsideBlock = null ; if ( ! isVariableInOperatorExpr ( block , variable ) ) { DetailAST currentNode = block . getLastChild ( ) ; final List < DetailAST > variableUsageExpressions = new ArrayList < > ( ) ; while ( currentNode != null && currentNode . getType ( ) == TokenTypes . LITERAL_ELSE ) { final DetailAST previousNode = currentNode . getPreviousSibling ( ) ; if ( isChild ( previousNode , variable ) ) { variableUsageExpressions . add ( previousNode ) ; } currentNode = currentNode . getFirstChild ( ) ; if ( currentNode . getType ( ) == TokenTypes . LITERAL_IF ) { currentNode = currentNode . getLastChild ( ) ; } else if ( isChild ( currentNode , variable ) ) { variableUsageExpressions . add ( currentNode ) ; currentNode = null ; } } if ( currentNode != null && isChild ( currentNode , variable ) ) { variableUsageExpressions . add ( currentNode ) ; } if ( variableUsageExpressions . size ( ) == 1 ) { firstNodeInsideBlock = variableUsageExpressions . get ( 0 ) ; } } return firstNodeInsideBlock ; } private DetailAST getFirstNodeInsideSwitchBlock ( DetailAST block , DetailAST variable ) { DetailAST firstNodeInsideBlock = null ; if ( ! isVariableInOperatorExpr ( block , variable ) ) { DetailAST currentNode = block . findFirstToken ( TokenTypes . CASE_GROUP ) ; final List < DetailAST > variableUsageExpressions = new ArrayList < > ( ) ; while ( currentNode != null && currentNode . getType ( ) == TokenTypes . CASE_GROUP ) { final DetailAST lastNodeInCaseGroup = currentNode . getLastChild ( ) ; if ( isChild ( lastNodeInCaseGroup , variable ) ) { variableUsageExpressions . add ( lastNodeInCaseGroup ) ; } currentNode = currentNode . getNextSibling ( ) ; } if ( variableUsageExpressions . size ( ) == 1 ) { firstNodeInsideBlock = variableUsageExpressions . get ( 0 ) ; } } return firstNodeInsideBlock ; } private static DetailAST getFirstNodeInsideTryCatchFinallyBlocks ( DetailAST block , DetailAST variable ) { DetailAST currentNode = block . getFirstChild ( ) ; final List < DetailAST > variableUsageExpressions = new ArrayList < > ( ) ; if ( isChild ( currentNode , variable ) ) { variableUsageExpressions . add ( currentNode ) ; } currentNode = currentNode . getNextSibling ( ) ; while ( currentNode != null && currentNode . getType ( ) == TokenTypes . LITERAL_CATCH ) { final DetailAST catchBlock = currentNode . getLastChild ( ) ; if ( isChild ( catchBlock , variable ) ) { variableUsageExpressions . add ( catchBlock ) ; } currentNode = currentNode . getNextSibling ( ) ; } if ( currentNode != null ) { final DetailAST finalBlock = currentNode . getLastChild ( ) ; if ( isChild ( finalBlock , variable ) ) { variableUsageExpressions . add ( finalBlock ) ; } } DetailAST variableUsageNode = null ; if ( variableUsageExpressions . size ( ) == 1 ) { variableUsageNode = variableUsageExpressions . get ( 0 ) . getFirstChild ( ) ; } return variableUsageNode ; } private boolean isVariableInOperatorExpr ( DetailAST operator , DetailAST variable ) { boolean isVarInOperatorDeclr = false ; final DetailAST openingBracket = operator . findFirstToken ( TokenTypes . LPAREN ) ; if ( openingBracket != null ) { DetailAST exprBetweenBrackets = openingBracket . getNextSibling ( ) ; while ( exprBetweenBrackets . getType ( ) != TokenTypes . RPAREN ) { if ( isChild ( exprBetweenBrackets , variable ) ) { isVarInOperatorDeclr = true ; break ; } exprBetweenBrackets = exprBetweenBrackets . getNextSibling ( ) ; } if ( ! isVarInOperatorDeclr ) { switch ( operator . getType ( ) ) { case TokenTypes . LITERAL_IF : final DetailAST elseBlock = operator . getLastChild ( ) ; if ( elseBlock . getType ( ) == TokenTypes . LITERAL_ELSE ) { final DetailAST firstNodeInsideElseBlock = elseBlock . getFirstChild ( ) ; if ( firstNodeInsideElseBlock . getType ( ) == TokenTypes . LITERAL_IF ) { isVarInOperatorDeclr |= isVariableInOperatorExpr ( firstNodeInsideElseBlock , variable ) ; } } break ; case TokenTypes . LITERAL_SWITCH : DetailAST currentCaseBlock = operator . findFirstToken ( TokenTypes . CASE_GROUP ) ; while ( currentCaseBlock != null && currentCaseBlock . getType ( ) == TokenTypes . CASE_GROUP ) { final DetailAST firstNodeInsideCaseBlock = currentCaseBlock . getFirstChild ( ) ; if ( isChild ( firstNodeInsideCaseBlock , variable ) ) { isVarInOperatorDeclr = true ; break ; } currentCaseBlock = currentCaseBlock . getNextSibling ( ) ; } break ; default : } } } return isVarInOperatorDeclr ; } private static boolean isChild ( DetailAST parent , DetailAST ast ) { boolean isChild = false ; final ASTEnumeration astList = parent . findAllPartial ( ast ) ; while ( astList . hasMoreNodes ( ) ) { final DetailAST astNode = ( DetailAST ) astList . nextNode ( ) ; DetailAST astParent = astNode . getParent ( ) ; while ( astParent != null ) { if ( astParent . equals ( parent ) && astParent . getLineNo ( ) == parent . getLineNo ( ) ) { isChild = true ; break ; } astParent = astParent . getParent ( ) ; } } return isChild ; } private boolean isVariableMatchesIgnorePattern ( String variable ) { final Matcher matcher = ignoreVariablePattern . matcher ( variable ) ; return matcher . matches ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class EmptyStatementCheck extends Check { public static final String MSG_KEY = "empty.statement" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . EMPTY_STAT } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . EMPTY_STAT } ; } @ Override public void visitToken ( DetailAST ast ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . AnnotationUtility ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . Collections ; import java . util . Set ; public final class IllegalThrowsCheck extends AbstractIllegalCheck { public static final String MSG_KEY = "illegal.throw" ; private static final String [ ] DEFAULT_IGNORED_METHOD_NAMES = { "finalize" , } ; private boolean ignoreOverriddenMethods = true ; private final Set < String > ignoredMethodNames = Sets . newHashSet ( ) ; public IllegalThrowsCheck ( ) { super ( "Error" , "RuntimeException" , "Throwable" , "java.lang.Error" , "java.lang.RuntimeException" , "java.lang.Throwable" ) ; setIgnoredMethodNames ( DEFAULT_IGNORED_METHOD_NAMES ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_THROWS } ; } @ Override public int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . LITERAL_THROWS } ; } @ Override public void visitToken ( DetailAST detailAST ) { final DetailAST methodDef = detailAST . getParent ( ) ; DetailAST token = detailAST . getFirstChild ( ) ; if ( ! isIgnorableMethod ( methodDef ) ) { while ( token != null ) { if ( token . getType ( ) != TokenTypes . COMMA ) { final FullIdent ident = FullIdent . createFullIdent ( token ) ; if ( isIllegalClassName ( ident . getText ( ) ) ) { log ( token , MSG_KEY , ident . getText ( ) ) ; } } token = token . getNextSibling ( ) ; } } } private boolean isIgnorableMethod ( DetailAST methodDef ) { return shouldIgnoreMethod ( methodDef . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ) || ignoreOverriddenMethods && ( AnnotationUtility . containsAnnotation ( methodDef , "Override" ) || AnnotationUtility . containsAnnotation ( methodDef , "java.lang.Override" ) ) ; } private boolean shouldIgnoreMethod ( String name ) { return ignoredMethodNames . contains ( name ) ; } public void setIgnoredMethodNames ( String ... methodNames ) { ignoredMethodNames . clear ( ) ; Collections . addAll ( ignoredMethodNames , methodNames ) ; } public void setIgnoreOverriddenMethods ( boolean ignoreOverriddenMethods ) { this . ignoreOverriddenMethods = ignoreOverriddenMethods ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class SimplifyBooleanExpressionCheck extends Check { public static final String MSG_KEY = "simplify.expression" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_TRUE , TokenTypes . LITERAL_FALSE } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { } ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . LITERAL_TRUE , TokenTypes . LITERAL_FALSE } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST parent = ast . getParent ( ) ; switch ( parent . getType ( ) ) { case TokenTypes . NOT_EQUAL : case TokenTypes . EQUAL : case TokenTypes . LNOT : case TokenTypes . LOR : case TokenTypes . LAND : log ( parent . getLineNo ( ) , parent . getColumnNo ( ) , MSG_KEY ) ; break ; default : break ; } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . AbstractFormatCheck ; import com . puppycrawl . tools . checkstyle . checks . CheckUtils ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; public final class IllegalTypeCheck extends AbstractFormatCheck { public static final String MSG_KEY = "illegal.type" ; private static final String DEFAULT_FORMAT = "^(.*[\\.])?Abstract.*$" ; private static final String [ ] DEFAULT_LEGAL_ABSTRACT_NAMES = { } ; private static final String [ ] DEFAULT_ILLEGAL_TYPES = { "HashSet" , "HashMap" , "LinkedHashMap" , "LinkedHashSet" , "TreeSet" , "TreeMap" , "java.util.HashSet" , "java.util.HashMap" , "java.util.LinkedHashMap" , "java.util.LinkedHashSet" , "java.util.TreeSet" , "java.util.TreeMap" , } ; private static final String [ ] DEFAULT_IGNORED_METHOD_NAMES = { "getInitialContext" , "getEnvironment" , } ; private final Set < String > illegalClassNames = Sets . newHashSet ( ) ; private final Set < String > legalAbstractClassNames = Sets . newHashSet ( ) ; private final Set < String > ignoredMethodNames = Sets . newHashSet ( ) ; private List < Integer > memberModifiers ; public IllegalTypeCheck ( ) { super ( DEFAULT_FORMAT ) ; setIllegalClassNames ( DEFAULT_ILLEGAL_TYPES ) ; setLegalAbstractClassNames ( DEFAULT_LEGAL_ABSTRACT_NAMES ) ; setIgnoredMethodNames ( DEFAULT_IGNORED_METHOD_NAMES ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . PARAMETER_DEF , TokenTypes . METHOD_DEF , TokenTypes . IMPORT , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . PARAMETER_DEF , TokenTypes . METHOD_DEF , TokenTypes . IMPORT , } ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . METHOD_DEF : if ( isVerifiable ( ast ) ) { visitMethodDef ( ast ) ; } break ; case TokenTypes . VARIABLE_DEF : if ( isVerifiable ( ast ) ) { visitVariableDef ( ast ) ; } break ; case TokenTypes . PARAMETER_DEF : visitParameterDef ( ast ) ; break ; case TokenTypes . IMPORT : visitImport ( ast ) ; break ; default : throw new IllegalStateException ( ast . toString ( ) ) ; } } private boolean isVerifiable ( DetailAST methodOrVariableDef ) { boolean result = true ; if ( memberModifiers != null ) { result = false ; final DetailAST modifiersAst = methodOrVariableDef . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( modifiersAst . getFirstChild ( ) != null ) { for ( DetailAST modifier = modifiersAst . getFirstChild ( ) ; modifier != null ; modifier = modifier . getNextSibling ( ) ) { if ( memberModifiers . contains ( modifier . getType ( ) ) ) { result = true ; } } } } return result ; } private void visitMethodDef ( DetailAST methodDef ) { if ( isCheckedMethod ( methodDef ) ) { checkClassName ( methodDef ) ; } } private void visitParameterDef ( DetailAST paradef ) { final DetailAST grandParentAST = paradef . getParent ( ) . getParent ( ) ; if ( grandParentAST . getType ( ) == TokenTypes . METHOD_DEF && isCheckedMethod ( grandParentAST ) ) { checkClassName ( paradef ) ; } } private void visitVariableDef ( DetailAST variableDef ) { checkClassName ( variableDef ) ; } private void visitImport ( DetailAST importAst ) { if ( ! isStarImport ( importAst ) ) { final String canonicalName = getCanonicalName ( importAst ) ; extendIllegalClassNamesWithShortName ( canonicalName ) ; } } private static boolean isStarImport ( DetailAST importAst ) { boolean result = false ; DetailAST toVisit = importAst ; while ( toVisit != null ) { toVisit = getNextSubTreeNode ( toVisit , importAst ) ; if ( toVisit != null && toVisit . getType ( ) == TokenTypes . STAR ) { result = true ; break ; } } return result ; } private void checkClassName ( DetailAST ast ) { final DetailAST type = ast . findFirstToken ( TokenTypes . TYPE ) ; final FullIdent ident = CheckUtils . createFullType ( type ) ; if ( isMatchingClassName ( ident . getText ( ) ) ) { log ( ident . getLineNo ( ) , ident . getColumnNo ( ) , MSG_KEY , ident . getText ( ) ) ; } } private boolean isMatchingClassName ( String className ) { final String shortName = className . substring ( className . lastIndexOf ( '.' ) + 1 ) ; return illegalClassNames . contains ( className ) || illegalClassNames . contains ( shortName ) || ! legalAbstractClassNames . contains ( className ) && getRegexp ( ) . matcher ( className ) . find ( ) ; } private void extendIllegalClassNamesWithShortName ( String canonicalName ) { if ( illegalClassNames . contains ( canonicalName ) ) { final String shortName = canonicalName . substring ( canonicalName . lastIndexOf ( '.' ) + 1 ) ; illegalClassNames . add ( shortName ) ; } } private static String getCanonicalName ( DetailAST importAst ) { final StringBuilder canonicalNameBuilder = new StringBuilder ( ) ; DetailAST toVisit = importAst ; while ( toVisit != null ) { toVisit = getNextSubTreeNode ( toVisit , importAst ) ; if ( toVisit != null && ( toVisit . getType ( ) == TokenTypes . IDENT || toVisit . getType ( ) == TokenTypes . STAR ) ) { canonicalNameBuilder . append ( toVisit . getText ( ) ) ; final DetailAST nextSubTreeNode = getNextSubTreeNode ( toVisit , importAst ) ; if ( nextSubTreeNode . getType ( ) != TokenTypes . SEMI ) { canonicalNameBuilder . append ( '.' ) ; } } } return canonicalNameBuilder . toString ( ) ; } private static DetailAST getNextSubTreeNode ( DetailAST currentNodeAst , DetailAST subTreeRootAst ) { DetailAST currentNode = currentNodeAst ; DetailAST toVisitAst = currentNode . getFirstChild ( ) ; while ( toVisitAst == null ) { toVisitAst = currentNode . getNextSibling ( ) ; if ( toVisitAst == null ) { if ( currentNode . getParent ( ) . equals ( subTreeRootAst ) ) { break ; } currentNode = currentNode . getParent ( ) ; } } currentNode = toVisitAst ; return currentNode ; } private boolean isCheckedMethod ( DetailAST ast ) { final String methodName = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; return ! ignoredMethodNames . contains ( methodName ) ; } public void setIllegalClassNames ( String ... classNames ) { illegalClassNames . clear ( ) ; Collections . addAll ( illegalClassNames , classNames ) ; } public String [ ] getIllegalClassNames ( ) { return illegalClassNames . toArray ( new String [ illegalClassNames . size ( ) ] ) ; } public void setIgnoredMethodNames ( String ... methodNames ) { ignoredMethodNames . clear ( ) ; Collections . addAll ( ignoredMethodNames , methodNames ) ; } public String [ ] getIgnoredMethodNames ( ) { return ignoredMethodNames . toArray ( new String [ ignoredMethodNames . size ( ) ] ) ; } public void setLegalAbstractClassNames ( String ... classNames ) { legalAbstractClassNames . clear ( ) ; Collections . addAll ( legalAbstractClassNames , classNames ) ; } public String [ ] getLegalAbstractClassNames ( ) { return legalAbstractClassNames . toArray ( new String [ legalAbstractClassNames . size ( ) ] ) ; } public void setMemberModifiers ( String modifiers ) { final List < Integer > modifiersList = new ArrayList < > ( ) ; for ( String modifier : modifiers . split ( "," ) ) { modifiersList . add ( Utils . getTokenId ( modifier . trim ( ) ) ) ; } this . memberModifiers = modifiersList ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import java . util . Locale ; import java . util . Set ; import java . util . regex . Pattern ; import org . apache . commons . beanutils . ConversionException ; import com . google . common . base . Objects ; import com . google . common . collect . Sets ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . Utils ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class HiddenFieldCheck extends Check { public static final String MSG_KEY = "hidden.field" ; private FieldFrame currentFrame ; private Pattern regexp ; private boolean ignoreSetter ; private boolean setterCanReturnItsClass ; private boolean ignoreConstructorParameter ; private boolean ignoreAbstractMethods ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . PARAMETER_DEF , TokenTypes . CLASS_DEF , TokenTypes . ENUM_DEF , TokenTypes . ENUM_CONSTANT_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . PARAMETER_DEF , } ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . ENUM_DEF , TokenTypes . ENUM_CONSTANT_DEF , } ; } @ Override public void beginTree ( DetailAST rootAST ) { currentFrame = new FieldFrame ( null , true , null ) ; } @ Override public void visitToken ( DetailAST ast ) { final int type = ast . getType ( ) ; switch ( type ) { case TokenTypes . VARIABLE_DEF : case TokenTypes . PARAMETER_DEF : processVariable ( ast ) ; break ; default : visitOtherTokens ( ast , type ) ; } } private void visitOtherTokens ( DetailAST ast , int type ) { final DetailAST typeMods = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; final boolean isStaticInnerType = typeMods != null && typeMods . branchContains ( TokenTypes . LITERAL_STATIC ) ; final FieldFrame frame = new FieldFrame ( currentFrame , isStaticInnerType , type == TokenTypes . CLASS_DEF || type == TokenTypes . ENUM_DEF ? ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) : null ) ; final DetailAST objBlock = ast . findFirstToken ( TokenTypes . OBJBLOCK ) ; if ( objBlock != null ) { DetailAST child = objBlock . getFirstChild ( ) ; while ( child != null ) { if ( child . getType ( ) == TokenTypes . VARIABLE_DEF ) { final String name = child . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; final DetailAST mods = child . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( mods . branchContains ( TokenTypes . LITERAL_STATIC ) ) { frame . addStaticField ( name ) ; } else { frame . addInstanceField ( name ) ; } } child = child . getNextSibling ( ) ; } } currentFrame = frame ; } @ Override public void leaveToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . CLASS_DEF || ast . getType ( ) == TokenTypes . ENUM_DEF || ast . getType ( ) == TokenTypes . ENUM_CONSTANT_DEF ) { currentFrame = currentFrame . getParent ( ) ; } } private void processVariable ( DetailAST ast ) { if ( ! ScopeUtils . inInterfaceOrAnnotationBlock ( ast ) && ( ScopeUtils . isLocalVariableDef ( ast ) || ast . getType ( ) == TokenTypes . PARAMETER_DEF ) ) { final DetailAST nameAST = ast . findFirstToken ( TokenTypes . IDENT ) ; final String name = nameAST . getText ( ) ; if ( isStaticOrOnstanceField ( ast , name ) && ! isMatchingRegexp ( name ) && ! isIgnoredSetterParam ( ast , name ) && ! isIgnoredConstructorParam ( ast ) && ! isIgnoredParamOfAbstractMethod ( ast ) ) { log ( nameAST , MSG_KEY , name ) ; } } } private boolean isStaticOrOnstanceField ( DetailAST ast , String name ) { return currentFrame . containsStaticField ( name ) || ! inStatic ( ast ) && currentFrame . containsInstanceField ( name ) ; } private boolean isMatchingRegexp ( String name ) { return regexp != null && regexp . matcher ( name ) . find ( ) ; } private static boolean inStatic ( DetailAST ast ) { DetailAST parent = ast . getParent ( ) ; while ( parent != null ) { switch ( parent . getType ( ) ) { case TokenTypes . STATIC_INIT : return true ; case TokenTypes . METHOD_DEF : final DetailAST mods = parent . findFirstToken ( TokenTypes . MODIFIERS ) ; return mods . branchContains ( TokenTypes . LITERAL_STATIC ) ; default : parent = parent . getParent ( ) ; } } return false ; } private boolean isIgnoredSetterParam ( DetailAST ast , String name ) { if ( ast . getType ( ) == TokenTypes . PARAMETER_DEF && ignoreSetter ) { final DetailAST parametersAST = ast . getParent ( ) ; final DetailAST methodAST = parametersAST . getParent ( ) ; if ( parametersAST . getChildCount ( ) == 1 && methodAST . getType ( ) == TokenTypes . METHOD_DEF && isSetterMethod ( methodAST , name ) ) { return true ; } } return false ; } private boolean isSetterMethod ( DetailAST aMethodAST , String aName ) { final String methodName = aMethodAST . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; boolean isSetterMethod = false ; if ( methodName . equals ( "set" + capitalize ( aName ) ) ) { final DetailAST typeAST = aMethodAST . findFirstToken ( TokenTypes . TYPE ) ; final String returnType = typeAST . getFirstChild ( ) . getText ( ) ; if ( typeAST . branchContains ( TokenTypes . LITERAL_VOID ) || setterCanReturnItsClass && currentFrame . embeddedIn ( returnType ) ) { isSetterMethod = true ; } } return isSetterMethod ; } private static String capitalize ( final String name ) { String setterName = name ; if ( name . length ( ) == 1 || ! Character . isUpperCase ( name . charAt ( 1 ) ) ) { setterName = name . substring ( 0 , 1 ) . toUpperCase ( Locale . ENGLISH ) + name . substring ( 1 ) ; } return setterName ; } private boolean isIgnoredConstructorParam ( DetailAST ast ) { boolean result = false ; if ( ast . getType ( ) == TokenTypes . PARAMETER_DEF && ignoreConstructorParameter ) { final DetailAST parametersAST = ast . getParent ( ) ; final DetailAST constructorAST = parametersAST . getParent ( ) ; result = constructorAST . getType ( ) == TokenTypes . CTOR_DEF ; } return result ; } private boolean isIgnoredParamOfAbstractMethod ( DetailAST ast ) { boolean result = false ; if ( ast . getType ( ) == TokenTypes . PARAMETER_DEF && ignoreAbstractMethods ) { final DetailAST method = ast . getParent ( ) . getParent ( ) ; if ( method . getType ( ) == TokenTypes . METHOD_DEF ) { final DetailAST mods = method . findFirstToken ( TokenTypes . MODIFIERS ) ; result = mods . branchContains ( TokenTypes . ABSTRACT ) ; } } return result ; } public void setIgnoreFormat ( String format ) throws ConversionException { regexp = Utils . createPattern ( format ) ; } public void setIgnoreSetter ( boolean ignoreSetter ) { this . ignoreSetter = ignoreSetter ; } public void setSetterCanReturnItsClass ( boolean aSetterCanReturnItsClass ) { setterCanReturnItsClass = aSetterCanReturnItsClass ; } public void setIgnoreConstructorParameter ( boolean ignoreConstructorParameter ) { this . ignoreConstructorParameter = ignoreConstructorParameter ; } public void setIgnoreAbstractMethods ( boolean ignoreAbstractMethods ) { this . ignoreAbstractMethods = ignoreAbstractMethods ; } private static class FieldFrame { private final String frameName ; private final boolean staticType ; private final FieldFrame parent ; private final Set < String > instanceFields = Sets . newHashSet ( ) ; private final Set < String > staticFields = Sets . newHashSet ( ) ; public FieldFrame ( FieldFrame parent , boolean staticType , String frameName ) { this . parent = parent ; this . staticType = staticType ; this . frameName = frameName ; } boolean isStaticType ( ) { return staticType ; } public void addInstanceField ( String field ) { instanceFields . add ( field ) ; } public void addStaticField ( String field ) { staticFields . add ( field ) ; } public boolean containsInstanceField ( String field ) { return instanceFields . contains ( field ) || parent != null && ! isStaticType ( ) && parent . containsInstanceField ( field ) ; } public boolean containsStaticField ( String field ) { return staticFields . contains ( field ) || parent != null && parent . containsStaticField ( field ) ; } public FieldFrame getParent ( ) { return parent ; } private boolean embeddedIn ( String classOrEnumName ) { FieldFrame currentFrame = this ; while ( currentFrame != null ) { if ( Objects . equal ( currentFrame . frameName , classOrEnumName ) ) { return true ; } currentFrame = currentFrame . parent ; } return false ; } } }
package com . puppycrawl . tools . checkstyle . checks . modifier ; import static com . puppycrawl . tools . checkstyle . checks . modifier . RedundantModifierCheck . MSG_KEY ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class RedundantModifierTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RedundantModifierCheck . class ) ; final String [ ] expected = { "54:12: " + getCheckMessage ( MSG_KEY , "static" ) , "57:9: " + getCheckMessage ( MSG_KEY , "public" ) , "63:9: " + getCheckMessage ( MSG_KEY , "abstract" ) , "66:9: " + getCheckMessage ( MSG_KEY , "public" ) , "72:9: " + getCheckMessage ( MSG_KEY , "final" ) , "79:13: " + getCheckMessage ( MSG_KEY , "final" ) , "88:12: " + getCheckMessage ( MSG_KEY , "final" ) , "99:1: " + getCheckMessage ( MSG_KEY , "abstract" ) , "116:5: " + getCheckMessage ( MSG_KEY , "public" ) , "117:5: " + getCheckMessage ( MSG_KEY , "final" ) , "118:5: " + getCheckMessage ( MSG_KEY , "static" ) , "120:5: " + getCheckMessage ( MSG_KEY , "public" ) , "121:5: " + getCheckMessage ( MSG_KEY , "abstract" ) , } ; verify ( checkConfig , getPath ( "InputModifier.java" ) , expected ) ; } @ Test public void testStaticMethodInInterface ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RedundantModifierCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/InputStaticModifierInInterface.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testFinalInInterface ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( RedundantModifierCheck . class ) ; final String [ ] expected = { "3:9: " + getCheckMessage ( MSG_KEY , "final" ) , } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/tools/" + "checkstyle/InputFinalInDefaultMethods.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { RedundantModifierCheck redundantModifierCheckObj = new RedundantModifierCheck ( ) ; int [ ] actual = redundantModifierCheckObj . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . VARIABLE_DEF , TokenTypes . ANNOTATION_FIELD_DEF , TokenTypes . INTERFACE_DEF , } ; Assert . assertNotNull ( actual ) ; Assert . assertArrayEquals ( expected , actual ) ; } @ Test public void testGetRequiredTokens ( ) { RedundantModifierCheck redundantModifierCheckObj = new RedundantModifierCheck ( ) ; int [ ] actual = redundantModifierCheckObj . getRequiredTokens ( ) ; int [ ] expected = new int [ ] { } ; Assert . assertNotNull ( actual ) ; Assert . assertArrayEquals ( expected , actual ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . CheckUtils ; public final class NestedIfDepthCheck extends AbstractNestedDepthCheck { public static final String MSG_KEY = "nested.if.depth" ; private static final int DEFAULT_MAX = 1 ; public NestedIfDepthCheck ( ) { super ( DEFAULT_MAX ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_IF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . LITERAL_IF } ; } @ Override public void visitToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . LITERAL_IF ) { visitLiteralIf ( ast ) ; } else { throw new IllegalStateException ( ast . toString ( ) ) ; } } @ Override public void leaveToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . LITERAL_IF ) { leaveLiteralIf ( ast ) ; } else { throw new IllegalStateException ( ast . toString ( ) ) ; } } private void visitLiteralIf ( DetailAST literalIf ) { if ( ! CheckUtils . isElseIf ( literalIf ) ) { nestIn ( literalIf , MSG_KEY ) ; } } private void leaveLiteralIf ( DetailAST literalIf ) { if ( ! CheckUtils . isElseIf ( literalIf ) ) { nestOut ( ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import antlr . collections . AST ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class EqualsAvoidNullCheck extends Check { public static final String MSG_EQUALS_AVOID_NULL = "equals.avoid.null" ; public static final String MSG_EQUALS_IGNORE_CASE_AVOID_NULL = "equalsIgnoreCase.avoid.null" ; private boolean ignoreEqualsIgnoreCase ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . METHOD_CALL } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . METHOD_CALL } ; } @ Override public void visitToken ( final DetailAST methodCall ) { final DetailAST dot = methodCall . getFirstChild ( ) ; if ( dot . getType ( ) != TokenTypes . DOT ) { return ; } final DetailAST objCalledOn = dot . getFirstChild ( ) ; if ( isStringLiteral ( objCalledOn ) ) { return ; } final DetailAST method = objCalledOn . getNextSibling ( ) ; final DetailAST expr = dot . getNextSibling ( ) . getFirstChild ( ) ; if ( "equals" . equals ( method . getText ( ) ) && containsOneArg ( expr ) && containsAllSafeTokens ( expr ) ) { log ( methodCall . getLineNo ( ) , methodCall . getColumnNo ( ) , MSG_EQUALS_AVOID_NULL ) ; } if ( ! ignoreEqualsIgnoreCase && "equalsIgnoreCase" . equals ( method . getText ( ) ) && containsOneArg ( expr ) && containsAllSafeTokens ( expr ) ) { log ( methodCall . getLineNo ( ) , methodCall . getColumnNo ( ) , MSG_EQUALS_IGNORE_CASE_AVOID_NULL ) ; } } private boolean isStringLiteral ( DetailAST objCalledOn ) { return objCalledOn . getType ( ) == TokenTypes . STRING_LITERAL || objCalledOn . getType ( ) == TokenTypes . LITERAL_NEW || objCalledOn . getType ( ) == TokenTypes . DOT ; } private boolean containsNoArgs ( final AST expr ) { return expr == null ; } private boolean containsMultiArgs ( final AST expr ) { final AST comma = expr . getNextSibling ( ) ; return comma != null && comma . getType ( ) == TokenTypes . COMMA ; } private boolean containsOneArg ( final AST expr ) { return ! containsNoArgs ( expr ) && ! containsMultiArgs ( expr ) ; } private boolean containsAllSafeTokens ( final DetailAST expr ) { DetailAST arg = expr . getFirstChild ( ) ; if ( arg . branchContains ( TokenTypes . METHOD_CALL ) ) { return false ; } arg = skipVariableAssign ( arg ) ; return ! arg . branchContains ( TokenTypes . PLUS_ASSIGN ) && ! arg . branchContains ( TokenTypes . IDENT ) ; } private DetailAST skipVariableAssign ( final DetailAST currentAST ) { if ( currentAST . getType ( ) == TokenTypes . ASSIGN && currentAST . getFirstChild ( ) . getType ( ) == TokenTypes . IDENT ) { return currentAST . getFirstChild ( ) . getNextSibling ( ) ; } return currentAST ; } public void setIgnoreEqualsIgnoreCase ( boolean newValue ) { ignoreEqualsIgnoreCase = newValue ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . AbstractFormatCheck ; import java . util . ArrayDeque ; import java . util . Deque ; public final class ReturnCountCheck extends AbstractFormatCheck { public static final String MSG_KEY = "return.count" ; private static final int DEFAULT_MAX = 2 ; private final Deque < Context > contextStack = new ArrayDeque < > ( ) ; private int max ; private Context context ; public ReturnCountCheck ( ) { super ( "^equals$" ) ; setMax ( DEFAULT_MAX ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . LAMBDA , TokenTypes . LITERAL_RETURN , } ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . LITERAL_RETURN , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . LAMBDA , TokenTypes . LITERAL_RETURN , } ; } public int getMax ( ) { return max ; } public void setMax ( int max ) { this . max = max ; } @ Override public void beginTree ( DetailAST rootAST ) { context = new Context ( false ) ; contextStack . clear ( ) ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CTOR_DEF : case TokenTypes . METHOD_DEF : visitMethodDef ( ast ) ; break ; case TokenTypes . LAMBDA : visitLambda ( ) ; break ; case TokenTypes . LITERAL_RETURN : context . visitLiteralReturn ( ) ; break ; default : throw new IllegalStateException ( ast . toString ( ) ) ; } } @ Override public void leaveToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CTOR_DEF : case TokenTypes . METHOD_DEF : case TokenTypes . LAMBDA : leave ( ast ) ; break ; case TokenTypes . LITERAL_RETURN : break ; default : throw new IllegalStateException ( ast . toString ( ) ) ; } } private void visitMethodDef ( DetailAST ast ) { contextStack . push ( context ) ; final DetailAST methodNameAST = ast . findFirstToken ( TokenTypes . IDENT ) ; context = new Context ( ! getRegexp ( ) . matcher ( methodNameAST . getText ( ) ) . find ( ) ) ; } private void leave ( DetailAST ast ) { context . checkCount ( ast ) ; context = contextStack . pop ( ) ; } private void visitLambda ( ) { contextStack . push ( context ) ; context = new Context ( true ) ; } private class Context { private final boolean checking ; private int count ; public Context ( boolean checking ) { this . checking = checking ; count = 0 ; } public void visitLiteralReturn ( ) { ++ count ; } public void checkCount ( DetailAST ast ) { if ( checking && count > getMax ( ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY , count , getMax ( ) ) ; } } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public final class OneStatementPerLineCheck extends Check { public static final String MSG_KEY = "multiple.statements.line" ; private int lastStatementEnd = - 1 ; private int exprDepth ; private boolean inForHeader ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . EXPR , TokenTypes . SEMI , TokenTypes . FOR_INIT , TokenTypes . FOR_ITERATOR , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . EXPR , TokenTypes . SEMI , TokenTypes . FOR_INIT , TokenTypes . FOR_ITERATOR , } ; } @ Override public void beginTree ( DetailAST rootAST ) { exprDepth = 0 ; inForHeader = false ; lastStatementEnd = - 1 ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . EXPR : visitExpr ( ast ) ; break ; case TokenTypes . SEMI : visitSemi ( ast ) ; break ; case TokenTypes . FOR_INIT : inForHeader = true ; break ; default : break ; } } @ Override public void leaveToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . FOR_ITERATOR : inForHeader = false ; break ; case TokenTypes . EXPR : exprDepth -- ; break ; default : break ; } } private void visitExpr ( DetailAST ast ) { exprDepth ++ ; if ( exprDepth == 1 && ! inForHeader && lastStatementEnd == ast . getLineNo ( ) ) { log ( ast , MSG_KEY ) ; } } private void visitSemi ( DetailAST ast ) { if ( exprDepth == 0 ) { lastStatementEnd = ast . getLineNo ( ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import antlr . collections . AST ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . Deque ; public abstract class AbstractSuperCheck extends Check { public static final String MSG_KEY = "missing.super.call" ; private static class MethodNode { private final DetailAST method ; private boolean callingSuper ; public MethodNode ( DetailAST ast ) { method = ast ; callingSuper = false ; } public void setCallingSuper ( ) { callingSuper = true ; } public boolean isCallingSuper ( ) { return callingSuper ; } public DetailAST getMethod ( ) { return method ; } } private final Deque < MethodNode > methodStack = Lists . newLinkedList ( ) ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . LITERAL_SUPER , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . LITERAL_SUPER , } ; } protected abstract String getMethodName ( ) ; @ Override public void beginTree ( DetailAST rootAST ) { methodStack . clear ( ) ; } @ Override public void visitToken ( DetailAST ast ) { if ( isOverridingMethod ( ast ) ) { methodStack . add ( new MethodNode ( ast ) ) ; } else if ( isSuperCall ( ast ) ) { final MethodNode methodNode = methodStack . getLast ( ) ; methodNode . setCallingSuper ( ) ; } } private boolean isSuperCall ( DetailAST ast ) { if ( ast . getType ( ) != TokenTypes . LITERAL_SUPER ) { return false ; } DetailAST parent = ast . getParent ( ) ; if ( parent == null || parent . getType ( ) != TokenTypes . DOT ) { return false ; } if ( isSameNameMethod ( ast ) ) { return false ; } if ( isZeroParameters ( parent ) ) { return false ; } while ( parent != null ) { if ( parent . getType ( ) == TokenTypes . METHOD_DEF ) { return isOverridingMethod ( parent ) ; } else if ( parent . getType ( ) == TokenTypes . CTOR_DEF || parent . getType ( ) == TokenTypes . INSTANCE_INIT ) { return false ; } parent = parent . getParent ( ) ; } return false ; } private boolean isZeroParameters ( DetailAST parent ) { final DetailAST args = parent . getNextSibling ( ) ; return args == null || args . getType ( ) != TokenTypes . ELIST || args . getChildCount ( ) != 0 ; } private boolean isSameNameMethod ( DetailAST ast ) { AST sibling = ast . getNextSibling ( ) ; if ( sibling != null && sibling . getType ( ) == TokenTypes . TYPE_ARGUMENTS ) { sibling = sibling . getNextSibling ( ) ; } if ( sibling == null || sibling . getType ( ) != TokenTypes . IDENT ) { return true ; } final String name = sibling . getText ( ) ; return ! getMethodName ( ) . equals ( name ) ; } @ Override public void leaveToken ( DetailAST ast ) { if ( isOverridingMethod ( ast ) ) { final MethodNode methodNode = methodStack . removeLast ( ) ; if ( ! methodNode . isCallingSuper ( ) ) { final DetailAST methodAST = methodNode . getMethod ( ) ; final DetailAST nameAST = methodAST . findFirstToken ( TokenTypes . IDENT ) ; log ( nameAST . getLineNo ( ) , nameAST . getColumnNo ( ) , MSG_KEY , nameAST . getText ( ) ) ; } } } private boolean isOverridingMethod ( DetailAST ast ) { if ( ast . getType ( ) != TokenTypes . METHOD_DEF || ScopeUtils . inInterfaceOrAnnotationBlock ( ast ) ) { return false ; } final DetailAST nameAST = ast . findFirstToken ( TokenTypes . IDENT ) ; final String name = nameAST . getText ( ) ; if ( ! getMethodName ( ) . equals ( name ) ) { return false ; } final DetailAST params = ast . findFirstToken ( TokenTypes . PARAMETERS ) ; return params . getChildCount ( ) == 0 ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class ArrayTrailingCommaCheck extends Check { public static final String MSG_KEY = "array.trailing.comma" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . ARRAY_INIT } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . ARRAY_INIT } ; } @ Override public void visitToken ( DetailAST arrayInit ) { final DetailAST rcurly = arrayInit . findFirstToken ( TokenTypes . RCURLY ) ; if ( arrayInit . getLineNo ( ) == rcurly . getLineNo ( ) || arrayInit . getChildCount ( ) == 1 ) { return ; } final DetailAST prev = rcurly . getPreviousSibling ( ) ; if ( prev . getType ( ) != TokenTypes . COMMA ) { log ( rcurly . getLineNo ( ) , MSG_KEY ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import java . util . Arrays ; import antlr . collections . AST ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class InnerAssignmentCheck extends Check { public static final String MSG_KEY = "assignment.inner.avoid" ; private static final int [ ] [ ] ALLOWED_ASSIGMENT_CONTEXT = { { TokenTypes . EXPR , TokenTypes . SLIST } , { TokenTypes . VARIABLE_DEF } , { TokenTypes . EXPR , TokenTypes . ELIST , TokenTypes . FOR_INIT } , { TokenTypes . EXPR , TokenTypes . ELIST , TokenTypes . FOR_ITERATOR } , { TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR } , { TokenTypes . RESOURCE , TokenTypes . RESOURCES , TokenTypes . RESOURCE_SPECIFICATION , } , { TokenTypes . EXPR , TokenTypes . LAMBDA } , } ; private static final int [ ] [ ] CONTROL_CONTEXT = { { TokenTypes . EXPR , TokenTypes . LITERAL_DO } , { TokenTypes . EXPR , TokenTypes . LITERAL_FOR } , { TokenTypes . EXPR , TokenTypes . LITERAL_WHILE } , { TokenTypes . EXPR , TokenTypes . LITERAL_IF } , { TokenTypes . EXPR , TokenTypes . LITERAL_ELSE } , } ; private static final int [ ] [ ] ALLOWED_ASSIGMENT_IN_COMPARISON_CONTEXT = { { TokenTypes . EXPR , TokenTypes . LITERAL_WHILE , } , } ; private static final int [ ] COMPARISON_TYPES = { TokenTypes . EQUAL , TokenTypes . GE , TokenTypes . GT , TokenTypes . LE , TokenTypes . LT , TokenTypes . NOT_EQUAL , } ; static { Arrays . sort ( COMPARISON_TYPES ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . ASSIGN , TokenTypes . DIV_ASSIGN , TokenTypes . PLUS_ASSIGN , TokenTypes . MINUS_ASSIGN , TokenTypes . STAR_ASSIGN , TokenTypes . MOD_ASSIGN , TokenTypes . SR_ASSIGN , TokenTypes . BSR_ASSIGN , TokenTypes . SL_ASSIGN , TokenTypes . BXOR_ASSIGN , TokenTypes . BOR_ASSIGN , TokenTypes . BAND_ASSIGN , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . ASSIGN , TokenTypes . DIV_ASSIGN , TokenTypes . PLUS_ASSIGN , TokenTypes . MINUS_ASSIGN , TokenTypes . STAR_ASSIGN , TokenTypes . MOD_ASSIGN , TokenTypes . SR_ASSIGN , TokenTypes . BSR_ASSIGN , TokenTypes . SL_ASSIGN , TokenTypes . BXOR_ASSIGN , TokenTypes . BOR_ASSIGN , TokenTypes . BAND_ASSIGN , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( isInContext ( ast , ALLOWED_ASSIGMENT_CONTEXT ) ) { return ; } if ( isInNoBraceControlStatement ( ast ) ) { return ; } if ( isInWhileIdiom ( ast ) ) { return ; } log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY ) ; } private static boolean isInNoBraceControlStatement ( DetailAST ast ) { if ( ! isInContext ( ast , CONTROL_CONTEXT ) ) { return false ; } final DetailAST expr = ast . getParent ( ) ; final AST exprNext = expr . getNextSibling ( ) ; return exprNext != null && exprNext . getType ( ) == TokenTypes . SEMI ; } private boolean isInWhileIdiom ( DetailAST ast ) { if ( ! isComparison ( ast . getParent ( ) ) ) { return false ; } return isInContext ( ast . getParent ( ) , ALLOWED_ASSIGMENT_IN_COMPARISON_CONTEXT ) ; } private static boolean isComparison ( DetailAST ast ) { final int astType = ast . getType ( ) ; return Arrays . binarySearch ( COMPARISON_TYPES , astType ) >= 0 ; } private static boolean isInContext ( DetailAST ast , int [ ] ... contextSet ) { for ( int [ ] element : contextSet ) { DetailAST current = ast ; final int len = element . length ; for ( int j = 0 ; j < len ; j ++ ) { current = current . getParent ( ) ; final int expectedType = element [ j ] ; if ( current == null || current . getType ( ) != expectedType ) { break ; } if ( j == len - 1 ) { return true ; } } } return false ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; import java . util . BitSet ; import java . util . List ; import java . util . Map ; import java . util . regex . Pattern ; public class MultipleStringLiteralsCheck extends Check { public static final String MSG_KEY = "multiple.string.literal" ; private final Map < String , List < StringInfo > > stringMap = Maps . newHashMap ( ) ; private final BitSet ignoreOccurrenceContext = new BitSet ( ) ; private int allowedDuplicates = 1 ; private Pattern pattern ; public MultipleStringLiteralsCheck ( ) { setIgnoreStringsRegexp ( "^\"\"$" ) ; ignoreOccurrenceContext . set ( TokenTypes . ANNOTATION ) ; } public void setAllowedDuplicates ( int allowedDuplicates ) { this . allowedDuplicates = allowedDuplicates ; } public void setIgnoreStringsRegexp ( String ignoreStringsRegexp ) { if ( ignoreStringsRegexp != null && ignoreStringsRegexp . length ( ) > 0 ) { pattern = Utils . createPattern ( ignoreStringsRegexp ) ; } else { pattern = null ; } } public final void setIgnoreOccurrenceContext ( String ... strRep ) { ignoreOccurrenceContext . clear ( ) ; for ( final String s : strRep ) { final int type = Utils . getTokenId ( s ) ; ignoreOccurrenceContext . set ( type ) ; } } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . STRING_LITERAL } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . STRING_LITERAL } ; } @ Override public void visitToken ( DetailAST ast ) { if ( isInIgnoreOccurrenceContext ( ast ) ) { return ; } final String currentString = ast . getText ( ) ; if ( pattern == null || ! pattern . matcher ( currentString ) . find ( ) ) { List < StringInfo > hitList = stringMap . get ( currentString ) ; if ( hitList == null ) { hitList = Lists . newArrayList ( ) ; stringMap . put ( currentString , hitList ) ; } final int line = ast . getLineNo ( ) ; final int col = ast . getColumnNo ( ) ; hitList . add ( new StringInfo ( line , col ) ) ; } } private boolean isInIgnoreOccurrenceContext ( DetailAST ast ) { for ( DetailAST token = ast ; token . getParent ( ) != null ; token = token . getParent ( ) ) { final int type = token . getType ( ) ; if ( ignoreOccurrenceContext . get ( type ) ) { return true ; } } return false ; } @ Override public void beginTree ( DetailAST rootAST ) { super . beginTree ( rootAST ) ; stringMap . clear ( ) ; } @ Override public void finishTree ( DetailAST rootAST ) { for ( Map . Entry < String , List < StringInfo > > stringListEntry : stringMap . entrySet ( ) ) { final List < StringInfo > hits = stringListEntry . getValue ( ) ; if ( hits . size ( ) > allowedDuplicates ) { final StringInfo firstFinding = hits . get ( 0 ) ; final int line = firstFinding . getLine ( ) ; final int col = firstFinding . getCol ( ) ; log ( line , col , MSG_KEY , stringListEntry . getKey ( ) , hits . size ( ) ) ; } } } private static final class StringInfo { private final int line ; private final int col ; public StringInfo ( int line , int col ) { this . line = line ; this . col = col ; } private int getLine ( ) { return line ; } private int getCol ( ) { return col ; } } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public abstract class AbstractNestedDepthCheck extends Check { private int max ; private int depth ; public AbstractNestedDepthCheck ( int max ) { setMax ( max ) ; } @ Override public final int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public void beginTree ( DetailAST rootAST ) { depth = 0 ; } public final int getMax ( ) { return max ; } public final void setMax ( int max ) { this . max = max ; } protected final void nestIn ( DetailAST ast , String messageId ) { if ( depth > max ) { log ( ast , messageId , depth , max ) ; } ++ depth ; } protected final void nestOut ( ) { -- depth ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . Scope ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . ArrayDeque ; import java . util . Deque ; public class DeclarationOrderCheck extends Check { public static final String MSG_CONSTRUCTOR = "declaration.order.constructor" ; public static final String MSG_METHOD = "declaration.order.method" ; public static final String MSG_STATIC = "declaration.order.static" ; public static final String MSG_INSTANCE = "declaration.order.instance" ; public static final String MSG_ACCESS = "declaration.order.access" ; private static final int STATE_STATIC_VARIABLE_DEF = 1 ; private static final int STATE_INSTANCE_VARIABLE_DEF = 2 ; private static final int STATE_CTOR_DEF = 3 ; private static final int STATE_METHOD_DEF = 4 ; private final Deque < ScopeState > scopeStates = new ArrayDeque < > ( ) ; private static class ScopeState { private int currentScopeState = STATE_STATIC_VARIABLE_DEF ; private Scope declarationAccess = Scope . PUBLIC ; } private boolean ignoreConstructors ; private boolean ignoreMethods ; private boolean ignoreModifiers ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . MODIFIERS , TokenTypes . OBJBLOCK , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . MODIFIERS , TokenTypes . OBJBLOCK , } ; } @ Override public void visitToken ( DetailAST ast ) { final int parentType = ast . getParent ( ) . getType ( ) ; switch ( ast . getType ( ) ) { case TokenTypes . OBJBLOCK : scopeStates . push ( new ScopeState ( ) ) ; break ; case TokenTypes . CTOR_DEF : if ( parentType != TokenTypes . OBJBLOCK ) { return ; } processConstructor ( ast ) ; break ; case TokenTypes . METHOD_DEF : if ( parentType != TokenTypes . OBJBLOCK ) { return ; } processMethod ( ast ) ; break ; case TokenTypes . MODIFIERS : if ( parentType != TokenTypes . VARIABLE_DEF || ast . getParent ( ) . getParent ( ) . getType ( ) != TokenTypes . OBJBLOCK ) { return ; } processModifiers ( ast ) ; break ; default : break ; } } private void processConstructor ( DetailAST ast ) { final ScopeState state = scopeStates . peek ( ) ; if ( state . currentScopeState > STATE_CTOR_DEF ) { if ( ! ignoreConstructors ) { log ( ast , MSG_CONSTRUCTOR ) ; } } else { state . currentScopeState = STATE_CTOR_DEF ; } } private void processMethod ( DetailAST ast ) { final ScopeState state = scopeStates . peek ( ) ; if ( state . currentScopeState > STATE_METHOD_DEF ) { if ( ! ignoreMethods ) { log ( ast , MSG_METHOD ) ; } } else { state . currentScopeState = STATE_METHOD_DEF ; } } private void processModifiers ( DetailAST ast ) { final ScopeState state = scopeStates . peek ( ) ; if ( ast . findFirstToken ( TokenTypes . LITERAL_STATIC ) != null ) { if ( state . currentScopeState > STATE_STATIC_VARIABLE_DEF ) { if ( ! ignoreModifiers || state . currentScopeState > STATE_INSTANCE_VARIABLE_DEF ) { log ( ast , MSG_STATIC ) ; } } else { state . currentScopeState = STATE_STATIC_VARIABLE_DEF ; } } else { if ( state . currentScopeState > STATE_INSTANCE_VARIABLE_DEF ) { log ( ast , MSG_INSTANCE ) ; } else if ( state . currentScopeState == STATE_STATIC_VARIABLE_DEF ) { state . declarationAccess = Scope . PUBLIC ; state . currentScopeState = STATE_INSTANCE_VARIABLE_DEF ; } } final Scope access = ScopeUtils . getScopeFromMods ( ast ) ; if ( state . declarationAccess . compareTo ( access ) > 0 ) { if ( ! ignoreModifiers ) { log ( ast , MSG_ACCESS ) ; } } else { state . declarationAccess = access ; } } @ Override public void leaveToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . OBJBLOCK ) { scopeStates . pop ( ) ; } } public void setIgnoreConstructors ( boolean ignoreConstructors ) { this . ignoreConstructors = ignoreConstructors ; } public void setIgnoreMethods ( boolean ignoreMethods ) { this . ignoreMethods = ignoreMethods ; } public void setIgnoreModifiers ( boolean ignoreModifiers ) { this . ignoreModifiers = ignoreModifiers ; } }
package com . puppycrawl . tools . checkstyle . checks . blocks ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . blocks . RightCurlyCheck . MSG_KEY_LINE_ALONE ; import static com . puppycrawl . tools . checkstyle . checks . blocks . RightCurlyCheck . MSG_KEY_LINE_BREAK_BEFORE ; import static com . puppycrawl . tools . checkstyle . checks . blocks . RightCurlyCheck . MSG_KEY_LINE_NEW ; import static com . puppycrawl . tools . checkstyle . checks . blocks . RightCurlyCheck . MSG_KEY_LINE_SAME ; public class RightCurlyCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( RightCurlyCheck . class ) ; } @ Test public void testDefault ( ) throws Exception { final String [ ] expected = { "25:17: " + getCheckMessage ( MSG_KEY_LINE_SAME , "}" ) , "28:17: " + getCheckMessage ( MSG_KEY_LINE_SAME , "}" ) , "40:13: " + getCheckMessage ( MSG_KEY_LINE_SAME , "}" ) , "44:13: " + getCheckMessage ( MSG_KEY_LINE_SAME , "}" ) , "93:27: " + getCheckMessage ( MSG_KEY_LINE_ALONE , "}" ) , "93:27: " + getCheckMessage ( MSG_KEY_LINE_NEW , "}" ) , "93:27: " + getCheckMessage ( MSG_KEY_LINE_BREAK_BEFORE , "}" ) , "97:54: " + getCheckMessage ( MSG_KEY_LINE_BREAK_BEFORE , "}" ) , } ; verify ( checkConfig , getPath ( "InputLeftCurlyOther.java" ) , expected ) ; } @ Test public void testSame ( ) throws Exception { checkConfig . addAttribute ( "option" , RightCurlyOption . SAME . toString ( ) ) ; final String [ ] expected = { "25:17: " + getCheckMessage ( MSG_KEY_LINE_SAME , "}" ) , "28:17: " + getCheckMessage ( MSG_KEY_LINE_SAME , "}" ) , "40:13: " + getCheckMessage ( MSG_KEY_LINE_SAME , "}" ) , "44:13: " + getCheckMessage ( MSG_KEY_LINE_SAME , "}" ) , "93:27: " + getCheckMessage ( MSG_KEY_LINE_ALONE , "}" ) , "93:27: " + getCheckMessage ( MSG_KEY_LINE_NEW , "}" ) , "93:27: " + getCheckMessage ( MSG_KEY_LINE_BREAK_BEFORE , "}" ) , "97:54: " + getCheckMessage ( MSG_KEY_LINE_BREAK_BEFORE , "}" ) , } ; verify ( checkConfig , getPath ( "InputLeftCurlyOther.java" ) , expected ) ; } @ Test public void testAlone ( ) throws Exception { checkConfig . addAttribute ( "option" , RightCurlyOption . ALONE . toString ( ) ) ; final String [ ] expected = { "93:27: " + getCheckMessage ( MSG_KEY_LINE_ALONE , "}" ) , "93:27: " + getCheckMessage ( MSG_KEY_LINE_NEW , "}" ) , } ; verify ( checkConfig , getPath ( "InputLeftCurlyOther.java" ) , expected ) ; } @ Test public void testNewLine ( ) throws Exception { checkConfig . addAttribute ( "option" , RightCurlyOption . ALONE . toString ( ) ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF, METHOD_DEF, CTOR_DEF" ) ; final String [ ] expected = { "111:10: " + getCheckMessage ( MSG_KEY_LINE_NEW , "}" ) , "122:10: " + getCheckMessage ( MSG_KEY_LINE_NEW , "}" ) , "136:10: " + getCheckMessage ( MSG_KEY_LINE_NEW , "}" ) , } ; verify ( checkConfig , getPath ( "InputLeftCurlyOther.java" ) , expected ) ; } @ Test public void testShouldStartLine ( ) throws Exception { checkConfig . addAttribute ( "option" , RightCurlyOption . ALONE . toString ( ) ) ; checkConfig . addAttribute ( "shouldStartLine" , "false" ) ; final String [ ] expected = { "93:27: " + getCheckMessage ( MSG_KEY_LINE_ALONE , "}" ) , } ; verify ( checkConfig , getPath ( "InputLeftCurlyOther.java" ) , expected ) ; } @ Test public void testMethodCtorNamedClassClosingBrace ( ) throws Exception { checkConfig . addAttribute ( "option" , RightCurlyOption . ALONE . toString ( ) ) ; checkConfig . addAttribute ( "shouldStartLine" , "false" ) ; final String [ ] expected = { "93:27: " + getCheckMessage ( MSG_KEY_LINE_ALONE , "}" ) , } ; verify ( checkConfig , getPath ( "InputLeftCurlyOther.java" ) , expected ) ; } @ Test public void testForceLineBreakBefore ( ) throws Exception { checkConfig . addAttribute ( "option" , RightCurlyOption . ALONE . toString ( ) ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_FOR," + "LITERAL_WHILE, LITERAL_DO, STATIC_INIT, INSTANCE_INIT" ) ; final String [ ] expected = { "35:43: " + getCheckMessage ( MSG_KEY_LINE_ALONE , "}" ) , "41:71: " + getCheckMessage ( MSG_KEY_LINE_ALONE , "}" ) , "47:25: " + getCheckMessage ( MSG_KEY_LINE_ALONE , "}" ) , } ; verify ( checkConfig , getPath ( "InputRightCurlyLineBreakBefore.java" ) , expected ) ; } @ Test public void testForceLineBreakBefore2 ( ) throws Exception { final String [ ] expected = { "24:33: " + getCheckMessage ( MSG_KEY_LINE_BREAK_BEFORE , "}" ) , "32:44: " + getCheckMessage ( MSG_KEY_LINE_BREAK_BEFORE , "}" ) , "32:63: " + getCheckMessage ( MSG_KEY_LINE_BREAK_BEFORE , "}" ) , "52:56: " + getCheckMessage ( MSG_KEY_LINE_BREAK_BEFORE , "}" ) , } ; verify ( checkConfig , getPath ( "InputRightCurlyLineBreakBefore.java" ) , expected ) ; } @ Test public void testNPE ( ) throws Exception { checkConfig . addAttribute ( "option" , RightCurlyOption . ALONE . toString ( ) ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF, METHOD_DEF, CTOR_DEF, LITERAL_FOR, LITERAL_WHILE, LITERAL_DO, STATIC_INIT, INSTANCE_INIT" ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputRightCurlyEmptyAbstractMethod.java" ) , expected ) ; } @ Test public void testWithAnnotations ( ) throws Exception { checkConfig . addAttribute ( "option" , RightCurlyOption . ALONE . toString ( ) ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF, METHOD_DEF, CTOR_DEF, LITERAL_FOR, LITERAL_WHILE, LITERAL_DO, STATIC_INIT, INSTANCE_INIT" ) ; final String [ ] expected = { "9:57: " + getCheckMessage ( MSG_KEY_LINE_ALONE , "}" ) , "16:41: " + getCheckMessage ( MSG_KEY_LINE_ALONE , "}" ) , } ; verify ( checkConfig , getPath ( "InputRightCurlyAnnotations.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; public class DefinitionsTest { @ Test public void testIsProperUtilsClass ( ) throws ReflectiveOperationException { assertUtilsClassHasPrivateConstructor ( Definitions . class ) ; } }
package com . puppycrawl . tools . checkstyle . checks . coding ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . CheckUtils ; public class MultipleVariableDeclarationsCheck extends Check { public static final String MSG_MULTIPLE = "multiple.variable.declarations" ; public static final String MSG_MULTIPLE_COMMA = "multiple.variable.declarations.comma" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF } ; } @ Override public void visitToken ( DetailAST ast ) { DetailAST nextNode = ast . getNextSibling ( ) ; if ( nextNode == null ) { return ; } final boolean isCommaSeparated = nextNode . getType ( ) == TokenTypes . COMMA ; if ( nextNode . getType ( ) == TokenTypes . COMMA || nextNode . getType ( ) == TokenTypes . SEMI ) { nextNode = nextNode . getNextSibling ( ) ; } if ( nextNode != null && nextNode . getType ( ) == TokenTypes . VARIABLE_DEF ) { final DetailAST firstNode = CheckUtils . getFirstNode ( ast ) ; if ( isCommaSeparated ) { if ( ast . getParent ( ) . getType ( ) != TokenTypes . FOR_INIT ) { log ( firstNode , "multiple.variable.declarations.comma" ) ; } return ; } final DetailAST lastNode = getLastNode ( ast ) ; final DetailAST firstNextNode = CheckUtils . getFirstNode ( nextNode ) ; if ( firstNextNode . getLineNo ( ) == lastNode . getLineNo ( ) ) { log ( firstNode , "multiple.variable.declarations" ) ; } } } private static DetailAST getLastNode ( final DetailAST node ) { DetailAST currentNode = node ; DetailAST child = node . getFirstChild ( ) ; while ( child != null ) { final DetailAST newNode = getLastNode ( child ) ; if ( newNode . getLineNo ( ) > currentNode . getLineNo ( ) || newNode . getLineNo ( ) == currentNode . getLineNo ( ) && newNode . getColumnNo ( ) > currentNode . getColumnNo ( ) ) { currentNode = newNode ; } child = child . getNextSibling ( ) ; } return currentNode ; } }
package com . puppycrawl . tools . checkstyle . checks . annotation ;
package com . puppycrawl . tools . checkstyle . checks . annotation ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class AnnotationLocationCheck extends Check { public static final String MSG_KEY_ANNOTATION_LOCATION_ALONE = "annotation.location.alone" ; public static final String MSG_KEY_ANNOTATION_LOCATION = "annotation.location" ; private boolean allowSamelineSingleParameterlessAnnotation = true ; private boolean allowSamelineParameterizedAnnotation ; private boolean allowSamelineMultipleAnnotations ; public final void setAllowSamelineSingleParameterlessAnnotation ( boolean allow ) { allowSamelineSingleParameterlessAnnotation = allow ; } public final void setAllowSamelineParameterizedAnnotation ( boolean allow ) { allowSamelineParameterizedAnnotation = allow ; } public final void setAllowSamelineMultipleAnnotations ( boolean allow ) { allowSamelineMultipleAnnotations = allow ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . VARIABLE_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . VARIABLE_DEF , TokenTypes . PARAMETER_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . TYPECAST , TokenTypes . LITERAL_THROWS , TokenTypes . IMPLEMENTS_CLAUSE , TokenTypes . TYPE_ARGUMENT , TokenTypes . LITERAL_NEW , TokenTypes . DOT , TokenTypes . ANNOTATION_FIELD_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST modifiersNode = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( hasAnnotations ( modifiersNode ) ) { checkAnnotations ( modifiersNode , getAnnotationLevel ( modifiersNode ) ) ; } } private void checkAnnotations ( DetailAST modifierNode , int correctLevel ) { DetailAST annotation = modifierNode . getFirstChild ( ) ; while ( annotation != null && annotation . getType ( ) == TokenTypes . ANNOTATION ) { final boolean hasParameters = isParameterized ( annotation ) ; if ( ! isCorrectLocation ( annotation , hasParameters ) ) { log ( annotation . getLineNo ( ) , MSG_KEY_ANNOTATION_LOCATION_ALONE , getAnnotationName ( annotation ) ) ; } else if ( annotation . getColumnNo ( ) != correctLevel && ! hasNodeBefore ( annotation ) ) { log ( annotation . getLineNo ( ) , MSG_KEY_ANNOTATION_LOCATION , getAnnotationName ( annotation ) , annotation . getColumnNo ( ) , correctLevel ) ; } annotation = annotation . getNextSibling ( ) ; } } private boolean isCorrectLocation ( DetailAST annotation , boolean hasParams ) { final boolean allowingCondition = hasParams ? allowSamelineParameterizedAnnotation : allowSamelineSingleParameterlessAnnotation ; return allowingCondition && ! hasNodeBefore ( annotation ) || ! allowingCondition && ! hasNodeBeside ( annotation ) || allowSamelineMultipleAnnotations ; } private static String getAnnotationName ( DetailAST annotation ) { DetailAST idenNode = annotation . findFirstToken ( TokenTypes . IDENT ) ; if ( idenNode == null ) { idenNode = annotation . findFirstToken ( TokenTypes . DOT ) . findFirstToken ( TokenTypes . IDENT ) ; } return idenNode . getText ( ) ; } private static boolean hasNodeAfter ( DetailAST annotation ) { final int annotationLineNo = annotation . getLineNo ( ) ; DetailAST nextNode = annotation . getNextSibling ( ) ; if ( nextNode == null ) { nextNode = annotation . getParent ( ) . getNextSibling ( ) ; } return nextNode != null && annotationLineNo == nextNode . getLineNo ( ) ; } private static boolean hasNodeBefore ( DetailAST annotation ) { final int annotationLineNo = annotation . getLineNo ( ) ; final DetailAST previousNode = annotation . getPreviousSibling ( ) ; return previousNode != null && annotationLineNo == previousNode . getLineNo ( ) ; } private static boolean hasNodeBeside ( DetailAST annotation ) { return hasNodeBefore ( annotation ) || hasNodeAfter ( annotation ) ; } private static int getAnnotationLevel ( DetailAST modifierNode ) { return modifierNode . getParent ( ) . getColumnNo ( ) ; } private static boolean isParameterized ( DetailAST annotation ) { return annotation . findFirstToken ( TokenTypes . EXPR ) != null ; } private static boolean hasAnnotations ( DetailAST modifierNode ) { return modifierNode . findFirstToken ( TokenTypes . ANNOTATION ) != null ; } }
package com . puppycrawl . tools . checkstyle . checks . annotation ; import com . puppycrawl . tools . checkstyle . AnnotationUtility ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class PackageAnnotationCheck extends Check { @ Override public int [ ] getDefaultTokens ( ) { return this . getRequiredTokens ( ) ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . PACKAGE_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return this . getRequiredTokens ( ) ; } @ Override public void visitToken ( final DetailAST ast ) { final boolean containsAnnotation = AnnotationUtility . containsAnnotation ( ast ) ; final boolean inPackageInfo = this . getFileContents ( ) . inPackageInfo ( ) ; if ( containsAnnotation && ! inPackageInfo ) { this . log ( ast . getLine ( ) , "annotation.package.location" ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . annotation ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import com . puppycrawl . tools . checkstyle . AnnotationUtility ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . JavadocTagInfo ; import com . puppycrawl . tools . checkstyle . api . TextBlock ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; public final class MissingDeprecatedCheck extends Check { public static final String MSG_KEY_ANNOTATION_MISSING_DEPRECATED = "annotation.missing.deprecated" ; public static final String MSG_KEY_JAVADOC_DUPLICATE_TAG = "javadoc.duplicateTag" ; public static final String MSG_KEY_JAVADOC_MISSING = "javadoc.missing" ; private static final String DEPRECATED = "Deprecated" ; private static final String FQ_DEPRECATED = "java.lang." + DEPRECATED ; private static final Pattern MATCH_DEPRECATED = Utils . createPattern ( "@(deprecated)\\s+\\S" ) ; private static final Pattern MATCH_DEPRECATED_MULTILINE_START = Utils . createPattern ( "@(deprecated)\\s*$" ) ; private static final Pattern MATCH_DEPRECATED_MULTILINE_CONT = Utils . createPattern ( "(\\*/|@|[^\\s\\*])" ) ; private static final String END_JAVADOC = "*/" ; private static final String NEXT_TAG = "@" ; @ Override public int [ ] getDefaultTokens ( ) { return this . getAcceptableTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . INTERFACE_DEF , TokenTypes . CLASS_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . ENUM_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , TokenTypes . VARIABLE_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . ANNOTATION_FIELD_DEF , } ; } @ Override public void visitToken ( final DetailAST ast ) { final TextBlock javadoc = this . getFileContents ( ) . getJavadocBefore ( ast . getLineNo ( ) ) ; final boolean containsAnnotation = AnnotationUtility . containsAnnotation ( ast , DEPRECATED ) || AnnotationUtility . containsAnnotation ( ast , FQ_DEPRECATED ) ; final boolean containsJavadocTag = this . containsJavadocTag ( javadoc ) ; if ( containsAnnotation ^ containsJavadocTag ) { this . log ( ast . getLineNo ( ) , MSG_KEY_ANNOTATION_MISSING_DEPRECATED ) ; } } private boolean containsJavadocTag ( final TextBlock javadoc ) { if ( javadoc == null ) { return false ; } final String [ ] lines = javadoc . getText ( ) ; boolean found = false ; int currentLine = javadoc . getStartLineNo ( ) - 1 ; for ( int i = 0 ; i < lines . length ; i ++ ) { currentLine ++ ; final String line = lines [ i ] ; final Matcher javadocNoargMatcher = MissingDeprecatedCheck . MATCH_DEPRECATED . matcher ( line ) ; final Matcher noargMultilineStart = MissingDeprecatedCheck . MATCH_DEPRECATED_MULTILINE_START . matcher ( line ) ; if ( javadocNoargMatcher . find ( ) ) { if ( found ) { this . log ( currentLine , MSG_KEY_JAVADOC_DUPLICATE_TAG , JavadocTagInfo . DEPRECATED . getText ( ) ) ; } found = true ; } else if ( noargMultilineStart . find ( ) ) { found = validateTagAtTheRestOfComment ( lines , found , currentLine , i ) ; } } return found ; } private boolean validateTagAtTheRestOfComment ( String [ ] lines , boolean foundBefore , int currentLine , int i ) { boolean found = false ; for ( int reindex = i + 1 ; reindex < lines . length ; reindex ++ ) { final Matcher multilineCont = MissingDeprecatedCheck . MATCH_DEPRECATED_MULTILINE_CONT . matcher ( lines [ reindex ] ) ; if ( multilineCont . find ( ) ) { reindex = lines . length ; final String lFin = multilineCont . group ( 1 ) ; if ( ! lFin . equals ( MissingDeprecatedCheck . NEXT_TAG ) && ! lFin . equals ( MissingDeprecatedCheck . END_JAVADOC ) ) { if ( foundBefore ) { this . log ( currentLine , MSG_KEY_JAVADOC_DUPLICATE_TAG , JavadocTagInfo . DEPRECATED . getText ( ) ) ; } found = true ; } else { this . log ( currentLine , MSG_KEY_JAVADOC_MISSING ) ; if ( foundBefore ) { this . log ( currentLine , MSG_KEY_JAVADOC_DUPLICATE_TAG , JavadocTagInfo . DEPRECATED . getText ( ) ) ; } found = true ; } } } return found ; } }
package com . puppycrawl . tools . checkstyle . checks . annotation ; import java . util . regex . Matcher ; import com . puppycrawl . tools . checkstyle . AnnotationUtility ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . AbstractFormatCheck ; public class SuppressWarningsCheck extends AbstractFormatCheck { public static final String MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED = "suppressed.warning.not.allowed" ; private static final String SUPPRESS_WARNINGS = "SuppressWarnings" ; private static final String FQ_SUPPRESS_WARNINGS = "java.lang." + SUPPRESS_WARNINGS ; public SuppressWarningsCheck ( ) { super ( "^$|^\\s+$" ) ; } @ Override public final int [ ] getDefaultTokens ( ) { return this . getAcceptableTokens ( ) ; } @ Override public final int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . ANNOTATION_FIELD_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . PARAMETER_DEF , TokenTypes . VARIABLE_DEF , TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF , } ; } @ Override public void visitToken ( final DetailAST ast ) { final DetailAST annotation = this . getSuppressWarnings ( ast ) ; if ( annotation == null ) { return ; } final DetailAST warningHolder = this . findWarningsHolder ( annotation ) ; final DetailAST token = warningHolder . findFirstToken ( TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR ) ; DetailAST warning ; if ( token != null ) { warning = token . findFirstToken ( TokenTypes . EXPR ) ; } else { warning = warningHolder . findFirstToken ( TokenTypes . EXPR ) ; } if ( warning == null ) { this . logMatch ( warningHolder . getLineNo ( ) , warningHolder . getColumnNo ( ) , "" ) ; return ; } while ( warning != null ) { if ( warning . getType ( ) == TokenTypes . EXPR ) { final DetailAST fChild = warning . getFirstChild ( ) ; switch ( fChild . getType ( ) ) { case TokenTypes . STRING_LITERAL : final String warningText = this . removeQuotes ( warning . getFirstChild ( ) . getText ( ) ) ; this . logMatch ( warning . getLineNo ( ) , warning . getColumnNo ( ) , warningText ) ; break ; case TokenTypes . QUESTION : this . walkConditional ( fChild ) ; break ; case TokenTypes . IDENT : case TokenTypes . DOT : break ; default : } } warning = warning . getNextSibling ( ) ; } } private DetailAST getSuppressWarnings ( DetailAST ast ) { final DetailAST annotation = AnnotationUtility . getAnnotation ( ast , SuppressWarningsCheck . SUPPRESS_WARNINGS ) ; return annotation != null ? annotation : AnnotationUtility . getAnnotation ( ast , SuppressWarningsCheck . FQ_SUPPRESS_WARNINGS ) ; } private void logMatch ( final int lineNo , final int colNum , final String warningText ) { final Matcher matcher = this . getRegexp ( ) . matcher ( warningText ) ; if ( matcher . matches ( ) ) { this . log ( lineNo , colNum , MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED , warningText ) ; } } private DetailAST findWarningsHolder ( final DetailAST annotation ) { final DetailAST annValuePair = annotation . findFirstToken ( TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR ) ; final DetailAST annArrayInit ; if ( annValuePair != null ) { annArrayInit = annValuePair . findFirstToken ( TokenTypes . ANNOTATION_ARRAY_INIT ) ; } else { annArrayInit = annotation . findFirstToken ( TokenTypes . ANNOTATION_ARRAY_INIT ) ; } if ( annArrayInit != null ) { return annArrayInit ; } return annotation ; } private String removeQuotes ( final String warning ) { return warning . substring ( 1 , warning . length ( ) - 1 ) ; } private void walkConditional ( final DetailAST cond ) { if ( cond . getType ( ) != TokenTypes . QUESTION ) { final String warningText = this . removeQuotes ( cond . getText ( ) ) ; this . logMatch ( cond . getLineNo ( ) , cond . getColumnNo ( ) , warningText ) ; return ; } this . walkConditional ( this . getCondLeft ( cond ) ) ; this . walkConditional ( this . getCondRight ( cond ) ) ; } private DetailAST getCondLeft ( final DetailAST cond ) { final DetailAST colon = cond . findFirstToken ( TokenTypes . COLON ) ; return colon . getPreviousSibling ( ) ; } private DetailAST getCondRight ( final DetailAST cond ) { final DetailAST colon = cond . findFirstToken ( TokenTypes . COLON ) ; return colon . getNextSibling ( ) ; } }
package com . puppycrawl . tools . checkstyle . checks . annotation ; import java . util . Locale ; import org . apache . commons . beanutils . ConversionException ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public final class AnnotationUseStyleCheck extends Check { public static final String MSG_KEY_ANNOTATION_INCORRECT_STYLE = "annotation.incorrect.style" ; public static final String MSG_KEY_ANNOTATION_PARENS_MISSING = "annotation.parens.missing" ; public static final String MSG_KEY_ANNOTATION_PARENS_PRESENT = "annotation.parens.present" ; public static final String MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING = "annotation.trailing.comma.missing" ; public static final String MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT = "annotation.trailing.comma.present" ; private static final String ANNOTATION_ELEMENT_SINGLE_NAME = "value" ; private ElementStyle style = ElementStyle . COMPACT_NO_ARRAY ; private TrailingArrayComma comma = TrailingArrayComma . NEVER ; private ClosingParens parens = ClosingParens . NEVER ; public void setElementStyle ( final String style ) { this . style = this . getOption ( ElementStyle . class , style ) ; } public void setTrailingArrayComma ( final String comma ) { this . comma = this . getOption ( TrailingArrayComma . class , comma ) ; } public void setClosingParens ( final String parens ) { this . parens = this . getOption ( ClosingParens . class , parens ) ; } private < T extends Enum < T > > T getOption ( final Class < T > enuclass , final String string ) { try { return Enum . valueOf ( enuclass , string . trim ( ) . toUpperCase ( Locale . ENGLISH ) ) ; } catch ( final IllegalArgumentException iae ) { throw new ConversionException ( "unable to parse " + string , iae ) ; } } @ Override public int [ ] getDefaultTokens ( ) { return this . getRequiredTokens ( ) ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . ANNOTATION , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return this . getRequiredTokens ( ) ; } @ Override public void visitToken ( final DetailAST ast ) { this . checkStyleType ( ast ) ; this . checkCheckClosingParens ( ast ) ; this . checkTrailingComma ( ast ) ; } private void checkStyleType ( final DetailAST annotation ) { if ( ElementStyle . IGNORE == this . style || this . style == null ) { return ; } if ( ElementStyle . COMPACT_NO_ARRAY == this . style ) { this . checkCompactNoArrayStyle ( annotation ) ; } else if ( ElementStyle . COMPACT == this . style ) { this . checkCompactStyle ( annotation ) ; } else if ( ElementStyle . EXPANDED == this . style ) { this . checkExpandedStyle ( annotation ) ; } } private void checkExpandedStyle ( final DetailAST annotation ) { final int valuePairCount = annotation . getChildCount ( TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR ) ; if ( valuePairCount == 0 && annotation . branchContains ( TokenTypes . EXPR ) ) { this . log ( annotation . getLineNo ( ) , MSG_KEY_ANNOTATION_INCORRECT_STYLE , ElementStyle . EXPANDED ) ; } } private void checkCompactStyle ( final DetailAST annotation ) { final int valuePairCount = annotation . getChildCount ( TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR ) ; final DetailAST valuePair = annotation . findFirstToken ( TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR ) ; if ( valuePairCount == 1 && AnnotationUseStyleCheck . ANNOTATION_ELEMENT_SINGLE_NAME . equals ( valuePair . getFirstChild ( ) . getText ( ) ) ) { this . log ( annotation . getLineNo ( ) , MSG_KEY_ANNOTATION_INCORRECT_STYLE , ElementStyle . COMPACT ) ; } } private void checkCompactNoArrayStyle ( final DetailAST annotation ) { final DetailAST arrayInit = annotation . findFirstToken ( TokenTypes . ANNOTATION_ARRAY_INIT ) ; final int valuePairCount = annotation . getChildCount ( TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR ) ; final DetailAST valuePair = annotation . findFirstToken ( TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR ) ; if ( arrayInit != null && arrayInit . getChildCount ( TokenTypes . EXPR ) == 1 ) { this . log ( annotation . getLineNo ( ) , MSG_KEY_ANNOTATION_INCORRECT_STYLE , ElementStyle . COMPACT_NO_ARRAY ) ; } else if ( valuePairCount == 1 ) { final DetailAST nestedArrayInit = valuePair . findFirstToken ( TokenTypes . ANNOTATION_ARRAY_INIT ) ; if ( nestedArrayInit != null && AnnotationUseStyleCheck . ANNOTATION_ELEMENT_SINGLE_NAME . equals ( valuePair . getFirstChild ( ) . getText ( ) ) && nestedArrayInit . getChildCount ( TokenTypes . EXPR ) == 1 ) { this . log ( annotation . getLineNo ( ) , MSG_KEY_ANNOTATION_INCORRECT_STYLE , ElementStyle . COMPACT_NO_ARRAY ) ; } } } private void checkTrailingComma ( final DetailAST annotation ) { if ( TrailingArrayComma . IGNORE == this . comma || this . comma == null ) { return ; } DetailAST child = annotation . getFirstChild ( ) ; while ( child != null ) { DetailAST arrayInit = null ; if ( child . getType ( ) == TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR ) { arrayInit = child . findFirstToken ( TokenTypes . ANNOTATION_ARRAY_INIT ) ; } else if ( child . getType ( ) == TokenTypes . ANNOTATION_ARRAY_INIT ) { arrayInit = child ; } if ( arrayInit != null ) { this . logCommaViolation ( arrayInit ) ; } child = child . getNextSibling ( ) ; } } private void logCommaViolation ( final DetailAST ast ) { final DetailAST rCurly = ast . findFirstToken ( TokenTypes . RCURLY ) ; final DetailAST comma = rCurly . getPreviousSibling ( ) ; if ( TrailingArrayComma . ALWAYS == this . comma && ( comma == null || comma . getType ( ) != TokenTypes . COMMA ) ) { this . log ( rCurly . getLineNo ( ) , rCurly . getColumnNo ( ) , MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING ) ; } else if ( TrailingArrayComma . NEVER == this . comma && comma != null && comma . getType ( ) == TokenTypes . COMMA ) { this . log ( comma . getLineNo ( ) , comma . getColumnNo ( ) , MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT ) ; } } private void checkCheckClosingParens ( final DetailAST ast ) { if ( ClosingParens . IGNORE == this . parens || this . parens == null ) { return ; } final DetailAST paren = ast . getLastChild ( ) ; final boolean parenExists = paren . getType ( ) == TokenTypes . RPAREN ; if ( ClosingParens . ALWAYS == this . parens && ! parenExists ) { this . log ( ast . getLineNo ( ) , MSG_KEY_ANNOTATION_PARENS_MISSING ) ; } else if ( ClosingParens . NEVER == this . parens && ! ast . branchContains ( TokenTypes . EXPR ) && ! ast . branchContains ( TokenTypes . ANNOTATION_MEMBER_VALUE_PAIR ) && ! ast . branchContains ( TokenTypes . ANNOTATION_ARRAY_INIT ) && parenExists ) { this . log ( ast . getLineNo ( ) , MSG_KEY_ANNOTATION_PARENS_PRESENT ) ; } } public static enum ElementStyle { EXPANDED , COMPACT , COMPACT_NO_ARRAY , IGNORE , } public static enum TrailingArrayComma { ALWAYS , NEVER , IGNORE , } public static enum ClosingParens { ALWAYS , NEVER , IGNORE , } }
package com . puppycrawl . tools . checkstyle . checks . annotation ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import com . puppycrawl . tools . checkstyle . AnnotationUtility ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . JavadocTagInfo ; import com . puppycrawl . tools . checkstyle . api . TextBlock ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; public final class MissingOverrideCheck extends Check { public static final String MSG_KEY_TAG_NOT_VALID_ON = "tag.not.valid.on" ; public static final String MSG_KEY_ANNOTATION_MISSING_OVERRIDE = "annotation.missing.override" ; private static final String OVERRIDE = "Override" ; private static final String FQ_OVERRIDE = "java.lang." + OVERRIDE ; private static final Pattern MATCH_INHERITDOC = Utils . createPattern ( "\\{\\s*@(inheritDoc)\\s*\\}" ) ; private boolean javaFiveCompatibility ; public void setJavaFiveCompatibility ( final boolean compatibility ) { this . javaFiveCompatibility = compatibility ; } @ Override public int [ ] getDefaultTokens ( ) { return this . getRequiredTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return this . getRequiredTokens ( ) ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , } ; } @ Override public void visitToken ( final DetailAST ast ) { final TextBlock javadoc = this . getFileContents ( ) . getJavadocBefore ( ast . getLineNo ( ) ) ; final boolean containastag = this . containsJavadocTag ( javadoc ) ; if ( containastag && ! JavadocTagInfo . INHERIT_DOC . isValidOn ( ast ) ) { this . log ( ast . getLineNo ( ) , MSG_KEY_TAG_NOT_VALID_ON , JavadocTagInfo . INHERIT_DOC . getText ( ) ) ; return ; } if ( this . javaFiveCompatibility ) { final DetailAST defOrNew = ast . getParent ( ) . getParent ( ) ; if ( defOrNew . branchContains ( TokenTypes . EXTENDS_CLAUSE ) || defOrNew . branchContains ( TokenTypes . IMPLEMENTS_CLAUSE ) || defOrNew . getType ( ) == TokenTypes . LITERAL_NEW ) { return ; } } if ( containastag && ! AnnotationUtility . containsAnnotation ( ast , OVERRIDE ) && ! AnnotationUtility . containsAnnotation ( ast , FQ_OVERRIDE ) ) { this . log ( ast . getLineNo ( ) , MSG_KEY_ANNOTATION_MISSING_OVERRIDE ) ; } } private boolean containsJavadocTag ( final TextBlock javadoc ) { if ( javadoc == null ) { return false ; } final String [ ] lines = javadoc . getText ( ) ; for ( final String line : lines ) { final Matcher matchInheritDoc = MissingOverrideCheck . MATCH_INHERITDOC . matcher ( line ) ; if ( matchInheritDoc . find ( ) ) { return true ; } } return false ; } }
package com . puppycrawl . tools . checkstyle . checks . design ;
package com . puppycrawl . tools . checkstyle . checks . design ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public final class ThrowsCountCheck extends Check { public static final String MSG_KEY = "throws.count" ; private static final int DEFAULT_MAX = 4 ; private boolean ignorePrivateMethods = true ; private int max ; public ThrowsCountCheck ( ) { setMax ( DEFAULT_MAX ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_THROWS , } ; } @ Override public int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . LITERAL_THROWS , } ; } public int getMax ( ) { return max ; } public void setIgnorePrivateMethods ( boolean ignorePrivateMethods ) { this . ignorePrivateMethods = ignorePrivateMethods ; } public void setMax ( int max ) { this . max = max ; } @ Override public void visitToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . LITERAL_THROWS ) { visitLiteralThrows ( ast ) ; } else { throw new IllegalStateException ( ast . toString ( ) ) ; } } private void visitLiteralThrows ( DetailAST ast ) { if ( ( ! ignorePrivateMethods || ! isInPrivateMethod ( ast ) ) && ! isOverriding ( ast ) ) { final int count = ( ast . getChildCount ( ) + 1 ) / 2 ; if ( count > getMax ( ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY , count , getMax ( ) ) ; } } } private static boolean isOverriding ( DetailAST ast ) { final DetailAST modifiers = ast . getParent ( ) . findFirstToken ( TokenTypes . MODIFIERS ) ; boolean isOverriding = false ; if ( modifiers . branchContains ( TokenTypes . ANNOTATION ) ) { DetailAST child = modifiers . getFirstChild ( ) ; while ( child != null ) { if ( child . getType ( ) == TokenTypes . ANNOTATION && "Override" . equals ( getAnnotationName ( child ) ) ) { isOverriding = true ; } child = child . getNextSibling ( ) ; } } return isOverriding ; } private static String getAnnotationName ( DetailAST annotation ) { final DetailAST dotAst = annotation . findFirstToken ( TokenTypes . DOT ) ; String name ; if ( dotAst != null ) { name = dotAst . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; } else { name = annotation . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; } return name ; } private static boolean isInPrivateMethod ( DetailAST ast ) { final DetailAST methodModifiers = ast . getParent ( ) . findFirstToken ( TokenTypes . MODIFIERS ) ; return methodModifiers . findFirstToken ( TokenTypes . LITERAL_PRIVATE ) != null ; } }
package com . puppycrawl . tools . checkstyle . checks . blocks ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . blocks . AvoidNestedBlocksCheck . MSG_KEY_BLOCK_NESTED ; public class AvoidNestedBlocksCheckTest extends BaseCheckTestSupport { @ Test public void testStrictSettings ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AvoidNestedBlocksCheck . class ) ; final String [ ] expected = { "22:9: " + getCheckMessage ( MSG_KEY_BLOCK_NESTED ) , "44:17: " + getCheckMessage ( MSG_KEY_BLOCK_NESTED ) , "50:17: " + getCheckMessage ( MSG_KEY_BLOCK_NESTED ) , "58:17: " + getCheckMessage ( MSG_KEY_BLOCK_NESTED ) , } ; verify ( checkConfig , getPath ( "InputNestedBlocks.java" ) , expected ) ; } @ Test public void testAllowSwitchInCase ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AvoidNestedBlocksCheck . class ) ; checkConfig . addAttribute ( "allowInSwitchCase" , Boolean . TRUE . toString ( ) ) ; final String [ ] expected = { "22:9: " + getCheckMessage ( MSG_KEY_BLOCK_NESTED ) , "44:17: " + getCheckMessage ( MSG_KEY_BLOCK_NESTED ) , "58:17: " + getCheckMessage ( MSG_KEY_BLOCK_NESTED ) , } ; verify ( checkConfig , getPath ( "InputNestedBlocks.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . design ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class InnerTypeLastCheck extends Check { public static final String MSG_KEY = "arrangement.members.before.inner" ; private boolean rootClass = true ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF } ; } @ Override public void visitToken ( DetailAST ast ) { if ( rootClass ) { rootClass = false ; } else { DetailAST nextSibling = ast . getNextSibling ( ) ; while ( null != nextSibling ) { if ( ! ScopeUtils . inCodeBlock ( ast ) && ( nextSibling . getType ( ) == TokenTypes . VARIABLE_DEF || nextSibling . getType ( ) == TokenTypes . METHOD_DEF ) ) { log ( nextSibling . getLineNo ( ) , nextSibling . getColumnNo ( ) , MSG_KEY ) ; } nextSibling = nextSibling . getNextSibling ( ) ; } } } @ Override public void leaveToken ( DetailAST ast ) { if ( null == ast . getParent ( ) ) { rootClass = true ; } } }
package com . puppycrawl . tools . checkstyle . checks . design ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . regex . Pattern ; import antlr . collections . AST ; import com . google . common . collect . ImmutableList ; import com . puppycrawl . tools . checkstyle . AnnotationUtility ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FullIdent ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . Utils ; public class VisibilityModifierCheck extends Check { public static final String MSG_KEY = "variable.notPrivate" ; private static final List < String > DEFAULT_IMMUTABLE_TYPES = ImmutableList . of ( "java.lang.String" , "java.lang.Integer" , "java.lang.Byte" , "java.lang.Character" , "java.lang.Short" , "java.lang.Boolean" , "java.lang.Long" , "java.lang.Double" , "java.lang.Float" , "java.lang.StackTraceElement" , "java.math.BigInteger" , "java.math.BigDecimal" , "java.io.File" , "java.util.Locale" , "java.util.UUID" , "java.net.URL" , "java.net.URI" , "java.net.Inet4Address" , "java.net.Inet6Address" , "java.net.InetSocketAddress" ) ; private static final List < String > DEFAULT_IGNORE_ANNOTATIONS = ImmutableList . of ( "org.junit.Rule" , "com.google.common.annotations.VisibleForTesting" ) ; private static final String [ ] EXPLICIT_MODS = { "public" , "private" , "protected" } ; private boolean protectedAllowed ; private boolean packageAllowed ; private String publicMemberFormat = "^serialVersionUID$" ; private Pattern publicMemberPattern = Pattern . compile ( publicMemberFormat ) ; private List < String > ignoreAnnotationCanonicalNames = new ArrayList < > ( DEFAULT_IGNORE_ANNOTATIONS ) ; private List < String > ignoreAnnotationShortNames = getClassShortNames ( DEFAULT_IGNORE_ANNOTATIONS ) ; private boolean allowPublicImmutableFields = true ; private List < String > immutableClassCanonicalNames = new ArrayList < > ( DEFAULT_IMMUTABLE_TYPES ) ; private final List < String > immutableClassShortNames = getClassShortNames ( DEFAULT_IMMUTABLE_TYPES ) ; public boolean isProtectedAllowed ( ) { return protectedAllowed ; } public void setIgnoreAnnotationCanonicalNames ( String ... annotationNames ) { ignoreAnnotationCanonicalNames = Arrays . asList ( annotationNames ) ; } public void setProtectedAllowed ( boolean protectedAllowed ) { this . protectedAllowed = protectedAllowed ; } public boolean isPackageAllowed ( ) { return packageAllowed ; } public void setPackageAllowed ( boolean packageAllowed ) { this . packageAllowed = packageAllowed ; } public void setPublicMemberPattern ( String pattern ) { publicMemberPattern = Utils . createPattern ( pattern ) ; publicMemberFormat = pattern ; } private Pattern getPublicMemberRegexp ( ) { return publicMemberPattern ; } public void setAllowPublicImmutableFields ( boolean allow ) { this . allowPublicImmutableFields = allow ; } public void setImmutableClassCanonicalNames ( String ... classNames ) { immutableClassCanonicalNames = Arrays . asList ( classNames ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . IMPORT , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF , TokenTypes . OBJBLOCK , TokenTypes . IMPORT , } ; } @ Override public void beginTree ( DetailAST rootAst ) { immutableClassShortNames . clear ( ) ; final List < String > classShortNames = getClassShortNames ( immutableClassCanonicalNames ) ; immutableClassShortNames . addAll ( classShortNames ) ; ignoreAnnotationShortNames . clear ( ) ; final List < String > annotationShortNames = getClassShortNames ( ignoreAnnotationCanonicalNames ) ; ignoreAnnotationShortNames . addAll ( annotationShortNames ) ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . VARIABLE_DEF : if ( ! isAnonymousClassVariable ( ast ) ) { visitVariableDef ( ast ) ; } break ; case TokenTypes . IMPORT : visitImport ( ast ) ; break ; default : final String exceptionMsg = "Unexpected token type: " + ast . getText ( ) ; throw new IllegalArgumentException ( exceptionMsg ) ; } } private static boolean isAnonymousClassVariable ( DetailAST variableDef ) { return variableDef . getParent ( ) . getType ( ) != TokenTypes . OBJBLOCK ; } private void visitVariableDef ( DetailAST variableDef ) { final boolean inInterfaceOrAnnotationBlock = ScopeUtils . inInterfaceOrAnnotationBlock ( variableDef ) ; if ( ! inInterfaceOrAnnotationBlock && ! hasIgnoreAnnotation ( variableDef ) ) { final DetailAST varNameAST = variableDef . findFirstToken ( TokenTypes . TYPE ) . getNextSibling ( ) ; final String varName = varNameAST . getText ( ) ; if ( ! hasProperAccessModifier ( variableDef , varName ) ) { log ( varNameAST . getLineNo ( ) , varNameAST . getColumnNo ( ) , MSG_KEY , varName ) ; } } } private boolean hasIgnoreAnnotation ( DetailAST variableDef ) { final DetailAST firstIgnoreAnnotation = containsMatchingAnnotation ( variableDef ) ; return firstIgnoreAnnotation != null ; } private void visitImport ( DetailAST importAst ) { if ( ! isStarImport ( importAst ) ) { final DetailAST type = importAst . getFirstChild ( ) ; final String canonicalName = getCanonicalName ( type ) ; final String shortName = getClassShortName ( canonicalName ) ; if ( ! immutableClassCanonicalNames . contains ( canonicalName ) && immutableClassShortNames . contains ( shortName ) ) { immutableClassShortNames . remove ( shortName ) ; } if ( ! ignoreAnnotationCanonicalNames . contains ( canonicalName ) && ignoreAnnotationShortNames . contains ( shortName ) ) { ignoreAnnotationShortNames . remove ( shortName ) ; } } } private static boolean isStarImport ( DetailAST importAst ) { boolean result = false ; DetailAST toVisit = importAst ; while ( toVisit != null ) { toVisit = getNextSubTreeNode ( toVisit , importAst ) ; if ( toVisit != null && toVisit . getType ( ) == TokenTypes . STAR ) { result = true ; break ; } } return result ; } private boolean hasProperAccessModifier ( DetailAST variableDef , String variableName ) { boolean result = true ; final Set < String > mods = getModifiers ( variableDef ) ; final String variableScope = getVisibilityScope ( mods ) ; if ( ! "private" . equals ( variableScope ) ) { final DetailAST classDef = variableDef . getParent ( ) . getParent ( ) ; final Set < String > classModifiers = getModifiers ( classDef ) ; result = mods . contains ( "static" ) && mods . contains ( "final" ) || isPackageAllowed ( ) && "package" . equals ( variableScope ) || isProtectedAllowed ( ) && "protected" . equals ( variableScope ) || "public" . equals ( variableScope ) && getPublicMemberRegexp ( ) . matcher ( variableName ) . find ( ) || allowPublicImmutableFields && classModifiers . contains ( "final" ) && isImmutableField ( variableDef ) ; } return result ; } private static Set < String > getModifiers ( DetailAST defAST ) { final AST modifiersAST = defAST . findFirstToken ( TokenTypes . MODIFIERS ) ; final Set < String > modifiersSet = new HashSet < > ( ) ; if ( modifiersAST != null ) { AST modifier = modifiersAST . getFirstChild ( ) ; while ( modifier != null ) { modifiersSet . add ( modifier . getText ( ) ) ; modifier = modifier . getNextSibling ( ) ; } } return modifiersSet ; } private static String getVisibilityScope ( Set < String > modifiers ) { String accessModifier = "package" ; for ( final String modifier : EXPLICIT_MODS ) { if ( modifiers . contains ( modifier ) ) { accessModifier = modifier ; break ; } } return accessModifier ; } private boolean isImmutableField ( DetailAST variableDef ) { boolean result = false ; final DetailAST modifiers = variableDef . findFirstToken ( TokenTypes . MODIFIERS ) ; final boolean isFinal = modifiers . branchContains ( TokenTypes . FINAL ) ; if ( isFinal ) { final DetailAST type = variableDef . findFirstToken ( TokenTypes . TYPE ) ; final boolean isCanonicalName = type . getFirstChild ( ) . getType ( ) == TokenTypes . DOT ; final String typeName = getTypeName ( type , isCanonicalName ) ; result = ! isCanonicalName && isPrimitive ( type ) || immutableClassShortNames . contains ( typeName ) || isCanonicalName && immutableClassCanonicalNames . contains ( typeName ) ; } return result ; } private static String getTypeName ( DetailAST type , boolean isCanonicalName ) { String typeName = "" ; if ( isCanonicalName ) { typeName = getCanonicalName ( type ) ; } else { typeName = type . getFirstChild ( ) . getText ( ) ; } return typeName ; } private static boolean isPrimitive ( DetailAST type ) { return type . getFirstChild ( ) . getType ( ) != TokenTypes . IDENT ; } private static String getCanonicalName ( DetailAST type ) { final StringBuilder canonicalNameBuilder = new StringBuilder ( ) ; DetailAST toVisit = type . getFirstChild ( ) ; while ( toVisit != null ) { toVisit = getNextSubTreeNode ( toVisit , type ) ; if ( toVisit != null && toVisit . getType ( ) == TokenTypes . IDENT ) { canonicalNameBuilder . append ( toVisit . getText ( ) ) ; final DetailAST nextSubTreeNode = getNextSubTreeNode ( toVisit , type ) ; if ( nextSubTreeNode != null ) { canonicalNameBuilder . append ( '.' ) ; } } } return canonicalNameBuilder . toString ( ) ; } private static DetailAST getNextSubTreeNode ( DetailAST currentNodeAst , DetailAST subTreeRootAst ) { DetailAST currentNode = currentNodeAst ; DetailAST toVisitAst = currentNode . getFirstChild ( ) ; while ( toVisitAst == null ) { toVisitAst = currentNode . getNextSibling ( ) ; if ( toVisitAst == null ) { if ( currentNode . getParent ( ) . equals ( subTreeRootAst ) && currentNode . getParent ( ) . getColumnNo ( ) == subTreeRootAst . getColumnNo ( ) ) { break ; } currentNode = currentNode . getParent ( ) ; } } currentNode = toVisitAst ; return currentNode ; } private static List < String > getClassShortNames ( List < String > canonicalClassNames ) { final List < String > shortNames = new ArrayList < > ( ) ; for ( String canonicalClassName : canonicalClassNames ) { final String shortClassName = canonicalClassName . substring ( canonicalClassName . lastIndexOf ( '.' ) + 1 , canonicalClassName . length ( ) ) ; shortNames . add ( shortClassName ) ; } return shortNames ; } private static String getClassShortName ( String canonicalClassName ) { final String shortClassName = canonicalClassName . substring ( canonicalClassName . lastIndexOf ( '.' ) + 1 , canonicalClassName . length ( ) ) ; return shortClassName ; } private DetailAST containsMatchingAnnotation ( DetailAST variableDef ) { DetailAST matchingAnnotation = null ; final DetailAST holder = AnnotationUtility . getAnnotationHolder ( variableDef ) ; for ( DetailAST child = holder . getFirstChild ( ) ; child != null ; child = child . getNextSibling ( ) ) { if ( child . getType ( ) == TokenTypes . ANNOTATION ) { final DetailAST at = child . getFirstChild ( ) ; final String name = FullIdent . createFullIdent ( at . getNextSibling ( ) ) . getText ( ) ; if ( ignoreAnnotationCanonicalNames . contains ( name ) || ignoreAnnotationShortNames . contains ( name ) ) { matchingAnnotation = child ; break ; } } } return matchingAnnotation ; } }
package com . puppycrawl . tools . checkstyle . checks . design ; import java . util . Map ; import java . util . SortedMap ; import java . util . TreeMap ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class OneTopLevelClassCheck extends Check { public static final String MSG_KEY = "one.top.level.class" ; private boolean publicTypeFound ; private SortedMap < Integer , String > lineNumberTypeMap = new TreeMap < > ( ) ; @ Override public int [ ] getDefaultTokens ( ) { return getAcceptableTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { } ; } @ Override public void beginTree ( DetailAST rootAST ) { publicTypeFound = false ; lineNumberTypeMap . clear ( ) ; DetailAST currentNode = rootAST ; while ( currentNode != null ) { if ( currentNode . getType ( ) == TokenTypes . CLASS_DEF || currentNode . getType ( ) == TokenTypes . ENUM_DEF || currentNode . getType ( ) == TokenTypes . INTERFACE_DEF ) { if ( isPublic ( currentNode ) ) { publicTypeFound = true ; } else { final String typeName = currentNode . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; lineNumberTypeMap . put ( currentNode . getLineNo ( ) , typeName ) ; } } currentNode = currentNode . getNextSibling ( ) ; } } @ Override public void finishTree ( DetailAST rootAST ) { if ( ! lineNumberTypeMap . isEmpty ( ) ) { if ( ! publicTypeFound ) { lineNumberTypeMap . remove ( lineNumberTypeMap . firstKey ( ) ) ; } for ( Map . Entry < Integer , String > entry : lineNumberTypeMap . entrySet ( ) ) { log ( entry . getKey ( ) , MSG_KEY , entry . getValue ( ) ) ; } } } private boolean isPublic ( DetailAST typeDef ) { final DetailAST modifiers = typeDef . findFirstToken ( TokenTypes . MODIFIERS ) ; return modifiers . findFirstToken ( TokenTypes . LITERAL_PUBLIC ) != null ; } }
package com . puppycrawl . tools . checkstyle . checks . design ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . Scope ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class DesignForExtensionCheck extends Check { public static final String MSG_KEY = "design.forExtension" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF } ; } @ Override public void visitToken ( DetailAST ast ) { if ( ScopeUtils . inInterfaceOrAnnotationBlock ( ast ) ) { return ; } if ( isPrivateOrFinalOrAbstract ( ast ) ) { return ; } if ( ! ScopeUtils . getSurroundingScope ( ast ) . isIn ( Scope . PROTECTED ) ) { return ; } final DetailAST implementation = ast . findFirstToken ( TokenTypes . SLIST ) ; if ( implementation != null && implementation . getFirstChild ( ) . getType ( ) == TokenTypes . RCURLY ) { return ; } final DetailAST classDef = findContainingClass ( ast ) ; final DetailAST classMods = classDef . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( classDef . getType ( ) == TokenTypes . ENUM_DEF || classMods . branchContains ( TokenTypes . FINAL ) ) { return ; } if ( hasDefaultOrExplNonPrivateCtor ( classDef ) ) { final String name = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY , name ) ; } } private boolean isPrivateOrFinalOrAbstract ( DetailAST ast ) { final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; return modifiers . branchContains ( TokenTypes . LITERAL_PRIVATE ) || modifiers . branchContains ( TokenTypes . ABSTRACT ) || modifiers . branchContains ( TokenTypes . FINAL ) || modifiers . branchContains ( TokenTypes . LITERAL_STATIC ) ; } private boolean hasDefaultOrExplNonPrivateCtor ( DetailAST classDef ) { final DetailAST objBlock = classDef . findFirstToken ( TokenTypes . OBJBLOCK ) ; boolean hasDefaultConstructor = true ; boolean hasExplNonPrivateCtor = false ; DetailAST candidate = objBlock . getFirstChild ( ) ; while ( candidate != null ) { if ( candidate . getType ( ) == TokenTypes . CTOR_DEF ) { hasDefaultConstructor = false ; final DetailAST ctorMods = candidate . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( ! ctorMods . branchContains ( TokenTypes . LITERAL_PRIVATE ) ) { hasExplNonPrivateCtor = true ; break ; } } candidate = candidate . getNextSibling ( ) ; } return hasDefaultConstructor || hasExplNonPrivateCtor ; } private DetailAST findContainingClass ( DetailAST ast ) { DetailAST searchAST = ast ; while ( searchAST . getType ( ) != TokenTypes . CLASS_DEF && searchAST . getType ( ) != TokenTypes . ENUM_DEF ) { searchAST = searchAST . getParent ( ) ; } return searchAST ; } }
package com . puppycrawl . tools . checkstyle . checks . design ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public final class InterfaceIsTypeCheck extends Check { public static final String MSG_KEY = "interface.type" ; private boolean allowMarkerInterfaces = true ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . INTERFACE_DEF } ; } @ Override public int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . INTERFACE_DEF } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST objBlock = ast . findFirstToken ( TokenTypes . OBJBLOCK ) ; final DetailAST methodDef = objBlock . findFirstToken ( TokenTypes . METHOD_DEF ) ; final DetailAST variableDef = objBlock . findFirstToken ( TokenTypes . VARIABLE_DEF ) ; final boolean methodRequired = ! allowMarkerInterfaces || variableDef != null ; if ( methodDef == null && methodRequired ) { log ( ast . getLineNo ( ) , MSG_KEY ) ; } } public void setAllowMarkerInterfaces ( boolean flag ) { allowMarkerInterfaces = flag ; } }
package com . puppycrawl . tools . checkstyle . checks . design ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class HideUtilityClassConstructorCheck extends Check { public static final String MSG_KEY = "hide.utility.class" ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF } ; } @ Override public void visitToken ( DetailAST ast ) { if ( isAbstract ( ast ) ) { return ; } final boolean hasStaticModifier = isStatic ( ast ) ; final Details details = new Details ( ast ) ; details . invoke ( ) ; final boolean hasDefaultCtor = details . isHasDefaultCtor ( ) ; final boolean hasPublicCtor = details . isHasPublicCtor ( ) ; final boolean hasMethodOrField = details . isHasMethodOrField ( ) ; final boolean hasNonStaticMethodOrField = details . isHasNonStaticMethodOrField ( ) ; final boolean hasNonPrivateStaticMethodOrField = details . isHasNonPrivateStaticMethodOrField ( ) ; final boolean hasAccessibleCtor = hasDefaultCtor || hasPublicCtor ; final boolean extendsJLO = ast . findFirstToken ( TokenTypes . EXTENDS_CLAUSE ) == null ; final boolean isUtilClass = extendsJLO && hasMethodOrField && ! hasNonStaticMethodOrField && hasNonPrivateStaticMethodOrField ; if ( isUtilClass && hasAccessibleCtor && ! hasStaticModifier ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY ) ; } } private boolean isAbstract ( DetailAST ast ) { return ast . findFirstToken ( TokenTypes . MODIFIERS ) . branchContains ( TokenTypes . ABSTRACT ) ; } private boolean isStatic ( DetailAST ast ) { return ast . findFirstToken ( TokenTypes . MODIFIERS ) . branchContains ( TokenTypes . LITERAL_STATIC ) ; } private static class Details { private DetailAST ast ; private boolean hasMethodOrField ; private boolean hasNonStaticMethodOrField ; private boolean hasNonPrivateStaticMethodOrField ; private boolean hasDefaultCtor ; private boolean hasPublicCtor ; public Details ( DetailAST ast ) { this . ast = ast ; } public boolean isHasMethodOrField ( ) { return hasMethodOrField ; } public boolean isHasNonStaticMethodOrField ( ) { return hasNonStaticMethodOrField ; } public boolean isHasNonPrivateStaticMethodOrField ( ) { return hasNonPrivateStaticMethodOrField ; } public boolean isHasDefaultCtor ( ) { return hasDefaultCtor ; } public boolean isHasPublicCtor ( ) { return hasPublicCtor ; } public void invoke ( ) { final DetailAST objBlock = ast . findFirstToken ( TokenTypes . OBJBLOCK ) ; DetailAST child = objBlock . getFirstChild ( ) ; hasMethodOrField = false ; hasNonStaticMethodOrField = false ; hasNonPrivateStaticMethodOrField = false ; hasDefaultCtor = true ; hasPublicCtor = false ; while ( child != null ) { final int type = child . getType ( ) ; if ( type == TokenTypes . METHOD_DEF || type == TokenTypes . VARIABLE_DEF ) { hasMethodOrField = true ; final DetailAST modifiers = child . findFirstToken ( TokenTypes . MODIFIERS ) ; final boolean isStatic = modifiers . branchContains ( TokenTypes . LITERAL_STATIC ) ; final boolean isPrivate = modifiers . branchContains ( TokenTypes . LITERAL_PRIVATE ) ; if ( ! isStatic ) { hasNonStaticMethodOrField = true ; } if ( isStatic && ! isPrivate ) { hasNonPrivateStaticMethodOrField = true ; } } if ( type == TokenTypes . CTOR_DEF ) { hasDefaultCtor = false ; final DetailAST modifiers = child . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( ! modifiers . branchContains ( TokenTypes . LITERAL_PRIVATE ) && ! modifiers . branchContains ( TokenTypes . LITERAL_PROTECTED ) ) { hasPublicCtor = true ; } } child = child . getNextSibling ( ) ; } } } }
package com . puppycrawl . tools . checkstyle . checks . design ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . ArrayDeque ; import java . util . Deque ; public class FinalClassCheck extends Check { public static final String MSG_KEY = "final.class" ; private final Deque < ClassDesc > classes = new ArrayDeque < > ( ) ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . CTOR_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . CTOR_DEF } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( ast . getType ( ) == TokenTypes . CLASS_DEF ) { final boolean isFinal = modifiers . branchContains ( TokenTypes . FINAL ) ; final boolean isAbstract = modifiers . branchContains ( TokenTypes . ABSTRACT ) ; classes . push ( new ClassDesc ( isFinal , isAbstract ) ) ; } else if ( ! ScopeUtils . inEnumBlock ( ast ) ) { final ClassDesc desc = classes . peek ( ) ; if ( modifiers . branchContains ( TokenTypes . LITERAL_PRIVATE ) ) { desc . reportPrivateCtor ( ) ; } else { desc . reportNonPrivateCtor ( ) ; } } } @ Override public void leaveToken ( DetailAST ast ) { if ( ast . getType ( ) != TokenTypes . CLASS_DEF ) { return ; } final ClassDesc desc = classes . pop ( ) ; if ( ! desc . isDeclaredAsFinal ( ) && ! desc . isDeclaredAsAbstract ( ) && desc . isWithPrivateCtor ( ) && ! desc . isWithNonPrivateCtor ( ) ) { final String className = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; log ( ast . getLineNo ( ) , MSG_KEY , className ) ; } } private static final class ClassDesc { private final boolean declaredAsFinal ; private final boolean declaredAsAbstract ; private boolean withNonPrivateCtor ; private boolean withPrivateCtor ; ClassDesc ( boolean declaredAsFinal , boolean declaredAsAbstract ) { this . declaredAsFinal = declaredAsFinal ; this . declaredAsAbstract = declaredAsAbstract ; } void reportPrivateCtor ( ) { withPrivateCtor = true ; } void reportNonPrivateCtor ( ) { withNonPrivateCtor = true ; } boolean isWithPrivateCtor ( ) { return withPrivateCtor ; } boolean isWithNonPrivateCtor ( ) { return withNonPrivateCtor ; } boolean isDeclaredAsFinal ( ) { return declaredAsFinal ; } boolean isDeclaredAsAbstract ( ) { return declaredAsAbstract ; } } }
package com . puppycrawl . tools . checkstyle . checks . design ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . checks . AbstractFormatCheck ; import java . util . ArrayDeque ; import java . util . Deque ; public final class MutableExceptionCheck extends AbstractFormatCheck { public static final String MSG_KEY = "mutable.exception" ; private static final String DEFAULT_FORMAT = "^.*Exception$|^.*Error$|^.*Throwable$" ; private String extendedClassNameFormat ; private final Deque < Boolean > checkingStack = new ArrayDeque < > ( ) ; private boolean checking ; public MutableExceptionCheck ( ) { super ( DEFAULT_FORMAT ) ; setExtendedClassNameFormat ( DEFAULT_FORMAT ) ; } public void setExtendedClassNameFormat ( String extendedClassNameFormat ) { this . extendedClassNameFormat = extendedClassNameFormat ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . VARIABLE_DEF } ; } @ Override public int [ ] getRequiredTokens ( ) { return getDefaultTokens ( ) ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . VARIABLE_DEF } ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CLASS_DEF : visitClassDef ( ast ) ; break ; case TokenTypes . VARIABLE_DEF : visitVariableDef ( ast ) ; break ; default : throw new IllegalStateException ( ast . toString ( ) ) ; } } @ Override public void leaveToken ( DetailAST ast ) { if ( ast . getType ( ) == TokenTypes . CLASS_DEF ) { leaveClassDef ( ) ; } } private void visitClassDef ( DetailAST ast ) { checkingStack . push ( checking ? Boolean . TRUE : Boolean . FALSE ) ; checking = isNamedAsException ( ast ) && isExtendedClassNamedAsException ( ast ) ; } private void leaveClassDef ( ) { checking = checkingStack . pop ( ) ; } private void visitVariableDef ( DetailAST ast ) { if ( checking && ast . getParent ( ) . getType ( ) == TokenTypes . OBJBLOCK ) { final DetailAST modifiersAST = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; if ( modifiersAST . findFirstToken ( TokenTypes . FINAL ) == null ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY , ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ) ; } } } private boolean isNamedAsException ( DetailAST ast ) { final String className = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; return getRegexp ( ) . matcher ( className ) . find ( ) ; } private boolean isExtendedClassNamedAsException ( DetailAST ast ) { final DetailAST extendsClause = ast . findFirstToken ( TokenTypes . EXTENDS_CLAUSE ) ; if ( extendsClause != null ) { DetailAST currentNode = extendsClause ; while ( currentNode . getType ( ) != TokenTypes . IDENT ) { currentNode = currentNode . getLastChild ( ) ; } final String extendedClassName = currentNode . getText ( ) ; return extendedClassName . matches ( extendedClassNameFormat ) ; } return false ; } }
package com . puppycrawl . tools . checkstyle . checks . regexp ;
package com . puppycrawl . tools . checkstyle . checks . regexp ; import com . puppycrawl . tools . checkstyle . api . AbstractViolationReporter ; import java . util . regex . Pattern ; class DetectorOptions { private final int compileFlags ; private final AbstractViolationReporter reporter ; private String format = "$." ; private String message = "" ; private int minimum ; private int maximum ; private boolean ignoreCase ; private MatchSuppressor suppressor = NeverSuppress . INSTANCE ; public DetectorOptions ( int compileFlags , AbstractViolationReporter reporter ) { this . compileFlags = compileFlags ; this . reporter = reporter ; } public DetectorOptions setFormat ( String format ) { this . format = format ; return this ; } public DetectorOptions setMessage ( String message ) { this . message = message ; return this ; } public DetectorOptions setMinimum ( int minimum ) { this . minimum = minimum ; return this ; } public DetectorOptions setMaximum ( int maximum ) { this . maximum = maximum ; return this ; } public DetectorOptions setSuppressor ( MatchSuppressor sup ) { suppressor = sup ; return this ; } public DetectorOptions setIgnoreCase ( boolean ignore ) { ignoreCase = ignore ; return this ; } public String getFormat ( ) { return format ; } public AbstractViolationReporter getReporter ( ) { return reporter ; } public String getMessage ( ) { return message ; } public int getMinimum ( ) { return minimum ; } public int getMaximum ( ) { return maximum ; } public MatchSuppressor getSuppressor ( ) { return suppressor ; } public boolean isIgnoreCase ( ) { return ignoreCase ; } public Pattern getPattern ( ) { final int options = ignoreCase ? compileFlags | Pattern . CASE_INSENSITIVE : compileFlags ; return Pattern . compile ( format , options ) ; } }
package com . puppycrawl . tools . checkstyle . checks . blocks ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class EmptyCatchBlockCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( EmptyCatchBlockCheck . class ) ; final String [ ] expected = { "35: Empty catch block." , "42: Empty catch block." , } ; verify ( checkConfig , getPath ( "InputEmptyCatchBlockCheck.java" ) , expected ) ; } @ Test public void testWithUserSetValues ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( EmptyCatchBlockCheck . class ) ; checkConfig . addAttribute ( "exceptionVariableName" , "expected|ignore|myException" ) ; checkConfig . addAttribute ( "commentFormat" , "This is expected" ) ; final String [ ] expected = { "35: Empty catch block." , "63: Empty catch block." , "97: Empty catch block." , "186: Empty catch block." , "195: Empty catch block." , "214: Empty catch block." , "230: Empty catch block." , } ; verify ( checkConfig , getPath ( "InputEmptyCatchBlockCheck.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . regexp ; import com . puppycrawl . tools . checkstyle . api . FileContents ; class CommentSuppressor implements MatchSuppressor { private FileContents currentContents ; public boolean shouldSuppress ( int startLineNo , int startColNo , int endLineNo , int endColNo ) { return null != currentContents && currentContents . hasIntersectionWithComment ( startLineNo , startColNo , endLineNo , endColNo ) ; } public void setCurrentContents ( FileContents currentContents ) { this . currentContents = currentContents ; } }
package com . puppycrawl . tools . checkstyle . checks . regexp ; import com . puppycrawl . tools . checkstyle . api . AbstractFileSetCheck ; import java . io . File ; import java . util . List ; public class RegexpSinglelineCheck extends AbstractFileSetCheck { private DetectorOptions options = new DetectorOptions ( 0 , this ) ; private SinglelineDetector detector ; @ Override public void beginProcessing ( String charset ) { super . beginProcessing ( charset ) ; detector = new SinglelineDetector ( options ) ; } @ Override protected void processFiltered ( File file , List < String > lines ) { detector . processLines ( lines ) ; } public void setFormat ( String format ) { options . setFormat ( format ) ; } public void setMessage ( String message ) { options . setMessage ( message ) ; } public void setMinimum ( int minimum ) { options . setMinimum ( minimum ) ; } public void setMaximum ( int maximum ) { options . setMaximum ( maximum ) ; } public void setIgnoreCase ( boolean ignore ) { options . setIgnoreCase ( ignore ) ; } }
package com . puppycrawl . tools . checkstyle . checks . regexp ; public final class NeverSuppress implements MatchSuppressor { public static final MatchSuppressor INSTANCE = new NeverSuppress ( ) ; private NeverSuppress ( ) { } public boolean shouldSuppress ( int startLineNo , int startColNo , int endLineNo , int endColNo ) { return false ; } }
package com . puppycrawl . tools . checkstyle . checks . regexp ; interface MatchSuppressor { boolean shouldSuppress ( int startLineNo , int startColNo , int endLineNo , int endColNo ) ; }
package com . puppycrawl . tools . checkstyle . checks . regexp ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import java . util . Arrays ; public class RegexpSinglelineJavaCheck extends Check { private DetectorOptions options = new DetectorOptions ( 0 , this ) ; private SinglelineDetector detector ; private final CommentSuppressor suppressor = new CommentSuppressor ( ) ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ 0 ] ; } @ Override public void init ( ) { super . init ( ) ; detector = new SinglelineDetector ( options ) ; } @ Override public void beginTree ( DetailAST rootAST ) { suppressor . setCurrentContents ( getFileContents ( ) ) ; detector . processLines ( Arrays . asList ( getLines ( ) ) ) ; } public void setFormat ( String format ) { options . setFormat ( format ) ; } public void setMessage ( String message ) { options . setMessage ( message ) ; } public void setMinimum ( int minimum ) { options . setMinimum ( minimum ) ; } public void setMaximum ( int maximum ) { options . setMaximum ( maximum ) ; } public void setIgnoreCase ( boolean ignore ) { options . setIgnoreCase ( ignore ) ; } public void setIgnoreComments ( boolean ignore ) { if ( ignore ) { options . setSuppressor ( suppressor ) ; } else { options . setSuppressor ( NeverSuppress . INSTANCE ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . regexp ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FileContents ; import com . puppycrawl . tools . checkstyle . api . FileText ; import com . puppycrawl . tools . checkstyle . api . LineColumn ; import com . puppycrawl . tools . checkstyle . checks . AbstractFormatCheck ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class RegexpCheck extends AbstractFormatCheck { public static final String MSG_ILLEGAL_REGEXP = "illegal.regexp" ; public static final String MSG_REQUIRED_REGEXP = "required.regexp" ; public static final String MSG_DUPLICATE_REGEXP = "duplicate.regexp" ; private static final int DEFAULT_DUPLICATE_LIMIT = - 1 ; private static final int DEFAULT_ERROR_LIMIT = 100 ; private static final String ERROR_LIMIT_EXCEEDED_MESSAGE = "The error limit has been exceeded, " + "the check is aborting, there may be more unreported errors." ; private String message = "" ; private boolean ignoreComments ; private boolean illegalPattern ; private int errorLimit = DEFAULT_ERROR_LIMIT ; private int duplicateLimit ; private boolean checkForDuplicates ; private int matchCount ; private int errorCount ; private Matcher matcher ; public RegexpCheck ( ) { super ( "$^" , Pattern . MULTILINE ) ; } public void setMessage ( String message ) { this . message = message == null ? "" : message ; } public String getMessage ( ) { return message ; } public void setIgnoreComments ( boolean ignoreComments ) { this . ignoreComments = ignoreComments ; } public void setIllegalPattern ( boolean illegalPattern ) { this . illegalPattern = illegalPattern ; } public void setErrorLimit ( int errorLimit ) { this . errorLimit = errorLimit ; } public void setDuplicateLimit ( int duplicateLimit ) { this . duplicateLimit = duplicateLimit ; checkForDuplicates = duplicateLimit > DEFAULT_DUPLICATE_LIMIT ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ 0 ] ; } @ Override public void beginTree ( DetailAST rootAST ) { final Pattern pattern = getRegexp ( ) ; matcher = pattern . matcher ( getFileContents ( ) . getText ( ) . getFullText ( ) ) ; matchCount = 0 ; errorCount = 0 ; findMatch ( ) ; } private void findMatch ( ) { int startLine ; boolean foundMatch ; boolean ignore = false ; foundMatch = matcher . find ( ) ; if ( foundMatch ) { final FileText text = getFileContents ( ) . getText ( ) ; final LineColumn start = text . lineColumn ( matcher . start ( ) ) ; startLine = start . getLine ( ) ; ignore = isIgnore ( startLine , text , start ) ; if ( ! ignore ) { matchCount ++ ; if ( illegalPattern || checkForDuplicates && matchCount - 1 > duplicateLimit ) { errorCount ++ ; logMessage ( startLine ) ; } } if ( canContinueValidation ( ignore ) ) { findMatch ( ) ; } } else if ( ! illegalPattern && matchCount == 0 ) { logMessage ( 0 ) ; } } private boolean canContinueValidation ( boolean ignore ) { return errorCount < errorLimit && ( ignore || illegalPattern || checkForDuplicates ) ; } private boolean isIgnore ( int startLine , FileText text , LineColumn start ) { int startColumn ; boolean ignore = false ; int endLine ; int endColumn ; final LineColumn end ; if ( matcher . end ( ) == 0 ) { end = text . lineColumn ( 0 ) ; } else { end = text . lineColumn ( matcher . end ( ) - 1 ) ; } startColumn = start . getColumn ( ) ; endLine = end . getLine ( ) ; endColumn = end . getColumn ( ) ; if ( ignoreComments ) { final FileContents theFileContents = getFileContents ( ) ; ignore = theFileContents . hasIntersectionWithComment ( startLine , startColumn , endLine , endColumn ) ; } return ignore ; } private void logMessage ( int lineNumber ) { String msg = "" . equals ( getMessage ( ) ) ? getFormat ( ) : message ; if ( errorCount >= errorLimit ) { msg = ERROR_LIMIT_EXCEEDED_MESSAGE + msg ; } if ( illegalPattern ) { log ( lineNumber , MSG_ILLEGAL_REGEXP , msg ) ; } else { if ( lineNumber > 0 ) { log ( lineNumber , MSG_DUPLICATE_REGEXP , msg ) ; } else { log ( lineNumber , MSG_REQUIRED_REGEXP , msg ) ; } } } }
package com . puppycrawl . tools . checkstyle . checks . regexp ; import java . util . List ; import java . util . regex . Matcher ; class SinglelineDetector { private final DetectorOptions options ; private int currentMatches ; public SinglelineDetector ( DetectorOptions options ) { this . options = options ; } public void processLines ( List < String > lines ) { resetState ( ) ; int lineno = 0 ; for ( String line : lines ) { lineno ++ ; checkLine ( lineno , line , options . getPattern ( ) . matcher ( line ) , 0 ) ; } finish ( ) ; } private void finish ( ) { if ( currentMatches < options . getMinimum ( ) ) { if ( "" . equals ( options . getMessage ( ) ) ) { options . getReporter ( ) . log ( 0 , "regexp.minimum" , options . getMinimum ( ) , options . getFormat ( ) ) ; } else { options . getReporter ( ) . log ( 0 , options . getMessage ( ) ) ; } } } private void resetState ( ) { currentMatches = 0 ; } private void checkLine ( int lineno , String line , Matcher matcher , int startPosition ) { final boolean foundMatch = matcher . find ( startPosition ) ; if ( ! foundMatch ) { return ; } final int startCol = matcher . start ( 0 ) ; final int endCol = matcher . end ( 0 ) ; if ( options . getSuppressor ( ) . shouldSuppress ( lineno , startCol , lineno , endCol - 1 ) ) { if ( endCol < line . length ( ) ) { checkLine ( lineno , line , matcher , endCol ) ; } return ; } currentMatches ++ ; if ( currentMatches > options . getMaximum ( ) ) { if ( "" . equals ( options . getMessage ( ) ) ) { options . getReporter ( ) . log ( lineno , "regexp.exceeded" , matcher . pattern ( ) . toString ( ) ) ; } else { options . getReporter ( ) . log ( lineno , options . getMessage ( ) ) ; } } } }
package com . puppycrawl . tools . checkstyle . checks . regexp ; import java . util . regex . Matcher ; import com . google . common . base . Strings ; import com . puppycrawl . tools . checkstyle . api . FileText ; import com . puppycrawl . tools . checkstyle . api . LineColumn ; class MultilineDetector { public static final String REGEXP_EXCEEDED = "regexp.exceeded" ; public static final String REGEXP_MINIMUM = "regexp.minimum" ; public static final String EMPTY = "regexp.empty" ; public static final String STACKOVERFLOW = "regexp.StackOverflowError" ; private final DetectorOptions options ; private int currentMatches ; private Matcher matcher ; private FileText text ; public MultilineDetector ( DetectorOptions options ) { this . options = options ; } public void processLines ( FileText text ) { this . text = text ; resetState ( ) ; if ( ! Strings . isNullOrEmpty ( options . getFormat ( ) ) ) { matcher = options . getPattern ( ) . matcher ( text . getFullText ( ) ) ; findMatch ( ) ; finish ( ) ; } else { options . getReporter ( ) . log ( 0 , EMPTY ) ; } } private void findMatch ( ) { try { boolean foundMatch = matcher . find ( ) ; while ( foundMatch ) { final LineColumn start = text . lineColumn ( matcher . start ( ) ) ; final LineColumn end = text . lineColumn ( matcher . end ( ) ) ; if ( ! options . getSuppressor ( ) . shouldSuppress ( start . getLine ( ) , start . getColumn ( ) , end . getLine ( ) , end . getColumn ( ) ) ) { currentMatches ++ ; if ( currentMatches > options . getMaximum ( ) ) { if ( "" . equals ( options . getMessage ( ) ) ) { options . getReporter ( ) . log ( start . getLine ( ) , REGEXP_EXCEEDED , matcher . pattern ( ) . toString ( ) ) ; } else { options . getReporter ( ) . log ( start . getLine ( ) , options . getMessage ( ) ) ; } } } foundMatch = matcher . find ( ) ; } } catch ( StackOverflowError e ) { options . getReporter ( ) . log ( 0 , STACKOVERFLOW , matcher . pattern ( ) . toString ( ) ) ; return ; } } private void finish ( ) { if ( currentMatches < options . getMinimum ( ) ) { if ( "" . equals ( options . getMessage ( ) ) ) { options . getReporter ( ) . log ( 0 , REGEXP_MINIMUM , options . getMinimum ( ) , options . getFormat ( ) ) ; } else { options . getReporter ( ) . log ( 0 , options . getMessage ( ) ) ; } } } private void resetState ( ) { currentMatches = 0 ; } }
package com . puppycrawl . tools . checkstyle . checks . regexp ; import java . util . regex . Pattern ; import com . puppycrawl . tools . checkstyle . api . AbstractFileSetCheck ; import com . puppycrawl . tools . checkstyle . api . FileText ; import java . io . File ; import java . util . List ; public class RegexpMultilineCheck extends AbstractFileSetCheck { private DetectorOptions options = new DetectorOptions ( Pattern . MULTILINE , this ) ; private MultilineDetector detector ; @ Override public void beginProcessing ( String charset ) { super . beginProcessing ( charset ) ; detector = new MultilineDetector ( options ) ; } @ Override protected void processFiltered ( File file , List < String > lines ) { detector . processLines ( FileText . fromLines ( file , lines ) ) ; } public void setFormat ( String format ) { options . setFormat ( format ) ; } public void setMessage ( String message ) { options . setMessage ( message ) ; } public void setMinimum ( int minimum ) { options . setMinimum ( minimum ) ; } public void setMaximum ( int maximum ) { options . setMaximum ( maximum ) ; } public void setIgnoreCase ( boolean ignore ) { options . setIgnoreCase ( ignore ) ; } }
package com . puppycrawl . tools . checkstyle . checks . header ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; import java . io . Reader ; import java . io . StringReader ; import java . io . UnsupportedEncodingException ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; import java . nio . charset . Charset ; import java . util . List ; import com . google . common . io . Closeables ; import org . apache . commons . beanutils . ConversionException ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . api . AbstractFileSetCheck ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import org . apache . commons . lang3 . StringUtils ; public abstract class AbstractHeaderCheck extends AbstractFileSetCheck { private String filename ; private String charset = System . getProperty ( "file.encoding" , "UTF-8" ) ; private final List < String > readerLines = Lists . newArrayList ( ) ; protected ImmutableList < String > getHeaderLines ( ) { return ImmutableList . copyOf ( readerLines ) ; } public void setCharset ( String charset ) throws UnsupportedEncodingException { if ( ! Charset . isSupported ( charset ) ) { final String message = "unsupported charset: '" + charset + "'" ; throw new UnsupportedEncodingException ( message ) ; } this . charset = charset ; } public void setHeaderFile ( String fileName ) { if ( StringUtils . isBlank ( fileName ) ) { return ; } filename = fileName ; } private void loadHeaderFile ( ) throws CheckstyleException { checkHeaderNotInitialized ( ) ; Reader headerReader = null ; try { final URI uri = resolveHeaderFile ( ) ; headerReader = new InputStreamReader ( new BufferedInputStream ( uri . toURL ( ) . openStream ( ) ) , charset ) ; loadHeader ( headerReader ) ; } catch ( final IOException ex ) { throw new CheckstyleException ( "unable to load header file " + filename , ex ) ; } finally { Closeables . closeQuietly ( headerReader ) ; } } private URI resolveHeaderFile ( ) throws IOException { URI uri ; try { final URL url = new URL ( filename ) ; uri = url . toURI ( ) ; } catch ( final MalformedURLException ex ) { uri = null ; } catch ( final URISyntaxException ex ) { uri = null ; } if ( uri == null ) { final File file = new File ( filename ) ; if ( file . exists ( ) ) { uri = file . toURI ( ) ; } else { try { final URL configUrl = AbstractHeaderCheck . class . getResource ( filename ) ; if ( configUrl == null ) { throw new FileNotFoundException ( filename ) ; } uri = configUrl . toURI ( ) ; } catch ( final URISyntaxException e ) { throw new FileNotFoundException ( filename ) ; } } } return uri ; } private void checkHeaderNotInitialized ( ) { if ( ! readerLines . isEmpty ( ) ) { throw new ConversionException ( "header has already been set - " + "set either header or headerFile, not both" ) ; } } public void setHeader ( String header ) { if ( StringUtils . isBlank ( header ) ) { return ; } checkHeaderNotInitialized ( ) ; final String headerExpandedNewLines = header . replaceAll ( "\\\\n" , "\n" ) ; final Reader headerReader = new StringReader ( headerExpandedNewLines ) ; try { loadHeader ( headerReader ) ; } catch ( final IOException ex ) { throw new ConversionException ( "unable to load header" , ex ) ; } finally { Closeables . closeQuietly ( headerReader ) ; } } private void loadHeader ( final Reader headerReader ) throws IOException { final LineNumberReader lnr = new LineNumberReader ( headerReader ) ; readerLines . clear ( ) ; while ( true ) { final String l = lnr . readLine ( ) ; if ( l == null ) { break ; } readerLines . add ( l ) ; } postprocessHeaderLines ( ) ; } protected void postprocessHeaderLines ( ) { } @ Override protected final void finishLocalSetup ( ) throws CheckstyleException { if ( filename != null ) { loadHeaderFile ( ) ; } if ( readerLines . isEmpty ( ) ) { throw new CheckstyleException ( "property 'headerFile' is missing or invalid in module " + getConfiguration ( ) . getName ( ) ) ; } } }
package com . puppycrawl . tools . checkstyle . checks . blocks ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Before ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . blocks . LeftCurlyCheck . MSG_KEY_LINE_BREAK_AFTER ; import static com . puppycrawl . tools . checkstyle . checks . blocks . LeftCurlyCheck . MSG_KEY_LINE_NEW ; import static com . puppycrawl . tools . checkstyle . checks . blocks . LeftCurlyCheck . MSG_KEY_LINE_PREVIOUS ; public class LeftCurlyCheckTest extends BaseCheckTestSupport { private DefaultConfiguration checkConfig ; @ Before public void setUp ( ) { checkConfig = createCheckConfig ( LeftCurlyCheck . class ) ; } @ Test public void testDefault ( ) throws Exception { final String [ ] expected = { "8:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "12:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "21:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "30:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "39:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , } ; verify ( checkConfig , getPath ( "InputScopeInnerInterfaces.java" ) , expected ) ; } @ Test public void testNL ( ) throws Exception { checkConfig . addAttribute ( "option" , LeftCurlyOption . NL . toString ( ) ) ; final String [ ] expected = { "49:14: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "53:14: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "58:18: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "62:18: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "67:12: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "72:18: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , } ; verify ( checkConfig , getPath ( "InputScopeInnerInterfaces.java" ) , expected ) ; } @ Test public void testNLOW ( ) throws Exception { checkConfig . addAttribute ( "option" , LeftCurlyOption . NLOW . toString ( ) ) ; final String [ ] expected = { "8:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "12:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "21:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "30:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "39:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "49:14: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "53:14: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "58:18: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "62:18: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "67:12: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "72:18: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , } ; verify ( checkConfig , getPath ( "InputScopeInnerInterfaces.java" ) , expected ) ; } @ Test public void testDefault2 ( ) throws Exception { final String [ ] expected = { "12:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "17:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "24:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "31:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "39:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "41:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "46:9: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "53:9: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "69:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "77:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "84:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , } ; verify ( checkConfig , getPath ( "InputLeftCurlyMethod.java" ) , expected ) ; } @ Test public void testNL2 ( ) throws Exception { checkConfig . addAttribute ( "option" , LeftCurlyOption . NL . toString ( ) ) ; final String [ ] expected = { "14:39: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "21:20: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "34:31: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "43:24: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "56:35: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "60:24: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "74:20: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "87:31: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , } ; verify ( checkConfig , getPath ( "InputLeftCurlyMethod.java" ) , expected ) ; } @ Test public void testDefault3 ( ) throws Exception { final String [ ] expected = { "12:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "15:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "19:9: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "21:13: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "23:17: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "30:17: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "34:17: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "42:13: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "46:13: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "52:9: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "54:13: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "63:9: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "76:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "83:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "89:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "97:19: " + getCheckMessage ( MSG_KEY_LINE_BREAK_AFTER , "{" ) , "106:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "109:9: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "118:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "120:9: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "129:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "131:9: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "133:17: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "148:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "157:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "164:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , } ; verify ( checkConfig , getPath ( "InputLeftCurlyOther.java" ) , expected ) ; } @ Test public void testNL3 ( ) throws Exception { checkConfig . addAttribute ( "option" , LeftCurlyOption . NL . toString ( ) ) ; final String [ ] expected = { "26:33: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "91:19: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "97:19: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "142:37: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "158:12: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "165:16: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , } ; verify ( checkConfig , getPath ( "InputLeftCurlyOther.java" ) , expected ) ; } @ Test public void testMissingBraces ( ) throws Exception { final String [ ] expected = { "12:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "15:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "21:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "34:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "51:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "69:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "105:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , } ; verify ( checkConfig , getPath ( "InputBraces.java" ) , expected ) ; } @ Test public void testDefaultWithAnnotations ( ) throws Exception { final String [ ] expected = { "10:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "14:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "21:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , } ; verify ( checkConfig , getPath ( "InputLeftCurlyAnnotations.java" ) , expected ) ; } @ Test public void testNLWithAnnotations ( ) throws Exception { checkConfig . addAttribute ( "option" , LeftCurlyOption . NL . toString ( ) ) ; final String [ ] expected = { "35:34: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "38:41: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "44:27: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , "58:32: " + getCheckMessage ( MSG_KEY_LINE_NEW , "{" ) , } ; verify ( checkConfig , getPath ( "InputLeftCurlyAnnotations.java" ) , expected ) ; } @ Test public void testLineBreakAfter ( ) throws Exception { checkConfig . addAttribute ( "option" , LeftCurlyOption . EOL . toString ( ) ) ; checkConfig . addAttribute ( "maxLineLength" , "100" ) ; final String [ ] expected = { "9:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "12:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "16:9: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "18:13: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "20:17: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "26:22: " + getCheckMessage ( MSG_KEY_LINE_BREAK_AFTER , "{" ) , "28:17: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "35:33: " + getCheckMessage ( MSG_KEY_LINE_BREAK_AFTER , "{" ) , "36:21: " + getCheckMessage ( MSG_KEY_LINE_BREAK_AFTER , "{" ) , "39:29: " + getCheckMessage ( MSG_KEY_LINE_BREAK_AFTER , "{" ) , "39:34: " + getCheckMessage ( MSG_KEY_LINE_BREAK_AFTER , "{" ) , "45:37: " + getCheckMessage ( MSG_KEY_LINE_BREAK_AFTER , "{" ) , "51:12: " + getCheckMessage ( MSG_KEY_LINE_BREAK_AFTER , "{" ) , "54:5: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , "56:27: " + getCheckMessage ( MSG_KEY_LINE_BREAK_AFTER , "{" ) , "66:1: " + getCheckMessage ( MSG_KEY_LINE_PREVIOUS , "{" ) , } ; verify ( checkConfig , getPath ( "InputLeftCurlyLineBreakAfter.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . header ;
package com . puppycrawl . tools . checkstyle . checks . header ; import java . io . File ; import java . util . Arrays ; import java . util . List ; public class HeaderCheck extends AbstractHeaderCheck { public static final String MSG_MISSING = "header.missing" ; public static final String MSG_MISMATCH = "header.mismatch" ; private static final int [ ] EMPTY_INT_ARRAY = new int [ 0 ] ; private int [ ] ignoreLines = EMPTY_INT_ARRAY ; private boolean isIgnoreLine ( int lineNo ) { return Arrays . binarySearch ( ignoreLines , lineNo ) >= 0 ; } protected boolean isMatch ( int lineNumber , String line ) { return isIgnoreLine ( lineNumber + 1 ) || getHeaderLines ( ) . get ( lineNumber ) . equals ( line ) ; } public void setIgnoreLines ( int ... list ) { if ( list == null || list . length == 0 ) { ignoreLines = EMPTY_INT_ARRAY ; return ; } ignoreLines = new int [ list . length ] ; System . arraycopy ( list , 0 , ignoreLines , 0 , list . length ) ; Arrays . sort ( ignoreLines ) ; } @ Override protected void processFiltered ( File file , List < String > lines ) { if ( getHeaderLines ( ) . size ( ) > lines . size ( ) ) { log ( 1 , MSG_MISSING ) ; } else { for ( int i = 0 ; i < getHeaderLines ( ) . size ( ) ; i ++ ) { if ( ! isMatch ( i , lines . get ( i ) ) ) { log ( i + 1 , MSG_MISMATCH , getHeaderLines ( ) . get ( i ) ) ; break ; } } } } }
package com . puppycrawl . tools . checkstyle . checks . header ; import java . util . Arrays ; import java . io . File ; import java . util . List ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; import com . puppycrawl . tools . checkstyle . Utils ; import org . apache . commons . beanutils . ConversionException ; import com . google . common . collect . Lists ; import org . apache . commons . lang3 . StringUtils ; public class RegexpHeaderCheck extends AbstractHeaderCheck { private static final int [ ] EMPTY_INT_ARRAY = new int [ 0 ] ; private final List < Pattern > headerRegexps = Lists . newArrayList ( ) ; private int [ ] multiLines = EMPTY_INT_ARRAY ; public void setMultiLines ( int ... list ) { if ( list == null || list . length == 0 ) { multiLines = EMPTY_INT_ARRAY ; return ; } multiLines = new int [ list . length ] ; System . arraycopy ( list , 0 , multiLines , 0 , list . length ) ; Arrays . sort ( multiLines ) ; } @ Override protected void processFiltered ( File file , List < String > lines ) { final int headerSize = getHeaderLines ( ) . size ( ) ; final int fileSize = lines . size ( ) ; if ( headerSize - multiLines . length > fileSize ) { log ( 1 , "header.missing" ) ; } else { int headerLineNo = 0 ; int i ; for ( i = 0 ; headerLineNo < headerSize && i < fileSize ; i ++ ) { final String line = lines . get ( i ) ; boolean isMatch = isMatch ( line , headerLineNo ) ; while ( ! isMatch && isMultiLine ( headerLineNo ) ) { headerLineNo ++ ; isMatch = headerLineNo == headerSize || isMatch ( line , headerLineNo ) ; } if ( ! isMatch ) { log ( i + 1 , "header.mismatch" , getHeaderLines ( ) . get ( headerLineNo ) ) ; break ; } if ( ! isMultiLine ( headerLineNo ) ) { headerLineNo ++ ; } } if ( i == fileSize ) { for ( ; headerLineNo < headerSize ; headerLineNo ++ ) { if ( ! isMultiLine ( headerLineNo ) ) { log ( 1 , "header.missing" ) ; break ; } } } } } private boolean isMatch ( String line , int headerLineNo ) { return headerRegexps . get ( headerLineNo ) . matcher ( line ) . find ( ) ; } private boolean isMultiLine ( int lineNo ) { return Arrays . binarySearch ( multiLines , lineNo + 1 ) >= 0 ; } @ Override protected void postprocessHeaderLines ( ) { final List < String > headerLines = getHeaderLines ( ) ; headerRegexps . clear ( ) ; for ( String line : headerLines ) { try { headerRegexps . add ( Pattern . compile ( line ) ) ; } catch ( final PatternSyntaxException ex ) { throw new ConversionException ( "line " + ( headerRegexps . size ( ) + 1 ) + " in header specification" + " is not a regular expression" ) ; } } } @ Override public void setHeader ( String header ) { if ( StringUtils . isBlank ( header ) ) { return ; } if ( ! Utils . isPatternValid ( header ) ) { throw new ConversionException ( "Unable to parse format: " + header ) ; } super . setHeader ( header ) ; } }
package com . puppycrawl . tools . checkstyle . checks . sizes ;
package com . puppycrawl . tools . checkstyle . checks . sizes ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . FileContents ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class MethodLengthCheck extends Check { public static final String MSG_KEY = "maxLen.method" ; private static final int DEFAULT_MAX_LINES = 150 ; private boolean countEmpty = true ; private int max = DEFAULT_MAX_LINES ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST openingBrace = ast . findFirstToken ( TokenTypes . SLIST ) ; if ( openingBrace != null ) { final DetailAST closingBrace = openingBrace . findFirstToken ( TokenTypes . RCURLY ) ; int length = closingBrace . getLineNo ( ) - openingBrace . getLineNo ( ) + 1 ; if ( ! countEmpty ) { final FileContents contents = getFileContents ( ) ; final int lastLine = closingBrace . getLineNo ( ) ; for ( int i = openingBrace . getLineNo ( ) - 1 ; i < lastLine ; i ++ ) { if ( contents . lineIsBlank ( i ) || contents . lineIsComment ( i ) ) { length -- ; } } } if ( length > max ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY , length , max ) ; } } } public void setMax ( int length ) { max = length ; } public void setCountEmpty ( boolean countEmpty ) { this . countEmpty = countEmpty ; } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . Scope ; import com . puppycrawl . tools . checkstyle . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . EnumMap ; import java . util . Map ; public final class MethodCountCheck extends Check { public static final String MSG_PRIVATE_METHODS = "too.many.privateMethods" ; public static final String MSG_PACKAGE_METHODS = "too.many.packageMethods" ; public static final String MSG_PROTECTED_METHODS = "too.many.protectedMethods" ; public static final String MSG_PUBLIC_METHODS = "too.many.publicMethods" ; public static final String MSG_MANY_METHODS = "too.many.methods" ; private static class MethodCounter { private final Map < Scope , Integer > counts = new EnumMap < > ( Scope . class ) ; private final boolean inInterface ; private int total ; MethodCounter ( boolean inInterface ) { this . inInterface = inInterface ; } void increment ( Scope scope ) { total ++ ; if ( inInterface ) { counts . put ( Scope . PUBLIC , 1 + value ( Scope . PUBLIC ) ) ; } else { counts . put ( scope , 1 + value ( scope ) ) ; } } int value ( Scope scope ) { final Integer value = counts . get ( scope ) ; return null == value ? 0 : value ; } int getTotal ( ) { return total ; } } private static final int DEFAULT_MAX_METHODS = 100 ; private int maxPrivate = DEFAULT_MAX_METHODS ; private int maxPackage = DEFAULT_MAX_METHODS ; private int maxProtected = DEFAULT_MAX_METHODS ; private int maxPublic = DEFAULT_MAX_METHODS ; private int maxTotal = DEFAULT_MAX_METHODS ; private final Deque < MethodCounter > counters = new ArrayDeque < > ( ) ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . ENUM_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . METHOD_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . ENUM_CONSTANT_DEF , TokenTypes . ENUM_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . METHOD_DEF , } ; } @ Override public void visitToken ( DetailAST ast ) { if ( TokenTypes . METHOD_DEF == ast . getType ( ) ) { raiseCounter ( ast ) ; } else { final boolean inInterface = TokenTypes . INTERFACE_DEF == ast . getType ( ) ; counters . push ( new MethodCounter ( inInterface ) ) ; } } @ Override public void leaveToken ( DetailAST ast ) { if ( TokenTypes . CLASS_DEF == ast . getType ( ) || TokenTypes . INTERFACE_DEF == ast . getType ( ) || TokenTypes . ENUM_CONSTANT_DEF == ast . getType ( ) || TokenTypes . ENUM_DEF == ast . getType ( ) ) { final MethodCounter counter = counters . pop ( ) ; checkCounters ( counter , ast ) ; } } private void raiseCounter ( DetailAST method ) { final MethodCounter actualCounter = counters . peek ( ) ; final DetailAST temp = method . findFirstToken ( TokenTypes . MODIFIERS ) ; final Scope scope = ScopeUtils . getScopeFromMods ( temp ) ; actualCounter . increment ( scope ) ; } private void checkCounters ( MethodCounter counter , DetailAST ast ) { checkMax ( maxPrivate , counter . value ( Scope . PRIVATE ) , MSG_PRIVATE_METHODS , ast ) ; checkMax ( maxPackage , counter . value ( Scope . PACKAGE ) , MSG_PACKAGE_METHODS , ast ) ; checkMax ( maxProtected , counter . value ( Scope . PROTECTED ) , MSG_PROTECTED_METHODS , ast ) ; checkMax ( maxPublic , counter . value ( Scope . PUBLIC ) , MSG_PUBLIC_METHODS , ast ) ; checkMax ( maxTotal , counter . getTotal ( ) , MSG_MANY_METHODS , ast ) ; } private void checkMax ( int max , int value , String msg , DetailAST ast ) { if ( max < value ) { log ( ast . getLineNo ( ) , msg , value , max ) ; } } public void setMaxPrivate ( int value ) { maxPrivate = value ; } public void setMaxPackage ( int value ) { maxPackage = value ; } public void setMaxProtected ( int value ) { maxProtected = value ; } public void setMaxPublic ( int value ) { maxPublic = value ; } public void setMaxTotal ( int value ) { maxTotal = value ; } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import com . puppycrawl . tools . checkstyle . api . AbstractFileSetCheck ; import java . io . File ; import java . util . List ; public class FileLengthCheck extends AbstractFileSetCheck { public static final String MSG_KEY = "maxLen.file" ; private static final int DEFAULT_MAX_LINES = 2000 ; private int maxFileLength = DEFAULT_MAX_LINES ; @ Override protected void processFiltered ( File file , List < String > lines ) { if ( lines . size ( ) > maxFileLength ) { log ( 1 , MSG_KEY , lines . size ( ) , maxFileLength ) ; } } public void setMax ( int length ) { maxFileLength = length ; } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import com . puppycrawl . tools . checkstyle . api . Check ; public class OuterTypeNumberCheck extends Check { public static final String MSG_KEY = "maxOuterTypes" ; private int max = 1 ; private int currentDepth ; private int outerNum ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , } ; } @ Override public void beginTree ( DetailAST ast ) { currentDepth = 0 ; outerNum = 0 ; } @ Override public void finishTree ( DetailAST ast ) { if ( max < outerNum ) { log ( ast , MSG_KEY , outerNum , max ) ; } } @ Override public void visitToken ( DetailAST ast ) { if ( 0 == currentDepth ) { outerNum ++ ; } currentDepth ++ ; } @ Override public void leaveToken ( DetailAST ast ) { currentDepth -- ; } public void setMax ( int to ) { max = to ; } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; import java . util . ArrayDeque ; import java . util . Deque ; public final class ExecutableStatementCountCheck extends Check { public static final String MSG_KEY = "executableStatementCount" ; private static final int DEFAULT_MAX = 30 ; private int max ; private final Deque < Context > contextStack = new ArrayDeque < > ( ) ; private Context context ; public ExecutableStatementCountCheck ( ) { setMax ( DEFAULT_MAX ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . INSTANCE_INIT , TokenTypes . STATIC_INIT , TokenTypes . SLIST , } ; } @ Override public int [ ] getRequiredTokens ( ) { return new int [ ] { TokenTypes . SLIST } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CTOR_DEF , TokenTypes . METHOD_DEF , TokenTypes . INSTANCE_INIT , TokenTypes . STATIC_INIT , TokenTypes . SLIST , } ; } public int getMax ( ) { return max ; } public void setMax ( int max ) { this . max = max ; } @ Override public void beginTree ( DetailAST rootAST ) { context = new Context ( null ) ; contextStack . clear ( ) ; } @ Override public void visitToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CTOR_DEF : case TokenTypes . METHOD_DEF : case TokenTypes . INSTANCE_INIT : case TokenTypes . STATIC_INIT : visitMemberDef ( ast ) ; break ; case TokenTypes . SLIST : visitSlist ( ast ) ; break ; default : throw new IllegalStateException ( ast . toString ( ) ) ; } } @ Override public void leaveToken ( DetailAST ast ) { switch ( ast . getType ( ) ) { case TokenTypes . CTOR_DEF : case TokenTypes . METHOD_DEF : case TokenTypes . INSTANCE_INIT : case TokenTypes . STATIC_INIT : leaveMemberDef ( ast ) ; break ; case TokenTypes . SLIST : break ; default : throw new IllegalStateException ( ast . toString ( ) ) ; } } private void visitMemberDef ( DetailAST ast ) { contextStack . push ( context ) ; context = new Context ( ast ) ; } private void leaveMemberDef ( DetailAST ast ) { final int count = context . getCount ( ) ; if ( count > getMax ( ) ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY , count , getMax ( ) ) ; } context = contextStack . pop ( ) ; } private void visitSlist ( DetailAST ast ) { if ( context . getAST ( ) != null ) { final DetailAST contextAST = context . getAST ( ) ; DetailAST parent = ast . getParent ( ) ; int type = parent . getType ( ) ; while ( type != TokenTypes . CTOR_DEF && type != TokenTypes . METHOD_DEF && type != TokenTypes . INSTANCE_INIT && type != TokenTypes . STATIC_INIT ) { parent = parent . getParent ( ) ; type = parent . getType ( ) ; } if ( parent == contextAST ) { context . addCount ( ast . getChildCount ( ) / 2 ) ; } } } private static class Context { private final DetailAST ast ; private int count ; public Context ( DetailAST ast ) { this . ast = ast ; count = 0 ; } public void addCount ( int count ) { this . count += count ; } public DetailAST getAST ( ) { return ast ; } public int getCount ( ) { return count ; } } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class AnonInnerLengthCheck extends Check { public static final String MSG_KEY = "maxLen.anonInner" ; private static final int DEFAULT_MAX = 20 ; private int max = DEFAULT_MAX ; @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . LITERAL_NEW } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . LITERAL_NEW } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST openingBrace = ast . findFirstToken ( TokenTypes . OBJBLOCK ) ; if ( openingBrace != null ) { final DetailAST closingBrace = openingBrace . findFirstToken ( TokenTypes . RCURLY ) ; final int length = closingBrace . getLineNo ( ) - openingBrace . getLineNo ( ) + 1 ; if ( length > max ) { log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG_KEY , length , max ) ; } } } public void setMax ( int length ) { max = length ; } }
package com . puppycrawl . tools . checkstyle . checks . blocks ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . blocks . EmptyBlockCheck . MSG_KEY_BLOCK_EMPTY ; import static com . puppycrawl . tools . checkstyle . checks . blocks . EmptyBlockCheck . MSG_KEY_BLOCK_NO_STMT ; public class EmptyBlockCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( EmptyBlockCheck . class ) ; final String [ ] expected = { "75:13: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "77:17: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "79:13: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "82:17: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "178:5: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "206:29: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "208:41: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testText ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( EmptyBlockCheck . class ) ; checkConfig . addAttribute ( "option" , BlockOption . TEXT . toString ( ) ) ; final String [ ] expected = { "75:13: " + getCheckMessage ( MSG_KEY_BLOCK_EMPTY , "try" ) , "77:17: " + getCheckMessage ( MSG_KEY_BLOCK_EMPTY , "finally" ) , "178:5: " + getCheckMessage ( MSG_KEY_BLOCK_EMPTY , "INSTANCE_INIT" ) , "206:29: " + getCheckMessage ( MSG_KEY_BLOCK_EMPTY , "synchronized" ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void testStatement ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( EmptyBlockCheck . class ) ; checkConfig . addAttribute ( "option" , BlockOption . STMT . toString ( ) ) ; final String [ ] expected = { "75:13: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "77:17: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "79:13: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "82:17: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "178:5: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "206:29: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "208:41: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , } ; verify ( checkConfig , getPath ( "InputSemantic.java" ) , expected ) ; } @ Test public void allowEmptyLoops ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( EmptyBlockCheck . class ) ; checkConfig . addAttribute ( "option" , BlockOption . STMT . toString ( ) ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_TRY, LITERAL_CATCH," + "LITERAL_FINALLY, LITERAL_DO, LITERAL_IF," + "LITERAL_ELSE, INSTANCE_INIT, STATIC_INIT, LITERAL_SWITCH" ) ; final String [ ] expected = { "16:29: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "19:42: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "22:29: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , "23:28: " + getCheckMessage ( MSG_KEY_BLOCK_NO_STMT ) , } ; verify ( checkConfig , getPath ( "InputSemantic2.java" ) , expected ) ; } @ Test public void allowEmptyLoopsText ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( EmptyBlockCheck . class ) ; checkConfig . addAttribute ( "option" , BlockOption . TEXT . toString ( ) ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_TRY, LITERAL_CATCH," + "LITERAL_FINALLY, LITERAL_DO, LITERAL_IF," + "LITERAL_ELSE, INSTANCE_INIT, STATIC_INIT, LITERAL_SWITCH" ) ; final String [ ] expected = { "16:29: " + getCheckMessage ( MSG_KEY_BLOCK_EMPTY , "if" ) , "19:42: " + getCheckMessage ( MSG_KEY_BLOCK_EMPTY , "if" ) , "22:29: " + getCheckMessage ( MSG_KEY_BLOCK_EMPTY , "if" ) , "23:28: " + getCheckMessage ( MSG_KEY_BLOCK_EMPTY , "switch" ) , } ; verify ( checkConfig , getPath ( "InputSemantic2.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . Utils ; import java . util . regex . Pattern ; import org . apache . commons . beanutils . ConversionException ; public class LineLengthCheck extends Check { public static final String MSG_KEY = "maxLineLen" ; private static final int DEFAULT_MAX_COLUMNS = 80 ; private int max = DEFAULT_MAX_COLUMNS ; private Pattern ignorePattern ; public LineLengthCheck ( ) { setIgnorePattern ( "^$" ) ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ 0 ] ; } @ Override public void beginTree ( DetailAST rootAST ) { final String [ ] lines = getLines ( ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { final String line = lines [ i ] ; final int realLength = Utils . lengthExpandedTabs ( line , line . length ( ) , getTabWidth ( ) ) ; if ( realLength > max && ! ignorePattern . matcher ( line ) . find ( ) ) { log ( i + 1 , MSG_KEY , max , realLength ) ; } } } public void setMax ( int length ) { max = length ; } public void setIgnorePattern ( String format ) throws ConversionException { ignorePattern = Utils . createPattern ( format ) ; } }
package com . puppycrawl . tools . checkstyle . checks . sizes ; import com . puppycrawl . tools . checkstyle . AnnotationUtility ; import com . puppycrawl . tools . checkstyle . api . Check ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class ParameterNumberCheck extends Check { public static final String MSG_KEY = "maxParam" ; private static final String OVERRIDE = "Override" ; private static final String CANONICAL_OVERRIDE = "java.lang." + OVERRIDE ; private static final int DEFAULT_MAX_PARAMETERS = 7 ; private int max = DEFAULT_MAX_PARAMETERS ; private boolean ignoreOverriddenMethods ; public void setMax ( int max ) { this . max = max ; } public void setIgnoreOverriddenMethods ( boolean ignoreOverriddenMethods ) { this . ignoreOverriddenMethods = ignoreOverriddenMethods ; } @ Override public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF } ; } @ Override public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . METHOD_DEF , TokenTypes . CTOR_DEF } ; } @ Override public void visitToken ( DetailAST ast ) { final DetailAST params = ast . findFirstToken ( TokenTypes . PARAMETERS ) ; final int count = params . getChildCount ( TokenTypes . PARAMETER_DEF ) ; if ( count > max && ! ignoreNumberOfParameters ( ast ) ) { final DetailAST name = ast . findFirstToken ( TokenTypes . IDENT ) ; log ( name . getLineNo ( ) , name . getColumnNo ( ) , MSG_KEY , max , count ) ; } } private boolean ignoreNumberOfParameters ( DetailAST ast ) { return ignoreOverriddenMethods && ( AnnotationUtility . containsAnnotation ( ast , OVERRIDE ) || AnnotationUtility . containsAnnotation ( ast , CANONICAL_OVERRIDE ) ) ; } }
package com . google . checkstyle . test . chapter3filestructure . rule32packagestate ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . sizes . LineLengthCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class LineLengthTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void lineLengthTest ( ) throws IOException , Exception { final String [ ] expected = { "5: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 112 ) , "29: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 183 ) , "46: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 131 ) , "47: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 124 ) , "48: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 113 ) , "50: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 116 ) , "53: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 131 ) , "57: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 116 ) , } ; Configuration checkConfig = builder . getCheckConfig ( "LineLength" ) ; String filePath = builder . getFilePath ( "LineLengthInput2" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter3filestructure . rule331nowildcard ; import java . io . File ; import java . io . IOException ; import java . util . List ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; public class AvoidStarImportTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void starImportTest ( ) throws IOException , Exception { final String [ ] expected = { "3: Using the '.*' form of import should be avoided - java.io.*." , "4: Using the '.*' form of import should be avoided - java.lang.*." , "18: Using the '.*' form of import should be avoided - javax.swing.WindowConstants.*." , "19: Using the '.*' form of import should be avoided - javax.swing.WindowConstants.*." , } ; Configuration checkConfig = builder . getCheckConfig ( "AvoidStarImport" ) ; String filePath = builder . getFilePath ( "AvoidStarImportInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter3filestructure . rule332nolinewrap ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . sizes . LineLengthCheck ; import com . puppycrawl . tools . checkstyle . checks . whitespace . NoLineWrapCheck ; public class NoLineWrapTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void badLineWrapTest ( ) throws IOException , Exception { String msg = getCheckMessage ( NoLineWrapCheck . class , "no.line.wrap" , "import" ) ; final String [ ] expected = { "1: " + getCheckMessage ( NoLineWrapCheck . class , "no.line.wrap" , "package" ) , "6: " + getCheckMessage ( NoLineWrapCheck . class , "no.line.wrap" , "import" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "NoLineWrap" ) ; String filePath = builder . getFilePath ( "NoLineWrap_Bad" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void goodLineWrapTest ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "NoLineWrap" ) ; String filePath = builder . getFilePath ( "NoLineWrap_Good" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void goodLineLength ( ) throws IOException , Exception { int maxLineLength = 100 ; final String [ ] expected = { "5: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , maxLineLength , 112 ) , "29: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , maxLineLength , 183 ) , "46: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , maxLineLength , 131 ) , "47: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , maxLineLength , 124 ) , "48: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , maxLineLength , 113 ) , "50: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , maxLineLength , 116 ) , "53: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , maxLineLength , 131 ) , "57: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , maxLineLength , 116 ) , } ; Configuration checkConfig = builder . getCheckConfig ( "LineLength" ) ; String filePath = builder . getFilePath ( "LineLengthInput2" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter3filestructure . rule333orderingandsoacing ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . design . OneTopLevelClassCheck ; import com . puppycrawl . tools . checkstyle . checks . imports . CustomImportOrderCheck ; public class CustomImportOrderTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; Class < CustomImportOrderCheck > clazz = CustomImportOrderCheck . class ; String msgSeparator = "custom.import.order.line.separator" ; String msgLex = "custom.import.order.lex" ; String msgOrder = "custom.import.order" ; String msgNongroup = "custom.import.order.nongroup.import" ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void customImportTest_1 ( ) throws IOException , Exception { final String [ ] expected = { "4: " + getCheckMessage ( clazz , msgLex , "java.awt.Button.ABORT" ) , "7: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "8: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "9: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "10: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "11: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "12: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "13: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "14: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "15: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "16: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "CustomImportOrder" ) ; String filePath = builder . getFilePath ( "CustomImportOrderInput_1" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void customImportTest_2 ( ) throws IOException , Exception { final String [ ] expected = { "4: " + getCheckMessage ( clazz , msgLex , "java.awt.Button.ABORT" ) , "7: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "8: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "9: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "10: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "11: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "14: " + getCheckMessage ( clazz , msgSeparator , "com.sun.xml.internal.xsom.impl.scd.Iterators" ) , "16: " + getCheckMessage ( clazz , msgOrder , "SPECIAL_IMPORTS" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "CustomImportOrder" ) ; String filePath = builder . getFilePath ( "CustomImportOrderInput_2" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void customImportTest_3 ( ) throws IOException , Exception { final String [ ] expected = { "4: " + getCheckMessage ( clazz , msgLex , "java.awt.Button.ABORT" ) , "8: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "9: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "10: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "11: " + getCheckMessage ( clazz , msgOrder , "STANDARD_JAVA_PACKAGE" ) , "14: " + getCheckMessage ( clazz , msgSeparator , "com.sun.xml.internal.xsom.impl.scd.Iterators" ) , "16: " + getCheckMessage ( clazz , msgOrder , "SPECIAL_IMPORTS" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "CustomImportOrder" ) ; String filePath = builder . getFilePath ( "CustomImportOrderInput_3" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void validTest ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "CustomImportOrder" ) ; String filePath = builder . getFilePath ( "CustomImportOrderValidInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter3filestructure . rule341onetoplevel ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . design . OneTopLevelClassCheck ; public class OneTopLevelClassTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void badTest ( ) throws IOException , Exception { Class < OneTopLevelClassCheck > clazz = OneTopLevelClassCheck . class ; String messageKey = "one.top.level.class" ; final String [ ] expected = { "25: " + getCheckMessage ( clazz , messageKey , "NoSuperClone" ) , "33: " + getCheckMessage ( clazz , messageKey , "InnerClone" ) , "50: " + getCheckMessage ( clazz , messageKey , "CloneWithTypeArguments" ) , "55: " + getCheckMessage ( clazz , messageKey , "CloneWithTypeArgumentsAndNoSuper" ) , "60: " + getCheckMessage ( clazz , messageKey , "MyClassWithGenericSuperMethod" ) , "77: " + getCheckMessage ( clazz , messageKey , "AnotherClass" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "OneTopLevelClass" ) ; String filePath = builder . getFilePath ( "OneTopLevelClassInput_Basic" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void goodTest ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "OneTopLevelClass" ) ; String filePath = builder . getFilePath ( "OneTopLevelClassInputGood" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void bad2Test ( ) throws IOException , Exception { Class < OneTopLevelClassCheck > clazz = OneTopLevelClassCheck . class ; String messageKey = "one.top.level.class" ; final String [ ] expected = { "4: " + getCheckMessage ( clazz , messageKey , "FooEnum" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "OneTopLevelClass" ) ; String filePath = builder . getFilePath ( "OneTopLevelClassBad2" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void bad3Test ( ) throws IOException , Exception { Class < OneTopLevelClassCheck > clazz = OneTopLevelClassCheck . class ; String messageKey = "one.top.level.class" ; final String [ ] expected = { "5: " + getCheckMessage ( clazz , messageKey , "FooIn" ) , "7: " + getCheckMessage ( clazz , messageKey , "FooClass" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "OneTopLevelClass" ) ; String filePath = builder . getFilePath ( "OneTopLevelClassBad3" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter3filestructure . rule3421overloadsplit ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . coding . OverloadMethodsDeclarationOrderCheck ; public class OverloadMethodsDeclarationOrderTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void overloadMethodsTest ( ) throws IOException , Exception { Class < OverloadMethodsDeclarationOrderCheck > clazz = OverloadMethodsDeclarationOrderCheck . class ; String messageKey = "overload.methods.declaration" ; final String [ ] expected = { "26: " + getCheckMessage ( clazz , messageKey , 15 ) , "54: " + getCheckMessage ( clazz , messageKey , 43 ) , "66: " + getCheckMessage ( clazz , messageKey , 64 ) , "109: " + getCheckMessage ( clazz , messageKey , 98 ) , } ; Configuration checkConfig = builder . getCheckConfig ( "OverloadMethodsDeclarationOrder" ) ; String filePath = builder . getFilePath ( "InputOverloadMethodsDeclarationOrder" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter3filestructure . rule3sourcefile ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . whitespace . EmptyLineSeparatorCheck ; public class EmptyLineSeparatorTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void emptyLineSeparatorTest ( ) throws IOException , Exception { java . lang . Class < EmptyLineSeparatorCheck > clazz = EmptyLineSeparatorCheck . class ; String messageKey = "empty.line.separator" ; final String [ ] expected = { "19: " + getCheckMessage ( clazz , messageKey , "package" ) , "20: " + getCheckMessage ( clazz , messageKey , "import" ) , "33: " + getCheckMessage ( clazz , messageKey , "CLASS_DEF" ) , "37: " + getCheckMessage ( clazz , messageKey , "STATIC_INIT" ) , "75: " + getCheckMessage ( clazz , messageKey , "INTERFACE_DEF" ) , "82: " + getCheckMessage ( clazz , messageKey , "INSTANCE_INIT" ) , "113: " + getCheckMessage ( clazz , messageKey , "CLASS_DEF" ) , "119: " + getCheckMessage ( clazz , messageKey , "VARIABLE_DEF" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "EmptyLineSeparator" ) ; String filePath = builder . getFilePath ( "EmptyLineSeparatorInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter5naming . rule528typevariablenames ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . naming . ClassTypeParameterNameCheck ; import com . puppycrawl . tools . checkstyle . checks . naming . MethodTypeParameterNameCheck ; public class ClassMethodTypeParameterNameTest extends BaseCheckTestSupport { private static ConfigurationBuilder builder ; private Class < ClassTypeParameterNameCheck > clazz = ClassTypeParameterNameCheck . class ; private String msgKey = "name.invalidPattern" ; private static Configuration checkConfig ; private static String format ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; checkConfig = builder . getCheckConfig ( "ClassTypeParameterName" ) ; format = checkConfig . getAttribute ( "format" ) ; } @ Test public void testClassDefault ( ) throws IOException , Exception { final String [ ] expected = { "5:31: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "t" , format ) , "13:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "foo" , format ) , "27:24: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "$foo" , format ) , } ; String filePath = builder . getFilePath ( "ClassTypeParameterNameInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void testMethodDefault ( ) throws IOException , Exception { Class < MethodTypeParameterNameCheck > clazz = MethodTypeParameterNameCheck . class ; Configuration checkConfig = builder . getCheckConfig ( "MethodTypeParameterName" ) ; final String [ ] expected = { "9:6: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "e_e" , format ) , "19:6: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Tfo$o2T" , format ) , "23:6: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "foo_" , format ) , "28:10: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "_abc" , format ) , "37:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "T$" , format ) , "42:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "EE" , format ) , } ; String filePath = builder . getFilePath ( "MethodTypeParameterNameInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . puppycrawl . tools . checkstyle . checks . blocks ; import java . io . File ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . blocks . NeedBracesCheck . MSG_KEY_NEED_BRACES ; public class NeedBracesCheckTest extends BaseCheckTestSupport { @ Test public void testIt ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NeedBracesCheck . class ) ; final String [ ] expected = { "29: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "do" ) , "41: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "while" ) , "42: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "while" ) , "44: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "while" ) , "45: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "if" ) , "58: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "for" ) , "59: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "for" ) , "61: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "for" ) , "63: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "if" ) , "82: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "if" ) , "83: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "if" ) , "85: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "if" ) , "87: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "else" ) , "89: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "if" ) , "97: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "else" ) , "99: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "if" ) , "100: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "if" ) , } ; verify ( checkConfig , getPath ( "InputBraces.java" ) , expected ) ; } @ Test public void testSigleLineStatements ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NeedBracesCheck . class ) ; checkConfig . addAttribute ( "allowSingleLineStatement" , "true" ) ; final String [ ] expected = { "23: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "if" ) , "29: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "if" ) , "38: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "if" ) , "46: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "while" ) , "53: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "do" ) , "59: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "for" ) , "88: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "if" ) , "92: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "else" ) , } ; verify ( checkConfig , getPath ( "InputBracesSingleLineStatements.java" ) , expected ) ; } @ Test public void testSigleLineLambda ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NeedBracesCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LAMBDA" ) ; checkConfig . addAttribute ( "allowSingleLineStatement" , "true" ) ; final String [ ] expected = { } ; verify ( checkConfig , new File ( "src/test/resources-noncompilable/com/puppycrawl/" + "tools/checkstyle/blocks/InputSingleLineLambda.java" ) . getCanonicalPath ( ) , expected ) ; } @ Test public void testSigleLineCaseDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( NeedBracesCheck . class ) ; checkConfig . addAttribute ( "tokens" , "LITERAL_CASE, LITERAL_DEFAULT" ) ; checkConfig . addAttribute ( "allowSingleLineStatement" , "true" ) ; final String [ ] expected = { "69: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "case" ) , "72: " + getCheckMessage ( MSG_KEY_NEED_BRACES , "case" ) , } ; verify ( checkConfig , getPath ( "InputBracesSingleLineStatements.java" ) , expected ) ; } }
package com . google . checkstyle . test . chapter5naming . rule522typenames ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . naming . TypeNameCheck ; public class TypeNameTest extends BaseCheckTestSupport { private static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void typeNameTest ( ) throws IOException , Exception { Configuration checkConfig = builder . getCheckConfig ( "TypeName" ) ; Class < TypeNameCheck > clazz = TypeNameCheck . class ; String msgKey = "name.invalidPattern" ; String format = "^[A-Z][a-zA-Z0-9]*$" ; final String [ ] expected = { "3:7: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "inputHeaderClass" , format ) , "5:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "InputHeader___Interface" , format ) , "7:17: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "inputHeaderEnum" , format ) , "9:11: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "NoValid$Name" , format ) , "11:11: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "$NoValidName" , format ) , "13:11: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "NoValidName$" , format ) , "19:7: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "_ValidName" , format ) , "21:7: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Valid_Name" , format ) , "23:7: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "ValidName_" , format ) , "27:11: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "_Foo" , format ) , "29:11: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Fo_o" , format ) , "31:11: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Foo_" , format ) , "33:11: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "$Foo" , format ) , "35:11: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Fo$o" , format ) , "37:11: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Foo$" , format ) , "41:6: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "_FooEnum" , format ) , "43:6: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Foo_Enum" , format ) , "45:6: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "FooEnum_" , format ) , "47:6: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "$FooEnum" , format ) , "49:6: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Foo$Enum" , format ) , "51:6: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "FooEnum$" , format ) , "53:7: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "aaa" , format ) , "55:11: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "bbb" , format ) , "57:6: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "ccc" , format ) , "61:12: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "_Annotation" , format ) , "63:12: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Annot_ation" , format ) , "65:12: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Annotation_" , format ) , "67:12: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "$Annotation" , format ) , "69:12: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Annot$ation" , format ) , "71:12: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Annotation$" , format ) , } ; String filePath = builder . getFilePath ( "TypeNameInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter5naming . rule523methodnames ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; public class MethodNameTest extends BaseCheckTestSupport { private static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void methodNameTest ( ) throws IOException , Exception { Configuration checkConfig = builder . getCheckConfig ( "MethodName" ) ; String msgKey = "name.invalidPattern" ; String format = "^[a-z][a-z0-9][a-zA-Z0-9_]*$" ; final String [ ] expected = { "11:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Foo" , format ) , "12:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "fOo" , format ) , "14:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "f$o" , format ) , "15:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "f_oo" , format ) , "16:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "f" , format ) , "17:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "fO" , format ) , "21:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Foo" , format ) , "22:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "fOo" , format ) , "24:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "f$o" , format ) , "25:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "f_oo" , format ) , "26:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "f" , format ) , "27:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "fO" , format ) , "32:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Foo" , format ) , "33:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "fOo" , format ) , "35:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "f$o" , format ) , "36:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "f_oo" , format ) , "37:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "f" , format ) , "38:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "fO" , format ) , "44:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "Foo" , format ) , "45:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "fOo" , format ) , "47:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "f$o" , format ) , "48:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "f_oo" , format ) , "49:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "f" , format ) , "50:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "fO" , format ) , } ; String filePath = builder . getFilePath ( "InputMethodName" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter5naming . rule526parameternames ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . naming . ParameterNameCheck ; public class ParameterNameTest extends BaseCheckTestSupport { private Class < ParameterNameCheck > clazz = ParameterNameCheck . class ; private String msgKey = "name.invalidPattern" ; private static String format ; private static ConfigurationBuilder builder ; private static Configuration checkConfig ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; checkConfig = builder . getCheckConfig ( "ParameterName" ) ; format = checkConfig . getAttribute ( "format" ) ; } @ Test public void parameterNameTest ( ) throws IOException , Exception { final String [ ] expected = { "8:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "$arg1" , format ) , "9:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "ar$g2" , format ) , "10:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "arg3$" , format ) , "11:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "a_rg4" , format ) , "12:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "_arg5" , format ) , "13:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "arg6_" , format ) , "14:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "aArg7" , format ) , "15:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "aArg8" , format ) , "16:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "aar_g" , format ) , "26:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "bB" , format ) , "49:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "llll_llll" , format ) , "50:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "bB" , format ) , } ; String filePath = builder . getFilePath ( "ParameterNameInput_Simple" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter5naming . rule53camelcase ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . naming . AbbreviationAsWordInNameCheck ; public class AbbreviationAsWordInNameTest extends BaseCheckTestSupport { private static ConfigurationBuilder builder ; private Class < AbbreviationAsWordInNameCheck > clazz = AbbreviationAsWordInNameCheck . class ; private String msgKey = "abbreviation.as.word" ; private static Configuration checkConfig ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; checkConfig = builder . getCheckConfig ( "AbbreviationAsWordInName" ) ; } @ Test public void abbreviationAsWordInNameTest ( ) throws IOException , Exception { int maxCapitalCount = 1 ; String msg = getCheckMessage ( clazz , msgKey , maxCapitalCount ) ; final String [ ] expected = { "50: " + msg , "52: " + msg , "54: " + msg , "58: " + msg , "60: " + msg , "62: " + msg , "67: " + msg , "69: " + msg , "71: " + msg , } ; String filePath = builder . getFilePath ( "InputAbbreviationAsWordInTypeNameCheck" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter5naming . rule525nonconstantfieldnames ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . naming . TypeNameCheck ; public class MemberNameTest extends BaseCheckTestSupport { private static ConfigurationBuilder builder ; private Class < TypeNameCheck > clazz = TypeNameCheck . class ; private String msgKey = "name.invalidPattern" ; private static Configuration checkConfig ; private static String format ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; checkConfig = builder . getCheckConfig ( "MemberName" ) ; format = checkConfig . getAttribute ( "format" ) ; } @ Test public void memberNameTest ( ) throws IOException , Exception { final String [ ] expected = { "5:16: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mPublic" , format ) , "6:19: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mProtected" , format ) , "7:9: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mPackage" , format ) , "8:17: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mPrivate" , format ) , "10:16: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "_public" , format ) , "11:19: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "prot_ected" , format ) , "12:9: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "package_" , format ) , "13:17: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "priva$te" , format ) , "20:9: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "ABC" , format ) , "21:15: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "C_D_E" , format ) , "23:16: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "$mPublic" , format ) , "24:19: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mPro$tected" , format ) , "25:9: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mPackage$" , format ) , } ; String filePath = builder . getFilePath ( "MemberNameInput_Basic" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void simpleTest ( ) throws IOException , Exception { final String [ ] expected = { "12:17: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "bad$Static" , format ) , "17:17: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "bad_Member" , format ) , "19:17: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "m" , format ) , "21:19: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "m_M" , format ) , "24:19: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "m$nts" , format ) , "35:9: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mTest1" , format ) , "37:16: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mTest2" , format ) , "39:16: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "$mTest2" , format ) , "41:16: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mTes$t2" , format ) , "43:16: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mTest2$" , format ) , "77:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "bad$Static" , format ) , "79:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "sum_Created" , format ) , "82:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "bad_Member" , format ) , "84:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "m" , format ) , "86:23: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "m_M" , format ) , "89:23: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "m$nts" , format ) , "93:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mTest1" , format ) , "95:20: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mTest2" , format ) , "97:20: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "$mTest2" , format ) , "99:20: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mTes$t2" , format ) , "101:20: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mTest2$" , format ) , "107:25: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "bad$Static" , format ) , "109:25: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "sum_Created" , format ) , "112:25: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "bad_Member" , format ) , "114:25: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "m" , format ) , "116:25: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "m_M" , format ) , "119:27: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "m$nts" , format ) , "123:25: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mTest1" , format ) , "125:25: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mTest2" , format ) , "127:25: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "$mTest2" , format ) , "129:25: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mTes$t2" , format ) , "131:25: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "mTest2$" , format ) , } ; String filePath = builder . getFilePath ( "MemberNameInput_Simple" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter5naming . rule527localvariablenames ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . naming . LocalVariableNameCheck ; public class LocalVariableNameTest extends BaseCheckTestSupport { private static ConfigurationBuilder builder ; private Class < LocalVariableNameCheck > clazz = LocalVariableNameCheck . class ; private String msgKey = "name.invalidPattern" ; private static Configuration checkConfig ; private static String format ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; checkConfig = builder . getCheckConfig ( "LocalVariableName" ) ; format = checkConfig . getAttribute ( "format" ) ; } @ Test public void localVariableNameTest ( ) throws IOException , Exception { final String [ ] expected = { "26:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "a" , format ) , "27:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "aA" , format ) , "28:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "a1_a" , format ) , "29:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "A_A" , format ) , "30:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "aa2_a" , format ) , "31:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "_a" , format ) , "32:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "_aa" , format ) , "33:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "aa_" , format ) , "34:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "aaa$aaa" , format ) , "35:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "$aaaaaa" , format ) , "36:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "aaaaaa$" , format ) , } ; String filePath = builder . getFilePath ( "LocalVariableNameInput_Simple" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void oneCharTest ( ) throws IOException , Exception { final String [ ] expected = { "15:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "i" , format ) , "21:17: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "I_ndex" , format ) , "45:17: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "i_ndex" , format ) , "49:17: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "ii_i1" , format ) , "53:17: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "$index" , format ) , "57:17: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "in$dex" , format ) , "61:17: " + getCheckMessage ( checkConfig . getMessages ( ) , msgKey , "index$" , format ) , } ; String filePath = builder . getFilePath ( "LocalVariableNameInput_OneCharVarName" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter5naming . rule521packagenames ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . naming . PackageNameCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class PackageNameTest extends BaseCheckTestSupport { private Class < PackageNameCheck > clazz = PackageNameCheck . class ; private static ConfigurationBuilder builder ; private static Configuration checkConfig ; private String msgKey = "name.invalidPattern" ; private static String format ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; checkConfig = builder . getCheckConfig ( "PackageName" ) ; format = checkConfig . getAttribute ( "format" ) ; } @ Test public void goodPackageNameTest ( ) throws IOException , Exception { final String [ ] expected = { } ; String filePath = builder . getFilePath ( "PackageNameInputGood" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void badPackageNameTest ( ) throws IOException , Exception { String packagePath = "com.google.checkstyle.test.chapter5naming.rule521packageNames" ; String msg = getCheckMessage ( checkConfig . getMessages ( ) , msgKey , packagePath , format ) ; final String [ ] expected = { "1:9: " + msg , } ; String filePath = builder . getFilePath ( "PackageNameInputBad" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void badPackageName2Test ( ) throws IOException , Exception { String packagePath = "com.google.checkstyle.test.chapter5naming.rule521_packagenames" ; String msg = getCheckMessage ( checkConfig . getMessages ( ) , msgKey , packagePath , format ) ; final String [ ] expected = { "1:9: " + msg , } ; String filePath = builder . getFilePath ( "BadPackageNameInput2" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void badPackageName3Test ( ) throws IOException , Exception { String packagePath = "com.google.checkstyle.test.chapter5naming.rule521$packagenames" ; String msg = getCheckMessage ( checkConfig . getMessages ( ) , msgKey , packagePath , format ) ; final String [ ] expected = { "1:9: " + msg , } ; String filePath = builder . getFilePath ( "PackageBadNameInput3" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . base ; import static java . text . MessageFormat . format ; import static org . junit . Assert . assertEquals ; import java . io . * ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Properties ; import com . google . common . collect . Lists ; import com . puppycrawl . tools . checkstyle . Checker ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . DefaultLogger ; import com . puppycrawl . tools . checkstyle . TreeWalker ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . Configuration ; public abstract class BaseCheckTestSupport { protected static class BriefLogger extends DefaultLogger { public BriefLogger ( OutputStream out ) throws UnsupportedEncodingException { super ( out , true ) ; } @ Override public void auditStarted ( AuditEvent evt ) { } @ Override public void fileFinished ( AuditEvent evt ) { } @ Override public void fileStarted ( AuditEvent evt ) { } } protected final ByteArrayOutputStream mBAOS = new ByteArrayOutputStream ( ) ; protected final PrintStream mStream = new PrintStream ( mBAOS ) ; protected final Properties mProps = new Properties ( ) ; public static DefaultConfiguration createCheckConfig ( Class < ? > aClazz ) { final DefaultConfiguration checkConfig = new DefaultConfiguration ( aClazz . getName ( ) ) ; return checkConfig ; } protected Checker createChecker ( Configuration aCheckConfig ) throws Exception { final DefaultConfiguration dc = createCheckerConfig ( aCheckConfig ) ; final Checker c = new Checker ( ) ; final Locale locale = Locale . ENGLISH ; c . setLocaleCountry ( locale . getCountry ( ) ) ; c . setLocaleLanguage ( locale . getLanguage ( ) ) ; c . setModuleClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; c . configure ( dc ) ; c . addListener ( new BriefLogger ( mStream ) ) ; return c ; } protected DefaultConfiguration createCheckerConfig ( Configuration aConfig ) { final DefaultConfiguration dc = new DefaultConfiguration ( "configuration" ) ; final DefaultConfiguration twConf = createCheckConfig ( TreeWalker . class ) ; dc . addAttribute ( "charset" , "iso-8859-1" ) ; dc . addChild ( twConf ) ; twConf . addChild ( aConfig ) ; return dc ; } protected static String getPath ( String aFilename ) throws IOException { return new File ( "src/main/java/com/google/checkstyle/test/filebasic/" + aFilename ) . getCanonicalPath ( ) ; } protected static String getSrcPath ( String aFilename ) throws IOException { return new File ( "src/test/java/com/puppycrawl/tools/checkstyle/" + aFilename ) . getCanonicalPath ( ) ; } protected void verify ( Configuration aConfig , String aFileName , String [ ] aExpected , Integer [ ] aWarnsExpected ) throws Exception { verify ( createChecker ( aConfig ) , aFileName , aFileName , aExpected , aWarnsExpected ) ; } protected void verify ( Checker aC , String aFileName , String [ ] aExpected , Integer [ ] aWarnsExpected ) throws Exception { verify ( aC , aFileName , aFileName , aExpected , aWarnsExpected ) ; } protected void verify ( Checker aC , String aProcessedFilename , String aMessageFileName , String [ ] aExpected , Integer [ ] aWarnsExpected ) throws Exception { verify ( aC , new File [ ] { new File ( aProcessedFilename ) } , aMessageFileName , aExpected , aWarnsExpected ) ; } protected void verify ( Checker aC , File [ ] aProcessedFiles , String aMessageFileName , String [ ] aExpected , Integer [ ] aWarnsExpected ) throws Exception { mStream . flush ( ) ; final List < File > theFiles = Lists . newArrayList ( ) ; Collections . addAll ( theFiles , aProcessedFiles ) ; final int errs = aC . process ( theFiles ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( mBAOS . toByteArray ( ) ) ; final LineNumberReader lnr = new LineNumberReader ( new InputStreamReader ( bais ) ) ; for ( int i = 0 ; i < aExpected . length ; i ++ ) { final String expected = aMessageFileName + ":" + aExpected [ i ] ; String actual = lnr . readLine ( ) ; assertEquals ( "error message " + i , expected , actual ) ; String parseInt = actual . substring ( actual . indexOf ( ":" ) + 1 ) ; parseInt = parseInt . substring ( 0 , parseInt . indexOf ( ":" ) ) ; int lineNumber = Integer . parseInt ( parseInt ) ; Integer integer = Arrays . asList ( aWarnsExpected ) . contains ( lineNumber ) ? lineNumber : 0 ; assertEquals ( "error message " + i , ( long ) integer , ( long ) lineNumber ) ; } assertEquals ( "unexpected output: " + lnr . readLine ( ) , aExpected . length , errs ) ; aC . destroy ( ) ; } public String getCheckMessage ( Class aClass , String messageKey ) { Properties pr = new Properties ( ) ; try { pr . load ( aClass . getResourceAsStream ( "messages.properties" ) ) ; } catch ( IOException e ) { return null ; } return pr . getProperty ( messageKey ) ; } public String getCheckMessage ( Class aClass , String messageKey , Object ... arguments ) { return format ( getCheckMessage ( aClass , messageKey ) , arguments ) ; } public String getCheckMessage ( Map < String , String > messages , String messageKey , Object ... arguments ) { for ( Map . Entry < String , String > entry : messages . entrySet ( ) ) { if ( messageKey . equals ( entry . getKey ( ) ) ) { return format ( entry . getValue ( ) , arguments ) ; } } return null ; } }
package com . google . checkstyle . test . base ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . net . URL ; import java . util . ArrayList ; import java . util . List ; import java . util . Properties ; import java . util . regex . Pattern ; import org . apache . commons . io . FileUtils ; import com . puppycrawl . tools . checkstyle . ConfigurationLoader ; import com . puppycrawl . tools . checkstyle . PropertiesExpander ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . Utils ; public class ConfigurationBuilder extends BaseCheckTestSupport { private File mROOT ; private List < File > mFiles = new ArrayList < File > ( ) ; Configuration mConfig ; URL mUrl ; String mXmlName = "/google_checks.xml" ; Pattern warnPattern = Utils . createPattern ( ".*[ ]*//[ ]*warn[ ]*|/[*]warn[*]/" ) ; public ConfigurationBuilder ( File aROOT ) throws CheckstyleException , IOException { this . mROOT = aROOT ; mConfig = getConfigurationFromXML ( mXmlName , System . getProperties ( ) ) ; listFiles ( mFiles , mROOT , "java" ) ; } private Configuration getConfigurationFromXML ( String aConfigName , Properties aProps ) throws CheckstyleException { try { return ConfigurationLoader . loadConfiguration ( aConfigName , new PropertiesExpander ( aProps ) ) ; } catch ( final CheckstyleException e ) { System . out . println ( "Error loading configuration file" ) ; e . printStackTrace ( System . out ) ; System . exit ( 1 ) ; return null ; } } public Configuration getCheckConfig ( String aCheckName ) { for ( Configuration config : mConfig . getChildren ( ) ) { if ( "TreeWalker" . equals ( config . getName ( ) ) ) { for ( Configuration checkConfig : config . getChildren ( ) ) { if ( aCheckName . equals ( checkConfig . getName ( ) ) ) { return checkConfig ; } } } else if ( aCheckName . equals ( config . getName ( ) ) ) { return config ; } } return null ; } public String getFilePath ( String aFileName ) { String absoluteRootPath = mROOT . getAbsolutePath ( ) ; String rootPath = absoluteRootPath . substring ( 0 , absoluteRootPath . lastIndexOf ( "src" ) ) ; for ( File file : mFiles ) { if ( file . toString ( ) . endsWith ( aFileName + ".java" ) ) { return rootPath + file . toString ( ) ; } } return null ; } private static void listFiles ( final List < File > files , final File folder , final String extension ) { if ( folder . canRead ( ) ) { if ( folder . isDirectory ( ) ) { for ( final File f : folder . listFiles ( ) ) { listFiles ( files , f , extension ) ; } } else if ( folder . toString ( ) . endsWith ( "." + extension ) ) { files . add ( folder ) ; } } } public File getROOT ( ) { return mROOT ; } public Integer [ ] getLinesWithWarn ( String aFileName ) throws IOException { int lineNumber = 1 ; List < Integer > result = new ArrayList < Integer > ( ) ; try ( BufferedReader br = new BufferedReader ( new FileReader ( aFileName ) ) ) { for ( String line ; ( line = br . readLine ( ) ) != null ; ) { if ( warnPattern . matcher ( line ) . find ( ) ) { result . add ( lineNumber ) ; } lineNumber ++ ; } } return result . toArray ( new Integer [ result . size ( ) ] ) ; } }
package com . google . checkstyle . test . base ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . Utils ; public class IndentationConfigurationBuilder extends ConfigurationBuilder { private static final int TAB_WIDTH = 4 ; public IndentationConfigurationBuilder ( File aROOT ) throws CheckstyleException , IOException { super ( aROOT ) ; } @ Override public Integer [ ] getLinesWithWarn ( String aFileName ) throws IOException { return getLinesWithWarnAndCheckComments ( aFileName , TAB_WIDTH ) ; } private static final Pattern NONEMPTY_LINE_REGEX = Pattern . compile ( ".*?\\S+.*?" ) ; private static final Pattern LINE_WITH_COMMENT_REGEX = Pattern . compile ( ".*?\\S+.*?(//indent:(\\d+) exp:((>=\\d+)|(\\d+(,\\d+)*?))( warn)?)" ) ; private static final Pattern GET_INDENT_FROM_COMMENT_REGEX = Pattern . compile ( "//indent:(\\d+).*?" ) ; private static final Pattern MULTILEVEL_COMMENT_REGEX = Pattern . compile ( "//indent:\\d+ exp:(\\d+(,\\d+)+?)( warn)?" ) ; private static final Pattern SINGLELEVEL_COMMENT_REGEX = Pattern . compile ( "//indent:\\d+ exp:(\\d+)( warn)?" ) ; private static final Pattern NONSTRICT_LEVEL_COMMENT_REGEX = Pattern . compile ( "//indent:\\d+ exp:>=(\\d+)( warn)?" ) ; protected static Integer [ ] getLinesWithWarnAndCheckComments ( String aFileName , final int tabWidth ) throws IOException { int lineNumber = 1 ; List < Integer > result = new ArrayList < > ( ) ; try ( BufferedReader br = new BufferedReader ( new FileReader ( aFileName ) ) ) { for ( String line = br . readLine ( ) ; line != null ; line = br . readLine ( ) ) { Matcher match = LINE_WITH_COMMENT_REGEX . matcher ( line ) ; if ( match . matches ( ) ) { final String comment = match . group ( 1 ) ; final int indentInComment = getIndentFromComment ( comment ) ; final int actualIndent = getLineStart ( line , tabWidth ) ; if ( actualIndent != indentInComment ) { throw new RuntimeException ( String . format ( "File \"%1$s\" has incorrect indentation in comment." + "Line %2$d: comment:%3$d, actual:%4$d." , aFileName , lineNumber , indentInComment , actualIndent ) ) ; } if ( isWarnComment ( comment ) ) { result . add ( lineNumber ) ; } if ( ! isCommentConsistent ( comment ) ) { throw new RuntimeException ( String . format ( "File \"%1$s\" has inconsistent comment on line %2$d" , aFileName , lineNumber ) ) ; } } else if ( NONEMPTY_LINE_REGEX . matcher ( line ) . matches ( ) ) { throw new RuntimeException ( String . format ( "File \"%1$s\" has no indentation comment or its format " + "malformed. Error on line: %2$d(%3$s)" , aFileName , lineNumber , line ) ) ; } lineNumber ++ ; } } return result . toArray ( new Integer [ result . size ( ) ] ) ; } private static int getIndentFromComment ( String comment ) { final Matcher match = GET_INDENT_FROM_COMMENT_REGEX . matcher ( comment ) ; match . matches ( ) ; return Integer . parseInt ( match . group ( 1 ) ) ; } private static boolean isWarnComment ( String comment ) { return comment . endsWith ( " warn" ) ; } private static boolean isCommentConsistent ( String comment ) { final int indentInComment = getIndentFromComment ( comment ) ; final boolean isWarnComment = isWarnComment ( comment ) ; Matcher match ; match = MULTILEVEL_COMMENT_REGEX . matcher ( comment ) ; if ( match . matches ( ) ) { final String [ ] levels = match . group ( 1 ) . split ( "," ) ; final String indentInCommentStr = String . valueOf ( indentInComment ) ; final boolean containsActualLevel = Arrays . asList ( levels ) . contains ( indentInCommentStr ) ; return containsActualLevel && ! isWarnComment || ! containsActualLevel && isWarnComment ; } match = SINGLELEVEL_COMMENT_REGEX . matcher ( comment ) ; if ( match . matches ( ) ) { final int expectedLevel = Integer . parseInt ( match . group ( 1 ) ) ; return ( expectedLevel == indentInComment ) && ! isWarnComment || ( expectedLevel != indentInComment ) && isWarnComment ; } match = NONSTRICT_LEVEL_COMMENT_REGEX . matcher ( comment ) ; if ( match . matches ( ) ) { final int expectedMinimalIndent = Integer . parseInt ( match . group ( 1 ) ) ; return ( indentInComment >= expectedMinimalIndent ) && ! isWarnComment || ( indentInComment < expectedMinimalIndent ) && isWarnComment ; } throw new IllegalArgumentException ( ) ; } private static int getLineStart ( String line , final int tabWidth ) { for ( int index = 0 ; index < line . length ( ) ; ++ index ) { if ( ! Character . isWhitespace ( line . charAt ( index ) ) ) { return Utils . lengthExpandedTabs ( line , index , tabWidth ) ; } } return 0 ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import org . junit . Test ; import static com . puppycrawl . tools . checkstyle . checks . naming . AbstractNameCheck . MSG_INVALID_PATTERN ; public class LocalVariableNameCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( LocalVariableNameCheck . class ) ; final String pattern = "^[a-z][a-zA-Z0-9]*$" ; final String [ ] expected = { "119:13: " + getCheckMessage ( MSG_INVALID_PATTERN , "ABC" , pattern ) , "130:18: " + getCheckMessage ( MSG_INVALID_PATTERN , "I" , pattern ) , "132:20: " + getCheckMessage ( MSG_INVALID_PATTERN , "InnerBlockVariable" , pattern ) , "207:21: " + getCheckMessage ( MSG_INVALID_PATTERN , "O" , pattern ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testInnerClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( LocalVariableNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "InputInner.java" ) , expected ) ; } @ Test public void testCatchParameter ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( LocalVariableNameCheck . class ) ; checkConfig . addAttribute ( "tokens" , "PARAMETER_DEF" ) ; checkConfig . addAttribute ( "format" , "^e$" ) ; final String pattern = "^e$" ; final String [ ] expected = { "74:24: " + getCheckMessage ( MSG_INVALID_PATTERN , "ex" , pattern ) , } ; verify ( checkConfig , getPath ( "InputEmptyStatement.java" ) , expected ) ; } @ Test public void testLoopVariables ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( LocalVariableNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^[a-z]{2,}[a-zA-Z0-9]*$" ) ; checkConfig . addAttribute ( "allowOneCharVarInForLoop" , "true" ) ; final String pattern = "^[a-z]{2,}[a-zA-Z0-9]*$" ; final String [ ] expected = { "19:21: " + getCheckMessage ( MSG_INVALID_PATTERN , "i" , pattern ) , "25:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "Index" , pattern ) , } ; verify ( checkConfig , getPath ( "InputOneCharInintVarName.java" ) , expected ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule412nonemptyblocks ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . blocks . LeftCurlyCheck ; import com . puppycrawl . tools . checkstyle . checks . blocks . RightCurlyCheck ; import com . puppycrawl . tools . checkstyle . checks . blocks . RightCurlyOption ; public class LeftCurlyRightCurlyTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void leftCurlyBracesTest ( ) throws IOException , Exception { String checkMessage = getCheckMessage ( LeftCurlyCheck . class , "line.previous" , "{" ) ; final String [ ] expected = { "4:1: " + checkMessage , "7:5: " + checkMessage , "13:5: " + checkMessage , "26:5: " + checkMessage , "43:5: " + checkMessage , "61:5: " + checkMessage , "97:5: " + checkMessage , } ; Configuration checkConfig = builder . getCheckConfig ( "LeftCurly" ) ; String filePath = builder . getFilePath ( "LeftCurlyInput_Braces" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void leftCurlyAnnotationsTest ( ) throws IOException , Exception { String checkMessagePrevious = getCheckMessage ( LeftCurlyCheck . class , "line.previous" , "{" ) ; final String [ ] expected = { "10:1: " + checkMessagePrevious , "14:5: " + checkMessagePrevious , "21:5: " + checkMessagePrevious , "27:5: " + checkMessagePrevious , "50:5: " + checkMessagePrevious , } ; Configuration checkConfig = builder . getCheckConfig ( "LeftCurly" ) ; String filePath = builder . getFilePath ( "LeftCurlyInput_Annotations" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void leftCurlyMethodsTest ( ) throws IOException , Exception { String checkMessagePrevious = getCheckMessage ( LeftCurlyCheck . class , "line.previous" , "{" ) ; final String [ ] expected = { "4:1: " + checkMessagePrevious , "9:5: " + checkMessagePrevious , "16:5: " + checkMessagePrevious , "19:5: " + checkMessagePrevious , "23:5: " + checkMessagePrevious , "31:1: " + checkMessagePrevious , "33:5: " + checkMessagePrevious , "38:9: " + checkMessagePrevious , "41:9: " + checkMessagePrevious , "45:9: " + checkMessagePrevious , "57:5: " + checkMessagePrevious , "61:5: " + checkMessagePrevious , "69:5: " + checkMessagePrevious , "72:5: " + checkMessagePrevious , "76:5: " + checkMessagePrevious , } ; Configuration checkConfig = builder . getCheckConfig ( "LeftCurly" ) ; String filePath = builder . getFilePath ( "LeftCurlyInput_Method" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void rightCurlyTestAlone ( ) throws Exception { DefaultConfiguration newCheckConfig = createCheckConfig ( RightCurlyCheck . class ) ; newCheckConfig . addAttribute ( "option" , RightCurlyOption . ALONE . toString ( ) ) ; newCheckConfig . addAttribute ( "tokens" , "CLASS_DEF, METHOD_DEF, CTOR_DEF" ) ; String checkMessageNew = getCheckMessage ( RightCurlyCheck . class , "line.new" , "}" ) ; final String [ ] expected = { "97:6: " + checkMessageNew , "108:6: " + checkMessageNew , "122:6: " + checkMessageNew , } ; String filePath = builder . getFilePath ( "RightCurlyInput_Other" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( newCheckConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule462horizontalwhitespace ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . whitespace . GenericWhitespaceCheck ; import com . puppycrawl . tools . checkstyle . checks . whitespace . WhitespaceAroundCheck ; public class WhitespaceAroundTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void whitespaceAroundBasicTest ( ) throws IOException , Exception { Configuration checkConfig = builder . getCheckConfig ( "WhitespaceAround" ) ; String msgPreceded = "ws.notPreceded" ; String msgFollowed = "ws.notFollowed" ; final String [ ] expected = { "10:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "=" ) , "12:24: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "=" ) , "20:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "=" ) , "21:10: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "=" ) , "22:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "+=" ) , "23:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "-=" ) , "31:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "synchronized" ) , "33:14: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "{" ) , "35:37: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "{" ) , "52:11: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "if" ) , "70:19: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "return" ) , "92:26: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "==" ) , "98:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "*" ) , "113:18: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "%" ) , "114:20: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "%" ) , "115:18: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "%" ) , "117:18: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "/" ) , "118:20: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "/" ) , "147:15: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "assert" ) , "150:20: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , ":" ) , } ; String filePath = builder . getFilePath ( "WhitespaceAroundInput_Basic" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void whitespaceAroundGenericsTest ( ) throws IOException , Exception { String msgPreceded = "ws.preceded" ; String msgFollowed = "ws.followed" ; Configuration checkConfig = builder . getCheckConfig ( "GenericWhitespace" ) ; final String [ ] expected = { "12:16: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "<" ) , "12:18: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "<" ) , "12:36: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "<" ) , "12:38: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "<" ) , "12:47: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , ">" ) , "12:49: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , ">" ) , "12:49: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , ">" ) , "14:32: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "<" ) , "14:34: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "<" ) , "14:45: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , ">" ) , "15:32: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "<" ) , "15:34: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "<" ) , "15:45: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , ">" ) , "20:38: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "<" ) , "20:40: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "<" ) , "20:61: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , ">" ) , } ; String filePath = builder . getFilePath ( "WhitespaceAroundInput_Generics" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void whitespaceAroundEmptyTypesCyclesTest ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "WhitespaceAround" ) ; String filePath = builder . getFilePath ( "WhitespaceAroundnput_EmptyTypesAndCycles" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void genericWhitespaceTest ( ) throws IOException , Exception { String msgPreceded = "ws.preceded" ; String msgFollowed = "ws.followed" ; String msgNotPreceded = "ws.notPreceded" ; String msgIllegalFollow = "ws.illegalFollow" ; Configuration checkConfig = builder . getCheckConfig ( "GenericWhitespace" ) ; final String [ ] expected = { "16:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "<" ) , "16:15: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "<" ) , "16:23: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , ">" ) , "16:43: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "<" ) , "16:45: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "<" ) , "16:53: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , ">" ) , "17:13: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "<" ) , "17:15: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "<" ) , "17:20: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "<" ) , "17:22: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "<" ) , "17:30: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , ">" ) , "17:32: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , ">" ) , "17:32: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , ">" ) , "17:52: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "<" ) , "17:54: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "<" ) , "17:59: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "<" ) , "17:61: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , "<" ) , "17:69: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , ">" ) , "17:71: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , ">" ) , "17:71: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , ">" ) , "30:17: " + getCheckMessage ( checkConfig . getMessages ( ) , msgNotPreceded , "<" ) , "30:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgIllegalFollow , ">" ) , "42:21: " + getCheckMessage ( checkConfig . getMessages ( ) , msgPreceded , "<" ) , "42:30: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , ">" ) , "60:60: " + getCheckMessage ( checkConfig . getMessages ( ) , msgNotPreceded , "&" ) , "63:60: " + getCheckMessage ( checkConfig . getMessages ( ) , msgFollowed , ">" ) , } ; String filePath = builder . getFilePath ( "GenericWhitespaceInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule461verticalwhitespace ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . whitespace . EmptyLineSeparatorCheck ; public class EmptyLineSeparatorTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void emptyLineSeparatorTest ( ) throws IOException , Exception { java . lang . Class < EmptyLineSeparatorCheck > clazz = EmptyLineSeparatorCheck . class ; String messageKey = "empty.line.separator" ; final String [ ] expected = { "19: " + getCheckMessage ( clazz , messageKey , "package" ) , "20: " + getCheckMessage ( clazz , messageKey , "import" ) , "33: " + getCheckMessage ( clazz , messageKey , "CLASS_DEF" ) , "37: " + getCheckMessage ( clazz , messageKey , "STATIC_INIT" ) , "75: " + getCheckMessage ( clazz , messageKey , "INTERFACE_DEF" ) , "82: " + getCheckMessage ( clazz , messageKey , "INSTANCE_INIT" ) , "113: " + getCheckMessage ( clazz , messageKey , "CLASS_DEF" ) , "119: " + getCheckMessage ( clazz , messageKey , "VARIABLE_DEF" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "EmptyLineSeparator" ) ; String filePath = builder . getFilePath ( "EmptyLineSeparatorInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule4832nocstylearray ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . ArrayTypeStyleCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class ArrayTypeStyleTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void arrayTypeStyleTest ( ) throws IOException , Exception { String msg = getCheckMessage ( ArrayTypeStyleCheck . class , "array.type.style" ) ; final String [ ] expected = { "9:23: " + msg , "15:44: " + msg , "21:20: " + msg , "22:23: " + msg , "41:16: " + msg , "42:19: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "ArrayTypeStyle" ) ; String filePath = builder . getFilePath ( "ArrayTypeStyleInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule411bracesareused ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . blocks . NeedBracesCheck ; public class NeedBracesTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void needBracesTest ( ) throws IOException , Exception { Class < NeedBracesCheck > clazz = NeedBracesCheck . class ; String messageKey = "needBraces" ; final String [ ] expected = { "29: " + getCheckMessage ( clazz , messageKey , "do" ) , "41: " + getCheckMessage ( clazz , messageKey , "while" ) , "42: " + getCheckMessage ( clazz , messageKey , "while" ) , "44: " + getCheckMessage ( clazz , messageKey , "while" ) , "45: " + getCheckMessage ( clazz , messageKey , "if" ) , "58: " + getCheckMessage ( clazz , messageKey , "for" ) , "59: " + getCheckMessage ( clazz , messageKey , "for" ) , "61: " + getCheckMessage ( clazz , messageKey , "for" ) , "63: " + getCheckMessage ( clazz , messageKey , "if" ) , "82: " + getCheckMessage ( clazz , messageKey , "if" ) , "83: " + getCheckMessage ( clazz , messageKey , "if" ) , "85: " + getCheckMessage ( clazz , messageKey , "if" ) , "87: " + getCheckMessage ( clazz , messageKey , "else" ) , "89: " + getCheckMessage ( clazz , messageKey , "if" ) , "97: " + getCheckMessage ( clazz , messageKey , "else" ) , "99: " + getCheckMessage ( clazz , messageKey , "if" ) , "100: " + getCheckMessage ( clazz , messageKey , "if" ) , "126: " + getCheckMessage ( clazz , messageKey , "while" ) , "129: " + getCheckMessage ( clazz , messageKey , "do" ) , "135: " + getCheckMessage ( clazz , messageKey , "if" ) , "138: " + getCheckMessage ( clazz , messageKey , "if" ) , "139: " + getCheckMessage ( clazz , messageKey , "else" ) , "144: " + getCheckMessage ( clazz , messageKey , "for" ) , "147: " + getCheckMessage ( clazz , messageKey , "for" ) , "157: " + getCheckMessage ( clazz , messageKey , "while" ) , "160: " + getCheckMessage ( clazz , messageKey , "do" ) , "166: " + getCheckMessage ( clazz , messageKey , "if" ) , "169: " + getCheckMessage ( clazz , messageKey , "if" ) , "170: " + getCheckMessage ( clazz , messageKey , "else" ) , "175: " + getCheckMessage ( clazz , messageKey , "for" ) , "178: " + getCheckMessage ( clazz , messageKey , "for" ) , "189: " + getCheckMessage ( clazz , messageKey , "while" ) , "192: " + getCheckMessage ( clazz , messageKey , "do" ) , "198: " + getCheckMessage ( clazz , messageKey , "if" ) , "201: " + getCheckMessage ( clazz , messageKey , "if" ) , "202: " + getCheckMessage ( clazz , messageKey , "else" ) , "207: " + getCheckMessage ( clazz , messageKey , "for" ) , "210: " + getCheckMessage ( clazz , messageKey , "for" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "NeedBraces" ) ; String filePath = builder . getFilePath ( "NeedBracesInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule4843defaultcasepresent ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . coding . MissingSwitchDefaultCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class MissingSwitchDefaultTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void missingSwitchDefaultTest ( ) throws IOException , Exception { String msg = getCheckMessage ( MissingSwitchDefaultCheck . class , "missing.switch.default" ) ; final String [ ] expected = { "11:9: " + msg , "19:9: " + msg , "23:9: " + msg , "31:13: " + msg , "38:21: " + msg , "42:21: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "MissingSwitchDefault" ) ; String filePath = builder . getFilePath ( "MissingSwitchDefaultInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule4822variabledistance ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . coding . VariableDeclarationUsageDistanceCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class VariableDeclarationUsageDistanceTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void arrayTypeStyleTest ( ) throws IOException , Exception { String msg = "variable.declaration.usage.distance" ; String msgExt = "variable.declaration.usage.distance.extend" ; Class < VariableDeclarationUsageDistanceCheck > clazz = VariableDeclarationUsageDistanceCheck . class ; final String [ ] expected = { "71: " + getCheckMessage ( clazz , msgExt , "count" , 4 , 3 ) , "219: " + getCheckMessage ( clazz , msgExt , "t" , 5 , 3 ) , "479: " + getCheckMessage ( clazz , msgExt , "myOption" , 7 , 3 ) , "491: " + getCheckMessage ( clazz , msgExt , "myOption" , 6 , 3 ) , } ; Configuration checkConfig = builder . getCheckConfig ( "VariableDeclarationUsageDistance" ) ; String filePath = builder . getFilePath ( "InputVariableDeclarationUsageDistanceCheck" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule4821onevariablepreline ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . coding . MultipleVariableDeclarationsCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class MultipleVariableDeclarationsTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void multipleVariableDeclarationsTest ( ) throws IOException , Exception { String msgComma = getCheckMessage ( MultipleVariableDeclarationsCheck . class , "multiple.variable.declarations.comma" ) ; String msg = getCheckMessage ( MultipleVariableDeclarationsCheck . class , "multiple.variable.declarations" ) ; final String [ ] expected = { "5:5: " + msgComma , "6:5: " + msg , "9:9: " + msgComma , "10:9: " + msg , "14:5: " + msg , "17:5: " + msg , "31:9: " + msgComma , "32:9: " + msg , "35:13: " + msgComma , "36:13: " + msg , "40:9: " + msg , "43:9: " + msg , "57:13: " + msgComma , "58:13: " + msg , "61:17: " + msgComma , "62:17: " + msg , "66:13: " + msg , "69:13: " + msg , "86:5: " + msgComma , "89:5: " + msgComma , } ; Configuration checkConfig = builder . getCheckConfig ( "MultipleVariableDeclarations" ) ; String filePath = builder . getFilePath ( "MultipleVariableDeclarationsInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule44cloumunlimit ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . sizes . LineLengthCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class LineLengthTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void lineLengthTest ( ) throws IOException , Exception { final String [ ] expected = { "5: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 112 ) , "29: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 183 ) , "46: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 131 ) , "47: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 124 ) , "48: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 113 ) , "50: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 116 ) , "53: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 131 ) , "57: " + getCheckMessage ( LineLengthCheck . class , "maxLineLen" , 100 , 116 ) , } ; Configuration checkConfig = builder . getCheckConfig ( "LineLength" ) ; String filePath = builder . getFilePath ( "LineLengthInput2" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule488numericliterals ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class UpperEllTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void upperEllTest ( ) throws IOException , Exception { final String [ ] expected = { "6:36: Should use uppercase 'L'." , "12:27: Should use uppercase 'L'." , "14:32: Should use uppercase 'L'." , "17:19: Should use uppercase 'L'." , "21:29: Should use uppercase 'L'." , "22:22: Should use uppercase 'L'." , "25:15: Should use uppercase 'L'." , "34:47: Should use uppercase 'L'." , "40:31: Should use uppercase 'L'." , "42:36: Should use uppercase 'L'." , "45:23: Should use uppercase 'L'." , "50:33: Should use uppercase 'L'." , "51:26: Should use uppercase 'L'." , "56:23: Should use uppercase 'L'." , "65:48: Should use uppercase 'L'." , "71:39: Should use uppercase 'L'." , "73:44: Should use uppercase 'L'." , "76:31: Should use uppercase 'L'." , "80:41: Should use uppercase 'L'." , "81:34: Should use uppercase 'L'." , "84:27: Should use uppercase 'L'." , "97:46: Should use uppercase 'L'." , "99:29: Should use uppercase 'L'." , "100:22: Should use uppercase 'L'." , } ; Configuration checkConfig = builder . getCheckConfig ( "UpperEll" ) ; String filePath = builder . getFilePath ( "UpperEllInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import static com . puppycrawl . tools . checkstyle . checks . naming . AbstractNameCheck . MSG_INVALID_PATTERN ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class TypeParameterNameTest extends BaseCheckTestSupport { @ Test public void testClassDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ClassTypeParameterNameCheck . class ) ; final String pattern = "^[A-Z]$" ; final String [ ] expected = { "5:38: " + getCheckMessage ( MSG_INVALID_PATTERN , "t" , pattern ) , "13:14: " + getCheckMessage ( MSG_INVALID_PATTERN , "foo" , pattern ) , "27:24: " + getCheckMessage ( MSG_INVALID_PATTERN , "foo" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputTypeParameterName.java" ) , expected ) ; } @ Test public void testMethodDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodTypeParameterNameCheck . class ) ; final String pattern = "^[A-Z]$" ; final String [ ] expected = { "7:13: " + getCheckMessage ( MSG_INVALID_PATTERN , "TT" , pattern ) , "9:6: " + getCheckMessage ( MSG_INVALID_PATTERN , "e_e" , pattern ) , "19:6: " + getCheckMessage ( MSG_INVALID_PATTERN , "Tfo$o2T" , pattern ) , "23:6: " + getCheckMessage ( MSG_INVALID_PATTERN , "foo" , pattern ) , "28:10: " + getCheckMessage ( MSG_INVALID_PATTERN , "_fo" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputTypeParameterName.java" ) , expected ) ; } @ Test public void testInterfaceDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( InterfaceTypeParameterNameCheck . class ) ; final String pattern = "^[A-Z]$" ; final String [ ] expected = { "48:15: " + getCheckMessage ( MSG_INVALID_PATTERN , "Input" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputTypeParameterName.java" ) , expected ) ; } @ Test public void testClassFooName ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( ClassTypeParameterNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^foo$" ) ; final String pattern = "^foo$" ; final String [ ] expected = { "5:38: " + getCheckMessage ( MSG_INVALID_PATTERN , "t" , pattern ) , "33:18: " + getCheckMessage ( MSG_INVALID_PATTERN , "T" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputTypeParameterName.java" ) , expected ) ; } @ Test public void testMethodFooName ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodTypeParameterNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^foo$" ) ; final String pattern = "^foo$" ; final String [ ] expected = { "7:13: " + getCheckMessage ( MSG_INVALID_PATTERN , "TT" , pattern ) , "9:6: " + getCheckMessage ( MSG_INVALID_PATTERN , "e_e" , pattern ) , "19:6: " + getCheckMessage ( MSG_INVALID_PATTERN , "Tfo$o2T" , pattern ) , "28:10: " + getCheckMessage ( MSG_INVALID_PATTERN , "_fo" , pattern ) , "35:6: " + getCheckMessage ( MSG_INVALID_PATTERN , "E" , pattern ) , "37:14: " + getCheckMessage ( MSG_INVALID_PATTERN , "T" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputTypeParameterName.java" ) , expected ) ; } @ Test public void testInterfaceFooName ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( InterfaceTypeParameterNameCheck . class ) ; checkConfig . addAttribute ( "format" , "^foo$" ) ; final String pattern = "^foo$" ; final String [ ] expected = { "48:15: " + getCheckMessage ( MSG_INVALID_PATTERN , "Input" , pattern ) , "52:24: " + getCheckMessage ( MSG_INVALID_PATTERN , "T" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputTypeParameterName.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { AbstractTypeParameterNameCheck typeParameterNameCheckObj = new ClassTypeParameterNameCheck ( ) ; int [ ] actual = typeParameterNameCheckObj . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . TYPE_PARAMETER , } ; Assert . assertNotNull ( actual ) ; Assert . assertArrayEquals ( expected , actual ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule4842fallthrow ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . checks . coding . FallThroughCheck ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class FallThroughTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void fallThroughTest ( ) throws IOException , Exception { String msg = getCheckMessage ( FallThroughCheck . class , "fall.through" ) ; final String [ ] expected = { "14:13: " + msg , "38:13: " + msg , "53:13: " + msg , "70:13: " + msg , "87:13: " + msg , "105:13: " + msg , "123:13: " + msg , "369:11: " + msg , "372:11: " + msg , "374:41: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "FallThrough" ) ; String filePath = builder . getFilePath ( "FallThroughInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule4841indentation ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . google . checkstyle . test . base . IndentationConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . ArrayTypeStyleCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class IndentationTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new IndentationConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void correctClassTest ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "Indentation" ) ; String filePath = builder . getFilePath ( "IndentationCorrectClassInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void correctFieldTest ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "Indentation" ) ; String filePath = builder . getFilePath ( "IndentationCorrectFieldAndParameterInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void correctForTest ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "Indentation" ) ; String filePath = builder . getFilePath ( "IndentationCorrectForAndParameterInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void correctIfTest ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "Indentation" ) ; String filePath = builder . getFilePath ( "IndentationCorrectIfAndParameterInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void correctTest ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "Indentation" ) ; String filePath = builder . getFilePath ( "IndentationCorrectInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void correctReturnTest ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "Indentation" ) ; String filePath = builder . getFilePath ( "IndentationCorrectReturnAndParameterInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void correctWhileTest ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "Indentation" ) ; String filePath = builder . getFilePath ( "IndentationCorrectWhileDoWhileAndParameterInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule413emptyblocks ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . blocks . EmptyBlockCheck ; public class EmptyBlockTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void emptyBlockTest ( ) throws IOException , Exception { final String [ ] expected = { "19:21: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "22:34: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "26:21: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "28:20: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "switch" ) , "68:25: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "71:38: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "75:25: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "77:24: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "switch" ) , "98:29: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "101:42: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "105:29: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "107:28: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "switch" ) , "126:16: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "else" ) , "172:28: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "173:14: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "else" ) , "175:21: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "179:14: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "else" ) , "181:21: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "182:26: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "195:20: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "else" ) , "241:32: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "242:18: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "else" ) , "244:25: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "248:18: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "else" ) , "250:25: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "251:30: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "264:24: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "else" ) , "310:36: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "311:22: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "else" ) , "313:29: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "317:22: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "else" ) , "319:29: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , "320:34: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "if" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "EmptyBlock" ) ; String filePath = builder . getFilePath ( "EmptyBlockInput_Basic" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void emptyBlockTestCatch ( ) throws IOException , Exception { final String [ ] expected = { "29:17: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "finally" ) , "50:21: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "finally" ) , "72:21: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "finally" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "EmptyBlock" ) ; String filePath = builder . getFilePath ( "EmptyBlockInputCatch" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule413emptyblocks ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . blocks . EmptyCatchBlockCheck ; public class EmptyCatchBlockTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void emptyBlockTestCatch ( ) throws IOException , Exception { final String [ ] expected = { "28: " + getCheckMessage ( EmptyCatchBlockCheck . class , "catch.block.empty" ) , "49: " + getCheckMessage ( EmptyCatchBlockCheck . class , "catch.block.empty" ) , "71: " + getCheckMessage ( EmptyCatchBlockCheck . class , "catch.block.empty" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "EmptyCatchBlock" ) ; String filePath = builder . getFilePath ( "EmptyBlockInputCatch" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void testNoViolations ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "EmptyCatchBlock" ) ; String filePath = builder . getFilePath ( "EmptyCatchBlockNoViolationsInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void testViolationsByComment ( ) throws IOException , Exception { final String [ ] expected = { "19: " + getCheckMessage ( EmptyCatchBlockCheck . class , "catch.block.empty" ) , "27: " + getCheckMessage ( EmptyCatchBlockCheck . class , "catch.block.empty" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "EmptyCatchBlock" ) ; String filePath = builder . getFilePath ( "EmptyCatchBlockViolationsByCommentInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void testViolationsByVariableName ( ) throws IOException , Exception { final String [ ] expected = { "19: " + getCheckMessage ( EmptyCatchBlockCheck . class , "catch.block.empty" ) , "35: " + getCheckMessage ( EmptyCatchBlockCheck . class , "catch.block.empty" ) , "51: " + getCheckMessage ( EmptyCatchBlockCheck . class , "catch.block.empty" ) , "58: " + getCheckMessage ( EmptyCatchBlockCheck . class , "catch.block.empty" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "EmptyCatchBlock" ) ; String filePath = builder . getFilePath ( "EmptyCatchBlockViolationsByVariableNameInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule487modifiers ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . modifier . ModifierOrderCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class ModifierOrderTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void modifierOrderTest ( ) throws IOException , Exception { Class < ModifierOrderCheck > clazz = ModifierOrderCheck . class ; String msgMod = "mod.order" ; String msgAnnotation = "annotation.order" ; final String [ ] expected = { "3:10: " + getCheckMessage ( clazz , msgMod , "abstract" ) , "5:19: " + getCheckMessage ( clazz , msgMod , "private" ) , "7:18: " + getCheckMessage ( clazz , msgMod , "public" ) , "15:14: " + getCheckMessage ( clazz , msgMod , "private" ) , "25:13: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "30:13: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "40:34: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation4" ) , "46:14: " + getCheckMessage ( clazz , msgMod , "protected" ) , "48:18: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "50:40: " + getCheckMessage ( clazz , msgMod , "final" ) , "52:29: " + getCheckMessage ( clazz , msgMod , "static" ) , "54:18: " + getCheckMessage ( clazz , msgMod , "final" ) , "56:49: " + getCheckMessage ( clazz , msgMod , "private" ) , "58:20: " + getCheckMessage ( clazz , msgMod , "synchronized" ) , "60:29: " + getCheckMessage ( clazz , msgMod , "protected" ) , "62:14: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "80:11: " + getCheckMessage ( clazz , msgMod , "private" ) , "96:15: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "98:12: " + getCheckMessage ( clazz , msgMod , "protected" ) , "102:12: " + getCheckMessage ( clazz , msgMod , "synchronized" ) , "104:12: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "106:19: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "108:18: " + getCheckMessage ( clazz , msgMod , "static" ) , "110:25: " + getCheckMessage ( clazz , msgMod , "private" ) , "137:27: " + getCheckMessage ( clazz , msgMod , "private" ) , "139:26: " + getCheckMessage ( clazz , msgMod , "public" ) , "143:23: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "145:26: " + getCheckMessage ( clazz , msgMod , "protected" ) , "147:20: " + getCheckMessage ( clazz , msgMod , "synchronized" ) , "149:20: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "151:20: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "153:33: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "155:26: " + getCheckMessage ( clazz , msgMod , "private" ) , "168:35: " + getCheckMessage ( clazz , msgMod , "private" ) , "170:34: " + getCheckMessage ( clazz , msgMod , "public" ) , "172:35: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "174:31: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "176:34: " + getCheckMessage ( clazz , msgMod , "protected" ) , "178:28: " + getCheckMessage ( clazz , msgMod , "synchronized" ) , "182:28: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "184:41: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "186:34: " + getCheckMessage ( clazz , msgMod , "private" ) , "197:27: " + getCheckMessage ( clazz , msgMod , "private" ) , "199:26: " + getCheckMessage ( clazz , msgMod , "public" ) , "203:22: " + getCheckMessage ( clazz , msgMod , "protected" ) , "205:26: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , "207:41: " + getCheckMessage ( clazz , msgMod , "final" ) , "209:37: " + getCheckMessage ( clazz , msgMod , "final" ) , "211:26: " + getCheckMessage ( clazz , msgMod , "final" ) , "213:50: " + getCheckMessage ( clazz , msgMod , "private" ) , "215:28: " + getCheckMessage ( clazz , msgMod , "synchronized" ) , "217:37: " + getCheckMessage ( clazz , msgMod , "protected" ) , "219:22: " + getCheckMessage ( clazz , msgAnnotation , "@MyAnnotation2" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "ModifierOrder" ) ; String filePath = builder . getFilePath ( "ModifierOrderInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule43onestatement ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . coding . OneStatementPerLineCheck ; public class OneStatementPerLineTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void oneStatmentTest ( ) throws IOException , Exception { String msg = getCheckMessage ( OneStatementPerLineCheck . class , "multiple.statements.line" ) ; final String [ ] expected = { "45:18: " + msg , "47:19: " + msg , "49:40: " + msg , "52:23: " + msg , "53:33: " + msg , "54:55: " + msg , "63:11: " + msg , "90:22: " + msg , "92:23: " + msg , "94:44: " + msg , "97:27: " + msg , "98:37: " + msg , "99:59: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "OneStatementPerLine" ) ; String filePath = builder . getFilePath ( "OneStatementPerLineInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule451wheretobreack ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . blocks . RightCurlyCheck ; import com . puppycrawl . tools . checkstyle . checks . blocks . RightCurlyOption ; import com . puppycrawl . tools . checkstyle . checks . whitespace . OperatorWrapCheck ; import com . puppycrawl . tools . checkstyle . checks . whitespace . WrapOption ; public class OperatorWrapTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void operatorWrapTest ( ) throws IOException , Exception { Class < OperatorWrapCheck > clazz = OperatorWrapCheck . class ; String messageKey = "line.new" ; final String [ ] expected = { "10:27: " + getCheckMessage ( clazz , messageKey , "+" ) , "11:28: " + getCheckMessage ( clazz , messageKey , "-" ) , "19:27: " + getCheckMessage ( clazz , messageKey , "&&" ) , "53:42: " + getCheckMessage ( clazz , messageKey , "?" ) , "57:27: " + getCheckMessage ( clazz , messageKey , "!=" ) , "63:30: " + getCheckMessage ( clazz , messageKey , "==" ) , "69:27: " + getCheckMessage ( clazz , messageKey , ">" ) , "75:35: " + getCheckMessage ( clazz , messageKey , "||" ) , "98:46: " + getCheckMessage ( clazz , messageKey , "?" ) , "102:31: " + getCheckMessage ( clazz , messageKey , "!=" ) , "108:34: " + getCheckMessage ( clazz , messageKey , "==" ) , "114:31: " + getCheckMessage ( clazz , messageKey , ">" ) , "120:39: " + getCheckMessage ( clazz , messageKey , "||" ) , "144:46: " + getCheckMessage ( clazz , messageKey , "?" ) , "148:31: " + getCheckMessage ( clazz , messageKey , "!=" ) , "154:34: " + getCheckMessage ( clazz , messageKey , "==" ) , "160:31: " + getCheckMessage ( clazz , messageKey , ">" ) , "166:39: " + getCheckMessage ( clazz , messageKey , "||" ) , "185:38: " + getCheckMessage ( clazz , messageKey , "?" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "OperatorWrap" ) ; String filePath = builder . getFilePath ( "OperatorWrapInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void operatorWrapTestAssign ( ) throws Exception { DefaultConfiguration newCheckConfig = createCheckConfig ( OperatorWrapCheck . class ) ; newCheckConfig . addAttribute ( "option" , WrapOption . EOL . toString ( ) ) ; newCheckConfig . addAttribute ( "tokens" , "ASSIGN, DIV_ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN," + "STAR_ASSIGN, MOD_ASSIGN, SR_ASSIGN, BSR_ASSIGN, SL_ASSIGN, BXOR_ASSIGN," + "BOR_ASSIGN, BAND_ASSIGN" ) ; String messageKey = "line.previous" ; Class < OperatorWrapCheck > clazz = OperatorWrapCheck . class ; final String [ ] expected = { "28:13: " + getCheckMessage ( clazz , messageKey , "=" ) , "177:9: " + getCheckMessage ( clazz , messageKey , "=" ) , "207:14: " + getCheckMessage ( clazz , messageKey , "+=" ) , "211:14: " + getCheckMessage ( clazz , messageKey , "-=" ) , "215:14: " + getCheckMessage ( clazz , messageKey , "/=" ) , "219:14: " + getCheckMessage ( clazz , messageKey , "*=" ) , "223:14: " + getCheckMessage ( clazz , messageKey , "%=" ) , "227:14: " + getCheckMessage ( clazz , messageKey , "^=" ) , "231:14: " + getCheckMessage ( clazz , messageKey , "|=" ) , "235:14: " + getCheckMessage ( clazz , messageKey , "&=" ) , "239:13: " + getCheckMessage ( clazz , messageKey , ">>=" ) , "243:13: " + getCheckMessage ( clazz , messageKey , ">>>=" ) , "247:13: " + getCheckMessage ( clazz , messageKey , "<<=" ) , "257:18: " + getCheckMessage ( clazz , messageKey , "+=" ) , "261:18: " + getCheckMessage ( clazz , messageKey , "-=" ) , "265:18: " + getCheckMessage ( clazz , messageKey , "/=" ) , "269:18: " + getCheckMessage ( clazz , messageKey , "*=" ) , "273:18: " + getCheckMessage ( clazz , messageKey , "%=" ) , "277:18: " + getCheckMessage ( clazz , messageKey , "^=" ) , "281:18: " + getCheckMessage ( clazz , messageKey , "|=" ) , "285:18: " + getCheckMessage ( clazz , messageKey , "&=" ) , "289:17: " + getCheckMessage ( clazz , messageKey , ">>=" ) , "293:17: " + getCheckMessage ( clazz , messageKey , ">>>=" ) , "297:17: " + getCheckMessage ( clazz , messageKey , "<<=" ) , "308:18: " + getCheckMessage ( clazz , messageKey , "+=" ) , "312:18: " + getCheckMessage ( clazz , messageKey , "-=" ) , "316:18: " + getCheckMessage ( clazz , messageKey , "/=" ) , "320:18: " + getCheckMessage ( clazz , messageKey , "*=" ) , "324:18: " + getCheckMessage ( clazz , messageKey , "%=" ) , "328:18: " + getCheckMessage ( clazz , messageKey , "^=" ) , "332:18: " + getCheckMessage ( clazz , messageKey , "|=" ) , "336:18: " + getCheckMessage ( clazz , messageKey , "&=" ) , "340:17: " + getCheckMessage ( clazz , messageKey , ">>=" ) , "344:17: " + getCheckMessage ( clazz , messageKey , ">>>=" ) , "348:17: " + getCheckMessage ( clazz , messageKey , "<<=" ) , } ; String filePath = builder . getFilePath ( "OperatorWrapAssignInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( newCheckConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule451wheretobreack ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . whitespace . MethodParamPadCheck ; public class MethodParamPadTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void operatorWrapTest ( ) throws IOException , Exception { Class < MethodParamPadCheck > clazz = MethodParamPadCheck . class ; String messageKey = "line.previous" ; final String [ ] expected = { "83:9: " + getCheckMessage ( clazz , messageKey , "(" ) , "128:13: " + getCheckMessage ( clazz , messageKey , "(" ) , "130:9: " + getCheckMessage ( clazz , messageKey , "(" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "MethodParamPad" ) ; String filePath = builder . getFilePath ( "MethodParamPadInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule451wheretobreack ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . whitespace . SeparatorWrapCheck ; public class SeparatorWrapTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void separatorWrapTest ( ) throws IOException , Exception { final String [ ] expected = { "28:30: " + getCheckMessage ( SeparatorWrapCheck . class , "line.new" , "." ) , } ; Configuration checkConfig = builder . getCheckConfig ( "SeparatorWrap" ) ; String filePath = builder . getFilePath ( "SeparatorWrapInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter4formatting . rule485annotations ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . annotation . AnnotationLocationCheck ; import com . puppycrawl . tools . checkstyle . checks . coding . MissingSwitchDefaultCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class AnnotationLocationTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void annotationTest ( ) throws IOException , Exception { Class < AnnotationLocationCheck > clazz = AnnotationLocationCheck . class ; String msgLocation = "annotation.location" ; String msgLocationAlone = "annotation.location.alone" ; getCheckMessage ( clazz , "annotation.location.alone" ) ; Configuration checkConfig = builder . getCheckConfig ( "AnnotationLocation" ) ; final String [ ] expected = { "3: " + getCheckMessage ( clazz , msgLocationAlone , "MyAnnotation1" ) , "20: " + getCheckMessage ( clazz , msgLocation , "MyAnnotation1" , "8" , "4" ) , "27: " + getCheckMessage ( clazz , msgLocation , "MyAnnotation2" , "7" , "4" ) , "31: " + getCheckMessage ( clazz , msgLocation , "MyAnnotation2" , "8" , "4" ) , "32: " + getCheckMessage ( clazz , msgLocation , "MyAnnotation3" , "6" , "4" ) , "33: " + getCheckMessage ( clazz , msgLocation , "MyAnnotation4" , "10" , "4" ) , "54: " + getCheckMessage ( clazz , msgLocation , "MyAnnotation2" , "12" , "8" ) , "58: " + getCheckMessage ( clazz , msgLocation , "MyAnnotation2" , "12" , "8" ) , "78: " + getCheckMessage ( clazz , msgLocation , "MyAnnotation2" , "11" , "8" ) , "81: " + getCheckMessage ( clazz , msgLocation , "MyAnnotation2" , "10" , "8" ) , "90: " + getCheckMessage ( clazz , msgLocation , "MyAnnotation2" , "1" , "0" ) , } ; String filePath = builder . getFilePath ( "AnnotationLocationInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import static com . puppycrawl . tools . checkstyle . checks . naming . AbstractNameCheck . MSG_INVALID_PATTERN ; import static com . puppycrawl . tools . checkstyle . checks . naming . MethodNameCheck . MSG_KEY ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class MethodNameCheckTest extends BaseCheckTestSupport { @ Test public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodNameCheck . class ) ; final String pattern = "^[a-z][a-zA-Z0-9]*$" ; final String [ ] expected = { "137:10: " + getCheckMessage ( MSG_INVALID_PATTERN , "ALL_UPPERCASE_METHOD" , pattern ) , } ; verify ( checkConfig , getPath ( "InputSimple.java" ) , expected ) ; } @ Test public void testMethodEqClass ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodNameCheck . class ) ; final String pattern = "^[a-z][a-zA-Z0-9]*$" ; final String [ ] expected = { "12:16: " + getCheckMessage ( MSG_KEY , "InputMethNameEqualClsName" ) , "12:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "InputMethNameEqualClsName" , pattern ) , "17:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "PRIVATEInputMethNameEqualClsName" , pattern ) , "23:20: " + getCheckMessage ( MSG_KEY , "Inner" ) , "23:20: " + getCheckMessage ( MSG_INVALID_PATTERN , "Inner" , pattern ) , "28:20: " + getCheckMessage ( MSG_INVALID_PATTERN , "InputMethNameEqualClsName" , pattern ) , "37:24: " + getCheckMessage ( MSG_KEY , "InputMethNameEqualClsName" ) , "37:24: " + getCheckMessage ( MSG_INVALID_PATTERN , "InputMethNameEqualClsName" , pattern ) , "47:9: " + getCheckMessage ( MSG_KEY , "SweetInterface" ) , "47:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "SweetInterface" , pattern ) , "53:17: " + getCheckMessage ( MSG_KEY , "Outter" ) , "53:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "Outter" , pattern ) , } ; verify ( checkConfig , getPath ( "InputMethNameEqualClsName.java" ) , expected ) ; } @ Test public void testMethodEqClassAllow ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodNameCheck . class ) ; checkConfig . addAttribute ( "allowClassName" , "true" ) ; final String pattern = "^[a-z][a-zA-Z0-9]*$" ; final String [ ] expected = { "12:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "InputMethNameEqualClsName" , pattern ) , "17:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "PRIVATEInputMethNameEqualClsName" , pattern ) , "23:20: " + getCheckMessage ( MSG_INVALID_PATTERN , "Inner" , pattern ) , "28:20: " + getCheckMessage ( MSG_INVALID_PATTERN , "InputMethNameEqualClsName" , pattern ) , "37:24: " + getCheckMessage ( MSG_INVALID_PATTERN , "InputMethNameEqualClsName" , pattern ) , "47:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "SweetInterface" , pattern ) , "53:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "Outter" , pattern ) , } ; verify ( checkConfig , getPath ( "InputMethNameEqualClsName.java" ) , expected ) ; } @ Test public void testAccessTuning ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodNameCheck . class ) ; checkConfig . addAttribute ( "allowClassName" , "true" ) ; checkConfig . addAttribute ( "applyToPrivate" , "false" ) ; final String pattern = "^[a-z][a-zA-Z0-9]*$" ; final String [ ] expected = { "12:16: " + getCheckMessage ( MSG_INVALID_PATTERN , "InputMethNameEqualClsName" , pattern ) , "23:20: " + getCheckMessage ( MSG_INVALID_PATTERN , "Inner" , pattern ) , "28:20: " + getCheckMessage ( MSG_INVALID_PATTERN , "InputMethNameEqualClsName" , pattern ) , "37:24: " + getCheckMessage ( MSG_INVALID_PATTERN , "InputMethNameEqualClsName" , pattern ) , "47:9: " + getCheckMessage ( MSG_INVALID_PATTERN , "SweetInterface" , pattern ) , "53:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "Outter" , pattern ) , } ; verify ( checkConfig , getPath ( "InputMethNameEqualClsName.java" ) , expected ) ; } @ Test public void testForNpe ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodNameCheck . class ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "naming/InputMethodNameExtra.java" ) , expected ) ; } @ Test public void testOverridenMethods ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( MethodNameCheck . class ) ; final String pattern = "^[a-z][a-zA-Z0-9]*$" ; final String [ ] expected = { "17:17: " + getCheckMessage ( MSG_INVALID_PATTERN , "PUBLICfoo" , pattern ) , "20:20: " + getCheckMessage ( MSG_INVALID_PATTERN , "PROTECTEDfoo" , pattern ) , } ; verify ( checkConfig , getPath ( "naming/InputMethodNameOverridenMethods.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { MethodNameCheck methodNameCheckObj = new MethodNameCheck ( ) ; int [ ] actual = methodNameCheckObj . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . METHOD_DEF , } ; Assert . assertNotNull ( actual ) ; Assert . assertArrayEquals ( expected , actual ) ; } }
package com . google . checkstyle . test . chapter6programpractice . rule64finalizers ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . coding . NoFinalizerCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class NoFinalizerTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void noFinalizerBasicTest ( ) throws IOException , Exception { String msg = getCheckMessage ( NoFinalizerCheck . class , "avoid.finalizer.method" ) ; final String [ ] expected = { "5: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "NoFinalizer" ) ; String filePath = builder . getFilePath ( "NoFinalizerInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void noFinalizerExtendedTest ( ) throws IOException , Exception { String msg = getCheckMessage ( NoFinalizerCheck . class , "avoid.finalizer.method" ) ; final String [ ] expected = { "9: " + msg , "21: " + msg , "33: " + msg , "45: " + msg , "57: " + msg , "69: " + msg , "79: " + msg , "119: " + msg , "136: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "NoFinalizer" ) ; String filePath = builder . getFilePath ( "NoFinalizeExtendInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter6programpractice . rule62donotignoreexceptions ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . blocks . EmptyBlockCheck ; public class EmptyBlockTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void emptyBlockTestCatch ( ) throws IOException , Exception { final String [ ] expected = { "29:17: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "finally" ) , "50:21: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "finally" ) , "72:21: " + getCheckMessage ( EmptyBlockCheck . class , "block.empty" , "finally" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "EmptyBlock" ) ; String filePath = builder . getFilePath ( "EmptyBlockInputCatch" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter2filebasic . rule232specialescape ; import java . io . File ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; public class IllegalTokenTextTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , MalformedURLException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void illegalTokensTest ( ) throws IOException , Exception { final String [ ] expected = { "17:27: Avoid using corresponding octal or Unicode escape." , "18:27: Avoid using corresponding octal or Unicode escape." , "19:27: Avoid using corresponding octal or Unicode escape." , "22:25: Avoid using corresponding octal or Unicode escape." , "23:25: Avoid using corresponding octal or Unicode escape." , "25:16: Avoid using corresponding octal or Unicode escape." , "42:21: Avoid using corresponding octal or Unicode escape." , "43:21: Avoid using corresponding octal or Unicode escape." , "44:21: Avoid using corresponding octal or Unicode escape." , "45:21: Avoid using corresponding octal or Unicode escape." , "46:21: Avoid using corresponding octal or Unicode escape." , "47:21: Avoid using corresponding octal or Unicode escape." , "48:21: Avoid using corresponding octal or Unicode escape." , "49:21: Avoid using corresponding octal or Unicode escape." , "54:21: Avoid using corresponding octal or Unicode escape." , "55:21: Avoid using corresponding octal or Unicode escape." , "56:21: Avoid using corresponding octal or Unicode escape." , "57:21: Avoid using corresponding octal or Unicode escape." , "58:21: Avoid using corresponding octal or Unicode escape." , "59:21: Avoid using corresponding octal or Unicode escape." , "60:21: Avoid using corresponding octal or Unicode escape." , "61:21: Avoid using corresponding octal or Unicode escape." , "68:31: Avoid using corresponding octal or Unicode escape." , "69:31: Avoid using corresponding octal or Unicode escape." , "70:31: Avoid using corresponding octal or Unicode escape." , "73:29: Avoid using corresponding octal or Unicode escape." , "74:29: Avoid using corresponding octal or Unicode escape." , "76:20: Avoid using corresponding octal or Unicode escape." , "93:25: Avoid using corresponding octal or Unicode escape." , "94:25: Avoid using corresponding octal or Unicode escape." , "95:25: Avoid using corresponding octal or Unicode escape." , "96:25: Avoid using corresponding octal or Unicode escape." , "97:25: Avoid using corresponding octal or Unicode escape." , "98:25: Avoid using corresponding octal or Unicode escape." , "99:25: Avoid using corresponding octal or Unicode escape." , "100:25: Avoid using corresponding octal or Unicode escape." , "105:25: Avoid using corresponding octal or Unicode escape." , "106:25: Avoid using corresponding octal or Unicode escape." , "107:25: Avoid using corresponding octal or Unicode escape." , "108:25: Avoid using corresponding octal or Unicode escape." , "109:25: Avoid using corresponding octal or Unicode escape." , "110:25: Avoid using corresponding octal or Unicode escape." , "111:25: Avoid using corresponding octal or Unicode escape." , "112:25: Avoid using corresponding octal or Unicode escape." , "118:35: Avoid using corresponding octal or Unicode escape." , "119:35: Avoid using corresponding octal or Unicode escape." , "120:35: Avoid using corresponding octal or Unicode escape." , "123:33: Avoid using corresponding octal or Unicode escape." , "124:33: Avoid using corresponding octal or Unicode escape." , "126:24: Avoid using corresponding octal or Unicode escape." , "143:29: Avoid using corresponding octal or Unicode escape." , "144:29: Avoid using corresponding octal or Unicode escape." , "145:29: Avoid using corresponding octal or Unicode escape." , "146:29: Avoid using corresponding octal or Unicode escape." , "147:29: Avoid using corresponding octal or Unicode escape." , "148:29: Avoid using corresponding octal or Unicode escape." , "149:29: Avoid using corresponding octal or Unicode escape." , "150:29: Avoid using corresponding octal or Unicode escape." , "155:29: Avoid using corresponding octal or Unicode escape." , "156:29: Avoid using corresponding octal or Unicode escape." , "157:29: Avoid using corresponding octal or Unicode escape." , "158:29: Avoid using corresponding octal or Unicode escape." , "159:29: Avoid using corresponding octal or Unicode escape." , "160:29: Avoid using corresponding octal or Unicode escape." , "161:29: Avoid using corresponding octal or Unicode escape." , "162:29: Avoid using corresponding octal or Unicode escape." , } ; Configuration checkConfig = builder . getCheckConfig ( "IllegalTokenText" ) ; String filePath = builder . getFilePath ( "IllegalTokenTextInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter2filebasic . rule231filetab ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . whitespace . FileTabCharacterCheck ; public class FileTabCharacterTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Override protected DefaultConfiguration createCheckerConfig ( Configuration aCheckConfig ) { final DefaultConfiguration dc = new DefaultConfiguration ( "root" ) ; dc . addChild ( aCheckConfig ) ; return dc ; } @ Test public void fileTabTest ( ) throws IOException , Exception { final DefaultConfiguration checkConfig = createConfig ( true ) ; final String [ ] expected = { "8:25: " + getCheckMessage ( FileTabCharacterCheck . class , "containsTab" ) , "51:5: " + getCheckMessage ( FileTabCharacterCheck . class , "containsTab" ) , "121:35: " + getCheckMessage ( FileTabCharacterCheck . class , "containsTab" ) , "122:64: " + getCheckMessage ( FileTabCharacterCheck . class , "containsTab" ) , "130:9: " + getCheckMessage ( FileTabCharacterCheck . class , "containsTab" ) , "131:10: " + getCheckMessage ( FileTabCharacterCheck . class , "containsTab" ) , "132:1: " + getCheckMessage ( FileTabCharacterCheck . class , "containsTab" ) , "133:3: " + getCheckMessage ( FileTabCharacterCheck . class , "containsTab" ) , "134:3: " + getCheckMessage ( FileTabCharacterCheck . class , "containsTab" ) , } ; String filePath = builder . getFilePath ( "FileTabCharacterInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( createChecker ( checkConfig ) , filePath , expected , warnList ) ; } private DefaultConfiguration createConfig ( boolean verbose ) { final DefaultConfiguration checkConfig = createCheckConfig ( FileTabCharacterCheck . class ) ; checkConfig . addAttribute ( "eachLine" , Boolean . toString ( verbose ) ) ; return checkConfig ; } }
package com . google . checkstyle . test . chapter2filebasic . rule233nonascii ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . AvoidEscapedUnicodeCharactersCheck ; public class AvoidEscapedUnicodeCharactersCheckTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void unicodeEscapesTest ( ) throws IOException , Exception { String msg = getCheckMessage ( AvoidEscapedUnicodeCharactersCheck . class , "forbid.escaped.unicode.char" ) ; final String [ ] expected = { "5: " + msg , "15: " + msg , "25: " + msg , "33: " + msg , "35: " + msg , "36: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "AvoidEscapedUnicodeCharacters" ) ; String filePath = builder . getFilePath ( "AvoidEscapedUnicodeCharactersInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter2filebasic . rule21filename ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . OuterTypeFilenameCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class OuterTypeFilenameTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void outerTypeFilenameTest_1 ( ) throws IOException , Exception { String msg = getCheckMessage ( OuterTypeFilenameCheck . class , "type.file.mismatch" ) ; final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "OuterTypeFilename" ) ; String filePath = builder . getFilePath ( "OuterTypeFilenameInput_1" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void outerTypeFilenameTest_2 ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "OuterTypeFilename" ) ; String filePath = builder . getFilePath ( "OuterTypeFilenameInput_2" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void outerTypeFilenameTest_3 ( ) throws IOException , Exception { final String [ ] expected = { "3: " + getCheckMessage ( OuterTypeFilenameCheck . class , "type.file.mismatch" ) , } ; Configuration checkConfig = builder . getCheckConfig ( "OuterTypeFilename" ) ; String filePath = builder . getFilePath ( "OuterTypeFilenameInput_3" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter7javadoc . rule712paragraphs ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocParagraphCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class JavadocParagraphTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void javadocParagraphCorrectTest ( ) throws IOException , Exception { final String [ ] expected = { } ; Configuration checkConfig = builder . getCheckConfig ( "JavadocParagraph" ) ; String filePath = builder . getFilePath ( "InputCorrectJavadocParagraphCheck" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void javadocParagraphIncorrectTest ( ) throws IOException , Exception { String msgBefore = getCheckMessage ( JavadocParagraphCheck . class , "javadoc.paragraph.line.before" ) ; String msgRed = getCheckMessage ( JavadocParagraphCheck . class , "javadoc.paragraph.redundant.paragraph" ) ; final String [ ] expected = { "5: " + msgBefore , "6: " + msgBefore , "12: " + msgBefore , "21: " + msgBefore , "30: " + msgRed , "31: " + msgBefore , "32: " + msgBefore , "33: " + msgBefore , "37: " + msgBefore , "43: " + msgRed , "48: " + msgBefore , "49: " + msgBefore , "59: " + msgRed , "68: " + msgBefore , "73: " + msgBefore , } ; Configuration checkConfig = builder . getCheckConfig ( "JavadocParagraph" ) ; String filePath = builder . getFilePath ( "InputIncorrectJavadocParagraphCheck" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter7javadoc . rule72thesummaryfragment ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . coding . NoFinalizerCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class SummaryJavadocTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void noFinalizerBasicTest ( ) throws IOException , Exception { String msg = getCheckMessage ( NoFinalizerCheck . class , "avoid.finalizer.method" ) ; final String [ ] expected = { "5: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "NoFinalizer" ) ; String filePath = builder . getFilePath ( "NoFinalizerInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void noFinalizerExtendedTest ( ) throws IOException , Exception { String msg = getCheckMessage ( NoFinalizerCheck . class , "avoid.finalizer.method" ) ; final String [ ] expected = { "9: " + msg , "21: " + msg , "33: " + msg , "45: " + msg , "57: " + msg , "69: " + msg , "79: " + msg , "119: " + msg , "136: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "NoFinalizer" ) ; String filePath = builder . getFilePath ( "NoFinalizeExtendInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter7javadoc . rule713atclauses ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . coding . NoFinalizerCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class AtclauseOrderTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void noFinalizerBasicTest ( ) throws IOException , Exception { String msg = getCheckMessage ( NoFinalizerCheck . class , "avoid.finalizer.method" ) ; final String [ ] expected = { "5: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "NoFinalizer" ) ; String filePath = builder . getFilePath ( "NoFinalizerInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void noFinalizerExtendedTest ( ) throws IOException , Exception { String msg = getCheckMessage ( NoFinalizerCheck . class , "avoid.finalizer.method" ) ; final String [ ] expected = { "9: " + msg , "21: " + msg , "33: " + msg , "45: " + msg , "57: " + msg , "69: " + msg , "79: " + msg , "119: " + msg , "136: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "NoFinalizer" ) ; String filePath = builder . getFilePath ( "NoFinalizeExtendInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter7javadoc . rule713atclauses ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . coding . NoFinalizerCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class NonEmptyAtclauseDescriptionTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void noFinalizerBasicTest ( ) throws IOException , Exception { String msg = getCheckMessage ( NoFinalizerCheck . class , "avoid.finalizer.method" ) ; final String [ ] expected = { "5: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "NoFinalizer" ) ; String filePath = builder . getFilePath ( "NoFinalizerInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void noFinalizerExtendedTest ( ) throws IOException , Exception { String msg = getCheckMessage ( NoFinalizerCheck . class , "avoid.finalizer.method" ) ; final String [ ] expected = { "9: " + msg , "21: " + msg , "33: " + msg , "45: " + msg , "57: " + msg , "69: " + msg , "79: " + msg , "119: " + msg , "136: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "NoFinalizer" ) ; String filePath = builder . getFilePath ( "NoFinalizeExtendInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . puppycrawl . tools . checkstyle . checks . naming ; import static com . puppycrawl . tools . checkstyle . checks . naming . AbstractClassNameCheck . ILLEGAL_ABSTRACT_CLASS_NAME ; import static com . puppycrawl . tools . checkstyle . checks . naming . AbstractClassNameCheck . NO_ABSTRACT_CLASS_MODIFIER ; import java . io . File ; import org . junit . Assert ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class AbstractClassNameCheckTest extends BaseCheckTestSupport { @ Test public void testIllegalAbstractClassName ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AbstractClassNameCheck . class ) ; checkConfig . addAttribute ( "ignoreName" , "false" ) ; checkConfig . addAttribute ( "ignoreModifier" , "true" ) ; final String pattern = "^Abstract.+$" ; final String [ ] expected = { "3:1: " + getCheckMessage ( ILLEGAL_ABSTRACT_CLASS_NAME , "InputAbstractClassName" , pattern ) , "6:1: " + getCheckMessage ( ILLEGAL_ABSTRACT_CLASS_NAME , "NonAbstractClassName" , pattern ) , "10:5: " + getCheckMessage ( ILLEGAL_ABSTRACT_CLASS_NAME , "NonAbstractInnerClass" , pattern ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputAbstractClassName.java" ) , expected ) ; } @ Test public void testIllegalClassType ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AbstractClassNameCheck . class ) ; checkConfig . addAttribute ( "ignoreName" , "true" ) ; checkConfig . addAttribute ( "ignoreModifier" , "false" ) ; final String [ ] expected = { "18:1: " + getCheckMessage ( NO_ABSTRACT_CLASS_MODIFIER , "AbstractClass" ) , "22:5: " + getCheckMessage ( NO_ABSTRACT_CLASS_MODIFIER , "AbstractInnerClass" ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputAbstractClassName.java" ) , expected ) ; } @ Test public void testAllVariants ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AbstractClassNameCheck . class ) ; checkConfig . addAttribute ( "ignoreName" , "false" ) ; checkConfig . addAttribute ( "ignoreModifier" , "false" ) ; final String pattern = "^Abstract.+$" ; final String [ ] expected = { "3:1: " + getCheckMessage ( ILLEGAL_ABSTRACT_CLASS_NAME , "InputAbstractClassName" , pattern ) , "6:1: " + getCheckMessage ( ILLEGAL_ABSTRACT_CLASS_NAME , "NonAbstractClassName" , pattern ) , "10:5: " + getCheckMessage ( ILLEGAL_ABSTRACT_CLASS_NAME , "NonAbstractInnerClass" , pattern ) , "18:1: " + getCheckMessage ( NO_ABSTRACT_CLASS_MODIFIER , "AbstractClass" ) , "22:5: " + getCheckMessage ( NO_ABSTRACT_CLASS_MODIFIER , "AbstractInnerClass" ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputAbstractClassName.java" ) , expected ) ; } @ Test public void testFalsePositive ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AbstractClassNameCheck . class ) ; final String [ ] expected = { "9:5: " + getCheckMessage ( NO_ABSTRACT_CLASS_MODIFIER , "AbstractClass" ) , } ; verify ( checkConfig , getPath ( "naming" + File . separator + "InputAbstractClassNameFormerFalsePositive.java" ) , expected ) ; } @ Test public void testGetAcceptableTokens ( ) { AbstractClassNameCheck classNameCheckObj = new AbstractClassNameCheck ( ) ; int [ ] actual = classNameCheckObj . getAcceptableTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . CLASS_DEF , } ; Assert . assertNotNull ( actual ) ; Assert . assertArrayEquals ( expected , actual ) ; } @ Test public void testGetRequiredTokens ( ) { AbstractClassNameCheck classNameCheckObj = new AbstractClassNameCheck ( ) ; int [ ] actual = classNameCheckObj . getRequiredTokens ( ) ; int [ ] expected = new int [ ] { TokenTypes . CLASS_DEF , } ; Assert . assertNotNull ( actual ) ; Assert . assertArrayEquals ( expected , actual ) ; } }
package com . google . checkstyle . test . chapter7javadoc . rule713atclauses ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . coding . NoFinalizerCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class JavadocTagContinuationIndentationTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void noFinalizerBasicTest ( ) throws IOException , Exception { String msg = getCheckMessage ( NoFinalizerCheck . class , "avoid.finalizer.method" ) ; final String [ ] expected = { "5: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "NoFinalizer" ) ; String filePath = builder . getFilePath ( "NoFinalizerInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test public void noFinalizerExtendedTest ( ) throws IOException , Exception { String msg = getCheckMessage ( NoFinalizerCheck . class , "avoid.finalizer.method" ) ; final String [ ] expected = { "9: " + msg , "21: " + msg , "33: " + msg , "45: " + msg , "57: " + msg , "69: " + msg , "79: " + msg , "119: " + msg , "136: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "NoFinalizer" ) ; String filePath = builder . getFilePath ( "NoFinalizeExtendInput" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter7javadoc . rule711generalform ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . javadoc . SingleLineJavadocCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class SingleLineJavadocTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void singleLineJavadocTest ( ) throws IOException , Exception { String msg = getCheckMessage ( SingleLineJavadocCheck . class , "singleline.javadoc" ) ; final String [ ] expected = { "5: " + msg , "13: " + msg , "29: " + msg , "32: " + msg , "35: " + msg , "38: " + msg , "41: " + msg , } ; final DefaultConfiguration checkConfig = createCheckConfig ( SingleLineJavadocCheck . class ) ; checkConfig . addAttribute ( "ignoreInlineTags" , "false" ) ; String filePath = builder . getFilePath ( "InputSingleLineJavadocCheck" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } @ Test ( expected = Exception . class ) public void customInlineTagTest ( ) throws IOException , Exception { String msg = getCheckMessage ( SingleLineJavadocCheck . class , "singleline.javadoc" ) ; Configuration checkConfig = builder . getCheckConfig ( "SingleLineJavadocCheck" ) ; String filePath = builder . getFilePath ( "InputSingleLineJavadocCheckError" ) ; final String [ ] expected = { "4: " + msg , } ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter7javadoc . rule731selfexplanatory ; import java . io . File ; import java . io . IOException ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . checkstyle . test . base . ConfigurationBuilder ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import com . puppycrawl . tools . checkstyle . checks . javadoc . JavadocMethodCheck ; import com . google . checkstyle . test . base . BaseCheckTestSupport ; public class JavadocMethodTest extends BaseCheckTestSupport { static ConfigurationBuilder builder ; @ BeforeClass public static void setConfigurationBuilder ( ) throws CheckstyleException , IOException { builder = new ConfigurationBuilder ( new File ( "src/it/" ) ) ; } @ Test public void javadocMethodTest ( ) throws IOException , Exception { String msg = getCheckMessage ( JavadocMethodCheck . class , "javadoc.missing" ) ; final String [ ] expected = { "57:5: " + msg , } ; Configuration checkConfig = builder . getCheckConfig ( "JavadocMethod" ) ; String filePath = builder . getFilePath ( "InputJavadocMethodCheck" ) ; Integer [ ] warnList = builder . getLinesWithWarn ( filePath ) ; verify ( checkConfig , filePath , expected , warnList ) ; } }
package com . google . checkstyle . test . chapter3filestructure . rule32packagestatement ; import java . io . * ; final class LineLengthInput2 { public static final int badConstant = 2 ; public static final int MAX_ROWS = 2 ; private static int badStatic = 2 ; private static int sNumCreated = 0 ; private int badMember = 2 ; private int mNumCreated1 = 0 ; protected int mNumCreated2 = 0 ; private int [ ] mInts = new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 } ; public void fooMethod ( ) { } public void fooMethodLongFtp ( ) { } public void fooLongStringUrl ( ) { String url = "https://github.com/checkstyle/checkstyle/blob/master/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java" ; processUrl ( "https://github.com/checkstyle/checkstyle/blob/master/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java" ) ; processUrl ( "some line" + "https://github.com/checkstyle/checkstyle/blob/master/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java" + "+ long fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo00000000000o line" ) ; processUrl ( "Some long foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo line" ) ; String [ ] soooooooooooooooooooooooooooooooooooolongfooooooooooooooooooooooooooooooooooooooooooo = { "http://github.com/checkstyle/checkstyle/blob/master/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java" , "Some long foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo line" , } ; String fakehttps = "Some long foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo line" ; processUrl ( new String [ ] { "http://github.com/checkstyle/checkstyle/blob/master/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java" , "Some long foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo line" , } ) ; String s = "text" + "text" + "text something more.. <a href=\"https://groups.google.com/forum/#!topic/checkstyle-devel/E0z89fzvxGs%5B226-250-false%5D\">long url name, long url name, long url name</a>" + "other text" ; } public void processUrl ( String url ) { } public void processUrl ( String [ ] urls ) { } }
package com . google . checkstyle . test . chapter3filestructure . rule331nowildcard ; import java . io . * ; import java . lang . * ; import java . lang . String ; import java . sql . Connection ; import java . util . List ; import java . util . List ; import java . util . Iterator ; import java . util . Enumeration ; import java . util . Arrays ; import javax . swing . JToolBar ; import javax . swing . JToggleButton ; import javax . swing . ScrollPaneLayout ; import javax . swing . BorderFactory ; import static java . io . File . listRoots ; import static javax . swing . WindowConstants . * ; import static javax . swing . WindowConstants . * ; import static java . io . File . createTempFile ; import java . awt . Component ; import java . awt . Graphics2D ; import java . awt . HeadlessException ; import java . awt . Label ; import java . util . Date ; import java . util . Calendar ; import java . util . BitSet ; class AvoidStarImportInput { }
package com . google . checkstyle . test . chapter3filestructure . rule332nolinewrap ; import com . google . common . annotations . Beta ; import javax . accessibility . AccessibleAttributeSequence ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; public class NoLineWrap_Bad { public void fooMethod ( ) { final int foo = 0 ; } } enum FooFoo { } interface InterFoo { }
package com . google . checkstyle . test . chapter3filestructure . rule332nolinewrap ; import com . google . common . annotations . Beta ; import javax . accessibility . AccessibleAttributeSequence ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; public class NoLineWrap_Good { public void fooMethod ( ) { } }
package com . google . checkstyle . test . chapter3filestructure . rule333orderingandsoacing ; import static java . io . File . createTempFile ; import static java . awt . Button . ABORT ; import static javax . swing . WindowConstants . * ; import java . util . List ; import java . util . StringTokenizer ; import java . util . * ; import java . util . concurrent . AbstractExecutorService ; import java . util . concurrent . * ; import com . google . checkstyle . test . chapter2filebasic . rule21filename . * ; import com . sun . xml . internal . xsom . impl . scd . Iterators ; import com . google . common . reflect . * ; public class CustomImportOrderInput_2 { }
package com . google . checkstyle . test . chapter3filestructure . rule333orderingandsoacing ; import static java . io . File . createTempFile ; import static java . awt . Button . ABORT ; import static javax . swing . WindowConstants . * ; import java . awt . Button ; import java . awt . Frame ; import java . awt . Dialog ; import java . awt . event . ActionEvent ; import javax . swing . JComponent ; import javax . swing . JTable ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import com . google . common . base . Ascii ; public class CustomImportOrderInput_1 { }
package com . google . checkstyle . test . chapter3filestructure . rule333orderingandsoacing ; import static java . io . File . createTempFile ; import static java . awt . Button . ABORT ; import static javax . swing . WindowConstants . * ; import java . util . StringTokenizer ; import java . util . * ; import java . util . concurrent . AbstractExecutorService ; import java . util . concurrent . * ; import com . google . checkstyle . test . chapter2filebasic . rule21filename . * ; import com . sun . xml . internal . xsom . impl . scd . Iterators ; import com . google . common . reflect . * ; public class CustomImportOrderInput_3 { }
package com . puppycrawl . tools . checkstyle . checks . naming ; import static com . puppycrawl . tools . checkstyle . checks . naming . AbbreviationAsWordInNameCheck . MSG_KEY ; import org . junit . Test ; import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class AbbreviationAsWordInNameCheckTest extends BaseCheckTestSupport { private String warningMessage ; @ Test public void testTypeNamesForThreePermitedCapitalLetters ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AbbreviationAsWordInNameCheck . class ) ; final int expectedCapitalCount = 3 ; warningMessage = getCheckMessage ( MSG_KEY , expectedCapitalCount ) ; checkConfig . addAttribute ( "allowedAbbreviationLength" , String . valueOf ( expectedCapitalCount ) ) ; checkConfig . addAttribute ( "allowedAbbreviations" , "III" ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF" ) ; checkConfig . addAttribute ( "ignoreOverriddenMethods" , "true" ) ; final String [ ] expected = { "9: " + warningMessage , "12: " + warningMessage , "32: " + warningMessage , "37: " + warningMessage , } ; verify ( checkConfig , getPath ( "naming/InputAbbreviationAsWordInTypeNameCheck.java" ) , expected ) ; } @ Test public void testTypeNamesForFourPermitedCapitalLetters ( ) throws Exception { final int expectedCapitalCount = 4 ; warningMessage = getCheckMessage ( MSG_KEY , expectedCapitalCount ) ; final DefaultConfiguration checkConfig = createCheckConfig ( AbbreviationAsWordInNameCheck . class ) ; checkConfig . addAttribute ( "allowedAbbreviationLength" , String . valueOf ( expectedCapitalCount ) ) ; checkConfig . addAttribute ( "allowedAbbreviations" , "CLASS,FACTORY" ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF" ) ; checkConfig . addAttribute ( "ignoreOverriddenMethods" , "true" ) ; final String [ ] expected = { "32: " + warningMessage , } ; verify ( checkConfig , getPath ( "naming/InputAbbreviationAsWordInTypeNameCheck.java" ) , expected ) ; } @ Test public void testTypeNamesForFivePermitedCapitalLetters ( ) throws Exception { final int expectedCapitalCount = 5 ; warningMessage = getCheckMessage ( MSG_KEY , expectedCapitalCount ) ; final DefaultConfiguration checkConfig = createCheckConfig ( AbbreviationAsWordInNameCheck . class ) ; checkConfig . addAttribute ( "allowedAbbreviationLength" , String . valueOf ( expectedCapitalCount ) ) ; checkConfig . addAttribute ( "allowedAbbreviations" , "CLASS" ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF" ) ; checkConfig . addAttribute ( "ignoreOverriddenMethods" , "true" ) ; final String [ ] expected = { "32: " + warningMessage , "37: " + warningMessage , } ; verify ( checkConfig , getPath ( "naming/InputAbbreviationAsWordInTypeNameCheck.java" ) , expected ) ; } @ Test public void testTypeAndVariablesAndMethodNames ( ) throws Exception { final int expectedCapitalCount = 5 ; warningMessage = getCheckMessage ( MSG_KEY , expectedCapitalCount ) ; final DefaultConfiguration checkConfig = createCheckConfig ( AbbreviationAsWordInNameCheck . class ) ; checkConfig . addAttribute ( "allowedAbbreviationLength" , String . valueOf ( expectedCapitalCount ) ) ; checkConfig . addAttribute ( "allowedAbbreviations" , "CLASS" ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF" + ",VARIABLE_DEF" + ",METHOD_DEF,ENUM_DEF,ENUM_CONSTANT_DEF" + ",PARAMETER_DEF,INTERFACE_DEF,ANNOTATION_DEF" ) ; checkConfig . addAttribute ( "ignoreOverriddenMethods" , "true" ) ; final String [ ] expected = { "32: " + warningMessage , "37: " + warningMessage , "38: " + warningMessage , "39: " + warningMessage , "40: " + warningMessage , "58: " + warningMessage , } ; verify ( checkConfig , getPath ( "naming/InputAbbreviationAsWordInTypeNameCheck.java" ) , expected ) ; } @ Test public void testTypeAndVariablesAndMethodNamesWithNoIgnores ( ) throws Exception { final int expectedCapitalCount = 5 ; warningMessage = getCheckMessage ( MSG_KEY , expectedCapitalCount ) ; final DefaultConfiguration checkConfig = createCheckConfig ( AbbreviationAsWordInNameCheck . class ) ; checkConfig . addAttribute ( "allowedAbbreviationLength" , String . valueOf ( expectedCapitalCount ) ) ; checkConfig . addAttribute ( "allowedAbbreviations" , "NUMBER,MARAZMATIC,VARIABLE" ) ; checkConfig . addAttribute ( "ignoreStatic" , "false" ) ; checkConfig . addAttribute ( "ignoreFinal" , "false" ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF" + ",VARIABLE_DEF" + ",METHOD_DEF,ENUM_DEF,ENUM_CONSTANT_DEF" + ",PARAMETER_DEF,INTERFACE_DEF,ANNOTATION_DEF" ) ; checkConfig . addAttribute ( "ignoreOverriddenMethods" , "true" ) ; final String [ ] expected = { "32: " + warningMessage , "37: " + warningMessage , "38: " + warningMessage , "66: " + warningMessage , "72: " + warningMessage , "78: " + warningMessage , "84: " + warningMessage , } ; verify ( checkConfig , getPath ( "naming/InputAbbreviationAsWordInTypeNameCheck.java" ) , expected ) ; } @ Test public void testTypeAndVariablesAndMethodNamesWithIgnores ( ) throws Exception { final int expectedCapitalCount = 5 ; warningMessage = getCheckMessage ( MSG_KEY , expectedCapitalCount ) ; final DefaultConfiguration checkConfig = createCheckConfig ( AbbreviationAsWordInNameCheck . class ) ; checkConfig . addAttribute ( "allowedAbbreviationLength" , String . valueOf ( expectedCapitalCount ) ) ; checkConfig . addAttribute ( "allowedAbbreviations" , "NUMBER,MARAZMATIC,VARIABLE" ) ; checkConfig . addAttribute ( "ignoreStatic" , "true" ) ; checkConfig . addAttribute ( "ignoreFinal" , "true" ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF" + ",VARIABLE_DEF" + ",METHOD_DEF,ENUM_DEF,ENUM_CONSTANT_DEF" + ",PARAMETER_DEF,INTERFACE_DEF,ANNOTATION_DEF" ) ; checkConfig . addAttribute ( "ignoreOverriddenMethods" , "true" ) ; final String [ ] expected = { "32: " + warningMessage , "37: " + warningMessage , "38: " + warningMessage , } ; verify ( checkConfig , getPath ( "naming/InputAbbreviationAsWordInTypeNameCheck.java" ) , expected ) ; } @ Test public void testTypeAndVariablesAndMethodNamesWithIgnoresFinal ( ) throws Exception { final int expectedCapitalCount = 4 ; warningMessage = getCheckMessage ( MSG_KEY , expectedCapitalCount ) ; final DefaultConfiguration checkConfig = createCheckConfig ( AbbreviationAsWordInNameCheck . class ) ; checkConfig . addAttribute ( "allowedAbbreviationLength" , String . valueOf ( expectedCapitalCount ) ) ; checkConfig . addAttribute ( "allowedAbbreviations" , "MARAZMATIC,VARIABLE" ) ; checkConfig . addAttribute ( "ignoreStatic" , "false" ) ; checkConfig . addAttribute ( "ignoreFinal" , "true" ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF" + ",VARIABLE_DEF" + ",METHOD_DEF,ENUM_DEF,ENUM_CONSTANT_DEF" + ",PARAMETER_DEF,INTERFACE_DEF,ANNOTATION_DEF" ) ; checkConfig . addAttribute ( "ignoreOverriddenMethods" , "true" ) ; final String [ ] expected = { "12: " + warningMessage , "32: " + warningMessage , "37: " + warningMessage , "38: " + warningMessage , "58: " + warningMessage , "60: " + warningMessage , } ; verify ( checkConfig , getPath ( "naming/InputAbbreviationAsWordInTypeNameCheck.java" ) , expected ) ; } @ Test public void testTypeAndVariablesAndMethodNamesWithIgnoresStatic ( ) throws Exception { final int expectedCapitalCount = 5 ; warningMessage = getCheckMessage ( MSG_KEY , expectedCapitalCount ) ; final DefaultConfiguration checkConfig = createCheckConfig ( AbbreviationAsWordInNameCheck . class ) ; checkConfig . addAttribute ( "allowedAbbreviationLength" , String . valueOf ( expectedCapitalCount ) ) ; checkConfig . addAttribute ( "allowedAbbreviations" , "MARAZMATIC,VARIABLE" ) ; checkConfig . addAttribute ( "ignoreStatic" , "true" ) ; checkConfig . addAttribute ( "ignoreFinal" , "false" ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF" + ",VARIABLE_DEF" + ",METHOD_DEF,ENUM_DEF,ENUM_CONSTANT_DEF" + ",PARAMETER_DEF,INTERFACE_DEF,ANNOTATION_DEF" ) ; checkConfig . addAttribute ( "ignoreOverriddenMethods" , "true" ) ; final String [ ] expected = { "32: " + warningMessage , "37: " + warningMessage , "38: " + warningMessage , "58: " + warningMessage , "59: " + warningMessage , } ; verify ( checkConfig , getPath ( "naming/InputAbbreviationAsWordInTypeNameCheck.java" ) , expected ) ; } @ Test public void testTypeNamesForThreePermitedCapitalLettersWithOverridenMethod ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AbbreviationAsWordInNameCheck . class ) ; final int expectedCapitalCount = 3 ; warningMessage = getCheckMessage ( MSG_KEY , expectedCapitalCount ) ; checkConfig . addAttribute ( "allowedAbbreviationLength" , String . valueOf ( expectedCapitalCount ) ) ; checkConfig . addAttribute ( "allowedAbbreviations" , "" ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF, METHOD_DEF" ) ; checkConfig . addAttribute ( "ignoreOverriddenMethods" , "true" ) ; final String [ ] expected = { "22: " + warningMessage , } ; verify ( checkConfig , getPath ( "naming/InputAbbreviationAsWordInTypeNameCheckOverridableMethod.java" ) , expected ) ; } @ Test public void testTypeNamesForZeroPermitedCapitalLetter ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AbbreviationAsWordInNameCheck . class ) ; final int expectedCapitalCount = 0 ; warningMessage = getCheckMessage ( MSG_KEY , expectedCapitalCount ) ; checkConfig . addAttribute ( "allowedAbbreviationLength" , String . valueOf ( expectedCapitalCount ) ) ; checkConfig . addAttribute ( "allowedAbbreviations" , "" ) ; checkConfig . addAttribute ( "ignoreStatic" , "false" ) ; checkConfig . addAttribute ( "ignoreFinal" , "false" ) ; checkConfig . addAttribute ( "ignoreOverriddenMethods" , "false" ) ; checkConfig . addAttribute ( "tokens" , "CLASS_DEF,INTERFACE_DEF,ENUM_DEF," + "ANNOTATION_DEF,ANNOTATION_FIELD_DEF,ENUM_CONSTANT_DEF," + "PARAMETER_DEF,VARIABLE_DEF,METHOD_DEF" ) ; final String [ ] expected = { "3: " + warningMessage , "6: " + warningMessage , "9: " + warningMessage , "12: " + warningMessage , "32: " + warningMessage , "37: " + warningMessage , "38: " + warningMessage , "39: " + warningMessage , "40: " + warningMessage , "46: " + warningMessage , "47: " + warningMessage , "48: " + warningMessage , "49: " + warningMessage , "57: " + warningMessage , "58: " + warningMessage , "59: " + warningMessage , "60: " + warningMessage , "61: " + warningMessage , "66: " + warningMessage , "72: " + warningMessage , "78: " + warningMessage , "84: " + warningMessage , "88: " + warningMessage , "90: " + warningMessage , "98: " + warningMessage , } ; verify ( checkConfig , getPath ( "naming/InputAbbreviationAsWordInTypeNameCheck.java" ) , expected ) ; } @ Test public void testNPE ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( AbbreviationAsWordInNameCheck . class ) ; final int expectedCapitalCount = 1 ; warningMessage = getCheckMessage ( MSG_KEY , expectedCapitalCount ) ; checkConfig . addAttribute ( "allowedAbbreviationLength" , String . valueOf ( expectedCapitalCount ) ) ; checkConfig . addAttribute ( "ignoreFinal" , "false" ) ; checkConfig . addAttribute ( "allowedAbbreviations" , null ) ; final String [ ] expected = { } ; verify ( checkConfig , getPath ( "naming/AbstractMultisetSetCountTester.java" ) , expected ) ; } }
package com . puppycrawl . tools . checkstyle ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . Configuration ; import org . junit . Test ; import java . io . File ; import java . util . Properties ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class ConfigurationLoaderTest { private Configuration loadConfiguration ( String name ) throws CheckstyleException { return loadConfiguration ( name , new Properties ( ) ) ; } private Configuration loadConfiguration ( String name , Properties props ) throws CheckstyleException { final String fName = "src/test/resources/com/puppycrawl/tools/checkstyle/configs/" + name ; return ConfigurationLoader . loadConfiguration ( fName , new PropertiesExpander ( props ) ) ; } @ Test public void testResourceLoadConfiguration ( ) throws Exception { final Properties props = new Properties ( ) ; props . put ( "checkstyle.basedir" , "basedir" ) ; final DefaultConfiguration config = ( DefaultConfiguration ) ConfigurationLoader . loadConfiguration ( "src/test/resources/com/puppycrawl/tools/checkstyle/configs/checkstyle_checks.xml" , new PropertiesExpander ( props ) ) ; final Properties atts = new Properties ( ) ; atts . put ( "tabWidth" , "4" ) ; atts . put ( "basedir" , "basedir" ) ; verifyConfigNode ( config , "Checker" , 3 , atts ) ; } @ Test public void testEmptyConfiguration ( ) throws Exception { final DefaultConfiguration config = ( DefaultConfiguration ) loadConfiguration ( "empty_configuration.xml" ) ; verifyConfigNode ( config , "Checker" , 0 , new Properties ( ) ) ; } @ Test public void testMissingPropertyName ( ) { try { loadConfiguration ( "missing_property_name.xml" ) ; fail ( "missing property name" ) ; } catch ( CheckstyleException ex ) { assertTrue ( ex . getMessage ( ) . endsWith ( "Attribute \"name\" is required and must be specified " + "for element type \"property\".:8:41" ) ) ; } } @ Test public void testMissingPropertyValue ( ) { try { loadConfiguration ( "missing_property_value.xml" ) ; fail ( "missing property value" ) ; } catch ( CheckstyleException ex ) { assertTrue ( ex . getMessage ( ) . endsWith ( "Attribute \"value\" is required and must be specified " + "for element type \"property\".:8:41" ) ) ; } } @ Test public void testMissingConfigName ( ) { try { loadConfiguration ( "missing_config_name.xml" ) ; fail ( "missing module name" ) ; } catch ( CheckstyleException ex ) { assertTrue ( ex . getMessage ( ) . endsWith ( "Attribute \"name\" is required and must be specified " + "for element type \"module\".:7:23" ) ) ; } } @ Test public void testMissingConfigParent ( ) { try { loadConfiguration ( "missing_config_parent.xml" ) ; fail ( "missing module parent" ) ; } catch ( CheckstyleException ex ) { assertTrue ( ex . getMessage ( ) . endsWith ( "Document root element \"property\", must match DOCTYPE " + "root \"module\".:7:38" ) ) ; } } @ Test public void testCheckstyleChecks ( ) throws Exception { final Properties props = new Properties ( ) ; props . put ( "checkstyle.basedir" , "basedir" ) ; final DefaultConfiguration config = ( DefaultConfiguration ) loadConfiguration ( "checkstyle_checks.xml" , props ) ; final Properties atts = new Properties ( ) ; atts . put ( "tabWidth" , "4" ) ; atts . put ( "basedir" , "basedir" ) ; verifyConfigNode ( config , "Checker" , 3 , atts ) ; final Configuration [ ] children = config . getChildren ( ) ; atts . clear ( ) ; verifyConfigNode ( ( DefaultConfiguration ) children [ 1 ] , "JavadocPackage" , 0 , atts ) ; verifyConfigNode ( ( DefaultConfiguration ) children [ 2 ] , "Translation" , 0 , atts ) ; atts . put ( "testName" , "testValue" ) ; verifyConfigNode ( ( DefaultConfiguration ) children [ 0 ] , "TreeWalker" , 8 , atts ) ; final Configuration [ ] grandchildren = children [ 0 ] . getChildren ( ) ; atts . clear ( ) ; verifyConfigNode ( ( DefaultConfiguration ) grandchildren [ 0 ] , "AvoidStarImport" , 0 , atts ) ; atts . put ( "format" , "System.out.println" ) ; verifyConfigNode ( ( DefaultConfiguration ) grandchildren [ grandchildren . length - 1 ] , "GenericIllegalRegexp" , 0 , atts ) ; atts . clear ( ) ; atts . put ( "tokens" , "DOT" ) ; atts . put ( "allowLineBreaks" , "true" ) ; verifyConfigNode ( ( DefaultConfiguration ) grandchildren [ 6 ] , "NoWhitespaceAfter" , 0 , atts ) ; } @ Test public void testCustomMessages ( ) throws CheckstyleException { final Properties props = new Properties ( ) ; props . put ( "checkstyle.basedir" , "basedir" ) ; final DefaultConfiguration config = ( DefaultConfiguration ) loadConfiguration ( "custom_messages.xml" , props ) ; final Configuration [ ] children = config . getChildren ( ) ; final Configuration [ ] grandchildren = children [ 0 ] . getChildren ( ) ; assertTrue ( ( ( DefaultConfiguration ) grandchildren [ 0 ] ) . getMessages ( ) . containsKey ( "name.invalidPattern" ) ) ; } private void verifyConfigNode ( DefaultConfiguration config , String name , int childrenLength , Properties atts ) throws Exception { assertEquals ( "name." , name , config . getName ( ) ) ; assertEquals ( "children.length." , childrenLength , config . getChildren ( ) . length ) ; final String [ ] attNames = config . getAttributeNames ( ) ; assertEquals ( "attributes.length" , atts . size ( ) , attNames . length ) ; for ( int i = 0 ; i < attNames . length ; i ++ ) { assertEquals ( "attribute[" + attNames [ i ] + "]" , atts . get ( attNames [ i ] ) , config . getAttribute ( attNames [ i ] ) ) ; } } @ Test public void testReplacePropertiesNoReplace ( ) throws CheckstyleException { final String [ ] testValues = { null , "" , "a" , "$a" , "{a" , "{a}" , "a}" , "$a}" , "$" , "a$b" , } ; final Properties props = initProperties ( ) ; for ( int i = 0 ; i < testValues . length ; i ++ ) { final String value = ConfigurationLoader . replaceProperties ( testValues [ i ] , new PropertiesExpander ( props ) , null ) ; assertEquals ( "\"" + testValues [ i ] + "\"" , value , testValues [ i ] ) ; } } @ Test public void testReplacePropertiesSyntaxError ( ) { final Properties props = initProperties ( ) ; try { final String value = ConfigurationLoader . replaceProperties ( "${a" , new PropertiesExpander ( props ) , null ) ; fail ( "expected to fail, instead got: " + value ) ; } catch ( CheckstyleException ex ) { assertEquals ( "Syntax error in property: ${a" , ex . getMessage ( ) ) ; } } @ Test public void testReplacePropertiesMissingProperty ( ) { final Properties props = initProperties ( ) ; try { final String value = ConfigurationLoader . replaceProperties ( "${c}" , new PropertiesExpander ( props ) , null ) ; fail ( "expected to fail, instead got: " + value ) ; } catch ( CheckstyleException ex ) { assertEquals ( "Property ${c} has not been set" , ex . getMessage ( ) ) ; } } @ Test public void testReplacePropertiesReplace ( ) throws CheckstyleException { final String [ ] [ ] testValues = { { "${a}" , "A" } , { "x${a}" , "xA" } , { "${a}x" , "Ax" } , { "${a}${b}" , "AB" } , { "x${a}${b}" , "xAB" } , { "${a}x${b}" , "AxB" } , { "${a}${b}x" , "ABx" } , { "x${a}y${b}" , "xAyB" } , { "${a}x${b}y" , "AxBy" } , { "x${a}${b}y" , "xABy" } , { "x${a}y${b}z" , "xAyBz" } , { "$$" , "$" } , } ; final Properties props = initProperties ( ) ; for ( int i = 0 ; i < testValues . length ; i ++ ) { final String value = ConfigurationLoader . replaceProperties ( testValues [ i ] [ 0 ] , new PropertiesExpander ( props ) , null ) ; assertEquals ( "\"" + testValues [ i ] [ 0 ] + "\"" , testValues [ i ] [ 1 ] , value ) ; } } private Properties initProperties ( ) { final Properties props = new Properties ( ) ; props . put ( "a" , "A" ) ; props . put ( "b" , "B" ) ; return props ; } @ Test public void testExternalEntity ( ) throws Exception { final Properties props = new Properties ( ) ; props . put ( "checkstyle.basedir" , "basedir" ) ; final DefaultConfiguration config = ( DefaultConfiguration ) loadConfiguration ( "including.xml" , props ) ; final Properties atts = new Properties ( ) ; atts . put ( "tabWidth" , "4" ) ; atts . put ( "basedir" , "basedir" ) ; verifyConfigNode ( config , "Checker" , 2 , atts ) ; } @ Test public void testExternalEntitySubdir ( ) throws Exception { final Properties props = new Properties ( ) ; props . put ( "checkstyle.basedir" , "basedir" ) ; final DefaultConfiguration config = ( DefaultConfiguration ) loadConfiguration ( "subdir/including.xml" , props ) ; final Properties atts = new Properties ( ) ; atts . put ( "tabWidth" , "4" ) ; atts . put ( "basedir" , "basedir" ) ; verifyConfigNode ( config , "Checker" , 2 , atts ) ; } @ Test public void testExternalEntityFromURI ( ) throws Exception { final Properties props = new Properties ( ) ; props . put ( "checkstyle.basedir" , "basedir" ) ; final File file = new File ( "src/test/resources/com/puppycrawl/tools/checkstyle/configs/subdir/including.xml" ) ; final DefaultConfiguration config = ( DefaultConfiguration ) ConfigurationLoader . loadConfiguration ( file . toURI ( ) . toString ( ) , new PropertiesExpander ( props ) ) ; final Properties atts = new Properties ( ) ; atts . put ( "tabWidth" , "4" ) ; atts . put ( "basedir" , "basedir" ) ; verifyConfigNode ( config , "Checker" , 2 , atts ) ; } }
