package org . glyptodon . guacamole . protocol ; import java . io . StringReader ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . ReaderGuacamoleReader ; import static org . junit . Assert . * ; import org . junit . Test ; public class FilteredGuacamoleReaderTest { private static class TestFilter implements GuacamoleFilter { @ Override public GuacamoleInstruction filter ( GuacamoleInstruction instruction ) throws GuacamoleException { if ( instruction . getOpcode ( ) . equals ( "yes" ) ) return instruction ; return null ; } } @ Test public void testFilter ( ) throws Exception { final String test = "3.yes,1.A;2.no,1.B;3.yes,1.C;3.yes,1.D;4.nope,1.E;" ; GuacamoleReader reader = new FilteredGuacamoleReader ( new ReaderGuacamoleReader ( new StringReader ( test ) ) , new TestFilter ( ) ) ; GuacamoleInstruction instruction ; instruction = reader . readInstruction ( ) ; assertNotNull ( instruction ) ; assertEquals ( "yes" , instruction . getOpcode ( ) ) ; assertEquals ( 1 , instruction . getArgs ( ) . size ( ) ) ; assertEquals ( "A" , instruction . getArgs ( ) . get ( 0 ) ) ; instruction = reader . readInstruction ( ) ; assertNotNull ( instruction ) ; assertEquals ( "yes" , instruction . getOpcode ( ) ) ; assertEquals ( 1 , instruction . getArgs ( ) . size ( ) ) ; assertEquals ( "C" , instruction . getArgs ( ) . get ( 0 ) ) ; instruction = reader . readInstruction ( ) ; assertNotNull ( instruction ) ; assertEquals ( "yes" , instruction . getOpcode ( ) ) ; assertEquals ( 1 , instruction . getArgs ( ) . size ( ) ) ; assertEquals ( "D" , instruction . getArgs ( ) . get ( 0 ) ) ; instruction = reader . readInstruction ( ) ; assertNull ( instruction ) ; } }
package org . glyptodon . guacamole . net . basic . rest ; import org . aopalliance . intercept . MethodInterceptor ; import org . aopalliance . intercept . MethodInvocation ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleResourceNotFoundException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . net . auth . credentials . GuacamoleInsufficientCredentialsException ; import org . glyptodon . guacamole . net . auth . credentials . GuacamoleInvalidCredentialsException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class AuthProviderRESTExceptionWrapper implements MethodInterceptor { @ Override public Object invoke ( MethodInvocation invocation ) throws Throwable { Logger logger = LoggerFactory . getLogger ( invocation . getMethod ( ) . getDeclaringClass ( ) ) ; try { return invocation . proceed ( ) ; } catch ( GuacamoleInsufficientCredentialsException e ) { String message = e . getMessage ( ) ; if ( message == null ) message = "Permission denied." ; throw new APIException ( APIError . Type . INSUFFICIENT_CREDENTIALS , message , e . getCredentialsInfo ( ) . getFields ( ) ) ; } catch ( GuacamoleInvalidCredentialsException e ) { String message = e . getMessage ( ) ; if ( message == null ) message = "Permission denied." ; throw new APIException ( APIError . Type . INVALID_CREDENTIALS , message , e . getCredentialsInfo ( ) . getFields ( ) ) ; } catch ( GuacamoleSecurityException e ) { String message = e . getMessage ( ) ; if ( message == null ) message = "Permission denied." ; throw new APIException ( APIError . Type . PERMISSION_DENIED , message ) ; } catch ( GuacamoleResourceNotFoundException e ) { String message = e . getMessage ( ) ; if ( message == null ) message = "Not found." ; throw new APIException ( APIError . Type . NOT_FOUND , message ) ; } catch ( GuacamoleClientException e ) { String message = e . getMessage ( ) ; if ( message == null ) message = "Invalid request." ; throw new APIException ( APIError . Type . BAD_REQUEST , message ) ; } catch ( GuacamoleException e ) { String message = e . getMessage ( ) ; if ( message == null ) message = "Unexpected server error." ; logger . debug ( "Unexpected exception in REST endpoint." , e ) ; throw new APIException ( APIError . Type . INTERNAL_ERROR , message ) ; } } }
package org . glyptodon . guacamole . net . basic . rest ; import com . google . inject . AbstractModule ; import org . glyptodon . guacamole . net . basic . rest . auth . AuthTokenGenerator ; import org . glyptodon . guacamole . net . basic . rest . auth . AuthenticationService ; import org . glyptodon . guacamole . net . basic . rest . auth . SecureRandomAuthTokenGenerator ; import org . glyptodon . guacamole . net . basic . rest . auth . TokenSessionMap ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class RESTAuthModule extends AbstractModule { private final Logger logger = LoggerFactory . getLogger ( RESTAuthModule . class ) ; private final TokenSessionMap tokenSessionMap ; public RESTAuthModule ( TokenSessionMap tokenSessionMap ) { this . tokenSessionMap = tokenSessionMap ; } @ Override protected void configure ( ) { bind ( TokenSessionMap . class ) . toInstance ( tokenSessionMap ) ; bind ( AuthenticationService . class ) ; bind ( AuthTokenGenerator . class ) . to ( SecureRandomAuthTokenGenerator . class ) ; } }
package org . glyptodon . guacamole . net . basic . rest ; import java . util . Collection ; import javax . ws . rs . core . Response ; import org . glyptodon . guacamole . form . Field ; public class APIError { private final String message ; private final Collection < Field > expected ; private final Type type ; public enum Type { BAD_REQUEST ( Response . Status . BAD_REQUEST ) , INVALID_CREDENTIALS ( Response . Status . FORBIDDEN ) , INSUFFICIENT_CREDENTIALS ( Response . Status . FORBIDDEN ) , INTERNAL_ERROR ( Response . Status . INTERNAL_SERVER_ERROR ) , NOT_FOUND ( Response . Status . NOT_FOUND ) , PERMISSION_DENIED ( Response . Status . FORBIDDEN ) ; private final Response . Status status ; Type ( Response . Status status ) { this . status = status ; } public Response . Status getStatus ( ) { return status ; } } public APIError ( Type type , String message ) { this . type = type ; this . message = message ; this . expected = null ; } public APIError ( Type type , String message , Collection < Field > expected ) { this . type = type ; this . message = message ; this . expected = expected ; } public Type getType ( ) { return type ; } public Collection < Field > getExpected ( ) { return expected ; } public String getMessage ( ) { return message ; } }
package org . glyptodon . guacamole . net . basic . rest . language ;
package org . glyptodon . guacamole . net . basic . rest . language ; import com . google . inject . Inject ; import java . util . Map ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import javax . ws . rs . core . MediaType ; import org . glyptodon . guacamole . net . basic . extension . LanguageResourceService ; @ Path ( "/languages" ) @ Produces ( MediaType . APPLICATION_JSON ) public class LanguageRESTService { @ Inject private LanguageResourceService languageResourceService ; @ GET public Map < String , String > getLanguages ( ) { return languageResourceService . getLanguageNames ( ) ; } }
package org . glyptodon . guacamole . net . basic . rest . auth ;
package org . glyptodon . guacamole . net . basic . rest . auth ; public interface AuthTokenGenerator { public String getToken ( ) ; }
package org . glyptodon . guacamole . net . basic . rest . auth ; import org . glyptodon . guacamole . net . basic . GuacamoleSession ; public interface TokenSessionMap { public void put ( String authToken , GuacamoleSession session ) ; public GuacamoleSession get ( String authToken ) ; public GuacamoleSession remove ( String authToken ) ; public void shutdown ( ) ; }
package org . glyptodon . guacamole . net . basic . rest . auth ; import java . util . Collections ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . concurrent . Executors ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . TimeUnit ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . net . basic . GuacamoleSession ; import org . glyptodon . guacamole . net . basic . properties . BasicGuacamoleProperties ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class BasicTokenSessionMap implements TokenSessionMap { private static final Logger logger = LoggerFactory . getLogger ( BasicTokenSessionMap . class ) ; private final ScheduledExecutorService executor = Executors . newScheduledThreadPool ( 1 ) ; private final Map < String , GuacamoleSession > sessionMap = Collections . synchronizedMap ( new LinkedHashMap < String , GuacamoleSession > ( 16 , 0.75f , true ) ) ; public BasicTokenSessionMap ( Environment environment ) { int sessionTimeoutValue ; try { sessionTimeoutValue = environment . getProperty ( BasicGuacamoleProperties . API_SESSION_TIMEOUT , 60 ) ; } catch ( GuacamoleException e ) { logger . error ( "Unable to read guacamole.properties: {}" , e . getMessage ( ) ) ; logger . debug ( "Error while reading session timeout value." , e ) ; sessionTimeoutValue = 60 ; } logger . info ( "Sessions will expire after {} minutes of inactivity." , sessionTimeoutValue ) ; executor . scheduleAtFixedRate ( new SessionEvictionTask ( sessionTimeoutValue * 60000l ) , 1 , 1 , TimeUnit . MINUTES ) ; } private class SessionEvictionTask implements Runnable { private final long sessionTimeout ; public SessionEvictionTask ( long sessionTimeout ) { this . sessionTimeout = sessionTimeout ; } @ Override public void run ( ) { long now = System . currentTimeMillis ( ) ; logger . debug ( "Checking for expired sessions..." ) ; Iterator < Map . Entry < String , GuacamoleSession > > entries = sessionMap . entrySet ( ) . iterator ( ) ; while ( entries . hasNext ( ) ) { Map . Entry < String , GuacamoleSession > entry = entries . next ( ) ; GuacamoleSession session = entry . getValue ( ) ; if ( session . hasTunnels ( ) ) continue ; long age = now - session . getLastAccessedTime ( ) ; if ( age >= sessionTimeout ) { logger . debug ( "Session \"{}\" has timed out." , entry . getKey ( ) ) ; entries . remove ( ) ; session . invalidate ( ) ; } else break ; } logger . debug ( "Session check complete." ) ; } } @ Override public GuacamoleSession get ( String authToken ) { GuacamoleSession session = sessionMap . get ( authToken ) ; if ( session != null ) session . access ( ) ; return session ; } @ Override public void put ( String authToken , GuacamoleSession session ) { sessionMap . put ( authToken , session ) ; } @ Override public GuacamoleSession remove ( String authToken ) { return sessionMap . remove ( authToken ) ; } @ Override public void shutdown ( ) { executor . shutdownNow ( ) ; } }
package org . glyptodon . guacamole . net . basic . rest . auth ; import com . google . inject . Inject ; import java . io . UnsupportedEncodingException ; import java . util . regex . Pattern ; import javax . servlet . http . HttpServletRequest ; import javax . ws . rs . DELETE ; import javax . ws . rs . FormParam ; import javax . ws . rs . POST ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import javax . ws . rs . Produces ; import javax . ws . rs . core . Context ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . xml . bind . DatatypeConverter ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . net . auth . AuthenticationProvider ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . net . auth . credentials . CredentialsInfo ; import org . glyptodon . guacamole . net . auth . credentials . GuacamoleInvalidCredentialsException ; import org . glyptodon . guacamole . net . basic . GuacamoleSession ; import org . glyptodon . guacamole . net . basic . rest . APIError ; import org . glyptodon . guacamole . net . basic . rest . APIRequest ; import org . glyptodon . guacamole . net . basic . rest . AuthProviderRESTExposure ; import org . glyptodon . guacamole . net . basic . rest . APIException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; @ Path ( "/tokens" ) @ Produces ( MediaType . APPLICATION_JSON ) public class TokenRESTService { @ Inject private Environment environment ; @ Inject private AuthenticationProvider authProvider ; @ Inject private TokenSessionMap tokenSessionMap ; @ Inject private AuthTokenGenerator authTokenGenerator ; private static final Logger logger = LoggerFactory . getLogger ( TokenRESTService . class ) ; private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})" ; private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})" ; private static final String IP_ADDRESS_REGEX = "(" + IPV4_ADDRESS_REGEX + "|" + IPV6_ADDRESS_REGEX + ")" ; private static final Pattern X_FORWARDED_FOR = Pattern . compile ( "^" + IP_ADDRESS_REGEX + "(, " + IP_ADDRESS_REGEX + ")*$" ) ; private String getLoggableAddress ( HttpServletRequest request ) { String header = request . getHeader ( "X-Forwarded-For" ) ; if ( header != null && X_FORWARDED_FOR . matcher ( header ) . matches ( ) ) return "[" + header + ", " + request . getRemoteAddr ( ) + "]" ; return request . getRemoteAddr ( ) ; } @ POST @ AuthProviderRESTExposure public APIAuthToken createToken ( @ FormParam ( "username" ) String username , @ FormParam ( "password" ) String password , @ FormParam ( "token" ) String token , @ Context HttpServletRequest consumedRequest , MultivaluedMap < String , String > parameters ) throws GuacamoleException { HttpServletRequest request = new APIRequest ( consumedRequest , parameters ) ; GuacamoleSession existingSession ; if ( token != null ) existingSession = tokenSessionMap . get ( token ) ; else existingSession = null ; if ( username == null && password == null ) { String authorization = request . getHeader ( "Authorization" ) ; if ( authorization != null && authorization . startsWith ( "Basic " ) ) { try { String basicBase64 = authorization . substring ( 6 ) ; String basicCredentials = new String ( DatatypeConverter . parseBase64Binary ( basicBase64 ) , "UTF-8" ) ; int colon = basicCredentials . indexOf ( ':' ) ; if ( colon != - 1 ) { username = basicCredentials . substring ( 0 , colon ) ; password = basicCredentials . substring ( colon + 1 ) ; } else logger . debug ( "Invalid HTTP Basic \"Authorization\" header received." ) ; } catch ( UnsupportedEncodingException e ) { throw new UnsupportedOperationException ( "Unexpected lack of UTF-8 support." , e ) ; } } } Credentials credentials = new Credentials ( ) ; credentials . setUsername ( username ) ; credentials . setPassword ( password ) ; credentials . setRequest ( request ) ; credentials . setSession ( request . getSession ( true ) ) ; UserContext userContext ; try { if ( existingSession != null ) userContext = authProvider . updateUserContext ( existingSession . getUserContext ( ) , credentials ) ; else { userContext = authProvider . getUserContext ( credentials ) ; if ( userContext != null && logger . isInfoEnabled ( ) ) logger . info ( "User \"{}\" successfully authenticated from {}." , userContext . self ( ) . getIdentifier ( ) , getLoggableAddress ( request ) ) ; } if ( userContext == null ) throw new GuacamoleInvalidCredentialsException ( "Permission Denied." , CredentialsInfo . USERNAME_PASSWORD ) ; } catch ( GuacamoleException e ) { if ( username != null ) { if ( logger . isWarnEnabled ( ) ) logger . warn ( "Authentication attempt from {} for user \"{}\" failed." , getLoggableAddress ( request ) , username ) ; } else if ( logger . isDebugEnabled ( ) ) logger . debug ( "Anonymous authentication attempt from {} failed." , getLoggableAddress ( request ) , username ) ; throw e ; } String authToken ; if ( existingSession != null ) { authToken = token ; existingSession . setCredentials ( credentials ) ; existingSession . setUserContext ( userContext ) ; } else { authToken = authTokenGenerator . getToken ( ) ; tokenSessionMap . put ( authToken , new GuacamoleSession ( environment , credentials , userContext ) ) ; } logger . debug ( "Login was successful for user \"{}\"." , userContext . self ( ) . getIdentifier ( ) ) ; return new APIAuthToken ( authToken , userContext . self ( ) . getIdentifier ( ) ) ; } @ DELETE @ Path ( "/{token}" ) @ AuthProviderRESTExposure public void invalidateToken ( @ PathParam ( "token" ) String authToken ) { GuacamoleSession session = tokenSessionMap . remove ( authToken ) ; if ( session == null ) throw new APIException ( APIError . Type . NOT_FOUND , "No such token." ) ; session . invalidate ( ) ; } }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleUnauthorizedException extends GuacamoleSecurityException { public GuacamoleUnauthorizedException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleUnauthorizedException ( String message ) { super ( message ) ; } public GuacamoleUnauthorizedException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . CLIENT_UNAUTHORIZED ; } }
package org . glyptodon . guacamole . net . basic . rest . auth ; public class APIAuthToken { private final String authToken ; private final String userID ; public String getAuthToken ( ) { return authToken ; } public String getUserID ( ) { return userID ; } public APIAuthToken ( String authToken , String userID ) { this . authToken = authToken ; this . userID = userID ; } }
package org . glyptodon . guacamole . net . basic . rest . auth ; import java . security . SecureRandom ; import org . apache . commons . codec . binary . Hex ; public class SecureRandomAuthTokenGenerator implements AuthTokenGenerator { private final SecureRandom secureRandom = new SecureRandom ( ) ; @ Override public String getToken ( ) { byte [ ] bytes = new byte [ 32 ] ; secureRandom . nextBytes ( bytes ) ; return Hex . encodeHexString ( bytes ) ; } }
package org . glyptodon . guacamole . net . basic . rest . auth ; import com . google . inject . Inject ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleUnauthorizedException ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . net . basic . GuacamoleSession ; public class AuthenticationService { @ Inject private TokenSessionMap tokenSessionMap ; public GuacamoleSession getGuacamoleSession ( String authToken ) throws GuacamoleException { GuacamoleSession session = tokenSessionMap . get ( authToken ) ; if ( session == null ) throw new GuacamoleUnauthorizedException ( "Permission Denied." ) ; return session ; } public UserContext getUserContext ( String authToken ) throws GuacamoleException { return getGuacamoleSession ( authToken ) . getUserContext ( ) ; } }
package org . glyptodon . guacamole . net . basic . rest . permission ;
package org . glyptodon . guacamole . net . basic . rest . permission ; import java . util . EnumSet ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . User ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . auth . permission . SystemPermission ; import org . glyptodon . guacamole . net . auth . permission . SystemPermissionSet ; public class APIPermissionSet { private Map < String , Set < ObjectPermission . Type > > connectionPermissions = new HashMap < String , Set < ObjectPermission . Type > > ( ) ; private Map < String , Set < ObjectPermission . Type > > connectionGroupPermissions = new HashMap < String , Set < ObjectPermission . Type > > ( ) ; private Map < String , Set < ObjectPermission . Type > > activeConnectionPermissions = new HashMap < String , Set < ObjectPermission . Type > > ( ) ; private Map < String , Set < ObjectPermission . Type > > userPermissions = new HashMap < String , Set < ObjectPermission . Type > > ( ) ; private Set < SystemPermission . Type > systemPermissions = EnumSet . noneOf ( SystemPermission . Type . class ) ; public APIPermissionSet ( ) { } private void addSystemPermissions ( Set < SystemPermission . Type > permissions , SystemPermissionSet permSet ) throws GuacamoleException { for ( SystemPermission permission : permSet . getPermissions ( ) ) permissions . add ( permission . getType ( ) ) ; } private void addObjectPermissions ( Map < String , Set < ObjectPermission . Type > > permissions , ObjectPermissionSet permSet ) throws GuacamoleException { for ( ObjectPermission permission : permSet . getPermissions ( ) ) { String identifier = permission . getObjectIdentifier ( ) ; Set < ObjectPermission . Type > objectPermissions = permissions . get ( identifier ) ; if ( objectPermissions == null ) permissions . put ( identifier , EnumSet . of ( permission . getType ( ) ) ) ; else objectPermissions . add ( permission . getType ( ) ) ; } } public APIPermissionSet ( User user ) throws GuacamoleException { addSystemPermissions ( systemPermissions , user . getSystemPermissions ( ) ) ; addObjectPermissions ( connectionPermissions , user . getConnectionPermissions ( ) ) ; addObjectPermissions ( connectionGroupPermissions , user . getConnectionGroupPermissions ( ) ) ; addObjectPermissions ( activeConnectionPermissions , user . getActiveConnectionPermissions ( ) ) ; addObjectPermissions ( userPermissions , user . getUserPermissions ( ) ) ; } public Map < String , Set < ObjectPermission . Type > > getConnectionPermissions ( ) { return connectionPermissions ; } public Map < String , Set < ObjectPermission . Type > > getConnectionGroupPermissions ( ) { return connectionGroupPermissions ; } public Map < String , Set < ObjectPermission . Type > > getActiveConnectionPermissions ( ) { return activeConnectionPermissions ; } public Map < String , Set < ObjectPermission . Type > > getUserPermissions ( ) { return userPermissions ; } public Set < SystemPermission . Type > getSystemPermissions ( ) { return systemPermissions ; } public void setConnectionPermissions ( Map < String , Set < ObjectPermission . Type > > connectionPermissions ) { this . connectionPermissions = connectionPermissions ; } public void setConnectionGroupPermissions ( Map < String , Set < ObjectPermission . Type > > connectionGroupPermissions ) { this . connectionGroupPermissions = connectionGroupPermissions ; } public void setActiveConnectionPermissions ( Map < String , Set < ObjectPermission . Type > > activeConnectionPermissions ) { this . activeConnectionPermissions = activeConnectionPermissions ; } public void setUserPermissions ( Map < String , Set < ObjectPermission . Type > > userPermissions ) { this . userPermissions = userPermissions ; } public void setSystemPermissions ( Set < SystemPermission . Type > systemPermissions ) { this . systemPermissions = systemPermissions ; } }
package org . glyptodon . guacamole . net . basic . rest . connectiongroup ;
package org . glyptodon . guacamole . net . basic . rest . connectiongroup ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . Connection ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . basic . rest . connection . APIConnection ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class ConnectionGroupTree { private static final Logger logger = LoggerFactory . getLogger ( ConnectionGroupTree . class ) ; private final UserContext userContext ; private final APIConnectionGroup rootAPIGroup ; private final Map < String , APIConnectionGroup > retrievedGroups = new HashMap < String , APIConnectionGroup > ( ) ; private void addConnections ( Collection < Connection > connections ) throws GuacamoleException { for ( Connection connection : connections ) { APIConnectionGroup parent = retrievedGroups . get ( connection . getParentIdentifier ( ) ) ; if ( parent != null ) { Collection < APIConnection > children = parent . getChildConnections ( ) ; if ( children == null ) { children = new ArrayList < APIConnection > ( ) ; parent . setChildConnections ( children ) ; } children . add ( new APIConnection ( connection ) ) ; } else logger . debug ( "Connection \"{}\" cannot be added to the tree: parent \"{}\" does not actually exist." , connection . getIdentifier ( ) , connection . getParentIdentifier ( ) ) ; } } private void addConnectionGroups ( Collection < ConnectionGroup > connectionGroups ) { for ( ConnectionGroup connectionGroup : connectionGroups ) { APIConnectionGroup parent = retrievedGroups . get ( connectionGroup . getParentIdentifier ( ) ) ; if ( parent != null ) { Collection < APIConnectionGroup > children = parent . getChildConnectionGroups ( ) ; if ( children == null ) { children = new ArrayList < APIConnectionGroup > ( ) ; parent . setChildConnectionGroups ( children ) ; } APIConnectionGroup apiConnectionGroup = new APIConnectionGroup ( connectionGroup ) ; retrievedGroups . put ( connectionGroup . getIdentifier ( ) , apiConnectionGroup ) ; children . add ( apiConnectionGroup ) ; } else logger . debug ( "Connection group \"{}\" cannot be added to the tree: parent \"{}\" does not actually exist." , connectionGroup . getIdentifier ( ) , connectionGroup . getParentIdentifier ( ) ) ; } } private void addDescendants ( Collection < ConnectionGroup > parents , List < ObjectPermission . Type > permissions ) throws GuacamoleException { if ( parents . isEmpty ( ) ) return ; Collection < String > childConnectionIdentifiers = new ArrayList < String > ( ) ; Collection < String > childConnectionGroupIdentifiers = new ArrayList < String > ( ) ; for ( ConnectionGroup parent : parents ) { childConnectionIdentifiers . addAll ( parent . getConnectionIdentifiers ( ) ) ; childConnectionGroupIdentifiers . addAll ( parent . getConnectionGroupIdentifiers ( ) ) ; } if ( permissions != null && ! permissions . isEmpty ( ) ) { ObjectPermissionSet permissionSet = userContext . self ( ) . getConnectionPermissions ( ) ; childConnectionIdentifiers = permissionSet . getAccessibleObjects ( permissions , childConnectionIdentifiers ) ; } if ( ! childConnectionIdentifiers . isEmpty ( ) ) { Collection < Connection > childConnections = userContext . getConnectionDirectory ( ) . getAll ( childConnectionIdentifiers ) ; addConnections ( childConnections ) ; } if ( ! childConnectionGroupIdentifiers . isEmpty ( ) ) { Collection < ConnectionGroup > childConnectionGroups = userContext . getConnectionGroupDirectory ( ) . getAll ( childConnectionGroupIdentifiers ) ; addConnectionGroups ( childConnectionGroups ) ; addDescendants ( childConnectionGroups , permissions ) ; } } public ConnectionGroupTree ( UserContext userContext , ConnectionGroup root , List < ObjectPermission . Type > permissions ) throws GuacamoleException { this . userContext = userContext ; this . rootAPIGroup = new APIConnectionGroup ( root ) ; retrievedGroups . put ( root . getIdentifier ( ) , this . rootAPIGroup ) ; addDescendants ( Collections . singleton ( root ) , permissions ) ; } public APIConnectionGroup getRootAPIConnectionGroup ( ) { return rootAPIGroup ; } }
package org . glyptodon . guacamole . net . basic . rest . connectiongroup ; import com . google . inject . Inject ; import java . util . List ; import javax . ws . rs . Consumes ; import javax . ws . rs . DELETE ; import javax . ws . rs . GET ; import javax . ws . rs . POST ; import javax . ws . rs . PUT ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import javax . ws . rs . Produces ; import javax . ws . rs . QueryParam ; import javax . ws . rs . core . MediaType ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . net . auth . Directory ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . basic . rest . AuthProviderRESTExposure ; import org . glyptodon . guacamole . net . basic . rest . ObjectRetrievalService ; import org . glyptodon . guacamole . net . basic . rest . auth . AuthenticationService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; @ Path ( "/connectionGroups" ) @ Produces ( MediaType . APPLICATION_JSON ) @ Consumes ( MediaType . APPLICATION_JSON ) public class ConnectionGroupRESTService { private static final Logger logger = LoggerFactory . getLogger ( ConnectionGroupRESTService . class ) ; @ Inject private AuthenticationService authenticationService ; @ Inject private ObjectRetrievalService retrievalService ; @ GET @ Path ( "/{connectionGroupID}" ) @ AuthProviderRESTExposure public APIConnectionGroup getConnectionGroup ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "connectionGroupID" ) String connectionGroupID ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; return new APIConnectionGroup ( retrievalService . retrieveConnectionGroup ( userContext , connectionGroupID ) ) ; } @ GET @ Path ( "/{connectionGroupID}/tree" ) @ AuthProviderRESTExposure public APIConnectionGroup getConnectionGroupTree ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "connectionGroupID" ) String connectionGroupID , @ QueryParam ( "permission" ) List < ObjectPermission . Type > permissions ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; ConnectionGroup treeRoot = retrievalService . retrieveConnectionGroup ( userContext , connectionGroupID ) ; ConnectionGroupTree tree = new ConnectionGroupTree ( userContext , treeRoot , permissions ) ; return tree . getRootAPIConnectionGroup ( ) ; } @ DELETE @ Path ( "/{connectionGroupID}" ) @ AuthProviderRESTExposure public void deleteConnectionGroup ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "connectionGroupID" ) String connectionGroupID ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; Directory < ConnectionGroup > connectionGroupDirectory = userContext . getConnectionGroupDirectory ( ) ; connectionGroupDirectory . remove ( connectionGroupID ) ; } @ POST @ AuthProviderRESTExposure public String createConnectionGroup ( @ QueryParam ( "token" ) String authToken , APIConnectionGroup connectionGroup ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; if ( connectionGroup == null ) throw new GuacamoleClientException ( "Connection group JSON must be submitted when creating connections groups." ) ; Directory < ConnectionGroup > connectionGroupDirectory = userContext . getConnectionGroupDirectory ( ) ; connectionGroupDirectory . add ( new APIConnectionGroupWrapper ( connectionGroup ) ) ; return connectionGroup . getIdentifier ( ) ; } @ PUT @ Path ( "/{connectionGroupID}" ) @ AuthProviderRESTExposure public void updateConnectionGroup ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "connectionGroupID" ) String connectionGroupID , APIConnectionGroup connectionGroup ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; if ( connectionGroup == null ) throw new GuacamoleClientException ( "Connection group JSON must be submitted when updating connection groups." ) ; Directory < ConnectionGroup > connectionGroupDirectory = userContext . getConnectionGroupDirectory ( ) ; ConnectionGroup existingConnectionGroup = retrievalService . retrieveConnectionGroup ( userContext , connectionGroupID ) ; existingConnectionGroup . setName ( connectionGroup . getName ( ) ) ; existingConnectionGroup . setParentIdentifier ( connectionGroup . getParentIdentifier ( ) ) ; existingConnectionGroup . setType ( connectionGroup . getType ( ) ) ; existingConnectionGroup . setAttributes ( connectionGroup . getAttributes ( ) ) ; connectionGroupDirectory . update ( existingConnectionGroup ) ; } }
package org . glyptodon . guacamole . net . basic . rest . connectiongroup ; import java . util . Collection ; import java . util . Map ; import org . codehaus . jackson . annotate . JsonIgnoreProperties ; import org . codehaus . jackson . map . annotate . JsonSerialize ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . net . auth . ConnectionGroup . Type ; import org . glyptodon . guacamole . net . basic . rest . connection . APIConnection ; @ JsonIgnoreProperties ( ignoreUnknown = true ) @ JsonSerialize ( include = JsonSerialize . Inclusion . NON_NULL ) public class APIConnectionGroup { public static final String ROOT_IDENTIFIER = "ROOT" ; private String name ; private String identifier ; private String parentIdentifier ; private Type type ; private int activeConnections ; private Collection < APIConnectionGroup > childConnectionGroups ; private Collection < APIConnection > childConnections ; private Map < String , String > attributes ; public APIConnectionGroup ( ) { } public APIConnectionGroup ( ConnectionGroup connectionGroup ) { this . identifier = connectionGroup . getIdentifier ( ) ; this . parentIdentifier = connectionGroup . getParentIdentifier ( ) ; this . name = connectionGroup . getName ( ) ; this . type = connectionGroup . getType ( ) ; this . activeConnections = connectionGroup . getActiveConnections ( ) ; this . attributes = connectionGroup . getAttributes ( ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getIdentifier ( ) { return identifier ; } public void setIdentifier ( String identifier ) { this . identifier = identifier ; } public String getParentIdentifier ( ) { return parentIdentifier ; } public void setParentIdentifier ( String parentIdentifier ) { this . parentIdentifier = parentIdentifier ; } public Type getType ( ) { return type ; } public void setType ( Type type ) { this . type = type ; } public Collection < APIConnectionGroup > getChildConnectionGroups ( ) { return childConnectionGroups ; } public void setChildConnectionGroups ( Collection < APIConnectionGroup > childConnectionGroups ) { this . childConnectionGroups = childConnectionGroups ; } public Collection < APIConnection > getChildConnections ( ) { return childConnections ; } public void setChildConnections ( Collection < APIConnection > childConnections ) { this . childConnections = childConnections ; } public int getActiveConnections ( ) { return activeConnections ; } public void setActiveUsers ( int activeConnections ) { this . activeConnections = activeConnections ; } public Map < String , String > getAttributes ( ) { return attributes ; } public void setAttributes ( Map < String , String > attributes ) { this . attributes = attributes ; } }
package org . glyptodon . guacamole . net . basic . rest . connectiongroup ; import java . util . Map ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . protocol . GuacamoleClientInformation ; public class APIConnectionGroupWrapper implements ConnectionGroup { private final APIConnectionGroup apiConnectionGroup ; public APIConnectionGroupWrapper ( APIConnectionGroup apiConnectionGroup ) { this . apiConnectionGroup = apiConnectionGroup ; } @ Override public String getName ( ) { return apiConnectionGroup . getName ( ) ; } @ Override public void setName ( String name ) { apiConnectionGroup . setName ( name ) ; } @ Override public String getIdentifier ( ) { return apiConnectionGroup . getIdentifier ( ) ; } @ Override public void setIdentifier ( String identifier ) { apiConnectionGroup . setIdentifier ( identifier ) ; } @ Override public String getParentIdentifier ( ) { return apiConnectionGroup . getParentIdentifier ( ) ; } @ Override public void setParentIdentifier ( String parentIdentifier ) { apiConnectionGroup . setParentIdentifier ( parentIdentifier ) ; } @ Override public void setType ( Type type ) { apiConnectionGroup . setType ( type ) ; } @ Override public Type getType ( ) { return apiConnectionGroup . getType ( ) ; } @ Override public int getActiveConnections ( ) { return apiConnectionGroup . getActiveConnections ( ) ; } @ Override public Set < String > getConnectionIdentifiers ( ) { throw new UnsupportedOperationException ( "Operation not supported." ) ; } @ Override public Set < String > getConnectionGroupIdentifiers ( ) { throw new UnsupportedOperationException ( "Operation not supported." ) ; } @ Override public Map < String , String > getAttributes ( ) { return apiConnectionGroup . getAttributes ( ) ; } @ Override public void setAttributes ( Map < String , String > attributes ) { apiConnectionGroup . setAttributes ( attributes ) ; } @ Override public GuacamoleTunnel connect ( GuacamoleClientInformation info ) throws GuacamoleException { throw new UnsupportedOperationException ( "Operation not supported." ) ; } }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleResourceConflictException extends GuacamoleClientException { public GuacamoleResourceConflictException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleResourceConflictException ( String message ) { super ( message ) ; } public GuacamoleResourceConflictException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . RESOURCE_CONFLICT ; } }
package org . glyptodon . guacamole . net . basic . rest . clipboard ; import com . google . inject . Inject ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . QueryParam ; import javax . ws . rs . core . Response ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleUnsupportedException ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . net . basic . ClipboardState ; import org . glyptodon . guacamole . net . basic . GuacamoleSession ; import org . glyptodon . guacamole . net . basic . rest . AuthProviderRESTExposure ; import org . glyptodon . guacamole . net . basic . rest . auth . AuthenticationService ; import org . glyptodon . guacamole . properties . BooleanGuacamoleProperty ; @ Path ( "/clipboard" ) public class ClipboardRESTService { @ Inject private Environment environment ; @ Inject private AuthenticationService authenticationService ; private static final int CLIPBOARD_TIMEOUT = 250 ; public static final BooleanGuacamoleProperty INTEGRATION_ENABLED = new BooleanGuacamoleProperty ( ) { @ Override public String getName ( ) { return "enable-clipboard-integration" ; } } ; @ GET @ AuthProviderRESTExposure public Response getClipboard ( @ QueryParam ( "token" ) String authToken ) throws GuacamoleException { if ( environment . getProperty ( INTEGRATION_ENABLED , false ) ) { GuacamoleSession session = authenticationService . getGuacamoleSession ( authToken ) ; final ClipboardState clipboard = session . getClipboardState ( ) ; synchronized ( clipboard ) { clipboard . waitForContents ( CLIPBOARD_TIMEOUT ) ; return Response . ok ( clipboard . getContents ( ) , clipboard . getMimetype ( ) ) . build ( ) ; } } else throw new GuacamoleUnsupportedException ( "Clipboard integration not supported" ) ; } }
package org . glyptodon . guacamole . net . basic . rest . connection ;
package org . glyptodon . guacamole . net . basic . rest . connection ; import java . util . Map ; import org . codehaus . jackson . annotate . JsonIgnoreProperties ; import org . codehaus . jackson . map . annotate . JsonSerialize ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . Connection ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; @ JsonIgnoreProperties ( ignoreUnknown = true ) @ JsonSerialize ( include = JsonSerialize . Inclusion . NON_NULL ) public class APIConnection { private String name ; private String identifier ; private String parentIdentifier ; private String protocol ; private Map < String , String > parameters ; private Map < String , String > attributes ; private int activeConnections ; public APIConnection ( ) { } public APIConnection ( Connection connection ) throws GuacamoleException { this . name = connection . getName ( ) ; this . identifier = connection . getIdentifier ( ) ; this . parentIdentifier = connection . getParentIdentifier ( ) ; this . activeConnections = connection . getActiveConnections ( ) ; GuacamoleConfiguration configuration = connection . getConfiguration ( ) ; this . protocol = configuration . getProtocol ( ) ; this . attributes = connection . getAttributes ( ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getIdentifier ( ) { return identifier ; } public void setIdentifier ( String identifier ) { this . identifier = identifier ; } public String getParentIdentifier ( ) { return parentIdentifier ; } public void setParentIdentifier ( String parentIdentifier ) { this . parentIdentifier = parentIdentifier ; } public Map < String , String > getParameters ( ) { return parameters ; } public void setParameters ( Map < String , String > parameters ) { this . parameters = parameters ; } public String getProtocol ( ) { return protocol ; } public void setProtocol ( String protocol ) { this . protocol = protocol ; } public int getActiveConnections ( ) { return activeConnections ; } public void setActiveUsers ( int activeConnections ) { this . activeConnections = activeConnections ; } public Map < String , String > getAttributes ( ) { return attributes ; } public void setAttributes ( Map < String , String > attributes ) { this . attributes = attributes ; } }
package org . glyptodon . guacamole . net . basic . rest . connection ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . Connection ; import org . glyptodon . guacamole . net . auth . ConnectionRecord ; import org . glyptodon . guacamole . protocol . GuacamoleClientInformation ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; public class APIConnectionWrapper implements Connection { private final APIConnection apiConnection ; public APIConnectionWrapper ( APIConnection apiConnection ) { this . apiConnection = apiConnection ; } @ Override public String getName ( ) { return apiConnection . getName ( ) ; } @ Override public void setName ( String name ) { apiConnection . setName ( name ) ; } @ Override public String getIdentifier ( ) { return apiConnection . getIdentifier ( ) ; } @ Override public void setIdentifier ( String identifier ) { apiConnection . setIdentifier ( identifier ) ; } @ Override public String getParentIdentifier ( ) { return apiConnection . getParentIdentifier ( ) ; } @ Override public void setParentIdentifier ( String parentIdentifier ) { apiConnection . setParentIdentifier ( parentIdentifier ) ; } @ Override public int getActiveConnections ( ) { return apiConnection . getActiveConnections ( ) ; } @ Override public GuacamoleConfiguration getConfiguration ( ) { GuacamoleConfiguration configuration = new GuacamoleConfiguration ( ) ; configuration . setProtocol ( apiConnection . getProtocol ( ) ) ; Map < String , String > parameters = apiConnection . getParameters ( ) ; if ( parameters != null ) configuration . setParameters ( parameters ) ; return configuration ; } @ Override public void setConfiguration ( GuacamoleConfiguration config ) { apiConnection . setProtocol ( config . getProtocol ( ) ) ; apiConnection . setParameters ( config . getParameters ( ) ) ; } @ Override public Map < String , String > getAttributes ( ) { return apiConnection . getAttributes ( ) ; } @ Override public void setAttributes ( Map < String , String > attributes ) { apiConnection . setAttributes ( attributes ) ; } @ Override public GuacamoleTunnel connect ( GuacamoleClientInformation info ) throws GuacamoleException { throw new UnsupportedOperationException ( "Operation not supported." ) ; } @ Override public List < ? extends ConnectionRecord > getHistory ( ) throws GuacamoleException { return Collections . < ConnectionRecord > emptyList ( ) ; } }
package org . glyptodon . guacamole . net . basic . rest . connection ; import com . google . inject . Inject ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import javax . ws . rs . Consumes ; import javax . ws . rs . DELETE ; import javax . ws . rs . GET ; import javax . ws . rs . POST ; import javax . ws . rs . PUT ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import javax . ws . rs . Produces ; import javax . ws . rs . QueryParam ; import javax . ws . rs . core . MediaType ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . net . auth . Connection ; import org . glyptodon . guacamole . net . auth . ConnectionRecord ; import org . glyptodon . guacamole . net . auth . Directory ; import org . glyptodon . guacamole . net . auth . User ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . auth . permission . SystemPermission ; import org . glyptodon . guacamole . net . auth . permission . SystemPermissionSet ; import org . glyptodon . guacamole . net . basic . rest . AuthProviderRESTExposure ; import org . glyptodon . guacamole . net . basic . rest . ObjectRetrievalService ; import org . glyptodon . guacamole . net . basic . rest . auth . AuthenticationService ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; @ Path ( "/connections" ) @ Produces ( MediaType . APPLICATION_JSON ) @ Consumes ( MediaType . APPLICATION_JSON ) public class ConnectionRESTService { private static final Logger logger = LoggerFactory . getLogger ( ConnectionRESTService . class ) ; @ Inject private AuthenticationService authenticationService ; @ Inject private ObjectRetrievalService retrievalService ; @ GET @ Path ( "/{connectionID}" ) @ AuthProviderRESTExposure public APIConnection getConnection ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "connectionID" ) String connectionID ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; return new APIConnection ( retrievalService . retrieveConnection ( userContext , connectionID ) ) ; } @ GET @ Path ( "/{connectionID}/parameters" ) @ AuthProviderRESTExposure public Map < String , String > getConnectionParameters ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "connectionID" ) String connectionID ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; User self = userContext . self ( ) ; SystemPermissionSet systemPermissions = self . getSystemPermissions ( ) ; ObjectPermissionSet connectionPermissions = self . getConnectionPermissions ( ) ; if ( ! systemPermissions . hasPermission ( SystemPermission . Type . ADMINISTER ) && ! connectionPermissions . hasPermission ( ObjectPermission . Type . UPDATE , connectionID ) ) throw new GuacamoleSecurityException ( "Permission to read connection parameters denied." ) ; Connection connection = retrievalService . retrieveConnection ( userContext , connectionID ) ; GuacamoleConfiguration config = connection . getConfiguration ( ) ; return config . getParameters ( ) ; } @ GET @ Path ( "/{connectionID}/history" ) @ AuthProviderRESTExposure public List < APIConnectionRecord > getConnectionHistory ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "connectionID" ) String connectionID ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; Connection connection = retrievalService . retrieveConnection ( userContext , connectionID ) ; List < APIConnectionRecord > apiRecords = new ArrayList < APIConnectionRecord > ( ) ; for ( ConnectionRecord record : connection . getHistory ( ) ) apiRecords . add ( new APIConnectionRecord ( record ) ) ; return apiRecords ; } @ DELETE @ Path ( "/{connectionID}" ) @ AuthProviderRESTExposure public void deleteConnection ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "connectionID" ) String connectionID ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; Directory < Connection > connectionDirectory = userContext . getConnectionDirectory ( ) ; connectionDirectory . remove ( connectionID ) ; } @ POST @ AuthProviderRESTExposure public String createConnection ( @ QueryParam ( "token" ) String authToken , APIConnection connection ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; if ( connection == null ) throw new GuacamoleClientException ( "Connection JSON must be submitted when creating connections." ) ; Directory < Connection > connectionDirectory = userContext . getConnectionDirectory ( ) ; connectionDirectory . add ( new APIConnectionWrapper ( connection ) ) ; return connection . getIdentifier ( ) ; } @ PUT @ Path ( "/{connectionID}" ) @ AuthProviderRESTExposure public void updateConnection ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "connectionID" ) String connectionID , APIConnection connection ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; if ( connection == null ) throw new GuacamoleClientException ( "Connection JSON must be submitted when updating connections." ) ; Directory < Connection > connectionDirectory = userContext . getConnectionDirectory ( ) ; Connection existingConnection = retrievalService . retrieveConnection ( userContext , connectionID ) ; GuacamoleConfiguration config = new GuacamoleConfiguration ( ) ; config . setProtocol ( connection . getProtocol ( ) ) ; config . setParameters ( connection . getParameters ( ) ) ; existingConnection . setConfiguration ( config ) ; existingConnection . setParentIdentifier ( connection . getParentIdentifier ( ) ) ; existingConnection . setName ( connection . getName ( ) ) ; existingConnection . setAttributes ( connection . getAttributes ( ) ) ; connectionDirectory . update ( existingConnection ) ; } }
package org . glyptodon . guacamole . net . basic . rest . connection ; import java . util . Date ; import org . glyptodon . guacamole . net . auth . ConnectionRecord ; public class APIConnectionRecord { private final Date startDate ; private final Date endDate ; private final String remoteHost ; private final String username ; private final boolean active ; public APIConnectionRecord ( ConnectionRecord record ) { this . startDate = record . getStartDate ( ) ; this . endDate = record . getEndDate ( ) ; this . remoteHost = record . getRemoteHost ( ) ; this . username = record . getUsername ( ) ; this . active = record . isActive ( ) ; } public Date getStartDate ( ) { return startDate ; } public Date getEndDate ( ) { return endDate ; } public String getRemoteHost ( ) { return remoteHost ; } public String getUsername ( ) { return username ; } public boolean isActive ( ) { return active ; } }
package org . glyptodon . guacamole . net . basic . rest . user ;
package org . glyptodon . guacamole . net . basic . rest . user ; public class APIUserPasswordUpdate { private String oldPassword ; private String newPassword ; public String getOldPassword ( ) { return oldPassword ; } public void setOldPassword ( String oldPassword ) { this . oldPassword = oldPassword ; } public String getNewPassword ( ) { return newPassword ; } public void setNewPassword ( String newPassword ) { this . newPassword = newPassword ; } }
package org . glyptodon . guacamole . net . basic . rest . user ; import com . google . inject . Inject ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . UUID ; import javax . servlet . http . HttpServletRequest ; import javax . ws . rs . Consumes ; import javax . ws . rs . DELETE ; import javax . ws . rs . GET ; import javax . ws . rs . POST ; import javax . ws . rs . PUT ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import javax . ws . rs . Produces ; import javax . ws . rs . QueryParam ; import javax . ws . rs . core . Context ; import javax . ws . rs . core . MediaType ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleResourceNotFoundException ; import org . glyptodon . guacamole . net . auth . AuthenticationProvider ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . net . auth . Directory ; import org . glyptodon . guacamole . net . auth . User ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . auth . permission . Permission ; import org . glyptodon . guacamole . net . auth . permission . SystemPermission ; import org . glyptodon . guacamole . net . auth . permission . SystemPermissionSet ; import org . glyptodon . guacamole . net . basic . rest . APIError ; import org . glyptodon . guacamole . net . basic . rest . APIPatch ; import static org . glyptodon . guacamole . net . basic . rest . APIPatch . Operation . add ; import static org . glyptodon . guacamole . net . basic . rest . APIPatch . Operation . remove ; import org . glyptodon . guacamole . net . basic . rest . AuthProviderRESTExposure ; import org . glyptodon . guacamole . net . basic . rest . APIException ; import org . glyptodon . guacamole . net . basic . rest . ObjectRetrievalService ; import org . glyptodon . guacamole . net . basic . rest . PATCH ; import org . glyptodon . guacamole . net . basic . rest . auth . AuthenticationService ; import org . glyptodon . guacamole . net . basic . rest . permission . APIPermissionSet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; @ Path ( "/users" ) @ Produces ( MediaType . APPLICATION_JSON ) @ Consumes ( MediaType . APPLICATION_JSON ) public class UserRESTService { private static final Logger logger = LoggerFactory . getLogger ( UserRESTService . class ) ; private static final String CONNECTION_PERMISSION_PATCH_PATH_PREFIX = "/connectionPermissions/" ; private static final String CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX = "/connectionGroupPermissions/" ; private static final String ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX = "/activeConnectionPermissions/" ; private static final String USER_PERMISSION_PATCH_PATH_PREFIX = "/userPermissions/" ; private static final String SYSTEM_PERMISSION_PATCH_PATH = "/systemPermissions" ; @ Inject private AuthenticationService authenticationService ; @ Inject private ObjectRetrievalService retrievalService ; @ Inject private AuthenticationProvider authProvider ; @ GET @ AuthProviderRESTExposure public List < APIUser > getUsers ( @ QueryParam ( "token" ) String authToken , @ QueryParam ( "permission" ) List < ObjectPermission . Type > permissions ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; User self = userContext . self ( ) ; if ( permissions != null && permissions . isEmpty ( ) ) permissions = null ; SystemPermissionSet systemPermissions = self . getSystemPermissions ( ) ; boolean isAdmin = systemPermissions . hasPermission ( SystemPermission . Type . ADMINISTER ) ; Directory < User > userDirectory = userContext . getUserDirectory ( ) ; Collection < String > userIdentifiers = userDirectory . getIdentifiers ( ) ; if ( ! isAdmin && permissions != null ) { ObjectPermissionSet userPermissions = self . getUserPermissions ( ) ; userIdentifiers = userPermissions . getAccessibleObjects ( permissions , userIdentifiers ) ; } List < APIUser > apiUsers = new ArrayList < APIUser > ( ) ; for ( User user : userDirectory . getAll ( userIdentifiers ) ) apiUsers . add ( new APIUser ( user ) ) ; return apiUsers ; } @ GET @ Path ( "/{username}" ) @ AuthProviderRESTExposure public APIUser getUser ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "username" ) String username ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; User user = retrievalService . retrieveUser ( userContext , username ) ; return new APIUser ( user ) ; } @ POST @ AuthProviderRESTExposure public String createUser ( @ QueryParam ( "token" ) String authToken , APIUser user ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; Directory < User > userDirectory = userContext . getUserDirectory ( ) ; if ( user . getPassword ( ) == null ) user . setPassword ( UUID . randomUUID ( ) . toString ( ) ) ; userDirectory . add ( new APIUserWrapper ( user ) ) ; return user . getUsername ( ) ; } @ PUT @ Path ( "/{username}" ) @ AuthProviderRESTExposure public void updateUser ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "username" ) String username , APIUser user ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; Directory < User > userDirectory = userContext . getUserDirectory ( ) ; if ( ! user . getUsername ( ) . equals ( username ) ) throw new APIException ( APIError . Type . BAD_REQUEST , "Username in path does not match username provided JSON data." ) ; if ( userContext . self ( ) . getIdentifier ( ) . equals ( user . getUsername ( ) ) ) { throw new APIException ( APIError . Type . PERMISSION_DENIED , "Permission denied." ) ; } User existingUser = retrievalService . retrieveUser ( userContext , username ) ; if ( user . getPassword ( ) != null ) existingUser . setPassword ( user . getPassword ( ) ) ; existingUser . setAttributes ( user . getAttributes ( ) ) ; userDirectory . update ( existingUser ) ; } @ PUT @ Path ( "/{username}/password" ) @ AuthProviderRESTExposure public void updatePassword ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "username" ) String username , APIUserPasswordUpdate userPasswordUpdate , @ Context HttpServletRequest request ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; Credentials credentials = new Credentials ( ) ; credentials . setUsername ( username ) ; credentials . setPassword ( userPasswordUpdate . getOldPassword ( ) ) ; credentials . setRequest ( request ) ; credentials . setSession ( request . getSession ( true ) ) ; if ( authProvider . getUserContext ( credentials ) == null ) { throw new APIException ( APIError . Type . PERMISSION_DENIED , "Permission denied." ) ; } Directory < User > userDirectory = userContext . getUserDirectory ( ) ; User user = retrievalService . retrieveUser ( userContext , username ) ; user . setPassword ( userPasswordUpdate . getNewPassword ( ) ) ; userDirectory . update ( user ) ; } @ DELETE @ Path ( "/{username}" ) @ AuthProviderRESTExposure public void deleteUser ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "username" ) String username ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; Directory < User > userDirectory = userContext . getUserDirectory ( ) ; User existingUser = userDirectory . get ( username ) ; if ( existingUser == null ) throw new GuacamoleResourceNotFoundException ( "No such user: \"" + username + "\"" ) ; userDirectory . remove ( username ) ; } @ GET @ Path ( "/{username}/permissions" ) @ AuthProviderRESTExposure public APIPermissionSet getPermissions ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "username" ) String username ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; User user ; if ( userContext . self ( ) . getIdentifier ( ) . equals ( username ) ) user = userContext . self ( ) ; else { user = userContext . getUserDirectory ( ) . get ( username ) ; if ( user == null ) throw new GuacamoleResourceNotFoundException ( "No such user: \"" + username + "\"" ) ; } return new APIPermissionSet ( user ) ; } private < PermissionType extends Permission > void updatePermissionSet ( APIPatch . Operation operation , PermissionSetPatch < PermissionType > permissionSetPatch , PermissionType permission ) { switch ( operation ) { case add : permissionSetPatch . addPermission ( permission ) ; break ; case remove : permissionSetPatch . removePermission ( permission ) ; break ; default : throw new APIException ( APIError . Type . BAD_REQUEST , "Unsupported patch operation: \"" + operation + "\"" ) ; } } @ PATCH @ Path ( "/{username}/permissions" ) @ AuthProviderRESTExposure public void patchPermissions ( @ QueryParam ( "token" ) String authToken , @ PathParam ( "username" ) String username , List < APIPatch < String > > patches ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; User user = userContext . getUserDirectory ( ) . get ( username ) ; if ( user == null ) throw new GuacamoleResourceNotFoundException ( "No such user: \"" + username + "\"" ) ; PermissionSetPatch < ObjectPermission > connectionPermissionPatch = new PermissionSetPatch < ObjectPermission > ( ) ; PermissionSetPatch < ObjectPermission > connectionGroupPermissionPatch = new PermissionSetPatch < ObjectPermission > ( ) ; PermissionSetPatch < ObjectPermission > activeConnectionPermissionPatch = new PermissionSetPatch < ObjectPermission > ( ) ; PermissionSetPatch < ObjectPermission > userPermissionPatch = new PermissionSetPatch < ObjectPermission > ( ) ; PermissionSetPatch < SystemPermission > systemPermissionPatch = new PermissionSetPatch < SystemPermission > ( ) ; for ( APIPatch < String > patch : patches ) { String path = patch . getPath ( ) ; if ( path . startsWith ( CONNECTION_PERMISSION_PATCH_PATH_PREFIX ) ) { String identifier = path . substring ( CONNECTION_PERMISSION_PATCH_PATH_PREFIX . length ( ) ) ; ObjectPermission . Type type = ObjectPermission . Type . valueOf ( patch . getValue ( ) ) ; ObjectPermission permission = new ObjectPermission ( type , identifier ) ; updatePermissionSet ( patch . getOp ( ) , connectionPermissionPatch , permission ) ; } else if ( path . startsWith ( CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX ) ) { String identifier = path . substring ( CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX . length ( ) ) ; ObjectPermission . Type type = ObjectPermission . Type . valueOf ( patch . getValue ( ) ) ; ObjectPermission permission = new ObjectPermission ( type , identifier ) ; updatePermissionSet ( patch . getOp ( ) , connectionGroupPermissionPatch , permission ) ; } else if ( path . startsWith ( ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX ) ) { String identifier = path . substring ( ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX . length ( ) ) ; ObjectPermission . Type type = ObjectPermission . Type . valueOf ( patch . getValue ( ) ) ; ObjectPermission permission = new ObjectPermission ( type , identifier ) ; updatePermissionSet ( patch . getOp ( ) , activeConnectionPermissionPatch , permission ) ; } else if ( path . startsWith ( USER_PERMISSION_PATCH_PATH_PREFIX ) ) { String identifier = path . substring ( USER_PERMISSION_PATCH_PATH_PREFIX . length ( ) ) ; ObjectPermission . Type type = ObjectPermission . Type . valueOf ( patch . getValue ( ) ) ; ObjectPermission permission = new ObjectPermission ( type , identifier ) ; updatePermissionSet ( patch . getOp ( ) , userPermissionPatch , permission ) ; } else if ( path . equals ( SYSTEM_PERMISSION_PATCH_PATH ) ) { SystemPermission . Type type = SystemPermission . Type . valueOf ( patch . getValue ( ) ) ; SystemPermission permission = new SystemPermission ( type ) ; updatePermissionSet ( patch . getOp ( ) , systemPermissionPatch , permission ) ; } else throw new APIException ( APIError . Type . BAD_REQUEST , "Unsupported patch path: \"" + path + "\"" ) ; } connectionPermissionPatch . apply ( user . getConnectionPermissions ( ) ) ; connectionGroupPermissionPatch . apply ( user . getConnectionGroupPermissions ( ) ) ; activeConnectionPermissionPatch . apply ( user . getActiveConnectionPermissions ( ) ) ; userPermissionPatch . apply ( user . getUserPermissions ( ) ) ; systemPermissionPatch . apply ( user . getSystemPermissions ( ) ) ; } }
package org . glyptodon . guacamole . net . basic . rest . user ; import java . util . Map ; import org . codehaus . jackson . annotate . JsonIgnoreProperties ; import org . codehaus . jackson . map . annotate . JsonSerialize ; import org . glyptodon . guacamole . net . auth . User ; @ JsonIgnoreProperties ( ignoreUnknown = true ) @ JsonSerialize ( include = JsonSerialize . Inclusion . NON_NULL ) public class APIUser { private String username ; private String password ; private Map < String , String > attributes ; public APIUser ( ) { } public APIUser ( User user ) { this . username = user . getIdentifier ( ) ; this . password = user . getPassword ( ) ; this . attributes = user . getAttributes ( ) ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public Map < String , String > getAttributes ( ) { return attributes ; } public void setAttributes ( Map < String , String > attributes ) { this . attributes = attributes ; } }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleException extends Exception { public GuacamoleException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleException ( String message ) { super ( message ) ; } public GuacamoleException ( Throwable cause ) { super ( cause ) ; } public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . SERVER_ERROR ; } }
package org . glyptodon . guacamole . net . basic . rest . user ; import java . util . Map ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleUnsupportedException ; import org . glyptodon . guacamole . net . auth . User ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . auth . permission . SystemPermissionSet ; public class APIUserWrapper implements User { private final APIUser apiUser ; public APIUserWrapper ( APIUser apiUser ) { this . apiUser = apiUser ; } @ Override public String getIdentifier ( ) { return apiUser . getUsername ( ) ; } @ Override public void setIdentifier ( String username ) { apiUser . setUsername ( username ) ; } @ Override public String getPassword ( ) { return apiUser . getPassword ( ) ; } @ Override public void setPassword ( String password ) { apiUser . setPassword ( password ) ; } @ Override public Map < String , String > getAttributes ( ) { return apiUser . getAttributes ( ) ; } @ Override public void setAttributes ( Map < String , String > attributes ) { apiUser . setAttributes ( attributes ) ; } @ Override public SystemPermissionSet getSystemPermissions ( ) throws GuacamoleException { throw new GuacamoleUnsupportedException ( "APIUserWrapper does not provide permission access." ) ; } @ Override public ObjectPermissionSet getConnectionPermissions ( ) throws GuacamoleException { throw new GuacamoleUnsupportedException ( "APIUserWrapper does not provide permission access." ) ; } @ Override public ObjectPermissionSet getConnectionGroupPermissions ( ) throws GuacamoleException { throw new GuacamoleUnsupportedException ( "APIUserWrapper does not provide permission access." ) ; } @ Override public ObjectPermissionSet getUserPermissions ( ) throws GuacamoleException { throw new GuacamoleUnsupportedException ( "APIUserWrapper does not provide permission access." ) ; } @ Override public ObjectPermissionSet getActiveConnectionPermissions ( ) throws GuacamoleException { throw new GuacamoleUnsupportedException ( "APIUserWrapper does not provide permission access." ) ; } }
package org . glyptodon . guacamole . net . basic . rest . user ; import java . util . HashSet ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . permission . Permission ; import org . glyptodon . guacamole . net . auth . permission . PermissionSet ; public class PermissionSetPatch < PermissionType extends Permission > { private final Set < PermissionType > addedPermissions = new HashSet < PermissionType > ( ) ; private final Set < PermissionType > removedPermissions = new HashSet < PermissionType > ( ) ; public void addPermission ( PermissionType permission ) { addedPermissions . add ( permission ) ; } public void removePermission ( PermissionType permission ) { removedPermissions . add ( permission ) ; } public void apply ( PermissionSet < PermissionType > permissionSet ) throws GuacamoleException { if ( ! addedPermissions . isEmpty ( ) ) permissionSet . addPermissions ( addedPermissions ) ; if ( ! removedPermissions . isEmpty ( ) ) permissionSet . removePermissions ( removedPermissions ) ; } }
package org . glyptodon . guacamole . net . basic . rest . schema ;
package org . glyptodon . guacamole . net . basic . rest . schema ; import com . google . inject . Inject ; import java . util . Collection ; import java . util . Map ; import javax . ws . rs . Consumes ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import javax . ws . rs . QueryParam ; import javax . ws . rs . core . MediaType ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . environment . LocalEnvironment ; import org . glyptodon . guacamole . form . Form ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . net . basic . rest . AuthProviderRESTExposure ; import org . glyptodon . guacamole . net . basic . rest . auth . AuthenticationService ; import org . glyptodon . guacamole . protocols . ProtocolInfo ; @ Path ( "/schema" ) @ Produces ( MediaType . APPLICATION_JSON ) @ Consumes ( MediaType . APPLICATION_JSON ) public class SchemaRESTService { @ Inject private AuthenticationService authenticationService ; @ GET @ Path ( "/users/attributes" ) @ AuthProviderRESTExposure public Collection < Form > getUserAttributes ( @ QueryParam ( "token" ) String authToken ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; return userContext . getUserAttributes ( ) ; } @ GET @ Path ( "/connections/attributes" ) @ AuthProviderRESTExposure public Collection < Form > getConnectionAttributes ( @ QueryParam ( "token" ) String authToken ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; return userContext . getConnectionAttributes ( ) ; } @ GET @ Path ( "/connectionGroups/attributes" ) @ AuthProviderRESTExposure public Collection < Form > getConnectionGroupAttributes ( @ QueryParam ( "token" ) String authToken ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; return userContext . getConnectionGroupAttributes ( ) ; } @ GET @ Path ( "/protocols" ) @ AuthProviderRESTExposure public Map < String , ProtocolInfo > getProtocols ( @ QueryParam ( "token" ) String authToken ) throws GuacamoleException { authenticationService . getUserContext ( authToken ) ; Environment env = new LocalEnvironment ( ) ; return env . getProtocols ( ) ; } }
package org . glyptodon . guacamole . net . basic . rest . activeconnection ; import com . google . inject . Inject ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . ws . rs . Consumes ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import javax . ws . rs . QueryParam ; import javax . ws . rs . core . MediaType ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleUnsupportedException ; import org . glyptodon . guacamole . net . auth . ActiveConnection ; import org . glyptodon . guacamole . net . auth . Directory ; import org . glyptodon . guacamole . net . auth . User ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . auth . permission . SystemPermission ; import org . glyptodon . guacamole . net . auth . permission . SystemPermissionSet ; import org . glyptodon . guacamole . net . basic . rest . APIPatch ; import org . glyptodon . guacamole . net . basic . rest . AuthProviderRESTExposure ; import org . glyptodon . guacamole . net . basic . rest . PATCH ; import org . glyptodon . guacamole . net . basic . rest . auth . AuthenticationService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; @ Path ( "/activeConnections" ) @ Produces ( MediaType . APPLICATION_JSON ) @ Consumes ( MediaType . APPLICATION_JSON ) public class ActiveConnectionRESTService { private static final Logger logger = LoggerFactory . getLogger ( ActiveConnectionRESTService . class ) ; @ Inject private AuthenticationService authenticationService ; @ GET @ AuthProviderRESTExposure public Map < String , APIActiveConnection > getActiveConnections ( @ QueryParam ( "token" ) String authToken , @ QueryParam ( "permission" ) List < ObjectPermission . Type > permissions ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; User self = userContext . self ( ) ; if ( permissions != null && permissions . isEmpty ( ) ) permissions = null ; SystemPermissionSet systemPermissions = self . getSystemPermissions ( ) ; boolean isAdmin = systemPermissions . hasPermission ( SystemPermission . Type . ADMINISTER ) ; Directory < ActiveConnection > activeConnectionDirectory = userContext . getActiveConnectionDirectory ( ) ; Collection < String > activeConnectionIdentifiers = activeConnectionDirectory . getIdentifiers ( ) ; if ( ! isAdmin && permissions != null ) { ObjectPermissionSet activeConnectionPermissions = self . getActiveConnectionPermissions ( ) ; activeConnectionIdentifiers = activeConnectionPermissions . getAccessibleObjects ( permissions , activeConnectionIdentifiers ) ; } Map < String , APIActiveConnection > apiActiveConnections = new HashMap < String , APIActiveConnection > ( ) ; for ( ActiveConnection activeConnection : activeConnectionDirectory . getAll ( activeConnectionIdentifiers ) ) apiActiveConnections . put ( activeConnection . getIdentifier ( ) , new APIActiveConnection ( activeConnection ) ) ; return apiActiveConnections ; } @ PATCH @ AuthProviderRESTExposure public void patchTunnels ( @ QueryParam ( "token" ) String authToken , List < APIPatch < String > > patches ) throws GuacamoleException { UserContext userContext = authenticationService . getUserContext ( authToken ) ; Directory < ActiveConnection > activeConnectionDirectory = userContext . getActiveConnectionDirectory ( ) ; for ( APIPatch < String > patch : patches ) { if ( patch . getOp ( ) != APIPatch . Operation . remove ) throw new GuacamoleUnsupportedException ( "Only the \"remove\" operation is supported when patching active connections." ) ; String path = patch . getPath ( ) ; if ( ! path . startsWith ( "/" ) ) throw new GuacamoleClientException ( "Patch paths must start with \"/\"." ) ; activeConnectionDirectory . remove ( path . substring ( 1 ) ) ; } } }
package org . glyptodon . guacamole . net . basic . rest . activeconnection ; import java . util . Date ; import org . glyptodon . guacamole . net . auth . ActiveConnection ; public class APIActiveConnection { private final String identifier ; private final String connectionIdentifier ; private final Date startDate ; private final String remoteHost ; private final String username ; public APIActiveConnection ( ActiveConnection connection ) { this . identifier = connection . getIdentifier ( ) ; this . connectionIdentifier = connection . getConnectionIdentifier ( ) ; this . startDate = connection . getStartDate ( ) ; this . remoteHost = connection . getRemoteHost ( ) ; this . username = connection . getUsername ( ) ; } public String getConnectionIdentifier ( ) { return connectionIdentifier ; } public Date getStartDate ( ) { return startDate ; } public String getRemoteHost ( ) { return remoteHost ; } public String getUsername ( ) { return username ; } public String getIdentifier ( ) { return identifier ; } }
package org . glyptodon . guacamole . net . basic . resource ;
package org . glyptodon . guacamole . net . basic . resource ; public abstract class AbstractResource implements Resource { private final String mimetype ; private final long lastModified ; public AbstractResource ( String mimetype , long lastModified ) { this . mimetype = mimetype ; this . lastModified = lastModified ; } public AbstractResource ( String mimetype ) { this ( mimetype , System . currentTimeMillis ( ) ) ; } @ Override public long getLastModified ( ) { return lastModified ; } @ Override public String getMimeType ( ) { return mimetype ; } }
package org . glyptodon . guacamole . net . basic . resource ; import java . io . InputStream ; public interface Resource { String getMimeType ( ) ; long getLastModified ( ) ; InputStream asStream ( ) ; }
package org . glyptodon . guacamole . net . basic . resource ; import java . io . InputStream ; public class ClassPathResource extends AbstractResource { private final ClassLoader classLoader ; private final String path ; public ClassPathResource ( ClassLoader classLoader , String mimetype , String path ) { super ( mimetype ) ; this . classLoader = classLoader ; this . path = path ; } public ClassPathResource ( String mimetype , String path ) { this ( ClassPathResource . class . getClassLoader ( ) , mimetype , path ) ; } @ Override public InputStream asStream ( ) { return classLoader . getResourceAsStream ( path ) ; } }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleUpstreamException extends GuacamoleException { public GuacamoleUpstreamException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleUpstreamException ( String message ) { super ( message ) ; } public GuacamoleUpstreamException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . UPSTREAM_ERROR ; } }
package org . glyptodon . guacamole . net . basic . resource ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class ResourceServlet extends HttpServlet { private static final Logger logger = LoggerFactory . getLogger ( ResourceServlet . class ) ; private static final int BUFFER_SIZE = 10240 ; private final Resource resource ; public ResourceServlet ( Resource resource ) { this . resource = resource ; } @ Override protected void doHead ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { response . addDateHeader ( "Last-Modified" , resource . getLastModified ( ) ) ; response . setContentType ( resource . getMimeType ( ) ) ; } @ Override protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { InputStream input = resource . asStream ( ) ; if ( input == null ) { logger . debug ( "Resource does not exist: \"{}\"" , request . getServletPath ( ) ) ; response . setStatus ( HttpServletResponse . SC_NOT_FOUND ) ; return ; } try { doHead ( request , response ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( resource . getLastModified ( ) - ifModifiedSince < 1000 ) { logger . debug ( "Resource not modified: \"{}\"" , request . getServletPath ( ) ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; return ; } int length ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; OutputStream output = response . getOutputStream ( ) ; while ( ( length = input . read ( buffer ) ) != - 1 ) output . write ( buffer , 0 , length ) ; } finally { input . close ( ) ; } } }
package org . glyptodon . guacamole . net . basic . resource ; import java . io . InputStream ; import javax . servlet . ServletContext ; public class WebApplicationResource extends AbstractResource { private final ServletContext context ; private final String path ; private static String getMimeType ( ServletContext context , String path ) { String mimetype = context . getMimeType ( path ) ; if ( mimetype != null ) return mimetype ; return "application/octet-stream" ; } public WebApplicationResource ( ServletContext context , String mimetype , String path ) { super ( mimetype ) ; this . context = context ; this . path = path ; } public WebApplicationResource ( ServletContext context , String path ) { this ( context , getMimeType ( context , path ) , path ) ; } @ Override public InputStream asStream ( ) { return context . getResourceAsStream ( path ) ; } }
package org . glyptodon . guacamole . net . basic . resource ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; public class ByteArrayResource extends AbstractResource { private final byte [ ] bytes ; public ByteArrayResource ( String mimetype , byte [ ] bytes ) { super ( mimetype ) ; this . bytes = bytes ; } @ Override public InputStream asStream ( ) { return new ByteArrayInputStream ( bytes ) ; } }
package org . glyptodon . guacamole . net . basic . resource ; import java . io . InputStream ; import java . io . SequenceInputStream ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . Iterator ; public class SequenceResource extends AbstractResource { private final Iterable < Resource > resources ; private static String getMimeType ( Iterable < Resource > resources ) { Iterator < Resource > resourceIterator = resources . iterator ( ) ; if ( ! resourceIterator . hasNext ( ) ) return "application/octet-stream" ; return resourceIterator . next ( ) . getMimeType ( ) ; } public SequenceResource ( String mimetype , Iterable < Resource > resources ) { super ( mimetype ) ; this . resources = resources ; } public SequenceResource ( Iterable < Resource > resources ) { super ( getMimeType ( resources ) ) ; this . resources = resources ; } public SequenceResource ( String mimetype , Resource ... resources ) { this ( mimetype , Arrays . asList ( resources ) ) ; } public SequenceResource ( Resource ... resources ) { this ( Arrays . asList ( resources ) ) ; } @ Override public InputStream asStream ( ) { return new SequenceInputStream ( new Enumeration < InputStream > ( ) { private final Iterator < Resource > resourceIterator = resources . iterator ( ) ; @ Override public boolean hasMoreElements ( ) { return resourceIterator . hasNext ( ) ; } @ Override public InputStream nextElement ( ) { return resourceIterator . next ( ) . asStream ( ) ; } } ) ; } }
package org . glyptodon . guacamole . net . basic . properties ;
package org . glyptodon . guacamole . net . basic . properties ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . AuthenticationProvider ; import org . glyptodon . guacamole . properties . GuacamoleProperty ; @ Deprecated public abstract class AuthenticationProviderProperty implements GuacamoleProperty < Class < AuthenticationProvider > > { @ Override @ SuppressWarnings ( "unchecked" ) public Class < AuthenticationProvider > parseValue ( String authProviderClassName ) throws GuacamoleException { if ( authProviderClassName == null ) return null ; try { Class < ? > authProviderClass = org . glyptodon . guacamole . net . basic . GuacamoleClassLoader . getInstance ( ) . loadClass ( authProviderClassName ) ; if ( ! AuthenticationProvider . class . isAssignableFrom ( authProviderClass ) ) throw new GuacamoleException ( "Specified authentication provider class is not a AuthenticationProvider." ) ; return ( Class < AuthenticationProvider > ) authProviderClass ; } catch ( ClassNotFoundException e ) { throw new GuacamoleException ( "Authentication provider class not found" , e ) ; } } }
package org . glyptodon . guacamole . net . basic . properties ; import org . glyptodon . guacamole . properties . FileGuacamoleProperty ; import org . glyptodon . guacamole . properties . IntegerGuacamoleProperty ; public class BasicGuacamoleProperties { private BasicGuacamoleProperties ( ) { } @ Deprecated public static final AuthenticationProviderProperty AUTH_PROVIDER = new AuthenticationProviderProperty ( ) { @ Override public String getName ( ) { return "auth-provider" ; } } ; @ Deprecated public static final FileGuacamoleProperty LIB_DIRECTORY = new FileGuacamoleProperty ( ) { @ Override public String getName ( ) { return "lib-directory" ; } } ; public static final IntegerGuacamoleProperty API_SESSION_TIMEOUT = new IntegerGuacamoleProperty ( ) { @ Override public String getName ( ) { return "api-session-timeout" ; } } ; }
package org . glyptodon . guacamole . net . basic . extension ;
package org . glyptodon . guacamole . net . basic . extension ; import com . google . inject . servlet . ServletModule ; import java . io . File ; import java . io . FileFilter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import net . sourceforge . guacamole . net . basic . BasicFileAuthenticationProvider ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . net . auth . AuthenticationProvider ; import org . glyptodon . guacamole . net . basic . properties . BasicGuacamoleProperties ; import org . glyptodon . guacamole . net . basic . resource . Resource ; import org . glyptodon . guacamole . net . basic . resource . ResourceServlet ; import org . glyptodon . guacamole . net . basic . resource . SequenceResource ; import org . glyptodon . guacamole . net . basic . resource . WebApplicationResource ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class ExtensionModule extends ServletModule { private final Logger logger = LoggerFactory . getLogger ( ExtensionModule . class ) ; private static final List < String > ALLOWED_GUACAMOLE_VERSIONS = Collections . unmodifiableList ( Arrays . asList ( "*" , "0.9.6" ) ) ; private static final String LIB_DIRECTORY = "lib" ; private static final String EXTENSIONS_DIRECTORY = "extensions" ; private static final String EXTENSION_SUFFIX = ".jar" ; private final Environment environment ; private Class < ? extends AuthenticationProvider > boundAuthenticationProvider = null ; private final LanguageResourceService languageResourceService = new LanguageResourceService ( ) ; private ClassLoader getParentClassLoader ( ) throws GuacamoleException { File libDir = new File ( environment . getGuacamoleHome ( ) , LIB_DIRECTORY ) ; if ( ! libDir . isDirectory ( ) ) return ExtensionModule . class . getClassLoader ( ) ; return DirectoryClassLoader . getInstance ( libDir ) ; } public ExtensionModule ( Environment environment ) { this . environment = environment ; } @ SuppressWarnings ( "deprecation" ) private Class < AuthenticationProvider > getAuthProviderProperty ( ) { try { Class < AuthenticationProvider > authenticationProvider = environment . getProperty ( BasicGuacamoleProperties . AUTH_PROVIDER ) ; if ( authenticationProvider != null ) logger . warn ( "The \"auth-provider\" and \"lib-directory\" properties are now deprecated. Please use the \"extensions\" and \"lib\" directories within GUACAMOLE_HOME instead." ) ; return authenticationProvider ; } catch ( GuacamoleException e ) { logger . warn ( "Value of deprecated \"auth-provider\" property within guacamole.properties is not valid: {}" , e . getMessage ( ) ) ; logger . debug ( "Error reading authentication provider from guacamole.properties." , e ) ; } return null ; } private void bindAuthenticationProvider ( Class < ? extends AuthenticationProvider > authenticationProvider ) { if ( boundAuthenticationProvider == null ) boundAuthenticationProvider = authenticationProvider ; else { logger . debug ( "Ignoring AuthenticationProvider \"{}\"." , authenticationProvider ) ; logger . warn ( "Only one authentication extension may be used at a time. Please " + "make sure that only one authentication extension is present " + "within the GUACAMOLE_HOME/" + EXTENSIONS_DIRECTORY + " " + "directory, and that you are not also specifying the deprecated " + "\"auth-provider\" property within guacamole.properties." ) ; return ; } logger . debug ( "Binding AuthenticationProvider \"{}\"." , authenticationProvider ) ; bind ( AuthenticationProvider . class ) . toInstance ( new AuthenticationProviderFacade ( authenticationProvider ) ) ; } private void bindAuthenticationProviders ( Collection < Class < AuthenticationProvider > > authProviders ) { for ( Class < AuthenticationProvider > authenticationProvider : authProviders ) bindAuthenticationProvider ( authenticationProvider ) ; } private void serveLanguageResources ( Map < String , Resource > resources ) { for ( Map . Entry < String , Resource > translationResource : resources . entrySet ( ) ) { String path = translationResource . getKey ( ) ; Resource resource = translationResource . getValue ( ) ; String languageKey = languageResourceService . getLanguageKey ( path ) ; if ( languageKey == null ) { logger . warn ( "Invalid language file name: \"{}\"" , path ) ; continue ; } languageResourceService . addLanguageResource ( languageKey , resource ) ; } } private void serveStaticResources ( String prefix , Map < String , Resource > resources ) { for ( Map . Entry < String , Resource > staticResource : resources . entrySet ( ) ) { String path = staticResource . getKey ( ) ; Resource resource = staticResource . getValue ( ) ; serve ( prefix + path ) . with ( new ResourceServlet ( resource ) ) ; } } private boolean isCompatible ( String guacamoleVersion ) { return ALLOWED_GUACAMOLE_VERSIONS . contains ( guacamoleVersion ) ; } private void loadExtensions ( Collection < Resource > javaScriptResources , Collection < Resource > cssResources ) { File extensionsDir = new File ( environment . getGuacamoleHome ( ) , EXTENSIONS_DIRECTORY ) ; if ( ! extensionsDir . isDirectory ( ) ) return ; File [ ] extensionFiles = extensionsDir . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( File file ) { return file . isFile ( ) && file . getName ( ) . endsWith ( EXTENSION_SUFFIX ) ; } } ) ; if ( extensionFiles == null ) { logger . warn ( "Although GUACAMOLE_HOME/" + EXTENSIONS_DIRECTORY + " exists, its contents cannot be read." ) ; return ; } for ( File extensionFile : extensionFiles ) { logger . debug ( "Loading extension: \"{}\"" , extensionFile . getName ( ) ) ; try { Extension extension = new Extension ( getParentClassLoader ( ) , extensionFile ) ; if ( ! isCompatible ( extension . getGuacamoleVersion ( ) ) ) { logger . debug ( "Declared Guacamole version \"{}\" of extension \"{}\" is not compatible with this version of Guacamole." , extension . getGuacamoleVersion ( ) , extensionFile . getName ( ) ) ; throw new GuacamoleServerException ( "Extension \"" + extension . getName ( ) + "\" is not " + "compatible with this version of Guacamole." ) ; } javaScriptResources . addAll ( extension . getJavaScriptResources ( ) . values ( ) ) ; cssResources . addAll ( extension . getCSSResources ( ) . values ( ) ) ; bindAuthenticationProviders ( extension . getAuthenticationProviderClasses ( ) ) ; serveLanguageResources ( extension . getTranslationResources ( ) ) ; String staticResourcePrefix = "/app/ext/" + extension . getNamespace ( ) + "/" ; serveStaticResources ( staticResourcePrefix , extension . getStaticResources ( ) ) ; logger . info ( "Extension \"{}\" loaded." , extension . getName ( ) ) ; } catch ( GuacamoleException e ) { logger . error ( "Extension \"{}\" could not be loaded: {}" , extensionFile . getName ( ) , e . getMessage ( ) ) ; logger . debug ( "Unable to load extension." , e ) ; } } } @ Override protected void configureServlets ( ) { bind ( LanguageResourceService . class ) . toInstance ( languageResourceService ) ; languageResourceService . addLanguageResources ( getServletContext ( ) ) ; Class < AuthenticationProvider > authProviderProperty = getAuthProviderProperty ( ) ; if ( authProviderProperty != null ) bindAuthenticationProvider ( authProviderProperty ) ; Collection < Resource > javaScriptResources = new ArrayList < Resource > ( ) ; javaScriptResources . add ( new WebApplicationResource ( getServletContext ( ) , "/guacamole.min.js" ) ) ; Collection < Resource > cssResources = new ArrayList < Resource > ( ) ; cssResources . add ( new WebApplicationResource ( getServletContext ( ) , "/guacamole.min.css" ) ) ; loadExtensions ( javaScriptResources , cssResources ) ; if ( boundAuthenticationProvider == null ) { logger . info ( "Using default, \"basic\", XML-driven authentication." ) ; bindAuthenticationProvider ( BasicFileAuthenticationProvider . class ) ; } serve ( "/app.js" ) . with ( new ResourceServlet ( new SequenceResource ( javaScriptResources ) ) ) ; serve ( "/app.css" ) . with ( new ResourceServlet ( new SequenceResource ( cssResources ) ) ) ; for ( Map . Entry < String , Resource > entry : languageResourceService . getLanguageResources ( ) . entrySet ( ) ) { String languageKey = entry . getKey ( ) ; Resource resource = entry . getValue ( ) ; serve ( "/translations/" + languageKey + ".json" ) . with ( new ResourceServlet ( resource ) ) ; } } }
package org . glyptodon . guacamole . net . basic . extension ; import java . io . File ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLClassLoader ; import java . security . AccessController ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import java . util . zip . ZipEntry ; import java . util . zip . ZipException ; import java . util . zip . ZipFile ; import org . codehaus . jackson . JsonParseException ; import org . codehaus . jackson . map . ObjectMapper ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; import org . glyptodon . guacamole . net . auth . AuthenticationProvider ; import org . glyptodon . guacamole . net . basic . resource . ClassPathResource ; import org . glyptodon . guacamole . net . basic . resource . Resource ; public class Extension { private static final ObjectMapper mapper = new ObjectMapper ( ) ; private static final String MANIFEST_NAME = "guac-manifest.json" ; private final ExtensionManifest manifest ; private final ClassLoader classLoader ; private final Map < String , Resource > javaScriptResources ; private final Map < String , Resource > cssResources ; private final Map < String , Resource > translationResources ; private final Map < String , Resource > staticResources ; private final Collection < Class < AuthenticationProvider > > authenticationProviderClasses ; private Map < String , Resource > getClassPathResources ( String mimetype , Collection < String > paths ) { if ( paths == null ) return Collections . < String , Resource > emptyMap ( ) ; Map < String , Resource > resources = new HashMap < String , Resource > ( paths . size ( ) ) ; for ( String path : paths ) resources . put ( path , new ClassPathResource ( classLoader , mimetype , path ) ) ; return Collections . unmodifiableMap ( resources ) ; } private Map < String , Resource > getClassPathResources ( Map < String , String > resourceTypes ) { if ( resourceTypes == null ) return Collections . < String , Resource > emptyMap ( ) ; Map < String , Resource > resources = new HashMap < String , Resource > ( resourceTypes . size ( ) ) ; for ( Map . Entry < String , String > resource : resourceTypes . entrySet ( ) ) { String path = resource . getKey ( ) ; String mimetype = resource . getValue ( ) ; resources . put ( path , new ClassPathResource ( classLoader , mimetype , path ) ) ; } return Collections . unmodifiableMap ( resources ) ; } @ SuppressWarnings ( "unchecked" ) private Class < AuthenticationProvider > getAuthenticationProviderClass ( String name ) throws GuacamoleException { try { Class < ? > authenticationProviderClass = classLoader . loadClass ( name ) ; if ( ! AuthenticationProvider . class . isAssignableFrom ( authenticationProviderClass ) ) throw new GuacamoleServerException ( "Authentication providers MUST extend the AuthenticationProvider class." ) ; return ( Class < AuthenticationProvider > ) authenticationProviderClass ; } catch ( ClassNotFoundException e ) { throw new GuacamoleException ( "Authentication provider class not found." , e ) ; } } private Collection < Class < AuthenticationProvider > > getAuthenticationProviderClasses ( Collection < String > names ) throws GuacamoleException { if ( names == null ) return Collections . < Class < AuthenticationProvider > > emptyList ( ) ; Collection < Class < AuthenticationProvider > > classes = new ArrayList < Class < AuthenticationProvider > > ( names . size ( ) ) ; for ( String name : names ) classes . add ( getAuthenticationProviderClass ( name ) ) ; return Collections . unmodifiableCollection ( classes ) ; } public Extension ( final ClassLoader parent , final File file ) throws GuacamoleException { try { ZipFile extension = new ZipFile ( file ) ; try { ZipEntry manifestEntry = extension . getEntry ( MANIFEST_NAME ) ; if ( manifestEntry == null ) throw new GuacamoleServerException ( "Extension " + file . getName ( ) + " is missing " + MANIFEST_NAME ) ; manifest = mapper . readValue ( extension . getInputStream ( manifestEntry ) , ExtensionManifest . class ) ; if ( manifest == null ) throw new GuacamoleServerException ( "Contents of " + MANIFEST_NAME + " must be a valid JSON object." ) ; } finally { extension . close ( ) ; } try { classLoader = AccessController . doPrivileged ( new PrivilegedExceptionAction < ClassLoader > ( ) { @ Override public ClassLoader run ( ) throws GuacamoleException { try { return new URLClassLoader ( new URL [ ] { file . toURI ( ) . toURL ( ) } , parent ) ; } catch ( MalformedURLException e ) { throw new GuacamoleException ( e ) ; } } } ) ; } catch ( PrivilegedActionException e ) { throw ( GuacamoleException ) e . getException ( ) ; } } catch ( ZipException e ) { throw new GuacamoleServerException ( "Extension is not a valid zip file: " + file . getName ( ) , e ) ; } catch ( JsonParseException e ) { throw new GuacamoleServerException ( MANIFEST_NAME + " is not valid JSON: " + file . getName ( ) , e ) ; } catch ( IOException e ) { throw new GuacamoleServerException ( "Unable to read extension: " + file . getName ( ) , e ) ; } cssResources = getClassPathResources ( "text/css" , manifest . getCSSPaths ( ) ) ; javaScriptResources = getClassPathResources ( "text/javascript" , manifest . getJavaScriptPaths ( ) ) ; translationResources = getClassPathResources ( "application/json" , manifest . getTranslationPaths ( ) ) ; staticResources = getClassPathResources ( manifest . getResourceTypes ( ) ) ; authenticationProviderClasses = getAuthenticationProviderClasses ( manifest . getAuthProviders ( ) ) ; } public String getGuacamoleVersion ( ) { return manifest . getGuacamoleVersion ( ) ; } public String getName ( ) { return manifest . getName ( ) ; } public String getNamespace ( ) { return manifest . getNamespace ( ) ; } public Map < String , Resource > getJavaScriptResources ( ) { return javaScriptResources ; } public Map < String , Resource > getCSSResources ( ) { return cssResources ; } public Map < String , Resource > getTranslationResources ( ) { return translationResources ; } public Map < String , Resource > getStaticResources ( ) { return staticResources ; } public Collection < Class < AuthenticationProvider > > getAuthenticationProviderClasses ( ) { return authenticationProviderClasses ; } }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleClientTooManyException extends GuacamoleClientException { public GuacamoleClientTooManyException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleClientTooManyException ( String message ) { super ( message ) ; } public GuacamoleClientTooManyException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . CLIENT_TOO_MANY ; } }
package org . glyptodon . guacamole . net . basic . extension ; import java . io . File ; import java . io . FilenameFilter ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLClassLoader ; import java . security . AccessController ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . ArrayList ; import java . util . Collection ; import org . glyptodon . guacamole . GuacamoleException ; public class DirectoryClassLoader extends URLClassLoader { public static DirectoryClassLoader getInstance ( final File dir ) throws GuacamoleException { try { return AccessController . doPrivileged ( new PrivilegedExceptionAction < DirectoryClassLoader > ( ) { @ Override public DirectoryClassLoader run ( ) throws GuacamoleException { return new DirectoryClassLoader ( dir ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( GuacamoleException ) e . getException ( ) ; } } private static URL [ ] getJarURLs ( File dir ) throws GuacamoleException { if ( ! dir . isDirectory ( ) ) throw new GuacamoleException ( dir + " is not a directory." ) ; Collection < URL > jarURLs = new ArrayList < URL > ( ) ; File [ ] files = dir . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String name ) { return name . endsWith ( ".jar" ) ; } } ) ; if ( files == null ) throw new GuacamoleException ( "Unable to read contents of directory " + dir ) ; for ( File file : files ) { try { jarURLs . add ( file . toURI ( ) . toURL ( ) ) ; } catch ( MalformedURLException e ) { throw new GuacamoleException ( e ) ; } } URL [ ] urls = new URL [ jarURLs . size ( ) ] ; return jarURLs . toArray ( urls ) ; } private DirectoryClassLoader ( File dir ) throws GuacamoleException { super ( getJarURLs ( dir ) , DirectoryClassLoader . class . getClassLoader ( ) ) ; } }
package org . glyptodon . guacamole . net . basic . extension ; import java . util . Collection ; import java . util . Map ; import org . codehaus . jackson . annotate . JsonProperty ; public class ExtensionManifest { private String guacamoleVersion ; private String name ; private String namespace ; private Collection < String > javaScriptPaths ; private Collection < String > cssPaths ; private Collection < String > translationPaths ; private Map < String , String > resourceTypes ; private Collection < String > authProviders ; public String getGuacamoleVersion ( ) { return guacamoleVersion ; } public void setGuacamoleVersion ( String guacamoleVersion ) { this . guacamoleVersion = guacamoleVersion ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } @ JsonProperty ( "js" ) public Collection < String > getJavaScriptPaths ( ) { return javaScriptPaths ; } @ JsonProperty ( "js" ) public void setJavaScriptPaths ( Collection < String > javaScriptPaths ) { this . javaScriptPaths = javaScriptPaths ; } @ JsonProperty ( "css" ) public Collection < String > getCSSPaths ( ) { return cssPaths ; } @ JsonProperty ( "css" ) public void setCSSPaths ( Collection < String > cssPaths ) { this . cssPaths = cssPaths ; } @ JsonProperty ( "translations" ) public Collection < String > getTranslationPaths ( ) { return translationPaths ; } @ JsonProperty ( "translations" ) public void setTranslationPaths ( Collection < String > translationPaths ) { this . translationPaths = translationPaths ; } @ JsonProperty ( "resources" ) public Map < String , String > getResourceTypes ( ) { return resourceTypes ; } @ JsonProperty ( "resources" ) public void setResourceTypes ( Map < String , String > resourceTypes ) { this . resourceTypes = resourceTypes ; } public Collection < String > getAuthProviders ( ) { return authProviders ; } public void setAuthProviders ( Collection < String > authProviders ) { this . authProviders = authProviders ; } }
package org . glyptodon . guacamole . net . basic . extension ; import java . io . IOException ; import java . io . InputStream ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import javax . servlet . ServletContext ; import org . codehaus . jackson . JsonNode ; import org . codehaus . jackson . map . ObjectMapper ; import org . codehaus . jackson . node . JsonNodeFactory ; import org . codehaus . jackson . node . ObjectNode ; import org . glyptodon . guacamole . net . basic . resource . ByteArrayResource ; import org . glyptodon . guacamole . net . basic . resource . Resource ; import org . glyptodon . guacamole . net . basic . resource . WebApplicationResource ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class LanguageResourceService { private final Logger logger = LoggerFactory . getLogger ( LanguageResourceService . class ) ; private static final String TRANSLATION_PATH = "/translations" ; private static final String LANGUAGE_DISPLAY_NAME_KEY = "NAME" ; private static final ObjectMapper mapper = new ObjectMapper ( ) ; private static final Pattern LANGUAGE_KEY_PATTERN = Pattern . compile ( ".*/([a-z]+(_[A-Z]+)?)\\.json" ) ; private final Map < String , Resource > resources = new HashMap < String , Resource > ( ) ; public String getLanguageKey ( String path ) { Matcher languageKeyMatcher = LANGUAGE_KEY_PATTERN . matcher ( path ) ; if ( ! languageKeyMatcher . matches ( ) ) return null ; return languageKeyMatcher . group ( 1 ) ; } private JsonNode mergeTranslations ( JsonNode original , JsonNode overlay ) { if ( ! overlay . isObject ( ) || original == null ) return overlay ; ObjectNode newNode = JsonNodeFactory . instance . objectNode ( ) ; Iterator < String > fieldNames = original . getFieldNames ( ) ; while ( fieldNames . hasNext ( ) ) { String fieldName = fieldNames . next ( ) ; newNode . put ( fieldName , original . get ( fieldName ) ) ; } fieldNames = overlay . getFieldNames ( ) ; while ( fieldNames . hasNext ( ) ) { String fieldName = fieldNames . next ( ) ; newNode . put ( fieldName , mergeTranslations ( original . get ( fieldName ) , overlay . get ( fieldName ) ) ) ; } return newNode ; } private JsonNode parseLanguageResource ( Resource resource ) throws IOException { InputStream stream = resource . asStream ( ) ; if ( stream == null ) return null ; try { JsonNode tree = mapper . readTree ( stream ) ; return tree ; } finally { stream . close ( ) ; } } public void addLanguageResource ( String key , Resource resource ) { Resource existing = resources . get ( key ) ; if ( existing != null ) { try { JsonNode existingTree = parseLanguageResource ( existing ) ; if ( existingTree == null ) { logger . warn ( "Base language resource \"{}\" does not exist." , key ) ; return ; } JsonNode resourceTree = parseLanguageResource ( resource ) ; if ( resourceTree == null ) { logger . warn ( "Overlay language resource \"{}\" does not exist." , key ) ; return ; } JsonNode mergedTree = mergeTranslations ( existingTree , resourceTree ) ; resources . put ( key , new ByteArrayResource ( "application/json" , mapper . writeValueAsBytes ( mergedTree ) ) ) ; logger . debug ( "Merged strings with existing language: \"{}\"" , key ) ; } catch ( IOException e ) { logger . error ( "Unable to merge language resource \"{}\": {}" , key , e . getMessage ( ) ) ; logger . debug ( "Error merging language resource." , e ) ; } } else { resources . put ( key , resource ) ; logger . debug ( "Added language: \"{}\"" , key ) ; } } public void addLanguageResources ( ServletContext context ) { Set < ? > resourcePaths = context . getResourcePaths ( TRANSLATION_PATH ) ; if ( resourcePaths == null ) return ; for ( Object resourcePathObject : resourcePaths ) { String resourcePath = ( String ) resourcePathObject ; String languageKey = getLanguageKey ( resourcePath ) ; if ( languageKey == null ) { logger . warn ( "Invalid language file name: \"{}\"" , resourcePath ) ; continue ; } addLanguageResource ( languageKey , new WebApplicationResource ( context , "application/json" , resourcePath ) ) ; } } public Set < String > getLanguageKeys ( ) { return Collections . unmodifiableSet ( resources . keySet ( ) ) ; } public Map < String , Resource > getLanguageResources ( ) { return Collections . unmodifiableMap ( resources ) ; } public Map < String , String > getLanguageNames ( ) { Map < String , String > languageNames = new HashMap < String , String > ( ) ; for ( Map . Entry < String , Resource > entry : resources . entrySet ( ) ) { String languageKey = entry . getKey ( ) ; Resource resource = entry . getValue ( ) ; InputStream resourceStream = resource . asStream ( ) ; if ( resourceStream == null ) { logger . warn ( "Expected language resource does not exist: \"{}\"." , languageKey ) ; continue ; } try { JsonNode tree = mapper . readTree ( resourceStream ) ; JsonNode nameNode = tree . get ( LANGUAGE_DISPLAY_NAME_KEY ) ; String languageName ; if ( nameNode == null || ( languageName = nameNode . getTextValue ( ) ) == null ) { logger . warn ( "Root-level \"" + LANGUAGE_DISPLAY_NAME_KEY + "\" string missing or invalid in language \"{}\"" , languageKey ) ; languageName = languageKey ; } languageNames . put ( languageKey , languageName ) ; } catch ( IOException e ) { logger . warn ( "Unable to read language resource \"{}\"." , languageKey ) ; logger . debug ( "Error reading language resource." , e ) ; } } return Collections . unmodifiableMap ( languageNames ) ; } }
package org . glyptodon . guacamole . net . basic . extension ; import java . lang . reflect . InvocationTargetException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . AuthenticationProvider ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . net . auth . credentials . CredentialsInfo ; import org . glyptodon . guacamole . net . auth . credentials . GuacamoleInvalidCredentialsException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class AuthenticationProviderFacade implements AuthenticationProvider { private Logger logger = LoggerFactory . getLogger ( AuthenticationProviderFacade . class ) ; private final AuthenticationProvider authProvider ; public AuthenticationProviderFacade ( Class < ? extends AuthenticationProvider > authProviderClass ) { AuthenticationProvider instance = null ; try { instance = authProviderClass . getConstructor ( ) . newInstance ( ) ; } catch ( NoSuchMethodException e ) { logger . error ( "The authentication extension in use is not properly defined. " + "Please contact the developers of the extension or, if you " + "are the developer, turn on debug-level logging." ) ; logger . debug ( "AuthenticationProvider is missing a default constructor." , e ) ; } catch ( SecurityException e ) { logger . error ( "The Java security mananager is preventing authentication extensions " + "from being loaded. Please check the configuration of Java or your " + "servlet container." ) ; logger . debug ( "Creation of AuthenticationProvider disallowed by security manager." , e ) ; } catch ( InstantiationException e ) { logger . error ( "The authentication extension in use is not properly defined. " + "Please contact the developers of the extension or, if you " + "are the developer, turn on debug-level logging." ) ; logger . debug ( "AuthenticationProvider cannot be instantiated." , e ) ; } catch ( IllegalAccessException e ) { logger . error ( "The authentication extension in use is not properly defined. " + "Please contact the developers of the extension or, if you " + "are the developer, turn on debug-level logging." ) ; logger . debug ( "Default constructor of AuthenticationProvider is not public." , e ) ; } catch ( IllegalArgumentException e ) { logger . error ( "The authentication extension in use is not properly defined. " + "Please contact the developers of the extension or, if you " + "are the developer, turn on debug-level logging." ) ; logger . debug ( "Default constructor of AuthenticationProvider cannot accept zero arguments." , e ) ; } catch ( InvocationTargetException e ) { Throwable cause = e . getCause ( ) ; if ( cause == null ) cause = new GuacamoleException ( "Error encountered during initialization." ) ; logger . error ( "Authentication extension failed to start: {}" , cause . getMessage ( ) ) ; logger . debug ( "AuthenticationProvider instantiation failed." , e ) ; } authProvider = instance ; } @ Override public UserContext getUserContext ( Credentials credentials ) throws GuacamoleException { if ( authProvider == null ) { logger . warn ( "Authentication attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs." ) ; throw new GuacamoleInvalidCredentialsException ( "Permission denied." , CredentialsInfo . USERNAME_PASSWORD ) ; } return authProvider . getUserContext ( credentials ) ; } @ Override public UserContext updateUserContext ( UserContext context , Credentials credentials ) throws GuacamoleException { if ( authProvider == null ) { logger . warn ( "Reauthentication attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs." ) ; throw new GuacamoleInvalidCredentialsException ( "Permission denied." , CredentialsInfo . USERNAME_PASSWORD ) ; } return authProvider . updateUserContext ( context , credentials ) ; } }
package net . sourceforge . guacamole . net . basic ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Map ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . environment . LocalEnvironment ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . net . auth . simple . SimpleAuthenticationProvider ; import org . glyptodon . guacamole . net . basic . auth . Authorization ; import org . glyptodon . guacamole . net . basic . auth . UserMapping ; import org . glyptodon . guacamole . xml . DocumentHandler ; import org . glyptodon . guacamole . net . basic . xml . user_mapping . UserMappingTagHandler ; import org . glyptodon . guacamole . properties . FileGuacamoleProperty ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class BasicFileAuthenticationProvider extends SimpleAuthenticationProvider { private Logger logger = LoggerFactory . getLogger ( BasicFileAuthenticationProvider . class ) ; private long mod_time ; private UserMapping user_mapping ; private final Environment environment ; public static final FileGuacamoleProperty BASIC_USER_MAPPING = new FileGuacamoleProperty ( ) { @ Override public String getName ( ) { return "basic-user-mapping" ; } } ; public static final String DEFAULT_USER_MAPPING = "user-mapping.xml" ; public BasicFileAuthenticationProvider ( ) throws GuacamoleException { environment = new LocalEnvironment ( ) ; } private UserMapping getUserMapping ( ) throws GuacamoleException { File user_mapping_file = environment . getProperty ( BASIC_USER_MAPPING ) ; if ( user_mapping_file == null ) user_mapping_file = new File ( environment . getGuacamoleHome ( ) , DEFAULT_USER_MAPPING ) ; if ( user_mapping == null || ( user_mapping_file . exists ( ) && mod_time < user_mapping_file . lastModified ( ) ) ) { logger . debug ( "Reading user mapping file: \"{}\"" , user_mapping_file ) ; try { UserMappingTagHandler userMappingHandler = new UserMappingTagHandler ( ) ; DocumentHandler contentHandler = new DocumentHandler ( "user-mapping" , userMappingHandler ) ; XMLReader parser = XMLReaderFactory . createXMLReader ( ) ; parser . setContentHandler ( contentHandler ) ; InputStream input = new BufferedInputStream ( new FileInputStream ( user_mapping_file ) ) ; parser . parse ( new InputSource ( input ) ) ; input . close ( ) ; mod_time = user_mapping_file . lastModified ( ) ; user_mapping = userMappingHandler . asUserMapping ( ) ; } catch ( IOException e ) { throw new GuacamoleException ( "Error reading basic user mapping file." , e ) ; } catch ( SAXException e ) { throw new GuacamoleException ( "Error parsing basic user mapping XML." , e ) ; } } return user_mapping ; } @ Override public Map < String , GuacamoleConfiguration > getAuthorizedConfigurations ( Credentials credentials ) throws GuacamoleException { Authorization auth = getUserMapping ( ) . getAuthorization ( credentials . getUsername ( ) ) ; if ( auth != null && auth . validate ( credentials . getUsername ( ) , credentials . getPassword ( ) ) ) return auth . getConfigurations ( ) ; return null ; } }
package org . glyptodon . guacamole . net . example ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpSession ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . GuacamoleSocket ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . InetGuacamoleSocket ; import org . glyptodon . guacamole . net . SimpleGuacamoleTunnel ; import org . glyptodon . guacamole . protocol . ConfiguredGuacamoleSocket ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; import org . glyptodon . guacamole . servlet . GuacamoleHTTPTunnelServlet ; import org . glyptodon . guacamole . servlet . GuacamoleSession ; public class DummyGuacamoleTunnelServlet extends GuacamoleHTTPTunnelServlet { @ Override protected GuacamoleTunnel doConnect ( HttpServletRequest request ) throws GuacamoleException { HttpSession httpSession = request . getSession ( true ) ; String hostname = "localhost" ; int port = 4822 ; GuacamoleConfiguration config = new GuacamoleConfiguration ( ) ; config . setProtocol ( "vnc" ) ; config . setParameter ( "hostname" , "localhost" ) ; config . setParameter ( "port" , "5901" ) ; config . setParameter ( "password" , "potato" ) ; GuacamoleSocket socket = new ConfiguredGuacamoleSocket ( new InetGuacamoleSocket ( hostname , port ) , config ) ; GuacamoleTunnel tunnel = new SimpleGuacamoleTunnel ( socket ) ; GuacamoleSession session = new GuacamoleSession ( httpSession ) ; session . attachTunnel ( tunnel ) ; return tunnel ; } }
package net . sourceforge . guacamole . net . auth . mysql ;
package net . sourceforge . guacamole . net . auth . mysql ; import com . google . inject . Binder ; import com . google . inject . Module ; import com . google . inject . name . Names ; import java . util . Properties ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . environment . Environment ; import org . mybatis . guice . datasource . helper . JdbcHelper ; public class MySQLAuthenticationProviderModule implements Module { private final Properties myBatisProperties = new Properties ( ) ; private final Properties driverProperties = new Properties ( ) ; public MySQLAuthenticationProviderModule ( Environment environment ) throws GuacamoleException { myBatisProperties . setProperty ( "mybatis.environment.id" , "guacamole" ) ; myBatisProperties . setProperty ( "JDBC.host" , environment . getRequiredProperty ( MySQLGuacamoleProperties . MYSQL_HOSTNAME ) ) ; myBatisProperties . setProperty ( "JDBC.port" , String . valueOf ( environment . getRequiredProperty ( MySQLGuacamoleProperties . MYSQL_PORT ) ) ) ; myBatisProperties . setProperty ( "JDBC.schema" , environment . getRequiredProperty ( MySQLGuacamoleProperties . MYSQL_DATABASE ) ) ; myBatisProperties . setProperty ( "JDBC.username" , environment . getRequiredProperty ( MySQLGuacamoleProperties . MYSQL_USERNAME ) ) ; myBatisProperties . setProperty ( "JDBC.password" , environment . getRequiredProperty ( MySQLGuacamoleProperties . MYSQL_PASSWORD ) ) ; myBatisProperties . setProperty ( "JDBC.autoCommit" , "false" ) ; myBatisProperties . setProperty ( "mybatis.pooled.pingEnabled" , "true" ) ; myBatisProperties . setProperty ( "mybatis.pooled.pingQuery" , "SELECT 1" ) ; driverProperties . setProperty ( "characterEncoding" , "UTF-8" ) ; } @ Override public void configure ( Binder binder ) { JdbcHelper . MySQL . configure ( binder ) ; Names . bindProperties ( binder , myBatisProperties ) ; binder . bind ( Properties . class ) . annotatedWith ( Names . named ( "JDBC.driverProperties" ) ) . toInstance ( driverProperties ) ; } }
package net . sourceforge . guacamole . net . auth . mysql ; import org . glyptodon . guacamole . properties . BooleanGuacamoleProperty ; import org . glyptodon . guacamole . properties . IntegerGuacamoleProperty ; import org . glyptodon . guacamole . properties . StringGuacamoleProperty ; public class MySQLGuacamoleProperties { private MySQLGuacamoleProperties ( ) { } public static final StringGuacamoleProperty MYSQL_HOSTNAME = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "mysql-hostname" ; } } ; public static final IntegerGuacamoleProperty MYSQL_PORT = new IntegerGuacamoleProperty ( ) { @ Override public String getName ( ) { return "mysql-port" ; } } ; public static final StringGuacamoleProperty MYSQL_DATABASE = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "mysql-database" ; } } ; public static final StringGuacamoleProperty MYSQL_USERNAME = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "mysql-username" ; } } ; public static final StringGuacamoleProperty MYSQL_PASSWORD = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "mysql-password" ; } } ; public static final BooleanGuacamoleProperty MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS = new BooleanGuacamoleProperty ( ) { @ Override public String getName ( ) { return "mysql-disallow-simultaneous-connections" ; } } ; public static final BooleanGuacamoleProperty MYSQL_DISALLOW_DUPLICATE_CONNECTIONS = new BooleanGuacamoleProperty ( ) { @ Override public String getName ( ) { return "mysql-disallow-duplicate-connections" ; } } ; }
package net . sourceforge . guacamole . net . auth . mysql ; import com . google . inject . Guice ; import com . google . inject . Injector ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . AuthenticationProvider ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . auth . jdbc . JDBCAuthenticationProviderModule ; import org . glyptodon . guacamole . auth . jdbc . tunnel . GuacamoleTunnelService ; import org . glyptodon . guacamole . auth . jdbc . tunnel . MultiseatGuacamoleTunnelService ; import org . glyptodon . guacamole . auth . jdbc . tunnel . BalancedGuacamoleTunnelService ; import org . glyptodon . guacamole . auth . jdbc . tunnel . SingleSeatGuacamoleTunnelService ; import org . glyptodon . guacamole . auth . jdbc . tunnel . UnrestrictedGuacamoleTunnelService ; import org . glyptodon . guacamole . auth . jdbc . user . UserContextService ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . environment . LocalEnvironment ; public class MySQLAuthenticationProvider implements AuthenticationProvider { private final Injector injector ; private Class < ? extends GuacamoleTunnelService > getSocketServiceClass ( Environment environment ) throws GuacamoleException { boolean disallowSimultaneous = environment . getProperty ( MySQLGuacamoleProperties . MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS , false ) ; boolean disallowDuplicate = environment . getProperty ( MySQLGuacamoleProperties . MYSQL_DISALLOW_DUPLICATE_CONNECTIONS , true ) ; if ( disallowSimultaneous ) { if ( disallowDuplicate ) return SingleSeatGuacamoleTunnelService . class ; else return BalancedGuacamoleTunnelService . class ; } else { if ( disallowDuplicate ) return MultiseatGuacamoleTunnelService . class ; else return UnrestrictedGuacamoleTunnelService . class ; } } public MySQLAuthenticationProvider ( ) throws GuacamoleException { Environment environment = new LocalEnvironment ( ) ; injector = Guice . createInjector ( new MySQLAuthenticationProviderModule ( environment ) , new JDBCAuthenticationProviderModule ( environment , getSocketServiceClass ( environment ) ) ) ; } @ Override public UserContext getUserContext ( Credentials credentials ) throws GuacamoleException { UserContextService userContextService = injector . getInstance ( UserContextService . class ) ; return userContextService . getUserContext ( credentials ) ; } @ Override public UserContext updateUserContext ( UserContext context , Credentials credentials ) throws GuacamoleException { return context ; } }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleClientOverrunException extends GuacamoleClientException { public GuacamoleClientOverrunException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleClientOverrunException ( String message ) { super ( message ) ; } public GuacamoleClientOverrunException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . CLIENT_OVERRUN ; } }
package org . glyptodon . guacamole . auth . jdbc ;
package org . glyptodon . guacamole . auth . jdbc ; import org . glyptodon . guacamole . auth . jdbc . user . UserContext ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . RootConnectionGroup ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . ModeledConnectionGroup ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . ConnectionGroupDirectory ; import org . glyptodon . guacamole . auth . jdbc . connection . ConnectionDirectory ; import org . glyptodon . guacamole . auth . jdbc . connection . ModeledGuacamoleConfiguration ; import org . glyptodon . guacamole . auth . jdbc . connection . ModeledConnection ; import org . glyptodon . guacamole . auth . jdbc . permission . SystemPermissionSet ; import org . glyptodon . guacamole . auth . jdbc . user . ModeledUser ; import org . glyptodon . guacamole . auth . jdbc . user . UserDirectory ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . ConnectionGroupMapper ; import org . glyptodon . guacamole . auth . jdbc . connection . ConnectionMapper ; import org . glyptodon . guacamole . auth . jdbc . connection . ConnectionRecordMapper ; import org . glyptodon . guacamole . auth . jdbc . connection . ParameterMapper ; import org . glyptodon . guacamole . auth . jdbc . permission . SystemPermissionMapper ; import org . glyptodon . guacamole . auth . jdbc . user . UserMapper ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . ConnectionGroupService ; import org . glyptodon . guacamole . auth . jdbc . connection . ConnectionService ; import org . glyptodon . guacamole . auth . jdbc . tunnel . GuacamoleTunnelService ; import org . glyptodon . guacamole . auth . jdbc . security . PasswordEncryptionService ; import org . glyptodon . guacamole . auth . jdbc . security . SHA256PasswordEncryptionService ; import org . glyptodon . guacamole . auth . jdbc . security . SaltService ; import org . glyptodon . guacamole . auth . jdbc . security . SecureRandomSaltService ; import org . glyptodon . guacamole . auth . jdbc . permission . SystemPermissionService ; import org . glyptodon . guacamole . auth . jdbc . user . UserService ; import org . apache . ibatis . transaction . jdbc . JdbcTransactionFactory ; import org . glyptodon . guacamole . auth . jdbc . permission . ConnectionGroupPermissionMapper ; import org . glyptodon . guacamole . auth . jdbc . permission . ConnectionGroupPermissionService ; import org . glyptodon . guacamole . auth . jdbc . permission . ConnectionGroupPermissionSet ; import org . glyptodon . guacamole . auth . jdbc . permission . ConnectionPermissionMapper ; import org . glyptodon . guacamole . auth . jdbc . permission . ConnectionPermissionService ; import org . glyptodon . guacamole . auth . jdbc . permission . ConnectionPermissionSet ; import org . glyptodon . guacamole . auth . jdbc . permission . UserPermissionMapper ; import org . glyptodon . guacamole . auth . jdbc . permission . UserPermissionService ; import org . glyptodon . guacamole . auth . jdbc . permission . UserPermissionSet ; import org . glyptodon . guacamole . auth . jdbc . activeconnection . ActiveConnectionDirectory ; import org . glyptodon . guacamole . auth . jdbc . activeconnection . ActiveConnectionPermissionService ; import org . glyptodon . guacamole . auth . jdbc . activeconnection . ActiveConnectionPermissionSet ; import org . glyptodon . guacamole . auth . jdbc . activeconnection . ActiveConnectionService ; import org . glyptodon . guacamole . auth . jdbc . activeconnection . TrackedActiveConnection ; import org . glyptodon . guacamole . environment . Environment ; import org . mybatis . guice . MyBatisModule ; import org . mybatis . guice . datasource . builtin . PooledDataSourceProvider ; public class JDBCAuthenticationProviderModule extends MyBatisModule { private final Environment environment ; private final Class < ? extends GuacamoleTunnelService > tunnelServiceClass ; public JDBCAuthenticationProviderModule ( Environment environment , Class < ? extends GuacamoleTunnelService > tunnelServiceClass ) { this . environment = environment ; this . tunnelServiceClass = tunnelServiceClass ; } @ Override protected void initialize ( ) { bindDataSourceProviderType ( PooledDataSourceProvider . class ) ; bindTransactionFactoryType ( JdbcTransactionFactory . class ) ; addMapperClass ( ConnectionMapper . class ) ; addMapperClass ( ConnectionGroupMapper . class ) ; addMapperClass ( ConnectionGroupPermissionMapper . class ) ; addMapperClass ( ConnectionPermissionMapper . class ) ; addMapperClass ( ConnectionRecordMapper . class ) ; addMapperClass ( ParameterMapper . class ) ; addMapperClass ( SystemPermissionMapper . class ) ; addMapperClass ( UserMapper . class ) ; addMapperClass ( UserPermissionMapper . class ) ; bind ( ActiveConnectionDirectory . class ) ; bind ( ActiveConnectionPermissionSet . class ) ; bind ( Environment . class ) . toInstance ( environment ) ; bind ( ConnectionDirectory . class ) ; bind ( ConnectionGroupDirectory . class ) ; bind ( ConnectionGroupPermissionSet . class ) ; bind ( ConnectionPermissionSet . class ) ; bind ( ModeledConnection . class ) ; bind ( ModeledConnectionGroup . class ) ; bind ( ModeledGuacamoleConfiguration . class ) ; bind ( ModeledUser . class ) ; bind ( RootConnectionGroup . class ) ; bind ( SystemPermissionSet . class ) ; bind ( TrackedActiveConnection . class ) ; bind ( UserContext . class ) ; bind ( UserDirectory . class ) ; bind ( UserPermissionSet . class ) ; bind ( ActiveConnectionService . class ) ; bind ( ActiveConnectionPermissionService . class ) ; bind ( ConnectionGroupPermissionService . class ) ; bind ( ConnectionGroupService . class ) ; bind ( ConnectionPermissionService . class ) ; bind ( ConnectionService . class ) ; bind ( PasswordEncryptionService . class ) . to ( SHA256PasswordEncryptionService . class ) ; bind ( SaltService . class ) . to ( SecureRandomSaltService . class ) ; bind ( SystemPermissionService . class ) ; bind ( UserPermissionService . class ) ; bind ( UserService . class ) ; bind ( GuacamoleTunnelService . class ) . to ( tunnelServiceClass ) ; } }
package org . glyptodon . guacamole . auth . jdbc . tunnel ;
package org . glyptodon . guacamole . auth . jdbc . tunnel ; import com . google . inject . Singleton ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; import org . glyptodon . guacamole . GuacamoleClientTooManyException ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . connection . ModeledConnection ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleResourceConflictException ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . ModeledConnectionGroup ; @ Singleton public class SingleSeatGuacamoleTunnelService extends AbstractGuacamoleTunnelService { private final Set < String > activeConnections = Collections . newSetFromMap ( new ConcurrentHashMap < String , Boolean > ( ) ) ; private final Set < Seat > activeGroupSeats = Collections . newSetFromMap ( new ConcurrentHashMap < Seat , Boolean > ( ) ) ; @ Override protected ModeledConnection acquire ( AuthenticatedUser user , List < ModeledConnection > connections ) throws GuacamoleException { for ( ModeledConnection connection : connections ) { if ( activeConnections . add ( connection . getIdentifier ( ) ) ) return connection ; } throw new GuacamoleResourceConflictException ( "Cannot connect. This connection is in use." ) ; } @ Override protected void release ( AuthenticatedUser user , ModeledConnection connection ) { activeConnections . remove ( connection . getIdentifier ( ) ) ; } @ Override protected void acquire ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup ) throws GuacamoleException { Seat seat = new Seat ( user . getUser ( ) . getIdentifier ( ) , connectionGroup . getIdentifier ( ) ) ; if ( ! activeGroupSeats . add ( seat ) ) throw new GuacamoleClientTooManyException ( "Cannot connect. Connection group already in use by this user." ) ; } @ Override protected void release ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup ) { activeGroupSeats . remove ( new Seat ( user . getUser ( ) . getIdentifier ( ) , connectionGroup . getIdentifier ( ) ) ) ; } }
package org . glyptodon . guacamole . auth . jdbc . tunnel ; import java . util . Collection ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . connection . ModeledConnection ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . ModeledConnectionGroup ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . Connection ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . protocol . GuacamoleClientInformation ; public interface GuacamoleTunnelService { public Collection < ActiveConnectionRecord > getActiveConnections ( AuthenticatedUser user ) throws GuacamoleException ; GuacamoleTunnel getGuacamoleTunnel ( AuthenticatedUser user , ModeledConnection connection , GuacamoleClientInformation info ) throws GuacamoleException ; public Collection < ActiveConnectionRecord > getActiveConnections ( Connection connection ) ; GuacamoleTunnel getGuacamoleTunnel ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup , GuacamoleClientInformation info ) throws GuacamoleException ; public Collection < ActiveConnectionRecord > getActiveConnections ( ConnectionGroup connectionGroup ) ; }
package org . glyptodon . guacamole . auth . jdbc . tunnel ; import com . google . inject . Inject ; import com . google . inject . Provider ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Date ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . atomic . AtomicBoolean ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . connection . ModeledConnection ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . ModeledConnectionGroup ; import org . glyptodon . guacamole . auth . jdbc . connection . ConnectionRecordMapper ; import org . glyptodon . guacamole . auth . jdbc . connection . ParameterMapper ; import org . glyptodon . guacamole . auth . jdbc . connection . ConnectionModel ; import org . glyptodon . guacamole . auth . jdbc . connection . ConnectionRecordModel ; import org . glyptodon . guacamole . auth . jdbc . connection . ParameterModel ; import org . glyptodon . guacamole . auth . jdbc . user . UserModel ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . auth . jdbc . connection . ConnectionMapper ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . net . GuacamoleSocket ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . Connection ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . protocol . ConfiguredGuacamoleSocket ; import org . glyptodon . guacamole . protocol . GuacamoleClientInformation ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; import org . glyptodon . guacamole . token . StandardTokens ; import org . glyptodon . guacamole . token . TokenFilter ; import org . mybatis . guice . transactional . Transactional ; public abstract class AbstractGuacamoleTunnelService implements GuacamoleTunnelService { @ Inject private Environment environment ; @ Inject private ConnectionMapper connectionMapper ; @ Inject private Provider < ModeledConnection > connectionProvider ; @ Inject private ParameterMapper parameterMapper ; @ Inject private ConnectionRecordMapper connectionRecordMapper ; private static final String DEFAULT_GUACD_HOSTNAME = "localhost" ; private static final int DEFAULT_GUACD_PORT = 4822 ; private final Map < String , ActiveConnectionRecord > activeTunnels = new ConcurrentHashMap < String , ActiveConnectionRecord > ( ) ; private final ActiveConnectionMultimap activeConnections = new ActiveConnectionMultimap ( ) ; private final ActiveConnectionMultimap activeConnectionGroups = new ActiveConnectionMultimap ( ) ; protected abstract ModeledConnection acquire ( AuthenticatedUser user , List < ModeledConnection > connections ) throws GuacamoleException ; protected abstract void release ( AuthenticatedUser user , ModeledConnection connection ) ; protected abstract void acquire ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup ) throws GuacamoleException ; protected abstract void release ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup ) ; private GuacamoleConfiguration getGuacamoleConfiguration ( AuthenticatedUser user , ModeledConnection connection ) { GuacamoleConfiguration config = new GuacamoleConfiguration ( ) ; ConnectionModel model = connection . getModel ( ) ; config . setProtocol ( model . getProtocol ( ) ) ; Collection < ParameterModel > parameters = parameterMapper . select ( connection . getIdentifier ( ) ) ; for ( ParameterModel parameter : parameters ) config . setParameter ( parameter . getName ( ) , parameter . getValue ( ) ) ; TokenFilter tokenFilter = new TokenFilter ( ) ; StandardTokens . addStandardTokens ( tokenFilter , user . getCredentials ( ) ) ; tokenFilter . filterValues ( config . getParameters ( ) ) ; return config ; } private void saveConnectionRecord ( ActiveConnectionRecord record ) { ModeledConnection connection = record . getConnection ( ) ; AuthenticatedUser user = record . getUser ( ) ; UserModel userModel = user . getUser ( ) . getModel ( ) ; ConnectionRecordModel recordModel = new ConnectionRecordModel ( ) ; recordModel . setUserID ( userModel . getObjectID ( ) ) ; recordModel . setUsername ( userModel . getIdentifier ( ) ) ; recordModel . setConnectionIdentifier ( connection . getIdentifier ( ) ) ; recordModel . setStartDate ( record . getStartDate ( ) ) ; recordModel . setEndDate ( new Date ( ) ) ; connectionRecordMapper . insert ( recordModel ) ; } private GuacamoleSocket getUnconfiguredGuacamoleSocket ( Runnable socketClosedCallback ) throws GuacamoleException { if ( environment . getProperty ( Environment . GUACD_SSL , false ) ) return new ManagedSSLGuacamoleSocket ( environment . getProperty ( Environment . GUACD_HOSTNAME , DEFAULT_GUACD_HOSTNAME ) , environment . getProperty ( Environment . GUACD_PORT , DEFAULT_GUACD_PORT ) , socketClosedCallback ) ; return new ManagedInetGuacamoleSocket ( environment . getProperty ( Environment . GUACD_HOSTNAME , DEFAULT_GUACD_HOSTNAME ) , environment . getProperty ( Environment . GUACD_PORT , DEFAULT_GUACD_PORT ) , socketClosedCallback ) ; } private class ConnectionCleanupTask implements Runnable { private final AtomicBoolean hasRun = new AtomicBoolean ( false ) ; private final ActiveConnectionRecord activeConnection ; public ConnectionCleanupTask ( ActiveConnectionRecord activeConnection ) { this . activeConnection = activeConnection ; } @ Override public void run ( ) { if ( ! hasRun . compareAndSet ( false , true ) ) return ; AuthenticatedUser user = activeConnection . getUser ( ) ; ModeledConnection connection = activeConnection . getConnection ( ) ; String identifier = connection . getIdentifier ( ) ; String parentIdentifier = connection . getParentIdentifier ( ) ; activeTunnels . remove ( activeConnection . getUUID ( ) . toString ( ) ) ; activeConnections . remove ( identifier , activeConnection ) ; activeConnectionGroups . remove ( parentIdentifier , activeConnection ) ; release ( user , connection ) ; if ( activeConnection . hasBalancingGroup ( ) ) release ( user , activeConnection . getBalancingGroup ( ) ) ; saveConnectionRecord ( activeConnection ) ; } } private GuacamoleTunnel assignGuacamoleTunnel ( ActiveConnectionRecord activeConnection , GuacamoleClientInformation info ) throws GuacamoleException { ModeledConnection connection = activeConnection . getConnection ( ) ; Runnable cleanupTask = new ConnectionCleanupTask ( activeConnection ) ; activeTunnels . put ( activeConnection . getUUID ( ) . toString ( ) , activeConnection ) ; activeConnections . put ( connection . getIdentifier ( ) , activeConnection ) ; activeConnectionGroups . put ( connection . getParentIdentifier ( ) , activeConnection ) ; try { GuacamoleSocket socket = new ConfiguredGuacamoleSocket ( getUnconfiguredGuacamoleSocket ( cleanupTask ) , getGuacamoleConfiguration ( activeConnection . getUser ( ) , connection ) , info ) ; return activeConnection . assignGuacamoleTunnel ( socket ) ; } catch ( GuacamoleException e ) { cleanupTask . run ( ) ; throw e ; } } private List < ModeledConnection > getBalancedConnections ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup ) { if ( connectionGroup . getType ( ) != ConnectionGroup . Type . BALANCING ) return Collections . < ModeledConnection > emptyList ( ) ; Collection < String > identifiers = connectionMapper . selectIdentifiersWithin ( connectionGroup . getIdentifier ( ) ) ; if ( identifiers . isEmpty ( ) ) return Collections . < ModeledConnection > emptyList ( ) ; Collection < ConnectionModel > models = connectionMapper . select ( identifiers ) ; List < ModeledConnection > connections = new ArrayList < ModeledConnection > ( models . size ( ) ) ; for ( ConnectionModel model : models ) { ModeledConnection connection = connectionProvider . get ( ) ; connection . init ( user , model ) ; connections . add ( connection ) ; } return connections ; } @ Override public Collection < ActiveConnectionRecord > getActiveConnections ( AuthenticatedUser user ) throws GuacamoleException { Collection < ActiveConnectionRecord > records = activeTunnels . values ( ) ; if ( records . isEmpty ( ) ) return Collections . < ActiveConnectionRecord > emptyList ( ) ; Set < String > identifiers = new HashSet < String > ( records . size ( ) ) ; for ( ActiveConnectionRecord record : records ) identifiers . add ( record . getConnection ( ) . getIdentifier ( ) ) ; Collection < ConnectionModel > connections = connectionMapper . selectReadable ( user . getUser ( ) . getModel ( ) , identifiers ) ; identifiers . clear ( ) ; for ( ConnectionModel connection : connections ) identifiers . add ( connection . getIdentifier ( ) ) ; Collection < ActiveConnectionRecord > visibleRecords = new ArrayList < ActiveConnectionRecord > ( records . size ( ) ) ; for ( ActiveConnectionRecord record : records ) { if ( identifiers . contains ( record . getConnection ( ) . getIdentifier ( ) ) ) visibleRecords . add ( record ) ; } return visibleRecords ; } @ Override @ Transactional public GuacamoleTunnel getGuacamoleTunnel ( final AuthenticatedUser user , final ModeledConnection connection , GuacamoleClientInformation info ) throws GuacamoleException { acquire ( user , Collections . singletonList ( connection ) ) ; return assignGuacamoleTunnel ( new ActiveConnectionRecord ( user , connection ) , info ) ; } @ Override public Collection < ActiveConnectionRecord > getActiveConnections ( Connection connection ) { return activeConnections . get ( connection . getIdentifier ( ) ) ; } @ Override @ Transactional public GuacamoleTunnel getGuacamoleTunnel ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup , GuacamoleClientInformation info ) throws GuacamoleException { List < ModeledConnection > connections = getBalancedConnections ( user , connectionGroup ) ; if ( connections . isEmpty ( ) ) throw new GuacamoleSecurityException ( "Permission denied." ) ; acquire ( user , connectionGroup ) ; ModeledConnection connection = acquire ( user , connections ) ; return assignGuacamoleTunnel ( new ActiveConnectionRecord ( user , connectionGroup , connection ) , info ) ; } @ Override public Collection < ActiveConnectionRecord > getActiveConnections ( ConnectionGroup connectionGroup ) { if ( connectionGroup . getType ( ) != ConnectionGroup . Type . BALANCING ) return Collections . < ActiveConnectionRecord > emptyList ( ) ; return activeConnectionGroups . get ( connectionGroup . getIdentifier ( ) ) ; } }
package org . glyptodon . guacamole . auth . jdbc . tunnel ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Set ; public class ActiveConnectionMultimap { private final Map < String , Set < ActiveConnectionRecord > > records = new HashMap < String , Set < ActiveConnectionRecord > > ( ) ; public void put ( String identifier , ActiveConnectionRecord record ) { synchronized ( records ) { Set < ActiveConnectionRecord > connections = records . get ( identifier ) ; if ( connections == null ) { connections = Collections . synchronizedSet ( Collections . newSetFromMap ( new LinkedHashMap < ActiveConnectionRecord , Boolean > ( ) ) ) ; records . put ( identifier , connections ) ; } connections . add ( record ) ; } } public void remove ( String identifier , ActiveConnectionRecord record ) { synchronized ( records ) { Set < ActiveConnectionRecord > connections = records . get ( identifier ) ; assert ( connections != null ) ; connections . remove ( record ) ; if ( connections . isEmpty ( ) ) records . remove ( identifier ) ; } } public Collection < ActiveConnectionRecord > get ( String identifier ) { synchronized ( records ) { Collection < ActiveConnectionRecord > connections = records . get ( identifier ) ; if ( connections != null ) return Collections . unmodifiableCollection ( connections ) ; return Collections . < ActiveConnectionRecord > emptyList ( ) ; } } }
package org . glyptodon . guacamole . auth . jdbc . tunnel ; import com . google . inject . Singleton ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; import org . glyptodon . guacamole . GuacamoleClientTooManyException ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . connection . ModeledConnection ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleResourceConflictException ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . ModeledConnectionGroup ; @ Singleton public class MultiseatGuacamoleTunnelService extends AbstractGuacamoleTunnelService { private final Set < Seat > activeSeats = Collections . newSetFromMap ( new ConcurrentHashMap < Seat , Boolean > ( ) ) ; private final Set < Seat > activeGroupSeats = Collections . newSetFromMap ( new ConcurrentHashMap < Seat , Boolean > ( ) ) ; @ Override protected ModeledConnection acquire ( AuthenticatedUser user , List < ModeledConnection > connections ) throws GuacamoleException { String username = user . getUser ( ) . getIdentifier ( ) ; ModeledConnection [ ] sortedConnections = connections . toArray ( new ModeledConnection [ connections . size ( ) ] ) ; Arrays . sort ( sortedConnections , new Comparator < ModeledConnection > ( ) { @ Override public int compare ( ModeledConnection a , ModeledConnection b ) { return getActiveConnections ( a ) . size ( ) - getActiveConnections ( b ) . size ( ) ; } } ) ; for ( ModeledConnection connection : sortedConnections ) { if ( activeSeats . add ( new Seat ( username , connection . getIdentifier ( ) ) ) ) return connection ; } throw new GuacamoleResourceConflictException ( "Cannot connect. This connection is in use." ) ; } @ Override protected void release ( AuthenticatedUser user , ModeledConnection connection ) { activeSeats . remove ( new Seat ( user . getUser ( ) . getIdentifier ( ) , connection . getIdentifier ( ) ) ) ; } @ Override protected void acquire ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup ) throws GuacamoleException { Seat seat = new Seat ( user . getUser ( ) . getIdentifier ( ) , connectionGroup . getIdentifier ( ) ) ; if ( ! activeGroupSeats . add ( seat ) ) throw new GuacamoleClientTooManyException ( "Cannot connect. Connection group already in use by this user." ) ; } @ Override protected void release ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup ) { activeGroupSeats . remove ( new Seat ( user . getUser ( ) . getIdentifier ( ) , connectionGroup . getIdentifier ( ) ) ) ; } }
package org . glyptodon . guacamole . auth . jdbc . tunnel ; import com . google . inject . Singleton ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . connection . ModeledConnection ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleResourceConflictException ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . ModeledConnectionGroup ; @ Singleton public class BalancedGuacamoleTunnelService extends AbstractGuacamoleTunnelService { private final Set < String > activeConnections = Collections . newSetFromMap ( new ConcurrentHashMap < String , Boolean > ( ) ) ; @ Override protected ModeledConnection acquire ( AuthenticatedUser user , List < ModeledConnection > connections ) throws GuacamoleException { for ( ModeledConnection connection : connections ) { if ( activeConnections . add ( connection . getIdentifier ( ) ) ) return connection ; } throw new GuacamoleResourceConflictException ( "Cannot connect. This connection is in use." ) ; } @ Override protected void release ( AuthenticatedUser user , ModeledConnection connection ) { activeConnections . remove ( connection . getIdentifier ( ) ) ; } @ Override protected void acquire ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup ) throws GuacamoleException { } @ Override protected void release ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup ) { } }
package org . glyptodon . guacamole . auth . jdbc . tunnel ; public class Seat { private final String username ; private final String identifier ; public Seat ( String username , String identifier ) { this . username = username ; this . identifier = identifier ; } @ Override public int hashCode ( ) { assert ( username != null ) ; assert ( identifier != null ) ; int hash = 5 ; hash = 37 * hash + username . hashCode ( ) ; hash = 37 * hash + identifier . hashCode ( ) ; return hash ; } @ Override public boolean equals ( Object object ) { assert ( object instanceof Seat ) ; Seat seat = ( Seat ) object ; assert ( seat . username != null ) ; assert ( seat . identifier != null ) ; return username . equals ( seat . username ) && identifier . equals ( seat . identifier ) ; } }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleUnsupportedException extends GuacamoleServerException { public GuacamoleUnsupportedException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleUnsupportedException ( String message ) { super ( message ) ; } public GuacamoleUnsupportedException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . UNSUPPORTED ; } }
package org . glyptodon . guacamole . auth . jdbc . tunnel ; import com . google . inject . Singleton ; import java . util . List ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . connection . ModeledConnection ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . ModeledConnectionGroup ; @ Singleton public class UnrestrictedGuacamoleTunnelService extends AbstractGuacamoleTunnelService { @ Override protected ModeledConnection acquire ( AuthenticatedUser user , List < ModeledConnection > connections ) throws GuacamoleException { ModeledConnection chosen = null ; int lowestUsage = 0 ; for ( ModeledConnection connection : connections ) { int usage = getActiveConnections ( connection ) . size ( ) ; if ( chosen == null || usage < lowestUsage ) { chosen = connection ; lowestUsage = usage ; } } return chosen ; } @ Override protected void release ( AuthenticatedUser user , ModeledConnection connection ) { } @ Override protected void acquire ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup ) throws GuacamoleException { } @ Override protected void release ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup ) { } }
package org . glyptodon . guacamole . auth . jdbc . tunnel ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . SSLGuacamoleSocket ; public class ManagedSSLGuacamoleSocket extends SSLGuacamoleSocket { private final Runnable socketClosedTask ; public ManagedSSLGuacamoleSocket ( String hostname , int port , Runnable socketClosedTask ) throws GuacamoleException { super ( hostname , port ) ; this . socketClosedTask = socketClosedTask ; } @ Override public void close ( ) throws GuacamoleException { super . close ( ) ; socketClosedTask . run ( ) ; } }
package org . glyptodon . guacamole . auth . jdbc . tunnel ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . InetGuacamoleSocket ; public class ManagedInetGuacamoleSocket extends InetGuacamoleSocket { private final Runnable socketClosedTask ; public ManagedInetGuacamoleSocket ( String hostname , int port , Runnable socketClosedTask ) throws GuacamoleException { super ( hostname , port ) ; this . socketClosedTask = socketClosedTask ; } @ Override public void close ( ) throws GuacamoleException { super . close ( ) ; socketClosedTask . run ( ) ; } }
package org . glyptodon . guacamole . auth . jdbc . tunnel ; import java . util . Date ; import java . util . UUID ; import org . glyptodon . guacamole . auth . jdbc . connection . ModeledConnection ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . ModeledConnectionGroup ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . net . AbstractGuacamoleTunnel ; import org . glyptodon . guacamole . net . GuacamoleSocket ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . ConnectionRecord ; public class ActiveConnectionRecord implements ConnectionRecord { private final AuthenticatedUser user ; private final ModeledConnectionGroup balancingGroup ; private final ModeledConnection connection ; private final Date startDate = new Date ( ) ; private final UUID uuid = UUID . randomUUID ( ) ; private GuacamoleTunnel tunnel ; public ActiveConnectionRecord ( AuthenticatedUser user , ModeledConnectionGroup balancingGroup , ModeledConnection connection ) { this . user = user ; this . balancingGroup = balancingGroup ; this . connection = connection ; } public ActiveConnectionRecord ( AuthenticatedUser user , ModeledConnection connection ) { this ( user , null , connection ) ; } public AuthenticatedUser getUser ( ) { return user ; } public ModeledConnectionGroup getBalancingGroup ( ) { return balancingGroup ; } public ModeledConnection getConnection ( ) { return connection ; } public boolean hasBalancingGroup ( ) { return balancingGroup != null ; } @ Override public Date getStartDate ( ) { return startDate ; } @ Override public Date getEndDate ( ) { return null ; } @ Override public String getRemoteHost ( ) { return user . getRemoteHost ( ) ; } @ Override public String getUsername ( ) { return user . getUser ( ) . getIdentifier ( ) ; } @ Override public boolean isActive ( ) { return true ; } public GuacamoleTunnel getTunnel ( ) { return tunnel ; } public GuacamoleTunnel assignGuacamoleTunnel ( final GuacamoleSocket socket ) { this . tunnel = new AbstractGuacamoleTunnel ( ) { @ Override public GuacamoleSocket getSocket ( ) { return socket ; } @ Override public UUID getUUID ( ) { return uuid ; } } ; return this . tunnel ; } public UUID getUUID ( ) { return uuid ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ;
package org . glyptodon . guacamole . auth . jdbc . permission ; import java . util . Collection ; import org . glyptodon . guacamole . auth . jdbc . user . UserModel ; import org . apache . ibatis . annotations . Param ; public interface PermissionMapper < PermissionType > { Collection < PermissionType > select ( @ Param ( "user" ) UserModel user ) ; int insert ( @ Param ( "permissions" ) Collection < PermissionType > permissions ) ; int delete ( @ Param ( "permissions" ) Collection < PermissionType > permissions ) ; }
package org . glyptodon . guacamole . auth . jdbc . permission ; public interface UserPermissionMapper extends ObjectPermissionMapper { }
package org . glyptodon . guacamole . auth . jdbc . permission ; import com . google . inject . Inject ; import com . google . inject . Provider ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . user . ModeledUser ; public class ConnectionPermissionService extends ModeledObjectPermissionService { @ Inject private ConnectionPermissionMapper connectionPermissionMapper ; @ Inject private Provider < ConnectionPermissionSet > connectionPermissionSetProvider ; @ Override protected ObjectPermissionMapper getPermissionMapper ( ) { return connectionPermissionMapper ; } @ Override public ObjectPermissionSet getPermissionSet ( AuthenticatedUser user , ModeledUser targetUser ) throws GuacamoleException { ObjectPermissionSet permissionSet = connectionPermissionSetProvider . get ( ) ; permissionSet . init ( user , targetUser ) ; return permissionSet ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; public interface ConnectionPermissionMapper extends ObjectPermissionMapper { }
package org . glyptodon . guacamole . auth . jdbc . permission ; import com . google . inject . Inject ; import com . google . inject . Provider ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . user . ModeledUser ; public class UserPermissionService extends ModeledObjectPermissionService { @ Inject private UserPermissionMapper userPermissionMapper ; @ Inject private Provider < UserPermissionSet > userPermissionSetProvider ; @ Override protected ObjectPermissionMapper getPermissionMapper ( ) { return userPermissionMapper ; } @ Override public ObjectPermissionSet getPermissionSet ( AuthenticatedUser user , ModeledUser targetUser ) throws GuacamoleException { ObjectPermissionSet permissionSet = userPermissionSetProvider . get ( ) ; permissionSet . init ( user , targetUser ) ; return permissionSet ; } }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleServerException extends GuacamoleException { public GuacamoleServerException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleServerException ( String message ) { super ( message ) ; } public GuacamoleServerException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . SERVER_ERROR ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; import com . google . inject . Inject ; public class UserPermissionSet extends ObjectPermissionSet { @ Inject private UserPermissionService userPermissionService ; @ Override protected ObjectPermissionService getObjectPermissionService ( ) { return userPermissionService ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; import com . google . inject . Inject ; import com . google . inject . Provider ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . user . ModeledUser ; public class ConnectionGroupPermissionService extends ModeledObjectPermissionService { @ Inject private ConnectionGroupPermissionMapper connectionGroupPermissionMapper ; @ Inject private Provider < ConnectionGroupPermissionSet > connectionGroupPermissionSetProvider ; @ Override protected ObjectPermissionMapper getPermissionMapper ( ) { return connectionGroupPermissionMapper ; } @ Override public ObjectPermissionSet getPermissionSet ( AuthenticatedUser user , ModeledUser targetUser ) throws GuacamoleException { ObjectPermissionSet permissionSet = connectionGroupPermissionSetProvider . get ( ) ; permissionSet . init ( user , targetUser ) ; return permissionSet ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; import com . google . inject . Inject ; public class ConnectionGroupPermissionSet extends ObjectPermissionSet { @ Inject private ConnectionGroupPermissionService connectionGroupPermissionService ; @ Override protected ObjectPermissionService getObjectPermissionService ( ) { return connectionGroupPermissionService ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashSet ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . user . ModeledUser ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . net . auth . permission . Permission ; import org . glyptodon . guacamole . net . auth . permission . PermissionSet ; public abstract class ModeledPermissionService < PermissionSetType extends PermissionSet < PermissionType > , PermissionType extends Permission , ModelType > extends AbstractPermissionService < PermissionSetType , PermissionType > { protected abstract PermissionMapper < ModelType > getPermissionMapper ( ) ; protected abstract PermissionType getPermissionInstance ( ModelType model ) ; protected Set < PermissionType > getPermissionInstances ( Collection < ModelType > models ) { Set < PermissionType > permissions = new HashSet < PermissionType > ( models . size ( ) ) ; for ( ModelType model : models ) permissions . add ( getPermissionInstance ( model ) ) ; return permissions ; } protected abstract ModelType getModelInstance ( ModeledUser targetUser , PermissionType permission ) ; protected Collection < ModelType > getModelInstances ( ModeledUser targetUser , Collection < PermissionType > permissions ) { Collection < ModelType > models = new ArrayList < ModelType > ( permissions . size ( ) ) ; for ( PermissionType permission : permissions ) models . add ( getModelInstance ( targetUser , permission ) ) ; return models ; } @ Override public Set < PermissionType > retrievePermissions ( AuthenticatedUser user , ModeledUser targetUser ) throws GuacamoleException { if ( canReadPermissions ( user , targetUser ) ) return getPermissionInstances ( getPermissionMapper ( ) . select ( targetUser . getModel ( ) ) ) ; throw new GuacamoleSecurityException ( "Permission denied." ) ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . user . ModeledUser ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . auth . permission . Permission ; import org . glyptodon . guacamole . net . auth . permission . PermissionSet ; public abstract class AbstractPermissionService < PermissionSetType extends PermissionSet < PermissionType > , PermissionType extends Permission > implements PermissionService < PermissionSetType , PermissionType > { protected boolean canReadPermissions ( AuthenticatedUser user , ModeledUser targetUser ) throws GuacamoleException { if ( user . getUser ( ) . getIdentifier ( ) . equals ( targetUser . getIdentifier ( ) ) ) return true ; if ( user . getUser ( ) . isAdministrator ( ) ) return true ; ObjectPermissionSet userPermissionSet = user . getUser ( ) . getUserPermissions ( ) ; return userPermissionSet . hasPermission ( ObjectPermission . Type . READ , targetUser . getIdentifier ( ) ) ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . user . ModeledUser ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; public abstract class ModeledObjectPermissionService extends ModeledPermissionService < ObjectPermissionSet , ObjectPermission , ObjectPermissionModel > implements ObjectPermissionService { @ Override protected abstract ObjectPermissionMapper getPermissionMapper ( ) ; @ Override protected ObjectPermission getPermissionInstance ( ObjectPermissionModel model ) { return new ObjectPermission ( model . getType ( ) , model . getObjectIdentifier ( ) ) ; } @ Override protected ObjectPermissionModel getModelInstance ( ModeledUser targetUser , ObjectPermission permission ) { ObjectPermissionModel model = new ObjectPermissionModel ( ) ; model . setUserID ( targetUser . getModel ( ) . getObjectID ( ) ) ; model . setUsername ( targetUser . getModel ( ) . getIdentifier ( ) ) ; model . setType ( permission . getType ( ) ) ; model . setObjectIdentifier ( permission . getObjectIdentifier ( ) ) ; return model ; } protected boolean canAlterPermissions ( AuthenticatedUser user , ModeledUser targetUser , Collection < ObjectPermission > permissions ) throws GuacamoleException { if ( user . getUser ( ) . isAdministrator ( ) ) return true ; ObjectPermissionSet userPermissionSet = user . getUser ( ) . getUserPermissions ( ) ; if ( ! userPermissionSet . hasPermission ( ObjectPermission . Type . UPDATE , targetUser . getIdentifier ( ) ) ) return false ; Collection < String > affectedIdentifiers = new HashSet < String > ( permissions . size ( ) ) ; for ( ObjectPermission permission : permissions ) affectedIdentifiers . add ( permission . getObjectIdentifier ( ) ) ; ObjectPermissionSet affectedPermissionSet = getPermissionSet ( user , user . getUser ( ) ) ; Collection < String > allowedSubset = affectedPermissionSet . getAccessibleObjects ( Collections . singleton ( ObjectPermission . Type . ADMINISTER ) , affectedIdentifiers ) ; return affectedIdentifiers . size ( ) == allowedSubset . size ( ) ; } @ Override public void createPermissions ( AuthenticatedUser user , ModeledUser targetUser , Collection < ObjectPermission > permissions ) throws GuacamoleException { if ( canAlterPermissions ( user , targetUser , permissions ) ) { Collection < ObjectPermissionModel > models = getModelInstances ( targetUser , permissions ) ; getPermissionMapper ( ) . insert ( models ) ; return ; } throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public void deletePermissions ( AuthenticatedUser user , ModeledUser targetUser , Collection < ObjectPermission > permissions ) throws GuacamoleException { if ( canAlterPermissions ( user , targetUser , permissions ) ) { Collection < ObjectPermissionModel > models = getModelInstances ( targetUser , permissions ) ; getPermissionMapper ( ) . delete ( models ) ; return ; } throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public ObjectPermission retrievePermission ( AuthenticatedUser user , ModeledUser targetUser , ObjectPermission . Type type , String identifier ) throws GuacamoleException { if ( canReadPermissions ( user , targetUser ) ) { ObjectPermissionModel model = getPermissionMapper ( ) . selectOne ( targetUser . getModel ( ) , type , identifier ) ; if ( model == null ) return null ; return getPermissionInstance ( model ) ; } throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public Collection < String > retrieveAccessibleIdentifiers ( AuthenticatedUser user , ModeledUser targetUser , Collection < ObjectPermission . Type > permissions , Collection < String > identifiers ) throws GuacamoleException { if ( identifiers . isEmpty ( ) ) return identifiers ; if ( canReadPermissions ( user , targetUser ) ) { if ( user . getUser ( ) . isAdministrator ( ) ) return identifiers ; return getPermissionMapper ( ) . selectAccessibleIdentifiers ( targetUser . getModel ( ) , permissions , identifiers ) ; } throw new GuacamoleSecurityException ( "Permission denied." ) ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; import org . glyptodon . guacamole . auth . jdbc . user . UserModel ; import org . apache . ibatis . annotations . Param ; import org . glyptodon . guacamole . net . auth . permission . SystemPermission ; public interface SystemPermissionMapper extends PermissionMapper < SystemPermissionModel > { SystemPermissionModel selectOne ( @ Param ( "user" ) UserModel user , @ Param ( "type" ) SystemPermission . Type type ) ; }
package org . glyptodon . guacamole . auth . jdbc . permission ; public interface ConnectionGroupPermissionMapper extends ObjectPermissionMapper { }
package org . glyptodon . guacamole . auth . jdbc . permission ; import com . google . inject . Inject ; public class ConnectionPermissionSet extends ObjectPermissionSet { @ Inject private ConnectionPermissionService connectionPermissionService ; @ Override protected ObjectPermissionService getObjectPermissionService ( ) { return connectionPermissionService ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; import java . util . Collection ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . user . ModeledUser ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; public interface ObjectPermissionService extends PermissionService < ObjectPermissionSet , ObjectPermission > { ObjectPermission retrievePermission ( AuthenticatedUser user , ModeledUser targetUser , ObjectPermission . Type type , String identifier ) throws GuacamoleException ; Collection < String > retrieveAccessibleIdentifiers ( AuthenticatedUser user , ModeledUser targetUser , Collection < ObjectPermission . Type > permissions , Collection < String > identifiers ) throws GuacamoleException ; }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleServerBusyException extends GuacamoleServerException { public GuacamoleServerBusyException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleServerBusyException ( String message ) { super ( message ) ; } public GuacamoleServerBusyException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . SERVER_BUSY ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; public abstract class PermissionModel < PermissionType > { private Integer userID ; private String username ; private PermissionType type ; public Integer getUserID ( ) { return userID ; } public void setUserID ( Integer userID ) { this . userID = userID ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public PermissionType getType ( ) { return type ; } public void setType ( PermissionType type ) { this . type = type ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashSet ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . user . ModeledUser ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . auth . permission . Permission ; import org . glyptodon . guacamole . net . auth . permission . PermissionSet ; public interface PermissionService < PermissionSetType extends PermissionSet < PermissionType > , PermissionType extends Permission > { PermissionSetType getPermissionSet ( AuthenticatedUser user , ModeledUser targetUser ) throws GuacamoleException ; Set < PermissionType > retrievePermissions ( AuthenticatedUser user , ModeledUser targetUser ) throws GuacamoleException ; void createPermissions ( AuthenticatedUser user , ModeledUser targetUser , Collection < PermissionType > permissions ) throws GuacamoleException ; void deletePermissions ( AuthenticatedUser user , ModeledUser targetUser , Collection < PermissionType > permissions ) throws GuacamoleException ; }
package org . glyptodon . guacamole . auth . jdbc . permission ; import org . glyptodon . guacamole . auth . jdbc . user . ModeledUser ; import com . google . inject . Inject ; import java . util . Collections ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . base . RestrictedObject ; import org . glyptodon . guacamole . net . auth . permission . SystemPermission ; public class SystemPermissionSet extends RestrictedObject implements org . glyptodon . guacamole . net . auth . permission . SystemPermissionSet { private ModeledUser user ; @ Inject private SystemPermissionService systemPermissionService ; public SystemPermissionSet ( ) { } public void init ( AuthenticatedUser currentUser , ModeledUser user ) { super . init ( currentUser ) ; this . user = user ; } @ Override public Set < SystemPermission > getPermissions ( ) throws GuacamoleException { return systemPermissionService . retrievePermissions ( getCurrentUser ( ) , user ) ; } @ Override public boolean hasPermission ( SystemPermission . Type permission ) throws GuacamoleException { return systemPermissionService . retrievePermission ( getCurrentUser ( ) , user , permission ) != null ; } @ Override public void addPermission ( SystemPermission . Type permission ) throws GuacamoleException { addPermissions ( Collections . singleton ( new SystemPermission ( permission ) ) ) ; } @ Override public void removePermission ( SystemPermission . Type permission ) throws GuacamoleException { removePermissions ( Collections . singleton ( new SystemPermission ( permission ) ) ) ; } @ Override public void addPermissions ( Set < SystemPermission > permissions ) throws GuacamoleException { systemPermissionService . createPermissions ( getCurrentUser ( ) , user , permissions ) ; } @ Override public void removePermissions ( Set < SystemPermission > permissions ) throws GuacamoleException { systemPermissionService . deletePermissions ( getCurrentUser ( ) , user , permissions ) ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; public class ObjectPermissionModel extends PermissionModel < ObjectPermission . Type > { private String objectIdentifier ; public ObjectPermissionModel ( ) { } public String getObjectIdentifier ( ) { return objectIdentifier ; } public void setObjectIdentifier ( String objectIdentifier ) { this . objectIdentifier = objectIdentifier ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; import org . glyptodon . guacamole . auth . jdbc . user . ModeledUser ; import java . util . Collection ; import java . util . Collections ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . base . RestrictedObject ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; public abstract class ObjectPermissionSet extends RestrictedObject implements org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet { private ModeledUser user ; public ObjectPermissionSet ( ) { } public void init ( AuthenticatedUser currentUser , ModeledUser user ) { super . init ( currentUser ) ; this . user = user ; } protected abstract ObjectPermissionService getObjectPermissionService ( ) ; @ Override public Set < ObjectPermission > getPermissions ( ) throws GuacamoleException { return getObjectPermissionService ( ) . retrievePermissions ( getCurrentUser ( ) , user ) ; } @ Override public boolean hasPermission ( ObjectPermission . Type permission , String identifier ) throws GuacamoleException { return getObjectPermissionService ( ) . retrievePermission ( getCurrentUser ( ) , user , permission , identifier ) != null ; } @ Override public void addPermission ( ObjectPermission . Type permission , String identifier ) throws GuacamoleException { addPermissions ( Collections . singleton ( new ObjectPermission ( permission , identifier ) ) ) ; } @ Override public void removePermission ( ObjectPermission . Type permission , String identifier ) throws GuacamoleException { removePermissions ( Collections . singleton ( new ObjectPermission ( permission , identifier ) ) ) ; } @ Override public Collection < String > getAccessibleObjects ( Collection < ObjectPermission . Type > permissions , Collection < String > identifiers ) throws GuacamoleException { return getObjectPermissionService ( ) . retrieveAccessibleIdentifiers ( getCurrentUser ( ) , user , permissions , identifiers ) ; } @ Override public void addPermissions ( Set < ObjectPermission > permissions ) throws GuacamoleException { getObjectPermissionService ( ) . createPermissions ( getCurrentUser ( ) , user , permissions ) ; } @ Override public void removePermissions ( Set < ObjectPermission > permissions ) throws GuacamoleException { getObjectPermissionService ( ) . deletePermissions ( getCurrentUser ( ) , user , permissions ) ; } }
package org . glyptodon . guacamole . auth . jdbc . permission ; import java . util . Collection ; import org . apache . ibatis . annotations . Param ; import org . glyptodon . guacamole . auth . jdbc . user . UserModel ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; public interface ObjectPermissionMapper extends PermissionMapper < ObjectPermissionModel > { ObjectPermissionModel selectOne ( @ Param ( "user" ) UserModel user , @ Param ( "type" ) ObjectPermission . Type type , @ Param ( "identifier" ) String identifier ) ; Collection < String > selectAccessibleIdentifiers ( @ Param ( "user" ) UserModel user , @ Param ( "permissions" ) Collection < ObjectPermission . Type > permissions , @ Param ( "identifiers" ) Collection < String > identifiers ) ; }
package org . glyptodon . guacamole . auth . jdbc . permission ; import org . glyptodon . guacamole . net . auth . permission . SystemPermission ; public class SystemPermissionModel extends PermissionModel < SystemPermission . Type > { public SystemPermissionModel ( ) { } }
package org . glyptodon . guacamole . auth . jdbc . permission ; import com . google . inject . Inject ; import com . google . inject . Provider ; import java . util . Collection ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . user . ModeledUser ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . GuacamoleUnsupportedException ; import org . glyptodon . guacamole . net . auth . permission . SystemPermission ; public class SystemPermissionService extends ModeledPermissionService < SystemPermissionSet , SystemPermission , SystemPermissionModel > { @ Inject private SystemPermissionMapper systemPermissionMapper ; @ Inject private Provider < SystemPermissionSet > systemPermissionSetProvider ; @ Override protected SystemPermissionMapper getPermissionMapper ( ) { return systemPermissionMapper ; } @ Override protected SystemPermission getPermissionInstance ( SystemPermissionModel model ) { return new SystemPermission ( model . getType ( ) ) ; } @ Override protected SystemPermissionModel getModelInstance ( final ModeledUser targetUser , final SystemPermission permission ) { SystemPermissionModel model = new SystemPermissionModel ( ) ; model . setUserID ( targetUser . getModel ( ) . getObjectID ( ) ) ; model . setUsername ( targetUser . getModel ( ) . getIdentifier ( ) ) ; model . setType ( permission . getType ( ) ) ; return model ; } @ Override public SystemPermissionSet getPermissionSet ( AuthenticatedUser user , ModeledUser targetUser ) throws GuacamoleException { SystemPermissionSet permissionSet = systemPermissionSetProvider . get ( ) ; permissionSet . init ( user , targetUser ) ; return permissionSet ; } @ Override public void createPermissions ( AuthenticatedUser user , ModeledUser targetUser , Collection < SystemPermission > permissions ) throws GuacamoleException { if ( user . getUser ( ) . isAdministrator ( ) ) { Collection < SystemPermissionModel > models = getModelInstances ( targetUser , permissions ) ; systemPermissionMapper . insert ( models ) ; return ; } throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public void deletePermissions ( AuthenticatedUser user , ModeledUser targetUser , Collection < SystemPermission > permissions ) throws GuacamoleException { if ( user . getUser ( ) . isAdministrator ( ) ) { if ( user . getUser ( ) . getIdentifier ( ) . equals ( targetUser . getIdentifier ( ) ) ) throw new GuacamoleUnsupportedException ( "Removing your own administrative permissions is not allowed." ) ; Collection < SystemPermissionModel > models = getModelInstances ( targetUser , permissions ) ; systemPermissionMapper . delete ( models ) ; return ; } throw new GuacamoleSecurityException ( "Permission denied." ) ; } public SystemPermission retrievePermission ( AuthenticatedUser user , ModeledUser targetUser , SystemPermission . Type type ) throws GuacamoleException { if ( canReadPermissions ( user , targetUser ) ) { SystemPermissionModel model = getPermissionMapper ( ) . selectOne ( targetUser . getModel ( ) , type ) ; if ( model == null ) return null ; return getPermissionInstance ( model ) ; } throw new GuacamoleSecurityException ( "Permission denied." ) ; } }
package org . glyptodon . guacamole . auth . jdbc . connectiongroup ;
package org . glyptodon . guacamole . auth . jdbc . connectiongroup ; import com . google . inject . Inject ; import java . util . Collections ; import java . util . Map ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . connection . ConnectionService ; import org . glyptodon . guacamole . auth . jdbc . tunnel . GuacamoleTunnelService ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . base . ModeledGroupedDirectoryObject ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . protocol . GuacamoleClientInformation ; public class ModeledConnectionGroup extends ModeledGroupedDirectoryObject < ConnectionGroupModel > implements ConnectionGroup { @ Inject private ConnectionService connectionService ; @ Inject private ConnectionGroupService connectionGroupService ; @ Inject private GuacamoleTunnelService tunnelService ; public ModeledConnectionGroup ( ) { } @ Override public String getName ( ) { return getModel ( ) . getName ( ) ; } @ Override public void setName ( String name ) { getModel ( ) . setName ( name ) ; } @ Override public GuacamoleTunnel connect ( GuacamoleClientInformation info ) throws GuacamoleException { return connectionGroupService . connect ( getCurrentUser ( ) , this , info ) ; } @ Override public int getActiveConnections ( ) { return tunnelService . getActiveConnections ( this ) . size ( ) ; } @ Override public void setType ( Type type ) { getModel ( ) . setType ( type ) ; } @ Override public Type getType ( ) { return getModel ( ) . getType ( ) ; } @ Override public Set < String > getConnectionIdentifiers ( ) throws GuacamoleException { return connectionService . getIdentifiersWithin ( getCurrentUser ( ) , getIdentifier ( ) ) ; } @ Override public Set < String > getConnectionGroupIdentifiers ( ) throws GuacamoleException { return connectionGroupService . getIdentifiersWithin ( getCurrentUser ( ) , getIdentifier ( ) ) ; } @ Override public Map < String , String > getAttributes ( ) { return Collections . < String , String > emptyMap ( ) ; } @ Override public void setAttributes ( Map < String , String > attributes ) { } }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleConnectionClosedException extends GuacamoleServerException { public GuacamoleConnectionClosedException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleConnectionClosedException ( String message ) { super ( message ) ; } public GuacamoleConnectionClosedException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . SERVER_ERROR ; } }
package org . glyptodon . guacamole . protocol ; import java . io . StringWriter ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . io . GuacamoleWriter ; import org . glyptodon . guacamole . io . WriterGuacamoleWriter ; import static org . junit . Assert . * ; import org . junit . Test ; public class FilteredGuacamoleWriterTest { private static class TestFilter implements GuacamoleFilter { @ Override public GuacamoleInstruction filter ( GuacamoleInstruction instruction ) throws GuacamoleException { if ( instruction . getOpcode ( ) . equals ( "yes" ) ) return instruction ; return null ; } } @ Test public void testFilter ( ) throws Exception { StringWriter stringWriter = new StringWriter ( ) ; GuacamoleWriter writer = new FilteredGuacamoleWriter ( new WriterGuacamoleWriter ( stringWriter ) , new TestFilter ( ) ) ; writer . write ( "3.yes,1.A;2.no,1.B;3.yes,1.C;3.yes,1.D;4.nope,1.E;" . toCharArray ( ) ) ; writer . write ( "1.n,3.abc;3.yes,5.hello;2.no,4.test;3.yes,5.world;" . toCharArray ( ) ) ; assertEquals ( "3.yes,1.A;3.yes,1.C;3.yes,1.D;3.yes,5.hello;3.yes,5.world;" , stringWriter . toString ( ) ) ; } }
package org . glyptodon . guacamole . auth . jdbc . connectiongroup ; import org . glyptodon . guacamole . auth . jdbc . base . GroupedObjectModel ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; public class ConnectionGroupModel extends GroupedObjectModel { private String name ; private ConnectionGroup . Type type ; public ConnectionGroupModel ( ) { } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public ConnectionGroup . Type getType ( ) { return type ; } public void setType ( ConnectionGroup . Type type ) { this . type = type ; } @ Override public String getIdentifier ( ) { Integer id = getObjectID ( ) ; if ( id == null ) return null ; return id . toString ( ) ; } @ Override public void setIdentifier ( String identifier ) { throw new UnsupportedOperationException ( "Connection group identifiers are derived from IDs. They cannot be set." ) ; } }
package org . glyptodon . guacamole . auth . jdbc . connectiongroup ; import com . google . inject . Inject ; import com . google . inject . Provider ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . base . ModeledDirectoryObjectMapper ; import org . glyptodon . guacamole . auth . jdbc . tunnel . GuacamoleTunnelService ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . GuacamoleUnsupportedException ; import org . glyptodon . guacamole . auth . jdbc . base . ModeledGroupedDirectoryObjectService ; import org . glyptodon . guacamole . auth . jdbc . permission . ConnectionGroupPermissionMapper ; import org . glyptodon . guacamole . auth . jdbc . permission . ObjectPermissionMapper ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . auth . permission . SystemPermission ; import org . glyptodon . guacamole . net . auth . permission . SystemPermissionSet ; import org . glyptodon . guacamole . protocol . GuacamoleClientInformation ; public class ConnectionGroupService extends ModeledGroupedDirectoryObjectService < ModeledConnectionGroup , ConnectionGroup , ConnectionGroupModel > { @ Inject private ConnectionGroupMapper connectionGroupMapper ; @ Inject private ConnectionGroupPermissionMapper connectionGroupPermissionMapper ; @ Inject private Provider < ModeledConnectionGroup > connectionGroupProvider ; @ Inject private GuacamoleTunnelService tunnelService ; @ Override protected ModeledDirectoryObjectMapper < ConnectionGroupModel > getObjectMapper ( ) { return connectionGroupMapper ; } @ Override protected ObjectPermissionMapper getPermissionMapper ( ) { return connectionGroupPermissionMapper ; } @ Override protected ModeledConnectionGroup getObjectInstance ( AuthenticatedUser currentUser , ConnectionGroupModel model ) { ModeledConnectionGroup connectionGroup = connectionGroupProvider . get ( ) ; connectionGroup . init ( currentUser , model ) ; return connectionGroup ; } @ Override protected ConnectionGroupModel getModelInstance ( AuthenticatedUser currentUser , final ConnectionGroup object ) { ConnectionGroupModel model = new ConnectionGroupModel ( ) ; ModeledConnectionGroup connectionGroup = getObjectInstance ( currentUser , model ) ; connectionGroup . setParentIdentifier ( object . getParentIdentifier ( ) ) ; connectionGroup . setName ( object . getName ( ) ) ; connectionGroup . setType ( object . getType ( ) ) ; return model ; } @ Override protected boolean hasCreatePermission ( AuthenticatedUser user ) throws GuacamoleException { SystemPermissionSet permissionSet = user . getUser ( ) . getSystemPermissions ( ) ; return permissionSet . hasPermission ( SystemPermission . Type . CREATE_CONNECTION_GROUP ) ; } @ Override protected ObjectPermissionSet getPermissionSet ( AuthenticatedUser user ) throws GuacamoleException { return user . getUser ( ) . getConnectionGroupPermissions ( ) ; } @ Override protected void beforeCreate ( AuthenticatedUser user , ConnectionGroupModel model ) throws GuacamoleException { super . beforeCreate ( user , model ) ; if ( model . getName ( ) == null || model . getName ( ) . trim ( ) . isEmpty ( ) ) throw new GuacamoleClientException ( "Connection group names must not be blank." ) ; ConnectionGroupModel existing = connectionGroupMapper . selectOneByName ( model . getParentIdentifier ( ) , model . getName ( ) ) ; if ( existing != null ) throw new GuacamoleClientException ( "The connection group \"" + model . getName ( ) + "\" already exists." ) ; } @ Override protected void beforeUpdate ( AuthenticatedUser user , ConnectionGroupModel model ) throws GuacamoleException { super . beforeUpdate ( user , model ) ; if ( model . getName ( ) == null || model . getName ( ) . trim ( ) . isEmpty ( ) ) throw new GuacamoleClientException ( "Connection group names must not be blank." ) ; ConnectionGroupModel existing = connectionGroupMapper . selectOneByName ( model . getParentIdentifier ( ) , model . getName ( ) ) ; if ( existing != null ) { if ( ! existing . getObjectID ( ) . equals ( model . getObjectID ( ) ) ) throw new GuacamoleClientException ( "The connection group \"" + model . getName ( ) + "\" already exists." ) ; } String relativeParentIdentifier = model . getParentIdentifier ( ) ; while ( relativeParentIdentifier != null ) { if ( relativeParentIdentifier . equals ( model . getIdentifier ( ) ) ) throw new GuacamoleUnsupportedException ( "A connection group may not contain itself." ) ; ModeledConnectionGroup relativeParentGroup = retrieveObject ( user , relativeParentIdentifier ) ; relativeParentIdentifier = relativeParentGroup . getModel ( ) . getParentIdentifier ( ) ; } } public Set < String > getIdentifiersWithin ( AuthenticatedUser user , String identifier ) throws GuacamoleException { if ( user . getUser ( ) . isAdministrator ( ) ) return connectionGroupMapper . selectIdentifiersWithin ( identifier ) ; else return connectionGroupMapper . selectReadableIdentifiersWithin ( user . getUser ( ) . getModel ( ) , identifier ) ; } public GuacamoleTunnel connect ( AuthenticatedUser user , ModeledConnectionGroup connectionGroup , GuacamoleClientInformation info ) throws GuacamoleException { if ( hasObjectPermission ( user , connectionGroup . getIdentifier ( ) , ObjectPermission . Type . READ ) ) return tunnelService . getGuacamoleTunnel ( user , connectionGroup , info ) ; throw new GuacamoleSecurityException ( "Permission denied." ) ; } }
package org . glyptodon . guacamole . auth . jdbc . connectiongroup ; import com . google . inject . Inject ; import java . util . Collection ; import java . util . Collections ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . base . RestrictedObject ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . net . auth . Directory ; import org . mybatis . guice . transactional . Transactional ; public class ConnectionGroupDirectory extends RestrictedObject implements Directory < ConnectionGroup > { @ Inject private ConnectionGroupService connectionGroupService ; @ Override public ConnectionGroup get ( String identifier ) throws GuacamoleException { return connectionGroupService . retrieveObject ( getCurrentUser ( ) , identifier ) ; } @ Override @ Transactional public Collection < ConnectionGroup > getAll ( Collection < String > identifiers ) throws GuacamoleException { Collection < ModeledConnectionGroup > objects = connectionGroupService . retrieveObjects ( getCurrentUser ( ) , identifiers ) ; return Collections . < ConnectionGroup > unmodifiableCollection ( objects ) ; } @ Override @ Transactional public Set < String > getIdentifiers ( ) throws GuacamoleException { return connectionGroupService . getIdentifiers ( getCurrentUser ( ) ) ; } @ Override @ Transactional public void add ( ConnectionGroup object ) throws GuacamoleException { connectionGroupService . createObject ( getCurrentUser ( ) , object ) ; } @ Override @ Transactional public void update ( ConnectionGroup object ) throws GuacamoleException { ModeledConnectionGroup connectionGroup = ( ModeledConnectionGroup ) object ; connectionGroupService . updateObject ( getCurrentUser ( ) , connectionGroup ) ; } @ Override @ Transactional public void remove ( String identifier ) throws GuacamoleException { connectionGroupService . deleteObject ( getCurrentUser ( ) , identifier ) ; } }
package org . glyptodon . guacamole . auth . jdbc . connectiongroup ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . base . ModeledDirectoryObjectMapper ; import org . glyptodon . guacamole . auth . jdbc . user . UserModel ; import org . apache . ibatis . annotations . Param ; public interface ConnectionGroupMapper extends ModeledDirectoryObjectMapper < ConnectionGroupModel > { Set < String > selectIdentifiersWithin ( @ Param ( "parentIdentifier" ) String parentIdentifier ) ; Set < String > selectReadableIdentifiersWithin ( @ Param ( "user" ) UserModel user , @ Param ( "parentIdentifier" ) String parentIdentifier ) ; ConnectionGroupModel selectOneByName ( @ Param ( "parentIdentifier" ) String parentIdentifier , @ Param ( "name" ) String name ) ; }
package org . glyptodon . guacamole . auth . jdbc . connectiongroup ; import com . google . inject . Inject ; import java . util . Collections ; import java . util . Map ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . connection . ConnectionService ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . auth . jdbc . base . RestrictedObject ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . protocol . GuacamoleClientInformation ; public class RootConnectionGroup extends RestrictedObject implements ConnectionGroup { public static final String IDENTIFIER = "ROOT" ; public static final String NAME = "ROOT" ; @ Inject private ConnectionService connectionService ; @ Inject private ConnectionGroupService connectionGroupService ; public RootConnectionGroup ( ) { } @ Override public String getName ( ) { return NAME ; } @ Override public void setName ( String name ) { throw new UnsupportedOperationException ( "The root connection group cannot be modified." ) ; } @ Override public String getParentIdentifier ( ) { return null ; } @ Override public void setParentIdentifier ( String parentIdentifier ) { throw new UnsupportedOperationException ( "The root connection group cannot be modified." ) ; } @ Override public Type getType ( ) { return ConnectionGroup . Type . ORGANIZATIONAL ; } @ Override public void setType ( Type type ) { throw new UnsupportedOperationException ( "The root connection group cannot be modified." ) ; } @ Override public Set < String > getConnectionIdentifiers ( ) throws GuacamoleException { return connectionService . getIdentifiersWithin ( getCurrentUser ( ) , null ) ; } @ Override public Set < String > getConnectionGroupIdentifiers ( ) throws GuacamoleException { return connectionGroupService . getIdentifiersWithin ( getCurrentUser ( ) , null ) ; } @ Override public String getIdentifier ( ) { return IDENTIFIER ; } @ Override public void setIdentifier ( String identifier ) { throw new UnsupportedOperationException ( "The root connection group cannot be modified." ) ; } @ Override public GuacamoleTunnel connect ( GuacamoleClientInformation info ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public int getActiveConnections ( ) { return 0 ; } @ Override public Map < String , String > getAttributes ( ) { return Collections . < String , String > emptyMap ( ) ; } @ Override public void setAttributes ( Map < String , String > attributes ) { throw new UnsupportedOperationException ( "The root connection group cannot be modified." ) ; } }
package org . glyptodon . guacamole . auth . jdbc . base ;
package org . glyptodon . guacamole . auth . jdbc . base ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; public abstract class ModeledObject < ModelType > extends RestrictedObject { private ModelType model ; public void init ( AuthenticatedUser currentUser , ModelType model ) { super . init ( currentUser ) ; setModel ( model ) ; } public ModelType getModel ( ) { return model ; } public void setModel ( ModelType model ) { this . model = model ; } }
package org . glyptodon . guacamole . auth . jdbc . base ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; public abstract class ModeledGroupedDirectoryObjectService < InternalType extends ModeledGroupedDirectoryObject < ModelType > , ExternalType , ModelType extends GroupedObjectModel > extends ModeledDirectoryObjectService < InternalType , ExternalType , ModelType > { protected Collection < String > getModifiedGroups ( AuthenticatedUser user , String identifier , ModelType model ) throws GuacamoleException { String oldParentIdentifier = null ; if ( identifier != null ) { ModelType current = retrieveObject ( user , identifier ) . getModel ( ) ; oldParentIdentifier = current . getParentIdentifier ( ) ; } String parentIdentifier = null ; if ( model != null ) { parentIdentifier = model . getParentIdentifier ( ) ; if ( parentIdentifier != null && parentIdentifier . equals ( oldParentIdentifier ) ) return Collections . < String > emptyList ( ) ; } Collection < String > groups = new ArrayList < String > ( 2 ) ; if ( oldParentIdentifier != null ) groups . add ( oldParentIdentifier ) ; if ( parentIdentifier != null ) groups . add ( parentIdentifier ) ; return groups ; } protected boolean canUpdateModifiedGroups ( AuthenticatedUser user , String identifier , ModelType model ) throws GuacamoleException { if ( user . getUser ( ) . isAdministrator ( ) ) return true ; Collection < String > modifiedGroups = getModifiedGroups ( user , identifier , model ) ; if ( ! modifiedGroups . isEmpty ( ) ) { ObjectPermissionSet permissionSet = user . getUser ( ) . getConnectionGroupPermissions ( ) ; Collection < String > updateableGroups = permissionSet . getAccessibleObjects ( Collections . singleton ( ObjectPermission . Type . UPDATE ) , modifiedGroups ) ; return updateableGroups . size ( ) == modifiedGroups . size ( ) ; } return true ; } @ Override protected void beforeCreate ( AuthenticatedUser user , ModelType model ) throws GuacamoleException { super . beforeCreate ( user , model ) ; if ( ! canUpdateModifiedGroups ( user , null , model ) ) throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override protected void beforeUpdate ( AuthenticatedUser user , ModelType model ) throws GuacamoleException { super . beforeUpdate ( user , model ) ; if ( ! canUpdateModifiedGroups ( user , model . getIdentifier ( ) , model ) ) throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override protected void beforeDelete ( AuthenticatedUser user , String identifier ) throws GuacamoleException { super . beforeDelete ( user , identifier ) ; if ( ! canUpdateModifiedGroups ( user , identifier , null ) ) throw new GuacamoleSecurityException ( "Permission denied." ) ; } }
package org . glyptodon . guacamole . auth . jdbc . base ; import java . util . Collection ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . GuacamoleException ; public interface DirectoryObjectService < InternalType , ExternalType > { InternalType retrieveObject ( AuthenticatedUser user , String identifier ) throws GuacamoleException ; Collection < InternalType > retrieveObjects ( AuthenticatedUser user , Collection < String > identifiers ) throws GuacamoleException ; InternalType createObject ( AuthenticatedUser user , ExternalType object ) throws GuacamoleException ; void deleteObject ( AuthenticatedUser user , String identifier ) throws GuacamoleException ; void updateObject ( AuthenticatedUser user , InternalType object ) throws GuacamoleException ; Set < String > getIdentifiers ( AuthenticatedUser user ) throws GuacamoleException ; }
package org . glyptodon . guacamole . auth . jdbc . base ; import java . util . Collection ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . user . UserModel ; import org . apache . ibatis . annotations . Param ; public interface ModeledDirectoryObjectMapper < ModelType > { Set < String > selectIdentifiers ( ) ; Set < String > selectReadableIdentifiers ( @ Param ( "user" ) UserModel user ) ; Collection < ModelType > select ( @ Param ( "identifiers" ) Collection < String > identifiers ) ; Collection < ModelType > selectReadable ( @ Param ( "user" ) UserModel user , @ Param ( "identifiers" ) Collection < String > identifiers ) ; int insert ( @ Param ( "object" ) ModelType object ) ; int delete ( @ Param ( "identifier" ) String identifier ) ; int update ( @ Param ( "object" ) ModelType object ) ; }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleClientBadTypeException extends GuacamoleClientException { public GuacamoleClientBadTypeException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleClientBadTypeException ( String message ) { super ( message ) ; } public GuacamoleClientBadTypeException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . CLIENT_BAD_TYPE ; } }
package org . glyptodon . guacamole . auth . jdbc . base ; public abstract class ObjectModel { private Integer objectID ; private String identifier ; public ObjectModel ( ) { } public String getIdentifier ( ) { return identifier ; } public void setIdentifier ( String identifier ) { this . identifier = identifier ; } public Integer getObjectID ( ) { return objectID ; } public void setObjectID ( Integer objectID ) { this . objectID = objectID ; } }
package org . glyptodon . guacamole . auth . jdbc . base ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . auth . jdbc . permission . ObjectPermissionMapper ; import org . glyptodon . guacamole . auth . jdbc . permission . ObjectPermissionModel ; import org . glyptodon . guacamole . auth . jdbc . user . UserModel ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; public abstract class ModeledDirectoryObjectService < InternalType extends ModeledDirectoryObject < ModelType > , ExternalType , ModelType extends ObjectModel > implements DirectoryObjectService < InternalType , ExternalType > { private static final ObjectPermission . Type [ ] IMPLICIT_OBJECT_PERMISSIONS = { ObjectPermission . Type . READ , ObjectPermission . Type . UPDATE , ObjectPermission . Type . DELETE , ObjectPermission . Type . ADMINISTER } ; protected abstract ModeledDirectoryObjectMapper < ModelType > getObjectMapper ( ) ; protected abstract ObjectPermissionMapper getPermissionMapper ( ) ; protected abstract InternalType getObjectInstance ( AuthenticatedUser currentUser , ModelType model ) ; protected abstract ModelType getModelInstance ( AuthenticatedUser currentUser , ExternalType object ) ; protected abstract boolean hasCreatePermission ( AuthenticatedUser user ) throws GuacamoleException ; protected boolean hasObjectPermission ( AuthenticatedUser user , String identifier , ObjectPermission . Type type ) throws GuacamoleException { ObjectPermissionSet permissionSet = getPermissionSet ( user ) ; return user . getUser ( ) . isAdministrator ( ) || permissionSet . hasPermission ( type , identifier ) ; } protected abstract ObjectPermissionSet getPermissionSet ( AuthenticatedUser user ) throws GuacamoleException ; protected Collection < InternalType > getObjectInstances ( AuthenticatedUser currentUser , Collection < ModelType > models ) { Collection < InternalType > objects = new ArrayList < InternalType > ( models . size ( ) ) ; for ( ModelType model : models ) objects . add ( getObjectInstance ( currentUser , model ) ) ; return objects ; } protected void beforeCreate ( AuthenticatedUser user , ModelType model ) throws GuacamoleException { if ( ! user . getUser ( ) . isAdministrator ( ) && ! hasCreatePermission ( user ) ) throw new GuacamoleSecurityException ( "Permission denied." ) ; } protected void beforeUpdate ( AuthenticatedUser user , ModelType model ) throws GuacamoleException { if ( ! hasObjectPermission ( user , model . getIdentifier ( ) , ObjectPermission . Type . UPDATE ) ) throw new GuacamoleSecurityException ( "Permission denied." ) ; } protected void beforeDelete ( AuthenticatedUser user , String identifier ) throws GuacamoleException { if ( ! hasObjectPermission ( user , identifier , ObjectPermission . Type . DELETE ) ) throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public InternalType retrieveObject ( AuthenticatedUser user , String identifier ) throws GuacamoleException { Collection < InternalType > objects = retrieveObjects ( user , Collections . singleton ( identifier ) ) ; if ( objects . isEmpty ( ) ) return null ; assert ( objects . size ( ) == 1 ) ; return objects . iterator ( ) . next ( ) ; } @ Override public Collection < InternalType > retrieveObjects ( AuthenticatedUser user , Collection < String > identifiers ) throws GuacamoleException { if ( identifiers . isEmpty ( ) ) return Collections . < InternalType > emptyList ( ) ; Collection < ModelType > objects ; if ( user . getUser ( ) . isAdministrator ( ) ) objects = getObjectMapper ( ) . select ( identifiers ) ; else objects = getObjectMapper ( ) . selectReadable ( user . getUser ( ) . getModel ( ) , identifiers ) ; return getObjectInstances ( user , objects ) ; } protected Collection < ObjectPermissionModel > getImplicitPermissions ( AuthenticatedUser user , ModelType model ) { Collection < ObjectPermissionModel > implicitPermissions = new ArrayList < ObjectPermissionModel > ( IMPLICIT_OBJECT_PERMISSIONS . length ) ; UserModel userModel = user . getUser ( ) . getModel ( ) ; for ( ObjectPermission . Type permission : IMPLICIT_OBJECT_PERMISSIONS ) { ObjectPermissionModel permissionModel = new ObjectPermissionModel ( ) ; permissionModel . setUserID ( userModel . getObjectID ( ) ) ; permissionModel . setUsername ( userModel . getIdentifier ( ) ) ; permissionModel . setType ( permission ) ; permissionModel . setObjectIdentifier ( model . getIdentifier ( ) ) ; implicitPermissions . add ( permissionModel ) ; } return implicitPermissions ; } @ Override public InternalType createObject ( AuthenticatedUser user , ExternalType object ) throws GuacamoleException { ModelType model = getModelInstance ( user , object ) ; beforeCreate ( user , model ) ; getObjectMapper ( ) . insert ( model ) ; getPermissionMapper ( ) . insert ( getImplicitPermissions ( user , model ) ) ; return getObjectInstance ( user , model ) ; } @ Override public void deleteObject ( AuthenticatedUser user , String identifier ) throws GuacamoleException { beforeDelete ( user , identifier ) ; getObjectMapper ( ) . delete ( identifier ) ; } @ Override public void updateObject ( AuthenticatedUser user , InternalType object ) throws GuacamoleException { ModelType model = object . getModel ( ) ; beforeUpdate ( user , model ) ; getObjectMapper ( ) . update ( model ) ; } @ Override public Set < String > getIdentifiers ( AuthenticatedUser user ) throws GuacamoleException { if ( user . getUser ( ) . isAdministrator ( ) ) return getObjectMapper ( ) . selectIdentifiers ( ) ; else return getObjectMapper ( ) . selectReadableIdentifiers ( user . getUser ( ) . getModel ( ) ) ; } }
package org . glyptodon . guacamole . auth . jdbc . base ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . RootConnectionGroup ; public abstract class ModeledGroupedDirectoryObject < ModelType extends GroupedObjectModel > extends ModeledDirectoryObject < ModelType > { public String getParentIdentifier ( ) { String parentIdentifier = getModel ( ) . getParentIdentifier ( ) ; if ( parentIdentifier == null ) return RootConnectionGroup . IDENTIFIER ; return parentIdentifier ; } public void setParentIdentifier ( String parentIdentifier ) { if ( parentIdentifier != null && parentIdentifier . equals ( RootConnectionGroup . IDENTIFIER ) ) parentIdentifier = null ; getModel ( ) . setParentIdentifier ( parentIdentifier ) ; } }
package org . glyptodon . guacamole . auth . jdbc . base ; public abstract class GroupedObjectModel extends ObjectModel { private String parentIdentifier ; public GroupedObjectModel ( ) { } public String getParentIdentifier ( ) { return parentIdentifier ; } public void setParentIdentifier ( String parentIdentifier ) { this . parentIdentifier = parentIdentifier ; } }
package org . glyptodon . guacamole . auth . jdbc . base ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; public abstract class RestrictedObject { private AuthenticatedUser currentUser ; public void init ( AuthenticatedUser currentUser ) { setCurrentUser ( currentUser ) ; } public AuthenticatedUser getCurrentUser ( ) { return currentUser ; } public void setCurrentUser ( AuthenticatedUser currentUser ) { this . currentUser = currentUser ; } }
package org . glyptodon . guacamole . auth . jdbc . base ; import org . glyptodon . guacamole . net . auth . Identifiable ; public abstract class ModeledDirectoryObject < ModelType extends ObjectModel > extends ModeledObject < ModelType > implements Identifiable { @ Override public String getIdentifier ( ) { return getModel ( ) . getIdentifier ( ) ; } @ Override public void setIdentifier ( String identifier ) { getModel ( ) . setIdentifier ( identifier ) ; } }
package org . glyptodon . guacamole . auth . jdbc . connection ;
package org . glyptodon . guacamole . auth . jdbc . connection ; import java . util . Collection ; import org . apache . ibatis . annotations . Param ; public interface ParameterMapper { Collection < ParameterModel > select ( @ Param ( "identifier" ) String identifier ) ; int insert ( @ Param ( "parameters" ) Collection < ParameterModel > parameters ) ; int delete ( @ Param ( "identifier" ) String identifier ) ; }
package org . glyptodon . guacamole . auth . jdbc . connection ; import java . util . Date ; public class ConnectionRecordModel { private String connectionIdentifier ; private Integer userID ; private String username ; private Date startDate ; private Date endDate ; public String getConnectionIdentifier ( ) { return connectionIdentifier ; } public void setConnectionIdentifier ( String connectionIdentifier ) { this . connectionIdentifier = connectionIdentifier ; } public Integer getUserID ( ) { return userID ; } public void setUserID ( Integer userID ) { this . userID = userID ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public Date getStartDate ( ) { return startDate ; } public void setStartDate ( Date startDate ) { this . startDate = startDate ; } public Date getEndDate ( ) { return endDate ; } public void setEndDate ( Date endDate ) { this . endDate = endDate ; } }
package org . glyptodon . guacamole . auth . jdbc . connection ; import com . google . inject . Inject ; import java . util . Collection ; import java . util . Collections ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . base . RestrictedObject ; import org . glyptodon . guacamole . net . auth . Connection ; import org . glyptodon . guacamole . net . auth . Directory ; import org . mybatis . guice . transactional . Transactional ; public class ConnectionDirectory extends RestrictedObject implements Directory < Connection > { @ Inject private ConnectionService connectionService ; @ Override public Connection get ( String identifier ) throws GuacamoleException { return connectionService . retrieveObject ( getCurrentUser ( ) , identifier ) ; } @ Override @ Transactional public Collection < Connection > getAll ( Collection < String > identifiers ) throws GuacamoleException { Collection < ModeledConnection > objects = connectionService . retrieveObjects ( getCurrentUser ( ) , identifiers ) ; return Collections . < Connection > unmodifiableCollection ( objects ) ; } @ Override @ Transactional public Set < String > getIdentifiers ( ) throws GuacamoleException { return connectionService . getIdentifiers ( getCurrentUser ( ) ) ; } @ Override @ Transactional public void add ( Connection object ) throws GuacamoleException { connectionService . createObject ( getCurrentUser ( ) , object ) ; } @ Override @ Transactional public void update ( Connection object ) throws GuacamoleException { ModeledConnection connection = ( ModeledConnection ) object ; connectionService . updateObject ( getCurrentUser ( ) , connection ) ; } @ Override @ Transactional public void remove ( String identifier ) throws GuacamoleException { connectionService . deleteObject ( getCurrentUser ( ) , identifier ) ; } }
package org . glyptodon . guacamole . servlet ;
package org . glyptodon . guacamole . auth . jdbc . connection ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . base . ModeledDirectoryObjectMapper ; import org . glyptodon . guacamole . auth . jdbc . user . UserModel ; import org . apache . ibatis . annotations . Param ; public interface ConnectionMapper extends ModeledDirectoryObjectMapper < ConnectionModel > { Set < String > selectIdentifiersWithin ( @ Param ( "parentIdentifier" ) String parentIdentifier ) ; Set < String > selectReadableIdentifiersWithin ( @ Param ( "user" ) UserModel user , @ Param ( "parentIdentifier" ) String parentIdentifier ) ; ConnectionModel selectOneByName ( @ Param ( "parentIdentifier" ) String parentIdentifier , @ Param ( "name" ) String name ) ; }
package org . glyptodon . guacamole . auth . jdbc . connection ; public class ParameterModel { private String connectionIdentifier ; private String name ; private String value ; public String getConnectionIdentifier ( ) { return connectionIdentifier ; } public void setConnectionIdentifier ( String connectionIdentifier ) { this . connectionIdentifier = connectionIdentifier ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } }
package org . glyptodon . guacamole . auth . jdbc . connection ; import com . google . inject . Inject ; import java . util . Map ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; public class ModeledGuacamoleConfiguration extends GuacamoleConfiguration { private AuthenticatedUser currentUser ; private ConnectionModel connectionModel ; @ Inject private ConnectionService connectionService ; private Map < String , String > parameters = null ; public ModeledGuacamoleConfiguration ( ) { } public void init ( AuthenticatedUser currentUser , ConnectionModel connectionModel ) { this . currentUser = currentUser ; this . connectionModel = connectionModel ; } @ Override public String getProtocol ( ) { return connectionModel . getProtocol ( ) ; } @ Override public void setProtocol ( String protocol ) { super . setProtocol ( protocol ) ; connectionModel . setProtocol ( protocol ) ; } @ Override public void setParameters ( Map < String , String > parameters ) { this . parameters = parameters ; super . setParameters ( parameters ) ; } @ Override public Map < String , String > getParameters ( ) { if ( parameters == null ) { Map < String , String > visibleParameters = connectionService . retrieveParameters ( currentUser , connectionModel . getIdentifier ( ) ) ; super . setParameters ( visibleParameters ) ; } return super . getParameters ( ) ; } }
package org . glyptodon . guacamole . auth . jdbc . connection ; import java . util . Date ; import org . glyptodon . guacamole . net . auth . ConnectionRecord ; public class ModeledConnectionRecord implements ConnectionRecord { private final ConnectionRecordModel model ; public ModeledConnectionRecord ( ConnectionRecordModel model ) { this . model = model ; } @ Override public Date getStartDate ( ) { return model . getStartDate ( ) ; } @ Override public Date getEndDate ( ) { return model . getEndDate ( ) ; } @ Override public String getRemoteHost ( ) { return null ; } @ Override public String getUsername ( ) { return model . getUsername ( ) ; } @ Override public boolean isActive ( ) { return false ; } }
package org . glyptodon . guacamole . auth . jdbc . connection ; import org . glyptodon . guacamole . auth . jdbc . base . GroupedObjectModel ; public class ConnectionModel extends GroupedObjectModel { private String name ; private String protocol ; public ConnectionModel ( ) { } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getProtocol ( ) { return protocol ; } public void setProtocol ( String protocol ) { this . protocol = protocol ; } @ Override public String getIdentifier ( ) { Integer id = getObjectID ( ) ; if ( id == null ) return null ; return id . toString ( ) ; } @ Override public void setIdentifier ( String identifier ) { throw new UnsupportedOperationException ( "Connection identifiers are derived from IDs. They cannot be set." ) ; } }
package org . glyptodon . guacamole . auth . jdbc . connection ; import com . google . inject . Inject ; import com . google . inject . Provider ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . base . ModeledDirectoryObjectMapper ; import org . glyptodon . guacamole . auth . jdbc . tunnel . GuacamoleTunnelService ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . auth . jdbc . base . ModeledGroupedDirectoryObjectService ; import org . glyptodon . guacamole . auth . jdbc . permission . ConnectionPermissionMapper ; import org . glyptodon . guacamole . auth . jdbc . permission . ObjectPermissionMapper ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . Connection ; import org . glyptodon . guacamole . net . auth . ConnectionRecord ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . auth . permission . SystemPermission ; import org . glyptodon . guacamole . net . auth . permission . SystemPermissionSet ; import org . glyptodon . guacamole . protocol . GuacamoleClientInformation ; public class ConnectionService extends ModeledGroupedDirectoryObjectService < ModeledConnection , Connection , ConnectionModel > { @ Inject private ConnectionMapper connectionMapper ; @ Inject private ConnectionPermissionMapper connectionPermissionMapper ; @ Inject private ParameterMapper parameterMapper ; @ Inject private ConnectionRecordMapper connectionRecordMapper ; @ Inject private Provider < ModeledConnection > connectionProvider ; @ Inject private GuacamoleTunnelService tunnelService ; @ Override protected ModeledDirectoryObjectMapper < ConnectionModel > getObjectMapper ( ) { return connectionMapper ; } @ Override protected ObjectPermissionMapper getPermissionMapper ( ) { return connectionPermissionMapper ; } @ Override protected ModeledConnection getObjectInstance ( AuthenticatedUser currentUser , ConnectionModel model ) { ModeledConnection connection = connectionProvider . get ( ) ; connection . init ( currentUser , model ) ; return connection ; } @ Override protected ConnectionModel getModelInstance ( AuthenticatedUser currentUser , final Connection object ) { ConnectionModel model = new ConnectionModel ( ) ; ModeledConnection connection = getObjectInstance ( currentUser , model ) ; connection . setParentIdentifier ( object . getParentIdentifier ( ) ) ; connection . setName ( object . getName ( ) ) ; connection . setConfiguration ( object . getConfiguration ( ) ) ; return model ; } @ Override protected boolean hasCreatePermission ( AuthenticatedUser user ) throws GuacamoleException { SystemPermissionSet permissionSet = user . getUser ( ) . getSystemPermissions ( ) ; return permissionSet . hasPermission ( SystemPermission . Type . CREATE_CONNECTION ) ; } @ Override protected ObjectPermissionSet getPermissionSet ( AuthenticatedUser user ) throws GuacamoleException { return user . getUser ( ) . getConnectionPermissions ( ) ; } @ Override protected void beforeCreate ( AuthenticatedUser user , ConnectionModel model ) throws GuacamoleException { super . beforeCreate ( user , model ) ; if ( model . getName ( ) == null || model . getName ( ) . trim ( ) . isEmpty ( ) ) throw new GuacamoleClientException ( "Connection names must not be blank." ) ; ConnectionModel existing = connectionMapper . selectOneByName ( model . getParentIdentifier ( ) , model . getName ( ) ) ; if ( existing != null ) throw new GuacamoleClientException ( "The connection \"" + model . getName ( ) + "\" already exists." ) ; } @ Override protected void beforeUpdate ( AuthenticatedUser user , ConnectionModel model ) throws GuacamoleException { super . beforeUpdate ( user , model ) ; if ( model . getName ( ) == null || model . getName ( ) . trim ( ) . isEmpty ( ) ) throw new GuacamoleClientException ( "Connection names must not be blank." ) ; ConnectionModel existing = connectionMapper . selectOneByName ( model . getParentIdentifier ( ) , model . getName ( ) ) ; if ( existing != null ) { if ( ! existing . getObjectID ( ) . equals ( model . getObjectID ( ) ) ) throw new GuacamoleClientException ( "The connection \"" + model . getName ( ) + "\" already exists." ) ; } } private Collection < ParameterModel > getParameterModels ( ModeledConnection connection ) { Map < String , String > parameters = connection . getConfiguration ( ) . getParameters ( ) ; Collection < ParameterModel > parameterModels = new ArrayList < ParameterModel > ( parameters . size ( ) ) ; for ( Map . Entry < String , String > parameterEntry : parameters . entrySet ( ) ) { String name = parameterEntry . getKey ( ) ; String value = parameterEntry . getValue ( ) ; if ( value == null || value . isEmpty ( ) ) continue ; ParameterModel model = new ParameterModel ( ) ; model . setConnectionIdentifier ( connection . getIdentifier ( ) ) ; model . setName ( name ) ; model . setValue ( value ) ; parameterModels . add ( model ) ; } return parameterModels ; } @ Override public ModeledConnection createObject ( AuthenticatedUser user , Connection object ) throws GuacamoleException { ModeledConnection connection = super . createObject ( user , object ) ; connection . setConfiguration ( object . getConfiguration ( ) ) ; Collection < ParameterModel > parameterModels = getParameterModels ( connection ) ; if ( ! parameterModels . isEmpty ( ) ) parameterMapper . insert ( parameterModels ) ; return connection ; } @ Override public void updateObject ( AuthenticatedUser user , ModeledConnection object ) throws GuacamoleException { super . updateObject ( user , object ) ; Collection < ParameterModel > parameterModels = getParameterModels ( object ) ; parameterMapper . delete ( object . getIdentifier ( ) ) ; if ( ! parameterModels . isEmpty ( ) ) parameterMapper . insert ( parameterModels ) ; } public Set < String > getIdentifiersWithin ( AuthenticatedUser user , String identifier ) throws GuacamoleException { if ( user . getUser ( ) . isAdministrator ( ) ) return connectionMapper . selectIdentifiersWithin ( identifier ) ; else return connectionMapper . selectReadableIdentifiersWithin ( user . getUser ( ) . getModel ( ) , identifier ) ; } public Map < String , String > retrieveParameters ( AuthenticatedUser user , String identifier ) { Map < String , String > parameterMap = new HashMap < String , String > ( ) ; boolean canRetrieveParameters ; try { canRetrieveParameters = hasObjectPermission ( user , identifier , ObjectPermission . Type . UPDATE ) ; } catch ( GuacamoleException e ) { return parameterMap ; } if ( canRetrieveParameters ) { for ( ParameterModel parameter : parameterMapper . select ( identifier ) ) parameterMap . put ( parameter . getName ( ) , parameter . getValue ( ) ) ; } return parameterMap ; } public List < ConnectionRecord > retrieveHistory ( AuthenticatedUser user , ModeledConnection connection ) throws GuacamoleException { String identifier = connection . getIdentifier ( ) ; if ( hasObjectPermission ( user , identifier , ObjectPermission . Type . READ ) ) { List < ConnectionRecordModel > models = connectionRecordMapper . select ( identifier ) ; List < ConnectionRecord > records = new ArrayList < ConnectionRecord > ( tunnelService . getActiveConnections ( connection ) ) ; Collections . reverse ( records ) ; for ( ConnectionRecordModel model : models ) records . add ( new ModeledConnectionRecord ( model ) ) ; return records ; } throw new GuacamoleSecurityException ( "Permission denied." ) ; } public GuacamoleTunnel connect ( AuthenticatedUser user , ModeledConnection connection , GuacamoleClientInformation info ) throws GuacamoleException { if ( hasObjectPermission ( user , connection . getIdentifier ( ) , ObjectPermission . Type . READ ) ) return tunnelService . getGuacamoleTunnel ( user , connection , info ) ; throw new GuacamoleSecurityException ( "Permission denied." ) ; } }
package org . glyptodon . guacamole . auth . jdbc . connection ; import com . google . inject . Inject ; import com . google . inject . Provider ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import org . glyptodon . guacamole . auth . jdbc . tunnel . GuacamoleTunnelService ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . base . ModeledGroupedDirectoryObject ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . Connection ; import org . glyptodon . guacamole . net . auth . ConnectionRecord ; import org . glyptodon . guacamole . protocol . GuacamoleClientInformation ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; public class ModeledConnection extends ModeledGroupedDirectoryObject < ConnectionModel > implements Connection { @ Inject private ConnectionService connectionService ; @ Inject private GuacamoleTunnelService tunnelService ; @ Inject private Provider < ModeledGuacamoleConfiguration > configProvider ; private GuacamoleConfiguration config = null ; public ModeledConnection ( ) { } @ Override public String getName ( ) { return getModel ( ) . getName ( ) ; } @ Override public void setName ( String name ) { getModel ( ) . setName ( name ) ; } @ Override public GuacamoleConfiguration getConfiguration ( ) { if ( config != null ) return config ; ModeledGuacamoleConfiguration restrictedConfig = configProvider . get ( ) ; restrictedConfig . init ( getCurrentUser ( ) , getModel ( ) ) ; return restrictedConfig ; } @ Override public void setConfiguration ( GuacamoleConfiguration config ) { this . config = config ; getModel ( ) . setProtocol ( config . getProtocol ( ) ) ; } @ Override public List < ? extends ConnectionRecord > getHistory ( ) throws GuacamoleException { return connectionService . retrieveHistory ( getCurrentUser ( ) , this ) ; } @ Override public GuacamoleTunnel connect ( GuacamoleClientInformation info ) throws GuacamoleException { return connectionService . connect ( getCurrentUser ( ) , this , info ) ; } @ Override public int getActiveConnections ( ) { return tunnelService . getActiveConnections ( this ) . size ( ) ; } @ Override public Map < String , String > getAttributes ( ) { return Collections . < String , String > emptyMap ( ) ; } @ Override public void setAttributes ( Map < String , String > attributes ) { } }
package org . glyptodon . guacamole . auth . jdbc . connection ; import java . util . List ; import org . apache . ibatis . annotations . Param ; public interface ConnectionRecordMapper { List < ConnectionRecordModel > select ( @ Param ( "identifier" ) String identifier ) ; int insert ( @ Param ( "record" ) ConnectionRecordModel record ) ; }
package org . glyptodon . guacamole . auth . jdbc . security ;
package org . glyptodon . guacamole . auth . jdbc . security ; import java . io . UnsupportedEncodingException ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import javax . xml . bind . DatatypeConverter ; public class SHA256PasswordEncryptionService implements PasswordEncryptionService { @ Override public byte [ ] createPasswordHash ( String password , byte [ ] salt ) { try { StringBuilder builder = new StringBuilder ( ) ; builder . append ( password ) ; if ( salt != null ) builder . append ( DatatypeConverter . printHexBinary ( salt ) ) ; MessageDigest md = MessageDigest . getInstance ( "SHA-256" ) ; md . update ( builder . toString ( ) . getBytes ( "UTF-8" ) ) ; return md . digest ( ) ; } catch ( UnsupportedEncodingException e ) { throw new UnsupportedOperationException ( "Unexpected lack of UTF-8 support." , e ) ; } catch ( NoSuchAlgorithmException e ) { throw new UnsupportedOperationException ( "Unexpected lack of SHA-256 support." , e ) ; } } }
package org . glyptodon . guacamole . servlet ; import java . io . BufferedWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleConnectionClosedException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleResourceNotFoundException ; import org . glyptodon . guacamole . GuacamoleServerException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . GuacamoleWriter ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public abstract class GuacamoleHTTPTunnelServlet extends HttpServlet { private Logger logger = LoggerFactory . getLogger ( GuacamoleHTTPTunnelServlet . class ) ; private static final String READ_PREFIX = "read:" ; private static final String WRITE_PREFIX = "write:" ; private static final int READ_PREFIX_LENGTH = READ_PREFIX . length ( ) ; private static final int WRITE_PREFIX_LENGTH = WRITE_PREFIX . length ( ) ; private static final int UUID_LENGTH = 36 ; @ Override protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException { handleTunnelRequest ( request , response ) ; } @ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException { handleTunnelRequest ( request , response ) ; } public static void sendError ( HttpServletResponse response , GuacamoleStatus guac_status , String message ) throws ServletException { try { if ( ! response . isCommitted ( ) ) { response . addHeader ( "Guacamole-Status-Code" , Integer . toString ( guac_status . getGuacamoleStatusCode ( ) ) ) ; response . addHeader ( "Guacamole-Error-Message" , message ) ; response . sendError ( guac_status . getHttpStatusCode ( ) ) ; } } catch ( IOException ioe ) { throw new ServletException ( ioe ) ; } } protected void handleTunnelRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException { try { String query = request . getQueryString ( ) ; if ( query == null ) throw new GuacamoleClientException ( "No query string provided." ) ; if ( query . equals ( "connect" ) ) { GuacamoleTunnel tunnel = doConnect ( request ) ; if ( tunnel != null ) { HttpSession httpSession = request . getSession ( true ) ; GuacamoleSession session = new GuacamoleSession ( httpSession ) ; session . attachTunnel ( tunnel ) ; try { response . setHeader ( "Cache-Control" , "no-cache" ) ; response . getWriter ( ) . print ( tunnel . getUUID ( ) . toString ( ) ) ; } catch ( IOException e ) { throw new GuacamoleServerException ( e ) ; } } else throw new GuacamoleResourceNotFoundException ( "No tunnel created." ) ; } else if ( query . startsWith ( READ_PREFIX ) ) doRead ( request , response , query . substring ( READ_PREFIX_LENGTH , READ_PREFIX_LENGTH + UUID_LENGTH ) ) ; else if ( query . startsWith ( WRITE_PREFIX ) ) doWrite ( request , response , query . substring ( WRITE_PREFIX_LENGTH , WRITE_PREFIX_LENGTH + UUID_LENGTH ) ) ; else throw new GuacamoleClientException ( "Invalid tunnel operation: " + query ) ; } catch ( GuacamoleClientException e ) { logger . warn ( "HTTP tunnel request rejected: {}" , e . getMessage ( ) ) ; sendError ( response , e . getStatus ( ) , e . getMessage ( ) ) ; } catch ( GuacamoleException e ) { logger . error ( "HTTP tunnel request failed: {}" , e . getMessage ( ) ) ; logger . debug ( "Internal error in HTTP tunnel." , e ) ; sendError ( response , e . getStatus ( ) , "Internal server error." ) ; } } protected abstract GuacamoleTunnel doConnect ( HttpServletRequest request ) throws GuacamoleException ; protected void doRead ( HttpServletRequest request , HttpServletResponse response , String tunnelUUID ) throws GuacamoleException { HttpSession httpSession = request . getSession ( false ) ; GuacamoleSession session = new GuacamoleSession ( httpSession ) ; GuacamoleTunnel tunnel = session . getTunnel ( tunnelUUID ) ; if ( tunnel == null ) throw new GuacamoleResourceNotFoundException ( "No such tunnel." ) ; if ( ! tunnel . isOpen ( ) ) throw new GuacamoleResourceNotFoundException ( "Tunnel is closed." ) ; GuacamoleReader reader = tunnel . acquireReader ( ) ; try { response . setContentType ( "application/octet-stream" ) ; response . setHeader ( "Cache-Control" , "no-cache" ) ; Writer out = new BufferedWriter ( new OutputStreamWriter ( response . getOutputStream ( ) , "UTF-8" ) ) ; try { char [ ] message = reader . read ( ) ; if ( message == null ) throw new GuacamoleConnectionClosedException ( "Tunnel reached end of stream." ) ; do { out . write ( message , 0 , message . length ) ; if ( ! reader . available ( ) ) { out . flush ( ) ; response . flushBuffer ( ) ; } if ( tunnel . hasQueuedReaderThreads ( ) ) break ; } while ( tunnel . isOpen ( ) && ( message = reader . read ( ) ) != null ) ; if ( message == null ) { session . detachTunnel ( tunnel ) ; tunnel . close ( ) ; } out . write ( "0.;" ) ; out . flush ( ) ; response . flushBuffer ( ) ; } catch ( GuacamoleConnectionClosedException e ) { session . detachTunnel ( tunnel ) ; tunnel . close ( ) ; out . write ( "0.;" ) ; out . flush ( ) ; response . flushBuffer ( ) ; } catch ( GuacamoleException e ) { session . detachTunnel ( tunnel ) ; tunnel . close ( ) ; throw e ; } finally { out . close ( ) ; } } catch ( IOException e ) { logger . debug ( "Error writing to servlet output stream" , e ) ; session . detachTunnel ( tunnel ) ; tunnel . close ( ) ; } finally { tunnel . releaseReader ( ) ; } } protected void doWrite ( HttpServletRequest request , HttpServletResponse response , String tunnelUUID ) throws GuacamoleException { HttpSession httpSession = request . getSession ( false ) ; GuacamoleSession session = new GuacamoleSession ( httpSession ) ; GuacamoleTunnel tunnel = session . getTunnel ( tunnelUUID ) ; if ( tunnel == null ) throw new GuacamoleResourceNotFoundException ( "No such tunnel." ) ; response . setContentType ( "application/octet-stream" ) ; response . setHeader ( "Cache-Control" , "no-cache" ) ; response . setContentLength ( 0 ) ; try { GuacamoleWriter writer = tunnel . acquireWriter ( ) ; Reader input = new InputStreamReader ( request . getInputStream ( ) , "UTF-8" ) ; try { int length ; char [ ] buffer = new char [ 8192 ] ; while ( tunnel . isOpen ( ) && ( length = input . read ( buffer , 0 , buffer . length ) ) != - 1 ) writer . write ( buffer , 0 , length ) ; } finally { input . close ( ) ; } } catch ( GuacamoleConnectionClosedException e ) { logger . debug ( "Connection to guacd closed." , e ) ; } catch ( IOException e ) { session . detachTunnel ( tunnel ) ; tunnel . close ( ) ; throw new GuacamoleServerException ( "I/O Error sending data to server: " + e . getMessage ( ) , e ) ; } finally { tunnel . releaseWriter ( ) ; } } }
package org . glyptodon . guacamole . auth . jdbc . security ; public interface PasswordEncryptionService { public byte [ ] createPasswordHash ( String password , byte [ ] salt ) ; }
package org . glyptodon . guacamole . auth . jdbc . security ; import java . security . SecureRandom ; public class SecureRandomSaltService implements SaltService { private SecureRandom secureRandom = new SecureRandom ( ) ; @ Override public byte [ ] generateSalt ( ) { byte [ ] salt = new byte [ 32 ] ; secureRandom . nextBytes ( salt ) ; return salt ; } }
package org . glyptodon . guacamole . auth . jdbc . security ; public interface SaltService { public byte [ ] generateSalt ( ) ; }
package org . glyptodon . guacamole . auth . jdbc . user ;
package org . glyptodon . guacamole . auth . jdbc . user ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import javax . servlet . http . HttpServletRequest ; import org . glyptodon . guacamole . net . auth . Credentials ; public class AuthenticatedUser { private final ModeledUser user ; private final Credentials credentials ; private final String remoteHost ; private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})" ; private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})" ; private static final String IP_ADDRESS_REGEX = "(" + IPV4_ADDRESS_REGEX + "|" + IPV6_ADDRESS_REGEX + ")" ; private static final Pattern X_FORWARDED_FOR = Pattern . compile ( "^" + IP_ADDRESS_REGEX + "(, " + IP_ADDRESS_REGEX + ")*$" ) ; private static String getRemoteHost ( Credentials credentials ) { HttpServletRequest request = credentials . getRequest ( ) ; String header = request . getHeader ( "X-Forwarded-For" ) ; if ( header != null ) { Matcher matcher = X_FORWARDED_FOR . matcher ( header ) ; if ( matcher . matches ( ) ) return matcher . group ( 1 ) ; } return request . getRemoteAddr ( ) ; } public AuthenticatedUser ( ModeledUser user , Credentials credentials ) { this . user = user ; this . credentials = credentials ; this . remoteHost = getRemoteHost ( credentials ) ; } public ModeledUser getUser ( ) { return user ; } public Credentials getCredentials ( ) { return credentials ; } public String getRemoteHost ( ) { return remoteHost ; } }
package org . glyptodon . guacamole . auth . jdbc . user ; import com . google . inject . Inject ; import java . util . Collection ; import java . util . Collections ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . base . RestrictedObject ; import org . glyptodon . guacamole . net . auth . Directory ; import org . glyptodon . guacamole . net . auth . User ; import org . mybatis . guice . transactional . Transactional ; public class UserDirectory extends RestrictedObject implements Directory < User > { @ Inject private UserService userService ; @ Override public User get ( String identifier ) throws GuacamoleException { return userService . retrieveObject ( getCurrentUser ( ) , identifier ) ; } @ Override @ Transactional public Collection < User > getAll ( Collection < String > identifiers ) throws GuacamoleException { Collection < ModeledUser > objects = userService . retrieveObjects ( getCurrentUser ( ) , identifiers ) ; return Collections . < User > unmodifiableCollection ( objects ) ; } @ Override @ Transactional public Set < String > getIdentifiers ( ) throws GuacamoleException { return userService . getIdentifiers ( getCurrentUser ( ) ) ; } @ Override @ Transactional public void add ( User object ) throws GuacamoleException { userService . createObject ( getCurrentUser ( ) , object ) ; } @ Override @ Transactional public void update ( User object ) throws GuacamoleException { ModeledUser user = ( ModeledUser ) object ; userService . updateObject ( getCurrentUser ( ) , user ) ; } @ Override @ Transactional public void remove ( String identifier ) throws GuacamoleException { userService . deleteObject ( getCurrentUser ( ) , identifier ) ; } }
package org . glyptodon . guacamole . auth . jdbc . user ; import com . google . inject . Inject ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import org . glyptodon . guacamole . auth . jdbc . base . ModeledDirectoryObject ; import org . glyptodon . guacamole . auth . jdbc . security . PasswordEncryptionService ; import org . glyptodon . guacamole . auth . jdbc . security . SaltService ; import org . glyptodon . guacamole . auth . jdbc . permission . SystemPermissionService ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . activeconnection . ActiveConnectionPermissionService ; import org . glyptodon . guacamole . auth . jdbc . permission . ConnectionGroupPermissionService ; import org . glyptodon . guacamole . auth . jdbc . permission . ConnectionPermissionService ; import org . glyptodon . guacamole . auth . jdbc . permission . UserPermissionService ; import org . glyptodon . guacamole . form . Field ; import org . glyptodon . guacamole . form . Form ; import org . glyptodon . guacamole . net . auth . User ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . auth . permission . SystemPermission ; import org . glyptodon . guacamole . net . auth . permission . SystemPermissionSet ; public class ModeledUser extends ModeledDirectoryObject < UserModel > implements User { public static final String DISABLED_ATTRIBUTE_NAME = "disabled" ; public static final String EXPIRED_ATTRIBUTE_NAME = "expired" ; public static final Form ACCOUNT_RESTRICTIONS = new Form ( "restrictions" , "Account Restrictions" , Arrays . asList ( new Field ( DISABLED_ATTRIBUTE_NAME , "Disabled" , "true" ) , new Field ( EXPIRED_ATTRIBUTE_NAME , "Password expired" , "true" ) ) ) ; public static final Collection < Form > ATTRIBUTES = Collections . unmodifiableCollection ( Arrays . asList ( ACCOUNT_RESTRICTIONS ) ) ; @ Inject private PasswordEncryptionService encryptionService ; @ Inject private SaltService saltService ; @ Inject private SystemPermissionService systemPermissionService ; @ Inject private ConnectionPermissionService connectionPermissionService ; @ Inject private ConnectionGroupPermissionService connectionGroupPermissionService ; @ Inject private ActiveConnectionPermissionService activeConnectionPermissionService ; @ Inject private UserPermissionService userPermissionService ; private String password = null ; public ModeledUser ( ) { } @ Override public String getPassword ( ) { return password ; } @ Override public void setPassword ( String password ) { UserModel userModel = getModel ( ) ; this . password = password ; if ( password == null ) { userModel . setPasswordSalt ( null ) ; userModel . setPasswordHash ( null ) ; } else { byte [ ] salt = saltService . generateSalt ( ) ; byte [ ] hash = encryptionService . createPasswordHash ( password , salt ) ; userModel . setPasswordSalt ( salt ) ; userModel . setPasswordHash ( hash ) ; } } public boolean isAdministrator ( ) throws GuacamoleException { SystemPermissionSet systemPermissionSet = getSystemPermissions ( ) ; return systemPermissionSet . hasPermission ( SystemPermission . Type . ADMINISTER ) ; } @ Override public SystemPermissionSet getSystemPermissions ( ) throws GuacamoleException { return systemPermissionService . getPermissionSet ( getCurrentUser ( ) , this ) ; } @ Override public ObjectPermissionSet getConnectionPermissions ( ) throws GuacamoleException { return connectionPermissionService . getPermissionSet ( getCurrentUser ( ) , this ) ; } @ Override public ObjectPermissionSet getConnectionGroupPermissions ( ) throws GuacamoleException { return connectionGroupPermissionService . getPermissionSet ( getCurrentUser ( ) , this ) ; } @ Override public ObjectPermissionSet getActiveConnectionPermissions ( ) throws GuacamoleException { return activeConnectionPermissionService . getPermissionSet ( getCurrentUser ( ) , this ) ; } @ Override public ObjectPermissionSet getUserPermissions ( ) throws GuacamoleException { return userPermissionService . getPermissionSet ( getCurrentUser ( ) , this ) ; } @ Override public Map < String , String > getAttributes ( ) { Map < String , String > attributes = new HashMap < String , String > ( ) ; attributes . put ( DISABLED_ATTRIBUTE_NAME , getModel ( ) . isDisabled ( ) ? "true" : null ) ; attributes . put ( EXPIRED_ATTRIBUTE_NAME , getModel ( ) . isExpired ( ) ? "true" : null ) ; return attributes ; } @ Override public void setAttributes ( Map < String , String > attributes ) { getModel ( ) . setDisabled ( "true" . equals ( attributes . get ( DISABLED_ATTRIBUTE_NAME ) ) ) ; getModel ( ) . setExpired ( "true" . equals ( attributes . get ( EXPIRED_ATTRIBUTE_NAME ) ) ) ; } }
package org . glyptodon . guacamole . auth . jdbc . user ; import com . google . inject . Inject ; import com . google . inject . Provider ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . auth . jdbc . base . ModeledDirectoryObjectMapper ; import org . glyptodon . guacamole . auth . jdbc . base . ModeledDirectoryObjectService ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleUnsupportedException ; import org . glyptodon . guacamole . auth . jdbc . permission . ObjectPermissionMapper ; import org . glyptodon . guacamole . auth . jdbc . permission . ObjectPermissionModel ; import org . glyptodon . guacamole . auth . jdbc . permission . UserPermissionMapper ; import org . glyptodon . guacamole . auth . jdbc . security . PasswordEncryptionService ; import org . glyptodon . guacamole . net . auth . User ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . auth . permission . SystemPermission ; import org . glyptodon . guacamole . net . auth . permission . SystemPermissionSet ; public class UserService extends ModeledDirectoryObjectService < ModeledUser , User , UserModel > { private static final ObjectPermission . Type [ ] IMPLICIT_USER_PERMISSIONS = { ObjectPermission . Type . READ , ObjectPermission . Type . UPDATE } ; @ Inject private UserMapper userMapper ; @ Inject private UserPermissionMapper userPermissionMapper ; @ Inject private Provider < ModeledUser > userProvider ; @ Inject private PasswordEncryptionService encryptionService ; @ Override protected ModeledDirectoryObjectMapper < UserModel > getObjectMapper ( ) { return userMapper ; } @ Override protected ObjectPermissionMapper getPermissionMapper ( ) { return userPermissionMapper ; } @ Override protected ModeledUser getObjectInstance ( AuthenticatedUser currentUser , UserModel model ) { ModeledUser user = userProvider . get ( ) ; user . init ( currentUser , model ) ; return user ; } @ Override protected UserModel getModelInstance ( AuthenticatedUser currentUser , final User object ) { UserModel model = new UserModel ( ) ; ModeledUser user = getObjectInstance ( currentUser , model ) ; user . setIdentifier ( object . getIdentifier ( ) ) ; user . setPassword ( object . getPassword ( ) ) ; return model ; } @ Override protected boolean hasCreatePermission ( AuthenticatedUser user ) throws GuacamoleException { SystemPermissionSet permissionSet = user . getUser ( ) . getSystemPermissions ( ) ; return permissionSet . hasPermission ( SystemPermission . Type . CREATE_USER ) ; } @ Override protected ObjectPermissionSet getPermissionSet ( AuthenticatedUser user ) throws GuacamoleException { return user . getUser ( ) . getUserPermissions ( ) ; } @ Override protected void beforeCreate ( AuthenticatedUser user , UserModel model ) throws GuacamoleException { super . beforeCreate ( user , model ) ; if ( model . getIdentifier ( ) == null || model . getIdentifier ( ) . trim ( ) . isEmpty ( ) ) throw new GuacamoleClientException ( "The username must not be blank." ) ; Collection < UserModel > existing = userMapper . select ( Collections . singleton ( model . getIdentifier ( ) ) ) ; if ( ! existing . isEmpty ( ) ) throw new GuacamoleClientException ( "User \"" + model . getIdentifier ( ) + "\" already exists." ) ; } @ Override protected void beforeUpdate ( AuthenticatedUser user , UserModel model ) throws GuacamoleException { super . beforeUpdate ( user , model ) ; if ( model . getIdentifier ( ) == null || model . getIdentifier ( ) . trim ( ) . isEmpty ( ) ) throw new GuacamoleClientException ( "The username must not be blank." ) ; UserModel existing = userMapper . selectOne ( model . getIdentifier ( ) ) ; if ( existing != null ) { if ( ! existing . getObjectID ( ) . equals ( model . getObjectID ( ) ) ) throw new GuacamoleClientException ( "User \"" + model . getIdentifier ( ) + "\" already exists." ) ; } } @ Override protected Collection < ObjectPermissionModel > getImplicitPermissions ( AuthenticatedUser user , UserModel model ) { Collection < ObjectPermissionModel > implicitPermissions = super . getImplicitPermissions ( user , model ) ; for ( ObjectPermission . Type permissionType : IMPLICIT_USER_PERMISSIONS ) { ObjectPermissionModel permissionModel = new ObjectPermissionModel ( ) ; permissionModel . setUserID ( model . getObjectID ( ) ) ; permissionModel . setUsername ( model . getIdentifier ( ) ) ; permissionModel . setType ( permissionType ) ; permissionModel . setObjectIdentifier ( model . getIdentifier ( ) ) ; implicitPermissions . add ( permissionModel ) ; } return implicitPermissions ; } @ Override protected void beforeDelete ( AuthenticatedUser user , String identifier ) throws GuacamoleException { super . beforeDelete ( user , identifier ) ; if ( identifier . equals ( user . getUser ( ) . getIdentifier ( ) ) ) throw new GuacamoleUnsupportedException ( "Deleting your own user is not allowed." ) ; } public ModeledUser retrieveUser ( Credentials credentials ) { String username = credentials . getUsername ( ) ; String password = credentials . getPassword ( ) ; UserModel userModel = userMapper . selectOne ( username ) ; if ( userModel == null ) return null ; byte [ ] hash = encryptionService . createPasswordHash ( password , userModel . getPasswordSalt ( ) ) ; if ( Arrays . equals ( hash , userModel . getPasswordHash ( ) ) ) { ModeledUser user = getObjectInstance ( null , userModel ) ; user . setCurrentUser ( new AuthenticatedUser ( user , credentials ) ) ; return user ; } return null ; } }
package org . glyptodon . guacamole . auth . jdbc . user ; import org . glyptodon . guacamole . auth . jdbc . base . ModeledDirectoryObjectMapper ; import org . apache . ibatis . annotations . Param ; public interface UserMapper extends ModeledDirectoryObjectMapper < UserModel > { UserModel selectOne ( @ Param ( "username" ) String username ) ; }
package org . glyptodon . guacamole . auth . jdbc . user ; import org . glyptodon . guacamole . auth . jdbc . base . ObjectModel ; public class UserModel extends ObjectModel { private byte [ ] passwordHash ; private byte [ ] passwordSalt ; private boolean disabled ; private boolean expired ; public UserModel ( ) { } public byte [ ] getPasswordHash ( ) { return passwordHash ; } public void setPasswordHash ( byte [ ] passwordHash ) { this . passwordHash = passwordHash ; } public byte [ ] getPasswordSalt ( ) { return passwordSalt ; } public void setPasswordSalt ( byte [ ] passwordSalt ) { this . passwordSalt = passwordSalt ; } public boolean isDisabled ( ) { return disabled ; } public void setDisabled ( boolean disabled ) { this . disabled = disabled ; } public boolean isExpired ( ) { return expired ; } public void setExpired ( boolean expired ) { this . expired = expired ; } }
package org . glyptodon . guacamole . servlet ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import javax . servlet . http . HttpSession ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class GuacamoleSession { private Logger logger = LoggerFactory . getLogger ( GuacamoleSession . class ) ; private ConcurrentMap < String , GuacamoleTunnel > tunnels ; @ SuppressWarnings ( "unchecked" ) public GuacamoleSession ( HttpSession session ) throws GuacamoleException { if ( session == null ) throw new GuacamoleSecurityException ( "User has no session." ) ; synchronized ( session ) { tunnels = ( ConcurrentMap < String , GuacamoleTunnel > ) session . getAttribute ( "GUAC_TUNNELS" ) ; if ( tunnels == null ) { tunnels = new ConcurrentHashMap < String , GuacamoleTunnel > ( ) ; session . setAttribute ( "GUAC_TUNNELS" , tunnels ) ; } } } public void attachTunnel ( GuacamoleTunnel tunnel ) { tunnels . put ( tunnel . getUUID ( ) . toString ( ) , tunnel ) ; logger . debug ( "Attached tunnel {}." , tunnel . getUUID ( ) ) ; } public void detachTunnel ( GuacamoleTunnel tunnel ) { tunnels . remove ( tunnel . getUUID ( ) . toString ( ) ) ; logger . debug ( "Detached tunnel {}." , tunnel . getUUID ( ) ) ; } public GuacamoleTunnel getTunnel ( String tunnelUUID ) { return tunnels . get ( tunnelUUID ) ; } }
package org . glyptodon . guacamole . auth . jdbc . user ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . RootConnectionGroup ; import org . glyptodon . guacamole . auth . jdbc . connectiongroup . ConnectionGroupDirectory ; import org . glyptodon . guacamole . auth . jdbc . connection . ConnectionDirectory ; import com . google . inject . Inject ; import com . google . inject . Provider ; import java . util . Collection ; import java . util . Collections ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . base . RestrictedObject ; import org . glyptodon . guacamole . auth . jdbc . activeconnection . ActiveConnectionDirectory ; import org . glyptodon . guacamole . form . Form ; import org . glyptodon . guacamole . net . auth . ActiveConnection ; import org . glyptodon . guacamole . net . auth . Connection ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . net . auth . Directory ; import org . glyptodon . guacamole . net . auth . User ; public class UserContext extends RestrictedObject implements org . glyptodon . guacamole . net . auth . UserContext { @ Inject private UserDirectory userDirectory ; @ Inject private ConnectionDirectory connectionDirectory ; @ Inject private ConnectionGroupDirectory connectionGroupDirectory ; @ Inject private ActiveConnectionDirectory activeConnectionDirectory ; @ Inject private Provider < RootConnectionGroup > rootGroupProvider ; @ Override public void init ( AuthenticatedUser currentUser ) { super . init ( currentUser ) ; userDirectory . init ( currentUser ) ; connectionDirectory . init ( currentUser ) ; connectionGroupDirectory . init ( currentUser ) ; activeConnectionDirectory . init ( currentUser ) ; } @ Override public User self ( ) { return getCurrentUser ( ) . getUser ( ) ; } @ Override public Directory < User > getUserDirectory ( ) throws GuacamoleException { return userDirectory ; } @ Override public Directory < Connection > getConnectionDirectory ( ) throws GuacamoleException { return connectionDirectory ; } @ Override public Directory < ConnectionGroup > getConnectionGroupDirectory ( ) throws GuacamoleException { return connectionGroupDirectory ; } @ Override public Directory < ActiveConnection > getActiveConnectionDirectory ( ) throws GuacamoleException { return activeConnectionDirectory ; } @ Override public ConnectionGroup getRootConnectionGroup ( ) throws GuacamoleException { RootConnectionGroup rootGroup = rootGroupProvider . get ( ) ; rootGroup . init ( getCurrentUser ( ) ) ; return rootGroup ; } @ Override public Collection < Form > getUserAttributes ( ) { return ModeledUser . ATTRIBUTES ; } @ Override public Collection < Form > getConnectionAttributes ( ) { return Collections . < Form > emptyList ( ) ; } @ Override public Collection < Form > getConnectionGroupAttributes ( ) { return Collections . < Form > emptyList ( ) ; } }
package org . glyptodon . guacamole . auth . jdbc . user ; import com . google . inject . Inject ; import com . google . inject . Provider ; import java . util . Arrays ; import javax . servlet . http . HttpServletRequest ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . form . Field ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . net . auth . credentials . CredentialsInfo ; import org . glyptodon . guacamole . net . auth . credentials . GuacamoleInsufficientCredentialsException ; import org . glyptodon . guacamole . net . auth . credentials . GuacamoleInvalidCredentialsException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class UserContextService { private static final Logger logger = LoggerFactory . getLogger ( UserService . class ) ; @ Inject private UserService userService ; @ Inject private Provider < UserContext > userContextProvider ; private static final String NEW_PASSWORD_PARAMETER = "new-password" ; private static final Field NEW_PASSWORD = new Field ( NEW_PASSWORD_PARAMETER , "New password" , Field . Type . PASSWORD ) ; private static final String CONFIRM_NEW_PASSWORD_PARAMETER = "confirm-new-password" ; private static final Field CONFIRM_NEW_PASSWORD = new Field ( CONFIRM_NEW_PASSWORD_PARAMETER , "Confirm new password" , Field . Type . PASSWORD ) ; private static final CredentialsInfo EXPIRED_PASSWORD = new CredentialsInfo ( Arrays . asList ( CredentialsInfo . USERNAME , CredentialsInfo . PASSWORD , NEW_PASSWORD , CONFIRM_NEW_PASSWORD ) ) ; public org . glyptodon . guacamole . net . auth . UserContext getUserContext ( Credentials credentials ) throws GuacamoleException { ModeledUser user = userService . retrieveUser ( credentials ) ; if ( user != null && ! user . getModel ( ) . isDisabled ( ) ) { if ( user . getModel ( ) . isExpired ( ) ) { HttpServletRequest request = credentials . getRequest ( ) ; String newPassword = request . getParameter ( NEW_PASSWORD_PARAMETER ) ; String confirmNewPassword = request . getParameter ( CONFIRM_NEW_PASSWORD_PARAMETER ) ; if ( newPassword == null || confirmNewPassword == null ) { logger . info ( "The password of user \"{}\" has expired and must be reset." , user . getIdentifier ( ) ) ; throw new GuacamoleInsufficientCredentialsException ( "Password expired" , EXPIRED_PASSWORD ) ; } if ( newPassword . equals ( credentials . getPassword ( ) ) ) throw new GuacamoleClientException ( "LOGIN.ERROR_PASSWORD_SAME" ) ; if ( newPassword . isEmpty ( ) ) throw new GuacamoleClientException ( "LOGIN.ERROR_PASSWORD_BLANK" ) ; if ( ! newPassword . equals ( confirmNewPassword ) ) throw new GuacamoleClientException ( "LOGIN.ERROR_PASSWORD_MISMATCH" ) ; logger . info ( "Resetting expired password of user \"{}\"." , user . getIdentifier ( ) ) ; } UserContext context = userContextProvider . get ( ) ; context . init ( user . getCurrentUser ( ) ) ; return context ; } throw new GuacamoleInvalidCredentialsException ( "Invalid login" , CredentialsInfo . USERNAME_PASSWORD ) ; } }
package org . glyptodon . guacamole . auth . jdbc . activeconnection ; import com . google . inject . Inject ; import java . util . Collection ; import java . util . Collections ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . auth . jdbc . base . RestrictedObject ; import org . glyptodon . guacamole . net . auth . ActiveConnection ; import org . glyptodon . guacamole . net . auth . Directory ; public class ActiveConnectionDirectory extends RestrictedObject implements Directory < ActiveConnection > { @ Inject private ActiveConnectionService activeConnectionService ; @ Override public ActiveConnection get ( String identifier ) throws GuacamoleException { return activeConnectionService . retrieveObject ( getCurrentUser ( ) , identifier ) ; } @ Override public Collection < ActiveConnection > getAll ( Collection < String > identifiers ) throws GuacamoleException { Collection < TrackedActiveConnection > objects = activeConnectionService . retrieveObjects ( getCurrentUser ( ) , identifiers ) ; return Collections . < ActiveConnection > unmodifiableCollection ( objects ) ; } @ Override public Set < String > getIdentifiers ( ) throws GuacamoleException { return activeConnectionService . getIdentifiers ( getCurrentUser ( ) ) ; } @ Override public void add ( ActiveConnection object ) throws GuacamoleException { activeConnectionService . createObject ( getCurrentUser ( ) , object ) ; } @ Override public void update ( ActiveConnection object ) throws GuacamoleException { TrackedActiveConnection connection = ( TrackedActiveConnection ) object ; activeConnectionService . updateObject ( getCurrentUser ( ) , connection ) ; } @ Override public void remove ( String identifier ) throws GuacamoleException { activeConnectionService . deleteObject ( getCurrentUser ( ) , identifier ) ; } }
package org . glyptodon . guacamole . auth . jdbc . activeconnection ;
package org . glyptodon . guacamole . auth . jdbc . activeconnection ; import com . google . inject . Inject ; import org . glyptodon . guacamole . auth . jdbc . permission . ObjectPermissionService ; import org . glyptodon . guacamole . auth . jdbc . permission . ObjectPermissionSet ; public class ActiveConnectionPermissionSet extends ObjectPermissionSet { @ Inject private ActiveConnectionPermissionService activeConnectionPermissionService ; @ Override protected ObjectPermissionService getObjectPermissionService ( ) { return activeConnectionPermissionService ; } }
package org . glyptodon . guacamole . auth . jdbc . activeconnection ; import java . util . Date ; import org . glyptodon . guacamole . auth . jdbc . base . RestrictedObject ; import org . glyptodon . guacamole . auth . jdbc . tunnel . ActiveConnectionRecord ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . ActiveConnection ; public class TrackedActiveConnection extends RestrictedObject implements ActiveConnection { private String identifier ; private String connectionIdentifier ; private Date startDate ; private String remoteHost ; private String username ; private GuacamoleTunnel tunnel ; public void init ( AuthenticatedUser currentUser , ActiveConnectionRecord activeConnectionRecord , boolean includeSensitiveInformation ) { super . init ( currentUser ) ; this . connectionIdentifier = activeConnectionRecord . getConnection ( ) . getIdentifier ( ) ; this . identifier = activeConnectionRecord . getUUID ( ) . toString ( ) ; this . startDate = activeConnectionRecord . getStartDate ( ) ; if ( includeSensitiveInformation ) { this . remoteHost = activeConnectionRecord . getRemoteHost ( ) ; this . tunnel = activeConnectionRecord . getTunnel ( ) ; this . username = activeConnectionRecord . getUsername ( ) ; } } @ Override public String getIdentifier ( ) { return identifier ; } @ Override public void setIdentifier ( String identifier ) { this . identifier = identifier ; } @ Override public String getConnectionIdentifier ( ) { return connectionIdentifier ; } @ Override public void setConnectionIdentifier ( String connnectionIdentifier ) { this . connectionIdentifier = connnectionIdentifier ; } @ Override public Date getStartDate ( ) { return startDate ; } @ Override public void setStartDate ( Date startDate ) { this . startDate = startDate ; } @ Override public String getRemoteHost ( ) { return remoteHost ; } @ Override public void setRemoteHost ( String remoteHost ) { this . remoteHost = remoteHost ; } @ Override public String getUsername ( ) { return username ; } @ Override public void setUsername ( String username ) { this . username = username ; } @ Override public GuacamoleTunnel getTunnel ( ) { return tunnel ; } @ Override public void setTunnel ( GuacamoleTunnel tunnel ) { this . tunnel = tunnel ; } }
package org . glyptodon . guacamole . auth . jdbc . activeconnection ; import com . google . inject . Inject ; import com . google . inject . Provider ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . Set ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . auth . jdbc . base . DirectoryObjectService ; import org . glyptodon . guacamole . auth . jdbc . tunnel . ActiveConnectionRecord ; import org . glyptodon . guacamole . auth . jdbc . tunnel . GuacamoleTunnelService ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . ActiveConnection ; public class ActiveConnectionService implements DirectoryObjectService < TrackedActiveConnection , ActiveConnection > { @ Inject private GuacamoleTunnelService tunnelService ; @ Inject private Provider < TrackedActiveConnection > trackedActiveConnectionProvider ; @ Override public TrackedActiveConnection retrieveObject ( AuthenticatedUser user , String identifier ) throws GuacamoleException { Collection < TrackedActiveConnection > objects = retrieveObjects ( user , Collections . singleton ( identifier ) ) ; if ( objects . isEmpty ( ) ) return null ; assert ( objects . size ( ) == 1 ) ; return objects . iterator ( ) . next ( ) ; } @ Override public Collection < TrackedActiveConnection > retrieveObjects ( AuthenticatedUser user , Collection < String > identifiers ) throws GuacamoleException { boolean isAdmin = user . getUser ( ) . isAdministrator ( ) ; Set < String > identifierSet = new HashSet < String > ( identifiers ) ; Collection < ActiveConnectionRecord > records = tunnelService . getActiveConnections ( user ) ; Collection < TrackedActiveConnection > activeConnections = new ArrayList < TrackedActiveConnection > ( identifiers . size ( ) ) ; for ( ActiveConnectionRecord record : records ) { if ( identifierSet . contains ( record . getUUID ( ) . toString ( ) ) ) { TrackedActiveConnection activeConnection = trackedActiveConnectionProvider . get ( ) ; activeConnection . init ( user , record , isAdmin ) ; activeConnections . add ( activeConnection ) ; } } return activeConnections ; } @ Override public void deleteObject ( AuthenticatedUser user , String identifier ) throws GuacamoleException { if ( ! user . getUser ( ) . isAdministrator ( ) ) throw new GuacamoleSecurityException ( "Permission denied." ) ; ActiveConnection activeConnection = retrieveObject ( user , identifier ) ; if ( activeConnection != null ) { GuacamoleTunnel tunnel = activeConnection . getTunnel ( ) ; if ( tunnel != null && tunnel . isOpen ( ) ) tunnel . close ( ) ; } } @ Override public Set < String > getIdentifiers ( AuthenticatedUser user ) throws GuacamoleException { Collection < ActiveConnectionRecord > records = tunnelService . getActiveConnections ( user ) ; Set < String > identifiers = new HashSet < String > ( records . size ( ) ) ; for ( ActiveConnectionRecord record : records ) identifiers . add ( record . getUUID ( ) . toString ( ) ) ; return identifiers ; } @ Override public TrackedActiveConnection createObject ( AuthenticatedUser user , ActiveConnection object ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public void updateObject ( AuthenticatedUser user , TrackedActiveConnection object ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } }
package org . glyptodon . guacamole . auth . jdbc . activeconnection ; import com . google . inject . Inject ; import com . google . inject . Provider ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . auth . jdbc . permission . AbstractPermissionService ; import org . glyptodon . guacamole . auth . jdbc . permission . ObjectPermissionService ; import org . glyptodon . guacamole . auth . jdbc . tunnel . ActiveConnectionRecord ; import org . glyptodon . guacamole . auth . jdbc . tunnel . GuacamoleTunnelService ; import org . glyptodon . guacamole . auth . jdbc . user . AuthenticatedUser ; import org . glyptodon . guacamole . auth . jdbc . user . ModeledUser ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; public class ActiveConnectionPermissionService extends AbstractPermissionService < ObjectPermissionSet , ObjectPermission > implements ObjectPermissionService { @ Inject private GuacamoleTunnelService tunnelService ; @ Inject private Provider < ActiveConnectionPermissionSet > activeConnectionPermissionSetProvider ; @ Override public ObjectPermission retrievePermission ( AuthenticatedUser user , ModeledUser targetUser , ObjectPermission . Type type , String identifier ) throws GuacamoleException { Set < ObjectPermission > permissions = retrievePermissions ( user , targetUser ) ; ObjectPermission permission = new ObjectPermission ( type , identifier ) ; if ( permissions . contains ( permission ) ) return permission ; return null ; } @ Override public Set < ObjectPermission > retrievePermissions ( AuthenticatedUser user , ModeledUser targetUser ) throws GuacamoleException { if ( canReadPermissions ( user , targetUser ) ) { boolean isAdmin = targetUser . isAdministrator ( ) ; Collection < ActiveConnectionRecord > records = tunnelService . getActiveConnections ( user ) ; Set < ObjectPermission > permissions = new HashSet < ObjectPermission > ( ) ; for ( ActiveConnectionRecord record : records ) { String identifier = record . getUUID ( ) . toString ( ) ; permissions . add ( new ObjectPermission ( ObjectPermission . Type . READ , identifier ) ) ; if ( isAdmin ) permissions . add ( new ObjectPermission ( ObjectPermission . Type . DELETE , identifier ) ) ; } return permissions ; } throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public Collection < String > retrieveAccessibleIdentifiers ( AuthenticatedUser user , ModeledUser targetUser , Collection < ObjectPermission . Type > permissionTypes , Collection < String > identifiers ) throws GuacamoleException { Set < ObjectPermission > permissions = retrievePermissions ( user , targetUser ) ; Collection < String > accessibleObjects = new ArrayList < String > ( permissions . size ( ) ) ; for ( String identifier : identifiers ) { for ( ObjectPermission . Type permissionType : permissionTypes ) { ObjectPermission permission = new ObjectPermission ( permissionType , identifier ) ; if ( permissions . contains ( permission ) ) { accessibleObjects . add ( identifier ) ; break ; } } } return accessibleObjects ; } @ Override public ObjectPermissionSet getPermissionSet ( AuthenticatedUser user , ModeledUser targetUser ) throws GuacamoleException { ActiveConnectionPermissionSet permissionSet = activeConnectionPermissionSetProvider . get ( ) ; permissionSet . init ( user , targetUser ) ; return permissionSet ; } @ Override public void createPermissions ( AuthenticatedUser user , ModeledUser targetUser , Collection < ObjectPermission > permissions ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public void deletePermissions ( AuthenticatedUser user , ModeledUser targetUser , Collection < ObjectPermission > permissions ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } }
package org . glyptodon . guacamole . auth . postgresql ;
package org . glyptodon . guacamole . auth . postgresql ; import com . google . inject . Guice ; import com . google . inject . Injector ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . AuthenticationProvider ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . auth . jdbc . JDBCAuthenticationProviderModule ; import org . glyptodon . guacamole . auth . jdbc . tunnel . BalancedGuacamoleTunnelService ; import org . glyptodon . guacamole . auth . jdbc . tunnel . GuacamoleTunnelService ; import org . glyptodon . guacamole . auth . jdbc . tunnel . MultiseatGuacamoleTunnelService ; import org . glyptodon . guacamole . auth . jdbc . tunnel . SingleSeatGuacamoleTunnelService ; import org . glyptodon . guacamole . auth . jdbc . tunnel . UnrestrictedGuacamoleTunnelService ; import org . glyptodon . guacamole . auth . jdbc . user . UserContextService ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . environment . LocalEnvironment ; public class PostgreSQLAuthenticationProvider implements AuthenticationProvider { private final Injector injector ; private Class < ? extends GuacamoleTunnelService > getSocketServiceClass ( Environment environment ) throws GuacamoleException { boolean disallowSimultaneous = environment . getProperty ( PostgreSQLGuacamoleProperties . POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS , false ) ; boolean disallowDuplicate = environment . getProperty ( PostgreSQLGuacamoleProperties . POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS , true ) ; if ( disallowSimultaneous ) { if ( disallowDuplicate ) return SingleSeatGuacamoleTunnelService . class ; else return BalancedGuacamoleTunnelService . class ; } else { if ( disallowDuplicate ) return MultiseatGuacamoleTunnelService . class ; else return UnrestrictedGuacamoleTunnelService . class ; } } public PostgreSQLAuthenticationProvider ( ) throws GuacamoleException { Environment environment = new LocalEnvironment ( ) ; injector = Guice . createInjector ( new PostgreSQLAuthenticationProviderModule ( environment ) , new JDBCAuthenticationProviderModule ( environment , getSocketServiceClass ( environment ) ) ) ; } @ Override public UserContext getUserContext ( Credentials credentials ) throws GuacamoleException { UserContextService userContextService = injector . getInstance ( UserContextService . class ) ; return userContextService . getUserContext ( credentials ) ; } @ Override public UserContext updateUserContext ( UserContext context , Credentials credentials ) throws GuacamoleException { return context ; } }
package org . glyptodon . guacamole . websocket ; import java . io . IOException ; import javax . websocket . CloseReason ; import javax . websocket . CloseReason . CloseCode ; import javax . websocket . Endpoint ; import javax . websocket . EndpointConfig ; import javax . websocket . MessageHandler ; import javax . websocket . OnClose ; import javax . websocket . OnMessage ; import javax . websocket . OnOpen ; import javax . websocket . RemoteEndpoint ; import javax . websocket . Session ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . GuacamoleWriter ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleConnectionClosedException ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public abstract class GuacamoleWebSocketTunnelEndpoint extends Endpoint { private static final int BUFFER_SIZE = 8192 ; private final Logger logger = LoggerFactory . getLogger ( GuacamoleWebSocketTunnelEndpoint . class ) ; private GuacamoleTunnel tunnel ; private void closeConnection ( Session session , GuacamoleStatus guac_status ) { try { CloseCode code = CloseReason . CloseCodes . getCloseCode ( guac_status . getWebSocketCode ( ) ) ; String message = Integer . toString ( guac_status . getGuacamoleStatusCode ( ) ) ; session . close ( new CloseReason ( code , message ) ) ; } catch ( IOException e ) { logger . debug ( "Unable to close WebSocket connection." , e ) ; } } protected abstract GuacamoleTunnel createTunnel ( Session session , EndpointConfig config ) throws GuacamoleException ; @ Override @ OnOpen public void onOpen ( final Session session , EndpointConfig config ) { try { tunnel = createTunnel ( session , config ) ; if ( tunnel == null ) { closeConnection ( session , GuacamoleStatus . RESOURCE_NOT_FOUND ) ; return ; } } catch ( GuacamoleException e ) { logger . error ( "Creation of WebSocket tunnel to guacd failed: {}" , e . getMessage ( ) ) ; logger . debug ( "Error connecting WebSocket tunnel." , e ) ; closeConnection ( session , e . getStatus ( ) ) ; return ; } session . addMessageHandler ( new MessageHandler . Whole < String > ( ) { @ Override public void onMessage ( String message ) { GuacamoleWebSocketTunnelEndpoint . this . onMessage ( message ) ; } } ) ; Thread readThread = new Thread ( ) { private final RemoteEndpoint . Basic remote = session . getBasicRemote ( ) ; @ Override public void run ( ) { StringBuilder buffer = new StringBuilder ( BUFFER_SIZE ) ; GuacamoleReader reader = tunnel . acquireReader ( ) ; char [ ] readMessage ; try { try { while ( ( readMessage = reader . read ( ) ) != null ) { buffer . append ( readMessage ) ; if ( ! reader . available ( ) || buffer . length ( ) >= BUFFER_SIZE ) { remote . sendText ( buffer . toString ( ) ) ; buffer . setLength ( 0 ) ; } } closeConnection ( session , GuacamoleStatus . SUCCESS ) ; } catch ( GuacamoleClientException e ) { logger . info ( "WebSocket connection terminated: {}" , e . getMessage ( ) ) ; logger . debug ( "WebSocket connection terminated due to client error." , e ) ; closeConnection ( session , e . getStatus ( ) ) ; } catch ( GuacamoleConnectionClosedException e ) { logger . debug ( "Connection to guacd closed." , e ) ; closeConnection ( session , GuacamoleStatus . SUCCESS ) ; } catch ( GuacamoleException e ) { logger . error ( "Connection to guacd terminated abnormally: {}" , e . getMessage ( ) ) ; logger . debug ( "Internal error during connection to guacd." , e ) ; closeConnection ( session , e . getStatus ( ) ) ; } } catch ( IOException e ) { logger . debug ( "I/O error prevents further reads." , e ) ; } } } ; readThread . start ( ) ; } @ OnMessage public void onMessage ( String message ) { GuacamoleWriter writer = tunnel . acquireWriter ( ) ; try { writer . write ( message . toCharArray ( ) ) ; } catch ( GuacamoleConnectionClosedException e ) { logger . debug ( "Connection to guacd closed." , e ) ; } catch ( GuacamoleException e ) { logger . debug ( "WebSocket tunnel write failed." , e ) ; } tunnel . releaseWriter ( ) ; } @ Override @ OnClose public void onClose ( Session session , CloseReason closeReason ) { try { if ( tunnel != null ) tunnel . close ( ) ; } catch ( GuacamoleException e ) { logger . debug ( "Unable to close WebSocket tunnel." , e ) ; } } }
package org . glyptodon . guacamole . auth . postgresql ; import com . google . inject . Binder ; import com . google . inject . Module ; import com . google . inject . name . Names ; import java . util . Properties ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . environment . Environment ; import org . mybatis . guice . datasource . helper . JdbcHelper ; public class PostgreSQLAuthenticationProviderModule implements Module { private final Properties myBatisProperties = new Properties ( ) ; private final Properties driverProperties = new Properties ( ) ; public PostgreSQLAuthenticationProviderModule ( Environment environment ) throws GuacamoleException { myBatisProperties . setProperty ( "mybatis.environment.id" , "guacamole" ) ; myBatisProperties . setProperty ( "JDBC.host" , environment . getRequiredProperty ( PostgreSQLGuacamoleProperties . POSTGRESQL_HOSTNAME ) ) ; myBatisProperties . setProperty ( "JDBC.port" , String . valueOf ( environment . getRequiredProperty ( PostgreSQLGuacamoleProperties . POSTGRESQL_PORT ) ) ) ; myBatisProperties . setProperty ( "JDBC.schema" , environment . getRequiredProperty ( PostgreSQLGuacamoleProperties . POSTGRESQL_DATABASE ) ) ; myBatisProperties . setProperty ( "JDBC.username" , environment . getRequiredProperty ( PostgreSQLGuacamoleProperties . POSTGRESQL_USERNAME ) ) ; myBatisProperties . setProperty ( "JDBC.password" , environment . getRequiredProperty ( PostgreSQLGuacamoleProperties . POSTGRESQL_PASSWORD ) ) ; myBatisProperties . setProperty ( "JDBC.autoCommit" , "false" ) ; myBatisProperties . setProperty ( "mybatis.pooled.pingEnabled" , "true" ) ; myBatisProperties . setProperty ( "mybatis.pooled.pingQuery" , "SELECT 1" ) ; driverProperties . setProperty ( "characterEncoding" , "UTF-8" ) ; } @ Override public void configure ( Binder binder ) { JdbcHelper . PostgreSQL . configure ( binder ) ; Names . bindProperties ( binder , myBatisProperties ) ; binder . bind ( Properties . class ) . annotatedWith ( Names . named ( "JDBC.driverProperties" ) ) . toInstance ( driverProperties ) ; } }
package org . glyptodon . guacamole . auth . postgresql ; import org . glyptodon . guacamole . properties . BooleanGuacamoleProperty ; import org . glyptodon . guacamole . properties . IntegerGuacamoleProperty ; import org . glyptodon . guacamole . properties . StringGuacamoleProperty ; public class PostgreSQLGuacamoleProperties { private PostgreSQLGuacamoleProperties ( ) { } public static final StringGuacamoleProperty POSTGRESQL_HOSTNAME = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "postgresql-hostname" ; } } ; public static final IntegerGuacamoleProperty POSTGRESQL_PORT = new IntegerGuacamoleProperty ( ) { @ Override public String getName ( ) { return "postgresql-port" ; } } ; public static final StringGuacamoleProperty POSTGRESQL_DATABASE = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "postgresql-database" ; } } ; public static final StringGuacamoleProperty POSTGRESQL_USERNAME = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "postgresql-username" ; } } ; public static final StringGuacamoleProperty POSTGRESQL_PASSWORD = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "postgresql-password" ; } } ; public static final BooleanGuacamoleProperty POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS = new BooleanGuacamoleProperty ( ) { @ Override public String getName ( ) { return "postgresql-disallow-simultaneous-connections" ; } } ; public static final BooleanGuacamoleProperty POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS = new BooleanGuacamoleProperty ( ) { @ Override public String getName ( ) { return "postgresql-disallow-duplicate-connections" ; } } ; }
package net . sourceforge . guacamole . net . auth . ldap ; import com . novell . ldap . LDAPAttribute ; import com . novell . ldap . LDAPConnection ; import com . novell . ldap . LDAPEntry ; import com . novell . ldap . LDAPException ; import com . novell . ldap . LDAPSearchResults ; import java . io . UnsupportedEncodingException ; import java . util . Enumeration ; import java . util . Map ; import java . util . TreeMap ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . Credentials ; import net . sourceforge . guacamole . net . auth . ldap . properties . LDAPGuacamoleProperties ; import org . glyptodon . guacamole . GuacamoleServerException ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . environment . LocalEnvironment ; import org . glyptodon . guacamole . net . auth . simple . SimpleAuthenticationProvider ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class LDAPAuthenticationProvider extends SimpleAuthenticationProvider { private Logger logger = LoggerFactory . getLogger ( LDAPAuthenticationProvider . class ) ; private final Environment environment ; public LDAPAuthenticationProvider ( ) throws GuacamoleException { environment = new LocalEnvironment ( ) ; } private static String escapeLDAPSearchFilter ( String filter ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < filter . length ( ) ; i ++ ) { char curChar = filter . charAt ( i ) ; switch ( curChar ) { case '\\' : sb . append ( "\\5c" ) ; break ; case '*' : sb . append ( "\\2a" ) ; break ; case '(' : sb . append ( "\\28" ) ; break ; case ')' : sb . append ( "\\29" ) ; break ; case '\u0000' : sb . append ( "\\00" ) ; break ; default : sb . append ( curChar ) ; } } return sb . toString ( ) ; } private static String escapeDN ( String name ) { StringBuilder sb = new StringBuilder ( ) ; if ( ( name . length ( ) > 0 ) && ( ( name . charAt ( 0 ) == ' ' ) || ( name . charAt ( 0 ) == '#' ) ) ) { sb . append ( '\\' ) ; } for ( int i = 0 ; i < name . length ( ) ; i ++ ) { char curChar = name . charAt ( i ) ; switch ( curChar ) { case '\\' : sb . append ( "\\\\" ) ; break ; case ',' : sb . append ( "\\," ) ; break ; case '+' : sb . append ( "\\+" ) ; break ; case '"' : sb . append ( "\\\"" ) ; break ; case '<' : sb . append ( "\\<" ) ; break ; case '>' : sb . append ( "\\>" ) ; break ; case ';' : sb . append ( "\\;" ) ; break ; default : sb . append ( curChar ) ; } } if ( ( name . length ( ) > 1 ) && ( name . charAt ( name . length ( ) - 1 ) == ' ' ) ) { sb . insert ( sb . length ( ) - 1 , '\\' ) ; } return sb . toString ( ) ; } @ Override public Map < String , GuacamoleConfiguration > getAuthorizedConfigurations ( Credentials credentials ) throws GuacamoleException { if ( credentials . getUsername ( ) == null ) { logger . debug ( "Anonymous bind is not currently allowed by the LDAP authentication provider." ) ; return null ; } if ( credentials . getPassword ( ) == null || credentials . getPassword ( ) . length ( ) == 0 ) { logger . debug ( "Anonymous bind is not currently allowed by the LDAP authentication provider." ) ; return null ; } LDAPConnection ldapConnection ; try { ldapConnection = new LDAPConnection ( ) ; ldapConnection . connect ( environment . getRequiredProperty ( LDAPGuacamoleProperties . LDAP_HOSTNAME ) , environment . getRequiredProperty ( LDAPGuacamoleProperties . LDAP_PORT ) ) ; } catch ( LDAPException e ) { throw new GuacamoleServerException ( "Unable to connect to LDAP server." , e ) ; } String username_attribute = environment . getRequiredProperty ( LDAPGuacamoleProperties . LDAP_USERNAME_ATTRIBUTE ) ; String user_base_dn = environment . getRequiredProperty ( LDAPGuacamoleProperties . LDAP_USER_BASE_DN ) ; String user_dn = escapeDN ( username_attribute ) + "=" + escapeDN ( credentials . getUsername ( ) ) + "," + user_base_dn ; try { try { ldapConnection . bind ( LDAPConnection . LDAP_V3 , user_dn , credentials . getPassword ( ) . getBytes ( "UTF-8" ) ) ; } catch ( UnsupportedEncodingException e ) { throw new GuacamoleException ( e ) ; } } catch ( LDAPException e ) { logger . debug ( "LDAP bind failed." , e ) ; return null ; } String config_base_dn = environment . getRequiredProperty ( LDAPGuacamoleProperties . LDAP_CONFIG_BASE_DN ) ; try { LDAPSearchResults results = ldapConnection . search ( config_base_dn , LDAPConnection . SCOPE_SUB , "(&(objectClass=guacConfigGroup)(member=" + escapeLDAPSearchFilter ( user_dn ) + "))" , null , false ) ; Map < String , GuacamoleConfiguration > configs = new TreeMap < String , GuacamoleConfiguration > ( ) ; while ( results . hasMore ( ) ) { LDAPEntry entry = results . next ( ) ; GuacamoleConfiguration config = new GuacamoleConfiguration ( ) ; LDAPAttribute cn = entry . getAttribute ( "cn" ) ; if ( cn == null ) throw new GuacamoleException ( "guacConfigGroup without cn" ) ; LDAPAttribute protocol = entry . getAttribute ( "guacConfigProtocol" ) ; if ( protocol == null ) throw new GuacamoleException ( "guacConfigGroup without guacConfigProtocol" ) ; config . setProtocol ( protocol . getStringValue ( ) ) ; LDAPAttribute parameterAttribute = entry . getAttribute ( "guacConfigParameter" ) ; if ( parameterAttribute != null ) { Enumeration < ? > parameters = parameterAttribute . getStringValues ( ) ; while ( parameters . hasMoreElements ( ) ) { String parameter = ( String ) parameters . nextElement ( ) ; int equals = parameter . indexOf ( '=' ) ; if ( equals != - 1 ) { String name = parameter . substring ( 0 , equals ) ; String value = parameter . substring ( equals + 1 ) ; config . setParameter ( name , value ) ; } } } configs . put ( cn . getStringValue ( ) , config ) ; } ldapConnection . disconnect ( ) ; return configs ; } catch ( LDAPException e ) { throw new GuacamoleServerException ( "Error while querying for connections." , e ) ; } } }
package net . sourceforge . guacamole . net . auth . ldap . properties ; import org . glyptodon . guacamole . properties . IntegerGuacamoleProperty ; import org . glyptodon . guacamole . properties . StringGuacamoleProperty ; public class LDAPGuacamoleProperties { private LDAPGuacamoleProperties ( ) { } public static final StringGuacamoleProperty LDAP_CONFIG_BASE_DN = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "ldap-config-base-dn" ; } } ; public static final StringGuacamoleProperty LDAP_USER_BASE_DN = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "ldap-user-base-dn" ; } } ; public static final StringGuacamoleProperty LDAP_USERNAME_ATTRIBUTE = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "ldap-username-attribute" ; } } ; public static final IntegerGuacamoleProperty LDAP_PORT = new IntegerGuacamoleProperty ( ) { @ Override public String getName ( ) { return "ldap-port" ; } } ; public static final StringGuacamoleProperty LDAP_HOSTNAME = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "ldap-hostname" ; } } ; }
package net . sourceforge . guacamole . net . auth . noauth ; import java . util . Map ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . io . Reader ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . environment . LocalEnvironment ; import org . glyptodon . guacamole . net . auth . simple . SimpleAuthenticationProvider ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . properties . FileGuacamoleProperty ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; import org . slf4j . LoggerFactory ; import org . slf4j . Logger ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class NoAuthenticationProvider extends SimpleAuthenticationProvider { private Logger logger = LoggerFactory . getLogger ( NoAuthenticationProvider . class ) ; private Map < String , GuacamoleConfiguration > configs ; private long configTime ; private final Environment environment ; public static final FileGuacamoleProperty NOAUTH_CONFIG = new FileGuacamoleProperty ( ) { @ Override public String getName ( ) { return "noauth-config" ; } } ; public static final String DEFAULT_NOAUTH_CONFIG = "noauth-config.xml" ; public NoAuthenticationProvider ( ) throws GuacamoleException { environment = new LocalEnvironment ( ) ; } private File getConfigurationFile ( ) throws GuacamoleException { File configFile = environment . getProperty ( NOAUTH_CONFIG ) ; if ( configFile == null ) configFile = new File ( environment . getGuacamoleHome ( ) , DEFAULT_NOAUTH_CONFIG ) ; return configFile ; } public synchronized void init ( ) throws GuacamoleException { File configFile = getConfigurationFile ( ) ; logger . debug ( "Reading configuration file: \"{}\"" , configFile ) ; try { NoAuthConfigContentHandler contentHandler = new NoAuthConfigContentHandler ( ) ; XMLReader parser = XMLReaderFactory . createXMLReader ( ) ; parser . setContentHandler ( contentHandler ) ; Reader reader = new BufferedReader ( new FileReader ( configFile ) ) ; parser . parse ( new InputSource ( reader ) ) ; reader . close ( ) ; configTime = configFile . lastModified ( ) ; configs = contentHandler . getConfigs ( ) ; } catch ( IOException e ) { throw new GuacamoleServerException ( "Error reading configuration file." , e ) ; } catch ( SAXException e ) { throw new GuacamoleServerException ( "Error parsing XML file." , e ) ; } } @ Override public Map < String , GuacamoleConfiguration > getAuthorizedConfigurations ( Credentials credentials ) throws GuacamoleException { File configFile = getConfigurationFile ( ) ; if ( configFile . exists ( ) && configTime < configFile . lastModified ( ) ) { synchronized ( this ) { if ( configFile . exists ( ) && configTime < configFile . lastModified ( ) ) { logger . debug ( "Configuration file \"{}\" has been modified." , configFile ) ; init ( ) ; } } } if ( configs == null ) throw new GuacamoleServerException ( "Configuration could not be read." ) ; return configs ; } }
package net . sourceforge . guacamole . net . auth . noauth ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . DefaultHandler ; public class NoAuthConfigContentHandler extends DefaultHandler { private Map < String , GuacamoleConfiguration > configs = new HashMap < String , GuacamoleConfiguration > ( ) ; private String current = null ; private GuacamoleConfiguration currentConfig = null ; public Map < String , GuacamoleConfiguration > getConfigs ( ) { return Collections . unmodifiableMap ( configs ) ; } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( localName . equals ( "config" ) ) { configs . put ( current , currentConfig ) ; currentConfig = null ; current = null ; } } @ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( localName . equals ( "config" ) ) { if ( current != null ) throw new SAXException ( "Configurations cannot be nested." ) ; String name = attributes . getValue ( "name" ) ; if ( name == null ) throw new SAXException ( "Each configuration must have a name." ) ; String protocol = attributes . getValue ( "protocol" ) ; if ( protocol == null ) throw new SAXException ( "Each configuration must have a protocol." ) ; current = name ; currentConfig = new GuacamoleConfiguration ( ) ; currentConfig . setProtocol ( protocol ) ; } else if ( localName . equals ( "param" ) ) { if ( currentConfig == null ) throw new SAXException ( "Parameter without corresponding configuration." ) ; currentConfig . setParameter ( attributes . getValue ( "name" ) , attributes . getValue ( "value" ) ) ; } } }
package org . glyptodon . guacamole . token ; import java . util . HashMap ; import java . util . Map ; import org . junit . Test ; import static org . junit . Assert . * ; public class TokenFilterTest { @ Test public void testFilter ( ) { TokenFilter tokenFilter = new TokenFilter ( ) ; tokenFilter . setToken ( "TOKEN_A" , "value-of-a" ) ; tokenFilter . setToken ( "TOKEN_B" , "value-of-b" ) ; assertEquals ( "$${NOPE}hellovalue-of-aworldvalue-of-b${NOT_A_TOKEN}" , tokenFilter . filter ( "$$${NOPE}hello${TOKEN_A}world${TOKEN_B}$${NOT_A_TOKEN}" ) ) ; assertEquals ( "${NOPE}hellovalue-of-aworld${TOKEN_C}" , tokenFilter . filter ( "${NOPE}hello${TOKEN_A}world${TOKEN_C}" ) ) ; } @ Test public void testFilterValues ( ) { TokenFilter tokenFilter = new TokenFilter ( ) ; tokenFilter . setToken ( "TOKEN_A" , "value-of-a" ) ; tokenFilter . setToken ( "TOKEN_B" , "value-of-b" ) ; Map < Integer , String > map = new HashMap < Integer , String > ( ) ; map . put ( 1 , "$$${NOPE}hello${TOKEN_A}world${TOKEN_B}$${NOT_A_TOKEN}" ) ; map . put ( 2 , "${NOPE}hello${TOKEN_A}world${TOKEN_C}" ) ; map . put ( 3 , null ) ; tokenFilter . filterValues ( map ) ; assertEquals ( 3 , map . size ( ) ) ; assertEquals ( "$${NOPE}hellovalue-of-aworldvalue-of-b${NOT_A_TOKEN}" , map . get ( 1 ) ) ; assertEquals ( "${NOPE}hellovalue-of-aworld${TOKEN_C}" , map . get ( 2 ) ) ; assertNull ( map . get ( 3 ) ) ; } }
package org . glyptodon . guacamole . token ; import org . glyptodon . guacamole . net . auth . Credentials ; public class StandardTokens { private static final String USERNAME_TOKEN = "GUAC_USERNAME" ; private static final String PASSWORD_TOKEN = "GUAC_PASSWORD" ; private StandardTokens ( ) { } public static void addStandardTokens ( TokenFilter filter , Credentials credentials ) { String username = credentials . getUsername ( ) ; if ( username != null ) filter . setToken ( USERNAME_TOKEN , username ) ; String password = credentials . getPassword ( ) ; if ( password != null ) filter . setToken ( PASSWORD_TOKEN , password ) ; } }
package org . glyptodon . guacamole . token ; import java . util . HashMap ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class TokenFilter { private final Pattern tokenPattern = Pattern . compile ( "(.*?)(^|.)(\\$\\{([A-Za-z0-9_]*)\\})" ) ; private static final int LEADING_TEXT_GROUP = 1 ; private static final int ESCAPE_CHAR_GROUP = 2 ; private static final int TOKEN_GROUP = 3 ; private static final int TOKEN_NAME_GROUP = 4 ; private final Map < String , String > tokenValues = new HashMap < String , String > ( ) ; public void setToken ( String name , String value ) { tokenValues . put ( name , value ) ; } public String getToken ( String name ) { return tokenValues . get ( name ) ; } public void unsetToken ( String name ) { tokenValues . remove ( name ) ; } public Map < String , String > getTokens ( ) { return tokenValues ; } public void setTokens ( Map < String , String > tokens ) { tokenValues . clear ( ) ; tokenValues . putAll ( tokens ) ; } public String filter ( String input ) { StringBuilder output = new StringBuilder ( ) ; Matcher tokenMatcher = tokenPattern . matcher ( input ) ; int endOfLastMatch = 0 ; while ( tokenMatcher . find ( ) ) { String literal = tokenMatcher . group ( LEADING_TEXT_GROUP ) ; String escape = tokenMatcher . group ( ESCAPE_CHAR_GROUP ) ; output . append ( literal ) ; if ( "$" . equals ( escape ) ) { String notToken = tokenMatcher . group ( TOKEN_GROUP ) ; output . append ( notToken ) ; } else { output . append ( escape ) ; String tokenName = tokenMatcher . group ( TOKEN_NAME_GROUP ) ; String tokenValue = getToken ( tokenName ) ; if ( tokenValue == null ) { String notToken = tokenMatcher . group ( TOKEN_GROUP ) ; output . append ( notToken ) ; } else output . append ( tokenValue ) ; } endOfLastMatch = tokenMatcher . end ( ) ; } output . append ( input . substring ( endOfLastMatch ) ) ; return output . toString ( ) ; } public void filterValues ( Map < ? , String > map ) { for ( Map . Entry < ? , String > entry : map . entrySet ( ) ) { String value = entry . getValue ( ) ; if ( value != null ) entry . setValue ( filter ( value ) ) ; } } }
package org . glyptodon . guacamole . xml ;
package org . glyptodon . guacamole . protocol ; import java . io . Serializable ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; public class GuacamoleConfiguration implements Serializable { private static final long serialVersionUID = 1L ; private String connectionID ; private String protocol ; private final Map < String , String > parameters = new HashMap < String , String > ( ) ; public GuacamoleConfiguration ( ) { } public GuacamoleConfiguration ( GuacamoleConfiguration config ) { protocol = config . getProtocol ( ) ; connectionID = config . getConnectionID ( ) ; for ( String name : config . getParameterNames ( ) ) parameters . put ( name , config . getParameter ( name ) ) ; } public String getConnectionID ( ) { return connectionID ; } public void setConnectionID ( String connectionID ) { this . connectionID = connectionID ; } public String getProtocol ( ) { return protocol ; } public void setProtocol ( String protocol ) { this . protocol = protocol ; } public String getParameter ( String name ) { return parameters . get ( name ) ; } public void setParameter ( String name , String value ) { parameters . put ( name , value ) ; } public void unsetParameter ( String name ) { parameters . remove ( name ) ; } public Set < String > getParameterNames ( ) { return Collections . unmodifiableSet ( parameters . keySet ( ) ) ; } public Map < String , String > getParameters ( ) { return parameters ; } public void setParameters ( Map < String , String > parameters ) { this . parameters . clear ( ) ; this . parameters . putAll ( parameters ) ; } }
package org . glyptodon . guacamole . xml ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public interface TagHandler { public TagHandler childElement ( String localName ) throws SAXException ; public void init ( Attributes attributes ) throws SAXException ; public void complete ( String textContent ) throws SAXException ; }
package org . glyptodon . guacamole . xml ; import java . util . Deque ; import java . util . LinkedList ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . DefaultHandler ; public class DocumentHandler extends DefaultHandler { private String rootElementName ; private TagHandler root ; private Deque < DocumentHandlerState > stack = new LinkedList < DocumentHandlerState > ( ) ; public DocumentHandler ( String rootElementName , TagHandler root ) { this . root = root ; this . rootElementName = rootElementName ; } private DocumentHandlerState getCurrentState ( ) { if ( stack . isEmpty ( ) ) return null ; return stack . getLast ( ) ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { DocumentHandlerState current = getCurrentState ( ) ; TagHandler handler ; if ( current == null ) { if ( ! localName . equals ( rootElementName ) ) throw new SAXException ( "Root element must be '" + rootElementName + "'" ) ; handler = root ; } else { TagHandler parent_handler = current . getTagHandler ( ) ; handler = parent_handler . childElement ( localName ) ; } if ( handler == null ) throw new SAXException ( "Unexpected element: '" + localName + "'" ) ; handler . init ( attributes ) ; stack . addLast ( new DocumentHandlerState ( handler ) ) ; } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { DocumentHandlerState completed = stack . removeLast ( ) ; completed . getTagHandler ( ) . complete ( completed . getTextContent ( ) . toString ( ) ) ; } @ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { DocumentHandlerState current = getCurrentState ( ) ; if ( current == null ) throw new SAXException ( "Character data not allowed outside XML document." ) ; current . getTextContent ( ) . append ( ch , start , length ) ; } private static class DocumentHandlerState { private StringBuilder textContent = new StringBuilder ( ) ; private TagHandler tagHandler ; public DocumentHandlerState ( TagHandler tagHandler ) { this . tagHandler = tagHandler ; } public StringBuilder getTextContent ( ) { return textContent ; } public TagHandler getTagHandler ( ) { return tagHandler ; } } }
package org . glyptodon . guacamole . protocols ; import java . util . ArrayList ; import java . util . Collection ; import org . glyptodon . guacamole . form . Form ; public class ProtocolInfo { private String title ; private String name ; private Collection < Form > forms ; public ProtocolInfo ( ) { this . forms = new ArrayList < Form > ( ) ; } public ProtocolInfo ( String name , String title ) { this . name = name ; this . title = title ; this . forms = new ArrayList < Form > ( ) ; } public ProtocolInfo ( String name , String title , Collection < Form > forms ) { this . name = name ; this . title = title ; this . forms = forms ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Collection < Form > getForms ( ) { return forms ; } public void setForms ( Collection < Form > forms ) { this . forms = forms ; } }
package org . glyptodon . guacamole . environment ; import java . io . File ; import java . io . FileInputStream ; import java . io . FilenameFilter ; import java . io . IOException ; import java . io . InputStream ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import org . codehaus . jackson . map . ObjectMapper ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; import org . glyptodon . guacamole . properties . GuacamoleProperty ; import org . glyptodon . guacamole . protocols . ProtocolInfo ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class LocalEnvironment implements Environment { private static final Logger logger = LoggerFactory . getLogger ( LocalEnvironment . class ) ; private static final String [ ] KNOWN_PROTOCOLS = new String [ ] { "vnc" , "rdp" , "ssh" , "telnet" } ; private final Properties properties ; private final File guacHome ; private final Map < String , ProtocolInfo > availableProtocols ; private static final ObjectMapper mapper = new ObjectMapper ( ) ; public LocalEnvironment ( ) throws GuacamoleException { guacHome = findGuacamoleHome ( ) ; properties = new Properties ( ) ; try { InputStream stream = null ; if ( ! guacHome . isDirectory ( ) ) stream = LocalEnvironment . class . getResourceAsStream ( "/guacamole.properties" ) ; else { File propertiesFile = new File ( guacHome , "guacamole.properties" ) ; if ( propertiesFile . exists ( ) ) stream = new FileInputStream ( propertiesFile ) ; } if ( stream != null ) { try { properties . load ( stream ) ; } finally { stream . close ( ) ; } } else logger . info ( "No guacamole.properties file found within GUACAMOLE_HOME or the classpath. Using defaults." ) ; } catch ( IOException e ) { throw new GuacamoleServerException ( "Error reading guacamole.properties" , e ) ; } availableProtocols = readProtocols ( ) ; } private static File findGuacamoleHome ( ) { File guacHome ; String desiredDir = System . getProperty ( "guacamole.home" ) ; if ( desiredDir == null ) desiredDir = System . getenv ( "GUACAMOLE_HOME" ) ; if ( desiredDir != null ) guacHome = new File ( desiredDir ) ; else guacHome = new File ( System . getProperty ( "user.home" ) , ".guacamole" ) ; return guacHome ; } private ProtocolInfo readProtocol ( InputStream input ) throws IOException { return mapper . readValue ( input , ProtocolInfo . class ) ; } private Map < String , ProtocolInfo > readProtocols ( ) throws GuacamoleException { Map < String , ProtocolInfo > protocols = new HashMap < String , ProtocolInfo > ( ) ; File protocol_directory = new File ( getGuacamoleHome ( ) , "protocols" ) ; if ( protocol_directory . isDirectory ( ) ) { File [ ] files = protocol_directory . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File file , String string ) { return string . endsWith ( ".json" ) ; } } ) ; if ( files == null ) { logger . error ( "Unable to read contents of \"{}\"." , protocol_directory . getAbsolutePath ( ) ) ; files = new File [ 0 ] ; } for ( File file : files ) { try { FileInputStream stream = new FileInputStream ( file ) ; ProtocolInfo protocol = readProtocol ( stream ) ; stream . close ( ) ; protocols . put ( protocol . getName ( ) , protocol ) ; } catch ( IOException e ) { logger . error ( "Unable to read connection parameter information from \"{}\": {}" , file . getAbsolutePath ( ) , e . getMessage ( ) ) ; logger . debug ( "Error reading protocol JSON." , e ) ; } } } for ( String protocol : KNOWN_PROTOCOLS ) { if ( ! protocols . containsKey ( protocol ) ) { InputStream stream = LocalEnvironment . class . getResourceAsStream ( "/org/glyptodon/guacamole/protocols/" + protocol + ".json" ) ; if ( stream != null ) { try { protocols . put ( protocol , readProtocol ( stream ) ) ; } catch ( IOException e ) { logger . error ( "Unable to read pre-defined connection parameter information for protocol \"{}\": {}" , protocol , e . getMessage ( ) ) ; logger . debug ( "Error reading pre-defined protocol JSON." , e ) ; } } } } return protocols ; } @ Override public File getGuacamoleHome ( ) { return guacHome ; } @ Override public < Type > Type getProperty ( GuacamoleProperty < Type > property ) throws GuacamoleException { return property . parseValue ( properties . getProperty ( property . getName ( ) ) ) ; } @ Override public < Type > Type getProperty ( GuacamoleProperty < Type > property , Type defaultValue ) throws GuacamoleException { Type value = getProperty ( property ) ; if ( value == null ) return defaultValue ; return value ; } @ Override public < Type > Type getRequiredProperty ( GuacamoleProperty < Type > property ) throws GuacamoleException { Type value = getProperty ( property ) ; if ( value == null ) throw new GuacamoleServerException ( "Property " + property . getName ( ) + " is required." ) ; return value ; } @ Override public Map < String , ProtocolInfo > getProtocols ( ) { return availableProtocols ; } @ Override public ProtocolInfo getProtocol ( String name ) { return availableProtocols . get ( name ) ; } }
package org . glyptodon . guacamole . environment ; import java . io . File ; import java . util . Map ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . properties . BooleanGuacamoleProperty ; import org . glyptodon . guacamole . properties . GuacamoleProperty ; import org . glyptodon . guacamole . properties . IntegerGuacamoleProperty ; import org . glyptodon . guacamole . properties . StringGuacamoleProperty ; import org . glyptodon . guacamole . protocols . ProtocolInfo ; public interface Environment { public static final StringGuacamoleProperty GUACD_HOSTNAME = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "guacd-hostname" ; } } ; public static final IntegerGuacamoleProperty GUACD_PORT = new IntegerGuacamoleProperty ( ) { @ Override public String getName ( ) { return "guacd-port" ; } } ; public static final BooleanGuacamoleProperty GUACD_SSL = new BooleanGuacamoleProperty ( ) { @ Override public String getName ( ) { return "guacd-ssl" ; } } ; public File getGuacamoleHome ( ) ; public Map < String , ProtocolInfo > getProtocols ( ) ; public ProtocolInfo getProtocol ( String name ) ; public < Type > Type getProperty ( GuacamoleProperty < Type > property ) throws GuacamoleException ; public < Type > Type getProperty ( GuacamoleProperty < Type > property , Type defaultValue ) throws GuacamoleException ; public < Type > Type getRequiredProperty ( GuacamoleProperty < Type > property ) throws GuacamoleException ; }
package org . glyptodon . guacamole . form ;
package org . glyptodon . guacamole . form ; import java . util . Collection ; import org . codehaus . jackson . map . annotate . JsonSerialize ; @ JsonSerialize ( include = JsonSerialize . Inclusion . NON_NULL ) public class Field { public static class Type { public static String TEXT = "TEXT" ; public static String USERNAME = "USERNAME" ; public static String PASSWORD = "PASSWORD" ; public static String NUMERIC = "NUMERIC" ; public static String BOOLEAN = "BOOLEAN" ; public static String ENUM = "ENUM" ; public static String MULTILINE = "MULTILINE" ; } private String name ; private String title ; private String type ; private String value ; private Collection < FieldOption > options ; public Field ( ) { } public Field ( String name , String title , String type ) { this . name = name ; this . title = title ; this . type = type ; } public Field ( String name , String title , Collection < FieldOption > options ) { this . name = name ; this . title = title ; this . type = Type . ENUM ; this . options = options ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public Collection < FieldOption > getOptions ( ) { return options ; } public void setOptions ( Collection < FieldOption > options ) { this . options = options ; } }
package org . glyptodon . guacamole . form ; import org . codehaus . jackson . map . annotate . JsonSerialize ; @ JsonSerialize ( include = JsonSerialize . Inclusion . NON_NULL ) public class FieldOption { private String value ; private String title ; public FieldOption ( ) { } public FieldOption ( String value , String title ) { this . value = value ; this . title = title ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } }
package org . glyptodon . guacamole . form ; import java . util . ArrayList ; import java . util . Collection ; import org . codehaus . jackson . map . annotate . JsonSerialize ; @ JsonSerialize ( include = JsonSerialize . Inclusion . NON_NULL ) public class Form { private String name ; private String title ; private Collection < Field > fields ; public Form ( ) { fields = new ArrayList < Field > ( ) ; } public Form ( String name , String title , Collection < Field > fields ) { this . name = name ; this . title = title ; this . fields = fields ; } public Collection < Field > getFields ( ) { return fields ; } public void setFields ( Collection < Field > fields ) { this . fields = fields ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } }
package org . glyptodon . guacamole . properties ; import java . io . File ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class GuacamoleHome { private static final Logger logger = LoggerFactory . getLogger ( GuacamoleHome . class ) ; static { logger . warn ( "GuacamoleHome is deprecated. Please use Environment instead." ) ; } private GuacamoleHome ( ) { } public static File getDirectory ( ) { File guacHome ; String desiredDir = System . getProperty ( "guacamole.home" ) ; if ( desiredDir == null ) desiredDir = System . getenv ( "GUACAMOLE_HOME" ) ; if ( desiredDir != null ) guacHome = new File ( desiredDir ) ; else guacHome = new File ( System . getProperty ( "user.home" ) , ".guacamole" ) ; return guacHome ; } }
package org . glyptodon . guacamole . protocol ;
package org . glyptodon . guacamole . properties ;
package org . glyptodon . guacamole . properties ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; public abstract class IntegerGuacamoleProperty implements GuacamoleProperty < Integer > { @ Override public Integer parseValue ( String value ) throws GuacamoleException { if ( value == null ) return null ; try { Integer integer = new Integer ( value ) ; return integer ; } catch ( NumberFormatException e ) { throw new GuacamoleServerException ( "Property \"" + getName ( ) + "\" must be an integer." , e ) ; } } }
package org . glyptodon . guacamole . properties ; import java . io . File ; import org . glyptodon . guacamole . GuacamoleException ; public abstract class FileGuacamoleProperty implements GuacamoleProperty < File > { @ Override public File parseValue ( String value ) throws GuacamoleException { if ( value == null ) return null ; return new File ( value ) ; } }
package org . glyptodon . guacamole . properties ; import org . glyptodon . guacamole . GuacamoleException ; public abstract class StringGuacamoleProperty implements GuacamoleProperty < String > { @ Override public String parseValue ( String value ) throws GuacamoleException { return value ; } }
package org . glyptodon . guacamole . properties ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; public abstract class BooleanGuacamoleProperty implements GuacamoleProperty < Boolean > { @ Override public Boolean parseValue ( String value ) throws GuacamoleException { if ( value == null ) return null ; if ( value . equalsIgnoreCase ( "true" ) ) return true ; if ( value . equalsIgnoreCase ( "false" ) ) return false ; throw new GuacamoleServerException ( "Property \"" + getName ( ) + "\" must be either \"true\" or \"false\"." ) ; } }
package org . glyptodon . guacamole . properties ; import org . glyptodon . guacamole . GuacamoleException ; public interface GuacamoleProperty < Type > { public String getName ( ) ; public Type parseValue ( String value ) throws GuacamoleException ; }
package org . glyptodon . guacamole . properties ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Properties ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class GuacamoleProperties { private static final Logger logger = LoggerFactory . getLogger ( GuacamoleProperties . class ) ; static { logger . warn ( "GuacamoleProperties is deprecated. Please use Environment instead." ) ; } private GuacamoleProperties ( ) { } public static final StringGuacamoleProperty GUACD_HOSTNAME = new StringGuacamoleProperty ( ) { @ Override public String getName ( ) { return "guacd-hostname" ; } } ; public static final IntegerGuacamoleProperty GUACD_PORT = new IntegerGuacamoleProperty ( ) { @ Override public String getName ( ) { return "guacd-port" ; } } ; public static final BooleanGuacamoleProperty GUACD_SSL = new BooleanGuacamoleProperty ( ) { @ Override public String getName ( ) { return "guacd-ssl" ; } } ; private static final Properties properties ; private static GuacamoleException exception ; static { properties = new Properties ( ) ; try { File guacHome = GuacamoleHome . getDirectory ( ) ; InputStream stream ; if ( ! guacHome . isDirectory ( ) ) { stream = GuacamoleProperties . class . getResourceAsStream ( "/guacamole.properties" ) ; if ( stream == null ) throw new IOException ( "guacamole.properties not loaded from " + guacHome + " (not a directory), and guacamole.properties could" + " not be found as a resource in the classpath." ) ; } else stream = new FileInputStream ( new File ( guacHome , "guacamole.properties" ) ) ; try { properties . load ( stream ) ; } finally { stream . close ( ) ; } } catch ( IOException e ) { exception = new GuacamoleServerException ( "Error reading guacamole.properties" , e ) ; } } public static < Type > Type getProperty ( GuacamoleProperty < Type > property ) throws GuacamoleException { if ( exception != null ) throw exception ; return property . parseValue ( properties . getProperty ( property . getName ( ) ) ) ; } public static < Type > Type getProperty ( GuacamoleProperty < Type > property , Type defaultValue ) throws GuacamoleException { Type value = getProperty ( property ) ; if ( value == null ) return defaultValue ; return value ; } public static < Type > Type getRequiredProperty ( GuacamoleProperty < Type > property ) throws GuacamoleException { Type value = getProperty ( property ) ; if ( value == null ) throw new GuacamoleServerException ( "Property " + property . getName ( ) + " is required." ) ; return value ; } }
package org . glyptodon . guacamole . properties ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; public abstract class LongGuacamoleProperty implements GuacamoleProperty < Long > { @ Override public Long parseValue ( String value ) throws GuacamoleException { if ( value == null ) return null ; try { Long longValue = new Long ( value ) ; return longValue ; } catch ( NumberFormatException e ) { throw new GuacamoleServerException ( "Property \"" + getName ( ) + "\" must be an long." , e ) ; } } }
package org . glyptodon . guacamole . net . auth ; public interface Identifiable { public String getIdentifier ( ) ; public void setIdentifier ( String identifier ) ; }
package org . glyptodon . guacamole . net . auth ;
package org . glyptodon . guacamole . protocol ; import java . util . Arrays ; import java . util . Iterator ; import java . util . List ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; public class GuacamoleParser implements Iterator < GuacamoleInstruction > { public static final int INSTRUCTION_MAX_LENGTH = 8192 ; public static final int INSTRUCTION_MAX_DIGITS = 5 ; public static final int INSTRUCTION_MAX_ELEMENTS = 64 ; private enum State { PARSING_LENGTH , PARSING_CONTENT , COMPLETE , ERROR } private GuacamoleInstruction parsedInstruction ; private State state = State . PARSING_LENGTH ; private int elementLength = 0 ; private int elementCount = 0 ; private final String elements [ ] = new String [ INSTRUCTION_MAX_ELEMENTS ] ; public int append ( char chunk [ ] , int offset , int length ) throws GuacamoleException { int charsParsed = 0 ; if ( elementCount == INSTRUCTION_MAX_ELEMENTS && state != State . COMPLETE ) { state = State . ERROR ; throw new GuacamoleServerException ( "Instruction contains too many elements." ) ; } if ( state == State . PARSING_LENGTH ) { int parsedLength = elementLength ; while ( charsParsed < length ) { char c = chunk [ offset + charsParsed ++ ] ; if ( c >= '0' && c <= '9' ) parsedLength = parsedLength * 10 + c - '0' ; else if ( c == '.' ) { state = State . PARSING_CONTENT ; break ; } else { state = State . ERROR ; throw new GuacamoleServerException ( "Non-numeric character in element length." ) ; } } if ( parsedLength > INSTRUCTION_MAX_LENGTH ) { state = State . ERROR ; throw new GuacamoleServerException ( "Instruction exceeds maximum length." ) ; } elementLength = parsedLength ; } if ( state == State . PARSING_CONTENT && charsParsed + elementLength + 1 <= length ) { String element = new String ( chunk , offset + charsParsed , elementLength ) ; charsParsed += elementLength ; elementLength = 0 ; char terminator = chunk [ offset + charsParsed ++ ] ; elements [ elementCount ++ ] = element ; if ( terminator == ';' ) { state = State . COMPLETE ; parsedInstruction = new GuacamoleInstruction ( elements [ 0 ] , Arrays . asList ( elements ) . subList ( 1 , elementCount ) ) ; } else if ( terminator == ',' ) state = State . PARSING_LENGTH ; else { state = State . ERROR ; throw new GuacamoleServerException ( "Element terminator of instruction was not ';' nor ','" ) ; } } return charsParsed ; } public int append ( char chunk [ ] ) throws GuacamoleException { return append ( chunk , 0 , chunk . length ) ; } @ Override public boolean hasNext ( ) { return state == State . COMPLETE ; } @ Override public GuacamoleInstruction next ( ) { if ( state != State . COMPLETE ) return null ; state = State . PARSING_LENGTH ; elementCount = 0 ; elementLength = 0 ; return parsedInstruction ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "GuacamoleParser does not support remove()." ) ; } }
package org . glyptodon . guacamole . net . auth ; public abstract class AbstractUser implements User { private String username ; private String password ; @ Override public String getIdentifier ( ) { return username ; } @ Override public void setIdentifier ( String username ) { this . username = username ; } @ Override public String getPassword ( ) { return password ; } @ Override public void setPassword ( String password ) { this . password = password ; } @ Override public int hashCode ( ) { if ( username == null ) return 0 ; return username . hashCode ( ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( ! ( obj instanceof AbstractUser ) ) return false ; String objUsername = ( ( AbstractUser ) obj ) . username ; if ( objUsername == null ) return username == null ; return objUsername . equals ( username ) ; } }
package org . glyptodon . guacamole . net . auth ; import java . util . List ; import java . util . Map ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; public interface Connection extends Identifiable , Connectable { public String getName ( ) ; public void setName ( String name ) ; public String getParentIdentifier ( ) ; public void setParentIdentifier ( String parentIdentifier ) ; public GuacamoleConfiguration getConfiguration ( ) ; public void setConfiguration ( GuacamoleConfiguration config ) ; Map < String , String > getAttributes ( ) ; void setAttributes ( Map < String , String > attributes ) ; public List < ? extends ConnectionRecord > getHistory ( ) throws GuacamoleException ; }
package org . glyptodon . guacamole . net . auth ; import java . util . Date ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; public abstract class AbstractActiveConnection implements ActiveConnection { private String identifier ; private String connectionIdentifier ; private Date startDate ; private String remoteHost ; private String username ; private GuacamoleTunnel tunnel ; @ Override public String getIdentifier ( ) { return identifier ; } @ Override public void setIdentifier ( String identifier ) { this . identifier = identifier ; } @ Override public String getConnectionIdentifier ( ) { return connectionIdentifier ; } @ Override public void setConnectionIdentifier ( String connnectionIdentifier ) { this . connectionIdentifier = connnectionIdentifier ; } @ Override public Date getStartDate ( ) { return startDate ; } @ Override public void setStartDate ( Date startDate ) { this . startDate = startDate ; } @ Override public String getRemoteHost ( ) { return remoteHost ; } @ Override public void setRemoteHost ( String remoteHost ) { this . remoteHost = remoteHost ; } @ Override public String getUsername ( ) { return username ; } @ Override public void setUsername ( String username ) { this . username = username ; } @ Override public GuacamoleTunnel getTunnel ( ) { return tunnel ; } @ Override public void setTunnel ( GuacamoleTunnel tunnel ) { this . tunnel = tunnel ; } }
package org . glyptodon . guacamole . net . auth ; public abstract class AbstractConnectionGroup implements ConnectionGroup { private String name ; private String identifier ; private String parentIdentifier ; private ConnectionGroup . Type type ; @ Override public String getName ( ) { return name ; } @ Override public void setName ( String name ) { this . name = name ; } @ Override public String getIdentifier ( ) { return identifier ; } @ Override public void setIdentifier ( String identifier ) { this . identifier = identifier ; } @ Override public String getParentIdentifier ( ) { return parentIdentifier ; } @ Override public void setParentIdentifier ( String parentIdentifier ) { this . parentIdentifier = parentIdentifier ; } @ Override public ConnectionGroup . Type getType ( ) { return type ; } @ Override public void setType ( ConnectionGroup . Type type ) { this . type = type ; } @ Override public int hashCode ( ) { if ( identifier == null ) return 0 ; return identifier . hashCode ( ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( ! ( obj instanceof AbstractConnectionGroup ) ) return false ; String objIdentifier = ( ( AbstractConnectionGroup ) obj ) . identifier ; if ( objIdentifier == null ) return identifier == null ; return objIdentifier . equals ( identifier ) ; } }
package org . glyptodon . guacamole . net . auth ; import java . util . Date ; public interface ConnectionRecord { public Date getStartDate ( ) ; public Date getEndDate ( ) ; public String getRemoteHost ( ) ; public String getUsername ( ) ; public boolean isActive ( ) ; }
package org . glyptodon . guacamole . net . auth ; import java . io . Serializable ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpSession ; public class Credentials implements Serializable { private static final long serialVersionUID = 1L ; private String username ; private String password ; private transient HttpServletRequest request ; private transient HttpSession session ; public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public HttpServletRequest getRequest ( ) { return request ; } public void setRequest ( HttpServletRequest request ) { this . request = request ; } public HttpSession getSession ( ) { return session ; } public void setSession ( HttpSession session ) { this . session = session ; } }
package org . glyptodon . guacamole . net . auth ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; public abstract class AbstractConnection implements Connection { private String name ; private String identifier ; private String parentIdentifier ; private GuacamoleConfiguration configuration ; @ Override public String getName ( ) { return name ; } @ Override public void setName ( String name ) { this . name = name ; } @ Override public String getIdentifier ( ) { return identifier ; } @ Override public void setIdentifier ( String identifier ) { this . identifier = identifier ; } @ Override public String getParentIdentifier ( ) { return parentIdentifier ; } @ Override public void setParentIdentifier ( String parentIdentifier ) { this . parentIdentifier = parentIdentifier ; } @ Override public GuacamoleConfiguration getConfiguration ( ) { return configuration ; } @ Override public void setConfiguration ( GuacamoleConfiguration configuration ) { this . configuration = configuration ; } @ Override public int hashCode ( ) { if ( identifier == null ) return 0 ; return identifier . hashCode ( ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( ! ( obj instanceof AbstractConnection ) ) return false ; String objIdentifier = ( ( AbstractConnection ) obj ) . identifier ; if ( objIdentifier == null ) return identifier == null ; return objIdentifier . equals ( identifier ) ; } }
package org . glyptodon . guacamole . net . auth ; import java . util . Date ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; public interface ActiveConnection extends Identifiable { String getConnectionIdentifier ( ) ; void setConnectionIdentifier ( String connnectionIdentifier ) ; Date getStartDate ( ) ; void setStartDate ( Date startDate ) ; String getRemoteHost ( ) ; void setRemoteHost ( String remoteHost ) ; String getUsername ( ) ; void setUsername ( String username ) ; GuacamoleTunnel getTunnel ( ) ; void setTunnel ( GuacamoleTunnel tunnel ) ; }
package org . glyptodon . guacamole . net . auth ; import org . glyptodon . guacamole . GuacamoleException ; public interface AuthenticationProvider { UserContext getUserContext ( Credentials credentials ) throws GuacamoleException ; UserContext updateUserContext ( UserContext context , Credentials credentials ) throws GuacamoleException ; }
package org . glyptodon . guacamole . net . auth ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . protocol . GuacamoleClientInformation ; public interface Connectable { public GuacamoleTunnel connect ( GuacamoleClientInformation info ) throws GuacamoleException ; public int getActiveConnections ( ) ; }
package org . glyptodon . guacamole . protocol ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . io . GuacamoleReader ; public class FilteredGuacamoleReader implements GuacamoleReader { private final GuacamoleReader reader ; private final GuacamoleFilter filter ; public FilteredGuacamoleReader ( GuacamoleReader reader , GuacamoleFilter filter ) { this . reader = reader ; this . filter = filter ; } @ Override public boolean available ( ) throws GuacamoleException { return reader . available ( ) ; } @ Override public char [ ] read ( ) throws GuacamoleException { GuacamoleInstruction filteredInstruction = readInstruction ( ) ; if ( filteredInstruction == null ) return null ; return filteredInstruction . toString ( ) . toCharArray ( ) ; } @ Override public GuacamoleInstruction readInstruction ( ) throws GuacamoleException { GuacamoleInstruction filteredInstruction ; do { GuacamoleInstruction unfilteredInstruction = reader . readInstruction ( ) ; if ( unfilteredInstruction == null ) return null ; filteredInstruction = filter . filter ( unfilteredInstruction ) ; } while ( filteredInstruction == null ) ; return filteredInstruction ; } }
package org . glyptodon . guacamole . net . auth ; import java . util . Map ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; public interface ConnectionGroup extends Identifiable , Connectable { public enum Type { ORGANIZATIONAL , BALANCING } ; public String getName ( ) ; public void setName ( String name ) ; public String getParentIdentifier ( ) ; public void setParentIdentifier ( String parentIdentifier ) ; public void setType ( Type type ) ; public Type getType ( ) ; public Set < String > getConnectionIdentifiers ( ) throws GuacamoleException ; public Set < String > getConnectionGroupIdentifiers ( ) throws GuacamoleException ; Map < String , String > getAttributes ( ) ; void setAttributes ( Map < String , String > attributes ) ; }
package org . glyptodon . guacamole . net . auth ; import java . util . Collection ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . form . Form ; public interface UserContext { User self ( ) ; Directory < User > getUserDirectory ( ) throws GuacamoleException ; Directory < Connection > getConnectionDirectory ( ) throws GuacamoleException ; Directory < ConnectionGroup > getConnectionGroupDirectory ( ) throws GuacamoleException ; Directory < ActiveConnection > getActiveConnectionDirectory ( ) throws GuacamoleException ; ConnectionGroup getRootConnectionGroup ( ) throws GuacamoleException ; Collection < Form > getUserAttributes ( ) ; Collection < Form > getConnectionAttributes ( ) ; Collection < Form > getConnectionGroupAttributes ( ) ; }
package org . glyptodon . guacamole . net . auth ; import java . util . Map ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . auth . permission . SystemPermissionSet ; public interface User extends Identifiable { public String getPassword ( ) ; public void setPassword ( String password ) ; Map < String , String > getAttributes ( ) ; void setAttributes ( Map < String , String > attributes ) ; SystemPermissionSet getSystemPermissions ( ) throws GuacamoleException ; ObjectPermissionSet getConnectionPermissions ( ) throws GuacamoleException ; ObjectPermissionSet getConnectionGroupPermissions ( ) throws GuacamoleException ; ObjectPermissionSet getActiveConnectionPermissions ( ) throws GuacamoleException ; ObjectPermissionSet getUserPermissions ( ) throws GuacamoleException ; }
package org . glyptodon . guacamole . net . auth ; import java . util . Collection ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; public interface Directory < ObjectType > { ObjectType get ( String identifier ) throws GuacamoleException ; Collection < ObjectType > getAll ( Collection < String > identifiers ) throws GuacamoleException ; Set < String > getIdentifiers ( ) throws GuacamoleException ; void add ( ObjectType object ) throws GuacamoleException ; void update ( ObjectType object ) throws GuacamoleException ; void remove ( String identifier ) throws GuacamoleException ; }
package org . glyptodon . guacamole . net . auth . permission ;
package org . glyptodon . guacamole . net . auth . permission ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; public interface PermissionSet < PermissionType extends Permission > { Set < PermissionType > getPermissions ( ) throws GuacamoleException ; void addPermissions ( Set < PermissionType > permissions ) throws GuacamoleException ; void removePermissions ( Set < PermissionType > permissions ) throws GuacamoleException ; }
package org . glyptodon . guacamole . net . auth . permission ; public class ObjectPermission implements Permission < ObjectPermission . Type > { public enum Type { READ , UPDATE , DELETE , ADMINISTER } private final String identifier ; private final Type type ; public ObjectPermission ( Type type , String identifier ) { this . identifier = identifier ; this . type = type ; } public String getObjectIdentifier ( ) { return identifier ; } @ Override public Type getType ( ) { return type ; } @ Override public int hashCode ( ) { int hash = 5 ; if ( identifier != null ) hash = 47 * hash + identifier . hashCode ( ) ; if ( type != null ) hash = 47 * hash + type . hashCode ( ) ; return hash ; } @ Override public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; final ObjectPermission other = ( ObjectPermission ) obj ; if ( this . type != other . type ) return false ; if ( identifier == null ) return other . identifier == null ; return identifier . equals ( other . identifier ) ; } }
package org . glyptodon . guacamole . net . auth . permission ; public class SystemPermission implements Permission < SystemPermission . Type > { public enum Type { CREATE_USER , CREATE_CONNECTION , CREATE_CONNECTION_GROUP , ADMINISTER } private Type type ; public SystemPermission ( Type type ) { this . type = type ; } @ Override public Type getType ( ) { return type ; } @ Override public int hashCode ( ) { return type . hashCode ( ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; final SystemPermission other = ( SystemPermission ) obj ; if ( type != other . type ) return false ; return true ; } }
package org . glyptodon . guacamole . net . auth . permission ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; public interface SystemPermissionSet extends PermissionSet < SystemPermission > { boolean hasPermission ( SystemPermission . Type permission ) throws GuacamoleException ; void addPermission ( SystemPermission . Type permission ) throws GuacamoleException ; void removePermission ( SystemPermission . Type permission ) throws GuacamoleException ; @ Override Set < SystemPermission > getPermissions ( ) throws GuacamoleException ; @ Override void addPermissions ( Set < SystemPermission > permissions ) throws GuacamoleException ; @ Override void removePermissions ( Set < SystemPermission > permissions ) throws GuacamoleException ; }
package org . glyptodon . guacamole . net . auth . permission ; public interface Permission < Type extends Enum > { public Type getType ( ) ; }
package org . glyptodon . guacamole . protocol ; import org . glyptodon . guacamole . GuacamoleException ; public interface GuacamoleFilter { public GuacamoleInstruction filter ( GuacamoleInstruction instruction ) throws GuacamoleException ; }
package org . glyptodon . guacamole . protocol ; import org . glyptodon . guacamole . GuacamoleException ; import static org . junit . Assert . * ; import org . junit . Test ; public class GuacamoleParserTest { private final GuacamoleParser parser = new GuacamoleParser ( ) ; @ Test public void testParser ( ) throws GuacamoleException { char buffer [ ] = "1.a,2.bc,3.def,10.helloworld;4.test,5.test2;0.;3.foo;" . toCharArray ( ) ; int offset = 0 ; int length = buffer . length ; GuacamoleInstruction instruction ; int parsed ; while ( length > 0 && ( parsed = parser . append ( buffer , offset , length ) ) != 0 ) { offset += parsed ; length -= parsed ; } assertTrue ( parser . hasNext ( ) ) ; instruction = parser . next ( ) ; assertNotNull ( instruction ) ; assertEquals ( 3 , instruction . getArgs ( ) . size ( ) ) ; assertEquals ( "a" , instruction . getOpcode ( ) ) ; assertEquals ( "bc" , instruction . getArgs ( ) . get ( 0 ) ) ; assertEquals ( "def" , instruction . getArgs ( ) . get ( 1 ) ) ; assertEquals ( "helloworld" , instruction . getArgs ( ) . get ( 2 ) ) ; while ( length > 0 && ( parsed = parser . append ( buffer , offset , length ) ) != 0 ) { offset += parsed ; length -= parsed ; } assertTrue ( parser . hasNext ( ) ) ; instruction = parser . next ( ) ; assertNotNull ( instruction ) ; assertEquals ( 1 , instruction . getArgs ( ) . size ( ) ) ; assertEquals ( "test" , instruction . getOpcode ( ) ) ; assertEquals ( "test2" , instruction . getArgs ( ) . get ( 0 ) ) ; while ( length > 0 && ( parsed = parser . append ( buffer , offset , length ) ) != 0 ) { offset += parsed ; length -= parsed ; } assertTrue ( parser . hasNext ( ) ) ; instruction = parser . next ( ) ; assertNotNull ( instruction ) ; assertEquals ( 0 , instruction . getArgs ( ) . size ( ) ) ; assertEquals ( "" , instruction . getOpcode ( ) ) ; while ( length > 0 && ( parsed = parser . append ( buffer , offset , length ) ) != 0 ) { offset += parsed ; length -= parsed ; } assertTrue ( parser . hasNext ( ) ) ; instruction = parser . next ( ) ; assertNotNull ( instruction ) ; assertEquals ( 0 , instruction . getArgs ( ) . size ( ) ) ; assertEquals ( "foo" , instruction . getOpcode ( ) ) ; while ( length > 0 && ( parsed = parser . append ( buffer , offset , length ) ) != 0 ) { offset += parsed ; length -= parsed ; } assertFalse ( parser . hasNext ( ) ) ; } }
package org . glyptodon . guacamole . net . auth . permission ; import java . util . Collection ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; public interface ObjectPermissionSet extends PermissionSet < ObjectPermission > { boolean hasPermission ( ObjectPermission . Type permission , String identifier ) throws GuacamoleException ; void addPermission ( ObjectPermission . Type permission , String identifier ) throws GuacamoleException ; void removePermission ( ObjectPermission . Type permission , String identifier ) throws GuacamoleException ; Collection < String > getAccessibleObjects ( Collection < ObjectPermission . Type > permissions , Collection < String > identifiers ) throws GuacamoleException ; @ Override Set < ObjectPermission > getPermissions ( ) throws GuacamoleException ; @ Override void addPermissions ( Set < ObjectPermission > permissions ) throws GuacamoleException ; @ Override void removePermissions ( Set < ObjectPermission > permissions ) throws GuacamoleException ; }
package org . glyptodon . guacamole . net . auth . simple ;
package org . glyptodon . guacamole . net . auth . simple ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . net . auth . AbstractUser ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; import org . glyptodon . guacamole . net . auth . permission . SystemPermissionSet ; public class SimpleUser extends AbstractUser { private final Set < ObjectPermission > connectionPermissions = new HashSet < ObjectPermission > ( ) ; private final Set < ObjectPermission > connectionGroupPermissions = new HashSet < ObjectPermission > ( ) ; public SimpleUser ( ) { } private void addReadPermissions ( Set < ObjectPermission > permissions , Collection < String > identifiers ) { for ( String identifier : identifiers ) { permissions . add ( new ObjectPermission ( ObjectPermission . Type . READ , identifier ) ) ; } } public SimpleUser ( String username , Collection < String > connectionIdentifiers , Collection < String > connectionGroupIdentifiers ) { setIdentifier ( username ) ; addReadPermissions ( connectionPermissions , connectionIdentifiers ) ; addReadPermissions ( connectionGroupPermissions , connectionGroupIdentifiers ) ; } @ Override public Map < String , String > getAttributes ( ) { return Collections . < String , String > emptyMap ( ) ; } @ Override public void setAttributes ( Map < String , String > attributes ) { } @ Override public SystemPermissionSet getSystemPermissions ( ) throws GuacamoleException { return new SimpleSystemPermissionSet ( ) ; } @ Override public ObjectPermissionSet getConnectionPermissions ( ) throws GuacamoleException { return new SimpleObjectPermissionSet ( connectionPermissions ) ; } @ Override public ObjectPermissionSet getConnectionGroupPermissions ( ) throws GuacamoleException { return new SimpleObjectPermissionSet ( connectionGroupPermissions ) ; } @ Override public ObjectPermissionSet getUserPermissions ( ) throws GuacamoleException { return new SimpleObjectPermissionSet ( ) ; } @ Override public ObjectPermissionSet getActiveConnectionPermissions ( ) throws GuacamoleException { return new SimpleObjectPermissionSet ( ) ; } }
package org . glyptodon . guacamole . net . auth . simple ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . AbstractConnectionGroup ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . protocol . GuacamoleClientInformation ; public class SimpleConnectionGroup extends AbstractConnectionGroup { private final Set < String > connectionIdentifiers ; private final Set < String > connectionGroupIdentifiers ; public SimpleConnectionGroup ( String name , String identifier , Collection < String > connectionIdentifiers , Collection < String > connectionGroupIdentifiers ) { setName ( name ) ; setIdentifier ( identifier ) ; setType ( ConnectionGroup . Type . ORGANIZATIONAL ) ; this . connectionIdentifiers = new HashSet < String > ( connectionIdentifiers ) ; this . connectionGroupIdentifiers = new HashSet < String > ( connectionGroupIdentifiers ) ; } @ Override public int getActiveConnections ( ) { return 0 ; } @ Override public Set < String > getConnectionIdentifiers ( ) { return connectionIdentifiers ; } @ Override public Set < String > getConnectionGroupIdentifiers ( ) { return connectionGroupIdentifiers ; } @ Override public Map < String , String > getAttributes ( ) { return Collections . < String , String > emptyMap ( ) ; } @ Override public void setAttributes ( Map < String , String > attributes ) { } @ Override public GuacamoleTunnel connect ( GuacamoleClientInformation info ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } }
package org . glyptodon . guacamole . net . auth . simple ; import java . util . Map ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . auth . AuthenticationProvider ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; import org . glyptodon . guacamole . token . StandardTokens ; import org . glyptodon . guacamole . token . TokenFilter ; public abstract class SimpleAuthenticationProvider implements AuthenticationProvider { public abstract Map < String , GuacamoleConfiguration > getAuthorizedConfigurations ( Credentials credentials ) throws GuacamoleException ; @ Override public UserContext getUserContext ( Credentials credentials ) throws GuacamoleException { String username = credentials . getUsername ( ) ; Map < String , GuacamoleConfiguration > configs = getAuthorizedConfigurations ( credentials ) ; if ( configs == null ) return null ; TokenFilter tokenFilter = new TokenFilter ( ) ; StandardTokens . addStandardTokens ( tokenFilter , credentials ) ; for ( GuacamoleConfiguration config : configs . values ( ) ) tokenFilter . filterValues ( config . getParameters ( ) ) ; if ( username != null && ! username . isEmpty ( ) ) return new SimpleUserContext ( username , configs ) ; else return new SimpleUserContext ( configs ) ; } @ Override public UserContext updateUserContext ( UserContext context , Credentials credentials ) throws GuacamoleException { return context ; } }
package org . glyptodon . guacamole . net . auth . simple ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Map ; import java . util . UUID ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . form . Form ; import org . glyptodon . guacamole . net . auth . ActiveConnection ; import org . glyptodon . guacamole . net . auth . Connection ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . net . auth . Directory ; import org . glyptodon . guacamole . net . auth . User ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; public class SimpleUserContext implements UserContext { private static final String ROOT_IDENTIFIER = "ROOT" ; private final User self ; private final Directory < User > userDirectory ; private final Directory < ConnectionGroup > connectionGroupDirectory ; private final Directory < Connection > connectionDirectory ; private final ConnectionGroup rootGroup ; public SimpleUserContext ( Map < String , GuacamoleConfiguration > configs ) { this ( UUID . randomUUID ( ) . toString ( ) , configs ) ; } public SimpleUserContext ( String username , Map < String , GuacamoleConfiguration > configs ) { Collection < String > connectionIdentifiers = new ArrayList < String > ( configs . size ( ) ) ; Collection < String > connectionGroupIdentifiers = Collections . singleton ( ROOT_IDENTIFIER ) ; Collection < Connection > connections = new ArrayList < Connection > ( configs . size ( ) ) ; for ( Map . Entry < String , GuacamoleConfiguration > configEntry : configs . entrySet ( ) ) { String identifier = configEntry . getKey ( ) ; GuacamoleConfiguration config = configEntry . getValue ( ) ; Connection connection = new SimpleConnection ( identifier , identifier , config ) ; connection . setParentIdentifier ( ROOT_IDENTIFIER ) ; connections . add ( connection ) ; connectionIdentifiers . add ( identifier ) ; } this . rootGroup = new SimpleConnectionGroup ( ROOT_IDENTIFIER , ROOT_IDENTIFIER , connectionIdentifiers , Collections . < String > emptyList ( ) ) ; this . self = new SimpleUser ( username , connectionIdentifiers , connectionGroupIdentifiers ) ; this . userDirectory = new SimpleUserDirectory ( self ) ; this . connectionDirectory = new SimpleConnectionDirectory ( connections ) ; this . connectionGroupDirectory = new SimpleConnectionGroupDirectory ( Collections . singleton ( this . rootGroup ) ) ; } @ Override public User self ( ) { return self ; } @ Override public Directory < User > getUserDirectory ( ) throws GuacamoleException { return userDirectory ; } @ Override public Directory < Connection > getConnectionDirectory ( ) throws GuacamoleException { return connectionDirectory ; } @ Override public Directory < ConnectionGroup > getConnectionGroupDirectory ( ) throws GuacamoleException { return connectionGroupDirectory ; } @ Override public ConnectionGroup getRootConnectionGroup ( ) throws GuacamoleException { return rootGroup ; } @ Override public Directory < ActiveConnection > getActiveConnectionDirectory ( ) throws GuacamoleException { return new SimpleDirectory < ActiveConnection > ( ) ; } @ Override public Collection < Form > getUserAttributes ( ) { return Collections . < Form > emptyList ( ) ; } @ Override public Collection < Form > getConnectionAttributes ( ) { return Collections . < Form > emptyList ( ) ; } @ Override public Collection < Form > getConnectionGroupAttributes ( ) { return Collections . < Form > emptyList ( ) ; } }
package org . glyptodon . guacamole . net . auth . simple ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . environment . LocalEnvironment ; import org . glyptodon . guacamole . net . GuacamoleSocket ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . InetGuacamoleSocket ; import org . glyptodon . guacamole . net . SSLGuacamoleSocket ; import org . glyptodon . guacamole . net . SimpleGuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . AbstractConnection ; import org . glyptodon . guacamole . net . auth . ConnectionRecord ; import org . glyptodon . guacamole . protocol . ConfiguredGuacamoleSocket ; import org . glyptodon . guacamole . protocol . GuacamoleClientInformation ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; public class SimpleConnection extends AbstractConnection { private static final String DEFAULT_GUACD_HOSTNAME = "localhost" ; private static final int DEFAULT_GUACD_PORT = 4822 ; private GuacamoleConfiguration config ; public SimpleConnection ( ) { } public SimpleConnection ( String name , String identifier , GuacamoleConfiguration config ) { setName ( name ) ; setIdentifier ( identifier ) ; setConfiguration ( config ) ; this . config = config ; } @ Override public int getActiveConnections ( ) { return 0 ; } @ Override public Map < String , String > getAttributes ( ) { return Collections . < String , String > emptyMap ( ) ; } @ Override public void setAttributes ( Map < String , String > attributes ) { } @ Override public GuacamoleTunnel connect ( GuacamoleClientInformation info ) throws GuacamoleException { Environment env = new LocalEnvironment ( ) ; String hostname = env . getProperty ( Environment . GUACD_HOSTNAME , DEFAULT_GUACD_HOSTNAME ) ; int port = env . getProperty ( Environment . GUACD_PORT , DEFAULT_GUACD_PORT ) ; GuacamoleSocket socket ; if ( env . getProperty ( Environment . GUACD_SSL , false ) ) socket = new ConfiguredGuacamoleSocket ( new SSLGuacamoleSocket ( hostname , port ) , config , info ) ; else socket = new ConfiguredGuacamoleSocket ( new InetGuacamoleSocket ( hostname , port ) , config , info ) ; return new SimpleGuacamoleTunnel ( socket ) ; } @ Override public List < ConnectionRecord > getHistory ( ) throws GuacamoleException { return Collections . < ConnectionRecord > emptyList ( ) ; } }
package org . glyptodon . guacamole . net . auth . simple ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Map ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . net . auth . Directory ; public class SimpleDirectory < ObjectType > implements Directory < ObjectType > { private Map < String , ObjectType > objects = Collections . < String , ObjectType > emptyMap ( ) ; public SimpleDirectory ( ) { } public SimpleDirectory ( Map < String , ObjectType > objects ) { this . objects = objects ; } protected void setObjects ( Map < String , ObjectType > objects ) { this . objects = objects ; } protected Map < String , ObjectType > getObjects ( ) { return objects ; } @ Override public ObjectType get ( String identifier ) throws GuacamoleException { return objects . get ( identifier ) ; } @ Override public Collection < ObjectType > getAll ( Collection < String > identifiers ) throws GuacamoleException { Collection < ObjectType > foundObjects = new ArrayList < ObjectType > ( identifiers . size ( ) ) ; for ( String identifier : identifiers ) { ObjectType object = objects . get ( identifier ) ; if ( object != null ) foundObjects . add ( object ) ; } return foundObjects ; } @ Override public Set < String > getIdentifiers ( ) throws GuacamoleException { return objects . keySet ( ) ; } @ Override public void add ( ObjectType connection ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public void update ( ObjectType connection ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public void remove ( String identifier ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } }
package org . glyptodon . guacamole . net . auth . simple ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import org . glyptodon . guacamole . net . auth . Connection ; public class SimpleConnectionDirectory extends SimpleDirectory < Connection > { private final Map < String , Connection > connections = new HashMap < String , Connection > ( ) ; public SimpleConnectionDirectory ( Collection < Connection > connections ) { for ( Connection connection : connections ) this . connections . put ( connection . getIdentifier ( ) , connection ) ; super . setObjects ( this . connections ) ; } public Connection putConnection ( Connection connection ) { return connections . put ( connection . getIdentifier ( ) , connection ) ; } public Connection removeConnection ( String identifier ) { return connections . remove ( identifier ) ; } }
package org . glyptodon . guacamole . net . auth . simple ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermission ; import org . glyptodon . guacamole . net . auth . permission . ObjectPermissionSet ; public class SimpleObjectPermissionSet implements ObjectPermissionSet { private Set < ObjectPermission > permissions = Collections . < ObjectPermission > emptySet ( ) ; public SimpleObjectPermissionSet ( ) { } public SimpleObjectPermissionSet ( Set < ObjectPermission > permissions ) { this . permissions = permissions ; } protected void setPermissions ( Set < ObjectPermission > permissions ) { this . permissions = permissions ; } @ Override public Set < ObjectPermission > getPermissions ( ) { return permissions ; } @ Override public boolean hasPermission ( ObjectPermission . Type permission , String identifier ) throws GuacamoleException { ObjectPermission objectPermission = new ObjectPermission ( permission , identifier ) ; return permissions . contains ( objectPermission ) ; } @ Override public void addPermission ( ObjectPermission . Type permission , String identifier ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public void removePermission ( ObjectPermission . Type permission , String identifier ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public Collection < String > getAccessibleObjects ( Collection < ObjectPermission . Type > permissionTypes , Collection < String > identifiers ) throws GuacamoleException { Collection < String > accessibleObjects = new ArrayList < String > ( permissions . size ( ) ) ; for ( String identifier : identifiers ) { for ( ObjectPermission . Type permissionType : permissionTypes ) { ObjectPermission permission = new ObjectPermission ( permissionType , identifier ) ; if ( permissions . contains ( permission ) ) { accessibleObjects . add ( identifier ) ; break ; } } } return accessibleObjects ; } @ Override public void addPermissions ( Set < ObjectPermission > permissions ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public void removePermissions ( Set < ObjectPermission > permissions ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } }
package org . glyptodon . guacamole . protocol ; import java . util . List ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . GuacamoleWriter ; import org . glyptodon . guacamole . net . GuacamoleSocket ; public class ConfiguredGuacamoleSocket implements GuacamoleSocket { private GuacamoleSocket socket ; private GuacamoleConfiguration config ; private String id ; private GuacamoleInstruction expect ( GuacamoleReader reader , String opcode ) throws GuacamoleException { GuacamoleInstruction instruction = reader . readInstruction ( ) ; if ( instruction == null ) throw new GuacamoleServerException ( "End of stream while waiting for \"" + opcode + "\"." ) ; if ( ! instruction . getOpcode ( ) . equals ( opcode ) ) throw new GuacamoleServerException ( "Expected \"" + opcode + "\" instruction but instead received \"" + instruction . getOpcode ( ) + "\"." ) ; return instruction ; } public ConfiguredGuacamoleSocket ( GuacamoleSocket socket , GuacamoleConfiguration config ) throws GuacamoleException { this ( socket , config , new GuacamoleClientInformation ( ) ) ; } public ConfiguredGuacamoleSocket ( GuacamoleSocket socket , GuacamoleConfiguration config , GuacamoleClientInformation info ) throws GuacamoleException { this . socket = socket ; this . config = config ; GuacamoleReader reader = socket . getReader ( ) ; GuacamoleWriter writer = socket . getWriter ( ) ; String select_arg = config . getConnectionID ( ) ; if ( select_arg == null ) select_arg = config . getProtocol ( ) ; writer . writeInstruction ( new GuacamoleInstruction ( "select" , select_arg ) ) ; GuacamoleInstruction args = expect ( reader , "args" ) ; List < String > arg_names = args . getArgs ( ) ; String [ ] arg_values = new String [ arg_names . size ( ) ] ; for ( int i = 0 ; i < arg_names . size ( ) ; i ++ ) { String arg_name = arg_names . get ( i ) ; String value = config . getParameter ( arg_name ) ; if ( value != null ) arg_values [ i ] = value ; else arg_values [ i ] = "" ; } writer . writeInstruction ( new GuacamoleInstruction ( "size" , Integer . toString ( info . getOptimalScreenWidth ( ) ) , Integer . toString ( info . getOptimalScreenHeight ( ) ) , Integer . toString ( info . getOptimalResolution ( ) ) ) ) ; writer . writeInstruction ( new GuacamoleInstruction ( "audio" , info . getAudioMimetypes ( ) . toArray ( new String [ 0 ] ) ) ) ; writer . writeInstruction ( new GuacamoleInstruction ( "video" , info . getVideoMimetypes ( ) . toArray ( new String [ 0 ] ) ) ) ; writer . writeInstruction ( new GuacamoleInstruction ( "connect" , arg_values ) ) ; GuacamoleInstruction ready = expect ( reader , "ready" ) ; List < String > ready_args = ready . getArgs ( ) ; if ( ready_args . isEmpty ( ) ) throw new GuacamoleServerException ( "No connection ID received" ) ; id = ready . getArgs ( ) . get ( 0 ) ; } public GuacamoleConfiguration getConfiguration ( ) { return config ; } public String getConnectionID ( ) { return id ; } @ Override public GuacamoleWriter getWriter ( ) { return socket . getWriter ( ) ; } @ Override public GuacamoleReader getReader ( ) { return socket . getReader ( ) ; } @ Override public void close ( ) throws GuacamoleException { socket . close ( ) ; } @ Override public boolean isOpen ( ) { return socket . isOpen ( ) ; } }
package org . glyptodon . guacamole . net . auth . simple ; import java . util . Collections ; import org . glyptodon . guacamole . net . auth . User ; public class SimpleUserDirectory extends SimpleDirectory < User > { public SimpleUserDirectory ( User user ) { super ( Collections . singletonMap ( user . getIdentifier ( ) , user ) ) ; } }
package org . glyptodon . guacamole . net . auth . simple ; import java . util . Collections ; import java . util . Set ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . net . auth . permission . SystemPermission ; import org . glyptodon . guacamole . net . auth . permission . SystemPermissionSet ; public class SimpleSystemPermissionSet implements SystemPermissionSet { private Set < SystemPermission > permissions = Collections . < SystemPermission > emptySet ( ) ; public SimpleSystemPermissionSet ( ) { } public SimpleSystemPermissionSet ( Set < SystemPermission > permissions ) { this . permissions = permissions ; } protected void setPermissions ( Set < SystemPermission > permissions ) { this . permissions = permissions ; } @ Override public Set < SystemPermission > getPermissions ( ) { return permissions ; } @ Override public boolean hasPermission ( SystemPermission . Type permission ) throws GuacamoleException { SystemPermission systemPermission = new SystemPermission ( permission ) ; return permissions . contains ( systemPermission ) ; } @ Override public void addPermission ( SystemPermission . Type permission ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public void removePermission ( SystemPermission . Type permission ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public void addPermissions ( Set < SystemPermission > permissions ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } @ Override public void removePermissions ( Set < SystemPermission > permissions ) throws GuacamoleException { throw new GuacamoleSecurityException ( "Permission denied." ) ; } }
package org . glyptodon . guacamole . net . auth . simple ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; public class SimpleConnectionGroupDirectory extends SimpleDirectory < ConnectionGroup > { private final Map < String , ConnectionGroup > connectionGroups = new HashMap < String , ConnectionGroup > ( ) ; public SimpleConnectionGroupDirectory ( Collection < ConnectionGroup > groups ) { for ( ConnectionGroup group : groups ) connectionGroups . put ( group . getIdentifier ( ) , group ) ; super . setObjects ( connectionGroups ) ; } public ConnectionGroup putConnectionGroup ( ConnectionGroup connectionGroup ) { return connectionGroups . put ( connectionGroup . getIdentifier ( ) , connectionGroup ) ; } public ConnectionGroup removeConnectionGroup ( String identifier ) { return connectionGroups . remove ( identifier ) ; } }
package org . glyptodon . guacamole . net . auth . credentials ; public class GuacamoleInvalidCredentialsException extends GuacamoleCredentialsException { public GuacamoleInvalidCredentialsException ( String message , Throwable cause , CredentialsInfo credentialsInfo ) { super ( message , cause , credentialsInfo ) ; } public GuacamoleInvalidCredentialsException ( String message , CredentialsInfo credentialsInfo ) { super ( message , credentialsInfo ) ; } public GuacamoleInvalidCredentialsException ( Throwable cause , CredentialsInfo credentialsInfo ) { super ( cause , credentialsInfo ) ; } }
package org . glyptodon . guacamole . net . auth . credentials ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import org . glyptodon . guacamole . form . Field ; public class CredentialsInfo { private final Collection < Field > fields ; public CredentialsInfo ( Collection < Field > fields ) { this . fields = fields ; } public Collection < Field > getFields ( ) { return Collections . unmodifiableCollection ( fields ) ; } public static final CredentialsInfo EMPTY = new CredentialsInfo ( Collections . < Field > emptyList ( ) ) ; public static final Field USERNAME = new Field ( "username" , "username" , Field . Type . USERNAME ) ; public static final Field PASSWORD = new Field ( "password" , "password" , Field . Type . PASSWORD ) ; public static final CredentialsInfo USERNAME_PASSWORD = new CredentialsInfo ( Arrays . asList ( USERNAME , PASSWORD ) ) ; }
package org . glyptodon . guacamole . net . auth . credentials ; import org . glyptodon . guacamole . GuacamoleSecurityException ; public class GuacamoleCredentialsException extends GuacamoleSecurityException { private final CredentialsInfo credentialsInfo ; public GuacamoleCredentialsException ( String message , Throwable cause , CredentialsInfo credentialsInfo ) { super ( message , cause ) ; this . credentialsInfo = credentialsInfo ; } public GuacamoleCredentialsException ( String message , CredentialsInfo credentialsInfo ) { super ( message ) ; this . credentialsInfo = credentialsInfo ; } public GuacamoleCredentialsException ( Throwable cause , CredentialsInfo credentialsInfo ) { super ( cause ) ; this . credentialsInfo = credentialsInfo ; } public CredentialsInfo getCredentialsInfo ( ) { return credentialsInfo ; } }
package org . glyptodon . guacamole . net . auth . credentials ; public class GuacamoleInsufficientCredentialsException extends GuacamoleCredentialsException { public GuacamoleInsufficientCredentialsException ( String message , Throwable cause , CredentialsInfo credentialsInfo ) { super ( message , cause , credentialsInfo ) ; } public GuacamoleInsufficientCredentialsException ( String message , CredentialsInfo credentialsInfo ) { super ( message , credentialsInfo ) ; } public GuacamoleInsufficientCredentialsException ( Throwable cause , CredentialsInfo credentialsInfo ) { super ( cause , credentialsInfo ) ; } }
package org . glyptodon . guacamole . net . event ;
package org . glyptodon . guacamole . net . event ; import org . glyptodon . guacamole . net . auth . Credentials ; public class AuthenticationFailureEvent implements CredentialEvent { private Credentials credentials ; public AuthenticationFailureEvent ( Credentials credentials ) { this . credentials = credentials ; } @ Override public Credentials getCredentials ( ) { return credentials ; } }
package org . glyptodon . guacamole . net . event ; import org . glyptodon . guacamole . net . auth . UserContext ; public interface UserEvent { UserContext getUserContext ( ) ; }
package org . glyptodon . guacamole . protocol ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; import org . glyptodon . guacamole . io . GuacamoleWriter ; public class FilteredGuacamoleWriter implements GuacamoleWriter { private final GuacamoleWriter writer ; private final GuacamoleFilter filter ; private final GuacamoleParser parser = new GuacamoleParser ( ) ; public FilteredGuacamoleWriter ( GuacamoleWriter writer , GuacamoleFilter filter ) { this . writer = writer ; this . filter = filter ; } @ Override public void write ( char [ ] chunk , int offset , int length ) throws GuacamoleException { while ( length > 0 ) { int parsed ; while ( ( parsed = parser . append ( chunk , offset , length ) ) != 0 ) { offset += parsed ; length -= parsed ; } if ( ! parser . hasNext ( ) ) throw new GuacamoleServerException ( "Filtered write() contained an incomplete instruction." ) ; writeInstruction ( parser . next ( ) ) ; } } @ Override public void write ( char [ ] chunk ) throws GuacamoleException { write ( chunk , 0 , chunk . length ) ; } @ Override public void writeInstruction ( GuacamoleInstruction instruction ) throws GuacamoleException { GuacamoleInstruction filteredInstruction = filter . filter ( instruction ) ; if ( filteredInstruction != null ) writer . writeInstruction ( filteredInstruction ) ; } }
package org . glyptodon . guacamole . net . event ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . net . auth . UserContext ; public class TunnelCloseEvent implements UserEvent , CredentialEvent , TunnelEvent { private UserContext context ; private Credentials credentials ; private GuacamoleTunnel tunnel ; public TunnelCloseEvent ( UserContext context , Credentials credentials , GuacamoleTunnel tunnel ) { this . context = context ; this . credentials = credentials ; this . tunnel = tunnel ; } @ Override public UserContext getUserContext ( ) { return context ; } @ Override public Credentials getCredentials ( ) { return credentials ; } @ Override public GuacamoleTunnel getTunnel ( ) { return tunnel ; } }
package org . glyptodon . guacamole . net . event ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . net . auth . UserContext ; public class AuthenticationSuccessEvent implements UserEvent , CredentialEvent { private UserContext context ; private Credentials credentials ; public AuthenticationSuccessEvent ( UserContext context , Credentials credentials ) { this . context = context ; this . credentials = credentials ; } @ Override public UserContext getUserContext ( ) { return context ; } @ Override public Credentials getCredentials ( ) { return credentials ; } }
package org . glyptodon . guacamole . net . event ; import org . glyptodon . guacamole . net . auth . Credentials ; public interface CredentialEvent { Credentials getCredentials ( ) ; }
package org . glyptodon . guacamole . net . event ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . net . auth . UserContext ; public class TunnelConnectEvent implements UserEvent , CredentialEvent , TunnelEvent { private UserContext context ; private Credentials credentials ; private GuacamoleTunnel tunnel ; public TunnelConnectEvent ( UserContext context , Credentials credentials , GuacamoleTunnel tunnel ) { this . context = context ; this . credentials = credentials ; this . tunnel = tunnel ; } @ Override public UserContext getUserContext ( ) { return context ; } @ Override public Credentials getCredentials ( ) { return credentials ; } @ Override public GuacamoleTunnel getTunnel ( ) { return tunnel ; } }
package org . glyptodon . guacamole . net . event ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; public interface TunnelEvent { GuacamoleTunnel getTunnel ( ) ; }
package org . glyptodon . guacamole . net . event . listener ;
package org . glyptodon . guacamole . net . event . listener ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . event . AuthenticationFailureEvent ; public interface AuthenticationFailureListener { void authenticationFailed ( AuthenticationFailureEvent e ) throws GuacamoleException ; }
package org . glyptodon . guacamole . net . event . listener ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . event . AuthenticationSuccessEvent ; public interface AuthenticationSuccessListener { boolean authenticationSucceeded ( AuthenticationSuccessEvent e ) throws GuacamoleException ; }
package org . glyptodon . guacamole . net . event . listener ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . event . TunnelCloseEvent ; public interface TunnelCloseListener { boolean tunnelClosed ( TunnelCloseEvent e ) throws GuacamoleException ; }
package org . glyptodon . guacamole . net . event . listener ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . event . TunnelConnectEvent ; public interface TunnelConnectListener { boolean tunnelConnected ( TunnelConnectEvent e ) throws GuacamoleException ; }
package org . glyptodon . guacamole . protocol ; public enum GuacamoleStatus { SUCCESS ( 200 , 1000 , 0x0000 ) , UNSUPPORTED ( 501 , 1011 , 0x0100 ) , SERVER_ERROR ( 500 , 1011 , 0x0200 ) , SERVER_BUSY ( 503 , 1008 , 0x0201 ) , UPSTREAM_TIMEOUT ( 504 , 1011 , 0x0202 ) , UPSTREAM_ERROR ( 502 , 1011 , 0x0203 ) , RESOURCE_NOT_FOUND ( 404 , 1002 , 0x0204 ) , RESOURCE_CONFLICT ( 409 , 1008 , 0x0205 ) , CLIENT_BAD_REQUEST ( 400 , 1002 , 0x0300 ) , CLIENT_UNAUTHORIZED ( 403 , 1008 , 0x0301 ) , CLIENT_FORBIDDEN ( 403 , 1008 , 0x0303 ) , CLIENT_TIMEOUT ( 408 , 1002 , 0x0308 ) , CLIENT_OVERRUN ( 413 , 1009 , 0x030D ) , CLIENT_BAD_TYPE ( 415 , 1003 , 0x030F ) , CLIENT_TOO_MANY ( 429 , 1008 , 0x031D ) ; private final int http_code ; private final int websocket_code ; private final int guac_code ; private GuacamoleStatus ( int http_code , int websocket_code , int guac_code ) { this . http_code = http_code ; this . websocket_code = websocket_code ; this . guac_code = guac_code ; } public int getHttpStatusCode ( ) { return http_code ; } public int getWebSocketCode ( ) { return websocket_code ; } public int getGuacamoleStatusCode ( ) { return guac_code ; } }
package org . glyptodon . guacamole . protocol ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . GuacamoleWriter ; import org . glyptodon . guacamole . net . GuacamoleSocket ; public class FilteredGuacamoleSocket implements GuacamoleSocket { private final GuacamoleSocket socket ; private final GuacamoleReader reader ; private final GuacamoleWriter writer ; public FilteredGuacamoleSocket ( GuacamoleSocket socket , GuacamoleFilter readFilter , GuacamoleFilter writeFilter ) { this . socket = socket ; if ( readFilter != null ) reader = new FilteredGuacamoleReader ( socket . getReader ( ) , readFilter ) ; else reader = socket . getReader ( ) ; if ( writeFilter != null ) writer = new FilteredGuacamoleWriter ( socket . getWriter ( ) , writeFilter ) ; else writer = socket . getWriter ( ) ; } @ Override public GuacamoleReader getReader ( ) { return reader ; } @ Override public GuacamoleWriter getWriter ( ) { return writer ; } @ Override public void close ( ) throws GuacamoleException { socket . close ( ) ; } @ Override public boolean isOpen ( ) { return socket . isOpen ( ) ; } }
package org . glyptodon . guacamole . protocol ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class GuacamoleInstruction { private String opcode ; private List < String > args ; public GuacamoleInstruction ( String opcode , String ... args ) { this . opcode = opcode ; this . args = Collections . unmodifiableList ( Arrays . asList ( args ) ) ; } public GuacamoleInstruction ( String opcode , List < String > args ) { this . opcode = opcode ; this . args = Collections . unmodifiableList ( args ) ; } public String getOpcode ( ) { return opcode ; } public List < String > getArgs ( ) { return args ; } @ Override public String toString ( ) { StringBuilder buff = new StringBuilder ( ) ; buff . append ( opcode . length ( ) ) ; buff . append ( '.' ) ; buff . append ( opcode ) ; for ( String value : args ) { buff . append ( ',' ) ; buff . append ( value . length ( ) ) ; buff . append ( '.' ) ; buff . append ( value ) ; } buff . append ( ';' ) ; return buff . toString ( ) ; } }
package org . glyptodon . guacamole . protocol ; import java . util . ArrayList ; import java . util . List ; public class GuacamoleClientInformation { private int optimalScreenWidth = 1024 ; private int optimalScreenHeight = 768 ; private int optimalResolution = 96 ; private final List < String > audioMimetypes = new ArrayList < String > ( ) ; private final List < String > videoMimetypes = new ArrayList < String > ( ) ; public int getOptimalScreenWidth ( ) { return optimalScreenWidth ; } public void setOptimalScreenWidth ( int optimalScreenWidth ) { this . optimalScreenWidth = optimalScreenWidth ; } public int getOptimalScreenHeight ( ) { return optimalScreenHeight ; } public void setOptimalScreenHeight ( int optimalScreenHeight ) { this . optimalScreenHeight = optimalScreenHeight ; } public int getOptimalResolution ( ) { return optimalResolution ; } public void setOptimalResolution ( int optimalResolution ) { this . optimalResolution = optimalResolution ; } public List < String > getAudioMimetypes ( ) { return audioMimetypes ; } public List < String > getVideoMimetypes ( ) { return videoMimetypes ; } }
package org . glyptodon . guacamole . io ;
package org . glyptodon . guacamole . io ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . protocol . GuacamoleInstruction ; public interface GuacamoleReader { public boolean available ( ) throws GuacamoleException ; public char [ ] read ( ) throws GuacamoleException ; public GuacamoleInstruction readInstruction ( ) throws GuacamoleException ; }
package org . glyptodon . guacamole . io ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . protocol . GuacamoleInstruction ; public interface GuacamoleWriter { public void write ( char [ ] chunk , int off , int len ) throws GuacamoleException ; public void write ( char [ ] chunk ) throws GuacamoleException ; public void writeInstruction ( GuacamoleInstruction instruction ) throws GuacamoleException ; }
package org . glyptodon . guacamole . io ; import java . io . IOException ; import java . io . Reader ; import java . net . SocketException ; import java . net . SocketTimeoutException ; import java . util . Deque ; import java . util . LinkedList ; import org . glyptodon . guacamole . GuacamoleConnectionClosedException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; import org . glyptodon . guacamole . GuacamoleUpstreamTimeoutException ; import org . glyptodon . guacamole . protocol . GuacamoleInstruction ; public class ReaderGuacamoleReader implements GuacamoleReader { private Reader input ; public ReaderGuacamoleReader ( Reader input ) { this . input = input ; } private int parseStart ; private char [ ] buffer = new char [ 20480 ] ; private int usedLength = 0 ; @ Override public boolean available ( ) throws GuacamoleException { try { return input . ready ( ) || usedLength != 0 ; } catch ( IOException e ) { throw new GuacamoleServerException ( e ) ; } } @ Override public char [ ] read ( ) throws GuacamoleException { try { for ( ; ; ) { int elementLength = 0 ; int i = parseStart ; while ( i < usedLength ) { char readChar = buffer [ i ++ ] ; if ( readChar >= '0' && readChar <= '9' ) elementLength = elementLength * 10 + readChar - '0' ; else if ( readChar == '.' ) { if ( i + elementLength < usedLength ) { char terminator = buffer [ i + elementLength ] ; i += elementLength + 1 ; elementLength = 0 ; parseStart = i ; if ( terminator == ';' ) { char [ ] instruction = new char [ i ] ; System . arraycopy ( buffer , 0 , instruction , 0 , i ) ; usedLength -= i ; parseStart = 0 ; System . arraycopy ( buffer , i , buffer , 0 , usedLength ) ; return instruction ; } else if ( terminator != ',' ) throw new GuacamoleServerException ( "Element terminator of instruction was not ';' nor ','" ) ; } else break ; } else throw new GuacamoleServerException ( "Non-numeric character in element length." ) ; } if ( usedLength > buffer . length / 2 ) { char [ ] biggerBuffer = new char [ buffer . length * 2 ] ; System . arraycopy ( buffer , 0 , biggerBuffer , 0 , usedLength ) ; buffer = biggerBuffer ; } int numRead = input . read ( buffer , usedLength , buffer . length - usedLength ) ; if ( numRead == - 1 ) return null ; usedLength += numRead ; } } catch ( SocketTimeoutException e ) { throw new GuacamoleUpstreamTimeoutException ( "Connection to guacd timed out." , e ) ; } catch ( SocketException e ) { throw new GuacamoleConnectionClosedException ( "Connection to guacd is closed." , e ) ; } catch ( IOException e ) { throw new GuacamoleServerException ( e ) ; } } @ Override public GuacamoleInstruction readInstruction ( ) throws GuacamoleException { char [ ] instructionBuffer = read ( ) ; if ( instructionBuffer == null ) return null ; int elementStart = 0 ; Deque < String > elements = new LinkedList < String > ( ) ; while ( elementStart < instructionBuffer . length ) { int lengthEnd = - 1 ; for ( int i = elementStart ; i < instructionBuffer . length ; i ++ ) { if ( instructionBuffer [ i ] == '.' ) { lengthEnd = i ; break ; } } if ( lengthEnd == - 1 ) throw new GuacamoleServerException ( "Read returned incomplete instruction." ) ; int length = Integer . parseInt ( new String ( instructionBuffer , elementStart , lengthEnd - elementStart ) ) ; elementStart = lengthEnd + 1 ; String element = new String ( instructionBuffer , elementStart , length ) ; elements . addLast ( element ) ; elementStart += length ; char terminator = instructionBuffer [ elementStart ] ; elementStart ++ ; if ( terminator == ';' ) break ; } String opcode = elements . removeFirst ( ) ; GuacamoleInstruction instruction = new GuacamoleInstruction ( opcode , elements . toArray ( new String [ elements . size ( ) ] ) ) ; return instruction ; } }
package org . glyptodon . guacamole . io ; import java . io . StringReader ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . protocol . GuacamoleInstruction ; import org . junit . Test ; import static org . junit . Assert . * ; public class ReaderGuacamoleReaderTest { @ Test public void testReader ( ) throws GuacamoleException { final String test = "1.a,2.bc,3.def,10.helloworld;4.test,5.test2;0.;3.foo;" ; GuacamoleReader reader = new ReaderGuacamoleReader ( new StringReader ( test ) ) ; GuacamoleInstruction instruction ; instruction = reader . readInstruction ( ) ; assertNotNull ( instruction ) ; assertEquals ( 3 , instruction . getArgs ( ) . size ( ) ) ; assertEquals ( "a" , instruction . getOpcode ( ) ) ; assertEquals ( "bc" , instruction . getArgs ( ) . get ( 0 ) ) ; assertEquals ( "def" , instruction . getArgs ( ) . get ( 1 ) ) ; assertEquals ( "helloworld" , instruction . getArgs ( ) . get ( 2 ) ) ; instruction = reader . readInstruction ( ) ; assertNotNull ( instruction ) ; assertEquals ( 1 , instruction . getArgs ( ) . size ( ) ) ; assertEquals ( "test" , instruction . getOpcode ( ) ) ; assertEquals ( "test2" , instruction . getArgs ( ) . get ( 0 ) ) ; instruction = reader . readInstruction ( ) ; assertNotNull ( instruction ) ; assertEquals ( 0 , instruction . getArgs ( ) . size ( ) ) ; assertEquals ( "" , instruction . getOpcode ( ) ) ; instruction = reader . readInstruction ( ) ; assertNotNull ( instruction ) ; assertEquals ( 0 , instruction . getArgs ( ) . size ( ) ) ; assertEquals ( "foo" , instruction . getOpcode ( ) ) ; instruction = reader . readInstruction ( ) ; assertNull ( instruction ) ; } }
package org . glyptodon . guacamole . io ; import java . io . IOException ; import java . io . Writer ; import java . net . SocketException ; import java . net . SocketTimeoutException ; import org . glyptodon . guacamole . GuacamoleConnectionClosedException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; import org . glyptodon . guacamole . GuacamoleUpstreamTimeoutException ; import org . glyptodon . guacamole . protocol . GuacamoleInstruction ; public class WriterGuacamoleWriter implements GuacamoleWriter { private Writer output ; public WriterGuacamoleWriter ( Writer output ) { this . output = output ; } @ Override public void write ( char [ ] chunk , int off , int len ) throws GuacamoleException { try { output . write ( chunk , off , len ) ; output . flush ( ) ; } catch ( SocketTimeoutException e ) { throw new GuacamoleUpstreamTimeoutException ( "Connection to guacd timed out." , e ) ; } catch ( SocketException e ) { throw new GuacamoleConnectionClosedException ( "Connection to guacd is closed." , e ) ; } catch ( IOException e ) { throw new GuacamoleServerException ( e ) ; } } @ Override public void write ( char [ ] chunk ) throws GuacamoleException { write ( chunk , 0 , chunk . length ) ; } @ Override public void writeInstruction ( GuacamoleInstruction instruction ) throws GuacamoleException { write ( instruction . toString ( ) . toCharArray ( ) ) ; } }
package org . glyptodon . guacamole . net ;
package org . glyptodon . guacamole . net ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . GuacamoleWriter ; public interface GuacamoleSocket { public GuacamoleReader getReader ( ) ; public GuacamoleWriter getWriter ( ) ; public void close ( ) throws GuacamoleException ; public boolean isOpen ( ) ; }
package org . glyptodon . guacamole . net ; import java . util . concurrent . locks . ReentrantLock ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . GuacamoleWriter ; public abstract class AbstractGuacamoleTunnel implements GuacamoleTunnel { private final ReentrantLock readerLock ; private final ReentrantLock writerLock ; public AbstractGuacamoleTunnel ( ) { readerLock = new ReentrantLock ( ) ; writerLock = new ReentrantLock ( ) ; } @ Override public GuacamoleReader acquireReader ( ) { readerLock . lock ( ) ; return getSocket ( ) . getReader ( ) ; } @ Override public void releaseReader ( ) { readerLock . unlock ( ) ; } @ Override public boolean hasQueuedReaderThreads ( ) { return readerLock . hasQueuedThreads ( ) ; } @ Override public GuacamoleWriter acquireWriter ( ) { writerLock . lock ( ) ; return getSocket ( ) . getWriter ( ) ; } @ Override public void releaseWriter ( ) { writerLock . unlock ( ) ; } @ Override public boolean hasQueuedWriterThreads ( ) { return writerLock . hasQueuedThreads ( ) ; } @ Override public void close ( ) throws GuacamoleException { getSocket ( ) . close ( ) ; } @ Override public boolean isOpen ( ) { return getSocket ( ) . isOpen ( ) ; } }
package org . glyptodon . guacamole . net ; import java . util . UUID ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . GuacamoleWriter ; public interface GuacamoleTunnel { GuacamoleReader acquireReader ( ) ; void releaseReader ( ) ; boolean hasQueuedReaderThreads ( ) ; GuacamoleWriter acquireWriter ( ) ; void releaseWriter ( ) ; boolean hasQueuedWriterThreads ( ) ; UUID getUUID ( ) ; GuacamoleSocket getSocket ( ) ; void close ( ) throws GuacamoleException ; boolean isOpen ( ) ; }
package org . glyptodon . guacamole . net ; import java . util . UUID ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . GuacamoleWriter ; public class DelegatingGuacamoleTunnel implements GuacamoleTunnel { private final GuacamoleTunnel tunnel ; public DelegatingGuacamoleTunnel ( GuacamoleTunnel tunnel ) { this . tunnel = tunnel ; } @ Override public GuacamoleReader acquireReader ( ) { return tunnel . acquireReader ( ) ; } @ Override public void releaseReader ( ) { tunnel . releaseReader ( ) ; } @ Override public boolean hasQueuedReaderThreads ( ) { return tunnel . hasQueuedReaderThreads ( ) ; } @ Override public GuacamoleWriter acquireWriter ( ) { return tunnel . acquireWriter ( ) ; } @ Override public void releaseWriter ( ) { tunnel . releaseWriter ( ) ; } @ Override public boolean hasQueuedWriterThreads ( ) { return tunnel . hasQueuedWriterThreads ( ) ; } @ Override public UUID getUUID ( ) { return tunnel . getUUID ( ) ; } @ Override public GuacamoleSocket getSocket ( ) { return tunnel . getSocket ( ) ; } @ Override public void close ( ) throws GuacamoleException { tunnel . close ( ) ; } @ Override public boolean isOpen ( ) { return tunnel . isOpen ( ) ; } }
package org . glyptodon . guacamole . net ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . ReaderGuacamoleReader ; import org . glyptodon . guacamole . io . WriterGuacamoleWriter ; import org . glyptodon . guacamole . io . GuacamoleWriter ; import java . io . IOException ; import java . net . InetAddress ; import java . net . Socket ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . net . SocketTimeoutException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; import org . glyptodon . guacamole . GuacamoleUpstreamTimeoutException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class InetGuacamoleSocket implements GuacamoleSocket { private Logger logger = LoggerFactory . getLogger ( InetGuacamoleSocket . class ) ; private GuacamoleReader reader ; private GuacamoleWriter writer ; private static final int SOCKET_TIMEOUT = 15000 ; private Socket sock ; public InetGuacamoleSocket ( String hostname , int port ) throws GuacamoleException { try { logger . debug ( "Connecting to guacd at {}:{}." , hostname , port ) ; SocketAddress address = new InetSocketAddress ( InetAddress . getByName ( hostname ) , port ) ; sock = new Socket ( ) ; sock . connect ( address , SOCKET_TIMEOUT ) ; sock . setSoTimeout ( SOCKET_TIMEOUT ) ; reader = new ReaderGuacamoleReader ( new InputStreamReader ( sock . getInputStream ( ) , "UTF-8" ) ) ; writer = new WriterGuacamoleWriter ( new OutputStreamWriter ( sock . getOutputStream ( ) , "UTF-8" ) ) ; } catch ( SocketTimeoutException e ) { throw new GuacamoleUpstreamTimeoutException ( "Connection timed out." , e ) ; } catch ( IOException e ) { throw new GuacamoleServerException ( e ) ; } } @ Override public void close ( ) throws GuacamoleException { try { logger . debug ( "Closing socket to guacd." ) ; sock . close ( ) ; } catch ( IOException e ) { throw new GuacamoleServerException ( e ) ; } } @ Override public GuacamoleReader getReader ( ) { return reader ; } @ Override public GuacamoleWriter getWriter ( ) { return writer ; } @ Override public boolean isOpen ( ) { return ! sock . isClosed ( ) ; } }
package org . glyptodon . guacamole . net ; import java . util . UUID ; public class SimpleGuacamoleTunnel extends AbstractGuacamoleTunnel { private final UUID uuid = UUID . randomUUID ( ) ; private final GuacamoleSocket socket ; public SimpleGuacamoleTunnel ( GuacamoleSocket socket ) { this . socket = socket ; } @ Override public UUID getUUID ( ) { return uuid ; } @ Override public GuacamoleSocket getSocket ( ) { return socket ; } }
package org . glyptodon . guacamole . net ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . Socket ; import java . net . SocketAddress ; import javax . net . SocketFactory ; import javax . net . ssl . SSLSocketFactory ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleServerException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . GuacamoleWriter ; import org . glyptodon . guacamole . io . ReaderGuacamoleReader ; import org . glyptodon . guacamole . io . WriterGuacamoleWriter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class SSLGuacamoleSocket implements GuacamoleSocket { private Logger logger = LoggerFactory . getLogger ( SSLGuacamoleSocket . class ) ; private GuacamoleReader reader ; private GuacamoleWriter writer ; private static final int SOCKET_TIMEOUT = 15000 ; private Socket sock ; public SSLGuacamoleSocket ( String hostname , int port ) throws GuacamoleException { SocketFactory socket_factory = SSLSocketFactory . getDefault ( ) ; try { logger . debug ( "Connecting to guacd at {}:{} via SSL/TLS." , hostname , port ) ; SocketAddress address = new InetSocketAddress ( InetAddress . getByName ( hostname ) , port ) ; sock = socket_factory . createSocket ( ) ; sock . connect ( address , SOCKET_TIMEOUT ) ; sock . setSoTimeout ( SOCKET_TIMEOUT ) ; reader = new ReaderGuacamoleReader ( new InputStreamReader ( sock . getInputStream ( ) , "UTF-8" ) ) ; writer = new WriterGuacamoleWriter ( new OutputStreamWriter ( sock . getOutputStream ( ) , "UTF-8" ) ) ; } catch ( IOException e ) { throw new GuacamoleServerException ( e ) ; } } @ Override public void close ( ) throws GuacamoleException { try { logger . debug ( "Closing socket to guacd." ) ; sock . close ( ) ; } catch ( IOException e ) { throw new GuacamoleServerException ( e ) ; } } @ Override public GuacamoleReader getReader ( ) { return reader ; } @ Override public GuacamoleWriter getWriter ( ) { return writer ; } @ Override public boolean isOpen ( ) { return ! sock . isClosed ( ) ; } }
import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpSession ; import net . sourceforge . guacamole . GuacamoleException ; import net . sourceforge . guacamole . properties . GuacamoleProperties ; import net . sourceforge . guacamole . net . GuacamoleSocket ; import net . sourceforge . guacamole . net . GuacamoleTunnel ; import net . sourceforge . guacamole . net . InetGuacamoleSocket ; import net . sourceforge . guacamole . protocol . GuacamoleConfiguration ; import net . sourceforge . guacamole . protocol . ConfiguredGuacamoleSocket ; import net . sourceforge . guacamole . servlet . GuacamoleSession ; import net . sourceforge . guacamole . servlet . GuacamoleHTTPTunnelServlet ; public class ExampleTunnelServlet extends GuacamoleHTTPTunnelServlet { @ Override protected GuacamoleTunnel doConnect ( HttpServletRequest request ) throws GuacamoleException { HttpSession httpSession = request . getSession ( true ) ; String hostname = GuacamoleProperties . getProperty ( GuacamoleProperties . GUACD_HOSTNAME ) ; int port = GuacamoleProperties . getProperty ( GuacamoleProperties . GUACD_PORT ) ; GuacamoleConfiguration config = new GuacamoleConfiguration ( ) ; config . setProtocol ( "vnc" ) ; config . setParameter ( "hostname" , "localhost" ) ; config . setParameter ( "port" , "5901" ) ; config . setParameter ( "password" , "potato" ) ; GuacamoleSocket socket = new ConfiguredGuacamoleSocket ( new InetGuacamoleSocket ( hostname , port ) , config ) ; GuacamoleTunnel tunnel = new GuacamoleTunnel ( socket ) ; GuacamoleSession session = new GuacamoleSession ( httpSession ) ; session . attachTunnel ( tunnel ) ; return tunnel ; } }
package org . glyptodon . guacamole ;
package org . glyptodon . guacamole . net . basic ;
package org . glyptodon . guacamole . net . basic ; import com . google . inject . Guice ; import com . google . inject . Injector ; import com . google . inject . Stage ; import com . google . inject . servlet . GuiceServletContextListener ; import javax . servlet . ServletContextEvent ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . environment . LocalEnvironment ; import org . glyptodon . guacamole . net . basic . extension . ExtensionModule ; import org . glyptodon . guacamole . net . basic . log . LogModule ; import org . glyptodon . guacamole . net . basic . rest . RESTAuthModule ; import org . glyptodon . guacamole . net . basic . rest . RESTServletModule ; import org . glyptodon . guacamole . net . basic . rest . auth . BasicTokenSessionMap ; import org . glyptodon . guacamole . net . basic . rest . auth . TokenSessionMap ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class BasicServletContextListener extends GuiceServletContextListener { private final Logger logger = LoggerFactory . getLogger ( BasicServletContextListener . class ) ; private Environment environment ; private TokenSessionMap sessionMap ; @ Override public void contextInitialized ( ServletContextEvent servletContextEvent ) { try { environment = new LocalEnvironment ( ) ; sessionMap = new BasicTokenSessionMap ( environment ) ; } catch ( GuacamoleException e ) { logger . error ( "Unable to read guacamole.properties: {}" , e . getMessage ( ) ) ; logger . debug ( "Error reading guacamole.properties." , e ) ; throw new RuntimeException ( e ) ; } super . contextInitialized ( servletContextEvent ) ; } @ Override protected Injector getInjector ( ) { return Guice . createInjector ( Stage . PRODUCTION , new EnvironmentModule ( environment ) , new LogModule ( environment ) , new ExtensionModule ( environment ) , new RESTAuthModule ( sessionMap ) , new RESTServletModule ( ) , new TunnelModule ( ) ) ; } @ Override public void contextDestroyed ( ServletContextEvent servletContextEvent ) { super . contextDestroyed ( servletContextEvent ) ; if ( sessionMap != null ) sessionMap . shutdown ( ) ; } }
package org . glyptodon . guacamole . net . basic ; import com . google . inject . Inject ; import com . google . inject . Singleton ; import org . glyptodon . guacamole . net . basic . rest . clipboard . ClipboardRESTService ; import java . util . List ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleSecurityException ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . net . DelegatingGuacamoleTunnel ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . Connection ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . net . auth . Directory ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . net . basic . rest . auth . AuthenticationService ; import org . glyptodon . guacamole . protocol . GuacamoleClientInformation ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; @ Singleton public class TunnelRequestService { @ Inject private Environment environment ; private final Logger logger = LoggerFactory . getLogger ( TunnelRequestService . class ) ; @ Inject private AuthenticationService authenticationService ; protected GuacamoleClientInformation getClientInformation ( TunnelRequest request ) { GuacamoleClientInformation info = new GuacamoleClientInformation ( ) ; String width = request . getParameter ( "width" ) ; if ( width != null ) info . setOptimalScreenWidth ( Integer . parseInt ( width ) ) ; String height = request . getParameter ( "height" ) ; if ( height != null ) info . setOptimalScreenHeight ( Integer . parseInt ( height ) ) ; String dpi = request . getParameter ( "dpi" ) ; if ( dpi != null ) info . setOptimalResolution ( Integer . parseInt ( dpi ) ) ; List < String > audio_mimetypes = request . getParameterValues ( "audio" ) ; if ( audio_mimetypes != null ) info . getAudioMimetypes ( ) . addAll ( audio_mimetypes ) ; List < String > video_mimetypes = request . getParameterValues ( "video" ) ; if ( video_mimetypes != null ) info . getVideoMimetypes ( ) . addAll ( video_mimetypes ) ; return info ; } protected GuacamoleTunnel createConnectedTunnel ( UserContext context , String id , GuacamoleClientInformation info ) throws GuacamoleException { TunnelRequest . IdentifierType id_type = TunnelRequest . IdentifierType . getType ( id ) ; if ( id_type == null ) throw new GuacamoleClientException ( "Illegal identifier - unknown type." ) ; id = id . substring ( id_type . PREFIX . length ( ) ) ; GuacamoleTunnel tunnel ; switch ( id_type ) { case CONNECTION : { Directory < Connection > directory = context . getConnectionDirectory ( ) ; Connection connection = directory . get ( id ) ; if ( connection == null ) { logger . info ( "Connection \"{}\" does not exist for user \"{}\"." , id , context . self ( ) . getIdentifier ( ) ) ; throw new GuacamoleSecurityException ( "Requested connection is not authorized." ) ; } tunnel = connection . connect ( info ) ; logger . info ( "User \"{}\" successfully connected to \"{}\"." , context . self ( ) . getIdentifier ( ) , id ) ; break ; } case CONNECTION_GROUP : { Directory < ConnectionGroup > directory = context . getConnectionGroupDirectory ( ) ; ConnectionGroup group = directory . get ( id ) ; if ( group == null ) { logger . info ( "Connection group \"{}\" does not exist for user \"{}\"." , id , context . self ( ) . getIdentifier ( ) ) ; throw new GuacamoleSecurityException ( "Requested connection group is not authorized." ) ; } tunnel = group . connect ( info ) ; logger . info ( "User \"{}\" successfully connected to group \"{}\"." , context . self ( ) . getIdentifier ( ) , id ) ; break ; } default : throw new GuacamoleClientException ( "Connection not supported for provided identifier type." ) ; } return tunnel ; } protected GuacamoleTunnel createAssociatedTunnel ( final GuacamoleSession session , GuacamoleTunnel tunnel ) throws GuacamoleException { GuacamoleTunnel monitoredTunnel = new DelegatingGuacamoleTunnel ( tunnel ) { @ Override public GuacamoleReader acquireReader ( ) { try { if ( environment . getProperty ( ClipboardRESTService . INTEGRATION_ENABLED , false ) ) { ClipboardState clipboard = session . getClipboardState ( ) ; return new MonitoringGuacamoleReader ( clipboard , super . acquireReader ( ) ) ; } } catch ( GuacamoleException e ) { logger . warn ( "Clipboard integration failed to initialize: {}" , e . getMessage ( ) ) ; logger . debug ( "Error setting up clipboard integration." , e ) ; } return super . acquireReader ( ) ; } @ Override public void close ( ) throws GuacamoleException { session . removeTunnel ( getUUID ( ) . toString ( ) ) ; super . close ( ) ; } } ; session . addTunnel ( monitoredTunnel ) ; return monitoredTunnel ; } public GuacamoleTunnel createTunnel ( TunnelRequest request ) throws GuacamoleException { final String authToken = request . getParameter ( "authToken" ) ; final GuacamoleSession session = authenticationService . getGuacamoleSession ( authToken ) ; final String id = request . getParameter ( "id" ) ; final GuacamoleClientInformation info = getClientInformation ( request ) ; final GuacamoleTunnel tunnel = createConnectedTunnel ( session . getUserContext ( ) , id , info ) ; return createAssociatedTunnel ( session , tunnel ) ; } }
package org . glyptodon . guacamole . net . basic ; import com . google . inject . Inject ; import com . google . inject . Singleton ; import javax . servlet . http . HttpServletRequest ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . servlet . GuacamoleHTTPTunnelServlet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; @ Singleton public class BasicGuacamoleTunnelServlet extends GuacamoleHTTPTunnelServlet { @ Inject private TunnelRequestService tunnelRequestService ; private static final Logger logger = LoggerFactory . getLogger ( BasicGuacamoleTunnelServlet . class ) ; @ Override protected GuacamoleTunnel doConnect ( HttpServletRequest request ) throws GuacamoleException { GuacamoleTunnel tunnel = tunnelRequestService . createTunnel ( new HTTPTunnelRequest ( request ) ) ; logger . info ( "Using HTTP tunnel (not WebSocket). Performance may be sub-optimal." ) ; return tunnel ; } }
package org . glyptodon . guacamole . net . basic ; import java . util . Arrays ; import java . util . List ; import javax . servlet . http . HttpServletRequest ; public class HTTPTunnelRequest implements TunnelRequest { private final HttpServletRequest request ; public HTTPTunnelRequest ( HttpServletRequest request ) { this . request = request ; } @ Override public String getParameter ( String name ) { return request . getParameter ( name ) ; } @ Override public List < String > getParameterValues ( String name ) { String [ ] values = request . getParameterValues ( name ) ; if ( values == null ) return null ; return Arrays . asList ( values ) ; } }
package org . glyptodon . guacamole . net . basic ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . auth . Credentials ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . net . basic . properties . BasicGuacamoleProperties ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class GuacamoleSession { private static final Logger logger = LoggerFactory . getLogger ( GuacamoleSession . class ) ; private Credentials credentials ; private UserContext userContext ; private final ClipboardState clipboardState = new ClipboardState ( ) ; private final Map < String , GuacamoleTunnel > tunnels = new ConcurrentHashMap < String , GuacamoleTunnel > ( ) ; private long lastAccessedTime ; public GuacamoleSession ( Environment environment , Credentials credentials , UserContext userContext ) throws GuacamoleException { this . lastAccessedTime = System . currentTimeMillis ( ) ; this . credentials = credentials ; this . userContext = userContext ; } public Credentials getCredentials ( ) { return credentials ; } public void setCredentials ( Credentials credentials ) { this . credentials = credentials ; } public UserContext getUserContext ( ) { return userContext ; } public void setUserContext ( UserContext userContext ) { this . userContext = userContext ; } public ClipboardState getClipboardState ( ) { return clipboardState ; } public boolean hasTunnels ( ) { return ! tunnels . isEmpty ( ) ; } public Map < String , GuacamoleTunnel > getTunnels ( ) { return tunnels ; } public void addTunnel ( GuacamoleTunnel tunnel ) { tunnels . put ( tunnel . getUUID ( ) . toString ( ) , tunnel ) ; } public boolean removeTunnel ( String uuid ) { return tunnels . remove ( uuid ) != null ; } public void access ( ) { lastAccessedTime = System . currentTimeMillis ( ) ; } public long getLastAccessedTime ( ) { return lastAccessedTime ; } public void invalidate ( ) { for ( GuacamoleTunnel tunnel : tunnels . values ( ) ) { try { tunnel . close ( ) ; } catch ( GuacamoleException e ) { logger . debug ( "Unable to close tunnel." , e ) ; } } } }
package org . glyptodon . guacamole . net . basic ; import com . google . inject . AbstractModule ; import org . glyptodon . guacamole . environment . Environment ; public class EnvironmentModule extends AbstractModule { private final Environment environment ; public EnvironmentModule ( Environment environment ) { this . environment = environment ; } @ Override protected void configure ( ) { bind ( Environment . class ) . toInstance ( environment ) ; } }
package org . glyptodon . guacamole . net . basic ; import java . util . List ; public interface TunnelRequest { public static enum IdentifierType { CONNECTION ( "c/" ) , CONNECTION_GROUP ( "g/" ) ; final String PREFIX ; IdentifierType ( String prefix ) { PREFIX = prefix ; } static IdentifierType getType ( String identifier ) { if ( identifier == null ) return null ; if ( identifier . startsWith ( CONNECTION . PREFIX ) ) return CONNECTION ; if ( identifier . startsWith ( CONNECTION_GROUP . PREFIX ) ) return CONNECTION_GROUP ; return null ; } } ; public String getParameter ( String name ) ; public List < String > getParameterValues ( String name ) ; }
package org . glyptodon . guacamole . net . basic ; public class ClipboardState { private static final int MAXIMUM_LENGTH = 262144 ; private String mimetype = "text/plain" ; private String pending_mimetype = "text/plain" ; private byte [ ] contents = new byte [ 0 ] ; private final byte [ ] pending = new byte [ MAXIMUM_LENGTH ] ; private int pending_length = 0 ; private long last_update = 0 ; public synchronized byte [ ] getContents ( ) { return contents ; } public synchronized String getMimetype ( ) { return mimetype ; } public synchronized void begin ( String mimetype ) { pending_length = 0 ; this . pending_mimetype = mimetype ; } public synchronized void append ( byte [ ] data ) { int length = data . length ; int remaining = pending . length - pending_length ; if ( remaining < length ) length = remaining ; System . arraycopy ( data , 0 , pending , pending_length , length ) ; pending_length += length ; } public synchronized void commit ( ) { mimetype = pending_mimetype ; contents = new byte [ pending_length ] ; System . arraycopy ( pending , 0 , contents , 0 , pending_length ) ; last_update = System . currentTimeMillis ( ) ; this . notifyAll ( ) ; } public synchronized boolean waitForContents ( int timeout ) { if ( System . currentTimeMillis ( ) - last_update > timeout ) { try { this . wait ( timeout ) ; return true ; } catch ( InterruptedException e ) { } } return false ; } }
package org . glyptodon . guacamole . net . basic ; import com . google . inject . servlet . ServletModule ; import java . lang . reflect . InvocationTargetException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class TunnelModule extends ServletModule { private final Logger logger = LoggerFactory . getLogger ( TunnelModule . class ) ; private static final String [ ] WEBSOCKET_MODULES = { "org.glyptodon.guacamole.net.basic.websocket.WebSocketTunnelModule" , "org.glyptodon.guacamole.net.basic.websocket.jetty8.WebSocketTunnelModule" , "org.glyptodon.guacamole.net.basic.websocket.jetty9.WebSocketTunnelModule" , "org.glyptodon.guacamole.net.basic.websocket.tomcat.WebSocketTunnelModule" } ; private boolean loadWebSocketModule ( String classname ) { try { Class < ? > module = Class . forName ( classname ) ; TunnelLoader loader = ( TunnelLoader ) module . getConstructor ( ) . newInstance ( ) ; if ( loader . isSupported ( ) ) { install ( loader ) ; return true ; } } catch ( ClassNotFoundException e ) { } catch ( NoClassDefFoundError e ) { } catch ( NoSuchMethodException e ) { } catch ( InstantiationException e ) { logger . debug ( "Error instantiating WebSocket module." , e ) ; } catch ( IllegalAccessException e ) { logger . debug ( "Error instantiating WebSocket module." , e ) ; } catch ( InvocationTargetException e ) { logger . debug ( "Error instantiating WebSocket module." , e ) ; } return false ; } @ Override protected void configureServlets ( ) { bind ( TunnelRequestService . class ) ; serve ( "/tunnel" ) . with ( BasicGuacamoleTunnelServlet . class ) ; for ( String classname : WEBSOCKET_MODULES ) { if ( loadWebSocketModule ( classname ) ) { logger . debug ( "WebSocket module loaded: {}" , classname ) ; return ; } } logger . info ( "WebSocket support NOT present. Only HTTP will be used." ) ; } }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleUpstreamTimeoutException extends GuacamoleUpstreamException { public GuacamoleUpstreamTimeoutException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleUpstreamTimeoutException ( String message ) { super ( message ) ; } public GuacamoleUpstreamTimeoutException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . UPSTREAM_TIMEOUT ; } }
package org . glyptodon . guacamole . net . basic ; import java . util . List ; import javax . xml . bind . DatatypeConverter ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . protocol . GuacamoleInstruction ; public class MonitoringGuacamoleReader implements GuacamoleReader { private final GuacamoleReader reader ; private final ClipboardState clipboard ; private String clipboard_stream_index = null ; public MonitoringGuacamoleReader ( ClipboardState clipboard , GuacamoleReader reader ) { this . clipboard = clipboard ; this . reader = reader ; } @ Override public boolean available ( ) throws GuacamoleException { return reader . available ( ) ; } @ Override public char [ ] read ( ) throws GuacamoleException { GuacamoleInstruction instruction = readInstruction ( ) ; if ( instruction == null ) return null ; return instruction . toString ( ) . toCharArray ( ) ; } @ Override public GuacamoleInstruction readInstruction ( ) throws GuacamoleException { GuacamoleInstruction instruction = reader . readInstruction ( ) ; if ( instruction == null ) return null ; if ( instruction . getOpcode ( ) . equals ( "clipboard" ) ) { List < String > args = instruction . getArgs ( ) ; if ( args . size ( ) >= 2 ) { clipboard_stream_index = args . get ( 0 ) ; clipboard . begin ( args . get ( 1 ) ) ; } } else if ( instruction . getOpcode ( ) . equals ( "blob" ) ) { List < String > args = instruction . getArgs ( ) ; if ( args . size ( ) >= 2 && args . get ( 0 ) . equals ( clipboard_stream_index ) ) { String base64 = args . get ( 1 ) ; clipboard . append ( DatatypeConverter . parseBase64Binary ( base64 ) ) ; } } else if ( instruction . getOpcode ( ) . equals ( "end" ) ) { List < String > args = instruction . getArgs ( ) ; if ( args . size ( ) >= 1 && args . get ( 0 ) . equals ( clipboard_stream_index ) ) { clipboard . commit ( ) ; clipboard_stream_index = null ; } } return instruction ; } }
package org . glyptodon . guacamole . net . basic ; import java . io . File ; import java . io . FilenameFilter ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLClassLoader ; import java . security . AccessController ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . ArrayList ; import java . util . Collection ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . environment . Environment ; import org . glyptodon . guacamole . environment . LocalEnvironment ; import org . glyptodon . guacamole . net . basic . properties . BasicGuacamoleProperties ; @ Deprecated public class GuacamoleClassLoader extends ClassLoader { private URLClassLoader classLoader = null ; private static GuacamoleException exception = null ; private static GuacamoleClassLoader instance = null ; static { try { instance = AccessController . doPrivileged ( new PrivilegedExceptionAction < GuacamoleClassLoader > ( ) { @ Override public GuacamoleClassLoader run ( ) throws GuacamoleException { Environment environment = new LocalEnvironment ( ) ; return new GuacamoleClassLoader ( environment . getProperty ( BasicGuacamoleProperties . LIB_DIRECTORY ) ) ; } } ) ; } catch ( PrivilegedActionException e ) { exception = ( GuacamoleException ) e . getException ( ) ; } } private GuacamoleClassLoader ( File libDirectory ) throws GuacamoleException { if ( libDirectory == null ) return ; if ( ! libDirectory . isDirectory ( ) ) throw new GuacamoleException ( libDirectory + " is not a directory." ) ; Collection < URL > jarURLs = new ArrayList < URL > ( ) ; File [ ] files = libDirectory . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String name ) { return name . endsWith ( ".jar" ) ; } } ) ; if ( files == null ) throw new GuacamoleException ( "Unable to read contents of directory " + libDirectory ) ; for ( File file : files ) { try { jarURLs . add ( file . toURI ( ) . toURL ( ) ) ; } catch ( MalformedURLException e ) { throw new GuacamoleException ( e ) ; } } URL [ ] urls = new URL [ jarURLs . size ( ) ] ; classLoader = new URLClassLoader ( jarURLs . toArray ( urls ) , getClass ( ) . getClassLoader ( ) ) ; } public static GuacamoleClassLoader getInstance ( ) throws GuacamoleException { if ( exception != null ) throw exception ; return instance ; } @ Override public Class < ? > findClass ( String name ) throws ClassNotFoundException { if ( classLoader == null ) return Class . forName ( name ) ; return classLoader . loadClass ( name ) ; } }
package org . glyptodon . guacamole . net . basic ; import com . google . inject . Module ; public interface TunnelLoader extends Module { public boolean isSupported ( ) ; }
package org . glyptodon . guacamole . net . basic . auth ;
package org . glyptodon . guacamole . net . basic . auth ; import java . util . HashMap ; import java . util . Map ; public class UserMapping { private Map < String , Authorization > authorizations = new HashMap < String , Authorization > ( ) ; public void addAuthorization ( Authorization authorization ) { authorizations . put ( authorization . getUsername ( ) , authorization ) ; } public Authorization getAuthorization ( String username ) { return authorizations . get ( username ) ; } }
package org . glyptodon . guacamole . net . basic . auth ; import java . io . UnsupportedEncodingException ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . Map ; import java . util . TreeMap ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; public class Authorization { public static enum Encoding { PLAIN_TEXT , MD5 } private String username ; private String password ; private Encoding encoding = Encoding . PLAIN_TEXT ; private Map < String , GuacamoleConfiguration > configs = new TreeMap < String , GuacamoleConfiguration > ( ) ; private static final char HEX_CHARS [ ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; private static String getHexString ( byte [ ] bytes ) { if ( bytes == null ) return null ; StringBuilder hex = new StringBuilder ( 2 * bytes . length ) ; for ( byte b : bytes ) { hex . append ( HEX_CHARS [ ( b & 0xF0 ) > > 4 ] ) . append ( HEX_CHARS [ b & 0x0F ] ) ; } return hex . toString ( ) ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public Encoding getEncoding ( ) { return encoding ; } public void setEncoding ( Encoding encoding ) { this . encoding = encoding ; } public boolean validate ( String username , String password ) { if ( username != null && password != null && username . equals ( this . username ) ) { switch ( encoding ) { case PLAIN_TEXT : return password . equals ( this . password ) ; case MD5 : try { MessageDigest digest = MessageDigest . getInstance ( "MD5" ) ; String hashedPassword = getHexString ( digest . digest ( password . getBytes ( "UTF-8" ) ) ) ; return hashedPassword . equals ( this . password . toUpperCase ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new UnsupportedOperationException ( "Unexpected lack of UTF-8 support." , e ) ; } catch ( NoSuchAlgorithmException e ) { throw new UnsupportedOperationException ( "Unexpected lack of MD5 support." , e ) ; } } } return false ; } public GuacamoleConfiguration getConfiguration ( String name ) { return configs . get ( name ) ; } public void addConfiguration ( String name , GuacamoleConfiguration config ) { configs . put ( name , config ) ; } public Map < String , GuacamoleConfiguration > getConfigurations ( ) { return configs ; } }
package org . glyptodon . guacamole . net . basic . websocket ;
package org . glyptodon . guacamole . net . basic . websocket ; import com . google . inject . Provider ; import java . util . Map ; import javax . websocket . EndpointConfig ; import javax . websocket . HandshakeResponse ; import javax . websocket . Session ; import javax . websocket . server . HandshakeRequest ; import javax . websocket . server . ServerEndpointConfig ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . basic . TunnelRequestService ; import org . glyptodon . guacamole . websocket . GuacamoleWebSocketTunnelEndpoint ; public class BasicGuacamoleWebSocketTunnelEndpoint extends GuacamoleWebSocketTunnelEndpoint { private static final String TUNNEL_USER_PROPERTY = "WS_GUAC_TUNNEL" ; private static final String ERROR_USER_PROPERTY = "WS_GUAC_TUNNEL_ERROR" ; public static class Configurator extends ServerEndpointConfig . Configurator { private final Provider < TunnelRequestService > tunnelRequestServiceProvider ; public Configurator ( Provider < TunnelRequestService > tunnelRequestServiceProvider ) { this . tunnelRequestServiceProvider = tunnelRequestServiceProvider ; } @ Override public void modifyHandshake ( ServerEndpointConfig config , HandshakeRequest request , HandshakeResponse response ) { super . modifyHandshake ( config , request , response ) ; Map < String , Object > userProperties = config . getUserProperties ( ) ; userProperties . clear ( ) ; try { TunnelRequestService tunnelRequestService = tunnelRequestServiceProvider . get ( ) ; GuacamoleTunnel tunnel = tunnelRequestService . createTunnel ( new WebSocketTunnelRequest ( request ) ) ; if ( tunnel != null ) userProperties . put ( TUNNEL_USER_PROPERTY , tunnel ) ; } catch ( GuacamoleException e ) { userProperties . put ( ERROR_USER_PROPERTY , e ) ; } } } @ Override protected GuacamoleTunnel createTunnel ( Session session , EndpointConfig config ) throws GuacamoleException { Map < String , Object > userProperties = config . getUserProperties ( ) ; GuacamoleException tunnelError = ( GuacamoleException ) userProperties . get ( ERROR_USER_PROPERTY ) ; if ( tunnelError != null ) throw tunnelError ; return ( GuacamoleTunnel ) userProperties . get ( TUNNEL_USER_PROPERTY ) ; } }
package org . glyptodon . guacamole . net . basic . websocket ; import java . util . List ; import java . util . Map ; import javax . websocket . server . HandshakeRequest ; import org . glyptodon . guacamole . net . basic . TunnelRequest ; public class WebSocketTunnelRequest implements TunnelRequest { private final Map < String , List < String > > handshakeParameters ; public WebSocketTunnelRequest ( HandshakeRequest request ) { this . handshakeParameters = request . getParameterMap ( ) ; } @ Override public String getParameter ( String name ) { List < String > values = getParameterValues ( name ) ; if ( values == null || values . isEmpty ( ) ) return null ; return values . get ( 0 ) ; } @ Override public List < String > getParameterValues ( String name ) { return handshakeParameters . get ( name ) ; } }
package org . glyptodon . guacamole . net . basic . websocket ; import com . google . inject . Provider ; import com . google . inject . servlet . ServletModule ; import java . util . Arrays ; import javax . websocket . DeploymentException ; import javax . websocket . server . ServerContainer ; import javax . websocket . server . ServerEndpointConfig ; import org . glyptodon . guacamole . net . basic . TunnelLoader ; import org . glyptodon . guacamole . net . basic . TunnelRequestService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class WebSocketTunnelModule extends ServletModule implements TunnelLoader { private final Logger logger = LoggerFactory . getLogger ( WebSocketTunnelModule . class ) ; @ Override public boolean isSupported ( ) { try { Class . forName ( "javax.websocket.Endpoint" ) ; return true ; } catch ( ClassNotFoundException e ) { } catch ( NoClassDefFoundError e ) { } return false ; } @ Override public void configureServlets ( ) { logger . info ( "Loading JSR-356 WebSocket support..." ) ; ServerContainer container = ( ServerContainer ) getServletContext ( ) . getAttribute ( "javax.websocket.server.ServerContainer" ) ; if ( container == null ) { logger . warn ( "ServerContainer attribute required by JSR-356 is missing. Cannot load JSR-356 WebSocket support." ) ; return ; } Provider < TunnelRequestService > tunnelRequestServiceProvider = getProvider ( TunnelRequestService . class ) ; ServerEndpointConfig config = ServerEndpointConfig . Builder . create ( BasicGuacamoleWebSocketTunnelEndpoint . class , "/websocket-tunnel" ) . configurator ( new BasicGuacamoleWebSocketTunnelEndpoint . Configurator ( tunnelRequestServiceProvider ) ) . subprotocols ( Arrays . asList ( new String [ ] { "guacamole" } ) ) . build ( ) ; try { container . addEndpoint ( config ) ; } catch ( DeploymentException e ) { logger . error ( "Unable to deploy WebSocket tunnel." , e ) ; } } }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleResourceNotFoundException extends GuacamoleClientException { public GuacamoleResourceNotFoundException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleResourceNotFoundException ( String message ) { super ( message ) ; } public GuacamoleResourceNotFoundException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . RESOURCE_NOT_FOUND ; } }
package org . glyptodon . guacamole . net . basic . websocket . jetty9 ;
package org . glyptodon . guacamole . net . basic . websocket . jetty9 ; import org . eclipse . jetty . websocket . api . Session ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . basic . TunnelRequestService ; public class BasicGuacamoleWebSocketTunnelListener extends GuacamoleWebSocketTunnelListener { private final TunnelRequestService tunnelRequestService ; public BasicGuacamoleWebSocketTunnelListener ( TunnelRequestService tunnelRequestService ) { this . tunnelRequestService = tunnelRequestService ; } @ Override protected GuacamoleTunnel createTunnel ( Session session ) throws GuacamoleException { return tunnelRequestService . createTunnel ( new WebSocketTunnelRequest ( session . getUpgradeRequest ( ) ) ) ; } }
package org . glyptodon . guacamole . net . basic . websocket . jetty9 ; import java . io . IOException ; import org . eclipse . jetty . websocket . api . CloseStatus ; import org . eclipse . jetty . websocket . api . RemoteEndpoint ; import org . eclipse . jetty . websocket . api . Session ; import org . eclipse . jetty . websocket . api . WebSocketListener ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleConnectionClosedException ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . GuacamoleWriter ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public abstract class GuacamoleWebSocketTunnelListener implements WebSocketListener { private static final int BUFFER_SIZE = 8192 ; private static final Logger logger = LoggerFactory . getLogger ( BasicGuacamoleWebSocketTunnelServlet . class ) ; private GuacamoleTunnel tunnel ; private void closeConnection ( Session session , GuacamoleStatus guac_status ) { try { int code = guac_status . getWebSocketCode ( ) ; String message = Integer . toString ( guac_status . getGuacamoleStatusCode ( ) ) ; session . close ( new CloseStatus ( code , message ) ) ; } catch ( IOException e ) { logger . debug ( "Unable to close WebSocket connection." , e ) ; } } protected abstract GuacamoleTunnel createTunnel ( Session session ) throws GuacamoleException ; @ Override public void onWebSocketConnect ( final Session session ) { try { tunnel = createTunnel ( session ) ; if ( tunnel == null ) { closeConnection ( session , GuacamoleStatus . RESOURCE_NOT_FOUND ) ; return ; } } catch ( GuacamoleException e ) { logger . error ( "Creation of WebSocket tunnel to guacd failed: {}" , e . getMessage ( ) ) ; logger . debug ( "Error connecting WebSocket tunnel." , e ) ; closeConnection ( session , e . getStatus ( ) ) ; return ; } Thread readThread = new Thread ( ) { private final RemoteEndpoint remote = session . getRemote ( ) ; @ Override public void run ( ) { StringBuilder buffer = new StringBuilder ( BUFFER_SIZE ) ; GuacamoleReader reader = tunnel . acquireReader ( ) ; char [ ] readMessage ; try { try { while ( ( readMessage = reader . read ( ) ) != null ) { buffer . append ( readMessage ) ; if ( ! reader . available ( ) || buffer . length ( ) >= BUFFER_SIZE ) { remote . sendString ( buffer . toString ( ) ) ; buffer . setLength ( 0 ) ; } } closeConnection ( session , GuacamoleStatus . SUCCESS ) ; } catch ( GuacamoleClientException e ) { logger . info ( "WebSocket connection terminated: {}" , e . getMessage ( ) ) ; logger . debug ( "WebSocket connection terminated due to client error." , e ) ; closeConnection ( session , e . getStatus ( ) ) ; } catch ( GuacamoleConnectionClosedException e ) { logger . debug ( "Connection to guacd closed." , e ) ; closeConnection ( session , GuacamoleStatus . SUCCESS ) ; } catch ( GuacamoleException e ) { logger . error ( "Connection to guacd terminated abnormally: {}" , e . getMessage ( ) ) ; logger . debug ( "Internal error during connection to guacd." , e ) ; closeConnection ( session , e . getStatus ( ) ) ; } } catch ( IOException e ) { logger . debug ( "I/O error prevents further reads." , e ) ; } } } ; readThread . start ( ) ; } @ Override public void onWebSocketText ( String message ) { GuacamoleWriter writer = tunnel . acquireWriter ( ) ; try { writer . write ( message . toCharArray ( ) ) ; } catch ( GuacamoleConnectionClosedException e ) { logger . debug ( "Connection to guacd closed." , e ) ; } catch ( GuacamoleException e ) { logger . debug ( "WebSocket tunnel write failed." , e ) ; } tunnel . releaseWriter ( ) ; } @ Override public void onWebSocketBinary ( byte [ ] payload , int offset , int length ) { throw new UnsupportedOperationException ( "Binary WebSocket messages are not supported." ) ; } @ Override public void onWebSocketError ( Throwable t ) { logger . debug ( "WebSocket tunnel closing due to error." , t ) ; try { if ( tunnel != null ) tunnel . close ( ) ; } catch ( GuacamoleException e ) { logger . debug ( "Unable to close connection to guacd." , e ) ; } } @ Override public void onWebSocketClose ( int statusCode , String reason ) { try { if ( tunnel != null ) tunnel . close ( ) ; } catch ( GuacamoleException e ) { logger . debug ( "Unable to close connection to guacd." , e ) ; } } }
package org . glyptodon . guacamole . net . basic . websocket . jetty9 ; import org . eclipse . jetty . websocket . api . UpgradeRequest ; import org . eclipse . jetty . websocket . api . UpgradeResponse ; import org . eclipse . jetty . websocket . servlet . WebSocketCreator ; import org . glyptodon . guacamole . net . basic . TunnelRequestService ; public class BasicGuacamoleWebSocketCreator implements WebSocketCreator { private final TunnelRequestService tunnelRequestService ; public BasicGuacamoleWebSocketCreator ( TunnelRequestService tunnelRequestService ) { this . tunnelRequestService = tunnelRequestService ; } @ Override public Object createWebSocket ( UpgradeRequest request , UpgradeResponse response ) { for ( String subprotocol : request . getSubProtocols ( ) ) { if ( "guacamole" . equals ( subprotocol ) ) { response . setAcceptedSubProtocol ( subprotocol ) ; return new BasicGuacamoleWebSocketTunnelListener ( tunnelRequestService ) ; } } return null ; } }
package org . glyptodon . guacamole . net . basic . websocket . jetty9 ; import com . google . inject . Inject ; import com . google . inject . Singleton ; import org . eclipse . jetty . websocket . servlet . WebSocketServlet ; import org . eclipse . jetty . websocket . servlet . WebSocketServletFactory ; import org . glyptodon . guacamole . net . basic . TunnelRequestService ; @ Singleton public class BasicGuacamoleWebSocketTunnelServlet extends WebSocketServlet { @ Inject private TunnelRequestService tunnelRequestService ; @ Override public void configure ( WebSocketServletFactory factory ) { factory . setCreator ( new BasicGuacamoleWebSocketCreator ( tunnelRequestService ) ) ; } }
package org . glyptodon . guacamole . net . basic . websocket . jetty9 ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import org . eclipse . jetty . websocket . api . UpgradeRequest ; import org . glyptodon . guacamole . net . basic . TunnelRequest ; public class WebSocketTunnelRequest implements TunnelRequest { private final Map < String , String [ ] > handshakeParameters ; public WebSocketTunnelRequest ( UpgradeRequest request ) { this . handshakeParameters = request . getParameterMap ( ) ; } @ Override public String getParameter ( String name ) { List < String > values = getParameterValues ( name ) ; if ( values == null || values . isEmpty ( ) ) return null ; return values . get ( 0 ) ; } @ Override public List < String > getParameterValues ( String name ) { String [ ] values = handshakeParameters . get ( name ) ; if ( values == null ) return null ; return Arrays . asList ( values ) ; } }
package org . glyptodon . guacamole . net . basic . websocket . jetty9 ; import com . google . inject . servlet . ServletModule ; import org . glyptodon . guacamole . net . basic . TunnelLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class WebSocketTunnelModule extends ServletModule implements TunnelLoader { private final Logger logger = LoggerFactory . getLogger ( WebSocketTunnelModule . class ) ; @ Override public boolean isSupported ( ) { try { Class . forName ( "org.glyptodon.guacamole.net.basic.websocket.jetty9.BasicGuacamoleWebSocketTunnelServlet" ) ; return true ; } catch ( ClassNotFoundException e ) { } catch ( NoClassDefFoundError e ) { } return false ; } @ Override public void configureServlets ( ) { logger . info ( "Loading Jetty 9 WebSocket support..." ) ; serve ( "/websocket-tunnel" ) . with ( BasicGuacamoleWebSocketTunnelServlet . class ) ; } }
package org . glyptodon . guacamole . net . basic . websocket . jetty8 ;
package org . glyptodon . guacamole . net . basic . websocket . jetty8 ; import com . google . inject . Inject ; import com . google . inject . Singleton ; import javax . servlet . http . HttpServletRequest ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . basic . TunnelRequestService ; import org . glyptodon . guacamole . net . basic . HTTPTunnelRequest ; @ Singleton public class BasicGuacamoleWebSocketTunnelServlet extends GuacamoleWebSocketTunnelServlet { @ Inject private TunnelRequestService tunnelRequestService ; @ Override protected GuacamoleTunnel doConnect ( HttpServletRequest request ) throws GuacamoleException { return tunnelRequestService . createTunnel ( new HTTPTunnelRequest ( request ) ) ; } }
package org . glyptodon . guacamole . net . basic . websocket . jetty8 ; import java . io . IOException ; import javax . servlet . http . HttpServletRequest ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . GuacamoleWriter ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . eclipse . jetty . websocket . WebSocket ; import org . eclipse . jetty . websocket . WebSocket . Connection ; import org . eclipse . jetty . websocket . WebSocketServlet ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleConnectionClosedException ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public abstract class GuacamoleWebSocketTunnelServlet extends WebSocketServlet { private static final Logger logger = LoggerFactory . getLogger ( GuacamoleWebSocketTunnelServlet . class ) ; private static final int BUFFER_SIZE = 8192 ; public static void closeConnection ( Connection connection , GuacamoleStatus guac_status ) { connection . close ( guac_status . getWebSocketCode ( ) , Integer . toString ( guac_status . getGuacamoleStatusCode ( ) ) ) ; } @ Override public WebSocket doWebSocketConnect ( HttpServletRequest request , String protocol ) { final GuacamoleTunnel tunnel ; try { tunnel = doConnect ( request ) ; } catch ( GuacamoleException e ) { logger . error ( "Creation of WebSocket tunnel to guacd failed: {}" , e . getMessage ( ) ) ; logger . debug ( "Error connecting WebSocket tunnel." , e ) ; return null ; } return new WebSocket . OnTextMessage ( ) { @ Override public void onMessage ( String string ) { GuacamoleWriter writer = tunnel . acquireWriter ( ) ; try { writer . write ( string . toCharArray ( ) ) ; } catch ( GuacamoleConnectionClosedException e ) { logger . debug ( "Connection to guacd closed." , e ) ; } catch ( GuacamoleException e ) { logger . debug ( "WebSocket tunnel write failed." , e ) ; } tunnel . releaseWriter ( ) ; } @ Override public void onOpen ( final Connection connection ) { if ( tunnel == null ) { closeConnection ( connection , GuacamoleStatus . RESOURCE_NOT_FOUND ) ; return ; } Thread readThread = new Thread ( ) { @ Override public void run ( ) { StringBuilder buffer = new StringBuilder ( BUFFER_SIZE ) ; GuacamoleReader reader = tunnel . acquireReader ( ) ; char [ ] readMessage ; try { try { while ( ( readMessage = reader . read ( ) ) != null ) { buffer . append ( readMessage ) ; if ( ! reader . available ( ) || buffer . length ( ) >= BUFFER_SIZE ) { connection . sendMessage ( buffer . toString ( ) ) ; buffer . setLength ( 0 ) ; } } closeConnection ( connection , GuacamoleStatus . SUCCESS ) ; } catch ( GuacamoleClientException e ) { logger . info ( "WebSocket connection terminated: {}" , e . getMessage ( ) ) ; logger . debug ( "WebSocket connection terminated due to client error." , e ) ; closeConnection ( connection , e . getStatus ( ) ) ; } catch ( GuacamoleConnectionClosedException e ) { logger . debug ( "Connection to guacd closed." , e ) ; closeConnection ( connection , GuacamoleStatus . SUCCESS ) ; } catch ( GuacamoleException e ) { logger . error ( "Connection to guacd terminated abnormally: {}" , e . getMessage ( ) ) ; logger . debug ( "Internal error during connection to guacd." , e ) ; closeConnection ( connection , e . getStatus ( ) ) ; } } catch ( IOException e ) { logger . debug ( "WebSocket tunnel read failed due to I/O error." , e ) ; } } } ; readThread . start ( ) ; } @ Override public void onClose ( int i , String string ) { try { if ( tunnel != null ) tunnel . close ( ) ; } catch ( GuacamoleException e ) { logger . debug ( "Unable to close connection to guacd." , e ) ; } } } ; } protected abstract GuacamoleTunnel doConnect ( HttpServletRequest request ) throws GuacamoleException ; }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleClientException extends GuacamoleException { public GuacamoleClientException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleClientException ( String message ) { super ( message ) ; } public GuacamoleClientException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . CLIENT_BAD_REQUEST ; } }
package org . glyptodon . guacamole . net . basic . websocket . jetty8 ; import com . google . inject . servlet . ServletModule ; import org . glyptodon . guacamole . net . basic . TunnelLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class WebSocketTunnelModule extends ServletModule implements TunnelLoader { private final Logger logger = LoggerFactory . getLogger ( WebSocketTunnelModule . class ) ; @ Override public boolean isSupported ( ) { try { Class . forName ( "org.glyptodon.guacamole.net.basic.websocket.jetty8.BasicGuacamoleWebSocketTunnelServlet" ) ; return true ; } catch ( ClassNotFoundException e ) { } catch ( NoClassDefFoundError e ) { } return false ; } @ Override public void configureServlets ( ) { logger . info ( "Loading Jetty 8 WebSocket support..." ) ; serve ( "/websocket-tunnel" ) . with ( BasicGuacamoleWebSocketTunnelServlet . class ) ; } }
package org . glyptodon . guacamole . net . basic . websocket . tomcat ;
package org . glyptodon . guacamole . net . basic . websocket . tomcat ; import com . google . inject . Inject ; import com . google . inject . Singleton ; import javax . servlet . http . HttpServletRequest ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . glyptodon . guacamole . net . basic . TunnelRequestService ; import org . glyptodon . guacamole . net . basic . HTTPTunnelRequest ; @ Singleton public class BasicGuacamoleWebSocketTunnelServlet extends GuacamoleWebSocketTunnelServlet { @ Inject private TunnelRequestService tunnelRequestService ; @ Override protected GuacamoleTunnel doConnect ( HttpServletRequest request ) throws GuacamoleException { return tunnelRequestService . createTunnel ( new HTTPTunnelRequest ( request ) ) ; } ; }
package org . glyptodon . guacamole . net . basic . websocket . tomcat ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import java . nio . ByteBuffer ; import java . nio . CharBuffer ; import java . util . List ; import javax . servlet . http . HttpServletRequest ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . io . GuacamoleReader ; import org . glyptodon . guacamole . io . GuacamoleWriter ; import org . glyptodon . guacamole . net . GuacamoleTunnel ; import org . apache . catalina . websocket . StreamInbound ; import org . apache . catalina . websocket . WebSocketServlet ; import org . apache . catalina . websocket . WsOutbound ; import org . glyptodon . guacamole . GuacamoleClientException ; import org . glyptodon . guacamole . GuacamoleConnectionClosedException ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public abstract class GuacamoleWebSocketTunnelServlet extends WebSocketServlet { private static final int BUFFER_SIZE = 8192 ; private final Logger logger = LoggerFactory . getLogger ( GuacamoleWebSocketTunnelServlet . class ) ; public void closeConnection ( WsOutbound outbound , GuacamoleStatus guac_status ) { try { byte [ ] message = Integer . toString ( guac_status . getGuacamoleStatusCode ( ) ) . getBytes ( "UTF-8" ) ; outbound . close ( guac_status . getWebSocketCode ( ) , ByteBuffer . wrap ( message ) ) ; } catch ( IOException e ) { logger . debug ( "Unable to close WebSocket tunnel." , e ) ; } } @ Override protected String selectSubProtocol ( List < String > subProtocols ) { for ( String protocol : subProtocols ) if ( "guacamole" . equals ( protocol ) ) return "guacamole" ; return null ; } @ Override public StreamInbound createWebSocketInbound ( String protocol , HttpServletRequest request ) { final GuacamoleTunnel tunnel ; try { tunnel = doConnect ( request ) ; } catch ( GuacamoleException e ) { logger . error ( "Creation of WebSocket tunnel to guacd failed: {}" , e . getMessage ( ) ) ; logger . debug ( "Error connecting WebSocket tunnel." , e ) ; return null ; } return new StreamInbound ( ) { @ Override protected void onTextData ( Reader reader ) throws IOException { GuacamoleWriter writer = tunnel . acquireWriter ( ) ; try { char [ ] buffer = new char [ BUFFER_SIZE ] ; int num_read ; while ( ( num_read = reader . read ( buffer ) ) > 0 ) writer . write ( buffer , 0 , num_read ) ; } catch ( GuacamoleConnectionClosedException e ) { logger . debug ( "Connection to guacd closed." , e ) ; } catch ( GuacamoleException e ) { logger . debug ( "WebSocket tunnel write failed." , e ) ; } tunnel . releaseWriter ( ) ; } @ Override public void onOpen ( final WsOutbound outbound ) { if ( tunnel == null ) { closeConnection ( outbound , GuacamoleStatus . RESOURCE_NOT_FOUND ) ; return ; } Thread readThread = new Thread ( ) { @ Override public void run ( ) { StringBuilder buffer = new StringBuilder ( BUFFER_SIZE ) ; GuacamoleReader reader = tunnel . acquireReader ( ) ; char [ ] readMessage ; try { try { while ( ( readMessage = reader . read ( ) ) != null ) { buffer . append ( readMessage ) ; if ( ! reader . available ( ) || buffer . length ( ) >= BUFFER_SIZE ) { outbound . writeTextMessage ( CharBuffer . wrap ( buffer ) ) ; buffer . setLength ( 0 ) ; } } closeConnection ( outbound , GuacamoleStatus . SUCCESS ) ; } catch ( GuacamoleClientException e ) { logger . info ( "WebSocket connection terminated: {}" , e . getMessage ( ) ) ; logger . debug ( "WebSocket connection terminated due to client error." , e ) ; closeConnection ( outbound , e . getStatus ( ) ) ; } catch ( GuacamoleConnectionClosedException e ) { logger . debug ( "Connection to guacd closed." , e ) ; closeConnection ( outbound , GuacamoleStatus . SUCCESS ) ; } catch ( GuacamoleException e ) { logger . error ( "Connection to guacd terminated abnormally: {}" , e . getMessage ( ) ) ; logger . debug ( "Internal error during connection to guacd." , e ) ; closeConnection ( outbound , e . getStatus ( ) ) ; } } catch ( IOException e ) { logger . debug ( "I/O error prevents further reads." , e ) ; } } } ; readThread . start ( ) ; } @ Override public void onClose ( int i ) { try { if ( tunnel != null ) tunnel . close ( ) ; } catch ( GuacamoleException e ) { logger . debug ( "Unable to close connection to guacd." , e ) ; } } @ Override protected void onBinaryData ( InputStream in ) throws IOException { throw new UnsupportedOperationException ( "Not supported yet." ) ; } } ; } protected abstract GuacamoleTunnel doConnect ( HttpServletRequest request ) throws GuacamoleException ; }
package org . glyptodon . guacamole . net . basic . websocket . tomcat ; import com . google . inject . servlet . ServletModule ; import org . glyptodon . guacamole . net . basic . TunnelLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class WebSocketTunnelModule extends ServletModule implements TunnelLoader { private final Logger logger = LoggerFactory . getLogger ( WebSocketTunnelModule . class ) ; @ Override public boolean isSupported ( ) { try { Class . forName ( "org.glyptodon.guacamole.net.basic.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet" ) ; return true ; } catch ( ClassNotFoundException e ) { } catch ( NoClassDefFoundError e ) { } return false ; } @ Override public void configureServlets ( ) { logger . info ( "Loading Tomcat 7 WebSocket support..." ) ; serve ( "/websocket-tunnel" ) . with ( BasicGuacamoleWebSocketTunnelServlet . class ) ; } }
package org . glyptodon . guacamole . net . basic . xml . user_mapping ; import org . glyptodon . guacamole . net . basic . auth . Authorization ; import org . glyptodon . guacamole . net . basic . auth . UserMapping ; import org . glyptodon . guacamole . xml . TagHandler ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class AuthorizeTagHandler implements TagHandler { private Authorization authorization = new Authorization ( ) ; private GuacamoleConfiguration default_config = null ; private UserMapping parent ; public AuthorizeTagHandler ( UserMapping parent ) { this . parent = parent ; } @ Override public void init ( Attributes attributes ) throws SAXException { authorization . setUsername ( attributes . getValue ( "username" ) ) ; authorization . setPassword ( attributes . getValue ( "password" ) ) ; String encoding = attributes . getValue ( "encoding" ) ; if ( encoding != null ) { if ( encoding . equals ( "md5" ) ) authorization . setEncoding ( Authorization . Encoding . MD5 ) ; else if ( encoding . equals ( "plain" ) ) authorization . setEncoding ( Authorization . Encoding . PLAIN_TEXT ) ; else throw new SAXException ( "Invalid encoding: '" + encoding + "'" ) ; } parent . addAuthorization ( this . asAuthorization ( ) ) ; } @ Override public TagHandler childElement ( String localName ) throws SAXException { if ( localName . equals ( "connection" ) ) return new ConnectionTagHandler ( authorization ) ; if ( localName . equals ( "param" ) ) { if ( default_config == null ) { default_config = new GuacamoleConfiguration ( ) ; authorization . addConfiguration ( "DEFAULT" , default_config ) ; } return new ParamTagHandler ( default_config ) ; } if ( localName . equals ( "protocol" ) ) { if ( default_config == null ) { default_config = new GuacamoleConfiguration ( ) ; authorization . addConfiguration ( "DEFAULT" , default_config ) ; } return new ProtocolTagHandler ( default_config ) ; } return null ; } @ Override public void complete ( String textContent ) throws SAXException { } public Authorization asAuthorization ( ) { return authorization ; } }
package org . glyptodon . guacamole . net . basic . xml . user_mapping ;
package org . glyptodon . guacamole . net . basic . xml . user_mapping ; import org . glyptodon . guacamole . net . basic . auth . Authorization ; import org . glyptodon . guacamole . xml . TagHandler ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ConnectionTagHandler implements TagHandler { private GuacamoleConfiguration config = new GuacamoleConfiguration ( ) ; private String name ; private Authorization parent ; public ConnectionTagHandler ( Authorization parent ) { this . parent = parent ; } @ Override public void init ( Attributes attributes ) throws SAXException { name = attributes . getValue ( "name" ) ; parent . addConfiguration ( name , this . asGuacamoleConfiguration ( ) ) ; } @ Override public TagHandler childElement ( String localName ) throws SAXException { if ( localName . equals ( "param" ) ) return new ParamTagHandler ( config ) ; if ( localName . equals ( "protocol" ) ) return new ProtocolTagHandler ( config ) ; return null ; } @ Override public void complete ( String textContent ) throws SAXException { } public GuacamoleConfiguration asGuacamoleConfiguration ( ) { return config ; } public String getName ( ) { return name ; } }
package org . glyptodon . guacamole . net . basic . xml . user_mapping ; import org . glyptodon . guacamole . xml . TagHandler ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ParamTagHandler implements TagHandler { private GuacamoleConfiguration config ; private String name ; public ParamTagHandler ( GuacamoleConfiguration config ) { this . config = config ; } @ Override public void init ( Attributes attributes ) throws SAXException { this . name = attributes . getValue ( "name" ) ; } @ Override public TagHandler childElement ( String localName ) throws SAXException { throw new SAXException ( "The 'param' tag can contain no elements." ) ; } @ Override public void complete ( String textContent ) throws SAXException { config . setParameter ( name , textContent ) ; } }
package org . glyptodon . guacamole . net . basic . xml . user_mapping ; import org . glyptodon . guacamole . net . basic . auth . UserMapping ; import org . glyptodon . guacamole . xml . TagHandler ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class UserMappingTagHandler implements TagHandler { private UserMapping user_mapping = new UserMapping ( ) ; @ Override public void init ( Attributes attributes ) throws SAXException { } @ Override public TagHandler childElement ( String localName ) throws SAXException { if ( localName . equals ( "authorize" ) ) return new AuthorizeTagHandler ( user_mapping ) ; return null ; } @ Override public void complete ( String textContent ) throws SAXException { } public UserMapping asUserMapping ( ) { return user_mapping ; } }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleClientTimeoutException extends GuacamoleClientException { public GuacamoleClientTimeoutException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleClientTimeoutException ( String message ) { super ( message ) ; } public GuacamoleClientTimeoutException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . CLIENT_TIMEOUT ; } }
package org . glyptodon . guacamole . net . basic . xml . user_mapping ; import org . glyptodon . guacamole . xml . TagHandler ; import org . glyptodon . guacamole . protocol . GuacamoleConfiguration ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ProtocolTagHandler implements TagHandler { private GuacamoleConfiguration config ; public ProtocolTagHandler ( GuacamoleConfiguration config ) throws SAXException { this . config = config ; } @ Override public void init ( Attributes attributes ) throws SAXException { } @ Override public TagHandler childElement ( String localName ) throws SAXException { throw new SAXException ( "The 'protocol' tag can contain no elements." ) ; } @ Override public void complete ( String textContent ) throws SAXException { config . setProtocol ( textContent ) ; } }
package org . glyptodon . guacamole . net . basic . log ; import ch . qos . logback . classic . LoggerContext ; import ch . qos . logback . classic . joran . JoranConfigurator ; import ch . qos . logback . core . joran . spi . JoranException ; import ch . qos . logback . core . util . StatusPrinter ; import com . google . inject . AbstractModule ; import java . io . File ; import org . glyptodon . guacamole . environment . Environment ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class LogModule extends AbstractModule { private final Logger logger = LoggerFactory . getLogger ( LogModule . class ) ; private final Environment environment ; public LogModule ( Environment environment ) { this . environment = environment ; } @ Override protected void configure ( ) { File guacamoleHome = environment . getGuacamoleHome ( ) ; if ( ! guacamoleHome . isDirectory ( ) ) return ; File logbackConfiguration = new File ( guacamoleHome , "logback.xml" ) ; if ( ! logbackConfiguration . exists ( ) ) return ; logger . info ( "Loading logback configuration from \"{}\"." , logbackConfiguration ) ; LoggerContext context = ( LoggerContext ) LoggerFactory . getILoggerFactory ( ) ; context . reset ( ) ; try { JoranConfigurator configurator = new JoranConfigurator ( ) ; configurator . setContext ( context ) ; configurator . doConfigure ( logbackConfiguration ) ; StatusPrinter . printInCaseOfErrorsOrWarnings ( context ) ; } catch ( JoranException e ) { logger . error ( "Initialization of logback failed: {}" , e . getMessage ( ) ) ; logger . debug ( "Unable to load logback configuration.." , e ) ; } } }
package org . glyptodon . guacamole . net . basic . rest ;
package org . glyptodon . guacamole . net . basic . rest ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import javax . ws . rs . HttpMethod ; @ Target ( { ElementType . METHOD } ) @ Retention ( RetentionPolicy . RUNTIME ) @ HttpMethod ( "PATCH" ) public @ interface PATCH { }
package org . glyptodon . guacamole . net . basic . rest ; public class APIPatch < T > { public enum Operation { add , remove , test , copy , replace , move } private Operation op ; private T value ; private String path ; public Operation getOp ( ) { return op ; } public void setOp ( Operation op ) { this . op = op ; } public T getValue ( ) { return value ; } public void setValue ( T value ) { this . value = value ; } public String getPath ( ) { return path ; } public void setPath ( String path ) { this . path = path ; } }
package org . glyptodon . guacamole . net . basic . rest ; import java . util . Collections ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletRequestWrapper ; import javax . ws . rs . core . MultivaluedMap ; public class APIRequest extends HttpServletRequestWrapper { private final Map < String , String [ ] > parameters ; public APIRequest ( HttpServletRequest request , MultivaluedMap < String , String > parameters ) { super ( request ) ; this . parameters = new HashMap < String , String [ ] > ( parameters . size ( ) ) ; for ( Map . Entry < String , List < String > > entry : parameters . entrySet ( ) ) { String name = entry . getKey ( ) ; List < String > values = entry . getValue ( ) ; this . parameters . put ( name , values . toArray ( new String [ values . size ( ) ] ) ) ; } } @ Override public String [ ] getParameterValues ( String name ) { return parameters . get ( name ) ; } @ Override public Enumeration < String > getParameterNames ( ) { return Collections . enumeration ( parameters . keySet ( ) ) ; } @ Override public Map < String , String [ ] > getParameterMap ( ) { return Collections . unmodifiableMap ( parameters ) ; } @ Override public String getParameter ( String name ) { String [ ] values = getParameterValues ( name ) ; if ( values == null ) return null ; return values [ 0 ] ; } }
package org . glyptodon . guacamole . net . basic . rest ; import com . google . inject . Scopes ; import com . google . inject . matcher . Matchers ; import com . google . inject . servlet . ServletModule ; import com . sun . jersey . guice . spi . container . servlet . GuiceContainer ; import org . codehaus . jackson . jaxrs . JacksonJsonProvider ; import org . glyptodon . guacamole . net . basic . rest . auth . TokenRESTService ; import org . glyptodon . guacamole . net . basic . rest . clipboard . ClipboardRESTService ; import org . glyptodon . guacamole . net . basic . rest . connection . ConnectionRESTService ; import org . glyptodon . guacamole . net . basic . rest . connectiongroup . ConnectionGroupRESTService ; import org . glyptodon . guacamole . net . basic . rest . activeconnection . ActiveConnectionRESTService ; import org . glyptodon . guacamole . net . basic . rest . language . LanguageRESTService ; import org . glyptodon . guacamole . net . basic . rest . schema . SchemaRESTService ; import org . glyptodon . guacamole . net . basic . rest . user . UserRESTService ; public class RESTServletModule extends ServletModule { @ Override protected void configureServlets ( ) { bindInterceptor ( Matchers . any ( ) , Matchers . annotatedWith ( AuthProviderRESTExposure . class ) , new AuthProviderRESTExceptionWrapper ( ) ) ; bind ( ObjectRetrievalService . class ) ; bind ( ActiveConnectionRESTService . class ) ; bind ( ClipboardRESTService . class ) ; bind ( ConnectionGroupRESTService . class ) ; bind ( ConnectionRESTService . class ) ; bind ( LanguageRESTService . class ) ; bind ( SchemaRESTService . class ) ; bind ( TokenRESTService . class ) ; bind ( UserRESTService . class ) ; bind ( GuiceContainer . class ) ; bind ( JacksonJsonProvider . class ) . in ( Scopes . SINGLETON ) ; serve ( "/api/*" ) . with ( GuiceContainer . class ) ; } }
package org . glyptodon . guacamole . net . basic . rest ; import java . util . Collection ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . Response ; import org . glyptodon . guacamole . form . Field ; public class APIException extends WebApplicationException { public APIException ( APIError error ) { super ( Response . status ( error . getType ( ) . getStatus ( ) ) . entity ( error ) . build ( ) ) ; } public APIException ( APIError . Type type , String message ) { this ( new APIError ( type , message ) ) ; } public APIException ( APIError . Type type , String message , Collection < Field > expected ) { this ( new APIError ( type , message , expected ) ) ; } }
package org . glyptodon . guacamole . net . basic . rest ; import org . glyptodon . guacamole . GuacamoleException ; import org . glyptodon . guacamole . GuacamoleResourceNotFoundException ; import org . glyptodon . guacamole . net . auth . Connection ; import org . glyptodon . guacamole . net . auth . ConnectionGroup ; import org . glyptodon . guacamole . net . auth . Directory ; import org . glyptodon . guacamole . net . auth . User ; import org . glyptodon . guacamole . net . auth . UserContext ; import org . glyptodon . guacamole . net . basic . rest . connectiongroup . APIConnectionGroup ; public class ObjectRetrievalService { public User retrieveUser ( UserContext userContext , String identifier ) throws GuacamoleException { Directory < User > directory = userContext . getUserDirectory ( ) ; User user = directory . get ( identifier ) ; if ( user == null ) throw new GuacamoleResourceNotFoundException ( "No such user: \"" + identifier + "\"" ) ; return user ; } public Connection retrieveConnection ( UserContext userContext , String identifier ) throws GuacamoleException { Directory < Connection > directory = userContext . getConnectionDirectory ( ) ; Connection connection = directory . get ( identifier ) ; if ( connection == null ) throw new GuacamoleResourceNotFoundException ( "No such connection: \"" + identifier + "\"" ) ; return connection ; } public ConnectionGroup retrieveConnectionGroup ( UserContext userContext , String identifier ) throws GuacamoleException { if ( identifier != null && identifier . equals ( APIConnectionGroup . ROOT_IDENTIFIER ) ) return userContext . getRootConnectionGroup ( ) ; Directory < ConnectionGroup > directory = userContext . getConnectionGroupDirectory ( ) ; ConnectionGroup connectionGroup = directory . get ( identifier ) ; if ( connectionGroup == null ) throw new GuacamoleResourceNotFoundException ( "No such connection group: \"" + identifier + "\"" ) ; return connectionGroup ; } }
package org . glyptodon . guacamole . net . basic . rest ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . METHOD } ) public @ interface AuthProviderRESTExposure { }
package org . glyptodon . guacamole ; import org . glyptodon . guacamole . protocol . GuacamoleStatus ; public class GuacamoleSecurityException extends GuacamoleClientException { public GuacamoleSecurityException ( String message , Throwable cause ) { super ( message , cause ) ; } public GuacamoleSecurityException ( String message ) { super ( message ) ; } public GuacamoleSecurityException ( Throwable cause ) { super ( cause ) ; } @ Override public GuacamoleStatus getStatus ( ) { return GuacamoleStatus . CLIENT_FORBIDDEN ; } }
