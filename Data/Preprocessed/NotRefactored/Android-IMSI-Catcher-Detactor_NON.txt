package com . stericson . RootShellTests ; import com . stericson . RootShell . containers . RootClass ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; @ RootClass . Candidate public class NativeJavaClass { public NativeJavaClass ( RootClass . RootArgs args ) { System . out . println ( "NativeJavaClass says: oh hi there." ) ; String p = "/data/data/com.android.browser/cache" ; File f = new File ( p ) ; String [ ] fl = f . list ( ) ; if ( fl != null ) { System . out . println ( "Look at all the stuff in your browser's cache:" ) ; for ( String af : fl ) { System . out . println ( "-" + af ) ; } System . out . println ( "Leaving my mark for posterity..." ) ; File f2 = new File ( p + "/rootshell_was_here" ) ; try { FileWriter filewriter = new FileWriter ( f2 ) ; BufferedWriter out = new BufferedWriter ( filewriter ) ; out . write ( "This is just a file created using RootShell's Sanity check tools..\n" ) ; out . close ( ) ; System . out . println ( "Done!" ) ; } catch ( IOException e ) { System . out . println ( "...and I failed miserably." ) ; e . printStackTrace ( ) ; } } } }
package com . SecUpwN . AIMSICD . activities ; import android . app . Activity ; import android . graphics . drawable . Drawable ; import android . os . Bundle ; import android . view . MotionEvent ; import android . view . Window ; import android . widget . ImageView ; import android . widget . TextView ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . utils . MiscUtils ; public class CustomPopUp extends Activity { TextView tv_popup_title , about_tv_status , about_tv_data ; ImageView about_icon_holder ; int mode = 0 ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestWindowFeature ( Window . FEATURE_NO_TITLE ) ; setContentView ( R . layout . about_pop_up ) ; about_icon_holder = ( ImageView ) findViewById ( R . id . about_icon_holder ) ; about_tv_status = ( TextView ) findViewById ( R . id . about_tv_status ) ; about_tv_data = ( TextView ) findViewById ( R . id . about_tv_data ) ; tv_popup_title = ( TextView ) findViewById ( R . id . tv_popup_title ) ; Bundle extras = getIntent ( ) . getExtras ( ) ; if ( extras != null ) { mode = extras . getInt ( "display_mode" ) ; } setFinishOnTouchOutside ( true ) ; switch ( mode ) { case 0 : createPopUp ( null , getString ( R . string . status ) + "\t" + getString ( R . string . idle ) , getResources ( ) . getString ( R . string . detail_info_idle ) , getResources ( ) . getDrawable ( R . drawable . sense_idle ) ) ; break ; case 1 : createPopUp ( null , getString ( R . string . status ) + "\t" + getString ( R . string . normal ) , getResources ( ) . getString ( R . string . detail_info_normal ) , getResources ( ) . getDrawable ( R . drawable . sense_ok ) ) ; break ; case 2 : createPopUp ( null , getString ( R . string . status ) + "\t" + getString ( R . string . medium ) , getResources ( ) . getString ( R . string . detail_info_medium ) , getResources ( ) . getDrawable ( R . drawable . sense_medium ) ) ; break ; case 3 : createPopUp ( null , getString ( R . string . status ) + "\t" + getString ( R . string . high ) , getResources ( ) . getString ( R . string . detail_info_high ) , getResources ( ) . getDrawable ( R . drawable . sense_high ) ) ; break ; case 4 : createPopUp ( null , getString ( R . string . status ) + "\t" + getString ( R . string . danger ) , getResources ( ) . getString ( R . string . detail_info_danger ) , getResources ( ) . getDrawable ( R . drawable . sense_danger ) ) ; break ; case 5 : createPopUp ( null , getString ( R . string . status ) + "\t" + getString ( R . string . run ) , getResources ( ) . getString ( R . string . detail_info_run ) , getResources ( ) . getDrawable ( R . drawable . sense_skull ) ) ; break ; case 6 : MiscUtils . showNotification ( getApplicationContext ( ) , getResources ( ) . getString ( R . string . alert_silent_sms_detected ) , getResources ( ) . getString ( R . string . app_name_short ) + " - " + getResources ( ) . getString ( R . string . typezero_header ) , R . drawable . sense_danger , true ) ; createPopUp ( getResources ( ) . getString ( R . string . typezero_title ) , getResources ( ) . getString ( R . string . typezero_header ) , getResources ( ) . getString ( R . string . typezero_data ) , getResources ( ) . getDrawable ( R . drawable . sense_danger ) ) ; break ; case 7 : MiscUtils . showNotification ( getApplicationContext ( ) , getResources ( ) . getString ( R . string . alert_silent_voice_sms_detected ) , getResources ( ) . getString ( R . string . app_name_short ) + " - " + getResources ( ) . getString ( R . string . typevoice_header ) , R . drawable . sense_danger , true ) ; createPopUp ( getResources ( ) . getString ( R . string . typevoice_title ) , getResources ( ) . getString ( R . string . typevoice_header ) , getResources ( ) . getString ( R . string . typevoice_data ) , getResources ( ) . getDrawable ( R . drawable . sense_danger ) ) ; break ; case 8 : MiscUtils . showNotification ( getApplicationContext ( ) , getResources ( ) . getString ( R . string . alert_silent_wap_sms_detected ) , getResources ( ) . getString ( R . string . app_name_short ) + " - " + getResources ( ) . getString ( R . string . typewap_header ) , R . drawable . sense_danger , true ) ; createPopUp ( getResources ( ) . getString ( R . string . typevoice_title ) , getResources ( ) . getString ( R . string . typewap_header ) , getResources ( ) . getString ( R . string . typewap_data ) , getResources ( ) . getDrawable ( R . drawable . sense_danger ) ) ; break ; } } public void createPopUp ( String title , String header , String data , Drawable icon ) { if ( title != null ) { tv_popup_title . setText ( title ) ; } if ( header != null ) { about_tv_status . setText ( header ) ; } if ( data != null ) { about_tv_data . setText ( data ) ; } if ( icon != null ) { about_icon_holder . setImageDrawable ( icon ) ; } } public boolean onTouchEvent ( MotionEvent event ) { switch ( event . getAction ( ) ) { case MotionEvent . ACTION_DOWN : if ( mode == 6 || mode == 7 || mode == 8 ) { MiscUtils . showNotification ( getApplicationContext ( ) , getResources ( ) . getString ( R . string . app_name_short ) , getResources ( ) . getString ( R . string . app_name_short ) + " - " + getResources ( ) . getString ( R . string . status_good ) , R . drawable . sense_ok , false ) ; } finish ( ) ; } return true ; } }
package com . SecUpwN . AIMSICD . activities ; import com . SecUpwN . AIMSICD . fragments . MapPrefFragment ; import android . app . FragmentManager ; import android . app . FragmentTransaction ; import android . os . Bundle ; public class MapPrefActivity extends BaseActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; MapPrefFragment settingsFragment = new MapPrefFragment ( ) ; FragmentManager fragmentManager = getFragmentManager ( ) ; FragmentTransaction fragmentTransaction = fragmentManager . beginTransaction ( ) ; fragmentTransaction . replace ( android . R . id . content , settingsFragment ) ; fragmentTransaction . commit ( ) ; } }
package com . SecUpwN . AIMSICD . activities ; import android . content . ClipData ; import android . content . ClipboardManager ; import android . content . Intent ; import android . os . Bundle ; import android . support . v4 . app . NavUtils ; import android . util . Log ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . widget . Button ; import android . widget . ScrollView ; import android . widget . TextView ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . utils . Helpers ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class DebugLogs extends BaseActivity { private LogUpdaterThread logUpdater = null ; private boolean updateLogs = true ; private boolean isRadioLogs = true ; private TextView logView = null ; private Button btnClear = null ; private Button btnCopy = null ; private Button btnStop = null ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_debug_logs ) ; getActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; logView = ( TextView ) findViewById ( R . id . debug_log_view ) ; btnClear = ( Button ) findViewById ( R . id . btnClear ) ; btnStop = ( Button ) findViewById ( R . id . btnStopLogs ) ; btnCopy = ( Button ) findViewById ( R . id . btnCopy ) ; runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { logView . setFocusable ( false ) ; } } ) ; btnClear . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { try { clearLogs ( ) ; } catch ( Exception e ) { Log . e ( "AIMSICD" , "DebugLogs: Error clearing logs" , e ) ; } } } ) ; btnCopy . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { ClipboardManager clipboard = ( ClipboardManager ) getSystemService ( CLIPBOARD_SERVICE ) ; ClipData cd = ClipData . newPlainText ( "log" , logView . getText ( ) ) ; clipboard . setPrimaryClip ( cd ) ; Helpers . msgShort ( DebugLogs . this , getString ( R . string . msg_copied_to_clipboard ) ) ; } } ) ; btnStop . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { if ( updateLogs ) { updateLogs = false ; btnStop . setText ( getString ( R . string . btn_start_logs ) ) ; } else { startLogging ( ) ; } } } ) ; } @ Override protected void onPause ( ) { updateLogs = false ; super . onPause ( ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; startLogging ( ) ; } private void startLogging ( ) { updateLogs = true ; try { logUpdater = new LogUpdaterThread ( ) ; logUpdater . start ( ) ; } catch ( Exception e ) { Log . e ( "AIMSICD" , "DebugLogs: Error starting log updater thread" , e ) ; } btnStop . setText ( getString ( R . string . btn_stop_logs ) ) ; } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . activity_debug_logs , menu ) ; return true ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case R . id . action_send_logs : sendEmail ( ) ; return true ; case android . R . id . home : NavUtils . navigateUpFromSameTask ( this ) ; return true ; } return super . onOptionsItemSelected ( item ) ; } public void sendEmail ( ) { new Thread ( ) { @ Override public void run ( ) { try { String helpUs = getString ( R . string . describe_the_problem_you_had ) ; String log = helpUs + "\n\n" + "GETPROP:" + "\n\n" + getProp ( ) + "\n\n" + "LOGCAT:" + "\n\n" + getLogs ( ) + "\n\n" + helpUs ; Intent intent = new Intent ( Intent . ACTION_SEND ) ; intent . setType ( "text/html" ) ; intent . putExtra ( Intent . EXTRA_EMAIL , new String [ ] { "SecUpwN[-AT-]protonmail.ch" } ) ; intent . putExtra ( Intent . EXTRA_SUBJECT , "AIMSICD Error Log" ) ; intent . putExtra ( Intent . EXTRA_TEXT , log ) ; startActivity ( Intent . createChooser ( intent , "Send Error Log" ) ) ; } catch ( IOException e ) { Log . e ( "AIMSICD" , "DebugLogs: Error reading logs" , e ) ; } } } . start ( ) ; } public String getProp ( ) throws IOException { return runProcess ( "/system/bin/getprop" ) ; } private String getLogs ( ) throws IOException { return runProcess ( "logcat -t 500 -v brief -b main" + ( isRadioLogs ? " -b radio RILQ:S" : "" ) + " AbsListView:S PackageInfo:S" + " LocSvc_eng:S LocSvc_adapter:S LocSvc_afw:S" + " QC-QMI:S AudioPolicyManager:S" + " *:D" ) ; } private String runProcess ( String command ) throws IOException { return runProcess ( new String [ ] { command } ) ; } private String runProcess ( String [ ] command ) throws IOException { Process process = null ; if ( command . length == 1 ) process = Runtime . getRuntime ( ) . exec ( command [ 0 ] ) ; else Runtime . getRuntime ( ) . exec ( command ) ; BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; StringBuilder log = new StringBuilder ( ) ; String line ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { log . append ( line ) ; log . append ( "\n" ) ; } return log . toString ( ) ; } private void clearLogs ( ) throws IOException { new Thread ( ) { @ Override public void run ( ) { try { Runtime . getRuntime ( ) . exec ( "logcat -c -b main -b system -b radio -b events" ) ; } catch ( Exception e ) { Log . e ( "AIMSICD" , "DebugLogs: Error clearing logs" , e ) ; } runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { logView . setText ( "" ) ; } } ) ; } } . start ( ) ; } class LogUpdaterThread extends Thread { @ Override public void run ( ) { while ( updateLogs ) { try { final String logs = getLogs ( ) ; if ( ! logs . equals ( logView . getText ( ) . toString ( ) ) ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { logView . setText ( logs ) ; final ScrollView scroll = ( ( ScrollView ) logView . getParent ( ) ) ; scroll . post ( new Runnable ( ) { @ Override public void run ( ) { scroll . fullScroll ( View . FOCUS_DOWN ) ; } } ) ; } } ) ; } } catch ( Exception e ) { Log . e ( "AIMSICD" , "DebugLogs: Error updating logs" , e ) ; } try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { } } } } }
package com . SecUpwN . AIMSICD . activities ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . SharedPreferences ; import android . support . v4 . app . FragmentActivity ; import android . support . v4 . content . LocalBroadcastManager ; import android . util . Log ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . service . AimsicdService ; import com . SecUpwN . AIMSICD . utils . Icon ; import com . SecUpwN . AIMSICD . utils . Status ; public class BaseActivity extends FragmentActivity { private static String TAG = "BaseActivity" ; @ Override protected void onResume ( ) { super . onResume ( ) ; Log . d ( TAG , "StatusWatcher starting watching" ) ; LocalBroadcastManager . getInstance ( this ) . registerReceiver ( mMessageReceiver , new IntentFilter ( "StatusChange" ) ) ; updateIcon ( this ) ; } private BroadcastReceiver mMessageReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { Log . d ( TAG , "StatusWatcher received status change to " + Status . getStatus ( ) . name ( ) + ", updating icon" ) ; updateIcon ( context ) ; } } ; private void updateIcon ( Context context ) { SharedPreferences prefs = context . getSharedPreferences ( AimsicdService . SHARED_PREFERENCES_BASENAME , 0 ) ; final String iconType = prefs . getString ( context . getString ( R . string . pref_ui_icons_key ) , "SENSE" ) . toUpperCase ( ) ; runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( getActionBar ( ) != null ) { getActionBar ( ) . setIcon ( Icon . getIcon ( Icon . Type . valueOf ( iconType ) ) ) ; } } } ) ; } @ Override protected void onPause ( ) { super . onPause ( ) ; Log . d ( TAG , "StatusWatcher stopped watching" ) ; LocalBroadcastManager . getInstance ( this ) . unregisterReceiver ( mMessageReceiver ) ; } }
package com . SecUpwN . AIMSICD . receiver ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . service . AimsicdService ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . util . Log ; public class BootCompletedReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { SharedPreferences prefs = context . getSharedPreferences ( AimsicdService . SHARED_PREFERENCES_BASENAME , 0 ) ; final String AUTO_START = context . getString ( R . string . pref_autostart_key ) ; boolean mAutoStart = prefs . getBoolean ( AUTO_START , false ) ; if ( mAutoStart ) { Log . i ( "AIMSICD" , "System booted starting service." ) ; context . startService ( new Intent ( context , AimsicdService . class ) ) ; } } }
package com . SecUpwN . AIMSICD . receiver ; import com . SecUpwN . AIMSICD . service . AimsicdService ; import com . SecUpwN . AIMSICD . service . CellTracker ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import android . telephony . SmsMessage ; import android . util . Log ; import java . util . ArrayList ; import java . util . List ; public class SmsReceiver extends BroadcastReceiver { public void onReceive ( Context context , Intent intent ) { try { final Bundle bundle = intent . getExtras ( ) ; if ( bundle != null ) { Object [ ] pdus = ( Object [ ] ) bundle . get ( "pdus" ) ; final List < SmsMessage > messages = new ArrayList < > ( ) ; StringBuilder sb = new StringBuilder ( ) ; String full_pdu_string = "" ; for ( Object pdu : pdus ) { byte smsPdu [ ] = ( byte [ ] ) pdu ; try { for ( int xx = 0 ; xx < smsPdu . length ; xx ++ ) { String test = Integer . toHexString ( smsPdu [ xx ] & 0xff ) ; if ( test . length ( ) <= 1 ) { test = "0" + test ; } sb . append ( test ) ; } full_pdu_string = sb . toString ( ) ; } catch ( Exception err ) { Log . e ( "SmsReceiver" , "Exception PDU smsReceiver" + err ) ; } int firstByte = smsPdu [ 0 ] & 0xff ; int mti = firstByte & 0x3 ; int pID = smsPdu [ 1 ] & 0xc0 ; Log . i ( "AIMSICD_SmsReceiver" , "PDU Data: firstByte: " + firstByte + " TP-MTI: " + mti + " TP-PID: " + pID ) ; if ( pID == 0x40 && mti == 0 ) { messages . add ( SmsMessage . createFromPdu ( ( byte [ ] ) pdu ) ) ; } } if ( messages . size ( ) > 0 ) { for ( SmsMessage sms : messages ) { Intent smsIntent = new Intent ( CellTracker . SILENT_SMS ) ; Bundle smsData = new Bundle ( ) ; smsData . putString ( "address" , sms . getOriginatingAddress ( ) ) ; smsData . putString ( "display_address" , sms . getDisplayOriginatingAddress ( ) ) ; smsData . putString ( "class" , sms . getMessageClass ( ) . name ( ) ) ; smsData . putString ( "service_centre" , sms . getServiceCenterAddress ( ) ) ; smsData . putString ( "message" , sms . getMessageBody ( ) ) ; smsIntent . putExtras ( smsData ) ; context . sendBroadcast ( smsIntent ) ; Log . i ( "AIMSICD_SmsReceiver" , "Type-0 SMS received! Sender: " + sms . getOriginatingAddress ( ) + " Message: " + sms . getMessageBody ( ) ) ; } } } } catch ( NullPointerException npe ) { Log . e ( "SmsReceiver" , "Exception smsReceiver" + npe ) ; } } }
package com . SecUpwN . AIMSICD . test ; import android . test . AndroidTestCase ; import com . SecUpwN . AIMSICD . adapters . AIMSICDDbAdapter ; import com . SecUpwN . AIMSICD . utils . Cell ; public class Detection1 extends AndroidTestCase { AIMSICDDbAdapter dbHelper ; public final static int CELL_ID = 123456 ; @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; dbHelper = new AIMSICDDbAdapter ( getContext ( ) ) ; dbHelper . open ( ) ; } @ Override protected void tearDown ( ) throws Exception { dbHelper . close ( ) ; super . tearDown ( ) ; } public void testChangingLAC ( ) { dbHelper . deleteCell ( CELL_ID ) ; Cell cell = new Cell ( ) ; cell . setCID ( CELL_ID ) ; cell . setLat ( 21.00 ) ; cell . setLon ( 21.00 ) ; cell . setLAC ( 123 ) ; long recId = dbHelper . insertCell ( cell ) ; assertTrue ( recId != 0l ) ; assertTrue ( dbHelper . checkLAC ( cell ) ) ; cell = new Cell ( ) ; cell . setCID ( CELL_ID ) ; cell . setLAC ( 234 ) ; assertFalse ( dbHelper . checkLAC ( cell ) ) ; } }
package com . SecUpwN . AIMSICD ; import android . app . ActionBar ; import android . app . AlertDialog ; import android . content . ComponentName ; import android . content . ContentValues ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . ServiceConnection ; import android . content . SharedPreferences ; import android . content . SharedPreferences . Editor ; import android . content . res . Configuration ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . net . Uri ; import android . os . Bundle ; import android . os . Environment ; import android . os . IBinder ; import android . provider . MediaStore ; import android . support . v4 . app . ActionBarDrawerToggle ; import android . support . v4 . content . ContextCompat ; import android . support . v4 . widget . DrawerLayout ; import android . telephony . TelephonyManager ; import android . util . Log ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . view . Window ; import android . widget . AdapterView ; import android . widget . ListView ; import android . widget . ProgressBar ; import android . widget . Toast ; import com . SecUpwN . AIMSICD . activities . BaseActivity ; import com . SecUpwN . AIMSICD . activities . DebugLogs ; import com . SecUpwN . AIMSICD . activities . MapViewerOsmDroid ; import com . SecUpwN . AIMSICD . activities . PrefActivity ; import com . SecUpwN . AIMSICD . adapters . AIMSICDDbAdapter ; import com . SecUpwN . AIMSICD . adapters . DrawerMenuAdapter ; import com . SecUpwN . AIMSICD . constants . DrawerMenu ; import com . SecUpwN . AIMSICD . drawer . DrawerMenuActivityConfiguration ; import com . SecUpwN . AIMSICD . drawer . DrawerMenuItem ; import com . SecUpwN . AIMSICD . drawer . DrawerMenuSection ; import com . SecUpwN . AIMSICD . drawer . NavDrawerItem ; import com . SecUpwN . AIMSICD . fragments . AboutFragment ; import com . SecUpwN . AIMSICD . fragments . AtCommandFragment ; import com . SecUpwN . AIMSICD . fragments . DetailsContainerFragment ; import com . SecUpwN . AIMSICD . service . AimsicdService ; import com . SecUpwN . AIMSICD . service . CellTracker ; import com . SecUpwN . AIMSICD . smsdetection . SmsDetectionDbAccess ; import com . SecUpwN . AIMSICD . smsdetection . SmsDetectionDbHelper ; import com . SecUpwN . AIMSICD . utils . AsyncResponse ; import com . SecUpwN . AIMSICD . utils . Cell ; import com . SecUpwN . AIMSICD . utils . GeoLocation ; import com . SecUpwN . AIMSICD . utils . Helpers ; import com . SecUpwN . AIMSICD . utils . Icon ; import com . SecUpwN . AIMSICD . utils . LocationServices ; import com . SecUpwN . AIMSICD . utils . MiscUtils ; import com . SecUpwN . AIMSICD . utils . RequestTask ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . net . URL ; import java . util . ArrayList ; import java . util . List ; public class AIMSICD extends BaseActivity implements AsyncResponse { private final String TAG = "AIMSICD" ; private final Context mContext = this ; private boolean mBound ; private SharedPreferences prefs ; private SharedPreferences . OnSharedPreferenceChangeListener prefListener ; private Editor prefsEditor ; private String mDisclaimerAccepted ; private AimsicdService mAimsicdService ; private DrawerLayout mDrawerLayout ; private ActionBar mActionBar ; private ListView mDrawerList ; private ActionBarDrawerToggle mDrawerToggle ; private CharSequence mDrawerTitle ; private CharSequence mTitle ; public static ProgressBar mProgressBar ; SmsDetectionDbHelper dbhelper ; private long mLastPress = 0 ; private DrawerMenuActivityConfiguration mNavConf ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; MiscUtils . refreshDetectionDbStrings ( getApplicationContext ( ) ) ; moveData ( ) ; getWindow ( ) . requestFeature ( Window . FEATURE_INDETERMINATE_PROGRESS ) ; mNavConf = new DrawerMenuActivityConfiguration . Builder ( this ) . build ( ) ; setContentView ( mNavConf . getMainLayout ( ) ) ; dbhelper = new SmsDetectionDbHelper ( this ) ; mDrawerLayout = ( DrawerLayout ) findViewById ( mNavConf . getDrawerLayoutId ( ) ) ; mDrawerList = ( ListView ) findViewById ( mNavConf . getLeftDrawerId ( ) ) ; mActionBar = getActionBar ( ) ; mTitle = mDrawerTitle = getTitle ( ) ; mDrawerList . setAdapter ( mNavConf . getBaseAdapter ( ) ) ; mDrawerToggle = new ActionBarDrawerToggle ( this , mDrawerLayout , R . drawable . ic_drawer , R . string . drawer_open , R . string . drawer_close ) { public void onDrawerClosed ( View view ) { super . onDrawerClosed ( view ) ; mActionBar . setTitle ( mTitle ) ; invalidateOptionsMenu ( ) ; } public void onDrawerOpened ( View drawerView ) { super . onDrawerOpened ( drawerView ) ; mActionBar . setTitle ( mDrawerTitle ) ; invalidateOptionsMenu ( ) ; } } ; mDrawerList . setOnItemClickListener ( new DrawerItemClickListener ( ) ) ; mDrawerLayout . setDrawerListener ( mDrawerToggle ) ; mActionBar . setDisplayHomeAsUpEnabled ( true ) ; mActionBar . setHomeButtonEnabled ( true ) ; mProgressBar = ( ProgressBar ) findViewById ( R . id . progressBar ) ; prefs = mContext . getSharedPreferences ( AimsicdService . SHARED_PREFERENCES_BASENAME , 0 ) ; prefListener = new SharedPreferences . OnSharedPreferenceChangeListener ( ) { public void onSharedPreferenceChanged ( SharedPreferences prefs , String key ) { if ( key . equals ( mContext . getString ( R . string . adv_user_root_pref_key ) ) ) { SmsDetection ( ) ; } } } ; prefs . registerOnSharedPreferenceChangeListener ( prefListener ) ; mDisclaimerAccepted = getResources ( ) . getString ( R . string . disclaimer_accepted ) ; if ( ! prefs . getBoolean ( mDisclaimerAccepted , false ) ) { final AlertDialog . Builder disclaimer = new AlertDialog . Builder ( this ) . setTitle ( R . string . disclaimer_title ) . setMessage ( R . string . disclaimer ) . setPositiveButton ( R . string . text_agree , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { prefsEditor = prefs . edit ( ) ; prefsEditor . putBoolean ( mDisclaimerAccepted , true ) ; prefsEditor . apply ( ) ; startService ( ) ; } } ) . setNegativeButton ( R . string . text_disagree , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { prefsEditor = prefs . edit ( ) ; prefsEditor . putBoolean ( mDisclaimerAccepted , false ) ; prefsEditor . apply ( ) ; Uri packageUri = Uri . parse ( "package:com.SecUpwN.AIMSICD" ) ; Intent uninstallIntent = new Intent ( Intent . ACTION_DELETE , packageUri ) ; startActivity ( uninstallIntent ) ; finish ( ) ; if ( mAimsicdService != null ) mAimsicdService . onDestroy ( ) ; } } ) ; AlertDialog disclaimerAlert = disclaimer . create ( ) ; disclaimerAlert . show ( ) ; } else { startService ( ) ; } } @ Override protected void onPostCreate ( Bundle savedInstanceState ) { super . onPostCreate ( savedInstanceState ) ; final String iconType = prefs . getString ( mContext . getString ( R . string . pref_ui_icons_key ) , "SENSE" ) . toUpperCase ( ) ; mActionBar . setIcon ( Icon . getIcon ( Icon . Type . valueOf ( iconType ) ) ) ; mDrawerToggle . syncState ( ) ; } @ Override public void onConfigurationChanged ( Configuration newConfig ) { super . onConfigurationChanged ( newConfig ) ; mDrawerToggle . onConfigurationChanged ( newConfig ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; if ( mBound ) { unbindService ( mConnection ) ; mBound = false ; } final String PERSIST_SERVICE = mContext . getString ( R . string . pref_persistservice_key ) ; boolean persistService = prefs . getBoolean ( PERSIST_SERVICE , false ) ; if ( ! persistService ) { stopService ( new Intent ( mContext , AimsicdService . class ) ) ; } } private class DrawerItemClickListener implements ListView . OnItemClickListener { @ Override public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { mDrawerLayout . closeDrawer ( mDrawerList ) ; selectItem ( position ) ; } } void selectItem ( int position ) { NavDrawerItem selectedItem = mNavConf . getNavItems ( ) . get ( position ) ; String title = selectedItem . getLabel ( ) ; DetailsContainerFragment mDetailsFrag = new DetailsContainerFragment ( ) ; switch ( selectedItem . getId ( ) ) { case DrawerMenu . ID . MAIN . PHONE_SIM_DETAILS : getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . content_frame , mDetailsFrag ) . commit ( ) ; mDetailsFrag . setCurrentPage ( 0 ) ; title = getString ( R . string . app_name_short ) ; break ; case DrawerMenu . ID . MAIN . CURRENT_TREAT_LEVEL : getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . content_frame , mDetailsFrag ) . commit ( ) ; mDetailsFrag . setCurrentPage ( 1 ) ; title = getString ( R . string . app_name_short ) ; break ; case DrawerMenu . ID . MAIN . AT_COMMAND_INTERFACE : getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . content_frame , new AtCommandFragment ( ) ) . commit ( ) ; break ; case DrawerMenu . ID . MAIN . DB_VIEWER : getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . content_frame , mDetailsFrag ) . commit ( ) ; mDetailsFrag . setCurrentPage ( 2 ) ; title = getString ( R . string . app_name_short ) ; break ; case DrawerMenu . ID . APPLICATION . ABOUT : getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . content_frame , new AboutFragment ( ) ) . commit ( ) ; break ; case DrawerMenu . ID . APPLICATION . UPLOAD_LOCAL_BST_DATA : new RequestTask ( mContext , com . SecUpwN . AIMSICD . utils . RequestTask . DBE_UPLOAD_REQUEST ) . execute ( "" ) ; break ; } if ( selectedItem . getId ( ) == DrawerMenu . ID . TRACKING . TOGGLE_AIMSICD_MONITORING ) { monitorcell ( ) ; } else if ( selectedItem . getId ( ) == DrawerMenu . ID . TRACKING . TOGGLE_2G_ONLY_NETWORK ) { trackcell ( ) ; } else if ( selectedItem . getId ( ) == DrawerMenu . ID . TRACKING . TRACK_FEMTOCELL ) { trackFemtocell ( ) ; } else if ( selectedItem . getId ( ) == DrawerMenu . ID . MAIN . ANTENNA_MAP_VIEW ) { showmap ( ) ; } else if ( selectedItem . getId ( ) == DrawerMenu . ID . SETTINGS . PREFERENCES ) { Intent intent = new Intent ( this , PrefActivity . class ) ; startActivity ( intent ) ; } else if ( selectedItem . getId ( ) == DrawerMenu . ID . SETTINGS . BACKUP_DB ) { new RequestTask ( mContext , RequestTask . BACKUP_DATABASE ) . execute ( ) ; } else if ( selectedItem . getId ( ) == DrawerMenu . ID . SETTINGS . RESTORE_DB ) { if ( CellTracker . LAST_DB_BACKUP_VERSION < AIMSICDDbAdapter . DATABASE_VERSION ) { Helpers . msgLong ( mContext , getString ( R . string . unable_to_restore_backup_from_previous_database_version ) ) ; } else { new RequestTask ( mContext , RequestTask . RESTORE_DATABASE ) . execute ( ) ; } } else if ( selectedItem . getId ( ) == DrawerMenu . ID . SETTINGS . RESET_DB ) { Helpers . askAndDeleteDb ( this ) ; } else if ( selectedItem . getId ( ) == DrawerMenu . ID . APPLICATION . DOWNLOAD_LOCAL_BST_DATA ) { if ( CellTracker . OCID_API_KEY != null && ! CellTracker . OCID_API_KEY . equals ( "NA" ) ) { GeoLocation loc = mAimsicdService . lastKnownLocation ( ) ; if ( loc != null ) { Helpers . msgLong ( mContext , mContext . getString ( R . string . contacting_opencellid_for_data ) ) ; Cell cell = new Cell ( ) ; cell . setLon ( loc . getLongitudeInDegrees ( ) ) ; cell . setLat ( loc . getLatitudeInDegrees ( ) ) ; Helpers . getOpenCellData ( mContext , cell , RequestTask . DBE_DOWNLOAD_REQUEST ) ; } else { Helpers . msgShort ( mContext , getString ( R . string . waiting_for_location ) ) ; LocationServices . LocationAsync locationAsync = new LocationServices . LocationAsync ( ) ; locationAsync . delegate = this ; locationAsync . execute ( mAimsicdService . getCell ( ) . getCID ( ) , mAimsicdService . getCell ( ) . getLAC ( ) , mAimsicdService . getCell ( ) . getMNC ( ) , mAimsicdService . getCell ( ) . getMCC ( ) ) ; } } else { Helpers . sendMsg ( mContext , mContext . getString ( R . string . no_opencellid_key_detected ) ) ; } } else if ( selectedItem . getId ( ) == DrawerMenu . ID . MAIN . ACD ) { if ( CellTracker . OCID_API_KEY != null && ! CellTracker . OCID_API_KEY . equals ( "NA" ) ) { Cell . CellLookUpAsync cellLookUpAsync = new Cell . CellLookUpAsync ( ) ; cellLookUpAsync . delegate = this ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( "http://www.opencellid.org/cell/get?key=" ) . append ( CellTracker . OCID_API_KEY ) ; if ( mAimsicdService . getCell ( ) . getMCC ( ) != Integer . MAX_VALUE ) { sb . append ( "&mcc=" ) . append ( mAimsicdService . getCell ( ) . getMCC ( ) ) ; } if ( mAimsicdService . getCell ( ) . getMNC ( ) != Integer . MAX_VALUE ) { sb . append ( "&mnc=" ) . append ( mAimsicdService . getCell ( ) . getMNC ( ) ) ; } if ( mAimsicdService . getCell ( ) . getLAC ( ) != Integer . MAX_VALUE ) { sb . append ( "&lac=" ) . append ( mAimsicdService . getCell ( ) . getLAC ( ) ) ; } if ( mAimsicdService . getCell ( ) . getCID ( ) != Integer . MAX_VALUE ) { sb . append ( "&cellid=" ) . append ( mAimsicdService . getCell ( ) . getCID ( ) ) ; } sb . append ( "&format=xml" ) ; cellLookUpAsync . execute ( sb . toString ( ) ) ; } else { Helpers . sendMsg ( mContext , mContext . getString ( R . string . no_opencellid_key_detected ) ) ; } } else if ( selectedItem . getId ( ) == DrawerMenu . ID . APPLICATION . SEND_DEBUGGING_LOG ) { Intent i = new Intent ( this , DebugLogs . class ) ; startActivity ( i ) ; } else if ( selectedItem . getId ( ) == DrawerMenu . ID . APPLICATION . QUIT ) { finish ( ) ; } mDrawerList . setItemChecked ( position , true ) ; if ( selectedItem . updateActionBarTitle ( ) ) { setTitle ( title ) ; } if ( this . mDrawerLayout . isDrawerOpen ( this . mDrawerList ) ) { mDrawerLayout . closeDrawer ( mDrawerList ) ; } } @ Override public void processFinish ( float [ ] location ) { Log . i ( TAG , "processFinish - location[0]=" + location [ 0 ] + " location[1]=" + location [ 1 ] ) ; if ( location [ 0 ] != 0.0f && location [ 1 ] != 0.0f ) { Helpers . msgLong ( mContext , mContext . getString ( R . string . contacting_opencellid_for_data ) ) ; Helpers . getOpenCellData ( mContext , mAimsicdService . getCell ( ) , RequestTask . DBE_DOWNLOAD_REQUEST ) ; } else { Helpers . msgLong ( mContext , mContext . getString ( R . string . unable_to_determine_last_location ) ) ; } } @ Override public void processFinish ( List < Cell > cells ) { if ( cells != null ) { if ( ! cells . isEmpty ( ) ) { for ( Cell cell : cells ) { Log . i ( TAG , "processFinish - Cell =" + cell . toString ( ) ) ; if ( cell . isValid ( ) ) { mAimsicdService . setCell ( cell ) ; Intent intent = new Intent ( AimsicdService . UPDATE_DISPLAY ) ; intent . putExtra ( "update" , true ) ; mContext . sendBroadcast ( intent ) ; } } } } } @ Override public void setTitle ( CharSequence title ) { mTitle = title ; mActionBar . setTitle ( mTitle ) ; } private final ServiceConnection mConnection = new ServiceConnection ( ) { @ Override public void onServiceConnected ( ComponentName name , IBinder service ) { mAimsicdService = ( ( AimsicdService . AimscidBinder ) service ) . getService ( ) ; mBound = true ; if ( mAimsicdService . isTrackingCell ( ) ) { mAimsicdService . checkLocationServices ( ) ; } if ( ! mAimsicdService . isSmsTracking ( ) && prefs . getBoolean ( mContext . getString ( R . string . adv_user_root_pref_key ) , false ) ) { SmsDetection ( ) ; } } @ Override public void onServiceDisconnected ( ComponentName arg0 ) { Log . e ( TAG , "Service Disconnected" ) ; mBound = false ; } } ; private void startService ( ) { if ( ! prefs . getBoolean ( mDisclaimerAccepted , false ) ) return ; if ( ! mBound ) { Intent intent = new Intent ( AIMSICD . this , AimsicdService . class ) ; startService ( intent ) ; bindService ( intent , mConnection , Context . BIND_AUTO_CREATE ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . content_frame , new DetailsContainerFragment ( ) ) . commit ( ) ; } } @ Override public void onResume ( ) { super . onResume ( ) ; invalidateOptionsMenu ( ) ; startService ( ) ; } @ Override public void onPause ( ) { super . onPause ( ) ; } @ Override public boolean onPrepareOptionsMenu ( Menu menu ) { if ( mNavConf . getActionMenuItemsToHideWhenDrawerOpen ( ) != null ) { boolean drawerOpen = mDrawerLayout . isDrawerOpen ( mDrawerList ) ; for ( int iItem : mNavConf . getActionMenuItemsToHideWhenDrawerOpen ( ) ) { menu . findItem ( iItem ) . setVisible ( ! drawerOpen ) ; } } NavDrawerItem femtoTrackingItem = null ; NavDrawerItem cellMonitoringItem = null ; NavDrawerItem cellTrackingItem = null ; List < NavDrawerItem > menuItems = mNavConf . getNavItems ( ) ; for ( NavDrawerItem lItem : menuItems ) { if ( lItem . getId ( ) == DrawerMenu . ID . TRACKING . TOGGLE_AIMSICD_MONITORING ) { cellMonitoringItem = lItem ; } else if ( lItem . getId ( ) == DrawerMenu . ID . TRACKING . TOGGLE_2G_ONLY_NETWORK ) { cellTrackingItem = lItem ; } else if ( lItem . getId ( ) == DrawerMenu . ID . TRACKING . TRACK_FEMTOCELL ) { femtoTrackingItem = lItem ; } } if ( mBound ) { if ( cellMonitoringItem != null ) { if ( mAimsicdService . isMonitoringCell ( ) ) { cellMonitoringItem . setmIconId ( R . drawable . track_cell ) ; } else { cellMonitoringItem . setmIconId ( R . drawable . untrack_cell ) ; } mNavConf . getBaseAdapter ( ) . notifyDataSetChanged ( ) ; } if ( cellTrackingItem != null ) { if ( mAimsicdService . isTrackingCell ( ) ) { cellTrackingItem . setmIconId ( R . drawable . track_cell ) ; } else { cellTrackingItem . setmIconId ( R . drawable . untrack_cell ) ; } mNavConf . getBaseAdapter ( ) . notifyDataSetChanged ( ) ; } if ( femtoTrackingItem != null ) { if ( mAimsicdService . isTrackingFemtocell ( ) ) { femtoTrackingItem . setmIconId ( R . drawable . ic_action_network_cell ) ; } else { femtoTrackingItem . setmIconId ( R . drawable . ic_action_network_cell_not_tracked ) ; } mNavConf . getBaseAdapter ( ) . notifyDataSetChanged ( ) ; } } return super . onPrepareOptionsMenu ( menu ) ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { return mDrawerToggle . onOptionsItemSelected ( item ) || super . onOptionsItemSelected ( item ) ; } @ Override public void onBackPressed ( ) { Toast onBackPressedToast = Toast . makeText ( this , R . string . press_once_again_to_exit , Toast . LENGTH_SHORT ) ; long currentTime = System . currentTimeMillis ( ) ; if ( currentTime - mLastPress > 5000 ) { onBackPressedToast . show ( ) ; mLastPress = currentTime ; } else { onBackPressedToast . cancel ( ) ; super . onBackPressed ( ) ; try { if ( mAimsicdService . isSmsTracking ( ) ) { mAimsicdService . stopSmsTracking ( ) ; } } catch ( Exception ee ) { System . out . println ( "Error Stopping sms detection" ) ; } finish ( ) ; } } private void SmsDetection ( ) { boolean root_sms = prefs . getBoolean ( mContext . getString ( R . string . adv_user_root_pref_key ) , false ) ; if ( root_sms && ! mAimsicdService . isSmsTracking ( ) ) { mAimsicdService . startSmsTracking ( ) ; Helpers . msgShort ( mContext , "Sms Detection Started" ) ; Log . i ( TAG , "Sms Detection Thread Started" ) ; } else if ( ! root_sms && mAimsicdService . isSmsTracking ( ) ) { mAimsicdService . stopSmsTracking ( ) ; Helpers . msgShort ( mContext , "Sms Detection Stopped" ) ; Log . i ( TAG , "Sms Detection Thread Stopped" ) ; } } private void showmap ( ) { Intent myIntent = new Intent ( this , MapViewerOsmDroid . class ) ; startActivity ( myIntent ) ; } private void trackcell ( ) { if ( mAimsicdService . isTrackingCell ( ) ) { mAimsicdService . setCellTracking ( false ) ; } else { mAimsicdService . setCellTracking ( true ) ; } } private void monitorcell ( ) { if ( mAimsicdService . isMonitoringCell ( ) ) { mAimsicdService . setCellMonitoring ( false ) ; } else { mAimsicdService . setCellMonitoring ( true ) ; } } private void trackFemtocell ( ) { if ( mAimsicdService . isTrackingFemtocell ( ) ) { mAimsicdService . setTrackingFemtocell ( false ) ; } else { mAimsicdService . setTrackingFemtocell ( true ) ; } } public void showProgressbar ( final boolean indeterminate , final int max , final int progress ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { mProgressBar . setIndeterminate ( indeterminate ) ; if ( max > 0 ) mProgressBar . setMax ( max ) ; if ( max > 0 && progress >= 0 ) mProgressBar . setProgress ( progress ) ; mProgressBar . setVisibility ( View . VISIBLE ) ; } } ) ; } public void hideProgressbar ( ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { mProgressBar . setMax ( 0 ) ; mProgressBar . setProgress ( 0 ) ; mProgressBar . setVisibility ( View . GONE ) ; } } ) ; } public void onStop ( ) { super . onStop ( ) ; ( ( AppAIMSICD ) getApplication ( ) ) . detach ( this ) ; } @ Override public void onStart ( ) { super . onStart ( ) ; ( ( AppAIMSICD ) getApplication ( ) ) . attach ( this ) ; } private void moveData ( ) { File destinedPath = new File ( getExternalFilesDir ( null ) + File . separator ) ; File currentPath = new File ( Environment . getExternalStorageDirectory ( ) . toString ( ) + "/AIMSICD" ) ; if ( currentPath . exists ( ) ) { if ( currentPath . isDirectory ( ) ) { File [ ] content = currentPath . listFiles ( ) ; for ( int i = 0 ; i < content . length ; i ++ ) { File from = new File ( content [ i ] . toString ( ) ) ; from . renameTo ( new File ( destinedPath . toString ( ) + content [ i ] . getName ( ) . toString ( ) ) ) ; } } currentPath . delete ( ) ; } } }
package com . SecUpwN . AIMSICD ; import android . app . Activity ; import android . app . Application ; import android . util . Log ; import android . util . SparseArray ; import com . SecUpwN . AIMSICD . constants . TinyDbKeys ; import com . SecUpwN . AIMSICD . utils . BaseAsyncTask ; import com . SecUpwN . AIMSICD . utils . TinyDB ; import com . squareup . leakcanary . LeakCanary ; import java . util . ArrayList ; import java . util . List ; public class AppAIMSICD extends Application { final static String TAG = "AppAIMSICD" ; private SparseArray < List < BaseAsyncTask < ? , ? , ? > > > mActivityTaskMap ; public AppAIMSICD ( ) { mActivityTaskMap = new SparseArray < > ( ) ; } @ Override public void onCreate ( ) { super . onCreate ( ) ; LeakCanary . install ( this ) ; TinyDB . getInstance ( ) . init ( getApplicationContext ( ) ) ; TinyDB . getInstance ( ) . putBoolean ( TinyDbKeys . FINISHED_LOAD_IN_MAP , true ) ; } public void removeTask ( BaseAsyncTask < ? , ? , ? > pTask ) { int key ; for ( int i = 0 ; i < mActivityTaskMap . size ( ) ; i ++ ) { key = mActivityTaskMap . keyAt ( i ) ; List < BaseAsyncTask < ? , ? , ? > > tasks = mActivityTaskMap . get ( key ) ; for ( BaseAsyncTask < ? , ? , ? > lTask : tasks ) { if ( lTask . equals ( pTask ) ) { tasks . remove ( lTask ) ; if ( BuildConfig . DEBUG ) { Log . v ( TAG , "BaseTask removed:" + pTask . toString ( ) ) ; } break ; } } if ( tasks . size ( ) == 0 ) { mActivityTaskMap . remove ( key ) ; return ; } } } public void addTask ( Activity activity , BaseAsyncTask < ? , ? , ? > pTask ) { if ( activity == null ) { return ; } if ( BuildConfig . DEBUG ) { Log . d ( TAG , "BaseTask addTask activity:" + activity . getClass ( ) . getCanonicalName ( ) ) ; } int key = activity . getClass ( ) . getCanonicalName ( ) . hashCode ( ) ; List < BaseAsyncTask < ? , ? , ? > > tasks = mActivityTaskMap . get ( key ) ; if ( tasks == null ) { tasks = new ArrayList < > ( ) ; mActivityTaskMap . put ( key , tasks ) ; } if ( BuildConfig . DEBUG ) { Log . v ( TAG , "BaseTask added:" + pTask . toString ( ) ) ; } tasks . add ( pTask ) ; } public void detach ( Activity activity ) { if ( activity == null ) { return ; } if ( BuildConfig . DEBUG ) { Log . d ( TAG , "BaseTask detach:" + activity . getClass ( ) . getCanonicalName ( ) ) ; } List < BaseAsyncTask < ? , ? , ? > > tasks = mActivityTaskMap . get ( activity . getClass ( ) . getCanonicalName ( ) . hashCode ( ) ) ; if ( tasks != null ) { for ( BaseAsyncTask < ? , ? , ? > task : tasks ) { task . setActivity ( null ) ; } } } public void attach ( Activity activity ) { if ( activity == null ) { return ; } if ( BuildConfig . DEBUG ) { Log . d ( TAG , "BaseTask attach:" + activity . getClass ( ) . getCanonicalName ( ) ) ; } List < BaseAsyncTask < ? , ? , ? > > tasks = mActivityTaskMap . get ( activity . getClass ( ) . getCanonicalName ( ) . hashCode ( ) ) ; if ( tasks != null ) { for ( BaseAsyncTask < ? , ? , ? > task : tasks ) { task . setActivity ( activity ) ; } } } }
package com . SecUpwN . AIMSICD . map ; public class MarkerData { public final String cellID ; public final String lat ; public final String lng ; public final String lac ; private final String mcc ; private final String mnc ; private final String samples ; public final boolean openCellID ; public MarkerData ( String cell_id , String latitude , String longitude , String local_area_code , String mobile_country_code , String mobile_network_code , String samples_taken , boolean openCellID_Data ) { cellID = cell_id ; lat = latitude ; lng = longitude ; lac = local_area_code ; mcc = mobile_country_code ; mnc = mobile_network_code ; samples = samples_taken ; openCellID = openCellID_Data ; } public String getMCC ( ) { if ( mcc == null ) return "000" ; if ( mcc . length ( ) >= 3 ) return mcc ; return ( "000" + mcc ) . substring ( mcc . length ( ) ) ; } public String getMNC ( ) { if ( mnc == null ) return "00" ; if ( mnc . length ( ) >= 2 ) return mnc ; return ( "00" + mnc ) . substring ( mnc . length ( ) ) ; } public String getPC ( ) { return getMCC ( ) + getMNC ( ) ; } public String getSamples ( ) { if ( samples == null || ( ! openCellID && samples . isEmpty ( ) ) ) return "0" ; return samples ; } }
package com . SecUpwN . AIMSICD . map ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . TableRow ; import android . widget . TextView ; import com . SecUpwN . AIMSICD . R ; import org . osmdroid . bonuspack . overlays . Marker ; import org . osmdroid . util . GeoPoint ; import org . osmdroid . views . MapView ; import org . osmdroid . views . overlay . OverlayItem ; public class CellTowerMarker extends Marker { private Context mContext ; private MarkerData mMarkerData ; public CellTowerMarker ( Context context , MapView mapView , String aTitle , String aSnippet , GeoPoint aGeoPoint , MarkerData data ) { super ( mapView ) ; mContext = context ; mTitle = aTitle ; mSnippet = aSnippet ; mPosition = aGeoPoint ; mMarkerData = data ; mOnMarkerClickListener = new OnCellTowerMarkerClickListener ( ) ; mInfoWindow = null ; } public MarkerData getMarkerData ( ) { return mMarkerData ; } public View getInfoContents ( MarkerData data ) { TextView tv ; View v = LayoutInflater . from ( mContext ) . inflate ( R . layout . marker_info_window , null ) ; if ( v != null ) { if ( data != null ) { if ( data . openCellID ) { TableRow tr = ( TableRow ) v . findViewById ( R . id . open_cell_label ) ; tr . setVisibility ( View . VISIBLE ) ; } tv = ( TextView ) v . findViewById ( R . id . cell_id ) ; tv . setText ( data . cellID ) ; tv = ( TextView ) v . findViewById ( R . id . lac ) ; tv . setText ( data . lac ) ; tv = ( TextView ) v . findViewById ( R . id . lat ) ; tv . setText ( String . valueOf ( data . lat ) ) ; tv = ( TextView ) v . findViewById ( R . id . lng ) ; tv . setText ( String . valueOf ( data . lng ) ) ; tv = ( TextView ) v . findViewById ( R . id . pc ) ; tv . setText ( data . getPC ( ) ) ; tv = ( TextView ) v . findViewById ( R . id . samples ) ; tv . setText ( data . getSamples ( ) ) ; } } return v ; } public class OnCellTowerMarkerClickListener implements OnMarkerClickListener { @ Override public boolean onMarkerClick ( Marker marker , MapView mapView ) { CellTowerMarker cellTowerMarker = ( CellTowerMarker ) marker ; AlertDialog . Builder dialog = new AlertDialog . Builder ( mContext ) ; dialog . setTitle ( cellTowerMarker . getTitle ( ) ) ; dialog . setView ( getInfoContents ( cellTowerMarker . getMarkerData ( ) ) ) ; dialog . setPositiveButton ( android . R . string . ok , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { dialogInterface . dismiss ( ) ; } } ) ; dialog . show ( ) ; return true ; } } }
package com . SecUpwN . AIMSICD . map ; import android . content . Context ; import org . osmdroid . bonuspack . clustering . GridMarkerClusterer ; import java . util . List ; public class CellTowerGridMarkerClusterer extends GridMarkerClusterer { protected Context mContext ; public CellTowerGridMarkerClusterer ( Context ctx ) { super ( ctx ) ; } public void addAll ( List < CellTowerMarker > markers ) { for ( CellTowerMarker marker : markers ) { add ( marker ) ; } } }
package com . SecUpwN . AIMSICD . rilexecutor ; public class HexDump { private final static char [ ] HEX_DIGITS = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; public static String dumpHexString ( byte [ ] array ) { return dumpHexString ( array , 0 , array . length ) ; } public static String dumpHexString ( byte [ ] array , int offset , int length ) { StringBuilder result = new StringBuilder ( ) ; byte [ ] line = new byte [ 16 ] ; int lineIndex = 0 ; result . append ( "\n0x" ) ; result . append ( toHexString ( offset ) ) ; for ( int i = offset ; i < offset + length ; i ++ ) { if ( lineIndex == 16 ) { result . append ( " " ) ; for ( int j = 0 ; j < 16 ; j ++ ) { if ( line [ j ] > ' ' && line [ j ] < '~' ) { result . append ( new String ( line , j , 1 ) ) ; } else { result . append ( "." ) ; } } result . append ( "\n0x" ) ; result . append ( toHexString ( i ) ) ; lineIndex = 0 ; } byte b = array [ i ] ; result . append ( " " ) ; result . append ( HEX_DIGITS [ ( b > > > 4 ) & 0x0F ] ) ; result . append ( HEX_DIGITS [ b & 0x0F ] ) ; line [ lineIndex ++ ] = b ; } if ( lineIndex != 16 ) { int count = ( 16 - lineIndex ) * 3 ; count ++ ; for ( int i = 0 ; i < count ; i ++ ) { result . append ( " " ) ; } for ( int i = 0 ; i < lineIndex ; i ++ ) { if ( line [ i ] > ' ' && line [ i ] < '~' ) { result . append ( new String ( line , i , 1 ) ) ; } else { result . append ( "." ) ; } } } return result . toString ( ) ; } public static String toHexString ( byte b ) { return toHexString ( toByteArray ( b ) ) ; } public static String toHexString ( byte [ ] array ) { return toHexString ( array , 0 , array . length ) ; } public static String toHexString ( byte [ ] array , int offset , int length ) { char [ ] buf = new char [ length * 2 ] ; int bufIndex = 0 ; for ( int i = offset ; i < offset + length ; i ++ ) { byte b = array [ i ] ; buf [ bufIndex ++ ] = HEX_DIGITS [ ( b > > > 4 ) & 0x0F ] ; buf [ bufIndex ++ ] = HEX_DIGITS [ b & 0x0F ] ; } return new String ( buf ) ; } public static String toHexString ( int i ) { return toHexString ( toByteArray ( i ) ) ; } public static byte [ ] toByteArray ( byte b ) { byte [ ] array = new byte [ 1 ] ; array [ 0 ] = b ; return array ; } public static byte [ ] toByteArray ( int i ) { byte [ ] array = new byte [ 4 ] ; array [ 3 ] = ( byte ) ( i & 0xFF ) ; array [ 2 ] = ( byte ) ( ( i > > 8 ) & 0xFF ) ; array [ 1 ] = ( byte ) ( ( i > > 16 ) & 0xFF ) ; array [ 0 ] = ( byte ) ( ( i > > 24 ) & 0xFF ) ; return array ; } private static int toByte ( char c ) { if ( c >= '0' && c <= '9' ) { return ( c - '0' ) ; } if ( c >= 'A' && c <= 'F' ) { return ( c - 'A' + 10 ) ; } if ( c >= 'a' && c <= 'f' ) { return ( c - 'a' + 10 ) ; } throw new RuntimeException ( "Invalid hex char '" + c + "'" ) ; } public static byte [ ] hexStringToByteArray ( String hexString ) { int length = hexString . length ( ) ; byte [ ] buffer = new byte [ length / 2 ] ; for ( int i = 0 ; i < length ; i += 2 ) { buffer [ i / 2 ] = ( byte ) ( ( toByte ( hexString . charAt ( i ) ) < < 4 ) | toByte ( hexString . charAt ( i + 1 ) ) ) ; } return buffer ; } }
package com . SecUpwN . AIMSICD . rilexecutor ; import android . os . Message ; public interface OemRilExecutor { public DetectResult detect ( ) ; public void start ( ) ; public void stop ( ) ; public void invokeOemRilRequestRaw ( byte data [ ] , Message response ) ; public void invokeOemRilRequestStrings ( String [ ] strings , Message response ) ; }
package com . SecUpwN . AIMSICD . rilexecutor ; public class DetectResult { public final boolean available ; public final String error ; static final DetectResult AVAILABLE = new DetectResult ( true , null ) ; private DetectResult ( boolean available , String error ) { this . available = available ; this . error = error ; } static DetectResult Unavailable ( String error ) { return new DetectResult ( false , error ) ; } }
package com . SecUpwN . AIMSICD . rilexecutor ; import android . content . Context ; import android . os . ConditionVariable ; import android . os . Handler ; import android . os . HandlerThread ; import android . os . Looper ; import android . os . Message ; import android . util . Log ; import com . SecUpwN . AIMSICD . rilexecutor . DetectResult ; import com . SecUpwN . AIMSICD . rilexecutor . OemRilExecutor ; import com . SecUpwN . AIMSICD . rilexecutor . RawResult ; import com . SecUpwN . AIMSICD . rilexecutor . SamsungMulticlientRilExecutor ; import com . SecUpwN . AIMSICD . utils . Helpers ; import com . SecUpwN . AIMSICD . utils . OemCommands ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . Queue ; public class RilExecutor { public static final String TAG = "MultiRil" ; public boolean mMultiRilCompatible ; private static final int ID_REQUEST_START_SERVICE_MODE_COMMAND = 1 ; private static final int ID_REQUEST_FINISH_SERVICE_MODE_COMMAND = 2 ; private static final int ID_REQUEST_PRESS_A_KEY = 3 ; private static final int ID_REQUEST_REFRESH = 4 ; private static final int ID_RESPONSE = 101 ; private static final int ID_RESPONSE_FINISH_SERVICE_MODE_COMMAND = 102 ; private static final int ID_RESPONSE_PRESS_A_KEY = 103 ; private static final int REQUEST_TIMEOUT = 10000 ; private final ConditionVariable mRequestCondvar = new ConditionVariable ( ) ; private final Object mLastResponseLock = new Object ( ) ; private volatile List < String > mLastResponse ; private DetectResult mRilExecutorDetectResult ; private OemRilExecutor mRequestExecutor ; private HandlerThread mHandlerThread ; private Handler mHandler ; public RilExecutor ( Context context ) { mRequestExecutor = new SamsungMulticlientRilExecutor ( ) ; mRilExecutorDetectResult = mRequestExecutor . detect ( ) ; if ( ! mRilExecutorDetectResult . available ) { mMultiRilCompatible = false ; Log . e ( TAG , "Samsung Multiclient RIL not available: " + mRilExecutorDetectResult . error ) ; mRequestExecutor = null ; } else { mRequestExecutor . start ( ) ; mMultiRilCompatible = true ; mHandlerThread = new HandlerThread ( "ServiceModeSeqHandler" ) ; mHandlerThread . start ( ) ; Looper l = mHandlerThread . getLooper ( ) ; if ( l != null ) { mHandler = new Handler ( l , new MyHandler ( ) ) ; } } } public void stop ( ) { if ( mRequestExecutor != null ) { mRequestExecutor . stop ( ) ; mRequestExecutor = null ; mHandler = null ; mHandlerThread . quit ( ) ; mHandlerThread = null ; } } public DetectResult getRilExecutorStatus ( ) { return mRilExecutorDetectResult ; } private List < String > executeServiceModeCommand ( int type , int subtype , java . util . Collection < KeyStep > keySeqence ) { return executeServiceModeCommand ( type , subtype , keySeqence , REQUEST_TIMEOUT ) ; } private synchronized List < String > executeServiceModeCommand ( int type , int subtype , java . util . Collection < KeyStep > keySeqence , int timeout ) { if ( mRequestExecutor == null ) { return Collections . emptyList ( ) ; } mRequestCondvar . close ( ) ; mHandler . obtainMessage ( ID_REQUEST_START_SERVICE_MODE_COMMAND , type , subtype , keySeqence ) . sendToTarget ( ) ; if ( ! mRequestCondvar . block ( timeout ) ) { Log . e ( TAG , "request timeout" ) ; return Collections . emptyList ( ) ; } else { synchronized ( mLastResponseLock ) { return mLastResponse ; } } } public List < String > getCipheringInfo ( ) { return executeServiceModeCommand ( OemCommands . OEM_SM_TYPE_TEST_MANUAL , OemCommands . OEM_SM_TYPE_SUB_CIPHERING_PROTECTION_ENTER , null ) ; } public List < String > getNeighbours ( ) { KeyStep getNeighboursKeySeq [ ] = new KeyStep [ ] { new KeyStep ( '\0' , false ) , new KeyStep ( '1' , false ) , new KeyStep ( '4' , true ) , } ; return executeServiceModeCommand ( OemCommands . OEM_SM_TYPE_TEST_MANUAL , OemCommands . OEM_SM_TYPE_SUB_ENTER , Arrays . asList ( getNeighboursKeySeq ) ) ; } private static class KeyStep { public final char keychar ; public final boolean captureResponse ; public KeyStep ( char keychar , boolean captureResponse ) { this . keychar = keychar ; this . captureResponse = captureResponse ; } public static final KeyStep KEY_START_SERVICE_MODE = new KeyStep ( '\0' , true ) ; } private class MyHandler implements Handler . Callback { private int mCurrentType ; private int mCurrentSubtype ; private Queue < KeyStep > mKeySequence ; @ Override public boolean handleMessage ( Message msg ) { byte [ ] requestData ; Message responseMsg ; KeyStep lastKeyStep ; switch ( msg . what ) { case ID_REQUEST_START_SERVICE_MODE_COMMAND : mCurrentType = msg . arg1 ; mCurrentSubtype = msg . arg2 ; mKeySequence = new ArrayDeque < > ( 3 ) ; if ( msg . obj != null ) { mKeySequence . addAll ( ( java . util . Collection < KeyStep > ) msg . obj ) ; } else { mKeySequence . add ( KeyStep . KEY_START_SERVICE_MODE ) ; } synchronized ( mLastResponseLock ) { mLastResponse = new ArrayList < > ( ) ; } requestData = OemCommands . getEnterServiceModeData ( mCurrentType , mCurrentSubtype , OemCommands . OEM_SM_ACTION ) ; responseMsg = mHandler . obtainMessage ( ID_RESPONSE ) ; mRequestExecutor . invokeOemRilRequestRaw ( requestData , responseMsg ) ; break ; case ID_REQUEST_FINISH_SERVICE_MODE_COMMAND : requestData = OemCommands . getEndServiceModeData ( mCurrentType ) ; responseMsg = mHandler . obtainMessage ( ID_RESPONSE_FINISH_SERVICE_MODE_COMMAND ) ; mRequestExecutor . invokeOemRilRequestRaw ( requestData , responseMsg ) ; break ; case ID_REQUEST_PRESS_A_KEY : requestData = OemCommands . getPressKeyData ( msg . arg1 , OemCommands . OEM_SM_ACTION ) ; responseMsg = mHandler . obtainMessage ( ID_RESPONSE_PRESS_A_KEY ) ; mRequestExecutor . invokeOemRilRequestRaw ( requestData , responseMsg ) ; break ; case ID_REQUEST_REFRESH : requestData = OemCommands . getPressKeyData ( '\0' , OemCommands . OEM_SM_QUERY ) ; responseMsg = mHandler . obtainMessage ( ID_RESPONSE ) ; mRequestExecutor . invokeOemRilRequestRaw ( requestData , responseMsg ) ; break ; case ID_RESPONSE : lastKeyStep = mKeySequence . poll ( ) ; try { RawResult result = ( RawResult ) msg . obj ; if ( result == null ) { Log . e ( TAG , "result is null" ) ; break ; } if ( result . exception != null ) { Log . e ( TAG , "" , result . exception ) ; break ; } if ( result . result == null ) { Log . v ( TAG , "No need to refresh." ) ; break ; } if ( lastKeyStep . captureResponse ) { synchronized ( mLastResponseLock ) { mLastResponse . addAll ( Helpers . unpackByteListOfStrings ( result . result ) ) ; } } } finally { if ( mKeySequence . isEmpty ( ) ) { mHandler . obtainMessage ( ID_REQUEST_FINISH_SERVICE_MODE_COMMAND ) . sendToTarget ( ) ; } else { mHandler . obtainMessage ( ID_REQUEST_PRESS_A_KEY , mKeySequence . element ( ) . keychar , 0 ) . sendToTarget ( ) ; } } break ; case ID_RESPONSE_PRESS_A_KEY : mHandler . sendMessageDelayed ( mHandler . obtainMessage ( ID_REQUEST_REFRESH ) , 10 ) ; break ; case ID_RESPONSE_FINISH_SERVICE_MODE_COMMAND : mRequestCondvar . open ( ) ; break ; } return true ; } } }
package com . stericson . RootShellTests ; import java . io . IOException ; import java . util . List ; import java . util . concurrent . TimeoutException ; import android . app . Activity ; import android . app . ProgressDialog ; import android . content . Context ; import android . os . Bundle ; import android . os . Handler ; import android . os . Message ; import android . os . StrictMode ; import android . widget . ScrollView ; import android . widget . TextView ; import com . stericson . RootShell . RootShell ; import com . stericson . RootShell . exceptions . RootDeniedException ; import com . stericson . RootShell . execution . Command ; import com . stericson . RootShell . execution . Shell ; public class SanityCheckRootShell extends Activity { private ScrollView mScrollView ; private TextView mTextView ; private ProgressDialog mPDialog ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; StrictMode . setThreadPolicy ( new StrictMode . ThreadPolicy . Builder ( ) . detectDiskReads ( ) . detectDiskWrites ( ) . detectNetwork ( ) . penaltyLog ( ) . build ( ) ) ; StrictMode . setVmPolicy ( new StrictMode . VmPolicy . Builder ( ) . detectLeakedSqlLiteObjects ( ) . detectLeakedClosableObjects ( ) . penaltyLog ( ) . penaltyDeath ( ) . build ( ) ) ; RootShell . debugMode = true ; mTextView = new TextView ( this ) ; mTextView . setText ( "" ) ; mScrollView = new ScrollView ( this ) ; mScrollView . addView ( mTextView ) ; setContentView ( mScrollView ) ; print ( "SanityCheckRootShell \n\n" ) ; if ( RootShell . isRootAvailable ( ) ) { print ( "Root found.\n" ) ; } else { print ( "Root not found" ) ; } try { RootShell . getShell ( true ) ; } catch ( IOException e2 ) { e2 . printStackTrace ( ) ; } catch ( TimeoutException e ) { print ( "[ TIMEOUT EXCEPTION! ]\n" ) ; e . printStackTrace ( ) ; } catch ( RootDeniedException e ) { print ( "[ ROOT DENIED EXCEPTION! ]\n" ) ; e . printStackTrace ( ) ; } try { if ( ! RootShell . isAccessGiven ( ) ) { print ( "ERROR: No root access to this device.\n" ) ; return ; } } catch ( Exception e ) { print ( "ERROR: could not determine root access to this device.\n" ) ; return ; } mPDialog = new ProgressDialog ( this ) ; mPDialog . setCancelable ( false ) ; mPDialog . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; new SanityCheckThread ( this , new TestHandler ( ) ) . start ( ) ; } protected void print ( CharSequence text ) { mTextView . append ( text ) ; mScrollView . post ( new Runnable ( ) { public void run ( ) { mScrollView . fullScroll ( ScrollView . FOCUS_DOWN ) ; } } ) ; } private class SanityCheckThread extends Thread { private Handler mHandler ; public SanityCheckThread ( Context context , Handler handler ) { mHandler = handler ; } public void run ( ) { visualUpdate ( TestHandler . ACTION_SHOW , null ) ; boolean result ; visualUpdate ( TestHandler . ACTION_PDISPLAY , "Testing getPath" ) ; visualUpdate ( TestHandler . ACTION_DISPLAY , "[ getPath ]\n" ) ; try { List < String > paths = RootShell . getPath ( ) ; for ( String path : paths ) { visualUpdate ( TestHandler . ACTION_DISPLAY , path + " k\n\n" ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } visualUpdate ( TestHandler . ACTION_PDISPLAY , "Testing A ton of commands" ) ; visualUpdate ( TestHandler . ACTION_DISPLAY , "[ Ton of Commands ]\n" ) ; for ( int i = 0 ; i < 100 ; i ++ ) { RootShell . exists ( "/system/xbin/busybox" ) ; } visualUpdate ( TestHandler . ACTION_PDISPLAY , "Testing Find Binary" ) ; result = RootShell . isRootAvailable ( ) ; visualUpdate ( TestHandler . ACTION_DISPLAY , "[ Checking Root ]\n" ) ; visualUpdate ( TestHandler . ACTION_DISPLAY , result + " k\n\n" ) ; result = RootShell . isBusyboxAvailable ( ) ; visualUpdate ( TestHandler . ACTION_DISPLAY , "[ Checking Busybox ]\n" ) ; visualUpdate ( TestHandler . ACTION_DISPLAY , result + " k\n\n" ) ; visualUpdate ( TestHandler . ACTION_PDISPLAY , "Testing file exists" ) ; visualUpdate ( TestHandler . ACTION_DISPLAY , "[ Checking Exists() ]\n" ) ; visualUpdate ( TestHandler . ACTION_DISPLAY , RootShell . exists ( "/system/sbin/[" ) + " k\n\n" ) ; visualUpdate ( TestHandler . ACTION_PDISPLAY , "Testing Is Access Given" ) ; result = RootShell . isAccessGiven ( ) ; visualUpdate ( TestHandler . ACTION_DISPLAY , "[ Checking for Access to Root ]\n" ) ; visualUpdate ( TestHandler . ACTION_DISPLAY , result + " k\n\n" ) ; Shell shell ; visualUpdate ( TestHandler . ACTION_PDISPLAY , "Testing output capture" ) ; visualUpdate ( TestHandler . ACTION_DISPLAY , "[ busybox ash --help ]\n" ) ; try { shell = RootShell . getShell ( true ) ; Command cmd = new Command ( 0 , "busybox ash --help" ) { @ Override public void commandOutput ( int id , String line ) { visualUpdate ( TestHandler . ACTION_DISPLAY , line + "\n" ) ; } } ; shell . add ( cmd ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } visualUpdate ( TestHandler . ACTION_PDISPLAY , "Switching RootContext - SYSTEM_APP" ) ; visualUpdate ( TestHandler . ACTION_DISPLAY , "[ Switching Root Context - SYSTEM_APP ]\n" ) ; try { shell = RootShell . getShell ( true , Shell . ShellContext . SYSTEM_APP ) ; Command cmd = new Command ( 0 , "id" ) { @ Override public void commandOutput ( int id , String line ) { visualUpdate ( TestHandler . ACTION_DISPLAY , line + "\n" ) ; super . commandOutput ( id , line ) ; } } ; shell . add ( cmd ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } visualUpdate ( TestHandler . ACTION_PDISPLAY , "Switching RootContext - UNTRUSTED" ) ; visualUpdate ( TestHandler . ACTION_DISPLAY , "[ Switching Root Context - UNTRUSTED ]\n" ) ; try { shell = RootShell . getShell ( true , Shell . ShellContext . UNTRUSTED_APP ) ; Command cmd = new Command ( 0 , "id" ) { @ Override public void commandOutput ( int id , String line ) { visualUpdate ( TestHandler . ACTION_DISPLAY , line + "\n" ) ; super . commandOutput ( id , line ) ; } } ; shell . add ( cmd ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } try { shell = RootShell . getShell ( true ) ; Command cmd = new Command ( 42 , false , "echo done" ) { boolean _catch = false ; @ Override public void commandOutput ( int id , String line ) { if ( _catch ) { RootShell . log ( "CAUGHT!!!" ) ; } super . commandOutput ( id , line ) ; } @ Override public void commandTerminated ( int id , String reason ) { synchronized ( com . stericson . RootShellTests . SanityCheckRootShell . this ) { _catch = true ; visualUpdate ( TestHandler . ACTION_PDISPLAY , "All tests complete." ) ; visualUpdate ( TestHandler . ACTION_HIDE , null ) ; try { RootShell . closeAllShells ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } @ Override public void commandCompleted ( int id , int exitCode ) { synchronized ( com . stericson . RootShellTests . SanityCheckRootShell . this ) { _catch = true ; visualUpdate ( TestHandler . ACTION_PDISPLAY , "All tests complete." ) ; visualUpdate ( TestHandler . ACTION_HIDE , null ) ; try { RootShell . closeAllShells ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } ; shell . add ( cmd ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } private void visualUpdate ( int action , String text ) { Message msg = mHandler . obtainMessage ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putInt ( TestHandler . ACTION , action ) ; bundle . putString ( TestHandler . TEXT , text ) ; msg . setData ( bundle ) ; mHandler . sendMessage ( msg ) ; } } private class TestHandler extends Handler { static final public String ACTION = "action" ; static final public int ACTION_SHOW = 0x01 ; static final public int ACTION_HIDE = 0x02 ; static final public int ACTION_DISPLAY = 0x03 ; static final public int ACTION_PDISPLAY = 0x04 ; static final public String TEXT = "text" ; public void handleMessage ( Message msg ) { int action = msg . getData ( ) . getInt ( ACTION ) ; String text = msg . getData ( ) . getString ( TEXT ) ; switch ( action ) { case ACTION_SHOW : mPDialog . show ( ) ; mPDialog . setMessage ( "Running Root Library Tests..." ) ; break ; case ACTION_HIDE : if ( null != text ) { print ( text ) ; } mPDialog . hide ( ) ; break ; case ACTION_DISPLAY : print ( text ) ; break ; case ACTION_PDISPLAY : mPDialog . setMessage ( text ) ; break ; } } } }
package com . SecUpwN . AIMSICD . rilexecutor ; public class StringsResult { public final String result [ ] ; public final Throwable exception ; public StringsResult ( String r [ ] , Throwable ex ) { result = r ; exception = ex ; } }
package com . SecUpwN . AIMSICD . rilexecutor ; public class RawResult { public final byte result [ ] ; public final Throwable exception ; public RawResult ( byte r [ ] , Throwable ex ) { result = r ; exception = ex ; } }
package com . SecUpwN . AIMSICD . rilexecutor ; import com . SecUpwN . AIMSICD . BuildConfig ; import android . annotation . SuppressLint ; import android . net . LocalSocket ; import android . net . LocalSocketAddress ; import android . os . Message ; import android . os . Parcel ; import android . util . Log ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . lang . reflect . Method ; import java . util . HashMap ; import java . util . Map ; import java . util . Random ; import java . util . concurrent . atomic . AtomicBoolean ; public class SamsungMulticlientRilExecutor implements OemRilExecutor { public static final String MULTICLIENT_SOCKET = "Multiclient" ; public static final String SOCKET_NAME_RIL = "rild" ; private static final int RIL_REQUEST_OEM_RAW = 59 ; private static final int RIL_REQUEST_OEM_STRINGS = 60 ; public static final int RIL_CLIENT_ERR_SUCCESS = 0 ; public static final int RIL_CLIENT_ERR_AGAIN = 1 ; public static final int RIL_CLIENT_ERR_INIT = 2 ; public static final int RIL_CLIENT_ERR_INVAL = 3 ; public static final int RIL_CLIENT_ERR_CONNECT = 4 ; public static final int RIL_CLIENT_ERR_IO = 5 ; public static final int RIL_CLIENT_ERR_RESPONSE = 6 ; public static final int RIL_CLIENT_ERR_UNKNOWN = 7 ; private static final int RESPONSE_SOLICITED = 0 ; private static final int RESPONSE_UNSOLICITED = 1 ; private static final int ID_REQUEST_AT_COMMAND = 5 ; private static final int ID_RESPONSE_AT_COMMAND = 104 ; private static final boolean DBG = false ; private static final String TAG = SamsungMulticlientRilExecutor . class . getSimpleName ( ) ; private volatile LocalSocketThread mThread ; public SamsungMulticlientRilExecutor ( ) { } @ Override public DetectResult detect ( ) { String gsmVerRilImpl = "" ; try { Class clazz ; clazz = Class . forName ( "android.os.SystemProperties" ) ; Method method = clazz . getDeclaredMethod ( "get" , String . class , String . class ) ; gsmVerRilImpl = ( String ) method . invoke ( null , "gsm.version.ril-impl" , "" ) ; } catch ( Exception ignore ) { ignore . printStackTrace ( ) ; } LocalSocket s = new LocalSocket ( ) ; try { s . connect ( new LocalSocketAddress ( MULTICLIENT_SOCKET ) ) ; } catch ( IOException e ) { return DetectResult . Unavailable ( "Multiclient socket is not available\n" + "gsm.version.ril-impl = " + gsmVerRilImpl ) ; } finally { try { s . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return DetectResult . AVAILABLE ; } @ Override public synchronized void start ( ) { if ( mThread != null ) { Log . e ( TAG , "OEM raw request executor thread is running" ) ; return ; } mThread = new LocalSocketThread ( MULTICLIENT_SOCKET ) ; mThread . start ( ) ; } @ Override public synchronized void stop ( ) { if ( mThread == null ) { Log . e ( TAG , "OEM raw request executor thread is not running" ) ; return ; } mThread . cancel ( ) ; mThread = null ; } @ Override public synchronized void invokeOemRilRequestRaw ( byte [ ] data , Message response ) { if ( mThread == null ) { Log . e ( TAG , "OEM raw request executor thread is not running" ) ; return ; } try { mThread . invokeOemRilRequestRaw ( data , response ) ; } catch ( IOException ioe ) { Log . e ( TAG , "invokeOemRilRequestRaw() error" , ioe ) ; } } @ Override public synchronized void invokeOemRilRequestStrings ( String [ ] strings , Message response ) { if ( mThread == null ) { Log . e ( TAG , "OEM raw request executor thread is not running" ) ; return ; } try { mThread . invokeOemRilRequestStrings ( strings , response ) ; } catch ( IOException ioe ) { Log . e ( TAG , "invokeOemRilRequestStrings() error" , ioe ) ; } } public class LocalSocketThread extends Thread { private static final int MAX_MESSAGES = 30 ; private final LocalSocketAddress mSocketPath ; private final AtomicBoolean mCancelRequested = new AtomicBoolean ( ) ; private LocalSocket mSocket ; private volatile InputStream mInputStream ; private volatile OutputStream mOutputStream ; private final Random mTokenGen = new Random ( ) ; private final Map < Integer , Message > mMessages ; @ SuppressLint ( "UseSparseArrays" ) public LocalSocketThread ( String socketPath ) { mSocketPath = new LocalSocketAddress ( socketPath ) ; mInputStream = null ; mOutputStream = null ; mMessages = new HashMap < > ( ) ; } public void cancel ( ) { if ( DBG ) { Log . v ( TAG , "SamsungMulticlientRil cancel()" ) ; } synchronized ( this ) { mCancelRequested . set ( true ) ; disconnect ( ) ; notifyAll ( ) ; } } public synchronized void invokeOemRilRequestRaw ( byte [ ] data , Message response ) throws IOException { int token ; if ( mMessages . size ( ) > MAX_MESSAGES ) { Log . e ( TAG , "message queue is full" ) ; return ; } if ( mOutputStream == null ) { Log . e ( TAG , "Local write() error: not connected" ) ; return ; } do { token = mTokenGen . nextInt ( ) ; } while ( mMessages . containsKey ( token ) ) ; byte req [ ] = marshallRequest ( token , data ) ; if ( DBG ) { Log . v ( TAG , String . format ( "invokeOemRilRequestRaw() token: 0x%X, header: %s, req: %s " , token , HexDump . toHexString ( getHeader ( req ) ) , HexDump . toHexString ( req ) ) ) ; } mOutputStream . write ( getHeader ( req ) ) ; mOutputStream . write ( req ) ; mMessages . put ( token , response ) ; } public synchronized void invokeOemRilRequestStrings ( String strings [ ] , Message response ) throws IOException { int token ; if ( mMessages . size ( ) > MAX_MESSAGES ) { Log . e ( TAG , "message queue is full" ) ; return ; } if ( mOutputStream == null ) { Log . e ( TAG , "Local write() error: not connected" ) ; return ; } do { token = mTokenGen . nextInt ( ) ; } while ( mMessages . containsKey ( token ) ) ; byte [ ] req = marshallRequest ( token , strings ) ; if ( DBG ) { Log . v ( TAG , String . format ( "invokeOemRilRequestStrings() token: 0x%X, header: %s, req: %s " , token , HexDump . toHexString ( getHeader ( req ) ) , HexDump . toHexString ( req ) ) ) ; } mOutputStream . write ( getHeader ( req ) ) ; mOutputStream . write ( req ) ; mMessages . put ( token , response ) ; } private byte [ ] getHeader ( byte data [ ] ) { int len = data . length ; return new byte [ ] { ( byte ) ( ( len > > 24 ) & 0xff ) , ( byte ) ( ( len > > 16 ) & 0xff ) , ( byte ) ( ( len > > 8 ) & 0xff ) , ( byte ) ( len & 0xff ) } ; } private byte [ ] marshallRequest ( int token , byte data [ ] ) { Parcel p = Parcel . obtain ( ) ; p . writeInt ( RIL_REQUEST_OEM_RAW ) ; p . writeInt ( token ) ; p . writeByteArray ( data ) ; byte [ ] res = p . marshall ( ) ; p . recycle ( ) ; return res ; } private byte [ ] marshallRequest ( int token , String strings [ ] ) { Parcel p = Parcel . obtain ( ) ; p . writeInt ( RIL_REQUEST_OEM_STRINGS ) ; p . writeInt ( token ) ; p . writeStringArray ( strings ) ; byte [ ] res = p . marshall ( ) ; p . recycle ( ) ; return res ; } public synchronized void disconnect ( ) { if ( DBG ) { Log . v ( TAG , "Local disconnect()" ) ; } if ( mSocket == null ) { return ; } try { mSocket . shutdownInput ( ) ; } catch ( IOException e ) { Log . e ( TAG , "Local shutdownInput() of mSocket failed" , e ) ; } try { mSocket . shutdownOutput ( ) ; } catch ( IOException e ) { Log . e ( TAG , "Local shutdownOutput() of mSocket failed" , e ) ; } try { mInputStream . close ( ) ; } catch ( IOException e ) { Log . e ( TAG , "Local close() of mInputStream failed" , e ) ; } try { mOutputStream . close ( ) ; } catch ( IOException e ) { Log . e ( TAG , "Local close() of mOutputStream failed" , e ) ; } try { mSocket . close ( ) ; } catch ( IOException e ) { Log . e ( TAG , "Local close() of mSocket failed" , e ) ; } mSocket = null ; mInputStream = null ; mOutputStream = null ; } @ Override public void run ( ) { int rcvd ; int endpos = 0 ; final byte buf [ ] = new byte [ 4096 ] ; Log . i ( TAG , "BEGIN LocalSocketThread-Socket" ) ; setName ( "MultiClientThread" ) ; mSocket = new LocalSocket ( ) ; try { mSocket . connect ( mSocketPath ) ; mInputStream = mSocket . getInputStream ( ) ; mOutputStream = mSocket . getOutputStream ( ) ; } catch ( IOException e ) { Log . e ( TAG , "Connect error" , e ) ; return ; } while ( ! mCancelRequested . get ( ) ) { try { rcvd = mInputStream . read ( buf , endpos , buf . length - endpos ) ; if ( rcvd < 0 ) { if ( DBG ) { Log . v ( TAG , "EOF reached" ) ; } break ; } endpos += rcvd ; if ( endpos < 4 ) { continue ; } int msgLen = ( buf [ 0 ] < < 24 ) | ( buf [ 1 ] < < 16 ) | ( buf [ 2 ] < < 8 ) | ( buf [ 3 ] & 0xff ) ; if ( msgLen + 4 > buf . length ) { Log . e ( TAG , "message to big. Length: " + msgLen ) ; endpos = 0 ; continue ; } if ( endpos >= msgLen + 4 ) { processRxPacket ( buf , 4 , msgLen ) ; int secondPktPos = msgLen + 4 ; if ( secondPktPos != endpos ) { System . arraycopy ( buf , secondPktPos , buf , 0 , endpos - secondPktPos ) ; } endpos -= msgLen + 4 ; } if ( endpos == buf . length ) { endpos = 0 ; } } catch ( IOException e ) { disconnect ( ) ; } } disconnect ( ) ; } private synchronized void processRxPacket ( byte data [ ] , int pos , int length ) { int responseType ; Parcel p ; if ( DBG ) { Log . v ( TAG , "received " + length + " bytes: " + HexDump . toHexString ( data , pos , length ) ) ; } p = Parcel . obtain ( ) ; try { p . unmarshall ( data , pos , length ) ; p . setDataPosition ( 0 ) ; responseType = p . readInt ( ) ; switch ( responseType ) { case RESPONSE_UNSOLICITED : Log . v ( TAG , "Unsolicited response " ) ; break ; case RESPONSE_SOLICITED : processSolicited ( p ) ; break ; default : Log . v ( TAG , "Invalid response type: " + responseType ) ; break ; } } finally { p . recycle ( ) ; } } private int processSolicited ( Parcel p ) { Integer token = null ; byte responseData [ ] = null ; String stringsResponseData [ ] = null ; Exception errorEx = null ; try { token = p . readInt ( ) ; int err = p . readInt ( ) ; if ( DBG ) { Log . v ( TAG , String . format ( "processSolicited() token: 0x%X err: %d" , token , err ) ) ; } if ( err != RIL_CLIENT_ERR_SUCCESS ) { throw new RemoteException ( "remote error " + err ) ; } responseData = p . createByteArray ( ) ; stringsResponseData = p . createStringArray ( ) ; } catch ( Exception ex ) { errorEx = ex ; } if ( token == null ) { Log . e ( TAG , "token is null" , errorEx ) ; } else { synchronized ( this ) { Message m = mMessages . remove ( token ) ; if ( m != null ) { switch ( m . what ) { case ID_REQUEST_AT_COMMAND : case ID_RESPONSE_AT_COMMAND : case RIL_REQUEST_OEM_STRINGS : m . obj = new StringsResult ( stringsResponseData , errorEx ) ; m . sendToTarget ( ) ; break ; default : m . obj = new RawResult ( responseData , errorEx ) ; m . sendToTarget ( ) ; } } else { Log . i ( TAG , "Message with token " + token + " not found" ) ; } } } return RIL_CLIENT_ERR_SUCCESS ; } } public static class RemoteException extends Exception { public RemoteException ( ) { } public RemoteException ( String detailMessage ) { super ( detailMessage ) ; } } }
package com . SecUpwN . AIMSICD . utils ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Map ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . Bitmap ; import android . graphics . Bitmap . CompressFormat ; import android . graphics . BitmapFactory ; import android . os . Environment ; import android . preference . PreferenceManager ; import android . text . TextUtils ; import android . util . Log ; public class TinyDB { Context mContext ; SharedPreferences preferences ; String DEFAULT_APP_IMAGEDATA_DIRECTORY ; File mFolder = null ; public static String lastImagePath = "" ; private TinyDB ( ) { } public void init ( Context appContext ) { mContext = appContext ; preferences = PreferenceManager . getDefaultSharedPreferences ( mContext ) ; } public Bitmap getImage ( String path ) { Bitmap theGottenBitmap = null ; try { theGottenBitmap = BitmapFactory . decodeFile ( path ) ; } catch ( Exception e ) { } return theGottenBitmap ; } public String getSavedImagePath ( ) { return lastImagePath ; } public String putImagePNG ( String theFolder , String theImageName , Bitmap theBitmap ) { this . DEFAULT_APP_IMAGEDATA_DIRECTORY = theFolder ; String mFullPath = setupFolderPath ( theImageName ) ; saveBitmapPNG ( mFullPath , theBitmap ) ; lastImagePath = mFullPath ; return mFullPath ; } public Boolean putImagePNGwithfullPath ( String fullPath , Bitmap theBitmap ) { return saveBitmapPNG ( fullPath , theBitmap ) ; } private String setupFolderPath ( String imageName ) { File sdcard_path = new File ( mContext . getExternalFilesDir ( null ) + File . separator ) ; mFolder = new File ( sdcard_path , DEFAULT_APP_IMAGEDATA_DIRECTORY ) ; if ( ! mFolder . exists ( ) ) { if ( ! mFolder . mkdirs ( ) ) { Log . e ( "AIMSICD" , "TinyDB:setupFolderPath() - Default Save Path Creation Error" ) ; } } String savePath = mFolder . getPath ( ) + '/' + imageName ; return savePath ; } private boolean saveBitmapPNG ( String strFileName , Bitmap bitmap ) { if ( strFileName == null || bitmap == null ) return false ; boolean bSuccess1 = false ; boolean bSuccess2 ; boolean bSuccess3 ; File saveFile = new File ( strFileName ) ; if ( saveFile . exists ( ) ) { if ( ! saveFile . delete ( ) ) return false ; } try { bSuccess1 = saveFile . createNewFile ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } OutputStream out = null ; try { out = new FileOutputStream ( saveFile ) ; bSuccess2 = bitmap . compress ( CompressFormat . PNG , 100 , out ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; bSuccess2 = false ; } try { if ( out != null ) { out . flush ( ) ; out . close ( ) ; bSuccess3 = true ; } else bSuccess3 = false ; } catch ( IOException e ) { e . printStackTrace ( ) ; bSuccess3 = false ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } return ( bSuccess1 && bSuccess2 && bSuccess3 ) ; } public int getInt ( String key ) { return preferences . getInt ( key , 0 ) ; } public long getLong ( String key ) { return preferences . getLong ( key , 0l ) ; } public String getString ( String key ) { return preferences . getString ( key , "" ) ; } public double getDouble ( String key ) { String number = getString ( key ) ; try { double value = Double . parseDouble ( number ) ; return value ; } catch ( NumberFormatException e ) { return 0 ; } } public void putInt ( String key , int value ) { SharedPreferences . Editor editor = preferences . edit ( ) ; editor . putInt ( key , value ) ; editor . apply ( ) ; } public void putLong ( String key , long value ) { SharedPreferences . Editor editor = preferences . edit ( ) ; editor . putLong ( key , value ) ; editor . apply ( ) ; } public void putDouble ( String key , double value ) { putString ( key , String . valueOf ( value ) ) ; } public void putString ( String key , String value ) { SharedPreferences . Editor editor = preferences . edit ( ) ; editor . putString ( key , value ) ; editor . apply ( ) ; } public void putList ( String key , ArrayList < String > marray ) { SharedPreferences . Editor editor = preferences . edit ( ) ; String [ ] mystringlist = marray . toArray ( new String [ marray . size ( ) ] ) ; editor . putString ( key , TextUtils . join ( "" , mystringlist ) ) ; editor . apply ( ) ; } public ArrayList < String > getList ( String key ) { String [ ] mylist = TextUtils . split ( preferences . getString ( key , "" ) , "" ) ; return new ArrayList < > ( Arrays . asList ( mylist ) ) ; } public void putListInt ( String key , ArrayList < Integer > marray ) { SharedPreferences . Editor editor = preferences . edit ( ) ; Integer [ ] mystringlist = marray . toArray ( new Integer [ marray . size ( ) ] ) ; editor . putString ( key , TextUtils . join ( "" , mystringlist ) ) ; editor . apply ( ) ; } public ArrayList < Integer > getListInt ( String key ) { String [ ] mylist = TextUtils . split ( preferences . getString ( key , "" ) , "" ) ; ArrayList < String > gottenlist = new ArrayList < > ( Arrays . asList ( mylist ) ) ; ArrayList < Integer > gottenlist2 = new ArrayList < > ( ) ; for ( int i = 0 ; i < gottenlist . size ( ) ; i ++ ) { gottenlist2 . add ( Integer . parseInt ( gottenlist . get ( i ) ) ) ; } return gottenlist2 ; } public void putListDouble ( String key , ArrayList < Double > marray ) { SharedPreferences . Editor editor = preferences . edit ( ) ; Double [ ] mystringlist = marray . toArray ( new Double [ marray . size ( ) ] ) ; editor . putString ( key , TextUtils . join ( "" , mystringlist ) ) ; editor . apply ( ) ; } public ArrayList < Double > getListDouble ( String key ) { String [ ] mylist = TextUtils . split ( preferences . getString ( key , "" ) , "" ) ; ArrayList < String > gottenlist = new ArrayList < > ( Arrays . asList ( mylist ) ) ; ArrayList < Double > gottenlist2 = new ArrayList < > ( ) ; for ( int i = 0 ; i < gottenlist . size ( ) ; i ++ ) { gottenlist2 . add ( Double . parseDouble ( gottenlist . get ( i ) ) ) ; } return gottenlist2 ; } public void putListBoolean ( String key , ArrayList < Boolean > marray ) { ArrayList < String > origList = new ArrayList < > ( ) ; for ( Boolean b : marray ) { if ( b ) { origList . add ( "true" ) ; } else { origList . add ( "false" ) ; } } putList ( key , origList ) ; } public ArrayList < Boolean > getListBoolean ( String key ) { ArrayList < String > origList = getList ( key ) ; ArrayList < Boolean > mBools = new ArrayList < > ( ) ; for ( String b : origList ) { if ( b . equals ( "true" ) ) { mBools . add ( true ) ; } else { mBools . add ( false ) ; } } return mBools ; } public void putBoolean ( String key , boolean value ) { SharedPreferences . Editor editor = preferences . edit ( ) ; editor . putBoolean ( key , value ) ; editor . apply ( ) ; } public boolean getBoolean ( String key ) { return preferences . getBoolean ( key , false ) ; } public void putFloat ( String key , float value ) { SharedPreferences . Editor editor = preferences . edit ( ) ; editor . putFloat ( key , value ) ; editor . apply ( ) ; } public float getFloat ( String key ) { return preferences . getFloat ( key , 0f ) ; } public void remove ( String key ) { SharedPreferences . Editor editor = preferences . edit ( ) ; editor . remove ( key ) ; editor . apply ( ) ; } public Boolean deleteImage ( String path ) { File tobedeletedImage = new File ( path ) ; Boolean isDeleted = tobedeletedImage . delete ( ) ; return isDeleted ; } public void clear ( ) { SharedPreferences . Editor editor = preferences . edit ( ) ; editor . clear ( ) ; editor . apply ( ) ; } public Map < String , ? > getAll ( ) { return preferences . getAll ( ) ; } public void registerOnSharedPreferenceChangeListener ( SharedPreferences . OnSharedPreferenceChangeListener listener ) { preferences . registerOnSharedPreferenceChangeListener ( listener ) ; } public void unregisterOnSharedPreferenceChangeListener ( SharedPreferences . OnSharedPreferenceChangeListener listener ) { preferences . unregisterOnSharedPreferenceChangeListener ( listener ) ; } private static class InstanceHolder { private static final TinyDB INSTANCE = new TinyDB ( ) ; } public static TinyDB getInstance ( ) { return InstanceHolder . INSTANCE ; } }
package com . SecUpwN . AIMSICD . utils ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import static java . lang . System . nanoTime ; public class ChildProcess { private String TAG = getClass ( ) . getSimpleName ( ) ; private static final int PIPE_SIZE = 1024 ; private class ChildReader extends Thread { final InputStream mStream ; final StringBuffer mBuffer ; ChildReader ( InputStream is , StringBuffer buf ) { mStream = is ; mBuffer = buf ; } public void run ( ) { byte [ ] buf = new byte [ PIPE_SIZE ] ; try { int len ; while ( ( len = mStream . read ( buf ) ) != - 1 ) { String s = new String ( buf , 0 , len ) ; mBuffer . append ( s ) ; } } catch ( IOException e ) { } try { mStream . close ( ) ; } catch ( IOException e ) { } } } private class ChildWriter extends Thread { final OutputStream mStream ; final String mBuffer ; ChildWriter ( OutputStream os , String buf ) { mStream = os ; mBuffer = buf ; } public void run ( ) { int off = 0 ; byte [ ] buf = mBuffer . getBytes ( ) ; try { while ( off < buf . length ) { int len = Math . min ( PIPE_SIZE , buf . length - off ) ; mStream . write ( buf , off , len ) ; off += len ; } } catch ( IOException e ) { } try { mStream . close ( ) ; } catch ( IOException e ) { } } } private final long mStartTime ; private Process mChildProc ; private ChildWriter mChildStdinWriter ; private ChildReader mChildStdoutReader ; private ChildReader mChildStderrReader ; final private StringBuffer mChildStdout ; final private StringBuffer mChildStderr ; private int mExitValue ; private long mEndTime ; public ChildProcess ( String [ ] cmdarray , String childStdin ) { mStartTime = nanoTime ( ) ; mChildStdout = new StringBuffer ( ) ; mChildStderr = new StringBuffer ( ) ; try { mChildProc = Runtime . getRuntime ( ) . exec ( cmdarray ) ; if ( childStdin != null ) { mChildStdinWriter = new ChildWriter ( mChildProc . getOutputStream ( ) , childStdin ) ; mChildStdinWriter . start ( ) ; } mChildStdoutReader = new ChildReader ( mChildProc . getInputStream ( ) , mChildStdout ) ; mChildStdoutReader . start ( ) ; mChildStderrReader = new ChildReader ( mChildProc . getErrorStream ( ) , mChildStderr ) ; mChildStderrReader . start ( ) ; } catch ( IOException e ) { } } public boolean isFinished ( ) { boolean finished = true ; if ( mChildProc != null ) { try { mChildProc . exitValue ( ) ; } catch ( IllegalStateException e ) { finished = false ; } } return finished ; } public int waitFinished ( ) { while ( mChildProc != null ) { try { mExitValue = mChildProc . waitFor ( ) ; mEndTime = nanoTime ( ) ; mChildProc = null ; mChildStderrReader . join ( ) ; mChildStderrReader = null ; mChildStdoutReader . join ( ) ; mChildStdoutReader = null ; if ( mChildStdinWriter != null ) { mChildStdinWriter . join ( ) ; mChildStdinWriter = null ; } } catch ( InterruptedException e ) { } } return mExitValue ; } public CommandResult getResult ( ) { if ( ! isFinished ( ) ) { throw new IllegalThreadStateException ( "Child process running" ) ; } return new CommandResult ( mStartTime , mExitValue , mChildStdout . toString ( ) , mChildStderr . toString ( ) , mEndTime ) ; } }
package com . SecUpwN . AIMSICD . utils ; import com . SecUpwN . AIMSICD . adapters . AIMSICDDbAdapter ; import android . os . Parcel ; import android . os . Parcelable ; import android . util . Log ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; @ SuppressWarnings ( "AccessOfSystemProperties" ) public class CommandResult implements Parcelable { private final String TAG = "AIMSICD_CommandResult" ; private final long mStartTime ; private final int mExitValue ; private final String mStdout ; private final String mStderr ; private final long mEndTime ; public CommandResult ( long startTime , int exitValue , String stdout , String stderr , long endTime ) { mStartTime = startTime ; mExitValue = exitValue ; mStdout = stdout ; mStderr = stderr ; mEndTime = endTime ; Log . d ( TAG , "Time to execute: " + ( mEndTime - mStartTime ) + " ns (nanoseconds)" ) ; checkForErrors ( ) ; } @ SuppressWarnings ( "CastToConcreteClass" ) public CommandResult ( Parcel inParcel ) { this ( inParcel . readLong ( ) , inParcel . readInt ( ) , inParcel . readString ( ) , inParcel . readString ( ) , inParcel . readLong ( ) ) ; } public boolean success ( ) { return ( mExitValue == 0 ) ; } public long getEndTime ( ) { return mEndTime ; } public String getStderr ( ) { return mStderr ; } public String getStdout ( ) { return mStdout ; } public Integer getExitValue ( ) { return mExitValue ; } public long getStartTime ( ) { return mStartTime ; } @ SuppressWarnings ( "UnnecessaryExplicitNumericCast" ) private void checkForErrors ( ) { if ( mExitValue != 0 || ! "" . equals ( mStderr . trim ( ) ) ) { boolean skipOfflineCpu = mStderr . contains ( "chmod: /sys/devices/system/cpu/cpu" ) || mStderr . contains ( ": can't create /sys/devices/system/cpu/cpu" ) ; String lineEnding = System . getProperty ( "line.separator" ) ; FileWriter errorWriter = null ; try { File errorLogFile = new File ( AIMSICDDbAdapter . FOLDER + "error.txt" ) ; if ( ! errorLogFile . exists ( ) ) { errorLogFile . createNewFile ( ) ; } errorWriter = new FileWriter ( errorLogFile , true ) ; if ( skipOfflineCpu ) { errorWriter . write ( lineEnding ) ; errorWriter . write ( "Attempted to write to an offline cpu core (ignore me)." ) ; } else { errorWriter . write ( TAG + " shell error detected!" ) ; errorWriter . write ( lineEnding ) ; errorWriter . write ( "CommandResult {" + this . toString ( ) + '}' ) ; errorWriter . write ( lineEnding ) ; } errorWriter . write ( lineEnding ) ; } catch ( IOException e ) { Log . e ( TAG , "Failed to write command result to error file" , e ) ; } finally { if ( errorWriter != null ) { try { errorWriter . close ( ) ; } catch ( IOException ignored ) { } } } } } @ Override public int describeContents ( ) { return 0 ; } @ Override public void writeToParcel ( Parcel parcel , int i ) { parcel . writeLong ( mStartTime ) ; parcel . writeInt ( mExitValue ) ; parcel . writeString ( mStdout ) ; parcel . writeString ( mStderr ) ; parcel . writeLong ( mEndTime ) ; } @ Override public String toString ( ) { return "CommandResult{" + ", mStartTime=" + mStartTime + ", mExitValue=" + mExitValue + ", stdout='" + mStdout + "'" + ", stderr='" + mStderr + "'" + ", mEndTime=" + mEndTime + '}' ; } public static final Parcelable . Creator < CommandResult > CREATOR = new Parcelable . Creator < CommandResult > ( ) { public CommandResult createFromParcel ( Parcel in ) { return new CommandResult ( in ) ; } public CommandResult [ ] newArray ( int size ) { return new CommandResult [ size ] ; } } ; @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof CommandResult ) ) { return false ; } CommandResult that = ( CommandResult ) o ; return ( mStartTime == that . mStartTime && mExitValue == that . mExitValue && mStdout . equals ( that . mStdout ) && mStderr . equals ( that . mStderr ) && mEndTime == that . mEndTime ) ; } @ Override public int hashCode ( ) { int result = 0 ; result = 31 * result + ( int ) ( mStartTime ^ ( mStartTime > > > 32 ) ) ; result = 31 * result + mExitValue ; result = 31 * result + ( mStdout != null ? mStdout . hashCode ( ) : 0 ) ; result = 31 * result + ( mStderr != null ? mStderr . hashCode ( ) : 0 ) ; result = 31 * result + ( int ) ( mEndTime ^ ( mEndTime > > > 32 ) ) ; return result ; } }
package com . SecUpwN . AIMSICD . utils ; import android . os . AsyncTask ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . net . HttpURLConnection ; import java . net . URL ; public class LocationServices { private static void writeData ( OutputStream out , int cid , int lac , int mnc , int mcc ) throws IOException { DataOutputStream dataOutputStream = new DataOutputStream ( out ) ; dataOutputStream . writeShort ( 0x0E ) ; dataOutputStream . writeInt ( 0 ) ; dataOutputStream . writeInt ( 0 ) ; dataOutputStream . writeShort ( 0 ) ; dataOutputStream . writeShort ( 0 ) ; dataOutputStream . writeShort ( 0 ) ; dataOutputStream . writeByte ( 0x1B ) ; dataOutputStream . writeInt ( 0 ) ; dataOutputStream . writeInt ( 0 ) ; dataOutputStream . writeInt ( 3 ) ; dataOutputStream . writeShort ( 0 ) ; dataOutputStream . writeInt ( cid ) ; dataOutputStream . writeInt ( lac ) ; dataOutputStream . writeInt ( mnc ) ; dataOutputStream . writeInt ( mcc ) ; dataOutputStream . writeInt ( - 1 ) ; dataOutputStream . writeInt ( 0 ) ; dataOutputStream . flush ( ) ; } public static class LocationAsync extends AsyncTask < Integer , Void , float [ ] > { public AsyncResponse delegate = null ; @ Override protected float [ ] doInBackground ( Integer ... params ) { return new float [ ] { 0.0f , 0.0f } ; } @ Override protected void onPostExecute ( float [ ] floats ) { delegate . processFinish ( floats ) ; } } }
package com . SecUpwN . AIMSICD . utils ; import java . util . List ; public interface AsyncResponse { void processFinish ( float [ ] output ) ; void processFinish ( List < Cell > cells ) ; }
package com . SecUpwN . AIMSICD . utils ; import android . annotation . TargetApi ; import android . os . Build ; import android . telephony . CellIdentityCdma ; import android . telephony . CellIdentityGsm ; import android . telephony . CellIdentityLte ; import android . telephony . CellIdentityWcdma ; import android . telephony . CellInfo ; import android . telephony . CellInfoCdma ; import android . telephony . CellInfoGsm ; import android . telephony . CellInfoLte ; import android . telephony . CellInfoWcdma ; import android . telephony . CellSignalStrengthCdma ; import android . telephony . CellSignalStrengthGsm ; import android . telephony . CellSignalStrengthLte ; import android . telephony . CellSignalStrengthWcdma ; import android . telephony . PhoneStateListener ; import android . telephony . TelephonyManager ; import android . util . Log ; import java . util . List ; @ TargetApi ( Build . VERSION_CODES . JELLY_BEAN_MR2 ) public class DeviceApi17 { public static final String TAG = "DeviceApi17" ; public static void loadCellInfo ( TelephonyManager tm , Device pDevice ) { int lCurrentApiVersion = android . os . Build . VERSION . SDK_INT ; try { if ( pDevice . mCell == null ) { pDevice . mCell = new Cell ( ) ; } List < CellInfo > cellInfoList = tm . getAllCellInfo ( ) ; if ( cellInfoList != null ) { for ( final CellInfo info : cellInfoList ) { pDevice . mCell . setNetType ( tm . getNetworkType ( ) ) ; if ( info instanceof CellInfoGsm ) { final CellSignalStrengthGsm gsm = ( ( CellInfoGsm ) info ) . getCellSignalStrength ( ) ; final CellIdentityGsm identityGsm = ( ( CellInfoGsm ) info ) . getCellIdentity ( ) ; pDevice . mCell . setDBM ( gsm . getDbm ( ) ) ; pDevice . mCell . setCID ( identityGsm . getCid ( ) ) ; pDevice . mCell . setMCC ( identityGsm . getMcc ( ) ) ; pDevice . mCell . setMNC ( identityGsm . getMnc ( ) ) ; pDevice . mCell . setLAC ( identityGsm . getLac ( ) ) ; } else if ( info instanceof CellInfoCdma ) { final CellSignalStrengthCdma cdma = ( ( CellInfoCdma ) info ) . getCellSignalStrength ( ) ; final CellIdentityCdma identityCdma = ( ( CellInfoCdma ) info ) . getCellIdentity ( ) ; pDevice . mCell . setDBM ( cdma . getDbm ( ) ) ; pDevice . mCell . setCID ( identityCdma . getBasestationId ( ) ) ; pDevice . mCell . setMNC ( identityCdma . getSystemId ( ) ) ; pDevice . mCell . setLAC ( identityCdma . getNetworkId ( ) ) ; pDevice . mCell . setSID ( identityCdma . getSystemId ( ) ) ; } else if ( info instanceof CellInfoLte ) { final CellSignalStrengthLte lte = ( ( CellInfoLte ) info ) . getCellSignalStrength ( ) ; final CellIdentityLte identityLte = ( ( CellInfoLte ) info ) . getCellIdentity ( ) ; pDevice . mCell . setDBM ( lte . getDbm ( ) ) ; pDevice . mCell . setTimingAdvance ( lte . getTimingAdvance ( ) ) ; pDevice . mCell . setMCC ( identityLte . getMcc ( ) ) ; pDevice . mCell . setMNC ( identityLte . getMnc ( ) ) ; pDevice . mCell . setCID ( identityLte . getCi ( ) ) ; } else if ( lCurrentApiVersion >= Build . VERSION_CODES . JELLY_BEAN_MR2 && info instanceof CellInfoWcdma ) { final CellSignalStrengthWcdma wcdma = ( ( CellInfoWcdma ) info ) . getCellSignalStrength ( ) ; final CellIdentityWcdma identityWcdma = ( ( CellInfoWcdma ) info ) . getCellIdentity ( ) ; pDevice . mCell . setDBM ( wcdma . getDbm ( ) ) ; pDevice . mCell . setLAC ( identityWcdma . getLac ( ) ) ; pDevice . mCell . setMCC ( identityWcdma . getMcc ( ) ) ; pDevice . mCell . setMNC ( identityWcdma . getMnc ( ) ) ; pDevice . mCell . setCID ( identityWcdma . getCid ( ) ) ; pDevice . mCell . setPSC ( identityWcdma . getPsc ( ) ) ; } else { Log . i ( TAG , "Unknown type of cell signal! " + "ClassName: " + info . getClass ( ) . getSimpleName ( ) + " ToString: " + info . toString ( ) ) ; } if ( pDevice . mCell . isValid ( ) ) break ; } } } catch ( NullPointerException npe ) { Log . e ( TAG , "loadCellInfo: Unable to obtain cell signal information: " , npe ) ; } } public static void startListening ( TelephonyManager tm , PhoneStateListener listener ) { tm . listen ( listener , PhoneStateListener . LISTEN_CELL_INFO | PhoneStateListener . LISTEN_CELL_LOCATION | PhoneStateListener . LISTEN_DATA_CONNECTION_STATE | PhoneStateListener . LISTEN_SERVICE_STATE | PhoneStateListener . LISTEN_SIGNAL_STRENGTHS ) ; } }
package com . SecUpwN . AIMSICD . utils ; import android . content . Context ; import java . io . File ; import java . lang . reflect . Method ; import dalvik . system . DexFile ; public class SystemPropertiesReflection { private SystemPropertiesReflection ( ) { } public static String get ( Context context , String key ) throws IllegalArgumentException { String ret = "" ; try { ClassLoader cl = context . getClassLoader ( ) ; Class < ? > SystemProperties = cl . loadClass ( "android.os.SystemProperties" ) ; @ SuppressWarnings ( "rawtypes" ) Class [ ] paramTypes = new Class [ 1 ] ; paramTypes [ 0 ] = String . class ; Method get = SystemProperties . getMethod ( "get" , paramTypes ) ; Object [ ] params = new Object [ 1 ] ; params [ 0 ] = key ; ret = ( String ) get . invoke ( SystemProperties , params ) ; } catch ( IllegalArgumentException iAE ) { throw iAE ; } catch ( Exception e ) { ret = "" ; } return ret ; } public static String get ( Context context , String key , String def ) throws IllegalArgumentException { String ret = def ; try { ClassLoader cl = context . getClassLoader ( ) ; Class < ? > SystemProperties = cl . loadClass ( "android.os.SystemProperties" ) ; @ SuppressWarnings ( "rawtypes" ) Class [ ] paramTypes = new Class [ 2 ] ; paramTypes [ 0 ] = String . class ; paramTypes [ 1 ] = String . class ; Method get = SystemProperties . getMethod ( "get" , paramTypes ) ; Object [ ] params = new Object [ 2 ] ; params [ 0 ] = key ; params [ 1 ] = def ; ret = ( String ) get . invoke ( SystemProperties , params ) ; } catch ( IllegalArgumentException iAE ) { throw iAE ; } catch ( Exception e ) { ret = def ; } return ret ; } public static Integer getInt ( Context context , String key , int def ) throws IllegalArgumentException { Integer ret = def ; try { ClassLoader cl = context . getClassLoader ( ) ; Class < ? > SystemProperties = cl . loadClass ( "android.os.SystemProperties" ) ; @ SuppressWarnings ( "rawtypes" ) Class [ ] paramTypes = new Class [ 2 ] ; paramTypes [ 0 ] = String . class ; paramTypes [ 1 ] = int . class ; Method getInt = SystemProperties . getMethod ( "getInt" , paramTypes ) ; Object [ ] params = new Object [ 2 ] ; params [ 0 ] = key ; params [ 1 ] = def ; ret = ( Integer ) getInt . invoke ( SystemProperties , params ) ; } catch ( IllegalArgumentException iAE ) { throw iAE ; } catch ( Exception e ) { ret = def ; } return ret ; } public static Long getLong ( Context context , String key , long def ) throws IllegalArgumentException { Long ret = def ; try { ClassLoader cl = context . getClassLoader ( ) ; @ SuppressWarnings ( "rawtypes" ) Class SystemProperties = cl . loadClass ( "android.os.SystemProperties" ) ; @ SuppressWarnings ( "rawtypes" ) Class [ ] paramTypes = new Class [ 2 ] ; paramTypes [ 0 ] = String . class ; paramTypes [ 1 ] = long . class ; Method getLong = SystemProperties . getMethod ( "getLong" , paramTypes ) ; Object [ ] params = new Object [ 2 ] ; params [ 0 ] = key ; params [ 1 ] = def ; ret = ( Long ) getLong . invoke ( SystemProperties , params ) ; } catch ( IllegalArgumentException iAE ) { throw iAE ; } catch ( Exception e ) { ret = def ; } return ret ; } public static Boolean getBoolean ( Context context , String key , boolean def ) throws IllegalArgumentException { Boolean ret = def ; try { ClassLoader cl = context . getClassLoader ( ) ; @ SuppressWarnings ( "rawtypes" ) Class SystemProperties = cl . loadClass ( "android.os.SystemProperties" ) ; @ SuppressWarnings ( "rawtypes" ) Class [ ] paramTypes = new Class [ 2 ] ; paramTypes [ 0 ] = String . class ; paramTypes [ 1 ] = boolean . class ; Method getBoolean = SystemProperties . getMethod ( "getBoolean" , paramTypes ) ; Object [ ] params = new Object [ 2 ] ; params [ 0 ] = key ; params [ 1 ] = def ; ret = ( Boolean ) getBoolean . invoke ( SystemProperties , params ) ; } catch ( IllegalArgumentException iAE ) { throw iAE ; } catch ( Exception e ) { ret = def ; } return ret ; } public static void set ( Context context , String key , String val ) throws IllegalArgumentException { try { @ SuppressWarnings ( "unused" ) DexFile df = new DexFile ( new File ( "/system/app/Settings.apk" ) ) ; @ SuppressWarnings ( "unused" ) ClassLoader cl = context . getClassLoader ( ) ; @ SuppressWarnings ( "rawtypes" ) Class SystemProperties = Class . forName ( "android.os.SystemProperties" ) ; @ SuppressWarnings ( "rawtypes" ) Class [ ] paramTypes = new Class [ 2 ] ; paramTypes [ 0 ] = String . class ; paramTypes [ 1 ] = String . class ; Method set = SystemProperties . getMethod ( "set" , paramTypes ) ; Object [ ] params = new Object [ 2 ] ; params [ 0 ] = key ; params [ 1 ] = val ; set . invoke ( SystemProperties , params ) ; } catch ( IllegalArgumentException iAE ) { throw iAE ; } catch ( Exception ignored ) { } } }
package com . stericson . RootShell ; import com . stericson . RootShell . exceptions . RootDeniedException ; import com . stericson . RootShell . execution . Command ; import com . stericson . RootShell . execution . Shell ; import android . util . Log ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . concurrent . TimeoutException ; public class RootShell { public static boolean debugMode = false ; public static final String version = "RootShell v1.2" ; public static boolean handlerEnabled = true ; public static int defaultCommandTimeout = 20000 ; public static enum LogLevel { VERBOSE , ERROR , DEBUG , WARN } public static void closeAllShells ( ) throws IOException { Shell . closeAll ( ) ; } public static void closeCustomShell ( ) throws IOException { Shell . closeCustomShell ( ) ; } public static void closeShell ( boolean root ) throws IOException { if ( root ) { Shell . closeRootShell ( ) ; } else { Shell . closeShell ( ) ; } } public static boolean exists ( final String file ) { return exists ( file , false ) ; } public static boolean exists ( final String file , boolean isDir ) { final List < String > result = new ArrayList < String > ( ) ; String cmdToExecute = "ls " + ( isDir ? "-d " : " " ) ; Command command = new Command ( 0 , false , cmdToExecute + file ) { @ Override public void commandOutput ( int id , String line ) { RootShell . log ( line ) ; result . add ( line ) ; super . commandOutput ( id , line ) ; } } ; try { RootShell . getShell ( false ) . add ( command ) ; commandWait ( RootShell . getShell ( false ) , command ) ; } catch ( Exception e ) { return false ; } for ( String line : result ) { if ( line . trim ( ) . equals ( file ) ) { return true ; } } result . clear ( ) ; try { RootShell . getShell ( true ) . add ( command ) ; commandWait ( RootShell . getShell ( true ) , command ) ; } catch ( Exception e ) { return false ; } List < String > final_result = new ArrayList < String > ( ) ; final_result . addAll ( result ) ; for ( String line : final_result ) { if ( line . trim ( ) . equals ( file ) ) { return true ; } } return false ; } public static List < String > findBinary ( final String binaryName ) { return findBinary ( binaryName , null ) ; } public static List < String > findBinary ( final String binaryName , List < String > searchPaths ) { final List < String > foundPaths = new ArrayList < String > ( ) ; boolean found = false ; if ( searchPaths == null ) { searchPaths = RootShell . getPath ( ) ; } RootShell . log ( "Checking for " + binaryName ) ; try { for ( String path : searchPaths ) { if ( ! path . endsWith ( "/" ) ) { path += "/" ; } final String currentPath = path ; Command cc = new Command ( 0 , false , "stat " + path + binaryName ) { @ Override public void commandOutput ( int id , String line ) { if ( line . contains ( "File: " ) && line . contains ( binaryName ) ) { foundPaths . add ( currentPath ) ; RootShell . log ( binaryName + " was found here: " + currentPath ) ; } RootShell . log ( line ) ; super . commandOutput ( id , line ) ; } } ; RootShell . getShell ( false ) . add ( cc ) ; commandWait ( RootShell . getShell ( false ) , cc ) ; } found = ! foundPaths . isEmpty ( ) ; } catch ( Exception e ) { RootShell . log ( binaryName + " was not found, more information MAY be available with Debugging on." ) ; } if ( ! found ) { RootShell . log ( "Trying second method" ) ; for ( String path : searchPaths ) { if ( ! path . endsWith ( "/" ) ) { path += "/" ; } if ( RootShell . exists ( path + binaryName ) ) { RootShell . log ( binaryName + " was found here: " + path ) ; foundPaths . add ( path ) ; } else { RootShell . log ( binaryName + " was NOT found here: " + path ) ; } } } Collections . reverse ( foundPaths ) ; return foundPaths ; } public static Shell getCustomShell ( String shellPath , int timeout ) throws IOException , TimeoutException , RootDeniedException { return RootShell . getCustomShell ( shellPath , timeout ) ; } public static List < String > getPath ( ) { return Arrays . asList ( System . getenv ( "PATH" ) . split ( ":" ) ) ; } public static Shell getShell ( boolean root , int timeout , Shell . ShellContext shellContext , int retry ) throws IOException , TimeoutException , RootDeniedException { if ( root ) { return Shell . startRootShell ( timeout , shellContext , retry ) ; } else { return Shell . startShell ( timeout ) ; } } public static Shell getShell ( boolean root , int timeout , Shell . ShellContext shellContext ) throws IOException , TimeoutException , RootDeniedException { return getShell ( root , timeout , shellContext , 3 ) ; } public static Shell getShell ( boolean root , Shell . ShellContext shellContext ) throws IOException , TimeoutException , RootDeniedException { return getShell ( root , 0 , shellContext , 3 ) ; } public static Shell getShell ( boolean root , int timeout ) throws IOException , TimeoutException , RootDeniedException { return getShell ( root , timeout , Shell . defaultContext , 3 ) ; } public static Shell getShell ( boolean root ) throws IOException , TimeoutException , RootDeniedException { return RootShell . getShell ( root , 0 ) ; } public static boolean isAccessGiven ( ) { final Set < String > ID = new HashSet < String > ( ) ; final int IAG = 158 ; try { RootShell . log ( "Checking for Root access" ) ; Command command = new Command ( IAG , false , "id" ) { @ Override public void commandOutput ( int id , String line ) { if ( id == IAG ) { ID . addAll ( Arrays . asList ( line . split ( " " ) ) ) ; } super . commandOutput ( id , line ) ; } } ; Shell . startRootShell ( ) . add ( command ) ; commandWait ( Shell . startRootShell ( ) , command ) ; for ( String userid : ID ) { RootShell . log ( userid ) ; if ( userid . toLowerCase ( ) . contains ( "uid=0" ) ) { RootShell . log ( "Access Given" ) ; return true ; } } return false ; } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } } public static boolean isBusyboxAvailable ( ) { return ( findBinary ( "busybox" ) ) . size ( ) > 0 ; } public static boolean isRootAvailable ( ) { return ( findBinary ( "su" ) ) . size ( ) > 0 ; } public static void log ( String msg ) { log ( null , msg , LogLevel . DEBUG , null ) ; } public static void log ( String TAG , String msg ) { log ( TAG , msg , LogLevel . DEBUG , null ) ; } public static void log ( String msg , LogLevel type , Exception e ) { log ( null , msg , type , e ) ; } public static boolean islog ( ) { return debugMode ; } public static void log ( String TAG , String msg , LogLevel type , Exception e ) { if ( msg != null && ! msg . equals ( "" ) ) { if ( debugMode ) { if ( TAG == null ) { TAG = version ; } switch ( type ) { case VERBOSE : Log . v ( TAG , msg ) ; break ; case ERROR : Log . e ( TAG , msg , e ) ; break ; case DEBUG : Log . d ( TAG , msg ) ; break ; case WARN : Log . w ( TAG , msg ) ; break ; } } } } private static void commandWait ( Shell shell , Command cmd ) throws Exception { while ( ! cmd . isFinished ( ) ) { RootShell . log ( version , shell . getCommandQueuePositionString ( cmd ) ) ; synchronized ( cmd ) { try { if ( ! cmd . isFinished ( ) ) { cmd . wait ( 2000 ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } if ( ! cmd . isExecuting ( ) && ! cmd . isFinished ( ) ) { if ( ! shell . isExecuting && ! shell . isReading ) { RootShell . log ( version , "Waiting for a command to be executed in a shell that is not executing and not reading! \n\n Command: " + cmd . getCommand ( ) ) ; Exception e = new Exception ( ) ; e . setStackTrace ( Thread . currentThread ( ) . getStackTrace ( ) ) ; e . printStackTrace ( ) ; } else if ( shell . isExecuting && ! shell . isReading ) { RootShell . log ( version , "Waiting for a command to be executed in a shell that is executing but not reading! \n\n Command: " + cmd . getCommand ( ) ) ; Exception e = new Exception ( ) ; e . setStackTrace ( Thread . currentThread ( ) . getStackTrace ( ) ) ; e . printStackTrace ( ) ; } else { RootShell . log ( version , "Waiting for a command to be executed in a shell that is not reading! \n\n Command: " + cmd . getCommand ( ) ) ; Exception e = new Exception ( ) ; e . setStackTrace ( Thread . currentThread ( ) . getStackTrace ( ) ) ; e . printStackTrace ( ) ; } } } } }
package com . SecUpwN . AIMSICD . utils ; public class GeoLocation { private double radLat ; private double radLon ; private double degLat ; private double degLon ; private static final double MIN_LAT = Math . toRadians ( - 90d ) ; private static final double MAX_LAT = Math . toRadians ( 90d ) ; private static final double MIN_LON = Math . toRadians ( - 180d ) ; private static final double MAX_LON = Math . toRadians ( 180d ) ; private GeoLocation ( ) { } public static GeoLocation fromDegrees ( double latitude , double longitude ) { GeoLocation result = new GeoLocation ( ) ; result . radLat = Math . toRadians ( latitude ) ; result . radLon = Math . toRadians ( longitude ) ; result . degLat = latitude ; result . degLon = longitude ; result . checkBounds ( ) ; return result ; } public static GeoLocation fromRadians ( double latitude , double longitude ) { GeoLocation result = new GeoLocation ( ) ; result . radLat = latitude ; result . radLon = longitude ; result . degLat = Math . toDegrees ( latitude ) ; result . degLon = Math . toDegrees ( longitude ) ; result . checkBounds ( ) ; return result ; } private void checkBounds ( ) { if ( radLat < MIN_LAT || radLat > MAX_LAT || radLon < MIN_LON || radLon > MAX_LON ) { throw new IllegalArgumentException ( ) ; } } public double getLatitudeInDegrees ( ) { return degLat ; } public double getLongitudeInDegrees ( ) { return degLon ; } public double getLatitudeInRadians ( ) { return radLat ; } public double getLongitudeInRadians ( ) { return radLon ; } @ Override public String toString ( ) { return "(" + degLat + "\u00B0, " + degLon + "\u00B0) = (" + radLat + " rad, " + radLon + " rad)" ; } public double distanceTo ( GeoLocation location , double radius ) { return Math . acos ( Math . sin ( radLat ) * Math . sin ( location . radLat ) + Math . cos ( radLat ) * Math . cos ( location . radLat ) * Math . cos ( radLon - location . radLon ) ) * radius ; } public GeoLocation [ ] boundingCoordinates ( double distance , double radius ) { if ( radius < 0d || distance < 0d ) { throw new IllegalArgumentException ( ) ; } double radDist = distance / radius ; double minLat = radLat - radDist ; double maxLat = radLat + radDist ; double minLon , maxLon ; if ( minLat > MIN_LAT && maxLat < MAX_LAT ) { double deltaLon = Math . asin ( Math . sin ( radDist ) / Math . cos ( radLat ) ) ; minLon = radLon - deltaLon ; if ( minLon < MIN_LON ) { minLon += 2d * Math . PI ; } maxLon = radLon + deltaLon ; if ( maxLon > MAX_LON ) { maxLon -= 2d * Math . PI ; } } else { minLat = Math . max ( minLat , MIN_LAT ) ; maxLat = Math . min ( maxLat , MAX_LAT ) ; minLon = MIN_LON ; maxLon = MAX_LON ; } return new GeoLocation [ ] { fromRadians ( minLat , minLon ) , fromRadians ( maxLat , maxLon ) } ; } }
package com . SecUpwN . AIMSICD . utils ; import android . app . Notification ; import android . app . NotificationManager ; import android . app . PendingIntent ; import android . content . ContentValues ; import android . content . Context ; import android . content . Intent ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . support . v4 . app . NotificationCompat ; import android . util . Log ; import android . widget . Toast ; import com . SecUpwN . AIMSICD . AIMSICD ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . activities . CustomPopUp ; import com . SecUpwN . AIMSICD . smsdetection . SmsDetectionDbAccess ; import com . SecUpwN . AIMSICD . smsdetection . SmsDetectionDbHelper ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . net . URL ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Date ; public class MiscUtils { public static String setAssetsString ( Context context ) { BufferedReader reader = null ; StringBuilder buildassets = new StringBuilder ( ) ; try { reader = new BufferedReader ( new InputStreamReader ( context . getAssets ( ) . open ( "CREDITS" ) ) ) ; String rline = reader . readLine ( ) . replace ( "'" , "\\'" ) . replace ( "\\n" , "" ) ; while ( rline != null ) { buildassets . append ( rline ) . append ( "\n" ) ; rline = reader . readLine ( ) . replace ( "'" , "\\'" ) . replace ( "\\n" , "" ) ; } } catch ( Exception ee ) { ee . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( Exception ee ) { ee . printStackTrace ( ) ; } } } return buildassets . toString ( ) ; } public static void startPopUpInfo ( Context context , int mode ) { Intent i = new Intent ( context , CustomPopUp . class ) ; i . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; i . putExtra ( "display_mode" , mode ) ; context . startActivity ( i ) ; } public static String getCurrentTimeStamp ( ) { Date now = new Date ( ) ; String timestamp = new SimpleDateFormat ( "yyyyMMddHHmmss" ) . format ( now ) ; return timestamp ; } public static void showNotification ( Context context , String tickertext , String contentText , int drawable_id , boolean auto_cancel ) { int NOTIFICATION_ID = 1 ; Intent notificationIntent = new Intent ( context , AIMSICD . class ) ; notificationIntent . addFlags ( Intent . FLAG_ACTIVITY_SINGLE_TOP | Intent . FLAG_FROM_BACKGROUND ) ; PendingIntent contentIntent = PendingIntent . getActivity ( context , NOTIFICATION_ID , notificationIntent , PendingIntent . FLAG_CANCEL_CURRENT ) ; Notification mBuilder = new NotificationCompat . Builder ( context ) . setSmallIcon ( drawable_id ) . setTicker ( tickertext ) . setContentTitle ( context . getResources ( ) . getString ( R . string . main_app_name ) ) . setContentText ( contentText ) . setOngoing ( true ) . setAutoCancel ( auto_cancel ) . setContentIntent ( contentIntent ) . build ( ) ; NotificationManager mNotificationManager = ( NotificationManager ) context . getSystemService ( Context . NOTIFICATION_SERVICE ) ; mNotificationManager . notify ( NOTIFICATION_ID , mBuilder ) ; } public static void refreshDetectionDbStrings ( Context con ) { SmsDetectionDbAccess dbaccess = new SmsDetectionDbAccess ( con ) ; BufferedReader reader = null ; StringBuilder json_file = new StringBuilder ( ) ; try { reader = new BufferedReader ( new InputStreamReader ( con . getAssets ( ) . open ( "det_strings.json" ) ) ) ; String rline = reader . readLine ( ) ; while ( rline != null ) { json_file . append ( rline ) ; rline = reader . readLine ( ) ; } Log . i ( "refreshDetectionDbStrings" , json_file . toString ( ) ) ; } catch ( Exception ee ) { ee . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( Exception ee ) { ee . printStackTrace ( ) ; } } } JSONObject json_response ; try { json_response = new JSONObject ( json_file . toString ( ) ) ; JSONArray json_array_node = json_response . optJSONArray ( "load_detection_strings" ) ; int json_array_len = json_array_node . length ( ) ; for ( int i = 0 ; i < json_array_len ; i ++ ) { dbaccess . open ( ) ; JSONObject current_json_object = json_array_node . getJSONObject ( i ) ; ContentValues store_new_det_string = new ContentValues ( ) ; store_new_det_string . put ( SmsDetectionDbHelper . SILENT_SMS_STRING_COLUMN , current_json_object . optString ( "detection_string" ) . toString ( ) ) ; store_new_det_string . put ( SmsDetectionDbHelper . SILENT_SMS_TYPE_COLUMN , current_json_object . optString ( "detection_type" ) . toString ( ) ) ; if ( dbaccess . insertNewDetectionString ( store_new_det_string ) ) { Log . i ( "refreshDetectionDbStrings" , ">>>String added success" ) ; } dbaccess . close ( ) ; } } catch ( JSONException e ) { dbaccess . close ( ) ; Log . e ( "refreshDetectionDbStrings" , ">>> Error parsing JsonFile " + e . toString ( ) ) ; e . printStackTrace ( ) ; } } }
package com . SecUpwN . AIMSICD . utils ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . AsyncTask ; import android . os . Environment ; import android . support . v4 . content . LocalBroadcastManager ; import android . util . Log ; import com . SecUpwN . AIMSICD . AIMSICD ; import com . SecUpwN . AIMSICD . BuildConfig ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . activities . MapViewerOsmDroid ; import com . SecUpwN . AIMSICD . adapters . AIMSICDDbAdapter ; import com . SecUpwN . AIMSICD . constants . TinyDbKeys ; import com . SecUpwN . AIMSICD . service . AimsicdService ; import com . SecUpwN . AIMSICD . service . CellTracker ; import com . SecUpwN . AIMSICD . utils . TinyDB ; import java . io . BufferedInputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . MalformedURLException ; import java . net . URL ; import org . apache . http . HttpResponse ; import org . apache . http . client . HttpClient ; import org . apache . http . client . methods . HttpPost ; import org . apache . http . entity . ByteArrayEntity ; import org . apache . http . entity . mime . MultipartEntity ; import org . apache . http . entity . mime . content . InputStreamBody ; import org . apache . http . entity . mime . content . StringBody ; import org . apache . http . impl . client . DefaultHttpClient ; public class RequestTask extends BaseAsyncTask < String , Integer , String > { public static final int REQUEST_TIMEOUT_MAPS = 20000 ; public static final int REQUEST_TIMEOUT_MENU = 40000 ; public static final char DBE_DOWNLOAD_REQUEST = 1 ; public static final char DBE_DOWNLOAD_REQUEST_FROM_MAP = 2 ; public static final char DBE_UPLOAD_REQUEST = 6 ; public static final char BACKUP_DATABASE = 3 ; public static final char RESTORE_DATABASE = 4 ; public static final char CELL_LOOKUP = 5 ; public static final String TAG = "AIMSICD" ; public static final String mTAG = "RequestTask" ; private final AIMSICDDbAdapter mDbAdapter ; private final Context mAppContext ; private final char mType ; private int mTimeOut ; public RequestTask ( Context context , char type ) { super ( ( Activity ) context ) ; mType = type ; mAppContext = context . getApplicationContext ( ) ; mDbAdapter = new AIMSICDDbAdapter ( mAppContext ) ; mTimeOut = REQUEST_TIMEOUT_MAPS ; } @ Override protected String doInBackground ( String ... commandString ) { switch ( mType ) { case DBE_UPLOAD_REQUEST : try { boolean prepared = mDbAdapter . prepareOpenCellUploadData ( ) ; Log . i ( TAG , mTAG + ": OCID upload data prepared - " + String . valueOf ( prepared ) ) ; if ( prepared ) { File file = new File ( ( mAppContext . getExternalFilesDir ( null ) + File . separator ) + "OpenCellID/aimsicd-ocid-data.csv" ) ; publishProgress ( 25 , 100 ) ; MultipartEntity mpEntity = new MultipartEntity ( ) ; FileInputStream fin = new FileInputStream ( file ) ; String csv = Helpers . convertStreamToString ( fin ) ; mpEntity . addPart ( "key" , new StringBody ( CellTracker . OCID_API_KEY ) ) ; mpEntity . addPart ( "datafile" , new InputStreamBody ( new ByteArrayInputStream ( csv . getBytes ( ) ) , "text/csv" , "aimsicd-ocid-data.csv" ) ) ; ByteArrayOutputStream bAOS = new ByteArrayOutputStream ( ) ; publishProgress ( 50 , 100 ) ; mpEntity . writeTo ( bAOS ) ; bAOS . flush ( ) ; ByteArrayEntity bArrEntity = new ByteArrayEntity ( bAOS . toByteArray ( ) ) ; bAOS . close ( ) ; bArrEntity . setChunked ( false ) ; bArrEntity . setContentEncoding ( mpEntity . getContentEncoding ( ) ) ; bArrEntity . setContentType ( mpEntity . getContentType ( ) ) ; HttpClient httpclient ; HttpPost httppost ; HttpResponse response ; httpclient = new DefaultHttpClient ( ) ; httppost = new HttpPost ( "http://www.opencellid.org/measure/uploadCsv" ) ; publishProgress ( 60 , 100 ) ; httppost . setEntity ( bArrEntity ) ; response = httpclient . execute ( httppost ) ; publishProgress ( 80 , 100 ) ; if ( response != null ) { Log . i ( TAG , mTAG + ": OCID Upload Response: " + response . getStatusLine ( ) . getStatusCode ( ) + " - " + response . getStatusLine ( ) ) ; if ( response . getStatusLine ( ) . getStatusCode ( ) == org . apache . http . HttpStatus . SC_OK ) { mDbAdapter . ocidProcessed ( ) ; } publishProgress ( 95 , 100 ) ; } return "Successful" ; } else { Helpers . msgLong ( mAppContext , mAppContext . getString ( R . string . no_data_for_publishing ) ) ; return null ; } } catch ( Exception e ) { Log . e ( TAG , mTAG + ": Upload OpenCellID data Exception - " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } case DBE_DOWNLOAD_REQUEST : mTimeOut = REQUEST_TIMEOUT_MENU ; case DBE_DOWNLOAD_REQUEST_FROM_MAP : int count ; try { int total ; int progress = 0 ; File dir = new File ( ( mAppContext . getExternalFilesDir ( null ) + File . separator ) + "OpenCellID/" ) ; if ( ! dir . exists ( ) ) { dir . mkdirs ( ) ; } File file = new File ( dir , "opencellid.csv" ) ; URL url = new URL ( commandString [ 0 ] ) ; HttpURLConnection urlConnection = ( HttpURLConnection ) url . openConnection ( ) ; urlConnection . setRequestMethod ( "GET" ) ; urlConnection . setConnectTimeout ( mTimeOut ) ; urlConnection . setReadTimeout ( mTimeOut ) ; urlConnection . setDoInput ( true ) ; urlConnection . connect ( ) ; if ( urlConnection . getResponseCode ( ) != 200 ) { try { String error = Helpers . convertStreamToString ( urlConnection . getErrorStream ( ) ) ; Helpers . msgLong ( mAppContext , mAppContext . getString ( R . string . download_error ) + " " + error ) ; Log . e ( TAG , mTAG + ": Download OCID data error: " + error ) ; } catch ( Exception e ) { Helpers . msgLong ( mAppContext , mAppContext . getString ( R . string . download_error ) + " " + e . getClass ( ) . getName ( ) + " - " + e . getMessage ( ) ) ; Log . e ( TAG , mTAG + ": Download OCID exception: " + e ) ; e . printStackTrace ( ) ; } return "Error" ; } else { total = urlConnection . getContentLength ( ) ; if ( total == - 1 ) { Log . d ( TAG , mTAG + ":doInBackground DBE_DOWNLOAD_REQUEST total not returned!" ) ; total = 1024 ; } else { Log . d ( TAG , mTAG + ":doInBackground DBE_DOWNLOAD_REQUEST total: " + total ) ; publishProgress ( ( int ) ( 0.25 * total ) , total ) ; } FileOutputStream output = new FileOutputStream ( file , false ) ; InputStream input = new BufferedInputStream ( urlConnection . getInputStream ( ) ) ; byte [ ] data = new byte [ 1024 ] ; while ( ( count = input . read ( data ) ) > 0 ) { output . write ( data , 0 , count ) ; progress += count ; publishProgress ( progress , total ) ; } output . flush ( ) ; output . close ( ) ; } urlConnection . disconnect ( ) ; return "Successful" ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; return null ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } case BACKUP_DATABASE : mDbAdapter . open ( ) ; if ( mDbAdapter . backupDB ( ) ) { mDbAdapter . close ( ) ; return "Successful" ; } mDbAdapter . close ( ) ; return null ; case RESTORE_DATABASE : mDbAdapter . open ( ) ; if ( mDbAdapter . restoreDB ( ) ) { mDbAdapter . close ( ) ; return "Successful" ; } mDbAdapter . close ( ) ; return null ; } return null ; } @ Override protected void onPreExecute ( ) { super . onPreExecute ( ) ; Log . d ( TAG , mTAG + ":onPreExecute Started" ) ; } @ Override protected void onProgressUpdate ( Integer ... values ) { super . onProgressUpdate ( values ) ; Log . v ( TAG , mTAG + ":onProgressUpdate values[0]: " + values [ 0 ] + " values[1]: " + values [ 1 ] ) ; AIMSICD . mProgressBar . setProgress ( values [ 0 ] ) ; AIMSICD . mProgressBar . setMax ( values [ 1 ] ) ; } @ Override protected void onPostExecute ( String result ) { super . onPostExecute ( result ) ; AIMSICD . mProgressBar . setProgress ( 0 ) ; TinyDB tinydb = TinyDB . getInstance ( ) ; switch ( mType ) { case DBE_DOWNLOAD_REQUEST : if ( result != null && result . equals ( "Successful" ) ) { mDbAdapter . open ( ) ; if ( mDbAdapter . updateOpenCellID ( ) ) { Helpers . msgShort ( mAppContext , mAppContext . getString ( R . string . opencellid_data_successfully_received ) ) ; } mDbAdapter . checkDBe ( ) ; mDbAdapter . close ( ) ; tinydb . putBoolean ( "ocid_downloaded" , true ) ; } else { Helpers . msgLong ( mAppContext , mAppContext . getString ( R . string . error_retrieving_opencellid_data ) ) ; } break ; case DBE_DOWNLOAD_REQUEST_FROM_MAP : if ( result != null && result . equals ( "Successful" ) ) { mDbAdapter . open ( ) ; if ( mDbAdapter . updateOpenCellID ( ) ) { Intent intent = new Intent ( MapViewerOsmDroid . updateOpenCellIDMarkers ) ; LocalBroadcastManager . getInstance ( mAppContext ) . sendBroadcast ( intent ) ; Helpers . msgShort ( mAppContext , mAppContext . getString ( R . string . opencellid_data_successfully_received_markers_updated ) ) ; mDbAdapter . checkDBe ( ) ; mDbAdapter . close ( ) ; tinydb . putBoolean ( "ocid_downloaded" , true ) ; } } else { Helpers . msgLong ( mAppContext , mAppContext . getString ( R . string . error_retrieving_opencellid_data ) ) ; } showHideMapProgressBar ( false ) ; TinyDB . getInstance ( ) . putBoolean ( TinyDbKeys . FINISHED_LOAD_IN_MAP , true ) ; break ; case DBE_UPLOAD_REQUEST : if ( result != null && result . equals ( "Successful" ) ) { Helpers . msgShort ( mAppContext , mAppContext . getString ( R . string . uploaded_bts_data_successfully ) ) ; } else { Helpers . msgLong ( mAppContext , mAppContext . getString ( R . string . error_uploading_bts_data ) ) ; } break ; case RESTORE_DATABASE : if ( result != null && result . equals ( "Successful" ) ) { Helpers . msgShort ( mAppContext , mAppContext . getString ( R . string . restore_database_completed ) ) ; } else { Helpers . msgLong ( mAppContext , mAppContext . getString ( R . string . error_restoring_database ) ) ; } break ; case BACKUP_DATABASE : if ( result != null && result . equals ( "Successful" ) ) { tinydb . putInt ( "pref_last_db_backup_version" , AIMSICDDbAdapter . DATABASE_VERSION ) ; Activity lActivity = getActivity ( ) ; if ( lActivity != null ) { final AlertDialog . Builder builder = new AlertDialog . Builder ( lActivity ) ; builder . setTitle ( R . string . database_export_successful ) . setMessage ( lActivity . getString ( R . string . database_backup_successfully_saved_to ) + "\n" + AIMSICDDbAdapter . FOLDER ) ; builder . create ( ) . show ( ) ; } } else { Helpers . msgLong ( mAppContext , mAppContext . getString ( R . string . error_backing_up_data ) ) ; } } } @ Override protected void onActivityDetached ( ) { if ( mType == DBE_DOWNLOAD_REQUEST_FROM_MAP ) { showHideMapProgressBar ( false ) ; } } @ Override protected void onActivityAttached ( ) { if ( mType == DBE_DOWNLOAD_REQUEST_FROM_MAP ) { showHideMapProgressBar ( true ) ; } } @ Override protected void onCancelled ( ) { super . onCancelled ( ) ; if ( mType == DBE_DOWNLOAD_REQUEST_FROM_MAP ) { showHideMapProgressBar ( false ) ; } } private void showHideMapProgressBar ( boolean pFlag ) { Activity lActivity = getActivity ( ) ; if ( BuildConfig . DEBUG && lActivity == null ) { Log . v ( TAG , "BaseTask showHideMapProgressBar() activity is null" ) ; } if ( lActivity != null && lActivity instanceof MapViewerOsmDroid ) { ( ( MapViewerOsmDroid ) lActivity ) . setRefreshActionButtonState ( pFlag ) ; } } }
package com . SecUpwN . AIMSICD . utils ; import android . content . Context ; import android . location . Location ; import android . os . Build ; import android . telephony . TelephonyManager ; import android . telephony . cdma . CdmaCellLocation ; import android . telephony . gsm . GsmCellLocation ; import android . util . Log ; public class Device { private final String TAG = "AIMSICD" ; private final String mTAG = "Device" ; public Cell mCell ; private int mPhoneID = - 1 ; private String mNetType = "" ; private String mCellInfo = "" ; private String mDataState = "" ; private String mDataStateShort = "" ; private String mNetName = "" ; private String mMncmcc = "" ; private String mSimCountry = "" ; private String mPhoneType = "" ; private String mIMEI = "" ; private String mIMEIV = "" ; private String mSimOperator = "" ; private String mSimOperatorName = "" ; private String mSimSerial = "" ; private String mSimSubs = "" ; private String mDataActivityType = "" ; private String mDataActivityTypeShort = "" ; private boolean mRoaming ; private Location mLastLocation ; private static final int TWO_MINUTES = 1000 * 60 * 2 ; public void refreshDeviceInfo ( TelephonyManager tm , Context context ) { mIMEI = tm . getDeviceId ( ) ; mIMEIV = tm . getDeviceSoftwareVersion ( ) ; mPhoneID = tm . getPhoneType ( ) ; mRoaming = tm . isNetworkRoaming ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN_MR2 ) { mNetType = getNetworkTypeName ( ) ; DeviceApi17 . loadCellInfo ( tm , this ) ; } if ( mCell == null ) mCell = new Cell ( ) ; switch ( mPhoneID ) { case TelephonyManager . PHONE_TYPE_NONE : case TelephonyManager . PHONE_TYPE_SIP : case TelephonyManager . PHONE_TYPE_GSM : mPhoneType = "GSM" ; mMncmcc = tm . getNetworkOperator ( ) ; if ( mMncmcc != null && mMncmcc . length ( ) >= 5 ) { try { if ( mCell . getMCC ( ) == Integer . MAX_VALUE ) mCell . setMCC ( Integer . parseInt ( tm . getNetworkOperator ( ) . substring ( 0 , 3 ) ) ) ; if ( mCell . getMNC ( ) == Integer . MAX_VALUE ) mCell . setMNC ( Integer . parseInt ( tm . getNetworkOperator ( ) . substring ( 3 , 5 ) ) ) ; } catch ( Exception e ) { Log . i ( TAG , mTAG + ":MncMcc parse exception - " + e . getMessage ( ) ) ; } } mNetName = tm . getNetworkOperatorName ( ) ; if ( ! mCell . isValid ( ) ) { GsmCellLocation gsmCellLocation = ( GsmCellLocation ) tm . getCellLocation ( ) ; if ( gsmCellLocation != null ) { mCell . setCID ( gsmCellLocation . getCid ( ) ) ; mCell . setLAC ( gsmCellLocation . getLac ( ) ) ; mCell . setPSC ( gsmCellLocation . getPsc ( ) ) ; } } break ; case TelephonyManager . PHONE_TYPE_CDMA : mPhoneType = "CDMA" ; if ( ! mCell . isValid ( ) ) { CdmaCellLocation cdmaCellLocation = ( CdmaCellLocation ) tm . getCellLocation ( ) ; if ( cdmaCellLocation != null ) { mCell . setCID ( cdmaCellLocation . getBaseStationId ( ) ) ; mCell . setLAC ( cdmaCellLocation . getNetworkId ( ) ) ; mCell . setSID ( cdmaCellLocation . getSystemId ( ) ) ; mCell . setMNC ( cdmaCellLocation . getSystemId ( ) ) ; String homeOperator = Helpers . getSystemProp ( context , "ro.cdma.home.operator.numeric" , "UNKNOWN" ) ; if ( ! homeOperator . contains ( "UNKNOWN" ) ) { try { if ( mCell . getMCC ( ) == Integer . MAX_VALUE ) mCell . setMCC ( Integer . valueOf ( homeOperator . substring ( 0 , 3 ) ) ) ; if ( mCell . getMNC ( ) == Integer . MAX_VALUE ) mCell . setMNC ( Integer . valueOf ( homeOperator . substring ( 3 , 5 ) ) ) ; } catch ( Exception e ) { Log . i ( TAG , mTAG + ":homeOperator parse exception - " + e . getMessage ( ) ) ; } } } } break ; } int simState = tm . getSimState ( ) ; switch ( simState ) { case ( TelephonyManager . SIM_STATE_ABSENT ) : break ; case ( TelephonyManager . SIM_STATE_NETWORK_LOCKED ) : break ; case ( TelephonyManager . SIM_STATE_PIN_REQUIRED ) : break ; case ( TelephonyManager . SIM_STATE_PUK_REQUIRED ) : break ; case ( TelephonyManager . SIM_STATE_UNKNOWN ) : break ; case ( TelephonyManager . SIM_STATE_READY ) : { mSimCountry = getSimCountry ( tm ) ; mSimOperator = getSimOperator ( tm ) ; mSimOperatorName = getSimOperatorName ( tm ) ; mSimSerial = getSimSerial ( tm ) ; mSimSubs = getSimSubs ( tm ) ; } } mDataActivityType = getDataActivity ( tm ) ; mDataState = getDataState ( tm ) ; } public String getCellInfo ( ) { return mCellInfo ; } public void setCellInfo ( String cellInfo ) { mCellInfo = cellInfo ; } public int getPhoneID ( ) { return mPhoneID ; } String getSimCountry ( TelephonyManager tm ) { try { if ( tm . getSimState ( ) == TelephonyManager . SIM_STATE_READY ) { mSimCountry = ( tm . getSimCountryIso ( ) != null ) ? tm . getSimCountryIso ( ) : "N/A" ; } else { mSimCountry = "N/A" ; } } catch ( Exception e ) { mSimCountry = "N/A" ; Log . e ( TAG , mTAG + ":getSimCountry " + e ) ; } if ( mSimCountry . isEmpty ( ) ) { mSimCountry = "N/A" ; } return mSimCountry ; } public String getSimCountry ( ) { return mSimCountry ; } public String getSimOperator ( TelephonyManager tm ) { try { if ( tm . getSimState ( ) == TelephonyManager . SIM_STATE_READY ) { mSimOperator = ( tm . getSimOperator ( ) != null ) ? tm . getSimOperator ( ) : "N/A" ; } else { mSimOperator = "N/A" ; } } catch ( Exception e ) { mSimOperator = "N/A" ; Log . e ( TAG , mTAG + ":getSimOperator " + e ) ; } if ( mSimOperator . isEmpty ( ) ) { mSimOperator = "N/A" ; } return mSimOperator ; } public String getSimOperator ( ) { return mSimOperator ; } String getSimOperatorName ( TelephonyManager tm ) { try { if ( tm . getSimState ( ) == TelephonyManager . SIM_STATE_READY ) { mSimOperatorName = ( tm . getSimOperatorName ( ) != null ) ? tm . getSimOperatorName ( ) : "N/A" ; } else { mSimOperatorName = "N/A" ; } } catch ( Exception e ) { mSimOperatorName = "N/A" ; } if ( mSimOperatorName . isEmpty ( ) ) { mSimOperatorName = "N/A" ; } return mSimOperatorName ; } public String getSimOperatorName ( ) { return mSimOperatorName ; } String getSimSubs ( TelephonyManager tm ) { try { if ( tm . getSimState ( ) == TelephonyManager . SIM_STATE_READY ) { mSimSubs = ( tm . getSubscriberId ( ) != null ) ? tm . getSubscriberId ( ) : "N/A" ; } else { mSimSubs = "N/A" ; } } catch ( Exception e ) { mSimSubs = "N/A" ; Log . e ( TAG , mTAG + ":getSimSubs " + e ) ; } if ( mSimSubs . isEmpty ( ) ) { mSimSubs = "N/A" ; } return mSimSubs ; } public String getSimSubs ( ) { return mSimSubs ; } String getSimSerial ( TelephonyManager tm ) { try { if ( tm . getSimState ( ) == TelephonyManager . SIM_STATE_READY ) { mSimSerial = ( tm . getSimSerialNumber ( ) != null ) ? tm . getSimSerialNumber ( ) : "N/A" ; } else { mSimSerial = "N/A" ; } } catch ( Exception e ) { mSimSerial = "N/A" ; Log . e ( TAG , mTAG + ":getSimSerial " + e ) ; } if ( mSimSerial . isEmpty ( ) ) { mSimSerial = "N/A" ; } return mSimSerial ; } public String getSimSerial ( ) { return mSimSerial ; } public String getPhoneType ( ) { return mPhoneType ; } public String getIMEI ( ) { return mIMEI ; } public String getIMEIv ( ) { return mIMEIV ; } public void setNetworkName ( String networkName ) { mNetName = networkName ; } public String getNetworkName ( ) { return mNetName ; } public String getMncMcc ( ) { return mMncmcc ; } public String getNetworkTypeName ( ) { if ( mCell == null ) return "Unknown" ; switch ( mCell . getNetType ( ) ) { case TelephonyManager . NETWORK_TYPE_1xRTT : mNetType = "1xRTT" ; break ; case TelephonyManager . NETWORK_TYPE_CDMA : mNetType = "CDMA" ; break ; case TelephonyManager . NETWORK_TYPE_EDGE : mNetType = "EDGE" ; break ; case TelephonyManager . NETWORK_TYPE_EHRPD : mNetType = "eHRPD" ; break ; case TelephonyManager . NETWORK_TYPE_EVDO_0 : mNetType = "EVDO rev. 0" ; break ; case TelephonyManager . NETWORK_TYPE_EVDO_A : mNetType = "EVDO rev. A" ; break ; case TelephonyManager . NETWORK_TYPE_EVDO_B : mNetType = "EVDO rev. B" ; break ; case TelephonyManager . NETWORK_TYPE_GPRS : mNetType = "GPRS" ; break ; case TelephonyManager . NETWORK_TYPE_HSDPA : mNetType = "HSDPA" ; break ; case TelephonyManager . NETWORK_TYPE_HSPA : mNetType = "HSPA" ; break ; case TelephonyManager . NETWORK_TYPE_HSPAP : mNetType = "HSPA+" ; break ; case TelephonyManager . NETWORK_TYPE_HSUPA : mNetType = "HSUPA" ; break ; case TelephonyManager . NETWORK_TYPE_IDEN : mNetType = "iDen" ; break ; case TelephonyManager . NETWORK_TYPE_LTE : mNetType = "LTE" ; break ; case TelephonyManager . NETWORK_TYPE_UMTS : mNetType = "UMTS" ; break ; case TelephonyManager . NETWORK_TYPE_UNKNOWN : mNetType = "Unknown" ; break ; } return mNetType ; } public static String getNetworkTypeName ( int netType ) { String networkType = "Unknown" ; switch ( netType ) { case TelephonyManager . NETWORK_TYPE_1xRTT : networkType = "1xRTT" ; break ; case TelephonyManager . NETWORK_TYPE_CDMA : networkType = "CDMA" ; break ; case TelephonyManager . NETWORK_TYPE_EDGE : networkType = "EDGE" ; break ; case TelephonyManager . NETWORK_TYPE_EHRPD : networkType = "eHRPD" ; break ; case TelephonyManager . NETWORK_TYPE_EVDO_0 : networkType = "EVDO_0" ; break ; case TelephonyManager . NETWORK_TYPE_EVDO_A : networkType = "EVDO_A" ; break ; case TelephonyManager . NETWORK_TYPE_EVDO_B : networkType = "EVDO_B" ; break ; case TelephonyManager . NETWORK_TYPE_GPRS : networkType = "GPRS" ; break ; case TelephonyManager . NETWORK_TYPE_HSDPA : networkType = "HSDPA" ; break ; case TelephonyManager . NETWORK_TYPE_HSPA : networkType = "HSPA" ; break ; case TelephonyManager . NETWORK_TYPE_HSPAP : networkType = "HSPA+" ; break ; case TelephonyManager . NETWORK_TYPE_HSUPA : networkType = "HSUPA" ; break ; case TelephonyManager . NETWORK_TYPE_IDEN : networkType = "iDEN" ; break ; case TelephonyManager . NETWORK_TYPE_LTE : networkType = "LTE" ; break ; case TelephonyManager . NETWORK_TYPE_UMTS : networkType = "UMTS" ; break ; case TelephonyManager . NETWORK_TYPE_UNKNOWN : networkType = "Unknown" ; break ; } return networkType ; } String getDataActivity ( TelephonyManager tm ) { int direction = tm . getDataActivity ( ) ; mDataActivityTypeShort = "un" ; mDataActivityType = "undef" ; switch ( direction ) { case TelephonyManager . DATA_ACTIVITY_NONE : mDataActivityTypeShort = "No" ; mDataActivityType = "None" ; break ; case TelephonyManager . DATA_ACTIVITY_IN : mDataActivityTypeShort = "In" ; mDataActivityType = "In" ; break ; case TelephonyManager . DATA_ACTIVITY_OUT : mDataActivityTypeShort = "Ou" ; mDataActivityType = "Out" ; break ; case TelephonyManager . DATA_ACTIVITY_INOUT : mDataActivityTypeShort = "IO" ; mDataActivityType = "In-Out" ; break ; case TelephonyManager . DATA_ACTIVITY_DORMANT : mDataActivityTypeShort = "Do" ; mDataActivityType = "Dormant" ; break ; } return mDataActivityType ; } public String getDataActivity ( ) { return mDataActivityType ; } String getDataState ( TelephonyManager tm ) { int state = tm . getDataState ( ) ; mDataState = "undef" ; mDataStateShort = "un" ; switch ( state ) { case TelephonyManager . DATA_DISCONNECTED : mDataState = "Disconnected" ; mDataStateShort = "Di" ; break ; case TelephonyManager . DATA_CONNECTING : mDataState = "Connecting" ; mDataStateShort = "Ct" ; break ; case TelephonyManager . DATA_CONNECTED : mDataState = "Connected" ; mDataStateShort = "Cd" ; break ; case TelephonyManager . DATA_SUSPENDED : mDataState = "Suspended" ; mDataStateShort = "Su" ; break ; } return mDataState ; } public String getDataState ( ) { return mDataState ; } public String getDataActivityTypeShort ( ) { return mDataActivityTypeShort ; } public void setDataActivityTypeShort ( String dataActivityTypeShort ) { mDataActivityTypeShort = dataActivityTypeShort ; } public String getDataStateShort ( ) { return mDataStateShort ; } public void setDataStateShort ( String dataStateShort ) { mDataStateShort = dataStateShort ; } public void setDataActivityType ( String dataActivityType ) { mDataActivityType = dataActivityType ; } public void setDataState ( String dataState ) { mDataState = dataState ; } public void setSignalDbm ( int signalDbm ) { mCell . setDBM ( signalDbm ) ; } public int getSignalDBm ( ) { return mCell . getDBM ( ) ; } public void setNetID ( TelephonyManager tm ) { mCell . setNetType ( tm . getNetworkType ( ) ) ; } public String isRoaming ( ) { return String . valueOf ( mRoaming ) ; } public void setLastLocation ( Location location ) { mLastLocation = location ; } public Location getLastLocation ( ) { return mLastLocation ; } public boolean isBetterLocation ( Location location , Location currentBestLocation ) { if ( currentBestLocation == null ) { return true ; } long timeDelta = location . getTime ( ) - currentBestLocation . getTime ( ) ; boolean isSignificantlyNewer = timeDelta > TWO_MINUTES ; boolean isSignificantlyOlder = timeDelta < - TWO_MINUTES ; boolean isNewer = timeDelta > 0 ; if ( isSignificantlyNewer ) { return true ; } else if ( isSignificantlyOlder ) { return false ; } int accuracyDelta = ( int ) ( location . getAccuracy ( ) - currentBestLocation . getAccuracy ( ) ) ; boolean isLessAccurate = accuracyDelta > 0 ; boolean isMoreAccurate = accuracyDelta < 0 ; boolean isSignificantlyLessAccurate = accuracyDelta > 200 ; boolean isFromSameProvider = isSameProvider ( location . getProvider ( ) , currentBestLocation . getProvider ( ) ) ; if ( isMoreAccurate ) { return true ; } else if ( isNewer && ! isLessAccurate ) { return true ; } else if ( isNewer && ! isSignificantlyLessAccurate && isFromSameProvider ) { return true ; } return false ; } private boolean isSameProvider ( String provider1 , String provider2 ) { if ( provider1 == null ) { return provider2 == null ; } return provider1 . equals ( provider2 ) ; } }
package com . SecUpwN . AIMSICD . utils ; import com . SecUpwN . AIMSICD . R ; public class Icon { public enum Type { FLAT , SENSE , WHITE , } public static int getIcon ( Type t ) { switch ( t ) { case FLAT : switch ( Status . getStatus ( ) ) { case IDLE : return R . drawable . flat_idle ; case NORMAL : return R . drawable . flat_ok ; case MEDIUM : return R . drawable . flat_medium ; case ALARM : return R . drawable . flat_danger ; default : return R . drawable . flat_idle ; } case SENSE : switch ( Status . getStatus ( ) ) { case IDLE : return R . drawable . sense_idle ; case NORMAL : return R . drawable . sense_ok ; case MEDIUM : return R . drawable . sense_medium ; case ALARM : return R . drawable . sense_danger ; default : return R . drawable . sense_idle ; } case WHITE : switch ( Status . getStatus ( ) ) { case IDLE : return R . drawable . white_idle ; case NORMAL : return R . drawable . white_ok ; case MEDIUM : return R . drawable . white_medium ; case ALARM : return R . drawable . white_danger ; default : return R . drawable . white_idle ; } } return - 1 ; } }
package com . SecUpwN . AIMSICD . utils ; import android . util . Log ; public final class CMDProcessor { private static final String TAG = "CMDProcessor" ; public CMDProcessor ( ) { } public static ChildProcess startSysCmd ( String [ ] cmdarray , String childStdin ) { return new ChildProcess ( cmdarray , childStdin ) ; } public static CommandResult runSysCmd ( String [ ] cmdarray , String childStdin ) { ChildProcess proc = startSysCmd ( cmdarray , childStdin ) ; proc . waitFinished ( ) ; return proc . getResult ( ) ; } public static ChildProcess startShellCommand ( String cmd ) { String [ ] cmdarray = new String [ 3 ] ; cmdarray [ 0 ] = "sh" ; cmdarray [ 1 ] = "-c" ; cmdarray [ 2 ] = cmd ; return startSysCmd ( cmdarray , null ) ; } public static CommandResult runShellCommand ( String cmd ) { ChildProcess proc = startShellCommand ( cmd ) ; proc . waitFinished ( ) ; return proc . getResult ( ) ; } public static ChildProcess startSuCommand ( String cmd ) { String [ ] cmdarray = new String [ 3 ] ; cmdarray [ 0 ] = "su" ; cmdarray [ 1 ] = "-c" ; cmdarray [ 2 ] = cmd ; return startSysCmd ( cmdarray , null ) ; } public static CommandResult runSuCommand ( String cmd ) { ChildProcess proc = startSuCommand ( cmd ) ; proc . waitFinished ( ) ; return proc . getResult ( ) ; } public static boolean canSU ( ) { CommandResult r = runShellCommand ( "id" ) ; StringBuilder out = new StringBuilder ( 0 ) ; out . append ( r . getStdout ( ) ) ; out . append ( " ; " ) ; out . append ( r . getStderr ( ) ) ; Log . d ( TAG , "canSU() su[" + r . getExitValue ( ) + "]: " + out ) ; return r . success ( ) ; } }
package com . SecUpwN . AIMSICD . utils ; import android . util . Log ; import java . io . ByteArrayOutputStream ; import java . io . DataOutputStream ; import java . io . IOException ; public class OemCommands { private static final String TAG = "AIMSICD_OemCommands" ; public static final char OEM_SERVM_FUNCTAG = 1 ; public static final char OEM_SM_ACTION = 0 ; public static final char OEM_SM_QUERY = 1 ; public static final char OEM_SM_DUMMY = 0 ; public static final char OEM_SM_ENTER_MODE_MESSAGE = 1 ; public static final char OEM_SM_END_MODE_MESSAGE = 2 ; public static final char OEM_SM_PROCESS_KEY_MESSAGE = 3 ; public static final char OEM_SM_GET_DISPLAY_DATA_MESSAGE = 4 ; public static final char OEM_SM_TYPE_TEST_MANUAL = 1 ; public static final char OEM_SM_TYPE_TEST_AUTO = 2 ; public static final char OEM_SM_TYPE_NAM_EDIT = 3 ; public static final char OEM_SM_TYPE_MONITOR = 4 ; public static final char OEM_SM_TYPE_PHONE_TEST = 5 ; public static final char OEM_SM_TYPE_SUB_ENTER = 0 ; public static final char OEM_SM_TYPE_SUB_SW_VERSION_ENTER = 1 ; public static final char OEM_SM_TYPE_SUB_FTA_SW_VERSION_ENTER = 2 ; public static final char OEM_SM_TYPE_SUB_FTA_HW_VERSION_ENTER = 3 ; public static final char OEM_SM_TYPE_SUB_ALL_VERSION_ENTER = 4 ; public static final char OEM_SM_TYPE_SUB_BATTERY_INFO_ENTER = 5 ; public static final char OEM_SM_TYPE_SUB_CIPHERING_PROTECTION_ENTER = 6 ; public static final char OEM_SM_TYPE_SUB_INTEGRITY_PROTECTION_ENTER = 7 ; public static final char OEM_SM_TYPE_SUB_IMEI_READ_ENTER = 8 ; public static final char OEM_SM_TYPE_SUB_BLUETOOTH_TEST_ENTER = 9 ; public static final char OEM_SM_TYPE_SUB_VIBRATOR_TEST_ENTER = 10 ; public static final char OEM_SM_TYPE_SUB_MELODY_TEST_ENTER = 11 ; public static final char OEM_SM_TYPE_SUB_MP3_TEST_ENTER = 12 ; public static final char OEM_SM_TYPE_SUB_FACTORY_RESET_ENTER = 13 ; public static final char OEM_SM_TYPE_SUB_FACTORY_PRECONFIG_ENTER = 14 ; public static final char OEM_SM_TYPE_SUB_TFS4_EXPLORE_ENTER = 15 ; public static final char OEM_SM_TYPE_SUB_RSC_FILE_VERSION_ENTER = 17 ; public static final char OEM_SM_TYPE_SUB_USB_DRIVER_ENTER = 18 ; public static final char OEM_SM_TYPE_SUB_USB_UART_DIAG_CONTROL_ENTER = 19 ; public static final char OEM_SM_TYPE_SUB_RRC_VERSION_ENTER = 20 ; public static final char OEM_SM_TYPE_SUB_GPSONE_SS_TEST_ENTER = 21 ; public static final char OEM_SM_TYPE_SUB_BAND_SEL_ENTER = 22 ; public static final char OEM_SM_TYPE_SUB_GCF_TESTMODE_ENTER = 23 ; public static final char OEM_SM_TYPE_SUB_GSM_FACTORY_AUDIO_LB_ENTER = 24 ; public static final char OEM_SM_TYPE_SUB_FACTORY_VF_TEST_ENTER = 25 ; public static final char OEM_SM_TYPE_SUB_TOTAL_CALL_TIME_INFO_ENTER = 26 ; public static final char OEM_SM_TYPE_SUB_SELLOUT_SMS_ENABLE_ENTER = 27 ; public static final char OEM_SM_TYPE_SUB_SELLOUT_SMS_DISABLE_ENTER = 28 ; public static final char OEM_SM_TYPE_SUB_SELLOUT_SMS_TEST_MODE_ON = 29 ; public static final char OEM_SM_TYPE_SUB_SELLOUT_SMS_PRODUCT_MODE_ON = 30 ; public static final char OEM_SM_TYPE_SUB_GET_SELLOUT_SMS_INFO_ENTER = 31 ; public static final char OEM_SM_TYPE_SUB_TST_AUTO_ANSWER_ENTER = 32 ; public static final char OEM_SM_TYPE_SUB_TST_NV_RESET_ENTER = 33 ; public static final char OEM_SM_TYPE_SUB_TST_FTA_SW_VERSION_ENTER = 4098 ; public static final char OEM_SM_TYPE_SUB_TST_FTA_HW_VERSION_ENTER = 4099 ; public static byte [ ] getEnterServiceModeData ( int modeType , int subType , int query ) { try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutputStream dos = new DataOutputStream ( baos ) ; dos . writeByte ( OEM_SERVM_FUNCTAG ) ; dos . writeByte ( OEM_SM_ENTER_MODE_MESSAGE ) ; dos . writeShort ( 7 ) ; dos . writeByte ( modeType ) ; dos . writeByte ( subType ) ; dos . writeByte ( query ) ; return baos . toByteArray ( ) ; } catch ( IOException e ) { Log . e ( TAG , "" , e ) ; } return null ; } public static byte [ ] getEndServiceModeData ( int modeType ) { try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutputStream dos = new DataOutputStream ( baos ) ; dos . writeByte ( OEM_SERVM_FUNCTAG ) ; dos . writeByte ( OEM_SM_END_MODE_MESSAGE ) ; dos . writeShort ( 5 ) ; dos . writeByte ( modeType ) ; return baos . toByteArray ( ) ; } catch ( IOException e ) { Log . e ( TAG , "" , e ) ; } return null ; } public static byte [ ] getPressKeyData ( int keycode , int query ) { try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutputStream dos = new DataOutputStream ( baos ) ; dos . writeByte ( OEM_SERVM_FUNCTAG ) ; dos . writeByte ( OEM_SM_PROCESS_KEY_MESSAGE ) ; dos . writeShort ( 6 ) ; dos . writeByte ( keycode ) ; dos . writeByte ( query ) ; return baos . toByteArray ( ) ; } catch ( IOException e ) { Log . e ( TAG , "" , e ) ; } return null ; } }
package com . SecUpwN . AIMSICD . utils ; import org . xmlpull . v1 . XmlPullParser ; import org . xmlpull . v1 . XmlPullParserException ; import android . util . Xml ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class StackOverflowXmlParser { private static final String ns = null ; public List < Cell > parse ( InputStream in ) throws XmlPullParserException , IOException { try { XmlPullParser parser = Xml . newPullParser ( ) ; parser . setFeature ( XmlPullParser . FEATURE_PROCESS_NAMESPACES , false ) ; parser . setInput ( in , null ) ; parser . nextTag ( ) ; return readCells ( parser ) ; } finally { in . close ( ) ; } } private List < Cell > readCells ( XmlPullParser parser ) throws XmlPullParserException , IOException { List < Cell > cells = new ArrayList < > ( ) ; parser . require ( XmlPullParser . START_TAG , ns , "rsp" ) ; while ( parser . next ( ) != XmlPullParser . END_TAG ) { if ( parser . getEventType ( ) != XmlPullParser . START_TAG ) { continue ; } String name = parser . getName ( ) ; if ( name . equals ( "cell" ) ) { cells . add ( readCell ( parser ) ) ; } else { skip ( parser ) ; } } return cells ; } private Cell readCell ( XmlPullParser parser ) throws XmlPullParserException , IOException { Cell cell = new Cell ( ) ; parser . require ( XmlPullParser . START_TAG , ns , "cell" ) ; while ( parser . next ( ) != XmlPullParser . END_TAG ) { if ( parser . getEventType ( ) != XmlPullParser . START_TAG ) { continue ; } String name = parser . getName ( ) ; switch ( name ) { case "lat" : cell . setLat ( readDouble ( parser ) ) ; break ; case "lon" : cell . setLon ( readDouble ( parser ) ) ; break ; case "mcc" : cell . setMCC ( readInt ( parser ) ) ; break ; case "mnc" : cell . setMNC ( readInt ( parser ) ) ; break ; case "cellid" : cell . setCID ( readInt ( parser ) ) ; break ; case "lac" : cell . setLAC ( readInt ( parser ) ) ; break ; default : skip ( parser ) ; break ; } } return cell ; } private String readText ( XmlPullParser parser ) throws IOException , XmlPullParserException { String result = "" ; if ( parser . next ( ) == XmlPullParser . TEXT ) { result = parser . getText ( ) ; parser . nextTag ( ) ; } return result ; } private double readDouble ( XmlPullParser parser ) throws IOException , XmlPullParserException { String result = "" ; if ( parser . next ( ) == XmlPullParser . TEXT ) { result = parser . getText ( ) ; parser . nextTag ( ) ; } return Double . valueOf ( result ) ; } private int readInt ( XmlPullParser parser ) throws IOException , XmlPullParserException { String result = "" ; if ( parser . next ( ) == XmlPullParser . TEXT ) { result = parser . getText ( ) ; parser . nextTag ( ) ; } return Integer . valueOf ( result ) ; } private void skip ( XmlPullParser parser ) throws XmlPullParserException , IOException { if ( parser . getEventType ( ) != XmlPullParser . START_TAG ) { throw new IllegalStateException ( ) ; } int depth = 1 ; while ( depth != 0 ) { switch ( parser . next ( ) ) { case XmlPullParser . END_TAG : depth -- ; break ; case XmlPullParser . START_TAG : depth ++ ; break ; } } } }
package com . SecUpwN . AIMSICD . utils ; import android . content . Context ; import android . content . Intent ; import android . support . v4 . content . LocalBroadcastManager ; public class Status { public static Type currentStatus ; public enum Type { ALARM , MEDIUM , NORMAL , IDLE , } public static void setCurrentStatus ( Type t , Context context ) { if ( t != currentStatus ) { Intent intent = new Intent ( "StatusChange" ) ; LocalBroadcastManager . getInstance ( context ) . sendBroadcast ( intent ) ; } currentStatus = t ; } public static Type getStatus ( ) { if ( currentStatus == null ) { return Type . IDLE ; } return currentStatus ; } }
package com . SecUpwN . AIMSICD . utils ; import android . os . AsyncTask ; import android . os . Parcel ; import android . os . Parcelable ; import android . os . SystemClock ; import android . util . Log ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . URL ; import java . util . List ; public class Cell implements Parcelable { private int cid ; private int lac ; private int mcc ; private int mnc ; private int dbm ; private int psc ; private int rssi ; private int timingAdvance ; private int sid ; private long timestamp ; private int netType ; private double speed ; private double accuracy ; private double bearing ; private double lon ; private double lat ; { cid = Integer . MAX_VALUE ; lac = Integer . MAX_VALUE ; mcc = Integer . MAX_VALUE ; mnc = Integer . MAX_VALUE ; dbm = Integer . MAX_VALUE ; psc = Integer . MAX_VALUE ; rssi = Integer . MAX_VALUE ; timingAdvance = Integer . MAX_VALUE ; sid = Integer . MAX_VALUE ; netType = Integer . MAX_VALUE ; lon = 0.0 ; lat = 0.0 ; speed = 0.0 ; accuracy = 0.0 ; bearing = 0.0 ; } public Cell ( ) { } public Cell ( int cid , int lac , int mcc , int mnc , int dbm , long timestamp ) { super ( ) ; this . cid = cid ; this . lac = lac ; this . mcc = mcc ; this . mnc = mnc ; this . dbm = dbm ; rssi = Integer . MAX_VALUE ; this . psc = Integer . MAX_VALUE ; this . timestamp = timestamp ; timingAdvance = Integer . MAX_VALUE ; sid = Integer . MAX_VALUE ; netType = Integer . MAX_VALUE ; lon = 0.0 ; lat = 0.0 ; speed = 0.0 ; accuracy = 0.0 ; bearing = 0.0 ; } public Cell ( int cid , int lac , int signal , int psc , int netType , boolean dbm ) { this . cid = cid ; this . lac = lac ; mcc = Integer . MAX_VALUE ; mnc = Integer . MAX_VALUE ; if ( dbm ) { this . dbm = signal ; } else { this . rssi = signal ; } this . psc = psc ; this . netType = netType ; timingAdvance = Integer . MAX_VALUE ; sid = Integer . MAX_VALUE ; lon = 0.0 ; lat = 0.0 ; speed = 0.0 ; accuracy = 0.0 ; bearing = 0.0 ; this . timestamp = SystemClock . currentThreadTimeMillis ( ) ; } public Cell ( int cid , int lac , int mcc , int mnc , int dbm , double accuracy , double speed , double bearing , int netType , long timestamp ) { this . cid = cid ; this . lac = lac ; this . mcc = mcc ; this . mnc = mnc ; this . dbm = dbm ; rssi = Integer . MAX_VALUE ; timingAdvance = Integer . MAX_VALUE ; sid = Integer . MAX_VALUE ; this . accuracy = accuracy ; this . speed = speed ; this . bearing = bearing ; this . netType = netType ; this . timestamp = timestamp ; } public int getCID ( ) { return this . cid ; } public void setCID ( int cid ) { this . cid = cid ; } public int getLAC ( ) { return this . lac ; } public void setLAC ( int lac ) { this . lac = lac ; } public int getMCC ( ) { return this . mcc ; } public void setMCC ( int mcc ) { this . mcc = mcc ; } public int getMNC ( ) { return this . mnc ; } public void setMNC ( int mnc ) { this . mnc = mnc ; } public int getPSC ( ) { return this . psc ; } public void setPSC ( int psc ) { if ( psc == - 1 ) { this . psc = Integer . MAX_VALUE ; } else { this . psc = psc ; } } public int getSID ( ) { return this . sid ; } public void setSID ( int sid ) { this . sid = sid ; } public int getDBM ( ) { return dbm ; } public void setDBM ( int dbm ) { this . dbm = dbm ; } public double getLon ( ) { return this . lon ; } public void setLon ( double lon ) { this . lon = lon ; } public double getLat ( ) { return this . lat ; } public void setLat ( double lat ) { this . lat = lat ; } public double getSpeed ( ) { return this . speed ; } public void setSpeed ( double speed ) { this . speed = speed ; } public double getAccuracy ( ) { return this . accuracy ; } public void setAccuracy ( double accuracy ) { this . accuracy = accuracy ; } public double getBearing ( ) { return this . bearing ; } public void setBearing ( double bearing ) { this . bearing = bearing ; } public int getTimingAdvance ( ) { return this . timingAdvance ; } public void setTimingAdvance ( int ta ) { this . timingAdvance = ta ; } public int getNetType ( ) { return this . netType ; } public void setNetType ( int netType ) { this . netType = netType ; } public long getTimestamp ( ) { return this . timestamp ; } public void setTimestamp ( long timestamp ) { this . timestamp = timestamp ; } public int getRssi ( ) { return this . rssi ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + cid ; result = prime * result + lac ; result = prime * result + mcc ; result = prime * result + mnc ; if ( psc != - 1 ) result = prime * result + psc ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( ( ( Object ) this ) . getClass ( ) != obj . getClass ( ) ) { return false ; } Cell other = ( Cell ) obj ; if ( this . psc != Integer . MAX_VALUE ) { return this . cid == other . getCID ( ) && this . lac == other . getLAC ( ) && this . mcc == other . getMCC ( ) && this . mnc == other . getMNC ( ) && this . psc == other . getPSC ( ) ; } else { return this . cid == other . getCID ( ) && this . lac == other . getLAC ( ) && this . mcc == other . getMCC ( ) && this . mnc == other . getMNC ( ) ; } } public String toString ( ) { StringBuilder result = new StringBuilder ( ) ; result . append ( "CID - " ) . append ( cid ) . append ( "\n" ) ; result . append ( "LAC - " ) . append ( lac ) . append ( "\n" ) ; result . append ( "MCC - " ) . append ( mcc ) . append ( "\n" ) ; result . append ( "MNC - " ) . append ( mnc ) . append ( "\n" ) ; result . append ( "DBm - " ) . append ( dbm ) . append ( "\n" ) ; if ( psc != Integer . MAX_VALUE ) { result . append ( "PSC - " ) . append ( psc ) . append ( "\n" ) ; } result . append ( "Type - " ) . append ( netType ) . append ( "\n" ) ; result . append ( "Lon - " ) . append ( lon ) . append ( "\n" ) ; result . append ( "Lat - " ) . append ( lat ) . append ( "\n" ) ; return result . toString ( ) ; } public boolean isValid ( ) { return this . getCID ( ) != Integer . MAX_VALUE && this . getLAC ( ) != Integer . MAX_VALUE ; } public static class CellLookUpAsync extends AsyncTask < String , Void , List < Cell > > { public AsyncResponse delegate = null ; @ Override protected List < Cell > doInBackground ( String ... urls ) { try { InputStream stream ; StackOverflowXmlParser stackOverflowXmlParser = new StackOverflowXmlParser ( ) ; List < Cell > cells ; URL url = new URL ( urls [ 0 ] ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setReadTimeout ( 10000 ) ; conn . setConnectTimeout ( 15000 ) ; conn . setRequestMethod ( "GET" ) ; conn . setDoInput ( true ) ; conn . connect ( ) ; stream = conn . getInputStream ( ) ; cells = stackOverflowXmlParser . parse ( stream ) ; conn . disconnect ( ) ; stream . close ( ) ; return cells ; } catch ( Exception e ) { Log . i ( "AIMSICD" , "Cell Lookup - " + e . getMessage ( ) ) ; return null ; } } @ Override protected void onPostExecute ( List < Cell > cells ) { delegate . processFinish ( cells ) ; } } public Cell ( Parcel in ) { String [ ] data = new String [ 15 ] ; in . readStringArray ( data ) ; cid = Integer . valueOf ( data [ 0 ] ) ; lac = Integer . valueOf ( data [ 1 ] ) ; mcc = Integer . valueOf ( data [ 2 ] ) ; mnc = Integer . valueOf ( data [ 3 ] ) ; dbm = Integer . valueOf ( data [ 4 ] ) ; psc = Integer . valueOf ( data [ 5 ] ) ; rssi = Integer . valueOf ( data [ 6 ] ) ; timingAdvance = Integer . valueOf ( data [ 7 ] ) ; sid = Integer . valueOf ( data [ 8 ] ) ; netType = Integer . valueOf ( data [ 9 ] ) ; lon = Double . valueOf ( data [ 10 ] ) ; lat = Double . valueOf ( data [ 11 ] ) ; speed = Double . valueOf ( data [ 12 ] ) ; accuracy = Double . valueOf ( data [ 13 ] ) ; bearing = Double . valueOf ( data [ 14 ] ) ; } public int describeContents ( ) { return 0 ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeStringArray ( new String [ ] { String . valueOf ( this . cid ) , String . valueOf ( this . lac ) , String . valueOf ( this . mcc ) , String . valueOf ( this . mnc ) , String . valueOf ( this . dbm ) , String . valueOf ( this . psc ) , String . valueOf ( this . rssi ) , String . valueOf ( this . timingAdvance ) , String . valueOf ( this . sid ) , String . valueOf ( this . netType ) , String . valueOf ( this . lon ) , String . valueOf ( this . lat ) , String . valueOf ( this . speed ) , String . valueOf ( this . accuracy ) , String . valueOf ( this . bearing ) } ) ; } public static final Parcelable . Creator CREATOR = new Parcelable . Creator ( ) { public Cell createFromParcel ( Parcel in ) { return new Cell ( in ) ; } public Cell [ ] newArray ( int size ) { return new Cell [ size ] ; } } ; }
package com . stericson . RootShell . execution ; import com . stericson . RootShell . RootShell ; import android . content . Context ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import java . io . IOException ; public class Command { protected boolean javaCommand = false ; protected Context context = null ; public int totalOutput = 0 ; public int totalOutputProcessed = 0 ; ExecutionMonitor executionMonitor = null ; Handler mHandler = null ; boolean executing = false ; String [ ] command = { } ; boolean finished = false ; boolean terminated = false ; boolean handlerEnabled = true ; int exitCode = - 1 ; int id = 0 ; int timeout = RootShell . defaultCommandTimeout ; public Command ( int id , String ... command ) { this . command = command ; this . id = id ; createHandler ( RootShell . handlerEnabled ) ; } public Command ( int id , boolean handlerEnabled , String ... command ) { this . command = command ; this . id = id ; createHandler ( handlerEnabled ) ; } public Command ( int id , int timeout , String ... command ) { this . command = command ; this . id = id ; this . timeout = timeout ; createHandler ( RootShell . handlerEnabled ) ; } public void commandOutput ( int id , String line ) { RootShell . log ( "Command" , "ID: " + id + ", " + line ) ; totalOutputProcessed ++ ; } public void commandTerminated ( int id , String reason ) { } public void commandCompleted ( int id , int exitcode ) { } protected final void commandFinished ( ) { if ( ! terminated ) { synchronized ( this ) { if ( mHandler != null && handlerEnabled ) { Message msg = mHandler . obtainMessage ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putInt ( CommandHandler . ACTION , CommandHandler . COMMAND_COMPLETED ) ; msg . setData ( bundle ) ; mHandler . sendMessage ( msg ) ; } else { commandCompleted ( id , exitCode ) ; } RootShell . log ( "Command " + id + " finished." ) ; finishCommand ( ) ; } } } private void createHandler ( boolean handlerEnabled ) { this . handlerEnabled = handlerEnabled ; if ( Looper . myLooper ( ) != null && handlerEnabled ) { RootShell . log ( "CommandHandler created" ) ; mHandler = new CommandHandler ( ) ; } else { RootShell . log ( "CommandHandler not created" ) ; } } protected final void finishCommand ( ) { executing = false ; finished = true ; this . notifyAll ( ) ; } public final String getCommand ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < command . length ; i ++ ) { if ( i > 0 ) { sb . append ( '\n' ) ; } sb . append ( command [ i ] ) ; } return sb . toString ( ) ; } public final boolean isExecuting ( ) { return executing ; } public final boolean isHandlerEnabled ( ) { return handlerEnabled ; } public final boolean isFinished ( ) { return finished ; } public final int getExitCode ( ) { return this . exitCode ; } protected final void setExitCode ( int code ) { synchronized ( this ) { exitCode = code ; } } protected final void startExecution ( ) { executionMonitor = new ExecutionMonitor ( ) ; executionMonitor . setPriority ( Thread . MIN_PRIORITY ) ; executionMonitor . start ( ) ; executing = true ; } public final void terminate ( String reason ) { try { Shell . closeAll ( ) ; RootShell . log ( "Terminating all shells." ) ; terminated ( reason ) ; } catch ( IOException e ) { } } protected final void terminated ( String reason ) { synchronized ( Command . this ) { if ( mHandler != null && handlerEnabled ) { Message msg = mHandler . obtainMessage ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putInt ( CommandHandler . ACTION , CommandHandler . COMMAND_TERMINATED ) ; bundle . putString ( CommandHandler . TEXT , reason ) ; msg . setData ( bundle ) ; mHandler . sendMessage ( msg ) ; } else { commandTerminated ( id , reason ) ; } RootShell . log ( "Command " + id + " did not finish because it was terminated. Termination reason: " + reason ) ; setExitCode ( - 1 ) ; terminated = true ; finishCommand ( ) ; } } protected final void output ( int id , String line ) { totalOutput ++ ; if ( mHandler != null && handlerEnabled ) { Message msg = mHandler . obtainMessage ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putInt ( CommandHandler . ACTION , CommandHandler . COMMAND_OUTPUT ) ; bundle . putString ( CommandHandler . TEXT , line ) ; msg . setData ( bundle ) ; mHandler . sendMessage ( msg ) ; } else { commandOutput ( id , line ) ; } } public final void resetCommand ( ) { this . finished = false ; this . totalOutput = 0 ; this . totalOutputProcessed = 0 ; this . executing = false ; this . terminated = false ; this . exitCode = - 1 ; } private class ExecutionMonitor extends Thread { public void run ( ) { while ( ! finished ) { synchronized ( Command . this ) { try { Command . this . wait ( timeout ) ; } catch ( InterruptedException e ) { } } if ( ! finished ) { RootShell . log ( "Timeout Exception has occurred." ) ; terminate ( "Timeout Exception" ) ; } } } } private class CommandHandler extends Handler { static final public String ACTION = "action" ; static final public String TEXT = "text" ; static final public int COMMAND_OUTPUT = 0x01 ; static final public int COMMAND_COMPLETED = 0x02 ; static final public int COMMAND_TERMINATED = 0x03 ; public final void handleMessage ( Message msg ) { int action = msg . getData ( ) . getInt ( ACTION ) ; String text = msg . getData ( ) . getString ( TEXT ) ; switch ( action ) { case COMMAND_OUTPUT : commandOutput ( id , text ) ; break ; case COMMAND_COMPLETED : commandCompleted ( id , exitCode ) ; break ; case COMMAND_TERMINATED : commandTerminated ( id , text ) ; break ; } } } }
package com . SecUpwN . AIMSICD . utils ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . net . ConnectivityManager ; import android . net . NetworkInfo ; import android . os . CountDownTimer ; import android . os . Environment ; import android . os . Handler ; import android . text . TextUtils ; import android . util . Log ; import android . view . Gravity ; import android . widget . Toast ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . activities . MapViewerOsmDroid ; import com . SecUpwN . AIMSICD . service . CellTracker ; import java . io . BufferedReader ; import java . io . File ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . UnsupportedEncodingException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Date ; import java . util . List ; public class Helpers { private static final String TAG = "AIMSICD" ; private static final String mTAG = "Helpers" ; private static final int CHARS_PER_LINE = 34 ; private static final int SHORT_TOAST_DURATION = 2000 ; private static final long TOAST_DURATION_MILLS = 6000 ; public static void msgLong ( final Context context , final String msg ) { if ( context != null && msg != null ) { final Toast t = Toast . makeText ( context , msg , Toast . LENGTH_SHORT ) ; t . setGravity ( Gravity . TOP | Gravity . CENTER_HORIZONTAL , 0 , 0 ) ; new CountDownTimer ( Math . max ( TOAST_DURATION_MILLS - SHORT_TOAST_DURATION , 1000 ) , 1000 ) { @ Override public void onFinish ( ) { t . show ( ) ; } @ Override public void onTick ( long millisUntilFinished ) { t . show ( ) ; } } . start ( ) ; } } public static void msgShort ( final Context context , final String msg ) { if ( context != null && msg != null ) { new Handler ( context . getMainLooper ( ) ) . post ( new Runnable ( ) { @ Override public void run ( ) { Toast . makeText ( context , msg . trim ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; } } public static void sendMsg ( Context context , String msg ) { if ( context != null && msg != null ) { msgLong ( context , msg ) ; } } @ SuppressWarnings ( "UnnecessaryFullyQualifiedName" ) public static String getTimestamp ( Context context ) { String timestamp ; Date now = new Date ( ) ; java . text . DateFormat dateFormat = android . text . format . DateFormat . getDateFormat ( context ) ; java . text . DateFormat timeFormat = android . text . format . DateFormat . getTimeFormat ( context ) ; timestamp = dateFormat . format ( now ) + ' ' + timeFormat . format ( now ) ; return timestamp ; } public static Boolean isNetAvailable ( Context context ) { try { ConnectivityManager cM = ( ConnectivityManager ) context . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; NetworkInfo wifiInfo = cM . getNetworkInfo ( ConnectivityManager . TYPE_WIFI ) ; NetworkInfo mobileInfo = cM . getNetworkInfo ( ConnectivityManager . TYPE_MOBILE ) ; if ( wifiInfo != null && mobileInfo != null ) { return wifiInfo . isConnected ( ) || mobileInfo . isConnected ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return false ; } public static void getOpenCellData ( Context context , Cell cell , char type ) { if ( Helpers . isNetAvailable ( context ) ) { if ( ! CellTracker . OCID_API_KEY . equals ( "NA" ) ) { double earthRadius = 6371.01 ; int radius = 2 ; if ( cell . getLat ( ) != 0.0 && cell . getLon ( ) != 0.0 ) { GeoLocation currentLoc = GeoLocation . fromDegrees ( cell . getLat ( ) , cell . getLon ( ) ) ; GeoLocation [ ] boundingCoords = currentLoc . boundingCoordinates ( radius , earthRadius ) ; String boundParameter ; boundParameter = String . valueOf ( boundingCoords [ 0 ] . getLatitudeInDegrees ( ) ) + "," + String . valueOf ( boundingCoords [ 0 ] . getLongitudeInDegrees ( ) ) + "," + String . valueOf ( boundingCoords [ 1 ] . getLatitudeInDegrees ( ) ) + "," + String . valueOf ( boundingCoords [ 1 ] . getLongitudeInDegrees ( ) ) ; Log . i ( TAG , mTAG + ":OCID BBOX is set to: " + boundParameter + " with radius " + radius + " Km." ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( "http://www.opencellid.org/cell/getInArea?key=" ) . append ( CellTracker . OCID_API_KEY ) . append ( "&BBOX=" ) . append ( boundParameter ) ; if ( cell . getMCC ( ) != Integer . MAX_VALUE ) { sb . append ( "&mcc=" ) . append ( cell . getMCC ( ) ) ; } if ( cell . getMNC ( ) != Integer . MAX_VALUE ) { sb . append ( "&mnc=" ) . append ( cell . getMNC ( ) ) ; } sb . append ( "&format=csv" ) ; new RequestTask ( context , type ) . execute ( sb . toString ( ) ) ; } } else { if ( context instanceof MapViewerOsmDroid ) { ( ( MapViewerOsmDroid ) context ) . setRefreshActionButtonState ( false ) ; } Helpers . sendMsg ( context , context . getString ( R . string . no_opencellid_key_detected ) ) ; } } else { if ( context instanceof MapViewerOsmDroid ) { ( ( MapViewerOsmDroid ) context ) . setRefreshActionButtonState ( false ) ; } final AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setTitle ( R . string . no_network_connection_title ) . setMessage ( R . string . no_network_connection_message ) ; builder . create ( ) . show ( ) ; } } public static String ByteToString ( byte [ ] byteArray ) { if ( byteArray == null ) { return null ; } try { String result = new String ( byteArray , "ASCII" ) ; result = String . copyValueOf ( result . toCharArray ( ) , 0 , byteArray . length ) ; return result ; } catch ( UnsupportedEncodingException e ) { return null ; } } public static List < String > ByteArrayToStringList ( byte [ ] byteArray , int dataLength ) { if ( byteArray == null ) { return null ; } if ( dataLength <= 0 ) { return null ; } if ( dataLength > byteArray . length ) { return null ; } for ( int i = 0 ; i < dataLength ; i ++ ) { if ( ( byteArray [ i ] == 0x0D ) || ( byteArray [ i ] == 0x0A ) ) { byteArray [ i ] = 0 ; continue ; } if ( byteArray [ i ] < 0x20 ) { byteArray [ i ] = 0x2E ; } if ( byteArray [ i ] > 0x7E ) { byteArray [ i ] = 0x2E ; } } List < String > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < dataLength ; i ++ ) { if ( byteArray [ i ] == 0 ) { continue ; } int blockLength = - 1 ; for ( int j = i + 1 ; j < dataLength ; j ++ ) { if ( byteArray [ j ] == 0 ) { blockLength = j - i ; break ; } } if ( blockLength == - 1 ) { blockLength = dataLength - i ; } byte [ ] mBlockData = new byte [ blockLength ] ; System . arraycopy ( byteArray , i , mBlockData , 0 , blockLength ) ; result . add ( ByteToString ( mBlockData ) ) ; i += blockLength ; } if ( result . size ( ) <= 0 ) { return null ; } return result ; } public static List < String > unpackListOfStrings ( byte aob [ ] ) { if ( aob . length == 0 ) { return Collections . emptyList ( ) ; } int lines = aob . length / CHARS_PER_LINE ; String [ ] display = new String [ lines ] ; for ( int i = 0 ; i < lines ; i ++ ) { int offset , byteCount ; offset = i * CHARS_PER_LINE + 2 ; byteCount = 0 ; if ( offset + byteCount >= aob . length ) { Log . e ( TAG , "Unexpected EOF" ) ; break ; } while ( aob [ offset + byteCount ] != 0 && ( byteCount < CHARS_PER_LINE ) ) { byteCount += 1 ; if ( offset + byteCount >= aob . length ) { Log . e ( TAG , "Unexpected EOF" ) ; break ; } } display [ i ] = new String ( aob , offset , byteCount ) . trim ( ) ; } int newLength = display . length ; while ( newLength > 0 && TextUtils . isEmpty ( display [ newLength - 1 ] ) ) { newLength -= 1 ; } return Arrays . asList ( Arrays . copyOf ( display , newLength ) ) ; } public static List < String > unpackByteListOfStrings ( byte aob [ ] ) { if ( aob . length == 0 ) { return Collections . emptyList ( ) ; } int lines = aob . length / CHARS_PER_LINE ; String [ ] display = new String [ lines ] ; for ( int i = 0 ; i < lines ; i ++ ) { int offset , byteCount ; offset = i * CHARS_PER_LINE + 2 ; byteCount = 0 ; if ( offset + byteCount >= aob . length ) { Log . e ( TAG , "Unexpected EOF" ) ; break ; } while ( aob [ offset + byteCount ] != 0 && ( byteCount < CHARS_PER_LINE ) ) { byteCount += 1 ; if ( offset + byteCount >= aob . length ) { Log . e ( TAG , "Unexpected EOF" ) ; break ; } } display [ i ] = new String ( aob , offset , byteCount ) . trim ( ) ; } int newLength = display . length ; while ( newLength > 0 && TextUtils . isEmpty ( display [ newLength - 1 ] ) ) { newLength -= 1 ; } return Arrays . asList ( Arrays . copyOf ( display , newLength ) ) ; } public static String getSystemProp ( Context context , String prop , String def ) { String result = null ; try { result = SystemPropertiesReflection . get ( context , prop ) ; } catch ( IllegalArgumentException iae ) { Log . e ( TAG , mTAG + ": Failed to get system property: " + prop ) ; } return result == null ? def : result ; } public static String setProp ( String prop , String value ) { return CMDProcessor . runSuCommand ( "setprop " + prop + " " + value ) . getStdout ( ) ; } @ SuppressWarnings ( "MethodWithMultipleReturnPoints" ) public static boolean checkSu ( ) { if ( ! new File ( "/system/bin/su" ) . exists ( ) && ! new File ( "/system/xbin/su" ) . exists ( ) ) { Log . e ( TAG , mTAG + ": su binary does not exist!!!" ) ; return false ; } try { if ( CMDProcessor . runSuCommand ( "ls /data/app-private" ) . success ( ) ) { Log . i ( TAG , mTAG + ": SU exists and we have permission" ) ; return true ; } else { Log . i ( TAG , mTAG + ": SU exists but we don't have permission" ) ; return false ; } } catch ( NullPointerException e ) { Log . e ( TAG , mTAG + ": NPE while looking for su binary: " , e ) ; return false ; } } public static boolean checkBusybox ( ) { if ( ! new File ( "/system/bin/busybox" ) . exists ( ) && ! new File ( "/system/xbin/busybox" ) . exists ( ) ) { Log . e ( TAG , mTAG + ": Busybox not in xbin or bin!" ) ; return false ; } try { if ( ! CMDProcessor . runSuCommand ( "busybox mount" ) . success ( ) ) { Log . e ( TAG , mTAG + ": Busybox is there but is broken!" ) ; return false ; } } catch ( NullPointerException e ) { Log . e ( TAG , mTAG + ": NPE while testing Busybox: " , e ) ; return false ; } return true ; } public static String convertStreamToString ( InputStream is ) throws Exception { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; StringBuilder sb = new StringBuilder ( ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { sb . append ( line ) . append ( "\n" ) ; } reader . close ( ) ; return sb . toString ( ) ; } public static void askAndDeleteDb ( final Context pContext ) { AlertDialog lAlertDialog = new AlertDialog . Builder ( pContext ) . setNegativeButton ( R . string . open_cell_id_button_cancel , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { } } ) . setPositiveButton ( R . string . open_cell_id_button_ok , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { pContext . deleteDatabase ( "aimsicd.db" ) ; } } ) . setMessage ( pContext . getString ( R . string . clear_database_question ) ) . setTitle ( R . string . clear_database ) . setCancelable ( false ) . setIcon ( R . drawable . ic_action_delete_database ) . create ( ) ; lAlertDialog . show ( ) ; } }
package com . SecUpwN . AIMSICD . utils ; import android . app . Activity ; import android . os . AsyncTask ; import com . SecUpwN . AIMSICD . AppAIMSICD ; import java . lang . ref . WeakReference ; public abstract class BaseAsyncTask < TParams , TProgress , TResult > extends AsyncTask < TParams , TProgress , TResult > { protected AppAIMSICD mApp ; protected WeakReference < Activity > mWeakReferenceActivity ; public BaseAsyncTask ( Activity activity ) { mWeakReferenceActivity = new WeakReference < > ( activity ) ; mApp = ( AppAIMSICD ) activity . getApplication ( ) ; } public void setActivity ( Activity activity ) { if ( activity == null ) { mWeakReferenceActivity . clear ( ) ; onActivityDetached ( ) ; } else { onActivityAttached ( ) ; mWeakReferenceActivity = new WeakReference < > ( activity ) ; } } protected void onActivityAttached ( ) { } protected void onActivityDetached ( ) { } @ Override protected void onPreExecute ( ) { mApp . addTask ( mWeakReferenceActivity . get ( ) , this ) ; } @ Override protected void onPostExecute ( TResult result ) { mApp . removeTask ( this ) ; } @ Override protected void onCancelled ( ) { mApp . removeTask ( this ) ; } protected Activity getActivity ( ) { return mWeakReferenceActivity . get ( ) ; } }
package com . SecUpwN . AIMSICD . utils . atcmd ; import android . os . Message ; import android . util . Log ; import java . io . File ; import java . io . IOException ; public abstract class AtCommandTerminal { protected static final String TAG = "AIMSICD" ; protected static final String mTAG = "AtCommandTerminal" ; public abstract void send ( String s , Message message ) ; public abstract void dispose ( ) ; public static AtCommandTerminal factory ( ) throws UnsupportedOperationException { AtCommandTerminal term = null ; File smdFile = new File ( "/dev/smd7" ) ; if ( smdFile . exists ( ) ) { try { term = new TtyPrivFile ( smdFile . getAbsolutePath ( ) ) ; } catch ( IOException e ) { Log . e ( TAG , mTAG + " IOException in constructor" , e ) ; } } if ( term == null ) { throw new UnsupportedOperationException ( "unable to find AT command terminal" ) ; } return term ; } }
package com . SecUpwN . AIMSICD . utils . atcmd ; import android . util . Log ; import java . io . IOException ; public class TtyPrivFile extends TtyStream { protected Process mReadProc , mWriteProc ; public TtyPrivFile ( String ttyPath ) throws IOException { this ( new ProcessBuilder ( "su" , "-c" , "\\exec cat <" + ttyPath ) . start ( ) , new ProcessBuilder ( "su" , "-c" , "\\exec cat >" + ttyPath ) . start ( ) ) ; } private TtyPrivFile ( Process read , Process write ) { super ( read . getInputStream ( ) , write . getOutputStream ( ) ) ; mReadProc = read ; mWriteProc = write ; Log . d ( TAG , "mReadProc=" + mReadProc + ", mWriteProc=" + mWriteProc ) ; } @ Override public void dispose ( ) { super . dispose ( ) ; try { mOutputStream . write ( "ATE0\r" . getBytes ( "ASCII" ) ) ; mOutputStream . flush ( ) ; } catch ( IOException e ) { } mReadProc . destroy ( ) ; mWriteProc . destroy ( ) ; } }
package com . SecUpwN . AIMSICD . utils . atcmd ; import android . os . Message ; import android . util . Log ; import android . util . Pair ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . LinkedBlockingQueue ; class TtyStream extends AtCommandTerminal { protected InputStream mInputStream ; protected OutputStream mOutputStream ; private boolean mThreadRun = true ; private Thread mIoThread ; protected BlockingQueue < Pair < byte [ ] , Message > > mWriteQ ; TtyStream ( InputStream in , OutputStream out ) { mInputStream = in ; mOutputStream = out ; mIoThread = new Thread ( new IoRunnable ( ) , "AtCommandTerminalIO" ) ; mIoThread . start ( ) ; mWriteQ = new LinkedBlockingQueue < > ( ) ; this . send ( "ATQ0V1E0" , null ) ; } private class IoRunnable implements Runnable { @ Override public void run ( ) { try { BufferedReader in = new BufferedReader ( new InputStreamReader ( mInputStream , "ASCII" ) ) ; while ( mThreadRun ) { byte [ ] bytesOut ; Message resultMessage ; try { Pair < byte [ ] , Message > p = mWriteQ . take ( ) ; bytesOut = p . first ; resultMessage = p . second ; } catch ( InterruptedException e ) { continue ; } try { mOutputStream . write ( bytesOut ) ; mOutputStream . write ( '\r' ) ; mOutputStream . flush ( ) ; } catch ( IOException e ) { Log . e ( TAG , "Output IOException" , e ) ; if ( resultMessage != null ) { resultMessage . obj = e ; resultMessage . sendToTarget ( ) ; } return ; } String line ; List < String > lines = new ArrayList < > ( ) ; do { try { line = in . readLine ( ) ; if ( line == null ) throw new IOException ( "reader closed" ) ; } catch ( IOException e ) { Log . e ( TAG , "Input IOException" , e ) ; if ( resultMessage != null ) { resultMessage . obj = e ; resultMessage . sendToTarget ( ) ; } return ; } if ( line . length ( ) != 0 ) lines . add ( line ) ; } while ( ! ( line . equals ( "OK" ) || line . equals ( "ERROR" ) || line . startsWith ( "+CME ERROR" ) ) ) ; if ( resultMessage != null ) { resultMessage . obj = lines ; resultMessage . sendToTarget ( ) ; } else { Log . d ( TAG , "Data came in with no handler" ) ; } } } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } finally { dispose ( ) ; } } } @ Override public void send ( String s , Message resultMessage ) { try { mWriteQ . add ( Pair . create ( s . getBytes ( "ASCII" ) , resultMessage ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } @ Override public void dispose ( ) { mThreadRun = false ; } }
package com . SecUpwN . AIMSICD . adapters ; import android . view . View ; import android . view . ViewGroup ; public interface IAdapterViewInflater < T > { public View inflate ( BaseInflaterAdapter < T > adapter , int pos , View convertView , ViewGroup parent ) ; }
package com . SecUpwN . AIMSICD . adapters ; import com . SecUpwN . AIMSICD . R ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; public class SilentSmsCardInflater implements IAdapterViewInflater < SilentSmsCardData > { @ Override public View inflate ( final BaseInflaterAdapter < SilentSmsCardData > adapter , final int pos , View convertView , ViewGroup parent ) { ViewHolder holder ; if ( convertView == null ) { LayoutInflater inflater = LayoutInflater . from ( parent . getContext ( ) ) ; convertView = inflater . inflate ( R . layout . silent_sms_items , parent , false ) ; holder = new ViewHolder ( convertView ) ; } else { holder = ( ViewHolder ) convertView . getTag ( ) ; } final SilentSmsCardData item = adapter . getTItem ( pos ) ; holder . updateDisplay ( item ) ; return convertView ; } private class ViewHolder { private final View mRootView ; private final TextView mAddress ; private final TextView mDisplayAddress ; private final TextView mMessageClass ; private final TextView mServiceCentre ; private final TextView mMessageBody ; private final TextView mTimestamp ; private final TextView mExample ; public ViewHolder ( View rootView ) { mRootView = rootView ; mAddress = ( TextView ) mRootView . findViewById ( R . id . address ) ; mDisplayAddress = ( TextView ) mRootView . findViewById ( R . id . display_address ) ; mMessageClass = ( TextView ) mRootView . findViewById ( R . id . message_class ) ; mServiceCentre = ( TextView ) mRootView . findViewById ( R . id . service_centre ) ; mMessageBody = ( TextView ) mRootView . findViewById ( R . id . message_body ) ; mTimestamp = ( TextView ) mRootView . findViewById ( R . id . message_timestamp ) ; mExample = ( TextView ) mRootView . findViewById ( R . id . example ) ; rootView . setTag ( this ) ; } public void updateDisplay ( SilentSmsCardData item ) { mAddress . setText ( item . getAddress ( ) ) ; mDisplayAddress . setText ( item . getDisplayAddress ( ) ) ; mMessageClass . setText ( item . getMessageClass ( ) ) ; mServiceCentre . setText ( item . getServiceCentre ( ) ) ; mMessageBody . setText ( item . getMessage ( ) ) ; mTimestamp . setText ( item . getTimestamp ( ) ) ; if ( item . isFakeData ( ) ) { mExample . setText ( mRootView . getContext ( ) . getString ( R . string . example ) ) ; mExample . setVisibility ( View . VISIBLE ) ; } else { mExample . setVisibility ( View . GONE ) ; } } } }
package com . SecUpwN . AIMSICD . adapters ; import android . annotation . SuppressLint ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . animation . Animation ; import android . view . animation . AnimationUtils ; import android . widget . ArrayAdapter ; import android . widget . ImageView ; import android . widget . TextView ; import android . widget . Toast ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . constants . DrawerMenu ; import com . SecUpwN . AIMSICD . drawer . DrawerMenuItem ; import com . SecUpwN . AIMSICD . drawer . DrawerMenuSection ; import com . SecUpwN . AIMSICD . drawer . NavDrawerItem ; import java . util . List ; public class DrawerMenuAdapter extends ArrayAdapter < NavDrawerItem > { private final LayoutInflater inflater ; private final View . OnClickListener mInfoButtonListener ; private final Toast mToast ; private final Animation mBounceHelpButtonAnimation ; @ SuppressLint ( "ShowToast" ) public DrawerMenuAdapter ( Context context , int textViewResourceId , List < NavDrawerItem > objects ) { super ( context , textViewResourceId , objects ) ; inflater = LayoutInflater . from ( context ) ; mToast = Toast . makeText ( context . getApplicationContext ( ) , "" , Toast . LENGTH_LONG ) ; mInfoButtonListener = new View . OnClickListener ( ) { @ Override public void onClick ( View pView ) { pView . startAnimation ( mBounceHelpButtonAnimation ) ; if ( pView . getTag ( ) != null && pView . getTag ( ) instanceof Integer ) showHelpToast ( ( Integer ) pView . getTag ( ) ) ; } } ; mBounceHelpButtonAnimation = AnimationUtils . loadAnimation ( context . getApplicationContext ( ) , R . anim . action_button_help ) ; } private void showHelpToast ( Integer pToastValueId ) { mToast . setText ( getContext ( ) . getString ( pToastValueId ) ) ; mToast . show ( ) ; } @ Override public View getView ( int position , View convertView , ViewGroup parent ) { View view ; NavDrawerItem menuItem = this . getItem ( position ) ; if ( menuItem . getType ( ) == DrawerMenuItem . ITEM_TYPE ) { view = getItemView ( convertView , parent , menuItem ) ; } else { view = getSectionView ( convertView , parent , menuItem ) ; } return view ; } View getItemView ( View convertView , ViewGroup parentView , NavDrawerItem navDrawerItem ) { DrawerMenuItem menuItem = ( DrawerMenuItem ) navDrawerItem ; NavMenuItemHolder navMenuItemHolder = null ; if ( convertView == null ) { convertView = inflater . inflate ( R . layout . drawer_item , parentView , false ) ; TextView labelView = ( TextView ) convertView . findViewById ( R . id . drawer_menu_item_label ) ; ImageView iconView = ( ImageView ) convertView . findViewById ( R . id . drawer_menu_item_icon ) ; ImageView lInfoButton = ( ImageView ) convertView . findViewById ( R . id . drawer_menu_item_info_button ) ; navMenuItemHolder = new NavMenuItemHolder ( ) ; navMenuItemHolder . itemName = labelView ; navMenuItemHolder . itemIcon = iconView ; navMenuItemHolder . itemInfoButton = lInfoButton ; convertView . setTag ( navMenuItemHolder ) ; } if ( navMenuItemHolder == null ) { navMenuItemHolder = ( NavMenuItemHolder ) convertView . getTag ( ) ; } navMenuItemHolder . itemName . setText ( menuItem . getLabel ( ) ) ; navMenuItemHolder . itemIcon . setImageResource ( menuItem . getIconId ( ) ) ; if ( menuItem . isShowInfoButton ( ) ) { navMenuItemHolder . itemInfoButton . setTag ( menuItem . getHelpStringId ( ) ) ; navMenuItemHolder . itemInfoButton . setVisibility ( View . VISIBLE ) ; navMenuItemHolder . itemInfoButton . setOnClickListener ( mInfoButtonListener ) ; } else { navMenuItemHolder . itemInfoButton . setTag ( menuItem . getHelpStringId ( ) ) ; navMenuItemHolder . itemInfoButton . setVisibility ( View . INVISIBLE ) ; navMenuItemHolder . itemInfoButton . setOnClickListener ( null ) ; } return convertView ; } View getSectionView ( View convertView , ViewGroup parentView , NavDrawerItem navDrawerItem ) { DrawerMenuSection menuSection = ( DrawerMenuSection ) navDrawerItem ; NavMenuSectionHolder navMenuItemHolder = null ; if ( convertView == null ) { convertView = inflater . inflate ( R . layout . drawer_section , parentView , false ) ; TextView labelView = ( TextView ) convertView . findViewById ( R . id . drawer_menu_section_label ) ; navMenuItemHolder = new NavMenuSectionHolder ( ) ; navMenuItemHolder . itemName = labelView ; convertView . setTag ( navMenuItemHolder ) ; } if ( navMenuItemHolder == null ) { navMenuItemHolder = ( NavMenuSectionHolder ) convertView . getTag ( ) ; } navMenuItemHolder . itemName . setText ( menuSection . getLabel ( ) ) ; return convertView ; } @ Override public int getViewTypeCount ( ) { return DrawerMenu . COUNT_OF_MENU_TYPE ; } @ Override public int getItemViewType ( int position ) { return this . getItem ( position ) . getType ( ) ; } @ Override public boolean isEnabled ( int position ) { return getItem ( position ) . isEnabled ( ) ; } private static class NavMenuItemHolder { TextView itemName ; ImageView itemIcon ; ImageView itemInfoButton ; } private class NavMenuSectionHolder { private TextView itemName ; } }
package com . SecUpwN . AIMSICD . adapters ; import java . text . SimpleDateFormat ; public class SilentSmsCardData { private final String mAddress ; private final String mDisplayAddress ; private final String mMessageClass ; private final String mServiceCentre ; private final String mMessage ; private final long mTimestamp ; private boolean mIsFakeData ; public SilentSmsCardData ( String address , String displayAddress , String messageClass , String serviceCentre , String messageBody , long timestamp ) { mAddress = address ; mDisplayAddress = displayAddress ; mMessageClass = messageClass ; mServiceCentre = serviceCentre ; mMessage = messageBody ; mTimestamp = timestamp ; } public String getAddress ( ) { String address = "Address: " ; if ( mAddress . isEmpty ( ) ) { return address + "Unavailable" ; } else { return address + mAddress ; } } public String getDisplayAddress ( ) { String display = "Display Address: " ; if ( mDisplayAddress . isEmpty ( ) ) { return display + "Unavailable" ; } else { return display + mDisplayAddress ; } } public String getMessageClass ( ) { String messageClass = "Message Class: " ; if ( messageClass . isEmpty ( ) ) { return messageClass + "Unavailable" ; } else { return messageClass + mMessageClass ; } } public String getServiceCentre ( ) { String serviceCentre = "Service Centre: " ; if ( mServiceCentre . isEmpty ( ) ) { return serviceCentre + "Unavailable" ; } else { return serviceCentre + mServiceCentre ; } } public String getMessage ( ) { String message = "Message: " ; if ( message . isEmpty ( ) ) { return message + "Unavailable" ; } else { return message + mMessage ; } } public String getTimestamp ( ) { SimpleDateFormat formatter = new SimpleDateFormat ( "dd-MMM-yyyy HH:mm:ss" ) ; String dateString = formatter . format ( mTimestamp ) ; return "Timestamp: " + dateString ; } public boolean isFakeData ( ) { return mIsFakeData ; } public void setIsFakeData ( boolean pIsFakeData ) { mIsFakeData = pIsFakeData ; } }
package com . SecUpwN . AIMSICD . adapters ; import com . SecUpwN . AIMSICD . utils . Cell ; import com . SecUpwN . AIMSICD . utils . Device ; public class CardItemData { private final String mCellID ; private final String mLac ; private final String mMcc ; private final String mMnc ; private final String mNet ; private final String mSignal ; private final String mAvgSigStr ; private final String mSamples ; private final String mLat ; private final String mLng ; private final String mCountry ; private final String mPsc ; private final String mTimestamp ; private final String mRecordId ; public CardItemData ( Cell cell , String recordId ) { if ( cell . getCID ( ) != Integer . MAX_VALUE && cell . getCID ( ) != - 1 ) { mCellID = "CID: " + cell . getCID ( ) + " (0x" + Integer . toHexString ( cell . getCID ( ) ) + ")" ; } else { mCellID = "N/A" ; } if ( cell . getLAC ( ) != Integer . MAX_VALUE && cell . getLAC ( ) != - 1 ) { mLac = "LAC: " + cell . getLAC ( ) ; } else { mLac = "N/A" ; } if ( cell . getMCC ( ) != Integer . MAX_VALUE && cell . getMCC ( ) != 0 ) { mMcc = "MCC: " + cell . getMCC ( ) ; } else { mMcc = "N/A" ; } if ( cell . getMNC ( ) != Integer . MAX_VALUE && cell . getMNC ( ) != 0 ) { mMnc = "MNC: " + cell . getMNC ( ) ; } else { mMnc = "N/A" ; } if ( cell . getNetType ( ) != Integer . MAX_VALUE && cell . getNetType ( ) != - 1 ) { mNet = "Type: " + cell . getNetType ( ) + " - " + Device . getNetworkTypeName ( cell . getNetType ( ) ) ; } else { mNet = "N/A" ; } if ( cell . getPSC ( ) != Integer . MAX_VALUE && cell . getPSC ( ) != - 1 ) { mPsc = "PSC: " + cell . getPSC ( ) ; } else { mPsc = "N/A" ; } if ( cell . getRssi ( ) != Integer . MAX_VALUE && cell . getRssi ( ) != - 1 ) { mSignal = "RSSI: " + cell . getRssi ( ) ; } else if ( cell . getDBM ( ) != Integer . MAX_VALUE && cell . getDBM ( ) != - 1 ) { mSignal = "Dbm: " + cell . getDBM ( ) ; } else { mSignal = "N/A" ; } mLat = "N/A" ; mLng = "N/A" ; mAvgSigStr = "N/A" ; mSamples = "N/A" ; mCountry = "N/A" ; mTimestamp = "N/A" ; mRecordId = recordId ; } public CardItemData ( String cellID , String lac , String mcc , String mnc , String lat , String lng , String avgSigStr , String samples , String recordId ) { mCellID = cellID ; mLac = lac ; mMcc = mcc ; mMnc = mnc ; mNet = "Network Type: N/A" ; mLat = lat ; mLng = lng ; mSignal = "Signal: N/A" ; mAvgSigStr = avgSigStr ; mSamples = samples ; mPsc = "PSC: N/A" ; mCountry = "Country: N/A" ; mTimestamp = "Timestamp: N/A" ; mRecordId = recordId ; } public CardItemData ( String cellID , String psc , String mcc , String mnc , String signal , String recordId ) { mCellID = cellID ; mLac = "LAC: N/A" ; mMcc = mcc ; mMnc = mnc ; mLat = "Latitude: N/A" ; mLng = "Longitude: N/A" ; mNet = "Network Type: N/A" ; mAvgSigStr = "Avg Signal: N/A" ; mSamples = "Samples: N/A" ; mSignal = signal ; mPsc = psc ; mCountry = "Country: N/A" ; mTimestamp = "Timestamp: N/A" ; mRecordId = recordId ; } public CardItemData ( String cellID , String lac , String mcc , String mnc , String signal , String psc , String timestamp , String recordId ) { mCellID = cellID ; mLac = lac ; mMcc = mcc ; mMnc = mnc ; mLat = "Latitude: N/A" ; mLng = "Longitude: N/A" ; mNet = "Network Type: N/A" ; mSignal = signal ; mPsc = psc ; mAvgSigStr = "Avg Signal: N/A" ; mSamples = "Samples: N/A" ; mTimestamp = timestamp ; mCountry = "Country: N/A" ; mRecordId = recordId ; } public CardItemData ( int type , String cellID , String lac , String mcc , String mnc , String signal , String timestamp , String recordId ) { mCellID = cellID ; mLac = lac ; mMcc = mcc ; mMnc = mnc ; mLat = "Latitude: N/A" ; mLng = "Longitude: N/A" ; mNet = "Network Type: N/A" ; mSignal = signal ; mAvgSigStr = "Avg Signal: N/A" ; mSamples = "Samples: N/A" ; mTimestamp = timestamp ; mPsc = "PSC: N/A" ; mCountry = "Country: N/A" ; mRecordId = recordId ; } public CardItemData ( String cellID , String lac , String net , String lat , String lng , String signal , String recordId ) { mCellID = cellID ; mLac = lac ; mNet = net ; mMcc = "MCC: N/A" ; mMnc = "MNC: N/A" ; mLat = lat ; mLng = lng ; mSignal = signal ; mAvgSigStr = "Avg Signal: N/A" ; mSamples = "Samples: N/A" ; mPsc = "PSC: N/A" ; mCountry = "Country: N/A" ; mTimestamp = "Timestamp: N/A" ; mRecordId = recordId ; } public CardItemData ( String country , String mcc , String lat , String lng , String recordId ) { mCellID = "CellID: N/A" ; mLac = "LAC: N/A" ; mCountry = country ; mMcc = mcc ; mMnc = "MNC: N/A" ; mNet = "Network Type: N/A" ; mSignal = "Signal: N/A" ; mLat = lat ; mLng = lng ; mAvgSigStr = "Avg Signal: N/A" ; mSamples = "Samples: N/A" ; mPsc = "PSC: N/A" ; mTimestamp = "Timestamp: N/A" ; mRecordId = recordId ; } public String getCellID ( ) { return mCellID ; } public String getLac ( ) { return mLac ; } public String getMcc ( ) { return mMcc ; } public String getMnc ( ) { return mMnc ; } public String getNet ( ) { return mNet ; } public String getSignal ( ) { return mSignal ; } public String getAvgSigStr ( ) { return mAvgSigStr ; } public String getSamples ( ) { return mSamples ; } public String getLat ( ) { return mLat ; } public String getLng ( ) { return mLng ; } public String getCountry ( ) { return mCountry ; } public String getRecordId ( ) { return mRecordId ; } public String getPsc ( ) { return mPsc ; } public String getTimestamp ( ) { return mTimestamp ; } }
package com . stericson . RootShell . execution ; import com . stericson . RootShell . RootShell ; import com . stericson . RootShell . exceptions . RootDeniedException ; import android . content . Context ; import android . util . Log ; import java . io . BufferedReader ; import java . io . EOFException ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . TimeoutException ; public class Shell { public static enum ShellType { NORMAL , ROOT , CUSTOM } public static enum ShellContext { NORMAL ( "normal" ) , SHELL ( "u:r:shell:s0" ) , SYSTEM_SERVER ( "u:r:system_server:s0" ) , SYSTEM_APP ( "u:r:system_app:s0" ) , PLATFORM_APP ( "u:r:platform_app:s0" ) , UNTRUSTED_APP ( "u:r:untrusted_app:s0" ) , RECOVERY ( "u:r:recovery:s0" ) ; private String value ; private ShellContext ( String value ) { this . value = value ; } public String getValue ( ) { return this . value ; } } private static final String token = "F*D^W@#FGF" ; private static Shell rootShell = null ; private static Shell shell = null ; private static Shell customShell = null ; private static String [ ] suVersion = new String [ ] { null , null } ; public static ShellContext defaultContext = ShellContext . NORMAL ; private int shellTimeout = 25000 ; private ShellType shellType = null ; private ShellContext shellContext = Shell . ShellContext . NORMAL ; private String error = "" ; private final Process proc ; private final BufferedReader inputStream ; private final BufferedReader errorStream ; private final OutputStreamWriter outputStream ; private final List < Command > commands = new ArrayList < Command > ( ) ; private boolean close = false ; private Boolean isSELinuxEnforcing = null ; public boolean isExecuting = false ; public boolean isReading = false ; public boolean isClosed = false ; private int maxCommands = 5000 ; private int read = 0 ; private int write = 0 ; private int totalExecuted = 0 ; private int totalRead = 0 ; private boolean isCleaning = false ; private Shell ( String cmd , ShellType shellType , ShellContext shellContext , int shellTimeout ) throws IOException , TimeoutException , RootDeniedException { RootShell . log ( "Starting shell: " + cmd ) ; RootShell . log ( "Context: " + shellContext . getValue ( ) ) ; RootShell . log ( "Timeout: " + shellTimeout ) ; this . shellType = shellType ; this . shellTimeout = shellTimeout > 0 ? shellTimeout : this . shellTimeout ; this . shellContext = shellContext ; if ( this . shellContext == ShellContext . NORMAL ) { this . proc = Runtime . getRuntime ( ) . exec ( cmd ) ; } else { String display = getSuVersion ( false ) ; String internal = getSuVersion ( true ) ; if ( isSELinuxEnforcing ( ) && ( display != null ) && ( internal != null ) && ( display . endsWith ( "SUPERSU" ) ) && ( Integer . valueOf ( internal ) >= 190 ) ) { cmd += " --context " + this . shellContext . getValue ( ) ; } else { RootShell . log ( "Su binary --context switch not supported!" ) ; RootShell . log ( "Su binary display version: " + display ) ; RootShell . log ( "Su binary internal version: " + internal ) ; RootShell . log ( "SELinuxEnforcing: " + isSELinuxEnforcing ( ) ) ; } this . proc = Runtime . getRuntime ( ) . exec ( cmd ) ; } this . inputStream = new BufferedReader ( new InputStreamReader ( this . proc . getInputStream ( ) , "UTF-8" ) ) ; this . errorStream = new BufferedReader ( new InputStreamReader ( this . proc . getErrorStream ( ) , "UTF-8" ) ) ; this . outputStream = new OutputStreamWriter ( this . proc . getOutputStream ( ) , "UTF-8" ) ; Worker worker = new Worker ( this ) ; worker . start ( ) ; try { worker . join ( this . shellTimeout ) ; if ( worker . exit == - 911 ) { try { this . proc . destroy ( ) ; } catch ( Exception e ) { } closeQuietly ( this . inputStream ) ; closeQuietly ( this . errorStream ) ; closeQuietly ( this . outputStream ) ; throw new TimeoutException ( this . error ) ; } else if ( worker . exit == - 42 ) { try { this . proc . destroy ( ) ; } catch ( Exception e ) { } closeQuietly ( this . inputStream ) ; closeQuietly ( this . errorStream ) ; closeQuietly ( this . outputStream ) ; throw new RootDeniedException ( "Root Access Denied" ) ; } else { Thread si = new Thread ( this . input , "Shell Input" ) ; si . setPriority ( Thread . NORM_PRIORITY ) ; si . start ( ) ; Thread so = new Thread ( this . output , "Shell Output" ) ; so . setPriority ( Thread . NORM_PRIORITY ) ; so . start ( ) ; } } catch ( InterruptedException ex ) { worker . interrupt ( ) ; Thread . currentThread ( ) . interrupt ( ) ; throw new TimeoutException ( ) ; } } public Command add ( Command command ) throws IOException { if ( this . close ) { throw new IllegalStateException ( "Unable to add commands to a closed shell" ) ; } while ( this . isCleaning ) { ; } command . resetCommand ( ) ; this . commands . add ( command ) ; this . notifyThreads ( ) ; return command ; } public final void useCWD ( Context context ) throws IOException , TimeoutException , RootDeniedException { add ( new Command ( - 1 , false , "cd " + context . getApplicationInfo ( ) . dataDir ) ) ; } private void cleanCommands ( ) { this . isCleaning = true ; int toClean = Math . abs ( this . maxCommands - ( this . maxCommands / 4 ) ) ; RootShell . log ( "Cleaning up: " + toClean ) ; for ( int i = 0 ; i < toClean ; i ++ ) { this . commands . remove ( 0 ) ; } this . read = this . commands . size ( ) - 1 ; this . write = this . commands . size ( ) - 1 ; this . isCleaning = false ; } private void closeQuietly ( final Reader input ) { try { if ( input != null ) { input . close ( ) ; } } catch ( Exception ignore ) { } } private void closeQuietly ( final Writer output ) { try { if ( output != null ) { output . close ( ) ; } } catch ( Exception ignore ) { } } public void close ( ) throws IOException { RootShell . log ( "Request to close shell!" ) ; int count = 0 ; while ( isExecuting ) { RootShell . log ( "Waiting on shell to finish executing before closing..." ) ; count ++ ; if ( count > 10000 ) { break ; } } synchronized ( this . commands ) { this . close = true ; this . notifyThreads ( ) ; } RootShell . log ( "Shell Closed!" ) ; if ( this == Shell . rootShell ) { Shell . rootShell = null ; } else if ( this == Shell . shell ) { Shell . shell = null ; } else if ( this == Shell . customShell ) { Shell . customShell = null ; } } public static void closeCustomShell ( ) throws IOException { RootShell . log ( "Request to close custom shell!" ) ; if ( Shell . customShell == null ) { return ; } Shell . customShell . close ( ) ; } public static void closeRootShell ( ) throws IOException { RootShell . log ( "Request to close root shell!" ) ; if ( Shell . rootShell == null ) { return ; } Shell . rootShell . close ( ) ; } public static void closeShell ( ) throws IOException { RootShell . log ( "Request to close normal shell!" ) ; if ( Shell . shell == null ) { return ; } Shell . shell . close ( ) ; } public static void closeAll ( ) throws IOException { RootShell . log ( "Request to close all shells!" ) ; Shell . closeShell ( ) ; Shell . closeRootShell ( ) ; Shell . closeCustomShell ( ) ; } public int getCommandQueuePosition ( Command cmd ) { return this . commands . indexOf ( cmd ) ; } public String getCommandQueuePositionString ( Command cmd ) { return "Command is in position " + getCommandQueuePosition ( cmd ) + " currently executing command at position " + this . write + " and the number of commands is " + commands . size ( ) ; } public static Shell getOpenShell ( ) { if ( Shell . customShell != null ) { return Shell . customShell ; } else if ( Shell . rootShell != null ) { return Shell . rootShell ; } else { return Shell . shell ; } } private synchronized String getSuVersion ( boolean internal ) { int idx = internal ? 0 : 1 ; if ( suVersion [ idx ] == null ) { String version = null ; Process process ; try { process = Runtime . getRuntime ( ) . exec ( internal ? "su -V" : "su -v" , null ) ; process . waitFor ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; return null ; } List < String > stdout = new ArrayList < String > ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; try { String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { stdout . add ( line ) ; } } catch ( IOException e ) { } try { reader . close ( ) ; } catch ( IOException e ) { } process . destroy ( ) ; List < String > ret = stdout ; if ( ret != null ) { for ( String line : ret ) { if ( ! internal ) { if ( line . contains ( "." ) ) { version = line ; break ; } } else { try { if ( Integer . parseInt ( line ) > 0 ) { version = line ; break ; } } catch ( NumberFormatException e ) { } } } } suVersion [ idx ] = version ; } return suVersion [ idx ] ; } public static boolean isShellOpen ( ) { return Shell . shell == null ; } public static boolean isCustomShellOpen ( ) { return Shell . customShell == null ; } public static boolean isRootShellOpen ( ) { return Shell . rootShell == null ; } public static boolean isAnyShellOpen ( ) { return Shell . shell != null || Shell . rootShell != null || Shell . customShell != null ; } public synchronized boolean isSELinuxEnforcing ( ) { if ( isSELinuxEnforcing == null ) { Boolean enforcing = null ; if ( android . os . Build . VERSION . SDK_INT >= 17 ) { File f = new File ( "/sys/fs/selinux/enforce" ) ; if ( f . exists ( ) ) { try { InputStream is = new FileInputStream ( "/sys/fs/selinux/enforce" ) ; try { enforcing = ( is . read ( ) == '1' ) ; } finally { is . close ( ) ; } } catch ( Exception e ) { } } if ( enforcing == null ) { enforcing = ( android . os . Build . VERSION . SDK_INT >= 19 ) ; } } if ( enforcing == null ) { enforcing = false ; } isSELinuxEnforcing = enforcing ; } return isSELinuxEnforcing ; } private Runnable input = new Runnable ( ) { public void run ( ) { try { while ( true ) { synchronized ( commands ) { while ( ! close && write >= commands . size ( ) ) { isExecuting = false ; commands . wait ( ) ; } } if ( write >= maxCommands ) { while ( read != write ) { RootShell . log ( "Waiting for read and write to catch up before cleanup." ) ; } cleanCommands ( ) ; } if ( write < commands . size ( ) ) { isExecuting = true ; Command cmd = commands . get ( write ) ; cmd . startExecution ( ) ; RootShell . log ( "Executing: " + cmd . getCommand ( ) + " with context: " + shellContext ) ; outputStream . write ( cmd . getCommand ( ) ) ; String line = "\necho " + token + " " + totalExecuted + " $?\n" ; outputStream . write ( line ) ; outputStream . flush ( ) ; write ++ ; totalExecuted ++ ; } else if ( close ) { isExecuting = false ; outputStream . write ( "\nexit 0\n" ) ; outputStream . flush ( ) ; RootShell . log ( "Closing shell" ) ; return ; } } } catch ( IOException e ) { RootShell . log ( e . getMessage ( ) , RootShell . LogLevel . ERROR , e ) ; } catch ( InterruptedException e ) { RootShell . log ( e . getMessage ( ) , RootShell . LogLevel . ERROR , e ) ; } finally { write = 0 ; closeQuietly ( outputStream ) ; } } } ; protected void notifyThreads ( ) { Thread t = new Thread ( ) { public void run ( ) { synchronized ( commands ) { commands . notifyAll ( ) ; } } } ; t . start ( ) ; } private Runnable output = new Runnable ( ) { public void run ( ) { try { Command command = null ; while ( ! close || inputStream . ready ( ) || read < commands . size ( ) ) { isReading = false ; String outputLine = inputStream . readLine ( ) ; isReading = true ; if ( outputLine == null ) { break ; } if ( command == null ) { if ( read >= commands . size ( ) ) { if ( close ) { break ; } continue ; } command = commands . get ( read ) ; } int pos = - 1 ; pos = outputLine . indexOf ( token ) ; if ( pos == - 1 ) { command . output ( command . id , outputLine ) ; } else if ( pos > 0 ) { command . output ( command . id , outputLine . substring ( 0 , pos ) ) ; } if ( pos >= 0 ) { outputLine = outputLine . substring ( pos ) ; String fields [ ] = outputLine . split ( " " ) ; if ( fields . length >= 2 && fields [ 1 ] != null ) { int id = 0 ; try { id = Integer . parseInt ( fields [ 1 ] ) ; } catch ( NumberFormatException e ) { } int exitCode = - 1 ; try { exitCode = Integer . parseInt ( fields [ 2 ] ) ; } catch ( NumberFormatException e ) { } if ( id == totalRead ) { processErrors ( command ) ; int iterations = 0 ; while ( command . totalOutput > command . totalOutputProcessed ) { if ( iterations == 0 ) { iterations ++ ; RootShell . log ( "Waiting for output to be processed. " + command . totalOutputProcessed + " Of " + command . totalOutput ) ; } try { synchronized ( this ) { this . wait ( 2000 ) ; } } catch ( Exception e ) { RootShell . log ( e . getMessage ( ) ) ; } } RootShell . log ( "Read all output" ) ; command . setExitCode ( exitCode ) ; command . commandFinished ( ) ; command = null ; read ++ ; totalRead ++ ; continue ; } } } } try { proc . waitFor ( ) ; proc . destroy ( ) ; } catch ( Exception e ) { } while ( read < commands . size ( ) ) { if ( command == null ) { command = commands . get ( read ) ; } if ( command . totalOutput < command . totalOutputProcessed ) { command . terminated ( "All output not processed!" ) ; command . terminated ( "Did you forget the super.commandOutput call or are you waiting on the command object?" ) ; } else { command . terminated ( "Unexpected Termination." ) ; } command = null ; read ++ ; } read = 0 ; } catch ( IOException e ) { RootShell . log ( e . getMessage ( ) , RootShell . LogLevel . ERROR , e ) ; } finally { closeQuietly ( outputStream ) ; closeQuietly ( errorStream ) ; closeQuietly ( inputStream ) ; RootShell . log ( "Shell destroyed" ) ; isClosed = true ; isReading = false ; } } } ; public void processErrors ( Command command ) { try { while ( errorStream . ready ( ) && command != null ) { String line = errorStream . readLine ( ) ; if ( line == null ) { break ; } command . output ( command . id , line ) ; } } catch ( Exception e ) { RootShell . log ( e . getMessage ( ) , RootShell . LogLevel . ERROR , e ) ; } } public static void runRootCommand ( Command command ) throws IOException , TimeoutException , RootDeniedException { Shell . startRootShell ( ) . add ( command ) ; } public static void runCommand ( Command command ) throws IOException , TimeoutException { Shell . startShell ( ) . add ( command ) ; } public static Shell startRootShell ( ) throws IOException , TimeoutException , RootDeniedException { return Shell . startRootShell ( 0 , 3 ) ; } public static Shell startRootShell ( int timeout ) throws IOException , TimeoutException , RootDeniedException { return Shell . startRootShell ( timeout , 3 ) ; } public static Shell startRootShell ( int timeout , int retry ) throws IOException , TimeoutException , RootDeniedException { return Shell . startRootShell ( timeout , Shell . defaultContext , retry ) ; } public static Shell startRootShell ( int timeout , ShellContext shellContext , int retry ) throws IOException , TimeoutException , RootDeniedException { int retries = 0 ; if ( Shell . rootShell == null ) { RootShell . log ( "Starting Root Shell!" ) ; String cmd = "su" ; while ( Shell . rootShell == null ) { try { RootShell . log ( "Trying to open Root Shell, attempt #" + retries ) ; Shell . rootShell = new Shell ( cmd , ShellType . ROOT , shellContext , timeout ) ; } catch ( IOException e ) { if ( retries ++ >= retry ) { RootShell . log ( "IOException, could not start shell" ) ; throw e ; } } catch ( RootDeniedException e ) { if ( retries ++ >= retry ) { RootShell . log ( "RootDeniedException, could not start shell" ) ; throw e ; } } catch ( TimeoutException e ) { if ( retries ++ >= retry ) { RootShell . log ( "TimeoutException, could not start shell" ) ; throw e ; } } } } else if ( Shell . rootShell . shellContext != shellContext ) { try { RootShell . log ( "Context is different than open shell, switching context... " + Shell . rootShell . shellContext + " VS " + shellContext ) ; Shell . rootShell . switchRootShellContext ( shellContext ) ; } catch ( IOException e ) { if ( retries ++ >= retry ) { RootShell . log ( "IOException, could not switch context!" ) ; throw e ; } } catch ( RootDeniedException e ) { if ( retries ++ >= retry ) { RootShell . log ( "RootDeniedException, could not switch context!" ) ; throw e ; } } catch ( TimeoutException e ) { if ( retries ++ >= retry ) { RootShell . log ( "TimeoutException, could not switch context!" ) ; throw e ; } } } else { RootShell . log ( "Using Existing Root Shell!" ) ; } return Shell . rootShell ; } public static Shell startCustomShell ( String shellPath ) throws IOException , TimeoutException , RootDeniedException { return Shell . startCustomShell ( shellPath , 0 ) ; } public static Shell startCustomShell ( String shellPath , int timeout ) throws IOException , TimeoutException , RootDeniedException { if ( Shell . customShell == null ) { RootShell . log ( "Starting Custom Shell!" ) ; Shell . customShell = new Shell ( shellPath , ShellType . CUSTOM , ShellContext . NORMAL , timeout ) ; } else { RootShell . log ( "Using Existing Custom Shell!" ) ; } return Shell . customShell ; } public static Shell startShell ( ) throws IOException , TimeoutException { return Shell . startShell ( 0 ) ; } public static Shell startShell ( int timeout ) throws IOException , TimeoutException { try { if ( Shell . shell == null ) { RootShell . log ( "Starting Shell!" ) ; Shell . shell = new Shell ( "/system/bin/sh" , ShellType . NORMAL , ShellContext . NORMAL , timeout ) ; } else { RootShell . log ( "Using Existing Shell!" ) ; } return Shell . shell ; } catch ( RootDeniedException e ) { throw new IOException ( ) ; } } public Shell switchRootShellContext ( ShellContext shellContext ) throws IOException , TimeoutException , RootDeniedException { if ( this . shellType == ShellType . ROOT ) { try { Shell . closeRootShell ( ) ; } catch ( Exception e ) { RootShell . log ( "Problem closing shell while trying to switch context..." ) ; } return Shell . startRootShell ( this . shellTimeout , shellContext , 3 ) ; } else { RootShell . log ( "Can only switch context on a root shell!" ) ; return this ; } } protected static class Worker extends Thread { public int exit = - 911 ; public Shell shell ; private Worker ( Shell shell ) { this . shell = shell ; } public void run ( ) { try { shell . outputStream . write ( "echo Started\n" ) ; shell . outputStream . flush ( ) ; while ( true ) { String line = shell . inputStream . readLine ( ) ; if ( line == null ) { throw new EOFException ( ) ; } else if ( "" . equals ( line ) ) { continue ; } else if ( "Started" . equals ( line ) ) { this . exit = 1 ; setShellOom ( ) ; break ; } shell . error = "unkown error occured." ; } } catch ( IOException e ) { exit = - 42 ; if ( e . getMessage ( ) != null ) { shell . error = e . getMessage ( ) ; } else { shell . error = "RootAccess denied?." ; } } } private void setShellOom ( ) { try { Class < ? > processClass = shell . proc . getClass ( ) ; Field field ; try { field = processClass . getDeclaredField ( "pid" ) ; } catch ( NoSuchFieldException e ) { field = processClass . getDeclaredField ( "id" ) ; } field . setAccessible ( true ) ; int pid = ( Integer ) field . get ( shell . proc ) ; shell . outputStream . write ( "(echo -17 > /proc/" + pid + "/oom_adj) &> /dev/null\n" ) ; shell . outputStream . write ( "(echo -17 > /proc/$$/oom_adj) &> /dev/null\n" ) ; shell . outputStream . flush ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } }
package com . SecUpwN . AIMSICD . adapters ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; import com . SecUpwN . AIMSICD . R ; public class EventLogCardInflater implements IAdapterViewInflater < EventLogItemData > { @ Override public View inflate ( final BaseInflaterAdapter < EventLogItemData > adapter , final int pos , View convertView , ViewGroup parent ) { ViewHolder holder ; if ( convertView == null ) { LayoutInflater inflater = LayoutInflater . from ( parent . getContext ( ) ) ; convertView = inflater . inflate ( R . layout . eventlog_items , parent , false ) ; holder = new ViewHolder ( convertView ) ; } else { holder = ( ViewHolder ) convertView . getTag ( ) ; } final EventLogItemData item = adapter . getTItem ( pos ) ; holder . updateDisplay ( item ) ; return convertView ; } private class ViewHolder { private final View mRootView ; private final TextView mtime ; private final TextView mLAC ; private final TextView mCID ; private final TextView mPSC ; private final TextView mgpsd_lat ; private final TextView mgpsd_lon ; private final TextView mgpsd_accu ; private final TextView mDF_id ; private final TextView mDF_desc ; private final TextView mRecordId ; private final TextView mExample ; public ViewHolder ( View rootView ) { mRootView = rootView ; mtime = ( TextView ) mRootView . findViewById ( R . id . time ) ; mLAC = ( TextView ) mRootView . findViewById ( R . id . LAC ) ; mCID = ( TextView ) mRootView . findViewById ( R . id . CID ) ; mPSC = ( TextView ) mRootView . findViewById ( R . id . PSC ) ; mgpsd_lat = ( TextView ) mRootView . findViewById ( R . id . gpsd_lat ) ; mgpsd_lon = ( TextView ) mRootView . findViewById ( R . id . gpsd_lon ) ; mgpsd_accu = ( TextView ) mRootView . findViewById ( R . id . gpsd_accu ) ; mDF_id = ( TextView ) mRootView . findViewById ( R . id . DF_id ) ; mDF_desc = ( TextView ) mRootView . findViewById ( R . id . DF_desc ) ; mRecordId = ( TextView ) mRootView . findViewById ( R . id . record_id ) ; mExample = ( TextView ) mRootView . findViewById ( R . id . example ) ; rootView . setTag ( this ) ; } public void updateDisplay ( EventLogItemData item ) { mtime . setText ( item . getTimestamp ( ) ) ; mLAC . setText ( item . getLac ( ) ) ; mCID . setText ( item . getCellID ( ) ) ; mPSC . setText ( item . getPsc ( ) ) ; mgpsd_lat . setText ( item . getLat ( ) ) ; mgpsd_lon . setText ( item . getLng ( ) ) ; mgpsd_accu . setText ( item . getgpsd_accu ( ) ) ; mDF_id . setText ( item . getDF_id ( ) ) ; mDF_desc . setText ( item . getDF_desc ( ) ) ; mRecordId . setText ( item . getRecordId ( ) ) ; if ( item . isFakeData ( ) ) { mExample . setText ( mRootView . getContext ( ) . getString ( R . string . example ) ) ; mExample . setVisibility ( View . VISIBLE ) ; } else { mExample . setVisibility ( View . GONE ) ; } } } }
package com . SecUpwN . AIMSICD . adapters ; import com . SecUpwN . AIMSICD . R ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; public class OpenCellIdCardInflater implements IAdapterViewInflater < CardItemData > { @ Override public View inflate ( final BaseInflaterAdapter < CardItemData > adapter , final int pos , View convertView , ViewGroup parent ) { ViewHolder holder ; if ( convertView == null ) { LayoutInflater inflater = LayoutInflater . from ( parent . getContext ( ) ) ; convertView = inflater . inflate ( R . layout . opencelid_items , parent , false ) ; holder = new ViewHolder ( convertView ) ; } else { holder = ( ViewHolder ) convertView . getTag ( ) ; } final CardItemData item = adapter . getTItem ( pos ) ; holder . updateDisplay ( item ) ; return convertView ; } private class ViewHolder { private final View mRootView ; private final TextView mCellID ; private final TextView mLac ; private final TextView mMcc ; private final TextView mMnc ; private final TextView mLat ; private final TextView mLng ; private final TextView mAvgSigStr ; private final TextView mSamples ; private final TextView mRecordId ; public ViewHolder ( View rootView ) { mRootView = rootView ; mCellID = ( TextView ) mRootView . findViewById ( R . id . cellID ) ; mLac = ( TextView ) mRootView . findViewById ( R . id . lac ) ; mMcc = ( TextView ) mRootView . findViewById ( R . id . mcc ) ; mMnc = ( TextView ) mRootView . findViewById ( R . id . mnc ) ; mLat = ( TextView ) mRootView . findViewById ( R . id . lat ) ; mLng = ( TextView ) mRootView . findViewById ( R . id . lng ) ; mAvgSigStr = ( TextView ) mRootView . findViewById ( R . id . avgSigStr ) ; mSamples = ( TextView ) mRootView . findViewById ( R . id . samples ) ; mRecordId = ( TextView ) mRootView . findViewById ( R . id . record_id ) ; rootView . setTag ( this ) ; } public void updateDisplay ( CardItemData item ) { mCellID . setText ( item . getCellID ( ) ) ; mLac . setText ( item . getLac ( ) ) ; mMcc . setText ( item . getMcc ( ) ) ; mMnc . setText ( item . getMnc ( ) ) ; mLat . setText ( item . getLat ( ) ) ; mLng . setText ( item . getLng ( ) ) ; mAvgSigStr . setText ( item . getAvgSigStr ( ) ) ; mSamples . setText ( item . getSamples ( ) ) ; mRecordId . setText ( item . getRecordId ( ) ) ; } } }
package com . SecUpwN . AIMSICD . adapters ; import com . SecUpwN . AIMSICD . R ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; public class CellCardInflater implements IAdapterViewInflater < CardItemData > { @ Override public View inflate ( final BaseInflaterAdapter < CardItemData > adapter , final int pos , View convertView , ViewGroup parent ) { ViewHolder holder ; if ( convertView == null ) { LayoutInflater inflater = LayoutInflater . from ( parent . getContext ( ) ) ; convertView = inflater . inflate ( R . layout . cell_items , parent , false ) ; holder = new ViewHolder ( convertView ) ; } else { holder = ( ViewHolder ) convertView . getTag ( ) ; } final CardItemData item = adapter . getTItem ( pos ) ; holder . updateDisplay ( item ) ; return convertView ; } private class ViewHolder { private final View mRootView ; private final TextView mCellID ; private final TextView mPsc ; private final TextView mLac ; private final TextView mMcc ; private final TextView mMnc ; private final TextView mNet ; private final TextView mLat ; private final TextView mLng ; private final TextView mSignal ; private final TextView mRecordId ; public ViewHolder ( View rootView ) { mRootView = rootView ; mCellID = ( TextView ) mRootView . findViewById ( R . id . cellID ) ; mCellID . setVisibility ( View . GONE ) ; mPsc = ( TextView ) mRootView . findViewById ( R . id . psc ) ; mPsc . setVisibility ( View . GONE ) ; mLac = ( TextView ) mRootView . findViewById ( R . id . lac ) ; mLac . setVisibility ( View . GONE ) ; mMcc = ( TextView ) mRootView . findViewById ( R . id . mcc ) ; mMcc . setVisibility ( View . GONE ) ; mMnc = ( TextView ) mRootView . findViewById ( R . id . mnc ) ; mMnc . setVisibility ( View . GONE ) ; mNet = ( TextView ) mRootView . findViewById ( R . id . net ) ; mNet . setVisibility ( View . GONE ) ; mLat = ( TextView ) mRootView . findViewById ( R . id . lat ) ; mLat . setVisibility ( View . GONE ) ; mLng = ( TextView ) mRootView . findViewById ( R . id . lng ) ; mLng . setVisibility ( View . GONE ) ; mSignal = ( TextView ) mRootView . findViewById ( R . id . signal ) ; mSignal . setVisibility ( View . GONE ) ; mRecordId = ( TextView ) mRootView . findViewById ( R . id . record_id ) ; rootView . setTag ( this ) ; } public void updateDisplay ( CardItemData item ) { if ( ! item . getCellID ( ) . contains ( "N/A" ) ) { mCellID . setVisibility ( View . VISIBLE ) ; mCellID . setText ( item . getCellID ( ) ) ; } if ( ! item . getPsc ( ) . contains ( "N/A" ) ) { mPsc . setVisibility ( View . VISIBLE ) ; mPsc . setText ( item . getPsc ( ) ) ; } if ( ! item . getLac ( ) . contains ( "N/A" ) ) { mLac . setVisibility ( View . VISIBLE ) ; mLac . setText ( item . getLac ( ) ) ; } if ( ! item . getNet ( ) . contains ( "N/A" ) ) { mNet . setVisibility ( View . VISIBLE ) ; mNet . setText ( item . getNet ( ) ) ; } if ( ! item . getLat ( ) . contains ( "N/A" ) ) { mLat . setVisibility ( View . VISIBLE ) ; mLat . setText ( item . getLat ( ) ) ; } if ( ! item . getLng ( ) . contains ( "N/A" ) ) { mLng . setVisibility ( View . VISIBLE ) ; mLng . setText ( item . getLng ( ) ) ; } if ( ! item . getMcc ( ) . contains ( "N/A" ) ) { mMcc . setVisibility ( View . VISIBLE ) ; mMcc . setText ( item . getMcc ( ) ) ; } if ( ! item . getMnc ( ) . contains ( "N/A" ) ) { mMnc . setVisibility ( View . VISIBLE ) ; mMnc . setText ( item . getMnc ( ) ) ; } if ( ! item . getSignal ( ) . contains ( "N/A" ) ) { mSignal . setVisibility ( View . VISIBLE ) ; mSignal . setText ( item . getSignal ( ) ) ; } mRecordId . setText ( item . getRecordId ( ) ) ; } } }
package com . SecUpwN . AIMSICD . adapters ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; import com . SecUpwN . AIMSICD . R ; public class MeasuredCellStrengthCardInflater implements IAdapterViewInflater < MeasuredCellStrengthCardData > { @ Override public View inflate ( final BaseInflaterAdapter < MeasuredCellStrengthCardData > adapter , final int pos , View convertView , ViewGroup parent ) { ViewHolder holder ; if ( convertView == null ) { LayoutInflater inflater = LayoutInflater . from ( parent . getContext ( ) ) ; convertView = inflater . inflate ( R . layout . silent_sms_items , parent , false ) ; holder = new ViewHolder ( convertView ) ; } else { holder = ( ViewHolder ) convertView . getTag ( ) ; } final MeasuredCellStrengthCardData item = adapter . getTItem ( pos ) ; holder . updateDisplay ( item ) ; return convertView ; } private class ViewHolder { private final View mRootView ; private final TextView mAddress ; private final TextView mDisplayAddress ; private final TextView mMessageClass ; public ViewHolder ( View rootView ) { mRootView = rootView ; mAddress = ( TextView ) mRootView . findViewById ( R . id . address ) ; mDisplayAddress = ( TextView ) mRootView . findViewById ( R . id . display_address ) ; mMessageClass = ( TextView ) mRootView . findViewById ( R . id . message_class ) ; rootView . setTag ( this ) ; } public void updateDisplay ( MeasuredCellStrengthCardData item ) { mAddress . setText ( item . getCellID ( ) ) ; mDisplayAddress . setText ( item . getSignal ( ) ) ; mMessageClass . setText ( item . getTimestamp ( ) ) ; } } }
package com . SecUpwN . AIMSICD . adapters ; import com . SecUpwN . AIMSICD . R ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; public class DefaultLocationCardInflater implements IAdapterViewInflater < CardItemData > { @ Override public View inflate ( final BaseInflaterAdapter < CardItemData > adapter , final int pos , View convertView , ViewGroup parent ) { ViewHolder holder ; if ( convertView == null ) { LayoutInflater inflater = LayoutInflater . from ( parent . getContext ( ) ) ; convertView = inflater . inflate ( R . layout . default_location_items , parent , false ) ; holder = new ViewHolder ( convertView ) ; } else { holder = ( ViewHolder ) convertView . getTag ( ) ; } final CardItemData item = adapter . getTItem ( pos ) ; holder . updateDisplay ( item ) ; return convertView ; } private class ViewHolder { private final View mRootView ; private final TextView mCountry ; private final TextView mMcc ; private final TextView mLat ; private final TextView mLng ; private final TextView mRecordId ; public ViewHolder ( View rootView ) { mRootView = rootView ; mCountry = ( TextView ) mRootView . findViewById ( R . id . country ) ; mMcc = ( TextView ) mRootView . findViewById ( R . id . mcc ) ; mLat = ( TextView ) mRootView . findViewById ( R . id . lat ) ; mLng = ( TextView ) mRootView . findViewById ( R . id . lng ) ; mRecordId = ( TextView ) mRootView . findViewById ( R . id . record_id ) ; rootView . setTag ( this ) ; } public void updateDisplay ( CardItemData item ) { mCountry . setText ( item . getCountry ( ) ) ; mMcc . setText ( item . getMcc ( ) ) ; mLat . setText ( item . getLat ( ) ) ; mLng . setText ( item . getLng ( ) ) ; mRecordId . setText ( item . getRecordId ( ) ) ; } } }
package com . SecUpwN . AIMSICD . adapters ; import android . view . View ; import android . view . ViewGroup ; import android . widget . BaseAdapter ; import java . util . ArrayList ; import java . util . List ; public class BaseInflaterAdapter < T > extends BaseAdapter { private final List < T > m_items = new ArrayList < > ( ) ; private IAdapterViewInflater < T > m_viewInflater ; public BaseInflaterAdapter ( IAdapterViewInflater < T > viewInflater ) { m_viewInflater = viewInflater ; } public BaseInflaterAdapter ( List < T > items , IAdapterViewInflater < T > viewInflater ) { m_items . addAll ( items ) ; m_viewInflater = viewInflater ; } public void setViewInflater ( IAdapterViewInflater < T > viewInflater , boolean notifyChange ) { m_viewInflater = viewInflater ; if ( notifyChange ) { notifyDataSetChanged ( ) ; } } public void addItem ( T item , boolean notifyChange ) { m_items . add ( item ) ; if ( notifyChange ) { notifyDataSetChanged ( ) ; } } public void addItems ( List < T > items , boolean notifyChange ) { m_items . addAll ( items ) ; if ( notifyChange ) { notifyDataSetChanged ( ) ; } } public void clear ( boolean notifyChange ) { m_items . clear ( ) ; if ( notifyChange ) { notifyDataSetChanged ( ) ; } } @ Override public int getCount ( ) { return m_items . size ( ) ; } @ Override public Object getItem ( int pos ) { return getTItem ( pos ) ; } public T getTItem ( int pos ) { return m_items . get ( pos ) ; } @ Override public long getItemId ( int pos ) { return pos ; } @ Override public View getView ( int pos , View convertView , ViewGroup parent ) { return m_viewInflater != null ? m_viewInflater . inflate ( this , pos , convertView , parent ) : null ; } }
package com . SecUpwN . AIMSICD . adapters ; import android . content . Context ; import android . support . v4 . app . Fragment ; import android . support . v4 . app . FragmentManager ; import android . support . v4 . app . FragmentPagerAdapter ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . fragments . CellInfoFragment ; import com . SecUpwN . AIMSICD . fragments . DbViewerFragment ; import com . SecUpwN . AIMSICD . fragments . DeviceFragment ; public class DetailsPagerAdapter extends FragmentPagerAdapter { Context context ; public DetailsPagerAdapter ( FragmentManager fm , Context context ) { super ( fm ) ; this . context = context ; } @ Override public Fragment getItem ( int position ) { switch ( position ) { case 0 : return new DeviceFragment ( ) ; case 1 : return new CellInfoFragment ( ) ; case 2 : return new DbViewerFragment ( ) ; } return new DeviceFragment ( ) ; } @ Override public long getItemId ( int position ) { switch ( position ) { case 0 : return 4 ; case 1 : return 5 ; case 2 : return 7 ; } return - 1 ; } @ Override public CharSequence getPageTitle ( int position ) { switch ( position ) { case 0 : return context . getString ( R . string . device_info ) ; case 1 : return context . getString ( R . string . cell_info_title ) ; case 2 : return context . getString ( R . string . db_viewer ) ; } return "" ; } @ Override public int getCount ( ) { return 3 ; } }
package com . SecUpwN . AIMSICD . adapters ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ArrayAdapter ; import android . widget . TextView ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . adapters . Holders . ViewTableNameSpinnerHolder ; import com . SecUpwN . AIMSICD . enums . StatesDbViewer ; import java . util . ArrayList ; public class DbViewerSpinnerAdapter extends ArrayAdapter < StatesDbViewer > { public DbViewerSpinnerAdapter ( Context pContext , int pResource ) { super ( pContext , pResource ) ; mDataList = StatesDbViewer . getStates ( ) ; } ArrayList < StatesDbViewer > mDataList ; @ Override public View getView ( int pPosition , View pConvertView , ViewGroup pParent ) { View lView = pConvertView ; ViewTableNameSpinnerHolder lHolder ; if ( lView == null || ( lView . getId ( ) != R . id . item_root_layout && ! ( lView . getTag ( ) instanceof ViewTableNameSpinnerHolder ) ) ) { lView = ( ( LayoutInflater ) getContext ( ) . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ) . inflate ( R . layout . item_spinner_db_viewer , pParent , false ) ; lHolder = setViewHolderToView ( lView ) ; } else { lHolder = ( ViewTableNameSpinnerHolder ) lView . getTag ( ) ; } StatesDbViewer lEntry = mDataList . get ( pPosition ) ; lHolder . name . setText ( lEntry . getDisplayName ( getContext ( ) ) ) ; return lView ; } @ Override public View getDropDownView ( int pPosition , View pConvertView , ViewGroup pParent ) { return getView ( pPosition , pConvertView , pParent ) ; } @ Override public StatesDbViewer getItem ( int position ) { return mDataList . get ( position ) ; } private ViewTableNameSpinnerHolder setViewHolderToView ( View pView ) { ViewTableNameSpinnerHolder lHolder ; lHolder = new ViewTableNameSpinnerHolder ( ) ; lHolder . name = ( TextView ) pView . findViewById ( R . id . item_name ) ; pView . setTag ( lHolder ) ; return lHolder ; } @ Override public int getCount ( ) { return mDataList . size ( ) ; } }
package com . SecUpwN . AIMSICD . adapters ; import java . text . SimpleDateFormat ; public class MeasuredCellStrengthCardData { private final long timestamp ; private final int signal ; private final int cellID ; private SimpleDateFormat formatter = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; public MeasuredCellStrengthCardData ( int cellID , int signal , long timestamp ) { this . cellID = cellID ; this . signal = signal ; this . timestamp = timestamp ; } public String getCellID ( ) { return "CID: " + cellID + " (0x" + Integer . toHexString ( cellID ) + ")" ; } public String getSignal ( ) { return "RSS: " + signal + " dBm" ; } public String getTimestamp ( ) { return "Timestamp: " + formatter . format ( timestamp ) ; } }
package com . SecUpwN . AIMSICD . adapters ; public class EventLogItemData { private final String mTimestamp ; private final String mCellID ; private final String mLac ; private final String mPsc ; private final String mLat ; private final String mLng ; private final String mgpsd_accu ; private final String mDF_id ; private final String mDF_desc ; private final String mRecordId ; private boolean mIsFakeData ; public EventLogItemData ( String time , String LAC , String CID , String PSC , String gpsd_lat , String gpsd_lon , String gpsd_accu , String DF_id , String DF_desc , String recordId ) { this ( time , LAC , CID , PSC , gpsd_lat , gpsd_lon , gpsd_accu , DF_id , DF_desc , recordId , false ) ; } public EventLogItemData ( String pTime , String pLAC , String pCID , String pPSC , String pGpsd_lat , String pGpsd_lon , String pGpsd_accu , String pDF_id , String pDF_desc , String pRecordId , boolean pIsFakeData ) { mTimestamp = pTime ; mLac = pLAC ; mCellID = pCID ; mPsc = pPSC ; mLat = pGpsd_lat ; mLng = pGpsd_lon ; mgpsd_accu = pGpsd_accu ; mDF_id = pDF_id ; mDF_desc = pDF_desc ; mRecordId = pRecordId ; mIsFakeData = pIsFakeData ; } public String getTimestamp ( ) { return mTimestamp ; } public String getCellID ( ) { return mCellID ; } public String getLac ( ) { return mLac ; } public String getPsc ( ) { return mPsc ; } public String getLat ( ) { return mLat ; } public String getLng ( ) { return mLng ; } public String getgpsd_accu ( ) { return mgpsd_accu ; } public String getDF_id ( ) { return mDF_id ; } public String getDF_desc ( ) { return mDF_desc ; } public String getRecordId ( ) { return mRecordId ; } public boolean isFakeData ( ) { return mIsFakeData ; } public void setIsFakeData ( boolean pIsFakeData ) { mIsFakeData = pIsFakeData ; } }
package com . stericson . RootShell . execution ; import android . content . Context ; public class JavaCommand extends Command { public JavaCommand ( int id , Context context , String ... command ) { super ( id , command ) ; this . context = context ; this . javaCommand = true ; } public JavaCommand ( int id , boolean handlerEnabled , Context context , String ... command ) { super ( id , handlerEnabled , command ) ; this . context = context ; this . javaCommand = true ; } public JavaCommand ( int id , int timeout , Context context , String ... command ) { super ( id , timeout , command ) ; this . context = context ; this . javaCommand = true ; } @ Override public void commandOutput ( int id , String line ) { super . commandOutput ( id , line ) ; } @ Override public void commandTerminated ( int id , String reason ) { } @ Override public void commandCompleted ( int id , int exitCode ) { } }
package com . SecUpwN . AIMSICD . adapters ; import com . SecUpwN . AIMSICD . AIMSICD ; import com . SecUpwN . AIMSICD . constants . Examples ; import com . SecUpwN . AIMSICD . utils . Cell ; import com . SecUpwN . AIMSICD . utils . CMDProcessor ; import com . SecUpwN . AIMSICD . constants . Examples . EVENT_LOG_DATA ; import android . content . ContentValues ; import android . content . Context ; import android . content . SharedPreferences ; import android . content . res . AssetManager ; import android . database . Cursor ; import android . database . SQLException ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . os . Bundle ; import android . os . Environment ; import android . util . Log ; import android . util . SparseArray ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import au . com . bytecode . opencsv . CSVReader ; import au . com . bytecode . opencsv . CSVWriter ; public class AIMSICDDbAdapter { public static String FOLDER ; public static final int DATABASE_VERSION = 9 ; private final Boolean MONO_DB_DUMP = true ; private final String TAG = "AIMSICD" ; private final String mTAG = "DbAdapter" ; private final String DB_NAME = "aimsicd.db" ; private static final String COLUMN_ID = "_id" ; private final String LOCATION_TABLE = "locationinfo" ; private final String CELL_TABLE = "cellinfo" ; private final String OPENCELLID_TABLE = "opencellid" ; private final String TABLE_DEFAULT_MCC = "defaultlocation" ; private final String SILENT_SMS_TABLE = "silentsms" ; private final String CELL_SIGNAL_TABLE = "cellSignal" ; private final String TABLE_EVENTLOG = "EventLog" ; private final String [ ] mTables ; private final DbHelper mDbHelper ; private SQLiteDatabase mDb ; private final Context mContext ; private Cursor signalStrengthMeasurementDatA ; public AIMSICDDbAdapter ( Context context ) { mContext = context ; FOLDER = mContext . getExternalFilesDir ( null ) + File . separator ; mDbHelper = new DbHelper ( context ) ; mTables = new String [ ] { LOCATION_TABLE , CELL_TABLE , OPENCELLID_TABLE , SILENT_SMS_TABLE , TABLE_EVENTLOG , } ; } public AIMSICDDbAdapter open ( ) throws SQLException { mDb = mDbHelper . getWritableDatabase ( ) ; return this ; } public void close ( ) { mDbHelper . close ( ) ; } public long insertSilentSms ( Bundle bundle ) { ContentValues smsValues = new ContentValues ( ) ; smsValues . put ( "Address" , bundle . getString ( "address" ) ) ; smsValues . put ( "Display" , bundle . getString ( "display_address" ) ) ; smsValues . put ( "Class" , bundle . getString ( "class" ) ) ; smsValues . put ( "ServiceCtr" , bundle . getString ( "service_centre" ) ) ; smsValues . put ( "Message" , bundle . getString ( "message" ) ) ; return mDb . insert ( SILENT_SMS_TABLE , null , smsValues ) ; } public long insertCell ( int lac , int cellID , int netType , double latitude , double longitude , int signalInfo , int mcc , int mnc , double accuracy , double speed , double direction , String networkType , long measurementTaken ) { if ( cellID != - 1 && ( latitude != 0.0 && longitude != 0.0 ) ) { ContentValues cellValues = new ContentValues ( ) ; cellValues . put ( "Lac" , lac ) ; cellValues . put ( "CellID" , cellID ) ; cellValues . put ( "Net" , netType ) ; cellValues . put ( "Lat" , latitude ) ; cellValues . put ( "Lng" , longitude ) ; cellValues . put ( "Signal" , signalInfo ) ; cellValues . put ( "Mcc" , mcc ) ; cellValues . put ( "Mnc" , mnc ) ; cellValues . put ( "Accuracy" , accuracy ) ; cellValues . put ( "Speed" , speed ) ; cellValues . put ( "Direction" , direction ) ; cellValues . put ( "NetworkType" , networkType ) ; cellValues . put ( "MeasurementTaken" , measurementTaken ) ; if ( cellExists ( cellID ) ) { Log . v ( TAG , mTAG + ": Cell info updated in local db: " + cellID ) ; return mDb . update ( CELL_TABLE , cellValues , "CellID=?" , new String [ ] { Integer . toString ( cellID ) } ) ; } else { Log . v ( TAG , mTAG + ": New Cell found, insert into local db:: " + cellID ) ; return mDb . insert ( CELL_TABLE , null , cellValues ) ; } } return 0 ; } public long insertCell ( Cell cell ) { if ( cell . getCID ( ) != Integer . MAX_VALUE && ( cell . getLat ( ) != 0.0 && cell . getLon ( ) != 0.0 ) ) { ContentValues cellValues = new ContentValues ( ) ; cellValues . put ( "Lac" , cell . getLAC ( ) ) ; cellValues . put ( "CellID" , cell . getCID ( ) ) ; cellValues . put ( "Net" , cell . getNetType ( ) ) ; cellValues . put ( "Lat" , cell . getLat ( ) ) ; cellValues . put ( "Lng" , cell . getLon ( ) ) ; cellValues . put ( "Signal" , cell . getDBM ( ) ) ; cellValues . put ( "Mcc" , cell . getMCC ( ) ) ; cellValues . put ( "Mnc" , cell . getMNC ( ) ) ; cellValues . put ( "Accuracy" , cell . getAccuracy ( ) ) ; cellValues . put ( "Speed" , cell . getSpeed ( ) ) ; cellValues . put ( "Direction" , cell . getBearing ( ) ) ; cellValues . put ( "MeasurementTaken" , cell . getTimestamp ( ) ) ; if ( cellExists ( cell . getCID ( ) ) ) { Log . v ( TAG , mTAG + ": CID info updated in local db (DBi): " + cell . getCID ( ) ) ; return mDb . update ( CELL_TABLE , cellValues , "CellID=?" , new String [ ] { Integer . toString ( cell . getCID ( ) ) } ) ; } else { Log . v ( TAG , mTAG + ": New CID found, insert into local db (DBi):: " + cell . getCID ( ) ) ; return mDb . insert ( CELL_TABLE , null , cellValues ) ; } } return 0 ; } long insertOpenCell ( double latitude , double longitude , int mcc , int mnc , int lac , int cellID , int avgSigStr , int range , int samples , int isGPSexact , String RAT ) { return insertOpenCell ( latitude , longitude , mcc , mnc , lac , cellID , avgSigStr , range , samples , isGPSexact , RAT , true ) ; } long insertOpenCell ( double latitude , double longitude , int mcc , int mnc , int lac , int cellID , int avgSigStr , int range , int samples , int isGPSexact , String RAT , boolean isNeedCheckExists ) { ContentValues cellIDValues = new ContentValues ( ) ; cellIDValues . put ( "Lat" , latitude ) ; cellIDValues . put ( "Lng" , longitude ) ; cellIDValues . put ( "Mcc" , mcc ) ; cellIDValues . put ( "Mnc" , mnc ) ; cellIDValues . put ( "Lac" , lac ) ; cellIDValues . put ( "CellID" , cellID ) ; cellIDValues . put ( "AvgSigStr" , avgSigStr ) ; cellIDValues . put ( "avg_range" , range ) ; cellIDValues . put ( "Samples" , samples ) ; cellIDValues . put ( "isGPSexact" , isGPSexact ) ; cellIDValues . put ( "Type" , RAT ) ; if ( isNeedCheckExists && openCellExists ( cellID ) ) { Log . v ( TAG , mTAG + ": CID already found in DBe_import! Skipping: " + cellID ) ; return 1 ; } else { return mDb . insert ( OPENCELLID_TABLE , null , cellIDValues ) ; } } public long insertLocation ( int lac , int cellID , int netType , double latitude , double longitude , int signalInfo , String cellInfo ) { if ( latitude != 0.0 && longitude != 0.0 ) { ContentValues locationValues = new ContentValues ( ) ; locationValues . put ( "Lac" , lac ) ; locationValues . put ( "CellID" , cellID ) ; locationValues . put ( "Net" , netType ) ; locationValues . put ( "Lat" , latitude ) ; locationValues . put ( "Lng" , longitude ) ; locationValues . put ( "Signal" , signalInfo ) ; locationValues . put ( "Connection" , cellInfo ) ; if ( locationExists ( cellID , latitude , longitude , signalInfo ) ) { return mDb . update ( LOCATION_TABLE , locationValues , "CellID=?" , new String [ ] { Integer . toString ( cellID ) } ) ; } else { return mDb . insert ( LOCATION_TABLE , null , locationValues ) ; } } return 0 ; } public int deleteCell ( int cellId ) { Log . i ( TAG , mTAG + ": Deleted CID: " + cellId ) ; return mDb . delete ( CELL_TABLE , "CellID = ?" , new String [ ] { String . valueOf ( cellId ) } ) ; } public long insertDetection ( int LAC , int CID , int PSC , double latitude , double longitude , double accu , int DF_id , String DF_description ) { ContentValues detectionValues = new ContentValues ( ) ; detectionValues . put ( "LAC" , LAC ) ; detectionValues . put ( "CID" , CID ) ; detectionValues . put ( "PSC" , PSC ) ; detectionValues . put ( "gpsd_lat" , latitude ) ; detectionValues . put ( "gpsd_lon" , longitude ) ; detectionValues . put ( "gpsd_accu" , accu ) ; detectionValues . put ( "DF_id" , DF_id ) ; detectionValues . put ( "DF_description" , DF_description ) ; Log . v ( TAG , mTAG + ": Insert Detection into EventLog Table: " + CID ) ; return mDb . insert ( TABLE_EVENTLOG , null , detectionValues ) ; } public Cursor getEventLogData ( ) { return mDb . query ( TABLE_EVENTLOG , new String [ ] { "time" , "LAC" , "CID" , "PSC" , "gpsd_lat" , "gpsd_lon" , "gpsd_accu" , "DF_id" , "DF_desc" } , null , null , null , null , null ) ; } public Cursor getSilentSmsData ( ) { return mDb . query ( SILENT_SMS_TABLE , new String [ ] { "Address" , "Display" , "Class" , "ServiceCtr" , "Message" , "Timestamp" } , null , null , null , null , COLUMN_ID + " DESC" ) ; } public Cursor getCellData ( ) { return mDb . query ( CELL_TABLE , new String [ ] { "CellID" , "Lac" , "Net" , "Lat" , "Lng" , "Signal" , "Mcc" , "Mnc" , "Accuracy" , "Speed" , "Direction" } , null , null , null , null , null ) ; } public Cursor getOPCIDSubmitData ( ) { return mDb . query ( CELL_TABLE , new String [ ] { "Mcc" , "Mnc" , "Lac" , "CellID" , "Lng" , "Lat" , "Signal" , "Timestamp" , "Accuracy" , "Speed" , "Direction" , "NetworkType" } , "OCID_SUBMITTED <> 1" , null , null , null , null ) ; } public Cursor getLocationData ( ) { return mDb . query ( LOCATION_TABLE , new String [ ] { "CellID" , "Lac" , "Net" , "Lat" , "Lng" , "Signal" } , null , null , null , null , null ) ; } public Cursor getOpenCellIDData ( ) { return mDb . query ( OPENCELLID_TABLE , new String [ ] { "CellID" , "Lac" , "Mcc" , "Mnc" , "Lat" , "Lng" , "AvgSigStr" , "Samples" } , null , null , null , null , null ) ; } public Cursor getDefaultMccLocationData ( ) { return mDb . query ( TABLE_DEFAULT_MCC , new String [ ] { "Country" , "Mcc" , "Lat" , "Lng" } , null , null , null , null , null ) ; } boolean locationExists ( int cellID , double lat , double lng , int signal ) { Cursor cursor = mDb . rawQuery ( "SELECT * FROM " + LOCATION_TABLE + " WHERE CellID = " + cellID + " AND Lat = " + lat + " AND Lng = " + lng + " AND Signal = " + signal , null ) ; boolean exists = cursor . getCount ( ) > 0 ; cursor . close ( ) ; return exists ; } boolean cellExists ( int cellID ) { Cursor cursor = mDb . rawQuery ( "SELECT 1 FROM " + CELL_TABLE + " WHERE CellID = " + cellID , null ) ; boolean exists = cursor . getCount ( ) > 0 ; cursor . close ( ) ; return exists ; } public boolean openCellExists ( int cellID ) { Cursor cursor = mDb . rawQuery ( "SELECT * FROM " + OPENCELLID_TABLE + " WHERE CellID = " + cellID , null ) ; boolean exists = cursor . getCount ( ) > 0 ; cursor . close ( ) ; return exists ; } public boolean checkLAC ( Cell cell ) { Cursor cursor = mDb . query ( CELL_TABLE , new String [ ] { "CellID" , "Lac" , "Net" , "Lat" , "Lng" , "Signal" , "Mcc" , "Mnc" , "Accuracy" , "Speed" , "Direction" , "Timestamp" } , "CellID=" + cell . getCID ( ) , null , null , null , null ) ; while ( cursor . moveToNext ( ) ) { if ( cell . getLAC ( ) != cursor . getInt ( 1 ) ) { Log . i ( TAG , "ALERT: Changing LAC on CID: " + cell . getCID ( ) + " LAC(API): " + cell . getLAC ( ) + " LAC(DBi): " + cursor . getInt ( 1 ) ) ; insertDetection ( cell . getLAC ( ) , cell . getCID ( ) , cell . getPSC ( ) , cursor . getDouble ( 3 ) , cursor . getDouble ( 4 ) , cursor . getInt ( 8 ) , 1 , "Changing LAC" ) ; cursor . close ( ) ; return false ; } else { Log . v ( TAG , "LAC checked - no change on CID:" + cell . getCID ( ) + " LAC(API): " + cell . getLAC ( ) + " LAC(DBi): " + cursor . getInt ( 1 ) ) ; } } cursor . close ( ) ; return true ; } public void ocidProcessed ( ) { ContentValues ocidValues = new ContentValues ( ) ; ocidValues . put ( "OCID_SUBMITTED" , 1 ) ; mDb . update ( CELL_TABLE , ocidValues , "OCID_SUBMITTED<>?" , new String [ ] { "1" } ) ; } public double [ ] getDefaultLocation ( int mcc ) { double [ ] loc = new double [ 2 ] ; Cursor cursor = mDb . rawQuery ( "SELECT Lat, Lng FROM " + TABLE_DEFAULT_MCC + " WHERE Mcc = " + mcc , null ) ; if ( cursor . moveToFirst ( ) ) { loc [ 0 ] = Double . parseDouble ( cursor . getString ( 0 ) ) ; loc [ 1 ] = Double . parseDouble ( cursor . getString ( 1 ) ) ; } else { loc [ 0 ] = 0.0 ; loc [ 1 ] = 0.0 ; } cursor . close ( ) ; return loc ; } public void cleanseCellTable ( ) { mDb . execSQL ( "DELETE FROM " + CELL_TABLE + " WHERE " + COLUMN_ID + " NOT IN (SELECT MAX(" + COLUMN_ID + ") FROM " + CELL_TABLE + " GROUP BY CellID)" ) ; mDb . execSQL ( "DELETE FROM " + CELL_TABLE + " WHERE CellID = " + Integer . MAX_VALUE + " OR CellID = -1" ) ; } public boolean prepareOpenCellUploadData ( ) { boolean result ; File dir = new File ( FOLDER + "OpenCellID/" ) ; if ( ! dir . exists ( ) ) { result = dir . mkdirs ( ) ; if ( ! result ) { return false ; } } File file = new File ( dir , "aimsicd-ocid-data.csv" ) ; try { open ( ) ; Cursor c = getOPCIDSubmitData ( ) ; if ( c . getCount ( ) > 0 ) { if ( ! file . exists ( ) ) { result = file . createNewFile ( ) ; if ( ! result ) { c . close ( ) ; return false ; } CSVWriter csvWrite = new CSVWriter ( new FileWriter ( file ) ) ; csvWrite . writeNext ( "mcc,mnc,lac,cellid,lon,lat,signal,measured_at,rating,speed,direction,act" ) ; String [ ] rowData = new String [ c . getColumnCount ( ) ] ; int size = c . getColumnCount ( ) ; AIMSICD . mProgressBar . setProgress ( 0 ) ; AIMSICD . mProgressBar . setMax ( size ) ; while ( c . moveToNext ( ) ) { for ( int i = 0 ; i < size ; i ++ ) { rowData [ i ] = c . getString ( i ) ; AIMSICD . mProgressBar . setProgress ( i ) ; } csvWrite . writeNext ( rowData ) ; } csvWrite . close ( ) ; c . close ( ) ; } return true ; } return false ; } catch ( Exception e ) { Log . e ( TAG , mTAG + ": Error creating OpenCellID Upload Data: " + e ) ; return false ; } finally { AIMSICD . mProgressBar . setProgress ( 0 ) ; } } private void populateDefaultMCC ( SQLiteDatabase db ) { AssetManager mngr = mContext . getAssets ( ) ; InputStream csvDefaultMcc ; FileOutputStream fout ; try { csvDefaultMcc = mngr . open ( "default_mcc_locations.csv" ) ; File tempfile = File . createTempFile ( "tempFile" , ".tmp" ) ; tempfile . deleteOnExit ( ) ; fout = new FileOutputStream ( tempfile ) ; byte [ ] buf = new byte [ 1024 ] ; int len ; while ( ( len = csvDefaultMcc . read ( buf ) ) != - 1 ) { fout . write ( buf , 0 , len ) ; } fout . close ( ) ; csvDefaultMcc . close ( ) ; CSVReader csvReader = new CSVReader ( new FileReader ( tempfile ) ) ; List < String [ ] > csvMcc = csvReader . readAll ( ) ; ContentValues defaultMccValues = new ContentValues ( ) ; for ( int i = 1 ; i < csvMcc . size ( ) ; i ++ ) { defaultMccValues . put ( "Country" , csvMcc . get ( i ) [ 0 ] ) ; defaultMccValues . put ( "Mcc" , csvMcc . get ( i ) [ 1 ] ) ; defaultMccValues . put ( "Lng" , csvMcc . get ( i ) [ 2 ] ) ; defaultMccValues . put ( "Lat" , csvMcc . get ( i ) [ 3 ] ) ; db . insert ( TABLE_DEFAULT_MCC , null , defaultMccValues ) ; } } catch ( Exception e ) { Log . e ( TAG , mTAG + ": Error populating Default MCC Data: " + e ) ; } } public boolean updateOpenCellID ( ) { String fileName = Environment . getExternalStorageDirectory ( ) + "/AIMSICD/OpenCellID/opencellid.csv" ; File file = new File ( fileName ) ; try { if ( file . exists ( ) ) { CSVReader csvReader = new CSVReader ( new FileReader ( file ) ) ; List < String [ ] > csvCellID = new ArrayList < > ( ) ; String next [ ] ; while ( ( next = csvReader . readNext ( ) ) != null ) { csvCellID . add ( next ) ; } if ( ! csvCellID . isEmpty ( ) ) { int lines = csvCellID . size ( ) ; Log . i ( TAG , mTAG + ":updateOpenCellID: OCID CSV size (lines): " + lines ) ; String lQuery = "SELECT CellID, COUNT(CellID) FROM " + OPENCELLID_TABLE + " GROUP BY CellID;" ; Cursor lCursor = mDb . rawQuery ( lQuery , null ) ; SparseArray < Boolean > lPresentCellID = new SparseArray < > ( ) ; if ( lCursor . getCount ( ) > 0 ) { while ( lCursor . moveToNext ( ) ) { lPresentCellID . put ( lCursor . getInt ( 0 ) , true ) ; } } lCursor . close ( ) ; AIMSICD . mProgressBar . setProgress ( 0 ) ; AIMSICD . mProgressBar . setMax ( lines ) ; for ( int i = 1 ; i < lines ; i ++ ) { AIMSICD . mProgressBar . setProgress ( i ) ; if ( lPresentCellID . get ( Integer . parseInt ( csvCellID . get ( i ) [ 5 ] ) , false ) ) { continue ; } insertOpenCell ( Double . parseDouble ( csvCellID . get ( i ) [ 0 ] ) , Double . parseDouble ( csvCellID . get ( i ) [ 1 ] ) , Integer . parseInt ( csvCellID . get ( i ) [ 2 ] ) , Integer . parseInt ( csvCellID . get ( i ) [ 3 ] ) , Integer . parseInt ( csvCellID . get ( i ) [ 4 ] ) , Integer . parseInt ( csvCellID . get ( i ) [ 5 ] ) , Integer . parseInt ( csvCellID . get ( i ) [ 6 ] ) , Integer . parseInt ( csvCellID . get ( i ) [ 7 ] ) , Integer . parseInt ( csvCellID . get ( i ) [ 8 ] ) , Integer . parseInt ( csvCellID . get ( i ) [ 9 ] ) , String . valueOf ( csvCellID . get ( i ) [ 10 ] ) , false ) ; } } } return true ; } catch ( Exception e ) { Log . e ( TAG , mTAG + ": Error parsing OpenCellID data: " + e . getMessage ( ) ) ; return false ; } finally { AIMSICD . mProgressBar . setProgress ( 0 ) ; } } public boolean restoreDB ( ) { try { for ( String table : mTables ) { File file = new File ( FOLDER + "aimsicd-" + table + ".csv" ) ; if ( file . exists ( ) ) { List < String [ ] > records = new ArrayList < > ( ) ; String next [ ] ; CSVReader csvReader = new CSVReader ( new FileReader ( file ) ) ; while ( ( next = csvReader . readNext ( ) ) != null ) { records . add ( next ) ; } if ( ! records . isEmpty ( ) ) { int lines = records . size ( ) ; AIMSICD . mProgressBar . setMax ( lines ) ; AIMSICD . mProgressBar . setProgress ( 0 ) ; for ( int i = 1 ; i < lines ; i ++ ) { AIMSICD . mProgressBar . setProgress ( i ) ; switch ( table ) { case CELL_TABLE : insertCell ( Integer . parseInt ( records . get ( i ) [ 1 ] ) , Integer . parseInt ( records . get ( i ) [ 2 ] ) , Integer . parseInt ( records . get ( i ) [ 3 ] ) , Double . parseDouble ( records . get ( i ) [ 4 ] ) , Double . parseDouble ( records . get ( i ) [ 5 ] ) , Integer . parseInt ( records . get ( i ) [ 6 ] ) , Integer . valueOf ( records . get ( i ) [ 7 ] ) , Integer . valueOf ( records . get ( i ) [ 8 ] ) , Double . valueOf ( records . get ( i ) [ 9 ] ) , Double . valueOf ( records . get ( i ) [ 10 ] ) , Double . valueOf ( records . get ( i ) [ 11 ] ) , String . valueOf ( records . get ( i ) [ 12 ] ) , Long . valueOf ( records . get ( i ) [ 13 ] ) ) ; break ; case LOCATION_TABLE : insertLocation ( Integer . parseInt ( records . get ( i ) [ 1 ] ) , Integer . parseInt ( records . get ( i ) [ 2 ] ) , Integer . parseInt ( records . get ( i ) [ 3 ] ) , Double . parseDouble ( records . get ( i ) [ 4 ] ) , Double . parseDouble ( records . get ( i ) [ 5 ] ) , Integer . parseInt ( records . get ( i ) [ 6 ] ) , String . valueOf ( records . get ( i ) [ 7 ] ) ) ; break ; case OPENCELLID_TABLE : insertOpenCell ( Double . parseDouble ( records . get ( i ) [ 1 ] ) , Double . parseDouble ( records . get ( i ) [ 2 ] ) , Integer . parseInt ( records . get ( i ) [ 3 ] ) , Integer . parseInt ( records . get ( i ) [ 4 ] ) , Integer . parseInt ( records . get ( i ) [ 5 ] ) , Integer . parseInt ( records . get ( i ) [ 6 ] ) , Integer . parseInt ( records . get ( i ) [ 7 ] ) , Integer . parseInt ( records . get ( i ) [ 8 ] ) , Integer . parseInt ( records . get ( i ) [ 9 ] ) , Integer . parseInt ( records . get ( i ) [ 10 ] ) , String . valueOf ( records . get ( i ) [ 11 ] ) ) ; break ; case SILENT_SMS_TABLE : Bundle bundle = new Bundle ( ) ; bundle . putString ( "address" , String . valueOf ( records . get ( i ) [ 1 ] ) ) ; bundle . putString ( "display_address" , String . valueOf ( records . get ( i ) [ 2 ] ) ) ; bundle . putString ( "message_class" , String . valueOf ( records . get ( i ) [ 3 ] ) ) ; bundle . putString ( "service_centre" , String . valueOf ( records . get ( i ) [ 4 ] ) ) ; bundle . putString ( "message" , String . valueOf ( records . get ( i ) [ 5 ] ) ) ; insertSilentSms ( bundle ) ; break ; } } } } } return true ; } catch ( Exception e ) { Log . e ( TAG , mTAG + ": restoreDB() " + e ) ; return false ; } finally { AIMSICD . mProgressBar . setProgress ( 0 ) ; } } private void dumpDB ( ) { File dumpdir = new File ( FOLDER ) ; File file = new File ( dumpdir , "aimsicd_dump.db" ) ; String aimdir = "/data/data/com.SecUpwN.AIMSICD/databases/" ; String execString = "/system/xbin/sqlite3 " + aimdir + "aimsicd.db '.backup " + file + "'" ; try { Log . i ( TAG , mTAG + ":dumpDB() Attempting to dump DB to: " + file + "\nUsing: \"" + execString + "\"\n" ) ; CMDProcessor . runSuCommand ( execString ) ; } catch ( Exception e ) { Log . e ( TAG , mTAG + ":dumpDB() Failed to export DB dump file: " + e ) ; } Log . i ( TAG , mTAG + ":dumpDB() Database dumped to: " + file ) ; } public boolean backupDB ( ) { try { for ( String table : mTables ) { backup ( table ) ; } if ( MONO_DB_DUMP ) { dumpDB ( ) ; } return true ; } catch ( Exception ioe ) { Log . e ( TAG , mTAG + ":backupDB() Error: " + ioe ) ; return false ; } } private void backup ( String tableName ) { Log . i ( TAG , mTAG + ": Database Backup: " + DB_NAME ) ; File dir = new File ( FOLDER ) ; if ( ! dir . exists ( ) ) { dir . mkdirs ( ) ; } File file = new File ( dir , "aimsicd-" + tableName + ".csv" ) ; try { file . createNewFile ( ) ; CSVWriter csvWrite = new CSVWriter ( new FileWriter ( file ) ) ; Log . d ( TAG , mTAG + ": table name " + tableName ) ; open ( ) ; Cursor c = mDb . rawQuery ( "SELECT * FROM " + tableName , new String [ 0 ] ) ; csvWrite . writeNext ( c . getColumnNames ( ) ) ; String [ ] rowData = new String [ c . getColumnCount ( ) ] ; int size = c . getColumnCount ( ) ; AIMSICD . mProgressBar . setProgress ( 0 ) ; AIMSICD . mProgressBar . setMax ( size ) ; while ( c . moveToNext ( ) ) { for ( int i = 0 ; i < size ; i ++ ) { rowData [ i ] = c . getString ( i ) ; AIMSICD . mProgressBar . setProgress ( i ) ; } csvWrite . writeNext ( rowData ) ; } csvWrite . close ( ) ; c . close ( ) ; } catch ( Exception e ) { Log . e ( TAG , mTAG + ": Error exporting table: " + tableName + " " + e ) ; } finally { AIMSICD . mProgressBar . setProgress ( 0 ) ; } Log . i ( TAG , mTAG + ": Database Export complete." ) ; } public void checkDBe ( ) { int tf_settings = 30 ; int min_gps_precision = 50 ; String sqlq ; Log . d ( TAG , mTAG + ":checkDBe() Attempting to delete bad import data from DBe_import table..." ) ; sqlq = "DELETE FROM " + OPENCELLID_TABLE + " WHERE Samples < 1" ; mDb . execSQL ( sqlq ) ; sqlq = "DELETE FROM " + OPENCELLID_TABLE + " WHERE Lac < 1" ; mDb . execSQL ( sqlq ) ; sqlq = "DELETE FROM " + OPENCELLID_TABLE + " WHERE Lac > 65534" ; mDb . execSQL ( sqlq ) ; sqlq = "DELETE FROM " + OPENCELLID_TABLE + " WHERE CellID < 1" ; mDb . execSQL ( sqlq ) ; sqlq = "DELETE FROM " + OPENCELLID_TABLE + " WHERE CellID > 268435455" ; mDb . execSQL ( sqlq ) ; Log . i ( TAG , mTAG + ":checkDBe() Deleted BTS entries from DBe_import table with bad LAC/CID..." ) ; } public void cleanseCellStrengthTables ( long maxTime ) { Log . d ( TAG , mTAG + ": Cleaning " + CELL_SIGNAL_TABLE + " WHERE timestamp < " + maxTime ) ; mDb . execSQL ( "DELETE FROM " + CELL_SIGNAL_TABLE + " WHERE timestamp < " + maxTime ) ; } public void addSignalStrength ( int cellID , int signal , Long timestamp ) { ContentValues row = new ContentValues ( ) ; row . put ( "cellID" , cellID ) ; row . put ( "signal" , signal ) ; row . put ( "timestamp" , timestamp ) ; mDb . insert ( CELL_SIGNAL_TABLE , null , row ) ; } public int countSignalMeasurements ( int cellID ) { Cursor c = mDb . rawQuery ( "SELECT COUNT(cellID) FROM " + CELL_SIGNAL_TABLE + " WHERE cellID=" + cellID , new String [ 0 ] ) ; c . moveToFirst ( ) ; int lAnswer = c . getInt ( 0 ) ; c . close ( ) ; return lAnswer ; } public int getAverageSignalStrength ( int cellID ) { Cursor c = mDb . rawQuery ( "SELECT AVG(signal) FROM " + CELL_SIGNAL_TABLE + " WHERE cellID=" + cellID , new String [ 0 ] ) ; c . moveToFirst ( ) ; int lAnswer = c . getInt ( 0 ) ; c . close ( ) ; return lAnswer ; } public Cursor getSignalStrengthMeasurementData ( ) { return mDb . rawQuery ( "SELECT cellID, signal, timestamp FROM " + CELL_SIGNAL_TABLE + " ORDER BY timestamp DESC" , new String [ 0 ] ) ; } public class DbHelper extends SQLiteOpenHelper { DbHelper ( Context context ) { super ( context , DB_NAME , null , DATABASE_VERSION ) ; } @ Override public void onCreate ( SQLiteDatabase database ) { database . execSQL ( "CREATE TABLE " + CELL_SIGNAL_TABLE + " (" + COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + "cellID INTEGER, signal INTEGER, " + "timestamp INTEGER);" ) ; database . execSQL ( "CREATE INDEX cellID_index ON " + CELL_SIGNAL_TABLE + " (cellID);" ) ; database . execSQL ( "CREATE INDEX cellID_timestamp ON " + CELL_SIGNAL_TABLE + " (timestamp);" ) ; String SMS_DATABASE_CREATE = "CREATE TABLE " + SILENT_SMS_TABLE + " (" + COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + "Address VARCHAR, " + "Display VARCHAR, " + "Class VARCHAR, " + "ServiceCtr VARCHAR, " + "Message VARCHAR, " + "Timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP);" ; database . execSQL ( SMS_DATABASE_CREATE ) ; String ZeroSMS = "INSERT INTO " + SILENT_SMS_TABLE + " (Address,Display,Class,ServiceCtr,Message) " + "VALUES ('" + Examples . SILENT_SMS_CARD_DATA . ADDRESS + "','" + Examples . SILENT_SMS_CARD_DATA . DISPLAY + "','CLAZZ','SMSC','DaTestMessage');" ; database . execSQL ( ZeroSMS ) ; String LOC_DATABASE_CREATE = "CREATE TABLE " + LOCATION_TABLE + " (" + COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + "Lac INTEGER, CellID INTEGER, " + "Net VARCHAR, " + "Lat VARCHAR, " + "Lng VARCHAR, " + "Signal INTEGER, " + "Connection VARCHAR, " + "Timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP);" ; database . execSQL ( LOC_DATABASE_CREATE ) ; String CELL_DATABASE_CREATE = "CREATE TABLE " + CELL_TABLE + " (" + COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + "Lac INTEGER, " + "CellID INTEGER, " + "Net INTEGER, " + "Lat VARCHAR, " + "Lng VARCHAR, " + "Signal INTEGER, " + "Mcc INTEGER, " + "Mnc INTEGER, " + "Accuracy REAL, " + "Speed REAL, " + "Direction REAL, " + "NetworkType VARCHAR, " + "MeasurementTaken VARCHAR, " + "OCID_SUBMITTED INTEGER DEFAULT 0, " + "Timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP);" ; database . execSQL ( CELL_DATABASE_CREATE ) ; String OPENCELLID_DATABASE_CREATE = "CREATE TABLE " + OPENCELLID_TABLE + " (" + COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + "Lat VARCHAR, " + "Lng VARCHAR, " + "Mcc INTEGER, " + "Mnc INTEGER, " + "Lac INTEGER, " + "CellID INTEGER, " + "AvgSigStr INTEGER, " + "avg_range INTEGER, " + "Samples INTEGER, " + "isGPSexact INTEGER, " + "Type TEXT, " + "Timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP" + ");" ; database . execSQL ( OPENCELLID_DATABASE_CREATE ) ; String DEFAULT_MCC_DATABASE_CREATE = "CREATE TABLE " + TABLE_DEFAULT_MCC + " (" + COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + "Country VARCHAR, " + "Mcc INTEGER, " + "Lat VARCHAR, " + "Lng VARCHAR);" ; database . execSQL ( DEFAULT_MCC_DATABASE_CREATE ) ; String TABLE_EVENTLOG_CREATE = "CREATE TABLE " + TABLE_EVENTLOG + " (" + COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT," + "time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP," + "LAC INTEGER NOT NULL," + "CID INTEGER NOT NULL," + "PSC INTEGER," + "gpsd_lat REAL," + "gpsd_lon REAL," + "gpsd_accu INTEGER," + "DF_id INTEGER," + "DF_desc TEXT" + ");" ; database . execSQL ( TABLE_EVENTLOG_CREATE ) ; String ZeroEvent = "INSERT INTO " + TABLE_EVENTLOG + " (LAC,CID,PSC, gpsd_lat,gpsd_lon,gpsd_accu, DF_id,DF_desc) " + "VALUES (" + EVENT_LOG_DATA . LAC + "," + EVENT_LOG_DATA . CID + "," + EVENT_LOG_DATA . PSC + "," + EVENT_LOG_DATA . GPSD_LAT + "," + EVENT_LOG_DATA . GPSD_LON + "," + EVENT_LOG_DATA . GPSD_ACCU + "," + EVENT_LOG_DATA . DF_ID + ",'CellID not found in OCID Database');" ; database . execSQL ( ZeroEvent ) ; populateDefaultMCC ( database ) ; } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { Log . w ( TAG , mTAG + ": Upgrading database from version " + oldVersion + " to " + newVersion + ", and destroy all old data." ) ; db . execSQL ( "DROP TABLE IF EXISTS " + LOCATION_TABLE ) ; db . execSQL ( "DROP TABLE IF EXISTS " + CELL_TABLE ) ; db . execSQL ( "DROP TABLE IF EXISTS " + OPENCELLID_TABLE ) ; db . execSQL ( "DROP TABLE IF EXISTS " + SILENT_SMS_TABLE ) ; db . execSQL ( "DROP TABLE IF EXISTS " + TABLE_DEFAULT_MCC ) ; db . execSQL ( "DROP TABLE IF EXISTS " + CELL_SIGNAL_TABLE ) ; db . execSQL ( "DROP TABLE IF EXISTS " + TABLE_EVENTLOG ) ; onCreate ( db ) ; } } }
package com . SecUpwN . AIMSICD . adapters . Holders ; import android . widget . TextView ; public class ViewTableNameSpinnerHolder { public TextView name ; }
package com . SecUpwN . AIMSICD . smsdetection ; public class CapturedSmsData { private long id ; private String senderNumber ; private String senderMsg ; private String smsTimestamp ; private String smsType ; private int current_lac ; private int current_cid ; private String current_nettype ; private String current_roam_status ; private double current_gps_lat ; private double current_gps_lon ; public String getCurrent_nettype ( ) { return current_nettype ; } public void setCurrent_nettype ( String current_nettype ) { this . current_nettype = current_nettype ; } public String getCurrent_roam_status ( ) { return current_roam_status ; } public void setCurrent_roam_status ( String current_roam_status ) { this . current_roam_status = current_roam_status ; } public double getCurrent_gps_lat ( ) { return current_gps_lat ; } public void setCurrent_gps_lat ( double current_gps_lat ) { this . current_gps_lat = current_gps_lat ; } public double getCurrent_gps_lon ( ) { return current_gps_lon ; } public void setCurrent_gps_lon ( double current_gps_lon ) { this . current_gps_lon = current_gps_lon ; } public CapturedSmsData ( ) { } public int getCurrent_lac ( ) { return current_lac ; } public void setCurrent_lac ( int current_lac ) { this . current_lac = current_lac ; } public int getCurrent_cid ( ) { return current_cid ; } public void setCurrent_cid ( int current_cid ) { this . current_cid = current_cid ; } public String getSenderNumber ( ) { return senderNumber ; } public void setSenderNumber ( String senderNumber ) { this . senderNumber = senderNumber ; } public String getSenderMsg ( ) { return senderMsg ; } public void setSenderMsg ( String senderMsg ) { this . senderMsg = senderMsg ; } public String getSmsTimestamp ( ) { return smsTimestamp ; } public void setSmsTimestamp ( String smsTimestamp ) { this . smsTimestamp = smsTimestamp ; } public String getSmsType ( ) { return smsType ; } public void setSmsType ( String smsType ) { this . smsType = smsType ; } public long getId ( ) { return id ; } public void setId ( long id ) { this . id = id ; } }
package com . SecUpwN . AIMSICD . smsdetection ; public class DetectionStringsData { private final String mDetection_string ; private final String mDetection_type ; private boolean mIsFakeData ; public DetectionStringsData ( String detection_string , String detection_type ) { this ( detection_string , detection_type , false ) ; } public DetectionStringsData ( String pString , String pType , boolean pIsFakeData ) { mDetection_string = pString ; mDetection_type = pType ; mIsFakeData = pIsFakeData ; } public String getDetectionString ( ) { return mDetection_string ; } public String getDetectionType ( ) { return mDetection_type ; } public boolean isFakeData ( ) { return mIsFakeData ; } public void setIsFakeData ( boolean pIsFakeData ) { mIsFakeData = pIsFakeData ; } }
package com . SecUpwN . AIMSICD . smsdetection ; public class AdvanceUserItems { public String getDetection_string ( ) { return detection_string ; } public void setDetection_string ( String detection_string ) { this . detection_string = detection_string ; } public String getDetection_type ( ) { return detection_type ; } public void setDetection_type ( String detection_type ) { this . detection_type = detection_type ; } private String detection_string ; private String detection_type ; }
package com . SecUpwN . AIMSICD . smsdetection ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . adapters . BaseInflaterAdapter ; import com . SecUpwN . AIMSICD . adapters . IAdapterViewInflater ; public class CapturedSmsCardInflater implements IAdapterViewInflater < CapturedSmsData > { @ Override public View inflate ( final BaseInflaterAdapter < CapturedSmsData > adapter , final int pos , View convertView , ViewGroup parent ) { ViewHolder holder ; if ( convertView == null ) { LayoutInflater inflater = LayoutInflater . from ( parent . getContext ( ) ) ; convertView = inflater . inflate ( R . layout . detection_sms_db_listview , parent , false ) ; holder = new ViewHolder ( convertView ) ; } else { holder = ( ViewHolder ) convertView . getTag ( ) ; } final CapturedSmsData item = adapter . getTItem ( pos ) ; holder . updateDisplay ( item ) ; return convertView ; } private class ViewHolder { private final View mRootView ; private final TextView smsd_timestamp , smsd_smstype , smsd_number , smsd_data , smsd_lac , smsd_cid , smsd_rat , smsd_roam , smsd_lat , smsd_lon ; public ViewHolder ( View rootView ) { mRootView = rootView ; smsd_timestamp = ( TextView ) mRootView . findViewById ( R . id . tv_smsdata_timestamp ) ; smsd_smstype = ( TextView ) mRootView . findViewById ( R . id . tv_smsdata_smstype ) ; smsd_number = ( TextView ) mRootView . findViewById ( R . id . tv_smsdata_number ) ; smsd_data = ( TextView ) mRootView . findViewById ( R . id . tv_smsdata_msg ) ; smsd_lac = ( TextView ) mRootView . findViewById ( R . id . tv_smsdata_lac ) ; smsd_cid = ( TextView ) mRootView . findViewById ( R . id . tv_smsdata_cid ) ; smsd_rat = ( TextView ) mRootView . findViewById ( R . id . tv_smsdata_nettype ) ; smsd_roam = ( TextView ) mRootView . findViewById ( R . id . tv_smsdata_roaming ) ; smsd_lat = ( TextView ) mRootView . findViewById ( R . id . tv_smsdata_lat ) ; smsd_lon = ( TextView ) mRootView . findViewById ( R . id . tv_smsdata_lon ) ; rootView . setTag ( this ) ; } public void updateDisplay ( CapturedSmsData item ) { smsd_timestamp . setText ( item . getSmsTimestamp ( ) ) ; smsd_smstype . setText ( item . getSmsType ( ) ) ; smsd_number . setText ( item . getSenderNumber ( ) ) ; smsd_data . setText ( item . getSenderMsg ( ) ) ; smsd_lac . setText ( SV ( item . getCurrent_lac ( ) ) ) ; smsd_cid . setText ( SV ( item . getCurrent_cid ( ) ) ) ; smsd_rat . setText ( item . getCurrent_nettype ( ) ) ; smsd_roam . setText ( item . getCurrent_roam_status ( ) ) ; smsd_lat . setText ( String . valueOf ( item . getCurrent_gps_lat ( ) ) ) ; smsd_lon . setText ( String . valueOf ( item . getCurrent_gps_lon ( ) ) ) ; } } public String SV ( int value ) { return String . valueOf ( value ) ; } }
package com . SecUpwN . AIMSICD . smsdetection ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Log ; import java . util . ArrayList ; public class SmsDetectionDbAccess { SQLiteOpenHelper dbhelper ; SQLiteDatabase dectection_db ; private static final String LOGTAG = "SmsDetectionDbAccess" ; static Context mContext ; public SmsDetectionDbAccess ( Context context ) { mContext = context ; dbhelper = new SmsDetectionDbHelper ( context ) ; dectection_db = dbhelper . getWritableDatabase ( ) ; } public void open ( ) { dectection_db = dbhelper . getWritableDatabase ( ) ; Log . i ( LOGTAG , "database opened" ) ; } public void close ( ) { dbhelper . close ( ) ; Log . i ( LOGTAG , "database closed" ) ; } public boolean insertNewDetectionString ( ContentValues newstring ) { String check4String = String . format ( "SELECT * FROM %s WHERE %s = \"%s\"" , SmsDetectionDbHelper . SILENT_SMS_STRINGS_TABLE , SmsDetectionDbHelper . SILENT_SMS_STRING_COLUMN , newstring . get ( SmsDetectionDbHelper . SILENT_SMS_STRING_COLUMN ) ) ; Cursor stringcount = dectection_db . rawQuery ( check4String , null ) ; if ( stringcount . getCount ( ) > 0 ) { Log . i ( LOGTAG , "Detection String already in Database" ) ; } else { try { dectection_db . insert ( SmsDetectionDbHelper . SILENT_SMS_STRINGS_TABLE , null , newstring ) ; Log . i ( LOGTAG , "Detection String Added" ) ; return true ; } catch ( Exception ee ) { Log . i ( LOGTAG , "Detection String failed" ) ; } } return false ; } public boolean deleteDetectionString ( String deleteme ) { try { dectection_db . delete ( SmsDetectionDbHelper . SILENT_SMS_STRINGS_TABLE , SmsDetectionDbHelper . SILENT_SMS_STRING_COLUMN + "='" + deleteme + "'" , null ) ; return true ; } catch ( Exception ee ) { Log . i ( LOGTAG , "Delete String failed" ) ; } return false ; } public boolean deleteDetectedSms ( long deleteme ) { try { dectection_db . delete ( SmsDetectionDbHelper . SMS_DATA_TABLE_NAME , SmsDetectionDbHelper . SMS_DATA_ID + "=" + deleteme , null ) ; return true ; } catch ( Exception ee ) { Log . i ( LOGTAG , "Sms Deleted failed" ) ; } return false ; } public ArrayList < AdvanceUserItems > getDetectionStrings ( ) { Cursor stringcount = dectection_db . rawQuery ( "SELECT * FROM " + SmsDetectionDbHelper . SILENT_SMS_STRINGS_TABLE , null ) ; ArrayList < AdvanceUserItems > detection_strs = new ArrayList < > ( ) ; System . out . println ( "DB LEN = " + stringcount . getCount ( ) ) ; if ( stringcount . getCount ( ) > 0 ) { while ( stringcount . moveToNext ( ) ) { AdvanceUserItems setitems = new AdvanceUserItems ( ) ; setitems . setDetection_string ( stringcount . getString ( stringcount . getColumnIndex ( SmsDetectionDbHelper . SILENT_SMS_STRING_COLUMN ) ) ) ; setitems . setDetection_type ( stringcount . getString ( stringcount . getColumnIndex ( SmsDetectionDbHelper . SILENT_SMS_TYPE_COLUMN ) ) ) ; detection_strs . add ( setitems ) ; } } else { AdvanceUserItems setitems = new AdvanceUserItems ( ) ; setitems . setDetection_string ( "No data" ) ; setitems . setDetection_type ( "No data" ) ; detection_strs . add ( setitems ) ; } return detection_strs ; } public Cursor getDetectionStringCursor ( ) { return dectection_db . query ( SmsDetectionDbHelper . SILENT_SMS_STRINGS_TABLE , new String [ ] { SmsDetectionDbHelper . SILENT_SMS_STRING_COLUMN , SmsDetectionDbHelper . SILENT_SMS_TYPE_COLUMN } , null , null , null , null , null ) ; } public CapturedSmsData storeCapturedSms ( CapturedSmsData smsdata ) { ContentValues values = new ContentValues ( ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_SENDER_NUMBER , smsdata . getSenderNumber ( ) ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_SENDER_MSG , smsdata . getSenderMsg ( ) ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_TIMESTAMP , smsdata . getSmsTimestamp ( ) ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_SMS_TYPE , smsdata . getSmsType ( ) ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_CURRENT_LAC , smsdata . getCurrent_lac ( ) ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_CURRENT_CID , smsdata . getCurrent_cid ( ) ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_CURRENT_NETTYPE , smsdata . getCurrent_nettype ( ) ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_CURRENT_ROAM_STATE , smsdata . getCurrent_roam_status ( ) ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_CURRENT_GPS_LAT , smsdata . getCurrent_gps_lat ( ) ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_CURRENT_GPS_LON , smsdata . getCurrent_gps_lon ( ) ) ; long insertid = dectection_db . insert ( SmsDetectionDbHelper . SMS_DATA_TABLE_NAME , null , values ) ; smsdata . setId ( insertid ) ; return smsdata ; } public Cursor returnDetectedSmsData ( ) { Cursor getsmsdata_cursor = dectection_db . rawQuery ( "SELECT * FROM " + SmsDetectionDbHelper . SMS_DATA_TABLE_NAME , null ) ; return getsmsdata_cursor ; } }
package com . SecUpwN . AIMSICD . smsdetection ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . BaseAdapter ; import android . widget . TextView ; import com . SecUpwN . AIMSICD . R ; import java . util . ArrayList ; public class AdvanceUserBaseSmsAdapter extends BaseAdapter { private static ArrayList < CapturedSmsData > detectionItemDetails ; private LayoutInflater l_Inflater ; public AdvanceUserBaseSmsAdapter ( Context context , ArrayList < CapturedSmsData > results ) { detectionItemDetails = results ; l_Inflater = LayoutInflater . from ( context ) ; } public int getCount ( ) { return detectionItemDetails . size ( ) ; } public Object getItem ( int position ) { return detectionItemDetails . get ( position ) ; } public long getItemId ( int position ) { return position ; } public View getView ( int position , View convertView , ViewGroup parent ) { ViewHolder holder ; if ( convertView == null ) { convertView = l_Inflater . inflate ( R . layout . adv_user_sms_listview , null ) ; holder = new ViewHolder ( ) ; holder . smsd_timestamp = ( TextView ) convertView . findViewById ( R . id . tv_adv_smsdata_timestamp ) ; holder . smsd_smstype = ( TextView ) convertView . findViewById ( R . id . tv_adv_smsdata_smstype ) ; holder . smsd_number = ( TextView ) convertView . findViewById ( R . id . tv_adv_smsdata_number ) ; holder . smsd_data = ( TextView ) convertView . findViewById ( R . id . tv_adv_smsdata_msg ) ; holder . smsd_lac = ( TextView ) convertView . findViewById ( R . id . tv_adv_smsdata_lac ) ; holder . smsd_cid = ( TextView ) convertView . findViewById ( R . id . tv_adv_smsdata_cid ) ; holder . smsd_rat = ( TextView ) convertView . findViewById ( R . id . tv_adv_smsdata_nettype ) ; holder . smsd_roam = ( TextView ) convertView . findViewById ( R . id . tv_adv_smsdata_roaming ) ; holder . smsd_lat = ( TextView ) convertView . findViewById ( R . id . tv_adv_smsdata_lat ) ; holder . smsd_lon = ( TextView ) convertView . findViewById ( R . id . tv_adv_smsdata_lon ) ; convertView . setTag ( holder ) ; } else { holder = ( ViewHolder ) convertView . getTag ( ) ; } holder . smsd_timestamp . setText ( detectionItemDetails . get ( position ) . getSmsTimestamp ( ) ) ; holder . smsd_smstype . setText ( detectionItemDetails . get ( position ) . getSmsType ( ) ) ; holder . smsd_number . setText ( detectionItemDetails . get ( position ) . getSenderNumber ( ) ) ; holder . smsd_data . setText ( detectionItemDetails . get ( position ) . getSenderMsg ( ) ) ; holder . smsd_lac . setText ( SV ( detectionItemDetails . get ( position ) . getCurrent_lac ( ) ) ) ; holder . smsd_cid . setText ( SV ( detectionItemDetails . get ( position ) . getCurrent_cid ( ) ) ) ; holder . smsd_rat . setText ( detectionItemDetails . get ( position ) . getCurrent_nettype ( ) ) ; holder . smsd_roam . setText ( detectionItemDetails . get ( position ) . getCurrent_roam_status ( ) ) ; holder . smsd_lat . setText ( String . valueOf ( detectionItemDetails . get ( position ) . getCurrent_gps_lat ( ) ) ) ; holder . smsd_lon . setText ( String . valueOf ( detectionItemDetails . get ( position ) . getCurrent_gps_lon ( ) ) ) ; return convertView ; } static class ViewHolder { TextView smsd_timestamp , smsd_smstype , smsd_number , smsd_data , smsd_lac , smsd_cid , smsd_rat , smsd_roam , smsd_lat , smsd_lon ; } public String SV ( int value ) { return String . valueOf ( value ) ; } }
package com . SecUpwN . AIMSICD . smsdetection ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . adapters . BaseInflaterAdapter ; import com . SecUpwN . AIMSICD . adapters . IAdapterViewInflater ; public class DetectionStringsCardInflater implements IAdapterViewInflater < DetectionStringsData > { @ Override public View inflate ( final BaseInflaterAdapter < DetectionStringsData > adapter , final int pos , View convertView , ViewGroup parent ) { ViewHolder holder ; if ( convertView == null ) { LayoutInflater inflater = LayoutInflater . from ( parent . getContext ( ) ) ; convertView = inflater . inflate ( R . layout . detection_strings_items , parent , false ) ; holder = new ViewHolder ( convertView ) ; } else { holder = ( ViewHolder ) convertView . getTag ( ) ; } final DetectionStringsData item = adapter . getTItem ( pos ) ; holder . updateDisplay ( item ) ; return convertView ; } private class ViewHolder { private final View mRootView ; private final TextView d_string ; private final TextView d_type ; public ViewHolder ( View rootView ) { mRootView = rootView ; d_string = ( TextView ) mRootView . findViewById ( R . id . tv_det_str_info ) ; d_type = ( TextView ) mRootView . findViewById ( R . id . tv_det_type_info ) ; rootView . setTag ( this ) ; } public void updateDisplay ( DetectionStringsData item ) { d_string . setText ( item . getDetectionString ( ) ) ; d_type . setText ( item . getDetectionType ( ) ) ; } } }
package com . SecUpwN . AIMSICD . smsdetection ; import android . content . ContentValues ; import android . content . Context ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Log ; public class SmsDetectionDbHelper extends SQLiteOpenHelper { private static final String LOGTAG = "TYPE0_DETECTION" ; private static final String DATABASE_NAME = "pk_sms_detection.db" ; private static final int DATABASE_VERSION = 1 ; public static final String SMS_DATA_TABLE_NAME = "sms_data" ; public static final String SMS_DATA_ID = "id" ; public static final String SMS_DATA_SENDER_NUMBER = "sender_number" ; public static final String SMS_DATA_SENDER_MSG = "sender_msg" ; public static final String SMS_DATA_TIMESTAMP = "sms_timestamp" ; public static final String SMS_DATA_SMS_TYPE = "sms_type" ; public static final String SMS_DATA_CURRENT_CID = "current_cid" ; public static final String SMS_DATA_CURRENT_LAC = "current_lac" ; public static final String SMS_DATA_CURRENT_NETTYPE = "current_net_type" ; public static final String SMS_DATA_CURRENT_ROAM_STATE = "current_roam_state" ; public static final String SMS_DATA_CURRENT_GPS_LAT = "current_gps_lat" ; public static final String SMS_DATA_CURRENT_GPS_LON = "current_gps_lon" ; public static final String SILENT_SMS_ID = "_id" ; public static final String SILENT_SMS_STRINGS_TABLE = "silentsmsstrings" ; public static final String SILENT_SMS_STRING_COLUMN = "silent_sms_str" ; public static final String SILENT_SMS_TYPE_COLUMN = "silent_sms_type" ; String [ ] allSmsColumns = { SmsDetectionDbHelper . SMS_DATA_ID , SmsDetectionDbHelper . SMS_DATA_SENDER_NUMBER , SmsDetectionDbHelper . SMS_DATA_SENDER_MSG , SmsDetectionDbHelper . SMS_DATA_TIMESTAMP , SmsDetectionDbHelper . SMS_DATA_SMS_TYPE , SmsDetectionDbHelper . SMS_DATA_CURRENT_CID , SmsDetectionDbHelper . SMS_DATA_CURRENT_LAC , SmsDetectionDbHelper . SMS_DATA_CURRENT_NETTYPE , SmsDetectionDbHelper . SMS_DATA_CURRENT_ROAM_STATE , SmsDetectionDbHelper . SMS_DATA_CURRENT_GPS_LAT , SmsDetectionDbHelper . SMS_DATA_CURRENT_GPS_LON } ; String SILENT_SMS_STRINGS_TABLE_CREATE = "CREATE TABLE " + SILENT_SMS_STRINGS_TABLE + " (" + SILENT_SMS_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + "silent_sms_str TEXT, " + "silent_sms_type TEXT);" ; String CREATE_SMS_DATA_TB = String . format ( "CREATE TABLE %s (%s INTEGER PRIMARY KEY AUTOINCREMENT, %s TEXT, %s TEXT, %s TEXT, %s TEXT, %s INTEGER, %s INTEGER,%s TEXT, %s TEXT,%s DOUBLE, %s DOUBLE )" , SMS_DATA_TABLE_NAME , SMS_DATA_ID , SMS_DATA_SENDER_NUMBER , SMS_DATA_SENDER_MSG , SMS_DATA_TIMESTAMP , SMS_DATA_SMS_TYPE , SMS_DATA_CURRENT_LAC , SMS_DATA_CURRENT_CID , SMS_DATA_CURRENT_NETTYPE , SMS_DATA_CURRENT_ROAM_STATE , SMS_DATA_CURRENT_GPS_LAT , SMS_DATA_CURRENT_GPS_LON ) ; public SmsDetectionDbHelper ( Context context ) { super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ; } @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( SILENT_SMS_STRINGS_TABLE_CREATE ) ; db . execSQL ( CREATE_SMS_DATA_TB ) ; String SILENT_ONLY_TAGS [ ] = { "Received short message type 0, Don't display or store it. Send Ack#TYPE0" , "Received voice mail indicator clear SMS shouldStore=false#SILENTVOICE" , "SMS TP-PID:0 data coding scheme: 24#FLASH" , "isTypeZero=true#TYPE0" , "incoming msg. Mti 0 ProtocolID 0 DCS 0x04 class -1#WAPPUSH" } ; for ( int x = 0 ; x < SILENT_ONLY_TAGS . length ; x ++ ) { ContentValues sms_detection_string = new ContentValues ( ) ; sms_detection_string . put ( SILENT_SMS_STRING_COLUMN , SILENT_ONLY_TAGS [ x ] . split ( "#" ) [ 0 ] ) ; sms_detection_string . put ( SILENT_SMS_TYPE_COLUMN , SILENT_ONLY_TAGS [ x ] . split ( "#" ) [ 1 ] ) ; db . insert ( SILENT_SMS_STRINGS_TABLE , null , sms_detection_string ) ; } ContentValues values = new ContentValues ( ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_SENDER_NUMBER , "1234567890" ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_SENDER_MSG , "First install test sms" ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_TIMESTAMP , "20150404113312" ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_SMS_TYPE , "TYPE0" ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_CURRENT_LAC , "1234" ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_CURRENT_CID , "4321" ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_CURRENT_NETTYPE , "GSM" ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_CURRENT_ROAM_STATE , "false" ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_CURRENT_GPS_LAT , 51.00000 ) ; values . put ( SmsDetectionDbHelper . SMS_DATA_CURRENT_GPS_LON , - 8.00000 ) ; db . insert ( SmsDetectionDbHelper . SMS_DATA_TABLE_NAME , null , values ) ; Log . i ( LOGTAG , "onCreate >> Database has been created" ) ; } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { db . execSQL ( "DROP TABLE IF EXISTS " + SILENT_SMS_STRINGS_TABLE_CREATE ) ; db . execSQL ( "DROP TABLE IF EXISTS " + SMS_DATA_TABLE_NAME ) ; onCreate ( db ) ; Log . i ( LOGTAG , "onUpgrade >> Database has been created" ) ; } }
package com . stericson . RootShell . containers ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileFilter ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . FilenameFilter ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class RootClass { static String PATH_TO_DX = "/Users/Chris/Projects/android-sdk-macosx/build-tools/18.0.1/dx" ; enum READ_STATE { STARTING , FOUND_ANNOTATION ; } ; public RootClass ( String [ ] args ) throws ClassNotFoundException , NoSuchMethodException , IllegalAccessException , InvocationTargetException , InstantiationException { String className = args [ 0 ] ; RootArgs actualArgs = new RootArgs ( ) ; actualArgs . args = new String [ args . length - 1 ] ; System . arraycopy ( args , 1 , actualArgs . args , 0 , args . length - 1 ) ; Class < ? > classHandler = Class . forName ( className ) ; Constructor < ? > classConstructor = classHandler . getConstructor ( RootArgs . class ) ; classConstructor . newInstance ( actualArgs ) ; } public @ interface Candidate { } ; public class RootArgs { public String args [ ] ; } static void displayError ( Exception e ) { System . out . println ( "##ERR##" + e . getMessage ( ) + "##" ) ; e . printStackTrace ( ) ; } static public class AnnotationsFinder { private final String AVOIDDIRPATH = "stericson" + File . separator + "RootShell" + File . separator ; private List < File > classFiles ; public AnnotationsFinder ( ) throws IOException { System . out . println ( "Discovering root class annotations..." ) ; classFiles = new ArrayList < File > ( ) ; lookup ( new File ( "src" ) , classFiles ) ; System . out . println ( "Done discovering annotations. Building jar file." ) ; File builtPath = getBuiltPath ( ) ; if ( null != builtPath ) { String rc1 = "com" + File . separator + "stericson" + File . separator + "RootShell" + File . separator + "containers" + File . separator + "RootClass.class" ; String rc2 = "com" + File . separator + "stericson" + File . separator + "RootShell" + File . separator + "containers" + File . separator + "RootClass$RootArgs.class" ; String rc3 = "com" + File . separator + "stericson" + File . separator + "RootShell" + File . separator + "containers" + File . separator + "RootClass$AnnotationsFinder.class" ; String rc4 = "com" + File . separator + "stericson" + File . separator + "RootShell" + File . separator + "containers" + File . separator + "RootClass$AnnotationsFinder$1.class" ; String rc5 = "com" + File . separator + "stericson" + File . separator + "RootShell" + File . separator + "containers" + File . separator + "RootClass$AnnotationsFinder$2.class" ; String [ ] cmd ; boolean onWindows = ( - 1 != System . getProperty ( "os.name" ) . toLowerCase ( ) . indexOf ( "win" ) ) ; if ( onWindows ) { StringBuilder sb = new StringBuilder ( " " + rc1 + " " + rc2 + " " + rc3 + " " + rc4 + " " + rc5 ) ; for ( File file : classFiles ) { sb . append ( " " + file . getPath ( ) ) ; } cmd = new String [ ] { "cmd" , "/C" , "jar cvf" + " anbuild.jar" + sb . toString ( ) } ; } else { ArrayList < String > al = new ArrayList < String > ( ) ; al . add ( "jar" ) ; al . add ( "cf" ) ; al . add ( "anbuild.jar" ) ; al . add ( rc1 ) ; al . add ( rc2 ) ; al . add ( rc3 ) ; al . add ( rc4 ) ; al . add ( rc5 ) ; for ( File file : classFiles ) { al . add ( file . getPath ( ) ) ; } cmd = al . toArray ( new String [ al . size ( ) ] ) ; } ProcessBuilder jarBuilder = new ProcessBuilder ( cmd ) ; jarBuilder . directory ( builtPath ) ; try { jarBuilder . start ( ) . waitFor ( ) ; } catch ( IOException e ) { } catch ( InterruptedException e ) { } File rawFolder = new File ( "res/raw" ) ; if ( ! rawFolder . exists ( ) ) { rawFolder . mkdirs ( ) ; } System . out . println ( "Done building jar file. Creating dex file." ) ; if ( onWindows ) { cmd = new String [ ] { "cmd" , "/C" , "dx --dex --output=res/raw/anbuild.dex " + builtPath + File . separator + "anbuild.jar" } ; } else { cmd = new String [ ] { getPathToDx ( ) , "--dex" , "--output=res/raw/anbuild.dex" , builtPath + File . separator + "anbuild.jar" } ; } ProcessBuilder dexBuilder = new ProcessBuilder ( cmd ) ; try { dexBuilder . start ( ) . waitFor ( ) ; } catch ( IOException e ) { } catch ( InterruptedException e ) { } } System . out . println ( "All done. ::: anbuild.dex should now be in your project's res/raw/ folder :::" ) ; } protected void lookup ( File path , List < File > fileList ) { String desourcedPath = path . toString ( ) . replace ( "src/" , "" ) ; File [ ] files = path . listFiles ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { if ( - 1 == file . getAbsolutePath ( ) . indexOf ( AVOIDDIRPATH ) ) { lookup ( file , fileList ) ; } } else { if ( file . getName ( ) . endsWith ( ".java" ) ) { if ( hasClassAnnotation ( file ) ) { final String fileNamePrefix = file . getName ( ) . replace ( ".java" , "" ) ; final File compiledPath = new File ( getBuiltPath ( ) . toString ( ) + File . separator + desourcedPath ) ; File [ ] classAndInnerClassFiles = compiledPath . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String filename ) { return filename . startsWith ( fileNamePrefix ) ; } } ) ; for ( final File matchingFile : classAndInnerClassFiles ) { fileList . add ( new File ( desourcedPath + File . separator + matchingFile . getName ( ) ) ) ; } } } } } } protected boolean hasClassAnnotation ( File file ) { READ_STATE readState = READ_STATE . STARTING ; Pattern p = Pattern . compile ( " class ([A-Za-z0-9_]+)" ) ; try { BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; String line ; while ( null != ( line = reader . readLine ( ) ) ) { switch ( readState ) { case STARTING : if ( - 1 < line . indexOf ( "@RootClass.Candidate" ) ) { readState = READ_STATE . FOUND_ANNOTATION ; } break ; case FOUND_ANNOTATION : Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { System . out . println ( " Found annotated class: " + m . group ( 0 ) ) ; return true ; } else { System . err . println ( "Error: unmatched annotation in " + file . getAbsolutePath ( ) ) ; readState = READ_STATE . STARTING ; } break ; } } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return false ; } protected String getPathToDx ( ) throws IOException { String androidHome = System . getenv ( "ANDROID_HOME" ) ; if ( null == androidHome ) { throw new IOException ( "Error: you need to set $ANDROID_HOME globally" ) ; } String dxPath = null ; File [ ] files = new File ( androidHome + File . separator + "build-tools" ) . listFiles ( ) ; int recentSdkVersion = 0 ; for ( File file : files ) { String fileName = null ; if ( file . getName ( ) . contains ( "-" ) ) { String [ ] splitFileName = file . getName ( ) . split ( "-" ) ; if ( splitFileName [ 1 ] . contains ( "W" ) ) { char [ ] fileNameChars = splitFileName [ 1 ] . toCharArray ( ) ; fileName = String . valueOf ( fileNameChars [ 0 ] ) ; } else { fileName = splitFileName [ 1 ] ; } } else { fileName = file . getName ( ) ; } int sdkVersion ; String [ ] sdkVersionBits = fileName . split ( "[.]" ) ; sdkVersion = Integer . parseInt ( sdkVersionBits [ 0 ] ) * 10000 ; if ( sdkVersionBits . length > 1 ) { sdkVersion += Integer . parseInt ( sdkVersionBits [ 1 ] ) * 100 ; if ( sdkVersionBits . length > 2 ) { sdkVersion += Integer . parseInt ( sdkVersionBits [ 2 ] ) ; } } if ( sdkVersion > recentSdkVersion ) { String tentativePath = file . getAbsolutePath ( ) + File . separator + "dx" ; if ( new File ( tentativePath ) . exists ( ) ) { recentSdkVersion = sdkVersion ; dxPath = tentativePath ; } } } if ( dxPath == null ) { throw new IOException ( "Error: unable to find dx binary in $ANDROID_HOME" ) ; } return dxPath ; } protected File getBuiltPath ( ) { File foundPath = null ; File ideaPath = new File ( "out" + File . separator + "production" ) ; if ( ideaPath . isDirectory ( ) ) { File [ ] children = ideaPath . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( File pathname ) { return pathname . isDirectory ( ) ; } } ) ; if ( children . length > 0 ) { foundPath = new File ( ideaPath . getAbsolutePath ( ) + File . separator + children [ 0 ] . getName ( ) ) ; } } if ( null == foundPath ) { File eclipsePath = new File ( "bin" + File . separator + "classes" ) ; if ( eclipsePath . isDirectory ( ) ) { foundPath = eclipsePath ; } } return foundPath ; } } public static void main ( String [ ] args ) { try { if ( args . length == 0 ) { new AnnotationsFinder ( ) ; } else { new RootClass ( args ) ; } } catch ( Exception e ) { displayError ( e ) ; } } }
package com . SecUpwN . AIMSICD . smsdetection ; import android . app . Activity ; import android . database . Cursor ; import android . os . Bundle ; import android . view . View ; import android . widget . AdapterView ; import android . widget . ListView ; import android . widget . Toast ; import com . SecUpwN . AIMSICD . R ; import java . util . ArrayList ; public class AdvancedUserSmsActivity extends Activity { ListView listViewAdv ; private SmsDetectionDbAccess dbaccess ; ArrayList < CapturedSmsData > msgitems ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_advanced_sms_user ) ; dbaccess = new SmsDetectionDbAccess ( getApplicationContext ( ) ) ; listViewAdv = ( ListView ) findViewById ( R . id . listView_Adv_Sms_Activity ) ; msgitems = new ArrayList < > ( ) ; dbaccess . open ( ) ; try { Cursor smscur = dbaccess . returnDetectedSmsData ( ) ; if ( smscur . getCount ( ) > 0 ) { while ( smscur . moveToNext ( ) ) { CapturedSmsData getdata = new CapturedSmsData ( ) ; getdata . setId ( smscur . getLong ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_ID ) ) ) ; getdata . setSmsTimestamp ( smscur . getString ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_TIMESTAMP ) ) ) ; getdata . setSmsType ( smscur . getString ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_SMS_TYPE ) ) ) ; getdata . setSenderNumber ( smscur . getString ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_SENDER_NUMBER ) ) ) ; getdata . setSenderMsg ( smscur . getString ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_SENDER_MSG ) ) ) ; getdata . setCurrent_lac ( smscur . getInt ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_LAC ) ) ) ; getdata . setCurrent_cid ( smscur . getInt ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_CID ) ) ) ; getdata . setCurrent_nettype ( smscur . getString ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_NETTYPE ) ) ) ; getdata . setCurrent_roam_status ( smscur . getString ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_ROAM_STATE ) ) ) ; getdata . setCurrent_gps_lat ( smscur . getDouble ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_GPS_LAT ) ) ) ; getdata . setCurrent_gps_lon ( smscur . getDouble ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_GPS_LON ) ) ) ; msgitems . add ( getdata ) ; } } } catch ( Exception ee ) { System . out . println ( "DB ERROR>>>>" + ee . toString ( ) ) ; } dbaccess . close ( ) ; listViewAdv . setAdapter ( new AdvanceUserBaseSmsAdapter ( getApplicationContext ( ) , msgitems ) ) ; listViewAdv . setOnItemLongClickListener ( new AdapterView . OnItemLongClickListener ( ) { @ Override public boolean onItemLongClick ( AdapterView < ? > a , View v , int position , long id ) { Object o = listViewAdv . getItemAtPosition ( position ) ; CapturedSmsData obj_itemDetails = ( CapturedSmsData ) o ; dbaccess . open ( ) ; if ( dbaccess . deleteDetectedSms ( obj_itemDetails . getId ( ) ) ) { Toast . makeText ( getApplicationContext ( ) , "Deleted Sms Id = \n" + obj_itemDetails . getId ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( getApplicationContext ( ) , "Failed to Delete" , Toast . LENGTH_SHORT ) . show ( ) ; } dbaccess . close ( ) ; try { loadDbString ( ) ; } catch ( Exception ee ) { } return false ; } } ) ; } public void loadDbString ( ) { ArrayList < CapturedSmsData > newmsglist = new ArrayList < > ( ) ; dbaccess . open ( ) ; try { Cursor smscur = dbaccess . returnDetectedSmsData ( ) ; if ( smscur . getCount ( ) > 0 ) { while ( smscur . moveToNext ( ) ) { CapturedSmsData getdata = new CapturedSmsData ( ) ; getdata . setId ( smscur . getLong ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_ID ) ) ) ; getdata . setSmsTimestamp ( smscur . getString ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_TIMESTAMP ) ) ) ; getdata . setSmsType ( smscur . getString ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_SMS_TYPE ) ) ) ; getdata . setSenderNumber ( smscur . getString ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_SENDER_NUMBER ) ) ) ; getdata . setSenderMsg ( smscur . getString ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_SENDER_MSG ) ) ) ; getdata . setCurrent_lac ( smscur . getInt ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_LAC ) ) ) ; getdata . setCurrent_cid ( smscur . getInt ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_CID ) ) ) ; getdata . setCurrent_nettype ( smscur . getString ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_NETTYPE ) ) ) ; getdata . setCurrent_roam_status ( smscur . getString ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_ROAM_STATE ) ) ) ; getdata . setCurrent_gps_lat ( smscur . getDouble ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_GPS_LAT ) ) ) ; getdata . setCurrent_gps_lon ( smscur . getDouble ( smscur . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_GPS_LON ) ) ) ; newmsglist . add ( getdata ) ; } } listViewAdv . setAdapter ( new AdvanceUserBaseSmsAdapter ( getApplicationContext ( ) , newmsglist ) ) ; } catch ( Exception ee ) { System . out . println ( "DB ERROR>>>>" + ee . toString ( ) ) ; } dbaccess . close ( ) ; } }
package com . SecUpwN . AIMSICD . smsdetection ; import android . app . Activity ; import android . content . ContentValues ; import android . os . Bundle ; import android . view . View ; import android . widget . AdapterView ; import android . widget . Button ; import android . widget . EditText ; import android . widget . ListView ; import android . widget . Spinner ; import android . widget . Toast ; import com . SecUpwN . AIMSICD . R ; import java . util . ArrayList ; public class AdvancedUserActivity extends Activity { ListView listViewAdv ; private SmsDetectionDbAccess dbaccess ; Button btn_insert ; EditText edit_adv_user_det ; Spinner myspinner ; ArrayList < AdvanceUserItems > msgitems ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_advanced_user ) ; btn_insert = ( Button ) findViewById ( R . id . btn_insert ) ; edit_adv_user_det = ( EditText ) findViewById ( R . id . edit_adv_user_string ) ; myspinner = ( Spinner ) findViewById ( R . id . spinner ) ; dbaccess = new SmsDetectionDbAccess ( getApplicationContext ( ) ) ; dbaccess . open ( ) ; listViewAdv = ( ListView ) findViewById ( R . id . listView_Adv_Activity ) ; try { msgitems = dbaccess . getDetectionStrings ( ) ; } catch ( Exception ee ) { System . out . println ( "DB ERROR>>>>" + ee . toString ( ) ) ; msgitems = new ArrayList < AdvanceUserItems > ( ) ; AdvanceUserItems itemss = new AdvanceUserItems ( ) ; itemss . setDetection_string ( "NO DATA" ) ; itemss . setDetection_type ( "No TYPE" ) ; msgitems . add ( itemss ) ; } dbaccess . close ( ) ; listViewAdv . setAdapter ( new AdvanceUserBaseAdapter ( getApplicationContext ( ) , msgitems ) ) ; listViewAdv . setOnItemLongClickListener ( new AdapterView . OnItemLongClickListener ( ) { @ Override public boolean onItemLongClick ( AdapterView < ? > a , View v , int position , long id ) { Object o = listViewAdv . getItemAtPosition ( position ) ; AdvanceUserItems obj_itemDetails = ( AdvanceUserItems ) o ; dbaccess . open ( ) ; if ( dbaccess . deleteDetectionString ( obj_itemDetails . getDetection_string ( ) ) ) { Toast . makeText ( getApplicationContext ( ) , "Deleted String\n" + obj_itemDetails . getDetection_string ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( getApplicationContext ( ) , "Failed to Delete" , Toast . LENGTH_SHORT ) . show ( ) ; } dbaccess . close ( ) ; try { loadDbString ( ) ; } catch ( Exception ee ) { } return false ; } } ) ; btn_insert . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { dbaccess . open ( ) ; ContentValues store_new_sms_string = new ContentValues ( ) ; store_new_sms_string . put ( SmsDetectionDbHelper . SILENT_SMS_STRING_COLUMN , edit_adv_user_det . getText ( ) . toString ( ) ) ; store_new_sms_string . put ( SmsDetectionDbHelper . SILENT_SMS_TYPE_COLUMN , myspinner . getSelectedItem ( ) . toString ( ) ) ; if ( dbaccess . insertNewDetectionString ( store_new_sms_string ) ) { Toast . makeText ( getApplicationContext ( ) , "String Added to DB" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( getApplicationContext ( ) , "String Failed to add" , Toast . LENGTH_SHORT ) . show ( ) ; } dbaccess . close ( ) ; try { loadDbString ( ) ; } catch ( Exception ee ) { } } } ) ; } public void loadDbString ( ) { ArrayList < AdvanceUserItems > newmsglist ; dbaccess . open ( ) ; try { newmsglist = dbaccess . getDetectionStrings ( ) ; listViewAdv . setAdapter ( new AdvanceUserBaseAdapter ( getApplicationContext ( ) , newmsglist ) ) ; } catch ( Exception ee ) { } dbaccess . close ( ) ; } }
package com . SecUpwN . AIMSICD . smsdetection ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . BaseAdapter ; import android . widget . TextView ; import com . SecUpwN . AIMSICD . R ; import java . util . ArrayList ; public class AdvanceUserBaseAdapter extends BaseAdapter { private static ArrayList < AdvanceUserItems > detectionItemDetails ; private LayoutInflater l_Inflater ; public AdvanceUserBaseAdapter ( Context context , ArrayList < AdvanceUserItems > results ) { detectionItemDetails = results ; l_Inflater = LayoutInflater . from ( context ) ; } public int getCount ( ) { return detectionItemDetails . size ( ) ; } public Object getItem ( int position ) { return detectionItemDetails . get ( position ) ; } public long getItemId ( int position ) { return position ; } public View getView ( int position , View convertView , ViewGroup parent ) { ViewHolder holder ; if ( convertView == null ) { convertView = l_Inflater . inflate ( R . layout . adv_user_strings_list , null ) ; holder = new ViewHolder ( ) ; holder . tv_detection_string = ( TextView ) convertView . findViewById ( R . id . tv_adv_list_det_str ) ; holder . tv_detection_type = ( TextView ) convertView . findViewById ( R . id . tv_adv_list_det_type ) ; convertView . setTag ( holder ) ; } else { holder = ( ViewHolder ) convertView . getTag ( ) ; } holder . tv_detection_string . setText ( detectionItemDetails . get ( position ) . getDetection_string ( ) ) ; holder . tv_detection_type . setText ( detectionItemDetails . get ( position ) . getDetection_type ( ) ) ; return convertView ; } static class ViewHolder { TextView tv_detection_string , tv_detection_type ; } }
package com . SecUpwN . AIMSICD . smsdetection ; import android . app . Notification ; import android . app . NotificationManager ; import android . app . PendingIntent ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . ServiceConnection ; import android . content . SharedPreferences ; import android . os . IBinder ; import android . support . v4 . app . NotificationCompat ; import android . util . Log ; import com . SecUpwN . AIMSICD . AIMSICD ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . service . AimsicdService ; import com . SecUpwN . AIMSICD . utils . Device ; import com . SecUpwN . AIMSICD . utils . MiscUtils ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . util . ArrayList ; public class SmsDetector extends Thread { final static String TAG = "SmsDetector" ; private DataInputStream dis ; private DataOutputStream dos ; private AimsicdService mAimsicdService ; private SharedPreferences prefs ; private boolean mBound ; SmsDetectionDbAccess dbacess ; static Context tContext ; String [ ] SILENT_ONLY_TAGS ; String XPERIA_J_INDICATOR = "QCRIL_RPC#POSSIBLE TYPE 0 DETECTED" , CHECK_BROADCAST_REC = " SMS_ACKNOWLEDGE true #UNKNOWN_SILENT_SMS_DETECTED" ; String DETECTION_PHONENUM_SMS_DATA [ ] = { "SMS originating address:" , "SMS message body (raw):" , "OrigAddr" } ; public static boolean isrunning = false ; public static boolean getSmsDetectionState ( ) { return isrunning ; } public static void setSmsDetectionState ( boolean isrunning ) { SmsDetector . isrunning = isrunning ; } public SmsDetector ( Context newcontext ) { tContext = newcontext ; dbacess = new SmsDetectionDbAccess ( newcontext ) ; dbacess . open ( ) ; ArrayList < AdvanceUserItems > silent_string = dbacess . getDetectionStrings ( ) ; dbacess . close ( ) ; SILENT_ONLY_TAGS = new String [ silent_string . size ( ) ] ; for ( int x = 0 ; x < silent_string . size ( ) ; x ++ ) { SILENT_ONLY_TAGS [ x ] = silent_string . get ( x ) . getDetection_string ( ) + "#" + silent_string . get ( x ) . getDetection_type ( ) ; } prefs = newcontext . getSharedPreferences ( AimsicdService . SHARED_PREFERENCES_BASENAME , 0 ) ; } public void startSmsDetection ( ) { Intent intent = new Intent ( tContext , AimsicdService . class ) ; tContext . bindService ( intent , mConnection , Context . BIND_AUTO_CREATE ) ; start ( ) ; Log . i ( TAG , "sms detection started" ) ; } public void stopSmsDetection ( ) { setSmsDetectionState ( false ) ; if ( mBound ) { tContext . unbindService ( mConnection ) ; mBound = false ; } Log . i ( TAG , "sms detection stopped" ) ; } @ Override public void run ( ) { setSmsDetectionState ( true ) ; try { try { new Thread ( ) . sleep ( 500 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } try { String MODE = "logcat -b radio\n" ; Runtime r = Runtime . getRuntime ( ) ; Process process = r . exec ( "su" ) ; dos = new DataOutputStream ( process . getOutputStream ( ) ) ; dos . writeBytes ( MODE ) ; dos . flush ( ) ; dis = new DataInputStream ( process . getInputStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } while ( getSmsDetectionState ( ) ) { try { int bufferlen = dis . available ( ) ; if ( bufferlen != 0 ) { byte [ ] b = new byte [ bufferlen ] ; dis . read ( b ) ; String split [ ] = new String ( b ) . split ( "\n" ) ; checkForSilentSms ( split ) ; } else { Thread . sleep ( 1000 ) ; } } catch ( IOException e ) { if ( e . getMessage ( ) != null ) System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { } } public void checkForSilentSms ( String [ ] progress ) { for ( int arrayindex = 0 ; arrayindex < SILENT_ONLY_TAGS . length ; arrayindex ++ ) { int MAX_INT = progress . length - 4 ; for ( int x = 0 ; x < progress . length ; x ++ ) { if ( progress [ x ] . length ( ) < 250 ) { if ( progress [ x ] . contains ( SILENT_ONLY_TAGS [ arrayindex ] . split ( "#" ) [ 0 ] ) ) { System . out . println ( "Detected>>>>" + SILENT_ONLY_TAGS [ arrayindex ] . split ( "#" ) [ 1 ] ) ; if ( SILENT_ONLY_TAGS [ arrayindex ] . split ( "#" ) [ 1 ] . equals ( "TYPE0" ) ) { CapturedSmsData setmsg = new CapturedSmsData ( ) ; setmsg . setSenderNumber ( "unknown" ) ; setmsg . setSenderMsg ( "no data" ) ; int newcount = ( x - 15 ) ; if ( newcount > 0 ) { while ( newcount < x ) { if ( progress [ newcount ] . contains ( DETECTION_PHONENUM_SMS_DATA [ 2 ] . toString ( ) ) ) { try { String number = progress [ newcount ] . substring ( progress [ newcount ] . indexOf ( "OrigAddr" ) ) . replace ( DETECTION_PHONENUM_SMS_DATA [ 2 ] . toString ( ) , "" ) . trim ( ) ; setmsg . setSenderNumber ( number ) ; } catch ( Exception ee ) { Log . e ( TAG , "Error parsing number" ) ; } } else if ( progress [ newcount ] . contains ( DETECTION_PHONENUM_SMS_DATA [ 1 ] . toString ( ) ) ) { try { String smsdata = progress [ newcount ] . substring ( progress [ newcount ] . indexOf ( "'" ) + 1 , progress [ newcount ] . length ( ) - 1 ) ; setmsg . setSenderMsg ( smsdata ) ; } catch ( Exception ee ) { Log . e ( TAG , "Error parsing sms data" ) ; } } newcount ++ ; } } setmsg . setSmsTimestamp ( MiscUtils . getCurrentTimeStamp ( ) ) ; setmsg . setSmsType ( "TYPE0" ) ; setmsg . setCurrent_lac ( mAimsicdService . getCellTracker ( ) . getMonitorCell ( ) . getLAC ( ) ) ; setmsg . setCurrent_cid ( mAimsicdService . getCellTracker ( ) . getMonitorCell ( ) . getCID ( ) ) ; setmsg . setCurrent_nettype ( Device . getNetworkTypeName ( mAimsicdService . getCell ( ) . getNetType ( ) ) ) ; setmsg . setCurrent_roam_status ( mAimsicdService . getCellTracker ( ) . getDevice ( ) . isRoaming ( ) ) ; setmsg . setCurrent_gps_lat ( mAimsicdService . lastKnownLocation ( ) . getLatitudeInDegrees ( ) ) ; setmsg . setCurrent_gps_lon ( mAimsicdService . lastKnownLocation ( ) . getLongitudeInDegrees ( ) ) ; dbacess . open ( ) ; dbacess . storeCapturedSms ( setmsg ) ; dbacess . close ( ) ; MiscUtils . startPopUpInfo ( tContext , 6 ) ; } else if ( SILENT_ONLY_TAGS [ arrayindex ] . split ( "#" ) [ 1 ] . trim ( ) . equals ( "SILENTVOICE" ) ) { Log . i ( TAG , "SILENT DETECTED" ) ; CapturedSmsData setmsg = new CapturedSmsData ( ) ; setmsg . setSenderNumber ( "unknown" ) ; setmsg . setSenderMsg ( "no data" ) ; int newcount = ( x - 15 ) ; if ( newcount > 0 ) { while ( newcount < x ) { if ( progress [ newcount ] . contains ( DETECTION_PHONENUM_SMS_DATA [ 0 ] . toString ( ) ) ) { try { String number = progress [ newcount ] . substring ( progress [ newcount ] . indexOf ( "+" ) ) ; setmsg . setSenderNumber ( number ) ; } catch ( Exception ee ) { } } else if ( progress [ newcount ] . contains ( DETECTION_PHONENUM_SMS_DATA [ 2 ] . toString ( ) ) ) { try { String number = progress [ newcount ] . substring ( progress [ newcount ] . indexOf ( "OrigAddr" ) ) . replace ( DETECTION_PHONENUM_SMS_DATA [ 2 ] . toString ( ) , "" ) . trim ( ) ; setmsg . setSenderNumber ( number ) ; } catch ( Exception ee ) { Log . e ( TAG , "Error parsing number" ) ; } } else if ( progress [ newcount ] . contains ( DETECTION_PHONENUM_SMS_DATA [ 1 ] . toString ( ) ) ) { try { String smsdata = progress [ newcount ] . substring ( progress [ newcount ] . indexOf ( "'" ) + 1 , progress [ newcount ] . length ( ) - 1 ) ; setmsg . setSenderMsg ( smsdata ) ; } catch ( Exception ee ) { Log . e ( TAG , "Error parsing sms data" ) ; } } newcount ++ ; } } setmsg . setSmsTimestamp ( MiscUtils . getCurrentTimeStamp ( ) ) ; setmsg . setSmsType ( "SILENTVOICE" ) ; setmsg . setCurrent_lac ( mAimsicdService . getCellTracker ( ) . getMonitorCell ( ) . getLAC ( ) ) ; setmsg . setCurrent_cid ( mAimsicdService . getCellTracker ( ) . getMonitorCell ( ) . getCID ( ) ) ; setmsg . setCurrent_nettype ( Device . getNetworkTypeName ( mAimsicdService . getCell ( ) . getNetType ( ) ) ) ; setmsg . setCurrent_roam_status ( mAimsicdService . getCellTracker ( ) . getDevice ( ) . isRoaming ( ) ) ; setmsg . setCurrent_gps_lat ( mAimsicdService . lastKnownLocation ( ) . getLatitudeInDegrees ( ) ) ; setmsg . setCurrent_gps_lon ( mAimsicdService . lastKnownLocation ( ) . getLongitudeInDegrees ( ) ) ; dbacess . open ( ) ; dbacess . storeCapturedSms ( setmsg ) ; dbacess . close ( ) ; MiscUtils . startPopUpInfo ( tContext , 7 ) ; } else if ( SILENT_ONLY_TAGS [ arrayindex ] . split ( "#" ) [ 1 ] . trim ( ) . equals ( "WAPPUSH" ) ) { CapturedSmsData setmsg = new CapturedSmsData ( ) ; setmsg . setSenderNumber ( "unknown" ) ; setmsg . setSenderMsg ( "no data" ) ; int startindex = x - 2 ; int endindex = x + 3 ; if ( progress [ x + 3 ] . contains ( "DestPort 0x0B84" ) ) { Log . i ( TAG , "WAPPUSH DETECTED" ) ; if ( endindex + 3 <= progress . length ) { while ( startindex < endindex ) { if ( progress [ startindex ] . contains ( DETECTION_PHONENUM_SMS_DATA [ 2 ] . toString ( ) ) ) { try { String number = progress [ startindex ] . substring ( progress [ startindex ] . indexOf ( "OrigAddr" ) ) . replace ( DETECTION_PHONENUM_SMS_DATA [ 2 ] . toString ( ) , "" ) . trim ( ) ; setmsg . setSenderNumber ( number ) ; break ; } catch ( Exception ee ) { Log . e ( TAG , "Error parsing number" ) ; } } startindex ++ ; } } setmsg . setSmsTimestamp ( MiscUtils . getCurrentTimeStamp ( ) ) ; setmsg . setSmsType ( "WAPPUSH" ) ; setmsg . setCurrent_lac ( mAimsicdService . getCellTracker ( ) . getMonitorCell ( ) . getLAC ( ) ) ; setmsg . setCurrent_cid ( mAimsicdService . getCellTracker ( ) . getMonitorCell ( ) . getCID ( ) ) ; setmsg . setCurrent_nettype ( Device . getNetworkTypeName ( mAimsicdService . getCell ( ) . getNetType ( ) ) ) ; setmsg . setCurrent_roam_status ( mAimsicdService . getCellTracker ( ) . getDevice ( ) . isRoaming ( ) ) ; setmsg . setCurrent_gps_lat ( mAimsicdService . lastKnownLocation ( ) . getLatitudeInDegrees ( ) ) ; setmsg . setCurrent_gps_lon ( mAimsicdService . lastKnownLocation ( ) . getLongitudeInDegrees ( ) ) ; dbacess . open ( ) ; dbacess . storeCapturedSms ( setmsg ) ; dbacess . close ( ) ; MiscUtils . startPopUpInfo ( tContext , 8 ) ; } } break ; } } } } } private final ServiceConnection mConnection = new ServiceConnection ( ) { @ Override public void onServiceConnected ( ComponentName name , IBinder service ) { mAimsicdService = ( ( AimsicdService . AimscidBinder ) service ) . getService ( ) ; mBound = true ; } @ Override public void onServiceDisconnected ( ComponentName arg0 ) { Log . e ( TAG , "Service Disconnected Sms Detection" ) ; mBound = false ; } } ; }
package com . SecUpwN . AIMSICD . constants ; public class DrawerMenu { public static class ID { public static final int SECTION_MAIN = 10 ; public static final int SECTION_TRACKING = 20 ; public static final int SECTION_SETTINGS = 30 ; public static final int SECTION_APPLICATION = 40 ; public static class MAIN { public static final int CURRENT_TREAT_LEVEL = 100 ; public static final int PHONE_SIM_DETAILS = 110 ; public static final int ACD = 120 ; public static final int DB_VIEWER = 130 ; public static final int ANTENNA_MAP_VIEW = 140 ; public static final int AT_COMMAND_INTERFACE = 150 ; } public static class TRACKING { public static final int TOGGLE_AIMSICD_MONITORING = 200 ; public static final int TOGGLE_2G_ONLY_NETWORK = 210 ; public static final int TRACK_FEMTOCELL = 220 ; } public static class SETTINGS { public static final int PREFERENCES = 300 ; public static final int BACKUP_DB = 310 ; public static final int RESTORE_DB = 320 ; public static final int RESET_DB = 330 ; public static final int EXPORT_DB_TO_CVS = 340 ; public static final int IMPORT_DB_FROM_CVS = 350 ; } public static class APPLICATION { public static final int DOWNLOAD_LOCAL_BST_DATA = 400 ; public static final int UPLOAD_LOCAL_BST_DATA = 410 ; public static final int ADD_GET_OCID_API_KEY = 420 ; public static final int ABOUT = 430 ; public static final int SEND_DEBUGGING_LOG = 440 ; public static final int FAQ = 450 ; public static final int QUIT = 460 ; } } public final static int COUNT_OF_MENU_TYPE = 2 ; }
package com . SecUpwN . AIMSICD . constants ; public class TinyDbKeys { public final static String FINISHED_LOAD_IN_MAP = "FINISHED_LOAD_IN_MAP" ; }
package com . SecUpwN . AIMSICD . constants ; public class Examples { public static class EVENT_LOG_DATA { public static final String LAC = "12345" ; public static final String CID = "543210" ; public static final String PSC = "111" ; public static final String GPSD_LAT = "54.6" ; public static final String GPSD_LON = "25.2" ; public static final String GPSD_ACCU = "100" ; public static final String DF_ID = "2" ; } public static class SILENT_SMS_CARD_DATA { public static final String ADDRESS = "ADREZZ" ; public static final String DISPLAY = "DizzPlay" ; } }
package com . SecUpwN . AIMSICD . service ; import android . content . Context ; import android . hardware . Sensor ; import android . hardware . SensorEvent ; import android . hardware . SensorEventListener ; import android . hardware . SensorManager ; import android . util . Log ; public class AccelerometerMonitor { public static final long MOVEMENT_THRESHOLD_MS = 20 * 1000 ; private final float ACCELEROMETER_NOISE = 2.0f ; private long lastMovementTime = 0 ; private float mLastX , mLastY , mLastZ ; private boolean mInitialized ; private SensorManager mSensorManager ; private Sensor mAccelerometer ; private SensorEventListener mSensorListener ; private Runnable onMovement ; AccelerometerMonitor ( Context context , Runnable onMovement ) { setupAccelerometer ( context ) ; this . onMovement = onMovement ; } private void setupAccelerometer ( Context context ) { mSensorManager = ( SensorManager ) context . getSystemService ( Context . SENSOR_SERVICE ) ; mAccelerometer = mSensorManager . getDefaultSensor ( Sensor . TYPE_ACCELEROMETER ) ; mSensorListener = new SensorEventListener ( ) { @ Override public void onSensorChanged ( SensorEvent event ) { float x = event . values [ 0 ] ; float y = event . values [ 1 ] ; float z = event . values [ 2 ] ; if ( ! mInitialized ) { mLastX = x ; mLastY = y ; mLastZ = z ; mInitialized = true ; } else { float deltaX = Math . abs ( mLastX - x ) ; float deltaY = Math . abs ( mLastY - y ) ; float deltaZ = Math . abs ( mLastZ - z ) ; if ( deltaX < ACCELEROMETER_NOISE ) deltaX = 0.0f ; if ( deltaY < ACCELEROMETER_NOISE ) deltaY = 0.0f ; if ( deltaZ < ACCELEROMETER_NOISE ) deltaZ = 0.0f ; mLastX = x ; mLastY = y ; mLastZ = z ; if ( deltaX > 0 || deltaY > 0 || deltaZ > 0 ) { stop ( ) ; lastMovementTime = System . currentTimeMillis ( ) ; if ( onMovement != null ) onMovement . run ( ) ; } } } @ Override public void onAccuracyChanged ( Sensor sensor , int i ) { } } ; start ( ) ; } public void start ( ) { mSensorManager . registerListener ( mSensorListener , mAccelerometer , SensorManager . SENSOR_DELAY_NORMAL ) ; } public void stop ( ) { mSensorManager . unregisterListener ( mSensorListener ) ; } public boolean notMovedInAWhile ( ) { return System . currentTimeMillis ( ) - lastMovementTime >= MOVEMENT_THRESHOLD_MS ; } }
package com . SecUpwN . AIMSICD . service ; import android . annotation . TargetApi ; import android . content . Context ; import android . content . SharedPreferences ; import android . location . Location ; import android . location . LocationListener ; import android . location . LocationManager ; import android . os . Build ; import android . os . Bundle ; import android . util . Log ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . adapters . AIMSICDDbAdapter ; import com . SecUpwN . AIMSICD . utils . Cell ; import com . SecUpwN . AIMSICD . utils . GeoLocation ; public class LocationTracker { public static final long MOVEMENT_THRESHOLD_MS = 20 * 1000 ; private AimsicdService context ; private SharedPreferences prefs ; private static LocationManager lm ; private LocationListener mLocationListener ; private LocationListener extLocationListener ; private long lastLocationTime = 0 ; private Location lastLocation ; private static final long GPS_MIN_UPDATE_TIME = 10000 ; private static final float GPS_MIN_UPDATE_DISTANCE = 10 ; LocationTracker ( AimsicdService service , LocationListener extLocationListener ) { this . context = service ; this . extLocationListener = extLocationListener ; lm = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; mLocationListener = new MyLocationListener ( ) ; prefs = context . getSharedPreferences ( AimsicdService . SHARED_PREFERENCES_BASENAME , 0 ) ; } public void start ( ) { lastKnownLocation ( ) ; try { lm . requestLocationUpdates ( LocationManager . GPS_PROVIDER , GPS_MIN_UPDATE_TIME , GPS_MIN_UPDATE_DISTANCE , mLocationListener ) ; } catch ( IllegalArgumentException e ) { } try { lm . requestLocationUpdates ( LocationManager . PASSIVE_PROVIDER , GPS_MIN_UPDATE_TIME , GPS_MIN_UPDATE_DISTANCE , mLocationListener ) ; } catch ( IllegalArgumentException e ) { } try { lm . requestLocationUpdates ( LocationManager . NETWORK_PROVIDER , GPS_MIN_UPDATE_TIME , GPS_MIN_UPDATE_DISTANCE , mLocationListener ) ; } catch ( IllegalArgumentException e ) { } } public void stop ( ) { lm . removeUpdates ( mLocationListener ) ; } public boolean isGPSOn ( ) { return lm . isProviderEnabled ( LocationManager . GPS_PROVIDER ) ; } public boolean notMovedInAWhile ( ) { if ( lastLocationTime <= 0 ) return true ; if ( System . currentTimeMillis ( ) - lastLocationTime > MOVEMENT_THRESHOLD_MS ) return true ; return false ; } public GeoLocation lastKnownLocation ( ) { GeoLocation loc = null ; Location location = lm . getLastKnownLocation ( LocationManager . GPS_PROVIDER ) ; if ( location != null && ( location . getLatitude ( ) != 0.0 && location . getLongitude ( ) != 0.0 ) ) { loc = GeoLocation . fromDegrees ( location . getLatitude ( ) , location . getLongitude ( ) ) ; } else { location = lm . getLastKnownLocation ( LocationManager . NETWORK_PROVIDER ) ; if ( location != null && ( location . getLatitude ( ) != 0.0 && location . getLongitude ( ) != 0.0 ) ) { loc = GeoLocation . fromDegrees ( location . getLatitude ( ) , location . getLongitude ( ) ) ; } else { String coords = prefs . getString ( context . getString ( R . string . data_last_lat_lon ) , null ) ; if ( coords != null ) { String [ ] coord = coords . split ( ":" ) ; loc = GeoLocation . fromDegrees ( Double . valueOf ( coord [ 0 ] ) , Double . valueOf ( coord [ 1 ] ) ) ; } else { try { Cell cell = context . getCell ( ) ; if ( cell != null ) { Log . d ( "location" , "Looking up MCC " + cell . getMCC ( ) ) ; AIMSICDDbAdapter mDbHelper = new AIMSICDDbAdapter ( context ) ; mDbHelper . open ( ) ; double [ ] defLoc = mDbHelper . getDefaultLocation ( cell . getMCC ( ) ) ; mDbHelper . close ( ) ; loc = GeoLocation . fromDegrees ( defLoc [ 0 ] , defLoc [ 1 ] ) ; } } catch ( Exception e ) { Log . e ( "location" , "Unable to get location from MCC" , e ) ; } } } } if ( loc != null ) Log . i ( "location" , "Last known location " + loc . toString ( ) ) ; return loc ; } private class MyLocationListener implements LocationListener { @ TargetApi ( Build . VERSION_CODES . JELLY_BEAN_MR2 ) @ Override public void onLocationChanged ( Location loc ) { if ( lastLocation != null && lastLocation . getLongitude ( ) == loc . getLongitude ( ) && lastLocation . getLatitude ( ) == loc . getLatitude ( ) ) { return ; } lastLocationTime = System . currentTimeMillis ( ) ; extLocationListener . onLocationChanged ( loc ) ; } @ Override public void onProviderDisabled ( String provider ) { extLocationListener . onProviderDisabled ( provider ) ; } @ Override public void onProviderEnabled ( String provider ) { extLocationListener . onProviderEnabled ( provider ) ; } @ Override public void onStatusChanged ( String provider , int status , Bundle extras ) { extLocationListener . onStatusChanged ( provider , status , extras ) ; } } }
package com . SecUpwN . AIMSICD . service ; import android . app . AlertDialog ; import android . app . Notification ; import android . app . NotificationManager ; import android . app . PendingIntent ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . SharedPreferences ; import android . location . Location ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . os . SystemClock ; import android . support . v4 . app . NotificationCompat ; import android . telephony . CellInfo ; import android . telephony . CellLocation ; import android . telephony . NeighboringCellInfo ; import android . telephony . PhoneStateListener ; import android . telephony . ServiceState ; import android . telephony . SignalStrength ; import android . telephony . TelephonyManager ; import android . telephony . cdma . CdmaCellLocation ; import android . telephony . gsm . GsmCellLocation ; import android . util . Log ; import android . view . WindowManager ; import com . SecUpwN . AIMSICD . AIMSICD ; import com . SecUpwN . AIMSICD . BuildConfig ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . adapters . AIMSICDDbAdapter ; import com . SecUpwN . AIMSICD . utils . Cell ; import com . SecUpwN . AIMSICD . utils . Device ; import com . SecUpwN . AIMSICD . utils . DeviceApi17 ; import com . SecUpwN . AIMSICD . utils . Helpers ; import com . SecUpwN . AIMSICD . utils . Icon ; import com . SecUpwN . AIMSICD . utils . Status ; import com . SecUpwN . AIMSICD . utils . TinyDB ; import org . apache . http . HttpResponse ; import org . apache . http . StatusLine ; import org . apache . http . client . methods . HttpGet ; import org . apache . http . impl . client . DefaultHttpClient ; import java . io . ByteArrayOutputStream ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . TimeUnit ; public class CellTracker implements SharedPreferences . OnSharedPreferenceChangeListener { private final String TAG = "AIMSICD" ; private final String mTAG = "CellTracker" ; public static String OCID_API_KEY = null ; private final int NOTIFICATION_ID = 1 ; private static TelephonyManager tm ; private final SignalStrengthTracker signalStrengthTracker ; private PhoneStateListener mPhoneStateListener ; private SharedPreferences prefs ; public static int PHONE_TYPE ; public static long REFRESH_RATE ; public static int LAST_DB_BACKUP_VERSION ; public static final String SILENT_SMS = "SILENT_SMS_DETECTED" ; private boolean CELL_TABLE_CLEANSED ; private final Device mDevice = new Device ( ) ; private boolean mMonitoringCell ; private boolean mTrackingCell ; private boolean mTrackingFemtocell ; private boolean mFemtoDetected ; private boolean mChangedLAC ; private boolean mCellIdNotInOpenDb ; private Cell mMonitorCell ; private boolean mTypeZeroSmsDetected ; private LinkedBlockingQueue < NeighboringCellInfo > neighboringCellBlockingQueue ; private final AIMSICDDbAdapter dbHelper ; private static Context context ; private final Handler timerHandler = new Handler ( ) ; TinyDB tinydb ; public CellTracker ( Context context , SignalStrengthTracker sst ) { this . context = context ; this . signalStrengthTracker = sst ; tinydb = TinyDB . getInstance ( ) ; tm = ( TelephonyManager ) context . getSystemService ( Context . TELEPHONY_SERVICE ) ; prefs = context . getSharedPreferences ( AimsicdService . SHARED_PREFERENCES_BASENAME , 0 ) ; prefs . registerOnSharedPreferenceChangeListener ( this ) ; loadPreferences ( ) ; setNotification ( ) ; PHONE_TYPE = tm . getPhoneType ( ) ; dbHelper = new AIMSICDDbAdapter ( context ) ; if ( ! CELL_TABLE_CLEANSED ) { dbHelper . open ( ) ; dbHelper . cleanseCellTable ( ) ; dbHelper . close ( ) ; SharedPreferences . Editor prefsEditor ; prefsEditor = prefs . edit ( ) ; prefsEditor . putBoolean ( context . getString ( R . string . pref_cell_table_cleansed ) , true ) ; prefsEditor . apply ( ) ; } mDevice . refreshDeviceInfo ( tm , context ) ; mMonitorCell = new Cell ( ) ; context . registerReceiver ( mMessageReceiver , new IntentFilter ( SILENT_SMS ) ) ; } public boolean isTrackingCell ( ) { return mTrackingCell ; } public boolean isMonitoringCell ( ) { return mMonitoringCell ; } public void setCellMonitoring ( boolean monitor ) { if ( monitor ) { mMonitoringCell = true ; Helpers . msgShort ( context , context . getString ( R . string . monitoring_cell_information ) ) ; } else { mMonitoringCell = false ; Helpers . msgShort ( context , context . getString ( R . string . stopped_monitoring_cell_information ) ) ; } setNotification ( ) ; } public Device getDevice ( ) { return mDevice ; } public boolean isTrackingFemtocell ( ) { return mTrackingFemtocell ; } public void stop ( ) { if ( isMonitoringCell ( ) ) { setCellMonitoring ( false ) ; } if ( isTrackingCell ( ) ) { setCellTracking ( false ) ; } if ( isTrackingFemtocell ( ) ) { stopTrackingFemto ( ) ; } cancelNotification ( ) ; tm . listen ( mCellSignalListener , PhoneStateListener . LISTEN_NONE ) ; prefs . unregisterOnSharedPreferenceChangeListener ( this ) ; context . unregisterReceiver ( mMessageReceiver ) ; } public void setCellTracking ( boolean track ) { if ( track ) { tm . listen ( mCellSignalListener , PhoneStateListener . LISTEN_CELL_LOCATION | PhoneStateListener . LISTEN_SIGNAL_STRENGTHS | PhoneStateListener . LISTEN_DATA_ACTIVITY | PhoneStateListener . LISTEN_DATA_CONNECTION_STATE | PhoneStateListener . LISTEN_CELL_INFO ) ; mTrackingCell = true ; Helpers . msgShort ( context , context . getString ( R . string . tracking_cell_information ) ) ; } else { tm . listen ( mCellSignalListener , PhoneStateListener . LISTEN_NONE ) ; mDevice . mCell . setLon ( 0.0 ) ; mDevice . mCell . setLat ( 0.0 ) ; mDevice . setCellInfo ( "[0,0]|nn|nn|" ) ; mTrackingCell = false ; Helpers . msgShort ( context , context . getString ( R . string . stopped_tracking_cell_information ) ) ; } setNotification ( ) ; } private final BroadcastReceiver mMessageReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { final Bundle bundle = intent . getExtras ( ) ; if ( bundle != null ) { dbHelper . open ( ) ; dbHelper . insertSilentSms ( bundle ) ; dbHelper . close ( ) ; setSilentSmsStatus ( true ) ; } } } ; public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , String key ) { final String KEY_UI_ICONS = context . getString ( R . string . pref_ui_icons_key ) ; final String FEMTO_DETECTION = context . getString ( R . string . pref_femto_detection_key ) ; final String REFRESH = context . getString ( R . string . pref_refresh_key ) ; final String DB_VERSION = context . getString ( R . string . pref_last_database_backup_version ) ; final String OCID_KEY = context . getString ( R . string . pref_ocid_key ) ; if ( key . equals ( KEY_UI_ICONS ) ) { setNotification ( ) ; } else if ( key . equals ( FEMTO_DETECTION ) ) { boolean trackFemtoPref = sharedPreferences . getBoolean ( FEMTO_DETECTION , false ) ; if ( trackFemtoPref ) { startTrackingFemto ( ) ; } else { stopTrackingFemto ( ) ; } } else if ( key . equals ( REFRESH ) ) { String refreshRate = sharedPreferences . getString ( REFRESH , "1" ) ; if ( refreshRate . isEmpty ( ) ) { refreshRate = "1" ; } int rate = Integer . parseInt ( refreshRate ) ; long t ; switch ( rate ) { case 1 : t = 15L ; break ; default : t = ( rate * 1L ) ; break ; } REFRESH_RATE = TimeUnit . SECONDS . toMillis ( t ) ; } else if ( key . equals ( DB_VERSION ) ) { LAST_DB_BACKUP_VERSION = sharedPreferences . getInt ( DB_VERSION , 1 ) ; } else if ( key . equals ( OCID_KEY ) ) { getOcidKey ( ) ; } } public void getOcidKey ( ) { final String OCID_KEY = context . getString ( R . string . pref_ocid_key ) ; OCID_API_KEY = prefs . getString ( OCID_KEY , BuildConfig . OPEN_CELLID_API_KEY ) ; if ( OCID_API_KEY == null ) { OCID_API_KEY = "NA" ; } } public static String requestNewOCIDKey ( ) throws Exception { String responseFromServer = null ; DefaultHttpClient httpclient = new DefaultHttpClient ( ) ; HttpGet httpGet = new HttpGet ( "http://opencellid.org/gsmCell/user/generateApiKey" ) ; HttpResponse result = httpclient . execute ( httpGet ) ; StatusLine status = result . getStatusLine ( ) ; if ( status . getStatusCode ( ) == 200 ) { if ( result . getEntity ( ) != null ) { InputStream is = result . getEntity ( ) . getContent ( ) ; ByteArrayOutputStream content = new ByteArrayOutputStream ( ) ; int readBytes ; byte [ ] sBuffer = new byte [ 4096 ] ; while ( ( readBytes = is . read ( sBuffer ) ) != - 1 ) { content . write ( sBuffer , 0 , readBytes ) ; } responseFromServer = content . toString ( "UTF-8" ) ; result . getEntity ( ) . consumeContent ( ) ; } Log . d ( "OCID" , responseFromServer ) ; return responseFromServer ; } else if ( status . getStatusCode ( ) == 503 ) { Helpers . msgLong ( context , context . getString ( R . string . only_one_api_per_day ) ) ; if ( result . getEntity ( ) != null ) { InputStream is = result . getEntity ( ) . getContent ( ) ; ByteArrayOutputStream content = new ByteArrayOutputStream ( ) ; int readBytes = 0 ; byte [ ] sBuffer = new byte [ 4096 ] ; while ( ( readBytes = is . read ( sBuffer ) ) != - 1 ) { content . write ( sBuffer , 0 , readBytes ) ; } responseFromServer = content . toString ( "UTF-8" ) ; result . getEntity ( ) . consumeContent ( ) ; } Log . d ( "AIMSICD" , "CellTracker: OCID Reached 24hr API key limit: " + responseFromServer ) ; return responseFromServer ; } else { httpclient = null ; httpGet = null ; result = null ; Log . d ( "AIMSICD" , "CellTracker: OCID Returned " + status . getStatusCode ( ) + " " + status . getReasonPhrase ( ) ) ; throw new Exception ( "OCID Returned " + status . getStatusCode ( ) + " " + status . getReasonPhrase ( ) ) ; } } public List < Cell > updateNeighbouringCells ( ) { List < Cell > neighboringCells = new ArrayList < > ( ) ; List < NeighboringCellInfo > neighboringCellInfo = tm . getNeighboringCellInfo ( ) ; if ( neighboringCellInfo == null ) neighboringCellInfo = new ArrayList < > ( ) ; if ( neighboringCellInfo != null && neighboringCellInfo . size ( ) == 0 ) { neighboringCellBlockingQueue = new LinkedBlockingQueue < > ( 100 ) ; Log . i ( TAG , mTAG + ": neighbouringCellInfo empty - start polling" ) ; if ( Build . VERSION . SDK_INT > 16 ) { DeviceApi17 . startListening ( tm , phoneStatelistener ) ; } else { tm . listen ( phoneStatelistener , PhoneStateListener . LISTEN_CELL_LOCATION | PhoneStateListener . LISTEN_CELL_INFO | PhoneStateListener . LISTEN_DATA_CONNECTION_STATE | PhoneStateListener . LISTEN_SERVICE_STATE | PhoneStateListener . LISTEN_SIGNAL_STRENGTHS ) ; } for ( int i = 0 ; i < 10 && neighboringCellInfo . size ( ) == 0 ; i ++ ) { try { Log . d ( TAG , mTAG + ": neighbouringCellInfo empty: trying " + i ) ; NeighboringCellInfo info = neighboringCellBlockingQueue . poll ( 1 , TimeUnit . SECONDS ) ; if ( info == null ) { neighboringCellInfo = tm . getNeighboringCellInfo ( ) ; if ( neighboringCellInfo != null ) if ( neighboringCellInfo . size ( ) > 0 ) { Log . d ( TAG , mTAG + ": neighbouringCellInfo found on " + i + " try. (time based)" ) ; break ; } else { continue ; } } ArrayList < NeighboringCellInfo > cellInfoList = new ArrayList < > ( neighboringCellBlockingQueue . size ( ) + 1 ) ; while ( info != null ) { cellInfoList . add ( info ) ; info = neighboringCellBlockingQueue . poll ( 1 , TimeUnit . SECONDS ) ; } neighboringCellInfo = cellInfoList ; } catch ( InterruptedException e ) { } } } for ( NeighboringCellInfo neighbourCell : neighboringCellInfo ) { Log . i ( TAG , mTAG + ": neighbouringCellInfo -" + " LAC:" + neighbourCell . getLac ( ) + " CID:" + neighbourCell . getCid ( ) + " PSC:" + neighbourCell . getPsc ( ) + " RSSI:" + neighbourCell . getRssi ( ) ) ; final Cell cell = new Cell ( neighbourCell . getCid ( ) , neighbourCell . getLac ( ) , neighbourCell . getRssi ( ) , neighbourCell . getPsc ( ) , neighbourCell . getNetworkType ( ) , false ) ; neighboringCells . add ( cell ) ; } return neighboringCells ; } public void checkForNeighbourCount ( CellLocation location ) { Log . i ( mTAG , "in checkForNeighbourCount" ) ; Integer ncls = 0 ; if ( tm != null && tm . getNeighboringCellInfo ( ) != null ) ncls = tm . getNeighboringCellInfo ( ) . size ( ) ; Boolean nclp = tinydb . getBoolean ( "nc_list_present" ) ; if ( ncls > 0 ) { tinydb . putBoolean ( "nc_list_present" , true ) ; Log . d ( TAG , mTAG + ": neighbouringCellInfo size: " + ncls ) ; Log . d ( TAG , mTAG + ": Setting nc_list_present to: true" ) ; } else if ( ncls == 0 && nclp ) { Log . i ( TAG , mTAG + ": ALERT: No neighboring cells detected for CID: " + mDevice . mCell . getCID ( ) ) ; } else { Log . d ( TAG , mTAG + ": NC list not supported by AOS on this device. Nothing to do. CID: " + mDevice . mCell . getCID ( ) ) ; Log . d ( TAG , mTAG + ": Setting nc_list_present to: false" ) ; tinydb . putBoolean ( "nc_list_present" , false ) ; } } public void compareLac ( CellLocation location ) { switch ( mDevice . getPhoneID ( ) ) { case TelephonyManager . PHONE_TYPE_NONE : case TelephonyManager . PHONE_TYPE_SIP : case TelephonyManager . PHONE_TYPE_GSM : GsmCellLocation gsmCellLocation = ( GsmCellLocation ) location ; if ( gsmCellLocation != null ) { mMonitorCell . setLAC ( gsmCellLocation . getLac ( ) ) ; mMonitorCell . setCID ( gsmCellLocation . getCid ( ) ) ; dbHelper . open ( ) ; boolean lacOK = dbHelper . checkLAC ( mMonitorCell ) ; if ( ! lacOK ) { mChangedLAC = true ; setNotification ( ) ; } else { mChangedLAC = false ; } if ( tinydb . getBoolean ( "ocid_downloaded" ) ) { if ( ! dbHelper . openCellExists ( mMonitorCell . getCID ( ) ) ) { Log . i ( mTAG , "ALERT: Connected to unknown CID not in DBe_import: " + mMonitorCell . getCID ( ) ) ; mCellIdNotInOpenDb = true ; setNotification ( ) ; } else { mCellIdNotInOpenDb = false ; } dbHelper . close ( ) ; } } break ; case TelephonyManager . PHONE_TYPE_CDMA : CdmaCellLocation cdmaCellLocation = ( CdmaCellLocation ) location ; if ( cdmaCellLocation != null ) { mMonitorCell . setLAC ( cdmaCellLocation . getNetworkId ( ) ) ; mMonitorCell . setCID ( cdmaCellLocation . getBaseStationId ( ) ) ; dbHelper . open ( ) ; boolean lacOK = dbHelper . checkLAC ( mMonitorCell ) ; if ( ! lacOK ) { mChangedLAC = true ; setNotification ( ) ; } else { mChangedLAC = false ; } dbHelper . close ( ) ; } } } private void handlePhoneStateChange ( ) { List < NeighboringCellInfo > neighboringCellInfo = tm . getNeighboringCellInfo ( ) ; if ( neighboringCellInfo == null || neighboringCellInfo . size ( ) == 0 ) { return ; } Log . i ( TAG , mTAG + ": neighbouringCellInfo empty - event based polling succeeded!" ) ; tm . listen ( phoneStatelistener , PhoneStateListener . LISTEN_NONE ) ; if ( neighboringCellInfo == null ) neighboringCellInfo = new ArrayList < > ( ) ; neighboringCellBlockingQueue . addAll ( neighboringCellInfo ) ; } public void refreshDevice ( ) { mDevice . refreshDeviceInfo ( tm , context ) ; } private void loadPreferences ( ) { boolean trackFemtoPref = prefs . getBoolean ( context . getString ( R . string . pref_femto_detection_key ) , false ) ; boolean trackCellPref = prefs . getBoolean ( context . getString ( R . string . pref_enable_cell_key ) , true ) ; boolean monitorCellPref = prefs . getBoolean ( context . getString ( R . string . pref_enable_cell_monitoring_key ) , true ) ; LAST_DB_BACKUP_VERSION = prefs . getInt ( context . getString ( R . string . pref_last_database_backup_version ) , 1 ) ; CELL_TABLE_CLEANSED = prefs . getBoolean ( context . getString ( R . string . pref_cell_table_cleansed ) , false ) ; String refreshRate = prefs . getString ( context . getString ( R . string . pref_refresh_key ) , "1" ) ; if ( refreshRate . isEmpty ( ) ) { refreshRate = "1" ; } int rate = Integer . parseInt ( refreshRate ) ; long t ; switch ( rate ) { case 1 : t = 15L ; break ; default : t = ( rate * 1L ) ; break ; } REFRESH_RATE = TimeUnit . SECONDS . toMillis ( t ) ; getOcidKey ( ) ; if ( trackFemtoPref ) { startTrackingFemto ( ) ; } if ( trackCellPref ) { setCellTracking ( true ) ; } if ( monitorCellPref ) { setCellMonitoring ( true ) ; } } private final PhoneStateListener mCellSignalListener = new PhoneStateListener ( ) { public void onCellLocationChanged ( CellLocation location ) { checkForNeighbourCount ( location ) ; compareLac ( location ) ; refreshDevice ( ) ; mDevice . setNetID ( tm ) ; mDevice . getNetworkTypeName ( ) ; switch ( mDevice . getPhoneID ( ) ) { case TelephonyManager . PHONE_TYPE_NONE : case TelephonyManager . PHONE_TYPE_SIP : case TelephonyManager . PHONE_TYPE_GSM : GsmCellLocation gsmCellLocation = ( GsmCellLocation ) location ; if ( gsmCellLocation != null ) { mDevice . setCellInfo ( gsmCellLocation . toString ( ) + mDevice . getDataActivityTypeShort ( ) + "|" + mDevice . getDataStateShort ( ) + "|" + mDevice . getNetworkTypeName ( ) + "|" ) ; mDevice . mCell . setLAC ( gsmCellLocation . getLac ( ) ) ; mDevice . mCell . setCID ( gsmCellLocation . getCid ( ) ) ; if ( gsmCellLocation . getPsc ( ) != - 1 ) mDevice . mCell . setPSC ( gsmCellLocation . getPsc ( ) ) ; } break ; case TelephonyManager . PHONE_TYPE_CDMA : CdmaCellLocation cdmaCellLocation = ( CdmaCellLocation ) location ; if ( cdmaCellLocation != null ) { mDevice . setCellInfo ( cdmaCellLocation . toString ( ) + mDevice . getDataActivityTypeShort ( ) + "|" + mDevice . getDataStateShort ( ) + "|" + mDevice . getNetworkTypeName ( ) + "|" ) ; mDevice . mCell . setLAC ( cdmaCellLocation . getNetworkId ( ) ) ; mDevice . mCell . setCID ( cdmaCellLocation . getBaseStationId ( ) ) ; mDevice . mCell . setSID ( cdmaCellLocation . getSystemId ( ) ) ; mDevice . mCell . setMNC ( cdmaCellLocation . getSystemId ( ) ) ; mDevice . setNetworkName ( tm . getNetworkOperatorName ( ) ) ; } } } public void onSignalStrengthsChanged ( SignalStrength signalStrength ) { if ( signalStrength . isGsm ( ) ) { int dbm ; if ( signalStrength . getGsmSignalStrength ( ) <= 2 || signalStrength . getGsmSignalStrength ( ) == NeighboringCellInfo . UNKNOWN_RSSI ) { String [ ] bits = signalStrength . toString ( ) . split ( " " ) ; dbm = Integer . parseInt ( bits [ 9 ] ) ; } else { dbm = signalStrength . getGsmSignalStrength ( ) ; } mDevice . setSignalDbm ( dbm ) ; } else { int evdoDbm = signalStrength . getEvdoDbm ( ) ; int cdmaDbm = signalStrength . getCdmaDbm ( ) ; mDevice . setSignalDbm ( ( cdmaDbm < evdoDbm ) ? cdmaDbm : evdoDbm ) ; } signalStrengthTracker . registerSignalStrength ( mDevice . mCell . getCID ( ) , mDevice . getSignalDBm ( ) ) ; } public void onDataActivity ( int direction ) { switch ( direction ) { case TelephonyManager . DATA_ACTIVITY_NONE : mDevice . setDataActivityTypeShort ( "No" ) ; mDevice . setDataActivityType ( "None" ) ; break ; case TelephonyManager . DATA_ACTIVITY_IN : mDevice . setDataActivityTypeShort ( "In" ) ; mDevice . setDataActivityType ( "In" ) ; break ; case TelephonyManager . DATA_ACTIVITY_OUT : mDevice . setDataActivityTypeShort ( "Ou" ) ; mDevice . setDataActivityType ( "Out" ) ; break ; case TelephonyManager . DATA_ACTIVITY_INOUT : mDevice . setDataActivityTypeShort ( "IO" ) ; mDevice . setDataActivityType ( "In-Out" ) ; break ; case TelephonyManager . DATA_ACTIVITY_DORMANT : mDevice . setDataActivityTypeShort ( "Do" ) ; mDevice . setDataActivityType ( "Dormant" ) ; break ; } } public void onDataConnectionStateChanged ( int state ) { switch ( state ) { case TelephonyManager . DATA_DISCONNECTED : mDevice . setDataState ( "Disconnected" ) ; mDevice . setDataStateShort ( "Di" ) ; break ; case TelephonyManager . DATA_CONNECTING : mDevice . setDataState ( "Connecting" ) ; mDevice . setDataStateShort ( "Ct" ) ; break ; case TelephonyManager . DATA_CONNECTED : mDevice . setDataState ( "Connected" ) ; mDevice . setDataStateShort ( "Cd" ) ; break ; case TelephonyManager . DATA_SUSPENDED : mDevice . setDataState ( "Suspended" ) ; mDevice . setDataStateShort ( "Su" ) ; break ; } } } ; void setSilentSmsStatus ( boolean state ) { mTypeZeroSmsDetected = state ; setNotification ( ) ; if ( state ) { final AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setMessage ( R . string . sms_message ) . setTitle ( R . string . sms_title ) ; AlertDialog alert = builder . create ( ) ; alert . getWindow ( ) . setType ( WindowManager . LayoutParams . TYPE_SYSTEM_ALERT ) ; alert . show ( ) ; mTypeZeroSmsDetected = false ; } } public void onLocationChanged ( Location loc ) { if ( Build . VERSION . SDK_INT > 16 ) { DeviceApi17 . loadCellInfo ( tm , mDevice ) ; } if ( ! mDevice . mCell . isValid ( ) ) { CellLocation cellLocation = tm . getCellLocation ( ) ; if ( cellLocation != null ) { switch ( mDevice . getPhoneID ( ) ) { case TelephonyManager . PHONE_TYPE_NONE : case TelephonyManager . PHONE_TYPE_SIP : case TelephonyManager . PHONE_TYPE_GSM : GsmCellLocation gsmCellLocation = ( GsmCellLocation ) cellLocation ; mDevice . mCell . setCID ( gsmCellLocation . getCid ( ) ) ; mDevice . mCell . setLAC ( gsmCellLocation . getLac ( ) ) ; mDevice . mCell . setPSC ( gsmCellLocation . getPsc ( ) ) ; break ; case TelephonyManager . PHONE_TYPE_CDMA : CdmaCellLocation cdmaCellLocation = ( CdmaCellLocation ) cellLocation ; mDevice . mCell . setCID ( cdmaCellLocation . getBaseStationId ( ) ) ; mDevice . mCell . setLAC ( cdmaCellLocation . getNetworkId ( ) ) ; mDevice . mCell . setSID ( cdmaCellLocation . getSystemId ( ) ) ; mDevice . mCell . setMNC ( cdmaCellLocation . getSystemId ( ) ) ; } } } if ( loc != null && ( loc . getLatitude ( ) != 0.0 && loc . getLongitude ( ) != 0.0 ) ) { mDevice . mCell . setLon ( loc . getLongitude ( ) ) ; mDevice . mCell . setLat ( loc . getLatitude ( ) ) ; mDevice . mCell . setSpeed ( loc . getSpeed ( ) ) ; mDevice . mCell . setAccuracy ( loc . getAccuracy ( ) ) ; mDevice . mCell . setBearing ( loc . getBearing ( ) ) ; mDevice . setLastLocation ( loc ) ; SharedPreferences . Editor prefsEditor ; prefsEditor = prefs . edit ( ) ; prefsEditor . putString ( context . getString ( R . string . data_last_lat_lon ) , String . valueOf ( loc . getLatitude ( ) ) + ":" + String . valueOf ( loc . getLongitude ( ) ) ) ; prefsEditor . apply ( ) ; if ( mTrackingCell ) { dbHelper . open ( ) ; dbHelper . insertLocation ( mDevice . mCell . getLAC ( ) , mDevice . mCell . getCID ( ) , mDevice . mCell . getNetType ( ) , mDevice . mCell . getLat ( ) , mDevice . mCell . getLon ( ) , mDevice . mCell . getDBM ( ) , mDevice . getCellInfo ( ) ) ; dbHelper . insertCell ( mDevice . mCell . getLAC ( ) , mDevice . mCell . getCID ( ) , mDevice . mCell . getNetType ( ) , mDevice . mCell . getLat ( ) , mDevice . mCell . getLon ( ) , mDevice . mCell . getDBM ( ) , mDevice . mCell . getMCC ( ) , mDevice . mCell . getMNC ( ) , mDevice . mCell . getAccuracy ( ) , mDevice . mCell . getSpeed ( ) , mDevice . mCell . getBearing ( ) , mDevice . getNetworkTypeName ( ) , SystemClock . currentThreadTimeMillis ( ) ) ; dbHelper . close ( ) ; } } } public void cancelNotification ( ) { NotificationManager notificationManager = ( NotificationManager ) context . getSystemService ( Context . NOTIFICATION_SERVICE ) ; if ( notificationManager != null ) { notificationManager . cancel ( NOTIFICATION_ID ) ; } } void setNotification ( ) { String tickerText ; String contentText = "Phone Type " + mDevice . getPhoneType ( ) ; if ( mFemtoDetected || mTypeZeroSmsDetected ) { Status . setCurrentStatus ( Status . Type . ALARM , this . context ) ; } else if ( mChangedLAC ) { Status . setCurrentStatus ( Status . Type . MEDIUM , this . context ) ; contentText = context . getString ( R . string . hostile_service_area_changing_lac_detected ) ; } else if ( mCellIdNotInOpenDb ) { Status . setCurrentStatus ( Status . Type . MEDIUM , this . context ) ; contentText = context . getString ( R . string . cell_id_doesnt_exist_in_db ) ; } else if ( mTrackingFemtocell || mTrackingCell || mMonitoringCell ) { Status . setCurrentStatus ( Status . Type . NORMAL , this . context ) ; if ( mTrackingFemtocell ) { contentText = context . getString ( R . string . femtocell_detection_active ) ; } else if ( mTrackingCell ) { contentText = context . getString ( R . string . cell_tracking_active ) ; } else { contentText = context . getString ( R . string . cell_monitoring_active ) ; } } else { Status . setCurrentStatus ( Status . Type . IDLE , this . context ) ; } switch ( Status . getStatus ( ) ) { case IDLE : contentText = context . getString ( R . string . phone_type ) + mDevice . getPhoneType ( ) ; tickerText = context . getResources ( ) . getString ( R . string . app_name_short ) + " " + context . getString ( R . string . status_idle ) ; break ; case NORMAL : tickerText = context . getResources ( ) . getString ( R . string . app_name_short ) + " " + context . getString ( R . string . status_good ) ; break ; case MEDIUM : tickerText = context . getResources ( ) . getString ( R . string . app_name_short ) ; if ( mChangedLAC ) { contentText = context . getString ( R . string . hostile_service_area_changing_lac_detected ) ; tickerText += " - " + contentText ; } else if ( mCellIdNotInOpenDb ) { contentText = context . getString ( R . string . cell_id_doesnt_exist_in_db ) ; tickerText += " - " + contentText ; } break ; case ALARM : tickerText = context . getResources ( ) . getString ( R . string . app_name_short ) + " - " + context . getString ( R . string . alert_threat_detected ) ; if ( mFemtoDetected ) { contentText = context . getString ( R . string . aletr_femtocell_connection_detected ) ; } else if ( mTypeZeroSmsDetected ) { contentText = context . getString ( R . string . alert_silent_sms_detected ) ; } break ; default : tickerText = context . getResources ( ) . getString ( R . string . main_app_name ) ; break ; } Intent notificationIntent = new Intent ( context , AIMSICD . class ) ; notificationIntent . putExtra ( "silent_sms" , mTypeZeroSmsDetected ) ; notificationIntent . addFlags ( Intent . FLAG_ACTIVITY_SINGLE_TOP | Intent . FLAG_FROM_BACKGROUND ) ; PendingIntent contentIntent = PendingIntent . getActivity ( context , NOTIFICATION_ID , notificationIntent , PendingIntent . FLAG_CANCEL_CURRENT ) ; String iconType = prefs . getString ( context . getString ( R . string . pref_ui_icons_key ) , "SENSE" ) . toUpperCase ( ) ; Notification mBuilder = new NotificationCompat . Builder ( context ) . setSmallIcon ( Icon . getIcon ( Icon . Type . valueOf ( iconType ) ) ) . setTicker ( tickerText ) . setContentTitle ( context . getResources ( ) . getString ( R . string . main_app_name ) ) . setContentText ( contentText ) . setOngoing ( true ) . setAutoCancel ( false ) . setContentIntent ( contentIntent ) . build ( ) ; NotificationManager mNotificationManager = ( NotificationManager ) context . getSystemService ( Context . NOTIFICATION_SERVICE ) ; mNotificationManager . notify ( NOTIFICATION_ID , mBuilder ) ; } public void startTrackingFemto ( ) { if ( mDevice . getPhoneID ( ) != TelephonyManager . PHONE_TYPE_CDMA ) { Helpers . msgShort ( context , context . getString ( R . string . femtocell_only_on_cdma_devices ) ) ; return ; } mTrackingFemtocell = true ; mPhoneStateListener = new PhoneStateListener ( ) { public void onServiceStateChanged ( ServiceState s ) { Log . d ( TAG , mTAG + context . getString ( R . string . service_state_changed ) ) ; getServiceStateInfo ( s ) ; } } ; tm . listen ( mPhoneStateListener , PhoneStateListener . LISTEN_CELL_LOCATION ) ; tm . listen ( mPhoneStateListener , PhoneStateListener . LISTEN_SERVICE_STATE ) ; setNotification ( ) ; } public void stopTrackingFemto ( ) { if ( mPhoneStateListener != null ) { tm . listen ( mPhoneStateListener , PhoneStateListener . LISTEN_NONE ) ; mTrackingFemtocell = false ; setNotification ( ) ; Log . v ( TAG , mTAG + context . getString ( R . string . stopped_tracking_femtocell ) ) ; } } private void getServiceStateInfo ( ServiceState s ) { if ( s != null ) { if ( IsConnectedToCdmaFemto ( s ) ) { Helpers . msgShort ( context , context . getString ( R . string . alert_femtocell_tracking_detected ) ) ; mFemtoDetected = true ; setNotification ( ) ; } else { mFemtoDetected = false ; setNotification ( ) ; } } } private boolean IsConnectedToCdmaFemto ( ServiceState s ) { if ( s == null ) { return false ; } int networkType = mDevice . mCell . getNetType ( ) ; boolean evDoNetwork = isEvDoNetwork ( networkType ) ; if ( ! evDoNetwork ) { if ( tm != null ) { CdmaCellLocation c = ( CdmaCellLocation ) tm . getCellLocation ( ) ; if ( c != null ) { int networkID = c . getNetworkId ( ) ; int FEMTO_NID_MAX = 0xff ; int FEMTO_NID_MIN = 0xfa ; return ! ( ( networkID < FEMTO_NID_MIN ) || ( networkID >= FEMTO_NID_MAX ) ) ; } else { Log . v ( TAG , mTAG + ": Cell location info is null." ) ; return false ; } } else { Log . v ( TAG , mTAG + ": Telephony Manager is null." ) ; return false ; } } else { if ( tm != null ) { CdmaCellLocation c = ( CdmaCellLocation ) tm . getCellLocation ( ) ; if ( c != null ) { int networkID = c . getNetworkId ( ) ; int FEMTO_NID_MAX = 0xff ; int FEMTO_NID_MIN = 0xfa ; return ! ( ( networkID < FEMTO_NID_MIN ) || ( networkID >= FEMTO_NID_MAX ) ) ; } else { Log . v ( TAG , mTAG + ": Cell location info is null." ) ; return false ; } } else { Log . v ( TAG , mTAG + ": Telephony Manager is null." ) ; return false ; } } } private boolean isEvDoNetwork ( int networkType ) { return ( networkType == TelephonyManager . NETWORK_TYPE_EVDO_0 ) || ( networkType == TelephonyManager . NETWORK_TYPE_EVDO_A ) || ( networkType == TelephonyManager . NETWORK_TYPE_EVDO_B ) || ( networkType == TelephonyManager . NETWORK_TYPE_EHRPD ) ; } final PhoneStateListener phoneStatelistener = new PhoneStateListener ( ) { private void handle ( ) { handlePhoneStateChange ( ) ; } @ Override public void onServiceStateChanged ( ServiceState serviceState ) { handle ( ) ; } @ Override public void onDataConnectionStateChanged ( int state ) { handle ( ) ; } @ Override public void onDataConnectionStateChanged ( int state , int networkType ) { handle ( ) ; } @ Override public void onSignalStrengthsChanged ( SignalStrength signalStrength ) { handle ( ) ; } @ Override public void onCellInfoChanged ( List < CellInfo > cellInfo ) { handle ( ) ; Log . i ( mTAG , "Cell info change" ) ; } @ Override public void onCellLocationChanged ( CellLocation location ) { handle ( ) ; Log . i ( mTAG , "Cell info change" ) ; } } ; public Cell getMonitorCell ( ) { return mMonitorCell ; } }
package com . stericson . RootShell . exceptions ; public class RootDeniedException extends Exception { private static final long serialVersionUID = - 8713947214162841310L ; public RootDeniedException ( String error ) { super ( error ) ; } }
package com . SecUpwN . AIMSICD . service ; import android . app . AlertDialog ; import android . app . Service ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . SharedPreferences ; import android . content . SharedPreferences . OnSharedPreferenceChangeListener ; import android . location . Location ; import android . location . LocationListener ; import android . location . LocationManager ; import android . os . Binder ; import android . os . Bundle ; import android . os . Handler ; import android . os . IBinder ; import android . util . Log ; import android . view . WindowManager ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . adapters . AIMSICDDbAdapter ; import com . SecUpwN . AIMSICD . rilexecutor . RilExecutor ; import com . SecUpwN . AIMSICD . smsdetection . SmsDetector ; import com . SecUpwN . AIMSICD . utils . Cell ; import com . SecUpwN . AIMSICD . utils . GeoLocation ; public class AimsicdService extends Service { private final String TAG = "AIMSICD_Service" ; public static final String SHARED_PREFERENCES_BASENAME = "com.SecUpwN.AIMSICD_preferences" ; public static final String UPDATE_DISPLAY = "UPDATE_DISPLAY" ; private final AimscidBinder mBinder = new AimscidBinder ( ) ; private final Handler timerHandler = new Handler ( ) ; private CellTracker mCellTracker ; private AccelerometerMonitor mAccelerometerMonitor ; private SignalStrengthTracker signalStrengthTracker ; private LocationTracker mLocationTracker ; private RilExecutor mRilExecutor ; private SmsDetector smsdetector ; private boolean isLocationRequestShowing = false ; @ Override public IBinder onBind ( Intent intent ) { return mBinder ; } public class AimscidBinder extends Binder { public AimsicdService getService ( ) { return AimsicdService . this ; } } public void onCreate ( ) { signalStrengthTracker = new SignalStrengthTracker ( getBaseContext ( ) ) ; mAccelerometerMonitor = new AccelerometerMonitor ( this , new Runnable ( ) { @ Override public void run ( ) { mLocationTracker . start ( ) ; signalStrengthTracker . onSensorChanged ( ) ; timerHandler . postDelayed ( batterySavingRunnable , AccelerometerMonitor . MOVEMENT_THRESHOLD_MS ) ; } } ) ; mLocationTracker = new LocationTracker ( this , mLocationListener ) ; mRilExecutor = new RilExecutor ( this ) ; mCellTracker = new CellTracker ( this , signalStrengthTracker ) ; Log . i ( TAG , "Service launched successfully." ) ; } @ Override public int onStartCommand ( Intent intent , int flags , int startId ) { return START_STICKY ; } @ Override public void onDestroy ( ) { super . onDestroy ( ) ; mCellTracker . stop ( ) ; mLocationTracker . stop ( ) ; mAccelerometerMonitor . stop ( ) ; mRilExecutor . stop ( ) ; if ( smsdetector . getSmsDetectionState ( ) ) { smsdetector . stopSmsDetection ( ) ; } Log . i ( TAG , "Service destroyed." ) ; } public GeoLocation lastKnownLocation ( ) { return mLocationTracker . lastKnownLocation ( ) ; } public RilExecutor getRilExecutor ( ) { return mRilExecutor ; } public CellTracker getCellTracker ( ) { return mCellTracker ; } public Cell getCell ( ) { return mCellTracker . getDevice ( ) . mCell ; } public void setCell ( Cell cell ) { mCellTracker . getDevice ( ) . mCell = cell ; } public boolean isTrackingCell ( ) { return mCellTracker . isTrackingCell ( ) ; } public boolean isMonitoringCell ( ) { return mCellTracker . isMonitoringCell ( ) ; } public void setCellMonitoring ( boolean monitor ) { mCellTracker . setCellMonitoring ( monitor ) ; } public boolean isTrackingFemtocell ( ) { return mCellTracker . isTrackingFemtocell ( ) ; } public void setTrackingFemtocell ( boolean track ) { if ( track ) mCellTracker . startTrackingFemto ( ) ; else mCellTracker . stopTrackingFemto ( ) ; } public boolean isSmsTracking ( ) { return smsdetector . getSmsDetectionState ( ) ; } public void startSmsTracking ( ) { if ( ! isSmsTracking ( ) ) { Log . i ( TAG , "Sms Detection Thread Started" ) ; smsdetector = new SmsDetector ( this ) ; smsdetector . startSmsDetection ( ) ; } } public void stopSmsTracking ( ) { if ( isSmsTracking ( ) ) { smsdetector . stopSmsDetection ( ) ; Log . i ( TAG , "Sms Detection Thread Stopped" ) ; } } private final Runnable batterySavingRunnable = new Runnable ( ) { @ Override public void run ( ) { if ( mCellTracker . isTrackingCell ( ) ) { if ( mAccelerometerMonitor . notMovedInAWhile ( ) || mLocationTracker . notMovedInAWhile ( ) ) { mLocationTracker . stop ( ) ; } mAccelerometerMonitor . start ( ) ; } } } ; public void setCellTracking ( boolean track ) { mCellTracker . setCellTracking ( track ) ; if ( track ) { mLocationTracker . start ( ) ; mAccelerometerMonitor . start ( ) ; } else { mLocationTracker . stop ( ) ; mAccelerometerMonitor . stop ( ) ; } } public void checkLocationServices ( ) { if ( mCellTracker . isTrackingCell ( ) && ! mLocationTracker . isGPSOn ( ) ) { enableLocationServices ( ) ; } } private void enableLocationServices ( ) { if ( isLocationRequestShowing ) return ; final AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; builder . setMessage ( R . string . location_error_message ) . setTitle ( R . string . location_error_title ) . setCancelable ( false ) . setPositiveButton ( R . string . text_ok , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { isLocationRequestShowing = false ; Intent gpsSettings = new Intent ( android . provider . Settings . ACTION_LOCATION_SOURCE_SETTINGS ) ; gpsSettings . setFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; startActivity ( gpsSettings ) ; } } ) . setNegativeButton ( R . string . text_cancel , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { isLocationRequestShowing = false ; setCellTracking ( false ) ; } } ) ; AlertDialog alert = builder . create ( ) ; alert . getWindow ( ) . setType ( WindowManager . LayoutParams . TYPE_SYSTEM_ALERT ) ; alert . show ( ) ; isLocationRequestShowing = true ; } LocationListener mLocationListener = new LocationListener ( ) { @ Override public void onLocationChanged ( Location loc ) { timerHandler . postDelayed ( batterySavingRunnable , AccelerometerMonitor . MOVEMENT_THRESHOLD_MS ) ; mCellTracker . onLocationChanged ( loc ) ; } @ Override public void onProviderDisabled ( String provider ) { if ( mCellTracker . isTrackingCell ( ) && provider . equals ( LocationManager . GPS_PROVIDER ) ) { enableLocationServices ( ) ; } } @ Override public void onProviderEnabled ( String s ) { } @ Override public void onStatusChanged ( String s , int i , Bundle bundle ) { } } ; }
package com . SecUpwN . AIMSICD . service ; import android . content . Context ; import android . util . Log ; import com . SecUpwN . AIMSICD . adapters . AIMSICDDbAdapter ; import java . util . ArrayList ; import java . util . HashMap ; public class SignalStrengthTracker { public static final String TAG = "AIMSICD_SignalStrength" ; private static int sleepTimeBetweenSignalRegistration = 60 ; private static int minimumIdleTime = 30 ; private static int maximumNumberOfDaysSaved = 60 ; private static int mysteriousSignalDifference = 10 ; private static int sleepTimeBetweenCleanup = 3600 ; private Long lastRegistrationTime ; private Long lastCleanupTime ; private HashMap < Integer , Integer > averageSignalCache = new HashMap < > ( ) ; private long lastMovementDetected = 0l ; private AIMSICDDbAdapter mDbHelper ; public SignalStrengthTracker ( Context context ) { lastMovementDetected = System . currentTimeMillis ( ) ; lastRegistrationTime = System . currentTimeMillis ( ) ; lastCleanupTime = System . currentTimeMillis ( ) ; mDbHelper = new AIMSICDDbAdapter ( context ) ; } public void registerSignalStrength ( int cellID , int signalStrength ) { long now = System . currentTimeMillis ( ) ; if ( deviceIsMoving ( ) ) { Log . i ( TAG , "Ignored signal strength sample for CID: " + cellID + " as the device is currently moving around, will not accept anything for another " + ( ( minimumIdleTime * 1000 ) - ( now - lastMovementDetected ) ) + " ms." ) ; return ; } if ( now - ( sleepTimeBetweenSignalRegistration * 1000 ) > lastRegistrationTime ) { long diff = now - lastRegistrationTime ; Log . i ( TAG , "Scheduling signal strength calculation from CID: " + cellID + " @ " + signalStrength + " dBm. Last registration was " + diff + "ms ago." ) ; lastRegistrationTime = now ; mDbHelper . open ( ) ; mDbHelper . addSignalStrength ( cellID , signalStrength , now ) ; mDbHelper . close ( ) ; } if ( now - ( sleepTimeBetweenCleanup * 1000 ) > lastCleanupTime ) { Log . i ( TAG , "Removing old signal strength entries" ) ; cleanupOldData ( ) ; } } private void cleanupOldData ( ) { long maxTime = ( System . currentTimeMillis ( ) - ( ( maximumNumberOfDaysSaved * 86400 ) ) * 1000 ) ; mDbHelper . open ( ) ; mDbHelper . cleanseCellStrengthTables ( maxTime ) ; mDbHelper . close ( ) ; averageSignalCache . clear ( ) ; } private boolean deviceIsMoving ( ) { return System . currentTimeMillis ( ) - lastMovementDetected < minimumIdleTime * 1000 ; } public boolean isMysterious ( int cellID , int signalStrength ) { if ( deviceIsMoving ( ) ) { Log . i ( TAG , "Cannot check signal strength for CID: " + cellID + " as the device is currently moving around." ) ; return false ; } int storedAvg ; if ( averageSignalCache . get ( cellID ) != null ) { storedAvg = averageSignalCache . get ( cellID ) ; Log . d ( TAG , "Cached average SS for CID: " + cellID + " is: " + storedAvg ) ; } else { mDbHelper . open ( ) ; storedAvg = mDbHelper . getAverageSignalStrength ( cellID ) ; averageSignalCache . put ( cellID , storedAvg ) ; Log . d ( TAG , "Average SS in DB for CID: " + cellID + " is: " + storedAvg ) ; mDbHelper . close ( ) ; } boolean result ; if ( storedAvg > signalStrength ) { result = storedAvg - signalStrength > mysteriousSignalDifference ; } else { result = signalStrength - storedAvg > mysteriousSignalDifference ; } Log . d ( TAG , "Signal Strength mystery check for CID: " + cellID + " is " + result + ", avg:" + storedAvg + ", this signal: " + signalStrength ) ; return result ; } public void onSensorChanged ( ) { lastMovementDetected = System . currentTimeMillis ( ) ; } }
package com . SecUpwN . AIMSICD . drawer ; public class DrawerMenuSection implements NavDrawerItem { private static final int SECTION_TYPE = 0 ; private int id ; private String label ; private int icon ; private DrawerMenuSection ( ) { } public static DrawerMenuSection create ( int id , String label ) { DrawerMenuSection section = new DrawerMenuSection ( ) ; section . setId ( id ) ; section . setLabel ( label ) ; return section ; } @ Override public int getType ( ) { return SECTION_TYPE ; } public String getLabel ( ) { return label ; } public void setLabel ( String label ) { this . label = label ; } public void setmIconId ( int icon ) { this . icon = icon ; } @ Override public boolean isEnabled ( ) { return false ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } @ Override public boolean updateActionBarTitle ( ) { return false ; } }
package com . SecUpwN . AIMSICD . drawer ; import android . content . Context ; import android . telephony . TelephonyManager ; import android . widget . BaseAdapter ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . adapters . DrawerMenuAdapter ; import com . SecUpwN . AIMSICD . constants . DrawerMenu ; import com . SecUpwN . AIMSICD . service . CellTracker ; import java . util . ArrayList ; import java . util . List ; public class DrawerMenuActivityConfiguration { private final int mMainLayout ; private final int mDrawerLayoutId ; private final int mLeftDrawerId ; private final int [ ] mActionMenuItemsToHideWhenDrawerOpen ; private final List < NavDrawerItem > mNavItems ; private final int mDrawerOpenDesc ; private final int mDrawerCloseDesc ; private final BaseAdapter mBaseAdapter ; private DrawerMenuActivityConfiguration ( Builder pBuilder ) { mMainLayout = pBuilder . mMainLayout ; mDrawerLayoutId = pBuilder . mDrawerLayoutId ; mLeftDrawerId = pBuilder . mLeftDrawerId ; mActionMenuItemsToHideWhenDrawerOpen = pBuilder . mActionMenuItemsToHideWhenDrawerOpen ; mNavItems = pBuilder . mNavItems ; mDrawerOpenDesc = pBuilder . mDrawerOpenDesc ; mDrawerCloseDesc = pBuilder . mDrawerCloseDesc ; mBaseAdapter = pBuilder . mBaseAdapter ; } public int getMainLayout ( ) { return mMainLayout ; } public int getDrawerLayoutId ( ) { return mDrawerLayoutId ; } public int getLeftDrawerId ( ) { return mLeftDrawerId ; } public int [ ] getActionMenuItemsToHideWhenDrawerOpen ( ) { return mActionMenuItemsToHideWhenDrawerOpen ; } public List < NavDrawerItem > getNavItems ( ) { return mNavItems ; } public int getDrawerOpenDesc ( ) { return mDrawerOpenDesc ; } public int getDrawerCloseDesc ( ) { return mDrawerCloseDesc ; } public BaseAdapter getBaseAdapter ( ) { return mBaseAdapter ; } public static class Builder { private final Context mContext ; private int mMainLayout ; private int mDrawerLayoutId ; private int mLeftDrawerId ; private int [ ] mActionMenuItemsToHideWhenDrawerOpen ; private List < NavDrawerItem > mNavItems ; private int mDrawerOpenDesc ; private int mDrawerCloseDesc ; private BaseAdapter mBaseAdapter ; public Builder ( Context pContext ) { mContext = pContext ; } public Builder mainLayout ( int pMainLayout ) { mMainLayout = pMainLayout ; return this ; } public Builder drawerLayoutId ( int pDrawerLayoutId ) { mDrawerLayoutId = pDrawerLayoutId ; return this ; } public Builder leftDrawerId ( int pLeftDrawerId ) { mLeftDrawerId = pLeftDrawerId ; return this ; } public Builder actionMenuItemsToHideWhenDrawerOpen ( int [ ] pActionMenuItemsToHideWhenDrawerOpen ) { mActionMenuItemsToHideWhenDrawerOpen = pActionMenuItemsToHideWhenDrawerOpen ; return this ; } public Builder drawerOpenDesc ( int pDrawerOpenDesc ) { mDrawerOpenDesc = pDrawerOpenDesc ; return this ; } public Builder drawerCloseDesc ( int pDrawerCloseDesc ) { mDrawerCloseDesc = pDrawerCloseDesc ; return this ; } public Builder baseAdapter ( BaseAdapter pBaseAdapter ) { mBaseAdapter = pBaseAdapter ; return this ; } public DrawerMenuActivityConfiguration build ( ) { List < NavDrawerItem > menu = new ArrayList < > ( ) ; menu . add ( DrawerMenuSection . create ( DrawerMenu . ID . SECTION_MAIN , mContext . getString ( R . string . main ) ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . MAIN . CURRENT_TREAT_LEVEL , mContext . getString ( R . string . cell_info_title ) , R . drawable . cell_tower , true ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . MAIN . PHONE_SIM_DETAILS , mContext . getString ( R . string . device_info ) , R . drawable . ic_action_phone , true ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . MAIN . ACD , mContext . getString ( R . string . cell_lookup ) , R . drawable . stat_sys_download_anim0 , false ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . MAIN . DB_VIEWER , mContext . getString ( R . string . db_viewer ) , R . drawable . ic_action_storage , true ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . MAIN . ANTENNA_MAP_VIEW , mContext . getString ( R . string . map_view ) , R . drawable . ic_action_map , false ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . MAIN . AT_COMMAND_INTERFACE , mContext . getString ( R . string . at_command_title ) , R . drawable . ic_action_computer , true ) ) ; menu . add ( DrawerMenuSection . create ( DrawerMenu . ID . SECTION_TRACKING , mContext . getString ( R . string . tracking ) ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . TRACKING . TOGGLE_AIMSICD_MONITORING , mContext . getString ( R . string . toggle_aimsicd_monitoring ) , R . drawable . untrack_cell , false ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . TRACKING . TOGGLE_2G_ONLY_NETWORK , mContext . getString ( R . string . toggle_2g_only_network_lock ) , R . drawable . untrack_cell , false ) ) ; if ( CellTracker . PHONE_TYPE == TelephonyManager . PHONE_TYPE_CDMA ) { menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . TRACKING . TRACK_FEMTOCELL , mContext . getString ( R . string . toggle_femtocell ) , R . drawable . ic_action_network_cell , false , false ) ) ; } menu . add ( DrawerMenuSection . create ( DrawerMenu . ID . SECTION_SETTINGS , mContext . getString ( R . string . settings ) ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . SETTINGS . PREFERENCES , mContext . getString ( R . string . preferences ) , R . drawable . ic_action_settings , false ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . SETTINGS . BACKUP_DB , mContext . getString ( R . string . backup_database ) , R . drawable . ic_action_import_export , false ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . SETTINGS . RESTORE_DB , mContext . getString ( R . string . restore_database ) , R . drawable . ic_action_import_export , false ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . SETTINGS . RESET_DB , mContext . getString ( R . string . clear_database ) , R . drawable . ic_action_delete_database , false ) ) ; menu . add ( DrawerMenuSection . create ( DrawerMenu . ID . SECTION_APPLICATION , mContext . getString ( R . string . application ) ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . APPLICATION . DOWNLOAD_LOCAL_BST_DATA , mContext . getString ( R . string . get_opencellid ) , R . drawable . stat_sys_download_anim0 , false ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . APPLICATION . UPLOAD_LOCAL_BST_DATA , mContext . getString ( R . string . upload_bts ) , R . drawable . stat_sys_upload_anim0 , false ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . APPLICATION . ABOUT , mContext . getString ( R . string . about_aimsicd ) , R . drawable . ic_action_about , true ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . APPLICATION . SEND_DEBUGGING_LOG , mContext . getString ( R . string . send_logs ) , R . drawable . ic_action_computer , false ) ) ; menu . add ( DrawerMenuItem . create ( DrawerMenu . ID . APPLICATION . QUIT , mContext . getString ( R . string . quit ) , R . drawable . ic_action_remove , false ) ) ; mNavItems = menu ; if ( mMainLayout == 0 ) { this . mainLayout ( R . layout . main ) ; } if ( mDrawerLayoutId == 0 ) { this . drawerLayoutId ( R . id . drawer_layout ) ; } if ( mLeftDrawerId == 0 ) { this . leftDrawerId ( R . id . left_drawer ) ; } if ( mDrawerOpenDesc == 0 ) { this . drawerOpenDesc ( R . string . drawer_open ) ; } if ( mDrawerCloseDesc == 0 ) { this . drawerCloseDesc ( R . string . drawer_close ) ; } if ( mBaseAdapter == null ) { mBaseAdapter = new DrawerMenuAdapter ( mContext , R . layout . drawer_item , menu ) ; } return new DrawerMenuActivityConfiguration ( this ) ; } } }
package com . SecUpwN . AIMSICD . drawer ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . constants . DrawerMenu . ID . APPLICATION ; import com . SecUpwN . AIMSICD . constants . DrawerMenu . ID . MAIN ; import com . SecUpwN . AIMSICD . constants . DrawerMenu . ID . SETTINGS ; import com . SecUpwN . AIMSICD . constants . DrawerMenu . ID . TRACKING ; public class DrawerMenuItem implements NavDrawerItem { public static final int ITEM_TYPE = 1 ; private int mId ; private String mLabel ; private int mIconId ; private boolean mUpdateActionBarTitle ; private boolean mIsShowInfoButton ; private DrawerMenuItem ( ) { } public static DrawerMenuItem create ( int pMenuId , String pLabel , int pIconDrawableId , boolean pUpdateActionBarTitle ) { return create ( pMenuId , pLabel , pIconDrawableId , pUpdateActionBarTitle , true ) ; } public static DrawerMenuItem create ( int pMenuId , String pLabel , int pIconDrawableId , boolean pUpdateActionBarTitle , boolean pIsShowInfoButton ) { DrawerMenuItem item = new DrawerMenuItem ( ) ; item . setId ( pMenuId ) ; item . setLabel ( pLabel ) ; item . setmIconId ( pIconDrawableId ) ; item . setUpdateActionBarTitle ( pUpdateActionBarTitle ) ; item . setIsShowInfoButton ( pIsShowInfoButton ) ; return item ; } @ Override public int getType ( ) { return ITEM_TYPE ; } public int getId ( ) { return mId ; } void setId ( int pId ) { mId = pId ; } public String getLabel ( ) { return mLabel ; } public void setLabel ( String pLabel ) { mLabel = pLabel ; } public int getIconId ( ) { return mIconId ; } public void setmIconId ( int pIcon ) { mIconId = pIcon ; } @ Override public boolean isEnabled ( ) { return true ; } @ Override public boolean updateActionBarTitle ( ) { return mUpdateActionBarTitle ; } void setUpdateActionBarTitle ( boolean pUpdateActionBarTitle ) { mUpdateActionBarTitle = pUpdateActionBarTitle ; } public boolean isShowInfoButton ( ) { return mIsShowInfoButton ; } public void setIsShowInfoButton ( boolean pIsShowInfoButton ) { mIsShowInfoButton = pIsShowInfoButton ; } public int getHelpStringId ( ) { switch ( mId ) { case MAIN . CURRENT_TREAT_LEVEL : return R . string . help_main_current_threat_level ; case MAIN . PHONE_SIM_DETAILS : return R . string . help_main_phone_sim_details ; case MAIN . ACD : return R . string . help_main_acd ; case MAIN . DB_VIEWER : return R . string . help_main_database_viewer ; case MAIN . ANTENNA_MAP_VIEW : return R . string . help_main_antenna_map_view ; case MAIN . AT_COMMAND_INTERFACE : return R . string . help_main_at_command_interface ; case TRACKING . TOGGLE_2G_ONLY_NETWORK : return R . string . help_tracking_toggle_2g_only_network_lock ; case TRACKING . TOGGLE_AIMSICD_MONITORING : return R . string . help_tracking_toggle_aimsicd ; case SETTINGS . PREFERENCES : return R . string . help_settings_preferences ; case SETTINGS . BACKUP_DB : return R . string . help_settings_backup_db ; case SETTINGS . RESTORE_DB : return R . string . help_settings_restore_db ; case SETTINGS . RESET_DB : return R . string . help_settings_reset_db ; case SETTINGS . EXPORT_DB_TO_CVS : return R . string . help_settings_export_db_to_csv ; case SETTINGS . IMPORT_DB_FROM_CVS : return R . string . help_settings_import_db_from_csv ; case APPLICATION . ADD_GET_OCID_API_KEY : return R . string . help_app_add_get_ocid_api_key ; case APPLICATION . ABOUT : return R . string . help_app_about ; case APPLICATION . DOWNLOAD_LOCAL_BST_DATA : return R . string . help_app_download_local_bst ; case APPLICATION . UPLOAD_LOCAL_BST_DATA : return R . string . help_app_upload_local_bst ; case APPLICATION . SEND_DEBUGGING_LOG : return R . string . help_app_debugging ; case APPLICATION . QUIT : return R . string . help_app_quit ; default : return R . string . empty ; } } }
package com . SecUpwN . AIMSICD . drawer ; public interface NavDrawerItem { public int getId ( ) ; public String getLabel ( ) ; public void setLabel ( String label ) ; public void setmIconId ( int icon ) ; public int getType ( ) ; public boolean isEnabled ( ) ; public boolean updateActionBarTitle ( ) ; }
package com . SecUpwN . AIMSICD . enums ; import android . content . Context ; import com . SecUpwN . AIMSICD . R ; import java . util . ArrayList ; import java . util . Arrays ; public enum StatesDbViewer { UNIQUE_BTS_DATA ( R . string . unique_bts_data ) , BTS_MEASUREMENTS ( R . string . bts_measurements ) , IMPORTED_OCID_DATA ( R . string . imported_ocid_data ) , DEFAULT_MCC_LOCATIONS ( R . string . default_mmc_locations ) , SILENT_SMS ( R . string . silent_sms ) , MEASURED_SIGNAL_STRENGTHS ( R . string . measured_signal_strengths ) , EVENT_LOG ( R . string . eventlog ) , DETECTION_STRINGS ( R . string . detection_strings ) ; private final int mStatementValue ; StatesDbViewer ( int pStatementValue ) { mStatementValue = pStatementValue ; } public int getStatementValue ( ) { return mStatementValue ; } public static ArrayList < StatesDbViewer > getStates ( ) { return new ArrayList < > ( Arrays . asList ( values ( ) ) ) ; } public static StatesDbViewer getValueByOrdinal ( int pOrdinal ) { StatesDbViewer lResult = null ; for ( StatesDbViewer item : values ( ) ) { if ( item . ordinal ( ) == pOrdinal ) { lResult = item ; break ; } } return lResult ; } public String getDisplayName ( Context pContext ) { if ( pContext == null ) { return null ; } return pContext . getString ( getStatementValue ( ) ) ; } }
package com . SecUpwN . AIMSICD . fragments ; import com . SecUpwN . AIMSICD . R ; import android . os . Bundle ; import android . preference . PreferenceFragment ; public class MapPrefFragment extends PreferenceFragment { @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; addPreferencesFromResource ( R . xml . map_preferences ) ; } }
package com . SecUpwN . AIMSICD . fragments ; import android . content . Context ; import android . content . res . ColorStateList ; import android . content . res . TypedArray ; import android . graphics . Camera ; import android . graphics . Canvas ; import android . graphics . Matrix ; import android . graphics . Paint ; import android . text . Layout ; import android . text . StaticLayout ; import android . text . TextPaint ; import android . text . TextUtils ; import android . util . AttributeSet ; import android . widget . TextView ; import com . SecUpwN . AIMSICD . R ; public class CreditsRollView extends TextView { private static final float FLOAT_EPSILON = 0.001f ; private int mPaddingLeft ; private int mPaddingTop ; private int mPaddingRight ; private int mPaddingBottom ; private int mTextColor = 0xffffc92a ; private float mAngle = 60f ; private float mScrollPosition = 0f ; private float mEndScrollMult = 2f ; private float mDistanceFromText = 0f ; private final Camera mCamera = new Camera ( ) ; private Matrix mMatrix = new Matrix ( ) ; private TextPaint mTextPaint ; private StaticLayout mTextLayout ; public CreditsRollView ( Context context ) { super ( context ) ; init ( null , 0 , context ) ; } public CreditsRollView ( Context context , AttributeSet attrs ) { this ( context , attrs , 0 ) ; } public CreditsRollView ( Context context , AttributeSet attrs , int defStyle ) { super ( context , attrs , defStyle ) ; init ( attrs , defStyle , context ) ; } private void init ( AttributeSet attrs , int defStyle , Context context ) { final TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . CreditsRollView , defStyle , 0 ) ; if ( a != null ) { final int N = a . getIndexCount ( ) ; for ( int i = 0 ; i < N ; ++ i ) { int attr = a . getIndex ( i ) ; if ( attr == R . styleable . CreditsRollView_angle ) { float angle = a . getFloat ( attr , mAngle ) ; setAngle ( angle ) ; } else if ( attr == R . styleable . CreditsRollView_scrollPosition ) { float scrollPercent = a . getFloat ( attr , 0f ) ; setScrollPosition ( scrollPercent ) ; } else if ( attr == R . styleable . CreditsRollView_endScrollMultiplier ) { float scrollMult = a . getFloat ( attr , 0f ) ; setEndScrollMult ( scrollMult ) ; } else if ( attr == R . styleable . CreditsRollView_distanceFromText ) { float distance = a . getFloat ( attr , 0f ) ; setDistanceFromText ( distance ) ; } } a . recycle ( ) ; } initTextPaint ( ) ; } private void initTextPaint ( ) { mTextPaint = new TextPaint ( ) ; mTextPaint . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; mTextPaint . setTextSize ( getTextSize ( ) ) ; mTextPaint . setColor ( mTextColor ) ; } public float getScrollPosition ( ) { return mScrollPosition ; } public void setScrollPosition ( float scrollPosition ) { if ( scrollPosition < 0f ) { scrollPosition = 0f ; } else if ( scrollPosition > 1f ) { scrollPosition = 1f ; } if ( Math . abs ( mScrollPosition - scrollPosition ) > FLOAT_EPSILON ) { mScrollPosition = scrollPosition ; invalidate ( ) ; } } public float getAngle ( ) { return mAngle ; } public void setAngle ( float angle ) { if ( Math . abs ( mAngle - angle ) > FLOAT_EPSILON ) { mAngle = angle ; invalidate ( ) ; } } public float getEndScrollMult ( ) { return mEndScrollMult ; } public void setEndScrollMult ( float endScrollMult ) { if ( Math . abs ( mEndScrollMult - endScrollMult ) > FLOAT_EPSILON ) { mEndScrollMult = endScrollMult ; invalidate ( ) ; } } public float getDistanceFromText ( ) { return mDistanceFromText ; } public void setDistanceFromText ( float distanceFromText ) { mDistanceFromText = distanceFromText ; } @ Override protected void onDraw ( Canvas canvas ) { mPaddingLeft = getPaddingLeft ( ) ; mPaddingTop = getPaddingTop ( ) ; mPaddingRight = getPaddingRight ( ) ; mPaddingBottom = getPaddingBottom ( ) ; final CharSequence text = getText ( ) ; if ( TextUtils . isEmpty ( text ) ) { return ; } int contentWidth = getWidth ( ) - mPaddingLeft - mPaddingRight ; int contentHeight = getHeight ( ) - mPaddingTop - mPaddingBottom ; final int saveCnt = canvas . save ( ) ; canvas . getMatrix ( mMatrix ) ; mCamera . save ( ) ; int cX = contentWidth / 2 + mPaddingLeft ; int cY = contentHeight / 2 + mPaddingTop ; mCamera . rotateX ( mAngle ) ; mCamera . translate ( 0 , 0 , mDistanceFromText ) ; mCamera . getMatrix ( mMatrix ) ; mMatrix . preTranslate ( - cX , - cY ) ; mMatrix . postTranslate ( cX , cY ) ; mCamera . restore ( ) ; canvas . concat ( mMatrix ) ; canvas . translate ( 9f , contentHeight - mScrollPosition * ( mTextLayout . getHeight ( ) + mEndScrollMult * contentHeight ) ) ; mTextLayout . draw ( canvas ) ; canvas . restoreToCount ( saveCnt ) ; } @ Override public void setText ( CharSequence text , BufferType type ) { super . setText ( text , type ) ; if ( mTextPaint == null ) { initTextPaint ( ) ; } measureAndLayoutText ( text ) ; } @ Override public void setTextColor ( int color ) { super . setTextColor ( color ) ; mTextColor = color ; initTextPaint ( ) ; } @ Override public void setTextColor ( ColorStateList colors ) { super . setTextColor ( colors ) ; if ( ! colors . isStateful ( ) ) { mTextColor = colors . getDefaultColor ( ) ; } else { mTextColor = colors . getColorForState ( getDrawableState ( ) , colors . getDefaultColor ( ) ) ; } initTextPaint ( ) ; invalidate ( ) ; } @ Override public void setTextSize ( float size ) { super . setTextSize ( size ) ; initTextPaint ( ) ; invalidate ( ) ; } @ Override public void setTextSize ( int unit , float size ) { super . setTextSize ( unit , size ) ; initTextPaint ( ) ; invalidate ( ) ; } @ Override public void setTextAppearance ( Context context , int resid ) { super . setTextAppearance ( context , resid ) ; initTextPaint ( ) ; invalidate ( ) ; } @ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; final CharSequence text = getText ( ) ; measureAndLayoutText ( text ) ; } private void measureAndLayoutText ( CharSequence text ) { if ( TextUtils . isEmpty ( text ) ) { mTextLayout = null ; return ; } int availableWidth = getWidth ( ) ; mTextLayout = new StaticLayout ( text , mTextPaint , availableWidth , Layout . Alignment . ALIGN_CENTER , 1.1f , 0f , true ) ; } }
package com . SecUpwN . AIMSICD . fragments ; import com . SecUpwN . AIMSICD . R ; import android . os . Bundle ; import android . preference . PreferenceFragment ; public class PrefFragment extends PreferenceFragment { @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; addPreferencesFromResource ( R . xml . preferences ) ; } }
package com . SecUpwN . AIMSICD . test ; import android . test . ActivityInstrumentationTestCase2 ; import android . test . AndroidTestCase ; import android . util . Log ; import android . widget . Toast ; import com . SecUpwN . AIMSICD . AIMSICD ; import com . SecUpwN . AIMSICD . activities . DebugLogs ; import com . SecUpwN . AIMSICD . adapters . AIMSICDDbAdapter ; import com . SecUpwN . AIMSICD . utils . Cell ; import java . io . IOException ; public class GetProp extends ActivityInstrumentationTestCase2 < DebugLogs > { public GetProp ( ) { super ( DebugLogs . class ) ; } public void testGetPropsReturnsValue ( ) throws IOException { DebugLogs activity = ( DebugLogs ) getActivity ( ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { } String props = activity . getProp ( ) ; Log . d ( "getprop" , props ) ; assertTrue ( props . trim ( ) . length ( ) > 0 ) ; } }
package com . SecUpwN . AIMSICD . fragments ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . service . AimsicdService ; import com . SecUpwN . AIMSICD . utils . Device ; import com . SecUpwN . AIMSICD . utils . Helpers ; import android . app . Activity ; import android . content . BroadcastReceiver ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . ServiceConnection ; import android . os . Bundle ; import android . os . IBinder ; import android . support . v4 . app . Fragment ; import android . telephony . TelephonyManager ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TableRow ; import android . widget . TextView ; public class DeviceFragment extends Fragment { private final String TAG = "AIMSICD" ; private View mView ; private AimsicdService mAimsicdService ; private boolean mBound ; private Context mContext ; public DeviceFragment ( ) { } @ Override public void onAttach ( Activity activity ) { super . onAttach ( activity ) ; mContext = activity . getBaseContext ( ) ; Intent intent = new Intent ( mContext , AimsicdService . class ) ; mContext . bindService ( intent , mConnection , Context . BIND_AUTO_CREATE ) ; } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { mView = inflater . inflate ( R . layout . device , container , false ) ; return mView ; } @ Override public void onResume ( ) { super . onResume ( ) ; if ( ! mBound ) { Intent intent = new Intent ( mContext , AimsicdService . class ) ; mContext . bindService ( intent , mConnection , Context . BIND_AUTO_CREATE ) ; } mContext . registerReceiver ( mMessageReceiver , new IntentFilter ( AimsicdService . UPDATE_DISPLAY ) ) ; updateUI ( ) ; } @ Override public void onPause ( ) { super . onPause ( ) ; mContext . unregisterReceiver ( mMessageReceiver ) ; } @ Override public void onDestroy ( ) { super . onDestroy ( ) ; if ( mBound ) { mContext . unbindService ( mConnection ) ; mBound = false ; } } private final ServiceConnection mConnection = new ServiceConnection ( ) { @ Override public void onServiceConnected ( ComponentName name , IBinder service ) { mAimsicdService = ( ( AimsicdService . AimscidBinder ) service ) . getService ( ) ; mBound = true ; updateUI ( ) ; } @ Override public void onServiceDisconnected ( ComponentName arg0 ) { Log . e ( TAG , "Service Disconnected" ) ; mBound = false ; } } ; private final BroadcastReceiver mMessageReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { final Bundle bundle = intent . getExtras ( ) ; if ( bundle != null && bundle . getBoolean ( "update" ) ) { Helpers . msgShort ( mContext , context . getString ( R . string . refreshing_display ) ) ; updateUI ( ) ; } } } ; private void updateUI ( ) { TextView content ; TableRow tr ; if ( mBound ) { mAimsicdService . getCellTracker ( ) . refreshDevice ( ) ; Device mDevice = mAimsicdService . getCellTracker ( ) . getDevice ( ) ; switch ( mDevice . getPhoneID ( ) ) { case TelephonyManager . PHONE_TYPE_NONE : case TelephonyManager . PHONE_TYPE_SIP : case TelephonyManager . PHONE_TYPE_GSM : { content = ( TextView ) mView . findViewById ( R . id . network_lac ) ; content . setText ( String . valueOf ( mAimsicdService . getCell ( ) . getLAC ( ) ) ) ; tr = ( TableRow ) mView . findViewById ( R . id . gsm_cellid ) ; tr . setVisibility ( View . VISIBLE ) ; content = ( TextView ) mView . findViewById ( R . id . network_cellid ) ; content . setText ( String . valueOf ( mAimsicdService . getCell ( ) . getCID ( ) ) ) ; break ; } case TelephonyManager . PHONE_TYPE_CDMA : { tr = ( TableRow ) mView . findViewById ( R . id . cdma_netid ) ; tr . setVisibility ( View . VISIBLE ) ; content = ( TextView ) mView . findViewById ( R . id . network_netid ) ; content . setText ( String . valueOf ( mAimsicdService . getCell ( ) . getLAC ( ) ) ) ; tr = ( TableRow ) mView . findViewById ( R . id . cdma_sysid ) ; tr . setVisibility ( View . VISIBLE ) ; content = ( TextView ) mView . findViewById ( R . id . network_sysid ) ; content . setText ( String . valueOf ( mAimsicdService . getCell ( ) . getSID ( ) ) ) ; tr = ( TableRow ) mView . findViewById ( R . id . cdma_baseid ) ; tr . setVisibility ( View . VISIBLE ) ; content = ( TextView ) mView . findViewById ( R . id . network_baseid ) ; content . setText ( String . valueOf ( mAimsicdService . getCell ( ) . getCID ( ) ) ) ; break ; } } if ( mAimsicdService . getCell ( ) . getTimingAdvance ( ) != Integer . MAX_VALUE ) { tr = ( TableRow ) mView . findViewById ( R . id . lte_timing_advance ) ; tr . setVisibility ( View . VISIBLE ) ; content = ( TextView ) mView . findViewById ( R . id . network_lte_timing_advance ) ; content . setText ( String . valueOf ( mAimsicdService . getCell ( ) . getTimingAdvance ( ) ) ) ; } else { tr = ( TableRow ) mView . findViewById ( R . id . lte_timing_advance ) ; tr . setVisibility ( View . GONE ) ; } if ( mAimsicdService . getCell ( ) . getPSC ( ) != Integer . MAX_VALUE ) { content = ( TextView ) mView . findViewById ( R . id . network_psc ) ; content . setText ( String . valueOf ( mAimsicdService . getCell ( ) . getPSC ( ) ) ) ; tr = ( TableRow ) mView . findViewById ( R . id . primary_scrambling_code ) ; tr . setVisibility ( View . VISIBLE ) ; } content = ( TextView ) mView . findViewById ( R . id . sim_country ) ; content . setText ( mDevice . getSimCountry ( ) ) ; content = ( TextView ) mView . findViewById ( R . id . sim_operator_id ) ; content . setText ( mDevice . getSimOperator ( ) ) ; content = ( TextView ) mView . findViewById ( R . id . sim_operator_name ) ; content . setText ( mDevice . getSimOperatorName ( ) ) ; content = ( TextView ) mView . findViewById ( R . id . sim_imsi ) ; content . setText ( mDevice . getSimSubs ( ) ) ; content = ( TextView ) mView . findViewById ( R . id . sim_serial ) ; content . setText ( mDevice . getSimSerial ( ) ) ; content = ( TextView ) mView . findViewById ( R . id . device_type ) ; content . setText ( mDevice . getPhoneType ( ) ) ; content = ( TextView ) mView . findViewById ( R . id . device_imei ) ; content . setText ( mDevice . getIMEI ( ) ) ; content = ( TextView ) mView . findViewById ( R . id . device_version ) ; content . setText ( mDevice . getIMEIv ( ) ) ; content = ( TextView ) mView . findViewById ( R . id . network_name ) ; content . setText ( mDevice . getNetworkName ( ) ) ; content = ( TextView ) mView . findViewById ( R . id . network_code ) ; content . setText ( mDevice . getMncMcc ( ) ) ; content = ( TextView ) mView . findViewById ( R . id . network_type ) ; content . setText ( mDevice . getNetworkTypeName ( ) ) ; content = ( TextView ) mView . findViewById ( R . id . data_activity ) ; content . setText ( mDevice . getDataActivity ( ) ) ; content = ( TextView ) mView . findViewById ( R . id . data_status ) ; content . setText ( mDevice . getDataState ( ) ) ; content = ( TextView ) mView . findViewById ( R . id . network_roaming ) ; content . setText ( mDevice . isRoaming ( ) ) ; } } }
package com . SecUpwN . AIMSICD . fragments ; import android . graphics . Color ; import android . os . Bundle ; import android . support . v4 . app . Fragment ; import android . support . v4 . view . PagerTabStrip ; import android . support . v4 . view . ViewPager ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . adapters . DetailsPagerAdapter ; public class DetailsContainerFragment extends Fragment { ViewPager vp ; DetailsPagerAdapter adapter ; int initialPage = - 1 ; @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { return inflater . inflate ( R . layout . fragment_details_container , container , false ) ; } @ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; adapter = new DetailsPagerAdapter ( getChildFragmentManager ( ) , getActivity ( ) ) ; PagerTabStrip tabStrip = ( PagerTabStrip ) view . findViewById ( R . id . details_pager_tab_strip ) ; tabStrip . setBackgroundColor ( Color . BLACK ) ; vp = ( ViewPager ) view . findViewById ( R . id . details_pager ) ; vp . setAdapter ( adapter ) ; if ( initialPage >= 0 ) { vp . setCurrentItem ( initialPage ) ; } } public void setCurrentPage ( int page ) { if ( adapter == null ) { initialPage = page ; return ; } if ( page >= 0 && page < adapter . getCount ( ) ) { vp . setCurrentItem ( page ) ; } } }
package com . SecUpwN . AIMSICD . fragments ; import android . app . Activity ; import android . content . Context ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import android . support . v4 . app . Fragment ; import android . text . Editable ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . AdapterView ; import android . widget . ArrayAdapter ; import android . widget . Button ; import android . widget . EditText ; import android . widget . RelativeLayout ; import android . widget . Spinner ; import android . widget . TextView ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . utils . Helpers ; import com . SecUpwN . AIMSICD . utils . atcmd . AtCommandTerminal ; import com . SecUpwN . AIMSICD . utils . atcmd . TtyPrivFile ; import com . stericson . RootShell . RootShell ; import com . stericson . RootShell . execution . Command ; import com . stericson . RootShell . execution . Shell ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class AtCommandFragment extends Fragment { private final int SERIAL_INIT_OK = 100 ; private final int SERIAL_INIT_ERROR = 101 ; private final int ROOT_UNAVAILABLE = 102 ; private final int BUSYBOX_UNAVAILABLE = 103 ; private final int EXECUTE_AT = 200 ; private final int EXECUTE_COMMAND = 201 ; private Context mContext ; private String mSerialDevice ; private int mTimeout ; private final List < String > mSerialDevices = new ArrayList < > ( ) ; private RelativeLayout mAtCommandLayout ; private TextView mAtCommandError ; private TextView mSerialDeviceDisplay ; private TextView mAtResponse ; private EditText mAtCommand ; private Spinner mSerialDeviceSpinner ; private TextView mSerialDeviceSpinnerLabel ; private AtCommandTerminal mCommandTerminal ; @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . at_command_fragment , container , false ) ; if ( view != null ) { mAtCommandLayout = ( RelativeLayout ) view . findViewById ( R . id . atcommandView ) ; mAtCommandError = ( TextView ) view . findViewById ( R . id . at_command_error ) ; Button atCommandExecute = ( Button ) view . findViewById ( R . id . execute ) ; mSerialDeviceDisplay = ( TextView ) view . findViewById ( R . id . serial_device ) ; mAtResponse = ( TextView ) view . findViewById ( R . id . response ) ; mAtCommand = ( EditText ) view . findViewById ( R . id . at_command ) ; atCommandExecute . setOnClickListener ( new btnClick ( ) ) ; mSerialDeviceSpinner = ( Spinner ) view . findViewById ( R . id . serial_device_spinner ) ; mSerialDeviceSpinner . setOnItemSelectedListener ( new spinnerListener ( ) ) ; mSerialDeviceSpinnerLabel = ( TextView ) view . findViewById ( R . id . serial_device_spinner_title ) ; Spinner timoutSpinner = ( Spinner ) view . findViewById ( R . id . timeout_spinner ) ; timoutSpinner . setOnItemSelectedListener ( new timoutSpinnerListener ( ) ) ; timoutSpinner . setSelection ( 1 ) ; mTimeout = 5000 ; } return view ; } private class timoutSpinnerListener implements AdapterView . OnItemSelectedListener { @ Override public void onItemSelected ( AdapterView < ? > parentView , View selectedItemView , int position , long id ) { switch ( position ) { case 0 : mTimeout = 2000 ; break ; case 1 : mTimeout = 5000 ; break ; case 2 : mTimeout = 10000 ; break ; case 3 : mTimeout = 20000 ; break ; case 4 : mTimeout = 30000 ; break ; case 5 : mTimeout = 600000 ; break ; default : mTimeout = 5000 ; } } @ Override public void onNothingSelected ( AdapterView < ? > parentView ) { } } private class spinnerListener implements AdapterView . OnItemSelectedListener { @ Override public void onItemSelected ( AdapterView < ? > parentView , View selectedItemView , int position , long id ) { mSerialDevice = String . valueOf ( mSerialDeviceSpinner . getSelectedItem ( ) ) ; mSerialDeviceDisplay . setText ( mSerialDevice ) ; setSerialDevice ( ) ; } @ Override public void onNothingSelected ( AdapterView < ? > parentView ) { } } @ Override public void onAttach ( Activity activity ) { super . onAttach ( activity ) ; mContext = activity . getBaseContext ( ) ; } @ Override public void onDestroy ( ) { super . onDestroy ( ) ; if ( mCommandTerminal != null ) { mCommandTerminal . dispose ( ) ; } } @ Override public void onResume ( ) { super . onResume ( ) ; int serialDevice = initSerialDevice ( ) ; switch ( serialDevice ) { case SERIAL_INIT_OK : mAtCommandLayout . setVisibility ( View . VISIBLE ) ; break ; case ROOT_UNAVAILABLE : mAtCommandError . setText ( mContext . getString ( R . string . unable_to_acquire_root_access ) ) ; break ; case BUSYBOX_UNAVAILABLE : mAtCommandError . setText ( mContext . getString ( R . string . unable_to_detect_busybox ) ) ; break ; case SERIAL_INIT_ERROR : mAtCommandError . setText ( mContext . getString ( R . string . unknown_error_trying_to_acquire_serial_device ) ) ; break ; default : mAtCommandError . setText ( mContext . getString ( R . string . unknown_error_initialising_at_command_injector ) ) ; break ; } } private class btnClick implements View . OnClickListener { @ Override public void onClick ( View v ) { if ( mAtCommand . getText ( ) != null ) { String command = mAtCommand . getText ( ) . toString ( ) ; Log . i ( "AIMSICD" , "AT Command Detected: " + command ) ; executeAT ( ) ; } } } private int initSerialDevice ( ) { RootShell . handlerEnabled = false ; boolean root = RootShell . isAccessGiven ( ) ; if ( ! root ) { return ROOT_UNAVAILABLE ; } boolean busybox = RootShell . isBusyboxAvailable ( ) ; if ( ! busybox ) { return BUSYBOX_UNAVAILABLE ; } try { mAtResponse . setText ( R . string . at_command_response_looking ) ; mSerialDevices . clear ( ) ; try { String rilDevice = Helpers . getSystemProp ( mContext , "rild.libargs" , "UNKNOWN" ) ; mSerialDevice = ( rilDevice . equals ( "UNKNOWN" ) ? rilDevice : rilDevice . substring ( 3 ) ) ; if ( ! mSerialDevice . equals ( "UNKNOWN" ) ) { mSerialDevices . add ( mSerialDevice ) ; } } catch ( StringIndexOutOfBoundsException e ) { } for ( File file : new File ( "/dev" ) . listFiles ( ) ) { String name = file . getName ( ) ; boolean add = false ; if ( name . matches ( "^smd.$" ) ) { add = true ; } else if ( name . equals ( "radio" ) ) { for ( File subfile : file . listFiles ( ) ) { String subname = subfile . getName ( ) ; if ( subname . contains ( "atci" ) ) { add = true ; file = subfile ; } } } if ( add ) { mSerialDevices . add ( file . getAbsolutePath ( ) ) ; mAtResponse . append ( getString ( R . string . at_command_response_found ) + file . getAbsolutePath ( ) + "\n" ) ; } } File xgold = new File ( "/system/etc/ril_xgold_radio.cfg" ) ; if ( xgold . exists ( ) && xgold . isFile ( ) ) { Command cmd = new Command ( 1 , "\\cat /system/etc/ril_xgold_radio.cfg | " + "\\grep -E \"atport*|dataport*\"" ) { @ Override public void commandOutput ( int id , String line ) { if ( id == 0 ) { if ( ! line . trim ( ) . equals ( "" ) && line . contains ( "/dev/" ) ) { int place = line . indexOf ( "=" ) + 1 ; mSerialDevices . add ( line . substring ( place , line . length ( ) - 1 ) ) ; mAtResponse . append ( getString ( R . string . at_command_response_found ) + line . substring ( place , line . length ( ) - 1 ) + "\n" ) ; } } super . commandOutput ( id , line ) ; } } ; Shell shell = RootShell . getShell ( true ) ; shell . add ( cmd ) ; commandWait ( shell , cmd ) ; } } catch ( Exception e ) { Log . e ( "AIMSICD" , "ATCoP: initSerialDevice " + e ) ; } if ( ! mSerialDevices . isEmpty ( ) ) { String [ ] entries = new String [ mSerialDevices . size ( ) ] ; entries = mSerialDevices . toArray ( entries ) ; ArrayAdapter < String > spinnerAdapter = new ArrayAdapter < > ( mContext , android . R . layout . simple_spinner_item , entries ) ; mSerialDeviceSpinner . setAdapter ( spinnerAdapter ) ; mSerialDeviceSpinner . setVisibility ( View . VISIBLE ) ; mSerialDeviceSpinnerLabel . setVisibility ( View . VISIBLE ) ; } mAtResponse . append ( getString ( R . string . at_command_response_setup_complete ) ) ; mAtResponse . setVisibility ( View . VISIBLE ) ; return SERIAL_INIT_OK ; } private void setSerialDevice ( ) { if ( mCommandTerminal != null ) { mCommandTerminal . dispose ( ) ; mCommandTerminal = null ; } } private void openSerialDevice ( ) { if ( mCommandTerminal == null ) { try { mCommandTerminal = new TtyPrivFile ( mSerialDevice ) ; } catch ( IOException e ) { mAtResponse . append ( e . toString ( ) ) ; } } } private void executeAT ( ) { Editable cmd = mAtCommand . getText ( ) ; if ( cmd != null && cmd . length ( ) != 0 ) { openSerialDevice ( ) ; if ( mCommandTerminal != null ) { mCommandTerminal . send ( cmd . toString ( ) , new Handler ( Looper . getMainLooper ( ) ) { @ Override public void handleMessage ( Message message ) { if ( message . obj instanceof List ) { List < String > lines = ( ( List < String > ) message . obj ) ; StringBuffer response = new StringBuffer ( ) ; for ( String line : lines ) { response . append ( line ) ; response . append ( '\n' ) ; } if ( response . length ( ) != 0 ) { mAtResponse . append ( response ) ; } } else if ( message . obj instanceof IOException ) { mAtResponse . append ( "IOException: " + ( ( IOException ) message . obj ) . getMessage ( ) + "\n" ) ; } } } . obtainMessage ( ) ) ; } } } private void executeCommand ( ) { if ( mAtCommand . getText ( ) != null ) { final StringBuilder response = new StringBuilder ( ) ; try { Command cmd = new Command ( EXECUTE_COMMAND , mAtCommand . getText ( ) . toString ( ) + "\n" ) { @ Override public void commandOutput ( int id , String line ) { if ( id == EXECUTE_COMMAND ) { if ( ! line . trim ( ) . equals ( "" ) ) { response . append ( line ) . append ( "\n" ) ; } } super . commandOutput ( id , line ) ; } } ; Log . i ( "AIMSICD" , "Trying to executeCommand: " + cmd ) ; Shell shell = RootShell . getShell ( true ) ; shell . add ( cmd ) ; commandWait ( shell , cmd ) ; mAtResponse . append ( response . toString ( ) ) ; } catch ( Exception e ) { Log . e ( "AIMSICD" , "Failed to executeCommand: " + e ) ; } } } private void commandWait ( Shell shell , Command cmd ) throws Exception { while ( ! cmd . isFinished ( ) ) { synchronized ( cmd ) { try { if ( ! cmd . isFinished ( ) ) { cmd . wait ( mTimeout ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } if ( ! cmd . isExecuting ( ) && ! cmd . isFinished ( ) ) { if ( ! shell . isExecuting && ! shell . isReading ) { Log . e ( "AIMSICD" , "Waiting for a command to be executed in a shell that is not executing and not reading! \n\n Command: " + cmd . getCommand ( ) ) ; Exception e = new Exception ( ) ; e . setStackTrace ( Thread . currentThread ( ) . getStackTrace ( ) ) ; e . printStackTrace ( ) ; } else if ( shell . isExecuting && ! shell . isReading ) { Log . e ( "AIMSICD" , "Waiting for a command to be executed in a shell that is executing but not reading! \n\n Command: " + cmd . getCommand ( ) ) ; Exception e = new Exception ( ) ; e . setStackTrace ( Thread . currentThread ( ) . getStackTrace ( ) ) ; e . printStackTrace ( ) ; } else { Log . e ( "AIMSICD" , "Waiting for a command to be executed in a shell that is not reading! \n\n Command: " + cmd . getCommand ( ) ) ; Exception e = new Exception ( ) ; e . setStackTrace ( Thread . currentThread ( ) . getStackTrace ( ) ) ; e . printStackTrace ( ) ; } } } } }
package com . SecUpwN . AIMSICD . fragments ; import android . app . Activity ; import android . content . Context ; import android . database . Cursor ; import android . os . AsyncTask ; import android . os . Bundle ; import android . support . v4 . app . Fragment ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . AdapterView ; import android . widget . ListView ; import android . widget . Spinner ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . adapters . AIMSICDDbAdapter ; import com . SecUpwN . AIMSICD . adapters . BaseInflaterAdapter ; import com . SecUpwN . AIMSICD . adapters . CardItemData ; import com . SecUpwN . AIMSICD . adapters . CellCardInflater ; import com . SecUpwN . AIMSICD . adapters . DbViewerSpinnerAdapter ; import com . SecUpwN . AIMSICD . adapters . DefaultLocationCardInflater ; import com . SecUpwN . AIMSICD . adapters . EventLogCardInflater ; import com . SecUpwN . AIMSICD . adapters . EventLogItemData ; import com . SecUpwN . AIMSICD . adapters . MeasuredCellStrengthCardData ; import com . SecUpwN . AIMSICD . adapters . MeasuredCellStrengthCardInflater ; import com . SecUpwN . AIMSICD . adapters . OpenCellIdCardInflater ; import com . SecUpwN . AIMSICD . adapters . SilentSmsCardData ; import com . SecUpwN . AIMSICD . adapters . SilentSmsCardInflater ; import com . SecUpwN . AIMSICD . constants . Examples ; import com . SecUpwN . AIMSICD . enums . StatesDbViewer ; import com . SecUpwN . AIMSICD . smsdetection . CapturedSmsCardInflater ; import com . SecUpwN . AIMSICD . smsdetection . CapturedSmsData ; import com . SecUpwN . AIMSICD . smsdetection . DetectionStringsCardInflater ; import com . SecUpwN . AIMSICD . smsdetection . DetectionStringsData ; import com . SecUpwN . AIMSICD . smsdetection . SmsDetectionDbAccess ; import com . SecUpwN . AIMSICD . smsdetection . SmsDetectionDbHelper ; public class DbViewerFragment extends Fragment { private AIMSICDDbAdapter mDb ; private SmsDetectionDbAccess smsdetection_db ; private StatesDbViewer mTableSelected ; private Context mContext ; private Spinner tblSpinner ; private ListView lv ; private View emptyView ; public DbViewerFragment ( ) { } @ Override public void onAttach ( Activity activity ) { super . onAttach ( activity ) ; mContext = activity . getBaseContext ( ) ; mDb = new AIMSICDDbAdapter ( mContext ) ; smsdetection_db = new SmsDetectionDbAccess ( mContext ) ; } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . db_view , container , false ) ; lv = ( ListView ) view . findViewById ( R . id . list_view ) ; emptyView = view . findViewById ( R . id . db_list_empty ) ; tblSpinner = ( Spinner ) view . findViewById ( R . id . table_spinner ) ; DbViewerSpinnerAdapter mSpinnerAdapter = new DbViewerSpinnerAdapter ( getActivity ( ) , R . layout . item_spinner_db_viewer ) ; tblSpinner . setAdapter ( mSpinnerAdapter ) ; Spinner spnLocale = ( Spinner ) view . findViewById ( R . id . table_spinner ) ; spnLocale . setOnItemSelectedListener ( new AdapterView . OnItemSelectedListener ( ) { @ Override public void onItemSelected ( AdapterView < ? > parentView , View selectedItemView , final int position , long id ) { new AsyncTask < Void , Void , BaseInflaterAdapter > ( ) { @ Override protected BaseInflaterAdapter doInBackground ( Void ... params ) { mDb . open ( ) ; Cursor result ; mTableSelected = ( StatesDbViewer ) tblSpinner . getSelectedItem ( ) ; switch ( position ) { case 0 : result = mDb . getCellData ( ) ; break ; case 1 : result = mDb . getLocationData ( ) ; break ; case 2 : result = mDb . getOpenCellIDData ( ) ; break ; case 3 : result = mDb . getDefaultMccLocationData ( ) ; break ; case 4 : result = smsdetection_db . returnDetectedSmsData ( ) ; break ; case 5 : result = mDb . getSignalStrengthMeasurementData ( ) ; break ; case 6 : result = mDb . getEventLogData ( ) ; break ; case 7 : result = smsdetection_db . getDetectionStringCursor ( ) ; break ; default : throw new IllegalArgumentException ( "Unknown type of table" ) ; } BaseInflaterAdapter adapter = null ; if ( result != null ) { adapter = BuildTable ( result ) ; } mDb . close ( ) ; return adapter ; } @ Override protected void onPostExecute ( BaseInflaterAdapter adapter ) { if ( getActivity ( ) == null ) return ; lv . setEmptyView ( emptyView ) ; if ( adapter != null ) { lv . setAdapter ( adapter ) ; lv . setVisibility ( View . VISIBLE ) ; } else { lv . setVisibility ( View . GONE ) ; emptyView . setVisibility ( View . VISIBLE ) ; } getActivity ( ) . setProgressBarIndeterminateVisibility ( false ) ; } } . executeOnExecutor ( AsyncTask . THREAD_POOL_EXECUTOR ) ; } @ Override public void onNothingSelected ( AdapterView < ? > parentView ) { return ; } } ) ; return view ; } private BaseInflaterAdapter BuildTable ( Cursor tableData ) { if ( tableData != null && tableData . getCount ( ) > 0 ) { switch ( mTableSelected ) { case IMPORTED_OCID_DATA : { BaseInflaterAdapter < CardItemData > adapter = new BaseInflaterAdapter < > ( new OpenCellIdCardInflater ( ) ) ; int count = tableData . getCount ( ) ; while ( tableData . moveToNext ( ) ) { CardItemData data = new CardItemData ( "CID: " + tableData . getString ( 0 ) , "LAC: " + tableData . getString ( 1 ) , "MCC: " + tableData . getString ( 2 ) , "MNC: " + tableData . getString ( 3 ) , "Lat: " + tableData . getString ( 4 ) , "Lon: " + tableData . getString ( 5 ) , "AvgSignal: " + tableData . getString ( 6 ) , "Samples: " + tableData . getString ( 7 ) , "" + ( tableData . getPosition ( ) + 1 ) + " / " + count ) ; adapter . addItem ( data , false ) ; } if ( ! tableData . isClosed ( ) ) { tableData . close ( ) ; } return adapter ; } case DEFAULT_MCC_LOCATIONS : { BaseInflaterAdapter < CardItemData > adapter = new BaseInflaterAdapter < > ( new DefaultLocationCardInflater ( ) ) ; int count = tableData . getCount ( ) ; while ( tableData . moveToNext ( ) ) { CardItemData data = new CardItemData ( "Country: " + tableData . getString ( 0 ) , "MCC: " + tableData . getString ( 1 ) , "Lat: " + tableData . getString ( 2 ) , "Lon: " + tableData . getString ( 3 ) , "" + ( tableData . getPosition ( ) + 1 ) + " / " + count ) ; adapter . addItem ( data , false ) ; } if ( ! tableData . isClosed ( ) ) { tableData . close ( ) ; } return adapter ; } case SILENT_SMS : { BaseInflaterAdapter < CapturedSmsData > adapter = new BaseInflaterAdapter < > ( new CapturedSmsCardInflater ( ) ) ; if ( tableData . getCount ( ) > 0 ) { while ( tableData . moveToNext ( ) ) { CapturedSmsData getdata = new CapturedSmsData ( ) ; getdata . setSmsTimestamp ( tableData . getString ( tableData . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_TIMESTAMP ) ) ) ; getdata . setSmsType ( tableData . getString ( tableData . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_SMS_TYPE ) ) ) ; getdata . setSenderNumber ( tableData . getString ( tableData . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_SENDER_NUMBER ) ) ) ; getdata . setSenderMsg ( tableData . getString ( tableData . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_SENDER_MSG ) ) ) ; getdata . setCurrent_lac ( tableData . getInt ( tableData . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_LAC ) ) ) ; getdata . setCurrent_cid ( tableData . getInt ( tableData . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_CID ) ) ) ; getdata . setCurrent_nettype ( tableData . getString ( tableData . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_NETTYPE ) ) ) ; getdata . setCurrent_roam_status ( tableData . getString ( tableData . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_ROAM_STATE ) ) ) ; getdata . setCurrent_gps_lat ( tableData . getDouble ( tableData . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_GPS_LAT ) ) ) ; getdata . setCurrent_gps_lon ( tableData . getDouble ( tableData . getColumnIndex ( SmsDetectionDbHelper . SMS_DATA_CURRENT_GPS_LON ) ) ) ; adapter . addItem ( getdata , false ) ; } } if ( ! tableData . isClosed ( ) ) { tableData . close ( ) ; } return adapter ; } case MEASURED_SIGNAL_STRENGTHS : { BaseInflaterAdapter < MeasuredCellStrengthCardData > adapter = new BaseInflaterAdapter < > ( new MeasuredCellStrengthCardInflater ( ) ) ; while ( tableData . moveToNext ( ) ) { MeasuredCellStrengthCardData data = new MeasuredCellStrengthCardData ( tableData . getInt ( 0 ) , tableData . getInt ( 1 ) , tableData . getLong ( 2 ) ) ; adapter . addItem ( data , false ) ; } if ( ! tableData . isClosed ( ) ) { tableData . close ( ) ; } return adapter ; } case EVENT_LOG : { BaseInflaterAdapter < EventLogItemData > adapter = new BaseInflaterAdapter < > ( new EventLogCardInflater ( ) ) ; int count = tableData . getCount ( ) ; while ( tableData . moveToNext ( ) ) { EventLogItemData data = new EventLogItemData ( "Time: " + tableData . getString ( 0 ) , "LAC: " + tableData . getInt ( 1 ) , "CID: " + tableData . getInt ( 2 ) , "PSC: " + tableData . getInt ( 3 ) , "Lat: " + tableData . getDouble ( 4 ) , "Lon: " + tableData . getDouble ( 5 ) , "Accuracy: " + tableData . getInt ( 6 ) , "DetID: " + tableData . getInt ( 7 ) , "Event: " + tableData . getString ( 8 ) , "" + ( tableData . getPosition ( ) + 1 ) + " / " + count ) ; data . setIsFakeData ( isExample ( data ) ) ; adapter . addItem ( data , false ) ; } if ( ! tableData . isClosed ( ) ) { tableData . close ( ) ; } return adapter ; } case DETECTION_STRINGS : { BaseInflaterAdapter < DetectionStringsData > adapter = new BaseInflaterAdapter < > ( new DetectionStringsCardInflater ( ) ) ; int count = tableData . getCount ( ) ; while ( tableData . moveToNext ( ) ) { DetectionStringsData data = new DetectionStringsData ( tableData . getString ( 0 ) , tableData . getString ( 1 ) ) ; adapter . addItem ( data , false ) ; } if ( ! tableData . isClosed ( ) ) { tableData . close ( ) ; } return adapter ; } default : BaseInflaterAdapter < CardItemData > adapter = new BaseInflaterAdapter < > ( new CellCardInflater ( ) ) ; int count = tableData . getCount ( ) ; while ( tableData . moveToNext ( ) ) { CardItemData data = new CardItemData ( "CID: " + tableData . getString ( 0 ) , "LAC: " + tableData . getString ( 1 ) , "RAT: " + tableData . getString ( 2 ) , "Lat: " + tableData . getString ( 3 ) , "Lon: " + tableData . getString ( 4 ) , "RSS: " + tableData . getString ( 5 ) , "" + ( tableData . getPosition ( ) + 1 ) + " / " + count ) ; adapter . addItem ( data , false ) ; } if ( ! tableData . isClosed ( ) ) { tableData . close ( ) ; } return adapter ; } } else { return null ; } } private boolean isExample ( EventLogItemData pEventLogItemData ) { return pEventLogItemData != null && pEventLogItemData . getLac ( ) . contains ( Examples . EVENT_LOG_DATA . LAC ) && pEventLogItemData . getCellID ( ) . contains ( Examples . EVENT_LOG_DATA . CID ) && pEventLogItemData . getPsc ( ) . contains ( Examples . EVENT_LOG_DATA . PSC ) && pEventLogItemData . getLat ( ) . contains ( Examples . EVENT_LOG_DATA . GPSD_LAT ) && pEventLogItemData . getLng ( ) . contains ( Examples . EVENT_LOG_DATA . GPSD_LON ) && pEventLogItemData . getgpsd_accu ( ) . contains ( Examples . EVENT_LOG_DATA . GPSD_ACCU ) && pEventLogItemData . getDF_id ( ) . contains ( Examples . EVENT_LOG_DATA . DF_ID ) ; } private boolean isExample ( SilentSmsCardData pSilentSmsCardData ) { return pSilentSmsCardData != null && pSilentSmsCardData . getAddress ( ) . contains ( Examples . SILENT_SMS_CARD_DATA . ADDRESS ) && pSilentSmsCardData . getDisplayAddress ( ) . contains ( Examples . SILENT_SMS_CARD_DATA . DISPLAY ) ; } }
package com . SecUpwN . AIMSICD . fragments ; import android . app . Activity ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . ServiceConnection ; import android . os . AsyncTask ; import android . os . Bundle ; import android . os . Handler ; import android . os . IBinder ; import android . support . v4 . app . Fragment ; import android . text . TextUtils ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . ListView ; import android . widget . TableRow ; import android . widget . TextView ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . adapters . BaseInflaterAdapter ; import com . SecUpwN . AIMSICD . adapters . CardItemData ; import com . SecUpwN . AIMSICD . adapters . CellCardInflater ; import com . SecUpwN . AIMSICD . rilexecutor . RilExecutor ; import com . SecUpwN . AIMSICD . service . AimsicdService ; import com . SecUpwN . AIMSICD . service . CellTracker ; import com . SecUpwN . AIMSICD . utils . Cell ; import com . SecUpwN . AIMSICD . utils . Helpers ; import java . util . List ; import java . util . concurrent . TimeUnit ; public class CellInfoFragment extends Fragment { public static final int STOCK_REQUEST = 1 ; public static final int SAMSUNG_MULTIRIL_REQUEST = 2 ; private AimsicdService mAimsicdService ; private RilExecutor rilExecutor ; private boolean mBound ; private Context mContext ; private Activity mActivity ; private final Handler timerHandler = new Handler ( ) ; private List < Cell > neighboringCells ; private ListView lv ; private TextView mNeighbouringCells ; private TextView mNeighbouringTotal ; private TableRow mNeighbouringTotalView ; private TextView mCipheringIndicatorLabel ; private TextView mCipheringIndicator ; private final Runnable timerRunnable = new Runnable ( ) { @ Override public void run ( ) { updateUI ( ) ; timerHandler . postDelayed ( this , CellTracker . REFRESH_RATE ) ; } } ; public CellInfoFragment ( ) { } @ Override public void onAttach ( Activity activity ) { super . onAttach ( activity ) ; mContext = activity . getBaseContext ( ) ; mActivity = activity ; Intent intent = new Intent ( mContext , AimsicdService . class ) ; mContext . bindService ( intent , mConnection , Context . BIND_AUTO_CREATE ) ; } @ Override public void onPause ( ) { super . onPause ( ) ; timerHandler . removeCallbacks ( timerRunnable ) ; } @ Override public void onResume ( ) { super . onResume ( ) ; if ( ! mBound ) { Intent intent = new Intent ( mContext , AimsicdService . class ) ; mContext . bindService ( intent , mConnection , Context . BIND_AUTO_CREATE ) ; } if ( CellTracker . REFRESH_RATE != 0 ) { timerHandler . postDelayed ( timerRunnable , 0 ) ; Helpers . msgShort ( mContext , mContext . getString ( R . string . refreshing_every ) + " " + TimeUnit . MILLISECONDS . toSeconds ( CellTracker . REFRESH_RATE ) + " " + mContext . getString ( R . string . seconds ) ) ; } } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . cell_fragment , container , false ) ; if ( view != null ) { lv = ( ListView ) view . findViewById ( R . id . list_view ) ; mNeighbouringCells = ( TextView ) view . findViewById ( R . id . neighbouring_cells ) ; mNeighbouringTotal = ( TextView ) view . findViewById ( R . id . neighbouring_number ) ; mNeighbouringTotalView = ( TableRow ) view . findViewById ( R . id . neighbouring_total ) ; mCipheringIndicatorLabel = ( TextView ) view . findViewById ( R . id . ciphering_indicator_title ) ; mCipheringIndicator = ( TextView ) view . findViewById ( R . id . ciphering_indicator ) ; Button refresh = ( Button ) view . findViewById ( R . id . button_refresh ) ; refresh . setOnClickListener ( new btnClick ( ) ) ; } return view ; } @ Override public void onDestroy ( ) { super . onDestroy ( ) ; if ( mBound ) { mContext . unbindService ( mConnection ) ; mBound = false ; } timerHandler . removeCallbacks ( timerRunnable ) ; } private final ServiceConnection mConnection = new ServiceConnection ( ) { @ Override public void onServiceConnected ( ComponentName name , IBinder service ) { mAimsicdService = ( ( AimsicdService . AimscidBinder ) service ) . getService ( ) ; rilExecutor = mAimsicdService . getRilExecutor ( ) ; mBound = true ; updateUI ( ) ; } @ Override public void onServiceDisconnected ( ComponentName arg0 ) { mBound = false ; } } ; private class btnClick implements View . OnClickListener { @ Override public void onClick ( View v ) { Helpers . msgShort ( mContext , mAimsicdService . getString ( R . string . refreshing_now ) ) ; updateUI ( ) ; } } @ Override public void setUserVisibleHint ( boolean isVisibleToUser ) { super . setUserVisibleHint ( isVisibleToUser ) ; if ( isVisibleToUser ) { updateUI ( ) ; } } private void updateUI ( ) { if ( mBound && rilExecutor . mMultiRilCompatible ) { new CellAsyncTask ( ) . execute ( SAMSUNG_MULTIRIL_REQUEST ) ; } else { new CellAsyncTask ( ) . execute ( STOCK_REQUEST ) ; } } void updateCipheringIndicator ( ) { final List < String > list = rilExecutor . getCipheringInfo ( ) ; mActivity . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( list != null ) { mCipheringIndicatorLabel . setVisibility ( View . VISIBLE ) ; mCipheringIndicator . setVisibility ( View . VISIBLE ) ; mCipheringIndicator . setText ( TextUtils . join ( "\n" , list ) ) ; } } } ) ; } boolean getStockNeighbouringCells ( ) { if ( mBound ) { neighboringCells = mAimsicdService . getCellTracker ( ) . updateNeighbouringCells ( ) ; return neighboringCells . size ( ) > 0 ; } return false ; } void updateStockNeighbouringCells ( ) { mNeighbouringTotal . setText ( String . valueOf ( neighboringCells . size ( ) ) ) ; if ( neighboringCells . size ( ) != 0 ) { BaseInflaterAdapter < CardItemData > adapter = new BaseInflaterAdapter < > ( new CellCardInflater ( ) ) ; int i = 1 ; int total = neighboringCells . size ( ) ; for ( Cell cell : neighboringCells ) { CardItemData data = new CardItemData ( cell , i ++ + " / " + total ) ; adapter . addItem ( data , false ) ; } lv . setAdapter ( adapter ) ; mNeighbouringCells . setVisibility ( View . GONE ) ; mNeighbouringTotalView . setVisibility ( View . VISIBLE ) ; } } void updateNeighbouringCells ( ) { final List < String > list = rilExecutor . getNeighbours ( ) ; mActivity . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( list != null ) { mNeighbouringCells . setText ( TextUtils . join ( "\n" , list ) ) ; mNeighbouringCells . setVisibility ( View . VISIBLE ) ; mNeighbouringTotalView . setVisibility ( View . GONE ) ; } } } ) ; } void getSamSungMultiRil ( ) { if ( mBound && rilExecutor . mMultiRilCompatible ) { new CellAsyncTask ( ) . execute ( SAMSUNG_MULTIRIL_REQUEST ) ; } } private class CellAsyncTask extends AsyncTask < Integer , Void , Boolean > { @ Override protected Boolean doInBackground ( Integer ... type ) { switch ( type [ 0 ] ) { case STOCK_REQUEST : return getStockNeighbouringCells ( ) ; case SAMSUNG_MULTIRIL_REQUEST : if ( mBound ) { updateNeighbouringCells ( ) ; updateCipheringIndicator ( ) ; } break ; } return false ; } @ Override protected void onPostExecute ( Boolean result ) { super . onPostExecute ( result ) ; if ( result ) { updateStockNeighbouringCells ( ) ; } else { getSamSungMultiRil ( ) ; } } } }
package com . SecUpwN . AIMSICD . fragments ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . activities . CreditsRollActivity ; import com . SecUpwN . AIMSICD . utils . MiscUtils ; import android . app . Activity ; import android . content . Context ; import android . content . Intent ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . net . Uri ; import android . os . Bundle ; import android . support . v4 . app . Fragment ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . TextView ; public class AboutFragment extends Fragment { private Context mContext ; private Button btncredits ; @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View v = inflater . inflate ( R . layout . about_fragment , container , false ) ; String version ; btncredits = ( Button ) v . findViewById ( R . id . aimsicd_credits_link ) ; PackageManager manager = mContext . getPackageManager ( ) ; try { PackageInfo info = manager != null ? manager . getPackageInfo ( mContext . getPackageName ( ) , 0 ) : null ; version = info != null ? info . versionName : "" ; } catch ( PackageManager . NameNotFoundException nnfe ) { version = "" ; } TextView versionNumber ; if ( v != null ) { versionNumber = ( TextView ) v . findViewById ( R . id . aimsicd_version ) ; versionNumber . setText ( getString ( R . string . app_version ) + version ) ; View tv = v . findViewById ( R . id . aimsicd_status_icons ) ; tv = v . findViewById ( R . id . aimsicd_wiki_link ) ; setLink ( tv , R . string . wiki_link ) ; tv = v . findViewById ( R . id . aimsicd_poc_link ) ; setLink ( tv , R . string . contribute_link ) ; tv = v . findViewById ( R . id . aimsicd_disclaimer_link ) ; setLink ( tv , R . string . disclaimer_link ) ; tv = v . findViewById ( R . id . aimsicd_contribute_link ) ; setLink ( tv , R . string . aimsicd_github_link ) ; tv = v . findViewById ( R . id . aimsicd_release_link ) ; setLink ( tv , R . string . aimsicd_release_link ) ; tv = v . findViewById ( R . id . aimsicd_changelog_link ) ; setLink ( tv , R . string . aimsicd_changelog_link ) ; tv = v . findViewById ( R . id . aimsicd_license_link ) ; setLink ( tv , R . string . aimsicd_license_link ) ; View imgView_idle = v . findViewById ( R . id . imgView_idle ) ; imgView_idle . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MiscUtils . startPopUpInfo ( mContext , 0 ) ; } } ) ; View imgView_normal = v . findViewById ( R . id . imgView_normal ) ; imgView_normal . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MiscUtils . startPopUpInfo ( mContext , 1 ) ; } } ) ; View imgView_medium = v . findViewById ( R . id . imgView_medium ) ; imgView_medium . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MiscUtils . startPopUpInfo ( mContext , 2 ) ; } } ) ; View imgView_high = v . findViewById ( R . id . imgView_high ) ; imgView_high . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MiscUtils . startPopUpInfo ( mContext , 3 ) ; } } ) ; View imgView_danger = v . findViewById ( R . id . imgView_danger ) ; imgView_danger . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MiscUtils . startPopUpInfo ( mContext , 4 ) ; } } ) ; View imgView_run = v . findViewById ( R . id . imgView_run ) ; imgView_run . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { MiscUtils . startPopUpInfo ( mContext , 5 ) ; } } ) ; } return v ; } private void setLink ( View b , final int link ) { b . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { Intent intent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( getResources ( ) . getString ( link ) ) ) ; startActivity ( intent ) ; } } ) ; btncredits . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { try { Intent i = new Intent ( mContext , CreditsRollActivity . class ) ; startActivity ( i ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; } @ Override public void onAttach ( Activity activity ) { super . onAttach ( activity ) ; mContext = activity . getBaseContext ( ) ; } public AboutFragment ( ) { } }
package com . SecUpwN . AIMSICD . activities ; import android . app . ProgressDialog ; import android . content . SharedPreferences ; import android . os . AsyncTask ; import android . os . Bundle ; import android . view . View ; import android . widget . Button ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . service . AimsicdService ; import com . SecUpwN . AIMSICD . service . CellTracker ; import com . SecUpwN . AIMSICD . utils . Helpers ; public class OpenCellIdActivity extends BaseActivity { Button btnOk ; Button btnCancel ; private SharedPreferences prefs ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_open_cell_id ) ; prefs = getSharedPreferences ( AimsicdService . SHARED_PREFERENCES_BASENAME , 0 ) ; btnOk = ( Button ) findViewById ( R . id . btnOk ) ; btnCancel = ( Button ) findViewById ( R . id . btnCancel ) ; btnCancel . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { finish ( ) ; } } ) ; final ProgressDialog pd = new ProgressDialog ( this ) ; pd . setMessage ( getString ( R . string . getting_ocid_api_key ) ) ; btnOk . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { new AsyncTask < Void , Void , String > ( ) { @ Override protected void onPreExecute ( ) { pd . show ( ) ; } @ Override protected String doInBackground ( Void ... voids ) { try { return CellTracker . requestNewOCIDKey ( ) ; } catch ( final Exception e ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { pd . dismiss ( ) ; Helpers . msgLong ( OpenCellIdActivity . this , getString ( R . string . ocid_api_error ) + e . getClass ( ) . getName ( ) + " - " + e . getMessage ( ) ) ; } } ) ; return null ; } } @ Override protected void onPostExecute ( String s ) { if ( s == null ) return ; final String OCID_KEY = getString ( R . string . pref_ocid_key ) ; prefs . edit ( ) . putString ( OCID_KEY , s ) . commit ( ) ; CellTracker . OCID_API_KEY = s ; Helpers . msgShort ( OpenCellIdActivity . this , getString ( R . string . ocid_api_success ) ) ; pd . dismiss ( ) ; finish ( ) ; } } . execute ( ) ; } } ) ; } }
package com . SecUpwN . AIMSICD . activities ; import com . SecUpwN . AIMSICD . fragments . PrefFragment ; import android . app . FragmentManager ; import android . app . FragmentTransaction ; import android . os . Bundle ; public class PrefActivity extends BaseActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; loadFragment ( ) ; } @ Override protected void onRestart ( ) { super . onRestart ( ) ; loadFragment ( ) ; } private void loadFragment ( ) { PrefFragment settingsFragment = new PrefFragment ( ) ; FragmentManager fragmentManager = getFragmentManager ( ) ; FragmentTransaction fragmentTransaction = fragmentManager . beginTransaction ( ) ; fragmentTransaction . replace ( android . R . id . content , settingsFragment ) ; fragmentTransaction . commit ( ) ; } }
package com . SecUpwN . AIMSICD . activities ; import android . content . BroadcastReceiver ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . ServiceConnection ; import android . content . SharedPreferences ; import android . content . SharedPreferences . OnSharedPreferenceChangeListener ; import android . database . Cursor ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . os . AsyncTask ; import android . os . Bundle ; import android . os . IBinder ; import android . support . v4 . content . LocalBroadcastManager ; import android . telephony . CellInfo ; import android . telephony . PhoneStateListener ; import android . telephony . ServiceState ; import android . telephony . TelephonyManager ; import android . util . Log ; import android . view . Menu ; import android . view . MenuInflater ; import android . view . MenuItem ; import com . SecUpwN . AIMSICD . AppAIMSICD ; import com . SecUpwN . AIMSICD . BuildConfig ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . adapters . AIMSICDDbAdapter ; import com . SecUpwN . AIMSICD . constants . TinyDbKeys ; import com . SecUpwN . AIMSICD . map . CellTowerGridMarkerClusterer ; import com . SecUpwN . AIMSICD . map . CellTowerMarker ; import com . SecUpwN . AIMSICD . map . MarkerData ; import com . SecUpwN . AIMSICD . service . AimsicdService ; import com . SecUpwN . AIMSICD . utils . Cell ; import com . SecUpwN . AIMSICD . utils . GeoLocation ; import com . SecUpwN . AIMSICD . utils . Helpers ; import com . SecUpwN . AIMSICD . utils . RequestTask ; import com . SecUpwN . AIMSICD . utils . TinyDB ; import org . osmdroid . tileprovider . tilesource . TileSourceFactory ; import org . osmdroid . util . GeoPoint ; import org . osmdroid . views . MapView ; import org . osmdroid . views . overlay . ScaleBarOverlay ; import org . osmdroid . views . overlay . compass . CompassOverlay ; import org . osmdroid . views . overlay . compass . InternalCompassOrientationProvider ; import org . osmdroid . views . overlay . mylocation . GpsMyLocationProvider ; import org . osmdroid . views . overlay . mylocation . MyLocationNewOverlay ; import java . util . LinkedList ; import java . util . List ; public class MapViewerOsmDroid extends BaseActivity implements OnSharedPreferenceChangeListener { private final String TAG = "AIMSICD_MapViewer" ; public static final String updateOpenCellIDMarkers = "update_opencell_markers" ; private MapView mMap ; private AIMSICDDbAdapter mDbHelper ; private Context mContext ; private SharedPreferences prefs ; private AimsicdService mAimsicdService ; private boolean mBound ; private GeoPoint loc = null ; private MyLocationNewOverlay mMyLocationOverlay ; private CompassOverlay mCompassOverlay ; private ScaleBarOverlay mScaleBarOverlay ; private CellTowerGridMarkerClusterer mCellTowerGridMarkerClusterer ; private Menu mOptionsMenu ; private PhoneStateListener mPhoneStateListener = new PhoneStateListener ( ) { @ Override public void onServiceStateChanged ( ServiceState serviceState ) { loadEntries ( ) ; } @ Override public void onCellInfoChanged ( List < CellInfo > cellInfo ) { loadEntries ( ) ; } } ; @ Override public void onCreate ( Bundle savedInstanceState ) { Log . i ( TAG , "Starting MapViewer" ) ; super . onCreate ( savedInstanceState ) ; mContext = this ; setContentView ( R . layout . map ) ; setUpMapIfNeeded ( ) ; mDbHelper = new AIMSICDDbAdapter ( mContext ) ; Intent intent = new Intent ( mContext , AimsicdService . class ) ; mContext . bindService ( intent , mConnection , Context . BIND_AUTO_CREATE ) ; TelephonyManager tm = ( TelephonyManager ) mContext . getSystemService ( Context . TELEPHONY_SERVICE ) ; tm . listen ( mPhoneStateListener , PhoneStateListener . LISTEN_CELL_LOCATION | PhoneStateListener . LISTEN_DATA_CONNECTION_STATE ) ; } @ Override public void onResume ( ) { super . onResume ( ) ; setUpMapIfNeeded ( ) ; prefs = this . getSharedPreferences ( AimsicdService . SHARED_PREFERENCES_BASENAME , 0 ) ; prefs . registerOnSharedPreferenceChangeListener ( this ) ; LocalBroadcastManager . getInstance ( this ) . registerReceiver ( mMessageReceiver , new IntentFilter ( updateOpenCellIDMarkers ) ) ; if ( ! mBound ) { Intent intent = new Intent ( mContext , AimsicdService . class ) ; mContext . bindService ( intent , mConnection , Context . BIND_AUTO_CREATE ) ; } loadPreferences ( ) ; loadEntries ( ) ; if ( mCompassOverlay != null ) { mCompassOverlay . enableCompass ( ) ; } if ( mMyLocationOverlay != null ) { mMyLocationOverlay . enableMyLocation ( ) ; } } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; prefs . unregisterOnSharedPreferenceChangeListener ( this ) ; if ( mBound ) { mContext . unbindService ( mConnection ) ; mBound = false ; } TelephonyManager tm = ( TelephonyManager ) mContext . getSystemService ( Context . TELEPHONY_SERVICE ) ; tm . listen ( mPhoneStateListener , PhoneStateListener . LISTEN_NONE ) ; LocalBroadcastManager . getInstance ( this ) . unregisterReceiver ( mMessageReceiver ) ; } @ Override protected void onPause ( ) { super . onPause ( ) ; LocalBroadcastManager . getInstance ( this ) . unregisterReceiver ( mMessageReceiver ) ; if ( mCompassOverlay != null ) { mCompassOverlay . disableCompass ( ) ; } if ( mMyLocationOverlay != null ) { mMyLocationOverlay . disableMyLocation ( ) ; } } private final BroadcastReceiver mMessageReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { loadEntries ( ) ; if ( BuildConfig . DEBUG && mCellTowerGridMarkerClusterer != null && mCellTowerGridMarkerClusterer . getItems ( ) != null ) { Log . v ( TAG , "mMessageReceiver CellTowerMarkers.invalidate() markers.size():" + mCellTowerGridMarkerClusterer . getItems ( ) . size ( ) ) ; } } } ; private final ServiceConnection mConnection = new ServiceConnection ( ) { @ Override public void onServiceConnected ( ComponentName name , IBinder service ) { mAimsicdService = ( ( AimsicdService . AimscidBinder ) service ) . getService ( ) ; mBound = true ; GeoLocation lastKnown = mAimsicdService . lastKnownLocation ( ) ; if ( lastKnown != null ) { mMap . getController ( ) . setZoom ( 16 ) ; mMap . getController ( ) . animateTo ( new GeoPoint ( lastKnown . getLatitudeInDegrees ( ) , lastKnown . getLongitudeInDegrees ( ) ) ) ; } } @ Override public void onServiceDisconnected ( ComponentName arg0 ) { Log . e ( TAG , "Service Disconnected" ) ; mBound = false ; } } ; private void loadPreferences ( ) { String mapTypePref = getResources ( ) . getString ( R . string . pref_map_type_key ) ; prefs = mContext . getSharedPreferences ( AimsicdService . SHARED_PREFERENCES_BASENAME , 0 ) ; if ( prefs . contains ( mapTypePref ) ) { int mapType = Integer . parseInt ( prefs . getString ( mapTypePref , "0" ) ) ; setupMapType ( mapType ) ; } } private void setupMapType ( int mapType ) { mMap . setTileSource ( TileSourceFactory . DEFAULT_TILE_SOURCE ) ; switch ( mapType ) { case 0 : mMap . setTileSource ( TileSourceFactory . DEFAULT_TILE_SOURCE ) ; break ; case 1 : mMap . setTileSource ( TileSourceFactory . CYCLEMAP ) ; break ; default : mMap . setTileSource ( TileSourceFactory . DEFAULT_TILE_SOURCE ) ; break ; } } private void setUpMapIfNeeded ( ) { if ( mMap == null ) { mMap = ( MapView ) findViewById ( R . id . mapview ) ; if ( mMap != null ) { mMap . setBuiltInZoomControls ( true ) ; mMap . setMultiTouchControls ( true ) ; mMap . setMinZoomLevel ( 3 ) ; mMap . setMaxZoomLevel ( 19 ) ; mMap . getTileProvider ( ) . createTileCache ( ) ; mCompassOverlay = new CompassOverlay ( this , new InternalCompassOrientationProvider ( this ) , mMap ) ; mScaleBarOverlay = new ScaleBarOverlay ( this ) ; mScaleBarOverlay . setScaleBarOffset ( getResources ( ) . getDisplayMetrics ( ) . widthPixels / 2 , 10 ) ; mScaleBarOverlay . setCentred ( true ) ; mCellTowerGridMarkerClusterer = new CellTowerGridMarkerClusterer ( MapViewerOsmDroid . this ) ; mCellTowerGridMarkerClusterer . setIcon ( ( ( BitmapDrawable ) mContext . getResources ( ) . getDrawable ( R . drawable . ic_map_pin_orange ) ) . getBitmap ( ) ) ; GpsMyLocationProvider imlp = new GpsMyLocationProvider ( MapViewerOsmDroid . this . getBaseContext ( ) ) ; imlp . setLocationUpdateMinDistance ( 100 ) ; imlp . setLocationUpdateMinTime ( 10000 ) ; mMyLocationOverlay = new MyLocationNewOverlay ( MapViewerOsmDroid . this . getBaseContext ( ) , imlp , mMap ) ; mMyLocationOverlay . setDrawAccuracyEnabled ( true ) ; mMap . getOverlays ( ) . add ( mCellTowerGridMarkerClusterer ) ; mMap . getOverlays ( ) . add ( mMyLocationOverlay ) ; mMap . getOverlays ( ) . add ( mCompassOverlay ) ; mMap . getOverlays ( ) . add ( mScaleBarOverlay ) ; } else { Helpers . msgShort ( this , getString ( R . string . unable_to_create_map ) ) ; } } } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { this . mOptionsMenu = menu ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . map_viewer_menu , menu ) ; return super . onCreateOptionsMenu ( menu ) ; } @ Override public boolean onPrepareOptionsMenu ( Menu menu ) { return super . onCreateOptionsMenu ( menu ) ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case R . id . map_preferences : Intent intent = new Intent ( this , MapPrefActivity . class ) ; startActivity ( intent ) ; return true ; case R . id . get_opencellid : { if ( mBound ) { GeoLocation lastKnown = mAimsicdService . lastKnownLocation ( ) ; if ( lastKnown != null ) { Helpers . msgLong ( mContext , getString ( R . string . contacting_opencellid_for_data ) ) ; Cell cell ; cell = mAimsicdService . getCell ( ) ; cell . setLon ( lastKnown . getLongitudeInDegrees ( ) ) ; cell . setLat ( lastKnown . getLatitudeInDegrees ( ) ) ; setRefreshActionButtonState ( true ) ; TinyDB . getInstance ( ) . putBoolean ( TinyDbKeys . FINISHED_LOAD_IN_MAP , false ) ; Helpers . getOpenCellData ( mContext , cell , RequestTask . DBE_DOWNLOAD_REQUEST_FROM_MAP ) ; return true ; } } if ( loc != null ) { Helpers . msgLong ( this , getString ( R . string . contacting_opencellid_for_data ) ) ; Cell cell = new Cell ( ) ; cell . setLat ( loc . getLatitude ( ) ) ; cell . setLon ( loc . getLongitude ( ) ) ; setRefreshActionButtonState ( true ) ; TinyDB . getInstance ( ) . putBoolean ( TinyDbKeys . FINISHED_LOAD_IN_MAP , false ) ; Helpers . getOpenCellData ( mContext , cell , RequestTask . DBE_DOWNLOAD_REQUEST_FROM_MAP ) ; } else { Helpers . msgLong ( mContext , getString ( R . string . unable_to_determine_last_location ) ) ; } return true ; } default : return super . onOptionsItemSelected ( item ) ; } } private void loadEntries ( ) { new AsyncTask < Void , Void , GeoPoint > ( ) { @ Override protected GeoPoint doInBackground ( Void ... voids ) { final int SIGNAL_SIZE_RATIO = 15 ; int signal ; mCellTowerGridMarkerClusterer . getItems ( ) . clear ( ) ; loadOpenCellIDMarkers ( ) ; LinkedList < CellTowerMarker > items = new LinkedList < > ( ) ; mDbHelper . open ( ) ; Cursor c = null ; try { c = mDbHelper . getCellData ( ) ; } catch ( IllegalStateException ix ) { Log . e ( TAG , ix . getMessage ( ) , ix ) ; } if ( c != null && c . moveToFirst ( ) ) { do { final int cellID = c . getInt ( 0 ) ; final int lac = c . getInt ( 1 ) ; final int net = c . getInt ( 2 ) ; final int mcc = c . getInt ( 6 ) ; final int mnc = c . getInt ( 7 ) ; final double dlat = Double . parseDouble ( c . getString ( 3 ) ) ; final double dlng = Double . parseDouble ( c . getString ( 4 ) ) ; if ( dlat == 0.0 && dlng == 0.0 ) { continue ; } signal = c . getInt ( 5 ) ; if ( signal <= 0 ) { signal = 20 ; } if ( ( dlat != 0.0 ) || ( dlng != 0.0 ) ) { loc = new GeoPoint ( dlat , dlng ) ; CellTowerMarker ovm = new CellTowerMarker ( mContext , mMap , "Cell ID: " + cellID , "" , loc , new MarkerData ( "" + cellID , "" + loc . getLatitude ( ) , "" + loc . getLongitude ( ) , "" + lac , "" + mcc , "" + mnc , "" , false ) ) ; ovm . setIcon ( getResources ( ) . getDrawable ( R . drawable . ic_map_pin_blue ) ) ; items . add ( ovm ) ; } } while ( c . moveToNext ( ) ) ; } else { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { Helpers . msgLong ( MapViewerOsmDroid . this , getString ( R . string . no_tracked_locations_found ) ) ; } } ) ; } GeoPoint ret = new GeoPoint ( 0 , 0 ) ; if ( mBound ) { try { int mcc = mAimsicdService . getCell ( ) . getMCC ( ) ; double [ ] d = mDbHelper . getDefaultLocation ( mcc ) ; ret = new GeoPoint ( d [ 0 ] , d [ 1 ] ) ; } catch ( Exception e ) { Log . e ( "map" , "Error getting default location!" , e ) ; } } if ( c != null ) { c . close ( ) ; } mDbHelper . close ( ) ; while ( mAimsicdService == null ) try { Thread . sleep ( 100 ) ; } catch ( Exception e ) { } List < Cell > nc = mAimsicdService . getCellTracker ( ) . updateNeighbouringCells ( ) ; for ( Cell cell : nc ) { try { loc = new GeoPoint ( cell . getLat ( ) , cell . getLon ( ) ) ; CellTowerMarker ovm = new CellTowerMarker ( mContext , mMap , getString ( R . string . cell_id_label ) + cell . getCID ( ) , "" , loc , new MarkerData ( "" + cell . getCID ( ) , "" + loc . getLatitude ( ) , "" + loc . getLongitude ( ) , "" + cell . getLAC ( ) , "" + cell . getMCC ( ) , "" + cell . getMNC ( ) , "" , false ) ) ; ovm . setIcon ( getResources ( ) . getDrawable ( R . drawable . ic_map_pin_orange ) ) ; items . add ( ovm ) ; } catch ( Exception e ) { Log . e ( "map" , "Error plotting neighbouring cells" , e ) ; } } mCellTowerGridMarkerClusterer . addAll ( items ) ; return ret ; } @ Override protected void onPostExecute ( GeoPoint defaultLoc ) { if ( loc != null && ( loc . getLatitude ( ) != 0.0 && loc . getLongitude ( ) != 0.0 ) ) { mMap . getController ( ) . setZoom ( 16 ) ; mMap . getController ( ) . animateTo ( new GeoPoint ( loc . getLatitude ( ) , loc . getLongitude ( ) ) ) ; } else { if ( mBound ) { GeoLocation lastLoc = mAimsicdService . lastKnownLocation ( ) ; if ( lastLoc != null ) { loc = new GeoPoint ( lastLoc . getLatitudeInDegrees ( ) , lastLoc . getLongitudeInDegrees ( ) ) ; mMap . getController ( ) . setZoom ( 16 ) ; mMap . getController ( ) . animateTo ( new GeoPoint ( loc . getLatitude ( ) , loc . getLongitude ( ) ) ) ; } else { loc = defaultLoc ; mMap . getController ( ) . setZoom ( 12 ) ; mMap . getController ( ) . animateTo ( new GeoPoint ( loc . getLatitude ( ) , loc . getLongitude ( ) ) ) ; } } } if ( mCellTowerGridMarkerClusterer != null ) { if ( BuildConfig . DEBUG && mCellTowerGridMarkerClusterer . getItems ( ) != null ) { Log . v ( TAG , "CellTowerMarkers.invalidate() markers.size():" + mCellTowerGridMarkerClusterer . getItems ( ) . size ( ) ) ; } mCellTowerGridMarkerClusterer . invalidate ( ) ; } } } . executeOnExecutor ( AsyncTask . THREAD_POOL_EXECUTOR ) ; } private void loadOpenCellIDMarkers ( ) { LinkedList < CellTowerMarker > items = new LinkedList < > ( ) ; Drawable cellTowerMarkerIcon = getResources ( ) . getDrawable ( R . drawable . ic_map_pin_green ) ; mDbHelper . open ( ) ; Cursor c = mDbHelper . getOpenCellIDData ( ) ; if ( c . moveToFirst ( ) ) { do { final int cellID = c . getInt ( 0 ) ; final int lac = c . getInt ( 1 ) ; final int mcc = c . getInt ( 2 ) ; final int mnc = c . getInt ( 3 ) ; final double dlat = Double . parseDouble ( c . getString ( 4 ) ) ; final double dlng = Double . parseDouble ( c . getString ( 5 ) ) ; final GeoPoint location = new GeoPoint ( dlat , dlng ) ; final int samples = c . getInt ( 7 ) ; CellTowerMarker ovm = new CellTowerMarker ( mContext , mMap , "Cell ID: " + cellID , "" , location , new MarkerData ( "" + cellID , "" + location . getLatitude ( ) , "" + location . getLongitude ( ) , "" + lac , "" + mcc , "" + mnc , "" + samples , false ) ) ; ovm . setIcon ( cellTowerMarkerIcon ) ; items . add ( ovm ) ; } while ( c . moveToNext ( ) ) ; } c . close ( ) ; mDbHelper . close ( ) ; mCellTowerGridMarkerClusterer . addAll ( items ) ; } public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , String key ) { final String KEY_MAP_TYPE = getBaseContext ( ) . getString ( R . string . pref_map_type_key ) ; if ( key . equals ( KEY_MAP_TYPE ) ) { int item = Integer . parseInt ( sharedPreferences . getString ( key , "0" ) ) ; setupMapType ( item ) ; } } public void setRefreshActionButtonState ( final boolean refreshing ) { if ( mOptionsMenu != null ) { final MenuItem refreshItem = mOptionsMenu . findItem ( R . id . get_opencellid ) ; if ( refreshItem != null ) { if ( refreshing ) { refreshItem . setActionView ( R . layout . actionbar_indeterminate_progress ) ; } else { refreshItem . setActionView ( null ) ; } } } } public void onStop ( ) { super . onStop ( ) ; ( ( AppAIMSICD ) getApplication ( ) ) . detach ( this ) ; } @ Override public void onStart ( ) { super . onStart ( ) ; ( ( AppAIMSICD ) getApplication ( ) ) . attach ( this ) ; if ( TinyDB . getInstance ( ) . getBoolean ( TinyDbKeys . FINISHED_LOAD_IN_MAP ) ) { setRefreshActionButtonState ( false ) ; } } }
package com . SecUpwN . AIMSICD . activities ; import android . app . Activity ; import android . os . Bundle ; import android . view . View ; import android . view . animation . LinearInterpolator ; import android . widget . SeekBar ; import android . widget . Toast ; import com . SecUpwN . AIMSICD . R ; import com . SecUpwN . AIMSICD . fragments . CreditsRollView ; import com . SecUpwN . AIMSICD . utils . MiscUtils ; import com . nineoldandroids . animation . Animator ; import com . nineoldandroids . animation . ObjectAnimator ; import com . nineoldandroids . animation . ValueAnimator ; public class CreditsRollActivity extends Activity implements SeekBar . OnSeekBarChangeListener { private static final float SCROLL_ANIM_DURATION = 20000 ; private CreditsRollView mCreditsRollView ; private boolean mScrolling ; private SeekBar mSeekBar ; private ValueAnimator mScrollAnimator ; protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . creditroll ) ; mSeekBar = ( SeekBar ) findViewById ( R . id . seekbar ) ; mSeekBar . setOnSeekBarChangeListener ( this ) ; mCreditsRollView = ( CreditsRollView ) findViewById ( R . id . creditsroll ) ; mCreditsRollView . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( ! mScrolling ) { mCreditsRollView . setText ( MiscUtils . setAssetsString ( getApplicationContext ( ) ) ) ; animateScroll ( ) ; } else { stopScrollAnimation ( ) ; } } } ) ; if ( ! mScrolling ) { mCreditsRollView . setText ( MiscUtils . setAssetsString ( getApplicationContext ( ) ) ) ; animateScroll ( ) ; } } @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { mCreditsRollView . setScrollPosition ( progress / 100000f ) ; } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { if ( mScrolling ) { stopScrollAnimation ( ) ; } } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { } private void animateScroll ( ) { mScrolling = true ; mScrollAnimator = ObjectAnimator . ofInt ( mSeekBar , "progress" , mSeekBar . getProgress ( ) , mSeekBar . getMax ( ) ) ; mScrollAnimator . setDuration ( ( long ) ( SCROLL_ANIM_DURATION * ( 4 - ( float ) mSeekBar . getProgress ( ) / mSeekBar . getMax ( ) ) ) ) ; mScrollAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mScrollAnimator . addListener ( new Animator . AnimatorListener ( ) { @ Override public void onAnimationStart ( Animator animation ) { } @ Override public void onAnimationEnd ( Animator animation ) { mScrolling = false ; } @ Override public void onAnimationCancel ( Animator animation ) { } @ Override public void onAnimationRepeat ( Animator animation ) { } } ) ; mScrollAnimator . start ( ) ; } private void stopScrollAnimation ( ) { if ( mScrollAnimator != null ) { mScrollAnimator . cancel ( ) ; mScrollAnimator = null ; } } }
package com . SecUpwN . AIMSICD . test ; import android . test . ActivityInstrumentationTestCase2 ; import com . SecUpwN . AIMSICD . AIMSICD ; public class DummyTest extends ActivityInstrumentationTestCase2 < AIMSICD > { public DummyTest ( ) { super ( AIMSICD . class ) ; } public void testProgressBar ( ) { try { getActivity ( ) . showProgressbar ( true , 100 , 0 ) ; Thread . sleep ( 5000 ) ; getActivity ( ) . showProgressbar ( false , 100 , 30 ) ; Thread . sleep ( 1000 ) ; getActivity ( ) . showProgressbar ( false , 100 , 50 ) ; Thread . sleep ( 1000 ) ; getActivity ( ) . showProgressbar ( false , 100 , 80 ) ; Thread . sleep ( 1000 ) ; getActivity ( ) . hideProgressbar ( ) ; } catch ( InterruptedException e ) { } assertTrue ( true ) ; } }
